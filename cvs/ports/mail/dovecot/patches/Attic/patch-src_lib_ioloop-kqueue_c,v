head	1.8;
access;
symbols;
locks; strict;
comment	@# @;


1.8
date	2006.05.12.19.10.11;	author brad;	state dead;
branches;
next	1.7;

1.7
date	2006.05.10.19.51.03;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.10.00.30.04;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.02.18.45.01;	author brad;	state dead;
branches;
next	1.4;

1.4
date	2006.03.23.05.24.24;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.09.05.17.15;	author brad;	state dead;
branches;
next	1.2;

1.2
date	2006.01.23.20.33.40;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.22.15.35.43;	author brad;	state Exp;
branches;
next	;


desc
@@


1.8
log
@upgrade to Dovecot 1.0beta8
@
text
@$OpenBSD: patch-src_lib_ioloop-kqueue_c,v 1.7 2006/05/10 19:51:03 brad Exp $
--- src/lib/ioloop-kqueue.c.orig	Sat Mar 25 03:07:39 2006
+++ src/lib/ioloop-kqueue.c	Wed May 10 14:58:44 2006
@@@@ -74,7 +74,7 @@@@ void io_loop_handle_add(struct ioloop *i
 {
 	struct ioloop_handler_context *ctx = ioloop->handler_context;
 	const int fd = io->fd;
-	struct kevent ev = { fd, 0, EV_ADD | EV_EOF, 0, 0, NULL };
+	struct kevent ev = { fd, 0, EV_ADD, 0, 0, NULL };
 	enum io_condition condition = io->condition & MASK;
 	
 	i_assert(io->callback != NULL);
@@@@ -101,6 +101,8 @@@@ void io_loop_handle_add(struct ioloop *i
 	if (condition & (IO_READ | IO_ERROR)) {
 		ctx->fds[fd].mode |= condition;
 		ev.filter = EVFILT_READ;
+		if (!(condition & ~IO_ERROR))
+			ev.flags |= EV_CLEAR;
 		if (kevent(ctx->kq, &ev, 1, NULL, 0, NULL) < 0) {
 			i_error("kevent(%d) in io_loop_handle_add() failed: %m",
 				fd);
@@@@ -109,6 +111,8 @@@@ void io_loop_handle_add(struct ioloop *i
 	if (condition & (IO_WRITE | IO_ERROR)) {
 		ctx->fds[fd].mode |= condition;
 		ev.filter = EVFILT_WRITE;
+		if (!(condition & ~IO_ERROR))
+			ev.flags |= EV_CLEAR;
 		if (kevent(ctx->kq, &ev, 1, NULL, 0, NULL) < 0) {
 			i_error("kevent(%d) in io_loop_handle_add() failed: %m",
 				fd);
@@@@ -184,7 +188,7 @@@@ void io_loop_handler_run(struct ioloop *
 
 		i_assert(ctx->evbuf[i].ident < ctx->fds_size);
 		if ((ctx->fds[ctx->evbuf[i].ident].mode & IO_ERROR) &&
-		    (ctx->evbuf[i].flags & EV_EOF)) {
+		    (ctx->evbuf[i].flags & (EV_EOF | EV_ERROR))) {
 			struct io *errio = ctx->fds[ctx->evbuf[i].ident].errio;
 
 			t_id = t_push();
@@@@ -203,14 +207,22 @@@@ void io_loop_handler_run(struct ioloop *
 					" in I/O handler %p",
 					(void *)io->callback);
 			}
+		} else if (ctx->fds[ctx->evbuf[i].ident].mode & IO_ERROR) {
+			/* 
+			   NO-OP. If the handle is registered only for 
+			   IO_ERROR, then we can get readable/writable event
+			   but no IO_READ | IO_WRITE set.
+			 */
 		} else
 			i_panic("Unrecognized event: kevent {.ident =  %u,"
                                 " .filter = 0x%04x,"
                                 " .flags = 0x%04x,"
                                 " .fflags = 0x%08x,"
-                                " .data = 0x%08x}", ctx->evbuf[i].ident,
+                                " .data = 0x%08x}\n"
+				"mode: 0x%x04x", ctx->evbuf[i].ident,
                                 ctx->evbuf[i].filter, ctx->evbuf[i].flags,
-                                ctx->evbuf[i].fflags, ctx->evbuf[i].data);
+                                ctx->evbuf[i].fflags, ctx->evbuf[i].data,
+				ctx->fds[ctx->evbuf[i].ident].mode);
 	}
 }
 
@


1.7
log
@second revision of the kqueue diff that should resolve an issue with
Dovecot imap processes' spinning and taking up all the available CPU time.

From Vaclav Haisman on the Dovecot list.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_lib_ioloop-kqueue_c,v 1.6 2006/05/10 00:30:04 brad Exp $
@


1.6
log
@add a diff to fix the crashing issues exhibited when using kqueue() and
re-enable kqueue().

From Vaclav Haisman on the Dovecot list.
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ src/lib/ioloop-kqueue.c	Tue May  9 15:57:02 2006
d13 19
a31 1
@@@@ -184,7 +184,7 @@@@ void io_loop_handler_run(struct ioloop *
d40 1
a40 1
@@@@ -203,14 +203,22 @@@@ void io_loop_handler_run(struct ioloop *
@


1.5
log
@upgrade to Dovecot 1.0beta4
@
text
@d1 23
a23 4
$OpenBSD: patch-src_lib_ioloop-kqueue_c,v 1.4 2006/03/23 05:24:24 brad Exp $
--- src/lib/ioloop-kqueue.c.orig	Wed Mar 22 21:58:32 2006
+++ src/lib/ioloop-kqueue.c	Wed Mar 22 22:01:34 2006
@@@@ -204,7 +204,13 @@@@ void io_loop_handler_run(struct ioloop *
d26 6
d33 11
a43 8
-			i_panic("Unrecognized event");
+			i_panic("Unrecognized event: kevent {.ident =  %u,"
+				" .filter = 0x%04x,"
+				" .flags = 0x%04x,"
+				" .fflags = 0x%08x,"
+				" .data = 0x%08x}", ctx->evbuf[i].ident,
+				ctx->evbuf[i].filter, ctx->evbuf[i].flags,
+				ctx->evbuf[i].fflags, ctx->evbuf[i].data);
@


1.4
log
@for some fairly rare unrecognized events print some additional info
when i_panic() is called to help with debugging.

From Vaclav Haisman on the Dovecot list.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3
log
@upgrade to Dovecot 1.0beta3
@
text
@d1 4
a4 298
$OpenBSD: patch-src_lib_ioloop-kqueue_c,v 1.2 2006/01/23 20:33:40 brad Exp $
--- src/lib/ioloop-kqueue.c.orig	Fri Dec 30 15:46:28 2005
+++ src/lib/ioloop-kqueue.c	Mon Jan 23 15:11:11 2006
@@@@ -12,11 +12,13 @@@@
 /* @@UNSAFE: whole file */
 
 #include "lib.h"
-#include "ioloop-internal.h"
 
 #ifdef IOLOOP_KQUEUE
 
+#include "fd-close-on-exec.h"
+#include "ioloop-internal.h"
 #include <unistd.h>
+#include <fcntl.h>
 #include <sys/types.h>
 #include <sys/event.h>
 #include <sys/time.h>
@@@@ -28,166 +30,181 @@@@
 #define MASK (IO_READ | IO_WRITE | IO_ERROR)
 
 struct ioloop_handler_context {
-        int kq;
-        size_t evbuf_size;
-        struct kevent *evbuf;
+	int kq;
+	size_t evbuf_size;
+	struct kevent *evbuf;
 
-        size_t fds_size;
-        struct fdrecord *fds;
+	size_t fds_size;
+	struct fdrecord *fds;
 };
 
 struct fdrecord {
-        struct io *errio;
-        enum io_condition mode;
+	struct io *errio;
+	enum io_condition mode;
 };
 
 void io_loop_handler_init(struct ioloop *ioloop)
 {
-        struct ioloop_handler_context *ctx;
+	struct ioloop_handler_context *ctx;
 
-        ioloop->handler_context = ctx =
-                p_new(ioloop->pool, struct ioloop_handler_context, 1);
+	ioloop->handler_context = ctx =
+		p_new(ioloop->pool, struct ioloop_handler_context, 1);
 
 	ctx->evbuf_size = INITIAL_BUF_SIZE;
-        ctx->evbuf = p_new(ioloop->pool, struct kevent, ctx->evbuf_size);
-        ctx->kq = kqueue();
-        if (ctx->kq < 0)
-                i_fatal("kqueue(): %m");
+	ctx->evbuf = p_new(ioloop->pool, struct kevent, ctx->evbuf_size);
+	ctx->kq = kqueue();
+	if (ctx->kq < 0)
+		i_fatal("kqueue() for io_loop_handler_init() failed : %m");
+	fd_close_on_exec(ctx->kq, TRUE);
 
-        ctx->fds_size = INITIAL_BUF_SIZE;
-        ctx->fds = p_new(ioloop->pool, struct fdrecord, ctx->fds_size);
+	ctx->fds_size = INITIAL_BUF_SIZE;
+	ctx->fds = p_new(ioloop->pool, struct fdrecord, ctx->fds_size);
 }
 
 void io_loop_handler_deinit(struct ioloop *ioloop)
 {
 	if (close(ioloop->handler_context->kq) < 0)
-		i_error("close(kqueue) failed: %m");
-        p_free(ioloop->pool, ioloop->handler_context->evbuf);
-        p_free(ioloop->pool, ioloop->handler_context->fds);
-        p_free(ioloop->pool, ioloop->handler_context);
+		i_error("close(kqueue) for io_loop_handler_deinit() failed: %m");
+	p_free(ioloop->pool, ioloop->handler_context->evbuf);
+	p_free(ioloop->pool, ioloop->handler_context->fds);
+	p_free(ioloop->pool, ioloop->handler_context);
 }
 
 void io_loop_handle_add(struct ioloop *ioloop, struct io *io)
 {
-        struct ioloop_handler_context *ctx = ioloop->handler_context;
-        const int fd = io->fd;
-        struct kevent ev = { fd, 0, EV_ADD | EV_EOF, 0, 0, NULL };
-        enum io_condition condition = io->condition & MASK;
+	struct ioloop_handler_context *ctx = ioloop->handler_context;
+	const int fd = io->fd;
+	struct kevent ev = { fd, 0, EV_ADD | EV_EOF, 0, 0, NULL };
+	enum io_condition condition = io->condition & MASK;
+	
+	i_assert(io->callback);
+	/* grow ctx->fds array if necessary */
+	if ((size_t)fd >= ctx->fds_size) {
+		size_t old_size = ctx->fds_size;
 
-        /* grow ctx->fds array if necessary */
-        if ((size_t)fd >= ctx->fds_size) {
-                size_t old_size = ctx->fds_size;
+		ctx->fds_size = nearest_power((unsigned int)fd+1);
+		i_assert(ctx->fds_size < (size_t)-1 / sizeof(int));
 
-                ctx->fds_size = nearest_power((unsigned int)fd+1);
-                i_assert(ctx->fds_size < (size_t)-1 / sizeof(int));
+		ctx->fds = p_realloc(ioloop->pool, ctx->fds,
+				     sizeof(struct fdrecord) * old_size,
+				     sizeof(struct fdrecord) * ctx->fds_size);
+		memset(ctx->fds + old_size, 0,
+		       sizeof(struct fdrecord) * (ctx->fds_size - old_size));
+	}
 
-                ctx->fds = p_realloc(ioloop->pool, ctx->fds,
-                                     sizeof(struct fdrecord) * old_size,
-                                     sizeof(struct fdrecord) * ctx->fds_size);
-                memset(ctx->fds + old_size, 0,
-                       sizeof(struct fdrecord) * (ctx->fds_size - old_size));
-        }
+	if (condition & (IO_READ | IO_WRITE))
+		ev.udata = io;
+	if (condition & IO_ERROR)
+		ctx->fds[fd].errio = io;
 
-        if (condition & (IO_READ | IO_WRITE))
-                ev.udata = io;
-        if (condition & IO_ERROR)
-                ctx->fds[fd].errio = io;
-
-        if (condition & (IO_READ | IO_ERROR)) {
-                ctx->fds[fd].mode |= condition;
-                ev.filter = EVFILT_READ;
-                kevent(ctx->kq, &ev, 1, NULL, 0, NULL);
-        }
-        if (condition & (IO_WRITE | IO_ERROR)) {
-                ctx->fds[fd].mode |= condition;
-                ev.filter = EVFILT_WRITE;
-                kevent(ctx->kq, &ev, 1, NULL, 0, NULL);
-        }
+	if (condition & (IO_READ | IO_ERROR)) {
+		ctx->fds[fd].mode |= condition;
+		ev.filter = EVFILT_READ;
+		if (kevent(ctx->kq, &ev, 1, NULL, 0, NULL) == -1) {
+			i_error("kevent() for io_loop_handle_add() has failed,"
+				" fd:%d, %m", fd);
+		}
+	}
+	if (condition & (IO_WRITE | IO_ERROR)) {
+		ctx->fds[fd].mode |= condition;
+		ev.filter = EVFILT_WRITE;
+		if (kevent(ctx->kq, &ev, 1, NULL, 0, NULL) == -1) {
+			i_error("kevent() for io_loop_handle_add() has failed,"
+				" fd:%d, %m", fd);
+		}
+	}
 }
 
 void io_loop_handle_remove(struct ioloop *ioloop, struct io *io)
 {
-        struct ioloop_handler_context *ctx = ioloop->handler_context;
-        const int fd = io->fd;
-        struct kevent ev = { fd, 0, EV_DELETE, 0, 0, NULL };
-        struct fdrecord *const fds = ctx->fds;
-        const enum io_condition condition = io->condition & MASK;
+	struct ioloop_handler_context *ctx = ioloop->handler_context;
+	const int fd = io->fd;
+	struct kevent ev = { fd, 0, EV_DELETE, 0, 0, NULL };
+	struct fdrecord *const fds = ctx->fds;
+	const enum io_condition condition = io->condition & MASK;
 
-        i_assert((size_t)fd < ctx->fds_size);
-        i_assert(fds[fd].mode != 0);
+	i_assert((size_t)fd < ctx->fds_size);
 
-        if (condition & IO_ERROR)
-                fds[fd].errio = NULL;
-        if (condition & (IO_READ | IO_ERROR)) {
-                ev.filter = EVFILT_READ;
-                fds[fd].mode &= ~condition;
-                if ((fds[fd].mode & (IO_READ | IO_ERROR)) == 0)
-                        kevent(ctx->kq, &ev, 1, NULL, 0, NULL);
-        }
-        if (condition & (IO_WRITE | IO_ERROR)) {
-                ev.filter = EVFILT_WRITE;
-                fds[fd].mode &= ~condition;
-                if ((fds[fd].mode & (IO_WRITE | IO_ERROR)) == 0)
-                        kevent(ctx->kq, &ev, 1, NULL, 0, NULL);
-        }
+	if (condition & IO_ERROR)
+		fds[fd].errio = NULL;
+	if (condition & (IO_READ | IO_ERROR)) {
+		ev.filter = EVFILT_READ;
+		fds[fd].mode &= ~condition;
+		if ((fds[fd].mode & (IO_READ | IO_ERROR)) == 0 &&
+		    (fcntl(io->fd, F_GETFD, 0) != -1 || errno != EBADF))
+			if (kevent(ctx->kq, &ev, 1, NULL, 0, NULL) == -1) {
+				i_error("kevent() for io_loop_handle_remove"
+					" has failed: fd:%d, %m", fd);
+			}
+	}
+	if (condition & (IO_WRITE | IO_ERROR)) {
+		ev.filter = EVFILT_WRITE;
+		fds[fd].mode &= ~condition;
+		if ((fds[fd].mode & (IO_WRITE | IO_ERROR)) == 0 &&
+		    (fcntl(io->fd, F_GETFD, 0) != -1 || errno != EBADF))
+			if (kevent(ctx->kq, &ev, 1, NULL, 0, NULL) == -1) {
+				i_error("kevent() for io_loop_handle_remove"
+					" has failed: fd:%d, %m", fd);
+			}
+	}
 }
 
 void io_loop_handler_run(struct ioloop *ioloop)
 {
-        struct ioloop_handler_context *ctx = ioloop->handler_context;
-        struct timeval tv;
-        struct timespec ts;
-        unsigned int t_id;
-        int msecs, ret, i;
+	struct ioloop_handler_context *ctx = ioloop->handler_context;
+	struct timeval tv;
+	struct timespec ts;
+	unsigned int t_id;
+	int msecs, ret, i;
 
-        /* get the time left for next timeout task */
-        msecs = io_loop_get_wait_time(ioloop->timeouts, &tv, NULL);
-        ts.tv_sec = tv.tv_sec;
-        ts.tv_nsec = tv.tv_usec * 1000;
+	/* get the time left for next timeout task */
+	msecs = io_loop_get_wait_time(ioloop->timeouts, &tv, NULL);
+	ts.tv_sec = tv.tv_sec;
+	ts.tv_nsec = tv.tv_usec * 1000;
 
-        /* wait for events */
-        ret = kevent (ctx->kq, NULL, 0, ctx->evbuf, ctx->evbuf_size, &ts);
-        if (ret < 0 && errno != EINTR)
-                i_fatal("kevent(): %m");
+	/* wait for events */
+	ret = kevent (ctx->kq, NULL, 0, ctx->evbuf, ctx->evbuf_size, &ts);
+	if (ret < 0 && errno != EINTR)
+		i_fatal("kevent(): %m");
 
-        /* execute timeout handlers */
-        io_loop_handle_timeouts(ioloop);
+	/* execute timeout handlers */
+	io_loop_handle_timeouts(ioloop);
 
-        if (ret <= 0 || !ioloop->running) {
-                /* no I/O events */
-                return;
-        }
+	if (ret <= 0 || !ioloop->running) {
+		/* no I/O events */
+		return;
+	}
 
-        i_assert((size_t)ret <= ctx->evbuf_size);
+	i_assert((size_t)ret <= ctx->evbuf_size);
 
-        /* loop through all received events */
-        for (i = 0; i < ret; ++i) {
-                struct io *io = ctx->evbuf[i].udata;
+	/* loop through all received events */
+	for (i = 0; i < ret; ++i) {
+		struct io *io = ctx->evbuf[i].udata;
 
-                i_assert(ctx->evbuf[i].ident < ctx->fds_size);
+		i_assert(ctx->evbuf[i].ident < ctx->fds_size);
 		if ((ctx->fds[ctx->evbuf[i].ident].mode & IO_ERROR) &&
 		    (ctx->evbuf[i].flags & EV_EOF)) {
-                        struct io *errio = ctx->fds[ctx->evbuf[i].ident].errio;
+			struct io *errio = ctx->fds[ctx->evbuf[i].ident].errio;
 
-                        t_id = t_push();
-                        errio->callback(errio->context);
+			t_id = t_push();
+			errio->callback(errio->context);
 			if (t_pop() != t_id) {
-                                i_panic("Leaked a t_pop() call"
-                                        " in I/O handler %p",
+				i_panic("Leaked a t_pop() call"
+					" in I/O handler %p",
 					(void *)errio->callback);
 			}
-                } else if (ctx->fds[ctx->evbuf[i].ident].mode
-                         & (IO_WRITE | IO_READ)) {
-                        t_id = t_push();
-                        io->callback(io->context);
+		} else if (ctx->fds[ctx->evbuf[i].ident].mode
+			 & (IO_WRITE | IO_READ)) {
+			t_id = t_push();
+			io->callback(io->context);
 			if (t_pop() != t_id) {
-                                i_panic("Leaked a t_pop() call"
-                                        " in I/O handler %p",
+				i_panic("Leaked a t_pop() call"
+					" in I/O handler %p",
d7 10
a16 6
-                } else
-                        i_panic("Unrecognized event");
-        }
+		} else
+			i_panic("Unrecognized event");
+	}
a18 1
 #endif
@


1.2
log
@upgrade to Dovecot 1.0beta2
@
text
@d1 1
a1 1
$OpenBSD: patch-src_lib_ioloop-kqueue_c,v 1.1 2006/01/22 15:35:43 brad Exp $
@


1.1
log
@patches for the kqueue code to fix a few issues.

From: <V dot Haisman at sh dot cvut dot cz>
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
+++ src/lib/ioloop-kqueue.c	Sun Jan 22 00:54:23 2006
@@@@ -12,6 +12,7 @@@@
d8 4
d13 100
a112 1
 #include "ioloop-internal.h"
d114 56
a169 19
 #ifdef IOLOOP_KQUEUE
@@@@ -53,6 +54,7 @@@@ void io_loop_handler_init(struct ioloop 
         ctx->kq = kqueue();
         if (ctx->kq < 0)
                 i_fatal("kqueue(): %m");
+        fd_close_on_exec(ctx->kq, TRUE);
 
         ctx->fds_size = INITIAL_BUF_SIZE;
         ctx->fds = p_new(ioloop->pool, struct fdrecord, ctx->fds_size);
@@@@ -74,6 +76,7 @@@@ void io_loop_handle_add(struct ioloop *i
         struct kevent ev = { fd, 0, EV_ADD | EV_EOF, 0, 0, NULL };
         enum io_condition condition = io->condition & MASK;
 
+        i_assert(io->callback);
         /* grow ctx->fds array if necessary */
         if ((size_t)fd >= ctx->fds_size) {
                 size_t old_size = ctx->fds_size;
@@@@ -114,7 +117,6 @@@@ void io_loop_handle_remove(struct ioloop
         const enum io_condition condition = io->condition & MASK;
d171 1
a171 1
         i_assert((size_t)fd < ctx->fds_size);
d173 135
d309 1
a309 2
         if (condition & IO_ERROR)
                 fds[fd].errio = NULL;
@

