head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.8
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.4
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.6
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.2
	OPENBSD_5_7_BASE:1.1.1.1
	pascal_20140914:1.1.1.1
	pascal:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2016.09.01.16.50.14;	author pascal;	state Exp;
branches;
next	1.1;
commitid	SLN2dxKJh1nw9fdc;

1.1
date	2014.09.14.21.01.52;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	qTnyGevaWmGijpQu;

1.1.1.1
date	2014.09.14.21.01.52;	author pascal;	state Exp;
branches;
next	;
commitid	qTnyGevaWmGijpQu;


desc
@@


1.2
log
@Update to SFML 2.4.0.

ok bentley@@
@
text
@$OpenBSD: patch-src_SFML_Window_WindowImpl_cpp,v 1.1.1.1 2014/09/14 21:01:52 pascal Exp $
--- src/SFML/Window/WindowImpl.cpp.orig	Sat Jan 30 19:48:10 2016
+++ src/SFML/Window/WindowImpl.cpp	Sat Jan 30 19:48:20 2016
@@@@ -38,7 +38,7 @@@@
     #include <SFML/Window/Win32/WindowImplWin32.hpp>
     typedef sf::priv::WindowImplWin32 WindowImplType;
 
-#elif defined(SFML_SYSTEM_LINUX) || defined(SFML_SYSTEM_FREEBSD)
+#elif defined(SFML_SYSTEM_LINUX) || defined(SFML_SYSTEM_FREEBSD) || defined(SFML_SYSTEM_OPENBSD)
 
     #include <SFML/Window/Unix/WindowImplX11.hpp>
     typedef sf::priv::WindowImplX11 WindowImplType;
@


1.1
log
@Initial revision
@
text
@d1 4
a4 12
$OpenBSD$
--- src/SFML/Window/WindowImpl.cpp.orig	Thu Mar 20 02:18:17 2014
+++ src/SFML/Window/WindowImpl.cpp	Thu Mar 20 02:23:23 2014
@@@@ -27,7 +27,6 @@@@
 ////////////////////////////////////////////////////////////
 #include <SFML/Window/WindowImpl.hpp>
 #include <SFML/Window/Event.hpp>
-#include <SFML/Window/JoystickManager.hpp>
 #include <SFML/System/Sleep.hpp>
 #include <algorithm>
 #include <cmath>
@@@@ -37,7 +36,7 @@@@
d11 1
a11 1
     #include <SFML/Window/Linux/WindowImplX11.hpp>
a12 100
@@@@ -73,9 +72,6 @@@@ WindowImpl::WindowImpl() :
 m_joyThreshold(0.1f)
 {
     // Get the initial joystick states
-    JoystickManager::getInstance().update();
-    for (unsigned int i = 0; i < Joystick::Count; ++i)
-        m_joyStates[i] = JoystickManager::getInstance().getState(i);
 }
 
 
@@@@ -89,7 +85,7 @@@@ WindowImpl::~WindowImpl()
 ////////////////////////////////////////////////////////////
 void WindowImpl::setJoystickThreshold(float threshold)
 {
-    m_joyThreshold = threshold;
+    // Nothing to do
 }
 
 
@@@@ -102,7 +98,6 @@@@ bool WindowImpl::popEvent(Event& event, bool block)
         if (!block)
         {
             // Non-blocking mode: process events and continue
-            processJoystickEvents();
             processEvents();
         }
         else
@@@@ -114,7 +109,6 @@@@ bool WindowImpl::popEvent(Event& event, bool block)
             // events (which require polling)
             while (m_events.empty())
             {
-                processJoystickEvents();
                 processEvents();
                 sleep(milliseconds(10));
             }
@@@@ -145,64 +139,6 @@@@ void WindowImpl::pushEvent(const Event& event)
 void WindowImpl::processJoystickEvents()
 {
     // First update the global joystick states
-    JoystickManager::getInstance().update();
-
-    for (unsigned int i = 0; i < Joystick::Count; ++i)
-    {
-        // Copy the previous state of the joystick and get the new one
-        JoystickState previousState = m_joyStates[i];
-        m_joyStates[i] = JoystickManager::getInstance().getState(i);
-        JoystickCaps caps = JoystickManager::getInstance().getCapabilities(i);
-
-        // Connection state
-        bool connected = m_joyStates[i].connected;
-        if (previousState.connected ^ connected)
-        {
-            Event event;
-            event.type = connected ? Event::JoystickConnected : Event::JoystickDisconnected;
-            event.joystickButton.joystickId = i;
-            pushEvent(event);
-        }
-
-        if (connected)
-        {
-            // Axes
-            for (unsigned int j = 0; j < Joystick::AxisCount; ++j)
-            {
-                if (caps.axes[j])
-                {
-                    Joystick::Axis axis = static_cast<Joystick::Axis>(j);
-                    float prevPos = previousState.axes[axis];
-                    float currPos = m_joyStates[i].axes[axis];
-                    if (fabs(currPos - prevPos) >= m_joyThreshold)
-                    {
-                        Event event;
-                        event.type = Event::JoystickMoved;
-                        event.joystickMove.joystickId = i;
-                        event.joystickMove.axis = axis;
-                        event.joystickMove.position = currPos;
-                        pushEvent(event);
-                    }
-                }
-            }
-
-            // Buttons
-            for (unsigned int j = 0; j < caps.buttonCount; ++j)
-            {
-                bool prevPressed = previousState.buttons[j];
-                bool currPressed = m_joyStates[i].buttons[j];
-
-                if (prevPressed ^ currPressed)
-                {
-                    Event event;
-                    event.type = currPressed ? Event::JoystickButtonPressed : Event::JoystickButtonReleased;
-                    event.joystickButton.joystickId = i;
-                    event.joystickButton.button = j;
-                    pushEvent(event);
-                }
-            }
-        }
-    }
 }
 
 
@


1.1.1.1
log
@Import multimedia/sfml, requested by and ok bcallah@@

SFML is a portable and easy to use multimedia API written in C++.
You can see it as a modern, object-oriented alternative to SDL.
SFML is composed of several packages to perfectly suit your needs.
You can use SFML as a minimal windowing system to interface with
OpenGL, or as a fully-featured multimedia library for building games
or interactive programs.
@
text
@@
