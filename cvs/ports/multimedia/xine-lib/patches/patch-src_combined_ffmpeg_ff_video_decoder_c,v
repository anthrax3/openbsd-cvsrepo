head	1.22;
access;
symbols
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@# @;


1.22
date	2017.03.20.08.14.03;	author ajacoutot;	state Exp;
branches;
next	1.21;
commitid	cskePNdb4ONv3Bqf;

1.21
date	2017.02.25.11.17.30;	author ajacoutot;	state dead;
branches;
next	1.20;
commitid	R9cUvPmiwv30c4Ve;

1.20
date	2015.09.18.05.45.26;	author ajacoutot;	state Exp;
branches;
next	1.19;
commitid	Qv9ZlTnZcEAiwBTG;

1.19
date	2014.07.13.20.03.51;	author brad;	state dead;
branches;
next	1.18;
commitid	YLfQXW0aptQ3vfxK;

1.18
date	2014.05.24.16.16.14;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.21.23.41.03;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.14.08.07.24;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.30.22.13.37;	author brad;	state dead;
branches;
next	1.14;

1.14
date	2013.08.28.15.30.35;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2012.11.29.20.18.21;	author brad;	state dead;
branches;
next	1.12;

1.12
date	2012.06.10.07.35.30;	author ajacoutot;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.09.08.41.16;	author ajacoutot;	state Exp;
branches;
next	1.10;

1.10
date	2012.05.14.13.48.49;	author ajacoutot;	state Exp;
branches;
next	1.9;

1.9
date	2012.04.21.12.36.31;	author ajacoutot;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.07.05.48.49;	author ajacoutot;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.16.00.43.17;	author sthen;	state dead;
branches;
next	1.6;

1.6
date	2011.10.09.20.45.07;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.13.08.10.01;	author dcoppa;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.13.20.35.51;	author sthen;	state dead;
branches;
next	1.3;

1.3
date	2010.09.13.20.12.16;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.21.01.41.15;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.05.11.50.18;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Bring in some bug fixes from upstream and use the FFmpeg decoder for
VP8 / VP9 content.

from Brad (maintainer)
@
text
@$OpenBSD$

- ff_video_decoder: turn off that interlaced field hack for VP9
- ff_video_decoder: less useless flushing

--- src/combined/ffmpeg/ff_video_decoder.c.orig	Sun Mar 19 16:12:17 2017
+++ src/combined/ffmpeg/ff_video_decoder.c	Sun Mar 19 16:18:29 2017
@@@@ -110,6 +110,7 @@@@ struct ff_video_decoder_s {
   uint8_t           is_direct_rendering_disabled:1;  /* used only to avoid flooding log */
   uint8_t           cs_convert_init:1;
   uint8_t           assume_bad_field_picture:1;
+  uint8_t           use_bad_frames:1;
 
   xine_bmiheader    bih;
   unsigned char    *buf;
@@@@ -172,12 +173,14 @@@@ struct ff_video_decoder_s {
 
   /* Ugly: 2nd guess the reason for flush.
      ff_flush () should really have an extra argument telling this. */
-#define STATE_RESET         0
-#define STATE_DISCONTINUITY 1
-#define STATE_READING_DATA  2
-#define STATE_FRAME_SENT    3
-#define STATE_FLUSHED       4
-  int               state;
+  enum {
+    STATE_RESET = 0,
+    STATE_DISCONTINUITY,
+    STATE_READING_DATA,
+    STATE_FRAME_SENT,
+    STATE_FLUSHED
+  }                 state;
+  int               decode_attempts;
 
 #ifdef ENABLE_EMMS
   /* see get_buffer () */
@@@@ -896,6 +899,10 @@@@ static void init_video_codec (ff_video_decoder_t *this
     thread_count = 1;
   }
 
+  /* Use "bad frames" to fill pts gaps */
+  if (codec_type != BUF_VIDEO_VP9)
+    this->use_bad_frames = 1;
+
   /* Check for VAAPI HWDEC capability */
 #ifdef ENABLE_VAAPI
   if( this->class->enable_vaapi ) {
@@@@ -1811,6 +1818,7 @@@@ static int decode_video_wrapper(ff_video_decoder_t *th
   }
 # endif /* XFF_PALETTE */
 
+  this->decode_attempts++;
   len = avcodec_decode_video2 (this->context, av_frame,
                                got_picture, &avpkt);
 
@@@@ -1833,6 +1841,7 @@@@ static int decode_video_wrapper(ff_video_decoder_t *th
 # endif /* XFF_PALETTE */
 
 #else /* XFF_VIDEO */
+  this->decode_attempts++;
   len = avcodec_decode_video (this->context, av_frame,
                               got_picture, buf, buf_size);
 #endif /* XFF_VIDEO */
@@@@ -2317,7 +2326,7 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
     /* workaround for demux_mpeg_pes sending fields as frames:
      * do not generate a bad frame for the first field picture
      */
-    if (!got_one_picture && (this->size || this->video_step || this->assume_bad_field_picture)) {
+    if (!got_one_picture && this->use_bad_frames && (this->size || this->video_step || this->assume_bad_field_picture)) {
       /* skipped frame, output a bad frame (use size 16x16, when size still uninitialized) */
       img = this->stream->video_out->get_frame (this->stream->video_out,
                                                 (this->bih.biWidth  <= 0) ? 16 : ((this->bih.biWidth  + 15) & ~15),
@@@@ -2415,8 +2424,12 @@@@ static void ff_flush_internal (ff_video_decoder_t *thi
   AVRational  avr00 = {0, 1};
 
   /* This is a stripped version of ff_handle_buffer (). It shall return yet undisplayed frames. */
+
   if (!this->context || !this->decoder_ok || this->state == STATE_FLUSHED)
     return;
+  /* For some reason, we are flushed right while reading the first frame?? */
+  if (!this->decode_attempts)
+    return;
   this->state = STATE_FLUSHED;
 
   while (1) {
@@@@ -2516,6 +2529,8 @@@@ static void ff_flush_internal (ff_video_decoder_t *thi
     av_frame_unref (this->av_frame2);
 #endif
   }
+
+  this->decode_attempts = 0;
 
   if (frames)
     xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
@


1.21
log
@Update to xine-lib-1.2.8.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.20 2015/09/18 05:45:26 ajacoutot Exp $
d3 2
a4 1
Fix AVCodecContext/AVFrame freeing.
d6 7
a12 20
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Thu Sep 17 17:52:07 2015
+++ src/combined/ffmpeg/ff_video_decoder.c	Thu Sep 17 17:53:32 2015
@@@@ -2474,14 +2474,14 @@@@ static void ff_dispose (video_decoder_t *this_gen) {
   if (this->slice_offset_table)
     free (this->slice_offset_table);
 
-  if(this->context && this->context->extradata)
-    free(this->context->extradata);
+  if (this->context) {
+    _x_freep (&this->context->extradata);
+    this->context->extradata_size = 0;
+    avcodec_free_context (&this->context);
+  }
 
-  if( this->context )
-    av_free( this->context );
-
   if( this->av_frame )
-    av_free( this->av_frame );
+    avcodec_free_frame( &this->av_frame );
d14 81
a94 2
   if (this->buf)
     free(this->buf);
@


1.20
log
@Back port a bug fix:
- fix AVCodecContext/AVFrame freeing.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.19
log
@Update to Xine-lib 1.2.6.

ok ajacoutot@@ sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.18 2014/05/24 16:16:14 brad Exp $
d3 1
a3 3
- Simplify FFmpeg video edge handling.
- Add DR1 reenable message.
- Fix multithreading.
d5 12
a16 63
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Thu Mar 13 00:06:09 2014
+++ src/combined/ffmpeg/ff_video_decoder.c	Sat May 24 11:17:54 2014
@@@@ -278,8 +278,19 @@@@ static int get_buffer (AVCodecContext *context, AVFram
   /* The visible size, may be smaller. */
   int width  = context->width;
   int height = context->height;
+  int top_edge;
   int guarded_render = 0;
 
+  /* multiple threads have individual contexts !! */
+#ifdef AVCODEC_HAS_COLORSPACE
+  if (context != this->context) {
+    if (this->context->colorspace == 2) /* undefined */
+      this->context->colorspace = context->colorspace;
+    if (this->context->color_range == 0)
+      this->context->color_range = context->color_range;
+  }
+#endif
+
   /* A bit of unmotivated paranoia... */
   if (buf_width < width)
     buf_width = width;
@@@@ -303,7 +314,7 @@@@ static int get_buffer (AVCodecContext *context, AVFram
   avcodec_align_dimensions(context, &buf_width, &buf_height);
 
 #ifdef ENABLE_VAAPI
-  if( this->context->pix_fmt == PIX_FMT_VAAPI_VLD) {
+  if( context->pix_fmt == PIX_FMT_VAAPI_VLD ) {
 
     av_frame->opaque  = NULL;
     av_frame->data[0] = NULL;
@@@@ -406,13 +417,18 @@@@ static int get_buffer (AVCodecContext *context, AVFram
 #endif /* ENABLE_VAAPI */
 
   /* The alignment rhapsody */
-  buf_width  += 2 * this->edge + 15;
-  buf_width  &= ~15;
-  buf_height += 2 * this->edge + 15;
+  /* SSE2+ requirement (U, V rows need to be 16 byte aligned too) */
+  buf_width  += 2 * this->edge + 31;
+  buf_width  &= ~31;
+  /* 2 extra lines for the edge wrap below plus XINE requirement */
+  top_edge = this->edge;
+  if (top_edge)
+    top_edge += 2;
+  buf_height += top_edge + this->edge + 15;
   buf_height &= ~15;
 
-  if ((this->full2mpeg || (this->context->pix_fmt != PIX_FMT_YUV420P &&
-			   this->context->pix_fmt != PIX_FMT_YUVJ420P)) || guarded_render) {
+  if (this->full2mpeg || guarded_render ||
+    (context->pix_fmt != PIX_FMT_YUV420P && context->pix_fmt != PIX_FMT_YUVJ420P)) {
     if (!this->is_direct_rendering_disabled) {
       xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
               _("ffmpeg_video_dec: unsupported frame format, DR1 disabled.\n"));
@@@@ -449,7 +465,10 @@@@ static int get_buffer (AVCodecContext *context, AVFram
     }
   }
 
-  this->is_direct_rendering_disabled = 0;
+  if (this->is_direct_rendering_disabled) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_LOG, _("ffmpeg_video_dec: direct rendering enabled\n"));
+    this->is_direct_rendering_disabled = 0;
d19 6
a24 23
   img = this->stream->video_out->get_frame (this->stream->video_out,
                                             buf_width,
@@@@ -503,13 +522,15 @@@@ static int get_buffer (AVCodecContext *context, AVFram
   av_frame->linesize[2] = img->pitches[2];
 
   if (this->output_format == XINE_IMGFMT_YV12) {
-    av_frame->data[0] += (img->pitches[0] + 1) * this->edge;
-    av_frame->data[1] += (img->pitches[1] + 1) * this->edge / 2;
-    av_frame->data[2] += (img->pitches[2] + 1) * this->edge / 2;
-    img->crop_left   = this->edge;
-    img->crop_top    = this->edge;
-    img->crop_right  = buf_width  - width  - this->edge;
-    img->crop_bottom = buf_height - height - this->edge;
+    /* nasty hack: wrap left edge to the right side to get proper
+       SSE2 alignment on all planes. */
+    av_frame->data[0] += img->pitches[0] * top_edge;
+    av_frame->data[1] += img->pitches[1] * top_edge / 2;
+    av_frame->data[2] += img->pitches[2] * top_edge / 2;
+    img->crop_left   = 0;
+    img->crop_top    = top_edge;
+    img->crop_right  = buf_width  - width;
+    img->crop_bottom = buf_height - height - top_edge;
   }
d26 2
a27 26
   /* We should really keep track of the ages of xine frames (see
@@@@ -731,6 +752,7 @@@@ static void init_video_codec (ff_video_decoder_t *this
   if( this->codec->capabilities & CODEC_CAP_DR1 && this->class->enable_dri ) {
 #ifdef AV_BUFFER
     this->context->get_buffer2 = get_buffer;
+    this->context->thread_safe_callbacks = 1;
 #else
     this->context->get_buffer = get_buffer;
     this->context->release_buffer = release_buffer;
@@@@ -2280,6 +2302,7 @@@@ static void ff_free_dr1_frames (ff_video_decoder_t *th
      They will only be replaced when new ones arrive, and freed on codec close.
      They also have no AVCodec.flush () callback for manual freeing (that is,
      avcodec_flush_buffers () does nothing).
+     Even worse: multithreading seems to always do it like that...
      So lets tolerate this behaviour on plain stream seek. */
   if (!all) {
     it = NULL;
@@@@ -2288,7 +2311,7 @@@@ static void ff_free_dr1_frames (ff_video_decoder_t *th
       frames++;
     if (!frames)
       return;
-    if (frames < 5) {
+    if (frames < 12) {
       xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
         "ffmpeg_video_dec: tolerating %d held DR1 frames.\n", frames);
       return;
@


1.18
log
@Further fixes for multithreading support with FFmpeg.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.17 2014/05/21 23:41:03 brad Exp $
@


1.17
log
@- Add some fixes for the FFmpeg decoder
- Enable the libvpx decoder as a means of working around a bug
  with Xine's VP9 decoder via FFmpeg
- Add Opus support

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.16 2014/05/14 08:07:24 brad Exp $
d8 2
a9 2
+++ src/combined/ffmpeg/ff_video_decoder.c	Tue May 20 14:04:56 2014
@@@@ -278,6 +278,7 @@@@ static int get_buffer (AVCodecContext *context, AVFram
d16 10
d27 12
a38 1
@@@@ -406,9 +407,14 @@@@ static int get_buffer (AVCodecContext *context, AVFram
d55 8
a62 2
   if ((this->full2mpeg || (this->context->pix_fmt != PIX_FMT_YUV420P &&
@@@@ -449,7 +455,10 @@@@ static int get_buffer (AVCodecContext *context, AVFram
d74 1
a74 1
@@@@ -503,13 +512,15 @@@@ static int get_buffer (AVCodecContext *context, AVFram
d97 9
a105 1
@@@@ -2280,6 +2291,7 @@@@ static void ff_free_dr1_frames (ff_video_decoder_t *th
d113 1
a113 1
@@@@ -2288,7 +2300,7 @@@@ static void ff_free_dr1_frames (ff_video_decoder_t *th
@


1.16
log
@Attempt to fix FFmpeg VP9 segfault.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
d3 3
a5 1
Attempt to fix FFmpeg VP9 segfault.
d8 10
a17 2
+++ src/combined/ffmpeg/ff_video_decoder.c	Tue May 13 21:11:15 2014
@@@@ -406,9 +406,11 @@@@ static int get_buffer (AVCodecContext *context, AVFram
d28 4
a31 1
+  buf_height += 2 * this->edge + 2 + 15;
d35 13
a47 1
@@@@ -503,12 +505,15 @@@@ static int get_buffer (AVCodecContext *context, AVFram
d55 4
a58 1
+    /* nasty hack: wrap right edge to the left side when needed to get proper
d60 7
a66 9
+    int left_edge = (this->edge + 31) & ~31;
+    av_frame->data[0] += img->pitches[0] * this->edge + left_edge;
+    av_frame->data[1] += (img->pitches[1] * this->edge + left_edge) / 2;
+    av_frame->data[2] += (img->pitches[2] * this->edge + left_edge) / 2;
+    img->crop_left   = left_edge;
     img->crop_top    = this->edge;
-    img->crop_right  = buf_width  - width  - this->edge;
+    img->crop_right  = buf_width  - width - left_edge;
     img->crop_bottom = buf_height - height - this->edge;
d69 18
@


1.15
log
@Update to Xine-lib 1.2.4.

ok juanfra@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.14 2013/08/28 15:30:35 brad Exp $
d3 1
a3 2
- Default to square pixels.
- Avoid CODEC_FLAG_EMU_EDG.
d5 4
a8 26
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Mon Aug 19 21:56:03 2013
+++ src/combined/ffmpeg/ff_video_decoder.c	Mon Aug 19 21:56:08 2013
@@@@ -131,7 +131,7 @@@@ struct ff_video_decoder_s {
   double            aspect_ratio;
   int               aspect_ratio_prio;
   int               frame_flags;
-  int               crop_right, crop_bottom;
+  int               edge;
 
   int               output_format;
 
@@@@ -157,6 +157,8 @@@@ struct ff_video_decoder_s {
   uint8_t           set_stream_info;
 
 #ifdef ENABLE_VAAPI
+  int                   vaapi_width, vaapi_height;
+  int                   vaapi_profile;
   struct vaapi_context  vaapi_context;
   vaapi_accel_t         *accel;
   vo_frame_t            *accel_img;
@@@@ -225,6 +227,7 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
   vo_frame_t *img;
   int width  = context->width;
   int height = context->height;
+  int crop_right = 0, crop_bottom = 0;
   int guarded_render = 0;
d10 10
a19 6
   ff_check_colorspace (this);
@@@@ -232,13 +235,13 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
   if (!this->bih.biWidth || !this->bih.biHeight) {
     this->bih.biWidth = width;
     this->bih.biHeight = height;
+  }
a20 51
-    if (this->aspect_ratio_prio == 0) {
-      this->aspect_ratio = (double)width / (double)height;
-      this->aspect_ratio_prio = 1;
-      lprintf("default aspect ratio: %f\n", this->aspect_ratio);
-      this->set_stream_info = 1;
-    }
+  if (this->aspect_ratio_prio == 0) {
+    this->aspect_ratio = (double)width / (double)height;
+    this->aspect_ratio_prio = 1;
+    lprintf("default aspect ratio: %f\n", this->aspect_ratio);
+    this->set_stream_info = 1;
   }
 
   avcodec_align_dimensions(context, &width, &height);
@@@@ -257,6 +260,26 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
 #endif
     av_frame->reordered_opaque = context->reordered_opaque;
 
+    /* reinitialize vaapi for new image size */
+    if (context->width != this->vaapi_width || context->height != this->vaapi_height) {
+      VAStatus status;
+
+      this->vaapi_width  = context->width;
+      this->vaapi_height = context->height;
+      status = this->accel->vaapi_init (this->accel_img, this->vaapi_profile,
+        context->width, context->height, 0);
+
+      if (status == VA_STATUS_SUCCESS) {
+        ff_vaapi_context_t *va_context = this->accel->get_context (this->accel_img);
+
+        if (va_context) {
+          this->vaapi_context.config_id  = va_context->va_config_id;
+          this->vaapi_context.context_id = va_context->va_context_id;
+          this->vaapi_context.display    = va_context->va_display;
+        }
+      }
+    }
+
     if(!this->accel->guarded_render(this->accel_img)) {
       img = this->stream->video_out->get_frame (this->stream->video_out,
                                             width,
@@@@ -305,6 +328,12 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
     guarded_render = this->accel->guarded_render(this->accel_img);
 #endif /* ENABLE_VAAPI */
 
+  /* The alignment rhapsody */
+  width  += 2 * this->edge;
+  height += 2 * this->edge;
+  width   = (width + 15) & ~15;
+  height  = (height + 15) & ~15;
+
d22 1
a22 24
 			   this->context->pix_fmt != PIX_FMT_YUVJ420P)) || guarded_render) {
     if (!this->is_direct_rendering_disabled) {
@@@@ -322,8 +351,8 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
 
   if((width != this->bih.biWidth) || (height != this->bih.biHeight)) {
     if(this->stream->video_out->get_capabilities(this->stream->video_out) & VO_CAP_CROP) {
-      this->crop_right = width - this->bih.biWidth;
-      this->crop_bottom = height - this->bih.biHeight;
+      crop_right = width - this->bih.biWidth - this->edge;
+      crop_bottom = height - this->bih.biHeight - this->edge;
     } else {
       if (!this->is_direct_rendering_disabled) {
         xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
@@@@ -349,6 +378,8 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
 
   av_frame->opaque = img;
 
+  av_frame->extended_data = av_frame->data;
+
   av_frame->data[0]= img->base[0];
   av_frame->data[1]= img->base[1];
   av_frame->data[2]= img->base[2];
@@@@ -357,6 +388,16 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
   av_frame->linesize[1] = img->pitches[1];
d25 16
a40 84
+  if (this->output_format == XINE_IMGFMT_YV12) {
+    av_frame->data[0] += (img->pitches[0] + 1) * this->edge;
+    av_frame->data[1] += (img->pitches[1] + 1) * this->edge / 2;
+    av_frame->data[2] += (img->pitches[2] + 1) * this->edge / 2;
+    img->crop_left   = this->edge;
+    img->crop_top    = this->edge;
+    img->crop_right  = crop_right;
+    img->crop_bottom = crop_bottom;
+  }
+
   /* We should really keep track of the ages of xine frames (see
    * avcodec_default_get_buffer in libavcodec/utils.c)
    * For the moment tell ffmpeg that every frame is new (age = bignumber) */
@@@@ -436,9 +477,14 @@@@ static const int skip_loop_filter_enum_values[] = {
 };
 
 #ifdef ENABLE_VAAPI
+/* TJ. libavcodec calls this with a list of supported pixel formats and lets us choose 1.
+   Returning PIX_FMT_VAAPI_VLD enables VAAPI.
+   However, at this point we only got image width and height from container, being unreliable
+   or zero (MPEG-TS). Thus we repeat vaapi_context initialization in get_buffer when needed.
+   This should be OK since NAL unit parsing is always done in software. */
 static enum PixelFormat get_format(struct AVCodecContext *context, const enum PixelFormat *fmt)
 {
-  int i, profile;
+  int i;
   ff_video_decoder_t *this = (ff_video_decoder_t *)context->opaque;
 
   if(!this->class->enable_vaapi || !this->accel_img)
@@@@ -450,12 +496,21 @@@@ static enum PixelFormat get_format(struct AVCodecConte
     if (fmt[i] != PIX_FMT_VAAPI_VLD)
       continue;
 
-    profile = accel->profile_from_imgfmt(this->accel_img, fmt[i], context->codec_id, this->class->vaapi_mpeg_softdec);
+    this->vaapi_profile = accel->profile_from_imgfmt (this->accel_img, fmt[i],
+      context->codec_id, this->class->vaapi_mpeg_softdec);
 
-    if (profile >= 0) {
+    if (this->vaapi_profile >= 0) {
+      int width  = context->width;
+      int height = context->height;
       VAStatus status;
 
-      status = accel->vaapi_init(this->accel_img, profile, context->width, context->height, 0);
+      if (!width || !height) {
+        width  = 1920;
+        height = 1080;
+      }
+      this->vaapi_width  = width;
+      this->vaapi_height = height;
+      status = accel->vaapi_init (this->accel_img, this->vaapi_profile, width, height, 0);
 
       if( status == VA_STATUS_SUCCESS ) {
         ff_vaapi_context_t *va_context = accel->get_context(this->accel_img);
@@@@ -513,10 +568,20 @@@@ static void init_video_codec (ff_video_decoder_t *this
     _x_stream_info_get(this->stream, XINE_STREAM_INFO_VIDEO_FOURCC);
 
 
-  /* Some codecs (eg rv10) copy flags in init so it's necessary to set
-   * this flag here in case we are going to use direct rendering */
+  this->stream->video_out->open (this->stream->video_out, this->stream);
+
+  this->edge = 0;
   if(this->codec->capabilities & CODEC_CAP_DR1 && this->class->enable_dri) {
-    this->context->flags |= CODEC_FLAG_EMU_EDGE;
+    if (this->stream->video_out->get_capabilities (this->stream->video_out) & VO_CAP_CROP) {
+      /* We can crop. Fine. Lets allow decoders to paint over the frame edges.
+         This will be slightly faster. And it is also a workaround for buggy
+         v54 who likes to ignore EMU_EDGE for wmv2 and xvid. */
+      this->edge = avcodec_get_edge_width ();
+    } else {
+      /* Some codecs (eg rv10) copy flags in init so it's necessary to set
+       * this flag here in case we are going to use direct rendering */
+      this->context->flags |= CODEC_FLAG_EMU_EDGE;
+    }
   }
 
   /* TJ. without this, it wont work at all on my machine */
@@@@ -575,6 +640,7 @@@@ static void init_video_codec (ff_video_decoder_t *this
     free(this->context);
     this->context = NULL;
     _x_stream_info_set(this->stream, XINE_STREAM_INFO_VIDEO_HANDLED, 0);
+    this->stream->video_out->close (this->stream->video_out, this->stream);
     return;
a42 74
@@@@ -590,6 +656,7 @@@@ static void init_video_codec (ff_video_decoder_t *this
       free(this->context);
       this->context = NULL;
       _x_stream_info_set(this->stream, XINE_STREAM_INFO_VIDEO_HANDLED, 0);
+      this->stream->video_out->close (this->stream->video_out, this->stream);
       return;
     }
   }
@@@@ -620,8 +687,6 @@@@ static void init_video_codec (ff_video_decoder_t *this
     set_stream_info(this);
   }
 
-  (this->stream->video_out->open) (this->stream->video_out, this->stream);
-
   this->skipframes = 0;
 
   /* flag for interlaced streams */
@@@@ -1450,9 +1515,6 @@@@ static void ff_handle_mpeg12_buffer (ff_video_decoder_
       else
         img->duration = this->video_step;
 
-      img->crop_right  = this->crop_right;
-      img->crop_bottom = this->crop_bottom;
-
 #ifdef ENABLE_VAAPI
       if( this->context->pix_fmt == PIX_FMT_VAAPI_VLD) {
         if(this->accel->guarded_render(this->accel_img)) {
@@@@ -1731,6 +1793,8 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
                                                     this->aspect_ratio,
                                                     this->output_format,
                                                     VO_BOTH_FIELDS|this->frame_flags);
+          img->crop_right  = img->width  - this->bih.biWidth;
+          img->crop_bottom = img->height - this->bih.biHeight;
           free_img = 1;
         } else {
           /* DR1 */
@@@@ -1745,19 +1809,22 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
         if(this->pp_available && this->pp_quality && this->context->pix_fmt != PIX_FMT_VAAPI_VLD) {
 
           if(this->av_frame->opaque) {
-            /* DR1 */
+            /* DR1: filter into a new frame. Same size to avoid reallcation, just move the
+               image to top left corner. */
             img = this->stream->video_out->get_frame (this->stream->video_out,
-                                                      (img->width  + 15) & ~15,
-                                                      (img->height + 15) & ~15,
+                                                      img->width,
+                                                      img->height,
                                                       this->aspect_ratio,
                                                       this->output_format,
                                                       VO_BOTH_FIELDS|this->frame_flags);
+            img->crop_right  = img->width  - this->bih.biWidth;
+            img->crop_bottom = img->height - this->bih.biHeight;
             free_img = 1;
           }
 
           pp_postprocess((const uint8_t **)this->av_frame->data, this->av_frame->linesize,
                         img->base, img->pitches,
-                        img->width, img->height,
+                        this->bih.biWidth, this->bih.biHeight,
                         this->av_frame->qscale_table, this->av_frame->qstride,
                         this->our_mode, this->our_context,
                         this->av_frame->pict_type);
@@@@ -1785,10 +1852,6 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
           img->duration = video_step_to_use * 3 / 2;
         else
           img->duration = video_step_to_use;
-
-        /* additionally crop away the extra pixels due to adjusting frame size above */
-        img->crop_right  = img->width  - this->bih.biWidth;
-        img->crop_bottom = img->height - this->bih.biHeight;
 
         /* transfer some more frame settings for deinterlacing */
         img->progressive_frame = !this->av_frame->interlaced_frame;
@


1.14
log
@Several fixes from upstream:

- Fix multichannel playback.
- Default to square pixels.
- Avoid CODEC_FLAG_EMU_EDG.
- Use AV_CODEC_ID_MPEG2VIDEO.
- Fix another potential xine_play() hang.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.13
log
@Update to Xine-lib 1.2.2.

ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.12 2012/06/10 07:35:30 ajacoutot Exp $
d3 2
a4 1
Enable direct rendering for H.264.
d6 8
a13 18
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Fri Jun  8 09:36:36 2012
+++ src/combined/ffmpeg/ff_video_decoder.c	Sat Jun  9 20:29:04 2012
@@@@ -69,6 +69,7 @@@@ typedef struct ff_video_class_s {
   int                     thread_count;
   int8_t                  skip_loop_filter_enum;
   int8_t                  choose_speed_over_accuracy;
+  uint8_t                 enable_dri;
 
   xine_t                 *xine;
 } ff_video_class_t;
@@@@ -95,7 +96,7 @@@@ struct ff_video_decoder_s {
   uint8_t           is_mpeg12:1;
   uint8_t           pp_available:1;
   uint8_t           yuv_init:1;
-  uint8_t           is_direct_rendering_disabled:1;
+  uint8_t           is_direct_rendering_disabled:1;  /* used only to avoid flooding log */
   uint8_t           cs_convert_init:1;
   uint8_t           assume_bad_field_picture:1;
d15 36
a50 2
@@@@ -241,6 +242,8 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
     }
d53 24
a76 1
+  this->is_direct_rendering_disabled = 0;
d78 2
a79 1
   img = this->stream->video_out->get_frame (this->stream->video_out,
d81 64
a144 2
                                             height,
@@@@ -360,7 +363,7 @@@@ static void init_video_codec (ff_video_decoder_t *this
d146 56
a201 5
   /* Some codecs (eg rv10) copy flags in init so it's necessary to set
    * this flag here in case we are going to use direct rendering */
-  if(this->codec->capabilities & CODEC_CAP_DR1 && this->codec->id != CODEC_ID_H264) {
+  if(this->codec->capabilities & CODEC_CAP_DR1 && this->class->enable_dri) {
     this->context->flags |= CODEC_FLAG_EMU_EDGE;
d204 71
a274 32
@@@@ -440,7 +443,7 @@@@ static void init_video_codec (ff_video_decoder_t *this
   /* enable direct rendering by default */
   this->output_format = XINE_IMGFMT_YV12;
 #ifdef ENABLE_DIRECT_RENDERING
-  if( this->codec->capabilities & CODEC_CAP_DR1 && this->codec->id != CODEC_ID_H264 ) {
+  if( this->codec->capabilities & CODEC_CAP_DR1 && this->class->enable_dri ) {
     this->context->get_buffer = get_buffer;
     this->context->release_buffer = release_buffer;
     xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
@@@@ -500,6 +503,12 @@@@ static void pp_quality_cb(void *user_data, xine_cfg_en
   class->pp_quality = entry->num_value;
 }
 
+static void dri_cb(void *user_data, xine_cfg_entry_t *entry) {
+  ff_video_class_t   *class = (ff_video_class_t *) user_data;
+
+  class->enable_dri = entry->num_value;
+}
+
 static void pp_change_quality (ff_video_decoder_t *this) {
   this->pp_quality = this->class->pp_quality;
 
@@@@ -1984,6 +1993,12 @@@@ void *init_video_plugin (xine_t *xine, void *data) {
       "Cheating may speed up decoding but can also lead to decoding artefacts.\n"
       "A change of this setting will take effect with playing the next stream."),
     10, choose_speed_over_accuracy_cb, this);
+
+  this->enable_dri = xine->config->register_bool(config, "video.processing.ffmpeg_direct_rendering", 1,
+    _("Enable direct rendering"),
+    _("Disable direct rendering if you are experiencing lock-ups with\n"
+      "streams with lot of reference frames."),
+    10, dri_cb, this);
d276 2
a277 2
   return this;
 }
@


1.12
log
@Update to stable, xine-lib-1.1.21.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.11 2012/06/09 08:41:16 ajacoutot Exp $
@


1.11
log
@Several fixes from upstream:
- Fix MPEG2 parsing.
- Enable direct rendering for H.264.
- Fix DR1 frame garbage collector when using multithreaded decoding.
- Fix U-plane conversion (YUVJ444P -> YUV420).
- Add support for FLAC with Matroska.
- mmx_yuv2rgb() optimizations.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.10 2012/05/14 13:48:49 ajacoutot Exp $
d3 1
a3 10
- Moved FFmpeg API version checks to single header.
- Frame garbage collector in ff_reset.
- Fix compile against recent FFmpeg.
- Fix multithreaded initialization with API change.
- Fix decoding of full range YUV420 H.264 videos.
- Enable direct rendering for H.264.
- Convert full range YUV to MPEG range.
- Fix cropping.
- Fix DR1 frame garbage collector when using multithreaded decoding. 
- Fix U-plane conversion (YUVJ444P -> YUV420).
d5 3
a7 37
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Sat Dec 31 11:25:26 2011
+++ src/combined/ffmpeg/ff_video_decoder.c	Fri Jun  8 23:38:14 2012
@@@@ -51,6 +51,8 @@@@
 #  include <libpostproc/postprocess.h>
 #endif
 
+#include "ffmpeg_compat.h"
+
 #define VIDEOBUFSIZE        (128*1024)
 #define SLICE_BUFFER_SIZE   (1194*1024)
 
@@@@ -58,24 +60,6 @@@@
 
 #define ENABLE_DIRECT_RENDERING
 
-#if LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 32)
-#  define AVVIDEO 2
-#else
-#  define AVVIDEO 1
-#  define pp_context	pp_context_t
-#  define pp_mode	pp_mode_t
-#endif
-
-#if LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 112)
-#  define DEPRECATED_AVCODEC_THREAD_INIT 1
-#endif
-
-/* reordered_opaque appeared in libavcodec 51.68.0 */
-#define AVCODEC_HAS_REORDERED_OPAQUE
-#if LIBAVCODEC_VERSION_INT < 0x334400
-# undef AVCODEC_HAS_REORDERED_OPAQUE
-#endif
-
 typedef struct ff_video_decoder_s ff_video_decoder_t;
 
 typedef struct ff_video_class_s {
@@@@ -85,6 +69,7 @@@@ typedef struct ff_video_class_s {
d15 8
a22 57
@@@@ -146,14 +131,46 @@@@ struct ff_video_decoder_s {
 
   yuv_planes_t      yuv;
 
+#ifdef AVPaletteControl
   AVPaletteControl  palette_control;
+#endif
 
+  int               color_matrix, full2mpeg;
+  unsigned char     ytab[256], ctab[256];
+
 #ifdef LOG
   enum PixelFormat  debug_fmt;
 #endif
 };
 
+static void ff_check_colorspace (ff_video_decoder_t *this) {
+  int i, cm;
 
+  cm = this->context->colorspace << 1;
+  /* ffmpeg bug: color_range not set by svq3 decoder */
+  i = this->context->pix_fmt;
+  if (cm && ((i == PIX_FMT_YUVJ420P) || (i == PIX_FMT_YUVJ444P) ||
+    (this->context->color_range == AVCOL_RANGE_JPEG)))
+    cm |= 1;
+
+  /* report changes of colorspyce and/or color range */
+  if (cm != this->color_matrix) {
+    this->color_matrix = cm;
+    xprintf (this->stream->xine, XINE_VERBOSITY_LOG,
+      "ffmpeg_video_dec: color matrix #%d\n", cm >> 1);
+
+    this->full2mpeg = 0;
+    if (cm & 1) {
+      /* sigh. fall back to manual conversion */
+      this->full2mpeg = 1;
+      for (i = 0; i < 256; i++) {
+        this->ytab[i] = (219 * i + 127) / 255 + 16;
+        this->ctab[i] = 112 * (i - 128) / 127 + 128;
+      }
+    }
+  }
+}
+
 static void set_stream_info(ff_video_decoder_t *this) {
   _x_stream_info_set(this->stream, XINE_STREAM_INFO_VIDEO_WIDTH,  this->bih.biWidth);
   _x_stream_info_set(this->stream, XINE_STREAM_INFO_VIDEO_HEIGHT, this->bih.biHeight);
@@@@ -168,6 +185,8 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
   int width  = context->width;
   int height = context->height;
 
+  ff_check_colorspace (this);
+
   if (!this->bih.biWidth || !this->bih.biHeight) {
     this->bih.biWidth = width;
     this->bih.biHeight = height;
@@@@ -182,7 +201,8 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
d24 1
a24 9
   avcodec_align_dimensions(context, &width, &height);
 
-  if( this->context->pix_fmt != PIX_FMT_YUV420P && this->context->pix_fmt != PIX_FMT_YUVJ420P ) {
+  if (this->full2mpeg || (this->context->pix_fmt != PIX_FMT_YUV420P &&
+    this->context->pix_fmt != PIX_FMT_YUVJ420P)) {
     if (!this->is_direct_rendering_disabled) {
       xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
               _("ffmpeg_video_dec: unsupported frame format, DR1 disabled.\n"));
@@@@ -214,6 +234,8 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
d33 1
a33 34
@@@@ -234,7 +256,9 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
   /* We should really keep track of the ages of xine frames (see
    * avcodec_default_get_buffer in libavcodec/utils.c)
    * For the moment tell ffmpeg that every frame is new (age = bignumber) */
+#ifdef AVFRAMEAGE
   av_frame->age = 256*256*256*64;
+#endif
 
   av_frame->type= FF_BUFFER_TYPE_USER;
 
@@@@ -243,7 +267,7 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
   av_frame->reordered_opaque = context->reordered_opaque;
 #endif
 
-  xine_list_push_back(this->dr1_frames, av_frame);
+  xine_list_push_back(this->dr1_frames, img);
 
   return 0;
 }
@@@@ -260,10 +284,11 @@@@ static void release_buffer(struct AVCodecContext *cont
 
     xine_list_iterator_t it;
 
-    it = xine_list_find(this->dr1_frames, av_frame);
+    it = xine_list_find(this->dr1_frames, av_frame->opaque);
     assert(it);
-    if( it != NULL )
+    if( it != NULL ) {
       xine_list_remove(this->dr1_frames, it);
+    }
   } else {
     avcodec_default_release_buffer(context, av_frame);
   }
@@@@ -330,7 +355,7 @@@@ static void init_video_codec (ff_video_decoder_t *this
d42 1
a42 33
@@@@ -341,6 +366,13 @@@@ static void init_video_codec (ff_video_decoder_t *this
   if (this->class->choose_speed_over_accuracy)
     this->context->flags2 |= CODEC_FLAG2_FAST;
 
+#ifdef DEPRECATED_AVCODEC_THREAD_INIT
+  if (this->class->thread_count > 1) {
+    if (this->codec->id != CODEC_ID_SVQ3)
+      this->context->thread_count = this->class->thread_count;
+  }
+#endif
+
   pthread_mutex_lock(&ffmpeg_lock);
   if (avcodec_open (this->context, this->codec) < 0) {
     pthread_mutex_unlock(&ffmpeg_lock);
@@@@ -368,14 +400,13 @@@@ static void init_video_codec (ff_video_decoder_t *this
     }
   }
 
+#ifndef DEPRECATED_AVCODEC_THREAD_INIT
   if (this->class->thread_count > 1) {
     if (this->codec->id != CODEC_ID_SVQ3
-#ifndef DEPRECATED_AVCODEC_THREAD_INIT
-	&& avcodec_thread_init(this->context, this->class->thread_count) != -1
-#endif
-	)
+	&& avcodec_thread_init(this->context, this->class->thread_count) != -1)
       this->context->thread_count = this->class->thread_count;
   }
+#endif
 
   this->context->skip_loop_filter = skip_loop_filter_enum_values[this->class->skip_loop_filter_enum];
 
@@@@ -404,7 +435,7 @@@@ static void init_video_codec (ff_video_decoder_t *this
d51 1
a51 1
@@@@ -463,6 +494,12 @@@@ static void pp_quality_cb(void *user_data, xine_cfg_en
d64 1
a64 236
@@@@ -563,6 +600,8 @@@@ static void ff_convert_frame(ff_video_decoder_t *this,
     printf ("frame format == %08x\n", this->debug_fmt = this->context->pix_fmt);
 #endif
 
+  ff_check_colorspace (this);
+
   dy = img->base[0];
   du = img->base[1];
   dv = img->base[2];
@@@@ -793,54 +832,92 @@@@ static void ff_convert_frame(ff_video_decoder_t *this,
 
   } else {
 
-    for (y = 0; y < this->bih.biHeight; y++) {
-      xine_fast_memcpy (dy, sy, img->width);
+    int subsamph = (this->context->pix_fmt == PIX_FMT_YUV444P)
+                || (this->context->pix_fmt == PIX_FMT_YUVJ444P);
+    int subsampv = (this->context->pix_fmt != PIX_FMT_YUV420P)
+                && (this->context->pix_fmt != PIX_FMT_YUVJ420P);
 
-      dy += img->pitches[0];
+    if (this->full2mpeg) {
 
-      sy += this->av_frame->linesize[0];
-    }
+      uint8_t *ytab = this->ytab;
+      uint8_t *ctab = this->ctab;
+      uint8_t *p, *q;
+      int x;
 
-    for (y = 0; y < this->bih.biHeight / 2; y++) {
+      for (y = 0; y < this->bih.biHeight; y++) {
+        p = sy;
+        q = dy;
+        for (x = img->width; x > 0; x--) *q++ = ytab[*p++];
+        dy += img->pitches[0];
+        sy += this->av_frame->linesize[0];
 
-      if (this->context->pix_fmt != PIX_FMT_YUV444P) {
+      }
 
-        xine_fast_memcpy (du, su, img->width/2);
-        xine_fast_memcpy (dv, sv, img->width/2);
+      for (y = 0; y < this->bih.biHeight / 2; y++) {
+        if (!subsamph) {
+          p = su, q = du;
+          for (x = img->width / 2; x > 0; x--) *q++ = ctab[*p++];
+          p = sv, q = dv;
+          for (x = img->width / 2; x > 0; x--) *q++ = ctab[*p++];
+        } else {
+          p = su, q = du;
+          for (x = img->width / 2; x > 0; x--) {*q++ = ctab[*p]; p += 2;}
+          p = sv, q = dv;
+          for (x = img->width / 2; x > 0; x--) {*q++ = ctab[*p]; p += 2;}
+        }
+        du += img->pitches[1];
+        dv += img->pitches[2];
+        if (subsampv) {
+          su += 2 * this->av_frame->linesize[1];
+          sv += 2 * this->av_frame->linesize[2];
+        } else {
+          su += this->av_frame->linesize[1];
+          sv += this->av_frame->linesize[2];
+        }
+      }
 
-      } else {
+    } else {
 
-        int x;
-        uint8_t *src;
-        uint8_t *dst;
+      for (y = 0; y < this->bih.biHeight; y++) {
+        xine_fast_memcpy (dy, sy, img->width);
+        dy += img->pitches[0];
+        sy += this->av_frame->linesize[0];
+      }
 
-        /* subsample */
-
-        src = su; dst = du;
-        for (x=0; x<(img->width/2); x++) {
-          *dst = *src;
-          dst++;
-          src += 2;
+      for (y = 0; y < this->bih.biHeight / 2; y++) {
+        if (!subsamph) {
+          xine_fast_memcpy (du, su, img->width/2);
+          xine_fast_memcpy (dv, sv, img->width/2);
+        } else {
+          int x;
+          uint8_t *src;
+          uint8_t *dst;
+          src = su;
+          dst = du;
+          for (x = 0; x < (img->width / 2); x++) {
+            *dst = *src;
+            dst++;
+            src += 2;
+          }
+          src = sv;
+          dst = dv;
+          for (x = 0; x < (img->width / 2); x++) {
+            *dst = *src;
+            dst++;
+            src += 2;
+          }
         }
-        src = sv; dst = dv;
-        for (x=0; x<(img->width/2); x++) {
-          *dst = *src;
-          dst++;
-          src += 2;
+        du += img->pitches[1];
+        dv += img->pitches[2];
+        if (subsampv) {
+          su += 2*this->av_frame->linesize[1];
+          sv += 2*this->av_frame->linesize[2];
+        } else {
+          su += this->av_frame->linesize[1];
+          sv += this->av_frame->linesize[2];
         }
-
       }
 
-      du += img->pitches[1];
-      dv += img->pitches[2];
-
-      if (this->context->pix_fmt != PIX_FMT_YUV420P) {
-        su += 2*this->av_frame->linesize[1];
-        sv += 2*this->av_frame->linesize[2];
-      } else {
-        su += this->av_frame->linesize[1];
-        sv += this->av_frame->linesize[2];
-      }
     }
   }
 }
@@@@ -1044,7 +1121,9 @@@@ static void ff_handle_special_buffer (ff_video_decoder
     memcpy(this->context->extradata, buf->decoder_info_ptr[2],
       buf->decoder_info[2]);
 
-  } else if (buf->decoder_info[1] == BUF_SPECIAL_PALETTE) {
+  }
+#ifdef AVPaletteControl
+  else if (buf->decoder_info[1] == BUF_SPECIAL_PALETTE) {
     unsigned int i;
 
     palette_entry_t *demuxer_palette;
@@@@ -1063,7 +1142,9 @@@@ static void ff_handle_special_buffer (ff_video_decoder
     }
     decoder_palette->palette_changed = 1;
 
-  } else if (buf->decoder_info[1] == BUF_SPECIAL_RV_CHUNK_TABLE) {
+  }
+#endif
+  else if (buf->decoder_info[1] == BUF_SPECIAL_RV_CHUNK_TABLE) {
     int i;
 
     lprintf("BUF_SPECIAL_RV_CHUNK_TABLE\n");
@@@@ -1549,8 +1630,8 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
           img->duration = video_step_to_use;
 
         /* additionally crop away the extra pixels due to adjusting frame size above */
-        img->crop_right  = this->crop_right  + (img->width  - this->bih.biWidth);
-        img->crop_bottom = this->crop_bottom + (img->height - this->bih.biHeight);
+        img->crop_right  = img->width  - this->bih.biWidth;
+        img->crop_bottom = img->height - this->bih.biHeight;
 
         /* transfer some more frame settings for deinterlacing */
         img->progressive_frame = !this->av_frame->interlaced_frame;
@@@@ -1586,8 +1667,8 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
       img->duration  = video_step_to_use;
 
       /* additionally crop away the extra pixels due to adjusting frame size above */
-      img->crop_right  = ((this->bih.biWidth  <= 0) ? 0 : this->crop_right)  + (img->width  - this->bih.biWidth);
-      img->crop_bottom = ((this->bih.biHeight <= 0) ? 0 : this->crop_bottom) + (img->height - this->bih.biHeight);
+      img->crop_right  = this->bih.biWidth  <= 0 ? 0 : (img->width  - this->bih.biWidth);
+      img->crop_bottom = this->bih.biHeight <= 0 ? 0 : (img->height - this->bih.biHeight);
 
       img->bad_frame = 1;
       this->skipframes = img->draw(img, this->stream);
@@@@ -1663,8 +1744,22 @@@@ static void ff_reset (video_decoder_t *this_gen) {
   this->size = 0;
 
   if(this->context && this->decoder_ok)
+  {
+    xine_list_iterator_t it;
+
     avcodec_flush_buffers(this->context);
 
+    /* frame garbage collector here - workaround for buggy ffmpeg codecs that
+     * don't release their DR1 frames */
+    while( (it = xine_list_front(this->dr1_frames)) != NULL )
+    {
+      vo_frame_t *img = (vo_frame_t *)xine_list_get_value(this->dr1_frames, it);
+      if (img)
+        img->free(img);
+    }
+    xine_list_clear(this->dr1_frames);
+  }
+
   if (this->is_mpeg12)
     mpeg_parser_reset(this->mpeg_parser);
 
@@@@ -1725,7 +1820,6 @@@@ static void ff_dispose (video_decoder_t *this_gen) {
 
   if (this->decoder_ok) {
     xine_list_iterator_t it;
-    AVFrame *av_frame;
 
     pthread_mutex_lock(&ffmpeg_lock);
     avcodec_close (this->context);
@@@@ -1735,8 +1829,9 @@@@ static void ff_dispose (video_decoder_t *this_gen) {
      * don't release their DR1 frames */
     while( (it = xine_list_front(this->dr1_frames)) != NULL )
     {
-      av_frame = (AVFrame *)xine_list_get_value(this->dr1_frames, it);
-      release_buffer(this->context, av_frame);
+      vo_frame_t *img = (vo_frame_t *)xine_list_get_value(this->dr1_frames, it);
+      if (img)
+        img->free(img);
     }
 
     this->stream->video_out->close(this->stream->video_out, this->stream);
@@@@ -1796,7 +1891,9 @@@@ static video_decoder_t *ff_video_open_plugin (video_de
   this->av_frame          = avcodec_alloc_frame();
   this->context           = avcodec_alloc_context();
   this->context->opaque   = this;
+#ifdef AVPaletteControl
   this->context->palctrl  = NULL;
+#endif
 
   this->decoder_ok        = 0;
   this->decoder_init_mode = 1;
@@@@ -1888,6 +1985,12 @@@@ void *init_video_plugin (xine_t *xine, void *data) {
@


1.10
log
@Some fixes from upstream:
- Convert full range YUV to MPEG range.
- Fix cropping.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.9 2012/04/21 12:36:31 ajacoutot Exp $
d8 1
d11 2
d15 1
a15 1
+++ src/combined/ffmpeg/ff_video_decoder.c	Sun May 13 03:26:03 2012
d50 9
a58 1
@@@@ -146,14 +130,46 @@@@ struct ff_video_decoder_s {
d105 1
a105 1
@@@@ -168,6 +184,8 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
d114 1
a114 1
@@@@ -182,7 +200,8 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
d124 10
a133 1
@@@@ -234,7 +253,9 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
d143 33
a175 1
@@@@ -341,6 +362,13 @@@@ static void init_video_codec (ff_video_decoder_t *this
d189 1
a189 1
@@@@ -368,14 +396,13 @@@@ static void init_video_codec (ff_video_decoder_t *this
d207 23
a229 1
@@@@ -563,6 +590,8 @@@@ static void ff_convert_frame(ff_video_decoder_t *this,
d238 1
a238 1
@@@@ -793,54 +822,92 @@@@ static void ff_convert_frame(ff_video_decoder_t *this,
d279 1
a279 1
+          p = su, q = sv;
d367 1
a367 1
@@@@ -1044,7 +1111,9 @@@@ static void ff_handle_special_buffer (ff_video_decoder
d378 1
a378 1
@@@@ -1063,7 +1132,9 @@@@ static void ff_handle_special_buffer (ff_video_decoder
d389 1
a389 1
@@@@ -1549,8 +1620,8 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
d400 1
a400 1
@@@@ -1586,8 +1657,8 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
d411 1
a411 1
@@@@ -1663,8 +1734,22 @@@@ static void ff_reset (video_decoder_t *this_gen) {
a416 1
+    AVFrame *av_frame;
d424 3
a426 2
+      av_frame = (AVFrame *)xine_list_get_value(this->dr1_frames, it);
+      release_buffer(this->context, av_frame);
d434 21
a454 1
@@@@ -1796,7 +1881,9 @@@@ static video_decoder_t *ff_video_open_plugin (video_de
d464 13
@


1.9
log
@Upstream:
- Fix multithreaded initialization with API change.
- Fix decoding of full range YUV420 H.264 videos.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.8 2012/04/07 05:48:49 ajacoutot Exp $
d8 2
d12 1
a12 1
+++ src/combined/ffmpeg/ff_video_decoder.c	Sat Apr 21 01:25:36 2012
d47 1
a47 1
@@@@ -146,7 +130,9 @@@@ struct ff_video_decoder_s {
d55 3
d60 54
a113 1
@@@@ -234,7 +220,9 @@@@ static int get_buffer(AVCodecContext *context, AVFrame
d123 1
a123 1
@@@@ -341,6 +329,13 @@@@ static void init_video_codec (ff_video_decoder_t *this
d137 1
a137 1
@@@@ -368,14 +363,13 @@@@ static void init_video_codec (ff_video_decoder_t *this
d155 124
a278 3
@@@@ -834,7 +828,7 @@@@ static void ff_convert_frame(ff_video_decoder_t *this,
       du += img->pitches[1];
       dv += img->pitches[2];
d280 3
d284 10
a293 5
+      if (this->context->pix_fmt != PIX_FMT_YUV420P && this->context->pix_fmt != PIX_FMT_YUVJ420P) {
         su += 2*this->av_frame->linesize[1];
         sv += 2*this->av_frame->linesize[2];
       } else {
@@@@ -1044,7 +1038,9 @@@@ static void ff_handle_special_buffer (ff_video_decoder
d304 1
a304 1
@@@@ -1063,7 +1059,9 @@@@ static void ff_handle_special_buffer (ff_video_decoder
d315 23
a337 1
@@@@ -1663,8 +1661,22 @@@@ static void ff_reset (video_decoder_t *this_gen) {
d360 1
a360 1
@@@@ -1796,7 +1808,9 @@@@ static video_decoder_t *ff_video_open_plugin (video_de
@


1.8
log
@Bring a bunch of bugfixes from upstream.

from Brad
@
text
@d1 1
a1 1
$OpenBSD$
d6 2
d9 2
a10 2
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Fri Feb 17 22:42:05 2012
+++ src/combined/ffmpeg/ff_video_decoder.c	Fri Feb 17 22:42:10 2012
d65 42
a106 1
@@@@ -1044,7 +1032,9 @@@@ static void ff_handle_special_buffer (ff_video_decoder
d117 1
a117 1
@@@@ -1063,7 +1053,9 @@@@ static void ff_handle_special_buffer (ff_video_decoder
d128 1
a128 1
@@@@ -1663,8 +1655,22 @@@@ static void ff_reset (video_decoder_t *this_gen) {
d151 1
a151 1
@@@@ -1796,7 +1802,9 @@@@ static video_decoder_t *ff_video_open_plugin (video_de
@


1.7
log
@update to xine-lib 1.1.20, from Brad
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.6 2011/10/09 20:45:07 sthen Exp $
d3 3
a5 5
- Eliminate use of old FFmpeg APIs.
- RV30 & RV40 support.
- Fixed multithreaded decoding with lavc >= 52.112.0.
- VC-1: scan for extradata (sequence header) from preview buffers.
- Do not require preview buffers for MPEG1/2.
d7 12
a18 3
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Wed Mar 10 14:07:15 2010
+++ src/combined/ffmpeg/ff_video_decoder.c	Sun Oct  2 15:47:43 2011
@@@@ -58,6 +58,18 @@@@
d22 22
a43 36
+#if LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 32)
+#  define AVVIDEO 2
+#else
+#  define AVVIDEO 1
+#  define pp_context	pp_context_t
+#  define pp_mode	pp_mode_t
+#endif
+
+#if LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 112)
+#  define DEPRECATED_AVCODEC_THREAD_INIT 1
+#endif
+
 /* reordered_opaque appeared in libavcodec 51.68.0 */
 #define AVCODEC_HAS_REORDERED_OPAQUE
 #if LIBAVCODEC_VERSION_INT < 0x334400
@@@@ -116,8 +128,8 @@@@ struct ff_video_decoder_s {
 
   int               pp_quality;
   int               pp_flags;
-  pp_context_t     *pp_context;
-  pp_mode_t        *pp_mode;
+  pp_context       *our_context;
+  pp_mode          *our_mode;
 
   /* mpeg-es parsing */
   mpeg_parser_t    *mpeg_parser;
@@@@ -321,6 +333,10 @@@@ static void init_video_codec (ff_video_decoder_t *this
     this->context->flags |= CODEC_FLAG_EMU_EDGE;
   }
 
+  /* TJ. without this, it wont work at all on my machine */
+  this->context->codec_id = this->codec->id;
+  this->context->codec_type = this->codec->type;
+
   if (this->class->choose_speed_over_accuracy)
     this->context->flags2 |= CODEC_FLAG2_FAST;
d45 1
a45 1
@@@@ -353,7 +369,10 @@@@ static void init_video_codec (ff_video_decoder_t *this
d47 2
a48 5
   if (this->class->thread_count > 1) {
     if (this->codec->id != CODEC_ID_SVQ3
-        && avcodec_thread_init(this->context, this->class->thread_count) != -1)
+#ifndef DEPRECATED_AVCODEC_THREAD_INIT
+	&& avcodec_thread_init(this->context, this->class->thread_count) != -1
a49 29
+	)
       this->context->thread_count = this->class->thread_count;
   }
 
@@@@ -444,23 +463,23 @@@@ static void pp_change_quality (ff_video_decoder_t *thi
   this->pp_quality = this->class->pp_quality;
 
   if(this->pp_available && this->pp_quality) {
-    if(!this->pp_context && this->context)
-      this->pp_context = pp_get_context(this->context->width, this->context->height,
+    if(!this->our_context && this->context)
+      this->our_context = pp_get_context(this->context->width, this->context->height,
                                         this->pp_flags);
-    if(this->pp_mode)
-      pp_free_mode(this->pp_mode);
+    if(this->our_mode)
+      pp_free_mode(this->our_mode);
 
-    this->pp_mode = pp_get_mode_by_name_and_quality("hb:a,vb:a,dr:a",
+    this->our_mode = pp_get_mode_by_name_and_quality("hb:a,vb:a,dr:a",
                                                     this->pp_quality);
   } else {
-    if(this->pp_mode) {
-      pp_free_mode(this->pp_mode);
-      this->pp_mode = NULL;
+    if(this->our_mode) {
+      pp_free_mode(this->our_mode);
+      this->our_mode = NULL;
     }
d51 9
a59 94
-    if(this->pp_context) {
-      pp_free_context(this->pp_context);
-      this->pp_context = NULL;
+    if(this->our_context) {
+      pp_free_context(this->our_context);
+      this->our_context = NULL;
     }
   }
 }
@@@@ -502,17 +521,6 @@@@ static void init_postprocess (ff_video_decoder_t *this
 
 static int ff_handle_mpeg_sequence(ff_video_decoder_t *this, mpeg_parser_t *parser) {
 
-  /*
-   * init codec
-   */
-  if (this->decoder_init_mode) {
-    _x_meta_info_set_utf8(this->stream, XINE_META_INFO_VIDEOCODEC,
-                          "mpeg-1 (ffmpeg)");
-
-    init_video_codec (this, BUF_VIDEO_MPEG);
-    this->decoder_init_mode = 0;
-  }
-
   /* frame format change */
   if ((parser->width != this->bih.biWidth) ||
       (parser->height != this->bih.biHeight) ||
@@@@ -843,6 +851,67 @@@@ static void ff_check_bufsize (ff_video_decoder_t *this
   }
 }
 
+static int ff_vc1_find_header(ff_video_decoder_t *this, buf_element_t *buf)
+{
+  uint8_t *p = buf->content;
+
+  if (!p[0] && !p[1] && p[2] == 1 && p[3] == 0x0f) {
+    int i;
+
+    this->context->extradata = calloc(1, buf->size);
+    this->context->extradata_size = 0;
+
+    for (i = 0; i < buf->size && i < 128; i++) {
+      if (!p[i] && !p[i+1] && p[i+2]) {
+	lprintf("00 00 01 %02x at %d\n", p[i+3], i);
+	if (p[i+3] != 0x0e && p[i+3] != 0x0f)
+	  break;
+      }
+      this->context->extradata[i] = p[i];
+      this->context->extradata_size++;
+    }
+
+    lprintf("ff_video_decoder: found VC1 sequence header\n");
+    return 1;
+  }
+
+  xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
+	  "ffmpeg_video_dec: VC1 extradata missing !\n");
+  return 0;
+}
+
+static int ff_check_extradata(ff_video_decoder_t *this, unsigned int codec_type, buf_element_t *buf)
+{
+  if (this->context && this->context->extradata)
+    return 1;
+
+  switch (codec_type) {
+  case BUF_VIDEO_VC1:
+    return ff_vc1_find_header(this, buf);
+  default:;
+  }
+
+  return 1;
+}
+
+static void ff_init_mpeg12_mode(ff_video_decoder_t *this)
+{
+  this->is_mpeg12 = 1;
+
+  if (this->decoder_init_mode) {
+    _x_meta_info_set_utf8(this->stream, XINE_META_INFO_VIDEOCODEC,
+                          "mpeg-1 (ffmpeg)");
+
+    init_video_codec (this, BUF_VIDEO_MPEG);
+    this->decoder_init_mode = 0;
+  }
+
+  if ( this->mpeg_parser == NULL ) {
+    this->mpeg_parser = calloc(1, sizeof(mpeg_parser_t));
+    mpeg_parser_init(this->mpeg_parser);
+  }
+}
+
 static void ff_handle_preview_buffer (ff_video_decoder_t *this, buf_element_t *buf) {
   int codec_type;
d61 1
a61 1
@@@@ -850,15 +919,14 @@@@ static void ff_handle_preview_buffer (ff_video_decoder
d63 3
a65 10
   codec_type = buf->type & 0xFFFF0000;
   if (codec_type == BUF_VIDEO_MPEG) {
-    this->is_mpeg12 = 1;
-    if ( this->mpeg_parser == NULL ) {
-      this->mpeg_parser = calloc(1, sizeof(mpeg_parser_t));
-      mpeg_parser_init(this->mpeg_parser);
-      this->decoder_init_mode = 0;
-    }
+    ff_init_mpeg12_mode(this);
   }
d67 1
a67 24
   if (this->decoder_init_mode && !this->is_mpeg12) {
+
+    if (!ff_check_extradata(this, codec_type, buf))
+      return;
+
     init_video_codec(this, codec_type);
     init_postprocess(this);
     this->decoder_init_mode = 0;
@@@@ -902,6 +970,8 @@@@ static void ff_handle_header_buffer (ff_video_decoder_
       switch (codec_type) {
       case BUF_VIDEO_RV10:
       case BUF_VIDEO_RV20:
+      case BUF_VIDEO_RV30:
+      case BUF_VIDEO_RV40:
         this->bih.biWidth  = _X_BE_16(&this->buf[12]);
         this->bih.biHeight = _X_BE_16(&this->buf[14]);
 
@@@@ -1022,6 +1092,11 @@@@ static void ff_handle_mpeg12_buffer (ff_video_decoder_
 
   lprintf("handle_mpeg12_buffer\n");
 
+  if (!this->is_mpeg12) {
+    /* initialize mpeg parser */
+    ff_init_mpeg12_mode(this);
d69 3
a71 2
+
   while ((size > 0) || (flush == 1)) {
d73 2
a74 2
     uint8_t *current;
@@@@ -1055,12 +1130,26 @@@@ static void ff_handle_mpeg12_buffer (ff_video_decoder_
d76 1
d78 2
a79 5
     /* skip decoding b frames if too late */
+#if AVVIDEO > 1
+    this->context->skip_frame = (this->skipframes > 0) ? AVDISCARD_NONREF : AVDISCARD_DEFAULT;
+#else
     this->context->hurry_up = (this->skipframes > 0);
d81 2
d84 30
a113 27
     lprintf("avcodec_decode_video: size=%d\n", this->mpeg_parser->buffer_size);
+#if AVVIDEO > 1
+    AVPacket avpkt;
+    av_init_packet(&avpkt);
+    avpkt.data = (uint8_t *)this->mpeg_parser->chunk_buffer;
+    avpkt.size = this->mpeg_parser->buffer_size;
+    avpkt.flags = AV_PKT_FLAG_KEY;
+    len = avcodec_decode_video2 (this->context, this->av_frame,
+				 &got_picture, &avpkt);
+#else
     len = avcodec_decode_video (this->context, this->av_frame,
                                 &got_picture, this->mpeg_parser->chunk_buffer,
                                 this->mpeg_parser->buffer_size);
+#endif
     lprintf("avcodec_decode_video: decoded_size=%d, got_picture=%d\n",
             len, got_picture);
     len = current - buf->content - offset;
@@@@ -1112,7 +1201,13 @@@@ static void ff_handle_mpeg12_buffer (ff_video_decoder_
 
     } else {
 
-      if (this->context->hurry_up) {
+      if (
+#if AVVIDEO > 1
+	  this->context->skip_frame != AVDISCARD_DEFAULT
+#else
+	  this->context->hurry_up
a114 135
+	 ) {
         /* skipped frame, output a bad frame */
         img = this->stream->video_out->get_frame (this->stream->video_out,
                                                   this->bih.biWidth,
@@@@ -1178,49 +1273,6 @@@@ static void ff_check_pts_tagging(ff_video_decoder_t *t
 }
 #endif /* AVCODEC_HAS_REORDERED_OPAQUE */
 
-static int ff_vc1_find_header(ff_video_decoder_t *this, buf_element_t *buf)
-{
-  uint8_t *p = buf->content;
-
-  if (!p[0] && !p[1] && p[2] == 1 && p[3] == 0x0f) {
-    int i;
-
-    this->context->extradata = calloc(1, buf->size);
-    this->context->extradata_size = 0;
-
-    for (i = 0; i < buf->size && i < 128; i++) {
-      if (!p[i] && !p[i+1] && p[i+2]) {
-	lprintf("00 00 01 %02x at %d\n", p[i+3], i);
-	if (p[i+3] != 0x0e && p[i+3] != 0x0f)
-	  break;
-      }
-      this->context->extradata[i] = p[i];
-      this->context->extradata_size++;
-    }
-
-    lprintf("ff_video_decoder: found VC1 sequence header\n");
-    return 1;
-  }
-
-  xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
-	  "ffmpeg_video_dec: VC1 extradata missing !\n");
-  return 0;
-}
-
-static int ff_check_extradata(ff_video_decoder_t *this, unsigned int codec_type, buf_element_t *buf)
-{
-  if (this->context && this->context->extradata)
-    return 1;
-
-  switch (codec_type) {
-  case BUF_VIDEO_VC1:
-    return ff_vc1_find_header(this, buf);
-  default:;
-  }
-
-  return 1;
-}
-
 static void ff_handle_buffer (ff_video_decoder_t *this, buf_element_t *buf) {
   uint8_t *chunk_buf = this->buf;
   AVRational avr00 = {0, 1};
@@@@ -1229,7 +1281,7 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
 
   if (!this->decoder_ok) {
     if (this->decoder_init_mode) {
-      int codec_type = buf->type & 0xFFFF0000;
+      int codec_type = buf->type & (BUF_MAJOR_MASK | BUF_DECODER_MASK);
 
       if (!ff_check_extradata(this, codec_type, buf))
 	return;
@@@@ -1304,13 +1356,25 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
         got_picture = 0;
       } else {
         /* skip decoding b frames if too late */
+#if AVVIDEO > 1
+	this->context->skip_frame = (this->skipframes > 0) ? AVDISCARD_NONREF : AVDISCARD_DEFAULT;
+#else
         this->context->hurry_up = (this->skipframes > 0);
-
+#endif
         lprintf("buffer size: %d\n", this->size);
+#if AVVIDEO > 1
+	AVPacket avpkt;
+	av_init_packet(&avpkt);
+	avpkt.data = (uint8_t *)&chunk_buf[offset];
+	avpkt.size = this->size;
+	avpkt.flags = AV_PKT_FLAG_KEY;
+	len = avcodec_decode_video2 (this->context, this->av_frame,
+				     &got_picture, &avpkt);
+#else
         len = avcodec_decode_video (this->context, this->av_frame,
                                     &got_picture, &chunk_buf[offset],
                                     this->size);
-
+#endif
 #ifdef AVCODEC_HAS_REORDERED_OPAQUE
         /* reset consumed pts value */
         this->context->reordered_opaque = ff_tag_pts(this, 0);
@@@@ -1432,7 +1496,7 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
                         img->base, img->pitches,
                         img->width, img->height,
                         this->av_frame->qscale_table, this->av_frame->qstride,
-                        this->pp_mode, this->pp_context,
+                        this->our_mode, this->our_context,
                         this->av_frame->pict_type);
 
         } else if (!this->av_frame->opaque) {
@@@@ -1555,7 +1619,7 @@@@ static void ff_decode_data (video_decoder_t *this_gen,
       if (buf->pts)
 	this->pts = buf->pts;
 
-      if (this->is_mpeg12) {
+      if ((buf->type & 0xFFFF0000) == BUF_VIDEO_MPEG) {
 	ff_handle_mpeg12_buffer(this, buf);
       } else {
 	ff_handle_buffer(this, buf);
@@@@ -1676,11 +1740,11 @@@@ static void ff_dispose (video_decoder_t *this_gen) {
     free(this->buf);
   this->buf = NULL;
 
-  if(this->pp_context)
-    pp_free_context(this->pp_context);
+  if(this->our_context)
+    pp_free_context(this->our_context);
 
-  if(this->pp_mode)
-    pp_free_mode(this->pp_mode);
+  if(this->our_mode)
+    pp_free_mode(this->our_mode);
 
   mpeg_parser_dispose(this->mpeg_parser);
 
@@@@ -1721,8 +1785,8 @@@@ static video_decoder_t *ff_video_open_plugin (video_de
   this->aspect_ratio      = 0;
 
   this->pp_quality        = 0;
-  this->pp_context        = NULL;
-  this->pp_mode           = NULL;
+  this->our_context       = NULL;
+  this->our_mode          = NULL;
 
   this->mpeg_parser       = NULL;
d116 2
@


1.6
log
@Backport support to xine-lib for VP8 (WebM) and RealVideo 3/4, improved
24-bit LPCM support and various bug fixes. From Brad.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_video_decoder_c,v 1.5 2011/06/13 08:10:01 dcoppa Exp $
@


1.5
log
@Eliminate use of old FFmpeg APIs.

OK myself, sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
d3 5
a7 1
Eliminate use of old FFmpeg APIs.
d10 2
a11 2
+++ src/combined/ffmpeg/ff_video_decoder.c	Mon May 16 20:42:58 2011
@@@@ -58,6 +58,14 @@@@
d23 4
d30 1
a30 1
@@@@ -116,8 +124,8 @@@@ struct ff_video_decoder_s {
d41 24
a64 1
@@@@ -444,23 +452,23 @@@@ static void pp_change_quality (ff_video_decoder_t *thi
d99 129
a227 1
@@@@ -1055,12 +1063,26 @@@@ static void ff_handle_mpeg12_buffer (ff_video_decoder_
d254 1
a254 1
@@@@ -1112,7 +1134,13 @@@@ static void ff_handle_mpeg12_buffer (ff_video_decoder_
d269 60
a328 1
@@@@ -1304,13 +1332,25 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
d356 1
a356 1
@@@@ -1432,7 +1472,7 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
d365 10
a374 1
@@@@ -1676,11 +1716,11 @@@@ static void ff_dispose (video_decoder_t *this_gen) {
d390 1
a390 1
@@@@ -1721,8 +1761,8 @@@@ static video_decoder_t *ff_video_open_plugin (video_de
@


1.4
log
@remove 0-byte files, spotted by Brad
@
text
@d1 173
@


1.3
log
@update xine-lib to 1.1.19 and switch to new-style LIB_DEPENDS/WANTLIB
from Brad, thanks landry@@ for testing in bulk build
@
text
@@


1.2
log
@update to 1.1.18.1, from Brad
@
text
@a0 24
$OpenBSD$
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Fri Mar 12 19:28:57 2010
+++ src/combined/ffmpeg/ff_video_decoder.c	Fri Mar 12 19:30:34 2010
@@@@ -309,11 +309,6 @@@@ static void init_video_codec (ff_video_decoder_t *this
 
   lprintf("lavc decoder found\n");
 
-  /* force (width % 8 == 0), otherwise there will be
-   * display problems with Xv.
-   */
-  this->bih.biWidth = (this->bih.biWidth + 1) & (~1);
-
   this->context->width = this->bih.biWidth;
   this->context->height = this->bih.biHeight;
   this->context->stream_codec_tag = this->context->codec_tag =
@@@@ -1389,7 +1384,7 @@@@ static void ff_handle_buffer (ff_video_decoder_t *this
 	        (this->context->pix_fmt == PIX_FMT_RGB24) ||
 	        (this->context->pix_fmt == PIX_FMT_PAL8)) {
 	      this->output_format = XINE_IMGFMT_YUY2;
-	      init_yuv_planes(&this->yuv, this->bih.biWidth, this->bih.biHeight);
+	      init_yuv_planes(&this->yuv, (this->bih.biWidth + 15) & ~15, this->bih.biHeight);
 	      this->yuv_init = 1;
 	    }
 	    this->cs_convert_init = 1;
@


1.1
log
@Update to xine-lib 1.1.7 and disable win32 codec support, from Brad.
oops, missed a 'cvs add'.
@
text
@d2 3
a4 7
--- src/combined/ffmpeg/ff_video_decoder.c.orig	Fri Dec  4 19:13:34 2009
+++ src/combined/ffmpeg/ff_video_decoder.c	Fri Dec  4 20:39:22 2009
@@@@ -1180,6 +1180,7 @@@@ static void ff_check_pts_tagging(ff_video_decoder_t *t
     }
   }
 }
+#endif /* AVCODEC_HAS_REORDERED_OPAQUE */
d6 1
a6 5
 static int ff_vc1_find_header(ff_video_decoder_t *this, buf_element_t *buf)
 {
@@@@ -1224,7 +1225,6 @@@@ static int ff_check_extradata(ff_video_decoder_t *this
   return 1;
 }
d8 17
a24 4
-#endif /* AVCODEC_HAS_REORDERED_OPAQUE */
 static void ff_handle_buffer (ff_video_decoder_t *this, buf_element_t *buf) {
   uint8_t *chunk_buf = this->buf;
   AVRational avr00 = {0, 1};
@

