head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@# @;


1.10
date	2015.09.18.05.45.26;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	Qv9ZlTnZcEAiwBTG;

1.9
date	2014.07.13.17.02.59;	author brad;	state dead;
branches;
next	1.8;
commitid	9wyF29wRMGhOFlhZ;

1.8
date	2014.07.12.21.55.35;	author brad;	state Exp;
branches;
next	1.7;
commitid	cTxEMKefKf6oEqf2;

1.7
date	2013.11.30.22.13.37;	author brad;	state dead;
branches;
next	1.6;

1.6
date	2013.08.28.15.30.35;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.07.35.30;	author ajacoutot;	state dead;
branches;
next	1.4;

1.4
date	2012.04.07.05.48.49;	author ajacoutot;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.16.00.43.17;	author sthen;	state dead;
branches;
next	1.2;

1.2
date	2011.10.09.20.45.07;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.13.08.10.01;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Back port a bug fix:
- fix AVCodecContext/AVFrame freeing.

from Brad (maintainer)
@
text
@$OpenBSD$

Fix AVCodecContext/AVFrame freeing.

--- src/combined/ffmpeg/ff_audio_decoder.c.orig	Thu Sep 17 17:50:50 2015
+++ src/combined/ffmpeg/ff_audio_decoder.c	Thu Sep 17 17:51:58 2015
@@@@ -1117,11 +1117,11 @@@@ static void ff_audio_dispose (audio_decoder_t *this_ge
   free16 (this->buf);
   free16 (this->decode_buffer);
 
-  if(this->context && this->context->extradata)
-    free(this->context->extradata);
-
-  if(this->context)
-    av_free(this->context);
+  if (this->context) {
+    _x_freep (&this->context->extradata);
+    this->context->extradata_size = 0;
+    avcodec_free_context (&this->context);
+  }
 
   free (this_gen);
 }
@


1.9
log
@Revert the decoders change in the previous commit for the time being. While
testing 1.2.6 I encountered a stack overflow in Xine-lib I had not experienced
with earlier testing; happens when decoding AAC. Possibly related to additional
multi-threaded decoding changes made in 1.2.6 but since this wasn't a high
priority change it can wait.

ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_audio_decoder_c,v 1.8 2014/07/12 21:55:35 brad Exp $
d3 1
a3 1
Enable parser for AC3, DTS, AAC.
d5 5
a9 5
--- src/combined/ffmpeg/ff_audio_decoder.c.orig	Wed Feb 26 10:49:10 2014
+++ src/combined/ffmpeg/ff_audio_decoder.c	Thu Jun 12 05:12:13 2014
@@@@ -196,14 +196,17 @@@@ static void ff_audio_init_codec(ff_audio_decoder_t *th
   this->context->codec_type  = this->codec->type;
   this->context->codec_tag   = _x_stream_info_get(this->stream, XINE_STREAM_INFO_AUDIO_FOURCC);
d11 10
a20 14
-  /* Use parser for EAC3, AAC LATM and MPEG.
+  /* Use parser for AC3, EAC3, DTS, AAC, AAC LATM and MPEG.
    * Fixes:
    *  - DVB streams where multiple AAC LATM frames are packed to single PES
    *  - DVB streams where MPEG audio frames do not follow PES packet boundaries
    */
 #if AVPARSE > 1
-  if (codec_type == BUF_AUDIO_AAC_LATM ||
+  if (codec_type == BUF_AUDIO_AAC ||
+      codec_type == BUF_AUDIO_AAC_LATM ||
+      codec_type == BUF_AUDIO_A52 ||
       codec_type == BUF_AUDIO_EAC3 ||
+      codec_type == BUF_AUDIO_DTS ||
       codec_type == BUF_AUDIO_MPEG) {
d22 2
a23 1
     xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
@


1.8
log
@- Reducing the external dependencies a bit by utilizing FFmpeg instead
  of the reference decoders for AAC, AC3 and DTS.
- A build fix for LLVM.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.7
log
@Update to Xine-lib 1.2.4.

ok juanfra@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_audio_decoder_c,v 1.6 2013/08/28 15:30:35 brad Exp $
d3 1
a3 1
Fix multichannel playback.
d5 3
a7 67
--- src/combined/ffmpeg/ff_audio_decoder.c.orig	Mon Aug 19 21:55:26 2013
+++ src/combined/ffmpeg/ff_audio_decoder.c	Mon Aug 19 21:55:37 2013
@@@@ -46,6 +46,8 @@@@
 
 #define AUDIOBUFSIZE (64 * 1024)
 
+#define MAX_CHANNELS 6
+
 typedef struct {
   audio_decoder_class_t   decoder_class;
 
@@@@ -59,11 +61,6 @@@@ typedef struct ff_audio_decoder_s {
 
   xine_stream_t    *stream;
 
-  int               output_open;
-  int               audio_channels;
-  int               audio_bits;
-  int               audio_sample_rate;
-
   unsigned char    *buf;
   int               bufsize;
   int               size;
@@@@ -78,6 +75,29 @@@@ typedef struct ff_audio_decoder_s {
 #if AVAUDIO > 3
   AVFrame          *av_frame;
 #endif
+
+  /* decoder settings */
+  int               ff_channels;
+  int               ff_bits;
+  int               ff_sample_rate;
+  int64_t           ff_map;
+
+  /* channel mixer settings */
+  /* map[ao_channel] = ff_channel */
+  int8_t            map[MAX_CHANNELS];
+  int8_t            left[4], right[4];
+  /* how many left[] / right[] entries are in use */
+  int               front_mixes;
+  /* volume adjustment */
+  int               downmix_shift;
+
+  /* audio out settings */
+  int               output_open;
+  int               ao_channels;
+  int               new_mode;
+  int               ao_mode;
+  int               ao_caps;
+
 } ff_audio_decoder_t;
 
 
@@@@ -163,11 +183,11 @@@@ static void ff_audio_init_codec(ff_audio_decoder_t *th
   /* Current ffmpeg audio decoders usually use 16 bits/sample
    * buf->decoder_info[2] can't be used as it doesn't refer to the output
    * bits/sample for some codecs (e.g. MS ADPCM) */
-  this->audio_bits = 16;
+  this->ff_bits = 16;
 
-  this->context->bits_per_sample = this->audio_bits;
-  this->context->sample_rate = this->audio_sample_rate;
-  this->context->channels    = this->audio_channels;
+  this->context->bits_per_sample = this->ff_bits;
+  this->context->sample_rate = this->ff_sample_rate;
+  this->context->channels    = this->ff_channels;
   this->context->codec_id    = this->codec->id;
a9 737
@@@@ -237,8 +257,8 @@@@ static void ff_handle_header_buffer(ff_audio_decoder_t
   }
 
   if(buf->decoder_flags & BUF_FLAG_STDHEADER) {
-    this->audio_sample_rate = buf->decoder_info[1];
-    this->audio_channels    = buf->decoder_info[3];
+    this->ff_sample_rate = buf->decoder_info[1];
+    this->ff_channels    = buf->decoder_info[3];
 
     if(this->size) {
       audio_header = (xine_waveformatex *)this->buf;
@@@@ -259,15 +279,15 @@@@ static void ff_handle_header_buffer(ff_audio_decoder_t
 
     switch(codec_type) {
     case BUF_AUDIO_14_4:
-      this->audio_sample_rate = 8000;
-      this->audio_channels    = 1;
+      this->ff_sample_rate = 8000;
+      this->ff_channels    = 1;
 
       this->context->block_align = 240;
       break;
     case BUF_AUDIO_28_8:
-      this->audio_sample_rate = _X_BE_16(&this->buf[0x30]);
-      this->audio_channels    = this->buf[0x37];
-      /* this->audio_bits = buf->content[0x35] */
+      this->ff_sample_rate = _X_BE_16(&this->buf[0x30]);
+      this->ff_channels    = this->buf[0x37];
+      /* this->ff_bits = buf->content[0x35] */
 
       this->context->block_align = _X_BE_32(&this->buf[0x18]);
 
@@@@ -284,7 +304,7 @@@@ static void ff_handle_header_buffer(ff_audio_decoder_t
 
       xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
               "ffmpeg_audio_dec: 28_8 audio channels %d bits %d sample rate %d block align %d\n",
-              this->audio_channels, this->audio_bits, this->audio_sample_rate,
+              this->ff_channels, this->ff_bits, this->ff_sample_rate,
               this->context->block_align);
       break;
     case BUF_AUDIO_COOK:
@@@@ -295,15 +315,15 @@@@ static void ff_handle_header_buffer(ff_audio_decoder_t
 
         version = _X_BE_16 (this->buf+4);
         if (version == 4) {
-          this->audio_sample_rate = _X_BE_16 (this->buf+48);
-          this->audio_bits = _X_BE_16 (this->buf+52);
-          this->audio_channels = _X_BE_16 (this->buf+54);
+          this->ff_sample_rate = _X_BE_16 (this->buf+48);
+          this->ff_bits = _X_BE_16 (this->buf+52);
+          this->ff_channels = _X_BE_16 (this->buf+54);
           data_len = _X_BE_32 (this->buf+67);
           extradata = 71;
         } else {
-          this->audio_sample_rate = _X_BE_16 (this->buf+54);
-          this->audio_bits = _X_BE_16 (this->buf+58);
-          this->audio_channels = _X_BE_16 (this->buf+60);
+          this->ff_sample_rate = _X_BE_16 (this->buf+54);
+          this->ff_bits = _X_BE_16 (this->buf+58);
+          this->ff_channels = _X_BE_16 (this->buf+60);
           data_len = _X_BE_32 (this->buf+74);
           extradata = 78;
         }
@@@@ -311,7 +331,7 @@@@ static void ff_handle_header_buffer(ff_audio_decoder_t
 
         xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
                 "ffmpeg_audio_dec: cook audio channels %d bits %d sample rate %d block align %d\n",
-                this->audio_channels, this->audio_bits, this->audio_sample_rate,
+                this->ff_channels, this->ff_bits, this->ff_sample_rate,
                 this->context->block_align);
 
         if (extradata + data_len > this->size)
@@@@ -363,11 +383,146 @@@@ static void ff_audio_output_close(ff_audio_decoder_t *
     this->output_open = 0;
   }
 
-  this->audio_bits = 0;
-  this->audio_sample_rate = 0;
-  this->audio_channels = 0;
+  this->ff_sample_rate = 0;
+  this->ao_mode = 0;
 }
 
+static void ff_map_channels (ff_audio_decoder_t *this) {
+  uint64_t ff_map;
+  int caps = this->stream->audio_out->get_capabilities (this->stream->audio_out);
+
+  /* safety kludge for very old libavcodec */
+#ifdef AV_CH_FRONT_LEFT
+  ff_map = this->context->channel_layout;
+  if (!ff_map) /* wma2 bug */
+#endif
+    ff_map = (1 << this->context->channels) - 1;
+
+  if ((caps != this->ao_caps) || (ff_map != this->ff_map)) {
+    int i, j;
+    /* ff: see names[] below; xine: L R RL RR C LFE */
+    const int8_t base_map[] = {0, 1, 4, 5, 2, 3, -1, -1, -1, 2, 3};
+    int8_t name_map[MAX_CHANNELS];
+    const int modes[] = {
+      AO_CAP_MODE_MONO, AO_CAP_MODE_STEREO,
+      AO_CAP_MODE_4CHANNEL, AO_CAP_MODE_4_1CHANNEL,
+      AO_CAP_MODE_5CHANNEL, AO_CAP_MODE_5_1CHANNEL
+    };
+    const int num_modes = sizeof (modes) / sizeof (modes[0]);
+    const int8_t mode_channels[]   = {1, 2, 4, 6, 6, 6};
+    const int8_t wishlist[] = {
+      0, 1, 2, 3, 4, 5, /* mono */
+      1, 2, 3, 4, 5, 0, /* stereo */
+      5, 4, 3, 2, 1, 0, /* center + lfe */
+      4, 5, 2, 3, 1, 0, /* center */
+      3, 5, 2, 4, 1, 0, /* lfe */
+      2, 3, 4, 5, 1, 0  /* 4.0 */
+    };
+    const int8_t *tries;
+
+    this->ao_caps     = caps;
+    this->ff_map      = ff_map;
+    this->ff_channels = this->context->channels;
+
+    /* silence out */
+    for (i = 0; i < MAX_CHANNELS; i++)
+      this->map[i] = -1;
+    for (i = 0; i < 4; i++)
+      this->left[i] = this->right[i] = -1;
+
+    /* set up raw map and ao mode wishlist */
+    if (this->ff_channels == 1) { /* mono */
+      name_map[0] = 2;
+      this->left[0] = this->right[0] = 0;
+      tries = wishlist + 0 * num_modes;
+    } else if (this->ff_channels == 2) { /* stereo */
+      name_map[0] = 0;
+      name_map[1] = 1;
+      this->left[0] = 0;
+      this->right[0] = 1;
+      tries = wishlist + 1 * num_modes;
+    } else {
+      for (i = j = 0; i < sizeof (base_map) / sizeof (base_map[0]); i++) {
+        if ((ff_map >> i) & 1) {
+          int8_t target = base_map[i];
+          if ((target >= 0) && (this->map[target] < 0))
+            this->map[target] = j;
+          name_map[j] = i; /* for debug output below */
+          j++;
+        }
+      }
+      this->left[0]  = this->map[0] < 0 ? 0 : this->map[0];
+      this->map[0]   = -1;
+      this->right[0] = this->map[1] < 0 ? 1 : this->map[1];
+      this->map[1]   = -1;
+      tries = wishlist
+        + (2 + (this->map[4] < 0 ? 2 : 0) + (this->map[5] < 0 ? 1 : 0)) * num_modes;
+    }
+    this->front_mixes = 1;
+
+    /* find ao mode */
+    for (i = 0; i < num_modes; i++) if (caps & modes[tries[i]]) break;
+    i = i == num_modes ? 1 : tries[i];
+    this->new_mode = modes[i];
+    this->ao_channels = mode_channels[i];
+
+    /* mix center to front */
+    if ((this->map[4] >= 0) && !((0x30 >> i) & 1)) {
+      this->left[this->front_mixes]    = this->map[4];
+      this->right[this->front_mixes++] = this->map[4];
+      this->map[4] = -1;
+    }
+    /* mix lfe to front */
+    if ((this->map[5] >= 0) && !((0x28 >> i) & 1)) {
+      this->left[this->front_mixes]    = this->map[5];
+      this->right[this->front_mixes++] = this->map[5];
+      this->map[5] = -1;
+    }
+    /* mix surround to front */
+    if ((this->map[2] >= 0) && (this->map[3] >= 0) && !((0x3c >> i) & 1)) {
+      this->left[this->front_mixes]    = this->map[2];
+      this->right[this->front_mixes++] = this->map[3];
+      this->map[2] = -1;
+      this->map[3] = -1;
+    }
+
+    this->downmix_shift = this->front_mixes > 1 ? 1 : 0;
+    /* this will be on the safe side but usually too soft?? */
+#if 0
+    if (this->front_mixes > 2)
+      this->downmix_shift = 2;
+#endif
+
+    if (this->stream->xine->verbosity >= XINE_VERBOSITY_LOG) {
+      const int8_t *names[] = {
+        "left", "right", "center", "bass",
+        "rear left", "rear right",
+        "half left", "half right",
+        "rear center",
+        "side left", "side right"
+      };
+      int8_t buf[200];
+      int p = sprintf (buf, "ff_audio_dec: channel layout: ");
+      int8_t *indx = this->left;
+      for (i = 0; i < 2; i++) {
+        buf[p++] = '[';
+        for (j = 0; j < this->front_mixes; j++)
+          p += sprintf (buf + p, "%s%s", names[name_map[indx[j]]], (j < this->front_mixes - 1) ? " + " : "");
+        buf[p++] = ']';
+        buf[p++] = ' ';
+        indx = this->right;
+      }
+      for (i = 2; i < this->ao_channels; i++)
+        p += sprintf (buf + p, "[%s] ",
+          ((this->map[i] < 0) || (this->map[i] > 5)) ? (const int8_t *)"-" : names[name_map[this->map[i]]]);
+      buf[p++] = '\n';
+      fwrite (buf, 1, p, stdout);
+    }
+  }
+}
+
+#define CLIP_16(v) ((v + 0x8000) & ~0xffff ? (v >> 31) ^ 0x7fff : v)
+
 static int ff_audio_decode (ff_audio_decoder_t *this,
   int16_t *decode_buffer, int *decode_buffer_size, uint8_t *buf, int size) {
   int consumed;
@@@@ -408,106 +563,250 @@@@ static int ff_audio_decode (ff_audio_decoder_t *this,
   avpkt.flags = AV_PKT_FLAG_KEY;
 #  if AVAUDIO > 3
   int got_frame;
-  const float gain = this->class->gain;
+  float gain = this->class->gain;
   if (!this->av_frame)
     this->av_frame = avcodec_alloc_frame ();
 
   consumed = avcodec_decode_audio4 (this->context, this->av_frame, &got_frame, &avpkt);
   if ((consumed >= 0) && got_frame) {
+    /* setup may have altered while decoding */
+    ff_map_channels (this);
+
     int16_t *q = decode_buffer;
     int samples = this->av_frame->nb_samples;
-    int channels = this->context->channels;
-    int bytes, i, j;
+    int channels = this->ao_channels;
+    int bytes, i, j, shift = this->downmix_shift;
     /* limit buffer */
-    if (channels > 12)
-      channels = 12;
     if (*decode_buffer_size < samples * channels * 2)
       samples = *decode_buffer_size / (channels * 2);
     bytes = samples * channels * 2;
     *decode_buffer_size = bytes;
-    /* convert to packed int16_t. I guess there is something
-       in libavfilter but also another dependency... */
+    /* TJ. convert to packed int16_t while respecting the user's speaker arrangement.
+       I tried to speed up and not to pull in libswresample. */
+    for (i = 2; i < channels; i++) if (this->map[i] < 0) {
+      /* clear if there is an upmix mute channel */
+      memset (q, 0, bytes);
+      break;
+    }
+    /* For mono output, downmix to stereo first */
+    if ((channels == 1) && (this->ff_channels > 1))
+      channels = 2;
+    gain /= (float)(1 << shift);
     switch (this->context->sample_fmt) {
+#define MIX_AUDIO(stype,planar,idx,num,dindx) {\
+    stype *p1, *p2, *p3, *p4;\
+    int i, sstep;\
+    int8_t *x = idx;\
+    int16_t *dptr = (int16_t *)decode_buffer + dindx;\
+    if (planar) {\
+      p1 = (stype *)this->av_frame->extended_data[x[0]];\
+      sstep = 1;\
+    } else {\
+      p1 = (stype *)this->av_frame->extended_data[0] + x[0];\
+      sstep = this->ff_channels;\
+    }\
+    if (num == 1) {\
+      if (p1) for (i = 0; i < samples; i++) {\
+        int32_t v = MIX_FIX(*p1);\
+        p1       += sstep;\
+        v       >>= shift;\
+        *dptr     = (v);\
+        dptr     += channels;\
+      }\
+    } else {\
+      if (planar)\
+        p2 = (stype *)this->av_frame->extended_data[x[1]];\
+      else\
+        p2 = (stype *)this->av_frame->extended_data[0] + x[1];\
+      if (num == 2) {\
+        if (p1 && p2) for (i = 0; i < samples; i++) {\
+          int32_t v = MIX_FIX(*p1);\
+          p1       += sstep;\
+          v        += MIX_FIX(*p2);\
+          p2       += sstep;\
+          v       >>= shift;\
+          *dptr     = CLIP_16(v);\
+          dptr     += channels;\
+        }\
+      } else {\
+        if (planar)\
+          p3 = (stype *)this->av_frame->extended_data[x[2]];\
+        else\
+          p3 = (stype *)this->av_frame->extended_data[0] + x[2];\
+        if (num == 3) {\
+          if (p1 && p2 && p3) for (i = 0; i < samples; i++) {\
+            int32_t v = MIX_FIX(*p1);\
+            p1       += sstep;\
+            v        += MIX_FIX(*p2);\
+            p2       += sstep;\
+            v        += MIX_FIX(*p3);\
+            p3       += sstep;\
+            v       >>= shift;\
+            *dptr     = CLIP_16(v);\
+            dptr     += channels;\
+          }\
+        } else {\
+          if (planar)\
+            p4 = (stype *)this->av_frame->extended_data[x[3]];\
+          else\
+            p4 = (stype *)this->av_frame->extended_data[0] + x[3];\
+          if (p1 && p2 && p3 && p4) for (i = 0; i < samples; i++) {\
+            int32_t v = MIX_FIX(*p1);\
+            p1       += sstep;\
+            v        += MIX_FIX(*p2);\
+            p2       += sstep;\
+            v        += MIX_FIX(*p3);\
+            p3       += sstep;\
+            v        += MIX_FIX(*p4);\
+            p4       += sstep;\
+            v       >>= shift;\
+            *dptr     = CLIP_16(v);\
+            dptr     += channels;\
+          }\
+        }\
+      }\
+    }\
+  }
+#define MIX_FIX(v) (((int16_t)(v)<<8)^0x8000)
       case AV_SAMPLE_FMT_U8P:
-        if (channels > 1) {
-          uint8_t *p[12];
-          for (i = 0; i < channels; i++)
-            p[i] = (uint8_t *)this->av_frame->extended_data[i];
-          for (i = samples; i; i--) {
-            for (j = 0; j < channels; j++)
-              *q++ = ((uint16_t)(*p[j]++) << 8) ^ 0x8000;
-          }
-          break;
-        }
+        MIX_AUDIO (uint8_t, 1, this->left,  this->front_mixes, 0);
+        MIX_AUDIO (uint8_t, 1, this->right, this->front_mixes, 1);
+        for (j = 0; j < channels; j++) if (this->map[j] >= 0)
+          MIX_AUDIO (uint8_t, 1, this->map + j, 1, j);
+      break;
       case AV_SAMPLE_FMT_U8:
-        {
-          uint8_t *p = (uint8_t *)this->av_frame->extended_data[0];
-          for (i = samples * channels; i; i--)
-            *q++ = ((uint16_t)(*p++) << 8) ^ 0x8000;
-        }
+        MIX_AUDIO (uint8_t, 0, this->left,  this->front_mixes, 0);
+        MIX_AUDIO (uint8_t, 0, this->right, this->front_mixes, 1);
+        for (j = 0; j < channels; j++) if (this->map[j] >= 0)
+          MIX_AUDIO (uint8_t, 0, this->map + j, 1, j);
       break;
+#undef MIX_FIX
+#define MIX_FIX(v) (v)
       case AV_SAMPLE_FMT_S16P:
-        if (channels > 1) {
-          int16_t *p[12];
-          for (i = 0; i < channels; i++)
-            p[i] = (int16_t *)this->av_frame->extended_data[i];
-          for (i = samples; i; i--) {
-            for (j = 0; j < channels; j++)
-              *q++ = *p[j]++;
-          }
-          break;
-        }
+        MIX_AUDIO (int16_t, 1, this->left,  this->front_mixes, 0);
+        MIX_AUDIO (int16_t, 1, this->right, this->front_mixes, 1);
+        for (j = 0; j < channels; j++) if (this->map[j] >= 0)
+          MIX_AUDIO (int16_t, 1, this->map + j, 1, j);
+      break;
       case AV_SAMPLE_FMT_S16:
-        xine_fast_memcpy (q, this->av_frame->extended_data[0], bytes);
+        MIX_AUDIO (int16_t, 0, this->left,  this->front_mixes, 0);
+        MIX_AUDIO (int16_t, 0, this->right, this->front_mixes, 1);
+        for (j = 0; j < channels; j++) if (this->map[j] >= 0)
+          MIX_AUDIO (int16_t, 0, this->map + j, 1, j);
       break;
+#undef MIX_FIX
+#define MIX_FIX(v) ((v)>>16)
       case AV_SAMPLE_FMT_S32P:
-        if (channels > 1) {
-          int32_t *p[12];
-          for (i = 0; i < channels; i++)
-            p[i] = (int32_t *)this->av_frame->extended_data[i];
-          for (i = samples; i; i--) {
-            for (j = 0; j < channels; j++)
-              *q++ = *p[j]++ >> 16;
-          }
-          break;
-        }
+        MIX_AUDIO (int32_t, 1, this->left,  this->front_mixes, 0);
+        MIX_AUDIO (int32_t, 1, this->right, this->front_mixes, 1);
+        for (j = 0; j < channels; j++) if (this->map[j] >= 0)
+          MIX_AUDIO (int32_t, 1, this->map + j, 1, j);
+      break;
       case AV_SAMPLE_FMT_S32:
-        {
-          int32_t *p = (int32_t *)this->av_frame->extended_data[0];
-          for (i = samples * channels; i; i--)
-            *q++ = *p++ >> 16;
-        }
+        MIX_AUDIO (int32_t, 0, this->left,  this->front_mixes, 0);
+        MIX_AUDIO (int32_t, 0, this->right, this->front_mixes, 1);
+        for (j = 0; j < channels; j++) if (this->map[j] >= 0)
+          MIX_AUDIO (int32_t, 0, this->map + j, 1, j);
       break;
+#undef MIX_FIX
+#undef MIX_AUDIO
+#define MIX_AUDIO(stype,planar,idx,num,dindx) {\
+    stype *p1, *p2, *p3, *p4;\
+    int i, sstep;\
+    int8_t *x = idx;\
+    int16_t *dptr = (int16_t *)decode_buffer + dindx;\
+    if (planar) {\
+      p1 = (stype *)this->av_frame->extended_data[x[0]];\
+      sstep = 1;\
+    } else {\
+      p1 = (stype *)this->av_frame->extended_data[0] + x[0];\
+      sstep = this->ff_channels;\
+    }\
+    if (num == 1) {\
+      if (p1) for (i = 0; i < samples; i++) {\
+        int32_t v = (*p1) * gain;\
+        p1       += sstep;\
+        *dptr     = CLIP_16(v);\
+        dptr     += channels;\
+      }\
+    } else {\
+      if (planar)\
+        p2 = (stype *)this->av_frame->extended_data[x[1]];\
+      else\
+        p2 = (stype *)this->av_frame->extended_data[0] + x[1];\
+      if (num == 2) {\
+        if (p1 && p2) for (i = 0; i < samples; i++) {\
+          int32_t v = (*p1 + *p2) * gain;\
+          p1       += sstep;\
+          p2       += sstep;\
+          *dptr     = CLIP_16(v);\
+          dptr     += channels;\
+        }\
+      } else {\
+        if (planar)\
+          p3 = (stype *)this->av_frame->extended_data[x[2]];\
+        else\
+          p3 = (stype *)this->av_frame->extended_data[0] + x[2];\
+        if (num == 3) {\
+          if (p1 && p2 && p3) for (i = 0; i < samples; i++) {\
+            int32_t v = (*p1 + *p2 + *p3) * gain;\
+            p1       += sstep;\
+            p2       += sstep;\
+            p3       += sstep;\
+            *dptr     = CLIP_16(v);\
+            dptr     += channels;\
+          }\
+        } else {\
+          if (planar)\
+            p4 = (stype *)this->av_frame->extended_data[x[3]];\
+          else\
+            p4 = (stype *)this->av_frame->extended_data[0] + x[3];\
+          if (p1 && p2 && p3 && p4) for (i = 0; i < samples; i++) {\
+            int32_t v = (*p1 + *p2 + *p3 + *p4) * gain;\
+            p1       += sstep;\
+            p2       += sstep;\
+            p3       += sstep;\
+            p4       += sstep;\
+            *dptr     = CLIP_16(v);\
+            dptr     += channels;\
+          }\
+        }\
+      }\
+    }\
+  }
       case AV_SAMPLE_FMT_FLTP: /* the most popular one */
-        if (channels > 1) {
-          float *p[12];
-          for (i = 0; i < channels; i++)
-            p[i] = (float *)this->av_frame->extended_data[i];
-          for (i = samples; i; i--) {
-            for (j = 0; j < channels; j++) {
-              int v = *p[j]++ * gain;
-              *q++ = (v + 0x8000) & ~0xffff ? (v >> 31) ^ 0x7fff : v;
-            }
-          }
-          break;
-        }
+        MIX_AUDIO (float, 1, this->left,  this->front_mixes, 0);
+        MIX_AUDIO (float, 1, this->right, this->front_mixes, 1);
+        for (j = 0; j < channels; j++) if (this->map[j] >= 0)
+          MIX_AUDIO (float, 1, this->map + j, 1, j);
+      break;
       case AV_SAMPLE_FMT_FLT:
-        {
-          float *p = (float *)this->av_frame->extended_data[0];
-          for (i = samples * channels; i; i--) {
-            int v = *p++ * gain;
-            *q++ = (v + 0x8000) & ~0xffff ? (v >> 31) ^ 0x7fff : v;
-          }
-        }
+        MIX_AUDIO (float, 0, this->left,  this->front_mixes, 0);
+        MIX_AUDIO (float, 0, this->right, this->front_mixes, 1);
+        for (j = 0; j < channels; j++) if (this->map[j] >= 0)
+          MIX_AUDIO (float, 0, this->map + j, 1, j);
       break;
       default: ;
     }
+    if (channels > this->ao_channels) {
+      /* final mono downmix */
+      int16_t *p = decode_buffer;
+      q = p;
+      for (i = samples; i; i--) {
+        int v = *p++;
+        v += *p++;
+        *q++ = v >> 1;
+      }
+      *decode_buffer_size = samples * 2;
+    }
   } else *decode_buffer_size = 0;
 #  else
   consumed = avcodec_decode_audio3 (this->context, decode_buffer, decode_buffer_size, &avpkt);
+  ff_map_channels (this);
 #  endif
 #else
   consumed = avcodec_decode_audio2 (this->context, decode_buffer, decode_buffer_size, buf, size);
+  ff_map_channels (this);
 #endif
 
   if (consumed < 0) {
@@@@ -567,23 +866,25 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
       while (this->size>=0) {
         decode_buffer_size = AVCODEC_MAX_AUDIO_FRAME_SIZE;
 
-	bytes_consumed =
-          ff_audio_decode(this,
-                          (int16_t *)this->decode_buffer, &decode_buffer_size,
-                          &this->buf[offset], this->size);
+        bytes_consumed = ff_audio_decode (this, (int16_t *)this->decode_buffer, &decode_buffer_size,
+          &this->buf[offset], this->size);
 
-        if (bytes_consumed<0) {
-          this->size=0;
-          return;
-        } else if (bytes_consumed == 0 && decode_buffer_size == 0) {
+        if (bytes_consumed < 0)
+          break;
+
+        offset     += bytes_consumed;
+        this->size -= bytes_consumed;
+
+        if (decode_buffer_size == 0) {
+          if (bytes_consumed)
+            continue;
           if (offset)
             memmove(this->buf, &this->buf[offset], this->size);
           return;
         }
 
-        if (this->audio_bits        != this->context->bits_per_sample ||
-            this->audio_sample_rate != this->context->sample_rate ||
-            this->audio_channels    != this->context->channels) {
+        if (this->ff_sample_rate != this->context->sample_rate ||
+            this->ao_mode        != this->new_mode) {
           xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
                   _("ffmpeg_audio_dec: codec parameters changed\n"));
           /* close if it was open, and always trigger 1 new open attempt below */
@@@@ -591,12 +892,11 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
         }
 
 	if (!this->output_open) {
-	  if (!this->audio_bits || !this->audio_sample_rate || !this->audio_channels) {
-	    this->audio_bits = this->context->bits_per_sample;
-	    this->audio_sample_rate = this->context->sample_rate;
-	    this->audio_channels = this->context->channels;
+	  if (!this->ff_sample_rate || !this->ao_mode) {
+	    this->ff_sample_rate = this->context->sample_rate;
+	    this->ao_mode        = this->new_mode;
 	  }
-	  if (!this->audio_bits || !this->audio_sample_rate || !this->audio_channels) {
+	  if (!this->ff_sample_rate || !this->new_mode) {
 	    xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
 		    _("ffmpeg_audio_dec: cannot read codec parameters from packet\n"));
 	    /* try to decode next packet. */
@@@@ -606,8 +906,8 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
 	    buf->pts = 0;
 	  } else {
 	    this->output_open = (this->stream->audio_out->open) (this->stream->audio_out,
-								 this->stream, this->audio_bits, this->audio_sample_rate,
-								 _x_ao_channels2mode(this->audio_channels));
+								 this->stream, 16, this->ff_sample_rate,
+								 this->ao_mode);
 	    if (!this->output_open) {
 	      xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
 		      "ffmpeg_audio_dec: error opening audio output\n");
@@@@ -617,6 +917,84 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
 	  }
 	}
 
+#if AVAUDIO < 4
+        /* Old style postprocessing */
+        if (codec_type == BUF_AUDIO_WMAPRO) {
+          /* the above codecs output float samples, not 16-bit integers */
+          int samples = decode_buffer_size / sizeof(float);
+          float gain  = this->class->gain;
+          float *p    = (float *)this->decode_buffer;
+          int16_t *q  = (int16_t *)this->decode_buffer;
+          int i;
+          for (i = samples; i; i--) {
+            int v = *p++ * gain;
+            *q++ = CLIP_16 (v);
+          }
+          decode_buffer_size = samples * 2;
+        }
+
+        if ((this->ao_channels != this->ff_channels) || (this->ao_channels > 2)) {
+          /* Channel reordering and/or mixing */
+          int samples     = decode_buffer_size / (this->ff_channels * 2);
+          int channels    = this->ao_channels;
+          int ff_channels = this->ff_channels;
+          int16_t *p      = (int16_t *)this->decode_buffer;
+          int16_t *q      = p;
+          int shift       = this->downmix_shift, i, j;
+          /* downmix mono output to stereo first */
+          if ((channels == 1) && (ff_channels > 1))
+            channels = 2;
+          /* move to end of buf for in-place editing */
+          p += AVCODEC_MAX_AUDIO_FRAME_SIZE - decode_buffer_size;
+          if (p >= q + decode_buffer_size)
+            xine_fast_memcpy (p, q, decode_buffer_size);
+          else
+            memmove (p, q, decode_buffer_size);
+          /* not very optimized but it only hits when playing multichannel audio through
+             old ffmpeg - and its still better than previous code there */
+          if (this->front_mixes < 2) {
+            /* just reorder and maybe upmix */
+            for (i = samples; i; i--) {
+              q[0] = p[0];
+              q[1] = p[this->right[0]];
+              for (j = 2; j < channels; j++)
+                q[j] = this->map[j] < 0 ? 0 : p[this->map[j]];
+              p += ff_channels;
+              q += channels;
+            }
+          } else {
+            /* downmix */
+            for (i = samples; i; i--) {
+              int left  = p[0];
+              int right = p[this->right[0]];
+              for (j = 1; j < this->front_mixes; j++) {
+                left  += p[this->left[j]];
+                right += p[this->right[j]];
+              }
+              left  >>= shift;
+              q[0]    = CLIP_16 (left);
+              right >>= shift;
+              q[1]    = CLIP_16 (right);
+              for (j = 2; j < channels; j++)
+                q[j] = this->map[j] < 0 ? 0 : p[this->map[j]] >> shift;
+              p += ff_channels;
+              q += channels;
+            }
+          }
+          /* final mono downmix */
+          if (channels > this->ao_channels) {
+            p = (int16_t *)this->decode_buffer;
+            q = p;
+            for (i = samples; i; i--) {
+              int v = *p++;
+              v += *p++;
+              *q++ = v >> 1;
+            }
+          }
+          decode_buffer_size = samples * this->ao_channels * 2;
+        }
+#endif
+
         /* dispatch the decoded audio */
         out = 0;
         while (out < decode_buffer_size) {
@@@@ -636,40 +1014,16 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
           }
 
           /* fill up this buffer */
-#if AVAUDIO < 4
-          if (codec_type == BUF_AUDIO_WMAPRO) {
-            /* the above codecs output float samples, not 16-bit integers */
-            int bytes_per_sample = sizeof(float);
-            if (((decode_buffer_size - out) * 2 / bytes_per_sample) > audio_buffer->mem_size)
-              bytes_to_send = audio_buffer->mem_size * bytes_per_sample / 2;
-            else
-              bytes_to_send = decode_buffer_size - out;
+          if ((decode_buffer_size - out) > audio_buffer->mem_size)
+            bytes_to_send = audio_buffer->mem_size;
+          else
+            bytes_to_send = decode_buffer_size - out;
 
-            int16_t *int_buffer = calloc(1, bytes_to_send * 2 / bytes_per_sample);
-            int i;
-            for (i = 0; i < (bytes_to_send / bytes_per_sample); i++) {
-              float *float_sample = (float *)&this->decode_buffer[i * bytes_per_sample + out];
-              int_buffer[i] = (int16_t)lrintf(*float_sample * 32768.);
-            }
+          xine_fast_memcpy(audio_buffer->mem, &this->decode_buffer[out], bytes_to_send);
+          out += bytes_to_send;
 
-            out += bytes_to_send;
-            bytes_to_send = bytes_to_send * 2 / bytes_per_sample;
-            xine_fast_memcpy(audio_buffer->mem, int_buffer, bytes_to_send);
-            free(int_buffer);
-          } else
-#endif
-          {
-            if ((decode_buffer_size - out) > audio_buffer->mem_size)
-              bytes_to_send = audio_buffer->mem_size;
-            else
-              bytes_to_send = decode_buffer_size - out;
-
-            xine_fast_memcpy(audio_buffer->mem, &this->decode_buffer[out], bytes_to_send);
-            out += bytes_to_send;
-          }
-
           /* byte count / 2 (bytes / sample) / channels */
-          audio_buffer->num_frames = bytes_to_send / 2 / this->audio_channels;
+          audio_buffer->num_frames = bytes_to_send / 2 / this->ao_channels;
 
           audio_buffer->vpts = buf->pts;
d11 14
a24 14
@@@@ -677,11 +1031,7 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
           this->stream->audio_out->put_buffer (this->stream->audio_out,
             audio_buffer, this->stream);
         }
-
-        this->size -= bytes_consumed;
-        offset += bytes_consumed;
       }
-
       /* reset internal accumulation buffer */
       this->size = 0;
     }
@@@@ -765,7 +1115,7 @@@@ static audio_decoder_t *ff_audio_open_plugin (audio_de
   this->audio_decoder.dispose             = ff_audio_dispose;
d26 1
a26 6
   this->output_open = 0;
-  this->audio_channels = 0;
+  this->ff_channels = 0;
   this->stream = stream;
   this->buf = NULL;
   this->size = 0;
@


1.6
log
@Several fixes from upstream:

- Fix multichannel playback.
- Default to square pixels.
- Avoid CODEC_FLAG_EMU_EDG.
- Use AV_CODEC_ID_MPEG2VIDEO.
- Fix another potential xine_play() hang.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.5
log
@Update to stable, xine-lib-1.1.21.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_audio_decoder_c,v 1.4 2012/04/07 05:48:49 ajacoutot Exp $
d3 1
a3 1
Moved FFmpeg API version checks to single header.
d5 3
a7 7
--- src/combined/ffmpeg/ff_audio_decoder.c.orig	Fri Feb 17 22:41:13 2012
+++ src/combined/ffmpeg/ff_audio_decoder.c	Fri Feb 17 22:41:23 2012
@@@@ -43,15 +43,10 @@@@
 #include "xineutils.h"
 #include "bswap.h"
 #include "ffmpeg_decoder.h"
+#include "ffmpeg_compat.h"
d11 2
a12 6
-#if LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 32)
-#  define AVAUDIO 3
-#else
-#  define AVAUDIO 2
-#endif
-
a14 9
 } ff_audio_class_t;
@@@@ -173,7 +168,7 @@@@ static void ff_audio_init_codec(ff_audio_decoder_t *th
    *  - DVB streams where multiple AAC LATM frames are packed to single PES
    *  - DVB streams where MPEG audio frames do not follow PES packet boundaries
    */
-#if LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 94)
+#if AVPARSE > 1
   if (codec_type == BUF_AUDIO_AAC_LATM ||
       codec_type == BUF_AUDIO_MPEG) {
d16 279
a294 1
@@@@ -356,7 +351,7 @@@@ static int ff_audio_decode(xine_t *xine,
d296 484
a779 1
   int parser_consumed = 0;
d781 45
a825 11
-#if LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 94)
+#if AVPARSE > 1
   if (parser_ctx) {
     uint8_t *outbuf;
     int      outsize;
@@@@ -383,7 +378,7 @@@@ static int ff_audio_decode(xine_t *xine,
     buf  = outbuf;
     size = outsize;
   }
-#endif /* LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 94) */
+#endif /* AVPARSE > 1 */
d827 6
a832 2
 #if AVAUDIO > 2
   AVPacket avpkt;
@


1.4
log
@Bring a bunch of bugfixes from upstream.

from Brad
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3
log
@update to xine-lib 1.1.20, from Brad
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_audio_decoder_c,v 1.2 2011/10/09 20:45:07 sthen Exp $
d3 1
a3 6
- Eliminate use of old FFmpeg APIs.
- Fix audio crash (SSE2 alignment).
- Use xine's fast memcpy.
- Pad end of audio data buffer with zeros.
- Not every audio packet can be used to determine the sample rate and number of
  audio channels.
d5 7
a11 3
--- src/combined/ffmpeg/ff_audio_decoder.c.orig	Tue Mar 23 11:41:49 2010
+++ src/combined/ffmpeg/ff_audio_decoder.c	Sun Oct  2 15:45:17 2011
@@@@ -46,6 +46,12 @@@@
d15 6
a20 6
+#if LIBAVCODEC_VERSION_MAJOR >= 53 || (LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR >= 32)
+#  define AVAUDIO 3
+#else
+#  define AVAUDIO 2
+#endif
+
d24 21
a44 40
@@@@ -75,13 +81,41 @@@@ typedef struct ff_audio_decoder_s {
 
 #include "ff_audio_list.h"
 
+#define malloc16(s) realloc16(NULL,s)
+#define free16(p) realloc16(p,0)
+
+static void *realloc16 (void *m, size_t s) {
+  unsigned long diff, diff2;
+  unsigned char *p = m, *q;
+  if (p) {
+    diff = p[-1];
+    if (s == 0) {
+      free (p - diff);
+      return (NULL);
+    }
+    q = realloc (p - diff, s + 16);
+    if (!q) return (q);
+    diff2 = 16 - ((unsigned long)q & 15);
+    if (diff2 != diff) memmove (q + diff2, q + diff, s);
+  } else {
+    if (s == 0) return (NULL);
+    q = malloc (s + 16);
+    if (!q) return (q);
+    diff2 = 16 - ((unsigned long)q & 15);
+  }
+  q += diff2;
+  q[-1] = diff2;
+  return (q);
+}
+
+
  static void ff_audio_ensure_buffer_size(ff_audio_decoder_t *this, int size) {
   if (size > this->bufsize) {
     this->bufsize = size + size / 2;
     xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
             _("ffmpeg_audio_dec: increasing buffer to %d to avoid overflow.\n"),
             this->bufsize);
-    this->buf = realloc( this->buf, this->bufsize );
+    this->buf = realloc16 (this->buf, this->bufsize + FF_INPUT_BUFFER_PADDING_SIZE);
d46 2
a47 119
 }
 
@@@@ -94,14 +128,13 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
   int out;
   audio_buffer_t *audio_buffer;
   int bytes_to_send;
-  unsigned int codec_type = buf->type & 0xFFFF0000;
+  unsigned int codec_type = buf->type & (BUF_MAJOR_MASK | BUF_DECODER_MASK);
 
-  if ( (buf->decoder_flags & BUF_FLAG_HEADER) &&
-      !(buf->decoder_flags & BUF_FLAG_SPECIAL) ) {
+  if ( (buf->decoder_flags & (BUF_FLAG_HEADER | BUF_FLAG_SPECIAL)) == BUF_FLAG_HEADER ) {
 
     /* accumulate init data */
     ff_audio_ensure_buffer_size(this, this->size + buf->size);
-    memcpy(this->buf + this->size, buf->content, buf->size);
+    xine_fast_memcpy(this->buf + this->size, buf->content, buf->size);
     this->size += buf->size;
 
     if (buf->decoder_flags & BUF_FLAG_FRAME_END) {
@@@@ -241,7 +274,7 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
 
       this->size = 0;
 
-      this->decode_buffer = calloc(1, AVCODEC_MAX_AUDIO_FRAME_SIZE);
+      this->decode_buffer = malloc16 (AVCODEC_MAX_AUDIO_FRAME_SIZE);
 
       return;
     }
@@@@ -255,6 +288,9 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
       buf->decoder_info[2]);
 
   } else if (!(buf->decoder_flags & BUF_FLAG_SPECIAL)) {
+#if AVAUDIO > 2
+    AVPacket avpkt;
+#endif
 
     if( !this->decoder_ok ) {
       if ( ! this->context || ! this->codec ) {
@@@@ -285,17 +321,36 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
 
     if (!this->output_open) {
       if (!this->audio_bits || !this->audio_sample_rate || !this->audio_channels) {
+        int ret;
+
         decode_buffer_size = AVCODEC_MAX_AUDIO_FRAME_SIZE;
-        avcodec_decode_audio2 (this->context,
-                              (int16_t *)this->decode_buffer,
-                              &decode_buffer_size,
-                              &this->buf[0],
-                              this->size);
+#if AVAUDIO > 2
+	av_init_packet (&avpkt);
+	avpkt.data = (uint8_t *)&this->buf[0];
+	avpkt.size = this->size;
+	avpkt.flags = AV_PKT_FLAG_KEY;
+	ret = avcodec_decode_audio3 (this->context,
+				     (int16_t *)this->decode_buffer,
+				     &decode_buffer_size, &avpkt);
+#else
+        ret = avcodec_decode_audio2 (this->context,
+                                     (int16_t *)this->decode_buffer,
+                                     &decode_buffer_size,
+                                     &this->buf[0],
+                                     this->size);
+#endif
 	this->audio_bits = this->context->bits_per_sample;
 	this->audio_sample_rate = this->context->sample_rate;
 	this->audio_channels = this->context->channels;
-	if (!this->audio_bits || !this->audio_sample_rate || !this->audio_channels)
+	if (!this->audio_bits || !this->audio_sample_rate || !this->audio_channels) {
+	  xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+	          _("ffmpeg_audio_dec: cannot read codec parameters from packet (error=%d)\n"), ret);
+
+	  /* We can't use this packet, so we must discard it
+	   * and wait for another one. */
+	  this->size = 0;
 	  return;
+	}
       }
       this->output_open = (this->stream->audio_out->open) (this->stream->audio_out,
         this->stream, this->audio_bits, this->audio_sample_rate,
@@@@ -309,14 +364,27 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
     if (buf->decoder_flags & BUF_FLAG_FRAME_END)  { /* time to decode a frame */
 
       offset = 0;
+
+      /* pad input data */
+      memset(&this->buf[this->size], 0, FF_INPUT_BUFFER_PADDING_SIZE);
+
       while (this->size>0) {
         decode_buffer_size = AVCODEC_MAX_AUDIO_FRAME_SIZE;
+#if AVAUDIO > 2
+	av_init_packet (&avpkt);
+	avpkt.data = (uint8_t *)&this->buf[offset];
+	avpkt.size = this->size;
+	avpkt.flags = AV_PKT_FLAG_KEY;
+	bytes_consumed = avcodec_decode_audio3 (this->context,
+						(int16_t *)this->decode_buffer,
+						&decode_buffer_size, &avpkt);
+#else
         bytes_consumed = avcodec_decode_audio2 (this->context,
                                                (int16_t *)this->decode_buffer,
                                                &decode_buffer_size,
                                                &this->buf[offset],
                                                this->size);
-
+#endif
         if (bytes_consumed<0) {
           xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
                    "ffmpeg_audio_dec: error decompressing audio frame\n");
@@@@ -427,8 +495,8 @@@@ static void ff_audio_dispose (audio_decoder_t *this_ge
     this->stream->audio_out->close (this->stream->audio_out, this->stream);
   this->output_open = 0;
 
-  free(this->buf);
-  free(this->decode_buffer);
+  free16 (this->buf);
+  free16 (this->decode_buffer);
d49 2
a50 2
   if(this->context && this->context->extradata)
     free(this->context->extradata);
@


1.2
log
@Backport support to xine-lib for VP8 (WebM) and RealVideo 3/4, improved
24-bit LPCM support and various bug fixes. From Brad.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_combined_ffmpeg_ff_audio_decoder_c,v 1.1 2011/06/13 08:10:01 dcoppa Exp $
@


1.1
log
@Eliminate use of old FFmpeg APIs.

OK myself, sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
d3 6
a8 1
Eliminate use of old FFmpeg APIs.
d11 1
a11 1
+++ src/combined/ffmpeg/ff_audio_decoder.c	Mon May 16 20:42:58 2011
d25 71
a95 1
@@@@ -255,6 +261,9 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
d105 2
a106 1
@@@@ -286,11 +295,21 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
d109 2
d112 5
d122 3
a124 3
+	avcodec_decode_audio3 (this->context,
+			       (int16_t *)this->decode_buffer,
+			       &decode_buffer_size, &avpkt);
d126 5
a130 5
         avcodec_decode_audio2 (this->context,
                               (int16_t *)this->decode_buffer,
                               &decode_buffer_size,
                               &this->buf[0],
                               this->size);
d135 16
a150 1
@@@@ -311,12 +330,21 @@@@ static void ff_audio_decode_data (audio_decoder_t *thi
d152 4
d177 11
@

