head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.2
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.2
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@# @;


1.20
date	2014.04.16.05.09.00;	author brad;	state dead;
branches;
next	1.19;

1.19
date	2013.11.30.22.13.37;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.10.07.35.30;	author ajacoutot;	state dead;
branches;
next	1.17;

1.17
date	2012.04.28.09.14.33;	author ajacoutot;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.07.05.48.49;	author ajacoutot;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.16.00.43.17;	author sthen;	state dead;
branches;
next	1.14;

1.14
date	2011.10.09.20.45.07;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.11.09.05.54;	author dcoppa;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.15.23.22.31;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.15.14.13.03;	author dcoppa;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.21.01.41.15;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.05.11.48.51;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.04.00.28.56;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.02.22.00.42;	author sthen;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2008.06.18.01.26.41;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.15.11.24.14;	author jakemsr;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.06.10.12.23;	author jakemsr;	state Exp;
branches;
next	1.3;

1.3
date	2008.03.31.11.28.59;	author jakemsr;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.15.00.36.46;	author jakemsr;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.13.10.58.29;	author jakemsr;	state Exp;
branches;
next	;

1.7.2.1
date	2009.08.13.00.57.18;	author william;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Update to Xine-lib 1.2.5.

ok juanfra@@
@
text
@$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.19 2013/11/30 22:13:37 brad Exp $

- Simple (E)AC3 support.
- Add multitrak audio support.
- Add audio language info.

--- src/demuxers/demux_qt.c.orig	Wed Sep 18 06:04:54 2013
+++ src/demuxers/demux_qt.c	Wed Nov 20 21:11:34 2013
@@@@ -1,5 +1,5 @@@@
 /*
- * Copyright (C) 2001-2012 the xine project
+ * Copyright (C) 2001-2013 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@@@ -108,6 +108,8 @@@@ typedef unsigned int qt_atom;
 #define IN24_FOURCC ME_FOURCC('i', 'n', '2', '4')
 #define NI42_FOURCC ME_FOURCC('4', '2', 'n', 'i')
 #define AVC1_FOURCC ME_FOURCC('a', 'v', 'c', '1')
+#define AC_3_FOURCC ME_FOURCC('a', 'c', '-', '3')
+#define EAC3_FOURCC ME_FOURCC('e', 'c', '-', '3')
 
 #define UDTA_ATOM QT_ATOM('u', 'd', 't', 'a')
 #define META_ATOM QT_ATOM('m', 'e', 't', 'a')
@@@@ -131,8 +133,9 @@@@ typedef unsigned int qt_atom;
 #define RMVC_ATOM QT_ATOM('r', 'm', 'v', 'c')
 #define QTIM_ATOM QT_ATOM('q', 't', 'i', 'm')
 
-/* placeholder for cutting and pasting */
+/* placeholder for cutting and pasting
 #define _ATOM QT_ATOM('', '', '', '')
+*/
 
 #define ATOM_PREAMBLE_SIZE 8
 #define PALETTE_COUNT 256
@@@@ -315,6 +318,11 @@@@ typedef struct {
   unsigned int timeoffs_to_sample_count;
   time_to_sample_table_t *timeoffs_to_sample_table;
 
+  /* what to add to output buffer type */
+  int audio_index;
+
+  int lang;
+
 } qt_trak;
 
 typedef struct {
@@@@ -330,6 +338,10 @@@@ typedef struct {
   int               trak_count;
   qt_trak          *traks;
 
+#define MAX_AUDIO_TRAKS 8
+  int               audio_trak_count;
+  int               audio_traks[MAX_AUDIO_TRAKS];
+
   /* the trak numbers that won their respective frame count competitions */
   int               video_trak;
   int               audio_trak;
@@@@ -699,13 +711,12 @@@@ static int is_qt_file(input_plugin_t *qt_file) {
   off_t moov_atom_offset = -1;
   int64_t moov_atom_size = -1;
   int i;
-  int len;
 
   /* if the input is non-seekable, be much more stringent about qualifying
    * a QT file: In this case, the moov must be the first atom in the file */
   if ((qt_file->get_capabilities(qt_file) & INPUT_CAP_SEEKABLE) == 0) {
     unsigned char preview[MAX_PREVIEW_SIZE] = { 0, };
-    len = qt_file->get_optional_data(qt_file, preview, INPUT_OPTIONAL_DATA_PREVIEW);
+    qt_file->get_optional_data(qt_file, preview, INPUT_OPTIONAL_DATA_PREVIEW);
     if (_X_BE_32(&preview[4]) == MOOV_ATOM)
       return 1;
     else {
@@@@ -798,7 +809,7 @@@@ static void parse_meta_atom(qt_info *info, unsigned ch
     const uint8_t *const current_atom = &meta_atom[i];
     const qt_atom current_atom_code = _X_BE_32(&current_atom[4]);
     const uint32_t current_atom_size = _X_BE_32(&current_atom[0]);
-    uint32_t handler_type = 0;
+    /*uint32_t handler_type = 0;*/
 
     switch (current_atom_code) {
     case HDLR_ATOM: {
@@@@ -813,7 +824,7 @@@@ static void parse_meta_atom(qt_info *info, unsigned ch
 	return;
       }
 
-      handler_type = _X_BE_32(&current_atom[12]);
+      /*handler_type = _X_BE_32(&current_atom[12]);*/
     }
       break;
 
@@@@ -1005,6 +1016,7 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
 	if ( version > 1 ) continue; /* unsupported, undocumented */
 
 	trak->timescale = _X_BE_32(&trak_atom[i + (version == 0 ? 0x10 : 0x18) ]);
+	trak->lang = _X_BE_16 (trak_atom + i + (version == 0 ? 0x18 : 0x24));
       }
       break;
 
@@@@ -1284,6 +1296,8 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
            * further, do not do load these parameters if the audio is just
            * PCM ('raw ', 'twos', 'sowt' or 'in24') */
           if ((current_stsd_atom_size > 0x24) &&
+              (trak->stsd_atoms[k].audio.codec_fourcc != AC_3_FOURCC) &&
+              (trak->stsd_atoms[k].audio.codec_fourcc != EAC3_FOURCC) &&
               (trak->stsd_atoms[k].audio.codec_fourcc != TWOS_FOURCC) &&
               (trak->stsd_atoms[k].audio.codec_fourcc != SOWT_FOURCC) &&
               (trak->stsd_atoms[k].audio.codec_fourcc != RAW_FOURCC)  &&
@@@@ -1322,6 +1336,12 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
           if (trak->stsd_atoms[k].audio.codec_fourcc == SAMR_FOURCC)
             trak->stsd_atoms[k].audio.vbr = 1;
 
+          if (trak->stsd_atoms[k].audio.codec_fourcc == AC_3_FOURCC)
+            trak->stsd_atoms[k].audio.vbr = 1;
+
+          if (trak->stsd_atoms[k].audio.codec_fourcc == EAC3_FOURCC)
+            trak->stsd_atoms[k].audio.vbr = 1;
+
           if (trak->stsd_atoms[k].audio.codec_fourcc == ALAC_FOURCC) {
             trak->stsd_atoms[k].audio.vbr = 1;
             /* further, FFmpeg's ALAC decoder requires 36 out-of-band bytes */
@@@@ -2446,10 +2466,8 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
   unsigned int frame_aligned_buf_size;
   int frame_duration;
   int first_buf;
-  qt_trak *video_trak = NULL;
-  qt_trak *audio_trak = NULL;
-  int dispatch_audio;  /* boolean for deciding which trak to dispatch */
-  int64_t pts_diff;
+  qt_trak *trak = NULL;
+  off_t current_pos = this->input->get_current_pos (this->input);
 
   /* if this is DRM-protected content, finish playback before it even
    * tries to start */
@@@@ -2468,117 +2486,105 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
     return this->status;
   }
 
-  if (this->qt->video_trak != -1) {
-    video_trak = &this->qt->traks[this->qt->video_trak];
-  }
-  if (this->qt->audio_trak != -1) {
-    audio_trak = &this->qt->traks[this->qt->audio_trak];
-  }
-
-  if (!audio_trak && !video_trak) {
-    /* something is really wrong if this case is reached */
-    this->status = DEMUX_FINISHED;
-    return this->status;
-  }
-
-  /* check if it is time to seek */
-  if (this->qt->seek_flag) {
-    this->qt->seek_flag = 0;
-
-    /* if audio is present, send pts of current audio frame, otherwise
-     * send current video frame pts */
-    if (audio_trak)
-      _x_demux_control_newpts(this->stream,
-        audio_trak->frames[audio_trak->current_frame].pts,
-        BUF_FLAG_SEEK);
-    else
-      _x_demux_control_newpts(this->stream,
-        video_trak->frames[video_trak->current_frame].pts,
-        BUF_FLAG_SEEK);
-  }
-
   /* Decide the trak from which to dispatch a frame. Policy: Dispatch
    * the frames in offset order as much as possible. If the pts difference
    * between the current frames from the audio and video traks is too
    * wide, make an exception. This exception deals with non-interleaved
    * Quicktime files. */
-  if (!audio_trak) {
+  do {
+    int traks[MAX_AUDIO_TRAKS + 1];
+    int trak_count = 0;
+    int min_trak = -1, next_trak = -1;
+    int64_t min_pts = 0, max_pts = 0; /* avoid warning */
+    off_t next_pos = 0x7fffffffffffffffLL;
+    int i;
 
-    /* only video is present */
-    dispatch_audio = 0;
-    if (video_trak->current_frame >= video_trak->frame_count) {
-      this->status = DEMUX_FINISHED;
-      return this->status;
+    /* Step 1: list yet unfinished traks. */
+    if (this->qt->video_trak >= 0) {
+      trak = &this->qt->traks[this->qt->video_trak];
+      if (trak->current_frame < trak->frame_count)
+        traks[trak_count++] = this->qt->video_trak;
     }
+    for (i = 0; i < this->qt->audio_trak_count; i++) {
+      trak = &this->qt->traks[this->qt->audio_traks[i]];
+      if (trak->current_frame < trak->frame_count)
+        traks[trak_count++] = this->qt->audio_traks[i];
+    }
 
-  } else if (!video_trak) {
-
-    /* only audio is present */
-    dispatch_audio = 1;
-    if (audio_trak->current_frame >= audio_trak->frame_count) {
+    /* Step 2: handle trivial cases. */
+    if (trak_count == 0) {
       this->status = DEMUX_FINISHED;
       return this->status;
     }
+    if (trak_count == 1) {
+      trak = &this->qt->traks[traks[0]];
+      break;
+    }
 
-  } else {
+    /* Step 3: find
+       * The minimum pts and the trak who has it.
+       * The maximum pts.
+       * The forward nearest to current position and the trak thereof. */
+    for (i = 0; i < trak_count; i++) {
+      int64_t pts;
+      off_t pos;
+      trak = &this->qt->traks[traks[i]];
+      pts  = trak->frames[trak->current_frame].pts;
+      if (i == 0) {
+        min_pts  = max_pts = pts;
+        min_trak = traks[i];
+      } else if (pts < min_pts) {
+        min_pts  = pts;
+        min_trak = traks[i];
+      } else if (pts > max_pts)
+        max_pts  = pts;
+      pos = trak->frames[trak->current_frame].offset;
+      if ((pos >= current_pos) && (pos < next_pos)) {
+        next_pos = pos;
+        next_trak = traks[i];
+      }
+    }
 
-    /* both audio and video are present; start making some tough choices */
+    /* Step 4: after seek, or if the pts scissors opened too much, send minimum pts trak next.
+       Otherwise, take next one by offset. */
+    i = this->qt->seek_flag || (next_trak < 0) || (max_pts - min_pts > MAX_PTS_DIFF) ?
+      min_trak : next_trak;
+    trak = &this->qt->traks[i];
+  } while (0);
 
-    /* check the frame count limits */
-    if ((audio_trak->current_frame >= audio_trak->frame_count) &&
-        (video_trak->current_frame >= video_trak->frame_count)) {
+  if (this->stream->xine->verbosity == XINE_VERBOSITY_DEBUG + 1) {
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG + 1,
+      "demux_qt: sending trak %d dts %"PRId64" pos %"PRId64"\n",
+      trak - this->qt->traks,
+      trak->frames[trak->current_frame].pts,
+      trak->frames[trak->current_frame].offset);
+  }
 
-      this->status = DEMUX_FINISHED;
-      return this->status;
+  /* check if it is time to seek */
+  if (this->qt->seek_flag) {
+    this->qt->seek_flag = 0;
 
-    } else if (video_trak->current_frame >= video_trak->frame_count) {
-
-      dispatch_audio = 1;
-
-    } else if (audio_trak->current_frame >= audio_trak->frame_count) {
-
-      dispatch_audio = 0;
-
-    } else {
-
-      /* at this point, it is certain that both traks still have frames
-       * yet to be dispatched */
-      pts_diff  = audio_trak->frames[audio_trak->current_frame].pts;
-      pts_diff -= video_trak->frames[video_trak->current_frame].pts;
-
-      if (pts_diff > MAX_PTS_DIFF) {
-        /* if diff is +max_diff, audio is too far ahead of video */
-        dispatch_audio = 0;
-      } else if (pts_diff < -MAX_PTS_DIFF) {
-        /* if diff is -max_diff, video is too far ahead of audio */
-        dispatch_audio = 1;
-      } else if (audio_trak->frames[audio_trak->current_frame].offset <
-                 video_trak->frames[video_trak->current_frame].offset) {
-        /* pts diff is not too wide, decide based on earlier offset */
-        dispatch_audio = 1;
-      } else {
-        dispatch_audio = 0;
-      }
-    }
+    /* send min pts of all used traks, usually audio (see demux_qt_seek ()). */
+    _x_demux_control_newpts (this->stream, trak->frames[trak->current_frame].pts, BUF_FLAG_SEEK);
   }
 
-  if (!dispatch_audio) {
-    i = video_trak->current_frame++;
+  if (trak->type == MEDIA_VIDEO) {
+    i = trak->current_frame++;
 
-    if (video_trak->frames[i].media_id != video_trak->properties->video.media_id) {
+    if (trak->frames[i].media_id != trak->properties->video.media_id) {
       this->status = DEMUX_OK;
       return this->status;
     }
 
-    remaining_sample_bytes = video_trak->frames[i].size;
-    this->input->seek(this->input, video_trak->frames[i].offset,
-      SEEK_SET);
+    remaining_sample_bytes = trak->frames[i].size;
+    if (trak->frames[i].offset != current_pos)
+      this->input->seek (this->input, trak->frames[i].offset, SEEK_SET);
 
-    if (i + 1 < video_trak->frame_count) {
+    if (i + 1 < trak->frame_count) {
       /* frame duration is the pts diff between this video frame and
        * the next video frame */
-      frame_duration  = video_trak->frames[i + 1].pts;
-      frame_duration -= video_trak->frames[i].pts;
+      frame_duration  = trak->frames[i + 1].pts;
+      frame_duration -= trak->frames[i].pts;
     } else {
       /* give the last frame some fixed duration */
       frame_duration = 12000;
@@@@ -2590,10 +2596,10 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
      * to compensate. */
     if (!frame_duration) {
       frame_duration = 1;
-      video_trak->properties->video.edit_list_compensation++;
+      trak->properties->video.edit_list_compensation++;
     } else {
-      frame_duration -= video_trak->properties->video.edit_list_compensation;
-      video_trak->properties->video.edit_list_compensation = 0;
+      frame_duration -= trak->properties->video.edit_list_compensation;
+      trak->properties->video.edit_list_compensation = 0;
     }
 
     _x_stream_info_set(this->stream, XINE_STREAM_INFO_FRAME_DURATION,
@@@@ -2601,19 +2607,19 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
 
     debug_video_demux("  qt: sending off video frame %d from offset 0x%"PRIX64", %d bytes, media id %d, %"PRId64" pts\n",
       i,
-      video_trak->frames[i].offset,
-      video_trak->frames[i].size,
-      video_trak->frames[i].media_id,
-      video_trak->frames[i].pts);
+      trak->frames[i].offset,
+      trak->frames[i].size,
+      trak->frames[i].media_id,
+      trak->frames[i].pts);
 
     while (remaining_sample_bytes) {
       buf = this->video_fifo->buffer_pool_alloc (this->video_fifo);
-      buf->type = video_trak->properties->video.codec_buftype;
+      buf->type = trak->properties->video.codec_buftype;
       if( this->data_size )
-        buf->extra_info->input_normpos = (int)( (double) (video_trak->frames[i].offset - this->data_start)
+        buf->extra_info->input_normpos = (int)( (double) (trak->frames[i].offset - this->data_start)
                                                 * 65535 / this->data_size);
-      buf->extra_info->input_time = video_trak->frames[i].pts / 90;
-      buf->pts = video_trak->frames[i].pts + (int64_t)video_trak->frames[i].ptsoffs;
+      buf->extra_info->input_time = trak->frames[i].pts / 90;
+      buf->pts = trak->frames[i].pts + (int64_t)trak->frames[i].ptsoffs;
 
       buf->decoder_flags |= BUF_FLAG_FRAMERATE;
       buf->decoder_info[0] = frame_duration;
@@@@ -2631,7 +2637,7 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
         break;
       }
 
-      if (video_trak->frames[i].keyframe)
+      if (trak->frames[i].keyframe)
         buf->decoder_flags |= BUF_FLAG_KEYFRAME;
       if (!remaining_sample_bytes)
         buf->decoder_flags |= BUF_FLAG_FRAME_END;
@@@@ -2639,11 +2645,11 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
       this->video_fifo->put(this->video_fifo, buf);
     }
 
-  } else {
+  } else { /* trak->type == MEDIA_AUDIO */
     /* load an audio sample and packetize it */
-    i = audio_trak->current_frame++;
+    i = trak->current_frame++;
 
-    if (audio_trak->frames[i].media_id != audio_trak->properties->audio.media_id) {
+    if (trak->frames[i].media_id != trak->properties->audio.media_id) {
       this->status = DEMUX_OK;
       return this->status;
     }
@@@@ -2652,24 +2658,24 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
     if (!this->audio_fifo)
       return this->status;
 
-    remaining_sample_bytes = audio_trak->frames[i].size;
+    remaining_sample_bytes = trak->frames[i].size;
 
-    this->input->seek(this->input, audio_trak->frames[i].offset,
-      SEEK_SET);
+    if (trak->frames[i].offset != current_pos)
+      this->input->seek (this->input, trak->frames[i].offset, SEEK_SET);
 
     debug_audio_demux("  qt: sending off audio frame %d from offset 0x%"PRIX64", %d bytes, media id %d, %"PRId64" pts\n",
       i,
-      audio_trak->frames[i].offset,
-      audio_trak->frames[i].size,
-      audio_trak->frames[i].media_id,
-      audio_trak->frames[i].pts);
+      trak->frames[i].offset,
+      trak->frames[i].size,
+      trak->frames[i].media_id,
+      trak->frames[i].pts);
 
     first_buf = 1;
     while (remaining_sample_bytes) {
       buf = this->audio_fifo->buffer_pool_alloc (this->audio_fifo);
-      buf->type = audio_trak->properties->audio.codec_buftype;
+      buf->type = trak->properties->audio.codec_buftype;
       if( this->data_size )
-        buf->extra_info->input_normpos = (int)( (double) (audio_trak->frames[i].offset - this->data_start)
+        buf->extra_info->input_normpos = (int)( (double) (trak->frames[i].offset - this->data_start)
                                                 * 65535 / this->data_size);
       /* The audio chunk is often broken up into multiple 8K buffers when
        * it is sent to the audio decoder. Only attach the proper timestamp
@@@@ -2680,20 +2686,20 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
       if ((buf->type == BUF_AUDIO_LPCM_BE) ||
           (buf->type == BUF_AUDIO_LPCM_LE)) {
         if (first_buf) {
-          buf->extra_info->input_time = audio_trak->frames[i].pts / 90;
-          buf->pts = audio_trak->frames[i].pts;
+          buf->extra_info->input_time = trak->frames[i].pts / 90;
+          buf->pts = trak->frames[i].pts;
           first_buf = 0;
         } else {
           buf->extra_info->input_time = 0;
           buf->pts = 0;
         }
       } else {
-        buf->extra_info->input_time = audio_trak->frames[i].pts / 90;
-        buf->pts = audio_trak->frames[i].pts;
+        buf->extra_info->input_time = trak->frames[i].pts / 90;
+        buf->pts = trak->frames[i].pts;
       }
 
       /* 24-bit audio doesn't fit evenly into the default 8192-byte buffers */
-      if (audio_trak->properties->audio.bits == 24)
+      if (trak->properties->audio.bits == 24)
         frame_aligned_buf_size = 8184;
       else
         frame_aligned_buf_size = buf->max_size;
@@@@ -2713,9 +2719,9 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
 
       /* Special case alert: If this is signed, 8-bit data, transform
        * the data to unsigned. */
-      if ((audio_trak->properties->audio.bits == 8) &&
-          ((audio_trak->properties->audio.codec_fourcc == TWOS_FOURCC) ||
-           (audio_trak->properties->audio.codec_fourcc == SOWT_FOURCC)))
+      if ((trak->properties->audio.bits == 8) &&
+          ((trak->properties->audio.codec_fourcc == TWOS_FOURCC) ||
+           (trak->properties->audio.codec_fourcc == SOWT_FOURCC)))
         for (j = 0; j < buf->size; j++)
           buf->content[j] += 0x80;
 
@@@@ -2723,6 +2729,7 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
         buf->decoder_flags |= BUF_FLAG_FRAME_END;
       }
 
+      buf->type |= trak->audio_index;
       this->audio_fifo->put(this->audio_fifo, buf);
     }
   }
@@@@ -2738,6 +2745,9 @@@@ static void demux_qt_send_headers(demux_plugin_t *this
   qt_trak *audio_trak = NULL;
   unsigned int audio_bitrate;
 
+  int tnum;
+  int audio_index = 0;
+
   /* for deciding data start and data size */
   int64_t first_video_offset = -1;
   int64_t  last_video_offset = -1;
@@@@ -2820,31 +2830,6 @@@@ static void demux_qt_send_headers(demux_plugin_t *this
 
   if (this->qt->audio_trak != -1) {
 
-    /* in mp4 files the audio fourcc is always 'mp4a' - the codec is
-     * specified by the object type id field in the esds atom */
-    if(audio_trak->properties->audio.codec_fourcc == MP4A_FOURCC) {
-      switch(audio_trak->object_type_id) {
-        case 107:
-          audio_trak->properties->audio.codec_buftype = BUF_AUDIO_MPEG;
-          break;
-        default:
-          /* default to AAC if we have no better idea */
-          audio_trak->properties->audio.codec_buftype = BUF_AUDIO_AAC;
-          break;
-      }
-    } else {
-      audio_trak->properties->audio.codec_buftype =
-        _x_formattag_to_buf_audio(audio_trak->properties->audio.codec_fourcc);
-    }
-
-    if( !audio_trak->properties->audio.codec_buftype &&
-         audio_trak->properties->audio.codec_fourcc )
-    {
-      audio_trak->properties->audio.codec_buftype = BUF_AUDIO_UNKNOWN;
-      _x_report_audio_format_tag (this->stream->xine, LOG_MODULE,
-				  audio_trak->properties->audio.codec_fourcc);
-    }
-
     _x_stream_info_set(this->stream, XINE_STREAM_INFO_HAS_AUDIO, 1);
     _x_stream_info_set(this->stream, XINE_STREAM_INFO_AUDIO_CHANNELS,
       audio_trak->properties->audio.channels);
@@@@ -2941,10 +2926,44 @@@@ static void demux_qt_send_headers(demux_plugin_t *this
     this->video_fifo->put (this->video_fifo, buf);
   }
 
-  if ((this->qt->audio_trak != -1) &&
-      (audio_trak->properties->audio.codec_buftype) &&
-      this->audio_fifo) {
+  for (tnum = 0; tnum < this->qt->trak_count; tnum++) {
 
+    audio_trak = &this->qt->traks[tnum];
+    if (audio_trak->type != MEDIA_AUDIO)
+      continue;
+
+    /* in mp4 files the audio fourcc is always 'mp4a' - the codec is
+     * specified by the object type id field in the esds atom */
+    if (audio_trak->properties->audio.codec_fourcc == MP4A_FOURCC) {
+      switch (audio_trak->object_type_id) {
+        case 107:
+          audio_trak->properties->audio.codec_buftype = BUF_AUDIO_MPEG;
+          break;
+        default:
+          /* default to AAC if we have no better idea */
+          audio_trak->properties->audio.codec_buftype = BUF_AUDIO_AAC;
+          break;
+      }
+    } else {
+      audio_trak->properties->audio.codec_buftype =
+        _x_formattag_to_buf_audio (audio_trak->properties->audio.codec_fourcc);
+    }
+
+    if (!audio_trak->properties->audio.codec_buftype &&
+         audio_trak->properties->audio.codec_fourcc) {
+      audio_trak->properties->audio.codec_buftype = BUF_AUDIO_UNKNOWN;
+      _x_report_audio_format_tag (this->stream->xine, LOG_MODULE,
+        audio_trak->properties->audio.codec_fourcc);
+    }
+
+    if ((audio_trak->properties->audio.codec_buftype == 0) ||
+        (audio_index >= MAX_AUDIO_TRAKS) ||
+        (this->audio_fifo == NULL))
+      continue;
+
+    this->qt->audio_traks[audio_index] = tnum;
+    audio_trak->audio_index = audio_index;
+
     /* set the audio bitrate field (only for CBR audio) */
     if (!audio_trak->properties->audio.vbr) {
       audio_bitrate =
@@@@ -2958,7 +2977,7 @@@@ static void demux_qt_send_headers(demux_plugin_t *this
     }
 
     buf = this->audio_fifo->buffer_pool_alloc (this->audio_fifo);
-    buf->type = audio_trak->properties->audio.codec_buftype;
+    buf->type = audio_trak->properties->audio.codec_buftype | audio_index;
     buf->decoder_flags = BUF_FLAG_HEADER|BUF_FLAG_STDHEADER|BUF_FLAG_FRAME_END;
     buf->decoder_info[0] = 0;
     buf->decoder_info[1] = audio_trak->properties->audio.sample_rate;
@@@@ -2980,7 +2999,7 @@@@ static void demux_qt_send_headers(demux_plugin_t *this
 
     if( audio_trak->decoder_config ) {
       buf = this->audio_fifo->buffer_pool_alloc (this->audio_fifo);
-      buf->type = audio_trak->properties->audio.codec_buftype;
+      buf->type = audio_trak->properties->audio.codec_buftype | audio_index;
       buf->size = 0;
       buf->decoder_flags = BUF_FLAG_SPECIAL|BUF_FLAG_HEADER;
       buf->decoder_info[1] = BUF_SPECIAL_DECODER_CONFIG;
@@@@ -2996,9 +3015,10 @@@@ static void demux_qt_send_headers(demux_plugin_t *this
     buf->decoder_info[2] = audio_trak->properties->audio.properties_atom_size;
     buf->decoder_info_ptr[2] = audio_trak->properties->audio.properties_atom;
     buf->size = 0;
-    buf->type = audio_trak->properties->audio.codec_buftype;
+    buf->type = audio_trak->properties->audio.codec_buftype | audio_index;
     this->audio_fifo->put (this->audio_fifo, buf);
 
+    this->qt->audio_trak_count = ++audio_index;
   }
 }
 
@@@@ -3069,7 +3089,8 @@@@ static int demux_qt_seek (demux_plugin_t *this_gen,
   demux_qt_t *this = (demux_qt_t *) this_gen;
   qt_trak *video_trak = NULL;
   qt_trak *audio_trak = NULL;
-  int64_t keyframe_pts;
+  int i;
+  int64_t keyframe_pts = -1;
 
   start_pos = (off_t) ( (double) start_pos / 65535 *
               this->data_size );
@@@@ -3089,32 +3110,32 @@@@ static int demux_qt_seek (demux_plugin_t *this_gen,
     this->status = binary_seek(video_trak, start_pos, start_time);
     if (this->status != DEMUX_OK)
       return this->status;
-  }
-
-  if (this->qt->audio_trak != -1) {
-    audio_trak = &this->qt->traks[this->qt->audio_trak];
-    this->status = binary_seek(audio_trak, start_pos, start_time);
-    if (this->status != DEMUX_OK)
-      return this->status;
-  }
-
-  /* search back in the video trak for the nearest keyframe */
-  if (video_trak)
+    /* search back in the video trak for the nearest keyframe */
     while (video_trak->current_frame) {
       if (video_trak->frames[video_trak->current_frame].keyframe) {
         break;
       }
       video_trak->current_frame--;
     }
+    keyframe_pts = video_trak->frames[video_trak->current_frame].pts;
+  }
 
+  /* seek all supported audio traks */
+  for (i = 0; i < this->qt->audio_trak_count; i++) {
+    audio_trak = &this->qt->traks[this->qt->audio_traks[i]];
+    this->status = binary_seek(audio_trak, start_pos, start_time);
+    if (this->status != DEMUX_OK)
+      return this->status;
+  }
+
   /* not done yet; now that the nearest keyframe has been found, seek
    * back to the first audio frame that has a pts less than or equal to
    * that of the keyframe; do not go through with this process there is
    * no video trak */
-  if (audio_trak && video_trak) {
-    keyframe_pts = video_trak->frames[video_trak->current_frame].pts;
+  if (keyframe_pts >= 0) for (i = 0; i < this->qt->audio_trak_count; i++) {
+    audio_trak = &this->qt->traks[this->qt->audio_traks[i]];
     while (audio_trak->current_frame) {
-      if (audio_trak->frames[audio_trak->current_frame].pts < keyframe_pts) {
+      if (audio_trak->frames[audio_trak->current_frame].pts <= keyframe_pts) {
         break;
       }
       audio_trak->current_frame--;
@@@@ -3158,11 +3179,39 @@@@ static int demux_qt_get_stream_length (demux_plugin_t 
 }
 
 static uint32_t demux_qt_get_capabilities(demux_plugin_t *this_gen) {
-  return DEMUX_CAP_NOCAP;
+  return DEMUX_CAP_AUDIOLANG;
 }
 
 static int demux_qt_get_optional_data(demux_plugin_t *this_gen,
 					void *data, int data_type) {
+  demux_qt_t *this = (demux_qt_t *) this_gen;
+
+  /* be a bit paranoid */
+  if (this == NULL || this->stream == NULL)
+    return DEMUX_OPTIONAL_UNSUPPORTED;
+
+  switch (data_type) {
+    case DEMUX_OPTIONAL_DATA_AUDIOLANG: {
+      char *str   = data;
+      int channel = *((int *)data);
+      if ((channel < 0) || (channel >= this->qt->audio_trak_count)) {
+        strcpy (str, "none");
+      } else {
+        int lang = this->qt->traks[this->qt->audio_traks[channel]].lang;
+        if ((lang < 0x400) || (lang == 0x7fff)) {
+          sprintf (str, "%d", channel);
+        } else {
+          int i;
+          for (i = 10; i >= 0; i -= 5)
+            *str++ = 0x60 | ((lang >> i) & 0x1f);
+          *str = 0;
+        }
+        return DEMUX_OPTIONAL_SUCCESS;
+      }
+    }
+    break;
+    default: ;
+  }
   return DEMUX_OPTIONAL_UNSUPPORTED;
 }
 
@


1.19
log
@Update to Xine-lib 1.2.4.

ok juanfra@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.18
log
@Update to stable, xine-lib-1.1.21.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.17 2012/04/28 09:14:33 ajacoutot Exp $
d3 3
a5 2
- Made demux_ts send pts not dts even for reordered (b-framed) video.
- Fix demux_qt for the pts < dts case.
d7 15
a21 9
--- src/demuxers/demux_qt.c.orig	Tue Oct  4 18:40:59 2011
+++ src/demuxers/demux_qt.c	Thu Apr 26 14:33:18 2012
@@@@ -83,6 +83,7 @@@@ typedef unsigned int qt_atom;
 #define STSC_ATOM QT_ATOM('s', 't', 's', 'c')
 #define STCO_ATOM QT_ATOM('s', 't', 'c', 'o')
 #define STTS_ATOM QT_ATOM('s', 't', 't', 's')
+#define CTTS_ATOM QT_ATOM('c', 't', 't', 's')
 #define STSS_ATOM QT_ATOM('s', 't', 's', 's')
 #define CO64_ATOM QT_ATOM('c', 'o', '6', '4')
d23 21
a43 19
@@@@ -165,6 +166,11 @@@@ typedef enum {
 typedef struct {
   int64_t offset;
   unsigned int size;
+  /* pts actually is dts for reordered video. Edit list and frame
+     duration code relies on that, so keep the offset separately
+     until sending to video fifo.
+     Value is small enough for plain int. */
+  int ptsoffs;
   int64_t pts;
   int keyframe;
   unsigned int media_id;
@@@@ -301,6 +307,10 @@@@ typedef struct {
   unsigned int time_to_sample_count;
   time_to_sample_table_t *time_to_sample_table;
 
+  /* pts to dts timeoffset to sample table */
+  unsigned int timeoffs_to_sample_count;
+  time_to_sample_table_t *timeoffs_to_sample_table;
d48 7
a54 33
@@@@ -640,6 +650,7 @@@@ static void free_qt_info(qt_info *info) {
         free(info->traks[i].sync_sample_table);
         free(info->traks[i].sample_to_chunk_table);
         free(info->traks[i].time_to_sample_table);
+        free(info->traks[i].timeoffs_to_sample_table);
         free(info->traks[i].decoder_config);
         for (j = 0; j < info->traks[i].stsd_atoms_count; j++) {
           if (info->traks[i].type == MEDIA_AUDIO) {
@@@@ -981,6 +992,8 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
   trak->sample_to_chunk_table = NULL;
   trak->time_to_sample_count = 0;
   trak->time_to_sample_table = NULL;
+  trak->timeoffs_to_sample_count = 0;
+  trak->timeoffs_to_sample_table = NULL;
   trak->frames = NULL;
   trak->frame_count = 0;
   trak->current_frame = 0;
@@@@ -1685,6 +1698,47 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
           trak->time_to_sample_table[j].duration);
       }
       trak->time_to_sample_table[j].count = 0; /* terminate with zero */
+
+    } else if (current_atom == CTTS_ATOM) {
+
+      /* TJ. this has the same format as stts. If present, duration here
+         means (pts - dts), while the corresponding stts defines dts. */
+
+      /* there should only be one of these atoms */
+      if (trak->timeoffs_to_sample_table
+          || current_atom_size < 12 || current_atom_size >= UINT_MAX) {
+        last_error = QT_HEADER_TROUBLE;
+        goto free_trak;
+      }
d56 59
a114 1
+      trak->timeoffs_to_sample_count = _X_BE_32(&trak_atom[i + 8]);
d116 2
a117 2
+      debug_atom_load("    qt ctts atom (timeoffset-to-sample atom): %d entries\n",
+        trak->timeoffs_to_sample_count);
d119 117
a235 3
+      if (trak->timeoffs_to_sample_count > (current_atom_size - 12) / 8) {
+        last_error = QT_HEADER_TROUBLE;
+        goto free_trak;
d237 242
d480 59
a538 5
+      trak->timeoffs_to_sample_table = (time_to_sample_table_t *)calloc(
+        trak->timeoffs_to_sample_count+1, sizeof(time_to_sample_table_t));
+      if (!trak->timeoffs_to_sample_table) {
+        last_error = QT_NO_MEMORY;
+        goto free_trak;
d540 16
d557 7
a563 11
+      /* load the pts to dts time offset to sample table */
+      for (j = 0; j < trak->timeoffs_to_sample_count; j++) {
+        trak->timeoffs_to_sample_table[j].count =
+          _X_BE_32(&trak_atom[i + 12 + j * 8 + 0]);
+        trak->timeoffs_to_sample_table[j].duration =
+          _X_BE_32(&trak_atom[i + 12 + j * 8 + 4]);
+        debug_atom_load("      %d: count = %d, duration = %d\n",
+          j, trak->timeoffs_to_sample_table[j].count,
+          trak->timeoffs_to_sample_table[j].duration);
+      }
+      trak->timeoffs_to_sample_table[j].count = 0; /* terminate with zero */
d565 25
d591 66
d658 7
a664 48
@@@@ -1700,6 +1754,7 @@@@ free_trak:
   free(trak->sync_sample_table);
   free(trak->sample_to_chunk_table);
   free(trak->time_to_sample_table);
+  free(trak->timeoffs_to_sample_table);
   free(trak->decoder_config);
   if (trak->stsd_atoms) {
     for (i = 0; i < trak->stsd_atoms_count; i++)
@@@@ -1853,6 +1908,8 @@@@ static qt_error build_frame_table(qt_trak *trak,
   int64_t current_pts;
   unsigned int pts_index;
   unsigned int pts_index_countdown;
+  unsigned int ptsoffs_index;
+  unsigned int ptsoffs_index_countdown;
   unsigned int audio_frame_counter = 0;
   unsigned int edit_list_media_time;
   int64_t edit_list_duration;
@@@@ -1887,6 +1944,10 @@@@ static qt_error build_frame_table(qt_trak *trak,
     pts_index = 0;
     pts_index_countdown =
       trak->time_to_sample_table[pts_index].count;
+    /* used by reordered video */
+    ptsoffs_index = 0;
+    ptsoffs_index_countdown = trak->timeoffs_to_sample_count ?
+      trak->timeoffs_to_sample_table[ptsoffs_index].count : 0;
 
     media_id_counts = calloc(trak->stsd_atoms_count, sizeof(int));
     if (!media_id_counts)
@@@@ -1957,6 +2018,23 @@@@ static qt_error build_frame_table(qt_trak *trak,
               trak->time_to_sample_table[pts_index].count;
           }
 
+          /* offset pts for reordered video */
+          if (ptsoffs_index < trak->timeoffs_to_sample_count) {
+            /* TJ. this is 32 bit signed. All casts necessary for my gcc 4.5.0 */
+            int i = trak->timeoffs_to_sample_table[ptsoffs_index].duration;
+            if ((sizeof (int) > 4) && (i & 0x80000000))
+              i |= ~0xffffffffL;
+            trak->frames[frame_counter].ptsoffs = (int)90000 * i / (int)trak->timescale;
+            ptsoffs_index_countdown--;
+            /* time to refresh countdown? */
+            if (!ptsoffs_index_countdown) {
+              ptsoffs_index++;
+              ptsoffs_index_countdown =
+                trak->timeoffs_to_sample_table[ptsoffs_index].count;
+            }
+          } else
+            trak->frames[frame_counter].ptsoffs = 0;
d666 24
a689 17
           samples_per_chunk--;
           frame_counter++;
         }
@@@@ -2051,6 +2129,7 @@@@ static qt_error build_frame_table(qt_trak *trak,
           trak->frames[j].pts = audio_frame_counter;
           trak->frames[j].pts *= 90000;
           trak->frames[j].pts /= trak->timescale;
+          trak->frames[j].ptsoffs = 0;
 
           /* fetch the alleged chunk size according to the QT header */
           trak->frames[j].size =
@@@@ -2592,7 +2671,7 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
         buf->extra_info->input_normpos = (int)( (double) (video_trak->frames[i].offset - this->data_start)
                                                 * 65535 / this->data_size);
       buf->extra_info->input_time = video_trak->frames[i].pts / 90;
-      buf->pts = video_trak->frames[i].pts;
+      buf->pts = video_trak->frames[i].pts + (int64_t)video_trak->frames[i].ptsoffs;
a690 2
       buf->decoder_flags |= BUF_FLAG_FRAMERATE;
       buf->decoder_info[0] = frame_duration;
@


1.17
log
@Merge several bugfixes from upstream.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.16 2012/04/07 05:48:49 ajacoutot Exp $
@


1.16
log
@Bring a bunch of bugfixes from upstream.

from Brad
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
Made demux_ts send pts not dts even for reordered (b-framed) video.
d6 2
a7 2
--- src/demuxers/demux_qt.c.orig	Fri Apr  6 19:58:54 2012
+++ src/demuxers/demux_qt.c	Fri Apr  6 20:05:29 2012
d132 1
a132 1
@@@@ -1957,6 +2018,21 @@@@ static qt_error build_frame_table(qt_trak *trak,
d138 5
a142 3
+            trak->frames[frame_counter].ptsoffs = 90000 *
+              trak->timeoffs_to_sample_table[ptsoffs_index].duration /
+              trak->timescale;
d156 1
a156 1
@@@@ -2051,6 +2127,7 @@@@ static qt_error build_frame_table(qt_trak *trak,
d164 1
a164 1
@@@@ -2592,7 +2669,7 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
@


1.15
log
@update to xine-lib 1.1.20, from Brad
@
text
@d1 1
a1 1
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.14 2011/10/09 20:45:07 sthen Exp $
d3 1
a3 2
- Add f4v/f4a file extensions to the Qt demuxer.
- Better support for 24-bit LPCM.
d5 52
a56 59
--- src/demuxers/demux_qt.c.orig	Sat Jul 24 18:21:31 2010
+++ src/demuxers/demux_qt.c	Wed Sep 28 04:09:22 2011
@@@@ -90,6 +90,7 @@@@ typedef unsigned int qt_atom;
 #define WAVE_ATOM QT_ATOM('w', 'a', 'v', 'e')
 #define FRMA_ATOM QT_ATOM('f', 'r', 'm', 'a')
 #define AVCC_ATOM QT_ATOM('a', 'v', 'c', 'C')
+#define ENDA_ATOM QT_ATOM('e', 'n', 'd', 'a')
 
 #define IMA4_FOURCC ME_FOURCC('i', 'm', 'a', '4')
 #define MAC3_FOURCC ME_FOURCC('M', 'A', 'C', '3')
@@@@ -103,6 +104,8 @@@@ typedef unsigned int qt_atom;
 #define TWOS_FOURCC ME_FOURCC('t', 'w', 'o', 's')
 #define SOWT_FOURCC ME_FOURCC('s', 'o', 'w', 't')
 #define RAW_FOURCC  ME_FOURCC('r', 'a', 'w', ' ')
+#define IN24_FOURCC ME_FOURCC('i', 'n', '2', '4')
+#define NI42_FOURCC ME_FOURCC('4', '2', 'n', 'i')
 #define AVC1_FOURCC ME_FOURCC('a', 'v', 'c', '1')
 
 #define UDTA_ATOM QT_ATOM('u', 'd', 't', 'a')
@@@@ -1250,6 +1253,13 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
           trak->stsd_atoms[k].audio.channels = trak_atom[atom_pos + 0x15];
           trak->stsd_atoms[k].audio.bits = trak_atom[atom_pos + 0x17];
 
+          /* 24-bit audio doesn't always declare itself properly, and can be big- or little-endian */
+          if (trak->stsd_atoms[k].audio.codec_fourcc == IN24_FOURCC) {
+            trak->stsd_atoms[k].audio.bits = 24;
+            if (_X_BE_32(&trak_atom[atom_pos + 0x48]) == ENDA_ATOM && trak_atom[atom_pos + 0x4D])
+              trak->stsd_atoms[k].audio.codec_fourcc = NI42_FOURCC;
+          }
+
           /* assume uncompressed audio parameters */
           trak->stsd_atoms[k].audio.bytes_per_sample =
             trak->stsd_atoms[k].audio.bits / 8;
@@@@ -1312,11 +1322,13 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
            * appears to be a handler for uncompressed data; if there are an
            * extra 0x10 bytes, there are some more useful decoding params;
            * further, do not do load these parameters if the audio is just
-           * PCM ('raw ', 'twos', or 'sowt') */
+           * PCM ('raw ', 'twos', 'sowt' or 'in24') */
           if ((current_stsd_atom_size > 0x24) &&
               (trak->stsd_atoms[k].audio.codec_fourcc != TWOS_FOURCC) &&
               (trak->stsd_atoms[k].audio.codec_fourcc != SOWT_FOURCC) &&
-              (trak->stsd_atoms[k].audio.codec_fourcc != RAW_FOURCC)) {
+              (trak->stsd_atoms[k].audio.codec_fourcc != RAW_FOURCC)  &&
+              (trak->stsd_atoms[k].audio.codec_fourcc != IN24_FOURCC) &&
+              (trak->stsd_atoms[k].audio.codec_fourcc != NI42_FOURCC)) {
 
             if (_X_BE_32(&trak_atom[atom_pos + 0x20]))
               trak->stsd_atoms[k].audio.samples_per_packet =
@@@@ -2400,6 +2412,7 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
   buf_element_t *buf = NULL;
   unsigned int i, j;
   unsigned int remaining_sample_bytes;
+  unsigned int frame_aligned_buf_size;
   int frame_duration;
   int first_buf;
   qt_trak *video_trak = NULL;
@@@@ -2655,9 +2668,15 @@@@ static int demux_qt_send_chunk(demux_plugin_t *this_ge
         buf->pts = audio_trak->frames[i].pts;
d58 109
d168 2
a169 34
-      if (remaining_sample_bytes > buf->max_size)
-        buf->size = buf->max_size;
+      /* 24-bit audio doesn't fit evenly into the default 8192-byte buffers */
+      if (audio_trak->properties->audio.bits == 24)
+        frame_aligned_buf_size = 8184;
       else
+        frame_aligned_buf_size = buf->max_size;
+
+      if (remaining_sample_bytes > frame_aligned_buf_size)
+        buf->size = frame_aligned_buf_size;
+      else
         buf->size = remaining_sample_bytes;
       remaining_sample_bytes -= buf->size;
 
@@@@ -3255,7 +3274,7 @@@@ static const char *get_identifier (demux_class_t *this
 }
 
 static const char *get_extensions (demux_class_t *this_gen) {
-  return "mov qt qtl mp4 m4a m4b";
+  return "mov qt qtl mp4 m4a m4b f4a f4v";
 }
 
 static const char *get_mimetypes (demux_class_t *this_gen) {
@@@@ -3263,8 +3282,8 @@@@ static const char *get_mimetypes (demux_class_t *this_
          "video/x-quicktime: mov,qt: Quicktime animation;"
          "audio/x-m4a: m4a,m4b: MPEG-4 audio;"
          "application/x-quicktimeplayer: qtl: Quicktime list;"
-         "video/mp4: mp4,mpg4: MPEG-4 video;"
-         "audio/mp4: mp4,mpg4: MPEG-4 audio;";
+         "video/mp4: f4v,mp4,mpg4: MPEG-4 video;"
+         "audio/mp4: f4a,mp4,mpg4: MPEG-4 audio;";
 }
 
 static void class_dispose (demux_class_t *this_gen) {
@


1.14
log
@Backport support to xine-lib for VP8 (WebM) and RealVideo 3/4, improved
24-bit LPCM support and various bug fixes. From Brad.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.13 2011/05/11 09:05:54 dcoppa Exp $
@


1.13
log
@- Get rid of the use of libtool's -tag=disable-static.

- Merge in a whole bunch of various fixes from upstream and add
  comments for the existing fixes which didn't have a comment in
  the patch.

From Brad; OK sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.12 2011/04/15 23:22:31 sthen Exp $
d3 2
a4 1
Add f4v/f4a file extensions to the Qt demuxer.
d7 75
a81 2
+++ src/demuxers/demux_qt.c	Fri Apr 15 17:46:25 2011
@@@@ -3255,7 +3255,7 @@@@ static const char *get_identifier (demux_class_t *this
d90 1
a90 1
@@@@ -3263,8 +3263,8 @@@@ static const char *get_mimetypes (demux_class_t *this_
@


1.12
log
@remove casts now that NULL is a void *
from Brad.
@
text
@d1 4
a4 1
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.11 2010/10/15 14:13:03 dcoppa Exp $
@


1.11
log
@Recognize the f4a / f4v extensions.

From Brad (maintainer)
@
text
@d1 3
a3 12
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.10 2010/03/21 01:41:15 sthen Exp $
--- src/demuxers/demux_qt.c.orig	Sun Jul 25 00:21:31 2010
+++ src/demuxers/demux_qt.c	Fri Oct 15 15:50:29 2010
@@@@ -3184,7 +3184,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
       /* special consideration for DRM-protected files */
       if (this->qt->last_error == QT_DRM_NOT_SUPPORTED)
         _x_message (this->stream, XINE_MSG_ENCRYPTED_SOURCE,
-          "DRM-protected Quicktime file", NULL);
+          "DRM-protected Quicktime file", (char *)NULL);
 
     } else if (last_error != QT_OK) {
 
@


1.10
log
@update to 1.1.18.1, from Brad
@
text
@d1 3
a3 3
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.9 2010/01/05 11:48:51 sthen Exp $
--- src/demuxers/demux_qt.c.orig	Mon Jan 25 19:54:27 2010
+++ src/demuxers/demux_qt.c	Tue Feb 23 19:29:38 2010
d13 20
@


1.9
log
@Update to xine-lib 1.1.17 and disable win32 codecs. From Brad.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.8 2009/04/04 00:28:56 sthen Exp $
--- src/demuxers/demux_qt.c.orig	Mon Nov 30 15:55:56 2009
+++ src/demuxers/demux_qt.c	Wed Dec  2 19:15:35 2009
@@@@ -3060,7 +3060,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.8
log
@Security update to 1.1.16.3 from Brad (maintainer) - int overflows in
the 4XM demux (TKADV2009-004, CVE-2009-0385) and the Quicktime demux.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.7 2009/02/02 22:00:42 sthen Exp $
--- src/demuxers/demux_qt.c.orig	Thu Apr  2 14:44:44 2009
+++ src/demuxers/demux_qt.c	Fri Apr  3 14:42:42 2009
@@@@ -3055,7 +3055,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.7
log
@- SECURITY update to Xine-lib 1.1.16.1
  - Heap overflow in Quicktime atom parsing.  (CVE-2008-5234 vector 1)
  - Multiple buffer overflows.                (CVE-2008-5236)
  - Multiple integer overflows.               (CVE-2008-5237)
  - Unchecked read function results.          (CVE-2008-5239)
  - Unchecked malloc using untrusted values.  (CVE-2008-5240 vectors 3 & 4)
  - Buffer indexing using an untrusted value. (CVE-2008-5243)
- Clean up the Makefile
- Enable the Xv motion compensation support
- Remove the JACK sound support
- Remove the now unnecessary multi-packaging
- Remove an unnecessary patch for the Sun sound code
- Comment out some files in the PLIST that do not pertain to OpenBSD
- Add WavPack support

from Brad (taking MAINTAINER).
@
text
@d1 4
a4 4
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.6 2008/06/18 01:26:41 brad Exp $
--- src/demuxers/demux_qt.c.orig	Wed Jan  7 11:14:32 2009
+++ src/demuxers/demux_qt.c	Thu Jan  8 01:02:34 2009
@@@@ -3049,7 +3049,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.7.2.1
log
@Security fix

Resolve another int overflow in the 4XM demux and the Quicktime demux.

From upstream mercurial repository.

ok robert@@
@
text
@d1 4
a4 30
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.7 2009/02/02 22:00:42 sthen Exp $

First two chunks are from upstream changeset 9758  d21a4564db03:
Fix an integer overflow in the Quicktime demuxer.

--- src/demuxers/demux_qt.c.orig	Sun Feb  8 13:56:51 2009
+++ src/demuxers/demux_qt.c	Sat Jul 11 15:23:07 2009
@@@@ -1535,7 +1535,8 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
     } else if (current_atom == STTS_ATOM) {
 
       /* there should only be one of these atoms */
-      if (trak->time_to_sample_table) {
+      if (trak->time_to_sample_table
+          || current_atom_size < 12 || current_atom_size >= UINT_MAX) {
         last_error = QT_HEADER_TROUBLE;
         goto free_trak;
       }
@@@@ -1545,6 +1546,11 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
       debug_atom_load("    qt stts atom (time-to-sample atom): %d entries\n",
         trak->time_to_sample_count);
 
+      if (trak->time_to_sample_count > (current_atom_size - 12) / 8) {
+        last_error = QT_HEADER_TROUBLE;
+        goto free_trak;
+      }
+
       trak->time_to_sample_table = (time_to_sample_table_t *)calloc(
         trak->time_to_sample_count+1, sizeof(time_to_sample_table_t));
       if (!trak->time_to_sample_table) {
@@@@ -3049,7 +3055,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.6
log
@update to Xine-lib 1.1.13

This release contains a security fix (buffer overflow in the NSF demuxer,
CVE-2008-1878). There are also a few bug fixes, and a new JACK output
plugin.

ok jakemsr@@
@
text
@d1 4
a4 4
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.5 2008/04/15 11:24:14 jakemsr Exp $
--- src/demuxers/demux_qt.c.orig	Sat Jun 14 19:15:00 2008
+++ src/demuxers/demux_qt.c	Mon Jun 16 02:30:50 2008
@@@@ -3022,7 +3022,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.5
log
@update to xine-lib-1.1.12

This release contains a security fix (unchecked array index,
CVE-2008-1686). There are also a few bug fixes, and open-source
support for RealAudio "cook". For front-end package maintainers,
there's a tool to help maintain MIME type lists, and for developers
who need raw frame data, you can now get that with the "raw" video
output plugin.

from brad@@
@
text
@d1 4
a4 4
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.4 2008/04/06 10:12:23 jakemsr Exp $
--- src/demuxers/demux_qt.c.orig	Mon Apr 14 16:27:20 2008
+++ src/demuxers/demux_qt.c	Mon Apr 14 20:28:43 2008
@@@@ -3023,7 +3023,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.4
log
@
fixes for quicktime, matroska and wavpack pulled from xine-lib repo
by brad@@

fixes problem reported by viq on ports@@
@
text
@d1 4
a4 16
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.3 2008/03/31 11:28:59 jakemsr Exp $
--- src/demuxers/demux_qt.c.orig	Fri Mar 28 18:50:47 2008
+++ src/demuxers/demux_qt.c	Tue Apr  1 19:47:19 2008
@@@@ -896,11 +896,6 @@@@ static qt_error parse_trak_atom (qt_trak *trak,
     current_atom_size = _X_BE_32(&trak_atom[i - 4]);	
     current_atom = _X_BE_32(&trak_atom[i]);
 
-    if (current_atom_size > trak_atom_size - i) {
-      last_error = QT_NOT_A_VALID_FILE;
-      goto free_trak;
-    }
-
     if (current_atom == TKHD_ATOM) {
       trak->flags = _X_BE_16(&trak_atom[i + 6]);
     } else if (current_atom == ELST_ATOM) {
@@@@ -3028,7 +3023,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.3
log
@update to xine-lib-1.1.11.1

* Security fixes:
  - Integer overflows in FLV, Qt, Real, WC3Movie, Matroska and FILM
    demuxers, allowing remote attackers to trigger heap overflows and
    possibly execute arbitrary code. (CVE-2008-1482)
* Added a few more memory allocation checks to the above demuxers.
* WAV file playback fix: don't assume that the first chunk is "fmt ".
* Don't try to play partial 24-bit AIFF frames (decoder would lose data).
* Fixed AIFF comment chunk handling and sample rate reading.
* LPCM fixes: input over-reading, conversion of 24-bit samples.

from brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.2 2008/01/15 00:36:46 jakemsr Exp $
d3 14
a16 2
+++ src/demuxers/demux_qt.c	Sun Mar 30 23:24:31 2008
@@@@ -3028,7 +3028,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.2
log
@update to 1.1.9.1

security fix: CVE-2008-0225 - heap-based buffer overflow in libreal (RTSP)

also incorporates post release bug fix in WMV decoding

from brad, thanks
@
text
@d1 4
a4 4
$OpenBSD: patch-src_demuxers_demux_qt_c,v 1.1 2007/06/13 10:58:29 jakemsr Exp $
--- src/demuxers/demux_qt.c.orig	Tue Jan  1 08:30:08 2008
+++ src/demuxers/demux_qt.c	Wed Jan  9 01:50:21 2008
@@@@ -2986,7 +2986,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@


1.1
log
@update to xine-lib-1.1.7

- use some CONFIGURE_ENV instead of patching
- rearrange/update CONFIGURE_ARGS
- many patches no longer relevant
- add CD audio support

input, tetsing and prodding from brad@@
@
text
@d1 4
a4 4
$OpenBSD$
--- src/demuxers/demux_qt.c.orig	Thu May 31 08:57:27 2007
+++ src/demuxers/demux_qt.c	Fri Jun  8 17:27:46 2007
@@@@ -2989,7 +2989,7 @@@@ static demux_plugin_t *open_plugin (demux_class_t *cla
@

