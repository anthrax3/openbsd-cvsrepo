head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.14
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.12
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.10
	OPENBSD_5_0:1.4.0.8
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@# @;


1.8
date	2014.05.05.11.51.37;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.26.12.47.44;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2013.01.19.08.42.35;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.06.15.01.06;	author ajacoutot;	state dead;
branches;
next	1.4;

1.4
date	2009.08.18.22.24.14;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.09.02.13.01;	author jakemsr;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.26.02.17.50;	author jakemsr;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.24.07.57.01;	author jakemsr;	state Exp;
branches;
next	;


desc
@@


1.8
log
@- Pull in some bits to deal with newer FFmpeg API. While testing I found
transcode was already broken as is due to it relying on certain functionality
with presets which is no longer relevant for more modern FFmpeg. Searching
via Google showed the same bug being reported with Debian, Gentoo and Arch.
They have eliminted the use of presets but that just exposed another bug.
So this builds with newer FFmpeg but it is essentially just as broken as
before. If anyone wants to take a look at this and figure out why it is
crashing go ahead.
- Merge the quicktime FLAVOR into the main port / package. IMO it doesn't
make sense to have an app like this that cannot work with the MP4 container

FFmpeg bits taken from FreeBSD and Debian packages.

ok ajacoutot@@
@
text
@$OpenBSD: patch-export_export_ffmpeg_c,v 1.7 2013/01/26 12:47:44 brad Exp $

Update for newer FFmpeg API.

--- export/export_ffmpeg.c.orig	Sat Nov 19 11:50:27 2011
+++ export/export_ffmpeg.c	Mon May  5 02:55:13 2014
@@@@ -122,6 +122,7 @@@@ static uint8_t             *img_buffer = NULL;
 static AVFrame             *lavc_convert_frame = NULL;
 
 static AVCodec             *lavc_venc_codec = NULL;
+static AVDictionary        *lavc_venc_opts = NULL;
 static AVFrame             *lavc_venc_frame = NULL;
 static AVCodecContext      *lavc_venc_context;
 static avi_t               *avifile = NULL;
@@@@ -180,7 +181,7 @@@@ static char *tc_strchrnul(const char *s, int c) {
 
 
 /* START: COPIED FROM ffmpeg-0.5_p22846(ffmpeg.c, cmdutils.c) */
-#include <libavcodec/opt.h>
+#include <libavutil/opt.h>
 #include <libavutil/avstring.h>
 #include <libswscale/swscale.h>
 
@@@@ -239,6 +240,14 @@@@ static void opt_subtitle_codec(const char *arg)
     opt_codec(&subtitle_stream_copy, &subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, arg);
 }
 
+static int av_set_string3_fallback(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)
+{
+    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);
+    if (o_out)
+        *o_out = o;
+    return av_opt_set(obj, name, val, 0);
+}
+
 static
 int opt_default(const char *opt, const char *arg){
     int type;
@@@@ -249,9 +258,9 @@@@ int opt_default(const char *opt, const char *arg){
     for(type=0; type<AVMEDIA_TYPE_NB && ret>= 0; type++){
 		/* GLUE: +if */
 		if (type == AVMEDIA_TYPE_VIDEO) {
-        const AVOption *o2 = av_find_opt(avcodec_opts[0], opt, NULL, opt_types[type], opt_types[type]);
+        const AVOption *o2 = av_opt_find(avcodec_opts[0], opt, NULL, opt_types[type], 0);
         if(o2)
-            ret = av_set_string3(avcodec_opts[type], opt, arg, 1, &o);
+            ret = av_set_string3_fallback(avcodec_opts[type], opt, arg, 1, &o);
 		/* GLUE: +if */
 		}
     }
@@@@ -266,7 +275,7 @@@@ int opt_default(const char *opt, const char *arg){
         if(opt[0] == 'a')
             ret = av_set_string3(avcodec_opts[AVMEDIA_TYPE_AUDIO], opt+1, arg, 1, &o);
         else */ if(opt[0] == 'v')
-            ret = av_set_string3(avcodec_opts[AVMEDIA_TYPE_VIDEO], opt+1, arg, 1, &o);
+            ret = av_set_string3_fallback(avcodec_opts[AVMEDIA_TYPE_VIDEO], opt+1, arg, 1, &o);
 		/* GLUE: disabling
         else if(opt[0] == 's')
             ret = av_set_string3(avcodec_opts[AVMEDIA_TYPE_SUBTITLE], opt+1, arg, 1, &o);
@@@@ -470,7 +479,6 @@@@ MOD_init
     }
 
     TC_LOCK_LIBAVCODEC;
-    avcodec_init();
     avcodec_register_all();
     TC_UNLOCK_LIBAVCODEC;
 
@@@@ -486,7 +494,7 @@@@ MOD_init
 		            codec->name, codec->fourCC, codec->comments);
     }
 
-    lavc_venc_context = avcodec_alloc_context();
+    lavc_venc_context = avcodec_alloc_context3(lavc_venc_codec);
     lavc_venc_frame   = avcodec_alloc_frame();
 
     lavc_convert_frame= avcodec_alloc_frame();
@@@@ -634,7 +642,7 @@@@ MOD_init
         lavc_param_rc_max_rate = 2516;
         lavc_param_rc_buffer_size = 224 * 8;
         lavc_param_rc_buffer_aggressivity = 99;
-        lavc_param_scan_offset = CODEC_FLAG_SVCD_SCAN_OFFSET;
+        lavc_param_scan_offset = 1;
 
         break;
 
@@@@ -674,7 +682,7 @@@@ MOD_init
 
         lavc_param_rc_buffer_size = 224 * 8;
         lavc_param_rc_buffer_aggressivity = 99;
-        lavc_param_scan_offset = CODEC_FLAG_SVCD_SCAN_OFFSET;
+        lavc_param_scan_offset = 1;
 
         break;
 
@@@@ -838,8 +846,13 @@@@ MOD_init
     lavc_venc_context->rc_strategy        = lavc_param_vrc_strategy;
     lavc_venc_context->b_frame_strategy   = lavc_param_vb_strategy;
     lavc_venc_context->b_quant_offset     = lavc_param_vb_qoffset;
-    lavc_venc_context->luma_elim_threshold= lavc_param_luma_elim_threshold;
-    lavc_venc_context->chroma_elim_threshold= lavc_param_chroma_elim_threshold;
+
+    char buf[1024];
+#define set_dict_opt(val, opt) \
+       snprintf(buf, sizeof(buf), "%i", val); \
+       av_dict_set(&lavc_venc_opts, opt, buf, 0)
+    set_dict_opt(lavc_param_luma_elim_threshold, "luma_elim_threshold");
+    set_dict_opt(lavc_param_chroma_elim_threshold, "chroma_elim_threshold");
     lavc_venc_context->rtp_payload_size   = lavc_param_packet_size;
 #if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)   
     if (lavc_param_packet_size)
@@@@ -870,7 +883,7 @@@@ MOD_init
     lavc_venc_context->context_model      = lavc_param_context;
     lavc_venc_context->scenechange_threshold= lavc_param_sc_threshold;
     lavc_venc_context->noise_reduction    = lavc_param_noise_reduction;
-    lavc_venc_context->inter_threshold    = lavc_param_inter_threshold;
+    set_dict_opt(lavc_param_inter_threshold, "inter_threshold");
     lavc_venc_context->intra_dc_precision = lavc_param_intra_dc_precision;
     lavc_venc_context->skip_top           = lavc_param_skip_top;
     lavc_venc_context->skip_bottom        = lavc_param_skip_bottom;
@@@@ -887,7 +900,7 @@@@ MOD_init
 		    lavc_venc_context->thread_count);
     }
 
-    avcodec_thread_init(lavc_venc_context, lavc_param_threads);
+    lavc_venc_context->thread_count = lavc_param_threads;
 
     if (lavc_param_intra_matrix) {
         char *tmp;
@@@@ -1065,15 +1078,12 @@@@ MOD_init
     lavc_venc_context->flags |= lavc_param_closedgop;
     lavc_venc_context->flags |= lavc_param_trunc;
     lavc_venc_context->flags |= lavc_param_aic;
-    lavc_venc_context->flags |= lavc_param_umv;
     lavc_venc_context->flags |= lavc_param_v4mv;
-    lavc_venc_context->flags |= lavc_param_data_partitioning;
-    lavc_venc_context->flags |= lavc_param_cbp;
+    if(lavc_param_cbp)
+       av_dict_set(&lavc_venc_opts, "mpv_flags", "+cbp_rd", 0);
     lavc_venc_context->flags |= lavc_param_mv0;
-    lavc_venc_context->flags |= lavc_param_qp_rd;
-    lavc_venc_context->flags |= lavc_param_scan_offset;
-    lavc_venc_context->flags |= lavc_param_ss;
-    lavc_venc_context->flags |= lavc_param_alt;
+    if(lavc_param_qp_rd)
+       av_dict_set(&lavc_venc_opts, "mpv_flags", "+qp_rd", 0);
     lavc_venc_context->flags |= lavc_param_ilme;
 #if LIBAVCODEC_VERSION_INT < ((52<<16)+(0<<8)+0)   
     lavc_venc_context->flags |= lavc_param_trell;
@@@@ -1241,20 +1251,39 @@@@ MOD_init
 		}
 	}
 
+    if (lavc_param_scan_offset) {
+        av_dict_set(&lavc_venc_opts, "scan_offset", "1", 0);
+    }
 
+    if (lavc_param_ss) {
+        av_dict_set(&lavc_venc_opts, "structured_slices", "1", 0);
+    }
+
+   if (lavc_param_alt) {
+       av_dict_set(&lavc_venc_opts, "alternate_scan", "1", 0);
+    }
+
+    if (lavc_param_umv) {
+        av_dict_set(&lavc_venc_opts, "umv", "1", 0);
+    }
+
+    if (lavc_param_data_partitioning) {
+        av_dict_set(&lavc_venc_opts, "vdpart", "1", 0);
+    }
+
     //-- open codec --
     //----------------
     TC_LOCK_LIBAVCODEC;
-    ret = avcodec_open(lavc_venc_context, lavc_venc_codec);
+    ret = avcodec_open2(lavc_venc_context, lavc_venc_codec, &lavc_venc_opts);
     TC_UNLOCK_LIBAVCODEC;
     if (ret < 0) {
       tc_log_warn(MOD_NAME, "could not open FFMPEG codec");
       return TC_EXPORT_ERROR;
     }
 
-    if (lavc_venc_context->codec->encode == NULL) {
+    if (av_codec_is_encoder(lavc_venc_context->codec) == 0) {
       tc_log_warn(MOD_NAME, "could not open FFMPEG codec "
-              "(lavc_venc_context->codec->encode == NULL)");
+              "(av_codec_is_encoder(lavc_venc_context->codec) == 0)");
       return TC_EXPORT_ERROR;
     }
 
@


1.7
log
@Add a comment to the patches.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-export_export_ffmpeg_c,v 1.6 2013/01/19 08:42:35 brad Exp $
d6 10
a15 2
+++ export/export_ffmpeg.c	Fri Jan 18 22:50:29 2013
@@@@ -180,7 +180,7 @@@@ static char *tc_strchrnul(const char *s, int c) {
d24 37
a60 9
@@@@ -362,6 +362,7 @@@@ static int opt_preset(const char *opt, const char *arg
 MOD_init
 {
     char *user_codec_string = NULL;
+    AVDictionary *opts = NULL;
 
     if (param->flag == TC_VIDEO) {
         size_t fsize = 0;
@@@@ -470,7 +471,6 @@@@ MOD_init
d68 3
a70 5
@@@@ -598,7 +598,6 @@@@ MOD_init
         lavc_param_rc_max_rate = 1150;
         lavc_param_rc_buffer_size = 40 * 8;
         lavc_param_rc_buffer_aggressivity = 99;
-        lavc_param_scan_offset = 0;
d72 3
a74 1
         break;
d76 2
a77 1
@@@@ -634,7 +633,7 @@@@ MOD_init
d82 1
a82 1
+        av_dict_set(&opts, "scan_offset", "1", 0);
d86 1
a86 1
@@@@ -674,7 +673,7 @@@@ MOD_init
d91 1
a91 1
+        av_dict_set(&opts, "scan_offset", "1", 0);
d95 35
a129 1
@@@@ -1065,15 +1064,20 @@@@ MOD_init
a133 2
+    if (lavc_param_umv)
+        av_dict_set(&opts, "umv", "1", 0);
d136 3
a138 3
+    if (lavc_param_data_partitioning)
+        av_dict_set(&opts, "data_partitioning", "1", 0);
     lavc_venc_context->flags |= lavc_param_cbp;
d140 1
a140 1
     lavc_venc_context->flags |= lavc_param_qp_rd;
d144 2
a145 6
+    if (lavc_param_scan_offset)
+        av_dict_set(&opts, "scan_offset", "1", 0);
+    if (lavc_param_ss)
+        av_dict_set(&opts, "structured_slices", "1", 0);
+    if (lavc_param_alt)
+        av_dict_set(&opts, "alternate_scan", "1", 0);
d149 24
a172 10
@@@@ -1082,7 +1086,7 @@@@ MOD_init
 #endif
 
     if (lavc_param_gray)
-        lavc_venc_context->flags |= CODEC_FLAG_GRAY;
+        av_dict_set(&opts, "gray", "1", 0);
     if (lavc_param_normalize_aqp)
         lavc_venc_context->flags |= CODEC_FLAG_NORMALIZE_AQP;
 
@@@@ -1245,14 +1249,14 @@@@ MOD_init
d177 1
a177 1
+    ret = avcodec_open2(lavc_venc_context, lavc_venc_codec, &opts);
d185 1
a185 1
+    if (lavc_venc_context->codec->encode2 == NULL) {
d187 2
a188 1
               "(lavc_venc_context->codec->encode == NULL)");
d190 2
@


1.6
log
@Update for newer FFmpeg API.

ok ajacoutot@@
@
text
@d1 4
a4 1
$OpenBSD$
@


1.5
log
@Remove unnecessary patch; the code already does the right thing.

from Brad
@
text
@d1 106
a106 12
$OpenBSD: patch-export_export_ffmpeg_c,v 1.4 2009/08/18 22:24:14 sthen Exp $
--- export/export_ffmpeg.c.orig	Sat Nov 29 10:43:14 2008
+++ export/export_ffmpeg.c	Thu May  7 21:10:13 2009
@@@@ -81,7 +81,7 @@@@ static struct ffmpeg_codec ffmpeg_codecs[] = {
     {"mpeg2video", "mpg2", "MPEG2 compliant video", 1},
     {"h263",       "h263", "H263", 0},
     {"h263p",      "h263", "H263 plus", 1},
-    {"h264",       "h264", "H264 (avc)", 1},
+    {"libx264",    "h264", "H264", 1},
     {"wmv1",       "WMV1", "Windows Media Video v1", 1},
     {"wmv2",       "WMV2", "Windows Media Video v2", 1},
     {"rv10",       "RV10", "old RealVideo codec", 1},
@


1.4
log
@update 1.0.5->1.1.3, from Brad. Various new features and bug fixes.
@
text
@d1 1
a1 1
$OpenBSD: patch-export_export_ffmpeg_c,v 1.3 2008/07/09 02:13:01 jakemsr Exp $
@


1.3
log
@
* FFmpeg headers moved
* FFmpeg LIB_DEPENDS/WANTLIB changes
* add @@bin markers in PLISTs
* bump PKGNAMEs

feedback/ok brad@@
@
text
@d1 4
a4 13
$OpenBSD: patch-export_export_ffmpeg_c,v 1.2 2008/01/26 02:17:50 jakemsr Exp $
--- export/export_ffmpeg.c.orig	Sat Nov 17 01:35:31 2007
+++ export/export_ffmpeg.c	Sat Jun 21 21:15:39 2008
@@@@ -36,7 +36,7 @@@@
 #include "vid_aux.h"
 // FIXME
 #undef EMULATE_FAST_INT
-#include <ffmpeg/avcodec.h>
+#include <libavcodec/avcodec.h>
 
 #if !defined(INFINITY) && defined(HUGE_VAL)
 #define INFINITY HUGE_VAL
@@@@ -87,7 +87,7 @@@@ static struct ffmpeg_codec ffmpeg_codecs[] = {
@


1.2
log
@maintenence update to 1.0.5
@
text
@d1 1
a1 1
$OpenBSD: patch-export_export_ffmpeg_c,v 1.1 2007/09/24 07:57:01 jakemsr Exp $
d3 10
a12 1
+++ export/export_ffmpeg.c	Sat Jan 19 20:28:14 2008
@


1.1
log
@- libavcodec no longer allows registering individual codecs, so register
  all codecs (from transcode CVS)
- our libavcodec does not have an encoder named 'h264', but it does have
  'libx264'.  H.264 encoding is now possible.
- bump PKGNAME
@
text
@d1 4
a4 4
$OpenBSD$
--- export/export_ffmpeg.c.orig	Sat Sep 15 23:00:30 2007
+++ export/export_ffmpeg.c	Sat Sep 15 23:07:23 2007
@@@@ -126,8 +126,7 @@@@ struct ffmpeg_codec ffmpeg_codecs[] = {
d9 1
a9 2
-    {"avc",        "h264", "H264 (avc)", 1},
+    {"libx264",    "h264", "H264 (libx264)", 1},
@

