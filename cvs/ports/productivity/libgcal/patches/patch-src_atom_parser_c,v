head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.10
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.6
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.8
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.4
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.2
	OPENBSD_5_6_BASE:1.1.1.1
	zhuk_20140709:1.1.1.1
	zhuk:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2014.07.09.10.51.26;	author zhuk;	state Exp;
branches
	1.1.1.1;
next	;
commitid	2PlGHb6XhQ15oU18;

1.1.1.1
date	2014.07.09.10.51.26;	author zhuk;	state Exp;
branches;
next	;
commitid	2PlGHb6XhQ15oU18;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$
BUG: https://code.google.com/p/libgcal/issues/detail?id=95
--- src/atom_parser.c.orig	Fri Jan 24 15:26:28 2014
+++ src/atom_parser.c	Fri Jan 24 15:45:30 2014
@@@@ -235,7 +235,7 @@@@ static int extract_and_check_multi(xmlDoc *doc, char *
 {
 	xmlXPathObject *xpath_obj;
 	xmlNodeSet *node;
-	xmlChar *tmp;
+	xmlChar *tmp, *tmp2;
 	int result = -1;
 	int i;
 
@@@@ -265,11 +265,11 @@@@ static int extract_and_check_multi(xmlDoc *doc, char *
 		goto exit;
 	}
 
-	*values = (char **)malloc(node->nodeNr * sizeof(char*));
+	*values = calloc(node->nodeNr, sizeof(char*));
 	if (attr2)
-		*types = (char **)malloc(node->nodeNr * sizeof(char*));
+		*types = calloc(node->nodeNr, sizeof(char*));
 	if (attr3)
-		*protocols = (char **)malloc(node->nodeNr * sizeof(char*));
+		*protocols = calloc(node->nodeNr, sizeof(char*));
 
 	for (i = 0; i < node->nodeNr; i++) {
 		if (getContent)
@@@@ -282,7 +282,8 @@@@ static int extract_and_check_multi(xmlDoc *doc, char *
 		if (attr2) {
 			if (xmlHasProp(node->nodeTab[i], attr2)) {
 				tmp = xmlGetProp(node->nodeTab[i], attr2);
-				(*types)[i] = strdup(strchr(tmp,'#') + 1);
+				tmp2 = strchr(tmp,'#');
+				(*types)[i] = strdup(tmp2 ? tmp2 : "");
 				xmlFree(tmp);
 			}
 			else
@@@@ -292,7 +293,8 @@@@ static int extract_and_check_multi(xmlDoc *doc, char *
 		if (attr3) {
 			if (xmlHasProp(node->nodeTab[i], attr3)) {
 				tmp = xmlGetProp(node->nodeTab[i], attr3);
-				(*protocols)[i] = strdup(strchr(tmp,'#') + 1);
+				tmp2 = strchr(tmp,'#');
+				(*protocols)[i] = strdup(tmp2 ? tmp2 : "");
 				xmlFree(tmp);
 			}
 			else
@@@@ -323,7 +325,7 @@@@ static int extract_and_check_multisub(xmlDoc *doc, cha
 	xmlXPathObject *xpath_obj;
 	xmlNodeSet *node;
 	xmlNode *child, *cur_node;
-	xmlChar *tmp;
+	xmlChar *tmp, *tmp2;
 	struct gcal_structured_subvalues *tempval;
 	int result = -1;
 	int i;
@@@@ -383,7 +385,8 @@@@ static int extract_and_check_multisub(xmlDoc *doc, cha
 		if (attr1) {
 			if (xmlHasProp(node->nodeTab[i], attr1)) {
 				tmp = xmlGetProp(node->nodeTab[i], attr1);
-				(*types)[i] = strdup(strchr(tmp,'#') + 1);
+				tmp2 = strchr(tmp,'#');
+				(*types)[i] = strdup(tmp2 ? tmp2 : "");
 				xmlFree(tmp);
 			} else
 				(*types)[i] = strdup("");
@


1.1.1.1
log
@libgcal is an ANSI C library that does allow communication with
google calendar and contacts, useful if you need to support this
in a C or C++ application.

Currently, libgcal implements:

 - authentication
 - get all events/contacts
 - atom stream parsing
 - access to individual events/contacts
 - add/delete/edit using gcal objects
 - add/delete/edit using raw XML
 - query for updated events/contacts
 - timezone
 - contact photo download/upload

What is missing: batch commit, calendar (creation of recurrent
events), support other calendars (only the main calendar is currently
supported).

This is a hard dependency for upcoming akonadi-googledata port.

okay landry@@
@
text
@@
