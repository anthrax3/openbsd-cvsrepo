head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.22
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.18
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.20
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.16
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.14
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.12
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.10
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.8
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.6
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2011.07.08.20.36.09;	author naddy;	state Exp;
branches;
next	1.2;

1.2
date	2011.01.03.10.44.27;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.15.10.05.55;	author jasper;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2009.12.29.23.35.04;	author william;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Fix build with png-1.5.
All fixes from/via NetBSD pkgsrc.  The people there did a lot of
heavy lifting.
@
text
@$OpenBSD: patch-src_glyphs-eimage_c,v 1.2 2011/01/03 10:44:27 jasper Exp $

Security fix for CVE-2009-2688, xemacs: multiple integer overflow flaws.
Patch from gentoo.

Fix build with png-1.5.

--- src/glyphs-eimage.c.orig	Mon Aug 20 13:52:28 2007
+++ src/glyphs-eimage.c	Mon Jul  4 15:11:49 2011
@@@@ -407,6 +407,7 @@@@ jpeg_instantiate (Lisp_Object image_instance, Lisp_Obj
    */
 
   {
+    UINT_64_BIT pixels_sq;
     int jpeg_gray = 0;		/* if we're dealing with a grayscale */
     /* Step 4: set parameters for decompression.   */
 
@@@@ -429,7 +430,10 @@@@ jpeg_instantiate (Lisp_Object image_instance, Lisp_Obj
     jpeg_start_decompress (&cinfo);
 
     /* Step 6: Read in the data and put into EImage format (8bit RGB triples)*/
-
+    pixels_sq =
+      (UINT_64_BIT) cinfo.output_width * (UINT_64_BIT) cinfo.output_height;
+    if (pixels_sq > ((size_t) -1) / 3)
+      signal_image_error ("JPEG image too large to instantiate", instantiator);
     unwind.eimage = (unsigned char*) xmalloc (cinfo.output_width * cinfo.output_height * 3);
     if (!unwind.eimage)
       signal_image_error("Unable to allocate enough memory for image", instantiator);
@@@@ -671,6 +675,7 @@@@ gif_instantiate (Lisp_Object image_instance, Lisp_Obje
   {
     ColorMapObject *cmo = unwind.giffile->SColorMap;
     int i, j, row, pass, interlace, slice;
+    UINT_64_BIT pixels_sq;
     unsigned char *eip;
     /* interlaced gifs have rows in this order:
        0, 8, 16, ..., 4, 12, 20, ..., 2, 6, 10, ..., 1, 3, 5, ...  */
@@@@ -679,6 +684,9 @@@@ gif_instantiate (Lisp_Object image_instance, Lisp_Obje
 
     height = unwind.giffile->SHeight;
     width = unwind.giffile->SWidth;
+    pixels_sq = (UINT_64_BIT) width * (UINT_64_BIT) height;
+    if (pixels_sq > ((size_t) -1) / (3 * unwind.giffile->ImageCount))
+      signal_image_error ("GIF image too large to instantiate", instantiator);
     unwind.eimage = (unsigned char*)
       xmalloc (width * height * 3 * unwind.giffile->ImageCount);
     if (!unwind.eimage)
@@@@ -937,11 +945,15 @@@@ png_instantiate (Lisp_Object image_instance, Lisp_Obje
   {
     int y;
     unsigned char **row_pointers;
-    height = info_ptr->height;
-    width = info_ptr->width;
+    UINT_64_BIT pixels_sq;
+    height = png_get_image_height(png_ptr, info_ptr);
+    width = png_get_image_width(png_ptr, info_ptr);
+    pixels_sq = (UINT_64_BIT) width * (UINT_64_BIT) height;
+    if (pixels_sq > ((size_t) -1) / 3)
+      signal_image_error ("PNG image too large to instantiate", instantiator);
 
     /* Wow, allocate all the memory.  Truly, exciting. */
-    unwind.eimage = xnew_array_and_zero (unsigned char, width * height * 3);
+    unwind.eimage = xnew_array_and_zero (unsigned char, pixels_sq * 3);
     /* libpng expects that the image buffer passed in contains a
        picture to draw on top of if the png has any transparencies.
        This could be a good place to pass that in... */
@@@@ -990,22 +1002,22 @@@@ png_instantiate (Lisp_Object image_instance, Lisp_Obje
     /* Now that we're using EImage, ask for 8bit RGB triples for any type
        of image*/
     /* convert palette images to full RGB */
-    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_PALETTE)
       png_set_expand (png_ptr);
     /* send grayscale images to RGB too */
-    if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
-        info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+    if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY ||
+	png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY_ALPHA)
       png_set_gray_to_rgb (png_ptr);
     /* we can't handle alpha values */
-    if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
+    if (png_get_color_type(png_ptr, info_ptr) & PNG_COLOR_MASK_ALPHA)
       png_set_strip_alpha (png_ptr);
     /* tell libpng to strip 16 bit depth files down to 8 bits */
-    if (info_ptr->bit_depth == 16)
+    if (png_get_bit_depth(png_ptr, info_ptr) == 16)
       png_set_strip_16 (png_ptr);
     /* if the image is < 8 bits, pad it out */
-    if (info_ptr->bit_depth < 8)
+    if (png_get_bit_depth(png_ptr, info_ptr) < 8)
       {
-	if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)
+	if (png_get_color_type(png_ptr, info_ptr) == PNG_COLOR_TYPE_GRAY)
 	  png_set_expand (png_ptr);
 	else
 	  png_set_packing (png_ptr);
@@@@ -1268,6 +1280,7 @@@@ tiff_instantiate (Lisp_Object image_instance, Lisp_Obj
 
     uint32 *raster;
     unsigned char *ep;
+    UINT_64_BIT pixels_sq;
 
     assert (!NILP (data));
 
@@@@ -1290,12 +1303,15 @@@@ tiff_instantiate (Lisp_Object image_instance, Lisp_Obj
 
     TIFFGetField (unwind.tiff, TIFFTAG_IMAGEWIDTH, &width);
     TIFFGetField (unwind.tiff, TIFFTAG_IMAGELENGTH, &height);
-    unwind.eimage = (unsigned char *) xmalloc (width * height * 3);
+    pixels_sq = (UINT_64_BIT) width * (UINT_64_BIT) height;
+    if (pixels_sq >= 1 << 29)
+      signal_image_error ("TIFF image too large to instantiate", instantiator);
+    unwind.eimage = (unsigned char *) xmalloc (pixels_sq * 3);
 
     /* #### This is little more than proof-of-concept/function testing.
        It needs to be reimplemented via scanline reads for both memory
        compactness. */
-    raster = (uint32*) _TIFFmalloc (width * height * sizeof (uint32));
+    raster = (uint32*) _TIFFmalloc ((tsize_t) (pixels_sq * sizeof (uint32)));
     if (raster != NULL)
       {
 	int i,j;
@


1.2
log
@- update xemacs to 21.4.22
@
text
@d1 1
a1 1
$OpenBSD: patch-src_glyphs-eimage_c,v 1.1 2009/12/15 10:05:55 jasper Exp $
d4 1
d6 1
a6 1
Patch from gentoo.
d8 2
a9 2
--- src/glyphs-eimage.c.orig	Mon Aug 20 21:52:28 2007
+++ src/glyphs-eimage.c	Sun Jan  2 23:29:57 2011
d52 2
d55 2
a56 2
     height = info_ptr->height;
     width = info_ptr->width;
d67 6
a72 1
@@@@ -994,7 +1006,7 @@@@ png_instantiate (Lisp_Object image_instance, Lisp_Obje
d75 1
a75 1
     if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY ||
d77 2
a78 1
+	info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
d81 16
a96 1
     if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
@


1.1
log
@Security fix for CVE-2009-2688, xemacs: multiple integer overflow flaws.
@
text
@d1 1
a1 1
$OpenBSD$
d7 2
a8 2
--- src/glyphs-eimage.c.orig	Mon Jan 31 03:55:17 2005
+++ src/glyphs-eimage.c	Tue Dec 15 10:57:11 2009
d47 1
a47 1
@@@@ -929,11 +937,15 @@@@ png_instantiate (Lisp_Object image_instance, Lisp_Obje
d64 1
a64 1
@@@@ -986,7 +998,7 @@@@ png_instantiate (Lisp_Object image_instance, Lisp_Obje
d73 1
a73 1
@@@@ -1260,6 +1272,7 @@@@ tiff_instantiate (Lisp_Object image_instance, Lisp_Obj
d81 1
a81 1
@@@@ -1282,12 +1295,15 @@@@ tiff_instantiate (Lisp_Object image_instance, Lisp_Obj
@


1.1.2.1
log
@MFC:

SECURITY FIX

Resolves CVE-2009-2688

ok jasper@@
@
text
@d5 1
@

