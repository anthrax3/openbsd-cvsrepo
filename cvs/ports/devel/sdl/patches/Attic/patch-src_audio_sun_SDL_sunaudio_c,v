head	1.5;
access;
symbols
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3;
locks; strict;
comment	@# @;


1.5
date	2010.01.12.11.19.06;	author jakemsr;	state dead;
branches;
next	1.4;

1.4
date	2007.09.22.01.12.38;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.14.15.51.07;	author naddy;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.07.14.22.02;	author pvalchev;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.20.05.23.41;	author jakemsr;	state Exp;
branches;
next	;


desc
@@


1.5
log
@- quit building audio(4) support
- remove unused --disable-ltdl configure arg
@
text
@$OpenBSD: patch-src_audio_sun_SDL_sunaudio_c,v 1.4 2007/09/22 01:12:38 pvalchev Exp $
--- src/audio/sun/SDL_sunaudio.c.orig	Fri Jul 20 01:52:10 2007
+++ src/audio/sun/SDL_sunaudio.c	Sat Sep  8 22:23:18 2007
@@@@ -25,7 +25,7 @@@@
 
 #include <fcntl.h>
 #include <errno.h>
-#ifdef __NETBSD__
+#if defined(__NETBSD__) || defined(__OpenBSD__)
 #include <sys/ioctl.h>
 #include <sys/audioio.h>
 #endif
@@@@ -135,12 +135,19 @@@@ void CheckUnderflow(_THIS)
 void DSP_WaitAudio(_THIS)
 {
 #ifdef AUDIO_GETINFO
-#define SLEEP_FUDGE	10		/* 10 ms scheduling fudge factor */
+#define SLEEP_FUDGE	100		/* 100 ms scheduling fudge factor */
+	u_long left;
+
+#ifdef AUDIO_WSEEK
+	ioctl(audio_fd, AUDIO_WSEEK, &left);
+	left = left / (this->spec.channels * (this->spec.format & 0xff) / 8);
+#else
 	audio_info_t info;
-	Sint32 left;
 
+	/* OpenBSD and NetBSD return bytes, not samples in info.play.samples */
 	ioctl(audio_fd, AUDIO_GETINFO, &info);
 	left = (written - info.play.samples);
+#endif
 	if ( left > fragsize ) {
 		Sint32 sleepy;
 
@@@@ -214,9 +221,22 @@@@ void DSP_PlayAudio(_THIS)
 #ifdef DEBUG_AUDIO
 		CheckUnderflow(this);
 #endif
-		if ( write(audio_fd, mixbuf, this->spec.size) < 0 ) {
+		while ( write(audio_fd, mixbuf, this->spec.size) < 0 ) {
+#ifdef DEBUG_AUDIO
+			fprintf(stderr, "audio write error: %s\n", strerror(errno));
+#endif
+#ifndef AUDIO_GETINFO
 			/* Assume fatal error, for now */
 			this->enabled = 0;
+			break;
+#else
+			/* no guarantee against EAGAIN doing our own timing */
+			if (!((errno == EAGAIN) && (OPEN_FLAGS & O_NONBLOCK))) {
+				/* Assume fatal error, for now */
+				this->enabled = 0;
+				break;
+			}
+#endif
 		}
 		written += fragsize;
 	}
@@@@ -244,7 +264,10 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
 {
 	char audiodev[1024];
 #ifdef AUDIO_SETINFO
+	audio_info_t info, ginfo;
+	audio_encoding_t audio_enc;
 	int enc;
+	int encodings, i;
 #endif
 	int desired_freq = spec->freq;
 
@@@@ -259,16 +282,34 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
 		case 8: { /* Unsigned 8 bit audio data */
 			spec->format = AUDIO_U8;
 #ifdef AUDIO_SETINFO
+#ifdef __OpenBSD__
+#if BYTE_ORDER == LITTLE_ENDIAN
+			enc = AUDIO_ENCODING_ULINEAR_LE;
+#else
+			enc = AUDIO_ENCODING_ULINEAR_BE;
+#endif
+#else
 			enc = AUDIO_ENCODING_LINEAR8;
 #endif
+#endif
 		}
 		break;
 
 		case 16: { /* Signed 16 bit audio data */
-		        spec->format = AUDIO_S16SYS;
 #ifdef AUDIO_SETINFO
+#ifdef __OpenBSD__
+			if (spec->format & 0x1000) {
+			        spec->format = AUDIO_S16MSB;
+				enc = AUDIO_ENCODING_SLINEAR_BE;
+			} else {
+			        spec->format = AUDIO_S16LSB;
+				enc = AUDIO_ENCODING_SLINEAR_LE;
+			}
+#else
+		        spec->format = AUDIO_S16SYS;
 			enc = AUDIO_ENCODING_LINEAR;
 #endif
+#endif
 		}
 		break;
 
@@@@ -287,10 +328,128 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
 		return(-1);
 	}
 
+	/* find native encodings */
+	/* all drivers support one of ulinear:8, slinear_le:16, slinear_be:16 */
+	/* except audioce on sparc, which is ulaw only */
+	/* and SDL doesn't do ulaw */
+
+	encodings = 0;
+	for (i = 0; ; i++) {
+		audio_enc.index = i;
+		if (ioctl(audio_fd, AUDIO_GETENC, &audio_enc) < 0)
+			break;
+
+		if ((audio_enc.encoding == AUDIO_ENCODING_SLINEAR_LE) &&
+		    (audio_enc.precision == 16) &&
+		    !(audio_enc.flags & AUDIO_ENCODINGFLAG_EMULATED))
+			encodings |= 0x1;
+
+		if ((audio_enc.encoding == AUDIO_ENCODING_SLINEAR_BE) &&
+		    (audio_enc.precision == 16) &&
+		    !(audio_enc.flags & AUDIO_ENCODINGFLAG_EMULATED))
+			encodings |= 0x2;
+
+		if ((audio_enc.encoding == AUDIO_ENCODING_ULINEAR) &&
+		    (audio_enc.precision == 8) &&
+		    !(audio_enc.flags & AUDIO_ENCODINGFLAG_EMULATED))
+			encodings |= 0x4;
+
+		/* there's really no endianness with 1 byte formats */
+		/* and some drivers don't add the generic form above */
+
+		if ((audio_enc.encoding == AUDIO_ENCODING_ULINEAR_LE) &&
+		    (audio_enc.precision == 8) &&
+		    !(audio_enc.flags & AUDIO_ENCODINGFLAG_EMULATED))
+			encodings |= 0x4;
+
+		if ((audio_enc.encoding == AUDIO_ENCODING_ULINEAR_BE) &&
+		    (audio_enc.precision == 8) &&
+		    !(audio_enc.flags & AUDIO_ENCODINGFLAG_EMULATED))
+			encodings |= 0x4;
+	}
+
+	if (encodings == 0) {
+		SDL_SetError("No native audio encodings found for %s",
+		    audiodev);
+		return(-1);
+	}
+	if (encodings & 0x1) {
+		if (enc == AUDIO_ENCODING_SLINEAR_BE && !(encodings & 0x2)) {
+			enc = AUDIO_ENCODING_SLINEAR_LE;
+		        spec->format = AUDIO_S16LSB;
+		}
+		if (enc == AUDIO_ENCODING_ULINEAR_LE && !(encodings & 0x4)) {
+			enc = AUDIO_ENCODING_SLINEAR_LE;
+		        spec->format = AUDIO_S16LSB;
+		}
+	}
+	if (encodings & 0x2) {
+		if (enc == AUDIO_ENCODING_SLINEAR_LE && !(encodings & 0x1)) {
+			enc = AUDIO_ENCODING_SLINEAR_BE;
+		        spec->format = AUDIO_S16MSB;
+		}
+		if (enc == AUDIO_ENCODING_ULINEAR_BE && !(encodings & 0x4)) {
+			enc = AUDIO_ENCODING_SLINEAR_BE;
+		        spec->format = AUDIO_S16MSB;
+		}
+	}
+	if (encodings & 0x4) {
+		if (enc == AUDIO_ENCODING_SLINEAR_LE && !(encodings & 0x1)) {
+			enc = AUDIO_ENCODING_ULINEAR_LE;
+		        spec->format = AUDIO_U8;
+		}
+		if (enc == AUDIO_ENCODING_SLINEAR_BE && !(encodings & 0x2)) {
+			enc = AUDIO_ENCODING_ULINEAR_BE;
+		        spec->format = AUDIO_U8;
+		}
+	}
+
+	AUDIO_INITINFO(&info);
+	info.play.precision = spec->format & 0xff;
+	info.play.encoding = enc;
+	/* this should always pass, based on AUDIO_GETENC work above */
+	if (ioctl(audio_fd, AUDIO_SETINFO, &info) == -1 ) {
+		SDL_SetError("Setting encoding %d failed", enc);
+		return(-1);
+	}
+	if (ioctl(audio_fd, AUDIO_GETINFO, &ginfo) != -1 ) {
+		if (ginfo.play.encoding != enc) {
+			SDL_SetError("error setting encoding, "
+			    "tried %d, returned %d",
+			    enc, ginfo.play.encoding);
+			return(-1);
+		}
+		if (ginfo.play.precision != (spec->format & 0xff)) {
+			SDL_SetError("error setting precision, "
+			    "tried %d, returned %d",
+			    spec->format & 0xff, ginfo.play.precision);
+			return(-1);
+		}
+	}
+
+	/* now check the number of channels */
+	info.play.channels = spec->channels;
+	if (ioctl(audio_fd, AUDIO_SETINFO, &info) == -1 ) {
+		if (spec->channels == 2)
+			spec->channels = 1;
+		else
+			spec->channels = 2;
+
+		info.play.channels = spec->channels;
+		(void)ioctl(audio_fd, AUDIO_SETINFO, &info);
+	}
+	if (ioctl(audio_fd, AUDIO_GETINFO, &ginfo) != -1 ) {
+		if (ginfo.play.channels != spec->channels) {
+			SDL_SetError("error setting channels, "
+				"tried %d, returned %d",
+				spec->channels, ginfo.play.channels);
+			return(-1);
+		}
+	}
+
 	ulaw_only = 0;		/* modern Suns do support linear audio */
 #ifdef AUDIO_SETINFO
 	for(;;) {
-	    audio_info_t info;
 	    AUDIO_INITINFO(&info); /* init all fields to "no change" */
 
 	    /* Try to set the requested settings */
@@@@ -299,8 +458,25 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
 	    info.play.precision = (enc == AUDIO_ENCODING_ULAW)
 		                  ? 8 : spec->format & 0xff;
 	    info.play.encoding = enc;
-	    if( ioctl(audio_fd, AUDIO_SETINFO, &info) == 0 ) {
 
+	    if (ioctl(audio_fd, AUDIO_SETINFO, &info) == -1 ) {
+
+		 /* some devices only play at certain frequencies */
+		 /* try the current frequency */
+		 (void)ioctl(audio_fd, AUDIO_GETINFO, &ginfo);
+	         info.play.sample_rate = ginfo.play.sample_rate;
+		 if (ioctl(audio_fd, AUDIO_SETINFO, &info) == -1 ) {
+
+		 	/* some may play only @@ 48000 Hz */
+		 	info.play.sample_rate = 48000;
+		        if( ioctl(audio_fd, AUDIO_SETINFO, &info) == -1 ) {
+
+		            /* some may play only @@ 44100 Hz */
+	                    info.play.sample_rate = 44100;
+			}
+		 }
+	    }
+	    if( ioctl(audio_fd, AUDIO_SETINFO, &info) == 0 ) {
 		/* Check to be sure we got what we wanted */
 		if(ioctl(audio_fd, AUDIO_GETINFO, &info) < 0) {
 		    SDL_SetError("Error getting audio parameters: %s",
@@@@ -317,13 +493,34 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
 	    }
 
 	    switch(enc) {
+#ifdef __OpenBSD__
+	    case AUDIO_ENCODING_ULINEAR:
+	    case AUDIO_ENCODING_ULINEAR_LE:
+	    case AUDIO_ENCODING_ULINEAR_BE:
+#else
 	    case AUDIO_ENCODING_LINEAR8:
+#endif
 		/* unsigned 8bit apparently not supported here */
-		enc = AUDIO_ENCODING_LINEAR;
 		spec->format = AUDIO_S16SYS;
+#ifdef AUDIO_SETINFO
+#ifdef __OpenBSD__
+#if BYTE_ORDER == LITTLE_ENDIAN
+		enc = AUDIO_ENCODING_SLINEAR_LE;
+#else
+		enc = AUDIO_ENCODING_SLINEAR_BE;
+#endif
+#else
+		enc = AUDIO_ENCODING_LINEAR;
+#endif
+#endif
 		break;	/* try again */
 
+#ifdef __OpenBSD__
+	    case AUDIO_ENCODING_SLINEAR_LE:
+	    case AUDIO_ENCODING_SLINEAR_BE:
+#else
 	    case AUDIO_ENCODING_LINEAR:
+#endif
 		/* linear 16bit didn't work either, resort to µ-law */
 		enc = AUDIO_ENCODING_ULAW;
 		spec->channels = 1;
@@@@ -342,6 +539,9 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
 #endif /* AUDIO_SETINFO */
 	written = 0;
 
+	/* reset counters */
+	ioctl(audio_fd, AUDIO_FLUSH, NULL);
+
 	/* We can actually convert on-the-fly to U-Law */
 	if ( ulaw_only ) {
 	        spec->freq = desired_freq;
@@@@ -354,8 +554,14 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
 		}
 		spec->channels = 1;
 	} else {
-		fragsize = spec->samples;
-		frequency = spec->freq/1000;
+		if (ioctl(audio_fd, AUDIO_GETINFO, &ginfo) != -1) {
+			int sampsize = ginfo.play.precision / 8 * ginfo.play.channels;
+			fragsize = spec->samples = ginfo.blocksize / sampsize;
+			frequency = ginfo.play.sample_rate / 1000;
+		} else {
+			fragsize = spec->samples;
+			frequency = spec->freq/1000;
+		}
 	}
 #ifdef DEBUG_AUDIO
 	fprintf(stderr, "Audio device %s U-Law only\n", 
@


1.4
log
@update to sdl-1.2.12. long due update, possible now since the macppc
X acceleration bug is now gone (thanks for ajacoutot for endless testing
of this issue), diff from brad
@
text
@d1 1
a1 1
$OpenBSD: patch-src_audio_sun_SDL_sunaudio_c,v 1.3 2007/08/14 15:51:07 naddy Exp $
@


1.3
log
@various audio fixes; from jakemsr@@
@
text
@d1 5
a5 4
$OpenBSD: patch-src_audio_sun_SDL_sunaudio_c,v 1.2 2007/08/07 14:22:02 pvalchev Exp $
--- src/audio/sun/SDL_sunaudio.c.orig	Sun Jan  4 08:49:15 2004
+++ src/audio/sun/SDL_sunaudio.c	Sun Aug 12 02:43:22 2007
@@@@ -32,7 +32,7 @@@@ static char rcsid =
d8 2
a9 3
 #include <string.h>
-#ifdef __NetBSD__
+#if defined(__NetBSD__) || defined(__OpenBSD__)
d13 1
a13 1
@@@@ -141,12 +141,19 @@@@ void CheckUnderflow(_THIS)
d35 1
a35 1
@@@@ -221,9 +228,22 @@@@ void DSP_PlayAudio(_THIS)
d59 1
a59 1
@@@@ -251,7 +271,10 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d70 1
a70 1
@@@@ -266,16 +289,34 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d106 1
a106 1
@@@@ -294,10 +335,128 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d236 1
a236 1
@@@@ -306,8 +465,25 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d263 1
a263 1
@@@@ -324,13 +500,34 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d299 1
a299 1
@@@@ -349,6 +546,9 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d309 1
a309 1
@@@@ -361,8 +561,14 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
@


1.2
log
@if requested sound settings fail, try 48000 Hz, as some audio devices
can only support that sample rate. reported by deanna, fixed by jakemsr
who asked me to commit it
@
text
@d1 1
a1 1
$OpenBSD: patch-src_audio_sun_SDL_sunaudio_c,v 1.1 2007/07/20 05:23:41 jakemsr Exp $
d3 1
a3 1
+++ src/audio/sun/SDL_sunaudio.c	Mon Aug  6 17:12:50 2007
d13 1
a13 1
@@@@ -141,12 +141,18 @@@@ void CheckUnderflow(_THIS)
d19 2
a20 3
 	audio_info_t info;
 	Sint32 left;
 
d25 3
d35 1
a35 1
@@@@ -221,9 +227,22 @@@@ void DSP_PlayAudio(_THIS)
d59 12
a70 1
@@@@ -266,16 +285,28 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d75 5
a79 1
+			enc = AUDIO_ENCODING_ULINEAR;
d88 1
a88 1
 		        spec->format = AUDIO_S16SYS;
d91 7
a97 5
+#if BYTE_ORDER == LITTLE_ENDIAN
+			enc = AUDIO_ENCODING_SLINEAR_LE;
+#else
+			enc = AUDIO_ENCODING_SLINEAR_BE;
+#endif
d99 1
d106 131
a236 1
@@@@ -306,6 +337,10 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d240 18
a257 3
+	    if( ioctl(audio_fd, AUDIO_SETINFO, &info) == -1 ) {
+		 /* some devices only play at 48000 Hz */
+	         info.play.sample_rate = 48000;
d259 1
a259 2
 	    if( ioctl(audio_fd, AUDIO_SETINFO, &info) == 0 ) {
 
d261 3
a263 1
@@@@ -324,13 +359,22 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d269 2
d275 1
a275 1
 		enc = AUDIO_ENCODING_LINEAR;
d277 11
d299 1
a299 2
@@@@ -348,6 +392,9 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
 	}
d302 1
a302 1
+
d305 1
a305 1
 
d308 18
@


1.1
log
@- use the sun audio interface instead of the OpenBSD interface
- sync patches with update-patches
- bump PKGNAME

the sun interface keeps fewer samples in the play buffer, and with
less fluctuation than the OpenBSD interface.  results in better
audio-video synchronization in e.g. ffplay and gnash

go for it -pval
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ src/audio/sun/SDL_sunaudio.c	Sat Jul 14 15:54:19 2007
d86 12
a97 1
@@@@ -324,13 +355,22 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
d120 1
a120 1
@@@@ -348,6 +388,9 @@@@ int DSP_OpenAudio(_THIS, SDL_AudioSpec *spec)
@

