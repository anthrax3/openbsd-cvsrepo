head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.20
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.18
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.16
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.14
	OPENBSD_5_0:1.5.0.12
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.10
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.6
date	2013.12.15.01.57.55;	author brad;	state dead;
branches;
next	1.5;

1.5
date	2009.01.24.10.56.11;	author jakemsr;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.08.20.10.46;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.23.07.45.32;	author jakemsr;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.13.22.09.59;	author jakemsr;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.53.51;	author jakemsr;	state Exp;
branches;
next	;


desc
@@


1.6
log
@- Rename the sndio backend files to match what was submitted upstream
  and sync in the autoconf bits.
- Sync WANTLIB.
- Merge in PFRAG.shared.

ok bcallah@@
@
text
@/*
 * Copyright (c) 2008 Jacob Meuser <jakemsr@@sdf.lonestar.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#include "SDL_config.h"

/* Allow access to a raw mixing buffer */

#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif
#include <unistd.h>

#include "SDL_timer.h"
#include "SDL_audio.h"
#include "../SDL_audiomem.h"
#include "../SDL_audio_c.h"
#include "../SDL_audiodev_c.h"
#include "SDL_libsndioaudio.h"

/* The tag name used by libsndio audio */
#define SNDIO_DRIVER_NAME         "sndio"

/* Audio driver functions */
static int SNDIO_OpenAudio(_THIS, SDL_AudioSpec *spec);
static void SNDIO_WaitAudio(_THIS);
static void SNDIO_PlayAudio(_THIS);
static Uint8 *SNDIO_GetAudioBuf(_THIS);
static void SNDIO_CloseAudio(_THIS);

/* Audio driver bootstrap functions */

static int Audio_Available(void)
{
	struct sio_hdl *this_hdl;
	int available = 0;

	if ( (this_hdl = sio_open(NULL, SIO_PLAY, 0)) != NULL ) {
		sio_close(this_hdl);
		available = 1;
	}

	return available;
}

static void Audio_DeleteDevice(SDL_AudioDevice *device)
{
	SDL_free(device->hidden);
	SDL_free(device);
}

static SDL_AudioDevice *Audio_CreateDevice(int devindex)
{
	SDL_AudioDevice *this;

	/* Initialize all variables that we clean on shutdown */
	this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
	if ( this ) {
		SDL_memset(this, 0, (sizeof *this));
		this->hidden = (struct SDL_PrivateAudioData *)
				SDL_malloc((sizeof *this->hidden));
	}
	if ( (this == NULL) || (this->hidden == NULL) ) {
		SDL_OutOfMemory();
		if ( this ) {
			SDL_free(this);
		}
		return(0);
	}
	SDL_memset(this->hidden, 0, (sizeof *this->hidden));

	/* Set the function pointers */
	this->OpenAudio = SNDIO_OpenAudio;
	this->WaitAudio = SNDIO_WaitAudio;
	this->PlayAudio = SNDIO_PlayAudio;
	this->GetAudioBuf = SNDIO_GetAudioBuf;
	this->CloseAudio = SNDIO_CloseAudio;

	this->free = Audio_DeleteDevice;

	hdl = NULL;

	return this;
}

AudioBootStrap SNDIO_bootstrap = {
	SNDIO_DRIVER_NAME, "sndio",
	Audio_Available, Audio_CreateDevice
};



/* This function waits until it is possible to write a full sound buffer */
static void SNDIO_WaitAudio(_THIS)
{
	/* Check to see if the thread-parent process is still alive */
	{ static int cnt = 0;
		/* Note that this only works with thread implementations 
		   that use a different process id for each thread.
		*/
		if (parent && (((++cnt)%10) == 0)) { /* Check every 10 loops */
			if ( kill(parent, 0) < 0 ) {
				this->enabled = 0;
			}
		}
	}
}

static void SNDIO_PlayAudio(_THIS)
{
	int written;

	/* Write the audio data */
	written = sio_write(hdl, mixbuf, mixlen);
	
	/* If we couldn't write, assume fatal error for now */
	if ( written == 0 ) {
		this->enabled = 0;
	}
#ifdef DEBUG_AUDIO
	fprintf(stderr, "Wrote %d bytes of audio data\n", written);
#endif
}

static Uint8 *SNDIO_GetAudioBuf(_THIS)
{
	return(mixbuf);
}

static void SNDIO_CloseAudio(_THIS)
{
	if ( mixbuf != NULL ) {
		SDL_FreeAudioMem(mixbuf);
		mixbuf = NULL;
	}
	if ( hdl != NULL ) {
		sio_close(hdl);
		hdl = NULL;
	}
}

static int SNDIO_OpenAudio(_THIS, SDL_AudioSpec *spec)
{
	struct sio_par par, reqpar;
	int newrate;

	mixbuf = NULL;

	if ((hdl = sio_open(NULL, SIO_PLAY, 0)) == NULL) {
		SDL_SetError("sio_open() failed");
		return(-1);
	}

	sio_initpar(&par);

	switch (spec->format) {
	case AUDIO_S16LSB:
		par.bits = 16;
		par.sig = 1;
		par.le = 1;
		break;
	case AUDIO_S16MSB:
		par.bits = 16;
		par.sig = 1;
		par.le = 0;
		break;
	case AUDIO_S8:
		par.bits = 8;
		par.sig = 1;
		break;
	case AUDIO_U16LSB:
		par.bits = 16;
		par.sig = 0;
		par.le = 1;
		break;
	case AUDIO_U16MSB:
		par.bits = 16;
		par.sig = 0;
		par.le = 0;
		break;
	case AUDIO_U8:
		par.bits = 8;
		par.sig = 0;
		break;
	default:
		SDL_SetError("SNDIO unknown format");
		return(-1);
	}

	par.rate = spec->freq;
	par.pchan = spec->channels;
	par.round = spec->samples;
	par.appbufsz = par.round * 2;

	reqpar = par;

	if (sio_setpar(hdl, &par) == 0) {
		SDL_SetError("sio_setpar() failed");
		return(-1);
	}

	if (sio_getpar(hdl, &par) == 0) {
		SDL_SetError("sio_getpar() failed");
		return(-1);
	}

	/* if wanted rate not found, find a multiple/factor */
	if (par.rate != spec->freq) {
		newrate = par.rate;
		if ((newrate > spec->freq && newrate % spec->freq != 0) ||
		     (newrate < spec->freq && spec->freq % newrate != 0)) {
			if ((spec->freq < 44100 && 44100 % spec->freq == 0) ||
			     (spec->freq > 44100 && spec->freq % 44100 == 0)) {
				newrate = 44100;
			}
		}
		/* only change sample rate */
		par = reqpar;
		par.rate = newrate;
		/* keep same latency */
		par.round = spec->samples * par.rate / reqpar.rate;
		par.appbufsz = par.round * 2;
		if (sio_setpar(hdl, &par) == 0) {
			SDL_SetError("sio_setpar() failed");
			return(-1);
		}
	}

	if (sio_getpar(hdl, &par) == 0) {
		SDL_SetError("sio_getpar() failed");
		return(-1);
	}

	if (par.bits == 16) {
		if (par.sig && par.le) {
			spec->format = AUDIO_S16LSB;
		} else if (par.sig && !par.le) {
			spec->format = AUDIO_S16MSB;
		} else if (!par.sig && par.le) {
			spec->format = AUDIO_U16LSB;
		} else 
			spec->format = AUDIO_U16MSB;
	} else if (par.bits == 8) {
		spec->format = par.sig ? AUDIO_S8 : AUDIO_U8;
	} else {
		SDL_SetError("SNDIO couldn't configure a suitable format");
		return(-1);
	}

	spec->freq = par.rate;
	spec->channels = par.pchan;
	spec->samples = par.round;

	SDL_CalculateAudioSpec(spec);

	/* Allocate mixing buffer */
	mixlen = spec->size;
	mixbuf = (Uint8 *)SDL_AllocAudioMem(mixlen);
	if ( mixbuf == NULL ) {
		return(-1);
	}
	SDL_memset(mixbuf, spec->silence, spec->size);

	/* Get the parent process id (we're the parent of the audio thread) */
	parent = getpid();

	if ( sio_start(hdl) == 0 ) {
		SDL_SetError("sio_start() failed");
		return(-1);
	}

	/* We're ready to rock and roll. :-) */
	return(0);
}
@


1.5
log
@cleanup sndio backend
- rename from "libsndio" to "sndio"
- remove support for "frame tick" synchronization; nothing uses it
- as with many other sndio backends, the audio device block size is the
  buffer-write-size the application wants and there are 2 blocks per
  device buffer
- if SDL will resample, increase the audio block and buffer size by
  the same ratio, so that device latency (or how much *time* the
  application has between write()s to not let the buffer underrun) does
  not change
- allow applications to disable conversions

tested with almost every port that uses this code (exceptions being some
games that require non-free game data) on a device most likely to be
affected by the changes (azalia(4) that only does 44.1 or 48 kHz s16)

unoverriding conversion disabling exposes brokenness in a few other
ports, those will be fixed soon
@
text
@@


1.4
log
@allow programs to use big endian and unsigned 16-bit encodings
discussed with, tested by and ok todd@@,
looks good to jakemsr@@
@
text
@d35 1
a35 1
#define LIBSNDIO_DRIVER_NAME         "libsndio"
d38 5
a42 5
static int LIBSNDIO_OpenAudio(_THIS, SDL_AudioSpec *spec);
static void LIBSNDIO_WaitAudio(_THIS);
static void LIBSNDIO_PlayAudio(_THIS);
static Uint8 *LIBSNDIO_GetAudioBuf(_THIS);
static void LIBSNDIO_CloseAudio(_THIS);
d86 5
a90 5
	this->OpenAudio = LIBSNDIO_OpenAudio;
	this->WaitAudio = LIBSNDIO_WaitAudio;
	this->PlayAudio = LIBSNDIO_PlayAudio;
	this->GetAudioBuf = LIBSNDIO_GetAudioBuf;
	this->CloseAudio = LIBSNDIO_CloseAudio;
d99 2
a100 2
AudioBootStrap LIBSNDIO_bootstrap = {
	LIBSNDIO_DRIVER_NAME, "libsndio",
d107 1
a107 1
static void LIBSNDIO_WaitAudio(_THIS)
a108 2
	Sint32 ticks;

a119 6

	/* Use timer for general audio synchronization */
	ticks = ((Sint32)(next_frame - SDL_GetTicks()))-FUDGE_TICKS;
	if ( ticks > 0 ) {
		SDL_Delay(ticks);
	}
d122 1
a122 1
static void LIBSNDIO_PlayAudio(_THIS)
a128 5
	/* If timer synchronization is enabled, set the next write frame */
	if ( frame_ticks ) {
		next_frame += frame_ticks;
	}

d138 1
a138 1
static Uint8 *LIBSNDIO_GetAudioBuf(_THIS)
d143 1
a143 1
static void LIBSNDIO_CloseAudio(_THIS)
d155 1
a155 1
static int LIBSNDIO_OpenAudio(_THIS, SDL_AudioSpec *spec)
d157 2
a158 5
	struct sio_par par;

	/* Reset the timer synchronization flag */
	frame_ticks = 0.0;
	next_frame = 0;
d199 1
a199 1
		SDL_SetError("LIBSNDIO unknown format");
d205 2
d208 1
a208 6
	/* Calculate the final parameters for this audio specification */
	SDL_CalculateAudioSpec(spec);

	/* bufsz is in frames, size is in bytes.  they both are counts
	   of the total buffer size (total latency desired) */
	par.appbufsz = spec->size / par.pchan / (par.bits / 8);
d222 3
a224 2
		if ((par.rate > spec->freq && par.rate % spec->freq != 0) ||
		     (par.rate < spec->freq && spec->freq % par.rate != 0)) {
d227 1
a227 6
				sio_initpar(&par);
				par.rate = 44100;
				if (sio_setpar(hdl, &par) == 0) {
					SDL_SetError("sio_setpar() failed");
					return(-1);
				}
d230 10
d259 1
a259 1
		SDL_SetError("LIBSNDIO couldn't configure a suitable format");
d265 1
d267 1
a267 6
	/* tell SDL we want to write in par.round sized blocks */
	/* this is problematic for some applications, don't do it now.
	   maybe in SDL-1.3.
	spec->size = par.bufsz * par.pchan * par.bps;
	frame_ticks = (float)par.bufsz / par.rate;
	*/
@


1.3
log
@bufsz -> appbufsz per recent libsndio changes
@
text
@d191 19
d260 12
a271 5
	if (par.bits == 16 && par.sig == 1 && par.le == 1)
		spec->format = AUDIO_S16LSB;
	else if (par.bits == 8 && par.sig == 0)
		spec->format = AUDIO_U8;
	else {
@


1.2
log
@
ISC license for these files, as they are not actually SDL files.
@
text
@d208 1
a208 1
	par.bufsz = spec->size / par.pchan / (par.bits / 8);
@


1.1
log
@add libsndio backend and use it by default.

take maintainership as suggested by current maintainer.

ok pvalchev@@
@
text
@d2 14
a15 2
    SDL - Simple DirectMedia Layer
    Copyright (C) 1997-2006 Sam Lantinga
a16 4
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
a17 12
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

    Sam Lantinga
    slouken@@libsdl.org
*/
@

