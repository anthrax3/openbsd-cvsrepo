head	1.3;
access;
symbols
	OPENBSD_4_1:1.2.0.12
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.1.1.1.0.4
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.2
	OPENBSD_3_4_BASE:1.1.1.1
	avsm_2003-Jul-23:1.1.1.1
	avsm:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2007.07.21.17.20.57;	author kili;	state dead;
branches;
next	1.2;

1.2
date	2004.04.23.03.00.07;	author dons;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.23.19.09.34;	author avsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.07.23.19.09.34;	author avsm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@
Update to 1.16 to make it build with ghc-6.6.1.
@
text
@$OpenBSD: patch-Makefile,v 1.2 2004/04/23 03:00:07 dons Exp $
Add a nice regress target 

--- Makefile.orig	Wed Jun 19 23:48:31 2002
+++ Makefile	Wed Jul 23 12:45:05 2003
@@@@ -368,3 +368,21 @@@@
 
 # -----------------------------------------------------------------------------
 
+TEST_RESULT=actual.result
+
+check::
+	@@( cd happy/tests/ ; ${MAKE} | tee ../../${TEST_RESULT}.raw )
+	@@( sed '1d;$$d' ${TEST_RESULT}.raw > ${TEST_RESULT} )
+	@@(if cmp -s expected.result ${TEST_RESULT} ; then \
+                echo ;\
+                echo "All is good!" ; \
+                echo ;\
+          else \
+                echo ;\
+                echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@";\
+                echo "Unexpected regress results!" ;\
+                echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@";\
+                echo ;\
+                echo "here is a diff:" ;\
+                diff -u expected.result ${TEST_RESULT} ;\
+          fi ; exit 0 )
@


1.2
log
@
Let happy build on amd64.
Update maintainer and add RCS tags.

ok pvalchev@@ avsm@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of happy-1.13, from Don Stewart <dons at cse.unsw.edu.au> 
with minor tweaks by me.

--
Happy - The LALR(1) Parser Generator for Haskell

Happy is a parser generator system for Haskell, similar to the
tool `yacc' for C. Like `yacc', it takes a file containing an
annotated BNF specification of a grammar and produces a Haskell
module containing a parser for the grammar.

Happy is flexible: you can have several Happy parsers in the same
program, and several entry points to a single grammar. Happy can
work in conjunction with a lexical analyser supplied by the user
(either hand-written or generated by another program), or it can
parse a stream of characters directly.

@
text
@@
