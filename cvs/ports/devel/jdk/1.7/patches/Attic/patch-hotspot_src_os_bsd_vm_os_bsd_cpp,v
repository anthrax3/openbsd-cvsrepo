head	1.13;
access;
symbols
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.6
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.2
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	kurt_20070508:1.1.1.1
	kurt:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2011.09.22.20.26.47;	author kurt;	state dead;
branches;
next	1.12;

1.12
date	2011.01.11.15.47.49;	author kurt;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.10.19.01.09;	author kurt;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.23.03.03.24;	author kurt;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.17.11.37.42;	author kurt;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.16.16.49.29;	author kurt;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.04.23.25.16;	author kurt;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.22.16.02.24;	author kurt;	state Exp;
branches;
next	1.5;

1.5
date	2008.03.19.18.05.43;	author kurt;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.06.15.46.18;	author kurt;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.13.22.52.35;	author kurt;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.09.15.48.31;	author kurt;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.08.17.06.19;	author kurt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.05.08.17.06.19;	author kurt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update devel/jdk/1.7 to b147 / non-beta
- Remove Early Access now that jdk 1.7 is final
- Use a patch set for all patches from upstream repository:
  http://hg.openjdk.java.net/bsd-port/bsd-port
- Set milestone and build number to fcs b00 to match Oracle.
- Update cacerts file.
- Install unlimited crypto policy.
- Add DIST_SUBDIR=jdk.
- Include patches from icedtea-web for applet hole from
  Landry Breuil <landry@@openbsd.org> via FreeBSD OpenJDK7 port
- Include fix for Oracle bug "7070134: Hotspot crashes with
  sigsegv from PorterStemmer":
  http://hg.openjdk.java.net/hsx/hotspot-comp/hotspot/rev/4e761e7e6e12
okay landry@@ jasper@@
@
text
@$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.12 2011/01/11 15:47:49 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Tue Jan  4 18:25:16 2011
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Tue Jan  4 18:34:25 2011
@@@@ -46,20 +46,42 @@@@
 # include <sys/utsname.h>
 # include <sys/socket.h>
 # include <sys/wait.h>
+# include <time.h>
 # include <pwd.h>
 # include <poll.h>
 # include <semaphore.h>
 # include <fcntl.h>
 # include <string.h>
+#ifdef _ALLBSD_SOURCE
+# include <sys/param.h>
+# include <sys/sysctl.h>
+#else
 # include <syscall.h>
 # include <sys/sysinfo.h>
 # include <gnu/libc-version.h>
+#endif
 # include <sys/ipc.h>
 # include <sys/shm.h>
-# include <link.h>
 # include <stdint.h>
 # include <inttypes.h>
 
+#ifndef __APPLE__
+# include <link.h>
+#endif
+
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+# include <elf.h>
+#endif
+
+#ifdef __APPLE__
+#include <mach/mach.h> // semaphore_* API
+#include <mach-o/dyld.h>
+#endif
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
 #define MAX_PATH    (2 * K)
 
 // for timer info max values which include all bits
@@@@ -70,19 +92,25 @@@@
 // global variables
 julong os::Bsd::_physical_memory = 0;
 
+#ifndef _ALLBSD_SOURCE
 address   os::Bsd::_initial_thread_stack_bottom = NULL;
 uintptr_t os::Bsd::_initial_thread_stack_size   = 0;
+#endif
 
 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
+#ifndef _ALLBSD_SOURCE
 int (*os::Bsd::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 Mutex* os::Bsd::_createThread_lock = NULL;
+#endif
 pthread_t os::Bsd::_main_thread;
 int os::Bsd::_page_size = -1;
+#ifndef _ALLBSD_SOURCE
 bool os::Bsd::_is_floating_stack = false;
 bool os::Bsd::_is_NPTL = false;
 bool os::Bsd::_supports_fast_thread_cpu_time = false;
 const char * os::Bsd::_glibc_version = NULL;
 const char * os::Bsd::_libpthread_version = NULL;
+#endif
 
 static jlong initial_time_count=0;
 
@@@@ -100,8 +128,6 @@@@ static pid_t _initial_pid = 0;
 static int SR_signum = SIGUSR2;
 sigset_t SR_sigset;
 
-/* Used to protect dlsym() calls */
-static pthread_mutex_t dl_mutex;
 
 ////////////////////////////////////////////////////////////////////////////////
 // utility functions
@@@@ -114,11 +140,16 @@@@ julong os::available_memory() {
 }
 
 julong os::Bsd::available_memory() {
+#ifdef _ALLBSD_SOURCE
+  // XXXBSD: this is just a stopgap implementation
+  return physical_memory() >> 2;
+#else
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
 
   return (julong)si.freeram * si.mem_unit;
+#endif
 }
 
 julong os::physical_memory() {
@@@@ -166,6 +197,7 @@@@ bool os::have_special_privileges() {
 }
 
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_gettid
 // i386: 224, ia64: 1105, amd64: 186, sparc 143
 #ifdef __ia64__
@@@@ -180,6 +212,7 @@@@ bool os::have_special_privileges() {
 #error define gettid for the arch
 #endif
 #endif
+#endif
 
 // Cpu architecture string
 #if   defined(ZERO)
@@@@ -205,6 +238,7 @@@@ static char cpu_arch[] = "sparc";
 #endif
 
 
+#ifndef _ALLBSD_SOURCE
 // pid_t gettid()
 //
 // Returns the kernel thread id of the currently running thread. Kernel
@@@@ -231,8 +265,49 @@@@ static bool unsafe_chroot_detected = false;
 static const char *unstable_chroot_error = "/proc file system not found.\n"
                      "Java may be unstable running multithreaded in a chroot "
                      "environment on Bsd when /proc filesystem is not mounted.";
+#endif
 
+#ifdef _ALLBSD_SOURCE
 void os::Bsd::initialize_system_info() {
+  int mib[2];
+  size_t len;
+  int cpu_val;
+  u_long mem_val;
+
+  /* get processors count via hw.ncpus sysctl */
+  mib[0] = CTL_HW;
+  mib[1] = HW_NCPU;
+  len = sizeof(cpu_val);
+  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1 && cpu_val >= 1) {
+       set_processor_count(cpu_val);
+  }
+  else {
+       set_processor_count(1);   // fallback
+  }
+
+  /* get physical memory via hw.usermem sysctl (hw.usermem is used
+   * instead of hw.physmem because we need size of allocatable memory
+   */
+  mib[0] = CTL_HW;
+  mib[1] = HW_USERMEM;
+  len = sizeof(mem_val);
+  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1)
+       _physical_memory = mem_val;
+  else
+       _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
+
+#ifdef __OpenBSD__
+  {
+       // limit _physical_memory memory view on OpenBSD since
+       // datasize rlimit restricts us anyway.
+       struct rlimit limits;
+       getrlimit(RLIMIT_DATA, &limits);
+       _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);
+  }
+#endif
+}
+#else
+void os::Bsd::initialize_system_info() {
   set_processor_count(sysconf(_SC_NPROCESSORS_CONF));
   if (processor_count() == 1) {
     pid_t pid = os::Bsd::gettid();
@@@@ -248,6 +323,7 @@@@ void os::Bsd::initialize_system_info() {
   _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);
   assert(processor_count() > 0, "bsd error");
 }
+#endif
 
 void os::init_system_properties_values() {
 //  char arch[12];
@@@@ -291,9 +367,7 @@@@ void os::init_system_properties_values() {
  *        ...
  *        7: The default directories, normally /lib and /usr/lib.
  */
-#if defined(AMD64) || defined(_LP64) && (defined(SPARC) || defined(PPC) || defined(S390))
-#define DEFAULT_LIBPATH "/usr/lib64:/lib64:/lib:/usr/lib"
-#else
+#ifndef DEFAULT_LIBPATH
 #define DEFAULT_LIBPATH "/lib:/usr/lib"
 #endif
 
@@@@ -372,7 +446,11 @@@@ void os::init_system_properties_values() {
          * should always exist (until the legacy problem cited above is
          * addressed).
          */
+#ifdef __APPLE__
+        char *v = getenv("DYLD_LIBRARY_PATH");
+#else
         char *v = getenv("LD_LIBRARY_PATH");
+#endif
         if (v != NULL) {
             char *t = ld_library_path;
             /* That's +1 for the colon and +1 for the trailing '\0' */
@@@@ -531,6 +609,7 @@@@ void os::Bsd::hotspot_sigmask(Thread* thread) {
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 //////////////////////////////////////////////////////////////////////////////
 // detecting pthread library
 
@@@@ -694,6 +773,7 @@@@ bool os::Bsd::manually_expand_stack(JavaThread * t, ad
   }
   return false;
 }
+#endif
 
 //////////////////////////////////////////////////////////////////////////////
 // create new thread
@@@@ -702,6 +782,9 @@@@ static address highest_vm_reserved_address();
 
 // check if it's safe to start a new thread
 static bool _thread_safety_check(Thread* thread) {
+#ifdef _ALLBSD_SOURCE
+    return true;
+#else
   if (os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack()) {
     // Fixed stack BsdThreads (SuSE Bsd/x86, and some versions of Redhat)
     //   Heap is mmap'ed at lower end of memory space. Thread stacks are
@@@@ -735,6 +818,7 @@@@ static bool _thread_safety_check(Thread* thread) {
     //   here, that means enough space has been reserved for stack.
     return true;
   }
+#endif
 }
 
 // Thread start routine for all newly created threads
@@@@ -762,6 +846,10 @@@@ static void *java_start(Thread *thread) {
     return NULL;
   }
 
+#ifdef _ALLBSD_SOURCE
+  // thread_id is pthread_id on BSD
+  osthread->set_thread_id(::pthread_self());
+#else
   // thread_id is kernel thread id (similar to Solaris LWP id)
   osthread->set_thread_id(os::Bsd::gettid());
 
@@@@ -771,6 +859,7 @@@@ static void *java_start(Thread *thread) {
       thread->set_lgrp_id(lgrp_id);
     }
   }
+#endif
   // initialize signal mask for this thread
   os::Bsd::hotspot_sigmask(thread);
 
@@@@ -853,17 +942,22 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
     // let pthread_create() pick the default value.
   }
 
+#ifndef _ALLBSD_SOURCE
   // glibc guard page
   pthread_attr_setguardsize(&attr, os::Bsd::default_guard_size(thr_type));
+#endif
 
   ThreadState state;
 
   {
+
+#ifndef _ALLBSD_SOURCE
     // Serialize thread creation if we are running with fixed stack BsdThreads
     bool lock = os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack();
     if (lock) {
       os::Bsd::createThread_lock()->lock_without_safepoint_check();
     }
+#endif
 
     pthread_t tid;
     int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);
@@@@ -877,7 +971,9 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
       // Need to clean up stuff we've allocated so far
       thread->set_osthread(NULL);
       delete osthread;
+#ifndef _ALLBSD_SOURCE
       if (lock) os::Bsd::createThread_lock()->unlock();
+#endif
       return false;
     }
 
@@@@ -893,9 +989,11 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
       }
     }
 
+#ifndef _ALLBSD_SOURCE
     if (lock) {
       os::Bsd::createThread_lock()->unlock();
     }
+#endif
   }
 
   // Aborted due to thread limit being reached
@@@@ -933,7 +1031,11 @@@@ bool os::create_attached_thread(JavaThread* thread) {
   }
 
   // Store pthread info into the OSThread
+#ifdef _ALLBSD_SOURCE
+  osthread->set_thread_id(::pthread_self());
+#else
   osthread->set_thread_id(os::Bsd::gettid());
+#endif
   osthread->set_pthread_id(::pthread_self());
 
   // initialize floating point control register
@@@@ -944,6 +1046,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
 
   thread->set_osthread(osthread);
 
+#ifndef _ALLBSD_SOURCE
   if (UseNUMA) {
     int lgrp_id = os::numa_get_group_id();
     if (lgrp_id != -1) {
@@@@ -970,6 +1073,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
     os::Bsd::manually_expand_stack(jt, addr);
     osthread->clear_expanding_stack();
   }
+#endif
 
   // initialize signal mask for this thread
   // and save the caller's signal mask
@@@@ -1028,6 +1132,7 @@@@ extern "C" Thread* get_thread() {
 //////////////////////////////////////////////////////////////////////////////
 // initial thread
 
+#ifndef _ALLBSD_SOURCE
 // Check if current thread is the initial thread, similar to Solaris thr_main.
 bool os::Bsd::is_initial_thread(void) {
   char dummy;
@@@@ -1264,6 +1369,7 @@@@ void os::Bsd::capture_initial_stack(size_t max_size) {
   _initial_thread_stack_size = align_size_down(_initial_thread_stack_size, page_size());
   _initial_thread_stack_bottom = (address)stack_top - _initial_thread_stack_size;
 }
+#endif
 
 ////////////////////////////////////////////////////////////////////////////////
 // time support
@@@@ -1285,9 +1391,7 @@@@ jlong os::elapsed_frequency() {
   return (1000 * 1000);
 }
 
-// For now, we say that bsd does not support vtime.  I have no idea
-// whether it can actually be made to (DLD, 9/13/05).
-
+// XXX: For now, code this as if BSD does not support vtime.
 bool os::supports_vtime() { return false; }
 bool os::enable_vtime()   { return false; }
 bool os::vtime_enabled()  { return false; }
@@@@ -1307,7 +1411,22 @@@@ jlong os::javaTimeMillis() {
 #define CLOCK_MONOTONIC (1)
 #endif
 
+#ifdef __APPLE__
 void os::Bsd::clock_init() {
+	// XXXDARWIN: Investigate replacement monotonic clock
+}
+#elif defined(_ALLBSD_SOURCE)
+void os::Bsd::clock_init() {
+  struct timespec res;
+  struct timespec tp;
+  if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&
+      ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {
+    // yes, monotonic clock is supported
+    _clock_gettime = ::clock_gettime;
+  }
+}
+#else
+void os::Bsd::clock_init() {
   // we do dlopen's in this particular order due to bug in bsd
   // dynamical loader (see 6348968) leading to crash on exit
   void* handle = dlopen("librt.so.1", RTLD_LAZY);
@@@@ -1342,7 +1461,9 @@@@ void os::Bsd::clock_init() {
     }
   }
 }
+#endif
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_clock_getres
 
 #if defined(IA32) || defined(AMD64)
@@@@ -1383,6 +1504,7 @@@@ void os::Bsd::fast_thread_clock_init() {
     _pthread_getcpuclockid = pthread_getcpuclockid_func;
   }
 }
+#endif
 
 jlong os::javaTimeNanos() {
   if (Bsd::supports_monotonic_clock()) {
@@@@ -1533,8 +1655,15 @@@@ int os::current_process_id() {
 
 // DLL functions
 
-const char* os::dll_file_extension() { return ".so"; }
+#define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#else
+#define JNI_LIB_SUFFIX ".so"
+#endif
 
+const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
+
 const char* os::get_temp_directory() {
   const char *prop = Arguments::get_property("java.io.tmpdir");
   return prop == NULL ? "/tmp" : prop;
@@@@ -1554,13 +1683,13 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
   const size_t pnamelen = pname ? strlen(pname) : 0;
 
   // Quietly truncate on buffer overflow.  Should be an error.
-  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {
+  if (pnamelen + strlen(fname) + strlen(JNI_LIB_PREFIX) + strlen(JNI_LIB_SUFFIX) + 2 > buflen) {
       *buffer = '\0';
       return;
   }
 
   if (pnamelen == 0) {
-    snprintf(buffer, buflen, "lib%s.so", fname);
+    snprintf(buffer, buflen, JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX, fname);
   } else if (strchr(pname, *os::path_separator()) != NULL) {
     int n;
     char** pelements = split_path(pname, &n);
@@@@ -1569,7 +1698,8 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
       if (pelements[i] == NULL || strlen(pelements[i]) == 0) {
         continue; // skip the empty path values
       }
-      snprintf(buffer, buflen, "%s/lib%s.so", pelements[i], fname);
+      snprintf(buffer, buflen, "%s/" JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX,
+          pelements[i], fname);
       if (file_exists(buffer)) {
         break;
       }
@@@@ -1584,7 +1714,7 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
       FREE_C_HEAP_ARRAY(char*, pelements);
     }
   } else {
-    snprintf(buffer, buflen, "%s/lib%s.so", pname, fname);
+    snprintf(buffer, buflen, "%s/" JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX, pname, fname);
   }
 }
 
@@@@ -1625,6 +1755,23 @@@@ bool os::dll_address_to_function_name(address addr, ch
   }
 }
 
+#ifdef _ALLBSD_SOURCE
+// ported from solaris version
+bool os::dll_address_to_library_name(address addr, char* buf,
+                                     int buflen, int* offset) {
+  Dl_info dlinfo;
+
+  if (dladdr((void*)addr, &dlinfo)){
+     if (buf) jio_snprintf(buf, buflen, "%s", dlinfo.dli_fname);
+     if (offset) *offset = addr - (address)dlinfo.dli_fbase;
+     return true;
+  } else {
+     if (buf) buf[0] = '\0';
+     if (offset) *offset = -1;
+     return false;
+  }
+}
+#else
 struct _address_to_library_name {
   address addr;          // input : memory address
   size_t  buflen;        //         size of fname
@@@@ -1699,11 +1846,27 @@@@ bool os::dll_address_to_library_name(address addr, cha
      return false;
   }
 }
+#endif
 
   // Loads .dll/.so and
   // in case of error it checks if .dll/.so was built for the
   // same architecture as Hotspot is running on
+ 
+#ifdef __APPLE__
+void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
+  void * result= ::dlopen(filename, RTLD_LAZY);
+  if (result != NULL) {
+    // Successful loading
+    return result;
+  }
 
+  // Read system error message into ebuf
+  ::strncpy(ebuf, ::dlerror(), ebuflen-1);
+  ebuf[ebuflen-1]='\0';
+
+  return NULL;
+}
+#else
 void * os::dll_load(const char *filename, char *ebuf, int ebuflen)
 {
   void * result= ::dlopen(filename, RTLD_LAZY);
@@@@ -1756,6 +1919,26 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
   #define EM_486          6               /* Intel 80486 */
   #endif
 
+  #ifndef EM_MIPS_RS3_LE
+  #define EM_MIPS_RS3_LE  10              /* MIPS */
+  #endif
+
+  #ifndef EM_PPC64
+  #define EM_PPC64        21              /* PowerPC64 */
+  #endif
+
+  #ifndef EM_S390
+  #define EM_S390         22              /* IBM System/390 */
+  #endif
+
+  #ifndef EM_IA_64
+  #define EM_IA_64        50              /* HP/Intel IA-64 */ 
+  #endif
+
+  #ifndef EM_X86_64
+  #define EM_X86_64       62              /* AMD x86-64 */ 
+  #endif
+
   static const arch_t arch_array[]={
     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
@@@@ -1859,17 +2042,11 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
 
   return NULL;
 }
+#endif /* !__APPLE__ */
 
-/*
- * glibc-2.0 libdl is not MT safe.  If you are building with any glibc,
- * chances are you might want to run the generated bits against glibc-2.0
- * libdl.so, so always use locking for any version of glibc.
- */
+// XXX: Do we need a lock around this as per Linux?
 void* os::dll_lookup(void* handle, const char* name) {
-  pthread_mutex_lock(&dl_mutex);
-  void* res = dlsym(handle, name);
-  pthread_mutex_unlock(&dl_mutex);
-  return res;
+  return dlsym(handle, name);
 }
 
 
@@@@ -1892,7 +2069,51 @@@@ bool _print_ascii_file(const char* filename, outputStr
 
 void os::print_dll_info(outputStream *st) {
    st->print_cr("Dynamic libraries:");
+#ifdef _ALLBSD_SOURCE
+#ifdef RTLD_DI_LINKMAP
+    Dl_info dli;
+    void *handle;
+    Link_map *map;
+    Link_map *p;
 
+    if (!dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli)) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    handle = dlopen(dli.dli_fname, RTLD_LAZY);
+    if (handle == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    dlinfo(handle, RTLD_DI_LINKMAP, &map);
+    if (map == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+
+    while (map->l_prev != NULL)
+        map = map->l_prev;
+
+    while (map != NULL) {
+        st->print_cr(PTR_FORMAT " \t%s", map->l_addr, map->l_name);
+        map = map->l_next;
+    }
+
+    dlclose(handle);
+#elif defined(__APPLE__)
+    uint32_t count;
+    uint32_t i;
+
+    count = _dyld_image_count();
+    for (i = 1; i < count; i++) {
+        const char *name = _dyld_get_image_name(i);
+        intptr_t slide = _dyld_get_image_vmaddr_slide(i);
+        st->print_cr(PTR_FORMAT " \t%s", slide, name);
+    }
+#else
+   st->print_cr("Error: Cannot print dynamic libraries.");
+#endif
+#else
    char fname[32];
    pid_t pid = os::Bsd::gettid();
 
@@@@ -1901,6 +2122,7 @@@@ void os::print_dll_info(outputStream *st) {
    if (!_print_ascii_file(fname, st)) {
      st->print("Can not get library information for pid = %d\n", pid);
    }
+#endif
 }
 
 
@@@@ -1935,6 +2157,7 @@@@ void os::print_os_info(outputStream* st) {
   st->print(name.machine);
   st->cr();
 
+#ifndef _ALLBSD_SOURCE
   // Print warning if unsafe chroot environment detected
   if (unsafe_chroot_detected) {
     st->print("WARNING!! ");
@@@@ -1949,6 +2172,7 @@@@ void os::print_os_info(outputStream* st) {
      st->print("(%s stack)", os::Bsd::is_floating_stack() ? "floating" : "fixed");
   }
   st->cr();
+#endif
 
   // rlimit
   st->print("rlimit:");
@@@@ -1974,6 +2198,7 @@@@ void os::print_os_info(outputStream* st) {
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%d", rlim.rlim_cur);
 
+#ifndef _ALLBSD_SOURCE
   st->print(", AS ");
   getrlimit(RLIMIT_AS, &rlim);
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
@@@@ -1986,11 +2211,7 @@@@ void os::print_os_info(outputStream* st) {
   os::loadavg(loadavg, 3);
   st->print("%0.02f %0.02f %0.02f", loadavg[0], loadavg[1], loadavg[2]);
   st->cr();
-
-  // meminfo
-  st->print("\n/proc/meminfo:\n");
-  _print_ascii_file("/proc/meminfo", st);
-  st->cr();
+#endif
 }
 
 void os::print_memory_info(outputStream* st) {
@@@@ -1998,19 +2219,28 @@@@ void os::print_memory_info(outputStream* st) {
   st->print("Memory:");
   st->print(" %dk page", os::vm_page_size()>>10);
 
+#ifndef _ALLBSD_SOURCE
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
+#endif
 
   st->print(", physical " UINT64_FORMAT "k",
             os::physical_memory() >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
+#ifndef _ALLBSD_SOURCE
   st->print(", swap " UINT64_FORMAT "k",
             ((jlong)si.totalswap * si.mem_unit) >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             ((jlong)si.freeswap * si.mem_unit) >> 10);
+#endif
   st->cr();
+
+  // meminfo
+  st->print("\n/proc/meminfo:\n");
+  _print_ascii_file("/proc/meminfo", st);
+  st->cr();
 }
 
 // Taken from /usr/include/bits/siginfo.h  Supposed to be architecture specific
@@@@ -2252,19 +2482,29 @@@@ int os::sigexitnum_pd() {
 static volatile jint pending_signals[NSIG+1] = { 0 };
 
 // Bsd(POSIX) specific hand shaking semaphore.
+#ifdef __APPLE__
+static semaphore_t sig_sem;
+#define SEM_INIT(sem, value)	semaphore_create(mach_task_self(), &sem, SYNC_POLICY_FIFO, value)
+#define SEM_WAIT(sem)		semaphore_wait(sem);
+#define SEM_POST(sem)		semaphore_signal(sem);
+#else
 static sem_t sig_sem;
+#define SEM_INIT(sem, value)	sem_init(&sem, 0, value)
+#define SEM_WAIT(sem)		sem_wait(&sem);
+#define SEM_POST(sem)		sem_post(&sem);
+#endif
 
 void os::signal_init_pd() {
   // Initialize signal structures
   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
 
   // Initialize signal semaphore
-  ::sem_init(&sig_sem, 0, 0);
+  ::SEM_INIT(sig_sem, 0);
 }
 
 void os::signal_notify(int sig) {
   Atomic::inc(&pending_signals[sig]);
-  ::sem_post(&sig_sem);
+  ::SEM_POST(sig_sem);
 }
 
 static int check_pending_signals(bool wait) {
@@@@ -2286,7 +2526,7 @@@@ static int check_pending_signals(bool wait) {
     do {
       thread->set_suspend_equivalent();
       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
-      ::sem_wait(&sig_sem);
+      ::SEM_WAIT(sig_sem);
 
       // were we externally suspended while we were waiting?
       threadIsSuspended = thread->handle_special_suspend_equivalent_condition();
@@@@ -2297,7 +2537,7 @@@@ static int check_pending_signals(bool wait) {
         // while suspended because that would surprise the thread that
         // suspended us.
         //
-        ::sem_post(&sig_sem);
+        ::SEM_POST(sig_sem);
 
         thread->java_suspend_self();
       }
@@@@ -2341,10 +2581,10 @@@@ void bsd_wrap_code(char* base, size_t size) {
     return;
   }
 
-  char buf[PATH_MAX+1];
+  char buf[PATH_MAX + 1];
   int num = Atomic::add(1, &cnt);
 
-  snprintf(buf, sizeof(buf), "%s/hs-vm-%d-%d",
+  snprintf(buf, PATH_MAX + 1, "%s/hs-vm-%d-%d",
            os::get_temp_directory(), os::current_process_id(), num);
   unlink(buf);
 
@@@@ -2370,9 +2610,14 @@@@ void bsd_wrap_code(char* base, size_t size) {
 //       problem.
 bool os::commit_memory(char* addr, size_t size, bool exec) {
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return ::mprotect(addr, size, prot) == 0;
+#else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
                                    MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   return res != (uintptr_t) MAP_FAILED;
+#endif
 }
 
 bool os::commit_memory(char* addr, size_t size, size_t alignment_hint,
@@@@ -2388,36 +2633,27 @@@@ void os::free_memory(char *addr, size_t bytes) {
 }
 
 void os::numa_make_global(char *addr, size_t bytes) {
-  Bsd::numa_interleave_memory(addr, bytes);
 }
 
 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {
-  Bsd::numa_tonode_memory(addr, bytes, lgrp_hint);
 }
 
 bool os::numa_topology_changed()   { return false; }
 
 size_t os::numa_get_groups_num() {
-  int max_node = Bsd::numa_max_node();
-  return max_node > 0 ? max_node + 1 : 1;
+  return 1;
 }
 
 int os::numa_get_group_id() {
-  int cpu_id = Bsd::sched_getcpu();
-  if (cpu_id != -1) {
-    int lgrp_id = Bsd::get_node_by_cpu(cpu_id);
-    if (lgrp_id != -1) {
-      return lgrp_id;
-    }
-  }
   return 0;
 }
 
 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
-  for (size_t i = 0; i < size; i++) {
-    ids[i] = i;
+  if (size > 0) {
+    ids[0] = 0;
+    return 1;
   }
-  return size;
+  return 0;
 }
 
 bool os::get_page_info(char *start, page_info* info) {
@@@@ -2428,6 +2664,7 @@@@ char *os::scan_pages(char *start, char* end, page_info
   return end;
 }
 
+#ifndef _ALLBSD_SOURCE
 extern "C" void numa_warn(int number, char *where, ...) { }
 extern "C" void numa_error(char *where) { }
 
@@@@ -2529,104 +2766,26 @@@@ os::Bsd::numa_available_func_t os::Bsd::_numa_availabl
 os::Bsd::numa_tonode_memory_func_t os::Bsd::_numa_tonode_memory;
 os::Bsd::numa_interleave_memory_func_t os::Bsd::_numa_interleave_memory;
 unsigned long* os::Bsd::_numa_all_nodes;
+#endif
 
 bool os::uncommit_memory(char* addr, size_t size) {
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return ::mprotect(addr, size, PROT_NONE) == 0;
+#else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                 MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
+#endif
 }
 
-// Bsd uses a growable mapping for the stack, and if the mapping for
-// the stack guard pages is not removed when we detach a thread the
-// stack cannot grow beyond the pages where the stack guard was
-// mapped.  If at some point later in the process the stack expands to
-// that point, the Bsd kernel cannot expand the stack any further
-// because the guard pages are in the way, and a segfault occurs.
-//
-// However, it's essential not to split the stack region by unmapping
-// a region (leaving a hole) that's already part of the stack mapping,
-// so if the stack mapping has already grown beyond the guard pages at
-// the time we create them, we have to truncate the stack mapping.
-// So, we need to know the extent of the stack mapping when
-// create_stack_guard_pages() is called.
-
-// Find the bounds of the stack mapping.  Return true for success.
-//
-// We only need this for stacks that are growable: at the time of
-// writing thread stacks don't use growable mappings (i.e. those
-// creeated with MAP_GROWSDOWN), and aren't marked "[stack]", so this
-// only applies to the main thread.
-static bool
-get_stack_bounds(uintptr_t *bottom, uintptr_t *top)
-{
-  FILE *f = fopen("/proc/self/maps", "r");
-  if (f == NULL)
-    return false;
-
-  while (!feof(f)) {
-    size_t dummy;
-    char *str = NULL;
-    ssize_t len = getline(&str, &dummy, f);
-    if (len == -1) {
-      fclose(f);
-      return false;
-    }
-
-    if (len > 0 && str[len-1] == '\n') {
-      str[len-1] = 0;
-      len--;
-    }
-
-    static const char *stack_str = "[stack]";
-    if (len > (ssize_t)strlen(stack_str)
-       && (strcmp(str + len - strlen(stack_str), stack_str) == 0)) {
-      if (sscanf(str, "%" SCNxPTR "-%" SCNxPTR, bottom, top) == 2) {
-        uintptr_t sp = (uintptr_t)__builtin_frame_address(0);
-        if (sp >= *bottom && sp <= *top) {
-          free(str);
-          fclose(f);
-          return true;
-        }
-      }
-    }
-    free(str);
-  }
-  fclose(f);
-  return false;
-}
-
-// If the (growable) stack mapping already extends beyond the point
-// where we're going to put our guard pages, truncate the mapping at
-// that point by munmap()ping it.  This ensures that when we later
-// munmap() the guard pages we don't leave a hole in the stack
-// mapping. This only affects the main/initial thread, but guard
-// against future OS changes
 bool os::create_stack_guard_pages(char* addr, size_t size) {
-  uintptr_t stack_extent, stack_base;
-  bool chk_bounds = NOT_DEBUG(os::Bsd::is_initial_thread()) DEBUG_ONLY(true);
-  if (chk_bounds && get_stack_bounds(&stack_extent, &stack_base)) {
-      assert(os::Bsd::is_initial_thread(),
-           "growable stack in non-initial thread");
-    if (stack_extent < (uintptr_t)addr)
-      ::munmap((void*)stack_extent, (uintptr_t)addr - stack_extent);
-  }
-
   return os::commit_memory(addr, size);
 }
 
 // If this is a growable mapping, remove the guard pages entirely by
-// munmap()ping them.  If not, just call uncommit_memory(). This only
-// affects the main/initial thread, but guard against future OS changes
+// munmap()ping them.  If not, just call uncommit_memory().
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  uintptr_t stack_extent, stack_base;
-  bool chk_bounds = NOT_DEBUG(os::Bsd::is_initial_thread()) DEBUG_ONLY(true);
-  if (chk_bounds && get_stack_bounds(&stack_extent, &stack_base)) {
-      assert(os::Bsd::is_initial_thread(),
-           "growable stack in non-initial thread");
-
-    return ::munmap(addr, size) == 0;
-  }
-
   return os::uncommit_memory(addr, size);
 }
 
@@@@ -2731,6 +2890,9 @@@@ bool os::unguard_memory(char* addr, size_t size) {
 static size_t _large_page_size = 0;
 
 bool os::large_page_init() {
+#ifdef _ALLBSD_SOURCE
+  return false;
+#else
   if (!UseLargePages) return false;
 
   if (LargePageSizeInBytes) {
@@@@ -2788,6 +2950,7 @@@@ bool os::large_page_init() {
   // We optimistically assume the support is available. If later it turns out
   // not true, VM will automatically switch to use regular page size.
   return true;
+#endif
 }
 
 #ifndef SHM_HUGETLB
@@@@ -2964,7 +3127,7 @@@@ char* os::attempt_reserve_memory_at(size_t bytes, char
 }
 
 size_t os::read(int fd, void *buf, unsigned int nBytes) {
-  return ::read(fd, buf, nBytes);
+  RESTARTABLE_RETURN_INT(::read(fd, buf, nBytes));
 }
 
 // TODO-FIXME: reconcile Solaris' os::sleep with the bsd variation.
@@@@ -3100,9 +3263,47 @@@@ void os::loop_breaker(int attempts) {
 // this reason, the code should not be used as default (ThreadPriorityPolicy=0).
 // It is only used when ThreadPriorityPolicy=1 and requires root privilege.
 
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__)
 int os::java_to_os_priority[MaxPriority + 1] = {
   19,              // 0 Entry should never be used
 
+   0,              // 1 MinPriority
+   3,              // 2
+   6,              // 3
+
+   10,              // 4
+   15,              // 5 NormPriority
+   18,              // 6
+
+   21,              // 7
+   25,              // 8
+   28,              // 9 NearMaxPriority
+
+   31              // 10 MaxPriority
+};
+#elif defined(__APPLE__)
+/* Using Mach high-level priority assignments */
+int os::java_to_os_priority[MaxPriority + 1] = {
+   0,              // 0 Entry should never be used (MINPRI_USER)
+
+  27,              // 1 MinPriority
+  28,              // 2
+  29,              // 3
+
+  30,              // 4
+  31,              // 5 NormPriority (BASEPRI_DEFAULT)
+  32,              // 6
+
+  33,              // 7
+  34,              // 8
+  35,              // 9 NearMaxPriority
+
+  36               // 10 MaxPriority
+};
+#else
+int os::java_to_os_priority[MaxPriority + 1] = {
+  19,              // 0 Entry should never be used
+
    4,              // 1 MinPriority
    3,              // 2
    2,              // 3
@@@@ -3117,6 +3318,7 @@@@ int os::java_to_os_priority[MaxPriority + 1] = {
 
   -5               // 10 MaxPriority
 };
+#endif
 
 static int prio_init() {
   if (ThreadPriorityPolicy == 1) {
@@@@ -3136,8 +3338,28 @@@@ static int prio_init() {
 OSReturn os::set_native_priority(Thread* thread, int newpri) {
   if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;
 
+#ifdef __OpenBSD__
+  // OpenBSD pthread_setprio starves low priority threads
+  return OS_OK;
+#elif defined(__FreeBSD__)
+  int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);
+#elif defined(__APPLE__) || defined(__NetBSD__)
+  struct sched_param sp;
+  int policy;
+  pthread_t self = pthread_self();
+
+  if (pthread_getschedparam(self, &policy, &sp) != 0)
+    return OS_ERR;
+
+  sp.sched_priority = newpri;
+  if (pthread_setschedparam(self, policy, &sp) != 0)
+    return OS_ERR;
+
+  return OS_OK;
+#else
   int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);
   return (ret == 0) ? OS_OK : OS_ERR;
+#endif
 }
 
 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
@@@@ -3147,7 +3369,17 @@@@ OSReturn os::get_native_priority(const Thread* const t
   }
 
   errno = 0;
+#if defined(__OpenBSD__) || defined(__FreeBSD__)
+  *priority_ptr = pthread_getprio(thread->osthread()->pthread_id());
+#elif defined(__APPLE__) || defined(__NetBSD__)
+  int policy;
+  struct sched_param sp;
+
+  pthread_getschedparam(pthread_self(), &policy, &sp);
+  *priority_ptr = sp.sched_priority;
+#else
   *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());
+#endif
   return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);
 }
 
@@@@ -3257,7 +3489,7 @@@@ static int SR_initialize() {
   /* Get signal number to use for suspend/resume */
   if ((s = ::getenv("_JAVA_SR_SIGNUM")) != 0) {
     int sig = ::strtol(s, 0, 10);
-    if (sig > 0 || sig < _NSIG) {
+    if (sig > 0 || sig < NSIG) {
         SR_signum = sig;
     }
   }
@@@@ -3601,6 +3833,28 @@@@ void os::Bsd::install_signal_handlers() {
     set_signal_handler(SIGFPE, true);
     set_signal_handler(SIGXFSZ, true);
 
+#if defined(__APPLE__)
+    // In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including
+    // signals caught and handled by the JVM. To work around this, we reset the mach task
+    // signal handler that's placed on our process by CrashReporter. This disables
+    // CrashReporter-based reporting.
+    //
+    // This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes
+    // on caught fatal signals.
+    //
+    // Additionally, gdb installs both standard BSD signal handlers, and mach exception
+    // handlers. By replacing the existing task exception handler, we disable gdb's mach
+    // exception handling, while leaving the standard BSD signal handlers functional.
+    kern_return_t kr;
+    kr = task_set_exception_ports(mach_task_self(),
+        EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,
+        MACH_PORT_NULL,
+        EXCEPTION_STATE_IDENTITY,
+        MACHINE_THREAD_STATE);
+
+    assert(kr == KERN_SUCCESS, "could not set mach task signal handler");
+#endif
+
     if (libjsig_is_loaded) {
       // Tell libjsig jvm finishes setting signal handlers
       (*end_signal_setting)();
@@@@ -3621,6 +3875,7 @@@@ void os::Bsd::install_signal_handlers() {
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 // This is the fastest way to get thread cpu time on Bsd.
 // Returns cpu time (user+sys) for any thread, not only for current.
 // POSIX compliant clocks are implemented in the kernels 2.6.16+.
@@@@ -3635,6 +3890,7 @@@@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
 
   return (tp.tv_sec * SEC_IN_NANOSECS) + tp.tv_nsec;
 }
+#endif
 
 /////
 // glibc on Bsd platform uses non-documented flag
@@@@ -3856,13 +4112,13 @@@@ void os::init(void) {
 
   _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();
 
-  clock_tics_per_sec = sysconf(_SC_CLK_TCK);
+  clock_tics_per_sec = CLK_TCK;
 
   init_random(1234567);
 
   ThreadCritical::initialize();
 
-  Bsd::set_page_size(sysconf(_SC_PAGESIZE));
+  Bsd::set_page_size(getpagesize());
   if (Bsd::page_size() == -1) {
     fatal(err_msg("os_bsd.cpp: os::init: sysconf failed (%s)",
                   strerror(errno)));
@@@@ -3876,7 +4132,16 @@@@ void os::init(void) {
 
   Bsd::clock_init();
   initial_time_count = os::elapsed_counter();
-  pthread_mutex_init(&dl_mutex, NULL);
+
+#ifdef __APPLE__
+  // XXXDARWIN
+  // Work around the unaligned VM callbacks in hotspot's
+  // sharedRuntime. The callbacks don't use SSE2 instructions, and work on
+  // Linux, Solaris, and FreeBSD. On Mac OS X, dyld (rightly so) enforces
+  // alignment when doing symbol lookup. To work around this, we force early
+  // binding of all symbols now, thus binding when alignment is known-good.
+  _dyld_bind_fully_image_containing_address((const void *) &os::init);
+#endif
 }
 
 // To install functions for atexit system call
@@@@ -3889,7 +4154,9 @@@@ extern "C" {
 // this is called _after_ the global arguments have been parsed
 jint os::init_2(void)
 {
+#ifndef _ALLBSD_SOURCE
   Bsd::fast_thread_clock_init();
+#endif
 
   // Allocate a single page and mark it as readable for safepoint polling
   address polling_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
@@@@ -3947,6 +4214,7 @@@@ jint os::init_2(void)
   JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,
         vm_page_size()));
 
+#ifndef _ALLBSD_SOURCE
   Bsd::capture_initial_stack(JavaThread::stack_size_at_create());
 
   Bsd::libpthread_init();
@@@@ -3969,6 +4237,7 @@@@ jint os::init_2(void)
       UseNUMA = true;
     }
   }
+#endif
 
   if (MaxFDLimit) {
     // set the number of file descriptors to max. print out error
@@@@ -3980,6 +4249,14 @@@@ jint os::init_2(void)
         perror("os::init_2 getrlimit failed");
     } else {
       nbr_files.rlim_cur = nbr_files.rlim_max;
+      
+#ifdef __APPLE__
+      // Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if
+      // you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must
+      // be used instead
+      nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);
+#endif
+
       status = setrlimit(RLIMIT_NOFILE, &nbr_files);
       if (status != 0) {
         if (PrintMiscellaneous && (Verbose || WizardMode))
@@@@ -3988,8 +4265,10 @@@@ jint os::init_2(void)
     }
   }
 
+#ifndef _ALLBSD_SOURCE
   // Initialize lock used to serialize thread creation (see os::create_thread)
   Bsd::set_createThread_lock(new Mutex(Mutex::leaf, "createThread_lock", false));
+#endif
 
   // Initialize HPI.
   jint hpi_result = hpi::initialize();
@@@@ -4040,11 +4319,15 @@@@ void os::make_polling_page_readable(void) {
 };
 
 int os::active_processor_count() {
+#ifdef _ALLBSD_SOURCE
+  return _processor_count;
+#else
   // Bsd doesn't yet have a (official) notion of processor sets,
   // so just return the number of online processors.
   int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
   assert(online_cpus > 0 && online_cpus <= processor_count(), "sanity check");
   return online_cpus;
+#endif
 }
 
 bool os::distribute_processes(uint length, uint* distribution) {
@@@@ -4086,6 +4369,9 @@@@ ExtendedPC os::get_thread_pc(Thread* thread) {
 
 int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)
 {
+#ifdef _ALLBSD_SOURCE
+  return pthread_cond_timedwait(_cond, _mutex, _abstime);
+#else
    if (is_NPTL()) {
       return pthread_cond_timedwait(_cond, _mutex, _abstime);
    } else {
@@@@ -4101,6 +4387,7 @@@@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
 #endif // IA64
       return status;
    }
+#endif
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@@@ -4233,17 +4520,17 @@@@ int os::create_binary_file(const char* path, bool rewr
   if (!rewrite_existing) {
     oflags |= O_EXCL;
   }
-  return ::open64(path, oflags, S_IREAD | S_IWRITE);
+  return ::open(path, oflags, S_IREAD | S_IWRITE);
 }
 
 // return current position of file pointer
 jlong os::current_file_offset(int fd) {
-  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);
 }
 
 // move file pointer to the specified offset
 jlong os::seek_to_file_offset(int fd, jlong offset) {
-  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);
+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);
 }
 
 // Map a block of memory.
@@@@ -4293,6 +4580,7 @@@@ bool os::unmap_memory(char* addr, size_t bytes) {
   return munmap(addr, bytes) == 0;
 }
 
+#ifndef _ALLBSD_SOURCE
 static jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time);
 
 static clockid_t thread_cpu_clockid(Thread* thread) {
@@@@ -4304,6 +4592,7 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
   assert(rc == 0, "pthread_getcpuclockid is expected to return 0 code");
   return clockid;
 }
+#endif
 
 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
 // are used by JVM M&M and JVMTI to get user+sys or user CPU time
@@@@ -4313,39 +4602,71 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
 // the fast estimate available on the platform.
 
 jlong os::current_thread_cpu_time() {
+#ifdef __APPLE__
+  return os::thread_cpu_time(Thread::current(), true /* user + sys */);
+#elif !defined(_ALLBSD_SOURCE)
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     // return user + sys since the cost is the same
     return slow_thread_cpu_time(Thread::current(), true /* user + sys */);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread* thread) {
+#ifndef _ALLBSD_SOURCE
   // consistent with what current_thread_cpu_time() returns
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, true /* user + sys */);
   }
+#endif
 }
 
 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
+#ifdef __APPLE__
+  return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
+#elif !defined(_ALLBSD_SOURCE)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     return slow_thread_cpu_time(Thread::current(), user_sys_cpu_time);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
+#ifdef __APPLE__
+  struct thread_basic_info tinfo;
+  mach_msg_type_number_t tcount = THREAD_INFO_MAX;
+  kern_return_t kr;
+  mach_port_t mach_thread;
+
+  mach_thread = pthread_mach_thread_np(thread->osthread()->thread_id());
+  kr = thread_info(mach_thread, THREAD_BASIC_INFO, (thread_info_t)&tinfo, &tcount);
+  if (kr != KERN_SUCCESS)
+    return -1;
+
+  if (user_sys_cpu_time) {
+    jlong nanos;
+    nanos = ((jlong) tinfo.system_time.seconds + tinfo.user_time.seconds) * (jlong)1000000000;
+    nanos += ((jlong) tinfo.system_time.microseconds + (jlong) tinfo.user_time.microseconds) * (jlong)1000;
+    return nanos;
+  } else {
+    return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);
+  }
+#elif !defined(_ALLBSD_SOURCE)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, user_sys_cpu_time);
   }
+#endif
 }
 
+#ifndef _ALLBSD_SOURCE
 //
 //  -1 on error.
 //
@@@@ -4435,6 +4756,7 @@@@ static jlong slow_thread_cpu_time(Thread *thread, bool
     return (jlong)user_time * (1000000000 / clock_tics_per_sec);
   }
 }
+#endif
 
 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
   info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
@@@@ -4451,7 +4773,13 @@@@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
 }
 
 bool os::is_thread_cpu_time_supported() {
+#ifdef __APPLE__
   return true;
+#elif defined(_ALLBSD_SOURCE)
+  return false;
+#else
+  return true;
+#endif
 }
 
 // System loadavg support.  Returns -1 if load average cannot be obtained.
@@@@ -4584,7 +4912,7 @@@@ jdk_pthread_sigmask(int how , const sigset_t* newmask,
 // abstime will be the absolute timeout time
 // TODO: replace compute_abstime() with unpackTime()
 
-static struct timespec* compute_abstime(timespec* abstime, jlong millis) {
+static struct timespec* compute_abstime(struct timespec* abstime, jlong millis) {
   if (millis < 0)  millis = 0;
   struct timeval now;
   int status = gettimeofday(&now, NULL);
@@@@ -4636,7 +4964,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
         status = pthread_cond_wait(_cond, _mutex);
         // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...
         // Treat this the same as if the wait was interrupted
-        if (status == ETIME) { status = EINTR; }
+        if (status == ETIMEDOUT) { status = EINTR; } 
         assert_status(status == 0 || status == EINTR, status, "cond_wait");
      }
      -- _nParked ;
@@@@ -4694,10 +5022,10 @@@@ int os::PlatformEvent::park(jlong millis) {
       pthread_cond_init (_cond, NULL) ;
     }
     assert_status(status == 0 || status == EINTR ||
-                  status == ETIME || status == ETIMEDOUT,
+		  status == ETIMEDOUT, 
                   status, "cond_timedwait");
     if (!FilterSpuriousWakeups) break ;                 // previous semantics
-    if (status == ETIME || status == ETIMEDOUT) break ;
+    if (status == ETIMEDOUT) break ; 
     // We consume and ignore EINTR and spurious wakeups.
   }
   --_nParked ;
@@@@ -4789,7 +5117,7 @@@@ void os::PlatformEvent::unpark() {
  * years from "now".
  */
 
-static void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {
+static void unpackTime(struct timespec* absTime, bool isAbsolute, jlong time) {
   assert (time > 0, "convertTime");
 
   struct timeval now;
@@@@ -4849,7 +5177,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
   }
 
   // Next, demultiplex/decode time arguments
-  timespec absTime;
+  struct timespec absTime;
   if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all
     return;
   }
@@@@ -4903,7 +5231,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
     }
   }
   assert_status(status == 0 || status == EINTR ||
-                status == ETIME || status == ETIMEDOUT,
+                status == ETIMEDOUT, 
                 status, "cond_timedwait");
 
 #ifdef ASSERT
@@@@ -4946,16 +5274,14 @@@@ void Parker::unpark() {
 }
 
 
+/* Darwin has no "environ" in a dynamic library. */
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
 extern char** environ;
-
-#ifndef __NR_fork
-#define __NR_fork IA32_ONLY(2) IA64_ONLY(not defined) AMD64_ONLY(57)
 #endif
 
-#ifndef __NR_execve
-#define __NR_execve IA32_ONLY(11) IA64_ONLY(1033) AMD64_ONLY(59)
-#endif
-
 // Run the specified command in a separate process. Return its exit value,
 // or -1 on failure (e.g. can't fork a new process).
 // Unlike system(), this function can be called from signal handler. It
@@@@ -4968,8 +5294,7 @@@@ int os::fork_and_exec(char* cmd) {
   // separate process to execve. Make a direct syscall to fork process.
   // On IA64 there's no fork syscall, we have to use fork() and hope for
   // the best...
-  pid_t pid = NOT_IA64(syscall(__NR_fork);)
-              IA64_ONLY(fork();)
+  pid_t pid = fork();
 
   if (pid < 0) {
     // fork failed
@@@@ -4985,8 +5310,7 @@@@ int os::fork_and_exec(char* cmd) {
     // in the new process, so make a system call directly.
     // IA64 should use normal execve() from glibc to match the glibc fork()
     // above.
-    NOT_IA64(syscall(__NR_execve, "/bin/sh", argv, environ);)
-    IA64_ONLY(execve("/bin/sh", (char* const*)argv, environ);)
+    execve("/bin/sh", (char* const*)argv, environ);
 
     // execve failed
     _exit(-1);
@


1.12
log
@Update to early access build 122. okay jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.11 2009/06/10 19:01:09 kurt Exp $
@


1.11
log
@- binary plugs distfile no longer needed
- sync patches with OpenJDK7 bsd-port repository
- install a usable cacerts
- Remove Interruptible IO support
tested by ian@@ william@@
@
text
@d1 4
a4 4
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.10 2009/05/23 03:03:24 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Sat May 30 10:11:57 2009
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Sat May 30 10:15:08 2009
@@@@ -42,18 +42,40 @@@@
d24 4
a27 1
+
d29 1
a29 1
 # include <link.h>
d31 1
a31 1
 
d48 1
a48 1
@@@@ -64,19 +86,25 @@@@
d74 1
a74 1
@@@@ -94,8 +122,6 @@@@ static pid_t _initial_pid = 0;
d83 1
a83 1
@@@@ -108,11 +134,16 @@@@ julong os::available_memory() {
d100 1
a100 1
@@@@ -160,6 +191,7 @@@@ bool os::have_special_privileges() {
d108 1
a108 1
@@@@ -174,6 +206,7 @@@@ bool os::have_special_privileges() {
d115 2
a116 2
 #if   defined(IA64)
@@@@ -193,6 +226,7 @@@@ static char cpu_arch[] = "sparc";
d124 1
a124 1
@@@@ -219,8 +253,48 @@@@ static bool unsafe_chroot_detected = false;
d141 6
a146 5
+  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1)
+        _processor_count = cpu_val;
+
+  if (_processor_count < 1)
+       _processor_count = 1;   // fallback
d171 2
a172 2
   _processor_count = sysconf(_SC_NPROCESSORS_CONF);
   if (_processor_count == 1) {
d174 1
a174 1
@@@@ -236,6 +310,7 @@@@ void os::Bsd::initialize_system_info() {
d176 1
a176 1
   assert(_processor_count > 0, "bsd error");
d182 1
a182 1
@@@@ -279,9 +354,7 @@@@ void os::init_system_properties_values() {
d193 1
a193 1
@@@@ -360,7 +433,11 @@@@ void os::init_system_properties_values() {
d205 1
a205 1
@@@@ -519,6 +596,7 @@@@ void os::Bsd::hotspot_sigmask(Thread* thread) {
d213 1
a213 1
@@@@ -682,6 +760,7 @@@@ bool os::Bsd::manually_expand_stack(JavaThread * t, ad
d221 1
a221 1
@@@@ -690,6 +769,9 @@@@ static address highest_vm_reserved_address();
d231 1
a231 1
@@@@ -723,6 +805,7 @@@@ static bool _thread_safety_check(Thread* thread) {
d239 1
a239 1
@@@@ -750,6 +833,10 @@@@ static void *java_start(Thread *thread) {
d250 1
a250 1
@@@@ -759,6 +846,7 @@@@ static void *java_start(Thread *thread) {
d258 1
a258 1
@@@@ -839,17 +927,22 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d281 1
a281 1
@@@@ -863,7 +956,9 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d291 1
a291 1
@@@@ -879,9 +974,11 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d303 1
a303 1
@@@@ -919,7 +1016,11 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d315 1
a315 1
@@@@ -930,6 +1031,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d323 1
a323 1
@@@@ -956,6 +1058,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d331 1
a331 1
@@@@ -1014,6 +1117,7 @@@@ extern "C" Thread* get_thread() {
d339 1
a339 1
@@@@ -1247,6 +1351,7 @@@@ void os::Bsd::capture_initial_stack(size_t max_size) {
d347 1
a347 1
@@@@ -1268,9 +1373,7 @@@@ jlong os::elapsed_frequency() {
d358 1
a358 1
@@@@ -1290,7 +1393,22 @@@@ jlong os::javaTimeMillis() {
d381 1
a381 1
@@@@ -1325,7 +1443,9 @@@@ void os::Bsd::clock_init() {
d391 1
a391 1
@@@@ -1364,6 +1484,7 @@@@ void os::Bsd::fast_thread_clock_init() {
d399 1
a399 1
@@@@ -1514,8 +1635,15 @@@@ int os::current_process_id() {
d413 4
a416 4
 const char* os::get_temp_directory() { return "/tmp/"; }
 
 static bool file_exists(const char* filename) {
@@@@ -1532,13 +1660,13 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
d432 1
a432 1
@@@@ -1547,7 +1675,8 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
d442 1
a442 1
@@@@ -1562,7 +1691,7 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
d451 1
a451 1
@@@@ -1603,6 +1732,23 @@@@ bool os::dll_address_to_function_name(address addr, ch
d475 1
a475 1
@@@@ -1677,11 +1823,27 @@@@ bool os::dll_address_to_library_name(address addr, cha
d503 1
a503 1
@@@@ -1734,6 +1896,18 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
d507 4
d515 4
d530 1
a530 1
@@@@ -1814,17 +1988,11 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
d551 1
a551 1
@@@@ -1847,7 +2015,51 @@@@ bool _print_ascii_file(const char* filename, outputStr
d603 1
a603 1
@@@@ -1856,6 +2068,7 @@@@ void os::print_dll_info(outputStream *st) {
d611 1
a611 1
@@@@ -1888,6 +2101,7 @@@@ void os::print_os_info(outputStream* st) {
d619 1
a619 1
@@@@ -1902,6 +2116,7 @@@@ void os::print_os_info(outputStream* st) {
d627 1
a627 1
@@@@ -1927,6 +2142,7 @@@@ void os::print_os_info(outputStream* st) {
d635 1
a635 1
@@@@ -1939,6 +2155,7 @@@@ void os::print_os_info(outputStream* st) {
d639 5
d648 1
a648 1
@@@@ -1946,18 +2163,22 @@@@ void os::print_memory_info(outputStream* st) {
d669 5
d676 2
a677 1
@@@@ -2184,19 +2405,29 @@@@ int os::sigexitnum_pd() {
d709 1
a709 1
@@@@ -2218,7 +2449,7 @@@@ static int check_pending_signals(bool wait) {
d718 1
a718 1
@@@@ -2229,7 +2460,7 @@@@ static int check_pending_signals(bool wait) {
d727 14
a740 1
@@@@ -2301,9 +2532,14 @@@@ void bsd_wrap_code(char* base, size_t size) {
d755 1
a755 1
@@@@ -2319,36 +2555,27 @@@@ void os::free_memory(char *addr, size_t bytes) {
d797 1
a797 1
@@@@ -2359,6 +2586,7 @@@@ char *os::scan_pages(char *start, char* end, page_info
d805 1
a805 1
@@@@ -2460,11 +2688,18 @@@@ os::Bsd::numa_available_func_t os::Bsd::_numa_availabl
a811 1
-  return ::mmap(addr, size, PROT_NONE,
d816 3
a818 4
+  return ::mmap(addr, size,
+                PROT_READ|PROT_WRITE|PROT_EXEC,
                 MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0)
     != MAP_FAILED;
d822 96
a917 2
 static address _highest_vm_reserved_address = NULL;
@@@@ -2568,6 +2803,9 @@@@ bool os::unguard_memory(char* addr, size_t size) {
d927 1
a927 1
@@@@ -2622,6 +2860,7 @@@@ bool os::large_page_init() {
d935 1
a935 1
@@@@ -2798,7 +3037,7 @@@@ char* os::attempt_reserve_memory_at(size_t bytes, char
d944 1
a944 1
@@@@ -2934,9 +3173,47 @@@@ void os::loop_breaker(int attempts) {
d992 1
a992 1
@@@@ -2951,6 +3228,7 @@@@ int os::java_to_os_priority[MaxPriority + 1] = {
d1000 1
a1000 1
@@@@ -2970,8 +3248,28 @@@@ static int prio_init() {
d1029 1
a1029 1
@@@@ -2981,7 +3279,17 @@@@ OSReturn os::get_native_priority(const Thread* const t
d1047 1
a1047 1
@@@@ -3091,7 +3399,7 @@@@ static int SR_initialize() {
d1056 1
a1056 1
@@@@ -3434,6 +3742,28 @@@@ void os::Bsd::install_signal_handlers() {
d1085 1
a1085 1
@@@@ -3454,6 +3784,7 @@@@ void os::Bsd::install_signal_handlers() {
d1093 1
a1093 1
@@@@ -3468,6 +3799,7 @@@@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
d1101 1
a1101 1
@@@@ -3689,13 +4021,13 @@@@ void os::init(void) {
d1115 3
a1117 3
     fatal1("os_bsd.cpp: os::init: sysconf failed (%s)", strerror(errno));
   }
@@@@ -3708,7 +4040,16 @@@@ void os::init(void) {
d1135 1
a1135 1
@@@@ -3721,7 +4062,9 @@@@ extern "C" {
d1145 1
a1145 1
@@@@ -3770,6 +4113,7 @@@@ jint os::init_2(void)
d1153 1
a1153 1
@@@@ -3792,6 +4136,7 @@@@ jint os::init_2(void)
d1161 1
a1161 1
@@@@ -3803,6 +4148,14 @@@@ jint os::init_2(void)
d1176 1
a1176 1
@@@@ -3811,8 +4164,10 @@@@ jint os::init_2(void)
d1187 1
a1187 1
@@@@ -3860,11 +4215,15 @@@@ void os::make_polling_page_readable(void) {
d1203 1
a1203 1
@@@@ -3906,6 +4265,9 @@@@ ExtendedPC os::get_thread_pc(Thread* thread) {
d1213 1
a1213 1
@@@@ -3921,6 +4283,7 @@@@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
d1221 1
a1221 1
@@@@ -4056,17 +4419,17 @@@@ int os::create_binary_file(const char* path, bool rewr
d1242 1
a1242 1
@@@@ -4116,6 +4479,7 @@@@ bool os::unmap_memory(char* addr, size_t bytes) {
d1250 1
a1250 1
@@@@ -4127,6 +4491,7 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d1258 1
a1258 1
@@@@ -4136,39 +4501,71 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d1330 1
a1330 1
@@@@ -4257,6 +4654,7 @@@@ static jlong slow_thread_cpu_time(Thread *thread, bool
d1338 1
a1338 1
@@@@ -4273,7 +4671,13 @@@@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
d1352 1
a1352 1
@@@@ -4406,7 +4810,7 @@@@ jdk_pthread_sigmask(int how , const sigset_t* newmask,
d1361 1
a1361 1
@@@@ -4458,7 +4862,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
d1370 1
a1370 1
@@@@ -4516,10 +4920,10 @@@@ int os::PlatformEvent::park(jlong millis) {
d1383 1
a1383 1
@@@@ -4611,7 +5015,7 @@@@ void os::PlatformEvent::unpark() {
d1392 1
a1392 1
@@@@ -4670,7 +5074,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d1398 1
a1398 1
   if (time < 0) { // don't wait at all
d1401 1
a1401 1
@@@@ -4723,7 +5127,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d1410 1
a1410 1
@@@@ -4765,16 +5169,14 @@@@ void Parker::unpark() {
d1432 1
a1432 1
@@@@ -4787,8 +5189,7 @@@@ int os::fork_and_exec(char* cmd) {
d1442 1
a1442 1
@@@@ -4804,8 +5205,7 @@@@ int os::fork_and_exec(char* cmd) {
@


1.10
log
@- update from early access b43 to b59
- sync patches with OpenJDK's bsd_port project
- require a pre-installed package for native_bootstrap
- The new 1.7 class java.nio.channels.spi.AsynchronousChannelProvider
  is not implemented yet on BSD.
- The new 1.7 package java.nio.sctp is not included and not supported on
  OpenBD
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.9 2009/01/17 11:37:42 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Wed May 20 17:42:24 2009
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Wed May 20 18:24:46 2009
d71 1
a71 1
@@@@ -94,9 +122,76 @@@@ static pid_t _initial_pid = 0;
a76 3
+#ifdef _ALLBSD_SOURCE
+// XXXBSD: ported from solaris version
+// interruptible infrastructure
a77 66
+// setup_interruptible saves the thread state before going into an
+// interruptible system call.  
+// The saved state is used to restore the thread to
+// its former state whether or not an interrupt is received.  
+// Used by classloader os::read 
+// hpi calls skip this layer and stay in _thread_in_native
+
+void os::Bsd::setup_interruptible(JavaThread* thread) {
+ 
+  JavaThreadState thread_state = thread->thread_state();
+
+  assert(thread_state != _thread_blocked, "Coming from the wrong thread");
+  assert(thread_state != _thread_in_native, "Native threads skip setup_interruptible");
+  OSThread* osthread = thread->osthread();
+  osthread->set_saved_interrupt_thread_state(thread_state);
+  thread->frame_anchor()->make_walkable(thread);
+  ThreadStateTransition::transition(thread, thread_state, _thread_blocked);
+}
+
+// Version of setup_interruptible() for threads that are already in
+// _thread_blocked. Used by os_sleep().
+void os::Bsd::setup_interruptible_already_blocked(JavaThread* thread) {
+  thread->frame_anchor()->make_walkable(thread);
+}
+
+JavaThread* os::Bsd::setup_interruptible() {
+  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();
+  setup_interruptible(thread);
+  return thread;
+}
+
+#ifdef ASSERT
+
+JavaThread* os::Bsd::setup_interruptible_native() {
+  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();
+  JavaThreadState thread_state = thread->thread_state();
+  assert(thread_state == _thread_in_native, "Assumed thread_in_native");
+  return thread;
+}
+
+void os::Bsd::cleanup_interruptible_native(JavaThread* thread) {
+  JavaThreadState thread_state = thread->thread_state();
+  assert(thread_state == _thread_in_native, "Assumed thread_in_native");
+}
+#endif
+
+// cleanup_interruptible reverses the effects of setup_interruptible
+// setup_interruptible_already_blocked() does not need any cleanup.
+
+void os::Bsd::cleanup_interruptible(JavaThread* thread) {
+  OSThread* osthread = thread->osthread();
+
+  ThreadStateTransition::transition(thread, _thread_blocked, osthread->saved_interrupt_thread_state());
+}
+
+// I/O interruption related counters called in _INTERRUPTIBLE
+
+void os::Bsd::bump_interrupted_before_count() {
+  RuntimeService::record_interrupted_before_count();
+}
+
+void os::Bsd::bump_interrupted_during_count() {
+  RuntimeService::record_interrupted_during_count();
+}
+#endif
+
d80 1
a80 2
 
@@@@ -108,11 +203,16 @@@@ julong os::available_memory() {
d97 1
a97 1
@@@@ -160,6 +260,7 @@@@ bool os::have_special_privileges() {
d105 1
a105 1
@@@@ -174,6 +275,7 @@@@ bool os::have_special_privileges() {
d113 1
a113 1
@@@@ -193,6 +295,7 @@@@ static char cpu_arch[] = "sparc";
d121 1
a121 1
@@@@ -219,8 +322,48 @@@@ static bool unsafe_chroot_detected = false;
d170 1
a170 1
@@@@ -236,6 +379,7 @@@@ void os::Bsd::initialize_system_info() {
d178 1
a178 1
@@@@ -279,9 +423,7 @@@@ void os::init_system_properties_values() {
d189 1
a189 1
@@@@ -360,7 +502,11 @@@@ void os::init_system_properties_values() {
d201 1
a201 1
@@@@ -519,6 +665,7 @@@@ void os::Bsd::hotspot_sigmask(Thread* thread) {
d209 1
a209 1
@@@@ -682,6 +829,7 @@@@ bool os::Bsd::manually_expand_stack(JavaThread * t, ad
d217 1
a217 1
@@@@ -690,6 +838,9 @@@@ static address highest_vm_reserved_address();
d227 1
a227 1
@@@@ -723,6 +874,7 @@@@ static bool _thread_safety_check(Thread* thread) {
d235 1
a235 1
@@@@ -750,6 +902,10 @@@@ static void *java_start(Thread *thread) {
d246 1
a246 1
@@@@ -759,6 +915,7 @@@@ static void *java_start(Thread *thread) {
d254 1
a254 1
@@@@ -839,17 +996,22 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d277 1
a277 1
@@@@ -863,7 +1025,9 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d287 1
a287 1
@@@@ -879,9 +1043,11 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d299 1
a299 1
@@@@ -919,7 +1085,11 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d311 1
a311 1
@@@@ -930,6 +1100,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d319 1
a319 1
@@@@ -956,6 +1127,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d327 1
a327 1
@@@@ -1014,6 +1186,7 @@@@ extern "C" Thread* get_thread() {
d335 1
a335 1
@@@@ -1247,6 +1420,7 @@@@ void os::Bsd::capture_initial_stack(size_t max_size) {
d343 1
a343 1
@@@@ -1268,9 +1442,7 @@@@ jlong os::elapsed_frequency() {
d354 1
a354 1
@@@@ -1290,7 +1462,22 @@@@ jlong os::javaTimeMillis() {
d377 1
a377 1
@@@@ -1325,7 +1512,9 @@@@ void os::Bsd::clock_init() {
d387 1
a387 1
@@@@ -1364,6 +1553,7 @@@@ void os::Bsd::fast_thread_clock_init() {
d395 1
a395 1
@@@@ -1514,8 +1704,15 @@@@ int os::current_process_id() {
d412 1
a412 1
@@@@ -1532,13 +1729,13 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
d428 1
a428 1
@@@@ -1547,7 +1744,8 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
d438 1
a438 1
@@@@ -1562,7 +1760,7 @@@@ void os::dll_build_name(char* buffer, size_t buflen,
d447 1
a447 1
@@@@ -1603,6 +1801,23 @@@@ bool os::dll_address_to_function_name(address addr, ch
d471 1
a471 1
@@@@ -1677,11 +1892,27 @@@@ bool os::dll_address_to_library_name(address addr, cha
d499 1
a499 1
@@@@ -1734,6 +1965,18 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
d518 1
a518 1
@@@@ -1814,17 +2057,11 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
d539 1
a539 1
@@@@ -1847,7 +2084,51 @@@@ bool _print_ascii_file(const char* filename, outputStr
d591 1
a591 1
@@@@ -1856,6 +2137,7 @@@@ void os::print_dll_info(outputStream *st) {
d599 1
a599 1
@@@@ -1888,6 +2170,7 @@@@ void os::print_os_info(outputStream* st) {
d607 1
a607 1
@@@@ -1902,6 +2185,7 @@@@ void os::print_os_info(outputStream* st) {
d615 1
a615 1
@@@@ -1927,6 +2211,7 @@@@ void os::print_os_info(outputStream* st) {
d623 1
a623 1
@@@@ -1939,6 +2224,7 @@@@ void os::print_os_info(outputStream* st) {
d631 1
a631 1
@@@@ -1946,18 +2232,22 @@@@ void os::print_memory_info(outputStream* st) {
d654 1
a654 1
@@@@ -2184,19 +2474,29 @@@@ int os::sigexitnum_pd() {
d686 1
a686 1
@@@@ -2218,7 +2518,7 @@@@ static int check_pending_signals(bool wait) {
d695 1
a695 1
@@@@ -2229,7 +2529,7 @@@@ static int check_pending_signals(bool wait) {
d704 1
a704 1
@@@@ -2301,9 +2601,14 @@@@ void bsd_wrap_code(char* base, size_t size) {
d719 1
a719 1
@@@@ -2319,36 +2624,27 @@@@ void os::free_memory(char *addr, size_t bytes) {
d761 1
a761 1
@@@@ -2359,6 +2655,7 @@@@ char *os::scan_pages(char *start, char* end, page_info
d769 1
a769 1
@@@@ -2460,11 +2757,18 @@@@ os::Bsd::numa_available_func_t os::Bsd::_numa_availabl
d789 1
a789 1
@@@@ -2568,6 +2872,9 @@@@ bool os::unguard_memory(char* addr, size_t size) {
d799 1
a799 1
@@@@ -2622,6 +2929,7 @@@@ bool os::large_page_init() {
d807 1
a807 1
@@@@ -2798,7 +3106,7 @@@@ char* os::attempt_reserve_memory_at(size_t bytes, char
d812 1
a812 1
+  INTERRUPTIBLE_RETURN_INT_VM(::read(fd, buf, nBytes), os::Bsd::clear_interrupted);
d816 1
a816 1
@@@@ -2934,9 +3242,47 @@@@ void os::loop_breaker(int attempts) {
d864 1
a864 1
@@@@ -2951,6 +3297,7 @@@@ int os::java_to_os_priority[MaxPriority + 1] = {
d872 1
a872 1
@@@@ -2970,8 +3317,28 @@@@ static int prio_init() {
d901 1
a901 1
@@@@ -2981,7 +3348,17 @@@@ OSReturn os::get_native_priority(const Thread* const t
d919 1
a919 1
@@@@ -3091,7 +3468,7 @@@@ static int SR_initialize() {
d928 1
a928 1
@@@@ -3434,6 +3811,28 @@@@ void os::Bsd::install_signal_handlers() {
d957 1
a957 1
@@@@ -3454,6 +3853,7 @@@@ void os::Bsd::install_signal_handlers() {
d965 1
a965 1
@@@@ -3468,6 +3868,7 @@@@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
d973 1
a973 1
@@@@ -3689,13 +4090,13 @@@@ void os::init(void) {
d989 1
a989 1
@@@@ -3708,7 +4109,16 @@@@ void os::init(void) {
d1007 1
a1007 1
@@@@ -3721,7 +4131,9 @@@@ extern "C" {
d1017 1
a1017 1
@@@@ -3770,6 +4182,7 @@@@ jint os::init_2(void)
d1025 1
a1025 1
@@@@ -3792,6 +4205,7 @@@@ jint os::init_2(void)
d1033 1
a1033 1
@@@@ -3803,6 +4217,14 @@@@ jint os::init_2(void)
d1048 1
a1048 1
@@@@ -3811,8 +4233,10 @@@@ jint os::init_2(void)
d1059 1
a1059 1
@@@@ -3860,11 +4284,15 @@@@ void os::make_polling_page_readable(void) {
d1075 1
a1075 1
@@@@ -3906,6 +4334,9 @@@@ ExtendedPC os::get_thread_pc(Thread* thread) {
d1085 1
a1085 1
@@@@ -3921,6 +4352,7 @@@@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
d1093 1
a1093 1
@@@@ -4056,17 +4488,17 @@@@ int os::create_binary_file(const char* path, bool rewr
d1114 1
a1114 1
@@@@ -4116,6 +4548,7 @@@@ bool os::unmap_memory(char* addr, size_t bytes) {
d1122 1
a1122 1
@@@@ -4127,6 +4560,7 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d1130 1
a1130 1
@@@@ -4136,39 +4570,71 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d1202 1
a1202 1
@@@@ -4257,6 +4723,7 @@@@ static jlong slow_thread_cpu_time(Thread *thread, bool
d1210 1
a1210 1
@@@@ -4273,7 +4740,13 @@@@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
d1224 1
a1224 1
@@@@ -4406,7 +4879,7 @@@@ jdk_pthread_sigmask(int how , const sigset_t* newmask,
d1233 1
a1233 1
@@@@ -4458,7 +4931,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
d1242 1
a1242 1
@@@@ -4516,10 +4989,10 @@@@ int os::PlatformEvent::park(jlong millis) {
d1255 1
a1255 1
@@@@ -4611,7 +5084,7 @@@@ void os::PlatformEvent::unpark() {
d1264 1
a1264 1
@@@@ -4670,7 +5143,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d1273 1
a1273 1
@@@@ -4723,7 +5196,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d1282 1
a1282 1
@@@@ -4765,16 +5238,14 @@@@ void Parker::unpark() {
d1304 1
a1304 1
@@@@ -4787,8 +5258,7 @@@@ int os::fork_and_exec(char* cmd) {
d1314 1
a1314 1
@@@@ -4804,8 +5274,7 @@@@ int os::fork_and_exec(char* cmd) {
@


1.9
log
@- Update to early access b43:
  http://download.java.net/jdk7/changes/jdk7-b43.html
- Remove KOI8_U char encoding which no longer applies
- Correct datatype warning in fork_and_exec()
- Sync patches
@
text
@d1 10
a10 4
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.8 2009/01/16 16:49:29 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Fri Jan 16 12:16:37 2009
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Fri Jan 16 12:52:29 2009
@@@@ -47,13 +47,26 @@@@
d24 2
d27 1
d29 1
a29 1
+#if defined(__FreeBSD__)
d33 5
d45 1
a45 1
@@@@ -64,19 +77,25 @@@@
d71 3
a73 3
@@@@ -97,6 +116,76 @@@@ sigset_t SR_sigset;
 /* Used to protect dlsym() calls */
 static pthread_mutex_t dl_mutex;
d75 2
d80 1
a80 1
+
d150 1
a150 1
@@@@ -108,11 +197,16 @@@@ julong os::available_memory() {
d167 1
a167 1
@@@@ -160,6 +254,7 @@@@ bool os::have_special_privileges() {
d175 1
a175 1
@@@@ -174,6 +269,7 @@@@ bool os::have_special_privileges() {
d183 1
a183 1
@@@@ -193,6 +289,7 @@@@ static char cpu_arch[] = "sparc";
d191 1
a191 1
@@@@ -219,8 +316,48 @@@@ static bool unsafe_chroot_detected = false;
d228 1
a228 1
+       // datasize maximum limits us anyway.
d240 1
a240 1
@@@@ -236,6 +373,7 @@@@ void os::Bsd::initialize_system_info() {
d248 1
a248 1
@@@@ -279,7 +417,9 @@@@ void os::init_system_properties_values() {
d252 3
d257 10
d268 4
a271 4
 
 #define EXTENSIONS_DIR  "/lib/ext"
 #define ENDORSED_DIR    "/lib/endorsed"
@@@@ -515,6 +655,7 @@@@ void os::Bsd::hotspot_sigmask(Thread* thread) {
d279 1
a279 1
@@@@ -678,6 +819,7 @@@@ bool os::Bsd::manually_expand_stack(JavaThread * t, ad
d287 1
a287 1
@@@@ -686,6 +828,9 @@@@ static address highest_vm_reserved_address();
d297 1
a297 1
@@@@ -719,6 +864,7 @@@@ static bool _thread_safety_check(Thread* thread) {
d305 1
a305 1
@@@@ -746,6 +892,10 @@@@ static void *java_start(Thread *thread) {
d316 1
a316 1
@@@@ -755,6 +905,7 @@@@ static void *java_start(Thread *thread) {
d324 1
a324 1
@@@@ -835,17 +986,22 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d347 1
a347 1
@@@@ -859,7 +1015,9 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d357 1
a357 1
@@@@ -875,9 +1033,11 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d369 1
a369 1
@@@@ -915,7 +1075,11 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d381 1
a381 1
@@@@ -926,6 +1090,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d389 1
a389 1
@@@@ -952,6 +1117,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d397 1
a397 1
@@@@ -1010,6 +1176,7 @@@@ extern "C" Thread* get_thread() {
d405 1
a405 1
@@@@ -1240,6 +1407,7 @@@@ void os::Bsd::capture_initial_stack(size_t max_size) {
d413 12
a424 1
@@@@ -1283,7 +1451,18 @@@@ jlong os::javaTimeMillis() {
d428 1
a428 1
+#ifdef _ALLBSD_SOURCE
d430 4
d447 1
a447 1
@@@@ -1318,7 +1497,9 @@@@ void os::Bsd::clock_init() {
d457 1
a457 1
@@@@ -1357,6 +1538,7 @@@@ void os::Bsd::fast_thread_clock_init() {
d465 53
a517 1
@@@@ -1562,6 +1744,23 @@@@ bool os::dll_address_to_function_name(address addr, ch
d541 1
a541 1
@@@@ -1636,6 +1835,7 @@@@ bool os::dll_address_to_library_name(address addr, cha
d549 21
a569 1
@@@@ -1693,6 +1893,18 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
d588 22
a609 1
@@@@ -1806,7 +2018,41 @@@@ bool _print_ascii_file(const char* filename, outputStr
d644 10
d661 1
a661 1
@@@@ -1815,6 +2061,7 @@@@ void os::print_dll_info(outputStream *st) {
d669 1
a669 1
@@@@ -1847,6 +2094,7 @@@@ void os::print_os_info(outputStream* st) {
d677 1
a677 1
@@@@ -1861,6 +2109,7 @@@@ void os::print_os_info(outputStream* st) {
d685 1
a685 1
@@@@ -1886,6 +2135,7 @@@@ void os::print_os_info(outputStream* st) {
d693 1
a693 1
@@@@ -1898,6 +2148,7 @@@@ void os::print_os_info(outputStream* st) {
d701 1
a701 1
@@@@ -1905,18 +2156,22 @@@@ void os::print_memory_info(outputStream* st) {
d724 51
a774 2
@@@@ -2256,10 +2511,15 @@@@ void bsd_wrap_code(char* base, size_t size) {
 //       left at the time of mmap(). This could be a potential
d776 2
a777 1
 bool os::commit_memory(char* addr, size_t size) {
d780 1
a780 1
+  return mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC) == 0;
d782 1
a782 2
   uintptr_t res = (uintptr_t) ::mmap(addr, size,
                                    PROT_READ|PROT_WRITE|PROT_EXEC,
d788 54
a841 2
 bool os::commit_memory(char* addr, size_t size, size_t alignment_hint) {
@@@@ -2403,10 +2663,15 @@@@ os::Bsd::numa_interleave_memory_func_t os::Bsd::_numa_
d843 1
d846 1
d849 1
a849 1
+  return mprotect(addr, size, PROT_NONE) == 0;
d851 2
a852 2
   return ::mmap(addr, size,
                 PROT_READ|PROT_WRITE|PROT_EXEC,
d859 1
a859 1
@@@@ -2508,6 +2773,9 @@@@ bool os::unguard_memory(char* addr, size_t size) {
d869 1
a869 1
@@@@ -2562,6 +2830,7 @@@@ bool os::large_page_init() {
d877 1
a877 1
@@@@ -2736,7 +3005,7 @@@@ char* os::attempt_reserve_memory_at(size_t bytes, char
d886 1
a886 1
@@@@ -2872,9 +3141,28 @@@@ void os::loop_breaker(int attempts) {
d890 1
a890 1
+#ifdef _ALLBSD_SOURCE
d908 19
d934 1
a934 1
@@@@ -2889,6 +3177,7 @@@@ int os::java_to_os_priority[MaxPriority + 1] = {
d942 1
a942 1
@@@@ -2908,8 +3197,17 @@@@ static int prio_init() {
d949 1
a949 2
+#else
+#ifdef _ALLBSD_SOURCE
d951 13
a967 1
+#endif
d971 1
a971 1
@@@@ -2919,7 +3217,11 @@@@ OSReturn os::get_native_priority(const Thread* const t
d975 1
a975 1
+#ifdef _ALLBSD_SOURCE
d977 6
d989 1
a989 1
@@@@ -3029,7 +3331,7 @@@@ static int SR_initialize() {
d998 30
a1027 1
@@@@ -3392,6 +3694,7 @@@@ void os::Bsd::install_signal_handlers() {
d1035 1
a1035 1
@@@@ -3406,6 +3709,7 @@@@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
d1043 1
a1043 1
@@@@ -3627,13 +3931,13 @@@@ void os::init(void) {
d1059 19
a1077 1
@@@@ -3659,7 +3963,9 @@@@ extern "C" {
d1087 1
a1087 1
@@@@ -3708,6 +4014,7 @@@@ jint os::init_2(void)
d1095 3
a1097 3
@@@@ -3716,6 +4023,7 @@@@ jint os::init_2(void)
           Bsd::glibc_version(), Bsd::libpthread_version(),
           Bsd::is_floating_stack() ? "floating stack" : "fixed stack");
d1101 18
a1118 3
   if (UseNUMA) {
     if (!Bsd::libnuma_init()) {
@@@@ -3749,8 +4057,10 @@@@ jint os::init_2(void)
d1129 1
a1129 1
@@@@ -3798,11 +4108,15 @@@@ void os::make_polling_page_readable(void) {
d1145 1
a1145 1
@@@@ -3844,6 +4158,9 @@@@ ExtendedPC os::get_thread_pc(Thread* thread) {
d1155 1
a1155 1
@@@@ -3859,6 +4176,7 @@@@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
d1163 1
a1163 1
@@@@ -3994,17 +4312,17 @@@@ int os::create_binary_file(const char* path, bool rewr
d1184 1
a1184 1
@@@@ -4054,6 +4372,7 @@@@ bool os::unmap_memory(char* addr, size_t bytes) {
d1192 1
a1192 1
@@@@ -4065,6 +4384,7 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d1200 1
a1200 1
@@@@ -4074,39 +4394,48 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d1204 3
a1206 1
+#ifndef _ALLBSD_SOURCE
d1228 3
a1230 1
+#ifndef _ALLBSD_SOURCE
d1240 20
a1259 1
+#ifndef _ALLBSD_SOURCE
d1272 1
a1272 1
@@@@ -4195,6 +4524,7 @@@@ static jlong slow_thread_cpu_time(Thread *thread, bool
d1280 1
a1280 1
@@@@ -4211,7 +4541,11 @@@@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
d1284 3
a1286 1
+#ifdef _ALLBSD_SOURCE
d1289 1
a1289 1
   return true;
d1294 1
a1294 1
@@@@ -4344,7 +4678,7 @@@@ jdk_pthread_sigmask(int how , const sigset_t* newmask,
d1303 1
a1303 1
@@@@ -4396,7 +4730,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
d1312 1
a1312 1
@@@@ -4454,10 +4788,10 @@@@ int os::PlatformEvent::park(jlong millis) {
d1325 1
a1325 1
@@@@ -4549,7 +4883,7 @@@@ void os::PlatformEvent::unpark() {
d1334 1
a1334 1
@@@@ -4608,7 +4942,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d1343 1
a1343 1
@@@@ -4661,7 +4995,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d1352 3
a1354 1
@@@@ -4705,14 +5039,6 @@@@ void Parker::unpark() {
d1356 5
d1362 1
a1362 1
 
d1365 2
a1366 2
-#endif
-
d1374 1
a1374 1
@@@@ -4725,8 +5051,7 @@@@ int os::fork_and_exec(char* cmd) {
d1384 1
a1384 1
@@@@ -4742,8 +5067,7 @@@@ int os::fork_and_exec(char* cmd) {
@


1.8
log
@Various minor corrections:
- Remove some patches no longer needed
- Sync some corba and jdk makefiles with bsd-port repo
- Another datatype correction in hotspot
- Use proper scoping for clock_get* from bsd-port repo
- Use includeDB corrections from Coleen Phillimore @@ Sun
instead of my own ones. From hotspot-dev list.
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.7 2009/01/04 23:25:16 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Wed Jan 14 13:01:37 2009
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Wed Jan 14 13:03:52 2009
d979 1
a979 1
@@@@ -4705,28 +5039,19 @@@@ void Parker::unpark() {
d994 1
a994 7
 // doesn't block SIGINT et al.
 int os::fork_and_exec(char* cmd) {
-  const char * argv[4] = {"sh", "-c", cmd, NULL};
+  char * const argv[4] = {"sh", "-c", cmd, NULL};
 
   // fork() in BsdThreads/NPTL is not async-safe. It needs to run
   // pthread_atfork handlers and reset pthread library. All we need is a
d1010 1
a1010 1
+    execve("/bin/sh", argv, environ);
@


1.7
log
@Update to early access build 42:
- sync/regen patches
- use os_bsd_x86.cpp from OpenJDK bsd-java repository plus
  Greg Lewis's fixes posted to the bsd-port-dev list
- use Xiaobin Lu's datatype corrections from OpenJDK bug
  6787106 + additional datatype corrections from me.
- use Vladimir Kozlov's bug fix from OpenJDK bug 6782820
- remove obsolete IcedTea awt binary plugs and update binary
  plug distfile
- correctly define DEVTOOLS_PATH for bsd and verify + correct
  Defs-utils.gmk locations for bsd utilities
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.6 2008/10/22 16:02:24 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Wed Dec 24 10:02:07 2008
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Wed Dec 24 10:02:13 2008
d392 2
a393 2
+  if (clock_getres(CLOCK_MONOTONIC, &res) == 0 &&
+      clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {
d395 1
a395 1
+    _clock_gettime = clock_gettime;
@


1.6
log
@Limit the jdk's view of physical memory to rlimit_cur instead of
rlimit_max. This makes the jdk behave better on amd64.

okay naddy@@ ian@@
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.5 2008/03/19 18:05:43 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Tue Aug  5 21:06:35 2008
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Tue Aug  5 21:10:17 2008
d51 2
a52 2
 char * os::Bsd::_glibc_version = NULL;
 char * os::Bsd::_libpthread_version = NULL;
d57 3
a59 3
@@@@ -94,6 +113,76 @@@@ static pid_t _initial_pid = 0;
 static int SR_signum = SIGUSR2;
 sigset_t SR_sigset;
d134 1
a134 1
@@@@ -105,11 +194,16 @@@@ julong os::available_memory() {
d151 1
a151 1
@@@@ -143,6 +237,7 @@@@ bool os::have_special_privileges() {
d159 1
a159 1
@@@@ -157,6 +252,7 @@@@ bool os::have_special_privileges() {
d167 1
a167 1
@@@@ -176,6 +272,7 @@@@ static char cpu_arch[] = "sparc";
d175 4
a178 4
@@@@ -202,8 +299,48 @@@@ static bool unsafe_chroot_detected = false;
 static char *unstable_chroot_error = "/proc file system not found.\n"
               "Java may be unstable running multithreaded in a chroot "
               "environment on Bsd when /proc filesystem is not mounted.";
d224 1
a224 1
@@@@ -219,6 +356,7 @@@@ void os::Bsd::initialize_system_info() {
d232 1
a232 1
@@@@ -262,7 +400,9 @@@@ void os::init_system_properties_values() {
d242 1
a242 1
@@@@ -498,6 +638,7 @@@@ void os::Bsd::hotspot_sigmask(Thread* thread) {
d250 1
a250 1
@@@@ -664,6 +805,7 @@@@ bool os::Bsd::manually_expand_stack(JavaThread * t, ad
d258 1
a258 1
@@@@ -672,6 +814,9 @@@@ static address highest_vm_reserved_address();
d268 1
a268 1
@@@@ -705,6 +850,7 @@@@ static bool _thread_safety_check(Thread* thread) {
d276 1
a276 1
@@@@ -732,6 +878,10 @@@@ static void *java_start(Thread *thread) {
d287 1
a287 1
@@@@ -741,6 +891,7 @@@@ static void *java_start(Thread *thread) {
d295 1
a295 1
@@@@ -821,17 +972,22 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d318 1
a318 1
@@@@ -845,7 +1001,9 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d328 1
a328 1
@@@@ -861,9 +1019,11 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d340 1
a340 1
@@@@ -901,7 +1061,11 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d352 1
a352 1
@@@@ -912,6 +1076,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d360 1
a360 1
@@@@ -938,6 +1103,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d368 1
a368 1
@@@@ -996,6 +1162,7 @@@@ extern "C" Thread* get_thread() {
d376 1
a376 1
@@@@ -1226,6 +1393,7 @@@@ void os::Bsd::capture_initial_stack(size_t max_size) {
d384 1
a384 1
@@@@ -1264,7 +1432,18 @@@@ jlong os::javaTimeMillis() {
d403 1
a403 1
@@@@ -1299,7 +1478,9 @@@@ void os::Bsd::clock_init() {
d413 1
a413 1
@@@@ -1338,6 +1519,7 @@@@ void os::Bsd::fast_thread_clock_init() {
d421 1
a421 1
@@@@ -1525,6 +1707,23 @@@@ bool os::dll_address_to_function_name(address addr, ch
d445 1
a445 1
@@@@ -1599,6 +1798,7 @@@@ bool os::dll_address_to_library_name(address addr, cha
d453 1
a453 1
@@@@ -1656,6 +1856,18 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
d472 1
a472 1
@@@@ -1759,7 +1971,41 @@@@ bool _print_ascii_file(const char* filename, outputStr
d514 1
a514 1
@@@@ -1768,6 +2014,7 @@@@ void os::print_dll_info(outputStream *st) {
d522 1
a522 1
@@@@ -1800,6 +2047,7 @@@@ void os::print_os_info(outputStream* st) {
d530 1
a530 1
@@@@ -1814,6 +2062,7 @@@@ void os::print_os_info(outputStream* st) {
d538 1
a538 1
@@@@ -1839,6 +2088,7 @@@@ void os::print_os_info(outputStream* st) {
d546 1
a546 1
@@@@ -1851,6 +2101,7 @@@@ void os::print_os_info(outputStream* st) {
d554 1
a554 1
@@@@ -1858,18 +2109,22 @@@@ void os::print_memory_info(outputStream* st) {
d577 1
a577 1
@@@@ -2209,10 +2464,15 @@@@ void bsd_wrap_code(char* base, size_t size) {
d593 2
a594 2
@@@@ -2243,10 +2503,15 @@@@ char *os::scan_pages(char *start, char* end, page_info
 }
d609 1
a609 1
@@@@ -2336,6 +2601,9 @@@@ bool os::unguard_memory(char* addr, size_t size) {
d619 1
a619 1
@@@@ -2390,6 +2658,7 @@@@ bool os::large_page_init() {
d627 1
a627 1
@@@@ -2560,7 +2829,7 @@@@ char* os::attempt_reserve_memory_at(size_t bytes, char
d636 1
a636 1
@@@@ -2696,9 +2965,28 @@@@ void os::loop_breaker(int attempts) {
d665 1
a665 1
@@@@ -2713,6 +3001,7 @@@@ int os::java_to_os_priority[MaxPriority + 1] = {
d673 1
a673 1
@@@@ -2732,8 +3021,17 @@@@ static int prio_init() {
d691 1
a691 1
@@@@ -2743,7 +3041,11 @@@@ OSReturn os::get_native_priority(const Thread* const t
d703 1
a703 1
@@@@ -2853,7 +3155,7 @@@@ static int SR_initialize() {
d712 1
a712 1
@@@@ -3216,6 +3518,7 @@@@ void os::Bsd::install_signal_handlers() {
d720 1
a720 1
@@@@ -3230,6 +3533,7 @@@@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
d728 1
a728 1
@@@@ -3451,13 +3755,13 @@@@ void os::init(void) {
d744 1
a744 1
@@@@ -3482,7 +3786,9 @@@@ extern "C" {
d754 1
a754 1
@@@@ -3531,6 +3837,7 @@@@ jint os::init_2(void)
d762 1
a762 1
@@@@ -3539,6 +3846,7 @@@@ jint os::init_2(void)
d768 3
a770 3
   if (MaxFDLimit) {
     // set the number of file descriptors to max. print out error
@@@@ -3558,8 +3866,10 @@@@ jint os::init_2(void)
d781 1
a781 1
@@@@ -3606,11 +3916,15 @@@@ void os::make_polling_page_readable(void) {
d797 1
a797 1
@@@@ -3652,6 +3966,9 @@@@ ExtendedPC os::get_thread_pc(Thread* thread) {
d807 1
a807 1
@@@@ -3667,6 +3984,7 @@@@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
d815 1
a815 1
@@@@ -3802,17 +4120,17 @@@@ int os::create_binary_file(const char* path, bool rewr
d836 1
a836 1
@@@@ -3862,6 +4180,7 @@@@ bool os::unmap_memory(char* addr, size_t bytes) {
d844 1
a844 1
@@@@ -3873,6 +4192,7 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d852 1
a852 1
@@@@ -3882,39 +4202,48 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d901 1
a901 1
@@@@ -4003,6 +4332,7 @@@@ static jlong slow_thread_cpu_time(Thread *thread, bool
d909 1
a909 1
@@@@ -4019,7 +4349,11 @@@@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
d921 1
a921 1
@@@@ -4152,7 +4486,7 @@@@ jdk_pthread_sigmask(int how , const sigset_t* newmask,
d930 1
a930 1
@@@@ -4204,7 +4538,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
d939 1
a939 1
@@@@ -4262,10 +4596,10 @@@@ int os::PlatformEvent::park(jlong millis) {
d952 1
a952 1
@@@@ -4357,7 +4691,7 @@@@ void os::PlatformEvent::unpark() {
d961 1
a961 1
@@@@ -4416,7 +4750,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d970 1
a970 1
@@@@ -4469,7 +4803,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d979 1
a979 1
@@@@ -4513,14 +4847,6 @@@@ void Parker::unpark() {
d994 7
a1000 1
@@@@ -4537,8 +4863,7 @@@@ int os::fork_and_exec(char* cmd) {
d1010 1
a1010 1
@@@@ -4554,8 +4879,7 @@@@ int os::fork_and_exec(char* cmd) {
d1015 1
a1015 1
-    IA64_ONLY(execve("/bin/sh", argv, environ);)
@


1.5
log
@- switch to GPLv2 w/CLASSPATH exception licensed openjdk7 code
- update to early access build 24
- Use GPLv2 licensed binary plugs from the IcedTea project and parts of
  IcedTea's icedtea-copy-plugs.patch & icedtea-graphics.patch.
  For more info see:
    http://icedtea.classpath.org/wiki/Main_Page
- Enable packages since we're fully GPLv2 based now, but still not
  hooked up to bulk builds just yet.
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.4 2007/09/06 15:46:18 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Wed Nov  7 12:41:29 2007
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Wed Nov  7 13:07:56 2007
d215 1
a215 1
+       _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_max);
@


1.4
log
@Remove BROKEN and update port to b19. The port is fully 1.7 now (both
hotspot and j2se). The j2se patches are from the bsd java repositories
1.5 -> 1.6 (performed by Greg Lewis) -> 1.7 by myself. j2se patches are
in sync with 1.6 patchset 1 plus the Runtime.exec fix from Michiel Boland
via FreeBSD PR http://www.freebsd.org/cgi/query-pr.cgi?pr=115557.

Also from FreeBSD: interactive JRL license verification. By default the
port is IS_INTERACTIVE=Yes. Add ACCEPT_JRL_LICENSE=Yes to /etc/mk.conf
to permanently accept the JRL license.

At some point in the future I will work on switching this back to
OpenJDK/GPLv2 src. That largely depends on Sun's progress at removing more
of the binary plug bits so that stubbing out the remainder is less
cumbersome and time consuming.

Testing, comments and okay ian@@
@
text
@d1 4
a4 4
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.3 2007/07/13 22:52:35 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Fri Aug  3 18:02:38 2007
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Fri Aug  3 18:35:06 2007
@@@@ -50,13 +50,26 @@@@
d31 1
a31 1
@@@@ -67,19 +80,25 @@@@
d57 1
a57 1
@@@@ -97,6 +116,76 @@@@ static pid_t _initial_pid = 0;
d134 1
a134 1
@@@@ -108,11 +197,16 @@@@ julong os::available_memory() {
d145 1
a145 1
   
d151 1
a151 1
@@@@ -146,6 +240,7 @@@@ bool os::have_special_privileges() {
d159 1
a159 1
@@@@ -160,6 +255,7 @@@@ bool os::have_special_privileges() {
d167 1
a167 1
@@@@ -179,6 +275,7 @@@@ static char cpu_arch[] = "sparc";
d175 1
a175 1
@@@@ -205,8 +302,48 @@@@ static bool unsafe_chroot_detected = false;
d224 1
a224 1
@@@@ -222,6 +359,7 @@@@ void os::Bsd::initialize_system_info() {
d232 3
a234 3
@@@@ -265,7 +403,9 @@@@ void os::init_system_properties_values() {
  *	  ...
  *	  7: The default directories, normally /lib and /usr/lib.
d237 1
a237 1
 #define DEFAULT_LIBPATH	"/lib:/usr/lib"
d240 3
a242 3
 #define EXTENSIONS_DIR	"/lib/ext"
 #define ENDORSED_DIR	"/lib/endorsed"
@@@@ -501,6 +641,7 @@@@ void os::Bsd::hotspot_sigmask(Thread* thread) {
d250 1
a250 1
@@@@ -667,6 +808,7 @@@@ bool os::Bsd::manually_expand_stack(JavaThread * t, ad
d258 1
a258 1
@@@@ -675,6 +817,9 @@@@ static address highest_vm_reserved_address();
d268 1
a268 1
@@@@ -708,6 +853,7 @@@@ static bool _thread_safety_check(Thread* thread) {
d276 1
a276 1
@@@@ -735,6 +881,10 @@@@ static void *java_start(Thread *thread) {
d287 1
a287 1
@@@@ -744,6 +894,7 @@@@ static void *java_start(Thread *thread) {
d295 1
a295 1
@@@@ -824,17 +975,22 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d318 1
a318 1
@@@@ -848,7 +1004,9 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d328 1
a328 1
@@@@ -864,9 +1022,11 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d340 1
a340 1
@@@@ -904,7 +1064,11 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d352 1
a352 1
@@@@ -915,6 +1079,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d360 1
a360 1
@@@@ -941,6 +1106,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d368 1
a368 1
@@@@ -999,6 +1165,7 @@@@ extern "C" Thread* get_thread() {
d376 1
a376 1
@@@@ -1229,6 +1396,7 @@@@ void os::Bsd::capture_initial_stack(size_t max_size) {
d384 1
a384 1
@@@@ -1267,7 +1435,18 @@@@ jlong os::javaTimeMillis() {
d403 1
a403 1
@@@@ -1302,7 +1481,9 @@@@ void os::Bsd::clock_init() {
d413 1
a413 1
@@@@ -1341,6 +1522,7 @@@@ void os::Bsd::fast_thread_clock_init() {
d421 1
a421 1
@@@@ -1528,6 +1710,23 @@@@ bool os::dll_address_to_function_name(address addr, ch
d445 1
a445 1
@@@@ -1602,6 +1801,7 @@@@ bool os::dll_address_to_library_name(address addr, cha
d451 1
a451 1
   // Loads .dll/.so and 
d453 1
a453 1
@@@@ -1659,6 +1859,18 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
d469 1
a469 1
   static const arch_t arch_array[]={ 
d472 1
a472 1
@@@@ -1762,7 +1974,41 @@@@ bool _print_ascii_file(const char* filename, outputStr
d514 1
a514 1
@@@@ -1771,6 +2017,7 @@@@ void os::print_dll_info(outputStream *st) {
d522 1
a522 1
@@@@ -1803,6 +2050,7 @@@@ void os::print_os_info(outputStream* st) {
d530 1
a530 1
@@@@ -1817,6 +2065,7 @@@@ void os::print_os_info(outputStream* st) {
d538 1
a538 1
@@@@ -1842,6 +2091,7 @@@@ void os::print_os_info(outputStream* st) {
d546 1
a546 1
@@@@ -1854,6 +2104,7 @@@@ void os::print_os_info(outputStream* st) {
d554 1
a554 1
@@@@ -1861,18 +2112,22 @@@@ void os::print_memory_info(outputStream* st) {
d563 1
a563 1
   
d577 3
a579 3
@@@@ -2212,10 +2467,15 @@@@ void bsd_wrap_code(char* base, size_t size) {
 //       left at the time of mmap(). This could be a potential  
 //       problem.                                               
d593 1
a593 1
@@@@ -2246,10 +2506,15 @@@@ char *os::scan_pages(char *start, char* end, page_info
d602 2
a603 2
 		PROT_READ|PROT_WRITE|PROT_EXEC,
 		MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0)
d609 1
a609 1
@@@@ -2338,6 +2603,9 @@@@ bool os::unguard_memory(char* addr, size_t size) {
d619 1
a619 1
@@@@ -2385,6 +2653,7 @@@@ bool os::large_page_init() {
d627 1
a627 1
@@@@ -2555,9 +2824,11 @@@@ char* os::attempt_reserve_memory_at(size_t bytes, char
d633 1
a633 1
 }  
a634 2
+//XXXBSD: note in 1.5 we used our own nanosleep based os_sleep
+
d636 1
a636 3
 // Solaris uses poll(), bsd uses park().  
 // Poll() is likely a better choice, assuming that Thread.interrupt()
@@@@ -2691,9 +2962,28 @@@@ void os::loop_breaker(int attempts) {
d665 1
a665 1
@@@@ -2708,6 +2998,7 @@@@ int os::java_to_os_priority[MaxPriority + 1] = {
d673 1
a673 1
@@@@ -2727,8 +3018,17 @@@@ static int prio_init() {
d691 1
a691 1
@@@@ -2738,7 +3038,11 @@@@ OSReturn os::get_native_priority(const Thread* const t
d703 1
a703 1
@@@@ -2848,7 +3152,7 @@@@ static int SR_initialize() {
d709 1
a709 1
 	SR_signum = sig;
d712 1
a712 1
@@@@ -3211,6 +3515,7 @@@@ void os::Bsd::install_signal_handlers() {
d720 1
a720 1
@@@@ -3225,6 +3530,7 @@@@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
d728 1
a728 1
@@@@ -3446,16 +3752,16 @@@@ void os::init(void) {
a740 1
 
d742 1
a742 2
-    fatal1("os_bsd.cpp: os::init: sysconf failed (%s)", strerror(errno));
+    fatal1("os_bsd.cpp: os::init: getpagesize failed (%s)", strerror(errno));
d744 1
a744 3
 
   Bsd::initialize_system_info();
@@@@ -3477,7 +3783,9 @@@@ extern "C" {
d754 1
a754 1
@@@@ -3526,6 +3834,7 @@@@ jint os::init_2(void)
d762 2
a763 2
@@@@ -3534,6 +3843,7 @@@@ jint os::init_2(void)
           Bsd::glibc_version(), Bsd::libpthread_version(), 
d770 1
a770 1
@@@@ -3553,8 +3863,10 @@@@ jint os::init_2(void)
d781 1
a781 1
@@@@ -3601,11 +3913,15 @@@@ void os::make_polling_page_readable(void) {
d797 1
a797 1
@@@@ -3647,6 +3963,9 @@@@ ExtendedPC os::get_thread_pc(Thread* thread) {
d807 1
a807 1
@@@@ -3662,6 +3981,7 @@@@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
d815 1
a815 1
@@@@ -3797,17 +4117,17 @@@@ int os::create_binary_file(const char* path, bool rewr
d836 1
a836 1
@@@@ -3857,6 +4177,7 @@@@ bool os::unmap_memory(char* addr, size_t bytes) {
d844 1
a844 1
@@@@ -3868,6 +4189,7 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d850 1
a850 1
 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool) 
d852 1
a852 1
@@@@ -3877,39 +4199,48 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d900 2
a901 2
 // 
@@@@ -3998,6 +4329,7 @@@@ static jlong slow_thread_cpu_time(Thread *thread, bool
d909 1
a909 1
@@@@ -4014,7 +4346,11 @@@@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
d921 1
a921 1
@@@@ -4147,7 +4483,7 @@@@ jdk_pthread_sigmask(int how , const sigset_t* newmask,
d930 1
a930 1
@@@@ -4199,7 +4535,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
d934 1
a934 1
-        if (status == ETIME) { status = EINTR; } 
d938 2
a939 2
      -- _nParked ; 
@@@@ -4257,10 +4593,10 @@@@ int os::PlatformEvent::park(jlong millis) {
d942 2
a943 2
     assert_status(status == 0 || status == EINTR || 
-		  status == ETIME || status == ETIMEDOUT, 
d945 3
a947 3
 		  status, "cond_timedwait");
     if (!FilterSpuriousWakeups) break ; 		// previous semantics
-    if (status == ETIME || status == ETIMEDOUT) break ; 
d949 1
a949 1
     // We consume and ignore EINTR and spurious wakeups.   
d952 1
a952 1
@@@@ -4352,7 +4688,7 @@@@ void os::PlatformEvent::unpark() {
d961 1
a961 1
@@@@ -4411,7 +4747,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d968 1
a968 1
     return; 
d970 1
a970 1
@@@@ -4464,7 +4800,7 @@@@ void Parker::park(bool isAbsolute, jlong time) {
d973 2
a974 2
   assert_status(status == 0 || status == EINTR || 
-                status == ETIME || status == ETIMEDOUT, 
d979 1
a979 1
@@@@ -4508,14 +4844,6 @@@@ void Parker::unpark() {
d994 1
a994 1
@@@@ -4532,8 +4860,7 @@@@ int os::fork_and_exec(char* cmd) {
d998 1
a998 1
-  pid_t pid = NOT_IA64(syscall(__NR_fork);) 
d1004 1
a1004 1
@@@@ -4549,8 +4876,7 @@@@ int os::fork_and_exec(char* cmd) {
d1006 1
a1006 1
     // IA64 should use normal execve() from glibc to match the glibc fork() 
@


1.3
log
@- update to build 15
- switch to the JRL licensed src. why? because it will allow me to complete
the port. OpenJDK/GPLv2 src isn't complete and the parts that we don't have
are only released in binary form with a defend and indemnify clause. When
all of the jdk is GPLv2 I will switch back to OpenJDK/GPLv2 src.
- copy the Linux src files for the rest of the jdk so i can begin to patch
them. One src file is based on solaris code since that suits us better as
a starting point.
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.2 2007/05/09 15:48:31 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Wed Jun 13 16:37:27 2007
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Wed Jun 13 16:37:30 2007
d640 1
a640 1
@@@@ -2676,9 +2947,28 @@@@ void os::loop_breaker(int attempts) {
d669 1
a669 1
@@@@ -2693,6 +2983,7 @@@@ int os::java_to_os_priority[MaxPriority + 1] = {
d677 1
a677 1
@@@@ -2712,8 +3003,17 @@@@ static int prio_init() {
d695 1
a695 1
@@@@ -2723,7 +3023,11 @@@@ OSReturn os::get_native_priority(const Thread* const t
d707 1
a707 1
@@@@ -2833,7 +3137,7 @@@@ static int SR_initialize() {
d716 1
a716 1
@@@@ -3197,6 +3501,7 @@@@ void os::Bsd::install_signal_handlers() {
d724 1
a724 1
@@@@ -3211,6 +3516,7 @@@@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
d732 1
a732 1
@@@@ -3432,16 +3738,16 @@@@ void os::init(void) {
d752 1
a752 1
@@@@ -3463,7 +3769,9 @@@@ extern "C" {
d762 1
a762 1
@@@@ -3512,6 +3820,7 @@@@ jint os::init_2(void)
d770 1
a770 1
@@@@ -3520,6 +3829,7 @@@@ jint os::init_2(void)
d778 1
a778 1
@@@@ -3539,8 +3849,10 @@@@ jint os::init_2(void)
d789 1
a789 1
@@@@ -3587,11 +3899,15 @@@@ void os::make_polling_page_readable(void) {
d805 1
a805 1
@@@@ -3633,6 +3949,9 @@@@ ExtendedPC os::get_thread_pc(Thread* thread) {
d815 1
a815 1
@@@@ -3648,6 +3967,7 @@@@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
d823 1
a823 1
@@@@ -3783,17 +4103,17 @@@@ int os::create_binary_file(const char* path, bool rewr
d844 1
a844 1
@@@@ -3843,6 +4163,7 @@@@ bool os::unmap_memory(char* addr, size_t bytes) {
d852 1
a852 1
@@@@ -3854,6 +4175,7 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d860 1
a860 1
@@@@ -3863,39 +4185,48 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d909 1
a909 1
@@@@ -3984,6 +4315,7 @@@@ static jlong slow_thread_cpu_time(Thread *thread, bool
d917 1
a917 1
@@@@ -4000,7 +4332,11 @@@@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
d929 10
a938 1
@@@@ -4169,7 +4505,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
d947 1
a947 1
@@@@ -4227,10 +4563,10 @@@@ int os::PlatformEvent::park(jlong millis) {
d960 62
@


1.2
log
@. update to b12 sources (just building hotspot)
. adjust SIGRTMIN SIGRTMAX defines - from Jung-uk Kim <jkim@@freebsd.org>
. use SIGSEGV || SIGBUS in amd64 signal handling code
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.1.1.1 2007/05/08 17:06:19 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Tue May  8 15:33:11 2007
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Tue May  8 15:38:54 2007
d928 2
a929 2
 #ifdef JVMPI_SUPPORT
@@@@ -4176,7 +4512,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
d938 1
a938 1
@@@@ -4234,10 +4570,10 @@@@ int os::PlatformEvent::park(jlong millis) {
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Mon Apr 16 08:42:36 2007
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Mon Apr 16 08:42:39 2007
d276 1
a276 1
@@@@ -735,8 +881,13 @@@@ static void *java_start(Thread *thread) {
d286 5
a291 1
 
d294 2
a295 1
@@@@ -818,17 +969,22 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d318 1
a318 1
@@@@ -842,7 +998,9 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d328 1
a328 1
@@@@ -858,9 +1016,11 @@@@ bool os::create_thread(Thread* thread, ThreadType thr_
d340 1
a340 1
@@@@ -898,7 +1058,11 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d352 1
a352 1
@@@@ -909,6 +1073,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d355 1
a355 1
   
d357 4
a360 4
   if (os::Bsd::is_initial_thread()) {
     // If current thread is initial thread, its stack is mapped on demand,
     // see notes about MAP_GROWSDOWN. Here we try to force kernel to map
@@@@ -928,6 +1093,7 @@@@ bool os::create_attached_thread(JavaThread* thread) {
d368 1
a368 1
@@@@ -986,6 +1152,7 @@@@ extern "C" Thread* get_thread() {
d376 1
a376 1
@@@@ -1213,6 +1380,7 @@@@ void os::Bsd::capture_initial_stack(size_t max_size) {
d384 1
a384 1
@@@@ -1245,7 +1413,18 @@@@ jlong os::javaTimeMillis() {
d403 1
a403 1
@@@@ -1280,7 +1459,9 @@@@ void os::Bsd::clock_init() {
d413 1
a413 1
@@@@ -1319,6 +1500,7 @@@@ void os::Bsd::fast_thread_clock_init() {
d421 1
a421 1
@@@@ -1499,6 +1681,23 @@@@ bool os::dll_address_to_function_name(address addr, ch
d445 1
a445 1
@@@@ -1573,6 +1772,7 @@@@ bool os::dll_address_to_library_name(address addr, cha
d453 1
a453 1
@@@@ -1630,6 +1830,18 @@@@ void * os::dll_load(const char *filename, char *ebuf, 
d472 1
a472 1
@@@@ -1732,7 +1944,41 @@@@ bool _print_ascii_file(const char* filename, outputStr
d514 1
a514 1
@@@@ -1741,6 +1987,7 @@@@ void os::print_dll_info(outputStream *st) {
d522 1
a522 1
@@@@ -1773,6 +2020,7 @@@@ void os::print_os_info(outputStream* st) {
d530 1
a530 1
@@@@ -1787,6 +2035,7 @@@@ void os::print_os_info(outputStream* st) {
d538 1
a538 1
@@@@ -1812,6 +2061,7 @@@@ void os::print_os_info(outputStream* st) {
d546 1
a546 1
@@@@ -1824,6 +2074,7 @@@@ void os::print_os_info(outputStream* st) {
d554 1
a554 1
@@@@ -1831,18 +2082,22 @@@@ void os::print_memory_info(outputStream* st) {
d577 1
a577 1
@@@@ -2146,10 +2401,15 @@@@ void bsd_wrap_code(char* base, size_t size) {
d593 1
a593 1
@@@@ -2170,10 +2430,15 @@@@ size_t os::numa_get_leaf_groups(int *ids, size_t size)
d609 1
a609 1
@@@@ -2262,6 +2527,9 @@@@ bool os::unguard_memory(char* addr, size_t size) {
d619 1
a619 1
@@@@ -2309,6 +2577,7 @@@@ bool os::large_page_init() {
d627 1
a627 1
@@@@ -2479,9 +2748,11 @@@@ char* os::attempt_reserve_memory_at(size_t bytes, char
d640 1
a640 1
@@@@ -2600,9 +2871,28 @@@@ void os::loop_breaker(int attempts) {
d669 1
a669 1
@@@@ -2617,6 +2907,7 @@@@ int os::java_to_os_priority[MaxPriority + 1] = {
d677 1
a677 1
@@@@ -2636,8 +2927,17 @@@@ static int prio_init() {
d695 1
a695 1
@@@@ -2647,7 +2947,11 @@@@ OSReturn os::get_native_priority(const Thread* const t
d707 1
a707 1
@@@@ -2757,7 +3061,7 @@@@ static int SR_initialize() {
d716 1
a716 1
@@@@ -3121,6 +3425,7 @@@@ void os::Bsd::install_signal_handlers() {
d724 1
a724 1
@@@@ -3135,6 +3440,7 @@@@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
d732 1
a732 1
@@@@ -3356,16 +3662,16 @@@@ void os::init(void) {
d752 1
a752 1
@@@@ -3387,7 +3693,9 @@@@ extern "C" {
d762 1
a762 1
@@@@ -3436,6 +3744,7 @@@@ jint os::init_2(void)
d770 1
a770 1
@@@@ -3444,6 +3753,7 @@@@ jint os::init_2(void)
d778 1
a778 1
@@@@ -3463,8 +3773,10 @@@@ jint os::init_2(void)
d789 1
a789 1
@@@@ -3511,11 +3823,15 @@@@ void os::make_polling_page_readable(void) {
d805 1
a805 1
@@@@ -3557,6 +3873,9 @@@@ ExtendedPC os::get_thread_pc(Thread* thread) {
d815 1
a815 1
@@@@ -3572,6 +3891,7 @@@@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
d823 1
a823 1
@@@@ -3707,17 +4027,17 @@@@ int os::create_binary_file(const char* path, bool rewr
d844 1
a844 1
@@@@ -3767,6 +4087,7 @@@@ bool os::unmap_memory(char* addr, size_t bytes) {
d852 1
a852 1
@@@@ -3778,6 +4099,7 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d860 1
a860 1
@@@@ -3787,39 +4109,48 @@@@ static clockid_t thread_cpu_clockid(Thread* thread) {
d909 1
a909 1
@@@@ -3908,6 +4239,7 @@@@ static jlong slow_thread_cpu_time(Thread *thread, bool
d917 1
a917 1
@@@@ -3924,7 +4256,11 @@@@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
d928 2
a929 2
 bool os::thread_is_running(JavaThread* tp) {
@@@@ -4098,7 +4434,7 @@@@ void os::PlatformEvent::park() {       // AKA "down()"
d938 1
a938 1
@@@@ -4156,10 +4492,10 @@@@ int os::PlatformEvent::park(jlong millis) {
@


1.1.1.1
log
@Initial import of jdk 1.7 (a.k.a. OpenJDK 7) work in progress. So far Sun
has released the hotspot portion of 1.7 under GPLv2. j2se and deploy
(plugin & webstart) will come later. No packages yet since j2se is copied
in from 1.5.

Note: hotspot for BSD in previous versions of the jdk were based on a
mixture of Solaris code and Linux code (for amd64). In this version I have
selected Linux as the base and only ported of small parts of the Solaris
code as needed. Using Linux code as the base has significantly reduced the
code divergence for BSD support and should make maintaining the port
easier.

okay ian@@, go for it espie@@
@
text
@@
