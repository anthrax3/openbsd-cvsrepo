head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@# @;


1.7
date	2014.04.30.13.21.00;	author kurt;	state dead;
branches;
next	1.6;

1.6
date	2013.10.16.15.36.49;	author bluhm;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.22.20.26.48;	author kurt;	state dead;
branches;
next	1.4;

1.4
date	2011.01.11.15.47.50;	author kurt;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.23.03.03.25;	author kurt;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.04.23.25.16;	author kurt;	state Exp;
branches;
next	1.1;

1.1
date	2008.03.19.18.05.46;	author kurt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@- Update to 7u55 including several security updates
- Remove patches included in upstream repository
- Update cacerts (from FreeBSD)
- Add build-bootjdk makefile target in prep for new bootstrap
- Allow changes to LD_LIBRARY_PATH so that new bootstrap will work
okay sthen@@, dcoppa@@, ian@@
@
text
@$OpenBSD: patch-jdk_src_solaris_native_java_net_NetworkInterface_c,v 1.6 2013/10/16 15:36:49 bluhm Exp $
--- jdk/src/solaris/native/java/net/NetworkInterface.c.orig	Sat Sep  7 17:12:52 2013
+++ jdk/src/solaris/native/java/net/NetworkInterface.c	Sat Sep  7 18:53:36 2013
@@@@ -65,6 +65,7 @@@@
 #include <net/if_var.h>
 #elif defined(__OpenBSD__)
 #include <netinet/if_ether.h>
+#include <netinet6/in6_var.h>
 #elif defined(__NetBSD__)
 #include <net/if_ether.h>
 #endif
@


1.6
log
@Including the header file netinet6/in6_var.h from netinet/in_var.h
automatically is bad.  To change that, a few ports must be adapted.
Do an explicit #include <netinet6/in6_var.h> when it is needed.
OK ajacoutot@@

Next try to commit this file after a fresh cvs -d cvs:/cvs add.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.5
log
@Update devel/jdk/1.7 to b147 / non-beta
- Remove Early Access now that jdk 1.7 is final
- Use a patch set for all patches from upstream repository:
  http://hg.openjdk.java.net/bsd-port/bsd-port
- Set milestone and build number to fcs b00 to match Oracle.
- Update cacerts file.
- Install unlimited crypto policy.
- Add DIST_SUBDIR=jdk.
- Include patches from icedtea-web for applet hole from
  Landry Breuil <landry@@openbsd.org> via FreeBSD OpenJDK7 port
- Include fix for Oracle bug "7070134: Hotspot crashes with
  sigsegv from PorterStemmer":
  http://hg.openjdk.java.net/hsx/hotspot-comp/hotspot/rev/4e761e7e6e12
okay landry@@ jasper@@
@
text
@d1 10
a10 15
$OpenBSD: patch-jdk_src_solaris_native_java_net_NetworkInterface_c,v 1.4 2011/01/11 15:47:50 kurt Exp $
--- jdk/src/solaris/native/java/net/NetworkInterface.c.orig	Fri Aug 13 03:22:13 2010
+++ jdk/src/solaris/native/java/net/NetworkInterface.c	Tue Oct 26 11:04:25 2010
@@@@ -26,6 +26,9 @@@@
 
 #include <errno.h>
 #include <strings.h>
+#if defined(_ALLBSD_SOURCE) && defined(__OpenBSD__)
+#include <sys/types.h>
+#endif
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
@@@@ -54,6 +57,23 @@@@
 #define _PATH_PROCNET_IFINET6           "/proc/net/if_inet6"
a11 344
 
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/sockio.h>
+#if defined(__FreeBSD__) || defined(__APPLE__)
+#include <net/ethernet.h>
+#include <net/if_var.h>
+#elif defined(__OpenBSD__)
+#include <netinet/if_ether.h>
+#elif defined(__NetBSD__)
+#include <net/if_ether.h>
+#endif
+#include <net/if_dl.h>
+#include <netinet/in_var.h>
+#include <ifaddrs.h>
+#endif
+
 #include "jvm.h"
 #include "jni_util.h"
 #include "net_util.h"
@@@@ -821,11 +841,11 @@@@ netif *addif(JNIEnv *env, int sock, const char * if_na
     netif *currif = ifs, *parent;
     netaddr *addrP;
 
-    #ifdef __solaris__
+#ifdef LIFNAMSIZ
     char name[LIFNAMSIZ],  vname[LIFNAMSIZ];
-    #else
+#else
     char name[IFNAMSIZ],  vname[IFNAMSIZ];
-    #endif
+#endif
 
     char  *name_colonP;
     int mask;
@@@@ -1649,3 +1669,307 @@@@ static int getFlags(int sock, const char *ifname) {
 #endif
 
 
+/** BSD **/
+#ifdef _ALLBSD_SOURCE
+/* Open socket for further ioct calls, try v4 socket first and
+ * if it falls return v6 socket
+ */
+
+#ifdef AF_INET6
+static int openSocketWithFallback(JNIEnv *env, const char *ifname){
+    int sock;
+    struct ifreq if2;
+
+     if ((sock = JVM_Socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+         if (errno == EPROTONOSUPPORT){
+              if ( (sock = JVM_Socket(AF_INET6, SOCK_DGRAM, 0)) < 0 ){
+                 NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException", "IPV6 Socket creation failed");
+                 return -1;
+              }
+         }
+         else{ // errno is not NOSUPPORT
+             NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException", "IPV4 Socket creation failed");
+             return -1;
+         }
+   }
+
+   return sock;
+}
+
+#else
+static int openSocketWithFallback(JNIEnv *env, const char *ifname){
+    return openSocket(env,AF_INET);
+}
+#endif
+
+/*
+ * Enumerates and returns all IPv4 interfaces
+ */
+static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
+    struct ifaddrs *ifa, *origifa;
+
+    if (getifaddrs(&origifa) != 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                         "getifaddrs() function failed");
+	return ifs;
+    }
+
+    for (ifa = origifa; ifa != NULL; ifa = ifa->ifa_next) {
+
+	/*
+	 * Skip non-AF_INET entries.
+	 */
+	if (ifa->ifa_addr == NULL || ifa->ifa_addr->sa_family != AF_INET)
+	    continue;
+
+	/*
+	 * Add to the list.
+	 */
+	ifs = addif(env, sock, ifa->ifa_name, ifs, ifa->ifa_addr, AF_INET, 0);
+
+	/*
+	 * If an exception occurred then free the list.
+	 */
+	if ((*env)->ExceptionOccurred(env)) {
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+    }
+
+    /*
+     * Free socket and buffer
+     */
+    freeifaddrs(origifa);
+    return ifs;
+}
+
+
+/*
+ * Enumerates and returns all IPv6 interfaces on Linux
+ */
+
+#ifdef AF_INET6
+/*
+ * Determines the prefix on BSD for IPv6 interfaces.
+ */
+static
+int prefix(void *val, int size) {
+    u_char *name = (u_char *)val;
+    int byte, bit, plen = 0;
+
+    for (byte = 0; byte < size; byte++, plen += 8)
+        if (name[byte] != 0xff)
+            break;
+    if (byte == size)
+        return (plen);
+    for (bit = 7; bit != 0; bit--, plen++)
+        if (!(name[byte] & (1 << bit)))
+            break;
+    for (; bit != 0; bit--)
+        if (name[byte] & (1 << bit))
+            return (0);
+    byte++;
+    for (; byte < size; byte++)
+        if (name[byte])
+            return (0);
+    return (plen);
+}
+
+/*
+ * Enumerates and returns all IPv6 interfaces on BSD
+ */
+static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
+    struct ifaddrs *ifa, *origifa;
+    struct sockaddr_in6 *sin6;
+    struct in6_ifreq ifr6;
+
+    if (getifaddrs(&origifa) != 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                         "getifaddrs() function failed");
+	return ifs;
+    }
+
+    for (ifa = origifa; ifa != NULL; ifa = ifa->ifa_next) {
+
+	/*
+	 * Skip non-AF_INET6 entries.
+	 */
+	if (ifa->ifa_addr == NULL || ifa->ifa_addr->sa_family != AF_INET6)
+	    continue;
+
+	memset(&ifr6, 0, sizeof(ifr6));
+	strlcpy(ifr6.ifr_name, ifa->ifa_name, sizeof(ifr6.ifr_name));
+	memcpy(&ifr6.ifr_addr, ifa->ifa_addr, MIN(sizeof(ifr6.ifr_addr), ifa->ifa_addr->sa_len));
+
+	if (ioctl(sock, SIOCGIFNETMASK_IN6, (caddr_t)&ifr6) < 0) {
+	    NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                             "ioctl SIOCGIFNETMASK_IN6 failed");
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+
+	/* Add to the list.  */
+	sin6 = (struct sockaddr_in6 *)&ifr6.ifr_addr;
+	ifs = addif(env, sock, ifa->ifa_name, ifs, ifa->ifa_addr, AF_INET6,
+		    prefix(&sin6->sin6_addr, sizeof(struct in6_addr)));
+
+	/* If an exception occurred then free the list.  */
+	if ((*env)->ExceptionOccurred(env)) {
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+    }
+
+    /*
+     * Free socket and ifaddrs buffer
+     */
+    freeifaddrs(origifa);
+    return ifs;
+}
+#endif
+
+static int getIndex(int sock, const char *name){
+#ifdef __FreeBSD__
+     /*
+      * Try to get the interface index
+      * (Not supported on Solaris 2.6 or 7)
+      */
+    struct ifreq if2;
+    strcpy(if2.ifr_name, name);
+
+    if (ioctl(sock, SIOCGIFINDEX, (char *)&if2) < 0) {
+        return -1;
+    }
+
+    return if2.ifr_index;
+#else
+    /*
+     * Try to get the interface index using BSD specific if_nametoindex
+     */
+    int index = if_nametoindex(name);
+    return (index == 0) ? -1 : index;
+#endif
+}
+
+/**
+ * Returns the IPv4 broadcast address of a named interface, if it exists.
+ * Returns 0 if it doesn't have one.
+ */
+static struct sockaddr *getBroadcast(JNIEnv *env, int sock, const char *ifname, struct sockaddr *brdcast_store) {
+  struct sockaddr *ret = NULL;
+  struct ifreq if2;
+
+  memset((char *) &if2, 0, sizeof(if2));
+  strcpy(if2.ifr_name, ifname);
+
+  /* Let's make sure the interface does have a broadcast address */
+  if (ioctl(sock, SIOCGIFFLAGS, (char *)&if2) < 0) {
+      NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "IOCTL SIOCGIFFLAGS failed");
+      return ret;
+  }
+
+  if (if2.ifr_flags & IFF_BROADCAST) {
+      /* It does, let's retrieve it*/
+      if (ioctl(sock, SIOCGIFBRDADDR, (char *)&if2) < 0) {
+          NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "IOCTL SIOCGIFBRDADDR failed");
+	  return ret;
+      }
+
+      ret = brdcast_store;
+      memcpy(ret, &if2.ifr_broadaddr, sizeof(struct sockaddr));
+  }
+
+  return ret;
+}
+
+/**
+ * Returns the IPv4 subnet prefix length (aka subnet mask) for the named
+ * interface, if it has one, otherwise return -1.
+ */
+static short getSubnet(JNIEnv *env, int sock, const char *ifname) {
+    unsigned int mask;
+    short ret;
+    struct ifreq if2;
+
+    memset((char *) &if2, 0, sizeof(if2));
+    strcpy(if2.ifr_name, ifname);
+
+    if (ioctl(sock, SIOCGIFNETMASK, (char *)&if2) < 0) {
+        NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "IOCTL SIOCGIFNETMASK failed");
+        return -1;
+    }
+
+    mask = ntohl(((struct sockaddr_in*)&(if2.ifr_addr))->sin_addr.s_addr);
+    ret = 0;
+    while (mask) {
+       mask <<= 1;
+       ret++;
+    }
+
+    return ret;
+}
+
+/**
+ * Get the Hardware address (usually MAC address) for the named interface.
+ * return puts the data in buf, and returns the length, in byte, of the
+ * MAC address. Returns -1 if there is no hardware address on that interface.
+ */
+static int getMacAddress(JNIEnv *env, int sock, const char* ifname, const struct in_addr* addr, unsigned char *buf) {
+    struct ifaddrs *ifa0, *ifa;
+    struct sockaddr *saddr;
+    int i;
+
+    /* Grab the interface list */
+    if (!getifaddrs(&ifa0)) {
+        /* Cycle through the interfaces */
+        for (i = 0, ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next, i++) {
+            saddr = ifa->ifa_addr;
+            /* Link layer contains the MAC address */
+            if (saddr->sa_family == AF_LINK && !strcmp(ifname, ifa->ifa_name)) {
+                struct sockaddr_dl *sadl = (struct sockaddr_dl *) saddr;
+                /* Check the address is the correct length */
+                if (sadl->sdl_alen == ETHER_ADDR_LEN) {
+                    memcpy(buf, (sadl->sdl_data + sadl->sdl_nlen), ETHER_ADDR_LEN);
+                    freeifaddrs(ifa0);
+                    return ETHER_ADDR_LEN;
+                }
+            }
+        }
+        freeifaddrs(ifa0);
+    }
+
+    return -1;
+}
+
+static int getMTU(JNIEnv *env, int sock,  const char *ifname) {
+    struct ifreq if2;
+
+    memset((char *) &if2, 0, sizeof(if2));
+    strcpy(if2.ifr_name, ifname);
+
+    if (ioctl(sock, SIOCGIFMTU, (char *)&if2) < 0) {
+        NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "IOCTL SIOCGIFMTU failed");
+        return -1;
+    }
+
+    return  if2.ifr_mtu;
+}
+
+static int getFlags(int sock, const char *ifname) {
+  struct ifreq if2;
+  int ret = -1;
+
+  memset((char *) &if2, 0, sizeof(if2));
+  strcpy(if2.ifr_name, ifname);
+
+  if (ioctl(sock, SIOCGIFFLAGS, (char *)&if2) < 0){
+      return -1;
+  }
+
+  return if2.ifr_flags;
+}
+
+#endif
@


1.4
log
@Update to early access build 122. okay jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-jdk_src_solaris_native_java_net_NetworkInterface_c,v 1.3 2009/05/23 03:03:25 kurt Exp $
@


1.3
log
@- update from early access b43 to b59
- sync patches with OpenJDK's bsd_port project
- require a pre-installed package for native_bootstrap
- The new 1.7 class java.nio.channels.spi.AsynchronousChannelProvider
  is not implemented yet on BSD.
- The new 1.7 package java.nio.sctp is not included and not supported on
  OpenBD
@
text
@d1 4
a4 6
$OpenBSD: patch-jdk_src_solaris_native_java_net_NetworkInterface_c,v 1.2 2009/01/04 23:25:16 kurt Exp $
--- jdk/src/solaris/native/java/net/NetworkInterface.c.orig	Fri May  8 03:35:07 2009
+++ jdk/src/solaris/native/java/net/NetworkInterface.c	Mon May 18 19:36:07 2009
@@@@ -23,13 +23,13 @@@@
  * have any questions.
  */
a5 2
+#include <sys/types.h>
+#include <sys/socket.h>
d8 3
d14 2
a15 8
-#include <sys/types.h>
-#include <sys/socket.h>
 #include <arpa/inet.h>
 #include <net/if.h>
 #include <net/if_arp.h>
@@@@ -47,6 +47,21 @@@@
 #else
 #include <sys/sockio.h>
d17 1
d21 1
d34 7
d42 8
a49 4
 #ifdef __linux__
 #define ifr_index ifr_ifindex
@@@@ -583,6 +598,7 @@@@ static netif *enumInterfaces(JNIEnv *env) {
 }
d51 4
a55 7
+#if !defined(_ALLBSD_SOURCE)
 /*
  * Enumerates and returns all IPv4 interfaces
  */
@@@@ -693,7 +709,177 @@@@ static netif *enumIPv4Interfaces(JNIEnv *env, netif *i
     return ifs;
 }
d57 33
a89 2
+#else /* _ALLBSD_SOURCE */
+ 
a91 3
+ *
+ * WARNING! Make sure that it's correctly synchronized on future JDK
+ * versions imports!
d93 1
a93 3
+static netif *enumIPv4Interfaces(JNIEnv *env, netif *ifs)
+{
+    int sock;
a94 13
 
+    sock = JVM_Socket(AF_INET, SOCK_DGRAM, 0);
+    if (sock < 0) {
+	/*
+	 * If EPROTONOSUPPORT is returned it means we don't have
+	 * IPv4 support so don't throw an exception.
+	 */
+	if (errno != EPROTONOSUPPORT) {
+	    NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                             "Socket creation failed");
+	}
+	return ifs;
+    }
a98 1
+	close(sock);
a111 3
+	 *
+	 * BSDNOTE: in order to optimize code, interface index detection
+	 * logic was added directly to addif().
d113 1
a113 2
+	ifs = addif(env, ifs, ifa->ifa_name, (-1), AF_INET,
+		    ifa->ifa_addr, sizeof(struct sockaddr_in), 0);
a118 1
+	    close(sock);
a127 1
+    close(sock);
d132 6
a137 1
+#if defined(AF_INET6)
d165 1
a165 4
+ * Enumerates and returns all IPv6 interfaces on FreeBSD
+ *
+ * BSDNOTE: it's done in same as IPv4 enumeration and should be carefully
+ *          reviewed with each JDK update (according to Solaris/Linux version)
d167 1
a167 3
+static netif *enumIPv6Interfaces(JNIEnv *env, netif *ifs) {
+
+    int sock;
a171 8
+    // Open IPv6 UDP socket.
+    sock = JVM_Socket(AF_INET6, SOCK_DGRAM, 0);
+    if (sock < 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                     "Failed to create IPv6 socket");
+        return ifs;
+    }
+
a174 1
+	close(sock);
a192 1
+	    close(sock);
d200 1
a200 2
+	ifs = addif(env, ifs, ifa->ifa_name, (-1), AF_INET6,
+	            ifa->ifa_addr, sizeof(struct sockaddr_in6),
a204 1
+	    close(sock);
a213 1
+    close(sock);
d217 1
a217 1
+#endif /* AF_INET6 */
d219 12
a230 1
+#endif /* !_ALLBSD_SOURCE */
d232 1
a232 11
 #if defined(__solaris__) && defined(AF_INET6)
 /*
  * Enumerates and returns all IPv6 interfaces on Solaris
@@@@ -1036,7 +1222,13 @@@@ netif *addif(JNIEnv *env, netif *ifs, char *if_name, i
             JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
             return ifs;
         }
+#if defined(_ALLBSD_SOURCE)
+	currif->index = if_nametoindex(name);
+	if (currif->index == 0)
+	    currif->index = -1;
d234 5
a238 1
         currif->index = index;
d240 85
a324 25
         currif->addr = NULL;
         currif->childs = NULL;
         currif->virtual = isVirtual;
@@@@ -1347,6 +1539,31 @@@@ int getMacAddress(JNIEnv *env, const struct in_addr* a
    * All bytes to 0 means no hardware address.
    */
   return -1;
+#elif defined(_ALLBSD_SOURCE)
+  struct ifaddrs *ifa0, *ifa;
+  struct sockaddr *saddr;
+  int i;
+
+  /* Grab the interface list */
+  if (!getifaddrs(&ifa0)) {
+    /* Cycle through the interfaces */
+    for (i = 0, ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next, i++) {
+      saddr = ifa->ifa_addr;
+      /* Link layer contains the MAC address */
+      if (saddr->sa_family == AF_LINK && !strcmp(ifname, ifa->ifa_name)) {
+        struct sockaddr_dl *sadl = (struct sockaddr_dl *) saddr;
+        /* Check the address is the correct length */
+        if (sadl->sdl_alen == ETHER_ADDR_LEN) {
+           memcpy(buf, (sadl->sdl_data + sadl->sdl_nlen), ETHER_ADDR_LEN);
+           freeifaddrs(ifa0);
+           return ETHER_ADDR_LEN;
d326 15
a340 1
+      }
d342 13
a354 1
+    freeifaddrs(ifa0);
d357 4
a360 13
+  return -1;
 #else
   struct arpreq arpreq;
   struct sockaddr_in* sin;
@@@@ -1512,7 +1729,7 @@@@ JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_
                                  "Socket creation failed");
   } else {
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *) &if2, 0, sizeof(if2));
     strcpy(if2.ifr_name, name_utf);
 
@


1.2
log
@Update to early access build 42:
- sync/regen patches
- use os_bsd_x86.cpp from OpenJDK bsd-java repository plus
  Greg Lewis's fixes posted to the bsd-port-dev list
- use Xiaobin Lu's datatype corrections from OpenJDK bug
  6787106 + additional datatype corrections from me.
- use Vladimir Kozlov's bug fix from OpenJDK bug 6782820
- remove obsolete IcedTea awt binary plugs and update binary
  plug distfile
- correctly define DEVTOOLS_PATH for bsd and verify + correct
  Defs-utils.gmk locations for bsd utilities
@
text
@d1 3
a3 3
$OpenBSD: patch-jdk_src_solaris_native_java_net_NetworkInterface_c,v 1.1 2008/03/19 18:05:46 kurt Exp $
--- jdk/src/solaris/native/java/net/NetworkInterface.c.orig	Thu Sep 11 03:44:53 2008
+++ jdk/src/solaris/native/java/net/NetworkInterface.c	Fri Sep 12 17:45:12 2008
d20 1
a20 1
@@@@ -47,6 +47,19 @@@@
d27 1
a27 1
+#if defined(__FreeBSD__)
d32 2
d42 1
a42 1
@@@@ -583,6 +596,7 @@@@ static netif *enumInterfaces(JNIEnv *env) {
d50 1
a50 1
@@@@ -693,7 +707,177 @@@@ static netif *enumIPv4Interfaces(JNIEnv *env, netif *i
d228 1
a228 1
@@@@ -1010,7 +1194,13 @@@@ netif *addif(JNIEnv *env, netif *ifs, char *if_name, i
d242 1
a242 1
@@@@ -1321,6 +1511,31 @@@@ int getMacAddress(JNIEnv *env, const struct in_addr* a
d274 1
a274 1
@@@@ -1486,7 +1701,7 @@@@ JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_
@


1.1
log
@- switch to GPLv2 w/CLASSPATH exception licensed openjdk7 code
- update to early access build 24
- Use GPLv2 licensed binary plugs from the IcedTea project and parts of
  IcedTea's icedtea-copy-plugs.patch & icedtea-graphics.patch.
  For more info see:
    http://icedtea.classpath.org/wiki/Main_Page
- Enable packages since we're fully GPLv2 based now, but still not
  hooked up to bulk builds just yet.
@
text
@d1 3
a3 3
$OpenBSD$
--- jdk/src/solaris/native/java/net/NetworkInterface.c.orig	Sat Dec  1 00:00:00 2007
+++ jdk/src/solaris/native/java/net/NetworkInterface.c	Tue Feb 26 18:50:58 2008
d40 1
a40 1
@@@@ -584,6 +597,7 @@@@ static netif *enumInterfaces(JNIEnv *env) {
d48 1
a48 1
@@@@ -694,7 +708,177 @@@@ static netif *enumIPv4Interfaces(JNIEnv *env, netif *i
d226 1
a226 1
@@@@ -1014,7 +1198,13 @@@@ netif *addif(JNIEnv *env, netif *ifs, char *if_name, i
d240 1
a240 1
@@@@ -1302,6 +1492,31 @@@@ int getMacAddress(JNIEnv *env, const struct in_addr* a
d272 1
a272 1
@@@@ -1467,7 +1682,7 @@@@ JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_
@

