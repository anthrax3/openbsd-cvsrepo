head	1.6;
access;
symbols
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2011.09.22.20.26.47;	author kurt;	state dead;
branches;
next	1.5;

1.5
date	2011.01.11.15.47.49;	author kurt;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.23.03.03.25;	author kurt;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.17.11.37.42;	author kurt;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.04.23.25.16;	author kurt;	state Exp;
branches;
next	1.1;

1.1
date	2008.03.19.18.05.43;	author kurt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update devel/jdk/1.7 to b147 / non-beta
- Remove Early Access now that jdk 1.7 is final
- Use a patch set for all patches from upstream repository:
  http://hg.openjdk.java.net/bsd-port/bsd-port
- Set milestone and build number to fcs b00 to match Oracle.
- Update cacerts file.
- Install unlimited crypto policy.
- Add DIST_SUBDIR=jdk.
- Include patches from icedtea-web for applet hole from
  Landry Breuil <landry@@openbsd.org> via FreeBSD OpenJDK7 port
- Include fix for Oracle bug "7070134: Hotspot crashes with
  sigsegv from PorterStemmer":
  http://hg.openjdk.java.net/hsx/hotspot-comp/hotspot/rev/4e761e7e6e12
okay landry@@ jasper@@
@
text
@$OpenBSD: patch-hotspot_src_os_cpu_bsd_x86_vm_os_bsd_x86_cpp,v 1.5 2011/01/11 15:47:49 kurt Exp $
--- hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp.orig	Tue Jan  4 18:25:16 2011
+++ hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	Tue Jan  4 19:03:34 2011
@@@@ -44,23 +44,202 @@@@
 # include <sys/wait.h>
 # include <pwd.h>
 # include <poll.h>
+#ifndef __OpenBSD__
 # include <ucontext.h>
-# include <fpu_control.h>
+#endif
 
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__) && !defined(__NetBSD__)
+# include <pthread_np.h>
+#endif
+
 #ifdef AMD64
-#define REG_SP REG_RSP
-#define REG_PC REG_RIP
-#define REG_FP REG_RBP
 #define SPELL_REG_SP "rsp"
 #define SPELL_REG_FP "rbp"
 #else
-#define REG_SP REG_UESP
-#define REG_PC REG_EIP
-#define REG_FP REG_EBP
 #define SPELL_REG_SP "esp"
 #define SPELL_REG_FP "ebp"
 #endif // AMD64
 
+#ifdef __FreeBSD__
+# define context_trapno uc_mcontext.mc_trapno
+# ifdef AMD64
+#  define context_pc uc_mcontext.mc_rip
+#  define context_sp uc_mcontext.mc_rsp
+#  define context_fp uc_mcontext.mc_rbp
+#  define context_rip uc_mcontext.mc_rip
+#  define context_rsp uc_mcontext.mc_rsp
+#  define context_rbp uc_mcontext.mc_rbp
+#  define context_rax uc_mcontext.mc_rax
+#  define context_rbx uc_mcontext.mc_rbx
+#  define context_rcx uc_mcontext.mc_rcx
+#  define context_rdx uc_mcontext.mc_rdx
+#  define context_rsi uc_mcontext.mc_rsi
+#  define context_rdi uc_mcontext.mc_rdi
+#  define context_r8  uc_mcontext.mc_r8
+#  define context_r9  uc_mcontext.mc_r9
+#  define context_r10 uc_mcontext.mc_r10
+#  define context_r11 uc_mcontext.mc_r11
+#  define context_r12 uc_mcontext.mc_r12
+#  define context_r13 uc_mcontext.mc_r13
+#  define context_r14 uc_mcontext.mc_r14
+#  define context_r15 uc_mcontext.mc_r15
+#  define context_flags uc_mcontext.mc_flags
+#  define context_err uc_mcontext.mc_err
+# else
+#  define context_pc uc_mcontext.mc_eip
+#  define context_sp uc_mcontext.mc_esp
+#  define context_fp uc_mcontext.mc_ebp
+#  define context_eip uc_mcontext.mc_eip
+#  define context_esp uc_mcontext.mc_esp
+#  define context_eax uc_mcontext.mc_eax
+#  define context_ebx uc_mcontext.mc_ebx
+#  define context_ecx uc_mcontext.mc_ecx
+#  define context_edx uc_mcontext.mc_edx
+#  define context_ebp uc_mcontext.mc_ebp
+#  define context_esi uc_mcontext.mc_esi
+#  define context_edi uc_mcontext.mc_edi
+#  define context_eflags uc_mcontext.mc_eflags
+#  define context_trapno uc_mcontext.mc_trapno
+# endif
+#endif
+
+#ifdef __APPLE__ 
+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
+  // 10.5 UNIX03 member name prefixes
+  #define DU3_PREFIX(s, m) __ ## s.__ ## m
+# else
+  #define DU3_PREFIX(s, m) s ## . ## m
+# endif
+
+# ifdef AMD64
+#  define context_pc context_rip
+#  define context_sp context_rsp
+#  define context_fp context_rbp
+#  define context_rip uc_mcontext->DU3_PREFIX(ss,rip)
+#  define context_rsp uc_mcontext->DU3_PREFIX(ss,rsp)
+#  define context_rax uc_mcontext->DU3_PREFIX(ss,rax)
+#  define context_rbx uc_mcontext->DU3_PREFIX(ss,rbx)
+#  define context_rcx uc_mcontext->DU3_PREFIX(ss,rcx)
+#  define context_rdx uc_mcontext->DU3_PREFIX(ss,rdx)
+#  define context_rbp uc_mcontext->DU3_PREFIX(ss,rbp)
+#  define context_rsi uc_mcontext->DU3_PREFIX(ss,rsi)
+#  define context_rdi uc_mcontext->DU3_PREFIX(ss,rdi)
+#  define context_r8  uc_mcontext->DU3_PREFIX(ss,r8)
+#  define context_r9  uc_mcontext->DU3_PREFIX(ss,r9)
+#  define context_r10 uc_mcontext->DU3_PREFIX(ss,r10)
+#  define context_r11 uc_mcontext->DU3_PREFIX(ss,r11)
+#  define context_r12 uc_mcontext->DU3_PREFIX(ss,r12)
+#  define context_r13 uc_mcontext->DU3_PREFIX(ss,r13)
+#  define context_r14 uc_mcontext->DU3_PREFIX(ss,r14)
+#  define context_r15 uc_mcontext->DU3_PREFIX(ss,r15)
+#  define context_flags uc_mcontext->DU3_PREFIX(ss,rflags)
+#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)
+#  define context_err uc_mcontext->DU3_PREFIX(es,err)
+# else
+#  define context_pc context_eip
+#  define context_sp context_esp
+#  define context_fp context_ebp
+#  define context_eip uc_mcontext->DU3_PREFIX(ss,eip)
+#  define context_esp uc_mcontext->DU3_PREFIX(ss,esp)
+#  define context_eax uc_mcontext->DU3_PREFIX(ss,eax)
+#  define context_ebx uc_mcontext->DU3_PREFIX(ss,ebx)
+#  define context_ecx uc_mcontext->DU3_PREFIX(ss,ecx)
+#  define context_edx uc_mcontext->DU3_PREFIX(ss,edx)
+#  define context_ebp uc_mcontext->DU3_PREFIX(ss,ebp)
+#  define context_esi uc_mcontext->DU3_PREFIX(ss,esi)
+#  define context_edi uc_mcontext->DU3_PREFIX(ss,edi)
+#  define context_eflags uc_mcontext->DU3_PREFIX(ss,eflags)
+#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)
+# endif
+#endif
+
+#ifdef __OpenBSD__
+# define context_trapno sc_trapno
+# ifdef AMD64
+#  define context_pc sc_rip
+#  define context_sp sc_rsp
+#  define context_fp sc_rbp
+#  define context_rip sc_rip
+#  define context_rsp sc_rsp
+#  define context_rbp sc_rbp
+#  define context_rax sc_rax
+#  define context_rbx sc_rbx
+#  define context_rcx sc_rcx
+#  define context_rdx sc_rdx
+#  define context_rsi sc_rsi
+#  define context_rdi sc_rdi
+#  define context_r8  sc_r8
+#  define context_r9  sc_r9
+#  define context_r10 sc_r10
+#  define context_r11 sc_r11
+#  define context_r12 sc_r12
+#  define context_r13 sc_r13
+#  define context_r14 sc_r14
+#  define context_r15 sc_r15
+#  define context_flags sc_rflags
+#  define context_err sc_err
+# else
+#  define context_pc sc_eip
+#  define context_sp sc_esp
+#  define context_fp sc_ebp
+#  define context_eip sc_eip
+#  define context_esp sc_esp
+#  define context_eax sc_eax
+#  define context_ebx sc_ebx
+#  define context_ecx sc_ecx
+#  define context_edx sc_edx
+#  define context_ebp sc_ebp
+#  define context_esi sc_esi
+#  define context_edi sc_edi
+#  define context_eflags sc_eflags
+#  define context_trapno sc_trapno
+# endif
+#endif
+
+#ifdef __NetBSD__
+# define context_trapno uc_mcontext.__gregs[_REG_TRAPNO]
+# ifdef AMD64
+#  define __register_t __greg_t
+#  define context_pc uc_mcontext.__gregs[_REG_RIP]
+#  define context_sp uc_mcontext.__gregs[_REG_URSP]
+#  define context_fp uc_mcontext.__gregs[_REG_RBP]
+#  define context_rip uc_mcontext.__gregs[_REG_RIP]
+#  define context_rsp uc_mcontext.__gregs[_REG_URSP]
+#  define context_rax uc_mcontext.__gregs[_REG_RAX]
+#  define context_rbx uc_mcontext.__gregs[_REG_RBX]
+#  define context_rcx uc_mcontext.__gregs[_REG_RCX]
+#  define context_rdx uc_mcontext.__gregs[_REG_RDX]
+#  define context_rbp uc_mcontext.__gregs[_REG_RBP]
+#  define context_rsi uc_mcontext.__gregs[_REG_RSI]
+#  define context_rdi uc_mcontext.__gregs[_REG_RDI]
+#  define context_r8  uc_mcontext.__gregs[_REG_R8]
+#  define context_r9  uc_mcontext.__gregs[_REG_R9]
+#  define context_r10 uc_mcontext.__gregs[_REG_R10]
+#  define context_r11 uc_mcontext.__gregs[_REG_R11]
+#  define context_r12 uc_mcontext.__gregs[_REG_R12]
+#  define context_r13 uc_mcontext.__gregs[_REG_R13]
+#  define context_r14 uc_mcontext.__gregs[_REG_R14]
+#  define context_r15 uc_mcontext.__gregs[_REG_R15]
+#  define context_flags uc_mcontext.__gregs[_REG_RFL]
+#  define context_err uc_mcontext.__gregs[_REG_ERR]
+# else
+#  define context_pc uc_mcontext.__gregs[_REG_EIP]
+#  define context_sp uc_mcontext.__gregs[_REG_UESP]
+#  define context_fp uc_mcontext.__gregs[_REG_EBP]
+#  define context_eip uc_mcontext.__gregs[_REG_EIP]
+#  define context_esp uc_mcontext.__gregs[_REG_UESP]
+#  define context_eax uc_mcontext.__gregs[_REG_EAX]
+#  define context_ebx uc_mcontext.__gregs[_REG_EBX]
+#  define context_ecx uc_mcontext.__gregs[_REG_ECX]
+#  define context_edx uc_mcontext.__gregs[_REG_EDX]
+#  define context_ebp uc_mcontext.__gregs[_REG_EBP]
+#  define context_esi uc_mcontext.__gregs[_REG_ESI]
+#  define context_edi uc_mcontext.__gregs[_REG_EDI]
+#  define context_eflags uc_mcontext.__gregs[_REG_EFL]
+#  define context_trapno uc_mcontext.__gregs[_REG_TRAPNO]
+# endif
+#endif
+
 address os::current_stack_pointer() {
 #ifdef SPARC_WORKS
   register void *esp;
@@@@ -85,15 +264,15 @@@@ void os::initialize_thread() {
 }
 
 address os::Bsd::ucontext_get_pc(ucontext_t * uc) {
-  return (address)uc->uc_mcontext.gregs[REG_PC];
+  return (address)uc->context_pc;
 }
 
 intptr_t* os::Bsd::ucontext_get_sp(ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.gregs[REG_SP];
+  return (intptr_t*)uc->context_sp;
 }
 
 intptr_t* os::Bsd::ucontext_get_fp(ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.gregs[REG_FP];
+  return (intptr_t*)uc->context_fp;
 }
 
 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
@@@@ -245,18 +424,18 @@@@ JVM_handle_bsd_signal(int sig,
     pc = (address) os::Bsd::ucontext_get_pc(uc);
 
     if (pc == (address) Fetch32PFI) {
-       uc->uc_mcontext.gregs[REG_PC] = intptr_t(Fetch32Resume) ;
+       uc->context_pc = intptr_t(Fetch32Resume) ;
        return 1 ;
     }
 #ifdef AMD64
     if (pc == (address) FetchNPFI) {
-       uc->uc_mcontext.gregs[REG_PC] = intptr_t (FetchNResume) ;
+       uc->context_pc = intptr_t (FetchNResume) ;
        return 1 ;
     }
 #endif // AMD64
 
     // Handle ALL stack overflow variations here
-    if (sig == SIGSEGV) {
+    if (sig == SIGSEGV || sig == SIGBUS) {
       address addr = (address) info->si_addr;
 
       // check if fault address is within thread stack
@@@@ -278,6 +457,7 @@@@ JVM_handle_bsd_signal(int sig,
           // to handle_unexpected_exception way down below.
           thread->disable_stack_red_zone();
           tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+#ifndef _ALLBSD_SOURCE
         } else {
           // Accessing stack address below sp may cause SEGV if current
           // thread has MAP_GROWSDOWN stack. This should only happen when
@@@@ -293,6 +473,7 @@@@ JVM_handle_bsd_signal(int sig,
           } else {
              fatal("recursive segv. expanding stack.");
           }
+#endif
         }
       }
     }
@@@@ -301,9 +482,16 @@@@ JVM_handle_bsd_signal(int sig,
       // Java thread running in Java code => find exception handler if any
       // a fault inside compiled code, the interpreter, or a stub
 
-      if (sig == SIGSEGV && os::is_poll_address((address)info->si_addr)) {
+      if ((sig == SIGSEGV || sig == SIGBUS) && os::is_poll_address((address)info->si_addr)) {
         stub = SharedRuntime::get_poll_stub(pc);
+#if defined(__APPLE__) && !defined(AMD64)
+      // 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.
+      // Catching SIGBUS here prevents the implicit SIGBUS NULL check below from
+      // being called, so only do so if the implicit NULL check is not necessary.
+      } else if (sig == SIGBUS && MacroAssembler::needs_explicit_null_check((int)info->si_addr)) {
+#else
       } else if (sig == SIGBUS /* && info->si_code == BUS_OBJERR */) {
+#endif
         // BugId 4454115: A read from a MappedByteBuffer can fault
         // here if the underlying file has been truncated.
         // Do not crash the VM in such a case.
@@@@ -324,6 +512,28 @@@@ JVM_handle_bsd_signal(int sig,
                                               pc,
                                               SharedRuntime::
                                               IMPLICIT_DIVIDE_BY_ZERO);
+#ifdef __APPLE__
+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {
+        int op = pc[0];
+
+        // Skip REX
+        if ((pc[0] & 0xf0) == 0x40) {
+          op = pc[1];
+        } else {
+          op = pc[0];
+        }
+
+        // Check for IDIV
+        if (op == 0xF7) {
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime:: IMPLICIT_DIVIDE_BY_ZERO);
+        } else {
+          // TODO: handle more cases if we are using other x86 instructions
+          //   that can generate SIGFPE signal.
+          tty->print_cr("unknown opcode 0x%X with SIGFPE.", op);
+          fatal("please update this code.");
+        }
+#endif /* __APPLE__ */
+
 #else
       if (sig == SIGFPE /* && info->si_code == FPE_INTDIV */) {
         // HACK: si_code does not work on bsd 2.2.12-20!!!
@@@@ -351,7 +561,7 @@@@ JVM_handle_bsd_signal(int sig,
           fatal("please update this code.");
         }
 #endif // AMD64
-      } else if (sig == SIGSEGV &&
+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&
                !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {
           // Determination of interpreter/vtable stub/compiled code null exception
           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
@@@@ -375,7 +585,7 @@@@ JVM_handle_bsd_signal(int sig,
     // process of write protecting the memory serialization page.
     // It write enables the page immediately after protecting it
     // so we can just return to retry the write.
-    if ((sig == SIGSEGV) &&
+    if ((sig == SIGSEGV || sig == SIGBUS) &&
         os::is_memory_serialize_page(thread, (address) info->si_addr)) {
       // Block current thread until the memory serialize page permission restored.
       os::block_on_serialize_page_trap();
@@@@ -396,7 +606,7 @@@@ JVM_handle_bsd_signal(int sig,
   // Furthermore, a false-positive should be harmless.
   if (UnguardOnExecutionViolation > 0 &&
       (sig == SIGSEGV || sig == SIGBUS) &&
-      uc->uc_mcontext.gregs[REG_TRAPNO] == trap_page_fault) {
+      uc->context_trapno == trap_page_fault) {
     int page_size = os::vm_page_size();
     address addr = (address) info->si_addr;
     address pc = os::Bsd::ucontext_get_pc(uc);
@@@@ -466,7 +676,7 @@@@ JVM_handle_bsd_signal(int sig,
     // save all thread context in case we need to restore it
     if (thread != NULL) thread->set_saved_exception_pc(pc);
 
-    uc->uc_mcontext.gregs[REG_PC] = (greg_t)stub;
+    uc->context_pc = (intptr_t)stub;
     return true;
   }
 
@@@@ -496,13 +706,24 @@@@ JVM_handle_bsd_signal(int sig,
   ShouldNotReachHere();
 }
 
+#ifdef _ALLBSD_SOURCE
+// From solaris_i486.s ported to bsd_i486.s
+extern "C" void fixcw();
+#endif
+
 void os::Bsd::init_thread_fpu_state(void) {
 #ifndef AMD64
+# ifdef _ALLBSD_SOURCE
+  // Set fpu to 53 bit precision. This happens too early to use a stub.
+  fixcw();
+# else
   // set fpu to 53 bit precision
   set_fpu_control_word(0x27f);
+# endif
 #endif // !AMD64
 }
 
+#ifndef _ALLBSD_SOURCE
 int os::Bsd::get_fpu_control_word(void) {
 #ifdef AMD64
   return 0;
@@@@ -518,11 +739,12 @@@@ void os::Bsd::set_fpu_control_word(int fpu_control) {
   _FPU_SETCW(fpu_control);
 #endif // !AMD64
 }
+#endif
 
 // Check that the bsd kernel version is 2.4 or higher since earlier
 // versions do not support SSE without patches.
 bool os::supports_sse() {
-#ifdef AMD64
+#if defined(AMD64) || defined(_ALLBSD_SOURCE)
   return true;
 #else
   struct utsname uts;
@@@@ -576,6 +798,9 @@@@ size_t os::Bsd::min_stack_allowed  =  (48 DEBUG_ONLY(+
 #define GET_GS() ({int gs; __asm__ volatile("movw %%gs, %w0":"=q"(gs)); gs&0xffff;})
 #endif
 
+#ifdef _ALLBSD_SOURCE
+bool os::Bsd::supports_variable_stack_size() { return true; }
+#else
 // Test if pthread library can support variable thread stack size. BsdThreads
 // in fixed stack mode allocates 2M fixed slot for each thread. BsdThreads
 // in floating stack mode and NPTL support variable stack size.
@@@@ -612,6 +837,7 @@@@ bool os::Bsd::supports_variable_stack_size() {
 #endif
   }
 }
+#endif
 #endif // AMD64
 
 // return default stack size for thr_type
@@@@ -665,6 +891,41 @@@@ size_t os::Bsd::default_guard_size(os::ThreadType thr_
 //    pthread_attr_getstack()
 
 static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_stackseg_np failed with err = %d", rslt));
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#elif defined(_ALLBSD_SOURCE)
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_init failed with err = %d", rslt));
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal(err_msg("pthread_attr_get_np failed with err = %d", rslt));
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#else
   if (os::Bsd::is_initial_thread()) {
      // initial thread needs special handling because pthread_getattr_np()
      // may return bogus value.
@@@@ -691,6 +952,7 @@@@ static void current_stack_region(address * bottom, siz
      pthread_attr_destroy(&attr);
 
   }
+#endif
   assert(os::current_stack_pointer() >= *bottom &&
          os::current_stack_pointer() < *bottom + *size, "just checking");
 }
@@@@ -719,46 +981,44 @@@@ void os::print_context(outputStream *st, void *context
   ucontext_t *uc = (ucontext_t*)context;
   st->print_cr("Registers:");
 #ifdef AMD64
-  st->print(  "RAX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RAX]);
-  st->print(", RBX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBX]);
-  st->print(", RCX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RCX]);
-  st->print(", RDX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDX]);
+  st->print(  "RAX=" INTPTR_FORMAT, uc->context_rax);
+  st->print(", RBX=" INTPTR_FORMAT, uc->context_rbx);
+  st->print(", RCX=" INTPTR_FORMAT, uc->context_rcx);
+  st->print(", RDX=" INTPTR_FORMAT, uc->context_rdx);
   st->cr();
-  st->print(  "RSP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSP]);
-  st->print(", RBP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBP]);
-  st->print(", RSI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSI]);
-  st->print(", RDI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDI]);
+  st->print(  "RSP=" INTPTR_FORMAT, uc->context_rsp);
+  st->print(", RBP=" INTPTR_FORMAT, uc->context_rbp);
+  st->print(", RSI=" INTPTR_FORMAT, uc->context_rsi);
+  st->print(", RDI=" INTPTR_FORMAT, uc->context_rdi);
   st->cr();
-  st->print(  "R8 =" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R8]);
-  st->print(", R9 =" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R9]);
-  st->print(", R10=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R10]);
-  st->print(", R11=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R11]);
+  st->print(  "R8 =" INTPTR_FORMAT, uc->context_r8);
+  st->print(", R9 =" INTPTR_FORMAT, uc->context_r9);
+  st->print(", R10=" INTPTR_FORMAT, uc->context_r10);
+  st->print(", R11=" INTPTR_FORMAT, uc->context_r11);
   st->cr();
-  st->print(  "R12=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R12]);
-  st->print(", R13=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R13]);
-  st->print(", R14=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R14]);
-  st->print(", R15=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R15]);
+  st->print(  "R12=" INTPTR_FORMAT, uc->context_r12);
+  st->print(", R13=" INTPTR_FORMAT, uc->context_r13);
+  st->print(", R14=" INTPTR_FORMAT, uc->context_r14);
+  st->print(", R15=" INTPTR_FORMAT, uc->context_r15);
   st->cr();
-  st->print(  "RIP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RIP]);
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
-  st->print(", CSGSFS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_CSGSFS]);
-  st->print(", ERR=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ERR]);
+  st->print(  "RIP=" INTPTR_FORMAT, uc->context_rip);
+  st->print(", EFLAGS=" INTPTR_FORMAT, uc->context_flags);
+  st->print(", ERR=" INTPTR_FORMAT, uc->context_err);
   st->cr();
-  st->print("  TRAPNO=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_TRAPNO]);
+  st->print("  TRAPNO=" INTPTR_FORMAT, uc->context_trapno);
 #else
-  st->print(  "EAX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EAX]);
-  st->print(", EBX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBX]);
-  st->print(", ECX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ECX]);
-  st->print(", EDX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDX]);
+  st->print(  "EAX=" INTPTR_FORMAT, uc->context_eax);
+  st->print(", EBX=" INTPTR_FORMAT, uc->context_ebx);
+  st->print(", ECX=" INTPTR_FORMAT, uc->context_ecx);
+  st->print(", EDX=" INTPTR_FORMAT, uc->context_edx);
   st->cr();
-  st->print(  "ESP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_UESP]);
-  st->print(", EBP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBP]);
-  st->print(", ESI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ESI]);
-  st->print(", EDI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDI]);
+  st->print(  "ESP=" INTPTR_FORMAT, uc->context_esp);
+  st->print(", EBP=" INTPTR_FORMAT, uc->context_ebp);
+  st->print(", ESI=" INTPTR_FORMAT, uc->context_esi);
+  st->print(", EDI=" INTPTR_FORMAT, uc->context_edi);
   st->cr();
-  st->print(  "EIP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EIP]);
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
-  st->print(", CR2=" INTPTR_FORMAT, uc->uc_mcontext.cr2);
+  st->print(  "EIP=" INTPTR_FORMAT, uc->context_eip);
+  st->print(", EFLAGS=" INTPTR_FORMAT, uc->context_eflags);
 #endif // AMD64
   st->cr();
   st->cr();
@@@@ -791,31 +1051,31 @@@@ void os::print_register_info(outputStream *st, void *c
   // this is only for the "general purpose" registers
 
 #ifdef AMD64
-  st->print("RAX="); print_location(st, uc->uc_mcontext.gregs[REG_RAX]);
-  st->print("RBX="); print_location(st, uc->uc_mcontext.gregs[REG_RBX]);
-  st->print("RCX="); print_location(st, uc->uc_mcontext.gregs[REG_RCX]);
-  st->print("RDX="); print_location(st, uc->uc_mcontext.gregs[REG_RDX]);
-  st->print("RSP="); print_location(st, uc->uc_mcontext.gregs[REG_RSP]);
-  st->print("RBP="); print_location(st, uc->uc_mcontext.gregs[REG_RBP]);
-  st->print("RSI="); print_location(st, uc->uc_mcontext.gregs[REG_RSI]);
-  st->print("RDI="); print_location(st, uc->uc_mcontext.gregs[REG_RDI]);
-  st->print("R8 ="); print_location(st, uc->uc_mcontext.gregs[REG_R8]);
-  st->print("R9 ="); print_location(st, uc->uc_mcontext.gregs[REG_R9]);
-  st->print("R10="); print_location(st, uc->uc_mcontext.gregs[REG_R10]);
-  st->print("R11="); print_location(st, uc->uc_mcontext.gregs[REG_R11]);
-  st->print("R12="); print_location(st, uc->uc_mcontext.gregs[REG_R12]);
-  st->print("R13="); print_location(st, uc->uc_mcontext.gregs[REG_R13]);
-  st->print("R14="); print_location(st, uc->uc_mcontext.gregs[REG_R14]);
-  st->print("R15="); print_location(st, uc->uc_mcontext.gregs[REG_R15]);
+  st->print("RAX="); print_location(st, uc->context_rax);
+  st->print("RBX="); print_location(st, uc->context_rbx);
+  st->print("RCX="); print_location(st, uc->context_rcx);
+  st->print("RDX="); print_location(st, uc->context_rdx);
+  st->print("RSP="); print_location(st, uc->context_rsp);
+  st->print("RBP="); print_location(st, uc->context_rbp);
+  st->print("RSI="); print_location(st, uc->context_rsi);
+  st->print("RDI="); print_location(st, uc->context_rdi);
+  st->print("R8 ="); print_location(st, uc->context_r8);
+  st->print("R9 ="); print_location(st, uc->context_r9);
+  st->print("R10="); print_location(st, uc->context_r10);
+  st->print("R11="); print_location(st, uc->context_r11);
+  st->print("R12="); print_location(st, uc->context_r12);
+  st->print("R13="); print_location(st, uc->context_r13);
+  st->print("R14="); print_location(st, uc->context_r14);
+  st->print("R15="); print_location(st, uc->context_r15);
 #else
-  st->print("EAX="); print_location(st, uc->uc_mcontext.gregs[REG_EAX]);
-  st->print("EBX="); print_location(st, uc->uc_mcontext.gregs[REG_EBX]);
-  st->print("ECX="); print_location(st, uc->uc_mcontext.gregs[REG_ECX]);
-  st->print("EDX="); print_location(st, uc->uc_mcontext.gregs[REG_EDX]);
-  st->print("ESP="); print_location(st, uc->uc_mcontext.gregs[REG_ESP]);
-  st->print("EBP="); print_location(st, uc->uc_mcontext.gregs[REG_EBP]);
-  st->print("ESI="); print_location(st, uc->uc_mcontext.gregs[REG_ESI]);
-  st->print("EDI="); print_location(st, uc->uc_mcontext.gregs[REG_EDI]);
+  st->print("EAX="); print_location(st, uc->context_eax);
+  st->print("EBX="); print_location(st, uc->context_ebx);
+  st->print("ECX="); print_location(st, uc->context_ecx);
+  st->print("EDX="); print_location(st, uc->context_edx);
+  st->print("ESP="); print_location(st, uc->context_esp);
+  st->print("EBP="); print_location(st, uc->context_ebp);
+  st->print("ESI="); print_location(st, uc->context_esi);
+  st->print("EDI="); print_location(st, uc->context_edi);
 #endif // AMD64
 
   st->cr();
@


1.5
log
@Update to early access build 122. okay jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-hotspot_src_os_cpu_bsd_x86_vm_os_bsd_x86_cpp,v 1.4 2009/05/23 03:03:25 kurt Exp $
@


1.4
log
@- update from early access b43 to b59
- sync patches with OpenJDK's bsd_port project
- require a pre-installed package for native_bootstrap
- The new 1.7 class java.nio.channels.spi.AsynchronousChannelProvider
  is not implemented yet on BSD.
- The new 1.7 package java.nio.sctp is not included and not supported on
  OpenBD
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_cpu_bsd_x86_vm_os_bsd_x86_cpp,v 1.3 2009/01/17 11:37:42 kurt Exp $
--- hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp.orig	Fri May 15 16:25:28 2009
+++ hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	Sat May 16 16:49:25 2009
d425 1
a425 1
+    fatal1("pthread_stackseg_np failed with err = %d", rslt);
d436 1
a436 1
+    fatal1("pthread_attr_init failed with err = %d", rslt);
d441 1
a441 1
+    fatal1("pthread_attr_get_np failed with err = %d", rslt);
d502 1
a502 1
-  st->print(", EFL=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
d506 1
a506 1
+  st->print(", EFL=" INTPTR_FORMAT, uc->context_flags);
d531 1
a532 1
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
d537 56
@


1.3
log
@- Update to early access b43:
  http://download.java.net/jdk7/changes/jdk7-b43.html
- Remove KOI8_U char encoding which no longer applies
- Correct datatype warning in fork_and_exec()
- Sync patches
@
text
@d1 4
a4 4
$OpenBSD: patch-hotspot_src_os_cpu_bsd_x86_vm_os_bsd_x86_cpp,v 1.2 2009/01/04 23:25:16 kurt Exp $
--- hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp.orig	Fri Jan 16 12:16:38 2009
+++ hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	Fri Jan 16 12:16:43 2009
@@@@ -44,23 +44,158 @@@@
d13 1
a13 1
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__)
d167 44
d214 1
a214 1
@@@@ -85,15 +220,15 @@@@ void os::initialize_thread() {
d233 1
a233 1
@@@@ -245,18 +380,18 @@@@ JVM_handle_bsd_signal(int sig,
d255 1
a255 1
@@@@ -278,6 +413,7 @@@@ JVM_handle_bsd_signal(int sig,
d263 1
a263 1
@@@@ -293,6 +429,7 @@@@ JVM_handle_bsd_signal(int sig,
d271 1
a271 1
@@@@ -301,9 +438,16 @@@@ JVM_handle_bsd_signal(int sig,
d289 1
a289 1
@@@@ -324,9 +468,31 @@@@ JVM_handle_bsd_signal(int sig,
d317 2
a318 6
-        // HACK: si_code does not work on bsd 2.2.12-20!!!
+        // HACK: si_code does not work on linux 2.2.12-20!!!
         int op = pc[0];
         if (op == 0xDB) {
           // FIST
@@@@ -351,7 +517,7 @@@@ JVM_handle_bsd_signal(int sig,
d327 1
a327 1
@@@@ -375,7 +541,7 @@@@ JVM_handle_bsd_signal(int sig,
d336 1
a336 1
@@@@ -396,7 +562,7 @@@@ JVM_handle_bsd_signal(int sig,
d345 1
a345 1
@@@@ -466,7 +632,7 @@@@ JVM_handle_bsd_signal(int sig,
d354 1
a354 1
@@@@ -496,13 +662,24 @@@@ JVM_handle_bsd_signal(int sig,
d379 1
a379 1
@@@@ -518,11 +695,12 @@@@ void os::Bsd::set_fpu_control_word(int fpu_control) {
d393 1
a393 1
@@@@ -576,6 +754,9 @@@@ size_t os::Bsd::min_stack_allowed  =  (48 DEBUG_ONLY(+
d403 1
a403 1
@@@@ -612,6 +793,7 @@@@ bool os::Bsd::supports_variable_stack_size() {
d411 1
a411 1
@@@@ -665,6 +847,41 @@@@ size_t os::Bsd::default_guard_size(os::ThreadType thr_
d453 1
a453 1
@@@@ -691,6 +908,7 @@@@ static void current_stack_region(address * bottom, siz
d461 1
a461 1
@@@@ -719,46 +937,44 @@@@ void os::print_context(outputStream *st, void *context
@


1.2
log
@Update to early access build 42:
- sync/regen patches
- use os_bsd_x86.cpp from OpenJDK bsd-java repository plus
  Greg Lewis's fixes posted to the bsd-port-dev list
- use Xiaobin Lu's datatype corrections from OpenJDK bug
  6787106 + additional datatype corrections from me.
- use Vladimir Kozlov's bug fix from OpenJDK bug 6782820
- remove obsolete IcedTea awt binary plugs and update binary
  plug distfile
- correctly define DEVTOOLS_PATH for bsd and verify + correct
  Defs-utils.gmk locations for bsd utilities
@
text
@d1 3
a3 3
$OpenBSD: patch-hotspot_src_os_cpu_bsd_x86_vm_os_bsd_x86_cpp,v 1.1 2008/03/19 18:05:43 kurt Exp $
--- hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp.orig	Wed Dec 24 13:41:51 2008
+++ hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	Sun Dec 28 17:28:37 2008
d305 1
a305 1
@@@@ -465,7 +631,7 @@@@ JVM_handle_bsd_signal(int sig,
d314 1
a314 1
@@@@ -495,13 +661,24 @@@@ JVM_handle_bsd_signal(int sig,
d339 1
a339 1
@@@@ -517,11 +694,12 @@@@ void os::Bsd::set_fpu_control_word(int fpu_control) {
d353 1
a353 1
@@@@ -575,6 +753,9 @@@@ size_t os::Bsd::min_stack_allowed  =  (48 DEBUG_ONLY(+
d363 1
a363 1
@@@@ -611,6 +792,7 @@@@ bool os::Bsd::supports_variable_stack_size() {
d371 1
a371 1
@@@@ -664,6 +846,41 @@@@ size_t os::Bsd::default_guard_size(os::ThreadType thr_
d413 1
a413 1
@@@@ -690,6 +907,7 @@@@ static void current_stack_region(address * bottom, siz
d421 1
a421 1
@@@@ -718,46 +936,44 @@@@ void os::print_context(outputStream *st, void *context
@


1.1
log
@- switch to GPLv2 w/CLASSPATH exception licensed openjdk7 code
- update to early access build 24
- Use GPLv2 licensed binary plugs from the IcedTea project and parts of
  IcedTea's icedtea-copy-plugs.patch & icedtea-graphics.patch.
  For more info see:
    http://icedtea.classpath.org/wiki/Main_Page
- Enable packages since we're fully GPLv2 based now, but still not
  hooked up to bulk builds just yet.
@
text
@d1 4
a4 4
$OpenBSD$
--- hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp.orig	Wed Nov  7 17:07:05 2007
+++ hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	Wed Nov  7 17:08:03 2007
@@@@ -44,23 +44,109 @@@@
d10 1
a10 1
 # include <fpu_control.h>
d13 1
a13 1
+#ifdef _ALLBSD_SOURCE
d74 50
d168 3
a170 3
   register void *esp __asm__ (SPELL_REG_SP);
   return (address) esp;
@@@@ -79,15 +165,15 @@@@ void os::initialize_thread() {
d189 1
a189 1
@@@@ -249,18 +335,18 @@@@ JVM_handle_bsd_signal(int sig,
d211 1
a211 1
@@@@ -282,6 +368,7 @@@@ JVM_handle_bsd_signal(int sig,
d219 1
a219 1
@@@@ -297,6 +384,7 @@@@ JVM_handle_bsd_signal(int sig,
d227 1
a227 1
@@@@ -305,7 +393,7 @@@@ JVM_handle_bsd_signal(int sig,
d234 6
d241 1
d243 36
a278 1
@@@@ -355,7 +443,7 @@@@ JVM_handle_bsd_signal(int sig,
d287 1
a287 1
@@@@ -379,7 +467,7 @@@@ JVM_handle_bsd_signal(int sig,
d296 1
a296 1
@@@@ -400,7 +488,7 @@@@ JVM_handle_bsd_signal(int sig,
d305 1
a305 1
@@@@ -469,7 +557,7 @@@@ JVM_handle_bsd_signal(int sig,
d314 1
a314 1
@@@@ -499,13 +587,24 @@@@ JVM_handle_bsd_signal(int sig,
d339 1
a339 1
@@@@ -521,11 +620,12 @@@@ void os::Bsd::set_fpu_control_word(int fpu_control) {
d353 1
a353 2
@@@@ -577,6 +677,9 @@@@ size_t os::Bsd::min_stack_allowed  =  (48 DEBUG_ONLY(+
 
d355 1
d363 2
a364 2
@@@@ -609,6 +712,7 @@@@ bool os::Bsd::supports_variable_stack_size() {
     return (GET_GS() != 0);
d371 1
a371 1
@@@@ -662,6 +766,36 @@@@ size_t os::Bsd::default_guard_size(os::ThreadType thr_
d375 6
a380 1
+#ifdef __OpenBSD__
d413 1
a413 1
@@@@ -688,6 +822,7 @@@@ static void current_stack_region(address * bottom, siz
d421 1
a421 1
@@@@ -716,46 +851,44 @@@@ void os::print_context(outputStream *st, void *context
@

