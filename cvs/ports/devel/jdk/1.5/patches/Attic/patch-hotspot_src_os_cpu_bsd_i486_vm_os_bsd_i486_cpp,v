head	1.5;
access;
symbols
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.1.1.1.0.2
	OPENBSD_3_8_BASE:1.1.1.1
	kurt_20050525:1.1.1.1
	kurt:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2006.04.11.00.45.42;	author kurt;	state dead;
branches;
next	1.4;

1.4
date	2006.01.22.22.46.31;	author kurt;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2005.11.30.02.21.32;	author kurt;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.22.14.43.05;	author kurt;	state dead;
branches;
next	1.1;

1.1
date	2005.05.25.17.27.53;	author kurt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.05.25.17.27.53;	author kurt;	state Exp;
branches;
next	;

1.4.2.1
date	2007.01.31.14.52.31;	author kurt;	state dead;
branches;
next	;


desc
@@


1.5
log
@Update to patchset 3. Patchset 3 includes several bug fixes that improve
compatiabily and stability which came from work sponsored by the FreeBSD
Foundation.
@
text
@$OpenBSD: patch-hotspot_src_os_cpu_bsd_i486_vm_os_bsd_i486_cpp,v 1.4 2006/01/22 22:46:31 kurt Exp $
--- hotspot/src/os_cpu/bsd_i486/vm/os_bsd_i486.cpp.orig	Thu Jan 19 21:50:33 2006
+++ hotspot/src/os_cpu/bsd_i486/vm/os_bsd_i486.cpp	Thu Jan 19 22:28:26 2006
@@@@ -292,10 +292,10 @@@@ void GetThreadPC_Callback::execute(OSThr
 // This is a "fast" implementation of fetch_top_frame that relies on the
 // new libthread APIs to get pc for a suspended thread
 // XXXBSD: This is Solaris specific.  Get rid or implement...
-ExtendedPC os::Bsd::fetch_top_frame_fast(Thread* thread, jint** sp, jint** fp) {
+ExtendedPC os::Bsd::fetch_top_frame_fast(Thread* thread, intptr_t** sp, intptr_t** fp) {
     ExtendedPC new_addr(NULL);
-    *sp   = (jint*)0;
-    *fp   = (jint*)0;
+    *sp   = (intptr_t*)0;
+    *fp   = (intptr_t*)0;
     return new_addr;  // bail out
 }
 
@@@@ -350,9 +350,12 @@@@ bool os::supports_sse() {
 
 bool os::is_allocatable(size_t bytes) {
 
+// XXXBSD: 1*G for OpenBSD or just check?
+#ifndef __OpenBSD__
   if (bytes < 2 * G) {
     return true;
   }
+#endif
 
   char* addr = reserve_memory(bytes, NULL);
 
@


1.4
log
@- fix a series of datatype assumptions in i486/hotspot (intptr_t != int
  on OpenBSD)
- fix implicit declaration's by adding headers or prototypes as needed.
@
text
@d1 1
a1 1
$OpenBSD: patch-hotspot_src_os_cpu_bsd_i486_vm_os_bsd_i486_cpp,v 1.3 2005/11/30 02:21:32 kurt Exp $
@


1.4.2.1
log
@Update to patchset 4 which includes a security fix for CVE-2007-0243

Buffer overflow allows applets to gain privileges via a GIF image with a
block with a 0 width field, which triggers memory corruption and possible
execution of arbitrary code.

Also included in patchset 4 are corrections for building the jdk on amd64
systems with 4G+ memory and the inclusion of the mozilla headers needed to
build the plugin without an external dependency on the old mozilla suite.

okay nikolay@@
@
text
@d1 1
a1 1
$OpenBSD: patch-hotspot_src_os_cpu_bsd_i486_vm_os_bsd_i486_cpp,v 1.4 2006/01/22 22:46:31 kurt Exp $
@


1.3
log
@- fix build for systems with > 2G physical memory (signed int value was
assigned to uint64).
- set some fall-back max-memory values to reasonable values for OpenBSD.
Problem reported and update tested by Douglas Santos.
@
text
@d1 17
a17 3
$OpenBSD$
--- hotspot/src/os_cpu/bsd_i486/vm/os_bsd_i486.cpp.orig	Tue Nov 29 09:54:02 2005
+++ hotspot/src/os_cpu/bsd_i486/vm/os_bsd_i486.cpp	Tue Nov 29 09:55:00 2005
@


1.2
log
@- update to patchset 2. mostly removing patches now included in patchset.
- link awt_robot with -pthread
- disable a runtime Motif version check that incorrectly thought we were
using Motif 1.2 based on Xm major version. problem reported by Laurence
Tratt
- plugin and webstart comming later
@
text
@d1 4
a4 6
$OpenBSD: patch-hotspot_src_os_cpu_bsd_i486_vm_os_bsd_i486_cpp,v 1.1 2005/05/25 17:27:53 kurt Exp $
--- hotspot/src/os_cpu/bsd_i486/vm/os_bsd_i486.cpp.orig	Tue Jan 25 22:14:33 2005
+++ hotspot/src/os_cpu/bsd_i486/vm/os_bsd_i486.cpp	Tue Jan 25 22:16:08 2005
@@@@ -28,19 +28,48 @@@@
 # include <pwd.h>
 # include <poll.h>
d6 1
a6 37
+# ifdef __FreeBSD__
+#  define context_eip uc_mcontext.mc_eip
+#  define context_esp uc_mcontext.mc_esp
+#  define context_eax uc_mcontext.mc_eax
+#  define context_ebx uc_mcontext.mc_ebx
+#  define context_ecx uc_mcontext.mc_ecx
+#  define context_edx uc_mcontext.mc_edx
+#  define context_ebp uc_mcontext.mc_ebp
+#  define context_esi uc_mcontext.mc_esi
+#  define context_edi uc_mcontext.mc_edi
+#  define context_eflags uc_mcontext.mc_eflags
+#  define context_trapno uc_mcontext.mc_trapno
+# endif
+
 # ifdef __NetBSD__
-#  define mc_eip __gregs[_REG_EIP]
-#  define mc_esp __gregs[_REG_UESP]
-#  define mc_eax __gregs[_REG_EAX]
-#  define mc_ebx __gregs[_REG_EBX]
-#  define mc_ecx __gregs[_REG_ECX]
-#  define mc_edx __gregs[_REG_EDX]
-#  define mc_ebp __gregs[_REG_EBP]
-#  define mc_esi __gregs[_REG_ESI]
-#  define mc_edi __gregs[_REG_EDI]
-#  define mc_eflags __gregs[_REG_EFL]
+#  define context_eip uc_mcontext.__gregs[_REG_EIP]
+#  define context_esp uc_mcontext.__gregs[_REG_UESP]
+#  define context_eax uc_mcontext.__gregs[_REG_EAX]
+#  define context_ebx uc_mcontext.__gregs[_REG_EBX]
+#  define context_ecx uc_mcontext.__gregs[_REG_ECX]
+#  define context_edx uc_mcontext.__gregs[_REG_EDX]
+#  define context_ebp uc_mcontext.__gregs[_REG_EBP]
+#  define context_esi uc_mcontext.__gregs[_REG_ESI]
+#  define context_edi uc_mcontext.__gregs[_REG_EDI]
+#  define context_eflags uc_mcontext.__gregs[_REG_EFL]
+#  define context_trapno uc_mcontext.mc_trapno
 # endif
d8 1
a8 22
+# ifdef __OpenBSD__
+#  define context_eip sc_eip
+#  define context_esp sc_esp
+#  define context_eax sc_eax
+#  define context_ebx sc_ebx
+#  define context_ecx sc_ecx
+#  define context_edx sc_edx
+#  define context_ebp sc_ebp
+#  define context_esi sc_esi
+#  define context_edi sc_edi
+#  define context_eflags sc_eflags
+#  define context_trapno sc_trapno
+# endif
+
 // Minimum stack size for the VM.  It's easier to document a constant value
 // but it's different for x86 and sparc because the page sizes are different.
 size_t os::Bsd::min_stack_allowed = 64*K;
@@@@ -59,6 +88,8 @@@@ char* os::non_memory_address_word() {
 // There are issues with libthread giving out uc_links for different threads
 // on the same uc_link chain and bad or circular links. 
 //
+// OpenBSD dosn't have a uc_link so can't do this check
d10 2
a11 69
 bool os::Bsd::valid_ucontext(Thread* thread, ucontext_t* valid, ucontext_t* suspect) {
   if (valid >= suspect || 
       valid->uc_stack.ss_flags != suspect->uc_stack.ss_flags ||
@@@@ -73,7 +104,7 @@@@ bool os::Bsd::valid_ucontext(Thread* thr
       DEBUG_ONLY(tty->print_cr("valid_ucontext: uc_link not in thread stack");)
       return false;
     }
-    if (!valid_stack_address(thread,  (address) suspect->uc_mcontext.mc_esp)) {
+    if (!valid_stack_address(thread,  (address) suspect->context_esp)) {
       DEBUG_ONLY(tty->print_cr("valid_ucontext: stackpointer not in thread stack");)
       return false;
     }
@@@@ -107,20 +138,21 @@@@ ucontext_t* os::Bsd::get_valid_uc_in_sig
   }
   return retuc;
 }
+#endif // !__OpenBSD__
 
 // Assumes ucontext is valid
 ExtendedPC os::Bsd::ucontext_get_ExtendedPC(ucontext_t *uc) {
-  return ExtendedPC((address)uc->uc_mcontext.mc_eip);
+  return ExtendedPC((address)uc->context_eip);
 }
 
 // Assumes ucontext is valid
 intptr_t* os::Bsd::ucontext_get_sp(ucontext_t *uc) {
-  return (intptr_t*)uc->uc_mcontext.mc_esp;
+  return (intptr_t*)uc->context_esp;
 }
 
 // Assumes ucontext is valid
 intptr_t* os::Bsd::ucontext_get_fp(ucontext_t *uc) {
-  return (intptr_t*)uc->uc_mcontext.mc_ebp;
+  return (intptr_t*)uc->context_ebp;
 }
 
 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
@@@@ -135,8 +167,12 @@@@ ExtendedPC os::Bsd::fetch_frame_from_uco
   assert(ret_sp != NULL, "just checking");
   assert(ret_fp != NULL, "just checking");
 
+#ifdef __OpenBSD__
+  return os::fetch_frame_from_context(uc, ret_sp, ret_fp);
+#else
   ucontext_t *luc = os::Bsd::get_valid_uc_in_signal_handler(thread, uc);
   return os::fetch_frame_from_context(luc, ret_sp, ret_fp);
+#endif
 }
 
 ExtendedPC os::fetch_frame_from_context(void* ucVoid, 
@@@@ -202,25 +238,33 @@@@ void SetThreadPC_Callback::execute(OSThr
   // success, if not we return failure and the caller can retry.
   // 
   _result = false;
-  if (uc->uc_mcontext.mc_eip == (int)_old_addr.pc() ) {
-    uc->uc_mcontext.mc_eip = (int)_new_addr.pc();
+  if (uc->context_eip == (int)_old_addr.pc() ) {
+    uc->context_eip = (int)_new_addr.pc();
     _result = true;
+#ifndef __OpenBSD__
   } else if (uc->uc_link != NULL) {
     // Check (and validate) one level of stacked ucontext
     ucontext_t* linked_uc = uc->uc_link;
-    if (os::Bsd::valid_ucontext(thread, uc, linked_uc) && linked_uc->uc_mcontext.mc_eip == (int)_old_addr.pc()) {
-      linked_uc->uc_mcontext.mc_eip = (int)_new_addr.pc();
+    if (os::Bsd::valid_ucontext(thread, uc, linked_uc) && linked_uc->context_eip == (int)_old_addr.pc()) {
+      linked_uc->context_eip = (int)_new_addr.pc();
       _result = true;
     }
a12 14
+#else
+  }
+#endif
 
   thread->safepoint_state()->notify_set_thread_pc_result(_result);
 
 #ifdef ASSERT
   if (!_result) { 
+#ifndef __OpenBSD__
     if (uc->uc_link != NULL) { 
       tty->print_cr("set_thread_pc:(nested) failed to set pc " INTPTR_FORMAT " -> " INTPTR_FORMAT, _old_addr.pc(), _new_addr.pc()); 
     } else { 
+#else
+    {
a13 71
       tty->print_cr("set_thread_pc: failed to set pc " INTPTR_FORMAT " -> " INTPTR_FORMAT, _old_addr.pc(), _new_addr.pc()); 
     } 
   } 
@@@@ -241,7 +285,7 @@@@ void GetThreadPC_Callback::execute(OSThr
 
   assert(ProfileVM && thread->is_VM_thread(), "just checking");
     
-  ExtendedPC new_addr((address)uc->uc_mcontext.mc_eip);
+  ExtendedPC new_addr((address)uc->context_eip);
   _addr = new_addr;
 }
 
@@@@ -326,7 +370,7 @@@@ int JVM_handle_bsd_signal(int sig, sigin
 
   if (sig == SIGILL && info->si_addr == (caddr_t)sse_check) {
     // the SSE instruction faulted. supports_sse() need return false.
-    uc->uc_mcontext.mc_eip = (int)sse_unavailable;
+    uc->context_eip = (int)sse_unavailable;
     return true;
   }
 
@@@@ -380,7 +424,7 @@@@ int JVM_handle_bsd_signal(int sig, sigin
   //%note os_trap_1
   if (info != NULL && thread != NULL) {
     // factor me: getPCfromContext
-    pc = (address) uc->uc_mcontext.mc_eip;
+    pc = (address) uc->context_eip;
     #ifndef CORE
     adjusted_pc = SafepointPolling ? pc : thread->safepoint_state()->compute_adjusted_pc(pc);
     #else
@@@@ -595,10 +639,10 @@@@ int JVM_handle_bsd_signal(int sig, sigin
   // Furthermore, a false-positive should be harmless.
   if (UnguardOnExecutionViolation > 0 &&
       (sig == SIGSEGV || sig == SIGBUS) &&
-      uc->uc_mcontext.mc_trapno == T_PAGEFLT) {  // page fault
+      uc->context_trapno == T_PAGEFLT) {  // page fault
     int page_size = os::vm_page_size();
     address addr = (address) info->si_addr;
-    address pc = (address) uc->uc_mcontext.mc_eip;
+    address pc = (address) uc->context_eip;
     // Make sure the pc and the faulting address are sane.
     //
     // If an instruction spans a page boundary, and the page containing
@@@@ -667,7 +711,7 @@@@ int JVM_handle_bsd_signal(int sig, sigin
     // 12/02/99: On Sparc it appears that the full context is alsosaved
     // but as yet, no one looks at or restores that saved context
     // factor me: setPC
-    uc->uc_mcontext.mc_eip = (int)stub;
+    uc->context_eip = (int)stub;
     return true;
   }
 
@@@@ -676,7 +720,7 @@@@ int JVM_handle_bsd_signal(int sig, sigin
   if (sig == SIGSEGV || sig == SIGBUS) {
     address addr = JNI_FastGetField::find_slowcase_pc(pc);
     if (addr != (address)-1) {
-      uc->uc_mcontext.mc_eip = (int)addr;
+      uc->context_eip = (int)addr;
       return true;
     }
   }
@@@@ -723,7 +767,7 @@@@ int JVM_handle_bsd_signal(int sig, sigin
   }
 
   if (pc == NULL && uc != NULL) {
-    pc = (address) uc->uc_mcontext.mc_eip;
+    pc = (address) uc->context_eip;
   }
 
   // unmask current signal
@@@@ -743,18 +787,18 @@@@ void os::print_context(outputStream *st,
d15 1
a15 26
   ucontext_t *uc = (ucontext_t*)context;
   st->print_cr("Registers:");
-  st->print(  "EAX=" INTPTR_FORMAT, uc->uc_mcontext.mc_eax);
-  st->print(", EBX=" INTPTR_FORMAT, uc->uc_mcontext.mc_ebx);
-  st->print(", ECX=" INTPTR_FORMAT, uc->uc_mcontext.mc_ecx);
-  st->print(", EDX=" INTPTR_FORMAT, uc->uc_mcontext.mc_edx);
+  st->print(  "EAX=" INTPTR_FORMAT, uc->context_eax);
+  st->print(", EBX=" INTPTR_FORMAT, uc->context_ebx);
+  st->print(", ECX=" INTPTR_FORMAT, uc->context_ecx);
+  st->print(", EDX=" INTPTR_FORMAT, uc->context_edx);
   st->cr();
-  st->print(  "ESP=" INTPTR_FORMAT, uc->uc_mcontext.mc_esp);
-  st->print(", EBP=" INTPTR_FORMAT, uc->uc_mcontext.mc_ebp);
-  st->print(", ESI=" INTPTR_FORMAT, uc->uc_mcontext.mc_esi);
-  st->print(", EDI=" INTPTR_FORMAT, uc->uc_mcontext.mc_edi);
+  st->print(  "ESP=" INTPTR_FORMAT, uc->context_esp);
+  st->print(", EBP=" INTPTR_FORMAT, uc->context_ebp);
+  st->print(", ESI=" INTPTR_FORMAT, uc->context_esi);
+  st->print(", EDI=" INTPTR_FORMAT, uc->context_edi);
   st->cr();
-  st->print(  "EIP=" INTPTR_FORMAT, uc->uc_mcontext.mc_eip);
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.mc_eflags);
+  st->print(  "EIP=" INTPTR_FORMAT, uc->context_eip);
+  st->print(", EFLAGS=" INTPTR_FORMAT, uc->context_eflags);
   st->cr();
   st->cr();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.1.1
log
@initial import of 1.5
@
text
@@
