head	1.4;
access;
symbols
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.1.0.4
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.2
	OPENBSD_5_6_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2016.03.05.15.31.41;	author pascal;	state dead;
branches;
next	1.3;
commitid	Hqi865xYWk2i2UMI;

1.3
date	2015.05.19.05.33.39;	author ajacoutot;	state Exp;
branches;
next	1.2;
commitid	pCal9wg5J0ccKDxv;

1.2
date	2015.05.11.23.21.51;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	OoEz6S2vTlKqF89r;

1.1
date	2014.07.11.01.05.24;	author brad;	state Exp;
branches;
next	;
commitid	HV2dQgWiQjyBoYgQ;


desc
@@


1.4
log
@Update to LLVM 3.7.1.  This version is modified to use C++ includes from
ports GCC and link to libestdc++.

Currently, this still breaks mail/mozilla-thunderbird, which will be taken care
of shortly.

feedback/testing from jsg landry mmcc semarie aja naddy (hope I didn't forget
anyone)

ok landry robert
@
text
@$OpenBSD: patch-lib_Target_Sparc_AsmParser_SparcAsmParser_cpp,v 1.3 2015/05/19 05:33:39 ajacoutot Exp $

Sync up the SPARC backend up to commit r203424.

r236107
Sparc: Prefer reg+reg address encoding when only one register used.

Reg+%g0 is preferred to Reg+imm0 by the manual, and is what GCC produces.

Futhermore, reg+imm is invalid for the (not yet supported) "alternate
address space" instructions.

r236137
Make Sparc assembler accept parenthesized constant expressions.

r237580
Add support for the Sparc implementation-defined "ASR" registers.

r237581
Sparc: Add the "alternate address space" load/store instructions.

- Adds support for the asm syntax, which has an immediate integer
  "ASI" (address space identifier) appearing after an address, before
  a comma.

- Adds the various-width load, store, and swap in alternate address
  space instructions. (ldsba, ldsha, lduba, lduha, lda, stba, stha,
  sta, swapa)

r237582
Sparc: Support PSR, TBR, WIM read/write instructions.

--- lib/Target/Sparc/AsmParser/SparcAsmParser.cpp.orig	Sun Mar  2 21:57:39 2014
+++ lib/Target/Sparc/AsmParser/SparcAsmParser.cpp	Mon May 18 19:47:25 2015
@@@@ -12,9 +12,11 @@@@
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/MC/MCContext.h"
 #include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCObjectFileInfo.h"
 #include "llvm/MC/MCParser/MCParsedAsmOperand.h"
 #include "llvm/MC/MCStreamer.h"
 #include "llvm/MC/MCSubtargetInfo.h"
+#include "llvm/MC/MCSymbol.h"
 #include "llvm/MC/MCTargetAsmParser.h"
 #include "llvm/Support/TargetRegistry.h"
 
@@@@ -66,14 +68,19 @@@@ class SparcAsmParser : public MCTargetAsmParser {
                StringRef Name);
 
   OperandMatchResultTy
-  parseSparcAsmOperand(SparcOperand *&Operand);
+  parseSparcAsmOperand(SparcOperand *&Operand, bool isCall = false);
 
+  OperandMatchResultTy
+  parseBranchModifiers(SmallVectorImpl<MCParsedAsmOperand*> &Operands);
+
   // returns true if Tok is matched to a register and returns register in RegNo.
   bool matchRegisterName(const AsmToken &Tok, unsigned &RegNo,
                          unsigned &RegKind);
 
   bool matchSparcAsmModifiers(const MCExpr *&EVal, SMLoc &EndLoc);
+  bool parseDirectiveWord(unsigned Size, SMLoc L);
 
+  bool is64Bit() const { return STI.getTargetTriple().startswith("sparcv9"); }
 public:
   SparcAsmParser(MCSubtargetInfo &sti, MCAsmParser &parser,
                 const MCInstrInfo &MII)
@@@@ -120,6 +127,15 @@@@ class SparcAsmParser : public MCTargetAsmParser {
     Sparc::Q8,  Sparc::Q9,  Sparc::Q10, Sparc::Q11,
     Sparc::Q12, Sparc::Q13, Sparc::Q14, Sparc::Q15 };
 
+  static unsigned ASRRegs[32] = {
+    SP::Y,     SP::ASR1,  SP::ASR2,  SP::ASR3,
+    SP::ASR4,  SP::ASR5,  SP::ASR6, SP::ASR7,
+    SP::ASR8,  SP::ASR9,  SP::ASR10, SP::ASR11,
+    SP::ASR12, SP::ASR13, SP::ASR14, SP::ASR15,
+    SP::ASR16, SP::ASR17, SP::ASR18, SP::ASR19,
+    SP::ASR20, SP::ASR21, SP::ASR22, SP::ASR23,
+    SP::ASR24, SP::ASR25, SP::ASR26, SP::ASR27,
+    SP::ASR28, SP::ASR29, SP::ASR30, SP::ASR31};
 
 /// SparcOperand - Instances of this class represent a parsed Sparc machine
 /// instruction.
@@@@ -131,9 +147,9 @@@@ class SparcOperand : public MCParsedAsmOperand { (publ
     rk_FloatReg,
     rk_DoubleReg,
     rk_QuadReg,
-    rk_CCReg,
-    rk_Y
+    rk_Special
   };
+
 private:
   enum KindTy {
     k_Token,
@@@@ -354,13 +370,11 @@@@ class SparcOperand : public MCParsedAsmOperand { (publ
     return Op;
   }
 
-  static SparcOperand *CreateMEMri(unsigned Base,
-                                 const MCExpr *Off,
-                                 SMLoc S, SMLoc E) {
-    SparcOperand *Op = new SparcOperand(k_MemoryImm);
+  static SparcOperand *CreateMEMr(unsigned Base, SMLoc S, SMLoc E) {
+    SparcOperand *Op = new SparcOperand(k_MemoryReg);
     Op->Mem.Base = Base;
-    Op->Mem.OffsetReg = 0;
-    Op->Mem.Off = Off;
+    Op->Mem.OffsetReg = Sparc::G0;  // always 0
+    Op->Mem.Off = 0;
     Op->StartLoc = S;
     Op->EndLoc = E;
     return Op;
@@@@ -415,7 +429,7 @@@@ MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
     return Error(ErrorLoc, "invalid operand for instruction");
   }
   case Match_MnemonicFail:
-    return Error(IDLoc, "invalid instruction");
+    return Error(IDLoc, "invalid instruction mnemonic");
   }
   return true;
 }
@@@@ -439,21 +453,30 @@@@ ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc 
   return Error(StartLoc, "invalid register name");
 }
 
+static void applyMnemonicAliases(StringRef &Mnemonic, unsigned Features,
+                                 unsigned VariantID);
+
 bool SparcAsmParser::
 ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
                  SMLoc NameLoc,
                  SmallVectorImpl<MCParsedAsmOperand*> &Operands)
 {
-  // Check if we have valid mnemonic.
-  if (!mnemonicIsValid(Name, 0)) {
-    Parser.eatToEndOfStatement();
-    return Error(NameLoc, "Unknown instruction");
-  }
+
   // First operand in MCInst is instruction mnemonic.
   Operands.push_back(SparcOperand::CreateToken(Name, NameLoc));
 
+  // apply mnemonic aliases, if any, so that we can parse operands correctly.
+  applyMnemonicAliases(Name, getAvailableFeatures(), 0);
+
   if (getLexer().isNot(AsmToken::EndOfStatement)) {
     // Read the first operand.
+    if (getLexer().is(AsmToken::Comma)) {
+      if (parseBranchModifiers(Operands) != MatchOperand_Success) {
+        SMLoc Loc = getLexer().getLoc();
+        Parser.eatToEndOfStatement();
+        return Error(Loc, "unexpected token");
+      }
+    }
     if (parseOperand(Operands, Name) != MatchOperand_Success) {
       SMLoc Loc = getLexer().getLoc();
       Parser.eatToEndOfStatement();
@@@@ -482,8 +505,52 @@@@ ParseInstruction(ParseInstructionInfo &Info, StringRef
 bool SparcAsmParser::
 ParseDirective(AsmToken DirectiveID)
 {
-  // Ignore all directives for now.
-  Parser.eatToEndOfStatement();
+  StringRef IDVal = DirectiveID.getString();
+
+  if (IDVal == ".byte")
+    return parseDirectiveWord(1, DirectiveID.getLoc());
+
+  if (IDVal == ".half")
+    return parseDirectiveWord(2, DirectiveID.getLoc());
+
+  if (IDVal == ".word")
+    return parseDirectiveWord(4, DirectiveID.getLoc());
+
+  if (IDVal == ".nword")
+    return parseDirectiveWord(is64Bit() ? 8 : 4, DirectiveID.getLoc());
+
+  if (is64Bit() && IDVal == ".xword")
+    return parseDirectiveWord(8, DirectiveID.getLoc());
+
+  if (IDVal == ".register") {
+    // For now, ignore .register directive.
+    Parser.eatToEndOfStatement();
+    return false;
+  }
+
+  // Let the MC layer to handle other directives.
+  return true;
+}
+
+bool SparcAsmParser:: parseDirectiveWord(unsigned Size, SMLoc L) {
+  if (getLexer().isNot(AsmToken::EndOfStatement)) {
+    for (;;) {
+      const MCExpr *Value;
+      if (getParser().parseExpression(Value))
+        return true;
+
+      getParser().getStreamer().EmitValue(Value, Size);
+
+      if (getLexer().is(AsmToken::EndOfStatement))
+        break;
+
+      // FIXME: Improve diagnostic.
+      if (getLexer().isNot(AsmToken::Comma))
+        return Error(L, "unexpected token in directive");
+      Parser.Lex();
+    }
+  }
+  Parser.Lex();
   return false;
 }
 
@@@@ -504,7 +571,7 @@@@ parseMEMOperand(SmallVectorImpl<MCParsedAsmOperand*> &
   case AsmToken::Comma:
   case AsmToken::RBrac:
   case AsmToken::EndOfStatement:
-    Operands.push_back(SparcOperand::CreateMEMri(BaseReg, 0, S, E));
+    Operands.push_back(SparcOperand::CreateMEMr(BaseReg, S, E));
     return MatchOperand_Success;
 
   case AsmToken:: Plus:
@@@@ -573,11 +640,21 @@@@ parseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Ope
     Operands.push_back(SparcOperand::CreateToken("]",
                                                  Parser.getTok().getLoc()));
     Parser.Lex(); // Eat the ]
+
+    // Parse an optional address-space identifier after the address.
+    if (getLexer().is(AsmToken::Integer)) {
+      SparcOperand *Op = 0;
+      ResTy = parseSparcAsmOperand(Op, false);
+      if (ResTy != MatchOperand_Success || !Op)
+        return MatchOperand_ParseFail;
+      Operands.push_back(Op);
+    }
     return MatchOperand_Success;
   }
 
   SparcOperand *Op = 0;
-  ResTy = parseSparcAsmOperand(Op);
+
+  ResTy = parseSparcAsmOperand(Op, (Mnemonic == "call"));
   if (ResTy != MatchOperand_Success || !Op)
     return MatchOperand_ParseFail;
 
@@@@ -588,7 +665,7 @@@@ parseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Ope
 }
 
 SparcAsmParser::OperandMatchResultTy
-SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op)
+SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op, bool isCall)
 {
 
   SMLoc S = Parser.getTok().getLoc();
@@@@ -611,21 +688,21 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
       default:
         Op = SparcOperand::CreateReg(RegNo, RegKind, S, E);
         break;
-      case Sparc::Y:
-        Op = SparcOperand::CreateToken("%y", S);
+      case Sparc::PSR:
+        Op = SparcOperand::CreateToken("%psr", S);
         break;
-
+      case Sparc::WIM:
+        Op = SparcOperand::CreateToken("%wim", S);
+        break;
+      case Sparc::TBR:
+        Op = SparcOperand::CreateToken("%tbr", S);
+        break;
       case Sparc::ICC:
         if (name == "xcc")
           Op = SparcOperand::CreateToken("%xcc", S);
         else
           Op = SparcOperand::CreateToken("%icc", S);
         break;
-
-      case Sparc::FCC:
-        assert(name == "fcc0" && "Cannot handle %fcc other than %fcc0 yet");
-        Op = SparcOperand::CreateToken("%fcc0", S);
-        break;
       }
       break;
     }
@@@@ -637,6 +714,7 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
 
   case AsmToken::Minus:
   case AsmToken::Integer:
+  case AsmToken::LParen:
     if (!getParser().parseExpression(EVal, E))
       Op = SparcOperand::CreateImm(EVal, S, E);
     break;
@@@@ -649,6 +727,10 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
 
       const MCExpr *Res = MCSymbolRefExpr::Create(Sym, MCSymbolRefExpr::VK_None,
                                                   getContext());
+      if (isCall &&
+          getContext().getObjectFileInfo()->getRelocM() == Reloc::PIC_)
+        Res = SparcMCExpr::Create(SparcMCExpr::VK_Sparc_WPLT30, Res,
+                                  getContext());
       Op = SparcOperand::CreateImm(Res, S, E);
     }
     break;
@@@@ -657,6 +739,27 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
   return (Op) ? MatchOperand_Success : MatchOperand_ParseFail;
 }
 
+SparcAsmParser::OperandMatchResultTy SparcAsmParser::
+parseBranchModifiers(SmallVectorImpl<MCParsedAsmOperand*> &Operands) {
+
+  // parse (,a|,pn|,pt)+
+
+  while (getLexer().is(AsmToken::Comma)) {
+
+    Parser.Lex(); // Eat the comma
+
+    if (!getLexer().is(AsmToken::Identifier))
+      return MatchOperand_ParseFail;
+    StringRef modName = Parser.getTok().getString();
+    if (modName == "a" || modName == "pn" || modName == "pt") {
+      Operands.push_back(SparcOperand::CreateToken(modName,
+                                                   Parser.getTok().getLoc()));
+      Parser.Lex(); // eat the identifier.
+    }
+  }
+  return MatchOperand_Success;
+}
+
 bool SparcAsmParser::matchRegisterName(const AsmToken &Tok,
                                        unsigned &RegNo,
                                        unsigned &RegKind)
@@@@ -682,20 +785,46 @@@@ bool SparcAsmParser::matchRegisterName(const AsmToken 
 
     if (name.equals("y")) {
       RegNo = Sparc::Y;
-      RegKind = SparcOperand::rk_Y;
+      RegKind = SparcOperand::rk_Special;
       return true;
     }
 
+    if (name.substr(0, 3).equals_lower("asr")
+        && !name.substr(3).getAsInteger(10, intVal)
+        && intVal > 0 && intVal < 32) {
+      RegNo = ASRRegs[intVal];
+      RegKind = SparcOperand::rk_Special;
+      return true;
+    }
+
     if (name.equals("icc")) {
       RegNo = Sparc::ICC;
-      RegKind = SparcOperand::rk_CCReg;
+      RegKind = SparcOperand::rk_Special;
       return true;
     }
 
+    if (name.equals("psr")) {
+      RegNo = Sparc::PSR;
+      RegKind = SparcOperand::rk_Special;
+      return true;
+    }
+
+    if (name.equals("wim")) {
+      RegNo = Sparc::WIM;
+      RegKind = SparcOperand::rk_Special;
+      return true;
+    }
+
+    if (name.equals("tbr")) {
+      RegNo = Sparc::TBR;
+      RegKind = SparcOperand::rk_Special;
+      return true;
+    }
+
     if (name.equals("xcc")) {
       // FIXME:: check 64bit.
       RegNo = Sparc::ICC;
-      RegKind = SparcOperand::rk_CCReg;
+      RegKind = SparcOperand::rk_Special;
       return true;
     }
 
@@@@ -704,8 +833,8 @@@@ bool SparcAsmParser::matchRegisterName(const AsmToken 
         && !name.substr(3).getAsInteger(10, intVal)
         && intVal < 4) {
       // FIXME: check 64bit and  handle %fcc1 - %fcc3
-      RegNo = Sparc::FCC;
-      RegKind = SparcOperand::rk_CCReg;
+      RegNo = Sparc::FCC0 + intVal;
+      RegKind = SparcOperand::rk_Special;
       return true;
     }
 
@@@@ -767,7 +896,32 @@@@ bool SparcAsmParser::matchRegisterName(const AsmToken 
   return false;
 }
 
+static bool hasGOTReference(const MCExpr *Expr) {
+  switch (Expr->getKind()) {
+  case MCExpr::Target:
+    if (const SparcMCExpr *SE = dyn_cast<SparcMCExpr>(Expr))
+      return hasGOTReference(SE->getSubExpr());
+    break;
 
+  case MCExpr::Constant:
+    break;
+
+  case MCExpr::Binary: {
+    const MCBinaryExpr *BE = cast<MCBinaryExpr>(Expr);
+    return hasGOTReference(BE->getLHS()) || hasGOTReference(BE->getRHS());
+  }
+
+  case MCExpr::SymbolRef: {
+    const MCSymbolRefExpr &SymRef = *cast<MCSymbolRefExpr>(Expr);
+    return (SymRef.getSymbol().getName() == "_GLOBAL_OFFSET_TABLE_");
+  }
+
+  case MCExpr::Unary:
+    return hasGOTReference(cast<MCUnaryExpr>(Expr)->getSubExpr());
+  }
+  return false;
+}
+
 bool SparcAsmParser::matchSparcAsmModifiers(const MCExpr *&EVal,
                                             SMLoc &EndLoc)
 {
@@@@ -790,6 +944,23 @@@@ bool SparcAsmParser::matchSparcAsmModifiers(const MCEx
   const MCExpr *subExpr;
   if (Parser.parseParenExpression(subExpr, EndLoc))
     return false;
+
+  bool isPIC = getContext().getObjectFileInfo()->getRelocM() == Reloc::PIC_;
+
+  switch(VK) {
+  default: break;
+  case SparcMCExpr::VK_Sparc_LO:
+    VK =  (hasGOTReference(subExpr)
+           ? SparcMCExpr::VK_Sparc_PC10
+           : (isPIC ? SparcMCExpr::VK_Sparc_GOT10 : VK));
+    break;
+  case SparcMCExpr::VK_Sparc_HI:
+    VK =  (hasGOTReference(subExpr)
+           ? SparcMCExpr::VK_Sparc_PC22
+           : (isPIC ? SparcMCExpr::VK_Sparc_GOT22 : VK));
+    break;
+  }
+
   EVal = SparcMCExpr::Create(VK, subExpr, getContext());
   return true;
 }
@


1.3
log
@Backport commits from upstream LLVM.

r237580
Add support for the Sparc implementation-defined "ASR" registers.

r237581
Sparc: Add the "alternate address space" load/store instructions.

- Adds support for the asm syntax, which has an immediate integer
  "ASI" (address space identifier) appearing after an address, before
  a comma.

- Adds the various-width load, store, and swap in alternate address
  space instructions. (ldsba, ldsha, lduba, lduha, lda, stba, stha,
  sta, swapa)

r237582
Sparc: Support PSR, TBR, WIM read/write instructions

from brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_Target_Sparc_AsmParser_SparcAsmParser_cpp,v 1.2 2015/05/11 23:21:51 ajacoutot Exp $
@


1.2
log
@Backport commits from upstream LLVM.

r236042
Sparc: Add alternate aliases for conditional branch instructions.

r236107
Sparc: Prefer reg+reg address encoding when only one register used.

r236137
Make Sparc assembler accept parenthesized constant expressions.

from brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_Target_Sparc_AsmParser_SparcAsmParser_cpp,v 1.1 2014/07/11 01:05:24 brad Exp $
d16 17
d34 1
a34 1
+++ lib/Target/Sparc/AsmParser/SparcAsmParser.cpp	Thu Apr 30 02:49:39 2015
d68 29
a96 1
@@@@ -354,13 +361,11 @@@@ class SparcOperand : public MCParsedAsmOperand { (publ
d114 1
a114 1
@@@@ -415,7 +420,7 @@@@ MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
d123 1
a123 1
@@@@ -439,21 +444,30 @@@@ ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc 
d159 1
a159 1
@@@@ -482,8 +496,52 @@@@ ParseInstruction(ParseInstructionInfo &Info, StringRef
d214 1
a214 1
@@@@ -504,7 +562,7 @@@@ parseMEMOperand(SmallVectorImpl<MCParsedAsmOperand*> &
d223 14
a236 1
@@@@ -577,7 +635,8 @@@@ parseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Ope
d246 1
a246 1
@@@@ -588,7 +647,7 @@@@ parseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Ope
d255 19
a273 1
@@@@ -621,11 +680,6 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
d285 1
a285 1
@@@@ -637,6 +691,7 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
d293 1
a293 1
@@@@ -649,6 +704,10 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
d304 1
a304 1
@@@@ -657,6 +716,27 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
d332 51
a382 1
@@@@ -704,7 +784,7 @@@@ bool SparcAsmParser::matchRegisterName(const AsmToken 
d387 1
d389 1
a389 1
       RegKind = SparcOperand::rk_CCReg;
d392 2
a393 1
@@@@ -767,7 +847,32 @@@@ bool SparcAsmParser::matchRegisterName(const AsmToken 
d426 1
a426 1
@@@@ -790,6 +895,23 @@@@ bool SparcAsmParser::matchSparcAsmModifiers(const MCEx
@


1.1
log
@Sync up the SPARC backend up to commit r203424.

ok matthew@@
@
text
@d1 1
a1 1
$OpenBSD$
d5 13
a17 2
--- lib/Target/Sparc/AsmParser/SparcAsmParser.cpp.orig	Sun Jun 15 02:46:35 2014
+++ lib/Target/Sparc/AsmParser/SparcAsmParser.cpp	Sun Jun 15 03:00:25 2014
d51 19
a69 1
@@@@ -415,7 +422,7 @@@@ MatchAndEmitInstruction(SMLoc IDLoc, unsigned &Opcode,
d78 1
a78 1
@@@@ -439,21 +446,30 @@@@ ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc 
d114 1
a114 1
@@@@ -482,8 +498,52 @@@@ ParseInstruction(ParseInstructionInfo &Info, StringRef
d169 10
a178 1
@@@@ -577,7 +637,8 @@@@ parseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Ope
d188 1
a188 1
@@@@ -588,7 +649,7 @@@@ parseOperand(SmallVectorImpl<MCParsedAsmOperand*> &Ope
d197 1
a197 1
@@@@ -621,11 +682,6 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
d209 9
a217 1
@@@@ -649,6 +705,10 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
d228 1
a228 1
@@@@ -657,6 +717,27 @@@@ SparcAsmParser::parseSparcAsmOperand(SparcOperand *&Op
d256 1
a256 1
@@@@ -704,7 +785,7 @@@@ bool SparcAsmParser::matchRegisterName(const AsmToken 
d265 1
a265 1
@@@@ -767,7 +848,32 @@@@ bool SparcAsmParser::matchRegisterName(const AsmToken 
d298 1
a298 1
@@@@ -790,6 +896,23 @@@@ bool SparcAsmParser::matchSparcAsmModifiers(const MCEx
@

