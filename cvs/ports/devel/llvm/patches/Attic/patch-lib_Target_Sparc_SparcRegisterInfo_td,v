head	1.3;
access;
symbols
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.4
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.1.0.4
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.2
	OPENBSD_5_6_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2016.03.05.15.31.41;	author pascal;	state dead;
branches;
next	1.2;
commitid	Hqi865xYWk2i2UMI;

1.2
date	2015.05.19.05.33.39;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	pCal9wg5J0ccKDxv;

1.1
date	2014.07.11.01.05.24;	author brad;	state Exp;
branches;
next	;
commitid	HV2dQgWiQjyBoYgQ;


desc
@@


1.3
log
@Update to LLVM 3.7.1.  This version is modified to use C++ includes from
ports GCC and link to libestdc++.

Currently, this still breaks mail/mozilla-thunderbird, which will be taken care
of shortly.

feedback/testing from jsg landry mmcc semarie aja naddy (hope I didn't forget
anyone)

ok landry robert
@
text
@$OpenBSD: patch-lib_Target_Sparc_SparcRegisterInfo_td,v 1.2 2015/05/19 05:33:39 ajacoutot Exp $

Sync up the SPARC backend up to commit r203424.

r237580
Add support for the Sparc implementation-defined "ASR" registers.

r237582
Sparc: Support PSR, TBR, WIM read/write instructions.

--- lib/Target/Sparc/SparcRegisterInfo.td.orig	Sun Mar  2 21:57:39 2014
+++ lib/Target/Sparc/SparcRegisterInfo.td	Mon May 18 18:32:12 2015
@@@@ -16,7 +16,8 @@@@ class SparcReg<bits<16> Enc, string n> : Register<n> {
   let Namespace = "SP";
 }
 
-class SparcCtrlReg<string n>: Register<n> {
+class SparcCtrlReg<bits<16> Enc, string n>: Register<n> {
+  let HWEncoding = Enc;
   let Namespace = "SP";
 }
 
@@@@ -49,12 +50,50 @@@@ class Rq<bits<16> Enc, string n, list<Register> subreg
 }
 
 // Control Registers
-def ICC : SparcCtrlReg<"ICC">; // This represents icc and xcc in 64-bit code.
-def FCC : SparcCtrlReg<"FCC">;
+def ICC : SparcCtrlReg<0, "ICC">; // This represents icc and xcc in 64-bit code.
+foreach I = 0-3 in
+  def FCC#I : SparcCtrlReg<I, "FCC"#I>;
 
 // Y register
-def Y : SparcCtrlReg<"Y">, DwarfRegNum<[64]>;
+def Y : SparcCtrlReg<0, "Y">, DwarfRegNum<[64]>;
+// Ancillary state registers (implementation defined)
+def ASR1 : SparcCtrlReg<1, "ASR1">;
+def ASR2 : SparcCtrlReg<2, "ASR2">;
+def ASR3 : SparcCtrlReg<3, "ASR3">;
+def ASR4 : SparcCtrlReg<4, "ASR4">;
+def ASR5 : SparcCtrlReg<5, "ASR5">;
+def ASR6 : SparcCtrlReg<6, "ASR6">;
+def ASR7 : SparcCtrlReg<7, "ASR7">;
+def ASR8 : SparcCtrlReg<8, "ASR8">;
+def ASR9 : SparcCtrlReg<9, "ASR9">;
+def ASR10 : SparcCtrlReg<10, "ASR10">;
+def ASR11 : SparcCtrlReg<11, "ASR11">;
+def ASR12 : SparcCtrlReg<12, "ASR12">;
+def ASR13 : SparcCtrlReg<13, "ASR13">;
+def ASR14 : SparcCtrlReg<14, "ASR14">;
+def ASR15 : SparcCtrlReg<15, "ASR15">;
+def ASR16 : SparcCtrlReg<16, "ASR16">;
+def ASR17 : SparcCtrlReg<17, "ASR17">;
+def ASR18 : SparcCtrlReg<18, "ASR18">;
+def ASR19 : SparcCtrlReg<19, "ASR19">;
+def ASR20 : SparcCtrlReg<20, "ASR20">;
+def ASR21 : SparcCtrlReg<21, "ASR21">;
+def ASR22 : SparcCtrlReg<22, "ASR22">;
+def ASR23 : SparcCtrlReg<23, "ASR23">;
+def ASR24 : SparcCtrlReg<24, "ASR24">;
+def ASR25 : SparcCtrlReg<25, "ASR25">;
+def ASR26 : SparcCtrlReg<26, "ASR26">;
+def ASR27 : SparcCtrlReg<27, "ASR27">;
+def ASR28 : SparcCtrlReg<28, "ASR28">;
+def ASR29 : SparcCtrlReg<29, "ASR29">;
+def ASR30 : SparcCtrlReg<30, "ASR30">;
+def ASR31 : SparcCtrlReg<31, "ASR31">;
 
+// Note that PSR, WIM, and TBR don't exist on the SparcV9, only the V8.
+def PSR : SparcCtrlReg<0, "PSR">;
+def WIM : SparcCtrlReg<0, "WIM">;
+def TBR : SparcCtrlReg<0, "TBR">;
+
 // Integer registers
 def G0 : Ri< 0, "G0">, DwarfRegNum<[0]>;
 def G1 : Ri< 1, "G1">, DwarfRegNum<[1]>;
@@@@ -204,3 +243,10 @@@@ def FPRegs : RegisterClass<"SP", [f32], 32, (sequence 
 def DFPRegs : RegisterClass<"SP", [f64], 64, (sequence "D%u", 0, 31)>;
 
 def QFPRegs : RegisterClass<"SP", [f128], 128, (sequence "Q%u", 0, 15)>;
+
+// Floating point control register classes.
+def FCCRegs : RegisterClass<"SP", [i1], 1, (sequence "FCC%u", 0, 3)>;
+
+// Ancillary state registers
+def ASRRegs : RegisterClass<"SP", [i32], 32,
+                            (add Y, (sequence "ASR%u", 1, 31))>;
@


1.2
log
@Backport commits from upstream LLVM.

r237580
Add support for the Sparc implementation-defined "ASR" registers.

r237581
Sparc: Add the "alternate address space" load/store instructions.

- Adds support for the asm syntax, which has an immediate integer
  "ASI" (address space identifier) appearing after an address, before
  a comma.

- Adds the various-width load, store, and swap in alternate address
  space instructions. (ldsba, ldsha, lduba, lduha, lda, stba, stha,
  sta, swapa)

r237582
Sparc: Support PSR, TBR, WIM read/write instructions

from brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_Target_Sparc_SparcRegisterInfo_td,v 1.1 2014/07/11 01:05:24 brad Exp $
@


1.1
log
@Sync up the SPARC backend up to commit r203424.

ok matthew@@
@
text
@d1 1
a1 1
$OpenBSD$
d5 8
a12 2
--- lib/Target/Sparc/SparcRegisterInfo.td.orig	Sun Jun 15 02:47:03 2014
+++ lib/Target/Sparc/SparcRegisterInfo.td	Sun Jun 15 02:57:59 2014
d23 1
a23 1
@@@@ -49,11 +50,12 @@@@ class Rq<bits<16> Enc, string n, list<Register> subreg
d36 38
a73 1
 
d76 2
a77 1
@@@@ -204,3 +206,6 @@@@ def FPRegs : RegisterClass<"SP", [f32], 32, (sequence 
d84 4
@

