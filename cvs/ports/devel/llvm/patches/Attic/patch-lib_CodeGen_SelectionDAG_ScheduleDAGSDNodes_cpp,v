head	1.2;
access;
symbols
	OPENBSD_5_9:1.1.0.6
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.8
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.4
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.2
	OPENBSD_5_6_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2016.03.05.15.31.40;	author pascal;	state dead;
branches;
next	1.1;
commitid	Hqi865xYWk2i2UMI;

1.1
date	2014.07.10.22.46.37;	author brad;	state Exp;
branches;
next	;
commitid	QWL9Lg9Nbr4j1VZM;


desc
@@


1.2
log
@Update to LLVM 3.7.1.  This version is modified to use C++ includes from
ports GCC and link to libestdc++.

Currently, this still breaks mail/mozilla-thunderbird, which will be taken care
of shortly.

feedback/testing from jsg landry mmcc semarie aja naddy (hope I didn't forget
anyone)

ok landry robert
@
text
@$OpenBSD: patch-lib_CodeGen_SelectionDAG_ScheduleDAGSDNodes_cpp,v 1.1 2014/07/10 22:46:37 brad Exp $

r205738
Put a limit on ScheduleDAGSDNodes::ClusterNeighboringLoads to avoid blowing up compile time.

Fixes PR16365 - Extremely slow compilation in -O1 and -O2.

The SD scheduler has a quadratic implementation of load clustering
which absolutely blows up compile time for large blocks with constant
pool loads. The MI scheduler has a better implementation of load
clustering. However, we have not done the work yet to completely
eliminate the SD scheduler. Some benchmarks still seem to benefit from
early load clustering, although maybe by chance.

As an intermediate term fix, I just put a nice limit on the number of
DAG users to search before finding a match. With this limit there are no
binary differences in the LLVM test suite, and the PR16365 test case
does not suffer any compile time impact from this routine.

--- lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp.orig	Sun Mar  2 21:57:42 2014
+++ lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp	Sat Jun 14 04:01:39 2014
@@@@ -219,8 +219,11 @@@@ void ScheduleDAGSDNodes::ClusterNeighboringLoads(SDNod
   DenseMap<long long, SDNode*> O2SMap;  // Map from offset to SDNode.
   bool Cluster = false;
   SDNode *Base = Node;
+  // This algorithm requires a reasonably low use count before finding a match
+  // to avoid uselessly blowing up compile time in large blocks.
+  unsigned UseCount = 0;
   for (SDNode::use_iterator I = Chain->use_begin(), E = Chain->use_end();
-       I != E; ++I) {
+       I != E && UseCount < 100; ++I, ++UseCount) {
     SDNode *User = *I;
     if (User == Node || !Visited.insert(User))
       continue;
@@@@ -237,6 +240,8 @@@@ void ScheduleDAGSDNodes::ClusterNeighboringLoads(SDNod
     if (Offset2 < Offset1)
       Base = User;
     Cluster = true;
+    // Reset UseCount to allow more matches.
+    UseCount = 0;
   }
 
   if (!Cluster)
@


1.1
log
@Bring in fixes from 3.4.1 / 3.4.2 that do not already exist in the
3.5 snapshot (which around 60% of them did)..

r203025, r203050, r203054, r203281, r203581, r203719, r203818, r204155, r204304,
r205067, r205630, r205738, r207990, r208501.

ok matthew@@
@
text
@d1 1
a1 1
$OpenBSD$
@

