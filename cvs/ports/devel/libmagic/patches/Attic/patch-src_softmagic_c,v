head	1.5;
access;
symbols
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_4:1.5.0.2
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.6
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2;
locks; strict;
comment	@# @;


1.5
date	2010.06.16.12.22.45;	author ajacoutot;	state dead;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2009.04.04.18.28.15;	author rui;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.25.20.43.56;	author rui;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.08.17.49.40;	author rui;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.17.21.43.20;	author jolan;	state Exp;
branches;
next	;

1.5.2.1
date	2014.03.18.14.04.33;	author jasper;	state Exp;
branches;
next	;

1.5.4.1
date	2014.03.18.14.04.46;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Remove now unused patch -- we have strndup(3).
No bump because because code was #ifndef HAVE_STRNDUP ... so it wasn't
picked up anymore.
@
text
@$OpenBSD: patch-src_softmagic_c,v 1.4 2009/04/04 18:28:15 rui Exp $
--- src/softmagic.c.orig	Fri Nov  7 22:50:37 2008
+++ src/softmagic.c	Sat Mar 28 13:22:45 2009
@@@@ -331,21 +331,26 @@@@ check_fmt(struct magic_set *ms, struct magic *m)
 
 #ifndef HAVE_STRNDUP
 char * strndup(const char *, size_t);
+size_t strnlen (const char *, size_t);
 
+size_t
+strnlen (const char *string, size_t maxlen)
+{
+  const char *end = memchr (string, '\0', maxlen);
+  return end ? (size_t) (end - string) : maxlen;
+}
+
 char *
 strndup(const char *str, size_t n)
 {
-	size_t len;
-	char *copy;
+	size_t len = strnlen (str, n);
+	char *copy = malloc (len + 1);
 
-	len = strlen(str);
-	if (len > n)
-		len = n;
-	if (!(copy = malloc(len + 1)))
-		return (NULL);
-	(void) memcpy(copy, str, len + 1);
+	if (copy == NULL)
+		return NULL;
+
 	copy[len] = '\0';
-	return (copy);
+	return memcpy (copy, str, len); 
 }
 #endif /* HAVE_STRNDUP */
 
@


1.5.4.1
log
@Security fix for CVE-2014-2270,
out-of-bounds memory access when parsing Portable Executable (PE) format files
@
text
@d1 38
a38 10
$OpenBSD$

Security fix for CVE-2014-2270,
out-of-bounds memory access when parsing Portable Executable (PE) format files

--- src/softmagic.c.orig	Thu May 30 17:53:33 2013
+++ src/softmagic.c	Tue Mar 18 07:03:07 2014
@@@@ -62,6 +62,7 @@@@ private void cvt_16(union VALUETYPE *, const struct ma
 private void cvt_32(union VALUETYPE *, const struct magic *);
 private void cvt_64(union VALUETYPE *, const struct magic *);
a39 139
+#define OFFSET_OOB(n, o, i)	((n) < (o) || (i) >= ((n) - (o)))
 /*
  * softmagic - lookup one file in parsed, in-memory copy of database
  * Passed the name and FILE * of one file to be typed.
@@@@ -1190,7 +1191,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 		}
 		switch (in_type = cvt_flip(m->in_type, flip)) {
 		case FILE_BYTE:
-			if (nbytes < offset || nbytes < (offset + 1))
+			if (OFFSET_OOB(nbytes, offset, 1))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1225,7 +1226,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 				offset = ~offset;
 			break;
 		case FILE_BESHORT:
-			if (nbytes < offset || nbytes < (offset + 2))
+			if (OFFSET_OOB(nbytes, offset, 2))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1277,7 +1278,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 				offset = ~offset;
 			break;
 		case FILE_LESHORT:
-			if (nbytes < offset || nbytes < (offset + 2))
+			if (OFFSET_OOB(nbytes, offset, 2))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1329,7 +1330,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 				offset = ~offset;
 			break;
 		case FILE_SHORT:
-			if (nbytes < offset || nbytes < (offset + 2))
+			if (OFFSET_OOB(nbytes, offset, 2))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1366,7 +1367,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 			break;
 		case FILE_BELONG:
 		case FILE_BEID3:
-			if (nbytes < offset || nbytes < (offset + 4))
+			if (OFFSET_OOB(nbytes, offset, 4))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1437,7 +1438,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 			break;
 		case FILE_LELONG:
 		case FILE_LEID3:
-			if (nbytes < offset || nbytes < (offset + 4))
+			if (OFFSET_OOB(nbytes, offset, 4))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1507,7 +1508,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 				offset = ~offset;
 			break;
 		case FILE_MELONG:
-			if (nbytes < offset || nbytes < (offset + 4))
+			if (OFFSET_OOB(nbytes, offset, 4))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1577,7 +1578,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 				offset = ~offset;
 			break;
 		case FILE_LONG:
-			if (nbytes < offset || nbytes < (offset + 4))
+			if (OFFSET_OOB(nbytes, offset, 4))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1654,14 +1655,14 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 	/* Verify we have enough data to match magic type */
 	switch (m->type) {
 	case FILE_BYTE:
-		if (nbytes < (offset + 1)) /* should alway be true */
+		if (OFFSET_OOB(nbytes, offset, 1))
 			return 0;
 		break;
 
 	case FILE_SHORT:
 	case FILE_BESHORT:
 	case FILE_LESHORT:
-		if (nbytes < (offset + 2))
+		if (OFFSET_OOB(nbytes, offset, 2))
 			return 0;
 		break;
 
@@@@ -1680,31 +1681,31 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 	case FILE_FLOAT:
 	case FILE_BEFLOAT:
 	case FILE_LEFLOAT:
-		if (nbytes < (offset + 4))
+		if (OFFSET_OOB(nbytes, offset, 4))
 			return 0;
 		break;
 
 	case FILE_DOUBLE:
 	case FILE_BEDOUBLE:
 	case FILE_LEDOUBLE:
-		if (nbytes < (offset + 8))
+		if (OFFSET_OOB(nbytes, offset, 8))
 			return 0;
 		break;
 
 	case FILE_STRING:
 	case FILE_PSTRING:
 	case FILE_SEARCH:
-		if (nbytes < (offset + m->vallen))
+		if (OFFSET_OOB(nbytes, offset, m->vallen))
 			return 0;
 		break;
 
 	case FILE_REGEX:
-		if (nbytes < offset)
+		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
 		break;
 
 	case FILE_INDIRECT:
-		if (nbytes < offset)
+		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
 		sbuf = ms->o.buf;
 		soffset = ms->offset;
@@@@ -1728,7 +1729,7 @@@@ mget(struct magic_set *ms, const unsigned char *s, str
 		return rv;
 
 	case FILE_USE:
-		if (nbytes < offset)
+		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
 		sbuf = m->value.s;
 		if (*sbuf == '^') {
@


1.5.2.1
log
@Security fix for CVE-2014-2270,
out-of-bounds memory access when parsing Portable Executable (PE) format files
@
text
@d1 38
a38 10
$OpenBSD$

Security fix for CVE-2014-2270,
out-of-bounds memory access when parsing Portable Executable (PE) format files

--- src/softmagic.c.orig	Sat Dec 17 18:17:18 2011
+++ src/softmagic.c	Fri Mar 14 16:54:01 2014
@@@@ -60,6 +60,7 @@@@ private void cvt_16(union VALUETYPE *, const struct ma
 private void cvt_32(union VALUETYPE *, const struct magic *);
 private void cvt_64(union VALUETYPE *, const struct magic *);
a39 133
+#define OFFSET_OOB(n, o, i)	((n) < (o) || (i) >= ((n) - (o)))
 /*
  * softmagic - lookup one file in parsed, in-memory copy of database
  * Passed the name and FILE * of one file to be typed.
@@@@ -1073,7 +1074,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 		}
 		switch (m->in_type) {
 		case FILE_BYTE:
-			if (nbytes < (offset + 1))
+			if (OFFSET_OOB(nbytes, offset, 1))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1108,7 +1109,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 				offset = ~offset;
 			break;
 		case FILE_BESHORT:
-			if (nbytes < (offset + 2))
+			if (OFFSET_OOB(nbytes, offset, 2))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1160,7 +1161,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 				offset = ~offset;
 			break;
 		case FILE_LESHORT:
-			if (nbytes < (offset + 2))
+			if (OFFSET_OOB(nbytes, offset, 2))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1212,7 +1213,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 				offset = ~offset;
 			break;
 		case FILE_SHORT:
-			if (nbytes < (offset + 2))
+			if (OFFSET_OOB(nbytes, offset, 2))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1249,7 +1250,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 			break;
 		case FILE_BELONG:
 		case FILE_BEID3:
-			if (nbytes < (offset + 4))
+			if (OFFSET_OOB(nbytes, offset, 4))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1320,7 +1321,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 			break;
 		case FILE_LELONG:
 		case FILE_LEID3:
-			if (nbytes < (offset + 4))
+			if (OFFSET_OOB(nbytes, offset, 4))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1390,7 +1391,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 				offset = ~offset;
 			break;
 		case FILE_MELONG:
-			if (nbytes < (offset + 4))
+			if (OFFSET_OOB(nbytes, offset, 4))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1460,7 +1461,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 				offset = ~offset;
 			break;
 		case FILE_LONG:
-			if (nbytes < (offset + 4))
+			if (OFFSET_OOB(nbytes, offset, 4))
 				return 0;
 			if (off) {
 				switch (m->in_op & FILE_OPS_MASK) {
@@@@ -1527,14 +1528,14 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 	/* Verify we have enough data to match magic type */
 	switch (m->type) {
 	case FILE_BYTE:
-		if (nbytes < (offset + 1)) /* should alway be true */
+		if (OFFSET_OOB(nbytes, offset, 1))
 			return 0;
 		break;
 
 	case FILE_SHORT:
 	case FILE_BESHORT:
 	case FILE_LESHORT:
-		if (nbytes < (offset + 2))
+		if (OFFSET_OOB(nbytes, offset, 2))
 			return 0;
 		break;
 
@@@@ -1553,26 +1554,26 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 	case FILE_FLOAT:
 	case FILE_BEFLOAT:
 	case FILE_LEFLOAT:
-		if (nbytes < (offset + 4))
+		if (OFFSET_OOB(nbytes, offset, 4))
 			return 0;
 		break;
 
 	case FILE_DOUBLE:
 	case FILE_BEDOUBLE:
 	case FILE_LEDOUBLE:
-		if (nbytes < (offset + 8))
+		if (OFFSET_OOB(nbytes, offset, 8))
 			return 0;
 		break;
 
 	case FILE_STRING:
 	case FILE_PSTRING:
 	case FILE_SEARCH:
-		if (nbytes < (offset + m->vallen))
+		if (OFFSET_OOB(nbytes, offset, m->vallen))
 			return 0;
 		break;
 
 	case FILE_REGEX:
-		if (nbytes < offset)
+		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
 		break;
 
@@@@ -1580,7 +1581,7 @@@@ mget(struct magic_set *ms, const unsigned char *s,
 	  	if ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&
 		    file_printf(ms, "%s", m->desc) == -1)
 			return -1;
-		if (nbytes < offset)
+		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
 		return file_softmagic(ms, s + offset, nbytes - offset,
 		    BINTEST, text);
@


1.4
log
@- update to 5.00, based on initial diff from Benoit Lecocq.
- fix build on Vax while here

ok naddy@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_softmagic_c,v 1.3 2008/09/25 20:43:56 rui Exp $
@


1.3
log
@- maintenance update to libmagic 4.26.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_softmagic_c,v 1.2 2007/06/08 17:49:40 rui Exp $
--- src/softmagic.c.orig	Mon Jul 28 18:25:21 2008
+++ src/softmagic.c	Sat Sep 20 17:24:18 2008
@@@@ -303,21 +303,26 @@@@ check_fmt(struct magic_set *ms, struct magic *m)
@


1.2
log
@update libmagic to 4.21

ok mbalmer@@, ajacoutot@@
@
text
@d1 4
a4 4
$OpenBSD$
--- src/softmagic.c.orig	Tue May  8 15:44:18 2007
+++ src/softmagic.c	Thu Jun  7 23:54:20 2007
@@@@ -288,21 +288,26 @@@@ check_fmt(struct magic_set *ms, struct magic *m)
@


1.1
log
@update to 4.20, from maintainer rui reis
@
text
@d2 3
a4 3
--- src/softmagic.c.orig	Sun Mar  4 21:19:20 2007
+++ src/softmagic.c	Sun Mar  4 21:21:18 2007
@@@@ -314,21 +314,26 @@@@ check_fmt(struct magic_set *ms, struct m
@

