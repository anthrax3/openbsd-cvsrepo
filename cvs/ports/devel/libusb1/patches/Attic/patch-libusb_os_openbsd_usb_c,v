head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.12
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2015.09.15.09.03.53;	author dcoppa;	state dead;
branches;
next	1.5;
commitid	rEDGIyrWWPY5ovqE;

1.5
date	2013.04.22.08.37.20;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.17.14.28.17;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2013.04.12.08.22.10;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.05.10.55.24;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2012.06.19.20.48.55;	author mpi;	state Exp;
branches;
next	;


desc
@@


1.6
log
@
Update to libusb1-1.0.20

OK mpi@@ (maintainer)
@
text
@$OpenBSD: patch-libusb_os_openbsd_usb_c,v 1.5 2013/04/22 08:37:20 mpi Exp $

Add support for non ugen(4) attached devices through usb(4) buses.

--- libusb/os/openbsd_usb.c.orig	Fri Apr 20 08:44:27 2012
+++ libusb/os/openbsd_usb.c	Sun Apr 21 12:39:40 2013
@@@@ -1,5 +1,5 @@@@
 /*
- * Copyright (c) 2011 Martin Pieuchot <mpi@@openbsd.org>
+ * Copyright (c) 2011-2013 Martin Pieuchot <mpi@@openbsd.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@@@ -32,8 +32,8 @@@@
 #include "libusbi.h"
 
 struct device_priv {
-	char devnode[16];
-	int fd;
+	char *devname;				/* name of the ugen(4) node */
+	int fd;					/* device file descriptor */
 
 	unsigned char *cdesc;			/* active config descriptor */
 	usb_device_descriptor_t ddesc;		/* usb device descriptor */
@@@@ -82,11 +82,14 @@@@ static int obsd_clock_gettime(int, struct timespec *);
  * Private functions
  */
 static int _errno_to_libusb(int);
-static int _cache_active_config_descriptor(struct libusb_device *, int);
+static int _cache_active_config_descriptor(struct libusb_device *);
 static int _sync_control_transfer(struct usbi_transfer *);
 static int _sync_gen_transfer(struct usbi_transfer *);
 static int _access_endpoint(struct libusb_transfer *);
 
+static int _bus_open(int);
+
+
 const struct usbi_os_backend openbsd_backend = {
 	"Synchronous OpenBSD backend",
 	NULL,				/* init() */
@@@@ -128,75 +131,105 @@@@ const struct usbi_os_backend openbsd_backend = {
 	0,				/* add_iso_packet_size */
 };
 
+#define DEVPATH	"/dev/"
+#define USBDEV	DEVPATH "usb"
+
 int
 obsd_get_device_list(struct libusb_context * ctx,
 	struct discovered_devs **discdevs)
 {
+	struct discovered_devs *ddd;
 	struct libusb_device *dev;
 	struct device_priv *dpriv;
 	struct usb_device_info di;
+	struct usb_device_ddesc dd;
 	unsigned long session_id;
-	char devnode[16];
-	int fd, err, i;
+	char devices[USB_MAX_DEVICES];
+	char busnode[16];
+	char *udevname;
+	int fd, addr, i, j;
 
 	usbi_dbg("");
 
-	/* Only ugen(4) is supported */
-	for (i = 0; i < USB_MAX_DEVICES; i++) {
-		/* Control endpoint is always .00 */
-		snprintf(devnode, sizeof(devnode), "/dev/ugen%d.00", i);
+	for (i = 0; i < 8; i++) {
+		snprintf(busnode, sizeof(busnode), USBDEV "%d", i);
 
-		if ((fd = open(devnode, O_RDONLY)) < 0) {
+		if ((fd = open(busnode, O_RDWR)) < 0) {
 			if (errno != ENOENT && errno != ENXIO)
-				usbi_err(ctx, "could not open %s", devnode);
+				usbi_err(ctx, "could not open %s", busnode);
 			continue;
 		}
 
-		if (ioctl(fd, USB_GET_DEVICEINFO, &di) < 0)
-			continue;
+		bzero(devices, sizeof(devices));
+		for (addr = 1; addr < USB_MAX_DEVICES; addr++) {
+			if (devices[addr])
+				continue;
 
-		session_id = (di.udi_bus << 8 | di.udi_addr);
-		dev = usbi_get_device_by_session_id(ctx, session_id);
+			di.udi_addr = addr;
+			if (ioctl(fd, USB_DEVICEINFO, &di) < 0)
+				continue;
 
-		if (dev == NULL) {
-			dev = usbi_alloc_device(ctx, session_id);
-			if (dev == NULL)
-				return (LIBUSB_ERROR_NO_MEM);
+			/*
+			 * XXX If ugen(4) is attached to the USB device
+			 * it will be used.
+			 */
+			udevname = NULL;
+			for (j = 0; j < USB_MAX_DEVNAMES; j++)
+				if (!strncmp("ugen", di.udi_devnames[j], 4)) {
+					udevname = strdup(di.udi_devnames[j]);
+					break;
+				}
 
-			dev->bus_number = di.udi_bus;
-			dev->device_address = di.udi_addr;
-			dev->speed = di.udi_speed;
+			session_id = (di.udi_bus << 8 | di.udi_addr);
+			dev = usbi_get_device_by_session_id(ctx, session_id);
 
-			dpriv = (struct device_priv *)dev->os_priv;
-			strlcpy(dpriv->devnode, devnode, sizeof(devnode));
-			dpriv->fd = -1;
+			if (dev == NULL) {
+				dev = usbi_alloc_device(ctx, session_id);
+				if (dev == NULL) {
+					close(fd);
+					return (LIBUSB_ERROR_NO_MEM);
+				}
 
-			if (ioctl(fd, USB_GET_DEVICE_DESC, &dpriv->ddesc) < 0) {
-				err = errno;
-				goto error;
+				dev->bus_number = di.udi_bus;
+				dev->device_address = di.udi_addr;
+				dev->speed = di.udi_speed;
+
+				dpriv = (struct device_priv *)dev->os_priv;
+				dpriv->fd = -1;
+				dpriv->cdesc = NULL;
+				dpriv->devname = udevname;
+
+				dd.udd_bus = di.udi_bus;
+				dd.udd_addr = di.udi_addr;
+				if (ioctl(fd, USB_DEVICE_GET_DDESC, &dd) < 0) {
+					libusb_unref_device(dev);
+					continue;
+				}
+				dpriv->ddesc = dd.udd_desc;
+
+				if (_cache_active_config_descriptor(dev)) {
+					libusb_unref_device(dev);
+					continue;
+				}
+
+				if (usbi_sanitize_device(dev))
+					libusb_unref_device(dev);
 			}
 
-			dpriv->cdesc = NULL;
-			if (_cache_active_config_descriptor(dev, fd)) {
-				err = errno;
-				goto error;
+			ddd = discovered_devs_append(*discdevs, dev);
+			if (ddd == NULL) {
+				close(fd);
+				return (LIBUSB_ERROR_NO_MEM);
 			}
 
-			if ((err = usbi_sanitize_device(dev)))
-				goto error;
+			*discdevs = ddd;
+			devices[addr] = 1;
 		}
-		close(fd);
 
-		if (discovered_devs_append(*discdevs, dev) == NULL)
-			return (LIBUSB_ERROR_NO_MEM);
+		close(fd);
 	}
 
 	return (LIBUSB_SUCCESS);
-
-error:
-	close(fd);
-	libusb_unref_device(dev);
-	return _errno_to_libusb(err);
 }
 
 int
@@@@ -204,16 +237,22 @@@@ obsd_open(struct libusb_device_handle *handle)
 {
 	struct handle_priv *hpriv = (struct handle_priv *)handle->os_priv;
 	struct device_priv *dpriv = (struct device_priv *)handle->dev->os_priv;
+	char devnode[16];
 
-	dpriv->fd = open(dpriv->devnode, O_RDWR);
-	if (dpriv->fd < 0) {
-		dpriv->fd = open(dpriv->devnode, O_RDONLY);
+	if (dpriv->devname) {
+		/*
+		 * Only open ugen(4) attached devices read-write, all
+		 * read-only operations are done through the bus node.
+		 */
+		snprintf(devnode, sizeof(devnode), DEVPATH "%s.00",
+		    dpriv->devname);
+		dpriv->fd = open(devnode, O_RDWR);
 		if (dpriv->fd < 0)
 			return _errno_to_libusb(errno);
+
+		usbi_dbg("open %s: fd %d", devnode, dpriv->fd);
 	}
 
-	usbi_dbg("open %s: fd %d", dpriv->devnode, dpriv->fd);
-
 	if (pipe(hpriv->pipe) < 0)
 		return _errno_to_libusb(errno);
 
@@@@ -226,10 +265,12 @@@@ obsd_close(struct libusb_device_handle *handle)
 	struct handle_priv *hpriv = (struct handle_priv *)handle->os_priv;
 	struct device_priv *dpriv = (struct device_priv *)handle->dev->os_priv;
 
-	usbi_dbg("close: fd %d", dpriv->fd);
+	if (dpriv->devname) {
+		usbi_dbg("close: fd %d", dpriv->fd);
 
-	close(dpriv->fd);
-	dpriv->fd = -1;
+		close(dpriv->fd);
+		dpriv->fd = -1;
+	}
 
 	usbi_remove_pollfd(HANDLE_CTX(handle), hpriv->pipe[0]);
 
@@@@ -257,9 +298,8 @@@@ obsd_get_active_config_descriptor(struct libusb_device
     unsigned char *buf, size_t len, int *host_endian)
 {
 	struct device_priv *dpriv = (struct device_priv *)dev->os_priv;
-	usb_config_descriptor_t *ucd;
+	usb_config_descriptor_t *ucd = (usb_config_descriptor_t *)dpriv->cdesc;
 
-	ucd = (usb_config_descriptor_t *) dpriv->cdesc;
 	len = MIN(len, UGETW(ucd->wTotalLength));
 
 	usbi_dbg("len %d", len);
@@@@ -275,35 +315,27 @@@@ int
 obsd_get_config_descriptor(struct libusb_device *dev, uint8_t idx,
     unsigned char *buf, size_t len, int *host_endian)
 {
-	struct device_priv *dpriv = (struct device_priv *)dev->os_priv;
-	struct usb_full_desc ufd;
+	struct usb_device_fdesc udf;
 	int fd, err;
 
-	usbi_dbg("index %d, len %d", idx, len);
+	if ((fd = _bus_open(dev->bus_number)) < 0)
+		return _errno_to_libusb(errno);
 
-	/* A config descriptor may be requested before opening the device */
-	if (dpriv->fd >= 0) {
-		fd = dpriv->fd;
-	} else {
-		fd = open(dpriv->devnode, O_RDONLY);
-		if (fd < 0)
-			return _errno_to_libusb(errno);
-	}
+	udf.udf_bus = dev->bus_number;
+	udf.udf_addr = dev->device_address;
+	udf.udf_config_index = idx;
+	udf.udf_size = len;
+	udf.udf_data = buf;
 
-	ufd.ufd_config_index = idx;
-	ufd.ufd_size = len;
-	ufd.ufd_data = buf;
+	usbi_dbg("index %d, len %d", udf.udf_config_index, len);
 
-	if ((ioctl(fd, USB_GET_FULL_DESC, &ufd)) < 0) {
+	if (ioctl(fd, USB_DEVICE_GET_FDESC, &udf) < 0) {
 		err = errno;
-		if (dpriv->fd < 0)
-			close(fd);
+		close(fd);
 		return _errno_to_libusb(err);
 	}
+	close(fd);
 
-	if (dpriv->fd < 0)
-		close(fd);
-
 	*host_endian = 0;
 
 	return (LIBUSB_SUCCESS);
@@@@ -313,14 +345,12 @@@@ int
 obsd_get_configuration(struct libusb_device_handle *handle, int *config)
 {
 	struct device_priv *dpriv = (struct device_priv *)handle->dev->os_priv;
+	usb_config_descriptor_t *ucd = (usb_config_descriptor_t *)dpriv->cdesc;
 
-	usbi_dbg("");
+	*config = ucd->bConfigurationValue;
 
-	if (ioctl(dpriv->fd, USB_GET_CONFIG, config) < 0)
-		return _errno_to_libusb(errno);
+	usbi_dbg("bConfigurationValue %d", *config);
 
-	usbi_dbg("configuration %d", *config);
-
 	return (LIBUSB_SUCCESS);
 }
 
@@@@ -329,12 +359,15 @@@@ obsd_set_configuration(struct libusb_device_handle *ha
 {
 	struct device_priv *dpriv = (struct device_priv *)handle->dev->os_priv;
 
-	usbi_dbg("configuration %d", config);
+	if (dpriv->devname == NULL)
+		return (LIBUSB_ERROR_NOT_SUPPORTED);
 
+	usbi_dbg("bConfigurationValue %d", config);
+
 	if (ioctl(dpriv->fd, USB_SET_CONFIG, &config) < 0)
 		return _errno_to_libusb(errno);
 
-	return _cache_active_config_descriptor(handle->dev, dpriv->fd);
+	return _cache_active_config_descriptor(handle->dev);
 }
 
 int
@@@@ -369,6 +402,9 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
 	struct device_priv *dpriv = (struct device_priv *)handle->dev->os_priv;
 	struct usb_alt_interface intf;
 
+	if (dpriv->devname == NULL)
+		return (LIBUSB_ERROR_NOT_SUPPORTED);
+
 	usbi_dbg("iface %d, setting %d", iface, altsetting);
 
 	memset(&intf, 0, sizeof(intf));
@@@@ -385,19 +421,27 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
 int
 obsd_clear_halt(struct libusb_device_handle *handle, unsigned char endpoint)
 {
-	struct device_priv *dpriv = (struct device_priv *)handle->dev->os_priv;
 	struct usb_ctl_request req;
+	int fd, err;
 
+	if ((fd = _bus_open(handle->dev->bus_number)) < 0)
+		return _errno_to_libusb(errno);
+
 	usbi_dbg("");
 
+	req.ucr_addr = handle->dev->device_address;
 	req.ucr_request.bmRequestType = UT_WRITE_ENDPOINT;
 	req.ucr_request.bRequest = UR_CLEAR_FEATURE;
 	USETW(req.ucr_request.wValue, UF_ENDPOINT_HALT);
 	USETW(req.ucr_request.wIndex, endpoint);
 	USETW(req.ucr_request.wLength, 0);
 
-	if (ioctl(dpriv->fd, USB_DO_REQUEST, &req) < 0)
-		return _errno_to_libusb(errno);
+	if (ioctl(fd, USB_REQUEST, &req) < 0) {
+		err = errno;
+		close(fd);
+		return _errno_to_libusb(err);
+	}
+	close(fd);
 
 	return (LIBUSB_SUCCESS);
 }
@@@@ -418,6 +462,7 @@@@ obsd_destroy_device(struct libusb_device *dev)
 	usbi_dbg("");
 
 	free(dpriv->cdesc);
+	free(dpriv->devname);
 }
 
 int
@@@@ -557,6 +602,8 @@@@ obsd_clock_gettime(int clkid, struct timespec *tp)
 int
 _errno_to_libusb(int err)
 {
+	usbi_dbg("error: %s (%d)", strerror(err), err);
+
 	switch (err) {
 	case EIO:
 		return (LIBUSB_ERROR_IO);
@@@@ -566,52 +613,64 @@@@ _errno_to_libusb(int err)
 		return (LIBUSB_ERROR_NO_DEVICE);
 	case ENOMEM:
 		return (LIBUSB_ERROR_NO_MEM);
+	case ETIMEDOUT:
+		return (LIBUSB_ERROR_TIMEOUT);
 	}
 
-	usbi_dbg("error: %s", strerror(err));
-
 	return (LIBUSB_ERROR_OTHER);
 }
 
 int
-_cache_active_config_descriptor(struct libusb_device *dev, int fd)
+_cache_active_config_descriptor(struct libusb_device *dev)
 {
 	struct device_priv *dpriv = (struct device_priv *)dev->os_priv;
-	struct usb_config_desc ucd;
-	struct usb_full_desc ufd;
+	struct usb_device_cdesc udc;
+	struct usb_device_fdesc udf;
 	unsigned char* buf;
-	int len;
+	int fd, len, err;
 
-	usbi_dbg("fd %d", fd);
+	if ((fd = _bus_open(dev->bus_number)) < 0)
+		return _errno_to_libusb(errno);
 
-	ucd.ucd_config_index = USB_CURRENT_CONFIG_INDEX;
+	usbi_dbg("fd %d, addr %d", fd, dev->device_address);
 
-	if ((ioctl(fd, USB_GET_CONFIG_DESC, &ucd)) < 0)
+	udc.udc_bus = dev->bus_number;
+	udc.udc_addr = dev->device_address;
+	udc.udc_config_index = USB_CURRENT_CONFIG_INDEX;
+	if (ioctl(fd, USB_DEVICE_GET_CDESC, &udc) < 0) {
+		err = errno;
+		close(fd);
 		return _errno_to_libusb(errno);
+	}
 
-	usbi_dbg("active bLength %d", ucd.ucd_desc.bLength);
+	usbi_dbg("active bLength %d", udc.udc_desc.bLength);
 
-	len = UGETW(ucd.ucd_desc.wTotalLength);
+	len = UGETW(udc.udc_desc.wTotalLength);
 	buf = malloc(len);
 	if (buf == NULL)
 		return (LIBUSB_ERROR_NO_MEM);
 
-	ufd.ufd_config_index = ucd.ucd_config_index;
-	ufd.ufd_size = len;
-	ufd.ufd_data = buf;
+	udf.udf_bus = dev->bus_number;
+	udf.udf_addr = dev->device_address;
+	udf.udf_config_index = udc.udc_config_index;
+	udf.udf_size = len;
+	udf.udf_data = buf;
 
-	usbi_dbg("index %d, len %d", ufd.ufd_config_index, len);
+	usbi_dbg("index %d, len %d", udf.udf_config_index, len);
 
-	if ((ioctl(fd, USB_GET_FULL_DESC, &ufd)) < 0) {
+	if (ioctl(fd, USB_DEVICE_GET_FDESC, &udf) < 0) {
+		err = errno;
+		close(fd);
 		free(buf);
-		return _errno_to_libusb(errno);
+		return _errno_to_libusb(err);
 	}
+	close(fd);
 
 	if (dpriv->cdesc)
 		free(dpriv->cdesc);
 	dpriv->cdesc = buf;
 
-	return (0);
+	return (LIBUSB_SUCCESS);
 }
 
 int
@@@@ -626,12 +685,13 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
 	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
 	setup = (struct libusb_control_setup *)transfer->buffer;
 
-	usbi_dbg("type %d request %d value %d index %d length %d timeout %d",
+	usbi_dbg("type %x request %x value %x index %d length %d timeout %d",
 	    setup->bmRequestType, setup->bRequest,
 	    libusb_le16_to_cpu(setup->wValue),
 	    libusb_le16_to_cpu(setup->wIndex),
 	    libusb_le16_to_cpu(setup->wLength), transfer->timeout);
 
+	req.ucr_addr = transfer->dev_handle->dev->device_address;
 	req.ucr_request.bmRequestType = setup->bmRequestType;
 	req.ucr_request.bRequest = setup->bRequest;
 	/* Don't use USETW, libusb already deals with the endianness */
@@@@ -643,12 +703,31 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
 	if ((transfer->flags & LIBUSB_TRANSFER_SHORT_NOT_OK) == 0)
 		req.ucr_flags = USBD_SHORT_XFER_OK;
 
-	if ((ioctl(dpriv->fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0)
-		return _errno_to_libusb(errno);
+	if (dpriv->devname == NULL) {
+		/*
+		 * XXX If the device is not attached to ugen(4) it is
+		 * XXX still possible to submit a control transfer but
+		 * XXX with the default timeout only.
+		 */
+		int fd, err;
 
-	if ((ioctl(dpriv->fd, USB_DO_REQUEST, &req)) < 0)
-		return _errno_to_libusb(errno);
+		if ((fd = _bus_open(transfer->dev_handle->dev->bus_number)) < 0)
+			return _errno_to_libusb(errno);
 
+		if ((ioctl(fd, USB_REQUEST, &req)) < 0) {
+			err = errno;
+			close(fd);
+			return _errno_to_libusb(err);
+		}
+		close(fd);
+	} else {
+		if ((ioctl(dpriv->fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0)
+			return _errno_to_libusb(errno);
+
+		if ((ioctl(dpriv->fd, USB_DO_REQUEST, &req)) < 0)
+			return _errno_to_libusb(errno);
+	}
+
 	itransfer->transferred = req.ucr_actlen;
 
 	usbi_dbg("transferred %d", itransfer->transferred);
@@@@ -661,7 +740,7 @@@@ _access_endpoint(struct libusb_transfer *transfer)
 {
 	struct handle_priv *hpriv;
 	struct device_priv *dpriv;
-	char *s, devnode[16];
+	char devnode[16];
 	int fd, endpt;
 	mode_t mode;
 
@@@@ -674,10 +753,9 @@@@ _access_endpoint(struct libusb_transfer *transfer)
 	usbi_dbg("endpoint %d mode %d", endpt, mode);
 
 	if (hpriv->endpoints[endpt] < 0) {
-		/* Pick the right node given the control one */
-		strlcpy(devnode, dpriv->devnode, sizeof(devnode));
-		s = strchr(devnode, '.');
-		snprintf(s, 4, ".%02d", endpt);
+		/* Pick the right endpoint node */
+		snprintf(devnode, sizeof(devnode), DEVPATH "%s.%02d",
+		    dpriv->devname, endpt);
 
 		/* We may need to read/write to the same endpoint later. */
 		if (((fd = open(devnode, O_RDWR)) < 0) && (errno == ENXIO))
@@@@ -694,10 +772,15 @@@@ int
 _sync_gen_transfer(struct usbi_transfer *itransfer)
 {
 	struct libusb_transfer *transfer;
+	struct device_priv *dpriv;
 	int fd, nr = 1;
 
 	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
+	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
 
+	if (dpriv->devname == NULL)
+		return (LIBUSB_ERROR_NOT_SUPPORTED);
+
 	/*
 	 * Bulk, Interrupt or Isochronous transfer depends on the
 	 * endpoint and thus the node to open.
@@@@ -724,4 +807,14 @@@@ _sync_gen_transfer(struct usbi_transfer *itransfer)
 	itransfer->transferred = nr;
 
 	return (0);
+}
+
+int
+_bus_open(int number)
+{
+	char busnode[16];
+
+	snprintf(busnode, sizeof(busnode), USBDEV "%d", number);
+
+	return open(busnode, O_RDWR);
 }
@


1.5
log
@Instead of generating I/O to get the active configuration number, just read
it from the cached descriptor.
@
text
@d1 1
a1 1
$OpenBSD: patch-libusb_os_openbsd_usb_c,v 1.4 2013/04/17 14:28:17 mpi Exp $
@


1.4
log
@Make use of the new usb(4) ioctl to retrieve the device descriptor from
memory instead of generating I/O as adertised by the libusb API.

ok mglocker@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libusb_os_openbsd_usb_c,v 1.3 2013/04/12 08:22:10 mpi Exp $
d6 1
a6 1
+++ libusb/os/openbsd_usb.c	Wed Apr 17 09:55:52 2013
d25 7
a31 1
@@@@ -87,6 +87,10 @@@@ static int _sync_control_transfer(struct usbi_transfer
a35 1
+static int _bus_get_config(int, int, int *);
d41 1
a41 1
@@@@ -128,75 +132,106 @@@@ const struct usbi_os_backend openbsd_backend = {
d146 1
a146 2
+				/* XXX Assume the active config is at index 0 */
+				if (_cache_active_config_descriptor(dev, 0)) {
d186 1
a186 1
@@@@ -204,16 +239,22 @@@@ obsd_open(struct libusb_device_handle *handle)
d214 1
a214 1
@@@@ -226,10 +267,12 @@@@ obsd_close(struct libusb_device_handle *handle)
d230 12
a241 1
@@@@ -275,35 +318,27 @@@@ int
d289 1
a289 2
@@@@ -312,15 +347,20 @@@@ obsd_get_config_descriptor(struct libusb_device *dev, 
 int
d292 2
a293 2
-	struct device_priv *dpriv = (struct device_priv *)handle->dev->os_priv;
+	int fd, err;
d296 2
a297 1
-
d299 2
a300 2
+	if ((fd = _bus_open(handle->dev->bus_number)) < 0)
 		return _errno_to_libusb(errno);
d303 1
a303 9
+	if (_bus_get_config(fd, handle->dev->device_address, config)) {
+		err = errno;
+		close(fd);
+		return _errno_to_libusb(err);
+	}
+	close(fd);
 
+	usbi_dbg("bConfigurationValue %d", *config);
+
d307 1
a307 2
@@@@ -328,13 +368,23 @@@@ int
 obsd_set_configuration(struct libusb_device_handle *handle, int config)
a309 1
+	int idx;
d321 1
a321 7
+	/*
+	 * XXX Instead of assuming that the index is at bConfigurationValue
+	 * minus one, we should iterate against the possible configurations.
+	 */
+	idx = config - 1;
+
+	return _cache_active_config_descriptor(handle->dev, idx);
d325 1
a325 1
@@@@ -369,6 +419,9 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
d335 1
a335 1
@@@@ -385,19 +438,27 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
d366 1
a366 1
@@@@ -418,6 +479,7 @@@@ obsd_destroy_device(struct libusb_device *dev)
d374 1
a374 1
@@@@ -557,6 +619,8 @@@@ obsd_clock_gettime(int clkid, struct timespec *tp)
d383 1
a383 1
@@@@ -566,52 +630,64 @@@@ _errno_to_libusb(int err)
d398 1
a398 1
+_cache_active_config_descriptor(struct libusb_device *dev, int idx)
d466 1
a466 1
@@@@ -626,12 +702,13 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
d481 1
a481 1
@@@@ -643,12 +720,31 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
d517 1
a517 1
@@@@ -661,7 +757,7 @@@@ _access_endpoint(struct libusb_transfer *transfer)
d526 1
a526 1
@@@@ -674,10 +770,9 @@@@ _access_endpoint(struct libusb_transfer *transfer)
d540 1
a540 1
@@@@ -694,10 +789,15 @@@@ int
d556 1
a556 1
@@@@ -724,4 +824,39 @@@@ _sync_gen_transfer(struct usbi_transfer *itransfer)
a569 25
+}
+
+int
+_bus_get_config(int fd, int addr, int *config)
+{
+	struct usb_ctl_request req;
+	uint8_t conf;
+	int err;
+
+	usbi_dbg("");
+
+	req.ucr_addr = addr;
+	req.ucr_request.bmRequestType = UT_READ_DEVICE;
+	req.ucr_request.bRequest = UR_GET_CONFIG;
+	USETW(req.ucr_request.wValue, 0);
+	USETW(req.ucr_request.wIndex, 0);
+	USETW(req.ucr_request.wLength, 1);
+	req.ucr_data = &conf;
+	req.ucr_flags = 0;
+
+	err = ioctl(fd, USB_REQUEST, &req);
+
+	*config = conf;
+
+	return (err);
@


1.3
log
@Make use of the new usb(4) ioctls to retrieve the config descriptor from
memory instead of generating I/O as adertised by the libusb API.

ok mglocker@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libusb_os_openbsd_usb_c,v 1.2 2012/08/05 10:55:24 mpi Exp $
d6 1
a6 1
+++ libusb/os/openbsd_usb.c	Mon Apr  8 10:09:07 2013
d10 1
a10 1
+ * Copyright (c) 2011-2012 Martin Pieuchot <mpi@@openbsd.org>
d25 1
a25 1
@@@@ -87,6 +87,11 @@@@ static int _sync_control_transfer(struct usbi_transfer
a30 1
+static int _bus_get_device_desc(int, int, usb_device_descriptor_t *);
d36 1
a36 1
@@@@ -128,75 +133,102 @@@@ const struct usbi_os_backend openbsd_backend = {
d47 1
a47 1
+	struct discovered_devs *dd;
d51 1
d133 3
a135 1
+				if (_bus_get_device_desc(fd, addr, &dpriv->ddesc)) {
d139 1
d155 2
a156 2
+			dd = discovered_devs_append(*discdevs, dev);
+			if (dd == NULL) {
d163 1
a163 1
+			*discdevs = dd;
d182 1
a182 1
@@@@ -204,16 +236,22 @@@@ obsd_open(struct libusb_device_handle *handle)
d210 1
a210 1
@@@@ -226,10 +264,12 @@@@ obsd_close(struct libusb_device_handle *handle)
d226 1
a226 1
@@@@ -275,35 +315,27 @@@@ int
d274 1
a274 1
@@@@ -312,15 +344,20 @@@@ obsd_get_config_descriptor(struct libusb_device *dev, 
d300 1
a300 1
@@@@ -328,13 +365,23 @@@@ int
d326 1
a326 1
@@@@ -369,6 +416,9 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
d336 1
a336 1
@@@@ -385,19 +435,27 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
d367 1
a367 1
@@@@ -418,6 +476,7 @@@@ obsd_destroy_device(struct libusb_device *dev)
d375 1
a375 1
@@@@ -557,6 +616,8 @@@@ obsd_clock_gettime(int clkid, struct timespec *tp)
d384 1
a384 1
@@@@ -566,52 +627,64 @@@@ _errno_to_libusb(int err)
d467 1
a467 1
@@@@ -626,12 +699,13 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
d482 1
a482 1
@@@@ -643,12 +717,31 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
d518 1
a518 1
@@@@ -661,7 +754,7 @@@@ _access_endpoint(struct libusb_transfer *transfer)
d527 1
a527 1
@@@@ -674,10 +767,9 @@@@ _access_endpoint(struct libusb_transfer *transfer)
d541 1
a541 1
@@@@ -694,10 +786,15 @@@@ int
d557 1
a557 1
@@@@ -724,4 +821,70 @@@@ _sync_gen_transfer(struct usbi_transfer *itransfer)
a595 31
+}
+
+static int
+_bus_get_desc(int fd, int addr, uint8_t type, uint8_t idx, int len, void *desc)
+{
+	struct usb_ctl_request req;
+
+	usbi_dbg("addr %d type %d index %d len %d", addr, type, idx, len);
+
+	req.ucr_addr = addr;
+	req.ucr_request.bmRequestType = UT_READ_DEVICE;
+	req.ucr_request.bRequest = UR_GET_DESCRIPTOR;
+	USETW2(req.ucr_request.wValue, type, idx);
+	USETW(req.ucr_request.wIndex, 0);
+	USETW(req.ucr_request.wLength, len);
+	req.ucr_data = desc;
+	req.ucr_flags = 0;
+
+	if (ioctl(fd, USB_REQUEST, &req) < 0)
+		return _errno_to_libusb(errno);
+
+	return (0);
+}
+
+int
+_bus_get_device_desc(int fd, int addr, usb_device_descriptor_t *ddesc)
+{
+	usbi_dbg("");
+
+	return _bus_get_desc(fd, addr, UDESC_DEVICE, 0,
+	    USB_DEVICE_DESCRIPTOR_SIZE, ddesc);
@


1.2
log
@Associate an ugen node to an USB device even if it is not attached as
first device and don't use the new bConfigurationValue for the index
when caching the config descriptor.

Fix scanning problems reported and tested by ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libusb_os_openbsd_usb_c,v 1.1 2012/06/19 20:48:55 mpi Exp $
d6 1
a6 1
+++ libusb/os/openbsd_usb.c	Thu Aug  2 23:06:22 2012
d25 1
a25 1
@@@@ -87,6 +87,13 @@@@ static int _sync_control_transfer(struct usbi_transfer
a31 2
+static int _bus_get_full_desc(int, int, int, int, void *);
+static int _bus_get_config_desc(int, int, int, usb_config_descriptor_t *);
d37 1
a37 1
@@@@ -128,75 +135,102 @@@@ const struct usbi_os_backend openbsd_backend = {
d179 1
a179 1
@@@@ -204,16 +238,22 @@@@ obsd_open(struct libusb_device_handle *handle)
d207 1
a207 1
@@@@ -226,10 +266,12 @@@@ obsd_close(struct libusb_device_handle *handle)
d223 1
a223 1
@@@@ -275,35 +317,20 @@@@ int
d229 1
d232 1
a234 2
+
 	usbi_dbg("index %d, len %d", idx, len);
d244 6
a249 1
-
d253 2
a254 1
-
d256 1
a256 1
+	if (_bus_get_full_desc(fd, dev->device_address, idx, len, buf)) {
d271 1
a271 1
@@@@ -312,15 +339,20 @@@@ obsd_get_config_descriptor(struct libusb_device *dev, 
d297 1
a297 1
@@@@ -328,13 +360,23 @@@@ int
d323 1
a323 1
@@@@ -369,6 +411,9 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
d333 1
a333 1
@@@@ -385,19 +430,27 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
d364 1
a364 1
@@@@ -418,6 +471,7 @@@@ obsd_destroy_device(struct libusb_device *dev)
d372 1
a372 1
@@@@ -557,6 +611,8 @@@@ obsd_clock_gettime(int clkid, struct timespec *tp)
d381 1
a381 1
@@@@ -566,52 +622,52 @@@@ _errno_to_libusb(int err)
d401 2
a402 1
+	usb_config_descriptor_t cdesc;
d415 4
a418 1
+	if (_bus_get_config_desc(fd, dev->device_address, idx, &cdesc)) {
d425 1
a425 1
+	usbi_dbg("active bLength %d", cdesc.bLength);
d428 1
a428 1
+	len = UGETW(cdesc.wTotalLength);
d436 6
a441 1
-
d443 2
a444 1
-
d446 1
a446 1
+	if (_bus_get_full_desc(fd, dev->device_address, idx, len, buf)) {
d464 1
a464 1
@@@@ -626,12 +682,13 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
d479 1
a479 1
@@@@ -643,12 +700,31 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
d515 1
a515 1
@@@@ -661,7 +737,7 @@@@ _access_endpoint(struct libusb_transfer *transfer)
d524 1
a524 1
@@@@ -674,10 +750,9 @@@@ _access_endpoint(struct libusb_transfer *transfer)
d538 1
a538 1
@@@@ -694,10 +769,15 @@@@ int
d554 1
a554 1
@@@@ -724,4 +804,87 @@@@ _sync_gen_transfer(struct usbi_transfer *itransfer)
a623 17
+}
+
+int
+_bus_get_config_desc(int fd, int addr, int idx, usb_config_descriptor_t *cdesc)
+{
+	usbi_dbg("config index %d", idx);
+
+	return _bus_get_desc(fd, addr, UDESC_CONFIG, idx,
+	    USB_CONFIG_DESCRIPTOR_SIZE, cdesc);
+}
+
+int
+_bus_get_full_desc(int fd, int addr, int idx, int size, void *desc)
+{
+	usbi_dbg("config index %d size %d", idx, size);
+
+	return _bus_get_desc(fd, addr, UDESC_CONFIG, idx, size, desc);
@


1.1
log
@Rework the OpenBSD backend to add *basic support* for non ugen(4) devices.

It is now possible to have a read access and submit control transfers to
all USB devices using libusb, please note that controllers and hubs also
appear as devices.

Requested by many, tested by and ok ajacoutot@@, jasper@@, henning@@, shten@@
@
text
@d1 1
a1 1
$OpenBSD$
d6 1
a6 1
+++ libusb/os/openbsd_usb.c	Fri Jun 15 18:36:21 2012
d39 1
a39 1
@@@@ -128,75 +135,98 @@@@ const struct usbi_os_backend openbsd_backend = {
d59 2
a60 1
+	int fd, addr, i;
d96 10
a105 2
+			session_id = (di.udi_bus << 8 | di.udi_addr);
+			dev = usbi_get_device_by_session_id(ctx, session_id);
d110 6
d123 3
a125 3
-			dpriv = (struct device_priv *)dev->os_priv;
-			strlcpy(dpriv->devnode, devnode, sizeof(devnode));
-			dpriv->fd = -1;
d129 1
a129 4
 
-			if (ioctl(fd, USB_GET_DEVICE_DESC, &dpriv->ddesc) < 0) {
-				err = errno;
-				goto error;
d133 1
a133 9
+				dpriv->devname = NULL;
+
+				/*
+				 * If a device is attached to ugen(4) it has
+				 * only one 'devname'.
+				 */
+				if (!strncmp("ugen", di.udi_devnames[0], 4))
+					dpriv->devname =
+					    strdup(di.udi_devnames[0]);
d181 1
a181 1
@@@@ -204,16 +234,22 @@@@ obsd_open(struct libusb_device_handle *handle)
d209 1
a209 1
@@@@ -226,10 +262,12 @@@@ obsd_close(struct libusb_device_handle *handle)
d225 1
a225 1
@@@@ -275,66 +313,59 @@@@ int
d267 1
a267 2
 }
 
d269 1
a269 2
-obsd_get_configuration(struct libusb_device_handle *handle, int *config)
+obsd_get_configuration(struct libusb_device_handle *handle, int *idx)
d281 1
a281 1
+	if (_bus_get_config(fd, handle->dev->device_address, idx)) {
d288 1
a288 1
+	usbi_dbg("config index %d", *idx);
d293 2
a294 3
 int
-obsd_set_configuration(struct libusb_device_handle *handle, int config)
+obsd_set_configuration(struct libusb_device_handle *handle, int idx)
d297 1
d303 1
a303 2
-	if (ioctl(dpriv->fd, USB_SET_CONFIG, &config) < 0)
+	usbi_dbg("config index %d", idx);
d305 1
a305 1
+	if (ioctl(dpriv->fd, USB_SET_CONFIG, &idx) < 0)
d309 6
d319 1
a319 1
@@@@ -369,6 +400,9 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
d329 1
a329 1
@@@@ -385,19 +419,27 @@@@ obsd_set_interface_altsetting(struct libusb_device_han
d360 1
a360 1
@@@@ -418,6 +460,7 @@@@ obsd_destroy_device(struct libusb_device *dev)
d368 1
a368 1
@@@@ -557,6 +600,8 @@@@ obsd_clock_gettime(int clkid, struct timespec *tp)
d377 1
a377 1
@@@@ -566,52 +611,52 @@@@ _errno_to_libusb(int err)
d450 1
a450 1
@@@@ -626,12 +671,13 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
d465 1
a465 1
@@@@ -643,12 +689,31 @@@@ _sync_control_transfer(struct usbi_transfer *itransfer
d501 1
a501 1
@@@@ -661,7 +726,7 @@@@ _access_endpoint(struct libusb_transfer *transfer)
d510 1
a510 1
@@@@ -674,10 +739,9 @@@@ _access_endpoint(struct libusb_transfer *transfer)
d524 1
a524 1
@@@@ -694,10 +758,15 @@@@ int
d540 1
a540 1
@@@@ -724,4 +793,84 @@@@ _sync_gen_transfer(struct usbi_transfer *itransfer)
d597 4
a600 1
+	return ioctl(fd, USB_REQUEST, &req);
@

