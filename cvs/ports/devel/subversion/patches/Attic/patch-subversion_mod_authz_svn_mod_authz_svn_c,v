head	1.3;
access;
symbols
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_2:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2016.06.14.08.36.29;	author czarkoff;	state dead;
branches;
next	1.2;
commitid	b2pyZR5sFm3sFbqK;

1.2
date	2016.04.28.16.03.01;	author stsp;	state Exp;
branches
	1.2.2.1;
next	1.1;
commitid	jvuJd9VnGMZxBNQX;

1.1
date	2013.04.05.15.06.21;	author stsp;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2013.04.05.15.06.21;	author stsp;	state Exp;
branches;
next	;

1.2.2.1
date	2016.04.28.17.36.00;	author stsp;	state Exp;
branches;
next	;
commitid	aAzU1aTmUvwfAxvd;


desc
@@


1.3
log
@update to subversion 1.9.4

OK sthen@@, stsp@@
@
text
@$OpenBSD: patch-subversion_mod_authz_svn_mod_authz_svn_c,v 1.2 2016/04/28 16:03:01 stsp Exp $
CVE-2016-2168
--- subversion/mod_authz_svn/mod_authz_svn.c.orig	Tue Sep  8 06:00:11 2015
+++ subversion/mod_authz_svn/mod_authz_svn.c	Thu Apr 28 17:16:44 2016
@@@@ -628,6 +628,8 @@@@ req_check_access(request_rec *r,
 
   if (r->method_number == M_MOVE || r->method_number == M_COPY)
     {
+      apr_status_t status;
+
       dest_uri = apr_table_get(r->headers_in, "Destination");
 
       /* Decline MOVE or COPY when there is no Destination uri, this will
@@@@ -636,7 +638,19 @@@@ req_check_access(request_rec *r,
       if (!dest_uri)
         return DECLINED;
 
-      apr_uri_parse(r->pool, dest_uri, &parsed_dest_uri);
+      status = apr_uri_parse(r->pool, dest_uri, &parsed_dest_uri);
+      if (status)
+        {
+          ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r,
+                        "Invalid URI in Destination header");
+          return HTTP_BAD_REQUEST;
+        }
+      if (!parsed_dest_uri.path)
+        {
+          ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+                        "Invalid URI in Destination header");
+          return HTTP_BAD_REQUEST;
+        }
 
       ap_unescape_url(parsed_dest_uri.path);
       dest_uri = parsed_dest_uri.path;
@


1.2
log
@No ports hackathon without a ports commit: Add patches for Subversion
security bugs CVE-2016-2167 and CVE-2016-2168 which were just released.
An update to a newer release of SVN will come later.
ok sthen@@ aja@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2.2.1
log
@For 5.9-stable: Add patches for Subversion security bugs CVE-2016-2167
and CVE-2016-2168 which were just released.
ok sthen@@ aja@@
@
text
@d2 1
d4 1
a4 1
+++ subversion/mod_authz_svn/mod_authz_svn.c	Thu Apr 28 18:37:04 2016
@


1.1
log
@file patch-subversion_mod_authz_svn_mod_authz_svn_c was initially added on branch OPENBSD_5_2.
@
text
@d1 34
@


1.1.2.1
log
@For 5.2-stable:

Add patches for CVE-2013-1884, CVE-2013-1845, CVE-2013-1846, CVE-2013-1847,
and CVE-2013-1849. All of these are denial-of-service vulnerabilities
which affect Subversion servers using mod_dav_svn (Apache HTTPD) only.

For good measure throw in two additional fixes which were made after SVN 1.7.5,
fixing a crash in mod_dav_svn and unbound memory use in mod_authz_svn.
These fixes are already in 5.3 and -current.
@
text
@a0 150
$OpenBSD$
Fix unbounded memory usage in mod_authz_svn with short_circuit enabled.
http://svn.apache.org/r1387943
--- subversion/mod_authz_svn/mod_authz_svn.c.orig	Fri Jul 22 20:37:42 2011
+++ subversion/mod_authz_svn/mod_authz_svn.c	Fri Apr  5 16:02:32 2013
@@@@ -44,6 +44,7 @@@@
 #include "svn_config.h"
 #include "svn_string.h"
 #include "svn_repos.h"
+#include "svn_pools.h"
 #include "svn_dirent_uri.h"
 #include "private/svn_fspath.h"
 
@@@@ -163,7 +164,8 @@@@ static const command_rec authz_svn_cmds[] =
  * Get the, possibly cached, svn_authz_t for this request.
  */
 static svn_authz_t *
-get_access_conf(request_rec *r, authz_svn_config_rec *conf)
+get_access_conf(request_rec *r, authz_svn_config_rec *conf,
+                apr_pool_t *scratch_pool)
 {
   const char *cache_key = NULL;
   const char *access_file;
@@@@ -181,7 +183,7 @@@@ get_access_conf(request_rec *r, authz_svn_config_rec *
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, "%s", dav_err->desc);
         return NULL;
       }
-      access_file = svn_dirent_join_many(r->pool, repos_path, "conf",
+      access_file = svn_dirent_join_many(scratch_pool, repos_path, "conf",
                                          conf->repo_relative_access_file,
                                          NULL);
     }
@@@@ -193,7 +195,7 @@@@ get_access_conf(request_rec *r, authz_svn_config_rec *
   ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                 "Path to authz file is %s", access_file);
 
-  cache_key = apr_pstrcat(r->pool, "mod_authz_svn:",
+  cache_key = apr_pstrcat(scratch_pool, "mod_authz_svn:",
                           access_file, (char *)NULL);
   apr_pool_userdata_get(&user_data, cache_key, r->connection->pool);
   access_conf = user_data;
@@@@ -242,12 +244,13 @@@@ convert_case(char *text, svn_boolean_t to_uppercase)
 /* Return the username to authorize, with case-conversion performed if
    CONF->force_username_case is set. */
 static char *
-get_username_to_authorize(request_rec *r, authz_svn_config_rec *conf)
+get_username_to_authorize(request_rec *r, authz_svn_config_rec *conf,
+                          apr_pool_t *pool)
 {
   char *username_to_authorize = r->user;
   if (username_to_authorize && conf->force_username_case)
     {
-      username_to_authorize = apr_pstrdup(r->pool, r->user);
+      username_to_authorize = apr_pstrdup(pool, r->user);
       convert_case(username_to_authorize,
                    strcasecmp(conf->force_username_case, "upper") == 0);
     }
@@@@ -282,7 +285,8 @@@@ req_check_access(request_rec *r,
   svn_authz_t *access_conf = NULL;
   svn_error_t *svn_err;
   char errbuf[256];
-  const char *username_to_authorize = get_username_to_authorize(r, conf);
+  const char *username_to_authorize = get_username_to_authorize(r, conf,
+                                                                r->pool);
 
   switch (r->method_number)
     {
@@@@ -418,7 +422,7 @@@@ req_check_access(request_rec *r,
     }
 
   /* Retrieve/cache authorization file */
-  access_conf = get_access_conf(r,conf);
+  access_conf = get_access_conf(r,conf, r->pool);
   if (access_conf == NULL)
     return DECLINED;
 
@@@@ -576,14 +580,13 @@@@ log_access_verdict(LOG_ARGS_SIGNATURE,
 }
 
 /*
- * This function is used as a provider to allow mod_dav_svn to bypass the
- * generation of an apache request when checking GET access from
- * "mod_dav_svn/authz.c" .
+ * Implementation of subreq_bypass with scratch_pool parameter.
  */
 static int
-subreq_bypass(request_rec *r,
-              const char *repos_path,
-              const char *repos_name)
+subreq_bypass2(request_rec *r,
+               const char *repos_path,
+               const char *repos_name,
+               apr_pool_t *scratch_pool)
 {
   svn_error_t *svn_err = NULL;
   svn_authz_t *access_conf = NULL;
@@@@ -594,7 +597,7 @@@@ subreq_bypass(request_rec *r,
 
   conf = ap_get_module_config(r->per_dir_config,
                               &authz_svn_module);
-  username_to_authorize = get_username_to_authorize(r, conf);
+  username_to_authorize = get_username_to_authorize(r, conf, scratch_pool);
 
   /* If configured properly, this should never be true, but just in case. */
   if (!conf->anonymous
@@@@ -605,7 +608,7 @@@@ subreq_bypass(request_rec *r,
     }
 
   /* Retrieve authorization file */
-  access_conf = get_access_conf(r, conf);
+  access_conf = get_access_conf(r, conf, scratch_pool);
   if (access_conf == NULL)
     return HTTP_FORBIDDEN;
 
@@@@ -619,7 +622,7 @@@@ subreq_bypass(request_rec *r,
                                              username_to_authorize,
                                              svn_authz_none|svn_authz_read,
                                              &authz_access_granted,
-                                             r->pool);
+                                             scratch_pool);
       if (svn_err)
         {
           ap_log_rerror(APLOG_MARK, APLOG_ERR,
@@@@ -646,6 +649,26 @@@@ subreq_bypass(request_rec *r,
   log_access_verdict(APLOG_MARK, r, 1, repos_path, NULL);
 
   return OK;
+}
+
+/*
+ * This function is used as a provider to allow mod_dav_svn to bypass the
+ * generation of an apache request when checking GET access from
+ * "mod_dav_svn/authz.c" .
+ */
+static int
+subreq_bypass(request_rec *r,
+              const char *repos_path,
+              const char *repos_name)
+{
+  int status;
+  apr_pool_t *scratch_pool;
+
+  scratch_pool = svn_pool_create(r->pool);
+  status = subreq_bypass2(r, repos_path, repos_name, scratch_pool);
+  svn_pool_destroy(scratch_pool);
+
+  return status;
 }
 
 /*
@

