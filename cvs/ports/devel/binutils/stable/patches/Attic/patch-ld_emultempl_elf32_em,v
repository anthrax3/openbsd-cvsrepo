head	1.9;
access;
symbols
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.1.0.2
	OPENBSD_3_1_BASE:1.1.1.1
	fgsch_20020219:1.1.1.1
	fgsch:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2004.11.18.23.40.06;	author fgsch;	state dead;
branches;
next	1.8;

1.8
date	2004.05.19.05.24.39;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.19.00.32.50;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.12.06.26.22;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.23.22.06.25;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.11.00.52.22;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.05.04.03.55;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.26.00.44.40;	author pvalchev;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.19.04.19.21;	author fgsch;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.02.19.04.19.21;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove binutils now that we have a recent and more closely tracked version.
if it's needed in the future, we can bring it back. pvalchev@@ ok.
@
text
@$OpenBSD: patch-ld_emultempl_elf32_em,v 1.8 2004/05/19 05:24:39 brad Exp $
--- ld/emultempl/elf32.em.orig	2003-02-28 17:55:11.000000000 -0500
+++ ld/emultempl/elf32.em	2004-05-18 23:59:31.000000000 -0400
@@@@ -87,6 +87,125 @@@@ static char *gld${EMULATION_NAME}_get_sc
   PARAMS ((int *isfile));
 
 EOF
+case ${target} in
+  *-*-openbsd*)
+    cat >>e${EMULATION_NAME}.c <<EOF
+#include <sys/types.h>
+#include <dirent.h>
+
+/* Search a directory for a .so file.  */
+
+static char *
+gld${EMULATION_NAME}_search_dir (dirname, filename)
+     const char *dirname;
+     const char *filename;
+{
+  const char *dot;
+  unsigned int len;
+  char *found;
+  int max_maj, max_min;
+  DIR *dir;
+  struct dirent *entry;
+  unsigned int dirnamelen;
+  char *full_path;
+  int statval;
+  struct stat st;
+
+  dot = strchr (filename, '.');
+  len = strlen (filename);
+  found = NULL;
+  max_maj = max_min = 0;
+
+  dir = opendir (dirname);
+  if (dir == NULL)
+    return NULL;
+  dirnamelen = strlen (dirname);
+  
+  while ((entry = readdir (dir)) != NULL)
+    {
+      const char *s;
+      char *eptr, *eptr1;
+      int found_maj, found_min;
+
+      if (strncmp (entry->d_name, "lib", 3) != 0
+	  || strncmp (entry->d_name + 3, filename, len) != 0)
+	continue;
+
+      /* We accept libfoo.so without a version number, even though the
+         native linker does not.  This is more convenient for packages
+         which just generate .so files for shared libraries, as on ELF
+         systems.  */
+      if (strncmp (entry->d_name + 3 + len, ".so", 3) != 0)
+	continue;
+
+      if (entry->d_name[6 + len] == '\0')
+	;
+      else if (entry->d_name[6 + len] == '.'
+	       && ISDIGIT ((unsigned char) entry->d_name[7 + len]))
+	;
+      else
+	continue;
+
+      for (s = entry->d_name + 6 + len; *s != '\0'; s++)
+	if (*s != '.' && ! ISDIGIT ((unsigned char) *s))
+	  break;
+      if (*s != '\0')
+	continue;
+
+      /* We've found a .so file.  Work out the major and minor
+	 version numbers.  */
+      found_maj = -1;
+      found_min = -1;
+
+      /* do allow libN.so */
+      if (entry->d_name[6 + len] == '.') {
+	found_maj = strtoul (entry->d_name + 7 + len, &eptr, 10);
+
+	/* do not support libN.so. or libN.so.X */
+	if (*eptr != '.' || ((entry->d_name + 3 + len) == eptr)) 
+	  continue;
+
+	found_min = strtoul (eptr+1, &eptr1, 10);
+
+	/* do not support libN.so.X. or libN.so.X.Y.[anything] */
+	if (*eptr1 != '\0' || (eptr+1 == eptr1)) 
+	  continue;
+      }
+
+      /* Make sure the file really exists (ignore broken symlinks).  */
+      full_path = xmalloc (dirnamelen + 1 + strlen (entry->d_name) + 1);
+      sprintf (full_path, "%s/%s", dirname, entry->d_name);
+      statval = stat (full_path, &st);
+      free (full_path);
+      if (statval != 0)
+	continue;
+
+      /* We've found a match for the name we are searching for.  See
+	 if this is the version we should use.  */
+      if (found == NULL
+	  || (found_maj > max_maj)
+	  || (found_maj == max_maj
+	      && (found_min > max_min)))
+	{
+	  if (found != NULL)
+	    free (found);
+	  found = (char *) xmalloc (dirnamelen + strlen (entry->d_name) + 2);
+	  sprintf (found, "%s/%s", dirname, entry->d_name);
+	  max_maj = found_maj;
+	  max_min = found_min;
+	}
+    }
+
+  closedir (dir);
+
+  return found;
+}
+
+EOF
+    ;;
+esac
+cat >>e${EMULATION_NAME}.c <<EOF
+EOF
 
 # Import any needed special functions and/or overrides.
 #
@@@@ -266,7 +385,7 @@@@ gld${EMULATION_NAME}_try_needed (name, f
      int force;
 {
   bfd *abfd;
-  const char *soname;
+  char *soname;
 
   abfd = bfd_openr (name, bfd_get_target (output_bfd));
   if (abfd == NULL)
@@@@ -359,7 +478,7 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
     einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);
 
   /* First strip off everything before the last '/'.  */
-  soname = lbasename (abfd->filename);
+  soname = xstrdup (lbasename (abfd->filename));
 
   if (trace_file_tries)
     info_msg (_("found %s at %s\n"), soname, name);
@@@@ -370,6 +489,7 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
     {
       /* Return TRUE to indicate that we found the file, even though
          we aren't going to do anything with it.  */
+      free(soname);
       return TRUE;
     }
 
@@@@ -684,7 +804,7 @@@@ gld${EMULATION_NAME}_after_open ()
 	 rpath_link, rpath, then the environment variable
 	 LD_LIBRARY_PATH (native only), then the DT_RPATH/DT_RUNPATH
 	 entries (native only), then the linker script LIB_SEARCH_DIRS.
-	 We do not search using the -L arguments.
+	 We look at the -L arguments to build search path.
 
 	 We search twice.  The first time, we skip objects which may
 	 introduce version mismatches.  The second time, we force
@@@@ -696,7 +816,7 @@@@ gld${EMULATION_NAME}_after_open ()
 EOF
 if [ "x${USE_LIBPATH}" = xyes ] ; then
 cat >>e${EMULATION_NAME}.c <<EOF
-	  const char *lib_path;
+	  char *lib_path;
 	  struct bfd_link_needed_list *rp;
 	  int found;
 EOF
@@@@ -716,15 +836,38 @@@@ EOF
 fi
 if [ "x${NATIVE}" = xyes ] ; then
 cat >>e${EMULATION_NAME}.c <<EOF
-	  if (command_line.rpath_link == NULL
+	  if (getenv("LD_RUN_PATH") != NULL
+	      && command_line.rpath_link == NULL
 	      && command_line.rpath == NULL)
 	    {
-	      lib_path = (const char *) getenv ("LD_RUN_PATH");
+	      lib_path = getenv ("LD_RUN_PATH");
 	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
 						      force))
 		break;
 	    }
-	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
+
+	  len = strlen(search_head->name);
+	  lib_path = xstrdup(search_head->name);
+	  for (search = search_head->next; search != NULL;
+	       search = search->next)
+	    {
+	      size_t nlen;
+
+	      nlen = strlen(search->name);
+	      lib_path = xrealloc(lib_path, len + nlen + 2);
+	      lib_path[len] = ':';
+	      strcpy(lib_path + len + 1, search->name);
+	      len += nlen + 1;
+	    }
+
+	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
+	    {
+	      free(lib_path);
+	      break;
+	    }
+	  free(lib_path);
+
+	  lib_path = getenv ("LD_LIBRARY_PATH");
 	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
 	    break;
 EOF
@@@@ -976,7 +1119,17 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
     return FALSE;
 
   filename = entry->filename;
-
+EOF
+case ${target} in
+  *-*-openbsd*)
+    cat >>e${EMULATION_NAME}.c <<EOF
+  string = gld${EMULATION_NAME}_search_dir(search->name, filename);
+  if (string == NULL)
+    return FALSE;
+EOF
+   ;;
+  *)
+    cat >>e${EMULATION_NAME}.c <<EOF
   /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
      is defined, but it does not seem worth the headache to optimize
      away those two bytes of space.  */
@@@@ -990,6 +1143,10 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
 
   sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);
 
+EOF
+    ;;
+esac
+cat >>e${EMULATION_NAME}.c <<EOF
 #ifdef EXTRA_SHLIB_EXTENSION
   /* Try the .so extension first.  If that fails build a new filename
      using EXTRA_SHLIB_EXTENSION.  */
@@@@ -1486,6 +1643,8 @@@@ if test -n "$GENERATE_COMBRELOC_SCRIPT" 
 echo '  ; else if (link_info.combreloc) return'        >> e${EMULATION_NAME}.c
 sed $sc ldscripts/${EMULATION_NAME}.xc                 >> e${EMULATION_NAME}.c
 fi
+echo '  ; else if (config.data_bss_contig == TRUE) return' >> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xz                 >> e${EMULATION_NAME}.c
 echo '  ; else return'                                 >> e${EMULATION_NAME}.c
 sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
 echo '; }'                                             >> e${EMULATION_NAME}.c
@@@@ -1530,6 +1689,8 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
 EOF
 fi
 cat >>e${EMULATION_NAME}.c <<EOF
+  else if (config.data_bss_contig == TRUE)
+    return "ldscripts/${EMULATION_NAME}.xz";
   else
     return "ldscripts/${EMULATION_NAME}.x";
 }
@


1.8
log
@remove a bit more
@
text
@d1 1
a1 1
$OpenBSD: patch-ld_emultempl_elf32_em,v 1.7 2004/05/19 00:32:50 brad Exp $
@


1.7
log
@remove the disabled DO_FORCE_VERS chunks of this patch.

reminded by drahn@@
@
text
@d1 1
a1 1
$OpenBSD: patch-ld_emultempl_elf32_em,v 1.6 2004/01/12 06:26:22 brad Exp $
d3 2
a4 2
+++ ld/emultempl/elf32.em	2004-05-18 19:24:48.000000000 -0400
@@@@ -87,6 +87,130 @@@@ static char *gld${EMULATION_NAME}_get_sc
a22 1
+  char *alc;
a33 1
+  alc = NULL;
a118 3
+  if (alc != NULL)
+    free (alc);
+
d130 1
a130 1
@@@@ -266,7 +390,7 @@@@ gld${EMULATION_NAME}_try_needed (name, f
d139 1
a139 1
@@@@ -359,7 +483,7 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
d148 1
a148 1
@@@@ -370,6 +494,7 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
d156 1
a156 1
@@@@ -684,7 +809,7 @@@@ gld${EMULATION_NAME}_after_open ()
d165 1
a165 1
@@@@ -696,7 +821,7 @@@@ gld${EMULATION_NAME}_after_open ()
d174 1
a174 1
@@@@ -716,15 +841,38 @@@@ EOF
d216 1
a216 1
@@@@ -976,7 +1124,17 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d235 1
a235 1
@@@@ -990,6 +1148,10 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d246 1
a246 1
@@@@ -1486,6 +1648,8 @@@@ if test -n "$GENERATE_COMBRELOC_SCRIPT" 
d255 1
a255 1
@@@@ -1530,6 +1694,8 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
@


1.6
log
@- use ISDIGIT from binutils
sync with in-tree binutils
- add missing free()
- add support for searching in -L paths when one shared
lib requires another
- add support for the -Z option
@
text
@d1 1
a1 1
$OpenBSD: patch-ld_emultempl_elf32_em,v 1.5 2003/11/23 22:06:25 brad Exp $
d3 2
a4 2
+++ ld/emultempl/elf32.em	2004-01-11 19:03:23.000000000 -0500
@@@@ -87,6 +87,159 @@@@ static char *gld${EMULATION_NAME}_get_sc
a20 1
+  int force_maj, force_min;
a32 2
+  force_maj = -1;
+  force_min = -1;
d34 2
a35 24
+#ifdef DO_FORCE_VERS
+  if (dot == NULL)
+    {
+#endif /* DO_FORCE_VERS */
+      len = strlen (filename);
+      alc = NULL;
+#ifdef DO_FORCE_VERS
+    }
+  else
+    {
+      force_maj = atoi (dot + 1);
+
+      len = dot - filename;
+      alc = (char *) xmalloc (len + 1);
+      strncpy (alc, filename, len);
+      alc[len] = '\0';
+      filename = alc;
+
+      dot = strchr (dot + 1, '.');
+      if (dot != NULL)
+	force_min = atoi (dot + 1);
+    }
+#endif /* DO_FORCE_VERS */
+
a94 4
+      if ((force_maj != -1 && force_maj != found_maj)
+	  || (force_min != -1 && force_min != found_min))
+	continue;
+
d135 1
a135 1
@@@@ -266,7 +419,7 @@@@ gld${EMULATION_NAME}_try_needed (name, f
d144 1
a144 1
@@@@ -359,7 +512,7 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
d153 1
a153 1
@@@@ -370,6 +523,7 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
d161 1
a161 1
@@@@ -684,7 +838,7 @@@@ gld${EMULATION_NAME}_after_open ()
d170 1
a170 1
@@@@ -696,7 +850,7 @@@@ gld${EMULATION_NAME}_after_open ()
d179 1
a179 1
@@@@ -716,15 +870,38 @@@@ EOF
d221 1
a221 1
@@@@ -976,7 +1153,17 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d240 1
a240 1
@@@@ -990,6 +1177,10 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d251 1
a251 1
@@@@ -1486,6 +1677,8 @@@@ if test -n "$GENERATE_COMBRELOC_SCRIPT" 
d260 1
a260 1
@@@@ -1530,6 +1723,8 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
@


1.5
log
@If gld${EMULATION_NAME}_search_dir() returns NULL, return early
and try not to fopen(NULL, ...) later.

From: sturm@@
@
text
@d1 1
a1 1
$OpenBSD: patch-ld_emultempl_elf32_em,v 1.4 2003/10/11 00:52:22 brad Exp $
d3 1
a3 1
+++ ld/emultempl/elf32.em	2003-11-23 16:54:10.000000000 -0500
d89 1
a89 1
+	       && isdigit ((unsigned char) entry->d_name[7 + len]))
d95 1
a95 1
+	if (*s != '.' && ! isdigit ((unsigned char) *s))
d182 9
a190 1
@@@@ -684,7 +837,7 @@@@ gld${EMULATION_NAME}_after_open ()
d199 1
a199 1
@@@@ -696,7 +849,7 @@@@ gld${EMULATION_NAME}_after_open ()
d208 43
a250 1
@@@@ -976,7 +1129,17 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d269 1
a269 1
@@@@ -990,6 +1153,10 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d280 18
@


1.4
log
@upgrade to binutils 2.14

Tested on powerpc/sparc64/alpha
@
text
@d1 1
a1 1
$OpenBSD: patch-ld_emultempl_elf32_em,v 1.3 2003/06/05 04:03:55 brad Exp $
d3 1
a3 1
+++ ld/emultempl/elf32.em	2003-09-04 02:03:38.000000000 -0400
d200 1
a200 1
@@@@ -976,7 +1129,15 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d210 2
d219 1
a219 1
@@@@ -990,6 +1151,10 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
@


1.3
log
@upgrade to binutils 2.13.2.1

This is work in progress. It is being commited as a starting point so other
people can look at it/fix issues/and maybe Art can add Hammer support? :)
It has been lightly tested on macppc/sparc64/i386 and compile tested by
mickey@@ on hppa.

DO NOT try to build ld.so on sparc/sparc64/macppc and install the resulting
binary unless you like having a hosed system. A known "misfeature" in ld.so
that is being worked on.
--
MAINTAINER ok
@
text
@d1 4
a4 4
$OpenBSD: patch-ld_emultempl_elf32_em,v 1.2 2002/04/26 00:44:40 pvalchev Exp $
--- ld/emultempl/elf32.em.orig	Sun Dec 15 14:41:07 2002
+++ ld/emultempl/elf32.em	Sun Mar 16 23:34:34 2003
@@@@ -86,6 +86,159 @@@@ static char *gld${EMULATION_NAME}_get_sc
d164 1
a164 1
@@@@ -265,7 +418,7 @@@@ gld${EMULATION_NAME}_try_needed (name, f
d173 1
a173 1
@@@@ -358,7 +511,7 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
d182 1
a182 9
@@@@ -369,6 +522,7 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
     {
       /* Return true to indicate that we found the file, even though
          we aren't going to do anything with it.  */
+      free (soname);
       return true;
     }
 
@@@@ -634,7 +788,7 @@@@ gld${EMULATION_NAME}_after_open ()
d191 3
a193 3
@@@@ -648,7 +802,7 @@@@ if [ "x${host}" = "x${target}" ] ; then
   case " ${EMULATION_LIBPATH} " in
   *" ${EMULATION_NAME} "*)
d200 2
a201 44
@@@@ -668,15 +822,38 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
 	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
 						  l->name, force))
 	    break;
-	  if (command_line.rpath_link == NULL
+	  if (getenv("LD_RUN_PATH") != NULL
+	      && command_line.rpath_link == NULL
 	      && command_line.rpath == NULL)
 	    {
-	      lib_path = (const char *) getenv ("LD_RUN_PATH");
+	      lib_path = getenv ("LD_RUN_PATH");
 	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
 						      force))
 		break;
 	    }
-	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
+
+	  len = strlen(search_head->name);
+	  lib_path = xstrdup(search_head->name);
+	  for (search = search_head->next; search != NULL;
+	       search = search->next)
+	    {
+	      size_t nlen;
+
+	      nlen = strlen(search->name);
+	      lib_path = xrealloc(lib_path, len + nlen + 2);
+	      lib_path[len] = ':';
+	      strcpy(lib_path + len + 1, search->name);
+	      len += nlen + 1;
+	    }
+
+	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
+	    {
+	      free(lib_path);
+	      break;
+	    }
+	  free(lib_path);
+
+	  lib_path = getenv ("LD_LIBRARY_PATH");
 	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
 	    break;
 
@@@@ -929,7 +1106,15 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
     return false;
d217 1
a217 1
@@@@ -943,6 +1128,10 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
@


1.2
log
@sync with in-tree binutils:
date: 2002/03/19 02:02:57;  author: pvalchev;  state: Exp;  lines: +27 -5
When one shared library requires another, it will try to locate the
required shared library and include it in the link if it's not specified
explicitly.  This change makes ld look at the -L arguments specified,
and build search path.  This avoids the need for -rpath-link, and
somewhat resembles the a.out linker behaviour.  However behaviour of
-rpath and -rpath-link is still preserved as a GNU extension.
@
text
@d1 5
a5 5
$OpenBSD: patch-ld_emultempl_elf32_em,v 1.1.1.1 2002/02/19 04:19:21 fgsch Exp $
--- ld/emultempl/elf32.em.orig	Thu Apr 25 15:41:38 2002
+++ ld/emultempl/elf32.em	Thu Apr 25 18:28:55 2002
@@@@ -71,6 +71,155 @@@@ static boolean gld${EMULATION_NAME}_plac
 static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
d37 1
d40 1
d43 1
d59 1
d164 27
a190 1
@@@@ -605,7 +754,7 @@@@ gld${EMULATION_NAME}_after_open ()
d199 1
a199 1
@@@@ -619,7 +768,7 @@@@ if [ "x${host}" = "x${target}" ] ; then
d208 1
a208 1
@@@@ -639,15 +788,38 @@@@ cat >>e${EMULATION_NAME}.c <<EOF
d250 1
a250 1
@@@@ -888,7 +1060,15 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d267 1
a267 1
@@@@ -902,6 +1082,10 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- ld/emultempl/elf32.em.orig	Sat Feb 16 19:42:58 2002
+++ ld/emultempl/elf32.em	Sat Feb 16 20:03:36 2002
d160 61
a220 1
@@@@ -888,7 +1037,15 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
d237 1
a237 1
@@@@ -902,6 +1059,10 @@@@ gld${EMULATION_NAME}_open_dynamic_archiv
@


1.1.1.1
log
@GNU binutils 2.11.2.
@
text
@@
