head	1.6;
access;
symbols
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.6
date	2011.08.30.12.24.53;	author jasper;	state dead;
branches;
next	1.5;

1.5
date	2011.06.20.11.48.39;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.20.09.50.04;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.23.19.35.54;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.23.18.47.30;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.23.18.09.10;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.6
log
@- update libgtop to 2.28.4
* openbsd now has it's own backend
- remove some patch- files that i've committed upstream too
@
text
@/* $OpenBSD: netload.c,v 1.5 2011/06/20 11:48:39 jasper Exp $	*/

/* Copyright (C) 1998-99 Martin Baulig
   This file is part of LibGTop 1.0.

   Contributed by Martin Baulig <martin@@home-of-linux.org>, October 1998.

   LibGTop is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License,
   or (at your option) any later version.

   LibGTop is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   for more details.

   You should have received a copy of the GNU General Public License
   along with LibGTop; see the file COPYING. If not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
*/

#include <config.h>
#include <glibtop.h>
#include <glibtop/error.h>
#include <glibtop/netload.h>

#include <glibtop_suid.h>

#include <string.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#include <sys/ioctl.h>

#ifdef HAVE_NET_IF_VAR_H
#include <net/if_var.h>
#endif

#include <netinet/in.h>
#include <netinet/in_var.h>

static const unsigned long _glibtop_sysdeps_netload =
(1L << GLIBTOP_NETLOAD_IF_FLAGS) +
(1L << GLIBTOP_NETLOAD_PACKETS_IN) +
(1L << GLIBTOP_NETLOAD_PACKETS_OUT) +
(1L << GLIBTOP_NETLOAD_PACKETS_TOTAL) +
(1L << GLIBTOP_NETLOAD_BYTES_IN) +
(1L << GLIBTOP_NETLOAD_BYTES_OUT) +
(1L << GLIBTOP_NETLOAD_BYTES_TOTAL) +
(1L << GLIBTOP_NETLOAD_ERRORS_IN) +
(1L << GLIBTOP_NETLOAD_ERRORS_OUT) +
(1L << GLIBTOP_NETLOAD_ERRORS_TOTAL) +
(1L << GLIBTOP_NETLOAD_COLLISIONS);

static const unsigned _glibtop_sysdeps_netload_data =
(1L << GLIBTOP_NETLOAD_ADDRESS) +
(1L << GLIBTOP_NETLOAD_SUBNET) +
(1L << GLIBTOP_NETLOAD_MTU);

/* nlist structure for kernel access */
static struct nlist nlst [] = {
    { "_ifnet" },
    { 0 }
};

/* Init function. */

void
_glibtop_init_netload_p (glibtop *server)
{
    server->sysdeps.netload = _glibtop_sysdeps_netload;

    if (kvm_nlist (server->machine.kd, nlst) < 0)
	glibtop_error_io_r (server, "kvm_nlist");
}

/* Provides Network statistics. */

void
glibtop_get_netload_p (glibtop *server, glibtop_netload *buf,
		       const char *interface)
{
    struct ifnet ifnet;
    u_long ifnetaddr, ifnetfound;
    struct sockaddr *sa = NULL;
    char name [32];

    union {
	struct ifaddr ifa;
	struct in_ifaddr in;
    } ifaddr;

    glibtop_init_p (server, (1L << GLIBTOP_SYSDEPS_NETLOAD), 0);

    memset (buf, 0, sizeof (glibtop_netload));

    if (kvm_read (server->machine.kd, nlst [0].n_value,
		  &ifnetaddr, sizeof (ifnetaddr)) != sizeof (ifnetaddr))
	glibtop_error_io_r (server, "kvm_read (ifnet)");

    while (ifnetaddr) {
	struct sockaddr_in *sin;
	register char *cp;
	u_long ifaddraddr;

	{
	    ifnetfound = ifnetaddr;

	    if (kvm_read (server->machine.kd, ifnetaddr, &ifnet,
			  sizeof (ifnet)) != sizeof (ifnet))
		    glibtop_error_io_r (server, "kvm_read (ifnetaddr)");

	    g_strlcpy (name, ifnet.if_xname, sizeof(name));
	    ifnetaddr = (u_long) ifnet.if_list.tqe_next;

	    if (strcmp (name, interface) != 0)
		    continue;

	    ifaddraddr = (u_long) ifnet.if_addrlist.tqh_first;
	}
	if (ifnet.if_flags & IFF_UP)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_UP);
	if (ifnet.if_flags & IFF_BROADCAST)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_BROADCAST);
	if (ifnet.if_flags & IFF_DEBUG)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_DEBUG);
	if (ifnet.if_flags & IFF_LOOPBACK)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LOOPBACK);
	if (ifnet.if_flags & IFF_POINTOPOINT)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_POINTOPOINT);
#ifdef IFF_DRV_RUNNING
	if (ifnet.if_drv_flags & IFF_DRV_RUNNING)
#else
	if (ifnet.if_flags & IFF_RUNNING)
#endif
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_RUNNING);
	if (ifnet.if_flags & IFF_NOARP)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_NOARP);
	if (ifnet.if_flags & IFF_PROMISC)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_PROMISC);
	if (ifnet.if_flags & IFF_ALLMULTI)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_ALLMULTI);
#ifdef IFF_DRV_OACTIVE
	if (ifnet.if_drv_flags & IFF_DRV_OACTIVE)
#else
	if (ifnet.if_flags & IFF_OACTIVE)
#endif
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_OACTIVE);
	if (ifnet.if_flags & IFF_SIMPLEX)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_SIMPLEX);
	if (ifnet.if_flags & IFF_LINK0)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK0);
	if (ifnet.if_flags & IFF_LINK1)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK1);
	if (ifnet.if_flags & IFF_LINK2)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK2);
	if (ifnet.if_flags & IFF_MULTICAST)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_MULTICAST);

	buf->packets_in = ifnet.if_ipackets;
	buf->packets_out = ifnet.if_opackets;
	buf->packets_total = buf->packets_in + buf->packets_out;

	buf->bytes_in = ifnet.if_ibytes;
	buf->bytes_out = ifnet.if_obytes;
	buf->bytes_total = buf->bytes_in + buf->bytes_out;

	buf->errors_in = ifnet.if_ierrors;
	buf->errors_out = ifnet.if_oerrors;
	buf->errors_total = buf->errors_in + buf->errors_out;

	buf->collisions = ifnet.if_collisions;
	buf->flags = _glibtop_sysdeps_netload;

	while (ifaddraddr) {
	    if ((kvm_read (server->machine.kd, ifaddraddr, &ifaddr,
			   sizeof (ifaddr)) != sizeof (ifaddr)))
		glibtop_error_io_r (server, "kvm_read (ifaddraddr)");

#define CP(x) ((char *)(x))
	    cp = (CP(ifaddr.ifa.ifa_addr) - CP(ifaddraddr)) +
		CP(&ifaddr);
	    sa = (struct sockaddr *)cp;

	    if (sa->sa_family == AF_LINK) {
		struct sockaddr_dl *dl = (struct sockaddr_dl *) sa;

		memcpy (buf->hwaddress, LLADDR (dl), sizeof (buf->hwaddress));
		buf->flags |= (1L << GLIBTOP_NETLOAD_HWADDRESS);
	    } else if (sa->sa_family == AF_INET) {
		sin = (struct sockaddr_in *)sa;
		buf->subnet = ifaddr.in.ia_netmask;
		buf->address = sin->sin_addr.s_addr;
		buf->mtu = ifnet.if_mtu;

		buf->flags |= _glibtop_sysdeps_netload_data;
	    } else if (sa->sa_family == AF_INET6) {
		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) sa;
		int in6fd;

		memcpy (buf->address6, &sin6->sin6_addr,
		    sizeof (buf->address6));
		buf->flags |= (1L << GLIBTOP_NETLOAD_ADDRESS6);

		if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
			sin6->sin6_scope_id =
				ntohs(*(u_int16_t *)&sin6->sin6_addr.s6_addr[2]);
			sin6->sin6_addr.s6_addr[2] = sin6->sin6_addr.s6_addr[3] = 0;
		}

		buf->scope6 = (guint8) sin6->sin6_scope_id;
		buf->flags |= (1L << GLIBTOP_NETLOAD_SCOPE6);

		in6fd = socket (AF_INET6, SOCK_DGRAM, 0);
		if (in6fd >= 0) {
			struct in6_ifreq ifr;

			memset (&ifr, 0, sizeof (ifr));
			ifr.ifr_addr = *sin6;
			g_strlcpy (ifr.ifr_name, interface,
			    sizeof (ifr.ifr_name));
			if (ioctl (in6fd, SIOCGIFNETMASK_IN6, (char *) &ifr) >= 0) {
				memcpy (buf->prefix6, &ifr.ifr_addr.sin6_addr,
				    sizeof (buf->prefix6));
				buf->flags |= (1L << GLIBTOP_NETLOAD_PREFIX6);
			}
			close (in6fd);
		}
	    }
	    ifaddraddr = (u_long) ifaddr.ifa.ifa_list.tqe_next;
	}
	return;
    }
}
@


1.5
log
@- Fix scope6 and prefix6 retrieval
@
text
@d1 1
a1 1
/* $OpenBSD: netload.c,v 1.4 2011/06/20 09:50:04 jasper Exp $	*/
@


1.4
log
@- fix GLIBTOP_NETLOAD_HWADDRESS so we can retrieve the hardware address of an interface
@
text
@d1 1
a1 1
/* $OpenBSD: netload.c,v 1.3 2011/05/23 19:35:54 jasper Exp $	*/
d37 2
d203 1
d205 28
a232 2
		memcpy (buf->address6, &sin6->sin6_addr, sizeof (buf->address6));
		buf->flags |= GLIBTOP_NETLOAD_ADDRESS6;
a233 1
	    /* FIXME prefix6, scope6 */
@


1.3
log
@add rcs id's
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d191 1
a191 1
		buf->flags |= GLIBTOP_NETLOAD_HWADDRESS;
@


1.2
log
@more ifdef cleaning
@
text
@d1 2
@


1.1
log
@the openbsd code has diverged too much from the freebsd and generic bsd code
to be easily maintainable. so instead move it to files/ for now untill it
gets incorporated upstream.

discussed with aja@@
@
text
@a56 1
#if !defined(__bsdi__)
a57 1
#endif
a85 3
#if (defined(__FreeBSD__) && (__FreeBSD_version < 501113)) || defined(__bsdi__)
    char tname [16];
#endif
a112 7
#if (defined(__FreeBSD__) && (__FreeBSD_version < 501113)) || defined(__bsdi__)
	    if (kvm_read (server->machine.kd, (u_long) ifnet.if_name,
			  tname, 16) != 16)
		    glibtop_error_io_r (server, "kvm_read (if_name)");
	    tname[15] = '\0';
	    snprintf (name, 32, "%s%d", tname, ifnet.if_unit);
#else
a113 6
#endif
#if defined(__FreeBSD__) && (__FreeBSD_version >= 300000)
	    ifnetaddr = (u_long) ifnet.if_link.tqe_next;
#elif defined(__FreeBSD__) || defined(__bsdi__)
	    ifnetaddr = (u_long) ifnet.if_next;
#else
a114 1
#endif
a118 5
#if defined(__FreeBSD__) && (__FreeBSD_version >= 300000)
	    ifaddraddr = (u_long) ifnet.if_addrhead.tqh_first;
#elif defined(__FreeBSD__) || defined(__bsdi__)
	    ifaddraddr = (u_long) ifnet.if_addrlist;
#else
a119 1
#endif
a156 4
#ifdef __FreeBSD__
	if (ifnet.if_flags & IFF_ALTPHYS)
		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_ALTPHYS);
#endif
a191 5
#if !defined(__bsdi__)
		/* Commenting out to "fix" #13345. */
#if defined(__NetBSD__)
		buf->subnet = ifaddr.in.ia_net;
#elif defined(__OpenBSD__)
a192 4
#else
		buf->subnet = htonl (ifaddr.in.ia_subnet);
#endif
#endif
a203 1
#if defined (__OpenBSD__)
a204 3
#else
	    ifaddraddr = (u_long) ifaddr.ifa.ifa_link.tqe_next;
#endif
@

