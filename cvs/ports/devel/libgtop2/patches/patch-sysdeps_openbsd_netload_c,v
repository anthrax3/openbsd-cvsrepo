head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.8
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.6
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6;
locks; strict;
comment	@# @;


1.9
date	2015.12.11.14.07.30;	author jasper;	state Exp;
branches;
next	1.8;
commitid	CWQNOsQpFRBLZIfv;

1.8
date	2015.12.06.15.19.49;	author mpi;	state Exp;
branches;
next	1.7;
commitid	NRH2KxbWDOCpHnv1;

1.7
date	2014.04.29.06.27.57;	author jasper;	state dead;
branches;
next	1.6;

1.6
date	2014.02.03.13.50.32;	author ajacoutot;	state Exp;
branches;
next	1.5;

1.5
date	2014.02.03.13.46.19;	author ajacoutot;	state Exp;
branches;
next	1.4;

1.4
date	2014.01.23.09.41.25;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.26.21.56.52;	author jca;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.16.15.11.12;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.16.15.04.07;	author bluhm;	state Exp;
branches;
next	;


desc
@@


1.9
log
@- update to libgtop2-2.32.0
* various changes, mostly upstream rototilling code
@
text
@$OpenBSD$

Rewrite of glibtop_get_netload_p() to use getifaddrs(3) instead of KVM.

https://bugzilla.gnome.org/show_bug.cgi?id=759064

--- sysdeps/openbsd/netload.c.orig	Mon Aug 17 20:59:37 2015
+++ sysdeps/openbsd/netload.c	Fri Dec 11 14:34:54 2015
@@@@ -1,48 +1,39 @@@@
-/* Copyright (C) 1998-99 Martin Baulig
-   This file is part of LibGTop 1.0.
+/*
+ * Copyright (c) 2015 Martin Pieuchot <mpi@@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
 
-   Contributed by Martin Baulig <martin@@home-of-linux.org>, October 1998.
+#include "config.h"
 
-   LibGTop is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License,
-   or (at your option) any later version.
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
 
-   LibGTop is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-   for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with LibGTop; see the file COPYING. If not, write to the
-   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#include <config.h>
-#include <glibtop.h>
-#include <glibtop/error.h>
-#include <glibtop/netload.h>
-
-#include <glibtop_suid.h>
-
-#include <string.h>
-
 #include <net/if.h>
 #include <net/if_dl.h>
-#include <net/if_types.h>
 
-#include <sys/ioctl.h>
-
-#include <net/if_var.h>
-
 #include <netinet/in.h>
-#define _KERNEL
 #include <netinet/in_var.h>
-#undef _KERNEL
 #include <netinet6/in6_var.h>
 
+#include <ifaddrs.h>
+
+#include "glibtop.h"
+#include "glibtop/netload.h"
+
 static const unsigned long _glibtop_sysdeps_netload =
+(1L << GLIBTOP_NETLOAD_MTU) +
 (1L << GLIBTOP_NETLOAD_IF_FLAGS) +
 (1L << GLIBTOP_NETLOAD_PACKETS_IN) +
 (1L << GLIBTOP_NETLOAD_PACKETS_OUT) +
@@@@ -55,183 +46,115 @@@@ static const unsigned long _glibtop_sysdeps_netload =
 (1L << GLIBTOP_NETLOAD_ERRORS_TOTAL) +
 (1L << GLIBTOP_NETLOAD_COLLISIONS);
 
-static const unsigned _glibtop_sysdeps_netload_data =
-(1L << GLIBTOP_NETLOAD_ADDRESS) +
-(1L << GLIBTOP_NETLOAD_SUBNET) +
-(1L << GLIBTOP_NETLOAD_MTU);
-
-/* nlist structure for kernel access */
-static struct nlist nlst [] = {
-    { "_ifnet" },
-    { 0 }
-};
-
-/* Init function. */
-
 void
 _glibtop_init_netload_p (glibtop *server)
 {
     server->sysdeps.netload = _glibtop_sysdeps_netload;
-
-    if (kvm_nlist (server->machine->kd, nlst) < 0)
-	glibtop_error_io_r (server, "kvm_nlist");
 }
 
-/* Provides Network statistics. */
-
 void
 glibtop_get_netload_p (glibtop *server, glibtop_netload *buf,
 		       const char *interface)
 {
-    struct ifnet ifnet;
-    u_long ifnetaddr, ifnetfound;
-    struct sockaddr *sa = NULL;
-    char name [32];
+    struct ifaddrs *ifap, *ifa;
+    struct if_data *ifd = NULL;
 
-    union {
-	struct ifaddr ifa;
-	struct in_ifaddr in;
-    } ifaddr;
+    buf->flags = 0;
 
-    glibtop_init_p (server, (1L << GLIBTOP_SYSDEPS_NETLOAD), 0);
+    if (getifaddrs(&ifap) != 0)
+        return;
 
-    memset (buf, 0, sizeof (glibtop_netload));
+    for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
+        if (strcmp (interface, ifa->ifa_name))
+            continue;
 
-    if (kvm_read (server->machine->kd, nlst [0].n_value,
-		  &ifnetaddr, sizeof (ifnetaddr)) != sizeof (ifnetaddr))
-	glibtop_error_io_r (server, "kvm_read (ifnet)");
+        if (ifa->ifa_addr->sa_family == AF_LINK) {
+            struct sockaddr_dl *dl = (struct sockaddr_dl *)ifa->ifa_addr;
 
-    while (ifnetaddr) {
-	struct sockaddr_in *sin;
-	register char *cp;
-	u_long ifaddraddr;
+            ifd = ifa->ifa_data;
 
-	{
-	    ifnetfound = ifnetaddr;
+            memcpy (buf->hwaddress, LLADDR (dl), sizeof (buf->hwaddress));
+            buf->flags |= (1L << GLIBTOP_NETLOAD_HWADDRESS);
 
-	    if (kvm_read (server->machine->kd, ifnetaddr, &ifnet,
-			  sizeof (ifnet)) != sizeof (ifnet))
-		    glibtop_error_io_r (server, "kvm_read (ifnetaddr)");
+            if (ifa->ifa_flags & IFF_UP)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_UP);
+            if (ifa->ifa_flags & IFF_BROADCAST)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_BROADCAST);
+            if (ifa->ifa_flags & IFF_DEBUG)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_DEBUG);
+            if (ifa->ifa_flags & IFF_LOOPBACK)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LOOPBACK);
+            if (ifa->ifa_flags & IFF_POINTOPOINT)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_POINTOPOINT);
+            if (ifa->ifa_flags & IFF_RUNNING)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_RUNNING);
+            if (ifa->ifa_flags & IFF_NOARP)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_NOARP);
+            if (ifa->ifa_flags & IFF_PROMISC)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_PROMISC);
+            if (ifa->ifa_flags & IFF_ALLMULTI)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_ALLMULTI);
+            if (ifa->ifa_flags & IFF_OACTIVE)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_OACTIVE);
+            if (ifa->ifa_flags & IFF_SIMPLEX)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_SIMPLEX);
+            if (ifa->ifa_flags & IFF_LINK0)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK0);
+            if (ifa->ifa_flags & IFF_LINK1)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK1);
+            if (ifa->ifa_flags & IFF_LINK2)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK2);
+            if (ifa->ifa_flags & IFF_MULTICAST)
+                buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_MULTICAST);
 
-	    g_strlcpy (name, ifnet.if_xname, sizeof(name));
-	    ifnetaddr = (u_long) ifnet.if_list.tqe_next;
+        } else if (ifa->ifa_addr->sa_family == AF_INET) {
+            struct sockaddr_in *sin = (struct sockaddr_in *)ifa->ifa_addr;
+            struct sockaddr_in *mask = (struct sockaddr_in *)ifa->ifa_netmask;
 
-	    if (strcmp (name, interface) != 0)
-		    continue;
+            buf->address = sin->sin_addr.s_addr;
+            buf->flags |= (1L << GLIBTOP_NETLOAD_ADDRESS);
 
-	    ifaddraddr = (u_long) ifnet.if_addrlist.tqh_first;
-	}
-	if (ifnet.if_flags & IFF_UP)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_UP);
-	if (ifnet.if_flags & IFF_BROADCAST)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_BROADCAST);
-	if (ifnet.if_flags & IFF_DEBUG)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_DEBUG);
-	if (ifnet.if_flags & IFF_LOOPBACK)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LOOPBACK);
-	if (ifnet.if_flags & IFF_POINTOPOINT)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_POINTOPOINT);
-#ifdef IFF_DRV_RUNNING
-	if (ifnet.if_drv_flags & IFF_DRV_RUNNING)
-#else
-	if (ifnet.if_flags & IFF_RUNNING)
-#endif
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_RUNNING);
-	if (ifnet.if_flags & IFF_NOARP)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_NOARP);
-	if (ifnet.if_flags & IFF_PROMISC)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_PROMISC);
-	if (ifnet.if_flags & IFF_ALLMULTI)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_ALLMULTI);
-#ifdef IFF_DRV_OACTIVE
-	if (ifnet.if_drv_flags & IFF_DRV_OACTIVE)
-#else
-	if (ifnet.if_flags & IFF_OACTIVE)
-#endif
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_OACTIVE);
-	if (ifnet.if_flags & IFF_SIMPLEX)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_SIMPLEX);
-	if (ifnet.if_flags & IFF_LINK0)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK0);
-	if (ifnet.if_flags & IFF_LINK1)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK1);
-	if (ifnet.if_flags & IFF_LINK2)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_LINK2);
-	if (ifnet.if_flags & IFF_MULTICAST)
-		buf->if_flags |= (1L << GLIBTOP_IF_FLAGS_MULTICAST);
+            buf->subnet = mask->sin_addr.s_addr;
+            buf->flags |= (1L << GLIBTOP_NETLOAD_SUBNET);
+        } else if (ifa->ifa_addr->sa_family == AF_INET6) {
+            struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
+            struct sockaddr_in6 *mask = (struct sockaddr_in6 *)ifa->ifa_netmask;
 
-	buf->packets_in = ifnet.if_ipackets;
-	buf->packets_out = ifnet.if_opackets;
-	buf->packets_total = buf->packets_in + buf->packets_out;
+            memcpy (buf->address6, &sin6->sin6_addr, sizeof (buf->address6));
+            buf->flags |= (1L << GLIBTOP_NETLOAD_ADDRESS6);
 
-	buf->bytes_in = ifnet.if_ibytes;
-	buf->bytes_out = ifnet.if_obytes;
-	buf->bytes_total = buf->bytes_in + buf->bytes_out;
+            if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
+                sin6->sin6_scope_id = ntohs(
+                    *(uint16_t *)&sin6->sin6_addr.s6_addr[2]);
+                sin6->sin6_addr.s6_addr[2] = sin6->sin6_addr.s6_addr[3] = 0;
+            }
 
-	buf->errors_in = ifnet.if_ierrors;
-	buf->errors_out = ifnet.if_oerrors;
-	buf->errors_total = buf->errors_in + buf->errors_out;
+            buf->scope6 = (guint8) sin6->sin6_scope_id;
+            buf->flags |= (1L << GLIBTOP_NETLOAD_SCOPE6);
 
-	buf->collisions = ifnet.if_collisions;
-	buf->flags = _glibtop_sysdeps_netload;
+	    memcpy (buf->prefix6, &mask->sin6_addr, sizeof (buf->prefix6));
+	    buf->flags |= (1L << GLIBTOP_NETLOAD_PREFIX6);
+        }
+    }
 
-	while (ifaddraddr) {
-	    if ((kvm_read (server->machine->kd, ifaddraddr, &ifaddr,
-			   sizeof (ifaddr)) != sizeof (ifaddr)))
-		glibtop_error_io_r (server, "kvm_read (ifaddraddr)");
+    if (ifd != NULL) {
+        buf->mtu = ifd->ifi_mtu;
 
-#define CP(x) ((char *)(x))
-	    cp = (CP(ifaddr.ifa.ifa_addr) - CP(ifaddraddr)) +
-		CP(&ifaddr);
-	    sa = (struct sockaddr *)cp;
+        buf->packets_in = ifd->ifi_ipackets;
+        buf->packets_out = ifd->ifi_opackets;
+        buf->packets_total = buf->packets_in + buf->packets_out;
 
-	    if (sa->sa_family == AF_LINK) {
-		struct sockaddr_dl *dl = (struct sockaddr_dl *) sa;
+        buf->bytes_in = ifd->ifi_ibytes;
+        buf->bytes_out = ifd->ifi_obytes;
+        buf->bytes_total = buf->bytes_in + buf->bytes_out;
 
-		memcpy (buf->hwaddress, LLADDR (dl), sizeof (buf->hwaddress));
-		buf->flags |= (1L << GLIBTOP_NETLOAD_HWADDRESS);
-	    } else if (sa->sa_family == AF_INET) {
-		sin = (struct sockaddr_in *)sa;
-		buf->subnet = ifaddr.in.ia_netmask;
-		buf->address = sin->sin_addr.s_addr;
-		buf->mtu = ifnet.if_mtu;
+        buf->errors_in = ifd->ifi_ierrors;
+        buf->errors_out = ifd->ifi_oerrors;
+        buf->errors_total = buf->errors_in + buf->errors_out;
 
-		buf->flags |= _glibtop_sysdeps_netload_data;
-	    } else if (sa->sa_family == AF_INET6) {
-		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) sa;
-		int in6fd;
-
-		memcpy (buf->address6, &sin6->sin6_addr,
-		    sizeof (buf->address6));
-		buf->flags |= (1L << GLIBTOP_NETLOAD_ADDRESS6);
-
-		if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
-			sin6->sin6_scope_id =
-				ntohs(*(u_int16_t *)&sin6->sin6_addr.s6_addr[2]);
-			sin6->sin6_addr.s6_addr[2] = sin6->sin6_addr.s6_addr[3] = 0;
-		}
-
-		buf->scope6 = (guint8) sin6->sin6_scope_id;
-		buf->flags |= (1L << GLIBTOP_NETLOAD_SCOPE6);
-
-		in6fd = socket (AF_INET6, SOCK_DGRAM, 0);
-		if (in6fd >= 0) {
-			struct in6_ifreq ifr;
-
-			memset (&ifr, 0, sizeof (ifr));
-			ifr.ifr_addr = *sin6;
-			g_strlcpy (ifr.ifr_name, interface,
-			    sizeof (ifr.ifr_name));
-			if (ioctl (in6fd, SIOCGIFNETMASK_IN6, (char *) &ifr) >= 0) {
-				memcpy (buf->prefix6, &ifr.ifr_addr.sin6_addr,
-				    sizeof (buf->prefix6));
-				buf->flags |= (1L << GLIBTOP_NETLOAD_PREFIX6);
-			}
-			close (in6fd);
-		}
-	    }
-	    ifaddraddr = (u_long) ifaddr.ifa.ifa_list.tqe_next;
-	}
-	return;
+        buf->collisions = ifd->ifi_collisions;
+        buf->flags |= _glibtop_sysdeps_netload;
     }
+
+    freeifaddrs(ifap);
 }
@


1.8
log
@Rewrite glibtop_get_netload_p() to use getifaddrs(3) instead of KVM.

ok jasper@@
@
text
@d7 2
a8 2
--- sysdeps/openbsd/netload.c.orig	Mon Apr 28 23:09:24 2014
+++ sysdeps/openbsd/netload.c	Sat Dec  5 16:27:56 2015
d46 2
a47 2
-   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.
d105 1
a105 1
-    if (kvm_nlist (server->machine.kd, nlst) < 0)
d137 1
a137 1
-    if (kvm_read (server->machine.kd, nlst [0].n_value,
d154 1
a154 1
-	    if (kvm_read (server->machine.kd, ifnetaddr, &ifnet,
d274 1
a274 1
-	    if ((kvm_read (server->machine.kd, ifaddraddr, &ifaddr,
@


1.7
log
@update to libgtop-2.30.0
@
text
@d1 1
a1 1
$OpenBSD: patch-sysdeps_openbsd_netload_c,v 1.6 2014/02/03 13:50:32 ajacoutot Exp $
d3 1
a3 1
RM at next release.
d5 25
a29 3
--- sysdeps/openbsd/netload.c.orig	Sat Jul 27 14:40:23 2013
+++ sysdeps/openbsd/netload.c	Sun Feb  2 12:54:19 2014
@@@@ -36,12 +36,13 @@@@
d31 7
a37 1
 #include <sys/ioctl.h>
d39 23
a61 3
-#ifdef HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
-#endif
d63 4
d68 1
a68 1
+#define _KERNEL
d70 2
a71 2
+#undef _KERNEL
+#include <netinet6/in6_var.h>
d73 5
d79 1
d81 267
@


1.6
log
@Explicitely mark all files that can be removed when the next release is out.
@
text
@d1 1
a1 1
$OpenBSD: patch-sysdeps_openbsd_netload_c,v 1.5 2014/02/03 13:46:19 ajacoutot Exp $
@


1.5
log
@Sync with what was committed upstream to bring us closer to what FreeBSD
does.
Properly use the OpenBSD-specific code instead of the common one.

ok jasper@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-sysdeps_openbsd_netload_c,v 1.4 2014/01/23 09:41:25 jasper Exp $
d3 1
a3 11
1.
From 07d2816d5b39325bd7381024a88c61b7c56f7b62 Mon Sep 17 00:00:00 2001
From: Jasper Lievisse Adriaanse <jasper@@humppa.nl>
Date: Thu, 23 Jan 2014 09:30:53 +0000
Subject: Adjust header inclusion on OpenBSD

2.
From 250666219659d721377613a916d8f166c2df93ee Mon Sep 17 00:00:00 2001
From: Antoine Jacoutot <ajacoutot@@gnome.org>
Date: Wed, 16 Oct 2013 15:09:16 +0000
Subject: OpenBSD: add missing header
@


1.4
log
@pushed upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-sysdeps_openbsd_netload_c,v 1.3 2013/11/26 21:56:52 jca Exp $
d16 1
a16 1
+++ sysdeps/openbsd/netload.c	Tue Nov 26 00:46:30 2013
@


1.3
log
@Cope with net*/ headers change.  No bump needed (didn't build and last
bump was today).  ok sthen@@ jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-sysdeps_openbsd_netload_c,v 1.2 2013/10/16 15:11:12 ajacoutot Exp $
d3 5
a7 2
1. - we need if_var.h but ./configure fails to define HAVE_NET_IF_VAR_H
   - some declarations in netiner/in_var.h are now kernel-private
@


1.2
log
@Committed upstream.
@
text
@d1 1
a1 1
$OpenBSD: patch-sysdeps_openbsd_netload_c,v 1.1 2013/10/16 15:04:07 bluhm Exp $
d3 4
d13 8
a20 2
+++ sysdeps/openbsd/netload.c	Fri Sep  6 19:11:28 2013
@@@@ -42,6 +42,7 @@@@
d23 1
d25 1
@


1.1
log
@Including the header file netinet6/in6_var.h from netinet/in_var.h
automatically is bad.  To change that, a few ports must be adapted.
Do an explicit #include <netinet6/in6_var.h> when it is needed.
OK ajacoutot@@

Commit the remaining ports that were blocked by an cvs commit error
in devel/jdk/1.7/patches.
@
text
@d1 7
a7 1
$OpenBSD$
@

