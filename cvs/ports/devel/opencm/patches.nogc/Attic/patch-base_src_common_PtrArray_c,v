head	1.3;
access;
symbols
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2003.10.15.13.12.04;	author todd;	state dead;
branches;
next	1.2;

1.2
date	2003.05.28.13.27.48;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.23.13.22.14;	author todd;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove the nogc flavor, pointless now that boehm-gc works again
update to the last public release opencm0.1.2alpha7pl1-1
@
text
@$OpenBSD: patch-base_src_common_PtrArray_c,v 1.2 2003/05/28 13:27:48 todd Exp $
--- base/src/common/PtrArray.c.orig	Sat Mar 29 16:15:21 2003
+++ base/src/common/PtrArray.c	Wed May 28 08:14:56 2003
@@@@ -70,7 +70,7 @@@@ block_fetch(const ObVec* vec, uint32_t i
     if(((void**)ptr)[block_index] == 0 && h != 1)
     {
       uint32_t j;
-      ((void**)ptr)[block_index] = GC_MALLOC(sizeof(void*) * BLOCK_SIZE);
+      ((void**)ptr)[block_index] = calloc(1, sizeof(void*) * BLOCK_SIZE);
       for(j = 0; j != BLOCK_SIZE; j++)
         ((void***)ptr)[block_index][j] = 0;
     }
@@@@ -101,7 +101,7 @@@@ vec_MaybeGrow(ObVec *vec)
   if(vec->size == (1 << (L2BS * vec->height)))
   {
     uint32_t j;
-    const void** elem = GC_MALLOC(sizeof(void*) * BLOCK_SIZE);
+    const void** elem = calloc(1, sizeof(void*) * BLOCK_SIZE);
 
     for(j = 1; j != BLOCK_SIZE; j++)
       elem[j] = 0;
@@@@ -117,7 +117,7 @@@@ vvec_fetch(const ObVec* vec, uint32_t in
 {
   return block_fetch(vec, index, 0);
 }
-
+  
 void
 obvec_append(ObVec *vec, const void *vp)
 {
@@@@ -149,7 +149,7 @@@@ vec_sort_using(void *vec_ptr, int (*cmp)
     const uint32_t last_used   = vec_size(vec) % BLOCK_SIZE;
     const uint32_t total_blocks = full_blocks + (last_used ? 1 : 0);
 
-    uint32_t* leaf_index = GC_MALLOC_ATOMIC(sizeof(uint32_t) * total_blocks);
+    uint32_t* leaf_index = calloc(1, sizeof(uint32_t) * total_blocks);
 
     for(j = 0; j != total_blocks; j++)
       leaf_index[j] = 0;
@@@@ -336,7 +336,7 @@@@ init_vector(void *vec_ptr)
 StrVec *
 strvec_create(void)
 {
-  StrVec *vec = (StrVec *) GC_MALLOC(sizeof(StrVec));
+  StrVec *vec = (StrVec *) calloc(1, sizeof(StrVec));
 
   ser_init(vec, &StrVec_SerType, StrVec_SerType.ver);
   SER_MODIFIED(vec);
@@@@ -349,7 +349,7 @@@@ strvec_create(void)
 TnVec *
 tnvec_create(void)
 {
-  TnVec *vec = (TnVec *) GC_MALLOC(sizeof(TnVec));
+  TnVec *vec = (TnVec *) calloc(1, sizeof(TnVec));
 
   ser_init(vec, &TnVec_SerType, TnVec_SerType.ver);
   SER_MODIFIED(vec);
@@@@ -362,7 +362,7 @@@@ tnvec_create(void)
 ObVec *
 obvec_create()
 {
-  ObVec *vec = (ObVec *) GC_MALLOC(sizeof(ObVec));
+  ObVec *vec = (ObVec *) calloc(1, sizeof(ObVec));
 
   ser_init(vec, &ObVec_SerType, ObVec_SerType.ver);
   SER_MODIFIED(vec);
@@@@ -564,7 +564,7 @@@@ strvec_flatten(StrVec *vec)
 
   cumlen += 1;			/* for trailing null */
 
-  s = GC_MALLOC_ATOMIC(cumlen);
+  s = calloc(1, cumlen);
   cumlen = 0;
 
   for (i = 0; i < size; i++) {
@


1.2
log
@more malloc -> calloc; fixes a 'cm add' fault
@
text
@d1 1
a1 1
$OpenBSD: patch-base_src_common_PtrArray_c,v 1.1 2003/05/23 13:22:14 todd Exp $
@


1.1
log
@update to 0.1.2alpha5pl2 from 0.1.0alpha18

see http://www.opencm.org/news.html for hilights of this update, major
noteworthy changes include:

- sxd has gone away, gzfs is 'interim' while 'sxd2' is almost ready
- if you have an old sxd repository, read the mailing list archives for
  how to update (use an interum version)
- an incompatible update to the server/client protocol requires that you
  update both at the same time

(as a reminder, this is 'alpha' and as such is subject to incompatible changes
 like the above.  expect more to come when sxd2 emerges)

Also, add a 'nogc' flavor that removes the dependency on boehm-gc, at the
cost of not free()'ing all memory allocated (read: at the moment, most).
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ base/src/common/PtrArray.c	Thu May 22 17:46:42 2003
d9 1
a9 1
+      ((void**)ptr)[block_index] = malloc(sizeof(void*) * BLOCK_SIZE);
d18 1
a18 1
+    const void** elem = malloc(sizeof(void*) * BLOCK_SIZE);
d36 1
a36 1
+    uint32_t* leaf_index = malloc(sizeof(uint32_t) * total_blocks);
d45 1
a45 1
+  StrVec *vec = (StrVec *) malloc(sizeof(StrVec));
d54 1
a54 1
+  TnVec *vec = (TnVec *) malloc(sizeof(TnVec));
d63 1
a63 1
+  ObVec *vec = (ObVec *) malloc(sizeof(ObVec));
d72 1
a72 1
+  s = malloc(cumlen);
@

