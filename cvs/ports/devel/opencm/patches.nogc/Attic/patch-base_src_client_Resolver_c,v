head	1.3;
access;
symbols
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2003.10.15.13.12.04;	author todd;	state dead;
branches;
next	1.2;

1.2
date	2003.05.28.13.27.48;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.23.13.22.14;	author todd;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove the nogc flavor, pointless now that boehm-gc works again
update to the last public release opencm0.1.2alpha7pl1-1
@
text
@$OpenBSD: patch-base_src_client_Resolver_c,v 1.2 2003/05/28 13:27:48 todd Exp $
--- base/src/client/Resolver.c.orig	Sat Mar 29 16:15:28 2003
+++ base/src/client/Resolver.c	Wed May 28 08:14:56 2003
@@@@ -66,7 +66,7 @@@@ resolve(Repository *repos, const char *a
   OC_bool progress;
   OC_bool no_matches = TRUE; /* until proven otherwise */
 
-  r = (Resolution *)GC_MALLOC(sizeof(Resolution));
+  r = (Resolution *)calloc(1, sizeof(Resolution));
   r->rest = xstrdup(arg);
 
   log_trace(DBG_RESOLVER, "ARG is: %s\n", arg);
@@@@ -162,10 +162,10 @@@@ resolve(Repository *repos, const char *a
     progress = FALSE;
 
     for (u = 0; u < vec_size(vec); u++) {
-      const char *fragment;
+      char *fragment;
 
       r = vec_fetch(vec, u, Resolution *);
-      fragment = r->rest;
+      fragment = (char *)r->rest;
 
       if (fragment == 0 || r->tail == 0) {
 	/* This one is done. */
@@@@ -173,10 +173,12 @@@@ resolve(Repository *repos, const char *a
 	no_matches = FALSE;
 	continue;
       }
+      fragment = xstrdup(r->rest);
 
       pos = strchr(r->rest, '/');
 
       if (pos) {
+	free(fragment);
 	fragment = xstrndup(r->rest, pos - r->rest);
 	while (*pos == '/')
 	  pos++;
@@@@ -211,6 +213,7 @@@@ resolve(Repository *repos, const char *a
 	    else if (nmequal(fragment, "top")) {
 	      first = last = r->m->nRevisions - 1;
 	      /* hack alert */
+	      free(fragment);
 	      fragment = xunsigned64_str(first);
 	    }
 
@@@@ -219,11 +222,13 @@@@ resolve(Repository *repos, const char *a
 	  DEFAULT(AnyException) {
 	  }
 	  END_CATCH;
-	  if (revs == NULL)
+	  if (revs == NULL) {
+	    free(fragment);
 	    continue;
+	  }
 
 	  for (w = 0; w < vec_size(revs); w++) {
-	    const char *revno;
+	    char *revno;
 	    Resolution *nr;
 
 	    rev = vec_fetch(revs, w, Revision *);
@@@@ -233,10 +238,12 @@@@ resolve(Repository *repos, const char *a
 
 	    revno = xunsigned64_str(rev->seq_number);
 
-	    if (!glob_match(revno, fragment, 0))
+	    if (!glob_match(revno, fragment, 0)) {
+	      free(revno);
 	      continue;
+	    }
 
-	    nr = (Resolution *)GC_MALLOC(sizeof(Resolution));
+	    nr = (Resolution *)calloc(1, sizeof(Resolution));
 
 	    nr->fullPath = path_join(r->fullPath, revno);
 	    nr->fp_frag = revno;
@@@@ -251,6 +258,7 @@@@ resolve(Repository *repos, const char *a
 	    progress = TRUE;
 
 	    no_matches = FALSE;
+	    free(revno);
 	  }
 
 	  break;
@@@@ -295,6 +303,7 @@@@ resolve(Repository *repos, const char *a
 	  DEFAULT(AnyException) {
 	  }
 	  END_CATCH;
+	  free(fragment);
 
 	  break;
 	}
@@@@ -362,8 +371,7 @@@@ resolve(Repository *repos, const char *a
 	       with entities immediately, handle directories in a
 	       second pass. */
 	    if (*rest == 0) {
-	      Resolution *nr = 
-		(Resolution *)GC_MALLOC(sizeof(Resolution));
+	      Resolution *nr = (Resolution *)calloc(1, sizeof(Resolution));
 	      const char *newPath = path_join(r->fullPath, path_tail(match));
 
 	      log_trace(DBG_RESOLVER, "New ent path is %s\n", newPath);
@@@@ -398,8 +406,7 @@@@ resolve(Repository *repos, const char *a
 		last = vec_fetch(dirlist, i, const char *);
 
 		{	      
-		  Resolution *nr = 
-		    (Resolution *)GC_MALLOC(sizeof(Resolution));
+		  Resolution *nr = (Resolution *)calloc(1, sizeof(Resolution));
 		  const char *newPath;
 
 		  newPath = last;
@@@@ -452,7 +459,7 @@@@ resolve(Repository *repos, const char *a
 	    break;
 	  }
 
-	  nr = (Resolution *)GC_MALLOC(sizeof(Resolution));
+	  nr = (Resolution *)calloc(1, sizeof(Resolution));
 
 	  nr->fullPath = path_join(r->fullPath, "home");
 	  nr->fp_frag = xstrdup("home");
@@@@ -478,7 +485,7 @@@@ resolve(Repository *repos, const char *a
 
 
 	    if (glob_match(de->key, fragment, 0)) {
-	      Resolution *nr = (Resolution *)GC_MALLOC(sizeof(Resolution));
+	      Resolution *nr = (Resolution *)calloc(1, sizeof(Resolution));
 
 	      /* FIX: This is SO broken!! */
 	      URI *uri = uri_create(de->value);
@@@@ -540,7 +547,7 @@@@ resolve(Repository *repos, const char *a
 	    if (!glob_match(m->name, fragment, 0))
 	      continue;
 
-	    nr = (Resolution *)GC_MALLOC(sizeof(Resolution));
+	    nr = (Resolution *)calloc(1, sizeof(Resolution));
 
 	    nr->fullPath = path_join(r->fullPath, m->name);
 	    nr->fp_frag = m->name;
@@@@ -568,7 +575,7 @@@@ resolve(Repository *repos, const char *a
 	       to resurrect the glob match against the mutable name
 	       for various reasons.. */
 	    if (glob_match(uri, fragment, 0)) {
-	      Resolution *nr = (Resolution *)GC_MALLOC(sizeof(Resolution));
+	      Resolution *nr = (Resolution *)calloc(1, sizeof(Resolution));
 
 	      nr->fullPath = path_join(r->fullPath, fragment);
 	      nr->fp_frag = uri;
@


1.2
log
@more malloc -> calloc; fixes a 'cm add' fault
@
text
@d1 1
a1 1
$OpenBSD: patch-base_src_client_Resolver_c,v 1.1 2003/05/23 13:22:14 todd Exp $
@


1.1
log
@update to 0.1.2alpha5pl2 from 0.1.0alpha18

see http://www.opencm.org/news.html for hilights of this update, major
noteworthy changes include:

- sxd has gone away, gzfs is 'interim' while 'sxd2' is almost ready
- if you have an old sxd repository, read the mailing list archives for
  how to update (use an interum version)
- an incompatible update to the server/client protocol requires that you
  update both at the same time

(as a reminder, this is 'alpha' and as such is subject to incompatible changes
 like the above.  expect more to come when sxd2 emerges)

Also, add a 'nogc' flavor that removes the dependency on boehm-gc, at the
cost of not free()'ing all memory allocated (read: at the moment, most).
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ base/src/client/Resolver.c	Thu May 22 17:46:42 2003
d9 1
a9 1
+  r = (Resolution *)malloc(sizeof(Resolution));
d74 1
a74 1
+	    nr = (Resolution *)malloc(sizeof(Resolution));
d100 1
a100 1
+	      Resolution *nr = (Resolution *)malloc(sizeof(Resolution));
d110 1
a110 1
+		  Resolution *nr = (Resolution *)malloc(sizeof(Resolution));
d119 1
a119 1
+	  nr = (Resolution *)malloc(sizeof(Resolution));
d128 1
a128 1
+	      Resolution *nr = (Resolution *)malloc(sizeof(Resolution));
d137 1
a137 1
+	    nr = (Resolution *)malloc(sizeof(Resolution));
d146 1
a146 1
+	      Resolution *nr = (Resolution *)malloc(sizeof(Resolution));
@

