head	1.3;
access;
symbols
	OPENBSD_5_6:1.2.0.8
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.10
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.8
	OPENBSD_5_0:1.1.1.1.0.6
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.4
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.2
	OPENBSD_4_8_BASE:1.1.1.1
	kili_20100620:1.1.1.1
	kili:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2015.01.01.19.06.24;	author kili;	state dead;
branches;
next	1.2;
commitid	0bqCI8t1p06XHG7G;

1.2
date	2012.12.31.15.48.10;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.20.09.43.23;	author kili;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.06.20.09.43.23;	author kili;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove outdated and ussless pugs-related hs-ports: hs-HsSyck, hs-MetaObject, hs-control-timeout,
hs-pugs-DrIFT,  hs-pugs-compat, hs-regex-pcre-builtin and hs-stringtable-atom.
@
text
@DrIFT is a type sensitive preprocessor for Haskell. It extracts
type declarations and directives from modules. The directives cause
rules to be fired on the parsed type declarations, generating new
code which is then appended to the bottom of the input file. The
rules are expressed as Haskell code, and it is intended that the
user can add new rules as required.
DrIFT automates instance derivation for classes that aren't supported
by the standard compilers.  In addition, instances can be produced
in separate modules to that containing the type declaration.  This
allows instances to be derived for a type after the original module
has been compiled.  As a bonus, simple utility functions can also
be produced from a type.
@


1.2
log
@spelling
@
text
@@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
in seperate modules to that containing the type declaration.  This
@


1.1.1.1
log
@DrIFT is a type sensitive preprocessor for Haskell. It extracts
type declarations and directives from modules. The directives cause
rules to be fired on the parsed type declarations, generating new
code which is then appended to the bottom of the input file. The
rules are expressed as Haskell code, and it is intended that the
user can add new rules as required.
DrIFT automates instance derivation for classes that aren't supported
by the standard compilers.  In addition, instances can be produced
in seperate modules to that containing the type declaration.  This
allows instances to be derived for a type after the original module
has been compiled.  As a bonus, simple utility functions can also
be produced from a type.

"go ahead, please" espie@@

@
text
@@
