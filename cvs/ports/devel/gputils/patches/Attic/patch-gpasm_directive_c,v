head	1.3;
access;
symbols
	OPENBSD_4_5:1.2.0.22
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.20
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.18
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.16
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.14
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.12
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.10
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.8
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	naddy_20031103:1.1.1.1
	naddy:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2009.06.01.23.05.32;	author benoit;	state dead;
branches;
next	1.2;

1.2
date	2004.01.30.01.01.11;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.03.01.02.34;	author naddy;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.03.01.02.34;	author naddy;	state Exp;
branches;
next	;


desc
@@


1.3
log
@- update gputils to 0.13.7
- remove patches & regen PLIST
- change maintainer (timeout old maintainer)
- update testsuite

ok ajacoutot@@
@
text
@$OpenBSD: patch-gpasm_directive_c,v 1.2 2004/01/30 01:01:11 naddy Exp $
--- gpasm/directive.c.orig	2004-01-07 17:35:53.000000000 +1100
+++ gpasm/directive.c	2004-01-25 20:40:03.000000000 +1100
@@@@ -323,7 +323,7 @@@@ static int list_symbol_member(struct pno
     return 0;
   } else if (STRCMP(M->value.symbol, HEAD(L)->value.symbol) == 0) {
     char buf[BUFSIZ];
-    sprintf(buf, "Duplicate macro parameter (%s).", HEAD(L)->value.symbol);
+    snprintf(buf, sizeof(buf), "Duplicate macro parameter (%s).", HEAD(L)->value.symbol);
     gperror(GPE_UNKNOWN, buf);
     return 1;
   } else {
@@@@ -524,14 +524,14 @@@@ static gpasmVal do_code(gpasmVal r,
     switch (arity) {
     case 0:
       /* new relocatable section */
-      strcpy(state.obj.new_sec_name, ".code");
+      strlcpy(state.obj.new_sec_name, ".code", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = 0;
       state.obj.new_sec_flags = STYP_TEXT;
       break;
     case 1:
       /* new absolute section */
       p = HEAD(parms);
-      strcpy(state.obj.new_sec_name, ".code");
+      strlcpy(state.obj.new_sec_name, ".code", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = maybe_evaluate(p) >> _16bit_core;
       state.obj.new_sec_flags = STYP_TEXT | STYP_ABS;
       break;
@@@@ -1109,12 +1109,12 @@@@ static gpasmVal do_global(gpasmVal r,
       if (p->tag == symbol) {
         s = get_symbol(state.stTop, p->value.symbol);
         if (s == NULL) {
-          sprintf(buf, "Symbol not previously defined (%s).", p->value.symbol);
+          snprintf(buf, sizeof(buf), "Symbol not previously defined (%s).", p->value.symbol);
           gperror(GPE_NOSYM, buf);    
 	} else {
           var = get_symbol_annotation(s);
           if (var == NULL) {
-            sprintf(buf, "Symbol not assigned a value (%s).", p->value.symbol);
+            snprintf(buf, sizeof(buf), "Symbol not assigned a value (%s).", p->value.symbol);
             gpwarning(GPW_UNKNOWN, buf);    
           } else {
             if ((var->previous_type == gvt_address) || 
@@@@ -1125,7 +1125,7 @@@@ static gpasmVal do_global(gpasmVal r,
             } else if (var->previous_type == gvt_extern) { 
               gperror(GPE_DUPLAB, NULL);    
             } else {
-              sprintf(buf, "Operand must be an address label (%s).", 
+              snprintf(buf, sizeof(buf), "Operand must be an address label (%s).", 
                       p->value.symbol);
               gperror(GPE_MUST_BE_LABEL, buf);    
             } 
@@@@ -1156,14 +1156,14 @@@@ static gpasmVal do_idata(gpasmVal r,
     switch (arity) {
     case 0:
       /* new relocatable section */
-      strcpy(state.obj.new_sec_name, ".idata");
+      strlcpy(state.obj.new_sec_name, ".idata", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = 0;
       state.obj.new_sec_flags = STYP_DATA;
       break;
     case 1:
       /* new absolute section */
       p = HEAD(parms);
-      strcpy(state.obj.new_sec_name, ".idata");
+      strlcpy(state.obj.new_sec_name, ".idata", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = maybe_evaluate(p) >> _16bit_core;
       state.obj.new_sec_flags = STYP_DATA | STYP_ABS;
       break;
@@@@ -1615,7 +1615,7 @@@@ static gpasmVal do_org(gpasmVal r,
       }	else {
         /* Default section name, this will be overwritten if a label is 
            present. */
-        sprintf(state.obj.new_sec_name, ".org_%d", state.obj.org_num++);
+        snprintf(state.obj.new_sec_name, sizeof(state.obj.new_sec_name), ".org_%d", state.obj.org_num++);
         state.obj.new_sec_addr = r;
         state.obj.new_sec_flags = STYP_TEXT | STYP_ABS;
         state.lst.line.linetype = sec;
@@@@ -1838,14 +1838,14 @@@@ static gpasmVal do_udata(gpasmVal r,
     switch (arity) {
     case 0:
       /* new relocatable section */
-      strcpy(state.obj.new_sec_name, ".udata");
+      strlcpy(state.obj.new_sec_name, ".udata", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = 0;
       state.obj.new_sec_flags = STYP_BSS;
       break;
     case 1:
       /* new absolute section */
       p = HEAD(parms);
-      strcpy(state.obj.new_sec_name, ".udata");
+      strlcpy(state.obj.new_sec_name, ".udata", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = maybe_evaluate(p);
       state.obj.new_sec_flags = STYP_BSS | STYP_ABS;
       break;
@@@@ -1873,14 +1873,14 @@@@ static gpasmVal do_udata_acs(gpasmVal r,
     switch (arity) {
     case 0:
       /* new relocatable section */
-      strcpy(state.obj.new_sec_name, ".udata_acs");
+      strlcpy(state.obj.new_sec_name, ".udata_acs", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = 0;
       state.obj.new_sec_flags = STYP_BSS | STYP_ACCESS;
       break;
     case 1:
       /* new absolute section */
       p = HEAD(parms);
-      strcpy(state.obj.new_sec_name, ".udata_acs");
+      strlcpy(state.obj.new_sec_name, ".udata_acs", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = maybe_evaluate(p);
       state.obj.new_sec_flags = STYP_BSS | STYP_ABS | STYP_ACCESS;
       break;
@@@@ -1908,14 +1908,14 @@@@ static gpasmVal do_udata_ovr(gpasmVal r,
     switch (arity) {
     case 0:
       /* new relocatable section */
-      strcpy(state.obj.new_sec_name, ".udata_ovr");
+      strlcpy(state.obj.new_sec_name, ".udata_ovr", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = 0;
       state.obj.new_sec_flags = STYP_BSS | STYP_OVERLAY;
       break;
     case 1:
       /* new absolute section */
       p = HEAD(parms);
-      strcpy(state.obj.new_sec_name, ".udata_ovr");
+      strlcpy(state.obj.new_sec_name, ".udata_ovr", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = maybe_evaluate(p);
       state.obj.new_sec_flags = STYP_BSS | STYP_ABS | STYP_OVERLAY;
       break;
@@@@ -1943,14 +1943,14 @@@@ static gpasmVal do_udata_shr(gpasmVal r,
     switch (arity) {
     case 0:
       /* new relocatable section */
-      strcpy(state.obj.new_sec_name, ".udata_shr");
+      strlcpy(state.obj.new_sec_name, ".udata_shr", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = 0;
       state.obj.new_sec_flags = STYP_BSS | STYP_SHARED;
       break;
     case 1:
       /* new absolute section */
       p = HEAD(parms);
-      strcpy(state.obj.new_sec_name, ".udata_shr");
+      strlcpy(state.obj.new_sec_name, ".udata_shr", sizeof(state.obj.new_sec_name));
       state.obj.new_sec_addr = maybe_evaluate(p);
       state.obj.new_sec_flags = STYP_BSS | STYP_ABS | STYP_SHARED;
       break;
@@@@ -2128,7 +2128,7 @@@@ static void emit_check_relative(int insn
 
   /* If the branch is too far then issue an error */
   if ((argument > range) || (argument < -(range+1))) {
-    sprintf(full_message,"Argument out of range (%d not between %d and %d)\n",
+    snprintf(full_message, sizeof(full_message), "Argument out of range (%d not between %d and %d)\n",
 	    argument,
 	    -(range+1),
 	    range);
@@@@ -2888,7 +2888,7 @@@@ gpasmVal do_insn(char *name, struct pnod
           gperror(GPE_UNDEF_PROC, NULL);
         } else {
           char mesg[80];
-          sprintf(mesg, "Unknown opcode \"%.40s\"", name);
+          snprintf(mesg, sizeof(mesg), "Unknown opcode \"%.40s\"", name);
           gperror(GPE_UNKNOWN, mesg);
         }
       }
@


1.2
log
@update to 0.12.0; from Andrew Dalgleish <openbsd@@ajd.net.au>
@
text
@d1 1
a1 1
$OpenBSD: patch-gpasm_directive_c,v 1.1.1.1 2003/11/03 01:02:34 naddy Exp $
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- gpasm/directive.c.orig	2003-10-03 15:44:16.000000000 +1000
+++ gpasm/directive.c	2003-10-19 01:24:54.000000000 +1000
d30 1
a30 1
@@@@ -1171,12 +1171,12 @@@@ static gpasmVal do_global(gpasmVal r,
d45 1
a45 1
@@@@ -1187,7 +1187,7 @@@@ static gpasmVal do_global(gpasmVal r,
d54 1
a54 1
@@@@ -1218,14 +1218,14 @@@@ static gpasmVal do_idata(gpasmVal r,
d71 1
a71 1
@@@@ -1677,7 +1677,7 @@@@ static gpasmVal do_org(gpasmVal r,
d80 1
a80 1
@@@@ -1900,14 +1900,14 @@@@ static gpasmVal do_udata(gpasmVal r,
d94 1
a94 1
       state.obj.new_sec_addr = maybe_evaluate(p) >> _16bit_core;
d97 1
a97 1
@@@@ -1935,14 +1935,14 @@@@ static gpasmVal do_udata_acs(gpasmVal r,
d111 1
a111 1
       state.obj.new_sec_addr = maybe_evaluate(p) >> _16bit_core;
d114 1
a114 1
@@@@ -1970,14 +1970,14 @@@@ static gpasmVal do_udata_ovr(gpasmVal r,
d128 1
a128 1
       state.obj.new_sec_addr = maybe_evaluate(p) >> _16bit_core;
d131 1
a131 1
@@@@ -2005,14 +2005,14 @@@@ static gpasmVal do_udata_shr(gpasmVal r,
d145 1
a145 1
       state.obj.new_sec_addr = maybe_evaluate(p) >> _16bit_core;
d148 1
a148 1
@@@@ -2190,7 +2190,7 @@@@ static void emit_check_relative(int insn
d157 1
a157 1
@@@@ -2950,7 +2950,7 @@@@ gpasmVal do_insn(char *name, struct pnod
@


1.1.1.1
log
@Import gputils 0.11.7.
Submitted by Andrew Dalgleish <openbsd@@ajd.net.au>.

GPUTILS is a collection of tools for the Microchip (TM) PIC
microcontrollers. It includes gpasm, gplink, and gplib.
@
text
@@
