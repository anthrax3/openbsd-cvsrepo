head	1.4;
access;
symbols
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@# @;


1.4
date	2011.09.20.21.09.34;	author ajacoutot;	state dead;
branches;
next	1.3;

1.3
date	2011.05.28.07.32.06;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.23.16.36.13;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.28.13.07.53;	author ajacoutot;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to glib2-2.29.92 (2.30 coming in the next few days).
Committing now (along with upcoming atk, pango and gtk+3 updates) during
the hackathon where we have time to fix all the eventual fallout (bulk
running).

ok jasper@@ robert@@
@
text
@$OpenBSD: patch-gio_gunixconnection_c,v 1.3 2011/05/28 07:32:06 ajacoutot Exp $

From 77f4f5aa02458e6c7f909dc6087a39d9b75d0ba6 Mon Sep 17 00:00:00 2001
From: Antoine Jacoutot <ajacoutot@@openbsd.org>
Date: Fri, 27 May 2011 13:51:08 +0000
Subject: Add glib credentials support to OpenBSD.

--- gio/gunixconnection.c.orig	Sat May 21 05:29:24 2011
+++ gio/gunixconnection.c	Fri May 27 15:57:02 2011
@@@@ -334,6 +334,7 @@@@ g_unix_connection_send_credentials (GUnixConnection   
   gboolean ret;
   GOutputVector vector;
   guchar nul_byte[1] = {'\0'};
+  gint num_messages;
 
   g_return_val_if_fail (G_IS_UNIX_CONNECTION (connection), FALSE);
   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
@@@@ -344,14 +345,25 @@@@ g_unix_connection_send_credentials (GUnixConnection   
 
   vector.buffer = &nul_byte;
   vector.size = 1;
-  scm = g_unix_credentials_message_new_with_credentials (credentials);
+
+  if (g_unix_credentials_message_is_supported ())
+    {
+      scm = g_unix_credentials_message_new_with_credentials (credentials);
+      num_messages = 1;
+    }
+  else
+    {
+      scm = NULL;
+      num_messages = 0;
+    }
+
   g_object_get (connection, "socket", &socket, NULL);
   if (g_socket_send_message (socket,
                              NULL, /* address */
                              &vector,
                              1,
                              &scm,
-                             1,
+                             num_messages,
                              G_SOCKET_MSG_NONE,
                              cancellable,
                              error) != 1)
@@@@ -364,7 +376,8 @@@@ g_unix_connection_send_credentials (GUnixConnection   
 
  out:
   g_object_unref (socket);
-  g_object_unref (scm);
+  if (scm != NULL)
+    g_object_unref (scm);
   g_object_unref (credentials);
   return ret;
 }
@@@@ -497,27 +510,46 @@@@ g_unix_connection_receive_credentials (GUnixConnection
       goto out;
     }
 
-  if (nscm != 1)
+  if (g_unix_credentials_message_is_supported ())
     {
-      g_set_error (error,
-                   G_IO_ERROR,
-                   G_IO_ERROR_FAILED,
-		   _("Expecting 1 control message, got %d"),
-                   nscm);
-      goto out;
-    }
+      if (nscm != 1)
+        {
+          g_set_error (error,
+                       G_IO_ERROR,
+                       G_IO_ERROR_FAILED,
+                       _("Expecting 1 control message, got %d"),
+                       nscm);
+          goto out;
+        }
 
-  if (!G_IS_UNIX_CREDENTIALS_MESSAGE (scms[0]))
+      if (!G_IS_UNIX_CREDENTIALS_MESSAGE (scms[0]))
+        {
+          g_set_error_literal (error,
+                               G_IO_ERROR,
+                               G_IO_ERROR_FAILED,
+                               _("Unexpected type of ancillary data"));
+          goto out;
+        }
+
+      ret = g_unix_credentials_message_get_credentials (G_UNIX_CREDENTIALS_MESSAGE (scms[0]));
+      g_object_ref (ret);
+    }
+  else
     {
-      g_set_error_literal (error,
-                           G_IO_ERROR,
-                           G_IO_ERROR_FAILED,
-			   _("Unexpected type of ancillary data"));
-      goto out;
+      if (nscm != 0)
+        {
+          g_set_error (error,
+                       G_IO_ERROR,
+                       G_IO_ERROR_FAILED,
+                       _("Not expecting control message, but got %d"),
+                       nscm);
+          goto out;
+        }
+      else
+        {
+          ret = g_socket_get_credentials (socket, error);
+        }
     }
-
-  ret = g_unix_credentials_message_get_credentials (G_UNIX_CREDENTIALS_MESSAGE (scms[0]));
-  g_object_ref (ret);
 
  out:
 
@


1.3
log
@Rewrite / add glib credentials support to OpenBSD.
Joint work with upstream.
@
text
@d1 1
a1 1
$OpenBSD: patch-gio_gunixconnection_c,v 1.2 2011/05/23 16:36:13 ajacoutot Exp $
@


1.2
log
@Missing ifdef.
@
text
@d1 1
a1 1
$OpenBSD: patch-gio_gunixconnection_c,v 1.1 2011/04/28 13:07:53 ajacoutot Exp $
d3 4
a6 9
XXX
Workaround the fact that we cannot pass SCM_CREDS over unix sockets:
implement the "intended" SCM_CREDS stack as if we had support for that
in the kernel (by-pass it almost completely).
send/recv a single null byte without creds, but on recv, just do a
getsockopt(SO_PEERCRED) and return that as if it coming from the cmsg.
This works as long as creds are not retreived from an fd which has
already been handed over to a different process via SCM_RIGHTS. It will
probably not be enough in the future but we'll see then.
d9 2
a10 19
+++ gio/gunixconnection.c	Mon May 23 18:20:08 2011
@@@@ -42,7 +42,7 @@@@
 #include <gio/gsocket.h>
 #include <unistd.h>
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__OpenBSD__)
 /* for getsockopt() and setsockopt() */
 #include <sys/types.h>          /* See NOTES */
 #include <sys/socket.h>
@@@@ -328,8 +328,10 @@@@ g_unix_connection_send_credentials (GUnixConnection   
                                     GCancellable         *cancellable,
                                     GError              **error)
 {
+#ifndef __OpenBSD__
   GCredentials *credentials;
   GSocketControlMessage *scm;
+#endif
   GSocket *socket;
d13 2
a14 3
@@@@ -340,18 +342,28 @@@@ g_unix_connection_send_credentials (GUnixConnection   
 
   ret = FALSE;
d16 3
a18 4
+#ifndef __OpenBSD__
   credentials = g_credentials_new ();
+  scm = g_unix_credentials_message_new_with_credentials (credentials);
+#endif
d22 13
a34 3
+#ifndef __OpenBSD__
   scm = g_unix_credentials_message_new_with_credentials (credentials);
+#endif
a39 1
+#ifndef __OpenBSD__
d41 2
a42 5
                              1,
+#else
+                             NULL,
+                             0,
+#endif
d46 1
a46 1
@@@@ -364,8 +376,10 @@@@ g_unix_connection_send_credentials (GUnixConnection   
d50 3
a52 2
+#ifndef __OpenBSD__
   g_object_unref (scm);
a53 1
+#endif
d56 1
a56 13
 
@@@@ -406,6 +420,10 @@@@ g_unix_connection_receive_credentials (GUnixConnection
 #ifdef __linux__
   gboolean turn_off_so_passcreds;
 #endif
+#ifdef __OpenBSD__
+  struct sockpeercred cred;
+  socklen_t len;
+#endif
 
   g_return_val_if_fail (G_IS_UNIX_CONNECTION (connection), NULL);
   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
@@@@ -497,16 +515,25 @@@@ g_unix_connection_receive_credentials (GUnixConnection
d60 2
a61 5
+#ifndef __OpenBSD__
   if (nscm != 1)
+#else
+  if (nscm != 0)
+#endif
d63 50
a112 10
       g_set_error (error,
                    G_IO_ERROR,
                    G_IO_ERROR_FAILED,
+#ifndef __OpenBSD__
 		   _("Expecting 1 control message, got %d"),
+#else
+		   _("Expecting 0 control message, got %d"),
+#endif
                    nscm);
       goto out;
d114 3
a116 24
 
+#ifndef __OpenBSD__
   if (!G_IS_UNIX_CREDENTIALS_MESSAGE (scms[0]))
     {
       g_set_error_literal (error,
@@@@ -518,6 +545,21 @@@@ g_unix_connection_receive_credentials (GUnixConnection
 
   ret = g_unix_credentials_message_get_credentials (G_UNIX_CREDENTIALS_MESSAGE (scms[0]));
   g_object_ref (ret);
+#else
+  len = sizeof(cred);
+  if (getsockopt(g_socket_get_fd(socket),
+		 SOL_SOCKET, SO_PEERCRED, &cred, &len) == -1) {
+	  g_set_error (error,
+		       G_IO_ERROR,
+		       g_io_error_from_errno (errno),
+		       _("Error : getsockopt(SO_PEERCRED): %s"),
+		       strerror (errno));
+	  goto out;
+  }
+  
+  ret = g_credentials_new();
+  g_credentials_set_native(ret, G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED, &cred);
+#endif
@


1.1
log
@Workaround the fact that we cannot pass SCM_CREDS over unix sockets:
implement the "intended" SCM_CREDS stack as if we had support for that
in the kernel (by-pass it almost completely).
send/recv a single null byte without creds, but on recv, just do a
getsockopt(SO_PEERCRED) and return that as if it coming from the cmsg.
This works as long as creds are not retreived from an fd which has
already been handed over to a different process via SCM_RIGHTS. It will
probably not be enough in the future but we'll see then.
all this work done by eric@@ (thanks!) and tested by myself

Enable support for g_credential*
Fix a couple of warnings.

ok eric@@ jasper@@
@
text
@d1 1
a1 1
$OpenBSD$
d13 2
a14 2
--- gio/gunixconnection.c.orig	Thu Apr 14 00:55:29 2011
+++ gio/gunixconnection.c	Wed Apr 27 18:54:47 2011
d35 1
a35 1
@@@@ -340,18 +342,25 @@@@ g_unix_connection_send_credentials (GUnixConnection   
d46 3
a48 1
-  scm = g_unix_credentials_message_new_with_credentials (credentials);
d64 1
a64 1
@@@@ -364,8 +373,10 @@@@ g_unix_connection_send_credentials (GUnixConnection   
d75 1
a75 1
@@@@ -406,6 +417,10 @@@@ g_unix_connection_receive_credentials (GUnixConnection
d86 1
a86 1
@@@@ -497,16 +512,25 @@@@ g_unix_connection_receive_credentials (GUnixConnection
d112 1
a112 1
@@@@ -518,6 +542,21 @@@@ g_unix_connection_receive_credentials (GUnixConnection
@

