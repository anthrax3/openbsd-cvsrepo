head	1.2;
access;
symbols
	OPENBSD_3_9:1.1.0.2
	OPENBSD_3_9_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2006.05.28.15.44.14;	author avsm;	state dead;
branches;
next	1.1;

1.1
date	2005.10.16.21.55.15;	author pvalchev;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to cil-1.3.5, lots of nice fixes to parsing gcc/msvc code
@
text
@$OpenBSD: patch-ocamlutil_perfcount_c_in,v 1.1 2005/10/16 21:55:15 pvalchev Exp $
--- ocamlutil/perfcount.c.in.orig	Sat Oct  8 02:22:55 2005
+++ ocamlutil/perfcount.c.in	Sat Oct  8 02:23:45 2005
@@@@ -22,7 +22,7 @@@@ inline static unsigned long long read_pp
 #if !defined(__i386__)
   printf ("Reading of performance counters is supported only on Intel x86\n");
   exit(1);
-#endif
+#else
 
   // RDTSC puts the result in EAX and EDX. We tell gcc to use those registers
   // for "low" and "high"
@@@@ -37,6 +37,7 @@@@ inline static unsigned long long read_pp
     first_value = lowhigh;
   }
   return lowhigh - first_value;
+#endif
 }
 
 
@@@@ -50,9 +51,15 @@@@ inline static unsigned long long read_pp
 inline static unsigned long sample_ppc_20()
 {
   unsigned long low, high;
+
+#if !defined(__i386__)
+  printf ("Reading of performance counters is supported only on Intel x86\n");
+  exit(1);
+#else
   __asm__ volatile ("rdtsc" : "=a" (low), "=d" (high));
 
   return ((low >> 20) | (high << 12)) & 0x3FFFFFFF;
+#endif
 }
 
 /* This version drops the low 10 bits, yielding something like
@@@@ -60,7 +67,12 @@@@ inline static unsigned long sample_ppc_2
 inline static unsigned long sample_ppc_10()
 {
   unsigned long low, high;
+#if !defined(__i386__)
+  printf ("Reading of performance counters is supported only on Intel x86\n");
+  exit(1);
+#else
   __asm__ volatile ("rdtsc" : "=a" (low), "=d" (high));
+#endif
 
   return ((low >> 10) | (high << 22)) & 0x3FFFFFFF;
 }
@


1.1
log
@move #ifdef __i386__ to actually include the inline x86 asm too
so this compiles on other arches, no binary change; ok avsm
@
text
@d1 1
a1 1
$OpenBSD$
@

