head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.26
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.22
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.24
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.20
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.18
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.16
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.14
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.12
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.10
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.28
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.24
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.22
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.20
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.18
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.16
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.14
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.12
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.10
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.8
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.6
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.4
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.2
	OPENBSD_3_4_BASE:1.1.1.1
	sturm_2003-Apr-17:1.1.1.1
	sturm:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2010.05.22.20.35.17;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.17.10.59.48;	author sturm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.04.17.10.59.48;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@ANSI __FUNCTION__
@
text
@$OpenBSD: patch-io_method_c,v 1.1.1.1 2003/04/17 10:59:48 sturm Exp $
--- io_method.c.orig	Wed Mar 27 05:41:23 2002
+++ io_method.c	Sat May 22 22:34:22 2010
@@@@ -59,7 +59,7 @@@@ ssize_t
 io_method_accept(int fd, void *buf, size_t size)
 {
 	struct sockaddr_storage from;
-	size_t fromlen = sizeof(from);
+	socklen_t fromlen = sizeof(from);
 
 	if (size < sizeof(int))
 		return (0);
@@@@ -177,7 +177,7 @@@@ io_method_connect(struct io_obj *obj, int fd, void *bu
 
 	/* Check if the connection completed */
 	if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &error, &errsz) == -1) {
-		warn(__FUNCTION__": getsockopt for %d", fd);
+		warn("%s: getsockopt for %d", __FUNCTION__, fd);
 		return (-1);
 	}
 
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- io_method.c.orig	Tue Mar 26 22:41:23 2002
+++ io_method.c	Sun Apr 13 08:20:08 2003
d13 9
@


1.1.1.1
log
@Initial import of libio 0.1

libio provides an abstraction for general data transport. It creates
data sources and data sinks. The sources and sinks can be connected with
multiple filters. As a result encryption and authentication can happen
completely transparent to the main core of an application. Mutliplex
nodes can be used to deal with N-fan in and M-fan out.

WWW: http://monkey.org/~provos/libio/

from Jolan Luff <jolan@@cryptonomicon.org>
@
text
@@
