head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2014.06.04.17.40.27;	author jasper;	state dead;
branches;
next	1.2;
commitid	1Q2YRNXbzPxCMReq;

1.2
date	2013.07.15.19.01.56;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.05.01.10.11.54;	author miod;	state Exp;
branches;
next	;


desc
@@


1.3
log
@- update to libffi-3.0.13 (an update to 3.1 will be worked on shortly)
- sync homepage

tested by many on nearly every supported architecture, thanks!

feedback/ok miod@@
@
text
@$OpenBSD: patch-src_m68k_ffi_c,v 1.2 2013/07/15 19:01:56 miod Exp $

Match the calling convention used by NetBSD and OpenBSD on m68k/ELF, which
differs from Linux/ELF: structs are always passed on the stack, functions
returning structs receive the struct pointer in %a0 instead of %a1.

Add an OpenBSD-specific function to flush the instruction cache after
building closure trampolines.

--- src/m68k/ffi.c.orig	Tue Dec 29 15:22:26 2009
+++ src/m68k/ffi.c	Mon Jul 15 18:53:57 2013
@@@@ -9,8 +9,12 @@@@
 
 #include <stdlib.h>
 #include <unistd.h>
+#ifdef __OpenBSD__
+void ffi_sync_icache(void *, unsigned int);
+#else
 #include <sys/syscall.h>
 #include <asm/cachectl.h>
+#endif
 
 void ffi_call_SYSV (extended_cif *,
 		    unsigned, unsigned,
@@@@ -103,6 +107,8 @@@@ ffi_prep_args (void *stack, extended_cif *ecif)
 #define CIF_FLAGS_POINTER	32
 #define CIF_FLAGS_STRUCT1	64
 #define CIF_FLAGS_STRUCT2	128
+#define CIF_FLAGS_SINT8		256
+#define CIF_FLAGS_SINT16	512
 
 /* Perform machine dependent cif processing */
 ffi_status
@@@@ -116,6 +122,16 @@@@ ffi_prep_cif_machdep (ffi_cif *cif)
       break;
 
     case FFI_TYPE_STRUCT:
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+      cif->flags = 0;	/* structs are always passed on the stack */
+#else
+      if (cif->rtype->elements[0]->type == FFI_TYPE_STRUCT &&
+	  cif->rtype->elements[1])
+	{
+	  cif->flags = 0;
+	  break;
+	}
+
       switch (cif->rtype->size)
 	{
 	case 1:
@@@@ -134,6 +150,7 @@@@ ffi_prep_cif_machdep (ffi_cif *cif)
 	  cif->flags = 0;
 	  break;
 	}
+#endif
       break;
 
     case FFI_TYPE_FLOAT:
@@@@ -157,6 +174,14 @@@@ ffi_prep_cif_machdep (ffi_cif *cif)
       cif->flags = CIF_FLAGS_DINT;
       break;
 
+    case FFI_TYPE_SINT16:
+      cif->flags = CIF_FLAGS_SINT16;
+      break;
+
+    case FFI_TYPE_SINT8:
+      cif->flags = CIF_FLAGS_SINT8;
+      break;
+
     default:
       cif->flags = CIF_FLAGS_INT;
       break;
@@@@ -178,7 +203,7 @@@@ ffi_call (ffi_cif *cif, void (*fn) (), void *rvalue, v
 
   if (rvalue == NULL
       && cif->rtype->type == FFI_TYPE_STRUCT
-      && cif->rtype->size > 8)
+      && cif->flags == 0)
     ecif.rvalue = alloca (cif->rtype->size);
   else
     ecif.rvalue = rvalue;
@@@@ -257,17 +282,26 @@@@ ffi_prep_closure_loc (ffi_closure* closure,
 {
   FFI_ASSERT (cif->abi == FFI_SYSV);
 
-  *(unsigned short *)closure->tramp = 0x207c;
   *(void **)(closure->tramp + 2) = codeloc;
-  *(unsigned short *)(closure->tramp + 6) = 0x4ef9;
+  *(unsigned short *)(closure->tramp + 6) = 0x4ef9; /* jmp ffi_closure_... */
   if (cif->rtype->type == FFI_TYPE_STRUCT
       && !cif->flags)
-    *(void **)(closure->tramp + 8) = ffi_closure_struct_SYSV;
+    {
+      *(unsigned short *)closure->tramp = 0x227c; /* moval #codeloc, %a1 */
+      *(void **)(closure->tramp + 8) = ffi_closure_struct_SYSV;
+    }
   else
-    *(void **)(closure->tramp + 8) = ffi_closure_SYSV;
+    {
+      *(unsigned short *)closure->tramp = 0x207c; /* moval #codeloc, %a0 */
+      *(void **)(closure->tramp + 8) = ffi_closure_SYSV;
+    }
 
+#ifdef __OpenBSD__
+  ffi_sync_icache(codeloc, FFI_TRAMPOLINE_SIZE);
+#else
   syscall(SYS_cacheflush, codeloc, FLUSH_SCOPE_LINE,
 	  FLUSH_CACHE_BOTH, FFI_TRAMPOLINE_SIZE);
+#endif
 
   closure->cif  = cif;
   closure->user_data = user_data;
@


1.2
log
@The m68k fixes were not good enough to work correctly for closures around
functions returning structs of 5 to 15 bytes, inclusive; making me wonder
what I had actually tested. Now all the testcase passes, for real. Noticed
while working on cleaning these changes to push them upstream.
Bump revision.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_m68k_ffi_c,v 1.1 2013/05/01 10:11:54 miod Exp $
@


1.1
log
@Fix m68k support (Linux/ELF uses a slightly different calling convention than
SysV/m68k, which NetBSD and OpenBSD follow).

Add m88k/ELF support.

Add vax/a.out support.

All tests from the libffi.call dejagnu testsuite pass on these three platforms.

ok jasper@@
@
text
@d1 1
a1 1
$OpenBSD$
d11 1
a11 1
+++ src/m68k/ffi.c	Wed Apr 24 15:23:09 2013
d83 15
a97 1
@@@@ -266,8 +291,12 @@@@ ffi_prep_closure_loc (ffi_closure* closure,
d99 5
a103 1
     *(void **)(closure->tramp + 8) = ffi_closure_SYSV;
@

