head	1.2;
access;
symbols
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2010.06.27.20.58.10;	author ckuethe;	state dead;
branches;
next	1.1;

1.1
date	2008.10.01.04.52.19;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to the latest AVR gcc, binutils, libc and gdb. Based on the FreeBSD
port, which is also in sync with winavr/avrstudio. Among other things, this
adds support for atmega328... which means new arduino boards should work.
@
text
@$OpenBSD: patch-libcpp_expr_c,v 1.1 2008/10/01 04:52:19 ckuethe Exp $
--- libcpp/expr.c.orig	Mon Aug 14 16:13:54 2006
+++ libcpp/expr.c	Sat Sep 27 16:29:43 2008
@@@@ -182,6 +182,11 @@@@ cpp_classify_number (cpp_reader *pfile, const cpp_toke
 	  radix = 16;
 	  str++;
 	}
+      else if ((*str == 'b' || *str == 'B') && (str[1] == '0' || str[1] == '1'))
+	{
+	  radix = 2;
+	  str++;
+	}
     }
 
   /* Now scan for a well-formed integer or float.  */
@@@@ -220,10 +225,22 @@@@ cpp_classify_number (cpp_reader *pfile, const cpp_toke
     radix = 10;
 
   if (max_digit >= radix)
-    SYNTAX_ERROR2 ("invalid digit \"%c\" in octal constant", '0' + max_digit);
+    {
+      if (radix == 2)
+	SYNTAX_ERROR2 ("invalid digit \"%c\" in binary constant", '0' + max_digit);
+      else
+	SYNTAX_ERROR2 ("invalid digit \"%c\" in octal constant", '0' + max_digit);
+    }
 
   if (float_flag != NOT_FLOAT)
     {
+      if (radix == 2)
+	{
+	  cpp_error (pfile, CPP_DL_ERROR,
+		     "invalid prefix \"0b\" for floating constant");
+	  return CPP_N_INVALID;
+	}
+
       if (radix == 16 && CPP_PEDANTIC (pfile) && !CPP_OPTION (pfile, c99))
 	cpp_error (pfile, CPP_DL_PEDWARN,
 		   "use of C99 hexadecimal floating constant");
@@@@ -308,11 +325,16 @@@@ cpp_classify_number (cpp_reader *pfile, const cpp_toke
   if ((result & CPP_N_IMAGINARY) && CPP_PEDANTIC (pfile))
     cpp_error (pfile, CPP_DL_PEDWARN,
 	       "imaginary constants are a GCC extension");
+  if (radix == 2 && CPP_PEDANTIC (pfile))
+    cpp_error (pfile, CPP_DL_PEDWARN,
+	       "binary constants are a GCC extension");
 
   if (radix == 10)
     result |= CPP_N_DECIMAL;
   else if (radix == 16)
     result |= CPP_N_HEX;
+  else if (radix == 2)
+    result |= CPP_N_BINARY;
   else
     result |= CPP_N_OCTAL;
 
@@@@ -363,6 +385,11 @@@@ cpp_interpret_integer (cpp_reader *pfile, const cpp_to
 	  base = 16;
 	  p += 2;
 	}
+      else if ((type & CPP_N_RADIX) == CPP_N_BINARY)
+	{
+	  base = 2;
+	  p += 2;
+	}
 
       /* We can add a digit to numbers strictly less than this without
 	 needing the precision and slowness of double integers.  */
@@@@ -418,12 +445,25 @@@@ static cpp_num
 append_digit (cpp_num num, int digit, int base, size_t precision)
 {
   cpp_num result;
-  unsigned int shift = 3 + (base == 16);
+  unsigned int shift;
   bool overflow;
   cpp_num_part add_high, add_low;
 
-  /* Multiply by 8 or 16.  Catching this overflow here means we don't
+  /* Multiply by 2, 8 or 16.  Catching this overflow here means we don't
      need to worry about add_high overflowing.  */
+  switch (base)
+    {
+    case 2:
+      shift = 1;
+      break;
+
+    case 16:
+      shift = 4;
+      break;
+
+    default:
+      shift = 3;
+    }
   overflow = !!(num.high >> (PART_PRECISION - shift));
   result.high = num.high << shift;
   result.low = num.low << shift;
@


1.1
log
@update to gcc-4.2.2. adds support for lots of new devices, makes it possible
to compile arduino compatible code. based on the freebsd port
@
text
@d1 1
a1 1
$OpenBSD$
@

