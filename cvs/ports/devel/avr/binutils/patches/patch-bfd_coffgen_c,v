head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.26
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.22
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.24
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.20
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.18
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.16
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.14
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.12
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2010.06.27.20.58.10;	author ckuethe;	state Exp;
branches;
next	1.2;

1.2
date	2009.12.09.16.55.51;	author ckuethe;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.01.04.46.19;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to the latest AVR gcc, binutils, libc and gdb. Based on the FreeBSD
port, which is also in sync with winavr/avrstudio. Among other things, this
adds support for atmega328... which means new arduino boards should work.
@
text
@$OpenBSD$
--- bfd/coffgen.c.orig	Sat Jun 26 11:23:52 2010
+++ bfd/coffgen.c	Sat Jun 26 11:31:17 2010
@@@@ -699,6 +699,20 @@@@ coff_renumber_symbols (bfd *bfd_ptr, int *first_undef)
 	      if (last_file != NULL)
 		last_file->n_value = native_index;
 	      last_file = &(s->u.syment);
+	      if (bfd_get_arch (bfd_ptr) == bfd_arch_avr
+		  && bfd_coff_long_filenames (bfd_ptr)
+		  && s->u.syment.n_numaux > 0)
+		{
+		  /* AVR COFF records long filenames in successive aux
+		     records.  Adjust the number of aux records
+		     required here, so the renumbering will account
+		     for them. */
+		  unsigned int filnmlen = bfd_coff_filnmlen (bfd_ptr);
+		  unsigned int namelen = strlen (coff_symbol_ptr->symbol.name);
+		  unsigned int n = (namelen + filnmlen - 1) / filnmlen;
+
+		  s->u.syment.n_numaux = n > NAUXENTS? NAUXENTS: n;
+		}
 	    }
 	  else
 	    /* Modify the symbol values according to their section and
@@@@ -827,6 +841,20 @@@@ coff_fix_symbol_name (bfd *abfd,
 	{
 	  if (name_length <= filnmlen)
 	    strncpy (auxent->x_file.x_fname, name, filnmlen);
+	  else if (bfd_get_arch (abfd) == bfd_arch_avr)
+	    {
+	      /* AVR COFF records long filenames in successive aux records. */
+	      int i = 1;
+	      while (name_length > filnmlen && i < NAUXENTS)
+		{
+		  strncpy (auxent->x_file.x_fname, name, filnmlen);
+		  name += filnmlen;
+		  name_length -= filnmlen;
+		  i++;
+		  auxent = &(native + i)->u.auxent;
+		}
+	      strncpy (auxent->x_file.x_fname, name, filnmlen);
+	    }
 	  else
 	    {
 	      auxent->x_file.x_n.x_offset = *string_size_p + STRING_SIZE_SIZE;
@@@@ -1272,6 +1300,10 @@@@ coff_write_symbols (bfd *abfd)
 		  if (bfd_bwrite (".file", (bfd_size_type) 6, abfd) != 6)
 		    return FALSE;
 		}
+	      if (bfd_get_arch (abfd) == bfd_arch_avr)
+		/* AVR COFF handles long file names in aux records. */
+		maxlen = name_length;
+	      else
 	      maxlen = bfd_coff_filnmlen (abfd);
 	    }
 	  else
@@@@ -1710,14 +1742,27 @@@@ coff_get_normalized_symtab (bfd *abfd)
 	    {
 	      /* Ordinary short filename, put into memory anyway.  The
                  Microsoft PE tools sometimes store a filename in
-                 multiple AUX entries.  */
+                 multiple AUX entries.
+		 AVR COFF does it that way, too. */
 	      if (internal_ptr->u.syment.n_numaux > 1
-		  && coff_data (abfd)->pe)
-		internal_ptr->u.syment._n._n_n._n_offset =
-		  ((bfd_hostptr_t)
-		   copy_name (abfd,
-			      (internal_ptr + 1)->u.auxent.x_file.x_fname,
-			      internal_ptr->u.syment.n_numaux * symesz));
+		  && (coff_data (abfd)->pe
+		      || (bfd_get_arch (abfd) == bfd_arch_avr)))
+		{
+		  char *b;
+		  unsigned int i;
+
+		  /* We allocate enough storage to fit the contents of
+		     this many aux records, and simply append a \0.
+		     This ensures the string will always be
+		     terminated, even in the case where it just fit
+		     into the aux records. */
+		  b = (char *) bfd_alloc (abfd,
+					  internal_ptr->u.syment.n_numaux * FILNMLEN + 1);
+		  internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) b;
+		  b[internal_ptr->u.syment.n_numaux * FILNMLEN] = '\0';
+		  for (i = 0; i < internal_ptr->u.syment.n_numaux; i++, b += FILNMLEN)
+		    memcpy (b, (internal_ptr + i + 1)->u.auxent.x_file.x_fname, FILNMLEN);
+		}
 	      else
 		internal_ptr->u.syment._n._n_n._n_offset =
 		  ((bfd_hostptr_t)
@@@@ -1823,9 +1868,9 @@@@ coff_bfd_make_debug_symbol (bfd *abfd,
 
   if (new_symbol == NULL)
     return NULL;
-  /* @@@@ The 10 is a guess at a plausible maximum number of aux entries
+  /* @@@@ The NAUXENTS is a guess at a plausible maximum number of aux entries
      (but shouldn't be a constant).  */
-  amt = sizeof (combined_entry_type) * 10;
+  amt = sizeof (combined_entry_type) * (NAUXENTS + 1);
   new_symbol->native = (combined_entry_type *) bfd_zalloc (abfd, amt);
   if (!new_symbol->native)
     return NULL;
@


1.2
log
@based on the freebsd port, update to binutils 2.19.1. adds support for
a whole bunch of new devices.
@
text
@d2 3
a4 3
--- bfd/coffgen.c.orig	Wed Aug 13 19:38:22 2008
+++ bfd/coffgen.c	Sun Dec  6 21:48:53 2009
@@@@ -687,6 +687,20 @@@@ coff_renumber_symbols (bfd *bfd_ptr, int *first_undef)
d25 1
a25 1
@@@@ -815,6 +829,20 @@@@ coff_fix_symbol_name (bfd *abfd,
d46 1
a46 1
@@@@ -1218,7 +1246,11 @@@@ coff_write_symbols (bfd *abfd)
a49 1
-	      maxlen = bfd_coff_filnmlen (abfd);
d54 1
a54 1
+		maxlen = bfd_coff_filnmlen (abfd);
d57 1
a57 2
 	    maxlen = bfd_coff_force_symnames_in_strings (abfd) ? 0 : SYMNMLEN;
@@@@ -1655,14 +1687,27 @@@@ coff_get_normalized_symtab (bfd *abfd)
d92 1
a92 1
@@@@ -1768,9 +1813,9 @@@@ coff_bfd_make_debug_symbol (bfd *abfd,
d94 1
a94 1
   if (new == NULL)
d97 2
a98 1
-     (but shouldn't be a constant).  */
a99 2
+  /* @@@@ The NAUXENTS is a guess at a plausible maximum number of aux
+     entries (but shouldn't be a constant).  */
d101 2
a102 2
   new->native = bfd_zalloc (abfd, amt);
   if (!new->native)
@


1.1
log
@update to binutils 2.18, plus some new devices. based on the freebsd port.
@
text
@d2 2
a3 2
--- bfd/coffgen.c.orig	Sun Aug 12 18:43:34 2007
+++ bfd/coffgen.c	Sat Sep 27 20:20:27 2008
@

