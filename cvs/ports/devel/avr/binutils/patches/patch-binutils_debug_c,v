head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.30
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.28
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.26
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.22
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.24
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.20
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.18
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.16
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.14
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.12
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2010.06.27.20.58.10;	author ckuethe;	state Exp;
branches;
next	1.2;

1.2
date	2009.12.09.16.55.51;	author ckuethe;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.01.04.46.20;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to the latest AVR gcc, binutils, libc and gdb. Based on the FreeBSD
port, which is also in sync with winavr/avrstudio. Among other things, this
adds support for atmega328... which means new arduino boards should work.
@
text
@$OpenBSD$
--- binutils/debug.c.orig	Sat Jun 26 11:22:43 2010
+++ binutils/debug.c	Sat Jun 26 11:31:17 2010
@@@@ -31,6 +31,7 @@@@
 #include <assert.h>
 #include "bfd.h"
 #include "libiberty.h"
+#include "bucomm.h"
 #include "debug.h"
 
 /* Global information we keep for debugging.  A pointer to this
@@@@ -552,6 +553,19 @@@@ struct debug_type_real_list
   struct debug_type_s *t;
 };
 
+/* Simple list, used for pathname translations. */
+struct xlat_list
+{
+  /* Next string on list. */
+  struct xlat_list *next;
+  /* Old part to match against. */
+  const char *old;
+  size_t olen;
+  /* New part to replace. */
+  const char *newstr;
+  size_t nlen;
+};
+
 /* Local functions.  */
 
 static void debug_error (const char *);
@@@@ -588,6 +602,11 @@@@ static bfd_boolean debug_type_samep
   (struct debug_handle *, struct debug_type_s *, struct debug_type_s *);
 static bfd_boolean debug_class_type_samep
   (struct debug_handle *, struct debug_type_s *, struct debug_type_s *);
+static const char *debug_xlat_pathname (const char *);
+
+/* List of pathname translations. */
+static struct xlat_list *xlat, *xltail;
+static bfd_boolean xlat_basename;
 
 /* Issue an error message.  */
 
@@@@ -680,6 +699,8 @@@@ debug_set_filename (void *handle, const char *name)
 
   if (name == NULL)
     name = "";
+  else
+    name = debug_xlat_pathname (name);
 
   nfile = (struct debug_file *) xmalloc (sizeof *nfile);
   memset (nfile, 0, sizeof *nfile);
@@@@ -720,6 +741,8 @@@@ debug_start_source (void *handle, const char *name)
 
   if (name == NULL)
     name = "";
+  else
+    name = debug_xlat_pathname (name);
 
   if (info->current_unit == NULL)
     {
@@@@ -3369,4 +3392,70 @@@@ debug_class_type_samep (struct debug_handle *info, str
     }
 
   return TRUE;
+}
+
+/* Register a pathname translation. */
+void
+debug_register_pathname_xlat (oname, nname)
+     const char *oname;
+     const char *nname;
+{
+  struct xlat_list *xlp;
+
+  /* Special case: if oname is given as NULL, this means the
+     --basename option has been given to objcopy. */
+  if (oname == NULL)
+    {
+      xlat_basename = TRUE;
+      return;
+    }
+
+  xlp = (struct xlat_list *) xmalloc (sizeof (struct xlat_list));
+  xlp->next = NULL;
+  if (xlat == NULL)
+    xlat = xltail = xlp;
+  else
+    {
+      xltail->next = xlp;
+      xltail = xlp;
+    }
+  xlp->old = oname;
+  xlp->newstr = nname;
+  xlp->olen = strlen (oname);
+  xlp->nlen = strlen (nname);
+}
+
+/* Try to translate a pathname. */
+static const char *
+debug_xlat_pathname (oname)
+     const char *oname;
+{
+  struct xlat_list *xlp;
+  char *cp;
+  size_t olen;
+
+  if (xlat_basename)
+    return bu_basename (oname);  
+
+  olen = strlen (oname);
+  for (xlp = xlat; xlp; xlp = xlp->next)
+    {
+      if (xlp->olen > olen)
+	/* This cannot be our turn. */
+	continue;
+      /* Since we have pre-computed all our length values to avoid
+	 repetitively computing them, just use memcmp() since it's
+	 faster than strcmp(). */
+      if (memcmp (xlp->old, oname, xlp->olen) == 0)
+	{
+	  cp = (char *) xmalloc (olen + xlp->nlen - xlp->olen + 1);
+	  memcpy (cp, xlp->newstr, xlp->nlen);
+	  memcpy (cp + xlp->nlen, oname + xlp->olen,
+		  olen - xlp->olen + 1);
+	  return cp;
+	}
+    }
+
+  /* Not found, pass the original name on. */
+  return oname;
 }
@


1.2
log
@based on the freebsd port, update to binutils 2.19.1. adds support for
a whole bunch of new devices.
@
text
@d2 2
a3 2
--- binutils/debug.c.orig	Thu Jul  5 09:54:45 2007
+++ binutils/debug.c	Sun Dec  6 21:48:53 2009
d13 1
a13 1
   struct debug_type *t;
d33 1
a33 1
   (struct debug_handle *, struct debug_type *, struct debug_type *);
d35 1
a35 1
   (struct debug_handle *, struct debug_type *, struct debug_type *);
@


1.1
log
@update to binutils 2.18, plus some new devices. based on the freebsd port.
@
text
@d2 2
a3 2
--- binutils/debug.c.orig	Mon Aug  6 12:55:10 2007
+++ binutils/debug.c	Sat Sep 27 20:20:27 2008
@

