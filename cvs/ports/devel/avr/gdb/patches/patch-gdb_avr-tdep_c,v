head	1.1;
access;
symbols
	OPENBSD_6_1:1.1.0.28
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.26
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.22
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.24
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.20
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.18
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.16
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.14
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.12
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.10
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.4
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.2
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2010.06.27.20.58.10;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Update to the latest AVR gcc, binutils, libc and gdb. Based on the FreeBSD
port, which is also in sync with winavr/avrstudio. Among other things, this
adds support for atmega328... which means new arduino boards should work.
@
text
@$OpenBSD$
--- gdb/avr-tdep.c.orig	Fri Jan 11 06:19:59 2008
+++ gdb/avr-tdep.c	Sat Jun 26 15:31:25 2010
@@@@ -181,8 +181,10 @@@@ struct avr_unwind_cache
 
 struct gdbarch_tdep
 {
-  /* FIXME: TRoth: is there anything to put here? */
-  int foo;
+  /* Size of the PC on the current AVR target.  This is equal 2 for
+     most AVRs except for the ATmega256x devices that have a 3-byte
+     PC. */
+  int pcsize;
 };
 
 /* Lookup the name of a register given it's number. */
@@@@ -1030,22 +1032,29 @@@@ avr_frame_prev_register (struct frame_info *next_frame
                  on the stack is in big endian byte order, even though most
                  everything else about the avr is little endian. Ick!  */
 
-              /* FIXME: number of bytes read here will need updated for the
-                 mega256 when it is available.  */
-
+	      struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
               ULONGEST pc;
               unsigned char tmp;
-              unsigned char buf[2];
+              unsigned char buf[3];
 
-              read_memory (info->saved_regs[regnum].addr, buf, 2);
+              read_memory (info->saved_regs[regnum].addr, buf, tdep->pcsize);
 
               /* Convert the PC read from memory as a big-endian to
                  little-endian order. */
-              tmp = buf[0];
-              buf[0] = buf[1];
-              buf[1] = tmp;
+	      if (tdep->pcsize == 2)
+		{
+		  tmp = buf[0];
+		  buf[0] = buf[1];
+		  buf[1] = tmp;
+		}
+	      else
+		{
+		  tmp = buf[0];
+		  buf[0] = buf[2];
+		  buf[2] = tmp;
+		}
 
-              pc = (extract_unsigned_integer (buf, 2) * 2);
+              pc = (extract_unsigned_integer (buf, tdep->pcsize) * 2);
               store_unsigned_integer
 		(bufferp, register_size (get_frame_arch (next_frame), regnum),
 		 pc);
@@@@ -1280,6 +1289,11 @@@@ avr_gdbarch_init (struct gdbarch_info info, struct gdb
     case bfd_mach_avr3:
     case bfd_mach_avr4:
     case bfd_mach_avr5:
+      tdep->pcsize = 2;
+      break;
+
+    case bfd_mach_avr6:
+      tdep->pcsize = 3;
       break;
     }
 
@
