head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.10
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	afresh1_20140404:1.1.1.2
	afresh1:1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.14
	OPENBSD_5_0:1.1.1.1.0.12
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.10
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.6
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.4
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	simon_20080820:1.1.1.1
	simon:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2014.04.05.09.10.13;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.05.06.20.05;	author afresh1;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.09.09.29.47;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2008.08.20.13.44.29;	author simon;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.08.20.13.44.29;	author simon;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.04.05.06.07.40;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.4
log
@simplify DESCR
@
text
@Method modifiers are a powerful feature from the CLOS (Common Lisp
Object System) world. In its most basic form, a method modifier is just
a method that calls $self->SUPER::foo(@@_).

Class::Method::Modifiers provides three modifiers: before, around, and
after. "before" and "after" are run just before and after the method they
modify, but can not really affect that original method. "around" is run in
place of the original method, with a hook to easily call that original
method.

One clear benefit of using Class::Method::Modifiers is that you can
define multiple modifiers in a single namespace. These separate modifiers
don't need to know about each other. This makes top-down design easy.
Have a base class that provides the skeleton methods of each operation,
and have plugins modify those methods to flesh out the specifics.

In short, Class::Method::Modifiers solves the problem of making sure you
call $self->SUPER::foo(@@_), and provides a cleaner interface for it.
@


1.3
log
@Bring back p5-Class-Method-Modifiers-2.10

Needed now for p5-Moo

From new maintainer Sergey Bronniko
@
text
@d2 2
a3 6
Object System) world.

In its most basic form, a method modifier is just a method that calls
$self->SUPER::foo(@@_). I for one have trouble remembering that exact
invocation, so my classes seldom re-dispatch to their base classes.
Very bad!
d6 2
a7 2
after.  before and after are run just before and after the method they
modify, but can not really affect that original method. around is run in
d12 4
a15 5
define multiple modifiers in a single namespace. These separate
modifiers don't need to know about each other. This makes top-down
design easy. Have a base class that provides the skeleton methods of
each operation, and have plugins modify those methods to flesh out the
specifics.
@


1.2
log
@Remove p5-Class-Method-Modifiers, was only needed for the old versions of
p5-Mouse and no longer used. Pointed out by Andreas VÃ¶gele.
@
text
@d3 6
d11 13
a23 3
modify, but can not really affect that original method.  around is run
in place of the original method, with a hook to easily call that
original method.
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import p5-Class-Method-Modifiers

Method modifiers are a powerful feature from the CLOS (Common Lisp
Object System) world.
Class::Method::Modifiers provides three modifiers: before, around, and
after.  before and after are run just before and after the method they
modify, but can not really affect that original method.  around is run
in place of the original method, with a hook to easily call that
original method.
@
text
@@


1.1.1.2
log
@Import p5-Class-Method-Modifiers-2.10

From new maintainer Sergey Bronniko
@
text
@a2 6

In its most basic form, a method modifier is just a method that calls
$self->SUPER::foo(@@_). I for one have trouble remembering that exact
invocation, so my classes seldom re-dispatch to their base classes.
Very bad!

d5 3
a7 13
modify, but can not really affect that original method. around is run in
place of the original method, with a hook to easily call that original
method.

One clear benefit of using Class::Method::Modifiers is that you can
define multiple modifiers in a single namespace. These separate
modifiers don't need to know about each other. This makes top-down
design easy. Have a base class that provides the skeleton methods of
each operation, and have plugins modify those methods to flesh out the
specifics.

In short, Class::Method::Modifiers solves the problem of making sure you
call $self->SUPER::foo(@@_), and provides a cleaner interface for it.
@

