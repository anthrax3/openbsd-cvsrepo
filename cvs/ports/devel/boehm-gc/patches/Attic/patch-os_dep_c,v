head	1.9;
access;
symbols
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.16
	OPENBSD_5_0:1.7.0.14
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.12
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.8
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.6.0.4
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@# @;


1.9
date	2013.06.01.21.05.28;	author kurt;	state dead;
branches;
next	1.8;

1.8
date	2012.02.22.12.31.42;	author kurt;	state Exp;
branches;
next	1.7;

1.7
date	2008.04.01.17.41.13;	author kurt;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.14.22.16.17;	author kili;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.16.04.11.15;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.15.12.58.11;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.17.21.00.45;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.26.13.25.26;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.27.15.41.30;	author todd;	state Exp;
branches;
next	;


desc
@@


1.9
log
@- Update to 7.2d. Tested on i386, amd64, sparc64, macppc, hppa and alpha.
okay and testing by sthen, landry, thanks!
@
text
@--- os_dep.c.orig	Fri Jun 29 15:17:44 2007
+++ os_dep.c	Sun Feb 19 13:28:15 2012
@@@@ -486,7 +486,7 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
 #define sbrk tiny_sbrk
 # endif /* ECOS */
 
-#if (defined(NETBSD) || defined(OPENBSD)) && defined(__ELF__)
+#if defined(NETBSD) && defined(__ELF__)
   ptr_t GC_data_start;
 
   void GC_init_netbsd_elf(void)
@@@@ -499,6 +499,86 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
   }
 #endif
 
+#if defined(OPENBSD)
+  static struct sigaction old_segv_act;
+  sigjmp_buf GC_jmp_buf_openbsd;
+
+    /*ARGSUSED*/
+    void GC_fault_handler_openbsd(int sig)
+    {
+	siglongjmp(GC_jmp_buf_openbsd, 1);
+    }
+
+    /* Return the first nonaddressible location > p or bound	*/
+    /* Requires allocation lock.				*/
+    ptr_t GC_find_limit_openbsd(ptr_t p, ptr_t bound)
+    {
+        static volatile ptr_t result;
+               /* Safer if static, since otherwise it may not be       */
+               /* preserved across the longjmp.  Can safely be         */
+               /* static since it's only called with the               */
+               /* allocation lock held.                                */
+        struct sigaction act;
+	size_t pgsz = (size_t)sysconf(_SC_PAGESIZE);
+
+	GC_ASSERT(I_HOLD_LOCK());
+
+        act.sa_handler = GC_fault_handler_openbsd;
+        sigemptyset(&act.sa_mask);
+        act.sa_flags = SA_NODEFER | SA_RESTART;
+        sigaction(SIGSEGV, &act, &old_segv_act);
+
+	if (sigsetjmp(GC_jmp_buf_openbsd, 1) == 0) {
+	    result = (ptr_t)(((word)(p)) & ~(pgsz-1));
+	    for (;;) {
+	        result += pgsz;
+	        if (result >= bound) {
+		    result = bound;
+		    break;
+ 	        }
+	        GC_noop1((word)(*result));
+	    }
+	}
+
+	sigaction(SIGSEGV, &old_segv_act, 0);
+
+	return(result);
+    }
+
+    /* Return first addressable location > p or bound */
+    /* Requires allocation lock. */
+    ptr_t GC_skip_hole_openbsd(ptr_t p, ptr_t bound)
+    {
+        static volatile ptr_t result;
+        struct sigaction act;
+	size_t pgsz = (size_t)sysconf(_SC_PAGESIZE);
+	static volatile int firstpass;
+
+	GC_ASSERT(I_HOLD_LOCK());
+
+        act.sa_handler = GC_fault_handler_openbsd;
+        sigemptyset(&act.sa_mask);
+        act.sa_flags = SA_NODEFER | SA_RESTART;
+        sigaction(SIGSEGV, &act, &old_segv_act);
+
+	firstpass = 1;
+	result = (ptr_t)(((word)(p)) & ~(pgsz-1));
+	if (sigsetjmp(GC_jmp_buf_openbsd, 1) != 0 || firstpass) {
+	    firstpass = 0;
+	    result += pgsz;
+	    if (result >= bound) {
+		result = bound;
+	    } else
+	        GC_noop1((word)(*result));
+        }
+
+	sigaction(SIGSEGV, &old_segv_act, 0);
+
+	return(result);
+    }
+#endif
+
+
 # ifdef OS2
 
 # include <stddef.h>
@@@@ -1097,7 +1177,7 @@@@ ptr_t GC_get_main_stack_base(void)
 
 #if !defined(BEOS) && !defined(AMIGA) && !defined(MSWIN32) \
     && !defined(MSWINCE) && !defined(OS2) && !defined(NOSYS) && !defined(ECOS) \
-    && !defined(CYGWIN32)
+    && !defined(CYGWIN32) && !defined(GC_OPENBSD_THREADS)
 
 ptr_t GC_get_main_stack_base(void)
 {
@@@@ -1206,6 +1286,35 @@@@ int GC_get_stack_base(struct GC_stack_base *b)
 
 #endif /* GC_LINUX_THREADS */
 
+#if defined(GC_OPENBSD_THREADS)
+
+/* Find the stack using pthread_stackseg_np() */
+
+# include <sys/signal.h>
+# include <pthread.h>
+# include <pthread_np.h>
+        
+#define HAVE_GET_STACK_BASE
+
+int GC_get_stack_base(struct GC_stack_base *sb)
+{
+    stack_t stack;
+    pthread_stackseg_np(pthread_self(), &stack);
+    sb->mem_base = stack.ss_sp;
+    return GC_SUCCESS;
+}
+
+/* This is always called from the main thread.	*/
+ptr_t GC_get_main_stack_base(void)
+{
+    struct GC_stack_base sb;
+
+    GC_get_stack_base(&sb);
+    return (ptr_t)sb.mem_base;
+}
+
+#endif /* GC_OPENBSD_THREADS */
+
 #ifndef HAVE_GET_STACK_BASE
 /* Retrieve stack base.						*/
 /* Using the GC_find_limit version is risky.			*/
@@@@ -1660,8 +1769,33 @@@@ ptr_t GC_FreeBSDGetDataStart(size_t max_page_size, ptr
 
 #else /* !OS2 && !Windows && !AMIGA */
 
+#if defined(OPENBSD)
+
+/*
+ * Depending on arch alignment there can be multiple holes
+ * between DATASTART & DATAEND. Scan from DATASTART - DATAEND
+ * and register each region.
+ */
 void GC_register_data_segments(void)
 {
+  ptr_t region_start, region_end;
+
+  region_start = DATASTART;
+
+  for(;;) {
+    region_end = GC_find_limit_openbsd(region_start, DATAEND);
+    GC_add_roots_inner(region_start, region_end, FALSE);
+    if (region_end < DATAEND)
+    	region_start = GC_skip_hole_openbsd(region_end, DATAEND);
+    else
+	break;
+  }
+}
+
+# else /* !OS2 && !Windows && !AMIGA && !OPENBSD */
+
+void GC_register_data_segments(void)
+{
 #   if !defined(PCR) && !defined(MACOS)
 #     if defined(REDIRECT_MALLOC) && defined(GC_SOLARIS_THREADS)
 	/* As of Solaris 2.3, the Solaris threads implementation	*/
@@@@ -1717,6 +1851,7 @@@@ void GC_register_data_segments(void)
     /* change.								*/
 }
 
+# endif  /* ! OPENBSD */
 # endif  /* ! AMIGA */
 # endif  /* ! MSWIN32 && ! MSWINCE*/
 # endif  /* ! OS2 */
@


1.8
log
@Remove uthreads work-arounds. Works ok with rthreads now.
Tested by sthen@@ and espie@@
@
text
@@


1.7
log
@- use __data_start symbol to find the beginning of the data sections
and adjust boehm-gc to deal with any number of holes that may appear
between __data_start and _end. (requires -current binutils)
- work-around libpthread bugs that prevent sigsuspend() from working
in a signal handler by using pthread_suspend_np() + an arch/libpthread
specific offset to obtain the suspended thread's stack pointer.

thanks to sthen@@ and jasper@@ for access to other arches. discussed
with todd@@
@
text
@d2 1
a2 1
+++ os_dep.c	Fri Feb  8 15:35:41 2008
d12 1
a12 1
@@@@ -499,6 +499,103 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
a19 12
+# if defined(GC_OPENBSD_THREADS)
+#   include <sys/syscall.h>
+    sigset_t __syscall(quad_t, ...);
+# endif
+
+  /*
+   * Dont use GC_find_limit() because siglongjmp out of the
+   * signal handler by-passes our userland pthreads lib, leaving
+   * SIGSEGV and SIGPROF masked. Instead use this custom one
+   * that works-around the issues.
+   */
+
a56 5
+# if defined(GC_OPENBSD_THREADS)
+	/* due to the siglongjump we need to manually unmask SIGPROF */
+	__syscall(SYS_sigprocmask, SIG_UNBLOCK, sigmask(SIGPROF));
+# endif
+
d99 1
a99 1
@@@@ -1097,7 +1194,7 @@@@ ptr_t GC_get_main_stack_base(void)
d108 1
a108 1
@@@@ -1206,6 +1303,35 @@@@ int GC_get_stack_base(struct GC_stack_base *b)
d144 1
a144 1
@@@@ -1660,8 +1786,33 @@@@ ptr_t GC_FreeBSDGetDataStart(size_t max_page_size, ptr
d178 1
a178 1
@@@@ -1717,6 +1868,7 @@@@ void GC_register_data_segments(void)
@


1.6
log
@
Update to 7.0.

Most work done by kurt@@, who got bleeding eyes and has been trapped
into pthread issues because some of us (me and Stuart Henderson)
were slopyy and applied some patches only partial. A big sorry to
kurt@@ for this waste of time!

Tested by many. Intermediate ok's (IIRC) from kurt@@, naddy@@ and todd@@.
@
text
@d2 1
a2 1
+++ os_dep.c	Thu Jul 12 22:25:04 2007
d12 1
a12 1
@@@@ -499,6 +499,106 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
d17 1
a17 1
+  ptr_t GC_data_end1, GC_data_start2;
d35 1
a35 1
+        siglongjmp(GC_jmp_buf_openbsd, 1);
d38 1
a38 3
+    /* Return the first nonaddressible location > p (up) or 	*/
+    /* the smallest location q s.t. [q,p) is addressable (!up).	*/
+    /* We assume that p (up) or p-1 (!up) is addressable.	*/
d40 1
a40 1
+    ptr_t GC_find_limit_openbsd(ptr_t p, GC_bool up, ptr_t bound)
d43 4
a46 4
+    		/* Safer if static, since otherwise it may not be	*/
+    		/* preserved across the longjmp.  Can safely be 	*/
+    		/* static since it's only called with the		*/
+    		/* allocation lock held.				*/
d54 2
a55 2
+        act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_RESTART;
+        sigaction(SIGSEGV, &act, NULL);
d58 1
a58 2
+	    result = (ptr_t)(((word)(p))
+			      & ~(pgsz-1));
d60 4
a63 12
+ 	        if (up) {
+		    result += pgsz;
+		    if (result >= bound) {
+		        result = bound;
+			break;
+		    }
+ 	        } else {
+		    result -= pgsz;
+		    if (result <= bound) {
+		        result = bound;
+			break;
+		    }
d65 1
a65 1
+		GC_noop1((word)(*result));
d68 1
d71 1
a71 1
+	 __syscall(SYS_sigprocmask, SIG_UNBLOCK, sigmask(SIGPROF));
d73 3
a75 3
+ 	if (!up && result != bound) {
+	    result += pgsz;
+ 	}
d79 30
a108 22
+  /*
+   * Depending on arch alignment there can be two holes in
+   * .data - end of .bss. Fortunately no pointers can be stored
+   * between the two holes. A better way of doing this would
+   * be to do something similar to how libraries are handled
+   * (section by section).
+   */
+  void GC_init_openbsd()
+  {
+    extern char _edata[];
+    ptr_t GC_find_limit(ptr_t, GC_bool);
+    GC_data_end1 = GC_find_limit_openbsd(DATASTART, TRUE, DATAEND2);
+    if (GC_data_end1 >= DATAEND2) {
+	/* no holes */
+        GC_data_end1 = (ptr_t)(&_edata);
+        GC_data_start2 = GC_data_end1;
+    } else {
+        /* search back to find second hole */
+        GC_data_start2 = GC_find_limit_openbsd(DATAEND2, FALSE, DATASTART);
+	/* not needed but for sanity */
+	if (GC_data_start2 < GC_data_end1)
+		GC_data_start2 = GC_data_end1;
a109 1
+  }
d116 1
a116 1
@@@@ -1097,7 +1197,7 @@@@ ptr_t GC_get_main_stack_base(void)
d125 1
a125 2
@@@@ -1205,6 +1305,35 @@@@ int GC_get_stack_base(struct GC_stack_base *b)
 #define HAVE_GET_STACK_BASE
d128 1
a128 1
+
d157 1
a157 1
 
d160 43
@


1.5
log
@teach boehm-gc about m68k
@
text
@d1 12
a12 4
$OpenBSD: patch-os_dep_c,v 1.4 2003/10/15 12:58:11 todd Exp $
--- os_dep.c.orig	2003-06-13 14:11:00.000000000 -0500
+++ os_dep.c	2003-10-16 02:31:36.000000000 -0500
@@@@ -391,6 +391,30 @@@@ static void *tiny_sbrk(ptrdiff_t increme
d17 34
a50 2
+  #if defined(__ELF__)
+  ptr_t GC_data_start;
d52 36
a87 9
+  void GC_init_openbsd_elf()
+  {
+    extern ptr_t GC_find_limit();
+	/* This may need to be environ, without the underscore, for	*/
+	/* some versions.						*/
+    GC_data_start = GC_find_limit((ptr_t)&end, FALSE);
+  }
+  #else
+  ptr_t GC_data_start;
d89 8
a96 1
+  void GC_init_openbsd_aout()
d98 14
a111 4
+    extern ptr_t GC_find_limit();
+	/* This may need to be environ, without the underscore, for	*/
+	/* some versions.						*/
+    GC_data_start = GC_find_limit((ptr_t)&end, FALSE);
a112 1
+  #endif
d115 1
d119 45
@


1.4
log
@Thanks to marius at monkey dot org for unbreaking this port.
Thanks to Andrew Delgleish for updating this to 6.2
patches submitted upstream.
@
text
@d1 4
a4 4
$OpenBSD: patch-os_dep_c,v 1.3 2003/01/17 21:00:45 drahn Exp $
--- os_dep.c.orig	2003-06-14 05:11:00.000000000 +1000
+++ os_dep.c	2003-10-15 13:40:09.000000000 +1000
@@@@ -391,6 +391,18 @@@@ static void *tiny_sbrk(ptrdiff_t increme
d8 2
a9 1
+#if defined(OPENBSD) && defined(__ELF__)
d19 11
@


1.3
log
@Instead of using a data symbol to find the last mapped section of the
executable, use _end. This is done other places in the file, and works
with latest ELF linker changes, (This only affects OpenBSD/ELF). ok todd@@
@
text
@d1 4
a4 4
$OpenBSD: patch-os_dep_c,v 1.2 2002/10/26 13:25:26 todd Exp $
--- os_dep.c.orig	Wed Jul 31 17:13:18 2002
+++ os_dep.c	Thu Jan  9 16:14:45 2003
@@@@ -233,6 +233,18 @@@@ static void *tiny_sbrk(ptrdiff_t increme
@


1.2
log
@thanks to drahn@@ update to gc6.1 (misc bugfixes, I've heard good things, etc,
best of all, you can drop this in on shared archs as a replacement for 6.0,
I've tested opencm and w3m)
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
+++ os_dep.c	Fri Oct 25 12:30:33 2002
@@@@ -233,6 +233,19 @@@@ static void *tiny_sbrk(ptrdiff_t increme
a13 1
+    extern char **environ;
d16 1
a16 1
+    GC_data_start = GC_find_limit((ptr_t)&environ, FALSE);
@


1.1
log
@update to 6.0
misc pieces from art@@, pval@@, and myself
@
text
@d2 3
a4 3
--- os_dep.c.orig	Thu Jul 26 20:39:45 2001
+++ os_dep.c	Wed Jul 31 07:29:54 2002
@@@@ -232,6 +232,19 @@@@ static void *tiny_sbrk(ptrdiff_t increme
a23 8
@@@@ -630,7 +643,6 @@@@ ptr_t GC_get_stack_base()
     		/* preserved across the longjmp.  Can safely be 	*/
     		/* static since it's only called once, with the		*/
     		/* allocation lock held.				*/
-
 
 	GC_setup_temporary_fault_handler();
 	if (setjmp(GC_jmp_buf) == 0) {
@

