head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.32
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.28
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.30
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.26
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.24
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.22
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.20
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.18
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.16
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.14
	OPENBSD_5_0:1.1.1.1.0.12
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.10
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.6
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.4
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	sthen_20090217:1.1.1.1
	sthen:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2009.02.17.00.16.04;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.02.17.00.16.04;	author sthen;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$

http://www.cvstrac.org/cvstrac/chngview?cn=994
Avoid using sqlite internal functions.

http://www.cvstrac.org/cvstrac/chngview?cn=932
chng and inspect records are viewable by people with wiki read
permissions, not checkout.

http://www.cvstrac.org/cvstrac/chngview?cn=969
Use sqlite3_free() not free() on functions returning memory strings.

--- db.c.orig	Thu Aug  7 01:15:31 2008
+++ db.c	Thu Aug  7 01:15:21 2008
@@@@ -31,6 +31,7 @@@@
 #include <errno.h>
 #include <sqlite3.h>
 #include <string.h>
+#include <strings.h>
 #include <wchar.h>
 #include "config.h"
 #include "db.h"
@@@@ -125,7 +126,6 @@@@ static int query_authorizer(
 ** routine NULLs-out fields of the database we do not want arbitrary
 ** users to see, such as the USER.PASSWD field.
 */
-extern int sqlite3StrICmp(const char*, const char*);
 static int access_authorizer(
   void *NotUsed,
   int type,
@@@@ -141,34 +141,34 @@@@ static int access_authorizer(
     return SQLITE_OK;
 #endif
   }else if( type==SQLITE_READ ){
-    if( sqlite3StrICmp(zArg1,"user")==0 ){
-      if( sqlite3StrICmp(zArg2,"passwd")==0 || sqlite3StrICmp(zArg2,"email")==0 ){
+    if( strcasecmp(zArg1,"user")==0 ){
+      if( strcasecmp(zArg2,"passwd")==0 || strcasecmp(zArg2,"email")==0 ){
         return SQLITE_IGNORE;
       }
-    }else if( sqlite3StrICmp(zArg1, "cookie")==0 ){
+    }else if( strcasecmp(zArg1, "cookie")==0 ){
       return SQLITE_IGNORE;
-    }else if( sqlite3StrICmp(zArg1, "config")==0 ){
+    }else if( strcasecmp(zArg1, "config")==0 ){
       return SQLITE_IGNORE;
-    }else if( !g.okSetup && sqlite3StrICmp(zArg1, "access_load")==0 ){
+    }else if( !g.okSetup && strcasecmp(zArg1, "access_load")==0 ){
       return SQLITE_IGNORE;
-    }else if( (!g.okWrite || g.isAnon) && sqlite3StrICmp(zArg1,"ticket")==0
-        && sqlite3StrICmp(zArg2,"contact")==0){
+    }else if( (!g.okWrite || g.isAnon) && strcasecmp(zArg1,"ticket")==0
+        && strcasecmp(zArg2,"contact")==0){
       return SQLITE_IGNORE;
-    }else if( !g.okCheckout && sqlite3StrICmp(zArg1,"chng")==0 ){
+    }else if( !g.okRead && strcasecmp(zArg1,"chng")==0 ){
       return SQLITE_IGNORE;
-    }else if( !g.okCheckout && sqlite3StrICmp(zArg1,"filechng")==0 ){
+    }else if( !g.okCheckout && strcasecmp(zArg1,"filechng")==0 ){
       return SQLITE_IGNORE;
-    }else if( !g.okCheckout && sqlite3StrICmp(zArg1,"file")==0 ){
+    }else if( !g.okCheckout && strcasecmp(zArg1,"file")==0 ){
       return SQLITE_IGNORE;
-    }else if( !g.okCheckout && sqlite3StrICmp(zArg1,"inspect")==0 ){
+    }else if( !g.okRead && strcasecmp(zArg1,"inspect")==0 ){
       return SQLITE_IGNORE;
-    }else if( !g.okRead && sqlite3StrICmp(zArg1,"ticket")==0 ){
+    }else if( !g.okRead && strcasecmp(zArg1,"ticket")==0 ){
       return SQLITE_IGNORE;
-    }else if( !g.okRead && sqlite3StrICmp(zArg1,"tktchng")==0 ){
+    }else if( !g.okRead && strcasecmp(zArg1,"tktchng")==0 ){
       return SQLITE_IGNORE;
-    }else if( !g.okRdWiki && sqlite3StrICmp(zArg1,"attachment")==0 ){
+    }else if( !g.okRdWiki && strcasecmp(zArg1,"attachment")==0 ){
       return SQLITE_IGNORE;
-    }else if( !g.okRdWiki && sqlite3StrICmp(zArg1,"wiki")==0 ){
+    }else if( !g.okRdWiki && strcasecmp(zArg1,"wiki")==0 ){
       return SQLITE_IGNORE;
     }
     return SQLITE_OK;
@@@@ -326,7 +326,7 @@@@ char **db_query(const char *zFormat, ...){
     db_err( zErrMsg ? zErrMsg : sqlite3_errmsg(pDb), zSql,
             "db_query: Database query failed" );
   }
-  free(zSql);
+  sqlite3_free(zSql);
   if( sResult.azElem==0 ){
     db_query_callback(&sResult, 0, 0, 0);
   }
@@@@ -385,7 +385,7 @@@@ char *db_short_query(const char *zFormat, ...){
     db_err( zErrMsg ? zErrMsg : sqlite3_errmsg(pDb), zSql,
             "db_short_query: Database query failed" );
   }
-  free(zSql);
+  sqlite3_free(zSql);
   return zResult;
 }
 
@@@@ -409,7 +409,7 @@@@ void db_execute(const char *zFormat, ...){
   if( rc!=SQLITE_OK ){
     db_err(zErrMsg, zSql, "db_execute: Database execute failed");
   }
-  free(zSql);
+  sqlite3_free(zSql);
 }
 
 /*
@@@@ -448,7 +448,7 @@@@ int db_exists(const char *zFormat, ...){
   if( rc!=SQLITE_OK ){
     db_err(zErrMsg, zSql, "db_exists: Database exists query failed");
   }
-  free(zSql);
+  sqlite3_free(zSql);
   return iResult;
 }
 
@@@@ -470,6 +470,7 @@@@ char *db_query_check(const char *zFormat, ...){
   db_restrict_query(1);
   rc = sqlite3_exec(pDb, zSql, 0, 0, &zErrMsg);
   db_restrict_query(0);
+  sqlite3_free(zSql);
   return (rc!=SQLITE_OK) ? zErrMsg : 0;
 }
 
@@@@ -538,7 +539,7 @@@@ void db_callback_query(
     db_err(zErrMsg ? zErrMsg : sqlite3_errmsg(pDb), zSql,
            "db_callback_query: Database query failed");
   }
-  free(zSql);
+  sqlite3_free(zSql);
 }
 
 /*
@@@@ -565,7 +566,7 @@@@ void db_callback_execute(
     db_err(zErrMsg ? zErrMsg : sqlite3_errmsg(pDb), zSql,
            "db_callback_execute: Database query failed");
   }
-  free(zSql);
+  sqlite3_free(zSql);
 }
 
 /*
@@@@ -672,7 +673,6 @@@@ static void f_cgi(sqlite3_context *context, int argc, 
 ** name as an argument and returns the value that the user enters in the
 ** resulting HTML form. A second optional parameter provides a default value.
 */
-extern int sqlite3StrICmp(const char*, const char*);
 static void f_aux(sqlite3_context *context, int argc, sqlite3_value **argv){
   int i;
   const char *zParm;
@@@@ -682,7 +682,7 @@@@ static void f_aux(sqlite3_context *context, int argc, 
   if( zParm==0 ) return;
 
   for(i=0; i<g.nAux && g.azAuxName[i]; i++){
-    if( sqlite3StrICmp(zParm,g.azAuxName[i])==0 ){
+    if( strcasecmp(zParm,g.azAuxName[i])==0 ){
       if( g.azAuxVal[i] ){
         sqlite3_result_text(context, g.azAuxVal[i], -1, SQLITE_STATIC);
       }
@@@@ -712,7 +712,6 @@@@ static void f_aux(sqlite3_context *context, int argc, 
 ** currently selected value.  Results may be a single value column or
 ** two value,description columns.  The first result row is the default.
 */
-extern int sqlite3StrICmp(const char*, const char*);
 static void f_option(sqlite3_context *context, int argc, sqlite3_value **argv){
   const char *zParm;
   int i;
@@@@ -722,7 +721,7 @@@@ static void f_option(sqlite3_context *context, int arg
   if( zParm==0 ) return;
 
   for(i=0; i<g.nAux && g.azAuxName[i]; i++){
-    if( sqlite3StrICmp(zParm,g.azAuxName[i])==0 ){
+    if( strcasecmp(zParm,g.azAuxName[i])==0 ){
       if( g.azAuxVal[i] ){
         sqlite3_result_text(context, g.azAuxVal[i], -1, SQLITE_STATIC);
       }
@


1.1.1.1
log
@import cvstrac; N.B. requires a recent /usr/bin/rlog (thanks Joris!)

CVSTrac implements a patch-set and bug tracking system for CVS
as a single self-contained executable, running as CGI, from inetd,
or as a stand-alone web server.

- Automatically generates a patch-set log from check-in comments
- User-defined color-coded database queries
- Built-in repository browser and Wiki
- Minimal memory, disk and CPU requirements
- Per-user access control
- Uses SQLite, no heavy database engine dependency
- Can be run from a chroot jail
@
text
@@
