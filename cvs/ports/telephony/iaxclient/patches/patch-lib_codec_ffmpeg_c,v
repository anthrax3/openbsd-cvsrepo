head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.10
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.4
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.2
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2014.04.27.20.52.50;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2013.01.20.12.52.35;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.30.09.48.21;	author sebastia;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.18.17.32.21;	author sebastia;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update for newer FFmpeg API.

ok sebastia@@
@
text
@$OpenBSD: patch-lib_codec_ffmpeg_c,v 1.3 2013/01/20 12:52:35 brad Exp $

Update for newer FFmpeg API.

--- lib/codec_ffmpeg.c.orig	Mon Apr  7 12:05:42 2008
+++ lib/codec_ffmpeg.c	Thu Apr 24 20:26:53 2014
@@@@ -23,11 +23,7 @@@@
 #include "codec_ffmpeg.h"
 #include "iaxclient_lib.h"
 
-#ifdef WIN32
 #include "libavcodec/avcodec.h"
-#else
-#include <ffmpeg/avcodec.h>
-#endif
 
 struct slice_header_t
 {
@@@@ -63,7 +59,7 @@@@ struct decoder_ctx
 
 static struct slice_set_t * g_slice_set = 0;
 
-static enum CodecID map_iaxc_codec_to_avcodec(int format)
+static enum AVCodecID map_iaxc_codec_to_avcodec(int format)
 {
 	switch (format)
 	{
@@@@ -165,10 +161,14 @@@@ static int pass_frame_to_decoder(AVCodecContext * avct
 {
 	int bytes_decoded;
 	int got_picture;
+	AVPacket pkt;
 
-	bytes_decoded = avcodec_decode_video(avctx, picture, &got_picture,
-			in, inlen);
+	pkt.data = in;
+	pkt.size = inlen;
 
+	bytes_decoded = avcodec_decode_video2(avctx, picture, &got_picture,
+			&pkt);
+
 	if ( bytes_decoded != inlen )
 	{
 		fprintf(stderr,
@@@@ -309,10 +309,14 @@@@ static int decode_rtp_slice(struct iaxc_video_codec * 
 	{
 		int bytes_decoded;
 		int got_picture;
+		AVPacket pkt;
 
-		bytes_decoded = avcodec_decode_video(d->avctx, d->picture,
-				&got_picture, (unsigned char *)in, inlen);
+		pkt.data = (unsigned char *)in;
+		pkt.size = inlen;
 
+		bytes_decoded = avcodec_decode_video2(d->avctx, d->picture,
+				&got_picture, &pkt);
+
 		if ( bytes_decoded < 0 )
 		{
 			fprintf(stderr,
@@@@ -441,6 +445,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 {
 	struct encoder_ctx *e;
 	struct decoder_ctx *d;
+	AVDictionary *opts = NULL;
 	AVCodec *codec;
 	int ff_enc_id, ff_dec_id;
 	char *name;
@@@@ -454,7 +459,6 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 		return NULL;
 	}
 
-	avcodec_init();
 	avcodec_register_all();
 
 	c->format = format;
@@@@ -475,7 +479,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 	if (!c->encstate)
 		goto bail;
 	e = c->encstate;
-	e->avctx = avcodec_alloc_context();
+	e->avctx = avcodec_alloc_context3(NULL);
 	if (!e->avctx)
 		goto bail;
 	e->picture = avcodec_alloc_frame();
@@@@ -496,7 +500,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 	if (!c->decstate)
 		goto bail;
 	d = c->decstate;
-	d->avctx = avcodec_alloc_context();
+	d->avctx = avcodec_alloc_context3(NULL);
 	if (!d->avctx)
 		goto bail;
 	d->picture = avcodec_alloc_frame();
@@@@ -524,9 +528,6 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 	e->avctx->pix_fmt = PIX_FMT_YUV420P;
 	e->avctx->has_b_frames = 0;
 
-	e->avctx->mb_qmin = e->avctx->qmin = 10;
-	e->avctx->mb_qmax = e->avctx->qmax = 10;
-
 	e->avctx->lmin = 2 * FF_QP2LAMBDA;
 	e->avctx->lmax = 10 * FF_QP2LAMBDA;
 	e->avctx->global_quality = FF_QP2LAMBDA * 2;
@@@@ -561,7 +562,8 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 			c->decode = decode_rtp_slice;
 			e->avctx->rtp_payload_size = fragsize;
 			e->avctx->flags |=
-				CODEC_FLAG_TRUNCATED | CODEC_FLAG2_STRICT_GOP;
+				CODEC_FLAG_TRUNCATED;
+			av_dict_set(&opts, "strict_gop", "1", 0);
 			e->avctx->rtp_callback = encode_rtp_callback;
 			d->avctx->flags |= CODEC_FLAG_TRUNCATED;
 		}
@@@@ -581,9 +583,9 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 			e->avctx->rtp_payload_size = fragsize;
 			e->avctx->flags |=
 				CODEC_FLAG_TRUNCATED |
-				CODEC_FLAG_H263P_SLICE_STRUCT |
-				CODEC_FLAG2_STRICT_GOP |
 				CODEC_FLAG2_LOCAL_HEADER;
+			av_dict_set(&opts, "strict_gop", "1", 0);
+			av_dict_set(&opts, "structured_slices", "1", 0);
 			e->avctx->rtp_callback = encode_rtp_callback;
 			d->avctx->flags |= CODEC_FLAG_TRUNCATED;
 		}
@@@@ -596,10 +598,9 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 		e->avctx->rtp_callback = encode_rtp_callback;
 		e->avctx->flags |=
 			CODEC_FLAG_TRUNCATED |
-			CODEC_FLAG_H263P_SLICE_STRUCT |
-			CODEC_FLAG2_STRICT_GOP |
 			CODEC_FLAG2_LOCAL_HEADER;
-
+		av_dict_set(&opts, "strict_gop", "1", 0);
+		av_dict_set(&opts, "structured_slices", "1", 0);
 		d->avctx->flags |= CODEC_FLAG_TRUNCATED;
 		break;
 
@@@@ -625,7 +626,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 		/* e->avctx->flags2 |= CODEC_FLAG2_8X8DCT; */
 
 		/* Access Unit Delimiters */
-		e->avctx->flags2 |= CODEC_FLAG2_AUD;
+		av_dict_set(&opts, "aud", "1", 0);
 
 		/* Allow b-frames to be used as reference */
 		/* e->avctx->flags2 |= CODEC_FLAG2_BPYRAMID; */
@@@@ -686,7 +687,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 		goto bail;
 	}
 
-	if (avcodec_open(e->avctx, codec))
+	if (avcodec_open2(e->avctx, codec, &opts))
 	{
 		iaxci_usermsg(IAXC_TEXT_TYPE_ERROR,
 			     "codec_ffmpeg: cannot open encoder %s\n", name);
@@@@ -701,7 +702,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 			     ff_dec_id);
 		goto bail;
 	}
-	if (avcodec_open(d->avctx, codec))
+	if (avcodec_open2(d->avctx, codec, NULL))
 	{
 		iaxci_usermsg(IAXC_TEXT_TYPE_ERROR,
 			     "codec_ffmpeg: cannot open decoder %s\n", name);
@@@@ -728,12 +729,11 @@@@ bail:
 int codec_video_ffmpeg_check_codec(int format)
 {
 	AVCodec *codec;
-	enum CodecID codec_id;
+	enum AVCodecID codec_id;
 
 	/* These functions are idempotent, so it is okay that we
 	 * may call them elsewhere at a different time.
 	 */
-	avcodec_init();
 	avcodec_register_all();
 
 	codec_id = map_iaxc_codec_to_avcodec(format);
@


1.3
log
@Update for newer FFmpeg API.

ok sebastia@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_codec_ffmpeg_c,v 1.2 2012/04/30 09:48:21 sebastia Exp $
d6 1
a6 1
+++ lib/codec_ffmpeg.c	Fri Jan 18 21:21:18 2013
d19 9
d78 18
d106 11
a116 1
@@@@ -581,9 +582,9 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
d121 1
a121 1
 				CODEC_FLAG2_STRICT_GOP |
d123 1
d128 1
a128 1
@@@@ -596,10 +597,9 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
d133 1
a133 1
 			CODEC_FLAG2_STRICT_GOP |
d136 1
d141 1
a141 1
@@@@ -625,7 +625,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
d150 1
a150 1
@@@@ -686,7 +686,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
d159 1
a159 1
@@@@ -701,7 +701,7 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
d168 7
a174 1
@@@@ -733,7 +733,6 @@@@ int codec_video_ffmpeg_check_codec(int format)
@


1.2
log
@Make iaxclient work wiht newer ffmpeg API
tested on i386 and macppc by myself with net/coccinella.
From Brad.

OK ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_codec_ffmpeg_c,v 1.1 2010/06/18 17:32:21 sebastia Exp $
d6 1
a6 1
+++ lib/codec_ffmpeg.c	Sat Apr 28 23:31:52 2012
d53 17
a69 2
@@@@ -523,9 +527,6 @@@@ struct iaxc_video_codec *codec_video_ffmpeg_new(int fo
 	e->avctx->gop_size = framerate * 3;
d72 1
a72 1
-
d75 1
a75 1
 
d78 59
@


1.1
log
@Initial import of iaxclient 2.1beta3

A lightweight cross platform IP telephony client using
the IAX protocol, designed for use with the asterisk
open source PBX.

OK, landry@@ jasper@@
@
text
@d1 9
a9 4
$OpenBSD$
--- lib/codec_ffmpeg.c.orig	Sat Nov 14 14:01:02 2009
+++ lib/codec_ffmpeg.c	Sat Nov 14 14:02:59 2009
@@@@ -25,6 +25,8 @@@@
d11 1
a11 1
 #ifdef WIN32
d13 50
a62 5
+#elif defined(__OpenBSD__) 
+#include "libavcodec/avcodec.h"
 #else
 #include <ffmpeg/avcodec.h>
 #endif
@

