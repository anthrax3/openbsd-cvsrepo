head	1.4;
access;
symbols
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2012.12.07.13.01.05;	author sthen;	state dead;
branches;
next	1.3;

1.3
date	2012.10.24.09.37.21;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2012.03.22.21.31.18;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2011.01.24.08.23.27;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.4
log
@rm appkonference, suggested a while ago by dhill; the built-in conferencing
in recent Asterisk works fine on OpenBSD, whereas appkonference  is somewhat
fragile, not well-maintained upstream, and only works with i386/amd64.
@
text
@$OpenBSD: patch-konference_member_c,v 1.3 2012/10/24 09:37:21 sthen Exp $
--- konference/member.c.orig	Mon Jul  2 13:28:19 2012
+++ konference/member.c	Tue Oct 23 10:01:21 2012
@@@@ -255,10 +255,10 @@@@ static struct ast_frame *get_next_soundframe(ast_conf_
 			ast_mutex_unlock( &member->lock ) ;
 			ast_free(toboot);
 			// if we get here, we've gotten to the end of the queue; reset write format
-			if ( ast_set_write_format( member->chan, member->write_format ) < 0 )
+			if ( ast_set_write_format_by_id( member->chan, member->chan->writeformat.id ) < 0 )
 			{
 				ast_log( LOG_ERROR, "unable to set write format to %d\n",
-				    member->write_format ) ;
+				    member->chan->writeformat.id ) ;
 			}
 			return NULL;
 		} else {
@@@@ -352,14 +352,14 @@@@ int member_exec( struct ast_channel* chan, const char*
 	// setup asterisk read/write formats
 	//
 
-	if ( ast_set_read_format( chan, member->read_format ) < 0 )
+	if ( ast_set_read_format_by_id( chan, member->chan->readformat.id ) < 0 )
 	{
 		ast_log( LOG_ERROR, "unable to set read format to signed linear\n" ) ;
 		delete_member( member ) ;
 		return -1 ;
 	}
 
-	if ( ast_set_write_format( chan, member->write_format ) < 0 ) // AST_FORMAT_SLINEAR, chan->nativeformats
+	if ( ast_set_write_format_by_id( chan, member->chan->writeformat.id ) < 0 ) // AST_FORMAT_SLINEAR, chan->nativeformats
 	{
 		ast_log( LOG_ERROR, "unable to set write format to signed linear\n" ) ;
 		delete_member( member ) ;
@@@@ -496,6 +496,7 @@@@ int member_exec( struct ast_channel* chan, const char*
 
 ast_conf_member* create_member( struct ast_channel *chan, const char* data, char* conf_name )
 {
+	struct ast_format tmp_fmt;
 	ast_conf_member *member;
 #ifdef	CACHE_CONTROL_BLOCKS
 #ifdef	SPEAKER_SCOREBOARD
@@@@ -756,14 +757,20 @@@@ ast_conf_member* create_member( struct ast_channel *ch
 	// ( chan->nativeformats, AST_FORMAT_SLINEAR, AST_FORMAT_ULAW, AST_FORMAT_GSM )
 #if	SILDET == 1 || SILDET == 2
 #ifndef	AC_USE_G722
-	member->read_format = !member->dsp ? chan->nativeformats : AST_FORMAT_SLINEAR ;
+	if (!member->dsp)
+		ast_set_read_format_from_cap(chan, chan->nativeformats);
+	else
+		ast_set_read_format_by_id(chan, AST_FORMAT_SLINEAR);
 #else
-	member->read_format = !member->dsp ? chan->nativeformats : AST_FORMAT_SLINEAR16 ;
+	if (!member->dsp)
+		ast_set_read_format_from_cap(chan, chan->nativeformats);
+	else
+		ast_set_read_format_by_id(chan, AST_FORMAT_SLINEAR16);
 #endif
 #else
-	member->read_format = chan->nativeformats ;
+	ast_set_read_format_from_cap(chan, chan->nativeformats);
 #endif
-	member->write_format = chan->nativeformats;
+	ast_set_write_format_from_cap(chan, chan->nativeformats);
 	// 1.2 or 1.3+
 #ifdef AST_FORMAT_AUDIO_MASK
 
@@@@ -773,15 +780,23 @@@@ ast_conf_member* create_member( struct ast_channel *ch
 
 	//translation paths ( ast_translator_build_path() returns null if formats match )
 #ifndef	AC_USE_G722
-	member->to_slinear = ast_translator_build_path( AST_FORMAT_SLINEAR, member->read_format ) ;
-	member->from_slinear = ast_translator_build_path( member->write_format, AST_FORMAT_SLINEAR ) ;
+	member->to_slinear = ast_translator_build_path(
+					ast_format_set(&tmp_fmt, AST_FORMAT_SLINEAR, 0),
+					&member->chan->rawreadformat );
+	member->from_slinear = ast_translator_build_path(
+					&member->chan->rawwriteformat,
+					ast_format_set(&tmp_fmt, AST_FORMAT_SLINEAR, 0) ) ;
 #else
-	member->to_slinear = ast_translator_build_path( AST_FORMAT_SLINEAR16, member->read_format ) ;
-	member->from_slinear = ast_translator_build_path( member->write_format, AST_FORMAT_SLINEAR16 ) ;
+	member->to_slinear = ast_translator_build_path(
+					ast_format_set(&tmp_fmt, AST_FORMAT_SLINEAR16, 0),
+					&member->chan->rawreadformat ) ;
+	member->from_slinear = ast_translator_build_path(
+					&member->chan->rawwriteformat,
+					ast_format_set(&tmp_fmt, AST_FORMAT_SLINEAR16, 0) ) ;
 #endif
 
 	// index for converted_frames array
-	switch ( member->write_format )
+	switch ( member->chan->rawwriteformat.id )
 	{
 #ifndef	AC_USE_G722
 		case AST_FORMAT_SLINEAR:
@@@@ -822,7 +837,7 @@@@ ast_conf_member* create_member( struct ast_channel *ch
 	}
 
 	// index for converted_frames array
-	switch ( member->read_format )
+	switch ( member->chan->rawreadformat.id )
 	{
 #ifndef	AC_USE_G722
 		case AST_FORMAT_SLINEAR:
@@@@ -1212,6 +1227,8 @@@@ void queue_silent_frame(
 	ast_conf_member* member
 )
 {
+	struct ast_format tmp_fmt;
+
 	// get the appropriate silent frame
 	struct ast_frame* qf = silent_conf_frame->converted[ member->write_format_index ] ;
 
@@@@ -1223,9 +1240,13 @@@@ void queue_silent_frame(
 		// can't be used simultaneously for multiple audio streams
 		//
 #ifndef AC_USE_G722
-		struct ast_trans_pvt* trans = ast_translator_build_path( member->write_format, AST_FORMAT_SLINEAR ) ;
+		struct ast_trans_pvt* trans = ast_translator_build_path(
+						&member->chan->rawwriteformat,
+						ast_format_set(&tmp_fmt, AST_FORMAT_SLINEAR, 0) ) ;
 #else
-		struct ast_trans_pvt* trans = ast_translator_build_path( member->write_format, AST_FORMAT_SLINEAR16 ) ;
+		struct ast_trans_pvt* trans = ast_translator_build_path(
+						&member->chan->rawwriteformat,
+						ast_format_set(&tmp_fmt, AST_FORMAT_SLINEAR16, 0) ) ;
 #endif
 		if ( trans )
 		{
@


1.3
log
@Fix appkonference with Asterisk 10.x; from dhill.

Note: this port may be removed in the future; users are recommended to
migrate to ConfBridge, which is part of Asterisk itself and has improved
greatly in the rewrite for Asterisk 10.x.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@update to appkonference 2.1, from dhill with tweaks by me
@
text
@d1 44
a44 31
$OpenBSD: patch-konference_member_c,v 1.1 2011/01/24 08:23:27 sthen Exp $

asterisk 1.8 support; https://gist.github.com/661206

--- konference/member.c.orig	Tue Aug 17 19:16:35 2010
+++ konference/member.c	Sat Jan 22 20:19:21 2011
@@@@ -49,7 +49,7 @@@@ static int process_incoming(struct ast_conf_member *me
 		if (member->dtmf_switch)
 		{
 			ast_mutex_lock( &member->lock ) ;
-			switch (f->subclass) {
+			switch (f->subclass.integer) {
 			case '0' :member->req_id=0;
 				break;
 			case '1' :member->req_id=1;
@@@@ -107,9 +107,9 @@@@ static int process_incoming(struct ast_conf_member *me
 				member->type,
 				member->chan->uniqueid,
 				member->chan->name,
-				member->chan->cid.cid_num ? member->chan->cid.cid_num : "unknown",
-				member->chan->cid.cid_name ? member->chan->cid.cid_name : "unknown",
-				f->subclass,
+				member->chan->caller.id.number.str ? member->chan->caller.id.number.str : "unknown",
+				member->chan->caller.id.name.str ? member->chan->caller.id.name.str : "unknown",
+				f->subclass.integer,
 				conf->membercount,
 				member->flags,
 				member->mute_audio
@@@@ -207,9 +207,9 @@@@ static int process_incoming(struct ast_conf_member *me
 		if (
 			member->dsp != NULL
d46 5
a50 2
-			&& f->subclass == AST_FORMAT_SLINEAR
+			&& f->subclass.integer == AST_FORMAT_SLINEAR
d52 5
a56 2
-			&& f->subclass == AST_FORMAT_SLINEAR16
+			&& f->subclass.integer == AST_FORMAT_SLINEAR16
d58 3
a60 27
 			&& f->datalen == AST_CONF_FRAME_DATA_SIZE
 			)
@@@@ -233,9 +233,11 @@@@ static int process_incoming(struct ast_conf_member *me
 						manager_event(
 							EVENT_FLAG_CALL,
 							"ConferenceState",
+							"ConferenceName: %s\r\n"
 							"Channel: %s\r\n"
 							"Flags: %s\r\n"
 							"State: %s\r\n",
+							conf->name,
 							member->chan->name,
 							member->flags,
 							"silent"
@@@@ -254,9 +256,11 @@@@ static int process_incoming(struct ast_conf_member *me
 					manager_event(
 						EVENT_FLAG_CALL,
 						"ConferenceState",
+						"ConferenceName: %s\r\n"
 						"Channel: %s\r\n"
 						"Flags: %s\r\n"
 						"State: %s\r\n",
+						conf->name,
 						member->chan->name,
 						member->flags,
 						"speaking"
@@@@ -288,7 +292,7 @@@@ static int process_incoming(struct ast_conf_member *me
d62 31
a92 5
 	else if (
 		f->frametype == AST_FRAME_CONTROL
-		&& f->subclass == AST_CONTROL_HANGUP
+		&& f->subclass.integer == AST_CONTROL_HANGUP
 		)
d94 3
a96 42
 		// hangup received
@@@@ -303,7 +307,7 @@@@ static int process_incoming(struct ast_conf_member *me
 #ifdef	VIDEO
 	else if (
 		f->frametype == AST_FRAME_CONTROL
-		&& f->subclass == AST_CONTROL_VIDUPDATE
+		&& f->subclass.integer == AST_CONTROL_VIDUPDATE
 		)
 	{
 		// say we have switched to cause a FIR to
@@@@ -761,8 +765,8 @@@@ int member_exec( struct ast_channel* chan, void* data 
 		member->id,
 		member->flags,
 		member->chan->name,
-		member->chan->cid.cid_num ? member->chan->cid.cid_num : "unknown",
-		member->chan->cid.cid_name ? member->chan->cid.cid_name: "unknown",
+		member->chan->caller.id.number.str ? member->chan->caller.id.number.str : "unknown",
+		member->chan->caller.id.name.str ? member->chan->caller.id.name.str: "unknown",
 		conf->stats.moderators,
 		conf->membercount
 	) ;
@@@@ -2129,7 +2133,7 @@@@ DEBUG("SMOOTH:Feeding frame into inSmoother, timestamp
 		while( ( sfr = ast_smoother_read( member->inSmoother ) ) ){
 
 			++i;
-DEBUG("\treading new frame [%d] from smoother, inFramesCount[%d], \n\tsfr->frametype -> %d , sfr->subclass -> %d , sfr->datalen => %d sfr->samples => %d\n", i , member->inFramesCount , sfr->frametype, sfr->subclass, sfr->datalen, sfr->samples) ;
+DEBUG("\treading new frame [%d] from smoother, inFramesCount[%d], \n\tsfr->frametype -> %d , sfr->subclass.integer -> %d , sfr->datalen => %d sfr->samples => %d\n", i , member->inFramesCount , sfr->frametype, sfr->subclass.integer, sfr->datalen, sfr->samples) ;
 DEBUG("SMOOTH:Reading frame from inSmoother, i=>%d, timestamp => %ld.%ld\n",i, sfr->delivery.tv_sec, sfr->delivery.tv_usec);
 			conf_frame* cfr = create_conf_frame( member, member->inFrames, sfr ) ;
 			if ( cfr == NULL )
@@@@ -2763,10 +2767,10 @@@@ int ast_packer_feed(struct ast_packer *s, const struct
 		return -1;
 	}
 	if (!s->format) {
-		s->format = f->subclass;
+		s->format = f->subclass.integer;
 		s->samples=0;
-	} else if (s->format != f->subclass) {
-		ast_log(LOG_WARNING, "Packer was working on %d format frames, now trying to feed %d?\n", s->format, f->subclass);
+	} else if (s->format != f->subclass.integer) {
+		ast_log(LOG_WARNING, "Packer was working on %d format frames, now trying to feed %d?\n", s->format, f->subclass.integer);
 		return -1;
a97 13
 	if (s->len + f->datalen > PACKER_SIZE) {
@@@@ -2815,7 +2819,7 @@@@ struct ast_frame *ast_packer_read(struct ast_packer *s
 		len = s->len;
 	/* Make frame */
 	s->f.frametype = AST_FRAME_VOICE;
-	s->f.subclass = s->format;
+	s->f.subclass.integer = s->format;
 	SETDATA2PTR(s->f.data, s->framedata + AST_FRIENDLY_OFFSET);
 	s->f.offset = AST_FRIENDLY_OFFSET;
 	s->f.datalen = len;
@@@@ -3029,7 +3033,7 @@@@ int queue_frame_for_speaker(
 		// short-cut pointer to the ast_frame
 		qf = frame->fr ;
d99 9
a107 6
-		if ( (qf->subclass == member->write_format) && (member->listen_volume == 0) )
+		if ( (qf->subclass.integer == member->write_format) && (member->listen_volume == 0) )
 		{
 			// frame is already in correct format, so just queue it
 
@@@@ -3377,8 +3381,11 @@@@ int is_video_eligible(struct ast_conf_member *member)
d109 4
a112 9
 	if ( member == NULL )
 		return 0;
-	
+#if ( SILDET == 2 )
 	return !member->no_camera && !member->mute_video && !member->via_telephone;
+#else
+	return !member->no_camera && !member->mute_video;
+#endif
 }
d114 16
a129 1
 // Member start and stop video methods
@


1.1
log
@update and patch appkonference to work with asterisk 1.8.
spotted by and diff ok with naddy@@
@
text
@d1 1
a1 1
$OpenBSD$
@

