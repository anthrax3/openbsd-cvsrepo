head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.16
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.14
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.10
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.12
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.8
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.42
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.40
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.38
	OPENBSD_5_0:1.2.0.36
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.34
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.32
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.30
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.28
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.26
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.24
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.22
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.20
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.18
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.16
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.14
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.12
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.10
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.8
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.6
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.1.0.4
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.2
	OPENBSD_3_1_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2013.06.01.17.59.55;	author naddy;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.21.05.41.14;	author pvalchev;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.12.19.59.55;	author fgsch;	state Exp;
branches;
next	;


desc
@@


1.3
log
@openpty(3) transparently does everything required, so remove ancient
cruft from pty handling and drop setuid root.  ok yuo@@
@
text
@$OpenBSD: patch-main_c,v 1.2 2002/11/21 05:41:14 pvalchev Exp $
--- main.c.orig	Fri May 31 22:15:05 2013
+++ main.c	Fri May 31 22:25:10 2013
@@@@ -142,9 +142,16 @@@@ static Bool IsPts = False;
 #define WTMP
 #endif
 
+#ifdef CSRG_BASED
+#define USE_POSIX_TERMIOS
+#endif
+
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 
+#ifdef USE_POSIX_TERMIOS
+#include <termios.h>
+#else
 #ifdef USE_TERMIOS
 #include <termios.h>
 /* this hacked termios support only works on SYSV */
@@@@ -159,10 +166,12 @@@@ static Bool IsPts = False;
 #include <sys/termio.h>
 #endif /* SYSV */
 #endif /* USE_TERMIOS else */
+#endif /* USE_POSIX_TERMIOS */
 
 #ifdef SVR4
 #undef TIOCSLTC				/* defined, but not useable */
 #endif
+#define USE_TERMCAP_ENVVARS	/* every one uses this except SYSV maybe */
 
 #if defined(__sgi) && OSMAJORVERSION >= 5
 #undef TIOCLSET				/* defined, but not useable */
@@@@ -225,7 +234,9 @@@@ static Bool IsPts = False;
 #endif
 #else /* } !SYSV { */			/* BSD systems */
 #ifndef linux
+#ifndef USE_POSIX_TERMIOS
 #include <sgtty.h>
+#endif /* USE_POSIX_TERMIOS */
 #endif
 #include <sys/resource.h>
 #define HAS_UTMP_UT_HOST
@@@@ -251,6 +262,8 @@@@ static Bool IsPts = False;
 
 #if (BSD >= 199103)
 #define USE_POSIX_WAIT
+#define LASTLOG
+#define WTMP
 #define HAS_POSIX_SAVED_IDS
 #endif
 
@@@@ -301,6 +314,10 @@@@ extern struct utmp *getutid __((struct utmp *_Id));
 int	Ptyfd;
 #endif /* PUCC_PTYD */
 
+#ifdef __OpenBSD__
+#include <util.h>
+#endif
+
 #ifdef sequent
 #define USE_GET_PSEUDOTTY
 #endif
@@@@ -407,6 +424,10 @@@@ static Bool added_utmp_entry = False;
 
 static Bool xterm_exiting = False;
 
+#ifdef __OpenBSD__
+static gid_t utmpGid = -1;
+#endif
+
 /*
 ** Ordinarily it should be okay to omit the assignment in the following
 ** statement. Apparently the c89 compiler on AIX 4.1.3 has a bug, or does
@@@@ -434,6 +455,9 @@@@ static struct ltchars d_ltc;
 static unsigned int d_lmode;
 #endif	/* TIOCLSET */
 #else /* not USE_SYSV_TERMIO */
+#ifdef USE_POSIX_TERMIOS
+static struct termios d_tio;
+#else /* not USE_POSIX_TERMIOS */
 static struct  sgttyb d_sg = {
         0, 0, 0177, CKILL, EVENP|ODDP|ECHO|XTABS|CRMOD
 };
@@@@ -457,6 +481,7 @@@@ static struct jtchars d_jtc = {
 	'J', 'B'
 };
 #endif /* sony */
+#endif /* USE_POSIX_TERMIOS */
 #endif /* USE_SYSV_TERMIO */
 
 /* allow use of system default characters if defined and reasonable */
@@@@ -1107,21 +1132,19 @@@@ char **argv;
 	char *base_name();
 	int xerror(), xioerror();
 
-	XtSetLanguageProc (NULL, NULL, NULL);
-
 	ProgramName = argv[0];
 
 	/* +2 in case longer tty name like /dev/ttyq255 */
-	ttydev = (char *) malloc (sizeof(TTYDEV) + 2);
+	ttydev = (char *) malloc (sizeof(TTYDEV) + 80);
 #ifndef __osf__
-	ptydev = (char *) malloc (sizeof(PTYDEV) + 2);
+	ptydev = (char *) malloc (sizeof(PTYDEV) + 80);
 	if (!ttydev || !ptydev)
 #else
 	if (!ttydev)
 #endif
 	{
 	    fprintf (stderr, 
-	    	     "%s:  unable to allocate memory for ttydev or ptydev\n",
+	    	     "%s: unable to allocate memory for ttydev or ptydev\n",
 		     ProgramName);
 	    exit (1);
 	}
@@@@ -1130,14 +1153,20 @@@@ char **argv;
 	strcpy (ptydev, PTYDEV);
 #endif
 
-#ifdef USE_SYSV_TERMIO /* { */
+	XtSetLanguageProc (NULL, NULL, NULL);
+
+#if defined(USE_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS) /* { */
 	/* Initialization is done here rather than above in order
 	** to prevent any assumptions about the order of the contents
 	** of the various terminal structures (which may change from
 	** implementation to implementation).
 	*/
 	d_tio.c_iflag = ICRNL|IXON;
+#ifdef TAB3
 	d_tio.c_oflag = OPOST|ONLCR|TAB3;
+#else
+	d_tio.c_oflag = OPOST|ONLCR;
+#endif
 #if defined(macII) || defined(ATT) || defined(CRAY) /* { */
     	d_tio.c_cflag = B9600|CS8|CREAD|PARENB|HUPCL;
     	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
@@@@ -1161,9 +1190,11 @@@@ char **argv;
 	d_tio.c_cc[VEOL2] = CNUL;
 	d_tio.c_cc[VSWTCH] = CNUL;
 
-#ifdef USE_TERMIOS /* { */
+#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS) /* { */
 	d_tio.c_cc[VSUSP] = CSUSP;
+#ifdef VDSUSP
 	d_tio.c_cc[VDSUSP] = CDSUSP;
+#endif
 	d_tio.c_cc[VREPRINT] = CRPRNT;
 	d_tio.c_cc[VDISCARD] = CFLUSH;
 	d_tio.c_cc[VWERASE] = CWERASE;
@@@@ -1181,11 +1212,17 @@@@ char **argv;
 	d_lmode = 0;
 #endif /* } TIOCLSET */
 #else  /* }{ else !macII, ATT, CRAY */
+#ifndef USE_POSIX_TERMIOS
 #ifdef BAUD_0 /* { */
     	d_tio.c_cflag = CS8|CREAD|PARENB|HUPCL;
 #else	/* }{ !BAUD_0 */
     	d_tio.c_cflag = B9600|CS8|CREAD|PARENB|HUPCL;
 #endif	/* } !BAUD_0 */
+#else /* USE_POSIX_TERMIOS */
+	d_tio.c_cflag = CS8|CREAD|PARENB|HUPCL;
+	cfsetispeed(&d_tio, B9600);
+	cfsetospeed(&d_tio, B9600);
+#endif
     	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
 #ifdef ECHOKE
 	d_tio.c_lflag |= ECHOKE|IEXTEN;
@@@@ -1193,11 +1230,13 @@@@ char **argv;
 #ifdef ECHOCTL
 	d_tio.c_lflag |= ECHOCTL|IEXTEN;
 #endif
+#ifndef USE_POSIX_TERMIOS
 #ifdef NTTYDISC
         d_tio.c_line = NTTYDISC;
 #else
 	d_tio.c_line = 0;
 #endif	
+#endif /* USE_POSIX_TERMIOS */
 #ifdef __sgi
         d_tio.c_cflag &= ~(HUPCL|PARENB);
         d_tio.c_iflag |= BRKINT|ISTRIP|IGNPAR;
@@@@ -1246,8 +1285,14 @@@@ char **argv;
 	    int i;
 
 	    for (i = 0; i <= 2; i++) {
+#ifndef USE_POSIX_TERMIOS
 		struct termio deftio;
-		if (ioctl (i, TCGETA, &deftio) == 0) {
+		if (ioctl (i, TCGETA, &deftio) == 0)
+#else
+		struct termios deftio;
+		if (tcgetattr(i, &deftio) == 0)
+#endif
+		{
 		    d_tio.c_cc[VINTR] = deftio.c_cc[VINTR];
 		    d_tio.c_cc[VQUIT] = deftio.c_cc[VQUIT];
 		    d_tio.c_cc[VERASE] = deftio.c_cc[VERASE];
@@@@ -1302,9 +1347,11 @@@@ char **argv;
         d_ltc.t_werasc = '\377';
         d_ltc.t_lnextc = '\377';
 #endif	/* } TIOCSLTC */
-#ifdef USE_TERMIOS /* { */
+#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS) /* { */
 	d_tio.c_cc[VSUSP] = CSUSP;
+#ifdef VDSUSP
 	d_tio.c_cc[VDSUSP] = '\000';
+#endif
 	d_tio.c_cc[VREPRINT] = '\377';
 	d_tio.c_cc[VDISCARD] = '\377';
 	d_tio.c_cc[VWERASE] = '\377';
@@@@ -1361,7 +1408,15 @@@@ char **argv;
 		(void) fprintf(stderr, "setegid(%d): %s\n",
 			       (int) egid, strerror(errno));
 #endif
+
+#ifdef __OpenBSD__
+	if (resource.utmpInhibit) {
+		/* Can totally revoke group privs */
+		setegid(getgid());
+		setgid(getgid());
 	}
+#endif
+	}
 
 	waiting_for_initial_map = resource.wait_for_map;
 
@@@@ -1719,7 +1774,7 @@@@ char *name;
 get_pty (pty)
     int *pty;
 {
-#ifdef __osf__
+#if defined(__osf__) || defined(__OpenBSD__)
     int tty;
     return (openpty(pty, &tty, ttydev, NULL, NULL));
 #endif
@@@@ -2065,6 +2120,9 @@@@ spawn ()
 	int zero = 0;
 	int status;
 #else	/* else not USE_SYSV_TERMIO */
+#ifdef USE_POSIX_TERMIOS
+	struct termios tio;
+#else /* else not USE_POSIX_TERMIOS */
 	unsigned lmode;
 	struct tchars tc;
 	struct ltchars ltc;
@@@@ -2073,6 +2131,7 @@@@ spawn ()
 	int jmode;
 	struct jtchars jtc;
 #endif /* sony */
+#endif  /* USE_POSIX_TERMIOS */
 #endif	/* USE_SYSV_TERMIO */
 
 	char termcap [1024];
@@@@ -2168,9 +2227,9 @@@@ spawn ()
 #ifdef TIOCLSET
 				lmode = d_lmode;
 #endif	/* TIOCLSET */
-#ifdef USE_SYSV_TERMIO
+#if defined(USE_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS)
 				tio = d_tio;
-#else	/* not USE_SYSV_TERMIO */
+#else	/* not USE_SYSV_TERMIO and not USE_POSIX_TERMIOS */
 				sg = d_sg;
 				tc = d_tc;
 				discipline = d_disipline;
@@@@ -2178,7 +2237,7 @@@@ spawn ()
 				jmode = d_jmode;
 				jtc = d_jtc;
 #endif /* sony */
-#endif	/* USE_SYSV_TERMIO */
+#endif	/* USE_SYSV_TERMIO or USE_POSIX_TERMIOS */
 			} else {
 			    SysError(ERROR_OPDEVTTY);
 			}
@@@@ -2202,6 +2261,10 @@@@ spawn ()
 			        tio = d_tio;
 
 #else	/* not USE_SYSV_TERMIO */
+#ifdef USE_POSIX_TERMIOS
+			if (tcgetattr(tty, &tio) == -1) 
+			        tio = d_tio;
+#else   /* not USE_POSIX_TERMIOS */
 			if(ioctl(tty, TIOCGETP, (char *)&sg) == -1)
 			        sg = d_sg;
 			if(ioctl(tty, TIOCGETC, (char *)&tc) == -1)
@@@@ -2214,6 +2277,7 @@@@ spawn ()
 			if(ioctl(tty, TIOCKGETC, (char *)&jtc) == -1)
 				jtc = d_jtc;
 #endif /* sony */
+#endif  /* USE_POSIX_TERMIOS */
 #endif	/* USE_SYSV_TERMIO */
 			close (tty);
 			/* tty is no longer an open fd! */
@@@@ -2507,6 +2571,7 @@@@ spawn ()
 				break;
 #endif	/* USE_SYSV_PGRP */
 			}
+			perror("open ttydev");
 
 #ifdef TIOCSCTTY
 			ioctl(tty, TIOCSCTTY, 0);
@@@@ -2581,7 +2646,7 @@@@ spawn ()
 		 * set up the tty modes
 		 */
 		{
-#ifdef USE_SYSV_TERMIO
+#if defined(USE_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS)
 #if defined(umips) || defined(CRAY) || defined(linux)
 		    /* If the control tty had its modes screwed around with,
 		       eg. by lineedit in the shell, or emacs, etc. then tio
@@@@ -2598,12 +2663,15 @@@@ spawn ()
 		    tio.c_iflag &= ~(INLCR|IGNCR);
 		    tio.c_iflag |= ICRNL;
 		    /* ouput: cr->cr, nl is not return, no delays, ln->cr/nl */
+#ifndef USE_POSIX_TERMIOS
 		    tio.c_oflag &=
 		     ~(OCRNL|ONLRET|NLDLY|CRDLY|TABDLY|BSDLY|VTDLY|FFDLY);
+#endif /* USE_POSIX_TERMIOS */
 		    tio.c_oflag |= ONLCR;
 #ifdef OPOST
 		    tio.c_oflag |= OPOST;
 #endif /* OPOST */		    
+#ifndef USE_POSIX_TERMIOS
 #ifdef BAUD_0
 		    /* baud rate is 0 (don't care) */
 		    tio.c_cflag &= ~(CBAUD);
@@@@ -2612,6 +2680,13 @@@@ spawn ()
 		    tio.c_cflag &= ~(CBAUD);
 		    tio.c_cflag |= B9600;
 #endif	/* !BAUD_0 */
+#else /* USE_POSIX_TERMIOS */
+		    cfsetispeed(&tio, B9600);
+		    cfsetospeed(&tio, B9600);
+		    /* Clear CLOCAL so that SIGHUP is sent to us 
+		       when the xterm ends */
+		    tio.c_cflag &= ~CLOCAL;
+#endif /* USE_POSIX_TERMIOS */
 		    tio.c_cflag &= ~CSIZE;
 		    if (screen->input_eight_bits)
 			tio.c_cflag |= CS8;
@@@@ -2723,9 +2798,14 @@@@ spawn ()
 		    if (ioctl (tty, TIOCLSET, (char *)&lmode) == -1)
 			    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
 #endif	/* TIOCLSET */
+#ifndef USE_POSIX_TERMIOS
 		    if (ioctl (tty, TCSETA, &tio) == -1)
 			    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
-#else	/* USE_SYSV_TERMIO */
+#else   /* USE_POSIX_TERMIOS */
+		    if (tcsetattr (tty, TCSANOW, &tio) == -1)
+			    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
+#endif  /* USE_POSIX_TERMIOS */
+#else	/* USE_SYSV_TERMIO or USE_POSIX_TERMIOS */
 #ifdef KTERM
 		    sg.sg_flags &= ~(ALLDELAY | XTABS | CBREAK | RAW
 						| EVENP | ODDP);
@@@@ -3100,6 +3180,14 @@@@ spawn ()
 				    close(i);
 				}
 #endif /* LASTLOG */
+
+#ifdef __OpenBSD__
+				/* Switch to real gid after writing utmp entry */
+				if (getgid() != getegid()) {
+					utmpGid = getegid();
+					setegid(getgid());
+				}
+#endif
 			} else
 				tslot = -tslot;
 		}
@@@@ -3272,11 +3360,11 @@@@ spawn ()
 		shname_minus = malloc(strlen(shname) + 2);
 		(void) strcpy(shname_minus, "-");
 		(void) strcat(shname_minus, shname);
-#ifndef USE_SYSV_TERMIO
+#if !defined(USE_SYSV_TERMIO) && !defined(USE_POSIX_TERMIOS)
 		ldisc = XStrCmp("csh", shname + strlen(shname) - 3) == 0 ?
 		 NTTYDISC : 0;
 		ioctl(0, TIOCSETD, (char *)&ldisc);
-#endif	/* !USE_SYSV_TERMIO */
+#endif	/* !USE_SYSV_TERMIO && !USE_POSIX_TERMIOS */
 
 #ifdef USE_LOGIN_DASH_P
 		if (term->misc.login_shell && pw && added_utmp_entry)
@@@@ -3459,6 +3547,12 @@@@ Exit(n)
 	    && added_utmp_entry
 #endif /* USE_HANDSHAKE */
 	    ) {
+#ifdef __OpenBSD__
+		if (utmpGid != -1) {
+			/* Switch back to group utmp */
+			setegid(utmpGid);
+		}
+#endif
 	    ptyname = ttydev;
 	    utmp.ut_type = USER_PROCESS;
 	    if (PTYCHARLEN >= (int)strlen(ptyname))
@


1.2
log
@Treat this much like XF4 xterm got treated based on the work on Matthieu
and Theo:
- Revoke root privileges early (root needed for pty allocation)
- Make it setgid utmp in order to update utmp with root privileges
revoked.  utmp also revoked if not needed (-u used for ex)
@
text
@d1 3
a3 3
$OpenBSD: patch-main_c,v 1.1 2002/03/12 19:59:55 fgsch Exp $
--- main.c.orig	Wed Nov 20 00:27:51 2002
+++ main.c	Wed Nov 20 01:02:33 2002
d44 1
a44 12
@@@@ -236,6 +247,10 @@@@ static Bool IsPts = False;
 #endif
 #endif	/* } !SYSV */
 
+#ifdef USE_TTY_GROUP
+#include <grp.h>
+#endif
+
 #ifdef _POSIX_SOURCE
 #define USE_POSIX_WAIT
 #define HAS_POSIX_SAVED_IDS
@@@@ -251,6 +266,8 @@@@ static Bool IsPts = False;
d53 1
a53 1
@@@@ -301,6 +318,10 @@@@ extern struct utmp *getutid __((struct u
d64 1
a64 12
@@@@ -362,6 +383,10 @@@@ int	Ptyfd;
 #define SIGNAL_RETURN return
 #endif
 
+#ifndef TTY_GROUP_NAME
+#define TTY_GROUP_NAME "tty"
+#endif
+
 SIGNAL_T Exit();
 
 #ifndef X_NOT_POSIX
@@@@ -407,6 +432,10 @@@@ static Bool added_utmp_entry = False;
d75 1
a75 11
@@@@ -416,6 +445,9 @@@@ static Bool xterm_exiting = False;
 */
 static char **command_to_exec = NULL;
 
+static int get_pty (int *pty);
+static void set_owner (char *device, int uid, int gid, int mode);
+
 #ifdef USE_SYSV_TERMIO
 /* The following structures are initialized in main() in order
 ** to eliminate any assumptions about the internal order of their
@@@@ -434,6 +466,9 @@@@ static struct ltchars d_ltc;
d85 1
a85 1
@@@@ -457,6 +492,7 @@@@ static struct jtchars d_jtc = {
d93 1
a93 1
@@@@ -1107,37 +1143,47 @@@@ char **argv;
d112 1
a112 1
-	    fprintf (stderr, 
d114 3
a116 6
-		     ProgramName);
-	    exit (1);
+		fprintf(stderr,
+			"%s: unable to allocate memory for ttydev or ptydev\n",
+			ProgramName);
+		exit (1);
d118 1
a118 2
 	strcpy (ttydev, TTYDEV);
 #ifndef __osf__
a122 6
+#ifdef __OpenBSD__
+	get_pty(NULL);
+	seteuid(getuid());
+	setuid(getuid());
+#endif /* __OpenBSD__ */
+
d140 1
a140 1
@@@@ -1161,9 +1207,11 @@@@ char **argv;
d153 1
a153 1
@@@@ -1181,11 +1229,17 @@@@ char **argv;
d171 1
a171 1
@@@@ -1193,11 +1247,13 @@@@ char **argv;
d185 1
a185 1
@@@@ -1246,8 +1302,14 @@@@ char **argv;
d201 1
a201 1
@@@@ -1302,9 +1364,11 @@@@ char **argv;
d214 1
a214 1
@@@@ -1361,6 +1425,14 @@@@ char **argv;
d224 2
a226 2
+#endif
 	}
d229 2
a230 1
@@@@ -1719,6 +1791,32 @@@@ char *name;
d234 2
a235 27
+#ifdef __OpenBSD__
+	int result;
+	static int m_tty = -1;
+	static int m_pty = -1;
+	struct group *ttygrp;
+
+	if (pty == NULL) {
+		result = openpty(&m_pty, &m_tty, ttydev, NULL, NULL);
+
+		seteuid(0);
+		if ((ttygrp = getgrnam(TTY_GROUP_NAME)) != 0) {
+			set_owner(ttydev, getuid(), ttygrp->gr_gid,
+			    0600);
+		} else {
+			set_owner(ttydev, getuid(), getgid(),
+			    0600);
+		}
+		seteuid(getuid());
+		return result;
+	} else if (m_pty != -1) {
+		*pty = m_pty;
+		return (0);
+	} else {
+		return (-1);
+	}
+#endif /* __OpenBSD__ */
 #ifdef __osf__
d238 2
a239 20
@@@@ -2034,6 +2132,18 @@@@ void first_map_occurred ()
 }
 #endif /* USE_HANDSHAKE else !USE_HANDSHAKE */
 
+static void
+set_owner(char *device, int uid, int gid, int mode)
+{
+	if (chown (device, uid, gid) < 0) {
+		if (errno != ENOENT
+		    && getuid() == 0) {
+			fprintf(stderr, "Cannot chown %s to %d,%d: %s\n",
+			    device, uid, gid, strerror(errno));
+		}
+	}
+	chmod (device, mode);
+}
 
 spawn ()
 /* 
@@@@ -2065,6 +2175,9 @@@@ spawn ()
d249 1
a249 1
@@@@ -2073,6 +2186,7 @@@@ spawn ()
d257 1
a257 1
@@@@ -2168,9 +2282,9 @@@@ spawn ()
d269 1
a269 1
@@@@ -2178,7 +2292,7 @@@@ spawn ()
d278 1
a278 1
@@@@ -2202,6 +2316,10 @@@@ spawn ()
d289 1
a289 1
@@@@ -2214,6 +2332,7 @@@@ spawn ()
d297 1
a297 1
@@@@ -2507,6 +2626,7 @@@@ spawn ()
d305 1
a305 9
@@@@ -2555,7 +2675,6 @@@@ spawn ()
 
 #ifdef USE_TTY_GROUP
 	{ 
-#include <grp.h>
 		struct group *ttygrp;
 		if (ttygrp = getgrnam("tty")) {
 			/* change ownership of tty to real uid, "tty" gid */
@@@@ -2581,7 +2700,7 @@@@ spawn ()
d314 1
a314 1
@@@@ -2598,12 +2717,15 @@@@ spawn ()
d330 1
a330 1
@@@@ -2612,6 +2734,13 @@@@ spawn ()
d344 1
a344 1
@@@@ -2723,9 +2852,14 @@@@ spawn ()
d360 1
a360 1
@@@@ -3100,6 +3234,15 @@@@ spawn ()
a366 1
+				utmpGid = getegid();
d375 1
a375 1
@@@@ -3272,11 +3415,11 @@@@ spawn ()
d389 1
a389 1
@@@@ -3459,6 +3602,12 @@@@ Exit(n)
@


1.1
log
@o indent.
o switch to distinfo.
o regen patches
@
text
@d1 3
a3 3
$OpenBSD$
--- main.c.orig	Tue Mar 12 16:14:07 2002
+++ main.c	Tue Mar 12 16:14:08 2002
d44 12
a55 1
@@@@ -251,6 +262,8 @@@@ static Bool IsPts = False;
d64 44
a107 1
@@@@ -434,6 +447,9 @@@@ static struct ltchars d_ltc;
d117 1
a117 1
@@@@ -457,6 +473,7 @@@@ static struct jtchars d_jtc = {
d125 30
a154 1
@@@@ -1130,14 +1147,18 @@@@ char **argv;
d159 8
d182 1
a182 1
@@@@ -1161,9 +1182,11 @@@@ char **argv;
d195 1
a195 1
@@@@ -1181,11 +1204,17 @@@@ char **argv;
d213 1
a213 1
@@@@ -1193,11 +1222,13 @@@@ char **argv;
d227 1
a227 1
@@@@ -1246,8 +1277,14 @@@@ char **argv;
d243 1
a243 1
@@@@ -1302,9 +1339,11 @@@@ char **argv;
d256 68
a323 1
@@@@ -2065,6 +2104,9 @@@@ spawn ()
d333 1
a333 1
@@@@ -2073,6 +2115,7 @@@@ spawn ()
d341 1
a341 1
@@@@ -2168,9 +2211,9 @@@@ spawn ()
d353 1
a353 1
@@@@ -2178,7 +2221,7 @@@@ spawn ()
d362 1
a362 1
@@@@ -2202,6 +2245,10 @@@@ spawn ()
d373 1
a373 1
@@@@ -2214,6 +2261,7 @@@@ spawn ()
d381 17
a397 1
@@@@ -2581,7 +2629,7 @@@@ spawn ()
d406 1
a406 1
@@@@ -2598,12 +2646,15 @@@@ spawn ()
d422 1
a422 1
@@@@ -2612,6 +2663,13 @@@@ spawn ()
d436 1
a436 1
@@@@ -2723,9 +2781,14 @@@@ spawn ()
d452 17
a468 1
@@@@ -3272,11 +3335,11 @@@@ spawn ()
d482 13
@

