head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.18
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.16
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.14
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.10
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.12
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.8
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.6
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.4
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	zhuk_20130422:1.1.1.1
	zhuk:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2013.04.22.17.32.31;	author zhuk;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.04.22.17.32.31;	author zhuk;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$
Fixup formatting errors, mostly annoying warnings on i386 but dunno about
64-bit archs.
--- libsrc/Wi/srvstat.c.orig	Tue Jan 29 21:48:45 2013
+++ libsrc/Wi/srvstat.c	Tue Jan 29 22:05:12 2013
@@@@ -2514,8 +2514,8 @@@@ col_comp_print (FILE * out, dbe_key_t * key, db_buf_t 
   int off, len;
   if (rv & cl->cl_row_version_mask)
     {
-      unsigned short ref = SHORT_REF (row + cl->cl_pos[rv]);
-      fprintf (out, "[R%d:%d]", (uint32)ref & ROW_NO_MASK, (uint32) ref >> COL_OFFSET_SHIFT);
+      unsigned long ref = SHORT_REF (row + cl->cl_pos[rv]);
+      fprintf (out, "[R%lu:%lu]", ref & ROW_NO_MASK, ref >> COL_OFFSET_SHIFT);
     }
   else if (!dtp_is_fixed (cl->cl_sqt.sqt_dtp))
     {
@@@@ -2533,9 +2533,9 @@@@ col_comp_print (FILE * out, dbe_key_t * key, db_buf_t 
 	}
       if (len & COL_VAR_SUFFIX)
 	{
-	  unsigned short ref = SHORT_REF_NA (row + off);
+	  unsigned long ref = SHORT_REF_NA (row + off);
 	  dtp_t extra = 15 == (ref >> COL_OFFSET_SHIFT) ? row[off + 2] : 0;
-	  fprintf (out, "[P%d:%d]", (uint32)ROW_NO_MASK & ref, extra ? extra : (uint32)ref >> COL_OFFSET_SHIFT);
+	  fprintf (out, "[P%lu:%lu]", ref & ROW_NO_MASK, (unsigned long)(extra ? extra : ref >> COL_OFFSET_SHIFT));
 	}
     }
 }
@@@@ -2600,7 +2600,7 @@@@ row_map_fprint (FILE * out, buffer_desc_t * buf, db_bu
           }
 	case DV_LONG_INT:
 	  ROW_INT_COL (buf, row, rv, (*cl), LONG_REF, n32);
-	  fprintf (out, " %d", n32);
+	  fprintf (out, " %ld", (long)n32);
 	  col_comp_print (out, key, row, cl);
 	  break;
 	case DV_INT64:
@@@@ -2662,7 +2662,7 @@@@ row_map_fprint (FILE * out, buffer_desc_t * buf, db_bu
 	    if (IS_STRING_DTP (b_dtp))
 	      fprintf (out, " <inline blob %d> ", (int)b_dtp);
 	    else
-	      fprintf (out, "<blob dp=%d> ", LONG_REF_NA (xx + BL_DP));
+	      fprintf (out, "<blob dp=%ld> ", (long)(LONG_REF_NA (xx + BL_DP)));
 	  }
 	case DV_SINGLE_FLOAT:
 	  {
@@@@ -3444,8 +3444,8 @@@@ bif_key_estimate (caddr_t * qst, caddr_t * err_ret, st
 double
 rep_num_scale (double n, char ** scale_ret, int is_base_2)
 {
-  double dec_scale[] = {1000, 1000000, 1000000000, 1000000000000, 0};
-  double bin_scale[] = {1024, 1024*1024,  1024*1024*1024,   1024.0*1024*1024*1024, 0};
+  double dec_scale[] = {1000., 1000000., 1000000000., 1000000000000., 0.};
+  double bin_scale[] = {1024., 1024*1024.,  1024*1024*1024.,   1024.0*1024*1024*1024, 0.};
   double * scale = is_base_2 ? bin_scale : dec_scale;
   static char * empty = "";
   static char * letter[] = {"K", "M", "G", "T", ""};
@


1.1.1.1
log
@Import Virtuoso. Needed by Soprano (for tests) and for KDE 4 (Nepomuk).

Virtuoso is a high-performance object-relational SQL database. As
a database, it provides transactions, a smart SQL compiler, powerful
stored-procedure language with optional Java and .Net server-side
hosting, hot backup, SQL-99 support and more. It has all major
data-access interfaces, such as ODBC, JDBC, ADO .Net and OLE/DB.

"I looked at virtuoso and it gave me too much headaches.
Import it then (and polish in-tree)" landry@@
@
text
@@
