head	1.46;
access;
symbols
	OPENBSD_6_1:1.46.0.14
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.12
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.8
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.10
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.6
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.2
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.2
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.4.0.8
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.6
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.4
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4;
locks; strict;
comment	@# @;


1.46
date	2013.11.01.14.50.29;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.01.11.46.19;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2013.09.04.15.35.02;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2013.08.27.07.51.03;	author zhuk;	state Exp;
branches;
next	1.42;

1.42
date	2013.06.23.08.58.07;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.06.21.20.58;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2012.05.22.12.04.02;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2012.05.20.11.06.07;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2012.05.18.12.11.28;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2012.05.08.17.22.00;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.29.16.34.53;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2012.02.17.07.31.26;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2011.09.24.07.37.34;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2011.09.10.08.48.15;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.10.18.01.13;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.02.16.19.54;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.04.21.55.19;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2010.11.26.20.32.38;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.11.26.20.11.12;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.24.20.44.50;	author ajacoutot;	state Exp;
branches;
next	1.26;

1.26
date	2010.10.02.10.26.17;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.21.15.18.03;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.26.10.20.50;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.17.14.37.02;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.17.13.06.49;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.17.09.33.18;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.13.10.23.53;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.12.11.53.09;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.25.09.23.03;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.25.09.15.43;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.16.03.24.28;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.15.12.43.58;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.14.14.02.11;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.14.12.41.56;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.14.11.31.37;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.14.10.45.52;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.14.09.23.10;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.25.18.01.15;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2008.10.26.23.42.24;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.26.15.12.30;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.20.21.02.47;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.19.23.50.54;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.27.11.16.10;	author steven;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.03.23.26.41;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.03.23.03.09;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.15.09.41.44;	author espie;	state Exp;
branches;
next	;


desc
@@


1.46
log
@have comment reflect reality
@
text
@#! /usr/bin/perl
# $OpenBSD: mksqlitedb,v 1.45 2013/11/01 11:46:19 espie Exp $
#
# Copyright (c) 2006-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# example script that shows how to store all variable values into a
# database, using SQLite for that purpose.
#
# usage: cd /usr/ports && mksqlitedb

use strict;
use warnings;
use FindBin;
use lib $FindBin::Bin;
use Getopt::Std;
use Column;
use Var;
use Inserter;
use DBI;
use PkgPath;
use Info;
use TreeWalker;

package MyTreeWalker;
our @@ISA = (qw(TreeWalker));

sub new
{
	my ($class, $inserter) = @@_;
	bless { inserter => $inserter }, $class;
}

sub inserter
{
	return shift->{inserter};
}

sub handle_value
{
	my ($self, $o, $var, $value, $arch) = @@_;
	$o->{info} //= Info->new($o);
	$o->{info}->create($var, $value, $arch, $o);
}

sub parse_dump
{
	my ($self, $fd, $subdirs) = @@_;
	$self->SUPER::parse_dump($fd, $subdirs);
	$self->inserter->commit_to_db;
}

sub create_missing_vars
{
	my ($self, $o) = @@_;
	for my $name (qw(SHARED_LIBS TARGETS)) {
		if (!defined $o->{info}->{vars}{$name}) {
			$o->{info}->create($name, '', undef, $o);
		}
	}
}

sub handle_path
{
	my ($self, $pkgpath) = @@_;
	$self->create_missing_vars($pkgpath);
	my $key = $pkgpath->fullpkgpath;
	if ($pkgpath->{info}{done}) {
		print "--- $key (already done)\n";
		return;
	}
	print "+++ $key\n";
	$self->inserter->set_newkey($key);
	for my $var ($pkgpath->{info}->variables) {
		$self->inserter->add_var($var);
	}
	$pkgpath->{info}->reclaim;
	$pkgpath->{info}{done} = 1;
	$pkgpath->{info}{canonical} = $pkgpath;
	$pkgpath->{done} = 1;
	$self->inserter->finish_port;
}

package main;

our ($opt_v, $opt_q, $opt_p);

getopts('vq:p:');
my $dbname;
if (@@ARGV > 0) {
	$dbname = shift;
} else {
	$dbname = 'sqlports';
}

my $inserter = InserterList->new;

my $db = DBI->connect("dbi:SQLite:dbname=$dbname", '', '', {AutoCommit => 0});
my $db2 = DBI->connect("dbi:SQLite:dbname=$dbname-compact", '', '',
    {AutoCommit => 0});
my $normal = NormalInserter->new($db, 1000, $opt_v);
$inserter->add($normal, CompactInserter->new($db2, 1000, $opt_v));


$inserter->create_tables($Info::vars);

if ($opt_p) {
	$ENV{'REPORT_PROBLEM_LOGFILE'}= $opt_p;
}

my $walker = MyTreeWalker->new($inserter);
$walker->dump_all_dirs;

print "Aliases\n";
for my $v (PkgPath->seen) {
	next unless defined $v->{needalias};
	my $alias = $v->{info}{canonical};
	if (defined $alias) {
		print $v->fullpkgpath, "->", $alias->fullpkgpath, "\n";
		$walker->inserter->add_path($v->fullpkgpath, $alias->fullpkgpath);
	} else {
		print "!!! Can't figure out alias for ", $v->fullpkgpath, "\n";
	}
}

$walker->inserter->commit_to_db;

while (my ($k, $v) = each %$Info::unknown) {
	print STDERR "Unknown variable $k in ", $v->fullpkgpath, "\n";
}

if (defined $opt_q) {
	open(my $log, ">", $opt_q) or die $!;
	$walker->inserter->write_log($log);
} else {
	$walker->inserter->write_log(\*STDERR);
}
@


1.45
log
@move the TreeWalker code to its own file, no functional change
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.44 2013/09/04 15:35:02 espie Exp $
d21 1
a21 1
# usage: cd /usr/ports && make dump-vars |mksqlitedb
@


1.44
log
@refactor TreeWalker code for later
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.43 2013/08/27 07:51:03 zhuk Exp $
d34 1
a34 134

package TreeWalker;

$SIG{__WARN__} = sub {
	require Carp;

	my $_ = pop @@_;
	s/(.*)( at .*? line .*?\n$)/$1/s;
	push @@_, $_;
	warn &Carp::longmess;
};

$SIG{__DIE__} = sub {
	require Carp;

	my $_ = pop @@_;
	s/(.*)( at .*? line .*?\n$)/$1/s;
	push @@_, $_;
	die &Carp::longmess;
};

sub subdirlist
{
	my ($self, $list) = @@_;
	return join(' ', sort keys %$list);
}

sub dump_dirs
{
	my ($self, $subdirs) = @@_;
	my ($pid, $fd);
	unless (defined($pid = open($fd, "-|"))) {
		die "can't fork : $!";
	}
	if ($pid) {
		$self->parse_dump($fd, $subdirs);
		close $fd || die $!;
	} else {
		if (defined $subdirs) {
			$ENV{'SUBDIR'} = $self->subdirlist($subdirs);
		}
		$ENV{'NO_IGNORE'} = 'Yes';
		delete $ENV{'SUBPACKAGE'};
		delete $ENV{'FLAVOR'};
		exec {'make'} ("make", "dump-vars");
		die $!;
	}
}

sub parse_dump
{
	my ($self, $fd, $subdirs) = @@_;
	my $h = {};
	my $seen = {};
	my $subdir;
	my $reset = sub {
		$h = PkgPath->handle_equivalences($self, $h, $subdirs);
		for my $pkgpath (values %$h) {
			$self->handle_path($pkgpath);
		}
		$h = {};
	};

	while (<$fd>) {
		chomp;
		# kill noise
		if (m/^\=\=\=\>\s*Exiting (.*) with an error$/) {
			my $dir = PkgPath->new($1);
			$dir->break("exiting with an error");
			$h->{$dir} = $dir;
			&$reset;
			next;
		}
		if (m/^\=\=\=\>\s*(.*)/) {
			$subdir = PkgPath->new($1);
			&$reset;
		} elsif (my ($pkgpath, $var, $arch, $value) =
		    m/^(.*?)\.([A-Z][A-Z_0-9]*)(?:\-([a-z0-9]+))?\=\s*(.*)\s*$/) {
			if ($value =~ m/^\"(.*)\"$/) {
				$value = $1;
			}
			my $o = PkgPath->compose($pkgpath, $subdir);
			$h->{$o} = $o;
			$self->handle_value($o, $var, $value, $arch);
			# Note we did it !
		} elsif (m/^\>\>\s*Broken dependency:\s*(.*?)\s*non existent/) {
			my $dir = PkgPath->new($1);
			$dir->break("broken dependency");
			$h->{$dir} = $dir;
			&$reset;
		}
	}
	&$reset;
}

sub handle_value
{
}

sub handle_path
{
}

sub dump_all_dirs
{
	my $self = shift;
	$self->dump_dirs(undef);

	my $i = 1;
	while (1) {
		my $subdirlist = {};
		for my $v (PkgPath->seen) {
			if (defined $v->{info}) {
				delete $v->{tried};
				if (defined $v->{want}) {
					delete $v->{want};
					if (!defined $v->{done}) {
						$v->{needalias} = 1;
					}
				}
				next;
			}
			if (defined $v->{tried}) {
			} elsif ($v->{want}) {
				$v->add_to_subdirlist($subdirlist);
				$v->{tried} = 1;
			}
		}
		last if (keys %$subdirlist) == 0;
		$i++;
		print "pass #$i\n";
		$self->dump_dirs($subdirlist);
	}
}
@


1.43
log
@Unbreak fetching of SHARED_LIBS and TARGETS in sqlports.

okay espie@@
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.42 2013/06/23 08:58:07 espie Exp $
d35 2
a54 2
our ($opt_v, $opt_q, $opt_p);

d57 1
a57 1
	my $list = shift;
d61 1
a61 1
sub create_missing_vars
d63 11
a73 4
	my $o = shift;
	for my $name (qw(SHARED_LIBS TARGETS)) {
		if (!defined $o->{info}->{vars}{$name}) {
			$o->{info}->create($name, '', undef, $o);
d75 5
d85 1
a85 1
	my ($inserter, $fd, $subdirs) = @@_;
d90 1
a90 1
		$h = PkgPath->handle_equivalences($inserter, $h, $subdirs);
d92 1
a92 16
			create_missing_vars($pkgpath);
			my $key = $pkgpath->fullpkgpath;
			if ($pkgpath->{info}{done}) {
				print "--- $key (already done)\n";
				next;
			}
			print "+++ $key\n";
			$inserter->set_newkey($key);
			for my $var ($pkgpath->{info}->variables) {
				$inserter->add_var($var);
			}
			$pkgpath->{info}->reclaim;
			$pkgpath->{info}{done} = 1;
			$pkgpath->{info}{canonical} = $pkgpath;
			$pkgpath->{done} = 1;
			$inserter->finish_port;
d117 1
a118 2
			$o->{info} //= Info->new($o);
			$o->{info}->create($var, $value, $arch, $o);
a126 1
	$inserter->commit_to_db;
d129 9
a137 1
sub dump_dirs
d139 27
a165 4
	my ($inserter, $subdirs) = @@_;
	my ($pid, $fd);
	unless (defined($pid = open($fd, "-|"))) {
		die "can't fork : $!";
d167 36
a202 6
	if ($pid) {
		parse_dump($inserter, $fd, $subdirs);
		close $fd || die $!;
	} else {
		if (defined $subdirs) {
			$ENV{'SUBDIR'} = subdirlist($subdirs);
a203 8
		if ($opt_p) {
			$ENV{'REPORT_PROBLEM_LOGFILE'}= $opt_p;
		}
		$ENV{'NO_IGNORE'} = 'Yes';
		delete $ENV{'SUBPACKAGE'};
		delete $ENV{'FLAVOR'};
		exec {'make'} ("make", "dump-vars");
		die $!;
d207 25
d251 3
a253 1
dump_dirs($inserter, undef);
d255 2
a256 25
my $i = 1;
while (1) {
	my $subdirlist = {};
	for my $v (PkgPath->seen) {
		if (defined $v->{info}) {
			delete $v->{tried};
			if (defined $v->{want}) {
				delete $v->{want};
				if (!defined $v->{done}) {
					$v->{needalias} = 1;
				}
			}
			next;
		}
		if (defined $v->{tried}) {
		} elsif ($v->{want}) {
			$v->add_to_subdirlist($subdirlist);
			$v->{tried} = 1;
		}
	}
	last if (keys %$subdirlist) == 0;
	$i++;
	print "pass #$i\n";
	dump_dirs($inserter, $subdirlist);
}
d264 1
a264 1
		$inserter->add_path($v->fullpkgpath, $alias->fullpkgpath);
d270 1
a270 1
$inserter->commit_to_db;
d278 1
a278 1
	$inserter->write_log($log);
d280 1
a280 1
	$inserter->write_log(\*STDERR);
@


1.42
log
@clean-up the business of variables we silently ignore.
no bump, doesn't affect the built packages at all.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.41 2013/01/06 21:20:58 espie Exp $
d65 1
a65 1
		if (!defined $o->{info}{$name}) {
@


1.41
log
@make it work even if dump-vars doesn't record empty vars
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.40 2012/05/22 12:04:02 espie Exp $
a220 1
	next if $k eq 'CHECKSUM_FILE';
@


1.40
log
@tweak: MULTI table now holds pointer to the corresponding subpackage path
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.39 2012/05/20 11:06:07 espie Exp $
d35 18
d61 10
d80 1
@


1.39
log
@more surgery:
- don't ask the database about existing pathkeys, it's simpler to have
our hash.
- in dependencies, don't like for non normalized pathkeys
- add CANONICAL column, and fill it.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.38 2012/05/18 12:11:28 espie Exp $
d93 1
a93 1
			$o->{info}->create($var, $value, $arch);
@


1.38
log
@bite the bullet, reuse dpb's algorithm to make sure we get correct
PkgPath.

This implies restructuring the database code, and the start of a
better separation between variables handling, and actual insertion
in the database.

bump version to 2.0: this changes the paths that actually get recorded,
and pkglocatedb will need to be aware of that.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.37 2012/05/08 17:22:00 espie Exp $
d64 2
d157 6
a162 1
			delete $v->{want};
d176 14
@


1.37
log
@if this pipe exits with an error, it means some subdirs could not be
scanned. That's not a warning, that's a hard error.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.36 2012/04/29 16:34:53 espie Exp $
d32 2
d35 1
d37 5
a41 1
our ($opt_v, $opt_q, $opt_p);
d45 24
a68 2
	my ($inserter, $vars, $fd, $unknown) = @@_;
	my $lastkey;
d72 5
a76 2
		if (s/^\=\=\=/---/) {
			print $_, "\n";
d79 7
a85 11
		next unless m/^(.*?)\.([A-Z][A-Z_0-9]*)(?:\-([a-z0-9]+))?\=(.*)$/;

		my ($key, $var, $arch, $value) = ($1, $2, $3, $4);
		# strip extra quotes
		if ($value =~ m/^\"(.*)\"$/) {
			$value = $1;
		}

		if (!(defined $lastkey) || $key ne $lastkey) {
			if (defined $lastkey) {
				$inserter->finish_port;
d87 10
a96 11
			$inserter->mark_done($key);
			if ($key =~ m/^(.*)\,\-main((?:\,.*)?)$/) {
				$inserter->mark_done("$1$2");
			}
			$inserter->set_newkey($key);
			$lastkey = $key;
		}
		if (defined $vars->{$var}) {
			$inserter->add_var($vars->{$var}->new($var, $value, $arch));
		} else {
			$unknown->{$var} //= $key;
d99 1
a99 2

	$inserter->finish_port;
d105 1
a105 1
	my ($inserter, $vars, $unknown, $todo) = @@_;
d111 1
a111 1
		parse_dump($inserter, $vars, $fd, $unknown);
d114 2
a115 2
		if (defined $todo) {
			$ENV{'SUBDIR'} = join(' ', keys %$todo);
d145 1
a145 69
my $vars = {
    AUTOCONF_VERSION => 'AutoVersionVar',
    AUTOMAKE_VERSION => 'AutoVersionVar',
    BROKEN => 'BrokenVar',
    BUILD_DEPENDS => 'BuildDependsVar',
    CATEGORIES => 'CategoriesVar',
    COMES_WITH => 'DefinedVar',
    COMMENT => 'AnyVar',
    CONFIGURE_ARGS => 'ConfigureArgsVar',
    CONFIGURE_STYLE => 'ConfigureVar',
    DESCR => 'FileVar',
    DISTFILES => 'AnyVar',
    PATCHFILES => 'AnyVar',
    DISTNAME => 'AnyVar',
    DIST_SUBDIR => 'DefinedVar',
    EPOCH => 'AnyVar',
    FLAVORS => 'FlavorsVar',
    FULLPKGNAME => 'AnyVar',
    HOMEPAGE => 'AnyVar',
    IGNORE => 'DefinedVar',
    IS_INTERACTIVE => 'AnyVar',
    LIB_DEPENDS => 'LibDependsVar',
    MAINTAINER=> 'EmailVar',
    MASTER_SITES => 'MasterSitesVar',
    MASTER_SITES0 => 'MasterSitesVar',
    MASTER_SITES1 => 'MasterSitesVar',
    MASTER_SITES2 => 'MasterSitesVar',
    MASTER_SITES3 => 'MasterSitesVar',
    MASTER_SITES4=> 'MasterSitesVar',
    MASTER_SITES5 => 'MasterSitesVar',
    MASTER_SITES6 => 'MasterSitesVar',
    MASTER_SITES7 => 'MasterSitesVar',
    MASTER_SITES8 => 'MasterSitesVar',
    MASTER_SITES9=> 'MasterSitesVar',
    MODULES => 'ModulesVar',
    MULTI_PACKAGES => 'MultiVar',
    NO_BUILD => 'YesNoVar',
    NO_REGRESS => 'YesNoVar',
    NOT_FOR_ARCHS => 'NotForArchListVar',
    ONLY_FOR_ARCHS => 'OnlyForArchListVar',
    PERMIT_DISTFILES_CDROM => 'YesKeyVar',
    PERMIT_DISTFILES_FTP=> 'YesKeyVar',
    PERMIT_PACKAGE_CDROM => 'YesKeyVar',
    PERMIT_PACKAGE_FTP=> 'YesKeyVar',
    PKGNAME => 'AnyVar',
    PKGSPEC => 'AnyVar',
    PKG_ARCH => 'ArchKeyVar',
    PSEUDO_FLAVOR => 'AnyVar',
    PSEUDO_FLAVORS => 'PseudoFlavorsVar',
    REGRESS_DEPENDS => 'RegressDependsVar',
    REGRESS_IS_INTERACTIVE => 'AnyVar',
    REVISION => 'AnyVar',
    RUN_DEPENDS => 'RunDependsVar',
    SEPARATE_BUILD => 'YesKeyVar',
    SHARED_LIBS => 'SharedLibsVar',
    SHARED_ONLY => 'YesNoVar',
    SUBPACKAGE => 'DefinedVar',
    SUPDISTFILES => 'AnyVar',
    TARGETS => 'TargetsVar',
    USE_GMAKE => 'YesNoVar',
    USE_GROFF => 'YesNoVar',
    USE_LIBTOOL => 'YesNoGnuVar',
    VMEM_WARNING => 'YesNoVar',
    WANTLIB => 'WantlibVar',
};

$inserter->create_tables($vars);

my $unknown = {};
d147 1
a147 1
dump_dirs($inserter, $vars, $unknown, undef);
d151 12
a162 7
	my $todo = {};
	my $stuff = 0;
	for my $v (keys %{$normal->{todo}}) {
		next if $normal->{done}{$v};
		$todo->{$v} = 1;
		$stuff = 1;

d164 1
a164 2
	last if !$stuff;
	$normal->{todo} = {};
d167 1
a167 6
	dump_dirs($inserter, $vars, $unknown, $todo);
	for my $v (keys %$todo) {
		if (!$normal->{done}{$v}) {
			$normal->{done}{$v} = 1;
		}
	}
d170 1
a170 1
while (my ($k, $v) = each %$unknown) {
d172 1
a172 1
	print STDERR "Unknown variable $k in $v\n";
@


1.36
log
@+VMEM_WARNING
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.35 2012/02/17 07:31:26 espie Exp $
d86 1
a86 1
		close $fd || warn $!;
@


1.35
log
@make sure we don't pass FLAVOR/SUBPACKAGE info thru subdirs.
count number of passes (purely cosmetic)
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.34 2011/09/24 07:37:34 espie Exp $
d181 1
@


1.34
log
@better: use REPORT_PROBLEM_LOGFILE to have nicer error messages.
use new FULLPATH setting from bsd.port.subdir.mk to avoid having to fiddle
too much with options.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.33 2011/09/10 08:48:15 espie Exp $
d95 2
d190 1
d202 2
a203 1
	print "Next pass\n";
@


1.33
log
@store PSEUDO_FLAVOR along. tweak descriptions a bit.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.32 2011/04/10 18:01:13 jasper Exp $
d92 1
a92 1
			$ENV{'REPORT_PROBLEM'}= "touch $opt_p; exit 1";
@


1.32
log
@adjust after recent lesstif removal

ok aja@@ sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.31 2011/03/02 16:19:54 espie Exp $
d164 1
@


1.31
log
@tweak the way mksqlitedb work: keep looking at dependencies after we do
the main tree.

initial work by florent tribouilloy

a bit of clean-up from me.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.30 2011/01/04 21:55:19 espie Exp $
a177 1
    USE_MOTIF => 'MotifVar',
@


1.30
log
@handle PATCHFILES, ignore CHECKSUM_FILE
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.29 2010/11/26 20:32:38 espie Exp $
d34 1
a34 1
our ($opt_v, $opt_q);
d36 65
a100 1
getopts('vq:');
d113 2
a114 2
$inserter->add(NormalInserter->new($db, 1000, $opt_v),
    CompactInserter->new($db2, 1000, $opt_v));
a183 1
my $lastkey;
a184 8
while (<STDIN>) {
	chomp;
	# kill noise
	if (s/^\=\=\=/---/) {
		print $_, "\n";
		next;
	}
	next unless m/^(.*?)\.([A-Z][A-Z_0-9]*)(?:\-([a-z0-9]+))?\=(.*)$/;
d186 10
a195 4
	my ($key, $var, $arch, $value) = ($1, $2, $3, $4);
	# strip extra quotes
	if ($value =~ m/^\"(.*)\"$/) {
		$value = $1;
d197 7
a203 4

	if (!(defined $lastkey) || $key ne $lastkey) {
		if (defined $lastkey) {
			$inserter->finish_port;
a204 2
		$inserter->set_newkey($key);
		$lastkey = $key;
a205 5
	if (defined $vars->{$var}) {
		$inserter->add_var($vars->{$var}->new($var, $value, $arch));
	} else {
		$unknown->{$var} //= $key;
    	}
a206 3

$inserter->finish_port;
$inserter->commit_to_db;
@


1.29
log
@handle USE_MOTIF, add PKGSPEC
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.28 2010/11/26 20:11:12 espie Exp $
d58 1
a58 1
    CATEGORIES=> 'CategoriesVar',
d65 1
d155 1
@


1.28
log
@report Yes/No variables with wrong values.
common work with Florent Tribouilloy

also rework Yes/No variables as valued variables.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.27 2010/10/24 20:44:50 ajacoutot Exp $
d97 1
d113 1
a113 1
    USE_MOTIF => 'YesNoVar',
@


1.27
log
@Remove obsolete USE_X11 from $vars.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.26 2010/10/02 10:26:17 espie Exp $
d34 1
a34 1
our ($opt_v);
d36 1
a36 1
getopts('v');
d43 1
d154 7
@


1.26
log
@USE_LIBTOOL is 3-valued.
register TARGETS
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.25 2010/09/21 15:18:03 sthen Exp $
a111 1
    USE_X11 => 'YesNoVar',
@


1.25
log
@output EPOCH and REVISION in dump-vars, and use it in sqlports.
ok espie@@ (with a reminder to add EPOCH, my first diff just had REVISION).
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.24 2010/04/26 10:20:50 espie Exp $
d107 1
d110 1
a110 1
    USE_LIBTOOL => 'YesNoVar',
@


1.24
log
@whitespace
@
text
@d2 1
a2 1
# $OpenBSD$
d66 1
d100 1
@


1.23
log
@turn on foreign key constraints, as they seem to work ;-)
@
text
@d46 1
a46 1
my $db2 = DBI->connect("dbi:SQLite:dbname=$dbname-compact", '', '', 
@


1.22
log
@a few minor tidying.
commit to db only at end of port (referential integrity for later)
handle BROKEN-arch and create new table/view based on that.
@
text
@d120 2
a121 2
	if (m/^\=\=\=/) {
		print "---", $_, "\n";
@


1.21
log
@sanitize code, no functional changes
@
text
@d45 2
a46 2
my $db =DBI->connect("dbi:SQLite:dbname=$dbname", '', '', {AutoCommit => 0});
my $db2 =DBI->connect("dbi:SQLite:dbname=$dbname-compact", '', '', 
d48 1
a48 1
$inserter->add(NormalInserter->new($db, 1000, $opt_v), 
d55 1
a55 1
    BROKEN => 'AnyVar',
d124 1
a124 1
	next unless m/^(.*?)\.([A-Z][A-Z_0-9]*)\=(.*)$/;
d126 1
a126 1
	my ($key, $var, $value) = ($1, $2, $3);
d140 1
a140 1
		$inserter->add_var($vars->{$var}->new($var, $value));
d145 1
@


1.20
log
@cut script into smaller pieces, since it becomes hard to manage
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.19 2010/02/12 11:53:09 espie Exp $
a35 8
sub words($)
{
	my $v = shift;
	$v =~ s/^\s+//;
	$v =~ s/\s+$//;
	return split(/\s+/, $v);
}

d43 1
a43 1
my @@inserters;
d48 2
a49 2
push(@@inserters, NormalInserter->new($db, 1000));
push(@@inserters, CompactInserter->new($db2, 1000));
d113 1
a113 6
for my $inserter (@@inserters) {
	$inserter->create_tables($vars);
	if ($opt_v) {
		print "-"x50, "\n";
	}
}
d134 1
a134 6
			for my $inserter (@@inserters) {
				$inserter->finish_port;
			}
		}
		for my $inserter (@@inserters) {
			$inserter->set_newkey($key);
d136 1
d139 3
a141 1
	if (!defined $vars->{$var}) {
a142 5
	} else {
		my $v = $vars->{$var}->new($var, $value);
		for my $inserter (@@inserters) {
			$v->add($inserter);
		}
d145 2
a146 4
for my $inserter (@@inserters) {
	$inserter->finish_port;
	$inserter->db->commit;
}
@


1.19
log
@get mksqlitedb to handle IGNORE and COMES_WITH if they show up.
Also don't spazz out if we meet variables we don't know. This makes us
safe from changes in dump-vars.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.18 2009/08/25 09:23:03 espie Exp $
d4 1
a4 1
# Copyright (c) 2006 Marc Espie <espie@@openbsd.org>
d25 2
d28 5
a43 1050
package Column;
sub new
{
	my ($class, $name) = @@_;
	if (!defined $name) {
		$name = $class->default_name;
	}
	bless {name => $name}, $class;
}

sub set_class
{
	my ($self, $varclass) = @@_;

	$self->{class} = $varclass;
	return $self;
}

sub name
{
	my $self = shift;
	return $self->{name};
}

sub render
{
	my ($self, $inserter, $class) = @@_;
	return $self->name." ".$self->sqltype;
}

sub render_view
{
	my ($self, $t) = @@_;
	return $t.".".$self->name." AS ".$self->name;
}

sub render_join
{
	return "";
}

package TextColumn;
our @@ISA = qw(Column);

sub sqltype
{
	return "TEXT NOT NULL";
}

package OptTextColumn;
our @@ISA = qw(TextColumn);

sub sqltype
{
	return "TEXT";
}

package IntegerColumn;
our @@ISA =qw(Column);
sub sqltype
{
	return "INTEGER NOT NULL";
}

package OptIntegerColumn;
our @@ISA = qw(IntegerColumn);
sub sqltype
{
	return "INTEGER";
}

package RefColumn;
our @@ISA = qw(Column);

my $table = "T0001";

sub table
{
	my $self = shift;
	if (!defined $self->{table}) {
		$self->{table} = $table++;
	}
	return $self->{table};
}

package PathColumn;
our @@ISA = qw(RefColumn);

sub default_name
{
	return "FULLPKGPATH";
}

sub render_view
{
	my ($self, $t) = @@_;
	return $self->table.".FULLPKGPATH AS ".$self->name;
}

sub render
{
	my ($self, $inserter, $class) = @@_;
	return $inserter->pathref($self->name);
}

sub render_join
{
	my ($self, $table) = @@_;
	return "JOIN Paths ".$self->{table}." ON ".$self->table.".ID=$table.".$self->name;
}

package ValueColumn;
our @@ISA = qw(RefColumn);

sub default_name
{
	return "VALUE";
}

sub k
{
	my $self = shift;
	return $self->{class}->keyword_table;
}

sub render
{
	my ($self, $inserter) = @@_;
	return $inserter->value($self->k, $self->name);
}

sub render_view
{
	my ($self, $t) = @@_;
	if (defined $self->k) {
		return $self->table.".VALUE AS ".$self->name;
	} else {
		return $self->SUPER::render_view($t);
	}
}

sub render_join
{
	my ($self, $table) = @@_;
	if (defined $self->k) {
		return "JOIN ".$self->k." ".$self->table." ON ".$self->table.".KEYREF=$table.".$self->name;
	}
}

package OptValueColumn;
our @@ISA = qw(ValueColumn);

sub render
{
	my ($self, $inserter) = @@_;
	return $inserter->optvalue($self->k, $self->name);
}

sub render_join
{
	my ($self, $table) = @@_;
	return "LEFT ".$self->SUPER::render_join($table);
}

package AbstractInserter;
# this is the object to use to put stuff into the db...
sub new
{
	my ($class, $db, $i) = @@_;
	bless {
		db => $db, 
		transaction => 0, 
		threshold => $i, 
		vars => {},
		tables_created => {}
	}, $class;
}

sub make_table
{
	my ($self, $class, $constraint, @@columns) = @@_;

	return if defined $self->{tables_created}->{$class->table};

	unshift(@@columns, PathColumn->new);
	for my $c (@@columns) {
		$c->set_class($class) unless defined $c->{class};
	}
	my @@l = map {$_->render($self)} @@columns;
	push(@@l, $constraint) if defined $constraint;
	$self->new_table($class->table, @@l);
}

sub set
{
	my ($self, $ref) = @@_;
	$self->{ref} = $ref;
}

sub db
{
	return shift->{db};
}

sub last_id
{
	return shift->db->func('last_insert_rowid');
}

sub insert_done
{
	my $self = shift;
	if ($self->{transaction}++ % $self->{threshold} == 0) {
		$self->db->commit;
	}
}

sub new_table
{
	my ($self, $name, @@cols) = @@_;

	return if defined $self->{tables_created}->{$name};

	$self->db->do("DROP TABLE IF EXISTS $name");
	print "CREATE TABLE $name (".join(', ', @@cols).")\n" if $main::opt_v;
	$self->db->do("CREATE TABLE $name (".join(', ', @@cols).")");
	$self->{tables_created}->{$name} = 1;
}

sub prepare
{
	my ($self, $s) = @@_;
	return $self->db->prepare($s);
}

sub prepare_inserter
{
	my ($ins, $table, @@cols) = @@_;
	$ins->{insert}->{$table} = $ins->prepare(
	    "INSERT OR REPLACE INTO $table (".
	    join(', ', @@cols).
	    ") VALUES (". 
	    join(', ', map {'?'} @@cols).")");
}

sub prepare_normal_inserter
{
	my ($ins, $table, @@cols) = @@_;
	$ins->prepare_inserter($table, "FULLPKGPATH", @@cols);
}

sub finish_port
{
	my $self = shift;
	my @@values = ($self->ref);
	for my $i (@@{$self->{varlist}}) {
		push(@@values, $self->{vars}->{$i});
	}
	$self->insert('Ports', @@values);
	$self->{vars} = {};
}

sub add_to_port
{
	my ($self, $var, $value) = @@_;
	$self->{vars}->{$var} = $value;
}

sub create_tables
{
	my ($self, $vars) = @@_;

	$self->db->commit;
	my @@columns = sort {$a->name cmp $b->name} @@{$self->{columnlist}};
	unshift(@@columns, PathColumn->new);
	my @@l = map {$_->render($self)} @@columns;
	$self->new_table("Ports", @@l, "UNIQUE(FULLPKGPATH)");
	$self->prepare_normal_inserter('Ports', @@{$self->{varlist}});
	$self->prepare_normal_inserter('Paths', 'PKGPATH');
}

sub ref
{
	return shift->{ref};
}

sub insert
{
	my $self = shift;
	my $table = shift;
	$self->{insert}->{$table}->execute(@@_);
	$self->insert_done;
}

package CompactInserter;
our @@ISA=(qw(AbstractInserter));

our $c = {
	Library => 0,
	Run => 1,
	Build => 2,
	Regress => 3
};

sub convert_depends
{
	my ($self, $value) = @@_;
	return $c->{$value};
}


sub pathref
{
	my ($self, $name) = @@_;
	$name = "FULLPKGPATH" if !defined $name;
	return "$name INTEGER NOT NULL REFERENCES Paths(ID)";
}

sub value
{
	my ($self, $k, $name) = @@_;
	$name = "VALUE" if !defined $name;
	if (defined $k) {
		return "$name INTEGER NOT NULL REFERENCES $k(KEYREF)";
	} else {
		return "$name TEXT NOT NULL";
	}
}

sub optvalue
{
	my ($self, $k, $name) = @@_;
	$name = "VALUE" if !defined $name;
	if (defined $k) {
		return "$name INTEGER REFERENCES $k(KEYREF)";
	} else {
		return "$name TEXT";
	}
}

sub create_view
{
	my ($self, $table, @@columns) = @@_;

	unshift(@@columns, PathColumn->new);
	my $name = "_$table";
	my @@l = map {$_->render_view($table) } @@columns;
	my @@j = map {$_->render_join($table)} @@columns;
	my $v = "CREATE VIEW $name AS SELECT ".join(", ", @@l). " FROM ".$table.' '.join(' ', @@j);
	$self->db->do("DROP VIEW IF EXISTS $name");
	print "$v\n" if $main::opt_v;
	$self->db->do($v);
}

sub make_table
{
	my ($self, $class, $constraint, @@columns) = @@_;

	return if defined $self->{tables_created}->{$class->table};

	$self->SUPER::make_table($class, $constraint, @@columns);
	$self->create_view($class->table, @@columns);
}

sub create_tables
{
	my ($self, $vars) = @@_;
	# create the various tables, dropping old versions

	$self->new_table("Paths", "ID INTEGER PRIMARY KEY", 
	    "FULLPKGPATH TEXT NOT NULL UNIQUE", "PKGPATH INTEGER");

	while (my ($name, $class) = each %$vars) {
		my $c = $class->column($name);
		if (!defined( $class->table )) {
			push(@@{$self->{varlist}}, $name);
			push(@@{$self->{columnlist}}, $c);
		}
		$class->create_table($self);
	}

	$self->SUPER::create_tables($vars);
	my @@columns = sort {$a->name cmp $b->name} @@{$self->{columnlist}};
	$self->create_view("Ports", @@columns);
	$self->{find_pathkey} =  
	    $self->prepare("SELECT ID From Paths WHERE FULLPKGPATH=(?)");
}

sub find_pathkey
{
	my ($self, $key) = @@_;

	if (!defined $key or $key eq '') {
		print STDERR "Empty pathkey\n";
		return 0;
	}

	# get pathkey for existing value
	$self->{find_pathkey}->execute($key);
	my $z = $self->{find_pathkey}->fetchrow_arrayref;
	if (!defined $z) {
		# if none, we create one
		my $path = $key;
		$path =~ s/\,.*//;
		if ($path ne $key) {
			$path = $self->find_pathkey($path);
		} else {
			$path = undef;
		}
		$self->insert('Paths', $key, $path);
		return $self->last_id;
	} else {
		return $z->[0];
	}
}

sub set_newkey
{
	my ($self, $key) = @@_;

	$self->set($self->find_pathkey($key));
}

sub find_keyword_id
{
	my ($self, $key, $t) = @@_;
	$self->{$t}->{find_key1}->execute($key);
	my $a = $self->{$t}->{find_key1}->fetchrow_arrayref;
	if (!defined $a) {
		$self->{$t}->{find_key2}->execute($key);
		$self->insert_done;
		return $self->last_id;
	} else {
		return $a->[0];
	}
}

sub create_keyword_table
{
	my ($self, $t) = @@_;
	$self->new_table($t,
	    "KEYREF INTEGER PRIMARY KEY AUTOINCREMENT", 
	    "VALUE TEXT NOT NULL UNIQUE");
	$self->{$t}->{find_key1} = $self->prepare("SELECT KEYREF FROM $t WHERE VALUE=(?)");
	$self->{$t}->{find_key2} = $self->prepare("INSERT INTO $t (VALUE) VALUES (?)");
}

package NormalInserter;
our @@ISA=(qw(AbstractInserter));

our $c = {
	Library => 'L',
	Run => 'R',
	Build => 'B',
	Regress => 'Regress'
};

sub convert_depends
{
	my ($self, $value) = @@_;
	return $c->{$value};
}

sub create_tables
{
	my ($self, $vars) = @@_;
	# create the various tables, dropping old versions

	$self->new_table("Paths", "FULLPKGPATH TEXT NOT NULL PRIMARY KEY", 
	    "PKGPATH TEXT NOT NULL");
	while (my ($name, $class) = each %$vars) {
		push(@@{$self->{varlist}}, $name);
		push(@@{$self->{columnlist}}, $class->column($name));
		$class->create_table($self);
	}

	$self->SUPER::create_tables($vars);

}

sub pathref
{
	my ($self, $name) = @@_;
	$name = "FULLPKGPATH" if !defined $name;
	return "$name TEXT NOT NULL";
}

sub value
{
	my ($self, $k, $name) = @@_;
	$name = "VALUE" if !defined $name;
	return "$name TEXT NOT NULL";
}

sub optvalue
{
	my ($self, $k, $name) = @@_;
	$name = "VALUE" if !defined $name;
	return "$name TEXT";
}

sub key
{
	return "TEXT NOT NULL";
}

sub optkey
{
	return "TEXT";
}

sub set_newkey
{
	my ($self, $key) = @@_;

	my $path = $key;
	$path =~ s/\,.*//;
	$self->insert('Paths', $key, $path);
	$self->set($key);
}

sub find_pathkey
{
	my ($self, $key) = @@_;

	return $key;
}

# no keyword for this dude
sub find_keyword_id
{
	my ($self, $key, $t) = @@_;
	return $key;
}

sub create_keyword_table
{
}

# use a Template Method approach to store the variable values.

# rule: we store each value in the main table, after converting YesNo
# variables to undef/1. Then, in addition, we process specific variables
# to store them in secondary tables (because of one/many associations).

package AnyVar;
sub new
{
	my ($class, $var, $value) = @@_;
	bless [$var, $value], $class;
}

sub var
{
	return shift->[0];
}

sub value
{
	return shift->[1];
}

sub add
{
	my ($self, $ins) = @@_;
	$ins->add_to_port($self->var, $self->value);
}

sub add_value
{
	my ($self, $ins, $value) = @@_;
	$ins->add_to_port($self->var, $value);
}

sub column
{
	my ($self, $name) = @@_;
	return $self->columntype->new($name)->set_class($self);
}

sub columntype
{
	return 'OptTextColumn';
}

sub table()
{
	return undef;
}

sub keyword_table()
{
	return undef;
}

sub keyword
{
	my ($self, $ins, $value) = @@_;
	return $ins->find_keyword_id($value, $self->keyword_table);
}

sub create_keyword_table
{
	my ($self, $inserter) = @@_;
	if (defined $self->keyword_table) {
		$inserter->create_keyword_table($self->keyword_table);
	}
}

sub create_table
{
	my ($self, $inserter) = @@_;
	$self->create_keyword_table($inserter);
}

sub insert
{
	my $self = shift;
	my $ins = shift;
	$ins->insert($self->table, @@_);
}

sub normal_insert
{
	my $self = shift;
	my $ins = shift;
    	$ins->insert($self->table, $ins->ref, @@_);
}

package KeyVar;
our @@ISA=(qw(AnyVar));
sub add
{
	my ($self, $ins) = @@_;
	$self->add_value($ins, $self->keyword($ins, $self->value));
}

sub columntype
{
	return 'ValueColumn';
}

package ArchKeyVar;
our @@ISA=(qw(KeyVar));

sub keyword_table()
{ 'Arch' }

package OptKeyVar;
our @@ISA=(qw(KeyVar));
sub add
{
	my ($self, $ins) = @@_;
	if ($self->value ne '') {
		$self->SUPER::add($ins);
	}
}

sub columntype
{
	return 'OptValueColumn';
}

package YesNoVar;
our @@ISA=(qw(AnyVar));

sub add
{
	my ($self, $ins) = @@_;
	$self->add_value($ins, $self->value =~ m/^Yes/i ? 1 : undef);
}

sub columntype
{
	return 'OptIntegerColumn';
}

# variable is always defined, but we don't need to store empty values.
package DefinedVar;
our @@ISA=(qw(AnyVar));

sub add
{
	my ($self, $ins) = @@_;
	return if $self->value eq '';
	$self->SUPER::add($ins);
}


# all the dependencies are converted into list. Stuff like LIB_DEPENDS will
# end up being treated as WANTLIB as well.

package DependsVar;
our @@ISA=(qw(AnyVar));
sub add
{
	my ($self, $ins) = @@_;
	$self->SUPER::add($ins);
	for my $depends (main::words $self->value) {
		my ($libs, $pkgspec, $pkgpath2, $rest) = split(/\:/, $depends);
		if (!defined $pkgpath2) {
			print STDERR "Wrong depends $depends\n";
			return;
		}
		$self->normal_insert($ins, $depends, 
		    $ins->find_pathkey($pkgpath2), 
		    $ins->convert_depends($self->depends_type), 
		    $pkgspec, $rest);
		if ($libs ne '') {
			for my $lib (split(/\,/, $libs)) {
				$self->add_lib($ins, $lib);
			}
		}
	}
}

sub create_table
{
	my ($self, $inserter) = @@_;
	$inserter->make_table($self, undef, 
	    TextColumn->new("FULLDEPENDS"),
	    OptTextColumn->new("PKGSPEC"),
	    OptTextColumn->new("REST"),
	    PathColumn->new("DEPENDSPATH"),
	    TextColumn->new("TYPE"));
	$inserter->prepare_normal_inserter($self->table, 
	    "FULLDEPENDS", "DEPENDSPATH", "TYPE", "PKGSPEC", "REST");
}

sub add_lib
{
}

sub table()
{
	return "Depends";
}

package LibDependsVar;
our @@ISA=(qw(DependsVar));
sub depends_type() { 'Library' }

sub add_lib
{
	my ($self, $ins, $lib) = @@_;
	WantlibVar->add_value($ins, $lib);
}

package RunDependsVar;
our @@ISA=(qw(DependsVar));
sub depends_type() { 'Run' }

package BuildDependsVar;
our @@ISA=(qw(DependsVar));
sub depends_type() { 'Build' }

package RegressDependsVar;
our @@ISA=(qw(DependsVar));
sub depends_type() { 'Regress' }

# Stuff that gets stored in another table
package SecondaryVar;
our @@ISA=(qw(KeyVar));
sub add_value
{
	my ($self, $ins, $value) = @@_;
	$self->normal_insert($ins, $value);
}

sub add_keyword
{
	my ($self, $ins, $value) = @@_;
	$self->add_value($ins, $self->keyword($ins, $value));
}

sub create_table
{
	my ($self, $inserter) = @@_;
	$self->create_keyword_table($inserter);
	$inserter->make_table($self, "UNIQUE(FULLPKGPATH, VALUE)", 
	    ValueColumn->new);
	$inserter->prepare_normal_inserter($self->table, "VALUE");
}

sub keyword_table()
{
	return undef;
}

package MasterSitesVar;
our @@ISA=(qw(OptKeyVar));
sub add
{
	my ($self, $ins) = @@_;

	my $n;
	if ($self->var =~ m/^MASTER_SITES(\d)$/) {
		$n = $1;
	}
	$self->normal_insert($ins, $n, $self->value);
}

sub create_table
{
	my ($self, $inserter) = @@_;
	$self->create_keyword_table($inserter);
	$inserter->make_table($self, "UNIQUE(FULLPKGPATH, N, VALUE)",
	    OptIntegerColumn->new("N"),
	    ValueColumn->new);
	$inserter->prepare_normal_inserter($self->table, "N", "VALUE");
}

sub table()
{
	return "MasterSites";
}

# Generic handling for any blank-separated list
package ListVar;
our @@ISA=(qw(SecondaryVar));

sub add
{
	my ($self, $ins) = @@_;
	$self->AnyVar::add($ins);
	for my $d (main::words $self->value) {
		$self->add_value($ins, $d) if $d ne '';
	}
}

sub columntype
{
	my ($self, $name) = @@_;
	return 'OptTextColumn';
}

package ListKeyVar;
our @@ISA=(qw(SecondaryVar));

sub add
{
	my ($self, $ins) = @@_;
	$self->AnyVar::add($ins);
	for my $d (main::words $self->value) {
		$self->add_keyword($ins, $d) if $d ne '';
	}
}

sub keyword_table()
{
	return "Keywords";
}

package QuotedListVar;
our @@ISA=(qw(ListVar));

sub add
{
	my ($self, $ins) = @@_;
	$self->AnyVar::add($ins);
	my @@l = (main::words $self->value);
	while (my $v = shift @@l) {
		while ($v =~ m/^[^']*\'[^']*$/ || $v =~m/^[^"]*\"[^"]*$/) {
			$v.=' '.shift @@l;
		}
		if ($v =~ m/^\"(.*)\"$/) {
		    $v = $1;
		}
		if ($v =~ m/^\'(.*)\'$/) {
		    $v = $1;
		}
		$self->add_value($ins, $v) if $v ne '';
	}
}

package DefinedListKeyVar;
our @@ISA=(qw(ListKeyVar));
sub add
{
	my ($self, $ins) = @@_;
	return if $self->value eq '';
	$self->SUPER::add($ins);
}

sub columntype
{
	return 'OptValueColumn';
}

package FlavorsVar;
our @@ISA=(qw(DefinedListKeyVar));
sub table() { 'Flavors' }

package PseudoFlavorsVar;
our @@ISA=(qw(DefinedListKeyVar));
sub table() { 'PseudoFlavors' }

package ArchListVar;
our @@ISA=(qw(DefinedListKeyVar));
sub keyword_table() { 'Arch' }

package OnlyForArchListVar;
our @@ISA=(qw(ArchListVar));
sub table() { 'OnlyForArch' }

package NotForArchListVar;
our @@ISA=(qw(ArchListVar));
sub table() { 'NotForArch' }

package CategoriesVar;
our @@ISA=(qw(ListKeyVar));
sub table() { 'Categories' }
sub keyword_table() { 'CategoryKeys' }

package MultiVar;
our @@ISA=(qw(ListVar));
sub table() { 'Multi' }

sub add
{
	my ($self, $ins) = @@_;
	return if $self->value eq '-';
	$self->SUPER::add($ins);
}

package ModulesVar;
our @@ISA=(qw(DefinedListKeyVar));
sub table() { 'Modules' }
sub keyword_table() { 'ModuleKeys' }

package ConfigureVar;
our @@ISA=(qw(DefinedListKeyVar));
sub table() { 'Configure' }
sub keyword_table() { 'ConfigureKeys' }

package ConfigureArgsVar;
our @@ISA=(qw(QuotedListVar));
sub table() { 'ConfigureArgs' }

package WantlibVar;
our @@ISA=(qw(ListVar));
sub table() { 'Wantlib' }
sub _add
{
	my ($self, $ins, $value, $extra) = @@_;
	$self->normal_insert($ins, $self->keyword($ins, $value), $extra);
}

sub add_value
{
	my ($self, $ins, $value) = @@_;
	if ($value =~ m/^(.*)(\.\>?\=\d+\.\d+)$/) {
		$self->_add($ins, $1, $2);
	} elsif ($value =~ m/^(.*)(\.\>?\=\d+)$/) {
		$self->_add($ins, $1, $2);
	} else {
		$self->_add($ins, $value, undef);
	}
}

sub create_table
{
	my ($self, $inserter) = @@_;
	$self->create_keyword_table($inserter);
	$inserter->make_table($self, "UNIQUE(FULLPKGPATH, VALUE)",
	    ValueColumn->new,
	    OptTextColumn->new("EXTRA"));
	$inserter->prepare_normal_inserter($self->table, "VALUE", "EXTRA");
}

sub keyword_table() { 'Library' }

package OnlyForArchVar;
our @@ISA=(qw(DefinedListKeyVar));
sub table() { 'OnlyForArch' }
sub keyword_table() { 'Arches' }

package FileVar;
our @@ISA=(qw(SecondaryVar));

sub add
{
	my ($self, $ins) = @@_;
	$self->AnyVar::add($ins);
	open my $file, '<', $self->value or return;
	local $/ = undef;
	$self->add_value($ins, <$file>);
}

sub table() { 'Descr' }

package SharedLibsVar;
our @@ISA=(qw(KeyVar));

sub add
{
	my ($self, $ins) = @@_;
	$self->AnyVar::add($ins);
	my %t = main::words($self->value);
	while (my ($k, $v) = each %t) {
		$self->normal_insert($ins, $self->keyword($ins, $k), $v);
	}
}

sub create_table
{
	my ($self, $inserter) = @@_;
	$self->create_keyword_table($inserter);
	$inserter->make_table($self, "UNIQUE (FULLPKGPATH, LIBNAME)",
	    ValueColumn->new("LIBNAME"),
	    TextColumn->new("VERSION"));
	$inserter->prepare_normal_inserter($self->table, "LIBNAME", "VERSION");
}

sub table()
{
	"Shared_Libs"
}

sub keyword_table() 
{
	return "Library";
}
	
package EmailVar;
our @@ISA=(qw(KeyVar));
sub keyword_table()
{
	return "Email";
}

package YesKeyVar;
our @@ISA=(qw(KeyVar));
sub keyword_table()
{
	return "Keywords2";
}

package AutoVersionVar;
our @@ISA=(qw(OptKeyVar));

sub keyword_table()
{
	return "AutoVersion";
}

package main;

use DBI;

d114 1
@


1.18
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.17 2009/08/25 09:15:43 espie Exp $
d1109 1
d1120 1
d1171 1
d1198 8
a1205 4
	my $v = $vars->{$var}->new($var, $value);
	for my $inserter (@@inserters) {
		$v->add($inserter);
	}
d1212 3
@


1.17
log
@use left join on optional values, otherwise we lose a lot of _ports entries.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.16 2009/08/16 03:24:28 espie Exp $
d385 1
a385 1
	my $v = "CREATE VIEW $name AS SELECT ".join(", ", @@l). " FROM ".$table.join(' ', @@j);
@


1.16
log
@make internals more consistent
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.15 2009/08/15 12:43:58 espie Exp $
d145 1
a145 1
	return " JOIN Paths ".$self->{table}." ON ".$self->table.".ID=$table.".$self->name;
d182 1
a182 1
		return " JOIN ".$self->k." ".$self->table." ON ".$self->table.".KEYREF=$table.".$self->name;
d195 6
d385 1
a385 1
	my $v = "CREATE VIEW $name AS SELECT ".join(", ", @@l). " FROM ".$table.join('', @@j);
@


1.15
log
@start building the _Ports view.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.14 2009/08/14 14:02:11 espie Exp $
d47 8
a155 9
sub new
{
	my ($class, $varclass, $name) = @@_;
	if (!defined $name) {
		$name = $class->default_name;
	}
	bless {name => $name, class => $varclass }, $class;
}

d216 3
d608 6
a613 1
	return OptTextColumn->new($name);
d668 1
a668 1
sub column
d670 1
a670 2
	my ($self, $name) = @@_;
	return ValueColumn->new($self, $name);
d689 1
a689 1
sub column
d691 1
a691 2
	my ($self, $name) = @@_;
	return OptValueColumn->new($self, $name);
d703 1
a703 1
sub column
d705 1
a705 2
	my ($self, $name) = @@_;
	return OptIntegerColumn->new($name);
d811 1
a811 1
	    ValueColumn->new($self));
d839 1
a839 1
	    ValueColumn->new($self));
d861 1
a861 1
sub column
d864 1
a864 1
	return OptTextColumn->new($name);
d915 1
a915 1
sub column
d917 1
a917 2
	my ($self, $name) = @@_;
	return OptValueColumn->new($self, $name);
d996 1
a996 1
	    ValueColumn->new($self),
d1040 1
a1040 1
	    ValueColumn->new($self, "LIBNAME"),
@


1.14
log
@consistent capitalization
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.13 2009/08/14 12:41:56 espie Exp $
d154 7
a160 1
	bless {name => $name, k => $varclass->keyword_table }, $class;
d166 1
a166 1
	return $inserter->value($self->{k}, $self->name);
d172 1
a172 1
	if (defined $self->{k}) {
d182 2
a183 2
	if (defined $self->{k}) {
		return " JOIN ".$self->{k}." ".$self->table." ON ".$self->table.".KEYREF=$table.".$self->name;
d193 1
a193 1
	return $inserter->optvalue($self->{k}, $self->name);
a195 1

d369 14
d390 1
a390 9

	unshift(@@columns, PathColumn->new);
	my $name = "_".$class->table;
	my @@l = map {$_->render_view($class->table) } @@columns;
	my @@j = map {$_->render_join($class->table)} @@columns;
	my $v = "CREATE VIEW $name AS SELECT ".join(", ", @@l). " FROM ".$class->table.join('', @@j);
	$self->db->do("DROP VIEW IF EXISTS $name");
	print "$v\n" if $main::opt_v;
	$self->db->do($v);
d402 1
d405 2
a406 2
			push(@@{$self->{columnlist}}, $class->column($name));
		} 
d411 2
@


1.13
log
@create views for most of the subsidiary tables
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.12 2009/08/14 11:31:37 espie Exp $
d137 1
a137 1
	return " JOIN PATHS ".$self->{table}." ON ".$self->table.".ID=$table.".$self->name;
d339 1
a339 1
	return "$name INTEGER NOT NULL REFERENCES PATHS(ID)";
@


1.12
log
@create the ports table in the same way
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.11 2009/08/14 10:45:52 espie Exp $
d59 11
d100 13
d115 1
a115 1
our @@ISA = qw(Column);
d122 6
d134 6
d141 1
a141 1
our @@ISA = qw(Column);
d163 18
d362 18
@


1.11
log
@higher level table creation for individual tables except Ports:
create column objects, and ask the inserter to "render" them.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.10 2009/08/14 09:23:10 espie Exp $
d112 18
d132 2
a133 2
	my ($self, $inserter, $class) = @@_;
	return $inserter->value($class->keyword_table, $self->name);
d136 1
d158 1
a158 1
	my @@l = map {$_->render($self, $class)} @@columns;
d243 4
a246 2
	$self->new_table("Ports", $self->pathref, 
	    (map {$_." ".$vars->{$_}->sqltype($self) } sort @@{$self->{varlist}}), "UNIQUE(FULLPKGPATH)");
d299 1
a299 1
sub key
d301 2
a302 2
	my ($self, $class) = @@_;
	my $k = $class->keyword_table;
d304 1
a304 1
		return "INTEGER NOT NULL REFERENCES $k(KEYREF)";
d306 1
a306 12
		return "TEXT NOT NULL";
	}
}

sub optkey
{
	my ($self, $class) = @@_;
	my $k = $class->keyword_table;
	if (defined $k) {
		return "INTEGER REFERENCES $k(KEYREF)";
	} else {
		return "TEXT";
d321 1
d415 1
d437 7
d517 1
a517 1
sub sqltype
d519 2
a520 1
	return "TEXT";
d575 1
a575 1
sub sqltype
d577 2
a578 2
	my ($self, $inserter) = @@_;
	return $inserter->key($self);
d597 1
a597 1
sub sqltype
d599 2
a600 2
	my ($self, $inserter) = @@_;
	return $inserter->optkey($self);
d612 1
a612 1
sub sqltype
d614 2
a615 1
	return "INTEGER";
a678 5
sub sqltype
{
	return "TEXT";
}

d721 1
a721 1
	    ValueColumn->new);
a729 2
sub sqltype { "TEXT" }

d749 1
a749 1
	    ValueColumn->new);
d771 6
d795 1
a795 1
our @@ISA=(qw(SecondaryVar));
d825 6
d868 1
a868 1
our @@ISA=(qw(ListKeyVar));
d907 1
a907 1
	    ValueColumn->new,
d951 1
a951 1
	    ValueColumn->new("LIBNAME"),
@


1.10
log
@even though sqlite doesn't really care, this fixes the column types and adds
foreign key constraints to all the sql compact stuff.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.9 2008/11/25 18:01:15 espie Exp $
d37 81
d127 1
a127 1
		vars => {}, 
d132 12
d400 2
a406 2
	$self->new_table("Paths", "FULLPKGPATH TEXT NOT NULL PRIMARY KEY", 
	    "PKGPATH TEXT NOT NULL");
d519 1
a519 1
sub create_table
d527 6
d639 6
a644 3
	$inserter->new_table($self->table, $inserter->pathref, 
	    "FULLDEPENDS TEXT NOT NULL", "PKGSPEC TEXT" , "REST TEXT", 
	    $inserter->pathref("DEPENDSPATH"), "TYPE TEXT NOT NULL");
d703 3
a705 4
	$inserter->new_table($self->table, $inserter->pathref, 
	    $inserter->value($self->keyword_table), 
	    "UNIQUE(FULLPKGPATH, VALUE)");
	$self->SUPER::create_table($inserter);
d732 4
a735 3
	$inserter->new_table($self->table, $inserter->pathref, 
	    "N INTEGER", $inserter->value($self->keyword_table), 
	    "UNIQUE(FULLPKGPATH, N, VALUE)");
a736 1
	$self->SUPER::create_table($inserter);
d879 4
a882 5
	# XXX
	$inserter->new_table($self->table, $inserter->pathref, 
	    $inserter->value($self->keyword_table), 
	    "EXTRA TEXT", "UNIQUE(FULLPKGPATH, VALUE)");
	$self->SUPER::create_table($inserter);
d923 4
a926 4
	$inserter->new_table("Shared_Libs", $inserter->pathref, 
	    $inserter->value($self->keyword_table, "LIBNAME"), 
	    "VERSION TEXT NOT NULL", 
	    "UNIQUE (FULLPKGPATH, LIBNAME)");
a927 1
	$self->SUPER::create_table($inserter);
@


1.9
log
@kill oldish wantlib syntax that no longer exists, results in saner wantlib
tables.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.8 2008/10/26 23:42:24 espie Exp $
d131 2
a132 2
	$self->new_table("Ports", $self->pathref." PRIMARY KEY", 
	    map {$_." ".$vars->{$_}->sqltype } sort @@{$self->{varlist}});
d169 36
a204 1
	return "FULLPKGPATH INTEGER NOT NULL";
d212 2
a213 1
	my @@keys;
d216 1
a216 2
		if (!defined( $class->table() )) {
			push(@@keys, $name." ".$class->sqltype);
d218 1
a218 1
		}
a221 2
	$self->new_table("Paths", "ID INTEGER PRIMARY KEY", 
	    "FULLPKGPATH TEXT NOT NULL UNIQUE", "PKGPATH INTEGER");
a306 2
	my @@keys;

a307 1
		push(@@keys, $name." ".$class->sqltype);
d320 20
a339 1
	return "FULLPKGPATH TEXT NOT NULL";
d405 1
a405 1
sub sqltype()
d415 5
a425 1
# by default, there's no separate table
d428 4
a431 5
}

sub keyword_table()
{
	return "Keywords";
d456 1
a456 6
sub sqltype()
{
	return "INTEGER NOT NULL";
}

sub create_table
d459 1
a459 1
	$inserter->create_keyword_table($self->keyword_table);
d478 1
a478 1
sub sqltype()
d480 2
a481 1
	return "INTEGER";
d493 1
a493 1
sub sqltype()
d542 1
a542 1
	    "DEPENDSPATH TEXT NOT NULL", "TYPE TEXT NOT NULL");
d556 1
a556 1
sub sqltype()
d602 2
a603 1
	    "VALUE TEXT NOT NULL", "UNIQUE(FULLPKGPATH, VALUE)");
d610 1
a610 1
	return "Keywords";
d613 1
a613 1
sub sqltype() { "TEXT" }
d632 2
a633 1
	    "N INTEGER", "VALUE TEXT NOT NULL", "UNIQUE(FULLPKGPATH, N, VALUE)");
d668 5
d778 1
d780 3
a782 2
	    "VALUE TEXT NOT NULL", "EXTRA TEXT", "UNIQUE(FULLPKGPATH, VALUE)");
	KeyVar::create_table($self, $inserter);
d824 2
a825 1
	    "LIBNAME TEXT NOT NULL", "VERSION TEXT NOT NULL", 
d943 3
@


1.8
log
@fixes some inheritance issues. Problem noticed by bernd@@
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.7 2008/10/26 15:12:30 espie Exp $
d711 1
a711 1
	if ($value =~ m/^(.*)(\.(?:\>?\=)?\d+\.\d+)$/) {
d713 1
a713 1
	} elsif ($value =~ m/^(.*)(\.(?:\>?\=)?\d+)$/) {
@


1.7
log
@recognize more wrong depends errors
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.6 2008/08/20 21:02:47 espie Exp $
d742 1
a742 1
	$self->SUPER::add($ins);
d756 1
a756 1
	$self->SUPER::add($ins);
@


1.6
log
@style nitpick, no functional changes
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.5 2008/08/19 23:50:54 espie Exp $
d198 1
a198 1
	if ($key eq '') {
d473 4
@


1.5
log
@new version, lots of code refactoring, and a new compact database.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.4 2006/12/27 11:16:10 steven Exp $
d42 7
a48 1
	bless {db => $db, transaction => 0, threshold => $i, vars => {}, done => {} }, $class;
d79 1
a79 1
	return if defined $self->{done}->{$name};
d84 1
a84 1
	$self->{done}->{$name} = 1;
d96 5
a100 1
	$ins->{insert}->{$table} = $ins->prepare("INSERT OR REPLACE INTO $table (".join(', ', @@cols).") VALUES (". join(', ', map {'?'} @@cols).")");
d131 2
a132 1
	$self->new_table("Ports", $self->pathref." PRIMARY KEY", map {$_." ".$vars->{$_}->sqltype } sort @@{$self->{varlist}});
d187 2
a188 1
	$self->new_table("Paths", "ID INTEGER PRIMARY KEY", "FULLPKGPATH TEXT NOT NULL UNIQUE", "PKGPATH INTEGER");
d190 2
a191 1
	$self->{find_pathkey} =  $self->prepare("SELECT ID From Paths WHERE FULLPKGPATH=(?)");
a215 1
		$self->insert_done;
d282 2
a283 1
	$self->new_table("Paths", "FULLPKGPATH TEXT NOT NULL PRIMARY KEY", "PKGPATH TEXT NOT NULL");
a299 1
	$self->insert_done;
a318 1
	my ($self, $t) = @@_;
d473 4
a476 1
		$self->normal_insert($ins, $depends, $ins->find_pathkey($pkgpath2), $ins->convert_depends($self->depends_type), $pkgspec, $rest);
d488 5
a492 2
	$inserter->new_table($self->table, $inserter->pathref, "FULLDEPENDS TEXT NOT NULL", "PKGSPEC TEXT" , "REST TEXT", "DEPENDSPATH TEXT NOT NULL", "TYPE TEXT NOT NULL");
	$inserter->prepare_normal_inserter($self->table, "FULLDEPENDS", "DEPENDSPATH", "TYPE", "PKGSPEC", "REST");
d815 2
a816 1
my $db2 =DBI->connect("dbi:SQLite:dbname=$dbname-compact", '', '', {AutoCommit => 0});
@


1.4
log
@put USE_X11 in the table.

sure espie@@
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.3 2006/11/03 23:26:41 espie Exp $
d25 3
d37 273
d317 16
d335 88
a422 3
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	my $stmt=$db->prepare("UPDATE Ports SET $var=(?) WHERE RowID=(?)");
	$stmt->execute($value, $rowid);
d430 7
a436 2
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	$class->SUPER::add($pkgpath, $db, $var, $value =~ m/^Yes/i ? 1 : undef, $rowid);
d445 3
a447 3
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	return if $value eq '';
	$class->SUPER::add($pkgpath, $db, $var, $value, $rowid);
d455 1
d458 3
a460 3
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	AnyVar->add($pkgpath, $db, $var, $value, $rowid);
	for my $depends (main::words $value) {
d462 1
a462 2
		my $stmt = $db->prepare("INSERT INTO Depends (FULLPKGPATH, FULLDEPENDS, DEPENDSPATH, TYPE) VALUES (?, ?, ?, ?)");
		$stmt->execute($pkgpath, $depends, $pkgpath2, $class->type());
d465 1
a465 1
				$class->addlib($pkgpath, $db, $lib);
d471 8
a478 1
sub addlib
d482 10
d494 1
a494 1
sub type() { 'L' }
d496 1
a496 1
sub addlib
d498 2
a499 2
	my ($class, $pkgpath, $db, $lib) = @@_;
	WantlibVar->addvalue($pkgpath, $db, $lib);
d504 1
a504 1
sub type() { 'R' }
d508 1
a508 1
sub type() { 'B' }
d512 1
a512 1
sub type() { 'Regress' }
d514 1
a514 1
# Stuff that gets stored in another table as well
d516 23
a538 1
sub addvalue
d540 30
a569 3
	my ($class, $pkgpath, $db, $value) = @@_;
	my $stmt = $db->prepare("INSERT OR REPLACE INTO ".$class->table." (FULLPKGPATH, VALUE) VALUES (?, ?)");
	$stmt->execute($pkgpath, $value);
d578 16
a593 4
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	AnyVar->add($pkgpath, $db, $var, $value, $rowid);
	for my $d (main::words $value) {
		$class->addvalue($pkgpath, $db, $d) if $d ne '';
d602 3
a604 3
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	AnyVar->add($pkgpath, $db, $var, $value, $rowid);
	my @@l = (main::words $value);
d615 1
a615 1
		$class->addvalue($pkgpath, $db, $v) if $v ne '';
d619 2
a620 2
package DefinedListVar;
our @@ISA=(qw(ListVar));
d623 3
a625 3
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	return if $value eq '';
	$class->SUPER::add($pkgpath, $db, $var, $value, $rowid);
d629 1
a629 1
our @@ISA=(qw(DefinedListVar));
d632 16
d649 1
a649 1
our @@ISA=(qw(ListVar));
d651 1
d657 7
d665 1
a665 1
our @@ISA=(qw(ListVar));
d667 1
d670 1
a670 1
our @@ISA=(qw(DefinedListVar));
d672 1
d681 7
a687 1
sub addvalue
d689 7
a695 6
	my ($class, $pkgpath, $db, $value) = @@_;
	$class->SUPER::addvalue($pkgpath, $db, $value);
	if ($value =~ m/\.(?:\>?\=)?\d+\.\d+$/) {
		$class->SUPER::addvalue($pkgpath, $db, $`);
	} elsif ($value =~ m/\.(?:\>?\=)?\d+$/) {
		$class->SUPER::addvalue($pkgpath, $db, $`);
d699 16
d720 3
a722 3
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	AnyVar->add($pkgpath, $db, $var, $value, $rowid);
	open my $file, '<', $value or return;
d724 1
a724 1
	$class->addvalue($pkgpath, $db, <$file>);
d730 1
a730 1
our @@ISA=(qw(AnyVar));
d734 3
a736 4
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	$class->SUPER::add($pkgpath, $db, $var, $value, $rowid);
	my $stmt = $db->prepare("INSERT INTO Shared_Libs (FULLPKGPATH, LIBNAME, VERSION) VALUES (?, ?, ?)");
	my %t = main::words($value);
d738 1
a738 1
		$stmt->execute($pkgpath, $k, $v);
d742 41
d788 1
d795 1
d798 5
d804 2
a805 2
    AUTOCONF_VERSION => 'AnyVar',
    AUTOMAKE_VERSION => 'AnyVar',
a812 1
    PACKAGING => 'AnyVar',
d821 12
a832 12
    MAINTAINER=> 'AnyVar',
    MASTER_SITES => 'AnyVar',
    MASTER_SITES0 => 'AnyVar',
    MASTER_SITES1 => 'AnyVar',
    MASTER_SITES2 => 'AnyVar',
    MASTER_SITES3 => 'AnyVar',
    MASTER_SITES4=> 'AnyVar',
    MASTER_SITES5 => 'AnyVar',
    MASTER_SITES6 => 'AnyVar',
    MASTER_SITES7 => 'AnyVar',
    MASTER_SITES8 => 'AnyVar',
    MASTER_SITES9=> 'AnyVar',
d837 6
a842 6
    ONLY_FOR_ARCHS => 'AnyVar',
    PACKAGES => 'AnyVar',
    PERMIT_DISTFILES_CDROM => 'AnyVar',
    PERMIT_DISTFILES_FTP=> 'AnyVar',
    PERMIT_PACKAGE_CDROM => 'AnyVar',
    PERMIT_PACKAGE_FTP=> 'AnyVar',
d844 2
a845 2
    PKG_ARCH => 'AnyVar',
    PSEUDO_FLAVORS => 'DefinedVar',
d849 1
a849 1
    SEPARATE_BUILD => 'AnyVar',
d861 3
a863 1
# create the various tables, dropping old versions
a864 23
for my $t (qw(Categories Flavors Multi Modules Configure ConfigureArgs Wantlib)) {
    $db->do("DROP TABLE IF EXISTS $t");
    $db->do("CREATE TABLE $t (FULLPKGPATH TEXT NOT NULL, VALUE TEXT NOT NULL, UNIQUE(FULLPKGPATH, VALUE))");
}
$db->do("DROP TABLE IF EXISTS Depends");
$db->do("CREATE TABLE Depends (FULLPKGPATH TEXT NOT NULL, FULLDEPENDS TEXT NOT NULL, DEPENDSPATH TEXT NOT NULL, TYPE TEXT NOT NULL)");
$db->do("DROP TABLE IF EXISTS Shared_Libs");
$db->do("CREATE TABLE Shared_Libs (FULLPKGPATH TEXT NOT NULL, LIBNAME TEXT NOT NULL, VERSION TEXT NOT NULL, UNIQUE (FULLPKGPATH, LIBNAME))");
$db->do("DROP TABLE IF EXISTS Ports");
$db->do("CREATE TABLE Ports (FULLPKGPATH TEXT NOT NULL PRIMARY KEY, ".
	join(',', (map {$_." TEXT"} (keys %$vars))).")");
$db->do("DROP TABLE IF EXISTS Paths");
$db->do("CREATE TABLE Paths (FULLPKGPATH TEXT NOT NULL PRIMARY KEY, PKGPATH TEXT NOT NULL)");
$db->do("DROP TABLE IF EXISTS Descr");
$db->do("CREATE TABLE Descr (FULLPKGPATH TEXT NOT NULL PRIMARY KEY, VALUE TEXT NOT NULL)");
$db->commit();

my $stmt = $db->prepare("SELECT RowID FROM Ports WHERE FULLPKGPATH=(?)");
my $stmt2= $db->prepare("INSERT INTO Ports (FULLPKGPATH) VALUES (?)");
my $stmt3= $db->prepare("INSERT INTO Paths (FULLPKGPATH, PKGPATH) VALUES (?, ?)");

my $i = 0;
my $rowid;
d870 1
a870 1
		print $_, "\n";
d882 7
a888 11
		# get rowid for existing value
		$stmt->execute($key);
		my $z = $stmt->fetchall_arrayref;
		if (@@$z == 0) {
			# if none, we create one
			$stmt2->execute($key);
			my $path = $key;
			$path =~ s/\,.*//;
			$stmt3->execute($key, $path);
			$stmt->execute($key);
			$z = $stmt->fetchall_arrayref;
a889 1
		$rowid = $z->[0]->[0];
d892 3
a894 6
	$vars->{$var}->add($key, $db, $var, $value, $rowid);

	# and we commit just once every 1000 transactions, for efficiency
	$i++;
	if ($i % 1000 == 0) {
		$db->commit();
d897 4
a900 1
$db->commit();
@


1.3
log
@optimize table structure, idea from Martynas Venckus
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.2 2006/11/03 23:03:09 espie Exp $
d302 1
@


1.2
log
@use DROP IF EXISTS (from Martynas Venckus)

fix WANTLIB, regexp to strip version was totally wrong...

(more to come)
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.1 2006/10/15 09:41:44 espie Exp $
d307 1
a307 1
for my $t (qw(Categories Flavors Multi Modules Configure ConfigureArgs Wantlib Descr)) {
d316 1
a316 1
$db->do("CREATE TABLE Ports (FULLPKGPATH TEXT PRIMARY KEY, ".
d319 3
a321 1
$db->do("CREATE TABLE Paths (FULLPKGPATH TEXT PRIMARY KEY, PKGPATH TEXT NOT NULL)");
@


1.1
log
@move mksqlitedb in the port that uses it.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.15 2006/10/14 09:03:23 espie Exp $
d199 1
a199 1
	if ($value =~ m/\(\>?\=\)?\.\d+\.\d+$/) {
d201 1
a201 1
	} elsif ($value =~ m/\(\>?\=\)?\.\d+$/) {
d308 1
a308 1
    $db->do("DROP TABLE $t");
d311 1
a311 1
$db->do("DROP TABLE Depends");
d313 1
a313 1
$db->do("DROP TABLE Shared_Libs");
d315 1
a315 1
$db->do("DROP TABLE Ports");
d318 1
a318 1
$db->do("DROP TABLE Paths");
@

