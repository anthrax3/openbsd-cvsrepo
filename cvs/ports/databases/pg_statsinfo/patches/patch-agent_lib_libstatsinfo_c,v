head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.4
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.2
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.2.0.4
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.6
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.1.1.1.0.4
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	landry_20131023:1.1.1.1
	landry:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2016.12.18.18.21.03;	author jeremy;	state Exp;
branches;
next	1.3;
commitid	kuFDkGwD3nOLmEyK;

1.3
date	2016.05.13.22.09.21;	author landry;	state Exp;
branches;
next	1.2;
commitid	FIw2mHfYDpYa5Dl8;

1.2
date	2014.12.26.12.56.56;	author landry;	state Exp;
branches;
next	1.1;
commitid	ISo6B3lvWFaDGMU8;

1.1
date	2013.10.23.22.00.19;	author landry;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.10.23.22.00.19;	author landry;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update patch to work on PostgreSQL 9.6

OK pea@@ landry@@
@
text
@$OpenBSD: patch-agent_lib_libstatsinfo_c,v 1.3 2016/05/13 22:09:21 landry Exp $
--- agent/lib/libstatsinfo.c.orig	Fri Feb 12 01:49:13 2016
+++ agent/lib/libstatsinfo.c	Tue Nov  1 04:48:05 2016
@@@@ -476,6 +476,7 @@@@ sample_activity(void)
 	int			waiting;
 	int			running;
 	int			i;
+	volatile PGPROC *proc = MyProc;
 
 	if (!long_xacts)
 	{
@@@@ -515,7 +516,7 @@@@ sample_activity(void)
 		 */
 		if (be->st_procpid == MyProcPid)
 			;	/* exclude myself */
-		else if (be->st_waiting)
+		else if (proc->wait_event_info)
 			waiting++;
 #if PG_VERSION_NUM >= 90200
 		else if (be->st_state == STATE_IDLE)
@@@@ -1693,9 +1694,11 @@@@ statsinfo_restart(PG_FUNCTION_ARGS)
 #define NUM_STAT_FIELDS_MIN		6
 
 /* not support a kernel that does not have the required fields at "/proc/stat" */
+#if defined(__linux__)
 #if !LINUX_VERSION_AT_LEAST(2,5,41)
 #error kernel version 2.5.41 or later is required
 #endif
+#endif
 
 /*
  * statsinfo_cpustats - get cpu information
@@@@ -1734,6 +1737,7 @@@@ statsinfo_cpustats_noarg(PG_FUNCTION_ARGS)
 	PG_RETURN_DATUM(get_cpustats(fcinfo, 0, 0, 0, 0));
 }
 
+#ifdef __OpenBSD__
 static Datum
 get_cpustats(FunctionCallInfo fcinfo,
 			 int64 prev_cpu_user,
@@@@ -1746,6 +1750,59 @@@@ get_cpustats(FunctionCallInfo fcinfo,
 	int64			 cpu_system;
 	int64			 cpu_idle;
 	int64			 cpu_iowait;
+	HeapTuple		 tuple;
+	Datum			 values[NUM_CPUSTATS_COLS];
+	bool			 nulls[NUM_CPUSTATS_COLS];
+	long			 cp_time[CPUSTATES];
+	char			 errbuf[_POSIX2_LINE_MAX];
+	int			 mib[] = {CTL_KERN, KERN_CPTIME};
+	size_t			 size = sizeof( cp_time );
+
+	must_be_superuser();
+
+	/* Build a tuple descriptor for our result type */
+	if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
+		elog(ERROR, "return type must be a row type");
+
+	Assert(tupdesc->natts == lengthof(values));
+
+	if (sysctl(mib, 2, &cp_time, &size, NULL, 0) < 0)
+		elog(ERROR,"failed to get kern.cptime");
+
+	memset(nulls, 0, sizeof(nulls));
+	memset(values, 0, sizeof(values));
+
+	cpu_user = cp_time[CP_USER] + cp_time[CP_IDLE];
+	cpu_system = cp_time[CP_SYS];
+	cpu_idle = cp_time[CP_IDLE];
+	cpu_iowait = cp_time[CP_INTR];
+
+	values[0] = CStringGetTextDatum((char *)"cpu");
+	values[1] = Int64GetDatum(cpu_user);
+	values[2] = Int64GetDatum(cpu_system);
+	values[3] = Int64GetDatum(cpu_idle);
+	values[4] = Int64GetDatum(cpu_iowait);
+	values[5] = Int16GetDatum(cpu_user < prev_cpu_user ? 1 : 0);
+	values[6] = Int16GetDatum(cpu_system < prev_cpu_system ? 1 : 0);
+	values[7] = Int16GetDatum(cpu_idle < prev_cpu_idle ? 1 : 0);
+	values[8] = Int16GetDatum(cpu_iowait < prev_cpu_iowait ? 1 : 0);
+
+	tuple = heap_form_tuple(tupdesc, values, nulls);
+	return HeapTupleGetDatum(tuple);
+}
+#else
+static Datum
+get_cpustats(FunctionCallInfo fcinfo,
+			 int64 prev_cpu_user,
+			 int64 prev_cpu_system,
+			 int64 prev_cpu_idle,
+			 int64 prev_cpu_iowait)
+{
+	TupleDesc		 tupdesc;
+	int64			 cpu_user;
+	int64			 cpu_system;
+	int64			 cpu_idle;
+	int64			 cpu_iowait;
 	List			*records = NIL;
 	List			*fields = NIL;
 	HeapTuple		 tuple;
@@@@ -1818,6 +1875,7 @@@@ get_cpustats(FunctionCallInfo fcinfo,
 
 	return HeapTupleGetDatum(tuple);
 }
+#endif
 
 #define NUM_DEVICESTATS_COLS			17
 #define TYPE_DEVICE_TABLESPACES			TEXTOID
@@@@ -1991,10 +2049,46 @@@@ statsinfo_devicestats(PG_FUNCTION_ARGS)
 /*
  * statsinfo_loadavg - get loadavg information
  */
+#if defined(__OpenBSD__)
 Datum
 statsinfo_loadavg(PG_FUNCTION_ARGS)
 {
 	TupleDesc	tupdesc;
+	HeapTuple	tuple;
+	Datum		values[NUM_LOADAVG_COLS];
+	bool		nulls[NUM_LOADAVG_COLS];
+	char		errbuf[_POSIX2_LINE_MAX];
+	struct loadavg	load;
+	int		 mib[] = {CTL_VM, VM_LOADAVG};
+	size_t		 size = sizeof( load );
+
+	must_be_superuser();
+
+	/* Build a tuple descriptor for our result type */
+	if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
+		elog(ERROR, "return type must be a row type");
+
+	Assert(tupdesc->natts == lengthof(values));
+
+	if (sysctl(mib, 2, &load, &size, NULL, 0) < 0)
+		elog(ERROR,"failed to get vm.loadavg");
+
+	memset(nulls, 0, sizeof(nulls));
+	memset(values, 0, sizeof(values));
+
+	values[0] = Float4GetDatum(load.ldavg[0]);
+	values[1] = Float4GetDatum(load.ldavg[1]);
+	values[2] = Float4GetDatum(load.ldavg[2]);
+
+	tuple = heap_form_tuple(tupdesc, values, nulls);
+
+	return HeapTupleGetDatum(tuple);
+}
+#else
+Datum
+statsinfo_loadavg(PG_FUNCTION_ARGS)
+{
+	TupleDesc	tupdesc;
 	int			fd;
 	char		buffer[256];
 	int			nbytes;
@@@@ -2053,6 +2147,7 @@@@ statsinfo_loadavg(PG_FUNCTION_ARGS)
 
 	return HeapTupleGetDatum(tuple);
 }
+#endif
 
 #define FILE_MEMINFO		"/proc/meminfo"
 #define NUM_MEMORY_COLS		5
@@@@ -2072,6 +2167,7 @@@@ compare_meminfo_table(const void *a, const void *b)
 /*
  * statsinfo_memory - get memory information
  */
+#if defined(__OpenBSD__)
 Datum
 statsinfo_memory(PG_FUNCTION_ARGS)
 {
@@@@ -2079,6 +2175,36 @@@@ statsinfo_memory(PG_FUNCTION_ARGS)
 	HeapTuple		 tuple;
 	Datum			 values[NUM_MEMORY_COLS];
 	bool			 nulls[NUM_MEMORY_COLS];
+
+	must_be_superuser();
+
+	/* Build a tuple descriptor for our result type */
+	if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
+		elog(ERROR, "return type must be a row type");
+
+	Assert(tupdesc->natts == lengthof(values));
+
+	memset(nulls, 0, sizeof(nulls));
+	memset(values, 0, sizeof(values));
+
+	values[0] = Int64GetDatum(0);
+	values[1] = Int64GetDatum(0);
+	values[2] = Int64GetDatum(0);
+	values[3] = Int64GetDatum(0);
+	values[4] = Int64GetDatum(0);
+
+	tuple = heap_form_tuple(tupdesc, values, nulls);
+
+	return HeapTupleGetDatum(tuple);
+}
+#else
+Datum
+statsinfo_memory(PG_FUNCTION_ARGS)
+{
+	TupleDesc		 tupdesc;
+	HeapTuple		 tuple;
+	Datum			 values[NUM_MEMORY_COLS];
+	bool			 nulls[NUM_MEMORY_COLS];
 	int				 fd;
 	char			 buffer[2048];
 	int				 nbytes;
@@@@ -2177,6 +2303,7 @@@@ nextline:
 
 	return HeapTupleGetDatum(tuple);
 }
+#endif
 
 #define FILE_PROFILE		"/proc/systemtap/statsinfo_prof/profile"
 #define NUM_PROFILE_COLS	3
@@@@ -2185,9 +2312,16 @@@@ nextline:
 /*
  * statsinfo_profile - get profile information
  */
+#if defined(__OpenBSD__)
 Datum
 statsinfo_profile(PG_FUNCTION_ARGS)
 {
+	PG_RETURN_VOID();
+}
+#else
+Datum
+statsinfo_profile(PG_FUNCTION_ARGS)
+{
 	ReturnSetInfo	*rsinfo = (ReturnSetInfo *) fcinfo->resultinfo;
 	TupleDesc		 tupdesc;
 	Tuplestorestate	*tupstore;
@@@@ -2294,6 +2428,7 @@@@ statsinfo_profile(PG_FUNCTION_ARGS)
 
 	PG_RETURN_VOID();
 }
+#endif
 
 static bool
 checked_write(int fd, const void *buf, int size)
@


1.3
log
@Unbreak by updating to pg_statsinfo 3.2.1.

Project moved to sourceforge, see http://pgstatsinfo.sourceforge.net/
Basic testing seems to show it works fine with postgres 9.5.
@
text
@d1 21
a21 4
$OpenBSD$
--- agent/lib/libstatsinfo.c.orig	Fri Feb 12 10:49:13 2016
+++ agent/lib/libstatsinfo.c	Fri May 13 23:34:34 2016
@@@@ -1693,9 +1693,11 @@@@ statsinfo_restart(PG_FUNCTION_ARGS)
d33 1
a33 1
@@@@ -1734,6 +1736,7 @@@@ statsinfo_cpustats_noarg(PG_FUNCTION_ARGS)
d41 1
a41 1
@@@@ -1746,6 +1749,59 @@@@ get_cpustats(FunctionCallInfo fcinfo,
d101 1
a101 1
@@@@ -1818,6 +1874,7 @@@@ get_cpustats(FunctionCallInfo fcinfo,
d109 1
a109 1
@@@@ -1991,10 +2048,46 @@@@ statsinfo_devicestats(PG_FUNCTION_ARGS)
d156 1
a156 1
@@@@ -2053,6 +2146,7 @@@@ statsinfo_loadavg(PG_FUNCTION_ARGS)
d164 1
a164 1
@@@@ -2072,6 +2166,7 @@@@ compare_meminfo_table(const void *a, const void *b)
d172 1
a172 1
@@@@ -2079,6 +2174,36 @@@@ statsinfo_memory(PG_FUNCTION_ARGS)
d209 1
a209 1
@@@@ -2177,6 +2302,7 @@@@ nextline:
d217 1
a217 1
@@@@ -2185,9 +2311,16 @@@@ nextline:
d234 1
a234 1
@@@@ -2294,6 +2427,7 @@@@ statsinfo_profile(PG_FUNCTION_ARGS)
@


1.2
log
@Use SnapshotAny instead of SnapshotNow, that API was removed in 9.4.
Maybe does something horrific to your data, but that code is really horrible.
Upgrading to 2.5.3 is an option, but uncovers more horrible parts.
@
text
@d1 4
a4 24
$OpenBSD: patch-agent_lib_libstatsinfo_c,v 1.1.1.1 2013/10/23 22:00:19 landry Exp $
freebsd-ports/databases/pg_statsinfo/files/patch-libstatsinfo.c
--- agent/lib/libstatsinfo.c.orig	Mon Nov 26 03:21:03 2012
+++ agent/lib/libstatsinfo.c	Fri Dec 26 13:54:46 2014
@@@@ -50,9 +50,17 @@@@
 #include "pgut/pgut-spi.h"
 #include "../common.h"
 
-#ifndef WIN32
+#if !defined(WIN32)
+#if defined(__OpenBSD__)
+#include <sys/sched.h>
+#include <sys/resource.h>
+#include <sys/sysctl.h>
+#include <paths.h>
+#include <kvm.h>
+#else
 #include "linux/version.h"
 #endif
+#endif
 
 /* also adjust non-critial setting parameters? */
 /* #define ADJUST_NON_CRITICAL_SETTINGS */
@@@@ -1114,9 +1122,11 @@@@ statsinfo_restart(PG_FUNCTION_ARGS)
d8 2
a9 2
+#if !defined(__OpenBSD__)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,41)
d16 1
a16 1
@@@@ -1155,6 +1165,7 @@@@ statsinfo_cpustats_noarg(PG_FUNCTION_ARGS)
d24 1
a24 1
@@@@ -1167,6 +1178,59 @@@@ get_cpustats(FunctionCallInfo fcinfo,
d84 1
a84 1
@@@@ -1239,6 +1303,7 @@@@ get_cpustats(FunctionCallInfo fcinfo,
d90 3
a92 94
 /*
  * statsinfo_devicestats - get device information
@@@@ -1333,11 +1398,14 @@@@ get_devicestats(FunctionCallInfo fcinfo, ArrayType *de
 
 	for (row = 0; row < SPI_processed; row++)
 	{
+#if !defined(__OpenBSD__)
 		HeapTupleHeader prev_devicestats;
+#endif
 		char *device;
 		char *spcname;
 		char *dev_major;
 		char *dev_minor;
+#if !defined(__OpenBSD__)
 		char *dev_name = NULL;
 		int64 readsector;
 		int64 readtime;
@@@@ -1346,14 +1414,18 @@@@ get_devicestats(FunctionCallInfo fcinfo, ArrayType *de
 		int64 ioqueue;
 		int64 iototaltime;
 		char *record;
+#endif
 		char  regex[64];
 		List *devicenum = NIL;
+#if !defined(__OpenBSD__)
 		List *records = NIL;
 		List *fields = NIL;
 		int   nfield;
+#endif
 
 		device = SPI_getvalue(tuptable->vals[row], tuptable->tupdesc, 1);
 		spcname = SPI_getvalue(tuptable->vals[row], tuptable->tupdesc, 2);
+		elog(LOG, "device:%s, spc:%s\n", device, spcname);
 
 		if (prev_device)
 		{
@@@@ -1375,6 +1447,7 @@@@ get_devicestats(FunctionCallInfo fcinfo, ArrayType *de
 
 		snprintf(regex, lengthof(regex), "^\\s*%s\\s+%s\\s+", dev_major, dev_minor);
 
+#if !defined(__OpenBSD__)
 		/* extract device information */
 		if (exec_grep(FILE_DISKSTATS, regex, &records) <= 0)
 		{
@@@@ -1389,11 +1462,24 @@@@ get_devicestats(FunctionCallInfo fcinfo, ArrayType *de
 		record = b_trim((char *) list_nth(records, 0));
 
 		nfield = exec_split(record, "\\s+", &fields);
+#endif
 
 		memset(nulls, 0, sizeof(nulls));
 		memset(values, 0, sizeof(values));
 		spclist = list_truncate(spclist, 0);
 
+#if defined(__OpenBSD__)
+		values[0] = CStringGetTextDatum("");
+		values[1] = CStringGetTextDatum("");
+		values[2] = CStringGetTextDatum("");
+		values[2] = Int64GetDatum(0);
+		values[3] = Int64GetDatum(0);
+		values[4] = Int64GetDatum(0);
+		values[5] = Int64GetDatum(0);
+		values[6] = Int64GetDatum(0);
+		values[7] = Int64GetDatum(0);
+		values[8] = Int64GetDatum(0);
+#else
 		if (nfield  == NUM_DISKSTATS_FIELDS)
 		{
 			/* device_major */
@@@@ -1467,7 +1553,15 @@@@ get_devicestats(FunctionCallInfo fcinfo, ArrayType *de
 				(errcode(ERRCODE_DATA_EXCEPTION),
 				 errmsg("unexpected file format: \"%s\"", FILE_DISKSTATS),
 				 errdetail("number of fields is not corresponding")));
+#endif
 
+#if defined(__OpenBSD__)
+		values[9] = Int16GetDatum(0);
+		values[10] = Int16GetDatum(0);
+		values[11] = Int16GetDatum(0);
+		values[12] = Int16GetDatum(0);
+		values[13] = Int16GetDatum(0);
+#else
 		/* set the overflow flag if value is smaller than previous value */
 		prev_devicestats = search_devicestats(devicestats, dev_name);
 
@@@@ -1536,6 +1630,7 @@@@ get_devicestats(FunctionCallInfo fcinfo, ArrayType *de
 
 		spclist = lappend(spclist, spcname);
 		prev_device = device;
+#endif
 	}
 
 	/* store the last tuple */
@@@@ -1560,10 +1655,46 @@@@ get_devicestats(FunctionCallInfo fcinfo, ArrayType *de
d139 1
a139 1
@@@@ -1622,6 +1753,7 @@@@ statsinfo_loadavg(PG_FUNCTION_ARGS)
d147 1
a147 1
@@@@ -1641,6 +1773,7 @@@@ compare_meminfo_table(const void *a, const void *b)
d155 1
a155 1
@@@@ -1648,6 +1781,36 @@@@ statsinfo_memory(PG_FUNCTION_ARGS)
d192 1
a192 1
@@@@ -1746,6 +1909,7 @@@@ nextline:
d200 1
a200 1
@@@@ -1754,9 +1918,16 @@@@ nextline:
d217 1
a217 1
@@@@ -1863,6 +2034,7 @@@@ statsinfo_profile(PG_FUNCTION_ARGS)
d223 1
a223 1
 static void
a224 9
@@@@ -2226,7 +2398,7 @@@@ statsinfo_tablespaces(PG_FUNCTION_ARGS)
 
 	relation = heap_open(TableSpaceRelationId, AccessShareLock);
 
-	scan = heap_beginscan(relation, SnapshotNow, 0, NULL);
+	scan = heap_beginscan(relation, SnapshotAny, 0, NULL);
 	while ((tuple = heap_getnext(scan, ForwardScanDirection)) != NULL)
 	{
 		Form_pg_tablespace form = (Form_pg_tablespace) GETSTRUCT(tuple);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
d4 1
a4 1
+++ agent/lib/libstatsinfo.c	Sun Aug 11 11:44:42 2013
d336 9
@


1.1.1.1
log
@Import pg_statsinfo-2.4.1.

pg_statsinfo is a utility that monitor statistics and the activity of
PostgreSQL(and OS). pg_statsinfo gets some statistics information as
snapshot. We can check the DB activity and bottleneck analysis by using
these snapshot information. This utility provides some function to get
the information acquisition easily.

Low-level os monitoring (cpu/loadavg/memory only for now) tweaked from
a patch in FreeBSD's portstree.
Refer to ${HOMEPAGE} for how to configure it, no need to replicate the
provided extensive doc in a README.

ok ajacoutot@@
@
text
@@
