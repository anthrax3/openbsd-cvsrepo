head	1.3;
access;
symbols
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_2:1.1.0.4
	OPENBSD_3_3:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2004.06.24.21.35.15;	author sturm;	state dead;
branches;
next	1.2;

1.2
date	2003.08.17.23.48.40;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.02.16.03.59;	author brad;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2003.07.02.16.06.52;	author brad;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.08.18.00.01.55;	author brad;	state Exp;
branches;
next	;

1.1.4.1
date	2003.07.02.16.09.06;	author brad;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.08.18.00.04.42;	author brad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@update to unzip 5.51
@
text
@$OpenBSD: patch-unix_unix_c,v 1.2 2003/08/17 23:48:40 brad Exp $
--- unix/unix.c.orig	2002-01-21 17:54:42.000000000 -0500
+++ unix/unix.c	2003-08-17 19:25:19.000000000 -0400
@@@@ -421,7 +421,8 @@@@ int mapname(__G__ renamed)
  */
 {
     char pathcomp[FILNAMSIZ];      /* path-component buffer */
-    char *pp, *cp=(char *)NULL;    /* character pointers */
+    char *pp, *cp=(char *)NULL,    /* character pointers */
+         *dp=(char *)NULL;
     char *lastsemi=(char *)NULL;   /* pointer to last semi-colon in pathcomp */
 #ifdef ACORN_FTYPE_NFS
     char *lastcomma=(char *)NULL;  /* pointer to last comma in pathcomp */
@@@@ -429,6 +430,8 @@@@ int mapname(__G__ renamed)
 #endif
     int quote = FALSE;             /* flags */
     int killed_ddot = FALSE;       /* is set when skipping "../" pathcomp */
+    int killed_qslash = FALSE;     /* is set when skipping "^V/" pathcomp */
+    int snarf_ddot = FALSE;	   /* Is set while scanning for "../" */
     int error = MPN_OK;
     register unsigned workch;      /* hold the character being tested */
 
@@@@ -467,6 +470,18 @@@@ int mapname(__G__ renamed)
     while ((workch = (uch)*cp++) != 0) {
 
         if (quote) {                 /* if character quoted, */
+	    if (pp == pathcomp) {
+		quote = FALSE;
+		if (workch == '.')
+		    /* Oh no you don't... */
+	   	    goto ddot_hack;
+	        if (workch == '/') {
+		    /* We *never* allow quote-slash at the beginning */
+		    killed_qslash = TRUE;
+		    continue;
+		}
+	    }
+		
             *pp++ = (char)workch;    /*  include it literally */
             quote = FALSE;
         } else
@@@@ -481,15 +496,45 @@@@ int mapname(__G__ renamed)
                 break;
 
             case '.':
-                if (pp == pathcomp) {   /* nothing appended yet... */
+                if (pp == pathcomp) {
+ddot_hack:
+		    /* nothing appended yet... */
                     if (*cp == '/') {   /* don't bother appending "./" to */
                         ++cp;           /*  the path: skip behind the '/' */
                         break;
-                    } else if (!uO.ddotflag && *cp == '.' && cp[1] == '/') {
-                        /* "../" dir traversal detected */
-                        cp += 2;        /*  skip over behind the '/' */
-                        killed_ddot = TRUE; /*  set "show message" flag */
-                        break;
+                    } else if (!uO.ddotflag) {
+
+			/*
+			 * SECURITY: Skip past control characters if the user
+			 * didn't OK use of absolute pathnames. lhh - this is
+			 * a very quick, ugly, inefficient fix; it traverses
+			 * the WHOLE path, eating up these as it comes to it.
+			 */
+			dp = cp;
+			do {
+			    workch = (uch)(*dp);
+			    if (workch == '/' && snarf_ddot) {
+                                /* "../" dir traversal detected */
+                                cp = dp + 1;      /* skip past the '/' */
+                                killed_ddot = TRUE; /* set "show msg" flag */
+                                break;
+                            } else if (workch == '.' && !snarf_ddot) {
+				snarf_ddot = TRUE;
+                	    } else if (isprint(workch) ||
+				       ((workch > 127) && (workch <= 254))) {
+				/*
+				 * Since we found a printable, non-ctrl char,
+				 * we can stop looking for '../', the amount
+				 * in ../!
+				 */
+			        break;
+			    }
+
+			    dp++;
+                        } while (*dp != 0);
+
+			if (killed_ddot)
+			    break;
                     }
                 }
                 *pp++ = '.';
@@@@ -534,6 +579,16 @@@@ int mapname(__G__ renamed)
             error = (error & MPN_MASK) | PK_WARN;
     }
 
+    /* Show warning when stripping insecure quoted-slash at beginning of
+       path components */
+    if (killed_qslash && QCOND2) {
+        Info(slide, 0, ((char *)slide,
+          "warning:  skipped root directory component(s) in %s\n",
+          FnFilter1(G.filename)));
+        if (!(error & ~MPN_MASK))
+            error = (error & MPN_MASK) | PK_WARN;
+    }
+
 /*---------------------------------------------------------------------------
     Report if directory was created (and no file to create:  filename ended
     in '/'), check name to be sure it exists, and combine path and name be-
@


1.2
log
@Improvement on the existing directory traversal patch, fixes the case
where the path component includes a quoted slash.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1
log
@Another directory traversal issue in unzip 5.50 and earlier. Similar to
the first except this issue is triggered by prefixing the .. sequence with
certain non-printable characters which are filtered out resulting in just
the .. sequence.
@
text
@d2 2
a3 2
--- unix/unix.c.orig	Mon Jan 21 17:54:42 2002
+++ unix/unix.c	Wed Jul  2 11:48:50 2003
d14 1
a14 1
@@@@ -429,6 +430,7 @@@@ int mapname(__G__ renamed)
d18 1
d23 1
a23 1
@@@@ -467,6 +469,9 @@@@ int mapname(__G__ renamed)
d27 12
a38 3
+	    if ((pp == pathcomp) && (workch == '.'))
+		/* Oh no you don't... */
+		goto ddot_hack;
d42 1
a42 1
@@@@ -481,15 +486,44 @@@@ int mapname(__G__ renamed)
d63 2
a64 1
+			 * a very quick, ugly, inefficient fix.
d94 17
@


1.1.4.1
log
@Another directory traversal issue in unzip 5.50 and earlier. Similar to
the first except this issue is triggered by prefixing the .. sequence with
certain non-printable characters which are filtered out resulting in just
the .. sequence.

http://marc.theaimsgroup.com/?l=bugtraq&m=105259038503175&w=2
@
text
@d1 1
a1 1
$OpenBSD: patch-unix_unix_c,v 1.1 2003/07/02 16:03:59 brad Exp $
@


1.1.4.2
log
@MFC:
Improvement on the existing directory traversal patch, fixes the case
where the path component includes a quoted slash.
@
text
@d1 3
a3 3
$OpenBSD: patch-unix_unix_c,v 1.2 2003/08/17 23:48:40 brad Exp $
--- unix/unix.c.orig	2002-01-21 17:54:42.000000000 -0500
+++ unix/unix.c	2003-08-17 19:25:19.000000000 -0400
d14 1
a14 1
@@@@ -429,6 +430,8 @@@@ int mapname(__G__ renamed)
a17 1
+    int killed_qslash = FALSE;     /* is set when skipping "^V/" pathcomp */
d22 1
a22 1
@@@@ -467,6 +470,18 @@@@ int mapname(__G__ renamed)
d26 3
a28 12
+	    if (pp == pathcomp) {
+		quote = FALSE;
+		if (workch == '.')
+		    /* Oh no you don't... */
+	   	    goto ddot_hack;
+	        if (workch == '/') {
+		    /* We *never* allow quote-slash at the beginning */
+		    killed_qslash = TRUE;
+		    continue;
+		}
+	    }
+		
d32 1
a32 1
@@@@ -481,15 +496,45 @@@@ int mapname(__G__ renamed)
d53 1
a53 2
+			 * a very quick, ugly, inefficient fix; it traverses
+			 * the WHOLE path, eating up these as it comes to it.
a82 17
@@@@ -534,6 +579,16 @@@@ int mapname(__G__ renamed)
             error = (error & MPN_MASK) | PK_WARN;
     }
 
+    /* Show warning when stripping insecure quoted-slash at beginning of
+       path components */
+    if (killed_qslash && QCOND2) {
+        Info(slide, 0, ((char *)slide,
+          "warning:  skipped root directory component(s) in %s\n",
+          FnFilter1(G.filename)));
+        if (!(error & ~MPN_MASK))
+            error = (error & MPN_MASK) | PK_WARN;
+    }
+
 /*---------------------------------------------------------------------------
     Report if directory was created (and no file to create:  filename ended
     in '/'), check name to be sure it exists, and combine path and name be-
@


1.1.2.1
log
@Another directory traversal issue in unzip 5.50 and earlier. Similar to
the first except this issue is triggered by prefixing the .. sequence with
certain non-printable characters which are filtered out resulting in just
the .. sequence.

http://marc.theaimsgroup.com/?l=bugtraq&m=105259038503175&w=2
@
text
@d1 1
a1 1
$OpenBSD: patch-unix_unix_c,v 1.1 2003/07/02 16:03:59 brad Exp $
@


1.1.2.2
log
@MFC:
Improvement on the existing directory traversal patch, fixes the case
where the path component includes a quoted slash.
@
text
@d1 3
a3 3
$OpenBSD: patch-unix_unix_c,v 1.2 2003/08/17 23:48:40 brad Exp $
--- unix/unix.c.orig	2002-01-21 17:54:42.000000000 -0500
+++ unix/unix.c	2003-08-17 19:25:19.000000000 -0400
d14 1
a14 1
@@@@ -429,6 +430,8 @@@@ int mapname(__G__ renamed)
a17 1
+    int killed_qslash = FALSE;     /* is set when skipping "^V/" pathcomp */
d22 1
a22 1
@@@@ -467,6 +470,18 @@@@ int mapname(__G__ renamed)
d26 3
a28 12
+	    if (pp == pathcomp) {
+		quote = FALSE;
+		if (workch == '.')
+		    /* Oh no you don't... */
+	   	    goto ddot_hack;
+	        if (workch == '/') {
+		    /* We *never* allow quote-slash at the beginning */
+		    killed_qslash = TRUE;
+		    continue;
+		}
+	    }
+		
d32 1
a32 1
@@@@ -481,15 +496,45 @@@@ int mapname(__G__ renamed)
d53 1
a53 2
+			 * a very quick, ugly, inefficient fix; it traverses
+			 * the WHOLE path, eating up these as it comes to it.
a82 17
@@@@ -534,6 +579,16 @@@@ int mapname(__G__ renamed)
             error = (error & MPN_MASK) | PK_WARN;
     }
 
+    /* Show warning when stripping insecure quoted-slash at beginning of
+       path components */
+    if (killed_qslash && QCOND2) {
+        Info(slide, 0, ((char *)slide,
+          "warning:  skipped root directory component(s) in %s\n",
+          FnFilter1(G.filename)));
+        if (!(error & ~MPN_MASK))
+            error = (error & MPN_MASK) | PK_WARN;
+    }
+
 /*---------------------------------------------------------------------------
     Report if directory was created (and no file to create:  filename ended
     in '/'), check name to be sure it exists, and combine path and name be-
@


