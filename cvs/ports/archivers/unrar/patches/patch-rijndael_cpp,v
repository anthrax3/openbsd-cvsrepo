head	1.4;
access;
symbols
	OPENBSD_6_1:1.3.0.10
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.6
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.4
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2017.06.21.21.19.05;	author naddy;	state Exp;
branches;
next	1.3;
commitid	ZOJP6E8fPhi3bneZ;

1.3
date	2014.09.08.18.54.30;	author naddy;	state Exp;
branches;
next	1.2;
commitid	C44zr3BzpchHfAvL;

1.2
date	2013.09.06.13.28.16;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.08.16.36.12;	author naddy;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Security update to 5.50 beta 4 to fix the VMSF_DELTA filter signedness
error and unspecified other issues.
@
text
@$OpenBSD: patch-rijndael_cpp,v 1.3 2014/09/08 18:54:30 naddy Exp $
Index: rijndael.cpp
--- rijndael.cpp.orig
+++ rijndael.cpp
@@@@ -11,6 +11,8 @@@@
 #include <wmmintrin.h>
 #endif
 
+#ifndef OPENSSL_AES
+
 static byte S[256],S5[256],rcon[30];
 static byte T1[256][4],T2[256][4],T3[256][4],T4[256][4];
 static byte T5[256][4],T6[256][4],T7[256][4],T8[256][4];
@@@@ -56,6 +58,7 @@@@ inline void Copy128(byte *dest,const byte *src)
 #endif
 }
 
+#endif // OPENSSL_AES
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // API
@@@@ -63,14 +66,35 @@@@ inline void Copy128(byte *dest,const byte *src)
 
 Rijndael::Rijndael()
 {
+#ifndef OPENSSL_AES
   if (S[0]==0)
     GenerateTables();
+#endif
   CBCMode = true; // Always true for RAR.
 }
 
 
 void Rijndael::Init(bool Encrypt,const byte *key,uint keyLen,const byte * initVector)
 {
+#ifdef OPENSSL_AES
+  const EVP_CIPHER *cipher;
+  switch(keyLen)
+  {
+    case 128:
+      cipher = EVP_aes_128_cbc();
+      break;
+    case 192:
+      cipher = EVP_aes_192_cbc();
+      break;
+    case 256:
+      cipher = EVP_aes_256_cbc();
+      break;
+  }
+
+  EVP_CIPHER_CTX_init(&ctx);
+  EVP_CipherInit_ex(&ctx, cipher, NULL, key, initVector, Encrypt);
+  EVP_CIPHER_CTX_set_padding(&ctx, 0);
+#else
 #ifdef USE_SSE
   // Check SSE here instead of constructor, so if object is a part of some
   // structure memset'ed before use, this variable is not lost.
@@@@ -111,6 +135,7 @@@@ void Rijndael::Init(bool Encrypt,const byte *key,uint 
 
   if(!Encrypt)
     keyEncToDec();
+#endif // OPENSSL_AES
 }
 
 void Rijndael::blockEncrypt(const byte *input,size_t inputLen,byte *outBuffer)
@@@@ -118,6 +143,11 @@@@ void Rijndael::blockEncrypt(const byte *input,size_t i
   if (inputLen <= 0)
     return;
 
+#ifdef OPENSSL_AES
+  int outLen;
+  EVP_CipherUpdate(&ctx, outBuffer, &outLen, input, inputLen);
+  return;
+#else // OPENSSL_AES
   size_t numBlocks = inputLen/16;
 #ifdef USE_SSE
   if (AES_NI)
@@@@ -176,6 +206,7 @@@@ void Rijndael::blockEncrypt(const byte *input,size_t i
     input += 16;
   }
   Copy128(m_initVector,prevBlock);
+#endif // OPENSSL_AES
 }
 
 
@@@@ -217,6 +248,11 @@@@ void Rijndael::blockDecrypt(const byte *input, size_t 
   if (inputLen <= 0)
     return;
 
+#ifdef OPENSSL_AES
+  int outLen;
+  EVP_CipherUpdate(&ctx, outBuffer, &outLen, input, inputLen);
+  return;
+#else
   size_t numBlocks=inputLen/16;
 #ifdef USE_SSE
   if (AES_NI)
@@@@ -279,6 +315,7 @@@@ void Rijndael::blockDecrypt(const byte *input, size_t 
   }
 
   memcpy(m_initVector,iv,16);
+#endif // OPENSSL_AES
 }
 
 
@@@@ -315,6 +352,7 @@@@ void Rijndael::blockDecryptSSE(const byte *input, size
 #endif
 
 
+#ifndef OPENSSL_AES
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // ALGORITHM
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@@@ -455,6 +493,7 @@@@ void Rijndael::GenerateTables()
   }
 }
 
+#endif // OPENSSL_AES
 
 #if 0
 static void TestRijndael();
@


1.3
log
@update to 5.1.6; specifically tested on sparc64
@
text
@d1 4
a4 3
$OpenBSD: patch-rijndael_cpp,v 1.2 2013/09/06 13:28:16 naddy Exp $
--- rijndael.cpp.orig	Tue Jun 10 19:14:06 2014
+++ rijndael.cpp	Tue Sep  2 22:58:36 2014
d65 20
d86 1
a86 1
@@@@ -120,6 +145,11 @@@@ void Rijndael::blockDecrypt(const byte *input, size_t 
d98 1
a98 1
@@@@ -182,6 +212,7 @@@@ void Rijndael::blockDecrypt(const byte *input, size_t 
d106 1
a106 1
@@@@ -218,6 +249,7 @@@@ void Rijndael::blockDecryptSSE(const byte *input, size
d114 1
a114 1
@@@@ -358,6 +390,7 @@@@ void Rijndael::GenerateTables()
@


1.2
log
@Update to 5.00 and take maintainer.
Multithreading is enabled but doesn't appear to be functional.
@
text
@d1 6
a6 6
$OpenBSD: patch-rijndael_cpp,v 1.1 2012/04/08 16:36:12 naddy Exp $
--- rijndael.cpp.orig	Fri Aug  2 15:30:12 2013
+++ rijndael.cpp	Thu Aug 29 22:58:10 2013
@@@@ -7,6 +7,8 @@@@
  ***************************************************************************/
 #include "rar.hpp"
d13 1
a13 1
@@@@ -52,6 +54,7 @@@@ inline void Copy128(byte *dest,const byte *src)
d21 1
a21 1
@@@@ -59,13 +62,34 @@@@ inline void Copy128(byte *dest,const byte *src)
d29 1
d54 4
a57 4
   uint uKeyLenInBytes;
   switch(keyLen)
   {
@@@@ -95,6 +119,7 @@@@ void Rijndael::Init(bool Encrypt,const byte *key,uint 
d65 3
a67 3
@@@@ -104,6 +129,11 @@@@ size_t Rijndael::blockDecrypt(const byte *input, size_
   if (input == 0 || inputLen <= 0)
     return 0;
d72 1
a72 1
+  return outLen;
d74 5
a78 2
   byte block[16], iv[4][4];
   memcpy(iv,m_initVector,16); 
a79 1
@@@@ -126,9 +156,11 @@@@ size_t Rijndael::blockDecrypt(const byte *input, size_
a80 2
   
   return 16*numBlocks;
d85 4
d93 1
a93 1
@@@@ -310,6 +342,7 @@@@ void Rijndael::GenerateTables()
@


1.1
log
@Use OpenSSL instead of the included AES code to speed up extraction
of encrypted archives.
@
text
@d1 3
a3 3
$OpenBSD$
--- rijndael.cpp.orig	Wed Mar  2 08:43:12 2011
+++ rijndael.cpp	Fri Apr  6 00:32:04 2012
d5 1
a5 1
  **************************************************************************/
d8 1
a8 1
+#ifndef OPENSSL
a9 2
 const int uKeyLenInBytes=16, m_uRounds=10;
 
d11 3
a13 1
@@@@ -54,6 +56,7 @@@@ inline void Copy128(byte *dest,const byte *src)
d17 1
a17 1
+#endif // OPENSSL
d21 1
a21 1
@@@@ -61,13 +64,21 @@@@ inline void Copy128(byte *dest,const byte *src)
d25 1
a25 1
+#ifndef OPENSSL
d32 1
a32 1
 void Rijndael::init(Direction dir,const byte * key,byte * initVector)
d34 15
a48 1
+#ifdef OPENSSL
d50 1
a50 2
+  EVP_CipherInit_ex(&ctx, EVP_aes_128_cbc(), NULL, key, initVector,
+    dir == Decrypt ? 0 : 1);
d53 4
a56 4
   m_direction = dir;
 
   byte keyMatrix[_MAX_KEY_COLUMNS][4];
@@@@ -82,6 +93,7 @@@@ void Rijndael::init(Direction dir,const byte * key,byt
d58 1
a58 1
   if(m_direction == Decrypt)
d60 1
a60 1
+#endif // OPENSSL
d64 1
a64 1
@@@@ -91,6 +103,11 @@@@ size_t Rijndael::blockDecrypt(const byte *input, size_
d68 1
a68 1
+#ifdef OPENSSL
d76 1
a76 1
@@@@ -113,9 +130,11 @@@@ size_t Rijndael::blockDecrypt(const byte *input, size_
d80 1
a80 1
+#endif // OPENSSL
d84 1
a84 1
+#ifndef OPENSSL
d88 1
a88 2
@@@@ -296,3 +315,5 @@@@ void Rijndael::GenerateTables()
     U1[b][0]=U2[b][1]=U3[b][2]=U4[b][3]=T5[i][0]=T6[i][1]=T7[i][2]=T8[i][3]=FFmul0e(b);
d91 5
a95 2
+
+#endif // OPENSSL
@

