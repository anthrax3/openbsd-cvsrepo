head	1.4;
access;
symbols
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_7:1.3.0.2;
locks; strict;
comment	@# @;


1.4
date	2006.11.13.16.25.10;	author naddy;	state dead;
branches;
next	1.3;

1.3
date	2006.02.27.21.29.55;	author naddy;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2004.05.15.12.57.34;	author naddy;	state dead;
branches;
next	1.1;

1.1
date	2004.04.22.02.56.10;	author naddy;	state Exp;
branches;
next	;

1.3.2.1
date	2006.02.28.09.11.52;	author sturm;	state Exp;
branches;
next	;

1.3.4.1
date	2006.02.28.09.12.19;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@update to 1.16
@
text
@$OpenBSD: patch-src_xheader_c,v 1.3 2006/02/27 21:29:55 naddy Exp $
--- src/xheader.c.orig	Mon Sep  6 13:31:14 2004
+++ src/xheader.c	Sun Feb 26 22:08:44 2006
@@@@ -783,6 +783,32 @@@@ code_num (uintmax_t value, char const *k
   xheader_print (xhdr, keyword, sbuf);
 }
 
+static bool
+decode_num (uintmax_t *num, char const *arg, uintmax_t maxval,
+        char const *keyword)
+{
+  uintmax_t u;
+  char *arg_lim;
+
+  if (! (ISDIGIT (*arg)
+     && (errno = 0, u = strtoumax (arg, &arg_lim, 10), !*arg_lim)))
+    {
+      ERROR ((0, 0, _("Malformed extended header: invalid %s=%s"),
+          keyword, arg));
+      return false;
+    }
+
+  if (! (u <= maxval && errno != ERANGE))
+    {
+      ERROR ((0, 0, _("Extended header %s=%s is out of range"),
+        keyword, arg));
+      return false;
+    }
+
+  *num = u;
+  return true;
+}
+
 static void
 dummy_coder (struct tar_stat_info const *st __attribute__ ((unused)),
 	     char const *keyword __attribute__ ((unused)),
@@@@ -821,7 +847,7 @@@@ static void
 gid_decoder (struct tar_stat_info *st, char const *arg)
 {
   uintmax_t u;
-  if (xstrtoumax (arg, NULL, 10, &u, "") == LONGINT_OK)
+  if (decode_num (&u, arg, TYPE_MAXIMUM (gid_t), "gid"))
     st->stat.st_gid = u;
 }
 
@@@@ -903,7 +929,7 @@@@ static void
 size_decoder (struct tar_stat_info *st, char const *arg)
 {
   uintmax_t u;
-  if (xstrtoumax (arg, NULL, 10, &u, "") == LONGINT_OK)
+  if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), "size"))
     st->archive_file_size = st->stat.st_size = u;
 }
 
@@@@ -918,7 +944,7 @@@@ static void
 uid_decoder (struct tar_stat_info *st, char const *arg)
 {
   uintmax_t u;
-  if (xstrtoumax (arg, NULL, 10, &u, "") == LONGINT_OK)
+  if (decode_num (&u, arg, TYPE_MAXIMUM (uid_t), "uid"))
     st->stat.st_uid = u;
 }
 
@@@@ -946,7 +972,7 @@@@ static void
 sparse_size_decoder (struct tar_stat_info *st, char const *arg)
 {
   uintmax_t u;
-  if (xstrtoumax (arg, NULL, 10, &u, "") == LONGINT_OK)
+  if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), "GNU.sparse.size"))
     st->stat.st_size = u;
 }
 
@@@@ -962,10 +988,10 @@@@ static void
 sparse_numblocks_decoder (struct tar_stat_info *st, char const *arg)
 {
   uintmax_t u;
-  if (xstrtoumax (arg, NULL, 10, &u, "") == LONGINT_OK)
+  if (decode_num (&u, arg, SIZE_MAX, "GNU.sparse.numblocks"))
     {
       st->sparse_map_size = u;
-      st->sparse_map = calloc(st->sparse_map_size, sizeof(st->sparse_map[0]));
+      st->sparse_map = xcalloc (u, sizeof st->sparse_map[0]);
       st->sparse_map_avail = 0;
     }
 }
@@@@ -982,8 +1008,14 @@@@ static void
 sparse_offset_decoder (struct tar_stat_info *st, char const *arg)
 {
   uintmax_t u;
-  if (xstrtoumax (arg, NULL, 10, &u, "") == LONGINT_OK)
+  if (decode_num (&u, arg, TYPE_MAXIMUM (off_t), "GNU.sparse.offset"))
+    {
+      if (st->sparse_map_avail < st->sparse_map_size)
     st->sparse_map[st->sparse_map_avail].offset = u;
+      else
+    ERROR ((0, 0, _("Malformed extended header: excess %s=%s"),
+        "GNU.sparse.offset", arg));
+    }
 }
 
 static void
@@@@ -998,15 +1030,13 @@@@ static void
 sparse_numbytes_decoder (struct tar_stat_info *st, char const *arg)
 {
   uintmax_t u;
-  if (xstrtoumax (arg, NULL, 10, &u, "") == LONGINT_OK)
+  if (decode_num (&u, arg, SIZE_MAX, "GNU.sparse.numbytes"))
     {
       if (st->sparse_map_avail == st->sparse_map_size)
-	{
-	  st->sparse_map_size *= 2;
-	  st->sparse_map = xrealloc (st->sparse_map,
-				     st->sparse_map_size
-				     * sizeof st->sparse_map[0]);
-	}
+        st->sparse_map = x2nrealloc (st->sparse_map,
+                                    &st->sparse_map_size,
+                                    sizeof st->sparse_map[0]);
+
       st->sparse_map[st->sparse_map_avail++].numbytes = u;
     }
 }
@


1.3
log
@SECURITY:
A buffer overflow allows user-complicit attackers to cause a denial
of service (application crash) and possibly execute code via
unspecified vectors involving PAX extended headers.
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0300

Fix via Ubuntu (ultimately from upstream CVS).

ok pvalchev@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3.4.1
log
@MFC:
SECURITY:
A buffer overflow allows user-complicit attackers to cause a denial
of service (application crash) and possibly execute code via
unspecified vectors involving PAX extended headers.
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0300

Fix via Ubuntu (ultimately from upstream CVS).
@
text
@d1 1
a1 1
$OpenBSD: patch-src_xheader_c,v 1.3 2006/02/27 21:29:55 naddy Exp $
@


1.3.2.1
log
@MFC:
SECURITY:
A buffer overflow allows user-complicit attackers to cause a denial
of service (application crash) and possibly execute code via
unspecified vectors involving PAX extended headers.
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0300

Fix via Ubuntu (ultimately from upstream CVS).
@
text
@d1 1
a1 1
$OpenBSD: patch-src_xheader_c,v 1.3 2006/02/27 21:29:55 naddy Exp $
@


1.2
log
@update to 1.14
@
text
@d1 6
a6 9
$OpenBSD: patch-src_xheader_c,v 1.1 2004/04/22 02:56:10 naddy Exp $
--- src/xheader.c.orig	2004-04-22 02:25:31.000000000 +0200
+++ src/xheader.c	2004-04-22 02:25:44.000000000 +0200
@@@@ -20,6 +20,7 @@@@
 
 #include <hash.h>
 #include <quotearg.h>
+#include <stpcpy.h>
 #include <xstrtol.h>
d8 115
a122 1
 #include "common.h"
@


1.1
log
@Update to 1.13.94:
- Added support for POSIX.1-2001 and ustar archive formats.
- Various option cleanups.
- New message translations.
- Bug fixes.

Switch to .bz2 distfile since we already depend on bzip2 anyway.
@
text
@d1 1
a1 1
$OpenBSD$
@

