head	1.3;
access;
symbols
	shadchin_20170423:1.1.1.1 shadchin:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2017.07.26.22.45.26;	author sthen;	state Exp;
branches;
next	1.2;
commitid	tD4MFrpYYDDL2UFT;

1.2
date	2017.07.16.19.19.00;	author espie;	state Exp;
branches;
next	1.1;
commitid	tt0GhWK5c4uf9ILG;

1.1
date	2017.04.23.17.45.20;	author shadchin;	state Exp;
branches
	1.1.1.1;
next	;
commitid	A0umrYBSPZ4KjdUp;

1.1.1.1
date	2017.04.23.17.45.20;	author shadchin;	state Exp;
branches;
next	;
commitid	A0umrYBSPZ4KjdUp;


desc
@@


1.3
log
@bump LIBCXX/LIBECXX/COMPILER_LIBCXX ports.
@
text
@# $OpenBSD: Makefile,v 1.2 2017/07/16 19:19:00 espie Exp $

COMMENT =		fast numerical expression evaluator for NumPy

MODPY_EGG_VERSION =	2.6.2
DISTNAME =		numexpr-${MODPY_EGG_VERSION}
PKGNAME =		py-${DISTNAME}
CATEGORIES =		math
REVISION =		0

MAINTAINER =		Alexandr Shadchin <shadchin@@openbsd.org>

# MIT
PERMIT_PACKAGE_CDROM =	Yes

WANTLIB +=		m pthread ${MODPY_WANTLIB} ${COMPILER_LIBCXX}

MODULES =		lang/python

MODPY_PI =		Yes
MODPY_SETUPTOOLS =	Yes

RUN_DEPENDS =		math/py-numpy${MODPY_FLAVOR}
BUILD_DEPENDS =		${RUN_DEPENDS}
TEST_DEPENDS =		${RUN_DEPENDS}

FLAVORS =		python3
FLAVOR ?=

do-test: fake
	PYTHONPATH=${WRKINST}${MODPY_SITEPKG} ${MODPY_BIN} -c \
	    "import numexpr; numexpr.test()"

.include <bsd.port.mk>
@


1.2
log
@use COMPILER_LIBCXX where applicable
@
text
@d1 1
a1 1
# $OpenBSD: Makefile,v 1.1.1.1 2017/04/23 17:45:20 shadchin Exp $
d9 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $OpenBSD$
d15 1
a15 1
WANTLIB +=		m pthread ${MODPY_WANTLIB} ${LIBCXX}
@


1.1.1.1
log
@Import py-numexpr 2.6.2, ok daniel@@

Numexpr is a fast numerical expression evaluator for NumPy. With it,                                                                                                   expressions that operate on arrays (like "3*a+4*b") are accelerated                                                                                                    and use less memory than doing the same calculation in Python.                                                                                                                                                                                                                                                                                In addition, its multi-threaded capabilities can make use of all your                                                                                                  cores, which may accelerate computations, most specially if they are                                                                                                   not memory-bounded (e.g. those using transcendental functions). 
@
text
@@
