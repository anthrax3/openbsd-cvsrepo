head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.18
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.14
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.16
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.12
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.10
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.8
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.6
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.4
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	gsoares_20120412:1.1.1.1
	dhill:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2012.04.12.13.53.03;	author gsoares;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.04.12.13.53.03;	author gsoares;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@@@comment $OpenBSD$
${P5SITE}/Math/
${P5SITE}/Math/Random/
${P5SITE}/Math/Random/ISAAC/
${P5SITE}/Math/Random/ISAAC.pm
${P5SITE}/Math/Random/ISAAC/PP.pm
@@man man/man3p/Math::Random::ISAAC.3p
@@man man/man3p/Math::Random::ISAAC::PP.3p
@


1.1.1.1
log
@Import p5-Math-Random-ISAAC-1.004

The ISAAC algorithm is designed to take some seed information and
produce seemingly random results as output.

However, ISAAC (Indirection, Shift, Accumulate, Add, and Count) has
different goals than other commonly used algorithms. In particular, it's
really fast - on average, it requires only 18.75 machine cycles to
generate a 32-bit value. This makes it suitable for applications where a
significant amount of random data needs to be produced quickly, such
solving using the Monte Carlo method or for games.

with feedback and tweaks by me
committing on behalf of dhill@@

OK sthen@@
@
text
@@
