head	1.3;
access;
symbols
	OPENBSD_5_6:1.2.0.16
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.14
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.12
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.2
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2015.01.06.13.19.05;	author pirofti;	state dead;
branches;
next	1.2;
commitid	usZ8vXLndKnSNZdl;

1.2
date	2010.10.24.22.36.37;	author pirofti;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.07.13.47.44;	author espie;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update GiNaC to 1.6.3

Changes by this update:
	- major libarary bump
	- added doxygen documentation
	- perl scripts switched to python
	- ditched the PFRAG.shared file

Okay sthen@@
@
text
@$OpenBSD: patch-ginac_function_pl,v 1.2 2010/10/24 22:36:37 pirofti Exp $
--- ginac/function.pl.orig	Tue Jul  6 15:39:14 2010
+++ ginac/function.pl	Sun Oct 24 20:37:54 2010
@@@@ -59,7 +59,7 @@@@ sub generate {
 $declare_function_macro = generate(
 	<<'END_OF_DECLARE_FUNCTION_MACRO','typename T${N}','const T${N} & p${N}','GiNaC::ex(p${N})');
 #define DECLARE_FUNCTION_${N}P(NAME) \\
-class NAME##_SERIAL { public: static unsigned serial; }; \\
+class NAME##_SERIAL { public: static serial_t serial; }; \\
 const unsigned NAME##_NPARAMS = ${N}; \\
 template<${SEQ1}> const GiNaC::function NAME(${SEQ2}) { \\
 	return GiNaC::function(NAME##_SERIAL::serial, ${SEQ3}); \\
@@@@ -130,12 +130,12 @@@@ $print_func_interface=generate(
 END_OF_PRINT_FUNC_INTERFACE
 
 $constructors_interface=generate(
-'    function(unsigned ser, ${SEQ1});'."\n",
+'    function(serial_t ser, ${SEQ1});'."\n",
 'const ex & param${N}','','');
 
 $constructors_implementation=generate(
 	<<'END_OF_CONSTRUCTORS_IMPLEMENTATION','const ex & param${N}','param${N}','');
-function::function(unsigned ser, ${SEQ1})
+function::function(serial_t ser, ${SEQ1})
 	: exprseq(${SEQ2}), serial(ser)
 {
 }
@@@@ -318,13 +318,14 @@@@ $interface=<<END_OF_INTERFACE;
 #include <algorithm>
 #include <string>
 #include <vector>
+typedef unsigned long serial_t;
 
 // the following lines have been generated for max. ${maxargs} parameters
 $declare_function_macro
 // end of generated lines
 
 #define REGISTER_FUNCTION(NAME,OPT) \\
-unsigned NAME##_SERIAL::serial = \\
+serial_t NAME##_SERIAL::serial = \\
 	GiNaC::function::register_new(GiNaC::function_options(#NAME, NAME##_NPARAMS).OPT);
 
 namespace GiNaC {
@@@@ -490,13 +491,13 @@@@ class function : public exprseq
 
 	// other constructors
 public:
-	function(unsigned ser);
+	function(serial_t ser);
 	// the following lines have been generated for max. ${maxargs} parameters
 $constructors_interface
 	// end of generated lines
-	function(unsigned ser, const exprseq & es);
-	function(unsigned ser, const exvector & v, bool discardable = false);
-	function(unsigned ser, std::auto_ptr<exvector> vp);
+	function(serial_t ser, const exprseq & es);
+	function(serial_t ser, const exvector & v, bool discardable = false);
+	function(serial_t ser, std::auto_ptr<exvector> vp);
 
 	// functions overriding virtual functions from base classes
 public:
@@@@ -533,16 +534,16 @@@@ $constructors_interface (protected)
 	void store_remember_table(ex const & result) const;
 public:
 	ex power(const ex & exp) const;
-	static unsigned register_new(function_options const & opt);
-	static unsigned current_serial;
-	static unsigned find_function(const std::string &name, unsigned nparams);
-	unsigned get_serial() const {return serial;}
+	static serial_t register_new(function_options const & opt);
+	static serial_t current_serial;
+	static serial_t find_function(const std::string &name, unsigned nparams);
+	serial_t get_serial() const {return serial;}
 	std::string get_name() const;
 
 // member variables
 
 protected:
-	unsigned serial;
+	serial_t serial;
 };
 GINAC_DECLARE_UNARCHIVER(function);
 
@@@@ -803,7 +804,7 @@@@ void function_options::set_print_func(unsigned id, pri
 }
 
 /** This can be used as a hook for external applications. */
-unsigned function::current_serial = 0;
+serial_t function::current_serial = 0;
 
 
 GINAC_IMPLEMENT_REGISTERED_CLASS(function, exprseq)
@@@@ -824,7 +825,7 @@@@ function::function() : serial(0)
 
 // public
 
-function::function(unsigned ser) : serial(ser)
+function::function(serial_t ser) : serial(ser)
 {
 }
 
@@@@ -832,7 +833,7 @@@@ function::function(unsigned ser) : serial(ser)
 $constructors_implementation
 // end of generated lines
 
-function::function(unsigned ser, const exprseq & es) : exprseq(es), serial(ser)
+function::function(serial_t ser, const exprseq & es) : exprseq(es), serial(ser)
 {
 
 	// Force re-evaluation even if the exprseq was already evaluated
@@@@ -840,7 +841,7 @@@@ function::function(unsigned ser, const exprseq & es) :
 	clearflag(status_flags::evaluated);
 }
 
-function::function(unsigned ser, const exvector & v, bool discardable) 
+function::function(serial_t ser, const exvector & v, bool discardable) 
   : exprseq(v,discardable), serial(ser)
 {
 	if ( ser >= registered_functions().size() ) {
@@@@ -848,7 +849,7 @@@@ function::function(unsigned ser, const exvector & v, b
 	}
 }
 
-function::function(unsigned ser, std::auto_ptr<exvector> vp) 
+function::function(serial_t ser, std::auto_ptr<exvector> vp) 
   : exprseq(vp), serial(ser)
 {
 }
@@@@ -1346,7 +1347,7 @@@@ void function::store_remember_table(ex const & result)
 
 // public
 
-unsigned function::register_new(function_options const & opt)
+serial_t function::register_new(function_options const & opt)
 {
 	size_t same_name = 0;
 	for (size_t i=0; i<registered_functions().size(); ++i) {
@@@@ -1375,10 +1376,10 @@@@ unsigned function::register_new(function_options const
 
 /** Find serial number of function by name and number of parameters.
  *  Throws exception if function was not found. */
-unsigned function::find_function(const std::string &name, unsigned nparams)
+serial_t function::find_function(const std::string &name, unsigned nparams)
 {
 	std::vector<function_options>::const_iterator i = function::registered_functions().begin(), end = function::registered_functions().end();
-	unsigned serial = 0;
+	serial_t serial = 0;
 	while (i != end) {
 		if (i->get_name() == name && i->get_nparams() == nparams)
 			return serial;
@


1.2
log
@Update to GiNaC 1.5.8. Okay steven@@.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1
log
@fix for LP64 and gcc4.
still passes all regression tests.
bump pkgname + shared lib major, since we substitute an unsigned long to
an unsigned int in internal data structures.
@
text
@d2 2
a3 2
--- ginac/function.pl.orig	Wed Jul 15 06:29:52 2009
+++ ginac/function.pl	Mon Jun  7 10:48:59 2010
d111 1
a111 1
@@@@ -840,12 +841,12 @@@@ function::function(unsigned ser, const exprseq & es) :
d119 3
d129 1
a129 1
@@@@ -1343,7 +1344,7 @@@@ void function::store_remember_table(ex const & result)
d138 1
a138 1
@@@@ -1372,7 +1373,7 @@@@ unsigned function::register_new(function_options const
d146 5
a150 1
 	unsigned serial = 0;
@

