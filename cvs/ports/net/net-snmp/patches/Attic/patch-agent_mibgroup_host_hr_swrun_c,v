head	1.6;
access;
symbols
	OPENBSD_5_6:1.5.0.8
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2;
locks; strict;
comment	@# @;


1.6
date	2014.12.09.15.20.06;	author sthen;	state dead;
branches;
next	1.5;
commitid	GeM80Hk0rAfPyGK0;

1.5
date	2012.10.18.14.01.45;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.07.20.02.02;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.06.21.32.57;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.26.00.42.21;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.25.22.59.12;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.6
log
@update to Net-SNMP 5.7.3

- roll -perl subpackage into -main, this greatly simplifies PLIST handling
for package updates. bumps to dependent ports to follow after this commit.
@
text
@$OpenBSD: patch-agent_mibgroup_host_hr_swrun_c,v 1.5 2012/10/18 14:01:45 sthen Exp $
--- agent/mibgroup/host/hr_swrun.c.orig	Sat Jun  2 17:27:10 2012
+++ agent/mibgroup/host/hr_swrun.c	Thu Jun  7 23:39:39 2012
@@@@ -695,6 +695,8 @@@@ var_hrswrun(struct variable * vp,
         strcpy(string, proc_table[LowProcIndex].ki_comm);
     #elif defined(dragonfly) && __DragonFly_version >= 190000
         strcpy(string, proc_table[LowProcIndex].kp_comm);
+    #elif defined(openbsd5)
+        strcpy(string, proc_table[LowProcIndex].p_comm);
     #else
         strcpy(string, proc_table[LowProcIndex].kp_proc.p_comm);
     #endif
@@@@ -816,6 +818,8 @@@@ var_hrswrun(struct variable * vp,
         strcpy(string, proc_table[LowProcIndex].ki_comm);
     #elif defined(dragonfly) && __DragonFly_version >= 190000
         strcpy(string, proc_table[LowProcIndex].kp_comm);
+    #elif defined(openbsd5)
+        strcpy(string, proc_table[LowProcIndex].p_comm);
     #else
         strcpy(string, proc_table[LowProcIndex].kp_proc.p_comm);
     #endif
@@@@ -1002,6 +1006,11 @@@@ var_hrswrun(struct variable * vp,
 		long_return = 2;/* operatingSystem */
 	} else
 	    long_return = 4;	/* application */
+    #elif defined(openbsd5)
+        if (proc_table[LowProcIndex].p_flag & P_SYSTEM)
+	    long_return = 2;	/* operatingSystem */
+	else
+	    long_return = 4;	/* application */
     #else
       #if defined(dragonfly) && __DragonFly_version >= 190000
         if (proc_table[LowProcIndex].kp_flags & P_SYSTEM)
@@@@ -1052,6 +1061,8 @@@@ var_hrswrun(struct variable * vp,
         switch (proc_table[LowProcIndex].ki_stat) {
     #elif defined(dragonfly) && __DragonFly_version >= 190000
         switch (proc_table[LowProcIndex].kp_stat) {
+    #elif defined(openbsd5)
+        switch (proc_table[LowProcIndex].p_stat) {
     #else
         switch (proc_table[LowProcIndex].kp_proc.p_stat) {
     #endif
@@@@ -1157,6 +1168,10 @@@@ var_hrswrun(struct variable * vp,
         long_return = proc_table[LowProcIndex].kp_lwp.kl_uticks +
             proc_table[LowProcIndex].kp_lwp.kl_sticks +
             proc_table[LowProcIndex].kp_lwp.kl_iticks;
+    #elif defined(openbsd5)
+        long_return = proc_table[LowProcIndex].p_uticks +
+            proc_table[LowProcIndex].p_sticks +
+            proc_table[LowProcIndex].p_iticks;
     #elif defined(dragonfly)
         long_return = proc_table[LowProcIndex].kp_eproc.e_uticks +
             proc_table[LowProcIndex].kp_eproc.e_sticks +
@@@@ -1278,6 +1293,11 @@@@ var_hrswrun(struct variable * vp,
     #else
             proc_table[LowProcIndex].kp_eproc.e_vm.vm_map.size / 1024;
     #endif
+  #elif defined(openbsd5)
+        long_return = proc_table[LowProcIndex].p_vm_tsize +
+            proc_table[LowProcIndex].p_vm_ssize +
+            proc_table[LowProcIndex].p_vm_dsize;
+        long_return = long_return * (getpagesize() / 1024);
   #else
         long_return = proc_table[LowProcIndex].kp_eproc.e_vm.vm_tsize +
             proc_table[LowProcIndex].kp_eproc.e_vm.vm_ssize +
@@@@ -1540,7 +1560,11 @@@@ Init_HR_SWRun(void)
             nproc = 0;
             return;
         }
+  #if defined(openbsd5)
+        proc_table = kvm_getprocs(kd, KERN_PROC_ALL, 0, sizeof (struct kinfo_proc), &nproc);
+  #else
         proc_table = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc);
+  #endif
     }
 #else
 
@@@@ -1600,6 +1624,9 @@@@ Get_Next_HR_SWRun(void)
     #elif defined(dragonfly) && __DragonFly_version >= 190000
         if (proc_table[current_proc_entry].kp_stat != 0)
             return proc_table[current_proc_entry++].kp_pid;
+    #elif defined(openbsd5)
+        if (proc_table[current_proc_entry].p_stat != 0)
+            return proc_table[current_proc_entry++].p_pid;
     #else
         if (proc_table[current_proc_entry].kp_proc.p_stat != 0)
             return proc_table[current_proc_entry++].kp_proc.p_pid;
@


1.5
log
@update to Net-SNMP 5.7.2; lots of fixes and improvements

- many of our local patches are now committed upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-agent_mibgroup_host_hr_swrun_c,v 1.4 2011/07/07 20:02:02 sthen Exp $
@


1.4
log
@update to Net-SNMP 5.7 and clean up the patches a lot.

- rc scripts added (names suggested by Nigel Taylor, I was having
a hard time coming up with something nice that avoid a conflict with
base snmpd now the rc.d namespace is shared).
@
text
@d1 4
a4 4
$OpenBSD: patch-agent_mibgroup_host_hr_swrun_c,v 1.3 2011/07/06 21:32:57 sthen Exp $
--- agent/mibgroup/host/hr_swrun.c.orig	Fri Jul  1 23:35:46 2011
+++ agent/mibgroup/host/hr_swrun.c	Wed Jul  6 23:45:48 2011
@@@@ -700,6 +700,8 @@@@ var_hrswrun(struct variable * vp,
d13 1
a13 1
@@@@ -822,6 +824,8 @@@@ var_hrswrun(struct variable * vp,
d22 1
a22 1
@@@@ -1008,6 +1012,11 @@@@ var_hrswrun(struct variable * vp,
d34 1
a34 1
@@@@ -1058,6 +1067,8 @@@@ var_hrswrun(struct variable * vp,
d43 1
a43 1
@@@@ -1163,6 +1174,10 @@@@ var_hrswrun(struct variable * vp,
d54 1
a54 1
@@@@ -1284,6 +1299,11 @@@@ var_hrswrun(struct variable * vp,
d66 1
a66 1
@@@@ -1546,7 +1566,11 @@@@ Init_HR_SWRun(void)
d78 1
a78 1
@@@@ -1606,6 +1630,9 @@@@ Get_Next_HR_SWRun(void)
@


1.3
log
@- convert kinfo_proc2 -> kinfo_procs

- don't use "#if defined(openbsd3) || defined(openbsd4)" all over the place,
this is definitely not web scale

- zap some pointless ifdefs
@
text
@d1 4
a4 6
$OpenBSD: patch-agent_mibgroup_host_hr_swrun_c,v 1.2 2010/10/26 00:42:21 sthen Exp $
--- agent/mibgroup/host/hr_swrun.c.orig	Thu Jul 29 15:58:47 2010
+++ agent/mibgroup/host/hr_swrun.c	Wed Jul  6 16:53:05 2011
@@@@ -614,6 +614,9 @@@@ var_hrswrun(struct variable * vp,
 #elif HAVE_KVM_GETPROCS
     #if defined(freebsd5) && __FreeBSD_version >= 500014
d6 3
a8 2
+    #elif defined(openbsd) /* XXX check version */
+	/* p_comm[MAXCOMLEN+1] should fit in string[1024] */
d13 1
a13 3
@@@@ -737,6 +740,9 @@@@ var_hrswrun(struct variable * vp,
 #elif HAVE_KVM_GETPROCS
     #if defined(freebsd5) && __FreeBSD_version >= 500014
d15 3
a17 2
+    #elif defined(openbsd) /* XXX check version */
+        /* Should be path, but this is not available, just use argv[0] again */
d22 1
a22 1
@@@@ -942,6 +948,11 @@@@ var_hrswrun(struct variable * vp,
d26 1
a26 1
+    #elif defined(openbsd) /* XXX check version */
d32 3
a34 5
         if (proc_table[LowProcIndex].kp_proc.p_flag & P_SYSTEM)
 	    long_return = 2;	/* operatingSystem */
@@@@ -984,6 +995,8 @@@@ var_hrswrun(struct variable * vp,
 #if HAVE_KVM_GETPROCS
     #if defined(freebsd5) && __FreeBSD_version >= 500014
d36 3
a38 1
+    #elif defined(openbsd) /* XXX check version */
d43 5
a47 5
@@@@ -1091,6 +1104,10 @@@@ var_hrswrun(struct variable * vp,
         long_return = 0;
     #elif defined(freebsd5)
         long_return = proc_table[LowProcIndex].ki_runtime / 100000;
+    #elif defined(openbsd) /* XXX check version */
d51 4
a54 4
     #else
         long_return = proc_table[LowProcIndex].kp_proc.p_uticks +
             proc_table[LowProcIndex].kp_proc.p_sticks +
@@@@ -1211,6 +1228,11 @@@@ var_hrswrun(struct variable * vp,
d58 1
a58 1
+  #elif defined(openbsd) /* XXX check version */
d66 1
a66 1
@@@@ -1474,7 +1496,11 @@@@ Init_HR_SWRun(void)
d70 1
a70 1
+  #if defined(openbsd) /* XXX check version */
d78 5
a82 5
@@@@ -1528,6 +1554,9 @@@@ Get_Next_HR_SWRun(void)
     #if defined(freebsd5) && __FreeBSD_version >= 500014
         if (proc_table[current_proc_entry].ki_stat != 0)
             return proc_table[current_proc_entry++].ki_pid;
+    #elif defined(openbsd) /* XXX check version */
@


1.2
log
@feed the right size to kvm_getproc2
@
text
@d1 4
a4 40
$OpenBSD: patch-agent_mibgroup_host_hr_swrun_c,v 1.1 2010/10/25 22:59:12 sthen Exp $
--- agent/mibgroup/host/hr_swrun.c.orig	Thu Jul 29 16:58:47 2010
+++ agent/mibgroup/host/hr_swrun.c	Tue Oct 26 02:31:04 2010
@@@@ -122,6 +122,8 @@@@ static int      LowProcIndex;
 #if defined(hpux10) || defined(hpux11)
 struct pst_status *proc_table;
 struct pst_dynamic pst_dyn;
+#elif HAVE_KVM_GETPROC2
+struct kinfo_proc2 *proc_table;
 #elif HAVE_KVM_GETPROCS
 struct kinfo_proc *proc_table;
 #elif defined(solaris2)
@@@@ -504,7 +506,7 @@@@ var_hrswrun(struct variable * vp,
     time_t          now;
     static int      oldpid = -1;
 #endif
-#if HAVE_KVM_GETPROCS
+#ifdef (HAVE_KVM_GETPROCS || HAVE_KVM_GETPROC2)
     char          **argv;
 #endif
 #ifdef linux
@@@@ -550,7 +552,7 @@@@ var_hrswrun(struct variable * vp,
 #else
         if (kd == NULL)
             return NULL;
-        if ((proc_buf = kvm_getproc(kd, pid)) == NULL)
+        if ((proc_buf = kvm_getproc(kd, pid)) == NULL) /* XXX */
             return NULL;
 #endif
         oldpid = pid;
@@@@ -611,6 +613,12 @@@@ var_hrswrun(struct variable * vp,
         cp = strchr(string, ' ');
         if (cp != NULL)
             *cp = '\0';
+#elif HAVE_KVM_GETPROC2
+        strlcpy(string, proc_table[LowProcIndex].p_comm, sizeof(string));
+	/* process name: truncate the string at the first space */
+        cp = strchr(string, ' ');
+        if (cp != NULL)
+            *cp = '\0';
d8 7
a14 10
@@@@ -734,6 +742,12 @@@@ var_hrswrun(struct variable * vp,
         cp = strchr(string, ' ');
         if (cp != NULL)
             *cp = '\0';
+#elif HAVE_KVM_GETPROC2
+        /* Should be path, but this is not available, just use argv[0] again */
+        strlcpy(string, proc_table[LowProcIndex].p_comm, sizeof(string));
+        cp = strchr(string, ' ');
+        if (cp != NULL)
+            *cp = '\0';
d18 11
a28 23
@@@@ -851,6 +865,17 @@@@ var_hrswrun(struct variable * vp,
             sprintf(string, "%s", cp);
         } else
             string[0] = '\0';
+#elif HAVE_KVM_GETPROC2
+        string[0] = 0;
+        argv = kvm_getargv2(kd, proc_table + LowProcIndex, sizeof(string));
+        if (argv)
+            argv++;
+        while (argv && *argv) {
+            if (string[0] != 0)
+                strcat(string, " ");
+            strcat(string, *argv);
+            argv++;
+        }
 #elif HAVE_KVM_GETPROCS
         string[0] = 0;
         argv = kvm_getargv(kd, proc_table + LowProcIndex, sizeof(string));
@@@@ -933,6 +958,11 @@@@ var_hrswrun(struct variable * vp,
 			long_return = 2;	/* kernel process */
 		} else
 			long_return = 4;	/* application */
+#elif HAVE_KVM_GETPROC2
d33 5
a37 1
 #elif HAVE_KVM_GETPROCS
d39 2
a40 7
 	if (proc_table[LowProcIndex].ki_flag & P_SYSTEM) {
@@@@ -981,7 +1011,9 @@@@ var_hrswrun(struct variable * vp,
             break;
         }
 #else
-#if HAVE_KVM_GETPROCS
+#if HAVE_KVM_GETPROC2
a41 3
+#elif HAVE_KVM_GETPROCS
     #if defined(freebsd5) && __FreeBSD_version >= 500014
         switch (proc_table[LowProcIndex].ki_stat) {
d43 7
a49 5
@@@@ -1082,6 +1114,10 @@@@ var_hrswrun(struct variable * vp,
 #else
         long_return = proc_buf->p_utime * 100 + proc_buf->p_stime * 100;
 #endif
+#elif HAVE_KVM_GETPROC2
d53 8
a60 8
 #elif HAVE_KVM_GETPROCS
     #if defined(NOT_DEFINED) && defined(freebsd5) && __FreeBSD_version >= 500014
         /* XXX: Accessing ki_paddr causes sig10 ...
@@@@ -1196,6 +1232,11 @@@@ var_hrswrun(struct variable * vp,
 #endif
 #elif defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = proc_table[LowProcIndex].pi_size * getpagesize() / 1024;
+#elif HAVE_KVM_GETPROC2
d65 4
a68 18
 #elif HAVE_KVM_GETPROCS && !defined(darwin8)
   #if defined(NOT_DEFINED) && defined(freebsd5) && __FreeBSD_version >= 500014
 	    /* XXX
@@@@ -1468,13 +1509,21 @@@@ Init_HR_SWRun(void)
 			proc_table = realloc(proc_table, avail * sizeof(proc_table[0]));
 		}
     }
+#elif HAVE_KVM_GETPROC2
+    {
+        if (kd == NULL) {
+            nproc = 0;
+            return;
+        }
+        proc_table = kvm_getproc2(kd, KERN_PROC_ALL, 0, sizeof (struct kinfo_proc2), &nproc);
+    }
 #elif HAVE_KVM_GETPROCS
     {
         if (kd == NULL) {
d72 5
a76 2
-        proc_table = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc);
+        proc_table = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc); /* XXX */
d80 5
a84 5
@@@@ -1524,6 +1573,9 @@@@ Get_Next_HR_SWRun(void)
         return proc_table[current_proc_entry++].pst_pid;
 #elif defined(solaris2)
         return proc_table[current_proc_entry++];
+#elif HAVE_KVM_GETPROC2
d87 3
a89 28
 #elif HAVE_KVM_GETPROCS
     #if defined(freebsd5) && __FreeBSD_version >= 500014
         if (proc_table[current_proc_entry].ki_stat != 0)
@@@@ -1558,13 +1610,13 @@@@ End_HR_SWRun(void)
 int
 count_processes(void)
 {
-#if !(defined(linux) || defined(cygwin) || defined(hpux10) || defined(hpux11) || defined(solaris2) || HAVE_KVM_GETPROCS || defined(dynix))
+#if !(defined(linux) || defined(cygwin) || defined(hpux10) || defined(hpux11) || defined(solaris2) || HAVE_KVM_GETPROCS || HAVE_KVM_GETPROC2 || defined(dynix))
     int             i;
 #endif
     int             total = 0;
 
     Init_HR_SWRun();
-#if defined(hpux10) || defined(hpux11) || HAVE_KVM_GETPROCS || defined(solaris2)
+#if defined(hpux10) || defined(hpux11) || HAVE_KVM_GETPROCS || HAVE_KVM_GETPROC2 || defined(solaris2)
     total = nproc;
 #else
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
@@@@ -1578,7 +1630,7 @@@@ count_processes(void)
 #endif
         ++total;
     }
-#endif                          /* !hpux10 && !hpux11 && !HAVE_KVM_GETPROCS && !solaris2 */
+#endif                         /* !hpux10 && !hpux11 && !HAVE_KVM_GETPROCS && !HAVE_KVM_GETPROC2 && !solaris2 */
     End_HR_SWRun();
     return total;
 }
@


1.1
log
@update Net-SNMP to 5.6 and switch to kvm_getproc2, thanks landry for testing
"commit it!" landry@@
@
text
@d1 3
a3 3
$OpenBSD$
--- agent/mibgroup/host/hr_swrun.c.orig	Mon Oct 25 00:15:26 2010
+++ agent/mibgroup/host/hr_swrun.c	Mon Oct 25 02:26:50 2010
d131 1
a131 1
+        proc_table = kvm_getproc2(kd, KERN_PROC_ALL, 0, sizeof (*proc_table), &nproc);
@

