head	1.3;
access;
symbols
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2011.04.18.18.37.48;	author jasper;	state dead;
branches;
next	1.2;

1.2
date	2009.12.23.09.08.44;	author sturm;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.03.18.05.36;	author pvalchev;	state Exp;
branches;
next	;


desc
@@


1.3
log
@- update to 1.4.2

joint work with dcoppa@@ who fixed some cmake-beginners mistakes
  from the synergy devs
@
text
@$OpenBSD: patch-lib_platform_CXWindowsEventQueueBuffer_cpp,v 1.2 2009/12/23 09:08:44 sturm Exp $
--- lib/platform/CXWindowsEventQueueBuffer.cpp.orig	Sun Apr 24 05:02:16 2005
+++ lib/platform/CXWindowsEventQueueBuffer.cpp	Mon Dec 21 22:26:21 2009
@@@@ -84,6 +84,8 @@@@ CXWindowsEventQueueBuffer::waitForEvent(double dtimeou
 	pfds[0].events = POLLIN;
 	int timeout    = (dtimeout < 0.0) ? -1 :
 						static_cast<int>(1000.0 * dtimeout);
+	int remaining  =  timeout;
+	int retval     =  0;
 #else
 	struct timeval timeout;
 	struct timeval* timeoutPtr;
@@@@ -102,19 +104,43 @@@@ CXWindowsEventQueueBuffer::waitForEvent(double dtimeou
 	FD_ZERO(&rfds);
 	FD_SET(ConnectionNumber(m_display), &rfds);
 #endif
+	// It's possible that the X server has queued events locally
+	// in xlib's event buffer and not pushed on to the fd. Hence we
+	// can't simply monitor the fd as we may never be woken up.
+	// ie addEvent calls flush, XFlush may not send via the fd hence
+	// there is an event waiting to be sent but we must exit the poll
+	// before it can.
+	// Instead we poll for a brief period of time (so if events
+	// queued locally in the xlib buffer can be processed)
+	// and continue doing this until timeout is reached.
+	// The human eye can notice 60hz (ansi) which is 16ms, however
+	// we want to give the cpu a chance s owe up this to 25ms
+#define TIMEOUT_DELAY 25
 
-	// wait for message from X server or for timeout.  also check
-	// if the thread has been cancelled.  poll() should return -1
-	// with EINTR when the thread is cancelled.
+	if (timeout == -1) {
 #if HAVE_POLL
-	poll(pfds, 1, timeout);
+		poll(pfds, 1, timeout);
 #else
-	select(ConnectionNumber(m_display) + 1,
+		select(ConnectionNumber(m_display) + 1,
+				SELECT_TYPE_ARG234 &rfds,
+				SELECT_TYPE_ARG234 NULL,
+				SELECT_TYPE_ARG234 NULL,
+				SELECT_TYPE_ARG5   timeoutPtr);
+#endif
+	} else {
+		while( remaining > 0 && QLength(m_display)==0 && retval==0){
+#if HAVE_POLL
+			retval = poll(pfds, 1, TIMEOUT_DELAY); //16ms = 60hz, but we make it > to play nicely with the cpu
+#else
+			retval = select(ConnectionNumber(m_display) + 1,
 						SELECT_TYPE_ARG234 &rfds,
 						SELECT_TYPE_ARG234 NULL,
 						SELECT_TYPE_ARG234 NULL,
-						SELECT_TYPE_ARG5   timeoutPtr);
+						SELECT_TYPE_ARG5   TIMEOUT_DELAY);
 #endif
+			remaining-=TIMEOUT_DELAY;
+		}
+	}
 
 	{
 		// we're no longer waiting for events
@@@@ -179,7 +205,7 @@@@ bool
 CXWindowsEventQueueBuffer::isEmpty() const
 {
 	CLock lock(&m_mutex);
-	return (XPending(m_display) == 0);
+	return (QLength(m_display) == 0 );
 }
 
 CEventQueueTimer*
@


1.2
log
@revert server to old behaviour of blocking in case no client is
connected, this was introduced with the xcb fix and would result in
the server eating 100% cpu while waiting for clients
bump PKGNAME
ok dim@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_platform_CXWindowsEventQueueBuffer_cpp,v 1.1 2009/09/03 18:05:36 pvalchev Exp $
@


1.1
log
@Unbreak synergy after the X11 Xlib -> XCB switch, which
caused multi-second pauses for each event rendering it useless,
due to queueing in xcb buffers not triggering X file descriptor
changes.
Patch from http://bugs.gentoo.org/show_bug.cgi?id=257794

OK & hint in the right direction from maintainer dim@@ :)
@
text
@d1 3
a3 3
$OpenBSD$
--- lib/platform/CXWindowsEventQueueBuffer.cpp.orig	Sat Apr 23 20:02:16 2005
+++ lib/platform/CXWindowsEventQueueBuffer.cpp	Wed Sep  2 14:18:24 2009
d13 1
a13 1
@@@@ -102,19 +104,31 @@@@ CXWindowsEventQueueBuffer::waitForEvent(double dtimeou
d33 1
a33 1
+	while( remaining > 0 && QLength(m_display)==0 && retval==0){
d36 1
a36 1
+	retval = poll(pfds, 1, TIMEOUT_DELAY); //16ms = 60hz, but we make it > to play nicely with the cpu
d39 12
a50 1
+	retval = select(ConnectionNumber(m_display) + 1,
d57 2
a58 1
+	    remaining-=TIMEOUT_DELAY;
d63 1
a63 1
@@@@ -179,7 +193,7 @@@@ bool
@

