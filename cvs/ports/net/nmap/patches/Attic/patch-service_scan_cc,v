head	1.3;
access;
symbols
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2014.02.10.17.43.15;	author sthen;	state dead;
branches;
next	1.2;

1.2
date	2012.12.19.17.12.11;	author giovanni;	state Exp;
branches;
next	1.1;

1.1
date	2012.07.16.07.39.31;	author giovanni;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update nmap to 6.40, and build with their bundled libpcap for now, bpf_timeval
patches are questionable and there's a timing-related problem to track down.
From giovanni@@ (maintainer) a while ago. Add a fix from jca@@ to fix a floating-
point related assertion failure seen on i386, reminded by zhuk@@. Committing the
update rather than the minimal assertion-fix diff as it has been more
extensively tested in the past (then slipped through the cracks), jasper@@
agrees. OK jasper@@ giovanni@@
@
text
@$OpenBSD: patch-service_scan_cc,v 1.2 2012/12/19 17:12:11 giovanni Exp $
--- service_scan.cc.orig	Mon Oct 22 17:33:57 2012
+++ service_scan.cc	Fri Nov 30 12:41:48 2012
@@@@ -1964,10 +1964,10 @@@@ static void startNextProbe(nsock_pool nsp, nsock_iod n
     // if the last probe was the NULL probe.
     probe = svc->nextProbe(false);
     if (probe) {
-      svc->currentprobe_exec_time = *nsock_gettimeofday();
+      svc->currentprobe_exec_time = (const timeval&)*nsock_gettimeofday();
       send_probe_text(nsp, nsi, svc, probe);
       nsock_read(nsp, nsi, servicescan_read_handler, 
-		 svc->currentprobe_timemsleft(nsock_gettimeofday()), svc);
+		 svc->currentprobe_timemsleft((const timeval*)nsock_gettimeofday()), svc);
     } else {
       // Should only happen if someone has a highly perverse nmap-service-probes
       // file.  Null scan should generally never be the only probe.
@@@@ -2012,11 +2012,11 @@@@ static void startNextProbe(nsock_pool nsp, nsock_iod n
       } else {
 	assert(svc->proto == IPPROTO_UDP);
 	/* Can maintain the same UDP "connection" */
-	svc->currentprobe_exec_time = *nsock_gettimeofday();
+	svc->currentprobe_exec_time = (const timeval&)*nsock_gettimeofday();
 	send_probe_text(nsp, nsi, svc, probe);
 	// Now let us read any results
 	nsock_read(nsp, nsi, servicescan_read_handler, 
-		   svc->currentprobe_timemsleft(nsock_gettimeofday()), svc);
+		   svc->currentprobe_timemsleft((const timeval*)nsock_gettimeofday()), svc);
       }
     } else {
       // No more probes remaining!  Failed to match
@@@@ -2083,14 +2083,14 @@@@ static void considerPrintingStats(ServiceGroup *SG) {
    if (keyWasPressed()) {
       SG->SPM->printStats(SG->services_finished.size() /
                           ((double)SG->services_remaining.size() + SG->services_in_progress.size() + 
-                           SG->services_finished.size()), nsock_gettimeofday());
+                           SG->services_finished.size()), (const timeval*)nsock_gettimeofday());
    }
 
 
   /* Perhaps this should be made more complex, but I suppose it should be
      good enough for now. */
-  if (SG->SPM->mayBePrinted(nsock_gettimeofday())) {
-    SG->SPM->printStatsIfNecessary(SG->services_finished.size() / ((double)SG->services_remaining.size() + SG->services_in_progress.size() + SG->services_finished.size()), nsock_gettimeofday());
+  if (SG->SPM->mayBePrinted((const timeval*)nsock_gettimeofday())) {
+    SG->SPM->printStatsIfNecessary(SG->services_finished.size() / ((double)SG->services_remaining.size() + SG->services_in_progress.size() + SG->services_finished.size()), (const timeval*)nsock_gettimeofday());
   }
 }
 
@@@@ -2117,7 +2117,7 @@@@ static void handleHostIfDone(ServiceGroup *SG, Target 
   }
 
   if (!found) {
-    target->stopTimeOutClock(nsock_gettimeofday());
+    target->stopTimeOutClock((const timeval*)nsock_gettimeofday());
     if (target->timedOut(NULL)) {
       SG->num_hosts_timedout++;
     }
@@@@ -2173,7 +2173,7 @@@@ static int launchSomeServiceProbes(nsock_pool nsp, Ser
 	 !SG->services_remaining.empty()) {
     // Start executing a probe from the new list and move it to in_progress
     svc = SG->services_remaining.front();
-    if (svc->target->timedOut(nsock_gettimeofday())) {
+    if (svc->target->timedOut((const timeval*)nsock_gettimeofday())) {
       end_svcprobe(nsp, PROBESTATE_INCOMPLETE, SG, svc, NULL);
       continue;
     }
@@@@ -2232,7 +2232,7 @@@@ static void servicescan_connect_handler(nsock_pool nsp
 
   assert(type == NSE_TYPE_CONNECT || type == NSE_TYPE_CONNECT_SSL);
 
-  if (svc->target->timedOut(nsock_gettimeofday())) {
+  if (svc->target->timedOut((const timeval*)nsock_gettimeofday())) {
     end_svcprobe(nsp, PROBESTATE_INCOMPLETE, SG, svc, nsi);
   } else if (status == NSE_STATUS_SUCCESS) {
 
@@@@ -2258,10 +2258,10 @@@@ static void servicescan_connect_handler(nsock_pool nsp
 
     // Yeah!  Connection made to the port.  Send the appropriate probe
     // text (if any is needed -- might be NULL probe)
-    svc->currentprobe_exec_time = *nsock_gettimeofday();
+    svc->currentprobe_exec_time = (const timeval&)*nsock_gettimeofday();
     send_probe_text(nsp, nsi, svc, probe);
     // Now let us read any results
-    nsock_read(nsp, nsi, servicescan_read_handler, svc->currentprobe_timemsleft(nsock_gettimeofday()), svc);
+    nsock_read(nsp, nsi, servicescan_read_handler, svc->currentprobe_timemsleft((const timeval*)nsock_gettimeofday()), svc);
   } else if (status == NSE_STATUS_TIMEOUT || status == NSE_STATUS_ERROR) {
       // This is not good.  The connect() really shouldn't generally
       // be timing out like that.  We'll mark this svc as incomplete
@@@@ -2296,11 +2296,11 @@@@ static void servicescan_write_handler(nsock_pool nsp, 
   if (keyWasPressed()) {
      SG->SPM->printStats(SG->services_finished.size() /
                          ((double)SG->services_remaining.size() + SG->services_in_progress.size() + 
-                          SG->services_finished.size()), nsock_gettimeofday());
+                          SG->services_finished.size()), (const timeval*)nsock_gettimeofday());
   }
   
 
-  if (svc->target->timedOut(nsock_gettimeofday())) {
+  if (svc->target->timedOut((const timeval*)nsock_gettimeofday())) {
     end_svcprobe(nsp, PROBESTATE_INCOMPLETE, SG, svc, nsi);
     return;
   }
@@@@ -2346,7 +2346,7 @@@@ static void servicescan_read_handler(nsock_pool nsp, n
 
   assert(type == NSE_TYPE_READ);
 
-  if (svc->target->timedOut(nsock_gettimeofday())) {
+  if (svc->target->timedOut((const timeval*)nsock_gettimeofday())) {
     end_svcprobe(nsp, PROBESTATE_INCOMPLETE, SG, svc, nsi);
   } else if (status == NSE_STATUS_SUCCESS) {
     // w00p, w00p, we read something back from the port.
@


1.2
log
@
Update to 6.25
lot of improvements in nse scripting engine and in ipv6 support
Full changelog: http://nmap.org/changelog.html
Help and ok sthen@@ and dcoppa@@
@
text
@d1 1
a1 1
$OpenBSD: patch-service_scan_cc,v 1.1 2012/07/16 07:39:31 giovanni Exp $
@


1.1
log
@
Major update to 6.01
tests & ok benoit@@, thanks
@
text
@d1 4
a4 4
$OpenBSD$
--- service_scan.cc.orig	Fri May 25 14:45:48 2012
+++ service_scan.cc	Fri May 25 15:10:52 2012
@@@@ -1968,10 +1968,10 @@@@ static void startNextProbe(nsock_pool nsp, nsock_iod n
d17 1
a17 1
@@@@ -2016,11 +2016,11 @@@@ static void startNextProbe(nsock_pool nsp, nsock_iod n
d31 1
a31 1
@@@@ -2087,14 +2087,14 @@@@ static void considerPrintingStats(ServiceGroup *SG) {
d49 1
a49 1
@@@@ -2121,7 +2121,7 @@@@ static void handleHostIfDone(ServiceGroup *SG, Target 
d58 1
a58 1
@@@@ -2177,7 +2177,7 @@@@ static int launchSomeServiceProbes(nsock_pool nsp, Ser
d67 1
a67 1
@@@@ -2236,7 +2236,7 @@@@ static void servicescan_connect_handler(nsock_pool nsp
d76 1
a76 1
@@@@ -2262,10 +2262,10 @@@@ static void servicescan_connect_handler(nsock_pool nsp
d89 1
a89 1
@@@@ -2300,11 +2300,11 @@@@ static void servicescan_write_handler(nsock_pool nsp, 
d103 1
a103 1
@@@@ -2350,7 +2350,7 @@@@ static void servicescan_read_handler(nsock_pool nsp, n
@

