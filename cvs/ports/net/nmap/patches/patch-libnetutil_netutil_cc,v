head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.2
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@# @;


1.10
date	2016.12.22.21.58.40;	author sthen;	state Exp;
branches;
next	1.9;
commitid	a5cps34zmWstUXtx;

1.9
date	2016.10.06.05.47.35;	author giovanni;	state Exp;
branches;
next	1.8;
commitid	SMKs6eDgmpJSXPER;

1.8
date	2016.03.18.21.13.38;	author giovanni;	state Exp;
branches;
next	1.7;
commitid	zlRR6IJpSjr8N5kZ;

1.7
date	2016.01.07.13.23.47;	author giovanni;	state Exp;
branches;
next	1.6;
commitid	MbHWCjE1Ed0RmzSe;

1.6
date	2014.06.16.10.22.15;	author sthen;	state Exp;
branches;
next	1.5;
commitid	79tXxFG2YD7kwb1P;

1.5
date	2014.05.16.15.08.54;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2014.02.10.17.43.15;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2012.12.19.17.12.11;	author giovanni;	state Exp;
branches;
next	1.2;

1.2
date	2012.07.16.07.39.31;	author giovanni;	state Exp;
branches;
next	1.1;

1.1
date	2011.03.28.09.01.24;	author giovanni;	state Exp;
branches;
next	;


desc
@@


1.10
log
@update to nmap-7.40, from maintainer David CARLIER
@
text
@$OpenBSD: patch-libnetutil_netutil_cc,v 1.9 2016/10/06 05:47:35 giovanni Exp $

first chunk:
http://marc.info/?l=openbsd-ports&m=140284432321370&w=2

similar diff to DLT_LINUX_SLL chunks sent upstream but they seem uninterested.
http://marc.info/?l=nmap-dev&m=140179174718457&w=2

chunks dealing with iovec: ???

--- libnetutil/netutil.cc.orig	Wed Dec 14 00:12:23 2016
+++ libnetutil/netutil.cc	Thu Dec 22 05:45:11 2016
@@@@ -3179,7 +3179,6 @@@@ static int route_dst_netlink(const struct sockaddr_sto
                              const struct sockaddr_storage *spoofss) {
   struct sockaddr_nl snl;
   struct msghdr msg;
-  struct iovec iov;
   struct nlmsghdr *nlmsg;
   struct rtmsg *rtmsg;
   struct rtattr *rtattr;
@@@@ -3231,22 +3230,14 @@@@ static int route_dst_netlink(const struct sockaddr_sto
     add_rtattr_addr(nlmsg, &rtattr, &len, RTA_SRC, spoofss, intf_index);
   }
 
-  iov.iov_base = nlmsg;
-  iov.iov_len = nlmsg->nlmsg_len;
-
   memset(&msg, 0, sizeof(msg));
   msg.msg_name = &snl;
   msg.msg_namelen = sizeof(snl);
-  msg.msg_iov = &iov;
-  msg.msg_iovlen = 1;
 
   rc = sendmsg(fd, &msg, 0);
   if (rc == -1)
     netutil_fatal("%s: cannot sendmsg: %s", __func__, strerror(errno));
 
-  iov.iov_base = buf;
-  iov.iov_len = sizeof(buf);
-
   len = recvmsg(fd, &msg, 0);
   if (len <= 0)
     netutil_fatal("%s: cannot recvmsg: %s", __func__, strerror(errno));
@@@@ -3877,7 +3868,6 @@@@ static const unsigned char *add_exthdr_ancillary(struc
 static int send_ipv6_ip(const struct sockaddr_in6 *dst,
   const unsigned char *packet, size_t packetlen) {
   struct msghdr msg;
-  struct iovec iov;
 
   const unsigned char *end;
   struct ip6_hdr *hdr;
@@@@ -3896,8 +3886,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
   /* Set up sendmsg data structure. iov is filled in below. */
   msg.msg_name = (void *) dst;
   msg.msg_namelen = sizeof(*dst);
-  msg.msg_iov = &iov;
-  msg.msg_iovlen = 1;
   msg.msg_control = NULL;
   msg.msg_controllen = 0;
   msg.msg_flags = 0;
@@@@ -3956,8 +3944,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
   }
 
   assert(packet <= end);
-  iov.iov_base = (unsigned char *) packet;
-  iov.iov_len = end - packet;
 
   n = sendmsg(sd, &msg, 0);
   if (n == -1)
@@@@ -4160,9 +4146,6 @@@@ int datalink_offset(int datalink)
 {
   if (datalink == DLT_EN10MB)
     return ETH_HDR_LEN;
-  else if (datalink == DLT_LINUX_SLL)
-    /* The datalink type is Linux "cooked" sockets. See pcap-linktype(7). */
-    return 16;
   else
     return -1;
 }
@@@@ -4288,10 +4271,6 @@@@ static bool accept_arp(const unsigned char *p, const s
 
   if (datalink == DLT_EN10MB) {
     return ntohs(*((u16 *) (p + 12))) == ETH_TYPE_ARP;
-  } else if (datalink == DLT_LINUX_SLL) {
-    return ntohs(*((u16 *) (p + 2))) == ARPHRD_ETHER && /* sll_hatype */
-      ntohs(*((u16 *) (p + 4))) == 6 && /* sll_halen */
-      ntohs(*((u16 *) (p + 14))) == ETH_TYPE_ARP; /* sll_protocol */
   } else {
     return false;
   }
@


1.9
log
@Update to 7.30
from David Carlier with tweaks by me
@
text
@d1 1
a1 1
$OpenBSD: patch-libnetutil_netutil_cc,v 1.8 2016/03/18 21:13:38 giovanni Exp $
d11 3
a13 3
--- libnetutil/netutil.cc.orig	Thu Aug 25 19:41:03 2016
+++ libnetutil/netutil.cc	Thu Sep 29 22:04:48 2016
@@@@ -3172,7 +3172,6 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d21 1
a21 1
@@@@ -3224,22 +3223,14 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d44 1
a44 1
@@@@ -3870,7 +3861,6 @@@@ static const unsigned char *add_exthdr_ancillary(struc
d52 1
a52 1
@@@@ -3889,8 +3879,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d61 1
a61 1
@@@@ -3949,8 +3937,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d70 1
a70 1
@@@@ -4153,9 +4139,6 @@@@ int datalink_offset(int datalink)
d80 1
a80 1
@@@@ -4281,10 +4264,6 @@@@ static bool accept_arp(const unsigned char *p, const s
@


1.8
log
@update to 7.10 from maintainer David Carlier with tweaks by me
@
text
@d1 1
a1 1
$OpenBSD: patch-libnetutil_netutil_cc,v 1.7 2016/01/07 13:23:47 giovanni Exp $
d11 3
a13 3
--- libnetutil/netutil.cc.orig	Thu Mar 17 20:17:27 2016
+++ libnetutil/netutil.cc	Thu Mar 17 20:19:47 2016
@@@@ -3142,7 +3142,6 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d21 1
a21 1
@@@@ -3194,22 +3193,14 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d44 1
a44 1
@@@@ -3840,7 +3831,6 @@@@ static const unsigned char *add_exthdr_ancillary(struc
d52 1
a52 1
@@@@ -3859,8 +3849,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d61 1
a61 1
@@@@ -3919,8 +3907,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d70 1
a70 1
@@@@ -4123,9 +4109,6 @@@@ int datalink_offset(int datalink)
d80 1
a80 1
@@@@ -4262,10 +4245,6 @@@@ static bool accept_arp(const unsigned char *p, const s
@


1.7
log
@Update to 7.01 and drop maintainership
new maintainer is David Carlier
ok jca@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libnetutil_netutil_cc,v 1.6 2014/06/16 10:22:15 sthen Exp $
d11 3
a13 12
--- libnetutil/netutil.cc.orig	Wed Oct 28 04:21:15 2015
+++ libnetutil/netutil.cc	Tue Dec 29 10:47:48 2015
@@@@ -915,7 +915,7 @@@@ void set_ttl(int sd, int ttl) {
 /* Other than WIN32, what these systems have in common is that they use BPF for
    packet capture. (Solaris 10 and earlier used DLPI and had valid selectable
    fds.) */
-#if defined(WIN32) || defined(MACOSX) || (defined(FREEBSD) && (__FreeBSD_version < 500000) || defined(SOLARIS_BPF_PCAP_CAPTURE))
+#if defined(WIN32) || defined(MACOSX) || defined(OPENBSD) || (defined(FREEBSD) && (__FreeBSD_version < 500000) || defined(SOLARIS_BPF_PCAP_CAPTURE))
 /* Returns whether the system supports pcap_get_selectable_fd() properly */
 int pcap_selectable_fd_valid() {
   return 0;
@@@@ -3139,7 +3139,6 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d21 1
a21 1
@@@@ -3191,22 +3190,14 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d44 1
a44 1
@@@@ -3837,7 +3828,6 @@@@ static const unsigned char *add_exthdr_ancillary(struc
d52 1
a52 1
@@@@ -3853,8 +3843,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d61 1
a61 1
@@@@ -3913,8 +3901,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d70 1
a70 1
@@@@ -4117,9 +4103,6 @@@@ int datalink_offset(int datalink)
d80 1
a80 10
@@@@ -4156,7 +4139,7 @@@@ static int read_reply_pcap(pcap_t *pd, long to_usec,
     netutil_fatal("Cannot obtain datalink information: %s", pcap_geterr(pd));
   ioffset = datalink_offset(*datalink);
   if (ioffset < 0)
-    netutil_fatal("datalink_offset failed for type %d (DLT_EN10MB = %d, DLT_LINUX_SLL = %d)", *datalink, DLT_EN10MB, DLT_LINUX_SLL);
+    netutil_fatal("datalink_offset failed for type %d (DLT_EN10MB = %d)", *datalink, DLT_EN10MB);
   *offset = (unsigned int) ioffset;
 
   if (to_usec > 0) {
@@@@ -4256,10 +4239,6 @@@@ static bool accept_arp(const unsigned char *p, const s
@


1.6
log
@Don't use pcap_get_selectable_fd; I don't know if it works in base libpcap,
but it doesn't work for us in nmap's internal libpcap causing problems with
at least -sS and probably some others. Found by Kent Fritz, ok giovanni@@.
@
text
@d1 1
a1 1
$OpenBSD: patch-libnetutil_netutil_cc,v 1.5 2014/05/16 15:08:54 sthen Exp $
d11 3
a13 3
--- libnetutil/netutil.cc.orig	Thu Nov  7 19:32:33 2013
+++ libnetutil/netutil.cc	Sun Jun 15 20:36:36 2014
@@@@ -916,7 +916,7 @@@@ void set_ttl(int sd, int ttl) {
d22 1
a22 1
@@@@ -3140,7 +3140,6 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d30 1
a30 1
@@@@ -3192,22 +3191,14 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d53 1
a53 1
@@@@ -3838,7 +3829,6 @@@@ static const unsigned char *add_exthdr_ancillary(struc
d61 1
a61 1
@@@@ -3854,8 +3844,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d70 1
a70 1
@@@@ -3914,8 +3902,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d79 1
a79 1
@@@@ -4084,9 +4070,6 @@@@ int datalink_offset(int datalink)
d89 1
a89 1
@@@@ -4123,7 +4106,7 @@@@ static int read_reply_pcap(pcap_t *pd, long to_usec,
d98 1
a98 1
@@@@ -4223,10 +4206,6 @@@@ static bool accept_arp(const unsigned char *p, const s
@


1.5
log
@update to nmap 6.46, tweak from / ok giovanni@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libnetutil_netutil_cc,v 1.4 2014/02/10 17:43:15 sthen Exp $
d3 5
a7 2
chunks dealing with DLT_LINUX_SLL are to cope with non-bundled libpcap (not
currently used). should probably be #ifdef DLT_LINUX_SLL and go upstream?
d12 10
a21 1
+++ libnetutil/netutil.cc	Thu May 15 20:12:32 2014
@


1.4
log
@Update nmap to 6.40, and build with their bundled libpcap for now, bpf_timeval
patches are questionable and there's a timing-related problem to track down.
From giovanni@@ (maintainer) a while ago. Add a fix from jca@@ to fix a floating-
point related assertion failure seen on i386, reminded by zhuk@@. Committing the
update rather than the minimal assertion-fix diff as it has been more
extensively tested in the past (then slipped through the cracks), jasper@@
agrees. OK jasper@@ giovanni@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libnetutil_netutil_cc,v 1.3 2012/12/19 17:12:11 giovanni Exp $
d8 3
a10 3
--- libnetutil/netutil.cc.orig	Mon Jul 29 00:08:48 2013
+++ libnetutil/netutil.cc	Wed Oct 16 22:00:54 2013
@@@@ -3124,7 +3124,6 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d18 1
a18 1
@@@@ -3176,22 +3175,14 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d41 1
a41 1
@@@@ -3822,7 +3813,6 @@@@ static const unsigned char *add_exthdr_ancillary(struc
d49 1
a49 1
@@@@ -3838,8 +3828,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d58 1
a58 1
@@@@ -3898,8 +3886,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d67 1
a67 1
@@@@ -4068,9 +4054,6 @@@@ int datalink_offset(int datalink)
d77 1
a77 1
@@@@ -4107,7 +4090,7 @@@@ static int read_reply_pcap(pcap_t *pd, long to_usec,
d86 1
a86 1
@@@@ -4207,10 +4190,6 @@@@ static bool accept_arp(const unsigned char *p, const s
@


1.3
log
@
Update to 6.25
lot of improvements in nse scripting engine and in ipv6 support
Full changelog: http://nmap.org/changelog.html
Help and ok sthen@@ and dcoppa@@
@
text
@d1 10
a10 4
$OpenBSD: patch-libnetutil_netutil_cc,v 1.2 2012/07/16 07:39:31 giovanni Exp $
--- libnetutil/netutil.cc.orig	Thu Oct 11 05:11:53 2012
+++ libnetutil/netutil.cc	Fri Nov 30 12:41:47 2012
@@@@ -3087,7 +3087,6 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d18 2
a19 2
@@@@ -3128,22 +3127,14 @@@@ static int route_dst_netlink(const struct sockaddr_sto
     add_rtattr_addr(nlmsg, &rtattr, &len, RTA_SRC, spoofss);
d41 1
a41 1
@@@@ -3769,7 +3760,6 @@@@ static const unsigned char *add_exthdr_ancillary(struc
d49 1
a49 1
@@@@ -3785,8 +3775,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d58 1
a58 1
@@@@ -3845,8 +3833,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d67 1
a67 1
@@@@ -4015,9 +4001,6 @@@@ int datalink_offset(int datalink)
d77 1
a77 1
@@@@ -4054,7 +4037,7 @@@@ static int read_reply_pcap(pcap_t *pd, long to_usec,
d86 1
a86 1
@@@@ -4154,10 +4137,6 @@@@ static bool accept_arp(const unsigned char *p, const s
@


1.2
log
@
Major update to 6.01
tests & ok benoit@@, thanks
@
text
@d1 4
a4 4
$OpenBSD$
--- libnetutil/netutil.cc.orig	Fri May 25 11:30:27 2012
+++ libnetutil/netutil.cc	Fri May 25 11:32:11 2012
@@@@ -2997,7 +2997,6 @@@@ static int route_dst_netlink(const struct sockaddr_sto
d12 2
a13 2
@@@@ -3067,22 +3066,14 @@@@ static int route_dst_netlink(const struct sockaddr_sto
     nlmsg->nlmsg_len = NLMSG_ALIGN(nlmsg->nlmsg_len) + rtattr->rta_len;
d35 1
a35 1
@@@@ -3702,7 +3693,6 @@@@ static const unsigned char *add_exthdr_ancillary(struc
d43 1
a43 1
@@@@ -3718,8 +3708,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d52 1
a52 1
@@@@ -3778,8 +3766,6 @@@@ static int send_ipv6_ip(const struct sockaddr_in6 *dst
d61 1
a61 1
@@@@ -3948,9 +3934,6 @@@@ int datalink_offset(int datalink)
d71 1
a71 1
@@@@ -3987,7 +3970,7 @@@@ static int read_reply_pcap(pcap_t *pd, long to_usec,
d80 1
a80 1
@@@@ -4087,10 +4070,6 @@@@ static bool accept_arp(const unsigned char *p, const s
@


1.1
log
@
Update to version 5.51, lot of improvements since latest version,
full changelog available at http://nmap.org/changelog.html
Nping needs a very current libpcap to work as root
@
text
@d2 51
a52 12
--- libnetutil/netutil.cc.orig	Wed Feb  2 16:14:26 2011
+++ libnetutil/netutil.cc	Wed Feb  2 16:15:38 2011
@@@@ -3424,10 +3424,6 @@@@ void set_pcap_filter(const char *device, pcap_t *pd, c
 static bool frame_is_arp(const u8 *frame, int datalink) {
   if (datalink == DLT_EN10MB) {
     return ntohs(*((u16 *) (frame + 12))) == ETH_TYPE_ARP;
-  } else if (datalink == DLT_LINUX_SLL) {
-    return ntohs(*((u16 *) (frame + 2))) == ARPHRD_ETHER && /* sll_hatype */
-      ntohs(*((u16 *) (frame + 4))) == 6 && /* sll_halen */
-      ntohs(*((u16 *) (frame + 14))) == ETH_TYPE_ARP; /* sll_protocol */
   } else {
     return false;
d54 27
a80 1
@@@@ -3472,11 +3468,8 @@@@ int read_arp_reply_pcap(pcap_t *pd, u8 *sendermac,
d83 1
a83 1
     offset = ETH_HDR_LEN;
d85 3
a87 2
-    /* The datalink type is Linux "cooked" sockets. See pcap-linktype(7). */
-    offset = 16;
d89 1
a89 2
-    netutil_fatal("%s called on interface that is datatype %d rather than DLT_EN10MB (%d) or DLT_LINUX_SLL (%d)", __func__, datalink, DLT_EN10MB, DLT_LINUX_SLL);
+    netutil_fatal("%s called on interface that is datatype %d rather than DLT_EN10MB (%d)", __func__, datalink, DLT_EN10MB);
a90 2
 
   if (to_usec > 0) {
@

