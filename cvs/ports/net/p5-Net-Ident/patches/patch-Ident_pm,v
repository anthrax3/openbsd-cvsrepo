head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.1.1.1.0.10
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.6
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.4
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	dlg_20131114:1.1.1.1
	dlg:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2015.09.05.07.25.15;	author benoit;	state Exp;
branches;
next	1.1;
commitid	Z5MaSLTBnOLc4vX9;

1.1
date	2013.11.14.10.09.52;	author dlg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.11.14.10.09.52;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to p5-Net-Ident-1.24.
@
text
@$OpenBSD$
--- Ident.pm.orig	Sun Dec 14 08:08:02 2014
+++ Ident.pm	Sat Sep  5 09:14:17 2015
@@@@ -2,6 +2,7 @@@@
 
 use strict;
 use Socket;
+use Socket::GetAddrInfo qw( getaddrinfo getnameinfo :constants );
 use Fcntl;
 use FileHandle;
 use Carp;
@@@@ -50,12 +51,6 @@@@
     print STDDBG "Debugging turned to level $DEBUG\n";
 }
 
-# protocol number for tcp.
-my $tcpproto = ( getprotobyname('tcp') )[2] || 6;
-
-# get identd port (default to 113).
-my $identport = ( getservbyname( 'ident', 'tcp' ) )[2] || 113;
-
 # what to use to make nonblocking sockets
 my $NONBLOCK = eval "&$Config{o_nonblock}";
 
@@@@ -146,49 +141,81 @@@@
     my ( $class, $localaddr, $remoteaddr, $timeout ) = @@_;
     my $self = {};
 
-    print STDDBG "Net::Ident::newFromInAddr localaddr=", sub { inet_ntoa( $_[1] ) . ":$_[0]" }
-      ->( sockaddr_in($localaddr) ), ", remoteaddr=", sub { inet_ntoa( $_[1] ) . ":$_[0]" }
-      ->( sockaddr_in($remoteaddr) ), ", timeout=", defined $timeout ? $timeout : "<undef>", "\n"
-      if $DEBUG > 1;
+    if ($DEBUG > 1) {
+       my ($err, $lip, $lport, $rip, $rport);
+       ($err, $lip, $lport) = getnameinfo($localaddr, NI_NUMERICHOST|NI_NUMERICSERV, 0);
+       ($err, $rip, $rport) = getnameinfo($remoteaddr, NI_NUMERICHOST|NI_NUMERICSERV, 0);
+       printf STDDBG "Net::Ident::newFromInAddr localaddr=%s port %s remoteaddr=%s port %s defined timeout=%s\n",
+           $lip, $lport, $rip, $rport, defined $timeout ? $timeout : "<undef>";
+    }
 
     eval {
         # unpack addresses and store in
-        my ( $localip, $remoteip );
-        ( $self->{localport},  $localip )  = sockaddr_in($localaddr);
-        ( $self->{remoteport}, $remoteip ) = sockaddr_in($remoteaddr);
+        my($family, $err, $localip, $remoteip, @@res);
+        $family = sockaddr_family($localaddr);
+        if ($family != sockaddr_family($remoteaddr)) {
+            die "= local and remote address family mismatch\n";
+        }
 
-        # create a local binding port. We cannot bind to INADDR_ANY, it has
-        # to be bind (bound?) to the same IP address as the connection we're
-        # interested in on machines with multiple IP addresses
-        my $localbind = sockaddr_in( 0, $localip );
+        ($err, $localip, $self->{localport}) = getnameinfo($localaddr,
+           NI_NUMERICHOST | NI_NUMERICSERV);
+        if ($err) {
+            die "= local getnameinfo failed: $err\n";
+        }
 
+        ($err, $remoteip, $self->{remoteport}) = getnameinfo($remoteaddr,
+            NI_NUMERICHOST | NI_NUMERICSERV);
+        if ($err) {
+            die "= remote getnameinfo failed: $err\n";
+        }
+
         # store max time
         $self->{maxtime} = defined($timeout) ? time + $timeout : undef;
 
-        # create a remote connect point
-        my $identbind = sockaddr_in( $identport, $remoteip );
+        # create a local binding port.
+        ($err, @@res) = getaddrinfo($localip, 0, {
+            flags => AI_PASSIVE|AI_NUMERICHOST,
+            family => $family,
+            socktype => SOCK_STREAM
+        });
+        if ($err) {
+            die "= local getaddrinfo failed: $err\n";
+        }
 
-        # create a new FileHandle
-        $self->{fh} = new FileHandle;
+        for my $ai ( @@res ) {
+            my $fh = new FileHandle;
+            socket($fh, $ai->{family}, $ai->{socktype}, $ai->{protocol})
+                or next;
 
-        # create a stream socket.
-        socket( $self->{fh}, PF_INET, SOCK_STREAM, $tcpproto )
-          or die "= socket failed: $!\n";
+            # bind it to the same IP number as the local end of THESOCK
+            bind($fh, $ai->{addr})
+                or next;
 
-        # bind it to the same IP number as the local end of THESOCK
-        bind( $self->{fh}, $localbind ) or die "= bind failed: $!\n";
+            # make it a non-blocking socket
+            fcntl($fh, F_SETFL, $NONBLOCK) or die "= fcntl failed: $!\n";
 
-        # make it a non-blocking socket
-        if ( $^O ne 'MSWin32' ) {
-            fcntl( $self->{fh}, F_SETFL, $NONBLOCK ) or die "= fcntl failed: $!\n";
+            $self->{fh} = $fh;
+            last;
         }
+        if (!defined($self->{fh})) {
+            die "= unable to bind to $localaddr: $!\n";
+        }
 
-        # connect it to the remote identd port, this can return EINPROGRESS.
-        # for some reason, reading $! twice doesn't work as it should
-        connect( $self->{fh}, $identbind )
-          or $!{EINPROGRESS}
-          or die "= connect failed: $!\n";
-        $self->{fh}->blocking(0) if $^O eq 'MSWin32';
+        # create a remote connect point
+        ($err, @@res) = getaddrinfo($remoteip, 'ident', {
+            flags => AI_NUMERICHOST,
+            family => $family,
+            socktype => SOCK_STREAM
+        });
+        if ($err) {
+            die "= remote getaddrinfo failed: $err\n";
+        }
+
+        for my $ai ( @@res ) {
+            connect($self->{fh}, $ai->{addr}) or $!{EINPROGRESS} or
+                die "= connect failed: $!\n";
+            last;
+        }
     };
     if ( $@@ =~ /^= (.*)/ ) {
 
@@@@ -504,10 +531,13 @@@@
 sub lookupFromInAddr ($$;$) {
     my ( $localaddr, $remoteaddr, $timeout ) = @@_;
 
-    print STDDBG "Net::Ident::lookupFromInAddr localaddr=", sub { inet_ntoa( $_[1] ) . ":$_[0]" }
-      ->( sockaddr_in($localaddr) ), ", remoteaddr=", sub { inet_ntoa( $_[1] ) . ":$_[0]" }
-      ->( sockaddr_in($remoteaddr) ), ", timeout=", defined $timeout ? $timeout : "<undef>", "\n"
-      if $DEBUG > 1;
+    if ($DEBUG > 1) {
+        my ($err, $lip, $lport, $rip, $rport);
+        ($err, $lip, $lport) = getnameinfo($localaddr, NI_NUMERICHOST|NI_NUMERICSERV);
+        ($err, $rip, $rport) = getnameinfo($remoteaddr, NI_NUMERICHOST|NI_NUMERICSERV);
+        printf STDDBG "Net::Ident::lookupFromInAddr localaddr=%s port %s, remoteaddr=%s port %s, timeout=%s\n",
+            $lip, $lport, $rip, $rport, defined $timeout ? $timeout : "<undef>";
+    }
 
     Net::Ident->newFromInAddr( $localaddr, $remoteaddr, $timeout )->username;
 }
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
--- Ident.pm.orig	Wed Nov 13 15:30:45 2013
+++ Ident.pm	Wed Nov 13 17:06:01 2013
@@@@ -2,6 +2,7 @@@@ package Net::Ident;
d12 1
a12 1
@@@@ -50,11 +51,6 @@@@ sub _set_debug {
d17 2
a18 1
-my $tcpproto = (getprotobyname('tcp'))[2] || 6;
d20 1
a20 1
-my $identport = (getservbyname('ident', 'tcp'))[2] || 113;
d25 2
a26 2
@@@@ -138,49 +134,81 @@@@ sub newFromInAddr {
     my($class, $localaddr, $remoteaddr, $timeout) = @@_;
d29 4
a32 8
-    print STDDBG "Net::Ident::newFromInAddr localaddr=",
-	sub { inet_ntoa($_[1]) . ":$_[0]" }->(sockaddr_in($localaddr)),
-	", remoteaddr=",
-	sub { inet_ntoa($_[1]) . ":$_[0]" }->(sockaddr_in($remoteaddr)),
-	", timeout=", 
-        defined $timeout ? $timeout : "<undef>",
-	"\n"
-	if $DEBUG > 1;
d34 5
a38 5
+	my ($err, $lip, $lport, $rip, $rport);
+	($err, $lip, $lport) = getnameinfo($localaddr, NI_NUMERICHOST|NI_NUMERICSERV, 0);
+	($err, $rip, $rport) = getnameinfo($remoteaddr, NI_NUMERICHOST|NI_NUMERICSERV, 0);
+	printf STDDBG "Net::Ident::newFromInAddr localaddr=%s port %s remoteaddr=%s port %s defined timeout=%s\n",
+	    $lip, $lport, $rip, $rport, defined $timeout ? $timeout : "<undef>";
d42 91
a132 96
     	# unpack addresses and store in
-    	my($localip, $remoteip);
-    	($self->{localport}, $localip) = sockaddr_in($localaddr);
-    	($self->{remoteport}, $remoteip) = sockaddr_in($remoteaddr);
-    
-    	# create a local binding port. We cannot bind to INADDR_ANY, it has
-    	# to be bind (bound?) to the same IP address as the connection we're
-    	# interested in on machines with multiple IP addresses
-    	my $localbind = sockaddr_in(0, $localip);
-    
+    	my($family, $err, $localip, $remoteip, @@res);
+	$family = sockaddr_family($localaddr);
+	if ($family != sockaddr_family($remoteaddr)) {
+		die "= local and remote address family mismatch\n";
+	}
+
+	($err, $localip, $self->{localport}) = getnameinfo($localaddr,
+	    NI_NUMERICHOST | NI_NUMERICSERV);
+	if ($err) {
+		die "= local getnameinfo failed: $err\n";
+	}
+
+	($err, $remoteip, $self->{remoteport}) = getnameinfo($remoteaddr,
+	    NI_NUMERICHOST | NI_NUMERICSERV);
+	if ($err) {
+		die "= remote getnameinfo failed: $err\n";
+	}
+
     	# store max time
     	$self->{maxtime} = defined($timeout) ? time + $timeout : undef;
-    
-    	# create a remote connect point
-    	my $identbind = sockaddr_in($identport, $remoteip);
-    
-    	# create a new FileHandle
-    	$self->{fh} = new FileHandle;
-    
-    	# create a stream socket.
-    	socket($self->{fh}, PF_INET, SOCK_STREAM, $tcpproto) or
-    	    die "= socket failed: $!\n";
-    
-    	# bind it to the same IP number as the local end of THESOCK
-    	bind($self->{fh}, $localbind) or die "= bind failed: $!\n";
-    
-    	# make it a non-blocking socket
-    	fcntl($self->{fh}, F_SETFL, $NONBLOCK) or die "= fcntl failed: $!\n";
-    
-    	# connect it to the remote identd port, this can return EINPROGRESS.
-    	# for some reason, reading $! twice doesn't work as it should
-    	connect($self->{fh}, $identbind) or $!{EINPROGRESS} or
-    	  die "= connect failed: $!\n";
+  
+	# create a local binding port.
+	($err, @@res) = getaddrinfo($localip, 0, {
+	    flags => AI_PASSIVE|AI_NUMERICHOST,
+	    family => $family,
+	    socktype => SOCK_STREAM
+	});
+	if ($err) {
+		die "= local getaddrinfo failed: $err\n";
+	}
+
+	for my $ai ( @@res ) {
+		my $fh = new FileHandle;
+		socket($fh, $ai->{family}, $ai->{socktype}, $ai->{protocol})
+		    or next;
+
+		# bind it to the same IP number as the local end of THESOCK
+		bind($fh, $ai->{addr})
+		    or next;
+
+		# make it a non-blocking socket
+		fcntl($fh, F_SETFL, $NONBLOCK) or die "= fcntl failed: $!\n";
+
+		$self->{fh} = $fh;
+		last;
+	}
+	if (!defined($self->{fh})) {
+		die "= unable to bind to $localaddr: $!\n";
+	}
+
+	# create a remote connect point
+	($err, @@res) = getaddrinfo($remoteip, 'ident', {
+	    flags => AI_NUMERICHOST,
+	    family => $family,
+	    socktype => SOCK_STREAM
+	});
+	if ($err) {
+		die "= remote getaddrinfo failed: $err\n";
+	}
+
+	for my $ai ( @@res ) {
+	    	connect($self->{fh}, $ai->{addr}) or $!{EINPROGRESS} or
+	    	  die "= connect failed: $!\n";
+		last;
+	}
d135 2
a136 2
     	# here's the catch of the throw
@@@@ -479,14 +507,13 @@@@ sub lookup ($;$) {
d138 1
a138 1
     my($localaddr, $remoteaddr, $timeout) = @@_;
d140 4
a143 8
-    print STDDBG "Net::Ident::lookupFromInAddr localaddr=",
-	sub { inet_ntoa($_[1]) . ":$_[0]" }->(sockaddr_in($localaddr)),
-	", remoteaddr=",
-	sub { inet_ntoa($_[1]) . ":$_[0]" }->(sockaddr_in($remoteaddr)),
-	", timeout=", 
-        defined $timeout ? $timeout : "<undef>",
-	"\n"
-	if $DEBUG > 1;
d145 5
a149 5
+	my ($err, $lip, $lport, $rip, $rport);
+	($err, $lip, $lport) = getnameinfo($localaddr, NI_NUMERICHOST|NI_NUMERICSERV);
+	($err, $rip, $rport) = getnameinfo($remoteaddr, NI_NUMERICHOST|NI_NUMERICSERV);
+	printf STDDBG "Net::Ident::lookupFromInAddr localaddr=%s port %s, remoteaddr=%s port %s, timeout=%s\n",
+	    $lip, $lport, $rip, $rport, defined $timeout ? $timeout : "<undef>";
d152 1
a152 1
     Net::Ident->newFromInAddr($localaddr, $remoteaddr, $timeout)->username;
@


1.1.1.1
log
@import Net::Ident

this includes a patch that rewrites the socket bits so it can support v6
lookups as well as v4.

tweaks from benoit@@ and sthen@@, ok sthen@@
@
text
@@
