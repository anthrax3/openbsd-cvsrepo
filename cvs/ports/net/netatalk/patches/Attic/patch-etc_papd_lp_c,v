head	1.3;
access;
symbols
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.12
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.10
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.8
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.6
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.4
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.2
	OPENBSD_4_1_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2012.04.11.18.39.13;	author sthen;	state dead;
branches;
next	1.2;

1.2
date	2009.08.14.19.09.22;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.22.05.56.25;	author pvalchev;	state Exp;
branches
	1.1.10.1
	1.1.12.1;
next	;

1.1.10.1
date	2009.08.13.02.55.14;	author william;	state Exp;
branches;
next	;

1.1.12.1
date	2009.10.31.04.07.54;	author william;	state Exp;
branches;
next	;


desc
@@


1.3
log
@update to netatalk 2.2.2, from Brad, tested by william@@ and Ian McWilliam
- support for MacOS X Lion and TimeMachine
- add rc scripts
@
text
@$OpenBSD: patch-etc_papd_lp_c,v 1.2 2009/08/14 19:09:22 naddy Exp $

First 3 chunks resolve CVE-2008-5718

--- etc/papd/lp.c.orig	Tue Jun  8 22:24:47 2004
+++ etc/papd/lp.c	Sat Jul 25 11:02:06 2009
@@@@ -212,10 +212,37 @@@@ static void lp_setup_comments (charset_t dest)
 
 #define is_var(a, b) (strncmp((a), (b), 2) == 0)
 
+static size_t quote(char *dest, char *src, const size_t bsize, size_t len)
+{
+size_t used = 0;
+
+    while (len && used < bsize ) {
+        switch (*src) {
+          case '$':
+          case '\\':
+          case '"':
+          case '`':
+            if (used + 2 > bsize )
+              return used;
+            *dest = '\\';
+            dest++;
+            used++;
+            break;
+        }
+        *dest = *src;
+        src++;
+        dest++;
+        len--;
+        used++;
+    }
+    return used;
+}
+
+
 static char* pipexlate(char *src)
 {
     char *p, *q, *dest; 
-    static char destbuf[MAXPATHLEN];
+    static char destbuf[MAXPATHLEN +1];
     size_t destlen = MAXPATHLEN;
     int len = 0;
    
@@@@ -224,13 +251,15 @@@@ static char* pipexlate(char *src)
     if (!src)
 	return NULL;
 
-    strncpy(dest, src, MAXPATHLEN);
-    if ((p = strchr(src, '%')) == NULL) /* nothing to do */
+    memset(dest, 0, MAXPATHLEN +1);
+    if ((p = strchr(src, '%')) == NULL) { /* nothing to do */
+        strncpy(dest, src, MAXPATHLEN);
         return destbuf;
-
-    /* first part of the path. just forward to the next variable. */
+    }
+    /* first part of the path. copy and forward to the next variable. */
     len = MIN((size_t)(p - src), destlen);
     if (len > 0) {
+        strncpy(dest, src, len);
         destlen -= len;
         dest += len;
     }
@@@@ -246,17 +275,20 @@@@ static char* pipexlate(char *src)
             q =  lp.lp_created_for;
         } else if (is_var(p, "%%")) {
             q = "%";
-        } else
-            q = p;
+        } 
 
         /* copy the stuff over. if we don't understand something that we
          * should, just skip it over. */
         if (q) {
-            len = MIN(p == q ? 2 : strlen(q), destlen);
+            len = MIN(strlen(q), destlen);
+            len = quote(dest, q, destlen, len);
+        }
+        else {
+            len = MIN(2, destlen);
             strncpy(dest, q, len);
-            dest += len;
-            destlen -= len;
         }
+        dest += len;
+        destlen -= len;
 
         /* stuff up to next $ */
         src = p + 2;
@@@@ -377,7 +409,7 @@@@ int lp_init( out, sat )
 	    FILE *cap_file;
 
 	    memset( auth_string, 0, 256 );
-	    sprintf(addr_filename, "%s/net%d.%dnode%d", 
+	    snprintf(addr_filename, sizeof(addr_filename), "%s/net%d.%dnode%d", 
 		printer->p_authprintdir, addr_net/256, addr_net%256, 
 		addr_node);
 	    if (stat(addr_filename, &cap_st) == 0) {
@@@@ -489,7 +521,7 @@@@ int lp_init( out, sat )
 	lp.lp_seq = n;
 
 	n = ( n + 1 ) % 1000;
-	sprintf( buf, "%03d\n", n );
+	snprintf( buf, sizeof(buf), "%03d\n", n );
 	lseek( fd, 0L, 0 );
 	write( fd, buf, strlen( buf ));
 	close( fd );
@@@@ -558,7 +590,7 @@@@ int lp_open( out, sat )
 	}
         LOG(log_debug, logtype_papd, "lp_open: opened %s",  pipexlate(printer->p_printer) );
     } else {
-	sprintf( name, "df%c%03d%s", lp.lp_letter++, lp.lp_seq, hostname );
+	snprintf( name, sizeof(name), "df%c%03d%s", lp.lp_letter++, lp.lp_seq, hostname );
 
 	if (( fd = open( name, O_WRONLY|O_CREAT|O_EXCL, 0660 )) < 0 ) {
 	    LOG(log_error, logtype_papd, "lp_open %s: %m", name );
@@@@ -719,7 +751,7 @@@@ int lp_cancel()
     }
 
     for ( letter = 'A'; letter < lp.lp_letter; letter++ ) {
-	sprintf( name, "df%c%03d%s", letter, lp.lp_seq, hostname );
+	snprintf( name, sizeof(name), "df%c%03d%s", letter, lp.lp_seq, hostname );
 	if ( unlink( name ) < 0 ) {
 	    LOG(log_error, logtype_papd, "lp_cancel unlink %s: %m", name );
 	}
@@@@ -753,7 +785,7 @@@@ int lp_print()
 
     if ( printer->p_flags & P_SPOOLED ) {
 #ifndef HAVE_CUPS
-	sprintf( tfname, "tfA%03d%s", lp.lp_seq, hostname );
+	snprintf( tfname, sizeof(tfname), "tfA%03d%s", lp.lp_seq, hostname );
 	if (( fd = open( tfname, O_WRONLY|O_EXCL|O_CREAT, 0660 )) < 0 ) {
 	    LOG(log_error, logtype_papd, "lp_print %s: %m", tfname );
 	    return 0;
@@@@ -798,7 +830,7 @@@@ int lp_print()
 	}
 	fclose( cfile );
 
-	sprintf( cfname, "cfA%03d%s", lp.lp_seq, hostname );
+	snprintf( cfname, sizeof(cfname), "cfA%03d%s", lp.lp_seq, hostname );
 	if ( link( tfname, cfname ) < 0 ) {
 	    LOG(log_error, logtype_papd, "lp_print can't link %s to %s: %m", cfname,
 		    tfname );
@@@@ -811,7 +843,7 @@@@ int lp_print()
 	    return 0;
 	}
 
-	sprintf( buf, "\1%s\n", printer->p_printer );
+	snprintf( buf, sizeof(buf), "\1%s\n", printer->p_printer );
 	n = strlen( buf );
 	if ( write( s, buf, n ) != n ) {
 	    LOG(log_error, logtype_papd, "lp_print write: %m" );
@@@@ -944,7 +976,7 @@@@ int lp_rmjob( job )
 	return( -1 );
     }
 
-    sprintf( buf, "\5%s %s %d\n", printer->p_printer, lp.lp_person, job );
+    snprintf( buf, sizeof(buf), "\5%s %s %d\n", printer->p_printer, lp.lp_person, job );
     n = strlen( buf );
     if ( write( s, buf, n ) != n ) {
 	LOG(log_error, logtype_papd, "lp_rmjob write: %m" );
@@@@ -982,7 +1014,7 @@@@ int lp_queue( out )
 	return( -1 );
     }
 
-    sprintf( buf, "\3%s\n", printer->p_printer );
+    snprintf( buf, sizeof(buf), "\3%s\n", printer->p_printer );
     n = strlen( buf );
     if ( write( s, buf, n ) != n ) {
 	LOG(log_error, logtype_papd, "lp_queue write: %m" );
@


1.2
log
@SECURITY FIX
Resolves CVE-2008-5718, diff from upstream

reminded by Brad
@
text
@d1 1
a1 1
$OpenBSD: patch-etc_papd_lp_c,v 1.1.10.1 2009/08/13 02:55:14 william Exp $
@


1.1
log
@Update to netatalk-2.0.3 and get rid of old directory structure.
A long due update with important features such as long filenames,
unicode, etc.
From new maintainer "Arnaud Bergeron" <abergeron@@gmail.com>
@
text
@d1 4
a4 1
$OpenBSD$
d6 87
a92 2
+++ etc/papd/lp.c	Sat Dec 31 01:31:29 2005
@@@@ -377,7 +377,7 @@@@ int lp_init( out, sat )
d101 1
a101 1
@@@@ -489,7 +489,7 @@@@ int lp_init( out, sat )
d110 1
a110 1
@@@@ -558,7 +558,7 @@@@ int lp_open( out, sat )
d119 1
a119 1
@@@@ -719,7 +719,7 @@@@ int lp_cancel()
d128 1
a128 1
@@@@ -753,7 +753,7 @@@@ int lp_print()
d137 1
a137 1
@@@@ -798,7 +798,7 @@@@ int lp_print()
d146 1
a146 1
@@@@ -811,7 +811,7 @@@@ int lp_print()
d155 1
a155 1
@@@@ -944,7 +944,7 @@@@ int lp_rmjob( job )
d164 1
a164 1
@@@@ -982,7 +982,7 @@@@ int lp_queue( out )
@


1.1.12.1
log
@SECURITY FIX

Resolves CVE-2008-5718, diff from upstream
@
text
@d1 1
a1 4
$OpenBSD: patch-etc_papd_lp_c,v 1.2 2009/08/14 19:09:22 naddy Exp $

First 3 chunks resolve CVE-2008-5718

d3 2
a4 87
+++ etc/papd/lp.c	Sat Jul 25 11:02:06 2009
@@@@ -212,10 +212,37 @@@@ static void lp_setup_comments (charset_t dest)
 
 #define is_var(a, b) (strncmp((a), (b), 2) == 0)
 
+static size_t quote(char *dest, char *src, const size_t bsize, size_t len)
+{
+size_t used = 0;
+
+    while (len && used < bsize ) {
+        switch (*src) {
+          case '$':
+          case '\\':
+          case '"':
+          case '`':
+            if (used + 2 > bsize )
+              return used;
+            *dest = '\\';
+            dest++;
+            used++;
+            break;
+        }
+        *dest = *src;
+        src++;
+        dest++;
+        len--;
+        used++;
+    }
+    return used;
+}
+
+
 static char* pipexlate(char *src)
 {
     char *p, *q, *dest; 
-    static char destbuf[MAXPATHLEN];
+    static char destbuf[MAXPATHLEN +1];
     size_t destlen = MAXPATHLEN;
     int len = 0;
    
@@@@ -224,13 +251,15 @@@@ static char* pipexlate(char *src)
     if (!src)
 	return NULL;
 
-    strncpy(dest, src, MAXPATHLEN);
-    if ((p = strchr(src, '%')) == NULL) /* nothing to do */
+    memset(dest, 0, MAXPATHLEN +1);
+    if ((p = strchr(src, '%')) == NULL) { /* nothing to do */
+        strncpy(dest, src, MAXPATHLEN);
         return destbuf;
-
-    /* first part of the path. just forward to the next variable. */
+    }
+    /* first part of the path. copy and forward to the next variable. */
     len = MIN((size_t)(p - src), destlen);
     if (len > 0) {
+        strncpy(dest, src, len);
         destlen -= len;
         dest += len;
     }
@@@@ -246,17 +275,20 @@@@ static char* pipexlate(char *src)
             q =  lp.lp_created_for;
         } else if (is_var(p, "%%")) {
             q = "%";
-        } else
-            q = p;
+        } 
 
         /* copy the stuff over. if we don't understand something that we
          * should, just skip it over. */
         if (q) {
-            len = MIN(p == q ? 2 : strlen(q), destlen);
+            len = MIN(strlen(q), destlen);
+            len = quote(dest, q, destlen, len);
+        }
+        else {
+            len = MIN(2, destlen);
             strncpy(dest, q, len);
-            dest += len;
-            destlen -= len;
         }
+        dest += len;
+        destlen -= len;
 
         /* stuff up to next $ */
         src = p + 2;
@@@@ -377,7 +409,7 @@@@ int lp_init( out, sat )
d13 1
a13 1
@@@@ -489,7 +521,7 @@@@ int lp_init( out, sat )
d22 1
a22 1
@@@@ -558,7 +590,7 @@@@ int lp_open( out, sat )
d31 1
a31 1
@@@@ -719,7 +751,7 @@@@ int lp_cancel()
d40 1
a40 1
@@@@ -753,7 +785,7 @@@@ int lp_print()
d49 1
a49 1
@@@@ -798,7 +830,7 @@@@ int lp_print()
d58 1
a58 1
@@@@ -811,7 +843,7 @@@@ int lp_print()
d67 1
a67 1
@@@@ -944,7 +976,7 @@@@ int lp_rmjob( job )
d76 1
a76 1
@@@@ -982,7 +1014,7 @@@@ int lp_queue( out )
@


1.1.10.1
log
@SECURITY FIX

Resolves CVE-2008-5718, diff from upstream

ok robert@@
@
text
@d1 1
a1 4
$OpenBSD: patch-etc_papd_lp_c,v 1.1 2006/09/22 05:56:25 pvalchev Exp $

First 3 chunks resolve CVE-2008-5718

d3 2
a4 87
+++ etc/papd/lp.c	Sat Jul 25 11:02:06 2009
@@@@ -212,10 +212,37 @@@@ static void lp_setup_comments (charset_t dest)
 
 #define is_var(a, b) (strncmp((a), (b), 2) == 0)
 
+static size_t quote(char *dest, char *src, const size_t bsize, size_t len)
+{
+size_t used = 0;
+
+    while (len && used < bsize ) {
+        switch (*src) {
+          case '$':
+          case '\\':
+          case '"':
+          case '`':
+            if (used + 2 > bsize )
+              return used;
+            *dest = '\\';
+            dest++;
+            used++;
+            break;
+        }
+        *dest = *src;
+        src++;
+        dest++;
+        len--;
+        used++;
+    }
+    return used;
+}
+
+
 static char* pipexlate(char *src)
 {
     char *p, *q, *dest; 
-    static char destbuf[MAXPATHLEN];
+    static char destbuf[MAXPATHLEN +1];
     size_t destlen = MAXPATHLEN;
     int len = 0;
    
@@@@ -224,13 +251,15 @@@@ static char* pipexlate(char *src)
     if (!src)
 	return NULL;
 
-    strncpy(dest, src, MAXPATHLEN);
-    if ((p = strchr(src, '%')) == NULL) /* nothing to do */
+    memset(dest, 0, MAXPATHLEN +1);
+    if ((p = strchr(src, '%')) == NULL) { /* nothing to do */
+        strncpy(dest, src, MAXPATHLEN);
         return destbuf;
-
-    /* first part of the path. just forward to the next variable. */
+    }
+    /* first part of the path. copy and forward to the next variable. */
     len = MIN((size_t)(p - src), destlen);
     if (len > 0) {
+        strncpy(dest, src, len);
         destlen -= len;
         dest += len;
     }
@@@@ -246,17 +275,20 @@@@ static char* pipexlate(char *src)
             q =  lp.lp_created_for;
         } else if (is_var(p, "%%")) {
             q = "%";
-        } else
-            q = p;
+        } 
 
         /* copy the stuff over. if we don't understand something that we
          * should, just skip it over. */
         if (q) {
-            len = MIN(p == q ? 2 : strlen(q), destlen);
+            len = MIN(strlen(q), destlen);
+            len = quote(dest, q, destlen, len);
+        }
+        else {
+            len = MIN(2, destlen);
             strncpy(dest, q, len);
-            dest += len;
-            destlen -= len;
         }
+        dest += len;
+        destlen -= len;
 
         /* stuff up to next $ */
         src = p + 2;
@@@@ -377,7 +409,7 @@@@ int lp_init( out, sat )
d13 1
a13 1
@@@@ -489,7 +521,7 @@@@ int lp_init( out, sat )
d22 1
a22 1
@@@@ -558,7 +590,7 @@@@ int lp_open( out, sat )
d31 1
a31 1
@@@@ -719,7 +751,7 @@@@ int lp_cancel()
d40 1
a40 1
@@@@ -753,7 +785,7 @@@@ int lp_print()
d49 1
a49 1
@@@@ -798,7 +830,7 @@@@ int lp_print()
d58 1
a58 1
@@@@ -811,7 +843,7 @@@@ int lp_print()
d67 1
a67 1
@@@@ -944,7 +976,7 @@@@ int lp_rmjob( job )
d76 1
a76 1
@@@@ -982,7 +1014,7 @@@@ int lp_queue( out )
@

