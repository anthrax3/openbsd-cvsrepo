head	1.2;
access;
symbols
	OPENBSD_3_1:1.1.0.10
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.8
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2002.07.23.11.54.37;	author naddy;	state dead;
branches;
next	1.1;

1.1
date	99.12.15.02.56.52;	author kevlo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Finish netatalk reorganization and update.
Submitted by maintainer Ian McWilliam <i.mcwilliam@@uws.edu.au>.
@
text
@--- etc/papd/session.c.orig	Thu Sep 24 00:15:11 1998
+++ etc/papd/session.c	Fri Nov 19 15:43:43 1999
@@@@ -7,6 +7,9 @@@@
 #include <sys/syslog.h>
 #include <sys/time.h>
 #include <sys/uio.h>
+#include <string.h>
+#include <unistd.h>
+#include <netatalk/endian.h>
 #include <netatalk/at.h>
 #include <atalk/atp.h>
 #include <atalk/pap.h>
@@@@ -14,6 +17,8 @@@@
 #include "file.h"
 
 extern unsigned char	connid, quantum, oquantum;
+extern int		lp_cancel(), lp_print();
+extern int		ps();
 
 char		buf[ PAP_MAXQUANTUM ][ 4 + PAP_MAXDATA ];
 struct iovec	niov[ PAP_MAXQUANTUM ] = {
@@@@ -42,6 +47,7 @@@@
  * Read lines of a file, until the client sends eof, after
  * which we'll send eof also.
  */
+int
 session( atp, sat )
     ATP			atp;
     struct sockaddr_at	*sat;
@@@@ -53,8 +59,8 @@@@
     fd_set		fds;
     char		cbuf[ 578 ];
     int			i, cc, timeout = 0, readpending = 0;
-    u_short		seq = 1, rseq = 1, netseq;
-    u_char		readport;
+    u_int16_t		seq = 0, rseq =1, netseq;
+    u_int8_t		readport;
 
     infile.pf_state = PF_BOT;
     infile.pf_len = 0;
@@@@ -73,9 +79,9 @@@@
      */
     cbuf[ 0 ] = connid;
     cbuf[ 1 ] = PAP_READ;
-    if ( seq++ == 0xffff ) seq = 1;
+    if ( ++seq == 0 ) seq = 1;
     netseq = htons( seq );
-    bcopy( &netseq, &cbuf[ 2 ], sizeof( netseq ));
+    memcpy( &cbuf[ 2 ], &netseq, sizeof( netseq ));
     atpb.atp_saddr = sat;
     atpb.atp_sreqdata = cbuf;
     atpb.atp_sreqdlen = 4;		/* bytes in SendData request */
@@@@ -130,7 +136,7 @@@@
 	    timeout = 0;
 	}
 
-	bzero( &ssat, sizeof( struct sockaddr_at ));
+	memset( &ssat, 0, sizeof( struct sockaddr_at ));
 	switch( atp_rsel( atp, &ssat, ATP_TRESP | ATP_TREQ )) {
 	case ATP_TREQ :
 	    atpb.atp_saddr = &ssat;
@@@@ -151,7 +157,7 @@@@
 		/*
 		 * Other side is ready for some data.
 		 */
-		bcopy( &cbuf[ 2 ], &netseq, sizeof( netseq ));
+		memcpy( &netseq, &cbuf[ 2 ], sizeof( netseq ));
 		if ( netseq != 0 ) {
 		    if ( rseq != ntohs( netseq )) {
 			break;
@@@@ -236,9 +242,9 @@@@
 	     */
 	    cbuf[ 0 ] = connid;
 	    cbuf[ 1 ] = PAP_READ;
-	    if ( seq++ == 0xffff ) seq = 1;
+	    if ( ++seq == 0 ) seq = 1;
 	    netseq = htons( seq );
-	    bcopy( &netseq, &cbuf[ 2 ], sizeof( netseq ));
+	    memcpy( &cbuf[ 2 ], &netseq, sizeof( netseq ));
 	    atpb.atp_saddr = sat;
 	    atpb.atp_sreqdata = cbuf;
 	    atpb.atp_sreqdlen = 4;		/* bytes in SendData request */
@@@@ -279,8 +285,8 @@@@
 		}
 
 		niov[ i ].iov_len = 4 + cc;
-		bcopy( outfile.pf_cur, niov[ i ].iov_base + 4, cc );
-		CONSUME( &outfile, cc );
+		memcpy( niov[ i ].iov_base + 4, outfile.pf_cur, cc );
+		(void)CONSUME( &outfile, cc );
 		if ( PF_BUFSIZ( &outfile ) == 0 ) {
 		    i++;
 		    break;
@


1.1
log
@95% of the warnings are fixed. Port no longer destroys /etc/netatalk/rc.atalk
if it exists.
@
text
@@

