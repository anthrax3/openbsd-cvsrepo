head	1.2;
access;
symbols
	OPENBSD_5_1:1.2.0.2
	OPENBSD_3_9:1.1.1.1.0.2
	OPENBSD_3_9_BASE:1.1.1.1
	jolan_2005-oct-19:1.1.1.1
	jolan:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2006.06.03.03.05.41;	author jolan;	state dead;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.10.20.04.20.28;	author jolan;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.10.20.04.20.28;	author jolan;	state Exp;
branches;
next	;

1.2.2.1
date	2012.04.12.09.02.15;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.2
log
@these should have been removed along with the update

from dennis suhonin
@
text
@$OpenBSD: patch-src_common_logger_py,v 1.1 2005/10/20 04:20:28 jolan Exp $
--- src/common/logger.py.orig	Tue Sep  6 12:30:14 2005
+++ src/common/logger.py	Wed Oct 19 01:37:07 2005
@@@@ -36,7 +36,10 @@@@ if os.name == 'nt':
 		# win9x, ./logs
 		LOGPATH = 'Logs'
 
-LOGPATH = LOGPATH.decode(sys.getfilesystemencoding())
+try:
+	LOGPATH = LOGPATH.decode(sys.getfilesystemencoding())
+except:
+	pass
 
 class Logger:
 	def __init__(self):
@


1.2.2.1
log
@    security fix for CVE-2012-2085/CVE-2012-2086.
	ok pea@@ (MAINTAINER)
@
text
@d1 12
a12 15
$OpenBSD$

use prepared statements in all SQL queries that contains jids to prevent SQL injection.

From upstream changeset: bfd5f94489d8
Fixes CVE-2012-2085

--- src/common/logger.py.orig	Tue Apr 10 10:41:43 2012
+++ src/common/logger.py	Tue Apr 10 10:47:24 2012
@@@@ -563,7 +563,7 @@@@ class Logger:
         except exceptions.PysqliteOperationalError, e:
             # Error trying to create a new jid_id. This means there is no log
             return []
-        where_sql = self._build_contact_where(account, jid)
+        where_sql, jid_tuple = self._build_contact_where(account, jid)
d14 2
a15 145
         now = int(float(time.time()))
         timed_out = now - (timeout * 60) # before that they are too old
@@@@ -571,14 +571,13 @@@@ class Logger:
         # 3 - 8 (we avoid the last 2 lines but we still return 5 asked)
         try:
             self.cur.execute('''
-                    SELECT time, kind, message FROM logs
-                    WHERE (%s) AND kind IN (%d, %d, %d, %d, %d) AND time > %d
-                    ORDER BY time DESC LIMIT %d OFFSET %d
-                    ''' % (where_sql, constants.KIND_SINGLE_MSG_RECV,
-                            constants.KIND_CHAT_MSG_RECV, constants.KIND_SINGLE_MSG_SENT,
-                            constants.KIND_CHAT_MSG_SENT, constants.KIND_ERROR,
-                            timed_out, restore_how_many_rows, pending_how_many)
-                    )
+                SELECT time, kind, message FROM logs
+                WHERE (%s) AND kind IN (%d, %d, %d, %d, %d) AND time > %d
+                ORDER BY time DESC LIMIT %d OFFSET %d
+                ''' % (where_sql, constants.KIND_SINGLE_MSG_RECV,
+                constants.KIND_CHAT_MSG_RECV, constants.KIND_SINGLE_MSG_SENT,
+                constants.KIND_CHAT_MSG_SENT, constants.KIND_ERROR, timed_out,
+                restore_how_many_rows, pending_how_many), jid_tuple)
 
             results = self.cur.fetchall()
         except sqlite.DatabaseError:
@@@@ -608,18 +607,18 @@@@ class Logger:
         except exceptions.PysqliteOperationalError, e:
             # Error trying to create a new jid_id. This means there is no log
             return []
-        where_sql = self._build_contact_where(account, jid)
+	where_sql, jid_tuple = self._build_contact_where(account, jid)
 
         start_of_day = self.get_unix_time_from_date(year, month, day)
         seconds_in_a_day = 86400 # 60 * 60 * 24
         last_second_of_day = start_of_day + seconds_in_a_day - 1
 
         self.cur.execute('''
-                SELECT contact_name, time, kind, show, message, subject FROM logs
-                WHERE (%s)
-                AND time BETWEEN %d AND %d
-                ORDER BY time
-                ''' % (where_sql, start_of_day, last_second_of_day))
+            SELECT contact_name, time, kind, show, message, subject FROM logs
+            WHERE (%s)
+            AND time BETWEEN %d AND %d
+            ORDER BY time
+            ''' % (where_sql, start_of_day, last_second_of_day), jid_tuple)
 
         results = self.cur.fetchall()
         return results
@@@@ -645,13 +644,13 @@@@ class Logger:
                 return results
 
         else: # user just typed something, we search in message column
-            where_sql = self._build_contact_where(account, jid)
+            where_sql, jid_tuple = self._build_contact_where(account, jid)
             like_sql = '%' + query.replace("'", "''") + '%'
             self.cur.execute('''
-                    SELECT contact_name, time, kind, show, message, subject FROM logs
-                    WHERE (%s) AND message LIKE '%s'
-                    ORDER BY time
-                    ''' % (where_sql, like_sql))
+                SELECT contact_name, time, kind, show, message, subject FROM logs
+                WHERE (%s) AND message LIKE '%s'
+                ORDER BY time
+                ''' % (where_sql, like_sql), jid_tuple)
 
         results = self.cur.fetchall()
         return results
@@@@ -666,7 +665,7 @@@@ class Logger:
             # Error trying to create a new jid_id. This means there is no log
             return []
         days_with_logs = []
-        where_sql = self._build_contact_where(account, jid)
+        where_sql, jid_tuple = self._build_contact_where(account, jid)
 
         # First select all date of month whith logs we want
         start_of_month = self.get_unix_time_from_date(year, month, 1)
@@@@ -678,13 +677,13 @@@@ class Logger:
         # and take only one of the same values (distinct)
         # Now we have timestamps of time 0:00 of every day with logs
         self.cur.execute('''
-                SELECT DISTINCT time/(86400)*86400 FROM logs
-                WHERE (%s)
-                AND time BETWEEN %d AND %d
-                AND kind NOT IN (%d, %d)
-                ORDER BY time
-                ''' % (where_sql, start_of_month, last_second_of_month,
-                constants.KIND_STATUS, constants.KIND_GCSTATUS))
+            SELECT DISTINCT time/(86400)*86400 FROM logs
+            WHERE (%s)
+            AND time BETWEEN %d AND %d
+            AND kind NOT IN (%d, %d)
+            ORDER BY time
+            ''' % (where_sql, start_of_month, last_second_of_month,
+            constants.KIND_STATUS, constants.KIND_GCSTATUS), jid_tuple)
         result = self.cur.fetchall()
 
         # convert timestamps to day of month
@@@@ -707,12 +706,14 @@@@ class Logger:
             except exceptions.PysqliteOperationalError, e:
                 # Error trying to create a new jid_id. This means there is no log
                 return None
-            where_sql = 'jid_id = %s' % jid_id
+            where_sql = 'jid_id = ?'
+            jid_tuple = (jid_id,)
         self.cur.execute('''
-                SELECT MAX(time) FROM logs
-                WHERE (%s)
-                AND kind NOT IN (%d, %d)
-                ''' % (where_sql, constants.KIND_STATUS, constants.KIND_GCSTATUS))
+            SELECT MAX(time) FROM logs
+            WHERE (%s)
+            AND kind NOT IN (%d, %d)
+            ''' % (where_sql, constants.KIND_STATUS, constants.KIND_GCSTATUS),
+            jid_tuple)
 
         results = self.cur.fetchone()
         if results is not None:
@@@@ -760,6 +761,7 @@@@ class Logger:
         Build the where clause for a jid, including metacontacts jid(s) if any
         """
         where_sql = ''
+	jid_tuple = ()
         # will return empty list if jid is not associated with
         # any metacontacts
         family = gajim.contacts.get_metacontacts_family(account, jid)
@@@@ -769,13 +771,15 @@@@ class Logger:
                     jid_id = self.get_jid_id(user['jid'])
                 except exceptions.PysqliteOperationalError, e:
                     continue
-                where_sql += 'jid_id = %s' % jid_id
+                where_sql += 'jid_id = ?'
+                jid_tuple += (jid_id,)
                 if user != family[-1]:
                     where_sql += ' OR '
         else: # if jid was not associated with metacontacts
             jid_id = self.get_jid_id(jid)
-            where_sql = 'jid_id = %s' % jid_id
-        return where_sql
+            where_sql = 'jid_id = ?'
+            jid_tuple += (jid_id,)
+        return where_sql, jid_tuple
 
     def save_transport_type(self, jid, type_):
         """
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.1.1
log
@gajim-0.8.2, jabber client written in PyGtk

thanks to fgsch@@ for the python help/patches
@
text
@@
