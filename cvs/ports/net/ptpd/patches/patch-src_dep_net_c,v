head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.32
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.28
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.30
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.26
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.24
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.22
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.20
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.18
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.16
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.14
	OPENBSD_5_0:1.1.1.1.0.12
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.10
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.6
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.4
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	naddy_20090120:1.1.1.1
	naddy:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2009.01.20.19.05.23;	author naddy;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.01.20.19.05.23;	author naddy;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$
--- src/dep/net.c.orig	Mon Apr  2 23:57:44 2007
+++ src/dep/net.c	Sun Oct 26 13:38:49 2008
@@@@ -8,26 +8,26 @@@@ Boolean lookupSubdomainAddress(Octet *subdomainName, O
   
   /* set multicast group address based on subdomainName */
   if (!memcmp(subdomainName, DEFAULT_PTP_DOMAIN_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-    memcpy(subdomainAddress, DEFAULT_PTP_DOMAIN_ADDRESS, NET_ADDRESS_LENGTH);
+    strncpy(subdomainAddress, DEFAULT_PTP_DOMAIN_ADDRESS, NET_ADDRESS_LENGTH);
   else if(!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN1_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-    memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
+    strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
   else if(!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN2_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-    memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
+    strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
   else if(!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN3_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-    memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
+    strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
   else
   {
     h = crc_algorithm(subdomainName, PTP_SUBDOMAIN_NAME_LENGTH) % 3;
     switch(h)
     {
     case 0:
-      memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
+      strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
       break;
     case 1:
-      memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
+      strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
       break;
     case 2:
-      memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
+      strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
       break;
     default:
       ERROR("handle out of range for '%s'!\n", subdomainName);
@@@@ -229,6 +229,7 @@@@ Boolean netInit(NetPath *netPath, RunTimeOpts *rtOpts,
   struct in_addr interfaceAddr, netAddr;
   struct sockaddr_in addr;
   struct ip_mreq imr;
+  unsigned char c;
   char addrStr[NET_ADDRESS_LENGTH];
   char *s;
   
@@@@ -332,18 +333,18 @@@@ Boolean netInit(NetPath *netPath, RunTimeOpts *rtOpts,
   }
 
   /* set socket time-to-live to 1 */
-  temp = 1;
-  if( setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_TTL, &temp, sizeof(int)) < 0
-    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_TTL, &temp, sizeof(int)) < 0 )
+  c = 1;
+  if( setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_TTL, &c, sizeof(c)) < 0
+    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_TTL, &c, sizeof(c)) < 0 )
   {
     PERROR("failed to set the multi-cast time-to-live");
     return FALSE;
   }
   
   /* enable loopback */
-  temp = 1;
-  if( setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_LOOP, &temp, sizeof(int)) < 0
-    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_LOOP, &temp, sizeof(int)) < 0 )
+  c = 1;
+  if( setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_LOOP, &c, sizeof(c)) < 0
+    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_LOOP, &c, sizeof(c)) < 0 )
   {
     PERROR("failed to enable multi-cast loopback");
     return FALSE;
@


1.1.1.1
log
@Import ptpd 1.0.0

The PTP daemon (PTPd) implements the Precision Time protocol (PTP) as
defined by the IEEE 1588 standard. PTP was developed to provide very
precise time coordination of LAN connected computers.

with ckuethe@@
@
text
@@
