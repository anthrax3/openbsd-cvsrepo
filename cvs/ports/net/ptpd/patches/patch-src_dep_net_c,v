head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.1.1.1.0.34
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.32
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.28
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.30
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.26
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.24
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.22
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.20
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.18
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.16
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.14
	OPENBSD_5_0:1.1.1.1.0.12
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.10
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.6
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.4
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	naddy_20090120:1.1.1.1
	naddy:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2017.09.09.21.22.49;	author naddy;	state Exp;
branches;
next	1.1;
commitid	JfjQznIXnlRBDFDh;

1.1
date	2009.01.20.19.05.23;	author naddy;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.01.20.19.05.23;	author naddy;	state Exp;
branches;
next	;


desc
@@


1.2
log
@* Update to 1.1.0.
* Replace MESSAGE with rc file.
* Drop maintainership.
* Set PORTROACH.

ptpd-1.x implements PTPv1 (IEEE 1588-2002)
ptpd-2.x implements PTPv2 (IEEE 1588-2008)
PTPv2 is not backward compatible with PTPv1.
@
text
@$OpenBSD: patch-src_dep_net_c,v 1.1.1.1 2009/01/20 19:05:23 naddy Exp $
Index: src/dep/net.c
--- src/dep/net.c.orig
+++ src/dep/net.c
@@@@ -16,24 +16,24 @@@@ lookupSubdomainAddress(Octet * subdomainName, Octet * 
 
 	/* set multicast group address based on subdomainName */
 	if (!memcmp(subdomainName, DEFAULT_PTP_DOMAIN_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-		memcpy(subdomainAddress, DEFAULT_PTP_DOMAIN_ADDRESS, NET_ADDRESS_LENGTH);
+		strncpy(subdomainAddress, DEFAULT_PTP_DOMAIN_ADDRESS, NET_ADDRESS_LENGTH);
 	else if (!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN1_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-		memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
+		strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
 	else if (!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN2_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-		memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
+		strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
 	else if (!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN3_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-		memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
+		strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
 	else {
 		h = crc_algorithm(subdomainName, PTP_SUBDOMAIN_NAME_LENGTH) % 3;
 		switch (h) {
 		case 0:
-			memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
+			strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
 			break;
 		case 1:
-			memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
+			strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
 			break;
 		case 2:
-			memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
+			strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
 			break;
 		default:
 			ERROR("handle out of range for '%s'!\n", subdomainName);
@@@@ -217,6 +217,7 @@@@ netInit(NetPath * netPath, RunTimeOpts * rtOpts, PtpCl
 	struct in_addr interfaceAddr, netAddr;
 	struct sockaddr_in addr;
 	struct ip_mreq imr;
+	unsigned char c;
 	char addrStr[NET_ADDRESS_LENGTH];
 	char *s;
 
@@@@ -304,22 +305,23 @@@@ netInit(NetPath * netPath, RunTimeOpts * rtOpts, PtpCl
 		return FALSE;
 	}
 	/* set socket time-to-live */
-	if (setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_TTL, &rtOpts->ttl, sizeof(int)) < 0
-	    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_TTL, &rtOpts->ttl, sizeof(int)) < 0) {
+	c = rtOpts->ttl;
+	if (setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_TTL, &c, sizeof(c)) < 0
+	    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_TTL, &c, sizeof(c)) < 0) {
 		PERROR("failed to set the multi-cast time-to-live");
 		return FALSE;
 	}
 	/* enable loopback */
-	temp = 1;
-	if (setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_LOOP, &temp, sizeof(int)) < 0
-	    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_LOOP, &temp, sizeof(int)) < 0) {
+	c = 1;
+	if (setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_LOOP, &c, sizeof(c)) < 0
+	    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_LOOP, &c, sizeof(c)) < 0) {
 		PERROR("failed to enable multi-cast loopback");
 		return FALSE;
 	}
 	/* make timestamps available through recvmsg() */
 
 	temp = 1;
-#if defined(linux)
+#if defined(linux) || defined(__NetBSD__) || defined(__OpenBSD__)
 	if (setsockopt(netPath->eventSock, SOL_SOCKET, SO_TIMESTAMP, &temp, sizeof(int)) < 0
 	    || setsockopt(netPath->generalSock, SOL_SOCKET, SO_TIMESTAMP, &temp, sizeof(int)) < 0) {
 #else /* BSD */
@@@@ -405,7 +407,7 @@@@ netRecvEvent(Octet * buf, TimeInternal * time, NetPath
 		char	control[CMSG_SPACE(sizeof(struct timeval))];
 	}     cmsg_un;
 	struct cmsghdr *cmsg;
-#if defined(linux)
+#if defined(linux) || defined(__NetBSD__) || defined(__OpenBSD__)
 	struct timeval *tv;
 #else /* FreeBSD */
 	struct timespec ts;
@@@@ -454,7 +456,7 @@@@ netRecvEvent(Octet * buf, TimeInternal * time, NetPath
 		return 0;
 	}
 
-#if defined(linux)
+#if defined(linux) || defined(__NetBSD__) || defined(__OpenBSD__)
 	tv = 0;
 	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; 
 	     cmsg = CMSG_NXTHDR(&msg, cmsg)) 
@


1.1
log
@Initial revision
@
text
@d1 5
a5 47
$OpenBSD$
--- src/dep/net.c.orig	Mon Apr  2 23:57:44 2007
+++ src/dep/net.c	Sun Oct 26 13:38:49 2008
@@@@ -8,26 +8,26 @@@@ Boolean lookupSubdomainAddress(Octet *subdomainName, O
   
   /* set multicast group address based on subdomainName */
   if (!memcmp(subdomainName, DEFAULT_PTP_DOMAIN_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-    memcpy(subdomainAddress, DEFAULT_PTP_DOMAIN_ADDRESS, NET_ADDRESS_LENGTH);
+    strncpy(subdomainAddress, DEFAULT_PTP_DOMAIN_ADDRESS, NET_ADDRESS_LENGTH);
   else if(!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN1_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-    memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
+    strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
   else if(!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN2_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-    memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
+    strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
   else if(!memcmp(subdomainName, ALTERNATE_PTP_DOMAIN3_NAME, PTP_SUBDOMAIN_NAME_LENGTH))
-    memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
+    strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
   else
   {
     h = crc_algorithm(subdomainName, PTP_SUBDOMAIN_NAME_LENGTH) % 3;
     switch(h)
     {
     case 0:
-      memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
+      strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN1_ADDRESS, NET_ADDRESS_LENGTH);
       break;
     case 1:
-      memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
+      strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN2_ADDRESS, NET_ADDRESS_LENGTH);
       break;
     case 2:
-      memcpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
+      strncpy(subdomainAddress, ALTERNATE_PTP_DOMAIN3_ADDRESS, NET_ADDRESS_LENGTH);
       break;
     default:
       ERROR("handle out of range for '%s'!\n", subdomainName);
@@@@ -229,6 +229,7 @@@@ Boolean netInit(NetPath *netPath, RunTimeOpts *rtOpts,
   struct in_addr interfaceAddr, netAddr;
   struct sockaddr_in addr;
   struct ip_mreq imr;
+  unsigned char c;
   char addrStr[NET_ADDRESS_LENGTH];
   char *s;
   
@@@@ -332,18 +333,18 @@@@ Boolean netInit(NetPath *netPath, RunTimeOpts *rtOpts,
   }
d7 86
a92 22
   /* set socket time-to-live to 1 */
-  temp = 1;
-  if( setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_TTL, &temp, sizeof(int)) < 0
-    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_TTL, &temp, sizeof(int)) < 0 )
+  c = 1;
+  if( setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_TTL, &c, sizeof(c)) < 0
+    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_TTL, &c, sizeof(c)) < 0 )
   {
     PERROR("failed to set the multi-cast time-to-live");
     return FALSE;
   }
   
   /* enable loopback */
-  temp = 1;
-  if( setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_LOOP, &temp, sizeof(int)) < 0
-    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_LOOP, &temp, sizeof(int)) < 0 )
+  c = 1;
+  if( setsockopt(netPath->eventSock, IPPROTO_IP, IP_MULTICAST_LOOP, &c, sizeof(c)) < 0
+    || setsockopt(netPath->generalSock, IPPROTO_IP, IP_MULTICAST_LOOP, &c, sizeof(c)) < 0 )
   {
     PERROR("failed to enable multi-cast loopback");
     return FALSE;
@


1.1.1.1
log
@Import ptpd 1.0.0

The PTP daemon (PTPd) implements the Precision Time protocol (PTP) as
defined by the IEEE 1588 standard. PTP was developed to provide very
precise time coordination of LAN connected computers.

with ckuethe@@
@
text
@@
