head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.20
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.16
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.18
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.14
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.12
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.10
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.8
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.6
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	jasper_20112909:1.1.1.1
	jasper:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2011.09.29.17.07.03;	author jasper;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.09.29.17.07.03;	author jasper;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$

- Add missing headers.
- Set interface index to -1 by default.

--- tests/framework.c.orig	Thu May 12 21:11:43 2011
+++ tests/framework.c	Thu Sep 29 11:28:48 2011
@@@@ -24,8 +24,12 @@@@
 #include <avahi-client/client.h>
 #include <avahi-common/error.h>
 
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
 #include <net/if.h>
-#include <sys/ioctl.h>
+#include <net/if_dl.h>
+#include <ifaddrs.h>
 
 #include <errno.h>
 #include <unistd.h>
@@@@ -188,12 +192,14 @@@@ epc_test_list_ifaces (void)
           continue;
         }
 
+#ifdef SIOCGIFINDEX
       if (ioctl (fd, SIOCGIFINDEX, req) < 0)
         {
           g_warning ("%s: ioctl(SIOCGIFINDEX): %s",
                      G_STRLOC, g_strerror (errno));
           goto out;
         }
+#endif
 
 /* The following allows to fall back to ifr_index on kFreeBSD, where 
    ifr_ifindex does not exist. See bug #592474. */
@@@@ -201,7 +207,7 @@@@ epc_test_list_ifaces (void)
 #define ifr_ifindex ifr_index
 #endif
 
-      ifaces[j].ifidx = req->ifr_ifindex;
+      ifaces[j].ifidx = -1;
       ifaces[j].mask = epc_test_result;
 
       g_print ("%s: name=%s, ifidx=%u, \n",
@


1.1.1.1
log
@import libepc 0.4.0

The Easy Publish and Consume library provides an easy method to:
    * Publish data using HTTPS: EpcPublisher;
    * Announce that information via DNS-SD: EpcDispatcher;
    * find that information: EpcConsumer;
    * And finally consume it.
You can use this library as a key/value store published to the network,
using encryption, authentication and service discovery.

ok aja@@
@
text
@@
