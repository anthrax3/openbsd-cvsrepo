head	1.1;
access;
symbols
	OPENBSD_5_5:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2014.06.06.19.21.33;	author sthen;	state dead;
branches
	1.1.2.1;
next	;
commitid	UTc2n5WW6b0jHaG6;

1.1.2.1
date	2014.06.06.19.21.33;	author sthen;	state Exp;
branches;
next	;
commitid	UTc2n5WW6b0jHaG6;


desc
@@


1.1
log
@file patch-src_proxy_udp_request_c was initially added on branch OPENBSD_5_5.
@
text
@@


1.1.2.1
log
@Backport reliability fix for assertion failure crash when out of buffer space
(https://github.com/jedisct1/dnscrypt-proxy/issues/71), req'd and tested by
kentas at hush com
@
text
@a0 51
$OpenBSD$

From 8e6ad7265cf37e96d80b54842d0b334110dcb75f Mon Sep 17 00:00:00 2001
From: Frank Denis <github@@pureftpd.org>
Date: Wed, 16 Apr 2014 06:02:07 -0700
Subject: [PATCH] Fix buggy retry code. Issue #71

--- src/proxy/udp_request.c.orig	Tue Aug 13 06:34:47 2013
+++ src/proxy/udp_request.c	Thu Jun  5 11:51:18 2014
@@@@ -101,9 +101,11 @@@@ sendto_with_retry(SendtoWithRetryCtx * const ctx)
                ctx->dest_addr, ctx->dest_len) == (ssize_t) ctx->length) {
         cb = ctx->cb;
         if (udp_request->sendto_retry_timer != NULL) {
-            assert(event_get_callback_arg(udp_request->sendto_retry_timer)
-                   == ctx);
-            free(ctx);
+            ctx_cb = event_get_callback_arg(udp_request->sendto_retry_timer);
+            assert(ctx_cb != NULL);
+            assert(ctx_cb->udp_request == ctx->udp_request);
+            assert(ctx_cb->buffer == ctx->buffer);
+            free(ctx_cb);
             event_free(udp_request->sendto_retry_timer);
             udp_request->sendto_retry_timer = NULL;
         }
@@@@ -139,13 +141,15 @@@@ sendto_with_retry(SendtoWithRetryCtx * const ctx)
         assert(ctx_cb != NULL);
         assert(ctx_cb->udp_request == ctx->udp_request);
         assert(ctx_cb->buffer == ctx->buffer);
-        assert(ctx_cb->cb == ctx->cb);
     } else {
         if ((ctx_cb = malloc(sizeof *ctx_cb)) == NULL) {
             logger_error(udp_request->proxy_context, "malloc");
             udp_request_kill(udp_request);
             return -1;
         }
+        assert(ctx_cb ==
+               event_get_callback_arg(udp_request->sendto_retry_timer));
+        *ctx_cb = *ctx;
         if ((udp_request->sendto_retry_timer =
              evtimer_new(udp_request->proxy_context->event_loop,
                          sendto_with_retry_timer_cb, ctx_cb)) == NULL) {
@@@@ -153,9 +157,6 @@@@ sendto_with_retry(SendtoWithRetryCtx * const ctx)
             udp_request_kill(udp_request);
             return -1;
         }
-        assert(ctx_cb ==
-               event_get_callback_arg(udp_request->sendto_retry_timer));
-        *ctx_cb = *ctx;
     }
     const struct timeval tv = {
         .tv_sec = (time_t) UDP_DELAY_BETWEEN_RETRIES, .tv_usec = 0
@

