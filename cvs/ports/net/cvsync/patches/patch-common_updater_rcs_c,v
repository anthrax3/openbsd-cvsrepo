head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.10
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.6
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.8
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.4
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.2
	OPENBSD_5_6_BASE:1.2;
locks; strict;
comment	@# @;


1.2
date	2014.06.26.20.06.50;	author naddy;	state Exp;
branches;
next	1.1;
commitid	l3MNNaaIdBEWInhO;

1.1
date	2014.06.25.17.54.07;	author naddy;	state Exp;
branches;
next	;
commitid	H1YfraZmPQVw4z3c;


desc
@@


1.2
log
@Fix an off-by-one error in the updater, where we would always consume
a byte but only sometimes account for it.
@
text
@$OpenBSD: patch-common_updater_rcs_c,v 1.1 2014/06/25 17:54:07 naddy Exp $
--- common/updater_rcs.c.orig	Mon Jul 18 16:32:59 2005
+++ common/updater_rcs.c	Thu Jun 26 19:28:00 2014
@@@@ -59,6 +59,7 @@@@
 #include "logmsg.h"
 #include "mux.h"
 #include "rcslib.h"
+#include "version.h"
 
 #include "updater.h"
 
@@@@ -1930,18 +1931,50 @@@@ updater_rcs_write_delta(struct updater_args *uda, uint
 		sp += slen;
 	}
 	len -= slen + 1;
-	iov[2].iov_base = ";\n\n";
-	iov[2].iov_len = 3;
+	iov[2].iov_base = ";\n";
+	iov[2].iov_len = 2;
 
 	if ((wn = writev(uda->uda_fileno, iov, 3)) == -1) {
 		logmsg_err("%s", strerror(errno));
 		(*hashops->destroy)(uda->uda_hash_ctx);
 		return (false);
 	}
-	if ((size_t)wn != slen + 10) {
+	if ((size_t)wn != slen + 9) {
 		logmsg_err("writev error");
 		(*hashops->destroy)(uda->uda_hash_ctx);
 		return (false);
+	}
+
+	/* commitid */
+	if (uda->uda_proto >= CVSYNC_PROTO(0, 25)) {
+	    len--;
+	    if ((slen = *sp++) != 0) {
+		iov[0].iov_base = "commitid\t";
+		iov[0].iov_len = 9;
+
+		if (len < slen) {
+			(*hashops->destroy)(uda->uda_hash_ctx);
+			return (false);
+		}
+		iov[1].iov_base = (void *)sp;
+		iov[1].iov_len = slen;
+		(*hashops->update)(uda->uda_hash_ctx, sp, slen);
+
+		sp += slen;
+		len -= slen;
+
+		iov[2].iov_base = ";\n\n";
+		iov[2].iov_len = 3;
+
+		if ((wn = writev(uda->uda_fileno, iov, 3)) == -1) {
+			(*hashops->destroy)(uda->uda_hash_ctx);
+			return (false);
+		}
+		if ((size_t)wn != slen + 12) {
+			(*hashops->destroy)(uda->uda_hash_ctx);
+			return (false);
+		}
+	    }
 	}
 
 	if (len != hashops->length) {
@


1.1
log
@Add full support for commitid and bump protocol version.
Old clients will receive updates with commitid stripped out.

Upstream author agrees with the direction taken.

Heavy lifting by jca@@, debugging and tweaks by yours truly
ok jcs@@
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ common/updater_rcs.c	Wed Jun 25 16:03:07 2014
d12 1
a12 1
@@@@ -1930,18 +1931,49 @@@@ updater_rcs_write_delta(struct updater_args *uda, uint
d35 1
d40 1
a40 1
+		if (len < slen + 1) {
d49 1
a49 1
+		len -= slen + 1;
@

