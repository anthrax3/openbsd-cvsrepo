head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.8
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.4
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.6
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.1.0.4
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.2
	OPENBSD_5_5_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2014.11.19.23.49.41;	author sthen;	state Exp;
branches;
next	1.1;
commitid	iIPWE0hxd0RqjJf7;

1.1
date	2013.08.29.14.28.14;	author naddy;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Initialize sa->sa_socket / sa_config earlier in access_authorize(). Seems to
fix crashes in cvsyncd now made visible by malloc's junk-after-free default.

From patrick keshishian who says 'I think protocol_exchange() will eventually
"realize" that status and/or error are not ok, and will return false, and
server thread will call assess_done(), which will socket_close() and
config_revoke().' Thanks for looking into this and suggesting the diff.

Survived 24h+ on my server, and looks good to naddy.
@
text
@$OpenBSD: patch-cvsyncd_access_c,v 1.1 2013/08/29 14:28:14 naddy Exp $
--- cvsyncd/access.c.orig	Mon Jul 18 07:33:02 2005
+++ cvsyncd/access.c	Mon Nov 17 23:35:16 2014
@@@@ -103,10 +103,12 @@@@ static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER
 bool
 access_init(size_t sz)
 {
+#if defined(NO_ARC4RANDOM)
 #if !defined(NO_INITSTATE)
 	static char acl_random_state[256];
 #endif /* !defined(NO_INITSTATE) */
 	struct timeval tv;
+#endif /* defined(NO_ARC4RANDOM) */
 
 	if ((acl = malloc(sz * sizeof(*acl))) == NULL) {
 		logmsg_err("ACL: %s", strerror(errno));
@@@@ -119,6 +121,7 @@@@ access_init(size_t sz)
 		return (false);
 	}
 
+#if defined(NO_ARC4RANDOM)
 	(void)gettimeofday(&tv, NULL);
 
 #if !defined(NO_INITSTATE)
@@@@ -127,6 +130,7 @@@@ access_init(size_t sz)
 #else /* !defined(NO_INITSTATE) */
 	srandom((unsigned long)tv.tv_usec);
 #endif /* !defined(NO_INITSTATE) */
+#endif /* defined(NO_ARC4RANDOM) */
 
 	acl_name[0] = '\0';
 	acl_size = sz;
@@@@ -193,6 +197,11 @@@@ access_authorize(int sock, struct config *cf)
 	}
 	sa->sa_error = CVSYNC_NO_ERROR;
 
+	sa->sa_socket = sock;
+	sa->sa_config = cf;
+
+	config_acquire(cf);
+
 	if (cvsync_isinterrupted()) {
 		sa->sa_status = ACL_DENY;
 		sa->sa_error = CVSYNC_ERROR_UNAVAIL;
@@@@ -205,7 +214,11 @@@@ access_authorize(int sock, struct config *cf)
 		sa->sa_error = CVSYNC_ERROR_UNAVAIL;
 		return (sa);
 	}
+#if !defined(NO_ARC4RANDOM)
+	_v.v32 = arc4random();
+#else /* !defined(NO_ARC4RANDOM) */
 	_v.v32 = (uint32_t)random();
+#endif /* !defined(NO_ARC4RANDOM) */
 	wn = snprintf(sa->sa_hostinfo, sizeof(sa->sa_hostinfo),
 		      "[%s] (%02x%02x%02x%02x)", sa->sa_addr,
 		      _v.v8[0], _v.v8[1], _v.v8[2], _v.v8[3]);
@@@@ -305,11 +318,6 @@@@ access_authorize(int sock, struct config *cf)
 		sa->sa_error = CVSYNC_ERROR_UNAVAIL;
 		return (sa);
 	}
-
-	sa->sa_socket = sock;
-	sa->sa_config = cf;
-
-	config_acquire(cf);
 
 	logmsg("%s Connected (status=%d)", sa->sa_hostinfo, sa->sa_status);
 	time(&sa->sa_tick);
@


1.1
log
@* replace random() with arc4random()
* improve configuration examples after discussion with Amit Kulkarni
@
text
@d1 3
a3 3
$OpenBSD$
--- cvsyncd/access.c.orig	Mon Jul 18 16:33:02 2005
+++ cvsyncd/access.c	Tue Aug 27 13:47:36 2013
d33 13
a45 1
@@@@ -205,7 +209,11 @@@@ access_authorize(int sock, struct config *cf)
d57 12
@

