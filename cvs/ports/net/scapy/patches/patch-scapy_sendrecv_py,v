head	1.5;
access;
symbols
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.1.0.22
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.18
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.16
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.14
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.12
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.10
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.8
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2016.12.09.16.40.11;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	iFg48fUcJyxZ0TTG;

1.4
date	2016.11.24.12.40.49;	author bluhm;	state Exp;
branches;
next	1.3;
commitid	sewSnamZBYwOetFR;

1.3
date	2016.11.14.20.04.56;	author danj;	state dead;
branches;
next	1.2;
commitid	es91ZvD6iX1X8HaM;

1.2
date	2016.01.31.23.21.37;	author sthen;	state Exp;
branches;
next	1.1;
commitid	wpSH0OBFo4M2FAva;

1.1
date	2010.10.05.09.18.05;	author armani;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Allow to switch the interface to promiscuous mode during sndrcv().
Call the sr...() functions with parameter promisc=1 for that.  This
is needed for the src/sys/netinet/arp regress test and was backported
from secdev/scapy master at github.
OK danj@@ (maintainer)
@
text
@$OpenBSD: patch-scapy_sendrecv_py,v 1.4 2016/11/24 12:40:49 bluhm Exp $

https://github.com/secdev/scapy/commit/3983433a3b93d2662e0baf9875a4d33dec743cbe
https://github.com/secdev/scapy/commit/e41627769f6eba2dc54f102e8e7c0bc246090eec

--- scapy/sendrecv.py.orig	Tue Oct 18 14:56:50 2016
+++ scapy/sendrecv.py	Fri Dec  9 14:51:03 2016
@@@@ -11,7 +11,7 @@@@ import errno
 import cPickle,os,sys,time,subprocess
 import itertools
 from select import select
-from scapy.arch.consts import DARWIN, FREEBSD
+from scapy.arch.consts import DARWIN, FREEBSD, OPENBSD
 from scapy.data import *
 from scapy.config import conf
 from scapy.packet import Gen
@@@@ -127,7 +127,7 @@@@ def sndrcv(pks, pkt, timeout = None, inter = 0, verbos
                                 if remaintime <= 0:
                                     break
                             r = None
-                            if not isinstance(pks, StreamSocket) and (FREEBSD or DARWIN):
+                            if not isinstance(pks, StreamSocket) and (FREEBSD or DARWIN or OPENBSD):
                                 inp, out, err = select(inmask,[],[], 0.05)
                                 if len(inp) == 0 or pks in inp:
                                     r = pks.nonblock_recv()
@@@@ -321,7 +321,7 @@@@ def sendpfast(x, pps=None, mbps=None, realtime=None, l
         
     
 @@conf.commands.register
-def sr(x,filter=None, iface=None, nofilter=0, *args,**kargs):
+def sr(x, promisc=None, filter=None, iface=None, nofilter=0, *args,**kargs):
     """Send and receive packets at layer 3
 nofilter: put 1 to avoid use of bpf filters
 retry:    if positive, how many times to resend unanswered packets
@@@@ -333,13 +333,13 @@@@ filter:   provide a BPF filter
 iface:    listen answers only on the given interface"""
     if not kargs.has_key("timeout"):
         kargs["timeout"] = -1
-    s = conf.L3socket(filter=filter, iface=iface, nofilter=nofilter)
+    s = conf.L3socket(promisc=promisc, filter=filter, iface=iface, nofilter=nofilter)
     a,b=sndrcv(s,x,*args,**kargs)
     s.close()
     return a,b
 
 @@conf.commands.register
-def sr1(x,filter=None,iface=None, nofilter=0, *args,**kargs):
+def sr1(x, promisc=None, filter=None, iface=None, nofilter=0, *args,**kargs):
     """Send packets at layer 3 and return only the first answer
 nofilter: put 1 to avoid use of bpf filters
 retry:    if positive, how many times to resend unanswered packets
@@@@ -351,7 +351,7 @@@@ filter:   provide a BPF filter
 iface:    listen answers only on the given interface"""
     if not kargs.has_key("timeout"):
         kargs["timeout"] = -1
-    s=conf.L3socket(filter=filter, nofilter=nofilter, iface=iface)
+    s=conf.L3socket(promisc=promisc, filter=filter, nofilter=nofilter, iface=iface)
     a,b=sndrcv(s,x,*args,**kargs)
     s.close()
     if len(a) > 0:
@@@@ -360,7 +360,7 @@@@ iface:    listen answers only on the given interface""
         return None
 
 @@conf.commands.register
-def srp(x,iface=None, iface_hint=None, filter=None, nofilter=0, type=ETH_P_ALL, *args,**kargs):
+def srp(x, promisc=None, iface=None, iface_hint=None, filter=None, nofilter=0, type=ETH_P_ALL, *args,**kargs):
     """Send and receive packets at layer 2
 nofilter: put 1 to avoid use of bpf filters
 retry:    if positive, how many times to resend unanswered packets
@@@@ -374,7 +374,7 @@@@ iface:    work only on the given interface"""
         kargs["timeout"] = -1
     if iface is None and iface_hint is not None:
         iface = conf.route.route(iface_hint)[0]
-    s = conf.L2socket(iface=iface, filter=filter, nofilter=nofilter, type=type)
+    s = conf.L2socket(promisc=promisc, iface=iface, filter=filter, nofilter=nofilter, type=type)
     a,b=sndrcv(s ,x,*args,**kargs)
     s.close()
     return a,b
@@@@ -516,7 +516,7 @@@@ def sndrcvflood(pks, pkt, prn=lambda (s,r):r.summary()
     return received
 
 @@conf.commands.register
-def srflood(x,filter=None, iface=None, nofilter=None, *args,**kargs):
+def srflood(x, promisc=None, filter=None, iface=None, nofilter=None, *args,**kargs):
     """Flood and receive packets at layer 3
 prn:      function applied to packets received. Ret val is printed if not None
 store:    if 1 (default), store answers and return them
@@@@ -524,13 +524,13 @@@@ unique:   only consider packets whose print 
 nofilter: put 1 to avoid use of bpf filters
 filter:   provide a BPF filter
 iface:    listen answers only on the given interface"""
-    s = conf.L3socket(filter=filter, iface=iface, nofilter=nofilter)
+    s = conf.L3socket(promisc=promisc, filter=filter, iface=iface, nofilter=nofilter)
     r=sndrcvflood(s,x,*args,**kargs)
     s.close()
     return r
 
 @@conf.commands.register
-def srpflood(x,filter=None, iface=None, iface_hint=None, nofilter=None, *args,**kargs):
+def srpflood(x, promisc=None, filter=None, iface=None, iface_hint=None, nofilter=None, *args,**kargs):
     """Flood and receive packets at layer 2
 prn:      function applied to packets received. Ret val is printed if not None
 store:    if 1 (default), store answers and return them
@@@@ -540,7 +540,7 @@@@ filter:   provide a BPF filter
 iface:    listen answers only on the given interface"""
     if iface is None and iface_hint is not None:
         iface = conf.route.route(iface_hint)[0]    
-    s = conf.L2socket(filter=filter, iface=iface, nofilter=nofilter)
+    s = conf.L2socket(promisc=promisc, filter=filter, iface=iface, nofilter=nofilter)
     r=sndrcvflood(s,x,*args,**kargs)
     s.close()
     return r
@


1.4
log
@Put back an OpenBSD special code path that was lost in the scapy
2.3.3 update.  Sniff the packets in sndrcv() like it is done on
FreeBSD and Darwin.  Without this patch, everything worked with
virtual qemu.  But on real ethernet hardware sr() sends TCP packets
to the broadcast MAC address as scapy did not see the ARP reply to
figure out the correct MAC address.
OK danj@@ (maintainer)
@
text
@d1 5
a5 1
$OpenBSD$
d7 1
a7 1
+++ scapy/sendrecv.py	Tue Nov 22 16:56:47 2016
d26 86
@


1.3
log
@Update to scapy-2.3.3 and take maintainership (no objection from
previous maintainer armani@@)

tested by bluhm@@
previous diff ok sthen@@
@
text
@d1 13
a13 4
$OpenBSD: patch-scapy_sendrecv_py,v 1.2 2016/01/31 23:21:37 sthen Exp $
--- scapy/sendrecv.py.orig	Tue Dec 30 21:25:32 2014
+++ scapy/sendrecv.py	Sun Jan 17 20:19:17 2016
@@@@ -121,7 +121,7 @@@@ def sndrcv(pks, pkt, timeout = None, inter = 0, verbos
d17 2
a18 2
-                            if arch.FREEBSD or arch.DARWIN:
+                            if arch.FREEBSD or arch.DARWIN or arch.OPENBSD:
@


1.2
log
@update to scapy-2.3.2, from Daniel Jakots, earlier version ok armani@@
@
text
@d1 1
a1 1
$OpenBSD: patch-scapy_sendrecv_py,v 1.1 2010/10/05 09:18:05 armani Exp $
@


1.1
log
@Update to 2.1.0, change my email address and integrate 2 patches from
Laurent Ghigonis, one to properly detect the mac address and the other to close
the bpf after use (You don't need to create 40 bpf anymore), thanks !

ok sthen@@
@
text
@d1 4
a4 4
$OpenBSD$
--- scapy/sendrecv.py.orig	Mon Oct  4 07:33:19 2010
+++ scapy/sendrecv.py	Mon Oct  4 07:35:09 2010
@@@@ -117,7 +117,7 @@@@ def sndrcv(pks, pkt, timeout = None, inter = 0, verbos
@

