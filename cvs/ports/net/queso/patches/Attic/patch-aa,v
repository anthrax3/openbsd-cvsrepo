head	1.4;
access;
symbols
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_TRACKING_SWITCH:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.2
	OPENBSD_2_5_BASE:1.1.1.1
	brad_1999-03-28:1.1.1.1
	brad:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2003.04.22.12.08.05;	author avsm;	state dead;
branches;
next	1.3;

1.3
date	99.12.01.03.04.04;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	99.07.27.04.30.06;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	99.03.28.19.12.56;	author brad;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.03.28.19.12.56;	author brad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@argh, cvs refuses to add/remove these patches from the previous
update; noticed by naddy@@
@
text
@Patch helping 64 bit cleanness taken from the Debian Linux package made
by Stéphane Bortmeyer <bortzmeyer@@debian.org>. 64 bit patch originally
by Bart Warmerdam <bartw@@xs4all.nl>.

Integrate previous OpenBSD patch using new libpcap types.

--- tcpip.c.orig	Tue Sep 22 22:35:43 1998
+++ tcpip.c	Wed Sep 29 14:43:06 1999
@@@@ -40,7 +40,7 @@@@
 typedef struct
   {
     struct in_addr addr;
-    unsigned long naddr;	/* netmask */
+    u_int32_t naddr;	/* netmask */
     interfacerec *iface;
   }
 routerec;
@@@@ -61,11 +61,11 @@@@
 #endif
 
 int sendsock, readsock;
-unsigned short ipident;
+u_int16_t ipident;
 
 /* This function will determine the checksum for a specific packet. Used by */
 /*  nearly EVERYTHING on the internet */
-unsigned short
+u_int16_t
 inet_checksum (void *addr, int len)
 {
   register int nleft = len;
@@@@ -106,16 +106,16 @@@@
   struct in_addr dest_address;
   unsigned char place_holder;
   unsigned char protocol;
-  unsigned short length;
+  u_int16_t length;
 } psuedohdr;
 
-unsigned short tcp_checksum(char *packet,
+u_int16_t tcp_checksum(char *packet,
                            int length,
                            struct in_addr source_address,
                            struct in_addr dest_address)
 {
   char *psuedo_packet;
-  unsigned short cksum;
+  u_int16_t cksum;
   
   psuedohdr.protocol = IPPROTO_TCP;
   psuedohdr.length = htons(length);
@@@@ -133,7 +133,7 @@@@
   memcpy((psuedo_packet + sizeof(psuedohdr)),
          packet,length);
   
-  cksum = inet_checksum((unsigned short *)psuedo_packet,(length + sizeof(psuedohdr)));
+  cksum = inet_checksum((u_int16_t *)psuedo_packet,(length + sizeof(psuedohdr)));
   free(psuedo_packet);
   return cksum;
 }
@@@@ -153,7 +153,7 @@@@
   memset (sa, 0, sizeof (struct sockaddr));
   sa->sin_family = AF_INET;
   sa->sin_addr.s_addr = inet_addr (host);
-  if ((long) inet_addr (host) == -1)
+  if ((int32_t) inet_addr (host) == -1)
     {
       ent = gethostbyname (host);
       if (ent != NULL)
@@@@ -173,7 +173,7 @@@@
 
 /* Sends a TCP packet */
 void
-sendtcp (spoofrec * spoof, unsigned short flags, short rep)
+sendtcp (spoofrec * spoof, u_int16_t flags, short rep)
 {
   struct tcphdr tcp;
   struct ip ip;
@@@@ -271,6 +271,7 @@@@
     switch(datalink) {
       case DLT_EN10MB:
         offset = 14; break;
+      case DLT_LOOP:
       case DLT_NULL:
       case DLT_PPP:
         offset =  4; break;
@@@@ -285,6 +286,8 @@@@
         offset =  8; break;
       case DLT_IEEE802:
         offset = 22; break;
+      case DLT_ENC:
+	offset = 12; break;
       default:
         fprintf(stderr, "unknown datalink type (%d)", datalink);
         return(0);
@@@@ -319,7 +322,7 @@@@
 /*-- Linux: Search out IP in Routing tables --*/
 /*-- Other: Return hostname ip ---------------*/
 struct in_addr
-getlocalip (unsigned long dest)
+getlocalip (u_int32_t dest)
 {
   static struct in_addr ina;
 #ifdef LINUX  /*---------------------------------------------- LINUX --*/
@@@@ -327,7 +330,7 @@@@
 
   for (i = 0; i < numroutes; i++)
     {
-      if ((dest & routes[i].naddr) == (unsigned long) routes[i].addr.s_addr)
+      if ((dest & routes[i].naddr) == (u_int32_t) routes[i].addr.s_addr)
         {
           return (routes[i].iface->addr);
         }
@@@@ -434,7 +437,7 @@@@
       else
         strcpy (iface, ptr);
       ptr = strtok (NULL, "\t ");       /* hack avoiding fscanf */
-      routes[i].addr.s_addr=(unsigned long)strtol(ptr,NULL,16);
+      routes[i].addr.s_addr=(u_int32_t)strtol(ptr,NULL,16);
       for (i1 = 0; i1 < 6; i1++)
         {
           ptr = strtok (NULL, "\t ");   /* ignore Gateway Flags RefCnt Use Metric */
@@@@ -443,7 +446,7 @@@@
         fputs ("Error parsing /proc/net/route\n", stderr);
         continue;
       }
-      routes[i].naddr=(unsigned long)strtol(ptr,NULL,16);   /* Netmask */
+      routes[i].naddr=(u_int32_t)strtol(ptr,NULL,16);   /* Netmask */
 
       found = 0;
       for (i1 = 0; i1 < numinterfaces; i1++)
@


1.3
log
@- add patches which fix compilation of queso on Alpha
- add queso man page

from Debian via rohee@@
@
text
@@


1.2
log
@- add a dist site that has queso
- make queso use the systems libpcap
- make queso work with datalink types of DLT_LOOP and DLT_ENC
@
text
@d1 78
a78 2
--- tcpip.c.orig	Mon Jul 26 23:34:24 1999
+++ tcpip.c	Mon Jul 26 23:39:18 1999
d92 1
a92 1
+        offset = 12; break;
d96 36
@


1.1
log
@Initial revision
@
text
@d1 19
a19 81
--- tcpip.c.orig	Tue Sep 22 13:35:43 1998
+++ tcpip.c	Sat Oct 24 11:46:58 1998
@@@@ -25,6 +25,12 @@@@
 #include <stdarg.h>
 #include <net/if.h>
 
+#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__bsdi__)
+#include <err.h>
+#include <errno.h>
+#include <sysexits.h>
+#endif
+
 #include "tcpip.h"
 
 /*-- LINUX routilng TABLES */
@@@@ -333,7 +339,64 @@@@
         }
     }
 
-#else /* !LINUX ---------------------------------------------- OTHER --*/
+/*------------------------------- FreeBSD / OpenBSD / NetBSD / BSDI --*/
+#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__bsdi__)
+/* 
+        FreeBSD Ref: /usr/share/examples/find_interface/ 
+*/
+        struct sockaddr_in local, remote;
+        int s, rv, namelen;
+
+        remote.sin_addr.s_addr = dest;
+        remote.sin_port = htons(60000);
+        remote.sin_family = AF_INET;
+        remote.sin_len = sizeof remote;
+
+        local.sin_addr.s_addr = htonl(INADDR_ANY);
+        local.sin_port = htons(60000);
+        local.sin_family = AF_INET;
+        local.sin_len = sizeof local;
+
+        s = socket(PF_INET, SOCK_DGRAM, 0);
+        if (s < 0)
+          err(EX_OSERR, "socket");
+
+        do 
+	  {
+            rv = bind(s, (struct sockaddr *)&local, sizeof local);
+            local.sin_port = htons(ntohs(local.sin_port) + 1);
+          } while(rv < 0 && errno == EADDRINUSE);
+
+        if (rv < 0)
+          err(EX_OSERR, "bind");
+
+        do
+	  {
+            rv = connect(s, (struct sockaddr *)&remote, sizeof remote);
+            remote.sin_port = htons(ntohs(remote.sin_port) + 1);
+          } while(rv < 0 && errno == EADDRINUSE);
+
+        if (rv < 0)
+          err(EX_OSERR, "bind");
+
+        do
+	  {
+            rv = connect(s, (struct sockaddr *)&remote, sizeof remote);
+            remote.sin_port = htons(ntohs(remote.sin_port) + 1);
+          } while(rv < 0 && errno == EADDRINUSE);
+
+        if (rv < 0)
+          err(EX_OSERR, "connect");
+
+        namelen = sizeof local;
+        rv = getsockname(s, (struct sockaddr *)&local, &namelen);
+
+        if (rv < 0)
+          err(EX_OSERR, "getsockname");
+
+	return local.sin_addr;
+
+#else /* !LINUX && !BSD ---------------------------------- OTHER --*/
   struct sockaddr_in sin; 
   char myname[80];
   
@


1.1.1.1
log
@add queso port
@
text
@@
