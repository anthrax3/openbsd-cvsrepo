head	1.1;
access;
symbols
	OPENBSD_6_1:1.1.0.56
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.54
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.50
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.52
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.48
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.46
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.44
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.42
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.40
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.38
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.36
	OPENBSD_5_0:1.1.0.34
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.32
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.30
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.28
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.26
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.24
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.22
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.20
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.18
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.16
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.14
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.12
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.10
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.8
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.2
	OPENBSD_3_4_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2003.04.22.12.08.05;	author avsm;	state Exp;
branches;
next	;


desc
@@


1.1
log
@argh, cvs refuses to add/remove these patches from the previous
update; noticed by naddy@@
@
text
@$OpenBSD$
--- tcpip.c.orig	Tue Sep 22 21:35:43 1998
+++ tcpip.c	Mon Apr 14 23:50:21 2003
@@@@ -40,7 +40,7 @@@@ interfacerec;
 typedef struct
   {
     struct in_addr addr;
-    unsigned long naddr;	/* netmask */
+    u_int32_t naddr;	/* netmask */
     interfacerec *iface;
   }
 routerec;
@@@@ -61,11 +61,11 @@@@ pcap_t *PCapHdlr=NULL;
 #endif
 
 int sendsock, readsock;
-unsigned short ipident;
+u_int16_t ipident;
 
 /* This function will determine the checksum for a specific packet. Used by */
 /*  nearly EVERYTHING on the internet */
-unsigned short
+u_int16_t
 inet_checksum (void *addr, int len)
 {
   register int nleft = len;
@@@@ -106,16 +106,16 @@@@ struct psuedohdr  {
   struct in_addr dest_address;
   unsigned char place_holder;
   unsigned char protocol;
-  unsigned short length;
+  u_int16_t length;
 } psuedohdr;
 
-unsigned short tcp_checksum(char *packet,
+u_int16_t tcp_checksum(char *packet,
                            int length,
                            struct in_addr source_address,
                            struct in_addr dest_address)
 {
   char *psuedo_packet;
-  unsigned short cksum;
+  u_int16_t cksum;
   
   psuedohdr.protocol = IPPROTO_TCP;
   psuedohdr.length = htons(length);
@@@@ -133,7 +133,7 @@@@ unsigned short tcp_checksum(char *packet
   memcpy((psuedo_packet + sizeof(psuedohdr)),
          packet,length);
   
-  cksum = inet_checksum((unsigned short *)psuedo_packet,(length + sizeof(psuedohdr)));
+  cksum = inet_checksum((u_int16_t *)psuedo_packet,(length + sizeof(psuedohdr)));
   free(psuedo_packet);
   return cksum;
 }
@@@@ -153,7 +153,7 @@@@ resolve_host (char *host, struct sockadd
   memset (sa, 0, sizeof (struct sockaddr));
   sa->sin_family = AF_INET;
   sa->sin_addr.s_addr = inet_addr (host);
-  if ((long) inet_addr (host) == -1)
+  if ((int32_t) inet_addr (host) == -1)
     {
       ent = gethostbyname (host);
       if (ent != NULL)
@@@@ -173,7 +173,7 @@@@ resolve_host (char *host, struct sockadd
 
 /* Sends a TCP packet */
 void
-sendtcp (spoofrec * spoof, unsigned short flags, short rep)
+sendtcp (spoofrec * spoof, u_int16_t flags, short rep)
 {
   struct tcphdr tcp;
   struct ip ip;
@@@@ -271,6 +271,7 @@@@ gettcp (spoofrec * spoof, tcprec * dtcp)
     switch(datalink) {
       case DLT_EN10MB:
         offset = 14; break;
+      case DLT_LOOP:
       case DLT_NULL:
       case DLT_PPP:
         offset =  4; break;
@@@@ -285,6 +286,8 @@@@ gettcp (spoofrec * spoof, tcprec * dtcp)
         offset =  8; break;
       case DLT_IEEE802:
         offset = 22; break;
+      case DLT_ENC:
+	offset = 12; break;
       default:
         fprintf(stderr, "unknown datalink type (%d)", datalink);
         return(0);
@@@@ -319,7 +322,7 @@@@ gettcp (spoofrec * spoof, tcprec * dtcp)
 /*-- Linux: Search out IP in Routing tables --*/
 /*-- Other: Return hostname ip ---------------*/
 struct in_addr
-getlocalip (unsigned long dest)
+getlocalip (u_int32_t dest)
 {
   static struct in_addr ina;
 #ifdef LINUX  /*---------------------------------------------- LINUX --*/
@@@@ -327,7 +330,7 @@@@ getlocalip (unsigned long dest)
 
   for (i = 0; i < numroutes; i++)
     {
-      if ((dest & routes[i].naddr) == (unsigned long) routes[i].addr.s_addr)
+      if ((dest & routes[i].naddr) == (u_int32_t) routes[i].addr.s_addr)
         {
           return (routes[i].iface->addr);
         }
@@@@ -434,7 +437,7 @@@@ void init_route_tables(void)
       else
         strcpy (iface, ptr);
       ptr = strtok (NULL, "\t ");       /* hack avoiding fscanf */
-      routes[i].addr.s_addr=(unsigned long)strtol(ptr,NULL,16);
+      routes[i].addr.s_addr=(u_int32_t)strtol(ptr,NULL,16);
       for (i1 = 0; i1 < 6; i1++)
         {
           ptr = strtok (NULL, "\t ");   /* ignore Gateway Flags RefCnt Use Metric */
@@@@ -443,7 +446,7 @@@@ void init_route_tables(void)
         fputs ("Error parsing /proc/net/route\n", stderr);
         continue;
       }
-      routes[i].naddr=(unsigned long)strtol(ptr,NULL,16);   /* Netmask */
+      routes[i].naddr=(u_int32_t)strtol(ptr,NULL,16);   /* Netmask */
 
       found = 0;
       for (i1 = 0; i1 < numinterfaces; i1++)
@
