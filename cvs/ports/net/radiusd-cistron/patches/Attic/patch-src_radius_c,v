head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2001.12.17.20.47.47;	author danh;	state dead;
branches;
next	1.1;

1.1
date	2001.11.20.18.54.55;	author danh;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to radiusd-cistron 1.6.5
@
text
@$OpenBSD: patch-src_radius_c,v 1.1 2001/11/20 18:54:55 danh Exp $
--- src/radius.c.orig	Tue Nov 20 13:26:31 2001
+++ src/radius.c	Tue Nov 20 13:33:21 2001
@@@@ -267,10 +267,11 @@@@ int calc_digest(u_char *digest, AUTH_REQ
  */
 int calc_acctdigest(u_char *digest, AUTH_REQ *authreq)
 {
-	int	secretlen;
+	char 	zero[AUTH_VECTOR_LEN];
+	char	*recvbuf = authreq->data;
+	char	*tmpbuf;
 	CLIENT	*cl;
-	char zero[AUTH_VECTOR_LEN];
-	char	* recvbuf = authreq->data;
+	int	secretlen;
 	int	len = authreq->data_len;
 
 	/*
@@@@ -283,13 +284,6 @@@@ int calc_acctdigest(u_char *digest, AUTH
 	}
 
 	/*
-	 *	Copy secret into authreq->secret so that we can
-	 *	use it with send_acct_reply()
-	 */
-	secretlen = strlen(cl->secret);
-	strNcpy(authreq->secret, cl->secret, sizeof(authreq->secret));
-
-	/*
 	 *	Older clients have the authentication vector set to
 	 *	all zeros. Return `1' in that case.
 	 */
@@@@ -303,9 +297,17 @@@@ int calc_acctdigest(u_char *digest, AUTH
 	 *	and calculate the MD5 sum. This must be the same
 	 *	as the original MD5 sum (authreq->vector).
 	 */
+	secretlen = strlen(authreq->secret);
 	memset(recvbuf + 4, 0, AUTH_VECTOR_LEN);
-	memcpy(recvbuf + len, cl->secret, secretlen);
-	md5_calc(digest, recvbuf, len + secretlen);
+
+	if ((tmpbuf = malloc(len + secretlen)) == NULL) {
+		log(L_ERR|L_CONS, "no memory");
+		exit(1);
+	}
+	memcpy(tmpbuf, recvbuf, len);
+	memcpy(tmpbuf + len, authreq->secret, secretlen);
+	md5_calc(digest, tmpbuf, len + secretlen);
+	free(tmpbuf);
 
 	/*
 	 *	Return 0 if OK, 2 if not OK.
@


1.1
log
@- pull in fix from latest snapshot for calc_acctdigest() overflow
- srand()/rand() changed to arc4random()
- bump PKGNAME
@
text
@d1 1
a1 1
$OpenBSD$
@

