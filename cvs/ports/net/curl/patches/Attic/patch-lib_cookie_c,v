head	1.2;
access;
symbols
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2;
locks; strict;
comment	@# @;


1.2
date	2013.10.09.17.25.39;	author naddy;	state dead;
branches
	1.2.2.1
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2013.05.07.06.53.26;	author jasper;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2013.05.07.06.54.51;	author jasper;	state Exp;
branches;
next	;

1.2.2.1
date	2014.09.13.15.02.54;	author naddy;	state Exp;
branches;
next	;
commitid	cI1O4Ho0GRVoGO50;

1.2.4.1
date	2014.09.13.19.57.07;	author naddy;	state Exp;
branches;
next	1.2.4.2;
commitid	PoFe9Sp53gZZLdWE;

1.2.4.2
date	2015.05.01.20.39.42;	author naddy;	state Exp;
branches;
next	;
commitid	Ij8k3y0w8XICbM4N;

1.2.6.1
date	2015.04.30.23.18.27;	author naddy;	state Exp;
branches;
next	;
commitid	zXKzsZprdoQeh32Z;


desc
@@


1.2
log
@Update to 7.32.0.
No revolutionary changes; see http://curl.haxx.se/changes.html for
the details.
@
text
@$OpenBSD: patch-lib_cookie_c,v 1.1 2013/05/07 06:53:26 jasper Exp $

Security fix for CVE-2013-1944 curl: Cookie domain suffix match vulnerability
Patch from http://curl.haxx.se/curl-tailmatch.patch

--- lib/cookie.c.orig	Thu Mar  8 20:35:24 2012
+++ lib/cookie.c	Mon May  6 16:17:34 2013
@@@@ -118,15 +118,29 @@@@ static void freecookie(struct Cookie *co)
   free(co);
 }
 
-static bool tailmatch(const char *little, const char *bigone)
+static bool tailmatch(const char *cooke_domain, const char *hostname)
 {
-  size_t littlelen = strlen(little);
-  size_t biglen = strlen(bigone);
+  size_t cookie_domain_len = strlen(cooke_domain);
+  size_t hostname_len = strlen(hostname);
 
-  if(littlelen > biglen)
+  if(hostname_len < cookie_domain_len)
     return FALSE;
 
-  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;
+  if(!Curl_raw_equal(cooke_domain, hostname+hostname_len-cookie_domain_len))
+    return FALSE;
+
+  /* A lead char of cookie_domain is not '.'.
+     RFC6265 4.1.2.3. The Domain Attribute says:
+       For example, if the value of the Domain attribute is
+       "example.com", the user agent will include the cookie in the Cookie
+       header when making HTTP requests to example.com, www.example.com, and
+       www.corp.example.com.
+   */
+  if(hostname_len == cookie_domain_len)
+    return TRUE;
+  if('.' == *(hostname + hostname_len - cookie_domain_len - 1))
+    return TRUE;
+  return FALSE;
 }
 
 /*
@


1.2.6.1
log
@Security fixes:
CVE-2015-3143: Re-using authenticated connection when unauthenticated
CVE-2015-3144: host name out of boundary memory access
CVE-2015-3145: cookie parser out of boundary memory access
CVE-2015-3148: Negotiate not treated as connection-oriented
CVE-2015-3153: sensitive HTTP server headers also sent to proxies
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
CVE-2015-3145: cookie parser out of boundary memory access
http://curl.haxx.se/docs/adv_20150422C.html
d6 5
a10 4
--- lib/cookie.c.orig	Wed Dec 10 00:01:02 2014
+++ lib/cookie.c	Thu Apr 30 23:56:53 2015
@@@@ -236,11 +236,14 @@@@ static char *sanitize_cookie_path(const char *cookie_p
     return NULL;
d12 7
a18 13
   /* some stupid site sends path attribute with '"'. */
+  len = strlen(new_path);
   if(new_path[0] == '\"') {
-    memmove((void *)new_path, (const void *)(new_path + 1), strlen(new_path));
+    memmove((void *)new_path, (const void *)(new_path + 1), len);
+    len--;
   }
-  if(new_path[strlen(new_path) - 1] == '\"') {
-    new_path[strlen(new_path) - 1] = 0x0;
+  if(len && (new_path[len - 1] == '\"')) {
+    new_path[len - 1] = 0x0;
+    len--;
   }
d20 3
a22 3
   /* RFC6265 5.2.4 The Path Attribute */
@@@@ -252,8 +255,7 @@@@ static char *sanitize_cookie_path(const char *cookie_p
   }
d24 17
a40 6
   /* convert /hoge/ to /hoge */
-  len = strlen(new_path);
-  if(1 < len && new_path[len - 1] == '/') {
+  if(len && new_path[len - 1] == '/') {
     new_path[len - 1] = 0x0;
   }
d42 1
@


1.2.4.1
log
@Security fixes for
CVE-2014-3613 (libcurl cookie leak with IP address as domain)
CVE-2014-3620 (libcurl cookie leak for TLDs)
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
CVE-2014-3613: libcurl cookie leak with IP address as domain
http://curl.haxx.se/docs/adv_20140910A.html
d6 4
a9 15
CVE-2014-3620: libcurl cookie leak for TLDs
http://curl.haxx.se/docs/adv_20140910B.html

--- lib/cookie.c.orig	Fri Apr 25 14:01:03 2014
+++ lib/cookie.c	Sat Sep 13 21:05:19 2014
@@@@ -95,6 +95,7 @@@@ Example set of cookies:
 #include "strtoofft.h"
 #include "rawstr.h"
 #include "curl_memrchr.h"
+#include "inet_pton.h"
 
 /* The last #include file should be: */
 #include "memdebug.h"
@@@@ -319,6 +320,28 @@@@ static void remove_expired(struct CookieInfo *cookies)
   }
d12 26
a37 16
+/*
+ * Return true if the given string is an IP(v4|v6) address.
+ */
+static bool isip(const char *domain)
+{
+  struct in_addr addr;
+#ifdef ENABLE_IPV6
+  struct in6_addr addr6;
+#endif
+
+  if(Curl_inet_pton(AF_INET, domain, &addr)
+#ifdef ENABLE_IPV6
+     || Curl_inet_pton(AF_INET6, domain, &addr6)
+#endif
+    ) {
+    /* domain name given as IP address */
a38 2
+  }
+
d40 1
a40 75
+}
+
 /****************************************************************************
  *
  * Curl_cookie_add()
@@@@ -439,24 +462,33 @@@@ Curl_cookie_add(struct SessionHandle *data,
           }
         }
         else if(Curl_raw_equal("domain", name)) {
+          bool is_ip;
+          const char *dotp;
+
           /* Now, we make sure that our host is within the given domain,
              or the given domain is not valid and thus cannot be set. */
 
           if('.' == whatptr[0])
             whatptr++; /* ignore preceding dot */
 
-          if(!domain || tailmatch(whatptr, domain)) {
-            const char *tailptr=whatptr;
-            if(tailptr[0] == '.')
-              tailptr++;
-            strstore(&co->domain, tailptr); /* don't prefix w/dots
-                                               internally */
+          is_ip = isip(domain ? domain : whatptr);
+
+          /* check for more dots */
+          dotp = strchr(whatptr, '.');
+          if(!dotp)
+            domain=":";
+
+          if(!domain
+             || (is_ip && !strcmp(whatptr, domain))
+             || (!is_ip && tailmatch(whatptr, domain))) {
+            strstore(&co->domain, whatptr);
             if(!co->domain) {
               badcookie = TRUE;
               break;
             }
-            co->tailmatch=TRUE; /* we always do that if the domain name was
-                                   given */
+            if(!is_ip)
+              co->tailmatch=TRUE; /* we always do that if the domain name was
+                                     given */
           }
           else {
             /* we did not get a tailmatch and then the attempted set domain
@@@@ -968,6 +1000,7 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
   time_t now = time(NULL);
   struct Cookie *mainco=NULL;
   size_t matches = 0;
+  bool is_ip;
 
   if(!c || !c->cookies)
     return NULL; /* no cookie struct or no cookies in the struct */
@@@@ -975,6 +1008,9 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
   /* at first, remove expired cookies */
   remove_expired(c);
 
+  /* check if host is an IP(v4|v6) address */
+  is_ip = isip(host);
+
   co = c->cookies;
 
   while(co) {
@@@@ -986,8 +1022,8 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
 
       /* now check if the domain is correct */
       if(!co->domain ||
-         (co->tailmatch && tailmatch(co->domain, host)) ||
-         (!co->tailmatch && Curl_raw_equal(host, co->domain)) ) {
+         (co->tailmatch && !is_ip && tailmatch(co->domain, host)) ||
+         ((!co->tailmatch || is_ip) && Curl_raw_equal(host, co->domain)) ) {
         /* the right part of the host matches the domain stuff in the
            cookie data */
d42 1
@


1.2.4.2
log
@Security fixes:
CVE-2015-3143: Re-using authenticated connection when unauthenticated
CVE-2015-3144: host name out of boundary memory access
CVE-2015-3145: cookie parser out of boundary memory access
CVE-2015-3148: Negotiate not treated as connection-oriented
CVE-2015-3153: sensitive HTTP server headers also sent to proxies

Backport for CVE-2015-3148 from Ubuntu.
@
text
@d1 1
a1 4
$OpenBSD: patch-lib_cookie_c,v 1.2.4.1 2014/09/13 19:57:07 naddy Exp $

CVE-2015-3145: cookie parser out of boundary memory access
http://curl.haxx.se/docs/adv_20150422C.html
d10 1
a10 1
+++ lib/cookie.c	Fri May  1 21:23:40 2015
d19 1
a19 29
@@@@ -232,11 +233,14 @@@@ static char *sanitize_cookie_path(const char *cookie_p
     return NULL;
 
   /* some stupid site sends path attribute with '"'. */
+  len = strlen(new_path);
   if(new_path[0] == '\"') {
-    memmove((void *)new_path, (const void *)(new_path + 1), strlen(new_path));
+    memmove((void *)new_path, (const void *)(new_path + 1), len);
+    len--;
   }
-  if(new_path[strlen(new_path) - 1] == '\"') {
-    new_path[strlen(new_path) - 1] = 0x0;
+  if(len && (new_path[len - 1] == '\"')) {
+    new_path[len - 1] = 0x0;
+    len--;
   }
 
   /* RFC6265 5.2.4 The Path Attribute */
@@@@ -248,8 +252,7 @@@@ static char *sanitize_cookie_path(const char *cookie_p
   }
 
   /* convert /hoge/ to /hoge */
-  len = strlen(new_path);
-  if(1 < len && new_path[len - 1] == '/') {
+  if(len && new_path[len - 1] == '/') {
     new_path[len - 1] = 0x0;
   }
 
@@@@ -319,6 +322,28 @@@@ static void remove_expired(struct CookieInfo *cookies)
d48 1
a48 1
@@@@ -439,24 +464,33 @@@@ Curl_cookie_add(struct SessionHandle *data,
d90 1
a90 1
@@@@ -968,6 +1002,7 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
d98 1
a98 1
@@@@ -975,6 +1010,9 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
d108 1
a108 1
@@@@ -986,8 +1024,8 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
@


1.2.2.1
log
@Security fixes for
CVE-2014-3613 (libcurl cookie leak with IP address as domain)
CVE-2014-3620 (libcurl cookie leak for TLDs)
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
CVE-2014-3613: libcurl cookie leak with IP address as domain
http://curl.haxx.se/docs/adv_20140910A.html
d6 4
a9 15
CVE-2014-3620: libcurl cookie leak for TLDs
http://curl.haxx.se/docs/adv_20140910B.html

--- lib/cookie.c.orig	Wed Oct 23 22:55:34 2013
+++ lib/cookie.c	Thu Sep 11 22:15:47 2014
@@@@ -95,6 +95,7 @@@@ Example set of cookies:
 #include "strtoofft.h"
 #include "rawstr.h"
 #include "curl_memrchr.h"
+#include "inet_pton.h"
 
 /* The last #include file should be: */
 #include "memdebug.h"
@@@@ -319,6 +320,28 @@@@ static void remove_expired(struct CookieInfo *cookies)
   }
d12 26
a37 16
+/*
+ * Return true if the given string is an IP(v4|v6) address.
+ */
+static bool isip(const char *domain)
+{
+  struct in_addr addr;
+#ifdef ENABLE_IPV6
+  struct in6_addr addr6;
+#endif
+
+  if(Curl_inet_pton(AF_INET, domain, &addr)
+#ifdef ENABLE_IPV6
+     || Curl_inet_pton(AF_INET6, domain, &addr6)
+#endif
+    ) {
+    /* domain name given as IP address */
a38 2
+  }
+
d40 1
a40 75
+}
+
 /****************************************************************************
  *
  * Curl_cookie_add()
@@@@ -439,24 +462,33 @@@@ Curl_cookie_add(struct SessionHandle *data,
           }
         }
         else if(Curl_raw_equal("domain", name)) {
+          bool is_ip;
+          const char *dotp;
+
           /* Now, we make sure that our host is within the given domain,
              or the given domain is not valid and thus cannot be set. */
 
           if('.' == whatptr[0])
             whatptr++; /* ignore preceding dot */
 
-          if(!domain || tailmatch(whatptr, domain)) {
-            const char *tailptr=whatptr;
-            if(tailptr[0] == '.')
-              tailptr++;
-            strstore(&co->domain, tailptr); /* don't prefix w/dots
-                                               internally */
+          is_ip = isip(domain ? domain : whatptr);
+
+          /* check for more dots */
+          dotp = strchr(whatptr, '.');
+          if(!dotp)
+            domain=":";
+
+          if(!domain
+             || (is_ip && !strcmp(whatptr, domain))
+             || (!is_ip && tailmatch(whatptr, domain))) {
+            strstore(&co->domain, whatptr);
             if(!co->domain) {
               badcookie = TRUE;
               break;
             }
-            co->tailmatch=TRUE; /* we always do that if the domain name was
-                                   given */
+            if(!is_ip)
+              co->tailmatch=TRUE; /* we always do that if the domain name was
+                                     given */
           }
           else {
             /* we did not get a tailmatch and then the attempted set domain
@@@@ -958,6 +990,7 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
   time_t now = time(NULL);
   struct Cookie *mainco=NULL;
   size_t matches = 0;
+  bool is_ip;
 
   if(!c || !c->cookies)
     return NULL; /* no cookie struct or no cookies in the struct */
@@@@ -965,6 +998,9 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
   /* at first, remove expired cookies */
   remove_expired(c);
 
+  /* check if host is an IP(v4|v6) address */
+  is_ip = isip(host);
+
   co = c->cookies;
 
   while(co) {
@@@@ -976,8 +1012,8 @@@@ struct Cookie *Curl_cookie_getlist(struct CookieInfo *
 
       /* now check if the domain is correct */
       if(!co->domain ||
-         (co->tailmatch && tailmatch(co->domain, host)) ||
-         (!co->tailmatch && Curl_raw_equal(host, co->domain)) ) {
+         (co->tailmatch && !is_ip && tailmatch(co->domain, host)) ||
+         ((!co->tailmatch || is_ip) && Curl_raw_equal(host, co->domain)) ) {
         /* the right part of the host matches the domain stuff in the
            cookie data */
d42 1
@


1.1
log
@Security fix for CVE-2013-1944 curl: Cookie domain suffix match vulnerability

ok naddy@@ (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.2.1
log
@Security fix for CVE-2013-1944 curl: Cookie domain suffix match vulnerability

ok naddy@@ (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_cookie_c,v 1.1 2013/05/07 06:53:26 jasper Exp $
@

