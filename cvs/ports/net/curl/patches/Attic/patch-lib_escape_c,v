head	1.3;
access;
symbols
	OPENBSD_5_9:1.3.0.4
	OPENBSD_6_0:1.3.0.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_0:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2013.10.09.17.25.39;	author naddy;	state dead;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2013.07.16.19.25.38;	author jasper;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2012.01.27.23.08.01;	author ajacoutot;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2012.01.27.23.08.01;	author ajacoutot;	state Exp;
branches;
next	;

1.2.2.1
date	2013.07.16.19.25.57;	author jasper;	state Exp;
branches;
next	;

1.3.2.1
date	2016.09.17.21.39.05;	author naddy;	state Exp;
branches;
next	1.3.2.2;
commitid	5a7T4XRfYINkwxvQ;

1.3.2.2
date	2016.11.04.14.09.36;	author naddy;	state dead;
branches;
next	;
commitid	j8vMfWnDLihMh9DN;

1.3.4.1
date	2016.09.17.21.39.18;	author naddy;	state Exp;
branches;
next	1.3.4.2;
commitid	iZ1E2fNWDnt1hpsi;

1.3.4.2
date	2016.11.04.15.20.52;	author naddy;	state dead;
branches;
next	;
commitid	woi9VmGflxdFUwos;


desc
@@


1.3
log
@Update to 7.32.0.
No revolutionary changes; see http://curl.haxx.se/changes.html for
the details.
@
text
@$OpenBSD: patch-lib_escape_c,v 1.2 2013/07/16 19:25:38 jasper Exp $

Security fix for CVE-2013-2174,
libcURL "curl_easy_unescape()" Buffer Overflow Vulnerability

http://curl.haxx.se/docs/adv_20130622.html

--- lib/escape.c.orig	Tue Jul 16 10:45:29 2013
+++ lib/escape.c	Tue Jul 16 10:46:01 2013
@@@@ -159,7 +159,8 @@@@ CURLcode Curl_urldecode(struct SessionHandle *data,
 
   while(--alloc > 0) {
     in = *string;
-    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
+    if(('%' == in) && (alloc > 2) &&
+      ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
       /* this is two hexadecimal digits following a '%' */
       char hexstr[3];
       char *ptr;
@


1.3.4.1
log
@Security fix:
CVE-2016-7167: curl escape and unescape integer overflows
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
CVE-2016-7167: curl escape and unescape integer overflows
d6 5
a10 50
--- lib/escape.c.orig	Fri Nov 27 16:00:14 2015
+++ lib/escape.c	Sat Sep 17 22:22:11 2016
@@@@ -78,15 +78,21 @@@@ char *curl_unescape(const char *string, int length)
 
 char *curl_easy_escape(CURL *handle, const char *string, int inlength)
 {
-  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
+  size_t alloc;
   char *ns;
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
-  size_t newlen = alloc;
+  size_t newlen;
   size_t strindex=0;
   size_t length;
   CURLcode result;
 
+  if(inlength < 0)
+    return NULL;
+
+  alloc = (inlength?(size_t)inlength:strlen(string))+1;
+  newlen = alloc;
+
   ns = malloc(alloc);
   if(!ns)
     return NULL;
@@@@ -211,14 +217,16 @@@@ char *curl_easy_unescape(CURL *handle, const char *str
                          int *olen)
 {
   char *str = NULL;
-  size_t inputlen = length;
-  size_t outputlen;
-  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
-                                FALSE);
-  if(res)
-    return NULL;
-  if(olen)
-    *olen = curlx_uztosi(outputlen);
+  if(length >= 0) {
+    size_t inputlen = length;
+    size_t outputlen;
+    CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
+                                  FALSE);
+    if(res)
+      return NULL;
+    if(olen)
+      *olen = curlx_uztosi(outputlen);
+  }
   return str;
 }
d12 8
@


1.3.4.2
log
@Security update to 7.51.0.
CVE-2016-8615: cookie injection for other servers
CVE-2016-8616: case insensitive password comparison
CVE-2016-8617: OOB write via unchecked multiplication
CVE-2016-8618: double-free in curl_maprintf
CVE-2016-8619: double-free in krb5 code
CVE-2016-8620: glob parser write/read out of bounds
CVE-2016-8621: curl_getdate read out of bounds
CVE-2016-8622: URL unescape heap overflow via integer truncation
CVE-2016-8623: Use-after-free via shared cookies
CVE-2016-8624: invalid URL parsing with '#'
CVE-2016-8625: IDNA 2003 makes curl use wrong host

Note that this drops support for internationalized domain names.
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_escape_c,v 1.3.4.1 2016/09/17 21:39:18 naddy Exp $
@


1.3.2.1
log
@Security fix:
CVE-2016-7167: curl escape and unescape integer overflows
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
CVE-2016-7167: curl escape and unescape integer overflows
d6 5
a10 50
--- lib/escape.c.orig	Mon May 16 09:23:33 2016
+++ lib/escape.c	Sat Sep 17 23:16:57 2016
@@@@ -77,15 +77,21 @@@@ char *curl_unescape(const char *string, int length)
 
 char *curl_easy_escape(CURL *handle, const char *string, int inlength)
 {
-  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
+  size_t alloc;
   char *ns;
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
-  size_t newlen = alloc;
+  size_t newlen;
   size_t strindex=0;
   size_t length;
   CURLcode result;
 
+  if(inlength < 0)
+    return NULL;
+
+  alloc = (inlength?(size_t)inlength:strlen(string))+1;
+  newlen = alloc;
+
   ns = malloc(alloc);
   if(!ns)
     return NULL;
@@@@ -210,14 +216,16 @@@@ char *curl_easy_unescape(CURL *handle, const char *str
                          int *olen)
 {
   char *str = NULL;
-  size_t inputlen = length;
-  size_t outputlen;
-  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
-                                FALSE);
-  if(res)
-    return NULL;
-  if(olen)
-    *olen = curlx_uztosi(outputlen);
+  if(length >= 0) {
+    size_t inputlen = length;
+    size_t outputlen;
+    CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
+                                  FALSE);
+    if(res)
+      return NULL;
+    if(olen)
+      *olen = curlx_uztosi(outputlen);
+  }
   return str;
 }
d12 8
@


1.3.2.2
log
@Security update to 7.51.0.
CVE-2016-8615: cookie injection for other servers
CVE-2016-8616: case insensitive password comparison
CVE-2016-8617: OOB write via unchecked multiplication
CVE-2016-8618: double-free in curl_maprintf
CVE-2016-8619: double-free in krb5 code
CVE-2016-8620: glob parser write/read out of bounds
CVE-2016-8621: curl_getdate read out of bounds
CVE-2016-8622: URL unescape heap overflow via integer truncation
CVE-2016-8623: Use-after-free via shared cookies
CVE-2016-8624: invalid URL parsing with '#'
CVE-2016-8625: IDNA 2003 makes curl use wrong host

Note that this drops support for internationalized domain names.
ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_escape_c,v 1.3.2.1 2016/09/17 21:39:05 naddy Exp $
@


1.2
log
@Security fix for CVE-2013-2174,
libcURL "curl_easy_unescape()" Buffer Overflow Vulnerability

ok naddy@@ (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2.2.1
log
@Security fix for CVE-2013-2174,
libcURL "curl_easy_unescape()" Buffer Overflow Vulnerability

ok naddy@@ (MAINTAINER)
@
text
@@


1.1
log
@file patch-lib_escape_c was initially added on branch OPENBSD_5_0.
@
text
@d1 19
@


1.1.2.1
log
@SECURITY fix for multiple vulnerabilities:
URL sanitize: reject URLs containing bad data (CVE-2012-0036)
OpenSSL: don't disable security work-around

ok sthen@@ naddy@@ (maintainer)
@
text
@a0 122
$OpenBSD$

From upstream: 75ca568fa1c19de4c5358fed246686de8467c238
URL sanitize: reject URLs containing bad data
CVE-2012-0036: http://curl.haxx.se/docs/adv_20120124.html

--- lib/escape.c.orig	Mon May 23 19:08:12 2011
+++ lib/escape.c	Fri Jan 27 08:41:52 2012
@@@@ -34,6 +34,7 @@@@
 #include "urldata.h"
 #include "warnless.h"
 #include "non-ascii.h"
+#include "escape.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
@@@@ -87,7 +88,7 @@@@ char *curl_easy_escape(CURL *handle, const char *strin
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
-  int strindex=0;
+  size_t strindex=0;
   size_t length;
   CURLcode res;
 
@@@@ -135,23 +136,29 @@@@ char *curl_easy_escape(CURL *handle, const char *strin
 }
 
 /*
- * Unescapes the given URL escaped string of given length. Returns a
- * pointer to a malloced string with length given in *olen.
- * If length == 0, the length is assumed to be strlen(string).
- * If olen == NULL, no output length is stored.
+ * Curl_urldecode() URL decodes the given string.
+ *
+ * Optionally detects control characters (byte codes lower than 32) in the
+ * data and rejects such data.
+ *
+ * Returns a pointer to a malloced string in *ostring with length given in
+ * *olen. If length == 0, the length is assumed to be strlen(string).
+ *
  */
-char *curl_easy_unescape(CURL *handle, const char *string, int length,
-                         int *olen)
+CURLcode Curl_urldecode(struct SessionHandle *data,
+                        const char *string, size_t length,
+                        char **ostring, size_t *olen,
+                        bool reject_ctrl)
 {
-  int alloc = (length?length:(int)strlen(string))+1;
+  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
-  int strindex=0;
+  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
-    return NULL;
+    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
@@@@ -167,16 +174,20 @@@@ char *curl_easy_unescape(CURL *handle, const char *str
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
-      res = Curl_convert_from_network(handle, &in, 1);
+      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
-        return NULL;
+        return res;
       }
 
       string+=2;
       alloc-=2;
     }
+    if(reject_ctrl && (in < 0x20)) {
+      free(ns);
+      return CURLE_URL_MALFORMAT;
+    }
 
     ns[strindex++] = in;
     string++;
@@@@ -186,7 +197,33 @@@@ char *curl_easy_unescape(CURL *handle, const char *str
   if(olen)
     /* store output size */
     *olen = strindex;
-  return ns;
+
+  if(ostring)
+    /* store output string */
+    *ostring = ns;
+
+  return CURLE_OK;
+}
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string with length given in *olen.
+ * If length == 0, the length is assumed to be strlen(string).
+ * If olen == NULL, no output length is stored.
+ */
+char *curl_easy_unescape(CURL *handle, const char *string, int length,
+                         int *olen)
+{
+  char *str = NULL;
+  size_t inputlen = length;
+  size_t outputlen;
+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
+                                FALSE);
+  if(res)
+    return NULL;
+  if(olen)
+    *olen = curlx_uztosi(outputlen);
+  return str;
 }
 
 /* For operating systems/environments that use different malloc/free
@

