head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.10
	OPENBSD_5_9:1.3.0.8
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_4:1.2.0.2
	OPENBSD_4_5:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2014.03.10.22.43.38;	author naddy;	state dead;
branches
	1.3.2.1
	1.3.4.1
	1.3.6.1
	1.3.8.1
	1.3.10.1;
next	1.2;

1.2
date	2014.02.03.21.52.14;	author naddy;	state Exp;
branches
	1.2.2.1
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2009.07.15.02.52.09;	author william;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2009.07.15.02.52.09;	author william;	state Exp;
branches;
next	;

1.2.2.1
date	2014.02.03.21.57.31;	author naddy;	state Exp;
branches;
next	;

1.2.4.1
date	2014.02.03.21.59.25;	author naddy;	state Exp;
branches;
next	;

1.2.6.1
date	2015.01.11.22.53.15;	author naddy;	state Exp;
branches;
next	;
commitid	HTkqIXpPaz4yHqG6;

1.3.2.1
date	2015.01.12.02.17.10;	author naddy;	state Exp;
branches;
next	1.3.2.2;
commitid	tJBKky4C4oSbqx2b;

1.3.2.2
date	2015.05.01.20.39.42;	author naddy;	state Exp;
branches;
next	;
commitid	Ij8k3y0w8XICbM4N;

1.3.4.1
date	2015.04.30.23.18.27;	author naddy;	state Exp;
branches;
next	;
commitid	zXKzsZprdoQeh32Z;

1.3.6.1
date	2016.01.29.23.53.07;	author naddy;	state Exp;
branches;
next	;
commitid	ZT0EqoAzyI0DSzya;

1.3.8.1
date	2016.08.03.22.04.40;	author naddy;	state Exp;
branches;
next	1.3.8.2;
commitid	w1tVN8qfx3AaO8h1;

1.3.8.2
date	2016.11.04.15.20.52;	author naddy;	state dead;
branches;
next	;
commitid	woi9VmGflxdFUwos;

1.3.10.1
date	2016.08.04.10.48.03;	author naddy;	state Exp;
branches;
next	1.3.10.2;
commitid	Cdkz6qSFEO9MccH1;

1.3.10.2
date	2016.11.04.14.09.36;	author naddy;	state dead;
branches;
next	;
commitid	j8vMfWnDLihMh9DN;


desc
@@


1.3
log
@maintenance update to 7.35.0
@
text
@$OpenBSD: patch-lib_url_c,v 1.2 2014/02/03 21:52:14 naddy Exp $

Security fix for CVE-2014-0015: re-use of wrong HTTP NTLM connection
http://curl.haxx.se/docs/adv_20140129.html

--- lib/url.c.orig	Mon Dec 16 23:02:35 2013
+++ lib/url.c	Sun Feb  2 11:57:42 2014
@@@@ -2886,8 +2886,8 @@@@ ConnectionExists(struct SessionHandle *data,
   struct connectdata *check;
   struct connectdata *chosen = 0;
   bool canPipeline = IsPipeliningPossible(data, needle);
-  bool wantNTLM = (data->state.authhost.want==CURLAUTH_NTLM) ||
-                  (data->state.authhost.want==CURLAUTH_NTLM_WB) ? TRUE : FALSE;
+  bool wantNTLM = (data->state.authhost.want & CURLAUTH_NTLM) ||
+    (data->state.authhost.want & CURLAUTH_NTLM_WB) ? TRUE : FALSE;
   struct connectbundle *bundle;
 
   *force_reuse = FALSE;
@


1.3.10.1
log
@Security fixes:
CVE-2016-5419: TLS session resumption client cert bypass
CVE-2016-5420: Re-using connections with wrong client cert
CVE-2016-5421: use of connection struct after free
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
CVE-2016-5419: TLS session resumption client cert bypass
d6 13
a18 10
--- lib/url.c.orig	Mon May 16 09:23:43 2016
+++ lib/url.c	Thu Aug  4 00:55:35 2016
@@@@ -6103,6 +6103,7 @@@@ static CURLcode create_conn(struct SessionHandle *data
   data->set.ssl.random_file = data->set.str[STRING_SSL_RANDOM_FILE];
   data->set.ssl.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];
   data->set.ssl.cipher_list = data->set.str[STRING_SSL_CIPHER_LIST];
+  data->set.ssl.clientcert = data->set.str[STRING_CERT];
 #ifdef USE_TLS_SRP
   data->set.ssl.username = data->set.str[STRING_TLSAUTH_USERNAME];
   data->set.ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD];
@


1.3.10.2
log
@Security update to 7.51.0.
CVE-2016-8615: cookie injection for other servers
CVE-2016-8616: case insensitive password comparison
CVE-2016-8617: OOB write via unchecked multiplication
CVE-2016-8618: double-free in curl_maprintf
CVE-2016-8619: double-free in krb5 code
CVE-2016-8620: glob parser write/read out of bounds
CVE-2016-8621: curl_getdate read out of bounds
CVE-2016-8622: URL unescape heap overflow via integer truncation
CVE-2016-8623: Use-after-free via shared cookies
CVE-2016-8624: invalid URL parsing with '#'
CVE-2016-8625: IDNA 2003 makes curl use wrong host

Note that this drops support for internationalized domain names.
ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_url_c,v 1.3.10.1 2016/08/04 10:48:03 naddy Exp $
@


1.3.8.1
log
@Security fixes:
CVE-2016-5419: TLS session resumption client cert bypass
CVE-2016-5420: Re-using connections with wrong client cert
CVE-2016-5421: use of connection struct after free
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
CVE-2016-5419: TLS session resumption client cert bypass
d6 13
a18 10
--- lib/url.c.orig	Wed Jan 27 08:23:39 2016
+++ lib/url.c	Wed Aug  3 23:38:02 2016
@@@@ -5781,6 +5781,7 @@@@ static CURLcode create_conn(struct SessionHandle *data
   data->set.ssl.random_file = data->set.str[STRING_SSL_RANDOM_FILE];
   data->set.ssl.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];
   data->set.ssl.cipher_list = data->set.str[STRING_SSL_CIPHER_LIST];
+  data->set.ssl.clientcert = data->set.str[STRING_CERT];
 #ifdef USE_TLS_SRP
   data->set.ssl.username = data->set.str[STRING_TLSAUTH_USERNAME];
   data->set.ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD];
@


1.3.8.2
log
@Security update to 7.51.0.
CVE-2016-8615: cookie injection for other servers
CVE-2016-8616: case insensitive password comparison
CVE-2016-8617: OOB write via unchecked multiplication
CVE-2016-8618: double-free in curl_maprintf
CVE-2016-8619: double-free in krb5 code
CVE-2016-8620: glob parser write/read out of bounds
CVE-2016-8621: curl_getdate read out of bounds
CVE-2016-8622: URL unescape heap overflow via integer truncation
CVE-2016-8623: Use-after-free via shared cookies
CVE-2016-8624: invalid URL parsing with '#'
CVE-2016-8625: IDNA 2003 makes curl use wrong host

Note that this drops support for internationalized domain names.
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_url_c,v 1.3.8.1 2016/08/03 22:04:40 naddy Exp $
@


1.3.6.1
log
@Security fix for
CVE-2016-0755: NTLM credentials not-checked for proxy connection re-use
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
CVE-2016-0755: NTLM credentials not-checked for proxy connection re-use
http://curl.haxx.se/docs/adv_20160127A.html
d6 3
a8 3
--- lib/url.c.orig	Sat Jun 13 00:20:46 2015
+++ lib/url.c	Fri Jan 29 23:54:11 2016
@@@@ -3107,12 +3107,17 @@@@ ConnectionExists(struct SessionHandle *data,
d12 5
a16 15
+  struct connectbundle *bundle;
+
 #ifdef USE_NTLM
-  bool wantNTLMhttp = ((data->state.authhost.want & CURLAUTH_NTLM) ||
-                       (data->state.authhost.want & CURLAUTH_NTLM_WB)) &&
-    (needle->handler->protocol & PROTO_FAMILY_HTTP) ? TRUE : FALSE;
+  bool wantNTLMhttp = ((data->state.authhost.want &
+                      (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&
+                      (needle->handler->protocol & PROTO_FAMILY_HTTP));
+  bool wantProxyNTLMhttp = (needle->bits.proxy_user_passwd &&
+                           ((data->state.authproxy.want &
+                           (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&
+                           (needle->handler->protocol & PROTO_FAMILY_HTTP)));
 #endif
-  struct connectbundle *bundle;
a18 85
   *waitpipe = FALSE;
@@@@ -3152,9 +3157,6 @@@@ ConnectionExists(struct SessionHandle *data,
     curr = bundle->conn_list->head;
     while(curr) {
       bool match = FALSE;
-#if defined(USE_NTLM)
-      bool credentialsMatch = FALSE;
-#endif
       size_t pipeLen;
 
       /*
@@@@ -3262,21 +3264,14 @@@@ ConnectionExists(struct SessionHandle *data,
           continue;
       }
 
-      if((!(needle->handler->flags & PROTOPT_CREDSPERREQUEST))
-#ifdef USE_NTLM
-         || (wantNTLMhttp || check->ntlm.state != NTLMSTATE_NONE)
-#endif
-        ) {
-        /* This protocol requires credentials per connection or is HTTP+NTLM,
+      if(!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) {
+        /* This protocol requires credentials per connection,
            so verify that we're using the same name and password as well */
         if(!strequal(needle->user, check->user) ||
            !strequal(needle->passwd, check->passwd)) {
           /* one of them was different */
           continue;
         }
-#if defined(USE_NTLM)
-        credentialsMatch = TRUE;
-#endif
       }
 
       if(!needle->bits.httpproxy || needle->handler->flags&PROTOPT_SSL ||
@@@@ -3335,20 +3330,43 @@@@ ConnectionExists(struct SessionHandle *data,
            possible. (Especially we must not reuse the same connection if
            partway through a handshake!) */
         if(wantNTLMhttp) {
-          if(credentialsMatch && check->ntlm.state != NTLMSTATE_NONE) {
-            chosen = check;
+          if(!strequal(needle->user, check->user) ||
+             !strequal(needle->passwd, check->passwd))
+            continue;
+        }
+        else if(check->ntlm.state != NTLMSTATE_NONE) {
+          /* Connection is using NTLM auth but we don't want NTLM */
+          continue;
+        }
 
+        /* Same for Proxy NTLM authentication */
+        if(wantProxyNTLMhttp) {
+          if(!strequal(needle->proxyuser, check->proxyuser) ||
+             !strequal(needle->proxypasswd, check->proxypasswd))
+            continue;
+        }
+        else if(check->proxyntlm.state != NTLMSTATE_NONE) {
+          /* Proxy connection is using NTLM auth but we don't want NTLM */
+          continue;
+        }
+
+        if(wantNTLMhttp || wantProxyNTLMhttp) {
+          /* Credentials are already checked, we can use this connection */
+          chosen = check;
+
+          if((wantNTLMhttp &&
+             (check->ntlm.state != NTLMSTATE_NONE)) ||
+              (wantProxyNTLMhttp &&
+               (check->proxyntlm.state != NTLMSTATE_NONE))) {
             /* We must use this connection, no other */
             *force_reuse = TRUE;
             break;
           }
-          else if(credentialsMatch)
-            /* this is a backup choice */
-            chosen = check;
+
+          /* Continue look up for a better connection */
           continue;
         }
 #endif
-
         if(canPipeline) {
           /* We can pipeline if we want to. Let's continue looking for
              the optimal connection to use, i.e the shortest pipe that is not
@


1.3.4.1
log
@Security fixes:
CVE-2015-3143: Re-using authenticated connection when unauthenticated
CVE-2015-3144: host name out of boundary memory access
CVE-2015-3145: cookie parser out of boundary memory access
CVE-2015-3148: Negotiate not treated as connection-oriented
CVE-2015-3153: sensitive HTTP server headers also sent to proxies
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
CVE-2015-3143: Re-using authenticated connection when unauthenticated
http://curl.haxx.se/docs/adv_20150422A.html
d6 11
a16 27
CVE-2015-3144: host name out of boundary memory access
http://curl.haxx.se/docs/adv_20150422D.html

CVE-2015-3153: sensitive HTTP server headers also sent to proxies
http://curl.haxx.se/docs/adv_20150429.html

--- lib/url.c.orig	Thu Jan  8 09:05:07 2015
+++ lib/url.c	Fri May  1 00:39:50 2015
@@@@ -605,6 +605,7 @@@@ CURLcode Curl_init_userdefined(struct UserDefined *set
   set->ssl_enable_alpn = TRUE;
 
   set->expect_100_timeout = 1000L; /* Wait for a second by default. */
+  set->sep_headers = TRUE; /* separated header lists by default */
   return result;
 }
 
@@@@ -3184,7 +3185,7 @@@@ ConnectionExists(struct SessionHandle *data,
       }
 
       if((!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) ||
-         wantNTLMhttp) {
+         (wantNTLMhttp || check->ntlm.state != NTLMSTATE_NONE)) {
         /* This protocol requires credentials per connection or is HTTP+NTLM,
            so verify that we're using the same name and password as well */
         if(!strequal(needle->user, check->user) ||
@@@@ -3602,7 +3603,7 @@@@ static void fix_hostname(struct SessionHandle *data,
   host->dispname = host->name;
d18 1
a18 6
   len = strlen(host->name);
-  if(host->name[len-1] == '.')
+  if(len && (host->name[len-1] == '.'))
     /* strip off a single trailing dot if present, primarily for SNI but
        there's no use for it */
     host->name[len-1]=0;
@


1.3.2.1
log
@Security fixes for
CVE-2014-3707: libcurl duphandle read out of bounds
CVE-2014-8150: URL request injection
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
CVE-2014-3707: libcurl duphandle read out of bounds
http://curl.haxx.se/docs/adv_20141105.html
d6 11
a16 64
CVE-2014-8150: URL request injection
http://curl.haxx.se/docs/adv_20150108B.html

--- lib/url.c.orig	Tue May 20 10:34:01 2014
+++ lib/url.c	Mon Jan 12 02:13:01 2015
@@@@ -125,6 +125,7 @@@@ int curl_win32_idn_to_ascii(const char *in, char **out
 #include "multihandle.h"
 #include "pipeline.h"
 #include "dotdot.h"
+#include "strdup.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
@@@@ -270,8 +271,9 @@@@ void Curl_freeset(struct SessionHandle *data)
 {
   /* Free all dynamic strings stored in the data->set substructure. */
   enum dupstring i;
-  for(i=(enum dupstring)0; i < STRING_LAST; i++)
+  for(i=(enum dupstring)0; i < STRING_LAST; i++) {
     Curl_safefree(data->set.str[i]);
+  }
 
   if(data->change.referer_alloc) {
     Curl_safefree(data->change.referer);
@@@@ -351,14 +353,24 @@@@ CURLcode Curl_dupset(struct SessionHandle *dst, struct
   memset(dst->set.str, 0, STRING_LAST * sizeof(char *));
 
   /* duplicate all strings */
-  for(i=(enum dupstring)0; i< STRING_LAST; i++) {
+  for(i=(enum dupstring)0; i< STRING_LASTZEROTERMINATED; i++) {
     r = setstropt(&dst->set.str[i], src->set.str[i]);
     if(r != CURLE_OK)
-      break;
+      return r;
   }
 
-  /* If a failure occurred, freeing has to be performed externally. */
-  return r;
+  /* duplicate memory areas pointed to */
+  i = STRING_COPYPOSTFIELDS;
+  if(src->set.postfieldsize && src->set.str[i]) {
+    /* postfieldsize is curl_off_t, Curl_memdup() takes a size_t ... */
+    dst->set.str[i] = Curl_memdup(src->set.str[i], src->set.postfieldsize);
+    if(!dst->set.str[i])
+      return CURLE_OUT_OF_MEMORY;
+    /* point to the new copy */
+    dst->set.postfields = dst->set.str[i];
+  }
+
+  return CURLE_OK;
 }
 
 /*
@@@@ -3747,6 +3759,13 @@@@ static CURLcode parseurlandfillconn(struct SessionHand
   bool rebuild_url = FALSE;
 
   *prot_missing = FALSE;
+
+  /* We might pass the entire URL into the request so we need to make sure
+   * there are no bad characters in there.*/
+  if(strpbrk(data->change.url, "\r\n")) {
+    failf(data, "Illegal characters found in URL");
+    return CURLE_URL_MALFORMAT;
+  }
d18 1
a18 2
   /*************************************************************
    * Parse the URL.
@


1.3.2.2
log
@Security fixes:
CVE-2015-3143: Re-using authenticated connection when unauthenticated
CVE-2015-3144: host name out of boundary memory access
CVE-2015-3145: cookie parser out of boundary memory access
CVE-2015-3148: Negotiate not treated as connection-oriented
CVE-2015-3153: sensitive HTTP server headers also sent to proxies

Backport for CVE-2015-3148 from Ubuntu.
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_url_c,v 1.3.2.1 2015/01/12 02:17:10 naddy Exp $
a8 9
CVE-2015-3153: sensitive HTTP server headers also sent to proxies
http://curl.haxx.se/docs/adv_20150429.html

CVE-2015-3143: Re-using authenticated connection when unauthenticated
http://curl.haxx.se/docs/adv_20150422A.html

CVE-2015-3144: host name out of boundary memory access
http://curl.haxx.se/docs/adv_20150422D.html

d10 1
a10 1
+++ lib/url.c	Fri May  1 21:29:00 2015
d59 1
a59 27
@@@@ -567,6 +579,7 @@@@ CURLcode Curl_init_userdefined(struct UserDefined *set
   set->ssl_enable_alpn = TRUE;
 
   set->expect_100_timeout = 1000L; /* Wait for a second by default. */
+  set->sep_headers = TRUE; /* separated header lists by default */
   return res;
 }
 
@@@@ -3083,7 +3096,7 @@@@ ConnectionExists(struct SessionHandle *data,
       }
 
       if((!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) ||
-         wantNTLMhttp) {
+         (wantNTLMhttp || check->ntlm.state != NTLMSTATE_NONE)) {
         /* This protocol requires credentials per connection or is HTTP+NTLM,
            so verify that we're using the same name and password as well */
         if(!strequal(needle->user, check->user) ||
@@@@ -3509,7 +3522,7 @@@@ static void fix_hostname(struct SessionHandle *data,
   host->dispname = host->name;
 
   len = strlen(host->name);
-  if(host->name[len-1] == '.')
+  if(len && (host->name[len-1] == '.'))
     /* strip off a single trailing dot if present, primarily for SNI but
        there's no use for it */
     host->name[len-1]=0;
@@@@ -3747,6 +3760,13 @@@@ static CURLcode parseurlandfillconn(struct SessionHand
@


1.2
log
@Security fix for CVE-2014-0015: re-use of wrong HTTP NTLM connection
http://curl.haxx.se/docs/adv_20140129.html
From: Donovan Watteau
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2.6.1
log
@Security fixes for
CVE-2014-3707: libcurl duphandle read out of bounds
CVE-2014-8150: URL request injection
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_url_c,v 1.2 2014/02/03 21:52:14 naddy Exp $
d3 1
a3 4
CVE-2014-3707: libcurl duphandle read out of bounds 
http://curl.haxx.se/docs/adv_20141105.html

CVE-2014-0015: re-use of wrong HTTP NTLM connection
a5 3
CVE-2014-8150: URL request injection
http://curl.haxx.se/docs/adv_20150108B.html

d7 2
a8 50
+++ lib/url.c	Sun Jan 11 22:22:46 2015
@@@@ -125,6 +125,7 @@@@ int curl_win32_idn_to_ascii(const char *in, char **out
 #include "multihandle.h"
 #include "pipeline.h"
 #include "dotdot.h"
+#include "strdup.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
@@@@ -270,8 +271,9 @@@@ void Curl_freeset(struct SessionHandle *data)
 {
   /* Free all dynamic strings stored in the data->set substructure. */
   enum dupstring i;
-  for(i=(enum dupstring)0; i < STRING_LAST; i++)
+  for(i=(enum dupstring)0; i < STRING_LAST; i++) {
     Curl_safefree(data->set.str[i]);
+  }
 
   if(data->change.referer_alloc) {
     Curl_safefree(data->change.referer);
@@@@ -351,14 +353,24 @@@@ CURLcode Curl_dupset(struct SessionHandle *dst, struct
   memset(dst->set.str, 0, STRING_LAST * sizeof(char *));
 
   /* duplicate all strings */
-  for(i=(enum dupstring)0; i< STRING_LAST; i++) {
+  for(i=(enum dupstring)0; i< STRING_LASTZEROTERMINATED; i++) {
     r = setstropt(&dst->set.str[i], src->set.str[i]);
     if(r != CURLE_OK)
-      break;
+      return r;
   }
 
-  /* If a failure occurred, freeing has to be performed externally. */
-  return r;
+  /* duplicate memory areas pointed to */
+  i = STRING_COPYPOSTFIELDS;
+  if(src->set.postfieldsize && src->set.str[i]) {
+    /* postfieldsize is curl_off_t, Curl_memdup() takes a size_t ... */
+    dst->set.str[i] = Curl_memdup(src->set.str[i], src->set.postfieldsize);
+    if(!dst->set.str[i])
+      return CURLE_OUT_OF_MEMORY;
+    /* point to the new copy */
+    dst->set.postfields = dst->set.str[i];
+  }
+
+  return CURLE_OK;
 }
 
 /*
@@@@ -2886,8 +2898,8 @@@@ ConnectionExists(struct SessionHandle *data,
a18 14
@@@@ -3694,6 +3706,13 @@@@ static CURLcode parseurlandfillconn(struct SessionHand
   bool rebuild_url = FALSE;
 
   *prot_missing = FALSE;
+
+  /* We might pass the entire URL into the request so we need to make sure
+   * there are no bad characters in there.*/
+  if(strpbrk(data->change.url, "\r\n")) {
+    failf(data, "Illegal characters found in URL");
+    return CURLE_URL_MALFORMAT;
+  }
 
   /*************************************************************
    * Parse the URL.
@


1.2.4.1
log
@Security fix for CVE-2014-0015: re-use of wrong HTTP NTLM connection
http://curl.haxx.se/docs/adv_20140129.html
From: Donovan Watteau
@
text
@d6 13
a18 13
--- lib/url.c.orig	Wed Apr 25 17:29:20 2012
+++ lib/url.c	Fri Jan 31 13:28:53 2014
@@@@ -3103,8 +3103,8 @@@@ ConnectionExists(struct SessionHandle *data,
         }
         if((needle->handler->protocol & CURLPROTO_FTP) ||
            ((needle->handler->protocol & CURLPROTO_HTTP) &&
-            ((data->state.authhost.want==CURLAUTH_NTLM) ||
-             (data->state.authhost.want==CURLAUTH_NTLM_WB)))) {
+            ((data->state.authhost.want & CURLAUTH_NTLM) ||
+             (data->state.authhost.want & CURLAUTH_NTLM_WB)))) {
           /* This is FTP or HTTP+NTLM, verify that we're using the same name
              and password as well */
           if(!strequal(needle->user, check->user) ||
@


1.2.2.1
log
@Security fix for CVE-2014-0015: re-use of wrong HTTP NTLM connection
http://curl.haxx.se/docs/adv_20140129.html
From: Donovan Watteau
@
text
@d6 13
a18 13
--- lib/url.c.orig	Wed Apr 25 17:29:20 2012
+++ lib/url.c	Fri Jan 31 12:20:11 2014
@@@@ -3103,8 +3103,8 @@@@ ConnectionExists(struct SessionHandle *data,
         }
         if((needle->handler->protocol & CURLPROTO_FTP) ||
            ((needle->handler->protocol & CURLPROTO_HTTP) &&
-            ((data->state.authhost.want==CURLAUTH_NTLM) ||
-             (data->state.authhost.want==CURLAUTH_NTLM_WB)))) {
+            ((data->state.authhost.want & CURLAUTH_NTLM) ||
+             (data->state.authhost.want & CURLAUTH_NTLM_WB)))) {
           /* This is FTP or HTTP+NTLM, verify that we're using the same name
              and password as well */
           if(!strequal(needle->user, check->user) ||
@


1.1
log
@file patch-lib_url_c was initially added on branch OPENBSD_4_5.
@
text
@d1 18
@


1.1.2.1
log
@SECURITY FIX

Resolve CVE-2009-0037:
Rogue servers could trick curl into accessing local files

Patch adapted from debian

ok robert@@
@
text
@a0 86
$OpenBSD$

CVE-2009-0037:  Rogue servers could trick curl into accessing local files

--- lib/url.c.orig	Fri Jan 16 02:10:24 2009
+++ lib/url.c	Fri Jun  5 11:23:49 2009
@@@@ -683,6 +683,13 @@@@ CURLcode Curl_init_userdefined(struct UserDefined *set
   set->new_file_perms = 0644;    /* Default permissions */
   set->new_directory_perms = 0755; /* Default permissions */
 
+  /* for the *protocols fields we don't use the CURLPROTO_ALL convenience
+     define since we internally only use the lower 16 bits for the passed
+     in bitmask to not conflict with the private bits */
+  set->allowed_protocols = PROT_EXTMASK;
+  set->redir_protocols =
+    PROT_EXTMASK & ~(CURLPROTO_FILE|CURLPROTO_SCP); /* not FILE or SCP */
+
   /* This is our preferred CA cert bundle/path since install time */
 #if defined(CURL_CA_BUNDLE)
   res = setstropt(&set->str[STRING_SSL_CAFILE], (char *) CURL_CA_BUNDLE);
@@@@ -1224,6 +1231,13 @@@@ CURLcode Curl_setopt(struct SessionHandle *data, CURLo
     result = setstropt(&data->set.str[STRING_COOKIEJAR],
                        va_arg(param, char *));
 
+    /* for the *protocols fields we don't use the CURLPROTO_ALL convenience
+       define since we internally only use the lower 16 bits for the passed
+       in bitmask to not conflict with the private bits */
+    data->set.allowed_protocols = PROT_EXTMASK;
+    data->set.redir_protocols =
+      PROT_EXTMASK & ~(CURLPROTO_FILE|CURLPROTO_SCP); /* not FILE or SCP */
+
     /*
      * Activate the cookie parser. This may or may not already
      * have been made.
@@@@ -2173,6 +2187,22 @@@@ CURLcode Curl_setopt(struct SessionHandle *data, CURLo
     data->set.scope = (unsigned int) va_arg(param, long);
     break;
 
+  case CURLOPT_PROTOCOLS:
+    /* set the bitmask for the protocols that are allowed to be used for the
+       transfer, which thus helps the app which takes URLs from users or other
+       external inputs and want to restrict what protocol(s) to deal
+       with. Defaults to CURLPROTO_ALL. */
+    data->set.allowed_protocols = va_arg(param, long) & PROT_EXTMASK;
+    break;
+
+  case CURLOPT_REDIR_PROTOCOLS:
+    /* set the bitmask for the protocols that libcurl is allowed to follow to,
+       as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs
+       to be set in both bitmasks to be allowed to get redirected to. Defaults
+       to all protocols except FILE and SCP. */
+    data->set.redir_protocols = va_arg(param, long) & PROT_EXTMASK;
+    break;
+
   default:
     /* unknown tag and its companion, just ignore: */
     result = CURLE_FAILED_INIT; /* correct this */
@@@@ -2460,7 +2490,6 @@@@ static void signalPipeClose(struct curl_llist *pipelin
   }
 }
 
-
 /*
  * Given one filled in connection struct (named needle), this function should
  * detect if there already is one that has all the significant details
@@@@ -3326,7 +3355,19 @@@@ static CURLcode setup_connection_internals(struct Sess
 
   for (pp = protocols; (p = *pp) != NULL; pp++)
     if(Curl_raw_equal(p->scheme, conn->protostr)) {
-      /* Protocol found in table. Perform setup complement if some. */
+      /* Protocol found in table. Check if allowed */
+      if(!(data->set.allowed_protocols & p->protocol))
+        /* nope, get out */
+        break;
+
+      /* it is allowed for "normal" request, now do an extra check if this is
+         the result of a redirect */
+      if(data->state.this_is_a_follow &&
+         !(data->set.redir_protocols & p->protocol))
+        /* nope, get out */
+        break;
+
+      /* Perform setup complement if some. */
       conn->handler = p;
 
       if(p->setup_connection) {
@

