head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.2
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.14
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.10
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.12
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.1.0.22
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.20
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.18
	OPENBSD_5_0:1.1.1.1.0.16
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.12
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.10
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.8
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	OPENBSD_4_3_BASE:1.1.1.1
	sthen_20080208:1.1.1.1
	sthen:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2016.12.23.13.44.31;	author rzalamena;	state Exp;
branches;
next	1.2;
commitid	zMjp3D5KOeqwsQNR;

1.2
date	2013.06.07.20.06.03;	author dcoppa;	state Exp;
branches;
next	1.1;

1.1
date	2008.02.08.19.30.52;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.02.08.19.30.52;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Improved the igmpproxy code to be able to run on multiple rdomains, here
is a list of changes:
- Ignore interfaces that are not listed in the configuration file: fixes
  an abort when trying to configure interface located in a different
  rdomain and doesn't look to the address of interfaces outside the
  configuration (otherwise it would pick the wrong interface in some cases).
- Improve the routing code: use a rb-tree to store groups avoiding group
  duplications and having to fix hand-rolled list implementations.
- Fixed some warnings and improved debug messages.

As discussed with ajacoutot@@,
ok reyk@@
@
text
@$OpenBSD: patch-config_c,v 1.2 2013/06/07 20:06:03 dcoppa Exp $
--- config.c.orig	Thu Dec 15 19:50:23 2016
+++ config.c	Mon Dec 19 21:02:00 2016
@@@@ -177,7 +177,7 @@@@
     }
 
     // Loop through all VIFs...
-    for ( Ix = 0; Dp = getIfByIx( Ix ); Ix++ ) {
+    for ( Ix = 0; (Dp = getIfByIx( Ix )); Ix++ ) {
         if ( Dp->InAdr.s_addr && ! (Dp->Flags & IFF_LOOPBACK) ) {
 
             // Now try to find a matching config...
@@@@ -241,11 +241,10 @@@@
     tmpPtr->allowednets = NULL;
 
     // Make a copy of the token to store the IF name
-    tmpPtr->name = (char *)malloc( sizeof(char) * strlen(token) );
+    tmpPtr->name = strdup(token);
     if(tmpPtr->name == NULL) {
         log(LOG_ERR, 0, "Out of memory.");
     }
-    strcpy(tmpPtr->name, token);
 
     // Set the altnet pointer to the allowednets pointer.
     anetPtr = &tmpPtr->allowednets;
@@@@ -255,8 +254,6 @@@@
     while(token != NULL) {
         if(strcmp("altnet", token)==0) {
             // Altnet...
-            struct in_addr  networkAddr;
-
             token = nextConfigToken();
             IF_DEBUG log(LOG_DEBUG, 0, "Config: IF: Got altnet token %s.",token);
 
@@@@ -328,29 +325,18 @@@@
 */
 struct SubnetList *parseSubnetAddress(char *addrstr) {
     struct SubnetList *tmpSubnet;
-    char        *tmpStr;
     uint32      addr = 0x00000000;
     uint32      mask = 0xFFFFFFFF;
+    int		bitcnt;
 
-    // First get the network part of the address...
-    tmpStr = strtok(addrstr, "/");
-    addr = inet_addr(tmpStr);
-
-    tmpStr = strtok(NULL, "/");
-    if(tmpStr != NULL) {
-        int bitcnt = atoi(tmpStr);
-        if(bitcnt <= 0 || bitcnt > 32) {
-            log(LOG_WARNING, 0, "The bits part of the address is invalid : %d.",tmpStr);
-            return NULL;
-        }
-
-        mask <<= (32 - bitcnt);
-    }
-
-    if(addr == -1 || addr == 0) {
-        log(LOG_WARNING, 0, "Unable to parse address token '%s'.", addrstr);
+    bitcnt = inet_net_pton(AF_INET, addrstr, &addr, sizeof(addr));
+    if(bitcnt<0) {
+        log(LOG_WARNING, 0, "Unable to parse address token '%s'.",addrstr);
         return NULL;
-    }
+    } else if(bitcnt>0)
+	mask <<= (32 - bitcnt);
+    else
+	mask = 0;
 
     tmpSubnet = (struct SubnetList*) malloc(sizeof(struct SubnetList));
     tmpSubnet->subnet_addr = addr;
@@@@ -363,3 +349,20 @@@@
     return tmpSubnet;
 }
 
+struct vifconfig *
+config_getinterface(const char *ifname)
+{
+	struct vifconfig *vc;
+
+	if (vifconf == NULL)
+		return (NULL);
+
+	for (vc = vifconf; vc; vc = vc->next) {
+		if (strcmp(vc->name, ifname))
+			continue;
+
+		return (vc);
+	}
+
+	return (NULL);
+}
@


1.2
log
@Fix an off-by-one bug in config.c

From Joseph Walsh <joseph_walsh AT genua DOT de>, thanks!

OK sthen@@
@
text
@d1 13
a13 4
$OpenBSD: patch-config_c,v 1.1.1.1 2008/02/08 19:30:52 sthen Exp $
--- config.c.orig	Tue May 24 17:49:29 2005
+++ config.c	Fri Jun  7 16:08:11 2013
@@@@ -241,11 +241,10 @@@@ struct vifconfig *parsePhyintToken() {
d26 10
a35 1
@@@@ -328,29 +327,18 @@@@ struct vifconfig *parsePhyintToken() {
d73 21
@


1.1
log
@Initial revision
@
text
@d1 17
a17 4
$OpenBSD$
--- config.c.orig	Tue May 24 16:49:29 2005
+++ config.c	Fri Jan 25 14:05:44 2008
@@@@ -328,29 +328,18 @@@@ struct vifconfig *parsePhyintToken() {
@


1.1.1.1
log
@igmpproxy is a simple multicast routing daemon which uses IGMP
forwarding to dynamically route multicast traffic.  Routing is done
by defining an "upstream" interface on which the daemon acts as a
normal Multicast client, and one or more "downstream" interfaces
that serves clients on the destination networks. This is useful in
situations where other dynamic multicast routers cannot be used.

from markus with small adjustments.
ok markus
@
text
@@
