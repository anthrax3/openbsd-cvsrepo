head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.40
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.38
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.36
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.32
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.34
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.30
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.28
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.26
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.24
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.22
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.20
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.18
	OPENBSD_5_0:1.1.1.1.0.16
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.12
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.10
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.8
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	OPENBSD_4_3_BASE:1.1.1.1
	sthen_20080208:1.1.1.1
	sthen:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2008.02.08.19.30.52;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.02.08.19.30.52;	author sthen;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$
--- igmp.c.orig	Tue May 24 17:49:16 2005
+++ igmp.c	Mon Aug 13 15:16:51 2007
@@@@ -41,8 +41,6 @@@@
 uint32     allhosts_group;          /* All hosts addr in net order */
 uint32     allrouters_group;          /* All hosts addr in net order */
               
-extern int MRouterFD;
-
 /*
  * Open and initialize the igmp socket, and fill in the non-changing
  * IP header fields in the output packet buffer.
@@@@ -128,6 +126,7 @@@@ void acceptIgmp(int recvlen) {
         }
         else {
             struct IfDesc *checkVIF;
+	    int downIf = -1;
             
             // Check if the source address matches a valid address on upstream vif.
             checkVIF = getIfByIx( upStreamVif );
@@@@ -141,15 +140,30 @@@@ void acceptIgmp(int recvlen) {
                 return;
             }
             else if(!isAdressValidForIf(checkVIF, src)) {
-                log(LOG_WARNING, 0, "The source address %s for group %s, is not in any valid net for upstream VIF.",
-                    inetFmt(src, s1), inetFmt(dst, s2));
-                return;
+		unsigned Ix;
+		struct IfDesc *Dp;
+
+		for ( Ix = 0; (Dp = getIfByIx( Ix )); Ix++ ) {
+		    if ((Dp->state == IF_STATE_DOWNSTREAM) &&isAdressValidForIf(Dp, src)) {
+			downIf = Ix;
+			break;
+		    }
+		}
+		
+		if (downIf == -1) {
+                   log(LOG_WARNING, 0, "The source address %s for group %s, is not in any valid net for upstream VIF.",
+                       inetFmt(src, s1), inetFmt(dst, s2));
+                   return;
+		} else {
+		    log(LOG_NOTICE, 0, "The source address %s for group %s, is valid DOWNSTREAM VIF #%d.",
+			inetFmt(src, s1), inetFmt(dst, s2), downIf);
+		}
             }
             
             // Activate the route.
-            IF_DEBUG log(LOG_DEBUG, 0, "Route activate request from %s to %s",
-                         inetFmt(src,s1), inetFmt(dst,s2));
-            activateRoute(dst, src);
+            IF_DEBUG log(LOG_DEBUG, 0, "Route activate request from %s to %s, downIf %d",
+                         inetFmt(src,s1), inetFmt(dst,s2), downIf);
+            activateRoute(dst, src, downIf);
             
 
         }
@@@@ -176,9 +190,9 @@@@ void acceptIgmp(int recvlen) {
         return;
     }
 
-    log(LOG_NOTICE, 0, "RECV %s from %-15s to %s",
+    log(LOG_NOTICE, 0, "RECV %s from %-15s to %s (ip_hl %d, data %d)",
         igmpPacketKind(igmp->igmp_type, igmp->igmp_code),
-        inetFmt(src, s1), inetFmt(dst, s2) );
+        inetFmt(src, s1), inetFmt(dst, s2), iphdrlen, ipdatalen);
 
     switch (igmp->igmp_type) {
     case IGMP_V1_MEMBERSHIP_REPORT:
@@@@ -190,12 +204,9 @@@@ void acceptIgmp(int recvlen) {
         acceptLeaveMessage(src, group);
         return;
     
-        /*
     case IGMP_MEMBERSHIP_QUERY:
         //accept_membership_query(src, dst, group, igmp->igmp_code);
         return;
-
-    */
 
     default:
         log(LOG_INFO, 0,
@


1.1.1.1
log
@igmpproxy is a simple multicast routing daemon which uses IGMP
forwarding to dynamically route multicast traffic.  Routing is done
by defining an "upstream" interface on which the daemon acts as a
normal Multicast client, and one or more "downstream" interfaces
that serves clients on the destination networks. This is useful in
situations where other dynamic multicast routers cannot be used.

from markus with small adjustments.
ok markus
@
text
@@
