head	1.1;
access;
symbols
	OPENBSD_5_9:1.1.0.8
	OPENBSD_5_6:1.1.0.6
	OPENBSD_5_5:1.1.0.4
	OPENBSD_5_4:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2014.10.30.07.37.30;	author brad;	state dead;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1
	1.1.8.1;
next	;
commitid	m6VWQUdGf2sBMx2J;

1.1.2.1
date	2014.10.30.07.37.30;	author brad;	state Exp;
branches;
next	;
commitid	m6VWQUdGf2sBMx2J;

1.1.4.1
date	2014.10.30.07.39.10;	author brad;	state Exp;
branches;
next	;
commitid	WQNd7LozvjAC4lPY;

1.1.6.1
date	2014.10.30.07.40.49;	author brad;	state Exp;
branches;
next	;
commitid	zm0kqMBvEx3BHQZ2;

1.1.8.1
date	2016.07.05.07.16.52;	author jasper;	state Exp;
branches;
next	;
commitid	ATFCg0d2YCHGzcS2;


desc
@@


1.1
log
@file patch-libpurple_protocols_mxit_markup_c was initially added on branch OPENBSD_5_4.
@
text
@@


1.1.8.1
log
@Security fixes for: CVE-2016-2376 - CVE 2016-2380, CVE-2016-4323,
CVE-2016-2365 - CVE-2016-2375 (only affecting the mxit protocol)

originally pointed out by Jeremy Thorn
@
text
@a0 42
$OpenBSD$

Security fixes for:
CVE-2016-2376 - CVE 2016-2380,
CVE 2016-4323,
CVE-2016-2365 - CVE-2016-2375

--- libpurple/protocols/mxit/markup.c.orig	Mon Jul  4 13:22:37 2016
+++ libpurple/protocols/mxit/markup.c	Mon Jul  4 13:22:58 2016
@@@@ -1083,7 +1083,6 @@@@ char* mxit_convert_markup_tx( const char* message, int
 	GList*				entry;
 	GList*				tagstack	= NULL;
 	char*				reply;
-	char				color[8];
 	int					len			= strlen ( message );
 	int					i;
 
@@@@ -1145,12 +1144,18 @@@@ char* mxit_convert_markup_tx( const char* message, int
 				}
 				else if ( purple_str_has_prefix( &message[i], "<font color=" ) ) {
 					/* font colour */
-					tag = g_new0( struct tag, 1 );
-					tag->type = MXIT_TAG_COLOR;
-					tagstack = g_list_append( tagstack, tag );
-					memset( color, 0x00, sizeof( color ) );
-					memcpy( color, &message[i + 13], 7 );
-					g_string_append( mx, color );
+					char color[8];
+
+					/* ensure we have the complete tag: <font color="#123456"> */
+					if ( i + 20 < len ) {
+						tag = g_new0( struct tag, 1 );
+						tag->type = MXIT_TAG_COLOR;
+						tagstack = g_list_append( tagstack, tag );
+
+						memset( color, 0x00, sizeof( color ) );
+						memcpy( color, &message[i + 13], 7 );
+						g_string_append( mx, color );
+					}
 				}
 				else if ( purple_str_has_prefix( &message[i], "</font>" ) ) {
 					/* end of font tag */
@


1.1.6.1
log
@Security fixes from 2.10.10... CVE-2014-3695, CVE-2014-3696, CVE-2014-3698.

The commit for 2.10.10 mentioned CVE-2014-3697 but after looking at it
again I noticed it is a Windows specific issue.
@
text
@a0 145
$OpenBSD$

Remote crash parsing malformed MXit emoticon. CVE-2014-3695

--- libpurple/protocols/mxit/markup.c.orig	Sun Feb  2 16:29:18 2014
+++ libpurple/protocols/mxit/markup.c	Thu Oct 30 02:46:41 2014
@@@@ -163,16 +163,22 @@@@ void mxit_add_html_link( struct RXMsgData* mx, const c
  * Extract an ASN.1 formatted length field from the data.
  *
  *  @@param data				The source data
+ *  @@param data_len			Length of data
  *  @@param size				The extracted length
  *  @@return					The number of bytes extracted
  */
-static unsigned int asn_getlength( const gchar* data, int* size )
+static unsigned int asn_getlength( const gchar* data, gsize data_len, int* size )
 {
 	unsigned int	len		= 0;
 	unsigned char	bytes;
 	unsigned char	byte;
 	int				i;
 
+	if ( data_len < 1 ) {
+		/* missing first byte! */
+		return -1;
+	}
+
 	/* first byte specifies the number of bytes in the length */
 	bytes = ( data[0] & ~0x80 );
 	if ( bytes > sizeof( unsigned int ) ) {
@@@@ -181,6 +187,11 @@@@ static unsigned int asn_getlength( const gchar* data, 
 	}
 	data++;
 
+	if ( data_len - 1 < bytes ) {
+		/* missing length! */
+		return -1;
+	}
+
 	/* parse out the actual length */
 	for ( i = 0; i < bytes; i++ ) {
 		byte = data[i];
@@@@ -197,15 +208,21 @@@@ static unsigned int asn_getlength( const gchar* data, 
  * Extract an ASN.1 formatted UTF-8 string field from the data.
  *
  *  @@param data				The source data
+ *  @@param data_len			Length of data
  *  @@param type				Expected type of string
  *  @@param utf8				The extracted string.  Must be deallocated by caller.
  *  @@return					The number of bytes extracted
  */
-static int asn_getUtf8( const gchar* data, gchar type, char** utf8 )
+static int asn_getUtf8( const gchar* data, gsize data_len, gchar type, char** utf8 )
 {
 	unsigned int len;
 	gchar *out_str;
 
+	if ( data_len < 2 ) {
+		/* missing type or length! */
+		return -1;
+	}
+
 	/* validate the field type [1 byte] */
 	if ( data[0] != type ) {
 		/* this is not a utf-8 string! */
@@@@ -214,6 +231,11 @@@@ static int asn_getUtf8( const gchar* data, gchar type,
 	}
 
 	len = (uint8_t)data[1]; /* length field [1 byte] */
+	if ( data_len - 2 < len ) {
+		/* not enough bytes left in data! */
+		return -1;
+	}
+
 	out_str = g_malloc(len + 1);
 	memcpy(out_str, &data[2], len); /* data field */
 	out_str[len] = '\0';
@@@@ -500,7 +522,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #endif
 
 	/* validate that the returned data starts with the magic constant that indicates it is a custom emoticon */
-	if ( memcmp( MXIT_FRAME_MAGIC, &data[pos], strlen( MXIT_FRAME_MAGIC ) ) != 0 ) {
+	if ( len - pos < strlen( MXIT_FRAME_MAGIC ) || memcmp( MXIT_FRAME_MAGIC, &data[pos], strlen( MXIT_FRAME_MAGIC ) ) != 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad magic)\n" );
 		goto done;
 	}
@@@@ -514,7 +536,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	pos++;
 
 	/* get the frame image data length */
-	res = asn_getlength( &data[pos], &em_size );
+	res = asn_getlength( &data[pos], len - pos, &em_size );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad frame length)\n" );
 		goto done;
@@@@ -525,7 +547,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #endif
 
 	/* utf-8 (emoticon name) */
-	res = asn_getUtf8( &data[pos], 0x0C, &str );
+	res = asn_getUtf8( &data[pos], len - pos, 0x0C, &str );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad name string)\n" );
 		goto done;
@@@@ -538,7 +560,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	str = NULL;
 
 	/* utf-8 (emoticon shortcut) */
-	res = asn_getUtf8( &data[pos], 0x81, &str );
+	res = asn_getUtf8( &data[pos], len - pos, 0x81, &str );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad shortcut string)\n" );
 		goto done;
@@@@ -550,7 +572,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	em_id = str;
 
 	/* validate the image data type */
-	if ( data[pos] != '\x82' ) {
+	if ( len - pos < 1 || data[pos] != '\x82' ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad data type)\n" );
 		g_free( em_id );
 		goto done;
@@@@ -558,7 +580,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	pos++;
 
 	/* get the data length */
-	res = asn_getlength( &data[pos], &em_size );
+	res = asn_getlength( &data[pos], len - pos, &em_size );
 	if ( res <= 0 ) {
 		/* bad frame length */
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad data length)\n" );
@@@@ -569,6 +591,13 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #ifdef	MXIT_DEBUG_EMO
 	purple_debug_info( MXIT_PLUGIN_ID, "read the length '%i'\n", em_size );
 #endif
+
+	if ( len - pos < em_size ) {
+		/* not enough bytes left in data! */
+		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (data length too long)\n");
+		g_free( em_id );
+		goto done;
+	}
 
 	/* strip the mxit markup tags from the emoticon id (eg, .{XY} -> XY) */
 	if ( ( em_id[0] == '.' ) && ( em_id[1] == '{' ) ) {
@


1.1.4.1
log
@Security fixes from 2.10.10... CVE-2014-3695, CVE-2014-3696, CVE-2014-3698.

The commit for 2.10.10 mentioned CVE-2014-3697 but after looking at it
again I noticed it is a Windows specific isue.
@
text
@a0 145
$OpenBSD$

Remote crash parsing malformed MXit emoticon. CVE-2014-3695

--- libpurple/protocols/mxit/markup.c.orig	Sun Feb  2 16:29:18 2014
+++ libpurple/protocols/mxit/markup.c	Thu Oct 30 02:46:41 2014
@@@@ -163,16 +163,22 @@@@ void mxit_add_html_link( struct RXMsgData* mx, const c
  * Extract an ASN.1 formatted length field from the data.
  *
  *  @@param data				The source data
+ *  @@param data_len			Length of data
  *  @@param size				The extracted length
  *  @@return					The number of bytes extracted
  */
-static unsigned int asn_getlength( const gchar* data, int* size )
+static unsigned int asn_getlength( const gchar* data, gsize data_len, int* size )
 {
 	unsigned int	len		= 0;
 	unsigned char	bytes;
 	unsigned char	byte;
 	int				i;
 
+	if ( data_len < 1 ) {
+		/* missing first byte! */
+		return -1;
+	}
+
 	/* first byte specifies the number of bytes in the length */
 	bytes = ( data[0] & ~0x80 );
 	if ( bytes > sizeof( unsigned int ) ) {
@@@@ -181,6 +187,11 @@@@ static unsigned int asn_getlength( const gchar* data, 
 	}
 	data++;
 
+	if ( data_len - 1 < bytes ) {
+		/* missing length! */
+		return -1;
+	}
+
 	/* parse out the actual length */
 	for ( i = 0; i < bytes; i++ ) {
 		byte = data[i];
@@@@ -197,15 +208,21 @@@@ static unsigned int asn_getlength( const gchar* data, 
  * Extract an ASN.1 formatted UTF-8 string field from the data.
  *
  *  @@param data				The source data
+ *  @@param data_len			Length of data
  *  @@param type				Expected type of string
  *  @@param utf8				The extracted string.  Must be deallocated by caller.
  *  @@return					The number of bytes extracted
  */
-static int asn_getUtf8( const gchar* data, gchar type, char** utf8 )
+static int asn_getUtf8( const gchar* data, gsize data_len, gchar type, char** utf8 )
 {
 	unsigned int len;
 	gchar *out_str;
 
+	if ( data_len < 2 ) {
+		/* missing type or length! */
+		return -1;
+	}
+
 	/* validate the field type [1 byte] */
 	if ( data[0] != type ) {
 		/* this is not a utf-8 string! */
@@@@ -214,6 +231,11 @@@@ static int asn_getUtf8( const gchar* data, gchar type,
 	}
 
 	len = (uint8_t)data[1]; /* length field [1 byte] */
+	if ( data_len - 2 < len ) {
+		/* not enough bytes left in data! */
+		return -1;
+	}
+
 	out_str = g_malloc(len + 1);
 	memcpy(out_str, &data[2], len); /* data field */
 	out_str[len] = '\0';
@@@@ -500,7 +522,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #endif
 
 	/* validate that the returned data starts with the magic constant that indicates it is a custom emoticon */
-	if ( memcmp( MXIT_FRAME_MAGIC, &data[pos], strlen( MXIT_FRAME_MAGIC ) ) != 0 ) {
+	if ( len - pos < strlen( MXIT_FRAME_MAGIC ) || memcmp( MXIT_FRAME_MAGIC, &data[pos], strlen( MXIT_FRAME_MAGIC ) ) != 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad magic)\n" );
 		goto done;
 	}
@@@@ -514,7 +536,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	pos++;
 
 	/* get the frame image data length */
-	res = asn_getlength( &data[pos], &em_size );
+	res = asn_getlength( &data[pos], len - pos, &em_size );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad frame length)\n" );
 		goto done;
@@@@ -525,7 +547,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #endif
 
 	/* utf-8 (emoticon name) */
-	res = asn_getUtf8( &data[pos], 0x0C, &str );
+	res = asn_getUtf8( &data[pos], len - pos, 0x0C, &str );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad name string)\n" );
 		goto done;
@@@@ -538,7 +560,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	str = NULL;
 
 	/* utf-8 (emoticon shortcut) */
-	res = asn_getUtf8( &data[pos], 0x81, &str );
+	res = asn_getUtf8( &data[pos], len - pos, 0x81, &str );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad shortcut string)\n" );
 		goto done;
@@@@ -550,7 +572,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	em_id = str;
 
 	/* validate the image data type */
-	if ( data[pos] != '\x82' ) {
+	if ( len - pos < 1 || data[pos] != '\x82' ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad data type)\n" );
 		g_free( em_id );
 		goto done;
@@@@ -558,7 +580,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	pos++;
 
 	/* get the data length */
-	res = asn_getlength( &data[pos], &em_size );
+	res = asn_getlength( &data[pos], len - pos, &em_size );
 	if ( res <= 0 ) {
 		/* bad frame length */
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad data length)\n" );
@@@@ -569,6 +591,13 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #ifdef	MXIT_DEBUG_EMO
 	purple_debug_info( MXIT_PLUGIN_ID, "read the length '%i'\n", em_size );
 #endif
+
+	if ( len - pos < em_size ) {
+		/* not enough bytes left in data! */
+		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (data length too long)\n");
+		g_free( em_id );
+		goto done;
+	}
 
 	/* strip the mxit markup tags from the emoticon id (eg, .{XY} -> XY) */
 	if ( ( em_id[0] == '.' ) && ( em_id[1] == '{' ) ) {
@


1.1.2.1
log
@Security fixes from 2.10.10... CVE-2014-3695, CVE-2014-3696, CVE-2014-3698.

The commit for 2.10.10 mentioned CVE-2014-3697 but after looking at it
again I noticed it is a Windows specific isue.
@
text
@a0 145
$OpenBSD$

Remote crash parsing malformed MXit emoticon. CVE-2014-3695

--- libpurple/protocols/mxit/markup.c.orig	Sun Feb  2 16:29:18 2014
+++ libpurple/protocols/mxit/markup.c	Thu Oct 30 02:46:41 2014
@@@@ -163,16 +163,22 @@@@ void mxit_add_html_link( struct RXMsgData* mx, const c
  * Extract an ASN.1 formatted length field from the data.
  *
  *  @@param data				The source data
+ *  @@param data_len			Length of data
  *  @@param size				The extracted length
  *  @@return					The number of bytes extracted
  */
-static unsigned int asn_getlength( const gchar* data, int* size )
+static unsigned int asn_getlength( const gchar* data, gsize data_len, int* size )
 {
 	unsigned int	len		= 0;
 	unsigned char	bytes;
 	unsigned char	byte;
 	int				i;
 
+	if ( data_len < 1 ) {
+		/* missing first byte! */
+		return -1;
+	}
+
 	/* first byte specifies the number of bytes in the length */
 	bytes = ( data[0] & ~0x80 );
 	if ( bytes > sizeof( unsigned int ) ) {
@@@@ -181,6 +187,11 @@@@ static unsigned int asn_getlength( const gchar* data, 
 	}
 	data++;
 
+	if ( data_len - 1 < bytes ) {
+		/* missing length! */
+		return -1;
+	}
+
 	/* parse out the actual length */
 	for ( i = 0; i < bytes; i++ ) {
 		byte = data[i];
@@@@ -197,15 +208,21 @@@@ static unsigned int asn_getlength( const gchar* data, 
  * Extract an ASN.1 formatted UTF-8 string field from the data.
  *
  *  @@param data				The source data
+ *  @@param data_len			Length of data
  *  @@param type				Expected type of string
  *  @@param utf8				The extracted string.  Must be deallocated by caller.
  *  @@return					The number of bytes extracted
  */
-static int asn_getUtf8( const gchar* data, gchar type, char** utf8 )
+static int asn_getUtf8( const gchar* data, gsize data_len, gchar type, char** utf8 )
 {
 	unsigned int len;
 	gchar *out_str;
 
+	if ( data_len < 2 ) {
+		/* missing type or length! */
+		return -1;
+	}
+
 	/* validate the field type [1 byte] */
 	if ( data[0] != type ) {
 		/* this is not a utf-8 string! */
@@@@ -214,6 +231,11 @@@@ static int asn_getUtf8( const gchar* data, gchar type,
 	}
 
 	len = (uint8_t)data[1]; /* length field [1 byte] */
+	if ( data_len - 2 < len ) {
+		/* not enough bytes left in data! */
+		return -1;
+	}
+
 	out_str = g_malloc(len + 1);
 	memcpy(out_str, &data[2], len); /* data field */
 	out_str[len] = '\0';
@@@@ -500,7 +522,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #endif
 
 	/* validate that the returned data starts with the magic constant that indicates it is a custom emoticon */
-	if ( memcmp( MXIT_FRAME_MAGIC, &data[pos], strlen( MXIT_FRAME_MAGIC ) ) != 0 ) {
+	if ( len - pos < strlen( MXIT_FRAME_MAGIC ) || memcmp( MXIT_FRAME_MAGIC, &data[pos], strlen( MXIT_FRAME_MAGIC ) ) != 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad magic)\n" );
 		goto done;
 	}
@@@@ -514,7 +536,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	pos++;
 
 	/* get the frame image data length */
-	res = asn_getlength( &data[pos], &em_size );
+	res = asn_getlength( &data[pos], len - pos, &em_size );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad frame length)\n" );
 		goto done;
@@@@ -525,7 +547,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #endif
 
 	/* utf-8 (emoticon name) */
-	res = asn_getUtf8( &data[pos], 0x0C, &str );
+	res = asn_getUtf8( &data[pos], len - pos, 0x0C, &str );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad name string)\n" );
 		goto done;
@@@@ -538,7 +560,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	str = NULL;
 
 	/* utf-8 (emoticon shortcut) */
-	res = asn_getUtf8( &data[pos], 0x81, &str );
+	res = asn_getUtf8( &data[pos], len - pos, 0x81, &str );
 	if ( res <= 0 ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad shortcut string)\n" );
 		goto done;
@@@@ -550,7 +572,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	em_id = str;
 
 	/* validate the image data type */
-	if ( data[pos] != '\x82' ) {
+	if ( len - pos < 1 || data[pos] != '\x82' ) {
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad data type)\n" );
 		g_free( em_id );
 		goto done;
@@@@ -558,7 +580,7 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 	pos++;
 
 	/* get the data length */
-	res = asn_getlength( &data[pos], &em_size );
+	res = asn_getlength( &data[pos], len - pos, &em_size );
 	if ( res <= 0 ) {
 		/* bad frame length */
 		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (bad data length)\n" );
@@@@ -569,6 +591,13 @@@@ static void emoticon_returned( PurpleUtilFetchUrlData*
 #ifdef	MXIT_DEBUG_EMO
 	purple_debug_info( MXIT_PLUGIN_ID, "read the length '%i'\n", em_size );
 #endif
+
+	if ( len - pos < em_size ) {
+		/* not enough bytes left in data! */
+		purple_debug_error( MXIT_PLUGIN_ID, "Invalid emoticon received from wapsite (data length too long)\n");
+		g_free( em_id );
+		goto done;
+	}
 
 	/* strip the mxit markup tags from the emoticon id (eg, .{XY} -> XY) */
 	if ( ( em_id[0] == '.' ) && ( em_id[1] == '{' ) ) {
@

