head	1.38;
access;
symbols
	OPENBSD_5_9:1.37.0.12
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.37.0.14
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.10
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.37.0.8
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.37.0.6
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.37.0.4
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.34.0.4
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.22.0.2
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2;
locks; strict;
comment	@# @;


1.38
date	2016.06.06.13.27.02;	author dcoppa;	state dead;
branches;
next	1.37;
commitid	Khu9QqwaOzfJ2q4u;

1.37
date	2012.12.13.02.48.15;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2012.09.30.02.45.04;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2012.08.06.09.47.20;	author sthen;	state Exp;
branches;
next	1.34;

1.34
date	2011.08.18.08.27.33;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.26.12.53.26;	author jsg;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2011.07.19.16.29.46;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2011.05.30.20.28.54;	author martynas;	state Exp;
branches;
next	1.30;

1.30
date	2011.03.08.20.11.43;	author martynas;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.28.22.52.28;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.07.22.43.26;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2010.04.05.15.13.27;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.18.21.10.03;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.13.18.23.11;	author martynas;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.24.19.31.27;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.16.19.37.59;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.13.02.01.19;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.13.01.51.08;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.06.11.58.22;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.07.00.14.52;	author martynas;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.06.18.48.17;	author martynas;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.06.12.35.27;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.05.18.44.37;	author martynas;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.04.04.14.50;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.14.12.28.11;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.11.11.58.09;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.02.17.43.10;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.02.17.29.56;	author martynas;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.06.20.49.51;	author martynas;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.01.19.14.59;	author martynas;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.28.21.48.45;	author jolan;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.09.00.26.29;	author jolan;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.29.22.50.31;	author jolan;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.26.21.47.46;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.23.05.16.22;	author sturm;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.19.17.32.52;	author pedro;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.24.09.52.01;	author sturm;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.21.13.50.18;	author pedro;	state Exp;
branches;
next	;

1.33.2.1
date	2011.08.24.07.53.31;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.38
log
@
Remove net/yt

It's obsolete, broken (it dates back to a time before YouTube did
HTML5 video) and it gets in the way of a luastdlib update

OK sthen@@, jsg@@
@
text
@#!${MODLUA_BIN}
-- $OpenBSD: yt.lua,v 1.37 2012/12/13 02:48:15 jsg Exp $
-- Fetch videos from YouTube.com/Videos.Google.com, and convert to MPEG.
-- Written by Pedro Martelletto and Martynas Venckus.  Public domain.
-- Example: lua yt.lua http://www.youtube.com/watch?v=c5uoo1Kl_uA

getopt = require("getopt")
http = require("socket.http")
ltn12 = require("ltn12")

-- Set this to a command capable of talking HTTP and following 3XX requests.
fetch = "ftp <arguments> -o <file> <url>"

-- Default arguments for the fetch command.
arguments = ""

-- Set this to a command capable of converting from FLV to MPEG.
convert = "ffmpeg -y -i <flv> -b 1000k -f mp4 -vcodec mpeg4 -acodec aac -ab 128k -strict experimental <mp4> 1>/dev/null 2>&1"

-- Set this to the base location where to fetch YouTube videos from.
base_url = "http://www.youtube.com/get_video_info"

-- Usage and supported options.
prog = {
   name = arg[0],
   usage = "[-cC] [-o=output] url ...",
}
options = Options {
   Option {{"C"}, "continue previous transfer"},
   Option {{"c"}, "convert video"},
   Option {{"o"}, "change output filename", "Req", "filename"},
}

-- from lua-users.org StringRecipes
function url_decode(str)
   while (string.find(str, "%%%x%x")) do
      str = string.gsub (str, "+", " ")
      str = string.gsub (str, "%%(%x%x)",
          function(h) return string.char(tonumber(h,16)) end)
      str = string.gsub (str, "\r\n", "\n")
   end
   return str
end

-- Process arguments.  Show usage.
urls, opts, errors = getopt.getOpt(arg, options)
if #errors > 0 or urls.n < 1 then
   getopt.dieWithUsage()
end

-- Build arguments for the fetch command.
if opts.C then
   arguments = arguments .. "-C"
end

-- Fetch one or more URL.
for i = 1, table.getn(urls) do
   url = urls[i]

   -- Convert embedded links to the correct form.
   url = string.gsub(url, "/v/", "/watch?v=")

   -- Fetch the page holding the embedded video.
   io.stderr:write(string.format("Getting %s ...\n", url))
   t = {  }
   assert(http.request{
      url = url,
      sink = ltn12.sink.table(t),
      proxy = os.getenv("http_proxy")
   })
   body = table.concat(t)

   -- Look for the video title.
   pattern = "<title>%s*(.-)%s*</title>"
   title = assert(string.match(body, pattern))
   -- strip html elements
   title = string.gsub(title, "&[^ ]*;", "")
   title = string.gsub(title, "%s*- YouTube%s*", "")

   -- Build a name for the files the video will be stored in.
   if opts.o then
      file = opts.o
   else
      file = string.gsub(title, "[^%w-]+", "_")
      file = string.lower(file)
   end

   -- Look for the video ID.
   pattern = "VIDEO_ID':%s*['\"]([^'\"]*)['\"]"
   video_id = string.match(body, pattern)

   -- Check for error such as "This video is not available in your country."
   error_pattern = "unavailable%-message\"%s* class=\"\">%s*(.-)\n*</div>"
   err = string.match(body, error_pattern)
   if err then
      io.stderr:write(err .. "\n")
      return
   end

   if video_id then
      url = string.format("%q", base_url .. "?video_id=" .. video_id
         .. "&eurl=&el=detailpage&ps=default&gl=US&hl=en")

      -- Look for the download URL
      url = string.match(url, "\"(.*)\"")
      io.stderr:write(string.format("Getting %s ...\n", url))
      t = {  }
      assert(http.request{
         url = url,
         sink = ltn12.sink.table(t),
         proxy = os.getenv("http_proxy")
      })
      body = table.concat(t)
      body = url_decode(body)
      encurl = string.match(body, "url=(http[^,=&]-videoplayback.-type.-)[&;]")
      -- signature
      sig = string.match(body, "sig=(.-)&")
      if sig then
         encurl = encurl .. "&signature=" .. sig
      end
      url = string.format("\"%s\"", encurl)
   else
      -- We assume it's Google Video URL.
      pattern = "/googleplayer.swf%?videoUrl(.-)thumbnailUrl"
      url = assert(string.match(body, pattern))
      url = string.gsub (url, "\\x", "%%")
      url = url_decode(url)
      url = string.gsub (url, "^=", "")
      url = string.format("%q", url)
   end

   -- Build flv and mp4 file names.
   mpeg4 = false

   if file == "-" then
      opts.n = 0
      o_file = file
   else
      if string.find(url, "video/mp4") then
         ext = "mp4"
         mpeg4 = true
      elseif string.find(url, "video/webm") then
         ext = "webm"
      else
         ext = "flv"
      end
      o_file = string.format("%s.%s", file, ext)
   end

   o_mp4 = file .. ".mp4"
   e_file = string.format("%q", o_file)
   e_mp4 = string.format("%q", o_mp4)

   cmd = string.gsub(fetch, "<(%w+)>", { arguments = arguments,
      url = url, file = e_file })
   assert(os.execute(cmd) == 0, "Failed")

   -- Convert it to MPEG.
   if opts.c and mpeg4 ~= true then
      cmd = string.gsub(convert, "<(%w+)>", { flv = e_file, mp4 = e_mp4 })
      io.stderr:write("Converting ...\n")
      assert(os.execute(cmd) == 0, "Failed")
      os.remove(o_file)
      io.stderr:write("Done. Video saved in " .. o_mp4 .. "\n")
   else
      io.stderr:write("Done. Video saved in " .. o_file .. ".\n")
   end
end
@


1.37
log
@unbreak after recent youtube changes, ok martynas@@
take maintainership as suggested by martynas (previous maintainer).
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.36 2012/09/30 02:45:04 jsg Exp $
@


1.36
log
@adapt to recent youtube changes
ok martynas@@ ajacoutot@@ dcoppa@@
tested by matthieu@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.35 2012/08/06 09:47:20 sthen Exp $
d115 1
a115 1
      encurl = string.match(body, "url=(http[^,=&]-cache.-type.-)[&;]")
@


1.35
log
@unbreak path to lua binary
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.34 2011/08/18 08:27:33 jsg Exp $
d116 5
@


1.34
log
@unbreak after recent youtube changes and don't covert downloaded
video by default
ok martynas@@
@
text
@d1 2
a2 2
#!${LOCALBASE}/bin/lua
-- $OpenBSD: yt.lua,v 1.33 2011/07/26 12:53:26 jsg Exp $
@


1.33
log
@strip some junk from the title we don't want in the filename
ok martynas@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.32 2011/07/19 16:29:46 jasper Exp $
d26 1
a26 1
   usage = "[-C] [-n] [-o=output] url ...",
d30 1
a30 1
   Option {{"n"}, "do not convert video"},
d36 6
a41 4
   str = string.gsub (str, "+", " ")
   str = string.gsub (str, "%%(%x%x)",
       function(h) return string.char(tonumber(h,16)) end)
   str = string.gsub (str, "\r\n", "\n")
a79 29
   -- Fetch high quality if available, just take the first format for now
   --  5  320x 240 H.263/MP3 mono FLV
   --  6  320x 240 H.263/MP3 mono FLV
   -- 13  176x 144 3GP/AMR mono 3GP 
   -- 17  176x 144 3GP/AAC mono 3GP
   -- 18  480x 360 480x270 H.264/AAC stereo MP4
   -- 22 1280x 720 H.264/AAC stereo MP4
   -- 34  320x 240 H.264/AAC stereo FLV
   -- 35  640x 480 640x360 H.264/AAC stereo FLV
   -- 37 1920x1024 H.264/AAC MP4 AVC
   mpeg4 = false
   pattern = "fmt_map=([%d]+)"
   if (string.match(body, pattern) ~= nil) then
      format = string.match(body, pattern)
      -- format 37 isn't in fmt_map so fake it
--[[
      if (string.match(body, "IS_HD_AVAILABLE':%s*true") ~= nil) then
         format = "37"
      end
]]--
      nf = tonumber(format)
      if nf == 18 or nf == 22 or nf == 37 then
         mpeg4 = true
      end
      fmt = "&fmt=" .. format
   else
      fmt = ""
   end

a87 13
   -- Build flv and mp4 file names.
   if file == "-" then
      opts.n = 0
      flv = file
   else
      flv = file .. ".flv"
   end
   mp4 = file .. ".mp4"

   -- Escape the file names.
   e_flv = string.format("%q", flv)
   e_mp4 = string.format("%q", mp4)

d93 1
a93 2
   error_pattern = "class=\"yt%-alert%-content\">%s+(.-)%s*\n*</div>"
--[[
a98 1
]]--
d102 1
a102 1
         .. "&eurl=&el=detailpage&ps=default&gl=US&hl=en" .. fmt)
d114 3
a116 2
      encurl = string.match(body, "7C(http.-id%%3D.-)%%")
      url = string.format("\"%s\"", url_decode(encurl))
d127 6
a132 4
   -- Fetch the video.
   if mpeg4 == true then
        e_file = e_mp4
        o_file = mp4
d134 9
a142 2
        e_file = e_flv
        o_file = flv
d144 5
a148 1
   
d154 2
a155 4
   if opts.n or mpeg4 == true then
      io.stderr:write("Done. Video saved in " .. o_file .. ".\n")
   else
      cmd = string.gsub(convert, "<(%w+)>", { flv = e_flv, mp4 = e_mp4 })
d158 4
a161 2
      os.remove(flv)
      io.stderr:write("Done. Video saved in " .. mp4 .. "\n")
a163 1

@


1.33.2.1
log
@Fix youtube functionality in OPENBSD_5_0, original commit by jsg@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.34 2011/08/18 08:27:33 jsg Exp $
d26 1
a26 1
   usage = "[-cC] [-o=output] url ...",
d30 1
a30 1
   Option {{"c"}, "convert video"},
d36 4
a39 6
   while (string.find(str, "%%%x%x")) do
      str = string.gsub (str, "+", " ")
      str = string.gsub (str, "%%(%x%x)",
          function(h) return string.char(tonumber(h,16)) end)
      str = string.gsub (str, "\r\n", "\n")
   end
d78 29
d115 13
d133 2
a134 1
   error_pattern = "unavailable%-message\"%s* class=\"\">%s*(.-)\n*</div>"
d140 1
d144 1
a144 1
         .. "&eurl=&el=detailpage&ps=default&gl=US&hl=en")
d156 2
a157 3
      body = url_decode(body)
      encurl = string.match(body, "url=(http[^,=&]-cache.-type.-)[&;]")
      url = string.format("\"%s\"", encurl)
d168 4
a171 6
   -- Build flv and mp4 file names.
   mpeg4 = false

   if file == "-" then
      opts.n = 0
      o_file = file
d173 2
a174 9
      if string.find(url, "video/mp4") then
         ext = "mp4"
         mpeg4 = true
      elseif string.find(url, "video/webm") then
         ext = "webm"
      else
         ext = "flv"
      end
      o_file = string.format("%s.%s", file, ext)
d176 1
a176 5

   o_mp4 = file .. ".mp4"
   e_file = string.format("%q", o_file)
   e_mp4 = string.format("%q", o_mp4)

d182 4
a185 2
   if opts.c and mpeg4 ~= true then
      cmd = string.gsub(convert, "<(%w+)>", { flv = e_file, mp4 = e_mp4 })
d188 2
a189 4
      os.remove(o_file)
      io.stderr:write("Done. Video saved in " .. o_mp4 .. "\n")
   else
      io.stderr:write("Done. Video saved in " .. o_file .. ".\n")
d192 1
@


1.32
log
@Strip the trailing full stop after printing the saved filename. Now
you can just double click on the filename in X and have it copied to the
clipboard, without the extra dot.

ok martynas@@ (MAINTAINER)
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.31 2011/05/30 20:28:54 martynas Exp $
d74 3
@


1.31
log
@Switch yt over to using FFmpeg's internal AAC encoder (the other
encoder will be going away).  From Brad.
OK sthen@@.
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.30 2011/03/08 20:11:43 martynas Exp $
d186 1
a186 1
      io.stderr:write("Done. Video saved in " .. mp4 .. ".\n")
@


1.30
log
@youtube changed things;  apparently it uses double-quotes for id.
recognize both ways (in case they change this again).
ok sthen@@, jsg@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.29 2010/07/28 22:52:28 jsg Exp $
d18 1
a18 1
convert = "ffmpeg -y -i <flv> -b 1000k -f mp4 -vcodec mpeg4 -acodec libfaac -ab 128k <mp4> 1>/dev/null 2>&1"
@


1.29
log
@update for recent youtube changes
ok martynas@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.28 2010/06/07 22:43:26 jsg Exp $
d126 1
a126 1
   pattern = "VIDEO_ID':%s*'([^\']*)'"
@


1.28
log
@the way errors were caught before now picks up non fatal things
like "Melde dich an Kommentar zu posten" so don't treat errors
as fatal any more.
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.27 2010/04/05 15:13:27 jsg Exp $
d21 1
a21 1
base_url = "http://www.youtube.com/get_video"
d34 9
a139 3
      --- Look for the additional video ID.
      pattern = "&t=([^\&='\"]*)"
      t = assert(string.match(body, pattern))
d141 14
a154 1
         .. "&t=" .. t .. "&eurl=&el=detailpage&ps=default&gl=US&hl=en" .. fmt)
d160 1
a160 2
      url = string.gsub (url, "%%(%x%x)", function(h)
         return string.char(tonumber(h,16)) end)
@


1.27
log
@adapt to youtube changes.
ok sthen@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.26 2009/09/18 21:10:03 martynas Exp $
d122 1
d128 1
@


1.26
log
@catch up pattern to the new google video format.  don't include
thumbnailUrl.  makes google videos fetch again - reported by jsg@@.
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.25 2009/09/13 18:23:11 martynas Exp $
d63 1
a63 1
   pattern = "<title>(.-)</title>"
d67 9
a75 8
   --  5  320x240 H.263/MP3 mono FLV
   --  6  320x240 H.263/MP3 mono FLV
   -- 13  176x144 3GP/AMR mono 3GP 
   -- 17  176x144 3GP/AAC mono 3GP
   -- 18  480x360 480x270 H.264/AAC stereo MP4
   -- 22 1280x720 H.264/AAC stereo MP4
   -- 34 320x240 H.264/AAC stereo FLV
   -- 35  640x480 640x360 H.264/AAC stereo FLV
d77 1
a77 1
   pattern = '"fmt_map": *"([%d]+)'
d80 6
d87 1
a87 1
      if nf == 18 or nf == 22 then
d99 1
a99 1
      file = string.gsub(title, "[^%w-]", "_")
d117 1
a117 1
   pattern = '"video_id": *"([^\"]*)"'
d121 4
a124 4
   error_pattern = "<div class=\"errorBox\">%s+(.-)</div>"
   error = string.match(body, error_pattern)
   if error then
      io.stderr:write(error .. "\n")
d130 1
a130 1
      pattern = '"t": *"([^\"]*)"'
d133 1
a133 1
         .. "&t=" .. t .. fmt)
@


1.25
log
@add support for proxies (uses the standard http_proxy variable).
ok jsg@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.24 2009/08/24 19:31:27 jsg Exp $
d129 1
a129 1
      pattern = "'/googleplayer.swf%?videoUrl(.-)'"
@


1.24
log
@Be less demanding with the fmt_map, so we don't
have to care if it is url encoded or not.

Makes us able to fetch higher than lowest quality videos again,
after another youtube change.

ok martynas@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.23 2009/08/16 19:37:59 jsg Exp $
d9 1
d54 7
a60 1
   body = assert(http.request(url))
@


1.23
log
@make yt work again after recent youtube changes
fetch higher quality video if avaible
don't convert to mpeg4 if we fetched mpeg4

ok sthen@@ martynas@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.22 2009/06/13 02:01:19 martynas Exp $
d69 1
a69 1
   pattern = '"fmt_map": *"([%d]+)\/'
@


1.22
log
@- update comments, it can also fetch google videos now
- take maintainership
- bump package name
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.21 2009/06/13 01:51:08 martynas Exp $
d59 18
a76 5
   -- Fetch high quality if available.
   if (string.match(body, "yt.VideoQualityConstants.HIGH") ~= nil) and
   ((string.match(body, "/watch_fullscreen%?.*fmt_map=[^&]*%%2C6[^%d]")~=nil) or
   (string.match(body,"/watch_fullscreen%?.*fmt_map=6[^%d]")~=nil)) then
      fmt = "&fmt=6"
d103 1
a103 1
   pattern = "/watch_fullscreen%?.*video_id=([^&\"]*)"
d116 1
a116 1
      pattern = "/watch_fullscreen%?.*&t=([^&\"]*)"
d132 8
d141 1
a141 1
      url = url, file = e_flv })
d145 2
a146 2
   if opts.n then
      io.stderr:write("Done. Video saved in " .. flv .. ".\n")
@


1.21
log
@- start accepting options: -C, -n, -o
- -C will resume previously interrupted transfer
- -n will not convert videos
- -o=XXX will save file to XXX.(mp4|flv)
- print info stuff to stderr;  so we can pipe it
- bump to yt-10;  since usage changes
as a result;  you can actually stream your videos with mplayer, like:
	yt -o=- url | mplayer -
ok jsg@@, sthen@@
@
text
@d2 3
a4 3
-- $OpenBSD: yt.lua,v 1.20 2009/06/06 11:58:22 martynas Exp $
-- Fetch videos from YouTube.com and convert them to MPEG.
-- Written by Pedro Martelletto in August 2006. Public domain.
@


1.20
log
@make it, like most other unix utilities, accept multiple urls.  ok jsg@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.19 2009/01/07 00:14:52 martynas Exp $
d7 1
d11 4
a14 1
fetch = "ftp -o <file> <url>"
d22 21
a42 2
-- Make sure a URL was given.
assert(table.getn(arg) > 0, "Wrong usage, no URL given")
d45 2
a46 2
for i = 1, table.getn(arg) do
   url = arg[i]
d52 1
a52 1
   print(string.format("Getting %s ...", url))
d69 14
a82 3
   file = string.gsub(title, "[^%w-]", "_")
   file = string.lower(file)
   flv = file .. ".flv"
d97 1
a97 1
      print(error)
d119 2
a120 1
   cmd = string.gsub(fetch, "<(%w+)>", { url = url, file = e_flv })
d124 9
a132 6
   cmd = string.gsub(convert, "<(%w+)>", { flv = e_flv, mp4 = e_mp4 })
   print("Converting ...")
   assert(os.execute(cmd) == 0, "Failed")

   os.remove(flv)
   print("Done. Video saved in " .. mp4 .. ".")
@


1.19
log
@tweak high-quality matching expression a bit;  newer youtube contains
more information and there may be number that matches quality identificator
while we with Henrikas did not find such video;  there may be
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.18 2009/01/06 18:48:17 martynas Exp $
a8 3
-- Make sure a URL was given.
url = assert(arg[1], "Wrong usage, no URL given")

d18 2
a19 2
-- Convert embedded links to the correct form
url = string.gsub(url, "/v/", "/watch?v=")
d21 71
a91 16
-- Fetch the page holding the embedded video.
print(string.format("Getting %s ...", url))
body = assert(http.request(url))

-- Look for the video title.
pattern = "<title>(.-)</title>"
title = assert(string.match(body, pattern))

-- Fetch high quality if available
if (string.match(body, "yt.VideoQualityConstants.HIGH") ~= nil) and
   ((string.match(body,"/watch_fullscreen%?.*fmt_map=[^&]*%%2C6[^%d]")~=nil) or
    (string.match(body,"/watch_fullscreen%?.*fmt_map=6[^%d]")~=nil)) then
	fmt = "&fmt=6"
else
	fmt = ""
end
d93 2
a94 20
-- Build a name for the files the video will be stored in.
file = string.gsub(title, "[^%w-]", "_")
file = string.lower(file)
flv = file .. ".flv"
mp4 = file .. ".mp4"

-- Escape the file names.
e_flv = string.format("%q", flv)
e_mp4 = string.format("%q", mp4)

-- Look for the video ID.
pattern = "/watch_fullscreen%?.*video_id=([^&\"]*)"
video_id = string.match(body, pattern)

-- check for error such as "This video is not available in your country."
error_pattern = "<div class=\"errorBox\">%s+(.-)</div>"
error = string.match(body, error_pattern)
if error then
	print(error)
	return
a96 28
if video_id then
	--- Look for the additional video ID.
	pattern = "/watch_fullscreen%?.*&t=([^&\"]*)"
	t = assert(string.match(body, pattern))
	url = string.format("%q", base_url .. "?video_id=" .. video_id
		.. "&t=" .. t .. fmt)
else
	-- We assume it's Google Video URL.
	pattern = "'/googleplayer.swf%?videoUrl(.-)'"
	url = assert(string.match(body, pattern))
	url = string.gsub (url, "\\x", "%%")
	url = string.gsub (url, "%%(%x%x)", function(h)
		return string.char(tonumber(h,16)) end)
	url = string.gsub (url, "^=", "")
	url = string.format("%q", url)
end

-- Fetch the video.
cmd = string.gsub(fetch, "<(%w+)>", { url = url, file = e_flv })
assert(os.execute(cmd) == 0, "Failed")

-- Convert it to MPEG.
cmd = string.gsub(convert, "<(%w+)>", { flv = e_flv, mp4 = e_mp4 })
print("Converting ...")
assert(os.execute(cmd) == 0, "Failed")

os.remove(flv)
print("Done. Video saved in " .. mp4 .. ".")
@


1.18
log
@yt.VideoQualityConstants.HIGH may not be enough;  be safe and always
fetch low-quality, except when 6 is matched in fmt_list -- in this
case we are sure that high-quality format is available
links provided, much tested by Henrikas Judickas <Henrikas.Judickas at
mif.stud.vu.lt>.  Thanks!
ok jsg@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.17 2009/01/06 12:35:27 sthen Exp $
d34 3
a36 2
   (string.match(body, "/watch_fullscreen%?.*fmt_map=[^&]*6[^&]*&") ~= nil) then
	fmt = "%&fmt=6"
@


1.17
log
@CATEGORIES+=www, use SUBST_CMD, bump. ok jasper
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.16 2009/01/05 18:44:37 martynas Exp $
d33 3
a35 2
if (string.match(body, "yt.VideoQualityConstants.HIGH") ~= nil) then
	fmt = "&fmt=6"
@


1.16
log
@recently youtube added "Send greeting card" function;  breaking yt.  make
yt more careful with parameter matching;  as a result videos can fetch again
ok jolan@@
@
text
@d1 2
a2 2
#!/usr/local/bin/lua
-- $OpenBSD: yt.lua,v 1.15 2008/11/04 04:14:50 jsg Exp $
@


1.15
log
@Check for and display errors, so a string like
"This video is not available in your country." will be
displayed instead of a failed assert.

ok martynas@@ pedro@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.14 2008/09/14 12:28:11 jsg Exp $
d50 1
a50 1
pattern = "/watch_fullscreen%?.*video_id=(.-)&"
d63 1
a63 1
	pattern = "/watch_fullscreen%?.*&t=(.-)&"
@


1.14
log
@Download higher quality videos (fmt=6) if available.
ok martynas@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.13 2008/09/11 11:58:09 jsg Exp $
d52 8
@


1.13
log
@Add support for links from players embedded in third party pages.
ok martynas@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.12 2008/06/02 17:43:10 martynas Exp $
d32 7
d58 1
a58 1
		.. "&t=" .. t)
@


1.12
log
@- add support for Google Video
- bump package name
"sounds good" jolan@@;  tested by Wiktor Izdebski
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.11 2008/06/02 17:29:56 martynas Exp $
d20 3
@


1.11
log
@- remove origin
- remove redundant substitution
- better pattern for watch_fullscreen
- bump package name
"sounds good" jolan@@;  tested by Wiktor Izdebski
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.10 2008/05/06 20:49:51 martynas Exp $
d26 1
a26 1
pattern = "<meta name=\"title\" content=\"(.-)\""
d31 1
a31 1
file = "youtube-" .. string.lower(file)
d41 1
a41 1
video_id = assert(string.match(body, pattern))
d43 16
a58 3
-- Look for the additional video ID.
pattern = "/watch_fullscreen%?.*&t=(.-)&"
t = assert(string.match(body, pattern))
a60 1
url = string.format("%q", base_url .. "?video_id=" .. video_id .. "&t=" .. t)
@


1.10
log
@googlevideo returns 403 for some urls, so switch base_url back to
youtube.  this makes some videos fetch again.  (e.g., video id
uPTcnzgseaQ recently posted on mailing-lists)
ok jolan@@, pedro@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.9 2008/02/01 19:14:59 martynas Exp $
d19 1
a19 1
base_url = "http://www.youtube.com/get_video?origin=youtube.com"
a29 1
file = string.gsub(title, " ", "_")
d40 1
a40 1
pattern = "/watch_fullscreen.*video_id=(.-)&"
d44 1
a44 1
pattern = "/watch_fullscreen.*&t=(.-)&"
d48 1
a48 1
url = string.format("%q", base_url .. "&video_id=" .. video_id .. "&t=" .. t)
@


1.9
log
@make yt videos that aren't on the primary mirror work again.
googlevideo server expects the "t" parameter to know which mirror
to forward to;  ok jolan@@, pedro@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.8 2008/01/28 21:48:45 jolan Exp $
d19 1
a19 1
base_url = "http://cache.googlevideo.com/get_video?origin=youtube.com"
@


1.8
log
@make it work again, from tedude via pedro martelletto
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.7 2007/11/09 00:26:29 jolan Exp $
d19 1
a19 1
base_url = "http://cache.googlevideo.com/get_video?origin=youtube.com&video_id="
d42 5
a46 1
id = assert(string.match(body, pattern))
d49 1
a49 1
url = string.format("%q", base_url .. id)
@


1.7
log
@aac->libfaac
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.6 2007/10/29 22:50:31 jolan Exp $
d19 1
a19 1
base_url = "http://www.youtube.com/get_video?video_id="
d41 1
a41 1
pattern = "/watch_fullscreen.*video_id=(.-)&fs="
@


1.6
log
@generate files that will play in quicktime, ok pedro martelletto
@
text
@d1 2
a2 2
#!%%LOCALBASE%%/bin/lua
-- $OpenBSD: yt.lua,v 1.5 2007/08/26 21:47:46 jasper Exp $
d16 1
a16 1
convert = "ffmpeg -y -i <flv> -b 1000k -f mp4 -vcodec mpeg4 -acodec aac -ab 128k <mp4> 1>/dev/null 2>&1"
@


1.5
log
@update to yt-7, makes it work again

from pedro
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.4 2007/06/23 05:16:22 sturm Exp $
d16 1
a16 1
convert = "ffmpeg -y -i <flv> -b 1000k -vcodec mpeg4 -acodec copy <avi> 1>/dev/null 2>&1"
d34 1
a34 1
avi = file .. ".avi"
d38 1
a38 1
e_avi = string.format("%q", avi)
d50 1
a50 1
cmd = string.gsub(convert, "<(%w+)>", { flv = e_flv, avi = e_avi })
d55 1
a55 1
print("Done. Video saved in " .. avi .. ".")
@


1.4
log
@substitute all special characters but dashes with '_'

discussed with and ok pedro
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.3 2007/06/19 17:32:52 pedro Exp $
d41 1
a41 1
pattern = "player2.swf.*video_id=(.-)\","
@


1.3
log
@yt-4, handles new youtube html syntax, from jsg@@
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.2 2007/02/24 09:52:01 sturm Exp $
d31 1
@


1.2
log
@make this example script into a standalone application

ok pedro
@
text
@d2 1
a2 1
-- $OpenBSD: yt.lua,v 1.1 2007/02/21 13:50:18 pedro Exp $
d40 1
a40 1
pattern = "player2.swf[?]video_id=(.-)\","
@


1.1
log
@yt-2, with suggestions from sturm@@, okay sturm@@, jasper@@
@
text
@d1 2
a2 1
-- $OpenBSD$
@

