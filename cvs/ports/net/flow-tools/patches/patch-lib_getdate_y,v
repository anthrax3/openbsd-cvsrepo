head	1.1;
access;
symbols
	OPENBSD_6_1:1.1.0.16
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.14
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.10
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.12
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.8
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.6
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.4
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2013.04.19.21.32.37;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Constrain date.y's 2038 check to only when sizeof(time_t) == sizeof(int).
As done in base e.g. usr.bin/cvs/date.y r1.23

Add an XXX comment for stupid static LeapYears table in trn/tin.
@
text
@$OpenBSD$
--- lib/getdate.y.orig	Fri Apr 19 21:26:06 2013
+++ lib/getdate.y	Fri Apr 19 22:18:00 2013
@@@@ -651,9 +651,9 @@@@ Convert(time_t Month, time_t Day, time_t Year,
 	Year += 1900;
     DaysInMonth[1] = Year % 4 == 0 && (Year % 100 != 0 || Year % 400 == 0)
 		    ? 29 : 28;
-    /* Checking for 2038 bogusly assumes that time_t is 32 bits.  But
-       I'm too lazy to try to check for time_t overflow in another way.  */
-    if (Year < EPOCH || Year > 2038
+    /* XXX Sloppily check for 2038 if time_t is 32 bits */
+    if (Year < EPOCH
+     || (sizeof(time_t) == sizeof(int) && Year > 2038)
      || Month < 1 || Month > 12
      /* Lint fluff:  "conversion from long may lose accuracy" */
      || Day < 1 || Day > DaysInMonth[(int)--Month])
@
