head	1.3;
access;
symbols
	OPENBSD_5_6:1.2.0.16
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.14
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.12
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.10
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.8
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.20
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.18
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.16
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.14
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.12
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.10
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.8
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.6
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.4
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.2
	OPENBSD_3_9_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2014.12.29.10.48.15;	author sthen;	state dead;
branches;
next	1.2;
commitid	7byQLzR4OsIJDF9n;

1.2
date	2010.08.30.03.48.17;	author kevlo;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.11.20.12.45;	author steven;	state Exp;
branches;
next	;


desc
@@


1.3
log
@update to p5-IO-Interface-1.09 from Mikolaj Kucharski (taking maintainer)
@
text
@
NetBSD and OpenBSD don't set the address family on the "netmask" address.
Work around that by just setting the address family field after ioctl() and
before checking it.

if_hwaddr() was broken, code looping all interfaces was causing segmentation
fault on freeifaddrs()

$OpenBSD: patch-Interface_xs,v 1.2 2010/08/30 03:48:17 kevlo Exp $
--- Interface.xs.orig	Fri Jun  6 16:51:42 2008
+++ Interface.xs	Sun Aug 29 01:53:48 2010
@@@@ -2,6 +2,9 @@@@
 #include "perl.h"
 #include "XSUB.h"
 
+#include <stdio.h>
+#include <string.h>
+
 /* socket definitions */
 #include <sys/types.h>
 #include <sys/socket.h>
@@@@ -511,6 +514,9 @@@@ if_netmask(sock, name, ...)
 	  operation = SIOCGIFNETMASK;
      }
      if (!Ioctl(sock,operation,&ifr)) XSRETURN_UNDEF;
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+     ifr.ifr_addr.sa_family = AF_INET;
+#endif
      if (ifr.ifr_addr.sa_family != AF_INET) croak ("Address is not in the AF_INET family.\n");
      RETVAL = inet_ntoa(((struct sockaddr_in*) &ifr.ifr_addr)->sin_addr);
 #endif
@@@@ -566,7 +572,7 @@@@ if_hwaddr(sock, name, ...)
      IOCTL_CMD_T    operation;
      struct ifreq   ifr;
 #if (defined(USE_GETIFADDRS) && defined(HAVE_SOCKADDR_DL_STRUCT))
-     struct ifaddrs* ifap = NULL;
+     struct ifaddrs *ifap, *ifa;
      struct sockaddr_dl* sdl;
      sa_family_t  family;
      char *sdlname, *haddr, *s;
@@@@ -582,20 +588,17 @@@@ if_hwaddr(sock, name, ...)
 #if (defined(USE_GETIFADDRS) && defined(HAVE_SOCKADDR_DL_STRUCT))
      getifaddrs(&ifap);
 
-     while(1) {
-       if (ifap == NULL) break;
-       if (strncmp(name, ifap -> ifa_name, IFNAMSIZ) == 0) {
-         family = ifap -> ifa_addr -> sa_family;
+     for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+       if (strncmp(name, ifa->ifa_name, IFNAMSIZ) == 0) {
+         family = ifa->ifa_addr->sa_family;
          if (family == AF_LINK) {
-           sdl = (struct sockaddr_dl *) ifap->ifa_addr;
+           sdl = (struct sockaddr_dl *) ifa->ifa_addr;
            haddr = sdl->sdl_data + sdl->sdl_nlen;
            hlen = sdl->sdl_alen;
            break;
          }
        }
-       ifap = ifap -> ifa_next;
      } 
-     freeifaddrs(ifap);
 
      s = hwaddr; 
      s[0] = '\0';
@@@@ -608,6 +611,9 @@@@ if_hwaddr(sock, name, ...)
          s += len;
        }
      }
+
+     freeifaddrs(ifap);
+
      RETVAL = hwaddr;
 #elif (defined(HAS_IOCTL) && defined(SIOCGIFHWADDR))
      bzero((void*)&ifr,sizeof(struct ifreq));
@


1.2
log
@Update to 1.05; fixes regress test for netmask and mac address detection.

from Mikolaj Kucharsk, thanks!
@
text
@d9 1
a9 1
$OpenBSD$
@


1.1
log
@- update to 0.98
- fix ioctl calls to work on 64 bit arches

ok sturm@@
@
text
@d1 8
d10 5
a14 5
--- Interface.xs.orig	Wed Jan 11 08:24:31 2006
+++ Interface.xs	Wed Jan 11 08:25:51 2006
@@@@ -317,7 +317,7 @@@@ not_there:
     return 0;
 }
d16 18
a33 29
-int Ioctl (InputStream sock,int operation,void* result) {
+int Ioctl (InputStream sock,unsigned long operation,void* result) {
   int fd = PerlIO_fileno(sock);
   return ioctl(fd,operation,result) == 0;
 }
@@@@ -383,7 +383,7 @@@@ if_addr(sock, name, ...)
      PROTOTYPE: $$;$
      PREINIT:
      STRLEN        len;
-     int           operation;
+     unsigned long operation;
      struct ifreq  ifr;
      char*         newaddr;
      CODE:
@@@@ -421,7 +421,7 @@@@ if_broadcast(sock, name, ...)
      PROTOTYPE: $$;$
      PREINIT:
      STRLEN        len;
-     int           operation;
+     unsigned long operation;
      struct ifreq  ifr;
      char*         newaddr;
      CODE:
@@@@ -455,7 +455,7 @@@@ if_netmask(sock, name, ...)
      PROTOTYPE: $$;$
      PREINIT:
      STRLEN         len;
-     int            operation;
+     unsigned long  operation;
d35 41
a75 30
      char*          newaddr;
      CODE:
@@@@ -489,7 +489,7 @@@@ if_dstaddr(sock, name, ...)
      PROTOTYPE: $$;$
      PREINIT:
      STRLEN         len;
-     int            operation;
+     unsigned long  operation;
      struct ifreq   ifr;
      char*          newaddr;
      CODE:
@@@@ -523,7 +523,7 @@@@ if_hwaddr(sock, name, ...)
      PROTOTYPE: $$;$
      PREINIT:
      STRLEN	    len;
-     int            operation;
+     unsigned long  operation;
      struct ifreq   ifr;
      char           *newaddr,hwaddr[128];
      CODE:
@@@@ -555,7 +555,8 @@@@ if_flags(sock, name, ...)
      char*       name
      PROTOTYPE: $$;$
      PREINIT:
-     int            operation,flags;
+     unsigned long  operation;
+     int            flags;
      struct ifreq   ifr;
      CODE:
    {
@

