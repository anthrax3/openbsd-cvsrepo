head	1.3;
access;
symbols
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.1.1.1.0.24
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.22
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.20
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.18
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.16
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.14
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.12
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.10
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.8
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.6
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.4
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.2
	OPENBSD_3_1_BASE:1.1.1.1
	naddy_20020131:1.1.1.1
	naddy:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2008.08.25.15.14.43;	author jasper;	state dead;
branches;
next	1.2;

1.2
date	2007.12.11.11.04.57;	author jakemsr;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.31.12.21.53;	author naddy;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.01.31.12.21.53;	author naddy;	state Exp;
branches;
next	;


desc
@@


1.3
log
@- update dctc to a less ancient version 0.85.9
- merge parts of pkg/SECURITY into pkg/MESSAGE
- fix license marker

feedback and ok ajacoutot@@
@
text
@$OpenBSD: patch-src_dc_manage_c,v 1.2 2007/12/11 11:04:57 jakemsr Exp $
--- src/dc_manage.c.orig	Fri Jan 25 08:39:48 2002
+++ src/dc_manage.c	Tue Dec 11 00:04:50 2007
@@@@ -69,6 +69,16 @@@@ typedef enum
 	MY_DIR_UPLOAD=1,				/* what we should do on the connection: Upload */
 } MY_DIR;
 
+
+/* compability macros for reading/writing to sockets */
+#ifdef __OpenBSD__
+# define sock_read(sck, buf, size, flags) read(sck, buf, size)
+# define sock_write(sck, buf, size, flags) write(sck, buf, size)
+#else
+# define sock_read(sck, buf, size, flags) recv(sck, buf, size, flags)
+# define sock_write(sck, buf, size, flags) send(sck, buf, size, flags)
+#endif
+
 int hub_logged=0;	/* set to 1 when dctc is logged on the hub */
 
 /********************************************************/
@@@@ -294,13 +304,13 @@@@ static int send_file_data(int sck,char *filename, int 
 		act->last_touch=time(NULL);
 
 		get_slices(bl_semid,sizeof(buf)/512);							/* obtain upload authorization */
-		res=send(sck,buf,sizeof(buf),MSG_NOSIGNAL /* |MSG_WAITALL */ );
+                res=sock_write(sck,buf,sizeof(buf),MSG_NOSIGNAL /* |MSG_WAITALL */ );
 
 		act->last_touch=time(NULL);
 		if(res!=sizeof(buf))
 			goto abrt;
 
-		sprintf(ul_stat,"%lu:%d/%lu/%lu/%lu",act->thread_id,start_pos,file_len,(i+1)*sizeof(buf),a);
+		snprintf(ul_stat, sizeof(ul_stat), "%lu:%d/%lu/%lu/%lu",act->thread_id,start_pos,file_len,(i+1)*sizeof(buf),a);
 		disp_msg(XFER_UL_STAT,NULL,ul_stat,NULL);
 	}
 
@@@@ -317,7 +327,7 @@@@ static int send_file_data(int sck,char *filename, int 
 		act->last_touch=time(NULL);
 
 		get_slices(bl_semid,(remain+511)/512);							/* obtain upload authorization */
-		res=send(sck,buf,remain,MSG_NOSIGNAL /* |MSG_WAITALL */ );
+		res=sock_write(sck,buf,remain,MSG_NOSIGNAL /* |MSG_WAITALL */ );
 
 		act->last_touch=time(NULL);
 		if(res!=remain)
@@@@ -351,7 +361,7 @@@@ static int send_array_data(int sck,GByteArray *ba,WAIT
 		act->last_touch=time(NULL);
 
 		get_slices(bl_semid,BLOCK_SIZE/512);							/* obtain upload authorization */
-		res=send(sck,ba->data+cur_pos,BLOCK_SIZE,MSG_NOSIGNAL /* |MSG_WAITALL */ );
+		res=sock_write(sck,ba->data+cur_pos,BLOCK_SIZE,MSG_NOSIGNAL /* |MSG_WAITALL */ );
 
 		act->last_touch=time(NULL);
 		if(res!=BLOCK_SIZE)
@@@@ -369,7 +379,7 @@@@ static int send_array_data(int sck,GByteArray *ba,WAIT
 		act->last_touch=time(NULL);
 
 		get_slices(bl_semid,(remain+511)/512);							/* obtain upload authorization */
-		res=send(sck,ba->data+cur_pos,remain,MSG_NOSIGNAL /* |MSG_WAITALL */ );
+		res=sock_write(sck,ba->data+cur_pos,remain,MSG_NOSIGNAL /* |MSG_WAITALL */ );
 
 		act->last_touch=time(NULL);
 		if(res!=remain)
@@@@ -454,17 +464,18 @@@@ static int com_up_get_list_len_process(const char *cmd
 
 	disp_msg(DEBUG_MSG,"reply",out->str,NULL);
 
-	res=send(sck,out->str,out->len,MSG_NOSIGNAL);
+	res=sock_write(sck,out->str,out->len,MSG_NOSIGNAL);
 	res=(res!=out->len);
 	g_string_free(out,TRUE);
-	if(res)
+
+	if(res || !strcmp(cmd,"$GetListLen"))
 	{
 		if(cpy_data!=NULL)
 			g_byte_array_free(cpy_data,TRUE);
 		LOCK_WRITE(user_info);
 		free_dl_slot++;
 		UNLOCK_WRITE(user_info);
-		return 1;
+		return strcmp(cmd,"$GetListLen");
 	}
 
 	/* get command */
@@@@ -480,7 +491,9 @@@@ static int com_up_get_list_len_process(const char *cmd
 				g_string_sprintfa(out,"%lu|",(unsigned long)100000+rand()%500000);
 			else
 				g_string_sprintfa(out,"%lu|",(unsigned long)cpy_data->len);
-			res=send(sck,out->str,out->len,MSG_NOSIGNAL);
+
+			res=sock_write(sck,out->str,out->len,MSG_NOSIGNAL);
+
 			res=(res!=out->len);
 			g_string_free(out,TRUE);
 			if(res)
@@@@ -685,7 +698,7 @@@@ static int com_up_get_process(const char *cmd,WAIT_ACT
 	disp_msg(XFER_UL_START,"",act->remote_nick->str,fullpathname,NULL);
 	{
 		char tmp[510];
-		sprintf(tmp,"%lu",(unsigned long)(act->thread_id));
+		snprintf(tmp, sizeof(tmp), "%lu",(unsigned long)(act->thread_id));
 		disp_msg(XFER_UL_RUN,NULL,tmp,act->remote_nick->str,act->disp_info->str,NULL);
 	}
 	
@@@@ -885,8 +898,9 @@@@ static int copie_fd_to_file(int remote, FILE *local, u
 
 		/* touch the action slot to avoid timeout */
 		act->last_touch=time(NULL);
-		ret=recv(remote,buf,nb,MSG_WAITALL|MSG_NOSIGNAL);
-		
+
+		ret=sock_read(remote,buf,nb,MSG_WAITALL|MSG_NOSIGNAL);
+
 		if((ret==-1)||(ret==0))
 		{	/* error or nothing received */
 			disp_msg(ERR_MSG,"copie_fd_to_file","connection closed (1)",NULL);
@@@@ -1298,7 +1312,8 @@@@ static int start_a_xdownload(WAIT_ACT *act, WAIT_REVCO
 				break;
 
 			act->last_touch=time(NULL);
-			ret=recv(act->sock_fd,buf,amount,MSG_WAITALL|MSG_NOSIGNAL);
+			ret=sock_read(act->sock_fd,buf,amount,MSG_WAITALL|MSG_NOSIGNAL);
+
 			if((ret==-1)||(ret==0))
 			{	/* error or nothing received */
 				goto end_on_error;
@@@@ -1388,12 +1403,9 @@@@ static int copie_fd_to_bytearray(int remote, GByteArra
 
 		/* touch the action slot to avoid timeout */
 		act->last_touch=time(NULL);
-#if 0
-		ret=recv(remote,(*ba)->data+pos,nb,MSG_WAITALL|MSG_NOSIGNAL);
-#else
-		ret=recv(remote,(*ba)->data+pos,nb,MSG_NOSIGNAL);
+		ret=sock_read(remote,(*ba)->data+pos,nb,MSG_NOSIGNAL /*MSG_NOSIGNAL*/);
+
 		printf("%d (nb:%lu, amount: %lu)\n",ret,nb,amount);
-#endif
 		
 		if((ret==-1)||(ret==0))
 		{	/* error or nothing received */
@@@@ -3109,7 +3121,7 @@@@ void get_dc_line_and_process(int sck)
 	static int call_counter=0;
 	char tmp[512];
 
-	sprintf(tmp,"call counter: %d",call_counter++);
+	snprintf(tmp, sizeof(tmp), "call counter: %d",call_counter++);
 
 	disp_msg(DEBUG_MSG,"get_dc_lines_until_no_more",tmp,NULL);
 
@


1.2
log
@use -pthread instead of -lpthread for pthreads linkage

sync w/update-patches
@
text
@d1 1
a1 1
$OpenBSD: patch-src_dc_manage_c,v 1.1.1.1 2002/01/31 12:21:53 naddy Exp $
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- src/dc_manage.c.orig	Fri Jan 25 17:39:48 2002
+++ src/dc_manage.c	Mon Jan 28 18:26:10 2002
d21 1
a21 1
@@@@ -294,13 +304,13 @@@@ static int send_file_data(int sck,char *
d37 1
a37 1
@@@@ -317,7 +327,7 @@@@ static int send_file_data(int sck,char *
d46 1
a46 1
@@@@ -351,7 +361,7 @@@@ static int send_array_data(int sck,GByte
d55 1
a55 1
@@@@ -369,7 +379,7 @@@@ static int send_array_data(int sck,GByte
d64 1
a64 1
@@@@ -454,17 +464,18 @@@@ static int com_up_get_list_len_process(c
d86 1
a86 1
@@@@ -480,7 +491,9 @@@@ static int com_up_get_list_len_process(c
d97 1
a97 1
@@@@ -685,7 +698,7 @@@@ static int com_up_get_process(const char
d106 1
a106 1
@@@@ -885,8 +898,9 @@@@ static int copie_fd_to_file(int remote, 
d118 1
a118 1
@@@@ -1298,7 +1312,8 @@@@ static int start_a_xdownload(WAIT_ACT *a
d128 1
a128 1
@@@@ -1388,12 +1403,9 @@@@ static int copie_fd_to_bytearray(int rem
@


1.1.1.1
log
@Import dctc 0.68.0; submitted by Nils Nordman <nino@@nforced.com>.

DCTC is a Direct Connect clone, allowing users to share their files
and talk (like IRC but more software sharing oriented) using a
proprietary protocol. 
@
text
@@
