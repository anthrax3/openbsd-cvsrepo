head	1.5;
access;
symbols
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2007.05.14.21.42.47;	author ckuethe;	state dead;
branches;
next	1.4;

1.4
date	2007.02.12.18.07.12;	author ckuethe;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.12.17.38.03;	author ckuethe;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.11.18.11.09;	author ckuethe;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.03.20.07.46;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.5
log
@update to darkstat 3.0.619.
ok rui
@
text
@$OpenBSD: patch-cap_c,v 1.4 2007/02/12 18:07:12 ckuethe Exp $
--- cap.c.orig	Mon Feb 12 10:50:08 2007
+++ cap.c	Mon Feb 12 10:50:23 2007
@@@@ -43,7 +43,7 @@@@ static const linkhdr_t *linkhdr = NULL;
  * Init pcap.  Exits on failure.
  */
 void
-cap_init(const char *device, const char *filter)
+cap_init(const char *device, const char *filter, int promisc)
 {
    char errbuf[PCAP_ERRBUF_SIZE], *tmp_device;
    int linktype, caplen;
@@@@ -79,7 +79,7 @@@@ cap_init(const char *device, const char 
    pcap = pcap_open_live(
       tmp_device,
       caplen,      /* snaplen */
-      1,           /* promisc, FIXME */
+      promisc,           /* promisc */
       CAP_TIMEOUT,
       errbuf);
 
@@@@ -91,6 +91,11 @@@@ cap_init(const char *device, const char 
 
    free(tmp_device);
 
+   if (promisc)
+      verbosef("capturing in promiscuous mode");
+   else
+      verbosef("capturing in non-promiscuous mode");
+
    /* Set filter expression, if any. */
    if (filter != NULL)
    {
@@@@ -112,28 +117,13 @@@@ cap_init(const char *device, const char 
       free(tmp_filter);
    }
 
-#ifdef HAVE_PCAP_GET_SELECTABLE_FD
-   if (pcap_setnonblock(pcap, 1, errbuf) == -1)
-      errx(1, "pcap_setnonblock(): %s", errbuf);
-
-   pcap_fd = pcap_get_selectable_fd(pcap);
-   if (pcap_fd == -1)
-      errx(1, "pcap_get_selectable_fd(): there isn't one!");
-
-   verbosef("pcap_got_selectable_fd");
-#else
-   /* hax */
    pcap_fd = pcap_fileno(pcap);
 
+   /* set non-blocking */
 { int one = 1;
    if (ioctl(pcap_fd, FIONBIO, &one) == -1)
       err(1, "ioctl(pcap_fd, FIONBIO)"); }
 
-{ struct timeval t = { 0, CAP_TIMEOUT * 1000 }; /* msec -> usec */
-   if (ioctl(pcap_fd, BIOCSRTIMEOUT, &t) == -1)
-      err(1, "ioctl(pcap_fd, BIOCSRTIMEOUT)"); }
-#endif
-
 #ifdef BIOCSETWF
 {
    /* Deny all writes to the socket */
@@@@ -151,6 +141,7 @@@@ cap_init(const char *device, const char 
 #endif
 
 #ifdef BIOCLOCK
+   /* set "locked" flag (no reset) */
    if (ioctl(pcap_fd, BIOCLOCK) == -1)
       err(1, "ioctl(pcap_fd, BIOCLOCK)");
    verbosef("locked down BPF for security");
@@@@ -190,7 +181,7 @@@@ cap_poll(fd_set *read_set)
 
 #ifndef linux /* We don't use select() on Linux. */
    if (!FD_ISSET(pcap_fd, read_set)) {
-      dverbosef("cap_poll premature");
+      verbosef("cap_poll premature");
       return;
    }
 #endif
@@@@ -202,19 +193,29 @@@@ cap_poll(fd_set *read_set)
    localip_update(); /* FIXME: this might even be too often */
 
    total = 0;
-   do {
+   for (;;) {
       ret = pcap_dispatch(
             pcap,
             -1,               /* count, -1 = entire buffer */
             linkhdr->handler, /* callback func from decode.c */
             NULL);            /* user */
 
+      verbosef("ret = %d", ret); /* FIXME: debugging the FIONBIO change */
+
       if (ret < 0)
          errx(1, "pcap_dispatch(): %s", pcap_geterr(pcap));
 
       /* Despite count = -1, Linux will only dispatch one packet at a time. */
       total += ret;
-   } while (ret != 0);
+
+#ifdef linux
+      /* keep looping until we've dispatched all the outstanding packets */
+      if (ret == 0) break;
+#else
+      /* we get them all on the first shot */
+      break;
+#endif
+   }
    /*FIXME*/fprintf(stderr, "%-20d\r", total);
 }
 
@


1.4
log
@unclobber patches.
ok naddy
@
text
@d1 1
a1 1
$OpenBSD: patch-cap_c,v 1.3 2007/02/12 17:38:03 ckuethe Exp $
@


1.3
log
@Allow darkstat run without making the interface promiscuous. This was marked
as a FIXME in the source.
ok naddy
@
text
@d1 3
a3 3
$OpenBSD: patch-cap_c,v 1.2 2006/11/11 18:11:09 ckuethe Exp $
--- cap.c.orig	Mon Feb 12 10:29:27 2007
+++ cap.c	Mon Feb 12 10:29:53 2007
d22 1
a22 2
@@@@ -90,6 +90,11 @@@@ cap_init(const char *device, const char 
       warnx("pcap_open_live() warning: %s", errbuf);
d25 1
a25 1
+
d30 1
a30 1
 
d33 80
@


1.2
log
@update to darkstat 3.0.540, plus the 3.0.553 patches.
ok jasper
@
text
@d1 9
a9 31
$OpenBSD$
--- cap.c.orig	Fri Jul 14 01:31:23 2006
+++ cap.c	Fri Nov  3 17:59:07 2006
@@@@ -112,28 +112,13 @@@@ cap_init(const char *device, const char 
       free(tmp_filter);
    }
 
-#ifdef HAVE_PCAP_GET_SELECTABLE_FD
-   if (pcap_setnonblock(pcap, 1, errbuf) == -1)
-      errx(1, "pcap_setnonblock(): %s", errbuf);
-
-   pcap_fd = pcap_get_selectable_fd(pcap);
-   if (pcap_fd == -1)
-      errx(1, "pcap_get_selectable_fd(): there isn't one!");
-
-   verbosef("pcap_got_selectable_fd");
-#else
-   /* hax */
    pcap_fd = pcap_fileno(pcap);
 
+   /* set non-blocking */
 { int one = 1;
    if (ioctl(pcap_fd, FIONBIO, &one) == -1)
       err(1, "ioctl(pcap_fd, FIONBIO)"); }
 
-{ struct timeval t = { 0, CAP_TIMEOUT * 1000 }; /* msec -> usec */
-   if (ioctl(pcap_fd, BIOCSRTIMEOUT, &t) == -1)
-      err(1, "ioctl(pcap_fd, BIOCSRTIMEOUT)"); }
-#endif
-
 #ifdef BIOCSETWF
d11 10
a20 10
    /* Deny all writes to the socket */
@@@@ -151,6 +136,7 @@@@ cap_init(const char *device, const char 
 #endif
 
 #ifdef BIOCLOCK
+   /* set "locked" flag (no reset) */
    if (ioctl(pcap_fd, BIOCLOCK) == -1)
       err(1, "ioctl(pcap_fd, BIOCLOCK)");
    verbosef("locked down BPF for security");
@@@@ -190,7 +176,7 @@@@ cap_poll(fd_set *read_set)
d22 2
a23 23
 #ifndef linux /* We don't use select() on Linux. */
    if (!FD_ISSET(pcap_fd, read_set)) {
-      dverbosef("cap_poll premature");
+      verbosef("cap_poll premature");
       return;
    }
 #endif
@@@@ -202,19 +188,29 @@@@ cap_poll(fd_set *read_set)
    localip_update(); /* FIXME: this might even be too often */
 
    total = 0;
-   do {
+   for (;;) {
       ret = pcap_dispatch(
             pcap,
             -1,               /* count, -1 = entire buffer */
             linkhdr->handler, /* callback func from decode.c */
             NULL);            /* user */
 
+      verbosef("ret = %d", ret); /* FIXME: debugging the FIONBIO change */
+
       if (ret < 0)
          errx(1, "pcap_dispatch(): %s", pcap_geterr(pcap));
d25 1
a25 3
       /* Despite count = -1, Linux will only dispatch one packet at a time. */
       total += ret;
-   } while (ret != 0);
d27 4
a30 10
+#ifdef linux
+      /* keep looping until we've dispatched all the outstanding packets */
+      if (ret == 0) break;
+#else
+      /* we get them all on the first shot */
+      break;
+#endif
+   }
    /*FIXME*/fprintf(stderr, "%-20d\r", total);
 }
d32 2
@


1.1
log
@Update to 3.0.524. Includes some security enhancements.
ok alek
@
text
@d2 48
a49 4
--- cap.c.orig	Wed Jun 21 07:58:41 2006
+++ cap.c	Mon Jul 10 10:24:21 2006
@@@@ -134,6 +134,22 @@@@ cap_init(const char *device, const char 
       err(1, "ioctl(pcap_fd, BIOCSRTIMEOUT)"); }
d51 11
d63 1
a63 6
+#ifdef BIOCSETWF
+{
+   /* Deny all writes to the socket */
+   struct bpf_insn bpf_wfilter[] = { BPF_STMT(BPF_RET+BPF_K, 0) };
+   int wf_len = sizeof(bpf_wfilter) / sizeof(struct bpf_insn);
+   struct bpf_program pr;
d65 6
a70 2
+   pr.bf_len = wf_len;
+   pr.bf_insns = bpf_wfilter;
d72 6
a77 4
+   if (ioctl(pcap_fd, BIOCSETWF, &pr) == -1)
+      err(1, "ioctl(pcap_fd, BIOCSETFW)");
+   verbosef("Filtered out BPF writes");
+}
d79 4
a82 4
+
 #ifdef BIOCLOCK
    if (ioctl(pcap_fd, BIOCLOCK) == -1)
       err(1, "ioctl(pcap_fd, BIOCLOCK)");
@

