head	1.8;
access;
symbols
	OPENBSD_5_8:1.4.0.18
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.14
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.12
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.10
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.8
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.6
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2016.06.24.14.52.20;	author mglocker;	state dead;
branches;
next	1.7;
commitid	vCNQcZ4byTlLbRKE;

1.7
date	2016.03.13.14.36.58;	author sthen;	state Exp;
branches;
next	1.6;
commitid	QD17PwYNiTQPHPX9;

1.6
date	2016.03.06.13.40.04;	author sthen;	state Exp;
branches;
next	1.5;
commitid	o1mfv0Q88Fhv5Onu;

1.5
date	2015.12.29.22.45.05;	author sthen;	state dead;
branches;
next	1.4;
commitid	oEoIWEQ9jIPM88TY;

1.4
date	2011.10.19.09.47.26;	author dcoppa;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.14.10.22.16;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.19.09.17.51;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.21.10.35.27;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Switch to a new GitHub fork mglocker/irssi-icb which updates to
irssi-icb-0.17 and includes our ports patches.

ok sthen
@
text
@$OpenBSD: patch-src_fe-common_fe-icb_c,v 1.7 2016/03/13 14:36:58 sthen Exp $
--- src/fe-common/fe-icb.c.orig	Mon Mar  7 08:54:15 2016
+++ src/fe-common/fe-icb.c	Sun Mar 13 14:35:33 2016
@@@@ -120,8 +120,12 @@@@ static void event_personal(ICB_SERVER_REC *server, con
 	char **args;
 
 	args = icb_split(data, 2);
+#if IRSSI_VERSION_DATE > 20141206
 	signal_emit("message private", 5, server, args[1], args[0], "",
 		    server->nick);
+#else
+	signal_emit("message private", 4, server, args[1], args[0], "");
+#endif
         icb_split_free(args);
 }
 
@


1.7
log
@switch to Ailin Nemui's devel branch of irssi-icb, fixes privmsg-to-self
in newer irssi
@
text
@d1 1
a1 1
$OpenBSD$
@


1.6
log
@cope with API change in newer irssi
@
text
@d2 4
a5 3
--- src/fe-common/fe-icb.c.orig	Sun Mar  6 13:36:59 2016
+++ src/fe-common/fe-icb.c	Sun Mar  6 13:37:47 2016
@@@@ -531,3 +531,11 @@@@ void fe_icb_deinit(void)
d7 8
a14 1
 	signal_remove("server add fill", (SIGNAL_FUNC) sig_server_add_fill);
d16 1
a16 8
+
+#ifdef IRSSI_ABI_VERSION
+void
+fe_icb_abicheck(int * version)
+{
+	*version = IRSSI_ABI_VERSION;
+}
+#endif
@


1.5
log
@update to irssi-icb 0.15, plus pkgsrc patches
@
text
@d1 4
a4 6
$OpenBSD: patch-src_fe-common_fe-icb_c,v 1.4 2011/10/19 09:47:26 dcoppa Exp $
--- src/fe-common/fe-icb.c.orig	Sat Apr 27 22:56:18 2002
+++ src/fe-common/fe-icb.c	Tue Oct 18 15:20:42 2011
@@@@ -18,33 +18,73 @@@@
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
d6 1
a6 80
+#include <time.h>
+
 #include "module.h"
 #include "module-formats.h"
 #include "signals.h"
 #include "commands.h"
 #include "servers-setup.h"
 #include "levels.h"
+#include "nicklist.h"
 
 #include "icb.h"
 #include "icb-servers.h"
 #include "icb-channels.h"
+#include "icb-nicklist.h"
 #include "icb-protocol.h"
 
 #include "printtext.h"
 #include "themes.h"
 
-static void event_status(ICB_SERVER_REC *server, const char *data)
+static void icb_change_topic(ICB_SERVER_REC *server, const char *topic,
+			     const char *setby, time_t settime)
 {
-	char **args;
+	if (topic != NULL) {
+		g_free_not_null(server->group->topic);
+		server->group->topic = g_strdup(topic);
+	}
 
-	/* FIXME: status messages should probably divided into their own
-	   signals so irssi could track joins, parts, etc. */
-	args = icb_split(data, 2);
-	printformat(server, server->group->name, MSGLEVEL_CRAP,
-		    ICBTXT_STATUS, args[0], args[1]);
-        icb_split_free(args);
+	if (setby != NULL) {
+		g_free_not_null(server->group->topic_by);
+		server->group->topic_by = g_strdup(setby);
+	}
+
+	server->group->topic_time = settime;
+
+	signal_emit("channel topic changed", 1, server->group);
 }
 
+/*
+ * ICB makes it hard to keep track of nicks:
+ *
+ *  - moderators can come and go, and even return with a different nick, while
+ *    still retaining their moderator status
+ *
+ *  - group moderator can change at any time, if the moderator is off-group
+ *    while changing nick
+ *
+ *  - users can be moderator of multiple groups simultaneously, but can only
+ *    be in one group at a time
+ *
+ * So for now we don't bother to track the moderator, just the group nicks
+ */
+static void icb_update_nicklist(ICB_SERVER_REC *server)
+{
+	/*
+	 * In theory we should be able to just send '/who <group>' and parse,
+	 * but the problem is that ICB does not send any kind of end-of-who
+	 * marker when only listing one group, and sending a separate command
+	 * isn't guaranteed to come back in the right order.
+	 *
+	 * So we're forced do perform a full /who and then match against our
+	 * groupname.  A full /who is terminated with a 'Total: ' line which we
+	 * can use as EOF>
+	 */
+	server->silentwho = TRUE;
+	icb_command(server, "w", "", NULL);
+}
+
 static void event_error(ICB_SERVER_REC *server, const char *data)
 {
 	printformat(server, NULL, MSGLEVEL_CRAP, ICBTXT_ERROR, data);
@@@@ -84,15 +124,351 @@@@ static void event_personal(ICB_SERVER_REC *server, con
         icb_split_free(args);
a7 7
 
+static void idle_time(char *buf, size_t bufsize, time_t idle)
+{
+#define MIN_LEN		60UL
+#define HOUR_LEN	3600UL
+#define DAY_LEN		86400UL
+#define WEEK_LEN	604800UL
d9 3
a11 17
+	if (idle >= WEEK_LEN)
+		snprintf(buf, bufsize, "%2dw%2dd",
+			 (int)(idle/WEEK_LEN), (int)((idle%WEEK_LEN)/DAY_LEN));
+	else if (idle >= DAY_LEN)
+		snprintf(buf, bufsize, "%2dd%2dh",
+			 (int)(idle/DAY_LEN), (int)((idle%DAY_LEN)/HOUR_LEN));
+	else if (idle >= HOUR_LEN)
+		snprintf(buf, bufsize, "%2dh%2dm",
+			 (int)(idle/HOUR_LEN), (int)((idle%HOUR_LEN)/MIN_LEN));
+	else if (idle >= MIN_LEN)
+		snprintf(buf, bufsize, "%2dm%2ds",
+			 (int)(idle/MIN_LEN), (int)(idle%MIN_LEN));
+	else
+		snprintf(buf, bufsize, "   %2ds", (int)idle);
+}
+
+static void cmdout_co(ICB_SERVER_REC *server, char **args)
d13 1
a13 67
+	char *p, *group, *topic;
+	int len;
+
+	static const char match_group[] = "Group: ";
+	static const char match_topic[] = "Topic: ";
+	static const char match_topicunset[] = "(None)";
+	static const char match_topicis[] = "The topic is";
+	static const char match_total[] = "Total: ";
+
+	/*
+	 * Use 'co' as the marker to denote wl lines have finished, so
+	 * reset the nick updates
+	 */
+	server->updatenicks = FALSE;
+
+	/* If we're running in silent mode, parse the output for nicks/topic */
+	if (server->silentwho) {
+
+		/* Match group lines */
+		len = strlen(match_group);
+		if (strncmp(args[0], match_group, len) == 0) {
+
+			group = g_strdup(args[0] + len);
+			p = strchr(group, ' ');
+			*p = '\0';
+
+			/* Check for our particular group */
+			len = strlen(group);
+			if (g_ascii_strncasecmp(group, server->group->name, len) == 0) {
+
+				/* Start matching nicks */
+				server->updatenicks = TRUE;
+
+				p = strstr(args[0], match_topic);
+				if (p != NULL && p != args[0]) {
+					topic = p + strlen(match_topic);
+					if (topic != NULL) {
+						len = strlen(match_topicunset);
+						if (strncmp(topic,
+							    match_topicunset,
+							    len) != 0) {
+
+							/* No way to find who set the topic, mark as unknown */
+							icb_change_topic(server, topic, "unknown", time(NULL));
+						}
+					}
+				}
+			}
+			g_free(group);
+		}
+
+		/*
+		 * End of /who output, stop silent mode and signal front-end
+		 * to display /names list
+		 */
+		len = strlen(match_total);
+		if (strncmp(args[0], match_total, len) == 0) {
+			server->silentwho = FALSE;
+			signal_emit("channel joined", 1, server->group);
+		}
+	} else {
+		/* Now that /topic works correctly, ignore server output */
+		len = strlen(match_topicis);
+		if (strncmp(args[0], match_topicis, len) != 0) {
+			printtext(server, NULL, MSGLEVEL_CRAP, "%s", args[0]);
+		}
+	}
a14 38
+
+static void cmdout_wl(ICB_SERVER_REC *server, char **args)
+{
+	struct tm *logintime;
+	char logbuf[20];
+	char idlebuf[20];
+	char line[255];
+	time_t temptime;
+	int op;
+
+	/* "wl" : In a who listing, a line of output listing a user. Has the following format:
+
+	* Field 1: String indicating whether user is moderator or not. Usually "*" for
+	* moderator, and " " for not.
+	* Field 2: Nickname of user.
+	* Field 3: Number of seconds user has been idle.
+	* Field 4: Response Time. No longer in use.
+	* Field 5: Login Time. Unix time_t format. Seconds since Jan. 1, 1970 GMT.
+	* Field 6: Username of user.
+	* Field 7: Hostname of user.
+	* Field 8: Registration status.
+	*/
+	temptime = strtol(args[4], NULL, 10);
+	logintime = gmtime(&temptime);
+	strftime(logbuf, sizeof(logbuf), "%b %e %H:%M", logintime);
+	temptime = strtol(args[2], NULL, 10);
+	idle_time(idlebuf, sizeof(idlebuf), temptime);
+
+	/* Update nicklist */
+	if (server->updatenicks) {
+		op = FALSE;
+#ifdef NO_MOD_SUPPORT_YET
+		switch(args[0][0]) {
+		case '*':
+		case 'm':
+			op = TRUE;
+			break;
+		}
a15 267
+		icb_nicklist_insert(server->group, args[1], op);
+	}
+	if (!server->silentwho) {
+		snprintf(line, sizeof(line), "*** %c%-14.14s %6.6s %12.12s %s@@%s %s",
+			  args[0][0] == ' '?' ':'*', args[1], idlebuf, logbuf, args[5],
+			  args[6], args[7]);
+		printtext(server, NULL, MSGLEVEL_CRAP, line);
+	}
+}
+
 static void cmdout_default(ICB_SERVER_REC *server, char **args)
 {
 	char *data;
 
 	data = g_strjoinv(" ", args+1);
-	printtext(server, server->group->name, MSGLEVEL_CRAP, "%s", data);
+	if (!server->silentwho) {
+		printtext(server, NULL, MSGLEVEL_CRAP, "%s", data);
+	}
         g_free(data);
 }
 
+/*
+ * args0 = "Arrive"
+ * args0 = "<nickname> (<user>@@<host>) entered group"
+ */
+static void status_arrive(ICB_SERVER_REC *server, char **args)
+{
+	char *nick, *p;
+
+	nick = g_strdup(args[1]);
+	p = strchr(nick, ' ');
+	*p = '\0';
+	/* XXX: new arrivals can still be moderator */
+	icb_nicklist_insert(server->group, nick, FALSE);
+        g_free(nick);
+
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
+/*
+ * args0 = "Depart"
+ * args1 = "<nickname> (<user>@@<host>) just left"
+ */
+static void status_depart(ICB_SERVER_REC *server, char **args)
+{
+	NICK_REC *nickrec;
+	char *nick, *p;
+
+	nick = g_strdup(args[1]);
+	p = strchr(nick, ' ');
+	*p = '\0';
+
+	nickrec = nicklist_find(CHANNEL(server->group), nick);
+	if (nickrec != NULL) {
+		nicklist_remove(CHANNEL(server->group), nickrec);
+	}
+	g_free(nick);
+
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
+/*
+ * args0 = "Sign-on"
+ * args1 = "<nickname> (<user>@@<host>) entered group"
+ */
+static void status_signon(ICB_SERVER_REC *server, char **args)
+{
+	char *nick, *p;
+
+	nick = g_strdup(args[1]);
+	p = strchr(nick, ' ');
+	*p = '\0';
+
+	icb_nicklist_insert(server->group, nick, FALSE);
+
+        g_free(nick);
+
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
+/*
+ * args0 = "Sign-off"
+ * args1 = "<nickname> (<user>@@<host>) has signed off."
+ */
+static void status_signoff(ICB_SERVER_REC *server, char **args)
+{
+	NICK_REC *nickrec;
+	char *nick, *p;
+
+	nick = g_strdup(args[1]);
+	p = strchr(nick, ' ');
+	*p = '\0';
+
+	nickrec = nicklist_find(CHANNEL(server->group), nick);
+	if (nickrec != NULL) {
+		nicklist_remove(CHANNEL(server->group), nickrec);
+	}
+	g_free(nick);
+
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
+/*
+ * In theory should be status_status() but that's just silly :-)
+ *
+ * args0 = "Status"
+ * args0 = "You are now in group <group>[ as moderator]"
+ */
+static void status_join(ICB_SERVER_REC *server, char **args)
+{
+	icb_update_nicklist(server);
+
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
+/*
+ * args0 = "Name"
+ * args1 = "<oldnick> changed nickname to <newnick>"
+ */
+static void status_name(ICB_SERVER_REC *server, char **args)
+{
+	NICK_REC *nickrec;
+	char *oldnick, *newnick, *p;
+
+	oldnick = g_strdup(args[1]);
+	p = strchr(oldnick, ' ');
+	if (p != NULL) *p = '\0';
+
+	p = g_strdup(args[1]);
+	newnick = strrchr(p, ' ');
+	if (newnick != NULL)
+	       newnick++;
+
+	nickrec = nicklist_find(CHANNEL(server->group), oldnick);
+	if (nickrec != NULL)
+		nicklist_rename(SERVER(server), oldnick, newnick);
+
+	/* Update our own nick */
+	if (strcmp(oldnick, server->connrec->nick) == 0) {
+		server_change_nick(SERVER(server), newnick);
+		g_free(server->connrec->nick);
+		server->connrec->nick = g_strdup(newnick);
+	}
+
+	g_free(oldnick);
+	g_free(p);
+
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
+/*
+ * args0 = "Topic"
+ * args1 = "<nickname> changed the topic to "<topic>"
+ */
+static void status_topic(ICB_SERVER_REC *server, char **args)
+{
+	char *topic, *setby, *p1, *p2;
+
+	p1 = strchr(args[1], '"');
+	p2 = strrchr(args[1], '"');
+
+	if (p1++) {
+		topic = g_strdup(p1);
+		p2 = strrchr(topic, '"');
+		*p2 = '\0';
+
+		setby = g_strdup(args[1]);
+		p2 = strchr(setby, ' ');
+		*p2 = '\0';
+
+		icb_change_topic(server, topic, setby, time(NULL));
+
+		g_free(topic);
+		g_free(setby);
+	}
+
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
+/*
+ * args0 = "Pass"
+ * args1 = "<nickname> just passed you moderation of group <group>"
+ * args1 = "<nickname> has passed moderation to <nickname>"
+ * args1 = "<nickname> is now mod."
+ *
+ * If the moderator signs off and you are passed moderation, then the third
+ * args1 is used.
+ *
+ */
+static void status_pass(ICB_SERVER_REC *server, char **args)
+{
+	/*
+	 * Eventually we might want to track this, for now just print status
+	 * to the group window
+	 */
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
+static void status_default(ICB_SERVER_REC *server, char **args)
+{
+	/* Send messages to the group window by default */
+	printformat(server, server->group->name, MSGLEVEL_CRAP,
+		    ICBTXT_STATUS, args[0], args[1]);
+}
+
 static void sig_server_add_fill(SERVER_SETUP_REC *rec,
 				GHashTable *optlist)
 {
@@@@ -109,13 +485,23 @@@@ void fe_icb_init(void)
 {
 	theme_register(fecommon_icb_formats);
 
-	signal_add("icb event status", (SIGNAL_FUNC) event_status);
         signal_add("icb event error", (SIGNAL_FUNC) event_error);
         signal_add("icb event important", (SIGNAL_FUNC) event_important);
         signal_add("icb event beep", (SIGNAL_FUNC) event_beep);
         signal_add("icb event open", (SIGNAL_FUNC) event_open);
         signal_add("icb event personal", (SIGNAL_FUNC) event_personal);
+        signal_add("icb cmdout co", (SIGNAL_FUNC) cmdout_co);
+        signal_add("icb cmdout wl", (SIGNAL_FUNC) cmdout_wl);
         signal_add("default icb cmdout", (SIGNAL_FUNC) cmdout_default);
+        signal_add("icb status arrive", (SIGNAL_FUNC) status_arrive);
+        signal_add("icb status depart", (SIGNAL_FUNC) status_depart);
+        signal_add("icb status sign-on", (SIGNAL_FUNC) status_signon);
+        signal_add("icb status sign-off", (SIGNAL_FUNC) status_signoff);
+        signal_add("icb status status", (SIGNAL_FUNC) status_join);
+        signal_add("icb status topic", (SIGNAL_FUNC) status_topic);
+        signal_add("icb status name", (SIGNAL_FUNC) status_name);
+        signal_add("icb status pass", (SIGNAL_FUNC) status_pass);
+        signal_add("default icb status", (SIGNAL_FUNC) status_default);
 
 	signal_add("server add fill", (SIGNAL_FUNC) sig_server_add_fill);
 	command_set_options("server add", "-icbnet");
@@@@ -125,13 +511,23 @@@@ void fe_icb_init(void)
 
 void fe_icb_deinit(void)
 {
-        signal_remove("icb event status", (SIGNAL_FUNC) event_status);
         signal_remove("icb event error", (SIGNAL_FUNC) event_error);
         signal_remove("icb event important", (SIGNAL_FUNC) event_important);
         signal_remove("icb event beep", (SIGNAL_FUNC) event_beep);
         signal_remove("icb event open", (SIGNAL_FUNC) event_open);
         signal_remove("icb event personal", (SIGNAL_FUNC) event_personal);
+        signal_remove("icb cmdout co", (SIGNAL_FUNC) cmdout_co);
+        signal_remove("icb cmdout wl", (SIGNAL_FUNC) cmdout_wl);
         signal_remove("default icb cmdout", (SIGNAL_FUNC) cmdout_default);
+        signal_remove("icb status arrive", (SIGNAL_FUNC) status_arrive);
+        signal_remove("icb status depart", (SIGNAL_FUNC) status_depart);
+        signal_remove("icb status sign-on", (SIGNAL_FUNC) status_signon);
+        signal_remove("icb status sign-off", (SIGNAL_FUNC) status_signoff);
+        signal_remove("icb status status", (SIGNAL_FUNC) status_join);
+        signal_remove("icb status topic", (SIGNAL_FUNC) status_topic);
+        signal_remove("icb status name", (SIGNAL_FUNC) status_name);
+        signal_remove("icb status pass", (SIGNAL_FUNC) status_pass);
+        signal_remove("default icb status", (SIGNAL_FUNC) status_default);
 
 	signal_remove("server add fill", (SIGNAL_FUNC) sig_server_add_fill);
 }
@


1.4
log
@Small cleanup:

add "-module" to LDFLAGS
remove now unneeded (char *) casts from NULLs
add missing time.h

OK sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_fe-common_fe-icb_c,v 1.3 2011/06/14 10:22:16 sthen Exp $
@


1.3
log
@sync irssi-icb with pkgsrc changes, ok jasper@@

- implement commands via irssi signals
- detect /topic on join
- support /names, including on join
@
text
@d1 12
a12 4
$OpenBSD: patch-src_fe-common_fe-icb_c,v 1.2 2010/05/19 09:17:51 sthen Exp $
--- src/fe-common/fe-icb.c.orig	Sat Apr 27 21:56:18 2002
+++ src/fe-common/fe-icb.c	Tue Jun 14 10:40:30 2011
@@@@ -24,27 +24,65 @@@@
d86 1
a86 1
@@@@ -84,15 +122,351 @@@@ static void event_personal(ICB_SERVER_REC *server, con
d439 1
a439 1
@@@@ -109,13 +483,23 @@@@ void fe_icb_init(void)
d464 1
a464 1
@@@@ -125,13 +509,23 @@@@ void fe_icb_init(void)
@


1.2
log
@Add a prototype, the implicit declaration has a conflicting type.
Fixes build with gcc4.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_fe-common_fe-icb_c,v 1.1 2008/04/21 10:35:27 sthen Exp $
d3 2
a4 2
+++ src/fe-common/fe-icb.c	Wed May 19 10:14:42 2010
@@@@ -24,6 +24,7 @@@@
d12 4
a15 1
@@@@ -33,18 +34,96 @@@@
d19 3
a21 4
+static void icb_channel_change_topic(ICB_SERVER_REC *,
+	const char *, const char *, time_t );
+
 static void event_status(ICB_SERVER_REC *server, const char *data)
d23 1
a23 70
 	char **args;
+	int len;
+	char *oldnick, *newnick;
+	char *topic, *setby, *p1, *p2;
 
 	/* FIXME: status messages should probably divided into their own
 	   signals so irssi could track joins, parts, etc. */
 	args = icb_split(data, 2);
 	printformat(server, server->group->name, MSGLEVEL_CRAP,
 		    ICBTXT_STATUS, args[0], args[1]);
+
+	/* sample nick msg: oldnick changed nickname to newnick */
+	len = strlen("Name");
+	if (strncmp(args[0],"Name",len) == 0) {
+
+		oldnick = g_strdup(args[1]);
+		p2 = strchr(oldnick, ' ');
+		if (p2 != NULL)
+		{
+			*p2 = '\0';
+
+			/* make sure it's me changing the nick */
+			if (strcmp(oldnick, server->connrec->nick) == 0)
+			{
+				newnick = strrchr(args[1], ' ');
+				if (newnick != NULL) {
+					newnick++;  /* skip the space */
+
+					server_change_nick(SERVER(server), newnick);
+					nicklist_rename(SERVER(server), server->connrec->nick, newnick);
+					g_free(server->connrec->nick);
+					server->connrec->nick = g_strdup(newnick);
+				}
+			}
+		}
+		g_free(oldnick);
+	}
+
+	/* sample topic msg: nick changed the topic to \"test 1\" */
+	len = strlen("Topic");
+	if (strncmp(args[0],"Topic",len) == 0) {
+		p1 = strchr(args[1], '"');
+		p2 = strrchr(args[1], '"');
+
+		/* make sure there's something between those quotes */
+		if (p1)
+		{
+			p1++;
+			topic = g_strdup(p1);
+			p2 = strrchr(topic, '"');
+			*p2 = '\0';
+
+			setby = g_strdup(args[1]);
+			p2 = strchr(setby, ' ');
+			*p2 = '\0';
+
+			icb_channel_change_topic(server, topic, setby, time(NULL));
+
+			g_free(topic);
+			g_free(setby);
+		}
+	}
+
         icb_split_free(args);
 }
 
+static void icb_channel_change_topic(ICB_SERVER_REC *server, 
+				 const char *topic, const char *setby,
+				 time_t settime)
+{
d28 7
a34 1
+
d39 1
a39 1
+	
d43 30
d78 1
a78 10
@@@@ -62,7 +141,7 @@@@ static void event_important(ICB_SERVER_REC *server, co
 
 static void event_beep(ICB_SERVER_REC *server, const char *data)
 {
-	printformat(server, data, MSGLEVEL_CRAP, ICBTXT_BEEP, data);
+	printformat(server, data, MSGLEVEL_MSGS, ICBTXT_BEEP, data);
 }
 
 static void event_open(ICB_SERVER_REC *server, const char *data)
@@@@ -84,13 +163,51 @@@@ static void event_personal(ICB_SERVER_REC *server, con
d82 19
a100 7
+static char *icb_who_idle(char *line)
+{       
+	int	idle = atoi(line);
+	static	char	lbuf[16];
+        
+	if (idle > 99 * 60)
+		g_snprintf(lbuf, sizeof lbuf, "%5dm", idle / 60);
d102 121
a222 18
+	if (idle < 60)
+		g_snprintf(lbuf, sizeof lbuf, "%d sec", idle);
+	else
+		g_snprintf(lbuf, sizeof lbuf, "%d:%02ds", idle / 60, idle % 60);
+	lbuf[6] = 0;    /* XXX see below */
+	return (lbuf);
+}
+       
+static char *icb_who_signon(char *line)
+{       
+	time_t  their_time = (time_t)atoi(line);
+	char	*s = asctime(localtime(&their_time));
+        
+	s[16] = '\0';   /* XXX */
+	/* Tue Mar  2 05:10:10 1999J */
+	/*     <---------->          */
+	return (s + 4);
+}       
d226 3
a228 3
-	char *data;
-
-	data = g_strjoinv(" ", args+1);
d230 2
a231 16
-        g_free(data);
+	if (args[0][0] == 'w') {
+		if (args[0][1] == 'h')
+			printformat(server, NULL, MSGLEVEL_CRAP, ICBTXT_WHO_HEADER);
+		else if (args[0][1] == 'l') {
+			char *arg1 = args[1][0] == 'm' ? "*" : " ";
+			printformat(server, NULL, MSGLEVEL_CRAP,
+				ICBTXT_WHO_LIST, arg1, args[2],
+				icb_who_idle(args[3]),
+				icb_who_signon(args[5]),
+				args[6], args[7], args[8]);
+		}
+	} else {
+		char *data = g_strjoinv(" ", args+1);
+		printtext(server, server->group->name, MSGLEVEL_CRAP, "%s", data);
+		g_free(data);
d233 1
d236 192
d429 52
@


1.1
log
@display changed topic and your /nick changes in the status bar,
convert times in /who to readable format, display the correct user
name when someone /beeps you, and add a note to the README.

ok jasper
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ src/fe-common/fe-icb.c	Sun Oct 21 15:31:29 2007
d12 7
a18 1
@@@@ -36,15 +37,90 @@@@
d109 1
a109 1
@@@@ -62,7 +138,7 @@@@ static void event_important(ICB_SERVER_REC *server, co
d118 1
a118 1
@@@@ -84,13 +160,51 @@@@ static void event_personal(ICB_SERVER_REC *server, con
@

