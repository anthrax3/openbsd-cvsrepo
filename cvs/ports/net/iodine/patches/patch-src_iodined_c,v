head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.10
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.6
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.20
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.18
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.16
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.14
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.12
	OPENBSD_5_0:1.2.0.10
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.8
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	OPENBSD_4_3_BASE:1.1.1.1
	bernd_2008-feb-06:1.1.1.1
	bernd:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2014.06.19.22.45.56;	author chris;	state Exp;
branches;
next	1.2;
commitid	KR0YITWX5VPsW0FS;

1.2
date	2009.03.30.09.17.45;	author sthen;	state Exp;
branches
	1.2.20.1;
next	1.1;

1.1
date	2008.02.06.21.42.28;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.02.06.21.42.28;	author bernd;	state Exp;
branches;
next	;

1.2.20.1
date	2014.06.19.22.58.10;	author sthen;	state Exp;
branches;
next	;
commitid	MCH9dN2XKq3JwmPa;


desc
@@


1.3
log
@Update iodine DNS tunnel to 0.7.0

ok sthen@@
@
text
@$OpenBSD$
--- src/iodined.c.orig	Mon Jun 16 13:28:43 2014
+++ src/iodined.c	Thu Jun 19 15:16:45 2014
@@@@ -771,7 +771,7 @@@@ handle_null_request(int tun_fd, int dns_fd, struct que
 				int i;
 				struct sockaddr_in *tempin;
 
-				users[userid].seed = rand();
+				users[userid].seed = arc4random();
 				/* Store remote IP number */
 				tempin = (struct sockaddr_in *) &(q->from);
 				memcpy(&(users[userid].host), &(tempin->sin_addr), sizeof(struct in_addr));
@@@@ -1100,7 +1100,7 @@@@ handle_null_request(int tun_fd, int dns_fd, struct que
 		} else {
 			char buf[2048];
 			int i;
-			unsigned int v = ((unsigned int) rand()) & 0xff ;
+			unsigned int v = ((unsigned int) arc4random()) & 0xff ;
 
 			memset(buf, 0, sizeof(buf));
 			buf[0] = (req_frag_size >> 8) & 0xff;
@@@@ -2293,8 +2293,8 @@@@ main(int argc, char **argv)
 	pw = NULL;
 #endif
 	errormsg = NULL;
-	username = NULL;
-	newroot = NULL;
+	username = "_iodine";
+	newroot = "/var/empty"; 
 	context = NULL;
 	device = NULL;
 	foreground = 0;
@@@@ -2332,7 +2332,6 @@@@ main(int argc, char **argv)
 #endif
 
 	memset(password, 0, sizeof(password));
-	srand(time(NULL));
 	fw_query_init();
 
 	while ((choice = getopt(argc, argv, "vcsfhDu:t:d:m:l:p:n:b:P:z:F:i:")) != -1) {
@


1.2
log
@- update to 0.5.1, from Simon Kuhnle.
- don't hide command lines in build output
- honour CC in the environment not just mk.conf
@
text
@d1 6
a6 9
$OpenBSD: patch-src_iodined_c,v 1.1.1.1 2008/02/06 21:42:28 bernd Exp $

Drop privileges and chroot by default.

--- src/iodined.c.orig	Sat Mar 21 14:07:49 2009
+++ src/iodined.c	Mon Mar 30 10:25:08 2009
@@@@ -961,8 +961,8 @@@@ main(int argc, char **argv)
 	int skipipconfig;
 	char *netsize;
d8 18
d29 2
a30 1
+	newroot = "/var/empty";
d33 8
a40 1
 	bind_enable = 0;
@


1.2.20.1
log
@MFC Update iodine DNS tunnel to 0.7.0 - CVE-2014-4168 - authentication bypass

"The client could bypass the password check by continuing after getting error
from the server and guessing the network parameters. The server would still
accept the rest of the setup and also network traffic."
@
text
@d1 9
a9 6
$OpenBSD: patch-src_iodined_c,v 1.3 2014/06/19 22:45:56 chris Exp $
--- src/iodined.c.orig	Mon Jun 16 13:28:43 2014
+++ src/iodined.c	Thu Jun 19 15:16:45 2014
@@@@ -771,7 +771,7 @@@@ handle_null_request(int tun_fd, int dns_fd, struct que
 				int i;
 				struct sockaddr_in *tempin;
a10 18
-				users[userid].seed = rand();
+				users[userid].seed = arc4random();
 				/* Store remote IP number */
 				tempin = (struct sockaddr_in *) &(q->from);
 				memcpy(&(users[userid].host), &(tempin->sin_addr), sizeof(struct in_addr));
@@@@ -1100,7 +1100,7 @@@@ handle_null_request(int tun_fd, int dns_fd, struct que
 		} else {
 			char buf[2048];
 			int i;
-			unsigned int v = ((unsigned int) rand()) & 0xff ;
+			unsigned int v = ((unsigned int) arc4random()) & 0xff ;
 
 			memset(buf, 0, sizeof(buf));
 			buf[0] = (req_frag_size >> 8) & 0xff;
@@@@ -2293,8 +2293,8 @@@@ main(int argc, char **argv)
 	pw = NULL;
 #endif
 	errormsg = NULL;
d14 1
a14 2
+	newroot = "/var/empty"; 
 	context = NULL;
d17 1
a17 8
@@@@ -2332,7 +2332,6 @@@@ main(int argc, char **argv)
 #endif
 
 	memset(password, 0, sizeof(password));
-	srand(time(NULL));
 	fw_query_init();
 
 	while ((choice = getopt(argc, argv, "vcsfhDu:t:d:m:l:p:n:b:P:z:F:i:")) != -1) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
d5 5
a9 5
--- src/iodined.c.orig	Fri Nov 30 23:11:30 2007
+++ src/iodined.c	Fri Feb  1 20:54:41 2008
@@@@ -447,8 +447,8 @@@@ main(int argc, char **argv)
 	int port;
 	int mtu;
d17 1
a17 1
 	mtu = 1024;
@


1.1.1.1
log
@Initial import of iodine-0.4.1.

This is a piece of software that lets you tunnel IPv4 data through a
DNS server. This can be usable in different situations where internet
access is firewalled, but DNS queries are allowed.

help/ok jasper@@
@
text
@@
