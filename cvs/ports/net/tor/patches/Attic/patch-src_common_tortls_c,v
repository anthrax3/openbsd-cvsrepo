head	1.5;
access;
symbols
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3;
locks; strict;
comment	@# @;


1.5
date	2014.10.24.20.14.48;	author pascal;	state dead;
branches;
next	1.4;
commitid	H8Pv7dNL7DUwDRzV;

1.4
date	2014.10.05.19.29.20;	author pascal;	state Exp;
branches;
next	1.3;
commitid	eQXMplYzjuLuI2it;

1.3
date	2014.07.12.13.57.23;	author pascal;	state Exp;
branches
	1.3.2.1;
next	1.2;
commitid	Q0iQPiSHXc9MEVxH;

1.2
date	2010.01.04.08.08.00;	author benoit;	state dead;
branches;
next	1.1;

1.1
date	2009.11.14.10.09.09;	author benoit;	state Exp;
branches;
next	;

1.3.2.1
date	2015.03.25.11.47.07;	author jasper;	state Exp;
branches;
next	;
commitid	VmwZdtsk8oOPnE57;


desc
@@


1.5
log
@Update to tor 0.2.5.10.
@
text
@$OpenBSD: patch-src_common_tortls_c,v 1.4 2014/10/05 19:29:20 pascal Exp $
--- src/common/tortls.c.orig	Tue Sep 23 10:41:52 2014
+++ src/common/tortls.c	Mon Oct  6 03:18:38 2014
@@@@ -1345,10 +1345,12 @@@@ tor_tls_context_new(crypto_pk_t *identity, unsigned in
     SSL_CTX_set_options(result->ctx,
                         SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
   }
+#ifndef OPENSSL_NO_COMP
   /* Don't actually allow compression; it uses ram and time, but the data
    * we transmit is all encrypted anyway. */
   if (result->ctx->comp_methods)
     result->ctx->comp_methods = NULL;
+#endif
 #ifdef SSL_MODE_RELEASE_BUFFERS
   SSL_CTX_set_mode(result->ctx, SSL_MODE_RELEASE_BUFFERS);
 #endif
@@@@ -1484,27 +1486,35 @@@@ static int v2_cipher_list_pruned = 0;
 static void
 prune_v2_cipher_list(void)
 {
+  STACK_OF(SSL_CIPHER) *ciphers;
   uint16_t *inp, *outp;
-  const SSL_METHOD *m = SSLv23_method();
+  SSL_CTX *ctx;
+  SSL *ssl;
+  int i;
 
+  ctx = SSL_CTX_new(SSLv23_method());
+  tor_assert(ctx);
+  ssl = SSL_new(ctx);
+  tor_assert(ssl);
+  ciphers = SSL_get_ciphers(ssl);
+
   inp = outp = v2_cipher_list;
   while (*inp) {
-    unsigned char cipherid[3];
-    const SSL_CIPHER *cipher;
-    /* Is there no better way to do this? */
-    set_uint16(cipherid, htons(*inp));
-    cipherid[2] = 0; /* If ssl23_get_cipher_by_char finds no cipher starting
-                      * with a two-byte 'cipherid', it may look for a v2
-                      * cipher with the appropriate 3 bytes. */
-    cipher = m->get_cipher_by_char(cipherid);
-    if (cipher) {
-      tor_assert((cipher->id & 0xffff) == *inp);
-      *outp++ = *inp++;
-    } else {
-      inp++;
+    for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
+      const SSL_CIPHER *cipher;
+
+      cipher = sk_SSL_CIPHER_value(ciphers, i);
+      if (SSL_CIPHER_get_id(cipher) == (SSL3_VERSION_MAJOR << 24 | *inp)) {
+        *outp++ = *inp;
+        break;
+      }
     }
+    *inp++;
   }
   *outp = 0;
+
+  SSL_CTX_free(ctx);
+  SSL_free(ssl);
 
   v2_cipher_list_pruned = 1;
 }
@


1.4
log
@Fix relay functionality after get_cipher_by_char removal.  Patch by jsing@@,
tested by myself and "babut".

ok dcoppa@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_common_tortls_c,v 1.3 2014/07/12 13:57:23 pascal Exp $
@


1.3
log
@Check for OPENSSL_NO_COMP before turning off compression.
@
text
@d1 3
a3 3
$OpenBSD$
--- src/common/tortls.c.orig	Sat Jul 12 15:52:08 2014
+++ src/common/tortls.c	Sat Jul 12 15:53:06 2014
d17 50
@


1.3.2.1
log
@- update to tor-0.2.4.26, which includes an updated list of directory
authorities. It also backports a couple of stability and security bugfixes
from 0.2.5 and beyond.

ok pascal@@ (MAINTAINER) who had the same diff
@
text
@d1 4
a4 4
$OpenBSD: patch-src_common_tortls_c,v 1.3 2014/07/12 13:57:23 pascal Exp $
--- src/common/tortls.c.orig	Mon Mar  9 21:23:46 2015
+++ src/common/tortls.c	Wed Mar 25 11:41:15 2015
@@@@ -1347,10 +1347,12 @@@@ tor_tls_context_new(crypto_pk_t *identity, unsigned in
@


1.2
log
@- update tor to 0.2.1.21

ok rui@@
@
text
@d1 15
a15 12
$OpenBSD: patch-src_common_tortls_c,v 1.1 2009/11/14 10:09:09 benoit Exp $
--- src/common/tortls.c.orig	Wed Nov 11 11:17:04 2009
+++ src/common/tortls.c	Wed Nov 11 11:20:05 2009
@@@@ -154,6 +154,7 @@@@
                                         const char *cname,
                                         const char *cname_sign,
                                         unsigned int lifetime);
+static void tor_tls_unblock_renegotiation(tor_tls_t *tls);
 
 /** Global tls context. We keep it here because nobody else needs to
  * touch it. */
@@@@ -904,6 +905,36 @@@@
a16 45
 }
 
+/** If this version of openssl requires it, turn on renegotiation on
+ * <b>tls</b>.  (Our protocol never requires this for security, but it's nice
+ * to use belt-and-suspenders here.)
+ */
+static void
+tor_tls_unblock_renegotiation(tor_tls_t *tls)
+{
+#ifdef SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
+  /* Yes, we know what we are doing here.  No, we do not treat a renegotiation
+   * as authenticating any earlier-received data. */
+  tls->ssl->s3->flags |= SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
+#else
+  (void)tls;
+#endif
+}
+
+/** If this version of openssl supports it, turn off renegotiation on
+ * <b>tls</b>.  (Our protocol never requires this for security, but it's nice
+ * to use belt-and-suspenders here.)
+ */
+void
+tor_tls_block_renegotiation(tor_tls_t *tls)
+{
+#ifdef SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
+  tls->ssl->s3->flags &= ~SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
+#else
+  (void)tls;
+#endif
+}
+
 /** Return whether this tls initiated the connect (client) or
  * received it (server). */
 int
@@@@ -1026,6 +1057,9 @@@@
   } else {
     r = SSL_connect(tls->ssl);
   }
+  /* We need to call this here and not earlier, since OpenSSL has a penchant
+   * for clearing its flags when you say accept or connect. */
+  tor_tls_unblock_renegotiation(tls);
   r = tor_tls_get_error(tls,r,0, "handshaking", LOG_INFO);
   if (ERR_peek_error() != 0) {
     tls_log_errors(tls, tls->isServer ? LOG_INFO : LOG_WARN,
@


1.1
log
@- update tor to 0.2.1.20
- add patches using the new SSL/TLS renegotiation.

ok rui@@, ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD$
@

