head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.1.0.18
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.14
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.12
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.10
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.8
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.6
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.4
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@# @;


1.4
date	2016.01.10.16.23.17;	author sthen;	state Exp;
branches;
next	1.3;
commitid	Xc670HliAVKb4y3C;

1.3
date	2016.01.04.03.30.39;	author sthen;	state Exp;
branches;
next	1.2;
commitid	G0N2M8PniSKeh2VP;

1.2
date	2015.12.22.12.56.27;	author sthen;	state Exp;
branches;
next	1.1;
commitid	VihqfwJLlxokWRNq;

1.1
date	2011.10.30.16.47.08;	author stsp;	state Exp;
branches;
next	;


desc
@@


1.4
log
@FD-related fixes for wide-dhcpv6, part of a diff from Brad.
Mostly from Debian.
@
text
@$OpenBSD: patch-dhcp6c_c,v 1.3 2016/01/04 03:30:39 sthen Exp $

- Close inherited file descriptors

wide-dhcpv6 binaries should close inherited fds.

- Update ifid on interface restart

Interface ID may have changed between a stop and start.

- Close file descriptors on exec

Avoid FD leakage to children.

- Call client script after interfaces have been updated

--- dhcp6c.c.orig	Sun Jun 15 03:48:41 2008
+++ dhcp6c.c	Sun Jan 10 00:59:31 2016
@@@@ -88,7 +88,6 @@@@ static sig_atomic_t sig_flags = 0;
 const dhcp6_mode_t dhcp6_mode = DHCP6_MODE_CLIENT;
 
 int sock;	/* inbound/outbound udp port */
-int rtsock;	/* routing socket */
 int ctlsock = -1;		/* control TCP port */
 char *ctladdr = DEFAULT_CLIENT_CONTROL_ADDR;
 char *ctlport = DEFAULT_CLIENT_CONTROL_PORT;
@@@@ -159,6 +158,7 @@@@ main(argc, argv)
 	char *progname;
 	FILE *pidfp;
 	struct dhcp6_if *ifp;
+	int fd;
 
 #ifndef HAVE_ARC4RANDOM
 	srandom(time(NULL) & getpid());
@@@@ -205,8 +205,12 @@@@ main(argc, argv)
 		exit(0);
 	}
 
-	if (foreground == 0)
+	if (foreground == 0) {
+		for (fd = 3; fd < 1024; fd++)
+			close(fd);
+
 		openlog(progname, LOG_NDELAY|LOG_PID, LOG_DAEMON);
+	}
 
 	setloglevel(debug);
 
@@@@ -282,6 +286,8 @@@@ client6_init()
 		    gai_strerror(error));
 		exit(1);
 	}
+	/* Force socket to be closed on execve */
+	res->ai_socktype |= SOCK_CLOEXEC;
 	sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
 	if (sock < 0) {
 		dprintf(LOG_ERR, FNAME, "socket");
@@@@ -337,13 +343,6 @@@@ client6_init()
 	}
 	freeaddrinfo(res);
 
-	/* open a routing socket to watch the routing table */
-	if ((rtsock = socket(PF_ROUTE, SOCK_RAW, 0)) < 0) {
-		dprintf(LOG_ERR, FNAME, "open a routing socket: %s",
-		    strerror(errno));
-		exit(1);
-	}
-
 	memset(&hints, 0, sizeof(hints));
 	hints.ai_family = PF_INET6;
 	hints.ai_socktype = SOCK_DGRAM;
@@@@ -763,6 +762,15 @@@@ client6_ifctl(ifname, command)
 
 	switch(command) {
 	case DHCP6CTL_COMMAND_START:
+		/*
+		 * The ifid might have changed, so reset it before releasing the
+		 * lease.
+		 */
+		if (ifreset(ifp)) {
+			dprintf(LOG_NOTICE, FNAME, "failed to reset %s",
+			    ifname);
+			return (-1);
+		}
 		free_resources(ifp);
 		if (client6_start(ifp)) {
 			dprintf(LOG_NOTICE, FNAME, "failed to restart %s",
@@@@ -1828,15 +1836,6 @@@@ client6_recvreply(ifp, dh6, len, optinfo)
 	}
 
 	/*
-	 * Call the configuration script, if specified, to handle various
-	 * configuration parameters.
-	 */
-	if (ifp->scriptpath != NULL && strlen(ifp->scriptpath) != 0) {
-		dprintf(LOG_DEBUG, FNAME, "executes %s", ifp->scriptpath);
-		client6_script(ifp->scriptpath, state, optinfo);
-	}
-
-	/*
 	 * Set refresh timer for configuration information specified in
 	 * information-request.  If the timer value is specified by the server
 	 * in an information refresh time option, use it; use the protocol
@@@@ -1899,6 +1898,15 @@@@ client6_recvreply(ifp, dh6, len, optinfo)
 		 * [RFC3315 Section 18.1.8]
 		 */
 		check_exit();
+	}
+
+	/*
+	 * Call the configuration script, if specified, to handle various
+	 * configuration parameters.
+	 */
+	if (ifp->scriptpath != NULL && strlen(ifp->scriptpath) != 0) {
+		dprintf(LOG_DEBUG, FNAME, "executes %s", ifp->scriptpath);
+		client6_script(ifp->scriptpath, state, optinfo);
 	}
 
 	dprintf(LOG_DEBUG, FNAME, "got an expected reply, sleeping.");
@


1.3
log
@add wide-dhcpv6 patches to close inherited FDs. port diff from Brad;
Debian 0003-Close-inherited-file-descriptors.patch
@
text
@d1 1
a1 1
$OpenBSD: patch-dhcp6c_c,v 1.2 2015/12/22 12:56:27 sthen Exp $
d11 8
a18 2
--- dhcp6c.c.orig	Sat Jan  2 20:48:18 2016
+++ dhcp6c.c	Sat Jan  2 20:48:25 2016
d49 10
a58 1
@@@@ -337,13 +341,6 @@@@ client6_init()
d72 1
a72 1
@@@@ -763,6 +760,15 @@@@ client6_ifctl(ifname, command)
d88 32
@


1.2
log
@Bring in two bug fixes for wide-dhcpv6 that have been in the
Debian/Ubuntu/Fedora/Red Hat packages. From Brad.

- Fix renewal of IA NA
- Update ifid on interface restart, it may have changed.
@
text
@d1 1
a1 1
$OpenBSD: patch-dhcp6c_c,v 1.1 2011/10/30 16:47:08 stsp Exp $
d3 5
a7 1
Update ifid on interface restart
d11 2
a12 2
--- dhcp6c.c.orig	Sun Jun 15 03:48:41 2008
+++ dhcp6c.c	Sat Dec 19 01:44:20 2015
d21 23
a43 1
@@@@ -337,13 +336,6 @@@@ client6_init()
d57 1
a57 1
@@@@ -763,6 +755,15 @@@@ client6_ifctl(ifname, command)
@


1.1
log
@Don't open a routing socket that's never used.
Found back in February this year by Alan Wilkie.
The unused routing socket exposed an mbuf leak kernel bug (fixed in 4.9).
Back then I forgot to commit this corresponding wide-dhcpv6 change,
which isn't strictly needed with current kernels but is nevertheless correct.
reminded by and ok jsing
@
text
@d1 8
a8 3
$OpenBSD$
--- dhcp6c.c.orig	Sun Feb 20 13:29:11 2011
+++ dhcp6c.c	Sun Feb 20 13:29:49 2011
d17 1
a17 2
@@@@ -336,13 +335,6 @@@@ client6_init()
 		exit(1);
d20 1
a20 1
-
d27 1
a27 1
 
d30 17
@

