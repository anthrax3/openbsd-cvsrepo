head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@# @;


1.6
date	2012.05.23.15.13.41;	author jasper;	state dead;
branches;
next	1.5;

1.5
date	2012.05.07.18.11.29;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2011.12.07.12.18.01;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.02.07.21.14;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.31.07.55.16;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.21.20.32.54;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.6
log
@be gone, you belong in lang/ now.
@
text
@$OpenBSD: patch-deps_v8_src_heap_cc,v 1.5 2012/05/07 18:11:29 jasper Exp $
--- deps/v8/src/heap.cc.orig	Fri May  4 22:12:52 2012
+++ deps/v8/src/heap.cc	Mon May  7 20:09:43 2012
@@@@ -5032,6 +5032,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
   initial_semispace_size_ = Min(initial_semispace_size_, max_semispace_size_);
   external_allocation_limit_ = 10 * max_semispace_size_;
 
+  intptr_t max_virtual = OS::MaxVirtualMemory();
+
+  if (max_virtual > 0) {
+    intptr_t half = max_virtual >> 1;
+    intptr_t quarter = max_virtual >> 2;
+    // If we have limits on the amount of virtual memory we can use then we may
+    // be forced to lower the allocation limits.  We reserve one quarter of the
+    // memory for young space and off-heap data.  The rest is distributed as
+    // described below.
+    if (code_range_size_ > 0) {
+      // Reserve a quarter of the memory for the code range.  The old space
+      // heap gets the remaining half.  There is some unavoidable double
+      // counting going on here since the heap size is measured in committed
+      // virtual memory and the code range is only reserved virtual memory.
+      code_range_size_ = Min(code_range_size_, quarter);
+      max_old_generation_size_ = Min(max_old_generation_size_, half);
+    } else {
+      // Reserve three quarters of the memory for the old space heap including
+      // the executable code.
+      max_old_generation_size_ = Min(max_old_generation_size_, half + quarter);
+    }
+  }
+
   // The old generation is paged.
   max_old_generation_size_ = RoundUp(max_old_generation_size_, Page::kPageSize);
 
@


1.5
log
@regen patches
@
text
@d1 1
a1 1
$OpenBSD: patch-deps_v8_src_heap_cc,v 1.4 2011/12/07 12:18:01 sthen Exp $
@


1.4
log
@update to node 0.6.3, parts from Aaron Bieber
(further update 0.6.5 to be done soonish, but let's get this in first)
@
text
@d1 4
a4 4
$OpenBSD$
--- deps/v8/src/heap.cc.orig	Wed Nov 16 13:45:37 2011
+++ deps/v8/src/heap.cc	Wed Nov 16 13:47:00 2011
@@@@ -5025,6 +5025,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
@


1.3
log
@Instead of reserving 32MB of virtual memory let's reserve the quarter of
RLIMIT_DATA (ulimit -d) if RLIMIT_DATA is not 0 (unlimited).
If RLIMIT_DATA is 0 then the default 512MB reservation will be used.
Using 32MB made v8 use less memory for sure but it was a huge performance
loss too.
@
text
@d1 4
a4 4
$OpenBSD: patch-deps_v8_src_heap_cc,v 1.2 2011/05/31 07:55:16 robert Exp $
--- deps/v8/src/heap.cc.orig	Sat May 21 04:40:06 2011
+++ deps/v8/src/heap.cc	Wed Jun  1 14:26:51 2011
@@@@ -4503,6 +4503,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
@


1.2
log
@Make v8 pre-allocate at least 32M of virtual memory to avoid
crashing with vmmap. This is needed because of their JIT is
not fully 64-bit.
@
text
@d1 1
a1 5
$OpenBSD: patch-deps_v8_src_heap_cc,v 1.1 2011/05/21 20:32:54 sthen Exp $

Don't allocate a huge chunk of VM upfront on amd64, but still use a bigger
code range size to avoid crashing with vmmap.

d3 31
a33 10
+++ deps/v8/src/heap.cc	Mon May 30 22:57:26 2011
@@@@ -91,7 +91,7 @@@@ intptr_t Heap::max_executable_size_ = max_old_generati
 static const int default_max_semispace_size_  = 16*MB;
 intptr_t Heap::max_old_generation_size_ = 1*GB;
 int Heap::initial_semispace_size_ = 1*MB;
-intptr_t Heap::code_range_size_ = 512*MB;
+intptr_t Heap::code_range_size_ = 32*MB;
 intptr_t Heap::max_executable_size_ = 256*MB;
 #else
 static const int default_max_semispace_size_  = 8*MB;
@


1.1
log
@- update node to 0.4.8

- pull across a patch from www/chromium to use the same memory allocation
policy on amd64 as is currently used on i386, this seriously reduces the
amount of virtual memory required
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
Don't allocate a huge chunk of VM upfront on amd64, use the same allocation
policy as done on i386.
d6 3
a8 8
--- deps/v8/src/heap.cc.orig	Sat May 21 09:07:11 2011
+++ deps/v8/src/heap.cc	Sat May 21 09:07:31 2011
@@@@ -87,7 +87,7 @@@@ intptr_t Heap::max_old_generation_size_ = 192*MB;
 int Heap::initial_semispace_size_ = 128*KB;
 intptr_t Heap::code_range_size_ = 0;
 intptr_t Heap::max_executable_size_ = max_old_generation_size_;
-#elif defined(V8_TARGET_ARCH_X64)
+#elif defined(V8_TARGET_ARCH_X64) && !defined(__OpenBSD__)
d12 5
@

