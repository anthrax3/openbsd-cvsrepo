head	1.3;
access;
symbols
	OPENBSD_5_8:1.3.0.2
	OPENBSD_4_3:1.2.0.20
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.18
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.16
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.14
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.12
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.10
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	sturm_2002-Nov-29:1.1.1.1
	sturm:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2008.04.04.02.21.29;	author merdely;	state dead;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.04.01.20.52.59;	author sturm;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.29.09.41.39;	author sturm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.11.29.09.41.39;	author sturm;	state Exp;
branches;
next	;

1.3.2.1
date	2016.01.27.11.03.41;	author jasper;	state Exp;
branches;
next	;
commitid	ofOqqwtZETbvjlDq;


desc
@@


1.3
log
@Update to 3.0.8.
Take over MAINTAINER-ship (discussed with ckuethe, old MAINTAINER)
Remove patches that were included upstream.

ok wcmaier@@, ckuethe@@, sturm@@
@
text
@$OpenBSD: patch-filters_c,v 1.2 2003/04/01 20:52:59 sturm Exp $
--- filters.c.orig	Fri Feb 28 07:52:45 2003
+++ filters.c	Sat Mar 29 18:17:02 2003
@@@@ -958,7 +958,7 @@@@ struct http_response *trust_url(struct c
    p = strdup("");
    for (tl = csp->config->trust_list; (t = *tl) != NULL ; tl++)
    {
-      sprintf(buf, "<li>%s</li>\n", t->spec);
+      snprintf(buf, sizeof(buf), "<li>%s</li>\n", t->spec);
       string_append(&p, buf);
    }
    err = map(exports, "trusted-referrers", 1, p, 0);
@@@@ -980,7 +980,7 @@@@ struct http_response *trust_url(struct c
       p = strdup("");
       for (l = csp->config->trust_info->first; l ; l = l->next)
       {
-         sprintf(buf, "<li> <a href=\"%s\">%s</a><br>\n",l->str, l->str);
+         snprintf(buf, sizeof(buf), "<li> <a href=\"%s\">%s</a><br>\n",l->str, l->str);
          string_append(&p, buf);
       }
       err = map(exports, "trust-info", 1, p, 0);
@


1.3.2.1
log
@Security fixes for:
CVE-2016-1982 (invalid reads in case of corrupt chunk-encoded content) and
CVE-2016-1983 (invalid reads with empty Host headers).
@
text
@d1 6
a6 19
$OpenBSD$

Security fix for CVE-2016-1982
privoxy: invalid reads in case of corrupt chunk-encoded content
http://ijbswa.cvs.sourceforge.net/viewvc/ijbswa/current/filters.c?r1=1.196&r2=1.197

--- filters.c.orig	Sat Oct 18 13:30:24 2014
+++ filters.c	Wed Jan 27 12:01:38 2016
@@@@ -2046,6 +2046,7 @@@@ static jb_err remove_chunked_transfer_coding(char *buf
    size_t newsize = 0;
    unsigned int chunksize = 0;
    char *from_p, *to_p;
+   const char *end_of_buffer = buffer + *size;
 
    assert(buffer);
    from_p = to_p = buffer;
@@@@ -2058,27 +2059,62 @@@@ static jb_err remove_chunked_transfer_coding(char *buf
 
    while (chunksize > 0U)
d8 8
a15 20
+      /*
+       * If the chunk-size is valid, we should have at least
+       * chunk-size bytes of chunk-data and five bytes of
+       * meta data (chunk-size, CRLF, CRLF) left in the buffer.
+       */
+      if (chunksize + 5 >= *size - newsize)
+      {
+         log_error(LOG_LEVEL_ERROR,
+            "Chunk size %u exceeds buffered data left. "
+            "Already digested %u of %u buffered bytes.",
+            chunksize, (unsigned int)newsize, (unsigned int)*size);
+         return JB_ERR_PARSE;
+      }
+
+      /*
+       * Skip the chunk-size, the optional chunk-ext and the CRLF
+       * that is supposed to be located directly before the start
+       * of chunk-data.
+       */
       if (NULL == (from_p = strstr(from_p, "\r\n")))
d17 3
a19 2
          log_error(LOG_LEVEL_ERROR, "Parse error while stripping \"chunked\" transfer coding");
          return JB_ERR_PARSE;
d21 1
a21 42
+      from_p += 2;
 
-      if (chunksize >= *size - newsize)
+      /*
+       * The previous strstr() does not enforce chunk-validity
+       * and is sattisfied as long a CRLF is left in the buffer.
+       *
+       * Make sure the bytes we consider chunk-data are within
+       * the valid range.
+       */
+      if (from_p + chunksize >= end_of_buffer)
       {
          log_error(LOG_LEVEL_ERROR,
-            "Chunk size %u exceeds buffered data left. "
-            "Already digested %u of %u buffered bytes.",
-            chunksize, (unsigned int)newsize, (unsigned int)*size);
+            "End of chunk is beyond the end of the buffer.");
          return JB_ERR_PARSE;
       }
-      newsize += chunksize;
-      from_p += 2;
 
       memmove(to_p, from_p, (size_t) chunksize);
+      newsize += chunksize;
       to_p = buffer + newsize;
-      from_p += chunksize + 2;
+      from_p += chunksize;
 
+      /*
+       * Not merging this check with the previous one allows us
+       * to keep chunks without trailing CRLF. It's not clear
+       * if we actually have to care about those, though.
+       */
+      if (from_p + 2 >= end_of_buffer)
+      {
+         log_error(LOG_LEVEL_ERROR, "Not enough room for trailing CRLF.");
+         return JB_ERR_PARSE;
+      }
+      from_p += 2;
       if (sscanf(from_p, "%x", &chunksize) != 1)
       {
          log_error(LOG_LEVEL_INFO, "Invalid \"chunked\" transfer encoding detected and ignored.");
@


1.2
log
@update to 3.0.2

- fixes two memory leaks, one serious
- quite some filter changes, upgraders beware!
- for details, see http://www.privoxy.org/announce.txt

from MAINTAINER
@
text
@d1 1
a1 1
$OpenBSD: patch-filters_c,v 1.1.1.1 2002/11/29 09:41:39 sturm Exp $
@


1.1
log
@Initial revision
@
text
@d1 4
a4 4
$OpenBSD$
--- filters.c.orig	Thu Aug  1 13:18:28 2002
+++ filters.c	Sun Nov 17 12:56:21 2002
@@@@ -950,7 +950,7 @@@@ struct http_response *trust_url(struct c
d13 1
a13 1
@@@@ -972,7 +972,7 @@@@ struct http_response *trust_url(struct c
@


1.1.1.1
log
@import of privoxy-3.0.0
submitted by Dan Weeks <danimal@@danimal.org>

Privoxy is a web proxy with advanced filtering capabilities for protecting
privacy, filtering web page content, managing cookies, controlling access,
and removing ads, banners, pop-ups and other obnoxious Internet junk.
Privoxy has a very flexible configuration and can be customized to suit
individual needs and tastes. Privoxy has application for both stand-alone
systems and multi-user networks.

naddy@@ OK
@
text
@@
