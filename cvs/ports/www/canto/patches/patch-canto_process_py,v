head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.26
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.24
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.22
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.18
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.20
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.16
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.14
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.12
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.10
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.8
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2011.03.13.09.36.24;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Fix a bug causing a crash on OpenBSD.
Problem reported by a user on the #canto irc channel.
Patch by Jack Miller <jack@@codezen.org> (upstream developer)

OK landry@@, jasper@@
@
text
@$OpenBSD$

Fix a crash reported by a user on the #canto irc channel.
Patch by Jack Miller <jack@@codezen.org> (upstream developer)
http://codezen.org/cgi-bin/gitweb.cgi?p=canto.git;a=commit;h=e5a4b15b0ddcab49699ab2293d560966fd9af810

--- canto/process.py.orig	Tue Jul 27 19:47:06 2010
+++ canto/process.py	Fri Mar 11 10:53:43 2011
@@@@ -106,6 +106,7 @@@@ from threading import Thread, Lock
 from cPickle import dumps, loads
 import select
 import signal
+import errno
 import time
 import sys
 import os
@@@@ -122,17 +123,41 @@@@ class Queue():
 
         self.thread = None
         self.alive = True
+        self.frag = ""
 
+    def _try_parse(self):
+        if "\0" in self.frag:
+            idx = self.frag.index("\0")
+            s, self.frag = self.frag[:idx], self.frag[idx+1:]
+            return loads(s)
+        return None
+
     def get(self, block=True, timeout=None):
+
+        # Parse a message out of the remaining fragment.
+        r = self._try_parse()
+        if r:
+            return r
+
         ready = self.poll.poll(timeout)
-        for fd, event in ready:
-            l = os.read(self.recvpipe, 1)
-            while l[-1] != " ":
-                l += os.read(self.recvpipe, 1)
-            l = int(l)
+        if not ready:
+            raise Exception
 
-            s = os.read(self.recvpipe, l)
-            return loads(s)
+        while True:
+            try:
+                self.frag += os.read(self.recvpipe, 1024)
+                r = self._try_parse()
+                if r:
+                    return r
+            except OSError, e:
+                if e.errno == errno.EINTR:
+                    continue
+                raise
+
+            if block and timeout == None:
+                continue
+            break
+
         raise Exception
 
     def feed_pipe(self):
@@@@ -145,9 +170,14 @@@@ class Queue():
             self.objlist = self.objlist[1:]
             self.objlock.release()
 
-            s = dumps(obj)
-            l = len(s)
-            os.write(self.sendpipe, "%d %s" % (l, s))
+            s = dumps(obj) + "\0"
+            while s:
+                try:
+                    written = os.write(self.sendpipe, s)
+                    s = s[written:]
+                except OSError, e:
+                    if e.errno != errno.EINTR:
+                        raise
 
     def put(self, obj):
         if not self.thread:
@
