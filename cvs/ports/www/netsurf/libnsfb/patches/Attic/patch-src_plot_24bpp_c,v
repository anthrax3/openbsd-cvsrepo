head	1.3;
access;
symbols
	bentley_20160831:1.1.1.1 bentley:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2016.11.30.07.35.00;	author bentley;	state dead;
branches;
next	1.2;
commitid	xkQnr62KFHgvGxQB;

1.2
date	2016.09.08.03.52.24;	author bentley;	state Exp;
branches;
next	1.1;
commitid	Uo540fCBvuzGX2mW;

1.1
date	2016.09.01.00.25.40;	author bentley;	state Exp;
branches
	1.1.1.1;
next	;
commitid	0S3X0J6YG3FCsHFw;

1.1.1.1
date	2016.09.01.00.25.40;	author bentley;	state Exp;
branches;
next	;
commitid	0S3X0J6YG3FCsHFw;


desc
@@


1.3
log
@Update to netsurf-3.6 and its accompanying libraries.

Note: upstream has renamed the main executable from "netsurf" to
"netsurf-gtk".
@
text
@$OpenBSD: patch-src_plot_24bpp_c,v 1.2 2016/09/08 03:52:24 bentley Exp $
--- src/plot/24bpp.c.orig	Sun Jan  3 04:52:16 2016
+++ src/plot/24bpp.c	Wed Sep  7 20:12:50 2016
@@@@ -9,13 +9,6 @@@@
 #include <stdbool.h>
 #include <stdlib.h>
 
-#ifndef _WIN32
-#include <endian.h>
-#else
-#define __BYTE_ORDER __BYTE_ORDER__
-#define __BIG_ENDIAN __ORDER_BIG_ENDIAN__
-#endif
-
 #include "libnsfb.h"
 #include "libnsfb_plot.h"
 #include "libnsfb_plot_util.h"
@@@@ -23,24 +16,43 @@@@
 #include "nsfb.h"
 #include "plot.h"
 
-static inline uint8_t *
-get_xy_loc(nsfb_t *nsfb, int x, int y)
+/**
+ * Get the address of a logical location on the framebuffer
+ */
+static inline uint8_t *get_xy_loc(nsfb_t *nsfb, int x, int y)
 {
         return (uint8_t *)(nsfb->ptr + (y * nsfb->linelen) + (x * 3));
 }
 
-#if __BYTE_ORDER == __BIG_ENDIAN
-static inline nsfb_colour_t pixel_to_colour(uint8_t pixel)
+#ifdef NSFB_BE_BYTE_ORDER
+
+/**
+ * convert a 24bpp big endian pixel value to netsurf colour
+ */
+static inline nsfb_colour_t pixel_to_colour(uint32_t pixel)
 {
         return (pixel >> 8) & ~0xFF000000U;
 }
 
-/* convert a colour value to a 32bpp pixel value ready for screen output */
+/**
+ * convert a colour value to a big endian 24bpp pixel value
+ *
+ * The resulting value is ready for screen output
+ */
 static inline uint32_t colour_to_pixel(nsfb_colour_t c)
 {
         return (c << 8);
 }
-#else /* __BYTE_ORDER == __BIG_ENDIAN */
+
+#else
+
+/**
+ * convert a 24bpp little endian pixel value to netsurf colour
+ *
+ * \param nsfb The framebuffer
+ * \param pixel The pixel values
+ * \return The netsurf colour value.
+ */
 static inline nsfb_colour_t pixel_to_colour(uint32_t pixel)
 {
         return ((pixel & 0xFF) << 16) |
@@@@ -48,11 +60,17 @@@@ static inline nsfb_colour_t pixel_to_colour(uint32_t p
                 ((pixel & 0xFF0000) >> 16);
 }
 
-/* convert a colour value to a 32bpp pixel value ready for screen output */
+/**
+ * convert a colour value to a little endian 24bpp pixel value
+ *
+ * \param c The netsurf colour
+ * \return A pixel value ready for screen output.
+ */
 static inline uint32_t colour_to_pixel(nsfb_colour_t c)
 {
         return ((c & 0xff0000) >> 16) | (c & 0xff00) | ((c & 0xff) << 16);
 }
+
 #endif
 
 #define SIGN(x)  ((x<0) ?  -1  :  ((x>0) ? 1 : 0))
@


1.2
log
@Sync patches with upstream.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_plot_24bpp_c,v 1.1.1.1 2016/09/01 00:25:40 bentley Exp $
@


1.1
log
@Initial revision
@
text
@d1 10
a10 7
$OpenBSD$
--- src/plot/24bpp.c.orig	Tue Aug 30 02:39:18 2016
+++ src/plot/24bpp.c	Tue Aug 30 02:39:44 2016
@@@@ -12,8 +12,8 @@@@
 #ifndef _WIN32
 #include <endian.h>
 #else
d13 8
a20 3
+#define BYTE_ORDER __BYTE_ORDER__
+#define BIG_ENDIAN __ORDER_BIG_ENDIAN__
 #endif
d22 7
a28 2
 #include "libnsfb.h"
@@@@ -29,7 +29,7 @@@@ get_xy_loc(nsfb_t *nsfb, int x, int y)
d33 7
a39 2
+#if BYTE_ORDER == BIG_ENDIAN
 static inline nsfb_colour_t pixel_to_colour(uint8_t pixel)
d42 9
a50 1
@@@@ -40,7 +40,7 @@@@ static inline uint32_t colour_to_pixel(nsfb_colour_t c
d55 10
a64 1
+#else /* BYTE_ORDER == BIG_ENDIAN */
d68 19
@


1.1.1.1
log
@Import libnsfb-0.1.4.

LibNSFB is a framebuffer abstraction library, written in C. It is currently
in development for use with NetSurf and is intended to be suitable for use
in other projects too.

The overall idea of the library is to provide a generic abstraction to a
linear section of memory which corresponds to a visible array of pixel
elements on a display device. Different colour depths are supported and the
library provides routines for tasks such as drawing onto the framebuffer and
rectangle copy operations.

ok landry@@ (thanks for testing!)
@
text
@@
