head	1.7;
access;
symbols
	OPENBSD_6_1:1.6.0.2
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.2.0.2
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.0.2
	OPENBSD_5_9_BASE:1.1;
locks; strict;
comment	@// @;


1.7
date	2017.07.27.14.23.46;	author robert;	state Exp;
branches;
next	1.6;
commitid	UqlSU0wmYWtcPgqI;

1.6
date	2017.03.14.12.18.53;	author robert;	state Exp;
branches;
next	1.5;
commitid	FgEdsLreTqAdn1i5;

1.5
date	2016.12.10.15.35.25;	author robert;	state Exp;
branches;
next	1.4;
commitid	D24Pj03ujnweitOe;

1.4
date	2016.09.01.16.28.11;	author robert;	state Exp;
branches;
next	1.3;
commitid	0duujWXlyOCBrehm;

1.3
date	2016.07.31.13.11.44;	author robert;	state Exp;
branches;
next	1.2;
commitid	dRegVegviFQGKQZc;

1.2
date	2016.04.26.14.22.24;	author robert;	state Exp;
branches;
next	1.1;
commitid	qCqOPZ55nJ1pWebp;

1.1
date	2015.12.05.16.13.32;	author robert;	state Exp;
branches;
next	;
commitid	D0GFSwUDbKAnIs1m;


desc
@@


1.7
log
@update to 60.0.3112.78
@
text
@// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/metrics/histogram_macros.h"
#include "base/memory/ptr_util.h"

#include "media/audio/openbsd/audio_manager_openbsd.h"

#include "media/audio/audio_device_description.h"
#include "media/audio/audio_output_dispatcher.h"
#if defined(USE_SNDIO)
#include "media/audio/sndio/sndio_input.h"
#include "media/audio/sndio/sndio_output.h"
#else
#include "media/audio/fake_audio_manager.h"
#endif
#include "media/base/limits.h"
#include "media/base/media_switches.h"

namespace media {

enum OpenBSDAudioIO {
  kPulse,
  kSndio,
  kAudioIOMax = kSndio
};

#if defined(USE_SNDIO)
// Maximum number of output streams that can be open simultaneously.
static const int kMaxOutputStreams = 4;

// Default sample rate for input and output streams.
static const int kDefaultSampleRate = 48000;

void AddDefaultDevice(AudioDeviceNames* device_names) {
  DCHECK(device_names->empty());
  device_names->push_front(AudioDeviceName::CreateDefault());
}

bool AudioManagerOpenBSD::HasAudioOutputDevices() {
  return true;
}

bool AudioManagerOpenBSD::HasAudioInputDevices() {
  return true;
}

void AudioManagerOpenBSD::ShowAudioInputSettings() {
  NOTIMPLEMENTED();
}

void AudioManagerOpenBSD::GetAudioInputDeviceNames(
    AudioDeviceNames* device_names) {
  DCHECK(device_names->empty());
  AddDefaultDevice(device_names);
}

void AudioManagerOpenBSD::GetAudioOutputDeviceNames(
    AudioDeviceNames* device_names) {
  AddDefaultDevice(device_names);
}

#if defined(USE_SNDIO)
const char* AudioManagerOpenBSD::GetName() {
  return "SNDIO";
}
#endif

AudioParameters AudioManagerOpenBSD::GetInputStreamParameters(
    const std::string& device_id) {
  static const int kDefaultInputBufferSize = 1024;

  int user_buffer_size = GetUserBufferSize();
  int buffer_size = user_buffer_size ?
      user_buffer_size : kDefaultInputBufferSize;

  return AudioParameters(
      AudioParameters::AUDIO_PCM_LOW_LATENCY, CHANNEL_LAYOUT_STEREO,
      kDefaultSampleRate, 16, buffer_size);
}

AudioManagerOpenBSD::AudioManagerOpenBSD(std::unique_ptr<AudioThread> audio_thread,
                                         AudioLogFactory* audio_log_factory)
    : AudioManagerBase(std::move(audio_thread),
                       audio_log_factory) {
  DLOG(WARNING) << "AudioManagerOpenBSD";
  SetMaxOutputStreamsAllowed(kMaxOutputStreams);
}

AudioManagerOpenBSD::~AudioManagerOpenBSD() {
  Shutdown();
}

AudioOutputStream* AudioManagerOpenBSD::MakeLinearOutputStream(
    const AudioParameters& params,
    const LogCallback& log_callback) {
  DCHECK_EQ(AudioParameters::AUDIO_PCM_LINEAR, params.format());
  return MakeOutputStream(params);
}

AudioOutputStream* AudioManagerOpenBSD::MakeLowLatencyOutputStream(
    const AudioParameters& params,
    const std::string& device_id,
    const LogCallback& log_callback) {
  DLOG_IF(ERROR, !device_id.empty()) << "Not implemented!";
  DCHECK_EQ(AudioParameters::AUDIO_PCM_LOW_LATENCY, params.format());
  return MakeOutputStream(params);
}

AudioInputStream* AudioManagerOpenBSD::MakeLinearInputStream(
    const AudioParameters& params,
    const std::string& device_id,
    const LogCallback& log_callback) {
  DCHECK_EQ(AudioParameters::AUDIO_PCM_LINEAR, params.format());
  return MakeInputStream(params);
}

AudioInputStream* AudioManagerOpenBSD::MakeLowLatencyInputStream(
    const AudioParameters& params,
    const std::string& device_id,
    const LogCallback& log_callback) {
  DCHECK_EQ(AudioParameters::AUDIO_PCM_LOW_LATENCY, params.format());
  return MakeInputStream(params);
}

AudioParameters AudioManagerOpenBSD::GetPreferredOutputStreamParameters(
    const std::string& output_device_id,
    const AudioParameters& input_params) {
  // TODO(tommi): Support |output_device_id|.
  DLOG_IF(ERROR, !output_device_id.empty()) << "Not implemented!";
  static const int kDefaultOutputBufferSize = 2048;

  ChannelLayout channel_layout = CHANNEL_LAYOUT_STEREO;
  int sample_rate = kDefaultSampleRate;
  int buffer_size = kDefaultOutputBufferSize;
  int bits_per_sample = 16;
  if (input_params.IsValid()) {
    sample_rate = input_params.sample_rate();
    bits_per_sample = input_params.bits_per_sample();
    channel_layout = input_params.channel_layout();
    buffer_size = std::min(buffer_size, input_params.frames_per_buffer());
  }

  int user_buffer_size = GetUserBufferSize();
  if (user_buffer_size)
    buffer_size = user_buffer_size;

  return AudioParameters(
      AudioParameters::AUDIO_PCM_LOW_LATENCY, channel_layout,
      sample_rate, bits_per_sample, buffer_size);
}

AudioInputStream* AudioManagerOpenBSD::MakeInputStream(
    const AudioParameters& params) {
  DLOG(WARNING) << "MakeInputStream";
  return new SndioAudioInputStream(this,
             AudioDeviceDescription::kDefaultDeviceId, params);
}

AudioOutputStream* AudioManagerOpenBSD::MakeOutputStream(
    const AudioParameters& params) {
  DLOG(WARNING) << "MakeOutputStream";
  return new SndioAudioOutputStream(params, this);
}
#endif

std::unique_ptr<media::AudioManager> CreateAudioManager(
    std::unique_ptr<AudioThread> audio_thread,
    AudioLogFactory* audio_log_factory) {
  DLOG(WARNING) << "CreateAudioManager";
#if defined(USE_SNDIO)
  UMA_HISTOGRAM_ENUMERATION("Media.OpenBSDAudioIO", kSndio, kAudioIOMax + 1);
  return base::MakeUnique<AudioManagerOpenBSD>(std::move(audio_thread),
                                            audio_log_factory);
#else
  return base::MakeUnique<FakeAudioManager>(std::move(audio_thread),
                                            audio_log_factory);
#endif

}

}  // namespace media
@


1.6
log
@update to 57.0.2987.98
@
text
@d6 1
a11 3
#if defined(USE_PULSEAUDIO)
#include "media/audio/pulse/audio_manager_pulse.h"
#endif
d83 3
a85 6
AudioManagerOpenBSD::AudioManagerOpenBSD(
    scoped_refptr<base::SingleThreadTaskRunner> task_runner,
    scoped_refptr<base::SingleThreadTaskRunner> worker_task_runner,
    AudioLogFactory* audio_log_factory)
    : AudioManagerBase(std::move(task_runner),
                       std::move(worker_task_runner),
d168 2
a169 3
ScopedAudioManagerPtr CreateAudioManager(
    scoped_refptr<base::SingleThreadTaskRunner> task_runner,
    scoped_refptr<base::SingleThreadTaskRunner> worker_task_runner,
a171 14
#if defined(USE_PULSEAUDIO)
  // Do not move task runners when creating AudioManagerPulse.
  // If the creation fails, we need to use the task runners to create other
  // AudioManager implementations.
  std::unique_ptr<AudioManagerPulse, AudioManagerDeleter> manager(
      new AudioManagerPulse(task_runner, worker_task_runner,
                            audio_log_factory));
  if (manager->Init()) {
    UMA_HISTOGRAM_ENUMERATION("Media.OpenBSDAudioIO", kPulse, kAudioIOMax + 1);
    return std::move(manager);
  }
  DVLOG(1) << "PulseAudio is not available on the OS";
#endif

d174 2
a175 3
  return ScopedAudioManagerPtr(
      new AudioManagerOpenBSD(std::move(task_runner),
                              std::move(worker_task_runner),audio_log_factory));
d177 2
a178 3
  return ScopedAudioManagerPtr(
      new FakeAudioManager(std::move(task_runner),
                           std::move(worker_task_runner), audio_log_factory));
@


1.5
log
@update to 55.0.2883.75; add lpr support to the system dialog while here
@
text
@d5 1
a5 1
#include "base/metrics/histogram.h"
d65 6
@


1.4
log
@update to 53.0.2785.89
@
text
@d5 2
d11 4
d17 3
d25 7
d165 1
d172 16
d191 6
@


1.3
log
@update to 52.0.2743.82
@
text
@d79 2
a80 1
    const AudioParameters& params) {
d87 2
a88 1
    const std::string& device_id) {
d95 3
a97 1
    const AudioParameters& params, const std::string& device_id) {
d103 3
a105 1
    const AudioParameters& params, const std::string& device_id) {
@


1.2
log
@enable webrtc support and fix video recording. the only thing
that's missing from working video conferencing is the sndio
input support, which is being worked on
@
text
@d7 1
d24 1
a24 2
  device_names->push_front(AudioDeviceName(AudioManager::GetDefaultDeviceName(),
                                           AudioManagerBase::kDefaultDeviceId));
d63 7
a69 2
AudioManagerOpenBSD::AudioManagerOpenBSD(AudioLogFactory* audio_log_factory)
    : AudioManagerBase(audio_log_factory) {
d135 1
a135 1
             AudioManagerBase::kDefaultDeviceId, params);
d144 4
a147 3
// TODO(xians): Merge AudioManagerOpenBSD with AudioManagerPulse;
// static
AudioManager* CreateAudioManager(AudioLogFactory* audio_log_factory) {
d149 3
a151 1
  return new AudioManagerOpenBSD(audio_log_factory);
@


1.1
log
@update to 47.0.2526.73
@
text
@d8 1
d21 6
d32 16
a47 1
  return false;
d90 1
a90 2
  NOTIMPLEMENTED();
  return NULL;
d96 1
a96 2
  NOTIMPLEMENTED();
  return NULL;
d124 7
@

