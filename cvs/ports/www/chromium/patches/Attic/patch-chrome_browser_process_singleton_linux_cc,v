head	1.6;
access;
symbols
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2011.10.27.07.59.08;	author robert;	state dead;
branches;
next	1.5;

1.5
date	2011.08.16.08.17.44;	author robert;	state Exp;
branches;
next	1.4;

1.4
date	2011.03.16.10.52.46;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2011.03.15.11.38.05;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2011.03.02.08.53.51;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2011.02.08.09.43.02;	author espie;	state Exp;
branches;
next	;


desc
@@


1.6
log
@update to 15.0.874.102.

switch from using the hacked macosx transport dib to the linux one
which uses sysv shms.
make sure you also have a current kernel before using this version
@
text
@$OpenBSD: patch-chrome_browser_process_singleton_linux_cc,v 1.5 2011/08/16 08:17:44 robert Exp $
--- chrome/browser/process_singleton_linux.cc.orig	Wed Jul 27 10:01:52 2011
+++ chrome/browser/process_singleton_linux.cc	Tue Aug  2 20:12:17 2011
@@@@ -55,6 +55,13 @@@@
 #include <set>
 #include <string>
 
+#if defined(OS_OPENBSD)
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <kvm.h>
+#include <libgen.h>
+#endif
+
 #include "base/base_paths.h"
 #include "base/basictypes.h"
 #include "base/command_line.h"
@@@@ -315,10 +322,42 @@@@ void DisplayProfileInUseError(const std::string& lock_
 }
 
 bool IsChromeProcess(pid_t pid) {
+#if defined(OS_OPENBSD)
+  int i, nproc;
+  struct kinfo_proc *plist, *kp;
+  char buf[_POSIX2_LINE_MAX], **pargv;
+  char *p;
+  kvm_t *kd;
+
+  if ((kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, buf)) == NULL) {
+    LOG(ERROR) << "kvm_openfiles(): failed";
+    return false;
+  }
+
+  plist = kvm_getproc2(kd, KERN_PROC_PID, pid, sizeof(*plist), &nproc);
+  CHECK(plist != NULL);
+
+  for (i = 0, kp = plist; i < nproc; i++, kp++) {
+    if ((kp->p_flag & P_SYSTEM) != 0)
+      continue;
+    if ((pargv = kvm_getargv2(kd, kp, 0)) == NULL)
+      continue;
+    p = basename(pargv[0]);
+    if (!strcmp(p, "chrome")) {
+      LOG(ERROR) << pid << " is chrome";
+      kvm_close(kd);
+      return true;
+    }
+  }
+
+  kvm_close(kd);
+  return false;
+#else
   FilePath other_chrome_path(base::GetProcessExecutablePath(pid));
   return (!other_chrome_path.empty() &&
           other_chrome_path.BaseName() ==
           FilePath(chrome::kBrowserProcessExecutableName));
+#endif
 }
 
 // Return true if the given pid is one of our child processes.
@


1.5
log
@update to the next stable release (13.0.782.112)
@
text
@d1 1
a1 1
$OpenBSD: patch-chrome_browser_process_singleton_linux_cc,v 1.4 2011/03/16 10:52:46 robert Exp $
@


1.4
log
@Add some missing patches that were missed by the previous commit
and move back to KERN_PROC from KERN_PROC2 now that we can.
@
text
@d1 3
a3 3
$OpenBSD: patch-chrome_browser_process_singleton_linux_cc,v 1.3 2011/03/15 11:38:05 robert Exp $
--- chrome/browser/process_singleton_linux.cc.orig	Fri Mar 11 10:01:43 2011
+++ chrome/browser/process_singleton_linux.cc	Wed Mar 16 10:25:55 2011
d18 1
a18 1
@@@@ -314,10 +321,42 @@@@ void DisplayProfileInUseError(const std::string& lock_
@


1.3
log
@update to 10.0.648.133
@
text
@d1 3
a3 3
$OpenBSD$
--- chrome/browser/process_singleton_linux.cc.orig	Mon Mar 14 11:33:39 2011
+++ chrome/browser/process_singleton_linux.cc	Mon Mar 14 11:35:56 2011
d24 1
a24 1
+  struct kinfo_proc2 *plist, *kp;
@


1.2
log
@Use KERN_PROC2 everywhere instead of trying to use /proc and use
kvm(3) to help chrome identify it's own processes.
@
text
@d1 4
a4 4
$OpenBSD: patch-chrome_browser_process_singleton_linux_cc,v 1.1 2011/02/08 09:43:02 espie Exp $
--- chrome/browser/process_singleton_linux.cc.orig	Mon Feb  7 10:43:42 2011
+++ chrome/browser/process_singleton_linux.cc	Wed Feb 23 23:21:37 2011
@@@@ -54,6 +54,13 @@@@
a14 1
 #include "app/l10n_util.h"
d17 2
a18 1
@@@@ -325,10 +332,42 @@@@ void DisplayProfileInUseError(const std::string& lock_
d22 1
a22 6
+#if defined(OS_LINUX)
   FilePath other_chrome_path(base::GetProcessExecutablePath(pid));
   return (!other_chrome_path.empty() &&
           other_chrome_path.BaseName() ==
           FilePath::FromWStringHack(chrome::kBrowserProcessExecutableName));
+#elif defined(OS_OPENBSD)
d52 5
@


1.1
log
@late update to chromium 9, robert@@ did the work, but he doesn't have the
time right now.
Tree is still locked!
Reasons for the update:
- good work that can be used now
- only builds on i386/amd64, and they're fast
- multiple security problems in old chrome
- old chrome half working, can't break it more than it was.

This one requires resources (see MESSAGE), but it's ways more stable.

Again, discussed with sthen@@, jasper@@, naddy@@, miod@@
@
text
@d1 18
a18 4
$OpenBSD$
--- chrome/browser/process_singleton_linux.cc.orig	Fri Jan 21 10:20:26 2011
+++ chrome/browser/process_singleton_linux.cc	Sun Jan 23 23:27:31 2011
@@@@ -325,23 +325,24 @@@@ void DisplayProfileInUseError(const std::string& lock_
d22 2
a23 2
-  FilePath other_chrome_path(base::GetProcessExecutablePath(pid));
+/*  FilePath other_chrome_path(base::GetProcessExecutablePath(pid));
d26 32
a57 3
-          FilePath::FromWStringHack(chrome::kBrowserProcessExecutableName));
+          FilePath::FromWStringHack(chrome::kBrowserProcessExecutableName));*/
+  return true;
a60 15
 // Assumes that the current pid is the root of all pids of the current instance.
 bool IsSameChromeInstance(pid_t pid) {
   pid_t cur_pid = base::GetCurrentProcId();
-  while (pid != cur_pid) {
+/*  while (pid != cur_pid) {
     pid = base::GetParentProcessId(pid);
     if (pid < 0)
       return false;
     if (!IsChromeProcess(pid))
       return false;
-  }
+  }*/
   return true;
 }
 
@

