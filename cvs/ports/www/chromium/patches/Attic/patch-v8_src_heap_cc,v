head	1.9;
access;
symbols
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4;
locks; strict;
comment	@# @;


1.9
date	2012.02.17.10.19.51;	author robert;	state dead;
branches;
next	1.8;

1.8
date	2011.12.14.16.58.19;	author robert;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.27.07.59.09;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.19.08.55.26;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2011.08.16.08.17.44;	author robert;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.08.20.36.56;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.02.07.22.12;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.31.07.55.04;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.17.08.35.31;	author robert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@update to 17.0.963.56
@
text
@$OpenBSD: patch-v8_src_heap_cc,v 1.8 2011/12/14 16:58:19 robert Exp $
--- v8/src/heap.cc.orig	Wed Dec  7 09:04:42 2011
+++ v8/src/heap.cc	Tue Dec 13 21:23:12 2011
@@@@ -5025,6 +5025,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
   initial_semispace_size_ = Min(initial_semispace_size_, max_semispace_size_);
   external_allocation_limit_ = 10 * max_semispace_size_;
 
+  intptr_t max_virtual = OS::MaxVirtualMemory();
+
+  if (max_virtual > 0) {
+    intptr_t half = max_virtual >> 1;
+    intptr_t quarter = max_virtual >> 2;
+    // If we have limits on the amount of virtual memory we can use then we may
+    // be forced to lower the allocation limits.  We reserve one quarter of the
+    // memory for young space and off-heap data.  The rest is distributed as
+    // described below.
+    if (code_range_size_ > 0) {
+      // Reserve a quarter of the memory for the code range.  The old space
+      // heap gets the remaining half.  There is some unavoidable double
+      // counting going on here since the heap size is measured in committed
+      // virtual memory and the code range is only reserved virtual memory.
+      code_range_size_ = Min(code_range_size_, quarter);
+      max_old_generation_size_ = Min(max_old_generation_size_, half);
+    } else {
+      // Reserve three quarters of the memory for the old space heap including
+      // the executable code.
+      max_old_generation_size_ = Min(max_old_generation_size_, half + quarter);
+    }
+  }
+
   // The old generation is paged.
   max_old_generation_size_ = RoundUp(max_old_generation_size_, Page::kPageSize);
 
@


1.8
log
@update to 16.0.912.63
@
text
@d1 1
a1 1
$OpenBSD: patch-v8_src_heap_cc,v 1.7 2011/10/27 07:59:09 robert Exp $
@


1.7
log
@update to 15.0.874.102.

switch from using the hacked macosx transport dib to the linux one
which uses sysv shms.
make sure you also have a current kernel before using this version
@
text
@d1 4
a4 4
$OpenBSD: patch-v8_src_heap_cc,v 1.6 2011/09/19 08:55:26 robert Exp $
--- v8/src/heap.cc.orig	Fri Oct 21 10:49:34 2011
+++ v8/src/heap.cc	Wed Oct 26 13:37:47 2011
@@@@ -4896,6 +4896,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
@


1.6
log
@update to 14.0.835.163
@
text
@d1 4
a4 4
$OpenBSD: patch-v8_src_heap_cc,v 1.5 2011/08/16 08:17:44 robert Exp $
--- v8/src/heap.cc.orig	Wed Sep 14 10:19:54 2011
+++ v8/src/heap.cc	Fri Sep 16 18:17:25 2011
@@@@ -4775,6 +4775,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
@


1.5
log
@update to the next stable release (13.0.782.112)
@
text
@d1 4
a4 4
$OpenBSD: patch-v8_src_heap_cc,v 1.4 2011/06/08 20:36:56 robert Exp $
--- v8/src/heap.cc.orig	Wed Jul 27 10:18:22 2011
+++ v8/src/heap.cc	Tue Aug  2 20:12:21 2011
@@@@ -4642,6 +4642,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
@


1.4
log
@Update to the new stable branch: 12.0.742.91
http://googlechromereleases.blogspot.com/2011/06/chrome-stable-release.html
@
text
@d1 4
a4 4
$OpenBSD: patch-v8_src_heap_cc,v 1.3 2011/06/02 07:22:12 robert Exp $
--- v8/src/heap.cc.orig	Mon Jun  6 11:43:03 2011
+++ v8/src/heap.cc	Wed Jun  8 09:58:37 2011
@@@@ -4573,6 +4573,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
@


1.3
log
@Instead of reserving 32MB of virtual memory let's reserve the quarter of
RLIMIT_DATA (ulimit -d) if RLIMIT_DATA is not 0 (unlimited).
If RLIMIT_DATA is 0 then the default 512MB reservation will be used.
Using 32MB made v8 use less memory for sure but it was a huge performance
loss too.
@
text
@d1 4
a4 4
$OpenBSD: patch-v8_src_heap_cc,v 1.2 2011/05/31 07:55:04 robert Exp $
--- v8/src/heap.cc.orig	Fri May 20 10:56:51 2011
+++ v8/src/heap.cc	Wed Jun  1 13:43:18 2011
@@@@ -4503,6 +4503,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
@


1.2
log
@Make v8 pre-allocate at least 32M of virtual memory to avoid
crashing with vmmap. This is needed because of their JIT is
not fully 64-bit.
@
text
@d1 1
a1 1
$OpenBSD: patch-v8_src_heap_cc,v 1.1 2011/05/17 08:35:31 robert Exp $
d3 31
a33 10
+++ v8/src/heap.cc	Mon May 30 23:09:01 2011
@@@@ -91,7 +91,7 @@@@ intptr_t Heap::max_executable_size_ = max_old_generati
 static const int default_max_semispace_size_  = 16*MB;
 intptr_t Heap::max_old_generation_size_ = 1*GB;
 int Heap::initial_semispace_size_ = 1*MB;
-intptr_t Heap::code_range_size_ = 512*MB;
+intptr_t Heap::code_range_size_ = 32*MB;
 intptr_t Heap::max_executable_size_ = 256*MB;
 #else
 static const int default_max_semispace_size_  = 8*MB;
@


1.1
log
@- use the same memory allocation values on amd64 and i386 too.
  this makes chrome use way less memory and since it does not hit
  datasize limits anymore, it is way more stable too
- remove the warning of datasize bumping from the wrapper script

tested by sthen@@, jasper@@ and me
@
text
@d1 4
a4 9
$OpenBSD$
--- v8/src/heap.cc.orig	Mon May 16 17:04:03 2011
+++ v8/src/heap.cc	Mon May 16 17:07:18 2011
@@@@ -87,7 +87,7 @@@@ intptr_t Heap::max_old_generation_size_ = 192*MB;
 int Heap::initial_semispace_size_ = 128*KB;
 intptr_t Heap::code_range_size_ = 0;
 intptr_t Heap::max_executable_size_ = max_old_generation_size_;
-#elif defined(V8_TARGET_ARCH_X64)
+#elif defined(V8_TARGET_ARCH_X64) && !defined(__OpenBSD__)
d8 5
@

