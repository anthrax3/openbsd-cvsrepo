head	1.4;
access;
symbols
	OPENBSD_6_1:1.3.0.2
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.2
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.4
	OPENBSD_5_8_BASE:1.1.1.1
	robert_20150503:1.1.1.1
	robert:1.1.1;
locks; strict;
comment	@// @;


1.4
date	2017.04.19.05.16.46;	author robert;	state Exp;
branches;
next	1.3;
commitid	jpW2BiKwA9H7U7d6;

1.3
date	2016.10.27.18.30.40;	author robert;	state Exp;
branches;
next	1.2;
commitid	lED1Oks5HVh03mCa;

1.2
date	2016.03.23.20.13.06;	author robert;	state Exp;
branches;
next	1.1;
commitid	2hNT21XsdisESysQ;

1.1
date	2015.05.03.15.35.35;	author robert;	state Exp;
branches
	1.1.1.1;
next	;
commitid	O1GeKHU5BcsYea8a;

1.1.1.1
date	2015.05.03.15.35.35;	author robert;	state Exp;
branches;
next	;
commitid	O1GeKHU5BcsYea8a;


desc
@@


1.4
log
@update to 57.0
@
text
@// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/logging.h"
#include "base/time/time.h"
#include "base/time/default_tick_clock.h"
#include "media/audio/audio_manager_base.h"
#include "media/base/audio_timestamp_helper.h"
#include "media/audio/sndio/sndio_output.h"

namespace media {

void sndio_onmove(void *arg, int delta) {
  SndioAudioOutputStream* self = static_cast<SndioAudioOutputStream*>(arg);

  self->hw_delay = delta;
}

void sndio_onvol(void *arg, unsigned int vol) {
  SndioAudioOutputStream* self = static_cast<SndioAudioOutputStream*>(arg);

  self->vol = vol;
}

void *sndio_threadstart(void *arg) {
  SndioAudioOutputStream* self = static_cast<SndioAudioOutputStream*>(arg);

  self->RealTimeThread();
  return NULL;
}

SndioAudioOutputStream::SndioAudioOutputStream(const AudioParameters& params,
                                               AudioManagerBase* manager)
    : manager(manager),
      params(params),
      audio_bus(AudioBus::Create(params)),
      bytes_per_frame(params.GetBytesPerFrame()),
      state(kClosed),
      mutex(PTHREAD_MUTEX_INITIALIZER) {
}

SndioAudioOutputStream::~SndioAudioOutputStream() {
  if (state != kClosed)
    Close();
}

bool SndioAudioOutputStream::Open() {
  struct sio_par par;
  int sig;

  if (params.format() != AudioParameters::AUDIO_PCM_LINEAR &&
      params.format() != AudioParameters::AUDIO_PCM_LOW_LATENCY) {
    LOG(WARNING) << "Unsupported audio format.";
    return false;
  }
  sio_initpar(&par);
  par.rate = params.sample_rate();
  par.pchan = params.channels();
  par.bits = params.bits_per_sample();
  par.bps = par.bits / 8;
  par.sig = sig = par.bits != 8 ? 1 : 0;
  par.le = SIO_LE_NATIVE;
  par.appbufsz = params.frames_per_buffer();

  hdl = sio_open(SIO_DEVANY, SIO_PLAY, 0);
  if (hdl == NULL) {
    LOG(ERROR) << "Couldn't open audio device.";
    return false;
  }
  if (!sio_setpar(hdl, &par) || !sio_getpar(hdl, &par)) {
    LOG(ERROR) << "Couldn't set audio parameters.";
    goto bad_close;
  }
  if (par.rate  != (unsigned int)params.sample_rate() ||
      par.pchan != (unsigned int)params.channels() ||
      par.bits  != (unsigned int)params.bits_per_sample() ||
      par.sig   != (unsigned int)sig ||
      (par.bps > 1 && par.le != SIO_LE_NATIVE) ||
      (par.bits != par.bps * 8)) {
    LOG(ERROR) << "Unsupported audio parameters.";
    goto bad_close;
  }
  state = kStopped;
  volpending = 0;
  vol = 0;
  buffer = new char[audio_bus->frames() * params.GetBytesPerFrame()];
  sio_onmove(hdl, sndio_onmove, this);
  sio_onvol(hdl, sndio_onvol, this);
  return true;
 bad_close:
  sio_close(hdl);
  return false;
}

void SndioAudioOutputStream::Close() {
  if (state == kClosed)
    return;
  if (state == kRunning)
    Stop();
  state = kClosed;
  delete [] buffer;
  sio_close(hdl);
  manager->ReleaseOutputStream(this);  // Calls the destructor
}

void SndioAudioOutputStream::Start(AudioSourceCallback* callback) {
  state = kRunning;
  hw_delay = 0;
  source = callback;
  sio_start(hdl);
  if (pthread_create(&thread, NULL, sndio_threadstart, this) != 0) {
    LOG(ERROR) << "Failed to create real-time thread.";
    sio_stop(hdl);
    state = kStopped;
  }
}

void SndioAudioOutputStream::Stop() {
  if (state == kStopped)
    return;
  state = kStopWait;
  pthread_join(thread, NULL);
  sio_stop(hdl);
  state = kStopped;
}

void SndioAudioOutputStream::SetVolume(double v) {
  pthread_mutex_lock(&mutex);
  vol = v * SIO_MAXVOL;
  volpending = 1;
  pthread_mutex_unlock(&mutex);
}

void SndioAudioOutputStream::GetVolume(double* v) {
  pthread_mutex_lock(&mutex);
  *v = vol * (1. / SIO_MAXVOL);
  pthread_mutex_unlock(&mutex);
}

void SndioAudioOutputStream::RealTimeThread(void) {
  int avail, count;

  while (state == kRunning) {
    // Update volume if needed
    pthread_mutex_lock(&mutex);
    if (volpending) {
      volpending = 0;
      sio_setvol(hdl, vol);
    }
    pthread_mutex_unlock(&mutex);

    // Get data to play
    const base::TimeDelta delay = AudioTimestampHelper::FramesToTime(hw_delay, params.sample_rate() * 1000);
    count = source->OnMoreData(delay, base::TimeTicks::Now(), 0, audio_bus.get());
    audio_bus->ToInterleaved(count, params.bits_per_sample() / 8, buffer);
    if (count == 0) {
      // We have to submit something to the device
      count = audio_bus->frames();
      memset(buffer, 0, count * params.GetBytesPerFrame());
      LOG(WARNING) << "No data to play, running empty cycle.";
    }

    // Submit data to the device
    avail = count * params.GetBytesPerFrame();
    count = sio_write(hdl, buffer, avail);
    if (count == 0) {
      LOG(WARNING) << "Audio device disconnected.";
      break;
    }

    // Update hardware pointer
    hw_delay += count;
  }
}

}  // namespace media
@


1.3
log
@update to 54.0
@
text
@d6 2
d9 1
d17 1
a17 1
  self->hw_delay = delta * self->params.GetBytesPerFrame();
d38 1
d154 2
a155 1
    count = source->OnMoreData(audio_bus.get(), hw_delay, 0);
@


1.2
log
@update to 49.0
@
text
@a5 1
#include "media/audio/audio_parameters.h"
@


1.1
log
@Initial revision
@
text
@d151 1
a151 1
    count = source->OnMoreData(audio_bus.get(), hw_delay);
@


1.1.1.1
log
@import of iridium-41.2:

Iridium is a free, open, and libre browser modification of the Chromium code base,
with privacy being enhanced in several key areas.
Automatic transmission of partial queries, keywords, metrics to central services
inhibited and only occurs with consent.
In addition, all our builds are reproducible, and modifications are auditable,
setting the project ahead of other secure browser providers.

For more information, visit: https://iridiumbrowser.de/about

ok ajacoutot@@
@
text
@@
