head	1.30;
access;
symbols
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.8.0.2
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_1:1.1.0.2
	OPENBSD_4_1_BASE:1.1;
locks; strict;
comment	@# @;


1.30
date	2016.11.11.10.23.34;	author sthen;	state dead;
branches;
next	1.29;
commitid	zcSafSSsrSci3osM;

1.29
date	2016.10.12.08.09.26;	author ajacoutot;	state Exp;
branches;
next	1.28;
commitid	RcsywKx0OmgVaY4K;

1.28
date	2016.09.17.20.22.41;	author ajacoutot;	state Exp;
branches;
next	1.27;
commitid	erqZjU8459iZzz15;

1.27
date	2015.12.08.06.59.44;	author ajacoutot;	state dead;
branches;
next	1.26;
commitid	CxDtNHd2uVCvIZNk;

1.26
date	2015.10.14.05.33.02;	author ajacoutot;	state Exp;
branches;
next	1.25;
commitid	vwkHDQ3nBut4c3t7;

1.25
date	2015.09.25.06.17.15;	author ajacoutot;	state Exp;
branches;
next	1.24;
commitid	hQ3MC4sMrBFcmKQQ;

1.24
date	2013.09.30.19.26.04;	author brad;	state dead;
branches;
next	1.23;

1.23
date	2013.03.28.16.22.32;	author brad;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2012.11.21.21.58.18;	author sthen;	state dead;
branches;
next	1.21;

1.21
date	2012.11.15.10.46.58;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.13.23.02.15;	author sthen;	state dead;
branches;
next	1.19;

1.19
date	2011.12.20.22.27.28;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.03.22.26.08;	author sthen;	state Exp;
branches;
next	1.17;

1.17
date	2011.10.09.20.42.33;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2011.09.06.08.49.51;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2011.08.24.21.28.09;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.21.09.56.55;	author sthen;	state dead;
branches;
next	1.13;

1.13
date	2010.02.02.08.10.29;	author sthen;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2009.12.13.22.06.24;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.25.23.06.53;	author sthen;	state dead;
branches;
next	1.10;

1.10
date	2009.11.08.13.16.40;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.02.11;	author sthen;	state dead;
branches;
next	1.8;

1.8
date	2009.06.22.09.28.07;	author sthen;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2008.10.23.20.29.17;	author brad;	state dead;
branches;
next	1.6;

1.6
date	2008.04.08.19.11.40;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.03.10.18.15;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2007.07.25.21.31.46;	author rui;	state dead;
branches;
next	1.3;

1.3
date	2007.07.22.19.44.17;	author rui;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.28.10.08.01;	author rui;	state dead;
branches;
next	1.1;

1.1
date	2007.02.02.09.25.19;	author bernd;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2007.07.29.19.00.56;	author sturm;	state dead;
branches;
next	;

1.8.2.1
date	2009.12.05.22.43.33;	author william;	state dead;
branches;
next	1.8.2.2;

1.8.2.2
date	2009.12.18.02.14.32;	author william;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2010.02.02.13.58.53;	author sthen;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2010.04.29.01.37.22;	author william;	state dead;
branches;
next	;

1.13.2.1
date	2010.06.12.14.43.07;	author william;	state dead;
branches;
next	;

1.23.2.1
date	2013.11.22.08.42.13;	author jasper;	state dead;
branches;
next	;


desc
@@


1.30
log
@update to lighttpd-1.4.43, from Brad
@
text
@$OpenBSD: patch-src_connections_c,v 1.29 2016/10/12 08:09:26 ajacoutot Exp $

- [core] check if client half-closed TCP if POLLHUP (#2743)
- performance: use Linux extended syscalls and flags

--- src/connections.c.orig	Mon Oct 10 18:05:17 2016
+++ src/connections.c	Mon Oct 10 18:04:38 2016
@@@@ -140,14 +140,11 @@@@ static int connection_close(server *srv, connection *c
 				"(warning) close:", con->fd, strerror(errno));
 	}
 #endif
-	con->fd = -1;
+	else {
+		srv->cur_fds--;
+	}
 
-	srv->cur_fds--;
-#if 0
-	log_error_write(srv, __FILE__, __LINE__, "sd",
-			"closed()", con->fd);
-#endif
-
+	con->fd = -1;
 	connection_del(srv, con);
 	connection_set_state(srv, con, CON_STATE_CONNECT);
 
@@@@ -943,43 +940,6 @@@@ static handler_t connection_handle_fdevent(server *srv
 	}
 
 
-	if (revents & ~(FDEVENT_IN | FDEVENT_OUT)) {
-		/* looks like an error */
-
-		/* FIXME: revents = 0x19 still means that we should read from the queue */
-		if (revents & FDEVENT_HUP) {
-			if (con->state == CON_STATE_CLOSE) {
-				con->close_timeout_ts = srv->cur_ts - (HTTP_LINGER_TIMEOUT+1);
-			} else {
-				/* sigio reports the wrong event here
-				 *
-				 * there was no HUP at all
-				 */
-#ifdef USE_LINUX_SIGIO
-				if (srv->ev->in_sigio == 1) {
-					log_error_write(srv, __FILE__, __LINE__, "sd",
-						"connection closed: poll() -> HUP", con->fd);
-				} else {
-					connection_set_state(srv, con, CON_STATE_ERROR);
-				}
-#else
-				connection_set_state(srv, con, CON_STATE_ERROR);
-#endif
-
-			}
-		} else if (revents & FDEVENT_ERR) {
-			/* error, connection reset, whatever... we don't want to spam the logfile */
-#if 0
-			log_error_write(srv, __FILE__, __LINE__, "sd",
-					"connection closed: poll() -> ERR", con->fd);
-#endif
-			connection_set_state(srv, con, CON_STATE_ERROR);
-		} else {
-			log_error_write(srv, __FILE__, __LINE__, "sd",
-					"connection closed: poll() -> ???", revents);
-		}
-	}
-
 	if (con->state == CON_STATE_READ) {
 		connection_handle_read_state(srv, con);
 	}
@@@@ -1008,6 +968,27 @@@@ static handler_t connection_handle_fdevent(server *srv
 		}
 	}
 
+
+	/* attempt (above) to read data in kernel socket buffers
+	 * prior to handling FDEVENT_HUP and FDEVENT_ERR */
+
+	if ((revents & ~(FDEVENT_IN | FDEVENT_OUT)) && con->state != CON_STATE_ERROR) {
+		if (con->state == CON_STATE_CLOSE) {
+			con->close_timeout_ts = srv->cur_ts - (HTTP_LINGER_TIMEOUT+1);
+		} else if (revents & FDEVENT_HUP) {
+			if (fdevent_is_tcp_half_closed(con->fd)) {
+				con->keep_alive = 0;
+			} else {
+				connection_set_state(srv, con, CON_STATE_ERROR);
+			}
+		} else if (revents & FDEVENT_ERR) { /* error, connection reset */
+			connection_set_state(srv, con, CON_STATE_ERROR);
+		} else {
+			log_error_write(srv, __FILE__, __LINE__, "sd",
+					"connection closed: poll() -> ???", revents);
+		}
+	}
+
 	return HANDLER_FINISHED;
 }
 
@@@@ -1033,7 +1014,12 @@@@ connection *connection_accept(server *srv, server_sock
 
 	cnt_len = sizeof(cnt_addr);
 
-	if (-1 == (cnt = accept(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len))) {
+#if defined(SOCK_CLOEXEC) && defined(SOCK_NONBLOCK)
+	cnt = accept4(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len, SOCK_CLOEXEC | SOCK_NONBLOCK);
+#else
+	cnt = accept(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len);
+#endif
+	if (-1 == cnt) {
 		switch (errno) {
 		case EAGAIN:
 #if EWOULDBLOCK != EAGAIN
@@@@ -1084,8 +1070,9 @@@@ connection *connection_accepted(server *srv, server_so
 		buffer_copy_string(con->dst_addr_buf, inet_ntop_cache_get_ip(srv, &(con->dst_addr)));
 		con->srv_socket = srv_socket;
 
-		if (-1 == (fdevent_fcntl_set(srv->ev, con->fd))) {
+		if (-1 == fdevent_fcntl_set_nb_cloexec_sock(srv->ev, con->fd)) {
 			log_error_write(srv, __FILE__, __LINE__, "ss", "fcntl failed: ", strerror(errno));
+			connection_close(srv, con);
 			return NULL;
 		}
 #ifdef USE_OPENSSL
@@@@ -1095,6 +1082,7 @@@@ connection *connection_accepted(server *srv, server_so
 				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
 						ERR_error_string(ERR_get_error(), NULL));
 
+				connection_close(srv, con);
 				return NULL;
 			}
 
@@@@ -1105,6 +1093,7 @@@@ connection *connection_accepted(server *srv, server_so
 			if (1 != (SSL_set_fd(con->ssl, cnt))) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "SSL:",
 						ERR_error_string(ERR_get_error(), NULL));
+				connection_close(srv, con);
 				return NULL;
 			}
 		}
@


1.29
log
@Bring in a commit from upstream
- performance: use Linux extended syscalls and flags

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.28 2016/09/17 20:22:41 ajacoutot Exp $
@


1.28
log
@Update to lighttpd-1.4.41.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
[core] check if client half-closed TCP if POLLHUP (#2743)
d6 22
a27 3
--- src/connections.c.orig	Wed Sep 14 21:06:19 2016
+++ src/connections.c	Wed Sep 14 20:59:39 2016
@@@@ -943,43 +943,6 @@@@ static handler_t connection_handle_fdevent(server *srv
d71 4
a74 7
@@@@ -1005,6 +968,27 @@@@ static handler_t connection_handle_fdevent(server *srv
 		len = read(con->fd, buf, sizeof(buf));
 		if (len == 0 || (len < 0 && errno != EAGAIN && errno != EINTR) ) {
 			con->close_timeout_ts = srv->cur_ts - (HTTP_LINGER_TIMEOUT+1);
+		}
+	}
+
d93 29
d123 8
a130 1
 	}
d132 8
@


1.27
log
@Update to lighttpd-1.4.38.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.26 2015/10/14 05:33:02 ajacoutot Exp $
d3 1
a3 3
- [core] allocate at least 4k buffer for incoming data
- [core] fix search for header end if split across chunks (fixes #2670)
- [core] don't buffer request bodies smaller than 64k on disk
d5 3
a7 9
--- src/connections.c.orig	Sat Aug 29 08:22:38 2015
+++ src/connections.c	Tue Oct 13 17:31:54 2015
@@@@ -336,10 +336,11 @@@@ static int connection_handle_read(server *srv, connect
 	len = recv(con->fd, mem, mem_len, 0);
 #else /* __WIN32 */
 	if (ioctl(con->fd, FIONREAD, &toread) || toread == 0 || toread <= 4*1024) {
-		if (toread > MAX_READ_LIMIT) toread = MAX_READ_LIMIT;
-	} else {
 		toread = 4096;
a8 4
+	else if (toread > MAX_READ_LIMIT) {
+		toread = MAX_READ_LIMIT;
+	}
 	chunkqueue_get_memory(con->read_queue, &mem, &mem_len, 0, toread);
a9 2
 	len = read(con->fd, mem, mem_len);
@@@@ -931,7 +932,7 @@@@ static int connection_handle_read_state(server *srv, c
d11 67
a77 4
 					for ( ; cc; cc = cc->next, j = 0 ) {
 						size_t bblen = buffer_string_length(cc->mem) - cc->offset;
-						const char *bb = c->mem->ptr + cc->offset;
+						const char *bb = cc->mem->ptr + cc->offset;
a78 15
 						for ( ; j < bblen; j++) {
 							ch = bb[j];
@@@@ -982,7 +983,11 @@@@ found_header_end:
 		}
 		break;
 	case CON_STATE_READ_POST:
-		if (0 != chunkqueue_steal_with_tempfiles(srv, dst_cq, cq, con->request.content_length - dst_cq->bytes_in )) {
+		if (con->request.content_length <= 64*1024) {
+			/* don't buffer request bodies <= 64k on disk */
+			chunkqueue_steal(dst_cq, cq, con->request.content_length - dst_cq->bytes_in);
+		}
+		else if (0 != chunkqueue_steal_with_tempfiles(srv, dst_cq, cq, con->request.content_length - dst_cq->bytes_in )) {
 			con->http_status = 413; /* Request-Entity too large */
 			con->keep_alive = 0;
 			connection_set_state(srv, con, CON_STATE_HANDLE_REQUEST);
@


1.26
log
@Backport from upstream:
[core] don't buffer request bodies smaller than 64k on disk

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.25 2015/09/25 06:17:15 ajacoutot Exp $
@


1.25
log
@Back port some bug fixes.
- [core] allocate at least 4k buffer for incoming data
- [core] fix search for header end if split across chunks (fixes #2670)

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d5 1
d7 2
a8 2
--- src/connections.c.orig	Fri Sep 25 01:53:03 2015
+++ src/connections.c	Fri Sep 25 01:54:52 2015
d32 13
@


1.24
log
@Update to lighttpd 1.4.33.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.23 2013/03/28 16:22:32 brad Exp $
d3 2
a4 1
Call ERR_clear_error only for SSL connections in CON_STATE_ERROR.
d6 14
a19 10
--- src/connections.c.orig	Wed Mar 27 09:17:03 2013
+++ src/connections.c	Wed Mar 27 09:17:37 2013
@@@@ -1736,8 +1736,8 @@@@ int connection_state_machine(server *srv, connection *
 						break;
 					}
 				}
+				ERR_clear_error();
 			}
-			ERR_clear_error();
 #endif
d21 10
a30 1
 			switch(con->mode) {
@


1.23
log
@More fixes from upstream..

- Support multi line logging.
- Call ERR_clear_error only for SSL connections in CON_STATE_ERROR.
- Reject non ASCII characters in HTTP header names.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.23.2.1
log
@- update lighttpd to 1.4.33 and apply the security fixes for CVE-2013-4508

testing/ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.23 2013/03/28 16:22:32 brad Exp $
@


1.22
log
@security update to lighttpd 1.4.32, fixing a trivial DoS introduced in 1.4.31
http://download.lighttpd.net/lighttpd/security/lighttpd_sa_2012_01.txt

OK brad@@ (maintainer), same update from gsoares@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.21 2012/11/15 10:46:58 brad Exp $
d3 1
a3 1
Ignore EPIPE/ECONNRESET after SSL_shutdown.
d5 3
a7 29
--- src/connections.c.orig	Wed Nov  7 21:34:01 2012
+++ src/connections.c	Wed Nov  7 21:30:28 2012
@@@@ -1712,11 +1712,18 @@@@ int connection_state_machine(server *srv, connection *
 										ERR_error_string(err, NULL));
 							} while((err = ERR_get_error()));
 						} else if (errno != 0) { /* ssl bug (see lighttpd ticket #2213): sometimes errno == 0 */
-							log_error_write(srv, __FILE__, __LINE__, "sddds", "SSL (error):",
+							switch(errno) {
+							case EPIPE:
+							case ECONNRESET:
+								break;
+							default:
+								log_error_write(srv, __FILE__, __LINE__, "sddds", "SSL (error):",
 									ssl_r, ret, errno,
 									strerror(errno));
+								break;
+							}
 						}
-	
+
 						break;
 					default:
 						while((err = ERR_get_error())) {
@@@@ -1724,7 +1731,7 @@@@ int connection_state_machine(server *srv, connection *
 									ssl_r, ret,
 									ERR_error_string(err, NULL));
 						}
-	
+
d11 6
@


1.21
log
@More fixes from upstream..

- Fix :port handling in $HTTP["host"] checks.
- Ignore EPIPE/ECONNRESET after SSL_shutdown.
- Add PATCH method.
- Handle ENAMETOOLONG, return 404 Not Found.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.20
log
@updates to lighttpd from upstream svn, from Brad

- remove "let HEAD for 0-byte files return the Content-Length" patch,
there are some cases where this is undesirable

- fix handling if etags are disabled but cache-dir is set - may
lead to double response
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.19 2011/12/20 22:27:28 sthen Exp $
d3 1
a3 1
let HEAD for 0-byte files return the Content-Length
d5 31
a35 5
--- src/connections.c.orig	Wed Nov 30 12:42:45 2011
+++ src/connections.c	Tue Dec 20 16:33:10 2011
@@@@ -567,8 +567,10 @@@@ static int connection_handle_write_prepare(server *srv
 				if (NULL != (ds = (data_string*) array_get_element(con->response.headers, "Content-Length"))) {
 					buffer_reset(ds->value); /* Headers with empty values are ignored for output */
a36 9
-			} else if (qlen > 0 || con->request.http_method != HTTP_METHOD_HEAD) {
-				/* qlen = 0 is important for Redirects (301, ...) as they MAY have
+			} else if (qlen >= 0) {
+				/* the Content-Length header has to be >= 0 to be valid.
+				 *
+				 * qlen = 0 is important for Redirects (301, ...) as they MAY have
 				 * a content. Browsers are waiting for a Content otherwise
 				 */
 				buffer_copy_off_t(srv->tmp_buf, qlen);
@


1.19
log
@update to lighttpd 1.4.30, from Brad (maintainer).
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.18 2011/12/03 22:26:08 sthen Exp $
@


1.18
log
@ssl-related fixes from lighttpd upstream via Brad
- [ssl] count renegotiations to prevent client renegotiations
- [ssl] add option to honor server cipher order, true by default
@
text
@d1 7
a7 25
$OpenBSD: patch-src_connections_c,v 1.17 2011/10/09 20:42:33 sthen Exp $
--- src/connections.c.orig	Sun Apr 24 11:55:46 2011
+++ src/connections.c	Fri Dec  2 04:40:01 2011
@@@@ -223,6 +223,12 @@@@ static int connection_handle_read_ssl(server *srv, con
 
 		len = SSL_read(con->ssl, b->ptr + read_offset, toread);
 
+		if (con->renegotiations > 1 && con->conf.ssl_disable_client_renegotiation) {
+			connection_set_state(srv, con, CON_STATE_ERROR);
+			log_error_write(srv, __FILE__, __LINE__, "s", "SSL: renegotiation initiated by client");
+			return -1;
+		}
+
 		if (len > 0) {
 			if (b->used > 0) b->used--;
 			b->used += len;
@@@@ -445,6 +451,7 @@@@ static int connection_handle_write_prepare(server *srv
 		default:
 			switch(con->http_status) {
 			case 400: /* bad request */
+			case 401: /* authorization required */
 			case 414: /* overload request header */
 			case 505: /* unknown protocol */
 			case 207: /* this was webdav */
@@@@ -560,8 +567,10 @@@@ static int connection_handle_write_prepare(server *srv
a19 45
@@@@ -617,8 +626,9 @@@@ static int connection_handle_write_prepare(server *srv
 }
 
 static int connection_handle_write(server *srv, connection *con) {
-	switch(network_write_chunkqueue(srv, con, con->write_queue)) {
+	switch(network_write_chunkqueue(srv, con, con->write_queue, MAX_WRITE_LIMIT)) {
 	case 0:
+		con->write_request_ts = srv->cur_ts;
 		if (con->file_finished) {
 			connection_set_state(srv, con, CON_STATE_RESPONSE_END);
 			joblist_append(srv, con);
@@@@ -635,6 +645,7 @@@@ static int connection_handle_write(server *srv, connec
 		joblist_append(srv, con);
 		break;
 	case 1:
+		con->write_request_ts = srv->cur_ts;
 		con->is_writable = 0;
 
 		/* not finished yet -> WRITE */
@@@@ -1251,8 +1262,6 @@@@ static handler_t connection_handle_fdevent(server *srv
 			log_error_write(srv, __FILE__, __LINE__, "ds",
 					con->fd,
 					"handle write failed.");
-		} else if (con->state == CON_STATE_WRITE) {
-			con->write_request_ts = srv->cur_ts;
 		}
 	}
 
@@@@ -1352,6 +1361,7 @@@@ connection *connection_accept(server *srv, server_sock
 				return NULL;
 			}
 
+			con->renegotiations = 0;
 #ifndef OPENSSL_NO_TLSEXT
 			SSL_set_app_data(con->ssl, con);
 #endif
@@@@ -1667,8 +1677,6 @@@@ int connection_state_machine(server *srv, connection *
 							con->fd,
 							"handle write failed.");
 					connection_set_state(srv, con, CON_STATE_ERROR);
-				} else if (con->state == CON_STATE_WRITE) {
-					con->write_request_ts = srv->cur_ts;
 				}
 			}
 
@


1.17
log
@lighttpd patches;
- let HEAD for 0-byte files return the Content-Length, from upstream via Brad
- implement reloads (graceful restart) in rc, from Ben Lovett via Brad
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.16 2011/09/06 08:49:51 sthen Exp $
d3 15
a17 2
+++ src/connections.c	Sun Sep 18 16:00:21 2011
@@@@ -445,6 +445,7 @@@@ static int connection_handle_write_prepare(server *srv
d25 1
a25 1
@@@@ -560,8 +561,10 @@@@ static int connection_handle_write_prepare(server *srv
d38 1
a38 1
@@@@ -617,8 +620,9 @@@@ static int connection_handle_write_prepare(server *srv
d49 1
a49 1
@@@@ -635,6 +639,7 @@@@ static int connection_handle_write(server *srv, connec
d57 1
a57 1
@@@@ -1251,8 +1256,6 @@@@ static handler_t connection_handle_fdevent(server *srv
d66 9
a74 1
@@@@ -1667,8 +1670,6 @@@@ int connection_state_machine(server *srv, connection *
@


1.16
log
@fixes from lighttpd upstream via Brad (maintainer)
- Add static-file.disable-pathinfo option to prevent handling of
  urls like .../secret.php/image.jpg as static file.
- Don't overwrite 401 (auth required) with 501 (unknown method).
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.15 2011/08/24 21:28:09 sthen Exp $
d3 1
a3 1
+++ src/connections.c	Mon Sep  5 20:38:50 2011
d12 14
a25 1
@@@@ -617,8 +618,9 @@@@ static int connection_handle_write_prepare(server *srv
d36 1
a36 1
@@@@ -635,6 +637,7 @@@@ static int connection_handle_write(server *srv, connec
d44 1
a44 1
@@@@ -1251,8 +1254,6 @@@@ static handler_t connection_handle_fdevent(server *srv
d53 1
a53 1
@@@@ -1667,8 +1668,6 @@@@ int connection_state_machine(server *srv, connection *
@


1.15
log
@lighttpd bugfix: Limit amount of bytes we send in one go; fixes stalling in one
connection and timeouts on slow systems. From upstream via Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d3 10
a12 2
+++ src/connections.c	Wed Aug 24 02:50:41 2011
@@@@ -617,8 +617,9 @@@@ static int connection_handle_write_prepare(server *srv
d23 1
a23 1
@@@@ -635,6 +636,7 @@@@ static int connection_handle_write(server *srv, connec
d31 1
a31 1
@@@@ -1251,8 +1253,6 @@@@ static handler_t connection_handle_fdevent(server *srv
d40 1
a40 1
@@@@ -1667,8 +1667,6 @@@@ int connection_state_machine(server *srv, connection *
@


1.14
log
@update to 1.4.26, from Brad
@
text
@d1 28
a28 56
$OpenBSD: patch-src_connections_c,v 1.13 2010/02/02 08:10:29 sthen Exp $
--- src/connections.c.orig	Mon Feb  1 19:21:56 2010
+++ src/connections.c	Mon Feb  1 19:21:46 2010
@@@@ -192,40 +192,42 @@@@ static void dump_packet(const unsigned char *data, siz
 
 static int connection_handle_read_ssl(server *srv, connection *con) {
 #ifdef USE_OPENSSL
-	int r, ssl_err, len, count = 0;
+	int r, ssl_err, len, count = 0, read_offset, toread;
 	buffer *b = NULL;
 
 	if (!con->conf.is_ssl) return -1;
 
-	/* don't resize the buffer if we were in SSL_ERROR_WANT_* */
-
 	ERR_clear_error();
 	do {
-		if (!con->ssl_error_want_reuse_buffer) {
-			b = buffer_init();
-			buffer_prepare_copy(b, SSL_pending(con->ssl) + (16 * 1024)); /* the pending bytes + 16kb */
+		if (NULL != con->read_queue->last) {
+			b = con->read_queue->last->mem;
+		}
 
+		if (NULL == b || b->size - b->used < 1024) {
+			b = chunkqueue_get_append_buffer(con->read_queue);
+			len = SSL_pending(con->ssl);
+			if (len < 4*1024) len = 4*1024; /* always alloc >= 4k buffer */
+			buffer_prepare_copy(b, len + 1);
+
 			/* overwrite everything with 0 */
 			memset(b->ptr, 0, b->size);
-		} else {
-			b = con->ssl_error_want_reuse_buffer;
 		}
 
-		len = SSL_read(con->ssl, b->ptr, b->size - 1);
-		con->ssl_error_want_reuse_buffer = NULL; /* reuse it only once */
+		read_offset = (b->used > 0) ? b->used - 1 : 0;
+		toread = b->size - 1 - read_offset;
 
+		len = SSL_read(con->ssl, b->ptr + read_offset, toread);
+
 		if (len > 0) {
-			b->used = len;
+			if (b->used > 0) b->used--;
+			b->used += len;
 			b->ptr[b->used++] = '\0';
 
-		       	/* we move the buffer to the chunk-queue, no need to free it */
+			con->bytes_read += len;
 
-			chunkqueue_append_buffer_weak(con->read_queue, b);
 			count += len;
-			con->bytes_read += len;
-			b = NULL;
a29 46
-	} while (len > 0 && count < MAX_READ_LIMIT);
+	} while (len == toread && count < MAX_READ_LIMIT);
 
 
 	if (len < 0) {
@@@@ -234,11 +236,11 @@@@ static int connection_handle_read_ssl(server *srv, con
 		case SSL_ERROR_WANT_READ:
 		case SSL_ERROR_WANT_WRITE:
 			con->is_readable = 0;
-			con->ssl_error_want_reuse_buffer = b;
 
-			b = NULL;
+			/* the manual says we have to call SSL_read with the same arguments next time.
+			 * we ignore this restriction; no one has complained about it in 1.5 yet, so it probably works anyway.
+			 */
 
-			/* we have to steal the buffer from the queue-queue */
 			return 0;
 		case SSL_ERROR_SYSCALL:
 			/**
@@@@ -297,16 +299,11 @@@@ static int connection_handle_read_ssl(server *srv, con
 
 		connection_set_state(srv, con, CON_STATE_ERROR);
 
-		buffer_free(b);
-
 		return -1;
 	} else if (len == 0) {
 		con->is_readable = 0;
 		/* the other end close the connection -> KEEP-ALIVE */
 
-		/* pipelining */
-		buffer_free(b);
-
 		return -2;
 	}
 
@@@@ -321,26 +318,41 @@@@ static int connection_handle_read_ssl(server *srv, con
 static int connection_handle_read(server *srv, connection *con) {
 	int len;
 	buffer *b;
-	int toread;
+	int toread, read_offset;
 
 	if (con->conf.is_ssl) {
 		return connection_handle_read_ssl(srv, con);
d32 6
a37 142
+	b = (NULL != con->read_queue->last) ? con->read_queue->last->mem : NULL;
+
+	/* default size for chunks is 4kb; only use bigger chunks if FIONREAD tells
+	 *  us more than 4kb is available
+	 * if FIONREAD doesn't signal a big chunk we fill the previous buffer
+	 *  if it has >= 1kb free
+	 */
 #if defined(__WIN32)
-	b = chunkqueue_get_append_buffer(con->read_queue);
-	buffer_prepare_copy(b, 4 * 1024);
-	len = recv(con->fd, b->ptr, b->size - 1, 0);
-#else
-	if (ioctl(con->fd, FIONREAD, &toread) || toread == 0) {
+	if (NULL == b || b->size - b->used < 1024) {
 		b = chunkqueue_get_append_buffer(con->read_queue);
 		buffer_prepare_copy(b, 4 * 1024);
+	}
+
+	read_offset = (b->used == 0) ? 0 : b->used - 1;
+	len = recv(con->fd, b->ptr + read_offset, b->size - 1 - read_offset, 0);
+#else
+	if (ioctl(con->fd, FIONREAD, &toread) || toread == 0 || toread <= 4*1024) {
+		if (NULL == b || b->size - b->used < 1024) {
+			b = chunkqueue_get_append_buffer(con->read_queue);
+			buffer_prepare_copy(b, 4 * 1024);
+		}
 	} else {
 		if (toread > MAX_READ_LIMIT) toread = MAX_READ_LIMIT;
 		b = chunkqueue_get_append_buffer(con->read_queue);
 		buffer_prepare_copy(b, toread + 1);
 	}
-	len = read(con->fd, b->ptr, b->size - 1);
+
+	read_offset = (b->used == 0) ? 0 : b->used - 1;
+	len = read(con->fd, b->ptr + read_offset, b->size - 1 - read_offset);
 #endif
 
 	if (len < 0) {
@@@@ -374,7 +386,8 @@@@ static int connection_handle_read(server *srv, connect
 		con->is_readable = 0;
 	}
 
-	b->used = len;
+	if (b->used > 0) b->used--;
+	b->used += len;
 	b->ptr[b->used++] = '\0';
 
 	con->bytes_read += len;
@@@@ -850,13 +863,6 @@@@ int connection_reset(server *srv, connection *con) {
 	/* The cond_cache gets reset in response.c */
 	/* config_cond_cache_reset(srv, con); */
 
-#ifdef USE_OPENSSL
-	if (con->ssl_error_want_reuse_buffer) {
-		buffer_free(con->ssl_error_want_reuse_buffer);
-		con->ssl_error_want_reuse_buffer = NULL;
-	}
-#endif
-
 	con->header_len = 0;
 	con->in_error_handler = 0;
 
@@@@ -945,62 +951,50 @@@@ static int connection_handle_read_state(server *srv, c
 		last_chunk = NULL;
 		last_offset = 0;
 
-		for (c = cq->first; !last_chunk && c; c = c->next) {
+		for (c = cq->first; c; c = c->next) {
 			buffer b;
 			size_t i;
 
 			b.ptr = c->mem->ptr + c->offset;
 			b.used = c->mem->used - c->offset;
+			if (b.used > 0) b.used--; /* buffer "used" includes terminating zero */
 
-			for (i = 0; !last_chunk && i < b.used; i++) {
+			for (i = 0; i < b.used; i++) {
 				char ch = b.ptr[i];
-				size_t have_chars = 0;
 
-				switch (ch) {
-				case '\r':
-					/* we have to do a 4 char lookup */
-					have_chars = b.used - i - 1;
+				if ('\r' == ch) {
+					/* chec if \n\r\n follows */
+					size_t j = i+1;
+					chunk *cc = c;
+					const char header_end[] = "\r\n\r\n";
+					int header_end_match_pos = 1;
 
-					if (have_chars >= 4) {
-						/* all chars are in this buffer */
+					for ( ; cc; cc = cc->next, j = 0 ) {
+						buffer bb;
+						bb.ptr = cc->mem->ptr + cc->offset;
+						bb.used = cc->mem->used - cc->offset;
+						if (bb.used > 0) bb.used--; /* buffer "used" includes terminating zero */
 
-						if (0 == strncmp(b.ptr + i, "\r\n\r\n", 4)) {
-							/* found */
-							last_chunk = c;
-							last_offset = i + 4;
+						for ( ; j < bb.used; j++) {
+							ch = bb.ptr[j];
 
-							break;
-						}
-					} else {
-						chunk *lookahead_chunk = c->next;
-						size_t missing_chars;
-						/* looks like the following chars are not in the same chunk */
-
-						missing_chars = 4 - have_chars;
-
-						if (lookahead_chunk && lookahead_chunk->type == MEM_CHUNK) {
-							/* is the chunk long enough to contain the other chars ? */
-
-							if (lookahead_chunk->mem->used > missing_chars) {
-								if (0 == strncmp(b.ptr + i, "\r\n\r\n", have_chars) &&
-								    0 == strncmp(lookahead_chunk->mem->ptr, "\r\n\r\n" + have_chars, missing_chars)) {
-
-									last_chunk = lookahead_chunk;
-									last_offset = missing_chars;
-
-									break;
+							if (ch == header_end[header_end_match_pos]) {
+								header_end_match_pos++;
+								if (4 == header_end_match_pos) {
+									last_chunk = cc;
+									last_offset = j+1;
+									goto found_header_end;
 								}
 							} else {
-								/* a splited \r \n */
-								break;
+								goto reset_search;
 							}
 						}
 					}
-
-					break;
a38 22
+reset_search: ;
 			}
 		}
+found_header_end:
 
 		/* found */
 		if (last_chunk) {
@@@@ -1140,8 +1134,15 @@@@ static int connection_handle_read_state(server *srv, c
 			} else {
 				buffer *b;
 
-				b = chunkqueue_get_append_buffer(dst_cq);
-				buffer_copy_string_len(b, c->mem->ptr + c->offset, toRead);
+				if (dst_cq->last &&
+				    dst_cq->last->type == MEM_CHUNK) {
+					b = dst_cq->last->mem;
+				} else {
+					b = chunkqueue_get_append_buffer(dst_cq);
+					/* prepare buffer size for remaining POST data; is < 64kb */
+					buffer_prepare_copy(b, con->request.content_length - dst_cq->bytes_in + 1);
+				}
+				buffer_append_string_len(b, c->mem->ptr + c->offset, toRead);
a40 1
 			c->offset += toRead;
@


1.13
log
@SECURITY fix for CVE-2010-0295 DoS issue.
http://download.lighttpd.net/lighttpd/security/lighttpd_sa_2010_01.txt

From Brad, ok ajacoutot@@ jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.12 2009/12/13 22:06:24 sthen Exp $
@


1.13.2.1
log
@MFC:

Bugfix update to 1.4.26, fix mod_proxy and alias handling

ok Brad
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.13 2010/02/02 08:10:29 sthen Exp $
@


1.12
log
@Add a patch from upstream via Brad; fix request parser to handle packets
with splitted \r\n\r\n. (http://redmine.lighttpd.net/issues/2105)
@
text
@d1 168
a168 4
$OpenBSD$
--- src/connections.c.orig	Thu Nov  5 09:53:32 2009
+++ src/connections.c	Sun Nov 29 18:34:38 2009
@@@@ -945,62 +945,50 @@@@ static int connection_handle_read_state(server *srv, c
d256 18
@


1.11
log
@update to 1.4.25, from Brad
@
text
@d1 85
a85 25
$OpenBSD: patch-src_connections_c,v 1.10 2009/11/08 13:16:40 sthen Exp $
--- src/connections.c.orig	Mon Oct 19 08:15:24 2009
+++ src/connections.c	Sat Nov  7 19:58:41 2009
@@@@ -807,6 +807,9 @@@@ int connection_reset(server *srv, connection *con) {
 	CLEAN(authed_user);
 	CLEAN(server_name);
 	CLEAN(error_handler);
+#if defined USE_OPENSSL && ! defined OPENSSL_NO_TLSEXT
+	CLEAN(tlsext_server_name);
+#endif
 #undef CLEAN
 
 #define CLEAN(x) \
@@@@ -1250,8 +1253,10 @@@@ static handler_t connection_handle_fdevent(void *s, vo
 
 		if (b > 0) {
 			char buf[1024];
+#if 0
 			log_error_write(srv, __FILE__, __LINE__, "sdd",
 					"CLOSE-read()", con->fd, b);
+#endif
 
 			/* */
 			read(con->fd, buf, sizeof(buf));
@@@@ -1621,8 +1626,10 @@@@ int connection_state_machine(server *srv, connection *
d87 2
a88 6
 			if (b > 0) {
 				char buf[1024];
+#if 0
 				log_error_write(srv, __FILE__, __LINE__, "sdd",
 						"CLOSE-read()", con->fd, b);
+#endif
d90 2
a91 2
 				/* */
 				read(con->fd, buf, sizeof(buf));
@


1.10
log
@add patches from upstream via Brad:

- disable warning "CLOSE-read"
- reset tlsext_server_name in connection_reset - fixes random
hostnames in the $HTTP["host"] conditional
- mod_fastcgi: fix mod_fastcgi packet parsing
- mod_fastcgi: Don't reconnect after connect() succeeded
@
text
@d1 1
a1 1
$OpenBSD$
@


1.9
log
@update to 1.4.24, from Brad (maintainer).
@
text
@d1 11
a11 6
$OpenBSD: patch-src_connections_c,v 1.8 2009/06/22 09:28:07 sthen Exp $
--- src/connections.c.orig	Sun Jun 21 22:00:27 2009
+++ src/connections.c	Sun Jun 21 22:03:27 2009
@@@@ -782,13 +782,13 @@@@ int connection_reset(server *srv, connection *con) {
 	CLEAN(request.pathinfo);
 	CLEAN(request.request);
d13 2
a14 2
-	CLEAN(request.orig_uri);
+	/* CLEAN(request.orig_uri); */
d16 6
a21 8
 	CLEAN(uri.scheme);
-	CLEAN(uri.authority);
-	CLEAN(uri.path);
+	/* CLEAN(uri.authority); */
+	/* CLEAN(uri.path); */
 	CLEAN(uri.path_raw);
-	CLEAN(uri.query);
+	/* CLEAN(uri.query); */
d23 3
a25 5
 	CLEAN(physical.doc_root);
 	CLEAN(physical.path);
@@@@ -1400,6 +1400,11 @@@@ int connection_state_machine(server *srv, connection *
 				log_error_write(srv, __FILE__, __LINE__, "sds",
 						"state for fd", con->fd, connection_get_state(con->state));
d27 6
a32 5
+
+			buffer_reset(con->uri.authority);
+			buffer_reset(con->uri.path);
+			buffer_reset(con->uri.query);
+			buffer_reset(con->request.orig_uri);
d34 2
a35 2
 			if (http_request_parse(srv, con)) {
 				/* we have to read some data from the POST request */
@


1.8
log
@Add information about keep-alive connections to mod_status.
From upstream repo, via Brad.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.8.2.1
log
@MFC:

lighttpd-1.4.25

bugfix / stability update

requested by Brad, MAINTAINER

ok Brad, jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.8 2009/06/22 09:28:07 sthen Exp $
@


1.8.2.2
log
@MFC bugfix:

fix request parser to handle packets with splitted \r\n\r\n; from upstream
http://redmine.lighttpd.net/issues/2105

Requested by and ok Brad
@
text
@d1 24
a24 90
$OpenBSD$

fix request parser to handle packets with splitted \r\n\r\n; from upstream
http://redmine.lighttpd.net/issues/2105


--- src/connections.c.orig	Thu Nov  5 09:53:32 2009
+++ src/connections.c	Sun Nov 29 18:34:38 2009
@@@@ -945,62 +945,50 @@@@ static int connection_handle_read_state(server *srv, c
 		last_chunk = NULL;
 		last_offset = 0;
 
-		for (c = cq->first; !last_chunk && c; c = c->next) {
+		for (c = cq->first; c; c = c->next) {
 			buffer b;
 			size_t i;
 
 			b.ptr = c->mem->ptr + c->offset;
 			b.used = c->mem->used - c->offset;
+			if (b.used > 0) b.used--; /* buffer "used" includes terminating zero */
 
-			for (i = 0; !last_chunk && i < b.used; i++) {
+			for (i = 0; i < b.used; i++) {
 				char ch = b.ptr[i];
-				size_t have_chars = 0;
 
-				switch (ch) {
-				case '\r':
-					/* we have to do a 4 char lookup */
-					have_chars = b.used - i - 1;
+				if ('\r' == ch) {
+					/* chec if \n\r\n follows */
+					size_t j = i+1;
+					chunk *cc = c;
+					const char header_end[] = "\r\n\r\n";
+					int header_end_match_pos = 1;
 
-					if (have_chars >= 4) {
-						/* all chars are in this buffer */
+					for ( ; cc; cc = cc->next, j = 0 ) {
+						buffer bb;
+						bb.ptr = cc->mem->ptr + cc->offset;
+						bb.used = cc->mem->used - cc->offset;
+						if (bb.used > 0) bb.used--; /* buffer "used" includes terminating zero */
 
-						if (0 == strncmp(b.ptr + i, "\r\n\r\n", 4)) {
-							/* found */
-							last_chunk = c;
-							last_offset = i + 4;
+						for ( ; j < bb.used; j++) {
+							ch = bb.ptr[j];
 
-							break;
-						}
-					} else {
-						chunk *lookahead_chunk = c->next;
-						size_t missing_chars;
-						/* looks like the following chars are not in the same chunk */
-
-						missing_chars = 4 - have_chars;
-
-						if (lookahead_chunk && lookahead_chunk->type == MEM_CHUNK) {
-							/* is the chunk long enough to contain the other chars ? */
-
-							if (lookahead_chunk->mem->used > missing_chars) {
-								if (0 == strncmp(b.ptr + i, "\r\n\r\n", have_chars) &&
-								    0 == strncmp(lookahead_chunk->mem->ptr, "\r\n\r\n" + have_chars, missing_chars)) {
-
-									last_chunk = lookahead_chunk;
-									last_offset = missing_chars;
-
-									break;
+							if (ch == header_end[header_end_match_pos]) {
+								header_end_match_pos++;
+								if (4 == header_end_match_pos) {
+									last_chunk = cc;
+									last_offset = j+1;
+									goto found_header_end;
 								}
 							} else {
-								/* a splited \r \n */
-								break;
+								goto reset_search;
 							}
 						}
 					}
-
-					break;
 				}
+reset_search: ;
d26 5
a30 2
 		}
+found_header_end:
d32 2
a33 2
 		/* found */
 		if (last_chunk) {
@


1.8.2.3
log
@SECURITY fix for CVE-2010-0295 DoS issue.
http://download.lighttpd.net/lighttpd/security/lighttpd_sa_2010_01.txt

From Brad, ok ajacoutot@@ jasper@@
MFC ok william@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.8.2.2 2009/12/18 02:14:32 william Exp $
d7 3
a9 167
--- src/connections.c.orig	Mon Feb  1 19:21:56 2010
+++ src/connections.c	Mon Feb  1 19:21:46 2010
@@@@ -192,40 +192,42 @@@@ static void dump_packet(const unsigned char *data, siz
 
 static int connection_handle_read_ssl(server *srv, connection *con) {
 #ifdef USE_OPENSSL
-	int r, ssl_err, len, count = 0;
+	int r, ssl_err, len, count = 0, read_offset, toread;
 	buffer *b = NULL;
 
 	if (!con->conf.is_ssl) return -1;
 
-	/* don't resize the buffer if we were in SSL_ERROR_WANT_* */
-
 	ERR_clear_error();
 	do {
-		if (!con->ssl_error_want_reuse_buffer) {
-			b = buffer_init();
-			buffer_prepare_copy(b, SSL_pending(con->ssl) + (16 * 1024)); /* the pending bytes + 16kb */
+		if (NULL != con->read_queue->last) {
+			b = con->read_queue->last->mem;
+		}
 
+		if (NULL == b || b->size - b->used < 1024) {
+			b = chunkqueue_get_append_buffer(con->read_queue);
+			len = SSL_pending(con->ssl);
+			if (len < 4*1024) len = 4*1024; /* always alloc >= 4k buffer */
+			buffer_prepare_copy(b, len + 1);
+
 			/* overwrite everything with 0 */
 			memset(b->ptr, 0, b->size);
-		} else {
-			b = con->ssl_error_want_reuse_buffer;
 		}
 
-		len = SSL_read(con->ssl, b->ptr, b->size - 1);
-		con->ssl_error_want_reuse_buffer = NULL; /* reuse it only once */
+		read_offset = (b->used > 0) ? b->used - 1 : 0;
+		toread = b->size - 1 - read_offset;
 
+		len = SSL_read(con->ssl, b->ptr + read_offset, toread);
+
 		if (len > 0) {
-			b->used = len;
+			if (b->used > 0) b->used--;
+			b->used += len;
 			b->ptr[b->used++] = '\0';
 
-		       	/* we move the buffer to the chunk-queue, no need to free it */
+			con->bytes_read += len;
 
-			chunkqueue_append_buffer_weak(con->read_queue, b);
 			count += len;
-			con->bytes_read += len;
-			b = NULL;
 		}
-	} while (len > 0 && count < MAX_READ_LIMIT);
+	} while (len == toread && count < MAX_READ_LIMIT);
 
 
 	if (len < 0) {
@@@@ -234,11 +236,11 @@@@ static int connection_handle_read_ssl(server *srv, con
 		case SSL_ERROR_WANT_READ:
 		case SSL_ERROR_WANT_WRITE:
 			con->is_readable = 0;
-			con->ssl_error_want_reuse_buffer = b;
 
-			b = NULL;
+			/* the manual says we have to call SSL_read with the same arguments next time.
+			 * we ignore this restriction; no one has complained about it in 1.5 yet, so it probably works anyway.
+			 */
 
-			/* we have to steal the buffer from the queue-queue */
 			return 0;
 		case SSL_ERROR_SYSCALL:
 			/**
@@@@ -297,16 +299,11 @@@@ static int connection_handle_read_ssl(server *srv, con
 
 		connection_set_state(srv, con, CON_STATE_ERROR);
 
-		buffer_free(b);
-
 		return -1;
 	} else if (len == 0) {
 		con->is_readable = 0;
 		/* the other end close the connection -> KEEP-ALIVE */
 
-		/* pipelining */
-		buffer_free(b);
-
 		return -2;
 	}
 
@@@@ -321,26 +318,41 @@@@ static int connection_handle_read_ssl(server *srv, con
 static int connection_handle_read(server *srv, connection *con) {
 	int len;
 	buffer *b;
-	int toread;
+	int toread, read_offset;
 
 	if (con->conf.is_ssl) {
 		return connection_handle_read_ssl(srv, con);
 	}
 
+	b = (NULL != con->read_queue->last) ? con->read_queue->last->mem : NULL;
+
+	/* default size for chunks is 4kb; only use bigger chunks if FIONREAD tells
+	 *  us more than 4kb is available
+	 * if FIONREAD doesn't signal a big chunk we fill the previous buffer
+	 *  if it has >= 1kb free
+	 */
 #if defined(__WIN32)
-	b = chunkqueue_get_append_buffer(con->read_queue);
-	buffer_prepare_copy(b, 4 * 1024);
-	len = recv(con->fd, b->ptr, b->size - 1, 0);
-#else
-	if (ioctl(con->fd, FIONREAD, &toread) || toread == 0) {
+	if (NULL == b || b->size - b->used < 1024) {
 		b = chunkqueue_get_append_buffer(con->read_queue);
 		buffer_prepare_copy(b, 4 * 1024);
+	}
+
+	read_offset = (b->used == 0) ? 0 : b->used - 1;
+	len = recv(con->fd, b->ptr + read_offset, b->size - 1 - read_offset, 0);
+#else
+	if (ioctl(con->fd, FIONREAD, &toread) || toread == 0 || toread <= 4*1024) {
+		if (NULL == b || b->size - b->used < 1024) {
+			b = chunkqueue_get_append_buffer(con->read_queue);
+			buffer_prepare_copy(b, 4 * 1024);
+		}
 	} else {
 		if (toread > MAX_READ_LIMIT) toread = MAX_READ_LIMIT;
 		b = chunkqueue_get_append_buffer(con->read_queue);
 		buffer_prepare_copy(b, toread + 1);
 	}
-	len = read(con->fd, b->ptr, b->size - 1);
+
+	read_offset = (b->used == 0) ? 0 : b->used - 1;
+	len = read(con->fd, b->ptr + read_offset, b->size - 1 - read_offset);
 #endif
 
 	if (len < 0) {
@@@@ -374,7 +386,8 @@@@ static int connection_handle_read(server *srv, connect
 		con->is_readable = 0;
 	}
 
-	b->used = len;
+	if (b->used > 0) b->used--;
+	b->used += len;
 	b->ptr[b->used++] = '\0';
 
 	con->bytes_read += len;
@@@@ -850,13 +863,6 @@@@ int connection_reset(server *srv, connection *con) {
 	/* The cond_cache gets reset in response.c */
 	/* config_cond_cache_reset(srv, con); */
 
-#ifdef USE_OPENSSL
-	if (con->ssl_error_want_reuse_buffer) {
-		buffer_free(con->ssl_error_want_reuse_buffer);
-		con->ssl_error_want_reuse_buffer = NULL;
-	}
-#endif
-
 	con->header_len = 0;
 	con->in_error_handler = 0;
 
@@@@ -945,62 +951,50 @@@@ static int connection_handle_read_state(server *srv, c
a96 18
@@@@ -1140,8 +1134,15 @@@@ static int connection_handle_read_state(server *srv, c
 			} else {
 				buffer *b;
 
-				b = chunkqueue_get_append_buffer(dst_cq);
-				buffer_copy_string_len(b, c->mem->ptr + c->offset, toRead);
+				if (dst_cq->last &&
+				    dst_cq->last->type == MEM_CHUNK) {
+					b = dst_cq->last->mem;
+				} else {
+					b = chunkqueue_get_append_buffer(dst_cq);
+					/* prepare buffer size for remaining POST data; is < 64kb */
+					buffer_prepare_copy(b, con->request.content_length - dst_cq->bytes_in + 1);
+				}
+				buffer_append_string_len(b, c->mem->ptr + c->offset, toRead);
 			}
 
 			c->offset += toRead;
@


1.8.2.4
log
@MFC:

Update to lighttpd-1.4.26p1 for bugfixes

Requested by Brad
ok Brad jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.8.2.3 2010/02/02 13:58:53 sthen Exp $
@


1.7
log
@Upgrade to lighttpd 1.4.20. Large bug fix update.

Tested by a number of users.
@
text
@d1 6
a6 4
$OpenBSD: patch-src_connections_c,v 1.6 2008/04/08 19:11:40 jasper Exp $
--- src/connections.c.orig	Wed Feb 27 18:41:35 2008
+++ src/connections.c	Mon Apr  7 21:39:42 2008
@@@@ -199,6 +199,7 @@@@ static int connection_handle_read_ssl(server *srv, con
d8 2
a9 1
 	/* don't resize the buffer if we were in SSL_ERROR_WANT_* */
d11 14
a24 5
+	ERR_clear_error();
 	do {
 		if (!con->ssl_error_want_reuse_buffer) {
 			b = buffer_init();
@@@@ -1668,21 +1669,51 @@@@ int connection_state_machine(server *srv, connection *
a25 22
 #ifdef USE_OPENSSL
 			if (srv_sock->is_ssl) {
-				int ret;
+				int ret, ssl_r;
+				unsigned long err;
+				ERR_clear_error();
 				switch ((ret = SSL_shutdown(con->ssl))) {
 				case 1:
 					/* ok */
 					break;
 				case 0:
-					SSL_shutdown(con->ssl);
-					break;
+					ERR_clear_error();
+					if (-1 != (ret = SSL_shutdown(con->ssl))) break;
+
+					/* fall through */
 				default:
-					log_error_write(srv, __FILE__, __LINE__, "sds", "SSL:",
-							SSL_get_error(con->ssl, ret),
-							ERR_error_string(ERR_get_error(), NULL));
-					return -1;
d27 4
a30 32
+					switch ((ssl_r = SSL_get_error(con->ssl, ret))) {
+					case SSL_ERROR_WANT_WRITE:
+					case SSL_ERROR_WANT_READ:
+						break;
+					case SSL_ERROR_SYSCALL:
+						/* perhaps we have error waiting in our error-queue */
+						if (0 != (err = ERR_get_error())) {
+							do {
+								log_error_write(srv, __FILE__, __LINE__, "sdds", "SSL:",
+										ssl_r, ret,
+										ERR_error_string(err, NULL));
+							} while((err = ERR_get_error()));
+						} else {
+							log_error_write(srv, __FILE__, __LINE__, "sddds", "SSL (error):",
+									ssl_r, ret, errno,
+									strerror(errno));
+						}
+	
+						break;
+					default:
+						while((err = ERR_get_error())) {
+							log_error_write(srv, __FILE__, __LINE__, "sdds", "SSL:",
+									ssl_r, ret,
+									ERR_error_string(err, NULL));
+						}
+	
+						break;
+					}
 				}
 			}
+			ERR_clear_error();
 #endif
d32 2
a33 1
 			switch(con->mode) {
@


1.6
log
@- fix typos in the previous ssl fix;

from lighttpd svn (changeset 2144); via brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.5 2008/04/03 10:18:15 jasper Exp $
@


1.5
log
@SECURITY FIX for http://secunia.com/advisories/29544/
lighttpd OpenSSL Error Queue Denial of Service Vulnerability

patches from upstream svn, via brad@@
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ src/connections.c	Thu Apr  3 02:33:53 2008
d30 1
a30 1
+					// fall through
d51 1
a51 1
+									ssl_r, r, errno,
@


1.4
log
@update lighttpd to 1.4.16

ok brad (maintainer), simon@@
@
text
@d1 4
a4 6
$OpenBSD: patch-src_connections_c,v 1.3 2007/07/22 19:44:17 rui Exp $
--- src/connections.c.orig	Fri Apr 13 16:26:31 2007
+++ src/connections.c	Sat Jul 21 11:20:09 2007
@@@@ -1252,6 +1252,16 @@@@ connection *connection_accept(server *srv, server_sock
 	socklen_t cnt_len;
 	/* accept it and register the fd */
d6 23
a28 5
+	/**
+	 * check if we can still open a new connections
+	 *
+	 * see #1216
+	 */
d30 6
a35 3
+	if (srv->conns->used >= srv->max_conns) {
+		return NULL;
+	}
d37 28
a64 18
 	cnt_len = sizeof(cnt_addr);
 
 	if (-1 == (cnt = accept(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len))) {
@@@@ -1265,6 +1275,9 @@@@ connection *connection_accept(server *srv, server_sock
 		case ECONNABORTED: /* this is a FreeBSD thingy */
 			/* we were stopped _after_ we had a connection */
 			break;
+		case EMFILE:
+			/* out of fds */
+			break;
 		default:
 			log_error_write(srv, __FILE__, __LINE__, "ssd", "accept failed:", strerror(errno), errno);
 		}
@@@@ -1432,6 +1445,7 @@@@ int connection_state_machine(server *srv, connection *
 				} else if (con->in_error_handler) {
 					/* error-handler is back and has generated content */
 					/* if Status: was set, take it otherwise use 200 */
+					con->http_status = con->error_handler_saved_status;
d66 3
d70 1
a70 1
 				if (con->http_status == 0) con->http_status = 200;
@


1.3
log
@roll in some distribution patches which fix multiple vulnerabilities.
Reference: http://secunia.com/advisories/26130/

ok kili@@, simon@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@update lighttpd to 1.4.15, from brad
ok bernd@@
@
text
@d1 38
a38 16
$OpenBSD: patch-src_connections_c,v 1.1 2007/02/02 09:25:19 bernd Exp $

Fixes a possible 99% cpu bug when a client connection is dropped.
See http://trac.lighttpd.net/trac/wiki/Release-1.4.13-patches.

--- src/connections.c.orig	Tue Jan 30 10:20:09 2007
+++ src/connections.c	Tue Jan 30 10:20:25 2007
@@@@ -970,7 +970,7 @@@@ int connection_handle_read_state(server 
 								}
 							} else {
 								/* a splited \r \n */
-								return -1;
+								break;
 							}
 						}
 					}
@


1.1
log
@Fix a possible 99% cpu bug when a client connection is dropped.
See http://trac.lighttpd.net/trac/wiki/Release-1.4.13-patches.

Submitted by Frank Denis. Thanks!

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.2.1
log
@security update to 1.4.16, fixes multiple vulnerabilities
Reference: http://secunia.com/advisories/26130/

from brad
@
text
@d1 1
a1 1
$OpenBSD: patch-src_connections_c,v 1.1 2007/02/02 09:25:19 bernd Exp $
@


