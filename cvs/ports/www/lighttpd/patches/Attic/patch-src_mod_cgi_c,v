head	1.9;
access;
symbols
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@# @;


1.9
date	2016.11.11.10.23.34;	author sthen;	state dead;
branches;
next	1.8;
commitid	zcSafSSsrSci3osM;

1.8
date	2016.10.12.08.09.26;	author ajacoutot;	state Exp;
branches;
next	1.7;
commitid	RcsywKx0OmgVaY4K;

1.7
date	2016.09.17.20.22.41;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	erqZjU8459iZzz15;

1.6
date	2012.06.01.08.20.50;	author sthen;	state dead;
branches;
next	1.5;

1.5
date	2012.04.28.09.25.25;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.07.14.34.36;	author sthen;	state dead;
branches;
next	1.3;

1.3
date	2011.03.20.13.42.53;	author sthen;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2008.10.23.20.29.17;	author brad;	state dead;
branches;
next	1.1;

1.1
date	2008.04.25.10.23.07;	author jasper;	state Exp;
branches;
next	;

1.3.2.1
date	2011.05.02.12.05.38;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.9
log
@update to lighttpd-1.4.43, from Brad
@
text
@$OpenBSD: patch-src_mod_cgi_c,v 1.8 2016/10/12 08:09:26 ajacoutot Exp $

- [core] fix crash if ready events on abandoned fd (fixes #2748)
- performance: use Linux extended syscalls and flags

--- src/mod_cgi.c.orig	Mon Oct 10 18:05:40 2016
+++ src/mod_cgi.c	Mon Oct 10 18:04:38 2016
@@@@ -36,6 +36,14 @@@@
 #include <stdio.h>
 #include <fcntl.h>
 
+#ifdef O_CLOEXEC
+#define pipe_cloexec(pipefd) pipe2((pipefd), O_CLOEXEC)
+#elif defined FD_CLOEXEC
+#define pipe_cloexec(pipefd) (0 == pipe(pipefd) ? fcntl(fd, F_SETFD, FD_CLOEXEC) : -1)
+#else
+#define pipe_cloexec(pipefd) pipe(pipefd)
+#endif
+
 enum {EOL_UNSET, EOL_N, EOL_RN};
 
 typedef struct {
@@@@ -606,10 +614,7 @@@@ static void cgi_connection_close_fdtocgi(server *srv, 
 	/*(closes only hctx->fdtocgi)*/
 	fdevent_event_del(srv->ev, &(hctx->fde_ndx_tocgi), hctx->fdtocgi);
 	fdevent_unregister(srv->ev, hctx->fdtocgi);
-
-	if (close(hctx->fdtocgi)) {
-		log_error_write(srv, __FILE__, __LINE__, "sds", "cgi stdin close failed ", hctx->fdtocgi, strerror(errno));
-	}
+	fdevent_sched_close(srv->ev, hctx->fdtocgi, 0);
 	hctx->fdtocgi = -1;
 }
 
@@@@ -631,10 +636,7 @@@@ static void cgi_connection_close(server *srv, handler_
 		/* close connection to the cgi-script */
 		fdevent_event_del(srv->ev, &(hctx->fde_ndx), hctx->fd);
 		fdevent_unregister(srv->ev, hctx->fd);
-
-		if (close(hctx->fd)) {
-			log_error_write(srv, __FILE__, __LINE__, "sds", "cgi close failed ", hctx->fd, strerror(errno));
-		}
+		fdevent_sched_close(srv->ev, hctx->fd, 0);
 	}
 
 	if (hctx->fdtocgi != -1) {
@@@@ -1078,12 +1080,12 @@@@ static int cgi_create_env(server *srv, connection *con
 		}
 	}
 
-	if (pipe(to_cgi_fds)) {
+	if (pipe_cloexec(to_cgi_fds)) {
 		log_error_write(srv, __FILE__, __LINE__, "ss", "pipe failed:", strerror(errno));
 		return -1;
 	}
 
-	if (pipe(from_cgi_fds)) {
+	if (pipe_cloexec(from_cgi_fds)) {
 		close(to_cgi_fds[0]);
 		close(to_cgi_fds[1]);
 		log_error_write(srv, __FILE__, __LINE__, "ss", "pipe failed:", strerror(errno));
@@@@ -1105,18 +1107,20 @@@@ static int cgi_create_env(server *srv, connection *con
 		server_socket *srv_sock = con->srv_socket;
 
 		/* move stdout to from_cgi_fd[1] */
-		close(STDOUT_FILENO);
 		dup2(from_cgi_fds[1], STDOUT_FILENO);
+	      #ifndef FD_CLOEXEC
 		close(from_cgi_fds[1]);
 		/* not needed */
 		close(from_cgi_fds[0]);
+	      #endif
 
 		/* move the stdin to to_cgi_fd[0] */
-		close(STDIN_FILENO);
 		dup2(to_cgi_fds[0], STDIN_FILENO);
+	      #ifndef FD_CLOEXEC
 		close(to_cgi_fds[0]);
 		/* not needed */
 		close(to_cgi_fds[1]);
+	      #endif
 
 		/* create environment */
 		env.ptr = NULL;
@@@@ -1372,11 +1376,13 @@@@ static int cgi_create_env(server *srv, connection *con
 		hctx->fd = from_cgi_fds[0];
 		hctx->fde_ndx = -1;
 
+		++srv->cur_fds;
+
 		if (0 == con->request.content_length) {
 			close(to_cgi_fds[1]);
 		} else {
 			/* there is content to send */
-			if (-1 == fdevent_fcntl_set(srv->ev, to_cgi_fds[1])) {
+			if (-1 == fdevent_fcntl_set_nb(srv->ev, to_cgi_fds[1])) {
 				log_error_write(srv, __FILE__, __LINE__, "ss", "fcntl failed: ", strerror(errno));
 				close(to_cgi_fds[1]);
 				cgi_connection_close(srv, hctx);
@@@@ -1388,16 +1394,17 @@@@ static int cgi_create_env(server *srv, connection *con
 				cgi_connection_close(srv, hctx);
 				return -1;
 			}
+
+			++srv->cur_fds;
 		}
 
 		fdevent_register(srv->ev, hctx->fd, cgi_handle_fdevent, hctx);
-		fdevent_event_set(srv->ev, &(hctx->fde_ndx), hctx->fd, FDEVENT_IN);
-
-		if (-1 == fdevent_fcntl_set(srv->ev, hctx->fd)) {
+		if (-1 == fdevent_fcntl_set_nb(srv->ev, hctx->fd)) {
 			log_error_write(srv, __FILE__, __LINE__, "ss", "fcntl failed: ", strerror(errno));
 			cgi_connection_close(srv, hctx);
 			return -1;
 		}
+		fdevent_event_set(srv->ev, &(hctx->fde_ndx), hctx->fd, FDEVENT_IN);
 
 		break;
 	}
@


1.8
log
@Bring in a commit from upstream
- performance: use Linux extended syscalls and flags

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_mod_cgi_c,v 1.7 2016/09/17 20:22:41 ajacoutot Exp $
@


1.7
log
@Update to lighttpd-1.4.41.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
[core] fix crash if ready events on abandoned fd (fixes #2748)
d6 18
a23 3
--- src/mod_cgi.c.orig	Wed Sep 14 21:06:50 2016
+++ src/mod_cgi.c	Wed Sep 14 21:04:56 2016
@@@@ -606,10 +606,7 @@@@ static void cgi_connection_close_fdtocgi(server *srv, 
d35 1
a35 1
@@@@ -631,10 +628,7 @@@@ static void cgi_connection_close(server *srv, handler_
d47 39
a85 1
@@@@ -1372,6 +1366,8 @@@@ static int cgi_create_env(server *srv, connection *con
d94 7
a100 1
@@@@ -1388,6 +1384,8 @@@@ static int cgi_create_env(server *srv, connection *con
d109 12
@


1.6
log
@update to lighttpd 1.4.31, rolling in the backported patches. ok brad
@
text
@d1 1
a1 1
$OpenBSD: patch-src_mod_cgi_c,v 1.5 2012/04/28 09:25:25 sthen Exp $
d3 1
a3 1
Fix splitting :port with IPv6.
d5 13
a17 3
--- src/mod_cgi.c.orig	Sun Dec 18 07:52:52 2011
+++ src/mod_cgi.c	Mon Apr 23 00:13:55 2012
@@@@ -811,8 +811,14 @@@@ static int cgi_create_env(server *srv, connection *con
d19 17
a35 4
 		if (!buffer_is_empty(con->server_name)) {
 			size_t len = con->server_name->used - 1;
-			char *colon = strchr(con->server_name->ptr, ':');
-			if (colon) len = colon - con->server_name->ptr;
d37 10
a46 7
+			if (con->server_name->ptr[0] == '[') {
+				const char *colon = strstr(con->server_name->ptr, "]:");
+				if (colon) len = (colon + 1) - con->server_name->ptr;
+			} else {
+				const char *colon = strchr(con->server_name->ptr, ':');
+				if (colon) len = colon - con->server_name->ptr;
+			}
d48 1
a48 2
 			cgi_env_add(&env, CONST_STR_LEN("SERVER_NAME"), con->server_name->ptr, len);
 		} else {
@


1.5
log
@lighttpd fixes, from upstream via Brad.
- Fix handling of empty header list entries in http_request_split_value.
- Fix access log escaping of " and \\.
- Fix digest "md5-sess" implementation (Errata ID 1649, RFC 2617).
- Add "AUTH_TYPE" environment (for *cgi), remove fastcgi specific workaround.
- Fix splitting :port with IPv6.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.4
log
@update lighttpd to 1.4.29, from Brad

- while there, remove patch-src_server_c too, all the various /dev/*random
are equivalent now, ok Brad
@
text
@d1 7
a7 4
$OpenBSD: patch-src_mod_cgi_c,v 1.3 2011/03/20 13:42:53 sthen Exp $
--- src/mod_cgi.c.orig	Mon Mar 14 21:11:20 2011
+++ src/mod_cgi.c	Mon Mar 14 21:13:22 2011
@@@@ -341,8 +341,19 @@@@ static int cgi_demux_response(server *srv, handler_ctx
d9 12
a20 3
 	while(1) {
 		int n;
+		int toread;
d22 2
a23 15
-		buffer_prepare_copy(hctx->response, 1024);
+#if defined(__WIN32)
+		buffer_prepare_copy(hctx->response, 4 * 1024);
+#else
+		if (ioctl(con->fd, FIONREAD, &toread) || toread == 0 || toread <= 4*1024) {
+			buffer_prepare_copy(hctx->response, 4 * 1024);
+		} else {
+			if (toread > MAX_READ_LIMIT) toread = MAX_READ_LIMIT;
+			buffer_prepare_copy(hctx->response, toread + 1);
+		}
+#endif
+
 		if (-1 == (n = read(hctx->fd, hctx->response->ptr, hctx->response->size - 1))) {
 			if (errno == EAGAIN || errno == EINTR) {
 				/* would block, wait for signal */
@


1.3
log
@Fixes from upstream via Brad (maintainer)
* mod_proxy: fix delayed connect
* mod_cgi: make read buffer as big as incoming data block
* ssl: Support for Diffie-Hellman and Elliptic-Curve Diffie-Hellman
key exchange (add ssl.use-sslv3)

While there, update autoconf version comment, should be 2.67.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3.2.1
log
@- Fixes from upstream via Brad (maintainer)
* mod_proxy: fix delayed connect
* mod_cgi: make read buffer as big as incoming data block
* ssl: Support for Diffie-Hellman and Elliptic-Curve Diffie-Hellman
key exchange (add ssl.use-sslv3)

- backport a patch from upstream to avoid a conflict between OpenSSL and
internal implementations of MD5. Fixes SSL problems with some clients.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_mod_cgi_c,v 1.3 2011/03/20 13:42:53 sthen Exp $
@


1.2
log
@Upgrade to lighttpd 1.4.20. Large bug fix update.

Tested by a number of users.
@
text
@d1 24
a24 34
$OpenBSD: patch-src_mod_cgi_c,v 1.1 2008/04/25 10:23:07 jasper Exp $
--- src/mod_cgi.c.orig	Thu Apr 24 01:17:35 2008
+++ src/mod_cgi.c	Thu Apr 24 01:19:08 2008
@@@@ -1058,8 +1058,9 @@@@ static int cgi_create_env(server *srv, connection *con
 						switch(errno) {
 						case ENOSPC:
 							con->http_status = 507;
-
 							break;
+						case EINTR:
+							continue;
 						default:
 							con->http_status = 403;
 							break;
@@@@ -1071,8 +1072,9 @@@@ static int cgi_create_env(server *srv, connection *con
 						switch(errno) {
 						case ENOSPC:
 							con->http_status = 507;
-
 							break;
+						case EINTR:
+							continue;
 						default:
 							con->http_status = 403;
 							break;
@@@@ -1087,6 +1089,8 @@@@ static int cgi_create_env(server *srv, connection *con
 					c->offset += r;
 					cq->bytes_out += r;
 				} else {
+					log_error_write(srv, __FILE__, __LINE__, "ss", "write() failed due to: ", strerror(errno)); 
+					con->http_status = 500;
 					break;
 				}
 				chunkqueue_remove_finished_chunks(cq);
@


1.1
log
@- Handle EINTR in mod_cgi during write()
- Fix mod_magnet to set con->mode = p->id if it generates content,
  so returning 4xx/5xx doesn't append an error page

from brad@@
@
text
@d1 1
a1 1
$OpenBSD$
@

