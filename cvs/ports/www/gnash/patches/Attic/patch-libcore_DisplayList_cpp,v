head	1.2;
access;
symbols
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2011.03.23.16.20.03;	author dcoppa;	state dead;
branches;
next	1.1;

1.1
date	2010.11.07.18.58.24;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to gnash-0.8.9

from Brad
@
text
@$OpenBSD: patch-libcore_DisplayList_cpp,v 1.1 2010/11/07 18:58:24 dcoppa Exp $

Drop assertion, handle the case instead.

--- libcore/DisplayList.cpp.orig	Sat Aug  7 11:50:00 2010
+++ libcore/DisplayList.cpp	Fri Nov  5 21:15:20 2010
@@@@ -45,15 +45,11 @@@@ namespace {
     DisplayList::const_iterator beginNonRemoved(
             const DisplayList::container_type& c);
 
-	/// Return an iterator succeeding the last element in zone
-    /// (-16384, 0xffff-16384)
+    /// Return the first element in the DisplayList whose depth exceeds
+    /// 65535 (-16384).
     DisplayList::iterator dlistTagsEffectiveZoneEnd(
             DisplayList::container_type& c);
 	
-	/// Return an constant iterator succeeding the last element
-    /// in (-16384, 0xffff-16384)
-    DisplayList::const_iterator dlistTagsEffectiveZoneEnd(
-            const DisplayList::container_type& c);
 }
 
 /// Anonymous namespace for generic algorithm functors.
@@@@ -881,21 +877,27 @@@@ DisplayList::sort()
 }
 
 void
-DisplayList::mergeDisplayList(DisplayList & newList)
+DisplayList::mergeDisplayList(DisplayList& newList)
 {
     testInvariant();
 
+    log_debug("New list size: %s", newList.size());
+
     iterator itOld = beginNonRemoved(_charsByDepth);
     iterator itNew = beginNonRemoved(newList._charsByDepth);
 
     iterator itOldEnd = dlistTagsEffectiveZoneEnd(_charsByDepth);
-    iterator itNewEnd = newList._charsByDepth.end(); 
-    assert(itNewEnd == dlistTagsEffectiveZoneEnd(newList._charsByDepth) );
 
+    // There used to be an assertion here that no character in the new list
+    // is at depth 65535 or higher. There's no reason why the tags executed
+    // on the new list shouldn't do this though. Bug #29282 does this.
+    // TODO: check whether we should be ignoring that character.
+    iterator itNewEnd = dlistTagsEffectiveZoneEnd(newList._charsByDepth); 
+
     // step1. 
     // starting scanning both lists.
-    while (itOld != itOldEnd)
-    {
+    while (itOld != itOldEnd) {
+
         iterator itOldBackup = itOld;
         
         DisplayObject* chOld = *itOldBackup;
@@@@ -1105,13 +1107,6 @@@@ beginNonRemoved(const DisplayList::container_type& c)
 
 DisplayList::iterator
 dlistTagsEffectiveZoneEnd(DisplayList::container_type& c)
-{
-    return std::find_if(c.begin(), c.end(), 
-             DepthGreaterOrEqual(0xffff + DisplayObject::staticDepthOffset));
-}
-
-DisplayList::const_iterator
-dlistTagsEffectiveZoneEnd(const DisplayList::container_type& c)
 {
     return std::find_if(c.begin(), c.end(), 
              DepthGreaterOrEqual(0xffff + DisplayObject::staticDepthOffset));
@


1.1
log
@Backport a bunch of bug fixes from upstream, including fixing WAV
header writing on 64-bit archs.

From Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
@

