head	1.3;
access;
symbols
	OPENBSD_6_0:1.2.0.10
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.6
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.8
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.4
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.2
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.1.0.4
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2016.11.05.16.45.43;	author ajacoutot;	state dead;
branches;
next	1.2;
commitid	unO9pHWUMxa96QsB;

1.2
date	2014.04.10.06.13.04;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.08.00.58.26;	author brad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove www/gnash because... well :-)
General agreement from the b2k16 hackroom a couple days ago and Brad is ok
to remove it as well.
@
text
@$OpenBSD: patch-libmedia_ffmpeg_MediaParserFfmpeg_cpp,v 1.2 2014/04/10 06:13:04 brad Exp $

Update for newer FFmpeg API.

--- libmedia/ffmpeg/MediaParserFfmpeg.cpp.orig	Thu Jan 19 14:17:48 2012
+++ libmedia/ffmpeg/MediaParserFfmpeg.cpp	Mon Apr  7 06:39:48 2014
@@@@ -344,8 +344,10 @@@@ MediaParserFfmpeg::initializeParser()
 {
     av_register_all(); // TODO: needs to be invoked only once ?
 
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52,107,0)
     _byteIOCxt.buffer = NULL;
-    
+#endif
+
     _inputFmt = probeStream();
 
 #ifdef GNASH_ALLOW_VCODEC_ENV	
@@@@ -366,7 +368,11 @@@@ MediaParserFfmpeg::initializeParser()
     // which isn't needed.
     _byteIOBuffer.reset(new unsigned char[byteIOBufferSize]);
 
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52,107,0)
     init_put_byte(&_byteIOCxt,
+#else
+    _avIOCxt = avio_alloc_context(
+#endif
 		  _byteIOBuffer.get(), // buffer
 		  byteIOBufferSize, // buffer size
 		  0, // write flags
@@@@ -376,7 +382,11 @@@@ MediaParserFfmpeg::initializeParser()
 		  MediaParserFfmpeg::seekMediaWrapper // seeker callback
 		  );
     
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52,107,0)
     _byteIOCxt.is_streamed = 1;
+#else
+    _avIOCxt->seekable = 0;
+#endif
 
 #if !defined(LIBAVCODEC_VERSION_MAJOR) || LIBAVCODEC_VERSION_MAJOR < 52
     // Needed for Lenny.
@@@@ -387,12 +397,19 @@@@ MediaParserFfmpeg::initializeParser()
 
     assert(_formatCtx);
 
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52,107,0)
     // Otherwise av_open_input_stream will reallocate the context.
     AVFormatParameters ap;
     std::memset(&ap, 0, sizeof ap);
     ap.prealloced_context = 1;
 
     if (av_open_input_stream(&_formatCtx, &_byteIOCxt, "", _inputFmt, &ap) < 0)
+#else
+
+    _formatCtx->pb = _avIOCxt;
+
+    if (avformat_open_input(&_formatCtx, "", _inputFmt, NULL) < 0)
+#endif
     {
         throw IOException("MediaParserFfmpeg couldn't open input stream");
     }
@@@@ -400,10 +417,17 @@@@ MediaParserFfmpeg::initializeParser()
 #if defined(LIBAVCODEC_VERSION_MAJOR) && LIBAVCODEC_VERSION_MAJOR >= 52
     // Note: in at least some versions of ffmpeg, av_open_input_stream does
     // not parse metadata; not sure why.
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(51,5,0)
     AVMetadata* md = _formatCtx->metadata;
     if (md) {
         AVMetadataTag* tag = av_metadata_get(md, "album", 0,
                 AV_METADATA_MATCH_CASE);
+#else
+    AVDictionary* md = _formatCtx->metadata;
+    if (md) {
+        AVDictionaryEntry* tag = av_dict_get(md, "album", 0,
+                AV_DICT_MATCH_CASE);
+#endif
         if (tag && tag->value) {
             setId3Info(&Id3Info::album, std::string(tag->value),
                     _id3Object);
@@@@ -468,13 +492,13 @@@@ MediaParserFfmpeg::initializeParser()
         boost::uint16_t width = _videoStream->codec->width;
         boost::uint16_t height = _videoStream->codec->height;
         boost::uint16_t frameRate = static_cast<boost::uint16_t>(
-                as_double(_videoStream->r_frame_rate));
+                as_double(_videoStream->avg_frame_rate));
 #if !defined(HAVE_LIBAVFORMAT_AVFORMAT_H) && !defined(HAVE_FFMPEG_AVCODEC_H)
         boost::uint64_t duration = _videoStream->codec_info_duration;
 #else
         boost::uint64_t duration = _videoStream->duration;
 #endif
-        if (duration == AV_NOPTS_VALUE) {
+        if (duration == static_cast<boost::uint64_t>(AV_NOPTS_VALUE)) {
             log_error(_("Duration of video stream unknown"));
             duration=0; // TODO: guess!
         } else {
@@@@ -503,7 +527,7 @@@@ MediaParserFfmpeg::initializeParser()
 #else
         boost::uint64_t duration = _audioStream->duration;
 #endif
-        if (duration == AV_NOPTS_VALUE) {
+        if (duration == static_cast<boost::uint64_t>(AV_NOPTS_VALUE)) {
             log_error(_("Duration of audio stream unknown to ffmpeg"));
             duration=0; // TODO: guess!
         } 
@@@@ -601,7 +625,7 @@@@ MediaParserFfmpeg::seekMedia(boost::int64_t offset, in
 	else if (whence == SEEK_END)
 	{
 		// New position is offset + end of file
-		log_unimpl("MediaParserFfmpeg seek from end of file");
+		LOG_ONCE(log_unimpl("MediaParserFfmpeg seek from end of file"));
 		// This is (most likely) a streamed file, so we can't seek to the end!
 		// Instead we seek to byteIOBufferSize bytes... seems to work fine...
 		_stream->seek(byteIOBufferSize);
@@@@ -611,7 +635,7 @@@@ MediaParserFfmpeg::seekMedia(boost::int64_t offset, in
 	{
 		// ffmpeg uses whence=AVSEEK_SIZE and offset=0 to request
 		// stream size !
-		log_unimpl("MediaParserFfmpeg: unsupported whence value %d", whence);
+		LOG_ONCE(log_unimpl("MediaParserFfmpeg: unsupported whence value %d", whence));
 		return -1;
 	}
 
@@@@ -620,30 +644,34 @@@@ MediaParserFfmpeg::seekMedia(boost::int64_t offset, in
 }
 
 boost::uint16_t
-MediaParserFfmpeg::SampleFormatToSampleSize(SampleFormat fmt)
+MediaParserFfmpeg::SampleFormatToSampleSize(AVSampleFormat fmt)
 {
+#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(51,4,0)
+        return av_get_bytes_per_sample(fmt);
+#else
 	switch (fmt)
 	{
-		case SAMPLE_FMT_U8: // unsigned 8 bits
+		case AV_SAMPLE_FMT_U8: // unsigned 8 bits
 			return 1;
 
-		case SAMPLE_FMT_S16: // signed 16 bits
-		case SAMPLE_FMT_FLT: // float
+		case AV_SAMPLE_FMT_S16: // signed 16 bits
+		case AV_SAMPLE_FMT_FLT: // float
 			return 2;
 
 #if !defined (LIBAVCODEC_VERSION_MAJOR) || LIBAVCODEC_VERSION_MAJOR < 52
 // Was dropped for version 52.0.0
-		case SAMPLE_FMT_S24: // signed 24 bits
+		case AV_SAMPLE_FMT_S24: // signed 24 bits
 			return 3;
 #endif
 
-		case SAMPLE_FMT_S32: // signed 32 bits
+		case AV_SAMPLE_FMT_S32: // signed 32 bits
 			return 4;
 
-		case SAMPLE_FMT_NONE:
+		case AV_SAMPLE_FMT_NONE:
 		default:
 			return 8; // arbitrary value
 	}
+#endif
 }
 
 
@


1.2
log
@Back port updated FFmpeg backend for Gnash to bring in some
bug fixes and deal with newer FFmpeg.

ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libmedia_ffmpeg_MediaParserFfmpeg_cpp,v 1.1 2013/03/08 00:58:26 brad Exp $
@


1.1
log
@Switch back to the FFmpeg media backend and add some patches from
upstream to allow building with newer FFmpeg API.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
d6 1
a6 1
+++ libmedia/ffmpeg/MediaParserFfmpeg.cpp	Mon Feb 18 12:06:22 2013
d81 43
@

