head	1.2;
access;
symbols
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	sthen_20100917:1.1.1.1
	sthen:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2011.04.16.00.15.37;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2010.09.17.21.37.19;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.17.21.37.19;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@- remove casts now that NULL is a void *
- sync WANTLIB
@
text
@$OpenBSD: patch-src_gui_presets_c,v 1.1 2010/09/17 21:37:19 sthen Exp $

missing sentinel in function call; pushed upstream

--- src/gui/presets.c.orig	Fri Aug 27 15:01:47 2010
+++ src/gui/presets.c	Fri Sep 17 00:01:57 2010
@@@@ -201,16 +201,16 @@@@ edit_preset (const char *name_in, dt_iop_module_t *mod
   g->name = GTK_ENTRY(gtk_entry_new());
   gtk_entry_set_text(g->name, name);
   gtk_box_pack_start(box, GTK_WIDGET(g->name), FALSE, FALSE, 0);
-  gtk_object_set(GTK_OBJECT(g->name), "tooltip-text", _("name of the preset"), NULL);
+  gtk_object_set(GTK_OBJECT(g->name), "tooltip-text", _("name of the preset"), (char *)NULL);
 
   g->description = GTK_ENTRY(gtk_entry_new());
   gtk_box_pack_start(box, GTK_WIDGET(g->description), FALSE, FALSE, 0);
-  gtk_object_set(GTK_OBJECT(g->description), "tooltip-text", _("description or further information"), NULL);
+  gtk_object_set(GTK_OBJECT(g->description), "tooltip-text", _("description or further information"), (char *)NULL);
 
   g->autoapply = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_("auto apply this preset to matching images")));
   gtk_box_pack_start(box, GTK_WIDGET(g->autoapply), FALSE, FALSE, 0);
   g->filter = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_("only show this preset for matching images")));
-  gtk_object_set(GTK_OBJECT(g->filter), "tooltip-text", _("be very careful with this option. this might be the last time you see your preset."), NULL);
+  gtk_object_set(GTK_OBJECT(g->filter), "tooltip-text", _("be very careful with this option. this might be the last time you see your preset."), (char *)NULL);
   gtk_box_pack_start(box, GTK_WIDGET(g->filter), FALSE, FALSE, 0);
   g_signal_connect(G_OBJECT(g->autoapply), "toggled", G_CALLBACK(check_buttons_activated), g);
   g_signal_connect(G_OBJECT(g->filter),    "toggled", G_CALLBACK(check_buttons_activated), g);
@@@@ -225,21 +225,21 @@@@ edit_preset (const char *name_in, dt_iop_module_t *mod
 
   // model, maker, lens
   g->model = GTK_ENTRY(gtk_entry_new());
-  gtk_object_set(GTK_OBJECT(g->model), "tooltip-text", _("string to match model (use % as wildcard)"), NULL);
+  gtk_object_set(GTK_OBJECT(g->model), "tooltip-text", _("string to match model (use % as wildcard)"), (char *)NULL);
   label = gtk_label_new(_("model"));
   gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
   gtk_box_pack_start(vbox2, label, FALSE, FALSE, 0);
   gtk_box_pack_start(vbox3, GTK_WIDGET(g->model), FALSE, FALSE, 0);
   gtk_box_pack_start(vbox4, gtk_label_new(""), FALSE, FALSE, 0);
   g->maker = GTK_ENTRY(gtk_entry_new());
-  gtk_object_set(GTK_OBJECT(g->maker), "tooltip-text", _("string to match maker (use % as wildcard)"), NULL);
+  gtk_object_set(GTK_OBJECT(g->maker), "tooltip-text", _("string to match maker (use % as wildcard)"), (char *)NULL);
   label = gtk_label_new(_("maker"));
   gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
   gtk_box_pack_start(vbox2, label, FALSE, FALSE, 0);
   gtk_box_pack_start(vbox3, GTK_WIDGET(g->maker), FALSE, FALSE, 0);
   gtk_box_pack_start(vbox4, gtk_label_new(""), FALSE, FALSE, 0);
   g->lens  = GTK_ENTRY(gtk_entry_new());
-  gtk_object_set(GTK_OBJECT(g->lens), "tooltip-text", _("string to match lens (use % as wildcard)"), NULL);
+  gtk_object_set(GTK_OBJECT(g->lens), "tooltip-text", _("string to match lens (use % as wildcard)"), (char *)NULL);
   label = gtk_label_new(_("lens"));
   gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
   gtk_box_pack_start(vbox2, label, FALSE, FALSE, 0);
@@@@ -251,11 +251,11 @@@@ edit_preset (const char *name_in, dt_iop_module_t *mod
   gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
   gtk_box_pack_start(vbox2, label, FALSE, FALSE, 0);
   g->iso_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 51200, 100));
-  gtk_object_set(GTK_OBJECT(g->iso_min), "tooltip-text", _("minimum iso value"), NULL);
+  gtk_object_set(GTK_OBJECT(g->iso_min), "tooltip-text", _("minimum iso value"), (char *)NULL);
   gtk_spin_button_set_digits(g->iso_min, 0);
   gtk_box_pack_start(vbox3, GTK_WIDGET(g->iso_min), FALSE, FALSE, 0);
   g->iso_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 51200, 100));
-  gtk_object_set(GTK_OBJECT(g->iso_max), "tooltip-text", _("maximum iso value"), NULL);
+  gtk_object_set(GTK_OBJECT(g->iso_max), "tooltip-text", _("maximum iso value"), (char *)NULL);
   gtk_spin_button_set_digits(g->iso_max, 0);
   gtk_box_pack_start(vbox4, GTK_WIDGET(g->iso_max), FALSE, FALSE, 0);
 
@@@@ -265,8 +265,8 @@@@ edit_preset (const char *name_in, dt_iop_module_t *mod
   gtk_box_pack_start(vbox2, label, FALSE, FALSE, 0);
   g->exposure_min = GTK_COMBO_BOX(gtk_combo_box_new_text());
   g->exposure_max = GTK_COMBO_BOX(gtk_combo_box_new_text());
-  gtk_object_set(GTK_OBJECT(g->exposure_min), "tooltip-text", _("minimum exposure time"), NULL);
-  gtk_object_set(GTK_OBJECT(g->exposure_max), "tooltip-text", _("maximum exposure time"), NULL);
+  gtk_object_set(GTK_OBJECT(g->exposure_min), "tooltip-text", _("minimum exposure time"), (char *)NULL);
+  gtk_object_set(GTK_OBJECT(g->exposure_max), "tooltip-text", _("maximum exposure time"), (char *)NULL);
   for(int k=0;k<dt_gui_presets_exposure_value_cnt;k++)
     gtk_combo_box_append_text(g->exposure_min, dt_gui_presets_exposure_value_str[k]);
   for(int k=0;k<dt_gui_presets_exposure_value_cnt;k++)
@@@@ -280,8 +280,8 @@@@ edit_preset (const char *name_in, dt_iop_module_t *mod
   gtk_box_pack_start(vbox2, label, FALSE, FALSE, 0);
   g->aperture_min = GTK_COMBO_BOX(gtk_combo_box_new_text());
   g->aperture_max = GTK_COMBO_BOX(gtk_combo_box_new_text());
-  gtk_object_set(GTK_OBJECT(g->aperture_min), "tooltip-text", _("minimum aperture value"), NULL);
-  gtk_object_set(GTK_OBJECT(g->aperture_max), "tooltip-text", _("maximum aperture value"), NULL);
+  gtk_object_set(GTK_OBJECT(g->aperture_min), "tooltip-text", _("minimum aperture value"), (char *)NULL);
+  gtk_object_set(GTK_OBJECT(g->aperture_max), "tooltip-text", _("maximum aperture value"), (char *)NULL);
   for(int k=0;k<dt_gui_presets_aperture_value_cnt;k++)
     gtk_combo_box_append_text(g->aperture_min, dt_gui_presets_aperture_value_str[k]);
   for(int k=0;k<dt_gui_presets_aperture_value_cnt;k++)
@@@@ -297,8 +297,8 @@@@ edit_preset (const char *name_in, dt_iop_module_t *mod
   gtk_spin_button_set_digits(g->focal_length_min, 0);
   gtk_box_pack_start(vbox3, GTK_WIDGET(g->focal_length_min), FALSE, FALSE, 0);
   g->focal_length_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));
-  gtk_object_set(GTK_OBJECT(g->focal_length_min), "tooltip-text", _("minimum focal length"), NULL);
-  gtk_object_set(GTK_OBJECT(g->focal_length_max), "tooltip-text", _("maximum focal length"), NULL);
+  gtk_object_set(GTK_OBJECT(g->focal_length_min), "tooltip-text", _("minimum focal length"), (char *)NULL);
+  gtk_object_set(GTK_OBJECT(g->focal_length_max), "tooltip-text", _("maximum focal length"), (char *)NULL);
   gtk_spin_button_set_digits(g->focal_length_max, 0);
   gtk_box_pack_start(vbox4, GTK_WIDGET(g->focal_length_max), FALSE, FALSE, 0);
 
@@@@ -508,7 +508,7 @@@@ dt_gui_presets_popup_menu_show_internal(dt_dev_operati
     }
     if(module) g_signal_connect(G_OBJECT(mi), "activate", G_CALLBACK(menuitem_pick_preset), module);
     else if(pick_callback) g_signal_connect(G_OBJECT(mi), "activate", G_CALLBACK(pick_callback), callback_data);
-    gtk_object_set(GTK_OBJECT(mi), "tooltip-text", sqlite3_column_text(stmt, 3), NULL);
+    gtk_object_set(GTK_OBJECT(mi), "tooltip-text", sqlite3_column_text(stmt, 3), (char *)NULL);
     gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);
     cnt ++;
   }
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.1.1
log
@import ports/graphics/darktable, thanks ajacoutot@@ for review+fixes.

darktable is a virtual lighttable and darkroom for photographers:
it manages your digital negatives in a database and lets you view
them through a zoomable lighttable. It also enables you to develop
raw images and enhance them. It tries to fill the gap between the
many excellent existing free raw converters and image management
tools (such as ufraw or f-spot).

All editing is fully non-destructive and only operates on cached
image buffers for display. The full image is only converted during
export. Raw files, high-dynamic range and standard image formats
such as jpeg are all supported. The core operates completely on
floating point values, so darktable can not only be used for
photography but also for scientifically acquired images or output
of renderers (high dynamic range).
@
text
@@
