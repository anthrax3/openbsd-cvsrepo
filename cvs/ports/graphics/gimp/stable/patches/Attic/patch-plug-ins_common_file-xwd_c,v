head	1.5;
access;
symbols
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2014.10.18.14.27.11;	author giovanni;	state dead;
branches;
next	1.4;
commitid	0yEJUpqaDPWGdu4M;

1.4
date	2014.07.11.17.02.00;	author giovanni;	state Exp;
branches;
next	1.3;
commitid	rHC77RvqwJ7V9snH;

1.3
date	2013.12.15.19.54.00;	author jasper;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2013.03.11.16.21.45;	author giovanni;	state dead;
branches;
next	1.1;

1.1
date	2012.11.27.12.12.41;	author jasper;	state Exp;
branches;
next	;

1.3.2.1
date	2013.12.15.20.33.38;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Bugfix update to 2.8.14
@
text
@$OpenBSD: patch-plug-ins_common_file-xwd_c,v 1.4 2014/07/11 17:02:00 giovanni Exp $

Security fix for CVE-2013-1978
gimp: XWD plugin color map heap-based buffer overflow

Patch from https://git.gnome.org/browse/gimp/commit/?id=23f685931e5f000dd033a45c60c1e60d7f78caf4

--- plug-ins/common/file-xwd.c.orig	Sun Nov 10 16:37:53 2013
+++ plug-ins/common/file-xwd.c	Fri Jul 11 15:46:41 2014
@@@@ -424,9 +424,9 @@@@ static gint32
 load_image (const gchar  *filename,
             GError      **error)
 {
-  FILE            *ifp;
+  FILE            *ifp = NULL;
   gint             depth, bpp;
-  gint32           image_ID;
+  gint32           image_ID = -1;
   L_XWDFILEHEADER  xwdhdr;
   L_XWDCOLOR      *xwdcolmap = NULL;
 
@@@@ -436,7 +436,7 @@@@ load_image (const gchar  *filename,
       g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),
                    _("Could not open '%s' for reading: %s"),
                    gimp_filename_to_utf8 (filename), g_strerror (errno));
-      return -1;
+      goto out;
     }
 
   read_xwd_header (ifp, &xwdhdr);
@@@@ -445,8 +445,7 @@@@ load_image (const gchar  *filename,
       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                    _("Could not read XWD header from '%s'"),
                    gimp_filename_to_utf8 (filename));
-      fclose (ifp);
-      return -1;
+      goto out;
     }
 
 #ifdef XWD_COL_WAIT_DEBUG
@@@@ -463,6 +462,13 @@@@ load_image (const gchar  *filename,
 
   if (xwdhdr.l_colormap_entries > 0)
     {
+      if (xwdhdr.l_colormap_entries < xwdhdr.l_ncolors)
+        {
+          g_message (_("'%s':\nNumber of colormap entries < number of colors"),
+                     gimp_filename_to_utf8 (filename));
+          goto out;
+        }
+
       xwdcolmap = g_new (L_XWDCOLOR, xwdhdr.l_colormap_entries);
 
       read_xwd_cols (ifp, &xwdhdr, xwdcolmap);
@@@@ -482,9 +488,7 @@@@ load_image (const gchar  *filename,
       if (xwdhdr.l_file_version != 7)
         {
           g_message (_("Can't read color entries"));
-          g_free (xwdcolmap);
-          fclose (ifp);
-          return (-1);
+          goto out;
         }
     }
 
@@@@ -492,9 +496,7 @@@@ load_image (const gchar  *filename,
     {
       g_message (_("'%s':\nNo image width specified"),
                  gimp_filename_to_utf8 (filename));
-      g_free (xwdcolmap);
-      fclose (ifp);
-      return (-1);
+      goto out;
     }
 
   if (xwdhdr.l_pixmap_width > GIMP_MAX_IMAGE_SIZE
@@@@ -502,27 +504,21 @@@@ load_image (const gchar  *filename,
     {
       g_message (_("'%s':\nImage width is larger than GIMP can handle"),
                  gimp_filename_to_utf8 (filename));
-      g_free (xwdcolmap);
-      fclose (ifp);
-      return (-1);
+      goto out;
     }
 
   if (xwdhdr.l_pixmap_height <= 0)
     {
       g_message (_("'%s':\nNo image height specified"),
                  gimp_filename_to_utf8 (filename));
-      g_free (xwdcolmap);
-      fclose (ifp);
-      return (-1);
+      goto out;
     }
 
   if (xwdhdr.l_pixmap_height > GIMP_MAX_IMAGE_SIZE)
     {
       g_message (_("'%s':\nImage height is larger than GIMP can handle"),
                  gimp_filename_to_utf8 (filename));
-      g_free (xwdcolmap);
-      fclose (ifp);
-      return (-1);
+      goto out;
     }
 
   gimp_progress_init_printf (_("Opening '%s'"),
@@@@ -571,17 +567,23 @@@@ load_image (const gchar  *filename,
     }
   gimp_progress_update (1.0);
 
-  fclose (ifp);
-
-  if (xwdcolmap)
-    g_free (xwdcolmap);
-
   if (image_ID == -1 && ! (error && *error))
     g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                  _("XWD-file %s has format %d, depth %d and bits per pixel %d. "
                    "Currently this is not supported."),
                  gimp_filename_to_utf8 (filename),
                  (gint) xwdhdr.l_pixmap_format, depth, bpp);
+
+out:
+  if (ifp)
+    {
+      fclose (ifp);
+    }
+
+  if (xwdcolmap)
+    {
+      g_free (xwdcolmap);
+    }
 
   return image_ID;
 }
@


1.4
log
@
Bugfix update to 2.8.10
switch master_sites to http
@
text
@d1 1
a1 1
$OpenBSD: patch-plug-ins_common_file-xwd_c,v 1.3 2013/12/15 19:54:00 jasper Exp $
@


1.3
log
@Security fix for CVE-2013-1978
gimp: XWD plugin color map heap-based buffer overflow

ok giovanni@@ (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD$
d8 3
a10 3
--- plug-ins/common/file-xwd.c.orig	Thu Nov  8 00:19:16 2012
+++ plug-ins/common/file-xwd.c	Fri Dec  6 23:07:16 2013
@@@@ -422,9 +422,9 @@@@ static gint32
d22 1
a22 1
@@@@ -434,7 +434,7 @@@@ load_image (const gchar  *filename,
d31 1
a31 1
@@@@ -443,8 +443,7 @@@@ load_image (const gchar  *filename,
d41 1
a41 1
@@@@ -461,6 +460,13 @@@@ load_image (const gchar  *filename,
d55 1
a55 1
@@@@ -480,9 +486,7 @@@@ load_image (const gchar  *filename,
d66 1
a66 1
@@@@ -490,9 +494,7 @@@@ load_image (const gchar  *filename,
d77 1
a77 1
@@@@ -500,27 +502,21 @@@@ load_image (const gchar  *filename,
d108 1
a108 1
@@@@ -569,17 +565,23 @@@@ load_image (const gchar  *filename,
@


1.3.2.1
log
@Security fix for CVE-2013-1978
gimp: XWD plugin color map heap-based buffer overflow

ok giovanni@@ (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD: patch-plug-ins_common_file-xwd_c,v 1.3 2013/12/15 19:54:00 jasper Exp $
@


1.2
log
@
Bugfix update to 2.8.4 version
@
text
@d1 1
a1 1
$OpenBSD: patch-plug-ins_common_file-xwd_c,v 1.1 2012/11/27 12:12:41 jasper Exp $
d3 2
a4 4
From 2873262fccba12af144ed96ed91be144d92ff2e1 Mon Sep 17 00:00:00 2001
From: Michael Natterer <mitch@@gimp.org>
Date: Wed, 07 Nov 2012 23:16:31 +0000
Subject: Bug 687392 - Memory corruption vulnerability when reading XWD files
d6 1
a6 1
CVE-2012-5576
d8 49
a56 21
--- plug-ins/common/file-xwd.c.orig	Mon Mar 12 20:18:10 2012
+++ plug-ins/common/file-xwd.c	Tue Nov 27 10:06:22 2012
@@@@ -186,11 +186,13 @@@@ static gint32 load_xwd_f2_d16_b16 (const gchar *,
 static gint32 load_xwd_f2_d24_b32 (const gchar *,
                                    FILE *,
                                    L_XWDFILEHEADER *,
-                                   L_XWDCOLOR *);
+                                   L_XWDCOLOR *,
+                                   GError **);
 static gint32 load_xwd_f1_d24_b1  (const gchar *,
                                    FILE *,
                                    L_XWDFILEHEADER *,
-                                   L_XWDCOLOR *);
+                                   L_XWDCOLOR *,
+                                   GError **);
 
 static L_CARD32 read_card32  (FILE *,
                               gint *);
@@@@ -540,7 +542,8 @@@@ load_image (const gchar  *filename,
     case 1:    /* Single plane pixmap */
       if ((depth <= 24) && (bpp == 1))
d58 5
a62 3
-          image_ID = load_xwd_f1_d24_b1 (filename, ifp, &xwdhdr, xwdcolmap);
+          image_ID = load_xwd_f1_d24_b1 (filename, ifp, &xwdhdr, xwdcolmap,
+                                         error);
d64 1
a64 1
       break;
d66 29
a94 9
@@@@ -559,7 +562,8 @@@@ load_image (const gchar  *filename,
         }
       else if ((depth <= 24) && ((bpp == 24) || (bpp == 32)))
         {
-          image_ID = load_xwd_f2_d24_b32 (filename, ifp, &xwdhdr, xwdcolmap);
+          image_ID = load_xwd_f2_d24_b32 (filename, ifp, &xwdhdr, xwdcolmap,
+                                          error);
         }
       break;
a95 3
@@@@ -570,7 +574,7 @@@@ load_image (const gchar  *filename,
   if (xwdcolmap)
     g_free (xwdcolmap);
d97 9
a105 7
-  if (image_ID == -1)
+  if (image_ID == -1 && ! (error && *error))
     g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                  _("XWD-file %s has format %d, depth %d and bits per pixel %d. "
                    "Currently this is not supported."),
@@@@ -1624,10 +1628,11 @@@@ load_xwd_f2_d16_b16 (const gchar     *filename,
 /* Load XWD with pixmap_format 2, pixmap_depth up to 24, bits_per_pixel 24/32 */
d107 4
a110 16
 static gint32
-load_xwd_f2_d24_b32 (const gchar     *filename,
-                     FILE            *ifp,
-                     L_XWDFILEHEADER *xwdhdr,
-                     L_XWDCOLOR      *xwdcolmap)
+load_xwd_f2_d24_b32 (const gchar      *filename,
+                     FILE             *ifp,
+                     L_XWDFILEHEADER  *xwdhdr,
+                     L_XWDCOLOR       *xwdcolmap,
+                     GError          **error)
 {
   register guchar *dest, lsbyte_first;
   gint             width, height, linepad, i, j, c0, c1, c2, c3;
@@@@ -1652,12 +1657,6 @@@@ load_xwd_f2_d24_b32 (const gchar     *filename,
   width  = xwdhdr->l_pixmap_width;
   height = xwdhdr->l_pixmap_height;
d112 1
a112 2
-  image_ID = create_new_image (filename, width, height, GIMP_RGB,
-                               &layer_ID, &drawable, &pixel_rgn);
d114 2
a115 2
-  tile_height = gimp_tile_height ();
-  data = g_malloc (tile_height * width * 3);
d117 9
a125 10
   redmask   = xwdhdr->l_red_mask;
   greenmask = xwdhdr->l_green_mask;
   bluemask  = xwdhdr->l_blue_mask;
@@@@ -1685,6 +1684,22 @@@@ load_xwd_f2_d24_b32 (const gchar     *filename,
   maxblue = 0; while (bluemask >> (blueshift + maxblue)) maxblue++;
   maxblue = (1 << maxblue) - 1;
 
+  if (maxred   > sizeof (redmap)   ||
+      maxgreen > sizeof (greenmap) ||
+      maxblue  > sizeof (bluemap))
d127 1
a127 4
+      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                   _("XWD-file %s is corrupt."),
+                   gimp_filename_to_utf8 (filename));
+      return -1;
d130 4
a133 67
+  image_ID = create_new_image (filename, width, height, GIMP_RGB,
+                               &layer_ID, &drawable, &pixel_rgn);
+
+  tile_height = gimp_tile_height ();
+  data = g_malloc (tile_height * width * 3);
+
   /* Set map-arrays for red, green, blue */
   for (red = 0; red <= maxred; red++)
     redmap[red] = (red * 255) / maxred;
@@@@ -1825,10 +1840,11 @@@@ load_xwd_f2_d24_b32 (const gchar     *filename,
 /* Load XWD with pixmap_format 1, pixmap_depth up to 24, bits_per_pixel 1 */
 
 static gint32
-load_xwd_f1_d24_b1 (const gchar     *filename,
-                    FILE            *ifp,
-                    L_XWDFILEHEADER *xwdhdr,
-                    L_XWDCOLOR      *xwdcolmap)
+load_xwd_f1_d24_b1 (const gchar      *filename,
+                    FILE             *ifp,
+                    L_XWDFILEHEADER  *xwdhdr,
+                    L_XWDCOLOR       *xwdcolmap,
+                    GError          **error)
 {
   register guchar *dest, outmask, inmask, do_reverse;
   gint             width, height, i, j, plane, fromright;
@@@@ -1863,13 +1879,6 @@@@ load_xwd_f1_d24_b1 (const gchar     *filename,
   indexed         = (xwdhdr->l_pixmap_depth <= 8);
   bytes_per_pixel = (indexed ? 1 : 3);
 
-  image_ID = create_new_image (filename, width, height,
-                               indexed ? GIMP_INDEXED : GIMP_RGB,
-                               &layer_ID, &drawable, &pixel_rgn);
-
-  tile_height = gimp_tile_height ();
-  data = g_malloc (tile_height * width * bytes_per_pixel);
-
   for (j = 0; j < 256; j++)   /* Create an array for reversing bits */
     {
       inmask = 0;
@@@@ -1913,6 +1922,16 @@@@ load_xwd_f1_d24_b1 (const gchar     *filename,
       maxblue = 0; while (bluemask >> (blueshift + maxblue)) maxblue++;
       maxblue = (1 << maxblue) - 1;
 
+      if (maxred   > sizeof (redmap)   ||
+          maxgreen > sizeof (greenmap) ||
+          maxblue  > sizeof (bluemap))
+        {
+          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                       _("XWD-file %s is corrupt."),
+                       gimp_filename_to_utf8 (filename));
+          return -1;
+        }
+
       /* Set map-arrays for red, green, blue */
       for (red = 0; red <= maxred; red++)
         redmap[red] = (red * 255) / maxred;
@@@@ -1921,6 +1940,13 @@@@ load_xwd_f1_d24_b1 (const gchar     *filename,
       for (blue = 0; blue <= maxblue; blue++)
         bluemap[blue] = (blue * 255) / maxblue;
     }
+
+  image_ID = create_new_image (filename, width, height,
+                               indexed ? GIMP_INDEXED : GIMP_RGB,
+                               &layer_ID, &drawable, &pixel_rgn);
+
+  tile_height = gimp_tile_height ();
+  data = g_malloc (tile_height * width * bytes_per_pixel);
d135 2
a136 2
   ncols = xwdhdr->l_colormap_entries;
   if (xwdhdr->l_ncolors < ncols)
@


1.1
log
@Security fix for CVE-2012-5576,
Memory corruption vulnerability when reading XWD files

ok giovanni@@ (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD$
@

