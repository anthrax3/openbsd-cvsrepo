head	1.4;
access;
symbols
	OPENBSD_5_0:1.2.0.12
	OPENBSD_4_7:1.2.0.10
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_0:1.2.0.6
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_4:1.1.0.4
	OPENBSD_3_5:1.1.0.2;
locks; strict;
comment	@# @;


1.4
date	2012.02.26.14.57.54;	author naddy;	state dead;
branches;
next	1.3;

1.3
date	2012.02.17.15.44.13;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.20.01.24.11;	author brad;	state dead;
branches
	1.2.2.1
	1.2.4.1
	1.2.6.1
	1.2.8.1
	1.2.10.1
	1.2.12.1;
next	1.1;

1.1
date	2004.08.05.19.17.14;	author brad;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2004.08.05.19.32.37;	author brad;	state Exp;
branches;
next	;

1.1.4.1
date	2004.08.05.19.53.27;	author brad;	state Exp;
branches;
next	;

1.2.2.1
date	2006.07.02.15.30.43;	author sturm;	state Exp;
branches;
next	;

1.2.4.1
date	2006.07.02.15.31.23;	author sturm;	state Exp;
branches;
next	;

1.2.6.1
date	2007.05.20.17.36.02;	author sturm;	state Exp;
branches;
next	;

1.2.8.1
date	2007.05.20.17.39.24;	author sturm;	state Exp;
branches;
next	;

1.2.10.1
date	2010.07.22.02.31.07;	author william;	state Exp;
branches;
next	;

1.2.12.1
date	2011.09.24.23.43.05;	author william;	state Exp;
branches;
next	;


desc
@@


1.4
log
@update to 1.5.9
@
text
@$OpenBSD: patch-pngrutil_c,v 1.3 2012/02/17 15:44:13 sthen Exp $

CVE-2011-3026 libpng: Heap-buffer-overflow in png_decompress_chunk

--- pngrutil.c.orig	Thu Feb 16 10:01:56 2012
+++ pngrutil.c	Thu Feb 16 10:04:05 2012
@@@@ -457,8 +457,15 @@@@ png_decompress_chunk(png_structp png_ptr, int comp_typ
       {
          /* Success (maybe) - really uncompress the chunk. */
          png_size_t new_size = 0;
-         png_charp text = (png_charp)png_malloc_warn(png_ptr,
-             prefix_size + expanded_size + 1);
+         png_charp text = NULL;
+         /* Need to check for both truncation (64-bit platforms) and integer
+          * overflow.
+          */
+         if (prefix_size + expanded_size > prefix_size &&
+             prefix_size + expanded_size < 0xffffffffU)
+         {
+            text = png_malloc_warn(png_ptr, prefix_size + expanded_size + 1);
+         }
 
          if (text != NULL)
          {
@


1.3
log
@png SECURITY fix: CVE-2011-3026, heap-buffer-overflow in png_decompress_chunk
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@upgrade to png 1.2.7
@
text
@d1 21
a21 62
$OpenBSD: patch-pngrutil_c,v 1.1 2004/08/05 19:17:14 brad Exp $
--- pngrutil.c.orig	Thu Oct  3 07:32:30 2002
+++ pngrutil.c	Thu Aug  5 14:29:45 2004
@@@@ -38,6 +38,14 @@@@ __inline double strtod(const char *nptr,
 #  endif
 #endif
 
+png_uint_32 /* PRIVATE */
+png_get_uint_31(png_structp png_ptr, png_bytep buf)
+{
+   png_uint_32 i = png_get_uint_32(buf);
+   if (i > PNG_UINT_31_MAX)
+     png_error(png_ptr, "PNG unsigned integer out of range.\n");
+   return (i);
+}
 #ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
 /* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
 png_uint_32 /* PRIVATE */
@@@@ -579,7 +587,7 @@@@ png_handle_gAMA(png_structp png_ptr, png
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place gAMA chunk");
 
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
 #if defined(PNG_READ_sRGB_SUPPORTED)
       && !(info_ptr->valid & PNG_INFO_sRGB)
 #endif
@@@@ -660,7 +668,7 @@@@ png_handle_sBIT(png_structp png_ptr, png
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place sBIT chunk");
    }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
    {
       png_warning(png_ptr, "Duplicate sBIT chunk");
       png_crc_finish(png_ptr, length);
@@@@ -729,7 +737,7 @@@@ png_handle_cHRM(png_structp png_ptr, png
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Missing PLTE before cHRM");
 
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
 #if defined(PNG_READ_sRGB_SUPPORTED)
       && !(info_ptr->valid & PNG_INFO_sRGB)
 #endif
@@@@ -891,7 +899,7 @@@@ png_handle_sRGB(png_structp png_ptr, png
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place sRGB chunk");
 
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
    {
       png_warning(png_ptr, "Duplicate sRGB chunk");
       png_crc_finish(png_ptr, length);
@@@@ -977,8 +985,7 @@@@ png_handle_iCCP(png_structp png_ptr, png
    png_bytep pC;
    png_charp profile;
    png_uint_32 skip = 0;
-   png_uint_32 profile_size = 0;
-   png_uint_32 profile_length = 0;
+   png_uint_32 profile_size, profile_length;
    png_size_t slength, prefix_length, data_length;
d23 2
a24 40
    png_debug(1, "in png_handle_iCCP\n");
@@@@ -995,7 +1002,7 @@@@ png_handle_iCCP(png_structp png_ptr, png
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place iCCP chunk");
 
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
    {
       png_warning(png_ptr, "Duplicate iCCP chunk");
       png_crc_finish(png_ptr, length);
@@@@ -1154,8 +1161,18 @@@@ png_handle_sPLT(png_structp png_ptr, png
    }
 
    new_palette.nentries = data_length / entry_size;
-   new_palette.entries = (png_sPLT_entryp)png_malloc(
+   if (new_palette.nentries > PNG_SIZE_MAX / sizeof(png_sPLT_entry))
+   {
+       png_warning(png_ptr, "sPLT chunk too long");
+       return;
+   }
+   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(
        png_ptr, new_palette.nentries * sizeof(png_sPLT_entry));
+   if (new_palette.entries == NULL)
+   {
+       png_warning(png_ptr, "sPLT chunk requires too much memory");
+       return;
+   }
 
 #ifndef PNG_NO_POINTER_INDEXING
    for (i = 0; i < new_palette.nentries; i++)
@@@@ -1241,7 +1258,8 @@@@ png_handle_tRNS(png_structp png_ptr, png
          /* Should be an error, but we can cope with it */
          png_warning(png_ptr, "Missing PLTE before tRNS");
       }
-      else if (length > (png_uint_32)png_ptr->num_palette)
+      if (length > (png_uint_32)png_ptr->num_palette ||
+          length > PNG_MAX_PALETTE_LENGTH)
       {
          png_warning(png_ptr, "Incorrect tRNS chunk length");
          png_crc_finish(png_ptr, length);
@


1.2.12.1
log
@SECURITY FIX

Resolve CVE-2011-3328, from upstream

ok jasper sthen (who had the same diff)
@
text
@d1 30
a30 27
$OpenBSD$

Resolve CVE-2011-3328, from upstream


--- pngrutil.c.orig	Fri Sep 23 20:26:12 2011
+++ pngrutil.c	Fri Sep 23 20:27:28 2011
@@@@ -1037,12 +1037,15 @@@@ png_handle_cHRM(png_structp png_ptr, png_infop info_pt
           */
          png_uint_32 w = y_red + y_green + y_blue;
 
-         png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)(((png_uint_32)y_red *
-            32768)/w);
-         png_ptr->rgb_to_gray_green_coeff = (png_uint_16)(((png_uint_32)y_green
-            * 32768)/w);
-         png_ptr->rgb_to_gray_blue_coeff  = (png_uint_16)(((png_uint_32)y_blue *
-            32768)/w);
+         if (w != 0)
+         {
+            png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)(((png_uint_32)y_red *
+               32768)/w);
+            png_ptr->rgb_to_gray_green_coeff = (png_uint_16)(((png_uint_32)y_green
+               * 32768)/w);
+            png_ptr->rgb_to_gray_blue_coeff  = (png_uint_16)(((png_uint_32)y_blue *
+               32768)/w);
+         }
       }
d32 13
d46 58
@


1.2.10.1
log
@SECURITY FIX

Resolves CVE-2010-0205, CVE-2010-1205, and CVE-2010-2249

patches from upstream

started by stephan@@ and reads fine to kili@@ (thanks)
@
text
@d1 6
a6 14
$OpenBSD$

SECURITY FIX

Resolves CVE-2010-0205
code from #5 at http://libpng.sourceforge.net/decompression_bombs.html

Resolves CVE-2010-2249
code from upstream commit 90cfcecc09febb8d6c8c1d37ea7bb7cf0f4b00f3


--- pngrutil.c.orig	Thu Jul 15 20:08:55 2010
+++ pngrutil.c	Thu Jul 15 20:09:42 2010
@@@@ -217,180 +217,203 @@@@ png_crc_error(png_structp png_ptr)
d8 7
a14 206
 #if defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) || \
     defined(PNG_READ_iCCP_SUPPORTED)
-/*
- * Decompress trailing data in a chunk.  The assumption is that chunkdata
- * points at an allocated area holding the contents of a chunk with a
- * trailing compressed part.  What we get back is an allocated area
- * holding the original prefix part and an uncompressed version of the
- * trailing part (the malloc area passed in is freed).
- */
-void /* PRIVATE */
-png_decompress_chunk(png_structp png_ptr, int comp_type,
-                              png_size_t chunklength,
-                              png_size_t prefix_size, png_size_t *newlength)
+static png_size_t
+png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,
+	png_bytep output, png_size_t output_size)
 {
-   static PNG_CONST char msg[] = "Error decoding compressed chunk";
-   png_charp text;
-   png_size_t text_size;
+   png_size_t count = 0;
 
-   if (comp_type == PNG_COMPRESSION_TYPE_BASE)
+   png_ptr->zstream.next_in = (png_bytep)data; /* const_cast: VALID */
+   png_ptr->zstream.avail_in = size;
+
+   while (1)
    {
-      int ret = Z_OK;
-      png_ptr->zstream.next_in = (png_bytep)(png_ptr->chunkdata + prefix_size);
-      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);
+      int ret, avail;
+
+      /* Reset the output buffer each time round - we empty it
+       * after every inflate call.
+       */
       png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
+      png_ptr->zstream.avail_out = png_ptr->zbuf_size;
 
-      text_size = 0;
-      text = NULL;
+      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);
+      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;
 
-      while (png_ptr->zstream.avail_in)
+      /* First copy/count any new output - but only if we didn't
+       * get an error code.
+       */
+      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)
       {
-         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-         if (ret != Z_OK && ret != Z_STREAM_END)
-         {
-            if (png_ptr->zstream.msg != NULL)
-               png_warning(png_ptr, png_ptr->zstream.msg);
-            else
-               png_warning(png_ptr, msg);
-            inflateReset(&png_ptr->zstream);
-            png_ptr->zstream.avail_in = 0;
+         if (output != 0 && output_size > count)
+	 {
+	    int copy = output_size - count;
+	    if (avail < copy) copy = avail;
+	    png_memcpy(output + count, png_ptr->zbuf, copy);
+	 }
+         count += avail;
+      }
 
-            if (text ==  NULL)
-            {
-               text_size = prefix_size + png_sizeof(msg) + 1;
-               text = (png_charp)png_malloc_warn(png_ptr, text_size);
-               if (text ==  NULL)
-                 {
-                    png_free(png_ptr, png_ptr->chunkdata);
-                    png_ptr->chunkdata = NULL;
-                    png_error(png_ptr, "Not enough memory to decompress chunk");
-                 }
-               png_memcpy(text, png_ptr->chunkdata, prefix_size);
-            }
+      if (ret == Z_OK)
+         continue;
 
-            text[text_size - 1] = 0x00;
+      /* Termination conditions - always reset the zstream, it
+       * must be left in inflateInit state.
+       */
+      png_ptr->zstream.avail_in = 0;
+      inflateReset(&png_ptr->zstream);
 
-            /* Copy what we can of the error message into the text chunk */
-            text_size = (png_size_t)(chunklength -
-              (text - png_ptr->chunkdata) - 1);
-            if (text_size > png_sizeof(msg))
-               text_size = png_sizeof(msg);
-            png_memcpy(text + prefix_size, msg, text_size);
-            break;
-         }
-         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)
-         {
-            if (text == NULL)
-            {
-               text_size = prefix_size +
-                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-               text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);
-               if (text ==  NULL)
-               {
-                  png_free(png_ptr, png_ptr->chunkdata);
-                  png_ptr->chunkdata = NULL;
-                  png_error(png_ptr,
-                    "Not enough memory to decompress chunk.");
-               }
-               png_memcpy(text + prefix_size, png_ptr->zbuf,
-                    text_size - prefix_size);
-               png_memcpy(text, png_ptr->chunkdata, prefix_size);
-               *(text + text_size) = 0x00;
-            }
-            else
-            {
-               png_charp tmp;
+      if (ret == Z_STREAM_END)
+         return count; /* NOTE: may be zero. */
 
-               tmp = text;
-                  text = (png_charp)png_malloc_warn(png_ptr,
-                     (png_uint_32)(text_size +
-                      png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));
-               if (text == NULL)
-               {
-                  png_free(png_ptr, tmp);
-                  png_free(png_ptr, png_ptr->chunkdata);
-                  png_ptr->chunkdata = NULL;
-                  png_error(png_ptr,
-                    "Not enough memory to decompress chunk..");
-               }
-               png_memcpy(text, tmp, text_size);
-               png_free(png_ptr, tmp);
-               png_memcpy(text + text_size, png_ptr->zbuf,
-                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));
-               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-               *(text + text_size) = 0x00;
-            }
-            if (ret == Z_STREAM_END)
-               break;
-            else
-            {
-               png_ptr->zstream.next_out = png_ptr->zbuf;
-               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-            }
-         }
-      }
-      if (ret != Z_STREAM_END)
+      /* Now handle the error codes - the API always returns 0
+       * and the error message is dumped into the uncompressed
+       * buffer if available.
+       */
       {
-#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
+         PNG_CONST char *msg;
          char umsg[52];
+	 if (png_ptr->zstream.msg != 0)
+	    msg = png_ptr->zstream.msg;
+	 else
+	 {
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
+	    switch (ret)
+	    {
+	 case Z_BUF_ERROR:
+	    msg = "Buffer error in compressed datastream in %s chunk";
+	    break;
+	 case Z_DATA_ERROR:
+	    msg = "Data error in compressed datastream in %s chunk";
+	    break;
+	 default:
+	    msg = "Incomplete compressed datastream in %s chunk";
+	    break;
+	    }
 
-         if (ret == Z_BUF_ERROR)
-            png_snprintf(umsg, 52,
-                "Buffer error in compressed datastream in %s chunk",
-                png_ptr->chunk_name);
+	    png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);
+	    msg = umsg;
+#else
+	    msg = "Damaged compressed datastream in chunk other than IDAT";
+#endif
+	 }
 
-         else if (ret == Z_DATA_ERROR)
-            png_snprintf(umsg, 52,
-                "Data error in compressed datastream in %s chunk",
-                png_ptr->chunk_name);
+         png_warning(png_ptr, msg);
+      }
 
-         else
-            png_snprintf(umsg, 52,
-                "Incomplete compressed datastream in %s chunk",
-                png_ptr->chunk_name);
+      /* 0 means an error - notice that this code simple ignores
+       * zero length compressed chunks as a result.
+       */
+      return 0;
+   }
d16 64
a79 19
 
-         png_warning(png_ptr, umsg);
-#else
-         png_warning(png_ptr,
-            "Incomplete compressed datastream in chunk other than IDAT");
+/*
+ * Decompress trailing data in a chunk.  The assumption is that chunkdata
+ * points at an allocated area holding the contents of a chunk with a
+ * trailing compressed part.  What we get back is an allocated area
+ * holding the original prefix part and an uncompressed version of the
+ * trailing part (the malloc area passed in is freed).
+ */
+void /* PRIVATE */
+png_decompress_chunk(png_structp png_ptr, int comp_type,
+    png_size_t chunklength,
+    png_size_t prefix_size, png_size_t *newlength)
+{
+   /* The caller should guarantee this */
+   if (prefix_size > chunklength)
d81 2
a82 3
+      /* The recovery is to delete the chunk. */
+      png_warning(png_ptr, "invalid chunklength");
+      prefix_size = 0; /* To delete everything */
d84 3
a86 2
+
+   else if (comp_type == PNG_COMPRESSION_TYPE_BASE)
d88 2
a89 105
+      png_size_t expanded_size = png_inflate(png_ptr,
+		(png_bytep)(png_ptr->chunkdata + prefix_size),
+                chunklength - prefix_size,
+		0/*output*/, 0/*output size*/);
+
+#ifdef PNG_USER_CHUNK_MALLOC_MAX
+      /* Now check the limits on this chunk - if the limit fails the
+       * compressed data will be removed, the prefix will remain.
+       */
+      if ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
+          prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)
+         png_warning(png_ptr, "Exceeded size limit while expanding chunk");
+      /* If the size is zero either there was an error and a message
+       * has already been output (warning) or the size really is zero
+       * and we have nothing to do - the code will exit through the
+       * error case below.
+       */
+      else
 #endif
-         text_size = prefix_size;
-         if (text ==  NULL)
+      if (expanded_size > 0)
+      {
+         /* Success (maybe) - really uncompress the chunk. */
+	 png_size_t new_size = 0;
+	 png_charp text = png_malloc_warn(png_ptr,
+			prefix_size + expanded_size + 1);
+
+         if (text != NULL)
          {
-            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);
-            if (text == NULL)
-              {
-                png_free(png_ptr, png_ptr->chunkdata);
-                png_ptr->chunkdata = NULL;
-                png_error(png_ptr, "Not enough memory for text.");
-              }
-            png_memcpy(text, png_ptr->chunkdata, prefix_size);
-         }
-         *(text + text_size) = 0x00;
-      }
+	    png_memcpy(text, png_ptr->chunkdata, prefix_size);
+	    new_size = png_inflate(png_ptr,
+                (png_bytep)(png_ptr->chunkdata + prefix_size),
+		chunklength - prefix_size,
+                (png_bytep)(text + prefix_size), expanded_size);
+	    text[prefix_size + expanded_size] = 0; /* just in case */
 
-      inflateReset(&png_ptr->zstream);
-      png_ptr->zstream.avail_in = 0;
-
-      png_free(png_ptr, png_ptr->chunkdata);
-      png_ptr->chunkdata = text;
-      *newlength=text_size;
+	    if (new_size == expanded_size)
+	    {
+	       png_free(png_ptr, png_ptr->chunkdata);
+	       png_ptr->chunkdata = text;
+	       *newlength = prefix_size + expanded_size;
+	       return; /* The success return! */
+	    }
+      
+	    png_warning(png_ptr, "png_inflate logic error");
+	    png_free(png_ptr, text);
+	 }
+	 else
+          png_warning(png_ptr, "Not enough memory to decompress chunk.");
+      }
    }
+
    else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
    {
-#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
       char umsg[50];
 
-      png_snprintf(umsg, 50, "Unknown zTXt compression type %d", comp_type);
+#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
+      png_snprintf(umsg, sizeof umsg, "Unknown zTXt compression type %d", comp_type);
       png_warning(png_ptr, umsg);
 #else
       png_warning(png_ptr, "Unknown zTXt compression type");
 #endif
 
-      *(png_ptr->chunkdata + prefix_size) = 0x00;
-      *newlength = prefix_size;
+      /* The recovery is to simply drop the data. */
    }
+
+   /* Generic error return - leave the prefix, delete the compressed
+    * data, reallocate the chunkdata to remove the potentially large
+    * amount of compressed data.
+    */
+   {
+      png_charp text = png_malloc_warn(png_ptr, prefix_size + 1);
+      if (text != NULL)
+      {
+	 if (prefix_size > 0)
+            png_memcpy(text, png_ptr->chunkdata, prefix_size);
+	 png_free(png_ptr, png_ptr->chunkdata);
+	 png_ptr->chunkdata = text;
+
+	 /* This is an extra zero in the 'uncompressed' part. */
+	 *(png_ptr->chunkdata + prefix_size) = 0x00;
+      }
+      /* Ignore a malloc error here - it is safe. */
a90 4
+
+   *newlength = prefix_size;
 }
 #endif
d92 12
a103 60
@@@@ -1762,6 +1785,7 @@@@ png_handle_sCAL(png_structp png_ptr, png_infop info_pt
    if (png_ptr->chunkdata == NULL)
    {
       png_warning(png_ptr, "Out of memory while processing sCAL chunk");
+      png_crc_finish(png_ptr, length);
       return;
    }
    slength = (png_size_t)length;
@@@@ -1783,6 +1807,8 @@@@ png_handle_sCAL(png_structp png_ptr, png_infop info_pt
    if (*vp)
    {
       png_warning(png_ptr, "malformed width string in sCAL chunk");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
 #else
@@@@ -1791,6 +1817,8 @@@@ png_handle_sCAL(png_structp png_ptr, png_infop info_pt
    if (swidth == NULL)
    {
       png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
       return;
    }
    png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));
@@@@ -1804,8 +1832,7 @@@@ png_handle_sCAL(png_structp png_ptr, png_infop info_pt
    if (png_ptr->chunkdata + slength < ep)
    {
       png_warning(png_ptr, "Truncated sCAL chunk");
-#if defined(PNG_FIXED_POINT_SUPPORTED) && \
-    !defined(PNG_FLOATING_POINT_SUPPORTED)
+#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
       png_free(png_ptr, swidth);
 #endif
       png_free(png_ptr, png_ptr->chunkdata);
@@@@ -1818,6 +1845,11 @@@@ png_handle_sCAL(png_structp png_ptr, png_infop info_pt
    if (*vp)
    {
       png_warning(png_ptr, "malformed height string in sCAL chunk");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
+      png_free(png_ptr, swidth);
+#endif
       return;
    }
 #else
@@@@ -1826,6 +1858,11 @@@@ png_handle_sCAL(png_structp png_ptr, png_infop info_pt
    if (sheight == NULL)
    {
       png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
+      png_free(png_ptr, swidth);
+#endif
       return;
    }
    png_memcpy(sheight, ep, (png_size_t)png_strlen(ep));
@


1.2.8.1
log
@Fix a NULL pointer dereference vulnerability involving palette
images with a malformed tRNS chunk (CVE-2007-2445).

from steven
@
text
@d1 30
a30 4
$OpenBSD$
--- pngrutil.c.orig	Sun May 20 19:36:46 2007
+++ pngrutil.c	Sun May 20 19:37:14 2007
@@@@ -1314,7 +1314,10 @@@@ png_handle_tRNS(png_structp png_ptr, png
d32 36
d69 18
a86 1
    if (png_crc_finish(png_ptr, 0))
d88 2
a89 2
+      png_ptr->num_trans = 0;
       return;
d92 12
a103 2
    png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
       &(png_ptr->trans_values));
@


1.2.6.1
log
@Fix a NULL pointer dereference vulnerability involving palette
images with a malformed tRNS chunk (CVE-2007-2445).

from steven
@
text
@d1 30
a30 4
$OpenBSD$
--- pngrutil.c.orig	Sun May 20 19:29:32 2007
+++ pngrutil.c	Sun May 20 19:30:09 2007
@@@@ -1311,7 +1311,10 @@@@ png_handle_tRNS(png_structp png_ptr, png
d32 36
d69 18
a86 1
    if (png_crc_finish(png_ptr, 0))
d88 2
a89 2
+      png_ptr->num_trans = 0;
       return;
d92 12
a103 2
    png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
       &(png_ptr->trans_values));
@


1.2.4.1
log
@MFC:
Fixes a buffer overflow vulnerability.

More information:
http://www.securityfocus.com/bid/18698/
@
text
@d1 100
a100 5
$OpenBSD$
--- pngrutil.c.orig	Sun Jul  2 17:11:19 2006
+++ pngrutil.c	Sun Jul  2 17:11:33 2006
@@@@ -275,7 +275,7 @@@@ png_decompress_chunk(png_structp png_ptr
       if (ret != Z_STREAM_END)
d102 2
a103 6
 #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
-         char umsg[50];
+         char umsg[52];
 
          if (ret == Z_BUF_ERROR)
             sprintf(umsg,"Buffer error in compressed datastream in %s chunk",
@


1.2.2.1
log
@MFC:
Fixes a buffer overflow vulnerability.

More information:
http://www.securityfocus.com/bid/18698/
@
text
@d1 100
a100 5
$OpenBSD$
--- pngrutil.c.orig	Sun Jul  2 17:11:19 2006
+++ pngrutil.c	Sun Jul  2 17:11:33 2006
@@@@ -275,7 +275,7 @@@@ png_decompress_chunk(png_structp png_ptr
       if (ret != Z_STREAM_END)
d102 2
a103 6
 #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
-         char umsg[50];
+         char umsg[52];
 
          if (ret == Z_BUF_ERROR)
             sprintf(umsg,"Buffer error in compressed datastream in %s chunk",
@


1.1
log
@Add pieces of the libpng jumbo security patch not already in the port.

http://www.us-cert.gov/cas/techalerts/TA04-217A.html
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.4.1
log
@Add pieces of the libpng jumbo security patch not already in the port.

http://www.us-cert.gov/cas/techalerts/TA04-217A.html
@
text
@d1 1
a1 1
$OpenBSD: patch-pngrutil_c,v 1.1 2004/08/05 19:17:14 brad Exp $
@


1.1.2.1
log
@Add pieces of the libpng jumbo security patch not already in the port.

http://www.us-cert.gov/cas/techalerts/TA04-217A.html
@
text
@d1 1
a1 1
$OpenBSD: patch-pngrutil_c,v 1.1 2004/08/05 19:17:14 brad Exp $
@

