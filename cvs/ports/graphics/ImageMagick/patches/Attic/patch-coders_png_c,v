head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.14
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.10
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@# @;


1.12
date	2015.11.06.20.37.21;	author sthen;	state dead;
branches;
next	1.11;
commitid	FPc2cn4cBl8iHChc;

1.11
date	2012.08.28.15.20.21;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.19.12.46.12;	author sthen;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2012.06.12.17.40.35;	author okan;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.06.22.43.00;	author kili;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.29.05.00.20;	author okan;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.20.13.29.56;	author okan;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.19.18.46.55;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.20.19.44.47;	author steven;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.08.15.22.50;	author steven;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.31.04.23.42;	author pvalchev;	state dead;
branches;
next	1.1;

1.1
date	2004.08.13.06.17.41;	author brad;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2004.12.30.19.31.15;	author sturm;	state Exp;
branches;
next	;

1.10.2.1
date	2012.08.28.15.21.07;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.12
log
@update to ImageMagick 6.9.2-5
- dependent ports will be fixed in the following commit
@
text
@$OpenBSD: patch-coders_png_c,v 1.11 2012/08/28 15:20:21 jasper Exp $

Security fix for CVE-2012-3437, ImageMagick: Magick_png_malloc() size argument

Patch from upstream svn:
http://trac.imagemagick.org/changeset/8733/ImageMagick/trunk/coders/png.c

--- coders/png.c.orig	Thu Jun  7 13:50:28 2012
+++ coders/png.c	Fri Aug 24 21:52:35 2012
@@@@ -1809,7 +1809,11 @@@@ static void MagickPNGWarningHandler(png_struct *ping,p
 }
 
 #ifdef PNG_USER_MEM_SUPPORTED
-static png_voidp Magick_png_malloc(png_structp png_ptr,png_uint_32 size)
+#if PNG_LIBPNG_VER >= 14000
+static png_voidp Magick_png_malloc(png_structp png_ptr,png_alloc_size_t size)
+#else
+static png_voidp Magick_png_malloc(png_structp png_ptr,png_size_t size)
+#endif
 {
   (void) png_ptr;
   return((png_voidp) AcquireMagickMemory((size_t) size));
@@@@ -2254,7 +2258,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
 
 #if (PNG_LIBPNG_VER < 10400)
 #  if defined(PNG_USE_PNGGCCRD) && defined(PNG_ASSEMBLER_CODE_SUPPORTED) && \
-   (PNG_LIBPNG_VER >= 10200) && (PNG_LIBPNG_VER < 10220) && defined(__i386__)
+   (PNG_LIBPNG_VER >= 10200) && (PNG_LIBPNG_VER < 10220) && defined(PNG_MMX_CODE_SUPPORTED)
   /* Disable thread-unsafe features of pnggccrd */
   if (png_access_version_number() >= 10200)
   {
@@@@ -7341,12 +7345,22 @@@@ Magick_png_write_raw_profile(const ImageInfo *image_in
          (char *) profile_type, (double) length);
      }
 
-   text=(png_textp) png_malloc(ping,(png_uint_32) sizeof(png_text));
+#if PNG_LIBPNG_VER >= 14000
+   text=(png_textp) png_malloc(ping,(png_alloc_size_t) sizeof(png_text));
+#else
+   text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));
+#endif
    description_length=(png_uint_32) strlen((const char *) profile_description);
    allocated_length=(png_uint_32) (length*2 + (length >> 5) + 20
       + description_length);
-   text[0].text=(png_charp) png_malloc(ping,allocated_length);
-   text[0].key=(png_charp) png_malloc(ping, (png_uint_32) 80);
+#if PNG_LIBPNG_VER >= 14000
+   text[0].text=(png_charp) png_malloc(ping,
+      (png_alloc_size_t) allocated_length);
+   text[0].key=(png_charp) png_malloc(ping, (png_alloc_size_t) 80);
+#else
+   text[0].text=(png_charp) png_malloc(ping, (png_size_t) allocated_length);
+   text[0].key=(png_charp) png_malloc(ping, (png_size_t) 80);
+#endif
    text[0].key[0]='\0';
    (void) ConcatenateMagickString(text[0].key,
       "Raw profile type ",MaxTextExtent);
@@@@ -10691,7 +10705,12 @@@@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng
         {
         if (value != (const char *) NULL)
           {
-            text=(png_textp) png_malloc(ping,(png_uint_32) sizeof(png_text));
+#if PNG_LIBPNG_VER >= 14000
+            text=(png_textp) png_malloc(ping,
+                 (png_alloc_size_t) sizeof(png_text));
+#else
+            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));
+#endif
             text[0].key=(char *) property;
             text[0].text=(char *) value;
             text[0].text_length=strlen(value);
@


1.11
log
@Security fix for CVE-2012-3437, ImageMagick: Magick_png_malloc() size argument
@
text
@d1 1
a1 1
$OpenBSD: patch-coders_png_c,v 1.10 2012/06/19 12:46:12 sthen Exp $
@


1.10
log
@revise pkgconfig files for ImageMagick to add -pthread and -L/usr/X11R6/lib
may not all be necessary, but this unbreaks things and we can revise later

with okan@@ and naddy@@, ok okan@@
@
text
@d1 23
a23 4
$OpenBSD: patch-coders_png_c,v 1.9 2012/06/12 17:40:35 okan Exp $
--- coders/png.c.orig	Thu Jun  7 12:50:28 2012
+++ coders/png.c	Mon Jun 18 22:44:21 2012
@@@@ -2254,7 +2254,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
d32 40
@


1.10.2.1
log
@Security fix for CVE-2012-3437, ImageMagick: Magick_png_malloc() size argument
@
text
@d1 4
a4 23
$OpenBSD: patch-coders_png_c,v 1.11 2012/08/28 15:20:21 jasper Exp $

Security fix for CVE-2012-3437, ImageMagick: Magick_png_malloc() size argument

Patch from upstream svn:
http://trac.imagemagick.org/changeset/8733/ImageMagick/trunk/coders/png.c

--- coders/png.c.orig	Thu Jun  7 13:50:28 2012
+++ coders/png.c	Fri Aug 24 21:52:35 2012
@@@@ -1809,7 +1809,11 @@@@ static void MagickPNGWarningHandler(png_struct *ping,p
 }
 
 #ifdef PNG_USER_MEM_SUPPORTED
-static png_voidp Magick_png_malloc(png_structp png_ptr,png_uint_32 size)
+#if PNG_LIBPNG_VER >= 14000
+static png_voidp Magick_png_malloc(png_structp png_ptr,png_alloc_size_t size)
+#else
+static png_voidp Magick_png_malloc(png_structp png_ptr,png_size_t size)
+#endif
 {
   (void) png_ptr;
   return((png_voidp) AcquireMagickMemory((size_t) size));
@@@@ -2254,7 +2258,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
a12 40
@@@@ -7341,12 +7345,22 @@@@ Magick_png_write_raw_profile(const ImageInfo *image_in
          (char *) profile_type, (double) length);
      }
 
-   text=(png_textp) png_malloc(ping,(png_uint_32) sizeof(png_text));
+#if PNG_LIBPNG_VER >= 14000
+   text=(png_textp) png_malloc(ping,(png_alloc_size_t) sizeof(png_text));
+#else
+   text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));
+#endif
    description_length=(png_uint_32) strlen((const char *) profile_description);
    allocated_length=(png_uint_32) (length*2 + (length >> 5) + 20
       + description_length);
-   text[0].text=(png_charp) png_malloc(ping,allocated_length);
-   text[0].key=(png_charp) png_malloc(ping, (png_uint_32) 80);
+#if PNG_LIBPNG_VER >= 14000
+   text[0].text=(png_charp) png_malloc(ping,
+      (png_alloc_size_t) allocated_length);
+   text[0].key=(png_charp) png_malloc(ping, (png_alloc_size_t) 80);
+#else
+   text[0].text=(png_charp) png_malloc(ping, (png_size_t) allocated_length);
+   text[0].key=(png_charp) png_malloc(ping, (png_size_t) 80);
+#endif
    text[0].key[0]='\0';
    (void) ConcatenateMagickString(text[0].key,
       "Raw profile type ",MaxTextExtent);
@@@@ -10691,7 +10705,12 @@@@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng
         {
         if (value != (const char *) NULL)
           {
-            text=(png_textp) png_malloc(ping,(png_uint_32) sizeof(png_text));
+#if PNG_LIBPNG_VER >= 14000
+            text=(png_textp) png_malloc(ping,
+                 (png_alloc_size_t) sizeof(png_text));
+#else
+            text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));
+#endif
             text[0].key=(char *) property;
             text[0].text=(char *) value;
             text[0].text_length=strlen(value);
@


1.9
log
@update to 6.7.7.7

feedback and ok giovanni@@
@
text
@d1 4
a4 4
$OpenBSD: patch-coders_png_c,v 1.8 2011/07/06 22:43:00 kili Exp $
--- coders/png.c.orig	Thu May 17 16:47:50 2012
+++ coders/png.c	Sun May 20 20:17:39 2012
@@@@ -2217,7 +2217,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
@


1.8
log
@Update to ImageMagick-6.6.6-10, with help from Brad.

An update to a more recent version (6.7.*) will follow soon.

This helps naddy with the png update.
@
text
@d1 4
a4 4
$OpenBSD: patch-coders_png_c,v 1.7 2008/11/29 05:00:20 okan Exp $
--- coders/png.c.orig	Fri Dec 24 19:00:33 2010
+++ coders/png.c	Sat Jan  1 23:06:23 2011
@@@@ -1786,7 +1786,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
@


1.7
log
@- update to 6.4.5-6 (for real this time) and sync patches
- explicitly disable lqr (experimental liquid rescale)
- fix for building no_x11 FLAVOR with ImageMagick already installed

noticed by and previous ok kili@@, ok naddy@@
@
text
@d1 4
a4 6
$OpenBSD: patch-coders_png_c,v 1.6 2008/11/20 13:29:56 okan Exp $
--- coders/png.c.orig	Tue Nov 11 20:58:15 2008
+++ coders/png.c	Thu Nov 20 14:38:55 2008
@@@@ -1783,7 +1783,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
   png_set_read_user_chunk_fn(ping, image, read_vpag_chunk_callback);
 #endif
d6 4
a9 2
-#if defined(PNG_USE_PNGGCCRD) && defined(PNG_ASSEMBLER_CODE_SUPPORTED) && (PNG_LIBPNG_VER >= 10200) && defined(__i386__)
+#if defined(PNG_USE_PNGGCCRD) && defined(PNG_ASSEMBLER_CODE_SUPPORTED) && (PNG_LIBPNG_VER >= 10200) && defined(PNG_MMX_CODE_SUPPORTED)
@


1.6
log
@- long awaited update ImageMagick to 6.4.5-6
- now includes perl modules, superseding graphics/p5-PerlMagick

feedback from ajacoutot@@, kili@@ and naddy@@ (and bulk)

ok kili@@
@
text
@d1 4
a4 4
$OpenBSD: patch-coders_png_c,v 1.5 2007/09/19 18:46:55 sthen Exp $
--- coders/png.c.orig	Sun Oct 12 13:38:07 2008
+++ coders/png.c	Tue Oct 21 09:25:45 2008
@@@@ -1770,7 +1770,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
@


1.5
log
@update to 6.3.5-9 from Giovanni Bechis; this fixes various bugs
including a number of security vulnerabilities; see
http://www.imagemagick.org/script/changelog.php

ok merdely@@
@
text
@d1 4
a4 4
$OpenBSD: patch-coders_png_c,v 1.4 2007/05/20 19:44:47 steven Exp $
--- coders/png.c.orig	Mon Sep 17 22:18:06 2007
+++ coders/png.c	Mon Sep 17 22:18:35 2007
@@@@ -1763,7 +1763,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
@


1.4
log
@update to 6.3.4.1

feedback/ok kili@@
@
text
@d1 4
a4 4
$OpenBSD: patch-coders_png_c,v 1.3 2007/04/08 15:22:50 steven Exp $
--- coders/png.c.orig	Sat May  5 02:42:11 2007
+++ coders/png.c	Wed May 16 17:41:56 2007
@@@@ -1768,7 +1768,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
@


1.3
log
@unbreak build with latest png, regen patches.  "get it in" naddy@@
@
text
@d1 4
a4 4
$OpenBSD$
--- coders/png.c.orig	Sun Apr  8 09:39:25 2007
+++ coders/png.c	Sun Apr  8 09:40:09 2007
@@@@ -1756,7 +1756,7 @@@@ static Image *ReadOnePNGImage(MngInfo *mng_info,
@


1.2
log
@update to ImageMagick-6.2.0-8; Bernd Ahlers <b.ahlers@@ba-net.org>
@
text
@d1 6
a6 6
$OpenBSD: patch-coders_png_c,v 1.1 2004/08/13 06:17:41 brad Exp $
--- coders/png.c.orig	Thu Aug 12 22:54:19 2004
+++ coders/png.c	Thu Aug 12 23:04:05 2004
@@@@ -1372,6 +1372,8 @@@@ static void PNGErrorHandler(png_struct *
   Image
     *image;
d8 2
a9 38
+  if (LocaleCompare(message, "Missing PLTE before tRNS") == 0)
+    png_error(ping, message);
   image=(Image *) png_get_error_ptr(ping);
   if (image->debug != False)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
@@@@ -1600,6 +1602,20 @@@@ static Image *ReadOnePNGImage(MngInfo *m
     length,
     row_offset;
 
+#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+  png_byte unused_chunks[]=
+       {
+        104,  73,  83,  84, '\0',   /* hIST */
+        105,  84,  88, 116, '\0',   /* iTXt */
+        112,  67,  65,  76, '\0',   /* pCAL */
+        115,  67,  65,  76, '\0',   /* sCAL */
+        115,  80,  76,  84, '\0',   /* sPLT */
+        116,  69,  88, 116, '\0',   /* tEXt */
+        116,  73,  77,  69, '\0',   /* tIME */
+        122,  84,  88, 116, '\0',   /* zTXt */
+        };
+#endif
+
   logging=LogMagickEvent(CoderEvent,GetMagickModule(),
       "  enter ReadOnePNGImage()");
 
@@@@ -1685,6 +1701,12 @@@@ static Image *ReadOnePNGImage(MngInfo *m
   else
     png_set_read_fn(ping,image,png_get_data);
 
+#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+  /* Ignore unused chunks */
+  png_set_keep_unknown_chunks(ping, 0, unused_chunks,
+     (int)sizeof(unused_chunks)/5);
+#endif
+
 #if defined(PNG_USE_PNGGCCRD) && defined(PNG_ASSEMBLER_CODE_SUPPORTED) \
 && (PNG_LIBPNG_VER >= 10200)
d11 2
a12 18
@@@@ -2551,7 +2573,7 @@@@ static Image *ReadOnePNGImage(MngInfo *m
             *value;
 
           length=text[i].text_length;
-          value=(char *) AcquireMagickMemory(length+1);
+          value=(char *) AcquireMagickMemory(length+MaxTextExtent);
           if (value == (char *) NULL)
             {
               (void) ThrowMagickException(&image->exception,GetMagickModule(),
@@@@ -2623,6 +2645,8 @@@@ static Image *ReadOnePNGImage(MngInfo *m
               image->filename);
           png_get_IHDR(ping,ping_info,&width,&height,&bit_depth,&color_type,
             &interlace_method,&compression_method,&filter_method);
+          if (width > 250000L || height > 250000L)
+             png_error(ping,"PNG Image dimensions are too large.");
           mng_info->ob[object_id]->width=width;
           mng_info->ob[object_id]->height=height;
           mng_info->ob[object_id]->color_type=color_type;
@


1.1
log
@PNG vulnerability fix.

http://www.imagemagick.org/www/Changelog.html

ok pvalchev@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.4.1
log
@MFC:

PNG vulnerability fix.

http://www.imagemagick.org/www/Changelog.html

and

- Don't allow a corrupt GIF image to overflow pixel stack
- Prevent buffer overruns when decoding runlength-encoded images in the BMP format

ok brad@@
@
text
@d2 3
a4 3
--- coders/png.c.orig	2004-12-27 21:04:32.000000000 +0100
+++ coders/png.c	2004-12-27 21:24:19.000000000 +0100
@@@@ -1125,6 +1125,8 @@@@ static void PNGErrorHandler(png_struct *
d10 6
a15 6
   image=(Image *) ping->error_ptr;
 #ifdef PNG_DEBUG
   printf("libpng-%s error: %s\n", PNG_LIBPNG_VER_STRING, message);
@@@@ -1273,6 +1275,20 @@@@ static Image *ReadPNGImage(const ImageIn
     png_textp
       text;
d19 10
a28 10
+    {
+     104,  73,  83,  84, '\0',   /* hIST */
+     105,  84,  88, 116, '\0',   /* iTXt */
+     112,  67,  65,  76, '\0',   /* pCAL */
+     115,  67,  65,  76, '\0',   /* sCAL */
+     115,  80,  76,  84, '\0',   /* sPLT */
+     116,  69,  88, 116, '\0',   /* tEXt */
+     116,  73,  77,  69, '\0',   /* tIME */
+     122,  84,  88, 116, '\0',   /* zTXt */
+    };
d31 7
a37 8
   /*
     Open image file.
   */
@@@@ -2426,6 +2442,13 @@@@ static Image *ReadPNGImage(const ImageIn
       }
     else
       png_set_read_fn(ping,image,png_get_data);
+
d39 3
a41 3
+    /* Ignore unused chunks */
+    png_set_keep_unknown_chunks(ping, 0, unused_chunks,
+      (int)sizeof(unused_chunks)/5);
d44 5
a48 5
     png_read_info(ping,ping_info);
     image->depth=ping_info->bit_depth;
     if (ping_info->bit_depth < 8)
@@@@ -3108,7 +3131,7 @@@@ static Image *ReadPNGImage(const ImageIn
           *value;
d50 15
a64 15
         length=text[i].text_length;
-        value=(char *) AcquireMemory(length+1);
+        value=(char *) AcquireMemory(length+MaxTextExtent);
         if (value == (char *) NULL)
           {
             ThrowException(&image->exception,ResourceLimitWarning,
@@@@ -3174,6 +3197,8 @@@@ static Image *ReadPNGImage(const ImageIn
                 "Cloning image for object buffer failed",image->filename);
             png_get_IHDR(ping,ping_info,&width,&height,&bit_depth,&color_type,
               &interlace_method,&compression_method,&filter_method);
+            if (width > 250000L || height > 250000L)
+              png_error(ping,"PNG Image dimensions are too large.");
             mng_info->ob[object_id]->width=width;
             mng_info->ob[object_id]->height=height;
             mng_info->ob[object_id]->color_type=color_type;
@

