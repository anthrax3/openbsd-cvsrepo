head	1.2;
access;
symbols
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_5:1.1.0.2;
locks; strict;
comment	@# @;


1.2
date	2005.03.31.04.23.42;	author pvalchev;	state dead;
branches;
next	1.1;

1.1
date	2004.09.21.18.39.15;	author brad;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2004.12.30.19.31.15;	author sturm;	state Exp;
branches;
next	;

1.1.4.1
date	2004.12.30.19.37.18;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to ImageMagick-6.2.0-8; Bernd Ahlers <b.ahlers@@ba-net.org>
@
text
@$OpenBSD: patch-coders_bmp_c,v 1.1 2004/09/21 18:39:15 brad Exp $
--- coders/bmp.c.orig	Fri Apr  9 19:13:24 2004
+++ coders/bmp.c	Tue Sep 21 04:05:37 2004
@@@@ -178,6 +178,7 @@@@ static unsigned int DecodeImage(Image *i
     x;
 
   register unsigned char
+    *p,
     *q;
 
   unsigned char
@@@@ -191,9 +192,12 @@@@ static unsigned int DecodeImage(Image *i
   (void) ResetMagickMemory(pixels,0,(size_t) image->columns*image->rows);
   byte=0;
   x=0;
-  q=pixels;
+  p=pixels;
+  q=pixels+(size_t) image->columns*image->rows;
   for (y=0; y < (long) image->rows; )
   {
+    if ((p < pixels) || (p >= q))
+      break;
     count=ReadBlobByte(image);
     if (count == EOF)
       break;
@@@@ -202,16 +206,17 @@@@ static unsigned int DecodeImage(Image *i
         /*
           Encoded mode.
         */
+        count=Min(count,q-p);
         byte=(unsigned char) ReadBlobByte(image);
         if (compression == BI_RLE8)
           {
             for (i=count; i != 0; i--)
-              *q++=(unsigned char) byte;
+              *p++=(unsigned char) byte;
           }
         else
           {
             for (i=0; i < count; i++)
-              *q++=(unsigned char)
+              *p++=(unsigned char)
                 ((i & 0x01) != 0 ? (byte & 0x0f) : ((byte >> 4) & 0x0f));
           }
         x+=count;
@@@@ -233,7 +238,7 @@@@ static unsigned int DecodeImage(Image *i
             */
             x=0;
             y++;
-            q=pixels+y*image->columns;
+            p=pixels+y*image->columns;
             break;
           }
           case 0x02:
@@@@ -243,7 +248,7 @@@@ static unsigned int DecodeImage(Image *i
             */
             x+=ReadBlobByte(image);
             y+=ReadBlobByte(image);
-            q=pixels+y*image->columns+x;
+            p=pixels+y*image->columns+x;
             break;
           }
           default:
@@@@ -251,15 +256,16 @@@@ static unsigned int DecodeImage(Image *i
             /*
               Absolute mode.
             */
+            count=Min(count,q-p);
             if (compression == BI_RLE8)
               for (i=(long) count; i != 0; --i)
-                *q++=(unsigned char) ReadBlobByte(image);
+                *p++=(unsigned char) ReadBlobByte(image);
             else
               for (i=0; i < count; i++)
               {
                 if ((i & 0x01) == 0)
                   byte=(unsigned char) ReadBlobByte(image);
-                *q++=(unsigned char)
+                *p++=(unsigned char)
                   ((i & 0x01) != 0 ? (byte & 0x0f) : ((byte >> 4) & 0x0f));
               }
             x+=count;
@


1.1
log
@- Don't allow a corrupt GIF image to overflow pixel stack
- Prevent buffer overruns when decoding runlength-encoded images in the BMP format
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.4.1
log
@MFC:

- Don't allow a corrupt GIF image to overflow pixel stack
- Prevent buffer overruns when decoding runlength-encoded images in the BMP format

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-coders_bmp_c,v 1.1 2004/09/21 18:39:15 brad Exp $
@


1.1.2.1
log
@MFC:

PNG vulnerability fix.

http://www.imagemagick.org/www/Changelog.html

and

- Don't allow a corrupt GIF image to overflow pixel stack
- Prevent buffer overruns when decoding runlength-encoded images in the BMP format

ok brad@@
@
text
@d2 3
a4 3
--- coders/bmp.c.orig	2004-12-27 20:48:34.000000000 +0100
+++ coders/bmp.c	2004-12-27 20:53:50.000000000 +0100
@@@@ -151,6 +151,7 @@@@ static unsigned int DecodeImage(Image *i
d11 3
a13 3
   assert(image != (Image *) NULL);
@@@@ -159,9 +160,12 @@@@ static unsigned int DecodeImage(Image *i
     pixels[i]=0;
d19 1
a19 1
   for (y=0; y < (int) image->rows; )
d26 1
a26 1
@@@@ -170,13 +174,14 @@@@ static unsigned int DecodeImage(Image *i
d31 16
a46 13
         byte=ReadBlobByte(image);
         for (i=0; i < count; i++)
         {
           if (compression == 1)
-            *q++=(unsigned char) byte;
+            *p++=(unsigned char) byte;
           else
-            *q++=(i & 0x01) ? (byte & 0x0f) : ((byte >> 4) & 0x0f);
+            *p++=(i & 0x01) ? (byte & 0x0f) : ((byte >> 4) & 0x0f);
           x++;
         }
       }
@@@@ -197,7 +202,7 @@@@ static unsigned int DecodeImage(Image *i
d55 1
a55 1
@@@@ -207,7 +212,7 @@@@ static unsigned int DecodeImage(Image *i
d64 1
a64 1
@@@@ -215,15 +220,16 @@@@ static unsigned int DecodeImage(Image *i
d69 14
a82 14
             for (i=0; i < count; i++)
             {
               if (compression == 1)
-                *q++=ReadBlobByte(image);
+                *p++=ReadBlobByte(image);
               else
                 {
                   if ((i & 0x01) == 0)
                     byte=ReadBlobByte(image);
-                  *q++=(i & 0x01) ? (byte & 0x0f) : ((byte >> 4) & 0x0f);
+                  *p++=(i & 0x01) ? (byte & 0x0f) : ((byte >> 4) & 0x0f);
                 }
               x++;
             }
@

