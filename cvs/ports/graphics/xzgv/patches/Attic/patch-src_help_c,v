head	1.3;
access;
symbols
	OPENBSD_4_5:1.2.0.8
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.6
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.1.1.1.0.8
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.6
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.4
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.2
	OPENBSD_3_8_BASE:1.1.1.1
	alek_20050522:1.1.1.1
	alek:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2009.03.06.08.54.22;	author jasper;	state dead;
branches;
next	1.2;

1.2
date	2007.07.17.12.45.49;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.22.11.32.11;	author alek;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.05.22.11.32.11;	author alek;	state Exp;
branches;
next	;


desc
@@


1.3
log
@- update xzgv to 0.9
* this makes this port switch to gtk+2, and get ride of ancient gtk+1
- update ${HOMEPAGE} and ${MASTER_SITES}

from Julian Leyh (MAINTAINER), thanks
@
text
@$OpenBSD: patch-src_help_c,v 1.2 2007/07/17 12:45:49 ajacoutot Exp $
--- src/help.c.orig	Tue Sep 16 16:07:44 2003
+++ src/help.c	Tue Jul 17 14:26:29 2007
@@@@ -84,8 +84,9 @@@@ void help_run(char *node)
 char *cmd_start="xterm -e info '(xzgv)";
 char *cmd_end="' &";
 char *buf;
+int siz = strlen(cmd_start)+strlen(node)+strlen(cmd_end)+1;
 
-if((buf=malloc(strlen(cmd_start)+strlen(node)+strlen(cmd_end)+1))==NULL)
+if((buf=malloc(siz))==NULL)
   {
   /* if we're *that* low on memory, then error_dialog() will fail too,
    * so just return.
@@@@ -93,9 +94,9 @@@@ if((buf=malloc(strlen(cmd_start)+strlen(node)+strlen(c
   return;
   }
 
-strcpy(buf,cmd_start);
-strcat(buf,node);
-strcat(buf,cmd_end);
+strlcpy(buf,cmd_start,siz);
+strlcat(buf,node,siz);
+strlcat(buf,cmd_end,siz);
 
 /* XXX it turns out the error check is useless, as the `&' leads to
  * starting another shell which is the one to give any errors. The
@@@@ -106,13 +107,14 @@@@ if(system(buf)!=0)
   {
   char *msg="Couldn't run help command:\n";
   char *buf2;
+  int siz=strlen(msg)+strlen(buf)+1;
   
-  if((buf2=malloc(strlen(msg)+strlen(buf)+1))==NULL)
+  if((buf2=malloc(siz))==NULL)
     error_dialog("xzgv error",msg);
   else
     {
-    strcpy(buf2,msg);
-    strcat(buf2,buf);
+    strlcpy(buf2,msg,siz);
+    strlcat(buf2,buf,siz);
     error_dialog("xzgv error",buf2);
     free(buf2);
     }
@


1.2
log
@SECURITY - fix a heap overflow

While here:
- remove quotes around COMMENT
- change MAINTAINER's email
- update patches
- reformat dependencies/WANTLIB
- don't use hardcoded patches in man and info pages

based on a diff from Julian Leyh <julian at vgai dot de> (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_help_c,v 1.1.1.1 2005/05/22 11:32:11 alek Exp $
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ src/help.c	Thu May 12 15:38:33 2005
d15 1
a15 1
@@@@ -93,9 +94,9 @@@@ if((buf=malloc(strlen(cmd_start)+strlen(
@


1.1.1.1
log
@Import xzgv 0.8

xzgv is a picture viewer for X, with a thumbnail-based file selector.
It uses GTK+ and Imlib. Most file formats are supported, and the
thumbnails used are compatible with xv, zgv, and the Gimp. It can also
be used with `xzgv file(s)', to effectively bypass the file selector.

From Julian Leyh <oenone@@oenone.de>
@
text
@@
