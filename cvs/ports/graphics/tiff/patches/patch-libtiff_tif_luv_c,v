head	1.7;
access;
symbols
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@# @;


1.7
date	2016.11.29.20.00.35;	author naddy;	state Exp;
branches;
next	1.6;
commitid	3rYO2yYEq9TuBxfZ;

1.6
date	2016.01.24.16.48.49;	author naddy;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;
commitid	9i2aWLjoSlOEXDeK;

1.5
date	2015.07.08.19.36.54;	author naddy;	state Exp;
branches
	1.5.4.1;
next	1.4;
commitid	pCU3S8EYHo6g9JDw;

1.4
date	2015.03.29.17.39.22;	author naddy;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;
commitid	DVvDfC6c0cv0tIBV;

1.3
date	2005.06.18.21.24.40;	author naddy;	state dead;
branches;
next	1.2;

1.2
date	2005.03.27.05.12.15;	author brad;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2004.10.20.20.37.48;	author brad;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.05.25.05.37.32;	author robert;	state Exp;
branches;
next	;

1.2.2.1
date	2005.03.31.22.02.44;	author sturm;	state Exp;
branches;
next	;

1.2.4.1
date	2005.03.31.22.08.46;	author sturm;	state Exp;
branches;
next	;

1.4.2.1
date	2015.03.29.19.41.56;	author naddy;	state Exp;
branches;
next	;
commitid	tay2jRrbkJ3GxbDm;

1.4.4.1
date	2015.03.29.20.58.58;	author naddy;	state Exp;
branches;
next	;
commitid	yV7LOUcjZFa2iAbX;

1.5.4.1
date	2016.01.25.16.08.35;	author jasper;	state Exp;
branches;
next	;
commitid	lZDo9FLWFeOiEZlI;

1.6.2.1
date	2016.11.30.22.14.18;	author naddy;	state Exp;
branches;
next	;
commitid	HYFVXR4DcvEOAZJj;

1.6.4.1
date	2016.11.30.21.36.36;	author naddy;	state Exp;
branches;
next	;
commitid	SSUFe7wdxWokBCcs;


desc
@@


1.7
log
@Update to 4.0.7.
* Multiple security fixes, including
  CVE-2016-3622, CVE-2014-8127, CVE-2016-9273, CVE-2016-9448,
  MSVR 35094, MSVR 35095, MSVR 35105
* Remove obsolete tools bmp2tiff, gif2tiff, ras2tiff, sgi2tiff, sgisv, ycbcr
@
text
@$OpenBSD: patch-libtiff_tif_luv_c,v 1.5 2015/07/08 19:36:54 naddy Exp $
--- libtiff/tif_luv.c.orig	Thu Sep  8 15:23:57 2016
+++ libtiff/tif_luv.c	Thu Nov 24 21:44:23 2016
@@@@ -743,7 +743,7 @@@@ LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
 
 #define itrunc(x,m)	((m)==SGILOGENCODE_NODITHER ? \
 				(int)(x) : \
-				(int)((x) + rand()*(1./RAND_MAX) - .5))
+				(int)((x) + arc4random()*(1./UINT_MAX) - .5))
 
 #if !LOGLUV_PUBLIC
 static
@


1.6
log
@Fix a number of out-of-bound reads and writes, including CVE-2015-8665 and
CVE-2015-8683.  From upstream CVS.
@
text
@d2 3
a4 166

* libtiff/tif_luv.c: fix potential out-of-bound writes in decode
functions in non debug builds by replacing assert()s by regular if
checks (bugzilla #2522).
Fix potential out-of-bound reads in case of short input data.

Avoid rand() warning in library.

--- libtiff/tif_luv.c.orig	Sat Aug 29 00:16:22 2015
+++ libtiff/tif_luv.c	Sun Jan 24 17:06:27 2016
@@@@ -202,7 +202,11 @@@@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint1
 	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
 		tp = (int16*) op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (int16*) sp->tbuf;
 	}
 	_TIFFmemset((void*) tp, 0, npixels*sizeof (tp[0]));
@@@@ -211,9 +215,11 @@@@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint1
 	cc = tif->tif_rawcc;
 	/* get each byte string */
 	for (shft = 2*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
+		for (i = 0; i < npixels && cc > 0; ) {
 			if (*bp >= 128) {		/* run */
-				rc = *bp++ + (2-128);   /* TODO: potential input buffer overrun when decoding corrupt or truncated data */
+				if( cc < 2 )
+					break;
+				rc = *bp++ + (2-128);
 				b = (int16)(*bp++ << shft);
 				cc -= 2;
 				while (rc-- && i < npixels)
@@@@ -223,6 +229,7 @@@@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint1
 				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (int16)*bp++ << shft;
 			}
+		}
 		if (i != npixels) {
 #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 			TIFFErrorExt(tif->tif_clientdata, module,
@@@@ -268,13 +275,17 @@@@ LogLuvDecode24(TIFF* tif, uint8* op, tmsize_t occ, uin
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
 		tp = (uint32 *)op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (uint32 *) sp->tbuf;
 	}
 	/* copy to array of uint32 */
 	bp = (unsigned char*) tif->tif_rawcp;
 	cc = tif->tif_rawcc;
-	for (i = 0; i < npixels && cc > 0; i++) {
+	for (i = 0; i < npixels && cc >= 3; i++) {
 		tp[i] = bp[0] << 16 | bp[1] << 8 | bp[2];
 		bp += 3;
 		cc -= 3;
@@@@ -325,7 +336,11 @@@@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uin
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
 		tp = (uint32*) op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (uint32*) sp->tbuf;
 	}
 	_TIFFmemset((void*) tp, 0, npixels*sizeof (tp[0]));
@@@@ -334,11 +349,13 @@@@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uin
 	cc = tif->tif_rawcc;
 	/* get each byte string */
 	for (shft = 4*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
+		for (i = 0; i < npixels && cc > 0; ) {
 			if (*bp >= 128) {		/* run */
+				if( cc < 2 )
+					break;
 				rc = *bp++ + (2-128);
 				b = (uint32)*bp++ << shft;
-				cc -= 2;                /* TODO: potential input buffer overrun when decoding corrupt or truncated data */
+				cc -= 2;
 				while (rc-- && i < npixels)
 					tp[i++] |= b;
 			} else {			/* non-run */
@@@@ -346,6 +363,7 @@@@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uin
 				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (uint32)*bp++ << shft;
 			}
+		}
 		if (i != npixels) {
 #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 			TIFFErrorExt(tif->tif_clientdata, module,
@@@@ -413,6 +431,7 @@@@ LogLuvDecodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
 static int
 LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 {
+	static const char module[] = "LogL16Encode";
 	LogLuvState* sp = EncoderState(tif);
 	int shft;
 	tmsize_t i;
@@@@ -433,7 +452,11 @@@@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16
 		tp = (int16*) bp;
 	else {
 		tp = (int16*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 	/* compress each byte string */
@@@@ -506,6 +529,7 @@@@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16
 static int
 LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 {
+	static const char module[] = "LogLuvEncode24";
 	LogLuvState* sp = EncoderState(tif);
 	tmsize_t i;
 	tmsize_t npixels;
@@@@ -521,7 +545,11 @@@@ LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint
 		tp = (uint32*) bp;
 	else {
 		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 	/* write out encoded pixels */
@@@@ -553,6 +581,7 @@@@ LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint
 static int
 LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 {
+	static const char module[] = "LogLuvEncode32";
 	LogLuvState* sp = EncoderState(tif);
 	int shft;
 	tmsize_t i;
@@@@ -574,7 +603,11 @@@@ LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint
 		tp = (uint32*) bp;
 	else {
 		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 	/* compress each byte string */
@@@@ -702,7 +735,7 @@@@ LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
@


1.6.2.1
log
@Update to 4.0.7.
* Multiple security fixes, including
CVE-2016-3622, CVE-2014-8127, CVE-2016-9273, CVE-2016-9448,
MSVR 35094, MSVR 35095, MSVR 35105
* Remove obsolete tools bmp2tiff, gif2tiff, ras2tiff, sgi2tiff, sgisv, ycbcr

Minor patches to maintain ABI compatibility with 4.0.6.
@
text
@d1 167
a167 4
$OpenBSD$
--- libtiff/tif_luv.c.orig	Thu Sep  8 15:23:57 2016
+++ libtiff/tif_luv.c	Thu Nov 24 21:44:23 2016
@@@@ -743,7 +743,7 @@@@ LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
@


1.6.4.1
log
@Update to 4.0.7.
* Multiple security fixes, including
CVE-2016-3622, CVE-2014-8127, CVE-2016-9273, CVE-2016-9448,
MSVR 35094, MSVR 35095, MSVR 35105
* Remove obsolete tools bmp2tiff, gif2tiff, ras2tiff, sgi2tiff, sgisv, ycbcr

Minor patches to maintain ABI compatibility with 4.0.6.
@
text
@d1 167
a167 4
$OpenBSD: patch-libtiff_tif_luv_c,v 1.7 2016/11/29 20:00:35 naddy Exp $
--- libtiff/tif_luv.c.orig	Thu Sep  8 15:23:57 2016
+++ libtiff/tif_luv.c	Thu Nov 24 21:44:23 2016
@@@@ -743,7 +743,7 @@@@ LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
@


1.5
log
@Update to 4.0.4.  No major changes.
@
text
@d1 167
a167 4
$OpenBSD: patch-libtiff_tif_luv_c,v 1.4 2015/03/29 17:39:22 naddy Exp $
--- libtiff/tif_luv.c.orig	Sun Jun 21 03:09:09 2015
+++ libtiff/tif_luv.c	Wed Jul  8 21:08:06 2015
@@@@ -702,7 +702,7 @@@@ LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
@


1.5.4.1
log
@Fix a number of out-of-bound reads and writes, including CVE-2015-8665 and
CVE-2015-8683.  From upstream CVS.
@
text
@d1 4
a4 167
$OpenBSD: patch-libtiff_tif_luv_c,v 1.6 2016/01/24 16:48:49 naddy Exp $

* libtiff/tif_luv.c: fix potential out-of-bound writes in decode
functions in non debug builds by replacing assert()s by regular if
checks (bugzilla #2522).
Fix potential out-of-bound reads in case of short input data.

Avoid rand() warning in library.

--- libtiff/tif_luv.c.orig	Sat Aug 29 00:16:22 2015
+++ libtiff/tif_luv.c	Sun Jan 24 17:06:27 2016
@@@@ -202,7 +202,11 @@@@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint1
 	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
 		tp = (int16*) op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (int16*) sp->tbuf;
 	}
 	_TIFFmemset((void*) tp, 0, npixels*sizeof (tp[0]));
@@@@ -211,9 +215,11 @@@@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint1
 	cc = tif->tif_rawcc;
 	/* get each byte string */
 	for (shft = 2*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
+		for (i = 0; i < npixels && cc > 0; ) {
 			if (*bp >= 128) {		/* run */
-				rc = *bp++ + (2-128);   /* TODO: potential input buffer overrun when decoding corrupt or truncated data */
+				if( cc < 2 )
+					break;
+				rc = *bp++ + (2-128);
 				b = (int16)(*bp++ << shft);
 				cc -= 2;
 				while (rc-- && i < npixels)
@@@@ -223,6 +229,7 @@@@ LogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint1
 				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (int16)*bp++ << shft;
 			}
+		}
 		if (i != npixels) {
 #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 			TIFFErrorExt(tif->tif_clientdata, module,
@@@@ -268,13 +275,17 @@@@ LogLuvDecode24(TIFF* tif, uint8* op, tmsize_t occ, uin
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
 		tp = (uint32 *)op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (uint32 *) sp->tbuf;
 	}
 	/* copy to array of uint32 */
 	bp = (unsigned char*) tif->tif_rawcp;
 	cc = tif->tif_rawcc;
-	for (i = 0; i < npixels && cc > 0; i++) {
+	for (i = 0; i < npixels && cc >= 3; i++) {
 		tp[i] = bp[0] << 16 | bp[1] << 8 | bp[2];
 		bp += 3;
 		cc -= 3;
@@@@ -325,7 +336,11 @@@@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uin
 	if (sp->user_datafmt == SGILOGDATAFMT_RAW)
 		tp = (uint32*) op;
 	else {
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		tp = (uint32*) sp->tbuf;
 	}
 	_TIFFmemset((void*) tp, 0, npixels*sizeof (tp[0]));
@@@@ -334,11 +349,13 @@@@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uin
 	cc = tif->tif_rawcc;
 	/* get each byte string */
 	for (shft = 4*8; (shft -= 8) >= 0; ) {
-		for (i = 0; i < npixels && cc > 0; )
+		for (i = 0; i < npixels && cc > 0; ) {
 			if (*bp >= 128) {		/* run */
+				if( cc < 2 )
+					break;
 				rc = *bp++ + (2-128);
 				b = (uint32)*bp++ << shft;
-				cc -= 2;                /* TODO: potential input buffer overrun when decoding corrupt or truncated data */
+				cc -= 2;
 				while (rc-- && i < npixels)
 					tp[i++] |= b;
 			} else {			/* non-run */
@@@@ -346,6 +363,7 @@@@ LogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uin
 				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (uint32)*bp++ << shft;
 			}
+		}
 		if (i != npixels) {
 #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 			TIFFErrorExt(tif->tif_clientdata, module,
@@@@ -413,6 +431,7 @@@@ LogLuvDecodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
 static int
 LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 {
+	static const char module[] = "LogL16Encode";
 	LogLuvState* sp = EncoderState(tif);
 	int shft;
 	tmsize_t i;
@@@@ -433,7 +452,11 @@@@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16
 		tp = (int16*) bp;
 	else {
 		tp = (int16*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 	/* compress each byte string */
@@@@ -506,6 +529,7 @@@@ LogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16
 static int
 LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 {
+	static const char module[] = "LogLuvEncode24";
 	LogLuvState* sp = EncoderState(tif);
 	tmsize_t i;
 	tmsize_t npixels;
@@@@ -521,7 +545,11 @@@@ LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint
 		tp = (uint32*) bp;
 	else {
 		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 	/* write out encoded pixels */
@@@@ -553,6 +581,7 @@@@ LogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint
 static int
 LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
 {
+	static const char module[] = "LogLuvEncode32";
 	LogLuvState* sp = EncoderState(tif);
 	int shft;
 	tmsize_t i;
@@@@ -574,7 +603,11 @@@@ LogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint
 		tp = (uint32*) bp;
 	else {
 		tp = (uint32*) sp->tbuf;
-		assert(sp->tbuflen >= npixels);
+		if(sp->tbuflen < npixels) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+						 "Translation buffer too short");
+			return (0);
+		}
 		(*sp->tfunc)(sp, bp, npixels);
 	}
 	/* compress each byte string */
@@@@ -702,7 +735,7 @@@@ LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
@


1.4
log
@Security update to 4.0.4beta (plus one further upstream fix).
Should fix CVE-2014-8127, CVE-2014-8128, CVE-2014-8129, CVE-2014-8130,
CVE-2014-9655, CVE-2015-1547.
@
text
@d1 4
a4 4
$OpenBSD$
--- libtiff/tif_luv.c.orig	Sat Apr  2 22:54:09 2011
+++ libtiff/tif_luv.c	Sun Mar 29 17:24:13 2015
@@@@ -688,7 +688,7 @@@@ LogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, ui
@


1.4.4.1
log
@Security update to 4.0.4beta (plus one further upstream fix).
Should fix CVE-2014-8127, CVE-2014-8128, CVE-2014-8129, CVE-2014-8130,
CVE-2014-9655, CVE-2015-1547.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_luv_c,v 1.4.2.1 2015/03/29 19:41:56 naddy Exp $
@


1.4.2.1
log
@Security update to 4.0.4beta (plus one further upstream fix).
Should fix CVE-2014-8127, CVE-2014-8128, CVE-2014-8129, CVE-2014-8130,
CVE-2014-9655, CVE-2015-1547.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_luv_c,v 1.4 2015/03/29 17:39:22 naddy Exp $
@


1.3
log
@update to 3.7.2 which integrates the numerous security patches
brad@@ drops maintainership
@
text
@d1 4
a4 34
$OpenBSD: patch-libtiff_tif_luv_c,v 1.2 2005/03/27 05:12:15 brad Exp $
--- libtiff/tif_luv.c.orig	Thu Nov 27 10:08:10 2003
+++ libtiff/tif_luv.c	Sat Mar 26 23:06:29 2005
@@@@ -212,11 +212,11 @@@@ LogL16Decode(TIFF* tif, tidata_t op, tsi
 				rc = *bp++ + (2-128);
 				b = (int16)(*bp++ << shft);
 				cc -= 2;
-				while (rc--)
+				while (rc-- && i < npixels)
 					tp[i++] |= b;
 			} else {			/* non-run */
 				rc = *bp++;		/* nul is noop */
-				while (--cc && rc--)
+				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (int16)*bp++ << shft;
 			}
 		if (i != npixels) {
@@@@ -312,11 +312,11 @@@@ LogLuvDecode32(TIFF* tif, tidata_t op, t
 				rc = *bp++ + (2-128);
 				b = (uint32)*bp++ << shft;
 				cc -= 2;
-				while (rc--)
+				while (rc-- && i < npixels)
 					tp[i++] |= b;
 			} else {			/* non-run */
 				rc = *bp++;		/* nul is noop */
-				while (--cc && rc--)
+				while (--cc && rc-- && i < npixels)
 					tp[i++] |= (uint32)*bp++ << shft;
 			}
 		if (i != npixels) {
@@@@ -1161,6 +1161,17 @@@@ LogL16GuessDataFmt(TIFFDirectory *td)
 	return (SGILOGDATAFMT_UNKNOWN);
 }
d6 7
a12 49
+static uint32
+multiply(size_t m1, size_t m2)
+{
+	uint32	bytes = m1 * m2;
+
+	if (m1 && bytes / m1 != m2)
+		bytes = 0;
+
+	return bytes;
+}
+
 static int
 LogL16InitState(TIFF* tif)
 {
@@@@ -1189,9 +1200,9 @@@@ LogL16InitState(TIFF* tif)
 		    "No support for converting user data format to LogL");
 		return (0);
 	}
-	sp->tbuflen = td->td_imagewidth * td->td_rowsperstrip;
-	sp->tbuf = (tidata_t*) _TIFFmalloc(sp->tbuflen * sizeof (int16));
-	if (sp->tbuf == NULL) {
+	sp->tbuflen = multiply(td->td_imagewidth, td->td_rowsperstrip);
+	if (multiply(sp->tbuflen, sizeof (int16)) == 0 ||
+	    (sp->tbuf = (tidata_t*) _TIFFmalloc(sp->tbuflen * sizeof (int16))) == NULL) {
 		TIFFError(module, "%s: No space for SGILog translation buffer",
 		    tif->tif_name);
 		return (0);
@@@@ -1287,9 +1298,9 @@@@ LogLuvInitState(TIFF* tif)
 		    "No support for converting user data format to LogLuv");
 		return (0);
 	}
-	sp->tbuflen = td->td_imagewidth * td->td_rowsperstrip;
-	sp->tbuf = (tidata_t*) _TIFFmalloc(sp->tbuflen * sizeof (uint32));
-	if (sp->tbuf == NULL) {
+	sp->tbuflen = multiply(td->td_imagewidth, td->td_rowsperstrip);
+	if (multiply(sp->tbuflen, sizeof (uint32)) == 0 ||
+	    (sp->tbuf = (tidata_t*) _TIFFmalloc(sp->tbuflen * sizeof (uint32))) == NULL) {
 		TIFFError(module, "%s: No space for SGILog translation buffer",
 		    tif->tif_name);
 		return (0);
@@@@ -1497,7 +1508,7 @@@@ LogLuvVSetField(TIFF* tif, ttag_t tag, v
 		/*
 		 * Must recalculate sizes should bits/sample change.
 		 */
-		tif->tif_tilesize = TIFFTileSize(tif);
+		tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tsize_t) -1;
 		tif->tif_scanlinesize = TIFFScanlineSize(tif);
 		return (1);
 	case TIFFTAG_SGILOGENCODE:
@


1.2
log
@fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_luv_c,v 1.1 2004/10/20 20:37:48 brad Exp $
@


1.2.4.1
log
@cumulative update with patches of recent months

MFC:
fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
---
fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
---
fix MASTER_SITES; From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_luv_c,v 1.2 2005/03/27 05:12:15 brad Exp $
@


1.2.2.1
log
@cumulative update with patches of recent months

MFC:
fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
---
fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
---
fix MASTER_SITES; From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_luv_c,v 1.2 2005/03/27 05:12:15 brad Exp $
@


1.1
log
@Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ libtiff/tif_luv.c	Wed Oct 20 14:38:11 2004
d76 9
@


1.1.2.1
log
@SECURITY:
fix multiple vulnerabilities; bump PKGNAME
http://www.vuxml.org/openbsd/d045aeb6-9ea6-11d9-9623-00065bd5b0b6.html

ok brad@@
@
text
@d3 1
a3 1
+++ libtiff/tif_luv.c	Sat Mar 26 23:06:29 2005
a75 9
@@@@ -1497,7 +1508,7 @@@@ LogLuvVSetField(TIFF* tif, ttag_t tag, v
 		/*
 		 * Must recalculate sizes should bits/sample change.
 		 */
-		tif->tif_tilesize = TIFFTileSize(tif);
+		tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tsize_t) -1;
 		tif->tif_scanlinesize = TIFFScanlineSize(tif);
 		return (1);
 	case TIFFTAG_SGILOGENCODE:
@


