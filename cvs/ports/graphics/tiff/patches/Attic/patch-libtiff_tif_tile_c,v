head	1.2;
access;
symbols
	OPENBSD_5_1:1.2.0.2
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2005.06.18.21.24.40;	author naddy;	state dead;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.10.20.20.37.48;	author brad;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.1.2.1
date	2005.05.25.05.37.32;	author robert;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.07.29.17.38.59;	author brad;	state Exp;
branches;
next	;

1.1.4.1
date	2005.03.31.22.02.44;	author sturm;	state Exp;
branches;
next	;

1.1.6.1
date	2005.03.31.22.08.47;	author sturm;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2005.07.29.17.51.26;	author brad;	state Exp;
branches;
next	;

1.2.2.1
date	2012.06.27.14.33.35;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to 3.7.2 which integrates the numerous security patches
brad@@ drops maintainership
@
text
@$OpenBSD: patch-libtiff_tif_tile_c,v 1.1 2004/10/20 20:37:48 brad Exp $
--- libtiff/tif_tile.c.orig	Tue Nov 11 10:43:10 2003
+++ libtiff/tif_tile.c	Wed Oct 20 14:38:11 2004
@@@@ -31,6 +31,32 @@@@
  */
 #include "tiffiop.h"
 
+static uint32
+summarize(TIFF* tif, size_t summand1, size_t summand2, const char* where)
+{
+	uint32	bytes = summand1 + summand2;
+
+	if (bytes - summand1 != summand2) {
+		TIFFError(tif->tif_name, "Integer overflow in %s", where);
+		bytes = 0;
+	}
+
+	return (bytes);
+}
+
+static uint32
+multiply(TIFF* tif, size_t nmemb, size_t elem_size, const char* where)
+{
+	uint32	bytes = nmemb * elem_size;
+
+	if (elem_size && bytes / elem_size != nmemb) {
+		TIFFError(tif->tif_name, "Integer overflow in %s", where);
+		bytes = 0;
+	}
+
+	return (bytes);
+}
+
 /*
  * Compute which tile an (x,y,z,s) value is in.
  */
@@@@ -119,11 +145,13 @@@@ TIFFNumberOfTiles(TIFF* tif)
 	if (dz == (uint32) -1)
 		dz = td->td_imagedepth;
 	ntiles = (dx == 0 || dy == 0 || dz == 0) ? 0 :
-	    (TIFFhowmany(td->td_imagewidth, dx) *
-	     TIFFhowmany(td->td_imagelength, dy) *
-	     TIFFhowmany(td->td_imagedepth, dz));
+	    multiply(tif, multiply(tif, TIFFhowmany(td->td_imagewidth, dx),
+				   TIFFhowmany(td->td_imagelength, dy),
+				   "TIFFNumberOfTiles"),
+		     TIFFhowmany(td->td_imagedepth, dz), "TIFFNumberOfTiles");
 	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
-		ntiles *= td->td_samplesperpixel;
+		ntiles = multiply(tif, ntiles, td->td_samplesperpixel,
+				  "TIFFNumberOfTiles");
 	return (ntiles);
 }
 
@@@@ -138,10 +166,12 @@@@ TIFFTileRowSize(TIFF* tif)
 	
 	if (td->td_tilelength == 0 || td->td_tilewidth == 0)
 		return ((tsize_t) 0);
-	rowsize = td->td_bitspersample * td->td_tilewidth;
+	rowsize = multiply(tif, td->td_bitspersample, td->td_tilewidth,
+			   "TIFFTileRowSize");
 	if (td->td_planarconfig == PLANARCONFIG_CONTIG)
-		rowsize *= td->td_samplesperpixel;
-	return ((tsize_t) TIFFhowmany(rowsize, 8));
+		rowsize = multiply(tif, rowsize, td->td_samplesperpixel,
+				   "TIFFTileRowSize");
+	return ((tsize_t) TIFFhowmany8(rowsize));
 }
 
 /*
@@@@ -170,16 +200,24 @@@@ TIFFVTileSize(TIFF* tif, uint32 nrows)
 		 */
 		tsize_t w =
 		    TIFFroundup(td->td_tilewidth, td->td_ycbcrsubsampling[0]);
-		tsize_t rowsize = TIFFhowmany(w*td->td_bitspersample, 8);
+		tsize_t rowsize =
+		    TIFFhowmany8(multiply(tif, w, td->td_bitspersample,
+					  "TIFFVTileSize"));
 		tsize_t samplingarea =
 		    td->td_ycbcrsubsampling[0]*td->td_ycbcrsubsampling[1];
 		nrows = TIFFroundup(nrows, td->td_ycbcrsubsampling[1]);
 		/* NB: don't need TIFFhowmany here 'cuz everything is rounded */
-		tilesize = nrows*rowsize + 2*(nrows*rowsize / samplingarea);
+		tilesize = multiply(tif, nrows, rowsize, "TIFFVTileSize");
+		tilesize = summarize(tif, tilesize,
+				     multiply(tif, 2, tilesize / samplingarea,
+					      "TIFFVTileSize"),
+				     "TIFFVTileSize");
 	} else
 #endif
-		tilesize = nrows * TIFFTileRowSize(tif);
-	return ((tsize_t)(tilesize * td->td_tiledepth));
+		tilesize = multiply(tif, nrows, TIFFTileRowSize(tif),
+				    "TIFFVTileSize");
+	return ((tsize_t)
+	    multiply(tif, tilesize, td->td_tiledepth, "TIFFVTileSize"));
 }
 
 /*
@


1.2.2.1
log
@Apply patches for CVE-2012-2113,
LibTIFF "tiff2pdf" Integer Overflow Vulnerability
@
text
@d1 55
a55 15
$OpenBSD$

Security fix for CVE-2012-2113
libtiff: integer overflow in tiff2pdf leading to heap-buffer overflow when reading a tiled tiff file

Patch from https://bugzilla.redhat.com/show_bug.cgi?id=810551

--- libtiff/tif_tile.c.orig	Tue Jun  8 20:50:43 2010
+++ libtiff/tif_tile.c	Wed Jun 27 16:29:48 2012
@@@@ -174,7 +174,7 @@@@ tsize_t
 TIFFTileRowSize(TIFF* tif)
 {
 	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t rowsize;
+	uint32 rowsize;
d59 10
a68 6
@@@@ -193,7 +193,7 @@@@ tsize_t
 TIFFVTileSize(TIFF* tif, uint32 nrows)
 {
 	TIFFDirectory *td = &tif->tif_dir;
-	tsize_t tilesize;
+	uint32 tilesize;
d70 2
a71 5
 	if (td->td_tilelength == 0 || td->td_tilewidth == 0 ||
 	    td->td_tiledepth == 0)
@@@@ -209,12 +209,12 @@@@ TIFFVTileSize(TIFF* tif, uint32 nrows)
 		 * horizontal/vertical subsampling area include
 		 * YCbCr data for the extended image.
d73 1
a73 2
-		tsize_t w =
+		uint32 w =
d75 5
a79 6
-		tsize_t rowsize =
+		uint32 rowsize =
 		    TIFFhowmany8(multiply(tif, w, td->td_bitspersample,
 					  "TIFFVTileSize"));
-		tsize_t samplingarea =
+		uint32 samplingarea =
d81 8
a88 3
 		if (samplingarea == 0) {
 			TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "Invalid YCbCr subsampling");
@@@@ -230,8 +230,13 @@@@ TIFFVTileSize(TIFF* tif, uint32 nrows)
d90 7
a96 11
 		tilesize = multiply(tif, nrows, TIFFTileRowSize(tif),
 				    "TIFFVTileSize");
-	return ((tsize_t)
-	    multiply(tif, tilesize, td->td_tiledepth, "TIFFVTileSize"));
+	tilesize = multiply(tif, tilesize, td->td_tiledepth, "TIFFVTileSize");
+	/* Because tsize_t is signed, we might have conversion overflow */
+	if (((tsize_t) tilesize) < 0) {
+		TIFFErrorExt(tif->tif_clientdata, tif->tif_name, "Integer overflow in %s", "TIFFVTileSize");
+		tilesize = 0;
+	}
+	return (tsize_t) tilesize;
@


1.1
log
@Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.2.1
log
@SECURITY:
fix multiple vulnerabilities; bump PKGNAME
http://www.vuxml.org/openbsd/d045aeb6-9ea6-11d9-9623-00065bd5b0b6.html

ok brad@@
@
text
@@


1.1.2.2
log
@Fix a Denial of Service vulnerability and a buffer overflow.

- Check for zero YCbCr subsampling values which cause a division by zero crash.
- Properly check the BitsPerSample tag.

CAN-2005-1544
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_tile_c,v 1.1.2.1 2005/05/25 05:37:32 robert Exp $
d3 1
a3 1
+++ libtiff/tif_tile.c	Fri Jul 29 13:12:38 2005
d71 1
a71 1
@@@@ -170,16 +200,28 @@@@ TIFFVTileSize(TIFF* tif, uint32 nrows)
a80 4
+		if (samplingarea == 0) {
+			TIFFError(tif->tif_name, "Invalid YCbCr subsampling");
+			return 0;
+		}
@


1.1.6.1
log
@cumulative update with patches of recent months

MFC:
fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
---
fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
---
fix MASTER_SITES; From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_tile_c,v 1.1 2004/10/20 20:37:48 brad Exp $
@


1.1.6.2
log
@Fix a Denial of Service vulnerability and a buffer overflow.

- Check for zero YCbCr subsampling values which cause a division by zero crash.
- Properly check the BitsPerSample tag.

CAN-2005-1544
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_tile_c,v 1.1.2.2 2005/07/29 17:38:59 brad Exp $
d3 1
a3 1
+++ libtiff/tif_tile.c	Fri Jul 29 13:12:38 2005
d71 1
a71 1
@@@@ -170,16 +200,28 @@@@ TIFFVTileSize(TIFF* tif, uint32 nrows)
a80 4
+		if (samplingarea == 0) {
+			TIFFError(tif->tif_name, "Invalid YCbCr subsampling");
+			return 0;
+		}
@


1.1.4.1
log
@cumulative update with patches of recent months

MFC:
fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
---
fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
---
fix MASTER_SITES; From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_tile_c,v 1.1 2004/10/20 20:37:48 brad Exp $
@

