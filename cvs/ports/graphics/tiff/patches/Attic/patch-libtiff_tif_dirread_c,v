head	1.6;
access;
symbols
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2010.06.30.17.10.08;	author naddy;	state dead;
branches;
next	1.5;

1.5
date	2008.10.25.09.39.29;	author naddy;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.18.21.24.40;	author naddy;	state dead;
branches;
next	1.3;

1.3
date	2005.03.27.05.12.15;	author brad;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2005.03.27.03.57.26;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.20.20.37.48;	author brad;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.05.25.05.37.32;	author robert;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.07.29.17.38.59;	author brad;	state Exp;
branches;
next	;

1.3.2.1
date	2005.03.31.22.02.44;	author sturm;	state Exp;
branches;
next	;

1.3.4.1
date	2005.03.31.22.08.46;	author sturm;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2005.07.29.17.51.26;	author brad;	state Exp;
branches;
next	;


desc
@@


1.6
log
@SECURITY:
Update to 3.9.4, which includes fixes for CVE-2009-2347 and CVE-2010-1411.
@
text
@$OpenBSD: patch-libtiff_tif_dirread_c,v 1.5 2008/10/25 09:39:29 naddy Exp $

CVE-2006-3459,3463,3464,3465 

--- libtiff/tif_dirread.c.orig	Tue Mar 21 17:42:50 2006
+++ libtiff/tif_dirread.c	Fri Oct 24 18:54:00 2008
@@@@ -29,6 +29,9 @@@@
  *
  * Directory Read Support Routines.
  */
+
+#include <limits.h>
+
 #include "tiffiop.h"
 
 #define	IGNORE	0		/* tag placeholder used below */
@@@@ -81,6 +84,7 @@@@ TIFFReadDirectory(TIFF* tif)
 	uint16 dircount;
 	toff_t nextdiroff;
 	int diroutoforderwarning = 0;
+	int compressionknown = 0;
 	toff_t* new_dirlist;
 
 	tif->tif_diroff = tif->tif_nextdiroff;
@@@@ -147,13 +151,20 @@@@ TIFFReadDirectory(TIFF* tif)
 	} else {
 		toff_t off = tif->tif_diroff;
 
-		if (off + sizeof (uint16) > tif->tif_size) {
-			TIFFErrorExt(tif->tif_clientdata, module,
-			    "%s: Can not read TIFF directory count",
-                            tif->tif_name);
-			return (0);
+		/*
+		 * Check for integer overflow when validating the dir_off, otherwise
+		 * a very high offset may cause an OOB read and crash the client.
+		 * -- taviso@@google.com, 14 Jun 2006.
+		 */
+		if (off + sizeof (uint16) > tif->tif_size || 
+			off > (UINT_MAX - sizeof(uint16))) {
+				TIFFErrorExt(tif->tif_clientdata, module,
+				    "%s: Can not read TIFF directory count",
+				    tif->tif_name);
+				return (0);
 		} else
-			_TIFFmemcpy(&dircount, tif->tif_base + off, sizeof (uint16));
+			_TIFFmemcpy(&dircount, tif->tif_base + off,
+					sizeof (uint16));
 		off += sizeof (uint16);
 		if (tif->tif_flags & TIFF_SWAB)
 			TIFFSwabShort(&dircount);
@@@@ -254,6 +265,7 @@@@ TIFFReadDirectory(TIFF* tif)
 		while (fix < tif->tif_nfields &&
 		       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
 			fix++;
+
 		if (fix >= tif->tif_nfields ||
 		    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {
 
@@@@ -264,17 +276,23 @@@@ TIFFReadDirectory(TIFF* tif)
 						       dp->tdir_tag,
 						       dp->tdir_tag,
 						       dp->tdir_type);
-
-                    TIFFMergeFieldInfo(tif,
-                                       _TIFFCreateAnonFieldInfo(tif,
-						dp->tdir_tag,
-						(TIFFDataType) dp->tdir_type),
-				       1 );
+					/*
+					 * creating anonymous fields prior to knowing the compression
+					 * algorithm (ie, when the field info has been merged) could cause
+					 * crashes with pathological directories.
+					 * -- taviso@@google.com 15 Jun 2006
+					 */
+					if (compressionknown)
+			                    TIFFMergeFieldInfo(tif, _TIFFCreateAnonFieldInfo(tif, dp->tdir_tag, 
+						(TIFFDataType) dp->tdir_type), 1 );
+					else goto ignore;
+		    
                     fix = 0;
                     while (fix < tif->tif_nfields &&
                            tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)
 			fix++;
 		}
+		
 		/*
 		 * Null out old tags that we ignore.
 		 */
@@@@ -326,6 +344,7 @@@@ TIFFReadDirectory(TIFF* tif)
 				    dp->tdir_type, dp->tdir_offset);
 				if (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))
 					goto bad;
+				else compressionknown++;
 				break;
 			/* XXX: workaround for broken TIFFs */
 			} else if (dp->tdir_type == TIFF_LONG) {
@@@@ -540,6 +559,7 @@@@ TIFFReadDirectory(TIFF* tif)
 	 * Attempt to deal with a missing StripByteCounts tag.
 	 */
 	if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
+		const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, TIFFTAG_STRIPBYTECOUNTS);
 		/*
 		 * Some manufacturers violate the spec by not giving
 		 * the size of the strips.  In this case, assume there
@@@@ -556,7 +576,7 @@@@ TIFFReadDirectory(TIFF* tif)
 			"%s: TIFF directory is missing required "
 			"\"%s\" field, calculating from imagelength",
 			tif->tif_name,
-		        _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
+		        fip ? fip->field_name : "Unknown");
 		if (EstimateStripByteCounts(tif, dir, dircount) < 0)
 		    goto bad;
 /* 
@@@@ -580,6 +600,7 @@@@ TIFFReadDirectory(TIFF* tif)
 	} else if (td->td_nstrips == 1 
                    && td->td_stripoffset[0] != 0 
                    && BYTECOUNTLOOKSBAD) {
+		const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, TIFFTAG_STRIPBYTECOUNTS);
 		/*
 		 * XXX: Plexus (and others) sometimes give a value of zero for
 		 * a tag when they don't know what the correct value is!  Try
@@@@ -589,13 +610,14 @@@@ TIFFReadDirectory(TIFF* tif)
 		TIFFWarningExt(tif->tif_clientdata, module,
 	"%s: Bogus \"%s\" field, ignoring and calculating from imagelength",
                             tif->tif_name,
-		            _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
+		            fip ? fip->field_name : "Unknown");
 		if(EstimateStripByteCounts(tif, dir, dircount) < 0)
 		    goto bad;
 	} else if (td->td_planarconfig == PLANARCONFIG_CONTIG
 		   && td->td_nstrips > 2
 		   && td->td_compression == COMPRESSION_NONE
 		   && td->td_stripbytecount[0] != td->td_stripbytecount[1]) {
+		const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, TIFFTAG_STRIPBYTECOUNTS);
 		/*
 		 * XXX: Some vendors fill StripByteCount array with absolutely
 		 * wrong values (it can be equal to StripOffset array, for
@@@@ -604,7 +626,7 @@@@ TIFFReadDirectory(TIFF* tif)
 		TIFFWarningExt(tif->tif_clientdata, module,
 	"%s: Wrong \"%s\" field, ignoring and calculating from imagelength",
                             tif->tif_name,
-		            _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);
+		            fip ? fip->field_name : "Unknown");
 		if (EstimateStripByteCounts(tif, dir, dircount) < 0)
 		    goto bad;
 	}
@@@@ -870,8 +892,14 @@@@ EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, 
 
 	register TIFFDirEntry *dp;
 	register TIFFDirectory *td = &tif->tif_dir;
-	uint16 i;
+	
+	/* i is used to iterate over td->td_nstrips, so must be
+	 * at least the same width.
+	 * -- taviso@@google.com 15 Jun 2006
+	 */
 
+	uint32 i;
+
 	if (td->td_stripbytecount)
 		_TIFFfree(td->td_stripbytecount);
 	td->td_stripbytecount = (uint32*)
@@@@ -947,16 +975,18 @@@@ MissingRequired(TIFF* tif, const char* tagname)
 static int
 CheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)
 {
+	const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dir->tdir_tag);
+
 	if (count > dir->tdir_count) {
 		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
 	"incorrect count for field \"%s\" (%lu, expecting %lu); tag ignored",
-		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,
+		    fip ? fip->field_name : "Unknown",
 		    dir->tdir_count, count);
 		return (0);
 	} else if (count < dir->tdir_count) {
 		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
 	"incorrect count for field \"%s\" (%lu, expecting %lu); tag trimmed",
-		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,
+		    fip ? fip->field_name : "Unknown",
 		    dir->tdir_count, count);
 		return (1);
 	}
@@@@ -970,6 +1000,7 @@@@ static tsize_t
 TIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp)
 {
 	int w = TIFFDataWidth((TIFFDataType) dir->tdir_type);
+	const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dir->tdir_tag);
 	tsize_t cc = dir->tdir_count * w;
 
 	/* Check for overflow. */
@@@@ -1013,7 +1044,7 @@@@ TIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp)
 bad:
 	TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
 		     "Error fetching data for field \"%s\"",
-		     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
+		     fip ? fip->field_name : "Unknown");
 	return (tsize_t) 0;
 }
 
@@@@ -1039,10 +1070,12 @@@@ TIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp
 static int
 cvtRational(TIFF* tif, TIFFDirEntry* dir, uint32 num, uint32 denom, float* rv)
 {
+	const TIFFFieldInfo* fip;
 	if (denom == 0) {
+		fip = _TIFFFieldWithTag(tif, dir->tdir_tag);
 		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
 		    "%s: Rational with zero denominator (num = %lu)",
-		    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, num);
+		    fip ? fip->field_name : "Unknown", num);
 		return (0);
 	} else {
 		if (dir->tdir_type == TIFF_RATIONAL)
@@@@ -1159,6 +1192,20 @@@@ TIFFFetchShortArray(TIFF* tif, TIFFDirEntry* dir, uint
 static int
 TIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir)
 {
+	/*
+	 * Prevent overflowing the v stack arrays below by performing a sanity
+	 * check on tdir_count, this should never be greater than two.
+	 * -- taviso@@google.com 14 Jun 2006.
+	 */
+	if (dir->tdir_count > 2) {
+		const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dir->tdir_tag);
+		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
+				"unexpected count for field \"%s\", %lu, expected 2; ignored.",
+				fip ? fip->field_name : "Unknown",
+				dir->tdir_count);
+		return 0;
+	}
+
 	switch (dir->tdir_type) {
 		case TIFF_BYTE:
 		case TIFF_SBYTE:
@@@@ -1329,14 +1376,15 @@@@ TIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double
 	case TIFF_DOUBLE:
 		return (TIFFFetchDoubleArray(tif, dir, (double*) v));
 	default:
+		{ const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dir->tdir_tag);
 		/* TIFF_NOTYPE */
 		/* TIFF_ASCII */
 		/* TIFF_UNDEFINED */
 		TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
 			     "cannot read TIFF_ANY type %d for field \"%s\"",
 			     dir->tdir_type,
-			     _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
-		return (0);
+			     fip ? fip->field_name : "Unknown");
+		return (0); }
 	}
 	return (1);
 }
@@@@ -1351,6 +1399,9 @@@@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp)
 	int ok = 0;
 	const TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dp->tdir_tag);
 
+	if (fip == NULL) {
+		return (0);
+	}
 	if (dp->tdir_count > 1) {		/* array of values */
 		char* cp = NULL;
 
@@@@ -1493,6 +1544,7 @@@@ static int
 TIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, uint16* pl)
 {
     uint16 samples = tif->tif_dir.td_samplesperpixel;
+    const TIFFFieldInfo* fip;
     int status = 0;
 
     if (CheckDirCount(tif, dir, (uint32) samples)) {
@@@@ -1510,9 +1562,10 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir,
 
             for (i = 1; i < check_count; i++)
                 if (v[i] != v[0]) {
+				fip = _TIFFFieldWithTag(tif, dir->tdir_tag);
 					TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                               "Cannot handle different per-sample values for field \"%s\"",
-                              _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
+                              fip ? fip->field_name : "Unknown");
                     goto bad;
                 }
             *pl = v[0];
@@@@ -1534,6 +1587,7 @@@@ static int
 TIFFFetchPerSampleLongs(TIFF* tif, TIFFDirEntry* dir, uint32* pl)
 {
     uint16 samples = tif->tif_dir.td_samplesperpixel;
+    const TIFFFieldInfo* fip;
     int status = 0;
 
     if (CheckDirCount(tif, dir, (uint32) samples)) {
@@@@ -1551,9 +1605,10 @@@@ TIFFFetchPerSampleLongs(TIFF* tif, TIFFDirEntry* dir, 
                 check_count = samples;
             for (i = 1; i < check_count; i++)
                 if (v[i] != v[0]) {
+				fip = _TIFFFieldWithTag(tif, dir->tdir_tag);
 					TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                               "Cannot handle different per-sample values for field \"%s\"",
-                              _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
+                              fip ? fip->field_name : "Unknown");
                     goto bad;
                 }
             *pl = v[0];
@@@@ -1574,6 +1629,7 @@@@ static int
 TIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, double* pl)
 {
     uint16 samples = tif->tif_dir.td_samplesperpixel;
+    const TIFFFieldInfo* fip;
     int status = 0;
 
     if (CheckDirCount(tif, dir, (uint32) samples)) {
@@@@ -1591,9 +1647,10 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, d
 
             for (i = 1; i < check_count; i++)
                 if (v[i] != v[0]) {
+		    fip = _TIFFFieldWithTag(tif, dir->tdir_tag);
                     TIFFErrorExt(tif->tif_clientdata, tif->tif_name,
                               "Cannot handle different per-sample values for field \"%s\"",
-                              _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);
+                              fip ? fip->field_name : "Unknown");
                     goto bad;
                 }
             *pl = v[0];
@


1.5
log
@SECURITY fixes for CVE-2006-2656 and CVE-2006-3459 through 3465.
Man page fixes.

Mostly via FreeBSD.  Approving noises from bernd@@ and jasper@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.4
log
@update to 3.7.2 which integrates the numerous security patches
brad@@ drops maintainership
@
text
@d1 10
a10 13
$OpenBSD: patch-libtiff_tif_dirread_c,v 1.3 2005/03/27 05:12:15 brad Exp $
--- libtiff/tif_dirread.c.orig	Mon Dec 22 03:22:15 2003
+++ libtiff/tif_dirread.c	Sat Mar 26 23:18:01 2005
@@@@ -62,11 +62,17 @@@@ static	int TIFFFetchShortPair(TIFF*, TIF
 static	void ChopUpSingleUncompressedStrip(TIFF*);
 
 static char *
-CheckMalloc(TIFF* tif, tsize_t n, const char* what)
+CheckMalloc(TIFF* tif, size_t nmemb, size_t elem_size, const char* what)
 {
-	char *cp = (char*)_TIFFmalloc(n);
+	char	*cp = NULL;
+	tsize_t	bytes = nmemb * elem_size;
d12 1
a12 2
+	if (nmemb && elem_size && bytes / elem_size == nmemb)
+		cp = (char*)_TIFFmalloc(bytes);
d14 1
a14 5
 	if (cp == NULL)
 		TIFFError(tif->tif_name, "No space %s", what);
+	
 	return (cp);
 }
d16 3
a18 1
@@@@ -93,6 +99,7 @@@@ TIFFReadDirectory(TIFF* tif)
a19 1
 	char* cp;
d21 2
a22 1
+	toff_t* new_dirlist;
d25 3
a27 18
 	if (tif->tif_diroff == 0)		/* no more directories */
@@@@ -108,14 +115,15 @@@@ TIFFReadDirectory(TIFF* tif)
 			return (0);
 	}
 	tif->tif_dirnumber++;
-	tif->tif_dirlist = _TIFFrealloc(tif->tif_dirlist,
-					tif->tif_dirnumber * sizeof(toff_t));
-	if (!tif->tif_dirlist) {
+	new_dirlist = _TIFFrealloc(tif->tif_dirlist,
+				   tif->tif_dirnumber * sizeof(toff_t));
+	if (!new_dirlist) {
 		TIFFError(module,
 			  "%.1000s: Failed to allocate space for IFD list",
 			  tif->tif_name);
 		return (0);
 	}
+	tif->tif_dirlist = new_dirlist;
 	tif->tif_dirlist[tif->tif_dirnumber - 1] = tif->tif_diroff;
d29 21
a49 2
 	/*
@@@@ -140,7 +148,7 @@@@ TIFFReadDirectory(TIFF* tif)
d52 77
a128 50
 		dir = (TIFFDirEntry *)CheckMalloc(tif,
-		    dircount * sizeof (TIFFDirEntry), "to read TIFF directory");
+		    dircount, sizeof (TIFFDirEntry), "to read TIFF directory");
 		if (dir == NULL)
 			return (0);
 		if (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) {
@@@@ -167,7 +175,7 @@@@ TIFFReadDirectory(TIFF* tif)
 		if (tif->tif_flags & TIFF_SWAB)
 			TIFFSwabShort(&dircount);
 		dir = (TIFFDirEntry *)CheckMalloc(tif,
-		    dircount * sizeof (TIFFDirEntry), "to read TIFF directory");
+		    dircount, sizeof (TIFFDirEntry), "to read TIFF directory");
 		if (dir == NULL)
 			return (0);
 		if (off + dircount*sizeof (TIFFDirEntry) > tif->tif_size) {
@@@@ -175,9 +183,10 @@@@ TIFFReadDirectory(TIFF* tif)
                                   "%.1000s: Can not read TIFF directory",
                                   tif->tif_name);
 			goto bad;
-		} else
+		} else {
 			_TIFFmemcpy(dir, tif->tif_base + off,
-			    dircount*sizeof (TIFFDirEntry));
+				    dircount*sizeof (TIFFDirEntry));
+		}
 		off += dircount* sizeof (TIFFDirEntry);
 		if (off + sizeof (uint32) <= tif->tif_size)
 			_TIFFmemcpy(&nextdiroff, tif->tif_base+off, sizeof (uint32));
@@@@ -390,6 +399,11 @@@@ TIFFReadDirectory(TIFF* tif)
 		td->td_nstrips = TIFFNumberOfTiles(tif);
 		tif->tif_flags |= TIFF_ISTILED;
 	}
+	if (!td->td_nstrips) {
+		TIFFError(module, "%s: cannot handle zero number of %s",
+			  tif->tif_name, isTiled(tif) ? "tiles" : "strips");
+		goto bad;
+	}
 	td->td_stripsperimage = td->td_nstrips;
 	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
 		td->td_stripsperimage /= td->td_samplesperpixel;
@@@@ -466,7 +480,7 @@@@ TIFFReadDirectory(TIFF* tif)
 					break;
 			}
 			v *= sizeof (uint16);
-			cp = CheckMalloc(tif, dp->tdir_count * sizeof (uint16),
+			cp = CheckMalloc(tif, dp->tdir_count, sizeof (uint16),
 			    "to read \"TransferFunction\" tag");
 			if (cp != NULL) {
 				if (TIFFFetchData(tif, dp, cp)) {
@@@@ -573,8 +587,10 @@@@ TIFFReadDirectory(TIFF* tif)
d131 16
d148 12
a159 15
-	if (dir)
+	if (dir) {
 		_TIFFfree((char *)dir);
+		dir = NULL;
+	}
 	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
 		td->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);
 	/*
@@@@ -601,8 +617,28 @@@@ TIFFReadDirectory(TIFF* tif)
 	tif->tif_curstrip = (tstrip_t) -1;
 	tif->tif_col = (uint32) -1;
 	tif->tif_curtile = (ttile_t) -1;
-	tif->tif_tilesize = TIFFTileSize(tif);
+	tif->tif_tilesize = (tsize_t) -1;
 	tif->tif_scanlinesize = TIFFScanlineSize(tif);
a160 23
+	if (!tif->tif_scanlinesize) {
+		TIFFError(module, "%s: cannot handle zero scanline size",
+			  tif->tif_name);
+		return (0);
+	}
+	if (isTiled(tif)) {
+		tif->tif_tilesize = TIFFTileSize(tif);
+		if (!tif->tif_tilesize) {
+			TIFFError(module, "%s: cannot handle zero tile size",
+				tif->tif_name);
+			return (0);
+		}
+	} else {
+		if (!TIFFStripSize(tif)) {
+			TIFFError(module, "%s: cannot handle zero strip size",
+				tif->tif_name);
+			return (0);
+		}
+	}
 	return (1);
 bad:
 	if (dir)
@@@@ -622,7 +658,7 @@@@ EstimateStripByteCounts(TIFF* tif, TIFFD
d164 72
a235 15
-	    CheckMalloc(tif, td->td_nstrips * sizeof (uint32),
+	    CheckMalloc(tif, td->td_nstrips, sizeof (uint32),
 		"for \"StripByteCounts\" array");
 	if (td->td_compression != COMPRESSION_NONE) {
 		uint32 space = (uint32)(sizeof (TIFFHeader)
@@@@ -931,7 +967,7 @@@@ TIFFFetchRationalArray(TIFF* tif, TIFFDi
 	uint32* l;
 
 	l = (uint32*)CheckMalloc(tif,
-	    dir->tdir_count*TIFFDataWidth((TIFFDataType) dir->tdir_type),
+	    dir->tdir_count, TIFFDataWidth((TIFFDataType) dir->tdir_type),
 	    "to fetch array of rationals");
 	if (l) {
 		if (TIFFFetchData(tif, dir, (char *)l)) {
@@@@ -1087,35 +1123,35 @@@@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEnt
d237 15
a251 68
 			/* NB: always expand BYTE values to shorts */
 			cp = CheckMalloc(tif,
-			    dp->tdir_count * sizeof (uint16), mesg);
+			    dp->tdir_count, sizeof (uint16), mesg);
 			ok = cp && TIFFFetchByteArray(tif, dp, (uint16*) cp);
 			break;
 		case TIFF_SHORT:
 		case TIFF_SSHORT:
 			cp = CheckMalloc(tif,
-			    dp->tdir_count * sizeof (uint16), mesg);
+			    dp->tdir_count, sizeof (uint16), mesg);
 			ok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);
 			break;
 		case TIFF_LONG:
 		case TIFF_SLONG:
 			cp = CheckMalloc(tif,
-			    dp->tdir_count * sizeof (uint32), mesg);
+			    dp->tdir_count, sizeof (uint32), mesg);
 			ok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);
 			break;
 		case TIFF_RATIONAL:
 		case TIFF_SRATIONAL:
 			cp = CheckMalloc(tif,
-			    dp->tdir_count * sizeof (float), mesg);
+			    dp->tdir_count, sizeof (float), mesg);
 			ok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);
 			break;
 		case TIFF_FLOAT:
 			cp = CheckMalloc(tif,
-			    dp->tdir_count * sizeof (float), mesg);
+			    dp->tdir_count, sizeof (float), mesg);
 			ok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);
 			break;
 		case TIFF_DOUBLE:
 			cp = CheckMalloc(tif,
-			    dp->tdir_count * sizeof (double), mesg);
+			    dp->tdir_count, sizeof (double), mesg);
 			ok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);
 			break;
 		case TIFF_ASCII:
@@@@ -1124,7 +1160,7 @@@@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEnt
 			 * Some vendors write strings w/o the trailing
 			 * NULL byte, so always append one just in case.
 			 */
-			cp = CheckMalloc(tif, dp->tdir_count+1, mesg);
+			cp = CheckMalloc(tif, dp->tdir_count+1, 1, mesg);
 			if( (ok = (cp && TIFFFetchString(tif, dp, cp))) != 0 )
 				cp[dp->tdir_count] = '\0';	/* XXX */
 			break;
@@@@ -1226,8 +1262,9 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
 		uint16* v = buf;
 
 		if (samples > NITEMS(buf))
-			v = (uint16*) _TIFFmalloc(samples * sizeof (uint16));
-		if (TIFFFetchShortArray(tif, dir, v)) {
+			v = (uint16*) CheckMalloc(tif, samples, sizeof (uint16),
+						  "to fetch per-sample values");
+		if (v && TIFFFetchShortArray(tif, dir, v)) {
 			int i;
 			for (i = 1; i < samples; i++)
 				if (v[i] != v[0]) {
@@@@ -1240,7 +1277,7 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
 			status = 1;
 		}
 	bad:
-		if (v != buf)
+		if (v && v != buf)
 			_TIFFfree((char*) v);
d253 8
a260 60
 	return (status);
@@@@ -1262,8 +1299,9 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
 		double* v = buf;
 
 		if (samples > NITEMS(buf))
-			v = (double*) _TIFFmalloc(samples * sizeof (double));
-		if (TIFFFetchAnyArray(tif, dir, v)) {
+			v = (double*) CheckMalloc(tif, samples, sizeof (double),
+						  "to fetch per-sample values");
+		if (v && TIFFFetchAnyArray(tif, dir, v)) {
 			int i;
 			for (i = 1; i < samples; i++)
 				if (v[i] != v[0]) {
@@@@ -1276,7 +1314,7 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
 			status = 1;
 		}
 	bad:
-		if (v != buf)
+		if (v && v != buf)
 			_TIFFfree(v);
 	}
 	return (status);
@@@@ -1301,7 +1339,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
 	 */
 	if (*lpp == NULL &&
 	    (*lpp = (uint32 *)CheckMalloc(tif,
-	      nstrips * sizeof (uint32), "for strip array")) == NULL)
+	      nstrips, sizeof (uint32), "for strip array")) == NULL)
 		return (0);
 	lp = *lpp;
         memset( lp, 0, sizeof(uint32) * nstrips );
@@@@ -1311,7 +1349,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
 		 * Handle uint16->uint32 expansion.
 		 */
 		uint16* dp = (uint16*) CheckMalloc(tif,
-		    dir->tdir_count* sizeof (uint16), "to fetch strip tag");
+		    dir->tdir_count, sizeof (uint16), "to fetch strip tag");
 		if (dp == NULL)
 			return (0);
 		if( (status = TIFFFetchShortArray(tif, dir, dp)) != 0 ) {
@@@@ -1328,7 +1366,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
             /* Special case to correct length */
 
             uint32* dp = (uint32*) CheckMalloc(tif,
-		    dir->tdir_count* sizeof (uint32), "to fetch strip tag");
+		    dir->tdir_count, sizeof (uint32), "to fetch strip tag");
             if (dp == NULL)
                 return (0);
 
@@@@ -1360,8 +1398,12 @@@@ TIFFFetchExtraSamples(TIFF* tif, TIFFDir
 	uint16* v = buf;
 	int status;
 
-	if (dir->tdir_count > NITEMS(buf))
-		v = (uint16*) _TIFFmalloc(dir->tdir_count * sizeof (uint16));
+	if (dir->tdir_count > NITEMS(buf)) {
+		v = (uint16*) CheckMalloc(tif, dir->tdir_count, sizeof (uint16),
+					  "to fetch extra samples");
+		if (!v)
+			return (0);
d262 63
a324 28
 	if (dir->tdir_type == TIFF_BYTE)
 		status = TIFFFetchByteArray(tif, dir, v);
 	else
@@@@ -1390,10 +1432,10 @@@@ TIFFFetchRefBlackWhite(TIFF* tif, TIFFDi
 	/*
 	 * Handle LONG's for backward compatibility.
 	 */
-	cp = CheckMalloc(tif, dir->tdir_count * sizeof (uint32), mesg);
+	cp = CheckMalloc(tif, dir->tdir_count, sizeof (uint32), mesg);
 	if( (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) != 0) {
 		float* fp = (float*)
-		    CheckMalloc(tif, dir->tdir_count * sizeof (float), mesg);
+		    CheckMalloc(tif, dir->tdir_count, sizeof (float), mesg);
 		if( (ok = (fp != NULL)) != 0 ) {
 			uint32 i;
 			for (i = 0; i < dir->tdir_count; i++)
@@@@ -1444,9 +1486,9 @@@@ ChopUpSingleUncompressedStrip(TIFF* tif)
 	if (rowsperstrip >= td->td_rowsperstrip)
 		return;
 	nstrips = (tstrip_t) TIFFhowmany(bytecount, stripbytes);
-	newcounts = (uint32*) CheckMalloc(tif, nstrips * sizeof (uint32),
+	newcounts = (uint32*) CheckMalloc(tif, nstrips, sizeof (uint32),
 				"for chopped \"StripByteCounts\" array");
-	newoffsets = (uint32*) CheckMalloc(tif, nstrips * sizeof (uint32),
+	newoffsets = (uint32*) CheckMalloc(tif, nstrips, sizeof (uint32),
 				"for chopped \"StripOffsets\" array");
 	if (newcounts == NULL || newoffsets == NULL) {
 	        /*
@


1.3
log
@fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_dirread_c,v 1.2 2005/03/27 03:57:26 brad Exp $
@


1.3.4.1
log
@cumulative update with patches of recent months

MFC:
fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
---
fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
---
fix MASTER_SITES; From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_dirread_c,v 1.3 2005/03/27 05:12:15 brad Exp $
@


1.3.4.2
log
@Fix a Denial of Service vulnerability and a buffer overflow.

- Check for zero YCbCr subsampling values which cause a division by zero crash.
- Properly check the BitsPerSample tag.

CAN-2005-1544
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_dirread_c,v 1.1.2.2 2005/07/29 17:38:59 brad Exp $
d3 1
a3 1
+++ libtiff/tif_dirread.c	Fri Jul 29 13:31:50 2005
d214 1
a214 2
@@@@ -1225,11 +1261,16 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
 		uint16 buf[10];
d217 1
a217 1
-		if (samples > NITEMS(buf))
d220 1
a220 2
+		if (dir->tdir_count > NITEMS(buf))
+			v = (uint16*) CheckMalloc(tif, dir->tdir_count, sizeof(uint16),
d224 1
a224 6
-			for (i = 1; i < samples; i++)
+			int check_count = dir->tdir_count;
+			if (samples < check_count)
+				check_count = samples;
+
+			for (i = 1; i < check_count; i++)
d226 1
a226 3
 					TIFFError(tif->tif_name,
 		"Cannot handle different per-sample values for field \"%s\"",
@@@@ -1240,7 +1281,7 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
d235 1
a235 2
@@@@ -1261,11 +1302,16 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
 		double buf[10];
d238 1
a238 1
-		if (samples > NITEMS(buf))
d241 1
a241 2
+		if (dir->tdir_count > NITEMS(buf))
+			v = (double*) CheckMalloc(tif, dir->tdir_count, sizeof (double),
d245 1
a245 6
-			for (i = 1; i < samples; i++)
+			int check_count = dir->tdir_count;
+			if (samples < check_count)
+				check_count = samples;
+
+			for (i = 1; i < check_count; i++)
d247 1
a247 3
 					TIFFError(tif->tif_name,
 		"Cannot handle different per-sample values for field \"%s\"",
@@@@ -1276,7 +1322,7 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
d256 1
a256 1
@@@@ -1301,7 +1347,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d265 1
a265 1
@@@@ -1311,7 +1357,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d274 1
a274 1
@@@@ -1328,7 +1374,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d283 1
a283 1
@@@@ -1360,8 +1406,12 @@@@ TIFFFetchExtraSamples(TIFF* tif, TIFFDir
d298 1
a298 1
@@@@ -1390,10 +1440,10 @@@@ TIFFFetchRefBlackWhite(TIFF* tif, TIFFDi
d311 1
a311 1
@@@@ -1444,9 +1494,9 @@@@ ChopUpSingleUncompressedStrip(TIFF* tif)
@


1.3.2.1
log
@cumulative update with patches of recent months

MFC:
fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
---
fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
---
fix MASTER_SITES; From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_dirread_c,v 1.3 2005/03/27 05:12:15 brad Exp $
@


1.2
log
@Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_dirread_c,v 1.1 2004/10/20 20:37:48 brad Exp $
d3 1
a3 1
+++ libtiff/tif_dirread.c	Sat Mar 26 22:45:43 2005
d115 3
a117 1
@@@@ -603,6 +619,17 @@@@ TIFFReadDirectory(TIFF* tif)
d119 2
a120 1
 	tif->tif_tilesize = TIFFTileSize(tif);
a122 5
+	if (!tif->tif_tilesize) {
+		TIFFError(module, "%s: cannot handle zero tile size",
+			  tif->tif_name);
+		return (0);
+	}
d128 14
d145 1
a145 1
@@@@ -622,7 +649,7 @@@@ EstimateStripByteCounts(TIFF* tif, TIFFD
d154 1
a154 1
@@@@ -931,7 +958,7 @@@@ TIFFFetchRationalArray(TIFF* tif, TIFFDi
d163 1
a163 1
@@@@ -1087,35 +1114,35 @@@@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEnt
d205 1
a205 1
@@@@ -1124,7 +1151,7 @@@@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEnt
d214 1
a214 1
@@@@ -1226,8 +1253,9 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
d226 1
a226 1
@@@@ -1240,7 +1268,7 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
d235 1
a235 1
@@@@ -1262,8 +1290,9 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
d247 1
a247 1
@@@@ -1276,7 +1305,7 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
d256 1
a256 1
@@@@ -1301,7 +1330,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d265 1
a265 1
@@@@ -1311,7 +1340,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d274 1
a274 1
@@@@ -1328,7 +1357,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d283 1
a283 1
@@@@ -1360,8 +1389,12 @@@@ TIFFFetchExtraSamples(TIFF* tif, TIFFDir
d298 1
a298 1
@@@@ -1390,10 +1423,10 @@@@ TIFFFetchRefBlackWhite(TIFF* tif, TIFFDi
d311 1
a311 1
@@@@ -1444,9 +1477,9 @@@@ ChopUpSingleUncompressedStrip(TIFF* tif)
@


1.1
log
@Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ libtiff/tif_dirread.c	Wed Oct 20 14:38:11 2004
d15 1
a15 1
+	if (elem_size && bytes / elem_size == nmemb)
@


1.1.2.1
log
@SECURITY:
fix multiple vulnerabilities; bump PKGNAME
http://www.vuxml.org/openbsd/d045aeb6-9ea6-11d9-9623-00065bd5b0b6.html

ok brad@@
@
text
@d3 1
a3 1
+++ libtiff/tif_dirread.c	Sat Mar 26 23:18:01 2005
d15 1
a15 1
+	if (nmemb && elem_size && bytes / elem_size == nmemb)
d115 1
a115 3
@@@@ -601,8 +617,28 @@@@ TIFFReadDirectory(TIFF* tif)
 	tif->tif_curstrip = (tstrip_t) -1;
 	tif->tif_col = (uint32) -1;
d117 1
a117 2
-	tif->tif_tilesize = TIFFTileSize(tif);
+	tif->tif_tilesize = (tsize_t) -1;
d120 5
a129 14
+	if (isTiled(tif)) {
+		tif->tif_tilesize = TIFFTileSize(tif);
+		if (!tif->tif_tilesize) {
+			TIFFError(module, "%s: cannot handle zero tile size",
+				tif->tif_name);
+			return (0);
+		}
+	} else {
+		if (!TIFFStripSize(tif)) {
+			TIFFError(module, "%s: cannot handle zero strip size",
+				tif->tif_name);
+			return (0);
+		}
+	}
d133 1
a133 1
@@@@ -622,7 +658,7 @@@@ EstimateStripByteCounts(TIFF* tif, TIFFD
d142 1
a142 1
@@@@ -931,7 +967,7 @@@@ TIFFFetchRationalArray(TIFF* tif, TIFFDi
d151 1
a151 1
@@@@ -1087,35 +1123,35 @@@@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEnt
d193 1
a193 1
@@@@ -1124,7 +1160,7 @@@@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEnt
d202 1
a202 1
@@@@ -1226,8 +1262,9 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
d214 1
a214 1
@@@@ -1240,7 +1277,7 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
d223 1
a223 1
@@@@ -1262,8 +1299,9 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
d235 1
a235 1
@@@@ -1276,7 +1314,7 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
d244 1
a244 1
@@@@ -1301,7 +1339,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d253 1
a253 1
@@@@ -1311,7 +1349,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d262 1
a262 1
@@@@ -1328,7 +1366,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d271 1
a271 1
@@@@ -1360,8 +1398,12 @@@@ TIFFFetchExtraSamples(TIFF* tif, TIFFDir
d286 1
a286 1
@@@@ -1390,10 +1432,10 @@@@ TIFFFetchRefBlackWhite(TIFF* tif, TIFFDi
d299 1
a299 1
@@@@ -1444,9 +1486,9 @@@@ ChopUpSingleUncompressedStrip(TIFF* tif)
@


1.1.2.2
log
@Fix a Denial of Service vulnerability and a buffer overflow.

- Check for zero YCbCr subsampling values which cause a division by zero crash.
- Properly check the BitsPerSample tag.

CAN-2005-1544
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_dirread_c,v 1.1.2.1 2005/05/25 05:37:32 robert Exp $
d3 1
a3 1
+++ libtiff/tif_dirread.c	Fri Jul 29 13:31:50 2005
d214 1
a214 2
@@@@ -1225,11 +1261,16 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
 		uint16 buf[10];
d217 1
a217 1
-		if (samples > NITEMS(buf))
d220 1
a220 2
+		if (dir->tdir_count > NITEMS(buf))
+			v = (uint16*) CheckMalloc(tif, dir->tdir_count, sizeof(uint16),
d224 1
a224 6
-			for (i = 1; i < samples; i++)
+			int check_count = dir->tdir_count;
+			if (samples < check_count)
+				check_count = samples;
+
+			for (i = 1; i < check_count; i++)
d226 1
a226 3
 					TIFFError(tif->tif_name,
 		"Cannot handle different per-sample values for field \"%s\"",
@@@@ -1240,7 +1281,7 @@@@ TIFFFetchPerSampleShorts(TIFF* tif, TIFF
d235 1
a235 2
@@@@ -1261,11 +1302,16 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
 		double buf[10];
d238 1
a238 1
-		if (samples > NITEMS(buf))
d241 1
a241 2
+		if (dir->tdir_count > NITEMS(buf))
+			v = (double*) CheckMalloc(tif, dir->tdir_count, sizeof (double),
d245 1
a245 6
-			for (i = 1; i < samples; i++)
+			int check_count = dir->tdir_count;
+			if (samples < check_count)
+				check_count = samples;
+
+			for (i = 1; i < check_count; i++)
d247 1
a247 3
 					TIFFError(tif->tif_name,
 		"Cannot handle different per-sample values for field \"%s\"",
@@@@ -1276,7 +1322,7 @@@@ TIFFFetchPerSampleAnys(TIFF* tif, TIFFDi
d256 1
a256 1
@@@@ -1301,7 +1347,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d265 1
a265 1
@@@@ -1311,7 +1357,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d274 1
a274 1
@@@@ -1328,7 +1374,7 @@@@ TIFFFetchStripThing(TIFF* tif, TIFFDirEn
d283 1
a283 1
@@@@ -1360,8 +1406,12 @@@@ TIFFFetchExtraSamples(TIFF* tif, TIFFDir
d298 1
a298 1
@@@@ -1390,10 +1440,10 @@@@ TIFFFetchRefBlackWhite(TIFF* tif, TIFFDi
d311 1
a311 1
@@@@ -1444,9 +1494,9 @@@@ ChopUpSingleUncompressedStrip(TIFF* tif)
@


