head	1.12;
access;
symbols
	OPENBSD_6_1:1.11.0.2
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.12
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.10
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@# @;


1.12
date	2017.05.26.20.50.57;	author naddy;	state Exp;
branches;
next	1.11;
commitid	LwF6tGmRy7OxvnlY;

1.11
date	2016.11.29.20.00.35;	author naddy;	state Exp;
branches;
next	1.10;
commitid	3rYO2yYEq9TuBxfZ;

1.10
date	2016.01.24.16.48.49;	author naddy;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;
commitid	9i2aWLjoSlOEXDeK;

1.9
date	2015.03.29.17.39.22;	author naddy;	state Exp;
branches
	1.9.4.1;
next	1.8;
commitid	DVvDfC6c0cv0tIBV;

1.8
date	2012.06.27.14.27.02;	author jasper;	state Exp;
branches
	1.8.10.1
	1.8.12.1;
next	1.7;

1.7
date	2012.04.14.15.09.55;	author naddy;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.09.17.35.38;	author naddy;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.30.17.10.08;	author naddy;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2005.06.18.21.24.40;	author naddy;	state dead;
branches;
next	1.3;

1.3
date	2005.03.27.06.13.07;	author brad;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2005.03.27.03.40.00;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.20.20.37.48;	author brad;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.05.25.05.37.32;	author robert;	state Exp;
branches;
next	;

1.3.2.1
date	2005.03.31.22.02.44;	author sturm;	state Exp;
branches;
next	;

1.3.4.1
date	2005.03.31.22.08.46;	author sturm;	state Exp;
branches;
next	;

1.5.8.1
date	2012.04.13.07.18.06;	author jasper;	state Exp;
branches;
next	;

1.8.10.1
date	2015.03.29.20.58.58;	author naddy;	state Exp;
branches;
next	;
commitid	yV7LOUcjZFa2iAbX;

1.8.12.1
date	2015.03.29.19.41.56;	author naddy;	state Exp;
branches;
next	;
commitid	tay2jRrbkJ3GxbDm;

1.9.4.1
date	2016.01.25.16.08.35;	author jasper;	state Exp;
branches;
next	;
commitid	lZDo9FLWFeOiEZlI;

1.10.2.1
date	2016.11.30.22.14.18;	author naddy;	state Exp;
branches;
next	;
commitid	HYFVXR4DcvEOAZJj;

1.10.4.1
date	2016.11.30.21.36.36;	author naddy;	state Exp;
branches;
next	;
commitid	SSUFe7wdxWokBCcs;


desc
@@


1.12
log
@Security update to 4.0.8:
Fixes CVE-2017-5225, CVE-2017-7592 to -7602
@
text
@$OpenBSD: patch-libtiff_tif_getimage_c,v 1.11 2016/11/29 20:00:35 naddy Exp $

This one is slightly problematic.  If an application allocates less
room for its error buffer than the recommended 1024, the error message
buffer will still overflow.

Index: libtiff/tif_getimage.c
--- libtiff/tif_getimage.c.orig
+++ libtiff/tif_getimage.c
@@@@ -80,7 +80,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 	int colorchannels;
 
 	if (!tif->tif_decodestatus) {
-		sprintf(emsg, "Sorry, requested compression method is not configured");
+		snprintf(emsg, 1024, "Sorry, requested compression method is not configured");
 		return (0);
 	}
 	switch (td->td_bitspersample) {
@@@@ -91,12 +91,12 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 		case 16:
 			break;
 		default:
-			sprintf(emsg, "Sorry, can not handle images with %d-bit samples",
+			snprintf(emsg, 1024, "Sorry, can not handle images with %d-bit samples",
 			    td->td_bitspersample);
 			return (0);
 	}
         if (td->td_sampleformat == SAMPLEFORMAT_IEEEFP) {
-                sprintf(emsg, "Sorry, can not handle images with IEEE floating-point samples");
+                snprintf(emsg, 1024, "Sorry, can not handle images with IEEE floating-point samples");
                 return (0);
         }
 	colorchannels = td->td_samplesperpixel - td->td_extrasamples;
@@@@ -109,7 +109,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 				photometric = PHOTOMETRIC_RGB;
 				break;
 			default:
-				sprintf(emsg, "Missing needed %s tag", photoTag);
+				snprintf(emsg, 1024, "Missing needed %s tag", photoTag);
 				return (0);
 		}
 	}
@@@@ -120,7 +120,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 			if (td->td_planarconfig == PLANARCONFIG_CONTIG
 			    && td->td_samplesperpixel != 1
 			    && td->td_bitspersample < 8 ) {
-				sprintf(emsg,
+				snprintf(emsg, 1024,
 				    "Sorry, can not handle contiguous data with %s=%d, "
 				    "and %s=%d and Bits/Sample=%d",
 				    photoTag, photometric,
@@@@ -144,7 +144,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 			break;
 		case PHOTOMETRIC_RGB:
 			if (colorchannels < 3) {
-				sprintf(emsg, "Sorry, can not handle RGB image with %s=%d",
+				snprintf(emsg, 1024, "Sorry, can not handle RGB image with %s=%d",
 				    "Color channels", colorchannels);
 				return (0);
 			}
@@@@ -154,13 +154,13 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 				uint16 inkset;
 				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
 				if (inkset != INKSET_CMYK) {
-					sprintf(emsg,
+					snprintf(emsg, 1024,
 					    "Sorry, can not handle separated image with %s=%d",
 					    "InkSet", inkset);
 					return 0;
 				}
 				if (td->td_samplesperpixel < 4) {
-					sprintf(emsg,
+					snprintf(emsg, 1024,
 					    "Sorry, can not handle separated image with %s=%d",
 					    "Samples/pixel", td->td_samplesperpixel);
 					return 0;
@@@@ -169,7 +169,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 			}
 		case PHOTOMETRIC_LOGL:
 			if (td->td_compression != COMPRESSION_SGILOG) {
-				sprintf(emsg, "Sorry, LogL data must have %s=%d",
+				snprintf(emsg, 1024, "Sorry, LogL data must have %s=%d",
 				    "Compression", COMPRESSION_SGILOG);
 				return (0);
 			}
@@@@ -177,17 +177,17 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 		case PHOTOMETRIC_LOGLUV:
 			if (td->td_compression != COMPRESSION_SGILOG &&
 			    td->td_compression != COMPRESSION_SGILOG24) {
-				sprintf(emsg, "Sorry, LogLuv data must have %s=%d or %d",
+				snprintf(emsg, 1024, "Sorry, LogLuv data must have %s=%d or %d",
 				    "Compression", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);
 				return (0);
 			}
 			if (td->td_planarconfig != PLANARCONFIG_CONTIG) {
-				sprintf(emsg, "Sorry, can not handle LogLuv images with %s=%d",
+				snprintf(emsg, 1024, "Sorry, can not handle LogLuv images with %s=%d",
 				    "Planarconfiguration", td->td_planarconfig);
 				return (0);
 			}
 			if ( td->td_samplesperpixel != 3 || colorchannels != 3 ) {
-                                sprintf(emsg,
+                                snprintf(emsg, 1024,
                                         "Sorry, can not handle image with %s=%d, %s=%d",
                                         "Samples/pixel", td->td_samplesperpixel,
                                         "colorchannels", colorchannels);
@@@@ -196,7 +196,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
 			break;
 		case PHOTOMETRIC_CIELAB:
                         if ( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 ) {
-                                sprintf(emsg,
+                                snprintf(emsg, 1024,
                                         "Sorry, can not handle image with %s=%d, %s=%d and %s=%d",
                                         "Samples/pixel", td->td_samplesperpixel,
                                         "colorchannels", colorchannels,
@@@@ -205,7 +205,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
                         }
 			break;
                 default:
-			sprintf(emsg, "Sorry, can not handle image with %s=%d",
+			snprintf(emsg, 1024, "Sorry, can not handle image with %s=%d",
 			    photoTag, photometric);
 			return (0);
 	}
@@@@ -303,7 +303,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 		case 16:
 			break;
 		default:
-			sprintf(emsg, "Sorry, can not handle images with %d-bit samples",
+			snprintf(emsg, 1024, "Sorry, can not handle images with %d-bit samples",
 			    img->bitspersample);
 			goto fail_return;
 	}
@@@@ -353,7 +353,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 				img->photometric = PHOTOMETRIC_RGB;
 				break;
 			default:
-				sprintf(emsg, "Missing needed %s tag", photoTag);
+				snprintf(emsg, 1024, "Missing needed %s tag", photoTag);
                                 goto fail_return;
 		}
 	}
@@@@ -361,7 +361,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 		case PHOTOMETRIC_PALETTE:
 			if (!TIFFGetField(tif, TIFFTAG_COLORMAP,
 			    &red_orig, &green_orig, &blue_orig)) {
-				sprintf(emsg, "Missing required \"Colormap\" tag");
+				snprintf(emsg, 1024, "Missing required \"Colormap\" tag");
                                 goto fail_return;
 			}
 
@@@@ -371,7 +371,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 			img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
 			img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
 			if( !img->redcmap || !img->greencmap || !img->bluecmap ) {
-				sprintf(emsg, "Out of memory for colormap copy");
+				snprintf(emsg, 1024, "Out of memory for colormap copy");
                                 goto fail_return;
 			}
 
@@@@ -385,7 +385,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 			if (planarconfig == PLANARCONFIG_CONTIG
 			    && img->samplesperpixel != 1
 			    && img->bitspersample < 8 ) {
-				sprintf(emsg,
+				snprintf(emsg, 1024,
 				    "Sorry, can not handle contiguous data with %s=%d, "
 				    "and %s=%d and Bits/Sample=%d",
 				    photoTag, img->photometric,
@@@@ -422,7 +422,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 			break;
 		case PHOTOMETRIC_RGB:
 			if (colorchannels < 3) {
-				sprintf(emsg, "Sorry, can not handle RGB image with %s=%d",
+				snprintf(emsg, 1024, "Sorry, can not handle RGB image with %s=%d",
 				    "Color channels", colorchannels);
                                 goto fail_return;
 			}
@@@@ -432,12 +432,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 				uint16 inkset;
 				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
 				if (inkset != INKSET_CMYK) {
-					sprintf(emsg, "Sorry, can not handle separated image with %s=%d",
+					snprintf(emsg, 1024, "Sorry, can not handle separated image with %s=%d",
 					    "InkSet", inkset);
                                         goto fail_return;
 				}
 				if (img->samplesperpixel < 4) {
-					sprintf(emsg, "Sorry, can not handle separated image with %s=%d",
+					snprintf(emsg, 1024, "Sorry, can not handle separated image with %s=%d",
 					    "Samples/pixel", img->samplesperpixel);
                                         goto fail_return;
 				}
@@@@ -445,7 +445,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 			break;
 		case PHOTOMETRIC_LOGL:
 			if (compress != COMPRESSION_SGILOG) {
-				sprintf(emsg, "Sorry, LogL data must have %s=%d",
+				snprintf(emsg, 1024, "Sorry, LogL data must have %s=%d",
 				    "Compression", COMPRESSION_SGILOG);
                                 goto fail_return;
 			}
@@@@ -455,12 +455,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 			break;
 		case PHOTOMETRIC_LOGLUV:
 			if (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {
-				sprintf(emsg, "Sorry, LogLuv data must have %s=%d or %d",
+				snprintf(emsg, 1024, "Sorry, LogLuv data must have %s=%d or %d",
 				    "Compression", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);
                                 goto fail_return;
 			}
 			if (planarconfig != PLANARCONFIG_CONTIG) {
-				sprintf(emsg, "Sorry, can not handle LogLuv images with %s=%d",
+				snprintf(emsg, 1024, "Sorry, can not handle LogLuv images with %s=%d",
 				    "Planarconfiguration", planarconfig);
 				return (0);
 			}
@@@@ -471,7 +471,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 		case PHOTOMETRIC_CIELAB:
 			break;
 		default:
-			sprintf(emsg, "Sorry, can not handle image with %s=%d",
+			snprintf(emsg, 1024, "Sorry, can not handle image with %s=%d",
 			    photoTag, img->photometric);
                         goto fail_return;
 	}
@@@@ -482,12 +482,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 	    !(planarconfig == PLANARCONFIG_SEPARATE && img->samplesperpixel > 1);
 	if (img->isContig) {
 		if (!PickContigCase(img)) {
-			sprintf(emsg, "Sorry, can not handle image");
+			snprintf(emsg, 1024, "Sorry, can not handle image");
 			goto fail_return;
 		}
 	} else {
 		if (!PickSeparateCase(img)) {
-			sprintf(emsg, "Sorry, can not handle image");
+			snprintf(emsg, 1024, "Sorry, can not handle image");
 			goto fail_return;
 		}
 	}
@


1.11
log
@Update to 4.0.7.
* Multiple security fixes, including
  CVE-2016-3622, CVE-2014-8127, CVE-2016-9273, CVE-2016-9448,
  MSVR 35094, MSVR 35095, MSVR 35105
* Remove obsolete tools bmp2tiff, gif2tiff, ras2tiff, sgi2tiff, sgisv, ycbcr
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.9 2015/03/29 17:39:22 naddy Exp $
d7 3
a9 2
--- libtiff/tif_getimage.c.orig	Fri Nov 18 03:47:45 2016
+++ libtiff/tif_getimage.c	Thu Nov 24 22:01:47 2016
d125 1
a125 1
@@@@ -296,7 +296,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d134 1
a134 1
@@@@ -346,7 +346,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d143 1
a143 1
@@@@ -354,7 +354,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d152 1
a152 1
@@@@ -364,7 +364,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d161 1
a161 1
@@@@ -378,7 +378,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d170 1
a170 1
@@@@ -415,7 +415,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d179 1
a179 1
@@@@ -425,12 +425,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d194 1
a194 1
@@@@ -438,7 +438,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d203 1
a203 1
@@@@ -448,12 +448,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d218 1
a218 1
@@@@ -464,7 +464,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
@


1.10
log
@Fix a number of out-of-bound reads and writes, including CVE-2015-8665 and
CVE-2015-8683.  From upstream CVS.
@
text
@d3 3
a5 5
* libtiff/tif_getimage.c: fix out-of-bound reads in TIFFRGBAImage
interface in case of unsupported values of SamplesPerPixel/ExtraSamples
for LogLUV / CIELab. Add explicit call to TIFFRGBAImageOK() in
TIFFRGBAImageBegin(). Fix CVE-2015-8665 reported by limingxing and
CVE-2015-8683 reported by zzf of Alibaba.
d7 2
a8 6
This snprintf conversion is slightly problematic.  If an application
allocates less room for its error buffer than the recommended 1024,
the error message buffer will still overflow.

--- libtiff/tif_getimage.c.orig	Sat Aug 29 00:16:22 2015
+++ libtiff/tif_getimage.c	Sun Jan 24 17:04:12 2016
d18 1
a18 1
@@@@ -91,7 +91,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d27 7
a33 1
@@@@ -105,7 +105,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d42 1
a42 1
@@@@ -116,7 +116,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d51 1
a51 1
@@@@ -140,7 +140,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d60 1
a60 1
@@@@ -150,13 +150,13 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d76 1
a76 1
@@@@ -165,7 +165,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d85 1
a85 1
@@@@ -173,35 +173,37 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d100 7
a106 12
-			if( td->td_samplesperpixel != 3 )
+			if( td->td_samplesperpixel != 3 || colorchannels != 3 )
             {
-                sprintf(emsg,
-                        "Sorry, can not handle image with %s=%d",
-                        "Samples/pixel", td->td_samplesperpixel);
+                snprintf(emsg, 1024,
+                         "Sorry, can not handle image with %s=%d, %s=%d",
+                         "Samples/pixel", td->td_samplesperpixel,
+                         "colorchannels", colorchannels);
                 return 0;
             }
d109 8
a116 12
-            if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
+            if( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 )
             {
-                sprintf(emsg,
-                        "Sorry, can not handle image with %s=%d and %s=%d",
+                snprintf(emsg, 1024,
+                        "Sorry, can not handle image with %s=%d, %s=%d and %s=%d",
                         "Samples/pixel", td->td_samplesperpixel,
+                        "colorchannels", colorchannels,
                         "Bits/sample", td->td_bitspersample);
                 return 0;
             }
d118 1
a118 1
 		default:
d124 1
a124 11
@@@@ -255,6 +257,9 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 	int colorchannels;
 	uint16 *red_orig, *green_orig, *blue_orig;
 	int n_color;
+	
+	if( !TIFFRGBAImageOK(tif, emsg) )
+		return 0;
 
 	/* Initialize to normal values */
 	img->row_offset = 0;
@@@@ -275,7 +280,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d133 1
a133 1
@@@@ -325,7 +330,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d142 1
a142 1
@@@@ -333,7 +338,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d151 1
a151 1
@@@@ -343,7 +348,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d160 1
a160 1
@@@@ -357,7 +362,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d169 1
a169 1
@@@@ -394,7 +399,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d178 1
a178 1
@@@@ -404,12 +409,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d193 1
a193 1
@@@@ -417,7 +422,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d202 1
a202 1
@@@@ -427,12 +432,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d217 1
a217 1
@@@@ -443,7 +448,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d226 1
a226 1
@@@@ -461,12 +466,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
a240 58
@@@@ -2508,29 +2513,33 @@@@ PickContigCase(TIFFRGBAImage* img)
 		case PHOTOMETRIC_RGB:
 			switch (img->bitspersample) {
 				case 8:
-					if (img->alpha == EXTRASAMPLE_ASSOCALPHA)
+					if (img->alpha == EXTRASAMPLE_ASSOCALPHA &&
+						img->samplesperpixel >= 4)
 						img->put.contig = putRGBAAcontig8bittile;
-					else if (img->alpha == EXTRASAMPLE_UNASSALPHA)
+					else if (img->alpha == EXTRASAMPLE_UNASSALPHA &&
+							 img->samplesperpixel >= 4)
 					{
 						if (BuildMapUaToAa(img))
 							img->put.contig = putRGBUAcontig8bittile;
 					}
-					else
+					else if( img->samplesperpixel >= 3 )
 						img->put.contig = putRGBcontig8bittile;
 					break;
 				case 16:
-					if (img->alpha == EXTRASAMPLE_ASSOCALPHA)
+					if (img->alpha == EXTRASAMPLE_ASSOCALPHA &&
+						img->samplesperpixel >=4 )
 					{
 						if (BuildMapBitdepth16To8(img))
 							img->put.contig = putRGBAAcontig16bittile;
 					}
-					else if (img->alpha == EXTRASAMPLE_UNASSALPHA)
+					else if (img->alpha == EXTRASAMPLE_UNASSALPHA &&
+							 img->samplesperpixel >=4 )
 					{
 						if (BuildMapBitdepth16To8(img) &&
 						    BuildMapUaToAa(img))
 							img->put.contig = putRGBUAcontig16bittile;
 					}
-					else
+					else if( img->samplesperpixel >=3 )
 					{
 						if (BuildMapBitdepth16To8(img))
 							img->put.contig = putRGBcontig16bittile;
@@@@ -2539,7 +2548,7 @@@@ PickContigCase(TIFFRGBAImage* img)
 			}
 			break;
 		case PHOTOMETRIC_SEPARATED:
-			if (buildMap(img)) {
+			if (img->samplesperpixel >=4 && buildMap(img)) {
 				if (img->bitspersample == 8) {
 					if (!img->Map)
 						img->put.contig = putRGBcontig8bitCMYKtile;
@@@@ -2635,7 +2644,7 @@@@ PickContigCase(TIFFRGBAImage* img)
 			}
 			break;
 		case PHOTOMETRIC_CIELAB:
-			if (buildMap(img)) {
+			if (img->samplesperpixel == 3 && buildMap(img)) {
 				if (img->bitspersample == 8)
 					img->put.contig = initCIELabConversion(img);
 				break;
@


1.10.2.1
log
@Update to 4.0.7.
* Multiple security fixes, including
CVE-2016-3622, CVE-2014-8127, CVE-2016-9273, CVE-2016-9448,
MSVR 35094, MSVR 35095, MSVR 35105
* Remove obsolete tools bmp2tiff, gif2tiff, ras2tiff, sgi2tiff, sgisv, ycbcr

Minor patches to maintain ABI compatibility with 4.0.6.
@
text
@d1 1
a1 1
$OpenBSD$
d3 5
a7 3
This one is slightly problematic.  If an application allocates less
room for its error buffer than the recommended 1024, the error message
buffer will still overflow.
d9 6
a14 2
--- libtiff/tif_getimage.c.orig	Fri Nov 18 03:47:45 2016
+++ libtiff/tif_getimage.c	Thu Nov 24 22:01:47 2016
d24 1
a24 1
@@@@ -91,12 +91,12 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d33 1
a33 7
         if (td->td_sampleformat == SAMPLEFORMAT_IEEEFP) {
-                sprintf(emsg, "Sorry, can not handle images with IEEE floating-point samples");
+                snprintf(emsg, 1024, "Sorry, can not handle images with IEEE floating-point samples");
                 return (0);
         }
 	colorchannels = td->td_samplesperpixel - td->td_extrasamples;
@@@@ -109,7 +109,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d42 1
a42 1
@@@@ -120,7 +120,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d51 1
a51 1
@@@@ -144,7 +144,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d60 1
a60 1
@@@@ -154,13 +154,13 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d76 1
a76 1
@@@@ -169,7 +169,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d85 1
a85 1
@@@@ -177,17 +177,17 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d100 12
a111 7
 			if ( td->td_samplesperpixel != 3 || colorchannels != 3 ) {
-                                sprintf(emsg,
+                                snprintf(emsg, 1024,
                                         "Sorry, can not handle image with %s=%d, %s=%d",
                                         "Samples/pixel", td->td_samplesperpixel,
                                         "colorchannels", colorchannels);
@@@@ -196,7 +196,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d114 12
a125 8
                         if ( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 ) {
-                                sprintf(emsg,
+                                snprintf(emsg, 1024,
                                         "Sorry, can not handle image with %s=%d, %s=%d and %s=%d",
                                         "Samples/pixel", td->td_samplesperpixel,
                                         "colorchannels", colorchannels,
@@@@ -205,7 +205,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
                         }
d127 1
a127 1
                 default:
d133 11
a143 1
@@@@ -296,7 +296,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d152 1
a152 1
@@@@ -346,7 +346,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d161 1
a161 1
@@@@ -354,7 +354,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d170 1
a170 1
@@@@ -364,7 +364,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d179 1
a179 1
@@@@ -378,7 +378,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d188 1
a188 1
@@@@ -415,7 +415,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d197 1
a197 1
@@@@ -425,12 +425,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d212 1
a212 1
@@@@ -438,7 +438,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d221 1
a221 1
@@@@ -448,12 +448,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d236 1
a236 1
@@@@ -464,7 +464,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d245 1
a245 1
@@@@ -482,12 +482,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d260 58
@


1.10.4.1
log
@Update to 4.0.7.
* Multiple security fixes, including
CVE-2016-3622, CVE-2014-8127, CVE-2016-9273, CVE-2016-9448,
MSVR 35094, MSVR 35095, MSVR 35105
* Remove obsolete tools bmp2tiff, gif2tiff, ras2tiff, sgi2tiff, sgisv, ycbcr

Minor patches to maintain ABI compatibility with 4.0.6.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.11 2016/11/29 20:00:35 naddy Exp $
d3 5
a7 3
This one is slightly problematic.  If an application allocates less
room for its error buffer than the recommended 1024, the error message
buffer will still overflow.
d9 6
a14 2
--- libtiff/tif_getimage.c.orig	Fri Nov 18 03:47:45 2016
+++ libtiff/tif_getimage.c	Thu Nov 24 22:01:47 2016
d24 1
a24 1
@@@@ -91,12 +91,12 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d33 1
a33 7
         if (td->td_sampleformat == SAMPLEFORMAT_IEEEFP) {
-                sprintf(emsg, "Sorry, can not handle images with IEEE floating-point samples");
+                snprintf(emsg, 1024, "Sorry, can not handle images with IEEE floating-point samples");
                 return (0);
         }
 	colorchannels = td->td_samplesperpixel - td->td_extrasamples;
@@@@ -109,7 +109,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d42 1
a42 1
@@@@ -120,7 +120,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d51 1
a51 1
@@@@ -144,7 +144,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d60 1
a60 1
@@@@ -154,13 +154,13 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d76 1
a76 1
@@@@ -169,7 +169,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d85 1
a85 1
@@@@ -177,17 +177,17 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d100 12
a111 7
 			if ( td->td_samplesperpixel != 3 || colorchannels != 3 ) {
-                                sprintf(emsg,
+                                snprintf(emsg, 1024,
                                         "Sorry, can not handle image with %s=%d, %s=%d",
                                         "Samples/pixel", td->td_samplesperpixel,
                                         "colorchannels", colorchannels);
@@@@ -196,7 +196,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d114 12
a125 8
                         if ( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 ) {
-                                sprintf(emsg,
+                                snprintf(emsg, 1024,
                                         "Sorry, can not handle image with %s=%d, %s=%d and %s=%d",
                                         "Samples/pixel", td->td_samplesperpixel,
                                         "colorchannels", colorchannels,
@@@@ -205,7 +205,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
                         }
d127 1
a127 1
                 default:
d133 11
a143 1
@@@@ -296,7 +296,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d152 1
a152 1
@@@@ -346,7 +346,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d161 1
a161 1
@@@@ -354,7 +354,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d170 1
a170 1
@@@@ -364,7 +364,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d179 1
a179 1
@@@@ -378,7 +378,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d188 1
a188 1
@@@@ -415,7 +415,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d197 1
a197 1
@@@@ -425,12 +425,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d212 1
a212 1
@@@@ -438,7 +438,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d221 1
a221 1
@@@@ -448,12 +448,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d236 1
a236 1
@@@@ -464,7 +464,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d245 1
a245 1
@@@@ -482,12 +482,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d260 58
@


1.9
log
@Security update to 4.0.4beta (plus one further upstream fix).
Should fix CVE-2014-8127, CVE-2014-8128, CVE-2014-8129, CVE-2014-8130,
CVE-2014-9655, CVE-2015-1547.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.8 2012/06/27 14:27:02 jasper Exp $
d3 5
a7 3
This one is slightly problematic.  If an application allocates less
room for its error buffer than the recommended 1024, the error message
buffer will still overflow.
d9 6
a14 2
--- libtiff/tif_getimage.c.orig	Mon Dec 29 19:28:46 2014
+++ libtiff/tif_getimage.c	Sun Mar 29 17:09:38 2015
d85 1
a85 1
@@@@ -173,18 +173,18 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d100 2
a101 1
 			if( td->td_samplesperpixel != 3 )
d104 2
d107 3
a109 2
                         "Sorry, can not handle image with %s=%d",
                         "Samples/pixel", td->td_samplesperpixel);
d111 2
a112 1
@@@@ -193,7 +193,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d114 2
a115 1
             if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
d118 1
d120 1
a120 1
                         "Sorry, can not handle image with %s=%d and %s=%d",
d122 1
d124 1
a124 1
@@@@ -201,7 +201,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d133 11
a143 1
@@@@ -275,7 +275,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d152 1
a152 1
@@@@ -325,7 +325,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d161 1
a161 1
@@@@ -333,7 +333,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d170 1
a170 1
@@@@ -343,7 +343,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d179 1
a179 1
@@@@ -357,7 +357,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d188 1
a188 1
@@@@ -394,7 +394,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d197 1
a197 1
@@@@ -404,12 +404,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d212 1
a212 1
@@@@ -417,7 +417,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d221 1
a221 1
@@@@ -427,12 +427,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d236 1
a236 1
@@@@ -443,7 +443,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d245 1
a245 1
@@@@ -461,12 +461,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d260 58
@


1.9.4.1
log
@Fix a number of out-of-bound reads and writes, including CVE-2015-8665 and
CVE-2015-8683.  From upstream CVS.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.10 2016/01/24 16:48:49 naddy Exp $
d3 3
a5 5
* libtiff/tif_getimage.c: fix out-of-bound reads in TIFFRGBAImage
interface in case of unsupported values of SamplesPerPixel/ExtraSamples
for LogLUV / CIELab. Add explicit call to TIFFRGBAImageOK() in
TIFFRGBAImageBegin(). Fix CVE-2015-8665 reported by limingxing and
CVE-2015-8683 reported by zzf of Alibaba.
d7 2
a8 6
This snprintf conversion is slightly problematic.  If an application
allocates less room for its error buffer than the recommended 1024,
the error message buffer will still overflow.

--- libtiff/tif_getimage.c.orig	Sat Aug 29 00:16:22 2015
+++ libtiff/tif_getimage.c	Sun Jan 24 17:04:12 2016
d79 1
a79 1
@@@@ -173,35 +173,37 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d94 1
a94 2
-			if( td->td_samplesperpixel != 3 )
+			if( td->td_samplesperpixel != 3 || colorchannels != 3 )
a96 2
-                        "Sorry, can not handle image with %s=%d",
-                        "Samples/pixel", td->td_samplesperpixel);
d98 2
a99 3
+                         "Sorry, can not handle image with %s=%d, %s=%d",
+                         "Samples/pixel", td->td_samplesperpixel,
+                         "colorchannels", colorchannels);
d101 1
a101 2
             }
 			break;
d103 1
a103 2
-            if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
+            if( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 )
a105 1
-                        "Sorry, can not handle image with %s=%d and %s=%d",
d107 1
a107 1
+                        "Sorry, can not handle image with %s=%d, %s=%d and %s=%d",
a108 1
+                        "colorchannels", colorchannels,
d110 1
a110 1
                 return 0;
d119 1
a119 11
@@@@ -255,6 +257,9 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 	int colorchannels;
 	uint16 *red_orig, *green_orig, *blue_orig;
 	int n_color;
+	
+	if( !TIFFRGBAImageOK(tif, emsg) )
+		return 0;
 
 	/* Initialize to normal values */
 	img->row_offset = 0;
@@@@ -275,7 +280,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d128 1
a128 1
@@@@ -325,7 +330,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d137 1
a137 1
@@@@ -333,7 +338,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d146 1
a146 1
@@@@ -343,7 +348,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d155 1
a155 1
@@@@ -357,7 +362,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d164 1
a164 1
@@@@ -394,7 +399,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d173 1
a173 1
@@@@ -404,12 +409,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d188 1
a188 1
@@@@ -417,7 +422,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d197 1
a197 1
@@@@ -427,12 +432,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d212 1
a212 1
@@@@ -443,7 +448,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d221 1
a221 1
@@@@ -461,12 +466,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
a235 58
@@@@ -2508,29 +2513,33 @@@@ PickContigCase(TIFFRGBAImage* img)
 		case PHOTOMETRIC_RGB:
 			switch (img->bitspersample) {
 				case 8:
-					if (img->alpha == EXTRASAMPLE_ASSOCALPHA)
+					if (img->alpha == EXTRASAMPLE_ASSOCALPHA &&
+						img->samplesperpixel >= 4)
 						img->put.contig = putRGBAAcontig8bittile;
-					else if (img->alpha == EXTRASAMPLE_UNASSALPHA)
+					else if (img->alpha == EXTRASAMPLE_UNASSALPHA &&
+							 img->samplesperpixel >= 4)
 					{
 						if (BuildMapUaToAa(img))
 							img->put.contig = putRGBUAcontig8bittile;
 					}
-					else
+					else if( img->samplesperpixel >= 3 )
 						img->put.contig = putRGBcontig8bittile;
 					break;
 				case 16:
-					if (img->alpha == EXTRASAMPLE_ASSOCALPHA)
+					if (img->alpha == EXTRASAMPLE_ASSOCALPHA &&
+						img->samplesperpixel >=4 )
 					{
 						if (BuildMapBitdepth16To8(img))
 							img->put.contig = putRGBAAcontig16bittile;
 					}
-					else if (img->alpha == EXTRASAMPLE_UNASSALPHA)
+					else if (img->alpha == EXTRASAMPLE_UNASSALPHA &&
+							 img->samplesperpixel >=4 )
 					{
 						if (BuildMapBitdepth16To8(img) &&
 						    BuildMapUaToAa(img))
 							img->put.contig = putRGBUAcontig16bittile;
 					}
-					else
+					else if( img->samplesperpixel >=3 )
 					{
 						if (BuildMapBitdepth16To8(img))
 							img->put.contig = putRGBcontig16bittile;
@@@@ -2539,7 +2548,7 @@@@ PickContigCase(TIFFRGBAImage* img)
 			}
 			break;
 		case PHOTOMETRIC_SEPARATED:
-			if (buildMap(img)) {
+			if (img->samplesperpixel >=4 && buildMap(img)) {
 				if (img->bitspersample == 8) {
 					if (!img->Map)
 						img->put.contig = putRGBcontig8bitCMYKtile;
@@@@ -2635,7 +2644,7 @@@@ PickContigCase(TIFFRGBAImage* img)
 			}
 			break;
 		case PHOTOMETRIC_CIELAB:
-			if (buildMap(img)) {
+			if (img->samplesperpixel == 3 && buildMap(img)) {
 				if (img->bitspersample == 8)
 					img->put.contig = initCIELabConversion(img);
 				break;
@


1.8
log
@Update tiff to 4.0.2, includes a fix for CVE-2012-2113,
LibTIFF "tiff2pdf" Integer Overflow Vulnerability
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.7 2012/04/14 15:09:55 naddy Exp $
a2 1
1. sprintf()
d7 2
a8 2
--- libtiff/tif_getimage.c.orig	Wed Apr 11 18:42:32 2012
+++ libtiff/tif_getimage.c	Wed Apr 11 18:53:00 2012
d79 1
a79 1
@@@@ -173,12 +173,12 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d94 8
a101 1
@@@@ -186,7 +186,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d103 9
d119 1
a119 1
@@@@ -260,7 +260,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d128 1
a128 1
@@@@ -310,7 +310,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d137 1
a137 1
@@@@ -318,7 +318,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d146 1
a146 1
@@@@ -328,7 +328,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d155 1
a155 1
@@@@ -342,7 +342,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d164 1
a164 1
@@@@ -379,7 +379,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d173 1
a173 1
@@@@ -389,12 +389,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d188 1
a188 1
@@@@ -402,7 +402,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d197 1
a197 1
@@@@ -412,12 +412,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d212 1
a212 1
@@@@ -428,7 +428,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d221 1
a221 1
@@@@ -446,12 +446,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
@


1.8.10.1
log
@Security update to 4.0.4beta (plus one further upstream fix).
Should fix CVE-2014-8127, CVE-2014-8128, CVE-2014-8129, CVE-2014-8130,
CVE-2014-9655, CVE-2015-1547.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.8.12.1 2015/03/29 19:41:56 naddy Exp $
d3 1
d8 2
a9 2
--- libtiff/tif_getimage.c.orig	Mon Dec 29 19:28:46 2014
+++ libtiff/tif_getimage.c	Sun Mar 29 17:09:38 2015
d80 1
a80 1
@@@@ -173,18 +173,18 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d95 1
a95 8
 			if( td->td_samplesperpixel != 3 )
             {
-                sprintf(emsg,
+                snprintf(emsg, 1024,
                         "Sorry, can not handle image with %s=%d",
                         "Samples/pixel", td->td_samplesperpixel);
                 return 0;
@@@@ -193,7 +193,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
a96 9
             if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
             {
-                sprintf(emsg,
+                snprintf(emsg, 1024,
                         "Sorry, can not handle image with %s=%d and %s=%d",
                         "Samples/pixel", td->td_samplesperpixel,
                         "Bits/sample", td->td_bitspersample);
@@@@ -201,7 +201,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
             }
d104 1
a104 1
@@@@ -275,7 +275,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d113 1
a113 1
@@@@ -325,7 +325,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d122 1
a122 1
@@@@ -333,7 +333,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d131 1
a131 1
@@@@ -343,7 +343,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d140 1
a140 1
@@@@ -357,7 +357,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d149 1
a149 1
@@@@ -394,7 +394,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d158 1
a158 1
@@@@ -404,12 +404,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d173 1
a173 1
@@@@ -417,7 +417,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d182 1
a182 1
@@@@ -427,12 +427,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d197 1
a197 1
@@@@ -443,7 +443,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d206 1
a206 1
@@@@ -461,12 +461,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
@


1.8.12.1
log
@Security update to 4.0.4beta (plus one further upstream fix).
Should fix CVE-2014-8127, CVE-2014-8128, CVE-2014-8129, CVE-2014-8130,
CVE-2014-9655, CVE-2015-1547.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.9 2015/03/29 17:39:22 naddy Exp $
d3 1
d8 2
a9 2
--- libtiff/tif_getimage.c.orig	Mon Dec 29 19:28:46 2014
+++ libtiff/tif_getimage.c	Sun Mar 29 17:09:38 2015
d80 1
a80 1
@@@@ -173,18 +173,18 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d95 1
a95 8
 			if( td->td_samplesperpixel != 3 )
             {
-                sprintf(emsg,
+                snprintf(emsg, 1024,
                         "Sorry, can not handle image with %s=%d",
                         "Samples/pixel", td->td_samplesperpixel);
                 return 0;
@@@@ -193,7 +193,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
a96 9
             if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
             {
-                sprintf(emsg,
+                snprintf(emsg, 1024,
                         "Sorry, can not handle image with %s=%d and %s=%d",
                         "Samples/pixel", td->td_samplesperpixel,
                         "Bits/sample", td->td_bitspersample);
@@@@ -201,7 +201,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
             }
d104 1
a104 1
@@@@ -275,7 +275,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d113 1
a113 1
@@@@ -325,7 +325,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d122 1
a122 1
@@@@ -333,7 +333,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d131 1
a131 1
@@@@ -343,7 +343,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d140 1
a140 1
@@@@ -357,7 +357,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d149 1
a149 1
@@@@ -394,7 +394,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d158 1
a158 1
@@@@ -404,12 +404,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d173 1
a173 1
@@@@ -417,7 +417,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d182 1
a182 1
@@@@ -427,12 +427,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d197 1
a197 1
@@@@ -443,7 +443,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d206 1
a206 1
@@@@ -461,12 +461,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
@


1.7
log
@Major update to 4.0.1, which adds BigTIFF support and includes some API
changes.  Also include upstream fix for CVE-2012-1173.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.6 2012/04/09 17:35:38 naddy Exp $
a7 2
2. CVE-2012-1173: integer overflow.

a220 55
@@@@ -692,6 +692,7 @@@@ gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uin
 	unsigned char* p2;
 	unsigned char* pa;
 	tmsize_t tilesize;
+	tmsize_t bufsize;
 	int32 fromskew, toskew;
 	int alpha = img->alpha;
 	uint32 nrow;
@@@@ -699,12 +700,18 @@@@ gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uin
         int colorchannels;
 
 	tilesize = TIFFTileSize(tif);  
-	buf = (unsigned char*) _TIFFmalloc((alpha?4:3)*tilesize);
+	
+	bufsize = TIFFSafeMultiply(tmsize_t,alpha?4:3,tilesize);
+	if (bufsize == 0) {
+		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "Integer overflow in %s", "gtTileSeparate");
+		return (0);
+	}
+	buf = (unsigned char*) _TIFFmalloc(bufsize);
 	if (buf == 0) {
 		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "%s", "No space for tile buffer");
 		return (0);
 	}
-	_TIFFmemset(buf, 0, (alpha?4:3)*tilesize);
+	_TIFFmemset(buf, 0, bufsize);
 	p0 = buf;
 	p1 = p0 + tilesize;
 	p2 = p1 + tilesize;
@@@@ -917,17 +924,23 @@@@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, ui
 	uint32 rowsperstrip, offset_row;
 	uint32 imagewidth = img->width;
 	tmsize_t stripsize;
+	tmsize_t bufsize;
 	int32 fromskew, toskew;
 	int alpha = img->alpha;
 	int ret = 1, flip, colorchannels;
 
 	stripsize = TIFFStripSize(tif);  
-	p0 = buf = (unsigned char *)_TIFFmalloc((alpha?4:3)*stripsize);
+	bufsize = TIFFSafeMultiply(tmsize_t,alpha?4:3,stripsize);
+	if (bufsize == 0) {
+		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "Integer overflow in %s", "gtStripSeparate");
+		return (0);
+	}
+	p0 = buf = (unsigned char *)_TIFFmalloc(bufsize);
 	if (buf == 0) {
 		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for tile buffer");
 		return (0);
 	}
-	_TIFFmemset(buf, 0, (alpha?4:3)*stripsize);
+	_TIFFmemset(buf, 0, bufsize);
 	p1 = p0 + stripsize;
 	p2 = p1 + stripsize;
 	pa = (alpha?(p2+stripsize):NULL);
@


1.6
log
@SECURITY fix for CVE-2012-1173 (integer overflow).
From upstream, via Sebastien Marie.
http://bugzilla.maptools.org/show_bug.cgi?id=2369
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.5 2010/06/30 17:10:08 naddy Exp $
d10 3
a12 3
--- libtiff/tif_getimage.c.orig	Thu Jul  8 18:17:59 2010
+++ libtiff/tif_getimage.c	Mon Apr  9 19:26:57 2012
@@@@ -76,7 +76,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d21 1
a21 1
@@@@ -87,7 +87,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d30 1
a30 1
@@@@ -101,7 +101,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d39 1
a39 1
@@@@ -112,7 +112,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d48 1
a48 1
@@@@ -136,7 +136,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d57 1
a57 1
@@@@ -146,13 +146,13 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d73 1
a73 1
@@@@ -161,7 +161,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d82 1
a82 1
@@@@ -169,12 +169,12 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d97 1
a97 1
@@@@ -182,7 +182,7 @@@@ TIFFRGBAImageOK(TIFF* tif, char emsg[1024])
d106 1
a106 1
@@@@ -250,7 +250,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d113 1
a113 1
 			return (0);
d115 1
a115 1
@@@@ -300,7 +300,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d121 1
a121 1
 				return (0);
d124 1
a124 1
@@@@ -308,7 +308,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d130 1
a130 1
 				return (0);
d133 1
a133 1
@@@@ -318,7 +318,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d139 1
a139 1
 				return (0);
d142 1
a142 1
@@@@ -332,7 +332,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d151 1
a151 1
@@@@ -369,7 +369,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d158 1
a158 1
 				return (0);
d160 1
a160 1
@@@@ -379,12 +379,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d167 1
a167 1
 					return (0);
d173 1
a173 1
 					return (0);
d175 1
a175 1
@@@@ -392,7 +392,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d182 1
a182 1
 				return (0);
d184 1
a184 1
@@@@ -402,12 +402,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d191 1
a191 1
 				return (0);
d199 1
a199 1
@@@@ -418,7 +418,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
d206 1
a206 1
 			return (0);
d208 2
a209 2
@@@@ -434,12 +434,12 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int 
 	    !(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);
d214 1
a214 1
 			return 0;
d220 1
a220 1
 			return 0;
d223 1
a223 1
@@@@ -673,18 +673,24 @@@@ gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uin
d226 2
a227 2
 	tsize_t tilesize;
+	tsize_t bufsize;
d231 2
a232 1
 	int ret = 1, flip;
d234 1
a234 1
 	tilesize = TIFFTileSize(tif);
d236 2
a237 1
+	bufsize = TIFFSafeMultiply(tsize_t,alpha?4:3,tilesize);
d244 1
a244 1
 		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for tile buffer");
d252 1
a252 1
@@@@ -880,17 +886,23 @@@@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, ui
d255 2
a256 2
 	tsize_t stripsize;
+	tsize_t bufsize;
d259 1
a259 1
 	int ret = 1, flip;
d261 1
a261 1
 	stripsize = TIFFStripSize(tif);
d263 1
a263 1
+	bufsize = TIFFSafeMultiply(tsize_t,alpha?4:3,stripsize);
@


1.5
log
@SECURITY:
Update to 3.9.4, which includes fixes for CVE-2009-2347 and CVE-2010-1411.
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
d8 4
a11 2
--- libtiff/tif_getimage.c.orig	Sun Jun 27 00:40:39 2010
+++ libtiff/tif_getimage.c	Sun Jun 27 00:57:24 2010
d223 53
@


1.5.8.1
log
@Security fix for CVE-2012-1173
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.5 2010/06/30 17:10:08 naddy Exp $
a2 1
1. sprintf()
a6 2
2. CVE-2012-1173: integer overflow.

a219 53
@@@@ -673,18 +673,24 @@@@ gtTileSeparate(TIFFRGBAImage* img, uint32* raster, uin
 	unsigned char* p2;
 	unsigned char* pa;
 	tsize_t tilesize;
+	tsize_t bufsize;
 	int32 fromskew, toskew;
 	int alpha = img->alpha;
 	uint32 nrow;
 	int ret = 1, flip;
 
 	tilesize = TIFFTileSize(tif);
-	buf = (unsigned char*) _TIFFmalloc((alpha?4:3)*tilesize);
+	bufsize = TIFFSafeMultiply(tsize_t,alpha?4:3,tilesize);
+	if (bufsize == 0) {
+		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "Integer overflow in %s", "gtTileSeparate");
+		return (0);
+	}
+	buf = (unsigned char*) _TIFFmalloc(bufsize);
 	if (buf == 0) {
 		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for tile buffer");
 		return (0);
 	}
-	_TIFFmemset(buf, 0, (alpha?4:3)*tilesize);
+	_TIFFmemset(buf, 0, bufsize);
 	p0 = buf;
 	p1 = p0 + tilesize;
 	p2 = p1 + tilesize;
@@@@ -880,17 +886,23 @@@@ gtStripSeparate(TIFFRGBAImage* img, uint32* raster, ui
 	uint32 rowsperstrip, offset_row;
 	uint32 imagewidth = img->width;
 	tsize_t stripsize;
+	tsize_t bufsize;
 	int32 fromskew, toskew;
 	int alpha = img->alpha;
 	int ret = 1, flip;
 
 	stripsize = TIFFStripSize(tif);
-	p0 = buf = (unsigned char *)_TIFFmalloc((alpha?4:3)*stripsize);
+	bufsize = TIFFSafeMultiply(tsize_t,alpha?4:3,stripsize);
+	if (bufsize == 0) {
+		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "Integer overflow in %s", "gtStripSeparate");
+		return (0);
+	}
+	p0 = buf = (unsigned char *)_TIFFmalloc(bufsize);
 	if (buf == 0) {
 		TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), "No space for tile buffer");
 		return (0);
 	}
-	_TIFFmemset(buf, 0, (alpha?4:3)*stripsize);
+	_TIFFmemset(buf, 0, bufsize);
 	p1 = p0 + stripsize;
 	p2 = p1 + stripsize;
 	pa = (alpha?(p2+stripsize):NULL);
@


1.4
log
@update to 3.7.2 which integrates the numerous security patches
brad@@ drops maintainership
@
text
@d1 10
a10 24
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.3 2005/03/27 06:13:07 brad Exp $
--- libtiff/tif_getimage.c.orig	Mon Dec 22 03:22:15 2003
+++ libtiff/tif_getimage.c	Sun Mar 27 00:30:27 2005
@@@@ -248,11 +248,11 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, T
     TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);
     TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,
 	&extrasamples, &sampleinfo);
-    if (extrasamples == 1)
+    if (extrasamples >= 1)
     {
 	switch (sampleinfo[0]) {
 	case EXTRASAMPLE_UNSPECIFIED:	/* Workaround for some images without */
-		if (img->samplesperpixel == 4)	/* correct info about alpha channel */
+		if (img->samplesperpixel > 3)	/* correct info about alpha channel */
 			img->alpha = EXTRASAMPLE_ASSOCALPHA;
 		break;
 	case EXTRASAMPLE_ASSOCALPHA:	/* data is pre-multiplied */
@@@@ -565,6 +565,7 @@@@ gtTileContig(TIFFRGBAImage* img, uint32*
 	TIFFError(TIFFFileName(tif), "No space for tile buffer");
 	return (0);
     }
+    _TIFFmemset(buf, 0, TIFFTileSize(tif));
     TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);
     TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);
d12 117
a128 24
@@@@ -664,6 +665,7 @@@@ gtTileSeparate(TIFFRGBAImage* img, uint3
 	TIFFError(TIFFFileName(tif), "No space for tile buffer");
 	return (0);
     }
+    _TIFFmemset(buf, 0, 4*tilesize);
     r = buf;
     g = r + tilesize;
     b = g + tilesize;
@@@@ -727,9 +729,7 @@@@ gtTileSeparate(TIFFRGBAImage* img, uint3
                 (*put)(img, raster+y*w+col, col, y,
                        npix, nrow, fromskew, toskew + fromskew, 
                        r + pos, g + pos, b + pos, a + pos);
-            } 
-            else 
-            {
+            } else {
                 (*put)(img, raster+y*w+col, col, y,
                        tw, nrow, 0, toskew, r + pos, g + pos, b + pos, a + pos);
             }
@@@@ -783,13 +783,13 @@@@ gtStripContig(TIFFRGBAImage* img, uint32
 	TIFFError(TIFFFileName(tif), "No space for strip buffer");
 	return (0);
     }
+    _TIFFmemset(buf, 0, TIFFStripSize(tif));
d130 90
a219 18
     flip = setorientation(img);
     if (flip & FLIP_VERTICALLY) {
 	    y = h - 1;
 	    toskew = -(int32)(w + w);
-    }
-    else {
+    } else {
 	    y = 0;
 	    toskew = -(int32)(w - w);
     }
@@@@ -865,6 +865,7 @@@@ gtStripSeparate(TIFFRGBAImage* img, uint
 	TIFFError(TIFFFileName(tif), "No space for tile buffer");
 	return (0);
     }
+    _TIFFmemset(buf, 0, 4*stripsize);
     g = r + stripsize;
     b = g + stripsize;
     a = b + stripsize;
@


1.3
log
@missed part of the alpha channels fix.
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.2 2005/03/27 03:40:00 brad Exp $
@


1.3.4.1
log
@cumulative update with patches of recent months

MFC:
fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
---
fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
---
fix MASTER_SITES; From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.3 2005/03/27 06:13:07 brad Exp $
@


1.3.2.1
log
@cumulative update with patches of recent months

MFC:
fix an issue with not being able to open some valid TIFF files.

http://www.sigmasoft.com/~openbsd/archive/openbsd-ports/200503/msg00090.html

From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Integer overflow in tif_dirread.c and tif_fax3.c for libtiff allows remote
attackers to execute arbitrary code via a TIFF file containing a TIFF_ASCII
or TIFF_UNDEFINED directory entry with a -1 entry count, which leads to a
heap-based buffer overflow.

CAN-2004-1308
---
fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
---
fix MASTER_SITES; From: Bernd Ahlers <b dot ahlers at ba-net dot org>
---
Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.3 2005/03/27 06:13:07 brad Exp $
@


1.2
log
@fix an issue with alpha channels.

http://bugzilla.remotesensing.org/show_bug.cgi?id=718
@
text
@d1 1
a1 1
$OpenBSD: patch-libtiff_tif_getimage_c,v 1.1 2004/10/20 20:37:48 brad Exp $
d3 2
a4 2
+++ libtiff/tif_getimage.c	Sat Mar 26 22:35:37 2005
@@@@ -248,7 +248,7 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, T
d13 5
@


1.1
log
@Fix memory allocation problems and numerous integer overflows.

CAN-2004-0803, CAN-2004-0804, CAN-2004-0886
@
text
@d1 1
a1 1
$OpenBSD$
d3 10
a12 1
+++ libtiff/tif_getimage.c	Wed Oct 20 14:38:11 2004
@


1.1.2.1
log
@SECURITY:
fix multiple vulnerabilities; bump PKGNAME
http://www.vuxml.org/openbsd/d045aeb6-9ea6-11d9-9623-00065bd5b0b6.html

ok brad@@
@
text
@d3 1
a3 15
+++ libtiff/tif_getimage.c	Sun Mar 27 00:30:27 2005
@@@@ -248,11 +248,11 @@@@ TIFFRGBAImageBegin(TIFFRGBAImage* img, T
     TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);
     TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,
 	&extrasamples, &sampleinfo);
-    if (extrasamples == 1)
+    if (extrasamples >= 1)
     {
 	switch (sampleinfo[0]) {
 	case EXTRASAMPLE_UNSPECIFIED:	/* Workaround for some images without */
-		if (img->samplesperpixel == 4)	/* correct info about alpha channel */
+		if (img->samplesperpixel > 3)	/* correct info about alpha channel */
 			img->alpha = EXTRASAMPLE_ASSOCALPHA;
 		break;
 	case EXTRASAMPLE_ASSOCALPHA:	/* data is pre-multiplied */
@


