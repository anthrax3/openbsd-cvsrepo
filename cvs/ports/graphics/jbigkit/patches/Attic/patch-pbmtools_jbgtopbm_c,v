head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.0.12
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.10
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.4
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.2
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2014.04.08.13.59.32;	author sthen;	state dead;
branches;
next	1.2;

1.2
date	2013.04.13.08.53.10;	author ajacoutot;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2010.06.29.22.40.45;	author naddy;	state Exp;
branches;
next	;

1.2.4.1
date	2014.05.20.08.56.38;	author jasper;	state dead;
branches;
next	;


desc
@@


1.3
log
@SECURITY update to jbigkit 2.1 (no ABI change)

  - fixed a buffer-overflow vulnerability in the jbig.c decoder,
    reported by Florian Weimer (Red Hat): CVE-2013-6369

  - fixed ability of corrupted input data to force jbig85.c decoder
    into an end-less loop

  - fixed a bug in the processing of private deterministic-prediction
    tables (DPPRIV=1) in jbig.c decoder

  - fixed integer-type mismatches in printf arguments on 64-bit systems

  - fuzz-testing script added
@
text
@$OpenBSD: patch-pbmtools_jbgtopbm_c,v 1.2 2013/04/13 08:53:10 ajacoutot Exp $
--- pbmtools/jbgtopbm.c.orig	Wed Aug 27 22:37:45 2008
+++ pbmtools/jbgtopbm.c	Fri Apr 12 15:05:35 2013
@@@@ -110,7 +110,7 @@@@ void fprint_bytes(FILE *f, unsigned char *p, size_t le
   for (i = 0; i < len && i < max; i++)
     fprintf(f, "%02x ", p[i]);
   if (len > i)
-    fprintf(f, "... %d bytes total", len);
+    fprintf(f, "... %zd bytes total", len);
   fprintf(f, "\n");
 }
 
@@@@ -134,7 +134,7 @@@@ void diagnose_bie(FILE *fin)
   /* read BIH */
   read_file(&bie, &buflen, &len, fin);
   if (len < 20) {
-    fprintf(f, "Error: Input file is %d < 20 bytes long and therefore "
+    fprintf(f, "Error: Input file is %zd < 20 bytes long and therefore "
 	    "does not contain an intact BIE header!\n", len);
     return;
   }
@@@@ -188,18 +188,18 @@@@ void diagnose_bie(FILE *fin)
       == (JBG_DPON | JBG_DPPRIV))
     p += 1728;  /* skip DPTABLE */
   if (p > bie + len) {
-    fprintf(f, "Error: Input file is %d < 20+1728 bytes long and therefore "
+    fprintf(f, "Error: Input file is %zd < 20+1728 bytes long and therefore "
 	    "does not contain an intact BIE header with DPTABLE!\n", len);
     return;
   }
   while (p != bie + len) {
     if (p > bie + len - 2) {
-      fprintf(f, "%06x: Error: single byte 0x%02x left\n", p - bie, *p);
+      fprintf(f, "%06tx: Error: single byte 0x%02x left\n", p - bie, *p);
       return;
     }
     pnext = jbg_next_pscdms(p, len - (p - bie));
     if (p[0] != MARKER_ESC || p[1] == MARKER_STUFF) {
-      fprintf(f, "%06x: PSCD: ", p - bie);
+      fprintf(f, "%06tx: PSCD: ", p - bie);
       fprint_bytes(f, p, pnext ? (size_t) (pnext - p) : len - (p - bie), 60);
       if (!pnext) {
 	fprintf(f, "Error: PSCD not terminated by SDNORM or SDRST marker\n");
@@@@ -209,7 +209,7 @@@@ void diagnose_bie(FILE *fin)
       switch (p[1]) {
       case MARKER_SDNORM:
       case MARKER_SDRST:
-	fprintf(f, "%06x: ESC %s, ending SDE #%lu", p - bie,
+	fprintf(f, "%06tx: ESC %s, ending SDE #%lu", p - bie,
 		(p[1] == MARKER_SDNORM) ? "SDNORM" : "SDRST", ++sde);
 	if (sde == sdes)
 	  fprintf(f, " (final SDE)");
@@@@ -219,10 +219,10 @@@@ void diagnose_bie(FILE *fin)
 	fprintf(f, "\n");
 	break;
       case MARKER_ABORT:
-	fprintf(f, "%06x: ESC ABORT\n", p - bie);
+	fprintf(f, "%06tx: ESC ABORT\n", p - bie);
 	break;
       case MARKER_NEWLEN:
-	fprintf(f, "%06x: ESC NEWLEN ", p - bie);
+	fprintf(f, "%06tx: ESC NEWLEN ", p - bie);
 	if (p + 5 < bie + len) {
 	  fprintf(f, "YD = %lu\n",
 		  yd = (((long) p[2] << 24) | ((long) p[3] << 16) |
@@@@ -242,7 +242,7 @@@@ void diagnose_bie(FILE *fin)
 	  fprintf(f, "unexpected EOF\n");
 	break;
       case MARKER_ATMOVE:
-	fprintf(f, "%06x: ESC ATMOVE ", p - bie);
+	fprintf(f, "%06tx: ESC ATMOVE ", p - bie);
 	if (p + 7 < bie + len)
 	  fprintf(f, "YAT = %lu, tX = %d, tY = %d\n",
 		  (((long) p[2] << 24) | ((long) p[3] << 16) |
@@@@ -251,7 +251,7 @@@@ void diagnose_bie(FILE *fin)
 	  fprintf(f, "unexpected EOF\n");
 	break;
       case MARKER_COMMENT:
-	fprintf(f, "%06x: ESC COMMENT ", p - bie);
+	fprintf(f, "%06tx: ESC COMMENT ", p - bie);
 	if (p + 5 < bie + len)
 	  fprintf(f, "LC = %lu\n",
 		  (((long) p[2] << 24) | ((long) p[3] << 16) |
@@@@ -260,7 +260,7 @@@@ void diagnose_bie(FILE *fin)
 	  fprintf(f, "unexpected EOF\n");
 	break;
       default:
-	fprintf(f, "%06x: ESC 0x%02x\n", p - bie, p[1]);
+	fprintf(f, "%06tx: ESC 0x%02x\n", p - bie, p[1]);
       }
     if (!pnext) {
       fprintf(f, "Error encountered!\n");
@@@@ -372,7 +372,7 @@@@ int main (int argc, char **argv)
   /* read BIH first to check VLENGTH */
   len = fread(buffer, 1, 20, fin);
   if (len < 20) {
-    fprintf(stderr, "Input file '%s' (%d bytes) must be at least "
+    fprintf(stderr, "Input file '%s' (%zd bytes) must be at least "
 	    "20 bytes long\n", fnin, len);
     if (fout != stdout) {
       fclose(fout);
@


1.2
log
@Update to jbigkit-2.0.
This adds the lightweitgh version of the jbig library: jbig85 which is
needed by a WIP update of graphics/splix.

from Martin Crossley with some tweaks
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2.4.1
log
@SECURITY update to jbigkit 2.1 (no ABI change)

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-pbmtools_jbgtopbm_c,v 1.2 2013/04/13 08:53:10 ajacoutot Exp $
@


1.1
log
@LP64 fixes for format strings
@
text
@d2 12
a13 3
--- pbmtools/jbgtopbm.c.orig	Fri Jun 11 08:17:57 2004
+++ pbmtools/jbgtopbm.c	Tue Jun 29 16:28:35 2010
@@@@ -112,7 +112,7 @@@@ void diagnose_bie(FILE *f)
d15 1
a15 1
   read_file(&bie, &buflen, &len, f);
d17 2
a18 2
-    fprintf(d, "Error: Input file is %d < 20 bytes long and therefore "
+    fprintf(d, "Error: Input file is %zd < 20 bytes long and therefore "
d22 1
a22 1
@@@@ -158,30 +158,30 @@@@ void diagnose_bie(FILE *f)
d26 2
a27 2
-    fprintf(d, "Error: Input file is %d < 20+1728 bytes long and therefore "
+    fprintf(d, "Error: Input file is %zd < 20+1728 bytes long and therefore "
d33 2
a34 2
-      fprintf(d, "%06x: Error: single byte 0x%02x left\n", p - bie, *p);
+      fprintf(d, "%06tx: Error: single byte 0x%02x left\n", p - bie, *p);
d37 1
d39 6
a44 3
-      fprintf(d, "%06x: PSCD\n", p - bie);
+      fprintf(d, "%06tx: PSCD\n", p - bie);
     } else
a46 3
-	fprintf(d, "%06x: ESC SDNORM #%d\n", p - bie, sde++);
+	fprintf(d, "%06tx: ESC SDNORM #%d\n", p - bie, sde++);
 	break;
d48 7
a54 2
-	fprintf(d, "%06x: ESC SDRST #%d\n", p - bie, sde++);
+	fprintf(d, "%06tx: ESC SDRST #%d\n", p - bie, sde++);
d57 2
a58 2
-	fprintf(d, "%06x: ESC ABORT\n", p - bie);
+	fprintf(d, "%06tx: ESC ABORT\n", p - bie);
d61 7
a67 7
-	fprintf(d, "%06x: ESC NEWLEN ", p - bie);
+	fprintf(d, "%06tx: ESC NEWLEN ", p - bie);
 	if (p + 5 < bie + len)
 	  fprintf(d, "YD = %lu\n",
 		  (((long) p[2] << 24) | ((long) p[3] << 16) |
@@@@ -190,7 +190,7 @@@@ void diagnose_bie(FILE *f)
 	  fprintf(d, "unexpected EOF\n");
d70 2
a71 2
-	fprintf(d, "%06x: ESC ATMOVE ", p - bie);
+	fprintf(d, "%06tx: ESC ATMOVE ", p - bie);
d73 1
a73 1
 	  fprintf(d, "YAT = %lu, tX = %d, tY = %d\n",
d75 2
a76 2
@@@@ -199,7 +199,7 @@@@ void diagnose_bie(FILE *f)
 	  fprintf(d, "unexpected EOF\n");
d79 2
a80 2
-	fprintf(d, "%06x: ESC COMMENT ", p - bie);
+	fprintf(d, "%06tx: ESC COMMENT ", p - bie);
d82 1
a82 1
 	  fprintf(d, "LC = %lu\n",
d84 2
a85 2
@@@@ -208,7 +208,7 @@@@ void diagnose_bie(FILE *f)
 	  fprintf(d, "unexpected EOF\n");
d88 2
a89 2
-	fprintf(d, "%06x: ESC 0x%02x\n", p - bie, p[1]);
+	fprintf(d, "%06tx: ESC 0x%02x\n", p - bie, p[1]);
d91 3
a93 3
     p = jbg_next_pscdms(p, len - (p - bie));
     if (!p) {
@@@@ -319,7 +319,7 @@@@ int main (int argc, char **argv)
@

