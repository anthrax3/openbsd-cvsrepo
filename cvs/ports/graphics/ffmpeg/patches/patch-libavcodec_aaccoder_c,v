head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10;
locks; strict;
comment	@# @;


1.12
date	2016.10.17.07.51.00;	author ajacoutot;	state Exp;
branches;
next	1.11;
commitid	Wo4uP395zjJX9ZOv;

1.11
date	2016.09.06.12.37.11;	author ajacoutot;	state Exp;
branches;
next	1.10;
commitid	z3rQhI117DvrHlZm;

1.10
date	2016.01.22.07.05.01;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	QxWiiXgyevTr4Srf;

1.9
date	2016.01.18.15.34.45;	author ajacoutot;	state Exp;
branches;
next	1.8;
commitid	RwM3NoHU9JMWKEgE;

1.8
date	2016.01.14.06.09.43;	author ajacoutot;	state Exp;
branches;
next	1.7;
commitid	1MTT7RUn5DsgY3tS;

1.7
date	2015.12.10.06.53.38;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	syJXIQ2pJKvIoUp8;

1.6
date	2015.12.06.08.51.46;	author ajacoutot;	state Exp;
branches;
next	1.5;
commitid	qmMp5nlfDfTw8ZGw;

1.5
date	2015.10.17.06.49.22;	author ajacoutot;	state Exp;
branches;
next	1.4;
commitid	qCaTAupMCq4yvb8q;

1.4
date	2015.10.13.05.44.18;	author ajacoutot;	state Exp;
branches;
next	1.3;
commitid	qst9LZIZleMKOm5n;

1.3
date	2015.09.27.06.35.33;	author ajacoutot;	state Exp;
branches;
next	1.2;
commitid	37JetHBZHzvjG329;

1.2
date	2015.09.23.09.16.45;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	t74suKYQj33NdaVz;

1.1
date	2015.09.12.09.44.54;	author ajacoutot;	state Exp;
branches;
next	;
commitid	2zCvmn8WdgiiJ5l4;


desc
@@


1.12
log
@Some more AAC fixes.

from Brad (maintainer)
@
text
@$OpenBSD: patch-libavcodec_aaccoder_c,v 1.11 2016/09/06 12:37:11 ajacoutot Exp $

aaccoder: use roundf() instead of ceilf()

aaccoder: rewrite PNS implementation

aaccoder: add frequency scaling and quantization correction for PNS

aaccoder: tweak PNS implementation further

aaccoder: respect cutoff when marking bands as PNS

AAC encoder: refactor to resynchronize MIPS port

AAC encoder: tweak PNS usage to be more aggressive

AAC encoder: fix OOB access in search_for_pns

AAC encoder: Extensive improvements

aacenc: shorten name of ff_aac_adjust_common_prediction

aacenc: add support for encoding files using Long Term Prediction

AAC encoder: Fix application of M/S with PNS

avcodec/aac_tablegen: get rid of hardcoded tables entirely

AAC encoder: improve SF range utilization

AAC encoder: ANMR, avoid empty search ranges

AAC encoder: fix OOB access in search_for_pns

aacenc: switch to using the RNG from libavutil

AAC encoder: fix possible assertion failure in PNS

AAC encoder: avoid assertion failure on PNS

AAC encoder: various fixes in M/S coding

AAC encoder: enforce SF delta in PNS and IS SFs

aacenc: remove FAAC-like coder

aacenc: add a faster version of twoloop as the "fast" coder

aacenc: fix various typos and an error message

aacenc: use the decoder's lcg PRNG

--- libavcodec/aaccoder.c.orig	Sat Aug 27 22:51:19 2016
+++ libavcodec/aaccoder.c	Sat Oct 15 18:48:53 2016
@@@@ -33,7 +33,9 @@@@
 #include "libavutil/libm.h" // brought forward to work around cygwin header breakage
 
 #include <float.h>
+
 #include "libavutil/mathematics.h"
+#include "mathops.h"
 #include "avcodec.h"
 #include "put_bits.h"
 #include "aac.h"
@@@@ -42,24 +44,24 @@@@
 #include "aacenctab.h"
 #include "aacenc_utils.h"
 #include "aacenc_quantization.h"
-#include "aac_tablegen_decl.h"
 
 #include "aacenc_is.h"
 #include "aacenc_tns.h"
+#include "aacenc_ltp.h"
 #include "aacenc_pred.h"
 
-/** Frequency in Hz for lower limit of noise substitution **/
-#define NOISE_LOW_LIMIT 4500
+#include "libavcodec/aaccoder_twoloop.h"
 
-/* Energy spread threshold value below which no PNS is used, this corresponds to
- * typically around 17Khz, after which PNS usage decays ending at 19Khz */
-#define NOISE_SPREAD_THRESHOLD 0.5f
+/* Parameter of f(x) = a*(lambda/100), defines the maximum fourier spread
+ * beyond which no PNS is used (since the SFBs contain tone rather than noise) */
+#define NOISE_SPREAD_THRESHOLD 0.9f
 
-/* This constant gets divided by lambda to return ~1.65 which when multiplied
- * by the band->threshold and compared to band->energy is the boundary between
- * excessive PNS and little PNS usage. */
-#define NOISE_LAMBDA_NUMERATOR 252.1f
+/* Parameter of f(x) = a*(100/lambda), defines how much PNS is allowed to
+ * replace low energy non zero bands */
+#define NOISE_LAMBDA_REPLACE 1.948f
 
+#include "libavcodec/aaccoder_trellis.h"
+
 /**
  * structure used in optimal codebook search
  */
@@@@ -121,7 +123,7 @@@@ static void encode_window_bands_info(AACEncContext *s,
                     rd += quantize_band_cost(s, &sce->coeffs[start + w*128],
                                              &s->scoefs[start + w*128], size,
                                              sce->sf_idx[(win+w)*16+swb], aac_cb_out_map[cb],
-                                             lambda / band->threshold, INFINITY, NULL, 0);
+                                             lambda / band->threshold, INFINITY, NULL, NULL, 0);
                 }
                 cost_stay_here = path[swb][cb].cost + rd;
                 cost_get_here  = minrd              + rd + run_bits + 4;
@@@@ -182,138 +184,7 @@@@ static void encode_window_bands_info(AACEncContext *s,
     }
 }
 
-static void codebook_trellis_rate(AACEncContext *s, SingleChannelElement *sce,
-                                  int win, int group_len, const float lambda)
-{
-    BandCodingPath path[120][CB_TOT_ALL];
-    int w, swb, cb, start, size;
-    int i, j;
-    const int max_sfb  = sce->ics.max_sfb;
-    const int run_bits = sce->ics.num_windows == 1 ? 5 : 3;
-    const int run_esc  = (1 << run_bits) - 1;
-    int idx, ppos, count;
-    int stackrun[120], stackcb[120], stack_len;
-    float next_minbits = INFINITY;
-    int next_mincb = 0;
 
-    abs_pow34_v(s->scoefs, sce->coeffs, 1024);
-    start = win*128;
-    for (cb = 0; cb < CB_TOT_ALL; cb++) {
-        path[0][cb].cost     = run_bits+4;
-        path[0][cb].prev_idx = -1;
-        path[0][cb].run      = 0;
-    }
-    for (swb = 0; swb < max_sfb; swb++) {
-        size = sce->ics.swb_sizes[swb];
-        if (sce->zeroes[win*16 + swb]) {
-            float cost_stay_here = path[swb][0].cost;
-            float cost_get_here  = next_minbits + run_bits + 4;
-            if (   run_value_bits[sce->ics.num_windows == 8][path[swb][0].run]
-                != run_value_bits[sce->ics.num_windows == 8][path[swb][0].run+1])
-                cost_stay_here += run_bits;
-            if (cost_get_here < cost_stay_here) {
-                path[swb+1][0].prev_idx = next_mincb;
-                path[swb+1][0].cost     = cost_get_here;
-                path[swb+1][0].run      = 1;
-            } else {
-                path[swb+1][0].prev_idx = 0;
-                path[swb+1][0].cost     = cost_stay_here;
-                path[swb+1][0].run      = path[swb][0].run + 1;
-            }
-            next_minbits = path[swb+1][0].cost;
-            next_mincb = 0;
-            for (cb = 1; cb < CB_TOT_ALL; cb++) {
-                path[swb+1][cb].cost = 61450;
-                path[swb+1][cb].prev_idx = -1;
-                path[swb+1][cb].run = 0;
-            }
-        } else {
-            float minbits = next_minbits;
-            int mincb = next_mincb;
-            int startcb = sce->band_type[win*16+swb];
-            startcb = aac_cb_in_map[startcb];
-            next_minbits = INFINITY;
-            next_mincb = 0;
-            for (cb = 0; cb < startcb; cb++) {
-                path[swb+1][cb].cost = 61450;
-                path[swb+1][cb].prev_idx = -1;
-                path[swb+1][cb].run = 0;
-            }
-            for (cb = startcb; cb < CB_TOT_ALL; cb++) {
-                float cost_stay_here, cost_get_here;
-                float bits = 0.0f;
-                if (cb >= 12 && sce->band_type[win*16+swb] != aac_cb_out_map[cb]) {
-                    path[swb+1][cb].cost = 61450;
-                    path[swb+1][cb].prev_idx = -1;
-                    path[swb+1][cb].run = 0;
-                    continue;
-                }
-                for (w = 0; w < group_len; w++) {
-                    bits += quantize_band_cost(s, &sce->coeffs[start + w*128],
-                                               &s->scoefs[start + w*128], size,
-                                               sce->sf_idx[win*16+swb],
-                                               aac_cb_out_map[cb],
-                                               0, INFINITY, NULL, 0);
-                }
-                cost_stay_here = path[swb][cb].cost + bits;
-                cost_get_here  = minbits            + bits + run_bits + 4;
-                if (   run_value_bits[sce->ics.num_windows == 8][path[swb][cb].run]
-                    != run_value_bits[sce->ics.num_windows == 8][path[swb][cb].run+1])
-                    cost_stay_here += run_bits;
-                if (cost_get_here < cost_stay_here) {
-                    path[swb+1][cb].prev_idx = mincb;
-                    path[swb+1][cb].cost     = cost_get_here;
-                    path[swb+1][cb].run      = 1;
-                } else {
-                    path[swb+1][cb].prev_idx = cb;
-                    path[swb+1][cb].cost     = cost_stay_here;
-                    path[swb+1][cb].run      = path[swb][cb].run + 1;
-                }
-                if (path[swb+1][cb].cost < next_minbits) {
-                    next_minbits = path[swb+1][cb].cost;
-                    next_mincb = cb;
-                }
-            }
-        }
-        start += sce->ics.swb_sizes[swb];
-    }
-
-    //convert resulting path from backward-linked list
-    stack_len = 0;
-    idx       = 0;
-    for (cb = 1; cb < CB_TOT_ALL; cb++)
-        if (path[max_sfb][cb].cost < path[max_sfb][idx].cost)
-            idx = cb;
-    ppos = max_sfb;
-    while (ppos > 0) {
-        av_assert1(idx >= 0);
-        cb = idx;
-        stackrun[stack_len] = path[ppos][cb].run;
-        stackcb [stack_len] = cb;
-        idx = path[ppos-path[ppos][cb].run+1][cb].prev_idx;
-        ppos -= path[ppos][cb].run;
-        stack_len++;
-    }
-    //perform actual band info encoding
-    start = 0;
-    for (i = stack_len - 1; i >= 0; i--) {
-        cb = aac_cb_out_map[stackcb[i]];
-        put_bits(&s->pb, 4, cb);
-        count = stackrun[i];
-        memset(sce->zeroes + win*16 + start, !cb, count);
-        //XXX: memset when band_type is also uint8_t
-        for (j = 0; j < count; j++) {
-            sce->band_type[win*16 + start] = cb;
-            start++;
-        }
-        while (count >= run_esc) {
-            put_bits(&s->pb, run_bits, run_esc);
-            count -= run_esc;
-        }
-        put_bits(&s->pb, run_bits, count);
-    }
-}
-
 typedef struct TrellisPath {
     float cost;
     int prev;
@@@@ -324,23 +195,23 @@@@ typedef struct TrellisPath {
 
 static void set_special_band_scalefactors(AACEncContext *s, SingleChannelElement *sce)
 {
-    int w, g, start = 0;
-    int minscaler_n = sce->sf_idx[0], minscaler_i = sce->sf_idx[0];
+    int w, g;
+    int prevscaler_n = -255, prevscaler_i = 0;
     int bands = 0;
 
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        start = 0;
-        for (g = 0;  g < sce->ics.num_swb; g++) {
+        for (g = 0; g < sce->ics.num_swb; g++) {
+            if (sce->zeroes[w*16+g])
+                continue;
             if (sce->band_type[w*16+g] == INTENSITY_BT || sce->band_type[w*16+g] == INTENSITY_BT2) {
-                sce->sf_idx[w*16+g] = av_clip(ceilf(log2f(sce->is_ener[w*16+g])*2), -155, 100);
-                minscaler_i = FFMIN(minscaler_i, sce->sf_idx[w*16+g]);
+                sce->sf_idx[w*16+g] = av_clip(roundf(log2f(sce->is_ener[w*16+g])*2), -155, 100);
                 bands++;
             } else if (sce->band_type[w*16+g] == NOISE_BT) {
-                sce->sf_idx[w*16+g] = av_clip(4+log2f(sce->pns_ener[w*16+g])*2, -100, 155);
-                minscaler_n = FFMIN(minscaler_n, sce->sf_idx[w*16+g]);
+                sce->sf_idx[w*16+g] = av_clip(3+ceilf(log2f(sce->pns_ener[w*16+g])*2), -100, 155);
+                if (prevscaler_n == -255)
+                    prevscaler_n = sce->sf_idx[w*16+g];
                 bands++;
             }
-            start += sce->ics.swb_sizes[g];
         }
     }
 
@@@@ -349,11 +220,13 @@@@ static void set_special_band_scalefactors(AACEncContex
 
     /* Clip the scalefactor indices */
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        for (g = 0;  g < sce->ics.num_swb; g++) {
+        for (g = 0; g < sce->ics.num_swb; g++) {
+            if (sce->zeroes[w*16+g])
+                continue;
             if (sce->band_type[w*16+g] == INTENSITY_BT || sce->band_type[w*16+g] == INTENSITY_BT2) {
-                sce->sf_idx[w*16+g] = av_clip(sce->sf_idx[w*16+g], minscaler_i, minscaler_i + SCALE_MAX_DIFF);
+                sce->sf_idx[w*16+g] = prevscaler_i = av_clip(sce->sf_idx[w*16+g], prevscaler_i - SCALE_MAX_DIFF, prevscaler_i + SCALE_MAX_DIFF);
             } else if (sce->band_type[w*16+g] == NOISE_BT) {
-                sce->sf_idx[w*16+g] = av_clip(sce->sf_idx[w*16+g], minscaler_n, minscaler_n + SCALE_MAX_DIFF);
+                sce->sf_idx[w*16+g] = prevscaler_n = av_clip(sce->sf_idx[w*16+g], prevscaler_n - SCALE_MAX_DIFF, prevscaler_n + SCALE_MAX_DIFF);
             }
         }
     }
@@@@ -390,9 +263,9 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
     }
 
     //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped
-    q0 = coef2minsf(q0f);
+    q0 = av_clip(coef2minsf(q0f), 0, SCALE_MAX_POS-1);
     //maximum scalefactor index is when maximum coefficient after quantizing is still not zero
-    q1 = coef2maxsf(q1f);
+    q1 = av_clip(coef2maxsf(q1f), 1, SCALE_MAX_POS);
     if (q1 - q0 > 60) {
         int q0low  = q0;
         int q1high = q1;
@@@@ -408,6 +281,12 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
             q1  = q1high;
         }
     }
+    // q0 == q1 isn't really a legal situation
+    if (q0 == q1) {
+        // the following is indirect but guarantees q1 != q0 && q1 near q0
+        q1 = av_clip(q0+1, 1, SCALE_MAX_POS);
+        q0 = av_clip(q1-1, 0, SCALE_MAX_POS - 1);
+    }
 
     for (i = 0; i < TRELLIS_STATES; i++) {
         paths[0][i].cost    = 0.0f;
@@@@ -456,6 +335,10 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
                 maxscale = coef2maxsf(qmax);
                 minscale = av_clip(minscale - q0, 0, TRELLIS_STATES - 1);
                 maxscale = av_clip(maxscale - q0, 0, TRELLIS_STATES);
+                if (minscale == maxscale) {
+                    maxscale = av_clip(minscale+1, 1, TRELLIS_STATES);
+                    minscale = av_clip(maxscale-1, 0, TRELLIS_STATES - 1);
+                }
                 maxval = find_max_val(sce->ics.group_len[w], sce->ics.swb_sizes[g], s->scoefs+start);
                 for (q = minscale; q < maxscale; q++) {
                     float dist = 0;
@@@@ -463,7 +346,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
                     for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
                         FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
                         dist += quantize_band_cost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swb_sizes[g],
-                                                   q + q0, cb, lambda / band->threshold, INFINITY, NULL, 0);
+                                                   q + q0, cb, lambda / band->threshold, INFINITY, NULL, NULL, 0);
                     }
                     minrd = FFMIN(minrd, dist);
 
@@@@ -504,18 +387,14 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
     }
     //set the same quantizers inside window groups
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])
-        for (g = 0;  g < sce->ics.num_swb; g++)
+        for (g = 0; g < sce->ics.num_swb; g++)
             for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)
                 sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];
 }
 
-/**
- * two-loop quantizers search taken from ISO 13818-7 Appendix C
- */
-static void search_for_quantizers_twoloop(AVCodecContext *avctx,
-                                          AACEncContext *s,
-                                          SingleChannelElement *sce,
-                                          const float lambda)
+static void search_for_quantizers_fast(AVCodecContext *avctx, AACEncContext *s,
+                                       SingleChannelElement *sce,
+                                       const float lambda)
 {
     int start = 0, i, w, w2, g;
     int destbits = avctx->bit_rate * 1024.0 / avctx->sample_rate / avctx->channels * (lambda / 120.f);
@@@@ -529,15 +408,16 @@@@ static void search_for_quantizers_twoloop(AVCodecConte
     // for values above this the decoder might end up in an endless loop
     // due to always having more bits than what can be encoded.
     destbits = FFMIN(destbits, 5800);
-    //XXX: some heuristic to determine initial quantizers will reduce search time
+    //some heuristic to determine initial quantizers will reduce search time
     //determine zero bands and upper limits
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        for (g = 0;  g < sce->ics.num_swb; g++) {
+        start = 0;
+        for (g = 0; g < sce->ics.num_swb; g++) {
             int nz = 0;
             float uplim = 0.0f, energy = 0.0f;
             for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
                 FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
-                uplim  += band->threshold;
+                uplim += band->threshold;
                 energy += band->energy;
                 if (band->energy <= band->threshold || band->threshold == 0.0f) {
                     sce->zeroes[(w+w2)*16+g] = 1;
@@@@ -546,14 +426,16 @@@@ static void search_for_quantizers_twoloop(AVCodecConte
                 nz = 1;
             }
             uplims[w*16+g] = uplim *512;
+            sce->band_type[w*16+g] = 0;
             sce->zeroes[w*16+g] = !nz;
             if (nz)
                 minthr = FFMIN(minthr, uplim);
             allz |= nz;
+            start += sce->ics.swb_sizes[g];
         }
     }
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        for (g = 0;  g < sce->ics.num_swb; g++) {
+        for (g = 0; g < sce->ics.num_swb; g++) {
             if (sce->zeroes[w*16+g]) {
                 sce->sf_idx[w*16+g] = SCALE_ONE_POS;
                 continue;
@@@@ -565,10 +447,11 @@@@ static void search_for_quantizers_twoloop(AVCodecConte
     if (!allz)
         return;
     abs_pow34_v(s->scoefs, sce->coeffs, 1024);
+    ff_quantize_band_cost_cache_init(s);
 
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
         start = w*128;
-        for (g = 0;  g < sce->ics.num_swb; g++) {
+        for (g = 0; g < sce->ics.num_swb; g++) {
             const float *scaled = s->scoefs + start;
             maxvals[w*16+g] = find_max_val(sce->ics.group_len[w], sce->ics.swb_sizes[g], scaled);
             start += sce->ics.swb_sizes[g];
@@@@ -587,9 +470,9 @@@@ static void search_for_quantizers_twoloop(AVCodecConte
             tbits = 0;
             for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
                 start = w*128;
-                for (g = 0;  g < sce->ics.num_swb; g++) {
-                    const float *coefs = &sce->coeffs[start];
-                    const float *scaled = &s->scoefs[start];
+                for (g = 0; g < sce->ics.num_swb; g++) {
+                    const float *coefs = sce->coeffs + start;
+                    const float *scaled = s->scoefs + start;
                     int bits = 0;
                     int cb;
                     float dist = 0.0f;
@@@@ -602,15 +485,13 @@@@ static void search_for_quantizers_twoloop(AVCodecConte
                     cb = find_min_book(maxvals[w*16+g], sce->sf_idx[w*16+g]);
                     for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
                         int b;
-                        dist += quantize_band_cost(s, coefs + w2*128,
-                                                   scaled + w2*128,
-                                                   sce->ics.swb_sizes[g],
-                                                   sce->sf_idx[w*16+g],
-                                                   cb,
-                                                   1.0f,
-                                                   INFINITY,
-                                                   &b,
-                                                   0);
+                        dist += quantize_band_cost_cached(s, w + w2, g,
+                                                          coefs + w2*128,
+                                                          scaled + w2*128,
+                                                          sce->ics.swb_sizes[g],
+                                                          sce->sf_idx[w*16+g],
+                                                          cb, 1.0f, INFINITY,
+                                                          &b, NULL, 0);
                         bits += b;
                     }
                     dists[w*16+g] = dist - bits;
@@@@ -659,331 +540,378 @@@@ static void search_for_quantizers_twoloop(AVCodecConte
     } while (fflag && its < 10);
 }
 
-static void search_for_quantizers_faac(AVCodecContext *avctx, AACEncContext *s,
-                                       SingleChannelElement *sce,
-                                       const float lambda)
+static void search_for_pns(AACEncContext *s, AVCodecContext *avctx, SingleChannelElement *sce)
 {
-    int start = 0, i, w, w2, g;
-    float uplim[128], maxq[128];
-    int minq, maxsf;
-    float distfact = ((sce->ics.num_windows > 1) ? 85.80 : 147.84) / lambda;
-    int last = 0, lastband = 0, curband = 0;
-    float avg_energy = 0.0;
-    if (sce->ics.num_windows == 1) {
-        start = 0;
-        for (i = 0; i < 1024; i++) {
-            if (i - start >= sce->ics.swb_sizes[curband]) {
-                start += sce->ics.swb_sizes[curband];
-                curband++;
-            }
-            if (sce->coeffs[i]) {
-                avg_energy += sce->coeffs[i] * sce->coeffs[i];
-                last = i;
-                lastband = curband;
-            }
-        }
+    FFPsyBand *band;
+    int w, g, w2, i;
+    int wlen = 1024 / sce->ics.num_windows;
+    int bandwidth, cutoff;
+    float *PNS = &s->scoefs[0*128], *PNS34 = &s->scoefs[1*128];
+    float *NOR34 = &s->scoefs[3*128];
+    uint8_t nextband[128];
+    const float lambda = s->lambda;
+    const float freq_mult = avctx->sample_rate*0.5f/wlen;
+    const float thr_mult = NOISE_LAMBDA_REPLACE*(100.0f/lambda);
+    const float spread_threshold = FFMIN(0.75f, NOISE_SPREAD_THRESHOLD*FFMAX(0.5f, lambda/100.f));
+    const float dist_bias = av_clipf(4.f * 120 / lambda, 0.25f, 4.0f);
+    const float pns_transient_energy_r = FFMIN(0.7f, lambda / 140.f);
+
+    int refbits = avctx->bit_rate * 1024.0 / avctx->sample_rate
+        / ((avctx->flags & CODEC_FLAG_QSCALE) ? 2.0f : avctx->channels)
+        * (lambda / 120.f);
+
+    /** Keep this in sync with twoloop's cutoff selection */
+    float rate_bandwidth_multiplier = 1.5f;
+    int prev = -1000, prev_sf = -1;
+    int frame_bit_rate = (avctx->flags & CODEC_FLAG_QSCALE)
+        ? (refbits * rate_bandwidth_multiplier * avctx->sample_rate / 1024)
+        : (avctx->bit_rate / avctx->channels);
+
+    frame_bit_rate *= 1.15f;
+
+    if (avctx->cutoff > 0) {
+        bandwidth = avctx->cutoff;
     } else {
-        for (w = 0; w < 8; w++) {
-            const float *coeffs = &sce->coeffs[w*128];
-            curband = start = 0;
-            for (i = 0; i < 128; i++) {
-                if (i - start >= sce->ics.swb_sizes[curband]) {
-                    start += sce->ics.swb_sizes[curband];
-                    curband++;
-                }
-                if (coeffs[i]) {
-                    avg_energy += coeffs[i] * coeffs[i];
-                    last = FFMAX(last, i);
-                    lastband = FFMAX(lastband, curband);
-                }
-            }
-        }
+        bandwidth = FFMAX(3000, AAC_CUTOFF_FROM_BITRATE(frame_bit_rate, 1, avctx->sample_rate));
     }
-    last++;
-    avg_energy /= last;
-    if (avg_energy == 0.0f) {
-        for (i = 0; i < FF_ARRAY_ELEMS(sce->sf_idx); i++)
-            sce->sf_idx[i] = SCALE_ONE_POS;
-        return;
-    }
+
+    cutoff = bandwidth * 2 * wlen / avctx->sample_rate;
+
+    memcpy(sce->band_alt, sce->band_type, sizeof(sce->band_type));
+    ff_init_nextband_map(sce, nextband);
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        start = w*128;
+        int wstart = w*128;
         for (g = 0; g < sce->ics.num_swb; g++) {
-            float *coefs   = &sce->coeffs[start];
-            const int size = sce->ics.swb_sizes[g];
-            int start2 = start, end2 = start + size, peakpos = start;
-            float maxval = -1, thr = 0.0f, t;
-            maxq[w*16+g] = 0.0f;
-            if (g > lastband) {
-                maxq[w*16+g] = 0.0f;
-                start += size;
-                for (w2 = 0; w2 < sce->ics.group_len[w]; w2++)
-                    memset(coefs + w2*128, 0, sizeof(coefs[0])*size);
+            int noise_sfi;
+            float dist1 = 0.0f, dist2 = 0.0f, noise_amp;
+            float pns_energy = 0.0f, pns_tgt_energy, energy_ratio, dist_thresh;
+            float sfb_energy = 0.0f, threshold = 0.0f, spread = 2.0f;
+            float min_energy = -1.0f, max_energy = 0.0f;
+            const int start = wstart+sce->ics.swb_offset[g];
+            const float freq = (start-wstart)*freq_mult;
+            const float freq_boost = FFMAX(0.88f*freq/NOISE_LOW_LIMIT, 1.0f);
+            if (freq < NOISE_LOW_LIMIT || (start-wstart) >= cutoff) {
+                if (!sce->zeroes[w*16+g])
+                    prev_sf = sce->sf_idx[w*16+g];
                 continue;
             }
             for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
-                for (i = 0; i < size; i++) {
-                    float t = coefs[w2*128+i]*coefs[w2*128+i];
-                    maxq[w*16+g] = FFMAX(maxq[w*16+g], fabsf(coefs[w2*128 + i]));
-                    thr += t;
-                    if (sce->ics.num_windows == 1 && maxval < t) {
-                        maxval  = t;
-                        peakpos = start+i;
-                    }
+                band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
+                sfb_energy += band->energy;
+                spread     = FFMIN(spread, band->spread);
+                threshold  += band->threshold;
+                if (!w2) {
+                    min_energy = max_energy = band->energy;
+                } else {
+                    min_energy = FFMIN(min_energy, band->energy);
+                    max_energy = FFMAX(max_energy, band->energy);
                 }
             }
-            if (sce->ics.num_windows == 1) {
-                start2 = FFMAX(peakpos - 2, start2);
-                end2   = FFMIN(peakpos + 3, end2);
-            } else {
-                start2 -= start;
-                end2   -= start;
-            }
-            start += size;
-            thr = pow(thr / (avg_energy * (end2 - start2)), 0.3 + 0.1*(lastband - g) / lastband);
-            t   = 1.0 - (1.0 * start2 / last);
-            uplim[w*16+g] = distfact / (1.4 * thr + t*t*t + 0.075);
-        }
-    }
-    memset(sce->sf_idx, 0, sizeof(sce->sf_idx));
-    abs_pow34_v(s->scoefs, sce->coeffs, 1024);
-    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        start = w*128;
-        for (g = 0;  g < sce->ics.num_swb; g++) {
-            const float *coefs  = &sce->coeffs[start];
-            const float *scaled = &s->scoefs[start];
-            const int size      = sce->ics.swb_sizes[g];
-            int scf, prev_scf, step;
-            int min_scf = -1, max_scf = 256;
-            float curdiff;
-            if (maxq[w*16+g] < 21.544) {
-                sce->zeroes[w*16+g] = 1;
-                start += size;
+
+            /* Ramps down at ~8000Hz and loosens the dist threshold */
+            dist_thresh = av_clipf(2.5f*NOISE_LOW_LIMIT/freq, 0.5f, 2.5f) * dist_bias;
+
+            /* PNS is acceptable when all of these are true:
+             * 1. high spread energy (noise-like band)
+             * 2. near-threshold energy (high PE means the random nature of PNS content will be noticed)
+             * 3. on short window groups, all windows have similar energy (variations in energy would be destroyed by PNS)
+             *
+             * At this stage, point 2 is relaxed for zeroed bands near the noise threshold (hole avoidance is more important)
+             */
+            if ((!sce->zeroes[w*16+g] && !ff_sfdelta_can_remove_band(sce, nextband, prev_sf, w*16+g)) ||
+                ((sce->zeroes[w*16+g] || !sce->band_alt[w*16+g]) && sfb_energy < threshold*sqrtf(1.0f/freq_boost)) || spread < spread_threshold ||
+                (!sce->zeroes[w*16+g] && sce->band_alt[w*16+g] && sfb_energy > threshold*thr_mult*freq_boost) ||
+                min_energy < pns_transient_energy_r * max_energy ) {
+                sce->pns_ener[w*16+g] = sfb_energy;
+                if (!sce->zeroes[w*16+g])
+                    prev_sf = sce->sf_idx[w*16+g];
                 continue;
             }
-            sce->zeroes[w*16+g] = 0;
-            scf  = prev_scf = av_clip(SCALE_ONE_POS - SCALE_DIV_512 - log2f(1/maxq[w*16+g])*16/3, 60, 218);
-            for (;;) {
-                float dist = 0.0f;
-                int quant_max;
 
-                for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
-                    int b;
-                    dist += quantize_band_cost(s, coefs + w2*128,
-                                               scaled + w2*128,
-                                               sce->ics.swb_sizes[g],
-                                               scf,
-                                               ESC_BT,
-                                               lambda,
-                                               INFINITY,
-                                               &b,
-                                               0);
-                    dist -= b;
+            pns_tgt_energy = sfb_energy*FFMIN(1.0f, spread*spread);
+            noise_sfi = av_clip(roundf(log2f(pns_tgt_energy)*2), -100, 155); /* Quantize */
+            noise_amp = -ff_aac_pow2sf_tab[noise_sfi + POW_SF2_ZERO];    /* Dequantize */
+            if (prev != -1000) {
+                int noise_sfdiff = noise_sfi - prev + SCALE_DIFF_ZERO;
+                if (noise_sfdiff < 0 || noise_sfdiff > 2*SCALE_MAX_DIFF) {
+                    if (!sce->zeroes[w*16+g])
+                        prev_sf = sce->sf_idx[w*16+g];
+                    continue;
                 }
-                dist *= 1.0f / 512.0f / lambda;
-                quant_max = quant(maxq[w*16+g], ff_aac_pow2sf_tab[POW_SF2_ZERO - scf + SCALE_ONE_POS - SCALE_DIV_512], ROUND_STANDARD);
-                if (quant_max >= 8191) { // too much, return to the previous quantizer
-                    sce->sf_idx[w*16+g] = prev_scf;
-                    break;
+            }
+            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
+                float band_energy, scale, pns_senergy;
+                const int start_c = (w+w2)*128+sce->ics.swb_offset[g];
+                band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
+                for (i = 0; i < sce->ics.swb_sizes[g]; i++) {
+                    s->random_state  = lcg_random(s->random_state);
+                    PNS[i] = s->random_state;
                 }
-                prev_scf = scf;
-                curdiff = fabsf(dist - uplim[w*16+g]);
-                if (curdiff <= 1.0f)
-                    step = 0;
-                else
-                    step = log2f(curdiff);
-                if (dist > uplim[w*16+g])
-                    step = -step;
-                scf += step;
-                scf = av_clip_uint8(scf);
-                step = scf - prev_scf;
-                if (FFABS(step) <= 1 || (step > 0 && scf >= max_scf) || (step < 0 && scf <= min_scf)) {
-                    sce->sf_idx[w*16+g] = av_clip(scf, min_scf, max_scf);
-                    break;
-                }
-                if (step > 0)
-                    min_scf = prev_scf;
-                else
-                    max_scf = prev_scf;
+                band_energy = s->fdsp->scalarproduct_float(PNS, PNS, sce->ics.swb_sizes[g]);
+                scale = noise_amp/sqrtf(band_energy);
+                s->fdsp->vector_fmul_scalar(PNS, PNS, scale, sce->ics.swb_sizes[g]);
+                pns_senergy = s->fdsp->scalarproduct_float(PNS, PNS, sce->ics.swb_sizes[g]);
+                pns_energy += pns_senergy;
+                abs_pow34_v(NOR34, &sce->coeffs[start_c], sce->ics.swb_sizes[g]);
+                abs_pow34_v(PNS34, PNS, sce->ics.swb_sizes[g]);
+                dist1 += quantize_band_cost(s, &sce->coeffs[start_c],
+                                            NOR34,
+                                            sce->ics.swb_sizes[g],
+                                            sce->sf_idx[(w+w2)*16+g],
+                                            sce->band_alt[(w+w2)*16+g],
+                                            lambda/band->threshold, INFINITY, NULL, NULL, 0);
+                /* Estimate rd on average as 5 bits for SF, 4 for the CB, plus spread energy * lambda/thr */
+                dist2 += band->energy/(band->spread*band->spread)*lambda*dist_thresh/band->threshold;
             }
-            start += size;
+            if (g && sce->band_type[w*16+g-1] == NOISE_BT) {
+                dist2 += 5;
+            } else {
+                dist2 += 9;
+            }
+            energy_ratio = pns_tgt_energy/pns_energy; /* Compensates for quantization error */
+            sce->pns_ener[w*16+g] = energy_ratio*pns_tgt_energy;
+            if (sce->zeroes[w*16+g] || !sce->band_alt[w*16+g] || (energy_ratio > 0.85f && energy_ratio < 1.25f && dist2 < dist1)) {
+                sce->band_type[w*16+g] = NOISE_BT;
+                sce->zeroes[w*16+g] = 0;
+                prev = noise_sfi;
+            } else {
+                if (!sce->zeroes[w*16+g])
+                    prev_sf = sce->sf_idx[w*16+g];
+            }
         }
     }
-    minq = sce->sf_idx[0] ? sce->sf_idx[0] : INT_MAX;
-    for (i = 1; i < 128; i++) {
-        if (!sce->sf_idx[i])
-            sce->sf_idx[i] = sce->sf_idx[i-1];
-        else
-            minq = FFMIN(minq, sce->sf_idx[i]);
-    }
-    if (minq == INT_MAX)
-        minq = 0;
-    minq = FFMIN(minq, SCALE_MAX_POS);
-    maxsf = FFMIN(minq + SCALE_MAX_DIFF, SCALE_MAX_POS);
-    for (i = 126; i >= 0; i--) {
-        if (!sce->sf_idx[i])
-            sce->sf_idx[i] = sce->sf_idx[i+1];
-        sce->sf_idx[i] = av_clip(sce->sf_idx[i], minq, maxsf);
-    }
 }
 
-static void search_for_quantizers_fast(AVCodecContext *avctx, AACEncContext *s,
-                                       SingleChannelElement *sce,
-                                       const float lambda)
+static void mark_pns(AACEncContext *s, AVCodecContext *avctx, SingleChannelElement *sce)
 {
-    int i, w, w2, g;
-    int minq = 255;
+    FFPsyBand *band;
+    int w, g, w2;
+    int wlen = 1024 / sce->ics.num_windows;
+    int bandwidth, cutoff;
+    const float lambda = s->lambda;
+    const float freq_mult = avctx->sample_rate*0.5f/wlen;
+    const float spread_threshold = FFMIN(0.75f, NOISE_SPREAD_THRESHOLD*FFMAX(0.5f, lambda/100.f));
+    const float pns_transient_energy_r = FFMIN(0.7f, lambda / 140.f);
 
-    memset(sce->sf_idx, 0, sizeof(sce->sf_idx));
+    int refbits = avctx->bit_rate * 1024.0 / avctx->sample_rate
+        / ((avctx->flags & CODEC_FLAG_QSCALE) ? 2.0f : avctx->channels)
+        * (lambda / 120.f);
+
+    /** Keep this in sync with twoloop's cutoff selection */
+    float rate_bandwidth_multiplier = 1.5f;
+    int frame_bit_rate = (avctx->flags & CODEC_FLAG_QSCALE)
+        ? (refbits * rate_bandwidth_multiplier * avctx->sample_rate / 1024)
+        : (avctx->bit_rate / avctx->channels);
+
+    frame_bit_rate *= 1.15f;
+
+    if (avctx->cutoff > 0) {
+        bandwidth = avctx->cutoff;
+    } else {
+        bandwidth = FFMAX(3000, AAC_CUTOFF_FROM_BITRATE(frame_bit_rate, 1, avctx->sample_rate));
+    }
+
+    cutoff = bandwidth * 2 * wlen / avctx->sample_rate;
+
+    memcpy(sce->band_alt, sce->band_type, sizeof(sce->band_type));
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
         for (g = 0; g < sce->ics.num_swb; g++) {
+            float sfb_energy = 0.0f, threshold = 0.0f, spread = 2.0f;
+            float min_energy = -1.0f, max_energy = 0.0f;
+            const int start = sce->ics.swb_offset[g];
+            const float freq = start*freq_mult;
+            const float freq_boost = FFMAX(0.88f*freq/NOISE_LOW_LIMIT, 1.0f);
+            if (freq < NOISE_LOW_LIMIT || start >= cutoff) {
+                sce->can_pns[w*16+g] = 0;
+                continue;
+            }
             for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
-                FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
-                if (band->energy <= band->threshold) {
-                    sce->sf_idx[(w+w2)*16+g] = 218;
-                    sce->zeroes[(w+w2)*16+g] = 1;
+                band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
+                sfb_energy += band->energy;
+                spread     = FFMIN(spread, band->spread);
+                threshold  += band->threshold;
+                if (!w2) {
+                    min_energy = max_energy = band->energy;
                 } else {
-                    sce->sf_idx[(w+w2)*16+g] = av_clip(SCALE_ONE_POS - SCALE_DIV_512 + log2f(band->threshold), 80, 218);
-                    sce->zeroes[(w+w2)*16+g] = 0;
+                    min_energy = FFMIN(min_energy, band->energy);
+                    max_energy = FFMAX(max_energy, band->energy);
                 }
-                minq = FFMIN(minq, sce->sf_idx[(w+w2)*16+g]);
             }
-        }
-    }
-    for (i = 0; i < 128; i++) {
-        sce->sf_idx[i] = 140;
-        //av_clip(sce->sf_idx[i], minq, minq + SCALE_MAX_DIFF - 1);
-    }
-    //set the same quantizers inside window groups
-    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])
-        for (g = 0;  g < sce->ics.num_swb; g++)
-            for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)
-                sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];
-}
 
-static void search_for_pns(AACEncContext *s, AVCodecContext *avctx, SingleChannelElement *sce)
-{
-    int start = 0, w, w2, g;
-    const float lambda = s->lambda;
-    const float freq_mult = avctx->sample_rate/(1024.0f/sce->ics.num_windows)/2.0f;
-    const float spread_threshold = NOISE_SPREAD_THRESHOLD*(lambda/120.f);
-    const float thr_mult = NOISE_LAMBDA_NUMERATOR/lambda;
-
-    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        start = 0;
-        for (g = 0;  g < sce->ics.num_swb; g++) {
-            if (start*freq_mult > NOISE_LOW_LIMIT*(lambda/170.0f)) {
-                float energy = 0.0f, threshold = 0.0f, spread = 0.0f;
-                for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
-                    FFPsyBand *band = &s->psy.ch[s->cur_channel+0].psy_bands[(w+w2)*16+g];
-                    energy += band->energy;
-                    threshold += band->threshold;
-                    spread += band->spread;
-                }
-                if (spread > spread_threshold*sce->ics.group_len[w] &&
-                    ((sce->zeroes[w*16+g] && energy >= threshold) ||
-                    energy < threshold*thr_mult*sce->ics.group_len[w])) {
-                    sce->band_type[w*16+g] = NOISE_BT;
-                    sce->pns_ener[w*16+g] = energy / sce->ics.group_len[w];
-                    sce->zeroes[w*16+g] = 0;
-                }
+            /* PNS is acceptable when all of these are true:
+             * 1. high spread energy (noise-like band)
+             * 2. near-threshold energy (high PE means the random nature of PNS content will be noticed)
+             * 3. on short window groups, all windows have similar energy (variations in energy would be destroyed by PNS)
+             */
+            sce->pns_ener[w*16+g] = sfb_energy;
+            if (sfb_energy < threshold*sqrtf(1.5f/freq_boost) || spread < spread_threshold || min_energy < pns_transient_energy_r * max_energy) {
+                sce->can_pns[w*16+g] = 0;
+            } else {
+                sce->can_pns[w*16+g] = 1;
             }
-            start += sce->ics.swb_sizes[g];
         }
     }
 }
 
 static void search_for_ms(AACEncContext *s, ChannelElement *cpe)
 {
-    int start = 0, i, w, w2, g;
+    int start = 0, i, w, w2, g, sid_sf_boost, prev_mid, prev_side;
+    uint8_t nextband0[128], nextband1[128];
     float M[128], S[128];
     float *L34 = s->scoefs, *R34 = s->scoefs + 128, *M34 = s->scoefs + 128*2, *S34 = s->scoefs + 128*3;
     const float lambda = s->lambda;
+    const float mslambda = FFMIN(1.0f, lambda / 120.f);
     SingleChannelElement *sce0 = &cpe->ch[0];
     SingleChannelElement *sce1 = &cpe->ch[1];
     if (!cpe->common_window)
         return;
+
+    /** Scout out next nonzero bands */
+    ff_init_nextband_map(sce0, nextband0);
+    ff_init_nextband_map(sce1, nextband1);
+
+    prev_mid = sce0->sf_idx[0];
+    prev_side = sce1->sf_idx[0];
     for (w = 0; w < sce0->ics.num_windows; w += sce0->ics.group_len[w]) {
         start = 0;
-        for (g = 0;  g < sce0->ics.num_swb; g++) {
-            if (!cpe->ch[0].zeroes[w*16+g] && !cpe->ch[1].zeroes[w*16+g]) {
-                float dist1 = 0.0f, dist2 = 0.0f;
+        for (g = 0; g < sce0->ics.num_swb; g++) {
+            float bmax = bval2bmax(g * 17.0f / sce0->ics.num_swb) / 0.0045f;
+            if (!cpe->is_mask[w*16+g])
+                cpe->ms_mask[w*16+g] = 0;
+            if (!sce0->zeroes[w*16+g] && !sce1->zeroes[w*16+g] && !cpe->is_mask[w*16+g]) {
+                float Mmax = 0.0f, Smax = 0.0f;
+
+                /* Must compute mid/side SF and book for the whole window group */
                 for (w2 = 0; w2 < sce0->ics.group_len[w]; w2++) {
-                    FFPsyBand *band0 = &s->psy.ch[s->cur_channel+0].psy_bands[(w+w2)*16+g];
-                    FFPsyBand *band1 = &s->psy.ch[s->cur_channel+1].psy_bands[(w+w2)*16+g];
-                    float minthr = FFMIN(band0->threshold, band1->threshold);
-                    float maxthr = FFMAX(band0->threshold, band1->threshold);
                     for (i = 0; i < sce0->ics.swb_sizes[g]; i++) {
                         M[i] = (sce0->coeffs[start+(w+w2)*128+i]
                               + sce1->coeffs[start+(w+w2)*128+i]) * 0.5;
                         S[i] =  M[i]
                               - sce1->coeffs[start+(w+w2)*128+i];
                     }
-                    abs_pow34_v(L34, sce0->coeffs+start+(w+w2)*128, sce0->ics.swb_sizes[g]);
-                    abs_pow34_v(R34, sce1->coeffs+start+(w+w2)*128, sce0->ics.swb_sizes[g]);
-                    abs_pow34_v(M34, M,                         sce0->ics.swb_sizes[g]);
-                    abs_pow34_v(S34, S,                         sce0->ics.swb_sizes[g]);
-                    dist1 += quantize_band_cost(s, &sce0->coeffs[start + (w+w2)*128],
-                                                L34,
-                                                sce0->ics.swb_sizes[g],
-                                                sce0->sf_idx[(w+w2)*16+g],
-                                                sce0->band_type[(w+w2)*16+g],
-                                                lambda / band0->threshold, INFINITY, NULL, 0);
-                    dist1 += quantize_band_cost(s, &sce1->coeffs[start + (w+w2)*128],
-                                                R34,
-                                                sce1->ics.swb_sizes[g],
-                                                sce1->sf_idx[(w+w2)*16+g],
-                                                sce1->band_type[(w+w2)*16+g],
-                                                lambda / band1->threshold, INFINITY, NULL, 0);
-                    dist2 += quantize_band_cost(s, M,
-                                                M34,
-                                                sce0->ics.swb_sizes[g],
-                                                sce0->sf_idx[(w+w2)*16+g],
-                                                sce0->band_type[(w+w2)*16+g],
-                                                lambda / maxthr, INFINITY, NULL, 0);
-                    dist2 += quantize_band_cost(s, S,
-                                                S34,
-                                                sce1->ics.swb_sizes[g],
-                                                sce1->sf_idx[(w+w2)*16+g],
-                                                sce1->band_type[(w+w2)*16+g],
-                                                lambda / minthr, INFINITY, NULL, 0);
+                    abs_pow34_v(M34, M, sce0->ics.swb_sizes[g]);
+                    abs_pow34_v(S34, S, sce0->ics.swb_sizes[g]);
+                    for (i = 0; i < sce0->ics.swb_sizes[g]; i++ ) {
+                        Mmax = FFMAX(Mmax, M34[i]);
+                        Smax = FFMAX(Smax, S34[i]);
+                    }
                 }
-                cpe->ms_mask[w*16+g] = dist2 < dist1;
+
+                for (sid_sf_boost = 0; sid_sf_boost < 4; sid_sf_boost++) {
+                    float dist1 = 0.0f, dist2 = 0.0f;
+                    int B0 = 0, B1 = 0;
+                    int minidx;
+                    int mididx, sididx;
+                    int midcb, sidcb;
+
+                    minidx = FFMIN(sce0->sf_idx[w*16+g], sce1->sf_idx[w*16+g]);
+                    mididx = av_clip(minidx, 0, SCALE_MAX_POS - SCALE_DIV_512);
+                    sididx = av_clip(minidx - sid_sf_boost * 3, 0, SCALE_MAX_POS - SCALE_DIV_512);
+                    if (sce0->band_type[w*16+g] != NOISE_BT && sce1->band_type[w*16+g] != NOISE_BT
+                        && (   !ff_sfdelta_can_replace(sce0, nextband0, prev_mid, mididx, w*16+g)
+                            || !ff_sfdelta_can_replace(sce1, nextband1, prev_side, sididx, w*16+g))) {
+                        /* scalefactor range violation, bad stuff, will decrease quality unacceptably */
+                        continue;
+                    }
+
+                    midcb = find_min_book(Mmax, mididx);
+                    sidcb = find_min_book(Smax, sididx);
+
+                    /* No CB can be zero */
+                    midcb = FFMAX(1,midcb);
+                    sidcb = FFMAX(1,sidcb);
+
+                    for (w2 = 0; w2 < sce0->ics.group_len[w]; w2++) {
+                        FFPsyBand *band0 = &s->psy.ch[s->cur_channel+0].psy_bands[(w+w2)*16+g];
+                        FFPsyBand *band1 = &s->psy.ch[s->cur_channel+1].psy_bands[(w+w2)*16+g];
+                        float minthr = FFMIN(band0->threshold, band1->threshold);
+                        int b1,b2,b3,b4;
+                        for (i = 0; i < sce0->ics.swb_sizes[g]; i++) {
+                            M[i] = (sce0->coeffs[start+(w+w2)*128+i]
+                                  + sce1->coeffs[start+(w+w2)*128+i]) * 0.5;
+                            S[i] =  M[i]
+                                  - sce1->coeffs[start+(w+w2)*128+i];
+                        }
+
+                        abs_pow34_v(L34, sce0->coeffs+start+(w+w2)*128, sce0->ics.swb_sizes[g]);
+                        abs_pow34_v(R34, sce1->coeffs+start+(w+w2)*128, sce0->ics.swb_sizes[g]);
+                        abs_pow34_v(M34, M,                         sce0->ics.swb_sizes[g]);
+                        abs_pow34_v(S34, S,                         sce0->ics.swb_sizes[g]);
+                        dist1 += quantize_band_cost(s, &sce0->coeffs[start + (w+w2)*128],
+                                                    L34,
+                                                    sce0->ics.swb_sizes[g],
+                                                    sce0->sf_idx[w*16+g],
+                                                    sce0->band_type[w*16+g],
+                                                    lambda / band0->threshold, INFINITY, &b1, NULL, 0);
+                        dist1 += quantize_band_cost(s, &sce1->coeffs[start + (w+w2)*128],
+                                                    R34,
+                                                    sce1->ics.swb_sizes[g],
+                                                    sce1->sf_idx[w*16+g],
+                                                    sce1->band_type[w*16+g],
+                                                    lambda / band1->threshold, INFINITY, &b2, NULL, 0);
+                        dist2 += quantize_band_cost(s, M,
+                                                    M34,
+                                                    sce0->ics.swb_sizes[g],
+                                                    mididx,
+                                                    midcb,
+                                                    lambda / minthr, INFINITY, &b3, NULL, 0);
+                        dist2 += quantize_band_cost(s, S,
+                                                    S34,
+                                                    sce1->ics.swb_sizes[g],
+                                                    sididx,
+                                                    sidcb,
+                                                    mslambda / (minthr * bmax), INFINITY, &b4, NULL, 0);
+                        B0 += b1+b2;
+                        B1 += b3+b4;
+                        dist1 -= b1+b2;
+                        dist2 -= b3+b4;
+                    }
+                    cpe->ms_mask[w*16+g] = dist2 <= dist1 && B1 < B0;
+                    if (cpe->ms_mask[w*16+g]) {
+                        if (sce0->band_type[w*16+g] != NOISE_BT && sce1->band_type[w*16+g] != NOISE_BT) {
+                            sce0->sf_idx[w*16+g] = mididx;
+                            sce1->sf_idx[w*16+g] = sididx;
+                            sce0->band_type[w*16+g] = midcb;
+                            sce1->band_type[w*16+g] = sidcb;
+                        } else if ((sce0->band_type[w*16+g] != NOISE_BT) ^ (sce1->band_type[w*16+g] != NOISE_BT)) {
+                            /* ms_mask unneeded, and it confuses some decoders */
+                            cpe->ms_mask[w*16+g] = 0;
+                        }
+                        break;
+                    } else if (B1 > B0) {
+                        /* More boost won't fix this */
+                        break;
+                    }
+                }
             }
+            if (!sce0->zeroes[w*16+g] && sce0->band_type[w*16+g] < RESERVED_BT)
+                prev_mid = sce0->sf_idx[w*16+g];
+            if (!sce1->zeroes[w*16+g] && !cpe->is_mask[w*16+g] && sce1->band_type[w*16+g] < RESERVED_BT)
+                prev_side = sce1->sf_idx[w*16+g];
             start += sce0->ics.swb_sizes[g];
         }
     }
 }
 
 AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
-    [AAC_CODER_FAAC] = {
-        search_for_quantizers_faac,
-        encode_window_bands_info,
-        quantize_and_encode_band,
-        ff_aac_encode_tns_info,
-        ff_aac_encode_main_pred,
-        ff_aac_adjust_common_prediction,
-        ff_aac_apply_main_pred,
-        ff_aac_apply_tns,
-        set_special_band_scalefactors,
-        search_for_pns,
-        ff_aac_search_for_tns,
-        search_for_ms,
-        ff_aac_search_for_is,
-        ff_aac_search_for_pred,
-    },
     [AAC_CODER_ANMR] = {
         search_for_quantizers_anmr,
         encode_window_bands_info,
         quantize_and_encode_band,
         ff_aac_encode_tns_info,
+        ff_aac_encode_ltp_info,
         ff_aac_encode_main_pred,
-        ff_aac_adjust_common_prediction,
+        ff_aac_adjust_common_pred,
+        ff_aac_adjust_common_ltp,
         ff_aac_apply_main_pred,
         ff_aac_apply_tns,
+        ff_aac_update_ltp,
+        ff_aac_ltp_insert_new_frame,
         set_special_band_scalefactors,
         search_for_pns,
+        mark_pns,
         ff_aac_search_for_tns,
+        ff_aac_search_for_ltp,
         search_for_ms,
         ff_aac_search_for_is,
         ff_aac_search_for_pred,
@@@@ -993,29 +921,41 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
         codebook_trellis_rate,
         quantize_and_encode_band,
         ff_aac_encode_tns_info,
+        ff_aac_encode_ltp_info,
         ff_aac_encode_main_pred,
-        ff_aac_adjust_common_prediction,
+        ff_aac_adjust_common_pred,
+        ff_aac_adjust_common_ltp,
         ff_aac_apply_main_pred,
         ff_aac_apply_tns,
+        ff_aac_update_ltp,
+        ff_aac_ltp_insert_new_frame,
         set_special_band_scalefactors,
         search_for_pns,
+        mark_pns,
         ff_aac_search_for_tns,
+        ff_aac_search_for_ltp,
         search_for_ms,
         ff_aac_search_for_is,
         ff_aac_search_for_pred,
     },
     [AAC_CODER_FAST] = {
         search_for_quantizers_fast,
-        encode_window_bands_info,
+        codebook_trellis_rate,
         quantize_and_encode_band,
         ff_aac_encode_tns_info,
+        ff_aac_encode_ltp_info,
         ff_aac_encode_main_pred,
-        ff_aac_adjust_common_prediction,
+        ff_aac_adjust_common_pred,
+        ff_aac_adjust_common_ltp,
         ff_aac_apply_main_pred,
         ff_aac_apply_tns,
+        ff_aac_update_ltp,
+        ff_aac_ltp_insert_new_frame,
         set_special_band_scalefactors,
         search_for_pns,
+        mark_pns,
         ff_aac_search_for_tns,
+        ff_aac_search_for_ltp,
         search_for_ms,
         ff_aac_search_for_is,
         ff_aac_search_for_pred,
@


1.11
log
@Update to ffmpeg-20160903.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.10 2016/01/22 07:05:01 ajacoutot Exp $
d51 4
a54 2
--- libavcodec/aaccoder.c.orig	Mon May  2 21:27:22 2016
+++ libavcodec/aaccoder.c	Sat Aug 13 22:42:46 2016
d453 1
a453 1
@@@@ -659,331 +540,380 @@@@ static void search_for_quantizers_twoloop(AVCodecConte
d672 3
a674 5
+                for (i = 0; i < sce->ics.swb_sizes[g]; i+=2) {
+                    double rnd[2];
+                    av_bmg_get(&s->lfg, rnd);
+                    PNS[i+0] = (float)rnd[0];
+                    PNS[i+1] = (float)rnd[1];
d1086 1
a1086 1
@@@@ -993,29 +923,41 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
@


1.10
log
@Yet again mor AAC fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.9 2016/01/18 15:34:45 ajacoutot Exp $
d47 6
a52 2
--- libavcodec/aaccoder.c.orig	Wed Jan 13 15:27:47 2016
+++ libavcodec/aaccoder.c	Wed Jan 20 21:24:57 2016
d258 2
a259 1
         for (g = 0;  g < sce->ics.num_swb; g++) {
d279 2
a280 1
@@@@ -350,10 +221,12 @@@@ static void set_special_band_scalefactors(AACEncContex
d283 2
a284 1
         for (g = 0;  g < sce->ics.num_swb; g++) {
d341 7
a347 1
@@@@ -509,324 +392,6 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d358 10
a367 13
-{
-    int start = 0, i, w, w2, g;
-    int destbits = avctx->bit_rate * 1024.0 / avctx->sample_rate / avctx->channels * (lambda / 120.f);
-    float dists[128] = { 0 }, uplims[128] = { 0 };
-    float maxvals[128];
-    int fflag, minscaler;
-    int its  = 0;
-    int allz = 0;
-    float minthr = INFINITY;
-
-    // for values above this the decoder might end up in an endless loop
-    // due to always having more bits than what can be encoded.
-    destbits = FFMIN(destbits, 5800);
d369 3
a371 2
-    //determine zero bands and upper limits
-    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
d373 6
a378 4
-            int nz = 0;
-            float uplim = 0.0f, energy = 0.0f;
-            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
-                FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
d380 17
a396 15
-                energy += band->energy;
-                if (band->energy <= band->threshold || band->threshold == 0.0f) {
-                    sce->zeroes[(w+w2)*16+g] = 1;
-                    continue;
-                }
-                nz = 1;
-            }
-            uplims[w*16+g] = uplim *512;
-            sce->zeroes[w*16+g] = !nz;
-            if (nz)
-                minthr = FFMIN(minthr, uplim);
-            allz |= nz;
-        }
-    }
-    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
d398 12
a409 14
-            if (sce->zeroes[w*16+g]) {
-                sce->sf_idx[w*16+g] = SCALE_ONE_POS;
-                continue;
-            }
-            sce->sf_idx[w*16+g] = SCALE_ONE_POS + FFMIN(log2f(uplims[w*16+g]/minthr)*4,59);
-        }
-    }
-
-    if (!allz)
-        return;
-    abs_pow34_v(s->scoefs, sce->coeffs, 1024);
-
-    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        start = w*128;
d411 8
a418 18
-            const float *scaled = s->scoefs + start;
-            maxvals[w*16+g] = find_max_val(sce->ics.group_len[w], sce->ics.swb_sizes[g], scaled);
-            start += sce->ics.swb_sizes[g];
-        }
-    }
-
-    //perform two-loop search
-    //outer loop - improve quality
-    do {
-        int tbits, qstep;
-        minscaler = sce->sf_idx[0];
-        //inner loop - quantize spectrum to fit into given number of bits
-        qstep = its ? 1 : 32;
-        do {
-            int prev = -1;
-            tbits = 0;
-            for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-                start = w*128;
d422 10
a431 12
-                    int bits = 0;
-                    int cb;
-                    float dist = 0.0f;
-
-                    if (sce->zeroes[w*16+g] || sce->sf_idx[w*16+g] >= 218) {
-                        start += sce->ics.swb_sizes[g];
-                        continue;
-                    }
-                    minscaler = FFMIN(minscaler, sce->sf_idx[w*16+g]);
-                    cb = find_min_book(maxvals[w*16+g], sce->sf_idx[w*16+g]);
-                    for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
-                        int b;
d441 14
a454 48
-                        bits += b;
-                    }
-                    dists[w*16+g] = dist - bits;
-                    if (prev != -1) {
-                        bits += ff_aac_scalefactor_bits[sce->sf_idx[w*16+g] - prev + SCALE_DIFF_ZERO];
-                    }
-                    tbits += bits;
-                    start += sce->ics.swb_sizes[g];
-                    prev = sce->sf_idx[w*16+g];
-                }
-            }
-            if (tbits > destbits) {
-                for (i = 0; i < 128; i++)
-                    if (sce->sf_idx[i] < 218 - qstep)
-                        sce->sf_idx[i] += qstep;
-            } else {
-                for (i = 0; i < 128; i++)
-                    if (sce->sf_idx[i] > 60 - qstep)
-                        sce->sf_idx[i] -= qstep;
-            }
-            qstep >>= 1;
-            if (!qstep && tbits > destbits*1.02 && sce->sf_idx[0] < 217)
-                qstep = 1;
-        } while (qstep);
-
-        fflag = 0;
-        minscaler = av_clip(minscaler, 60, 255 - SCALE_MAX_DIFF);
-
-        for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-            for (g = 0; g < sce->ics.num_swb; g++) {
-                int prevsc = sce->sf_idx[w*16+g];
-                if (dists[w*16+g] > uplims[w*16+g] && sce->sf_idx[w*16+g] > 60) {
-                    if (find_min_book(maxvals[w*16+g], sce->sf_idx[w*16+g]-1))
-                        sce->sf_idx[w*16+g]--;
-                    else //Try to make sure there is some energy in every band
-                        sce->sf_idx[w*16+g]-=2;
-                }
-                sce->sf_idx[w*16+g] = av_clip(sce->sf_idx[w*16+g], minscaler, minscaler + SCALE_MAX_DIFF);
-                sce->sf_idx[w*16+g] = FFMIN(sce->sf_idx[w*16+g], 219);
-                if (sce->sf_idx[w*16+g] != prevsc)
-                    fflag = 1;
-                sce->band_type[w*16+g] = find_min_book(maxvals[w*16+g], sce->sf_idx[w*16+g]);
-            }
-        }
-        its++;
-    } while (fflag && its < 10);
-}
-
d458 2
a459 1
-{
d479 30
a508 1
-    } else {
d524 2
a525 1
-    }
d533 6
a538 1
-    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
d540 2
a541 1
-        for (g = 0; g < sce->ics.num_swb; g++) {
d552 14
a565 3
-                continue;
-            }
-            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
d574 11
a584 2
-                }
-            }
d612 20
a631 2
-                continue;
-            }
d637 1
a637 1
-
d650 10
a659 1
-                }
d665 11
a675 1
-                }
a694 155
-            }
-            start += size;
-        }
-    }
-    minq = sce->sf_idx[0] ? sce->sf_idx[0] : INT_MAX;
-    for (i = 1; i < 128; i++) {
-        if (!sce->sf_idx[i])
-            sce->sf_idx[i] = sce->sf_idx[i-1];
-        else
-            minq = FFMIN(minq, sce->sf_idx[i]);
-    }
-    if (minq == INT_MAX)
-        minq = 0;
-    minq = FFMIN(minq, SCALE_MAX_POS);
-    maxsf = FFMIN(minq + SCALE_MAX_DIFF, SCALE_MAX_POS);
-    for (i = 126; i >= 0; i--) {
-        if (!sce->sf_idx[i])
-            sce->sf_idx[i] = sce->sf_idx[i+1];
-        sce->sf_idx[i] = av_clip(sce->sf_idx[i], minq, maxsf);
-    }
-}
-
 static void search_for_quantizers_fast(AVCodecContext *avctx, AACEncContext *s,
                                        SingleChannelElement *sce,
                                        const float lambda)
@@@@ -863,127 +428,378 @@@@ static void search_for_quantizers_fast(AVCodecContext 
 
 static void search_for_pns(AACEncContext *s, AVCodecContext *avctx, SingleChannelElement *sce)
 {
-    int start = 0, w, w2, g;
+    FFPsyBand *band;
+    int w, g, w2, i;
+    int wlen = 1024 / sce->ics.num_windows;
+    int bandwidth, cutoff;
+    float *PNS = &s->scoefs[0*128], *PNS34 = &s->scoefs[1*128];
+    float *NOR34 = &s->scoefs[3*128];
+    uint8_t nextband[128];
     const float lambda = s->lambda;
-    const float freq_mult = avctx->sample_rate/(1024.0f/sce->ics.num_windows)/2.0f;
-    const float spread_threshold = NOISE_SPREAD_THRESHOLD*(lambda/120.f);
-    const float thr_mult = NOISE_LAMBDA_NUMERATOR/lambda;
+    const float freq_mult = avctx->sample_rate*0.5f/wlen;
+    const float thr_mult = NOISE_LAMBDA_REPLACE*(100.0f/lambda);
+    const float spread_threshold = FFMIN(0.75f, NOISE_SPREAD_THRESHOLD*FFMAX(0.5f, lambda/100.f));
+    const float dist_bias = av_clipf(4.f * 120 / lambda, 0.25f, 4.0f);
+    const float pns_transient_energy_r = FFMIN(0.7f, lambda / 140.f);
 
+    int refbits = avctx->bit_rate * 1024.0 / avctx->sample_rate
+        / ((avctx->flags & CODEC_FLAG_QSCALE) ? 2.0f : avctx->channels)
+        * (lambda / 120.f);
+
+    /** Keep this in sync with twoloop's cutoff selection */
+    float rate_bandwidth_multiplier = 1.5f;
+    int prev = -1000, prev_sf = -1;
+    int frame_bit_rate = (avctx->flags & CODEC_FLAG_QSCALE)
+        ? (refbits * rate_bandwidth_multiplier * avctx->sample_rate / 1024)
+        : (avctx->bit_rate / avctx->channels);
+
+    frame_bit_rate *= 1.15f;
+
+    if (avctx->cutoff > 0) {
+        bandwidth = avctx->cutoff;
+    } else {
+        bandwidth = FFMAX(3000, AAC_CUTOFF_FROM_BITRATE(frame_bit_rate, 1, avctx->sample_rate));
+    }
+
+    cutoff = bandwidth * 2 * wlen / avctx->sample_rate;
+
+    memcpy(sce->band_alt, sce->band_type, sizeof(sce->band_type));
+    ff_init_nextband_map(sce, nextband);
     for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
-        start = 0;
+        int wstart = w*128;
         for (g = 0;  g < sce->ics.num_swb; g++) {
-            if (start*freq_mult > NOISE_LOW_LIMIT*(lambda/170.0f)) {
-                float energy = 0.0f, threshold = 0.0f, spread = 0.0f;
-                for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
-                    FFPsyBand *band = &s->psy.ch[s->cur_channel+0].psy_bands[(w+w2)*16+g];
-                    energy += band->energy;
-                    threshold += band->threshold;
-                    spread += band->spread;
+            int noise_sfi;
+            float dist1 = 0.0f, dist2 = 0.0f, noise_amp;
+            float pns_energy = 0.0f, pns_tgt_energy, energy_ratio, dist_thresh;
+            float sfb_energy = 0.0f, threshold = 0.0f, spread = 2.0f;
+            float min_energy = -1.0f, max_energy = 0.0f;
+            const int start = wstart+sce->ics.swb_offset[g];
+            const float freq = (start-wstart)*freq_mult;
+            const float freq_boost = FFMAX(0.88f*freq/NOISE_LOW_LIMIT, 1.0f);
+            if (freq < NOISE_LOW_LIMIT || (start-wstart) >= cutoff) {
+                if (!sce->zeroes[w*16+g])
+                    prev_sf = sce->sf_idx[w*16+g];
+                continue;
+            }
+            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
+                band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
+                sfb_energy += band->energy;
+                spread     = FFMIN(spread, band->spread);
+                threshold  += band->threshold;
+                if (!w2) {
+                    min_energy = max_energy = band->energy;
+                } else {
+                    min_energy = FFMIN(min_energy, band->energy);
+                    max_energy = FFMAX(max_energy, band->energy);
                 }
-                if (spread > spread_threshold*sce->ics.group_len[w] &&
-                    ((sce->zeroes[w*16+g] && energy >= threshold) ||
-                    energy < threshold*thr_mult*sce->ics.group_len[w])) {
-                    sce->band_type[w*16+g] = NOISE_BT;
-                    sce->pns_ener[w*16+g] = energy / sce->ics.group_len[w];
-                    sce->zeroes[w*16+g] = 0;
+            }
+
+            /* Ramps down at ~8000Hz and loosens the dist threshold */
+            dist_thresh = av_clipf(2.5f*NOISE_LOW_LIMIT/freq, 0.5f, 2.5f) * dist_bias;
+
+            /* PNS is acceptable when all of these are true:
+             * 1. high spread energy (noise-like band)
+             * 2. near-threshold energy (high PE means the random nature of PNS content will be noticed)
+             * 3. on short window groups, all windows have similar energy (variations in energy would be destroyed by PNS)
+             *
+             * At this stage, point 2 is relaxed for zeroed bands near the noise threshold (hole avoidance is more important)
+             */
+            if ((!sce->zeroes[w*16+g] && !ff_sfdelta_can_remove_band(sce, nextband, prev_sf, w*16+g)) ||
+                ((sce->zeroes[w*16+g] || !sce->band_alt[w*16+g]) && sfb_energy < threshold*sqrtf(1.0f/freq_boost)) || spread < spread_threshold ||
+                (!sce->zeroes[w*16+g] && sce->band_alt[w*16+g] && sfb_energy > threshold*thr_mult*freq_boost) ||
+                min_energy < pns_transient_energy_r * max_energy ) {
+                sce->pns_ener[w*16+g] = sfb_energy;
+                if (!sce->zeroes[w*16+g])
+                    prev_sf = sce->sf_idx[w*16+g];
+                continue;
+            }
+
+            pns_tgt_energy = sfb_energy*FFMIN(1.0f, spread*spread);
+            noise_sfi = av_clip(roundf(log2f(pns_tgt_energy)*2), -100, 155); /* Quantize */
+            noise_amp = -ff_aac_pow2sf_tab[noise_sfi + POW_SF2_ZERO];    /* Dequantize */
+            if (prev != -1000) {
+                int noise_sfdiff = noise_sfi - prev + SCALE_DIFF_ZERO;
+                if (noise_sfdiff < 0 || noise_sfdiff > 2*SCALE_MAX_DIFF) {
+                    if (!sce->zeroes[w*16+g])
+                        prev_sf = sce->sf_idx[w*16+g];
+                    continue;
                 }
             }
-            start += sce->ics.swb_sizes[g];
+            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
+                float band_energy, scale, pns_senergy;
+                const int start_c = (w+w2)*128+sce->ics.swb_offset[g];
+                band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
+                for (i = 0; i < sce->ics.swb_sizes[g]; i+=2) {
+                    double rnd[2];
+                    av_bmg_get(&s->lfg, rnd);
+                    PNS[i+0] = (float)rnd[0];
+                    PNS[i+1] = (float)rnd[1];
+                }
d710 2
a711 1
+            }
d729 16
d747 3
d751 3
a753 1
+{
d762 2
a763 1
+
d785 2
a786 2
+    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
+        for (g = 0;  g < sce->ics.num_swb; g++) {
d796 5
a800 1
+            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
d807 3
a809 1
+                } else {
d812 42
a853 3
+                }
+            }
+
d864 6
a869 5
+            }
+        }
+    }
+}
+
d892 1
a892 1
         for (g = 0;  g < sce0->ics.num_swb; g++) {
d895 1
d1086 1
a1086 1
@@@@ -993,13 +809,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d1107 5
a1111 2
@@@@ -1009,13 +831,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
         encode_window_bands_info,
@


1.9
log
@Moar AAC.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.8 2016/01/14 06:09:43 ajacoutot Exp $
d45 2
d48 1
a48 1
+++ libavcodec/aaccoder.c	Sun Jan 17 21:02:47 2016
d334 1
a334 1
@@@@ -509,156 +392,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d354 1
a354 1
 
d488 169
a656 1
 static void search_for_quantizers_faac(AVCodecContext *avctx, AACEncContext *s,
d659 1
a659 10
@@@@ -776,7 +510,7 @@@@ static void search_for_quantizers_faac(AVCodecContext 
                                                ESC_BT,
                                                lambda,
                                                INFINITY,
-                                               &b,
+                                               &b, NULL,
                                                0);
                     dist -= b;
                 }
@@@@ -863,93 +597,354 @@@@ static void search_for_quantizers_fast(AVCodecContext 
d1069 9
a1077 6
@@@@ -961,13 +956,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
         encode_window_bands_info,
         quantize_and_encode_band,
         ff_aac_encode_tns_info,
+        ff_aac_encode_ltp_info,
         ff_aac_encode_main_pred,
d1079 11
a1089 15
+        ff_aac_adjust_common_pred,
+        ff_aac_adjust_common_ltp,
         ff_aac_apply_main_pred,
         ff_aac_apply_tns,
+        ff_aac_update_ltp,
+        ff_aac_ltp_insert_new_frame,
         set_special_band_scalefactors,
         search_for_pns,
+        mark_pns,
         ff_aac_search_for_tns,
+        ff_aac_search_for_ltp,
         search_for_ms,
         ff_aac_search_for_is,
         ff_aac_search_for_pred,
@@@@ -977,13 +978,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d1110 1
a1110 1
@@@@ -993,13 +1000,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d1131 1
a1131 1
@@@@ -1009,13 +1022,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
@


1.8
log
@Update to ffmpeg-20160113.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.7 2015/12/10 06:53:38 ajacoutot Exp $
d43 4
a46 2
--- libavcodec/aaccoder.c.orig	Fri Dec 25 03:00:18 2015
+++ libavcodec/aaccoder.c	Wed Jan 13 15:13:08 2016
d240 12
a251 2
@@@@ -332,11 +203,11 @@@@ static void set_special_band_scalefactors(AACEncContex
         start = 0;
d253 2
d257 1
a258 1
                 minscaler_i = FFMIN(minscaler_i, sce->sf_idx[w*16+g]);
d262 1
d264 2
a265 1
                 minscaler_n = FFMIN(minscaler_n, sce->sf_idx[w*16+g]);
d268 20
a287 1
@@@@ -390,9 +261,9 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d299 1
a299 1
@@@@ -408,6 +279,12 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d312 1
a312 1
@@@@ -456,6 +333,10 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d323 1
a323 1
@@@@ -463,7 +344,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d332 1
a332 1
@@@@ -509,156 +390,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d489 1
a489 1
@@@@ -776,7 +508,7 @@@@ static void search_for_quantizers_faac(AVCodecContext 
d498 1
a498 1
@@@@ -863,93 +595,354 @@@@ static void search_for_quantizers_fast(AVCodecContext 
d908 1
a908 1
@@@@ -961,13 +954,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d929 1
a929 1
@@@@ -977,13 +976,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d950 1
a950 1
@@@@ -993,13 +998,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d971 1
a971 1
@@@@ -1009,13 +1020,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
@


1.7
log
@Moar AAC fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.6 2015/12/06 08:51:46 ajacoutot Exp $
a30 2
aaccoder: prevent crash of anmr coder

d35 10
a44 2
--- libavcodec/aaccoder.c.orig	Thu Nov 12 02:08:28 2015
+++ libavcodec/aaccoder.c	Wed Dec  9 19:16:49 2015
a296 9
@@@@ -499,7 +380,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
     }
     while (idx) {
         sce->sf_idx[bandaddr[idx]] = minq + q0;
-        minq = paths[idx][minq].prev;
+        minq = FFMAX(paths[idx][minq].prev, 0);
         idx--;
     }
     //set the same quantizers inside window groups
d463 1
a463 1
@@@@ -863,93 +595,343 @@@@ static void search_for_quantizers_fast(AVCodecContext 
d527 3
a529 1
+            if (freq < NOISE_LOW_LIMIT || (start-wstart) >= cutoff)
d531 1
d587 6
a592 2
+                for (i = 0; i < sce->ics.swb_sizes[g]; i++)
+                    PNS[i] = s->random_state = lcg_random(s->random_state);
d620 3
a623 2
+            if (!sce->zeroes[w*16+g])
+                prev_sf = sce->sf_idx[w*16+g];
d725 3
a727 2
+            cpe->ms_mask[w*16+g] = 0;
+            if (!sce0->zeroes[w*16+g] && !sce1->zeroes[w*16+g]) {
d789 1
a789 1
+                    if (!cpe->is_mask[w*16+g] && sce0->band_type[w*16+g] != NOISE_BT && sce1->band_type[w*16+g] != NOISE_BT
d822 2
a823 2
+                                                    sce0->sf_idx[(w+w2)*16+g],
+                                                    sce0->band_type[(w+w2)*16+g],
d828 2
a829 2
+                                                    sce1->sf_idx[(w+w2)*16+g],
+                                                    sce1->band_type[(w+w2)*16+g],
d834 2
a835 2
+                                                    sce0->sf_idx[(w+w2)*16+g],
+                                                    sce0->band_type[(w+w2)*16+g],
d840 2
a841 2
+                                                    sce1->sf_idx[(w+w2)*16+g],
+                                                    sce1->band_type[(w+w2)*16+g],
d845 2
a846 2
+                        dist1 -= B0;
+                        dist2 -= B1;
d850 1
a850 2
+                        /* Setting the M/S mask is useful with I/S or PNS, but only the flag */
+                        if (!cpe->is_mask[w*16+g] && sce0->band_type[w*16+g] != NOISE_BT && sce1->band_type[w*16+g] != NOISE_BT) {
d855 3
d873 1
a873 1
@@@@ -961,13 +943,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d894 1
a894 1
@@@@ -977,13 +965,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d915 1
a915 1
@@@@ -993,13 +987,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d936 1
a936 1
@@@@ -1009,13 +1009,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
@


1.6
log
@More AAC bits and remove the experimental status for the encoder.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.5 2015/10/17 06:49:22 ajacoutot Exp $
d35 4
a38 2
--- libavcodec/aaccoder.c.orig	Sat Dec  5 15:12:49 2015
+++ libavcodec/aaccoder.c	Sat Dec  5 15:07:36 2015
d605 1
a605 1
+            if (g && sce->sf_idx[(w+w2)*16+g-1] == NOISE_BT) {
@


1.5
log
@Guess what... more AAC stuffs.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.4 2015/10/13 05:44:18 ajacoutot Exp $
d25 12
a36 2
--- libavcodec/aaccoder.c.orig	Mon Sep  7 21:58:01 2015
+++ libavcodec/aaccoder.c	Fri Oct 16 23:46:00 2015
d47 5
a51 1
@@@@ -46,20 +48,21 @@@@
d67 1
a67 1
+#define NOISE_SPREAD_THRESHOLD 0.5073f
d82 1
a82 1
@@@@ -121,7 +124,7 @@@@ static void encode_window_bands_info(AACEncContext *s,
d91 1
a91 1
@@@@ -182,138 +185,7 @@@@ static void encode_window_bands_info(AACEncContext *s,
d230 1
a230 1
@@@@ -332,11 +204,11 @@@@ static void set_special_band_scalefactors(AACEncContex
d244 37
a280 1
@@@@ -463,7 +335,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d289 10
a298 1
@@@@ -509,156 +381,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d455 1
a455 1
@@@@ -776,7 +499,7 @@@@ static void search_for_quantizers_faac(AVCodecContext 
d464 1
a464 1
@@@@ -863,92 +586,320 @@@@ static void search_for_quantizers_fast(AVCodecContext 
d475 1
d492 1
d508 1
d559 2
a560 1
+            if (((sce->zeroes[w*16+g] || !sce->band_alt[w*16+g]) && sfb_energy < threshold*sqrtf(1.5f/freq_boost)) || spread < spread_threshold ||
d564 2
d572 9
d613 1
d615 6
a620 4
+        }
+    }
+}
+
d674 2
a675 3
                 }
             }
-            start += sce->ics.swb_sizes[g];
d688 4
a691 4
         }
     }
 }
 
d695 2
a696 1
+    int start = 0, i, w, w2, g, sid_sf_boost;
d705 7
a712 9
+        int min_sf_idx_mid = SCALE_MAX_POS;
+        int min_sf_idx_side = SCALE_MAX_POS;
+        for (g = 0; g < sce0->ics.num_swb; g++) {
+            if (!sce0->zeroes[w*16+g] && sce0->band_type[w*16+g] < RESERVED_BT)
+                min_sf_idx_mid = FFMIN(min_sf_idx_mid, sce0->sf_idx[w*16+g]);
+            if (!sce1->zeroes[w*16+g] && sce1->band_type[w*16+g] < RESERVED_BT)
+                min_sf_idx_side = FFMIN(min_sf_idx_side, sce1->sf_idx[w*16+g]);
+        }
+
d715 2
d719 1
a719 2
             if (!cpe->ch[0].zeroes[w*16+g] && !cpe->ch[1].zeroes[w*16+g]) {
-                float dist1 = 0.0f, dist2 = 0.0f;
d779 5
a783 6
+                    mididx = av_clip(minidx, min_sf_idx_mid, min_sf_idx_mid + SCALE_MAX_DIFF);
+                    sididx = av_clip(minidx - sid_sf_boost * 3, min_sf_idx_side, min_sf_idx_side + SCALE_MAX_DIFF);
+                    midcb = find_min_book(Mmax, mididx);
+                    sidcb = find_min_book(Smax, sididx);
+
+                    if ((mididx > minidx) || (sididx > minidx)) {
d788 3
d842 2
a843 2
+                        /* Setting the M/S mask is useful with I/S, but only the flag */
+                        if (!cpe->is_mask[w*16+g]) {
d856 4
d862 2
a863 1
@@@@ -961,13 +912,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d884 1
a884 1
@@@@ -977,13 +934,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d905 1
a905 1
@@@@ -993,13 +956,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d926 1
a926 1
@@@@ -1009,13 +978,19 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
@


1.4
log
@Some more AAC stuffs.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.3 2015/09/27 06:35:33 ajacoutot Exp $
d23 2
d26 1
a26 1
+++ libavcodec/aaccoder.c	Mon Oct 12 22:04:45 2015
d37 3
a39 1
@@@@ -48,18 +50,18 @@@@
d41 1
d68 1
a68 1
@@@@ -121,7 +123,7 @@@@ static void encode_window_bands_info(AACEncContext *s,
d77 1
a77 1
@@@@ -182,138 +184,7 @@@@ static void encode_window_bands_info(AACEncContext *s,
d216 1
a216 1
@@@@ -332,11 +203,11 @@@@ static void set_special_band_scalefactors(AACEncContex
d230 1
a230 1
@@@@ -463,7 +334,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d239 1
a239 1
@@@@ -509,156 +380,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d396 1
a396 1
@@@@ -776,7 +498,7 @@@@ static void search_for_quantizers_faac(AVCodecContext 
d405 1
a405 1
@@@@ -863,92 +585,320 @@@@ static void search_for_quantizers_fast(AVCodecContext 
d780 2
a781 1
@@@@ -962,11 +912,12 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d784 1
d788 1
d791 2
d797 1
d800 3
a802 1
@@@@ -978,11 +929,12 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d805 1
d809 1
d812 2
d818 1
d821 3
a823 1
@@@@ -994,11 +946,12 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d826 1
d830 1
d833 2
d839 1
d842 3
a844 1
@@@@ -1010,11 +963,12 @@@@ AACCoefficientsEncoder ff_aac_coders[AAC_CODER_NB] = {
d847 1
d851 1
d854 2
d860 1
d863 1
@


1.3
log
@Some more AAC stuffs.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.2 2015/09/23 09:16:45 ajacoutot Exp $
d19 4
d24 12
a35 2
+++ libavcodec/aaccoder.c	Sat Sep 26 13:22:59 2015
@@@@ -48,18 +48,21 @@@@
d39 2
a41 4
+
 /** Frequency in Hz for lower limit of noise substitution **/
-#define NOISE_LOW_LIMIT 4500
+#define NOISE_LOW_LIMIT 4000
d63 10
a72 1
@@@@ -182,138 +185,7 @@@@ static void encode_window_bands_info(AACEncContext *s,
d211 1
a211 1
@@@@ -332,11 +204,11 @@@@ static void set_special_band_scalefactors(AACEncContex
d225 10
a234 1
@@@@ -509,156 +381,7 @@@@ static void search_for_quantizers_anmr(AVCodecContext 
d391 10
a400 1
@@@@ -863,32 +586,78 @@@@ static void search_for_quantizers_fast(AVCodecContext 
d407 2
d412 1
a412 1
     const float freq_mult = avctx->sample_rate/(1024.0f/sce->ics.num_windows)/2.0f;
d415 1
d417 3
a419 1
+    const float spread_threshold = NOISE_SPREAD_THRESHOLD*FFMAX(0.5f, lambda/100.f);
d421 20
a452 8
-                }
-                if (spread > spread_threshold*sce->ics.group_len[w] &&
-                    ((sce->zeroes[w*16+g] && energy >= threshold) ||
-                    energy < threshold*thr_mult*sce->ics.group_len[w])) {
-                    sce->band_type[w*16+g] = NOISE_BT;
-                    sce->pns_ener[w*16+g] = energy / sce->ics.group_len[w];
-                    sce->zeroes[w*16+g] = 0;
-                }
d456 2
a457 1
+            float sfb_energy = 0.0f, threshold = 0.0f, spread = 0.0f;
d461 1
a461 1
+            if (freq < NOISE_LOW_LIMIT || avctx->cutoff && freq >= avctx->cutoff)
d466 1
a466 1
+                spread     += band->spread;
d468 13
a480 2
             }
-            start += sce->ics.swb_sizes[g];
d483 1
a483 1
+            dist_thresh = FFMIN(2.5f*NOISE_LOW_LIMIT/freq, 2.5f);
d485 6
a490 2
+            /* zero and energy close to threshold usually means hole avoidance,
+             * we do want to remain avoiding holes with PNS
d493 2
a494 1
+                (sce->band_alt[w*16+g] && sfb_energy > threshold*thr_mult*freq_boost)) {
d499 1
a499 1
+            pns_tgt_energy = sfb_energy*spread*spread/sce->ics.group_len[w];
d520 8
a527 3
+                                            lambda/band->threshold, INFINITY, NULL, 0);
+                /* Estimate rd on average as 9 bits for CB and sf + spread energy * lambda/thr */
+                dist2 += 9+band->energy/(band->spread*band->spread)*lambda/band->threshold;
d531 1
a531 1
+            if (energy_ratio > 0.85f && energy_ratio < 1.25f && (sce->zeroes[w*16+g] || !sce->band_alt[w*16+g] || dist2*dist_thresh < dist1)) {
d535 72
d610 221
@


1.2
log
@Yet again more AAC encoder fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aaccoder_c,v 1.1 2015/09/12 09:44:54 ajacoutot Exp $
d15 4
d20 1
a20 1
+++ libavcodec/aaccoder.c	Wed Sep 23 03:48:35 2015
d361 1
a361 1
@@@@ -863,32 +586,83 @@@@ static void search_for_quantizers_fast(AVCodecContext 
d375 1
a375 1
+    const float spread_threshold = NOISE_SPREAD_THRESHOLD*(lambda/100.f);
d377 1
a377 3
+    if (sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE)
+        return;
+
d380 1
d389 8
d399 1
a399 1
+            float pns_energy = 0.0f, energy_ratio, dist_thresh;
d401 2
a402 2
+            const int start = sce->ics.swb_offset[w*16+g];
+            const float freq = start*freq_mult;
d411 2
a412 1
+            }
d415 1
a415 1
+            dist_thresh = FFMIN(2.5f*NOISE_LOW_LIMIT/freq, 1.27f);
d417 5
a421 2
+            if (sce->zeroes[w*16+g] || spread < spread_threshold ||
+                sfb_energy > threshold*thr_mult*freq_boost) {
d426 2
a427 1
+            noise_sfi = av_clip(roundf(log2f(sfb_energy)*2), -100, 155); /* Quantize */
d430 2
a431 2
+                float band_energy, scale;
+                const int start_c = sce->ics.swb_offset[(w+w2)*16+g];
d438 2
a439 1
+                pns_energy += s->fdsp->scalarproduct_float(PNS, PNS, sce->ics.swb_sizes[g]);
d448 2
a449 6
+                dist2 += quantize_band_cost(s, PNS,
+                                            PNS34,
+                                            sce->ics.swb_sizes[g],
+                                            noise_sfi,
+                                            NOISE_BT,
+                                            lambda/band->threshold, INFINITY, NULL, 0);
d451 3
a453 3
+            energy_ratio = sfb_energy/pns_energy; /* Compensates for quantization error */
+            sce->pns_ener[w*16+g] = energy_ratio*sfb_energy;
+            if (energy_ratio > 0.85f && energy_ratio < 1.25f && dist1/dist2 > dist_thresh) {
d456 1
a456 14
+                if (sce->band_type[w*16+g-1] != NOISE_BT && /* Prevent holes */
+                    sce->band_type[w*16+g-2] == NOISE_BT) {
+                    sce->band_type[w*16+g-1] = NOISE_BT;
+                    sce->zeroes[w*16+g-1] = 0;
                 }
-                if (spread > spread_threshold*sce->ics.group_len[w] &&
-                    ((sce->zeroes[w*16+g] && energy >= threshold) ||
-                    energy < threshold*thr_mult*sce->ics.group_len[w])) {
-                    sce->band_type[w*16+g] = NOISE_BT;
-                    sce->pns_ener[w*16+g] = energy / sce->ics.group_len[w];
-                    sce->zeroes[w*16+g] = 0;
-                }
             }
-            start += sce->ics.swb_sizes[g];
@


1.1
log
@Back port some AAC encoder fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d13 6
a18 3
--- libavcodec/aaccoder.c.orig	Sat Sep 12 02:11:01 2015
+++ libavcodec/aaccoder.c	Sat Sep 12 02:11:16 2015
@@@@ -49,16 +49,15 @@@@
d21 2
d42 2
d46 141
a186 1
@@@@ -332,11 +331,11 @@@@ static void set_special_band_scalefactors(AACEncContex
d200 158
a357 1
@@@@ -863,32 +862,83 @@@@ static void search_for_quantizers_fast(AVCodecContext 
@

