head	1.19;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_5:1.1.0.2
	OPENBSD_5_5_BASE:1.1;
locks; strict;
comment	@# @;


1.19
date	2016.12.05.09.02.29;	author ajacoutot;	state Exp;
branches;
next	1.18;
commitid	oQI5L2fkLhaPREvJ;

1.18
date	2016.10.17.07.51.00;	author ajacoutot;	state Exp;
branches;
next	1.17;
commitid	Wo4uP395zjJX9ZOv;

1.17
date	2016.09.06.12.37.11;	author ajacoutot;	state Exp;
branches;
next	1.16;
commitid	z3rQhI117DvrHlZm;

1.16
date	2016.05.03.06.05.49;	author ajacoutot;	state Exp;
branches;
next	1.15;
commitid	VfdMmnXKIRQjKU4e;

1.15
date	2016.04.07.06.01.19;	author ajacoutot;	state Exp;
branches;
next	1.14;
commitid	XQzqg9116vhXixw9;

1.14
date	2016.03.09.17.29.36;	author ajacoutot;	state Exp;
branches;
next	1.13;
commitid	TFfaaPvpBDwqcHyX;

1.13
date	2016.02.25.03.53.53;	author ajacoutot;	state Exp;
branches;
next	1.12;
commitid	1k5OP9J3MODxZT4L;

1.12
date	2016.01.22.07.05.01;	author ajacoutot;	state Exp;
branches;
next	1.11;
commitid	QxWiiXgyevTr4Srf;

1.11
date	2016.01.18.15.34.45;	author ajacoutot;	state Exp;
branches;
next	1.10;
commitid	RwM3NoHU9JMWKEgE;

1.10
date	2016.01.14.06.09.43;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	1MTT7RUn5DsgY3tS;

1.9
date	2015.12.10.06.53.38;	author ajacoutot;	state Exp;
branches;
next	1.8;
commitid	syJXIQ2pJKvIoUp8;

1.8
date	2015.12.06.08.51.46;	author ajacoutot;	state Exp;
branches;
next	1.7;
commitid	qmMp5nlfDfTw8ZGw;

1.7
date	2015.10.25.08.46.41;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	SKomGDNtuQfFPemq;

1.6
date	2015.10.17.06.49.22;	author ajacoutot;	state Exp;
branches;
next	1.5;
commitid	qCaTAupMCq4yvb8q;

1.5
date	2015.10.13.05.44.18;	author ajacoutot;	state Exp;
branches;
next	1.4;
commitid	qst9LZIZleMKOm5n;

1.4
date	2015.09.23.09.16.45;	author ajacoutot;	state Exp;
branches;
next	1.3;
commitid	t74suKYQj33NdaVz;

1.3
date	2015.09.12.09.44.54;	author ajacoutot;	state Exp;
branches;
next	1.2;
commitid	2zCvmn8WdgiiJ5l4;

1.2
date	2014.05.16.01.34.50;	author brad;	state dead;
branches;
next	1.1;

1.1
date	2013.08.19.14.38.29;	author brad;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Update to ffmpeg-20161203.

from Brad (maintainer)
@
text
@$OpenBSD: patch-libavcodec_aacenc_c,v 1.18 2016/10/17 07:51:00 ajacoutot Exp $

aacenc: copy PRNG from the decoder

avcodec/aacenc: use AV_OPT_TYPE_BOOL

AAC encoder: tweak rate-distortion logic

AAC encoder: Extensive improvements

AAC encoder: memoize quantize_band_cost

aacenc: add support for encoding 7.1 channel audio

aacenc: add support for changing options based on a profile

aacenc: shorten name of ff_aac_adjust_common_prediction

aacenc: indicate that TNS is off by default

aacenc: slightly simplify and remove a redundant variable

aacenc: correctly zero prediction_used array

aacenc: (re)enable Mid/Side coding by default

aacenc: add support for encoding files using Long Term Prediction

aacenc: partially revert previous commits to set options via a profile

aacenc_tns: enable Temporal Noise Shaping by default

avcodec/aacenc: Fix "libavcodec/aacenc.c:540:13: warning: ISO C90 forbids mixed declarations and code"

AAC encoder: Fix application of M/S with PNS

AAC encoder: improve SF range utilization

aac: Provide more information on the failure message

aacenc: mark the "faac"-like coder for removal

aacenc: mark coders other than twoloop as experimental

aacenc: remove the experimental flag

aacenc: fix aac_pred option triggering an error

aacenc: move the TNS search and filtering before PNS

aacenc: switch to using the RNG from libavutil

AAC encoder: don't apply MS on special bands

acenc: remove deprecated avctx->frame_bits use

avcodec/aacenc: Fix NAN check

avcodec/aacenc: mark output as const as its not written to

avcodec/aacenc: Check for +-Inf too

lavc/aacenc: use isfinite to simplify isnan/isinf logic

aacenc: mark LTP mode as experimental

aacenc: remove FAAC-like coder

avcodec/aacenc: Check all coefficients for finiteness

aacenc: make a better estimate for the audio bitrate if not provided

aacenc: temporarily disable Mid/Side coding with multichannel files

aacenc: use generational cache instead of resetting.

AAC encoder: fix valgrind errors

aacenc: unmark the fast coder as experimental

aacenc: fix various typos and an error message

aacenc: use the decoder's lcg PRNG

aacenc: quit when the audio queue reaches 0 rather than keeping track of empty frames

--- libavcodec/aacenc.c.orig	Sat Aug 27 22:51:29 2016
+++ libavcodec/aacenc.c	Thu Nov 10 19:22:09 2016
@@@@ -29,6 +29,7 @@@@
  * add sane pulse detection
  ***********************************/
 
+#include "libavutil/libm.h"
 #include "libavutil/float_dsp.h"
 #include "libavutil/opt.h"
 #include "avcodec.h"
@@@@ -54,11 +55,12 @@@@ static void put_audio_specific_config(AVCodecContext *
 {
     PutBitContext pb;
     AACEncContext *s = avctx->priv_data;
+    int channels = s->channels - (s->channels == 8 ? 1 : 0);
 
     init_put_bits(&pb, avctx->extradata, avctx->extradata_size);
     put_bits(&pb, 5, s->profile+1); //profile
     put_bits(&pb, 4, s->samplerate_index); //sample rate index
-    put_bits(&pb, 4, s->channels);
+    put_bits(&pb, 4, channels);
     //GASpecificConfig
     put_bits(&pb, 1, 0); //frame length - 1024 samples
     put_bits(&pb, 1, 0); //does not depend on core coder
@@@@ -71,6 +73,15 @@@@ static void put_audio_specific_config(AVCodecContext *
     flush_put_bits(&pb);
 }
 
+void ff_quantize_band_cost_cache_init(struct AACEncContext *s)
+{
+    ++s->quantize_band_cost_cache_generation;
+    if (s->quantize_band_cost_cache_generation == 0) {
+        memset(s->quantize_band_cost_cache, 0, sizeof(s->quantize_band_cost_cache));
+        s->quantize_band_cost_cache_generation = 1;
+    }
+}
+
 #define WINDOW_FUNC(type) \
 static void apply_ ##type ##_window(AVFloatDSPContext *fdsp, \
                                     SingleChannelElement *sce, \
@@@@ -140,7 +151,7 @@@@ static void apply_window_and_mdct(AACEncContext *s, Si
                                   float *audio)
 {
     int i;
-    float *output = sce->ret_buf;
+    const float *output = sce->ret_buf;
 
     apply_window[sce->ics.window_sequence[0]](s->fdsp, sce, audio);
 
@@@@ -258,6 +269,8 @@@@ static void apply_intensity_stereo(ChannelElement *cpe
                     start += ics->swb_sizes[g];
                     continue;
                 }
+                if (cpe->ms_mask[w*16 + g])
+                    p *= -1;
                 for (i = 0; i < ics->swb_sizes[g]; i++) {
                     float sum = (cpe->ch[0].coeffs[start+i] + p*cpe->ch[1].coeffs[start+i])*scale;
                     cpe->ch[0].coeffs[start+i] = sum;
@@@@ -279,7 +292,13 @@@@ static void apply_mid_side_stereo(ChannelElement *cpe)
         for (w2 =  0; w2 < ics->group_len[w]; w2++) {
             int start = (w+w2) * 128;
             for (g = 0; g < ics->num_swb; g++) {
-                if (!cpe->ms_mask[w*16 + g]) {
+                /* ms_mask can be used for other purposes in PNS and I/S,
+                 * so must not apply M/S if any band uses either, even if
+                 * ms_mask is set.
+                 */
+                if (!cpe->ms_mask[w*16 + g] || cpe->is_mask[w*16 + g]
+                    || cpe->ch[0].band_type[w*16 + g] >= NOISE_BT
+                    || cpe->ch[1].band_type[w*16 + g] >= NOISE_BT) {
                     start += ics->swb_sizes[g];
                     continue;
                 }
@@@@ -424,6 +443,8 @@@@ static int encode_individual_channel(AVCodecContext *a
         put_ics_info(s, &sce->ics);
         if (s->coder->encode_main_pred)
             s->coder->encode_main_pred(s, sce);
+        if (s->coder->encode_ltp_info)
+            s->coder->encode_ltp_info(s, sce, 0);
     }
     encode_band_info(s, sce);
     encode_scale_factors(avctx, s, sce);
@@@@ -489,19 +510,21 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
     float **samples = s->planar_samples, *samples2, *la, *overlap;
     ChannelElement *cpe;
     SingleChannelElement *sce;
-    int i, ch, w, chans, tag, start_ch, ret;
+    IndividualChannelStream *ics;
+    int i, its, ch, w, chans, tag, start_ch, ret, frame_bits;
+    int target_bits, rate_bits, too_many_bits, too_few_bits;
     int ms_mode = 0, is_mode = 0, tns_mode = 0, pred_mode = 0;
     int chan_el_counter[4];
     FFPsyWindowInfo windows[AAC_MAX_CHANNELS];
     int k;
 
-    if (s->last_frame == 2)
-        return 0;
-
     /* add current frame to queue */
     if (frame) {
         if ((ret = ff_af_queue_add(&s->afq, frame)) < 0)
             return ret;
+    } else {
+        if (!s->afq.remaining_samples || (!s->afq.frame_alloc && !s->afq.frame_count))
+            return 0;
     }
 
     copy_input_samples(s, frame);
@@@@ -518,19 +541,22 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
         chans    = tag == TYPE_CPE ? 2 : 1;
         cpe      = &s->cpe[i];
         for (ch = 0; ch < chans; ch++) {
-            IndividualChannelStream *ics = &cpe->ch[ch].ics;
-            int cur_channel = start_ch + ch;
+            int k;
             float clip_avoidance_factor;
-            overlap  = &samples[cur_channel][0];
+            sce = &cpe->ch[ch];
+            ics = &sce->ics;
+            s->cur_channel = start_ch + ch;
+            overlap  = &samples[s->cur_channel][0];
             samples2 = overlap + 1024;
             la       = samples2 + (448+64);
             if (!frame)
                 la = NULL;
             if (tag == TYPE_LFE) {
-                wi[ch].window_type[0] = ONLY_LONG_SEQUENCE;
+                wi[ch].window_type[0] = wi[ch].window_type[1] = ONLY_LONG_SEQUENCE;
                 wi[ch].window_shape   = 0;
                 wi[ch].num_windows    = 1;
                 wi[ch].grouping[0]    = 1;
+                wi[ch].clipping[0]    = 0;
 
                 /* Only the lowest 12 coefficients are used in a LFE channel.
                  * The expression below results in only the bottom 8 coefficients
@@@@ -538,7 +564,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
                  */
                 ics->num_swb = s->samplerate_index >= 8 ? 1 : 3;
             } else {
-                wi[ch] = s->psy.model->window(&s->psy, samples2, la, cur_channel,
+                wi[ch] = s->psy.model->window(&s->psy, samples2, la, s->cur_channel,
                                               ics->window_sequence[0]);
             }
             ics->window_sequence[1] = ics->window_sequence[0];
@@@@ -555,10 +581,23 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
             ics->tns_max_bands      = wi[ch].window_type[0] == EIGHT_SHORT_SEQUENCE ?
                                         ff_tns_max_bands_128 [s->samplerate_index]:
                                         ff_tns_max_bands_1024[s->samplerate_index];
-            clip_avoidance_factor = 0.0f;
+
             for (w = 0; w < ics->num_windows; w++)
                 ics->group_len[w] = wi[ch].grouping[w];
+
+            /* Calculate input sample maximums and evaluate clipping risk */
+            clip_avoidance_factor = 0.0f;
             for (w = 0; w < ics->num_windows; w++) {
+                const float *wbuf = overlap + w * 128;
+                const int wlen = 2048 / ics->num_windows;
+                float max = 0;
+                int j;
+                /* mdct input is 2 * output */
+                for (j = 0; j < wlen; j++)
+                    max = FFMAX(max, fabsf(wbuf[j]));
+                wi[ch].clipping[w] = max;
+            }
+            for (w = 0; w < ics->num_windows; w++) {
                 if (wi[ch].clipping[w] > CLIP_AVOIDANCE_FACTOR) {
                     ics->window_clipping[w] = 1;
                     clip_avoidance_factor = FFMAX(clip_avoidance_factor, wi[ch].clipping[w]);
@@@@ -610,15 +649,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
                 sce = &cpe->ch[ch];
                 coeffs[ch] = sce->coeffs;
                 sce->ics.predictor_present = 0;
-                memset(&sce->ics.prediction_used, 0, sizeof(sce->ics.prediction_used));
+                sce->ics.ltp.present = 0;
+                memset(sce->ics.ltp.used, 0, sizeof(sce->ics.ltp.used));
+                memset(sce->ics.prediction_used, 0, sizeof(sce->ics.prediction_used));
                 memset(&sce->tns, 0, sizeof(TemporalNoiseShaping));
                 for (w = 0; w < 128; w++)
                     if (sce->band_type[w] > RESERVED_BT)
                         sce->band_type[w] = 0;
             }
+            s->psy.bitres.alloc = -1;
+            s->psy.bitres.bits = s->last_frame_pb_count / s->channels;
             s->psy.model->analyze(&s->psy, start_ch, coeffs, wi);
+            if (s->psy.bitres.alloc > 0) {
+                /* Lambda unused here on purpose, we need to take psy's unscaled allocation */
+                target_bits += s->psy.bitres.alloc
+                    * (s->lambda / (avctx->global_quality ? avctx->global_quality : 120));
+                s->psy.bitres.alloc /= chans;
+            }
+            s->cur_type = tag;
             for (ch = 0; ch < chans; ch++) {
                 s->cur_channel = start_ch + ch;
+                if (s->options.pns && s->coder->mark_pns)
+                    s->coder->mark_pns(s, avctx, &cpe->ch[ch]);
                 s->coder->search_for_quantizers(avctx, s, &cpe->ch[ch], s->lambda);
             }
             if (chans > 1
@@@@ -636,14 +688,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
             for (ch = 0; ch < chans; ch++) { /* TNS and PNS */
                 sce = &cpe->ch[ch];
                 s->cur_channel = start_ch + ch;
-                if (s->options.pns && s->coder->search_for_pns)
-                    s->coder->search_for_pns(s, avctx, sce);
                 if (s->options.tns && s->coder->search_for_tns)
                     s->coder->search_for_tns(s, sce);
                 if (s->options.tns && s->coder->apply_tns_filt)
                     s->coder->apply_tns_filt(s, sce);
                 if (sce->tns.present)
                     tns_mode = 1;
+                if (s->options.pns && s->coder->search_for_pns)
+                    s->coder->search_for_pns(s, avctx, sce);
             }
             s->cur_channel = start_ch;
             if (s->options.intensity_stereo) { /* Intensity Stereo */
@@@@ -660,8 +712,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
                         s->coder->search_for_pred(s, sce);
                     if (cpe->ch[ch].ics.predictor_present) pred_mode = 1;
                 }
-                if (s->coder->adjust_common_prediction)
-                    s->coder->adjust_common_prediction(s, cpe);
+                if (s->coder->adjust_common_pred)
+                    s->coder->adjust_common_pred(s, cpe);
                 for (ch = 0; ch < chans; ch++) {
                     sce = &cpe->ch[ch];
                     s->cur_channel = start_ch + ch;
@@@@ -670,22 +722,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
                 }
                 s->cur_channel = start_ch;
             }
-            if (s->options.stereo_mode) { /* Mid/Side stereo */
-                if (s->options.stereo_mode == -1 && s->coder->search_for_ms)
+            if (s->options.mid_side) { /* Mid/Side stereo */
+                if (s->options.mid_side == -1 && s->coder->search_for_ms)
                     s->coder->search_for_ms(s, cpe);
                 else if (cpe->common_window)
                     memset(cpe->ms_mask, 1, sizeof(cpe->ms_mask));
-                for (w = 0; w < 128; w++)
-                    cpe->ms_mask[w] = cpe->is_mask[w] ? 0 : cpe->ms_mask[w];
                 apply_mid_side_stereo(cpe);
             }
             adjust_frame_information(cpe, chans);
+            if (s->options.ltp) { /* LTP */
+                for (ch = 0; ch < chans; ch++) {
+                    sce = &cpe->ch[ch];
+                    s->cur_channel = start_ch + ch;
+                    if (s->coder->search_for_ltp)
+                        s->coder->search_for_ltp(s, sce, cpe->common_window);
+                    if (sce->ics.ltp.present) pred_mode = 1;
+                }
+                s->cur_channel = start_ch;
+                if (s->coder->adjust_common_ltp)
+                    s->coder->adjust_common_ltp(s, cpe);
+            }
             if (chans == 2) {
                 put_bits(&s->pb, 1, cpe->common_window);
                 if (cpe->common_window) {
                     put_ics_info(s, &cpe->ch[0].ics);
                     if (s->coder->encode_main_pred)
                         s->coder->encode_main_pred(s, &cpe->ch[0]);
+                    if (s->coder->encode_ltp_info)
+                        s->coder->encode_ltp_info(s, &cpe->ch[0], 1);
                     encode_ms_info(&s->pb, cpe);
                     if (cpe->ms_mode) ms_mode = 1;
                 }
@@@@ -697,38 +761,77 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
             start_ch += chans;
         }
 
-        frame_bits = put_bits_count(&s->pb);
-        if (frame_bits <= 6144 * s->channels - 3) {
-            s->psy.bitres.bits = frame_bits / s->channels;
+        if (avctx->flags & CODEC_FLAG_QSCALE) {
+            /* When using a constant Q-scale, don't mess with lambda */
             break;
         }
-        if (is_mode || ms_mode || tns_mode || pred_mode) {
-            for (i = 0; i < s->chan_map[0]; i++) {
-                // Must restore coeffs
-                chans = tag == TYPE_CPE ? 2 : 1;
-                cpe = &s->cpe[i];
-                for (ch = 0; ch < chans; ch++)
-                    memcpy(cpe->ch[ch].coeffs, cpe->ch[ch].pcoeffs, sizeof(cpe->ch[ch].coeffs));
-            }
-        }
 
-        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;
+        /* rate control stuff
+         * allow between the nominal bitrate, and what psy's bit reservoir says to target
+         * but drift towards the nominal bitrate always
+         */
+        frame_bits = put_bits_count(&s->pb);
+        rate_bits = avctx->bit_rate * 1024 / avctx->sample_rate;
+        rate_bits = FFMIN(rate_bits, 6144 * s->channels - 3);
+        too_many_bits = FFMAX(target_bits, rate_bits);
+        too_many_bits = FFMIN(too_many_bits, 6144 * s->channels - 3);
+        too_few_bits = FFMIN(FFMAX(rate_bits - rate_bits/4, target_bits), too_many_bits);
 
+        /* When using ABR, be strict (but only for increasing) */
+        too_few_bits = too_few_bits - too_few_bits/8;
+        too_many_bits = too_many_bits + too_many_bits/2;
+
+        if (   its == 0 /* for steady-state Q-scale tracking */
+            || (its < 5 && (frame_bits < too_few_bits || frame_bits > too_many_bits))
+            || frame_bits >= 6144 * s->channels - 3  )
+        {
+            float ratio = ((float)rate_bits) / frame_bits;
+
+            if (frame_bits >= too_few_bits && frame_bits <= too_many_bits) {
+                /*
+                 * This path is for steady-state Q-scale tracking
+                 * When frame bits fall within the stable range, we still need to adjust
+                 * lambda to maintain it like so in a stable fashion (large jumps in lambda
+                 * create artifacts and should be avoided), but slowly
+                 */
+                ratio = sqrtf(sqrtf(ratio));
+                ratio = av_clipf(ratio, 0.9f, 1.1f);
+            } else {
+                /* Not so fast though */
+                ratio = sqrtf(ratio);
+            }
+            s->lambda = FFMIN(s->lambda * ratio, 65536.f);
+
+            /* Keep iterating if we must reduce and lambda is in the sky */
+            if (ratio > 0.9f && ratio < 1.1f) {
+                break;
+            } else {
+                if (is_mode || ms_mode || tns_mode || pred_mode) {
+                    for (i = 0; i < s->chan_map[0]; i++) {
+                        // Must restore coeffs
+                        chans = tag == TYPE_CPE ? 2 : 1;
+                        cpe = &s->cpe[i];
+                        for (ch = 0; ch < chans; ch++)
+                            memcpy(cpe->ch[ch].coeffs, cpe->ch[ch].pcoeffs, sizeof(cpe->ch[ch].coeffs));
+                    }
+                }
+                its++;
+            }
+        } else {
+            break;
+        }
     } while (1);
 
+    if (s->options.ltp && s->coder->ltp_insert_new_frame)
+        s->coder->ltp_insert_new_frame(s);
+
     put_bits(&s->pb, 3, TYPE_END);
     flush_put_bits(&s->pb);
-    avctx->frame_bits = put_bits_count(&s->pb);
 
-    // rate control stuff
-    if (!(avctx->flags & AV_CODEC_FLAG_QSCALE)) {
-        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;
-        s->lambda *= ratio;
-        s->lambda = FFMIN(s->lambda, 65536.f);
-    }
+    s->last_frame_pb_count = put_bits_count(&s->pb);
 
-    if (!frame)
-        s->last_frame++;
+    s->lambda_sum += s->lambda;
+    s->lambda_count++;
 
     ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,
                        &avpkt->duration);
@@@@ -742,6 +845,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
 {
     AACEncContext *s = avctx->priv_data;
 
+    av_log(avctx, AV_LOG_INFO, "Qavg: %.3f\n", s->lambda_sum / s->lambda_count);
+
     ff_mdct_end(&s->mdct1024);
     ff_mdct_end(&s->mdct128);
     ff_psy_end(&s->psy);
@@@@ -800,76 +905,123 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
     uint8_t grouping[AAC_MAX_CHANNELS];
     int lengths[2];
 
+    /* Constants */
+    s->last_frame_pb_count = 0;
+    avctx->extradata_size = 5;
     avctx->frame_size = 1024;
+    avctx->initial_padding = 1024;
+    s->lambda = avctx->global_quality > 0 ? avctx->global_quality : 120;
 
+    /* Channel map and unspecified bitrate guessing */
+    s->channels = avctx->channels;
+    ERROR_IF(s->channels > AAC_MAX_CHANNELS || s->channels == 7,
+             "Unsupported number of channels: %d\n", s->channels);
+    s->chan_map = aac_chan_configs[s->channels-1];
+    if (!avctx->bit_rate) {
+        for (i = 1; i <= s->chan_map[0]; i++) {
+            avctx->bit_rate += s->chan_map[i] == TYPE_CPE ? 128000 : /* Pair */
+                               s->chan_map[i] == TYPE_LFE ? 16000  : /* LFE  */
+                                                            69000  ; /* SCE  */
+        }
+    }
+ 
+    /* Samplerate */
     for (i = 0; i < 16; i++)
         if (avctx->sample_rate == avpriv_mpeg4audio_sample_rates[i])
             break;
-
-    s->channels = avctx->channels;
-
-    ERROR_IF(i == 16 || i >= ff_aac_swb_size_1024_len || i >= ff_aac_swb_size_128_len,
+    s->samplerate_index = i;
+    ERROR_IF(s->samplerate_index == 16 ||
+             s->samplerate_index >= ff_aac_swb_size_1024_len ||
+             s->samplerate_index >= ff_aac_swb_size_128_len,
              "Unsupported sample rate %d\n", avctx->sample_rate);
-    ERROR_IF(s->channels > AAC_MAX_CHANNELS,
-             "Unsupported number of channels: %d\n", s->channels);
+
+    /* Bitrate limiting */
     WARN_IF(1024.0 * avctx->bit_rate / avctx->sample_rate > 6144 * s->channels,
-             "Too many bits per frame requested, clamping to max\n");
-    if (avctx->profile == FF_PROFILE_AAC_MAIN) {
+             "Too many bits %f > %d per frame requested, clamping to max\n",
+             1024.0 * avctx->bit_rate / avctx->sample_rate,
+             6144 * s->channels);
+    avctx->bit_rate = (int64_t)FFMIN(6144 * s->channels / 1024.0 * avctx->sample_rate,
+                                     avctx->bit_rate);
+ 
+    /* Profile and option setting */
+    avctx->profile = avctx->profile == FF_PROFILE_UNKNOWN ? FF_PROFILE_AAC_LOW :
+                     avctx->profile;
+    for (i = 0; i < FF_ARRAY_ELEMS(aacenc_profiles); i++)
+        if (avctx->profile == aacenc_profiles[i])
+            break;
+    if (avctx->profile == FF_PROFILE_MPEG2_AAC_LOW) {
+        avctx->profile = FF_PROFILE_AAC_LOW;
+        ERROR_IF(s->options.pred,
+                 "Main prediction unavailable in the \"mpeg2_aac_low\" profile\n");
+        ERROR_IF(s->options.ltp,
+                 "LTP prediction unavailable in the \"mpeg2_aac_low\" profile\n");
+        WARN_IF(s->options.pns,
+                "PNS unavailable in the \"mpeg2_aac_low\" profile, turning off\n");
+        s->options.pns = 0;
+    } else if (avctx->profile == FF_PROFILE_AAC_LTP) {
+        s->options.ltp = 1;
+        ERROR_IF(s->options.pred,
+                 "Main prediction unavailable in the \"aac_ltp\" profile\n");
+    } else if (avctx->profile == FF_PROFILE_AAC_MAIN) {
         s->options.pred = 1;
-    } else if ((avctx->profile == FF_PROFILE_AAC_LOW ||
-                avctx->profile == FF_PROFILE_UNKNOWN) && s->options.pred) {
-        s->profile = 0; /* Main */
-        WARN_IF(1, "Prediction requested, changing profile to AAC-Main\n");
-    } else if (avctx->profile == FF_PROFILE_AAC_LOW ||
-               avctx->profile == FF_PROFILE_UNKNOWN) {
-        s->profile = 1; /* Low */
-    } else {
-        ERROR_IF(1, "Unsupported profile %d\n", avctx->profile);
+        ERROR_IF(s->options.ltp,
+                 "LTP prediction unavailable in the \"aac_main\" profile\n");
+    } else if (s->options.ltp) {
+        avctx->profile = FF_PROFILE_AAC_LTP;
+        WARN_IF(1,
+                "Chainging profile to \"aac_ltp\"\n");
+        ERROR_IF(s->options.pred,
+                 "Main prediction unavailable in the \"aac_ltp\" profile\n");
+    } else if (s->options.pred) {
+        avctx->profile = FF_PROFILE_AAC_MAIN;
+        WARN_IF(1,
+                "Chainging profile to \"aac_main\"\n");
+        ERROR_IF(s->options.ltp,
+                 "LTP prediction unavailable in the \"aac_main\" profile\n");
     }
+    s->profile = avctx->profile;
 
-    if (s->options.aac_coder != AAC_CODER_TWOLOOP) {
+    /* Coder limitations */
+    s->coder = &ff_aac_coders[s->options.coder];
+    if (s->options.coder == AAC_CODER_ANMR) {
+        ERROR_IF(avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL,
+                 "The ANMR coder is considered experimental, add -strict -2 to enable!\n");
         s->options.intensity_stereo = 0;
         s->options.pns = 0;
     }
+    ERROR_IF(s->options.ltp && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL,
+             "The LPT profile requires experimental compliance, add -strict -2 to enable!\n");
 
-    avctx->bit_rate = (int)FFMIN(
-        6144 * s->channels / 1024.0 * avctx->sample_rate,
-        avctx->bit_rate);
+    /* M/S introduces horrible artifacts with multichannel files, this is temporary */
+    if (s->channels > 3)
+        s->options.mid_side = 0;
 
-    s->samplerate_index = i;
-
-    s->chan_map = aac_chan_configs[s->channels-1];
-
     if ((ret = dsp_init(avctx, s)) < 0)
         goto fail;
 
     if ((ret = alloc_buffers(avctx, s)) < 0)
         goto fail;
 
-    avctx->extradata_size = 5;
     put_audio_specific_config(avctx);
 
-    sizes[0]   = ff_aac_swb_size_1024[i];
-    sizes[1]   = ff_aac_swb_size_128[i];
-    lengths[0] = ff_aac_num_swb_1024[i];
-    lengths[1] = ff_aac_num_swb_128[i];
+    sizes[0]   = ff_aac_swb_size_1024[s->samplerate_index];
+    sizes[1]   = ff_aac_swb_size_128[s->samplerate_index];
+    lengths[0] = ff_aac_num_swb_1024[s->samplerate_index];
+    lengths[1] = ff_aac_num_swb_128[s->samplerate_index];
     for (i = 0; i < s->chan_map[0]; i++)
         grouping[i] = s->chan_map[i + 1] == TYPE_CPE;
     if ((ret = ff_psy_init(&s->psy, avctx, 2, sizes, lengths,
                            s->chan_map[0], grouping)) < 0)
         goto fail;
     s->psypp = ff_psy_preprocess_init(avctx);
-    s->coder = &ff_aac_coders[s->options.aac_coder];
     ff_lpc_init(&s->lpc, 2*avctx->frame_size, TNS_MAX_ORDER, FF_LPC_TYPE_LEVINSON);
+    s->random_state = 0x1f2e3d4c;
 
     if (HAVE_MIPSDSPR1)
         ff_aac_coder_init_mips(s);
 
-    s->lambda = avctx->global_quality > 0 ? avctx->global_quality : 120;
-
     ff_aac_tableinit();
 
-    avctx->initial_padding = 1024;
     ff_af_queue_init(avctx, &s->afq);
 
     return 0;
@@@@ -880,27 +1032,16 @@@@ fail:
 
 #define AACENC_FLAGS AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_AUDIO_PARAM
 static const AVOption aacenc_options[] = {
-    {"stereo_mode", "Stereo coding method", offsetof(AACEncContext, options.stereo_mode), AV_OPT_TYPE_INT, {.i64 = 0}, -1, 1, AACENC_FLAGS, "stereo_mode"},
-        {"auto",     "Selected by the Encoder", 0, AV_OPT_TYPE_CONST, {.i64 = -1 }, INT_MIN, INT_MAX, AACENC_FLAGS, "stereo_mode"},
-        {"ms_off",   "Disable Mid/Side coding", 0, AV_OPT_TYPE_CONST, {.i64 =  0 }, INT_MIN, INT_MAX, AACENC_FLAGS, "stereo_mode"},
-        {"ms_force", "Force Mid/Side for the whole frame if possible", 0, AV_OPT_TYPE_CONST, {.i64 =  1 }, INT_MIN, INT_MAX, AACENC_FLAGS, "stereo_mode"},
-    {"aac_coder", "Coding algorithm", offsetof(AACEncContext, options.aac_coder), AV_OPT_TYPE_INT, {.i64 = AAC_CODER_TWOLOOP}, 0, AAC_CODER_NB-1, AACENC_FLAGS, "aac_coder"},
-        {"faac",     "FAAC-inspired method",      0, AV_OPT_TYPE_CONST, {.i64 = AAC_CODER_FAAC},    INT_MIN, INT_MAX, AACENC_FLAGS, "aac_coder"},
-        {"anmr",     "ANMR method",               0, AV_OPT_TYPE_CONST, {.i64 = AAC_CODER_ANMR},    INT_MIN, INT_MAX, AACENC_FLAGS, "aac_coder"},
-        {"twoloop",  "Two loop searching method", 0, AV_OPT_TYPE_CONST, {.i64 = AAC_CODER_TWOLOOP}, INT_MIN, INT_MAX, AACENC_FLAGS, "aac_coder"},
-        {"fast",     "Constant quantizer",        0, AV_OPT_TYPE_CONST, {.i64 = AAC_CODER_FAST},    INT_MIN, INT_MAX, AACENC_FLAGS, "aac_coder"},
-    {"aac_pns", "Perceptual Noise Substitution", offsetof(AACEncContext, options.pns), AV_OPT_TYPE_INT, {.i64 = 1}, 0, 1, AACENC_FLAGS, "aac_pns"},
-        {"disable",  "Disable perceptual noise substitution", 0, AV_OPT_TYPE_CONST, {.i64 =  0 }, INT_MIN, INT_MAX, AACENC_FLAGS, "aac_pns"},
-        {"enable",   "Enable perceptual noise substitution",  0, AV_OPT_TYPE_CONST, {.i64 =  1 }, INT_MIN, INT_MAX, AACENC_FLAGS, "aac_pns"},
-    {"aac_is", "Intensity stereo coding", offsetof(AACEncContext, options.intensity_stereo), AV_OPT_TYPE_INT, {.i64 = 1}, 0, 1, AACENC_FLAGS, "intensity_stereo"},
-        {"disable",  "Disable intensity stereo coding", 0, AV_OPT_TYPE_CONST, {.i64 = 0}, INT_MIN, INT_MAX, AACENC_FLAGS, "intensity_stereo"},
-        {"enable",   "Enable intensity stereo coding", 0, AV_OPT_TYPE_CONST, {.i64 = 1}, INT_MIN, INT_MAX, AACENC_FLAGS, "intensity_stereo"},
-    {"aac_tns", "Temporal noise shaping", offsetof(AACEncContext, options.tns), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, AACENC_FLAGS, "aac_tns"},
-        {"disable",  "Disable temporal noise shaping", 0, AV_OPT_TYPE_CONST, {.i64 = 0}, INT_MIN, INT_MAX, AACENC_FLAGS, "aac_tns"},
-        {"enable",   "Enable temporal noise shaping", 0, AV_OPT_TYPE_CONST, {.i64 = 1}, INT_MIN, INT_MAX, AACENC_FLAGS, "aac_tns"},
-    {"aac_pred", "AAC-Main prediction", offsetof(AACEncContext, options.pred), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, AACENC_FLAGS, "aac_pred"},
-        {"disable",  "Disable AAC-Main prediction", 0, AV_OPT_TYPE_CONST, {.i64 = 0}, INT_MIN, INT_MAX, AACENC_FLAGS, "aac_pred"},
-        {"enable",   "Enable AAC-Main prediction", 0, AV_OPT_TYPE_CONST, {.i64 = 1}, INT_MIN, INT_MAX, AACENC_FLAGS, "aac_pred"},
+    {"aac_coder", "Coding algorithm", offsetof(AACEncContext, options.coder), AV_OPT_TYPE_INT, {.i64 = AAC_CODER_TWOLOOP}, 0, AAC_CODER_NB-1, AACENC_FLAGS, "coder"},
+        {"anmr",     "ANMR method",               0, AV_OPT_TYPE_CONST, {.i64 = AAC_CODER_ANMR},    INT_MIN, INT_MAX, AACENC_FLAGS, "coder"},
+        {"twoloop",  "Two loop searching method", 0, AV_OPT_TYPE_CONST, {.i64 = AAC_CODER_TWOLOOP}, INT_MIN, INT_MAX, AACENC_FLAGS, "coder"},
+        {"fast",     "Constant quantizer",        0, AV_OPT_TYPE_CONST, {.i64 = AAC_CODER_FAST},    INT_MIN, INT_MAX, AACENC_FLAGS, "coder"},
+    {"aac_ms", "Force M/S stereo coding", offsetof(AACEncContext, options.mid_side), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AACENC_FLAGS},
+    {"aac_is", "Intensity stereo coding", offsetof(AACEncContext, options.intensity_stereo), AV_OPT_TYPE_BOOL, {.i64 = 1}, -1, 1, AACENC_FLAGS},
+    {"aac_pns", "Perceptual noise substitution", offsetof(AACEncContext, options.pns), AV_OPT_TYPE_BOOL, {.i64 = 1}, -1, 1, AACENC_FLAGS},
+    {"aac_tns", "Temporal noise shaping", offsetof(AACEncContext, options.tns), AV_OPT_TYPE_BOOL, {.i64 = 1}, -1, 1, AACENC_FLAGS},
+    {"aac_ltp", "Long term prediction", offsetof(AACEncContext, options.ltp), AV_OPT_TYPE_BOOL, {.i64 = 0}, -1, 1, AACENC_FLAGS},
+    {"aac_pred", "AAC-Main prediction", offsetof(AACEncContext, options.pred), AV_OPT_TYPE_BOOL, {.i64 = 0}, -1, 1, AACENC_FLAGS},
     {NULL}
 };
 
@@@@ -911,6 +1052,11 @@@@ static const AVClass aacenc_class = {
     LIBAVUTIL_VERSION_INT,
 };
 
+static const AVCodecDefault aac_encode_defaults[] = {
+    { "b", "0" },
+    { NULL }
+};
+
 AVCodec ff_aac_encoder = {
     .name           = "aac",
     .long_name      = NULL_IF_CONFIG_SMALL("AAC (Advanced Audio Coding)"),
@@@@ -920,9 +1066,9 @@@@ AVCodec ff_aac_encoder = {
     .init           = aac_encode_init,
     .encode2        = aac_encode_frame,
     .close          = aac_encode_end,
+    .defaults       = aac_encode_defaults,
     .supported_samplerates = mpeg4audio_sample_rates,
-    .capabilities   = AV_CODEC_CAP_SMALL_LAST_FRAME | AV_CODEC_CAP_DELAY |
-                      AV_CODEC_CAP_EXPERIMENTAL,
+    .capabilities   = AV_CODEC_CAP_SMALL_LAST_FRAME | AV_CODEC_CAP_DELAY,
     .sample_fmts    = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLTP,
                                                      AV_SAMPLE_FMT_NONE },
     .priv_class     = &aacenc_class,
@


1.18
log
@Some more AAC fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.17 2016/09/06 12:37:11 ajacoutot Exp $
d85 2
d88 1
a88 1
+++ libavcodec/aacenc.c	Sat Oct 15 18:50:01 2016
d169 1
a169 1
@@@@ -489,7 +510,9 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d180 15
d353 1
a353 1
@@@@ -697,36 +761,78 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d446 2
a449 3
+
     if (!frame)
         s->last_frame++;
d451 3
a453 1
@@@@ -742,6 +848,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d462 1
a462 1
@@@@ -800,76 +908,123 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d620 1
a620 1
@@@@ -880,27 +1035,16 @@@@ fail:
d658 1
a658 1
@@@@ -911,6 +1055,11 @@@@ static const AVClass aacenc_class = {
d670 1
a670 1
@@@@ -920,9 +1069,9 @@@@ AVCodec ff_aac_encoder = {
@


1.17
log
@Update to ffmpeg-20160903.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.16 2016/05/03 06:05:49 ajacoutot Exp $
d83 2
d86 1
a86 1
+++ libavcodec/aacenc.c	Sat Aug 27 22:55:40 2016
d589 1
a589 1
+    av_lfg_init(&s->lfg, 0x72adca55);
@


1.16
log
@Update to a newer snapshot: ffmpeg-20160502.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.15 2016/04/07 06:01:19 ajacoutot Exp $
d79 6
a84 2
--- libavcodec/aacenc.c.orig	Wed Apr 27 00:56:50 2016
+++ libavcodec/aacenc.c	Wed Apr 27 01:24:53 2016
d176 1
a176 1
@@@@ -517,19 +540,22 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d203 1
a203 1
@@@@ -537,7 +563,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d212 1
a212 1
@@@@ -554,10 +580,23 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d237 1
a237 50
@@@@ -571,33 +610,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
                 ics->clip_avoidance_factor = 1.0f;
             }
 
-            apply_window_and_mdct(s, &cpe->ch[ch], overlap);
+            apply_window_and_mdct(s, sce, overlap);
 
-            if (isnan(cpe->ch[ch].coeffs[    0]) || isinf(cpe->ch[ch].coeffs[    0]) ||
-                isnan(cpe->ch[ch].coeffs[  128]) || isinf(cpe->ch[ch].coeffs[  128]) ||
-                isnan(cpe->ch[ch].coeffs[2*128]) || isinf(cpe->ch[ch].coeffs[2*128]) ||
-                isnan(cpe->ch[ch].coeffs[3*128]) || isinf(cpe->ch[ch].coeffs[3*128]) ||
-                isnan(cpe->ch[ch].coeffs[4*128]) || isinf(cpe->ch[ch].coeffs[4*128]) ||
-                isnan(cpe->ch[ch].coeffs[5*128]) || isinf(cpe->ch[ch].coeffs[5*128]) ||
-                isnan(cpe->ch[ch].coeffs[6*128]) || isinf(cpe->ch[ch].coeffs[6*128]) ||
-                isnan(cpe->ch[ch].coeffs[7*128]) || isinf(cpe->ch[ch].coeffs[7*128])) {
-                av_log(avctx, AV_LOG_ERROR, "Input contains NaN/+-Inf\n");
-                return AVERROR(EINVAL);
+            if (s->options.ltp && s->coder->update_ltp) {
+                s->coder->update_ltp(s, sce);
+                apply_window[sce->ics.window_sequence[0]](s->fdsp, sce, &sce->ltp_state[0]);
+                s->mdct1024.mdct_calc(&s->mdct1024, sce->lcoeffs, sce->ret_buf);
             }
-            avoid_clipping(s, &cpe->ch[ch]);
+
+            for (k = 0; k < 1024; k++) {
+                if (!isfinite(cpe->ch[ch].coeffs[k])) {
+                    av_log(avctx, AV_LOG_ERROR, "Input contains NaN/+-Inf\n");
+                    return AVERROR(EINVAL);
+                }
+            }
+            avoid_clipping(s, sce);
         }
         start_ch += chans;
     }
     if ((ret = ff_alloc_packet2(avctx, avpkt, 8192 * s->channels, 0)) < 0)
         return ret;
+    frame_bits = its = 0;
     do {
-        int frame_bits;
-
         init_put_bits(&s->pb, avpkt->data, avpkt->size);
 
         if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & AV_CODEC_FLAG_BITEXACT))
             put_bitstream_info(s, LIBAVCODEC_IDENT);
         start_ch = 0;
+        target_bits = 0;
         memset(chan_el_counter, 0, sizeof(chan_el_counter));
         for (i = 0; i < s->chan_map[0]; i++) {
             FFPsyWindowInfo* wi = windows + start_ch;
@@@@ -614,15 +654,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d267 1
a267 1
@@@@ -640,14 +693,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d284 1
a284 1
@@@@ -664,8 +717,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d295 1
a295 1
@@@@ -674,22 +727,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d334 1
a334 1
@@@@ -701,36 +766,78 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d433 1
a433 1
@@@@ -746,6 +853,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d442 1
a442 1
@@@@ -804,76 +913,123 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d542 1
a542 1
+    if (s->options.coder != AAC_CODER_TWOLOOP) {
d544 1
a544 1
+                 "Coders other than twoloop require -strict -2 and some may be removed in the future\n");
d600 1
a600 1
@@@@ -884,27 +1040,16 @@@@ fail:
d638 1
a638 1
@@@@ -915,6 +1060,11 @@@@ static const AVClass aacenc_class = {
d650 1
a650 1
@@@@ -924,9 +1074,9 @@@@ AVCodec ff_aac_encoder = {
@


1.15
log
@More AAC support improvement.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.14 2016/03/09 17:29:36 ajacoutot Exp $
a64 2
avcodec/aacenc: Check both channels for finiteness

d79 2
a80 2
--- libavcodec/aacenc.c.orig	Wed Jan 13 15:27:48 2016
+++ libavcodec/aacenc.c	Wed Apr  6 18:35:10 2016
d233 1
a233 1
@@@@ -571,25 +610,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d238 11
a248 2
-            if (isnan(cpe->ch->coeffs[0])) {
-                av_log(avctx, AV_LOG_ERROR, "Input contains NaN\n");
a249 2
+            apply_window_and_mdct(s, sce, overlap);
+
d282 1
a282 1
@@@@ -606,15 +654,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d312 1
a312 1
@@@@ -632,14 +693,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d329 1
a329 1
@@@@ -656,8 +717,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d340 1
a340 1
@@@@ -666,22 +727,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d379 1
a379 1
@@@@ -693,36 +766,78 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d478 1
a478 1
@@@@ -738,6 +853,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d487 1
a487 1
@@@@ -796,76 +913,123 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d645 1
a645 1
@@@@ -876,27 +1040,16 @@@@ fail:
d683 1
a683 1
@@@@ -907,6 +1060,11 @@@@ static const AVClass aacenc_class = {
d695 1
a695 1
@@@@ -916,9 +1074,9 @@@@ AVCodec ff_aac_encoder = {
@


1.14
log
@Moar AAC.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.13 2016/02/25 03:53:53 ajacoutot Exp $
d79 2
d82 1
a82 1
+++ libavcodec/aacenc.c	Tue Mar  8 19:23:12 2016
d174 1
a174 1
@@@@ -517,10 +540,12 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d190 12
a201 1
@@@@ -537,7 +562,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d210 26
a235 1
@@@@ -571,25 +596,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d277 1
a277 1
@@@@ -606,15 +640,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d307 1
a307 1
@@@@ -632,14 +679,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d324 1
a324 1
@@@@ -656,8 +703,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d335 1
a335 1
@@@@ -666,22 +713,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d374 1
a374 1
@@@@ -693,36 +752,78 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d473 1
a473 1
@@@@ -738,6 +839,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d482 1
a482 1
@@@@ -796,76 +899,123 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d640 1
a640 1
@@@@ -876,27 +1026,16 @@@@ fail:
d678 1
a678 1
@@@@ -907,6 +1046,11 @@@@ static const AVClass aacenc_class = {
d690 1
a690 1
@@@@ -916,9 +1060,9 @@@@ AVCodec ff_aac_encoder = {
@


1.13
log
@aacenc: make a better estimate for the audio bitrate if not provided
aacenc: temporarily disable Mid/Side coding with multichannel files

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.12 2016/01/22 07:05:01 ajacoutot Exp $
d77 2
d80 1
a80 1
+++ libavcodec/aacenc.c	Mon Feb 15 17:12:33 2016
d103 1
a103 1
@@@@ -71,6 +73,16 @@@@ static void put_audio_specific_config(AVCodecContext *
d109 4
a112 5
+    int sf, g;
+    for (sf = 0; sf < 256; sf++) {
+        for (g = 0; g < 128; g++) {
+            s->quantize_band_cost_cache[sf][g].bits = -1;
+        }
d119 1
a119 1
@@@@ -140,7 +152,7 @@@@ static void apply_window_and_mdct(AACEncContext *s, Si
d128 1
a128 1
@@@@ -258,6 +270,8 @@@@ static void apply_intensity_stereo(ChannelElement *cpe
d137 1
a137 1
@@@@ -279,7 +293,13 @@@@ static void apply_mid_side_stereo(ChannelElement *cpe)
d152 1
a152 1
@@@@ -424,6 +444,8 @@@@ static int encode_individual_channel(AVCodecContext *a
d161 1
a161 1
@@@@ -489,7 +511,9 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d172 1
a172 1
@@@@ -517,10 +541,12 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d188 1
a188 1
@@@@ -537,7 +563,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d197 1
a197 1
@@@@ -571,25 +597,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d239 1
a239 1
@@@@ -606,15 +641,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d269 1
a269 1
@@@@ -632,14 +680,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d286 1
a286 1
@@@@ -656,8 +704,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d297 1
a297 1
@@@@ -666,22 +714,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d336 1
a336 1
@@@@ -693,36 +753,78 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d435 1
a435 1
@@@@ -738,6 +840,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d444 1
a444 1
@@@@ -796,76 +900,123 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d602 1
a602 1
@@@@ -876,27 +1027,16 @@@@ fail:
d640 1
a640 1
@@@@ -907,6 +1047,11 @@@@ static const AVClass aacenc_class = {
d652 1
a652 1
@@@@ -916,9 +1061,9 @@@@ AVCodec ff_aac_encoder = {
@


1.12
log
@Yet again mor AAC fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.11 2016/01/18 15:34:45 ajacoutot Exp $
d73 4
d78 1
a78 1
+++ libavcodec/aacenc.c	Wed Jan 20 21:30:40 2016
d443 1
a443 1
@@@@ -796,76 +900,109 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d447 1
a447 3
+    s->channels = avctx->channels;
+    s->chan_map = aac_chan_configs[s->channels-1];
+    s->lambda = avctx->global_quality > 0 ? avctx->global_quality : 120;
d452 1
a452 5
+    avctx->bit_rate = (int)FFMIN(
+        6144 * s->channels / 1024.0 * avctx->sample_rate,
+        avctx->bit_rate);
+    avctx->profile = avctx->profile == FF_PROFILE_UNKNOWN ? FF_PROFILE_AAC_LOW :
+                     avctx->profile;
d454 14
d471 1
a471 2
+    s->samplerate_index = i;
 
d475 1
d481 3
a483 2
+    ERROR_IF(s->channels > AAC_MAX_CHANNELS || s->channels == 7,
              "Unsupported number of channels: %d\n", s->channels);
d490 6
a495 1
+
a498 2
+    ERROR_IF(i == FF_ARRAY_ELEMS(aacenc_profiles),
+             "Unsupported encoding profile: %d\n", avctx->profile);
a538 1
+    s->coder = &ff_aac_coders[s->options.coder];
d541 2
d549 2
d555 3
a557 2
+    ERROR_IF(s->options.ltp && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL,
+             "The LPT profile requires experimental compliance, add -strict -2 to enable!\n");
d601 1
a601 1
@@@@ -876,27 +1013,16 @@@@ fail:
d639 14
a652 1
@@@@ -917,8 +1043,7 @@@@ AVCodec ff_aac_encoder = {
d655 1
@


1.11
log
@Moar AAC.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.10 2016/01/14 06:09:43 ajacoutot Exp $
d67 6
d74 1
a74 1
+++ libavcodec/aacenc.c	Sat Jan 16 18:41:08 2016
d167 1
a167 1
@@@@ -517,10 +541,11 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d173 1
d183 1
a183 1
@@@@ -537,7 +562,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d192 1
a192 1
@@@@ -571,25 +596,40 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d199 1
a205 13
+            }
+
+            if (!(isfinite(cpe->ch[ch].coeffs[    0]) &&
+                  isfinite(cpe->ch[ch].coeffs[  128]) &&
+                  isfinite(cpe->ch[ch].coeffs[2*128]) &&
+                  isfinite(cpe->ch[ch].coeffs[3*128]) &&
+                  isfinite(cpe->ch[ch].coeffs[4*128]) &&
+                  isfinite(cpe->ch[ch].coeffs[5*128]) &&
+                  isfinite(cpe->ch[ch].coeffs[6*128]) &&
+                  isfinite(cpe->ch[ch].coeffs[7*128]))
+            ) {
+                av_log(avctx, AV_LOG_ERROR, "Input contains NaN/+-Inf\n");
                 return AVERROR(EINVAL);
d208 7
d234 1
a234 1
@@@@ -606,15 +646,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d264 1
a264 1
@@@@ -632,14 +685,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d281 1
a281 1
@@@@ -656,8 +709,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d292 1
a292 1
@@@@ -666,22 +719,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d331 1
a331 1
@@@@ -693,36 +758,78 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d430 1
a430 1
@@@@ -738,6 +845,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d439 1
a439 1
@@@@ -796,76 +905,108 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
a528 2
+        WARN_IF(s->options.coder == AAC_CODER_FAAC,
+                "The FAAC-like coder will be removed in the near future, please use twoloop!\n");
d536 3
a538 1
-
d581 1
a581 1
@@@@ -876,27 +1017,17 @@@@ fail:
d606 1
a606 2
+    {"aac_coder", "Coding algorithm", offsetof(AACEncContext, options.coder), AV_OPT_TYPE_INT, {.i64 = AAC_CODER_TWOLOOP}, -1, AAC_CODER_NB-1, AACENC_FLAGS, "coder"},
+        {"faac",     "FAAC-inspired method",      0, AV_OPT_TYPE_CONST, {.i64 = AAC_CODER_FAAC},    INT_MIN, INT_MAX, AACENC_FLAGS, "coder"},
d619 1
a619 1
@@@@ -917,8 +1048,7 @@@@ AVCodec ff_aac_encoder = {
@


1.10
log
@Update to ffmpeg-20160113.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.9 2015/12/10 06:53:38 ajacoutot Exp $
d61 6
d68 10
a77 2
+++ libavcodec/aacenc.c	Wed Jan 13 17:25:05 2016
@@@@ -54,11 +54,12 @@@@ static void put_audio_specific_config(AVCodecContext *
d91 1
a91 1
@@@@ -71,6 +72,16 @@@@ static void put_audio_specific_config(AVCodecContext *
d108 1
a108 1
@@@@ -140,7 +151,7 @@@@ static void apply_window_and_mdct(AACEncContext *s, Si
d117 1
a117 1
@@@@ -258,6 +269,8 @@@@ static void apply_intensity_stereo(ChannelElement *cpe
d126 1
a126 1
@@@@ -279,7 +292,13 @@@@ static void apply_mid_side_stereo(ChannelElement *cpe)
d141 1
a141 1
@@@@ -424,6 +443,8 @@@@ static int encode_individual_channel(AVCodecContext *a
d150 1
a150 1
@@@@ -489,7 +510,9 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d161 1
a161 1
@@@@ -517,10 +540,11 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d176 1
a176 1
@@@@ -537,7 +561,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d185 1
a185 1
@@@@ -571,25 +595,40 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d191 1
d200 8
a207 8
+            if (isnan(cpe->ch->coeffs[0]) ||
+                isnan(cpe->ch->coeffs[  128]) ||
+                isnan(cpe->ch->coeffs[2*128]) ||
+                isnan(cpe->ch->coeffs[3*128]) ||
+                isnan(cpe->ch->coeffs[4*128]) ||
+                isnan(cpe->ch->coeffs[5*128]) ||
+                isnan(cpe->ch->coeffs[6*128]) ||
+                isnan(cpe->ch->coeffs[7*128])
d209 1
a209 1
                 av_log(avctx, AV_LOG_ERROR, "Input contains NaN\n");
d232 1
a232 1
@@@@ -606,15 +645,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d262 1
a262 1
@@@@ -632,14 +684,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d279 1
a279 1
@@@@ -656,8 +708,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d290 1
a290 1
@@@@ -666,22 +718,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d329 1
a329 1
@@@@ -693,36 +757,78 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d428 1
a428 1
@@@@ -738,6 +844,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d437 1
a437 1
@@@@ -796,76 +904,108 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d579 1
a579 1
@@@@ -876,27 +1016,17 @@@@ fail:
d618 1
a618 1
@@@@ -917,8 +1047,7 @@@@ AVCodec ff_aac_encoder = {
@


1.9
log
@Moar AAC fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.8 2015/12/06 08:51:46 ajacoutot Exp $
d39 2
d51 7
a57 1
aacenc: update max_sfb when num_swb changes
d59 4
a62 2
--- libavcodec/aacenc.c.orig	Thu Nov 12 02:08:28 2015
+++ libavcodec/aacenc.c	Wed Dec  9 01:12:49 2015
d94 9
d122 2
a123 2
+                    || cpe->ch[0].band_type[w*16 + g] == NOISE_BT
+                    || cpe->ch[1].band_type[w*16 + g] == NOISE_BT) {
d171 1
a171 9
@@@@ -547,6 +571,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
             ics->num_windows        = wi[ch].num_windows;
             ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];
             ics->num_swb            = tag == TYPE_LFE ? ics->num_swb : s->psy.num_bands[ics->num_windows == 8];
+            ics->max_sfb            = FFMIN(ics->max_sfb, ics->num_swb);
             ics->swb_offset         = wi[ch].window_type[0] == EIGHT_SHORT_SEQUENCE ?
                                         ff_swb_offset_128 [s->samplerate_index]:
                                         ff_swb_offset_1024[s->samplerate_index];
@@@@ -570,25 +595,32 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d176 1
d185 9
a193 1
             if (isnan(cpe->ch->coeffs[0])) {
d217 1
a217 1
@@@@ -605,15 +637,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d231 1
a231 1
+            s->psy.bitres.bits = avctx->frame_bits / s->channels;
d247 1
a247 1
@@@@ -631,14 +676,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d264 1
a264 1
@@@@ -655,8 +700,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d275 1
a275 1
@@@@ -665,22 +710,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d314 1
a314 1
@@@@ -692,36 +749,76 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d397 1
a397 3
     avctx->frame_bits = put_bits_count(&s->pb);
+    s->lambda_sum += s->lambda;
+    s->lambda_count++;
d405 5
a409 1
-
d413 1
a413 1
@@@@ -737,6 +834,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d422 1
a422 1
@@@@ -795,76 +894,105 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
a427 1
+    s->random_state = 0x1f2e3d4c;
d429 1
d455 1
a455 1
              "Too many bits per frame requested, clamping to max\n");
d457 3
d551 1
d564 1
a564 1
@@@@ -875,27 +1003,17 @@@@ fail:
d603 1
a603 1
@@@@ -916,8 +1034,7 @@@@ AVCodec ff_aac_encoder = {
@


1.8
log
@More AAC bits and remove the experimental status for the encoder.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.7 2015/10/25 08:46:41 ajacoutot Exp $
d47 6
a52 2
--- libavcodec/aacenc.c.orig	Sat Dec  5 15:13:08 2015
+++ libavcodec/aacenc.c	Sat Dec  5 15:11:04 2015
d152 9
a160 1
@@@@ -570,25 +594,32 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d197 1
a197 1
@@@@ -605,15 +636,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d227 18
a244 1
@@@@ -655,8 +699,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d255 1
a255 1
@@@@ -665,22 +709,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d294 1
a294 1
@@@@ -692,36 +748,76 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d391 1
a391 1
@@@@ -737,6 +833,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d400 1
a400 1
@@@@ -795,76 +893,105 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d538 1
a538 1
@@@@ -875,27 +1002,17 @@@@ fail:
d577 1
a577 1
@@@@ -916,8 +1033,7 @@@@ AVCodec ff_aac_encoder = {
@


1.7
log
@More AAC fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.6 2015/10/17 06:49:22 ajacoutot Exp $
d35 14
a48 2
--- libavcodec/aacenc.c.orig	Mon Sep  7 21:58:01 2015
+++ libavcodec/aacenc.c	Sun Oct 18 22:28:49 2015
d89 1
a89 1
@@@@ -279,7 +292,7 @@@@ static void apply_mid_side_stereo(ChannelElement *cpe)
d94 7
a100 1
+                if (!cpe->ms_mask[w*16 + g] && !cpe->is_mask[w*16 + g]) {
d104 1
a104 1
@@@@ -424,6 +437,8 @@@@ static int encode_individual_channel(AVCodecContext *a
d113 1
a113 1
@@@@ -489,7 +504,9 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d124 1
a124 1
@@@@ -517,10 +534,11 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d139 1
a139 1
@@@@ -537,7 +555,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d148 1
a148 1
@@@@ -570,25 +588,32 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d185 1
a185 1
@@@@ -605,15 +630,28 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d215 1
a215 1
@@@@ -655,8 +693,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d226 1
a226 1
@@@@ -665,22 +703,34 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d265 1
a265 1
@@@@ -692,36 +742,76 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d324 1
a324 1
+            if ((s->lambda < 300.f || ratio > 0.9f) && (s->lambda > 10.f || ratio < 1.1f)) {
d362 1
a362 1
@@@@ -737,6 +827,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d371 1
a371 1
@@@@ -795,76 +887,101 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
d448 1
a448 1
+        ERROR_IF(s->options.pred,
d456 4
d509 1
a509 1
@@@@ -875,27 +992,17 @@@@ fail:
d548 10
@


1.6
log
@Guess what... more AAC stuffs.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.5 2015/10/13 05:44:18 ajacoutot Exp $
d31 4
d36 1
a36 1
+++ libavcodec/aacenc.c	Fri Oct 16 23:46:49 2015
d112 2
a116 2
             float clip_avoidance_factor;
-            overlap  = &samples[cur_channel][0];
d520 1
a520 1
+    {"aac_tns", "Temporal noise shaping", offsetof(AACEncContext, options.tns), AV_OPT_TYPE_BOOL, {.i64 = 0}, -1, 1, AACENC_FLAGS},
@


1.5
log
@Some more AAC stuffs.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.4 2015/09/23 09:16:45 ajacoutot Exp $
d19 12
d32 2
a33 47
+++ libavcodec/aacenc.c	Mon Oct 12 22:07:21 2015
@@@@ -46,6 +46,44 @@@@
 
 #include "psymodel.h"
 
+struct AACProfileOptions {
+    int profile;
+    struct AACEncOptions opts;
+};
+
+ /**
+ * List of currently supported profiles, anything not listed isn't supported.
+ */
+static const struct AACProfileOptions aacenc_profiles[] = {
+    {FF_PROFILE_AAC_MAIN,
+        {  /* Main profile, all advanced encoding abilities enabled */
+            .mid_side = 0,
+            .pns = 1,
+            .tns = 0,
+            .pred = OPT_REQUIRED,
+            .intensity_stereo = 1,
+        },
+    },
+    {FF_PROFILE_AAC_LOW,
+        {  /* Default profile, these are the settings that get set by default */
+            .mid_side = 0,
+            .pns = 1,
+            .tns = 0,
+            .pred = OPT_NEEDS_MAIN,
+            .intensity_stereo = 1,
+        },
+    },
+    {FF_PROFILE_MPEG2_AAC_LOW,
+        {  /* Strict MPEG 2 Part 7 compliance profile */
+            .mid_side = 0,
+            .pns = OPT_BANNED,
+            .tns = 0,
+            .pred = OPT_BANNED,
+            .intensity_stereo = 1,
+        },
+    },
+};
+
 /**
  * Make AAC audio config object.
  * @@see 1.6.2.1 "Syntax - AudioSpecificConfig"
@@@@ -54,11 +92,12 @@@@ static void put_audio_specific_config(AVCodecContext *
d47 1
a47 1
@@@@ -71,6 +110,16 @@@@ static void put_audio_specific_config(AVCodecContext *
d64 1
a64 1
@@@@ -258,6 +307,8 @@@@ static void apply_intensity_stereo(ChannelElement *cpe
d73 1
a73 1
@@@@ -279,7 +330,7 @@@@ static void apply_mid_side_stereo(ChannelElement *cpe)
d82 10
a91 1
@@@@ -489,7 +540,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d96 1
d102 45
a146 1
@@@@ -581,14 +633,14 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d163 10
a172 1
@@@@ -611,9 +663,20 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d193 1
a193 1
@@@@ -655,8 +718,8 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d204 1
a204 1
@@@@ -665,13 +728,11 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d220 24
a243 1
@@@@ -692,36 +753,73 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d321 3
d340 1
a340 1
@@@@ -737,6 +835,8 @@@@ static av_cold int aac_encode_end(AVCodecContext *avct
d349 1
a349 7
@@@@ -790,81 +890,88 @@@@ alloc_fail:
 static av_cold int aac_encode_init(AVCodecContext *avctx)
 {
     AACEncContext *s = avctx->priv_data;
+    const AACEncOptions *p_opt = NULL;
     int i, ret = 0;
     const uint8_t *sizes[2];
d384 21
a404 1
-        s->options.pred = 1;
d414 14
a427 6
+
+    for (i = 0; i < FF_ARRAY_ELEMS(aacenc_profiles); i++) {
+        if (avctx->profile == aacenc_profiles[i].profile) {
+            p_opt = &aacenc_profiles[i].opts;
+            break;
+        }
d429 1
a429 11
+    ERROR_IF(!p_opt, "Unsupported encoding profile: %d\n", avctx->profile);
+    AAC_OPT_SET(&s->options, p_opt, 1, coder);
+    AAC_OPT_SET(&s->options, p_opt, 0, pns);
+    AAC_OPT_SET(&s->options, p_opt, 0, tns);
+    AAC_OPT_SET(&s->options, p_opt, 0, pred);
+    AAC_OPT_SET(&s->options, p_opt, 1, mid_side);
+    AAC_OPT_SET(&s->options, p_opt, 0, intensity_stereo);
+    if (avctx->profile == FF_PROFILE_MPEG2_AAC_LOW)
+        s->profile = FF_PROFILE_AAC_LOW;
+    else
+        s->profile = avctx->profile;
d483 1
a483 1
@@@@ -875,27 +982,16 @@@@ fail:
d513 6
a518 5
+    {"aac_ms", "Force M/S stereo coding", offsetof(AACEncContext, options.mid_side), AV_OPT_TYPE_BOOL, {.i64 = 0}, -1, 1, AACENC_FLAGS},
+    {"aac_is", "Intensity stereo coding", offsetof(AACEncContext, options.intensity_stereo), AV_OPT_TYPE_BOOL, {.i64 = OPT_AUTO}, -1, 1, AACENC_FLAGS},
+    {"aac_pns", "Perceptual noise substitution", offsetof(AACEncContext, options.pns), AV_OPT_TYPE_BOOL, {.i64 = OPT_AUTO}, -1, 1, AACENC_FLAGS},
+    {"aac_tns", "Temporal noise shaping", offsetof(AACEncContext, options.tns), AV_OPT_TYPE_BOOL, {.i64 = OPT_AUTO}, -1, 1, AACENC_FLAGS},
+    {"aac_pred", "AAC-Main prediction", offsetof(AACEncContext, options.pred), AV_OPT_TYPE_BOOL, {.i64 = OPT_AUTO}, -1, 1, AACENC_FLAGS},
@


1.4
log
@Yet again more AAC encoder fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.3 2015/09/12 09:44:54 ajacoutot Exp $
d5 2
d9 10
d20 96
a115 2
+++ libavcodec/aacenc.c	Wed Sep 23 03:54:56 2015
@@@@ -489,7 +489,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d121 1
d125 1
a125 1
@@@@ -581,14 +581,16 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d132 1
a132 2
+        int target_bits, too_many_bits, too_few_bits;
 
d142 1
a142 1
@@@@ -611,7 +613,15 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d151 2
a152 1
+                target_bits += s->psy.bitres.alloc;
d158 2
d161 30
a190 1
@@@@ -692,36 +702,69 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
d213 2
a214 2
+         * target either the nominal bitrate, or what psy's bit reservoir says to target
+         * whichever is greatest
d216 6
a222 4
+        frame_bits = put_bits_count(&s->pb);
+        target_bits = FFMAX(target_bits, avctx->bit_rate * 1024 / avctx->sample_rate);
+        target_bits = FFMIN(target_bits, 6144 * s->channels - 3);
+
d224 2
a225 2
+        too_many_bits = target_bits + target_bits/2;
+        too_few_bits = target_bits - target_bits/8;
d231 1
a231 1
+            float ratio = ((float)target_bits) / frame_bits;
d249 1
a249 1
+            if (s->lambda < 300.f || ratio > 0.9f) {
d271 2
d284 18
a301 2
@@@@ -861,6 +904,7 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
         ff_aac_coder_init_mips(s);
d303 2
a304 1
     s->lambda = avctx->global_quality > 0 ? avctx->global_quality : 120;
d306 97
d404 5
d410 42
@


1.3
log
@Back port some AAC encoder fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d5 138
a142 3
--- libavcodec/aacenc.c.orig	Sat Sep 12 02:09:31 2015
+++ libavcodec/aacenc.c	Sat Sep 12 02:09:53 2015
@@@@ -861,6 +861,7 @@@@ static av_cold int aac_encode_init(AVCodecContext *avc
@


1.2
log
@Update to FFmpeg 20140412 snapshot. From 2.2 branch.

Update to MPlayer 20140412 snapshot.

Take MAINTAINER for MPlayer. ok edd@@

ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_c,v 1.1 2013/08/19 14:38:29 brad Exp $
d3 1
a3 1
Fix erasure of surround channels.
d5 10
a14 20
--- libavcodec/aacenc.c.orig	Wed Jun 12 19:09:49 2013
+++ libavcodec/aacenc.c	Wed Jun 12 19:10:53 2013
@@@@ -593,7 +593,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
                 coeffs[ch] = cpe->ch[ch].coeffs;
             s->psy.model->analyze(&s->psy, start_ch, coeffs, wi);
             for (ch = 0; ch < chans; ch++) {
-                s->cur_channel = start_ch * 2 + ch;
+                s->cur_channel = start_ch + ch;
                 s->coder->search_for_quantizers(avctx, s, &cpe->ch[ch], s->lambda);
             }
             cpe->common_window = 0;
@@@@ -609,7 +609,7 @@@@ static int aac_encode_frame(AVCodecContext *avctx, AVP
                     }
                 }
             }
-            s->cur_channel = start_ch * 2;
+            s->cur_channel = start_ch;
             if (s->options.stereo_mode && cpe->common_window) {
                 if (s->options.stereo_mode > 0) {
                     IndividualChannelStream *ics = &cpe->ch[0].ics;
@


1.1
log
@Update to FFmpeg 20130718 snapshot. From 1.2 branch.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@

