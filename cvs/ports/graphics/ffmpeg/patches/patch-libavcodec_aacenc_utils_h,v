head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.2
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7;
locks; strict;
comment	@# @;


1.11
date	2016.10.17.07.51.00;	author ajacoutot;	state Exp;
branches;
next	1.10;
commitid	Wo4uP395zjJX9ZOv;

1.10
date	2016.04.07.06.01.19;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	XQzqg9116vhXixw9;

1.9
date	2016.03.09.17.29.36;	author ajacoutot;	state Exp;
branches;
next	1.8;
commitid	TFfaaPvpBDwqcHyX;

1.8
date	2016.03.07.07.11.35;	author ajacoutot;	state Exp;
branches;
next	1.7;
commitid	FnJIp1QTzf5KQpn7;

1.7
date	2016.01.18.15.34.45;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	RwM3NoHU9JMWKEgE;

1.6
date	2016.01.14.06.09.43;	author ajacoutot;	state Exp;
branches;
next	1.5;
commitid	1MTT7RUn5DsgY3tS;

1.5
date	2015.12.06.08.51.46;	author ajacoutot;	state Exp;
branches;
next	1.4;
commitid	qmMp5nlfDfTw8ZGw;

1.4
date	2015.10.17.06.49.22;	author ajacoutot;	state Exp;
branches;
next	1.3;
commitid	qCaTAupMCq4yvb8q;

1.3
date	2015.10.13.05.44.18;	author ajacoutot;	state Exp;
branches;
next	1.2;
commitid	qst9LZIZleMKOm5n;

1.2
date	2015.09.23.09.16.45;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	t74suKYQj33NdaVz;

1.1
date	2015.09.12.09.44.54;	author ajacoutot;	state Exp;
branches;
next	;
commitid	2zCvmn8WdgiiJ5l4;


desc
@@


1.11
log
@Some more AAC fixes.

from Brad (maintainer)
@
text
@$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.10 2016/04/07 06:01:19 ajacoutot Exp $

aacenc: copy PRNG from the decoder

AAC encoder: simplify and speed up find_min_book

AAC encoder: Extensive improvements

aacenc_utils: add 'inline' flag to find_form_factor, silence warning

aacenc: add support for changing options based on a profile

aacenc_utils: fit find_form_factor() below 80 chars per line

aacenc: partially revert previous commits to set options via a profile

avcodec/aac_tablegen: get rid of hardcoded tables entirely

AAC encoder: improve SF range utilization

aacenc: switch to using the RNG from libavutil

avcodec/aacenc_is: replace pow(x, 0.75) by x/sqrtf(sqrtf(x))

lavc/aacenc_utils: replace sqrtf(Q*sqrtf(Q)) by precomputed value

aacenc: avoid double in quantize_bands.

aacenc_utils: Use temporary variable.

lavc/aacenc_utils: replace powf(x,y) by expf(logf(x), y)

aacenc: use the decoder's lcg PRNG

--- libavcodec/aacenc_utils.h.orig	Sat Aug 27 22:51:19 2016
+++ libavcodec/aacenc_utils.h	Sat Oct 15 18:51:24 2016
@@@@ -28,9 +28,10 @@@@
 #ifndef AVCODEC_AACENC_UTILS_H
 #define AVCODEC_AACENC_UTILS_H
 
+#include "libavutil/internal.h"
 #include "aac.h"
-#include "aac_tablegen_decl.h"
 #include "aacenctab.h"
+#include "aactab.h"
 
 #define ROUND_STANDARD 0.4054f
 #define ROUND_TO_ZERO 0.1054f
@@@@ -45,6 +46,11 @@@@ static inline void abs_pow34_v(float *out, const float
     }
 }
 
+static inline float pos_pow34(float a)
+{
+    return sqrtf(a * sqrtf(a));
+}
+
 /**
  * Quantize one coefficient.
  * @@return absolute value of the quantized coefficient
@@@@ -61,13 +67,13 @@@@ static inline void quantize_bands(int *out, const floa
                                   const float rounding)
 {
     int i;
-    double qc;
     for (i = 0; i < size; i++) {
-        qc = scaled[i] * Q34;
-        out[i] = (int)FFMIN(qc + rounding, (double)maxval);
+        float qc = scaled[i] * Q34;
+        int tmp = (int)FFMIN(qc + rounding, (float)maxval);
         if (is_signed && in[i] < 0.0f) {
-            out[i] = -out[i];
+            tmp = -tmp;
         }
+        out[i] = tmp;
     }
 }
 
@@@@ -85,20 +91,68 @@@@ static inline float find_max_val(int group_len, int sw
 
 static inline int find_min_book(float maxval, int sf)
 {
-    float Q = ff_aac_pow2sf_tab[POW_SF2_ZERO - sf + SCALE_ONE_POS - SCALE_DIV_512];
-    float Q34 = sqrtf(Q * sqrtf(Q));
+    float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - sf + SCALE_ONE_POS - SCALE_DIV_512];
     int qmaxval, cb;
     qmaxval = maxval * Q34 + C_QUANT;
-    if      (qmaxval ==  0) cb = 0;
-    else if (qmaxval ==  1) cb = 1;
-    else if (qmaxval ==  2) cb = 3;
-    else if (qmaxval <=  4) cb = 5;
-    else if (qmaxval <=  7) cb = 7;
-    else if (qmaxval <= 12) cb = 9;
-    else                    cb = 11;
+    if (qmaxval >= (FF_ARRAY_ELEMS(aac_maxval_cb)))
+        cb = 11;
+    else
+        cb = aac_maxval_cb[qmaxval];
     return cb;
 }
 
+static inline float find_form_factor(int group_len, int swb_size, float thresh,
+                                     const float *scaled, float nzslope) {
+    const float iswb_size = 1.0f / swb_size;
+    const float iswb_sizem1 = 1.0f / (swb_size - 1);
+    const float ethresh = thresh;
+    float form = 0.0f, weight = 0.0f;
+    int w2, i;
+    for (w2 = 0; w2 < group_len; w2++) {
+        float e = 0.0f, e2 = 0.0f, var = 0.0f, maxval = 0.0f;
+        float nzl = 0;
+        for (i = 0; i < swb_size; i++) {
+            float s = fabsf(scaled[w2*128+i]);
+            maxval = FFMAX(maxval, s);
+            e += s;
+            e2 += s *= s;
+            /* We really don't want a hard non-zero-line count, since
+             * even below-threshold lines do add up towards band spectral power.
+             * So, fall steeply towards zero, but smoothly
+             */
+            if (s >= ethresh) {
+                nzl += 1.0f;
+            } else {
+                if (nzslope == 2.f)
+                    nzl += (s / ethresh) * (s / ethresh);
+                else
+                    nzl += ff_fast_powf(s / ethresh, nzslope);
+            }
+        }
+        if (e2 > thresh) {
+            float frm;
+            e *= iswb_size;
+
+            /** compute variance */
+            for (i = 0; i < swb_size; i++) {
+                float d = fabsf(scaled[w2*128+i]) - e;
+                var += d*d;
+            }
+            var = sqrtf(var * iswb_sizem1);
+
+            e2 *= iswb_size;
+            frm = e / FFMIN(e+4*var,maxval);
+            form += e2 * sqrtf(frm) / FFMAX(0.5f,nzl);
+            weight += e2;
+        }
+    }
+    if (weight > 0) {
+        return form / weight;
+    } else {
+        return 1.0f;
+    }
+}
+
 /** Return the minimum scalefactor where the quantized coef does not clip. */
 static inline uint8_t coef2minsf(float coef)
 {
@@@@ -128,6 +182,89 @@@@ static inline int quant_array_idx(const float val, con
     return index;
 }
 
+/**
+ * approximates exp10f(-3.0f*(0.5f + 0.5f * cosf(FFMIN(b,15.5f) / 15.5f)))
+ */
+static av_always_inline float bval2bmax(float b)
+{
+    return 0.001f + 0.0035f * (b*b*b) / (15.5f*15.5f*15.5f);
+}
+
+/*
+ * Compute a nextband map to be used with SF delta constraint utilities.
+ * The nextband array should contain 128 elements, and positions that don't
+ * map to valid, nonzero bands of the form w*16+g (with w being the initial
+ * window of the window group, only) are left indetermined.
+ */
+static inline void ff_init_nextband_map(const SingleChannelElement *sce, uint8_t *nextband)
+{
+    unsigned char prevband = 0;
+    int w, g;
+    /** Just a safe default */
+    for (g = 0; g < 128; g++)
+        nextband[g] = g;
+
+    /** Now really navigate the nonzero band chain */
+    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {
+        for (g = 0; g < sce->ics.num_swb; g++) {
+            if (!sce->zeroes[w*16+g] && sce->band_type[w*16+g] < RESERVED_BT)
+                prevband = nextband[prevband] = w*16+g;
+        }
+    }
+    nextband[prevband] = prevband; /* terminate */
+}
+
+/*
+ * Updates nextband to reflect a removed band (equivalent to
+ * calling ff_init_nextband_map after marking a band as zero)
+ */
+static inline void ff_nextband_remove(uint8_t *nextband, int prevband, int band)
+{
+    nextband[prevband] = nextband[band];
+}
+
+/*
+ * Checks whether the specified band could be removed without inducing
+ * scalefactor delta that violates SF delta encoding constraints.
+ * prev_sf has to be the scalefactor of the previous nonzero, nonspecial
+ * band, in encoding order, or negative if there was no such band.
+ */
+static inline int ff_sfdelta_can_remove_band(const SingleChannelElement *sce,
+    const uint8_t *nextband, int prev_sf, int band)
+{
+    return prev_sf >= 0
+        && sce->sf_idx[nextband[band]] >= (prev_sf - SCALE_MAX_DIFF)
+        && sce->sf_idx[nextband[band]] <= (prev_sf + SCALE_MAX_DIFF);
+}
+
+/*
+ * Checks whether the specified band's scalefactor could be replaced
+ * with another one without violating SF delta encoding constraints.
+ * prev_sf has to be the scalefactor of the previous nonzero, nonsepcial
+ * band, in encoding order, or negative if there was no such band.
+ */
+static inline int ff_sfdelta_can_replace(const SingleChannelElement *sce,
+    const uint8_t *nextband, int prev_sf, int new_sf, int band)
+{
+    return new_sf >= (prev_sf - SCALE_MAX_DIFF)
+        && new_sf <= (prev_sf + SCALE_MAX_DIFF)
+        && sce->sf_idx[nextband[band]] >= (new_sf - SCALE_MAX_DIFF)
+        && sce->sf_idx[nextband[band]] <= (new_sf + SCALE_MAX_DIFF);
+}
+
+/**
+ * linear congruential pseudorandom number generator
+ *
+ * @@param   previous_val    pointer to the current state of the generator
+ *
+ * @@return  Returns a 32-bit pseudorandom integer
+ */
+static av_always_inline int lcg_random(unsigned previous_val)
+{
+    union { unsigned u; int s; } v = { previous_val * 1664525u + 1013904223 };
+    return v.s;
+}
+
 #define ERROR_IF(cond, ...) \
     if (cond) { \
         av_log(avctx, AV_LOG_ERROR, __VA_ARGS__); \
@@@@ -138,6 +275,5 @@@@ static inline int quant_array_idx(const float val, con
     if (cond) { \
         av_log(avctx, AV_LOG_WARNING, __VA_ARGS__); \
     }
-
 
 #endif /* AVCODEC_AACENC_UTILS_H */
@


1.10
log
@More AAC support improvement.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.9 2016/03/09 17:29:36 ajacoutot Exp $
d33 4
a36 2
--- libavcodec/aacenc_utils.h.orig	Wed Jan 13 15:27:48 2016
+++ libavcodec/aacenc_utils.h	Fri Mar 18 20:59:09 2016
d157 1
a157 1
@@@@ -128,6 +182,76 @@@@ static inline int quant_array_idx(const float val, con
d231 13
d247 1
a247 1
@@@@ -138,6 +262,5 @@@@ static inline int quant_array_idx(const float val, con
@


1.9
log
@Moar AAC.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.8 2016/03/07 07:11:35 ajacoutot Exp $
d31 2
d34 3
a36 2
+++ libavcodec/aacenc_utils.h	Tue Mar  8 19:24:00 2016
@@@@ -29,8 +29,8 @@@@
d39 1
d47 1
a47 1
@@@@ -45,6 +45,11 @@@@ static inline void abs_pow34_v(float *out, const float
d59 1
a59 1
@@@@ -61,13 +66,13 @@@@ static inline void quantize_bands(int *out, const floa
d77 1
a77 1
@@@@ -85,20 +90,65 @@@@ static inline float find_max_val(int group_len, int sw
d122 4
a125 1
+                nzl += powf(s / ethresh, nzslope);
d155 1
a155 1
@@@@ -128,6 +178,76 @@@@ static inline int quant_array_idx(const float val, con
d232 1
a232 1
@@@@ -138,6 +258,5 @@@@ static inline int quant_array_idx(const float val, con
@


1.8
log
@Merge some more AAC fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.7 2016/01/18 15:34:45 ajacoutot Exp $
d29 2
d32 1
a32 1
+++ libavcodec/aacenc_utils.h	Sun Mar  6 19:40:41 2016
d55 1
a55 1
@@@@ -61,10 +66,9 @@@@ static inline void quantize_bands(int *out, const floa
d64 1
a64 1
+        out[i] = (int)FFMIN(qc + rounding, (float)maxval);
d66 2
a67 1
             out[i] = -out[i];
d69 5
a73 1
@@@@ -85,20 +89,65 @@@@ static inline float find_max_val(int group_len, int sw
d148 1
a148 1
@@@@ -128,6 +177,76 @@@@ static inline int quant_array_idx(const float val, con
d225 1
a225 1
@@@@ -138,6 +257,5 @@@@ static inline int quant_array_idx(const float val, con
@


1.7
log
@Moar AAC.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.6 2016/01/14 06:09:43 ajacoutot Exp $
d25 4
d30 1
a30 1
+++ libavcodec/aacenc_utils.h	Thu Jan 14 20:12:52 2016
d53 20
a72 2
@@@@ -89,16 +94,62 @@@@ static inline int find_min_book(float maxval, int sf)
     float Q34 = sqrtf(Q * sqrtf(Q));
d141 1
a141 1
@@@@ -128,6 +179,76 @@@@ static inline int quant_array_idx(const float val, con
d218 1
a218 1
@@@@ -138,6 +259,5 @@@@ static inline int quant_array_idx(const float val, con
@


1.6
log
@Update to ffmpeg-20160113.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.5 2015/12/06 08:51:46 ajacoutot Exp $
d23 4
a26 2
--- libavcodec/aacenc_utils.h.orig	Thu Nov 12 02:08:28 2015
+++ libavcodec/aacenc_utils.h	Thu Dec 17 21:02:03 2015
d37 13
a49 1
@@@@ -89,16 +89,62 @@@@ static inline int find_min_book(float maxval, int sf)
d119 1
a119 1
@@@@ -128,6 +174,76 @@@@ static inline int quant_array_idx(const float val, con
d196 1
a196 1
@@@@ -138,6 +254,5 @@@@ static inline int quant_array_idx(const float val, con
@


1.5
log
@More AAC bits and remove the experimental status for the encoder.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.4 2015/10/17 06:49:22 ajacoutot Exp $
d21 4
a24 2
--- libavcodec/aacenc_utils.h.orig	Sat Dec  5 15:13:51 2015
+++ libavcodec/aacenc_utils.h	Sat Dec  5 15:01:19 2015
d105 1
a105 1
@@@@ -128,6 +174,86 @@@@ static inline int quant_array_idx(const float val, con
a117 10
+ * linear congruential pseudorandom number generator, copied from the decoder
+ */
+static inline int lcg_random(unsigned previous_val)
+{
+    union { unsigned u; int s; } v = { previous_val * 1664525u + 1013904223 };
+    return v.s;
+}
+
+
+/*
d182 1
a182 1
@@@@ -138,6 +264,5 @@@@ static inline int quant_array_idx(const float val, con
@


1.4
log
@Guess what... more AAC stuffs.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.3 2015/10/13 05:44:18 ajacoutot Exp $
d17 16
a32 2
--- libavcodec/aacenc_utils.h.orig	Mon Sep  7 21:58:01 2015
+++ libavcodec/aacenc_utils.h	Fri Oct 16 23:46:52 2015
d103 1
a103 1
@@@@ -128,6 +174,23 @@@@ static inline int quant_array_idx(const float val, con
d124 63
d190 1
a190 1
@@@@ -138,6 +201,5 @@@@ static inline int quant_array_idx(const float val, con
@


1.3
log
@Some more AAC stuffs.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.2 2015/09/23 09:16:45 ajacoutot Exp $
d15 2
d18 1
a18 1
+++ libavcodec/aacenc_utils.h	Mon Oct 12 22:07:45 2015
d113 2
a114 1
@@@@ -139,5 +202,43 @@@@ static inline int quant_array_idx(const float val, con
d117 1
a117 39
 
+#define AAC_OPT_SET(e_opt, p_opt, bypass, name)                                \
+    ERROR_IF ((e_opt)->name == 1 && (p_opt)->name == OPT_BANNED,               \
+              "Profile %i does not allow %s\n", avctx->profile, #name);        \
+    ERROR_IF ((e_opt)->name == 0 && (p_opt)->name == OPT_REQUIRED,             \
+             "Option %s is a requirement for this profile (%i)\n",             \
+              #name, avctx->profile);                                          \
+    if ((e_opt)->name == 1 && (p_opt)->name == OPT_NEEDS_MAIN &&               \
+        avctx->profile == FF_PROFILE_AAC_LOW) {                                \
+        WARN_IF(1, "Profile %i does not allow for %s, setting profile to "     \
+                "\"aac_main\"(%i)\n", avctx->profile, #name,                   \
+                FF_PROFILE_AAC_MAIN);                                          \
+        avctx->profile = FF_PROFILE_AAC_MAIN;                                  \
+        p_opt = &aacenc_profiles[FF_PROFILE_AAC_MAIN].opts;                    \
+    }                                                                          \
+    if ((e_opt)->name == 1 && (p_opt)->name == OPT_NEEDS_LTP &&                \
+        avctx->profile == FF_PROFILE_AAC_LOW) {                                \
+        WARN_IF(1, "Profile %i does not allow for %s, setting profile to "     \
+                "\"aac_ltp\"(%i)\n", avctx->profile, #name,                    \
+                FF_PROFILE_AAC_LTP);                                           \
+        avctx->profile = FF_PROFILE_AAC_LTP;                                   \
+        p_opt = &aacenc_profiles[FF_PROFILE_AAC_LTP].opts;                     \
+    }                                                                          \
+    if ((e_opt)->name == OPT_AUTO) {                                           \
+        if ((p_opt)->name == OPT_BANNED) {                                     \
+            (e_opt)->name = 0;                                                 \
+        } else if ((p_opt)->name == OPT_NEEDS_LTP) {                           \
+            (e_opt)->name = 0;                                                 \
+        } else if ((p_opt)->name == OPT_NEEDS_MAIN) {                          \
+            (e_opt)->name = 0;                                                 \
+        } else if ((p_opt)->name == OPT_REQUIRED) {                            \
+            (e_opt)->name = 1;                                                 \
+        } else if (bypass) {                                                   \
+            (e_opt)->name = (e_opt)->name;                                     \
+        } else {                                                               \
+            (e_opt)->name = (p_opt)->name;                                     \
+        }                                                                      \
+    }                                                                          \
+    av_log(avctx, AV_LOG_VERBOSE, "Option %s set to %i\n", #name, (e_opt)->name);
@


1.2
log
@Yet again more AAC encoder fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-libavcodec_aacenc_utils_h,v 1.1 2015/09/12 09:44:54 ajacoutot Exp $
d7 8
d16 2
a17 2
+++ libavcodec/aacenc_utils.h	Wed Sep 23 03:52:58 2015
@@@@ -89,13 +89,10 @@@@ static inline int find_min_book(float maxval, int sf)
d35 53
a87 3
@@@@ -126,6 +123,15 @@@@ static inline int quant_array_idx(const float val, con
         }
     }
d89 8
d106 47
a152 1
 }
d154 1
a154 1
 #define ERROR_IF(cond, ...) \
@


1.1
log
@Back port some AAC encoder fixes.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d5 20
a24 4
--- libavcodec/aacenc_utils.h.orig	Sat Sep 12 02:09:48 2015
+++ libavcodec/aacenc_utils.h	Sat Sep 12 02:09:57 2015
@@@@ -128,6 +128,15 @@@@ static inline int quant_array_idx(const float val, con
     return index;
d27 6
d40 2
a41 2
+}
+
a42 2
     if (cond) { \
         av_log(avctx, AV_LOG_ERROR, __VA_ARGS__); \
@

