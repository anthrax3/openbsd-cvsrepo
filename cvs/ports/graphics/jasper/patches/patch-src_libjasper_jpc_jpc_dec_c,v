head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.8
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.6
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.3.0.32
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.28
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.26
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.24
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.22
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.20
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.18
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.16
	OPENBSD_5_0:1.3.0.14
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.12
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.10
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.8
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.1.1.1.0.12
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.10
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	brad_2004-05-14:1.1.1.1
	brad:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2015.11.06.22.28.29;	author sthen;	state Exp;
branches;
next	1.3;
commitid	4ni4D6u36mcuFV1W;

1.3
date	2008.05.17.09.32.16;	author espie;	state Exp;
branches
	1.3.32.1;
next	1.2;

1.2
date	2007.03.29.13.43.53;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.14.05.33.57;	author brad;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.14.05.33.57;	author brad;	state Exp;
branches;
next	;

1.3.32.1
date	2015.11.12.13.06.48;	author jasper;	state Exp;
branches;
next	;
commitid	dUxoBTuucapicQcU;


desc
@@


1.4
log
@add security fixes to graphics/jasper, from Slackware via patrick keshishian

CVE-2014-8137: double-free
CVE-2014-8138: heap-based buffer overflow
CVE-2014-8157: off-by-one
CVE-2014-8158: multiple stack-based buffer overflows
CVE-2014-9029: multiple off-by-one
@
text
@$OpenBSD: patch-src_libjasper_jpc_jpc_dec_c,v 1.3 2008/05/17 09:32:16 espie Exp $

Security fixes from Slackware:
	CVE-2014-8157: off-by-one
	CVE-2014-9029: multiple off-by-one

--- src/libjasper/jpc/jpc_dec.c.orig	Fri Jan 19 13:43:07 2007
+++ src/libjasper/jpc/jpc_dec.c	Thu Oct 29 22:08:08 2015
@@@@ -449,7 +449,7 @@@@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_
 
 	if (dec->state == JPC_MH) {
 
-		compinfos = jas_malloc(dec->numcomps * sizeof(jas_image_cmptparm_t));
+		compinfos = jas_alloc2(dec->numcomps, sizeof(jas_image_cmptparm_t));
 		assert(compinfos);
 		for (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;
 		  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {
@@@@ -489,7 +489,7 @@@@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_
 		dec->curtileendoff = 0;
 	}
 
-	if (JAS_CAST(int, sot->tileno) > dec->numtiles) {
+	if (JAS_CAST(int, sot->tileno) >= dec->numtiles) {
 		jas_eprintf("invalid tile number in SOT marker segment\n");
 		return -1;
 	}
@@@@ -692,7 +692,7 @@@@ static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_ti
 			tile->realmode = 1;
 		}
 		tcomp->numrlvls = ccp->numrlvls;
-		if (!(tcomp->rlvls = jas_malloc(tcomp->numrlvls *
+		if (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,
 		  sizeof(jpc_dec_rlvl_t)))) {
 			return -1;
 		}
@@@@ -764,7 +764,7 @@@@ rlvl->bands = 0;
 			  rlvl->cbgheightexpn);
 
 			rlvl->numbands = (!rlvlno) ? 1 : 3;
-			if (!(rlvl->bands = jas_malloc(rlvl->numbands *
+			if (!(rlvl->bands = jas_alloc2(rlvl->numbands,
 			  sizeof(jpc_dec_band_t)))) {
 				return -1;
 			}
@@@@ -797,7 +797,7 @@@@ rlvl->bands = 0;
 
 				assert(rlvl->numprcs);
 
-				if (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_dec_prc_t)))) {
+				if (!(band->prcs = jas_alloc2(rlvl->numprcs, sizeof(jpc_dec_prc_t)))) {
 					return -1;
 				}
 
@@@@ -834,7 +834,7 @@@@ rlvl->bands = 0;
 			if (!(prc->numimsbstagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {
 				return -1;
 			}
-			if (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_dec_cblk_t)))) {
+			if (!(prc->cblks = jas_alloc2(prc->numcblks, sizeof(jpc_dec_cblk_t)))) {
 				return -1;
 			}
 
@@@@ -1181,7 +1181,7 @@@@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_
 		return -1;
 	}
 
-	if (!(dec->cmpts = jas_malloc(dec->numcomps * sizeof(jpc_dec_cmpt_t)))) {
+	if (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {
 		return -1;
 	}
 
@@@@ -1204,7 +1204,7 @@@@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_
 	dec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);
 	dec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);
 	dec->numtiles = dec->numhtiles * dec->numvtiles;
-	if (!(dec->tiles = jas_malloc(dec->numtiles * sizeof(jpc_dec_tile_t)))) {
+	if (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {
 		return -1;
 	}
 
@@@@ -1228,7 +1228,7 @@@@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_
 		tile->pkthdrstreampos = 0;
 		tile->pptstab = 0;
 		tile->cp = 0;
-		if (!(tile->tcomps = jas_malloc(dec->numcomps *
+		if (!(tile->tcomps = jas_alloc2(dec->numcomps,
 		  sizeof(jpc_dec_tcomp_t)))) {
 			return -1;
 		}
@@@@ -1280,7 +1280,7 @@@@ static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_
 	jpc_coc_t *coc = &ms->parms.coc;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
+	if (JAS_CAST(int, coc->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in COC marker segment\n");
 		return -1;
 	}
@@@@ -1306,7 +1306,7 @@@@ static int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_
 	jpc_rgn_t *rgn = &ms->parms.rgn;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, rgn->compno) > dec->numcomps) {
+	if (JAS_CAST(int, rgn->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in RGN marker segment\n");
 		return -1;
 	}
@@@@ -1355,7 +1355,7 @@@@ static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_
 	jpc_qcc_t *qcc = &ms->parms.qcc;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
+	if (JAS_CAST(int, qcc->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in QCC marker segment\n");
 		return -1;
 	}
@@@@ -1466,7 +1466,9 @@@@ static int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_
 	dec = 0;
 
 	jas_eprintf("warning: ignoring unknown marker segment\n");
-	jpc_ms_dump(ms, stderr);
+	if (jas_getdbglevel() >= 1) {
+		jpc_ms_dump(ms, stderr);
+	}
 	return 0;
 }
 
@@@@ -1489,7 +1491,7 @@@@ static jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t n
 	cp->numlyrs = 0;
 	cp->mctid = 0;
 	cp->csty = 0;
-	if (!(cp->ccps = jas_malloc(cp->numcomps * sizeof(jpc_dec_ccp_t)))) {
+	if (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {
 		return 0;
 	}
 	if (!(cp->pchglist = jpc_pchglist_create())) {
@@@@ -2048,7 +2050,7 @@@@ jpc_streamlist_t *jpc_streamlist_create()
 	}
 	streamlist->numstreams = 0;
 	streamlist->maxstreams = 100;
-	if (!(streamlist->streams = jas_malloc(streamlist->maxstreams *
+	if (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,
 	  sizeof(jas_stream_t *)))) {
 		jas_free(streamlist);
 		return 0;
@@@@ -2068,8 +2070,8 @@@@ int jpc_streamlist_insert(jpc_streamlist_t *streamlist
 	/* Grow the array of streams if necessary. */
 	if (streamlist->numstreams >= streamlist->maxstreams) {
 		newmaxstreams = streamlist->maxstreams + 1024;
-		if (!(newstreams = jas_realloc(streamlist->streams,
-		  (newmaxstreams + 1024) * sizeof(jas_stream_t *)))) {
+		if (!(newstreams = jas_realloc2(streamlist->streams,
+		  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {
 			return -1;
 		}
 		for (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {
@@@@ -2155,8 +2157,7 @@@@ int jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)
 {
 	jpc_ppxstabent_t **newents;
 	if (tab->maxents < maxents) {
-		newents = (tab->ents) ? jas_realloc(tab->ents, maxents *
-		  sizeof(jpc_ppxstabent_t *)) : jas_malloc(maxents * sizeof(jpc_ppxstabent_t *));
+		newents = jas_realloc2(tab->ents, maxents, sizeof(jpc_ppxstabent_t *));
 		if (!newents) {
 			return -1;
 		}
@


1.3
log
@tidy up a few warnings.
with help from naddy@@
@
text
@d1 8
a8 3
$OpenBSD: patch-src_libjasper_jpc_jpc_dec_c,v 1.2 2007/03/29 13:43:53 jasper Exp $
--- src/libjasper/jpc/jpc_dec.c.orig	Fri Jan 19 22:43:07 2007
+++ src/libjasper/jpc/jpc_dec.c	Fri May 16 21:35:28 2008
d18 9
d90 27
@


1.3.32.1
log
@add security fixes to graphics/jasper, from Slackware via patrick keshishian

CVE-2014-8137: double-free
CVE-2014-8138: heap-based buffer overflow
CVE-2014-8157: off-by-one
CVE-2014-8158: multiple stack-based buffer overflows
CVE-2014-9029: multiple off-by-one
@
text
@d1 3
a3 8
$OpenBSD: patch-src_libjasper_jpc_jpc_dec_c,v 1.4 2015/11/06 22:28:29 sthen Exp $

Security fixes from Slackware:
	CVE-2014-8157: off-by-one
	CVE-2014-9029: multiple off-by-one

--- src/libjasper/jpc/jpc_dec.c.orig	Fri Jan 19 13:43:07 2007
+++ src/libjasper/jpc/jpc_dec.c	Thu Oct 29 22:08:08 2015
a12 9
@@@@ -489,7 +489,7 @@@@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_
 		dec->curtileendoff = 0;
 	}
 
-	if (JAS_CAST(int, sot->tileno) > dec->numtiles) {
+	if (JAS_CAST(int, sot->tileno) >= dec->numtiles) {
 		jas_eprintf("invalid tile number in SOT marker segment\n");
 		return -1;
 	}
a75 27
@@@@ -1280,7 +1280,7 @@@@ static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_
 	jpc_coc_t *coc = &ms->parms.coc;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
+	if (JAS_CAST(int, coc->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in COC marker segment\n");
 		return -1;
 	}
@@@@ -1306,7 +1306,7 @@@@ static int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_
 	jpc_rgn_t *rgn = &ms->parms.rgn;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, rgn->compno) > dec->numcomps) {
+	if (JAS_CAST(int, rgn->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in RGN marker segment\n");
 		return -1;
 	}
@@@@ -1355,7 +1355,7 @@@@ static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_
 	jpc_qcc_t *qcc = &ms->parms.qcc;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
+	if (JAS_CAST(int, qcc->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in QCC marker segment\n");
 		return -1;
 	}
@


1.2
log
@update myself to 1.900.1

ok ajacoutot@@
@
text
@d1 75
a75 3
$OpenBSD: patch-src_libjasper_jpc_jpc_dec_c,v 1.1.1.1 2004/05/14 05:33:57 brad Exp $
--- src/libjasper/jpc/jpc_dec.c.orig	Tue Mar 27 16:21:06 2007
+++ src/libjasper/jpc/jpc_dec.c	Tue Mar 27 16:22:07 2007
d87 39
@


1.1
log
@Initial revision
@
text
@d1 4
a4 4
$OpenBSD$
--- src/libjasper/jpc/jpc_dec.c.orig	2004-02-08 20:34:40.000000000 -0500
+++ src/libjasper/jpc/jpc_dec.c	2004-04-22 21:37:19.000000000 -0400
@@@@ -1472,7 +1472,9 @@@@ static int jpc_dec_process_unk(jpc_dec_t
d7 1
a7 1
 	fprintf(stderr, "warning: ignoring unknown marker segment\n");
@


1.1.1.1
log
@add jasper 1.701.0
--
The JasPer Project is a collaborative effort between Image Power,
Inc.  and the University of British Columbia. The objective of this
project is to develop a software-based reference implementation of
the codec specified in the JPEG-2000 Part-1 standard (i.e., ISO/IEC
15444-1). This software has also been submitted to the ISO for
inclusion in the JPEG-2000 Part-5 standard (as an official reference
implementation).
@
text
@@
