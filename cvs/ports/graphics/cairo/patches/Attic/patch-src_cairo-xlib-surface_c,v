head	1.11;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@# @;


1.11
date	2016.12.09.20.55.52;	author ajacoutot;	state dead;
branches;
next	1.10;
commitid	6VjExSMNf6IBWkvF;

1.10
date	2016.06.23.07.34.07;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	pz1ahK0hfMcui4J6;

1.9
date	2008.05.16.17.52.18;	author eric;	state dead;
branches;
next	1.8;

1.8
date	2008.01.22.20.30.01;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.08.22.39.36;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.24.17.47.07;	author steven;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.21.12.35.33;	author steven;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.18.14.48.45;	author kurt;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.06.21.29.06;	author espie;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2006.06.10.12.26.19;	author steven;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2006.05.10.21.34.17;	author brad;	state Exp;
branches;
next	;

1.2.2.1
date	2007.05.05.07.54.23;	author sturm;	state Exp;
branches;
next	;

1.3.2.1
date	2007.05.05.07.54.56;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to cairo-1.14.8.

ok eric@@ (maintainer)
@
text
@$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.10 2016/06/23 07:34:07 ajacoutot Exp $

From d69dd6b341594c338fa6c7b327fd7f201eb37bc1 Mon Sep 17 00:00:00 2001
From: Uli Schlachter <psychon@@znc.in>
Date: Sat, 18 Jun 2016 15:08:52 +0200
Subject: xlib: Fix double free in _get_image_surface()

--- src/cairo-xlib-surface.c.orig	Tue Oct 27 22:04:30 2015
+++ src/cairo-xlib-surface.c	Thu Jun 23 09:27:19 2016
@@@@ -807,6 +807,7 @@@@ _get_image_surface (cairo_xlib_surface_t    *surface,
 	    }
 
 	    cairo_surface_destroy (&image->base);
+	    image = NULL;
 	}
     }
 
@@@@ -1011,7 +1012,8 @@@@ _get_image_surface (cairo_xlib_surface_t    *surface,
     cairo_device_release (&display->base);
 
     if (unlikely (status)) {
-	cairo_surface_destroy (&image->base);
+	if (image)
+	    cairo_surface_destroy (&image->base);
 	return _cairo_surface_create_in_error (status);
     }
 
@


1.10
log
@xlib: Fix double free in _get_image_surface() - from upstream

ok eric@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.9
log
@update to cairo 1.6.4 and zap all our patches.

ok matthieu@@, steven@@.
@
text
@d1 15
a15 4
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.8 2008/01/22 20:30:01 eric Exp $
--- src/cairo-xlib-surface.c.orig	Tue Jan 15 00:23:07 2008
+++ src/cairo-xlib-surface.c	Sun Jan 20 00:09:24 2008
@@@@ -494,6 +494,255 @@@@ _swap_ximage_to_native (XImage *ximage)
a16 1
 }
d18 8
a25 363
+
+#if 0
+static void _set_optimal_cmap(Display *dpy, Colormap cmap) {
+    int i, r, g, b;
+    XColor cm[256];
+
+    for (i = 0; i < 256; i++) {
+	r = i >> 5;
+	g = (i >> 2) & 0x7;
+	b = (i << 1) & 0x7;
+	cm[i].pixel = i;
+	cm[i].flags = DoRed | DoGreen | DoBlue;
+	cm[i].red   = r << 13 | r << 10 | r << 7 | r << 4 | r << 1 | r >> 2;
+	cm[i].green = g << 13 | g << 10 | g << 7 | g << 4 | g << 1 | g >> 2;
+	cm[i].blue  = b << 13 | b << 10 | b << 7 | b << 4 | b << 1 | b >> 2;
+    }
+    XStoreColors(dpy, cmap, cm, 256);
+}
+#endif
+
+struct clut_r3g3b2 {
+    struct clut_r3g3b2 *next;
+    Display            *dpy;
+    Colormap           cmap;
+    uint32_t           clut[256];
+    unsigned char      ilut[256];
+};
+
+static struct clut_r3g3b2 * _get_clut_r3g3b2(Display *dpy, Colormap cmap) {
+    static struct clut_r3g3b2 *first = NULL;
+    int i,j, min, d;
+    struct clut_r3g3b2 *clut;
+    unsigned char r,g,b, r2,g2,b2;
+    
+    clut = first;
+    while(clut) {
+	if ( clut->dpy == dpy && clut->cmap == cmap )
+	    return clut;
+	clut = clut->next;
+    }
+    
+    clut = calloc(1, sizeof(*clut));
+    if(clut == NULL) {
+	fprintf(stderr, "cairo-xlib: cannot allocate clut_r3g3b2\n");
+	return NULL;
+    }
+    clut->next = first;
+    clut->dpy = dpy;
+    clut->cmap = cmap;
+    first = clut;
+
+    /* Construct the clut from Colormap */
+    for (i = 0; i < 256; i++) {
+	XColor xcol;
+	xcol.pixel = i;
+	XQueryColor(dpy, cmap, &xcol);
+	clut->clut[i] = ( ( ((uint32_t)xcol.red   & 0xff00 ) << 8) |
+			  ( ((uint32_t)xcol.green & 0xff00 ) ) |
+			  ( ((uint32_t)xcol.blue  & 0xff00 ) >> 8) );
+    }
+    /*
+      
+    Find the best matching color in the colormap for all r3g3b2
+    values. The distance is maybe not perceptively valid, but it
+    should not be too bad.
+    
+    */
+    for (i = 0; i < 256; i++) {
+	r = i >> 5;
+	g = (i >> 2) & 0x7;
+	b = (i << 1) & 0x7;
+	min = 255;
+	for(j = 0; j < 256; j++) {
+	    r2 = (clut->clut[j] & 0xff0000) >> 21;
+	    g2 = (clut->clut[j] & 0x00ff00) >> 13;
+	    b2 = (clut->clut[j] & 0x0000ff) >> 5;
+	    if ( r2 == r && g2 == g && (b2 & 0x6) == b ) {
+		clut->ilut[i] = j;
+		break;
+	    }
+	    /*
+	      Squares make higher bits much more important than lower
+	      ones.
+	    */
+	    d  = (r2 ^ r) * (r2 ^ r);
+	    d += (g2 ^ g) * (g2 ^ g);
+	    d += (b2 ^ b) * (b2 ^ b);
+	    if(d < min) {
+		clut->ilut[i] = j;
+		min = d;
+	    }
+	}
+    }
+    
+    return clut;
+}
+
+static const char * _visualClass[] = {
+    "StaticGray",
+    "GrayScale",
+    "StaticColor",
+    "PseudoColor",
+    "TrueColor",
+    "DirectColor"
+};
+
+
+static void _print_Visual(Visual *v) {
+    if(v)
+	fprintf(stderr,
+		"  Visual: %p\n"
+		"    class: %s\n"
+		"    bpRGB: %i\n"
+		"    map_entries: %i\n"
+		"    RGB masks: %08lx %08lx %08lx\n",
+		v,
+		_visualClass[v->class],
+		v->bits_per_rgb,
+		v->map_entries,
+		v->red_mask, v->green_mask, v->blue_mask);
+    else
+	fprintf(stderr, "  Visual: NULL\n");
+}
+
+
+#if 0
+static void _print_XImage(XImage *x)
+{
+    const char * format[] = { "XYBitmap", "XYPixmap", "ZPixmap" };
+    if(XImage)
+	fprintf(stderr, 
+		"  XImage: %p\n"
+		"    size: %ix%i\n"
+		"    xoffset: %i\n"
+		"    format: %s\n"
+		"    depth: %i\n"
+		"    bpp: %i\n"
+		"    stride: %i\n"
+                "    RGB masks: %08lx %08lx %08lx\n"
+		"    bitmap_unit: %i\n"
+		"    bitmap_pad: %i\n",
+		x,
+		x->width,
+		x->height,
+		x->xoffset,
+		format[x->format],
+		x->depth,
+		x->bits_per_pixel,
+		x->bytes_per_line,
+		x->red_mask, x->green_mask, x->blue_mask,
+		x->bitmap_unit, x->bitmap_pad);
+    else
+	fprintf(stderr, "  XImage: NULL\n")
+}
+
+const char * _cairoFormats[] = { "ARGB32", "RGB24", "A8", "A1" };
+
+static void _print_cairo_image_surface(cairo_image_surface_t *i)
+{
+    if(i)
+	fprintf(stderr,
+		"  CairoImage: %p\n"
+		"    size: %ix%i\n"
+		"    format: %s\n"
+		"    depth: %i\n"
+		"    stride: %i\n",
+		i,
+		i->width,
+		i->height,
+		_cairoFormats[i->format],
+		i->depth,
+		i->stride);
+    else
+	fprintf(stderr, "  CairoImage: NULL\n")
+}
+
+static void _print_cairo_format_masks(cairo_format_masks_t *m)
+{
+    if(m)
+	printf(stderr,
+	       "  CairoFormatMask: %p\n"
+	       "    bpp: %i\n"
+	       "    ARGB masks: %lx %lx %lx %lx\n",
+	       m,
+	       m->bpp, m->alpha_mask,
+	       m->red_mask, m->green_mask, m->blue_mask);
+    else
+	fprintf(stderr, "  CairoFormatMasks: NULL\n")
+}
+#endif
+
+#define WORKAROUND_NONE           0
+#define WORKAROUND_8BIT_GRAYLEVEL 1
+#define WORKAROUND_8BIT_PALETTE   2
+#define WORKAROUND_R5G6B5         3
+
+static const char *workarounds[] = {
+    "NONE",
+    "8BIT_GRAYLEVEL",
+    "8BIT_PALETTE",
+    "R5G6B5"
+};
+
+static void
+_print_XRenderPictFormat(XRenderPictFormat *f)
+{
+    if(f)
+	fprintf(stderr,
+		"  XRenderPictFormat: %p\n"
+		"    format: %lu\n"
+                "    type: %i\n"
+		"    depth: %i\n"
+		"    red: %hx mask: %hx\n"
+		"    green: %hx mask: %hx\n"
+		"    blue: %hx mask: %hx\n"
+		"    alpha: %hx mask: %hx\n",
+		f,
+		f->id, f->type, f->depth,
+		f->direct.red, f->direct.redMask,
+		f->direct.green, f->direct.greenMask,
+		f->direct.blue, f->direct.blueMask,
+		f->direct.alpha, f->direct.alphaMask
+		);
+    else
+	fprintf(stderr,
+		"  XRenderPictFormat: NULL\n");
+}
+
+static void
+_print_surface(cairo_xlib_surface_t *s)
+{
+    if(!s) {
+	fprintf(stderr, "CairoXlibSurface: NULL\n");
+	    return;
+    }
+    fprintf(stderr,
+	    "CairoXlibSurface: %p\n"
+	    "  render version: %i.%i\n"
+	    "  width: %i\n"
+	    "  height: %i\n"
+	    "  depth: %i\n",
+	    s,
+	    s->render_major, s->render_minor,
+	    s->width, s->height, s->depth);
+    _print_Visual(s->visual);
+    _print_XRenderPictFormat(s->xrender_format);
+}
+
+
 static cairo_status_t
 _get_image_surface (cairo_xlib_surface_t    *surface,
 		    cairo_rectangle_int16_t *interest_rect,
@@@@ -652,9 +901,14 @@@@ _get_image_surface (cairo_xlib_surface_t    *surface,
 						 ximage->bytes_per_line);
 	if (image->base.status)
 	    goto FAIL;
+	if (surface->workaround != WORKAROUND_NONE) {
+	    fprintf(stderr, "cancelling workaround %s\n", workarounds[surface->workaround]);
+	    surface->workaround = WORKAROUND_NONE;
+	}
     }
     else
     {
+#if 0
 	/*
 	 * XXX This can't work.  We must convert the data to one of the
 	 * supported pixman formats.  Pixman needs another function
@@@@ -669,6 +923,98 @@@@ _get_image_surface (cairo_xlib_surface_t    *surface,
 						    ximage->bytes_per_line);
 	if (image->base.status)
 	    goto FAIL;
+#else
+	/*
+	 * Otherwise, we construct a buffer containing RGB24 data
+	 * using the specified workaround.
+	 */
+	uint32_t *data, *dst, *clut;
+	uint8_t  *src8;
+	uint16_t *src16;
+	int i,j;
+	
+	if(surface->visual == NULL) {
+	    fprintf(stderr, "cairo-xlib: no visual for surface\n");
+	    goto FAIL;
+	}
+
+	if (surface->workaround == WORKAROUND_NONE) {
+	    fprintf(stderr, "cairo-xlib: no workaround for surface\n");
+	    _print_surface(surface);
+	    goto FAIL;
+	}
+	
+	data = (uint32_t*)malloc(ximage->height * ximage->width * 4);
+	if(data == NULL) {
+	    fprintf(stderr, "cairo-xlib: cannot allocate ARGB buffer\n");
+	    goto FAIL;
+	}
+	
+	switch (surface->workaround) {
+	    
+	case WORKAROUND_8BIT_GRAYLEVEL:
+
+	    dst = data;
+	    for(j = 0; j < ximage->height; j++) {
+		src8 = (uint8_t *) (ximage->data + ximage->bytes_per_line * j);
+		for(i = 0; i < ximage->width; i++) {
+		    *dst++ = (*src8 << 16) | (*src8 << 8) | *src8;
+		    src8++;
+		}
+	    }
+	    break;
+	    
+	case WORKAROUND_8BIT_PALETTE:
+
+	    if(surface->clut == NULL) {
+		surface->clut = _get_clut_r3g3b2(
+		    surface->dpy,
+		    DefaultColormapOfScreen(surface->screen));
+	    }
+
+	    if(surface->clut == NULL) {
+		free(data);
+		goto FAIL;
+	    }
+
+	    clut = surface->clut->clut;
+	    src8 = (uint8_t*) ximage->data;
+	    dst = data;
+	    for(j = 0; j < ximage->height; j++) {
+		for(i = 0; i < ximage->width; i++)
+		    *dst++ = clut[src8[i]];
+		src8 += ximage->bytes_per_line;
+	    }
+	    break;
+
+	case WORKAROUND_R5G6B5:
+
+	    src16 = (uint16_t*)ximage->data;
+	    dst = data;
+	    for(j = 0; j < ximage->height; j++) {
+		for(i = 0; i < ximage->width; i++) {
+		    *dst++ = ( ( ((src16[i] & 0xf800) << 8) | ((src16[i] & 0xe000) << 3) ) |
+			       ( ((src16[i] & 0x07e0) << 5) | ((src16[i] & 0x0600) >> 1) ) |
+			       ( ((src16[i] & 0x001f) << 3) | ((src16[i] & 0x001f) >> 2) ) );
+		}
+		src16 += ximage->bytes_per_line / sizeof(*src16);
+	    }
+	    break;
+	default:
+	    fprintf(stderr, "cairo-xlib: dunno what to do with surface\n");
+	    _print_surface(surface);
+	    goto FAIL;
+	}
+	free(ximage->data);
+	image = (cairo_image_surface_t*)
+	    cairo_image_surface_create_for_data((unsigned char *)data, CAIRO_FORMAT_RGB24, ximage->width, ximage->height, ximage->width*4);
+	
+	if (image->base.status) {
+	    fprintf(stderr, "cairo-xlib: cairo_image_surface_create_for_data failed\n");
+	    free(data);
+	    goto FAIL;
+	}
+#endif
a26 181
 
     /* Let the surface take ownership of the data */
@@@@ -770,6 +1116,30 @@@@ _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *s
     return CAIRO_STATUS_SUCCESS;
 }
 
+static int
+make_space_for(unsigned char ** buf, int *size, int *stride, int width, int height, int Bpp) {
+    unsigned char * data;
+    int l;
+
+    *stride = width * Bpp;
+    if(*stride%4)
+	*stride += 4 - *stride % 4;
+    l = (*stride * height);
+    if (*size < l) {
+	if(*buf)
+	    data = realloc(*buf, l);
+	else
+	    data = malloc(l);
+	if(data) {
+	    *buf = data;
+	    *size = l;
+	} else {
+	    return -1;
+	}
+    } 
+    return 0;
+}
+
 static cairo_status_t
 _draw_image_surface (cairo_xlib_surface_t   *surface,
 		     cairo_image_surface_t  *image,
@@@@ -785,19 +1155,98 @@@@ _draw_image_surface (cairo_xlib_surface_t   *surface,
     int native_byte_order = _native_byte_order_lsb () ? LSBFirst : MSBFirst;
     cairo_status_t status;
 
+    static unsigned char *buf = NULL;
+    static int size = 0;
+    int i, j, depth, stride;
+    unsigned char *data, *ilut;
+    uint32_t *src;
+    uint8_t *dst8;
+    uint16_t *dst16;
+
     pixman_format_get_masks (pixman_image_get_format (image->pixman_image),
 			     &bpp, &alpha, &red, &green, &blue);
 
+
+    switch(surface->workaround) {
+
+    case WORKAROUND_NONE:
+	/* Default behaviour is supposed to work */
+	stride = image->stride;
+	depth = image->depth;
+	data = image->data;
+	break;
+
+    case WORKAROUND_8BIT_GRAYLEVEL:
+
+	if (make_space_for(&buf, &size, &stride, image->width, image->height, 1))
+	    return CAIRO_STATUS_NO_MEMORY;
+	data = buf;
+	
+	for(j=0;j<image->height;j++) {
+	    src = (uint32_t*)(image->data);
+	    dst8 = data + j * stride;
+	    for(i=0;i<image->width;i++) {
+		dst8[i] = ( 30 * ((*src >> 16) & 0xff) +
+			    59 * ((*src >> 8) & 0xff) +
+			    11 * (*src & 0xff) ) / 100;
+		src++;
+	    }
+	}
+	
+	alpha = red = green = blue = 0;
+	depth = bpp = 8;
+	break;
+	
+    case WORKAROUND_8BIT_PALETTE:
+	
+	if (make_space_for(&buf, &size, &stride, image->width, image->height, 1))
+	    return CAIRO_STATUS_NO_MEMORY;
+	data = buf;
+	src = (uint32_t*)image->data;
+	ilut = surface->clut->ilut;
+	for(j=0;j<image->height;j++) {
+	    dst8 = data + j * stride;
+	    for(i=0;i<image->width;i++) {
+		dst8[i] = ilut[ ((*src >> 16) & 0xe0) |
+				((*src >> 11) & 0x1c) |
+				((*src >> 6)  & 0x03) ];
+		src++;
+	    }
+	}
+	alpha = red = green = blue = 0;
+	depth = bpp = 8;
+	break;
+
+    case WORKAROUND_R5G6B5:
+
+	if (make_space_for(&buf, &size, &stride, image->width, image->height, 2))
+	    return CAIRO_STATUS_NO_MEMORY;
+	data = buf;
+	src = (uint32_t*)image->data;
+	for(j=0;j<image->height;j++) {
+	    dst16 = (uint16_t*)(data + j * stride);
+	    for(i=0;i<image->width;i++) {
+		dst16[i] = ( ((*src >> 8) & 0xf800) |
+			     ((*src >> 5) & 0x07e0) |
+			     ((*src >> 3) & 0x001f) );
+		src++;
+	    }
+	}
+	alpha = 0; red = 0xf800; green = 0x07e0; blue = 0x001f;
+	depth = bpp = 16;
+	break;
+    }
+    
     ximage.width = image->width;
     ximage.height = image->height;
     ximage.format = ZPixmap;
-    ximage.data = (char *)image->data;
+    ximage.data = data;
     ximage.byte_order = native_byte_order;
     ximage.bitmap_unit = 32;	/* always for libpixman */
     ximage.bitmap_bit_order = native_byte_order;
     ximage.bitmap_pad = 32;	/* always for libpixman */
-    ximage.depth = image->depth;
-    ximage.bytes_per_line = image->stride;
+    ximage.depth = depth;
+    ximage.bytes_per_line = stride;
     ximage.bits_per_pixel = bpp;
     ximage.red_mask = red;
     ximage.green_mask = green;
@@@@ -1947,6 +2396,7 @@@@ _cairo_xlib_surface_create_internal (Display		       *
 				     int			height,
 				     int			depth)
 {
+    static int _trace = -1;
     cairo_xlib_surface_t *surface;
     cairo_xlib_screen_info_t *screen_info;
 
@@@@ -2044,7 +2494,38 @@@@ _cairo_xlib_surface_create_internal (Display		       *
     surface->have_clip_rects = FALSE;
     surface->clip_rects = surface->embedded_clip_rects;
     surface->num_clip_rects = 0;
+    
+    surface->clut = NULL;
+    surface->workaround = WORKAROUND_NONE;
 
+    if (visual) {
+	/* Install the correct workaround */
+	switch (visual->class) {
+	case StaticGray:
+	case GrayScale:
+	    surface->workaround = WORKAROUND_8BIT_GRAYLEVEL;
+	    break;
+	case PseudoColor:
+	case StaticColor:
+	    surface->workaround = WORKAROUND_8BIT_PALETTE;
+	    break;
+	case TrueColor:
+	    if (visual->red_mask   == 0xf800 &&
+		visual->green_mask == 0x07e0 &&
+		visual->blue_mask  == 0x001f) {
+		surface->workaround = WORKAROUND_R5G6B5;
+	    }
+	}
+    }
+
+    if(_trace == -1)
+	_trace = getenv("DEBUG_CAIRO_XLIB") ? 1 : 0;
+    if(_trace) {
+	fprintf(stderr, "New surface with workaround %s\n",
+		workarounds[surface->workaround]);
+	_print_surface(surface);
+    }
+    
     return (cairo_surface_t *) surface;
 }
@


1.8
log
@update to 1.4.14

ok brad@@, jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.7 2007/12/08 22:39:36 eric Exp $
@


1.7
log
@- update to 1.4.12
- change my email

ok steven@@, martynas@@
@
text
@d1 3
a3 3
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.6 2007/07/24 17:47:07 steven Exp $
--- src/cairo-xlib-surface.c.orig	Tue Nov 27 07:20:12 2007
+++ src/cairo-xlib-surface.c	Fri Nov 30 22:14:14 2007
d507 1
a507 1
@@@@ -1946,6 +2395,7 @@@@ _cairo_xlib_surface_create_internal (Display		       *
d515 1
a515 1
@@@@ -2043,7 +2493,38 @@@@ _cairo_xlib_surface_create_internal (Display		       *
@


1.6
log
@update to cairo 1.4.10

"looks ok" maintainer Eric Faurot, also tested by brad and simon, ok simon
@
text
@d1 3
a3 3
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.5 2007/05/21 12:35:33 steven Exp $
--- src/cairo-xlib-surface.c.orig	Wed Jun 27 20:05:33 2007
+++ src/cairo-xlib-surface.c	Sun Jul  8 12:20:08 2007
d507 1
a507 1
@@@@ -1945,6 +2394,7 @@@@ _cairo_xlib_surface_create_internal (Display		       *
d515 1
a515 1
@@@@ -2042,7 +2492,38 @@@@ _cairo_xlib_surface_create_internal (Display		       *
@


1.5
log
@update to cairo 1.4.6

from maintainer Eric Faurot

ok jasper@@
@
text
@d1 4
a4 4
$OpenBSD$
--- src/cairo-xlib-surface.c.orig	Tue May  1 19:39:47 2007
+++ src/cairo-xlib-surface.c	Sat May  5 18:47:44 2007
@@@@ -446,6 +446,255 @@@@ _swap_ximage_to_native (XImage *ximage)
d260 1
a260 1
@@@@ -604,9 +853,14 @@@@ _get_image_surface (cairo_xlib_surface_t    *surface,
d275 1
a275 1
@@@@ -621,6 +875,98 @@@@ _get_image_surface (cairo_xlib_surface_t    *surface,
d374 1
a374 1
@@@@ -698,6 +1044,30 @@@@ _cairo_xlib_surface_ensure_gc (cairo_xlib_surface_t *s
d405 1
a405 1
@@@@ -713,19 +1083,98 @@@@ _draw_image_surface (cairo_xlib_surface_t   *surface,
d507 1
a507 1
@@@@ -1793,6 +2242,7 @@@@ _cairo_xlib_surface_create_internal (Display		       *
d515 1
a515 1
@@@@ -1885,7 +2335,38 @@@@ _cairo_xlib_surface_create_internal (Display		       *
@


1.4
log
@fix for SVG image crashes seen in firefox from mantainer Eric Faurot <eric
. faurot at gmail dot com>
@
text
@d1 4
a4 23
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.3 2007/02/06 21:29:06 espie Exp $
--- src/cairo-xlib-surface.c.orig	Thu Nov  2 23:53:40 2006
+++ src/cairo-xlib-surface.c	Sat Mar 17 14:20:44 2007
@@@@ -81,6 +81,8 @@@@ _cairo_xlib_surface_show_glyphs (void   
 
 #define CAIRO_ASSUME_PIXMAP	20
 
+struct clut_r3g3b2;
+
 struct _cairo_xlib_surface {
     cairo_surface_t base;
 
@@@@ -126,6 +128,9 @@@@ struct _cairo_xlib_surface {
     int num_clip_rects;
 
     XRenderPictFormat *xrender_format;
+
+    struct clut_r3g3b2 *clut;
+    int workaround;
 };
 
 #define CAIRO_SURFACE_RENDER_AT_LEAST(surface, major, minor)	\
@@@@ -504,6 +509,254 @@@@ _swap_ximage_to_native (XImage *ximage)
d8 1
d260 1
a260 3
@@@@ -652,25 +905,106 @@@@ _get_image_surface (cairo_xlib_surface_t
 						 ximage->width,
 						 ximage->height,
a261 1
+	
d271 1
d273 8
a280 4
-	 * XXX This can't work.  We must convert the data to one of the
-	 * supported pixman formats.  Pixman needs another function
-	 * which takes data in an arbitrary format and converts it
-	 * to something supported by that library.
d283 1
a283 1
 	 */
d362 1
a362 7
 	image = (cairo_image_surface_t*)
-	    _cairo_image_surface_create_with_masks ((unsigned char *) ximage->data,
-						    &masks,
-						    ximage->width,
-						    ximage->height,
-						    ximage->bytes_per_line);
-	if (image->base.status)
d368 1
a368 1
 	    goto FAIL;
d370 1
d374 2
a375 2
@@@@ -743,29 +1077,132 @@@@ _cairo_xlib_surface_ensure_gc (cairo_xli
     _cairo_xlib_surface_set_gc_clip_rects (surface);
d405 4
a408 3
 		     int                    dst_x,
 		     int                    dst_y)
 {
d411 1
a411 4
     XImage ximage;
-    unsigned int bpp, alpha, red, green, blue;
+    unsigned int bpp, alpha, red, green, blue, stride, depth;
+    int i, j;
d416 1
a416 2
     int native_byte_order = _native_byte_order_lsb () ? LSBFirst : MSBFirst;
 
d419 2
a420 2
+    
+    
d422 1
a422 1
 
a490 1
+
d507 9
a515 1
@@@@ -1890,7 +2327,35 @@@@ _cairo_xlib_surface_create_internal (Dis
d517 1
a517 1
     surface->clip_rects = NULL;
d519 1
d542 4
a545 2
+    
+    if(getenv("DEBUG_CAIRO_XLIB")) {
@


1.3
log
@update glitz/cairo to current stable versions. New patch from maintainer
Eric Faurot. Some infrastructure tweaks by me.

Appears to work just fine on a variety of display and architectures,
only issue so far is:
- garbled menus with gimp on 8 bits + RENDER (weird combination).
- firefox 2.0 unhappy on 8 bits displays (setting GDK_USE_XFT=0 solves this)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.2 2006/06/10 12:26:19 steven Exp $
d3 1
a3 1
+++ src/cairo-xlib-surface.c	Sun Feb  4 23:47:01 2007
d449 1
a449 1
+	stride = image->width * 4;
@


1.3.2.1
log
@MFC:
fix for SVG image crashes seen in firefox from mantainer Eric Faurot <eric
. faurot at gmail dot com>
@
text
@d1 1
a1 1
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.3 2007/02/06 21:29:06 espie Exp $
d449 1
a449 1
+	stride = image->stride;
@


1.2
log
@- fix the channel mix up,
- improved palette handling (should be faster),
- reorganize the code to make workaround hooks easier,
- add a workaround for the 16bit r5g6b5 pixel case.

this fixes crashes on 16 bit displays with RENDER disabled

from maintainer Eric Faurot, thanks for writing this!

discussed with kurt, bernd, espie.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.1 2006/05/10 21:34:17 brad Exp $
--- src/cairo-xlib-surface.c.orig	Wed Mar 15 16:26:51 2006
+++ src/cairo-xlib-surface.c	Sat Jun  3 18:18:03 2006
@@@@ -72,6 +72,8 @@@@ _native_byte_order_lsb (void);
d13 1
a13 1
@@@@ -117,6 +119,9 @@@@ struct _cairo_xlib_surface {
d16 1
a16 1
     XRenderPictFormat *format;
d23 1
a23 1
@@@@ -416,6 +421,158 @@@@ _swap_ximage_to_native (XImage *ximage)
d68 2
a69 1
+    if(clut == NULL)
d71 1
a71 1
+    
d133 15
a147 6
+static void _print_visual(Visual *v) {
+    printf("Visual: class=%s, bpRGB=%i, CM=%i, r=%lx, g=%lx, b=%lx\n",
+	   _visualClass[v->class],
+	   v->bits_per_rgb,
+	   v->map_entries,
+	   v->red_mask, v->green_mask, v->blue_mask);
d152 2
a153 1
+static void _print_ximage(XImage *x) {
d155 24
a178 10
+    printf("XImage: size=(%i,%i), xoffset=%i, format=%s, depth=%i, bpp=%i, stride=%i\n        r=%lx, g=%lx, b=%lx, unit=%i, pad=%i\n",
+	   x->width,
+	   x->height,
+	   x->xoffset,
+	   format[x->format],
+	   x->depth,
+	   x->bits_per_pixel,
+	   x->bytes_per_line,
+	   x->red_mask, x->green_mask, x->blue_mask,
+	   x->bitmap_unit, x->bitmap_pad);
d183 17
a199 8
+static void _print_cairoimage(cairo_image_surface_t *i) {
+    
+    printf("CairoImage: size=(%i,%i), format=%s, depth=%i, stride=%i\n",
+	   i->width,
+	   i->height,
+	   _cairoFormats[i->format],
+	   i->depth,
+	   i->stride);
d202 12
a213 3
+static void _print_cairomasks(cairo_format_masks_t *m) {
+    printf("CairoFormatMask: bpp=%i, a=%lx, r=%lx, g=%lx, b=%lx\n",
+	   m->bpp, m->alpha_mask, m->red_mask, m->green_mask, m->blue_mask);
d222 53
d276 13
a288 21
 _get_image_surface (cairo_xlib_surface_t   *surface,
 		    cairo_rectangle_t      *interest_rect,
@@@@ -508,7 +665,7 @@@@ _get_image_surface (cairo_xlib_surface_t
 
 	XCopyArea (surface->dpy, surface->drawable, pixmap, surface->gc,
 		   x1, y1, x2 - x1, y2 - y1, 0, 0);
-	
+
 	ximage = XGetImage (surface->dpy,
 			    pixmap,
 			    0, 0,
@@@@ -521,7 +678,7 @@@@ _get_image_surface (cairo_xlib_surface_t
 	return CAIRO_STATUS_NO_MEMORY;
 
     _swap_ximage_to_native (ximage);
-					
+
     /*
      * Compute the pixel format masks from either a visual or a 
      * XRenderFormat, failing we assume the drawable is an
@@@@ -569,20 +726,98 @@@@ _get_image_surface (cairo_xlib_surface_t
d292 2
a293 2
-	/* 
-	 * XXX This can't work.  We must convert the data to one of the 
a296 1
+	/*
d306 1
a306 1
+	    printf("No visual for surface\n");
d311 2
a312 2
+	    printf("No workaround for this pixel format: ");
+	    _print_visual(surface->visual);
d318 1
a318 1
+	    printf("Cannot allocate RGB buffer\n");
a371 1
+	    
d373 2
a374 2
+	    printf("Dunno what to do with: ");
+	    _print_visual(surface->visual);
d381 1
a381 1
-						    ximage->width, 
d388 1
a388 1
+	    printf("Failed!\n");
a391 1
+	
d395 1
a395 1
@@@@ -655,29 +890,130 @@@@ _cairo_xlib_surface_ensure_gc (cairo_xli
d432 4
a435 3
-    int bpp, alpha, red, green, blue;
+    int bpp, alpha, red, green, blue, stride, depth, i, j;
+    unsigned char *data, *c, *ilut;
d440 1
a440 1
     
d443 1
a443 1
     
d446 1
d461 1
a461 1
+	    src = image->data;
d464 3
a466 4
+		/* XXX use correct factor for each channel */
+		dst8[i] = ( ((*src >> 16) & 0xff) +
+			    ((*src >> 8) & 0xff) +
+			    (*src & 0xff) ) / 3;
d480 1
a480 1
+	src = image->data;
d494 1
a494 1
+	
d496 1
d500 1
a500 1
+	src = image->data;
a512 1
+	
d515 1
d522 1
a522 2
-    ximage.bitmap_unit = 32;	/* always for libpixman */
+    ximage.bitmap_unit = 32; /* always for libpixman */
d524 1
a524 1
-    ximage.bitmap_pad = 32;	/* always for libpixman */
a526 1
+    ximage.bitmap_pad = 32; /* always for libpixman */
d532 2
a533 10
@@@@ -685,7 +1021,7 @@@@ _draw_image_surface (cairo_xlib_surface_
     ximage.xoffset = 0;
 
     XInitImage (&ximage);
-    
+
     _cairo_xlib_surface_ensure_gc (surface);
     XPutImage(surface->dpy, surface->drawable, surface->gc,
 	      &ximage, 0, 0, dst_x, dst_y,
@@@@ -1789,6 +2125,29 @@@@ _cairo_xlib_surface_create_internal (Dis
a535 1
 
d538 2
a539 2
+
+    if (surface->format == NULL) {
d557 6
@


1.2.2.1
log
@MFC:
fix for SVG image crashes seen in firefox from mantainer Eric Faurot <eric
. faurot at gmail dot com>
@
text
@d1 1
a1 1
$OpenBSD: patch-src_cairo-xlib-surface_c,v 1.2 2006/06/10 12:26:19 steven Exp $
d362 1
a362 1
+	stride = image->stride;
@


1.1
log
@update to 1.0.4

also adds a simple workaround to support PseudoColor
and StaticColor modes on X11.

From: maintainer
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ src/cairo-xlib-surface.c	Sun Mar 26 21:00:36 2006
d19 1
a19 1
+
d23 1
a23 1
@@@@ -416,6 +421,160 @@@@ _swap_ximage_to_native (XImage *ximage)
d50 1
a50 1
+    unsigned char      clut[256 * 3];
d58 2
a59 2
+    unsigned char *c, r,g,b, r2,g2,b2;
+
a76 1
+    c = clut->clut;
d81 3
a83 4
+	c[0] = xcol.red   / 256;
+	c[1] = xcol.green / 256;
+	c[2] = xcol.blue  / 256;
+	c += 3;
d98 3
a100 4
+	    c = clut->clut + j*3;
+	    r2 = c[0] >> 5;
+	    g2 = c[1] >> 5;
+	    b2 = c[2] >> 5;
a104 1
+
d106 2
a107 4
+	      
+	    Square make higher bits much more important than lower
+	    ones.
+	    
a111 1
+	    
d140 1
a155 1
+
d174 5
d182 1
a182 1
@@@@ -508,7 +667,7 @@@@ _get_image_surface (cairo_xlib_surface_t
d191 1
a191 1
@@@@ -521,7 +680,7 @@@@ _get_image_surface (cairo_xlib_surface_t
d200 1
a200 1
@@@@ -569,20 +728,78 @@@@ _get_image_surface (cairo_xlib_surface_t
d210 2
a211 1
+	 * Otherwise, we construct a buffer containing RGB24 data.
d213 3
a215 2
+	unsigned char *data, *dst, *src, *col, *clut;
+	unsigned int stride;
d222 8
a229 2
+	stride = ximage->width * 4;
+	data = malloc(stride * ximage->height);
d235 5
a239 3
+	switch (surface->visual->class) {
+	case StaticGray:
+	case GrayScale:
d241 1
a241 2
+		src = (unsigned char *) ximage->data + ximage->bytes_per_line * j;
+		dst = data + j * stride;
d243 2
a244 3
+		    dst[1] = dst[2] = dst[3] = *src;
+		    dst += 4;
+		    src++;
d248 3
a250 2
+	case PseudoColor:
+	case StaticColor:
d256 1
a257 1
+		printf("Cannot allocate clut/ilut!\n");
d261 1
d263 13
a275 1
+	    src = (unsigned char *) ximage->data;
a276 1
+		dst = data + j * stride;
d278 3
a280 5
+		    col = clut + (src[i] * 3);
+		    dst[1] = col[0];
+		    dst[2] = col[1];
+		    dst[3] = col[2];
+		    dst += 4;
d282 1
a282 1
+		src += ximage->bytes_per_line;
d285 1
d299 1
a299 1
+	    cairo_image_surface_create_for_data(data, CAIRO_FORMAT_RGB24, ximage->width, ximage->height, stride);
d310 31
a340 1
@@@@ -661,23 +878,67 @@@@ _draw_image_surface (cairo_xlib_surface_
d348 5
a352 2
+    int bpp, alpha, red, green, blue, stride, depth, i, j, l;
+    unsigned char *data, *c, *d, *ilut;
a357 4
+    stride = image->width * 4;
+    depth = image->depth;
+    data = image->data;
+    l = 0;
d359 23
a381 13
+    if(image->depth == 24 && surface->clut) {
+	stride = image->width;
+	if(stride%4)
+	    stride += 4 - stride % 4;
+	l = (stride * image->height);
+	if (size < l) {
+	    if(buf)
+		data = realloc(buf, l);
+	    else
+		data = malloc(l);
+	    if(data) {
+		buf = data;
+		size = l;
a382 2
+	} else {
+	    data = buf;
d384 8
a391 1
+	if(data == NULL)
d393 2
a394 1
+	
d397 1
a397 2
+	    c = image->data + j * image->stride;
+	    d = data + j * stride;
d399 4
a402 5
+		d[i] = ilut[ (unsigned int)
+			     (((c[1]) & ( 0x7 << 5 )) |
+			      ((c[2] >> 3) & (0x7 << 2 )) |
+			      ((c[3] >> 6) & 0x3)) ];
+		c += 4;
d407 20
d428 1
a428 1
+
d447 1
a447 1
@@@@ -685,7 +946,7 @@@@ _draw_image_surface (cairo_xlib_surface_
d456 1
a456 2
@@@@ -1788,6 +2049,8 @@@@ _cairo_xlib_surface_create_internal (Dis
     surface->have_clip_rects = FALSE;
d459 3
d463 20
a482 2
+    surface->clut = NULL;
 
d485 1
@

