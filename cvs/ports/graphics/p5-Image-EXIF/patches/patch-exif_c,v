head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.10
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.6
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.8
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.4
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.2
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.1.1.1.0.40
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.38
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.36
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.34
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.32
	OPENBSD_5_0:1.1.1.1.0.30
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.28
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.26
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.22
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.20
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.18
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.16
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.14
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.12
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.10
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	robert_20040517:1.1.1.1
	robert:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2014.07.12.18.36.53;	author giovanni;	state Exp;
branches;
next	1.1;
commitid	eNuRJSBt7UFQwcER;

1.1
date	2004.05.17.05.09.52;	author robert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.05.17.05.09.52;	author robert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@
Major update to 2.01
remove maintainer, his email bounces
@
text
@$OpenBSD: patch-exif_c,v 1.1.1.1 2004/05/17 05:09:52 robert Exp $
--- exif.c.orig	Fri May 11 19:03:30 2012
+++ exif.c	Sat Jul 12 19:39:39 2014
@@@@ -283,8 +283,7 @@@@ postprop(struct exifprop *prop, struct exiftags *t)
 		}
 		val = exif4byte(t->md.btiff + prop->value, o) /
 		    exif4byte(t->md.btiff + prop->value + 4, o);
-		snprintf(prop->str, 31, "%d dp%s", val, tmpprop->str);
-		prop->str[31] = '\0';
+		snprintf(prop->str, PROPSTR_SIZE, "%d dp%s", val, tmpprop->str);
 		break;
 
 	/*
@@@@ -298,14 +297,13 @@@@ postprop(struct exifprop *prop, struct exiftags *t)
 		    (float)exif4sbyte(t->md.btiff + prop->value + 4, o);
 		if (isnan(fval)) fval = 0;
 		/* 1 / (2^speed) */
-		snprintf(prop->str, 31, "1/%d",
+		snprintf(prop->str, PROPSTR_SIZE, "1/%d",
 		    (int)floor(pow(2, (double)fval) + 0.5));
-		prop->str[31] = '\0';
 		/* FALLTHROUGH */
 
 	case EXIF_T_EXPOSURE:
 		if (strlen(prop->str) > 27) break;
-		strcat(prop->str, " sec");
+		strlcat(prop->str, " sec", PROPSTR_SIZE);
 		if (prop->tag == EXIF_T_EXPOSURE)
 			prop->override = EXIF_T_SHUTTER;
 		break;
@@@@ -314,8 +312,7 @@@@ postprop(struct exifprop *prop, struct exiftags *t)
 		fval = (float)exif4byte(t->md.btiff + prop->value, o) /
 		    (float)exif4byte(t->md.btiff + prop->value + 4, o);
 		if (isnan(fval)) fval = 0;
-		snprintf(prop->str, 31, "f/%.1f", fval);
-		prop->str[31] = '\0';
+		snprintf(prop->str, PROPSTR_SIZE, "f/%.1f", fval);
 		break;
 
 	case EXIF_T_LAPERTURE:
@@@@ -324,36 +321,34 @@@@ postprop(struct exifprop *prop, struct exiftags *t)
 		    (float)exif4byte(t->md.btiff + prop->value + 4, o);
 		if (isnan(fval)) fval = 0;
 		/* sqrt(2)^aperture */
-		snprintf(prop->str, 31, "f/%.1f", pow(1.4142, (double)fval));
-		prop->str[31] = '\0';
+		snprintf(prop->str, PROPSTR_SIZE, "f/%.1f", pow(1.4142, (double)fval));
 		break;
 
 	case EXIF_T_BRIGHTVAL:
 		if (exif4byte(t->md.btiff + prop->value, o) == 0xffffffff) {
-			strcpy(prop->str, "Unknown");
+			strlcpy(prop->str, "Unknown", PROPSTR_SIZE);
 			break;
 		}
 		/* FALLTHROUGH */
 
 	case EXIF_T_EXPBIASVAL:
 		if (strlen(prop->str) > 28) break;
-		strcat(prop->str, " EV");
+		strlcat(prop->str, " EV", PROPSTR_SIZE);
 		break;
 
 	case EXIF_T_DISTANCE:
 		if (exif4byte(t->md.btiff + prop->value, o) == 0xffffffff) {
-			strcpy(prop->str, "Infinity");
+			strlcpy(prop->str, "Infinity", PROPSTR_SIZE);
 			break;
 		}
 		if (exif4byte(t->md.btiff + prop->value + 4, o) == 0) {
-			strcpy(prop->str, "Unknown");
+			strlcpy(prop->str, "Unknown", PROPSTR_SIZE);
 			break;
 		}
 		fval = (float)exif4byte(t->md.btiff + prop->value, o) /
 		    (float)exif4byte(t->md.btiff + prop->value + 4, o);
 		if (isnan(fval)) fval = 0;
-		snprintf(prop->str, 31, "%.2f m", fval);
-		prop->str[31] = '\0';
+		snprintf(prop->str, PROPSTR_SIZE, "%.2f m", fval);
 		break;
 
 	/* Flash consists of a number of bits, which expanded with v2.2. */
@@@@ -384,15 +379,14 @@@@ postprop(struct exifprop *prop, struct exiftags *t)
 		fval = (float)exif4byte(t->md.btiff + prop->value, o) /
 		    (float)exif4byte(t->md.btiff + prop->value + 4, o);
 		if (isnan(fval)) fval = 0;
-		snprintf(prop->str, 31, "%.2f mm", fval);
-		prop->str[31] = '\0';
+		snprintf(prop->str, PROPSTR_SIZE, "%.2f mm", fval);
 		break;
 
 	/* Digital zoom: set to verbose if numerator is 0 or fraction = 1. */
 
 	case EXIF_T_DIGIZOOM:
 		if (!exif4byte(t->md.btiff + prop->value, o))
-			strcpy(prop->str, "Unused");
+			strlcpy(prop->str, "Unused", PROPSTR_SIZE);
 		else if (exif4byte(t->md.btiff + prop->value, o) !=
 		    exif4byte(t->md.btiff + prop->value + 4, o))
 			break;
@@@@ -401,7 +395,7 @@@@ postprop(struct exifprop *prop, struct exiftags *t)
 
 	case EXIF_T_FOCALLEN35:
 		exifstralloc(&prop->str, 16);
-		snprintf(prop->str, 15, "%d mm", prop->value);
+		snprintf(prop->str, 16, "%d mm", prop->value);
 		break;
 
 	/*
@@@@ -566,7 +560,7 @@@@ parsetag(struct exifprop *prop, struct ifd *dir, struc
 		t->exifmaj = (short)atoi(buf);
 
 		exifstralloc(&prop->str, 8);
-		snprintf(prop->str, 7, "%d.%02d", t->exifmaj, t->exifmin);
+		snprintf(prop->str, 8, "%d.%02d", t->exifmaj, t->exifmin);
 		break;
 
 	/* Process a maker note. */
@@@@ -680,7 +674,7 @@@@ parsetag(struct exifprop *prop, struct ifd *dir, struc
 			while (d > c && isspace((int)*(d - 1))) --d;
 
 			exifstralloc(&prop->str, d - c + 1);
-			strncpy(prop->str, c, d - c);
+			strlcpy(prop->str, c, d - c + 1);
 			prop->lvl = prop->str[0] ? ED_IMG : ED_VRB;
 			return;
 		}
@@@@ -714,8 +708,8 @@@@ parsetag(struct exifprop *prop, struct ifd *dir, struc
 		/* Sanity check the offset. */
 		if (!offsanity(prop, 1, dir)) {
 			exifstralloc(&prop->str, prop->count + 1);
-			strncpy(prop->str, (const char *)(btiff + prop->value),
-			    prop->count);
+			strlcpy(prop->str, (const char *)(btiff + prop->value),
+			    prop->count + 1);
 		}
 		return;
 	}
@@@@ -730,7 +724,7 @@@@ parsetag(struct exifprop *prop, struct ifd *dir, struc
 	if ((prop->type == TIFF_RTNL || prop->type == TIFF_SRTNL) &&
 	    !offsanity(prop, 8, dir)) {
 
-		exifstralloc(&prop->str, 32);
+		exifstralloc(&prop->str, PROPSTR_SIZE);
 
 		if (prop->type == TIFF_RTNL) {
 			un = exif4byte(btiff + prop->value, o);
@


1.1
log
@Initial revision
@
text
@d1 4
a4 4
$OpenBSD$
--- exif.c.orig	2004-01-14 14:12:54.000000000 -0800
+++ exif.c	2004-05-03 11:44:51.000000000 -0700
@@@@ -257,8 +257,7 @@@@ postprop(struct exifprop *prop, struct e
d14 1
a14 1
@@@@ -272,14 +271,13 @@@@ postprop(struct exifprop *prop, struct e
d31 1
a31 1
@@@@ -288,8 +286,7 @@@@ postprop(struct exifprop *prop, struct e
d41 1
a41 1
@@@@ -298,36 +295,34 @@@@ postprop(struct exifprop *prop, struct e
d84 1
a84 1
@@@@ -344,15 +339,14 @@@@ postprop(struct exifprop *prop, struct e
d102 1
a102 1
@@@@ -361,7 +355,7 @@@@ postprop(struct exifprop *prop, struct e
d111 1
a111 3
@@@@ -502,7 +496,7 @@@@ parsetag(struct exifprop *prop, struct i
 		t->exifmin = (short)atoi(buf + 2);
 		buf[2] = '\0';
d113 4
a116 2
-		snprintf(prop->str, 7, "%d.%d", t->exifmaj, t->exifmin);
+		snprintf(prop->str, 8, "%d.%d", t->exifmaj, t->exifmin);
d120 1
a120 1
@@@@ -599,7 +593,7 @@@@ parsetag(struct exifprop *prop, struct i
d129 9
a137 8
@@@@ -627,8 +621,8 @@@@ parsetag(struct exifprop *prop, struct i
 	    (prop->value + prop->count <=
 	    (u_int32_t)(dir->md.etiff - btiff))) {
 		exifstralloc(&prop->str, prop->count + 1);
-		strncpy(prop->str, (const char *)(btiff + prop->value),
-		    prop->count);
+		strlcpy(prop->str, (const char *)(btiff + prop->value),
+		    (prop->count + 1));
d140 3
a142 4
 
@@@@ -641,7 +635,7 @@@@ parsetag(struct exifprop *prop, struct i
 	    (prop->value + prop->count * 8 <=
 	    (u_int32_t)(dir->md.etiff - btiff))) {
@


1.1.1.1
log
@Import of p5-Image-EXIF-0.98.6; from Dan Weeks <dan@@danimal.org>

The Image::Exif Perl extension allows the user to use the
libexif library to extract EXIF information from JPEG
files created by digital cameras.

ok naddy@@
@
text
@@
