head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.2
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2013.03.27.17.50.18;	author ajacoutot;	state dead;
branches
	1.2.2.1;
next	1.1;

1.1
date	2013.02.02.09.24.08;	author ajacoutot;	state Exp;
branches;
next	;

1.2.2.1
date	2016.12.13.14.50.52;	author ajacoutot;	state Exp;
branches;
next	;
commitid	OK1rFu4GRzJmLN05;


desc
@@


1.2
log
@Update to gdk-pixbuf-2.28.0.
@
text
@$OpenBSD: patch-gdk-pixbuf_io-jpeg_c,v 1.1 2013/02/02 09:24:08 ajacoutot Exp $

From ff9d69d5328abd846b2c66e3ed5ad0e90de8f5d8 Mon Sep 17 00:00:00 2001
From: Tormod Volden <debian.tormod@@gmail.com>
Date: Thu, 15 Nov 2012 20:17:29 +0000
Subject: Fix parsing of JPEG orientation tag

--- gdk-pixbuf/io-jpeg.c.orig	Mon Sep  3 18:16:55 2012
+++ gdk-pixbuf/io-jpeg.c	Sat Feb  2 10:20:08 2013
@@@@ -393,9 +393,6 @@@@ jpeg_parse_exif_app1 (JpegExifContext *context, jpeg_s
 	guint ret = FALSE;
 	guint offset;
 	guint tags;	   /* number of tags in current ifd */
-	guint tag;
-	guint type;
-	guint count;
 	guint endian = 0;	/* detected endian of data */
 	const char leth[]  = {0x49, 0x49, 0x2a, 0x00};	// Little endian TIFF header
 	const char beth[]  = {0x4d, 0x4d, 0x00, 0x2a};	// Big endian TIFF header
@@@@ -472,10 +469,11 @@@@ jpeg_parse_exif_app1 (JpegExifContext *context, jpeg_s
 
 	/* check through IFD0 for tags */
 	while (tags--){
-		tag    = de_get16(&marker->data[i + 0], endian);
-		type   = de_get16(&marker->data[i + 2], endian);
-		count  = de_get32(&marker->data[i + 4], endian);
-		offset = de_get32(&marker->data[i + 8], endian);
+		guint tag   = de_get16(&marker->data[i + 0], endian);
+		guint type  = de_get16(&marker->data[i + 2], endian);
+		guint count = de_get32(&marker->data[i + 4], endian);
+		/* values of types small enough to fit are stored directly in the (first) bytes of the Value Offset field */
+		guint short_value = de_get16(&marker->data[i + 8], endian);
 
 		/* orientation tag? */
 		if (tag == 0x112){
@@@@ -485,7 +483,7 @@@@ jpeg_parse_exif_app1 (JpegExifContext *context, jpeg_s
 				continue;
 
 			/* get the orientation value */
-			context->orientation = offset <= 8 ? offset : 0;
+			context->orientation = short_value <= 8 ? short_value : 0;
 		}
 		/* move the pointer to the next 12-byte tag field. */
 		i = i + 12;
@


1.2.2.1
log
@Check for integer overflows in app1 EXIF tags.
@
text
@d1 1
a1 1
$OpenBSD$
d3 4
a6 4
From 5daadc0b44092ba53797b2629490e5ea223647f5 Mon Sep 17 00:00:00 2001
From: Tobias Mueller <muelli@@cryptobitch.de>
Date: Mon, 28 Nov 2016 11:46:15 +0100
Subject: jpeg: Check for integer overflows in app1 EXIF tags
d8 13
a20 4
--- gdk-pixbuf/io-jpeg.c.orig	Mon Aug 24 22:27:16 2015
+++ gdk-pixbuf/io-jpeg.c	Tue Dec 13 15:49:05 2016
@@@@ -444,26 +444,36 @@@@ jpeg_parse_exif_app1 (JpegExifContext *context, jpeg_s
 	i = i + offset;
d22 11
a32 16
 	/* check that we still are within the buffer and can read the tag count */
-	if ((i + 2) > marker->data_length) {
-		ret = FALSE;
-		goto out;
+	{
+	    const size_t new_i = i + 2;
+	    if (new_i < i || new_i > marker->data_length) {
+		    ret = FALSE;
+		    goto out;
+	    }
+
+	    /* find out how many tags we have in IFD0. As per the TIFF spec, the first
+	       two bytes of the IFD contain a count of the number of tags. */
+	    tags = de_get16(&marker->data[i], endian);
+	    i = new_i;
 	}
d34 4
a37 16
-	/* find out how many tags we have in IFD0. As per the TIFF spec, the first
-	   two bytes of the IFD contain a count of the number of tags. */
-	tags = de_get16(&marker->data[i], endian);
-	i = i + 2;
-
 	/* check that we still have enough data for all tags to check. The tags
 	   are listed in consecutive 12-byte blocks. The tag ID, type, size, and
 	   a pointer to the actual value, are packed into these 12 byte entries. */
-	if ((i + tags * 12) > marker->data_length) {
+	{
+	    const size_t new_i = i + tags * 12;
+	    if (new_i < i || new_i > marker->data_length) {
 		ret = FALSE;
 		goto out;
+	    }
 	}
d39 3
a41 12
 	/* check through IFD0 for tags */
-	while (tags--){
+	while (tags--) {
+		size_t new_i;
+
+		/* We check for integer overflow before the loop and
+		 * at the end of each iteration */
 		guint tag   = de_get16(&marker->data[i + 0], endian);
 		guint type  = de_get16(&marker->data[i + 2], endian);
 		guint count = de_get32(&marker->data[i + 4], endian);
@@@@ -486,7 +496,12 @@@@ jpeg_parse_exif_app1 (JpegExifContext *context, jpeg_s
 			}
d44 1
a44 10
-		i = i + 12;
+		new_i = i + 12;
+		if (new_i < i || new_i > marker->data_length) {
+			ret = FALSE;
+			goto out;
+		}
+		i = new_i;
 	}
 
 out:
@


1.1
log
@Fix parsing of JPEG orientation tag (upstream).
@
text
@d1 1
a1 1
$OpenBSD$
@

