head	1.5;
access;
symbols
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.18
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.16
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.14
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.12
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.10
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.0.4
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1;
locks; strict;
comment	@ * @;


1.5
date	2008.12.20.08.58.32;	author jakemsr;	state dead;
branches;
next	1.4;

1.4
date	2008.03.31.01.05.54;	author jakemsr;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.25.22.07.28;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.25.22.04.39;	author wcobb;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.04.05.03.20;	author brad;	state Exp;
branches;
next	;


desc
@@


1.5
log
@- update to 0.2.41
- replace audio(4) backend with sio_open(3) (libsndio) backend

update by ajacoutot, new backend from me
@
text
@/*	$OpenBSD: audio_sun.c,v 1.4 2008/03/31 01:05:54 jakemsr Exp $	*/

/*
 * Copyright (c) 2002 CubeSoft Communications, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistribution of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Neither the name of CubeSoft Communications, nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
#include <string.h>

static void sun_panic(int fd, char *s)
{
    perror(s);
    close(fd);
    esd_audio_fd = -1;
}

#define ARCH_esd_audio_devices
const char *esd_audio_devices()
{
    return "/dev/audio";
}


#define ARCH_esd_audio_open
int esd_audio_open()
{
    const char *device;
    int afd = -1;
    int fmt = 0, channels = 0, bits = 0;
    int mode = O_WRONLY;
    audio_info_t info;

    AUDIO_INITINFO(&info);

    /* set the appropriate mode */
    if((esd_audio_format & ESD_MASK_FUNC) == ESD_RECORD) {
        mode = O_RDWR;
	info.mode = AUMODE_PLAY | AUMODE_PLAY_ALL | AUMODE_RECORD;
    } else {
	info.mode = AUMODE_PLAY | AUMODE_PLAY_ALL;
    }

    /* open the sound device */
    device = esd_audio_device ? esd_audio_device : "/dev/audio";
    if ((afd = open(device, mode, 0)) == -1) {
        perror(device);
        return( -2 );
    }

    /* set the requested mode */
    if(ioctl(afd, AUDIO_SETINFO, &info) < 0) {
	sun_panic(afd, "AUDIO_SETINFO");
	return(-1);
    }

    /* set full-duplex mode if we are recording */
    if ( (esd_audio_format & ESD_MASK_FUNC) == ESD_RECORD ) {
	if (ioctl(afd, AUDIO_SETFD, 1) == -1) {
	    sun_panic(afd, "AUDIO_SETFD");
	    return(-1);
	}
    }

    /* pick a supported encoding */
    if ((esd_audio_format & ESD_MASK_BITS) == ESD_BITS16) {
        bits = 16;
        fmt = (BYTE_ORDER == 4321) ?
          AUDIO_ENCODING_SLINEAR_BE : AUDIO_ENCODING_SLINEAR_LE;
    } else {
        bits = 8;
        fmt = (BYTE_ORDER == 4321) ?
          AUDIO_ENCODING_ULINEAR_BE : AUDIO_ENCODING_ULINEAR_LE;
    }
    info.play.encoding = fmt;
    info.play.precision = bits;
    if(ioctl(afd, AUDIO_SETINFO, &info) == -1) {
	fprintf(stderr, "Unsupported encoding: %i-bit (0x%x)\n",
	    bits, fmt);
	sun_panic(afd, "SETINFO");
	return(-1);
    }

    /* number of channels */
    channels = (((esd_audio_format & ESD_MASK_CHAN) == ESD_STEREO)
        ? /* stereo */	2
	: /* mono */	1);

    info.play.channels = channels;
    if((esd_audio_format & ESD_MASK_FUNC) == ESD_RECORD) {
	info.record.channels = channels;
    }
    if(ioctl(afd, AUDIO_SETINFO, &info) == -1) {
	fprintf(stderr, "Unsupported channel count: %d\n",
	    channels);
	sun_panic(afd, "SETINFO");
	return(-1);
    }

    /* blocksize, sync to internal esd buffer size */
    info.blocksize = ESD_BUF_SIZE;
    info.hiwat = 4;
    if(ioctl(afd, AUDIO_SETINFO, &info) < 0) {
	fprintf(stderr, "Unsupported blocksize: %d\n",
	    info.blocksize);
	sun_panic(afd, "SETINFO");
	return(-1);
    }

    /* finally, set the sample rate */
    info.play.sample_rate = esd_audio_rate;
    if(ioctl(afd, AUDIO_SETINFO, &info) < 0 || 
	fabs(info.play.sample_rate - esd_audio_rate) > esd_audio_rate * 0.05) {
	fprintf(stderr, "Unsupported rate: %i Hz\n", esd_audio_rate);
	sun_panic(afd, "SETINFO");
	return(-1);
    }

    return(esd_audio_fd = afd);
}

#define ARCH_esd_audio_pause
void esd_audio_pause()
{
    audio_info_t info;
    int afd = esd_audio_fd;

    AUDIO_INITINFO(&info);    

    if(ioctl(afd, AUDIO_GETINFO, &info) < 0) {
	sun_panic(afd, "AUDIO_GETINFO");
	return;
    }

    if((info.mode & AUMODE_PLAY) == AUMODE_PLAY)
	info.play.pause = !info.play.pause;
    if((info.mode & AUMODE_RECORD) == AUMODE_RECORD)
	info.record.pause = !info.record.pause;

    return;
}
@


1.4
log
@bring back esound-0.2.38.

fix the issues with audio(4) handling that caused this to get
reverted previously.

add an arts flavor.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_sun.c,v 1.3 2004/01/25 22:07:28 fgsch Exp $	*/
@


1.3
log
@set number of channels with the encoding, otherwise AUDIO_SETINFO will
fail with EINVAL. this gives esound a chance to work.
wcobb@@, brad@@ (maintainer), naddy@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_sun.c,v 1.2 2002/05/25 22:04:39 wcobb Exp $	*/
d30 2
d33 1
d54 1
a54 1
    int fmt = 0, channels = 0;
a55 1
    audio_encoding_t enc;
d63 1
a63 1
	info.mode = AUMODE_PLAY | AUMODE_RECORD;
d65 1
a65 1
	info.mode = AUMODE_PLAY;
a67 2
    mode |= O_NONBLOCK;

a74 4
    mode = fcntl(afd, F_GETFL);
    mode &= ~O_NONBLOCK;
    fcntl(afd, F_SETFL, mode);

d90 16
a105 14
    
#if defined(WORDS_BIGENDIAN)
    fmt = ( (esd_audio_format & ESD_MASK_BITS) == ESD_BITS16 )
        ? /* 16 bit */  AUDIO_ENCODING_SLINEAR_BE
	: /* 8 bit */	AUDIO_ENCODING_PCM8;
#else
    fmt = ( (esd_audio_format & ESD_MASK_BITS) == ESD_BITS16 )
        ? /* 16 bit */	AUDIO_ENCODING_SLINEAR_LE
	: /* 8 bit */	AUDIO_ENCODING_PCM8;
#endif

    enc.index = 0;
    while(!ioctl(afd, AUDIO_GETENC, &enc) && enc.encoding != fmt) {
	enc.index++;
d107 1
a107 1
    
d117 6
d124 6
a129 6
    info.play.encoding = fmt;
    info.play.precision = enc.precision;

    if(ioctl(afd, AUDIO_SETINFO, &info) == -1) {
	fprintf(stderr, "Unsupported encoding: %i-bit \"%s\" (0x%x)\n",
	    enc.precision, enc.name, fmt);
@


1.2
log
@Add missing license. ok brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_sun.c,v 1.1 2001/08/04 05:03:20 brad Exp $	*/
a57 5
    /* number of channels */
    channels = (((esd_audio_format & ESD_MASK_CHAN) == ESD_STEREO)
        ? /* stereo */	2
	: /* mono */	1);

a61 2
	info.play.channels = channels;
	info.record.channels = channels;
a63 1
	info.play.channels = channels;
d110 10
@


1.1
log
@replace oss audio API usage with our native audio API.
--
Patches and code for native audio API support from:
Wilbern Cobb <cobb@@vedge.com.ar>
@
text
@d1 26
a26 1
/*	$OpenBSD$	*/
@

