head	1.7;
access;
symbols
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.14
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.12
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.10
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.11.13.19.22.34;	author jca;	state Exp;
branches;
next	1.6;
commitid	P2tVKTVblSWgzQj7;

1.6
date	2015.05.05.19.45.19;	author sthen;	state Exp;
branches;
next	1.5;
commitid	fz8smaZvCGUbvSwh;

1.5
date	2012.01.24.08.03.52;	author ajacoutot;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.07.01.44.38;	author jakemsr;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.09.10.15.08;	author jakemsr;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.13.23.06.14;	author jakemsr;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.11.10.51.46;	author jakemsr;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to jack-0.125.0

From David Carlier, input and ok danj@@ on a previous version.
@
text
@@


1.6
log
@update to JACK 0.124.1, from Eric Lalonde.
@
text
@a0 997
/*
 * Copyright (c) 2009 Jacob Meuser <jakemsr@@sdf.lonestar.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <config.h>

#ifndef _REENTRANT
#define _REENTRANT
#endif
#ifndef _THREAD_SAFE
#define _THREAD_SAFE
#endif

#include <sys/types.h>

#include <errno.h>
#include <getopt.h>
#include <poll.h>
#include <sndio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <jack/types.h>
#include <internal.h>
#include <engine.h>
#include <jack/thread.h>
#include <sysdeps/time.h>

#include "sndio_driver.h"


#define SNDIO_DRIVER_N_PARAMS	10
const static jack_driver_param_desc_t sndio_params[SNDIO_DRIVER_N_PARAMS] = {
	{ "rate",
	  'r',
	  JackDriverParamUInt,
	  { .ui = SNDIO_DRIVER_DEF_FS },
	  NULL,
	  "sample rate",
	  "sample rate"
	},
	{ "period",
	  'p',
	  JackDriverParamUInt,
	  { .ui = SNDIO_DRIVER_DEF_BLKSIZE },
	  NULL,
	  "period size",
	  "period size"
	},
	{ "nperiods",
	  'n',
	  JackDriverParamUInt,
	  { .ui = SNDIO_DRIVER_DEF_NPERIODS },
	  NULL,
	  "number of periods in buffer",
	  "number of periods in buffer"
	},
	{ "wordlength",
	  'w',
	  JackDriverParamInt,
	  { .i = SNDIO_DRIVER_DEF_BITS },
	  NULL,
	  "word length",
	  "word length"
	},
	{ "inchannels",
	  'i',
	  JackDriverParamUInt,
	  { .ui = SNDIO_DRIVER_DEF_INS },
	  NULL,
	  "capture channels",
	  "capture channels"
	},
	{ "outchannels",
	  'o',
	  JackDriverParamUInt,
	  { .ui = SNDIO_DRIVER_DEF_OUTS },
	  NULL,
	  "playback channels",
	  "playback channels"
	},
	{ "device",
	  'd',
	  JackDriverParamString,
	  { },
	  NULL,
	  "device",
	  "device"
	},
	{ "ignorehwbuf",
	  'b',
	  JackDriverParamBool,
	  { },
	  NULL,
	  "ignore hardware period size",
	  "ignore hardware period size"
	},
	{ "input latency",
	  'I',
	  JackDriverParamUInt,
	  { .ui = 0 },
	  NULL,
	  "system capture latency",
	  "system capture latency"
	},
	{ "output latency",
	  'O',
	  JackDriverParamUInt,
	  { .ui = 0 },
	  NULL,
	  "system playback latency",
	  "system playback latency"
	}
};


/* internal functions */


static void
set_period_size (sndio_driver_t *driver, jack_nframes_t new_period_size)
{
	driver->period_size = new_period_size;

	driver->period_usecs = 
		((double)driver->period_size /
		(double)driver->sample_rate) * 1e6;
	driver->last_wait_ust = 0;
	driver->poll_timeout = (int)(driver->period_usecs / 666);
}


static void
sndio_driver_write_silence (sndio_driver_t *driver, jack_nframes_t nframes)
{
	size_t localsize, io_res, nbytes, offset;
	void *localbuf;

	localsize = nframes * driver->sample_bytes * driver->playback_channels;
	localbuf = malloc(localsize);
	if (localbuf == NULL)
	{
		jack_error("sndio_driver: malloc() failed: %s@@%i",
			__FILE__, __LINE__);
		return;
	}
	bzero(localbuf, localsize);

	offset = 0;
	nbytes = localsize;
	while (nbytes > 0)
	{
		io_res = sio_write(driver->hdl, localbuf + offset, nbytes);
		if (io_res == 0)
		{
			jack_error("sndio_driver: sio_write() failed: "
				"count=%d/%d: %s@@%i", io_res, localsize,
				__FILE__, __LINE__);
		}
		offset += io_res;
		nbytes -= io_res;
	}
	free(localbuf);
}


static void
sndio_driver_read_silence (sndio_driver_t *driver, jack_nframes_t nframes)
{
	size_t localsize, io_res, nbytes, offset;
	void *localbuf;

	localsize = nframes * driver->sample_bytes * driver->capture_channels;
	localbuf = malloc(localsize);
	if (localbuf == NULL)
	{
		jack_error("sndio_driver: malloc() failed: %s@@%i",
			__FILE__, __LINE__);
		return;
	}

	offset = 0;
	nbytes = localsize;
	while (nbytes > 0) {
		io_res = sio_read(driver->hdl, localbuf + offset, nbytes);
		if (io_res == 0) {
			jack_error("sndio_driver: sio_read() failed: "
				"count=%d/%d: %s@@%i", io_res, nbytes,
				__FILE__, __LINE__);
			break;
		}
		offset +=- io_res;
		nbytes -= io_res;
	}
	free(localbuf);
}


static int
sndio_driver_start (sndio_driver_t *driver)
{
	if (!sio_start(driver->hdl))
		jack_error("sio_start failed: %s@@%i",
			__FILE__, __LINE__);

	/* prime playback buffers */
	if (driver->playback_channels > 0)
		sndio_driver_write_silence(driver, driver->pprime);

	return 0;
}


static int
sndio_driver_set_parameters (sndio_driver_t *driver)
{
	struct sio_par par;
	unsigned int period_size = 0;
	unsigned int nperiods;
	int mode = 0;

	if (driver->capture_channels > 0)
		mode |= SIO_REC;

	if (driver->playback_channels > 0)
		mode |= SIO_PLAY;

	driver->hdl = sio_open(driver->dev, mode, 0);
	if (driver->hdl == NULL)
	{
		jack_error("sndio_driver: failed to open device "
			"%s: %s@@%i", (driver->dev == NULL) ?
			"default" : driver->dev, __FILE__, __LINE__);
		return -1;
	}

	if (driver->bits != 16 && driver->bits != 24 && driver->bits != 32)
	{
		jack_error("sndio_driver: invalid sample bits");
		return -1;
	}

	sio_initpar(&par);
	par.sig = 1;
	par.bits = driver->bits;
	par.pchan = driver->playback_channels;
	par.rchan = driver->capture_channels;
	par.rate = driver->sample_rate;
	par.appbufsz = driver->period_size * driver->nperiods;
	par.round = driver->period_size;
	par.xrun = SIO_SYNC;

	if (!sio_setpar(driver->hdl, &par))
	{
		jack_error("sndio_driver: failed to set parameters: %s@@%i",
			__FILE__, __LINE__);
		return -1;
	}

	if (!sio_getpar(driver->hdl, &par))
	{
		jack_error("sndio_driver: sio_getpar() failed: %s@@%i",
			__FILE__, __LINE__);
		return -1;
	}

	if (par.sig != 1 || par.bits != driver->bits ||
		par.pchan != driver->playback_channels ||
		par.rchan != driver->capture_channels ||
		par.rate != driver->sample_rate)
	{
		jack_error("sndio_driver: setting parameters failed: %s@@%i",
			__FILE__, __LINE__);
		return -1;
	}

	period_size = par.round;
	nperiods = par.appbufsz / par.round;
	driver->sample_bytes = par.bps;
	driver->pprime = par.bufsz;

	if (period_size != 0 && !driver->ignorehwbuf &&
		(period_size != driver->period_size || 
		nperiods != driver->nperiods))
	{
		printf("sndio_driver: buffer update: "
			"period_size=%u, nperiods=%u\n", period_size, nperiods);

		driver->nperiods = nperiods;
		set_period_size(driver, period_size);

		if (driver->engine)
			driver->engine->set_buffer_size(driver->engine, 
				driver->period_size);
	}

	driver->capbufsize = 0;
	driver->capbuf = NULL;
	if (driver->capture_channels != 0)
	{
		driver->capbufsize = driver->period_size * 
			driver->capture_channels * driver->sample_bytes;
		driver->capbuf = malloc(driver->capbufsize);
		if (driver->capbuf == NULL)
		{
			jack_error("sndio_driver: malloc() failed: %s@@%i", 
				__FILE__, __LINE__);
			return -1;
		}
		bzero(driver->capbuf, driver->capbufsize);
	}

	driver->playbufsize = 0;
	driver->playbuf = NULL;
	if (driver->playback_channels > 0)
	{
		driver->playbufsize = driver->period_size * 
			driver->playback_channels * driver->sample_bytes;
		driver->playbuf = malloc(driver->playbufsize);
		if (driver->playbuf == NULL)
		{
			jack_error("sndio_driver: malloc() failed: %s@@%i", 
				__FILE__, __LINE__);
			return -1;
		}
		bzero(driver->playbuf, driver->playbufsize);
	}

	printf("sndio_driver: capbuf %zd B, playbuf %zd B\n",
		driver->capbufsize, driver->playbufsize);

	return 0;
}


static int
sndio_driver_stop (sndio_driver_t *driver)
{
	if (driver->hdl != NULL)
		sio_stop(driver->hdl);

	return 0;
}


static jack_nframes_t
sndio_driver_wait (sndio_driver_t *driver, int *status, float *iodelay)
{
	struct pollfd pfd;
	nfds_t snfds, nfds;
	jack_time_t poll_ret;
	int need_capture, need_playback;
	int events, revents;

	*status = 0;
	*iodelay = 0;

	need_capture = need_playback = 0;

	if (driver->capture_channels > 0)
		need_capture = 1;

	if (driver->playback_channels > 0)
		need_playback = 1;

	if (jack_get_microseconds() > driver->poll_next)
	{
		/* late. don't count as wakeup delay. */
		driver->poll_next = 0;
	}

	snfds = sio_nfds(driver->hdl);

	while (need_capture || need_playback)
	{
		events = 0;
		if (need_capture)
			events |= POLLIN;

		if (need_playback)
			events |= POLLOUT;

		if (snfds != sio_pollfd(driver->hdl, &pfd, events)) {
			jack_error("sndio_driver: sio_pollfd failed: %s@@%i",
				__FILE__, __LINE__);
			*status = -1;
			return 0;
		}
		nfds = poll(&pfd, snfds, 1000);
		if (nfds == -1)
		{
			jack_error("sndio_driver: poll() error: %s: %s@@%i",  
				strerror(errno), __FILE__, __LINE__);
			*status = -1;
			return 0;
		}
		else if (nfds == 0)
		{
			jack_error("sndio_driver: poll() time out: %s@@%i",  
				__FILE__, __LINE__);
			*status = -1;
			return 0;
		}
		revents = sio_revents(driver->hdl, &pfd);
		if (revents & (POLLERR | POLLHUP | POLLNVAL))
		{
			jack_error("sndio_driver: poll() error: %s@@%i",  
				__FILE__, __LINE__);
			*status = -1;
			return 0;
		}

		if (revents & POLLIN)
			need_capture = 0;

		if (revents & POLLOUT)
			need_playback = 0;

		if (sio_eof(driver->hdl))
		{
			jack_error("sndio_driver: sio_eof(): %s@@%i",
				__FILE__, __LINE__);
			*status = -1;
			return 0;
		}
	}
	poll_ret = jack_get_microseconds();

	if (driver->poll_next && poll_ret > driver->poll_next)
		*iodelay = poll_ret - driver->poll_next;

	driver->poll_next = poll_ret + driver->period_usecs;
	driver->engine->transport_cycle_start(driver->engine, poll_ret);

	driver->last_wait_ust = poll_ret;

	return driver->period_size;
}


static inline int
sndio_driver_run_cycle (sndio_driver_t *driver)
{
	jack_nframes_t nframes;
	int wait_status;
	float iodelay;

	nframes = sndio_driver_wait(driver, &wait_status, &iodelay);

	if (wait_status < 0)
		return -1;

	return driver->engine->run_cycle(driver->engine, nframes, iodelay);
}


static void
copy_and_convert_in (jack_sample_t *dst, void *src, 
	size_t nframes,	int channel, int chcount, int bits)
{
	int srcidx, dstidx;
	signed short *s16src = (signed short *)src;
	signed int *s32src = (signed int *)src;
	jack_sample_t scale;

	srcidx = channel;
	switch (bits)
	{
		case 16:
			scale = 1.0f / 0x7fff;
			for (dstidx = 0; dstidx < nframes; dstidx++)
			{
				dst[dstidx] = (jack_sample_t) 
					s16src[srcidx] * scale;
				srcidx += chcount;
			}
			break;
		case 24:
		case 32:
			scale = 1.0f / 0x7fffffff;
			for (dstidx = 0; dstidx < nframes; dstidx++)
			{
				dst[dstidx] = (jack_sample_t)
					s32src[srcidx] * scale;
				srcidx += chcount;
			}
			break;
	}
}


static void
copy_and_convert_out (void *dst, jack_sample_t *src, 
	size_t nframes,	int channel, int chcount, int bits)
{
	int srcidx;
	int dstidx;
	signed short *s16dst = (signed short *)dst;
	signed int *s32dst = (signed int *)dst;
	jack_sample_t scale;

	dstidx = channel;
	switch (bits)
	{
		case 16:
			scale = 0x7fff;
			for (srcidx = 0; srcidx < nframes; srcidx++)
			{
				s16dst[dstidx] = (signed short)
					(src[srcidx] >= 0.0f) ?
					(src[srcidx] * scale + 0.5f) :
					(src[srcidx] * scale - 0.5f);
				dstidx += chcount;
			}
			break;
		case 24:
		case 32:
			scale = 0x7fffffff;
			for (srcidx = 0; srcidx < nframes; srcidx++)
			{
				s32dst[dstidx] = (signed int)
					(src[srcidx] >= 0.0f) ?
					(src[srcidx] * scale + 0.5f) :
					(src[srcidx] * scale - 0.5f);
				dstidx += chcount;
			}
			break;
	}
}


/* jack driver interface */

static int
sndio_driver_attach (sndio_driver_t *driver)
{
	int port_flags;
	int channel;
	char channel_name[64];
	jack_port_t *port;
	jack_latency_range_t range;

	driver->engine->set_buffer_size(driver->engine, driver->period_size);
	driver->engine->set_sample_rate(driver->engine, driver->sample_rate);

	port_flags = JackPortIsOutput|JackPortIsPhysical|JackPortIsTerminal;

	for (channel = 0; channel < driver->capture_channels; channel++)
	{
		snprintf(channel_name, sizeof(channel_name),
			"capture_%u", channel + 1);
		port = jack_port_register(driver->client, channel_name,
			JACK_DEFAULT_AUDIO_TYPE, port_flags, 0);
		if (port == NULL)
		{
			jack_error("sndio_driver: cannot register port for %s: "
				"%s@@%i", channel_name, __FILE__, __LINE__);
			break;
		}
		range.min = range.max = driver->period_size +
		    driver->sys_cap_latency;
		jack_port_set_latency_range(port, JackCaptureLatency, &range);
		driver->capture_ports =
			jack_slist_append(driver->capture_ports, port);
	}

	port_flags = JackPortIsInput|JackPortIsPhysical|JackPortIsTerminal;
	for (channel = 0; channel < driver->playback_channels; channel++)
	{
		snprintf(channel_name, sizeof(channel_name),
			"playback_%u", channel + 1);
		port = jack_port_register(driver->client, channel_name,
			JACK_DEFAULT_AUDIO_TYPE, port_flags, 0);
		if (port == NULL)
		{
			jack_error("sndio_driver: cannot register port for "
				"%s: %s@@%i", channel_name, __FILE__, __LINE__);
			break;
		}
		range.min = range.max = driver->period_size +
		    driver->sys_play_latency;
		jack_port_set_latency_range(port, JackPlaybackLatency, &range);
		driver->playback_ports =
			jack_slist_append(driver->playback_ports, port);
	}

	return jack_activate(driver->client);
}


static int
sndio_driver_detach (sndio_driver_t *driver)
{
	JSList *node;

	if (driver->engine == NULL)
		return 0;

	node = driver->capture_ports;
	while (node != NULL)
	{
		jack_port_unregister(driver->client, 
			((jack_port_t *) node->data));
		node = jack_slist_next(node);
	}
	if (driver->capture_ports != NULL)
	{
		jack_slist_free(driver->capture_ports);
		driver->capture_ports = NULL;
	}

	node = driver->playback_ports;
	while (node != NULL)
	{
		jack_port_unregister(driver->client,
			((jack_port_t *) node->data));
		node = jack_slist_next(node);
	}
	if (driver->playback_ports != NULL)
	{
		jack_slist_free(driver->playback_ports);
		driver->playback_ports = NULL;
	}

	return 0;
}


static int
sndio_driver_read (sndio_driver_t *driver, jack_nframes_t nframes)
{
	jack_nframes_t nbytes, offset;
	int channel;
	size_t io_res;
	jack_sample_t *portbuf;
	JSList *node;
	jack_port_t *port;

	if (driver->engine->freewheeling || driver->capture_channels == 0)
		return 0;

	if (nframes > driver->period_size)
	{
		jack_error("sndio_driver: read failed: nframes > period_size: "
			"(%u/%u): %s@@%i", nframes, driver->period_size,
			__FILE__, __LINE__);
		return -1;
	}

	node = driver->capture_ports;
	channel = 0;
	while (node != NULL)
	{
		port = (jack_port_t *)node->data;

		if (jack_port_connected(port))
		{
			portbuf = jack_port_get_buffer(port, nframes);
			copy_and_convert_in(portbuf, driver->capbuf, 
				nframes, channel, 
				driver->capture_channels,
				driver->bits);
		}

		node = jack_slist_next(node);
		channel++;
	}

	io_res = offset = 0;
	nbytes = nframes * driver->capture_channels * driver->sample_bytes;
	while (nbytes > 0)
	{
		io_res = sio_read(driver->hdl, driver->capbuf + offset, nbytes);
		if (io_res == 0)
		{
			jack_error("sndio_driver: sio_read() failed: %s@@%i",
				__FILE__, __LINE__);
			break;
		}
		offset += io_res;
		nbytes -= io_res;
	}
	return 0;
}


static int
sndio_driver_write (sndio_driver_t *driver, jack_nframes_t nframes)
{
	jack_nframes_t nbytes;
	int channel;
	size_t io_res, offset;
	jack_sample_t *portbuf;
	JSList *node;
	jack_port_t *port;

	if (driver->engine->freewheeling || driver->playback_channels == 0)
		return 0;

	if (nframes > driver->period_size)
	{
		jack_error("sndio_driver: write failed: nframes > period_size "
			"(%u/%u): %s@@%i", nframes, driver->period_size,
			__FILE__, __LINE__);
		return -1;
	}

	node = driver->playback_ports;
	channel = 0;
	while (node != NULL)
	{
		port = (jack_port_t *)node->data;

		if (jack_port_connected(port))
		{
			portbuf = jack_port_get_buffer(port, nframes);
			copy_and_convert_out(driver->playbuf, portbuf, 
				nframes, channel,
				driver->playback_channels,
				driver->bits);
		}

		node = jack_slist_next(node);
		channel++;
	}

	io_res = offset = 0;
	nbytes = nframes * driver->playback_channels * driver->sample_bytes;
	while (nbytes > 0)
	{
		io_res = sio_write(driver->hdl, driver->playbuf + offset, nbytes);
		if (io_res == 0)
		{
			jack_error("sndio_driver: sio_write() failed: %s@@%i",
				__FILE__, __LINE__);
			break;
		}
		offset += io_res;
		nbytes -= io_res;
	}
	bzero(driver->playbuf, driver->playbufsize);
	return 0;
}


static int
sndio_driver_null_cycle (sndio_driver_t *driver, jack_nframes_t nframes)
{
	if (nframes > driver->period_size)
	{
		jack_error("sndio_driver: null cycle failed: "
			"nframes > period_size (%u/%u): %s@@%i", nframes,
			driver->period_size, __FILE__, __LINE__);
		return -1;
	}

	printf("sndio_driver: running null cycle\n");

	if (driver->playback_channels > 0)
		sndio_driver_write_silence (driver, nframes);

	if (driver->capture_channels > 0)
		sndio_driver_read_silence (driver, nframes);

	return 0;
}


static int
sndio_driver_bufsize (sndio_driver_t *driver, jack_nframes_t nframes)
{
	return sndio_driver_set_parameters(driver);
}


static void
sndio_driver_delete (sndio_driver_t *driver)
{
	if (driver->hdl != NULL)
	{
		sio_close(driver->hdl);
		driver->hdl = NULL;
	}

	if (driver->capbuf != NULL)
	{
		free(driver->capbuf);
		driver->capbuf = NULL;
	}
	if (driver->playbuf != NULL)
	{
		free(driver->playbuf);
		driver->playbuf = NULL;
	}

	if (driver->dev != NULL)
	{
		free(driver->dev);
		driver->dev = NULL;
	}

	jack_driver_nt_finish((jack_driver_nt_t *) driver);

	if (driver != NULL)
	{
		free(driver);
		driver = NULL;
	}
}


void
driver_finish (jack_driver_t *driver)
{
	sndio_driver_delete((sndio_driver_t *)driver);
}


static jack_driver_t *
sndio_driver_new (char *dev, jack_client_t *client,
	jack_nframes_t sample_rate, jack_nframes_t period_size,
	jack_nframes_t nperiods, int bits,
	int capture_channels, int playback_channels,
	jack_nframes_t cap_latency, jack_nframes_t play_latency,
	int ignorehwbuf)
{
	sndio_driver_t *driver;

	driver = (sndio_driver_t *)malloc(sizeof(sndio_driver_t));
	if (driver == NULL)
	{
		jack_error("sndio_driver: malloc() failed: %s: %s@@%i",
			strerror(errno), __FILE__, __LINE__);
		return NULL;
	}
	driver->engine = NULL;
	jack_driver_nt_init((jack_driver_nt_t *)driver);

	driver->nt_attach = (JackDriverNTAttachFunction)sndio_driver_attach;
	driver->nt_detach = (JackDriverNTDetachFunction)sndio_driver_detach;
	driver->read = (JackDriverReadFunction)sndio_driver_read;
	driver->write = (JackDriverWriteFunction)sndio_driver_write;
	driver->null_cycle = (JackDriverNullCycleFunction)sndio_driver_null_cycle;
	driver->nt_bufsize = (JackDriverNTBufSizeFunction)sndio_driver_bufsize;
	driver->nt_start = (JackDriverNTStartFunction)sndio_driver_start;
	driver->nt_stop = (JackDriverNTStopFunction)sndio_driver_stop;
	driver->nt_run_cycle = (JackDriverNTRunCycleFunction)sndio_driver_run_cycle;

	if (dev != NULL)
		driver->dev = strdup(dev);
	else
		driver->dev = NULL;

	driver->ignorehwbuf = ignorehwbuf;

	driver->sample_rate = sample_rate;
	driver->period_size = period_size;
	driver->orig_period_size = period_size;
	driver->nperiods = nperiods;
	driver->bits = bits;
	driver->capture_channels = capture_channels;
	driver->playback_channels = playback_channels;
	driver->sys_cap_latency = cap_latency;
	driver->sys_play_latency = play_latency;

	set_period_size(driver, period_size);

	driver->hdl = NULL;
	driver->capbuf = driver->playbuf = NULL;
	driver->capture_ports = driver->playback_ports = NULL;

	driver->poll_next = 0;

	if (sndio_driver_set_parameters(driver) < 0)
	{
		free(driver);
		return NULL;
	}

	driver->client = client;

	return (jack_driver_t *)driver;
}


/* jack driver published interface */


const char driver_client_name[] = "sndio";


jack_driver_desc_t *
driver_get_descriptor ()
{
	jack_driver_desc_t *desc;
	jack_driver_param_desc_t *params;

	desc = (jack_driver_desc_t *)calloc(1, sizeof(jack_driver_desc_t));
	if (desc == NULL)
	{
		jack_error("sndio_driver: calloc() failed: %s: %s@@%i",
			strerror(errno), __FILE__, __LINE__);
		return NULL;
	}
	strlcpy(desc->name, driver_client_name, sizeof(desc->name));
	desc->nparams = SNDIO_DRIVER_N_PARAMS;

	params = calloc(desc->nparams, sizeof(jack_driver_param_desc_t));
	if (params == NULL)
	{
		jack_error("sndio_driver: calloc() failed: %s: %s@@%i",
			strerror(errno), __FILE__, __LINE__);
		return NULL;
	}
	memcpy(params, sndio_params, 
		desc->nparams * sizeof(jack_driver_param_desc_t));
	desc->params = params;

	return desc;
}


jack_driver_t *
driver_initialize (jack_client_t *client, JSList * params)
{
	int bits = SNDIO_DRIVER_DEF_BITS;
	jack_nframes_t sample_rate = SNDIO_DRIVER_DEF_FS;
	jack_nframes_t period_size = SNDIO_DRIVER_DEF_BLKSIZE;
	jack_nframes_t cap_latency = 0;
	jack_nframes_t play_latency = 0;
	unsigned int nperiods = SNDIO_DRIVER_DEF_NPERIODS;
	unsigned int capture_channels = SNDIO_DRIVER_DEF_INS;
	unsigned int playback_channels = SNDIO_DRIVER_DEF_OUTS;
	const JSList *pnode;
	const jack_driver_param_t *param;
	char *dev = NULL;
	int ignorehwbuf = 0;

	pnode = params;
	while (pnode != NULL)
	{
		param = (const jack_driver_param_t *)pnode->data;

		switch (param->character)
		{
			case 'r':
				sample_rate = param->value.ui;
				break;
			case 'p':
				period_size = param->value.ui;
				break;
			case 'n':
				nperiods = param->value.ui;
				break;
			case 'w':
				bits = param->value.i;
				break;
			case 'i':
				capture_channels = param->value.ui;
				break;
			case 'o':
				playback_channels = param->value.ui;
				break;
			case 'd':
				dev = strdup(param->value.str);
				break;
			case 'b':
				ignorehwbuf = 1;
				break;
			case 'I':
				cap_latency = param->value.ui;
				break;
			case 'O':
				play_latency = param->value.ui;
				break;
		}
		pnode = jack_slist_next(pnode);
	}

	return sndio_driver_new(dev, client, sample_rate, period_size,
		nperiods, bits, capture_channels, playback_channels,
		cap_latency, play_latency, ignorehwbuf);
}
@


1.5
log
@Update to jack-0.121.3.

README changes from rathov@@
tweaks and ok shadchin@@
@
text
@d38 2
a39 2
#include <jack/internal.h>
#include <jack/engine.h>
@


1.4
log
@* clean up sndio(7) driver
* update README.OpenBSD
* add patches to let it build on gcc2 archs (from Sebastian Reitenbach)
* disable audio(4) driver
@
text
@d52 1
d60 1
d68 1
d76 1
d84 1
d92 1
d100 1
d108 1
d116 1
d124 1
d555 1
d564 1
a564 1
		snprintf(channel_name, sizeof(channel_name), 
d574 4
a577 3
		jack_port_set_latency(port,
			driver->period_size + driver->sys_cap_latency);
		driver->capture_ports = 
d594 3
a596 2
		jack_port_set_latency(port,
			driver->period_size + driver->sys_play_latency);
@


1.3
log
@sndio_driver.c:
- make it work with 24-bit formats (as with azalia and envy)
- use the correct member of struct sio_par for the buffer size
- check both poll(2) revents as well as calculated buffer positions
to know when we can read/write data
sun_driver.c:
- make it work with 24-bit formats (as with azalia and envy)
jackd/engine.c:
- don't spam error messages every time a client quits
add README.OpenBSD
@
text
@a25 1
#include <sys/stat.h>
d28 5
a34 1
#include <poll.h>
a35 10
#include <pthread.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <math.h>
#include <float.h>
#include <stdarg.h>
#include <getopt.h>

#include <sndio.h>
a122 7
static void
sndio_movecb(void *arg, int delta)
{
	sndio_driver_t *driver = (sndio_driver_t *)arg;
	driver->realpos += delta;
}

d130 2
a131 2
		((double) driver->period_size /
		(double) driver->sample_rate) * 1e6;
a132 1
	driver->iodelay = 0.0F;
d151 1
a153 1
	bzero(localbuf, localsize);
d157 1
a157 1
		io_res = sio_write(driver->hdl, localbuf, nbytes);
a166 1
	driver->playpos += nframes;
a186 1
	bzero(localbuf, localsize);
a198 1
	driver->cappos += nframes;
a206 1
	{
a208 1
	}
d211 2
a212 3
	if (driver->playback_channels > 0) {
		sndio_driver_write_silence(driver, driver->buffer_fill);
	}
d255 1
d266 1
a266 1
		jack_error("sndio_driver: sio_getpar failed: %s@@%i",
a282 1
	driver->buffer_fill = par.appbufsz;
d284 1
d301 2
d310 1
a310 1
			jack_error( "sndio_driver: malloc() failed: %s@@%i", 
a315 5
	else
	{
		driver->capbufsize = 0;
		driver->capbuf = NULL;
	}
d317 2
a331 8
	else
	{
		driver->playbufsize = 0;
		driver->playbuf = NULL;
	}

	driver->realpos = driver->playpos = driver->cappos = 0;
	sio_onmove(driver->hdl, sndio_movecb, driver);
d343 2
a344 4
	if (driver->hdl != NULL) {
		sio_close(driver->hdl);
		driver->hdl = NULL;
	}
a354 1
	jack_time_t poll_enter;
a356 1
	long long cap_avail, play_avail, used;
a362 1
	cap_avail = play_avail = 0;
d364 1
a364 1
	if (driver->capture_channels != 0)
d367 1
a367 1
	if (driver->playback_channels != 0)
d370 1
a370 2
	poll_enter = jack_get_microseconds();
	if (poll_enter > driver->poll_next)
d381 1
a381 1
		if (need_capture != 0)
d384 1
a384 1
		if (need_playback != 0)
d390 1
a390 1
			*status = -3;
d393 1
a393 1
		nfds = poll(&pfd, snfds, driver->poll_timeout);
d398 8
a405 1
			*status = -3;
d413 1
a413 1
			*status = -3;
d425 3
a427 2
			jack_error("sndio_driver: sndio error");
			*status = -5;	/* restart */
a429 28

		if (driver->capture_channels > 0)
		{
			used = 0;
			if (driver->realpos > driver->cappos)
				used = driver->realpos - driver->cappos;
			cap_avail = used;

			if (cap_avail >= driver->period_size)
				need_capture = 0;

			if (cap_avail > driver->buffer_fill)
				jack_error("sndio_driver: capture xrun");
		}

		if (driver->playback_channels > 0)
		{
			used = 0;
			if (driver->playpos > driver->realpos)
				used = driver->playpos - driver->realpos;
			play_avail = driver->buffer_fill - used;

			if (play_avail >= driver->period_size)
				need_playback = 0;

			if (play_avail > driver->buffer_fill)
				jack_error("sndio_driver: playback xrun");
		}
a430 1

a435 1
	driver->poll_last = poll_ret;
a448 1
	jack_time_t now;
d452 1
a452 1
	nframes = sndio_driver_wait (driver, &wait_status, &iodelay);
d455 1
a455 29
	{
		switch (wait_status)
		{
		case -3:
			/* poll() error */
			return -1;
		case -5:
			/* xrun, restart */
			sndio_driver_stop(driver);
			driver->period_size = driver->orig_period_size;
			driver->nperiods = driver->orig_nperiods;
			sndio_driver_set_parameters(driver);
			sndio_driver_start(driver);

			if (driver->poll_next &&
				(now = jack_get_microseconds()) > driver->poll_next)
			{
				iodelay = now - driver->poll_next;
				driver->poll_next = now + driver->period_usecs;
				driver->engine->delay(driver->engine, iodelay);
				printf("sndio_driver: iodelay = %f\n", iodelay);
			}

			break;
		default:
			/* any other fatal error */
			return -1;
		}
	}
d465 3
a467 5
	int srcidx;
	int dstidx;
	signed short *s16src = (signed short *) src;
	signed int *s32src = (signed int *) src;
	double *f64src = (double *) src;
a491 7
		case 64:
			for (dstidx = 0; dstidx < nframes; dstidx++)
			{
				dst[dstidx] = (jack_sample_t) f64src[srcidx];
				srcidx += chcount;
			}
			break;
d502 2
a503 3
	signed short *s16dst = (signed short *) dst;
	signed int *s32dst = (signed int *) dst;
	double *f64dst = (double *) dst;
a531 7
		case 64:
			for (srcidx = 0; srcidx < nframes; srcidx++)
			{
				f64dst[dstidx] = (double) src[srcidx];
				dstidx += chcount;
			}
			break;
a537 1

d655 1
a655 1
		port = (jack_port_t *) node->data;
a683 2
	driver->cappos += nframes;

a697 1

a708 2
	bzero(driver->playbuf, driver->playbufsize);

d713 1
a713 1
		port = (jack_port_t *) node->data;
d728 1
a729 1
	io_res = offset = 0;
d742 1
a742 2
	driver->playpos += nframes;

d760 1
a760 1
	if (driver->playback_channels != 0)
d763 1
a763 1
	if (driver->capture_channels != 0)
d816 1
a816 1
	sndio_driver_delete ((sndio_driver_t *)driver);
d830 1
a830 1
	driver = (sndio_driver_t *) malloc(sizeof(sndio_driver_t));
d838 1
a838 1
	jack_driver_nt_init((jack_driver_nt_t *) driver);
d840 9
a848 10
	driver->nt_attach = (JackDriverNTAttachFunction) sndio_driver_attach;
	driver->nt_detach = (JackDriverNTDetachFunction) sndio_driver_detach;
	driver->read = (JackDriverReadFunction) sndio_driver_read;
	driver->write = (JackDriverWriteFunction) sndio_driver_write;
	driver->null_cycle = (JackDriverNullCycleFunction) 
		sndio_driver_null_cycle;
	driver->nt_bufsize = (JackDriverNTBufSizeFunction) sndio_driver_bufsize;
	driver->nt_start = (JackDriverNTStartFunction) sndio_driver_start;
	driver->nt_stop = (JackDriverNTStopFunction) sndio_driver_stop;
	driver->nt_run_cycle = (JackDriverNTRunCycleFunction) sndio_driver_run_cycle;
a860 1
	driver->orig_nperiods = nperiods;
d868 1
a868 1
	
d873 1
a873 2
	driver->iodelay = 0.0F;
	driver->poll_last = driver->poll_next = 0;
d875 1
a875 1
	if (sndio_driver_set_parameters (driver) < 0)
d883 1
a883 1
	return (jack_driver_t *) driver;
d899 1
a899 1
	desc = (jack_driver_desc_t *) calloc(1, sizeof(jack_driver_desc_t));
d906 1
a906 1
	strcpy(desc->name, driver_client_name);
d943 1
a943 1
		param = (const jack_driver_param_t *) pnode->data;
d981 1
a981 1
	return sndio_driver_new (dev, client, sample_rate, period_size,
@


1.2
log
@fixes for the sndio backend:
* deal with sio_{read,write} possibly moving less data than requested
* check for out-of-sync conditions and restart if they occur

makes running jackd over aucat much more reliable
@
text
@a246 2
	driver->sample_bytes = driver->bits / 8;

d262 6
d302 3
a304 2
	nperiods = par.bufsz / par.round;
	driver->buffer_fill = par.bufsz;
d411 2
d415 1
a415 1
		events = revents = 0;
a421 1
		snfds = sio_nfds(driver->hdl);
d464 4
d469 1
a469 3
			{
				jack_error("sndio_driver: capture overrun");
			}
d478 4
d483 1
a483 24
			{
				jack_error("sndio_driver: playback underrun");
			}
		}

		if (driver->capture_channels > 0 &&
		    driver->playback_channels > 0)
		{
			if ((driver->realpos > 0 &&
				(play_avail != driver->period_size ||
				  cap_avail != driver->period_size) &&
				!(!play_avail && !cap_avail && !need_playback &&
				  need_capture)) ||
			    (driver->realpos == 0 &&
				!play_avail && !cap_avail && need_playback &&
				!need_capture))
			{
				jack_error("sndio_driver: out of sync: "
					"rp=%lld pa=%lld ca=%lld np=%d nc=%d",
					driver->realpos, play_avail, cap_avail,
					need_playback, need_capture);
				*status = -5;
				return 0;
			}
a570 8
			scale = 1.0f / 0x7fffff;
			for (dstidx = 0; dstidx < nframes; dstidx++)
			{
				dst[dstidx] = (jack_sample_t)
					s32src[srcidx] * scale;
				srcidx += chcount;
			}
			break;
a616 10
			scale = 0x7fffff;
			for (srcidx = 0; srcidx < nframes; srcidx++)
			{
				s32dst[dstidx] = (signed int)
					(src[srcidx] >= 0.0f) ?
					(src[srcidx] * scale + 0.5f) :
					(src[srcidx] * scale - 0.5f);
				dstidx += chcount;
			}
			break;
@


1.1
log
@- update to 0.116.1, mostly stability/reliability fixes
- add sndio backend

playback under aucat server is pretty solid.  for full-duplex,
starting aucat with 'aucat -l -b 2048' and jackd with just
'jackd -d sndio' seems to work best for me.  we want low latency
anyway, right ;)
@
text
@d155 1
a155 1
	size_t localsize, io_res;
d167 1
d169 2
a170 2
	io_res = sio_write(driver->hdl, localbuf, localsize);
	if (io_res < localsize)
d172 9
a180 3
		jack_error("sndio_driver: sio_write() failed: "
			"count=%d/%d: %s@@%i", io_res, localsize,
			__FILE__, __LINE__);
d190 1
a190 1
	size_t localsize, io_res;
d202 1
d204 11
a214 6
	io_res = sio_read(driver->hdl, localbuf, localsize);
	if (io_res < localsize)
	{
		jack_error("sndio_driver: sio_read() failed: "
			"count=%d/%d: %s@@%i", io_res, localsize,
			__FILE__, __LINE__);
d231 3
a233 2
	sndio_driver_write_silence(driver,
		driver->buffer_fill);
a271 1
	// par.xrun = SIO_SYNC;
d384 1
a384 1
	int cap_avail, play_avail;
d387 1
a387 1
	*status = -1;
d391 1
d408 1
a408 1
		events = 0;
d419 1
a419 1
			*status = -1;
a421 1

d445 1
a445 1
		if (need_capture)
d447 4
a450 1
			cap_avail = driver->realpos - driver->cappos;
d452 7
a458 1
			if (cap_avail >= driver->buffer_fill)
a460 2
				*status = -5;
				return 0;
d462 9
a470 1
			else if (cap_avail >= driver->period_size)
d472 1
a472 1
				need_capture = 0;
d476 2
a477 1
		if (need_playback)
d479 13
a491 5
			play_avail = driver->playpos - driver->realpos;

			if (play_avail >= driver->buffer_fill)
			{
				jack_error("sndio_driver: playback underrun");
a494 4
			else if (play_avail >= driver->period_size)
			{
				need_playback = 0;
			}
a508 2
	*status = 0;

d538 2
a539 2
			now = jack_get_microseconds();
			if (now > driver->poll_next)
d766 1
a766 1
	jack_nframes_t nbytes;
d803 1
a804 1
	io_res = 0;
d807 1
a807 1
		io_res = sio_read(driver->hdl, driver->capbuf, nbytes);
d814 1
d828 1
a828 1
	size_t io_res;
d867 1
a867 1
	io_res = 0;
d870 1
a870 1
		io_res = sio_write(driver->hdl, driver->playbuf, nbytes);
d877 1
@

