head	1.5;
access;
symbols
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_1:1.1.0.4
	OPENBSD_4_0:1.1.0.2;
locks; strict;
comment	@# @;


1.5
date	2010.06.03.15.48.36;	author naddy;	state dead;
branches;
next	1.4;

1.4
date	2009.11.24.21.43.14;	author naddy;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.13.15.48.55;	author naddy;	state dead;
branches;
next	1.2;

1.2
date	2008.05.17.19.58.25;	author naddy;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2007.08.01.06.13.57;	author ajacoutot;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2007.08.01.06.13.57;	author ajacoutot;	state Exp;
branches;
next	;

1.1.4.1
date	2007.08.01.06.14.24;	author ajacoutot;	state Exp;
branches;
next	;

1.2.6.1
date	2010.01.02.23.12.35;	author william;	state Exp;
branches;
next	;


desc
@@


1.5
log
@update to 1.3.1; with and ok pea@@
@
text
@$OpenBSD: patch-lib_res0_c,v 1.4 2009/11/24 21:43:14 naddy Exp $
--- lib/res0.c.orig	Tue Nov 24 21:59:48 2009
+++ lib/res0.c	Tue Nov 24 22:00:01 2009
@@@@ -238,6 +238,10 @@@@ vorbis_info_residue *res0_unpack(vorbis_info *vi,oggpa
 
   /* verify the phrasebook is not specifying an impossible or
      inconsistent partitioning scheme. */
+  /* modify the phrasebook ranging check from r16327; an early beta
+     encoder had a bug where it used an oversized phrasebook by
+     accident.  These files should continue to be playable, but don't
+     allow an exploit */
   {
     int entries = ci->book_param[info->groupbook]->entries;
     int dim = ci->book_param[info->groupbook]->dim;
@@@@ -247,6 +251,7 @@@@ vorbis_info_residue *res0_unpack(vorbis_info *vi,oggpa
       if(partvals > entries) goto errout;
       dim--;
     }
+    info->partvals = partvals;
   }
 
   return(info);
@@@@ -667,7 +672,7 @@@@ static int _01inverse(vorbis_block *vb,vorbis_look_res
           for(j=0;j<ch;j++){
             int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
 
-            if(temp==-1)goto eopbreak;
+            if(temp==-1 || temp>=info->partvals)goto eopbreak;
             partword[j][l]=look->decodemap[temp];
             if(partword[j][l]==NULL)goto errout;
           }
@@@@ -883,7 +888,7 @@@@ int res2_inverse(vorbis_block *vb,vorbis_look_residue 
         if(s==0){
           /* fetch the partition word */
           int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
-          if(temp==-1)goto eopbreak;
+          if(temp==-1 || temp>info->partvals)goto eopbreak;
           partword[l]=look->decodemap[temp];
           if(partword[l]==NULL)goto errout;
         }
@


1.4
log
@SECURITY:
Fix handling of malformed Vorbis streams that would crash libvorbis.
CVE-2008-1420 (improved), CVE-2009-3379.  From xiph.org SVN.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3
log
@update to 1.2.3: mostly bug fixes
@
text
@d1 4
a4 6
$OpenBSD: patch-lib_res0_c,v 1.2 2008/05/17 19:58:25 naddy Exp $
--- lib/res0.c.orig	Sat May 17 21:22:14 2008
+++ lib/res0.c	Sat May 17 21:24:04 2008
@@@@ -223,6 +223,20 @@@@ vorbis_info_residue *res0_unpack(vorbis_info *vi,oggpa
   for(j=0;j<acc;j++)
     if(info->booklist[j]>=ci->books)goto errout;
d6 12
a17 18
+  /* verify the phrasebook is not specifying an impossible or
+     inconsistent partitioning scheme. */
+  {
+    int entries = ci->book_param[info->groupbook]->entries;
+    int dim = ci->book_param[info->groupbook]->dim;
+    int partvals = 1;
+    while(dim>0){
+      partvals *= info->partitions;
+      if(partvals > entries) goto errout;
+      dim--;
+    }
+    if(partvals != entries) goto errout;
+  }
+
   return(info);
  errout:
   res0_free_info(info);
@@@@ -263,7 +277,7 @@@@ vorbis_look_residue *res0_look(vorbis_dsp_state *vd,
d19 1
d22 19
a40 5
-  look->partvals=rint(pow((float)look->parts,(float)dim));
+  look->partvals=look->phrasebook->entries;
   look->stages=maxstage;
   look->decodemap=_ogg_malloc(look->partvals*sizeof(*look->decodemap));
   for(j=0;j<look->partvals;j++){
@


1.2
log
@SECURITY fixes from Xiph SVN:
* add code to prevent heap attacks by exploiting dim=bignum and
  partition_codewords = partion_values
* correctly handle the nonsensical codebook.dim==0 case
* dd checks/rejection for absurdly huge codebooks

CVE-2008-1419, CVE-2008-1420, CVE-2008-1423
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2.6.1
log
@SECURITY FIX

Resolves:

CVE-2008-1419
CVE-2008-1420
CVE-2008-1423
CVE-2009-2663
CVE-2009-3379
and adds upstream-r14811_huffman_sanity_checks

from ubuntu via naddy@@, thanks

help and ok jasper@@
@
text
@d2 5
a6 9

Fix for Mozilla BZ #501279


--- lib/res0.c.orig	Mon Jul 23 20:09:47 2007
+++ lib/res0.c	Thu Dec 17 21:54:44 2009
@@@@ -208,16 +208,27 @@@@ vorbis_info_residue *res0_unpack(vorbis_info *vi,oggpa
   info->partitions=oggpack_read(opb,6)+1;
   info->groupbook=oggpack_read(opb,8);
d8 10
a17 13
+  /* check for premature EOP */
+  if(info->groupbook<0)goto errout;
+
   for(j=0;j<info->partitions;j++){
     int cascade=oggpack_read(opb,3);
-    if(oggpack_read(opb,1))
-      cascade|=(oggpack_read(opb,5)<<3);
+    int cflag=oggpack_read(opb,1);
+    if(cflag<0) goto errout;
+    if(cflag){
+      int c=oggpack_read(opb,5);
+      if(c<0) goto errout;
+      cascade|=(c<<3);
d19 1
a19 10
     info->secondstages[j]=cascade;
 
     acc+=icount(cascade);
   }
-  for(j=0;j<acc;j++)
-    info->booklist[j]=oggpack_read(opb,8);
+  for(j=0;j<acc;j++){
+    int book=oggpack_read(opb,8);
+    if(book<0) goto errout;
+    info->booklist[j]=book;
d21 5
a25 4
 
   if(info->groupbook>=ci->books)goto errout;
   for(j=0;j<acc;j++)
@@@@ -263,7 +274,10 @@@@ vorbis_look_residue *res0_look(vorbis_dsp_state *vd,
d30 1
a30 4
+  look->partvals=1;
+  for(j=0;j<dim;j++)
+      look->partvals*=look->parts;
+
@


1.1
log
@file patch-lib_res0_c was initially added on branch OPENBSD_4_0.
@
text
@d1 33
@


1.1.4.1
log
@- backport several security fixes from libvorbis SVN
cf. http://www.isecpartners.com/advisories/2007-003-libvorbis.txt

ok sturm@@
@
text
@a0 197
$OpenBSD$
--- lib/res0.c.orig	Mon Nov 28 06:43:25 2005
+++ lib/res0.c	Tue Jul 31 12:25:37 2007
@@@@ -336,7 +336,7 @@@@ static int local_book_besterror(codebook
     }
   }
 
-  {
+  if(best>-1){
     float *ptr=book->valuelist+best*dim;
     for(i=0;i<dim;i++)
       *a++ -= *ptr++;
@@@@ -355,10 +355,12 @@@@ static int _encodepart(oggpack_buffer *o
     int entry=local_book_besterror(book,vec+i*dim);
 
 #ifdef TRAIN_RES
-    acc[entry]++;
+    if(entry>0)
+      acc[entry]++;
 #endif
-
+      
     bits+=vorbis_book_encode(book,entry,opb);
+  
   }
 
   return(bits);
@@@@ -512,7 +514,7 @@@@ static int _01forward(oggpack_buffer *op
 
 #ifdef TRAIN_RES
   for(i=0;i<ch;i++)
-    for(j=info->begin;j<info->end;j++){
+    for(j=info->begin;j<end;j++){
       if(in[i][j]>look->tmax)look->tmax=in[i][j];
       if(in[i][j]<look->tmin)look->tmin=in[i][j];
     }
@@@@ -617,45 +619,49 @@@@ static int _01inverse(vorbis_block *vb,v
   /* move all this setup out later */
   int samples_per_partition=info->grouping;
   int partitions_per_word=look->phrasebook->dim;
-  int n=info->end-info->begin;
+  int max=vb->pcmend>>1;
+  int end=(info->end<max?info->end:max);
+  int n=end-info->begin;
   
-  int partvals=n/samples_per_partition;
-  int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
-  int ***partword=alloca(ch*sizeof(*partword));
-
-  for(j=0;j<ch;j++)
-    partword[j]=_vorbis_block_alloc(vb,partwords*sizeof(*partword[j]));
-
-  for(s=0;s<look->stages;s++){
-
-    /* each loop decodes on partition codeword containing 
-       partitions_pre_word partitions */
-    for(i=0,l=0;i<partvals;l++){
-      if(s==0){
-	/* fetch the partition word for each channel */
-	for(j=0;j<ch;j++){
-	  int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
-	  if(temp==-1)goto eopbreak;
-	  partword[j][l]=look->decodemap[temp];
-	  if(partword[j][l]==NULL)goto errout;
-	}
-      }
+  if(n>0){
+    int partvals=n/samples_per_partition;
+    int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
+    int ***partword=alloca(ch*sizeof(*partword));
+    
+    for(j=0;j<ch;j++)
+      partword[j]=_vorbis_block_alloc(vb,partwords*sizeof(*partword[j]));
+    
+    for(s=0;s<look->stages;s++){
       
-      /* now we decode residual values for the partitions */
-      for(k=0;k<partitions_per_word && i<partvals;k++,i++)
-	for(j=0;j<ch;j++){
-	  long offset=info->begin+i*samples_per_partition;
-	  if(info->secondstages[partword[j][l][k]]&(1<<s)){
-	    codebook *stagebook=look->partbooks[partword[j][l][k]][s];
-	    if(stagebook){
-	      if(decodepart(stagebook,in[j]+offset,&vb->opb,
-			    samples_per_partition)==-1)goto eopbreak;
-	    }
+      /* each loop decodes on partition codeword containing 
+	 partitions_per_word partitions */
+      for(i=0,l=0;i<partvals;l++){
+	if(s==0){
+	  /* fetch the partition word for each channel */
+	  for(j=0;j<ch;j++){
+	    int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
+	    
+	    if(temp==-1)goto eopbreak;
+	    partword[j][l]=look->decodemap[temp];
+	    if(partword[j][l]==NULL)goto errout;
 	  }
 	}
-    } 
+	
+	/* now we decode residual values for the partitions */
+	for(k=0;k<partitions_per_word && i<partvals;k++,i++)
+	  for(j=0;j<ch;j++){
+	    long offset=info->begin+i*samples_per_partition;
+	    if(info->secondstages[partword[j][l][k]]&(1<<s)){
+	      codebook *stagebook=look->partbooks[partword[j][l][k]][s];
+	      if(stagebook){
+		if(decodepart(stagebook,in[j]+offset,&vb->opb,
+			      samples_per_partition)==-1)goto eopbreak;
+	      }
+	    }
+	  }
+      } 
+    }
   }
-  
  errout:
  eopbreak:
   return(0);
@@@@ -833,41 +839,44 @@@@ int res2_inverse(vorbis_block *vb,vorbis
   /* move all this setup out later */
   int samples_per_partition=info->grouping;
   int partitions_per_word=look->phrasebook->dim;
-  int n=info->end-info->begin;
+  int max=(vb->pcmend*ch)>>1;
+  int end=(info->end<max?info->end:max);
+  int n=end-info->begin;
 
-  int partvals=n/samples_per_partition;
-  int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
-  int **partword=_vorbis_block_alloc(vb,partwords*sizeof(*partword));
-
-  for(i=0;i<ch;i++)if(nonzero[i])break;
-  if(i==ch)return(0); /* no nonzero vectors */
-
-  for(s=0;s<look->stages;s++){
-    for(i=0,l=0;i<partvals;l++){
-
-      if(s==0){
-	/* fetch the partition word */
-	int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
-	if(temp==-1)goto eopbreak;
-	partword[l]=look->decodemap[temp];
-	if(partword[l]==NULL)goto errout;
-      }
-
-      /* now we decode residual values for the partitions */
-      for(k=0;k<partitions_per_word && i<partvals;k++,i++)
-	if(info->secondstages[partword[l][k]]&(1<<s)){
-	  codebook *stagebook=look->partbooks[partword[l][k]][s];
-	  
-	  if(stagebook){
-	    if(vorbis_book_decodevv_add(stagebook,in,
-					i*samples_per_partition+info->begin,ch,
-					&vb->opb,samples_per_partition)==-1)
-	      goto eopbreak;
-	  }
+  if(n>0){
+    int partvals=n/samples_per_partition;
+    int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
+    int **partword=_vorbis_block_alloc(vb,partwords*sizeof(*partword));
+    
+    for(i=0;i<ch;i++)if(nonzero[i])break;
+    if(i==ch)return(0); /* no nonzero vectors */
+    
+    for(s=0;s<look->stages;s++){
+      for(i=0,l=0;i<partvals;l++){
+	
+	if(s==0){
+	  /* fetch the partition word */
+	  int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
+	  if(temp==-1)goto eopbreak;
+	  partword[l]=look->decodemap[temp];
+	  if(partword[l]==NULL)goto errout;
 	}
-    } 
+	
+	/* now we decode residual values for the partitions */
+	for(k=0;k<partitions_per_word && i<partvals;k++,i++)
+	  if(info->secondstages[partword[l][k]]&(1<<s)){
+	    codebook *stagebook=look->partbooks[partword[l][k]][s];
+	    
+	    if(stagebook){
+	      if(vorbis_book_decodevv_add(stagebook,in,
+					  i*samples_per_partition+info->begin,ch,
+					  &vb->opb,samples_per_partition)==-1)
+		goto eopbreak;
+	    }
+	  }
+      } 
+    }
   }
-  
  errout:
  eopbreak:
   return(0);
@


1.1.2.1
log
@- backport several security fixes from libvorbis SVN
cf. http://www.isecpartners.com/advisories/2007-003-libvorbis.txt

ok sturm@@
@
text
@a0 197
$OpenBSD$
--- lib/res0.c.orig	Mon Nov 28 06:43:25 2005
+++ lib/res0.c	Tue Jul 31 12:25:37 2007
@@@@ -336,7 +336,7 @@@@ static int local_book_besterror(codebook
     }
   }
 
-  {
+  if(best>-1){
     float *ptr=book->valuelist+best*dim;
     for(i=0;i<dim;i++)
       *a++ -= *ptr++;
@@@@ -355,10 +355,12 @@@@ static int _encodepart(oggpack_buffer *o
     int entry=local_book_besterror(book,vec+i*dim);
 
 #ifdef TRAIN_RES
-    acc[entry]++;
+    if(entry>0)
+      acc[entry]++;
 #endif
-
+      
     bits+=vorbis_book_encode(book,entry,opb);
+  
   }
 
   return(bits);
@@@@ -512,7 +514,7 @@@@ static int _01forward(oggpack_buffer *op
 
 #ifdef TRAIN_RES
   for(i=0;i<ch;i++)
-    for(j=info->begin;j<info->end;j++){
+    for(j=info->begin;j<end;j++){
       if(in[i][j]>look->tmax)look->tmax=in[i][j];
       if(in[i][j]<look->tmin)look->tmin=in[i][j];
     }
@@@@ -617,45 +619,49 @@@@ static int _01inverse(vorbis_block *vb,v
   /* move all this setup out later */
   int samples_per_partition=info->grouping;
   int partitions_per_word=look->phrasebook->dim;
-  int n=info->end-info->begin;
+  int max=vb->pcmend>>1;
+  int end=(info->end<max?info->end:max);
+  int n=end-info->begin;
   
-  int partvals=n/samples_per_partition;
-  int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
-  int ***partword=alloca(ch*sizeof(*partword));
-
-  for(j=0;j<ch;j++)
-    partword[j]=_vorbis_block_alloc(vb,partwords*sizeof(*partword[j]));
-
-  for(s=0;s<look->stages;s++){
-
-    /* each loop decodes on partition codeword containing 
-       partitions_pre_word partitions */
-    for(i=0,l=0;i<partvals;l++){
-      if(s==0){
-	/* fetch the partition word for each channel */
-	for(j=0;j<ch;j++){
-	  int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
-	  if(temp==-1)goto eopbreak;
-	  partword[j][l]=look->decodemap[temp];
-	  if(partword[j][l]==NULL)goto errout;
-	}
-      }
+  if(n>0){
+    int partvals=n/samples_per_partition;
+    int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
+    int ***partword=alloca(ch*sizeof(*partword));
+    
+    for(j=0;j<ch;j++)
+      partword[j]=_vorbis_block_alloc(vb,partwords*sizeof(*partword[j]));
+    
+    for(s=0;s<look->stages;s++){
       
-      /* now we decode residual values for the partitions */
-      for(k=0;k<partitions_per_word && i<partvals;k++,i++)
-	for(j=0;j<ch;j++){
-	  long offset=info->begin+i*samples_per_partition;
-	  if(info->secondstages[partword[j][l][k]]&(1<<s)){
-	    codebook *stagebook=look->partbooks[partword[j][l][k]][s];
-	    if(stagebook){
-	      if(decodepart(stagebook,in[j]+offset,&vb->opb,
-			    samples_per_partition)==-1)goto eopbreak;
-	    }
+      /* each loop decodes on partition codeword containing 
+	 partitions_per_word partitions */
+      for(i=0,l=0;i<partvals;l++){
+	if(s==0){
+	  /* fetch the partition word for each channel */
+	  for(j=0;j<ch;j++){
+	    int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
+	    
+	    if(temp==-1)goto eopbreak;
+	    partword[j][l]=look->decodemap[temp];
+	    if(partword[j][l]==NULL)goto errout;
 	  }
 	}
-    } 
+	
+	/* now we decode residual values for the partitions */
+	for(k=0;k<partitions_per_word && i<partvals;k++,i++)
+	  for(j=0;j<ch;j++){
+	    long offset=info->begin+i*samples_per_partition;
+	    if(info->secondstages[partword[j][l][k]]&(1<<s)){
+	      codebook *stagebook=look->partbooks[partword[j][l][k]][s];
+	      if(stagebook){
+		if(decodepart(stagebook,in[j]+offset,&vb->opb,
+			      samples_per_partition)==-1)goto eopbreak;
+	      }
+	    }
+	  }
+      } 
+    }
   }
-  
  errout:
  eopbreak:
   return(0);
@@@@ -833,41 +839,44 @@@@ int res2_inverse(vorbis_block *vb,vorbis
   /* move all this setup out later */
   int samples_per_partition=info->grouping;
   int partitions_per_word=look->phrasebook->dim;
-  int n=info->end-info->begin;
+  int max=(vb->pcmend*ch)>>1;
+  int end=(info->end<max?info->end:max);
+  int n=end-info->begin;
 
-  int partvals=n/samples_per_partition;
-  int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
-  int **partword=_vorbis_block_alloc(vb,partwords*sizeof(*partword));
-
-  for(i=0;i<ch;i++)if(nonzero[i])break;
-  if(i==ch)return(0); /* no nonzero vectors */
-
-  for(s=0;s<look->stages;s++){
-    for(i=0,l=0;i<partvals;l++){
-
-      if(s==0){
-	/* fetch the partition word */
-	int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
-	if(temp==-1)goto eopbreak;
-	partword[l]=look->decodemap[temp];
-	if(partword[l]==NULL)goto errout;
-      }
-
-      /* now we decode residual values for the partitions */
-      for(k=0;k<partitions_per_word && i<partvals;k++,i++)
-	if(info->secondstages[partword[l][k]]&(1<<s)){
-	  codebook *stagebook=look->partbooks[partword[l][k]][s];
-	  
-	  if(stagebook){
-	    if(vorbis_book_decodevv_add(stagebook,in,
-					i*samples_per_partition+info->begin,ch,
-					&vb->opb,samples_per_partition)==-1)
-	      goto eopbreak;
-	  }
+  if(n>0){
+    int partvals=n/samples_per_partition;
+    int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
+    int **partword=_vorbis_block_alloc(vb,partwords*sizeof(*partword));
+    
+    for(i=0;i<ch;i++)if(nonzero[i])break;
+    if(i==ch)return(0); /* no nonzero vectors */
+    
+    for(s=0;s<look->stages;s++){
+      for(i=0,l=0;i<partvals;l++){
+	
+	if(s==0){
+	  /* fetch the partition word */
+	  int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
+	  if(temp==-1)goto eopbreak;
+	  partword[l]=look->decodemap[temp];
+	  if(partword[l]==NULL)goto errout;
 	}
-    } 
+	
+	/* now we decode residual values for the partitions */
+	for(k=0;k<partitions_per_word && i<partvals;k++,i++)
+	  if(info->secondstages[partword[l][k]]&(1<<s)){
+	    codebook *stagebook=look->partbooks[partword[l][k]][s];
+	    
+	    if(stagebook){
+	      if(vorbis_book_decodevv_add(stagebook,in,
+					  i*samples_per_partition+info->begin,ch,
+					  &vb->opb,samples_per_partition)==-1)
+		goto eopbreak;
+	    }
+	  }
+      } 
+    }
   }
-  
  errout:
  eopbreak:
   return(0);
@

