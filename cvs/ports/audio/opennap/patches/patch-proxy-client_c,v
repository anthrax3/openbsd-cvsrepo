head	1.1;
access;
symbols
	OPENBSD_6_1:1.1.0.60
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.58
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.54
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.56
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.52
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.50
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.48
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.46
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.44
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.42
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.40
	OPENBSD_5_0:1.1.0.38
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.36
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.34
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.32
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.30
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.28
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.26
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.24
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.22
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.20
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.18
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.16
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.14
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.12
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.10
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.8
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.6
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2002.08.10.01.14.04;	author naddy;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Update to 0.44 with some patches from CVS.

Notable changes to the port:
- creates opennap user/group to run as
- tons of bugfixes, improved performance
- no longer hardcodes SYSCONFDIR to /etc/opennap

Submitted by Jolan Luff <jolan@@pellaeon.com>.
@
text
@$OpenBSD$
--- proxy-client.c.orig	Fri Aug  2 22:15:44 2002
+++ proxy-client.c	Tue Mar  6 00:49:53 2001
@@@@ -0,0 +1,179 @@@@
+/* Copyright (C) 2000-1 drscholl@@users.sourceforge.net
+   This is free software distributed under the terms of the
+   GNU Public License.  See the file COPYING for details.
+
+   proxy-client.c,v 1.3 2001/03/06 06:49:53 drscholl Exp */
+
+/* a simple proxy server to spy on the traffic between clients.  this
+   is a lot easier than using tcpdump.  */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <arpa/inet.h>
+#include <errno.h>
+
+unsigned char buf[2048];
+
+int
+pass_message (const char *id, int s, int d)
+{
+    int     len;
+    int     i;
+
+    len = read (s, buf, sizeof (buf));
+    if (len <= 0)
+    {
+	if (len == -1)
+	    printf ("%s: %s\n", id, strerror (errno));
+	else
+	    printf ("%s: EOF\n", id);
+	return -1;
+    }
+    buf[len] = 0;
+
+    for (i = 0; i < len; i++)
+	if (buf[i] == '\r')
+	    buf[i] = 'M';
+
+    printf ("%s: len=%d, data=%s\n", id, len, buf);
+
+    write (d, buf, len);
+
+    return 0;
+}
+
+static void
+usage (void)
+{
+    puts ("usage: spyserv [ -s client ] [ -p clientport ] [ -l localport ]");
+    exit (0);
+}
+
+int
+main (int argc, char **argv)
+{
+    int     s;
+    int     c;
+    int     r;
+    int     localport = 6699;
+    size_t  sinsize;
+    struct sockaddr_in sin;
+    fd_set  fds;
+    char   *host = "192.168.0.101";
+    int     port = 6699;
+
+    while ((r = getopt (argc, argv, "hs:p:l:")) != EOF)
+    {
+	switch (r)
+	{
+	case 'l':
+	    localport = atoi (optarg);
+	    break;
+	case 's':
+	    host = optarg;
+	    break;
+	case 'p':
+	    port = atoi (optarg);
+	    break;
+	default:
+	    usage ();
+	}
+    }
+
+    /* accept connection from client */
+    s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (s < 0)
+    {
+	perror ("socket");
+	exit (1);
+    }
+    c = 1;
+    if (setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &c, sizeof (c)) != 0)
+    {
+	perror ("setsockopt");
+	exit (1);
+    }
+    memset (&sin, 0, sizeof (sin));
+    sin.sin_port = htons (localport);
+    sin.sin_family = AF_INET;
+    sin.sin_addr.s_addr = INADDR_ANY;
+    if (bind (s, &sin, sizeof (sin)) < 0)
+    {
+	perror ("bind");
+	exit (1);
+    }
+    if (listen (s, 1) < 0)
+    {
+	perror ("listen");
+	exit (1);
+    }
+
+    for (;;)
+    {
+	puts ("waiting for connection");
+	sinsize = sizeof (sin);
+	c = accept (s, &sin, &sinsize);
+	if (c < 0)
+	{
+	    perror ("accept");
+	    exit (1);
+	}
+	puts ("got incoming connection");
+
+	/* make connection to server */
+	printf ("connecting to client...");
+	fflush (stdout);
+	r = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
+	if (r < 0)
+	{
+	    perror ("socket");
+	    exit (1);
+	}
+	memset (&sin, 0, sizeof (sin));
+	sin.sin_port = htons (port);
+	sin.sin_family = AF_INET;
+	sin.sin_addr.s_addr = inet_addr (host);
+	if (connect (r, &sin, sizeof (sin)) < 0)
+	{
+	    perror ("connect");
+	    exit (1);
+	}
+	puts ("connected");
+
+	for (;;)
+	{
+	    FD_ZERO (&fds);
+	    FD_SET (r, &fds);
+	    FD_SET (c, &fds);
+	    puts ("Waiting for input");
+	    if (select (((r > c) ? r : c) + 1, &fds, 0, 0, 0) < 0)
+	    {
+		perror ("select");
+		break;
+	    }
+	    if (FD_ISSET (c, &fds))
+	    {
+		if (pass_message ("remote", c, r) != 0)
+		    break;
+	    }
+	    if (FD_ISSET (r, &fds))
+	    {
+		if (pass_message ("local", r, c) != 0)
+		    break;
+	    }
+	}
+
+	close (r);
+	close (c);
+    }
+    close (s);
+
+    exit (0);
+}
@
