head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.38
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.36
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.32
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.34
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.30
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.28
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.26
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.10
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.8
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.6
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.14
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.12
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.1.0.8
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.6
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.4
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	espie:1.1.1.1
	a7r:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2007.10.27.15.01.53;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.23.06.31.31;	author jakemsr;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.16.13.35.52;	author lebel;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.21.16.07.21;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.09.21.16.07.21;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@sequential build of library/shared library unmesses parallel builds...
regen patches while there.
@
text
@$OpenBSD: patch-interface_scsi_interface_c,v 1.3 2005/12/23 06:31:31 jakemsr Exp $
--- interface/scsi_interface.c.orig	Sat Mar 24 02:15:46 2001
+++ interface/scsi_interface.c	Sat Oct 27 16:57:49 2007
@@@@ -23,6 +23,7 @@@@ static void tweak_SG_buffer(cdrom_drive *d){
   int table,reserved;
   char buffer[256];
 
+#ifdef __linux__
   /* maximum transfer size? */
   if(ioctl(d->cdda_fd,SG_GET_RESERVED_SIZE,&reserved)){
     /* Up, guess not. */
@@@@ -31,6 +32,10 @@@@ static void tweak_SG_buffer(cdrom_drive *d){
   }
 
   if(ioctl(d->cdda_fd,SG_GET_SG_TABLESIZE,&table))table=1;
+#else
+  reserved = 32*1024;  /* ? */
+  table = 1;
+#endif
   {
     int cur;
 
@@@@ -53,20 +58,27 @@@@ static void tweak_SG_buffer(cdrom_drive *d){
     cdmessage(d,buffer);
   } 
 
+#ifdef __linux__
   /* Disable command queue; we don't need it, no reason to have it on */
   reserved=0;
   if(ioctl(d->cdda_fd,SG_SET_COMMAND_Q,&reserved)){
     cdmessage(d,"\tCouldn't disable command queue!  Continuing anyway...\n");
   }
-
+#endif
 }
 
 static void reset_scsi(cdrom_drive *d){
   int arg;
   d->enable_cdda(d,0);
 
+#ifdef __linux__
   cdmessage(d,"sending SG SCSI reset... ");
   if(ioctl(d->cdda_fd,SG_SCSI_RESET,&arg))
+#endif
+#if defined (__NetBSD__) || defined (__OpenBSD__)
+  cdmessage(d,"sending SCSI reset... ");
+  if(ioctl(d->cdda_fd,CDIOCRESET,&arg))
+#endif
     cdmessage(d,"FAILED: EBUSY\n");
   else
     cdmessage(d,"OK\n");
@@@@ -74,6 +86,7 @@@@ static void reset_scsi(cdrom_drive *d){
   d->enable_cdda(d,1);
 }
 
+#ifdef __linux__
 static void clear_garbage(cdrom_drive *d){
   fd_set fdset;
   struct timeval tv;
@@@@ -104,6 +117,7 @@@@ static void clear_garbage(cdrom_drive *d){
     flag=1;
   }
 }
+#endif
 
 /* process a complete scsi command. */
 static int handle_scsi_cmd(cdrom_drive *d,
@@@@ -114,11 +128,16 @@@@ static int handle_scsi_cmd(cdrom_drive *d,
 			   unsigned char bytefill,
 			   int bytecheck){
   int status = 0;
+#ifdef __linux__
   struct sg_header *sg_hd=(struct sg_header *)d->sg;
   long writebytes=SG_OFF+cmd_len+in_size;
-
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+  scsireq_t *sreq = (scsireq_t *)d->sg;
+#endif
   /* generic scsi device services */
 
+#ifdef __linux__
   /* clear out any possibly preexisting garbage */
   clear_garbage(d);
 
@@@@ -213,8 +232,38 @@@@ static int handle_scsi_cmd(cdrom_drive *d,
       }
     }
   }
+#endif /* __linux__ */
 
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+  if (in_size && out_size) {
+    warnx("handle_scsi_cmd: in and out is not supported");
+    abort();
+  }
+  memset(sreq, 0, sizeof(scsireq_t));
+  sreq->cmdlen = cmd_len;
+  memcpy(sreq->cmd, d->sg_buffer, cmd_len);
+  if (in_size) {
+    sreq->flags = SCCMD_WRITE;
+    sreq->databuf = d->sg_buffer + cmd_len;
+    sreq->datalen = in_size;
+  }
+  if (out_size) {
+    sreq->flags = SCCMD_READ;
+    sreq->databuf = d->sg_buffer;
+    sreq->datalen = out_size;
+    if(bytecheck)
+      memset(d->sg_buffer, bytefill, out_size); 
+  }
+  sreq->senselen = SENSEBUFLEN;
+  sreq->timeout = 10000;       /* 10s */
+
+  status = ioctl(d->cdda_fd, SCIOCCOMMAND, (void *) sreq);
+  if (status < 0)
+    return(TR_ILLEGAL);
+#endif
+
   errno=0;
+#ifdef __linux__
   status = read(d->cdda_fd, sg_hd, SG_OFF + out_size);
   sigprocmask ( SIG_UNBLOCK, &(d->sigset), NULL );
 
@@@@ -229,6 +278,13 @@@@ static int handle_scsi_cmd(cdrom_drive *d,
     char key=sg_hd->sense_buffer[2]&0xf;
     char ASC=sg_hd->sense_buffer[12];
     char ASCQ=sg_hd->sense_buffer[13];
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+  if (sreq->sense[0]){
+    char key = sreq->sense[2]&0xf;
+    char ASC = sreq->sense[12];
+    char ASCQ = sreq->sense[13];
+#endif
     switch(key){
     case 0:
       if(errno==0)errno=EIO;
@@@@ -266,9 +322,19 @@@@ static int handle_scsi_cmd(cdrom_drive *d,
      commands still get through.  Perhaps no data comes back even
      though the target reports success? */
 
+#ifdef __linux__
   if(bytecheck && in_size+cmd_len<out_size){
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+  if(bytecheck && out_size){
+#endif
     long i,flag=0;
+#ifdef __linux__
     for(i=in_size;i<out_size;i++)
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+    for(i=0;i<out_size;i++)
+#endif
       if(d->sg_buffer[i]!=bytefill){
 	flag=1;
 	break;
@@@@ -600,6 +666,24 @@@@ static int scsi_read_toc2 (cdrom_drive *d){
   return(tracks);
 }
 
+/* Set operating speed */
+static int scsi_setspeed(cdrom_drive *d, int speed)
+{
+  if (speed == 0)   
+    speed = 0xffff;            /* maximum speed */
+  else if (speed < 176)
+    speed *= 176;
+
+  memset(d->sg_buffer, 0, 12);
+  d->sg_buffer[0] = 0xbb;      /* set speed */
+  d->sg_buffer[2] = speed >> 8;
+  d->sg_buffer[3] = speed;
+  d->sg_buffer[4] = -1;
+  d->sg_buffer[5] = -1;
+  return handle_scsi_cmd(d, 12, 0, 0, 0, 0);
+}
+
+
 /* These do one 'extra' copy in the name of clean code */
 
 static int i_read_28 (cdrom_drive *d, void *p, long begin, long sectors){
@@@@ -833,16 +917,28 @@@@ static long scsi_read_map (cdrom_drive *d, void *p, lo
   while(1) {
     if((err=map(d,(p?buffer:NULL),begin,sectors))){
       if(d->report_all){
+#ifdef __linux__
 	struct sg_header *sg_hd=(struct sg_header *)d->sg;
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+       scsireq_t *sreq=(scsireq_t *)d->sg;
+#endif
 	char b[256];
 
 	sprintf(b,"scsi_read error: sector=%ld length=%ld retry=%d\n",
 		begin,sectors,retry_count);
 	cdmessage(d,b);
 	sprintf(b,"                 Sense key: %x ASC: %x ASCQ: %x\n",
+#ifdef __linux__
 		(int)(sg_hd->sense_buffer[2]&0xf),
 		(int)(sg_hd->sense_buffer[12]),
 		(int)(sg_hd->sense_buffer[13]));
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+               (int)(sreq->sense[2]&0xf),
+               (int)(sreq->sense[12]),
+               (int)(sreq->sense[13]));
+#endif
 	cdmessage(d,b);
 	sprintf(b,"                 Transport error: %s\n",strerror_tr[err]);
 	cdmessage(d,b);
@@@@ -852,9 +948,16 @@@@ static long scsi_read_map (cdrom_drive *d, void *p, lo
 	fprintf(stderr,"scsi_read error: sector=%ld length=%ld retry=%d\n",
 		begin,sectors,retry_count);
 	fprintf(stderr,"                 Sense key: %x ASC: %x ASCQ: %x\n",
+#ifdef __linux__
 		(int)(sg_hd->sense_buffer[2]&0xf),
 		(int)(sg_hd->sense_buffer[12]),
 		(int)(sg_hd->sense_buffer[13]));
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+               (int)(sreq->sense[2]&0xf),
+               (int)(sreq->sense[12]),
+               (int)(sreq->sense[13]));
+#endif
 	fprintf(stderr,"                 Transport error: %s\n",strerror_tr[err]);
 	fprintf(stderr,"                 System error: %s\n",strerror(errno));
       }
@@@@ -1308,21 +1411,37 @@@@ static void check_fua_bit(cdrom_drive *d){
 }
 
 static int check_atapi(cdrom_drive *d){
+#ifdef __linux__
   int atapiret=-1;
+#endif
+#if defined (__NetBSD__) || defined (__OpenBSD__)
+  struct scsi_addr scaddr;
+#endif
   int fd = d->cdda_fd; /* this is the correct fd (not ioctl_fd), as the 
 			  generic device is the device we need to check */
 			  
   cdmessage(d,"\nChecking for SCSI emulation...\n");
 
+#ifdef __linux__
   if (ioctl(fd,SG_EMULATED_HOST,&atapiret)){
+#endif
+#if defined (__NetBSD__) || defined (__OpenBSD__)
+  if(ioctl(fd,SCIOCIDENTIFY,&scaddr)){
+#endif
     cderror(d,"\tSG_EMULATED_HOST ioctl() failed!\n");
     return(-1);
   } else {
+#ifdef __linux__
     if(atapiret==1){
       cdmessage(d,"\tDrive is ATAPI (using SCSI host adaptor emulation)\n");
       /* Disable kernel SCSI command translation layer for access through sg */
       if (ioctl(fd,SG_SET_TRANSFORM,0))
 	cderror(d,"\tCouldn't disable kernel command translation layer\n");
+#endif
+#if defined (__NetBSD__) || defined (__OpenBSD__)
+    if(scaddr.type == TYPE_ATAPI){
+      cdmessage(d,"\tDrive is ATAPI\n");
+#endif
       d->is_atapi=1;
     }else{
       cdmessage(d,"\tDrive is SCSI\n");
@@@@ -1434,7 +1553,7 @@@@ int scsi_init_drive(cdrom_drive *d){
 
   d->read_toc = (!memcmp(d->drive_model, "IMS", 3) && !d->is_atapi) ? scsi_read_toc2 : 
     scsi_read_toc;
-  d->set_speed = NULL;
+  d->set_speed = scsi_setspeed;
   
 
   if(!d->is_atapi){
@


1.3
log
@sync with update-patches
@
text
@d1 4
a4 4
$OpenBSD: patch-interface_scsi_interface_c,v 1.2 2002/09/16 13:35:52 lebel Exp $
--- interface/scsi_interface.c.orig	Fri Mar 23 17:15:46 2001
+++ interface/scsi_interface.c	Thu Dec 22 22:30:02 2005
@@@@ -23,6 +23,7 @@@@ static void tweak_SG_buffer(cdrom_drive 
d12 1
a12 1
@@@@ -31,6 +32,10 @@@@ static void tweak_SG_buffer(cdrom_drive 
d23 1
a23 1
@@@@ -53,20 +58,27 @@@@ static void tweak_SG_buffer(cdrom_drive 
d60 1
a60 1
@@@@ -104,6 +117,7 @@@@ static void clear_garbage(cdrom_drive *d
d68 1
a68 1
@@@@ -114,11 +128,16 @@@@ static int handle_scsi_cmd(cdrom_drive *
d86 1
a86 1
@@@@ -213,8 +232,38 @@@@ static int handle_scsi_cmd(cdrom_drive *
d125 1
a125 1
@@@@ -229,6 +278,13 @@@@ static int handle_scsi_cmd(cdrom_drive *
d139 1
a139 1
@@@@ -266,9 +322,19 @@@@ static int handle_scsi_cmd(cdrom_drive *
d159 1
a159 1
@@@@ -600,6 +666,24 @@@@ static int scsi_read_toc2 (cdrom_drive *
d184 1
a184 1
@@@@ -833,16 +917,28 @@@@ static long scsi_read_map (cdrom_drive *
d213 1
a213 1
@@@@ -852,9 +948,16 @@@@ static long scsi_read_map (cdrom_drive *
d230 1
a230 1
@@@@ -1308,21 +1411,37 @@@@ static void check_fua_bit(cdrom_drive *d
@


1.2
log
@update audio/cdparanoia to 3.a9.8;
from Bjorn Sandell <biorn@@dce.chalmers.se> and from NetBSD
@
text
@d1 3
a3 3
$OpenBSD$
--- interface/scsi_interface.c.orig	Sat Mar 24 02:15:46 2001
+++ interface/scsi_interface.c	Mon Sep 16 14:02:54 2002
d91 1
a91 1
+
d119 1
a119 1
 
@


1.1
log
@Initial revision
@
text
@d1 12
a12 12
$OpenBSD: update-patches,v 1.3 2000/06/09 17:08:37 espie Exp $
--- interface/scsi_interface.c.orig	Tue Sep 19 16:20:14 2000
+++ interface/scsi_interface.c	Tue Sep 19 16:16:36 2000
@@@@ -32,6 +32,7 @@@@ static int Dummy (cdrom_drive *d,int s){
 #endif
 
 static int look_for_dougg(cdrom_drive *d){
+#ifdef __linux__
   /* are we using the new SG driver by Doug Gilbert? If so, our memory
      strategy will be different. */
   int reserved,table;
@@@@ -78,6 +79,9 @@@@ static int look_for_dougg(cdrom_drive *d
d15 1
a15 1
   return(1);
d17 17
a33 1
+  return(0);
d37 17
a53 3
 static void find_bloody_big_buff_size(cdrom_drive *d){
@@@@ -142,6 +146,7 @@@@ static void reset_scsi(cdrom_drive *d){
 
d60 1
a60 1
@@@@ -172,20 +177,28 @@@@ static void clear_garbage(cdrom_drive *d
d68 2
a69 5
 			   unsigned int cmd_len, 
 			   unsigned int in_size, 
 			   unsigned int out_size,
-			   unsigned char bytefill,
+			   unsigned int bfill,
a70 1
+  unsigned char bytefill = bfill;
d75 1
a79 1
 
d86 3
a88 3
@@@@ -291,11 +304,53 @@@@ static int handle_scsi_cmd(cdrom_drive *
     if(errno==0)errno=EIO;
     return(TR_EREAD);
d90 1
a90 1
+#endif	/* __linux__ */
d113 1
a113 1
+  sreq->timeout = 10000;	/* 10s */
d120 1
a120 8
-  if(sg_hd->sense_buffer[0]){
+#ifdef __linux__
+  if(sg_hd->sense_buffer[0])
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+  if (sreq->sense[0])
+#endif
+  {
d122 4
d131 1
d139 1
a139 1
@@@@ -333,9 +388,20 @@@@ static int handle_scsi_cmd(cdrom_drive *
a142 1
-  if(bytecheck && in_size+cmd_len<out_size){
d144 1
a144 1
+  if(bytecheck && in_size+cmd_len<out_size)
d147 1
a147 1
+  if(bytecheck && out_size)
a148 1
+  {
d159 26
a184 1
@@@@ -840,16 +906,29 @@@@ static long scsi_read_map (cdrom_drive *
d192 1
a192 1
+	scsireq_t *sreq=(scsireq_t *)d->sg;
d203 1
a203 2
-		(int)(sg_hd->sense_buffer[13]));
+		(int)(sg_hd->sense_buffer[13])
d206 3
a208 3
+		(int)(sreq->sense[2]&0xf),
+		(int)(sreq->sense[12]),
+		(int)(sreq->sense[13])
a209 1
+		);
d213 1
a213 1
@@@@ -859,9 +938,17 @@@@ static long scsi_read_map (cdrom_drive *
d220 1
a220 2
-		(int)(sg_hd->sense_buffer[13]));
+		(int)(sg_hd->sense_buffer[13])
d223 3
a225 3
+		(int)(sreq->sense[2]&0xf),
+		(int)(sreq->sense[12]),
+		(int)(sreq->sense[13])
a226 1
+		);
d230 47
a276 12
@@@@ -1376,6 +1463,11 @@@@ static int guess_atapi(cdrom_drive *d,in
     /* Mt Fuji */
     if(reportp)
       cdmessage(d,"\tDrive appears to be Mt. Fuji ATAPI C/DVD\n");
+    return(1);
+  case 0x32:
+    /* Toshiba DVD */
+    if(reportp)
+      cdmessage(d,"\tDrive appears to be Toshiba ATAPI C/DVD\n");
     return(1);
   default:
     if(reportp)
@


1.1.1.1
log
@Based on the NetBSD port, initially brought to Open by
Alexander S . Guy.

Some minor packaging tweaks.

Uses cd0c by default, as this is the most likely place for a CD-Rom drive.
@
text
@@
