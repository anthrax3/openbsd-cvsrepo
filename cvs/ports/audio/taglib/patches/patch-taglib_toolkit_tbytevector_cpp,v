head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.12
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.10
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.8
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.4
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.6
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.2
	OPENBSD_5_7_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2014.11.10.10.55.58;	author dcoppa;	state Exp;
branches;
next	;
commitid	QYS2Xe5ifb8PVDD9;


desc
@@


1.1
log
@
Merge some fixes from upstream via Fedora:

- Rewrote ByteVector::replace() simpler
- Fixed a wrong byte order handling on big-endian machines
- Changed XM::File::save() to use seek() properly
- Added some missing deletes to test_flac.cpp

Now the testsuite is 100% successful
@
text
@$OpenBSD$

From 4a7d31c87bf41c1de21cb725176d5b34c2a95720 Mon Sep 17 00:00:00 2001
From: Tsuda Kageyu <tsuda.kageyu@@gmail.com>
Date: Thu, 14 Nov 2013 14:05:32 +0900
Subject: [PATCH] Rewrote ByteVector::replace() simpler

--- taglib/toolkit/tbytevector.cpp.orig	Tue Oct  8 17:50:01 2013
+++ taglib/toolkit/tbytevector.cpp	Mon Nov 10 10:57:36 2014
@@@@ -31,6 +31,7 @@@@
 #include <iostream>
 #include <cstdio>
 #include <cstring>
+#include <cstddef>
 
 #include <tstring.h>
 #include <tdebug.h>
@@@@ -508,62 +509,40 @@@@ ByteVector &ByteVector::replace(const ByteVector &patt
   if(pattern.size() == 0 || pattern.size() > size())
     return *this;
 
-  const uint withSize = with.size();
-  const uint patternSize = pattern.size();
-  int offset = 0;
+  const size_t withSize    = with.size();
+  const size_t patternSize = pattern.size();
+  const ptrdiff_t diff = withSize - patternSize;
+  
+  size_t offset = 0;
+  while (true)
+  {
+    offset = find(pattern, offset);
+    if(offset == static_cast<size_t>(-1)) // Use npos in taglib2.
+      break;
 
-  if(withSize == patternSize) {
-    // I think this case might be common enough to optimize it
     detach();
-    offset = find(pattern);
-    while(offset >= 0) {
-      ::memcpy(data() + offset, with.data(), withSize);
-      offset = find(pattern, offset + withSize);
-    }
-    return *this;
-  }
 
-  // calculate new size:
-  uint newSize = 0;
-  for(;;) {
-    int next = find(pattern, offset);
-    if(next < 0) {
-      if(offset == 0)
-        // pattern not found, do nothing:
-        return *this;
-      newSize += size() - offset;
-      break;
+    if(diff < 0) {
+      ::memmove(
+        data() + offset + withSize, 
+        data() + offset + patternSize, 
+        size() - offset - patternSize);
+      resize(size() + diff);
     }
-    newSize += (next - offset) + withSize;
-    offset = next + patternSize;
-  }
+    else if(diff > 0) {
+      resize(size() + diff);
+      ::memmove(
+        data() + offset + withSize, 
+        data() + offset + patternSize, 
+        size() - diff - offset - patternSize);
+    }
 
-  // new private data of appropriate size:
-  ByteVectorPrivate *newData = new ByteVectorPrivate(newSize, 0);
-  char *target = DATA(newData);
-  const char *source = data();
+    ::memcpy(data() + offset, with.data(), with.size());
 
-  // copy modified data into new private data:
-  offset = 0;
-  for(;;) {
-    int next = find(pattern, offset);
-    if(next < 0) {
-      ::memcpy(target, source + offset, size() - offset);
+    offset += withSize;
+    if(offset > size() - patternSize)
       break;
-    }
-    int chunkSize = next - offset;
-    ::memcpy(target, source + offset, chunkSize);
-    target += chunkSize;
-    ::memcpy(target, with.data(), withSize);
-    target += withSize;
-    offset += chunkSize + patternSize;
   }
-
-  // replace private data:
-  if(d->deref())
-    delete d;
-
-  d = newData;
 
   return *this;
 }
@
