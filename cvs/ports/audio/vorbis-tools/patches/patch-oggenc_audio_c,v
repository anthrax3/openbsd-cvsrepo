head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.12
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.10
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.6
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_8:1.3.0.2
	OPENBSD_3_1:1.1.0.2
	OPENBSD_3_1_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2015.09.10.21.03.12;	author naddy;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;
commitid	2x6vn1fGD4naJDp1;

1.2
date	2002.07.20.00.52.45;	author naddy;	state dead;
branches;
next	1.1;

1.1
date	2002.03.26.02.40.55;	author naddy;	state Exp;
branches;
next	;

1.3.2.1
date	2015.09.11.19.37.49;	author naddy;	state Exp;
branches;
next	;
commitid	rBKlpCWfNOGLLrR1;

1.3.4.1
date	2015.09.11.19.38.11;	author naddy;	state Exp;
branches;
next	;
commitid	mIY0i5GTfXX5hDmK;


desc
@@


1.3
log
@Security fixes for:
CVE-2015-6749 (aiff_open buffer overflow)
CVE-2014-9638 (division by zero)
CVE-2014-9639 (channel integer overflow)

Also fix a crash on raw file close.

Via Jason Unovitch/FreeBSD
@
text
@$OpenBSD$

CVE-2015-6749 (aiff_open buffer overflow)
https://trac.xiph.org/attachment/ticket/2212/0001-oggenc-Fix-large-alloca-on-bad-AIFF-input.patch

CVE-2014-9638 (division by zero)
CVE-2014-9639 (channel integer overflow)
http://pkgs.fedoraproject.org/cgit/vorbis-tools.git/tree/vorbis-tools-1.4.0-CVE-2014-9638-CVE-2014-9639.patch

--- oggenc/audio.c.orig	Wed Mar 24 09:27:14 2010
+++ oggenc/audio.c	Thu Sep 10 22:48:38 2015
@@@@ -13,6 +13,7 @@@@
 #include <config.h>
 #endif
 
+#include <limits.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@@@ -245,12 +246,13 @@@@ static int aiff_permute_matrix[6][6] = 
 int aiff_open(FILE *in, oe_enc_opt *opt, unsigned char *buf, int buflen)
 {
     int aifc; /* AIFC or AIFF? */
-    unsigned int len;
-    unsigned char *buffer;
+    unsigned int len, readlen;
+    unsigned char buffer[22];
     unsigned char buf2[8];
     aiff_fmt format;
     aifffile *aiff = malloc(sizeof(aifffile));
     int i;
+    long channels;
 
     if(buf[11]=='C')
         aifc=1;
@@@@ -269,19 +271,25 @@@@ int aiff_open(FILE *in, oe_enc_opt *opt, unsigned char
         return 0; /* Weird common chunk */
     }
 
-    buffer = alloca(len);
-
-    if(fread(buffer,1,len,in) < len)
+    readlen = len < sizeof(buffer) ? len : sizeof(buffer);
+    if(fread(buffer,1,readlen,in) < readlen ||
+       (len > readlen && !seek_forward(in, len-readlen)))
     {
         fprintf(stderr, _("Warning: Unexpected EOF in reading AIFF header\n"));
         return 0;
     }
 
-    format.channels = READ_U16_BE(buffer);
+    format.channels = channels = READ_U16_BE(buffer);
     format.totalframes = READ_U32_BE(buffer+2);
     format.samplesize = READ_U16_BE(buffer+6);
     format.rate = (int)read_IEEE80(buffer+8);
 
+    if(channels <= 0L || SHRT_MAX < channels)
+    {
+         fprintf(stderr, _("Warning: Unsupported count of channels in AIFF header\n"));
+         return 0;
+    }
+
     aiff->bigendian = 1;
 
     if(aifc)
@@@@ -412,6 +420,7 @@@@ int wav_open(FILE *in, oe_enc_opt *opt, unsigned char 
     wav_fmt format;
     wavfile *wav = malloc(sizeof(wavfile));
     int i;
+    long channels;
 
     /* Ok. At this point, we know we have a WAV file. Now we have to detect
      * whether we support the subtype, and we have to find the actual data
@@@@ -449,11 +458,17 @@@@ int wav_open(FILE *in, oe_enc_opt *opt, unsigned char 
     }
 
     format.format =      READ_U16_LE(buf);
-    format.channels =    READ_U16_LE(buf+2);
+    format.channels = channels = READ_U16_LE(buf+2);
     format.samplerate =  READ_U32_LE(buf+4);
     format.bytespersec = READ_U32_LE(buf+8);
     format.align =       READ_U16_LE(buf+12);
     format.samplesize =  READ_U16_LE(buf+14);
+
+    if(channels <= 0L || SHRT_MAX < channels)
+    {
+        fprintf(stderr, _("Warning: Unsupported count of channels in WAV header\n"));
+        return 0;
+    }
 
     if(format.format == -2) /* WAVE_FORMAT_EXTENSIBLE */
     {
@


1.3.4.1
log
@MFC: Security fixes for
CVE-2015-6749 (aiff_open buffer overflow)
CVE-2014-9638 (division by zero)
CVE-2014-9639 (channel integer overflow)

Also fix a crash on raw file close.

Via Jason Unovitch/FreeBSD
@
text
@@


1.3.2.1
log
@MFC: Security fixes for
CVE-2015-6749 (aiff_open buffer overflow)
CVE-2014-9638 (division by zero)
CVE-2014-9639 (channel integer overflow)

Also fix a crash on raw file close.

Via Jason Unovitch/FreeBSD
@
text
@@


1.2
log
@Welcome to Ogg Vorbis 1.0!
@
text
@d1 14
a14 8
$OpenBSD: patch-oggenc_audio_c,v 1.1 2002/03/26 02:40:55 naddy Exp $
--- oggenc/audio.c.orig	Tue Mar 26 03:22:27 2002
+++ oggenc/audio.c	Tue Mar 26 03:23:35 2002
@@@@ -570,6 +570,7 @@@@ int raw_open(FILE *in, oe_enc_opt *opt)
 	wav->bigendian =     0;
 	wav->channels =      format.channels;
 	wav->samplesize =    opt->samplesize;
+	wav->totalsamples =  0;
d16 77
a92 2
 	opt->read_samples = wav_read;
 	opt->readdata = (void *)wav;
@


1.1
log
@Fix encoding of raw files; from Xiph CVS.
@
text
@d1 1
a1 1
$OpenBSD$
@

