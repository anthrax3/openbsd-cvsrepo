head	1.1;
access;
symbols
	OPENBSD_6_1:1.1.0.18
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.16
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.12
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.14
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.10
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.8
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.6
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_3:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2013.10.14.07.17.21;	author dcoppa;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2013.10.28.17.23.40;	author jasper;	state Exp;
branches;
next	;

1.1.4.1
date	2013.10.30.12.08.33;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Security fix for a heap-based buffer overflow in the it_read_envelope
function (CVE-2006-3668).
Cherry-picked from Fedora.

OK brad@@
@
text
@$OpenBSD$

Fix heap-based buffer overflow in the it_read_envelope function
(CVE-2006-3668)

--- src/it/itread.c.orig	Mon Aug  8 02:18:41 2005
+++ src/it/itread.c	Fri Oct 11 16:37:22 2013
@@@@ -292,6 +292,11 @@@@ static int it_read_envelope(IT_ENVELOPE *envelope, DUM
 
 	envelope->flags = dumbfile_getc(f);
 	envelope->n_nodes = dumbfile_getc(f);
+	if(envelope->n_nodes > 25) {
+		TRACE("IT error: wrong number of envelope nodes (%d)\n", envelope->n_nodes);
+		envelope->n_nodes = 0;
+		return -1;
+	}
 	envelope->loop_start = dumbfile_getc(f);
 	envelope->loop_end = dumbfile_getc(f);
 	envelope->sus_loop_start = dumbfile_getc(f);
@


1.1.4.1
log
@Security fix for CVE-2006-3668
@
text
@d1 1
a1 1
$OpenBSD: patch-src_it_itread_c,v 1.1 2013/10/14 07:17:21 dcoppa Exp $
@


1.1.2.1
log
@Security fix for CVE-2006-3668
@
text
@d1 1
a1 1
$OpenBSD: patch-src_it_itread_c,v 1.1 2013/10/14 07:17:21 dcoppa Exp $
@

