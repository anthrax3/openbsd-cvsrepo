head	1.4;
access;
symbols
	OPENBSD_5_8:1.3.0.14
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.10
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	landry_20110609:1.1.1.1
	dwatteau:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2016.01.17.01.16.38;	author juanfra;	state dead;
branches;
next	1.3;
commitid	vDhhxDQWiaQMjGv5;

1.3
date	2012.12.27.12.02.33;	author gonzalo;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.02.14.11.55;	author rpointel;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.06.07.10.56;	author landry;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.09.06.07.10.56;	author landry;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to cmus 2.7.1. From Donovan Watteau (MAINTAINER).
Tests and the updated quirks file by Florian Stinglmayr.
@
text
@/*
 * Copyright (C) 2011 Donovan "Tsomi" Watteau <tsoomi@@gmail.com>
 *
 * Based on Thomas Pfaff's work for XMMS, and some suggestions from
 * Alexandre Ratchov.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <sndio.h>

#include "op.h"
#include "mixer.h"
#include "sf.h"
#include "xmalloc.h"

static sample_format_t sndio_sf;
static struct sio_par par;
static struct sio_hdl *hdl = NULL;
static int sndio_volume = 100;
static int sndio_paused;

static int sndio_mixer_set_volume(int l, int r)
{
	sndio_volume = l > r ? l : r;

	if (hdl != NULL)
		sio_setvol(hdl, sndio_volume * SIO_MAXVOL / 100);

	return 0;
}

static int sndio_mixer_get_volume(int *l, int *r)
{
	*l = *r = sndio_volume;

	return 0;
}

static int sndio_set_sf(sample_format_t sf)
{
	struct sio_par apar;

	sndio_sf = sf;

	sio_initpar(&par);

	par.pchan = sf_get_channels(sndio_sf);
	par.rate = sf_get_rate(sndio_sf);
	sndio_paused = 0;

	if (sf_get_signed(sndio_sf))
		par.sig = 1;
	else
		par.sig = 0;

	if (sf_get_bigendian(sndio_sf))
		par.le = 0;
	else
		par.le = 1;

	switch (sf_get_bits(sndio_sf)) {
	case 16:
		par.bits = 16;
		break;
	case 8:
		par.bits = 8;
		break;
	default:
		return -1;
	}

	par.appbufsz = par.rate * 300 / 1000;
	apar = par;

	if (!sio_setpar(hdl, &par))
		return -1;

	if (!sio_getpar(hdl, &par))
		return -1;

	if (apar.rate != par.rate || apar.pchan != par.pchan ||
	    apar.bits != par.bits || (par.bits > 8 && apar.le != par.le) ||
	    apar.sig != par.sig)
		return -1;

	sndio_mixer_set_volume(sndio_volume, sndio_volume);

	if (!sio_start(hdl))
		return -1;

	return 0;
}

static int sndio_init(void)
{
	return 0;
}

static int sndio_exit(void)
{
	return 0;
}

static int sndio_close(void)
{
	if (hdl != NULL) {
		sio_close(hdl);
		hdl = NULL;
	}

	return 0;
}

static int sndio_open(sample_format_t sf, const channel_position_t *channel_map)
{
	hdl = sio_open(NULL, SIO_PLAY, 0);
	if (hdl == NULL)
		return -1;

	if (sndio_set_sf(sf) == -1) {
		sndio_close();
		return -1;
	}

	return 0;
}

static int sndio_write(const char *buf, int cnt)
{
	size_t rc;

	rc = sio_write(hdl, buf, cnt);
	if (rc == 0)
		return -1;

	return rc;
}

static int op_sndio_set_option(int key, const char *val)
{
	return -OP_ERROR_NOT_OPTION;
}

static int op_sndio_get_option(int key, char **val)
{
	return -OP_ERROR_NOT_OPTION;
}

static int sndio_pause(void)
{
	if (!sndio_paused) {
		sio_stop(hdl);
		sndio_paused = 1;
	}

	return 0;
}

static int sndio_unpause(void)
{
	if (sndio_paused) {
		sio_start(hdl);
		sndio_paused = 0;
	}

	return 0;
}

static int sndio_buffer_space(void)
{
	/*
	 * Do as if there's always some space and let sio_write() block.
	 */
	return par.bufsz * par.bps * par.pchan;
}

static int sndio_mixer_init(void)
{
	return OP_ERROR_SUCCESS;
}

static int sndio_mixer_exit(void)
{
	return OP_ERROR_SUCCESS;
}

static int sndio_mixer_open(int *volume_max)
{
	*volume_max = 100; 

	return OP_ERROR_SUCCESS;
}

static int sndio_mixer_close(void)
{
	return OP_ERROR_SUCCESS;
}

static int sndio_mixer_set_option(int key, const char *val)
{
	return -OP_ERROR_NOT_OPTION;
}

static int sndio_mixer_get_option(int key, char **val)
{
	return -OP_ERROR_NOT_OPTION;
}

const struct output_plugin_ops op_pcm_ops = {
	.init = sndio_init,
	.exit = sndio_exit,
	.open = sndio_open,
	.close = sndio_close,
	.write = sndio_write,
	.pause = sndio_pause,
	.unpause = sndio_unpause,
	.buffer_space = sndio_buffer_space,
	.set_option = op_sndio_set_option,
	.get_option = op_sndio_get_option
};

const struct mixer_plugin_ops op_mixer_ops = {
	.init = sndio_mixer_init,
	.exit = sndio_mixer_exit,
	.open = sndio_mixer_open,
	.close = sndio_mixer_close,
	.set_volume = sndio_mixer_set_volume,
	.get_volume = sndio_mixer_get_volume,
	.set_option = sndio_mixer_set_option,
	.get_option = sndio_mixer_get_option
};

const char * const op_pcm_options[] = {
	NULL
};

const char * const op_mixer_options[] = {
	NULL
};

const int op_priority = 2;
@


1.3
log
@Update for cmus to 2.5.0:

Two further changes:
  * I added CONFIG_ALSA=n back. Someone added it, I don't really know
    why, but I see that some other ports are explicitely disabling ALSA
    support, too. So I'll continue doing the same.
  * I added a patch from upstream which fixes a segfault.

From maintainer Donovan Watteau, Thanks!

Ok aja@@
@
text
@@


1.2
log
@Correct files/sndio.c, from Donovan Watteau (MAINTAINER).
Bump revision of -main subpackage.
@
text
@d134 1
a134 1
static int sndio_open(sample_format_t sf)
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * Copyright (C) 2010 Donovan "Tsomi" Watteau <tsoomi@@gmail.com>
a41 9
static long long rdpos;
static long long wrpos;
static long bytes_per_sec;

static void onmove_cb(void *addr, int delta)
{
	rdpos += delta * (int)(par.bps * par.pchan);
}

d92 1
d101 5
a105 3
	wrpos = 0;
	rdpos = 0;
	sio_onmove(hdl, onmove_cb, NULL);
a110 1
	bytes_per_sec = par.bps * par.pchan * par.rate;
d130 1
a130 1
	
d139 1
d150 1
a150 1
	const char *t;
d152 3
a154 14
	cnt /= 4;
	cnt *= 4;
	t = buf;
	while (cnt > 0) {
		int rc = sio_write(hdl, buf, cnt);
		if (rc == -1) {
			if (errno == EINTR)
				continue;
			else
				return rc;
		}
		buf += rc;
		cnt -= rc;
	}
d156 1
a156 1
	return (buf - t);
d171 4
a174 1
	sndio_paused = 1;
d181 4
a184 1
	sndio_paused = 0;
d191 4
a194 1
	return par.bufsz;
@


1.1.1.1
log
@Import cmus 2.4.2, from MAINTAINER Donovan Watteau.

cmus is a small ncurses-based music player. It supports various output
methods by output plugins. It has got completely configurable key
bindings and it can be controlled from the outside via cmus-remote(1).

sndio backend from Donovan with feedback from ratchov@@
with testing on arm & ok kili@@
@
text
@@
