head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.26
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.22
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.24
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.20
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.18
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.16
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.14
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.12
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.10
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2010.04.08.08.47.09;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.19.22.59.27;	author jakemsr;	state Exp;
branches;
next	;


desc
@@


1.2
log
@- update soundtracker to the gtk2 version
* sndio bits by jakemsr, thanks
@
text
@/*
 * Copyright (c) 2009 Jacob Meuser <jakemsr@@sdf.lonestar.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#include <config.h>

#include <stdio.h>
#include <stdlib.h>
#include <poll.h>
#include <pthread.h>
#include <unistd.h>
#include <sndio.h>

#include <glib.h>
#include <gtk/gtk.h>

#include "driver-inout.h"
#include "mixer.h"
#include "errors.h"

typedef struct sndio_in_driver {
	struct sio_hdl *hdl;
	struct sio_par par;

	pthread_t read_tid;
	int read_trun;

	void *sndbuf;
	int bufsize;
	int mf;

} sndio_in_driver;


static void *
read_thread(void *dp)
{
	sndio_in_driver *d = dp;
	struct pollfd pfd;
	int size, ret, off, nfds;

	if (!sio_start(d->hdl)) {
		error_error("could not start sndio");
		goto done;
	}

	while (d->read_trun) {
		nfds = sio_pollfd(d->hdl, &pfd, POLLIN);
		poll(&pfd, nfds, -1);
		if (sio_revents(d->hdl, &pfd) & POLLIN) {
			size = d->par.rchan * d->par.bps * d->bufsize;
			off = 0;
			while (size > 0) {
				ret = sio_read(d->hdl, d->sndbuf + off, size);
				off += ret;
				size -= ret;
			}
			sample_editor_sampled(d->sndbuf, d->bufsize,
			    d->par.rate, d->mf);
		}
	}
done:
	pthread_exit(NULL);
	return NULL;
}

static void *
sndio_new(void)
{
	sndio_in_driver *d = g_new(sndio_in_driver, 1);

	d->hdl = NULL;
	d->sndbuf = NULL;

	return d;
}

static void
sndio_release(void *dp)
{
	sndio_in_driver *d = dp;

	d->read_trun = 0;
	pthread_join(d->read_tid, NULL);

	if (d->sndbuf)
		free(d->sndbuf);
	d->sndbuf = NULL;

	if (d->hdl)
		sio_close(d->hdl);
	d->hdl = NULL;
}

static void
sndio_destroy(void *dp)
{
	/* just in case */
	sndio_release(dp);

	g_free(dp);
}

static gboolean
sndio_open(void *dp)
{
	sndio_in_driver *d = dp;
	char buf[256];

	sio_initpar(&d->par);

	d->hdl = sio_open(NULL, SIO_REC, 0);
	if (d->hdl == NULL) {
		snprintf(buf, sizeof(buf), "can't open sndio rec device");
		goto out;
	}

	d->par.rate = 44100;
	d->par.bits = 16;
	d->par.rchan = 1;
	d->par.appbufsz = 2048;

	if (!sio_setpar(d->hdl, &d->par) || !sio_getpar(d->hdl, &d->par)) {
		snprintf(buf, sizeof(buf), "can't configure sndio device");
		goto out;
	}

	if (d->par.bits == 16) {
		if (d->par.sig) {
			if (d->par.le)
				d->mf = ST_MIXER_FORMAT_S16_LE;
			else
				d->mf = ST_MIXER_FORMAT_S16_BE;
		} else {
			if (d->par.le)
				d->mf = ST_MIXER_FORMAT_U16_LE;
			else
				d->mf = ST_MIXER_FORMAT_U16_BE;
		}
	} else if (d->par.bits == 8) {
		if (d->par.sig)
			d->mf = ST_MIXER_FORMAT_S8;
		else
			d->mf = ST_MIXER_FORMAT_U8;
	} else {
		snprintf(buf, sizeof(buf), "invalid sndio bit-depth");
		goto out;
	}

	if (d->par.rchan == 2) {
		d->mf |= ST_MIXER_FORMAT_STEREO;
	} else if (d->par.rchan != 1) {
		snprintf(buf, sizeof(buf), "invalid sndio channel count");
		goto out;
	}

	d->bufsize = d->par.round;

	d->sndbuf = calloc(1, d->bufsize * d->par.bps * d->par.rchan);

	d->read_trun = 1;
	if (pthread_create(&d->read_tid, NULL, read_thread, d)) {
		snprintf(buf, sizeof(buf), "couldn't spawn reading thread");
		goto out;
	}

	return TRUE;

out:
	error_error(buf);
	sndio_release(dp);
	return FALSE;
}

static GtkWidget *
sndio_getwidget(void *dp)
{
	return NULL;
}

static gboolean
sndio_loadsettings(void *dp, prefs_node *f)
{
	return TRUE;
}

static gboolean
sndio_savesettings(void *dp, prefs_node *f)
{
	return TRUE;
}

st_io_driver driver_in_sndio = {
	{
		"Sndio Input",
		sndio_new,
		sndio_destroy,
		sndio_open,
		sndio_release,

		sndio_getwidget,
		sndio_loadsettings,
		sndio_savesettings,
	}
};
@


1.1
log
@- update to soundtracker-0.6.8
- use sndio for audio, kill esd flavor
- various cleanup

ok MAINTAINER
@
text
@d30 1
a30 1
#include "driver-in.h"
d206 1
a206 1
st_in_driver driver_in_sndio = {
@

