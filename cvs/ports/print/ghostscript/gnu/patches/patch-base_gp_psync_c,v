head	1.1;
access;
symbols
	OPENBSD_6_1:1.1.0.18
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.16
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.12
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.14
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.10
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.8
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.6
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2012.09.09.08.57.36;	author kili;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Create mutexes with type PTHREAD_MUTEX_RECURSIVE to stop ghostscript from
aborting.

ok aja@@
@
text
@$OpenBSD$

Use PTHREAD_MUTEX_RECURSIVE, which works fine even with the (broken)
wrappers still around which try to simulate PTHREAD_MUTEX_RECURSIVE
for mutexes created with default attributes.

--- base/gp_psync.c.orig	Wed Aug  8 10:01:36 2012
+++ base/gp_psync.c	Sun Sep  9 09:03:31 2012
@@@@ -147,13 +147,21 @@@@ int
 gp_monitor_open(gp_monitor * mona)
 {
     pthread_mutex_t *mon;
+    pthread_mutexattr_t mattr;
     int scode;
 
     if (!mona)
         return -1;		/* monitors are not movable */
     mon = &((gp_pthread_recursive_t *)mona)->mutex;
     ((gp_pthread_recursive_t *)mona)->self_id = 0;	/* Not valid unless mutex is locked */
-    scode = pthread_mutex_init(mon, NULL);
+    scode = pthread_mutexattr_init(&mattr);
+    if (scode != 0)
+	return SEM_ERROR_CODE(scode);
+    scode = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);
+    if (scode != 0)
+	return SEM_ERROR_CODE(scode);
+    scode = pthread_mutex_init(mon, &mattr);
+    pthread_mutexattr_destroy(&mattr);
     return SEM_ERROR_CODE(scode);
 }
 
@
