head	1.5;
access;
symbols
	OPENBSD_4_5:1.3.0.2;
locks; strict;
comment	@# @;


1.5
date	2010.11.12.07.09.00;	author ajacoutot;	state dead;
branches;
next	1.4;

1.4
date	2010.11.10.12.53.09;	author kili;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.21.13.03.12;	author ajacoutot;	state dead;
branches
	1.3.2.1;
next	1.2;

1.2
date	2009.04.10.16.36.02;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.10.15.35.01;	author ajacoutot;	state Exp;
branches;
next	;

1.3.2.1
date	2009.06.28.03.53.16;	author william;	state Exp;
branches;
next	;


desc
@@


1.5
log
@This release fixes several scheduler and printing bugs as well as a reported
security bug (which kili@@ already patched for in previous commmit).
@
text
@$OpenBSD: patch-cups_ipp_c,v 1.4 2010/11/10 12:53:09 kili Exp $
--- cups/ipp.c.orig	Fri Apr 23 20:56:34 2010
+++ cups/ipp.c	Wed Nov 10 11:19:50 2010
@@@@ -1275,7 +1275,9 @@@@ ippReadIO(void       *src,		/* I - Data source */
 
 	      attr->value_tag = tag;
 	    }
-	    else if ((value_tag >= IPP_TAG_TEXTLANG &&
+	    else if (value_tag == IPP_TAG_TEXTLANG ||
+	             value_tag == IPP_TAG_NAMELANG ||
+		     (value_tag >= IPP_TAG_TEXT &&
 		      value_tag <= IPP_TAG_MIMETYPE))
             {
 	     /*
@@@@ -1283,8 +1285,9 @@@@ ippReadIO(void       *src,		/* I - Data source */
 	      * forms; accept sets of differing values...
 	      */
 
-	      if ((tag < IPP_TAG_TEXTLANG || tag > IPP_TAG_MIMETYPE) &&
-	          tag != IPP_TAG_NOVALUE)
+	      if (tag != IPP_TAG_TEXTLANG && tag != IPP_TAG_NAMELANG &&
+	          (tag < IPP_TAG_TEXT || tag > IPP_TAG_MIMETYPE) &&
+		  tag != IPP_TAG_NOVALUE)
 	      {
 		DEBUG_printf(("1ippReadIO: 1setOf value tag %x(%s) != %x(%s)",
 			      value_tag, ippTagString(value_tag), tag,
@@@@ -2766,6 +2769,7 @@@@ _ippFreeAttr(ipp_attribute_t *attr)	/* I - Attribute t
   {
     case IPP_TAG_TEXT :
     case IPP_TAG_NAME :
+    case IPP_TAG_RESERVED_STRING :
     case IPP_TAG_KEYWORD :
     case IPP_TAG_URI :
     case IPP_TAG_URISCHEME :
@


1.4
log
@Security patch: CVE-2010-2941 (from redhat).

ok ajacoutot@@ (maintainer)

For increased fun, read the ticket at redhat:
https://bugzilla.redhat.com/show_bug.cgi?id=624438
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3
log
@- remove workaround now that our default thread stack size has been
increased
@
text
@d1 34
a34 25
$OpenBSD: patch-cups_ipp_c,v 1.2 2009/04/10 16:36:02 ajacoutot Exp $

Lower buffer so that we don't run into memory access issues with default
limits.

--- cups/ipp.c.orig	Fri Apr 10 16:56:45 2009
+++ cups/ipp.c	Fri Apr 10 16:57:46 2009
@@@@ -1023,7 +1023,7 @@@@ ippReadIO(void       *src,		/* I - Data source */
           ipp_t      *ipp)		/* I - IPP data */
 {
   int			n;		/* Length of data */
-  unsigned char		buffer[32768],	/* Data buffer */
+  unsigned char		buffer[4096],	/* Data buffer */
 			string[255],	/* Small string buffer */
 			*bufptr;	/* Pointer into buffer */
   ipp_attribute_t	*attr;		/* Current attribute */
@@@@ -1633,7 +1633,7 @@@@ ippWriteIO(void       *dst,		/* I - Destination */
 {
   int			i;		/* Looping var */
   int			n;		/* Length of data */
-  unsigned char		buffer[32768],	/* Data buffer */
+  unsigned char		buffer[4096],	/* Data buffer */
 			*bufptr;	/* Pointer into buffer */
   ipp_attribute_t	*attr;		/* Current attribute */
   ipp_value_t		*value;		/* Current value */
@


1.3.2.1
log
@SECURITY FIX

Resolve these, from debian:

CVE-2007-4351
CVE-2007-5849
CVE-2007-6358
CVE-2008-0047
CVE-2008-0053
CVE-2008-0882
CVE-2008-1373
CVE-2008-1722, plus integer overflow patch from L2974: _cupsImageReadPNG()
CVE-2008-3639
CVE-2008-3640
CVE-2008-3641, without SP_select_pen() in STR #2911, and fix an
additional off-by-one (STR #2966)
CVE-2009-0163
CVE-2009-0949

ok robert@@
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
CVE-2007-4351
d6 3
a8 3
--- cups/ipp.c.orig	Fri Jun  2 11:15:23 2006
+++ cups/ipp.c	Sat Jun 20 22:36:29 2009
@@@@ -1023,8 +1023,10 @@@@ ippReadIO(void       *src,		/* I - Data source */
d13 2
a14 5
-			string[255],	/* Small string buffer */
+  unsigned char		buffer[IPP_MAX_LENGTH],
+					/* Data buffer */
+			string[IPP_MAX_NAME],
+					/* Small string buffer */
d17 1
a17 151
   ipp_tag_t		tag;		/* Current tag */
@@@@ -1312,6 +1314,12 @@@@ ippReadIO(void       *src,		/* I - Data source */
 	  {
 	    case IPP_TAG_INTEGER :
 	    case IPP_TAG_ENUM :
+		if (n != 4)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, 4) < 4)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read integer value!");
@@@@ -1324,6 +1332,12 @@@@ ippReadIO(void       *src,		/* I - Data source */
                 value->integer = n;
 	        break;
 	    case IPP_TAG_BOOLEAN :
+		if (n != 1)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, 1) < 1)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read boolean value!");
@@@@ -1341,6 +1355,12 @@@@ ippReadIO(void       *src,		/* I - Data source */
 	    case IPP_TAG_CHARSET :
 	    case IPP_TAG_LANGUAGE :
 	    case IPP_TAG_MIMETYPE :
+		if (n >= sizeof(buffer))
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 		if ((*cb)(src, buffer, n) < n)
 		{
 		  DEBUG_puts("ippReadIO: unable to read name!");
@@@@ -1353,6 +1373,12 @@@@ ippReadIO(void       *src,		/* I - Data source */
 		              value->string.text));
 	        break;
 	    case IPP_TAG_DATE :
+		if (n != 11)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, value->date, 11) < 11)
 		{
 	          DEBUG_puts("ippReadIO: Unable to date integer value!");
@@@@ -1360,6 +1386,12 @@@@ ippReadIO(void       *src,		/* I - Data source */
 		}
 	        break;
 	    case IPP_TAG_RESOLUTION :
+		if (n != 9)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, 9) < 9)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read resolution value!");
@@@@ -1376,6 +1408,12 @@@@ ippReadIO(void       *src,		/* I - Data source */
 		    (ipp_res_t)buffer[8];
 	        break;
 	    case IPP_TAG_RANGE :
+		if (n != 8)
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, 8) < 8)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read range value!");
@@@@ -1391,7 +1429,7 @@@@ ippReadIO(void       *src,		/* I - Data source */
 	        break;
 	    case IPP_TAG_TEXTLANG :
 	    case IPP_TAG_NAMELANG :
-	        if (n > sizeof(buffer) || n < 4)
+	        if (n >= sizeof(buffer) || n < 4)
 		{
 		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
 		  return (IPP_ERROR);
@@@@ -1417,22 +1455,27 @@@@ ippReadIO(void       *src,		/* I - Data source */
 
 		n = (bufptr[0] << 8) | bufptr[1];
 
-                if (n >= sizeof(string))
+		if ((bufptr + 2 + n) >= (buffer + sizeof(buffer)) ||
+		    n >= sizeof(string))
 		{
-		  memcpy(string, bufptr + 2, sizeof(string) - 1);
-		  string[sizeof(string) - 1] = '\0';
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
 		}
-		else
-		{
-		  memcpy(string, bufptr + 2, n);
-		  string[n] = '\0';
-                }
 
+		memcpy(string, bufptr + 2, n);
+		string[n] = '\0';
+
 		value->string.charset = _cupsStrAlloc((char *)string);
 
                 bufptr += 2 + n;
 		n = (bufptr[0] << 8) | bufptr[1];
 
+		if ((bufptr + 2 + n) >= (buffer + sizeof(buffer)))
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 		bufptr[2 + n] = '\0';
                 value->string.text = _cupsStrAlloc((char *)bufptr + 2);
 	        break;
@@@@ -1474,6 +1517,12 @@@@ ippReadIO(void       *src,		/* I - Data source */
 		* we need to carry over...
 		*/
 
+		if (n >= sizeof(buffer))
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
 	        if ((*cb)(src, buffer, n) < n)
 		{
 	          DEBUG_puts("ippReadIO: Unable to read member name value!");
@@@@ -1495,6 +1544,12 @@@@ ippReadIO(void       *src,		/* I - Data source */
 		break;
 
             default : /* Other unsupported values */
+		if (n > sizeof(buffer))
+		{
+		  DEBUG_printf(("ippReadIO: bad value length %d!\n", n));
+		  return (IPP_ERROR);
+		}
+
                 value->unknown.length = n;
 	        if (n > 0)
 		{
@@@@ -1633,7 +1688,8 @@@@ ippWriteIO(void       *dst,		/* I - Destination */
d22 1
a22 2
+  unsigned char		buffer[IPP_MAX_LENGTH + 2],
+					/* Data buffer + length bytes */
a25 9
@@@@ -1953,7 +2009,7 @@@@ ippWriteIO(void       *dst,		/* I - Destination */
 		 /*
 		  * All simple strings consist of the 2-byte length and
 		  * character data without the trailing nul normally found
-		  * in C strings.  Also, strings cannot be longer than 32767
+		  * in C strings.  Also, strings cannot be longer than IPP_MAX_LENGTH
 		  * bytes since the 2-byte length is a signed (twos-complement)
 		  * value.
 		  *
@


1.2
log
@- add some comments ; no pkg change
@
text
@d1 1
a1 1
$OpenBSD: patch-cups_ipp_c,v 1.1 2009/04/10 15:35:01 ajacoutot Exp $
@


1.1
log
@- lower some buffer size to prevent crash with default limit settings
@
text
@d1 5
a5 1
$OpenBSD$
@

