head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.12
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.10
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.6
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_2:1.1.0.4
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_0:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2014.05.29.13.40.51;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2012.09.30.12.22.05;	author jasper;	state dead;
branches;
next	1.1;

1.1
date	2012.02.23.09.39.00;	author sthen;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2012.02.27.20.16.40;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.3
log
@In libxml, use arc4random instead of rand_r for hash bucket randomization.
Avoids triggering APIWARN for its many dependencies. ok/tweaks ajacoutot@@ (on
earlier version), jca@@
@
text
@$OpenBSD$
--- dict.c.orig	Fri Apr  5 16:58:37 2013
+++ dict.c	Thu May 29 14:18:00 2014
@@@@ -38,7 +38,7 @@@@
  *  list we will use the BigKey algo as soon as the hash size grows
  *  over MIN_DICT_SIZE so this actually works
  */
-#if defined(HAVE_RAND) && defined(HAVE_SRAND) && defined(HAVE_TIME)
+#if (defined(HAVE_RAND) && defined(HAVE_SRAND) && defined(HAVE_TIME)) || defined(HAVE_ARC4RANDOM)
 #define DICT_RANDOMIZATION
 #endif
 
@@@@ -139,7 +139,7 @@@@ static xmlRMutexPtr xmlDictMutex = NULL;
 static int xmlDictInitialized = 0;
 
 #ifdef DICT_RANDOMIZATION
-#ifdef HAVE_RAND_R
+#if defined(HAVE_RAND_R) && !defined(HAVE_ARC4RANDOM)
 /*
  * Internal data for random function, protected by xmlDictMutex
  */
@@@@ -180,7 +180,7 @@@@ int __xmlInitializeDict(void) {
         return(0);
     xmlRMutexLock(xmlDictMutex);
 
-#ifdef DICT_RANDOMIZATION
+#if defined(DICT_RANDOMIZATION) && !defined(HAVE_ARC4RANDOM)
 #ifdef HAVE_RAND_R
     rand_seed = time(NULL);
     rand_r(& rand_seed);
@@@@ -200,13 +200,17 @@@@ int __xmlRandom(void) {
     if (xmlDictInitialized == 0)
         __xmlInitializeDict();
 
+#ifdef HAVE_ARC4RANDOM
+    ret = arc4random();
+#else
     xmlRMutexLock(xmlDictMutex);
-#ifdef HAVE_RAND_R
+#  ifdef HAVE_RAND_R
     ret = rand_r(& rand_seed);
-#else
+#  else
     ret = rand();
-#endif
+#  endif
     xmlRMutexUnlock(xmlDictMutex);
+#endif
     return(ret);
 }
 #endif
@


1.2
log
@- update to libxml-2.8.0

tested on amd64, sparc64, mips64el and powerpc.
ok aja@@
@
text
@d1 11
a11 57
$OpenBSD: patch-dict_c,v 1.1 2012/02/23 09:39:00 sthen Exp $

CVE-2012-0841
http://git.gnome.org/browse/libxml2/commit/?id=8973d58b7498fa5100a876815476b81fd1a2412a

--- dict.c.orig	Tue Oct 12 07:25:31 2010
+++ dict.c	Wed Feb 22 19:02:10 2012
@@@@ -2,7 +2,7 @@@@
  * dict.c: dictionary of reusable strings, just used to avoid allocation
  *         and freeing operations.
  *
- * Copyright (C) 2003 Daniel Veillard.
+ * Copyright (C) 2003-2012 Daniel Veillard.
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@@@ -19,6 +19,28 @@@@
 #define IN_LIBXML
 #include "libxml.h"
 
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_TIME_H
+#include <time.h>
+#endif
+
+/*
+ * Following http://www.ocert.org/advisories/ocert-2011-003.html
+ * it seems that having hash randomization might be a good idea
+ * when using XML with untrusted data
+ * Note1: that it works correctly only if compiled with WITH_BIG_KEY
+ *  which is the default.
+ * Note2: the fast function used for a small dict won't protect very
+ *  well but since the attack is based on growing a very big hash
+ *  list we will use the BigKey algo as soon as the hash size grows
+ *  over MIN_DICT_SIZE so this actually works
+ */
+#if defined(HAVE_RAND) && defined(HAVE_SRAND) && defined(HAVE_TIME)
+#define DICT_RANDOMIZATION
+#endif
+
 #include <string.h>
 #ifdef HAVE_STDINT_H
 #include <stdint.h>
@@@@ -44,23 +66,23 @@@@ typedef unsigned __int32 uint32_t;
 #define WITH_BIG_KEY
 
 #ifdef WITH_BIG_KEY
-#define xmlDictComputeKey(dict, name, len)			\
-    (((dict)->size == MIN_DICT_SIZE) ?				\
-     xmlDictComputeFastKey(name, len) :				\
-     xmlDictComputeBigKey(name, len))
+#define xmlDictComputeKey(dict, name, len)                              \
+    (((dict)->size == MIN_DICT_SIZE) ?                                  \
+     xmlDictComputeFastKey(name, len, (dict)->seed) :                   \
+     xmlDictComputeBigKey(name, len, (dict)->seed))
d13 2
a14 23
-#define xmlDictComputeQKey(dict, prefix, plen, name, len)	\
-    (((prefix) == NULL) ?					\
-      (xmlDictComputeKey(dict, name, len)) :			\
-      (((dict)->size == MIN_DICT_SIZE) ?			\
-       xmlDictComputeFastQKey(prefix, plen, name, len) :	\
-       xmlDictComputeBigQKey(prefix, plen, name, len)))
+#define xmlDictComputeQKey(dict, prefix, plen, name, len)               \
+    (((prefix) == NULL) ?                                               \
+      (xmlDictComputeKey(dict, name, len)) :                             \
+      (((dict)->size == MIN_DICT_SIZE) ?                                \
+       xmlDictComputeFastQKey(prefix, plen, name, len, (dict)->seed) :	\
+       xmlDictComputeBigQKey(prefix, plen, name, len, (dict)->seed)))
 
 #else /* !WITH_BIG_KEY */
-#define xmlDictComputeKey(dict, name, len)			\
-        xmlDictComputeFastKey(name, len)
-#define xmlDictComputeQKey(dict, prefix, plen, name, len)	\
-        xmlDictComputeFastQKey(prefix, plen, name, len)
+#define xmlDictComputeKey(dict, name, len)                              \
+        xmlDictComputeFastKey(name, len, (dict)->seed)
+#define xmlDictComputeQKey(dict, prefix, plen, name, len)               \
+        xmlDictComputeFastQKey(prefix, plen, name, len, (dict)->seed)
 #endif /* WITH_BIG_KEY */
d16 3
d20 3
a22 11
@@@@ -98,6 +120,8 @@@@ struct _xmlDict {
     xmlDictStringsPtr strings;
 
     struct _xmlDict *subdict;
+    /* used for randomization */
+    int seed;
 };
 
 /*
@@@@ -125,6 +149,9 @@@@ static int xmlInitializeDict(void) {
     if ((xmlDictMutex = xmlNewRMutex()) == NULL)
d24 1
d26 8
a33 31
+#ifdef DICT_RANDOMIZATION
+    srand(time(NULL));
+#endif
     xmlDictInitialized = 1;
     return(1);
 }
@@@@ -277,13 +304,13 @@@@ found_pool:
  */
 
 static uint32_t
-xmlDictComputeBigKey(const xmlChar* data, int namelen) {
+xmlDictComputeBigKey(const xmlChar* data, int namelen, int seed) {
     uint32_t hash;
     int i;
 
     if (namelen <= 0 || data == NULL) return(0);
 
-    hash = 0;
+    hash = seed;
 
     for (i = 0;i < namelen; i++) {
         hash += data[i];
@@@@ -310,12 +337,12 @@@@ xmlDictComputeBigKey(const xmlChar* data, int namelen)
  */
 static unsigned long
 xmlDictComputeBigQKey(const xmlChar *prefix, int plen,
-                      const xmlChar *name, int len)
+                      const xmlChar *name, int len, int seed)
 {
     uint32_t hash;
     int i;
d35 2
a36 34
-    hash = 0;
+    hash = seed;
 
     for (i = 0;i < plen; i++) {
         hash += prefix[i];
@@@@ -346,8 +373,8 @@@@ xmlDictComputeBigQKey(const xmlChar *prefix, int plen,
  * for low hash table fill.
  */
 static unsigned long
-xmlDictComputeFastKey(const xmlChar *name, int namelen) {
-    unsigned long value = 0L;
+xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {
+    unsigned long value = seed;
 
     if (name == NULL) return(0);
     value = *name;
@@@@ -381,9 +408,9 @@@@ xmlDictComputeFastKey(const xmlChar *name, int namelen
  */
 static unsigned long
 xmlDictComputeFastQKey(const xmlChar *prefix, int plen,
-                       const xmlChar *name, int len)
+                       const xmlChar *name, int len, int seed)
 {
-    unsigned long value = 0L;
+    unsigned long value = (unsigned long) seed;
 
     if (plen == 0)
 	value += 30 * (unsigned long) ':';
@@@@ -460,6 +487,11 @@@@ xmlDictCreate(void) {
 	dict->subdict = NULL;
         if (dict->dict) {
 	    memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));
+#ifdef DICT_RANDOMIZATION
+            dict->seed = rand();
d38 10
a47 1
+            dict->seed = 0;
d49 2
a50 6
 	    return(dict);
         }
         xmlFree(dict);
@@@@ -486,6 +518,7 @@@@ xmlDictCreateSub(xmlDictPtr sub) {
 #ifdef DICT_DEBUG_PATTERNS
         fprintf(stderr, "R");
a51 4
+        dict->seed = sub->seed;
         dict->subdict = sub;
 	xmlDictReference(dict->subdict);
     }
@


1.1
log
@apply a fix for CVE-2012-0841 to libxml.  ok ajacoutot@@

"certain XML parsers/servers are affected by the same, or similar,
flaw as the hash table collisions CPU usage denial of service.
Sending a specially crafted message to an XML service can result
in longer processing time, which could lead to a denial of service.
It is reported that this attack on XML can be applied on different
XML nodes (such as entities, element attributes, namespaces, various
elements in the XML security, etc.)."
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.2.1
log
@MFC fix for CVE-2012-0841 to libxml.
@
text
@d1 1
a1 1
$OpenBSD: patch-dict_c,v 1.1 2012/02/23 09:39:00 sthen Exp $
@

