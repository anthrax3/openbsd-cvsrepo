head	1.18;
access;
symbols
	OPENBSD_6_1:1.17.0.2
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_5:1.3.0.2
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@# @;


1.18
date	2017.07.14.18.12.05;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	U59WqebkRM8g7Sm1;

1.17
date	2017.06.03.09.40.42;	author pirofti;	state Exp;
branches
	1.17.2.1;
next	1.16;
commitid	A6NZrwGvL1iFi1PY;

1.16
date	2015.11.21.08.46.44;	author ajacoutot;	state dead;
branches;
next	1.15;
commitid	uRMr4NXxd3MUcX9d;

1.15
date	2015.11.05.14.29.33;	author jasper;	state Exp;
branches;
next	1.14;
commitid	wWchJ3HgCREjmC9X;

1.14
date	2015.11.05.14.24.12;	author jasper;	state Exp;
branches;
next	1.13;
commitid	QfliiY5TMLxWtRhH;

1.13
date	2015.10.23.14.21.16;	author jasper;	state Exp;
branches;
next	1.12;
commitid	ksH6C8XHq4R21Fen;

1.12
date	2014.10.18.08.56.21;	author jasper;	state Exp;
branches
	1.12.6.1;
next	1.11;
commitid	bAWyan9oYhqEEgkF;

1.11
date	2014.10.17.13.24.59;	author jasper;	state dead;
branches;
next	1.10;
commitid	g3cHDFWhu6ouXPjZ;

1.10
date	2014.10.16.17.53.25;	author jasper;	state Exp;
branches;
next	1.9;
commitid	jPX2UYqhR5YPFRuC;

1.9
date	2014.05.12.07.48.35;	author jasper;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2013.09.25.12.32.23;	author jasper;	state dead;
branches;
next	1.7;

1.7
date	2013.04.17.13.55.42;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.30.12.22.05;	author jasper;	state dead;
branches;
next	1.5;

1.5
date	2012.01.23.10.17.49;	author ajacoutot;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2009.10.11.10.39.42;	author steven;	state dead;
branches
	1.4.2.1;
next	1.3;

1.3
date	2009.08.13.09.29.47;	author sthen;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.06.13.21.51.09;	author marcm;	state dead;
branches;
next	1.1;

1.1
date	2002.12.02.12.23.47;	author espie;	state Exp;
branches;
next	;

1.3.2.1
date	2009.09.26.23.46.01;	author william;	state Exp;
branches;
next	;

1.4.2.1
date	2009.10.26.03.53.53;	author william;	state Exp;
branches;
next	;

1.5.2.1
date	2012.01.23.10.19.14;	author ajacoutot;	state Exp;
branches;
next	;

1.9.2.1
date	2014.05.12.07.48.43;	author jasper;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2014.10.16.17.53.56;	author jasper;	state Exp;
branches;
next	;
commitid	wxk3t7cRL2VcfO9d;

1.9.4.1
date	2014.10.16.17.53.42;	author jasper;	state Exp;
branches;
next	;
commitid	GAekzIywPviDbYhS;

1.12.6.1
date	2015.10.23.14.22.13;	author jasper;	state Exp;
branches;
next	1.12.6.2;
commitid	KfZP4sdWyzDucNOQ;

1.12.6.2
date	2015.11.05.14.34.55;	author jasper;	state Exp;
branches;
next	1.12.6.3;
commitid	qWgtWFEgDZy7ZZu3;

1.12.6.3
date	2015.11.21.08.30.39;	author ajacoutot;	state dead;
branches;
next	;
commitid	qHr57rpbtMfO1xw3;

1.17.2.1
date	2017.06.03.10.49.07;	author pirofti;	state Exp;
branches;
next	;
commitid	afoZeycaVM1iq8sU;


desc
@@


1.18
log
@Fix libxml2 CVE-2017-7375, CVE-2017-7376, CVE-2017-9663.
From Matthias Pitzl; OK danj@@
@
text
@$OpenBSD: patch-parser_c,v 1.17 2017/06/03 09:40:42 pirofti Exp $

Fix CVE-2017-9049 and CVE-2017-9050.

CVE-2017-7375
https://github.com/GNOME/libxml2/commit/90ccb58242866b0ba3edbef8fe44214a101c2b3e

Index: parser.c
--- parser.c.orig
+++ parser.c
@@@@ -3312,6 +3312,7 @@@@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
     int len = 0, l;
     int c;
     int count = 0;
+    size_t startPosition = 0;
 
 #ifdef DEBUG
     nbParseNameComplex++;
@@@@ -3323,6 +3324,7 @@@@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
     GROW;
     if (ctxt->instate == XML_PARSER_EOF)
         return(NULL);
+    startPosition = CUR_PTR - BASE_PTR;
     c = CUR_CHAR(l);
     if ((ctxt->options & XML_PARSE_OLD10) == 0) {
         /*
@@@@ -3420,9 +3422,11 @@@@ xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
         return(NULL);
     }
-    if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
-        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
-    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
+
+    if (BASE_PTR + startPosition + len > ctxt->input->end)
+	return(NULL);
+
+    return(xmlDictLookup(ctxt->dict, BASE_PTR + startPosition, len));
 }
 
 /**
@@@@ -8123,6 +8127,15 @@@@ xmlParsePEReference(xmlParserCtxtPtr ctxt)
 	    if (xmlPushInput(ctxt, input) < 0)
 		return;
 	} else {
+	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+		(ctxt->replaceEntities == 0) &&
+		(ctxt->validate == 0))
+		return;
+
 	    /*
 	     * TODO !!!
 	     * handle the extra spaces added before and after
@


1.17
log
@Security update for textproc/libxml

Patches for CVE-2017-9047, CVE-2017-9048, CVE-2017-9049, CVE-2017-9050.
From Matthias Pitzl, thanks!

OK ajacoutot
@
text
@d1 1
a1 1
$OpenBSD$
d5 3
d42 16
@


1.17.2.1
log
@Backport recent textproc/libxml security fixes.

Patches CVE-2017-9047, CVE-2017-9048, CVE-2017-9049 and CVE-2017-9050.
From Matthias Pitzl, thanks!

OK ajacoutot@@
@
text
@@


1.16
log
@SECURITY: merge all recent CVEs from upstream
CVE-2015-8242 Buffer overead with HTML parser in push mode
CVE-2015-7500 Fix memory access error due to incorrect entities boundaries
CVE-2015-7499-2 Detect incoherency on GROW
CVE-2015-7499-1 Add xmlHaltParser() to stop the parser
CVE-2015-5312 Another entity expansion issue
CVE-2015-7497 Avoid an heap buffer overflow in xmlDictComputeFastQKey
CVE-2015-7498 Avoid processing entities after encoding conversion failures
CVE-2015-8035 Fix XZ compression support loop
CVE-2015-7942-2 Fix an error in previous Conditional section patch
CVE-2015-7942 Another variation of overflow in Conditional sections
CVE-2015-1819 Enforce the reader to run in constant memory
CVE-2015-7941_2 Cleanup conditional section error handling
CVE-2015-7941_1 Stop parsing on entities boundaries errors

Note that there's a new libxml release out, but it's in a bulk currently...
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.15 2015/11/05 14:29:33 jasper Exp $
d3 1
a3 4
Security fix for CVE-2015-7941, upstream git:
a7dfab7411cbf545f359dd3157e5df1eb0e7ce31
9b8512337d14c8ddf662fcb98b0135f225a1c489
41ac9049a27f52e7a1f3b341f8714149fc88d450
d5 8
a12 43
Security fix for CVE-2015-7942, upstream git:
bd0526e66a56e75a18da8c15c4750db8f801c52d

From f65128f38289d77ff322d63aef2858cc0a819c34 Mon Sep 17 00:00:00 2001
From: Daniel Veillard <veillard@@redhat.com>
Date: Fri, 17 Oct 2014 17:13:41 +0800
Subject: Revert "Missing initialization for the catalog module"

--- parser.c.orig	Thu Oct 16 07:57:40 2014
+++ parser.c	Thu Nov  5 15:28:59 2015
@@@@ -5658,6 +5658,7 @@@@ xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {
 	if (RAW != '>') {
 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            "xmlParseEntityDecl: entity %s not terminated\n", name);
+		xmlStopParser(ctxt);
 	} else {
 	    if (input != ctxt->input) {
 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6769,6 +6770,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	SKIP_BLANKS;
 	if (RAW != '[') {
 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
+	    xmlStopParser(ctxt);
+	    return;
 	} else {
 	    if (ctxt->input->id != id) {
 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6829,6 +6832,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	SKIP_BLANKS;
 	if (RAW != '[') {
 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
+	    xmlStopParser(ctxt);
+	    return;
 	} else {
 	    if (ctxt->input->id != id) {
 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6884,6 +6889,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 
     } else {
 	xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
+	xmlStopParser(ctxt);
+	return;
     }
d14 13
a26 9
     if (RAW == 0)
@@@@ -6897,7 +6904,9 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	"All markup of the conditional section is not in the same entity\n",
 				 NULL, NULL);
 	}
-        SKIP(3);
+	if ((ctxt-> instate != XML_PARSER_EOF) &&
+	    ((ctxt->input->cur + 3) <= ctxt->input->end))
+	SKIP(3);
d28 8
d38 1
a38 10
@@@@ -14829,9 +14838,6 @@@@ xmlInitParser(void) {
 #endif
 #ifdef LIBXML_XPATH_ENABLED
 	xmlXPathInit();
-#endif
-#ifdef LIBXML_CATALOG_ENABLED
-        xmlInitializeCatalog();
 #endif
 	xmlParserInitialized = 1;
 #ifdef LIBXML_THREAD_ENABLED
@


1.15
log
@fix patch
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.13 2015/10/23 14:21:16 jasper Exp $
@


1.14
log
@Security fix for CVE-2015-8035 and improve the fix for CVE-2015-7941 (from upstream)
@
text
@d16 39
a54 3
--- parser.c.orig	Thu Nov  5 15:14:01 2015
+++ parser.c	Thu Nov  5 15:15:22 2015
@@@@ -6905,7 +6905,7 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
d57 2
a58 2
 	if ((ctxt-> instate != XML_PARSER_EOF) &&
-	    ((ctxt->input->cur + 3) < ctxt->input->end))
d60 1
a60 1
 	SKIP(3);
d63 11
@


1.13
log
@Security fixes for CVE-2015-7941 and CVE-2015-7942
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.12 2014/10/18 08:56:21 jasper Exp $
d6 1
d16 3
a18 39
--- parser.c.orig	Thu Oct 16 07:57:40 2014
+++ parser.c	Fri Oct 23 16:13:17 2015
@@@@ -5658,6 +5658,7 @@@@ xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {
 	if (RAW != '>') {
 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            "xmlParseEntityDecl: entity %s not terminated\n", name);
+		xmlStopParser(ctxt);
 	} else {
 	    if (input != ctxt->input) {
 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6769,6 +6770,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	SKIP_BLANKS;
 	if (RAW != '[') {
 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
+	    xmlStopParser(ctxt);
+	    return;
 	} else {
 	    if (ctxt->input->id != id) {
 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6829,6 +6832,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	SKIP_BLANKS;
 	if (RAW != '[') {
 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
+	    xmlStopParser(ctxt);
+	    return;
 	} else {
 	    if (ctxt->input->id != id) {
 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6884,6 +6889,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 
     } else {
 	xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
+	xmlStopParser(ctxt);
+	return;
     }
 
     if (RAW == 0)
@@@@ -6897,7 +6904,9 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	"All markup of the conditional section is not in the same entity\n",
d21 4
a24 4
-        SKIP(3);
+	if ((ctxt-> instate != XML_PARSER_EOF) &&
+	    ((ctxt->input->cur + 3) < ctxt->input->end))
+	SKIP(3);
a26 11
 
@@@@ -14829,9 +14838,6 @@@@ xmlInitParser(void) {
 #endif
 #ifdef LIBXML_XPATH_ENABLED
 	xmlXPathInit();
-#endif
-#ifdef LIBXML_CATALOG_ENABLED
-        xmlInitializeCatalog();
 #endif
 	xmlParserInitialized = 1;
 #ifdef LIBXML_THREAD_ENABLED
@


1.12
log
@backport fix from upstream to unbreak the xmlcatalog command

ptd out by aja@@
@
text
@d1 8
a8 1
$OpenBSD$
d15 50
a64 3
--- parser.c.orig	Sat Oct 18 10:33:23 2014
+++ parser.c	Sat Oct 18 10:33:44 2014
@@@@ -14830,9 +14830,6 @@@@ xmlInitParser(void) {
d67 1
a67 1
 #endif
d70 1
a70 1
-#endif
a72 1
     }
@


1.12.6.1
log
@Security fixes for CVE-2015-7941 and CVE-2015-7942
@
text
@d1 1
a1 8
$OpenBSD: patch-parser_c,v 1.13 2015/10/23 14:21:16 jasper Exp $

Security fix for CVE-2015-7941, upstream git:
a7dfab7411cbf545f359dd3157e5df1eb0e7ce31
9b8512337d14c8ddf662fcb98b0135f225a1c489

Security fix for CVE-2015-7942, upstream git:
bd0526e66a56e75a18da8c15c4750db8f801c52d
d8 3
a10 50
--- parser.c.orig	Thu Oct 16 07:57:40 2014
+++ parser.c	Fri Oct 23 16:13:17 2015
@@@@ -5658,6 +5658,7 @@@@ xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {
 	if (RAW != '>') {
 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            "xmlParseEntityDecl: entity %s not terminated\n", name);
+		xmlStopParser(ctxt);
 	} else {
 	    if (input != ctxt->input) {
 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6769,6 +6770,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	SKIP_BLANKS;
 	if (RAW != '[') {
 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
+	    xmlStopParser(ctxt);
+	    return;
 	} else {
 	    if (ctxt->input->id != id) {
 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6829,6 +6832,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	SKIP_BLANKS;
 	if (RAW != '[') {
 	    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
+	    xmlStopParser(ctxt);
+	    return;
 	} else {
 	    if (ctxt->input->id != id) {
 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
@@@@ -6884,6 +6889,8 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 
     } else {
 	xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
+	xmlStopParser(ctxt);
+	return;
     }
 
     if (RAW == 0)
@@@@ -6897,7 +6904,9 @@@@ xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 	"All markup of the conditional section is not in the same entity\n",
 				 NULL, NULL);
 	}
-        SKIP(3);
+	if ((ctxt-> instate != XML_PARSER_EOF) &&
+	    ((ctxt->input->cur + 3) < ctxt->input->end))
+	SKIP(3);
     }
 }
 
@@@@ -14829,9 +14838,6 @@@@ xmlInitParser(void) {
 #endif
d13 1
a13 1
-#endif
d16 1
a16 1
 #endif
d19 1
@


1.12.6.2
log
@Security fix for CVE-2015-8035 and improve the fix for CVE-2015-7941 (from upstream)
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.15 2015/11/05 14:29:33 jasper Exp $
a5 1
41ac9049a27f52e7a1f3b341f8714149fc88d450
d16 1
a16 1
+++ parser.c	Thu Nov  5 15:28:59 2015
d58 1
a58 1
+	    ((ctxt->input->cur + 3) <= ctxt->input->end))
@


1.12.6.3
log
@Merge all recent CVEs from upstream:
CVE-2015-8242 Buffer overead with HTML parser in push mode
CVE-2015-7500 Fix memory access error due to incorrect entities boundaries
CVE-2015-7499-2 Detect incoherency on GROW
CVE-2015-7499-1 Add xmlHaltParser() to stop the parser
CVE-2015-5312 Another entity expansion issue
CVE-2015-7497 Avoid an heap buffer overflow in xmlDictComputeFastQKey
CVE-2015-7498 Avoid processing entities after encoding conversion failures
CVE-2015-8035 Fix XZ compression support loop
CVE-2015-7942-2 Fix an error in previous Conditional section patch
CVE-2015-7942 Another variation of overflow in Conditional sections
CVE-2015-1819 Enforce the reader to run in constant memory
CVE-2015-7941_2 Cleanup conditional section error handling
CVE-2015-7941_1 Stop parsing on entities boundaries errors
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.12.6.2 2015/11/05 14:34:55 jasper Exp $
@


1.11
log
@- update to libxml 2.9.2
* mostly bugfixes and two security fixes (booth were applied already)

ok aja@@
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.10 2014/10/16 17:53:25 jasper Exp $
d3 4
a6 2
Security fix for CVE-2014-0191
external parameter entity loaded when entity substitution is disabled
d8 11
a18 137
https://git.gnome.org/browse/libxml2/commit/?id=9cd1c3cfbd32655d60572c0a413e017260c854df

Security fix for CVE-2014-3660
https://git.gnome.org/browse/libxml2/commit/?id=be2a7edaf289c5da74a4f9ed3a0b6c733e775230

--- parser.c.orig	Thu Oct 16 19:35:41 2014
+++ parser.c	Thu Oct 16 19:35:34 2014
@@@@ -130,6 +130,29 @@@@ xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t siz
         return (0);
     if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
         return (1);
+
+    /*
+     * This may look absurd but is needed to detect
+     * entities problems
+     */
+    if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
+	(ent->content != NULL) && (ent->checked == 0)) {
+	unsigned long oldnbent = ctxt->nbentities;
+	xmlChar *rep;
+
+	ent->checked = 1;
+
+	rep = xmlStringDecodeEntities(ctxt, ent->content,
+				  XML_SUBSTITUTE_REF, 0, 0, 0);
+
+	ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;
+	if (rep != NULL) {
+	    if (xmlStrchr(rep, '<'))
+		ent->checked |= 1;
+	    xmlFree(rep);
+	    rep = NULL;
+	}
+    }
     if (replacement != 0) {
 	if (replacement < XML_MAX_TEXT_LENGTH)
 	    return(0);
@@@@ -189,9 +212,12 @@@@ xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t siz
             return (0);
     } else {
         /*
-         * strange we got no data for checking just return
+         * strange we got no data for checking
          */
-        return (0);
+	if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&
+	     (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||
+	    (ctxt->nbentities <= 10000))
+	    return (0);
     }
     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
     return (1);
@@@@ -2584,6 +2610,7 @@@@ xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
 				      name, NULL);
 		    ctxt->valid = 0;
 		}
+		xmlParserEntityCheck(ctxt, 0, NULL, 0);
 	    } else if (ctxt->input->free != deallocblankswrapper) {
 		    input = xmlNewBlanksWrapperInputStream(ctxt, entity);
 		    if (xmlPushInput(ctxt, input) < 0)
@@@@ -2595,6 +2622,20 @@@@ xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
 		    xmlCharEncoding enc;
 
 		    /*
+		     * Note: external parsed entities will not be loaded, it is
+		     * not required for a non-validating parser, unless the
+		     * option of validating, or substituting entities were
+		     * given. Doing so is far more secure as the parser will
+		     * only process data coming from the document entity by
+		     * default.
+		     */
+                    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+		        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+			((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+			(ctxt->validate == 0))
+			return;
+
+		    /*
 		     * handle the extra spaces added before and after
 		     * c.f. http://www.w3.org/TR/REC-xml#as-PE
 		     * this is done independently.
@@@@ -2737,6 +2778,7 @@@@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, cons
 	    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
 	        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
 	        goto int_error;
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	    if (ent != NULL)
 	        ctxt->nbentities += ent->checked / 2;
 	    if ((ent != NULL) &&
@@@@ -2788,6 +2830,7 @@@@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, cons
 	    ent = xmlParseStringPEReference(ctxt, &str);
 	    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
 	        goto int_error;
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	    if (ent != NULL)
 	        ctxt->nbentities += ent->checked / 2;
 	    if (ent != NULL) {
@@@@ -7286,6 +7329,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 		     "Entity '%s' failed to parse\n", ent->name);
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	} else if (list != NULL) {
 	    xmlFreeNodeList(list);
 	    list = NULL;
@@@@ -7392,7 +7436,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		/*
 		 * We are copying here, make sure there is no abuse
 		 */
-		ctxt->sizeentcopy += ent->length;
+		ctxt->sizeentcopy += ent->length + 5;
 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))
 		    return;
 
@@@@ -7440,7 +7484,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		/*
 		 * We are copying here, make sure there is no abuse
 		 */
-		ctxt->sizeentcopy += ent->length;
+		ctxt->sizeentcopy += ent->length + 5;
 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))
 		    return;
 
@@@@ -7626,6 +7670,7 @@@@ xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 		ctxt->sax->reference(ctxt->userData, name);
 	    }
 	}
+	xmlParserEntityCheck(ctxt, 0, ent, 0);
 	ctxt->valid = 0;
     }
 
@@@@ -7819,6 +7864,7 @@@@ xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const x
 			  "Entity '%s' not defined\n",
 			  name);
 	}
+	xmlParserEntityCheck(ctxt, 0, ent, 0);
 	/* TODO ? check regressions ctxt->valid = 0; */
a19 17
 
@@@@ -7978,6 +8024,7 @@@@ xmlParsePEReference(xmlParserCtxtPtr ctxt)
 			  name, NULL);
 	    ctxt->valid = 0;
 	}
+	xmlParserEntityCheck(ctxt, 0, NULL, 0);
     } else {
 	/*
 	 * Internal checking in case the entity quest barfed
@@@@ -8217,6 +8264,7 @@@@ xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const
 			  name, NULL);
 	    ctxt->valid = 0;
 	}
+	xmlParserEntityCheck(ctxt, 0, NULL, 0);
     } else {
 	/*
 	 * Internal checking in case the entity quest barfed
@


1.10
log
@security fix for CVE-2014-3660, more billion laugh entity expansion fixes
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.9 2014/05/12 07:48:35 jasper Exp $
@


1.9
log
@Security fix for CVE-2014-0191
external parameter entity loaded when entity substitution is disabled

pointed out by aja@@
@
text
@d1 1
a1 1
$OpenBSD$
d8 59
a66 3
--- parser.c.orig	Tue Apr 16 15:39:18 2013
+++ parser.c	Mon May 12 09:42:56 2014
@@@@ -2595,6 +2595,20 @@@@ xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
d87 74
@


1.9.4.1
log
@security fix for CVE-2014-3660, more billion laugh entity expansion fixes
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.9 2014/05/12 07:48:35 jasper Exp $
d8 3
a10 59
Security fix for CVE-2014-3660
https://git.gnome.org/browse/libxml2/commit/?id=be2a7edaf289c5da74a4f9ed3a0b6c733e775230

--- parser.c.orig	Thu Oct 16 19:35:41 2014
+++ parser.c	Thu Oct 16 19:35:34 2014
@@@@ -130,6 +130,29 @@@@ xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t siz
         return (0);
     if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
         return (1);
+
+    /*
+     * This may look absurd but is needed to detect
+     * entities problems
+     */
+    if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
+	(ent->content != NULL) && (ent->checked == 0)) {
+	unsigned long oldnbent = ctxt->nbentities;
+	xmlChar *rep;
+
+	ent->checked = 1;
+
+	rep = xmlStringDecodeEntities(ctxt, ent->content,
+				  XML_SUBSTITUTE_REF, 0, 0, 0);
+
+	ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;
+	if (rep != NULL) {
+	    if (xmlStrchr(rep, '<'))
+		ent->checked |= 1;
+	    xmlFree(rep);
+	    rep = NULL;
+	}
+    }
     if (replacement != 0) {
 	if (replacement < XML_MAX_TEXT_LENGTH)
 	    return(0);
@@@@ -189,9 +212,12 @@@@ xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t siz
             return (0);
     } else {
         /*
-         * strange we got no data for checking just return
+         * strange we got no data for checking
          */
-        return (0);
+	if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&
+	     (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||
+	    (ctxt->nbentities <= 10000))
+	    return (0);
     }
     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
     return (1);
@@@@ -2584,6 +2610,7 @@@@ xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
 				      name, NULL);
 		    ctxt->valid = 0;
 		}
+		xmlParserEntityCheck(ctxt, 0, NULL, 0);
 	    } else if (ctxt->input->free != deallocblankswrapper) {
 		    input = xmlNewBlanksWrapperInputStream(ctxt, entity);
 		    if (xmlPushInput(ctxt, input) < 0)
@@@@ -2595,6 +2622,20 @@@@ xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
a30 74
@@@@ -2737,6 +2778,7 @@@@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, cons
 	    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
 	        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
 	        goto int_error;
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	    if (ent != NULL)
 	        ctxt->nbentities += ent->checked / 2;
 	    if ((ent != NULL) &&
@@@@ -2788,6 +2830,7 @@@@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, cons
 	    ent = xmlParseStringPEReference(ctxt, &str);
 	    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
 	        goto int_error;
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	    if (ent != NULL)
 	        ctxt->nbentities += ent->checked / 2;
 	    if (ent != NULL) {
@@@@ -7286,6 +7329,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 		     "Entity '%s' failed to parse\n", ent->name);
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	} else if (list != NULL) {
 	    xmlFreeNodeList(list);
 	    list = NULL;
@@@@ -7392,7 +7436,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		/*
 		 * We are copying here, make sure there is no abuse
 		 */
-		ctxt->sizeentcopy += ent->length;
+		ctxt->sizeentcopy += ent->length + 5;
 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))
 		    return;
 
@@@@ -7440,7 +7484,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		/*
 		 * We are copying here, make sure there is no abuse
 		 */
-		ctxt->sizeentcopy += ent->length;
+		ctxt->sizeentcopy += ent->length + 5;
 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))
 		    return;
 
@@@@ -7626,6 +7670,7 @@@@ xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 		ctxt->sax->reference(ctxt->userData, name);
 	    }
 	}
+	xmlParserEntityCheck(ctxt, 0, ent, 0);
 	ctxt->valid = 0;
     }
 
@@@@ -7819,6 +7864,7 @@@@ xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const x
 			  "Entity '%s' not defined\n",
 			  name);
 	}
+	xmlParserEntityCheck(ctxt, 0, ent, 0);
 	/* TODO ? check regressions ctxt->valid = 0; */
     }
 
@@@@ -7978,6 +8024,7 @@@@ xmlParsePEReference(xmlParserCtxtPtr ctxt)
 			  name, NULL);
 	    ctxt->valid = 0;
 	}
+	xmlParserEntityCheck(ctxt, 0, NULL, 0);
     } else {
 	/*
 	 * Internal checking in case the entity quest barfed
@@@@ -8217,6 +8264,7 @@@@ xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const
 			  name, NULL);
 	    ctxt->valid = 0;
 	}
+	xmlParserEntityCheck(ctxt, 0, NULL, 0);
     } else {
 	/*
 	 * Internal checking in case the entity quest barfed
@


1.9.2.1
log
@Security fix for CVE-2014-0191
external parameter entity loaded when entity substitution is disabled
@
text
@@


1.9.2.2
log
@security fix for CVE-2014-3660, more billion laugh entity expansion fixes
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.9 2014/05/12 07:48:35 jasper Exp $
d8 3
a10 59
Security fix for CVE-2014-3660
https://git.gnome.org/browse/libxml2/commit/?id=be2a7edaf289c5da74a4f9ed3a0b6c733e775230

--- parser.c.orig	Thu Oct 16 19:35:41 2014
+++ parser.c	Thu Oct 16 19:35:34 2014
@@@@ -130,6 +130,29 @@@@ xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t siz
         return (0);
     if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
         return (1);
+
+    /*
+     * This may look absurd but is needed to detect
+     * entities problems
+     */
+    if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
+	(ent->content != NULL) && (ent->checked == 0)) {
+	unsigned long oldnbent = ctxt->nbentities;
+	xmlChar *rep;
+
+	ent->checked = 1;
+
+	rep = xmlStringDecodeEntities(ctxt, ent->content,
+				  XML_SUBSTITUTE_REF, 0, 0, 0);
+
+	ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;
+	if (rep != NULL) {
+	    if (xmlStrchr(rep, '<'))
+		ent->checked |= 1;
+	    xmlFree(rep);
+	    rep = NULL;
+	}
+    }
     if (replacement != 0) {
 	if (replacement < XML_MAX_TEXT_LENGTH)
 	    return(0);
@@@@ -189,9 +212,12 @@@@ xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t siz
             return (0);
     } else {
         /*
-         * strange we got no data for checking just return
+         * strange we got no data for checking
          */
-        return (0);
+	if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&
+	     (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||
+	    (ctxt->nbentities <= 10000))
+	    return (0);
     }
     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
     return (1);
@@@@ -2584,6 +2610,7 @@@@ xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
 				      name, NULL);
 		    ctxt->valid = 0;
 		}
+		xmlParserEntityCheck(ctxt, 0, NULL, 0);
 	    } else if (ctxt->input->free != deallocblankswrapper) {
 		    input = xmlNewBlanksWrapperInputStream(ctxt, entity);
 		    if (xmlPushInput(ctxt, input) < 0)
@@@@ -2595,6 +2622,20 @@@@ xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
a30 74
@@@@ -2737,6 +2778,7 @@@@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, cons
 	    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
 	        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
 	        goto int_error;
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	    if (ent != NULL)
 	        ctxt->nbentities += ent->checked / 2;
 	    if ((ent != NULL) &&
@@@@ -2788,6 +2830,7 @@@@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, cons
 	    ent = xmlParseStringPEReference(ctxt, &str);
 	    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
 	        goto int_error;
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	    if (ent != NULL)
 	        ctxt->nbentities += ent->checked / 2;
 	    if (ent != NULL) {
@@@@ -7286,6 +7329,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
 	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 		     "Entity '%s' failed to parse\n", ent->name);
+	    xmlParserEntityCheck(ctxt, 0, ent, 0);
 	} else if (list != NULL) {
 	    xmlFreeNodeList(list);
 	    list = NULL;
@@@@ -7392,7 +7436,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		/*
 		 * We are copying here, make sure there is no abuse
 		 */
-		ctxt->sizeentcopy += ent->length;
+		ctxt->sizeentcopy += ent->length + 5;
 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))
 		    return;
 
@@@@ -7440,7 +7484,7 @@@@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 		/*
 		 * We are copying here, make sure there is no abuse
 		 */
-		ctxt->sizeentcopy += ent->length;
+		ctxt->sizeentcopy += ent->length + 5;
 		if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))
 		    return;
 
@@@@ -7626,6 +7670,7 @@@@ xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 		ctxt->sax->reference(ctxt->userData, name);
 	    }
 	}
+	xmlParserEntityCheck(ctxt, 0, ent, 0);
 	ctxt->valid = 0;
     }
 
@@@@ -7819,6 +7864,7 @@@@ xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const x
 			  "Entity '%s' not defined\n",
 			  name);
 	}
+	xmlParserEntityCheck(ctxt, 0, ent, 0);
 	/* TODO ? check regressions ctxt->valid = 0; */
     }
 
@@@@ -7978,6 +8024,7 @@@@ xmlParsePEReference(xmlParserCtxtPtr ctxt)
 			  name, NULL);
 	    ctxt->valid = 0;
 	}
+	xmlParserEntityCheck(ctxt, 0, NULL, 0);
     } else {
 	/*
 	 * Internal checking in case the entity quest barfed
@@@@ -8217,6 +8264,7 @@@@ xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const
 			  name, NULL);
 	    ctxt->valid = 0;
 	}
+	xmlParserEntityCheck(ctxt, 0, NULL, 0);
     } else {
 	/*
 	 * Internal checking in case the entity quest barfed
@


1.8
log
@- update libxml to 2.9.1

tested in a bulk by landry@@, thanks!
ok aja@@
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.7 2013/04/17 13:55:42 sthen Exp $
d3 2
a4 4
From de0cc20c29cb3f056062925395e0f68d2250a46f Mon Sep 17 00:00:00 2001
From: Daniel Veillard <veillard@@redhat.com>
Date: Tue, 12 Feb 2013 08:55:34 +0000
Subject: Fix some buffer conversion issues
d6 1
a6 1
https://bugzilla.gnome.org/show_bug.cgi?id=690202
d8 4
a11 21
Buffer overflow errors originating from xmlBufGetInputBase in 2.9.0
The pointers from the context input were not properly reset after
that call which can do reallocations.

--- parser.c.orig	Tue Sep 11 05:24:08 2012
+++ parser.c	Wed Apr 17 14:33:44 2013
@@@@ -12125,7 +12125,7 @@@@ xmldecl_done:
                 remain = 0;
             }
         }
-	res =xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
+	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
 	if (res < 0) {
 	    ctxt->errNo = XML_PARSER_EOF;
 	    ctxt->disableSAX = 1;
@@@@ -12142,6 +12142,8 @@@@ xmldecl_done:
 	    if ((in->encoder != NULL) && (in->buffer != NULL) &&
 		    (in->raw != NULL)) {
 		int nbchars;
+		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);
+		size_t current = ctxt->input->cur - ctxt->input->base;
d13 13
a25 19
 		nbchars = xmlCharEncInput(in);
 		if (nbchars < 0) {
@@@@ -12150,6 +12152,7 @@@@ xmldecl_done:
 				    "xmlParseChunk: encoder error\n");
 		    return(XML_ERR_INVALID_ENCODING);
 		}
+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);
 	    }
 	}
     }
@@@@ -12189,7 +12192,14 @@@@ xmldecl_done:
     }
     if ((end_in_lf == 1) && (ctxt->input != NULL) &&
         (ctxt->input->buf != NULL)) {
+	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,
+					 ctxt->input);
+	size_t current = ctxt->input->cur - ctxt->input->base;
+
 	xmlParserInputBufferPush(ctxt->input->buf, 1, "\r");
d27 4
a30 5
+	xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,
+			      base, current);
     }
     if (terminate) {
 	/*
@


1.7
log
@Backport security fixes from libxml upstream:

https://secunia.com/advisories/53061/
https://bugzilla.gnome.org/show_bug.cgi?id=690202

ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.6
log
@- update to libxml-2.8.0

tested on amd64, sparc64, mips64el and powerpc.
ok aja@@
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.5 2012/01/23 10:17:49 ajacoutot Exp $
d3 1
a3 1
From 5bd3c061823a8499b27422aee04ea20aae24f03e Mon Sep 17 00:00:00 2001
d5 2
a6 2
Date: Fri, 16 Dec 2011 10:53:35 +0000
Subject: Fix an allocation error when copying entities
d8 1
a8 4
From 77404b8b69bc122d12231807abf1a837d121b551 Mon Sep 17 00:00:00 2001
From: Chris Evans <scarybeasts@@gmail.com>
Date: Wed, 14 Dec 2011 08:18:25 +0000
Subject: Make sure the parser returns when getting a Stop order
d10 29
a38 10
--- parser.c.orig	Mon Jan 23 08:11:49 2012
+++ parser.c	Mon Jan 23 08:11:54 2012
@@@@ -4949,7 +4949,8 @@@@ xmlParsePI(xmlParserCtxtPtr ctxt) {
 		    (ctxt->sax->processingInstruction != NULL))
 		    ctxt->sax->processingInstruction(ctxt->userData,
 		                                     target, NULL);
-		ctxt->instate = state;
+		if (ctxt->instate != XML_PARSER_EOF)
+		    ctxt->instate = state;
 		return;
a39 4
 	    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
@@@@ -5029,7 +5030,8 @@@@ xmlParsePI(xmlParserCtxtPtr ctxt) {
 	} else {
 	    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
a40 3
-	ctxt->instate = state;
+	if (ctxt->instate != XML_PARSER_EOF)
+	    ctxt->instate = state;
d42 15
a56 31
 }
 
@@@@ -9588,6 +9590,8 @@@@ xmlParseElement(xmlParserCtxtPtr ctxt) {
     else
 	name = xmlParseStartTag(ctxt);
 #endif /* LIBXML_SAX1_ENABLED */
+    if (ctxt->instate == XML_PARSER_EOF)
+	return;
     if (name == NULL) {
 	spacePop(ctxt);
         return;
@@@@ -10967,6 +10971,8 @@@@ xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int termina
 		else
 		    name = xmlParseStartTag(ctxt);
 #endif /* LIBXML_SAX1_ENABLED */
+		if (ctxt->instate == XML_PARSER_EOF)
+		    goto done;
 		if (name == NULL) {
 		    spacePop(ctxt);
 		    ctxt->instate = XML_PARSER_EOF;
@@@@ -11153,7 +11159,9 @@@@ xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int termina
 		  else
 		    xmlParseEndTag1(ctxt, 0);
 #endif /* LIBXML_SAX1_ENABLED */
-		if (ctxt->nameNr == 0) {
+		if (ctxt->instate == XML_PARSER_EOF) {
+		    /* Nothing */
+		} else if (ctxt->nameNr == 0) {
 		    ctxt->instate = XML_PARSER_EPILOG;
 		} else {
 		    ctxt->instate = XML_PARSER_CONTENT;
@


1.5
log
@Bring some patches from upstream repo to fix the following CVE:
CVE-2011-0216 - Off-by-one error
CVE-2011-2821 - Double free vulnerability
CVE-2011-2834 - Double free vulnerability
CVE-2011-3905 - DOS (out-of-bounds read) via unspecified vectors
CVE-2011-3919 - Heap-based buffer overflow

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.5.2.1
log
@Bring some patches from upstream repo to fix the following CVE:
CVE-2011-0216 - Off-by-one error
CVE-2011-2821 - Double free vulnerability
CVE-2011-2834 - Double free vulnerability
CVE-2011-3905 - DOS (out-of-bounds read) via unspecified vectors
CVE-2011-3919 - Heap-based buffer overflow

ok sthen@@
@
text
@@


1.4
log
@update to 2.7.6
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.3 2009/08/13 09:29:47 sthen Exp $
d3 4
a6 2
fix CVE-2009-2414, CVE-2009-2416, from Daniel Veillard via
redhat bug 515195
d8 20
a27 9
--- parser.c.orig	Tue Apr  8 15:47:58 2008
+++ parser.c	Thu Aug 13 10:04:54 2009
@@@@ -4893,10 +4893,14 @@@@ xmlParseNotationType(xmlParserCtxtPtr ctxt) {
 	if (name == NULL) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 			   "Name expected in NOTATION declaration\n");
-	    return(ret);
+            xmlFreeEnumeration(ret);
+	    return(NULL);
d29 3
a31 18
 	cur = xmlCreateEnumeration(name);
-	if (cur == NULL) return(ret);
+	if (cur == NULL) {
+            xmlFreeEnumeration(ret);
+            return(NULL);
+        }
 	if (last == NULL) ret = last = cur;
 	else {
 	    last->next = cur;
@@@@ -4906,9 +4910,8 @@@@ xmlParseNotationType(xmlParserCtxtPtr ctxt) {
     } while (RAW == '|');
     if (RAW != ')') {
 	xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
-	if ((last != NULL) && (last != ret))
-	    xmlFreeEnumeration(last);
-	return(ret);
+        xmlFreeEnumeration(ret);
+	return(NULL);
d33 1
a33 17
     NEXT;
     return(ret);
@@@@ -4949,7 +4952,10 @@@@ xmlParseEnumerationType(xmlParserCtxtPtr ctxt) {
 	}
 	cur = xmlCreateEnumeration(name);
 	xmlFree(name);
-	if (cur == NULL) return(ret);
+	if (cur == NULL) {
+            xmlFreeEnumeration(ret);
+            return(NULL);
+        }
 	if (last == NULL) ret = last = cur;
 	else {
 	    last->next = cur;
@@@@ -5351,6 +5357,12 @@@@ xmlParseElementChildrenContentDecl (xmlParserCtxtPtr c
     const xmlChar *elem;
     xmlChar type = 0;
d35 29
a63 29
+    if (ctxt->depth > 128) {
+        xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
+                "xmlParseElementChildrenContentDecl : depth %d too deep\n",
+                          ctxt->depth);
+	return(NULL);
+    }
     SKIP_BLANKS;
     GROW;
     if (RAW == '(') {
@@@@ -5359,7 +5371,9 @@@@ xmlParseElementChildrenContentDecl (xmlParserCtxtPtr c
         /* Recurse on first child */
 	NEXT;
 	SKIP_BLANKS;
+        ctxt->depth++;
         cur = ret = xmlParseElementChildrenContentDecl(ctxt, inputid);
+        ctxt->depth--;
 	SKIP_BLANKS;
 	GROW;
     } else {
@@@@ -5491,7 +5505,9 @@@@ xmlParseElementChildrenContentDecl (xmlParserCtxtPtr c
 	    /* Recurse on second child */
 	    NEXT;
 	    SKIP_BLANKS;
+            ctxt->depth++;
 	    last = xmlParseElementChildrenContentDecl(ctxt, inputid);
+            ctxt->depth--;
 	    SKIP_BLANKS;
 	} else {
 	    elem = xmlParseName(ctxt);
@


1.4.2.1
log
@MFC:

SECURITY FIX

Resolves CVE-2009-2414 and CVE-2009-2416,
from Daniel Veillard via redhat bug 515195.
@
text
@@


1.3
log
@SECURITY; add a patch to fix CVE-2009-2414 and CVE-2009-2416,
from Daniel Veillard via redhat bug 515195. Add @@bin markers to
PLIST while there.  ok jasper@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3.2.1
log
@MFC:

SECURITY FIX

Resolves CVE-2009-2414 and CVE-2009-2416,
from Daniel Veillard via redhat bug 515195.
@
text
@d1 1
a1 1
$OpenBSD: patch-parser_c,v 1.3 2009/08/13 09:29:47 sthen Exp $
@


1.2
log
@Update to 2.5.7.

In addition to updating, this restores the libxml includes to
${LOCALBASE}/include/libxml2, thereby avoiding odd conflicts in other
ports.

It also creates and uses an xml catalog at /var/db/xmlcatalog that can
be updated by other ports with local dtds.

ok naddy@@ jolan@@
@
text
@d1 33
a33 6
$OpenBSD: patch-parser_c,v 1.1 2002/12/02 12:23:47 espie Exp $
--- parser.c.orig	Mon Dec  2 11:37:43 2002
+++ parser.c	Mon Dec  2 11:37:57 2002
@@@@ -9820,7 +9820,7 @@@@ xmlParseBalancedChunkMemoryInternal(xmlP
 	ctxt->myDoc = oldctxt->myDoc;
         content = ctxt->myDoc->children;
d35 47
a81 5
-    ctxt->myDoc->children = xmlNewDocNode(newDoc, NULL,
+    ctxt->myDoc->children = xmlNewDocNode(ctxt->myDoc, NULL,
 	                                  BAD_CAST "pseudoroot", NULL);
     if (ctxt->myDoc->children == NULL) {
 	ctxt->sax = oldsax;
@


1.1
log
@2.4.28, crucial patch added...
@
text
@d1 1
a1 1
$OpenBSD$
@

