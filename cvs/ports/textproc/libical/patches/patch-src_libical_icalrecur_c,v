head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2016.04.26.10.24.46;	author ajacoutot;	state Exp;
branches;
next	1.2;
commitid	gwqnEOCMBDG3Cq8E;

1.2
date	2011.10.02.08.55.40;	author ajacoutot;	state dead;
branches;
next	1.1;

1.1
date	2010.09.07.10.38.40;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to libical-2.0.0.
@
text
@$OpenBSD$

Add patch for possible use-after-free of icalrecurrencetype::rscale (Fedora).

Fix build on arm (Fedora).

--- src/libical/icalrecur.c.orig	Mon Dec 28 22:44:53 2015
+++ src/libical/icalrecur.c	Tue Apr 26 12:10:19 2016
@@@@ -134,6 +134,7 @@@@
 #endif
 
 #include "icalrecur.h"
+#include "icalarray.h"
 #include "icalerror.h"
 #include "icalmemory.h"
 #include "icaltimezone.h"
@@@@ -186,6 +187,139 @@@@
 
 #define LEAP_MONTH 0x1000
 
+#if defined(HAVE_PTHREAD)
+#include <pthread.h>
+static pthread_mutex_t rscale_texts_mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
+static icalarray *rscale_texts = NULL;
+
+static void initialize_rscale_texts(void)
+{
+#if defined(HAVE_LIBICU)
+    UErrorCode status = U_ZERO_ERROR;
+    UEnumeration *en;
+    const char *cal;
+#endif
+
+#if defined(HAVE_PTHREAD)
+    pthread_mutex_lock(&rscale_texts_mutex);
+#endif
+
+    if (rscale_texts != NULL) {
+    #if defined(HAVE_PTHREAD)
+        pthread_mutex_unlock(&rscale_texts_mutex);
+    #endif
+        return;
+    }
+
+    rscale_texts = icalarray_new(sizeof(char **), 20);
+
+#if defined(HAVE_LIBICU)
+    en = ucal_getKeywordValuesForLocale("calendar", NULL, FALSE, &status);
+    while ((cal = uenum_next(en, NULL, &status))) {
+        char *copy = icalmemory_strdup(cal);
+        icalarray_append(rscale_texts, &copy);
+    }
+    uenum_close(en);
+#endif
+
+#if defined(HAVE_PTHREAD)
+    pthread_mutex_unlock(&rscale_texts_mutex);
+#endif
+}
+
+static const char *match_rscale_text(const char *text)
+{
+    size_t ii;
+    const char *res = NULL;
+
+    if(!text) {
+        return NULL;
+    }
+
+    initialize_rscale_texts();
+
+#if defined(HAVE_PTHREAD)
+    pthread_mutex_lock(&rscale_texts_mutex);
+#endif
+
+    for(ii = 0; rscale_texts && ii < rscale_texts->num_elements; ii++) {
+        const char **stored, *p1, *p2;
+
+        stored = icalarray_element_at(rscale_texts, ii);
+        if(!stored || !*stored)
+            continue;
+
+        for(p1 = *stored, p2 = text; *p1 && *p2; p1++, p2++) {
+            if (tolower(*p1) != tolower(*p2))
+                break;
+        }
+
+        if(!*p1 && !*p2) {
+            res = *stored;
+            break;
+        }
+    }
+
+#if defined(HAVE_PTHREAD)
+    pthread_mutex_unlock(&rscale_texts_mutex);
+#endif
+
+    return res;
+}
+
+static const char *match_or_add_rscale_text(const char *text)
+{
+    const char *res;
+
+    if(!text) {
+        return NULL;
+    }
+
+    res = match_rscale_text (text);
+
+#if defined(HAVE_PTHREAD)
+    pthread_mutex_lock(&rscale_texts_mutex);
+#endif
+
+    if(!res && rscale_texts) {
+        res = icalmemory_strdup(text);
+        icalarray_append(rscale_texts, &res);
+    }
+
+#if defined(HAVE_PTHREAD)
+    pthread_mutex_unlock(&rscale_texts_mutex);
+#endif
+
+    return res;
+}
+
+void icalrecur_free_rscale_texts(void)
+{
+#if defined(HAVE_PTHREAD)
+    pthread_mutex_lock(&rscale_texts_mutex);
+#endif
+
+    if(rscale_texts) {
+        size_t ii;
+        for(ii = 0; rscale_texts && ii < rscale_texts->num_elements; ii++) {
+            char **stored;
+
+            stored = icalarray_element_at(rscale_texts, ii);
+            if(stored && *stored)
+                icalmemory_free_buffer(*stored);
+        }
+
+        icalarray_free(rscale_texts);
+        rscale_texts = NULL;
+    }
+
+#if defined(HAVE_PTHREAD)
+    pthread_mutex_unlock(&rscale_texts_mutex);
+#endif
+}
+
 int icalrecurrencetype_rscale_is_supported(void)
 {
     return RSCALE_IS_SUPPORTED;
@@@@ -491,8 +625,8 @@@@ static int icalrecur_add_bydayrules(struct icalrecur_p
 
     while (n != 0) {
         int sign = 1;
-        char weekno;  /* note: Novell/Groupwise sends BYDAY=255SU,
-                         so we fit in a signed char to get -1 SU for last Sun */
+        signed char weekno;  /* note: Novell/Groupwise sends BYDAY=255SU,
+                                so we fit in a signed char to get -1 SU for last Sun */
         icalrecurrencetype_weekday wd;
 
         if (i == ICAL_BY_DAY_SIZE) {
@@@@ -510,7 +644,7 @@@@ static int icalrecur_add_bydayrules(struct icalrecur_p
         }
 
         /* Get Optional weekno */
-        weekno = (char)strtol(t, &t, 10);
+        weekno = (signed char)strtol(t, &t, 10);
         if (weekno < 0) {
             weekno = -weekno;
             sign = -1;
@@@@ -585,7 +719,7 @@@@ struct icalrecurrencetype icalrecurrencetype_from_stri
             if (parser.rt.freq == ICAL_NO_RECURRENCE) r = -1;
         } else if (icalrecurrencetype_rscale_is_supported() &&
                    strcasecmp(name, "RSCALE") == 0) {
-            parser.rt.rscale = icalmemory_tmp_copy(value);
+            parser.rt.rscale = match_or_add_rscale_text(value);
         } else if (icalrecurrencetype_rscale_is_supported() &&
                    strcasecmp(name, "SKIP") == 0) {
             parser.rt.skip = icalrecur_string_to_skip(value);
@@@@ -1359,19 +1493,16 @@@@ static int initialize_iterator(icalrecur_iterator *imp
         impl->greg = NULL;
     } else {
         UEnumeration *en;
-        const char *cal;
-        char *r;
+        const char *cal, *rrscale;
 
-        /* Lowercase the specified calendar */
-        for (r = rule.rscale; *r; r++) {
-            *r = tolower((int)*r);
-        }
+        /* This can be a user-created string, thus not a one from the pool */
+        rrscale = match_or_add_rscale_text (rule.rscale);
 
         /* Check if specified calendar is supported */
         en = ucal_getKeywordValuesForLocale("calendar", NULL, FALSE, &status);
         while ((cal = uenum_next(en, NULL, &status))) {
-            if (!strcmp(cal, rule.rscale)) {
-                is_hebrew = !strcmp(rule.rscale, "hebrew");
+            if (rrscale == match_rscale_text(cal)) {
+                is_hebrew = rrscale == match_rscale_text("hebrew");
                 break;
             }
         }
@


1.2
log
@Update to libical-0.46.
Merge some more changes from upstream SVN.

ok sebastia@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_libical_icalrecur_c,v 1.1 2010/09/07 10:38:40 jasper Exp $
d3 1
a3 1
Fix build with gcc2.
d5 195
a199 34
--- src/libical/icalrecur.c.orig	Mon Sep  6 09:16:29 2010
+++ src/libical/icalrecur.c	Mon Sep  6 14:14:53 2010
@@@@ -1593,10 +1593,11 @@@@ static int next_month(icalrecur_iterator* impl)
       int day;
       int days_in_month = icaltime_days_in_month(impl->last.month,
                                                    impl->last.year);
-      assert( BYDAYPTR[0]!=ICAL_RECURRENCE_ARRAY_MAX);
-
       int set_pos_counter = 0;
       int set_pos_total = 0;
+      int found = 0;
+
+      assert( BYDAYPTR[0]!=ICAL_RECURRENCE_ARRAY_MAX);
       
       /* Count the past positions for the BYSETPOS calculation */
       if(has_by_data(impl,BY_SET_POS)){
@@@@ -1613,8 +1614,6 @@@@ static int next_month(icalrecur_iterator* impl)
           impl->last.day = last_day;
       }
 
-      int found = 0;
-      
       for(day = impl->last.day+1; day <= days_in_month; day++){
           impl->last.day = day;
 	  
@@@@ -1927,8 +1926,8 @@@@ static int expand_year_days(icalrecur_iterator* impl, 
     /* BY_WEEK_NO together with BY_MONTH - may conflict, in this case BY_MONTH wins */
     if( (flags & 1<<BY_MONTH) && (flags & 1<<BY_WEEK_NO) ){
         int valid_weeks[ICAL_BY_WEEKNO_SIZE];
-        memset(valid_weeks, 0, sizeof(valid_weeks));
         int valid = 1;    
+        memset(valid_weeks, 0, sizeof(valid_weeks));
         t.year = year;
         t.is_date = 1;
d201 10
@


1.1
log
@- fix build with gcc2
@
text
@d1 1
a1 1
$OpenBSD$
@

