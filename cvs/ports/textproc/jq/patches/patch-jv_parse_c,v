head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.8
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.6
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.4
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2016.04.23.14.11.14;	author sthen;	state Exp;
branches
	1.1.2.1;
next	;
commitid	hFzWGYf17NVg7P6X;

1.1.2.1
date	2016.05.02.11.25.19;	author jasper;	state Exp;
branches;
next	;
commitid	rkPwFQjHClOANU52;


desc
@@


1.1
log
@Fix off-by-one leading to heap buffer overflow in textproc/jq,
triggered by JSON-encoded numbers longer than 256 bytes. CVE-2015-8863
@
text
@$OpenBSD$

From 8eb1367ca44e772963e704a700ef72ae2e12babd Mon Sep 17 00:00:00 2001
From: Nicolas Williams <nico@@cryptonector.com>
Date: Sat, 24 Oct 2015 17:24:57 -0500
Subject: [PATCH] Heap buffer overflow in tokenadd() (fix #105)

This was an off-by one: the NUL terminator byte was not allocated on
resize.  This was triggered by JSON-encoded numbers longer than 256
bytes.

--- jv_parse.c.orig	Sat Apr 23 15:06:29 2016
+++ jv_parse.c	Sat Apr 23 15:06:55 2016
@@@@ -383,7 +383,7 @@@@ static pfunc stream_token(struct jv_parser* p, char ch
 
 static void tokenadd(struct jv_parser* p, char c) {
   assert(p->tokenpos <= p->tokenlen);
-  if (p->tokenpos == p->tokenlen) {
+  if (p->tokenpos >= p->tokenlen) {
     p->tokenlen = p->tokenlen*2 + 256;
     p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);
   }
@@@@ -485,7 +485,7 @@@@ static pfunc check_literal(struct jv_parser* p) {
     TRY(value(p, v));
   } else {
     // FIXME: better parser
-    p->tokenbuf[p->tokenpos] = 0; // FIXME: invalid
+    p->tokenbuf[p->tokenpos] = 0;
     char* end = 0;
     double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);
     if (end == 0 || *end != 0)
@


1.1.2.1
log
@Fix off-by-one leading to heap buffer overflow in textproc/jq,
triggered by JSON-encoded numbers longer than 256 bytes. CVE-2015-8863
@
text
@d1 1
a1 1
$OpenBSD: patch-jv_parse_c,v 1.1 2016/04/23 14:11:14 sthen Exp $
@

