head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.8
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.6
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.2
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.4
	OPENBSD_5_8_BASE:1.1.1.1
	okan_20150324:1.1.1.1
	okan:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2015.03.24.19.16.13;	author okan;	state Exp;
branches
	1.1.1.1;
next	;
commitid	F0CFyG1IJkn4sMvY;

1.1.1.1
date	2015.03.24.19.16.13;	author okan;	state Exp;
branches;
next	;
commitid	F0CFyG1IJkn4sMvY;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$

Switch to using arc4random(3) everywhere, since they don't really want
repeatability (as evidenced by the arguments they pass to srand(3)).

--- html.c.orig	Mon Mar  9 18:52:39 2015
+++ html.c	Sat Mar 21 15:44:10 2015
@@@@ -112,8 +112,12 @@@@ void print_html_node(GString *out, node *n, scratch_pa
 				scratch->footnote_para_counter --;
 				if (scratch->footnote_para_counter == 0) {
 					if (scratch->extensions & EXT_RANDOM_FOOT) {
+#ifdef HAVE_ARC4RANDOM
+						random = arc4random_uniform(99999) + 1;
+#else
 						srand(scratch->random_seed_base + scratch->footnote_to_print);
 						random = rand() % 99999 + 1;
+#endif
 					} else {
 						random = scratch->footnote_to_print;
 					}
@@@@ -574,8 +578,12 @@@@ void print_html_node(GString *out, node *n, scratch_pa
 			temp_node = node_for_count(scratch->used_notes, lev);
 			
 			if (scratch->extensions & EXT_RANDOM_FOOT) {
+#ifdef HAVE_ARC4RANDOM
+				random = arc4random_uniform(99999) + 1;
+#else
 				srand(scratch->random_seed_base + lev);
 				random = rand() % 99999 + 1;
+#endif
 			} else {
 				random = lev;
 			}
@@@@ -628,8 +636,12 @@@@ void print_html_node(GString *out, node *n, scratch_pa
 					fprintf(stderr, "matching cite found - %d\n",lev);
 #endif
 					if (scratch->extensions & EXT_RANDOM_FOOT) {
+#ifdef HAVE_ARC4RANDOM
+						random = arc4random_uniform(99999) + 1;
+#else
 						srand(scratch->random_seed_base + lev);
 						random = rand() % 99999 + 1;
+#endif
 					} else {
 						random = lev;
 					}
@@@@ -901,8 +913,12 @@@@ void print_html_endnotes(GString *out, scratch_pad *sc
 		pad(out, 1, scratch);
 		
 		if (scratch->extensions & EXT_RANDOM_FOOT) {
+#ifdef HAVE_ARC4RANDOM
+			random = arc4random_uniform(99999) + 1;
+#else
 			srand(scratch->random_seed_base + counter);
 			random = rand() % 99999 + 1;
+#endif
 		} else {
 			random = counter;
 		}
@


1.1.1.1
log
@Import textproc/multimarkdown
feedback and ok bcallah@@

MultiMarkdown is a derivative of Markdown that adds new syntax
features, such as footnotes, tables, and metadata. Additionally, it
offers mechanisms to convert plain text into LaTeX in addition to
HTML.

From Sean Levy
@
text
@@
