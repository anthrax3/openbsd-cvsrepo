head	1.4;
access;
symbols
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_1:1.1.0.10
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.8
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.6
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_7:1.1.0.4
	OPENBSD_3_8:1.1.0.2;
locks; strict;
comment	@# @;


1.4
date	2011.10.01.19.46.35;	author kili;	state dead;
branches;
next	1.3;

1.3
date	2011.03.03.21.22.13;	author stsp;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.30.04.32.13;	author ckuethe;	state dead;
branches;
next	1.1;

1.1
date	2006.02.05.09.59.01;	author bernd;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1
	1.1.8.1
	1.1.10.1;
next	;

1.1.2.1
date	2006.02.06.22.13.43;	author sturm;	state Exp;
branches;
next	;

1.1.4.1
date	2006.02.06.22.15.58;	author sturm;	state Exp;
branches;
next	;

1.1.6.1
date	2007.04.03.12.16.22;	author sturm;	state dead;
branches;
next	;

1.1.8.1
date	2007.04.03.12.03.20;	author sturm;	state dead;
branches;
next	;

1.1.10.1
date	2007.05.01.16.28.30;	author sturm;	state dead;
branches;
next	;


desc
@@


1.4
log
@Update to xpdf-3.03.
@
text
@$OpenBSD: patch-splash_SplashXPathScanner_cc,v 1.3 2011/03/03 21:22:13 stsp Exp $

http://www.mail-archive.com/ports@@openbsd.org/msg23488.html

--- splash/SplashXPathScanner.cc.orig	Mon Aug 16 13:56:18 2010
+++ splash/SplashXPathScanner.cc	Mon Aug 16 13:57:02 2010
@@@@ -397,7 +397,7 @@@@ void SplashXPathScanner::clipAALine(SplashBitmap *aaBu
 	for (; xx + 7 <= xx0; xx += 8) {
 	  *p++ = 0x00;
 	}
-	if (xx <= xx0) {
+	if (xx < xx0) {
 	  *p &= 0xff >> (xx0 & 7);
 	}
       }
@@@@ -406,6 +406,9 @@@@ void SplashXPathScanner::clipAALine(SplashBitmap *aaBu
       }
     }
     xx0 = (*x1 + 1) * splashAASize;
+    if (xx0 > aaBuf->getWidth()) {
+      xx0 = aaBuf->getWidth();
+    }
     // set [xx, xx0) to 0
     if (xx < xx0) {
       p = aaBuf->getDataPtr() + yy * aaBuf->getRowSize() + (xx >> 3);
@@@@ -420,7 +423,7 @@@@ void SplashXPathScanner::clipAALine(SplashBitmap *aaBu
       for (; xx + 7 <= xx0; xx += 8) {
 	*p++ = 0x00;
       }
-      if (xx <= xx0) {
+      if (xx < xx0) {
 	*p &= 0xff >> (xx0 & 7);
       }
     }
@


1.3
log
@Apply a patch to fix a heap overflow (poppler has the same fix, and xpdf
upstream will release this fix in xpdf-3.03).
Also apply a patch that kili@@ lifted from poppler some time ago.
Both patches fix crashes seen with some PDF documents.

ok sthen, "don't wait for me" kili
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@Forgot to cvs rm this one too. Pointed out by marco
@
text
@d1 14
a14 27
$OpenBSD: patch-splash_SplashXPathScanner_cc,v 1.1 2006/02/05 09:59:01 bernd Exp $
--- splash/SplashXPathScanner.cc.orig	Wed Aug 17 07:34:31 2005
+++ splash/SplashXPathScanner.cc	Sat Feb  4 14:32:51 2006
@@@@ -186,7 +186,7 @@@@ GBool SplashXPathScanner::getNextSpan(in
 }
 
 void SplashXPathScanner::computeIntersections(int y) {
-  SplashCoord ySegMin, ySegMax, xx0, xx1;
+  SplashCoord xSegMin, xSegMax, ySegMin, ySegMax, xx0, xx1;
   SplashXPathSeg *seg;
   int i, j;
 
@@@@ -236,19 +236,27 @@@@ void SplashXPathScanner::computeIntersec
     } else if (seg->flags & splashXPathVert) {
       xx0 = xx1 = seg->x0;
     } else {
-      if (ySegMin <= y) {
-	// intersection with top edge
-	xx0 = seg->x0 + ((SplashCoord)y - seg->y0) * seg->dxdy;
+      if (seg->x0 < seg->x1) {
+	xSegMin = seg->x0;
+	xSegMax = seg->x1;
       } else {
-	// x coord of segment endpoint with min y coord
-	xx0 = (seg->flags & splashXPathFlip) ? seg->x1 : seg->x0;
+	xSegMin = seg->x1;
+	xSegMax = seg->x0;
d16 17
a32 20
-      if (ySegMax >= y + 1) {
-	// intersection with bottom edge
-	xx1 = seg->x0 + ((SplashCoord)y + 1 - seg->y0) * seg->dxdy;
-      } else {
-	// x coord of segment endpoint with max y coord
-	xx1 = (seg->flags & splashXPathFlip) ? seg->x0 : seg->x1;
+      // intersection with top edge
+      xx0 = seg->x0 + ((SplashCoord)y - seg->y0) * seg->dxdy;
+      // intersection with bottom edge
+      xx1 = seg->x0 + ((SplashCoord)y + 1 - seg->y0) * seg->dxdy;
+      // the segment may not actually extend to the top and/or bottom edges
+      if (xx0 < xSegMin) {
+	xx0 = xSegMin;
+      } else if (xx0 > xSegMax) {
+	xx0 = xSegMax;
+      }
+      if (xx1 < xSegMin) {
+	xx1 = xSegMin;
+      } else if (xx1 > xSegMax) {
+	xx1 = xSegMax;
a34 1
     if (xx0 < xx1) {
@


1.1
log
@Fix heap based buffer overflow.

From KDE. http://www.kde.org/info/security/advisory-20060202-1.txt

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.10.1
log
@MFC:
Update to xpdf 3.0.2, from Stuart Henderson and Brad Smith
Includes some security fixes
@
text
@d1 1
a1 1
$OpenBSD: patch-splash_SplashXPathScanner_cc,v 1.1 2006/02/05 09:59:01 bernd Exp $
@


1.1.6.1
log
@MFC:
Update to xpdf 3.0.2, from Stuart Henderson and Brad Smith
Includes some security fixes
@
text
@d1 1
a1 1
$OpenBSD: patch-splash_SplashXPathScanner_cc,v 1.1 2006/02/05 09:59:01 bernd Exp $
@


1.1.8.1
log
@MFC:
Update to xpdf 3.0.2, from Stuart Henderson and Brad Smith
Includes some security fixes
@
text
@d1 1
a1 1
$OpenBSD: patch-splash_SplashXPathScanner_cc,v 1.1 2006/02/05 09:59:01 bernd Exp $
@


1.1.4.1
log
@MFC:
Fix heap based buffer overflow.

From KDE. http://www.kde.org/info/security/advisory-20060202-1.txt
@
text
@d1 4
a4 4
$OpenBSD: patch-splash_SplashXPathScanner_cc,v 1.1 2006/02/05 09:59:01 bernd Exp $
--- splash/SplashXPathScanner.cc.orig	Thu Jan 22 02:26:44 2004
+++ splash/SplashXPathScanner.cc	Mon Feb  6 20:48:38 2006
@@@@ -182,7 +182,7 @@@@ GBool SplashXPathScanner::getNextSpan(in
d13 1
a13 1
@@@@ -232,19 +232,27 @@@@ void SplashXPathScanner::computeIntersec
d19 1
a19 1
-	xx0 = seg->x0 + (y - seg->y0) * seg->dxdy;
d31 1
a31 1
-	xx1 = seg->x0 + (y + 1 - seg->y0) * seg->dxdy;
@


1.1.2.1
log
@MFC:
Fix heap based buffer overflow.

From KDE. http://www.kde.org/info/security/advisory-20060202-1.txt
@
text
@d1 4
a4 4
$OpenBSD: patch-splash_SplashXPathScanner_cc,v 1.1 2006/02/05 09:59:01 bernd Exp $
--- splash/SplashXPathScanner.cc.orig	Mon Feb  6 20:42:26 2006
+++ splash/SplashXPathScanner.cc	Mon Feb  6 20:46:46 2006
@@@@ -182,7 +182,7 @@@@ GBool SplashXPathScanner::getNextSpan(in
d13 1
a13 1
@@@@ -232,19 +232,27 @@@@ void SplashXPathScanner::computeIntersec
d19 1
a19 1
-	xx0 = seg->x0 + (y - seg->y0) * seg->dxdy;
d31 1
a31 1
-	xx1 = seg->x0 + (y + 1 - seg->y0) * seg->dxdy;
@

