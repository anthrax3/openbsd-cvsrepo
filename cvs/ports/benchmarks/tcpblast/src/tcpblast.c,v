head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.56
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.54
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.52
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.48
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.50
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.46
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.44
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.40
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.38
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.36
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.22
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.20
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.18
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.16
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_TRACKING_SWITCH:1.3
	OPENBSD_2_9:1.3.0.14
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	tcpblast1_0:1.1.1.1
	tcpblast:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.10.07.21.08.44;	author jolan;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.02.00.56.56;	author jolan;	state Exp;
branches;
next	1.3;

1.3
date	98.02.13.14.37.22;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.02.13.07.45.43;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.11.27.02.29.25;	author joey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.11.27.02.29.25;	author joey;	state Exp;
branches;
next	;


desc
@@


1.5
log
@make usage message reflect the code (again).  pointed out by Andrey
Smagin.
@
text
@/*
 *	tcpblast - test and estimate TCP thruput
 *
 *	Daniel Karrenberg   <daniel@@karrenberg.net>
 *
 *	I released tcpblast into the public domain, so it is OK to
 *	redistribute it.  I am also fine with attaching the same public
 *      license	that is used for OpenBSD itself.  Your choice.
 *
 *	Daniel
 */

#include <sys/types.h>
#include <machine/endian.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/time.h>

#include <netinet/in.h>

#include <netdb.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>
#include <errno.h>

#define BLKSIZE 1024

struct	sockaddr_in sock_in;
struct	servent *sp;
struct	hostent *host;

long starts, startms, stops, stopms, expms;
struct timeval ti; 
struct timezone tiz;

char 	greet[BLKSIZE] = "Hi!";
int 	nblocks;
int	f;

int main(argc, argv)
int argc; char **argv;
{
	struct addrinfo hints, *res, *res0;
	char *cause = NULL;
	int ch, error;
	register int i;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	while ((ch = getopt(argc, argv, "46")) != -1) {
		switch (ch) {
		case '4':
			hints.ai_family = PF_INET;
			break;
		case '6':
			hints.ai_family = PF_INET6;
			break;
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 2) {
		fprintf(stderr,
			"usage: tcpblast [-4] [-6] destination nblkocks\n"
			"blocksize: %d bytes %d\n", BLKSIZE, argc);
		exit(1);
	}

	nblocks = atoi(argv[1]);
	if (nblocks<=1 || nblocks>=10000) {
		fprintf(stderr, "tcpblast: 1 < nblocks < 10000 \n");
		exit(1);
	}

	error = getaddrinfo(argv[0], "discard", &hints, &res0);
	if (error)
		errx(1, "%s", gai_strerror(error));
	f = -1;
	cause = "no addresses";
	errno = EADDRNOTAVAIL;
	for (res = res0; res; res = res->ai_next) {
		f = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (f < 0) {
			cause = "socket";
			continue;
		}
		if (connect(f, res->ai_addr, res->ai_addrlen) < 0) {
			cause = "connect";
			close(f);
			f = -1;
			continue;
		}
		break;
	}
	if (f < 0)
		err(1, cause);
	freeaddrinfo(res);

	if (gettimeofday(&ti, &tiz) < 0)
	{
		perror("tcpblast time:");
		exit(1);
	}
	starts =  ti.tv_sec;
	startms = ti.tv_usec / 1000L;


	for (i=0; i<nblocks; i++)
	{
		if (write(f, greet, BLKSIZE) != BLKSIZE)
			perror("tcpblast send:");
		write(1, ".", 1);
	}

	if (gettimeofday(&ti, &tiz) < 0)
	{
		perror("tcpblast time:");
		exit(1);
	}
	stops =  ti.tv_sec;
	stopms = ti.tv_usec / 1000L;

	expms = (stops-starts)*1000 + (stopms-startms);
	printf("\n%d %d-byte blocks in %ld msec.\n", nblocks, BLKSIZE, expms);
	printf("Throughput  =  %.1f kbit/s", (double) (nblocks*BLKSIZE) / expms * 8.0);
	printf("  =  %.1f kByte/s", (double) (nblocks*BLKSIZE) / expms);
	printf("  =  %.1f MByte/s\n", (double) (nblocks*BLKSIZE) / (double)(expms*1024.0));
return(0);
}
@


1.4
log
@- add author's statement about this being in the PD to the src
  (tracking down & e-mailing done by Xavier Santolaria)
- document in DESCR that this needs the discard service of inetd
- patch in ipv6 support (from FreeBSD port) and call it v1.1
@
text
@d76 1
a76 1
		fprintf(stderr, "tcpblast: 1 < nblocks <= 10000 \n");
@


1.3
log
@Make usage message reflect the code
@
text
@d4 7
a10 1
 *	Daniel Karrenberg   <dfk@@nic.eu.net>
d26 2
d46 3
d51 13
a63 5
	if (argc!=3)
	{
		fprintf(stderr, "usage: tcpblast destination nblocks\n");
		fprintf(stderr, "blocksize: %d bytes\n", BLKSIZE);
		exit(1);
d65 6
a70 5

	nblocks = atoi(argv[2]);
	if (nblocks<=1 || nblocks>=10000)
	{
		fprintf(stderr, "tcpblast: 1 < nblocks < 10000 \n");
d74 3
a76 9
	bzero((char *)&sock_in, sizeof (sock_in));
	sock_in.sin_family = AF_INET;
	f = socket(AF_INET, SOCK_STREAM, 0);
	if (f < 0) {
		perror("tcpblast: socket");
		exit(3);
	}
	if (bind(f, (struct sockaddr*) &sock_in, sizeof (sock_in)) < 0) {
		perror("tcpblast: bind");
d80 11
a90 10
	host = gethostbyname(argv[1]);
	if (host) {
		sock_in.sin_family = host->h_addrtype;
		bcopy(host->h_addr, &sock_in.sin_addr, host->h_length);
	} else {
		sock_in.sin_family = AF_INET;
		sock_in.sin_addr.s_addr = inet_addr(argv[1]);
		if (sock_in.sin_addr.s_addr == -1) {
			fprintf(stderr, "tcpblast: %s unknown host\n", argv[1]);
			exit(1);
d92 7
d100 3
a102 7
	sock_in.sin_port = htons(9);

	if (connect(f, (struct sockaddr*) &sock_in, sizeof(sock_in)) <0)
	{
		perror("tcpblast connect:");
		exit(1);
	}
d129 3
a131 3
	printf("\n%d KB in %ld msec", nblocks, expms);
	printf("  =  %.1f kbit/s", (double) (nblocks*BLKSIZE) / expms * 8000.0);
	printf("  =  %.1f kByte/s", (double) (nblocks*BLKSIZE) / expms * 1000);
@


1.2
log
@typo
@
text
@d50 1
a50 1
		fprintf(stderr, "tcpblast: 1 < nblocks <= 10000 \n");
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
		fprintf(stderr, "usage: tcpblast destination nblkocks\n");
@


1.1.1.1
log
@
@
text
@@
