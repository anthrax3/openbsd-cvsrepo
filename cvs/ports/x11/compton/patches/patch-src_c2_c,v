head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.12
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.10
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.8
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.4
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.6
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.2
	OPENBSD_5_7_BASE:1.1.1.1
	sthen_20141027:1.1.1.1
	sthen:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2014.10.27.11.21.49;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;
commitid	Y1ZJQVC2yFK3u0u6;

1.1.1.1
date	2014.10.27.11.21.49;	author sthen;	state Exp;
branches;
next	;
commitid	Y1ZJQVC2yFK3u0u6;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$

anonymous unions aren't part of c99, but code is compiled with --std=c99
(and uses other c99 features that need this).

--- src/c2.c.orig	Sat Oct 25 22:13:39 2014
+++ src/c2.c	Sat Oct 25 22:14:08 2014
@@@@ -171,7 +171,7 @@@@ c2_parse_grp(session_t *ps, const char *pattern, int o
       else {
         eles[1] = c2h_comb_tree(ops[2], eles[1], C2_PTR_NULL);
         assert(eles[1].isbranch);
-        pele = &eles[1].b->opr2;
+        pele = &eles[1].u.b->opr2;
       }
       // The last operator always needs to be reset
       ops[2] = C2_B_OUNDEFINED;
@@@@ -195,7 +195,7 @@@@ c2_parse_grp(session_t *ps, const char *pattern, int o
       if ((offset = c2_parse_pattern(ps, pattern, offset, pele)) < 0)
         goto c2_parse_grp_fail;
 
-      if (!c2_l_postprocess(ps, pele->l))
+      if (!c2_l_postprocess(ps, pele->u.l))
         goto c2_parse_grp_fail;
     }
     // Decrement offset -- we will increment it in loop update
@@@@ -205,9 +205,9 @@@@ c2_parse_grp(session_t *ps, const char *pattern, int o
     if (neg) {
       neg = false;
       if (pele->isbranch)
-        pele->b->neg = !pele->b->neg;
+        pele->u.b->neg = !pele->u.b->neg;
       else
-        pele->l->neg = !pele->l->neg;
+        pele->u.l->neg = !pele->u.l->neg;
     }
 
     next_expected = false;
@@@@ -263,11 +263,11 @@@@ static int
 c2_parse_target(session_t *ps, const char *pattern, int offset, c2_ptr_t *presult) {
   // Initialize leaf
   presult->isbranch = false;
-  presult->l = malloc(sizeof(c2_l_t));
-  if (!presult->l)
+  presult->u.l = malloc(sizeof(c2_l_t));
+  if (!presult->u.l)
     c2_error("Failed to allocate memory for new leaf.");
 
-  c2_l_t * const pleaf = presult->l;
+  c2_l_t * const pleaf = presult->u.l;
   memcpy(pleaf, &leaf_def, sizeof(c2_l_t));
 
   // Parse negation marks
@@@@ -452,7 +452,7 @@@@ c2_parse_target(session_t *ps, const char *pattern, in
  */
 static int
 c2_parse_op(const char *pattern, int offset, c2_ptr_t *presult) {
-  c2_l_t * const pleaf = presult->l;
+  c2_l_t * const pleaf = presult->u.l;
 
   // Parse negation marks
   C2H_SKIP_SPACES();
@@@@ -517,7 +517,7 @@@@ c2_parse_op(const char *pattern, int offset, c2_ptr_t 
  */
 static int
 c2_parse_pattern(session_t *ps, const char *pattern, int offset, c2_ptr_t *presult) {
-  c2_l_t * const pleaf = presult->l;
+  c2_l_t * const pleaf = presult->u.l;
 
   // Exists operator cannot have pattern
   if (!pleaf->op)
@@@@ -664,7 +664,7 @@@@ c2_parse_legacy(session_t *ps, const char *pattern, in
   if (!pleaf)
     printf_errfq(1, "(): Failed to allocate memory for new leaf.");
   presult->isbranch = false;
-  presult->l = pleaf;
+  presult->u.l = pleaf;
   memcpy(pleaf, &leaf_def, sizeof(c2_l_t));
   pleaf->type = C2_L_TSTRING;
   pleaf->op = C2_L_OEQ;
@@@@ -825,7 +825,7 @@@@ static void
 c2_free(c2_ptr_t p) {
   // For a branch element
   if (p.isbranch) {
-    c2_b_t * const pbranch = p.b;
+    c2_b_t * const pbranch = p.u.b;
 
     if (!pbranch)
       return;
@@@@ -836,7 +836,7 @@@@ c2_free(c2_ptr_t p) {
   }
   // For a leaf element
   else {
-    c2_l_t * const pleaf = p.l;
+    c2_l_t * const pleaf = p.u.l;
 
     if (!pleaf)
       return;
@@@@ -901,7 +901,7 @@@@ static void
 c2_dump_raw(c2_ptr_t p) {
   // For a branch
   if (p.isbranch) {
-    const c2_b_t * const pbranch = p.b;
+    const c2_b_t * const pbranch = p.u.b;
 
     if (!pbranch)
       return;
@@@@ -924,7 +924,7 @@@@ c2_dump_raw(c2_ptr_t p) {
   }
   // For a leaf
   else {
-    const c2_l_t * const pleaf = p.l;
+    const c2_l_t * const pleaf = p.u.l;
 
     if (!pleaf)
       return;
@@@@ -1219,7 +1219,7 @@@@ c2_match_once(session_t *ps, win *w, const c2_ptr_t co
 
   // Handle a branch
   if (cond.isbranch) {
-    const c2_b_t *pb = cond.b;
+    const c2_b_t *pb = cond.u.b;
 
     if (!pb)
       return false;
@@@@ -1251,7 +1251,7 @@@@ c2_match_once(session_t *ps, win *w, const c2_ptr_t co
   }
   // Handle a leaf
   else {
-    const c2_l_t *pleaf = cond.l;
+    const c2_l_t *pleaf = cond.u.l;
 
     if (!pleaf)
       return false;
@@@@ -1276,7 +1276,7 @@@@ c2_match_once(session_t *ps, win *w, const c2_ptr_t co
   if (error)
     result = false;
 
-  if (cond.isbranch ? cond.b->neg: cond.l->neg)
+  if (cond.isbranch ? cond.u.b->neg: cond.u.l->neg)
     result = !result;
 
   return result;
@


1.1.1.1
log
@import x11/compton, from maintainer Sunil Nimmagadda, ok landry@@

Compton is a lightweight, standalone composite manager, suitable for use
with window managers that do not natively provide compositing functionality.

Compton itself is a fork of xcompmgr-dana, in turn a fork of xcompmgr.

Compton in particular is notable for fixing numerous bugs found in
its predecessors, and as such, is popular due to its reliability and
stability. Numerous additional improvements and configuration options
have also been implemented, including a faster GLX (OpenGL) backend
(disabled by default), default inactive/active window opacity, window
frame transparency, window background blur, window color inversion,
painting rate throttling, VSync, condition-based fine-tune control,
configuration file reading, and D-Bus control.
@
text
@@
