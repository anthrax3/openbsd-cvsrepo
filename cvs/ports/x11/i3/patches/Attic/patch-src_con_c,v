head	1.17;
access;
symbols
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2;
locks; strict;
comment	@# @;


1.17
date	2016.03.09.09.25.51;	author dcoppa;	state dead;
branches;
next	1.16;
commitid	5e0lb25PYzcoURwg;

1.16
date	2015.12.18.15.53.09;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	0OqseA58UoyREWdQ;

1.15
date	2015.03.17.15.39.47;	author dcoppa;	state dead;
branches;
next	1.14;
commitid	WQl7M1uD6B2NjHh4;

1.14
date	2014.08.18.08.46.27;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	Bi02IjLxhs8ESxGu;

1.13
date	2014.01.11.16.04.43;	author dcoppa;	state dead;
branches;
next	1.12;

1.12
date	2013.11.22.19.02.50;	author dcoppa;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.13.10.01.56;	author dcoppa;	state dead;
branches;
next	1.10;

1.10
date	2013.05.17.10.21.42;	author dcoppa;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.13.12.10.13;	author dcoppa;	state dead;
branches;
next	1.8;

1.8
date	2012.10.01.08.12.17;	author dcoppa;	state Exp;
branches;
next	1.7;

1.7
date	2012.02.21.14.05.39;	author dcoppa;	state dead;
branches;
next	1.6;

1.6
date	2012.01.25.10.29.30;	author dcoppa;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.20.15.53.18;	author dcoppa;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.11.13.33.48;	author dcoppa;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.27.09.05.17;	author dcoppa;	state dead;
branches;
next	1.2;

1.2
date	2011.12.01.16.00.01;	author dcoppa;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.06.20.23.25;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.17
log
@
Update to i3-4.12
Added halex@@'s window hints fix
Fixed trailing whitespace in pkg/DESCR (spotted by Josh Grosse)

Tested by tb@@ and Josh Grosse
OK tb@@
@
text
@$OpenBSD: patch-src_con_c,v 1.16 2015/12/18 15:53:09 dcoppa Exp $

Avoid freeze when moving container

Fix moving windows to a marked workspace by mark.

Fix crash when trying to split and float a dock container.

--- src/con.c.orig	Wed Sep 30 08:55:10 2015
+++ src/con.c	Fri Dec 18 13:58:58 2015
@@@@ -448,6 +448,20 @@@@ bool con_is_floating(Con *con) {
 }
 
 /*
+ * Returns true if the container is a docked container.
+ *
+ */
+bool con_is_docked(Con *con) {
+    if (con->parent == NULL)
+        return false;
+
+    if (con->parent->type == CT_DOCKAREA)
+        return true;
+
+    return con_is_docked(con->parent);
+}
+
+/*
  * Checks if the given container is either floating or inside some floating
  * container. It returns the FLOATING_CON container.
  *
@@@@ -1017,6 +1031,12 @@@@ bool con_move_to_mark(Con *con, const char *mark) {
     if (con_is_floating(target)) {
         DLOG("target container is floating, moving container to target's workspace.\n");
         con_move_to_workspace(con, con_get_workspace(target), true, false, false);
+        return true;
+    }
+
+    if (con->type == CT_WORKSPACE) {
+        DLOG("target container is a workspace, simply moving the container there.\n");
+        con_move_to_workspace(con, target, true, false, false);
         return true;
     }
 
@


1.16
log
@
Merge all the fixes from the git stable branch of i3
Regen WANTLIB while here
@
text
@d1 1
a1 1
$OpenBSD$
@


1.15
log
@
Update to i3-4.9.1

new dependency on x11/xkbcommon
@
text
@d1 1
a1 1
$OpenBSD: patch-src_con_c,v 1.14 2014/08/18 08:46:27 dcoppa Exp $
d3 1
a3 3
commit fc886315342b3a2292ad0c08394b6bb452663bb1
Author: Michael Stapelberg <michael@@stapelberg.de>
Date:   Fri Aug 8 20:15:59 2014 +0200
d5 1
a5 1
Bugfix: don't set focus in con_set_layout() on invisible workspaces
d7 6
a12 5
--- src/con.c.orig	Sun Jun 15 19:12:43 2014
+++ src/con.c	Mon Aug 18 10:22:24 2014
@@@@ -1263,8 +1263,14 @@@@ void con_set_layout(Con *con, layout_t layout) {
             new->layout = layout;
             new->last_split_layout = con->last_split_layout;
d14 30
a43 9
+            /* Save the container that was focused before we move containers
+             * around, but only if the container is visible (otherwise focus
+             * will be restored properly automatically when switching). */
             Con *old_focused = TAILQ_FIRST(&(con->focus_head));
             if (old_focused == TAILQ_END(&(con->focus_head)))
+                old_focused = NULL;
+            if (old_focused != NULL &&
+                !workspace_is_visible(con_get_workspace(old_focused)))
                 old_focused = NULL;
a44 1
             /* 3: move the existing cons of this workspace below the new con */
@


1.14
log
@
Fixes from upstream:

Bugfix: properly restore workspace containers
(upstream git commit 679a5de8cfb9211afb1a1dd882e53bd672084754)

Bugfix: missed case for decoration rerender
(upstream git commit 56c284af8e281d9d5657e55b3edb7f7c673fc747)

Bugfix: add a sync call to i3bar to confirm reparents before exiting
(upstream git commit 4699c714b33afb1c264f3d19911b880267165b94)

Bugfix: don't set focus in con_set_layout() on invisible workspaces
(upstream git commit fc886315342b3a2292ad0c08394b6bb452663bb1)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.13
log
@Update to i3-4.7
@
text
@d1 1
a1 1
$OpenBSD: patch-src_con_c,v 1.12 2013/11/22 19:02:50 dcoppa Exp $
d3 21
a23 30
commit 57822e3ed43c011ad8d28c09b31c014cd930fe9b
Author: Tony Crisci <tony@@dubstepdish.com>
Date:   Fri Nov 22 10:00:49 2013 -0500

Remove-child callback skips output content cons

Every container 'above' (in the hierarchy) the workspace content should
not be closed when the last child was removed.

Add a check for output content containers and do not handle them. These
cons are at the root of the output container with dockarea siblings.
They may be run through this callback when an output is killed with
RandR.

Fixes an issue that caused content cons to become urgent when the output
is killed with RandR.

--- src/con.c.orig	Wed Aug  7 20:50:24 2013
+++ src/con.c	Fri Nov 22 19:50:19 2013
@@@@ -1354,8 +1354,9 @@@@ static void con_on_remove_child(Con *con) {
      * not be closed when the last child was removed */
     if (con->type == CT_OUTPUT ||
         con->type == CT_ROOT ||
-        con->type == CT_DOCKAREA) {
-        DLOG("not handling, type = %d\n", con->type);
+        con->type == CT_DOCKAREA ||
+        (con->parent != NULL && con->parent->type == CT_OUTPUT)) {
+        DLOG("not handling, type = %d, name = %s\n", con->type, con->name);
         return;
     }
d25 1
@


1.12
log
@Fix an issue that caused content cons to become urgent when the
output is killed with RandR
(upstream git commit 57822e3ed43c011ad8d28c09b31c014cd930fe9b)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.11
log
@Update to i3-4.6

ok tobiasu@@, abieber@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_con_c,v 1.10 2013/05/17 10:21:42 dcoppa Exp $
d3 29
a31 11
commit 0901720a24fde4503e5d2071f7c180531b2a634b
Author: Michael Stapelberg <michael@@stapelberg.de>
Date:   Tue Apr 2 23:59:26 2013 +0200

Bugfix: fix floating window size with hide_edge_borders

--- src/con.c.orig	Mon Mar 18 22:43:36 2013
+++ src/con.c	Fri May 17 10:50:32 2013
@@@@ -1079,6 +1079,12 @@@@ Rect con_border_style_rect(Con *con) {
     } else {
         result = (Rect){border_width, border_width, -(2 * border_width), -(2 * border_width)};
d33 1
a33 9
+
+    /* Floating windows are never adjacent to any other window, so
+       don't hide their border(s). This prevents bug #998. */
+    if (con_is_floating(con))
+      return result;
+
     if (borders_to_hide & ADJ_LEFT_SCREEN_EDGE) {
         result.x -= border_width;
         result.width += border_width;
@


1.10
log
@Bunch of fixes from upstream:

Fix crash when not having tray_output configured

libi3: mark IPC fd CLOEXEC

Ensure that resize will take place even if pixel is smaller than
size increments

Fix floating window size with hide_edge_borders

render_con: fix height rounding in aspect ratio computation

tabbed: floor(), put extra pixels into the last tab
@
text
@d1 1
a1 1
$OpenBSD$
@


1.9
log
@Update to i3-4.4
@
text
@d1 1
a1 1
$OpenBSD: patch-src_con_c,v 1.8 2012/10/01 08:12:17 dcoppa Exp $
d3 3
a5 4
From 31e8d7f2f81f115f70c1fc3eb404b0cfbc13ddf4 Mon Sep 17 00:00:00 2001
From: Michael Stapelberg <michael@@stapelberg.de>
Date: Fri, 28 Sep 2012 22:02:41 +0000
Subject: Bugfix: Correctly move floating windows to invisible workspaces cross-output
d7 17
a23 26
--- src/con.c.orig	Wed Sep 19 18:08:09 2012
+++ src/con.c	Mon Oct  1 09:44:02 2012
@@@@ -666,13 +666,20 @@@@ void con_move_to_workspace(Con *con, Con *workspace, b
     con->percent = 0.0;
     con_fix_percent(next);
 
-    /* 7: focus the con on the target workspace (the X focus is only updated by
-     * calling tree_render(), so for the "real" focus this is a no-op).
+    /* 7: focus the con on the target workspace, but only within that
+     * workspace, that is, don't move focus away if the target workspace is
+     * invisible.
      * We don’t focus the con for i3 pseudo workspaces like __i3_scratch and
      * we don’t focus when there is a fullscreen con on that workspace. */
     if ((workspace->name[0] != '_' || workspace->name[1] != '_') &&
-        con_get_fullscreen_con(workspace, CF_OUTPUT) == NULL)
+        con_get_fullscreen_con(workspace, CF_OUTPUT) == NULL) {
+        /* We need to save focus on workspace level and restore it afterwards.
+         * Otherwise, we might focus a different workspace without actually
+         * switching workspaces. */
+        Con *old_focus = TAILQ_FIRST(&(output_get_content(dest_output)->focus_head));
         con_focus(con_descend_focused(con));
+        con_focus(old_focus);
+    }
 
     /* 8: when moving to a visible workspace on a different output, we keep the
      * con focused. Otherwise, we leave the focus on the current workspace as we
@


1.8
log
@
Bugfix: don't crash when dragged floating window close

Bugfix: draw h-split indicator at the right position

Bugfix: Correctly move floating windows to invisible workspaces
cross-output

From upstream git
@
text
@d1 1
a1 1
$OpenBSD$
@


1.7
log
@Update to i3-4.1.2
@
text
@d1 1
a1 1
$OpenBSD: patch-src_con_c,v 1.6 2012/01/25 10:29:30 dcoppa Exp $
d3 4
a6 2
Bugfix: fix coordinates when the rect of an output changes
(upstream git commit 077d2433a7186550ee349284b1849ec2048af69c)
d8 4
a11 32
Bugfix: don't lose focus on fullscreen windows when another window
gets moved to that workspace
(upstream git commit f78caf8c5815ae7a66de9e4b734546fd740cc19d)

Bugfix: open new windows in the correct place when assignments match
(upstream git commit d4238c778a199ad88ebe8540904d98f81f110621)

--- src/con.c.orig	Mon Jan 23 09:50:24 2012
+++ src/con.c	Mon Jan 23 09:51:06 2012
@@@@ -613,20 +613,7 @@@@ void con_move_to_workspace(Con *con, Con *workspace, b
         /* Take the relative coordinates of the current output, then add them
          * to the coordinate space of the correct output */
         if (fix_coordinates && con->type == CT_FLOATING_CON) {
-            DLOG("Floating window, fixing coordinates\n");
-            /* First we get the x/y coordinates relative to the x/y coordinates
-             * of the output on which the window is on */
-            uint32_t rel_x = (con->rect.x - source_output->rect.x);
-            uint32_t rel_y = (con->rect.y - source_output->rect.y);
-            /* Then we calculate a fraction, for example 0.63 for a window
-             * which is at y = 1212 of a 1920 px high output */
-            double fraction_x = ((double)rel_x / source_output->rect.width);
-            double fraction_y = ((double)rel_y / source_output->rect.height);
-            DLOG("rel_x = %d, rel_y = %d, fraction_x = %f, fraction_y = %f, output->w = %d, output->h = %d\n",
-                 rel_x, rel_y, fraction_x, fraction_y, source_output->rect.width, source_output->rect.height);
-            con->rect.x = dest_output->rect.x + (fraction_x * dest_output->rect.width);
-            con->rect.y = dest_output->rect.y + (fraction_y * dest_output->rect.height);
-            DLOG("Resulting coordinates: x = %d, y = %d\n", con->rect.x, con->rect.y);
+            floating_fix_coordinates(con, &(source_output->rect), &(dest_output->rect));
         } else DLOG("Not fixing coordinates, fix_coordinates flag = %d\n", fix_coordinates);
 
         /* If moving to a visible workspace, call show so it can be considered
@@@@ -656,8 +643,10 @@@@ void con_move_to_workspace(Con *con, Con *workspace, b
d14 17
a30 7
     /* 7: focus the con on the target workspace (the X focus is only updated by
-     * calling tree_render(), so for the "real" focus this is a no-op). */
-    con_focus(con_descend_focused(con));
+     * calling tree_render(), so for the "real" focus this is a no-op).
+     * We don't focus when there is a fullscreen con on that workspace. */
+    if (con_get_fullscreen_con(workspace, CF_OUTPUT) == NULL)
+        con_focus(con_descend_focused(con));
a33 27
@@@@ -806,7 +795,7 @@@@ Con *con_get_next(Con *con, char way, orientation_t or
  */
 Con *con_descend_focused(Con *con) {
     Con *next = con;
-    while (!TAILQ_EMPTY(&(next->focus_head)))
+    while (next != focused && !TAILQ_EMPTY(&(next->focus_head)))
         next = TAILQ_FIRST(&(next->focus_head));
     return next;
 }
@@@@ -823,6 +812,8 @@@@ Con *con_descend_tiling_focused(Con *con) {
     Con *next = con;
     Con *before;
     Con *child;
+    if (next == focused)
+        return next;
     do {
         before = next;
         TAILQ_FOREACH(child, &(next->focus_head), focused) {
@@@@ -832,7 +823,7 @@@@ Con *con_descend_tiling_focused(Con *con) {
             next = child;
             break;
         }
-    } while (before != next);
+    } while (before != next && next != focused);
     return next;
 }
 
@


1.6
log
@Bugfix: setup the _NET_SUPPORTING_WM_CHECK atom in a standards-compliant
way. This makes chrome (and probably other apps, too) receive changes
of the _NET_ACTIVE_WINDOW and thus show its bookmark dialog properly
(upstream git commit 4f26d6f2a1a0efb7fa15999f9cc00d8673220e97)

Bugfix: only ignore EnterNotify events after UnmapNotifies from
managed windows. This fixes some focus follows mouse problems
(upstream git commit 47fd15649ad63f3becef8870276e51c6214300fc)

Bugfix: force a new sequence number after UnmapNotify. This fixes
the problem where legitimate EnterNotify arrived with the same
sequence as the UnmapNotify and was ignored
(upstream git commit 7a4d8ed6ed67c4d0d958458f58e4db1598c9cd75)

Bugfix: position floating windows exactly where their geometry
specified
(upstream git commit cb4c9b9d27a095047a5ac22ae75f6ee17475ba18)

Bugfix: fix coordinates when the rect of an output changes
(upstream git commit 077d2433a7186550ee349284b1849ec2048af69c)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_con_c,v 1.5 2012/01/20 15:53:18 dcoppa Exp $
@


1.5
log
@Bugfix: respect WM_HINTS.input for WM_TAKE_FOCUS clients. This fixes
problems with some Qt apps
(upstream git commit 2d14ced024416e2074b57290bf7dade7d08899e5)

Bugfix: either use SetInputFocus *or* send WM_TAKE_FOCUS, not both.
This fixes problems with Oracle/OpenJDK JRE 7.0
(upstream git commit 21a2971b2442ab0881cf79553cc6b65bbb44afa7)
@
text
@d1 4
a4 1
$OpenBSD: patch-src_con_c,v 1.4 2012/01/11 13:33:48 dcoppa Exp $
d13 25
a37 3
--- src/con.c.orig	Sat Dec 24 16:25:08 2011
+++ src/con.c	Fri Jan 20 16:32:59 2012
@@@@ -656,8 +656,10 @@@@ void con_move_to_workspace(Con *con, Con *workspace, b
d50 1
a50 1
@@@@ -806,7 +808,7 @@@@ Con *con_get_next(Con *con, char way, orientation_t or
d59 1
a59 1
@@@@ -823,6 +825,8 @@@@ Con *con_descend_tiling_focused(Con *con) {
d68 1
a68 1
@@@@ -832,7 +836,7 @@@@ Con *con_descend_tiling_focused(Con *con) {
@


1.4
log
@
Bugfix: don't lose focus on fullscreen windows when another window
gets moved to that workspace
(upstream git commit f78caf8c5815ae7a66de9e4b734546fd740cc19d)

Bugfix: open new windows in the correct place when assignments match
(upstream git commit d4238c778a199ad88ebe8540904d98f81f110621)

Fix assignments of floating windows to (yet) unused workspaces
(upstream git commit 96c491a4885bf33802e1be883dbf5fe24bece650)
@
text
@d1 1
a1 1
$OpenBSD$
d10 2
a11 2
--- src/con.c.orig	Wed Jan 11 14:13:26 2012
+++ src/con.c	Wed Jan 11 14:17:15 2012
d21 1
a21 1
+    	con_focus(con_descend_focused(con));
d39 1
a39 1
+	return next;
@


1.3
log
@Bugfixing update to i3-4.1.1
@
text
@d1 1
a1 1
$OpenBSD: patch-src_con_c,v 1.2 2011/12/01 16:00:01 dcoppa Exp $
d3 3
a5 2
Bugfix: retain absolute window position and size when changing
floating borders (git commit 970d11709e99aab7db13a2fd28a758a68a4137dc)
d7 2
a8 3
Do not set the _NET_WM_WORKAREA hint: fix incorrect transient
geometry with wxwidgets
(upstream git commit d25e77ce7597bf0736c610a04185c8c27694c890)
d10 40
a49 3
--- src/con.c.orig	Fri Nov 11 23:41:20 2011
+++ src/con.c	Thu Dec  1 14:07:37 2011
@@@@ -942,6 +942,52 @@@@ int con_border_style(Con *con) {
a51 58
 /*
+ * Sets the given border style on con, correctly keeping the position/size of a
+ * floating window.
+ *
+ */
+void con_set_border_style(Con *con, int border_style) {
+    /* Handle the simple case: non-floating containerns */
+    if (!con_is_floating(con)) {
+        con->border_style = border_style;
+        return;
+    }
+
+    /* For floating containers, we want to keep the position/size of the
+     * *window* itself. Since the window size is rendered based on the
+     * container which it is in, we first remove the border/decoration specific
+     * amount of pixels from parent->rect, change the border, then add the new
+     * border/decoration specific pixels. */
+    DLOG("This is a floating container\n");
+
+    /* Get current border/decoration pixel values. */
+    int deco_height =
+        (con->border_style == BS_NORMAL ? config.font.height + 5 : 0);
+    Rect bsr = con_border_style_rect(con);
+    Con *parent = con->parent;
+
+    con->rect.x += bsr.x;
+    con->rect.y += bsr.y;
+    con->rect.width += bsr.width;
+    con->rect.height += bsr.height;
+
+    /* Change the border style, get new border/decoration values. */
+    con->border_style = border_style;
+    bsr = con_border_style_rect(con);
+    deco_height = (con->border_style == BS_NORMAL ? config.font.height + 5 : 0);
+
+    con->rect.x -= bsr.x;
+    con->rect.y -= bsr.y;
+    con->rect.width -= bsr.width;
+    con->rect.height -= bsr.height;
+
+    parent->rect.x = con->rect.x;
+    parent->rect.y = con->rect.y - deco_height;
+    parent->rect.width = con->rect.width;
+    parent->rect.height = con->rect.height + deco_height;
+}
+
+/*
  * This function changes the layout of a given container. Use it to handle
  * special cases like changing a whole workspace to stacked/tabbed (creates a
  * new split container before).
@@@@ -1023,7 +1069,6 @@@@ static void con_on_remove_child(Con *con) {
             LOG("Closing old workspace (%p / %s), it is empty\n", con, con->name);
             tree_close(con, DONT_KILL_WINDOW, false, false);
             ipc_send_event("workspace", I3_IPC_EVENT_WORKSPACE, "{\"change\":\"empty\"}");
-            ewmh_update_workarea();
         }
         return;
     }
@


1.2
log
@Major update to i3-4.1
@
text
@d1 1
a1 1
$OpenBSD: patch-src_con_c,v 1.1 2011/11/06 20:23:25 dcoppa Exp $
@


1.1
log
@Update to i3-4.0.2 (plus patches from upstream git).
i3bar is now part of i3 itself and i3-wsbar is gone.
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
bugfix: don't fix floating coordinates when reassigning - fixes
flickering (upstream git commit 6b541d382b89de18104202e5820f466725d77576)
d6 8
a13 26
bugfix: always adjust floating position when moving to another
output (upstream git commit a5012f60213f29265edfeeaa4574ebeaa61e1ca5)

bugfix: avoid out of bounds coordinates when moving floating windows
(upstream git commit a82f5750ded81dd1789c868f0e8f233c5b79b85a)

bugfix: use con_orientation() - fixes switching between different
outputs (upstream git commit 7a2e92a11646eee8459fc982c0569b4d454c6db9)

bugfix: correctly revert focus to other floating windows when closing
a floating window (git commit 4dbda7311480c231332a9dab9ed23d00abecb7e9)

--- src/con.c.orig	Sun Aug 28 19:48:13 2011
+++ src/con.c	Fri Nov  4 16:05:33 2011
@@@@ -559,7 +559,7 @@@@ update_netwm_state:
  * TODO: is there a better place for this function?
  *
  */
-void con_move_to_workspace(Con *con, Con *workspace, bool dont_warp) {
+void con_move_to_workspace(Con *con, Con *workspace, bool fix_coordinates, bool dont_warp) {
     if (con->type == CT_WORKSPACE) {
         DLOG("Moving workspaces is not yet implemented.\n");
         return;
@@@@ -601,29 +601,39 @@@@ void con_move_to_workspace(Con *con, Con *workspace, b
         next = ws;
     }
d15 56
a70 97
-    /* If moving to a visible workspace, call show so it can be considered
-     * focused. Must do before attaching because workspace_show checks to see
-     * if focused container is in its area. */
-    if (source_output != dest_output &&
-        workspace_is_visible(workspace)) {
-        workspace_show(workspace->name);
-
-        if (con->type == CT_FLOATING_CON) {
+    if (source_output != dest_output) {
+        /* Take the relative coordinates of the current output, then add them
+         * to the coordinate space of the correct output */
+        if (fix_coordinates && con->type == CT_FLOATING_CON) {
             DLOG("Floating window, fixing coordinates\n");
-            /* Take the relative coordinates of the current output, then add them
-             * to the coordinate space of the correct output */
+            /* First we get the x/y coordinates relative to the x/y coordinates
+             * of the output on which the window is on */
             uint32_t rel_x = (con->rect.x - source_output->rect.x);
             uint32_t rel_y = (con->rect.y - source_output->rect.y);
-            con->rect.x = dest_output->rect.x + rel_x;
-            con->rect.y = dest_output->rect.y + rel_y;
-        }
+            /* Then we calculate a fraction, for example 0.63 for a window
+             * which is at y = 1212 of a 1920 px high output */
+            double fraction_x = ((double)rel_x / source_output->rect.width);
+            double fraction_y = ((double)rel_y / source_output->rect.height);
+            DLOG("rel_x = %d, rel_y = %d, fraction_x = %f, fraction_y = %f, output->w = %d, output->h = %d\n",
+                 rel_x, rel_y, fraction_x, fraction_y, source_output->rect.width, source_output->rect.height);
+            con->rect.x = dest_output->rect.x + (fraction_x * dest_output->rect.width);
+            con->rect.y = dest_output->rect.y + (fraction_y * dest_output->rect.height);
+            DLOG("Resulting coordinates: x = %d, y = %d\n", con->rect.x, con->rect.y);
+        } else DLOG("Not fixing coordinates, fix_coordinates flag = %d\n", fix_coordinates);
 
-        /* Don’t warp if told so (when dragging floating windows with the
-         * mouse for example) */
-        if (dont_warp)
-            x_set_warp_to(NULL);
-        else
-            x_set_warp_to(&(con->rect));
+        /* If moving to a visible workspace, call show so it can be considered
+         * focused. Must do before attaching because workspace_show checks to see
+         * if focused container is in its area. */
+        if (workspace_is_visible(workspace)) {
+            workspace_show(workspace->name);
+
+            /* Don’t warp if told so (when dragging floating windows with the
+             * mouse for example) */
+            if (dont_warp)
+                x_set_warp_to(NULL);
+            else
+                x_set_warp_to(&(con->rect));
+        }
     }
 
     DLOG("Re-attaching container to %p / %s\n", next, next->name);
@@@@ -827,15 +837,16 @@@@ Con *con_descend_tiling_focused(Con *con) {
  */
 Con *con_descend_direction(Con *con, direction_t direction) {
     Con *most = NULL;
-    DLOG("con_descend_direction(%p, %d)\n", con, direction);
+    int orientation = con_orientation(con);
+    DLOG("con_descend_direction(%p, orientation %d, direction %d)\n", con, orientation, direction);
     if (direction == D_LEFT || direction == D_RIGHT) {
-        if (con->orientation == HORIZ) {
+        if (orientation == HORIZ) {
             /* If the direction is horizontal, we can use either the first
              * (D_RIGHT) or the last con (D_LEFT) */
             if (direction == D_RIGHT)
                 most = TAILQ_FIRST(&(con->nodes_head));
             else most = TAILQ_LAST(&(con->nodes_head), nodes_head);
-        } else if (con->orientation == VERT) {
+        } else if (orientation == VERT) {
             /* Wrong orientation. We use the last focused con. Within that con,
              * we recurse to chose the left/right con or at least the last
              * focused one. */
@@@@ -848,13 +859,13 @@@@ Con *con_descend_direction(Con *con, direction_t direc
     }
 
     if (direction == D_UP || direction == D_DOWN) {
-        if (con->orientation == VERT) {
+        if (orientation == VERT) {
             /* If the direction is vertical, we can use either the first
              * (D_DOWN) or the last con (D_UP) */
             if (direction == D_UP)
                 most = TAILQ_LAST(&(con->nodes_head), nodes_head);
             else most = TAILQ_FIRST(&(con->nodes_head));
-        } else if (con->orientation == HORIZ) {
+        } else if (orientation == HORIZ) {
             /* Wrong orientation. We use the last focused con. Within that con,
              * we recurse to chose the top/bottom con or at least the last
              * focused one. */
@@@@ -1003,7 +1014,7 @@@@ static void con_on_remove_child(Con *con) {
     int children = con_num_children(con);
     if (children == 0) {
         DLOG("Container empty, closing\n");
-        tree_close(con, DONT_KILL_WINDOW, false);
+        tree_close(con, DONT_KILL_WINDOW, false, false);
a72 1
 }
@

