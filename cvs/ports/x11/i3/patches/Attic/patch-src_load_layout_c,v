head	1.3;
access;
symbols
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2015.03.17.15.39.48;	author dcoppa;	state dead;
branches;
next	1.2;
commitid	WQl7M1uD6B2NjHh4;

1.2
date	2015.02.02.17.24.26;	author dcoppa;	state Exp;
branches;
next	1.1;
commitid	ZdENL2eYRnS1hhZu;

1.1
date	2014.08.18.08.46.27;	author dcoppa;	state Exp;
branches;
next	;
commitid	Bi02IjLxhs8ESxGu;


desc
@@


1.3
log
@
Update to i3-4.9.1

new dependency on x11/xkbcommon
@
text
@$OpenBSD: patch-src_load_layout_c,v 1.2 2015/02/02 17:24:26 dcoppa Exp $

commit 679a5de8cfb9211afb1a1dd882e53bd672084754
Author: Michael Stapelberg <michael@@stapelberg.de>
Date:   Tue Jul 15 10:15:04 2014 +0200

Bugfix: properly restore workspace containers

commit 55b5f491a469ccf47c7fdc66f3f0df86ef2e1f64
Author: Michael Stapelberg <michael@@stapelberg.de>
Date:   Sat Jan 31 22:40:55 2015 +0100

Bugfix: correctly restore workspaces regardless of where "type" is

--- src/load_layout.c.orig	Sun Jun 15 12:12:43 2014
+++ src/load_layout.c	Mon Feb  2 11:05:28 2015
@@@@ -52,11 +52,13 @@@@ static int json_start_map(void *ctx) {
                 DLOG("New floating_node\n");
                 Con *ws = con_get_workspace(json_node);
                 json_node = con_new_skeleton(NULL, NULL);
+                json_node->name = NULL;
                 json_node->parent = ws;
                 DLOG("Parent is workspace = %p\n", ws);
             } else {
                 Con *parent = json_node;
                 json_node = con_new_skeleton(NULL, NULL);
+                json_node->name = NULL;
                 json_node->parent = parent;
             }
         }
@@@@ -84,6 +86,40 @@@@ static int json_end_map(void *ctx) {
             }
         }
 
+        if (json_node->type == CT_WORKSPACE) {
+            /* Ensure the workspace has a name. */
+            DLOG("Attaching workspace. name = %s\n", json_node->name);
+            if (json_node->name == NULL || strcmp(json_node->name, "") == 0) {
+                json_node->name = sstrdup("unnamed");
+            }
+
+            /* Prevent name clashes when appending a workspace, e.g. when the
+             * user tries to restore a workspace called "1" but already has a
+             * workspace called "1". */
+            Con *output;
+            Con *workspace = NULL;
+            TAILQ_FOREACH (output, &(croot->nodes_head), nodes)
+                GREP_FIRST(workspace, output_get_content(output), !strcasecmp(child->name, json_node->name));
+            char *base = sstrdup(json_node->name);
+            int cnt = 1;
+            while (workspace != NULL) {
+                FREE(json_node->name);
+                asprintf(&(json_node->name), "%s_%d", base, cnt++);
+                workspace = NULL;
+                TAILQ_FOREACH (output, &(croot->nodes_head), nodes)
+                    GREP_FIRST(workspace, output_get_content(output), !strcasecmp(child->name, json_node->name));
+            }
+            free(base);
+
+            /* Set num accordingly so that i3bar will properly sort it. */
+            json_node->num = ws_name_to_number(json_node->name);
+        } else {
+            // TODO: remove this in the "next" branch.
+            if (json_node->name == NULL || strcmp(json_node->name, "") == 0) {
+                json_node->name = sstrdup("#ff0000");
+            }
+        }
+
         LOG("attaching\n");
         con_attach(json_node, json_node->parent, true);
         LOG("Creating window\n");
@@@@ -390,26 +426,110 @@@@ static int json_double(void *ctx, double val) {
     return 1;
 }
 
+static json_content_t content_result;
+static int content_level;
+
+static int json_determine_content_deeper(void *ctx) {
+    content_level++;
+    return 1;
+}
+
+static int json_determine_content_shallower(void *ctx) {
+    content_level--;
+    return 1;
+}
+
+static int json_determine_content_string(void *ctx, const unsigned char *val, size_t len) {
+    if (strcasecmp(last_key, "type") != 0 || content_level > 1)
+        return 1;
+
+    DLOG("string = %.*s, last_key = %s\n", (int)len, val, last_key);
+    if (strncasecmp((const char *)val, "workspace", len) == 0)
+        content_result = JSON_CONTENT_WORKSPACE;
+    return 0;
+}
+
+/* Parses the given JSON file until it encounters the first "type" property to
+ * determine whether the file contains workspaces or regular containers, which
+ * is important to know when deciding where (and how) to append the contents.
+ * */
+json_content_t json_determine_content(const char *filename) {
+    FILE *f;
+    if ((f = fopen(filename, "r")) == NULL) {
+        ELOG("Cannot open file \"%s\"\n", filename);
+        return JSON_CONTENT_UNKNOWN;
+    }
+    struct stat stbuf;
+    if (fstat(fileno(f), &stbuf) != 0) {
+        ELOG("Cannot fstat() \"%s\"\n", filename);
+        fclose(f);
+        return JSON_CONTENT_UNKNOWN;
+    }
+    char *buf = smalloc(stbuf.st_size);
+    int n = fread(buf, 1, stbuf.st_size, f);
+    if (n != stbuf.st_size) {
+        ELOG("File \"%s\" could not be read entirely, not loading.\n", filename);
+        fclose(f);
+        return JSON_CONTENT_UNKNOWN;
+    }
+    DLOG("read %d bytes\n", n);
+    // We default to JSON_CONTENT_CON because it is legal to not include
+    // ""type": "con"" in the JSON files for better readability.
+    content_result = JSON_CONTENT_CON;
+    content_level = 0;
+    yajl_gen g;
+    yajl_handle hand;
+    static yajl_callbacks callbacks = {
+        .yajl_string = json_determine_content_string,
+        .yajl_map_key = json_key,
+        .yajl_start_array = json_determine_content_deeper,
+        .yajl_start_map = json_determine_content_deeper,
+        .yajl_end_map = json_determine_content_shallower,
+        .yajl_end_array = json_determine_content_shallower,
+    };
+    g = yajl_gen_alloc(NULL);
+    hand = yajl_alloc(&callbacks, NULL, (void *)g);
+    /* Allowing comments allows for more user-friendly layout files. */
+    yajl_config(hand, yajl_allow_comments, true);
+    /* Allow multiple values, i.e. multiple nodes to attach */
+    yajl_config(hand, yajl_allow_multiple_values, true);
+    yajl_status stat;
+    setlocale(LC_NUMERIC, "C");
+    stat = yajl_parse(hand, (const unsigned char *)buf, n);
+    if (stat != yajl_status_ok && stat != yajl_status_client_canceled) {
+        unsigned char *str = yajl_get_error(hand, 1, (const unsigned char *)buf, n);
+        ELOG("JSON parsing error: %s\n", str);
+        yajl_free_error(hand, str);
+    }
+
+    setlocale(LC_NUMERIC, "");
+    yajl_complete_parse(hand);
+
+    fclose(f);
+
+    return content_result;
+}
+
 void tree_append_json(Con *con, const char *filename, char **errormsg) {
     FILE *f;
     if ((f = fopen(filename, "r")) == NULL) {
-        LOG("Cannot open file \"%s\"\n", filename);
+        ELOG("Cannot open file \"%s\"\n", filename);
         return;
     }
     struct stat stbuf;
     if (fstat(fileno(f), &stbuf) != 0) {
-        LOG("Cannot fstat() the file\n");
+        ELOG("Cannot fstat() \"%s\"\n", filename);
         fclose(f);
         return;
     }
     char *buf = smalloc(stbuf.st_size);
     int n = fread(buf, 1, stbuf.st_size, f);
     if (n != stbuf.st_size) {
-        LOG("File \"%s\" could not be read entirely, not loading.\n", filename);
+        ELOG("File \"%s\" could not be read entirely, not loading.\n", filename);
         fclose(f);
         return;
     }
-    LOG("read %d bytes\n", n);
+    DLOG("read %d bytes\n", n);
     yajl_gen g;
     yajl_handle hand;
     static yajl_callbacks callbacks = {
@


1.2
log
@
Merge fixes from upstream:

Bugfix: correctly restore workspaces regardless of where "type" is
(git commit 55b5f491a469ccf47c7fdc66f3f0df86ef2e1f64)

Bugfix: actually parse client.placeholder
(git commit 13220e75d87991508ee1c30d9a797d42b131dc21)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_load_layout_c,v 1.1 2014/08/18 08:46:27 dcoppa Exp $
@


1.1
log
@
Fixes from upstream:

Bugfix: properly restore workspace containers
(upstream git commit 679a5de8cfb9211afb1a1dd882e53bd672084754)

Bugfix: missed case for decoration rerender
(upstream git commit 56c284af8e281d9d5657e55b3edb7f7c673fc747)

Bugfix: add a sync call to i3bar to confirm reparents before exiting
(upstream git commit 4699c714b33afb1c264f3d19911b880267165b94)

Bugfix: don't set focus in con_set_layout() on invisible workspaces
(upstream git commit fc886315342b3a2292ad0c08394b6bb452663bb1)
@
text
@d1 1
a1 1
$OpenBSD$
d9 8
a16 2
--- src/load_layout.c.orig	Sun Jun 15 19:12:43 2014
+++ src/load_layout.c	Mon Aug 18 08:25:05 2014
d72 1
a72 1
@@@@ -390,26 +426,94 @@@@ static int json_double(void *ctx, double val) {
d77 11
d90 1
a90 1
+    if (strcasecmp(last_key, "type") != 0)
d126 1
d132 4
@

