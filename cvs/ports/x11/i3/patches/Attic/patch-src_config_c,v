head	1.15;
access;
symbols
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	landry_20090902:1.1.1.1
	bapt:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2015.10.04.08.48.12;	author dcoppa;	state dead;
branches;
next	1.14;
commitid	VRvZAaOZt8xtMVjt;

1.14
date	2015.03.17.15.39.47;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	WQl7M1uD6B2NjHh4;

1.13
date	2014.07.11.15.49.58;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	dpkYaZL7eWFGPiTd;

1.12
date	2013.08.13.10.01.56;	author dcoppa;	state Exp;
branches;
next	1.11;

1.11
date	2013.05.16.18.42.30;	author dcoppa;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.25.10.34.02;	author dcoppa;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.13.12.10.13;	author dcoppa;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.21.17.16.14;	author dcoppa;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.27.09.05.17;	author dcoppa;	state Exp;
branches;
next	1.6;

1.6
date	2011.12.01.16.00.01;	author dcoppa;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.06.20.23.25;	author dcoppa;	state Exp;
branches;
next	1.4;

1.4
date	2011.03.14.12.55.18;	author dcoppa;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.14.08.54.18;	author dcoppa;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.28.22.51.26;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.02.19.26.17;	author landry;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.09.02.19.26.17;	author landry;	state Exp;
branches;
next	;


desc
@@


1.15
log
@
Update to i3-4.11
@
text
@$OpenBSD: patch-src_config_c,v 1.14 2015/03/17 15:39:47 dcoppa Exp $
--- src/config.c.orig	Wed Feb 25 01:50:09 2015
+++ src/config.c	Wed Feb 25 02:16:28 2015
@@@@ -85,7 +85,7 @@@@ static char *get_config_path(const char *override_conf
 
     /* 4: check for $XDG_CONFIG_DIRS/i3/config */
     if ((xdg_config_dirs = getenv("XDG_CONFIG_DIRS")) == NULL)
-        xdg_config_dirs = "/etc/xdg";
+        xdg_config_dirs = "${SYSCONFDIR}/xdg";
 
     char *buf = sstrdup(xdg_config_dirs);
     char *tok = strtok(buf, ":");
@


1.14
log
@
Update to i3-4.9.1

new dependency on x11/xkbcommon
@
text
@d1 1
a1 1
$OpenBSD: patch-src_config_c,v 1.13 2014/07/11 15:49:58 dcoppa Exp $
@


1.13
log
@
Update to i3-4.8 plus fixes.

Initial diff by Theo Buehler <theo AT math DOT ethz DOT ch>
@
text
@d1 4
a4 4
$OpenBSD: patch-src_config_c,v 1.12 2013/08/13 10:01:56 dcoppa Exp $
--- src/config.c.orig	Sun Jun 15 19:12:43 2014
+++ src/config.c	Thu Jul  3 21:06:32 2014
@@@@ -87,7 +87,7 @@@@ static char *get_config_path(const char *override_conf
@


1.12
log
@Update to i3-4.6

ok tobiasu@@, abieber@@
@
text
@d1 4
a4 4
$OpenBSD: patch-src_config_c,v 1.11 2013/05/16 18:42:30 dcoppa Exp $
--- src/config.c.orig	Wed Aug  7 20:50:24 2013
+++ src/config.c	Mon Aug 12 15:19:02 2013
@@@@ -299,7 +299,7 @@@@ static char *get_config_path(const char *override_conf
@


1.11
log
@Update to i3-4.5.1

ok jasper@@, abieber@@
@
text
@d1 4
a4 4
$OpenBSD: patch-src_config_c,v 1.10 2013/01/25 10:34:02 dcoppa Exp $
--- src/config.c.orig	Mon Mar 18 22:43:36 2013
+++ src/config.c	Mon May 13 08:27:23 2013
@@@@ -256,7 +256,7 @@@@ static char *get_config_path(const char *override_conf
@


1.10
log
@Bugfix: fix overlapping --release key bindings
(upstream git commit 2eb4ed95bcd5f039014db51eb56f0ac411401fa5)

See: http://bugs.i3wm.org/report/ticket/915
@
text
@d1 4
a4 77
$OpenBSD: patch-src_config_c,v 1.9 2012/12/13 12:10:13 dcoppa Exp $

From 2eb4ed95bcd5f039014db51eb56f0ac411401fa5 Mon Sep 17 00:00:00 2001
From: Michael Stapelberg <michael@@stapelberg.de>
Date: Thu, 24 Jan 2013 13:44:01 +0000
Subject: Bugfix: fix "overlapping" --release key bindings (Thanks phlux)

--- src/config.c.orig	Wed Dec 12 00:08:17 2012
+++ src/config.c	Fri Jan 25 07:41:46 2013
@@@@ -31,7 +31,7 @@@@ void ungrab_all_keys(xcb_connection_t *conn) {
 }
 
 static void grab_keycode_for_binding(xcb_connection_t *conn, Binding *bind, uint32_t keycode) {
-    DLOG("Grabbing %d\n", keycode);
+    DLOG("Grabbing %d with modifiers %d (with mod_mask_lock %d)\n", keycode, bind->mods, bind->mods | XCB_MOD_MASK_LOCK);
     /* Grab the key in all combinations */
     #define GRAB_KEY(modifier) \
         do { \
@@@@ -65,14 +65,6 @@@@ Binding *get_binding(uint16_t modifiers, bool key_rele
             if (bind->release == B_UPON_KEYRELEASE_IGNORE_MODS)
                 bind->release = B_UPON_KEYRELEASE;
         }
-
-        /* Then we transition the KeyRelease bindings into a state where the
-         * modifiers no longer matter for the KeyRelease event so that users
-         * can release the modifier key before releasing the actual key. */
-        TAILQ_FOREACH(bind, bindings, bindings) {
-            if (bind->release == B_UPON_KEYRELEASE && !key_release)
-                bind->release = B_UPON_KEYRELEASE_IGNORE_MODS;
-        }
     }
 
     TAILQ_FOREACH(bind, bindings, bindings) {
@@@@ -84,23 +76,33 @@@@ Binding *get_binding(uint16_t modifiers, bool key_rele
              !key_release))
             continue;
 
-        /* Check if the binding is for a KeyPress or a KeyRelease event */
-        if ((bind->release == B_UPON_KEYPRESS && key_release) ||
-            (bind->release >= B_UPON_KEYRELEASE && !key_release))
-            continue;
-
         /* If a symbol was specified by the user, we need to look in
          * the array of translated keycodes for the eventâ€™s keycode */
         if (bind->symbol != NULL) {
             if (memmem(bind->translated_to,
                        bind->number_keycodes * sizeof(xcb_keycode_t),
-                       &keycode, sizeof(xcb_keycode_t)) != NULL)
-                break;
+                       &keycode, sizeof(xcb_keycode_t)) == NULL)
+                continue;
         } else {
             /* This case is easier: The user specified a keycode */
-            if (bind->keycode == keycode)
-                break;
+            if (bind->keycode != keycode)
+                continue;
         }
+
+        /* If this keybinding is a KeyRelease binding, it matches the key which
+         * the user pressed. We therefore mark it as
+         * B_UPON_KEYRELEASE_IGNORE_MODS for later, so that the user can
+         * release the modifiers before the actual key and the KeyRelease will
+         * still be matched. */
+        if (bind->release == B_UPON_KEYRELEASE && !key_release)
+            bind->release = B_UPON_KEYRELEASE_IGNORE_MODS;
+
+        /* Check if the binding is for a KeyPress or a KeyRelease event */
+        if ((bind->release == B_UPON_KEYPRESS && key_release) ||
+            (bind->release >= B_UPON_KEYRELEASE && !key_release))
+            continue;
+
+        break;
     }
 
     return (bind == TAILQ_END(bindings) ? NULL : bind);
@@@@ -254,7 +256,7 @@@@ static char *get_config_path(const char *override_conf
@


1.9
log
@Update to i3-4.4
@
text
@d1 7
a7 1
$OpenBSD: patch-src_config_c,v 1.8 2012/09/21 17:16:14 dcoppa Exp $
d9 69
a77 2
+++ src/config.c	Thu Dec 13 09:45:54 2012
@@@@ -254,7 +254,7 @@@@ static char *get_config_path(const char *override_conf
@


1.8
log
@Update to i3-4.3

OK jasper@@
@
text
@d1 4
a4 4
$OpenBSD: patch-src_config_c,v 1.7 2011/12/27 09:05:17 dcoppa Exp $
--- src/config.c.orig	Wed Sep 19 18:08:09 2012
+++ src/config.c	Thu Sep 20 14:12:10 2012
@@@@ -246,7 +246,7 @@@@ static char *get_config_path(const char *override_conf
@


1.7
log
@Bugfixing update to i3-4.1.1
@
text
@d1 4
a4 4
$OpenBSD: patch-src_config_c,v 1.6 2011/12/01 16:00:01 dcoppa Exp $
--- src/config.c.orig	Sat Dec 24 16:25:08 2011
+++ src/config.c	Tue Dec 27 09:24:53 2011
@@@@ -218,7 +218,7 @@@@ static char *get_config_path(const char *override_conf
@


1.6
log
@Major update to i3-4.1
@
text
@d1 4
a4 4
$OpenBSD: patch-src_config_c,v 1.5 2011/11/06 20:23:25 dcoppa Exp $
--- src/config.c.orig	Wed Nov 30 16:44:46 2011
+++ src/config.c	Wed Nov 30 16:45:07 2011
@@@@ -210,7 +210,7 @@@@ static char *get_config_path(const char *override_conf
@


1.5
log
@Update to i3-4.0.2 (plus patches from upstream git).
i3bar is now part of i3 itself and i3-wsbar is gone.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_config_c,v 1.4 2011/03/14 12:55:18 dcoppa Exp $
--- src/config.c.orig	Wed Sep 14 12:11:00 2011
+++ src/config.c	Wed Sep 14 12:11:48 2011
@@@@ -215,7 +215,7 @@@@ static char *get_config_path(const char *override_conf
@


1.4
log
@Update to i3-3.e-bf2 (aka i3-3.5.2)
@
text
@d1 9
a9 9
$OpenBSD: patch-src_config_c,v 1.3 2010/09/14 08:54:18 dcoppa Exp $
--- src/config.c.orig	Wed Jan 19 21:26:37 2011
+++ src/config.c	Thu Mar 10 14:23:42 2011
@@@@ -18,7 +18,6 @@@@
 #include <sys/types.h>
 #include <stdlib.h>
 #include <glob.h>
-#include <wordexp.h>
 #include <unistd.h>
d11 2
a12 94
 /* We need Xlib for XStringToKeysym */
@@@@ -39,27 +38,34 @@@@ struct modes_head modes;
 
 /*
  * This function resolves ~ in pathnames.
+ * It may resolve wildcards in the first part of the path, but if no match
+ * or multiple matches are found, it just returns a copy of path as given.
  *
  */
-char *glob_path(const char *path) {
+char *resolve_tilde(const char *path) {
         static glob_t globbuf;
-        if (glob(path, GLOB_NOCHECK | GLOB_TILDE, NULL, &globbuf) < 0)
+        char *head, *tail, *result;
+
+	tail = strchr(path, '/');
+	head = strndup(path, tail ? tail - path : strlen(path));
+
+	int res = glob(head, GLOB_TILDE, NULL, &globbuf);
+	free(head);
+	/* no match, or many wildcard matches are bad */
+	if(res == GLOB_NOMATCH || globbuf.gl_pathc != 1)
+		result = strdup(path);
+	else if (res != 0) {
                 die("glob() failed");
-        char *result = sstrdup(globbuf.gl_pathc > 0 ? globbuf.gl_pathv[0] : path);
+                    result = NULL; /* don't complain about uninitialized */
+	}
+	else {
+		head = globbuf.gl_pathv[0];
+		result = malloc(strlen(head) + (tail ? strlen(tail) : 0) + 1);
+		strncpy(result, head, strlen(head)+1);
+		strncat(result, tail, strlen(tail));
+	}
         globfree(&globbuf);
 
-        /* If the file does not exist yet, we still may need to resolve tilde,
-         * so call wordexp */
-        if (strcmp(result, path) == 0) {
-                wordexp_t we;
-                wordexp(path, &we, WRDE_NOCMD);
-                if (we.we_wordc > 0) {
-                        free(result);
-                        result = sstrdup(we.we_wordv[0]);
-                }
-                wordfree(&we);
-        }
-
         return result;
 }
 
@@@@ -239,7 +245,7 @@@@ static char *get_config_path() {
         if ((xdg_config_home = getenv("XDG_CONFIG_HOME")) == NULL)
                 xdg_config_home = "~/.config";
 
-        xdg_config_home = glob_path(xdg_config_home);
+        xdg_config_home = resolve_tilde(xdg_config_home);
         if (asprintf(&config_path, "%s/i3/config", xdg_config_home) == -1)
                 die("asprintf() failed");
         free(xdg_config_home);
@@@@ -250,12 +256,12 @@@@ static char *get_config_path() {
 
         /* 2: check for $XDG_CONFIG_DIRS/i3/config */
         if ((xdg_config_dirs = getenv("XDG_CONFIG_DIRS")) == NULL)
-                xdg_config_dirs = "/etc/xdg";
+                xdg_config_dirs = "${SYSCONFDIR}/xdg";
 
         char *buf = sstrdup(xdg_config_dirs);
         char *tok = strtok(buf, ":");
         while (tok != NULL) {
-                tok = glob_path(tok);
+                tok = resolve_tilde(tok);
                 if (asprintf(&config_path, "%s/i3/config", tok) == -1)
                         die("asprintf() failed");
                 free(tok);
@@@@ -269,15 +275,15 @@@@ static char *get_config_path() {
         free(buf);
 
         /* 3: check traditional paths */
-        config_path = glob_path("~/.i3/config");
+        config_path = resolve_tilde("~/.i3/config");
         if (path_exists(config_path))
                 return config_path;
 
-        config_path = sstrdup("/etc/i3/config");
+        config_path = sstrdup("${SYSCONFDIR}/i3/config");
         if (!path_exists(config_path))
                 die("Neither $XDG_CONFIG_HOME/i3/config, nor "
                     "$XDG_CONFIG_DIRS/i3/config, nor ~/.i3/config nor "
-                    "/etc/i3/config exist.");
+                    "${SYSCONFDIR}/i3/config exist.");
 
         return config_path;
 }
@


1.3
log
@Update to i3-3.5.1

resolve_tilde() function by Christopher Zimmermann
(madroach AT zakweb DOT de): thanks!

OK landry@@
@
text
@d1 3
a3 3
$OpenBSD$
--- src/config.c.orig	Wed Jun  9 09:58:15 2010
+++ src/config.c	Mon Aug  2 08:20:48 2010
d26 2
a27 2
+        tail = strchr(path, '/');
+        head = strndup(path, tail ? tail - path : strlen(path));
d29 6
a34 6
+        int res = glob(head, GLOB_TILDE, NULL, &globbuf);
+        free(head);
+        /* no match, or many wildcard matches are bad */
+        if(res == GLOB_NOMATCH || globbuf.gl_pathc != 1)
+                result = strdup(path);
+        else if (res != 0) {
d38 7
a44 7
+        }
+        else {
+                head = globbuf.gl_pathv[0];
+                result = malloc(strlen(head) + (tail ? strlen(tail) : 0) + 1);
+                strncpy(result, head, strlen(head)+1);
+                strncat(result, tail, strlen(tail));
+        }
d78 1
a78 1
         char *buf = strdup(xdg_config_dirs);
d95 2
a96 2
-        config_path = strdup("/etc/i3/config");
+        config_path = strdup("${SYSCONFDIR}/i3/config");
@


1.2
log
@We have strlen(3) and strndup(3) now.
Set NO_REGRESS while here.
@
text
@d1 104
a104 14
$OpenBSD: patch-src_config_c,v 1.1.1.1 2009/09/02 19:26:17 landry Exp $
--- src/config.c.orig	Wed Aug 19 14:39:09 2009
+++ src/config.c	Mon Aug 31 20:30:32 2009
@@@@ -226,8 +226,8 @@@@ void load_configuration(xcb_connection_t *conn, const 
                 /* We first check for ~/.i3/config, then for /etc/i3/config */
                 char *globbed = glob_path("~/.i3/config");
                 if ((handle = fopen(globbed, "r")) == NULL)
-                        if ((handle = fopen("/etc/i3/config", "r")) == NULL)
-                                die("Neither \"%s\" nor /etc/i3/config could be opened\n", globbed);
+                        if ((handle = fopen("${SYSCONFDIR}/i3/config", "r")) == NULL)
+                                die("Neither \"%s\" nor ${SYSCONFDIR}/i3/config could be opened\n", globbed);
                 free(globbed);
         }
         char key[512], value[512], buffer[1026];
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
a14 19
@@@@ -312,7 +312,17 @@@@ void load_configuration(xcb_connection_t *conn, const 
                                         rest++;
                                 if (*rest != ' ')
                                         die("Invalid binding (keysym)\n");
-                                new->symbol = strndup(sym, (rest - sym));
+#if defined(__OpenBSD__)
+                               size_t len = strlen(sym);
+                               if( len > (rest - sym))
+                                       len = (rest - sym);
+                               new->symbol = malloc(len + 1);
+                               memcpy(new->symbol,sym,len+1);
+                               new->symbol[len]='\0';
+#else
+                                 new->symbol = strndup(sym, (rest - sym));
+#endif
+
                         }
                         rest++;
                         LOG("keycode = %d, symbol = %s, modifiers = %d, command = *%s*\n", new->keycode, new->symbol, modifiers, rest);
@


1.1.1.1
log
@Import (really, this time) i3 3.c, from MAINTAINER Baptiste Daroussin,
with tweaks by me.

i3 is an improved dynamic, tiling window manager.

note: It is still young, so some debug options are still enable by
default, and it's a bit verbose.

ok ajacoutot@@
@
text
@@
