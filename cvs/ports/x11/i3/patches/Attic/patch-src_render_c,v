head	1.8;
access;
symbols
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3;
locks; strict;
comment	@# @;


1.8
date	2015.03.17.15.39.48;	author dcoppa;	state dead;
branches;
next	1.7;
commitid	WQl7M1uD6B2NjHh4;

1.7
date	2015.01.18.19.45.44;	author dcoppa;	state Exp;
branches;
next	1.6;
commitid	09fCII5FmVhKkYaF;

1.6
date	2014.01.11.16.04.43;	author dcoppa;	state dead;
branches;
next	1.5;

1.5
date	2013.09.02.06.15.34;	author dcoppa;	state Exp;
branches;
next	1.4;

1.4
date	2013.08.13.10.01.57;	author dcoppa;	state dead;
branches;
next	1.3;

1.3
date	2013.05.17.10.21.42;	author dcoppa;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.27.09.05.17;	author dcoppa;	state dead;
branches;
next	1.1;

1.1
date	2011.12.01.16.00.01;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.8
log
@
Update to i3-4.9.1

new dependency on x11/xkbcommon
@
text
@$OpenBSD: patch-src_render_c,v 1.7 2015/01/18 19:45:44 dcoppa Exp $

commit 8b96bb0298fd9555a7c87d807651c0094c469e76
Author: Michael Stapelberg <michael@@stapelberg.de>
Date:   Sat Jan 17 18:19:15 2015 +0100

Bugfix: render floating windows during global fullscreen

--- src/render.c.orig	Sun Jun 15 12:12:43 2014
+++ src/render.c	Sun Jan 18 13:40:17 2015
@@@@ -210,7 +210,15 @@@@ void render_con(Con *con, bool render_fullscreen) {
         fullscreen->rect = rect;
         x_raise_con(fullscreen);
         render_con(fullscreen, true);
-        return;
+        /* Fullscreen containers are either global (underneath the CT_ROOT
+         * container) or per-output (underneath the CT_CONTENT container). For
+         * global fullscreen containers, we cannot abort rendering here yet,
+         * because the floating windows (with popup_during_fullscreen smart)
+         * have not yet been rendered (see the CT_ROOT code path below). See
+         * also http://bugs.i3wm.org/1393 */
+        if (con->type != CT_ROOT) {
+            return;
+        }
     }
 
     /* find the height for the decorations */
@@@@ -247,8 +255,10 @@@@ void render_con(Con *con, bool render_fullscreen) {
         render_l_output(con);
     } else if (con->type == CT_ROOT) {
         Con *output;
-        TAILQ_FOREACH (output, &(con->nodes_head), nodes) {
-            render_con(output, false);
+        if (!fullscreen) {
+            TAILQ_FOREACH (output, &(con->nodes_head), nodes) {
+                render_con(output, false);
+            }
         }
 
         /* We need to render floating windows after rendering all outputs’
@


1.7
log
@
Bugfix: render floating windows during global fullscreen
(upstream git commit 8b96bb0298fd9555a7c87d807651c0094c469e76)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.6
log
@Update to i3-4.7
@
text
@d1 1
a1 1
$OpenBSD: patch-src_render_c,v 1.5 2013/09/02 06:15:34 dcoppa Exp $
d3 1
a3 1
commit 103ab83131d30614ea9337e752548a834773bfc6
d5 1
a5 1
Date:   Tue Aug 27 20:21:11 2013 +0200
d7 1
a7 1
Revert "raise fullscreen windows on top of all other X11 windows"
d9 5
a13 14
This reverts commit 0659a0d98ca98fcd134c277c6a61ca3c9a04544e.

It was a fix for dzen2 setups, but broke several other use cases.
Because dzen2 is not really important since most people use i3bar
nowadays, let's revert this.

--- src/render.c.orig	Wed Aug  7 20:50:24 2013
+++ src/render.c	Mon Sep  2 07:42:58 2013
@@@@ -70,7 +70,7 @@@@ static void render_l_output(Con *con) {
     Con *fullscreen = con_get_fullscreen_con(ws, CF_OUTPUT);
     if (fullscreen) {
         fullscreen->rect = con->rect;
-        x_raise_con(fullscreen, true);
+        x_raise_con(fullscreen);
d15 10
a24 1
         return;
a25 1
@@@@ -110,7 +110,7 @@@@ static void render_l_output(Con *con) {
d27 11
a37 24
         DLOG("child at (%d, %d) with (%d x %d)\n",
                 child->rect.x, child->rect.y, child->rect.width, child->rect.height);
-        x_raise_con(child, false);
+        x_raise_con(child);
         render_con(child, false);
     }
 }
@@@@ -208,7 +208,7 @@@@ void render_con(Con *con, bool render_fullscreen) {
     }
     if (fullscreen) {
         fullscreen->rect = rect;
-        x_raise_con(fullscreen, false);
+        x_raise_con(fullscreen);
         render_con(fullscreen, true);
         return;
     }
@@@@ -299,7 +299,7 @@@@ void render_con(Con *con, bool render_fullscreen) {
                 }
                 DLOG("floating child at (%d,%d) with %d x %d\n",
                      child->rect.x, child->rect.y, child->rect.width, child->rect.height);
-                x_raise_con(child, false);
+                x_raise_con(child);
                 render_con(child, false);
             }
a38 1
@@@@ -408,7 +408,7 @@@@ void render_con(Con *con, bool render_fullscreen) {
d40 1
a40 25
         DLOG("child at (%d, %d) with (%d x %d)\n",
                 child->rect.x, child->rect.y, child->rect.width, child->rect.height);
-        x_raise_con(child, false);
+        x_raise_con(child);
         render_con(child, false);
         i++;
     }
@@@@ -416,7 +416,7 @@@@ void render_con(Con *con, bool render_fullscreen) {
     /* in a stacking or tabbed container, we ensure the focused client is raised */
     if (con->layout == L_STACKED || con->layout == L_TABBED) {
         TAILQ_FOREACH_REVERSE(child, &(con->focus_head), focus_head, focused)
-            x_raise_con(child, false);
+            x_raise_con(child);
         if ((child = TAILQ_FIRST(&(con->focus_head)))) {
             /* By rendering the stacked container again, we handle the case
              * that we have a non-leaf-container inside the stack. In that
@@@@ -430,7 +430,7 @@@@ void render_con(Con *con, bool render_fullscreen) {
              * top of every stack window. That way, when a new window is opened in
              * the stack, the old window will not obscure part of the decoration
              * (it’s unmapped afterwards). */
-            x_raise_con(con, false);
+            x_raise_con(con);
     }
     }
 }
@


1.5
log
@
Revert "raise fullscreen windows on top of all other X11 windows"
It was a fix for dzen2 setups, but broke several other use cases
(upstream git commit 103ab83131d30614ea9337e752548a834773bfc6)

Bugfix: update root geometry on output changes for "fullscreen global"
(upstream git commit 93463bc3932e820bc86383fc4de1a07c82356967)

Bugfix: don't flatten tabbed/stacked containers
(upstream git commit 2481b9dcd73e91969033abb2b6f83aed608aeea1)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.4
log
@Update to i3-4.6

ok tobiasu@@, abieber@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_render_c,v 1.3 2013/05/17 10:21:42 dcoppa Exp $
d3 1
a3 12
commit b7da2dbcd87fbb167f2e76c113e7289564375c3f
Author: Clement Boesch <ubitux@@gmail.com>
Date:   Sat Apr 20 23:47:37 2013 +0200

render_con: fix height rounding in aspect ratio computation

With a 484x292 window and proportion of 488x294, new_height is
291.590164 after the loop, causing a rounding issue leading to
a window of 484x291.


commit 9f353996feb8ebab74ca747d319dd3c6746afca7
d5 1
a5 1
Date:   Sun Apr 7 09:58:34 2013 +0200
d7 1
a7 1
tabbed: floor(), put extra pixels into the last tab
d9 1
a9 3
This is the only sane way I can think of to deal with the problem
that the screen size may not be dividable by the amount of tabbed
children (e.g. 1280 / 41 = 31.219512_).
d11 40
a50 4
--- src/render.c.orig	Mon Mar 18 22:43:36 2013
+++ src/render.c	Fri May 17 11:51:32 2013
@@@@ -184,10 +184,10 @@@@ void render_con(Con *con, bool render_fullscreen) {
                     new_width--;
a51 8
             /* Center the window */
-            inset->y += ceil(inset->height / 2) - floor(new_height / 2);
+            inset->y += ceil(inset->height / 2) - floor((new_height + .5) / 2);
             inset->x += ceil(inset->width / 2) - floor(new_width / 2);
 
-            inset->height = new_height;
+            inset->height = new_height + .5;
             inset->width = new_width;
d53 1
d55 25
a79 17
@@@@ -372,9 +372,15 @@@@ void render_con(Con *con, bool render_fullscreen) {
             child->rect.width = rect.width;
             child->rect.height = rect.height;
 
-            child->deco_rect.width = ceil((float)child->rect.width / children);
+            child->deco_rect.width = floor((float)child->rect.width / children);
             child->deco_rect.x = x - con->rect.x + i * child->deco_rect.width;
             child->deco_rect.y = y - con->rect.y;
+
+            /* Since the tab width may be something like 31,6 px per tab, we
+             * let the last tab have all the extra space (0,6 * children). */
+            if (i == (children-1)) {
+                child->deco_rect.width += (child->rect.width - (child->deco_rect.x + child->deco_rect.width));
+            }
 
             if (children > 1 || (child->border_style != BS_PIXEL && child->border_style != BS_NONE)) {
                 child->rect.y += deco_height;
@


1.3
log
@Bunch of fixes from upstream:

Fix crash when not having tray_output configured

libi3: mark IPC fd CLOEXEC

Ensure that resize will take place even if pixel is smaller than
size increments

Fix floating window size with hide_edge_borders

render_con: fix height rounding in aspect ratio computation

tabbed: floor(), put extra pixels into the last tab
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@Bugfixing update to i3-4.1.1
@
text
@d1 1
a1 1
$OpenBSD: patch-src_render_c,v 1.1 2011/12/01 16:00:01 dcoppa Exp $
d3 3
a5 2
Bugfix: fix fullscreen with floating windows
(upstream git commit 61b8a62132bf07682b79902f5ea9f712bca000c9)
d7 26
a32 5
--- src/render.c.orig	Fri Nov 11 23:41:20 2011
+++ src/render.c	Thu Dec  1 13:30:55 2011
@@@@ -236,6 +236,27 @@@@ void render_con(Con *con, bool render_fullscreen) {
             Con *content = output_get_content(output);
             Con *workspace = TAILQ_FIRST(&(content->focus_head));
d34 18
a51 19
+            /* Check for (floating!) fullscreen nodes */
+            /* XXX: This code duplication is unfortunate. Keep in mind to fix
+             * this when we clean up the whole render.c */
+            Con *fullscreen = NULL;
+            fullscreen = con_get_fullscreen_con(workspace, CF_OUTPUT);
+            if (fullscreen) {
+                /* Either the fullscreen window is inside the floating
+                 * container, then we need to render and raise it now... */
+                if (con_inside_floating(fullscreen)) {
+                    fullscreen->rect = output->rect;
+                    x_raise_con(fullscreen);
+                    render_con(fullscreen, true);
+                    continue;
+                } else {
+                    /* ...or it's a tiling window, in which case the floating
+                     * windows should not overlap it, so we skip rendering this
+                     * output. */
+                    continue;
+                }
d53 3
a55 4
+
             Con *child;
             TAILQ_FOREACH(child, &(workspace->floating_head), floating_windows) {
                 DLOG("floating child at (%d,%d) with %d x %d\n", child->rect.x, child->rect.y, child->rect.width, child->rect.height);
@


1.1
log
@Major update to i3-4.1
@
text
@d1 1
a1 1
$OpenBSD$
@

