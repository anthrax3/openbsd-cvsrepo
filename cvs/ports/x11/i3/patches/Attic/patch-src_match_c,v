head	1.2;
access;
symbols
	OPENBSD_5_9:1.1.0.2
	OPENBSD_5_9_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2016.03.09.09.25.51;	author dcoppa;	state dead;
branches;
next	1.1;
commitid	5e0lb25PYzcoURwg;

1.1
date	2015.12.18.15.53.09;	author dcoppa;	state Exp;
branches;
next	;
commitid	0OqseA58UoyREWdQ;


desc
@@


1.2
log
@
Update to i3-4.12
Added halex@@'s window hints fix
Fixed trailing whitespace in pkg/DESCR (spotted by Josh Grosse)

Tested by tb@@ and Josh Grosse
OK tb@@
@
text
@$OpenBSD: patch-src_match_c,v 1.1 2015/12/18 15:53:09 dcoppa Exp $

Refactor parsing of matches to avoid code duplication.

Fix multiple memory leaks with regular expressions.

--- src/match.c.orig	Wed Sep 30 08:55:10 2015
+++ src/match.c	Fri Dec 18 13:58:58 2015
@@@@ -238,19 +238,126 @@@@ bool match_matches_window(Match *match, i3Window *wind
  *
  */
 void match_free(Match *match) {
-    /* First step: free the regex fields / patterns */
     regex_free(match->title);
     regex_free(match->application);
     regex_free(match->class);
     regex_free(match->instance);
     regex_free(match->mark);
     regex_free(match->window_role);
+    regex_free(match->workspace);
+}
 
-    /* Second step: free the regex helper struct itself */
-    FREE(match->title);
-    FREE(match->application);
-    FREE(match->class);
-    FREE(match->instance);
-    FREE(match->mark);
-    FREE(match->window_role);
+/*
+ * Interprets a ctype=cvalue pair and adds it to the given match specification.
+ *
+ */
+void match_parse_property(Match *match, const char *ctype, const char *cvalue) {
+    assert(match != NULL);
+    DLOG("ctype=*%s*, cvalue=*%s*\n", ctype, cvalue);
+
+    if (strcmp(ctype, "class") == 0) {
+        regex_free(match->class);
+        match->class = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "instance") == 0) {
+        regex_free(match->instance);
+        match->instance = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "window_role") == 0) {
+        regex_free(match->window_role);
+        match->window_role = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "con_id") == 0) {
+        char *end;
+        long parsed = strtol(cvalue, &end, 10);
+        if (parsed == LONG_MIN ||
+            parsed == LONG_MAX ||
+            parsed < 0 ||
+            (end && *end != '\0')) {
+            ELOG("Could not parse con id \"%s\"\n", cvalue);
+        } else {
+            match->con_id = (Con *)parsed;
+            DLOG("id as int = %p\n", match->con_id);
+        }
+        return;
+    }
+
+    if (strcmp(ctype, "id") == 0) {
+        char *end;
+        long parsed = strtol(cvalue, &end, 10);
+        if (parsed == LONG_MIN ||
+            parsed == LONG_MAX ||
+            parsed < 0 ||
+            (end && *end != '\0')) {
+            ELOG("Could not parse window id \"%s\"\n", cvalue);
+        } else {
+            match->id = parsed;
+            DLOG("window id as int = %d\n", match->id);
+        }
+        return;
+    }
+
+    if (strcmp(ctype, "window_type") == 0) {
+        if (strcasecmp(cvalue, "normal") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_NORMAL;
+        else if (strcasecmp(cvalue, "dialog") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_DIALOG;
+        else if (strcasecmp(cvalue, "utility") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_UTILITY;
+        else if (strcasecmp(cvalue, "toolbar") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_TOOLBAR;
+        else if (strcasecmp(cvalue, "splash") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_SPLASH;
+        else if (strcasecmp(cvalue, "menu") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_MENU;
+        else if (strcasecmp(cvalue, "dropdown_menu") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_DROPDOWN_MENU;
+        else if (strcasecmp(cvalue, "popup_menu") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_POPUP_MENU;
+        else if (strcasecmp(cvalue, "tooltip") == 0)
+            match->window_type = A__NET_WM_WINDOW_TYPE_TOOLTIP;
+        else
+            ELOG("unknown window_type value \"%s\"\n", cvalue);
+
+        return;
+    }
+
+    if (strcmp(ctype, "con_mark") == 0) {
+        regex_free(match->mark);
+        match->mark = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "title") == 0) {
+        regex_free(match->title);
+        match->title = regex_new(cvalue);
+        return;
+    }
+
+    if (strcmp(ctype, "urgent") == 0) {
+        if (strcasecmp(cvalue, "latest") == 0 ||
+            strcasecmp(cvalue, "newest") == 0 ||
+            strcasecmp(cvalue, "recent") == 0 ||
+            strcasecmp(cvalue, "last") == 0) {
+            match->urgent = U_LATEST;
+        } else if (strcasecmp(cvalue, "oldest") == 0 ||
+                   strcasecmp(cvalue, "first") == 0) {
+            match->urgent = U_OLDEST;
+        }
+        return;
+    }
+
+    if (strcmp(ctype, "workspace") == 0) {
+        regex_free(match->workspace);
+        match->workspace = regex_new(cvalue);
+        return;
+    }
+
+    ELOG("Unknown criterion: %s\n", ctype);
 }
@


1.1
log
@
Merge all the fixes from the git stable branch of i3
Regen WANTLIB while here
@
text
@d1 1
a1 1
$OpenBSD$
@

