head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.42
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.40
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.38
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.34
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.36
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.32
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.30
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.28
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.26
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.24
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.22
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.20
	OPENBSD_5_0:1.3.0.18
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.16
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.14
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.12
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.10
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.8
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.6
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.4
	OPENBSD_3_9:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2007.03.31.22.49.46;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.04.18.34.46;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.18.05.31;	author espie;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2006.10.29.17.48.55;	author sturm;	state Exp;
branches;
next	;

1.1.4.1
date	2006.11.01.08.59.09;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@regen patches.
handle utf8 encoding better.
@
text
@$OpenBSD: patch-src_tools_qfile_cpp,v 1.2 2007/01/04 18:34:46 espie Exp $
--- src/tools/qfile.cpp.orig	Thu Oct 19 16:25:01 2006
+++ src/tools/qfile.cpp	Sat Mar 31 14:51:25 2007
@@@@ -70,8 +70,13 @@@@ class QFilePrivate
 {
 public:
     QString errorString;
+    int lastAccess;
 };
 
+#define ACCESS_NONE -1
+#define ACCESS_READ 0
+#define ACCESS_WRITE 1
+
 extern bool qt_file_access( const QString& fn, int t );
 
 /*!
@@@@ -196,6 +201,7 @@@@ void QFile::init()
 {
     delete d;
     d = new QFilePrivate;
+    d->lastAccess = ACCESS_NONE;
     setFlags( IO_Direct );
     setStatus( IO_Ok );
     setErrorString( qt_fileerr_unknown );
@@@@ -206,7 +212,6 @@@@ void QFile::init()
     ext_f  = FALSE;				// not an external file handle
 }
 
-
 /*!
     \fn QString QFile::name() const
 
@@@@ -382,6 +387,10 @@@@ Q_LONG QFile::readLine( char *p, Q_ULONG maxlen )
     if ( isRaw() ) {				// raw file
 	nread = QIODevice::readLine( p, maxlen );
     } else {					// buffered file
+    	if (d->lastAccess == ACCESS_WRITE) {
+	    ::fseek(fh, 0, SEEK_CUR);
+	    d->lastAccess = ACCESS_READ;
+	}
 	p = fgets( p, maxlen, fh );
 	if ( p ) {
 	    nread = qstrlen( p );
@@@@ -463,6 +472,10 @@@@ int QFile::getch()
 	char buf[1];
 	ch = readBlock( buf, 1 ) == 1 ? buf[0] : EOF;
     } else {					// buffered file
+    	if (d->lastAccess == ACCESS_WRITE) {
+	    ::fseek(fh, 0, SEEK_CUR);
+	    d->lastAccess = ACCESS_READ;
+	}
 	if ( (ch = getc( fh )) != EOF ) {
 	    if ( !isSequentialAccess() )
 		ioIndex++;
@@@@ -499,6 +512,10 @@@@ int QFile::putch( int ch )
 	buf[0] = ch;
 	ch = writeBlock( buf, 1 ) == 1 ? ch : EOF;
     } else {					// buffered file
+    	if (d->lastAccess == ACCESS_READ) {
+	    ::fseek(fh, 0, SEEK_CUR);
+	    d->lastAccess = ACCESS_WRITE;
+	}
 	if ( (ch = putc( ch, fh )) != EOF ) {
 	    if ( !isSequentialAccess() )
 		ioIndex++;
@@@@ -553,6 +570,10 @@@@ int QFile::ungetch( int ch )
 	else
 	    ch = EOF;
     } else {					// buffered file
+    	if (d->lastAccess == ACCESS_WRITE) {
+	    ::fseek(fh, 0, SEEK_CUR);
+	    d->lastAccess = ACCESS_READ;
+	}
 	if ( (ch = ungetc(ch, fh)) != EOF ) {
 	    if ( !isSequentialAccess() )
 		ioIndex--;
@


1.2
log
@update to qt 3.3.7 now that we have a qt immodule patch finally.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_tools_qfile_cpp,v 1.1 2006/10/18 18:05:31 espie Exp $
d3 1
a3 1
+++ src/tools/qfile.cpp	Tue Jan  2 15:36:11 2007
d34 1
a34 1
@@@@ -382,6 +387,10 @@@@ Q_LONG QFile::readLine( char *p, Q_ULONG
@


1.1
log
@Let qfile synch IO between read and write by using fflush, a bit like qt4
does.

This is hidden behind a pimpl, so there's no ABI change.

This should allow people to use QDataStream for input AND output with
impunity.
@
text
@d1 3
a3 3
$OpenBSD$
--- src/tools/qfile.cpp.orig	Wed Oct 18 13:21:33 2006
+++ src/tools/qfile.cpp	Wed Oct 18 13:35:35 2006
d34 1
a34 1
@@@@ -375,6 +380,10 @@@@ Q_LONG QFile::readLine( char *p, Q_ULONG
d45 1
a45 1
@@@@ -456,6 +465,10 @@@@ int QFile::getch()
d56 1
a56 1
@@@@ -492,6 +505,10 @@@@ int QFile::putch( int ch )
d67 1
a67 1
@@@@ -546,6 +563,10 @@@@ int QFile::ungetch( int ch )
@


1.1.4.1
log
@MFC:
Let qfile synch IO between read and write by using fflush, a bit like qt4
does.

This is hidden behind a pimpl, so there's no ABI change.

This should allow people to use QDataStream for input AND output with
impunity.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_tools_qfile_cpp,v 1.1 2006/10/18 18:05:31 espie Exp $
@


1.1.2.1
log
@MFC:
Let qfile synch IO between read and write by using fflush, a bit like qt4
does.

This is hidden behind a pimpl, so there's no ABI change.

This should allow people to use QDataStream for input AND output with
impunity.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_tools_qfile_cpp,v 1.1 2006/10/18 18:05:31 espie Exp $
@

