head	1.2;
access;
symbols
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2003.04.05.14.48.19;	author espie;	state dead;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2003.03.04.18.06.59;	author espie;	state Exp;
branches;
next	;

1.2.2.1
date	2004.10.01.01.51.41;	author brad;	state Exp;
branches;
next	;

1.2.4.1
date	2004.10.01.17.50.07;	author brad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@and remove integrated patches
@
text
@$OpenBSD: patch-src_kernel_qjpegio_cpp,v 1.1 2003/03/04 18:06:59 espie Exp $
--- src/kernel/qjpegio.cpp.orig	Tue Mar  4 19:00:44 2003
+++ src/kernel/qjpegio.cpp	Tue Mar  4 19:02:09 2003
@@@@ -235,7 +235,7 @@@@ void read_jpeg_image(QImageIO* iio)
 
 
 	} else if ( params.contains( "Scale" ) ) {
-	    sscanf( params.latin1(), "Scale( %i, %i, %s )", &sWidth, &sHeight, sModeStr );
+	    sscanf( params.latin1(), "Scale( %i, %i, %1023s )", &sWidth, &sHeight, sModeStr );
 
 	    QString sModeQStr( sModeStr );
 	    if ( sModeQStr == "ScaleFree" ) {
@


1.2.4.1
log
@Chris Evans found a heap overflow vulnerability in the QT
library when handling 8-bit RLE encoded BMP files. An attacker could
use this to compromise the account used to view the specially crafted
image. Further investigations found similar vulnerabilities in
XPM, GIF and JPEG image handlers.

CAN-2004-0691, CAN-2004-0692, CAN-2004-0693
@
text
@d1 4
a4 6
$OpenBSD: patch-src_kernel_qjpegio_cpp,v 1.2.2.1 2004/10/01 01:51:41 brad Exp $
--- src/kernel/qjpegio.cpp.orig	Mon Feb 24 03:30:22 2003
+++ src/kernel/qjpegio.cpp	Thu Sep 30 14:32:13 2004
@@@@ -254,15 +254,18 @@@@ void read_jpeg_image(QImageIO* iio)
 	    scaleSize( sWidth, sHeight, cinfo.output_width, cinfo.output_height, sMode );
 //	    qDebug( "Scaling the jpeg to %i x %i", sWidth, sHeight, sModeStr );
a5 14
+	    bool created = FALSE;
 	    if ( cinfo.output_components == 3 || cinfo.output_components == 4) {
-		image.create( sWidth, sHeight, 32 );
+		created = image.create( sWidth, sHeight, 32 );
 	    } else if ( cinfo.output_components == 1 ) {
-		image.create( sWidth, sHeight, 8, 256 );
+		created = image.create( sWidth, sHeight, 8, 256 );
 		for (int i=0; i<256; i++)
 		    image.setColor(i, qRgb(i,i,i));
 	    } else {
 		// Unsupported format
 	    }
+	    if (!created)
+		image = QImage();
d7 3
a9 3
 	    if (!image.isNull()) {
 		QImage tmpImage( cinfo.output_width, 1, 32 );
@@@@ -300,49 +303,54 @@@@ void read_jpeg_image(QImageIO* iio)
d11 2
a12 73
 	} else {
 
+	    bool created = false;
 	    if ( cinfo.output_components == 3 || cinfo.output_components == 4) {
-		image.create( cinfo.output_width, cinfo.output_height, 32 );
+		created = image.create( cinfo.output_width, cinfo.output_height, 32 );
 	    } else if ( cinfo.output_components == 1 ) {
-		image.create( cinfo.output_width, cinfo.output_height, 8, 256 );
+		created = image.create( cinfo.output_width, cinfo.output_height, 8, 256 );
 		for (int i=0; i<256; i++)
 		    image.setColor(i, qRgb(i,i,i));
 	    } else {
 		// Unsupported format
 	    }
+	    if (!created)
+		image = QImage();
 
 	    if (!image.isNull()) {
 		uchar** lines = image.jumpTable();
 		while (cinfo.output_scanline < cinfo.output_height)
 		    (void) jpeg_read_scanlines(&cinfo,
-				lines + cinfo.output_scanline,
-				cinfo.output_height);
+		                               lines + cinfo.output_scanline,
+		                               cinfo.output_height);
 		(void) jpeg_finish_decompress(&cinfo);
-	    }
 
-	    if ( cinfo.output_components == 3 ) {
-		// Expand 24->32 bpp.
-		for (uint j=0; j<cinfo.output_height; j++) {
-		    uchar *in = image.scanLine(j) + cinfo.output_width * 3;
-		    QRgb *out = (QRgb*)image.scanLine(j);
+		if ( cinfo.output_components == 3 ) {
+		    // Expand 24->32 bpp.
+		    for (uint j=0; j<cinfo.output_height; j++) {
+			uchar *in = image.scanLine(j) + cinfo.output_width * 3;
+			QRgb *out = (QRgb*)image.scanLine(j);
 
-		    for (uint i=cinfo.output_width; i--; ) {
-			in-=3;
-			out[i] = qRgb(in[0], in[1], in[2]);
+			for (uint i=cinfo.output_width; i--; ) {
+			    in-=3;
+			    out[i] = qRgb(in[0], in[1], in[2]);
+			}
 		    }
 		}
 	    }
         }
 
-	if ( cinfo.density_unit == 1 ) {
-	    image.setDotsPerMeterX( int(100. * cinfo.X_density / 2.54) );
-	    image.setDotsPerMeterY( int(100. * cinfo.Y_density / 2.54) );
-	} else if ( cinfo.density_unit == 2 ) {
-	    image.setDotsPerMeterX( int(100. * cinfo.X_density) );
-	    image.setDotsPerMeterY( int(100. * cinfo.Y_density) );
+	if (!image.isNull()) {
+	    if ( cinfo.density_unit == 1 ) {
+	        image.setDotsPerMeterX( int(100. * cinfo.X_density / 2.54) );
+	        image.setDotsPerMeterY( int(100. * cinfo.Y_density / 2.54) );
+	    } else if ( cinfo.density_unit == 2 ) {
+		image.setDotsPerMeterX( int(100. * cinfo.X_density) );
+		image.setDotsPerMeterY( int(100. * cinfo.Y_density) );
+	    }
 	}
 
 	iio->setImage(image);
-	iio->setStatus(0);
+	iio->setStatus(image.isNull());
     }
 
     jpeg_destroy_decompress(&cinfo);
@


1.2.2.1
log
@Chris Evans found a heap overflow vulnerability in the QT
library when handling 8-bit RLE encoded BMP files. An attacker could
use this to compromise the account used to view the specially crafted
image. Further investigations found similar vulnerabilities in
XPM, GIF and JPEG image handlers.

CAN-2004-0691, CAN-2004-0692, CAN-2004-0693
@
text
@d1 4
a4 6
$OpenBSD$
--- src/kernel/qjpegio.cpp.orig	Mon Feb 24 03:30:22 2003
+++ src/kernel/qjpegio.cpp	Thu Sep 30 14:32:13 2004
@@@@ -254,15 +254,18 @@@@ void read_jpeg_image(QImageIO* iio)
 	    scaleSize( sWidth, sHeight, cinfo.output_width, cinfo.output_height, sMode );
 //	    qDebug( "Scaling the jpeg to %i x %i", sWidth, sHeight, sModeStr );
a5 14
+	    bool created = FALSE;
 	    if ( cinfo.output_components == 3 || cinfo.output_components == 4) {
-		image.create( sWidth, sHeight, 32 );
+		created = image.create( sWidth, sHeight, 32 );
 	    } else if ( cinfo.output_components == 1 ) {
-		image.create( sWidth, sHeight, 8, 256 );
+		created = image.create( sWidth, sHeight, 8, 256 );
 		for (int i=0; i<256; i++)
 		    image.setColor(i, qRgb(i,i,i));
 	    } else {
 		// Unsupported format
 	    }
+	    if (!created)
+		image = QImage();
d7 3
a9 3
 	    if (!image.isNull()) {
 		QImage tmpImage( cinfo.output_width, 1, 32 );
@@@@ -300,49 +303,54 @@@@ void read_jpeg_image(QImageIO* iio)
d11 2
a12 73
 	} else {
 
+	    bool created = false;
 	    if ( cinfo.output_components == 3 || cinfo.output_components == 4) {
-		image.create( cinfo.output_width, cinfo.output_height, 32 );
+		created = image.create( cinfo.output_width, cinfo.output_height, 32 );
 	    } else if ( cinfo.output_components == 1 ) {
-		image.create( cinfo.output_width, cinfo.output_height, 8, 256 );
+		created = image.create( cinfo.output_width, cinfo.output_height, 8, 256 );
 		for (int i=0; i<256; i++)
 		    image.setColor(i, qRgb(i,i,i));
 	    } else {
 		// Unsupported format
 	    }
+	    if (!created)
+		image = QImage();
 
 	    if (!image.isNull()) {
 		uchar** lines = image.jumpTable();
 		while (cinfo.output_scanline < cinfo.output_height)
 		    (void) jpeg_read_scanlines(&cinfo,
-				lines + cinfo.output_scanline,
-				cinfo.output_height);
+		                               lines + cinfo.output_scanline,
+		                               cinfo.output_height);
 		(void) jpeg_finish_decompress(&cinfo);
-	    }
 
-	    if ( cinfo.output_components == 3 ) {
-		// Expand 24->32 bpp.
-		for (uint j=0; j<cinfo.output_height; j++) {
-		    uchar *in = image.scanLine(j) + cinfo.output_width * 3;
-		    QRgb *out = (QRgb*)image.scanLine(j);
+		if ( cinfo.output_components == 3 ) {
+		    // Expand 24->32 bpp.
+		    for (uint j=0; j<cinfo.output_height; j++) {
+			uchar *in = image.scanLine(j) + cinfo.output_width * 3;
+			QRgb *out = (QRgb*)image.scanLine(j);
 
-		    for (uint i=cinfo.output_width; i--; ) {
-			in-=3;
-			out[i] = qRgb(in[0], in[1], in[2]);
+			for (uint i=cinfo.output_width; i--; ) {
+			    in-=3;
+			    out[i] = qRgb(in[0], in[1], in[2]);
+			}
 		    }
 		}
 	    }
         }
 
-	if ( cinfo.density_unit == 1 ) {
-	    image.setDotsPerMeterX( int(100. * cinfo.X_density / 2.54) );
-	    image.setDotsPerMeterY( int(100. * cinfo.Y_density / 2.54) );
-	} else if ( cinfo.density_unit == 2 ) {
-	    image.setDotsPerMeterX( int(100. * cinfo.X_density) );
-	    image.setDotsPerMeterY( int(100. * cinfo.Y_density) );
+	if (!image.isNull()) {
+	    if ( cinfo.density_unit == 1 ) {
+	        image.setDotsPerMeterX( int(100. * cinfo.X_density / 2.54) );
+	        image.setDotsPerMeterY( int(100. * cinfo.Y_density / 2.54) );
+	    } else if ( cinfo.density_unit == 2 ) {
+		image.setDotsPerMeterX( int(100. * cinfo.X_density) );
+		image.setDotsPerMeterY( int(100. * cinfo.Y_density) );
+	    }
 	}
 
 	iio->setImage(image);
-	iio->setStatus(0);
+	iio->setStatus(image.isNull());
     }
 
     jpeg_destroy_decompress(&cinfo);
@


1.1
log
@backport buffer overrun fix from qt 3.1.2.
ok pval@@
@
text
@d1 1
a1 1
$OpenBSD$
@

