head	1.3;
access;
symbols
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	jolan_2004_01_30:1.1.1.1
	jolan:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2005.05.12.05.01.10;	author jolan;	state dead;
branches;
next	1.2;

1.2
date	2004.02.17.21.37.15;	author jolan;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.31.03.32.03;	author jolan;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.01.31.03.32.03;	author jolan;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove 4.0.6
@
text
@$OpenBSD: patch-panel-plugin_devperf_c,v 1.2 2004/02/17 21:37:15 jolan Exp $
--- panel-plugin/devperf.c.orig	2003-11-30 09:01:44.000000000 -0200
+++ panel-plugin/devperf.c	2004-02-15 22:51:32.000000000 -0300
@@@@ -310,6 +310,82 @@@@ int DevGetPerfData (const void *p_pvDevi
 /* *INDENT-ON* */
 	/**************************	NetBSD End	***************/
 
+#elif defined(__OpenBSD__)
+/*
+ * OpenBSD support.
+ */
+
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/disk.h>
+
+int DevPerfInit ()
+{
+        return (0);
+}
+
+int DevCheckStatAvailability(char const **strptr)
+{
+        return (0);
+}
+
+int DevGetPerfData (const void *p_pvDevice, struct devperf_t *perf)
+{
+	int mib[3], diskn, x;
+	size_t len;
+	char *devname = (char *)p_pvDevice;
+	struct diskstats *ds;
+	struct timeval tv;
+
+	mib[0] = CTL_HW;
+	mib[1] = HW_DISKCOUNT;
+	len = sizeof(diskn);
+
+	if (sysctl(mib, 2, &diskn, &len, NULL, 0) < 0)
+		return (-1);
+
+	mib[0] = CTL_HW;
+	mib[1] = HW_DISKSTATS;
+	len = diskn * sizeof(struct diskstats);
+
+	ds = malloc(len);
+	if (ds == NULL)
+		return (-1);
+
+	if (sysctl(mib, 2, ds, &len, NULL, 0) < 0) {
+		free(ds);
+		return (-1);
+	}
+
+	for (x = 0; x < diskn; x++)
+		if (!strcmp(ds[x].ds_name, devname))
+			break;
+
+	if (x == diskn) {
+		free(ds);
+		return (-1);
+	}
+
+	if (gettimeofday(&tv, NULL)) {
+		free(ds);
+		return (-1);
+	}
+
+	perf->timestamp_ns = (uint64_t)1000ull * 1000ull * 1000ull * tv.tv_sec
+	    + 1000ull * tv.tv_usec; 
+        perf->rbusy_ns = ((uint64_t)1000ull * 1000ull * 1000ull *
+	    ds[x].ds_time.tv_sec + 1000ull * ds[x].ds_time.tv_usec) / 2ull;
+
+	perf->wbusy_ns = perf->rbusy_ns / 2ull;
+	perf->rbytes = ds[x].ds_rbytes;
+	perf->wbytes = ds[x].ds_wbytes;
+	perf->qlen = ds[x].ds_rxfer + ds[x].ds_wxfer;
+
+	free(ds);
+
+	return (0);
+}
+
 #else
 	/**************************************************************/
 	/********************	Unsupported platform	***************/
@


1.2
log
@patch from Pedro Martelletto (again) to sync w/new separated read/write
statistics available in the kernel.  Pedro also did the kernel parts to
make this possible...
@
text
@d1 1
a1 1
$OpenBSD: patch-panel-plugin_devperf_c,v 1.1.1.1 2004/01/31 03:32:03 jolan Exp $
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
+++ panel-plugin/devperf.c	2004-01-30 23:37:45.000000000 -0200
@@@@ -310,6 +310,124 @@@@ int DevGetPerfData (const void *p_pvDevi
d10 1
a10 2
+ * OpenBSD support. As of the moment of this writing OpenBSD didn't separate
+ * read and write disk statistics, they were assumed to have the same value.
a16 5
+#include <string.h>
+
+static char **disks = NULL;
+static int diskn = 0;
+
d29 1
a29 1
+	int mib[3], cur_diskn, x;
d31 2
a32 3
+	void *r;
+	char **tok, *names, *devname = (char *)p_pvDevice;
+	struct diskstats *diskstats;
d37 1
a37 1
+	len = sizeof(cur_diskn);
d39 1
a39 44
+	if (sysctl(mib, 2, &cur_diskn, &len, NULL, 0) < 0)
+		return (-1);
+
+	if (cur_diskn != diskn) {
+		if (disks != NULL)
+			free(disks[0]);
+		r = realloc(disks, cur_diskn * sizeof(char *));
+		if (r == NULL) {
+error:			free(disks);
+			disks = NULL;
+			diskn = 0;
+			return (-1);
+		} else
+			disks = (char **)r;
+
+		mib[0] = CTL_HW;
+		mib[1] = HW_DISKNAMES;
+		len = 0;
+
+		if (sysctl(mib, 2, NULL, &len, NULL, 0) < 0)
+			goto error;
+
+		names = malloc(len);
+		if (names == NULL)
+			goto error;
+
+		if (sysctl(mib, 2, names, &len, NULL, 0) < 0) {
+			free(names);
+			goto error;
+		}
+
+		diskn = cur_diskn;
+
+		for (tok = disks; tok <= &disks[cur_diskn - 1] &&
+		    (*tok = strsep(&names, ",")) != NULL;)
+		    	if (**tok != '\0')
+				tok++;
+	}
+
+	for (x = 0; x < diskn; x++)
+		if (!strcmp(disks[x], devname))
+			break;
+
+	if (x == diskn)
d46 6
a51 2
+	diskstats = malloc(len);
+	if (diskstats == NULL)
d53 5
d59 2
a60 2
+	if (sysctl(mib, 2, diskstats, &len, NULL, 0) < 0) {
+		free(diskstats);
d65 1
a65 1
+		free(diskstats);
d72 1
a72 2
+	    diskstats[x].ds_time.tv_sec + 1000ull *
+	    diskstats[x].ds_time.tv_usec) / 2ull;
d75 3
a77 3
+	perf->rbytes = diskstats[x].ds_bytes;
+	perf->wbytes = perf->rbytes;
+	perf->qlen = diskstats[x].ds_xfer;
d79 1
a79 1
+	free(diskstats);
@


1.1.1.1
log
@import 1.4.1.  Thanks to Pedro Martelleto for adding OpenBSD support to
the plugin itself.
@
text
@@
