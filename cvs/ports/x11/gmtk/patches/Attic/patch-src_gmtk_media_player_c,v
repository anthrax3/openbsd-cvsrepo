head	1.16;
access;
symbols
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@# @;


1.16
date	2014.01.13.11.28.03;	author dcoppa;	state dead;
branches;
next	1.15;

1.15
date	2013.11.06.07.28.25;	author dcoppa;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.07.10.20.28;	author dcoppa;	state Exp;
branches;
next	1.13;

1.13
date	2013.07.12.09.58.56;	author dcoppa;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.05.08.10.57;	author dcoppa;	state Exp;
branches;
next	1.11;

1.11
date	2013.05.24.08.29.54;	author dcoppa;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.31.13.21.07;	author dcoppa;	state dead;
branches;
next	1.9;

1.9
date	2012.06.22.15.08.45;	author dcoppa;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.13.07.50.11;	author dcoppa;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.09.14.19.37;	author dcoppa;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.03.15.18.50;	author dcoppa;	state Exp;
branches;
next	1.5;

1.5
date	2012.04.10.13.29.33;	author dcoppa;	state dead;
branches;
next	1.4;

1.4
date	2012.04.06.10.13.55;	author dcoppa;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.26.14.41.16;	author dcoppa;	state dead;
branches;
next	1.2;

1.2
date	2012.03.06.08.50.54;	author dcoppa;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.23.11.01.34;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to 1.0.9b
@
text
@$OpenBSD: patch-src_gmtk_media_player_c,v 1.15 2013/11/06 07:28:25 dcoppa Exp $

Fix parameter warning to gtk_widget_get_visible
(upstream svn revision r232)

Add key bindings for h tv_step_channel down and k tv_step_channel
up (upstream svn revision r228)

Only do the media player allocation event if no video is present
(upstream svn revision r233)

--- src/gmtk_media_player.c.orig	Fri Aug 16 17:18:55 2013
+++ src/gmtk_media_player.c	Wed Nov  6 07:58:52 2013
@@@@ -147,7 +147,7 @@@@ gboolean signal_event(gpointer data)
             break;
 
         case EVENT_TYPE_ALLOCATION:
-            if (gtk_widget_get_visible(event->player)) {
+            if (gtk_widget_get_visible(GTK_WIDGET(event->player))) {
                 if (!(event->event_allocation->width >= 65535 || event->event_allocation->height >= 65535))
                     g_signal_emit_by_name(event->player, event->event_name, event->event_allocation);
             }
@@@@ -834,6 +834,12 @@@@ static gboolean player_key_press_event_callback(GtkWid
         case GDK_o:
             write_to_mplayer(player, "osd\n");
             break;
+		case GDK_h:
+			write_to_mplayer(player, "tv_step_channel -1\n");
+			break;
+		case GDK_k:
+			write_to_mplayer(player, "tv_step_channel 1\n");
+			break;
         default:
             gm_log(player->debug, G_LOG_LEVEL_INFO, "ignoring key %s%s%s%s",
                    (event->state & GDK_CONTROL_MASK) ? "Control-" : "", (event->state & GDK_MOD1_MASK) ? "Alt-" : "",
@@@@ -2375,7 +2381,6 @@@@ gpointer launch_mplayer(gpointer data)
 
     player->seekable = FALSE;
     player->has_chapters = FALSE;
-    player->video_present = FALSE;
     player->position = 0.0;
     player->cache_percent = -1.0;
     player->title_is_menu = FALSE;
@@@@ -3379,7 +3384,9 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
                 create_event_int(player, "media-state-changed", player->media_state);
                 allocation.width = player->video_width;
                 allocation.height = player->video_height;
-                create_event_allocation(player, "size_allocate", &allocation);
+				if (player->video_present == FALSE) {
+            		create_event_allocation(player, "size_allocate", &allocation);
+				}
                 player->video_present = TRUE;
                 buf = g_strdup_printf("set_property sub_visibility %i\n", player->sub_visible);
                 write_to_mplayer(player, buf);
@


1.15
log
@Fix parameter warning to gtk_widget_get_visible
(upstream svn revision r232)

Only do the media player allocation event if no video is present
(upstream svn revision r233)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.14 2013/10/07 10:20:28 dcoppa Exp $
@


1.14
log
@Update to gmtk-1.0.9alpha
@
text
@d1 4
a4 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.13 2013/07/12 09:58:56 dcoppa Exp $
d9 3
d13 10
a22 1
+++ src/gmtk_media_player.c	Mon Oct  7 11:56:50 2013
d36 19
@


1.13
log
@
If the user gives some mplayer video output driver (vo) options in
the "Video Output" preferences they should be passed along on the
mplayer command line (upstream svn revision r222)

Minor string cleanups (upstream svn revision r223)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.12 2013/06/05 08:10:57 dcoppa Exp $
d3 2
a4 3
If the user gives some mplayer video output driver (vo) options in
the "Video Output" preferences they should be passed along on the
mplayer command line (upstream svn revision r222)
d6 15
a20 452
Use case-insensitive parsing of metadata attributes
(upstream svn revision r212)

Fix OSD messages so they only displayed for level 1 and higher
(upstream svn revision r216)

Exclude input.conf from file not found message
(upstream svn revision r213)

Fix issue #682: item names in "Items to Play" replaced with CPUID
string (upstream svn revision r220)

--- src/gmtk_media_player.c.orig	Tue Feb 19 18:02:13 2013
+++ src/gmtk_media_player.c	Fri Jul 12 11:31:22 2013
@@@@ -75,6 +75,22 @@@@ static void alignment_realized(GtkWidget * widget, gpo
 
 }
 
+static gboolean vodesc_looks_like_vo(gchar const*const desc, gchar const*const vo) {
+   if(g_strcmp0(desc, vo) == 0) {
+      return TRUE;
+   }
+   if(!g_str_has_prefix(desc, vo)) {
+      return FALSE;
+   }
+   /* we know that they are not equal but desc starts with vo, i.e. desc is longer than vo */
+   /* now to check that desc looks like vo: */
+   const size_t vol = strlen(vo);
+   if(desc[vol] == ':') {
+      return TRUE;
+   }
+   return FALSE;
+}
+
 static void socket_realized(GtkWidget * widget, gpointer data)
 {
     GmtkMediaPlayer *player = GMTK_MEDIA_PLAYER(data);
@@@@ -83,7 +99,7 @@@@ static void socket_realized(GtkWidget * widget, gpoint
     player->socket_id = GPOINTER_TO_INT(gtk_socket_get_id(GTK_SOCKET(widget)));
     style = gtk_widget_get_style(widget);
     if (player->vo != NULL) {
-        if (!(g_ascii_strncasecmp(player->vo, "vdpau", strlen("vdpau")) == 0)) {
+        if (!vodesc_looks_like_vo(player->vo, "vdpau")) {
             gtk_widget_modify_bg(widget, GTK_STATE_NORMAL, &(style->black));
             gtk_widget_modify_bg(widget, GTK_STATE_ACTIVE, &(style->black));
             gtk_widget_modify_bg(widget, GTK_STATE_SELECTED, &(style->black));
@@@@ -477,6 +493,13 @@@@ static void gmtk_media_player_init(GmtkMediaPlayer * p
     player->album = NULL;
     player->disposed = FALSE;
     player->player_lock = g_mutex_new();
+    player->name_regex = g_regex_new(".*name\\s*:\\s*(.*)\n", G_REGEX_CASELESS, 0, NULL);
+    player->genre_regex = g_regex_new(".*genre\\s*:\\s*(.*)\n", G_REGEX_CASELESS, 0, NULL);
+    player->title_regex = g_regex_new(".*title\\s*:\\s*(.*)\n", G_REGEX_CASELESS, 0, NULL);
+    player->artist_regex = g_regex_new(".*artist\\s*:\\s*(.*)\n", G_REGEX_CASELESS, 0, NULL);
+    player->album_regex = g_regex_new(".*album\\s*:\\s*(.*)\n", G_REGEX_CASELESS, 0, NULL);
+    player->deintN_regex = g_regex_new("(.*)(:deint=[0-9]+)\\b(.*)", G_REGEX_CASELESS, 0, NULL);
+
     gmtk_media_player_log_state(player, "after init");
 }
 
@@@@ -741,7 +764,7 @@@@ static gboolean player_key_press_event_callback(GtkWid
         case GDK_d:
             write_to_mplayer(player, "frame_drop\n");
             cmd =
-                g_strdup_printf("osd_show_property_text \"%s: ${framedropping}\"\n",
+                g_strdup_printf("osd_show_property_text \"%s: ${framedropping}\" 1000 1\n",
                                 g_dgettext(GETTEXT_PACKAGE, "Frame Dropping"));
             write_to_mplayer(player, cmd);
             g_free(cmd);
@@@@ -755,7 +778,7 @@@@ static gboolean player_key_press_event_callback(GtkWid
         case GDK_D:
             write_to_mplayer(player, "step_property deinterlace\n");
             cmd =
-                g_strdup_printf("osd_show_property_text \"%s: ${deinterlace}\"\n",
+                g_strdup_printf("osd_show_property_text \"%s: ${deinterlace}\" 1000 1\n",
                                 g_dgettext(GETTEXT_PACKAGE, "Deinterlace"));
             write_to_mplayer(player, cmd);
             g_free(cmd);
@@@@ -1119,7 +1142,7 @@@@ void gmtk_media_player_send_command(GmtkMediaPlayer * 
         case COMMAND_SWITCH_FRAME_DROP:
             write_to_mplayer(player, "frame_drop\n");
             cmd =
-                g_strdup_printf("osd_show_property_text \"%s ${framedropping}\"\n",
+                g_strdup_printf("osd_show_property_text \"%s ${framedropping}\" 1000 1\n",
                                 g_dgettext(GETTEXT_PACKAGE, "Frame Dropping"));
             write_to_mplayer(player, cmd);
             g_free(cmd);
@@@@ -1147,11 +1170,12 @@@@ void gmtk_media_player_set_attribute_boolean(GmtkMedia
             cmd = NULL;
             if (value) {
                 cmd =
-                    g_strdup_printf("osd_show_property_text \"%s\"\n",
+                    g_strdup_printf("osd_show_property_text \"%s\" 1000 1\n",
                                     g_dgettext(GETTEXT_PACKAGE, "Subtitles Visible"));
             } else {
                 cmd =
-                    g_strdup_printf("osd_show_property_text \"%s\"\n", g_dgettext(GETTEXT_PACKAGE, "Subtitles Hidden"));
+                    g_strdup_printf("osd_show_property_text \"%s\" 1000 1\n",
+                                    g_dgettext(GETTEXT_PACKAGE, "Subtitles Hidden"));
             }
             write_to_mplayer(player, cmd);
             g_free(cmd);
@@@@ -1775,6 +1799,14 @@@@ const gchar *gmtk_media_player_get_attribute_string(Gm
         }
         break;
 
+    case ATTRIBUTE_GENRE:
+        if (player->genre == NULL || strlen(player->genre) == 0) {
+            value = NULL;
+        } else {
+            value = player->genre;
+        }
+        break;
+
     case ATTRIBUTE_PROFILE:
         value = player->profile;
         break;
@@@@ -2208,8 +2240,50 @@@@ static const gchar *playback_error_to_string(const Gmt
 
 }
 
+/* if it contains a deint=N leave as is, otherwise add deint=2
+   returns newly-allocated string, passing ownership to caller */
+static gchar* vdpau_compute_vo_with_deint(GmtkMediaPlayer * player, gchar const*const vodesc) {
+   gchar* ret;
+   if(g_regex_match(player->deintN_regex, vodesc, 0, NULL)) { 
+      ret = g_strdup(vodesc);
+   } else {
+      ret = g_strdup_printf("%s:deint=2", vodesc);
+   }
+   return ret;
+}
 
+/* if it contains a deint=N  remove that, otherwise leave as is
+   returns newly-allocated string, passing ownership to caller */
+static gchar* vdpau_compute_vo_without_deint(GmtkMediaPlayer * player, gchar const*const vodesc) {
+   GMatchInfo *match_info = NULL;
+   gchar *ret;
+   if(g_regex_match(player->deintN_regex, vodesc, 0, &match_info)) { 
+      gchar *before = g_match_info_fetch(match_info, 1);
+      gchar *after  = g_match_info_fetch(match_info, 3);
+      ret = g_strdup_printf("%s%s", before, after);
+      g_free(before);
+      g_free(after);
+   } else {
+      ret = g_strdup(vodesc);
+   }
+   g_match_info_free(match_info);
+   return ret;
+}
 
+/* replace the vo part with "gl_nosw"
+   returns newly-allocated string, passing ownership to caller */
+static gchar* vodesc_replace_gl_with_gl_nosw(GmtkMediaPlayer * player, gchar const*const vodesc) {
+   /* find the first colon : and replace the part before that with gl_nosw */
+   char *colonptr = strchr(vodesc, ':');
+   gchar *ret;
+   if(colonptr == NULL) {
+      ret = g_strdup("gl_nosw");
+   } else {
+      ret = g_strdup_printf("gl_nosw%s", colonptr);
+   }
+   return ret;   
+}
+
 gpointer launch_mplayer(gpointer data)
 {
     GmtkMediaPlayer *player = GMTK_MEDIA_PLAYER(data);
@@@@ -2321,12 +2395,18 @@@@ gpointer launch_mplayer(gpointer data)
         if (player->vo != NULL) {
             argv[argn++] = g_strdup_printf("-vo");
 
-            if (g_ascii_strncasecmp(player->vo, "vdpau", strlen("vdpau")) == 0) {
+            if (vodesc_looks_like_vo(player->vo, "vdpau")) {
 
                 if (player->deinterlace) {
-                    argv[argn++] = g_strdup_printf("vdpau:deint=2,%s,gl,x11", player->vo);
+                    /* if it contains a deint=N leave as is, otherwise add deint=2 */
+                    gchar* vo_with_deint = vdpau_compute_vo_with_deint(player, player->vo);
+                    argv[argn++] = g_strdup_printf("%s,gl,x11,", player->vo);
+                    g_free(vo_with_deint);
                 } else {
-                    argv[argn++] = g_strdup_printf("%s,gl,x11", player->vo);
+                    /* if it contains a deint=N remove that, otherwise leave as is */
+                    gchar* vo_without_deint = vdpau_compute_vo_without_deint(player, player->vo);
+                    argv[argn++] = g_strdup_printf("%s,gl,x11,", player->vo);
+                    g_free(vo_without_deint);
                 }
 
                 // told by uau that vdpau without hardware decoding is often what you want
@@@@ -2339,12 +2419,12 @@@@ gpointer launch_mplayer(gpointer data)
                     }
                 }
 
-            } else if (g_ascii_strncasecmp(player->vo, "vaapi", strlen("vaapi")) == 0) {
+            } else if (vodesc_looks_like_vo(player->vo, "vaapi")) {
                 argv[argn++] = g_strdup_printf("%s,", player->vo);
                 argv[argn++] = g_strdup_printf("-va");
                 argv[argn++] = g_strdup_printf("vaapi");
 
-            } else if (g_ascii_strncasecmp(player->vo, "xvmc", strlen("xvmc")) == 0) {
+            } else if (vodesc_looks_like_vo(player->vo, "xvmc")) {
 
                 if (player->disable_xvmc) {
                     argv[argn++] = g_strdup_printf("xv,");
@@@@ -2354,13 +2434,15 @@@@ gpointer launch_mplayer(gpointer data)
 
             } else {
 
-                if (g_ascii_strncasecmp(player->vo, "gl", strlen("gl")) == 0 && player->enable_hardware_codecs) {
-                    argv[argn++] = g_strdup_printf("gl_nosw");
-                } else if (g_ascii_strncasecmp(player->vo, "gl2", strlen("gl2")) == 0 && player->enable_hardware_codecs) {
-                    argv[argn++] = g_strdup_printf("gl_nosw");
+                if (vodesc_looks_like_vo(player->vo, "gl") && player->enable_hardware_codecs) {
+                    gchar *vodesc = vodesc_replace_gl_with_gl_nosw(player, player->vo);
+                    argv[argn++]  = vodesc;
+                } else if (vodesc_looks_like_vo(player->vo, "gl2") && player->enable_hardware_codecs) {
+                    gchar *vodesc = vodesc_replace_gl_with_gl_nosw(player, player->vo);
+                    argv[argn++]  = vodesc;
                 } else {
                     argv[argn++] = g_strdup_printf("%s", player->vo);
-                    if (g_ascii_strncasecmp(player->vo, "x11", strlen("x11")) == 0) {
+                    if (vodesc_looks_like_vo(player->vo, "x11")) {
                         argv[argn++] = g_strdup_printf("-zoom");
                     }
                 }
@@@@ -3010,7 +3092,7 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
         }
 
         if (strstr(mplayer_output->str, "Failed creating VDPAU decoder") != NULL) {
-            if (player->enable_divx && (g_ascii_strncasecmp(player->vo, "vdpau", strlen("vdpau")) == 0))
+            if (player->enable_divx && vodesc_looks_like_vo(player->vo, "vdpau"))
                 player->playback_error = ERROR_RETRY_WITHOUT_DIVX_VDPAU;
         }
 
@@@@ -3020,7 +3102,7 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
         }
 
         if (strstr(mplayer_output->str, "The selected video_out device is incompatible with this codec") != NULL) {
-            if (!player->disable_xvmc && (g_ascii_strncasecmp(player->vo, "xvmc", strlen("xvmc")) == 0))
+            if (!player->disable_xvmc && vodesc_looks_like_vo(player->vo, "xvmc"))
                 player->playback_error = ERROR_RETRY_WITHOUT_XVMC;
         }
 
@@@@ -3042,6 +3124,7 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
 
         if (strstr(mplayer_output->str, "Failed to open") != NULL) {
             if (strstr(mplayer_output->str, "LIRC") == NULL &&
+                strstr(mplayer_output->str, "input.conf") == NULL &&
                 strstr(mplayer_output->str, "/dev/rtc") == NULL &&
                 strstr(mplayer_output->str, "VDPAU") == NULL && strstr(mplayer_output->str, "registry file") == NULL) {
                 if (strstr(mplayer_output->str, "<") == NULL && strstr(mplayer_output->str, ">") == NULL
@@@@ -3161,6 +3244,8 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
     GmtkMediaPlayerAudioTrack *audio_track = NULL;
     GList *iter;
     GtkWidget *dialog;
+    gchar **split;
+    gint index;
 
     if (player == NULL) {
         gm_log(player->debug, G_LOG_LEVEL_MESSAGE, "player is NULL");
@@@@ -3635,94 +3720,120 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
             gtk_widget_destroy(dialog);
         }
 
-        if (strstr(mplayer_output->str, "Name   : ") != 0) {
-            buf = strstr(mplayer_output->str, "Name   : ");
-            buf = strstr(mplayer_output->str, "Name   : ") + strlen("Name   : ");
-            buf = g_strchomp(buf);
-            if (player->title != NULL) {
-                g_free(player->title);
-                player->title = NULL;
-            }
+        if (g_regex_match(player->name_regex, mplayer_output->str, 0, NULL) \
+        && (g_strrstr(mplayer_output->str, "CPU vendor name:") == NULL)) {
+            split = g_regex_split(player->name_regex, mplayer_output->str, 0);
+            index = 0;
+            while (split[index]) {
+                if (strlen(split[index]) > 0) {
+                    if (player->title != NULL) {
+                        g_free(player->title);
+                        player->title = NULL;
+                    }
 
-            player->title = g_locale_to_utf8(buf, -1, NULL, NULL, NULL);
-            if (player->title == NULL) {
-                player->title = g_strdup(buf);
-                gm_str_strip_unicode(player->title, strlen(player->title));
+                    player->title = g_locale_to_utf8(split[index], -1, NULL, NULL, NULL);
+                    if (player->title == NULL) {
+                        player->title = g_strdup(split[index]);
+                        gm_str_strip_unicode(player->title, strlen(player->title));
+                    }
+                    player->has_metadata = TRUE;
+                    create_event_int(player, "attribute-changed", ATTRIBUTE_TITLE);
+                }
+                index++;
             }
-            player->has_metadata = TRUE;
-            create_event_int(player, "attribute-changed", ATTRIBUTE_TITLE);
+            g_strfreev(split);
         }
 
-        if (strstr(mplayer_output->str, "Genre  : ") != 0) {
-            buf = strstr(mplayer_output->str, "Genre  : ");
-            buf = strstr(mplayer_output->str, "Genre  : ") + strlen("Genre  : ");
-            buf = g_strchomp(buf);
-            if (player->artist != NULL) {
-                g_free(player->artist);
-                player->artist = NULL;
-            }
+        if (g_regex_match(player->genre_regex, mplayer_output->str, 0, NULL)) {
+            split = g_regex_split(player->genre_regex, mplayer_output->str, 0);
+            index = 0;
+            while (split[index]) {
+                if (strlen(split[index]) > 0) {
+                    if (player->title != NULL) {
+                        g_free(player->genre);
+                        player->title = NULL;
+                    }
 
-            player->artist = g_locale_to_utf8(buf, -1, NULL, NULL, NULL);
-            if (player->artist == NULL) {
-                player->artist = g_strdup(buf);
-                gm_str_strip_unicode(player->artist, strlen(player->artist));
+                    player->genre = g_locale_to_utf8(split[index], -1, NULL, NULL, NULL);
+                    if (player->genre == NULL) {
+                        player->genre = g_strdup(split[index]);
+                        gm_str_strip_unicode(player->genre, strlen(player->genre));
+                    }
+                    player->has_metadata = TRUE;
+                    create_event_int(player, "attribute-changed", ATTRIBUTE_GENRE);
+                }
+                index++;
             }
-            player->has_metadata = TRUE;
-            create_event_int(player, "attribute-changed", ATTRIBUTE_ARTIST);
+            g_strfreev(split);
         }
 
-        if (strstr(mplayer_output->str, "Title: ") != 0) {
-            buf = strstr(mplayer_output->str, "Title:");
-            buf = strstr(mplayer_output->str, "Title: ") + strlen("Title: ");
-            buf = g_strchomp(buf);
-            if (player->title != NULL) {
-                g_free(player->title);
-                player->title = NULL;
-            }
+        if (g_regex_match(player->title_regex, mplayer_output->str, 0, NULL)) {
+            split = g_regex_split(player->title_regex, mplayer_output->str, 0);
+            index = 0;
+            while (split[index]) {
+                if (strlen(split[index]) > 0) {
+                    if (player->title != NULL) {
+                        g_free(player->title);
+                        player->title = NULL;
+                    }
 
-            player->title = g_locale_to_utf8(buf, -1, NULL, NULL, NULL);
-            if (player->title == NULL) {
-                player->title = g_strdup(buf);
-                gm_str_strip_unicode(player->title, strlen(player->title));
+                    player->title = g_locale_to_utf8(split[index], -1, NULL, NULL, NULL);
+                    if (player->title == NULL) {
+                        player->title = g_strdup(split[index]);
+                        gm_str_strip_unicode(player->title, strlen(player->title));
+                    }
+                    player->has_metadata = TRUE;
+                    create_event_int(player, "attribute-changed", ATTRIBUTE_TITLE);
+                }
+                index++;
             }
-            player->has_metadata = TRUE;
-            create_event_int(player, "attribute-changed", ATTRIBUTE_TITLE);
+            g_strfreev(split);
         }
 
-        if (strstr(mplayer_output->str, "Artist: ") != 0) {
-            buf = strstr(mplayer_output->str, "Artist:");
-            buf = strstr(mplayer_output->str, "Artist: ") + strlen("Artist: ");
-            buf = g_strchomp(buf);
-            if (player->artist != NULL) {
-                g_free(player->artist);
-                player->artist = NULL;
-            }
+        if (g_regex_match(player->artist_regex, mplayer_output->str, 0, NULL)) {
+            split = g_regex_split(player->artist_regex, mplayer_output->str, 0);
+            index = 0;
+            while (split[index]) {
+                if (strlen(split[index]) > 0) {
+                    if (player->artist != NULL) {
+                        g_free(player->artist);
+                        player->artist = NULL;
+                    }
 
-            player->artist = g_locale_to_utf8(buf, -1, NULL, NULL, NULL);
-            if (player->artist == NULL) {
-                player->artist = g_strdup(buf);
-                gm_str_strip_unicode(player->artist, strlen(player->artist));
+                    player->artist = g_locale_to_utf8(split[index], -1, NULL, NULL, NULL);
+                    if (player->artist == NULL) {
+                        player->artist = g_strdup(split[index]);
+                        gm_str_strip_unicode(player->artist, strlen(player->artist));
+                    }
+                    player->has_metadata = TRUE;
+                    create_event_int(player, "attribute-changed", ATTRIBUTE_ARTIST);
+                }
+                index++;
             }
-            player->has_metadata = TRUE;
-            create_event_int(player, "attribute-changed", ATTRIBUTE_ARTIST);
+            g_strfreev(split);
         }
 
-        if (strstr(mplayer_output->str, "Album: ") != 0) {
-            buf = strstr(mplayer_output->str, "Album:");
-            buf = strstr(mplayer_output->str, "Album: ") + strlen("Album: ");
-            buf = g_strchomp(buf);
-            if (player->album != NULL) {
-                g_free(player->album);
-                player->album = NULL;
-            }
+        if (g_regex_match(player->album_regex, mplayer_output->str, 0, NULL)) {
+            split = g_regex_split(player->album_regex, mplayer_output->str, 0);
+            index = 0;
+            while (split[index]) {
+                if (strlen(split[index]) > 0) {
+                    if (player->album != NULL) {
+                        g_free(player->album);
+                        player->album = NULL;
+                    }
 
-            player->album = g_locale_to_utf8(buf, -1, NULL, NULL, NULL);
-            if (player->album == NULL) {
-                player->album = g_strdup(buf);
-                gm_str_strip_unicode(player->album, strlen(player->album));
+                    player->album = g_locale_to_utf8(split[index], -1, NULL, NULL, NULL);
+                    if (player->album == NULL) {
+                        player->album = g_strdup(split[index]);
+                        gm_str_strip_unicode(player->album, strlen(player->album));
+                    }
+                    player->has_metadata = TRUE;
+                    create_event_int(player, "attribute-changed", ATTRIBUTE_ALBUM);
+                }
+                index++;
             }
-            player->has_metadata = TRUE;
-            create_event_int(player, "attribute-changed", ATTRIBUTE_ALBUM);
+            g_strfreev(split);
         }
 
         if (player->minimum_mplayer == FALSE) {
@


1.12
log
@Fix issue #682: item names in "Items to Play" replaced with CPUID
string (upstream svn revision r220)
@
text
@d1 5
a5 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.11 2013/05/24 08:29:54 dcoppa Exp $
d20 34
a53 2
+++ src/gmtk_media_player.c	Wed Jun  5 09:52:48 2013
@@@@ -477,6 +477,12 @@@@ static void gmtk_media_player_init(GmtkMediaPlayer * p
d62 1
d67 1
a67 1
@@@@ -741,7 +747,7 @@@@ static gboolean player_key_press_event_callback(GtkWid
d76 1
a76 1
@@@@ -755,7 +761,7 @@@@ static gboolean player_key_press_event_callback(GtkWid
d85 1
a85 1
@@@@ -1119,7 +1125,7 @@@@ void gmtk_media_player_send_command(GmtkMediaPlayer * 
d94 1
a94 1
@@@@ -1147,11 +1153,12 @@@@ void gmtk_media_player_set_attribute_boolean(GmtkMedia
d109 1
a109 1
@@@@ -1775,6 +1782,14 @@@@ const gchar *gmtk_media_player_get_attribute_string(Gm
d124 128
a251 1
@@@@ -3042,6 +3057,7 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
d259 1
a259 1
@@@@ -3161,6 +3177,8 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
d268 1
a268 1
@@@@ -3635,94 +3653,120 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
@


1.11
log
@Update to gmtk-1.0.8
@
text
@d1 1
a1 1
$OpenBSD$
d12 3
d16 1
a16 1
+++ src/gmtk_media_player.c	Thu May 23 14:22:23 2013
d104 1
a104 1
@@@@ -3635,94 +3653,119 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
d116 2
a117 1
+        if (g_regex_match(player->name_regex, mplayer_output->str, 0, NULL)) {
@


1.10
log
@Update to gmtk-1.0.7.
Switch to gtk+3.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.9 2012/06/22 15:08:45 dcoppa Exp $
d3 2
a4 2
Set black background color for all GTK states on media widget
(upstream svn revision r105)
d6 2
a7 4
Fix a subtle segmentation fault at program exit time:
gmtk_media_player_dispose() would be called multiple times, leading
to a double free from gdk_color_free()
(upstream svn revision r143)
d9 2
a10 2
Fix a couple of keyboard shortcuts as they were in the wrong shift
state, similar to gnome-mplayer fix (upstream svn revision r118)
d12 13
a24 37
Correct situation where media player window allocation is too small
or incorrect (upstream svn revision r109)

Protect against possible divide by zero in gmtk_media_player_size_allocate
(upstream svn revision r111)

Monitor subtitle visibility better
(upstream svn revision r112)

Fix logic error in ERROR_RETRY
(upstream svn revision r107)

If mplayer emits a signal at position 0, retry once
(upstream svn revision r108)

Replace deprecated g_strncasecmp with g_ascii_strncasecmp
(upstream svn revision r106)

--- src/gmtk_media_player.c.orig	Fri Apr  6 15:19:32 2012
+++ src/gmtk_media_player.c	Fri Jun 22 16:47:51 2012
@@@@ -56,6 +56,11 @@@@ static void socket_realized(GtkWidget * widget, gpoint
     player->socket_id = GPOINTER_TO_INT(gtk_socket_get_id(GTK_SOCKET(widget)));
     style = gtk_widget_get_style(GTK_WIDGET(player));
     gtk_widget_modify_bg(GTK_WIDGET(player), GTK_STATE_NORMAL, &(style->black));
+    gtk_widget_modify_bg(GTK_WIDGET(player->alignment), GTK_STATE_NORMAL, &(style->black));
+    gtk_widget_modify_bg(GTK_WIDGET(player), GTK_STATE_ACTIVE, &(style->black));
+    gtk_widget_modify_bg(GTK_WIDGET(player), GTK_STATE_SELECTED, &(style->black));
+    gtk_widget_modify_bg(GTK_WIDGET(player), GTK_STATE_PRELIGHT, &(style->black));
+    gtk_widget_modify_bg(GTK_WIDGET(player), GTK_STATE_INSENSITIVE, &(style->black));
     if (player->vo != NULL) {
         if (!(g_ascii_strncasecmp(player->vo, "vdpau", strlen("vdpau")) == 0)) {
             gtk_widget_modify_bg(GTK_WIDGET(player->socket), GTK_STATE_NORMAL, &(style->black));
@@@@ -338,6 +343,7 @@@@ static void gmtk_media_player_init(GmtkMediaPlayer * p
     player->profile = NULL;
     player->alang = NULL;
     player->slang = NULL;
+    player->disposed = FALSE;
d27 45
a71 2
 static void gmtk_media_player_dispose(GObject * object)
@@@@ -345,6 +351,11 @@@@ static void gmtk_media_player_dispose(GObject * object
d73 12
a84 1
     GmtkMediaPlayer *player = GMTK_MEDIA_PLAYER(object);
d86 18
a103 6
+    if (player->disposed) {
+        return;
+    }
+    player->disposed = TRUE;
+
     // cleanup the memory used
d105 36
a140 35
     if (player->uri != NULL) {
@@@@ -444,7 +455,7 @@@@ static gboolean player_key_press_event_callback(GtkWid
     if (event->is_modifier)
         return TRUE;
 
-    if ((event->state & GDK_SHIFT_MASK) == 0 && (event->state & GDK_CONTROL_MASK) == 0
+    if ((event->state & GDK_CONTROL_MASK) == 0
         && (event->state & GDK_MOD1_MASK) == 0) {
         switch (event->keyval) {
         case GDK_Right:
@@@@ -635,6 +646,15 @@@@ static void gmtk_media_player_size_allocate(GtkWidget 
     gdouble widget_aspect;
     gfloat xscale, yscale;
 
+    if (allocation->width == 0 || allocation->height == 0) {
+        gmtk_get_allocation(widget, allocation);
+    }
+
+    // protect against possible divide by zero
+    if (allocation->width == 0 || allocation->height == 0) {
+        return;
+    }
+
     if (player->video_width == 0 || player->video_height == 0 || !gmtk_widget_get_realized(widget)) {
         gtk_alignment_set(GTK_ALIGNMENT(player->alignment), 0.0, 0.0, 1.0, 1.0);
     } else {
@@@@ -1018,9 +1038,7 @@@@ gboolean gmtk_media_player_get_attribute_boolean(GmtkM
 
     switch (attribute) {
     case ATTRIBUTE_SUB_VISIBLE:
-        if (g_list_length(player->subtitles) != 0) {
-            ret = player->sub_visible;
-        }
+        ret = player->sub_visible;
         break;
d142 36
a177 31
     case ATTRIBUTE_ENABLE_FRAME_DROP:
@@@@ -2578,10 +2596,10 @@@@ gpointer launch_mplayer(gpointer data)
             break;
         case ERROR_RETRY:
             if (last_error == NO_ERROR) {
-                last_error == ERROR_RETRY;
+                last_error = ERROR_RETRY;
             } else {
-                last_error == NO_ERROR;
-                player->playback_error == NO_ERROR;
+                last_error = NO_ERROR;
+                player->playback_error = NO_ERROR;
             }
             break;
 
@@@@ -2679,10 +2697,18 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
             if (player->position == 0) {
                 player->playback_error = ERROR_RETRY;
             }
+        } else if (strstr(mplayer_output->str, "filter video") != NULL) {
+            player->playback_error = ERROR_RETRY;
         } else {
             error_msg = g_strdup(mplayer_output->str);
         }
     }
+    if (strstr(mplayer_output->str, "Error when calling vdp_output_surface_create") != NULL) {
+        create_event_int(player, "attribute-changed", ATTRIBUTE_SIZE);
+        if (player->position == 0) {
+            player->playback_error = ERROR_RETRY;
+        }
+    }
d179 36
a214 22
     if (strstr(mplayer_output->str, "Failed creating VDPAU decoder") != NULL) {
         if (player->enable_divx && (g_ascii_strncasecmp(player->vo, "vdpau", strlen("vdpau")) == 0))
@@@@ -2886,6 +2912,7 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
                 create_event_allocation(player, "size_allocate", &allocation);
                 player->video_present = TRUE;
                 write_to_mplayer(player, "get_property sub_source\n");
+                write_to_mplayer(player, "get_property sub_visibility\n");
                 create_event_int(player, "attribute-changed", ATTRIBUTE_SIZE);
                 create_event_int(player, "attribute-changed", ATTRIBUTE_VIDEO_PRESENT);
                 create_event_int(player, "subtitles-changed", g_list_length(player->subtitles));
@@@@ -2993,6 +3020,14 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
             create_event_int(player, "attribute-changed", ATTRIBUTE_SUBTITLE);
         }
 
+        if (strstr(mplayer_output->str, "ANS_sub_visibility") != 0) {
+            if (strstr(mplayer_output->str, "ANS_sub_visibility=yes") != 0) {
+                player->sub_visible = TRUE;
+            } else {
+                player->sub_visible = FALSE;
+            }
+            create_event_int(player, "attribute-changed", ATTRIBUTE_SUB_VISIBLE);
+        }
d216 35
a250 4
         if (strstr(mplayer_output->str, "DVDNAV_TITLE_IS_MENU") != 0) {
             player->title_is_menu = TRUE;
@@@@ -3463,6 +3498,12 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
             message = NULL;
d253 36
a288 7
+        if (strstr(mplayer_output->str, "ID_SIGNAL") != 0) {
+            if (player->position == 0) {
+                player->playback_error = ERROR_RETRY;
+            }
+        }
+
     }
d290 1
a290 10
     g_string_free(mplayer_output, TRUE);
@@@@ -3521,7 +3562,7 @@@@ gboolean write_to_mplayer(GmtkMediaPlayer * player, co
         if (player->use_mplayer2) {
             pkf_cmd = g_strdup(cmd);
         } else {
-            if (g_strncasecmp(cmd, "pause", strlen("pause")) == 0) {
+            if (g_ascii_strncasecmp(cmd, "pause", strlen("pause")) == 0) {
                 pkf_cmd = g_strdup(cmd);
             } else {
                 pkf_cmd = g_strdup_printf("pausing_keep_force %s", cmd);
@


1.9
log
@Fix a subtle segmentation fault at program exit time:
gmtk_media_player_dispose() would be called multiple times, leading
to a double free from gdk_color_free()
(upstream svn revision r143)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.8 2012/06/13 07:50:11 dcoppa Exp $
@


1.8
log
@Fix a couple of keyboard shortcuts as they were in the wrong shift
state, similar to gnome-mplayer fix (upstream svn revision r118)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.7 2012/05/09 14:19:37 dcoppa Exp $
d6 5
d33 1
a33 1
+++ src/gmtk_media_player.c	Wed Jun 13 09:41:41 2012
d46 21
a66 1
@@@@ -444,7 +449,7 @@@@ static gboolean player_key_press_event_callback(GtkWid
d75 1
a75 1
@@@@ -635,6 +640,15 @@@@ static void gmtk_media_player_size_allocate(GtkWidget 
d91 1
a91 1
@@@@ -1018,9 +1032,7 @@@@ gboolean gmtk_media_player_get_attribute_boolean(GmtkM
d102 1
a102 1
@@@@ -2578,10 +2590,10 @@@@ gpointer launch_mplayer(gpointer data)
d116 1
a116 1
@@@@ -2679,10 +2691,18 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
d135 1
a135 1
@@@@ -2886,6 +2906,7 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
d143 1
a143 1
@@@@ -2993,6 +3014,14 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
d158 1
a158 1
@@@@ -3463,6 +3492,12 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
d171 1
a171 1
@@@@ -3521,7 +3556,7 @@@@ gboolean write_to_mplayer(GmtkMediaPlayer * player, co
@


1.7
log
@
Monitor subtitle visibility better

From upstream svn
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.6 2012/05/03 15:18:50 dcoppa Exp $
d6 3
d28 1
a28 1
+++ src/gmtk_media_player.c	Wed May  9 15:26:51 2012
d41 9
@


1.6
log
@Several bugfixes from upstream svn (see patches for details)
@
text
@d1 1
a1 1
$OpenBSD$
d12 3
d25 1
a25 1
+++ src/gmtk_media_player.c	Thu May  3 14:25:30 2012
d54 12
a65 1
@@@@ -2578,10 +2592,10 @@@@ gpointer launch_mplayer(gpointer data)
d79 1
a79 1
@@@@ -2679,10 +2693,18 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
d98 24
a121 1
@@@@ -3463,6 +3485,12 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
d134 1
a134 1
@@@@ -3521,7 +3549,7 @@@@ gboolean write_to_mplayer(GmtkMediaPlayer * player, co
@


1.5
log
@Update to 1.0.6
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.4 2012/04/06 10:13:55 dcoppa Exp $
d3 2
a4 2
Fix error when shifting protocol from mms to mmsh
(upstream svn revision r92)
d6 2
a7 2
Allow one decoding error restart
(upstream svn revision r93)
d9 29
a37 16
Only do the restart on decoding error if the position is 0
(upstream svn revision r94)

Fix a crash by resetting codecs variables to NULL after
g_free has been called (upstream svn revision r95)

Kill GTK widget oversize warning
(upstream svn revision r98)

Assign NULL to freed strings
(upstream svn revision r102)

--- src/gmtk_media_player.c.orig	Mon Feb 20 21:40:13 2012
+++ src/gmtk_media_player.c	Fri Apr  6 11:01:10 2012
@@@@ -89,13 +89,15 @@@@ gboolean signal_event(gpointer data)
             break;
d39 24
a62 4
         case EVENT_TYPE_ALLOCATION:
-            g_signal_emit_by_name(event->player, event->event_name, event->event_allocation);
+            if (!(event->event_allocation->width >= 65535 || event->event_allocation->height >= 65535))
+                g_signal_emit_by_name(event->player, event->event_name, event->event_allocation);
d65 8
a72 2
         default:
             printf("undefined event %s\n", event->event_name);
a73 2
         g_free(event->event_name);
+        event->event_name = NULL;
d75 6
a80 16
     if (event)
         g_free(event);
@@@@ -752,6 +754,7 @@@@ void gmtk_media_player_set_uri(GmtkMediaPlayer * playe
         g_free(cmd);
         if (filename != NULL) {
             g_free(filename);
+            filename = NULL;
         }
         if (player->media_state == MEDIA_STATE_STOP) {
             gmtk_media_player_set_state(player, MEDIA_STATE_PLAY);
@@@@ -892,6 +895,7 @@@@ void gmtk_media_player_send_command(GmtkMediaPlayer * 
                                 g_dgettext(GETTEXT_PACKAGE, "Frame Dropping"));
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
             break;
d82 4
a85 86
         default:
@@@@ -913,6 +917,7 @@@@ void gmtk_media_player_set_attribute_boolean(GmtkMedia
             cmd = g_strdup_printf("set_property sub_visibility %i\n", value);
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
             if (value) {
                 cmd =
                     g_strdup_printf("osd_show_property_text \"%s\"\n",
@@@@ -923,6 +928,7 @@@@ void gmtk_media_player_set_attribute_boolean(GmtkMedia
             }
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
         }
         break;
 
@@@@ -932,6 +938,7 @@@@ void gmtk_media_player_set_attribute_boolean(GmtkMedia
             cmd = g_strdup_printf("frame_drop %i\n", value);
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
         }
         break;
 
@@@@ -953,6 +960,7 @@@@ void gmtk_media_player_set_attribute_boolean(GmtkMedia
             cmd = g_strdup_printf("mute %i\n", value);
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
         }
         break;
 
@@@@ -1142,6 +1150,7 @@@@ void gmtk_media_player_set_attribute_double(GmtkMediaP
             }
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
         }
         break;
 
@@@@ -1151,6 +1160,7 @@@@ void gmtk_media_player_set_attribute_double(GmtkMediaP
             cmd = g_strdup_printf("speed_set %f\n", player->speed_multiplier);
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
         }
         break;
 
@@@@ -1160,6 +1170,7 @@@@ void gmtk_media_player_set_attribute_double(GmtkMediaP
             cmd = g_strdup_printf("sub_scale %f 1\n", player->subtitle_scale);
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
         }
         break;
 
@@@@ -1169,6 +1180,7 @@@@ void gmtk_media_player_set_attribute_double(GmtkMediaP
             cmd = g_strdup_printf("set_property sub_delay %f 1\n", player->subtitle_delay);
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
         }
         break;
 
@@@@ -1178,6 +1190,7 @@@@ void gmtk_media_player_set_attribute_double(GmtkMediaP
             cmd = g_strdup_printf("set_property audio_delay %f 1\n", player->audio_delay);
             write_to_mplayer(player, cmd);
             g_free(cmd);
+            cmd = NULL;
         }
         break;
 
@@@@ -1278,6 +1291,7 @@@@ void gmtk_media_player_set_attribute_string(GmtkMediaP
     case ATTRIBUTE_VO:
         if (player->vo != NULL) {
             g_free(player->vo);
+            player->vo = NULL;
         }
         if (value == NULL || strlen(value) == 0) {
             player->vo = NULL;
@@@@ -1289,6 +1303,7 @@@@ void gmtk_media_player_set_attribute_string(GmtkMediaP
     case ATTRIBUTE_AO:
         if (player->ao != NULL) {
             g_free(player->ao);
+            player->ao = NULL;
a86 68
         if (value == NULL || strlen(value) == 0) {
             player->ao = NULL;
@@@@ -1300,6 +1315,7 @@@@ void gmtk_media_player_set_attribute_string(GmtkMediaP
     case ATTRIBUTE_MEDIA_DEVICE:
         if (player->media_device != NULL) {
             g_free(player->media_device);
+            player->media_device = NULL;
         }
         if (value == NULL || strlen(value) == 0) {
             player->media_device = NULL;
@@@@ -1311,6 +1327,7 @@@@ void gmtk_media_player_set_attribute_string(GmtkMediaP
     case ATTRIBUTE_EXTRA_OPTS:
         if (player->extra_opts != NULL) {
             g_free(player->extra_opts);
+            player->extra_opts = NULL;
         }
         if (value == NULL || strlen(value) == 0) {
             player->extra_opts = NULL;
@@@@ -1322,6 +1339,7 @@@@ void gmtk_media_player_set_attribute_string(GmtkMediaP
     case ATTRIBUTE_MPLAYER_BINARY:
         if (player->mplayer_binary != NULL) {
             g_free(player->mplayer_binary);
+            player->mplayer_binary = NULL;
         }
         if (value == NULL || strlen(value) == 0) {
             player->mplayer_binary = NULL;
@@@@ -1334,6 +1352,7 @@@@ void gmtk_media_player_set_attribute_string(GmtkMediaP
     case ATTRIBUTE_AUDIO_TRACK_FILE:
         if (player->audio_track_file != NULL) {
             g_free(player->audio_track_file);
+            player->audio_track_file = NULL;
         }
         if (value == NULL || strlen(value) == 0) {
             player->audio_track_file = NULL;
@@@@ -1941,6 +1960,7 @@@@ gpointer launch_mplayer(gpointer data)
     gchar *codecs_vdpau = NULL;
     gchar *codecs_crystalhd = NULL;
     gchar *codecs = NULL;
+    GmtkMediaPlayerPlaybackError last_error = NO_ERROR;
 #ifdef GIO_ENABLED
     GFile *file;
 #endif
@@@@ -2086,18 +2106,23 @@@@ gpointer launch_mplayer(gpointer data)
             codecs = g_strconcat(codecs_vdpau, codecs_crystalhd, NULL);
             g_free(codecs_vdpau);
             g_free(codecs_crystalhd);
+            codecs_vdpau = NULL;
+            codecs_crystalhd = NULL;
         } else if (codecs_vdpau) {
             codecs = g_strdup(codecs_vdpau);
             g_free(codecs_vdpau);
+            codecs_vdpau = NULL;
         } else if (codecs_crystalhd) {
             codecs = g_strdup(codecs_crystalhd);
             g_free(codecs_crystalhd);
+            codecs_crystalhd = NULL;
         }
 
         if (codecs != NULL) {
             argv[argn++] = g_strdup_printf("-vc");
             argv[argn++] = g_strdup_printf("%s", codecs);
             g_free(codecs);
+            codecs = NULL;
         }
 
         if (player->ao != NULL) {
@@@@ -2535,7 +2560,7 @@@@ gpointer launch_mplayer(gpointer data)
             break;
d88 1
a88 28
         case ERROR_RETRY_WITH_MMSHTTP:
-            tmp = gmtk_media_player_switch_protocol(player->uri, "http");
+            tmp = gmtk_media_player_switch_protocol(player->uri, "mmsh");
             g_free(player->uri);
             player->uri = tmp;
             break;
@@@@ -2551,6 +2576,14 @@@@ gpointer launch_mplayer(gpointer data)
         case ERROR_RETRY_ALSA_BUSY:
         case ERROR_RETRY_VDPAU:
             break;
+        case ERROR_RETRY:
+            if (last_error == NO_ERROR) {
+                last_error == ERROR_RETRY;
+            } else {
+                last_error == NO_ERROR;
+                player->playback_error == NO_ERROR;
+            }
+            break;
 
         case ERROR_RETRY_WITHOUT_HARDWARE_CODECS:
             player->enable_hardware_codecs = FALSE;
@@@@ -2641,7 +2674,14 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
     }
 
     if (strstr(mplayer_output->str, "signal") != NULL) {
-        error_msg = g_strdup(mplayer_output->str);
+        if (strstr(mplayer_output->str, "decode") != NULL) {
+            create_event_int(player, "attribute-changed", ATTRIBUTE_SIZE);
a91 2
+        } else {
+            error_msg = g_strdup(mplayer_output->str);
a92 11
     }
 
     if (strstr(mplayer_output->str, "Failed creating VDPAU decoder") != NULL) {
@@@@ -2688,6 +2728,11 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
         }
     }
 
+    if (strstr(mplayer_output->str, "MPlayer interrupted by signal 13 in module: open_stream") != NULL
+        && g_strrstr(player->uri, "mms://") != NULL) {
+        player->playback_error = ERROR_RETRY_WITH_MMSHTTP;
+    }
a93 16
     if (strstr(mplayer_output->str, "No stream found to handle url mmshttp://") != NULL) {
         player->playback_error = ERROR_RETRY_WITH_HTTP;
     }
@@@@ -2751,13 +2796,14 @@@@ gboolean thread_reader_error(GIOChannel * source, GIOC
         create_event_int(player, "attribute-changed", ATTRIBUTE_TITLE);
     }
 
-    if (error_msg != NULL) {
+    if (error_msg != NULL && player->playback_error == NO_ERROR) {
         dialog = gtk_message_dialog_new(NULL, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR,
                                         GTK_BUTTONS_CLOSE, "%s", error_msg);
         gtk_window_set_title(GTK_WINDOW(dialog), g_dgettext(GETTEXT_PACKAGE, "GNOME MPlayer Error"));
         gtk_dialog_run(GTK_DIALOG(dialog));
         gtk_widget_destroy(dialog);
         g_free(error_msg);
+        error_msg = NULL;
d97 9
a105 43
@@@@ -3373,6 +3419,7 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
 
                 }
                 g_free(icy);
+                icy = NULL;
                 g_free(message);
                 message = NULL;
             }
@@@@ -3411,6 +3458,7 @@@@ gboolean thread_reader(GIOChannel * source, GIOConditi
 
             }
             g_free(icy);
+            icy = NULL;
             g_free(message);
             message = NULL;
         }
@@@@ -3536,10 +3584,14 @@@@ gboolean detect_mplayer_features(GmtkMediaPlayer * pla
         printf("Error when running: %s\n", error->message);
         g_error_free(error);
         error = NULL;
-        if (out != NULL)
+        if (out != NULL) {
             g_free(out);
-        if (err != NULL)
+            out = NULL;
+        }
+        if (err != NULL) {
             g_free(err);
+            err = NULL;
+        }
         return FALSE;
     }
     output = g_strsplit(out, "\n", 0);
@@@@ -3555,7 +3607,9 @@@@ gboolean detect_mplayer_features(GmtkMediaPlayer * pla
     }
     g_strfreev(output);
     g_free(out);
+    out = NULL;
     g_free(err);
+    err = NULL;
 
     player->features_detected = TRUE;
     if (!ret) {
@


1.4
log
@Bugfixes from upstream
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3
log
@Update gmtk and gnome-mplayer to 1.0.6beta1
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.2 2012/03/06 08:50:54 dcoppa Exp $
d3 2
a4 2
Only allocate a size for the child window if the parent widget is
realized (upstream svn revision r87)
d6 2
a7 2
Add '-zoom' to mplayer when vo is x11
(upstream svn revision r84)
d9 269
a277 18
--- src/gmtk_media_player.c.orig	Tue Dec 20 21:54:35 2011
+++ src/gmtk_media_player.c	Tue Mar  6 09:35:09 2012
@@@@ -632,7 +632,7 @@@@ static void gmtk_media_player_size_allocate(GtkWidget 
     gdouble widget_aspect;
     gfloat xscale, yscale;
 
-    if (player->video_width == 0 || player->video_height == 0) {
+    if (player->video_width == 0 || player->video_height == 0 || !gmtk_widget_get_realized(widget)) {
         gtk_alignment_set(GTK_ALIGNMENT(player->alignment), 0.0, 0.0, 1.0, 1.0);
     } else {
         switch (player->aspect_ratio) {
@@@@ -2050,6 +2050,9 @@@@ gpointer launch_mplayer(gpointer data)
                     argv[argn++] = g_strdup_printf("gl_nosw");
                 } else {
                     argv[argn++] = g_strdup_printf("%s", player->vo);
+                    if (g_ascii_strncasecmp(player->vo, "x11", strlen("x11")) == 0) {
+                        argv[argn++] = g_strdup_printf("-zoom");
+                    }
d279 37
d317 2
a318 1
                 if (player->deinterlace) {
@


1.2
log
@Only allocate a size for the child window if the parent widget is
realized (upstream svn revision r87)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_gmtk_media_player_c,v 1.1 2012/01/23 11:01:34 dcoppa Exp $
@


1.1
log
@Add '-zoom' to mplayer when vo is x11
(upstream svn revision r84)
@
text
@d1 4
a4 1
$OpenBSD$
d9 11
a19 2
--- src/gmtk_media_player.c.orig	Mon Jan 23 11:52:38 2012
+++ src/gmtk_media_player.c	Mon Jan 23 11:54:58 2012
@

