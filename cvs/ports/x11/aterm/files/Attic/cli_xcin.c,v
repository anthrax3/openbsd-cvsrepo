head	1.2;
access;
symbols
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.46
	OPENBSD_5_0:1.1.0.44
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.42
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.40
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.38
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.36
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.34
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.32
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.30
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.28
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.26
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.24
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.22
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.20
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.18
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.16
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.14
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.12
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.10
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.8
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.04.26.19.18.08;	author jasper;	state dead;
branches;
next	1.1;

1.1
date	2001.04.17.03.41.03;	author kevlo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove aterm, it's been unmaintained upstream since they've started working
on rxvt-unicode instead....about four years ago.

ok aja@@ dcoppa@@
@
text
@/*
	Copyright (C) 1994,1995	Edward Der-Hua Liu, Hsin-Chu, Taiwan
*/

#include <stdio.h>
#include <stdarg.h>
#include <sys/types.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include "state.h"
#include "protocol.h"

/*static void p_err(char *fmt,...)
{
  va_list args;
  
  va_start(args, fmt);
  fprintf(stderr,"%s:", "cli_xcin:");
  vfprintf(stderr, fmt, args);
  va_end(args);
  fprintf(stderr,"\n");
  exit(-1);
} 
*/


static Atom xcin_atom=0;
static Window xcin_win=None;
static InmdState inmdstate;
#define ENDIAN_TEST() (*(int *)"\x11\x22\x33\x44"==0x11223344)
char my_endian;

static int connect_xcin(Display *display)
{
/*Window twin;*/
xcin_atom=XInternAtom(display, XCIN_ATOM,False);
my_endian=ENDIAN_TEST();  /* if == 11223344, it is big-endian */

xcin_win=XGetSelectionOwner(display,xcin_atom);
return xcin_win;
}

void send_FocusIn(Display *display, Window window)
{
	XClientMessageEvent event;
	/*XEvent erreve;*/
	char *tmp=event.data.b;

	if (connect_xcin(display)==None) return;
/* Ensure xcin exists, or the process will be hanged */
	event.type=ClientMessage;
	event.window=window;
	event.message_type=xcin_atom;
	event.format=8;
	
	tmp[0]=tmp[1]=tmp[2]=0xff;
	tmp[3]=CLI_FOCUS_IN;
	memcpy(&tmp[4],&inmdstate, sizeof(inmdstate));
	XSendEvent(display, xcin_win, False, 0, (XEvent *)&event);
}

void send_FocusOut(Display *display, Window window)
{
	XClientMessageEvent event;
/*	XEvent erreve; */
	char *tmp=event.data.b;

	if (connect_xcin(display)==None) return;
/* Ensure xcin exists, or the process will be hanged */
	event.type=ClientMessage;
	event.window=window;
	event.message_type=xcin_atom;
	event.format=8;
	
	tmp[0]=tmp[1]=tmp[2]=0xff;
	tmp[3]=CLI_FOCUS_OUT;
	memcpy(&tmp[4],&inmdstate, sizeof(inmdstate));
	XSendEvent(display, xcin_win, False, 0, (XEvent *)&event);
}

static void big_little(char *i)
{
char t;
t=*i; *i=*(i+3); *(i+3)=t;
t=*(i+1); *(i+1)=*(i+2); *(i+2)=t;
}
static int read_keys(Display *display, char *buf)
{
	Atom actual_type;
	int actual_format/*,i*/;
	u_long nitems,bytes_after;
	char *ttt, *cp;
	XCIN_RES res;
	int ofs;
 
	cp=(char *)&res;
	ofs=0;
	do { 
	if (XGetWindowProperty(display,xcin_win,xcin_atom,
		ofs/4,(sizeof(XCIN_RES)+3)/4,
		True, AnyPropertyType, &actual_type,&actual_format,
		&nitems,&bytes_after,(unsigned char **)&ttt) != Success)
			puts("err property");
		memcpy((char *)(&res)+(ofs & ~0x3), ttt, nitems);
		XFree(ttt);
		ofs=(ofs & ~0x3) + nitems;
	} while ((!nitems && !ofs) || bytes_after>0);
	if (my_endian) {
		big_little((char *)&res.len);
		big_little((char *)&res.status);
	}
	memcpy(buf,res.tkey, res.len);
	inmdstate=res.inmdstate;
	buf[res.len]=0;
 
	return  res.status;
}

#include <X11/Xutil.h>

static XComposeStatus compose_status = {NULL, 0};

int send_key(Display *display, Window win, XKeyEvent *eve, char *buf)
{
XClientMessageEvent event;
/*XEvent erreve;*/
char *tmp=event.data.b;
u_char tttt[8];
/*KeySym keysym;*/
int count;

if (xcin_win==None && connect_xcin(display)==None)
	return K_REJECT;
if ((xcin_win=XGetSelectionOwner(display,xcin_atom))==None)
	return K_REJECT;

event.type=ClientMessage;
event.window=win;
event.message_type=xcin_atom;
event.format=32;
count = XLookupString (eve, tttt, sizeof(tmp), (KeySym *)tmp, &compose_status);
memcpy(&tmp[4],&eve->state,4);
XSendEvent(display, xcin_win, False, 0, (XEvent *)&event);
XSync(display,False);
return (read_keys(display, buf));
}
@


1.1
log
@- support Big5 encoding with chinese/xcin
- integrate COMMENT
- bump NEED_VERSION
--
ok'd by maintainer
@
text
@@

