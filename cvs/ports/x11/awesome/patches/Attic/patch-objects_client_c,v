head	1.17;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@# @;


1.17
date	2016.03.07.11.33.59;	author dcoppa;	state dead;
branches;
next	1.16;
commitid	7zUqqCR47GCkIAqa;

1.16
date	2016.03.01.11.42.24;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	QAoVD7PgkclyraIQ;

1.15
date	2016.02.01.08.26.23;	author dcoppa;	state dead;
branches;
next	1.14;
commitid	b8Z8D2Rds0QfNlTK;

1.14
date	2016.01.27.15.18.05;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	zO42Vzz8VkZuapnh;

1.13
date	2016.01.18.09.50.09;	author dcoppa;	state dead;
branches;
next	1.12;
commitid	lrRI65aKSWqF9Rnn;

1.12
date	2015.11.09.14.36.12;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	LYfZ9mVasxXSCMq6;

1.11
date	2015.03.17.15.45.37;	author dcoppa;	state Exp;
branches;
next	1.10;
commitid	T2ZC5Vp0YgH8LCSY;

1.10
date	2015.01.12.09.00.17;	author dcoppa;	state dead;
branches;
next	1.9;
commitid	ZXrBV9TNCMLtawvr;

1.9
date	2014.12.16.11.16.05;	author dcoppa;	state Exp;
branches;
next	1.8;
commitid	4UkLQ4p6HUpxFojY;

1.8
date	2014.04.15.10.32.36;	author dcoppa;	state dead;
branches;
next	1.7;

1.7
date	2013.10.15.09.28.46;	author dcoppa;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.11.08.50.21;	author dcoppa;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.08.11.48.58;	author dcoppa;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.07.14.28.52;	author dcoppa;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.23.14.14.30;	author dcoppa;	state Exp;
branches;
next	1.2;

1.2
date	2013.08.21.04.58.49;	author dcoppa;	state Exp;
branches;
next	1.1;

1.1
date	2013.05.22.15.05.50;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.17
log
@
Update to awesome-3.5.9
@
text
@$OpenBSD: patch-objects_client_c,v 1.16 2016/03/01 11:42:24 dcoppa Exp $

commit 64748671cd8de154092be76e28b4a06080712d76
Author: Uli Schlachter <psychon@@znc.in>
Date:   Tue Feb 16 19:31:20 2016 +0100

Don't modify WM_HINTS in client_set_urgent()

To quote from ICCCM (_4.1.2): "The window manager will not change properties
written by the client."

We tried to do this anyway to update WM_HINTS so that the current urgency state
is reflected. Apparently, Chrome does a similar read-modify-set cycle and the
resulting race condition meant that the "accepts input" hint on Chromium's
window was permanently disabled.

This helps with https://github.com/awesomeWM/awesome/issues/670, but I still
think that Chrome shouldn't try to implement "please don't focus me when I do
the following" by temporarily claiming "please don't ever focus me".

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit e54d911a94697eb5fd5b7d5ac2a72e4d3be6194b
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sun Feb 28 13:29:25 2016 +0100

Make client key bindings for e.g. xeyes work again

Instead of focusing the root window, we now create a "focus window" inside of
our frame window. This window is placed so that it is not visible, but we can
grab key bindings on it to simulate the window having the input focus.

Fixes: https://github.com/awesomeWM/awesome/issues/699
Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit dfe44a15711eef0c236cea48c0ab30ec6bf764a3
Author: Uli Schlachter <psychon@@znc.in>
Date:   Thu Feb 4 18:21:25 2016 +0100

Always send ConfigureNotifies

ICCCM specifies when the WM has to send a ConfigureNotify. Java does not care
and wants one all the time. Meh.

Fixes: #248
Signed-off-by: Uli Schlachter <psychon@@znc.in>

--- objects/client.c.orig	Sat Jan 30 14:55:18 2016
+++ objects/client.c	Tue Mar  1 11:24:18 2016
@@@@ -71,22 +71,8 @@@@ client_set_urgent(lua_State *L, int cidx, bool urgent)
 
     if(c->urgent != urgent)
     {
-        xcb_get_property_cookie_t hints =
-            xcb_icccm_get_wm_hints_unchecked(globalconf.connection, c->window);
-
         c->urgent = urgent;
 
-        /* update ICCCM hints */
-        xcb_icccm_wm_hints_t wmh;
-        xcb_icccm_get_wm_hints_reply(globalconf.connection, hints, &wmh, NULL);
-
-        if(urgent)
-            wmh.flags |= XCB_ICCCM_WM_HINT_X_URGENCY;
-        else
-            wmh.flags &= ~XCB_ICCCM_WM_HINT_X_URGENCY;
-
-        xcb_icccm_set_wm_hints(globalconf.connection, c->window, &wmh);
-
         luaA_object_emit_signal(L, cidx, "property::urgent", 0);
     }
 }
@@@@ -178,6 +164,16 @@@@ client_getbywin(xcb_window_t w)
     return NULL;
 }
 
+client_t *
+client_getbynofocuswin(xcb_window_t w)
+{
+    foreach(c, globalconf.clients)
+        if((*c)->nofocus_window == w)
+            return *c;
+
+    return NULL;
+}
+
 /** Get a client by its frame window.
  * \param w The client window to find.
  * \return A client pointer if found, NULL otherwise.
@@@@ -340,6 +336,20 @@@@ client_focus(client_t *c)
     globalconf.focus.need_update = true;
 }
 
+static xcb_window_t
+client_get_nofocus_window(client_t *c)
+{
+    if (c->nofocus_window == XCB_NONE) {
+        c->nofocus_window = xcb_generate_id(globalconf.connection);
+        xcb_create_window(globalconf.connection, globalconf.default_depth, c->nofocus_window, c->frame_window,
+                          -2, -2, 1, 1, 0, XCB_COPY_FROM_PARENT, globalconf.visual->visual_id,
+                          0, NULL);
+        xcb_map_window(globalconf.connection, c->nofocus_window);
+        xwindow_grabkeys(c->nofocus_window, &c->keys);
+    }
+    return c->nofocus_window;
+}
+
 void
 client_focus_refresh(void)
 {
@@@@ -358,11 +368,7 @@@@ client_focus_refresh(void)
         if(!c->nofocus)
             win = c->window;
         else
-            /* Move the focus away from whatever has it to make sure the
-             * previously focused client doesn't get any input in case
-             * WM_TAKE_FOCUS gets ignored.
-             */
-            win = globalconf.focus.window_no_focus;
+            win = client_get_nofocus_window(c);
 
         if(client_hasproto(c, WM_TAKE_FOCUS))
             xwindow_takefocus(c->window);
@@@@ -741,13 +747,18 @@@@ client_resize_do(client_t *c, area_t geometry, bool fo
     bool send_notice = force_notice;
     bool hide_titlebars = c->fullscreen;
     screen_t *new_screen = screen_getbycoord(geometry.x, geometry.y);
+    bool java_is_broken = true;
 
     if (honor_hints)
         geometry = client_apply_size_hints(c, geometry);
 
     if(c->geometry.width == geometry.width
        && c->geometry.height == geometry.height)
+        /* We are moving without changing the size, see ICCCM 4.2.3 */
         send_notice = true;
+    if(java_is_broken)
+        /* Java strong. Java Hulk. Java make own rules! */
+        send_notice = true;
 
     /* Also store geometry including border */
     area_t old_geometry = c->geometry;
@@@@ -779,7 +790,6 @@@@ client_resize_do(client_t *c, area_t geometry, bool fo
             (uint32_t[]) { real_geometry.x, real_geometry.y, real_geometry.width, real_geometry.height });
 
     if(send_notice)
-        /* We are moving without changing the size, see ICCCM 4.2.3 */
         client_send_configure(c);
 
     client_restore_enterleave_events();
@@@@ -1236,6 +1246,8 @@@@ client_unmanage(client_t *c, bool window_valid)
 
     /* Ignore all spurious enter/leave notify events */
     client_ignore_enterleave_events();
+    if (c->nofocus_window != XCB_NONE)
+        xcb_destroy_window(globalconf.connection, c->nofocus_window);
     xcb_destroy_window(globalconf.connection, c->frame_window);
     client_restore_enterleave_events();
 
@@@@ -2285,6 +2297,8 @@@@ luaA_client_keys(lua_State *L)
         luaA_object_emit_signal(L, 1, "property::keys", 0);
         xcb_ungrab_key(globalconf.connection, XCB_GRAB_ANY, c->window, XCB_BUTTON_MASK_ANY);
         xwindow_grabkeys(c->window, keys);
+        if (c->nofocus_window)
+            xwindow_grabkeys(c->nofocus_window, &c->keys);
     }
 
     return luaA_key_array_get(L, 1, keys);
@


1.16
log
@
Merge several fixes from the stable '3.5' branch
@
text
@d1 1
a1 1
$OpenBSD$
@


1.15
log
@
Update to awesome-3.5.8
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.14 2016/01/27 15:18:05 dcoppa Exp $
d3 1
a3 1
commit f128b313130ad10dfa6a8e1bdf8e360038aee378
d5 1
a5 1
Date:   Sat Jan 23 13:14:30 2016 +0100
d7 1
a7 1
Fix window key grabbing
d9 2
a10 3
Commit ff799a0f5dba06b is incomplete. It changed the window on which we grab
keys, but only in some places. When the keyboard layout changes, we have to
re-grab these keys, but the code does so on the wrong window.
d12 4
a15 1
This patch fixes that oversight.
d17 29
a45 1
Fixes: https://github.com/awesomeWM/awesome/issues/639
d48 5
a52 3
--- objects/client.c.orig	Fri Jan 15 16:51:19 2016
+++ objects/client.c	Wed Jan 27 16:10:03 2016
@@@@ -2283,7 +2283,7 @@@@ luaA_client_keys(lua_State *L)
d54 107
a160 1
         luaA_key_array_set(L, 1, 2, keys);
d162 1
a162 2
-        xcb_ungrab_key(globalconf.connection, XCB_GRAB_ANY, c->frame_window, XCB_BUTTON_MASK_ANY);
+        xcb_ungrab_key(globalconf.connection, XCB_GRAB_ANY, c->window, XCB_BUTTON_MASK_ANY);
d164 2
d168 1
@


1.14
log
@
Merge fix from the stable '3.5' branch:

Fix window key grabbing
(git commit f128b313130ad10dfa6a8e1bdf8e360038aee378)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.13
log
@
Update to awesome-3.5.7
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.12 2015/11/09 14:36:12 dcoppa Exp $
d3 1
a3 1
commit facf51b8cbd614457e46efc8250707ba76d35bf6
d5 1
a5 1
Date:   Sat Oct 10 17:45:24 2015 +0200
d7 1
a7 1
Apply window gravity for border width changes
d9 3
a11 2
Together with the previous changes, this also fixes the initial positions for
metacity's test-gravity.c.
d13 1
a13 81
Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit 9b5ab994b024a42df38724a093509afe8eb89a8e
Author: Uli Schlachter <psychon@@znc.in>
Date:   Wed Sep 23 20:48:56 2015 +0200

Never explicitly focus the root window

Whenever client.focus == nil, we set the input focus to the root window to
express "nothing has the input focus". However, thanks to the way X11 input
works, this means that whatever is under the mouse cursor gets keyboard input
events. This can easily be reproduced with urxvt and some small addition to the
config to unfocus things.

This commit changes things. Instead of focusing the root window, we create a
special "no focus" window that gets focused if we want nothing to have the
focus.

Closes https://github.com/awesomeWM/awesome/pull/470.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit e7fbbf47e5ec30cba1ef55e0af6601c1b04e004f
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sat Oct 10 21:13:40 2015 +0200

Fix client_apply_size_hints()

The bit that indicates that the base size is set is
XCB_ICCCM_SIZE_HINT_BASE_SIZE. However, instead this code checked
XCB_ICCCM_SIZE_HINT_P_SIZE which is set to indicate how the initial window
position is chosen. So we were checking the complete wrong bit. Whoops...

Fixes: https://github.com/awesomeWM/awesome/issues/456

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit c03ee8ab362d9960d4742cb9c3baffa61db215c8
Author: Uli Schlachter <psychon@@znc.in>
Date:   Wed Feb 25 21:52:03 2015 +0100

Ignore more events while minimizing a client

When minimizing a client, we temporarily ignore events for the client window (so
that we don't get the UnmapNotify event that we are causing for the unmap) and
for the root window (I don't actually know why, no "harmful" events should be
caused...).

However, we weren't ignoring events on the frame window itself. This commit
fixes that oversight.

The problem here is that the pointer could be inside the window that is being
minimized. When we then unmap said window, the pointer will now be inside of the
frame window and the X11 server will thus generate an EnterNotify. When we
handle this event later on, we emit mouse::enter on the client and e.g. the
default config then focuses this client, which undoes the minimization.

This fixes a regression introduced in commit 3aeac3870ca4855 and fixes #92.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit 9c7cc12e5f1628b8dff65f78b0d513ee894aa598
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sat Oct 10 17:44:11 2015 +0200

Apply window gravity for titlebar resizes

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit ff799a0f5dba06beed9f13939237899e53ff8fd8
Author: Uli Schlachter <psychon@@znc.in>
Date:   Fri Oct 16 17:30:46 2015 +0200

Grab client keys on the client window (#496)

Before this, we grabbed the keys on the frame window. That meant we only got key
events for things that nothing else grabbed directly on the key window.

After this, we grab directly on the client window itself and so we "fight" with
everything else which wants to grab keys. I don't actually know how the winner
is decided... First come, first serve, the rest gets an error?
d15 1
d18 3
a20 82
--- objects/client.c.orig	Sat Jan 10 20:36:35 2015
+++ objects/client.c	Mon Nov  9 13:54:50 2015
@@@@ -36,6 +36,7 @@@@
 
 static area_t titlebar_get_area(client_t *c, client_titlebar_t bar);
 static drawable_t *titlebar_get_drawable(lua_State *L, client_t *c, int cl_idx, client_titlebar_t bar);
+static void client_resize_do(client_t *c, area_t geometry, bool force_notice, bool honor_hints);
 
 /** Collect a client.
  * \param L The Lua VM state.
@@@@ -343,7 +344,7 @@@@ void
 client_focus_refresh(void)
 {
     client_t *c = globalconf.focus.client;
-    xcb_window_t win = globalconf.screen->root;
+    xcb_window_t win = globalconf.focus.window_no_focus;
 
     if(!globalconf.focus.need_update)
         return;
@@@@ -357,10 +358,11 @@@@ client_focus_refresh(void)
         if(!c->nofocus)
             win = c->window;
         else
-            /* Focus the root window to make sure the previously focused client
-             * doesn't get any input in case WM_TAKE_FOCUS gets ignored.
+            /* Move the focus away from whatever has it to make sure the
+             * previously focused client doesn't get any input in case
+             * WM_TAKE_FOCUS gets ignored.
              */
-            win = globalconf.screen->root;
+            win = globalconf.focus.window_no_focus;
 
         if(client_hasproto(c, WM_TAKE_FOCUS))
             xwindow_takefocus(c->window);
@@@@ -376,6 +378,24 @@@@ client_focus_refresh(void)
 }
 
 static void
+border_width_callback(client_t *c, uint16_t old_width, uint16_t new_width)
+{
+    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_WIN_GRAVITY)
+    {
+        area_t geometry = c->geometry;
+        int16_t diff = new_width - old_width;
+        int16_t diff_x = 0, diff_y = 0;
+        xwindow_translate_for_gravity(c->size_hints.win_gravity,
+                                      diff, diff, diff, diff,
+                                      &diff_x, &diff_y);
+        geometry.x += diff_x;
+        geometry.y += diff_y;
+        /* force_notice = true -> inform client about changes */
+        client_resize_do(c, geometry, true, false);
+    }
+}
+
+static void
 client_update_properties(client_t *c)
 {
     /* get all hints */
@@@@ -446,6 +466,7 @@@@ client_manage(xcb_window_t w, xcb_get_geometry_reply_t
 
     client_t *c = client_new(globalconf.L);
     xcb_screen_t *s = globalconf.screen;
+    c->border_width_callback = (void (*) (void *, uint16_t, uint16_t)) border_width_callback;
 
     /* consider the window banned */
     c->isbanned = true;
@@@@ -623,7 +644,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
     /* Size hints are applied to the window without any decoration */
     client_remove_titlebar_geometry(c, &geometry);
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_SIZE)
+    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_BASE_SIZE)
     {
         basew = c->size_hints.base_width;
         baseh = c->size_hints.base_height;
@@@@ -642,7 +663,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
         minw = c->size_hints.min_width;
         minh = c->size_hints.min_height;
     }
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_SIZE)
+    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_BASE_SIZE)
a21 78
         /* min size is substituted with base size if not specified */
         minw = c->size_hints.base_width;
@@@@ -868,13 +889,18 @@@@ client_set_minimized(lua_State *L, int cidx, bool s)
             xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_ICONIC);
 
             uint32_t no_event[] = { 0 };
-            const uint32_t select_input_val[] = { CLIENT_SELECT_INPUT_EVENT_MASK };
+            const uint32_t client_select_input_val[] = { CLIENT_SELECT_INPUT_EVENT_MASK };
+            const uint32_t frame_select_input_val[] = { FRAME_SELECT_INPUT_EVENT_MASK };
             xcb_grab_server(globalconf.connection);
             xcb_change_window_attributes(globalconf.connection,
                                          globalconf.screen->root,
                                          XCB_CW_EVENT_MASK,
                                          no_event);
             xcb_change_window_attributes(globalconf.connection,
+                                         c->frame_window,
+                                         XCB_CW_EVENT_MASK,
+                                         no_event);
+            xcb_change_window_attributes(globalconf.connection,
                                          c->window,
                                          XCB_CW_EVENT_MASK,
                                          no_event);
@@@@ -884,9 +910,13 @@@@ client_set_minimized(lua_State *L, int cidx, bool s)
                                          XCB_CW_EVENT_MASK,
                                          ROOT_WINDOW_EVENT_MASK);
             xcb_change_window_attributes(globalconf.connection,
+                                         c->frame_window,
+                                         XCB_CW_EVENT_MASK,
+                                         frame_select_input_val);
+            xcb_change_window_attributes(globalconf.connection,
                                          c->window,
                                          XCB_CW_EVENT_MASK,
-                                         select_input_val);
+                                         client_select_input_val);
             xcb_ungrab_server(globalconf.connection);
         }
         else
@@@@ -1689,19 +1719,39 @@@@ titlebar_resize(client_t *c, client_titlebar_t bar, in
      * titlebars should keep its current size!) */
     area_t geometry = c->geometry;
     int change = size - c->titlebar[bar].size;
+    int16_t diff_top = 0, diff_bottom = 0, diff_right = 0, diff_left = 0;
     switch (bar) {
     case CLIENT_TITLEBAR_TOP:
+        geometry.height += change;
+        diff_top = change;
+        break;
     case CLIENT_TITLEBAR_BOTTOM:
         geometry.height += change;
+        diff_bottom = change;
         break;
     case CLIENT_TITLEBAR_RIGHT:
+        geometry.width += change;
+        diff_right = change;
+        break;
     case CLIENT_TITLEBAR_LEFT:
         geometry.width += change;
+        diff_left = change;
         break;
     default:
         fatal("Unknown titlebar kind %d\n", (int) bar);
     }
 
+    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_WIN_GRAVITY)
+    {
+        int16_t diff_x = 0, diff_y = 0;
+        xwindow_translate_for_gravity(c->size_hints.win_gravity,
+                                      diff_left, diff_top,
+                                      diff_right, diff_bottom,
+                                      &diff_x, &diff_y);
+        geometry.x += diff_x;
+        geometry.y += diff_y;
+    }
+
     c->titlebar[bar].size = size;
     client_resize_do(c, geometry, true, false);
 }
@@@@ -2234,7 +2284,7 @@@@ luaA_client_keys(lua_State *L)
d24 3
a26 3
         xcb_ungrab_key(globalconf.connection, XCB_GRAB_ANY, c->frame_window, XCB_BUTTON_MASK_ANY);
-        xwindow_grabkeys(c->frame_window, keys);
+        xwindow_grabkeys(c->window, keys);
a28 1
     return luaA_key_array_get(L, 1, keys);
@


1.12
log
@
Merge fixes from upstream (from the stable '3.5' branch)
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.11 2015/03/17 15:45:37 dcoppa Exp $
@


1.11
log
@
Merge bugfix from upstream:

ignore more events while minimizing a client

See: https://github.com/awesomeWM/awesome/commit/c03ee8ab362d9960d4742cb9c3baffa61db215c8
@
text
@d1 47
a47 1
$OpenBSD$
d73 109
a181 3
--- objects/client.c.orig	Sat Jan 10 13:36:35 2015
+++ objects/client.c	Mon Mar  2 03:12:51 2015
@@@@ -868,13 +868,18 @@@@ client_set_minimized(lua_State *L, int cidx, bool s)
d201 1
a201 1
@@@@ -884,9 +889,13 @@@@ client_set_minimized(lua_State *L, int cidx, bool s)
d216 49
@


1.10
log
@
Update to awesome-3.5.6, codename "For Those About To Rock"
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.9 2014/12/16 11:16:05 dcoppa Exp $
d3 1
a3 1
commit a44b3a2daffa52640a2be20b904156abf1c585e5
d5 1
a5 1
Date:   Sun Mar 30 14:58:03 2014 +0200
d7 1
a7 1
Don't set a background-pixel for our client frame windows
d9 4
a12 9
Previously we would get a short black flicker when a client closes. This
happened because first the client's window would get hidden and only a short
moment later would awesome react to this and close its own window. In the mean
time, the X server filled the frame window with its background-pixel which was
black.

Just removing the background-pixel means we get the default value which is None.
This means that the content will be left untouched and the client's window will
be visible for a moment longer.
d14 2
a15 5
Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit ed3d0489ced8c4f56d2af990979ba75cfa5107b8
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sun Dec 7 14:09:35 2014 +0100
d17 5
a21 1
Implement icon_pixmap and icon_mask from WM_HINTS (FS#1297)
d23 1
a23 4
Fun fact: ICCCM specifies that icon_pixmap must have depth 1. Xterm uses a
pixmap with depth 24. Yay... As such, I don't have any test for the depth == 1
case and will just assume that it does the right thing. If it doesn't, I bet no
one will notice anyway.
d27 4
a30 87
--- objects/client.c.orig	Fri Apr 11 04:07:10 2014
+++ objects/client.c	Tue Dec 16 04:47:44 2014
@@@@ -455,13 +455,11 @@@@ client_manage(xcb_window_t w, xcb_get_geometry_reply_t
     xcb_create_window(globalconf.connection, globalconf.default_depth, c->frame_window, s->root,
                       wgeom->x, wgeom->y, wgeom->width, wgeom->height,
                       wgeom->border_width, XCB_COPY_FROM_PARENT, globalconf.visual->visual_id,
-                      XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_BIT_GRAVITY
-                      | XCB_CW_WIN_GRAVITY | XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK
-                      | XCB_CW_COLORMAP,
+                      XCB_CW_BORDER_PIXEL | XCB_CW_BIT_GRAVITY | XCB_CW_WIN_GRAVITY
+                      | XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP,
                       (const uint32_t [])
                       {
                           globalconf.screen->black_pixel,
-                          globalconf.screen->black_pixel,
                           XCB_GRAVITY_NORTH_WEST,
                           XCB_GRAVITY_NORTH_WEST,
                           1,
@@@@ -1311,6 +1309,71 @@@@ client_set_icon(client_t *c, cairo_surface_t *s)
     luaA_object_emit_signal(globalconf.L, -1, "property::icon", 0);
     lua_pop(globalconf.L, 1);
 }
+
+/** Set a client icon.
+ * \param c The client to change.
+ * \param icon A bitmap containing the icon.
+ * \param mask A mask for the bitmap (optional)
+ */
+void
+client_set_icon_from_pixmaps(client_t *c, xcb_pixmap_t icon, xcb_pixmap_t mask)
+{
+    xcb_get_geometry_cookie_t geom_icon_c, geom_mask_c;
+    xcb_get_geometry_reply_t *geom_icon_r, *geom_mask_r = NULL;
+    cairo_surface_t *s_icon, *result;
+
+    geom_icon_c = xcb_get_geometry_unchecked(globalconf.connection, icon);
+    if (mask)
+        geom_mask_c = xcb_get_geometry_unchecked(globalconf.connection, mask);
+    geom_icon_r = xcb_get_geometry_reply(globalconf.connection, geom_icon_c, NULL);
+    if (mask)
+        geom_mask_r = xcb_get_geometry_reply(globalconf.connection, geom_mask_c, NULL);
+
+    if (!geom_icon_r || (mask && !geom_mask_r))
+        goto out;
+    if ((geom_icon_r->depth != 1 && geom_icon_r->depth != globalconf.screen->root_depth)
+            || (geom_mask_r && geom_mask_r->depth != 1))
+    {
+        warn("Got pixmaps with depth (%d, %d) while processing icon, but only depth 1 and %d are allowed",
+                geom_icon_r->depth, geom_mask_r ? geom_mask_r->depth : 0, globalconf.screen->root_depth);
+        goto out;
+    }
+
+    if (geom_icon_r->depth == 1)
+        s_icon = cairo_xcb_surface_create_for_bitmap(globalconf.connection,
+                globalconf.screen, icon, geom_icon_r->width, geom_icon_r->height);
+    else
+        s_icon = cairo_xcb_surface_create(globalconf.connection, icon, globalconf.default_visual,
+                geom_icon_r->width, geom_icon_r->height);
+    result = s_icon;
+
+    if (mask)
+    {
+        cairo_surface_t *s_mask;
+        cairo_t *cr;
+
+        result = cairo_surface_create_similar(s_icon, CAIRO_CONTENT_COLOR_ALPHA, geom_icon_r->width, geom_icon_r->height);
+        s_mask = cairo_xcb_surface_create_for_bitmap(globalconf.connection,
+                globalconf.screen, mask, geom_icon_r->width, geom_icon_r->height);
+        cr = cairo_create(result);
+
+        cairo_set_source_surface(cr, s_icon, 0, 0);
+        cairo_mask_surface(cr, s_mask, 0, 0);
+        cairo_surface_destroy(s_mask);
+        cairo_destroy(cr);
+    }
+
+    client_set_icon(c, result);
+
+    cairo_surface_destroy(result);
+    if (result != s_icon)
+        cairo_surface_destroy(s_icon);
+
+out:
+    p_delete(&geom_icon_r);
+    p_delete(&geom_mask_r);
+}
+
d32 32
a63 2
 /** Kill a client.
  * \param L The Lua VM state.
@


1.9
log
@
Merge fixes from the stable '3.5' branch:

Don't move clients on ConfigureRequests

Implement icon_pixmap and icon_mask from WM_HINTS

Don't set a background-pixel for our client frame windows
@
text
@d1 1
a1 1
$OpenBSD$
@


1.8
log
@
Cleanup following libxcb/xcb-util updates
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.7 2013/10/15 09:28:46 dcoppa Exp $
d3 3
a5 1
Revert to the old xcb-util-0.3.6 API
d7 114
a120 198
--- objects/client.c.orig	Sat Oct 12 18:48:49 2013
+++ objects/client.c	Tue Oct 15 09:51:13 2013
@@@@ -45,7 +45,7 @@@@ static void
 client_wipe(client_t *c)
 {
     key_array_wipe(&c->keys);
-    xcb_icccm_get_wm_protocols_reply_wipe(&c->protocols);
+    xcb_get_wm_protocols_reply_wipe(&c->protocols);
     p_delete(&c->machine);
     p_delete(&c->class);
     p_delete(&c->instance);
@@@@ -70,20 +70,20 @@@@ client_set_urgent(lua_State *L, int cidx, bool urgent)
     if(c->urgent != urgent)
     {
         xcb_get_property_cookie_t hints =
-            xcb_icccm_get_wm_hints_unchecked(globalconf.connection, c->window);
+            xcb_get_wm_hints_unchecked(globalconf.connection, c->window);
 
         c->urgent = urgent;
 
         /* update ICCCM hints */
-        xcb_icccm_wm_hints_t wmh;
-        xcb_icccm_get_wm_hints_reply(globalconf.connection, hints, &wmh, NULL);
+        xcb_wm_hints_t wmh;
+        xcb_get_wm_hints_reply(globalconf.connection, hints, &wmh, NULL);
 
         if(urgent)
-            wmh.flags |= XCB_ICCCM_WM_HINT_X_URGENCY;
+            wmh.flags |= XCB_WM_HINT_X_URGENCY;
         else
-            wmh.flags &= ~XCB_ICCCM_WM_HINT_X_URGENCY;
+            wmh.flags &= ~XCB_WM_HINT_X_URGENCY;
 
-        xcb_icccm_set_wm_hints(globalconf.connection, c->window, &wmh);
+        xcb_set_wm_hints(globalconf.connection, c->window, &wmh);
 
         luaA_object_emit_signal(L, cidx, "property::urgent", 0);
     }
@@@@ -565,7 +565,7 @@@@ HANDLE_GEOM(height)
      *
      * At this stage it's just safer to keep it in normal state and avoid confusion.
      */
-    xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_NORMAL);
+    xwindow_set_state(c->window, XCB_WM_STATE_NORMAL);
 
     if(!startup)
     {
@@@@ -637,26 +637,26 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
     /* Size hints are applied to the window without any decoration */
     client_remove_titlebar_geometry(c, &geometry);
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_SIZE)
     {
         basew = c->size_hints.base_width;
         baseh = c->size_hints.base_height;
         real_basew = basew;
         real_baseh = baseh;
     }
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MIN_SIZE)
+    else if(c->size_hints.flags & XCB_SIZE_HINT_P_MIN_SIZE)
     {
         /* base size is substituted with min size if not specified */
         basew = c->size_hints.min_width;
         baseh = c->size_hints.min_height;
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MIN_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_MIN_SIZE)
     {
         minw = c->size_hints.min_width;
         minh = c->size_hints.min_height;
     }
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_SIZE)
+    else if(c->size_hints.flags & XCB_SIZE_HINT_P_SIZE)
     {
         /* min size is substituted with base size if not specified */
         minw = c->size_hints.base_width;
@@@@ -664,7 +664,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
     }
 
     /* Handle the size aspect ratio */
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_ASPECT
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_ASPECT
             && c->size_hints.min_aspect_den > 0
             && c->size_hints.max_aspect_den > 0
             && geometry.height > real_baseh
@@@@ -705,7 +705,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
     geometry.height = MAX(geometry.height, minh);
 
     /* Handle the maximum size */
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MAX_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_MAX_SIZE)
     {
         if(c->size_hints.max_width)
             geometry.width = MIN(geometry.width, c->size_hints.max_width);
@@@@ -714,7 +714,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
     }
 
     /* Handle the size increment */
-    if(c->size_hints.flags & (XCB_ICCCM_SIZE_HINT_P_RESIZE_INC | XCB_ICCCM_SIZE_HINT_BASE_SIZE)
+    if(c->size_hints.flags & (XCB_SIZE_HINT_P_RESIZE_INC | XCB_SIZE_HINT_BASE_SIZE)
        && c->size_hints.width_inc && c->size_hints.height_inc)
     {
         uint16_t t1 = geometry.width, t2 = geometry.height;
@@@@ -896,9 +896,9 @@@@ client_set_minimized(lua_State *L, int cidx, bool s)
         c->minimized = s;
         banning_need_update();
         if(s)
-            xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_ICONIC);
+            xwindow_set_state(c->window, XCB_WM_STATE_ICONIC);
         else
-            xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_NORMAL);
+            xwindow_set_state(c->window, XCB_WM_STATE_NORMAL);
         if(strut_has_value(&c->strut))
             screen_emit_signal(globalconf.L, c->screen, "property::workarea", 0);
         luaA_object_emit_signal(L, cidx, "property::minimized", 0);
@@@@ -1201,7 +1201,7 @@@@ client_unmanage(client_t *c, bool window_valid)
 
         /* Do this last to avoid races with clients. According to ICCCM, clients
          * arent allowed to re-use the window until after this. */
-        xwindow_set_state(c->window, XCB_ICCCM_WM_STATE_WITHDRAWN);
+        xwindow_set_state(c->window, XCB_WM_STATE_WITHDRAWN);
     }
 
     /* set client as invalid */
@@@@ -1856,9 +1856,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
 
     lua_createtable(L, 0, 1);
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_US_POSITION)
+    if(c->size_hints.flags & XCB_SIZE_HINT_US_POSITION)
         u_or_p = "user_position";
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_POSITION)
+    else if(c->size_hints.flags & XCB_SIZE_HINT_P_POSITION)
         u_or_p = "program_position";
 
     if(u_or_p)
@@@@ -1872,9 +1872,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         u_or_p = NULL;
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_US_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_US_SIZE)
         u_or_p = "user_size";
-    else if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_SIZE)
+    else if(c->size_hints.flags & XCB_SIZE_HINT_P_SIZE)
         u_or_p = "program_size";
 
     if(u_or_p)
@@@@ -1887,7 +1887,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, u_or_p);
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MIN_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_MIN_SIZE)
     {
         lua_pushnumber(L, c->size_hints.min_width);
         lua_setfield(L, -2, "min_width");
@@@@ -1895,7 +1895,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "min_height");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MAX_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_MAX_SIZE)
     {
         lua_pushnumber(L, c->size_hints.max_width);
         lua_setfield(L, -2, "max_width");
@@@@ -1903,7 +1903,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "max_height");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_RESIZE_INC)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_RESIZE_INC)
     {
         lua_pushnumber(L, c->size_hints.width_inc);
         lua_setfield(L, -2, "width_inc");
@@@@ -1911,7 +1911,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "height_inc");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_ASPECT)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_ASPECT)
     {
         lua_pushnumber(L, c->size_hints.min_aspect_num);
         lua_setfield(L, -2, "min_aspect_num");
@@@@ -1923,7 +1923,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "max_aspect_den");
     }
 
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_BASE_SIZE)
+    if(c->size_hints.flags & XCB_SIZE_HINT_BASE_SIZE)
     {
         lua_pushnumber(L, c->size_hints.base_width);
         lua_setfield(L, -2, "base_width");
@@@@ -1931,7 +1931,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
         lua_setfield(L, -2, "base_height");
     }
d122 2
a123 5
-    if(c->size_hints.flags & XCB_ICCCM_SIZE_HINT_P_WIN_GRAVITY)
+    if(c->size_hints.flags & XCB_SIZE_HINT_P_WIN_GRAVITY)
     {
         switch(c->size_hints.win_gravity)
         {
@


1.7
log
@Update to awesome-3.5.2, codename "The Fox".
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.6 2013/10/11 08:50:21 dcoppa Exp $
@


1.6
log
@Revert "client: Don't move clients around across restarts" commit,
it was causing more pain than gain.

Add another two bugfixes:

- event: Handle MotionNotify before ButtonPress/Release
- awful.tag.withcurrent: Also act on restarts

All from upstream git repo.
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.5 2013/10/08 11:48:58 dcoppa Exp $
d5 3
a7 33
commit a0e45e878e450d890a0ab541d48d8dd6c1ede943
Author: Uli Schlachter <psychon@@znc.in>
Date:   Thu Aug 1 11:48:03 2013 +0200

client: Ignore "fake" string property changes

I noticed high CPU usage while using asunder. The reason was that asunder
re-sets its window name every 0.1 seconds (and awesome's drawing code is way too
slow).

A semi-fix for this is to ignore string property changes if the old and new
value for the property are equal.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit 11bef0795a450865b589c1c906bf97141436d314
Author: Uli Schlachter <psychon@@znc.in>
Date:   Mon Sep 16 12:06:10 2013 +0200

client.content: Use correct client size (FS#1150)

The size saved in c->geometry also includes the titlebars. Thus, for getting the
window content, we have to subtract this from the size.

Before this, the call to xcb_image_get() was failing with a BadMatch error,
because we were asking for an area that is outside of the actual client's
window's geometry.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

--- objects/client.c.orig	Mon Apr  1 13:44:46 2013
+++ objects/client.c	Fri Oct 11 10:02:39 2013
@@@@ -46,7 +46,7 @@@@ static void
d16 1
a16 1
@@@@ -71,20 +71,20 @@@@ client_set_urgent(lua_State *L, int cidx, bool urgent)
d43 1
a43 13
@@@@ -113,6 +113,11 @@@@ DO_CLIENT_SET_PROPERTY(skip_taskbar)
     client_set_##prop(lua_State *L, int cidx, char *value) \
     { \
         client_t *c = luaA_checkudata(L, cidx, &client_class); \
+        if (A_STREQ(c->prop, value)) \
+        { \
+            p_delete(&value); \
+            return; \
+        } \
         p_delete(&c->prop); \
         c->prop = value; \
         luaA_object_emit_signal(L, cidx, "property::" #signal, 0); \
@@@@ -561,7 +566,7 @@@@ HANDLE_GEOM(height)
d52 1
a52 1
@@@@ -633,26 +638,26 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
d83 1
a83 1
@@@@ -660,7 +665,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
d92 1
a92 1
@@@@ -701,7 +706,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
d101 1
a101 1
@@@@ -710,7 +715,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
d110 1
a110 1
@@@@ -892,9 +897,9 @@@@ client_set_minimized(lua_State *L, int cidx, bool s)
d122 1
a122 1
@@@@ -1197,7 +1202,7 @@@@ client_unmanage(client_t *c, bool window_valid)
d131 1
a131 21
@@@@ -1784,11 +1789,16 @@@@ LUA_OBJECT_EXPORT_PROPERTY(client, client_t, maximized
 static int
 luaA_client_get_content(lua_State *L, client_t *c)
 {
-    xcb_image_t *ximage = xcb_image_get(globalconf.connection,
+    xcb_image_t *ximage;
+    int width  = c->geometry.width;
+    int height = c->geometry.height;
+
+    width  -= c->titlebar[CLIENT_TITLEBAR_LEFT].size + c->titlebar[CLIENT_TITLEBAR_RIGHT].size;
+    height -= c->titlebar[CLIENT_TITLEBAR_TOP].size + c->titlebar[CLIENT_TITLEBAR_BOTTOM].size;
+    ximage = xcb_image_get(globalconf.connection,
                                         c->window,
                                         0, 0,
-                                        c->geometry.width,
-                                        c->geometry.height,
+                                        width, height,
                                         ~0, XCB_IMAGE_FORMAT_Z_PIXMAP);
     cairo_surface_t *surface = NULL;
 
@@@@ -1861,9 +1871,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d143 1
a143 1
@@@@ -1877,9 +1887,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d155 1
a155 1
@@@@ -1892,7 +1902,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d164 1
a164 1
@@@@ -1900,7 +1910,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d173 1
a173 1
@@@@ -1908,7 +1918,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d182 1
a182 1
@@@@ -1916,7 +1926,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d191 1
a191 1
@@@@ -1928,7 +1938,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d200 1
a200 1
@@@@ -1936,7 +1946,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
@


1.5
log
@Add a couple of missing comments.
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.4 2013/10/07 14:28:52 dcoppa Exp $
a19 15
commit c3bca6ac344577781858e06c83e310b69ac9a4e0
Author: Uli Schlachter <psychon@@znc.in>
Date:   Fri Oct 4 16:12:06 2013 +0200

client: Don't move clients around across restarts (FS#1159)

This kind of forces every client to have a window gravity of "static".

This fixes most of the problem of clients moving around across restarts due to
the titlebar. What is left is that they move due to the border width which
should be handled in another patch. Also, another patch should make this honor
the client's actual window gravity.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

d36 1
a36 1
+++ objects/client.c	Mon Oct  7 15:53:09 2013
d173 1
a173 27
@@@@ -1554,16 +1559,23 @@@@ titlebar_resize(client_t *c, client_titlebar_t bar, in
         return;
 
     /* Now resize the client (and titlebars!) suitably (the client without
-     * titlebars should keep its current size!) */
+     * titlebars should keep its current size!)
+     * TODO: I guess that this should honor the client's window gravity, right
+     * now we pretend to have static gravity. See awesome_atexit().
+     */
     area_t geometry = c->geometry;
     int change = size - c->titlebar[bar].size;
     switch (bar) {
     case CLIENT_TITLEBAR_TOP:
+        geometry.y -= change;
+        /* fall through */;
     case CLIENT_TITLEBAR_BOTTOM:
         geometry.height += change;
         break;
-    case CLIENT_TITLEBAR_RIGHT:
     case CLIENT_TITLEBAR_LEFT:
+        geometry.x -= change;
+        /* fall through */;
+    case CLIENT_TITLEBAR_RIGHT:
         geometry.width += change;
         break;
     default:
@@@@ -1784,11 +1796,16 @@@@ LUA_OBJECT_EXPORT_PROPERTY(client, client_t, maximized
d193 1
a193 1
@@@@ -1861,9 +1878,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d205 1
a205 1
@@@@ -1877,9 +1894,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d217 1
a217 1
@@@@ -1892,7 +1909,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d226 1
a226 1
@@@@ -1900,7 +1917,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d235 1
a235 1
@@@@ -1908,7 +1925,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d244 1
a244 1
@@@@ -1916,7 +1933,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d253 1
a253 1
@@@@ -1928,7 +1945,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d262 1
a262 1
@@@@ -1936,7 +1953,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
@


1.4
log
@Bunch of bugfixes from upstream:

Fix possible deadlock during startup
awful.client.tiled: Ignore fullscreen clients
awful.screen.focus: Don't move mouse to (0, 0) first
naughty: Verify image parameters coming from dbus
wibox.layout.fixed: Fix fill space
Revert "client: add a limit to the loop"
client: Ignore transient_for causing loops
screen: Fix screen equality comparison
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.3 2013/09/23 14:14:30 dcoppa Exp $
a4 1

d20 14
@


1.3
log
@
Unbreak building with LDoc-1.4.0

client.content: Use correct client size
https://awesome.naquadah.org/bugs/index.php?do=details&task_id=1150
(upstream git commit 11bef0795a450865b589c1c906bf97141436d314)
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.2 2013/08/21 04:58:49 dcoppa Exp $
d38 1
a38 1
+++ objects/client.c	Mon Sep 23 15:57:33 2013
d175 27
a201 1
@@@@ -1784,11 +1789,16 @@@@ LUA_OBJECT_EXPORT_PROPERTY(client, client_t, maximized
d221 1
a221 1
@@@@ -1861,9 +1871,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d233 1
a233 1
@@@@ -1877,9 +1887,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d245 1
a245 1
@@@@ -1892,7 +1902,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d254 1
a254 1
@@@@ -1900,7 +1910,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d263 1
a263 1
@@@@ -1908,7 +1918,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d272 1
a272 1
@@@@ -1916,7 +1926,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d281 1
a281 1
@@@@ -1928,7 +1938,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d290 1
a290 1
@@@@ -1936,7 +1946,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
@


1.2
log
@
client: ignore "fake" string property changes.
Ignore string property changes if the old and new value for the
property are equal.
(upstream git commit a0e45e878e450d890a0ab541d48d8dd6c1ede943)
@
text
@d1 1
a1 1
$OpenBSD: patch-objects_client_c,v 1.1 2013/05/22 15:05:50 dcoppa Exp $
d21 16
d38 1
a38 1
+++ objects/client.c	Tue Aug 20 20:48:06 2013
d175 21
a195 1
@@@@ -1861,9 +1866,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d207 1
a207 1
@@@@ -1877,9 +1882,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d219 1
a219 1
@@@@ -1892,7 +1897,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d228 1
a228 1
@@@@ -1900,7 +1905,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d237 1
a237 1
@@@@ -1908,7 +1913,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d246 1
a246 1
@@@@ -1916,7 +1921,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d255 1
a255 1
@@@@ -1928,7 +1933,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d264 1
a264 1
@@@@ -1936,7 +1941,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
@


1.1
log
@Major update to awesome-3.5.1

OK jasper@@
@
text
@d1 1
a1 1
$OpenBSD$
d5 18
a22 2
--- objects/client.c.orig	Mon May 20 13:35:44 2013
+++ objects/client.c	Mon May 20 13:37:04 2013
d59 13
a71 1
@@@@ -561,7 +561,7 @@@@ HANDLE_GEOM(height)
d80 1
a80 1
@@@@ -633,26 +633,26 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
d111 1
a111 1
@@@@ -660,7 +660,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
d120 1
a120 1
@@@@ -701,7 +701,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
d129 1
a129 1
@@@@ -710,7 +710,7 @@@@ client_apply_size_hints(client_t *c, area_t geometry)
d138 1
a138 1
@@@@ -892,9 +892,9 @@@@ client_set_minimized(lua_State *L, int cidx, bool s)
d150 1
a150 1
@@@@ -1197,7 +1197,7 @@@@ client_unmanage(client_t *c, bool window_valid)
d159 1
a159 1
@@@@ -1861,9 +1861,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d171 1
a171 1
@@@@ -1877,9 +1877,9 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d183 1
a183 1
@@@@ -1892,7 +1892,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d192 1
a192 1
@@@@ -1900,7 +1900,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d201 1
a201 1
@@@@ -1908,7 +1908,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d210 1
a210 1
@@@@ -1916,7 +1916,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d219 1
a219 1
@@@@ -1928,7 +1928,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
d228 1
a228 1
@@@@ -1936,7 +1936,7 @@@@ luaA_client_get_size_hints(lua_State *L, client_t *c)
@

