head	1.18;
access;
symbols
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.18
date	2017.02.28.13.27.15;	author dcoppa;	state dead;
branches;
next	1.17;
commitid	LK24Dq2Oc5IWnvdk;

1.17
date	2016.03.07.11.33.59;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	7zUqqCR47GCkIAqa;

1.16
date	2016.03.01.11.42.24;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	QAoVD7PgkclyraIQ;

1.15
date	2016.01.18.09.50.09;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	lrRI65aKSWqF9Rnn;

1.14
date	2015.11.09.14.36.12;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	LYfZ9mVasxXSCMq6;

1.13
date	2015.09.07.10.30.01;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	WUqbLhpCG8h9lOEo;

1.12
date	2015.01.12.09.00.17;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	ZXrBV9TNCMLtawvr;

1.11
date	2014.04.15.10.32.36;	author dcoppa;	state dead;
branches;
next	1.10;

1.10
date	2013.10.15.09.28.41;	author dcoppa;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.11.08.50.21;	author dcoppa;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.08.11.48.58;	author dcoppa;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.07.14.28.51;	author dcoppa;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.17.13.23.34;	author dcoppa;	state Exp;
branches;
next	1.5;

1.5
date	2013.05.22.15.05.50;	author dcoppa;	state Exp;
branches;
next	1.4;

1.4
date	2012.12.31.17.41.44;	author dcoppa;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.30.11.50.58;	author dcoppa;	state Exp;
branches;
next	1.2;

1.2
date	2011.03.13.18.07.23;	author dcoppa;	state dead;
branches;
next	1.1;

1.1
date	2011.01.20.21.17.15;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.18
log
@
Update to awesome v4.0 (Harder, Better, Faster, Stronger)

To migrate a custom rc.lua from version 3.5.x to version 4.0, see
https://awesomewm.org/apidoc/documentation/17-porting-tips.md.html#v4
@
text
@$OpenBSD: patch-awesome_c,v 1.17 2016/03/07 11:33:59 dcoppa Exp $

commit 635223b5fe599d94de4ab44d27500041f121e081
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sun Jan 11 10:42:45 2015 +0100

Remove titlebars from clients during shutdown

This reparents all clients back to their proper position during shutdown, so
that their top-left corner is now where their titlebar's top-left corner was.
Hopefully, this fixes floating clients moving around across a restart.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

--- awesome.c.orig	Fri Jan 15 16:51:19 2016
+++ awesome.c	Mon Jan 18 09:47:55 2016
@@@@ -89,6 +89,13 @@@@ awesome_atexit(bool restart)
                         globalconf.screen->root,
                         AWESOME_CLIENT_ORDER, XCB_ATOM_WINDOW, 32, n, wins);
 
+    /* Move clients where we want them to be */
+    foreach(c, globalconf.clients)
+    {
+        xcb_reparent_window(globalconf.connection, (*c)->window, globalconf.screen->root,
+                (*c)->geometry.x, (*c)->geometry.y);
+    }
+
     a_dbus_cleanup();
 
     systray_cleanup();
@


1.17
log
@
Update to awesome-3.5.9
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.15 2016/01/18 09:50:09 dcoppa Exp $
@


1.16
log
@
Merge several fixes from the stable '3.5' branch
@
text
@d15 2
a16 18
commit bf73f78eea61d4a0e93e5da5e6d89e1bdca2e816
Author: Uli Schlachter <psychon@@znc.in>
Date:   Wed Feb 17 18:40:01 2016 +0100

Check that the Lua stack is empty in the main loop

The Lua stack is a finite resource and everything that pushes something there
should also clean up. This is not a problem for functions that are called by
Lua, because their "stack frame" is freed when they return. However, in global
context, Lua does not and cannot automatically clean up for us. Thus, it makes
sense to print a warning in this case.

(Additionally, this cleans up the stack if something is left)

Signed-off-by: Uli Schlachter <psychon@@znc.in>

--- awesome.c.orig	Sat Jan 30 14:55:18 2016
+++ awesome.c	Tue Mar  1 11:24:18 2016
a30 14
@@@@ -284,6 +291,13 @@@@ a_glib_poll(GPollFD *ufds, guint nfsd, gint timeout)
 
     /* Do all deferred work now */
     awesome_refresh();
+
+    /* Check if the Lua stack is the way it should be */
+    if (lua_gettop(globalconf.L) != 0) {
+        warn("Something was left on the Lua stack, this is a bug!");
+        luaA_dumpstack(globalconf.L);
+        lua_settop(globalconf.L, 0);
+    }
 
     /* Check how long this main loop iteration took */
     gettimeofday(&now, NULL);
@


1.15
log
@
Update to awesome-3.5.7
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.12 2015/01/12 09:00:17 dcoppa Exp $
d15 18
a32 2
--- awesome.c.orig	Fri Jan 15 16:51:19 2016
+++ awesome.c	Mon Jan 18 09:47:55 2016
d47 14
@


1.14
log
@
Merge fixes from upstream (from the stable '3.5' branch)
@
text
@d1 1
a1 12
$OpenBSD: patch-awesome_c,v 1.13 2015/09/07 10:30:01 dcoppa Exp $

commit 0412acfdc02295973e3c216bda6ce4349dc86f80
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sun Jul 26 15:59:34 2015 +0200

Keep stacking order across restarts

ReparentWindow puts the window at the top of the stacking order. Thus, we have
to reparent clients back to the root window in the stacking order.

Signed-off-by: Uli Schlachter <psychon@@znc.in>
d15 5
a19 78
commit db087fdda72af25fcfbdf0ca34e349a6e6b3c7fa
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sun Jul 26 17:03:10 2015 +0200

Keep client order across restarts

This saves the order of clients in a property called AWESOME_CLIENT_ORDER on the
root window during shutdown. During startup, after managing all existing
windows, we force the client list into the order described by this property
(overwriting any changes that Lua possibly did).

This code should safely handle cases where the property doesn't contain all
existing clients or contains a client which doesn't exist anymore.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit d37cc7e9dfe968f65752e9dafefdce057862b1a0
Author: Daniel Hahler <git@@thequod.de>
Date:   Wed Jul 29 19:04:00 2015 +0200

awesome_atexit: keep client order always

This is not only useful for soft restarts, but also when TERMinating
awesome during development/testing.

The drawback appears to be that it would leak a property on the root
window in case it is really meant to be quit.

Closes https://github.com/awesomeWM/awesome/pull/374.

commit 925e6ecc171bdec65bf1f6ccafea2a0ce1724bf3
Author: Daniel Hahler <git@@thequod.de>
Date:   Sat Jun 20 02:08:04 2015 +0200

Make stdout/stderr line buffered

This improves the behaviour with print()ing for debugging, when the
output is redirected to a file.

I was using `setbuf(..., 0)` initially, but it makes sense to buffer it
per line.  This uses `setvbuf` instead of `setlinebuf`, which might not
be available everywhere.

Closes https://github.com/awesomeWM/awesome/pull/267

commit 9b5ab994b024a42df38724a093509afe8eb89a8e
Author: Uli Schlachter <psychon@@znc.in>
Date:   Wed Sep 23 20:48:56 2015 +0200

Never explicitly focus the root window

Whenever client.focus == nil, we set the input focus to the root window to
express "nothing has the input focus". However, thanks to the way X11 input
works, this means that whatever is under the mouse cursor gets keyboard input
events. This can easily be reproduced with urxvt and some small addition to the
config to unfocus things.

This commit changes things. Instead of focusing the root window, we create a
special "no focus" window that gets focused if we want nothing to have the
focus.

Closes https://github.com/awesomeWM/awesome/pull/470.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit 821e3e7e2cf1f301f83b790d66452913f92324ef
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sat Oct 10 22:25:56 2015 +0200

Make awesome.quit() during startup work

Signed-off-by: Uli Schlachter <psychon@@znc.in>

--- awesome.c.orig	Sat Jan 10 20:36:35 2015
+++ awesome.c	Mon Nov  9 13:54:50 2015
@@@@ -72,6 +72,23 @@@@ awesome_atexit(bool restart)
     lua_pushboolean(globalconf.L, restart);
     signal_object_emit(globalconf.L, &global_signals, "exit", 1);
d21 2
a22 2
+    /* Move clients where we want them to be and keep the stacking order intact */
+    foreach(c, globalconf.stack)
a27 10
+    /* Save the client order.  This is useful also for "hard" restarts. */
+    xcb_window_t *wins = p_alloca(xcb_window_t, globalconf.clients.len);
+    int n = 0;
+    foreach(client, globalconf.clients)
+        wins[n++] = (*client)->window;
+
+    xcb_change_property(globalconf.connection, XCB_PROP_MODE_REPLACE,
+                        globalconf.screen->root,
+                        AWESOME_CLIENT_ORDER, XCB_ATOM_WINDOW, 32, n, wins);
+
a30 127
@@@@ -94,6 +111,36 @@@@ awesome_atexit(bool restart)
     xcb_disconnect(globalconf.connection);
 }
 
+/** Restore the client order after a restart */
+static void
+restore_client_order(xcb_get_property_cookie_t prop_cookie)
+{
+    int client_idx = 0;
+    xcb_window_t *windows;
+    xcb_get_property_reply_t *reply;
+
+    reply = xcb_get_property_reply(globalconf.connection, prop_cookie, NULL);
+    if (!reply || reply->format != 32 || reply->value_len == 0) {
+        p_delete(&reply);
+        return;
+    }
+
+    windows = xcb_get_property_value(reply);
+    for (uint32_t i = 0; i < reply->value_len; i++)
+        /* Find windows[i] and swap it to where it belongs */
+        foreach(c, globalconf.clients)
+            if ((*c)->window == windows[i])
+            {
+                client_t *tmp = *c;
+                *c = globalconf.clients.tab[client_idx];
+                globalconf.clients.tab[client_idx] = tmp;
+                client_idx++;
+            }
+
+    luaA_class_emit_signal(globalconf.L, &client_class, "list", 0);
+    p_delete(&reply);
+}
+
 /** Scan X to find windows to manage.
  */
 static void
@@@@ -104,6 +151,7 @@@@ scan(xcb_query_tree_cookie_t tree_c)
     xcb_window_t *wins = NULL;
     xcb_get_window_attributes_reply_t *attr_r;
     xcb_get_geometry_reply_t *geom_r;
+    xcb_get_property_cookie_t prop_cookie;
     long state;
 
     tree_r = xcb_query_tree_reply(globalconf.connection,
@@@@ -113,6 +161,11 @@@@ scan(xcb_query_tree_cookie_t tree_c)
     if(!tree_r)
         return;
 
+    /* This gets the property and deletes it */
+    prop_cookie = xcb_get_property_unchecked(globalconf.connection, true,
+                          globalconf.screen->root, AWESOME_CLIENT_ORDER,
+                          XCB_ATOM_WINDOW, 0, UINT_MAX);
+
     /* Get the tree of the children windows of the current root window */
     if(!(wins = xcb_query_tree_children(tree_r)))
         fatal("cannot get tree children");
@@@@ -167,6 +220,8 @@@@ scan(xcb_query_tree_cookie_t tree_c)
     }
 
     p_delete(&tree_r);
+
+    restore_client_order(prop_cookie);
 }
 
 static void
@@@@ -324,6 +379,10 @@@@ main(int argc, char **argv)
         { NULL,      0, NULL, 0 }
     };
 
+    /* Make stdout/stderr line buffered. */
+    setvbuf(stdout, NULL, _IOLBF, 0);
+    setvbuf(stderr, NULL, _IOLBF, 0);
+
     /* clear the globalconf structure */
     p_clear(&globalconf, 1);
     globalconf.keygrabber = LUA_REFNIL;
@@@@ -499,23 +558,27 @@@@ main(int argc, char **argv)
     spawn_init();
 
     /* The default GC is just a newly created associated with a window with
-     * depth globalconf.default_depth */
-    xcb_window_t tmp_win = xcb_generate_id(globalconf.connection);
+     * depth globalconf.default_depth.
+     * The window_no_focus is used for "nothing has the input focus". */
+    globalconf.focus.window_no_focus = xcb_generate_id(globalconf.connection);
     globalconf.gc = xcb_generate_id(globalconf.connection);
     xcb_create_window(globalconf.connection, globalconf.default_depth,
-                      tmp_win, globalconf.screen->root,
+                      globalconf.focus.window_no_focus, globalconf.screen->root,
                       -1, -1, 1, 1, 0,
                       XCB_COPY_FROM_PARENT, globalconf.visual->visual_id,
-                      XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_COLORMAP,
+                      XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL |
+                      XCB_CW_OVERRIDE_REDIRECT | XCB_CW_COLORMAP,
                       (const uint32_t [])
                       {
                           globalconf.screen->black_pixel,
                           globalconf.screen->black_pixel,
+                          1,
                           globalconf.default_cmap
                       });
-    xcb_create_gc(globalconf.connection, globalconf.gc, tmp_win, XCB_GC_FOREGROUND | XCB_GC_BACKGROUND,
+    xcb_map_window(globalconf.connection, globalconf.focus.window_no_focus);
+    xcb_create_gc(globalconf.connection, globalconf.gc, globalconf.focus.window_no_focus,
+                  XCB_GC_FOREGROUND | XCB_GC_BACKGROUND,
                   (const uint32_t[]) { globalconf.screen->black_pixel, globalconf.screen->white_pixel });
-    xcb_destroy_window(globalconf.connection, tmp_win);
 
     /* Get the window tree associated to this screen */
     tree_c = xcb_query_tree_unchecked(globalconf.connection,
@@@@ -547,9 +610,12 @@@@ main(int argc, char **argv)
     g_main_context_set_poll_func(g_main_context_default(), &a_glib_poll);
     gettimeofday(&last_wakeup, NULL);
 
-    /* main event loop */
-    globalconf.loop = g_main_loop_new(NULL, FALSE);
-    g_main_loop_run(globalconf.loop);
+    /* main event loop (if not NULL, awesome.quit() was already called) */
+    if (globalconf.loop == NULL)
+    {
+        globalconf.loop = g_main_loop_new(NULL, FALSE);
+        g_main_loop_run(globalconf.loop);
+    }
     g_main_loop_unref(globalconf.loop);
     globalconf.loop = NULL;
 
@


1.13
log
@
Merge several fixes from the stable '3.5' branch
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.12 2015/01/12 09:00:17 dcoppa Exp $
d71 28
d100 1
a100 1
+++ awesome.c	Mon Sep  7 11:41:26 2015
d191 1
a191 2
@@@@ -323,6 +378,10 @@@@ main(int argc, char **argv)
         { "no-argb", 0, NULL, 'a' },
d194 1
a194 1
+
d198 1
a198 1
 
d201 51
@


1.12
log
@
Update to awesome-3.5.6, codename "For Those About To Rock"
@
text
@d1 12
a12 1
$OpenBSD$
d26 48
a73 3
--- awesome.c.orig	Mon Jan 12 02:45:28 2015
+++ awesome.c	Mon Jan 12 02:45:35 2015
@@@@ -72,6 +72,13 @@@@ awesome_atexit(bool restart)
d77 2
a78 2
+    /* Move clients where we want them to be */
+    foreach(c, globalconf.clients)
d84 10
d97 77
@


1.11
log
@
Cleanup following libxcb/xcb-util updates
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.10 2013/10/15 09:28:41 dcoppa Exp $
d3 3
a5 1
Revert to libXcursor
d7 1
a7 1
Revert to the old xcb-util-0.3.6 API
d9 18
a26 8
--- awesome.c.orig	Tue Oct 15 10:18:34 2013
+++ awesome.c	Tue Oct 15 10:18:16 2013
@@@@ -33,6 +33,9 @@@@
 #include <xcb/xtest.h>
 #include <xcb/shape.h>
 
+#include <X11/Xlib-xcb.h>
+#include <X11/XKBlib.h>
d28 1
a28 51
 #include <glib-unix.h>
 
 #include "awesome.h"
@@@@ -83,7 +86,6 @@@@ awesome_atexit(bool restart)
     xcb_aux_sync(globalconf.connection);
 
     /* Disconnect *after* closing lua */
-    xcb_cursor_context_free(globalconf.cursor_ctx);
     xcb_disconnect(globalconf.connection);
 }
 
@@@@ -134,7 +136,7 @@@@ scan(xcb_query_tree_cookie_t tree_c)
 
         if(!attr_r || attr_r->override_redirect
            || attr_r->map_state == XCB_MAP_STATE_UNMAPPED
-           || state == XCB_ICCCM_WM_STATE_WITHDRAWN)
+           || state == XCB_WM_STATE_WITHDRAWN)
         {
             geom_wins[i] = NULL;
             p_delete(&attr_r);
@@@@ -375,11 +377,21 @@@@ main(int argc, char **argv)
     sigemptyset(&sa.sa_mask);
     sigaction(SIGSEGV, &sa, 0);
 
+    /* XLib sucks */
+    XkbIgnoreExtension(True);
+
+    /* X stuff */
+    globalconf.display = XOpenDisplay(NULL);
+    if (globalconf.display == NULL) {
+        fatal("cannot open display");
+    }
+    XSetEventQueueOwner(globalconf.display, XCBOwnsEventQueue);
+    globalconf.default_screen = XDefaultScreen(globalconf.display);
+    globalconf.connection = XGetXCBConnection(globalconf.display);
     /* We have no clue where the input focus is right now */
     globalconf.focus.need_update = true;
 
-    /* X stuff */
-    globalconf.connection = xcb_connect(NULL, &globalconf.default_screen);
+    /* Double checking that connection is good and operatable with xcb */
     if(xcb_connection_has_error(globalconf.connection))
         fatal("cannot open display");
 
@@@@ -406,9 +418,6 @@@@ main(int argc, char **argv)
     xcb_prefetch_extension_data(globalconf.connection, &xcb_randr_id);
     xcb_prefetch_extension_data(globalconf.connection, &xcb_xinerama_id);
     xcb_prefetch_extension_data(globalconf.connection, &xcb_shape_id);
-
-    if (xcb_cursor_context_new(globalconf.connection, globalconf.screen, &globalconf.cursor_ctx) < 0)
-        fatal("Failed to initialize xcb-cursor");
d30 1
a30 2
     /* Setup the main context */
     g_main_context_set_poll_func(g_main_context_default(), &a_glib_poll);
@


1.10
log
@Update to awesome-3.5.2, codename "The Fox".
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.9 2013/10/11 08:50:21 dcoppa Exp $
@


1.9
log
@Revert "client: Don't move clients around across restarts" commit,
it was causing more pain than gain.

Add another two bugfixes:

- event: Handle MotionNotify before ButtonPress/Release
- awful.tag.withcurrent: Also act on restarts

All from upstream git repo.
@
text
@d1 3
a3 1
$OpenBSD: patch-awesome_c,v 1.8 2013/10/08 11:48:58 dcoppa Exp $
d7 21
a27 64
commit efd243b6d70b9c549c184c3c0b84c481453411e0
Author: Uli Schlachter <psychon@@znc.in>
Date:   Sun Oct 6 10:34:37 2013 +0200

event: Handle MotionNotify before ButtonPress/Release (FS#1136)

The above-mentioned bug report says that a window cannot be moved via its
titlebar if you move the move quickly while clicking.

The reason for this was awesome's "event compression": We don't handle all
MotionNotify events, because they can come in big quantities. Instead, we only
want to handle the latest one and ignore all earlier ones (the mouse isn't in
that position anymore anyway).

The problem now appears if a MotionNotify is moved across a ButtonPress event
and the ButtonPress is what should cause the window to be moved. Awesome first
handles the ButtonPress event normally and starts grabbing mouse input. Then,
our event loop feeds us with an old MotionNotify event in which the button was
not pressed yet. The code for moving clients gets a motion event in which no
mouse button is pressed, concludes that the move is done and ungrabs the mouse
again, even though the button is still physically pressed.

Fix this by making sure that MotionNotify events are never moved across
ButtonPress or ButtonRelease events. We already did this for EnterNotify and
LeaveNotify events for similar reasons.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit 57bec371f70f121785cd062dca3b86f18fd685fd
Author: kardan <kardan@@riseup.net>
Date:   Wed Jun 12 14:15:54 2013 +0200

honor appended -c option for --check

Signed-off-by: Uli Schlachter <psychon@@znc.in>

commit 9b7873392228e8ebab407144f1aacaead4f9733d
Author: Uli Schlachter <psychon@@znc.in>
Date:   Fri Oct 4 10:01:03 2013 +0200

Fix possible deadlock during startup

For setting up the wallpaper, awesome needs a second connection to the X11
server (isn't SetCloseDownMode just great?).

However, it was possible to have a dead-lock with our main connection due to
this. Awesome does a GrabServer during startup so that nothing else can use the
X11 server while we set ourselves up. The server is ungrabbed right before the
lua config is read. However, nothing makes sure that this ungrab request really
is sent to the server instead of just waiting in xcb's output buffer.

The dead-lock would now happen if we try to establish a second connection to the
X11 server before the ungrab request was flushed on the main connection. The
server will wait for the ungrab on the first connection, awesome is waiting for
the second connection to be successfully established.

Fix this by making sure the UngrabServer request is flushed before parsing the
config file.

Signed-off-by: Uli Schlachter <psychon@@znc.in>

--- awesome.c.orig	Mon Apr  1 13:44:46 2013
+++ awesome.c	Fri Oct 11 10:07:47 2013
@@@@ -136,7 +136,7 @@@@ scan(xcb_query_tree_cookie_t tree_c)
d36 11
a46 61
@@@@ -183,13 +183,13 @@@@ a_xcb_check(void)
         else
         {
             uint8_t type = XCB_EVENT_RESPONSE_TYPE(event);
-            if((type == XCB_ENTER_NOTIFY || type == XCB_LEAVE_NOTIFY) && mouse)
+            if(mouse && (type == XCB_ENTER_NOTIFY || type == XCB_LEAVE_NOTIFY
+                        || type == XCB_BUTTON_PRESS || type == XCB_BUTTON_RELEASE))
             {
-                /* Make sure enter/motion/leave events are handled in the
-                 * correct order */
+                /* Make sure enter/motion/leave/press/release events are handled
+                 * in the correct order */
                 event_handle(mouse);
                 p_delete(&mouse);
-                mouse = NULL;
             }
             event_handle(event);
             p_delete(&event);
@@@@ -288,6 +288,7 @@@@ main(int argc, char **argv)
     ssize_t cmdlen = 1;
     xdgHandle xdg;
     bool no_argb = false;
+    bool run_test = false;
     xcb_generic_event_t *event;
     xcb_query_tree_cookie_t tree_c;
     static struct option long_options[] =
@@@@ -340,16 +341,8 @@@@ main(int argc, char **argv)
             exit_help(EXIT_SUCCESS);
             break;
           case 'k':
-            if(!luaA_parserc(&xdg, confpath, false))
-            {
-                fprintf(stderr, "✘ Configuration file syntax error.\n");
-                return EXIT_FAILURE;
-            }
-            else
-            {
-                fprintf(stderr, "✔ Configuration file syntax OK.\n");
-                return EXIT_SUCCESS;
-            }
+            run_test = true;
+            break;
           case 'c':
             if(a_strlen(optarg))
                 confpath = a_strdup(optarg);
@@@@ -361,6 +354,20 @@@@ main(int argc, char **argv)
             break;
         }
 
+    if (run_test)
+    {
+        if(!luaA_parserc(&xdg, confpath, false))
+        {
+            fprintf(stderr, "✘ Configuration file syntax error.\n");
+            return EXIT_FAILURE;
+        }
+        else
+        {
+            fprintf(stderr, "✔ Configuration file syntax OK.\n");
+            return EXIT_SUCCESS;
+        }
d48 19
a66 9
+
     /* register function for signals */
     g_unix_signal_add(SIGINT, exit_on_signal, NULL);
     g_unix_signal_add(SIGTERM, exit_on_signal, NULL);
@@@@ -518,6 +525,7 @@@@ main(int argc, char **argv)
 
     /* we will receive events, stop grabbing server */
     xcb_ungrab_server(globalconf.connection);
+    xcb_flush(globalconf.connection);
d68 2
a69 2
     /* Parse and run configuration file */
     if (!luaA_parserc(&xdg, confpath, true))
@


1.8
log
@Add a couple of missing comments.
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.7 2013/10/07 14:28:51 dcoppa Exp $
d5 1
a5 1
commit c3bca6ac344577781858e06c83e310b69ac9a4e0
d7 1
a7 1
Date:   Fri Oct 4 16:12:06 2013 +0200
d9 1
a9 1
client: Don't move clients around across restarts (FS#1159)
d11 2
a12 1
This kind of forces every client to have a window gravity of "static".
d14 16
a29 4
This fixes most of the problem of clients moving around across restarts due to
the titlebar. What is left is that they move due to the border width which
should be handled in another patch. Also, another patch should make this honor
the client's actual window gravity.
d67 2
a68 15
+++ awesome.c	Mon Oct  7 15:53:09 2013
@@@@ -68,6 +68,12 @@@@ awesome_atexit(bool restart)
     lua_pushboolean(globalconf.L, restart);
     signal_object_emit(globalconf.L, &global_signals, "exit", 1);
 
+    /* TODO: Reparent windows back to root window, placing them according to
+     * their window gravity. Right now we pretend to use static gravity and that
+     * works automatically thanks to xcb_change_save_set(). See
+     * titlebar_resize().
+     */
+
     a_dbus_cleanup();
 
     systray_cleanup();
@@@@ -136,7 +142,7 @@@@ scan(xcb_query_tree_cookie_t tree_c)
d77 19
a95 1
@@@@ -288,6 +294,7 @@@@ main(int argc, char **argv)
d103 1
a103 1
@@@@ -340,16 +347,8 @@@@ main(int argc, char **argv)
d122 1
a122 1
@@@@ -361,6 +360,20 @@@@ main(int argc, char **argv)
d143 1
a143 1
@@@@ -518,6 +531,7 @@@@ main(int argc, char **argv)
@


1.7
log
@Bunch of bugfixes from upstream:

Fix possible deadlock during startup
awful.client.tiled: Ignore fullscreen clients
awful.screen.focus: Don't move mouse to (0, 0) first
naughty: Verify image parameters coming from dbus
wibox.layout.fixed: Fix fill space
Revert "client: add a limit to the loop"
client: Ignore transient_for causing loops
screen: Fix screen equality comparison
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.6 2013/06/17 13:23:34 dcoppa Exp $
d4 15
@


1.6
log
@
Bugfix: honor appended -c option for --check
(upstream git commit 57bec371f70f121785cd062dca3b86f18fd685fd)
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.5 2013/05/22 15:05:50 dcoppa Exp $
d13 25
d39 15
a53 2
+++ awesome.c	Mon Jun 17 14:57:00 2013
@@@@ -136,7 +136,7 @@@@ scan(xcb_query_tree_cookie_t tree_c)
d62 1
a62 1
@@@@ -288,6 +288,7 @@@@ main(int argc, char **argv)
d70 1
a70 1
@@@@ -340,16 +341,8 @@@@ main(int argc, char **argv)
d89 1
a89 2
@@@@ -360,6 +353,20 @@@@ main(int argc, char **argv)
             no_argb = true;
d92 1
a92 1
+
d106 1
a106 1
 
d109 9
@


1.5
log
@Major update to awesome-3.5.1

OK jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.4 2012/12/31 17:41:44 dcoppa Exp $
d5 10
a14 2
--- awesome.c.orig	Mon May 20 13:31:32 2013
+++ awesome.c	Mon May 20 13:31:52 2013
d24 48
@


1.4
log
@Update awesome to v3.4.14 (White Christmas)
@
text
@d1 1
a1 1
$OpenBSD: patch-awesome_c,v 1.3 2011/11/30 11:50:58 dcoppa Exp $
d5 3
a7 3
--- awesome.c.orig	Mon Dec 24 15:36:05 2012
+++ awesome.c	Mon Dec 31 11:54:55 2012
@@@@ -139,7 +139,7 @@@@ scan(xcb_query_tree_cookie_t tree_c[])
d9 7
a15 7
             if(!attr_r || attr_r->override_redirect
                || attr_r->map_state == XCB_MAP_STATE_UNMAPPED
-               || state == XCB_ICCCM_WM_STATE_WITHDRAWN)
+               || state == XCB_WM_STATE_WITHDRAWN)
             {
                 geom_wins[i] = NULL;
                 p_delete(&attr_r);
@


1.3
log
@Update to awesome v3.4.11 (Pickapart)

ChangeLog at http://awesome.naquadah.org/changelogs/short/v3.4.11
@
text
@d1 1
a1 1
$OpenBSD$
d5 3
a7 3
--- awesome.c.orig	Wed Nov 30 11:05:05 2011
+++ awesome.c	Wed Nov 30 11:05:55 2011
@@@@ -137,7 +137,7 @@@@ scan(xcb_query_tree_cookie_t tree_c[])
@


1.2
log
@From upstream git:
- Various bugfixes to Lua code.
- Fix a bug causing building with cmake 2.8.4 to fail (remove double
  slashes from icon path names).
@
text
@d1 7
a7 5
$OpenBSD: patch-awesome_c,v 1.1 2011/01/20 21:17:15 dcoppa Exp $
--- awesome.c.orig	Thu Jan 20 19:35:55 2011
+++ awesome.c	Thu Jan 20 19:36:44 2011
@@@@ -339,7 +339,7 @@@@ main(int argc, char **argv)
     luaA_init(&xdg);
d9 7
a15 6
     /* check args */
-    while((opt = getopt_long(argc, argv, "vhkc:",
+    while((opt = getopt_long(argc, argv, "vhkc:a",
                              long_options, NULL)) != -1)
         switch(opt)
         {
@


1.1
log
@An argument was forgotten in the getopt_long() call.

Bugfix from upstream git

Ok jasper@@
@
text
@d1 1
a1 1
$OpenBSD$
@

