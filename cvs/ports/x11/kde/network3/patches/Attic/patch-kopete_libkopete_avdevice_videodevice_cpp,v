head	1.4;
access;
symbols
	OPENBSD_5_9:1.3.0.28
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.30
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.26
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.24
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.22
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.20
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.18
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.16
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.14
	OPENBSD_5_0:1.3.0.12
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.10
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.6
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3;
locks; strict;
comment	@# @;


1.4
date	2016.04.29.21.10.23;	author zhuk;	state dead;
branches;
next	1.3;
commitid	u9TvebbKy1wgQMr9;

1.3
date	2008.09.07.23.00.17;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.03.12.47.31;	author espie;	state dead;
branches;
next	1.1;

1.1
date	2006.04.29.01.02.24;	author brad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Remove KDE3 applications that have well-working KDE4+ counterparts.
@
text
@$OpenBSD: patch-kopete_libkopete_avdevice_videodevice_cpp,v 1.3 2008/09/07 23:00:17 brad Exp $
--- kopete/libkopete/avdevice/videodevice.cpp.orig	Wed Feb 13 16:03:06 2008
+++ kopete/libkopete/avdevice/videodevice.cpp	Sun Jun 22 03:59:23 2008
@@@@ -181,7 +181,7 @@@@ int VideoDevice::checkDevice()
 		m_videostream=false;
 
 		m_driver=VIDEODEV_DRIVER_NONE;
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 
 //if(!getWorkaroundBrokenDriver())
@@@@ -360,6 +360,7 @@@@ kdDebug(14010) <<  k_funcinfo << " Control: " << QStri
 
 }
 #endif
+#ifdef __linux__
 
 		CLEAR(V4L_capabilities);
 
@@@@ -425,6 +426,7 @@@@ kdDebug(14010) <<  k_funcinfo << " Control: " << QStri
 			}
 		}
 #endif
+#endif
 		m_name=m_model; // Take care about changing the name to be different from the model itself...
 
 		detectPixelFormats();
@@@@ -512,7 +514,7 @@@@ int VideoDevice::initDevice()
 	m_io_method = IO_METHOD_NONE;
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			if(V4L2_capabilities.capabilities & V4L2_CAP_READWRITE)
@@@@ -540,6 +542,7 @@@@ int VideoDevice::initDevice()
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			m_videoread=true;
 			m_io_method=IO_METHOD_READ;
@@@@ -551,6 +554,7 @@@@ int VideoDevice::initDevice()
 			}
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 
@@@@ -558,7 +562,7 @@@@ int VideoDevice::initDevice()
 	}
 
 // Select video input, video standard and tune here.
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 	cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	if (-1 == xioctl (VIDIOC_CROPCAP, &cropcap))
@@@@ -676,7 +680,7 @@@@ kdDebug(14010) <<  k_funcinfo << "setSize(" << newwidt
 // Change resolution for the video device
 		switch(m_driver)
 		{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 			case VIDEODEV_DRIVER_V4L2:
 //				CLEAR (fmt);
@@@@ -705,6 +709,7 @@@@ kdDebug(14010) << k_funcinfo << "VIDIOC_S_FMT worked (
 				}
 				break;
 #endif
+#ifdef __linux__
 			case VIDEODEV_DRIVER_V4L:
 				{
 					struct video_window V4L_videowindow;
@@@@ -734,6 +739,7 @@@@ kdDebug(14010) << "------------- width: " << V4L_video
 				}
 				break;
 #endif
+#endif
 			case VIDEODEV_DRIVER_NONE:
 			default:
 				break;
@@@@ -778,7 +784,7 @@@@ pixel_format VideoDevice::setPixelFormat(pixel_format 
 // Change the pixel format for the video device
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 //			CLEAR (fmt);
@@@@ -805,6 +811,7 @@@@ pixel_format VideoDevice::setPixelFormat(pixel_format 
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			{
 			struct video_picture V4L_picture;
@@@@ -829,6 +836,7 @@@@ pixel_format VideoDevice::setPixelFormat(pixel_format 
 			}
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			break;
@@@@ -867,7 +875,7 @@@@ int VideoDevice::selectInput(int newinput)
 	{
 		switch (m_driver)
 		{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 			case VIDEODEV_DRIVER_V4L2:
 				if (-1 == ioctl (descriptor, VIDIOC_S_INPUT, &newinput))
@@@@ -877,6 +885,7 @@@@ int VideoDevice::selectInput(int newinput)
 				}
 				break;
 #endif
+#ifdef __linux__
 			case VIDEODEV_DRIVER_V4L:
 				struct video_channel V4L_input;
 				V4L_input.channel=newinput;
@@@@ -888,6 +897,7 @@@@ int VideoDevice::selectInput(int newinput)
 				}
 				break;
 #endif
+#endif
 			case VIDEODEV_DRIVER_NONE:
 			default:
 				break;
@@@@ -935,7 +945,7 @@@@ int VideoDevice::startCapturing()
 			case IO_METHOD_READ: // Nothing to do
 				break;
 			case IO_METHOD_MMAP:
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 				{
 					unsigned int loop;
@@@@ -957,7 +967,7 @@@@ int VideoDevice::startCapturing()
 #endif
 				break;
 			case IO_METHOD_USERPTR:
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 				{
 					unsigned int loop;
@@@@ -995,7 +1005,7 @@@@ int VideoDevice::getFrame()
     /// @@todo implement me
 	ssize_t bytesread;
 
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 	struct v4l2_buffer v4l2buffer;
 #endif
@@@@ -1029,7 +1039,7 @@@@ int VideoDevice::getFrame()
 				}
 				break;
 			case IO_METHOD_MMAP:
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 				CLEAR (v4l2buffer);
 				v4l2buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
@@@@ -1089,7 +1099,7 @@@@ memcpy(&m_currentbuffer.data[0], m_rawbuffers[v4l2buff
 #endif
 				break;
 			case IO_METHOD_USERPTR:
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 				{
 					unsigned int i;
@@@@ -1475,7 +1485,7 @@@@ float VideoDevice::setBrightness(float brightness)
 
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			{
@@@@ -1512,6 +1522,7 @@@@ float VideoDevice::setBrightness(float brightness)
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			{
 				struct video_picture V4L_picture;
@@@@ -1523,6 +1534,7 @@@@ float VideoDevice::setBrightness(float brightness)
 			}
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			break;
@@@@ -1545,7 +1557,7 @@@@ float VideoDevice::setContrast(float contrast)
 
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			{
@@@@ -1582,6 +1594,7 @@@@ float VideoDevice::setContrast(float contrast)
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			{
 				struct video_picture V4L_picture;
@@@@ -1593,6 +1606,7 @@@@ float VideoDevice::setContrast(float contrast)
 			}
 		break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			break;
@@@@ -1615,7 +1629,7 @@@@ float VideoDevice::setSaturation(float saturation)
 
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			{
@@@@ -1652,6 +1666,7 @@@@ float VideoDevice::setSaturation(float saturation)
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			{
 				struct video_picture V4L_picture;
@@@@ -1663,6 +1678,7 @@@@ float VideoDevice::setSaturation(float saturation)
 			}
 		break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			break;
@@@@ -1685,7 +1701,7 @@@@ float VideoDevice::setWhiteness(float whiteness)
 
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			{
@@@@ -1722,6 +1738,7 @@@@ float VideoDevice::setWhiteness(float whiteness)
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			{
 				struct video_picture V4L_picture;
@@@@ -1733,6 +1750,7 @@@@ float VideoDevice::setWhiteness(float whiteness)
 			}
 		break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			break;
@@@@ -1755,7 +1773,7 @@@@ float VideoDevice::setHue(float hue)
 
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			{
@@@@ -1792,6 +1810,7 @@@@ float VideoDevice::setHue(float hue)
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			{
 				struct video_picture V4L_picture;
@@@@ -1803,6 +1822,7 @@@@ float VideoDevice::setHue(float hue)
 			}
 		break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			break;
@@@@ -1876,7 +1896,7 @@@@ pixel_format VideoDevice::pixelFormatForPalette( int p
 {
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			switch(palette)
@@@@ -1927,6 +1947,7 @@@@ pixel_format VideoDevice::pixelFormatForPalette( int p
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			switch(palette)
 			{
@@@@ -1945,6 +1966,7 @@@@ pixel_format VideoDevice::pixelFormatForPalette( int p
 			}
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			return PIXELFORMAT_NONE;	break;
@@@@ -1956,7 +1978,7 @@@@ int VideoDevice::pixelFormatCode(pixel_format pixelfor
 {
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			switch(pixelformat)
@@@@ -2007,6 +2029,7 @@@@ int VideoDevice::pixelFormatCode(pixel_format pixelfor
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			switch(pixelformat)
 			{
@@@@ -2052,6 +2075,7 @@@@ int VideoDevice::pixelFormatCode(pixel_format pixelfor
 			}
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			return PIXELFORMAT_NONE;	break;
@@@@ -2162,7 +2186,7 @@@@ QString VideoDevice::pixelFormatName(int pixelformat)
 	returnvalue = "None";
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			switch(pixelformat)
@@@@ -2213,6 +2237,7 @@@@ QString VideoDevice::pixelFormatName(int pixelformat)
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			switch(pixelformat)
 			{
@@@@ -2230,6 +2255,7 @@@@ QString VideoDevice::pixelFormatName(int pixelformat)
 			}
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			break;
@@@@ -2242,7 +2268,7 @@@@ int VideoDevice::detectPixelFormats()
 			int err = 0;
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			fmtdesc.index = 0;
@@@@ -2264,6 +2290,7 @@@@ int VideoDevice::detectPixelFormats()
 			}
 //			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 // TODO: THis thing can be used to detec what pixel formats are supported in a API-independent way, but V4L2 has VIDIOC_ENUM_PIXFMT.
 // The correct thing to do is to isolate these calls and do a proper implementation for V4L and another for V4L2 when this thing will be migrated to a plugin architecture.
@@@@ -2308,6 +2335,7 @@@@ int VideoDevice::detectPixelFormats()
 			if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YYUV))	kdDebug(14010) <<  k_funcinfo << pixelFormatName(PIXELFORMAT_YYUV) << endl;
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			return PIXELFORMAT_NONE;	break;
@@@@ -2319,7 +2347,7 @@@@ __u64 VideoDevice::signalStandardCode(signal_standard 
 {
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			switch(standard)
@@@@ -2362,6 +2390,7 @@@@ __u64 VideoDevice::signalStandardCode(signal_standard 
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			switch(standard)
 			{
@@@@ -2403,6 +2432,7 @@@@ __u64 VideoDevice::signalStandardCode(signal_standard 
 			}
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			return STANDARD_NONE;	break;
@@@@ -2461,7 +2491,7 @@@@ QString VideoDevice::signalStandardName(int standard)
 	returnvalue = "None";
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			switch(standard)
@@@@ -2503,6 +2533,7 @@@@ QString VideoDevice::signalStandardName(int standard)
 			}
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			switch(standard)
 			{
@@@@ -2517,6 +2548,7 @@@@ QString VideoDevice::signalStandardName(int standard)
 			}
 			break;
 #endif
+#endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
 			break;
@@@@ -2531,13 +2563,15 @@@@ int VideoDevice::detectSignalStandards()
 {
 	switch(m_driver)
 	{
-#if defined(__linux__) && defined(ENABLE_AV)
+#if defined(ENABLE_AV) && (defined(__linux__) || defined(__OpenBSD__))
 #ifdef V4L2_CAP_VIDEO_CAPTURE
 		case VIDEODEV_DRIVER_V4L2:
 			break;
 #endif
+#ifdef __linux__
 		case VIDEODEV_DRIVER_V4L:
 			break;
+#endif
 #endif
 		case VIDEODEV_DRIVER_NONE:
 		default:
@


1.3
log
@Enable the V4L2 support in Kopete. Tested with MSN webcam support.

ok robert@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@minor update to 3.5.3, integrate libidn support (some more changes to come
to WANTLIB in packages dependent on KDE).
@
text
@d1 6
a6 4
$OpenBSD: patch-kopete_libkopete_avdevice_videodevice_cpp,v 1.1 2006/04/29 01:02:24 brad Exp $
--- kopete/libkopete/avdevice/videodevice.cpp.orig	Fri Mar 17 05:12:32 2006
+++ kopete/libkopete/avdevice/videodevice.cpp	Fri Apr 28 15:52:51 2006
@@@@ -141,6 +141,9 @@@@ int VideoDevice::checkDevice()
d8 6
a13 6
 #if defined(__linux__) && defined(ENABLE_AV)
 #ifdef HAVE_V4L2
+
+if(!getWorkaroundBrokenDriver())
+{
 		CLEAR(V4L2_capabilities);
d15 1
a15 17
 		if (-1 != xioctl (VIDIOC_QUERYCAP, &V4L2_capabilities))
@@@@ -214,7 +217,8 @@@@ int VideoDevice::checkDevice()
 				{
 					VideoInput tempinput;
 					tempinput.name = QString::fromLocal8Bit((const char*)videoinput.name);
-					tempinput.hastuner=videoinput.type & V4L2_INPUT_TYPE_TUNER;
+					tempinput.hastuner = videoinput.type & V4L2_INPUT_TYPE_TUNER;
+					tempinput.m_standards = videoinput.std;
 					m_input.push_back(tempinput);
 					kdDebug() <<  k_funcinfo << "Input " << loop << ": " << tempinput.name << " (tuner: " << ((videoinput.type & V4L2_INPUT_TYPE_TUNER) != 0) << ")" << endl;
 					if((videoinput.type & V4L2_INPUT_TYPE_TUNER) != 0)
@@@@ -237,6 +241,8 @@@@ int VideoDevice::checkDevice()
 // it will try the V4L api even if the error code is different than expected.
 			kdDebug() <<  k_funcinfo << "checkDevice(): " << full_filename << " is not a V4L2 device." << endl;
 		}
+
+}
d17 1
d20 3
a22 9
@@@@ -285,6 +291,7 @@@@ int VideoDevice::checkDevice()
 						VideoInput tempinput;
 						tempinput.name = QString::fromLocal8Bit((const char*)videoinput.name);
 						tempinput.hastuner=videoinput.flags & VIDEO_VC_TUNER;
+// TODO: The routine to detect the appropriate video standards for V4L must be placed here
 						m_input.push_back(tempinput);
 //						kdDebug() << "libkopete (avdevice): Input " << loop << ": " << tempinput.name << " (tuner: " << ((videoinput.flags & VIDEO_VC_TUNER) != 0) << ")" << endl;
 /*						if((input.type & V4L2_INPUT_TYPE_TUNER) != 0)
@@@@ -303,6 +310,8 @@@@ int VideoDevice::checkDevice()
d25 1
d27 28
a54 13
+// TODO: THis thing can be used to detec what pixel formats are supported in a API-independent way, but V4L2 has VIDIOC_ENUM_PIXFMT.
+// The correct thing to do is to isolate these calls and do a proper implementation for V4L and another for V4L2 when this thing will be migrated to a plugin architecture.
 		kdDebug() <<  k_funcinfo << "checkDevice(): " << "Supported pixel formats:" << endl;
 		if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_GREY))
 			kdDebug() <<  k_funcinfo << "checkDevice(): " << pixelFormatName(PIXELFORMAT_GREY) << endl;
@@@@ -333,7 +342,7 @@@@ int VideoDevice::checkDevice()
 		if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUV420P))
 			kdDebug() <<  k_funcinfo << "checkDevice(): " << pixelFormatName(PIXELFORMAT_YUV420P) << endl;
 
-		// Now we must execute the proper initialization according to the type of the driver.
+// TODO: Now we must execute the proper initialization according to the type of the driver.
 		kdDebug() <<  k_funcinfo << "checkDevice() exited successfuly." << endl;
 		return EXIT_SUCCESS;
a55 3
@@@@ -743,7 +752,6 @@@@ int VideoDevice::selectInput(int newinpu
 	if(m_current_input >= inputs())
 		return EXIT_FAILURE;
d57 57
a113 2
-	m_current_input = newinput;
 	if(isOpen())
d116 11
a126 1
@@@@ -761,7 +769,7 @@@@ int VideoDevice::selectInput(int newinpu
d130 15
a144 3
-				V4L_input.norm=1;
+				V4L_input.norm=4; // Hey, it's plain wrong! It should be input's signal standard!
 				if (-1 == ioctl (descriptor, VIDIOCSCHAN, &V4L_input))
d146 3
a148 2
 					perror ("ioctl (VIDIOCSCHAN)");
@@@@ -774,6 +782,7 @@@@ int VideoDevice::selectInput(int newinpu
d150 34
a183 7
 		}
 		kdDebug() <<  k_funcinfo << "Selected input " << newinput << " (" << m_input[newinput].name << ")" << endl;
+		m_current_input = newinput;
 		setInputParameters();
 		return EXIT_SUCCESS;
 	}
@@@@ -1282,7 +1291,10 @@@@ int VideoDevice::close()
d185 24
a208 7
 float VideoDevice::getBrightness()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getBrightness();
+  else
+	return 0;
 }
d210 24
a233 2
 float VideoDevice::setBrightness(float brightness)
@@@@ -1317,7 +1329,10 @@@@ float VideoDevice::setBrightness(float b
d235 24
a258 7
 float VideoDevice::getContrast()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getContrast();
+  else
+	return 0;
 }
d260 24
a283 2
 float VideoDevice::setContrast(float contrast)
@@@@ -1352,7 +1367,10 @@@@ float VideoDevice::setContrast(float con
d285 24
a308 1
 float VideoDevice::getSaturation()
d310 24
a333 10
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getSaturation();
+  else
+	return 0;
 }
 
 float VideoDevice::setSaturation(float saturation)
@@@@ -1387,7 +1405,10 @@@@ float VideoDevice::setSaturation(float s
 
 float VideoDevice::getWhiteness()
d335 1
a335 109
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getWhiteness();
+  else
+	return 0;
 }
 
 float VideoDevice::setWhiteness(float whiteness)
@@@@ -1422,7 +1443,10 @@@@ float VideoDevice::setWhiteness(float wh
 
 float VideoDevice::getHue()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getHue();
+  else
+	return 0;
 }
 
 float VideoDevice::setHue(float hue)
@@@@ -1458,41 +1482,77 @@@@ float VideoDevice::setHue(float hue)
 
 bool VideoDevice::getAutoBrightnessContrast()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getAutoBrightnessContrast();
+  else
+	return false;
 }
 
 bool VideoDevice::setAutoBrightnessContrast(bool brightnesscontrast)
 {
 	kdDebug() <<  k_funcinfo << "VideoDevice::setAutoBrightnessContrast(" << brightnesscontrast << ") called." << endl;
-	m_input[m_current_input].setAutoBrightnessContrast(brightnesscontrast);
-	return m_input[m_current_input].getAutoBrightnessContrast();
-
+	if (m_current_input < m_input.size() ) 
+	  {
+		m_input[m_current_input].setAutoBrightnessContrast(brightnesscontrast);
+		return m_input[m_current_input].getAutoBrightnessContrast();
+	  }
+	else
+	  return false;
+   
 }
 
 bool VideoDevice::getAutoColorCorrection()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getAutoColorCorrection();
+  else
+	return false;
 }
 
 bool VideoDevice::setAutoColorCorrection(bool colorcorrection)
 {
 	kdDebug() <<  k_funcinfo << "VideoDevice::setAutoColorCorrection(" << colorcorrection << ") called." << endl;
-	m_input[m_current_input].setAutoColorCorrection(colorcorrection);
-	return m_input[m_current_input].getAutoColorCorrection();
+	if (m_current_input < m_input.size() )
+	  {
+		m_input[m_current_input].setAutoColorCorrection(colorcorrection);
+		return m_input[m_current_input].getAutoColorCorrection();
+	  }
+	else
+	  return false;
 }
 
 bool VideoDevice::getImageAsMirror()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getImageAsMirror();
+  else
+	return false;
 }
 
 bool VideoDevice::setImageAsMirror(bool imageasmirror)
 {
 	kdDebug() <<  k_funcinfo << "VideoDevice::setImageAsMirror(" << imageasmirror << ") called." << endl;
-	m_input[m_current_input].setImageAsMirror(imageasmirror);
-	return m_input[m_current_input].getImageAsMirror();
+	if (m_current_input < m_input.size() ) 
+	  {
+		m_input[m_current_input].setImageAsMirror(imageasmirror);
+		return m_input[m_current_input].getImageAsMirror();
+	  }
+	else
+	  return false;
 }
 
+bool VideoDevice::getDisableMMap()
+{
+	return m_disablemmap;
+}
+
+bool VideoDevice::setDisableMMap(bool disablemmap)
+{
+	kdDebug() <<  k_funcinfo << "VideoDevice::setDisableMMap(" << disablemmap << ") called." << endl;
+	m_disablemmap = disablemmap;
+	return m_disablemmap;
+}
+
 bool VideoDevice::getWorkaroundBrokenDriver()
 {
 	return m_workaroundbrokendriver;
@@@@ -1637,6 +1697,7 @@@@ int VideoDevice::pixelFormatDepth(pixel_
 QString VideoDevice::pixelFormatName(pixel_format pixelformat)
 {
 	QString returnvalue;
+	returnvalue = "None";
 	switch(pixelformat)
d337 3
a339 2
 		case PIXELFORMAT_NONE	: returnvalue = "None";			break;
@@@@ -1669,36 +1730,36 @@@@ QString VideoDevice::pixelFormatName(int
d342 7
d350 18
a367 28
-				case V4L2_PIX_FMT_GREY		: returnvalue = "8-bit Grayscale";	break;
-				case V4L2_PIX_FMT_RGB332	: returnvalue = "8-bit RGB332";		break;
-				case V4L2_PIX_FMT_RGB555	: returnvalue = "16-bit RGB555";	break;
-				case V4L2_PIX_FMT_RGB555X	: returnvalue = "16-bit RGB555X";	break;
-				case V4L2_PIX_FMT_RGB565	: returnvalue = "16-bit RGB565";	break;
-				case V4L2_PIX_FMT_RGB565X	: returnvalue = "16-bit RGB565X";	break;
-				case V4L2_PIX_FMT_RGB24		: returnvalue = "24-bit RGB24";		break;
-				case V4L2_PIX_FMT_BGR24		: returnvalue = "24-bit BGR24";		break;
-				case V4L2_PIX_FMT_RGB32		: returnvalue = "32-bit RGB32";		break;
-				case V4L2_PIX_FMT_BGR32		: returnvalue = "32-bit BGR32";		break;
-				case V4L2_PIX_FMT_YUYV		: returnvalue = "Packed YUV 4:2:2";	break;
-				case V4L2_PIX_FMT_UYVY		: returnvalue = "Packed YVU 4:2:2";	break;
-				case V4L2_PIX_FMT_YUV420	: returnvalue = "Planar YUV 4:2:0";	break;
-				case V4L2_PIX_FMT_YUV422P	: returnvalue = "Planar YUV 4:2:2";	break;
+				case V4L2_PIX_FMT_GREY		: returnvalue = pixelFormatName(PIXELFORMAT_GREY);	break;
+				case V4L2_PIX_FMT_RGB332	: returnvalue = pixelFormatName(PIXELFORMAT_RGB332);	break;
+				case V4L2_PIX_FMT_RGB555	: returnvalue = pixelFormatName(PIXELFORMAT_RGB555);	break;
+				case V4L2_PIX_FMT_RGB555X	: returnvalue = pixelFormatName(PIXELFORMAT_RGB555X);	break;
+				case V4L2_PIX_FMT_RGB565	: returnvalue = pixelFormatName(PIXELFORMAT_RGB565);	break;
+				case V4L2_PIX_FMT_RGB565X	: returnvalue = pixelFormatName(PIXELFORMAT_RGB565X);	break;
+				case V4L2_PIX_FMT_RGB24		: returnvalue = pixelFormatName(PIXELFORMAT_RGB24);	break;
+				case V4L2_PIX_FMT_BGR24		: returnvalue = pixelFormatName(PIXELFORMAT_BGR24);	break;
+				case V4L2_PIX_FMT_RGB32		: returnvalue = pixelFormatName(PIXELFORMAT_RGB32);	break;
+				case V4L2_PIX_FMT_BGR32		: returnvalue = pixelFormatName(PIXELFORMAT_BGR32);	break;
+				case V4L2_PIX_FMT_YUYV		: returnvalue = pixelFormatName(PIXELFORMAT_YUYV);	break;
+				case V4L2_PIX_FMT_UYVY		: returnvalue = pixelFormatName(PIXELFORMAT_UYVY);	break;
+				case V4L2_PIX_FMT_YUV420	: returnvalue = pixelFormatName(PIXELFORMAT_YUV420P);	break;
+				case V4L2_PIX_FMT_YUV422P	: returnvalue = pixelFormatName(PIXELFORMAT_YUV422P);	break;
d371 1
d375 68
a442 20
-				case VIDEO_PALETTE_GREY		: returnvalue = "8-bit Grayscale";	break;
-				case VIDEO_PALETTE_HI240	: returnvalue = "8-bit RGB332";		break;
-				case VIDEO_PALETTE_RGB555	: returnvalue = "16-bit RGB555";	break;
-				case VIDEO_PALETTE_RGB565	: returnvalue = "16-bit RGB565";	break;
-				case VIDEO_PALETTE_RGB24	: returnvalue = "24-bit RGB24";		break;
-				case VIDEO_PALETTE_RGB32	: returnvalue = "32-bit RGB32";		break;
-				case VIDEO_PALETTE_YUYV		: returnvalue = "Packed YUV 4:2:2";	break;
-				case VIDEO_PALETTE_UYVY		: returnvalue = "Packed YVU 4:2:2";	break;
-				case VIDEO_PALETTE_YUV420	: returnvalue = "Planar YUV 4:2:0";	break;
-				case VIDEO_PALETTE_YUV422P	: returnvalue = "Planar YUV 4:2:2";	break;
+				case VIDEO_PALETTE_GREY		: returnvalue = pixelFormatName(PIXELFORMAT_GREY);	break;
+				case VIDEO_PALETTE_HI240	: returnvalue = pixelFormatName(PIXELFORMAT_RGB332);	break;
+				case VIDEO_PALETTE_RGB555	: returnvalue = pixelFormatName(PIXELFORMAT_RGB555);	break;
+				case VIDEO_PALETTE_RGB565	: returnvalue = pixelFormatName(PIXELFORMAT_RGB565);	break;
+				case VIDEO_PALETTE_RGB24	: returnvalue = pixelFormatName(PIXELFORMAT_RGB24);	break;
+				case VIDEO_PALETTE_RGB32	: returnvalue = pixelFormatName(PIXELFORMAT_RGB32);	break;
+				case VIDEO_PALETTE_YUYV		: returnvalue = pixelFormatName(PIXELFORMAT_YUYV);	break;
+				case VIDEO_PALETTE_UYVY		: returnvalue = pixelFormatName(PIXELFORMAT_UYVY);	break;
+				case VIDEO_PALETTE_YUV420	: returnvalue = pixelFormatName(PIXELFORMAT_YUV420P);	break;
+				case VIDEO_PALETTE_YUV422P	: returnvalue = pixelFormatName(PIXELFORMAT_YUV422P);	break;
d446 6
a451 1
@@@@ -1707,6 +1768,238 @@@@ QString VideoDevice::pixelFormatName(int
d453 22
a474 237
 	}
 	return returnvalue;
+}
+
+__u64 VideoDevice::signalStandardCode(signal_standard standard)
+{
+	switch(m_driver)
+	{
+#if defined(__linux__) && defined(ENABLE_AV)
+#ifdef HAVE_V4L2
+		case VIDEODEV_DRIVER_V4L2:
+			switch(standard)
+			{
+				case STANDARD_NONE	: return V4L2_STD_UNKNOWN;	break;
+				case STANDARD_PAL_B	: return V4L2_STD_PAL_B;	break;
+				case STANDARD_PAL_B1	: return V4L2_STD_PAL_B1;	break;
+				case STANDARD_PAL_G	: return V4L2_STD_PAL_G;	break;
+				case STANDARD_PAL_H	: return V4L2_STD_PAL_H;	break;
+				case STANDARD_PAL_I	: return V4L2_STD_PAL_I;	break;
+				case STANDARD_PAL_D	: return V4L2_STD_PAL_D;	break;
+				case STANDARD_PAL_D1	: return V4L2_STD_PAL_D1;	break;
+				case STANDARD_PAL_K	: return V4L2_STD_PAL_K;	break;
+				case STANDARD_PAL_M	: return V4L2_STD_PAL_M;	break;
+				case STANDARD_PAL_N	: return V4L2_STD_PAL_N;	break;
+				case STANDARD_PAL_Nc	: return V4L2_STD_PAL_Nc;	break;
+				case STANDARD_PAL_60	: return V4L2_STD_PAL_60;	break;
+				case STANDARD_NTSC_M	: return V4L2_STD_NTSC_M;	break;
+				case STANDARD_NTSC_M_JP	: return V4L2_STD_NTSC_M_JP;	break;
+				case STANDARD_NTSC_443	: return V4L2_STD_NTSC;		break; // Using workaround value because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case STANDARD_SECAM_B	: return V4L2_STD_SECAM_B;	break;
+				case STANDARD_SECAM_D	: return V4L2_STD_SECAM_D;	break;
+				case STANDARD_SECAM_G	: return V4L2_STD_SECAM_G;	break;
+				case STANDARD_SECAM_H	: return V4L2_STD_SECAM_H;	break;
+				case STANDARD_SECAM_K	: return V4L2_STD_SECAM_K;	break;
+				case STANDARD_SECAM_K1	: return V4L2_STD_SECAM_K1;	break;
+				case STANDARD_SECAM_L	: return V4L2_STD_SECAM_L;	break;
+				case STANDARD_SECAM_LC	: return V4L2_STD_SECAM;	break; // Using workaround value because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case STANDARD_ATSC_8_VSB	: return V4L2_STD_ATSC_8_VSB;	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case STANDARD_ATSC_16_VSB	: return V4L2_STD_ATSC_16_VSB;	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case STANDARD_PAL_BG	: return V4L2_STD_PAL_BG;	break;
+				case STANDARD_PAL_DK	: return V4L2_STD_PAL_DK;	break;
+				case STANDARD_PAL	: return V4L2_STD_PAL;		break;
+				case STANDARD_NTSC	: return V4L2_STD_NTSC;		break;
+				case STANDARD_SECAM_DK	: return V4L2_STD_SECAM_DK;	break;
+				case STANDARD_SECAM	: return V4L2_STD_SECAM;	break;
+				case STANDARD_525_60	: return V4L2_STD_525_60;	break;
+				case STANDARD_625_50	: return V4L2_STD_625_50;	break;
+				case STANDARD_ALL	: return V4L2_STD_ALL;		break;
+			}
+			break;
+#endif
+		case VIDEODEV_DRIVER_V4L:
+			switch(standard)
+			{
+				case STANDARD_NONE	: return VIDEO_MODE_AUTO;	break;
+				case STANDARD_PAL_B	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_B1	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_G	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_H	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_I	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_D	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_D1	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_K	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_M	: return 5;	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case STANDARD_PAL_N	: return 6;	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case STANDARD_PAL_Nc	: return 4;	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case STANDARD_PAL_60	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_NTSC_M	: return VIDEO_MODE_NTSC;	break;
+				case STANDARD_NTSC_M_JP	: return 7;	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case STANDARD_NTSC_443	: return VIDEO_MODE_NTSC;	break; // Using workaround value because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case STANDARD_SECAM_B	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_D	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_G	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_H	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_K	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_K1	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_L	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_LC	: return VIDEO_MODE_SECAM;	break; // Using workaround value because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case STANDARD_ATSC_8_VSB	: return VIDEO_MODE_AUTO;	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case STANDARD_ATSC_16_VSB	: return VIDEO_MODE_AUTO;	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case STANDARD_PAL_BG	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_DK	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_NTSC	: return VIDEO_MODE_NTSC;	break;
+				case STANDARD_SECAM_DK	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_525_60	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_625_50	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_ALL	: return VIDEO_MODE_AUTO;	break;
+			}
+			break;
+#endif
+		case VIDEODEV_DRIVER_NONE:
+		default:
+			return STANDARD_NONE;	break;
+	}
+	return STANDARD_NONE;
+}
+
+QString VideoDevice::signalStandardName(signal_standard standard)
+{
+	QString returnvalue;
+	returnvalue = "None";
+	switch(standard)
+	{
+		case STANDARD_NONE	: returnvalue = "None";		break;
+		case STANDARD_PAL_B	: returnvalue = "PAL-B";	break;
+		case STANDARD_PAL_B1	: returnvalue = "PAL-B1"; 	break;
+		case STANDARD_PAL_G	: returnvalue = "PAL-G";	break;
+		case STANDARD_PAL_H	: returnvalue = "PAL-H";	break;
+		case STANDARD_PAL_I	: returnvalue = "PAL-I";	break;
+		case STANDARD_PAL_D	: returnvalue = "PAL-D";	break;
+		case STANDARD_PAL_D1	: returnvalue = "PAL-D1";	break;
+		case STANDARD_PAL_K	: returnvalue = "PAL-K";	break;
+		case STANDARD_PAL_M	: returnvalue = "PAL-M";	break;
+		case STANDARD_PAL_N	: returnvalue = "PAL-N";	break;
+		case STANDARD_PAL_Nc	: returnvalue = "PAL-Nc";	break;
+		case STANDARD_PAL_60	: returnvalue = "PAL-60";	break;
+		case STANDARD_NTSC_M	: returnvalue = "NTSC-M";	break;
+		case STANDARD_NTSC_M_JP	: returnvalue = "NTSC-M(JP)";	break;
+		case STANDARD_NTSC_443	: returnvalue = "NTSC-443";	break;
+		case STANDARD_SECAM_B	: returnvalue = "SECAM-B";	break;
+		case STANDARD_SECAM_D	: returnvalue = "SECAM-D";	break;
+		case STANDARD_SECAM_G	: returnvalue = "SECAM-G";	break;
+		case STANDARD_SECAM_H	: returnvalue = "SECAM-H";	break;
+		case STANDARD_SECAM_K	: returnvalue = "SECAM-K";	break;
+		case STANDARD_SECAM_K1	: returnvalue = "SECAM-K1";	break;
+		case STANDARD_SECAM_L	: returnvalue = "SECAM-L";	break;
+		case STANDARD_SECAM_LC	: returnvalue = "SECAM-LC";	break;
+		case STANDARD_ATSC_8_VSB	: returnvalue = "ATSC-8-VSB";	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+		case STANDARD_ATSC_16_VSB	: returnvalue = "ATSC-16-VSB";	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+		case STANDARD_PAL_BG	: returnvalue = "PAL-BG";	break;
+		case STANDARD_PAL_DK	: returnvalue = "PAL-DK";	break;
+		case STANDARD_PAL	: returnvalue = "PAL";		break;
+		case STANDARD_NTSC	: returnvalue = "NTSC";		break;
+		case STANDARD_SECAM_DK  : returnvalue = "SECAM-DK";	break;
+		case STANDARD_SECAM	: returnvalue = "SECAM";	break;
+		case STANDARD_525_60	: returnvalue = "525 lines 60Hz";	break;
+		case STANDARD_625_50	: returnvalue = "625 lines 50Hz"; 	break;
+		case STANDARD_ALL	: returnvalue = "All";		break;
+	}
+	return returnvalue;
+}
+
+QString VideoDevice::signalStandardName(int standard)
+{
+	QString returnvalue;
+	returnvalue = "None";
+	switch(m_driver)
+	{
+#if defined(__linux__) && defined(ENABLE_AV)
+#ifdef HAVE_V4L2
+		case VIDEODEV_DRIVER_V4L2:
+			switch(standard)
+			{
+				case V4L2_STD_PAL_B	: returnvalue = signalStandardName(STANDARD_PAL_B);	break;
+				case V4L2_STD_PAL_B1	: returnvalue = signalStandardName(STANDARD_PAL_B1);	break;
+				case V4L2_STD_PAL_G	: returnvalue = signalStandardName(STANDARD_PAL_G);	break;
+				case V4L2_STD_PAL_H	: returnvalue = signalStandardName(STANDARD_PAL_H);	break;
+				case V4L2_STD_PAL_I	: returnvalue = signalStandardName(STANDARD_PAL_I);	break;
+				case V4L2_STD_PAL_D	: returnvalue = signalStandardName(STANDARD_PAL_D);	break;
+				case V4L2_STD_PAL_D1	: returnvalue = signalStandardName(STANDARD_PAL_D1);	break;
+				case V4L2_STD_PAL_K	: returnvalue = signalStandardName(STANDARD_PAL_K);	break;
+				case V4L2_STD_PAL_M	: returnvalue = signalStandardName(STANDARD_PAL_M);	break;
+				case V4L2_STD_PAL_N	: returnvalue = signalStandardName(STANDARD_PAL_N);	break;
+				case V4L2_STD_PAL_Nc	: returnvalue = signalStandardName(STANDARD_PAL_Nc);	break;
+				case V4L2_STD_PAL_60	: returnvalue = signalStandardName(STANDARD_PAL_60);	break;
+				case V4L2_STD_NTSC_M	: returnvalue = signalStandardName(STANDARD_NTSC_M);	break;
+				case V4L2_STD_NTSC_M_JP	: returnvalue = signalStandardName(STANDARD_NTSC_M_JP);	break;
+//				case V4L2_STD_NTSC_443	: returnvalue = signalStandardName(STANDARD_NTSC_443);	break; // Commented out because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case V4L2_STD_SECAM_B	: returnvalue = signalStandardName(STANDARD_SECAM_B);	break;
+				case V4L2_STD_SECAM_D	: returnvalue = signalStandardName(STANDARD_SECAM_D);	break;
+				case V4L2_STD_SECAM_G	: returnvalue = signalStandardName(STANDARD_SECAM_G);	break;
+				case V4L2_STD_SECAM_H	: returnvalue = signalStandardName(STANDARD_SECAM_H);	break;
+				case V4L2_STD_SECAM_K	: returnvalue = signalStandardName(STANDARD_SECAM_K);	break;
+				case V4L2_STD_SECAM_K1	: returnvalue = signalStandardName(STANDARD_SECAM_K1);	break;
+				case V4L2_STD_SECAM_L	: returnvalue = signalStandardName(STANDARD_SECAM_L);	break;
+//				case V4L2_STD_SECAM_LC	: returnvalue = signalStandardName(STANDARD_SECAM_LC);	break; // Commented out because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case V4L2_STD_ATSC_8_VSB	: returnvalue = signalStandardName(STANDARD_ATSC_8_VSB);	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case V4L2_STD_ATSC_16_VSB	: returnvalue = signalStandardName(STANDARD_ATSC_16_VSB);	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case V4L2_STD_PAL_BG	: returnvalue = signalStandardName(STANDARD_PAL_BG);	break;
+				case V4L2_STD_PAL_DK	: returnvalue = signalStandardName(STANDARD_PAL_DK);	break;
+				case V4L2_STD_PAL	: returnvalue = signalStandardName(STANDARD_PAL);	break;
+				case V4L2_STD_NTSC	: returnvalue = signalStandardName(STANDARD_NTSC);	break;
+				case V4L2_STD_SECAM_DK	: returnvalue = signalStandardName(STANDARD_SECAM_DK);	break;
+				case V4L2_STD_SECAM	: returnvalue = signalStandardName(STANDARD_SECAM);	break;
+				case V4L2_STD_525_60	: returnvalue = signalStandardName(STANDARD_525_60);	break;
+				case V4L2_STD_625_50	: returnvalue = signalStandardName(STANDARD_625_50);	break;
+				case V4L2_STD_ALL	: returnvalue = signalStandardName(STANDARD_ALL);	break;
+			}
+			break;
+#endif
+		case VIDEODEV_DRIVER_V4L:
+			switch(standard)
+			{
+				case VIDEO_MODE_PAL	: returnvalue = signalStandardName(STANDARD_PAL);	break;
+				case VIDEO_MODE_NTSC	: returnvalue = signalStandardName(STANDARD_NTSC);	break;
+				case VIDEO_MODE_SECAM	: returnvalue = signalStandardName(STANDARD_SECAM);	break;
+				case VIDEO_MODE_AUTO	: returnvalue = signalStandardName(STANDARD_ALL);	break;	// It must be disabled until I find a correct way to handle those non-standard bttv modes
+//				case VIDEO_MODE_PAL_Nc	: returnvalue = signalStandardName(STANDARD_PAL_Nc);	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case VIDEO_MODE_PAL_M	: returnvalue = signalStandardName(STANDARD_PAL_M);	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case VIDEO_MODE_PAL_N	: returnvalue = signalStandardName(STANDARD_PAL_N);	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case VIDEO_MODE_NTSC_JP	: returnvalue = signalStandardName(STANDARD_NTSC_M_JP);	break;	// Undocumented value found to be compatible with V4L bttv driver
+			}
+			break;
+#endif
+		case VIDEODEV_DRIVER_NONE:
+		default:
+			break;
+	}
+	return returnvalue;
+}
+
+/*!
+    \fn VideoDevice::detectSignalStandards()
+ */
+int VideoDevice::detectSignalStandards()
+{
+	switch(m_driver)
+	{
+#if defined(__linux__) && defined(ENABLE_AV)
+#ifdef HAVE_V4L2
+		case VIDEODEV_DRIVER_V4L2:
+			break;
+#endif
+		case VIDEODEV_DRIVER_V4L:
+			break;
+#endif
+		case VIDEODEV_DRIVER_NONE:
+		default:
+			break;
+	}
+	//FIXME: return a real value
+	return 0;
 }
 
 /*!
@


1.1
log
@Backport for the 120117 fix and some other bugs.

http://bugs.kde.org/show_bug.cgi?id=120117

From KDE SVN.
@
text
@d1 1
a1 1
$OpenBSD$
@

