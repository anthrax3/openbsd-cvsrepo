head	1.2;
access;
symbols
	OPENBSD_5_9:1.1.0.20
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.22
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.18
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.16
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.14
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.12
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.10
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.8
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2016.04.29.21.20.37;	author zhuk;	state dead;
branches;
next	1.1;
commitid	jLKJQnZluyuYhQUu;

1.1
date	2010.09.23.22.24.50;	author jeremy;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove another bunch of KDE3 ports: outdated, superseded and useless ones.
@
text
@$OpenBSD: patch-qtruby_rubylib_qtruby_Qt_cpp,v 1.1 2010/09/23 22:24:50 jeremy Exp $
--- qtruby/rubylib/qtruby/Qt.cpp.orig	Mon Jan 15 03:19:09 2007
+++ qtruby/rubylib/qtruby/Qt.cpp	Fri Sep  3 23:13:18 2010
@@@@ -950,7 +950,7 @@@@ cast_object_to(VALUE /*self*/, VALUE object, VALUE new
 const char *
 get_VALUEtype(VALUE ruby_value)
 {
-	char * classname = rb_obj_classname(ruby_value);
+	const char * classname = rb_obj_classname(ruby_value);
     const char *r = "";
     if(ruby_value == Qnil)
 	r = "u";
@@@@ -1432,7 +1432,7 @@@@ static QCString * mcid = 0;
 static VALUE
 method_missing(int argc, VALUE * argv, VALUE self)
 {
-	char * methodName = rb_id2name(SYM2ID(argv[0]));
+	const char * methodName = rb_id2name(SYM2ID(argv[0]));
     VALUE klass = rb_funcall(self, rb_intern("class"), 0);
 
 	// Look for 'thing?' methods, and try to match isThing() or hasThing() in the Smoke runtime
@@@@ -1475,14 +1475,14 @@@@ static QString * pred = 0;
     }
 
 	{
-		QCString * mcid = find_cached_selector(argc+3, temp_stack, klass, methodName);
+		QCString * mcid = find_cached_selector(argc+3, temp_stack, klass, (char *)methodName);
 
 		if (_current_method == -1) {
 			// Find the C++ method to call. Do that from Ruby for now
 
 			VALUE retval = rb_funcall2(qt_internal_module, rb_intern("do_method_missing"), argc+3, temp_stack);
 			if (_current_method == -1) {
-				char * op = rb_id2name(SYM2ID(argv[0]));
+				const char * op = rb_id2name(SYM2ID(argv[0]));
 				if (	qstrcmp(op, "-") == 0
 						|| qstrcmp(op, "+") == 0
 						|| qstrcmp(op, "/") == 0
@@@@ -1557,7 +1557,7 @@@@ static VALUE
 class_method_missing(int argc, VALUE * argv, VALUE klass)
 {
 	VALUE result = Qnil;
-	char * methodName = rb_id2name(SYM2ID(argv[0]));
+	const char * methodName = rb_id2name(SYM2ID(argv[0]));
 	VALUE * temp_stack = (VALUE *) calloc(argc+3, sizeof(VALUE));
     temp_stack[0] = rb_str_new2("Qt");
     temp_stack[1] = rb_str_new2(methodName);
@@@@ -1568,7 +1568,7 @@@@ class_method_missing(int argc, VALUE * argv, VALUE kla
     }
 
     {
-		QCString * mcid = find_cached_selector(argc+3, temp_stack, klass, methodName);
+		QCString * mcid = find_cached_selector(argc+3, temp_stack, klass, (char *)methodName);
 
 		if (_current_method == -1) {
 			VALUE retval = rb_funcall2(qt_internal_module, rb_intern("do_method_missing"), argc+3, temp_stack);
@@@@ -1674,7 +1674,7 @@@@ initialize_qt(int argc, VALUE * argv, VALUE self)
 	{ 
 		// Put this in a C block so that the mcid will be de-allocated at the end of the block,
 		// rather than on f'n exit, to avoid the longjmp problem described below
-		QCString * mcid = find_cached_selector(argc+4, temp_stack, klass, rb_class2name(klass));
+		QCString * mcid = find_cached_selector(argc+4, temp_stack, klass, (char *)rb_class2name(klass));
 
 		if (_current_method == -1) {
 			retval = rb_funcall2(qt_internal_module, rb_intern("do_method_missing"), argc+4, temp_stack);
@@@@ -1772,7 +1772,7 @@@@ qapplication_argv(VALUE /*self*/)
 VALUE
 getmetainfo(VALUE self, int &offset, int &index)
 {
-    char * signalname = rb_id2name(rb_frame_last_func());
+    const char * signalname = rb_id2name(rb_frame_last_func());
     VALUE metaObject_value = rb_funcall(qt_internal_module, rb_intern("getMetaObject"), 1, self);
 
     smokeruby_object *ometa = value_obj_info(metaObject_value);
@


1.1
log
@Handle changes caused by splitting the ruby port and bump

OK jcs@@, landry@@, jasper@@, sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@

