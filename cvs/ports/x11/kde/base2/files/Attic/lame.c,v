head	1.3;
access;
symbols
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.3
date	2002.09.11.17.43.42;	author espie;	state dead;
branches;
next	1.2;

1.2
date	2001.08.27.05.44.37;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.26.12.04.44;	author espie;	state Exp;
branches;
next	;


desc
@@


1.3
log
@ditch the files.
@
text
@#include <lame/lame.h>

lame_global_flags *
lame_init()
{
	return NULL;
}

void
id3tag_init(lame_global_flags *f)
{
}

void 
id3tag_set_album(lame_global_flags *f, const char *s)
{
}

void
id3tag_set_artist(lame_global_flags *f, const char *s)
{
}

void
id3tag_set_title(lame_global_flags *f, const char *s)
{
}

int
lame_init_params(lame_global_flags *f)
{
	return -1;
}

int
lame_encode_buffer_interleaved(lame_global_flags *f, short int pcm[],
	int num_samples, unsigned char *mp3buf, int bufsize)
{
	return -1;
}

int
lame_encode_finish(lame_global_flags *f, unsigned char *mp3buf, int sz)
{
	return -1;
}

int
lame_set_VBR(lame_global_flags *f, vbr_mode m)
{
	return 0;
}

int
lame_set_brate(lame_global_flags *f, int z)
{
	return 0;
}

int
lame_get_brate(const lame_global_flags *f)
{
	return 0;
}

int
lame_set_quality(lame_global_flags *f, int z)
{
	return 0;
}

int 
lame_set_VBR_mean_bitrate_kbps(lame_global_flags *f, int z)
{
	return 0;
}

int
lame_get_VBR_mean_bitrate_kbps(const lame_global_flags *f)
{
	return 0;
}

vbr_mode
lame_get_VBR(const lame_global_flags *f)
{
	return 0;
}

int
lame_set_VBR_min_bitrate_kbps(lame_global_flags *f, int z)
{
	return 0;
}

int
lame_set_VBR_hard_min(lame_global_flags *f, int z)
{
	return 0;
}

int
lame_set_VBR_max_bitrate_kbps(lame_global_flags *f, int z)
{
	return 0;
}

int
lame_set_VBR_q(lame_global_flags *f, int z)
{
	return 0;
}

int
lame_set_mode(lame_global_flags *f, MPEG_mode m)
{
	return 0;
}

int
lame_set_copyright(lame_global_flags *f, int c)
{
	return 0;
}

int
lame_set_original(lame_global_flags *f, int c)
{
	return 0;
}

int
lame_set_strict_ISO(lame_global_flags *f, int s)
{
	return 0;
}

int
lame_set_error_protection(lame_global_flags *f, int s)
{
	return 0;
}

int
lame_set_lowpassfreq(lame_global_flags *f, int s)
{
	return 0;
}

int
lame_set_lowpasswidth(lame_global_flags *f, int s)
{
	return 0;
}

int
lame_set_highpassfreq(lame_global_flags *f, int s)
{
	return 0;
}

int
lame_set_highpasswidth(lame_global_flags *f, int s)
{
	return 0;
}

int
lame_set_bWriteVbrTag(lame_global_flags *f, int s)
{
	return 0;
}

@


1.2
log
@Fix dependencies. Disable debug.
@
text
@@


1.1
log
@lame support
Somewhat sneaky: link against a `stub' lame library so that the dependency
is a build dependency.

This allows us to put a lame-enabled kdebase on the CD: it will refer to
the stub library by default. When you grab a newer lame, it will have
a higher minor number, and be used instead (this is the old ssl/crypto
trick).
@
text
@d157 6
d164 6
@

