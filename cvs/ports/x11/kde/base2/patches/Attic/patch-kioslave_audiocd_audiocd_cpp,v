head	1.4;
access;
symbols
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@# @;


1.4
date	2002.09.11.17.43.42;	author espie;	state dead;
branches;
next	1.3;

1.3
date	2001.09.19.14.13.28;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.26.14.05.05;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.23.22.25.49;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@ditch the files.
@
text
@$OpenBSD: patch-kioslave_audiocd_audiocd_cpp,v 1.3 2001/09/19 14:13:28 espie Exp $
--- kioslave/audiocd/audiocd.cpp.orig	Wed Sep  5 01:16:12 2001
+++ kioslave/audiocd/audiocd.cpp	Tue Sep 18 23:31:54 2001
@@@@ -41,8 +41,13 @@@@ extern "C"
 
 /* This is in support for the Mega Hack, if cdparanoia ever is fixed, or we
    use another ripping library we can remove this.  */
+#ifdef __linux__
 #include <linux/cdrom.h>
+#endif
 #include <sys/ioctl.h>
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/cdio.h>
+#endif
 
 #ifdef HAVE_LAME
 #include <lame/lame.h>
@@@@ -104,14 +109,24 @@@@ int FixupTOC(cdrom_drive *d, int tracks)
   start_of_first_data_as_in_toc = -1;
   hack_track = -1;
   if (d->ioctl_fd != -1) {
+#ifdef __linux__
     struct cdrom_multisession ms_str;
     ms_str.addr_format = CDROM_LBA;
     if (ioctl(d->ioctl_fd, CDROMMULTISESSION, &ms_str) == -1)
       return -1;
-    if (ms_str.addr.lba > 100) {
+#define ms_addr (ms_str.addr.lba)
+#endif
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+  int ms_addr;
+  ms_addr = 0;   /* last session */
+  if (ioctl(d->ioctl_fd, CDIOREADMSADDR, &ms_addr) == -1)
+        return -1;
+#endif
+
+    if (ms_addr > 100) {
       for (j = tracks-1; j >= 0; j--)
         if (j > 0 && !IS_AUDIO(d,j) && IS_AUDIO(d,j-1)) {
-          if (d->disc_toc[j].dwStartSector > ms_str.addr.lba - 11400) {
+          if (d->disc_toc[j].dwStartSector > ms_addr - 11400) {
             /* The next two code lines are the purpose of duplicating this
              * function, all others are an exact copy of paranoias FixupTOC().
              * The gory details: CD-Extra consist of N audio-tracks in the
@@@@ -132,7 +147,7 @@@@ int FixupTOC(cdrom_drive *d, int tracks)
              * length is only implicitely given.  Bloody sh*.  */
             start_of_first_data_as_in_toc = d->disc_toc[j].dwStartSector;
             hack_track = j + 1;
-            d->disc_toc[j].dwStartSector = ms_str.addr.lba - 11400;
+            d->disc_toc[j].dwStartSector = ms_addr - 11400;
           }
           break;
         }
@@@@ -273,11 +288,13 @@@@ AudioCDProtocol::initRequest(const KURL 
 {
 
 #ifdef HAVE_LAME
-  if (NULL == (d->gf = lame_init())) { // init the lame_global_flags structure with defaults
-    error(KIO::ERR_DOES_NOT_EXIST, url.path());
-    return 0;
-  }
-  id3tag_init (d->gf);
+  d->gf = lame_init();  // init the lame_global_flags structure with defaults
+  if (d->gf != NULL)
+    id3tag_init (d->gf);
+//  if (NULL == (d->gf = lame_init())) { 
+ //   error(KIO::ERR_DOES_NOT_EXIST, url.path());
+  //  return 0;
+//  }
 #endif
 
 #ifdef HAVE_VORBIS
@@@@ -429,7 +446,7 @@@@ AudioCDProtocol::get(const KURL & url)
  QString filetype = determineFiletype(d->fname);
 
 #ifdef HAVE_LAME
-  if (filetype == "mp3" && d->based_on_cddb && d->write_id3) {
+  if (filetype == "mp3" && d->gf != NULL && d->based_on_cddb && d->write_id3) {
     /* If CDDB is used to determine the filenames, tell lame to append ID3v1 TAG to MP3 Files */
     const char *tname =   d->titles[trackNumber-1].latin1();    // set trackname
     id3tag_set_album(d->gf, d->cd_title.latin1());
@@@@ -746,8 +763,11 @@@@ AudioCDProtocol::listDir(const KURL & ur
       listEntry(entry, false);
 
 #ifdef HAVE_LAME
-      app_dir(entry, d->s_mp3, d->tracks);
-      listEntry(entry, false);
+      if (d->gf != NULL)
+        {
+          app_dir(entry, d->s_mp3, d->tracks);
+          listEntry(entry, false);
+        }
 #endif
 
 #ifdef HAVE_VORBIS
@@@@ -1075,7 +1095,7 @@@@ static char mp3buffer[mp3buffer_size];
       ++currentSector;
 
 #ifdef HAVE_LAME
-      if ( filetype == "mp3" ) {
+      if ( filetype == "mp3" && d->gf != NULL) {
          int mp3bytes =
            lame_encode_buffer_interleaved(d->gf,buf,CD_FRAMESAMPLES,(unsigned char *)mp3buffer,(int)mp3buffer_size);
 
@@@@ -1158,7 +1178,7 @@@@ static char mp3buffer[mp3buffer_size];
     }
   }
 #ifdef HAVE_LAME
-  if (filetype == "mp3") {
+  if (filetype == "mp3" && d->gf != NULL) {
      int mp3bytes = lame_encode_finish(d->gf,(unsigned char *)mp3buffer,(int)mp3buffer_size);
 
      if (mp3bytes < 0 ) {
@@@@ -1224,6 +1244,8 @@@@ void AudioCDProtocol::getParameters() {
 
 #ifdef HAVE_LAME
 
+  if (d->gf != NULL)
+  {
   config->setGroup("MP3");
 
   int quality = config->readNumEntry("quality",2);
@@@@ -1311,6 +1333,7 @@@@ void AudioCDProtocol::getParameters() {
       lame_set_highpasswidth(d->gf, config->readNumEntry("highpassfilter_width",0));
     }
 
+  }
   }
 #endif // HAVE_LAME
 
@


1.3
log
@Update to 2.2.1.
Some patches folded back.
ksysguardd from Sebastian Stark. Doesn't work squeaky-clean yet, but at
least some people can look at it now...
@
text
@d1 1
a1 1
$OpenBSD: patch-kioslave_audiocd_audiocd_cpp,v 1.2 2001/08/26 14:05:05 espie Exp $
@


1.2
log
@Fix audiocd to continue working with the stubbed out lame.
@
text
@d1 3
a3 3
$OpenBSD: patch-kioslave_audiocd_audiocd_cpp,v 1.1 2001/08/23 22:25:49 espie Exp $
--- kioslave/audiocd/audiocd.cpp.orig	Sun Jul 29 06:56:35 2001
+++ kioslave/audiocd/audiocd.cpp	Sun Aug 26 14:48:51 2001
d114 1
a114 1
@@@@ -1224,94 +1244,96 @@@@ void AudioCDProtocol::getParameters() {
a117 1
-  config->setGroup("MP3");
d119 2
a120 2
+    {
+    config->setGroup("MP3");
d122 4
a125 2
-  int quality = config->readNumEntry("quality",2);
+    int quality = config->readNumEntry("quality",2);
d127 2
a128 145
-  if (quality < 0 ) quality = 0;
-  if (quality > 9) quality = 9;
+    if (quality < 0 ) quality = 0;
+    if (quality > 9) quality = 9;
 
-  int method = config->readNumEntry("encmethod",0);
+    int method = config->readNumEntry("encmethod",0);
 
-  if (method == 0) { 
-    
-    // Constant Bitrate Encoding
-    lame_set_VBR(d->gf, vbr_off);
-    lame_set_brate(d->gf,config->readNumEntry("cbrbitrate",160));
-    d->bitrate = lame_get_brate(d->gf);
-    lame_set_quality(d->gf, quality);
+    if (method == 0) { 
+      
+      // Constant Bitrate Encoding
+      lame_set_VBR(d->gf, vbr_off);
+      lame_set_brate(d->gf,config->readNumEntry("cbrbitrate",160));
+      d->bitrate = lame_get_brate(d->gf);
+      lame_set_quality(d->gf, quality);
 
-  } else {
-    
-    // Variable Bitrate Encoding
-    
-    if (config->readBoolEntry("set_vbr_avr",true)) {
+    } else {
+      
+      // Variable Bitrate Encoding
+      
+      if (config->readBoolEntry("set_vbr_avr",true)) {
 
-      lame_set_VBR(d->gf,vbr_abr);
-      lame_set_VBR_mean_bitrate_kbps(d->gf, config->readNumEntry("vbr_average_bitrate",0));
+        lame_set_VBR(d->gf,vbr_abr);
+        lame_set_VBR_mean_bitrate_kbps(d->gf, config->readNumEntry("vbr_average_bitrate",0));
 
-      d->bitrate = lame_get_VBR_mean_bitrate_kbps(d->gf);
+        d->bitrate = lame_get_VBR_mean_bitrate_kbps(d->gf);
 
-    } else {
+      } else {
 
-      if (lame_get_VBR(d->gf) == vbr_off) lame_set_VBR(d->gf, vbr_default);
+        if (lame_get_VBR(d->gf) == vbr_off) lame_set_VBR(d->gf, vbr_default);
 
-      if (config->readBoolEntry("set_vbr_min",true)) 
-	lame_set_VBR_min_bitrate_kbps(d->gf, config->readNumEntry("vbr_min_bitrate",0));
-      if (config->readBoolEntry("vbr_min_hard",true))
-	lame_set_VBR_hard_min(d->gf, 1);
-      if (config->readBoolEntry("set_vbr_max",true)) 
-	lame_set_VBR_max_bitrate_kbps(d->gf, config->readNumEntry("vbr_max_bitrate",0));
+        if (config->readBoolEntry("set_vbr_min",true)) 
+    lame_set_VBR_min_bitrate_kbps(d->gf, config->readNumEntry("vbr_min_bitrate",0));
+        if (config->readBoolEntry("vbr_min_hard",true))
+    lame_set_VBR_hard_min(d->gf, 1);
+        if (config->readBoolEntry("set_vbr_max",true)) 
+    lame_set_VBR_max_bitrate_kbps(d->gf, config->readNumEntry("vbr_max_bitrate",0));
 
-      d->bitrate = 128;
-      lame_set_VBR_q(d->gf, quality);
-      
-    }
+        d->bitrate = 128;
+        lame_set_VBR_q(d->gf, quality);
+        
+      }
 
-    if ( config->readBoolEntry("write_xing_tag",true) ) lame_set_bWriteVbrTag(d->gf, 1);
+      if ( config->readBoolEntry("write_xing_tag",true) ) lame_set_bWriteVbrTag(d->gf, 1);
 
-  }
+    }
 
-  switch (   config->readNumEntry("mode",0) ) {
+    switch (   config->readNumEntry("mode",0) ) {
 
-    case 0: lame_set_mode(d->gf, STEREO);
-                break;
-    case 1: lame_set_mode(d->gf, JOINT_STEREO);
-                break;
-    case 2: lame_set_mode(d->gf,DUAL_CHANNEL);
-                break;
-    case 3: lame_set_mode(d->gf,MONO);
-                break;
-    default: lame_set_mode(d->gf,STEREO);
-                break;
-  }
+      case 0: lame_set_mode(d->gf, STEREO);
+                  break;
+      case 1: lame_set_mode(d->gf, JOINT_STEREO);
+                  break;
+      case 2: lame_set_mode(d->gf,DUAL_CHANNEL);
+                  break;
+      case 3: lame_set_mode(d->gf,MONO);
+                  break;
+      default: lame_set_mode(d->gf,STEREO);
+                  break;
+    }
 
-  lame_set_copyright(d->gf, config->readBoolEntry("copyright",false));
-  lame_set_original(d->gf, config->readBoolEntry("original",true));
-  lame_set_strict_ISO(d->gf, config->readBoolEntry("iso",false));
-  lame_set_error_protection(d->gf, config->readBoolEntry("crc",false));
+    lame_set_copyright(d->gf, config->readBoolEntry("copyright",false));
+    lame_set_original(d->gf, config->readBoolEntry("original",true));
+    lame_set_strict_ISO(d->gf, config->readBoolEntry("iso",false));
+    lame_set_error_protection(d->gf, config->readBoolEntry("crc",false));
 
-  d->write_id3 = config->readBoolEntry("id3",true);
+    d->write_id3 = config->readBoolEntry("id3",true);
 
-  if ( config->readBoolEntry("enable_lowpassfilter",false) ) {
+    if ( config->readBoolEntry("enable_lowpassfilter",false) ) {
 
-    lame_set_lowpassfreq(d->gf, config->readNumEntry("lowpassfilter_freq",0));
+      lame_set_lowpassfreq(d->gf, config->readNumEntry("lowpassfilter_freq",0));
 
-    if (config->readBoolEntry("set_lowpassfilter_width",false)) {
-      lame_set_lowpasswidth(d->gf, config->readNumEntry("lowpassfilter_width",0));
-    }
+      if (config->readBoolEntry("set_lowpassfilter_width",false)) {
+        lame_set_lowpasswidth(d->gf, config->readNumEntry("lowpassfilter_width",0));
+      }
 
-  }
+    }
 
-  if ( config->readBoolEntry("enable_highpassfilter",false) ) {
+    if ( config->readBoolEntry("enable_highpassfilter",false) ) {
 
-    lame_set_highpassfreq(d->gf, config->readNumEntry("highpassfilter_freq",0));
+      lame_set_highpassfreq(d->gf, config->readNumEntry("highpassfilter_freq",0));
 
-    if (config->readBoolEntry("set_highpassfilter_width",false)) {
-      lame_set_highpasswidth(d->gf, config->readNumEntry("highpassfilter_width",0));
+      if (config->readBoolEntry("set_highpassfilter_width",false)) {
+        lame_set_highpasswidth(d->gf, config->readNumEntry("highpassfilter_width",0));
+      }
+    }
     }
-
-  }
a130 1
 #ifdef HAVE_VORBIS
@


1.1
log
@Make it compile with cdparanoia, even though it doesn't quite work yet.

Move kdmrc creation to pkg_install time (fries@@)
@
text
@d1 3
a3 3
$OpenBSD$
--- kioslave/audiocd/audiocd.cpp.orig	Thu Aug 23 21:46:28 2001
+++ kioslave/audiocd/audiocd.cpp	Thu Aug 23 22:08:18 2001
d54 220
@

