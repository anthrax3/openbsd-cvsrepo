head	1.2;
access;
symbols
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2;
locks; strict;
comment	@# @;


1.2
date	2006.04.01.10.49.20;	author espie;	state dead;
branches;
next	1.1;

1.1
date	2006.02.04.13.25.36;	author espie;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2006.02.05.19.04.55;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to 3.5.2
@
text
@$OpenBSD: patch-kpdf_xpdf_splash_SplashXPathScanner_cc,v 1.1 2006/02/04 13:25:36 espie Exp $
--- kpdf/xpdf/splash/SplashXPathScanner.cc.orig	Sat Sep 10 10:18:43 2005
+++ kpdf/xpdf/splash/SplashXPathScanner.cc	Sat Feb  4 14:21:47 2006
@@@@ -186,7 +186,7 @@@@ GBool SplashXPathScanner::getNextSpan(in
 }
 
 void SplashXPathScanner::computeIntersections(int y) {
-  SplashCoord ySegMin, ySegMax, xx0, xx1;
+  SplashCoord xSegMin, xSegMax, ySegMin, ySegMax, xx0, xx1;
   SplashXPathSeg *seg;
   int i, j;
 
@@@@ -236,19 +236,27 @@@@ void SplashXPathScanner::computeIntersec
     } else if (seg->flags & splashXPathVert) {
       xx0 = xx1 = seg->x0;
     } else {
-      if (ySegMin <= y) {
-	// intersection with top edge
-	xx0 = seg->x0 + ((SplashCoord)y - seg->y0) * seg->dxdy;
+      if (seg->x0 < seg->x1) {
+	xSegMin = seg->x0;
+	xSegMax = seg->x1;
       } else {
-	// x coord of segment endpoint with min y coord
-	xx0 = (seg->flags & splashXPathFlip) ? seg->x1 : seg->x0;
+	xSegMin = seg->x1;
+	xSegMax = seg->x0;
       }
-      if (ySegMax >= y + 1) {
-	// intersection with bottom edge
-	xx1 = seg->x0 + ((SplashCoord)y + 1 - seg->y0) * seg->dxdy;
-      } else {
-	// x coord of segment endpoint with max y coord
-	xx1 = (seg->flags & splashXPathFlip) ? seg->x0 : seg->x1;
+      // intersection with top edge
+      xx0 = seg->x0 + ((SplashCoord)y - seg->y0) * seg->dxdy;
+      // intersection with bottom edge
+      xx1 = seg->x0 + ((SplashCoord)y + 1 - seg->y0) * seg->dxdy;
+      // the segment may not actually extend to the top and/or bottom edges
+      if (xx0 < xSegMin) {
+	xx0 = xSegMin;
+      } else if (xx0 > xSegMax) {
+	xx0 = xSegMax;
+      }
+      if (xx1 < xSegMin) {
+	xx1 = xSegMin;
+      } else if (xx1 > xSegMax) {
+	xx1 = xSegMax;
       }
     }
     if (xx0 < xx1) {
@


1.1
log
@KDE Security Advisory: kpdf/xpdf heap based buffer overflow
http://www.kde.org/info/security/advisory-20060202-1.txt
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.2.1
log
@MFC:
KDE Security Advisory: kpdf/xpdf heap based buffer overflow
http://www.kde.org/info/security/advisory-20060202-1.txt
@
text
@d2 3
a4 3
--- kpdf/xpdf/splash/SplashXPathScanner.cc.orig	Mon May 23 14:05:37 2005
+++ kpdf/xpdf/splash/SplashXPathScanner.cc	Sun Feb  5 13:08:56 2006
@@@@ -182,7 +182,7 @@@@ GBool SplashXPathScanner::getNextSpan(in
d13 1
a13 1
@@@@ -232,19 +232,27 @@@@ void SplashXPathScanner::computeIntersec
d19 1
a19 1
-	xx0 = seg->x0 + (y - seg->y0) * seg->dxdy;
d31 1
a31 1
-	xx1 = seg->x0 + (y + 1 - seg->y0) * seg->dxdy;
@

