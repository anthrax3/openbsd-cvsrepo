head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2;
locks; strict;
comment	@# @;


1.5
date	2012.04.23.13.47.08;	author ajacoutot;	state dead;
branches;
next	1.4;

1.4
date	2011.11.16.13.33.15;	author phessler;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.12.22.35.01;	author jakemsr;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.03.01.05.03;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.09.00.16.26;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Major update to vlc-2.0.1.
More details at http://www.videolan.org/vlc/releases/2.0.1.html

tested on i386, amd64, sparc64
from Brad (maintainer)
@
text
@$OpenBSD: patch-modules_access_v4l2_c,v 1.4 2011/11/16 13:33:15 phessler Exp $
--- modules/access/v4l2.c.orig	Sun Jan 23 11:05:21 2011
+++ modules/access/v4l2.c	Thu Apr 28 21:47:48 2011
@@@@ -1675,8 +1675,8 @@@@ static float GetMaxFrameRate( demux_t *p_demux, int i_
                 float f_fps_max = -1;
                 do
                 {
-                    float f_fps = (float)frmival.discrete.denominator
-                                / (float)frmival.discrete.numerator;
+                    float f_fps = (float)frmival.un.discrete.denominator
+                                / (float)frmival.un.discrete.numerator;
                     if( f_fps > f_fps_max ) f_fps_max = f_fps;
                     frmival.index++;
                 } while( v4l2_ioctl( i_fd, VIDIOC_ENUM_FRAMEINTERVALS,
@@@@ -1685,10 +1685,10 @@@@ static float GetMaxFrameRate( demux_t *p_demux, int i_
             }
             case V4L2_FRMSIZE_TYPE_STEPWISE:
             case V4L2_FRMIVAL_TYPE_CONTINUOUS:
-                return __MAX( (float)frmival.stepwise.max.denominator
-                            / (float)frmival.stepwise.max.numerator,
-                              (float)frmival.stepwise.min.denominator
-                            / (float)frmival.stepwise.min.numerator );
+                return __MAX( (float)frmival.un.stepwise.max.denominator
+                            / (float)frmival.un.stepwise.max.numerator,
+                              (float)frmival.un.stepwise.min.denominator
+                            / (float)frmival.un.stepwise.min.numerator );
         }
     }
 #endif
@@@@ -1717,21 +1717,21 @@@@ static float GetAbsoluteMaxFrameRate( demux_t *p_demux
                     frmsize.index++;
                     float f_fps = GetMaxFrameRate( p_demux, i_fd,
                                                    i_pixel_format,
-                                                   frmsize.discrete.width,
-                                                   frmsize.discrete.height );
+                                                   frmsize.un.discrete.width,
+                                                   frmsize.un.discrete.height );
                     if( f_fps > f_fps_max ) f_fps_max = f_fps;
                 } while( v4l2_ioctl( i_fd, VIDIOC_ENUM_FRAMESIZES,
                          &frmsize ) >= 0 );
                 break;
             case V4L2_FRMSIZE_TYPE_STEPWISE:
             {
-                uint32_t i_width = frmsize.stepwise.min_width;
-                uint32_t i_height = frmsize.stepwise.min_height;
+                uint32_t i_width = frmsize.un.stepwise.min_width;
+                uint32_t i_height = frmsize.un.stepwise.min_height;
                 for( ;
-                     i_width <= frmsize.stepwise.max_width &&
-                     i_height <= frmsize.stepwise.max_width;
-                     i_width += frmsize.stepwise.step_width,
-                     i_height += frmsize.stepwise.step_height )
+                     i_width <= frmsize.un.stepwise.max_width &&
+                     i_height <= frmsize.un.stepwise.max_width;
+                     i_width += frmsize.un.stepwise.step_width,
+                     i_height += frmsize.un.stepwise.step_height )
                 {
                     float f_fps = GetMaxFrameRate( p_demux, i_fd,
                                                    i_pixel_format,
@@@@ -1745,8 +1745,8 @@@@ static float GetAbsoluteMaxFrameRate( demux_t *p_demux
                 msg_Err( p_demux, "GetAbsoluteMaxFrameRate implementation for V4L2_FRMSIZE_TYPE_CONTINUOUS isn't correct" );
                  f_fps_max = GetMaxFrameRate( p_demux, i_fd,
                                               i_pixel_format,
-                                              frmsize.stepwise.max_width,
-                                              frmsize.stepwise.max_height );
+                                              frmsize.un.stepwise.max_width,
+                                              frmsize.un.stepwise.max_height );
                 break;
         }
     }
@@@@ -1778,26 +1778,26 @@@@ static void GetMaxDimensions( demux_t *p_demux, int i_
                     frmsize.index++;
                     float f_fps = GetMaxFrameRate( p_demux, i_fd,
                                                    i_pixel_format,
-                                                   frmsize.discrete.width,
-                                                   frmsize.discrete.height );
+                                                   frmsize.un.discrete.width,
+                                                   frmsize.un.discrete.height );
                     if( f_fps >= f_fps_min &&
-                        frmsize.discrete.width > *pi_width )
+                        frmsize.un.discrete.width > *pi_width )
                     {
-                        *pi_width = frmsize.discrete.width;
-                        *pi_height = frmsize.discrete.height;
+                        *pi_width = frmsize.un.discrete.width;
+                        *pi_height = frmsize.un.discrete.height;
                     }
                 } while( v4l2_ioctl( i_fd, VIDIOC_ENUM_FRAMESIZES,
                          &frmsize ) >= 0 );
                 break;
             case V4L2_FRMSIZE_TYPE_STEPWISE:
             {
-                uint32_t i_width = frmsize.stepwise.min_width;
-                uint32_t i_height = frmsize.stepwise.min_height;
+                uint32_t i_width = frmsize.un.stepwise.min_width;
+                uint32_t i_height = frmsize.un.stepwise.min_height;
                 for( ;
-                     i_width <= frmsize.stepwise.max_width &&
-                     i_height <= frmsize.stepwise.max_width;
-                     i_width += frmsize.stepwise.step_width,
-                     i_height += frmsize.stepwise.step_height )
+                     i_width <= frmsize.un.stepwise.max_width &&
+                     i_height <= frmsize.un.stepwise.max_width;
+                     i_width += frmsize.un.stepwise.step_width,
+                     i_height += frmsize.un.stepwise.step_height )
                 {
                     float f_fps = GetMaxFrameRate( p_demux, i_fd,
                                                    i_pixel_format,
@@@@ -1815,13 +1815,13 @@@@ static void GetMaxDimensions( demux_t *p_demux, int i_
                 msg_Err( p_demux, "GetMaxDimension implementation for V4L2_FRMSIZE_TYPE_CONTINUOUS isn't correct" );
                 float f_fps = GetMaxFrameRate( p_demux, i_fd,
                                                i_pixel_format,
-                                               frmsize.stepwise.max_width,
-                                               frmsize.stepwise.max_height );
+                                               frmsize.un.stepwise.max_width,
+                                               frmsize.un.stepwise.max_height );
                 if( f_fps >= f_fps_min &&
-                    frmsize.stepwise.max_width > *pi_width )
+                    frmsize.un.stepwise.max_width > *pi_width )
                 {
-                    *pi_width = frmsize.stepwise.max_width;
-                    *pi_height = frmsize.stepwise.max_height;
+                    *pi_width = frmsize.un.stepwise.max_width;
+                    *pi_height = frmsize.un.stepwise.max_height;
                 }
                 break;
         }
@@@@ -2249,27 +2249,27 @@@@ static int OpenVideoDev( vlc_object_t *p_obj, demux_sy
                 do
                 {
                     msg_Dbg( p_obj, "    supported frame interval: %d/%d",
-                             frmival.discrete.numerator,
-                             frmival.discrete.denominator );
+                             frmival.un.discrete.numerator,
+                             frmival.un.discrete.denominator );
                     frmival.index++;
                 } while( v4l2_ioctl( i_fd, VIDIOC_ENUM_FRAMEINTERVALS, &frmival ) >= 0 );
                 break;
             case V4L2_FRMIVAL_TYPE_STEPWISE:
                 msg_Dbg( p_obj, "    supported frame intervals: %d/%d to "
                          "%d/%d using %d/%d increments",
-                         frmival.stepwise.min.numerator,
-                         frmival.stepwise.min.denominator,
-                         frmival.stepwise.max.numerator,
-                         frmival.stepwise.max.denominator,
-                         frmival.stepwise.step.numerator,
-                         frmival.stepwise.step.denominator );
+                         frmival.un.stepwise.min.numerator,
+                         frmival.un.stepwise.min.denominator,
+                         frmival.un.stepwise.max.numerator,
+                         frmival.un.stepwise.max.denominator,
+                         frmival.un.stepwise.step.numerator,
+                         frmival.un.stepwise.step.denominator );
                 break;
             case V4L2_FRMIVAL_TYPE_CONTINUOUS:
                 msg_Dbg( p_obj, "    supported frame intervals: %d/%d to %d/%d",
-                         frmival.stepwise.min.numerator,
-                         frmival.stepwise.min.denominator,
-                         frmival.stepwise.max.numerator,
-                         frmival.stepwise.max.denominator );
+                         frmival.un.stepwise.min.numerator,
+                         frmival.un.stepwise.min.denominator,
+                         frmival.un.stepwise.max.numerator,
+                         frmival.un.stepwise.max.denominator );
                 break;
         }
     }
@@@@ -2718,22 +2718,22 @@@@ static bool ProbeVideoDev( vlc_object_t *p_obj, demux_
                                 {
                                     msg_Dbg( p_obj,
                 "    device supports size %dx%d",
-                frmsize.discrete.width, frmsize.discrete.height );
+                frmsize.un.discrete.width, frmsize.un.discrete.height );
                                     frmsize.index++;
                                 } while( v4l2_ioctl( i_fd, VIDIOC_ENUM_FRAMESIZES, &frmsize ) >= 0 );
                                 break;
                             case V4L2_FRMSIZE_TYPE_STEPWISE:
                                 msg_Dbg( p_obj,
                 "    device supports sizes %dx%d to %dx%d using %dx%d increments",
-                frmsize.stepwise.min_width, frmsize.stepwise.min_height,
-                frmsize.stepwise.max_width, frmsize.stepwise.max_height,
-                frmsize.stepwise.step_width, frmsize.stepwise.step_height );
+                frmsize.un.stepwise.min_width, frmsize.un.stepwise.min_height,
+                frmsize.un.stepwise.max_width, frmsize.un.stepwise.max_height,
+                frmsize.un.stepwise.step_width, frmsize.un.stepwise.step_height );
                                 break;
                             case V4L2_FRMSIZE_TYPE_CONTINUOUS:
                                 msg_Dbg( p_obj,
                 "    device supports all sizes %dx%d to %dx%d",
-                frmsize.stepwise.min_width, frmsize.stepwise.min_height,
-                frmsize.stepwise.max_width, frmsize.stepwise.max_height );
+                frmsize.un.stepwise.min_width, frmsize.un.stepwise.min_height,
+                frmsize.un.stepwise.max_width, frmsize.un.stepwise.max_height );
                                 break;
                         }
                     }
@@@@ -3268,7 +3268,7 @@@@ static int Control( vlc_object_t *p_obj, demux_sys_t *
 
     if( i_value >= queryctrl.minimum && i_value <= queryctrl.maximum )
     {
-        ext_control.value = i_value;
+        ext_control.un.value = i_value;
         if( v4l2_ioctl( i_fd, VIDIOC_S_EXT_CTRLS, &ext_controls ) < 0 )
         {
             control.value = i_value;
@@@@ -3283,7 +3283,7 @@@@ static int Control( vlc_object_t *p_obj, demux_sys_t *
         else
         {
             i_ret = v4l2_ioctl( i_fd, VIDIOC_G_EXT_CTRLS, &ext_controls );
-            control.value = ext_control.value;
+            control.value = ext_control.un.value;
         }
     }
 
@


1.4
log
@Update to VLC 1.1.12

Most of the bits from Brad, a minor runtime fix by me.

Tested on amd64, i386, macppc

OK dhill@@, rpointel@@, sthen@@, jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-modules_access_v4l2_c,v 1.3 2010/09/12 22:35:01 jakemsr Exp $
@


1.3
log
@* no more anonymous unions in video(4)
* bump REVISION-main
@
text
@d1 4
a4 19
$OpenBSD: patch-modules_access_v4l2_c,v 1.2 2010/06/03 01:05:03 sthen Exp $
--- modules/access/v4l2.c.orig	Sun Mar  7 10:38:01 2010
+++ modules/access/v4l2.c	Mon Aug 30 17:38:54 2010
@@@@ -49,7 +49,13 @@@@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 
-#include <linux/videodev2.h>
+#ifdef HAVE_SYS_VIDEOIO_H
+#   include <sys/videoio.h>
+#elif defined (HAVE_SYS_VIDEODEV2_H)
+#   include <sys/videodev2.h>
+#else
+#   include <linux/videodev2.h>
+#endif
 
 #include <poll.h>
 
@@@@ -1655,8 +1661,8 @@@@ static float GetMaxFrameRate( demux_t *p_demux, int i_
d15 1
a15 1
@@@@ -1665,10 +1671,10 @@@@ static float GetMaxFrameRate( demux_t *p_demux, int i_
d30 1
a30 1
@@@@ -1697,21 +1703,21 @@@@ static float GetAbsoluteMaxFrameRate( demux_t *p_demux
d60 1
a60 1
@@@@ -1725,8 +1731,8 @@@@ static float GetAbsoluteMaxFrameRate( demux_t *p_demux
d71 1
a71 1
@@@@ -1758,26 +1764,26 @@@@ static void GetMaxDimensions( demux_t *p_demux, int i_
d109 1
a109 1
@@@@ -1795,13 +1801,13 @@@@ static void GetMaxDimensions( demux_t *p_demux, int i_
d128 1
a128 1
@@@@ -2212,27 +2218,27 @@@@ static int OpenVideoDev( vlc_object_t *p_obj, demux_sy
d168 1
a168 1
@@@@ -2681,22 +2687,22 @@@@ static bool ProbeVideoDev( vlc_object_t *p_obj, demux_
d197 1
a197 1
@@@@ -3231,7 +3237,7 @@@@ static int Control( vlc_object_t *p_obj, demux_sys_t *
d206 1
a206 1
@@@@ -3246,7 +3252,7 @@@@ static int Control( vlc_object_t *p_obj, demux_sys_t *
@


1.2
log
@Remove posix_memalign workaround, now we have it in libc.
In ifdef's no longer used following the libc update, so no bump.
From Brad (maintainer).
@
text
@d1 3
a3 3
$OpenBSD: patch-modules_access_v4l2_c,v 1.1 2010/05/09 00:16:26 sthen Exp $
--- modules/access/v4l2.c.orig	Wed May  5 18:50:08 2010
+++ modules/access/v4l2.c	Wed May  5 19:09:36 2010
d18 211
@


1.1
log
@Build v4l2 support, which can work with uvideo(4). From Brad.
@
text
@d1 1
a1 1
$OpenBSD$
a18 70
@@@@ -492,6 +498,9 @@@@ struct buffer_t
 {
     void *  start;
     size_t  length;
+#if !defined(HAVE_POSIX_MEMALIGN) && !defined(HAVE_MEMALIGN)
+    void *  free;
+#endif
 };
 
 struct demux_sys_t
@@@@ -1038,7 +1047,12 @@@@ static void DemuxClose( vlc_object_t *p_this )
         switch( p_sys->io )
         {
         case IO_METHOD_READ:
-            free( p_sys->p_buffers[0].start );
+#if !defined (HAVE_POSIX_MEMALIGN) && !defined (HAVE_MEMALIGN)
+            if (p_sys->p_buffers[0].free)
+                free( p_sys->p_buffers[0].free );
+            else
+#endif
+                free( p_sys->p_buffers[0].start );
             break;
 
         case IO_METHOD_MMAP:
@@@@ -1054,7 +1068,12 @@@@ static void DemuxClose( vlc_object_t *p_this )
         case IO_METHOD_USERPTR:
             for( i = 0; i < p_sys->i_nbuffers; ++i )
             {
-               free( p_sys->p_buffers[i].start );
+#if !defined (HAVE_POSIX_MEMALIGN) && !defined (HAVE_MEMALIGN)
+               if (p_sys->p_buffers[0].free)
+                   free( p_sys->p_buffers[i].free );
+               else
+#endif
+                   free( p_sys->p_buffers[i].start );
             }
             break;
 
@@@@ -1600,10 +1619,31 @@@@ static int InitUserP( vlc_object_t *p_demux, demux_sys
 
     for( p_sys->i_nbuffers = 0; p_sys->i_nbuffers < 4; ++p_sys->i_nbuffers )
     {
+#ifdef HAVE_POSIX_MEMALIGN
         p_sys->p_buffers[p_sys->i_nbuffers].length = i_buffer_size;
         if( posix_memalign( &p_sys->p_buffers[p_sys->i_nbuffers].start,
                 /* boundary */ i_page_size, i_buffer_size ) )
             goto open_failed;
+#elif defined (HAVE_MEMALIGN)
+        p_sys->p_buffers[p_sys->i_nbuffers].length = i_buffer_size;
+        p_sys->p_buffers[p_sys->i_nbuffers].start =
+            memalign ( /* boundary */ i_page_size, i_buffer_size );
+        if( p_sys->p_buffers[p_sys->i_nbuffers].start == NULL )
+            goto open_failed;
+#else
+        unsigned char *ptr;
+        size_t align = i_page_size - 1;
+
+        p_sys->p_buffers[p_sys->i_nbuffers].length = i_buffer_size;
+        ptr = malloc (i_buffer_size + align);
+        if ( ptr == NULL )
+            goto open_failed;
+
+        p_sys->p_buffers[p_sys->i_nbuffers].free = ptr;
+        ptr += align;
+        p_sys->p_buffers[p_sys->i_nbuffers].start =
+            (void *)(((uintptr_t)ptr) & ~align);
+#endif
     }
 
     return VLC_SUCCESS;
@

