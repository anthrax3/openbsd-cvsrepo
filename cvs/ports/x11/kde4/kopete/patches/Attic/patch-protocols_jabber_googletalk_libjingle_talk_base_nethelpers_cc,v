head	1.3;
access;
symbols
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	zhuk_20131208:1.1.1.1
	zhuk:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2014.11.03.13.23.52;	author zhuk;	state dead;
branches;
next	1.2;
commitid	PkTNh1PwbRj7gaT8;

1.2
date	2013.12.13.11.34.48;	author zhuk;	state Exp;
branches;
next	1.1;

1.1
date	2013.12.08.18.39.44;	author zhuk;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.12.08.18.39.44;	author zhuk;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Zap patches that aren't needed until Jingle support is ready and that need
adjusting. Forgot to remove them at the commit time, noticed by naddy@@.

Just verified that build goes fine on amd64.
@
text
@$OpenBSD: patch-protocols_jabber_googletalk_libjingle_talk_base_nethelpers_cc,v 1.2 2013/12/13 11:34:48 zhuk Exp $
Rewrite OpenBSD support using getaddrinfo() and "proper" OS check.
--- protocols/jabber/googletalk/libjingle/talk/base/nethelpers.cc.orig	Wed Aug 28 21:16:17 2013
+++ protocols/jabber/googletalk/libjingle/talk/base/nethelpers.cc	Mon Dec  9 15:51:49 2013
@@@@ -37,6 +37,13 @@@@ static const size_t kInitHostentLen = 1024;
 static const size_t kMaxHostentLen = kInitHostentLen * 8;
 #endif
 
+#ifdef OPENBSD
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#endif
+
 // AsyncResolver
 
 AsyncResolver::AsyncResolver() : result_(NULL), error_(0) {
@@@@ -57,7 +64,7 @@@@ void AsyncResolver::OnWorkDone() {
   }
 }
 
-#if defined(WIN32) || defined(ANDROID) || defined(OPENBSD)
+#if defined(WIN32) || defined(ANDROID)
 static hostent* DeepCopyHostent(const hostent* ent) {
   // Get the total number of bytes we need to copy, and allocate our buffer.
   int num_aliases = 0, num_addrs = 0;
@@@@ -127,6 +134,32 @@@@ hostent* SafeGetHostByName(const char* hostname, int* 
   }
   result = DeepCopyHostent(ent);
   *herrno = 0;
+#elif defined(OPENBSD)
+  struct addrinfo hints, *res, *res0;
+  int i, count;
+  char *buf;
+  
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = PF_INET;    // XXX this class does support IPv4 only anyway
+  // hints.ai_flags = AI_CANONNAME;
+  *herrno = getaddrinfo(hostname, NULL, &hints, &res0);
+  if (*herrno)
+    return NULL;
+  result = new hostent;
+  if (res0->ai_canonname != NULL)
+    result->h_name = strdup(res0->ai_canonname);    // No memory? - not a big deal here
+  for (res = res0, count = 0; res; res = res->ai_next)
+    count++;
+  buf = new char[count * 4];    // Here and below: 4 for PF_INET address size
+  result->h_addrtype = PF_INET;
+  result->h_length = 4;
+  result->h_addr_list = new char*[count + 1];
+  for (res = res0, i = 0; res; res = res->ai_next) {
+    result->h_addr_list[i] = buf + (i * 4);
+    memcpy(result->h_addr_list[i], &((const struct sockaddr_in*)res->ai_addr)->sin_addr.s_addr, 4);
+  }
+  freeaddrinfo(res0);
+  *herrno = 0;
 #elif defined(LINUX) || defined(ANDROID)
   // gethostbyname() is not thread safe, so we need to call gethostbyname_r()
   // which is a reentrant version of gethostbyname().
@@@@ -168,13 +201,6 @@@@ hostent* SafeGetHostByName(const char* hostname, int* 
 #elif defined(OSX) || defined(IOS) || defined(FREEBSD)
   // Mac OS returns an object with everything allocated.
   result = getipnodebyname(hostname, AF_INET, AI_DEFAULT, herrno);
-#elif defined(OPENBSD)
-  hostent* ent = gethostbyname(hostname);
-  if (!ent) {
-    return NULL;
-  }
-  result = DeepCopyHostent(ent);
-  *herrno = 0;
 #else
 #error "I don't know how to do gethostbyname safely on your system."
 #endif
@@@@ -186,6 +212,15 @@@@ hostent* SafeGetHostByName(const char* hostname, int* 
 void FreeHostEnt(hostent* host) {
 #if defined(OSX) || defined(IOS) || defined(FREEBSD)
   freehostent(host);
+#elif defined(OPENBSD)
+  if (host != NULL) {
+    // we may be sure that at least one element is there,
+    // getaddrinfo(3) always returns at least one address
+    // on success.
+    delete host->h_addr_list[0];
+    delete host->h_addr_list;
+    delete host;
+  }
 #elif defined(WIN32) || defined(POSIX)
   free(host);
 #else
@


1.2
log
@Fix (one) crash in googletalk-call. This code is not built yet, so no bump.
@
text
@d1 1
a1 1
$OpenBSD: patch-protocols_jabber_googletalk_libjingle_talk_base_nethelpers_cc,v 1.1.1.1 2013/12/08 18:39:44 zhuk Exp $
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 2
--- protocols/jabber/googletalk/libjingle/talk/base/nethelpers.cc.orig	Tue Dec  3 22:30:39 2013
+++ protocols/jabber/googletalk/libjingle/talk/base/nethelpers.cc	Thu Dec  5 01:21:12 2013
d75 1
a75 1
@@@@ -186,6 +212,10 @@@@ hostent* SafeGetHostByName(const char* hostname, int* 
d80 8
a87 3
+  delete host->h_addr_list[0];
+  delete host->h_addr_list;
+  delete host;
@


1.1.1.1
log
@Kopete is an instant messenger supporting AIM, Bonjour, Gadu-Gadu,
GroupWise, ICQ, Jabber (XMPP, Google Talk, Facebook, ...), Meanwhile,
QQ, Skype, Windows Live Messenger, WinPopup, Yahoo and more. It is
designed to be a flexible and extensible multi-protocol system
suitable for personal and enterprise use.

The goal of Kopete is to provide users with a single easy-to-use
way to access all of their instant messaging systems. The interface
puts people first, and is integrated with the system address book
to let you access your contacts from other KDE applications. Instant
messaging can be intrusive, but Kopete's notification system can
be tuned so that only important contacts interrupt you.

Kopete also features tools to enhance your instant messaging
experience, such as message encryption, archiving, and many other
fun and useful effects.

This is ex-kdenetwork member. Importing as a part of KDE 4.11.4 update.
This port won't work until update is finished, thus not hooking it up.
@
text
@@
