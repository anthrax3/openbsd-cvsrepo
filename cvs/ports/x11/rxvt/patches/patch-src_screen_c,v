head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.16
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.14
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.10
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.12
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.0.30
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.28
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.26
	OPENBSD_5_0:1.1.0.24
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.22
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.20
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.18
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.16
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.14
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.12
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.10
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.8
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.6
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.4
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.2
	OPENBSD_3_9_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2013.07.06.15.55.46;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.24.19.14.18;	author steven;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix crash when rxvt window holding selection and e.g. under synergy, move
focus to a different screen. From FreeBSD ports/98590. Dead upstream.
Looks ok to dcoppa@@
@
text
@$OpenBSD$

There is an underflow condition in rxvt_selection_adjust_kanji triggered
when one drags the mouse holding left button along the left side of the
window (c1 == 0). The added check prevents reading memory before the
allocated buffer. This seems to also be semantically correct as there is
no need to extend selection when there is nothing selected on the line.

Also, bring in FreeBSD patch ports/98590 64-bit crash inside rxvt_selection_send()

--- src/screen.c.orig	Sat Jul  6 10:27:22 2013
+++ src/screen.c	Sat Jul  6 10:28:03 2013
@@@@ -3211,9 +3211,9 @@@@ rxvt_selection_adjust_kanji(rxvt_t *r)
 	    && IS_MULTI1(r->screen.rend[r1][c1 - 1]))
 	    r->selection.beg.col--;
     }
-    if (r->selection.end.col < r->TermWin.ncol) {
+    c1 = r->selection.end.col;
+    if (0 < c1 && c1 < r->TermWin.ncol) {
 	r1 = r->selection.end.row + r->TermWin.saveLines;
-	c1 = r->selection.end.col;
 	if (IS_MULTI1(r->screen.rend[r1][c1 - 1])
 	    && IS_MULTI2(r->screen.rend[r1][c1]))
 	    r->selection.end.col++;
@@@@ -3520,6 +3520,7 @@@@ rxvt_selection_send(rxvt_t *r, const XSelectionRequest
     Atom32          target_list[3];
 #endif
     Atom            target;
+    Atom            property;
     XTextProperty   ct;
     XICCEncodingStyle style;
     char           *cl[2], dummy[1];
@@@@ -3532,6 +3533,15 @@@@ rxvt_selection_send(rxvt_t *r, const XSelectionRequest
     ev.target = rq->target;
     ev.time = rq->time;
 
+	/* ICCCM: 2.2. Responsibilities of the Selection Owner   
+	 * SelectionRequest:
+	 * If the specified property is None , the requestor
+	 * an obsolete client. Owners are encouraged
+	 * to support these clients by using the specified
+	 * target atom as the property name to be used for
+	 * the reply.
+	 */
+	property = (rq->property == 0) ? rq->target : rq->property;
     if (rq->target == r->h->xa[XA_TARGETS]) {
 	target_list[0] = (Atom32) r->h->xa[XA_TARGETS];
 	target_list[1] = (Atom32) XA_STRING;
@@@@ -3539,7 +3549,7 @@@@ rxvt_selection_send(rxvt_t *r, const XSelectionRequest
 #ifdef USE_XIM
 	target_list[3] = (Atom32) r->h->xa[XA_COMPOUND_TEXT];
 #endif
-	XChangeProperty(r->Xdisplay, rq->requestor, rq->property, XA_ATOM,
+	XChangeProperty(r->Xdisplay, rq->requestor, property, XA_ATOM,
 			(8 * sizeof(target_list[0])), PropModeReplace,
 			(unsigned char *)target_list,
 			(sizeof(target_list) / sizeof(target_list[0])));
@@@@ -3547,10 +3557,10 @@@@ rxvt_selection_send(rxvt_t *r, const XSelectionRequest
     } else if (rq->target == r->h->xa[XA_MULTIPLE]) {
 	/* TODO: Handle MULTIPLE */
     } else if (rq->target == r->h->xa[XA_TIMESTAMP] && r->selection.text) {
-	XChangeProperty(r->Xdisplay, rq->requestor, rq->property, XA_INTEGER,
-			(8 * sizeof(Time)), PropModeReplace,
+	XChangeProperty(r->Xdisplay, rq->requestor, property, XA_INTEGER,
+			32, PropModeReplace,
 			(unsigned char *)&r->h->selection_time, 1);
-	ev.property = rq->property;
+	ev.property = property;
     } else if (rq->target == XA_STRING
 	       || rq->target == r->h->xa[XA_COMPOUND_TEXT]
 	       || rq->target == r->h->xa[XA_TEXT]) {
@@@@ -3588,10 +3598,10 @@@@ rxvt_selection_send(rxvt_t *r, const XSelectionRequest
 	    ct.value = (unsigned char *)cl[0];
 	    ct.nitems = selectlen;
 	}
-	XChangeProperty(r->Xdisplay, rq->requestor, rq->property,
+	XChangeProperty(r->Xdisplay, rq->requestor, property,
 			target, 8, PropModeReplace,
 			ct.value, (int)ct.nitems);
-	ev.property = rq->property;
+	ev.property = property;
 #ifdef USE_XIM
 	if (freect)
 	    XFree(ct.value);
@


1.1
log
@fix underflow condition in rxvt_selection_adjust_kanji function.
from Gregory Steuck <greg at y2006.nest.cx>, thanks!
ok jolan@@
@
text
@d9 4
a12 2
--- src/screen.c.orig	Sat Dec 10 18:58:35 2005
+++ src/screen.c	Sat Dec 10 19:05:48 2005
d25 60
@

