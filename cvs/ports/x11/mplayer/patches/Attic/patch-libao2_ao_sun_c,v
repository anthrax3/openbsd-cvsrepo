head	1.5;
access;
symbols
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.1.0.2
	OPENBSD_3_9_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2009.10.11.13.36.23;	author edd;	state dead;
branches;
next	1.4;

1.4
date	2008.02.08.17.32.41;	author jakemsr;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.15.07.50.27;	author jakemsr;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.19.21.40.47;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.22.06.28.25;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.5
log
@New version of mplayer based upon a snapshot (20090708).
  * fixes some flv playback
  * removed ggi output - broken i386/sparc64.
  * removed gui (deprecated) - use gnome-mplayer instead.
  * removed win32 codecs - opensource codecs are good quality.

OK, naddy@@, sthen@@
@
text
@$OpenBSD: patch-libao2_ao_sun_c,v 1.4 2008/02/08 17:32:41 jakemsr Exp $
--- libao2/ao_sun.c.orig	Sun Oct  7 12:49:27 2007
+++ libao2/ao_sun.c	Mon Feb  4 05:07:06 2008
@@@@ -102,6 +102,7 @@@@ static int af2sunfmt(int format)
 // sample counter information
 static int realtime_samplecounter_available(char *dev)
 {
+#ifdef __svr4__
     int fd = -1;
     audio_info_t info;
     int rtsc_ok = RTSC_DISABLED;
@@@@ -217,6 +218,9 @@@@ error:
     }
 
     return rtsc_ok;
+#else
+    return RTSC_DISABLED;
+#endif
 }
 
 
@@@@ -440,7 +444,7 @@@@ static int control(int cmd,void *arg){
 		else
 		    info.play.balance = (vol->right - vol->left + volume) * AUDIO_RIGHT_BALANCE / (2*volume);
 	    }
-#if !defined (__OpenBSD__) && !defined (__NetBSD__)
+#if !defined (__NetBSD__)
 	    info.output_muted = (volume == 0);
 #endif
 	    ioctl( fd,AUDIO_SETINFO,&info );
@@@@ -566,11 +570,20 @@@@ static int init(int rate,int channels,int format,int f
     ao_data.bps = byte_per_sec = bytes_per_sample * ao_data.samplerate;
     ao_data.outburst = byte_per_sec > 100000 ? 16384 : 8192;
 
+#if defined(__OpenBSD__) || defined(__NetBSD__)
     AUDIO_INITINFO(&info);
+    info.blocksize = ao_data.outburst;
+    ioctl (audio_fd, AUDIO_SETINFO, &info);
+#endif
+#ifdef __svr4__
+    AUDIO_INITINFO(&info);
     info.play.samples = 0;
     info.play.eof = 0;
     info.play.error = 0;
     ioctl (audio_fd, AUDIO_SETINFO, &info);
+#else
+    ioctl (audio_fd, AUDIO_FLUSH);
+#endif
 
     queued_bursts = 0;
     queued_samples = 0;
@@@@ -607,9 +620,11 @@@@ static void reset(void){
 	 : AUDIO_PRECISION_8);
     info.play.channels = ao_data.channels;
     info.play.sample_rate = ao_data.samplerate;
+#ifdef __svr4__
     info.play.samples = 0;
     info.play.eof = 0;
     info.play.error = 0;
+#endif
     ioctl (audio_fd, AUDIO_SETINFO, &info);
     queued_bursts = 0;
     queued_samples = 0;
@@@@ -636,7 +651,11 @@@@ static void audio_resume(void)
 
 // return: how many bytes can be played without blocking
 static int get_space(void){
+#if defined(__OpenBSD__)
+    audio_bufinfo_t ab;
+#else
     audio_info_t info;
+#endif
 
     // check buffer
 #ifdef HAVE_AUDIO_SELECT
@@@@ -651,14 +670,22 @@@@ static int get_space(void){
     }
 #endif
 
+#if defined(__OpenBSD__)
+    ioctl(audio_fd, AUDIO_GETPRINFO, &ab);
+    if (ab.hiwat * ab.blksize - ab.seek < ao_data.outburst)
+	return 0;
+    else
+	return ao_data.outburst;
+#else
     ioctl(audio_fd, AUDIO_GETINFO, &info);
-#if !defined (__OpenBSD__) && !defined(__NetBSD__)
+#if !defined(__NetBSD__)
     if (queued_bursts - info.play.eof > 2)
 	return 0;
     return ao_data.outburst;
 #else
     return info.hiwat * info.blocksize - info.play.seek;
 #endif
+#endif  // __OpenBSD__
 
 }
 
@@@@ -666,6 +693,16 @@@@ static int get_space(void){
 // it should round it down to outburst*n
 // return: number of bytes played
 static int play(void* data,int len,int flags){
+#ifdef __OpenBSD__
+    if(len==0)
+        return len;
+    if(len>ao_data.outburst || !(flags & AOPLAY_FINAL_CHUNK)) {
+        len/=ao_data.outburst;
+        len*=ao_data.outburst;
+    }
+    len=write(audio_fd,data,len);
+    return len;
+#else
     if (len < ao_data.outburst) return 0;
     len /= ao_data.outburst;
     len *= ao_data.outburst;
@@@@ -679,16 +716,19 @@@@ static int play(void* data,int len,int flags){
 	    queued_bursts ++;
     }
     return len;
+#endif
 }
 
 
 // return: delay in seconds between first and last sample in buffer
 static float get_delay(void){
-    audio_info_t info;
-    ioctl(audio_fd, AUDIO_GETINFO, &info);
 #if defined (__OpenBSD__) || defined(__NetBSD__)
-    return (float) info.play.seek/ (float)byte_per_sec ;
+    u_long bytes;
+    ioctl(audio_fd, AUDIO_WSEEK, &bytes);
+    return (float) bytes/ (float)byte_per_sec ;
 #else
+    audio_info_t info;
+    ioctl(audio_fd, AUDIO_GETINFO, &info);
     if (info.play.samples && enable_sample_timing == RTSC_ENABLED)
 	return (float)(queued_samples - info.play.samples) / (float)ao_data.samplerate;
     else
@


1.4
log
@
maintenence update to mplayer-1.0rc2

ok biorn@@ (MAINTAINER), ajacoutot@@, brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libao2_ao_sun_c,v 1.3 2007/11/15 07:50:27 jakemsr Exp $
@


1.3
log
@- quit using select() for audio playback.  we end up counting bytes
in the playback buffer and waiting until there's enough space anyway.
- use -pthread instead of -lpthread for pthreads linkage
- don't even try to use the "real time sample counter" on *BSD, since
it's not that same as with Sun audio.
- use the audio(4) interface to the mixer "master" volume control
- actually mute the audio when output volume is '0'
- set the audio(4) blocksize to match size of chunks to be written
- provide *BSD equivilents to some Sun functionality
@
text
@d1 4
a4 4
$OpenBSD$
--- libao2/ao_sun.c.orig	Sun Jun 11 11:35:42 2006
+++ libao2/ao_sun.c	Wed Oct 31 00:53:40 2007
@@@@ -95,6 +95,7 @@@@ static int af2sunfmt(int format)
d12 1
a12 1
@@@@ -213,6 +214,9 @@@@ error:
d22 1
a22 1
@@@@ -436,7 +440,7 @@@@ static int control(int cmd,void *arg){
d31 1
a31 1
@@@@ -562,6 +566,13 @@@@ static int init(int rate,int channels,int format,int f
d36 1
a36 1
+    AUDIO_INITINFO(&info);
d38 1
a38 1
+    ioctl(audio_fd, AUDIO_SETINFO, &info);
a39 9
+
+
 #ifdef	__not_used__
     /*
      * hmm, ao_data.buffersize is currently not used in this driver, do there's
@@@@ -598,11 +609,15 @@@@ static int init(int rate,int channels,int format,int f
     }
 #endif	/* __not_used__ */
 
d41 1
a41 1
     AUDIO_INITINFO(&info);
d52 1
a52 11
@@@@ -616,6 +631,9 @@@@ static void uninit(int immed){
     // throw away buffered data in the audio driver's STREAMS queue
     if (immed)
 	ioctl(audio_fd, I_FLUSH, FLUSHW);
+#else
+    if (immed)
+	ioctl(audio_fd, AUDIO_FLUSH);
 #endif
     close(audio_fd);
 }
@@@@ -641,9 +659,11 @@@@ static void reset(){
d64 1
a64 1
@@@@ -670,7 +690,11 @@@@ static void audio_resume()
d67 1
a67 1
 static int get_space(){
d76 2
a77 2
@@@@ -691,9 +715,9 @@@@ static int get_space(){
 	return 0;
a79 3
-#if defined(__NetBSD__) || defined(__OpenBSD__)
-    ioctl(audio_fd, AUDIO_GETINFO, &info);
-    return info.hiwat * info.blocksize - info.play.seek;
d82 11
a92 1
+    return (ab.hiwat * ab.blksize - ab.seek);
d94 1
a94 1
     return ao_data.outburst;
d96 28
a123 1
@@@@ -722,11 +746,14 @@@@ static int play(void* data,int len,int flags){
d126 1
a126 1
 static float get_delay(){
a136 1
+
@


1.2
log
@update to versio 1.0pre8; include the speex and mpcdec codecs by default;
this version of mplayer now uses gtk2;

ok biorn@@ and tested by many
@
text
@d1 19
a19 5
$OpenBSD: patch-libao2_ao_sun_c,v 1.1 2006/01/22 06:28:25 biorn Exp $
--- libao2/ao_sun.c.orig	Sun Jun 11 20:35:42 2006
+++ libao2/ao_sun.c	Thu Jul  6 00:08:11 2006
@@@@ -65,7 +65,57 @@@@ static enum {
 } enable_sample_timing;
d22 13
d36 4
a39 30
+int sun_mixer_get_dev(int fd, int *dev, char *id)
+{
+	mixer_devinfo_t info;
 
+	for (info.index = 0; ioctl(fd, AUDIO_MIXER_DEVINFO, &info) >= 0;
+	     info.index++) {
+		if (!strcmp(id, info.label.name)) {
+			*dev = info.index;
+			return 0;
+		}
+	}
+	return -1;
+}
+
+int sun_get_volume(int fd, int *l, int *r)
+{
+	mixer_ctrl_t mixer;
+
+	if (sun_mixer_get_dev(fd, &mixer.dev, "master") < 0)
+		return -1;
+
+	mixer.type = AUDIO_MIXER_VALUE;
+	mixer.un.value.num_channels = 2;
+	if (ioctl(fd, AUDIO_MIXER_READ, &mixer) < 0)
+		return -1;
+	*l = mixer.un.value.level[AUDIO_MIXER_LEVEL_LEFT];
+	*r = mixer.un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
+
+	return 0;
+}
a40 18
+int sun_set_volume(int fd, int l, int r)
+{
+	mixer_ctrl_t mixer;
+
+	if (sun_mixer_get_dev(fd, &mixer.dev, "master") < 0)
+		return -1;
+
+	mixer.type = AUDIO_MIXER_VALUE;
+	mixer.un.value.num_channels = 2;
+	mixer.un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;
+	mixer.un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
+
+	if (ioctl(fd, AUDIO_MIXER_WRITE, &mixer) < 0)
+		return -1;
+
+	return 0;
+}
+#endif
d42 4
a45 5
 // convert an OSS audio format specification into a sun audio encoding
 static int af2sunfmt(int format)
 {
@@@@ -365,13 +415,21 @@@@ static void setup_device_paths()
 	    audio_dev = "/dev/audio";
d47 1
d49 6
a54 6
+#if defined(__OpenBSD__) || defined(__NetBSD__)
     if (sun_mixer_device == NULL) {
+	if (mixer_device == NULL)
+	    mixer_device = strdup("/dev/mixer");
+	sun_mixer_device = mixer_device;
+    }
d56 1
a56 7
+    if (sun_mixer_device == NULL) {
 	if ((sun_mixer_device = mixer_device) == NULL || !sun_mixer_device[0]) {
 	    sun_mixer_device = malloc(strlen(audio_dev) + 4);
 	    strcpy(sun_mixer_device, audio_dev);
 	    strcat(sun_mixer_device, "ctl");
 	}
     }
d59 11
a69 1
     if (ao_subdevice) audio_dev = ao_subdevice;
d71 18
a88 11
@@@@ -395,6 +453,14 @@@@ static int control(int cmd,void *arg){
 	if ( fd != -1 )
 	{
 	    ao_control_vol_t *vol = (ao_control_vol_t *)arg;
+#if defined(__OpenBSD__) || defined(__NetBSD__)
+	    int r, l;
+	    if (sun_get_volume(fd, &r, &l) < 0) {
+		    close(fd);
+		    goto cgerr;
+	    }
+	    vol->right = vol->left = (float)(r * 100. / AUDIO_MAX_GAIN);
d90 1
a90 7
 	    float volume;
 	    struct audio_info info;
 	    ioctl( fd,AUDIO_GETINFO,&info);
@@@@ -409,9 +475,11 @@@@ static int control(int cmd,void *arg){
 							/ AUDIO_MID_BALANCE;
 		vol->right = volume;
 	    }
d92 15
a106 30
 	    close( fd );
 	    return CONTROL_OK;
-	}	
+	}
+cgerr:
 	return CONTROL_ERROR;
     }
     case AOCONTROL_SET_VOLUME:
@@@@ -422,10 +490,18 @@@@ static int control(int cmd,void *arg){
 	if ( !sun_mixer_device )    /* control function is used before init? */
 	    setup_device_paths();
 
-	fd=open( sun_mixer_device,O_RDONLY );
+	fd=open( sun_mixer_device,O_RDWR );
 	if ( fd != -1 )
 	{
 	    struct audio_info info;
+#if defined(__OpenBSD__) || defined(__NetBSD__)
+	    int r;
+	    r = (int)(vol->right * AUDIO_MAX_GAIN / 100);
+	    if (sun_set_volume(fd, r, r) < 0) {
+		    close(fd);
+		    goto cserr;
+	    }
+#else
 	    float volume;
 	    AUDIO_INITINFO(&info);
 	    volume = vol->right > vol->left ? vol->right : vol->left;
@@@@ -440,9 +516,11 @@@@ static int control(int cmd,void *arg){
 	    info.output_muted = (volume == 0);
d108 18
a125 10
 	    ioctl( fd,AUDIO_SETINFO,&info );
+#endif
 	    close( fd );
 	    return CONTROL_OK;
-	}	
+	}
+cserr:
 	return CONTROL_ERROR;
     }
     }
@


1.1
log
@Add support for
- version 2 audio atoms in QuickTime containers, from mplayer cvs requested by
   David Hill (dhill at mindcry org)
- setting volumem via /dev/mixer, from Mike Belopuhov (mkb at crypt org ru)
@
text
@d1 5
a5 4
$OpenBSD$
--- libao2/ao_sun.c.orig	Thu Jan  6 23:56:54 2005
+++ libao2/ao_sun.c	Thu Jan 19 18:00:16 2006
@@@@ -66,7 +66,57 @@@@ static enum {
a6 1
 extern int verbose;
d62 1
a62 1
@@@@ -366,13 +416,21 @@@@ static void setup_device_paths()
d84 1
a84 1
@@@@ -396,6 +454,14 @@@@ static int control(int cmd,void *arg){
d99 1
a99 1
@@@@ -410,9 +476,11 @@@@ static int control(int cmd,void *arg){
d112 1
a112 1
@@@@ -423,10 +491,18 @@@@ static int control(int cmd,void *arg){
d132 1
a132 1
@@@@ -441,9 +517,11 @@@@ static int control(int cmd,void *arg){
@

