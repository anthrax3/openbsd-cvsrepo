head	1.6;
access;
symbols
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.1.0.2
	OPENBSD_3_9_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2008.02.08.17.32.42;	author jakemsr;	state dead;
branches;
next	1.5;

1.5
date	2007.04.19.08.37.09;	author ajacoutot;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.13.23.13.21;	author robert;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.08.17.33.39;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.19.21.40.47;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.17.07.41.58;	author jakemsr;	state Exp;
branches;
next	;


desc
@@


1.6
log
@
maintenence update to mplayer-1.0rc2

ok biorn@@ (MAINTAINER), ajacoutot@@, brad@@
@
text
@$OpenBSD: patch-libmpdemux_tvi_bsdbt848_c,v 1.5 2007/04/19 08:37:09 ajacoutot Exp $
--- libmpdemux/tvi_bsdbt848.c.orig	Sun Jun 11 20:35:46 2006
+++ libmpdemux/tvi_bsdbt848.c	Thu Apr 19 09:41:03 2007
@@@@ -40,9 +40,12 @@@@
 #include <string.h>
 
 #include <sys/param.h>
-#ifdef __NetBSD__
+#if defined(__NetBSD__) || defined(__OpenBSD__)
 #include <dev/ic/bt8xx.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
 #include <sys/audioio.h>
+#include <string.h>
 #elif defined(__DragonFly__)
 #include <dev/video/meteor/ioctl_meteor.h>
 #include <dev/video/bktr/ioctl_bt848.h>
@@@@ -54,15 +57,17 @@@@
 #include <machine/ioctl_bt848.h>
 #endif
 
+#if !defined(__OpenBSD__)
 #ifdef HAVE_SYS_SOUNDCARD_H
 #include <sys/soundcard.h>
 #else
-#ifdef HAVE_SOUNDCARD_H
+#if defined(HAVE_SOUNDCARD_H)
 #include <soundcard.h>
 #else
 #include <machine/soundcard.h>
 #endif
 #endif
+#endif
 
 #include "libaf/af_format.h"
 #include "libvo/img_format.h"
@@@@ -129,7 +134,7 @@@@ typedef struct {
     int tunerfd;
     int tunerready;
     u_long tunerfreq;
-    struct bktr_chnlset cset;
+    int tunertype;
 
 /* Other */
 
@@@@ -140,9 +145,34 @@@@ typedef struct {
 
 #include "tvi_def.h"
 
+static int chnlsets[17] = {
+    CHNLSET_NABCST,    /* us-bcast */
+    CHNLSET_CABLEIRC,  /* us-cable */
+    CHNLSET_CABLEHRC,  /* us-cable-hrc */
+    CHNLSET_JPNBCST,   /* japan-bcast */
+    CHNLSET_JPNCABLE,  /* japan-cable */
+    CHNLSET_WEUROPE,   /* europe-west */
+    CHNLSET_XUSSR,     /* europe-east ? */
+    CHNLSET_WEUROPE,   /* italy ? */
+    CHNLSET_AUSTRALIA, /* newzealand ? */
+    CHNLSET_AUSTRALIA, /* australia */
+    CHNLSET_WEUROPE,   /* ireland ? */
+    CHNLSET_FRANCE,    /* france */
+    CHNLSET_XUSSR,     /* china-bcast ? */
+    CHNLSET_WEUROPE,   /* southafrica ? */
+    CHNLSET_WEUROPE,   /* argentina ? */
+    CHNLSET_XUSSR,     /* russia */
+    NULL,              /* NULL */
+};
+
+static int sources[6] = { METEOR_INPUT_DEV1, METEOR_INPUT_DEV0, METEOR_INPUT_DEV2,
+    METEOR_INPUT_DEV3, METEOR_INPUT_DEV_RGB, METEOR_INPUT_DEV_SVIDEO };
+
+
 static priv_t *G_private=NULL;
 
 static int getinput(int innumber);
+static int getsource(int insrc);
 
 static void processframe(int signal)
 {
@@@@ -212,6 +242,19 @@@@ static int control(priv_t *priv, int cmd, void *arg)
         return(TVI_CONTROL_TRUE);        
         }
 
+    case TVI_CONTROL_TUN_SET_CHANLIST:
+	{
+	priv->tunertype = chnlsets[(int)*(void **)arg];
+	
+	if(ioctl(priv->tunerfd, TVTUNER_SETTYPE, &priv->tunertype) < 0)
+	    {
+	    perror("SETTYPE:ioctl");
+	    return(0);
+	    }
+
+	return(TVI_CONTROL_TRUE);
+	}
+	
     case TVI_CONTROL_TUN_GET_TUNER:
     case TVI_CONTROL_TUN_SET_TUNER:
 
@@@@ -219,23 +262,24 @@@@ static int control(priv_t *priv, int cmd, void *arg)
 
     case TVI_CONTROL_SPC_GET_INPUT:
         {
-        if(ioctl(priv->btfd, METEORGINPUT, &priv->input) < 0)
+        if(ioctl(priv->btfd, METEORGINPUT, &priv->source) < 0)
             {
             perror("GINPUT:ioctl");
             return(TVI_CONTROL_FALSE);
             }
 
+	priv->input = getsource(priv->source);
         (int)*(void **)arg = priv->input;
         return(TVI_CONTROL_TRUE);
         }
     
     case TVI_CONTROL_SPC_SET_INPUT:
         {
-        priv->input = getinput((int)*(void **)arg);
+        priv->source = getinput((int)*(void **)arg);
 
-        if(ioctl(priv->btfd, METEORSINPUT, &priv->input) < 0) 
+        if(ioctl(priv->btfd, METEORSINPUT, &priv->source) < 0) 
             {
-            perror("tunerfreq:ioctl");
+            perror("SINPUT:ioctl");
             return(0);
             }
 
@@@@ -261,8 +305,15 @@@@ static int control(priv_t *priv, int cmd, void *arg)
     case TVI_CONTROL_AUD_SET_SAMPLERATE:
         {
         int dspspeed = (int)*(void **)arg;
+#if defined(__OpenBSD__)
+           audio_info_t audio_if;
+           AUDIO_INITINFO(&audio_if);
+           audio_if.record.sample_rate = dspspeed;
+           if (ioctl(priv->dspfd, AUDIO_SETINFO, &audio_if) == -1)
+#else
 
-           if(ioctl(priv->dspfd, SNDCTL_DSP_SPEED, &dspspeed) == -1) 
+           if(ioctl(priv->dspfd, SNDCTL_DSP_SPEED, &dspspeed) == -1)
+#endif
             {
             perror("invalidaudiorate");
             return(TVI_CONTROL_FALSE);
@@@@ -473,7 +524,12 @@@@ static int init(priv_t *priv)
 int marg;
 int count;
 u_short tmp_fps;
+int tuner_audio;
+#if defined(__OpenBSD__)
+audio_info_t audio_if;
+#endif
 
+
 G_private = priv; /* Oooh, sick */
 
 /* Video Configuration */
@@@@ -485,7 +541,7 @@@@ priv->iformat = METEOR_FMT_PAL;
 priv->maxheight = PAL_HEIGHT;
 priv->maxwidth = PAL_WIDTH;
 priv->maxfps = PAL_FPS;
-priv->source = METEOR_INPUT_DEV0;
+priv->source = METEOR_INPUT_DEV1;
 priv->fps = priv->maxfps;
 
 priv->starttime=0;
@@@@ -572,10 +628,26 @@@@ if(priv->tunerfd < 0)
     priv->tunerready = FALSE;
     }
 
+if(ioctl(priv->tunerfd, BT848_GAUDIO, &tuner_audio) < 0)
+    {
+    perror("tuner get audio");
+    priv->tunerready = FALSE;
+    }
+if(tuner_audio & AUDIO_MUTE)
+    {
+    tuner_audio = AUDIO_UNMUTE;
+    if(ioctl(priv->tunerfd, BT848_SAUDIO, &tuner_audio) < 0)
+        {
+        perror("tuner unmute");
+        priv->tunerready = FALSE;
+        }
+    }
+
+
 /* Audio Configuration */
 
 priv->dspready = TRUE;
-#ifdef __NetBSD__
+#if defined(__NetBSD__) || defined(__OpenBSD__)
 priv->dspdev = strdup("/dev/sound");
 #else
 priv->dspdev = strdup("/dev/dsp");
@@@@ -583,7 +655,11 @@@@ priv->dspdev = strdup("/dev/dsp");
 priv->dspsamplesize = 16;
 priv->dspstereo = 1;
 priv->dspspeed = 44100;
+#if defined (__OpenBSD__)
+priv->dspfmt = AUDIO_ENCODING_SLINEAR_LE;
+#else
 priv->dspfmt = AFMT_S16_LE;
+#endif
 priv->dspbytesread = 0;
 priv->dsprate = priv->dspspeed * priv->dspsamplesize/8*(priv->dspstereo+1);
 priv->dspframesize = priv->dspspeed*priv->dspsamplesize/8/priv->fps * 
@@@@ -597,6 +673,31 @@@@ if((priv->dspfd = open (priv->dspdev, O_RDONLY, 0)) < 
 
 marg = (256 << 16) | 12;
 
+#if defined(__OpenBSD__)
+
+    AUDIO_INITINFO(&audio_if);
+
+    audio_if.record.precision = priv->dspsamplesize;
+    audio_if.record.channels = priv->dspstereo+1;
+    audio_if.record.sample_rate = priv->dspspeed;
+    audio_if.record.encoding = priv->dspfmt;
+
+    audio_if.mode = AUMODE_RECORD;
+
+    audio_if.play.open = 0;
+    audio_if.play.pause = 1;
+    audio_if.record.open = 1;
+    audio_if.record.pause = 0;
+
+    if (ioctl(priv->dspfd, AUDIO_SETINFO, &audio_if) < 0)
+        {
+        perror ("AUDIO_SETINFO:ioctl");
+        close(priv->dspfd);
+        priv->dspready = FALSE;
+        }
+
+#else
+
 if (ioctl(priv->dspfd, SNDCTL_DSP_SETFRAGMENT, &marg ) < 0 ) 
     {
     perror("setfrag");
@@@@ -614,6 +715,8 @@@@ if((priv->dspready == TRUE) &&
     priv->dspready = FALSE;
     }
 
+#endif
+
 return(1);
 }
 
@@@@ -623,6 +726,7 @@@@ static int start(priv_t *priv)
 int tmp;
 struct timeval curtime;
 int marg;
+int tuner_audio;
 
 fprintf(stderr,"START\n");
 if(priv->videoready == FALSE) return(0);
@@@@ -658,6 +762,7 @@@@ return(1);
 static int uninit(priv_t *priv)
 {
 int marg;
+int tuner_audio;
 
 if(priv->videoready == FALSE) return(0);
 
@@@@ -680,6 +785,15 @@@@ if(ioctl(priv->btfd, METEORCAPTUR, &marg) < 0 ) 
 close(priv->btfd);
 close(priv->dspfd);
 
+tuner_audio = AUDIO_MUTE;
+if(ioctl(priv->tunerfd, BT848_SAUDIO, &tuner_audio) < 0)
+    {
+    perror("tuner mute");
+    priv->tunerready = FALSE;
+    }
+
+close(priv->tunerfd);
+
 priv->dspfd = -1;
 priv->btfd = -1;
 
@@@@ -802,13 +916,13 @@@@ return(priv->dspbytesread * 1.0 / priv->dsprate);
 static int get_audio_framesize(priv_t *priv)
 {
 int bytesavail;
-#ifdef __NetBSD__
+#if defined(__NetBSD__) || defined(__OpenBSD__)
 struct audio_info auinf;
 #endif
 
 if(priv->dspready == FALSE) return 0;
 
-#ifdef __NetBSD__
+#if defined(__NetBSD__) || defined(__OpenBSD__)
 if(ioctl(priv->dspfd, AUDIO_GETINFO, &auinf) < 0) 
     {
     perror("AUDIO_GETINFO");
@@@@ -827,24 +941,28 @@@@ if(ioctl(priv->dspfd, FIONREAD, &bytesavail) < 0) 
 /* When mencoder wants audio data, it wants data..
    it won't go do anything else until it gets it :( */
 
-if(bytesavail == 0) return FRAGSIZE;
+// if(bytesavail == 0) return FRAGSIZE;
 
 return(bytesavail);
 }
 
 static int getinput(int innumber)
 {
-switch(innumber)
-    {
-    case 0: return METEOR_INPUT_DEV0;     /* RCA   */
-    case 1: return METEOR_INPUT_DEV1;     /* Tuner */
-    case 2: return METEOR_INPUT_DEV2;     /* In 1  */
-    case 3: return METEOR_INPUT_DEV3;     /* In 2  */
-    case 4: return METEOR_INPUT_DEV_RGB;     /* RGB   */
-    case 5: return METEOR_INPUT_DEV_SVIDEO; /* SVid  */
-    }
-
+if (sources[innumber])
+    return sources[innumber];
+    
 return 0;
 }
+
+static int getsource(int insrc)
+{
+    int i;
+
+    for (i = 0; sources[i]; i++)
+        if (sources[i] == insrc)
+            return i;
+
+    return 0;
+ }
 
 #endif /* USE_TV */
@


1.5
log
@- add live555 support
- regen patches while here

from brad
ok robert@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libmpdemux_tvi_bsdbt848_c,v 1.4 2007/04/13 23:13:21 robert Exp $
@


1.4
log
@- Fix heap overflow in DMO loader. (CVE-2007-1246)
- regen patches while here

pulled from MPlayer SVN by Brad <brad@@comstyle.com>
@
text
@d1 1
a1 1
$OpenBSD: patch-libmpdemux_tvi_bsdbt848_c,v 1.3 2007/04/08 17:33:39 ajacoutot Exp $
d3 1
a3 1
+++ libmpdemux/tvi_bsdbt848.c	Sat Apr 14 00:35:28 2007
d81 1
a81 1
@@@@ -212,6 +242,19 @@@@ static int control(priv_t *priv, int cmd
d101 1
a101 1
@@@@ -219,23 +262,24 @@@@ static int control(priv_t *priv, int cmd
d130 1
a130 1
@@@@ -261,8 +305,15 @@@@ static int control(priv_t *priv, int cmd
d209 1
a209 1
@@@@ -597,6 +673,31 @@@@ if((priv->dspfd = open (priv->dspdev, O_
d266 1
a266 1
@@@@ -680,6 +785,15 @@@@ if(ioctl(priv->btfd, METEORCAPTUR, &marg
d282 1
a282 1
@@@@ -802,13 +916,13 @@@@ return(priv->dspbytesread * 1.0 / priv->
d298 1
a298 1
@@@@ -827,24 +941,28 @@@@ if(ioctl(priv->dspfd, FIONREAD, &bytesav
@


1.3
log
@- add support for x264
- regen patches while here

"go for it" naddy@@
@
text
@d1 1
a1 1
$OpenBSD: patch-libmpdemux_tvi_bsdbt848_c,v 1.2 2006/07/19 21:40:47 robert Exp $
d3 1
a3 1
+++ libmpdemux/tvi_bsdbt848.c	Sun Apr  8 10:17:02 2007
d81 1
a81 1
@@@@ -212,6 +242,19 @@@@ static int control(priv_t *priv, int cmd, void *arg)
d101 1
a101 1
@@@@ -219,23 +262,24 @@@@ static int control(priv_t *priv, int cmd, void *arg)
d130 1
a130 1
@@@@ -261,8 +305,15 @@@@ static int control(priv_t *priv, int cmd, void *arg)
d209 1
a209 1
@@@@ -597,6 +673,31 @@@@ if((priv->dspfd = open (priv->dspdev, O_RDONLY, 0)) < 
d266 1
a266 1
@@@@ -680,6 +785,15 @@@@ if(ioctl(priv->btfd, METEORCAPTUR, &marg) < 0 ) 
d282 1
a282 1
@@@@ -802,13 +916,13 @@@@ return(priv->dspbytesread * 1.0 / priv->dsprate);
d298 1
a298 1
@@@@ -827,24 +941,28 @@@@ if(ioctl(priv->dspfd, FIONREAD, &bytesavail) < 0) 
@


1.2
log
@update to versio 1.0pre8; include the speex and mpcdec codecs by default;
this version of mplayer now uses gtk2;

ok biorn@@ and tested by many
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
+++ libmpdemux/tvi_bsdbt848.c	Thu Jul  6 00:08:12 2006
d81 1
a81 1
@@@@ -212,6 +242,19 @@@@ static int control(priv_t *priv, int cmd
d101 1
a101 1
@@@@ -219,23 +262,24 @@@@ static int control(priv_t *priv, int cmd
d130 1
a130 1
@@@@ -261,8 +305,15 @@@@ static int control(priv_t *priv, int cmd
d209 1
a209 1
@@@@ -597,6 +673,31 @@@@ if((priv->dspfd = open (priv->dspdev, O_
d266 1
a266 1
@@@@ -680,6 +785,15 @@@@ if(ioctl(priv->btfd, METEORCAPTUR, &marg
d282 1
a282 1
@@@@ -802,13 +916,13 @@@@ return(priv->dspbytesread * 1.0 / priv->
d298 1
a298 1
@@@@ -827,24 +941,28 @@@@ if(ioctl(priv->dspfd, FIONREAD, &bytesav
@


1.1
log
@enable bktr(4) support, and enhance the bktr(4) support by:
- adding support for setting the channel set
- making it use audio(4) instead of ossaudio(3)
- making it explicitly mute the tuner on exit
- use the tuner as default video source, as opposed to RCA

ok biorn@@, robert@@
@
text
@d2 2
a3 2
--- libmpdemux/tvi_bsdbt848.c.orig	Mon Dec 27 09:30:14 2004
+++ libmpdemux/tvi_bsdbt848.c	Mon Jan 16 21:35:44 2006
d15 4
a18 4
 #elif __FreeBSD_version >= 502100
 #include <dev/bktr/ioctl_meteor.h>
 #include <dev/bktr/ioctl_bt848.h>
@@@@ -51,15 +54,17 @@@@
d35 3
a37 3
 #include "../libaf/af_format.h"
 #include "../libvo/img_format.h"
@@@@ -126,7 +131,7 @@@@ typedef struct {
d46 1
a46 1
@@@@ -137,10 +142,35 @@@@ typedef struct {
d51 17
a67 17
+    CHNLSET_NABCST,	/* us-bcast */
+    CHNLSET_CABLEIRC,	/* us-cable */
+    CHNLSET_CABLEHRC,	/* us-cable-hrc */
+    CHNLSET_JPNBCST,	/* japan-bcast */
+    CHNLSET_JPNCABLE,	/* japan-cable */
+    CHNLSET_WEUROPE,	/* europe-west */
+    CHNLSET_XUSSR,	/* europe-east ? */
+    CHNLSET_WEUROPE,	/* italy ? */
+    CHNLSET_AUSTRALIA,	/* newzealand ? */
+    CHNLSET_AUSTRALIA,	/* australia */
+    CHNLSET_WEUROPE,	/* ireland ? */
+    CHNLSET_FRANCE,	/* france */
+    CHNLSET_XUSSR,	/* china-bcast ? */
+    CHNLSET_WEUROPE,	/* southafrica ? */
+    CHNLSET_WEUROPE,	/* argentina ? */
+    CHNLSET_XUSSR,	/* russia */
+    NULL,		/* NULL */
d73 1
d77 1
a78 2
+static int getsource(int insrc);
+
d81 1
a81 2
 struct timeval curtime;
@@@@ -209,6 +239,19 @@@@ static int control(priv_t *priv, int cmd
d86 12
a97 12
+        {
+        priv->tunertype = chnlsets[(int)*(void **)arg];
+
+        if(ioctl(priv->tunerfd, TVTUNER_SETTYPE, &priv->tunertype) < 0) 
+            {
+            perror("SETTYPE:ioctl");
+            return(0);
+            }
+
+        return(TVI_CONTROL_TRUE);        
+        }
+
d101 1
a101 1
@@@@ -216,23 +259,25 @@@@ static int control(priv_t *priv, int cmd
d112 1
a112 2
+        priv->input = getsource(priv->source);
+
d130 2
a131 1
@@@@ -259,7 +304,14 @@@@ static int control(priv_t *priv, int cmd
a133 1
 
d140 3
a142 1
            if(ioctl(priv->dspfd, SNDCTL_DSP_SPEED, &dspspeed) == -1) 
d147 1
a147 1
@@@@ -470,6 +522,10 @@@@ static int init(priv_t *priv)
d156 1
d159 2
a160 1
@@@@ -482,7 +538,7 @@@@ priv->iformat = METEOR_FMT_PAL;
d169 1
a169 1
@@@@ -569,10 +625,26 @@@@ if(priv->tunerfd < 0)
d197 1
a197 1
@@@@ -580,7 +652,11 @@@@ priv->dspdev = strdup("/dev/dsp");
d209 1
a209 1
@@@@ -594,6 +670,34 @@@@ if((priv->dspfd = open (priv->dspdev, O_
a216 3
+    // audio_if.blocksize = 4096;
+    // audio_if.hiwat = 256;
+
d241 1
a241 1
@@@@ -611,6 +715,8 @@@@ if((priv->dspready == TRUE) &&
d250 9
a258 1
@@@@ -655,6 +761,7 @@@@ return(1);
d266 1
a266 1
@@@@ -677,6 +784,15 @@@@ if(ioctl(priv->btfd, METEORCAPTUR, &marg
d270 6
a275 6
+    tuner_audio = AUDIO_MUTE;
+    if(ioctl(priv->tunerfd, BT848_SAUDIO, &tuner_audio) < 0)
+        {
+        perror("tuner mute");
+        priv->tunerready = FALSE;
+        }
d282 1
a282 1
@@@@ -799,20 +915,20 @@@@ return(priv->dspbytesread * 1.0 / priv->
d298 1
a298 9
     return(TVI_CONTROL_FALSE);
     }
 else
-    bytesavail = auinf.record.seek; /* *priv->dspsamplesize; */
+    bytesavail = auinf.record.seek; /* * priv->dspsamplesize/8 * (priv->dspstereo+1); */
 #else
 if(ioctl(priv->dspfd, FIONREAD, &bytesavail) < 0) 
     {
@@@@ -824,24 +940,29 @@@@ if(ioctl(priv->dspfd, FIONREAD, &bytesav
d303 1
a303 1
+  // if(bytesavail == 0) return FRAGSIZE;
d319 1
a319 1
 
d322 1
a322 1
+
d324 1
a324 1
+}
d328 1
a328 1
+int i;
d335 1
a335 1
 }
@

