head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5;
locks; strict;
comment	@# @;


1.8
date	2016.04.15.14.11.09;	author ajacoutot;	state Exp;
branches;
next	1.7;
commitid	Mbx3T92O3F2i3yTU;

1.7
date	2015.10.18.13.25.54;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	hskL6TnJZ8GALNPe;

1.6
date	2015.04.03.18.39.06;	author ajacoutot;	state Exp;
branches;
next	1.5;
commitid	yAn0NWAFkDqbBMqK;

1.5
date	2014.03.30.18.43.44;	author ajacoutot;	state Exp;
branches;
next	1.4;

1.4
date	2014.03.30.14.48.23;	author ajacoutot;	state Exp;
branches;
next	1.3;

1.3
date	2014.03.30.14.43.24;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2014.03.29.14.46.26;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2014.03.27.19.19.17;	author ajacoutot;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to gdm-3.18.3.
Drop the gettext module while here.
@
text
@$OpenBSD: patch-daemon_gdm-server_c,v 1.7 2015/10/18 13:25:54 ajacoutot Exp $

REVERT - OpenBSD lacks sigwaitinfo(2)
From 956d7d1c7a0cfbf2beacdb9e88e645e15ad32047 Mon Sep 17 00:00:00 2001
From: Jasper St. Pierre <jstpierre@@mecheye.net>
Date: Fri, 14 Feb 2014 19:32:50 +0000
Subject: server: Process SIGUSR1 more carefully

REVERT - OpenBSD does not have a systemd implementation (we need ConsoleKit)
From 1ac67f522f5690c27023d98096ca817f12f7eb88 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Fri, 12 Jun 2015 13:28:01 -0400
Subject: drop consolekit support

REVERT - OpenBSD does not have a systemd implementation (we need ConsoleKit)
From 9be58c9ec9a3a411492a5182ac4b0d51fdc3a323 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Fri, 12 Jun 2015 13:48:52 -0400
Subject: require logind support

--- daemon/gdm-server.c.orig	Thu Apr 14 07:29:22 2016
+++ daemon/gdm-server.c	Fri Apr 15 15:05:26 2016
@@@@ -43,7 +43,9 @@@@
 #include <linux/vt.h>
 #endif
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-daemon.h>
+#endif
 
 #ifdef ENABLE_SYSTEMD_JOURNAL
 #include <systemd/sd-journal.h>
@@@@ -92,6 +94,7 @@@@ struct GdmServerPrivate
         char    *auth_file;
 
         guint    child_watch_id;
+        guint    sigusr1_id;
 
         gboolean is_initial;
 };
@@@@ -122,90 +125,76 @@@@ static void     gdm_server_finalize     (GObject      
 
 G_DEFINE_TYPE (GdmServer, gdm_server, G_TYPE_OBJECT)
 
-char *
-gdm_server_get_display_device (GdmServer *server)
+static char *
+_gdm_server_query_ck_for_display_device (GdmServer *server)
 {
-        /* systemd finds the display device out on its own based on the display */
-        return NULL;
-}
+        char    *out;
+        char    *command;
+        int      status;
+        gboolean res;
+        GError  *error;
 
-static void
-gdm_server_ready (GdmServer *server)
-{
-        g_debug ("GdmServer: Got USR1 from X server - emitting READY");
+        g_return_val_if_fail (GDM_IS_SERVER (server), NULL);
 
-        gdm_run_script (GDMCONFDIR "/Init", GDM_USERNAME,
-                        server->priv->display_name,
-                        NULL, /* hostname */
-                        server->priv->auth_file);
+        error = NULL;
+        command = g_strdup_printf (CONSOLEKIT_DIR "/ck-get-x11-display-device --display %s",
+                                   server->priv->display_name);
 
-        g_signal_emit (server, signals[READY], 0);
-}
-
-static GSList *active_servers;
-static gboolean sigusr1_thread_running;
-static GCond sigusr1_thread_cond;
-static GMutex sigusr1_thread_mutex;
-
-static gboolean
-got_sigusr1 (gpointer user_data)
-{
-        GPid pid = GPOINTER_TO_UINT (user_data);
-        GSList *l;
-
-        g_debug ("GdmServer: got SIGUSR1 from PID %d", pid);
-
-        for (l = active_servers; l; l = l->next) {
-                GdmServer *server = l->data;
-
-                if (server->priv->pid == pid)
-                        gdm_server_ready (server);
+        g_debug ("GdmServer: Running helper %s", command);
+        out = NULL;
+        res = g_spawn_command_line_sync (command,
+                                         &out,
+                                         NULL,
+                                         &status,
+                                         &error);
+        if (! res) {
+                g_warning ("Could not run helper: %s", error->message);
+                g_error_free (error);
+        } else {
+                out = g_strstrip (out);
+                g_debug ("GdmServer: Got tty: '%s'", out);
         }
 
-        return G_SOURCE_REMOVE;
+        g_free (command);
+
+        return out;
 }
 
-static gpointer
-sigusr1_thread_main (gpointer user_data)
+char *
+gdm_server_get_display_device (GdmServer *server)
 {
-        sigset_t sigusr1_mask;
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                /* systemd finds the display device out on its own based on the display */
+                return NULL;
+        }
+#endif
 
-        /* Handle only SIGUSR1 */
-        sigemptyset (&sigusr1_mask);
-        sigaddset (&sigusr1_mask, SIGUSR1);
-        sigprocmask (SIG_SETMASK, &sigusr1_mask, NULL);
+        if (server->priv->display_device == NULL) {
+                server->priv->display_device =
+                    _gdm_server_query_ck_for_display_device (server);
 
-        g_mutex_lock (&sigusr1_thread_mutex);
-        sigusr1_thread_running = TRUE;
-        g_cond_signal (&sigusr1_thread_cond);
-        g_mutex_unlock (&sigusr1_thread_mutex);
-
-        /* Spin waiting for a SIGUSR1 */
-        while (TRUE) {
-                siginfo_t info;
-
-                if (sigwaitinfo (&sigusr1_mask, &info) == -1)
-                        continue;
-
-                g_idle_add (got_sigusr1, GUINT_TO_POINTER (info.si_pid));
+                g_object_notify (G_OBJECT (server), "display-device");
         }
 
-        return NULL;
+        return g_strdup (server->priv->display_device);
 }
 
-static void
-gdm_server_launch_sigusr1_thread_if_needed (void)
+static gboolean
+on_sigusr1 (gpointer user_data)
+
 {
-        static GThread *sigusr1_thread;
+        GdmServer *server = user_data;
 
-        if (sigusr1_thread == NULL) {
-                sigusr1_thread = g_thread_new ("gdm SIGUSR1 catcher", sigusr1_thread_main, NULL);
+        g_debug ("GdmServer: Got USR1 from X server - emitting READY");
 
-                g_mutex_lock (&sigusr1_thread_mutex);
-                while (!sigusr1_thread_running)
-                        g_cond_wait (&sigusr1_thread_cond, &sigusr1_thread_mutex);
-                g_mutex_unlock (&sigusr1_thread_mutex);
-        }
+        gdm_run_script (GDMCONFDIR "/Init", GDM_USERNAME,
+                        server->priv->display_name,
+                        NULL, /* hostname */
+                        server->priv->auth_file);
+
+        g_signal_emit (server, signals[READY], 0);
+        return FALSE;
 }
 
 static void
@@@@ -226,8 +215,10 @@@@ gdm_server_init_command (GdmServer *server)
                 debug_options = "";
         }
 
-#define X_SERVER_ARG_FORMAT " -background none -noreset -verbose %s%s"
+        #define X_SERVER_ARG_FORMAT " -background none -noreset -verbose %s%s"
 
+#ifdef WITH_SYSTEMD
+
         /* This is a temporary hack to work around the fact that XOrg
          * currently lacks support for multi-seat hotplugging for
          * display devices. This bit should be removed as soon as XOrg
@@@@ -242,6 +233,10 @@@@ gdm_server_init_command (GdmServer *server)
          * wasn't booted using systemd, or b) the wrapper tool is
          * missing, or c) we are running for the main seat 'seat0'. */
 
+        if (!LOGIND_RUNNING()) {
+                goto fallback;
+        }
+
 #ifdef ENABLE_SYSTEMD_JOURNAL
         /* For systemd, we don't have a log file but instead log to stdout,
            so set it to the xserver's built-in default verbosity */
@@@@ -264,8 +259,9 @@@@ gdm_server_init_command (GdmServer *server)
         return;
 
 fallback:
-        server->priv->command = g_strdup_printf (X_SERVER X_SERVER_ARG_FORMAT, verbosity, debug_options);
+#endif
 
+        server->priv->command = g_strdup_printf (X_SERVER X_SERVER_ARG_FORMAT, verbosity, debug_options);
 }
 
 static gboolean
@@@@ -315,10 +311,12 @@@@ gdm_server_resolve_command_line (GdmServer  *server,
                 argv[len++] = g_strdup (server->priv->auth_file);
         }
 
-        if (server->priv->display_seat_id != NULL) {
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING() && server->priv->display_seat_id != NULL) {
                 argv[len++] = g_strdup ("-seat");
                 argv[len++] = g_strdup (server->priv->display_seat_id);
         }
+#endif
 
         /* If we were compiled with Xserver >= 1.17 we need to specify
          * '-listen tcp' as the X server dosen't listen on tcp sockets
@@@@ -663,12 +661,6 @@@@ server_child_watch (GPid       pid,
         g_object_unref (server);
 }
 
-static void
-prune_active_servers_list (GdmServer *server)
-{
-        active_servers = g_slist_remove (active_servers, server);
-}
-
 static gboolean
 gdm_server_spawn (GdmServer    *server,
                   const char   *vtarg,
@@@@ -706,15 +698,6 @@@@ gdm_server_spawn (GdmServer    *server,
         g_debug ("GdmServer: Starting X server process: %s", freeme);
         g_free (freeme);
 
-        active_servers = g_slist_append (active_servers, server);
-
-        g_object_weak_ref (G_OBJECT (server),
-                           (GWeakNotify)
-                           prune_active_servers_list,
-                           server);
-
-        gdm_server_launch_sigusr1_thread_if_needed ();
-
         if (!g_spawn_async_with_pipes (NULL,
                                        argv,
                                        (char **)env->pdata,
@@@@ -1050,11 +1033,16 @@@@ gdm_server_class_init (GdmServerClass *klass)
 static void
 gdm_server_init (GdmServer *server)
 {
+
         server->priv = GDM_SERVER_GET_PRIVATE (server);
 
         server->priv->pid = -1;
 
         server->priv->log_dir = g_strdup (LOGDIR);
+
+        server->priv->sigusr1_id = g_unix_signal_add (SIGUSR1,
+                                                      on_sigusr1,
+                                                      server);
 }
 
 static void
@@@@ -1068,6 +1056,9 @@@@ gdm_server_finalize (GObject *object)
         server = GDM_SERVER (object);
 
         g_return_if_fail (server->priv != NULL);
+
+        if (server->priv->sigusr1_id > 0)
+                g_source_remove (server->priv->sigusr1_id);
 
         gdm_server_stop (server);
 
@


1.7
log
@Update to gdm-3.18.0.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-server_c,v 1.6 2015/04/03 18:39:06 ajacoutot Exp $
d21 2
a22 2
--- daemon/gdm-server.c.orig	Sun Oct 18 14:26:36 2015
+++ daemon/gdm-server.c	Sun Oct 18 14:24:34 2015
d230 3
a232 3
         if (server->priv->disable_tcp && ! query_in_arglist) {
                 argv[len++] = g_strdup ("-nolisten");
@@@@ -650,12 +648,6 @@@@ server_child_watch (GPid       pid,
d245 1
a245 1
@@@@ -693,15 +685,6 @@@@ gdm_server_spawn (GdmServer    *server,
d261 1
a261 1
@@@@ -1037,11 +1020,16 @@@@ gdm_server_class_init (GdmServerClass *klass)
d278 1
a278 1
@@@@ -1055,6 +1043,9 @@@@ gdm_server_finalize (GObject *object)
@


1.6
log
@Update to gdm-3.16.0.1.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-server_c,v 1.5 2014/03/30 18:43:44 ajacoutot Exp $
d9 25
a33 3
--- daemon/gdm-server.c.orig	Tue Mar 10 12:46:40 2015
+++ daemon/gdm-server.c	Fri Apr  3 20:24:53 2015
@@@@ -94,6 +94,7 @@@@ struct GdmServerPrivate
d41 17
a57 3
@@@@ -179,9 +180,12 @@@@ gdm_server_get_display_device (GdmServer *server)
         return g_strdup (server->priv->display_device);
 }
d61 3
a63 7
+static gboolean
+on_sigusr1 (gpointer user_data)
+
 {
+        GdmServer *server = user_data;
+
         g_debug ("GdmServer: Got USR1 from X server - emitting READY");
d65 7
a71 7
         gdm_run_script (GDMCONFDIR "/Init", GDM_USERNAME,
@@@@ -190,75 +194,10 @@@@ gdm_server_ready (GdmServer *server)
                         server->priv->auth_file);
 
         g_signal_emit (server, signals[READY], 0);
+        return FALSE;
 }
d73 3
d94 15
a108 2
-        }
-
d110 5
a114 2
-}
-
d117 3
a119 1
-{
d121 7
a127 1
-
d132 4
a135 1
-
d149 3
a151 2
-        }
-
d153 4
a156 3
-}
-
 static void
d158 4
a161 1
-{
d163 2
a164 1
-
d167 2
a168 1
-
d174 11
a184 7
-}
-
-static void
 gdm_server_init_command (GdmServer *server)
 {
         gboolean debug = FALSE;
@@@@ -276,7 +215,7 @@@@ gdm_server_init_command (GdmServer *server)
d191 38
a228 1
 #ifdef WITH_SYSTEMD
d230 3
a232 1
@@@@ -709,12 +648,6 @@@@ server_child_watch (GPid       pid,
d245 1
a245 1
@@@@ -752,15 +685,6 @@@@ gdm_server_spawn (GdmServer    *server,
d261 1
a261 1
@@@@ -1096,11 +1020,16 @@@@ gdm_server_class_init (GdmServerClass *klass)
d278 1
a278 1
@@@@ -1114,6 +1043,9 @@@@ gdm_server_finalize (GObject *object)
@


1.5
log
@Meh my last unexpected commit really fucked things up...

noticed by rpe@@
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-server_c,v 1.4 2014/03/30 14:48:23 ajacoutot Exp $
d9 2
a10 2
--- daemon/gdm-server.c.orig	Wed Mar 19 16:15:29 2014
+++ daemon/gdm-server.c	Sun Mar 30 20:43:02 2014
d149 1
a149 1
@@@@ -1105,11 +1029,16 @@@@ gdm_server_class_init (GdmServerClass *klass)
d166 1
a166 1
@@@@ -1123,6 +1052,9 @@@@ gdm_server_finalize (GObject *object)
@


1.4
log
@Re-apply the -noreset X switch from upstream.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-server_c,v 1.3 2014/03/30 14:43:24 ajacoutot Exp $
d10 1
a10 1
+++ daemon/gdm-server.c	Sun Mar 30 16:47:26 2014
d120 14
a133 1
@@@@ -752,15 +691,11 @@@@ gdm_server_spawn (GdmServer    *server,
d139 5
a143 5
         g_object_weak_ref (G_OBJECT (server),
                            (GWeakNotify)
                            prune_active_servers_list,
                            server);
 
d149 1
a149 1
@@@@ -1105,11 +1040,16 @@@@ gdm_server_class_init (GdmServerClass *klass)
d166 1
a166 1
@@@@ -1123,6 +1063,9 @@@@ gdm_server_finalize (GObject *object)
@


1.3
log
@Bump vala requirements.
@
text
@d1 1
a1 1
$OpenBSD$
d10 1
a10 1
+++ daemon/gdm-server.c	Sun Mar 30 11:33:15 2014
d116 1
a116 1
+        #define X_SERVER_ARG_FORMAT " -background none -verbose %s%s"
@


1.2
log
@Tweak patch; still fucked though.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-server_c,v 1.1 2014/03/27 19:19:17 ajacoutot Exp $
d3 5
a7 2
XXX push upstream
(no sigwaitinfo(2) on OpenBSD)
d10 3
a12 6
+++ daemon/gdm-server.c	Sat Mar 29 15:41:19 2014
@@@@ -233,8 +233,11 @@@@ sigusr1_thread_main (gpointer user_data)
         /* Spin waiting for a SIGUSR1 */
         while (TRUE) {
                 siginfo_t info;
+                int ret, sig;
d14 69
d84 78
a161 4
+                ret = sigwait (&sigusr1_mask, &sig);
+                info.si_pid = getpid ();
+                if (ret != 0)
                         continue;
a162 1
                 g_idle_add (got_sigusr1, GUINT_TO_POINTER (info.si_pid));
@


1.1
log
@Update to gdm-3.12.0.
@
text
@d1 1
a1 1
$OpenBSD$
d6 3
a8 11
--- daemon/gdm-server.c.orig	Thu Mar 27 19:24:15 2014
+++ daemon/gdm-server.c	Thu Mar 27 19:29:34 2014
@@@@ -219,6 +219,7 @@@@ static gpointer
 sigusr1_thread_main (gpointer user_data)
 {
         sigset_t sigusr1_mask;
+        int sig;
 
         /* Handle only SIGUSR1 */
         sigemptyset (&sigusr1_mask);
@@@@ -233,8 +234,11 @@@@ sigusr1_thread_main (gpointer user_data)
d16 2
a17 2
+                info.si_signo = sig;
+                if (ret == -1)
@

