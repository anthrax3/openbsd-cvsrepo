head	1.15;
access;
symbols
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8;
locks; strict;
comment	@# @;


1.15
date	2017.09.14.13.45.22;	author ajacoutot;	state Exp;
branches;
next	1.14;
commitid	U1x4N0ZmY4yzaCTj;

1.14
date	2017.05.10.10.18.15;	author ajacoutot;	state Exp;
branches;
next	1.13;
commitid	MWLyoRuOaJ97wX8y;

1.13
date	2017.04.17.13.17.07;	author ajacoutot;	state Exp;
branches;
next	1.12;
commitid	jKsCTviiCSXwN30M;

1.12
date	2017.03.11.00.22.27;	author ajacoutot;	state Exp;
branches;
next	1.11;
commitid	wTOKIz3zLsuh6oyz;

1.11
date	2017.03.03.13.01.26;	author ajacoutot;	state Exp;
branches;
next	1.10;
commitid	yUSOqvnIs3zvjqyw;

1.10
date	2016.04.26.08.25.04;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	U2wyfq8sPYBn4Lxu;

1.9
date	2015.10.18.13.25.54;	author ajacoutot;	state Exp;
branches;
next	1.8;
commitid	hskL6TnJZ8GALNPe;

1.8
date	2015.04.15.07.25.46;	author ajacoutot;	state Exp;
branches;
next	1.7;
commitid	75fdV4pvfzeme5bP;

1.7
date	2015.04.11.15.32.07;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	30bN2E72d6DnnVMT;

1.6
date	2015.04.10.20.43.51;	author ajacoutot;	state Exp;
branches;
next	1.5;
commitid	EGaVr3af0a3lQ0L8;

1.5
date	2015.04.03.18.39.06;	author ajacoutot;	state Exp;
branches;
next	1.4;
commitid	yAn0NWAFkDqbBMqK;

1.4
date	2014.04.15.13.15.19;	author ajacoutot;	state dead;
branches;
next	1.3;

1.3
date	2014.03.27.19.19.17;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.14.18.18.38;	author ajacoutot;	state dead;
branches;
next	1.1;

1.1
date	2013.05.17.14.55.58;	author ajacoutot;	state Exp;
branches;
next	;


desc
@@


1.15
log
@SECURITY update to gdm-3.24.3.
CVE-2017-12164 gdm unlock issue
Only GDM 3.24.1 or later are affected.
@
text
@$OpenBSD: patch-daemon_gdm-manager_c,v 1.14 2017/05/10 10:18:15 ajacoutot Exp $

REVERT - OpenBSD does not have a systemd implementation (we need ConsoleKit)
From 21905303afbd508f3bf599ad219c9209413c53a2 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Wed, 5 Apr 2017 12:11:20 -0400
Subject: manager: stop transient greeter session when done with it

REVERT - OpenBSD does not have a systemd implementation (we need ConsoleKit)
From 22c332baaf8ad6d7082c5b01250bae70934c2fd1 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Tue, 4 Apr 2017 17:07:04 -0400
Subject: manager: make sure we end up on a login screen

REVERT - OpenBSD does not have a systemd implementation (we need ConsoleKit)
From 1ac67f522f5690c27023d98096ca817f12f7eb88 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Fri, 12 Jun 2015 13:28:01 -0400
Subject: drop consolekit support

REVERT - OpenBSD does not have a systemd implementation (we need ConsoleKit)
From 9be58c9ec9a3a411492a5182ac4b0d51fdc3a323 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Fri, 12 Jun 2015 13:48:52 -0400
Subject: require logind support

Index: daemon/gdm-manager.c
--- daemon/gdm-manager.c.orig
+++ daemon/gdm-manager.c
@@@@ -36,7 +36,9 @@@@
 
 #include <act/act-user-manager.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "gdm-common.h"
 
@@@@ -61,8 +63,17 @@@@
 #define GDM_MANAGER_PATH          GDM_DBUS_PATH "/Manager"
 #define GDM_MANAGER_DISPLAYS_PATH GDM_DBUS_PATH "/Displays"
 
-#define INITIAL_SETUP_USERNAME "gnome-initial-setup"
+#define INITIAL_SETUP_USERNAME "_gnome-initial-setup"
 
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+
 typedef struct
 {
         GdmManager *manager;
@@@@ -206,9 +217,10 @@@@ plymouth_quit_without_transition (void)
 }
 #endif
 
+#ifdef WITH_SYSTEMD
 static char *
-get_session_id_for_pid (pid_t    pid,
-                        GError **error)
+get_session_id_for_pid_systemd (pid_t    pid,
+                                GError **error)
 {
         char *session, *gsession;
         int ret;
@@@@ -233,11 +245,61 @@@@ get_session_id_for_pid (pid_t    pid,
                 return NULL;
         }
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
+static char *
+get_session_id_for_pid_consolekit (GDBusConnection  *connection,
+                                   pid_t             pid,
+                                   GError          **error)
+{
+        GVariant *reply;
+        char *retval;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "GetSessionForUnixProcess",
+                                             g_variant_new ("(u)", pid),
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, error);
+        if (reply == NULL) {
+                return NULL;
+        }
+
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
+}
+#endif
+
+static char *
+get_session_id_for_pid (GDBusConnection  *connection,
+                        pid_t             pid,
+                        GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_session_id_for_pid_systemd (pid, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_session_id_for_pid_consolekit (connection, pid, error);
+#endif
+
+        return NULL;
+}
+
+#ifdef WITH_SYSTEMD
 static gboolean
-get_uid_for_session_id (const char  *session_id,
-                        uid_t       *uid,
-                        GError     **error)
+get_uid_for_systemd_session_id (const char  *session_id,
+                                uid_t       *uid,
+                                GError     **error)
 {
         int ret;
 
@@@@ -254,8 +316,62 @@@@ get_uid_for_session_id (const char  *session_id,
 
         return TRUE;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
+get_uid_for_consolekit_session_id (GDBusConnection  *connection,
+                                   const char       *session_id,
+                                   uid_t            *out_uid,
+                                   GError          **error)
+{
+        GVariant *reply;
+        guint32 uid;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetUnixUser",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(u)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(u)", &uid);
+        g_variant_unref (reply);
+
+        *out_uid = (uid_t) uid;
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+get_uid_for_session_id (GDBusConnection  *connection,
+                        const char       *session_id,
+                        uid_t            *uid,
+                        GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_uid_for_systemd_session_id (session_id, uid, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_uid_for_consolekit_session_id (connection, session_id, uid, error);
+#endif
+
+        return FALSE;
+}
+
+static gboolean
 lookup_by_session_id (const char *id,
                       GdmDisplay *display,
                       gpointer    user_data)
@@@@ -267,11 +383,51 @@@@ lookup_by_session_id (const char *id,
         return g_strcmp0 (current, looking_for) == 0;
 }
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
-is_login_session (GdmManager  *self,
-                  const char  *session_id,
-                  GError     **error)
+is_consolekit_login_session (GdmManager       *self,
+                             GDBusConnection  *connection,
+                             const char       *session_id,
+                             GError          **error)
 {
+        GVariant *reply;
+        char *session_type = NULL;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(s)", &session_type);
+        g_variant_unref (reply);
+
+        if (g_strcmp0 (session_type, "LoginWindow") != 0) {
+                g_free (session_type);
+
+                return FALSE;
+        }
+
+        g_free (session_type);
+        return TRUE;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+static gboolean
+is_systemd_login_session (GdmManager  *self,
+                          const char  *session_id,
+                          GError     **error)
+{
         char *session_class = NULL;
         int ret;
 
@@@@ -295,12 +451,33 @@@@ is_login_session (GdmManager  *self,
         g_free (session_class);
         return TRUE;
 }
+#endif
 
 static gboolean
-activate_session_id (GdmManager *manager,
-                     const char *seat_id,
-                     const char *session_id)
+is_login_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
 {
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return is_systemd_login_session (self, session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return is_consolekit_login_session (self, connection, session_id, error);
+#endif
+
+        return FALSE;
+}
+
+#ifdef WITH_SYSTEMD
+static gboolean
+activate_session_id_for_systemd (GdmManager   *manager,
+                                 const char *seat_id,
+                                 const char *session_id)
+{
         GError *error = NULL;
         GVariant *reply;
 
@@@@ -326,16 +503,75 @@@@ activate_session_id (GdmManager *manager,
 
         return TRUE;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
-session_unlock (GdmManager *manager,
-                const char *ssid)
+activate_session_id_for_ck (GdmManager *manager,
+                            const char *seat_id,
+                            const char *session_id)
 {
         GError *error = NULL;
         GVariant *reply;
 
-        g_debug ("Unlocking session %s", ssid);
+        reply = g_dbus_connection_call_sync (manager->priv->connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             "org.freedesktop.ConsoleKit.Seat",
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
 
+                /* It is very likely that the "error" just reported is
+                 * that the session is already active.  Unfortunately,
+                 * ConsoleKit doesn't use proper error codes and it
+                 * translates the error message, so we have no real way
+                 * to detect this case...
+                 */
+                return TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+activate_session_id (GdmManager *manager,
+                     const char *seat_id,
+                     const char *session_id)
+{
+
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return activate_session_id_for_systemd (manager, seat_id, session_id);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return activate_session_id_for_ck (manager, seat_id, session_id);
+#else
+        return FALSE;
+#endif
+}
+
+#ifdef WITH_SYSTEMD
+static gboolean
+session_unlock_for_systemd (GdmManager *manager,
+                            const char *ssid)
+{
+        GError *error = NULL;
+        GVariant *reply;
+
         reply = g_dbus_connection_call_sync (manager->priv->connection,
                                              "org.freedesktop.login1",
                                              "/org/freedesktop/login1",
@@@@ -358,7 +594,60 @@@@ session_unlock (GdmManager *manager,
 
         return TRUE;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+session_unlock_for_ck (GdmManager *manager,
+                       const char *ssid)
+{
+        GError *error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (manager->priv->connection,
+                                             CK_NAME,
+                                             ssid,
+                                             CK_SESSION_INTERFACE,
+                                             "Unlock",
+                                             NULL, /* parameters */
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+session_unlock (GdmManager *manager,
+                const char *ssid)
+{
+
+        g_debug ("Unlocking session %s", ssid);
+
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return session_unlock_for_systemd (manager, ssid);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return session_unlock_for_ck (manager, ssid);
+#else
+        return TRUE;
+#endif
+}
+
 static GdmSession *
 find_session_for_user_on_seat (GdmManager *manager,
                                const char *username,
@@@@ -389,11 +678,44 @@@@ find_session_for_user_on_seat (GdmManager *manager,
         return NULL;
 }
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
-is_remote_session (GdmManager  *self,
-                   const char  *session_id,
-                   GError     **error)
+is_consolekit_remote_session (GdmManager       *self,
+                             GDBusConnection  *connection,
+                             const char       *session_id,
+                             GError          **error)
 {
+        GVariant *reply;
+        gboolean is_remote;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "IsLocal",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &is_remote);
+        g_variant_unref (reply);
+
+        return is_remote;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+static gboolean
+is_systemd_remote_session (GdmManager  *self,
+                           const char  *session_id,
+                           GError     **error)
+{
         char *seat;
         int ret;
         gboolean is_remote;
@@@@ -418,10 +740,31 @@@@ is_remote_session (GdmManager  *self,
 
         return is_remote;
 }
+#endif
 
+static gboolean
+is_remote_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return is_systemd_remote_session (self, session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return is_consolekit_remote_session (self, connection, session_id, error);
+#endif
+
+        return FALSE;
+}
+
+#ifdef WITH_SYSTEMD
 static char *
-get_seat_id_for_session_id (const char  *session_id,
-                            GError     **error)
+get_seat_id_for_systemd_session_id (const char  *session_id,
+                                    GError     **error)
 {
         int ret;
         char *seat, *out_seat;
@@@@ -446,11 +789,62 @@@@ get_seat_id_for_session_id (const char  *session_id,
 
         return out_seat;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
 static char *
-get_tty_for_session_id (const char  *session_id,
-                        GError     **error)
+get_seat_id_for_consolekit_session_id (GDBusConnection  *connection,
+                                       const char       *session_id,
+                                       GError          **error)
 {
+        GVariant *reply;
+        char *retval;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSeatId",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return NULL;
+        }
+
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
+}
+#endif
+
+static char *
+get_seat_id_for_session_id (GDBusConnection  *connection,
+                            const char       *session_id,
+                            GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_seat_id_for_systemd_session_id (session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_seat_id_for_consolekit_session_id (connection, session_id, error);
+#endif
+
+        return NULL;
+}
+
+#ifdef WITH_SYSTEMD
+static char *
+get_tty_for_systemd_session_id (const char  *session_id,
+                                GError     **error)
+{
         int ret;
         char *tty, *out_tty;
 
@@@@ -473,7 +867,21 @@@@ get_tty_for_session_id (const char  *session_id,
 
         return out_tty;
 }
+#endif
 
+static char *
+get_tty_for_session_id (const char  *session_id,
+                        GError     **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_tty_for_systemd_session_id (session_id, error);
+        }
+#endif
+
+        return NULL;
+}
+
 static void
 get_display_and_details_for_bus_sender (GdmManager       *self,
                                         GDBusConnection  *connection,
@@@@ -516,7 +924,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
                 goto out;
         }
 
-        session_id = get_session_id_for_pid (pid, &error);
+        session_id = get_session_id_for_pid (connection, pid, &error);
 
         if (session_id == NULL) {
                 g_debug ("GdmManager: Error while retrieving session id for sender: %s",
@@@@ -530,7 +938,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_is_login_screen != NULL) {
-                *out_is_login_screen = is_login_session (self, session_id, &error);
+                *out_is_login_screen = is_login_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while checking if sender is login screen: %s",
@@@@ -540,7 +948,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
                 }
         }
 
-        if (!get_uid_for_session_id (session_id, &session_uid, &error)) {
+        if (!get_uid_for_session_id (connection, session_id, &session_uid, &error)) {
                 g_debug ("GdmManager: Error while retrieving uid for session: %s",
                          error->message);
                 g_error_free (error);
@@@@ -557,7 +965,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_seat_id != NULL) {
-                *out_seat_id = get_seat_id_for_session_id (session_id, &error);
+                *out_seat_id = get_seat_id_for_session_id (connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving seat id for session: %s",
@@@@ -567,7 +975,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_is_remote != NULL) {
-                *out_is_remote = is_remote_session (self, session_id, &error);
+                *out_is_remote = is_remote_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving remoteness for session: %s",
@@@@ -956,7 +1364,8 @@@@ on_reauthentication_client_rejected (GdmSession       
                  * same audit session, ignore it since it doesn't "own" the
                  * reauthentication session
                  */
-                client_session_id = get_session_id_for_pid (pid_of_client,
+                client_session_id = get_session_id_for_pid (self->priv->connection,
+                                                            pid_of_client,
                                                             NULL);
                 session_id = g_object_get_data (G_OBJECT (session), "caller-session-id");
 
@@@@ -1168,16 +1577,20 @@@@ static gboolean
 display_is_on_seat0 (GdmDisplay *display)
 {
         gboolean is_on_seat0 = TRUE;
-        char *seat_id = NULL;
 
-        g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                char *seat_id = NULL;
 
-        if (g_strcmp0 (seat_id, "seat0") != 0) {
-            is_on_seat0 = FALSE;
-        }
+                g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
 
-        g_free (seat_id);
+                if (g_strcmp0 (seat_id, "seat0") != 0) {
+                        is_on_seat0 = FALSE;
+                }
 
+                g_free (seat_id);
+        }
+#endif
         return is_on_seat0;
 }
 
@@@@ -1315,133 +1728,6 @@@@ maybe_start_pending_initial_login (GdmManager *manager
         g_free (user_session_seat_id);
 }
 
-static gboolean
-get_login_window_session_id (const char  *seat_id,
-                             char       **session_id)
-{
-        gboolean   ret;
-        int        res, i;
-        char     **sessions;
-        char      *service_id;
-        char      *service_class;
-        char      *state;
-
-        res = sd_seat_get_sessions (seat_id, &sessions, NULL, NULL);
-        if (res < 0) {
-                g_debug ("Failed to determine sessions: %s", strerror (-res));
-                return FALSE;
-        }
-
-        if (sessions == NULL || sessions[0] == NULL) {
-                *session_id = NULL;
-                ret = TRUE;
-                goto out;
-        }
-
-        for (i = 0; sessions[i]; i ++) {
-
-                res = sd_session_get_class (sessions[i], &service_class);
-                if (res < 0) {
-                        g_debug ("failed to determine class of session %s: %s", sessions[i], strerror (-res));
-                        ret = FALSE;
-                        goto out;
-                }
-
-                if (strcmp (service_class, "greeter") != 0) {
-                        free (service_class);
-                        continue;
-                }
-
-                free (service_class);
-
-                ret = sd_session_get_state (sessions[i], &state);
-                if (ret < 0) {
-                        g_debug ("failed to determine state of session %s: %s", sessions[i], strerror (-res));
-                        ret = FALSE;
-                        goto out;
-                }
-
-                if (g_strcmp0 (state, "closing") == 0) {
-                        free (state);
-                        continue;
-                }
-                free (state);
-
-                res = sd_session_get_service (sessions[i], &service_id);
-                if (res < 0) {
-                        g_debug ("failed to determine service of session %s: %s", sessions[i], strerror (-res));
-                        ret = FALSE;
-                        goto out;
-                }
-
-                if (strcmp (service_id, "gdm-launch-environment") == 0) {
-                        *session_id = g_strdup (sessions[i]);
-                        ret = TRUE;
-
-                        free (service_id);
-                        goto out;
-                }
-
-                free (service_id);
-        }
-
-        *session_id = NULL;
-        ret = TRUE;
-
-out:
-        if (sessions) {
-                for (i = 0; sessions[i]; i ++) {
-                        free (sessions[i]);
-                }
-
-                free (sessions);
-        }
-
-        return ret;
-}
-
-static void
-activate_login_window_session_on_seat (GdmManager *self,
-                                       const char *seat_id)
-{
-        char *session_id;
-
-        if (!get_login_window_session_id (seat_id, &session_id)) {
-                return;
-        }
-
-        activate_session_id (self, seat_id, session_id);
-}
-
-static void
-maybe_activate_other_session (GdmManager *self,
-                              GdmDisplay *old_display)
-{
-        char *seat_id = NULL;
-        char *session_id;
-        int ret;
-
-        g_object_get (G_OBJECT (old_display),
-                      "seat-id", &seat_id,
-                      NULL);
-
-        ret = sd_seat_get_active (seat_id, &session_id, NULL);
-
-        if (ret == 0) {
-                GdmDisplay *display;
-
-                display = gdm_display_store_find (self->priv->display_store,
-                                                  lookup_by_session_id,
-                                                  (gpointer) session_id);
-
-                if (display == NULL) {
-                        activate_login_window_session_on_seat (self, seat_id);
-                }
-        }
-
-        g_free (seat_id);
-}
-
 static const char *
 get_username_for_greeter_display (GdmManager *manager,
                                   GdmDisplay *display)
@@@@ -1687,7 +1973,6 @@@@ on_display_status_changed (GdmDisplay *display,
                                 manager->priv->ran_once = TRUE;
                         }
                         maybe_start_pending_initial_login (manager, display);
-                        maybe_activate_other_session (manager, display);
                         break;
                 default:
                         break;
@@@@ -2017,11 +2302,57 @@@@ on_user_session_died (GdmSession *session,
 }
 
 static char *
+query_ck_for_display_device (GdmManager *manager,
+                             GdmDisplay *display)
+{
+        char    *out;
+        char    *command;
+        char    *display_name = NULL;
+        int      status;
+        gboolean res;
+        GError  *error;
+
+        g_object_get (G_OBJECT (display),
+                      "x11-display-name", &display_name,
+                      NULL);
+
+        error = NULL;
+        command = g_strdup_printf (CONSOLEKIT_DIR "/ck-get-x11-display-device --display %s",
+                                   display_name);
+        g_free (display_name);
+
+        g_debug ("GdmManager: Running helper %s", command);
+        out = NULL;
+        res = g_spawn_command_line_sync (command,
+                                         &out,
+                                         NULL,
+                                         &status,
+                                         &error);
+        if (! res) {
+                g_warning ("GdmManager: Could not run helper %s: %s", command, error->message);
+                g_error_free (error);
+        } else {
+                out = g_strstrip (out);
+                g_debug ("GdmManager: Got tty: '%s'", out);
+        }
+
+        g_free (command);
+
+        return out;
+}
+
+static char *
 get_display_device (GdmManager *manager,
                     GdmDisplay *display)
 {
-        /* systemd finds the display device out on its own based on the display */
-        return NULL;
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                /* systemd finds the display device out on its own based on the display */
+                return NULL;
+        }
+#endif
+
+        return query_ck_for_display_device (manager, display);
 }
 
 static void
@@@@ -2030,26 +2361,6 @@@@ on_session_reauthenticated (GdmSession *session,
                             GdmManager *manager)
 {
         gboolean fail_if_already_switched = FALSE;
-
-        if (gdm_session_get_display_mode (session) == GDM_SESSION_DISPLAY_MODE_REUSE_VT) {
-                const char *seat_id;
-                char *session_id;
-
-                seat_id = gdm_session_get_display_seat_id (session);
-                if (get_login_window_session_id (seat_id, &session_id)) {
-                        GdmDisplay *display = gdm_display_store_find (manager->priv->display_store,
-                                                                      lookup_by_session_id,
-                                                                      (gpointer) session_id);
-
-                        if (display != NULL) {
-                                gdm_display_stop_greeter_session (display);
-                                gdm_display_unmanage (display);
-                                gdm_display_finish (display);
-                        }
-                }
-                g_free (session_id);
-        }
-
         /* There should already be a session running, so jump to its
          * VT. In the event we're already on the right VT, (i.e. user
          * used an unlock screen instead of a user switched login screen),
@


1.14
log
@Update to gdm-3.24.2.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.13 2017/04/17 13:17:07 ajacoutot Exp $
d817 1
a817 1
@@@@ -1684,7 +1970,6 @@@@ on_display_status_changed (GdmDisplay *display,
d825 1
a825 1
@@@@ -2014,11 +2299,57 @@@@ on_user_session_died (GdmSession *session,
d885 1
a885 1
@@@@ -2027,26 +2358,6 @@@@ on_session_reauthenticated (GdmSession *session,
@


1.13
log
@Update to gdm-3.24.1.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.12 2017/03/11 00:22:27 ajacoutot Exp $
d27 3
a29 2
--- daemon/gdm-manager.c.orig	Mon Apr 17 15:07:08 2017
+++ daemon/gdm-manager.c	Mon Apr 17 15:07:04 2017
d825 1
a825 1
@@@@ -2009,11 +2294,57 @@@@ on_user_session_died (GdmSession *session,
d885 1
a885 1
@@@@ -2022,26 +2353,6 @@@@ on_session_reauthenticated (GdmSession *session,
@


1.12
log
@Update to gdm-3.22.3.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.11 2017/03/03 13:01:26 ajacoutot Exp $
d3 11
a13 1
XXX fix+push upstream
d27 5
a31 5
--- daemon/gdm-manager.c.orig	Fri Mar  3 21:32:43 2017
+++ daemon/gdm-manager.c	Tue Mar  7 09:17:45 2017
@@@@ -34,7 +34,9 @@@@
 #include <glib/gstdio.h>
 #include <glib-object.h>
d39 1
a39 1
@@@@ -57,8 +59,17 @@@@
d58 1
a58 1
@@@@ -202,9 +213,10 @@@@ plymouth_quit_without_transition (void)
d71 1
a71 1
@@@@ -229,11 +241,61 @@@@ get_session_id_for_pid (pid_t    pid,
d136 1
a136 1
@@@@ -250,8 +312,62 @@@@ get_uid_for_session_id (const char  *session_id,
d199 1
a199 1
@@@@ -263,11 +379,51 @@@@ lookup_by_session_id (const char *id,
d254 1
a254 1
@@@@ -291,12 +447,33 @@@@ is_login_session (GdmManager  *self,
d291 1
a291 1
@@@@ -322,16 +499,75 @@@@ activate_session_id (GdmManager *manager,
d370 1
a370 1
@@@@ -354,7 +590,60 @@@@ session_unlock (GdmManager *manager,
d431 1
a431 1
@@@@ -385,11 +674,44 @@@@ find_session_for_user_on_seat (GdmManager *manager,
d479 1
a479 1
@@@@ -414,10 +736,31 @@@@ is_remote_session (GdmManager  *self,
d513 1
a513 1
@@@@ -442,11 +785,62 @@@@ get_seat_id_for_session_id (const char  *session_id,
d578 1
a578 1
@@@@ -469,7 +863,21 @@@@ get_tty_for_session_id (const char  *session_id,
d600 1
a600 1
@@@@ -512,7 +920,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
d609 1
a609 1
@@@@ -526,7 +934,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
d618 1
a618 1
@@@@ -536,7 +944,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
d627 1
a627 1
@@@@ -553,7 +961,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
d636 1
a636 1
@@@@ -563,7 +971,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
d645 1
a645 1
@@@@ -931,7 +1339,8 @@@@ on_reauthentication_client_rejected (GdmSession       
d655 1
a655 1
@@@@ -1143,16 +1552,20 @@@@ static gboolean
d682 143
a824 1
@@@@ -1770,11 +2183,57 @@@@ on_user_session_died (GdmSession *session,
d884 27
@


1.11
log
@Update to gdm-3.22.2.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.10 2016/04/26 08:25:04 ajacoutot Exp $
d17 2
a18 2
--- daemon/gdm-manager.c.orig	Wed Mar  1 21:58:01 2017
+++ daemon/gdm-manager.c	Fri Mar  3 11:46:46 2017
d635 1
a635 1
@@@@ -929,7 +1337,8 @@@@ on_reauthentication_client_rejected (GdmSession       
d645 1
a645 1
@@@@ -1141,16 +1550,20 @@@@ static gboolean
d672 1
a672 1
@@@@ -1759,11 +2172,57 @@@@ on_user_session_died (GdmSession *session,
@


1.10
log
@Update to gdm-3.20.1.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.9 2015/10/18 13:25:54 ajacoutot Exp $
d17 2
a18 2
--- daemon/gdm-manager.c.orig	Tue Apr 19 07:00:04 2016
+++ daemon/gdm-manager.c	Tue Apr 26 10:02:48 2016
d635 1
a635 1
@@@@ -927,7 +1335,8 @@@@ on_reauthentication_client_rejected (GdmSession       
d645 1
a645 1
@@@@ -1139,16 +1548,20 @@@@ static gboolean
d672 1
a672 1
@@@@ -1785,11 +2198,57 @@@@ on_user_session_died (GdmSession *session,
@


1.9
log
@Update to gdm-3.18.0.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.8 2015/04/15 07:25:46 ajacoutot Exp $
d17 2
a18 2
--- daemon/gdm-manager.c.orig	Sun Oct 18 14:26:34 2015
+++ daemon/gdm-manager.c	Sun Oct 18 14:34:21 2015
d672 1
a672 1
@@@@ -1749,11 +2162,57 @@@@ on_user_session_died (GdmSession *session,
@


1.8
log
@Update to gdm-3.16.1.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.7 2015/04/11 15:32:07 ajacoutot Exp $
d5 27
a31 5
--- daemon/gdm-manager.c.orig	Fri Apr 10 21:54:41 2015
+++ daemon/gdm-manager.c	Fri Apr 10 21:54:54 2015
@@@@ -68,7 +68,7 @@@@
 #define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
 #define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
d36 9
d47 685
@


1.7
log
@Committed upstream.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.6 2015/04/10 20:43:51 ajacoutot Exp $
a4 5
From 172534d4a803d7905c10a76dc7bd6652cebc5f81 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Tue, 7 Apr 2015 10:57:36 -0400
Subject: manager: properly query display number when built without plymouth

a15 13
@@@@ -1705,10 +1705,11 @@@@ on_display_status_changed (GdmDisplay *display,
 
         g_object_get (display,
                       "is-local", &display_is_local,
-                      "x11-display-number", &display_number,
                       NULL);
         quit_plymouth = display_is_local && manager->priv->plymouth_is_running;
 #endif
+
+        g_object_get (display, "x11-display-number", &display_number, NULL);
 
         status = gdm_display_get_status (display);
 
@


1.6
log
@Ensure X11 display device is propagated to launch environment so that
ConsoleKit works (upstream).
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.5 2015/04/03 18:39:06 ajacoutot Exp $
d5 4
a8 1
https://bugzilla.gnome.org/show_bug.cgi?id=747351
@


1.5
log
@Update to gdm-3.16.0.1.
@
text
@d1 1
a1 1
$OpenBSD$
d5 4
a8 2
--- daemon/gdm-manager.c.orig	Fri Apr  3 20:28:07 2015
+++ daemon/gdm-manager.c	Fri Apr  3 20:28:15 2015
d18 13
@


1.4
log
@Update to gdm-3.12.1.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.3 2014/03/27 19:19:17 ajacoutot Exp $
d3 1
a3 4
From 1d76114a001c5c4eeba17fc9a455e3a132fc23c5 Mon Sep 17 00:00:00 2001
From: Ryan Lortie <desrt@@desrt.ca>
Date: Wed, 26 Mar 2014 04:33:58 +0000
Subject: ConsoleKit: a pair of tweaks
d5 5
a9 16
--- daemon/gdm-manager.c.orig	Fri Mar 21 17:56:39 2014
+++ daemon/gdm-manager.c	Thu Mar 27 18:27:58 2014
@@@@ -430,7 +430,14 @@@@ activate_session_id_for_ck (GdmManager *manager,
                 g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
                          g_dbus_error_get_remote_error (error), error->message);
                 g_error_free (error);
-                return FALSE;
+
+                /* It is very likely that the "error" just reported is
+                 * that the session is already active.  Unfortunately,
+                 * ConsoleKit doesn't use proper error codes and it
+                 * translates the error message, so we have no real way
+                 * to detect this case...
+                 */
+                return TRUE;
         }
d11 5
a15 1
         g_variant_unref (reply);
@


1.3
log
@Update to gdm-3.12.0.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@Update to gdm-3.8.3.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.1 2013/05/17 14:55:58 ajacoutot Exp $
d3 4
a6 4
From c08e9a6a16b2fa953c6ee90b2a6adb618cba5942 Mon Sep 17 00:00:00 2001
From: Colin Walters <walters@@verbum.org>
Date: Fri, 17 May 2013 13:37:39 +0000
Subject: manager: Don't attempt to unexport DBus object if connection is closed
d8 16
a23 10
--- daemon/gdm-manager.c.orig	Mon Apr 15 23:02:31 2013
+++ daemon/gdm-manager.c	Fri May 17 16:40:22 2013
@@@@ -1135,7 +1135,8 @@@@ unexport_display (const char *id,
                   GdmDisplay *display,
                   GdmManager *manager)
 {
-    g_dbus_object_manager_server_unexport (manager->priv->object_manager, id);
+        if (!g_dbus_connection_is_closed (manager->priv->connection))
+                g_dbus_object_manager_server_unexport (manager->priv->object_manager, id);
 }
d25 1
a25 1
 static void
@


1.1
log
@Fix a crash on logout (from upstream).
@
text
@d1 1
a1 1
$OpenBSD$
@

