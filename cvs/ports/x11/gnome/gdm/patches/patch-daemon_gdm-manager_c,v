head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8;
locks; strict;
comment	@# @;


1.12
date	2017.03.11.00.22.27;	author ajacoutot;	state Exp;
branches;
next	1.11;
commitid	wTOKIz3zLsuh6oyz;

1.11
date	2017.03.03.13.01.26;	author ajacoutot;	state Exp;
branches;
next	1.10;
commitid	yUSOqvnIs3zvjqyw;

1.10
date	2016.04.26.08.25.04;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	U2wyfq8sPYBn4Lxu;

1.9
date	2015.10.18.13.25.54;	author ajacoutot;	state Exp;
branches;
next	1.8;
commitid	hskL6TnJZ8GALNPe;

1.8
date	2015.04.15.07.25.46;	author ajacoutot;	state Exp;
branches;
next	1.7;
commitid	75fdV4pvfzeme5bP;

1.7
date	2015.04.11.15.32.07;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	30bN2E72d6DnnVMT;

1.6
date	2015.04.10.20.43.51;	author ajacoutot;	state Exp;
branches;
next	1.5;
commitid	EGaVr3af0a3lQ0L8;

1.5
date	2015.04.03.18.39.06;	author ajacoutot;	state Exp;
branches;
next	1.4;
commitid	yAn0NWAFkDqbBMqK;

1.4
date	2014.04.15.13.15.19;	author ajacoutot;	state dead;
branches;
next	1.3;

1.3
date	2014.03.27.19.19.17;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.14.18.18.38;	author ajacoutot;	state dead;
branches;
next	1.1;

1.1
date	2013.05.17.14.55.58;	author ajacoutot;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to gdm-3.22.3.
@
text
@$OpenBSD: patch-daemon_gdm-manager_c,v 1.11 2017/03/03 13:01:26 ajacoutot Exp $

XXX fix+push upstream

REVERT - OpenBSD does not have a systemd implementation (we need ConsoleKit)
From 1ac67f522f5690c27023d98096ca817f12f7eb88 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Fri, 12 Jun 2015 13:28:01 -0400
Subject: drop consolekit support

REVERT - OpenBSD does not have a systemd implementation (we need ConsoleKit)
From 9be58c9ec9a3a411492a5182ac4b0d51fdc3a323 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Fri, 12 Jun 2015 13:48:52 -0400
Subject: require logind support

--- daemon/gdm-manager.c.orig	Fri Mar  3 21:32:43 2017
+++ daemon/gdm-manager.c	Tue Mar  7 09:17:45 2017
@@@@ -34,7 +34,9 @@@@
 #include <glib/gstdio.h>
 #include <glib-object.h>
 
+#ifdef WITH_SYSTEMD
 #include <systemd/sd-login.h>
+#endif
 
 #include "gdm-common.h"
 
@@@@ -57,8 +59,17 @@@@
 #define GDM_MANAGER_PATH          GDM_DBUS_PATH "/Manager"
 #define GDM_MANAGER_DISPLAYS_PATH GDM_DBUS_PATH "/Displays"
 
-#define INITIAL_SETUP_USERNAME "gnome-initial-setup"
+#define INITIAL_SETUP_USERNAME "_gnome-initial-setup"
 
+#define CK_NAME      "org.freedesktop.ConsoleKit"
+#define CK_PATH      "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE "org.freedesktop.ConsoleKit"
+
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+
 typedef struct
 {
         GdmManager *manager;
@@@@ -202,9 +213,10 @@@@ plymouth_quit_without_transition (void)
 }
 #endif
 
+#ifdef WITH_SYSTEMD
 static char *
-get_session_id_for_pid (pid_t    pid,
-                        GError **error)
+get_session_id_for_pid_systemd (pid_t    pid,
+                                GError **error)
 {
         char *session, *gsession;
         int ret;
@@@@ -229,11 +241,61 @@@@ get_session_id_for_pid (pid_t    pid,
                 return NULL;
         }
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
+static char *
+get_session_id_for_pid_consolekit (GDBusConnection  *connection,
+                                   pid_t             pid,
+                                   GError          **error)
+{
+        GVariant *reply;
+        char *retval;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "GetSessionForUnixProcess",
+                                             g_variant_new ("(u)", pid),
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, error);
+        if (reply == NULL) {
+                return NULL;
+        }
+
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
+}
+#endif
+
+static char *
+get_session_id_for_pid (GDBusConnection  *connection,
+                        pid_t             pid,
+                        GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_session_id_for_pid_systemd (pid, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_session_id_for_pid_consolekit (connection, pid, error);
+#endif
+
+        return NULL;
+}
+
+#ifdef WITH_SYSTEMD
 static gboolean
-get_uid_for_session_id (const char  *session_id,
-                        uid_t       *uid,
-                        GError     **error)
+get_uid_for_systemd_session_id (const char  *session_id,
+                                uid_t       *uid,
+                                GError     **error)
 {
         int ret;
 
@@@@ -250,8 +312,62 @@@@ get_uid_for_session_id (const char  *session_id,
 
         return TRUE;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
+get_uid_for_consolekit_session_id (GDBusConnection  *connection,
+                                   const char       *session_id,
+                                   uid_t            *out_uid,
+                                   GError          **error)
+{
+        GVariant *reply;
+        guint32 uid;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetUnixUser",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(u)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(u)", &uid);
+        g_variant_unref (reply);
+
+        *out_uid = (uid_t) uid;
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+get_uid_for_session_id (GDBusConnection  *connection,
+                        const char       *session_id,
+                        uid_t            *uid,
+                        GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_uid_for_systemd_session_id (session_id, uid, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_uid_for_consolekit_session_id (connection, session_id, uid, error);
+#endif
+
+        return FALSE;
+}
+
+static gboolean
 lookup_by_session_id (const char *id,
                       GdmDisplay *display,
                       gpointer    user_data)
@@@@ -263,11 +379,51 @@@@ lookup_by_session_id (const char *id,
         return g_strcmp0 (current, looking_for) == 0;
 }
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
-is_login_session (GdmManager  *self,
-                  const char  *session_id,
-                  GError     **error)
+is_consolekit_login_session (GdmManager       *self,
+                             GDBusConnection  *connection,
+                             const char       *session_id,
+                             GError          **error)
 {
+        GVariant *reply;
+        char *session_type = NULL;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(s)", &session_type);
+        g_variant_unref (reply);
+
+        if (g_strcmp0 (session_type, "LoginWindow") != 0) {
+                g_free (session_type);
+
+                return FALSE;
+        }
+
+        g_free (session_type);
+        return TRUE;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+static gboolean
+is_systemd_login_session (GdmManager  *self,
+                          const char  *session_id,
+                          GError     **error)
+{
         char *session_class = NULL;
         int ret;
 
@@@@ -291,12 +447,33 @@@@ is_login_session (GdmManager  *self,
         g_free (session_class);
         return TRUE;
 }
+#endif
 
 static gboolean
-activate_session_id (GdmManager *manager,
-                     const char *seat_id,
-                     const char *session_id)
+is_login_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
 {
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return is_systemd_login_session (self, session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return is_consolekit_login_session (self, connection, session_id, error);
+#endif
+
+        return FALSE;
+}
+
+#ifdef WITH_SYSTEMD
+static gboolean
+activate_session_id_for_systemd (GdmManager   *manager,
+                                 const char *seat_id,
+                                 const char *session_id)
+{
         GError *error = NULL;
         GVariant *reply;
 
@@@@ -322,16 +499,75 @@@@ activate_session_id (GdmManager *manager,
 
         return TRUE;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
-session_unlock (GdmManager *manager,
-                const char *ssid)
+activate_session_id_for_ck (GdmManager *manager,
+                            const char *seat_id,
+                            const char *session_id)
 {
         GError *error = NULL;
         GVariant *reply;
 
-        g_debug ("Unlocking session %s", ssid);
+        reply = g_dbus_connection_call_sync (manager->priv->connection,
+                                             CK_NAME,
+                                             seat_id,
+                                             "org.freedesktop.ConsoleKit.Seat",
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
 
+                /* It is very likely that the "error" just reported is
+                 * that the session is already active.  Unfortunately,
+                 * ConsoleKit doesn't use proper error codes and it
+                 * translates the error message, so we have no real way
+                 * to detect this case...
+                 */
+                return TRUE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+activate_session_id (GdmManager *manager,
+                     const char *seat_id,
+                     const char *session_id)
+{
+
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return activate_session_id_for_systemd (manager, seat_id, session_id);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return activate_session_id_for_ck (manager, seat_id, session_id);
+#else
+        return FALSE;
+#endif
+}
+
+#ifdef WITH_SYSTEMD
+static gboolean
+session_unlock_for_systemd (GdmManager *manager,
+                            const char *ssid)
+{
+        GError *error = NULL;
+        GVariant *reply;
+
         reply = g_dbus_connection_call_sync (manager->priv->connection,
                                              "org.freedesktop.login1",
                                              "/org/freedesktop/login1",
@@@@ -354,7 +590,60 @@@@ session_unlock (GdmManager *manager,
 
         return TRUE;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
+static gboolean
+session_unlock_for_ck (GdmManager *manager,
+                       const char *ssid)
+{
+        GError *error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (manager->priv->connection,
+                                             CK_NAME,
+                                             ssid,
+                                             CK_SESSION_INTERFACE,
+                                             "Unlock",
+                                             NULL, /* parameters */
+                                             NULL, /* expected reply */
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             &error);
+        if (reply == NULL) {
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
+                         g_dbus_error_get_remote_error (error), error->message);
+                g_error_free (error);
+                return FALSE;
+        }
+
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+#endif
+
+static gboolean
+session_unlock (GdmManager *manager,
+                const char *ssid)
+{
+
+        g_debug ("Unlocking session %s", ssid);
+
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return session_unlock_for_systemd (manager, ssid);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return session_unlock_for_ck (manager, ssid);
+#else
+        return TRUE;
+#endif
+}
+
 static GdmSession *
 find_session_for_user_on_seat (GdmManager *manager,
                                const char *username,
@@@@ -385,11 +674,44 @@@@ find_session_for_user_on_seat (GdmManager *manager,
         return NULL;
 }
 
+#ifdef WITH_CONSOLE_KIT
 static gboolean
-is_remote_session (GdmManager  *self,
-                   const char  *session_id,
-                   GError     **error)
+is_consolekit_remote_session (GdmManager       *self,
+                             GDBusConnection  *connection,
+                             const char       *session_id,
+                             GError          **error)
 {
+        GVariant *reply;
+        gboolean is_remote;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "IsLocal",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(b)", &is_remote);
+        g_variant_unref (reply);
+
+        return is_remote;
+}
+#endif
+
+#ifdef WITH_SYSTEMD
+static gboolean
+is_systemd_remote_session (GdmManager  *self,
+                           const char  *session_id,
+                           GError     **error)
+{
         char *seat;
         int ret;
         gboolean is_remote;
@@@@ -414,10 +736,31 @@@@ is_remote_session (GdmManager  *self,
 
         return is_remote;
 }
+#endif
 
+static gboolean
+is_remote_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return is_systemd_remote_session (self, session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return is_consolekit_remote_session (self, connection, session_id, error);
+#endif
+
+        return FALSE;
+}
+
+#ifdef WITH_SYSTEMD
 static char *
-get_seat_id_for_session_id (const char  *session_id,
-                            GError     **error)
+get_seat_id_for_systemd_session_id (const char  *session_id,
+                                    GError     **error)
 {
         int ret;
         char *seat, *out_seat;
@@@@ -442,11 +785,62 @@@@ get_seat_id_for_session_id (const char  *session_id,
 
         return out_seat;
 }
+#endif
 
+#ifdef WITH_CONSOLE_KIT
 static char *
-get_tty_for_session_id (const char  *session_id,
-                        GError     **error)
+get_seat_id_for_consolekit_session_id (GDBusConnection  *connection,
+                                       const char       *session_id,
+                                       GError          **error)
 {
+        GVariant *reply;
+        char *retval;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSeatId",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return NULL;
+        }
+
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
+}
+#endif
+
+static char *
+get_seat_id_for_session_id (GDBusConnection  *connection,
+                            const char       *session_id,
+                            GError          **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_seat_id_for_systemd_session_id (session_id, error);
+        }
+#endif
+
+#ifdef WITH_CONSOLE_KIT
+        return get_seat_id_for_consolekit_session_id (connection, session_id, error);
+#endif
+
+        return NULL;
+}
+
+#ifdef WITH_SYSTEMD
+static char *
+get_tty_for_systemd_session_id (const char  *session_id,
+                                GError     **error)
+{
         int ret;
         char *tty, *out_tty;
 
@@@@ -469,7 +863,21 @@@@ get_tty_for_session_id (const char  *session_id,
 
         return out_tty;
 }
+#endif
 
+static char *
+get_tty_for_session_id (const char  *session_id,
+                        GError     **error)
+{
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                return get_tty_for_systemd_session_id (session_id, error);
+        }
+#endif
+
+        return NULL;
+}
+
 static void
 get_display_and_details_for_bus_sender (GdmManager       *self,
                                         GDBusConnection  *connection,
@@@@ -512,7 +920,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
                 goto out;
         }
 
-        session_id = get_session_id_for_pid (pid, &error);
+        session_id = get_session_id_for_pid (connection, pid, &error);
 
         if (session_id == NULL) {
                 g_debug ("GdmManager: Error while retrieving session id for sender: %s",
@@@@ -526,7 +934,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_is_login_screen != NULL) {
-                *out_is_login_screen = is_login_session (self, session_id, &error);
+                *out_is_login_screen = is_login_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while checking if sender is login screen: %s",
@@@@ -536,7 +944,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
                 }
         }
 
-        if (!get_uid_for_session_id (session_id, &session_uid, &error)) {
+        if (!get_uid_for_session_id (connection, session_id, &session_uid, &error)) {
                 g_debug ("GdmManager: Error while retrieving uid for session: %s",
                          error->message);
                 g_error_free (error);
@@@@ -553,7 +961,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_seat_id != NULL) {
-                *out_seat_id = get_seat_id_for_session_id (session_id, &error);
+                *out_seat_id = get_seat_id_for_session_id (connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving seat id for session: %s",
@@@@ -563,7 +971,7 @@@@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_is_remote != NULL) {
-                *out_is_remote = is_remote_session (self, session_id, &error);
+                *out_is_remote = is_remote_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving remoteness for session: %s",
@@@@ -931,7 +1339,8 @@@@ on_reauthentication_client_rejected (GdmSession       
                  * same audit session, ignore it since it doesn't "own" the
                  * reauthentication session
                  */
-                client_session_id = get_session_id_for_pid (pid_of_client,
+                client_session_id = get_session_id_for_pid (self->priv->connection,
+                                                            pid_of_client,
                                                             NULL);
                 session_id = g_object_get_data (G_OBJECT (session), "caller-session-id");
 
@@@@ -1143,16 +1552,20 @@@@ static gboolean
 display_is_on_seat0 (GdmDisplay *display)
 {
         gboolean is_on_seat0 = TRUE;
-        char *seat_id = NULL;
 
-        g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                char *seat_id = NULL;
 
-        if (g_strcmp0 (seat_id, "seat0") != 0) {
-            is_on_seat0 = FALSE;
-        }
+                g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
 
-        g_free (seat_id);
+                if (g_strcmp0 (seat_id, "seat0") != 0) {
+                        is_on_seat0 = FALSE;
+                }
 
+                g_free (seat_id);
+        }
+#endif
         return is_on_seat0;
 }
 
@@@@ -1770,11 +2183,57 @@@@ on_user_session_died (GdmSession *session,
 }
 
 static char *
+query_ck_for_display_device (GdmManager *manager,
+                             GdmDisplay *display)
+{
+        char    *out;
+        char    *command;
+        char    *display_name = NULL;
+        int      status;
+        gboolean res;
+        GError  *error;
+
+        g_object_get (G_OBJECT (display),
+                      "x11-display-name", &display_name,
+                      NULL);
+
+        error = NULL;
+        command = g_strdup_printf (CONSOLEKIT_DIR "/ck-get-x11-display-device --display %s",
+                                   display_name);
+        g_free (display_name);
+
+        g_debug ("GdmManager: Running helper %s", command);
+        out = NULL;
+        res = g_spawn_command_line_sync (command,
+                                         &out,
+                                         NULL,
+                                         &status,
+                                         &error);
+        if (! res) {
+                g_warning ("GdmManager: Could not run helper %s: %s", command, error->message);
+                g_error_free (error);
+        } else {
+                out = g_strstrip (out);
+                g_debug ("GdmManager: Got tty: '%s'", out);
+        }
+
+        g_free (command);
+
+        return out;
+}
+
+static char *
 get_display_device (GdmManager *manager,
                     GdmDisplay *display)
 {
-        /* systemd finds the display device out on its own based on the display */
-        return NULL;
+#ifdef WITH_SYSTEMD
+        if (LOGIND_RUNNING()) {
+                /* systemd finds the display device out on its own based on the display */
+                return NULL;
+        }
+#endif
+
+        return query_ck_for_display_device (manager, display);
 }
 
 static void
@


1.11
log
@Update to gdm-3.22.2.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.10 2016/04/26 08:25:04 ajacoutot Exp $
d17 2
a18 2
--- daemon/gdm-manager.c.orig	Wed Mar  1 21:58:01 2017
+++ daemon/gdm-manager.c	Fri Mar  3 11:46:46 2017
d635 1
a635 1
@@@@ -929,7 +1337,8 @@@@ on_reauthentication_client_rejected (GdmSession       
d645 1
a645 1
@@@@ -1141,16 +1550,20 @@@@ static gboolean
d672 1
a672 1
@@@@ -1759,11 +2172,57 @@@@ on_user_session_died (GdmSession *session,
@


1.10
log
@Update to gdm-3.20.1.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.9 2015/10/18 13:25:54 ajacoutot Exp $
d17 2
a18 2
--- daemon/gdm-manager.c.orig	Tue Apr 19 07:00:04 2016
+++ daemon/gdm-manager.c	Tue Apr 26 10:02:48 2016
d635 1
a635 1
@@@@ -927,7 +1335,8 @@@@ on_reauthentication_client_rejected (GdmSession       
d645 1
a645 1
@@@@ -1139,16 +1548,20 @@@@ static gboolean
d672 1
a672 1
@@@@ -1785,11 +2198,57 @@@@ on_user_session_died (GdmSession *session,
@


1.9
log
@Update to gdm-3.18.0.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.8 2015/04/15 07:25:46 ajacoutot Exp $
d17 2
a18 2
--- daemon/gdm-manager.c.orig	Sun Oct 18 14:26:34 2015
+++ daemon/gdm-manager.c	Sun Oct 18 14:34:21 2015
d672 1
a672 1
@@@@ -1749,11 +2162,57 @@@@ on_user_session_died (GdmSession *session,
@


1.8
log
@Update to gdm-3.16.1.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.7 2015/04/11 15:32:07 ajacoutot Exp $
d5 27
a31 5
--- daemon/gdm-manager.c.orig	Fri Apr 10 21:54:41 2015
+++ daemon/gdm-manager.c	Fri Apr 10 21:54:54 2015
@@@@ -68,7 +68,7 @@@@
 #define CK_SEAT_INTERFACE    "org.freedesktop.ConsoleKit.Seat"
 #define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
d36 9
d47 685
@


1.7
log
@Committed upstream.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.6 2015/04/10 20:43:51 ajacoutot Exp $
a4 5
From 172534d4a803d7905c10a76dc7bd6652cebc5f81 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@@redhat.com>
Date: Tue, 7 Apr 2015 10:57:36 -0400
Subject: manager: properly query display number when built without plymouth

a15 13
@@@@ -1705,10 +1705,11 @@@@ on_display_status_changed (GdmDisplay *display,
 
         g_object_get (display,
                       "is-local", &display_is_local,
-                      "x11-display-number", &display_number,
                       NULL);
         quit_plymouth = display_is_local && manager->priv->plymouth_is_running;
 #endif
+
+        g_object_get (display, "x11-display-number", &display_number, NULL);
 
         status = gdm_display_get_status (display);
 
@


1.6
log
@Ensure X11 display device is propagated to launch environment so that
ConsoleKit works (upstream).
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.5 2015/04/03 18:39:06 ajacoutot Exp $
d5 4
a8 1
https://bugzilla.gnome.org/show_bug.cgi?id=747351
@


1.5
log
@Update to gdm-3.16.0.1.
@
text
@d1 1
a1 1
$OpenBSD$
d5 4
a8 2
--- daemon/gdm-manager.c.orig	Fri Apr  3 20:28:07 2015
+++ daemon/gdm-manager.c	Fri Apr  3 20:28:15 2015
d18 13
@


1.4
log
@Update to gdm-3.12.1.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.3 2014/03/27 19:19:17 ajacoutot Exp $
d3 1
a3 4
From 1d76114a001c5c4eeba17fc9a455e3a132fc23c5 Mon Sep 17 00:00:00 2001
From: Ryan Lortie <desrt@@desrt.ca>
Date: Wed, 26 Mar 2014 04:33:58 +0000
Subject: ConsoleKit: a pair of tweaks
d5 5
a9 16
--- daemon/gdm-manager.c.orig	Fri Mar 21 17:56:39 2014
+++ daemon/gdm-manager.c	Thu Mar 27 18:27:58 2014
@@@@ -430,7 +430,14 @@@@ activate_session_id_for_ck (GdmManager *manager,
                 g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
                          g_dbus_error_get_remote_error (error), error->message);
                 g_error_free (error);
-                return FALSE;
+
+                /* It is very likely that the "error" just reported is
+                 * that the session is already active.  Unfortunately,
+                 * ConsoleKit doesn't use proper error codes and it
+                 * translates the error message, so we have no real way
+                 * to detect this case...
+                 */
+                return TRUE;
         }
d11 5
a15 1
         g_variant_unref (reply);
@


1.3
log
@Update to gdm-3.12.0.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@Update to gdm-3.8.3.
@
text
@d1 1
a1 1
$OpenBSD: patch-daemon_gdm-manager_c,v 1.1 2013/05/17 14:55:58 ajacoutot Exp $
d3 4
a6 4
From c08e9a6a16b2fa953c6ee90b2a6adb618cba5942 Mon Sep 17 00:00:00 2001
From: Colin Walters <walters@@verbum.org>
Date: Fri, 17 May 2013 13:37:39 +0000
Subject: manager: Don't attempt to unexport DBus object if connection is closed
d8 16
a23 10
--- daemon/gdm-manager.c.orig	Mon Apr 15 23:02:31 2013
+++ daemon/gdm-manager.c	Fri May 17 16:40:22 2013
@@@@ -1135,7 +1135,8 @@@@ unexport_display (const char *id,
                   GdmDisplay *display,
                   GdmManager *manager)
 {
-    g_dbus_object_manager_server_unexport (manager->priv->object_manager, id);
+        if (!g_dbus_connection_is_closed (manager->priv->connection))
+                g_dbus_object_manager_server_unexport (manager->priv->object_manager, id);
 }
d25 1
a25 1
 static void
@


1.1
log
@Fix a crash on logout (from upstream).
@
text
@d1 1
a1 1
$OpenBSD$
@

