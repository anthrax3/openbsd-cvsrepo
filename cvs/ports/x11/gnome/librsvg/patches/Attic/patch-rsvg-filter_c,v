head	1.1;
access;
symbols
	OPENBSD_6_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2011.09.07.07.32.18;	author jasper;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2011.09.07.07.32.18;	author jasper;	state Exp;
branches;
next	;

1.1.4.1
date	2017.07.20.07.34.57;	author ajacoutot;	state Exp;
branches;
next	;
commitid	jgo6wm81ZqqkpoXD;


desc
@@


1.1
log
@file patch-rsvg-filter_c was initially added on branch OPENBSD_5_0.
@
text
@@


1.1.4.1
log
@Merge upstream fixes for:
CVE-2017-11464 - Fix division-by-zero in the Gaussian blur code.
@
text
@a0 96
$OpenBSD$

From 735bd813d7657f24dba222fa6e5be8f66491ef77 Mon Sep 17 00:00:00 2001
From: Federico Mena Quintero <federico@@gnome.org>
Date: Tue, 27 Jun 2017 17:12:51 -0500
Subject: bgo#783835 - Don't divide by zero in box_blur_line() for gaussian blurs

From 4c23831871b1bbb2fe569f70f813e2f703ea4eb3 Mon Sep 17 00:00:00 2001
From: Federico Mena Quintero <federico@@gnome.org>
Date: Thu, 6 Jul 2017 13:02:03 -0500
Subject: feTile: don't divide by zero if the input surface has empty bounds

Index: rsvg-filter.c
--- rsvg-filter.c.orig
+++ rsvg-filter.c
@@@@ -1331,8 +1331,10 @@@@ box_blur_line (gint box_width, gint even_offset,
                       kernel; it's the pixel to remove from the accumulator. */
     gint  *ac;     /* Accumulator for each channel                           */
 
-    ac = g_new (gint, bpp);
+    g_assert (box_width > 0);
 
+    ac = g_new0 (gint, bpp);
+
     /* The algorithm differs for even and odd-sized kernels.
      * With the output at the center,
      * If odd, the kernel might look like this: 0011100
@@@@ -1688,7 +1690,6 @@@@ gaussian_blur_surface (cairo_surface_t *in,
                        gdouble sx,
                        gdouble sy)
 {
-    gboolean use_box_blur;
     gint width, height;
     cairo_format_t in_format, out_format;
     gint in_stride;
@@@@ -1732,14 +1733,6 @@@@ gaussian_blur_surface (cairo_surface_t *in,
     if (sy < 0.0)
         sy = 0.0;
 
-    /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with
-     * clever offsets.
-     */
-    if (sx < 10.0 && sy < 10.0)
-        use_box_blur = FALSE;
-    else
-        use_box_blur = TRUE;
-
     /* Bail out by just copying? */
     if ((sx == 0.0 && sy == 0.0)
         || sx > 1000 || sy > 1000) {
@@@@ -1759,7 +1752,16 @@@@ gaussian_blur_surface (cairo_surface_t *in,
         int y;
         guchar *row_buffer = NULL;
         guchar *row1, *row2;
+        gboolean use_box_blur;
 
+        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with
+         * clever offsets.
+         */
+        if (sx < 10.0)
+            use_box_blur = FALSE;
+        else
+            use_box_blur = TRUE;
+
         if (use_box_blur) {
             box_width = compute_box_blur_width (sx);
 
@@@@ -1814,7 +1816,16 @@@@ gaussian_blur_surface (cairo_surface_t *in,
         guchar *col_buffer;
         guchar *col1, *col2;
         int x;
+        gboolean use_box_blur;
 
+        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with
+         * clever offsets.
+         */
+        if (sy < 10.0)
+            use_box_blur = FALSE;
+        else
+            use_box_blur = TRUE;
+
         /* twice the size so we can have the source pixels and the blurred pixels */
         col_buffer = g_new (guchar, height * bpp * 2);
         col1 = col_buffer;
@@@@ -4854,6 +4865,11 @@@@ rsvg_filter_primitive_tile_render (RsvgFilterPrimitive
     input = rsvg_filter_get_result (self->in, ctx);
     in = input.surface;
     boundarys = input.bounds;
+
+    if ((boundarys.x0 >= boundarys.x1) || (boundarys.y0 >= boundarys.y1)) {
+        cairo_surface_destroy (in);
+        return;
+    }
 
     cairo_surface_flush (in);
 
@


1.1.2.1
log
@- apply security fix for CVE-2011-3146, from upstream git
@
text
@a0 306
$OpenBSD$

From 34c95743ca692ea0e44778e41a7c0a129363de84 Mon Sep 17 00:00:00 2001
From: Christian Persch <chpe@@gnome.org>
Date: Thu, 01 Sep 2011 19:35:38 +0000
Subject: Store node type separately in RsvgNode

The node name (formerly RsvgNode:type) cannot be used to infer
the sub-type of RsvgNode that we're dealing with, since for unknown
elements we put type = node-name. This lead to a (potentially exploitable)
crash e.g. when the element name started with "fe" which tricked
the old code into considering it as a RsvgFilterPrimitive.

CVE-2011-3146

https://bugzilla.gnome.org/show_bug.cgi?id=658014

--- rsvg-filter.c.orig	Sun May 30 23:21:34 2010
+++ rsvg-filter.c	Wed Sep  7 09:29:58 2011
@@@@ -495,7 +495,7 @@@@ rsvg_filter_render (RsvgFilter * self, GdkPixbuf * sou
 
     for (i = 0; i < self->super.children->len; i++) {
         current = g_ptr_array_index (self->super.children, i);
-        if (!strncmp (current->super.type->str, "fe", 2))
+        if (RSVG_NODE_IS_FILTER_PRIMITIVE (&current->super))
             rsvg_filter_primitive_render (current, ctx);
     }
 
@@@@ -703,7 +703,7 @@@@ rsvg_filter_parse (const RsvgDefs * defs, const char *
         val = rsvg_defs_lookup (defs, name);
         g_free (name);
 
-        if (val && (!strcmp (val->type->str, "filter")))
+        if (val && RSVG_NODE_TYPE (val) == RSVG_NODE_TYPE_FILTER)
             return (RsvgFilter *) val;
     }
     return NULL;
@@@@ -754,7 +754,7 @@@@ rsvg_new_filter (void)
     RsvgFilter *filter;
 
     filter = g_new (RsvgFilter, 1);
-    _rsvg_node_init (&filter->super);
+    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_FILTER);
     filter->filterunits = objectBoundingBox;
     filter->primitiveunits = userSpaceOnUse;
     filter->x = _rsvg_css_parse_length ("-10%");
@@@@ -978,7 +978,7 @@@@ rsvg_new_filter_primitive_blend (void)
 {
     RsvgFilterPrimitiveBlend *filter;
     filter = g_new (RsvgFilterPrimitiveBlend, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_BLEND);
     filter->mode = normal;
     filter->super.in = g_string_new ("none");
     filter->in2 = g_string_new ("none");
@@@@ -1230,7 +1230,7 @@@@ rsvg_new_filter_primitive_convolve_matrix (void)
 {
     RsvgFilterPrimitiveConvolveMatrix *filter;
     filter = g_new (RsvgFilterPrimitiveConvolveMatrix, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_CONVOLVE_MATRIX);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -1471,7 +1471,7 @@@@ rsvg_new_filter_primitive_gaussian_blur (void)
 {
     RsvgFilterPrimitiveGaussianBlur *filter;
     filter = g_new (RsvgFilterPrimitiveGaussianBlur, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_GAUSSIAN_BLUR);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -1607,7 +1607,7 @@@@ rsvg_new_filter_primitive_offset (void)
 {
     RsvgFilterPrimitiveOffset *filter;
     filter = g_new (RsvgFilterPrimitiveOffset, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_OFFSET);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -1648,7 +1648,7 @@@@ rsvg_filter_primitive_merge_render (RsvgFilterPrimitiv
     for (i = 0; i < upself->super.super.children->len; i++) {
         RsvgFilterPrimitive *mn;
         mn = g_ptr_array_index (upself->super.super.children, i);
-        if (strcmp (mn->super.type->str, "feMergeNode"))
+        if (RSVG_NODE_TYPE (&mn->super) != RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE_NODE)
             continue;
         in = rsvg_filter_get_in (mn->in, ctx);
         rsvg_alpha_blt (in, boundarys.x0, boundarys.y0, boundarys.x1 - boundarys.x0,
@@@@ -1701,7 +1701,7 @@@@ rsvg_new_filter_primitive_merge (void)
 {
     RsvgFilterPrimitiveMerge *filter;
     filter = g_new (RsvgFilterPrimitiveMerge, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE);
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
         filter->super.height.factor = 'n';
@@@@ -1744,7 +1744,7 @@@@ rsvg_new_filter_primitive_merge_node (void)
 {
     RsvgFilterPrimitive *filter;
     filter = g_new (RsvgFilterPrimitive, 1);
-    _rsvg_node_init (&filter->super);
+    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE_NODE);
     filter->in = g_string_new ("none");
     filter->super.free = rsvg_filter_primitive_merge_node_free;
     filter->render = &rsvg_filter_primitive_merge_node_render;
@@@@ -1978,7 +1978,7 @@@@ rsvg_new_filter_primitive_colour_matrix (void)
 {
     RsvgFilterPrimitiveColourMatrix *filter;
     filter = g_new (RsvgFilterPrimitiveColourMatrix, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_COLOUR_MATRIX);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -2010,8 +2010,9 @@@@ struct _RsvgNodeComponentTransferFunc {
     gint slope;
     gint intercept;
     gint amplitude;
-    gdouble exponent;
     gint offset;
+    gdouble exponent;
+    char channel;
 };
 
 struct _RsvgFilterPrimitiveComponentTransfer {
@@@@ -2107,15 +2108,18 @@@@ rsvg_filter_primitive_component_transfer_render (RsvgF
     for (c = 0; c < 4; c++) {
         char channel = "RGBA"[c];
         for (i = 0; i < self->super.children->len; i++) {
-            RsvgNodeComponentTransferFunc *temp;
-            temp = (RsvgNodeComponentTransferFunc *)
-                g_ptr_array_index (self->super.children, i);
-            if (!strncmp (temp->super.type->str, "feFunc", 6))
-                if (temp->super.type->str[6] == channel) {
+            RsvgNode *child_node;
+
+            child_node = (RsvgNode *) g_ptr_array_index (self->super.children, i);
+            if (RSVG_NODE_TYPE (child_node) == RSVG_NODE_TYPE_FILTER_PRIMITIVE_COMPONENT_TRANSFER) {
+                RsvgNodeComponentTransferFunc *temp = (RsvgNodeComponentTransferFunc *) child_node;
+
+                if (temp->channel == channel) {
                     functions[ctx->channelmap[c]] = temp->function;
                     channels[ctx->channelmap[c]] = temp;
                     break;
                 }
+            }
         }
         if (i == self->super.children->len)
             functions[ctx->channelmap[c]] = identity_component_transfer_func;
@@@@ -2198,7 +2202,7 @@@@ rsvg_new_filter_primitive_component_transfer (void)
     RsvgFilterPrimitiveComponentTransfer *filter;
 
     filter = g_new (RsvgFilterPrimitiveComponentTransfer, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_COMPONENT_TRANSFER);
     filter->super.result = g_string_new ("none");
     filter->super.in = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -2272,7 +2276,7 @@@@ rsvg_new_node_component_transfer_function (char channe
     RsvgNodeComponentTransferFunc *filter;
 
     filter = g_new (RsvgNodeComponentTransferFunc, 1);
-    _rsvg_node_init (&filter->super);
+    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION);
     filter->super.free = rsvg_component_transfer_function_free;
     filter->super.set_atts = rsvg_node_component_transfer_function_set_atts;
     filter->function = identity_component_transfer_func;
@@@@ -2414,7 +2418,7 @@@@ rsvg_new_filter_primitive_erode (void)
 {
     RsvgFilterPrimitiveErode *filter;
     filter = g_new (RsvgFilterPrimitiveErode, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_ERODE);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -2639,7 +2643,7 @@@@ rsvg_new_filter_primitive_composite (void)
 {
     RsvgFilterPrimitiveComposite *filter;
     filter = g_new (RsvgFilterPrimitiveComposite, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_COMPOSITE);
     filter->mode = COMPOSITE_MODE_OVER;
     filter->super.in = g_string_new ("none");
     filter->in2 = g_string_new ("none");
@@@@ -2744,7 +2748,7 @@@@ rsvg_new_filter_primitive_flood (void)
 {
     RsvgFilterPrimitive *filter;
     filter = g_new (RsvgFilterPrimitive, 1);
-    _rsvg_node_init (&filter->super);
+    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_FLOOD);
     filter->in = g_string_new ("none");
     filter->result = g_string_new ("none");
     filter->x.factor = filter->y.factor = filter->width.factor = filter->height.factor = 'n';
@@@@ -2920,7 +2924,7 @@@@ rsvg_new_filter_primitive_displacement_map (void)
 {
     RsvgFilterPrimitiveDisplacementMap *filter;
     filter = g_new (RsvgFilterPrimitiveDisplacementMap, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_DISPLACEMENT_MAP);
     filter->super.in = g_string_new ("none");
     filter->in2 = g_string_new ("none");
     filter->super.result = g_string_new ("none");
@@@@ -3291,7 +3295,7 @@@@ rsvg_new_filter_primitive_turbulence (void)
 {
     RsvgFilterPrimitiveTurbulence *filter;
     filter = g_new (RsvgFilterPrimitiveTurbulence, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_TURBULENCE);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -3510,7 +3514,7 @@@@ rsvg_new_filter_primitive_image (void)
 {
     RsvgFilterPrimitiveImage *filter;
     filter = g_new (RsvgFilterPrimitiveImage, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_IMAGE);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -3871,8 +3875,8 @@@@ get_light_colour (RsvgNodeLightSource * source, vector
 
 
 static void
-rsvg_filter_primitive_light_source_set_atts (RsvgNode * self,
-                                             RsvgHandle * ctx, RsvgPropertyBag * atts)
+rsvg_node_light_source_set_atts (RsvgNode * self,
+                                 RsvgHandle * ctx, RsvgPropertyBag * atts)
 {
     RsvgNodeLightSource *data;
     const char *value;
@@@@ -3904,13 +3908,13 @@@@ rsvg_filter_primitive_light_source_set_atts (RsvgNode 
 }
 
 RsvgNode *
-rsvg_new_filter_primitive_light_source (char type)
+rsvg_new_node_light_source (char type)
 {
     RsvgNodeLightSource *data;
     data = g_new (RsvgNodeLightSource, 1);
-    _rsvg_node_init (&data->super);
+    _rsvg_node_init (&data->super, RSVG_NODE_TYPE_LIGHT_SOURCE);
     data->super.free = _rsvg_node_free;
-    data->super.set_atts = rsvg_filter_primitive_light_source_set_atts;
+    data->super.set_atts = rsvg_node_light_source_set_atts;
     data->specularExponent = 1;
     if (type == 's')
         data->type = SPOTLIGHT;
@@@@ -3960,10 +3964,11 @@@@ rsvg_filter_primitive_diffuse_lighting_render (RsvgFil
 
     for (i = 0; i < self->super.children->len; i++) {
         RsvgNode *temp;
+
         temp = g_ptr_array_index (self->super.children, i);
-        if (!strcmp (temp->type->str, "feDistantLight") ||
-            !strcmp (temp->type->str, "fePointLight") || !strcmp (temp->type->str, "feSpotLight"))
+        if (RSVG_NODE_TYPE (temp) == RSVG_NODE_TYPE_LIGHT_SOURCE) {
             source = (RsvgNodeLightSource *) temp;
+        }
     }
     if (source == NULL)
         return;
@@@@ -4080,7 +4085,7 @@@@ rsvg_new_filter_primitive_diffuse_lighting (void)
 {
     RsvgFilterPrimitiveDiffuseLighting *filter;
     filter = g_new (RsvgFilterPrimitiveDiffuseLighting, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_DIFFUSE_LIGHTING);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -4135,9 +4140,9 @@@@ rsvg_filter_primitive_specular_lighting_render (RsvgFi
     for (i = 0; i < self->super.children->len; i++) {
         RsvgNode *temp;
         temp = g_ptr_array_index (self->super.children, i);
-        if (!strcmp (temp->type->str, "feDistantLight") ||
-            !strcmp (temp->type->str, "fePointLight") || !strcmp (temp->type->str, "feSpotLight"))
+        if (RSVG_NODE_TYPE (temp) == RSVG_NODE_TYPE_LIGHT_SOURCE) {
             source = (RsvgNodeLightSource *) temp;
+        }
     }
     if (source == NULL)
         return;
@@@@ -4259,7 +4264,7 @@@@ rsvg_new_filter_primitive_specular_lighting (void)
 {
     RsvgFilterPrimitiveSpecularLighting *filter;
     filter = g_new (RsvgFilterPrimitiveSpecularLighting, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_SPECULAR_LIGHTING);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@@@@ -4381,7 +4386,7 @@@@ rsvg_new_filter_primitive_tile (void)
 {
     RsvgFilterPrimitiveTile *filter;
     filter = g_new (RsvgFilterPrimitiveTile, 1);
-    _rsvg_node_init (&filter->super.super);
+    _rsvg_node_init (&filter->super.super, RSVG_NODE_TYPE_FILTER_PRIMITIVE_TILE);
     filter->super.in = g_string_new ("none");
     filter->super.result = g_string_new ("none");
     filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
@

