head	1.38;
access;
symbols;
locks; strict;
comment	@# @;


1.38
date	2014.04.01.17.18.45;	author nick;	state dead;
branches;
next	1.37;

1.37
date	2013.11.01.18.04.05;	author ajacoutot;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.01.17.39.07;	author ajacoutot;	state Exp;
branches;
next	1.35;

1.35
date	2013.05.01.14.42.15;	author ajacoutot;	state Exp;
branches;
next	1.34;

1.34
date	2012.11.02.07.24.05;	author ajacoutot;	state Exp;
branches;
next	1.33;

1.33
date	2012.05.13.16.30.18;	author ajacoutot;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.21.19.34.39;	author ajacoutot;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.07.07.32.54;	author ajacoutot;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.04.19.07.52;	author tobias;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.22.20.35.21;	author tobias;	state Exp;
branches;
next	1.28;

1.28
date	2008.11.01.11.02.22;	author tobias;	state Exp;
branches;
next	1.27;

1.27
date	2008.08.10.16.14.28;	author tobias;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.09.13.37.13;	author tobias;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.12.20.29.59;	author saad;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.23.18.29.30;	author jufi;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.10.12.43.46;	author saad;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.26.03.08.06;	author jufi;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.10.05.22.16;	author saad;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.01.11.30.45;	author jufi;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.08.07.14.20;	author saad;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.01.12.19.18;	author jufi;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.25.08.25.49;	author saad;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.06.17.23.11;	author jufi;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.29.15.13.39;	author saad;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.04.20.24.24;	author jufi;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.20.07.30.02;	author saad;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.05.22.09.39;	author saad;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.22.17.38.08;	author saad;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.20.17.13.26;	author jufi;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.19.18.23.06;	author jufi;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.04.17.52.25;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.28.20.30.24;	author saad;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.08.13.59.02;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.18.17.18.10;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.03.19.49.57;	author jufi;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.22.20.00.48;	author jufi;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.08.05.22.44;	author saad;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.27.19.39.09;	author horacio;	state Exp;
branches;
next	;


desc
@@


1.38
log
@
missed another one...
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Paket-Queueing und Priorisierung</title>
<link rev="made" href="mailto:www@@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2005 Joel Knight <enabled@@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="anchors.html">Zurück: Anker</a>]
[<a href="index.html">Inhalt</a>]
[<a href="pools.html">Weiter: Adress-Pools und Load Balancing</a>]

<p>
<h1><font color="#e00000">PF: Paket-Queueing und Priorisierung</font></h1>


<hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#queueing">Queueing</a>
<li><a href="#sched">Schedulers</a>
	<ul>
	<li><a href="#cbq">Class Based Queueing</a>
	<li><a href="#priq">Priority Queueing</a>
	<li><a href="#red">Random Early Detection</a>
	<li><a href="#ecn">Explicit Congestion Notification</a>
	</ul>
<li><a href="#altq">Queueing konfigurieren</a>
<li><a href="#assign">Verkehr einer Queue zuweisen</a>
<li><a href="#example1">Beispiel #1: kleines, Heim-Netzwerk</a>
<li><a href="#example2">Beispiel #2: Firmen-Netzwerk</a>
</ul>

<hr>

<a name="queueing"></a>
<h2>Queueing</h2>
<p>
Etwas einzureihen heißt, es in Reihe aufzubewahren, während es darauf
wartet, verarbeitet zu werden. Wenn Daten-Pakete in einem Computer-Netzwerk
von einem Host ausgesendet werden, treten sie eine Warteschlange ein, wo
sie darauf warten, vom Betriebssystem verarbeitet zu werden. Das
Betriebssystem entscheidet dann, welche Warteschlange und welche(e)
Paket(e) von der Warteschlange verarbeitet werden sollten. Die Reihenfolge,
in der das Betriebssystem die zu verarbeitenden Pakete auswählt, kann
die Leistung vom Netzwerk beeinflussen. Stell dir zum Beispiel vor, ein
Benutzer lässt zwei Netzwerk-Anwendungen laufen: SSH und FTP. Idealerweise
sollten die SSH-Pakete vor den FTP-Paketen wegen der Zeit-sensiblen
Natur von SSH verarbeitet werden; wenn eine Taste im SSH-Client gedrückt
wird, wird eine unverzügliche Antwort erwartet, aber wenn eine
FTP-Übertragung um ein paar Sekunden verzögert wird, wird es wohl kaum
auffallen. Aber was passiert, wenn der Router, der diese Verbindungen
handhabt, eine große Portion an Paketen von der FTP-Verbindung
verarbeitet, bevor die SSH-Verbindung verarbeitet wird? Pakete von
der SSH-Verbindung werden in der Warteschlange verweilen
(oder vielleicht sogar vom Router fallengelassen, wenn die
Warteschlange nicht groß genug ist, um alle Pakete zu beinhalten)
und die SSH-Sitzung wirkt, als wenn sie ,laggt' oder verlangsamt
ist. Durch das Modifizieren der Warteschlangen-Strategie, die
verwendet wird, kann Netzwerk-Bandbreite gerecht zwischen unterschiedlichen
Applikationen, Benutzern und Computern aufgeteilt werden.

<p>
Bedenke, dass das Einreihen nur nützlich für Pakete in die
<i>ausgehende</i> Richtung ist. Sobald ein Paket auf dem Interface
in einer eingehenden Richtung ankommt, ist es bereits zu spät, dieses
einzureihen - es hat bereits Netzwerk-Bandbreite verbraucht, um
auf dem Interface anzukommen, das es aufgenommen hat. Die einzige
Lösung ist, das Einreihen auf dem angrenzenden Router zu aktivieren
oder, wenn der Host, der das Paket erhalten hat, als Router fungiert,
das Einreihen auf dem internen Interface zu aktiveren, von dem
Pakete den Router verlassen.

<a name="sched"></a>
<h2>Schedulers</h2>
Der ,scheduler' ist, wer entscheidet, welche Warteschlange verarbeitet
werden soll und in welcher Reihenfolge. Standardmäßig verwendet OpenBSD
einen ,First In First Out'- (FIFO) ,scheduler'. Eine FIFO-Warteschlange
funktioniert wie das Anreihen an einer Kasse in einem Supermarkt
- das erste Objekt in der Schlange wird zuerst verarbeitet. Wenn
neue Pakete ankommen, werden sie an das Ende der Warteschlange angehängt.
Wenn die Warteschlange voll wird, und hier endet die Analogie mit dem
Supermarkt, werden neu ankommende Pakete fallen gelassen. Dies ist bekannt
als ,tail-drop'.

<p>
OpenBSD unterstützt zwei zusätzliche ,scheduler':
<ul>
<li>Class Based Queueing
<li>Priority Queueing
</ul>

<a name="cbq"></a>
<h3>Class Based Queueing</h3>
,Class Based Queueing' (CBQ) ist ein Einreihe-Algorithmus, der die
Bandbreite einer Netzwerkverbindung auf mehrere Warteschlangen oder
Klassen aufteilt. Jeder Warteschlange wird Verkehr zugewiesen,
basierend auf der Quell- oder Ziel-Adresse, Port-Nummer, Protokoll etc.
Eine Warteschlange kann optional so konfiguriert werden, dass Bandbreite
von seiner Eltern-Warteschlange ausgeliehen wird, wenn diese nicht
voll ausgenutzt wird. Warteschlangen geben außerdem eine Priorität,
sodass jene, die interaktiven Verkehr beinhalten, zum Beispiel SSH,
ihre Pakete vor denen verarbeiten können, die ,bulk'-Verkehr, wie
zum Beispiel FTP, beinhalten.

<p>
CBQ-Warteschlangen werden in einer hierarchischen Manier angeordnet.
An oberster Stelle dieser Hierarchie ist die root-Warteschlange, welche
die Gesamtgröße der verfügbaren Bandbreite angibt. ,Child'-Warteschlangen
werden unter der root-Warteschlange angelegt, der jeder ein Teil der
Bandbreite der root-Warteschlange zugewiesen werden kann. Zum
Beispiel können Warteschlangen wie folgt definiert werden:
<dl>
<dd>Root-Warteschlange (2 Mbps)
	<dl>
	<dd>Warteschlange A (1 Mbps)
	<dd>Warteschlange B (500 Kbps)
	<dd>Warteschlange C (500 Kbps)
	</dl>
</dl>

<p>
In diesem Fall wird die gesamt verfügbare Bandbreite auf 2 Megabits pro
Sekunde (Mbps) gesetzt. Diese Bandbreite wird dann auf drei
,child'-Warteschlangen aufgeteilt.

<p>
Die Hierarchie kann weiter aufgegliedert werden, indem Warteschlangen
in Warteschlangen definiert werden. Um die Bandbreite auf mehrere
verschiedene Benutzer gleich aufzuteilen und ebenfalls ihren Verkehr
zu klassifizieren, sodass bestimmte Protokolle anderen nicht
Bandbreite wegnehmen, kann eine Warteschlangen-Struktur wie diese
definiert werden:
<dl>
<dd>Root-Warteschlange (2 Mbps)
	<dl>
	<dd>BenutzerA (1 Mbps)
		<dl>
		<dd>ssh (50 Kbps)
		<dd>bulk (950 Kbps)
		</dl>
	<dd>BenutzerB (1 Mbps)
		<dl>
		<dd>audio (250 Kbps)
		<dd>bulk (750 Kbps)
			<dl>
			<dd>http (100 Kbps)
			<dd>andere (650 Kbps)
			</dl>
		</dl>
	</dl>
</dl>

<p>
Bedenke, dass die Summe der Bandbreite für jedes Level nicht höher ist,
als was der Eltern-Warteschlange zugewiesen wurde.

<p>
Eine Warteschlange kann konfiguriert werden, um Bandbreite von seinen
Eltern zu leihen, wenn die Eltern genügend Bandbreite zur Verfügung
haben, wenn die ,child'-Warteschlangen diesen nicht verwenden.
Siehe dir eine Warteschlangen-Einrichtung wie die folgende an:
<dl>
<dd>Root-Warteschlange (2 Mbps)
	<dl>
	<dd>BenutzerA (1 Mbps)
		<dl>
		<dd>ssh (100 Kbps)
		<dd>ftp (900 Kbps, leihen)
		</dl>
	<dd>BenutzerB (1 Mbps)
	</dl>
</dl>

<p>
Wenn Verkehr in der <tt>ftp</tt>-Warteschlange größer ist als 900 Kbps
und Verkehr in der <tt>BenutzerA</tt>-Queue kleiner ist als 1 Mbps
(weil die <tt>ssh</tt>-Warteschlange weniger als die zugewiesenen 100 Kbps
verwendet), wird sich die <tt>ftp</tt>-Warteschlange die zusätzliche
Bandbreite von <tt>BenutzerA</tt> ausleihen. Auf diesem Weg ist die
<tt>ftp</tt>-Warteschlange in der Lage, mehr Bandbreite zu nutzen,
als ihr zugewiesen wurde, wenn eine Überladung stattfindet.
Wenn die <tt>ssh</tt>-Warteschlange nun ihre Last erhöht, wird die
geliehene Bandbreite zurückgegeben.

<p>
CBQ weist jeder Warteschlange ein Prioritäts-Level zu. Warteschlangen
mit einer höheren Priorität werden während der Anhäufung gegenüber
den Warteschlangen mit einer geringen Priorität bevorzugt, so lange
beide Warteschlangen die gleichen Eltern-Warteschlange haben
(mit anderen Worten, so lange beide Warteschlangen im gleichen Zweig
der Hierarchie sind). Warteschlangen mit der gleichen Priorität werden
in einer ,round-robin'-Manier verarbeitet. Zum Beispiel:
<dl>
<dd>Root-Warteschlange (2 Mbps)
	<dl>
	<dd>BenutzerA (1 Mbps, Priorität 1)
		<dl>
		<dd>ssh (100 Kbps, Priorität 5)
		<dd>ftp (900 Kbps, Priorität 3)
		</dl>
	<dd>BenutzerB (1 Mbps, Priorität 1)
	</dl>
</dl>

<p>
CBQ wird die <tt>BenutzerA</tt>- und <tt>BenutzerB</tt>-Warteschlangen
in einer ,round-robin'-Manier verarbeiten - keine Warteschlange wird
der anderen bevorzugt. Während der Zeit, in der die
<tt>BenutzerA</tt>-Warteschlange verarbeitet wird, wird CBQ ebenfalls
die ,child'-Warteschlangen verarbeiten. In diesem Fall hat die
<tt>ssh</tt>-Warteschlange eine höhere Priorität und wird gegenüber
der <tt>ftp</tt>-Warteschlange somit bevorzugt behandelt, wenn das
Netzwerk überladen ist. Bedenke, wie die <tt>ssh</tt>- und
<tt>ftp</tt>-Warteschlangen ihre Prioritäten nicht mit den
<tt>BenutzerA</tt>- und <tt>BenutzerB</tt>-Warteschlangen vergleichen,
weil sie sich nicht auf dem gleichen Ast in der Hierarchie befinden.

<p>
Für eine detaillierte Betrachtung der Theorie hinter CBQ, siehe bitte
<a href="http://www.icir.org/floyd/cbq.html">Reference on CBQ</a>.

<a name="priq"></a>
<h3>Priority Queueing</h3>
,Priority Queuing' (PRIQ) weist mehreren Warteschlangen einem Interface
zu, wobei jeder Warteschlange ein Prioritätslevel gegeben
wird. Eine Warteschlange mit einer höheren Priorität wird <i>immer</i>
vor einer Warteschlange mit einer geringeren Priorität verarbeitet.
Wenn zwei oder noch mehr Schlangen auf gleichem Prioritätenlevel liegen,
dann werden die Schlangen nach und nach abgearbeitet (in der
so genannten Round-Robin-Manier).

<p>
Die Einreihe-Struktur in PRIQ ist flach - du kannst keine Warteschlangen
in Warteschlangen definieren. Die root-Warteschlange, welche die
Gesamtgröße der Bandbreite angibt, wird definiert und Unterwarteschlangen
werden unter root definiert. Betrachte folgendes Beispiel:
<dl>
<dd>Root-Warteschlange (2 Mbps)
	<dl>
	<dd>Warteschlange A (Priorität 1)
	<dd>Warteschlange B (Priorität 2)
	<dd>Warteschlange C (Priorität 3)
	</dl>
</dl>

<p>
Die root-Warteschlange wurde so definiert, dass ihr 2 Mbps der
Bandbreite zur Verfügung stehen und drei Unterwarteschlangen wurden
definiert. Die Warteschlange mit der höchsten Priorität (die höchste
Prioritätennummer) wird zuerst bedient. Sobald alle Pakete in der
Warteschlange verarbeitet wurden, oder wenn festgestellt wird, dass
die Warteschlange leer ist, wird PRIQ zur nächsten Warteschlange
mit der nächst höchsten Priorität gehen. Innerhalb einer gegebenen
Warteschlange werden Pakete in einer ,First in First Out'- (FIFO)
Manier verarbeitet.

<p>
Es ist wichtig, daran zu denken, dass du, wenn PRIQ verwendet wird, deine
Warteschlangen sehr sorgfältig planen musst. Weil PRIQ <i>immer</i>
eine höher priorisierte Warteschlange vor einer niedrigeren verarbeitet,
ist es möglich für eine höher priorisierte Warteschlange, dazu zu führen,
dass Pakete einer niedriger priorisierten Warteschlange verzögert oder
fallen gelassen werden, wenn die höher priorisierte Warteschlange einen
konstanten Fluss an Paketen erhält.

<a name="red"></a>
<h3>Random Early Detection</h3>
,Random Early Detection' (RED) ist ein Anhäufungg-vermeidender Algorithmus.
Seine Aufgabe ist, Netzwerk-Anhäufungen zu vermeiden, indem sichergestellt
wird, dass die Warteschlange nicht voll wird. Er macht das, indem
durchgehend die durchschnittliche Länge (Größe) der Warteschlange
berechnet wird und vergleicht sie mit zwei ,tresholds', einem minimalem
,treshold' und einem maximalen ,treshold'. Wenn die durchschnittliche
Größe unterhalb des minimalem ,treshold' liegt, dann wird kein Paket
fallen gelassen. Wenn der Durchschnitt oberhalb des maximalen ,tresholds'
liegt, dann werden <i>alle</i> neu ankommenden Pakete fallengelassen.
Wenn der Durchschnitt zwischen den ,treshold'-Werten liegt, dann werden
Pakete basierend auf einer errechneten Wahrscheinlichkeit der
durchschnittlichen Warteschlangen-Größe fallengelassen.
Mit anderen Worten, je größer die durchschnittliche Warteschlangen-Größe
wird, umso mehr Pakete werden fallengelassen. Wenn Pakete fallengelassen
werden, wählt RED zufällig, von welchen Verbindungen Pakete fallengelassen
werden sollen.
Verbindungen, die mehr Bandbreite verwenden, haben eine höher Priorität
beim Fallen lassen ihrer Pakete.

<p>
RED ist nützlich, da es eine Situation verhindert, die als globale
Synchronisation bekannt ist, und ist in der Lage, das Anstürmen
von Verkehr in Einklang zu bringen. Globale Synchronisation verweist auf
den Verlust des gesamten Durchsatzes, weil Pakete von vielen Verbindungen
zur gleichen Zeit fallengelassen werden. Wenn zum Beispiel eine Anhäufung
auf einem Router eintritt, der den Verkehr für 10 FTP-Verbindungen trägt
und Pakete von allen (oder fast allen) dieser Verbindungen fallengelassen
werden (wie es der Fall in FIFO-Warteschlangen ist), wird der gesamte
Durchsatz drastisch fallen. Dies ist keine ideale Situation, da es dazu
führt, dass alle FTP-Verbindungen ihren Durchsatz reduzieren und das dann
bedeutet, dass das Netzwerk nicht mehr länger völlig ausgereizt wird. RED
verhindert dies, indem die Verbindung, von der Pakete fallengelassen werden
sollen, zufällig auswählt, statt alle dafür auszuwählen. Verbindungen,
die sehr viel der Bandbreite in Anspruch nehmen, werden wahrscheinlicher
Pakete durch das Fallen lassen genommen. Auf diesem Weg werden
Verbindungen mit hoher Bandbreite gedrosselt, Anhäufung wird verhindert
und das rapide reduzieren des gesamten Durchsatzes wird nicht eintreten.
Zusätzlich ist RED in der Lage, das Anstürmen von Verkehr handzuhaben,
da er beginnt, Pakete fallen zu lassen, <i>bevor</i> die Warteschlange voll
wird. Wenn ein Ansturm an Verkehr durchkommt, wird dort genug
Platz in der Warteschlange sein, um die neuen Pakete zu halten.

<p>
RED sollte nur benutzt werden, wenn das Transport-Protokoll in der
Lage ist, auf Anhäufungs-Anzeichen vom Netzwerk zu antworten. In den
meisten Fällen bedeutet das, dass RED nur in einer Warteschlange für
TCP-Verkehr und nicht für UDP- oder ICMP-Verkehr genutzt werden sollte.

<p>
Für einen detaillierteren Blick auf die Theorie hinter RED, siehe bitte
<a href="http://www.icir.org/floyd/red.html">References on RED</a>.

<a name="ecn"></a>
<h3>Explicit Congestion Notification</h3>
,Explicit Congestion Notification' (ECN) funktioniert in Verbindung mit
RED, um zwei Hosts, die über ein Netzwerk miteinander kommunizieren, über
Anhäufungen auf dem Verbindungsweg zu informieren. Es macht dies, indem
RED aktiviert wird, um ein Flag im Paket-Header zu setzen, statt das Paket
fallen zu lassen. Angenommen, der sendende Host hat Unterstützung für ECN,
dann kann er das Flag lesen und den Netzwerkverkehr dementsprechend
drosseln.

<p>
Für weitere Informationen über ECN, lies bitte
<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">RFC 3168</a>.

<a name="altq"></a>
<h2>Queueing konfigurieren</h2>
Seit OpenBSD 3.0 ist die
<a href="http://www.csl.sony.co.jp/person/kjc/kjc/software.html#ALTQ"
>,Alternate Queueing'- (ALTQ)</a> Implementation Teil des Basis-Systems.
Beginnend mit OpenBSD 3.3 wurde ALTQ in PF integriert. OpenBSDs
ALTQ-Implementation unterstützt ,Class Based Queueing'- (CBQ) und
,Priority Queueing'- (PRIQ) ,schedulers'. Es unterstützt ebenfalls
,Random Early Detection' (RED) und ,Explicit Congestion Notification' (ECN).

<p>
Weil ALTQ mit PF verbunden wurde, muss PF aktiviert werden, damit
,queueing' funktioniert. Anweisungen, wie man PF aktiviert, können in
den <a href="config.html#activate">Ersten Schritten</a> gefunden werden.

<p>
,Queueing' wird in <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+5.4"
>pf.conf</a></tt> konfiguriert. Dort gibt es zwei Arten an
Direktiven, die genutzt werden, um ,queueing' zu konfigurieren.
<ul>
<li><tt>altq on</tt> - aktiviert ,queueing' auf einem Interface, definiert,
welcher ,scheduler' genutzt werden soll und erstellt die root-Warteschlange
<li><tt>queue</tt> - definiert die Eigenschaften einer ,child'-Warteschlange
</ul>

<p>
Die Syntax für die <tt>altq on</tt>-Direktive ist:
<blockquote>
<tt>
altq on <i>interface scheduler</i> bandwidth <i>bw</i> qlimit
<i>qlim</i> \<br>
&nbsp;&nbsp;&nbsp;tbrsize <i>size</i> queue { <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>interface</i></tt> - das Netzwerk-Interface, auf dem ,queueing'
aktiviert werden soll.
<li><tt><i>scheduler</i></tt> - der zu nutzende ,queueing scheduler'.
Mögliche Werte sind:
<tt>cbq</tt> und <tt>priq</tt>. Nur ein ,scheduler' kann auf einem Interface
gleichzeitig aktiv sein.
<li><tt><i>bw</i></tt> - die gesamte Bandbreite, die für den ,scheduler'
verfügbar ist. Dies kann entweder mit absoluten Werten unter Verwendung
der <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt> und <tt>Gb</tt> gemacht werden, die
respektiv Bits, Kilobits, Megabits und Gigabits pro Sekunde darstellen oder
als Prozent der <tt><i>Interface</i></tt>-Bandbreite.
<li><tt><i>qlim</i></tt> - die maximale Anzahl der Pakete, die in der
Warteschlange gehalten werden soll. Dieser Parameter ist optional.
Der Standard ist 50.
<li><tt><i>size</i></tt> - Die Größe des ,token bucket regulator' in Byte.
Wenn nicht angegeben, basiert die Größe auf der
<tt><i>Interface</i></tt>-Bandbreite, die gesetzt ist.
<li><tt><i>queue_list</i></tt> - Eine Liste an ,child'-Warteschlangen, die
unterhalb der root-Warteschlange erstellt werden sollen.
</ul>

<p>
Zum Beispiel:
<blockquote>
<tt>
altq on fxp0 cbq bandwidth 2Mb queue { std, ssh, ftp }
</tt>
</blockquote>
Dies aktiviert CBQ auf dem <tt>fxp0</tt>-Interface. Die gesamte verfügbare
Bandbreite wird auf 2 Mbps gesetzt. Drei ,child'-Warteschlangen werden
definiert: <tt>std</tt>, <tt>ssh</tt> und <tt>ftp</tt>.

<p>
Die Syntax für die <tt>queue</tt>-Direktive ist:
<blockquote>
<tt>
queue <i>name</i> [on <i>interface</i>] bandwidth <i>bw</i> [priority
<i>pri</i>] [qlimit <i>qlim</i>] \<br>
&nbsp;&nbsp;&nbsp;<i>scheduler</i> ( <i>sched_options</i> )
{ <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>name</i></tt> - Der Name der Warteschlange. Dieser muss mit
dem Namen einer der Warteschlange übereinstimmen, die in der
zur <tt>altq on</tt>-Direktive gehörigen <tt><i>queue_list</i></tt>
definiert werden. Für <tt>cbq</tt> kann er ebenfalls mit dem
Namen einer Warteschlange einer vorherigen <tt>queue</tt>-Direktive
(<tt><i>queue_list</i></tt>) übereinstimmen. Warteschlangennamen dürfen
nicht länger als 15 Zeichen sein.
<li><tt><i>interface</i></tt> - Das Netzwerk-Interface, für das die
Warteschlange gültig ist. Dieser Wert ist optional und wenn er nicht
angegeben wird, wird die Warteschlange für alle Interfaces gültig sein.
<li><tt><i>bw</i></tt> - die gesamte Bandbreite, die für die Warteschlange
verfügbar ist. Dies kann entweder mit absoluten Werten unter Verwendung
der <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt> und <tt>Gb</tt> gemacht werden, die
respektiv Bits, Kilobits, Megabits und Gigabits pro Sekunde darstellen oder
als Prozent der Bandbreite der Eltern-Warteschlange.
Dieser Parameter ist nur anwendbar, wenn der <tt>cbq</tt>-,scheduler'
verwendet wird.
Wenn nicht angegeben, wird standardmäßig 100% der Bandbreite der
Eltern-Warteschlange genutzt.
<li><tt><i>pri</i></tt> - Die Priorität der Warteschlange. Für <tt>cbq</tt>
ist der Prioritätsbereich von 0 bis 7 und für <tt>priq</tt> 0 bis 15.
Priorität 0 ist die niedrigste Priorität. Wenn nicht angegeben, wird ein
Standard von 1 verwendet.
<li><tt><i>qlim</i></tt> - Die maximale Anzahl der Pakete, die in einer
Warteschlange gehalten werden sollen. Wenn nicht angegeben, wird ein Standard
von 50 verwendet.
<li><tt><i>scheduler</i></tt> - Der ,scheduler', der genutzt werden soll,
entweder <tt>cbq</tt> oder <tt>priq</tt>. Muss der gleiche wie der
root-Warteschlange sein.
<li><tt><i>sched_options</i></tt> - Weitere Optionen können dem ,scheduler'
übergeben werden, um sein Verhalten zu kontrollieren:
	<ul>
	<li><tt>default</tt> - definierte eine Standard-Warteschlange, in der
	alle Pakete eingereiht werden, die zu keiner anderen Warteschlange
	passen. Genau eine Standard-Warteschlange wird benötigt.
	<li><tt>red</tt> - aktiviert ,Random Early Detection' (RED) auf dieser
	Warteschlange.
	<li><tt>rio</tt> - aktiviert RED mit IN/OUT. In diesem Modus wird
	RED mehrere durchschnittliche Warteschlangenlängen verwalten und
	mehrere ,treshold'-Werte, einen für jeden
	IP-,Quality of Service'-Level.
	<li><tt>ecn</tt> - aktiviert ,Explicit Congestion Notification' (ECN)
	auf dieser Warteschlange. <tt>Ecn</tt> beinhaltet <tt>red</tt>.
	<li><tt>borrow</tt> - Die Warteschlange kann ungenutzte Bandbreite
	von seiner Eltern-Warteschlange leihen. Dies kann nur angegeben
	werden, wenn der <tt>cbq</tt>-,scheduler' genutzt wird.
	</ul>
<li><tt><i>queue_list</i></tt> - eine Liste von ,child'-Warteschlangen, die
unter dieser Warteschlange erstellt werden sollen. Eine
<tt><i>queue_list</i></tt> darf nur definiert werden, wenn der
<tt>cbq</tt>-,scheduler' genutzt wird.
</ul>

<p>
Das oben angegebene Beispiel weiterführend:
<blockquote>
<tt>
queue std bandwidth 50% cbq(default)<br>
queue ssh bandwidth 25% { ssh_login, ssh_bulk }<br>
&nbsp;&nbsp;queue ssh_login bandwidth 25% priority 4 cbq(ecn)<br>
&nbsp;&nbsp;queue ssh_bulk  bandwidth 75% cbq(ecn)<br>
queue ftp bandwidth 500Kb priority 3 cbq(borrow red)<br>
</tt>
</blockquote>

<p>
Hier werden die Parameter der zuvor definierten ,child'-Warteschlangen
gesetzt. Der <tt>std</tt>-Warteschlange wird eine Bandbreite von 50% der
Bandbreite der root-Warteschlange (oder 1 Mbps) zugewiesen und als
standardmäßige Warteschlange definiert. Der <tt>ssh</tt>-Warteschlange
werden 25% der Bandbreite der ,root'-Warteschlange (500kb) zugewiesen
und beinhaltet ebenfalls zwei ,child'-Warteschlangen, <tt>ssh_login</tt>
und <tt>ssh_bulk</tt>. Der <tt>ssh_login</tt>-Warteschlange wird eine
höhere Priorität als <tt>ssh_bulk</tt> gegeben und für beide ist
ECN aktiv. Der <tt>ftp</tt>-Warteschlange wird eine Bandbreite von
500 Kbps zugewiesen und eine Priorität von 3. Sie kann ebenfalls
Bandbreite leihen, wenn weitere verfügbar ist, und hat RED aktiviert.

<p>
<b>HINWEIS:</b> Jede ,child'-Warteschlange hat ihre eigene Bandbreite
angegeben. Ohne Angabe der Bandbreite wird PF der Warteschlange 100%
der Bandbreite der Eltern-Warteschlange zuweisen.
In diesem Fall wird dies einen Fehler verursachen, wenn die Regeln
geladen werden, da, falls eine Warteschlange existiert, die 100% der
Bandbreite nutzt, keine weitere Warteschlange auf diesem Level angegeben
werden kann, da keine weitere Bandbreite genutzt werden kann.

<a name="assign"></a>
<h3>Verkehr einer ,Queue' zuweisen</h3>
<p>
Um Verkehr einer Warteschlange zuzuweisen, wird das
<tt>queue</tt>-Schlüsselwort in Verbindung mit PFs
<a href="filter.html">Filterregeln</a> verwendet. Siehe dir zum
Beispiel einen Satz an Filterregeln an, der eine Zeile wie folgende
beinhaltet:
<blockquote>
<tt>pass out on fxp0 proto tcp to port 22</tt>
</blockquote>

<p>
Pakete, die zu dieser Regel zutreffen, können einer bestimmten
Warteschlange zugewiesen werden, unter Verwendung des
<tt>queue</tt>-Schlüsselworts:
<blockquote>
<tt>pass out on fxp0 proto tcp to port 22 queue ssh</tt>
</blockquote>

<p>
Wird von dieser Regel ein Statustabelleneintrag erzeugt, so wird PF die
Warteschlange im Statustabelleneintrag erfassen; dies wird für andere Pakete
benutzt, die von diesem Eintrag als statthaft erkannt werden:
<blockquote>
<tt>pass in on fxp0 proto tcp to port 80 queue http</tt>
</blockquote>
Mit dieser Regel werden Pakete, die über <tt>fxp0</tt> ausreisen und die der
zustandsorientierten Verbindung entsprechen, der <tt>http</tt>-Warteschlange
zugeordnet.
Beachte das, obwohl das Schlüsselwort <tt>queue</tt> mit einer Regel benutzt
wird, die eingehenden Datenverkehr filtert, das Ziel darin besteht, eine
Warteschlange für ausgehenden Datenverkehr zu spezifizieren; die oben gezeigte
Regel reiht nicht einkommende Pakete in die Warteschlange ein.

<p>
Wenn das <tt>queue</tt>-Schlüsselwort mit <tt>block</tt>-Direktiven
verwendet wird, werden jegliche resultierende ,TCP RST'- oder
,ICMP Unreachable'-Pakete dieser angegebenen Warteschlange zugewiesen.

<p>
Bedenke, dass das Bestimmen der Warteschlangen auf einem anderen Interface
stattfinden kann als auf dem, auf dem die <tt>altq on</tt>-Direktive
angegeben wurde:
<blockquote>
<tt>
altq on fxp0 cbq bandwidth 2Mb queue { std, ftp }<br>
queue std bandwidth 500Kb cbq(default)<br>
queue ftp bandwidth 1.5Mb<br>
<br>
pass in on dc0 proto tcp to port 21 queue ftp<br>
</tt>
</blockquote>

<p>
»Queueing« wird auf <tt>fxp0</tt> aktiviert, aber die Designierung findet auf
<tt>dc0</tt> statt.
Wenn Pakete, die dieser <tt>pass</tt>-Regel (oder dem vom ihr erzeugten
Zustand) entsprechen die Schnittstelle <tt>fxp0</tt> verlassen, so werden sie
in die Warteschlange <tt>ftp</tt> eingereiht.
Diese Art Warteschlange kann auf Routern sehr nützlich sein.

<p>
Normalerweise wird nur ein Warteschlangen-Name mit dem
<tt>queue</tt>-Schlüsselwort angegeben, aber wenn ein zweiter Name angegeben
wurde, dann wird diese Warteschlange für Pakete mit einem
<a href="http://www.rfc-editor.org/rfc/rfc791.txt">Type of
Service (ToS)</a> von ,low-delay' und für ,TCP ACK'-Pakete mit keinem
Daten-,payload' verwendet. Ein gutes Beispiel hierfür kann in der Verwendung
von SSH gefunden werden. SSH-Login-Sitzungen werden das ToS auf ,low-delay'
setzen, während SCP- und SFTP-Sitzungen das nicht machen. PF kann diese
Information verwenden, um Warteschlangen-Pakete, die zu einer
Login-Verbindung gehören, in eine andere Warteschlange zu stecken, als
sie für Nicht-Login-Verbindungen genutzt werden. Dies kann nützlich sein,
um Login-Verbindungspakete gegenüber Dateitransfer-Paketen zu bevorzugen.
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue(ssh_bulk, ssh_login)</tt>
</blockquote>

<p>
Dies weist Pakete, die zu einer SSH-Login-Sitzung gehören, zu der
<tt>ssh_login</tt>-Warteschlange zu und Pakete, die zu SCP- und
SFTP-Sitzungen gehören, zu der <tt>ssh_bulk</tt>-Warteschlange.
SSH-Login-Verbindungen werden dann ihre Pakete früher verarbeitet bekommen
als SCP- und SFTP-Verbindungen, da die <tt>ssh_login</tt>-Warteschlange
eine höhere Priorität hat.

<p>
,TCP ACK'-Pakete einer höher priorisierten Warteschlange hinzuzufügen
ist sinnvoll, wenn man asymmetrische Verbindungen hat, das heißt,
Verbindungen, die eine andere Upload- als Download-Bandbreite haben,
wie zum Beispiel ADSL-Verbindungen. Wenn bei einer ADSL-Verbindung
der Upload-Kanal ausgereizt ist und ein Download gestartet wird, wird
der Download benachteiligt, da die ,TCP ACK'-Pakete, die gesendet werden
müssen, in eine Anhäufung geraten, wenn sie durch den Upload-Kanal
gelangen wollen. Tests haben gezeigt, dass das beste Resultat erzielt
werden kann, wenn die Bandbreite für die Upload-Warteschlange auf einen
kleineren Wert gesetzt wird, als die Verbindung hergeben könnte. Wenn
zum Beispiel eine ADSL-Verbindung einen maximalen Upload von 640 Kbps
hat, wird das Setzen von <tt>bandwith</tt> der root-Warteschlange auf einen
Wert wie zum Beispiel 600 Kb bessere Leistung erbringen. Versuch und
Irrtum werden die beste <tt>bandwidth</tt>-Einstellung liefern.

<a name="example1"></a>
<h2>Beispiel #1: kleines, Heim-Netzwerk</h2>
<pre>

    [ Alice ]    [ Charlie ]
        |             |                              ADSL
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Internet )
              |
           [ Bob ]

</pre>

<p>
In diesem Beispiel wird OpenBSD auf einem Internet-Gateway für ein kleines
Heim-Netzwerk mit drei Workstations verwendet. Das Gateway führt
das Filtern von Paketen und NAT-Dienste aus. Die Internetverbindung ist
ein ADSL-Anschluss, der mit 2 Mbps ,down' und 640 Kbps ,up' läuft.

<p>
Die ,queueing'-Richtlinie für dieses Netzwerk:
<ul>
<li>Reserviere 80 Kbps an Download-Bandbreite für Bob, sodass er seine
Online-Spiele ohne ,lags' spielen kann, während Alices oder Charlies
Downloads laufen. Erlaube Bob, mehr als 80 Kbps zu nutzen, wenn mehr
zur Verfügung steht.
<li>Interaktiver SSH- und ,instant message'-Verkehr hat eine höhere
Priorität als regulärer Verkehr.
<li>DNS-Anfragen und -Antworten haben die zweithöchste Priorität.
<li>Ausgehende ,TCP ACK'-Pakete haben eine höhere Priorität als der ganze
andere ausgehende Verkehr.
</ul>

<p>
Es folgt der Regelsatz, der dieser Netzwerk-Richtlinie entspricht.
Beachte, dass nur jene <tt>pf.conf</tt>-Direktiven, die direkt obiger
Richtlinie entsprechen, dargestellt werden.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# enable queueing on the external interface to control traffic going to
# the Internet. use the priq scheduler to control only priorities. set
# the bandwidth to 610Kbps to get the best performance out of the TCP
# ACK queue.

altq on fxp0 priq bandwidth 610Kb queue { std_out, ssh_im_out, dns_out, \
	tcp_ack_out }

# define the parameters for the child queues.
# std_out      - the standard queue. any filter rule below that does not
#                explicitly specify a queue will have its traffic added
#                to this queue.
# ssh_im_out   - interactive SSH and various instant message traffic.
# dns_out      - DNS queries.
# tcp_ack_out  - TCP ACK packets with no data payload.

queue std_out     priq(default)
queue ssh_im_out  priority 4 priq(red)
queue dns_out     priority 5
queue tcp_ack_out priority 6

# enable queueing on the internal interface to control traffic coming in
# from the Internet. use the cbq scheduler to control bandwidth. max
# bandwidth is 2Mbps.

altq on dc0 cbq bandwidth 2Mb queue { std_in, ssh_im_in, dns_in, bob_in }

# define the parameters for the child queues.
# std_in      - the standard queue. any filter rule below that does not
#               explicitly specify a queue will have its traffic added
#               to this queue.
# ssh_im_in   - interactive SSH and various instant message traffic.
# dns_in      - DNS replies.
# bob_in      - bandwidth reserved for Bob's workstation. allow him to
#               borrow.

queue std_in    bandwidth 1.6Mb cbq(default)
queue ssh_im_in bandwidth 200Kb priority 4
queue dns_in    bandwidth 120Kb priority 5
queue bob_in    bandwidth 80Kb cbq(borrow)


# ... in the filtering section of pf.conf ...

alice         = "192.168.0.2"
bob           = "192.168.0.3"
charlie       = "192.168.0.4"
local_net     = "192.168.0.0/24"
ssh_ports     = "{ 22 2022 }"
im_ports      = "{ 1863 5190 5222 }"

# filter rules for fxp0 inbound
block in on fxp0 all

# filter rules for fxp0 outbound
block out on fxp0 all
pass  out on fxp0 inet proto tcp from (fxp0) queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0)
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to port domain \
	queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to port $ssh_ports \
	queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to port $im_ports \
	queue(ssh_im_out, tcp_ack_out)

# filter rules for dc0 inbound
block in on dc0 all
pass  in on dc0 from $local_net

# filter rules for dc0 outbound
block out on dc0 all
pass  out on dc0 to $local_net
pass  out on dc0 proto { tcp udp } from port domain to $local_net \
	queue dns_in
pass  out on dc0 proto tcp from port $ssh_ports to $local_net \
	queue(std_in, ssh_im_in)
pass  out on dc0 proto tcp from port $im_ports to $local_net \
	queue ssh_im_in
pass  out on dc0 to $bob queue bob_in
</pre>
</td></tr>
</table>

<a name="example2"></a>
<h2>Beispiel #2: Firmen-Netzwerk</h2>
<pre>

  ( IT Abt )  [ PC vom Chef ]
       |          |                                   T1
     --+----+-----+---------- dc0 [ OpenBSD ] fxp0 -------- ( Internet )
            |                         fxp1
         [ COMP1 ]    [ WWW ]         /
                         |           /
                       --+----------'

</pre>

<p>
In diesem Beispiel fungiert der OpenBSD-Host als eine Firewall für ein
Firmen-Netzwerk. Die Firma betreibt einen WWW-Server in dem DMZ-Bereich
ihres Netzwerks, in dem Kunden ihre Webseiten per FTP hochladen können.
Die IT-Abteilung hat ihr eigenes Subnetz zum Haupt-Netzwerk verbunden
und der Chef hat einen PC auf seinem Schreibtisch, der für E-Mails und
zum Surfen im Web verwendet wird. Die Verbindung zum Internet ist über
einen T1-Anschluss realisiert, der mit 1.5 Mbps in beide Richtungen
läuft. Alle anderen Netzwerksegmente verwenden Fast Ethernet (100 Mbps).

<p>
Der Netzwerkadministrator hat sich für die folgende Richtlinie entschieden:
<ul>
<li>Begrenze den gesamten Verkehr zwischen dem WWW-Server un dem Internet
auf 500 Kbps in beide Richtungen.
	<ul>
	<li>Vergebe 250 Kbps an den HTTP-Verkehr
	<li>Vergebe 250 Kbps an ,anderen' Verkehr (z.&nbsp;B. Nicht-HTTP-Verkehr)
	<li>Erlaube beiden Warteschlangen, bis zu den gesamten 500 Kbps
	Bandbreite zu leihen.
	<li>Gebe dem HTTP-Verkehr zwischen dem WWW-Server und dem Internet
	eine höhere Priorität als dem anderen Verkehr zwischen dem
	WWW-Server und dem Internet (wie zum Beispiel FTP-Uploads).
	</ul>
<li>Der Verkehr zwischen dem WWW-Server und dem internen Netzwerk kann
bis die gesamten 100 Mbps, die das Netzwerk bereitstellt, nutzen.
<li>Reserviere 500 Kbps für das IT-Abt-Netzwerk, sodass sie die aktuellsten
Software-Updates in einer zeitlichen Manier herunterladen können. Sie
sollten in der Lage sein, mehr als 500 Kbps zu verwenden, wenn mehr zur
Verfügung steht.
<li>Gib dem Verkehr zwischen dem PC vom Check und dem Internet eine höhere
Priorität als jeglichem anderen Verkehr vom/zum Internet.
</ul>

<p>
Weiter unten ist der Regelsatz, der dieser Netzwerk-Richtlinie entspricht.
Bedenke, dass nur die <tt>pf.conf</tt>-Direktiven, die direkt für diese
Richtlinie gelten, vorhanden sind; <a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">Optionen</a>
etc. werden nicht gezeigt.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# enable queueing on the external interface to queue packets going out
# to the Internet. use the cbq scheduler so that the bandwidth use of
# each queue can be controlled. the max outgoing bandwidth is 1.5Mbps.

altq on fxp0 cbq bandwidth 1.5Mb queue { std_ext, www_ext, boss_ext }

# define the parameters for the child queues.
# std_ext        - the standard queue. also the default queue for
#                  outgoing traffic on fxp0.
# www_ext        - container queue for WWW server queues. limit to
#                  500Kbps.
#   www_ext_http - http traffic from the WWW server; higher priority.
#   www_ext_misc - all non-http traffic from the WWW server.
# boss_ext       - traffic coming from the boss's computer.

queue std_ext        bandwidth 500Kb cbq(default borrow)
queue www_ext        bandwidth 500Kb { www_ext_http, www_ext_misc }
  queue www_ext_http bandwidth 50% priority 3 cbq(red borrow)
  queue www_ext_misc bandwidth 50% priority 1 cbq(borrow)
queue boss_ext       bandwidth 500Kb priority 3 cbq(borrow)

# enable queueing on the internal interface to control traffic coming
# from the Internet or the DMZ. use the cbq scheduler to control the
# bandwidth of each queue. bandwidth on this interface is set to the
# maximum. traffic coming from the DMZ will be able to use all of this
# bandwidth while traffic coming from the Internet will be limited to
# 1.0Mbps (because 0.5Mbps (500Kbps) is being allocated to fxp1).

altq on dc0 cbq bandwidth 100% queue { net_int, www_int }

# define the parameters for the child queues.
# net_int    - container queue for traffic from the Internet. bandwidth
#              is 1.0Mbps.
#   std_int  - the standard queue. also the default queue for outgoing
#              traffic on dc0.
#   it_int   - traffic to the IT Dept network; reserve them 500Kbps.
#   boss_int - traffic to the boss's PC; assign a higher priority.
# www_int    - traffic from the WWW server in the DMZ; full speed.

queue net_int    bandwidth 1.0Mb { std_int, it_int, boss_int }
  queue std_int  bandwidth 250Kb cbq(default borrow)
  queue it_int   bandwidth 500Kb cbq(borrow)
  queue boss_int bandwidth 250Kb priority 3 cbq(borrow)
queue www_int    bandwidth 99Mb cbq(red borrow)

# enable queueing on the DMZ interface to control traffic destined for
# the WWW server. cbq will be used on this interface since detailed
# control of bandwidth is necessary. bandwidth on this interface is set
# to the maximum. traffic from the internal network will be able to use
# all of this bandwidth while traffic from the Internet will be limited
# to 500Kbps.

altq on fxp1 cbq bandwidth 100% queue { internal_dmz, net_dmz }

# define the parameters for the child queues.
# internal_dmz   - traffic from the internal network.
# net_dmz        - container queue for traffic from the Internet.
#   net_dmz_http - http traffic; higher priority.
#   net_dmz_misc - all non-http traffic. this is also the default queue.

queue internal_dmz   bandwidth 99Mb cbq(borrow)
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http bandwidth 50% priority 3 cbq(red borrow)
  queue net_dmz_misc bandwidth 50% priority 1 cbq(default borrow)


# ... in the filtering section of pf.conf ...

main_net  = "192.168.0.0/24"
it_net    = "192.168.1.0/24"
int_nets  = "{ 192.168.0.0/24, 192.168.1.0/24 }"
dmz_net   = "10.0.0.0/24"

boss      = "192.168.0.200"
wwwserv   = "10.0.0.100"

# default deny
block on { fxp0, fxp1, dc0 } all

# filter rules for fxp0 inbound
pass in on fxp0 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 queue www_ext_http

# filter rules for fxp0 outbound
pass out on fxp0 from $int_nets
pass out on fxp0 from $boss queue boss_ext

# filter rules for dc0 inbound
pass in on dc0 from $int_nets
pass in on dc0 from $it_net queue it_int
pass in on dc0 from $boss queue boss_int
pass in on dc0 proto tcp from $int_nets to $wwwserv port { 21, 80, \
	&gt; 49151 } queue www_int

# filter rules for dc0 outbound
pass out on dc0 from dc0 to $int_nets

# filter rules for fxp1 inbound
pass in on fxp1 proto { tcp, udp } from $wwwserv to port 53

# filter rules for fxp1 outbound
pass out on fxp1 proto tcp to $wwwserv port { 21, \
	&gt; 49151 } queue net_dmz_misc
pass out on fxp1 proto tcp to $wwwserv port 80 queue net_dmz_http
pass out on fxp1 proto tcp from $int_nets to $wwwserv port { 80, \
	21, &gt; 49151 } queue internal_dmz
</pre>
</td></tr>
</table>

<p>
[<a href="anchors.html">Zurück: Anker</a>]
[<a href="index.html">Inhalt</a>]
[<a href="pools.html">Weiter: Adress-Pools und Load Balancing</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: queueing.html,v 1.46 ]<br>
$Translation: queueing.html,v 1.37 2013/11/01 16:59:45 steffen Exp $<br>
-->
$OpenBSD: queueing.html,v 1.37 2013/11/01 18:04:05 ajacoutot Exp $
</small>

</body>
</html>
@


1.37
log
@Sync with Steelix CVS
@
text
@d945 1
a945 1
$OpenBSD$
@


1.36
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+5.3"
d942 2
a943 2
Originally [OpenBSD: queueing.html,v 1.45 ]<br>
$Translation: queueing.html,v 1.36 2013/05/01 16:34:16 steffen Exp $<br>
@


1.35
log
@Sync with Steelix CVS
@
text
@d942 2
a943 2
Originally [OpenBSD: queueing.html,v 1.44 ]<br>
$Translation: queueing.html,v 1.35 2013/05/01 13:35:26 steffen Exp $<br>
@


1.34
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+5.2"
d943 1
a943 1
$Translation: queueing.html,v 1.34 2012/11/01 20:43:18 steffen Exp $<br>
@


1.33
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+5.1"
d942 2
a943 2
Originally [OpenBSD: queueing.html,v 1.43 ]<br>
$Translation: queueing.html,v 1.33 2012/05/11 17:06:29 steffen Exp $<br>
@


1.32
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+5.0"
d942 2
a943 2
Originally [OpenBSD: queueing.html,v 1.42 ]<br>
$Translation: queueing.html,v 1.32 2012/01/20 20:21:49 steffen Exp $<br>
@


1.31
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.6"
d542 1
a542 1
<tt>pass out on fxp0 from any to any port 22</tt>
d550 1
a550 1
<tt>pass out on fxp0 from any to any port 22 queue ssh</tt>
d554 15
d583 1
a583 1
pass in on dc0 from any to any port 21 queue ftp<br>
d588 6
a593 5
,Queueing' wird auf <tt>fxp0</tt> aktiviert, aber das Markieren findet auf
<tt>dc0</tt> statt. Wenn Pakete, die mit dieser <tt>pass</tt>-Regel
übereinstimmten, vom Interface <tt>fxp0</tt> aus hinausgehen, werden sie
in der <tt>ftp</tt>-Warteschlange eingereiht. Diese Art von ,queueing' kann
auf Routern sehr nützlich sein.
d634 1
a634 20
Irrtum werden die beste <tt>bandwith</tt>-Einstellung liefern.

<p>
Wenn das <tt>queue</tt>-Schlüsselwort mit Regeln genutzt wird, die
<tt>keep state</tt> beinhalten, wie zum Beispiel:
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port 22 flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state queue ssh
</tt>
</blockquote>

<p>
wird PF die Warteschlange in dem ,state'-Tabelleneintrag halten, so
dass Pakete, die zurück durch <tt>fxp0</tt> kommen und mit der ,stateful'
Verbindung übereinstimmen, in der <tt>ssh</tt>-Warteschlange enden. Bedenke,
dass, obwohl das <tt>queue</tt>-Schlüsselwort mit einem Regelfilter für
eingehenden Verkehr genutzt wird, das Ziel das Angeben einer Warteschlange
für korrespondierenden ausgehenden Verkehr ist; die oben angegebene Regel
reiht keine eingehenden Pakete ein.
d669 3
a671 5
Weiter unten ist der Regelsatz, der dieser Netzwerk-Richtlinie entspricht.
Bedenke, dass nur die <tt>pf.conf</tt>-Direktiven, die direkt für diese
Richtlinie gelten, vorhanden sind; <a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">Optionen</a>
etc. werden nicht gezeigt.
d677 4
a680 4
# aktiviere ,queueing' auf dem externen interface, um den verkehr, der
# zum internet geht, zu kontrollieren. verwende den priq-,scheduler',
# um nur prioritäten zu kontrollieren. setze die bandbreite auf 610 kbps,
# um die beste leistung aus der ,tcp ack'-warteschlange zu bekommen.
d685 7
a691 7
# definiere die parameter für die ,child'-warteschlangen.
# std_out      - die standard-warteschlange. jegliche filterregel weiter
#                unten, die nicht explizit eine warteschlange angibt,
#                wird ihren verkehr zu dieser warteschlange hinzufügen.
# ssh_im_out   - interaktiver SSH- und etlicher ,instant message'-verkehr.
# dns_out      - DNS-anfragen.
# tcp_ack_out  - ,TCP ACK'-pakete mit keinem daten-,payload'.
d698 3
a700 3
# aktivere ,queueing' auf dem internen interface, um den verkehr zu
# kontrollieren, der vom internet kommt. verwende den cbq-,scheduler' um
# die bandbreite zu kontrollieren. max bandbreite ist 2 Mbps.
d704 8
a711 8
# definiere die parameter für die ,child'-warteschlangen.
# std_in      - die standard-warteschlange. jegliche filterregel weiter
#               unten, die nicht explizit eine warteschlange angibt,
#               wird ihren verkehr zu dieser warteschlange hinzufügen.
# ssh_im_in   - interaktiver SSH- und etlicher ,instant message'-verkehr.
# dns_in      - DNS-antworten.
# bob_in      - für bobs workstation reservierte bandbreite. erlaube ihm,
#               zu leihen.
d719 1
a719 1
# ... in der filter-sektion von pf.conf ...
d728 1
a728 1
# filterregeln für fxp0-eingang
d731 1
a731 1
# filterregeln für fxp0-ausgang
d733 8
a740 9
pass  out on fxp0 inet proto tcp from (fxp0) to any flags S/SA \
	keep state queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0) to any keep state
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to any port domain \
	keep state queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to any port $ssh_ports \
	flags S/SA keep state queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to any port $im_ports \
	flags S/SA keep state queue(ssh_im_out, tcp_ack_out)
d742 1
a742 1
# filterregeln für dc0-eingang
d746 1
a746 1
# filterregeln für dc0-ausgang
d748 2
a749 2
pass  out on dc0 from any to $local_net
pass  out on dc0 proto { tcp udp } from any port domain to $local_net \
d751 1
a751 1
pass  out on dc0 proto tcp from any port $ssh_ports to $local_net \
d753 1
a753 1
pass  out on dc0 proto tcp from any port $im_ports to $local_net \
d755 1
a755 1
pass  out on dc0 from any to $bob queue bob_in
d819 3
a821 4
# aktiviere ,queueing' auf dem externen interface um pakete einzureihen,
# die ins internet hinaus gehen. verwende den ,cbq'-scheduler, sodass die
# bandbreite, die für jede warteschlange genutzt wird, kontrolliert werden
# kann. die max ausgehende bandbreite ist 1,5 Mbps.
d825 8
a832 9
# definiere die parameter für die ,child'-warteschlangen.
# std_ext        - die standard-warteschlange. ebenfalls die
#                  standardmäßige warteschlange für ausgehenden verkehr
#                  auf fxp0.
# www_ext        - container-warteschlange für WWW-server-warteschlangen.
#                  begrenzt für 500 Kbps.
#   www_ext_http - http-verkehr von dem WWW-server; höhere priorität.
#   www_ext_misc - jeder nicht-http-verkehr von dem WWW-server.
# boss_ext       - verkehr, der vom computer des chefs kommt.
d840 6
a845 8
# aktiviere ,queueing' auf dem internen interface, um verkehr zu
# kontrollieren, der vom internet oder der DMZ kommt. verwende
# den cbq-,scheduler' um die bandbreite für jede warteschlange zu
# kontrollieren. bandbreite auf diesem interface ist auf das maximum
# gesetzt. verkehr, der von der dmz kommt, wird in der lage sein,
# die gesamte bandbreite zu nutzen, während verkehr, der vom internet
# kommt, auf 1,0 Mbps (wegen 0,5 Mbps (500 Kbps) für fxp1 zugewiesen
# wird) begrenzt wird.
d849 8
a856 8
# definiere die parameter für die ,child'-warteschlangen.
# net_int    - container-warteschlange für verkehr vom internet.
#              bandbreite ist 1,0 Mbps.
#   std_int  - die standard-warteschlange. ebenfalls die
#              standard-warteschlange für ausgehenden verkehr auf dc0.
#   it_int   - verkehr zum it-abt-netzwerk; reserviere ihnen 500 Kbps.
#   boss_int - verkehr zum PC des chefs, eine höhere Priorität zuweisen
# www_int    - verkehr vom WWW-server in die DMZ; volle Geschwindigkeit.
d864 6
a869 7
# aktivere ,queueing' auf dem DMZ-interface, um den verkehr, der für
# den WWW-server bestimmt ist, zu kontrollieren. cbq wird auf diesem
# interface verwendet, da detaillierte kontrolle der bandbreite notwendig
# ist. bandbreite auf diesem interface ist auf das maximum gesetzt.
# verkehr vom internen netzwerk wird in der lage sein, alles dieser
# bandbreite nutzen zu können, während verkehr vom internet auf 500 Kbps
# begrenzt wird.
d873 5
a877 6
# definiere die parameter für die ,child'-warteschlangen.
# internal_dmz   - verkehr vom internen netzwerk.
# net_dmz        - container-warteschlange für den verkehr vom internet.
#   net_dmz_http - http verkehr; höhere Priorität.
#   net_dmz_misc - der gesamte nicht-http-verkehr. dies ist ebenfalls die
#                  standardmäßige warteschlange.
d885 1
a885 2

# ... in der filter-sektion von pf.conf ...
d895 1
a895 1
# standardmäßiges blocken
d898 1
a898 1
# filterregeln für fxp0-eingang
d900 11
a910 12
	&gt; 49151 } flags S/SA keep state queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue www_ext_http

# filterregeln für fxp0-ausgang
pass out on fxp0 from $int_nets to any keep state
pass out on fxp0 from $boss to any keep state queue boss_ext

# filterregeln für dc0-eingang
pass in on dc0 from $int_nets to any keep state
pass in on dc0 from $it_net to any queue it_int
pass in on dc0 from $boss to any queue boss_int
d912 1
a912 1
	&gt; 49151 } flags S/SA keep state queue www_int
d914 1
a914 1
# filterregeln für dc0-ausgang
d917 7
a923 9
# filterregeln für fxp1-eingang
pass in on fxp1 proto { tcp, udp } from $wwwserv to any port 53 \
	keep state

# filterregeln für fxp1-ausgang
pass out on fxp1 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } flags S/SA keep state queue net_dmz_misc
pass out on fxp1 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue net_dmz_http
d925 1
a925 1
	21, &gt; 49151 } flags S/SA keep state queue internal_dmz
d942 2
a943 2
Originally [OpenBSD: queueing.html,v 1.38 ]<br>
$Translation: queueing.html,v 1.31 2009/11/05 12:55:49 tobias Exp $<br>
@


1.30
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.5"
d958 2
a959 2
Originally [OpenBSD: queueing.html,v 1.37 ]<br>
$Translation: queueing.html,v 1.30 2009/05/03 12:44:32 tobias Exp $<br>
@


1.29
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.4"
d958 2
a959 2
Originally [OpenBSD: queueing.html,v 1.36 ]<br>
$Translation: queueing.html,v 1.29 2009/02/22 09:17:46 paldium Exp $<br>
@


1.28
log
@Sync with Steelix CVS
@
text
@d958 2
a959 2
Originally [OpenBSD: queueing.html,v 1.35 ]<br>
$Translation: queueing.html,v 1.28 2008/11/01 09:15:08 paldium Exp $<br>
@


1.27
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.3"
d958 2
a959 2
Originally [OpenBSD: queueing.html,v 1.34 ]<br>
$Translation: queueing.html,v 1.27 2008/08/04 14:41:05 paldium Exp $<br>
@


1.26
log
@Sync with Steelix CVS
@
text
@d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.2"
d958 2
a959 2
Originally [OpenBSD: queueing.html,v 1.33 ]<br>
$Translation: queueing.html,v 1.26 2008/03/04 23:03:18 paldium Exp $<br>
@


1.25
log
@Sync with Steelix CVS
@
text
@d81 1
a81 1
FTP-Übertraung um ein paar Sekunden verzögert wird, wird es wohl kaum
d307 1
a307 1
iegt, dann werden <i>alle</i> neu ankommenden Pakete fallengelassen.
d316 1
a316 1
beim Fallenlassen ihrer Pakete.
d333 1
a333 1
Pakete durch das Fallenlassen genommen. Auf diesem Weg werden
d337 1
a337 1
da er beginnt, Pakete fallenzulassen, <i>bevor</i> die Warteschlange voll
d357 1
a357 1
fallenzulassen. Angenommen, der sendende Host hat Unterstützung für ECN,
d959 1
a959 1
$Translation: queueing.html,v 1.25 2007/11/03 10:45:44 paldium Exp $<br>
@


1.24
log
@sync with steelix translation CVS
@
text
@d132 1
a132 1
so dass jene, die interaktiven Verkehr beinhalten, zum Beispiel SSH,
d161 1
a161 1
zu klassifizieren, so dass bestimmte Protokolle anderen nicht
d369 1
a369 1
>,Alternate Queueing'- (ALTQ)</a> Implementierung Teil des Basis-Systems.
d371 1
a371 1
ALTQ-Implementierung unterstützt ,Class Based Queueing'- (CBQ) und
d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.1"
d413 1
a413 1
<li><tt><i>qlim</i></tt> - die maximale Anzahl von Paketen, die in der
d469 1
a469 1
<li><tt><i>qlim</i></tt> - Die maximale Anzahl von Paketen, die in einer
d660 1
a660 1
<li>Reserviere 80 Kbps an Download-Bandbreite für Bob, so dass er seine
d806 1
a806 1
<li>Reserviere 500 Kbps für das IT-Abt-Netzwerk, so dass sie die aktuellsten
d826 1
a826 1
# die ins internet hinaus gehen. verwende den ,cbq'-scheduler, so dass die
d958 2
a959 2
Originally [OpenBSD: queueing.html,v 1.32 ]<br>
$Translation: queueing.html,v 1.23 2007/06/20 17:41:07 paldium Exp $<br>
@


1.23
log
@Sync with Steelix CVS
@
text
@d416 1
a416 1
<li><tt><i>size</i></tt> - Die Größe des ,token bucket regulator' in Bytes.
d959 1
a959 1
$Translation: queueing.html,v 1.22 2007/05/09 14:08:40 paldium Exp $<br>
@


1.22
log
@Sync with steelix translation CVS
@
text
@d256 1
a256 1
zu, wobei jeder Warteschlange ein einzigartiges Prioritätslevel gegeben
d259 3
d382 1
a382 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.0"
d958 2
a959 2
Originally [OpenBSD: queueing.html,v 1.30 ]<br>
$Translation: queueing.html,v 1.21 2007/04/25 15:41:14 paldium Exp $<br>
@


1.21
log
@sync with Steelix CVS
@
text
@d97 1
a97 1
einzureihen -- es hat bereits Netzwerk-Bandbreite verbraucht, um
d110 1
a110 1
-- das erste Objekt in der Schlange wird zuerst verarbeitet. Wenn
d238 1
a238 1
in einer ,round-robin'-Manier verarbeiten -- keine Warteschlange wird
d261 1
a261 1
Die Einreihe-Struktur in PRIQ ist flach -- du kannst keine Warteschlangen
d392 1
a392 1
altq on <i>interface scheduler</i> bandwidth <i>bw</i> qlimit 
d560 1
a560 1
<tt> 
d639 1
a639 1
  
d772 2
a773 2
                         |           / 
                       --+----------' 
d956 1
a956 1
$Translation: queueing.html,v 1.20 2007/02/09 18:13:49 paldium Exp $<br>
d962 1
a962 1
</html> 
@


1.20
log
@sync with steelix translation CVS
@
text
@d128 1
a128 1
basierend auf der Quell- oder Ziel-Adresse, Port-Nummer, Protokoll, etc.
d672 1
a672 1
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">Optionen</a>,
d815 1
a815 1
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">Optionen</a>,
d956 1
a956 1
$Translation: queueing.html,v 1.19 2006/11/01 10:48:51 paldium Exp $<br>
@


1.19
log
@sync with Steelix CVS
@
text
@d379 1
a379 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.9"
d955 2
a956 2
Originally [OpenBSD: queueing.html,v 1.29 ]<br>
$Translation: queueing.html,v 1.18 2006/08/06 14:06:56 paldium Exp $<br>
@


1.18
log
@3.9 release time.
@
text
@d794 1
a794 1
	<li>Vergebe 250 Kbps an ,anderen' Verkehr (z.B. Nicht-HTTP-Verkehr)
d956 1
a956 1
$Translation: queueing.html,v 1.17 2006/05/01 11:17:11 paldium Exp $<br>
@


1.17
log
@sync with Steelix CVS
@
text
@d379 1
a379 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.8"
d955 2
a956 2
Originally [OpenBSD: queueing.html,v 1.28 ]<br>
$Translation: queueing.html,v 1.16 2006/04/24 17:44:30 paldium Exp $<br>
@


1.16
log
@sync with steelix translation CVS
@
text
@a5 1
<meta http-equiv="Content-Language" content="de">
d8 1
a8 1
<meta name="description"   content="Die OpenBSD-FAQ-Seite">
d955 2
a956 2
Originally [OpenBSD: queueing.html,v 1.28 ]
$Translation: queueing.html,v 1.15 2006/04/06 13:05:11 paldium Exp $
@


1.15
log
@sync with Steelix CVS
@
text
@d448 3
a450 3
Namen einer Warteschlange einer vorherigen <tt><i>queue_list</i></tt> der
<tt>queue</tt>-Direktive übereinstimmen. Warteschlangen-Namen dürfen nicht
länger als 15 Zeichen sein.
d957 1
a957 1
$Translation: queueing.html,v 1.14 2005/11/28 21:15:07 paldium Exp $
@


1.14
log
@sync with steelix translation CVS
@
text
@d360 1
a360 1
Für weitere Informationen über ECN, lese bitte
d957 1
a957 1
$Translation: queueing.html,v 1.13 2005/11/04 11:01:45 paldium Exp $
@


1.13
log
@sync with Steelix CVS
@
text
@d380 1
a380 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.7"
d956 2
a957 2
Originally [OpenBSD: queueing.html,v 1.27 ]
$Translation: queueing.html,v 1.12 2005/09/14 16:16:39 paldium Exp $
@


1.12
log
@sync with Steelix CVS
@
text
@d6 1
a8 1
<meta http-equiv="Content-Language" content="de">
d39 1
a39 1
[<a href="scrub.html">Zurück: Anker</a>]
d951 1
a951 1
<a href="../../de/index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[zurück]"></a>
d957 1
a957 1
$Translation: queueing.html,v 1.11 2005/07/04 11:36:32 paldium Exp $
@


1.11
log
@sync with Steelix CVS
@
text
@d447 1
a447 3
definiert werden.
<tt><i>queue_list</i></tt> in der <tt>altq on</tt>-Direktive definierten
Warteschlange übereinstimmen. Für <tt>cbq</tt> kann er ebenfalls mit dem
d957 1
a957 1
$Translation: queueing.html,v 1.10 2005/05/20 18:05:19 paldium Exp $
@


1.10
log
@sync with steelix translation CVS
@
text
@d444 4
a447 1
<li><tt><i>name</i></tt> - Der Name der Warteschlange. Dieser muss mit einer
d814 1
d959 1
a959 1
$Translation: queueing.html,v 1.9 2005/05/20 16:33:52 paldium Exp $
@


1.9
log
@sync with steelxi translation CVS
@
text
@d380 1
a380 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.6"
d954 2
a955 2
Originally [OpenBSD: queueing.html,v 1.26 ]
$Translation: queueing.html,v 1.8 2005/04/25 18:16:47 paldium Exp $
@


1.8
log
@huge sync from the translators
@
text
@@


1.7
log
@sync with Steelix CVS
@
text
@d411 1
a411 1
<li><tt><i>qlim</i></tt> - die maximale Anzahl an Paketen, die in der
d466 1
a466 1
<li><tt><i>qlim</i></tt> - Die maximale Anzahl an Paketen, die in einer
d955 1
a955 1
$Translation: queueing.html,v 1.7 2005/02/27 11:58:48 paldium Exp $
@


1.6
log
@Sync with Steelix CVS
@
text
@d460 2
d501 3
a503 3
queue ssh { ssh_login, ssh_bulk }<br>
&nbsp;&nbsp;queue ssh_login  priority 4 cbq(ecn)<br>
&nbsp;&nbsp;queue ssh_bulk   cbq(ecn)<br>
d512 4
a515 3
standardmäßige Warteschlange definiert. Die <tt>ssh</tt>-Warteschlange
definiert zwei ,child'-Warteschlangen, <tt>ssh_login</tt> und
<tt>ssh_bulk</tt>. Der <tt>ssh_login</tt>-Warteschlange wird eine
d521 9
d562 1
a562 1
queue std cbq(default)<br>
d715 3
a717 3
queue std_in    cbq(default)
queue ssh_im_in priority 4
queue dns_in    priority 5
d790 13
a802 7
<li>Begrenze den Verkehr zwischen dem WWW-Server un dem Internet auf
500 Kbps in beide Richtungen.
<li>Keine Bandbreiten-Begrenzungen für den Verkehr zwischen dem WWW-Server
und dem internen Netzwerk.
<li>Gib dem HTTP-Verkehr zwischen dem WWW-Server und dem Internet eine
höhere Priorität als dem anderen Verkehr zwischen dem WWW-Server und dem
Internet (zum Beispiel FTP-Uploads).
d834 3
a836 3
#   www_ext_http - http-verkehr von dem WWW-server
#   www_ext_misc - jeder nicht-http-verkehr von dem WWW-server
# boss_ext       - verkehr, der vom computer des chefs kommt
d838 1
a838 1
queue std_ext        cbq(default)
d840 3
a842 3
  queue www_ext_http priority 3 cbq(red)
  queue www_ext_misc priority 1
queue boss_ext       priority 3
d860 3
a862 3
#   it_int   - verkehr zum it-abt-netzwerk.
#   boss_int - verkehr zum PC des chefs.
# www_int    - verkehr vom WWW-server in die DMZ.
d865 1
a865 1
  queue std_int  cbq(default)
d867 2
a868 2
  queue boss_int priority 3
queue www_int    cbq(red)
d883 1
a883 1
#   net_dmz_http - http verkehr.
d887 1
a887 1
queue internal_dmz      # keine speziellen einstellungen benötigt
d889 3
a891 2
  queue net_dmz_http priority 3 cbq(red)
  queue net_dmz_misc priority 1 cbq(default)
d954 2
a955 2
Originally [OpenBSD: queueing.html,v 1.25 ]
$Translation: queueing.html,v 1.6 2005/02/07 12:39:02 paldium Exp $
@


1.5
log
@Sync with Steelix CVS
@
text
@d15 1
a15 1
Copyright (c) 2003, 2004 Joel Knight <enabled@@myrealbox.com>
d39 1
a39 1
[<a href="scrub.html">Zurück: Anker und benannte (Unter-)Regelsätze</a>]
d924 1
a924 1
[<a href="anchors.html">Zurück: Anker und benannte (Unter-)Regelsätze</a>]
d935 2
a936 2
Originally [OpenBSD: queueing.html,v 1.24 ]
$Translation: queueing.html,v 1.5 2005/01/18 14:33:46 paldium Exp $
@


1.4
log
@Sync with Steelix CVS
@
text
@d9 1
a9 1
<meta name="description"   content="die OpenBSD-FAQ-Seite">
d934 5
a938 3
Originally [OpenBSD: queueing.html,v 1.24 ]<br>
$Translation: queueing.html,v 1.4 2005/01/03 13:37:36 paldium Exp $<br>
$OpenBSD$: queueing.html,v 1.24 2004/12/22 04:28:16 david Exp $
@


1.3
log
@Sync with Steelix CVS
@
text
@d80 1
a80 1
Natur von SSH verarbeitet werden; wenn eine taste im SSH-Client gedrückt
d95 2
a96 2
Bedenke, dass das einreihen nur nützlich für Pakete in die
<i>ausgehende</i> Verbindung ist. Sobald ein Paket auf dem Interface
d101 1
a101 1
oder, wenn der Host, der das Paket erhalten hat als Router fungiert,
d128 1
a128 1
Klassen aufteilt. Jeder Warteschlange wird dass Verkehr zugewiesen,
d140 2
a141 2
den Gesamtgröße der verfügbaren Bandbreite angibt. ,Child'-Warteschlangen
werden unter der root-Warteschlange angelegt, von der jeder ein Teil der
d145 1
a145 1
<dd>Root-Warteschlange (2Mbps)
d147 3
a149 3
	<dd>Warteschlange A (1Mbps)
	<dd>Warteschlange B (500Kbps)
	<dd>Warteschlange C (500Kbps)
d154 1
a154 1
In diesem Fall wird die gesamt-verfügbare Bandbreite auf 2 Megabits pro
d159 1
a159 1
Die Hierarchie kann weiter ausgebreitet werden, indem Warteschlangen
d161 1
a161 1
verschiende Benutzer gleich aufzuteilen und ebenfalls ihren Verkehr
d166 1
a166 1
<dd>Root-Warteschlange (2Mbps)
d168 1
a168 1
	<dd>BenutzerA (1Mbps)
d170 2
a171 2
		<dd>ssh (50Kbps)
		<dd>bulk (950Kbps)
d173 1
a173 1
	<dd>BenutzerB (1Mbps)
d175 2
a176 2
		<dd>audio (250Kbps)
		<dd>bulk (750Kbps)
d178 2
a179 2
			<dd>http (100Kbps)
			<dd>andere (650Kbps)
d195 1
a195 1
<dd>Root-Warteschlange (2Mbps)
d197 1
a197 1
	<dd>BenutzerA (1Mbps)
d199 2
a200 2
		<dd>ssh (100Kbps)
		<dd>ftp (900Kbps, leihen)
d202 1
a202 1
	<dd>BenutzerB (1Mbps)
d222 1
a222 1
(in anderen Worten, so lange beide Warteschlangen im gleichen Zweig
d226 1
a226 1
<dd>Root-Warteschlange (2Mbps)
d228 1
a228 1
	<dd>BenutzerA (1Mbps, Priorität 1)
d230 2
a231 2
		<dd>ssh (100Kbps, Priorität 5)
		<dd>ftp (900Kbps, Priorität 3)
d233 1
a233 1
	<dd>BenutzerB (1Mbps, Priorität 1)
d267 1
a267 1
<dd>Root-Warteschlange (2Mbps)
d276 1
a276 1
Die root-Warteschlange wurde so definiert, dass ihr 2Mbps der
d280 1
a280 1
Warteschlange bearbeitet wurden, oder wenn festgestellt wird, dass
d282 1
a282 1
mit der höchsten Priorität gehen. Innerhalb einer gegebenen
d297 1
a297 1
,Random Early Detection' (RED) ist ein Anhäufig-vermeidender Algorithmus.
d416 1
a416 1
<tt><i>Interface</i></tt>-Bandbreite gesetzt.
d429 1
a429 1
Bandbreite wird auf 2Mbps gesetzt. Drei ,child'-Warteschlangen werden
d444 1
a444 1
<li><tt><i>name</i></tt> - Der Name der Warteschalgen. Dieser muss mit einer
d450 1
a450 1
<li><tt><i>interface</i></tt> - Das Netzwerk-Interface, für as die
d485 1
a485 1
	von seiner Eltern-Warteschlange leihen. DIes kann nur angegeben
d509 1
a509 1
Bandbreite der root-Warteschlange (oder 1Mbps) zugewiesen und als
d513 1
a513 1
höhere Priorität als <tt>ssh_bulk</tt> gegeben und beide haben
d515 1
a515 1
500 Kbps zugewiesen und eine Priorität von 3. Es kann ebenfalls
d521 1
a521 1
Um Verkehr einer Warteschlange zuzweisen, wird das
d533 1
a533 1
<tt>queue</tt>-Schlüsselwortes:
d545 2
a546 2
stattfinden kann als auf dem, auf dem <tt>altq on</tt>-Direktive angegeben
wurde:
d566 2
a567 2
<tt>queue</tt>-Kennwort angegeben, aber wenn ein zweiter Name angegeben wurde,
dann wird diese Warteschlange für Pakete mit einem
d576 1
a576 1
um Login-Verbindungspakete gegenüber Dateitransfer-Pakete zu bevorzugen.
d582 1
a582 1
Dies weist Pakete, die zu einer SSH-Login-Sitzunge gehören, zu der
d592 1
a592 1
Verbindunge, die eine andere Upload- als Download-Bandbreite haben,
d596 1
a596 1
müssen, in eine Anhäufung geraten, wenn sie durch den upload-Kanal
d601 1
a601 1
hat, wird das setzen <tt>bandwith</tt> der root-Warteschlange auf einen
d640 1
a640 1
ein ADSL-Anschluss, der mit 2 Mbps down und 640 Kbps up läuft.
d645 1
a645 1
<li>Reserivere 80 Kbps an Download-Bandbreite für Bob, so dass er seine
d768 1
a768 1
ihres Netzwerk, in dem Kunden ihre Webseiten per FTP hochladen können.
d770 1
a770 1
und der Chef hat einen PF auf seinem Schreibtiss, der für E-Mails und
d810 1
a810 1
# definiere die parametr für die ,child'-warteschlangen.
d854 1
a854 1
# interface vwerdnet, da detaillierte kontrolle der bandbreite notwendig
d864 1
a864 1
# net_dmz        - container-warteschlange für den verkehr vom Internet.
d935 1
a935 1
$Translation: queueing.html,v 1.3 2004/12/22 12:29:54 paldium Exp $<br>
@


1.2
log
@sync with Steelix CVS
@
text
@d35 3
a37 1
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
d934 3
a936 3
Originally [OpenBSD: queueing.html,v 1.23 ]<br>
$Translation: queueing.html,v 1.2 2004/12/07 16:56:32 paldium Exp $<br>
$OpenBSD$: queueing.html,v 1.23 2004/10/29 17:22:57 nick Exp $
@


1.1
log
@Sync with Steelix CVS
@
text
@d4 1
a4 1
<title>PF: Queueing</title>
d8 2
a9 1
<meta name="description"   content="the OpenBSD FAQ page">
a11 1
<meta name="copyright"     content="This document copyright 2003 by OpenBSD.">
d14 17
d37 3
a39 3
[<a href="scrub.html">Previous: Scrub</a>]
[<a href="index.html">Contents</a>]
[<a href="nat.html">Next: Network Address Translation</a>]
d42 1
a42 1
<h1><font color="#e00000">PF: Queueing</font></h1>
d47 1
a47 1
<h3>Table of Contents</h3>
d57 4
a60 4
<li><a href="#altq">Configuring Queueing</a>
<li><a href="#assign">Assigning Traffic to a Queue</a>
<li><a href="#example1">Example #1: Small, Home Network</a>
<li><a href="#example2">Example #2: Company Network</a>
d68 34
a101 28
To queue something is to store it, in order, while it awaits
processing. In a computer network, when data packets are sent out from a
host, they enter a queue where they await processing by the operating
system.  The operating system then decides which queue and which
packet(s) from that queue should be processed. The order in which the
operating system selects the packets to process can affect network
performance. For example, imagine a user running two network
applications: SSH and FTP. Ideally, the SSH packets should be
processed before the FTP packets because of the time-sensitive nature
of SSH; when a key is typed in the SSH client, an immediate response 
is expected, but an FTP transfer being delayed by a few extra
seconds hardly bears any notice.  But what happens if the router
handling these connections processes a large chunk of packets from the
FTP connection before processing the SSH connection? Packets from the
SSH connection will remain in the queue (or possibly be dropped by the
router if the queue isn't big enough to hold all of the packets)
and the SSH session may appear to lag or slow down.  By modifying the
queueing strategy being used, network bandwidth can be shared fairly
between different applications, users, and computers.

<p>
Note that queueing is only useful for packets in the <i>outbound</i>
direction. Once a packet arrives on an interface in the inbound
direction it's already too late to queue it -- it's already consumed
network bandwidth to get to the interface that just received it. The
only solution is to enable queueing on the adjacent router or, if the
host that received the packet is acting as a router, to enable queueing
on the internal interface where packets exit the router.
d105 9
a113 6
The scheduler is what decides which queues to process and in what order.
By default, OpenBSD uses a First In First Out (FIFO) scheduler. A FIFO
queue works like the line-up at a supermarket or a bank -- the first
item into the queue is the first processed. As new packets arrive they
are added to the end of the queue. If the queue becomes full, newly
arriving packets are dropped.  This is known as tail-drop.
d116 1
a116 1
OpenBSD supports two additional schedulers:
d124 18
a141 15
Class Based Queueing (CBQ) is a queueing algorithm that divides a
network connection's bandwidth among multiple queues or classes.  Each
queue then has traffic assigned to it based on source or destination
address, port number, protocol, etc.  A queue may optionally be
configured to borrow bandwidth from its parent queue if the parent is
being under-utilized.  Queues are also given a priority such that those
containing interactive traffic, such as SSH, can have their packets
processed ahead of queues containing bulk traffic, such as FTP.

<p>
CBQ queues are arranged in an hierarchical manner.  At the top of the
hierarchy is the root queue which defines the total amount of bandwidth
available.  Child queues are created under the root queue, each of
which can be assigned some portion of the root queue's bandwidth.  For
example, queues might be defined as follows:
d143 1
a143 1
<dd>Root Queue (2Mbps)
d145 3
a147 3
	<dd>Queue A (1Mbps)
	<dd>Queue B (500Kbps)
	<dd>Queue C (500Kbps)
d152 3
a154 2
In this case, the total available bandwidth is set to 2 megabits per
second (Mbps). This bandwidth is then split among three child queues.
d157 6
a162 4
The hierarchy can further be expanded by defining queues within queues.
To split bandwidth equally among different users and also classify their
traffic so that certain protocols don't starve others for bandwidth, a
queueing structure like this might be defined:
d164 1
a164 1
<dd>Root Queue (2Mbps)
d166 1
a166 1
	<dd>UserA (1Mbps)
d171 1
a171 1
	<dd>UserB (1Mbps)
d177 1
a177 1
			<dd>other (650Kbps)
d184 2
a185 2
Note that at each level the sum of the bandwidth assigned to each of the
queues is not more than the bandwidth assigned to the parent queue.
d188 4
a191 3
A queue can be configured to borrow bandwidth from its parent if the
parent has excess bandwidth available due to it not being used by
the other child queues.  Consider a queueing setup like this:
d193 1
a193 1
<dd>Root Queue (2Mbps)
d195 1
a195 1
	<dd>UserA (1Mbps)
d198 1
a198 1
		<dd>ftp (900Kbps, borrow)
d200 1
a200 1
	<dd>UserB (1Mbps)
d205 18
a222 14
If traffic in the <tt>ftp</tt> queue exceeds 900Kbps and traffic in the
<tt>UserA</tt> queue is less than 1Mbps (because the ssh queue is using
less than its assigned 100Kbps), the <tt>ftp</tt> queue will borrow the
excess bandwidth from <tt>UserA</tt>.  In this way the <tt>ftp</tt>
queue is able to use more than its assigned bandwidth when it faces
overload.  When the <tt>ssh</tt> queue increases its load, the borrowed
bandwidth will be returned.

<p>
CBQ assigns each queue a priority level. Queues with a higher priority
are preferred during congestion over queues with a lower priority as
long as both queues share the same parent (in other words, as long as
both queues are on the same branch in the hierarchy).  Queues with the
same priority are processed in a round-robin fashion.  For example:
d224 1
a224 1
<dd>Root Queue (2Mbps)
d226 1
a226 1
	<dd>UserA (1Mbps, priority 1)
d228 2
a229 2
		<dd>ssh (100Kbps, priority 5)
		<dd>ftp (900Kbps, priority 3)
d231 1
a231 1
	<dd>UserB (1Mbps, priority 1)
d236 11
a246 9
CBQ will process the <tt>UserA</tt> and <tt>UserB</tt> queues in a
round-robin fashion -- neither queue will be preferred over the other.
During the time when the <tt>UserA</tt> queue is being processed, CBQ
will also process its child queues.  In this case, the <tt>ssh</tt>
queue has a higher priority and will be given preferential treatment
over the <tt>ftp</tt> queue if the network is congested.  Note how the
<tt>ssh</tt> and <tt>ftp</tt> queues do not have their priorities
compared to the <tt>UserA</tt> and <tt>UserB</tt> queues because they
are not all on the same branch in the hierarchy.
d249 2
a250 2
For a more detailed look at the theory behind CBQ, please visit
<a href="http://www.icir.org/floyd/cbq.html">this website</a>.
d254 4
a257 4
Priority Queueing (PRIQ) assigns multiple queues to a network
interface with each queue being given a unique priority level. A queue
with a higher priority is <i>always</i> processed ahead of a queue with
a lower priority. 
d260 4
a263 4
The queueing structure in PRIQ is flat -- you cannot define queues
within queues. The root queue is defined, which sets the total amount of
bandwidth that is available, and then sub queues are defined under the
root. Consider the following example:
d265 1
a265 1
<dd>Root Queue (2Mbps)
d267 3
a269 3
	<dd>Queue A (priority 1)
	<dd>Queue B (priority 2)
	<dd>Queue C (priority 3)
d274 18
a291 14
The root queue is defined as having 2Mbps of bandwidth available to it
and three subqueues are defined. The queue with the highest priority
(the highest priority number) is served first. Once all the packets
in that queue are processed, or if the queue is found to be empty, PRIQ
moves onto the queue with the next highest priority.  Within a given
queue, packets are processed in a First In First Out (FIFO) manner.

<p>
It is important to note that when using PRIQ you must plan your queues
very carefully.  Because PRIQ <i>always</i> processes a higher priority
queue before a lower priority one, it's possible for a high priority
queue to cause packets in a lower priority queue to be delayed or
dropped if the high priority queue is receiving a constant stream of
packets.
d295 47
a341 40
Random Early Detection (RED) is a congestion avoidance algorithm. Its
job is to avoid network congestion by making sure that the queue doesn't
become full. It does this by continually calculating the average length
(size) of the queue and comparing it to two thresholds, a minimum
threshold and a maximum threshold. If the average queue size is below
the minimum threshold then no packets will be dropped. If the average is
above the maximum threshold then <i>all</i> newly arriving packets will
be dropped. If the average is between the threshold values then packets
are dropped based on a probability calculated from the average queue
size. In other words, as the average queue size approaches the maximum
threshold, more and more packets are dropped. When dropping packets,
RED randomly chooses which connections to drop packets from.
Connections using larger amounts of bandwidth have a higher probability
of having their packets dropped.

<p>
RED is useful because it avoids a situation known as global
synchronization and it is able to accommodate bursts of traffic.  Global
synchronization refers to a loss of total throughput due to packets
being dropped from several connections at the same time. For example, if
congestion occurs at a router carrying traffic for 10 FTP connections
and packets from all (or most) of these connections are dropped (as is
the case with FIFO queueing), overall throughput will drop sharply. This
isn't an ideal situation because it causes all of the FTP connections to
reduce their throughput and also means that the network is no longer
being used to its maximum potential.  RED avoids this by randomly
choosing which connections to drop packets from instead of choosing all
of them. Connections using large amounts of bandwidth have a higher
chance of their packets being dropped. In this way, high bandwidth
connections will be throttled back, congestion will be avoided, and
sharp losses of overall throughput will not occur. In addition, RED is
able to handle bursts of traffic because it starts to drop packets
<i>before</i> the queue becomes full. When a burst of traffic comes
through there will be enough space in the queue to hold the new packets.

<p>
RED should only be used when the transport protocol is capable of
responding to congestion indicators from the network. In most cases
this means RED should be used to queue TCP traffic and not UDP or ICMP
traffic.
d344 2
a345 2
For a more detailed look at the theory behind RED, please visit
<a href="http://www.icir.org/floyd/red.html">this website</a>.
d349 7
a355 6
Explicit Congestion Notification (ECN) works in conjunction with RED to
notify two hosts communicating over the network of any congestion along
the communication path. It does this by enabling RED to set a flag in
the packet header instead of dropping the packet. Assuming the sending
host has support for ECN, it can then read this flag and throttle back
its network traffic accordingly.
d358 1
a358 1
For more information on ECN, please refer to 
d362 2
a363 2
<h2>Configuring Queueing</h2>
Since OpenBSD 3.0 the 
d365 16
a380 16
>Alternate Queueing (ALTQ)</a> queueing implementation has been a part of
the base system. Starting with OpenBSD 3.3 ALTQ has been integrated into
PF.  OpenBSD's ALTQ implementation supports the Class Based Queueing
(CBQ) and Priority Queueing (PRIQ) schedulers. It also supports Random
Early Detection (RED) and Explicit Congestion Notification (ECN).

<p>
Because ALTQ has been merged with PF, PF must be enabled for queueing to
work. Instructions on how to enable PF can be found in the 
<a href="config.html#activate">configuration section</a>.

<p>
Queueing is configured in <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.4"
>/etc/pf.conf</a></tt>. There are two types of directives that are used
to configure queueing:
d382 3
a384 3
<li><tt>altq on</tt> - enables queueing on an interface, defines which
scheduler to use, and creates the root queue
<li><tt>queue</tt> - defines the properties of a child queue
d388 1
a388 1
The syntax for the <tt>altq on</tt> directive is:
d398 19
a416 15
<li><tt><i>interface</i></tt> - the network interface to activate queueing on.
<li><tt><i>scheduler</i></tt> - the queueing scheduler to use. Possible values are 
<tt>cbq</tt> and <tt>priq</tt>. Only one scheduler may be active on an
interface at a time.
<li><tt><i>bw</i></tt> - the total amount of bandwidth available to the scheduler.
This may be specified as an absolute value using the suffixes <tt>b</tt>,
<tt>Kb</tt>, <tt>Mb</tt>, and <tt>Gb</tt> to represent bits, kilobits,
megabits, and gigabits per second, respectively or as a percentage of the
<tt><i>interface</i></tt> bandwidth.
<li><tt><i>qlim</i></tt> - the maximum number of packets to hold in the queue. 
This parameter is optional. The default is 50.
<li><tt><i>size</i></tt> - the size of the token bucket regulator in bytes. If not
specified, the size is set based on the <tt><i>interface</i></tt> bandwidth.
<li><tt><i>queue_list</i></tt> - a list of child queues to create under the root
queue.
d420 1
a420 1
For example:
d422 1
d424 1
d426 3
a428 3
This enables CBQ on the fxp0 interface. The total bandwidth available is
set to 2Mbps. Three child queues are defined: <tt>std</tt>,
<tt>ssh</tt>, and <tt>ftp</tt>.
d431 1
a431 1
The syntax for the <tt>queue</tt> directive is:
d434 2
a435 2
queue <i>name</i> bandwidth <i>bw</i> priority <i>pri</i> qlimit
<i>qlim</i> \<br>
d442 28
a469 20
<li><tt><i>name</i></tt> - the name of the queue. This must match the
name of one of the queues defined in the <tt>altq on</tt> directive's
<tt><i>queue_list</i></tt>. For <tt>cbq</tt> it can also match the name
of a queue in a previous <tt>queue</tt> directive's
<tt><i>queue_list</i></tt>. Queue names must be no longer than 15 characters.
<li><tt><i>bw</i></tt> - the total amount of bandwidth available to the scheduler.
This may be specified as an absolute value using the suffixes <tt>b</tt>,
<tt>Kb</tt>, <tt>Mb</tt>, and <tt>Gb</tt> to represent bits, kilobits,
megabits, and gigabits per second, respectively or as a percentage of the
<tt><i>interface</i></tt> bandwidth.
<li><tt><i>pri</i></tt> - the priority of the queue. For <tt>cbq</tt> the
priority range is 0 to 7 and for <tt>priq</tt> the range is 0 to 15.
Priority 0 is the lowest priority. When not specified, a default of 1 is
used.
<li><tt><i>qlim</i></tt> - the maximum number of packets to hold in the queue. 
When not specified, a default of 50 is used.
<li><tt><i>scheduler</i></tt> - the scheduler being used, either <tt>cbq</tt>
or <tt>priq</tt>. Must be the same as the root queue.
<li><tt><i>sched_options</i></tt> - further options may be passed to the scheduler
to control its behavior:
d471 14
a484 11
	<li><tt>default</tt> - defines a default queue where all packets not
	matching any other queue will be queued. Exactly one default queue
	is required.
	<li><tt>red</tt> - enables Random Early Detection (RED) on this queue.
	<li><tt>rio</tt> - enables RED with IN/OUT. In this mode, RED will
	maintain multiple average queue lengths and multiple threshold
	values, one for each IP Quality of Service level.
	<li><tt>ecn</tt> - enables Explicit Congestion Notification (ECN) on
	this queue. <tt>Ecn</tt> implies <tt>red</tt>.
	<li><tt>borrow</tt> - the queue can borrow bandwidth from its parent. This can
	only be specified when using the <tt>cbq</tt> scheduler.
d486 4
a489 3
<li><tt><i>queue_list</i></tt> - a list of child queues to create under this
queue. A <tt><i>queue_list</i></tt> may only be defined when using the
<tt>cbq</tt> scheduler.
d493 1
a493 1
Continuing with the example above:
d505 10
a514 9
Here the parameters of the previously defined child queues are set. The
<tt>std</tt> queue is assigned a bandwidth of 50% of the root queue's
bandwidth (or 1Mbps) and is set as the default queue. The <tt>ssh</tt>
queue defines two child queues, <tt>ssh_login</tt> and
<tt>ssh_bulk</tt>. The <tt>ssh_login</tt> queue is given a higher
priority than <tt>ssh_bulk</tt> and both have ECN enabled.  The
<tt>ftp</tt> queue is assigned a bandwidth of 500Kbps and given a
priority of 3. It can also borrow bandwidth when extra is available and
has RED enabled. 
d517 1
a517 1
<h3>Assigning Traffic to a Queue</h3>
d519 5
a523 3
To assign traffic to a queue, the <tt>queue</tt> keyword is used in
conjunction with PF's <a href="filter.html">filter rules</a>. For example,
consider a set of filtering rules containing a line such as:
d529 3
a531 2
Packets matching that rule can be assigned to a specific queue by using
the <tt>queue</tt> keyword:
d537 3
a539 3
When using the <tt>queue</tt> keyword with <tt>block</tt> directives, any
resulting TCP RST or ICMP Unreachable packets are assigned to the specified
queue.
d542 3
a544 2
Note that queue tagging can happen on an interface other than the one
defined in the <tt>altq on</tt> directive:
d556 19
a574 15
Queueing is enabled on fxp0 but the tagging takes place on dc0. If 
packets matching the <tt>pass</tt> rule exit from interface fxp0, they
will be queued in the <tt>ftp</tt> queue. This type of queueing can be
very useful on routers.

<p>
Normally only one queue name is given with the <tt>queue</tt> keyword,
but if a second name is specified that queue will be used for packets
with a <a href="http://www.rfc-editor.org/rfc/rfc791.txt">Type of
Service (ToS)</a> of low-delay and for TCP ACK packets with no data payload.
A good example of this is found when using SSH. SSH login sessions will
set the ToS to low-delay while SCP and SFTP sessions will not. PF can
use this information to queue packets belonging to a login connection in a
different queue than non-login connections. This can be useful to prioritize
login connection packets over file transfer packets.
d580 22
a601 19
This assigns packets belonging to SSH login connections to the
<tt>ssh_login</tt> queue and packets belonging to SCP and SFTP
connections to the <tt>ssh_bulk</tt> queue. SSH login connections will
then have their packets processed ahead of SCP and SFTP connections
because the <tt>ssh_login</tt> queue has a higher priority.

<p>
Assigning TCP ACK packets to a higher priority queue is useful on
asymmetric connections, that is, connections that have different upload
and download bandwidths such as ADSL lines. With an ADSL line, if the
upload channel is being maxed out and a download is started, the
download will suffer because the TCP ACK packets it needs to
send will run into congestion when they try to pass through the upload
channel. Testing has shown that to achieve the best results, the
bandwidth on the upload queue should be set to a value less than what
the connection is capable of. For instance, if an ADSL line has a max
upload of 640Kbps, setting the root queue's <tt>bandwidth</tt> to a value
such as 600Kb should result in better performance. Trial and error will
yield the best <tt>bandwidth</tt> setting.
d604 2
a605 2
When using the <tt>queue</tt> keyword with rules that <tt>keep
state</tt> such as:
d614 7
a620 6
PF will record the queue in the state table entry so that packets
traveling back out fxp0 that match the stateful connection will
end up in the <tt>ssh</tt> queue. Note that even though the <tt>queue</tt>
keyword is being used on a rule filtering incoming traffic, the goal is
to specify a queue for the corresponding outgoing traffic; the above
rule does not queue incoming packets.
d623 1
a623 1
<h2>Example #1: Small, Home Network</h2>
d635 4
a638 4
In this example, OpenBSD is being used on an Internet gateway for a small
home network with three workstations. The gateway is performing packet
filtering and NAT duties. The Internet connection is via an ADSL line
running at 2Mbps down and 640Kbps up.
d641 1
a641 1
The queueing policy for this network:
d643 9
a651 8
<li>Reserve 80Kbps of download bandwidth for Bob so he can play his
online games without being lagged by Alice or Charlie's downloads. Allow
Bob to use more than 80Kbps when it's available.
<li>Interactive SSH and instant message traffic will have a higher
priority than regular traffic.
<li>DNS queries and replies will have the second highest priority.
<li>Outgoing TCP ACK packets will have a higher priority than all other
outgoing traffic.
d655 5
a659 5
Below is the ruleset that meets this network policy. Note that only the
<tt>pf.conf</tt> directives that apply directly to the above policy are
present; <a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">options</a>,
etc., are not shown.
d665 4
a668 4
# enable queueing on the external interface to control traffic going to
# the Internet. use the priq scheduler to control only priorities. set
# the bandwidth to 610Kbps to get the best performance out of the TCP
# ACK queue.
d673 7
a679 7
# define the parameters for the child queues.
# std_out      - the standard queue. any filter rule below that does not
#                explicitly specify a queue will have its traffic added
#                to this queue.
# ssh_im_out   - interactive SSH and various instant message traffic.
# dns_out      - DNS queries.
# tcp_ack_out  - TCP ACK packets with no data payload.
d686 3
a688 3
# enable queueing on the internal interface to control traffic coming in
# from the Internet. use the cbq scheduler to control bandwidth. max
# bandwidth is 2Mbps.
d692 8
a699 8
# define the parameters for the child queues.
# std_in      - the standard queue. any filter rule below that does not
#               explicitly specify a queue will have its traffic added
#               to this queue.
# ssh_im_in   - interactive SSH and various instant message traffic.
# dns_in      - DNS replies.
# bob_in      - bandwidth reserved for Bob's workstation. allow him to
#               borrow.
d707 1
a707 1
# ... in the filtering section of pf.conf ...
d716 1
a716 1
# filter rules for fxp0 inbound
d719 1
a719 1
# filter rules for fxp0 outbound
d731 1
a731 1
# filter rules for dc0 inbound
d735 1
a735 1
# filter rules for dc0 outbound
d750 1
a750 1
<h2>Example #2: Company Network</h2>
d753 1
a753 1
  ( IT Dept )  [ Boss's PC ]
d764 8
a771 7
In this example, the OpenBSD host is acting as a firewall for a company
network. The company runs a WWW server in the DMZ portion of their
network where customers upload their websites via FTP. The IT department
has their own subnet connected to the main network, and the boss has a PC
on his desk that's used for email and surfing the web. The connection to
the Internet is via a T1 line running at 1.5Mbps in both directions. All
other network segments are using Fast Ethernet (100Mbps).
d774 1
a774 1
The network administrator has decided on the following policy:
d776 13
a788 12
<li>Limit traffic between the WWW server and the Internet to 500Kbps in
each direction.
<li>No bandwidth limit on traffic between the WWW server and the
internal network.
<li>Give HTTP traffic between the WWW server and the Internet a higher
priority than other traffic between the WWW server and the Internet
(such as FTP uploads).
<li>Reserve 500Kbps for the IT Dept network so they can download the
latest software updates in a timely manner. They should be able to use
more than 500Kbps when extra bandwidth is available.
<li>Give traffic between the boss's PC and the Internet a higher
priority than other traffic to/from the Internet.
d791 5
a795 6
<p>
Below is the ruleset that meets this network policy. Note that only the
<tt>pf.conf</tt> directives that apply directly to the above policy are
present; <a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">options</a>,
etc., are not shown.
d801 4
a804 3
# enable queueing on the external interface to queue packets going out
# to the Internet. use the cbq scheduler so that the bandwidth use of
# each queue can be controlled. the max outgoing bandwidth is 1.5Mbps.
d808 9
a816 8
# define the parameters for the child queues.
# std_ext        - the standard queue. also the default queue for
#                  outgoing traffic on fxp0.
# www_ext        - container queue for WWW server queues. limit to
#                  500Kbps.
#   www_ext_http - http traffic from the WWW server
#   www_ext_misc - all non-http traffic from the WWW server
# boss_ext       - traffic coming from the boss's computer
d824 8
a831 6
# enable queueing on the internal interface to control traffic coming
# from the Internet or the DMZ. use the cbq scheduler to control the
# bandwidth of each queue. bandwidth on this interface is set to the
# maximum. traffic coming from the DMZ will be able to use all of this
# bandwidth while traffic coming from the Internet will be limited to
# 1.0Mbps (because 0.5Mbps (500Kbps) is being allocated to fxp1).
d835 8
a842 8
# define the parameters for the child queues.
# net_int    - container queue for traffic from the Internet. bandwidth
#              is 1.0Mbps.
#   std_int  - the standard queue. also the default queue for outgoing
#              traffic on dc0.
#   it_int   - traffic to the IT Dept network.
#   boss_int - traffic to the boss's PC.
# www_int    - traffic from the WWW server in the DMZ.
d850 7
a856 6
# enable queueing on the DMZ interface to control traffic destined for
# the WWW server. cbq will be used on this interface since detailed
# control of bandwidth is necessary. bandwidth on this interface is set
# to the maximum. traffic from the internal network will be able to use
# all of this bandwidth while traffic from the Internet will be limited
# to 500Kbps.
d860 6
a865 5
# define the parameters for the child queues.
# internal_dmz   - traffic from the internal network.
# net_dmz        - container queue for traffic from the Internet.
#   net_dmz_http - http traffic.
#   net_dmz_misc - all non-http traffic. this is also the default queue.
d867 1
a867 1
queue internal_dmz      # no special settings needed
d873 1
a873 1
# ... in the filtering section of pf.conf ...
d883 1
a883 1
# default deny
d886 1
a886 1
# filter rules for fxp0 inbound
d892 1
a892 1
# filter rules for fxp0 outbound
d896 1
a896 1
# filter rules for dc0 inbound
d903 1
a903 1
# filter rules for dc0 outbound
d906 1
a906 1
# filter rules for fxp1 inbound
d910 1
a910 1
# filter rules for fxp1 outbound
d922 3
a924 3
[<a href="scrub.html">Previous: Scrub</a>]
[<a href="index.html">Contents</a>]
[<a href="nat.html">Next: Network Address Translation</a>]
d928 1
a928 1
<a href="../../de/index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
d932 3
a934 3
Originally [OpenBSD: queueing.html,v 1.13 ]<br>
$Translation: queueing.html,v 1.1 2003/11/27 17:34:57 sl Exp $<br>
$OpenBSD$
@

