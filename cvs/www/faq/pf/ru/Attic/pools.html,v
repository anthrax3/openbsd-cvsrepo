head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2014.04.01.17.14.11;	author nick;	state dead;
branches;
next	1.4;

1.4
date	2012.11.02.07.24.05;	author ajacoutot;	state Exp;
branches;
next	1.3;

1.3
date	2012.09.20.06.25.15;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.24.12.38.10;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.01.21.41.39;	author tobias;	state Exp;
branches;
next	;


desc
@@


1.5
log
@
Abandon translations, per deraadt@@ and ajacoutot@@.
@
text
@<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Пулы адресов и балансировка нагрузки</title>
<link rev="made" href="mailto:www@@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, 2004 Joel Knight <enabled@@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../ru/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="queueing.html">Предыдущая: Управление очередями пакетов и приоритезация</a>]
[<a href="index.html">Содержание</a>]
[<a href="tagging.html">Следующая: Packet Tagging</a>]

<p>
<h1>
<font color="#e00000">PF: Пулы адресов и балансировка нагрузки</font>
</h1>

<hr>

<h3>Содержание</h3>
<ul>
<li><a href="#intro">Введение</a>
<li><a href="#nat">Пул адресов NAT</a>
<li><a href="#incoming">Балансировка нагрузки входящих соединений</a>
<li><a href="#outgoing">Балансировка нагрузки исходящих соединений</a>
	<ul>
	<li><a href="#outexample">Примеры правил</a>
	</ul>
</ul>

<hr>

<a name="intro"></a>
<h2>Введение</h2>
Адресный пул представляет собой два или более интерфейсов, которые 
используются совместно группой пользователей. Адресный пул может 
быть указан в качестве целевого адреса в директивах <tt>nat-to</tt>, 
<tt>rdr-to</tt>, <tt>route-to</tt>, <tt>reply-to</tt>, и в дерективе
<tt>dup-to</tt> в качестве опций фильтра
(<a href="filter.html">filter</a>).

<p>
Существуют четыре метода использования адресного пула:
<ul>
<li><tt>bitmask (битовая маска)</tt>- указывает сетевую часть пула 
адресов с помощью которой будем модифицирован адрес (адрес источник 
для правил <tt>nat-to</tt>, адрес приемник для правил <tt>rdr-to</tt>).
Пример: если адресный пул определен как 192.0.2.1/24 и адрес, который 
необходимо модифицировать, 10.0.0.50, то результирующий адрес будет 
вычислен как 192.0.2.50. Если адресный пул определен как 192.0.2.1/25 и 
адрес, который необходимо модифицировать, 10.0.0.130, то результирующий 
адрес будет вычислен как 192.0.2.2.
<li><tt>random (случайный адрес)</tt> - адрес выбирается случайным
образом из пула.
<li><tt>source-hash (хеш источник)</tt> - используется хэш функция от 
адреса источника для определения какой адрес из пула бедет использован. 
Этот метод гарантирует, что адрес источник всегда будет перенаправлен 
на соответствующий ему адрес пула. Ключ, который используется для 
алгоритма хеширования, может быть указан дополнительно после ключевого 
<tt>source-hash </tt>в шестнадцатеричном формате, или как строка. По 
умолчанию,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+5.2"
>pfctl(8)</a> будет создавать случайный ключ каждый раз при загрузка 
набора правил.
<li><tt>round-robin (циклический)</tt> - адреса пула выбираются 
последовательно по кругу. Этот метод используется по умолчанию, а 
также ТОЛЬКО этот метод используется, когда адресный пул объявлен 
с использованием таблиц.
(<a href="tables.html">table</a>).
</ul>

<p>
За исключением циклического метода, адресный пул должен быть описан
как сетевой блок
<a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>
(Classless Inter-Domain Routing). <tt>Цикличейкий</tt> метод 
допускает использование множества отдельных адресов определенных
с помощью списка (<a href="macros.html#lists">list</a>) или
таблицы (<a href="tables.html">table</a>).

<p>
Опция <tt>sticky-address</tt> может быть использована с пулами типа
<tt>random</tt> и <tt>циклического</tt> типа для обеспечения того условия,
что адрес источника всегда будет соотнесен тому же адресу перенаправления.

<a name="nat"></a>
<h2>Адресный пул NAT</h2>
Адресный пул может быть использован в качестве адреса для преобразования
в правилах <a href="nat.html"><tt>nat-to</tt></a>. Соединения будут
получать свой адрес источник путем преобразования его в адреса из пула,
указанным способом. Это может быть полезным в ситуации, когда PF
обслуживает с помощью NAT очень большую сеть. Так как число соединений,
преобразованных с помощью NAT, ограниченно добавление дополнительных
адресов позволяет шлюзу масштабироваться и обслуживать большее
количество клиентов.

<p>
В этом примере пул из двух адресов используется для преобразования
исходящих пакетов. Для каждого исходящего соединения PF будет
циклически выбирать адрес способом round-robin.
<blockquote>
<tt>
match out on $ext_if inet nat-to { 192.0.2.5, 192.0.2.10 }
</tt>
</blockquote>

<p>
Одним из недостатков этого метода является то, что соединения с одного 
внутреннего адреса не могут быть всегда преобразованы в тот же конечный 
адрес. Это может препятствовать, например, просмотру сайтов, которые 
отслеживают доступ пользователей основываясь на IP его адресе. 
Альтернативный способ  - использовать метод <tt>source-hash</tt>. 
Тогда каждый внутренний адрес всегда будет преобразован в один и тот же 
конечный адрес. Для этого адресный пул должен быть описан с помощью 
сетевого блока
<a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<blockquote>
<tt>
match out on $ext_if inet nat-to 192.0.2.4/31 source-hash
</tt>
</blockquote>

<p>
Это правило использует пул адресов 192.0.2.4/31
(192.0.2.4 — 192.0.2.5) для преобразования адреса исходящих пакетов.
Каждый внутренний адрес будет всегда преобразован в один и тот же
адрес благодаря ключевому слову <tt>source-hash</tt>.

<a name="incoming"></a>
<h2>Балансировка нагрузки входящих соединений</h2>
Адресный пул также может быть использован для балансировки нагрузки 
входящих соединений. Например, входящие соединения к web серверу, 
могут быть распределены между web серверами в ферме:
<blockquote>
<tt>
web_servers = "{ 10.0.0.10, 10.0.0.11, 10.0.0.13 }"<br>
<br>
match in on $ext_if proto tcp to port 80 rdr-to $web_servers \<br>
&nbsp;&nbsp;&nbsp;&nbsp;round-robin sticky-address
</tt>
</blockquote>

<p>
Последовательные соединения будут перенаправлены на web серверы циклическим
методом. Причем соединения с одних и тех же адресов будут перенаправлены 
на одни и те же web серверы.
"Липкие связи" будут существовать до тех пор пока они будут 
привязаны к своим соединениям.
Как только соединения закрываются, исчезает и липкая связь. В будущем 
соединения с этого адреса будут перенаправлены к следующему web серверу 
в циклическом порядке.

<a name="outgoing"></a>
<h2>Балансировка нагрузки исходящего тафика</h2>
Пул адресов может быть использован в комбинации с опцией фильтра
<tt>route-to</tt> для балансировки двух или более Internet соединений,
когда невозможно использовать правильный протокол multipath-маршрутизации
(например
<a href="http://www.rfc-editor.org/rfc/rfc1771.txt">BGP4</a>).
При использовании <tt>route-to</tt> с адресным пулом <tt>циклического</tt>
типа исходящие соединения могут быть равномернораспределены между несколькими 
исходящими маршрутами.

<p>
Еще одна дополнительная порция информации, необходимая для
этого - это IP адрес соседнего роутера на каждом Internet соединении.
Она необходима опции <tt>route-to</tt> для управления полем
"приемник" (destination) исходящих пакетов.

<p>
Приведенный пример демонстрирует возможность балансировки исходящего 
трафика через два Internet соединения:
<blockquote>
<tt>
lan_net = "192.168.0.0/24"<br>
int_if &nbsp;= "dc0"<br>
ext_if1 = "fxp0"<br>
ext_if2 = "fxp1"<br>
ext_gw1 = "68.146.224.1"<br>
ext_gw2 = "142.59.76.1"<br>
<br>
pass in on $int_if from $lan_net \<br>
&nbsp;&nbsp;&nbsp;route-to { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) }\<br>
&nbsp;&nbsp;&nbsp;round-robin
</tt>
</blockquote>

<p>
Опция <tt>route-to</tt> применяется в <i>входящему</i> трафику на 
<i>внутреннем</i> интерфейсе, чтобы указать исходящий сетевой интерфейс,
трафик которого будет балансироваться через соответствующие шлюзы.
Заметьте, что опция <tt>route-to</tt> может присутствовать в 
<i>каждом</i> правиле фильтра, которое предназначено для балансировки 
трафика (она не может быть использованая с правилом <tt>match</tt>).

<p>
Чтобы быть уверенным, что пакеты с адресом источником, принадлежащие
<tt>$ext_if1</tt>, всегда перенаправляются на <tt>$ext_gw1</tt> (и
аналогично для <tt>$ext_if2</tt> и <tt>$ext_gw2</tt>), в правила
необходимо добавить следующие две строки:
<blockquote>
<tt>
pass out on $ext_if1 from $ext_if2 \<br>
&nbsp;&nbsp;&nbsp;route-to ($ext_if2 $ext_gw2)<br>
pass out on $ext_if2 from $ext_if1 \<br>
&nbsp;&nbsp;&nbsp;route-to ($ext_if1 $ext_gw1) 
</tt>
</blockquote>

<p>
В конечном счете, NAT может быть использован на каждом исходящем
интерфейсе:
<blockquote>
<tt>
match out on $ext_if1 from $lan_net nat-to ($ext_if1)<br>
match out on $ext_if2 from $lan_net nat-to ($ext_if2)
</tt>
</blockquote>

<a name="outexample"></a>
<p>
Сложный пример балансировки исходящего трафика может выглядеть
как указано ниже:

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
lan_net = "192.168.0.0/24"
int_if  = "dc0"
ext_if1 = "fxp0"
ext_if2 = "fxp1"
ext_gw1 = "68.146.224.1"
ext_gw2 = "142.59.76.1"

#  исходящие соединения nat на каждый сетевой интерфейс
match out on $ext_if1 from $lan_net nat-to ($ext_if1)
match out on $ext_if2 from $lan_net nat-to ($ext_if2)

#  по умолчанию блокируем все
block in
block out

#  разрешаем все исходящие пакеты на внутреннем интерфейсе
pass out on $int_if to $lan_net
#  разрешаем все входящие пакеты предназначенные самому шлюзу
pass in quick on $int_if from $lan_net to $int_if
#  балансируем исходящий трафик из внутренней сети. 
pass in on $int_if from $lan_net \
    route-to { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) } \
    round-robin
#  оставляем трафик https на одном соединении; некоторые web приложения
#  для большей безопасности не позволяют менять его в течение сессии
pass in on $int_if proto tcp from $lan_net to port https \
    route-to ($ext_if1 $ext_gw1)

#  обычное правило "pass out" для внешних интерфейсов
pass out on $ext_if1
pass out on $ext_if2

#  пропускаем пакеты с любых IP на $ext_if1 и $ext_gw1 
#  и аналогично на $ext_if2 и $ext_gw2
pass out on $ext_if1 from $ext_if2 route-to ($ext_if2 $ext_gw2)
pass out on $ext_if2 from $ext_if1 route-to ($ext_if1 $ext_gw1)
</pre>
</td></tr>
</table>

<p>
[<a href="queueing.html">Предыдущая: Очередь пакетов и приоритезация</a>]
[<a href="index.html">Содержание</a>]
[<a href="tagging.html">Следующая: Packet Tagging</a>]

<p>
<hr>
<a href="index.html"><img src="../../../images/back.gif" alt="[back]" border="0" width="24" height="24"></a> 
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: pools.html,v 1.32 ]<br>
$Translation: pools.html,v 1.7 2012/11/01 21:42:11 alex Exp $<br>
-->
$OpenBSD: pools.html,v 1.4 2012/11/02 07:24:05 ajacoutot Exp $
</small>
 
</body>
</html>@


1.4
log
@Sync with Steelix CVS
@
text
@d313 1
a313 1
$OpenBSD$
@


1.3
log
@Sync with Steelix CVS
@
text
@d91 1
a91 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+5.1"
d310 2
a311 2
Originally [OpenBSD: pools.html,v 1.31 ]<br>
$Translation: pools.html,v 1.6 2012/09/19 19:30:41 alex Exp $<br>
@


1.2
log
@Sync with Steelix CVS
@
text
@d1 316
a316 315
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Пулы адресов и балансировка нагрузки</title>
<link rev="made" href="mailto:www@@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, 2004 Joel Knight <enabled@@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../ru/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="queueing.html">Предыдущая: Очередь пакетов и приоритезация</a>]
[<a href="index.html">Содержание</a>]
[<a href="tagging.html">Следующая: Packet Tagging</a>]

<p>
<h1>
<font color="#e00000">PF: Пулы адресов и балансировка нагрузки</font>
</h1>

<hr>

<h3>Содержание</h3>
<ul>
<li><a href="#intro">Введение</a>
<li><a href="#nat">Пул адресов NAT</a>
<li><a href="#incoming">Балансировка нагрузки входящих соединений</a>
<li><a href="#outgoing">Балансировка нагрузки исходящих соединений</a>
	<ul>
	<li><a href="#outexample">Примеры правил</a>
	</ul>
</ul>

<hr>

<a name="intro"></a>
<h2>Введение</h2>
Адресный пул представляет собой два или более интерфейсов, которые 
используются совместно группой пользователей. Адресный пул может 
быть указан в качестве целевого адреса в директивах <tt>nat-to</tt>, 
<tt>rdr-to</tt>, <tt>route-to</tt>, <tt>reply-to</tt>, и в дерективе
<tt>dup-to</tt> в качестве опций фильтра
(<a href="filter.html">filter</a>).

<p>
Существуют четыре метода использования адресного пула:
<ul>
<li><tt>bitmask (битовая маска)</tt>- указывает сетевую часть пула 
адресов с помощью которой будем модифицирован адрес (адрес источник 
для правил <tt>nat-to</tt>, адрес приемник для правил <tt>rdr-to</tt>).
Пример: если адресный пул определен как 192.0.2.1/24 и адрес, который 
необходимо модифицировать, 10.0.0.50, то результирующий адрес будет 
вычислен как 192.0.2.50. Если адресный пул определен как 192.0.2.1/25 и 
адрес, который необходимо модифицировать, 10.0.0.130, то результирующий 
адрес будет вычислен как 192.0.2.2.
<li><tt>random (случайный адрес)</tt> - адрес выбирается случайным
образом из пула.
<li><tt>source-hash (хеш источник)</tt> - используется хэш функция от 
адреса источника для определения какой адрес из пула бедет использован. 
Этот метод гарантирует, что адрес источник всегда будет перенаправлен 
на соответствующий ему адрес пула. Ключ, который используется для 
алгоритма хеширования, может быть указан дополнительно после ключевого 
<tt>source-hash </tt>в шестнадцатеричном формате, или как строка. По 
умолчанию,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+5.1"
>pfctl(8)</a> будет создавать случайный ключ каждый раз при загрузка 
набора правил.
<li><tt>round-robin</tt> - адреса пула выбираются последовательно по 
кругу. Этот метод используется по умолчанию, а также ТОЛЬКО этот метод 
используется, когда адресный пул объявлен с использованием таблиц
(<a href="tables.html">table</a>).
</ul>

<p>
За исключением метода round-robin, адресный пул должен быть описан
как сетевой блок
<a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>
(Classless Inter-Domain Routing). Метод <tt>round-robin</tt>
допускает использование множества отдельных адресов определенных
с помощью списка (<a href="macros.html#lists">list</a>) или
таблицы (<a href="tables.html">table</a>).

<p>
Опция <tt>sticky-address</tt> может быть использована с пулами типа
<tt>random</tt> и <tt>round-robin</tt> для обеспечения того условия,
что адрес источника всегда будет соотнесен тому же адресу перенаправления.

<a name="nat"></a>
<h2>Адресный пул NAT</h2>
Адресный пул может быть использован в качестве адреса для преобразования
в правилах <a href="nat.html"><tt>nat-to</tt></a>. Соединения будут
получать свой адрес источник путем преобразования его в адреса из пула,
указанным способом. Это может быть полезным в ситуации, когда PF
обслуживает с помощью NAT очень большую сеть. Так как число соединений,
преобразованных с помощью NAT, ограниченно добавление дополнительных
адресов позволяет шлюзу масштабироваться и обслуживать большее
количество клиентов.

<p>
В этом примере пул из двух адресов используется для преобразования
исходящих пакетов. Для каждого исходящего соединения PF будет
циклически выбирать адрес способом  round-robin.
<blockquote>
<tt>
match out on $ext_if inet nat-to { 192.0.2.5, 192.0.2.10 }
</tt>
</blockquote>

<p>
Одним из недостатков этого метода является то, что соединения с одного 
внутреннего адреса не могут быть всегда преобразованы в тот же конечный 
адрес. Это может препятствовать, например, просмотру сайтов, которые 
отслеживают доступ пользователей основываясь на IP его адресе. 
Альтернативный способ  - использовать метод <tt>source-hash</tt>. 
Тогда каждый внутренний адрес всегда будет преобразован в один и тот же 
конечный адрес. Для этого адресный пул должен быть описан с помощью 
сетевого блока
<a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<blockquote>
<tt>
match out on $ext_if inet nat-to 192.0.2.4/31 source-hash
</tt>
</blockquote>

<p>
Это правило использует пул адресов 192.0.2.4/31
(192.0.2.4 — 192.0.2.5) для преобразования адреса исходящих пакетов.
Каждый внутренний адрес будет всегда преобразован в один и тот же
адрес благодаря ключевому слову <tt>source-hash</tt>.

<a name="incoming"></a>
<h2>Балансировка нагрузки входящих соединений</h2>
Адресный пул также может быть использован для балансировки нагрузки 
входящих соединений. Например, входящие соединения к web серверу, 
могут быть распределены между web серверами в ферме:
<blockquote>
<tt>
web_servers = "{ 10.0.0.10, 10.0.0.11, 10.0.0.13 }"<br>
<br>
match in on $ext_if proto tcp to port 80 rdr-to $web_servers \<br>
&nbsp;&nbsp;&nbsp;&nbsp;round-robin sticky-address
</tt>
</blockquote>

<p>
Последовательные соединения будут перенаправлены на web серверы методом 
round-robin, Причем соединения с одних и тех же адресов будут 
перенаправленя на одни и те же web серверы.
"Липкие связи" будут существовать до тех пор пока они будут 
привязаны к своим соединениям.
Как только соединения закрываются, исчезает и липкая связь. В будущем 
соединения с этого адреса будут перенаправлены к следующему web серверу 
в порядке round-robin.

<a name="outgoing"></a>
<h2>Балансировка нагрузки исходящего тафика</h2>
Пул адресов может быть использован в комбинации с опцией фильтра
<tt>route-to</tt> для балансировки двух или более Internet соединений,
когда невозможно использовать правильный протокол multipath-маршрутизации
(например
<a href="http://www.rfc-editor.org/rfc/rfc1771.txt">BGP4</a>).
При использовании <tt>route-to</tt> с адресным пулом типа
<tt>round-robin</tt> исходящие соединения могут быть равномерно
распределены между несколькими исходящими маршрутами.

<p>
Еще одна дополнительная порция информации, необходимая для
этого - это IP адрес соседнего роутера на каждом Internet соединении.
Она необходима опции <tt>route-to</tt> для управления полем
"приемник" (destination) исходящих пакетов.

<p>
Приведенный пример демонстрирует возможность балансировки исходящего 
трафика через два Internet соединения:
<blockquote>
<tt>
lan_net = "192.168.0.0/24"<br>
int_if &nbsp;= "dc0"<br>
ext_if1 = "fxp0"<br>
ext_if2 = "fxp1"<br>
ext_gw1 = "68.146.224.1"<br>
ext_gw2 = "142.59.76.1"<br>
<br>
pass in on $int_if from $lan_net \<br>
&nbsp;&nbsp;&nbsp;route-to { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) }\<br>
&nbsp;&nbsp;&nbsp;round-robin
</tt>
</blockquote>

<p>
Опция <tt>route-to</tt> применяется в <i>входящему</i> трафику на 
<i>внутреннем</i> интерфейсе, чтобы указать исходящий сетевой интерфейс,
трафик которого будет балансироваться через соответствующие шлюзы.
Заметьте, что опция <tt>route-to</tt> может присутствовать в 
<i>каждом</i> правиле фильтра, которое предназначено для балансировки 
трафика (она не может быть использованая с правилом <tt>match</tt>).

<p>
Чтобы быть уверенным, что пакеты с адресом источником, принадлежащие
<tt>$ext_if1</tt>, всегда перенаправляются на <tt>$ext_gw1</tt> (и
аналогично для <tt>$ext_if2</tt> и <tt>$ext_gw2</tt>), в правила
необходимо добавить следующие две строки:
<blockquote>
<tt>
pass out on $ext_if1 from $ext_if2 \<br>
&nbsp;&nbsp;&nbsp;route-to ($ext_if2 $ext_gw2)<br>
pass out on $ext_if2 from $ext_if1 \<br>
&nbsp;&nbsp;&nbsp;route-to ($ext_if1 $ext_gw1) 
</tt>
</blockquote>

<p>
В конечном счете, NAT может быть использован на каждом исходящем
интерфейсе:
<blockquote>
<tt>
match out on $ext_if1 from $lan_net nat-to ($ext_if1)<br>
match out on $ext_if2 from $lan_net nat-to ($ext_if2)
</tt>
</blockquote>

<a name="outexample"></a>
<p>
Сложный пример балансировки исходящего трафика может выглядеть
как указано ниже:

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
lan_net = "192.168.0.0/24"
int_if  = "dc0"
ext_if1 = "fxp0"
ext_if2 = "fxp1"
ext_gw1 = "68.146.224.1"
ext_gw2 = "142.59.76.1"

#  исходящие соединения nat на каждый сетевой интерфейс
match out on $ext_if1 from $lan_net nat-to ($ext_if1)
match out on $ext_if2 from $lan_net nat-to ($ext_if2)

#  по умолчанию блокируем все
block in
block out

#  разрешаем все исходящие пакеты на внутреннем интерфейсе
pass out on $int_if to $lan_net
#  разрешаем все входящие пакеты предназначенные самому шлюзу
pass in quick on $int_if from $lan_net to $int_if
#  балансируем исходящий трафик из внутренней сети. 
pass in on $int_if from $lan_net \
    route-to { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) } \
    round-robin
#  оставляем трафик https на одном соединении; некоторые web приложения
#  для большей безопасности не позволяют менять его в течение сессии
pass in on $int_if proto tcp from $lan_net to port https \
    route-to ($ext_if1 $ext_gw1)

#  обычное правило "pass out" для внешних интерфейсов
pass out on $ext_if1
pass out on $ext_if2

#  пропускаем пакеты с любых IP на $ext_if1 и $ext_gw1 
#  и аналогично на $ext_if2 и $ext_gw2
pass out on $ext_if1 from $ext_if2 route-to ($ext_if2 $ext_gw2)
pass out on $ext_if2 from $ext_if1 route-to ($ext_if1 $ext_gw1)
</pre>
</td></tr>
</table>

<p>
[<a href="queueing.html">Предыдущая: Очередь пакетов и приоритезация</a>]
[<a href="index.html">Содержание</a>]
[<a href="tagging.html">Следующая: Packet Tagging</a>]

<p>
<hr>
<a href="index.html"><img src="../../../images/back.gif" alt="[back]" border="0" width="24" height="24"></a> 
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: pools.html,v 1.31 ]<br>
$Translation: pools.html,v 1.5 2012/08/21 20:56:28 alex Exp $<br>
-->
$OpenBSD$
</small>
 
</body>
@


1.1
log
@Sync with Steelix CVS
@
text
@d1 1
a1 1
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
d4 1
a4 1
<title>PF: Address Pools and Load Balancing</title>
d6 1
a6 1
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
d38 3
a40 3
[<a href="queueing.html">Previous: Packet Queueing and Prioritization</a>]
[<a href="index.html">Contents</a>]
[<a href="tagging.html">Next: Packet Tagging</a>]
d44 1
a44 1
<font color="#e00000">PF: Address Pools and Load Balancing</font>
d49 1
a49 1
<h3>Table of Contents</h3>
d51 4
a54 4
<li><a href="#intro">Introduction</a>
<li><a href="#nat">NAT Address Pool</a>
<li><a href="#incoming">Load Balancing Incoming Connections</a>
<li><a href="#outgoing">Load Balancing Outgoing Traffic</a>
d56 1
a56 1
	<li><a href="#outexample">Ruleset Example</a>
d63 7
a69 7
<h2>Introduction</h2>
An address pool is a supply of two or more addresses whose use is shared
among a group of users. An address pool can be specified as the
redirection address in <a href="rdr.html"><tt>rdr</tt></a> rules, as the
translation address in <a href="nat.html"><tt>nat</tt></a> rules, and as
the target address in <tt>route-to</tt>, <tt>reply-to</tt>, and
<tt>dup-to</tt> <a href="filter.html">filter</a> options.
d72 1
a72 1
There are four methods for using an address pool:
d74 24
a97 21
<li><tt>bitmask</tt> - grafts the network portion of the pool
address over top of the address that is being modified (source address
for <tt>nat</tt> rules, destination address for <tt>rdr</tt> rules).
Example: if the address pool is 192.0.2.1/24 and the address being 
modified is 10.0.0.50, then the resulting address will be 192.0.2.50. If
the address pool is 192.0.2.1/25 and the address being modified is
10.0.0.130, then the resulting address will be 192.0.2.2. 
<li><tt>random</tt> - randomly selects an address from the pool.
<li><tt>source-hash</tt> - uses a hash of the source address to
determine which address to use from the pool. This method ensures that a
given source address is always mapped to the same pool address.
The key that is fed to the hashing algorithm can optionally be specified
after the <tt>source-hash</tt> keyword in hex format or as a string. By
default,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+4.5"
>pfctl(8)</a> will generate a random key every time the ruleset is
loaded. 
<li><tt>round-robin</tt> - loops through the address pool in
sequence. This is the default method and also the only method allowed
when the address pool is specified using a 
<a href="tables.html">table</a>.
d101 2
a102 2
Except for the <tt>round-robin</tt> method, the address pool must be
expressed as a 
d104 4
a107 3
(Classless Inter-Domain Routing) network block. The <tt>round-robin</tt>
method will accept multiple individual addresses using a
<a href="macros.html#lists">list</a> or <a href="tables.html">table</a>.
d110 3
a112 3
The <tt>sticky-address</tt> option can be used with the <tt>random</tt>
and <tt>round-robin</tt> pool types to ensure that a particular source
address is always mapped to the same redirection address.
d115 9
a123 8
<h2>NAT Address Pool</h2>
An address pool can be used as the translation address in 
<a href="nat.html"><tt>nat</tt></a> rules. Connections will have their
source address translated to an address from the pool based on the
method chosen. This can be useful in situations where PF is performing
NAT for a very large network. Since the number of NATed connections per
translation address is limited, adding additional translation addresses
will allow the NAT gateway to scale to serve a larger number of users.
d126 3
a128 3
In this example a pool of two addresses is being used to translate
outgoing packets. For each outgoing connection PF will rotate through
the addresses in a round-robin manner.
d131 1
a131 1
nat on $ext_if inet from any to any -&gt; { 192.0.2.5, 192.0.2.10 }
d136 9
a144 9
One drawback with this method is that successive connections from the
same internal address will not always be translated to the same
translation address.  This can cause interference, for example, when
browsing websites that track user logins based on IP address. An
alternate approach is to use the <tt>source-hash</tt> method so that
each internal address is always translated to the same translation
address. To do this, the address pool must be a
<a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>
network block.
d147 1
a147 1
nat on $ext_if inet from any to any -&gt; 192.0.2.4/31 source-hash
d152 4
a155 4
This <tt>nat</tt> rule uses the address pool 192.0.2.4/31 (192.0.2.4 -
192.0.2.5) as the translation address for outgoing packets. Each
internal address will always be translated to the same translation
address because of the <tt>source-hash</tt> keyword.
d158 4
a161 4
<h2>Load Balance Incoming Connections</h2>
Address pools can also be used to load balance incoming connections. For
example, incoming web server connections can be distributed across a web
server farm:
d166 1
a166 1
rdr on $ext_if proto tcp from any to any port 80 -&gt; $web_servers \<br>
d172 8
a179 8
Successive connections will be redirected to the web servers in a
round-robin manner with connections from the same source being sent to
the same web server.
This "sticky connection" will exist as long as there are states that
refer to this connection. 
Once the states expire, so will the sticky connection.
Further connections from that host will be redirected to the next web
server in the round robin.
d182 15
a196 14
<h2>Load Balance Outgoing Traffic</h2>
Address pools can be used in combination with the <tt>route-to</tt>
filter option to load balance two or more Internet connections when a
proper multi-path routing protocol (like 
<a href="http://www.rfc-editor.org/rfc/rfc1771.txt">BGP4</a>) is
unavailable. By using <tt>route-to</tt> with a <tt>round-robin</tt>
address pool, outbound connections can be evenly distributed among
multiple outbound paths. 

<p>
One additional piece of information that's needed to do this is the IP
address of the adjacent router on each Internet connection. This is fed
to the <tt>route-to</tt> option to control the destination of outgoing
packets.
d199 2
a200 2
The following example balances outgoing traffic across two Internet
connections:
d210 3
a212 3
pass in on $int_if route-to \<br>
&nbsp;&nbsp;&nbsp;{ ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) } round-robin \<br>
&nbsp;&nbsp;&nbsp;from $lan_net to any keep state
d217 6
a222 8
The <tt>route-to</tt> option is used on traffic coming <i>in</i> on the
<i>internal</i> interface to specify the outgoing network interfaces
that traffic will be balanced across along with their respective
gateways. Note that the <tt>route-to</tt> option must be present on
<i>each</i> filter rule that traffic is to be balanced for.  Return
packets will be routed back to the same external interface that they
exited (this is done by the ISPs) and will be routed back to the
internal network normally.
d225 4
a228 4
To ensure that packets with a source address belonging to
<tt>$ext_if1</tt> are always routed to <tt>$ext_gw1</tt> (and similarly
for <tt>$ext_if2</tt> and <tt>$ext_gw2</tt>), the following two lines
should be included in the ruleset:
d231 4
a234 4
pass out on $ext_if1 route-to ($ext_if2 $ext_gw2) from $ext_if2 \<br>
&nbsp;&nbsp;&nbsp;to any<br>
pass out on $ext_if2 route-to ($ext_if1 $ext_gw1) from $ext_if1 \<br>
&nbsp;&nbsp;&nbsp;to any 
d239 2
a240 1
Finally, NAT can also be used on each outgoing interface:
d243 2
a244 2
nat on $ext_if1 from $lan_net to any -&gt; ($ext_if1)<br>
nat on $ext_if2 from $lan_net to any -&gt; ($ext_if2)
d250 2
a251 2
A complete example that load balances outgoing traffic might look
something like this:
d264 11
a274 11
#  nat outgoing connections on each internet interface
nat on $ext_if1 from $lan_net to any -&gt; ($ext_if1)
nat on $ext_if2 from $lan_net to any -&gt; ($ext_if2)

#  default deny
block in  from any to any
block out from any to any

#  pass all outgoing packets on internal interface
pass out on $int_if from any to $lan_net
#  pass in quick any packets destined for the gateway itself
d276 17
a292 19
#  load balance outgoing tcp traffic from internal network. 
pass in on $int_if route-to \
    { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) } round-robin \
    proto tcp from $lan_net to any flags S/SA modulate state
#  load balance outgoing udp and icmp traffic from internal network
pass in on $int_if route-to \
    { ($ext_if1 $ext_gw1), ($ext_if2 $ext_gw2) } round-robin \
    proto { udp, icmp } from $lan_net to any keep state

#  general "pass out" rules for external interfaces
pass out on $ext_if1 proto tcp from any to any flags S/SA modulate state
pass out on $ext_if1 proto { udp, icmp } from any to any keep state
pass out on $ext_if2 proto tcp from any to any flags S/SA modulate state
pass out on $ext_if2 proto { udp, icmp } from any to any keep state

#  route packets from any IPs on $ext_if1 to $ext_gw1 and the same for
#  $ext_if2 and $ext_gw2
pass out on $ext_if1 route-to ($ext_if2 $ext_gw2) from $ext_if2 to any 
pass out on $ext_if2 route-to ($ext_if1 $ext_gw1) from $ext_if1 to any 
d298 3
a300 3
[<a href="queueing.html">Previous: Packet Queueing and Prioritization</a>]
[<a href="index.html">Contents</a>]
[<a href="tagging.html">Next: Packet Tagging</a>]
d304 1
a304 1
<a href="../../pf/ru/index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
d309 2
a310 2
Originally [OpenBSD: pools.html,v 1.23 ]<br>
$Translation: pools.html,v 1.4 2009/08/01 21:47:52 tobias Exp $<br>  
d314 1
a314 1

d316 1
a316 1
</html> 
@

