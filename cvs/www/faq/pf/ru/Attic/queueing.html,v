head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2014.04.01.17.14.11;	author nick;	state dead;
branches;
next	1.4;

1.4
date	2012.12.08.09.15.21;	author ajacoutot;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.02.07.24.05;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2012.09.20.06.25.15;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.01.21.41.39;	author tobias;	state Exp;
branches;
next	;


desc
@@


1.5
log
@
Abandon translations, per deraadt@@ and ajacoutot@@.
@
text
@﻿<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>PF: Управление очередями пакетов и приоритезация</title>
<link rev="made" href="mailto:www@@openbsd.org">
<meta name="resource-type" content="document">
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq,pf">
<meta name="distribution" content="global">
</head>

<!--
Copyright (c) 2003-2005 Joel Knight <enabled@@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="anchors.html">Предыдущая: Якоря</a>]
[<a href="index.html">Содержание</a>]
[<a href="pools.html">Следующая: Пулы адресов и балансировка нагрузки</a>]

<p>
<h1><font color="#e00000">PF: Управление очередями пакетов и приоритезация</font></h1>


<hr>

<h3>Содержание</h3>
<ul>
<li><a href="#queueing">Очереди</a>
<li><a href="#sched">Планировщики</a>
	<ul>
	<li><a href="#cbq">Управление очередями, основанное на классах</a>
	<li><a href="#priq">Управление очередями, основанное на приоритетах</a>
	<li><a href="#red">Ранняя случайная диагностика (Random Early Detection)</a>
	<li><a href="#ecn">Явное уведомление о перегрузке (Explicit Congestion Notification)</a>
	</ul>
<li><a href="#altq">Настройка очередей</a>
<li><a href="#assign">Привязка трафики к очереди</a>
<li><a href="#example1">Пример #1: Домашняя сеть</a>
<li><a href="#example2">Пример #2: Сеть предприятия</a>
</ul>

<hr>

<a name="queueing"></a>
<h2>Очереди</h2>
<p>
Поставить что-то в очередь - это значит сохранить в определенном порядке, пока
оно дожидатся обработки. В компьютерной сети, когда пакеты данных отсылаются
хостом, они попадают в очередь и ожидают обработки операционной системой. Затем
операционная система решает какие пакеты и из какой очереди будет обработаны.
Порядок, в котором операционная система выбирает пакеты для обработки, могут
влиять на производительность сети. Например, представьте, что пользователь
запустил два сетевых приложения: SSH и FTP. В идеале, пакеты SSH должны быть 
обработаны первыми, до пакетов FTP, исходя из времязависимой природы 
протокола SSH; когда клиент SSH нажимает кнопку, то он рассчитывает на
немедленный ответ, а передача данных FTP может быть отложена на несколько секунд
и вряд ли эта задержка будет иметь большое значение. Но что произойдет, если 
роутер начнет обрабатывать большую последовательность пакетов FTP соединения 
перед обработкой данных SSH соединения? Пакеты SSH соединения будут оставаться
в очереди (или возможно будут уничтожены роутором, если очередь не будет
достаточно большой, для хранения всех пакетов) и сессия SSH может прерваться
или сильно замедлиться. При помощи изменения стратегии очередности можно
добиться, чтобы ширина сетевого канала распределялась в достаточной степени
между различными приложениями, пользователями и компьютерами.

<p>
Учтите, что управление очередями возможно только для <i>исходящих</i> пакетов.
Когда пакет поступает на интерфейс во входящем направлении, то уже поздно
ставить его в очередь, так как он уже занял свою часть сетевого канала чтобы
попасть в интерфейс, который его получил. Единственным решением может стать
управление очередью на соседнем роутере, или если хост, получивший пакет,
выступает в качестве роутера, разрешить управление очередью на его внутреннем 
интерфейсе для исходящих пакетов.

<a name="sched"></a>
<h2>Планировщики</h2>
Планировщик - это алгоритм, который решает, какие очереди и в какой
последовательности будут обработаны. По умолчанию OpenBSD использует планировщик
First In First Out (FIFO). Очередь FIFO работает как очередь на кассе
супермаркета -- первый в очереди будет первым обслужен. Новые пакеты,
поступающие в очередь, будут добавлены в ее конец. Когда очередь заполняется,
как и в аналогии с запретом продаж в супермаркете, вновь поступающие пакеты
отбрасываются. Этот метод называется купированием хвоста (tail-drop).

<p>
OpenBSD поддерживает два дополнительных планировщика:
<ul>
<li>Управление очередями, основанное на классах
<li>Управление очередями, основанное на приоритетах
</ul>

<a name="cbq"></a>
<h3>Управление очередями, основанное на классах</h3>
Управление очередями, основанное на классах (CBQ) - это алгоритм, который 
делит ширину сетевого канала межде несколькими очередями или классами.
Каждая очередь, которая привязана к трафику, основывается на адресах источника,
получателя, номере порта, протоколе и т.д. Очередь может быть дополнительно
сконфигурирована так, чтобы отбирать у родительской очереди ширину канала, если
родительская очередь не использует свою часть канала. Для очереди также может
быть назначен приоритет, например, интерактивному трафику, такому как SSH. И ее
пакеты будут обработаны первыми, в отличии от очереди, содержащей объемный
трафик, например, такой как FTP.

<p>
CBQ очереди организованы по иерархическому принципу.
На вершине иерархии находится корневая очередь, которая определяет суммарную, 
доступную ей, ширину канала.
Дочерние очереди создаются под корневой очередью, каждой из которых может
быть назначена часть ширины канала корневой очереди.
Например, очереди могут быть определены следующим образом:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>Queue A (1Mbps)</dd>
	<dd>Queue B (500Kbps)</dd>
	<dd>Queue C (500Kbps)</dd>
	</dl>
</dd>
</dl>

<p>
В этом случае общая доступная ширина канала устанавливается в 2 мегабита 
в секунду (Mbps). Эта ширина распределяется между дочерними очередями.

<p>
Иерархическая структура может быть расширена путем объявления очередей в 
очередях. Чтобы разделить ширину канала поровну между несколькими
пользователями и распределить их трафик так, чтобы определенные протоколы
не испытывали недостатка в ширине канала, структуру очередей можно определить
таким образом:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps)
		<dl>
		<dd>ssh (50Kbps)</dd>
		<dd>bulk (950Kbps)</dd>
		</dl>
	</dd><dd>UserB (1Mbps)
		<dl>
		<dd>audio (250Kbps)</dd>
		<dd>bulk (750Kbps)
			<dl>
			<dd>http (100Kbps)</dd>
			<dd>other (650Kbps)</dd>
			</dl>
		</dd>
		</dl>
	</dd>
	</dl>
</dd>
</dl>

<p>
Обратите внимание, что на каждом уровне сумма ширин каналов, назначенных
каждой из очередей, не может быть больше чем ширина канала родительской 
очереди.

<p>
Очередь может быть настроена таким образом, чтобы она могла заимствовать (borrow)
ширину канала у родительской очереди, если родительская имеет незадействованную
полосу, выделенную другим дочерним очередям.
Рассмотрим пример такой настроки очередей:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps)
		<dl>
		<dd>ssh (100Kbps)</dd>
		<dd>ftp (900Kbps, borrow)</dd>
		</dl>
	</dd>
	<dd>UserB (1Mbps)</dd>
	</dl>
</dd>
</dl>

<p>
Если трафик в очереди <tt>ftp</tt> превышает 900Kbps и трафик в очереди 
пользователя <tt>UserA</tt> меньше 1Mbps (потому что очередь <tt>ssh</tt>
использует менее назначенной ей ширина в 100Kbps), то очередь <tt>ftp</tt>
будет отбирать ширину канала от очереди пользователя <tt>UserA</tt>.
В этом случае очередь <tt>ftp</tt> может использовать бОльшую ширину канала,
чем та которая ей назначена, в моменты перегрузки. Когда очередь <tt>ssh</tt>
увеличит нагрузку, заимствованная часть ширины канала будет ей 
возвращена.

<p>
CBQ назначает каждой очереди свой уровень приоритета. Очередям с бОльшим 
приоритетом будет отдаваться предпочтение на очередями с меньшим приоритетом
в случае если они имеют одних и тех же родителей (другими словами когда очереди 
находятся на одном уровне иерархии). Очереди с одинаковыми приоритетами будут 
обслуживаться по циклически (round-robin). Например:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps, priority 1)
		<dl>
		<dd>ssh (100Kbps, priority 5)</dd>
		<dd>ftp (900Kbps, priority 3)</dd>
		</dl>
	</dd>
	<dd>UserB (1Mbps, priority 1)</dd>
	</dl>
</dd>
</dl>

<p>
Алгоритм CBQ будет обслуживать очереди пользователей <tt>UserA</tt> и 
<tt>UserB</tt> циклически (round-robin) -- т.е ни одна очередь не будет 
иметь предпочтение над другой.
Пока обрабатывается очередь пользователя <tt>UserA</tt> алгоритм CBQ
также будет обрабатывать и его дочерние очереди.
В этом случае очередь <tt>ssh</tt> имеет бОльший приоритет и получит 
льготный режим в обслуживании над очередью <tt>ftp</tt> когда сеть 
перегружена.
Имейте в виду, что очереди <tt>ssh</tt> и <tt>ftp</tt> не имеют приоритетов над
очередями <tt>UserA</tt> и <tt>UserB</tt>, так как они находятся на разных
уровнях иерархии.

<p>
Для более детальной информации о теории CBQ, пожалуйста, смотрите
<a href="http://www.icir.org/floyd/cbq.html">References on CBQ</a>.

<a name="priq"></a>
<h3>Управление очередями, основанное на приоритетах</h3>
Управление очередями, основанное на приоритетах (PRIQ) назначает очередям 
сетевого интерфейса определенный уровень приоритета. Очереди с бОльшим 
приоритетом <i>всегда</i> обслуживаются раньше очередей с меньшим приоритетом.
Если двум и более очередям назначен одинаковый приоритет, то они будет обслужены
циклически (round-robin).

<p>
Структура правил управления очередями, основанное на приоритетах (PRIQ)
является плоской, т.е. вы не можете определить очереди в другой очереди.
Корневая очередь описывает общую ширину канала, которая ей доступна, а 
подочереди описываются под корневой. Рассмотрим следующий пример:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>Queue A (priority 1)</dd>
	<dd>Queue B (priority 2)</dd>
	<dd>Queue C (priority 3)
	</dd></dl>
</dd></dl>

<p>
Корневая очередь описывается с шириной канала в 2Mbps, доступной ей 
и определенными в ней трем подочередям. Очередь с наивысшим приоритетом
(с наивысшим номером приоритета) будет обслужена первой.
После того как все пакеты из этой очереди будут обработаны, или эта очередь 
оказывается пустой, алгоритм PRIQ переходит к обработке очереди со следующим
по порядку приоритетом. В пределах одной очереди пакеты обработываются в 
порядке FIFO.

<p>
Очень важно запомнить, что при использовании алгоритма PRIQ вы должны
планировать управление очередями очень аккуратно. Это связано с тем, что
этот алгоритм <i>всегда</i> обрабатывает очередь с более высоким приоритетом
ранее очереди с более низким приоритетом, и это позволяет очереди с высоким 
приоритетом вызывать задержку отправки пакетов из очереди с меньшим приоритетом
или удалять их, если очередь с высоким приоритетом получает постоянный поток
пакетов.

<a name="red"></a>
<h3>Ранняя случайная диагностика (Random Early Detection)</h3>
Ранняя случайная диагностика (RED) - это алгоритм предотвращения перегрузки.
Его работа заключается в предотвращении перегрузки сети путем слежения за тем, 
чтобы очередь не оказалась заполнена. Он выполняет ее с помощью постоянного
вычисления средней длины (размера) очереди и сравнения ее с двумя пороговыми 
значениями - минимальным и максимальным. Если средняя длина очереди меньше 
минимального порога, то пакеты не будут уничтожаться. Если средняя длина 
очереди больше максимального порога, то <i>все</i> все новые пакеты будут
уничтожены. Если среднее значение находится между пороговыми, то пакеты будут 
удаляться основываясь на вероятности, вычисленной из средней длины очереди.
Другими словами, если средняя длина очереди приближается к максимальному порогу,
то все больше и больше пакетов будет отброшено. При удалении пакетов алгоритм 
RED случайным образом выбирает соединения, чьи пакеты будет отброшены. Пакеты 
соединений, использующие большую часть ширины канала, будут отброшены с большей
вероятностью.

<p>
Алгоритм RED является полезным, поскольку позволяет избежать ситуации, 
называемой глобальной синхронизацией, и он может помочь сгладить пики трафика.
Проблема глобальной синхронизации относится к проблеме снижения общей 
пропускной способности сети, когда пакеты нескольких соединений уничтожаются в
одно и то же время. Например, когда происходит перегрузка на раутере, 
обслуживающем 10 FTP соединений, и пакеты от всех (или большинства) соединений
отбрасываются (как в случае обслуживания по принципу FIFO), тогда пропускная
способность сети резко падает. Это не идеальная ситуация, потому что она 
заставляет все FTP соединения уменьшить нагузку на сеть, и сеть не может больше
работать с максимальной производительностью. Алгоритм RED позволяет избежать
такой ситуации, благодаря уничтожения пакетов, случайно выбранных соединений, 
а не пакетов всех соединений. Пакеты соединений, занимающих большую часть
ширины канала, имеют больше шансов быть отброшенными. В этом случае,
соединения, которые сильно нагружают канал будут заторможены, заторов можно 
будет избежать и резких провалов пропускной способности сети не произойдет.
В дополнение к вышесказанному, алгоритм RED в состоянии справиться с всплесками
трафика, так как он начинает уничтожать пакеты <i>до</i> того как очередь
будет заполнена. Если проходящий трафик резко увеличивается, то в очереди 
остается еще свободное место для размещения новых пакетов.

<p>
Алгоримт RED должен использоваться только с транспортными протоколами,
способными распознать признаки перегрузки сети. В большинстве случаев это
означает, что этот алгоритм должен использоваться для управления очередями
трафика TCP, но не UPD или ICMP.

<p>
Для дополнительной информации, пожалуйста, ознакомьтесь с теорией RED по ссылке
<a href="http://www.icir.org/floyd/red.html">References on RED</a>.

<a name="ecn"></a>
<h3>Явное уведомление о перегрузке (Explicit Congestion Notification)</h3>
Явное уведомление о перегрузке (ECN) работает совместно с RED, уведомляя хосты,
взаимодействующие через сеть, о любых перегрузках в канале связи. Оно делает это
с помощью разрешения алгоритму RED устанавливать флаг в заголовке пакета вместо 
удаления пакета. Предполагается, что хост отправитель поддерживает ECN, и
поэтому он сможет прочитать этот флаг и соответственно снизить скорость своего
сетевого трафика.

<p>
Для дополнительной информации, пожалуйста, ознакомьтесь с ECN по ссылке
<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">RFC 3168</a>.

<a name="altq"></a>
<h2>Настройка очередей</h2>
Начиная с OpenBSD 3.0 реализация управления очередями
<a href="http://www.csl.sony.co.jp/person/kjc/kjc/software.html#ALTQ">
Alternate Queueing (ALTQ)</a>
является частью основной системы. Начиная с OpenBSD 3.3 ALTQ была встроена 
в PF. Реализация ALTQ в OpenBSD поддерживает управление очередями, основанное
на классах (CBQ) и управление очередями, основанное на приоритетах (PRIQ).
Она также поддерживает ранную случайную диагностику (RED) и явное уведомление
о перегрузке (ECN).

<p>
Поскольку ALTQ и PF были объединены, то для управления очередями PF должен
быть включен. О том, как включить PF смотрите инструкцию в разделе
<a href="config.html#activate">Приступая к работе</a>.

<p>
Управление очередями настраивается в <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5&manpath=OpenBSD+5.2">
pf.conf</a></tt>.
Существует два вида директив, которые используются для настройки управления
очередями:
<ul>
<li><tt>altq on</tt> - включает управление очередями на интерфейсе, определяет
тип используемого планировщика и создает корневую очередь <li><tt>queue</tt> -
объявляет свойства дочерней очереди
</ul>

<p>
Синтаксис директивы <tt>altq on</tt> таков:
<blockquote>
<tt>
altq on <i>interface scheduler</i> bandwidth <i>bw</i> qlimit 
<i>qlim</i> \<br>
&nbsp;&nbsp;&nbsp;tbrsize <i>size</i> queue { <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>interface</i></tt> - сетевой интерфейс, на котором включается 
управление очередями.
<li><tt><i>scheduler</i></tt> - используемый планировщик. Возможные значения - 
<tt>cbq</tt> и <tt>priq</tt>. В текуший момент времени активным может быть 
только один планировщик.
<li><tt><i>bw</i></tt> - общее значение ширины канала, доступное планировщику.
Оно может быть указано как абсолютное значение с использованием суффиксов
<tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt>, и <tt>Gb</tt> которые означают бит,
килобит, мегабит и гигабит в секунду соответственно или как процент от ширины
канала <tt><i>интерфейса</i></tt>.
<li><tt><i>qlim</i></tt> - максимальное количество пакетов, которые будет
содержать очередь. Этот параметр является опциональным. По умолчанию он равен
50.
<li><tt><i>size</i></tt> - размер регулятора контейнера маркеров(token bucket
regulator) (Примечание переводчика - видимо, это и есть пороговое значение для
RED) в байтах. Если параметр не определен, то размер устанавливается
основываясь на ширине канала <tt><i>интерфейса</i></tt>.
<li><tt><i>queue_list</i></tt> - список дочерних очередей, создаваемых под
корневой очередью.
</ul>

<p>
Например:
<blockquote>
<tt>
altq on fxp0 cbq bandwidth 2Mb queue { std, ssh, ftp }
</tt>
</blockquote>
CBQ разрешается на интерфейсе <tt>fxp0</tt>. Общая доступная ширина канала 
устанавливается в 2Mbps. Определяются три дочерние очереди: <tt>std</tt>,
<tt>ssh</tt>, и <tt>ftp</tt>.

<p>
Синтаксис директивы <tt>queue</tt> таков:
<blockquote>
<tt>
queue <i>name</i> [on <i>interface</i>] bandwidth <i>bw</i> [priority 
<i>pri</i>] [qlimit <i>qlim</i>] \<br>
&nbsp;&nbsp;&nbsp;<i>scheduler</i> ( <i>sched_options</i> )
{ <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>name</i></tt> - наименование очереди. Оно должно соответствовать
названию одной из очередей, определенных в списке <tt><i>queue_list</i></tt>
директивы <tt>altq on</tt>. Для использования <tt>cbq</tt> это наименование
также может присутствовать в списке <tt><i>queue_list</i></tt> определенной 
ранее директивы <tt>queue</tt>. Наименование очереди не должно превышать 15
символов.
<li><tt><i>interface</i></tt> - сетевой интерфейс к которому привязана очередь
Это значение не является обязательным и может быть опущено. В этом случае
очередь действеует на всех сетевых интерфейсах.
<li><tt><i>bw</i></tt> - полная ширина канала, доступная очереди.
Значение может быть указано как абсолютное значение с использованием суффиксов
<tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt>, и <tt>Gb</tt> которые означают бит,
килобит, мегабит и гигабит в секунду соответственно или как процент от ширины
родительской очереди. Этот параметр применяется только в случае использования
планировщика <tt>cbq</tt>. Если значение не определено, то по умолчанию
используется значение 100% ширины канала родительской очереди.
<li><tt><i>pri</i></tt> - приоритет очереди. Допустимые значения для
планировщика <tt>cbq</tt> - 0-7, для <tt>priq</tt> 0-15. Приоритер 0 - имеет
самый низкий приоритет. Если значение не указано, то по умолчанию используется
приоритет 1.
<li><tt><i>qlim</i></tt> - максимальное количество пакетов, которые будет
содержать очередь. Если значение не указано, то по умолчанию оно берется равным
50.
<li><tt><i>scheduler</i></tt> - тип используемого пранировщика <tt>cbq</tt> или
<tt>priq</tt>. Должен быть таким же как и у родительской очереди.
<li><tt><i>sched_options</i></tt> - дополнительные параметры планировщика, для
настройки его поведения:
	<ul>
	<li><tt>default</tt> - очередь назначается очередью по умолчанию, в которую
	будут попадать пакеты, не попавшие ни в одну другую очередь. Должна быть
	определена ровно одна очередь по умолчанию.
	<li><tt>red</tt> - разрешает раннюю случайную диагностику (RED) для очереди.
	<li><tt>rio</tt> - разрешает RED с IN/OUT (enables RED with IN/OUT). В этом
	режиме RED будет контролировать множество значений средних размеров очередей
	и множество пороговых значений по одному для каждого уровня IP Quality of
	Service.
	<li><tt>ecn</tt> - разрешает явное уведомление о перегрузке (ECN) для
	очереди. Указание <tt>Ecn</tt> подразумевает включение <tt>red</tt>.
	<li><tt>borrow</tt> - очередь может заимствовать канал у родительской
	очереди. Этот параметр может быть указан только для планировщика
	<tt>cbq</tt>.
	</ul>
<li><tt><i>queue_list</i></tt> - список дочерних очередей, создаваемых под
корневой очередью. Список <tt><i>queue_list</i></tt> может быть объявлен
только при использовании планировщика <tt>cbq</tt>.
</ul>

<p>
В продолжение вишеизложенного пример:
<blockquote>
<tt>
queue std bandwidth 50% cbq(default)<br>
queue ssh bandwidth 25% { ssh_login, ssh_bulk }<br>
&nbsp;&nbsp;queue ssh_login bandwidth 25% priority 4 cbq(ecn)<br>
&nbsp;&nbsp;queue ssh_bulk  bandwidth 75% cbq(ecn)<br>
queue ftp bandwidth 500Kb priority 3 cbq(borrow red)<br>
</tt>
</blockquote>

<p>
Здесь определяются параметры для объявленных ранее дочерних очередей
Очереди <tt>std</tt> присваивается ширина канала равная 50% ширины канала
корневой очереди и она назначается очередью по умолчанию. Очереди <tt>ssh</tt>
присваивается ширина канала равная 25% ширины канала корневой очереди (500kb)
и в ней объявляются две дочерние очереди <tt>ssh_login</tt> и <tt>ssh_bulk</tt>.
Очереди <tt>ssh_login</tt> присваивается более высокий приоритет чем очереди
<tt>ssh_bulk</tt>, и на обеих включается ECN. Очереди <tt>ftp</tt>
присваивается ширина канала равная 500Kbps и устанавливается приоритет 3. Эта
очередь также может заимствовать ширину канала в случае доступности излишка и
включается RED.

<p>
<b>Примечание:</b> В объявлении каждой дочерней очереди указывается ширина
канала. Если ширина канала не указана, то PF отдаст этой очереди 100% от ширины
канала родительской очереди.
В этом случае, при загрузке правил возможна ошибка, так как имеется очередь,
занимающая всю ширину канала и ни одна другая очередь не может быть объявлена
на этом уровне, так как не осталось свободной ширины канала для ее размещения.

<a name="assign"></a>
<h3>Привязка трафика к очереди</h3>
<p>
Для того, чтобы привязать трафик к очереди, необходимо иcпользовать ключевое
слово <tt>queue</tt> в сочетании с правилами PF
(<a href="filter.html">filter rules</a>).
Например, рассмотрим набор следующих правил фильтрации, содержащих такие строки как:
<blockquote>
<tt>pass out on fxp0 proto tcp to port 22</tt>
</blockquote>

<p>
Пакеты, подпадающие под это правило, могут быть привязаны к очереди с помощью
ключевого слова <tt>queue</tt>:
<blockquote>
<tt>pass out on fxp0 proto tcp to port 22 queue ssh</tt>
</blockquote>

<p>
Когда создается запись в таблице состояний по этому правилу, PF будет
сохранять очередь в этой записи таблицы состояний. Эта же запись будет
использоваться и для других пакетов разрешенных для нее:

<blockquote>
<tt>pass in on fxp0 proto tcp to port 80 queue http</tt>
</blockquote>
По этому правилу пакеты, возвращающиеся назад на интерфейс <tt>fxp0</tt>,
которые соответствуют установленным соединениям будут записаны в конец очереди
<tt>http</tt>. Учтите, что даже при использовании ключевого
слова <tt>queue</tt> для правила, фильтрующего входящий трафик, целью правила
является определение очереди для соответствующего исходящего трафика. Правило,
показанное выше, не управляет очередью входящих пакетов.

<p>
При использовании ключевого слова <tt>queue</tt> с директивой <tt>block</tt>
любые результирующие пакеты TCP RST или пакеты ICMP Unreachable ставятся
в указанную очередь.

<p>
Обратите внимание, что назначение очереди может произойти на интерфейсе,
отличном от интерфейса, определенного в директиве <tt>altq on</tt>:
<blockquote>
<tt> 
altq on fxp0 cbq bandwidth 2Mb queue { std, ftp }<br>
queue std bandwidth 500Kb cbq(default)<br>
queue ftp bandwidth 1.5Mb<br>
<br>
pass in on dc0 proto tcp to port 21 queue ftp<br>
</tt>
</blockquote>

<p>
Управление очередью включено на интерфейсе <tt>fxp0</tt>, но назначение 
происходит на интерфейс <tt>dc0</tt>.
Если пакеты, соответствующие правилу <tt>pass</tt> (или состоянию, созданному
этим правилом), выходят из интерфейса <tt>fxp0</tt>, то они будут поставлены в 
очередь <tt>ftp</tt>.
Этот тип управления очередями может быть очень полезен в роутерах.

<p>
Обычно используется только одно имя очереди с ключевым словом <tt>queue</tt>,
однако если определено второе имя, то эта очередь будет использована для 
пакетов с <a href="http://www.rfc-editor.org/rfc/rfc791.txt">Type of
Service (ToS)</a> low-delay и для пакетов TCP ACK без блока данных.
Хорошим примером для этого может служить протокол SSH. Сессии login SSH
устанавливают ToS low-delay пока не начнутся сессии SCP или SFTP.
PF может использовать эту информацию для распределения пакетов login-соединения
и не login-соединения по разным очередям. Это может быть полезно для 
приоретизации login-соединения над пакетами передачи файлов.
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue(ssh_bulk, ssh_login)</tt>
</blockquote>

<p>
Это правило направляет пакеты, принадлежащие соединению SSH login в очередь
<tt>ssh_login</tt>, а пакеты, принадлежащие соединениям SCP и SFTP в очередь
<tt>ssh_bulk</tt>. Пакеты соединения SSH login бужут иметь возможность быть 
обработанными раньше пакетов соединения SCP и SFTP, потому что очередь
<tt>ssh_login</tt> имеет больший приоритет.

<p>
Присваивание пакетам TCP ACK большего приоритета полезно для асимметричных
соединений, т.е. соединений, которые имеют разную входящую и исходящую ширину
канала, например линий ADSL. В применении к ADSL соединению: если начата
загрузка, а исходящий канал перегружен, то загрузка будет заторможена, так как
пакеты TCP ACK попадут в "пробку", чтобы пробиться наружу через исходящий канал.
Тестирование показало, что для достижения наилучшего результата, значение ширины
канала исходящей очереди должно быть меньше, чем полная пропускная способность
канала. Напрмер, если ADSL линия имеет исходящую скорость 640Kbps, то установка
значения <tt>ширины канала</tt> корневой очереди в 600Kb должно привести к
повышению производительности. Методом проб и ошибок можно будет подобрать
наилучшую настройку <tt>ширины канала</tt>.

<a name="example1"></a>
<h2>Пример #1: Домашняя сеть</h2>
<pre>  
    [ Алиса ]     [ Чарли ]
        |             |                              ADSL
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Интернет )
              |
           [ Боб ]

</pre>

<p>
В этом примере OpenBSD используется как Интернет-шлюз для малой домашней сети,
состоящей из трех рабочих станций. Шлюз выполняет роль фильтра пакетов и 
обязанности транслятора NAT. Интернет подключен с помощью линии ADSL с входящей
скоростью 2Mbps и исходящей скоростью 640Kbps.

<p>
Политика очередей для этой сети:
<ul>
<li> Резервируем 80Kbps входящей ширины канала Бобу, чтобы он мог играть в свои
online игры без задержек независимо от загрузок Алисы или Чарли. Разрешим Бобу
использовать более 80Kbps когда это возможно.
<li>Интерактивный трафик SSH и трафик клиентов IM будут иметь больший чем
обычный трафик приоритет.
<li>Запросы и ответы DNS будут иметь второй наивысший приоритет.
<li>Исходящие пакеты TCP ACK будут иметь больший приоритет, чем весь другой
исходящий трафик.
</ul>

<p>
Ниже приведен набор правил, который описывает эту сетевую политику.
Отметим, что в <tt>pf.conf</tt> присутствуют только те директивы, которые 
относятся непосредственно к указанной выше политике.

<p>
<table border="0" width="650">
<tbody><tr><td nowrap="" bgcolor="#EEEEEE">
<pre># разрешаем управление очередями на внешнем сетевом интерфейсе для
# управления исходящим интернет трафиком. используем плинировщик priq для
# управления только на основе приоритетов. устанавливаем ширину канала равной
# 610Kbps для обеспечения наилучшей производительности при отправке очереди 
# пакетов TCP ACK.

altq on fxp0 priq bandwidth 610Kb queue { std_out, ssh_im_out, dns_out, \
	tcp_ack_out }

# определяем параметры дочерних очередей.
# std_out      - стандартная очередь. любые правила фильтра, указанные ниже,
#                которые не определяют явно очередь, будут направлять свой
#                трафик в эту очередь.
# ssh_im_out   - интерактивный трафик SSH и трафик различных IM клиентов.
# dns_out      - запросы DNS.
# tcp_ack_out  - пакеты TCP ACK без блока данных.

queue std_out     priq(default)
queue ssh_im_out  priority 4 priq(red)
queue dns_out     priority 5
queue tcp_ack_out priority 6

# разрешаем управление очередями на внутреннем интерфейсе для управления
# трафиком, поступающим из интернет. используем планировщик cbq для управления
# шириной канала. устанавливаем максимальную ширину канала 2Mbps.

altq on dc0 cbq bandwidth 2Mb queue { std_in, ssh_im_in, dns_in, bob_in }

# определяем параметры дочерних очередей.
# std_in      - стандартная очередь. любые правила фильтра, указанные ниже,
#               которые не определяют явно очередь, будут направлять свой трафик
#               в эту очередь.
# ssh_im_in   - интерактивный трафик SSH и трафик различных IM клиентов.
# dns_in      - ответы DNS.
# bob_in      - ширина канала, резервируемая для рабочей станции Боба. разрешаем
#               ему заимствовать канал.

queue std_in    bandwidth 1.6Mb cbq(default)
queue ssh_im_in bandwidth 200Kb priority 4
queue dns_in    bandwidth 120Kb priority 5
queue bob_in    bandwidth 80Kb cbq(borrow)


# ... раздел фильтров pf.conf ...

alice         = "192.168.0.2"
bob           = "192.168.0.3"
charlie       = "192.168.0.4"
local_net     = "192.168.0.0/24"
ssh_ports     = "{ 22 2022 }"
im_ports      = "{ 1863 5190 5222 }"

# правила фильтра для входящих пакетов на интерфейсе fxp0
block in on fxp0 all

# правила фильтра для исходящих пакетов на интерфейсе fxp0
block out on fxp0 all
pass  out on fxp0 inet proto tcp from (fxp0) queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0)
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to port domain \
	queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to port $ssh_ports \
	queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to port $im_ports \
	queue(ssh_im_out, tcp_ack_out)

# правила фильтра для входящих пакетов на интерфейсе dc0
block in on dc0 all
pass  in on dc0 from $local_net

# правила фильтра для исходящих пакетов на интерфейсе dc0
block out on dc0 all
pass  out on dc0 to $local_net
pass  out on dc0 proto { tcp udp } from port domain to $local_net \
	queue dns_in
pass  out on dc0 proto tcp from port $ssh_ports to $local_net \
	queue(std_in, ssh_im_in)
pass  out on dc0 proto tcp from port $im_ports to $local_net \
	queue ssh_im_in
pass  out on dc0 to $bob queue bob_in
</pre>
</td></tr>
</tbody></table>

<a name="example2"></a>
<h2>Пример #2: Сеть предприятия</h2>
<pre>
  ( Отдел IT ) [ PC босса ]
       |          |                                   T1
     --+----+-----+---------- dc0 [ OpenBSD ] fxp0 -------- ( Интернет )
            |                         fxp1
         [ COMP1 ]    [ WWW ]         /
                         |           / 
                       --+----------' 

</pre>

<p>
В этом примере OpenBSD выступает в качестве файрвола корпоративной сети.
На предприятии работают WWW-сервер в DMZ-сегменте сети, на который клиенты 
загружают свои вебсайты по FTP, отдел IT, который имеет собственную подсеть,
подключенную к основной сети и рабочая станция босса, которую он использует для
электронной почты и веб-серфинга. Для подключения к интернету используется канал
T1 со скоростью 1.5Mbps в обоих направлениях. Все остальные сегменты сети
используют подключение Fast Ethernet (100Mbps).

<p>
Сетевой администратор решил использовать следующую сетевую политику:
<ul>
<li>Ограничить весь трафик между WWW-сервером и интернетом скоростью в 500Kbps в
обоих направлениях.
	<ul>
	<li>Выделить 250Kbps для трафика HTTP.
	<li>Выделить 250Kbps для "другого" (т.е., не-HTTP) трафика.
	<li>Разрешить каждой из этих очередей заимствовать канал вплоть до полной
	ширины в 500Kbps.
	<li>Назначить высокий приоритет HTTP-трафику между WWW-сервером и Интернетом
	по сравнению с другим трафиком между WWW-сервером и Интернетом (таким как
	FTP-трафик для загрузок).
	</ul>
<li>Трафик между WWW-сервером и внутренней сетью можно использовать вплоть до
полной скорости в 100Mbps, которую позволяет сеть.
<li>Зарезервировать 500Kbps для сети отдела IT, для того, чтобы они могли
своевременно загружать обновления программного обеспечения. Они также могут
использовать более чем 500Kbps, когда доступна дополнительная часть ширины
канала.
<li>Трафику между рабочей станцией босса и Интернетом присвоить больший
приоритет, чем другому входящему/исходящему интернет-трафику.
</ul>

<p>
Ниже приведен набор правил, который описывает эту сетевую политику.
Отметим, что в <tt>pf.conf</tt> присутствуют только те директивы, которые 
относятся непосредственно к указанной выше политике;
<a href="nat.html"><tt>nat</tt></a>, <a href="rdr.html"><tt>rdr</tt></a>,
<a href="options.html">options</a>,
и т.д., не показаны.

<p>
<table border="0" width="650">
<tbody><tr><td nowrap="" bgcolor="#EEEEEE">
<pre># разрешаем управление очередями на внешнем интерфейсе для управления 
# исходящими в Интернет пакетами. используем планировщие cbq для того, чтобы 
# имелась возможность контролировать ширину канала каждой очереди. устанавливаем 
# максимальную ширину исходящено канала в 1.5Mbps.

altq on fxp0 cbq bandwidth 1.5Mb queue { std_ext, www_ext, boss_ext }

# определяем параметры дочерних очередей.
# std_ext        - стандартная очередь. также является очередью по умолчанию для
#                  исходящего трафика на интерфейсе fxp0.
# www_ext        - очередь контейнер для очередей WWW сервера. ограничение
#                  500Kbps.
#   www_ext_http - http трафик от WWW сервера; более высокий приоритет.
#   www_ext_misc - весь не-http трафик от WWW сервера.
# boss_ext       - трафик от компьютера босса.

queue std_ext        bandwidth 500Kb cbq(default borrow)
queue www_ext        bandwidth 500Kb { www_ext_http, www_ext_misc }
  queue www_ext_http bandwidth 50% priority 3 cbq(red borrow)
  queue www_ext_misc bandwidth 50% priority 1 cbq(borrow)
queue boss_ext       bandwidth 500Kb priority 3 cbq(borrow)

# разрешаем управление очередями на внутреннем интерфейсе для управления
# трафиком поступающим из Интернета или DMZ. используем планировщик cbq для
# того, чтобы имелась возможность контролировать ширину канала каждой очереди.
# ширину канала на этом интерфейсе устанавливаем максимальной. трафик из DMZ
# может использовать ширину канала полностью, в то время как трафик из Интернета
# будет ограничен скоростью 1.0Mbps (так как 0.5Mbps (500Kbps) уже выделено для
# fxp1)

altq on dc0 cbq bandwidth 100% queue { net_int, www_int }

# определяем параметры дочерних очередей.
# net_int    - очередь контейнер для трафика из Интернета. ширина канала 
#              1.0Mbps.
#   std_int  - стандартная очередь. также является очередью по умолчанию для
#              исходящего трафика на интерфейсе dc0.
#   it_int   - трафик в сеть отдела IT; ограничение 500Kbps.
#   boss_int - трафик в компьютер босса; назначаем более высокий приоритет.
# www_int    - трафик от WWW сервера из DMZ; полная скорость.

queue net_int    bandwidth 1.0Mb { std_int, it_int, boss_int }
  queue std_int  bandwidth 250Kb cbq(default borrow)
  queue it_int   bandwidth 500Kb cbq(borrow)
  queue boss_int bandwidth 250Kb priority 3 cbq(borrow)
queue www_int    bandwidth 99Mb cbq(red borrow)

# разрешаем управление очередями на интерфейсе DMZ для управления трафиком
# предназначенным для WWW сервера. cbq будем использовать на этом интерфейсе в
# связи с необходимостью более детального управления шириной канала. ширину
# канала на этом интерфейсе устанавливаем максимальной. трафик из внутренней
# сети будет использовать всю полосу пропускания, в то время как трафик из
# Интернета будет ограничен скоростью в 500Kbps.

altq on fxp1 cbq bandwidth 100% queue { internal_dmz, net_dmz }

# определяем параметры дочерних очередей.
# internal_dmz   - трафик из внутренней сети.
# net_dmz        - очередь контейнер для трафика из Интернета.
#   net_dmz_http - http трафик; более высокий приоритет.
#   net_dmz_misc - не-http трафик. очередь также является очередью по умолчанию.

queue internal_dmz   bandwidth 99Mb cbq(borrow)
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http bandwidth 50% priority 3 cbq(red borrow)
  queue net_dmz_misc bandwidth 50% priority 1 cbq(default borrow)


# ... раздел фильтров pf.conf ...

main_net  = "192.168.0.0/24"
it_net    = "192.168.1.0/24"
int_nets  = "{ 192.168.0.0/24, 192.168.1.0/24 }"
dmz_net   = "10.0.0.0/24"

boss      = "192.168.0.200"
wwwserv   = "10.0.0.100"

# запрет по умолчанию
block on { fxp0, fxp1, dc0 } all

# правила фильтра для входящих пакетов на интерфейсе fxp0
pass in on fxp0 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 queue www_ext_http

# правила фильтра для исходящих пакетов на интерфейсе fxp0
pass out on fxp0 from $int_nets
pass out on fxp0 from $boss queue boss_ext

# правила фильтра для входящих пакетов на интерфейсе dc0
pass in on dc0 from $int_nets
pass in on dc0 from $it_net queue it_int
pass in on dc0 from $boss queue boss_int
pass in on dc0 proto tcp from $int_nets to $wwwserv port { 21, 80, \
	&gt; 49151 } queue www_int

# правила фильтра для исходящих пакетов на интерфейсе dc0
pass out on dc0 from dc0 to $int_nets

# правила фильтра для входящих пакетов на интерфейсе fxp1
pass in on fxp1 proto { tcp, udp } from $wwwserv to port 53

# правила фильтра для исходящих пакетов на интерфейсе fxp1
pass out on fxp1 proto tcp to $wwwserv port { 21, \
	&gt; 49151 } queue net_dmz_misc
pass out on fxp1 proto tcp to $wwwserv port 80 queue net_dmz_http
pass out on fxp1 proto tcp from $int_nets to $wwwserv port { 80, \
	21, &gt; 49151 } queue internal_dmz
</pre>
</td></tr>
</tbody></table>

<p>
[<a href="anchors.html">Предыдущая: Якоря</a>]
[<a href="index.html">Содержание</a>]
[<a href="pools.html">Следующая: Пулы адресов и балансировка нагрузки</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: queueing.html,v 1.44 ]<br>
$Translation: queueing.html,v 1.8 2012/12/07 11:38:31 alex Exp $<br>
-->
$OpenBSD: queueing.html,v 1.4 2012/12/08 09:15:21 ajacoutot Exp $
</small>
 
</body>
</html>@


1.4
log
@Sync with Steelix CVS
@
text
@d910 1
a910 1
$OpenBSD$
@


1.3
log
@Sync with Steelix CVS
@
text
@a6 1

d34 2
a35 2
<a href="http://openbsd.org/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="./queueing_o_files/smalltitle.gif" border="0">
d50 2
a51 2
<li><a href="http://openbsd.org/faq/pf/queueing.html#queueing">Очереди</a>
<li><a href="http://openbsd.org/faq/pf/queueing.html#sched">Планировщики</a>
d53 4
a56 4
	<li><a href="http://openbsd.org/faq/pf/queueing.html#cbq">Управление очередями, основанное на классах</a>
	<li><a href="http://openbsd.org/faq/pf/queueing.html#priq">Управление очередями, основанное на приоритетах</a>
	<li><a href="http://openbsd.org/faq/pf/queueing.html#red">Ранняя случайная диагностика (Random Early Detection)</a>
	<li><a href="http://openbsd.org/faq/pf/queueing.html#ecn">Явное уведомление о перегрузке (Explicit Congestion Notification)</a>
d58 4
a61 4
<li><a href="http://openbsd.org/faq/pf/queueing.html#altq">Настройка очередей</a>
<li><a href="http://openbsd.org/faq/pf/queueing.html#assign">Привязка трафики к очереди</a>
<li><a href="http://openbsd.org/faq/pf/queueing.html#example1">Пример #1: Small, Home Network</a>
<li><a href="http://openbsd.org/faq/pf/queueing.html#example2">Пример #2: Company Network</a>
d362 1
a362 1
<a href="http://openbsd.org/faq/pf/config.html#activate">Приступая к работе</a>.
d515 1
a515 1
(<a href="http://openbsd.org/faq/pf/filter.html">filter rules</a>).
d604 1
a604 1
<h2>Пример #1: Малая, домашняя сеть</h2>
d775 2
a776 3
<a href="http://openbsd.org/faq/pf/nat.html"><tt>nat</tt></a>,
<a href="http://openbsd.org/faq/pf/rdr.html"><tt>rdr</tt></a>,
<a href="http://openbsd.org/faq/pf/options.html">options</a>,
d908 1
a908 1
$Translation: queueing.html,v 1.6 2012/11/01 21:43:44 alex Exp $<br>
@


1.2
log
@Sync with Steelix CVS
@
text
@d367 1
a367 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5&manpath=OpenBSD+5.1">
d909 2
a910 2
Originally [OpenBSD: queueing.html,v 1.43 ]<br>
$Translation: queueing.html,v 1.5 2012/09/19 19:44:49 alex Exp $<br>
@


1.1
log
@Sync with Steelix CVS
@
text
@d1 1
a1 1
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
d4 2
a5 1
<title>PF: Packet Queueing and Prioritization</title>
d7 1
a7 1
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
d9 3
a11 3
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
d35 2
a36 2
<a href="../../../ru/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
d39 3
a41 3
[<a href="anchors.html">Previous: Anchors</a>]
[<a href="index.html">Contents</a>]
[<a href="pools.html">Next: Address Pools and Load Balancing</a>]
d44 1
a44 1
<h1><font color="#e00000">PF: Packet Queueing and Prioritization</font></h1>
d49 1
a49 1
<h3>Table of Contents</h3>
d51 2
a52 2
<li><a href="#queueing">Queueing</a>
<li><a href="#sched">Schedulers</a>
d54 4
a57 4
	<li><a href="#cbq">Class Based Queueing</a>
	<li><a href="#priq">Priority Queueing</a>
	<li><a href="#red">Random Early Detection</a>
	<li><a href="#ecn">Explicit Congestion Notification</a>
d59 4
a62 4
<li><a href="#altq">Configuring Queueing</a>
<li><a href="#assign">Assigning Traffic to a Queue</a>
<li><a href="#example1">Example #1: Small, Home Network</a>
<li><a href="#example2">Example #2: Company Network</a>
d68 1
a68 1
<h2>Queueing</h2>
d70 27
a96 28
To queue something is to store it, in order, while it awaits
processing. In a computer network, when data packets are sent out from a
host, they enter a queue where they await processing by the operating
system.  The operating system then decides which queue and which
packet(s) from that queue should be processed. The order in which the
operating system selects the packets to process can affect network
performance. For example, imagine a user running two network
applications: SSH and FTP. Ideally, the SSH packets should be
processed before the FTP packets because of the time-sensitive nature
of SSH; when a key is typed in the SSH client, an immediate response 
is expected, but an FTP transfer being delayed by a few extra
seconds hardly bears any notice.  But what happens if the router
handling these connections processes a large chunk of packets from the
FTP connection before processing the SSH connection? Packets from the
SSH connection will remain in the queue (or possibly be dropped by the
router if the queue isn't big enough to hold all of the packets)
and the SSH session may appear to lag or slow down.  By modifying the
queueing strategy being used, network bandwidth can be shared fairly
between different applications, users, and computers.

<p>
Note that queueing is only useful for packets in the <i>outbound</i>
direction. Once a packet arrives on an interface in the inbound
direction it's already too late to queue it -- it's already consumed
network bandwidth to get to the interface that just received it. The
only solution is to enable queueing on the adjacent router or, if the
host that received the packet is acting as a router, to enable queueing
on the internal interface where packets exit the router.
d99 8
a106 8
<h2>Schedulers</h2>
The scheduler is what decides which queues to process and in what order.
By default, OpenBSD uses a First In First Out (FIFO) scheduler. A FIFO
queue works like the line-up at a supermarket's checkout -- the first
item into the queue is the first processed. As new packets arrive they
are added to the end of the queue. If the queue becomes full, and here
the analogy with the supermarket stops, newly arriving packets are dropped.
This is known as tail-drop.
d109 1
a109 1
OpenBSD supports two additional schedulers:
d111 2
a112 2
<li>Class Based Queueing
<li>Priority Queueing
d116 18
a133 16
<h3>Class Based Queueing</h3>
Class Based Queueing (CBQ) is a queueing algorithm that divides a
network connection's bandwidth among multiple queues or classes.  Each
queue then has traffic assigned to it based on source or destination
address, port number, protocol, etc.  A queue may optionally be
configured to borrow bandwidth from its parent queue if the parent is
being under-utilized.  Queues are also given a priority such that those
containing interactive traffic, such as SSH, can have their packets
processed ahead of queues containing bulk traffic, such as FTP.

<p>
CBQ queues are arranged in an hierarchical manner.  At the top of the
hierarchy is the root queue which defines the total amount of bandwidth
available.  Child queues are created under the root queue, each of
which can be assigned some portion of the root queue's bandwidth.  For
example, queues might be defined as follows:
d137 3
a139 3
	<dd>Queue A (1Mbps)
	<dd>Queue B (500Kbps)
	<dd>Queue C (500Kbps)
d141 1
d145 2
a146 2
In this case, the total available bandwidth is set to 2 megabits per
second (Mbps). This bandwidth is then split among three child queues.
d149 5
a153 4
The hierarchy can further be expanded by defining queues within queues.
To split bandwidth equally among different users and also classify their
traffic so that certain protocols don't starve others for bandwidth, a
queueing structure like this might be defined:
d159 2
a160 2
		<dd>ssh (50Kbps)
		<dd>bulk (950Kbps)
d162 1
a162 1
	<dd>UserB (1Mbps)
d164 1
a164 1
		<dd>audio (250Kbps)
d167 2
a168 2
			<dd>http (100Kbps)
			<dd>other (650Kbps)
d170 1
d172 1
d174 1
d178 3
a180 2
Note that at each level the sum of the bandwidth assigned to each of the
queues is not more than the bandwidth assigned to the parent queue.
d183 4
a186 3
A queue can be configured to borrow bandwidth from its parent if the
parent has excess bandwidth available due to it not being used by
the other child queues.  Consider a queueing setup like this:
d192 2
a193 2
		<dd>ssh (100Kbps)
		<dd>ftp (900Kbps, borrow)
d195 2
a196 1
	<dd>UserB (1Mbps)
d198 1
d202 8
a209 7
If traffic in the <tt>ftp</tt> queue exceeds 900Kbps and traffic in the
<tt>UserA</tt> queue is less than 1Mbps (because the <tt>ssh</tt> queue is using
less than its assigned 100Kbps), the <tt>ftp</tt> queue will borrow the
excess bandwidth from <tt>UserA</tt>.  In this way the <tt>ftp</tt>
queue is able to use more than its assigned bandwidth when it faces
overload.  When the <tt>ssh</tt> queue increases its load, the borrowed
bandwidth will be returned.
d212 5
a216 5
CBQ assigns each queue a priority level. Queues with a higher priority
are preferred during congestion over queues with a lower priority as
long as both queues share the same parent (in other words, as long as
both queues are on the same branch in the hierarchy).  Queues with the
same priority are processed in a round-robin fashion.  For example:
d222 2
a223 2
		<dd>ssh (100Kbps, priority 5)
		<dd>ftp (900Kbps, priority 3)
d225 2
a226 1
	<dd>UserB (1Mbps, priority 1)
d228 1
d232 11
a242 9
CBQ will process the <tt>UserA</tt> and <tt>UserB</tt> queues in a
round-robin fashion -- neither queue will be preferred over the other.
During the time when the <tt>UserA</tt> queue is being processed, CBQ
will also process its child queues.  In this case, the <tt>ssh</tt>
queue has a higher priority and will be given preferential treatment
over the <tt>ftp</tt> queue if the network is congested.  Note how the
<tt>ssh</tt> and <tt>ftp</tt> queues do not have their priorities
compared to the <tt>UserA</tt> and <tt>UserB</tt> queues because they
are not all on the same branch in the hierarchy.
d245 1
a245 1
For a more detailed look at the theory behind CBQ, please see
d249 6
a254 7
<h3>Priority Queueing</h3>
Priority Queueing (PRIQ) assigns multiple queues to a network
interface with each queue being given a priority level. A queue
with a higher priority is <i>always</i> processed ahead of a queue with
a lower priority. 
If two or more queues are assigned the same priority then those queues
are processed in a round-robin fashion.
d257 4
a260 4
The queueing structure in PRIQ is flat -- you cannot define queues
within queues. The root queue is defined, which sets the total amount of
bandwidth that is available, and then sub queues are defined under the
root. Consider the following example:
d264 2
a265 2
	<dd>Queue A (priority 1)
	<dd>Queue B (priority 2)
d267 2
a268 2
	</dl>
</dl>
d271 16
a286 14
The root queue is defined as having 2Mbps of bandwidth available to it
and three subqueues are defined. The queue with the highest priority
(the highest priority number) is served first. Once all the packets
in that queue are processed, or if the queue is found to be empty, PRIQ
moves onto the queue with the next highest priority.  Within a given
queue, packets are processed in a First In First Out (FIFO) manner.

<p>
It is important to note that when using PRIQ you must plan your queues
very carefully.  Because PRIQ <i>always</i> processes a higher priority
queue before a lower priority one, it's possible for a high priority
queue to cause packets in a lower priority queue to be delayed or
dropped if the high priority queue is receiving a constant stream of
packets.
d289 42
a330 41
<h3>Random Early Detection</h3>
Random Early Detection (RED) is a congestion avoidance algorithm. Its
job is to avoid network congestion by making sure that the queue doesn't
become full. It does this by continually calculating the average length
(size) of the queue and comparing it to two thresholds, a minimum
threshold and a maximum threshold. If the average queue size is below
the minimum threshold then no packets will be dropped. If the average is
above the maximum threshold then <i>all</i> newly arriving packets will
be dropped. If the average is between the threshold values then packets
are dropped based on a probability calculated from the average queue
size. In other words, as the average queue size approaches the maximum
threshold, more and more packets are dropped. When dropping packets,
RED randomly chooses which connections to drop packets from.
Connections using larger amounts of bandwidth have a higher probability
of having their packets dropped.

<p>
RED is useful because it avoids a situation known as global
synchronization and it is able to accommodate bursts of traffic.  Global
synchronization refers to a loss of total throughput due to packets
being dropped from several connections at the same time. For example, if
congestion occurs at a router carrying traffic for 10 FTP connections
and packets from all (or most) of these connections are dropped (as is
the case with FIFO queueing), overall throughput will drop sharply. This
isn't an ideal situation because it causes all of the FTP connections to
reduce their throughput and also means that the network is no longer
being used to its maximum potential.  RED avoids this by randomly
choosing which connections to drop packets from instead of choosing all
of them. Connections using large amounts of bandwidth have a higher
chance of their packets being dropped. In this way, high bandwidth
connections will be throttled back, congestion will be avoided, and
sharp losses of overall throughput will not occur. In addition, RED is
able to handle bursts of traffic because it starts to drop packets
<i>before</i> the queue becomes full. When a burst of traffic comes
through there will be enough space in the queue to hold the new packets.

<p>
RED should only be used when the transport protocol is capable of
responding to congestion indicators from the network. In most cases
this means RED should be used to queue TCP traffic and not UDP or ICMP
traffic.
d333 1
a333 1
For a more detailed look at the theory behind RED, please see
d337 7
a343 7
<h3>Explicit Congestion Notification</h3>
Explicit Congestion Notification (ECN) works in conjunction with RED to
notify two hosts communicating over the network of any congestion along
the communication path. It does this by enabling RED to set a flag in
the packet header instead of dropping the packet. Assuming the sending
host has support for ECN, it can then read this flag and throttle back
its network traffic accordingly.
d346 1
a346 1
For more information on ECN, please refer to 
d350 21
a370 19
<h2>Configuring Queueing</h2>
Since OpenBSD 3.0 the 
<a href="http://www.csl.sony.co.jp/person/kjc/kjc/software.html#ALTQ"
>Alternate Queueing (ALTQ)</a> queueing implementation has been a part of
the base system. Starting with OpenBSD 3.3 ALTQ has been integrated into
PF.  OpenBSD's ALTQ implementation supports the Class Based Queueing
(CBQ) and Priority Queueing (PRIQ) schedulers. It also supports Random
Early Detection (RED) and Explicit Congestion Notification (ECN).

<p>
Because ALTQ has been merged with PF, PF must be enabled for queueing to
work. Instructions on how to enable PF can be found in
<a href="config.html#activate">Getting Started</a>.

<p>
Queueing is configured in <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.5"
>pf.conf</a></tt>. There are two types of directives that are used
to configure queueing:
d372 3
a374 3
<li><tt>altq on</tt> - enables queueing on an interface, defines which
scheduler to use, and creates the root queue
<li><tt>queue</tt> - defines the properties of a child queue
d378 1
a378 1
The syntax for the <tt>altq on</tt> directive is:
d388 19
a406 15
<li><tt><i>interface</i></tt> - the network interface to activate queueing on.
<li><tt><i>scheduler</i></tt> - the queueing scheduler to use. Possible values are 
<tt>cbq</tt> and <tt>priq</tt>. Only one scheduler may be active on an
interface at a time.
<li><tt><i>bw</i></tt> - the total amount of bandwidth available to the scheduler.
This may be specified as an absolute value using the suffixes <tt>b</tt>,
<tt>Kb</tt>, <tt>Mb</tt>, and <tt>Gb</tt> to represent bits, kilobits,
megabits, and gigabits per second, respectively or as a percentage of the
<tt><i>interface</i></tt> bandwidth.
<li><tt><i>qlim</i></tt> - the maximum number of packets to hold in the queue. 
This parameter is optional. The default is 50.
<li><tt><i>size</i></tt> - the size of the token bucket regulator in bytes. If not
specified, the size is set based on the <tt><i>interface</i></tt> bandwidth.
<li><tt><i>queue_list</i></tt> - a list of child queues to create under the root
queue.
d410 1
a410 1
For example:
d416 3
a418 3
This enables CBQ on the <tt>fxp0</tt> interface. The total bandwidth available is
set to 2Mbps. Three child queues are defined: <tt>std</tt>,
<tt>ssh</tt>, and <tt>ftp</tt>.
d421 1
a421 1
The syntax for the <tt>queue</tt> directive is:
d432 27
a458 26
<li><tt><i>name</i></tt> - the name of the queue. This must match the
name of one of the queues defined in the <tt>altq on</tt> directive's
<tt><i>queue_list</i></tt>. For <tt>cbq</tt> it can also match the name
of a queue in a previous <tt>queue</tt> directive's
<tt><i>queue_list</i></tt>. Queue names must be no longer than 15 characters.
<li><tt><i>interface</i></tt> - the network interface that the queue is
valid on. This value is optional, and when not specified, will make
the queue valid on all interfaces.
<li><tt><i>bw</i></tt> - the total amount of bandwidth available to the
queue.
This may be specified as an absolute value using the suffixes <tt>b</tt>,
<tt>Kb</tt>, <tt>Mb</tt>, and <tt>Gb</tt> to represent bits, kilobits,
megabits, and gigabits per second, respectively or as a percentage of the
parent queue's bandwidth.
This parameter is only applicable when using the <tt>cbq</tt> scheduler.
If not specified, the default is 100% of the parent queue's bandwidth.
<li><tt><i>pri</i></tt> - the priority of the queue. For <tt>cbq</tt> the
priority range is 0 to 7 and for <tt>priq</tt> the range is 0 to 15.
Priority 0 is the lowest priority. When not specified, a default of 1 is
used.
<li><tt><i>qlim</i></tt> - the maximum number of packets to hold in the queue. 
When not specified, a default of 50 is used.
<li><tt><i>scheduler</i></tt> - the scheduler being used, either <tt>cbq</tt>
or <tt>priq</tt>. Must be the same as the root queue.
<li><tt><i>sched_options</i></tt> - further options may be passed to the scheduler
to control its behavior:
d460 13
a472 11
	<li><tt>default</tt> - defines a default queue where all packets not
	matching any other queue will be queued. Exactly one default queue
	is required.
	<li><tt>red</tt> - enables Random Early Detection (RED) on this queue.
	<li><tt>rio</tt> - enables RED with IN/OUT. In this mode, RED will
	maintain multiple average queue lengths and multiple threshold
	values, one for each IP Quality of Service level.
	<li><tt>ecn</tt> - enables Explicit Congestion Notification (ECN) on
	this queue. <tt>Ecn</tt> implies <tt>red</tt>.
	<li><tt>borrow</tt> - the queue can borrow bandwidth from its parent. This can
	only be specified when using the <tt>cbq</tt> scheduler.
d474 3
a476 3
<li><tt><i>queue_list</i></tt> - a list of child queues to create under this
queue. A <tt><i>queue_list</i></tt> may only be defined when using the
<tt>cbq</tt> scheduler.
d480 1
a480 1
Continuing with the example above:
d492 18
a509 19
Here the parameters of the previously defined child queues are set. The
<tt>std</tt> queue is assigned a bandwidth of 50% of the root queue's
bandwidth (or 1Mbps) and is set as the default queue. The <tt>ssh</tt>
queue is assigned 25% of the root queue's bandwidth (500kb) and also
contains two child queues, <tt>ssh_login</tt> and
<tt>ssh_bulk</tt>. The <tt>ssh_login</tt> queue is given a higher
priority than <tt>ssh_bulk</tt> and both have ECN enabled.  The
<tt>ftp</tt> queue is assigned a bandwidth of 500Kbps and given a
priority of 3. It can also borrow bandwidth when extra is available and
has RED enabled. 

<p>
<b>NOTE:</b> Each child queue definition has its bandwidth specified.
Without specifying the bandwidth, PF will give the queue 100% of the
parent queue's bandwidth.
In this situation, that would cause an error when the rules are loaded
since if there's a queue with 100% of the bandwidth, no other queue can
be defined at that level since there is no free bandwidth to allocate to
it.
d512 1
a512 1
<h3>Assigning Traffic to a Queue</h3>
d514 4
a517 3
To assign traffic to a queue, the <tt>queue</tt> keyword is used in
conjunction with PF's <a href="filter.html">filter rules</a>. For example,
consider a set of filtering rules containing a line such as:
d519 1
a519 1
<tt>pass out on fxp0 from any to any port 22</tt>
d523 2
a524 2
Packets matching that rule can be assigned to a specific queue by using
the <tt>queue</tt> keyword:
d526 1
a526 1
<tt>pass out on fxp0 from any to any port 22 queue ssh</tt>
d530 18
a547 3
When using the <tt>queue</tt> keyword with <tt>block</tt> directives, any
resulting TCP RST or ICMP Unreachable packets are assigned to the specified
queue.
d550 2
a551 2
Note that queue designation can happen on an interface other than the one
defined in the <tt>altq on</tt> directive:
d558 1
a558 1
pass in on dc0 from any to any port 21 queue ftp<br>
d563 17
a579 16
Queueing is enabled on <tt>fxp0</tt> but the designation takes place
on <tt>dc0</tt>. 
If packets matching the <tt>pass</tt> rule exit from interface 
<tt>fxp0</tt>, they will be queued in the <tt>ftp</tt> queue. 
This type of queueing can be very useful on routers.

<p>
Normally only one queue name is given with the <tt>queue</tt> keyword,
but if a second name is specified that queue will be used for packets
with a <a href="http://www.rfc-editor.org/rfc/rfc791.txt">Type of
Service (ToS)</a> of low-delay and for TCP ACK packets with no data payload.
A good example of this is found when using SSH. SSH login sessions will
set the ToS to low-delay while SCP and SFTP sessions will not. PF can
use this information to queue packets belonging to a login connection in a
different queue than non-login connections. This can be useful to prioritize
login connection packets over file transfer packets.
d585 18
a602 37
This assigns packets belonging to SSH login connections to the
<tt>ssh_login</tt> queue and packets belonging to SCP and SFTP
connections to the <tt>ssh_bulk</tt> queue. SSH login connections will
then have their packets processed ahead of SCP and SFTP connections
because the <tt>ssh_login</tt> queue has a higher priority.

<p>
Assigning TCP ACK packets to a higher priority queue is useful on
asymmetric connections, that is, connections that have different upload
and download bandwidths such as ADSL lines. With an ADSL line, if the
upload channel is being maxed out and a download is started, the
download will suffer because the TCP ACK packets it needs to
send will run into congestion when they try to pass through the upload
channel. Testing has shown that to achieve the best results, the
bandwidth on the upload queue should be set to a value less than what
the connection is capable of. For instance, if an ADSL line has a max
upload of 640Kbps, setting the root queue's <tt>bandwidth</tt> to a value
such as 600Kb should result in better performance. Trial and error will
yield the best <tt>bandwidth</tt> setting.

<p>
When using the <tt>queue</tt> keyword with rules that <tt>keep
state</tt> such as:
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port 22 flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state queue ssh
</tt>
</blockquote>

<p>
PF will record the queue in the state table entry so that packets
traveling back out <tt>fxp0</tt> that match the stateful connection will
end up in the <tt>ssh</tt> queue. Note that even though the <tt>queue</tt>
keyword is being used on a rule filtering incoming traffic, the goal is
to specify a queue for the corresponding outgoing traffic; the above
rule does not queue incoming packets.
d605 3
a607 4
<h2>Example #1: Small, Home Network</h2>
<pre>
  
    [ Alice ]    [ Charlie ]
d609 1
a609 1
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Internet )
d611 1
a611 1
           [ Bob ]
d616 4
a619 4
In this example, OpenBSD is being used on an Internet gateway for a small
home network with three workstations. The gateway is performing packet
filtering and NAT duties. The Internet connection is via an ADSL line
running at 2Mbps down and 640Kbps up.
d622 1
a622 1
The queueing policy for this network:
d624 8
a631 8
<li>Reserve 80Kbps of download bandwidth for Bob so he can play his
online games without being lagged by Alice or Charlie's downloads. Allow
Bob to use more than 80Kbps when it's available.
<li>Interactive SSH and instant message traffic will have a higher
priority than regular traffic.
<li>DNS queries and replies will have the second highest priority.
<li>Outgoing TCP ACK packets will have a higher priority than all other
outgoing traffic.
d635 3
a637 5
Below is the ruleset that meets this network policy. Note that only the
<tt>pf.conf</tt> directives that apply directly to the above policy are
present; <a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">options</a>,
etc., are not shown.
d640 7
a646 7
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# enable queueing on the external interface to control traffic going to
# the Internet. use the priq scheduler to control only priorities. set
# the bandwidth to 610Kbps to get the best performance out of the TCP
# ACK queue.
d651 7
a657 7
# define the parameters for the child queues.
# std_out      - the standard queue. any filter rule below that does not
#                explicitly specify a queue will have its traffic added
#                to this queue.
# ssh_im_out   - interactive SSH and various instant message traffic.
# dns_out      - DNS queries.
# tcp_ack_out  - TCP ACK packets with no data payload.
d664 3
a666 3
# enable queueing on the internal interface to control traffic coming in
# from the Internet. use the cbq scheduler to control bandwidth. max
# bandwidth is 2Mbps.
d670 8
a677 8
# define the parameters for the child queues.
# std_in      - the standard queue. any filter rule below that does not
#               explicitly specify a queue will have its traffic added
#               to this queue.
# ssh_im_in   - interactive SSH and various instant message traffic.
# dns_in      - DNS replies.
# bob_in      - bandwidth reserved for Bob's workstation. allow him to
#               borrow.
d685 1
a685 1
# ... in the filtering section of pf.conf ...
d694 1
a694 1
# filter rules for fxp0 inbound
d697 1
a697 1
# filter rules for fxp0 outbound
d699 8
a706 9
pass  out on fxp0 inet proto tcp from (fxp0) to any flags S/SA \
	keep state queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0) to any keep state
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to any port domain \
	keep state queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to any port $ssh_ports \
	flags S/SA keep state queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to any port $im_ports \
	flags S/SA keep state queue(ssh_im_out, tcp_ack_out)
d708 1
a708 1
# filter rules for dc0 inbound
d712 1
a712 1
# filter rules for dc0 outbound
d714 2
a715 2
pass  out on dc0 from any to $local_net
pass  out on dc0 proto { tcp udp } from any port domain to $local_net \
d717 1
a717 1
pass  out on dc0 proto tcp from any port $ssh_ports to $local_net \
d719 1
a719 1
pass  out on dc0 proto tcp from any port $im_ports to $local_net \
d721 1
a721 1
pass  out on dc0 from any to $bob queue bob_in
d724 1
a724 1
</table>
d727 1
a727 1
<h2>Example #2: Company Network</h2>
d729 1
a729 2

  ( IT Dept )  [ Boss's PC ]
d731 1
a731 1
     --+----+-----+---------- dc0 [ OpenBSD ] fxp0 -------- ( Internet )
d740 7
a746 7
In this example, the OpenBSD host is acting as a firewall for a company
network. The company runs a WWW server in the DMZ portion of their
network where customers upload their websites via FTP. The IT department
has their own subnet connected to the main network, and the boss has a PC
on his desk that's used for email and surfing the web. The connection to
the Internet is via a T1 line running at 1.5Mbps in both directions. All
other network segments are using Fast Ethernet (100Mbps).
d749 1
a749 1
The network administrator has decided on the following policy:
d751 2
a752 2
<li>Limit all traffic between the WWW server and the Internet to 500Kbps in
each direction.
d754 7
a760 6
	<li>Allot 250Kbps to HTTP traffic.
	<li>Allot 250Kbps to "other" traffic (i.e., non-HTTP traffic)
	<li>Allow either queue to borrow up to the full 500Kbps.
	<li>Give HTTP traffic between the WWW server and the Internet a
	higher priority than other traffic between the WWW server and the
	Internet (such as FTP uploads).
d762 8
a769 7
<li>Traffic between the WWW server and the internal network can use up
to the full 100Mbps that the network offers.
<li>Reserve 500Kbps for the IT Dept network so they can download the
latest software updates in a timely manner. They should be able to use
more than 500Kbps when extra bandwidth is available.
<li>Give traffic between the boss's PC and the Internet a higher
priority than other traffic to/from the Internet.
d773 7
a779 5
Below is the ruleset that meets this network policy. Note that only the
<tt>pf.conf</tt> directives that apply directly to the above policy are
present; <a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">options</a>,
etc., are not shown.
d782 6
a787 6
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# enable queueing on the external interface to queue packets going out
# to the Internet. use the cbq scheduler so that the bandwidth use of
# each queue can be controlled. the max outgoing bandwidth is 1.5Mbps.
d791 4
a794 4
# define the parameters for the child queues.
# std_ext        - the standard queue. also the default queue for
#                  outgoing traffic on fxp0.
# www_ext        - container queue for WWW server queues. limit to
d796 3
a798 3
#   www_ext_http - http traffic from the WWW server; higher priority.
#   www_ext_misc - all non-http traffic from the WWW server.
# boss_ext       - traffic coming from the boss's computer.
d806 7
a812 6
# enable queueing on the internal interface to control traffic coming
# from the Internet or the DMZ. use the cbq scheduler to control the
# bandwidth of each queue. bandwidth on this interface is set to the
# maximum. traffic coming from the DMZ will be able to use all of this
# bandwidth while traffic coming from the Internet will be limited to
# 1.0Mbps (because 0.5Mbps (500Kbps) is being allocated to fxp1).
d816 8
a823 8
# define the parameters for the child queues.
# net_int    - container queue for traffic from the Internet. bandwidth
#              is 1.0Mbps.
#   std_int  - the standard queue. also the default queue for outgoing
#              traffic on dc0.
#   it_int   - traffic to the IT Dept network; reserve them 500Kbps.
#   boss_int - traffic to the boss's PC; assign a higher priority.
# www_int    - traffic from the WWW server in the DMZ; full speed.
d831 6
a836 6
# enable queueing on the DMZ interface to control traffic destined for
# the WWW server. cbq will be used on this interface since detailed
# control of bandwidth is necessary. bandwidth on this interface is set
# to the maximum. traffic from the internal network will be able to use
# all of this bandwidth while traffic from the Internet will be limited
# to 500Kbps.
d840 5
a844 5
# define the parameters for the child queues.
# internal_dmz   - traffic from the internal network.
# net_dmz        - container queue for traffic from the Internet.
#   net_dmz_http - http traffic; higher priority.
#   net_dmz_misc - all non-http traffic. this is also the default queue.
d852 1
a852 1
# ... in the filtering section of pf.conf ...
d862 1
a862 1
# default deny
d865 1
a865 1
# filter rules for fxp0 inbound
d867 11
a877 12
	&gt; 49151 } flags S/SA keep state queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue www_ext_http

# filter rules for fxp0 outbound
pass out on fxp0 from $int_nets to any keep state
pass out on fxp0 from $boss to any keep state queue boss_ext

# filter rules for dc0 inbound
pass in on dc0 from $int_nets to any keep state
pass in on dc0 from $it_net to any queue it_int
pass in on dc0 from $boss to any queue boss_int
d879 1
a879 1
	&gt; 49151 } flags S/SA keep state queue www_int
d881 1
a881 1
# filter rules for dc0 outbound
d884 7
a890 9
# filter rules for fxp1 inbound
pass in on fxp1 proto { tcp, udp } from $wwwserv to any port 53 \
	keep state

# filter rules for fxp1 outbound
pass out on fxp1 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } flags S/SA keep state queue net_dmz_misc
pass out on fxp1 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue net_dmz_http
d892 1
a892 1
	21, &gt; 49151 } flags S/SA keep state queue internal_dmz
d895 1
a895 1
</table>
d898 3
a900 3
[<a href="anchors.html">Previous: Anchors</a>]
[<a href="index.html">Contents</a>]
[<a href="pools.html">Next: Address Pools and Load Balancing</a>]
d904 1
a904 1
<a href="../../pf/ru/index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
d909 2
a910 2
Originally [OpenBSD: queueing.html,v 1.37 ]<br>
$Translation: queueing.html,v 1.4 2009/08/01 21:47:52 tobias Exp $<br>  
d914 1
a914 1

d916 1
a916 1
</html> 
@

