head	1.15;
access;
symbols;
locks; strict;
comment	@# @;


1.15
date	2014.04.01.17.14.10;	author nick;	state dead;
branches;
next	1.14;

1.14
date	2011.03.13.07.16.15;	author ajacoutot;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.02.12.46.38;	author jufi;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.04.22.29.12;	author horacio;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.03.21.40.56;	author horacio;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.17.19.44.24;	author horacio;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.27.14.55.54;	author horacio;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.20.07.00.26;	author horacio;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.16.20.11.34;	author jufi;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.11.19.44.31;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.06.15.17.26;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.21.11.27.36;	author jufi;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.15.12.27.34;	author jufi;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.09.08.59.36;	author jufi;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.28.14.39.30;	author jufi;	state Exp;
branches;
next	;


desc
@@


1.15
log
@
Abandon translations, per deraadt@@ and ajacoutot@@.
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtrado de paquetes</title>
<link rev="made" href="mailto:www@@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../es/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Anterior: Tablas</a>]
[<a href="index.html">Contenido</a>]
[<a href="nat.html">Siguiente: Traducción de Direcciones de
Red</a>]

<h1><font color="#e00000">PF: Filtrado de paquetes</font></h1>

<hr>

<h3>Índice de contenidos</h3>
<ul>
<li><a href="#intro">Introducción</a>
<li><a href="#syntax">Sintaxis de las reglas</a>
<li><a href="#defdeny">Denegación predeterminada</a>
<li><a href="#pass">Paso de tráfico</a>
<li><a href="#quick">La palabra-clave <tt>quick</tt></a>
<li><a href="#state">Mantenimiento del estado</a>
<li><a href="#udpstate">Mantenimiento del estado para UDP</a>
<li><a href="#stateopts">Opciones de seguimiento de estado</a>
<li><a href="#tcpflags">Indicadores de TCP</a>
<li><a href="#synproxy">Proxy de paquetes TCP SYN</a>
<li><a href="#antispoof">Bloqueo de paquetes falsificados</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Detección pasiva del Sistema Operativo</a>
<li><a href="#ipopts">Opciones de IP</a>
<li><a href="#example">Ejemplo de grupo de reglas de filtrado</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Introducción</h2>
<p>
La acción de filtrar paquetes es bloquear o permitir el paso a
los paquetes de datos de forma selectiva, según van llegando a
una interfaz de red.  Los criterios que usa
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.8"
>pf(4)</a>
para inspeccionar los paquetes los toma de la información
existente en la capa 'Layer 3'
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> and 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>)
y en la capa 'Layer 4'
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>) de las cabeceras de los paquetes.  Los criterios que más se
utilizan son los de la dirección de origen y de destino, el
puerto de origen y de destino, y el protocolo.

<p>
Las reglas de filtrado especifican los criterios con los que debe
concordar un paquete y la acción a seguir, bien sea bloquearlo o
permitir que pase, que se toma cuando se encuentra una concordancia.
Las reglas de filtrado se evalúan por orden de secuencia, de la
primera a la última.  A menos que el paquete concuerde con una
regla que contenga la clave <tt>quick</tt>, se evaluará el
paquete comparándolo con <i>todas</i> las reglas de filtrado
antes de decidir una acción final.  La última regla que
concuerde será la &laquo;ganadora&raquo; y la que dictamine
qué acción se tomará con el paquete.  Al principio del
grupo de reglas de filtrado hay un <tt>pass all</tt> implícito
que indica que si algún paquete no concuerda con ninguna de las
reglas de filtrado, la acción a seguir será <tt>pass</tt>,
o sea permitirle el paso.

<a name="syntax"></a>
<h2>Sintaxis de las reglas</h2>
<p>
La sintaxis general, <i>muy simplificada</i>, para las reglas de
filtrado es:
<blockquote>
<tt>
<i>action</i> [<i>direction</i>] [log] [quick] [on <i>interface</i>] 
[<i>af</i>] [proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to 
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>La acción a seguir para los paquetes que concuerden, ya sea
<tt>pass</tt> o <tt>block</tt>.  La acción <tt>pass</tt>
permitirá el paso al paquete de vuelta hasta el núcleo del
sistema, para que éste lo procese, mientras que la acción
<tt>block</tt> actuará según se indique en la
configuración de la opción de la política de
bloqueo, <a href="options.html#block-policy"><tt>block-policy</tt></a>.
La acción por omisión se puede anular especificando <tt>block
drop</tt> (bloquear y eliminar el paquete) o <tt>block return</tt>
(bloquear y devolver el paquete).

<dt><tt><i>direction</i></tt>
<dd>La dirección en la que se mueve el paquete en una interfaz,
que será <tt>in</tt> (entrante) o <tt>out</tt> (saliente).

<dt><tt>log</tt>
<dd>Indica que se debe registrar el paquete por medio de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.8"
>pflogd(8)</a>.
Si la regla crea un estado, entonces sólo
se registrará el paquete que establezca el estado.  Para
registrar todos los paquetes hay que usar la opción
<tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Si un paquete concuerda con una regla que especifique la
opción <tt>quick</tt>, entonces esa regla se considera como la
regla final de concordancia para el paquete, y se tomará la
acción que esté especificada en <tt><i>action</i></tt>
sin más dilación.

<dt><tt><i>interface</i></tt>
<dd>El nombre o el grupo de la interfaz de red a través del cual se mueve
el paquete.
Los interfaces pueden añadirse a grupos arbitrarios por medio de
la orden <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>
Varios grupos también son creados automáticamente por el kernel:
<ul>
<li>El grupo <tt>egress</tt>, que contiene la(s) interfaces(s) 
relativa(s) a la ruta por omisión.
<li>El grupo de la familia de interfaces clonadas: 
Por ejemplo: <tt>ppp</tt> o <tt>carp</tt>.
</ul>
Esto causaría la concordancia de la regla para todo paquete que
atraviesa cualquier interfaz
<tt>ppp</tt> o <tt>carp</tt>, respectivamente.

<dt><tt><i>af</i></tt>
<dd>La familia de direcciones del paquete, que será <tt>inet</tt>
para IPv4 ó <tt>inet6</tt> para IPv6.  Generalmente, PF es capaz
de determinar este parámetro basándose en la
dirección, o direcciones, de origen y/o de destino.

<dt><tt><i>protocol</i></tt>
<dd>El protocolo de la capa 'Layer 4' del paquete:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Un nombre de protocolo válido del fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
><tt>/etc/protocols</tt></a>
<li>Un número de protocolo entre 0 y 255
<li>Un grupo de protocolos que usen una
<a href="macros.html#lists">lista</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>La dirección de origen y/o de destino en la cabecera IP.  Las
direcciones se pueden especificar como:
<ul>
<li>Una sola dirección IPv4 o IPv6.
<li>Un bloque de red
<a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<li>Un &laquo;Nombre de Dominio Totalmente Cualificado&raquo; (FQDN) que
se resolverá por el &laquo;Servicio de Nombres de Dominio&raquo;
cuando se carguen las reglas.  Todas las direcciones IP resultantes se
sustituirán dentro de la regla.
<li>El nombre de una interfaz de red o grupo.  Cualquier dirección IP
asignada a la interfaz se sustituirá dentro de la regla.
<li>El nombre de una interfaz de red seguido de la máscara de red
como sigue: <tt>/<i>netmask</i></tt> (o sea, <tt>/24</tt>).  Cada
dirección IP en la interfaz se combina con la máscara de
red para formar un bloque de red CIDR, que se sustituye dentro de la
regla.
<li>El nombre de una interfaz de red o grupo entre paréntesis <tt>( )</tt>.  
De este modo se instruye a PF para que actualice la reglas si la
dirección, o direcciones, IP en dicha interfaz cambia.  Es de
gran utilidad cuando la interfaz obtiene su dirección IP por
medio de DHCP o de una conexión tipo <i>dial-up</i> (por
conexión telefónica), ya que no hay que volver a cargar
las reglas cada vez que cambie la dirección.
<li>El nombre de la interfaz de red seguido por cualquiera de los siguientes
modificadores:
  <ul>
  <li><tt>:network</tt> - expande al bloque de red CIDR (por ejemplo:
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - expande a la dirección de difusión
  (<i>broadcast</i>) de la red. (por ejemplo: 192.168.0.255)
  <li><tt>:peer</tt> - expande a la dirección IP del otro extremo en un
  enlace punto a punto.
  </ul>
  <dl>
  <dd>Además, el modificador <tt>:0</tt> puede ser añadido tanto a un nombre
  de interfaz o a cualquiera de los modificadores mencionados arriba para
  indicar que PF no debe incluir la dirección IP de alias en la expansión.
  Estos modificadores también puede ser usados cuando la interfaz está
  entre paréntesis.
  Ejemplo: <tt>fxp0:network:0</tt>
  </dl>
<li>Una <a href="tables.html">tabla</a>.
<li>La palabra-clave <tt>urpf-failed</tt> puede usarse en las direcciones 
origen para indicar que debe continuar a través de una
<a href="#urpf">comprobación uRPF</a>.
<li>Cualquiera de las anteriores en negación, usando el
modificador <tt>!</tt> ("not").
<li>Un grupo de direcciones que usen una
<a href="macros.html#lists">lista</a>.
<li>La clave <tt>any</tt> para indicar todas las direcciones.
<li>La clave <tt>all</tt>, que es una abreviación de
<tt>from any to any</tt>.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>El puerto de origen y/o de destino en la capa 'Layer 4' de la
cabecera IP.  Los puertos se pueden especificar como:
<ul>
<li>Un número entre el 1 y el 65535
<li>Un nombre de servicio válido del fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
><tt>/etc/services</tt></a>
<li>Un grupo de puertos que usen una
<a href="macros.html#lists">lista</a>
<li>Un intervalo:
	<ul>
	<li><tt>!=</tt> (distinto de)
	<li><tt>&lt;</tt> (menor que)
	<li><tt>&gt;</tt> (mayor que)
	<li><tt>&lt;=</tt> (menor o igual que)
	<li><tt>&gt;=</tt> (mayor o igual que)
	<li><tt>&gt;&lt;</tt> (intervalo)
	<li><tt>&lt;&gt;</tt> (intervalo inverso)
	<dl>
	<dd>Los dos últimos son operadores binarios (toman dos
	argumentos) y no incluyen los argumentos en el intervalo.
	</dl>
	<li><tt>:</tt> (intervalo inclusivo)
	<dl>
	<dd>El operador de intervalo inclusivo también es un operador binario
	e incluye el argumento en el intervalo.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Especifica los indicadores que deben existir en la cabecera TCP
cuando se usa <tt>proto tcp</tt>.  Los indicadores se especifican como
<tt>flags <i>check</i>/<i>mask</i></tt>.  Por ejemplo, <tt>flags
S/SA</tt> instruye a PF para que sólo mire los indicadores S y A
(SYN y ACK), y que acepte la concordancia si el indicador SYN
está activo (y esto se aplica a todas las reglas TCP 
predeterminadas).
<tt>flags any</tt> instruye a PF para que no verifique los 
indicadores (<i>flags</i>).

<dt><tt><i>state</i></tt>
<dd>Especifica si se guarda la información sobre el estado en
paquetes que concuerden con esta regla.
<ul>
<li><tt>no state</tt> - funciona con TCP, UDP e ICMP.
PF no trazará esta conexión con estado. Para conexiones 
TCP, <tt>flags any</tt> suele ser necesario.
<li><tt>keep state</tt> - funciona con TCP, UDP e ICMP.
Esta es la opción predeterminada en todas las reglas de filtrado.
<li><tt>modulate state</tt> - sólo funciona con TCP.  PF
generará &laquo;Números de Secuencia Inicial&raquo; (ISNs,
<i>Initial Sequence Numbers</i>) seguros para los paquetes que
concuerden con esta regla.
<li><tt>synproxy state</tt> - hace de proxy para las conexiones TCP
entrantes con el fin de ayudar a proteger a los servidores de
desbordamientos TCP SYN falsificados.  Esta opción incluye las
funcionalidades <tt>keep state</tt> y <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Denegación predeterminada</h2>
<p>
La práctica recomendada para configurar un cortafuegos es la de
tomar una aproximación de &laquo;denegación
predeterminada&raquo;; o sea, denegar el paso a <i>todo</i> y a partir
de ahí ir permitiendo el paso a través del cortafuegos de
forma selectiva a cierto tráfico.  Esta aproximación es la
recomendada ya que los posibles fallos se cometerían a favor de
la seguridad, y también porque hace más fácil la
creación de grupos de reglas.

<p>
Para crear una política de filtrado de denegación
predeterminada, las primeras dos reglas deben ser:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Con esto se bloquea todo el tráfico en todas las interfaces en
cualquier dirección, y desde cualquier origen, hasta cualquier
destino.

<a name="pass"></a>
<h2>Paso de tráfico</h2>
<p>
Ahora hay que permitir de forma explícita y selectiva el paso del
tráfico a través del cortafuegos, o de lo contrario
será bloqueado por la política de denegación
predeterminada.  Aquí es donde entran en juego los criterios del
paquete, como son el puerto de origen/destino, la dirección de
origen/destino, y el protocolo.  Siempre que se permita el paso de
cierto tráfico a través del cortafuegos hay que escribir
las reglas de un modo tan restrictivo como sea posible.  Esto es para
asegurarse de que sólo pasará el tráfico que se
permita, y ningún otro.

<p>
Algunos ejemplos:
<blockquote>
<tt>
# Permitir el paso al tráfico entrante en la interfaz dc0 de la red local,<br>
# 192.168.0.0/24, hacia la dirección IP 192.168.0.1 de la máquina de OpenBSD.<br>
# También permitir el paso al tráfico saliente que es enviado de vuelta en dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Permitir el paso al tráfico entrante TCP en la interfaz fxp0 del servidor<br>
# de <i>web</i> que se encuentra en la máquina de OpenBSD.  El nombre de la<br>
# interfaz, fxp0, se usa como la dirección de destino para que los paquetes<br>
# sólo concuerden con esta regla si tienen como destino la máquina de OpenBSD.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>La palabra-clave <tt>quick</tt></h2>
<p>
Como se ha indicado anteriormente, cada paquete se evalúa con el
grupo de reglas de filtrado, desde la primera hasta la última.
El resultado predeterminado es el de marcar el paquete para que se le
permita el paso;  esto puede cambiar con cualquiera de las reglas por
las que pasa, y podría cambiar varias veces antes de llegar al
final de las reglas de filtrado.  <b>La última regla con la que
concuerde marcará el resultado.</b>  Existe una excepción
para esto:  la opción <tt>quick</tt> en una regla de filtrado
tiene el efecto de cancelar el procesamiento de cualquier regla
consiguiente, y provoca que se ejecute la acción especificada sin
más dilación.  Veamos un par de ejemplos:

<p>
Mal:
<blockquote>
<tt>
block in on fxp0 proto tcp to port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
En este caso, la línea <tt>block</tt> puede ser evaluada, pero
nunca tendrá ningún efecto, ya que va seguida por una
línea que permite el paso de todo.

<p>
Mejor:
<blockquote>
<tt>
block in quick on fxp0 proto tcp to port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Estas reglas se evalúan de una forma algo diferente.  Si un
paquete concuerda con la línea <tt>block</tt>, debido a la
naturaleza de la opción <tt>quick</tt>, se bloqueará el
paso a dicho paquete y se ignorará el resto del grupo de reglas.

<a name="state"></a>
<h2>Mantenimiento del estado</h2>
<p>
Una de las funcionalidades importantes de PF es la del
&laquo;mantenimiento del estado&raquo; (<i>keeping state</i>) o
&laquo;inspección completa del estado&raquo; (<i>stateful
inspection</i>).  La inspección del estado se refiere a la
capacidad de PF de llevar un seguimiento del estado, o del progreso, de
una conexión de red.  Almacenando información sobre cada
conexión en una tabla de estado, PF puede determinar
rápidamente si un paquete que está pasando a través
del cortafuegos pertenece a una conexión ya establecida.  Si es
así, se le permite pasar a través del cortafuegos sin
tener que pasar a través de la evaluación del grupo de
reglas.

<p>
El mantenimiento del estado tiene muchas ventajas, entre otras que los
grupos de reglas son más simples y se obtiene un rendimiento
más alto del filtrado de paquetes.  PF puede puede hacer que los
paquetes que vayan en <i>cualquier</i> dirección concuerden con
entradas en la tabla de estado, lo que quiere decir que no es necesario
escribir reglas de filtrado que permitan el paso del tráfico de
vuelta.  Y, como los paquetes que concuerdan con conexiones
<i>stateful</i> no pasan a través de la evaluación del
grupo de reglas, el tiempo que tarda PF en procesarlos puede reducirse
considerablemente.

<p>
Cuando una regla crea el estado, el primer paquete que 
concuerda con ella crea un <b>estado</b> entre el remitente
y el destinatario.  A partir de ahí, los paquetes que vayan desde
el remitente hacia el destinatario no serán los únicos que
concuerden con la entrada de estado y que circunvalen la
evaluación de las reglas, sino que también lo harán
los paquetes de respuesta desde el destinatario hacia el remitente. 

<p>
Todas las reglas <i>pass</i> crean automáticamente una entrada en la 
tabla de estado cuando un paquete concuerda con la regla.
Esto puede deshabilitarse de manera explícita mediante la opción
<tt>no state</tt>

<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Esto permite el paso de cualquier tráfico TCP saliente en
la interfaz <tt>fxp0</tt>, y también permite que el
tráfico de respuesta pase de vuelta a través del
cortafuegos.  El mantenimiento del estado 
mejora de forma significativa el rendimiento del
cortafuegos, ya que las búsquedas de estados son mucho más
rápidas que la evaluación de un paquete a través de
todas las reglas de filtrado.

<p>
La opción de &laquo;modulación del estado&raquo;
(<tt>modulate state</tt>), funciona como <tt>keep state</tt>, con la
diferencia que solo es válida para paquetes TCP.  Con
<tt>modulate state</tt>, el ISN de las conexiones salientes es
aleatorio.  Esta opción es útil para proteger conexiones
que hayan sido iniciadas por ciertos sistemas operativos que realizan un
pobre trabajo al escoger ISNs.
Para simplificar las reglas, la opción <tt>modulate state</tt> 
puede usarse en reglas que especifican protocolos 
diferentes de TCP; en estos casos es tratada como <tt>keep state</tt>.

<p>
Mantenimiento del estado en paquetes TCP, UDP e ICMP salientes y ISN TCP
modulados:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Otra ventaja del mantenimiento del estado es que el tráfico ICMP
correspondiente también pasará por el cortafuegos.  Por
ejemplo, si una conexión TCP pasa a través del cortafuegos,
como se mantiene el estado, y llega una señal de congestión 
(<i>source quench</i>) ICMP, se buscará su concordancia con la entrada 
apropiada de la tabla de estado y pasará a través del cortafuegos.

<p>
El ámbito de una entrada en la tabla de estados es controlado 
globalmente por la opción en tiempo de ejecución 
<a href="options.html#state-policy"><tt>state-policy</tt></a>
y al nivel de cada regla por las palabras-clave de opciones de estado 
<tt>if-bound</tt> y <tt>floating</tt>.  Estas palabras-clave usadas 
en las reglas tienen el mismo efecto que cuando se usan con la opción 
<tt>state-policy</tt>.  Ejemplo:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Esta regla dictaminaría que para que los paquetes concuerden con la 
entrada de estado deben transitar por la interfaz <tt>fxp0</tt>.

<a name="udpstate"></a>
<h2>Mantenimiento del estado para UDP</h2>
<p>
Algunos dicen que &laquo;no se puede crear estado con UDP, ya que UDP es
un protocolo sin estado&raquo;.  Aunque es cierto que una sesión
de comunicación de UDP no tiene ningún concepto de estado
(un comienzo y un final de las comunicaciones explícito), esto no
tiene ningún impacto en la capacidad de PF para crear estado para
una sesión de UDP.  En el caso de protocolos sin paquetes de
&laquo;inicio&raquo; ni &laquo;final&raquo;, PF se limita a mantener un
seguimiento del tiempo transcurrido desde que ha pasado un paquete que
concuerde.  Los valores del tiempo agotado (<i>timeout</i>) se pueden
configurar en la sección de <a href="options.html">opciones</a>
del fichero <tt>pf.conf</tt>.

<a name="stateopts"></a>
<h2>Opciones de seguimiento de estado</h2>
Las reglas de filtrado que crean una entrada en la tabla de estados 
pueden especificar varias opciones para controlar el comportamiento 
de la entrada de estado resultante. 
Están disponibles las siguientes opciones:

<dl>
<dt><tt>max <i>número</i></tt>
<dd>Limita el número máximo de entradas de estado que la regla
puede crear para <i>número</i>.
Si se alcanza el máximo, los paquetes que normalmente crearían 
un estado son rechazados hasta que el número de estados existentes 
decrece por debajo del límite.

<dt><tt>no state</tt>
<dd>Impide que la regla cree automáticamente una entrada en la tabla
de estados.

<dt><tt>source-track</tt>
<dd>Esta opción habilita el seguimiento del número de estados creados
por dirección IP de origen.
Esta opción tiene dos formatos:
	<ul>
	<li><tt>source-track rule</tt> - El número máximo de estados 
	creados por esta regla está limitado por las opciones
	<tt>max-src-nodes</tt> y <tt>max-src-states</tt> de la regla.
	Solamente las entradas de estado creadas por esta regla en 
	particular cuenta para los límites de la regla.
	<li><tt>source-track global</tt> - El número de estados creados
	por todas las reglas que usan esta opción se limita. Cada regla
	puede especificar diferentes opciones <tt>max-src-nodes</tt> y 
	<tt>max-src-states</tt>, sin embargo las entradas de estado creadas
	por cualquier regla participante cuenta para los límites individuales 
	de la regla.
	</ul>
El número total de direcciones IP de origen rastreados globalmente puede
controlarse por medio de la 
<a href="options.html#limit">opción en tiempo de ejecución 
<a href="options.html#limit"><tt>src-nodes</tt></a>.

<dt><tt>max-src-nodes <i>número</i></tt>
<dd>Cuando se usa la opción <tt>source-track</tt>,
<tt>max-src-nodes</tt> limitará el número de direcciones IP de origen
que pueden crear estado de forma simultánea.
Esta opción solo puede usarse con <tt>source-track rule</tt>.

<dt><tt>max-src-states <i>número</i></tt>
<dd>Cuando se usa la opción <tt>source-track</tt>,
<tt>max-src-states</tt> limitará el número de entradas de estado
simultáneas que pueden crearse por dirección IP de origen.
El alcance de este límite (o sea, estados creados solamente por esta
regla o estados creados por todas las reglas que usan 
<tt>source-track</tt>) es dependiente de la opción <tt>source-track</tt> 
especificada.
</dl>

<p>
Las opciones se especifican entre paréntesis e inmediatamente 
después de una de las palabras-clave de estado (<tt>keep state</tt>,
<tt>modulate state</tt>, or <tt>synproxy state</tt>). Si hay múltiples 
opciones, deben ir separadas por comas. 
En OpenBSD 4.1 y versiones más recientes, la opción <tt>keep state</tt> 
se utiliza de forma predeterminada implícitamente para 
todas las reglas de filtrado. A pesar de ello, cuando se especifican 
opciones de mantener estado, debe especificarse todavía una de las 
palabras-clave por delante de las opciones.

<p>
Una regla de ejemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
La regla anterior define el siguiente comportamiento:

<ul>
<li>Limita a 200 el número máximo de estados que esta regla puede crear 
<li>Habilita el seguimiento del origen; limita la creación de estados basados
en estados creados solo por esta regla
<li>Limita a 100 el número máximo de nodos que pueden crear estados 
simultáneamente 
<li>Limita a 3 el número máximo de estados simultáneos por IP de origen. 
</ul>

<p>
Puede ponerse un conjunto separado de restricciones en conexiones 
TCP con estado que han completado la negociación en tres pasos 
(<i>3-way handshake</i>).

<dl>
<dt><tt>max-src-conn <i>número</i></tt>
<dd>Limita el número máximo de conexiones TCP simultáneas que
hayan completado la negociación en tres pasos y que una única máquina 
puede realizar.
<dt><tt>max-src-conn-rate <i>número</i> / <i>intervalo</i></tt>
<dd>Limita la tasa de nuevas conexiones a una cierta cantidad
por intervalo de tiempo 
</dl>

<p>
Ambas opciones invocan automáticamente la opción 
<tt>source-track rule</tt> y son incompatibles con 
<tt>source-track global</tt>

<p>
Dado que estos límites solo son colocados en conexiones 
TCP que han completado la negociación en tres pasos, se pueden adoptar
acciones más agresivas en direcciones IP ofensivas. 

<dl>
<dt><tt>overload &lt;<i>tabla</i>&gt;</tt>
<dd>Coloca una dirección IP de una máquina ofensiva en la tabla
nombrada.
<dt><tt>flush [global]</tt>
<dd>
Cesa cualquier otro estado que concuerde con esta regla y que
fuese creado por esta IP de origen.
Cuando <tt>global</tt> es especificado, cesa todos los estados
coincidentes con esta IP de origen, sin discernir qué regla
creó el estado.
</dl>

<p>
Un ejemplo:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Esto hace lo siguiente:

<ul>
<li>Limita a 100 el número máximo de conexiones por origen 
<li>Limita la tasa del número de conexiones a 15 en un lapso de 5 segundos
<li>Pone la dirección IP de cualquier máquina que quiebre estos límites en 
la tabla <tt>&lt;abusive_hosts&gt;</tt> 
<li>Para cualquier dirección IP ofensiva, suprime los estados creados 
por esta regla.
</ul>

<a name="tcpflags"></a>
<h2>Indicadores de TCP</h2>
<p>
La concordancia de paquetes TCP basada en indicadores es algo que se
suele usar para filtrar paquetes TCP que estén intentando abrir
una nueva conexión.  Aquí se puede ver una lista de
indicadores TCP y sus significados:
<ul>
<li><b>F</b> : FIN  - <i>Finish</i>; final de la sesión
<li><b>S</b> : SYN  - <i>Synchronize</i>; indica una petición para
iniciar la sesión
<li><b>R</b> : RST  - <i>Reset</i>; abandona una conexión
<li><b>P</b> : PUSH - <i>Push</i>; el paquete es enviado inmediatamente
<li><b>A</b> : ACK  - <i>Acknowledgement</i> (&laquo;acuse de recibo&raquo;)
<li><b>U</b> : URG  - <i>Urgent</i> (&laquo;urgente&raquo;)
<li><b>E</b> : ECE  - <i>Explicit Congestion Notification Echo</i> (&laquo;mensaje de congestión explícita&raquo;)
<li><b>W</b> : CWR  - <i>Congestion Window Reduced</i> (&laquo;ventana de congestión reducida&raquo;)
</ul>

<p>
Para que PF inspeccione los indicadores TCP durante la evaluación
de una regla se usa la clave <tt>flags</tt> con la sintaxis siguiente:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
La parte <tt><i>mask</i></tt> indica a PF que sólo inspeccione
los indicadores especificados, y la parte <tt><i>check</i></tt>
especifica qué indicadores deben estar activos ("on")
en la cabecera para que ocurra una concordancia.
EL uso de la palabra-clave <tt>any</tt> permite que cualquier
combinación de indicadores (<i>flags</i>) sea definido en la cabecera.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
pass in on fxp0 proto tcp from any to any port ssh
</tt>
</blockquote>

<p>
Como los <tt>indicadores S/SA</tt> se definen de forma prederminada,
las reglas anteriores son equivalentes. Cada una de estas reglas 
permite el paso de tráfico TCP con el indicador SYN activo, 
y sólo mira a los indicadores SYN y ACK.  
Un paquete con los indicadores SYN y ECE concordaría con la regla 
anterior, mientras que un paquete con SYN y ACK, o sólo con ACK, no
concordaría.

<p>
Los indicadores predeterminados pueden sobreescribirse
mediante la opción <tt>flags</tt> tal como se ha descrito
anteriormente.

<p>
Hay que tener cuidado con el uso de indicadores;  hay que entender
qué es lo que se está haciendo y por qué, y tener
cuidado con los consejos recibidos de otros ya que muchos suelen ser
erróneos.  Algunas personas han sugerido la creación de
estado &laquo;solo si está activado el indicador SYN, y no
otros&raquo;.  Una regla de este tipo terminaría así
<pre>
     . . . flags S/FSRPAUEW  <i>mala idea!!</i>
</pre>

<p>
La teoría es crear estado solo en el inicio de la
sesión TCP, y la sesión debería iniciarse con un
indicador SYN, y ningún otro.  El problema es que algunos sitios
están empezando a usar el indicador ECN, y cualquier sitio que
use ECN e intentara conectar con nosotros sería rechazado por una
regla de ese tipo.  Un enfoque mucho mejor sería no especificar
indicador alguno y dejar a PF que aplique los indicadores
predeterminados a las reglas de usted.
Si realmente necesita usted especificar indicadores, 
entonces esta combinación debería ser segura: 
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
<!--XXX scrub changes may have invalidated this-->
Aunque esto es práctico y seguro, también es necesario
comprobar los indicadores FIN y RST si se está normalizando 
(<i>scrub</i>) el tráfico.  El proceso de normalización de paquetes
hará que PF descarte cualquier paquete entrante que lleve una
combinación ilegal del indicador TCP (como SYN y
RST) y normalice combinaciones potencialmente 
ambiguas (como SYN y FIN).


<a name="synproxy"></a>
<h2>Proxy de paquetes TCP SYN</h2>
<p>
Normalmente, cuando un cliente inicia una conexión TCP a un
servidor, PF pasa los paquetes del saludo inicial
(<i><a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"> 
handshake</a></i>) entre los dos extremos según llegan.
Sin embargo, PF también puede hacer de proxy para el saludo
inicial.  Con el modo proxy, PF completará el saludo inicial con
el cliente, iniciará un saludo inicial con el servidor, y
pasará los paquetes entre los dos.  La ventaja de este proceso es
que no se enviará ningún paquete al servidor antes de que
el cliente complete el saludo inicial.  Esto elimina la amenaza de que
desbordamientos TCP SYN falseados puedan afectar al servidor, debido a
que una conexión de un cliente falseado no podrá completar
el saludo inicial.

<p>
El proxy TCP SYN se activa usando la clave <tt>synproxy state</tt> en
las reglas de filtrado.  Ejemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server port www synproxy state
</tt>
</blockquote>

<p>
En este ejemplo, PF hará de proxy TCP para las conexiones del
servidor web.

<p>
Debido al modo en que funciona <tt>synproxy state</tt>, también
incluye la misma funcionalidad que <tt>keep state</tt> y <tt>modulate
state</tt>.

<p>
El proxy SYN no funcionará si PF está funcionando sobre un
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>.

<a name="antispoof"></a>
<h2>Bloqueo de paquetes falsificados</h2>
<p>
La falsificación de direcciones (<i>spoofing</i>) es cuando un
usuario con malas intenciones falsifica la dirección IP de origen
en los paquetes que se transmiten, con el objetivo de esconder su
dirección real o de suplantar otro nodo en la red.  Una vez que
el usuario ha falsificado su dirección, puede lanzar un ataque a
nivel de red sin revelar la dirección real de origen del ataque,
o intentar obtener acceso a servicios de la red que estén
restringidos para ciertas direcciones IP.

<p>
PF ofrece cierto nivel de protección contra la
falsificación de direcciones mediante la clave
<tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Indica que los paquetes que concuerden se deben registrar en un
fichero a través de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.8"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Si un paquete concuerda con esta regla, entonces se
considerará que es la regla &laquo;ganadora&raquo; y
finalizará la evaluación del grupo de reglas.

<dt><tt><i>interface</i></tt>
<dd>La interfaz de red en la que se va a activar la protección
contra las falsificaciones.  También puede ser una
<a href="macros.html#lists">lista</a> de interfaces.

<dt><tt><i>af</i></tt>
<dd>La familia de direcciones para la que se va a activar la
protección contra las falsificaciones, y que puede ser
<tt>inet</tt> para IPv4 ó <tt>inet6</tt> para IPv6.
</dl>

<p>
Ejemplo:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Cuando se carga un grupo de reglas, cualquier suceso de la clave
<tt>antispoof</tt> se expandirá en dos reglas de filtrado.
Asumiendo que la interfaz <tt>fxp0</tt> tuviera una dirección IP
10.0.0.1 y una máscara de subred de 255.255.255.0 (o sea, un
/24), la regla <tt>antispoof</tt> anterior se expandiría
así:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Estas reglas realizan dos funciones:

<ul>
<li>Bloquean todo el tráfico que viene desde la red 10.0.0.0/24
que <i>no</i> pase a través de <tt>fxp0</tt>.  Como la red
10.0.0.0/24 está en la interfaz <tt>fxp0</tt>, los paquetes que
tengan una dirección de origen en ese bloque de red nunca
entrarán por ninguna otra interfaz.
<li>Bloquean todo el tráfico entrante desde 10.0.0.1, la
dirección IP en <tt>fxp0</tt>.  La máquina anfitriona no
debería enviar nunca paquetes a sí misma a través
de una interfaz externa;  por lo tanto, se puede considerar que
cualquier paquete entrante con una dirección de origen que
pertenezca a la máquina es malicioso.
</ul>

<p>
<b>NOTA</b>:  Las reglas de filtrado resultantes de la expansión
de la regla <tt>antispoof</tt> también bloquearán los
paquetes que se envíen por la interfaz de <i>loopback</i> hacia
direcciones locales.  
Es recomendable desactivar el filtrado en las interfaces 
de <i>loopback</i>, pero esto se convierte en necesidad 
cuando se utilizan reglas contra falsificaciones:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
El uso de <tt>antispoof</tt> se debe restringir a las interfaces a las
que se les haya asignado una dirección IP.  El uso de
<tt>antispoof</tt> en una interfaz sin una dirección IP
resultará en reglas de filtrado como:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Con estas reglas existe el riesgo de bloquear <i>todo</i> el
tráfico entrante en <i>todas</i> las interfaces.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
PF ofrece la funcionalidad <i>Unicast Reverse Path Forwarding</i> (uRPF). 
Cuando un paquete se somete a la comprobación uRPF, 
se busca la dirección IP de origen del paquete en la tabla de 
enrutamiento. 
Si la interfaz de salida hallada en la la tabla de enrutamiento 
es la misma por la que el paquete acaba de entrar, 
entonces la comprobación uRPF permite el paso del paquete. 
Si las interfaces no coinciden, entonces es posible que el paquete 
tenga su dirección de origen falsificada.

<p>
La comprobación uRPF puede realizarse en los paquetes utilizando
la palabra-clave <tt>urpf-failed</tt> en las reglas de filtrado:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Nótese que la comprobación uRPF solo tiene sentido en un entorno
donde el enrutado es simétrico.

<p>
uRPF proporciona la misma funcionalidad que las reglas
<a href="#antispoof">antifalsificación</a>

<a name="osfp"></a>
<h2>Detección pasiva del Sistema Operativo</h2>

<p>
La identificación pasiva del sistema operativo (<i>OS Fingerprinting</i> 
u OSFP por sus siglas en inglés) es un método para detectar pasivamente 
el sistema operativo de una máquina remota basado en ciertas características 
contenidas en sus paquetes SYN TCP.
Esta información puede usarse después como criterio en las reglas de filtrado.

<p>
PF determina el sistema operativo remoto comparando las características de un
paquete SYN TCP con el
<a href="options.html#fingerprints">archivo de huellas digitales</a> (<i>fingerprints</i>),
que por omisión es
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.8"
><tt>/etc/pf.os</tt></a>. 
Una vez que PF está habilitado, la lista actual de huellas digitales 
puede verse con la siguiente instrucción:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Dentro de una regla de filtrado, una huella digital puede especificarse
mediante una clase de sistema operativo, versión o nivel de subtipo/parche.
Cada uno de estos elementos se lista en la salida de la instrucción
<tt>pfctl</tt> de arriba. Para especificar una huella digital en una regla
de filtrado se usa la palabra clave <tt>os</tt>:

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
La clase especial de sistema operativo <tt>unknown</tt> hace que los paquetes
concuerden con la regla si las huellas digitales del sistema operativo son
desconocidas.

<p>
<font color="#ff0000">TOME NOTA</font> de lo siguiente:
<ul>
   <li>Las huellas digitales de los sistemas operativos de vez en cuando
   son incorrectas debido a paquetes falsificados y/o fabricados que
   son hechos para parecer como si provinieran de un sistema operativo
   específico.
   <li>Ciertas revisiones o niveles de parcheo de un sistema operativo
   pueden cambiar el comportamiento de la pila y hacer que ya no concuerde
   con el archivo de huellas digitales o que concuerde con algún otro
   sistema operativo. 
   <li>El OSFP sólo funciona con los paquetes SYN TCP; no funcionará con
   otro protocolos o con conexiones ya establecidas.
</ul>

<a name="ipopts"></a>
<h2>Opciones de IP</h2>
<p>
Por definición, PF bloquea los paquetes con las opciones IP
activadas.  Esto puede hacer las cosas más difíciles para
utilidades de detección de sistemas operativos (<i>OS
fingerprinting</i>) como nmap.  Si se tiene una aplicación que
requiere el paso de estos paquetes, como multidifusión o IGMP, se
puede usar la directiva <tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Ejemplo de reglas de filtrado</h2>
<p>
A continuación tenemos un ejemplo de un grupo de reglas de
filtrado.  La máquina en la que está funcionando PF
actúa como cortafuegos entre una red interna pequeña e
Internet.  Sólo se muestran las reglas de filtrado;  las reglas
de <a href="queueing.html">queueing</a>,
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>,
etc.. se han omitido en este ejemplo.
<br>
<br>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# tabla que contiene todas las direcciones IP asignadas al cortafuegos
table &lt;firewall&gt; const { self }

# no filtrar en el interfaz loopback
set skip on lo0

# normalizar los paquetes entrantes
match in all scrub (no-df)

# configurar una política de denegación predeterminada
block all

# activar la protección contra la falsificación de direcciones
# para todas las interfaces
block in quick from urpf-failed

# permitir sólo conexiones por ssh si provienen
# desde la máquina de confianza, 192.168.0.15;
# usar "block return" para que se envíe un TCP RST
# para cerrar inmediatamente las conexiones bloqueadas;
# usar "quick" para que las reglas "pass" que
# vienen a continuación no anulen esta regla.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# permitir el paso del tráfico hacia y desde la red local
# estas reglas crearán entradas de estado debido a la opción
# por omisión "keep state" que se aplica automáticamente
pass in  on $int_if from $lan_net
pass out on $int_if to $lan_net

# permitir el paso de paquetes tcp, udp e icmp
# salientes en la interfaz externa (Internet);
# modular el estado en conexiones tcp y mantener el estado en udp/icmp.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# permitir el paso de las conexiones entrantes de ssh
# en la interfaz externa siempre que su destino NO sea
# el cortafuegos (o sea, aquellas cuyo destino sea
# una máquina en la red local);  registrar el paquete inicial
# para que podamos ver más tarde quién intenta conectar.
# Usar el proxy tcp syn para la conexión.
# PF aplicará automáticamente los indicadores por omisión "S/SA" 
# a la regla.
pass in log on $ext_if proto tcp to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Anterior: Tablas</a>]
[<a href="index.html">Contenido</a>]
[<a href="nat.html">Siguiente: Traducción de Direcciones de
Red</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.55 ]<br>
$Translation: filter.html,v 1.15 2011/03/12 23:17:40 mvidal Exp $<br>
-->
$OpenBSD: filter.html,v 1.14 2011/03/13 07:16:15 ajacoutot Exp $
</small>

</body>
</html>
@


1.14
log
@Sync with Steelix CVS
@
text
@d1151 1
a1151 1
$OpenBSD$
@


1.13
log
@Sync with Steelix CVS
@
text
@d4 1
a4 1
<title>PF: Filtrado de Paquetes</title>
a6 1
<meta http-equiv="Content-Language" content="es">
d8 2
a9 2
<meta name="description"   content="Preguntas Frecuentes de OpenBSD">
<meta name="keywords"      content="openbsd,preguntas frecuentes,faq,pf">
d14 1
a14 1
Copyright (c) 2003, 2004 Joel Knight <enabled@@myrealbox.com>
d34 3
a36 1
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif">
d40 1
a40 1
[<a href="nat.html">Siguiente: Traducci&oacute;n de Direcciones de
d43 1
a43 1
<h1><font color="#e00000">PF: Filtrado de Paquetes</font></h1>
d47 1
a47 1
<h3>&Iacute;ndice de Contenidos</h3>
d49 8
a56 7
<li><a href="#intro">Introducci&oacute;n</a>
<li><a href="#syntax">Sintaxis de las Reglas</a>
<li><a href="#defdeny">Denegaci&oacute;n Predeterminada</a>
<li><a href="#pass">Paso de Tr&aacute;fico</a>
<li><a href="#quick">La Clave <tt>quick</tt></a>
<li><a href="#state">Mantenimiento del Estado</a>
<li><a href="#udpstate">Mantenimiento del Estado para UDP</a>
d58 4
a61 3
<li><a href="#synproxy">Proxy TCP SYN</a>
<li><a href="#antispoof">Bloqueo de Paquetes Falsificados</a>
<li><a href="#osfp">Identificación Pasiva del Sistema Operativo</a>
d63 1
a63 1
<li><a href="#example">Ejemplo de Grupo de Reglas de Filtrado</a>
d69 1
a69 1
<h2>Introducci&oacute;n</h2>
d71 2
a72 2
La acci&oacute;n de filtrar paquetes es bloquear o permitir el paso a
los paquetes de datos de forma selectiva, seg&uacute;n van llegando a
d74 3
a76 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.5">pf(4)</a>
para inspeccionar los paquetes los toma de la informaci&oacute;n
d78 4
a81 2
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.5">IPv4</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.5">IPv6</a>)
d83 9
a91 6
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.5">TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.5">UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.5">ICMP</a>, y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.5">ICMPv6</a>)
de las cabeceras de los paquetes.  Los criterios que m&aacute;s se
utilizan son los de la direcci&oacute;n de origen y de destino, el
d96 1
a96 1
concordar un paquete y la acci&oacute;n a seguir, bien sea bloquearlo o
d98 10
a107 10
Las reglas de filtrado se eval&uacute;an por orden de secuencia, de la
primera a la &uacute;ltima.  A menos que el paquete concuerde con una
regla que contenga la clave <tt>quick</tt>, se evaluar&aacute; el
paquete compar&aacute;ndolo con <i>todas</i> las reglas de filtrado
antes de decidir una acci&oacute;n final.  La &uacute;ltima regla que
concuerde ser&aacute; la &laquo;ganadora&raquo; y la que dictamine
qu&eacute; acci&oacute;n se tomar&aacute; con el paquete.  Al principio del
grupo de reglas de filtrado hay un <tt>pass all</tt> impl&iacute;cito
que indica que si alg&uacute;n paquete no concuerda con ninguna de las
reglas de filtrado, la acci&oacute;n a seguir ser&aacute; <tt>pass</tt>,
d111 1
a111 1
<h2>Sintaxis de las Reglas</h2>
d117 5
a121 5
<i>action</i> <i>direction</i> [log] [quick] on <i>interfaz</i> [<i>af</i>] 
[proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;from <i>src_addr</i> [port <i>src_port</i>] to 
<i>dst_addr</i> [port <i>dst_port</i>] \<br>
&nbsp;&nbsp;&nbsp;[<i>tcp_flags</i>] [<i>state</i>]
d127 6
a132 6
<dd>La acci&oacute;n a seguir para los paquetes que concuerden, ya sea
<tt>pass</tt> o <tt>block</tt>.  La acci&oacute;n <tt>pass</tt>
permitir&aacute; el paso al paquete de vuelta hasta el n&uacute;cleo del
sistema, para que &eacute;ste lo procese, mientras que la acci&oacute;n
<tt>block</tt> actuar&aacute; seg&uacute;n se indique en la
configuraci&oacute;n de la opci&oacute;n de la pol&iacute;tica de
d134 1
a134 1
La acci&oacute;n predeterminada se puede anular especificando <tt>block
d139 2
a140 2
<dd>La direcci&oacute;n en la que se mueve el paquete en una interfaz,
que ser&aacute; <tt>in</tt> (entrante) o <tt>out</tt> (saliente).
d144 6
a149 6
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.5">pflogd(8)</a>.
Si la regla especifica la opci&oacute;n <tt>keep state</tt>,
<tt>modulate state</tt>, o <tt>synproxy state</tt> entonces s&oacute;lo
se registrar&aacute; el paquete que establezca el estado.  Para
registrar todos los paquetes hay que usar la opci&oacute;n
<tt>log-all</tt>.
d153 4
a156 4
opci&oacute;n <tt>quick</tt>, entonces esa regla se considera como la
regla final de concordancia para el paquete, y se tomar&aacute; la
acci&oacute;n que est&eacute; especificada en <tt><i>action</i></tt>
sin m&aacute;s dilaci&oacute;n.
d158 1
a158 1
<dt><tt><i>interfaz</i></tt>
d161 14
a174 5
Un grupo de interfaces se especifica con el nombre de la interfaz pero sin
el número entero añadido.
Por ejemplo: <tt>ppp</tt> o <tt>fxp</tt>.
Esto hará que cualquier paquete que atraviese cualquier interfaz <tt>ppp</tt>
o <tt>fxp</tt> respectivamente, concuerde con esta regla.
d177 4
a180 4
<dd>La familia de direcciones del paquete, que ser&aacute; <tt>inet</tt>
para IPv4 &oacute; <tt>inet6</tt> para IPv6.  Generalmente, PF es capaz
de determinar este par&aacute;metro bas&aacute;ndose en la
direcci&oacute;n, o direcciones, de origen y/o de destino.
d189 4
a192 3
<li>Un nombre de protocolo v&aacute;lido del fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.5"><tt>/etc/protocols</tt></a>
<li>Un n&uacute;mero de protocolo entre 0 y 255
d198 1
a198 1
<dd>La direcci&oacute;n de origen y/o de destino en la cabecera IP.  Las
d201 1
a201 1
<li>Una sola direcci&oacute;n IPv4 &oacute; IPv6.
d205 1
a205 1
se resolver&aacute; por el &laquo;Servicio de Nombres de Dominio&raquo;
d207 4
a210 4
sustituir&aacute;n dentro de la regla.
<li>El nombre de una interfaz de red.  Cualquier direcci&oacute;n IP
asignada a la interfaz se sustituir&aacute; dentro de la regla.
<li>El nombre de una interfaz de red seguido de la m&aacute;scara de red
d212 1
a212 1
direcci&oacute;n IP en la interfaz se combina con la m&aacute;scara de
d215 7
a221 8
<li>El nombre de una interfaz de red entre par&eacute;ntesis.  De este
modo se instruye a PF para que actualice la reglas si la
direcci&oacute;n, o direcciones, IP en dicha interfaz cambia.  Es de
gran utilidad cuando la interfaz obtiene su direcci&oacute;n IP por
medio de DHCP o de una conexi&oacute;n tipo <i>dial-up</i> (por
conexi&oacute;n telef&oacute;nica), ya que no hay que volver a cargar
las reglas cada vez que cambie la direcci&oacute;n.

a239 2


d241 5
a245 2
<li>Cualquiera de las anteriores en negaci&oacute;n, usando el
modificador <tt>!</tt> (&quot;not&quot;).
d249 1
a249 1
<li>La clave <tt>all</tt>, que es una abreviaci&oacute;n de
d257 4
a260 3
<li>Un n&uacute;mero entre el 1 y el 65535
<li>Un nombre de servicio v&aacute;lido del fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.5"><tt>/etc/services</tt></a>
d263 1
a263 1
<li>Un indicador de campo:
d265 1
a265 1
	<li><tt>!=</tt> (no es igual que)
d273 2
a274 2
	<dd>Los dos &uacute;ltimos son operadores binarios (toman dos
	argumentos) y no incluyen los argumentos en el campo.
d288 1
a288 1
S/SA</tt> instruye a PF para que s&oacute;lo mire los indicadores S y A
d290 4
a293 1
est&aacute; activo (&quot;on&quot;).
d296 1
a296 1
<dd>Especifica si se guarda la informaci&oacute;n sobre el estado en
d299 8
a306 4
<li><tt>keep state</tt> - funciona con TCP, UDP y ICMP.
<li><tt>modulate state</tt> - s&oacute;lo funciona con TCP.  PF
generar&aacute; &laquo;N&uacute;meros de Secuencia Inicial&raquo; (ISNs,
<i>Initial Sequence Numbers</i>) consistentes para los paquetes que
d310 1
a310 1
desbordamientos TCP SYN falsificados.  Esta opci&oacute;n incluye las
d316 1
a316 1
<h2>Denegaci&oacute;n Predeterminada</h2>
d318 2
a319 2
La pr&aacute;ctica recomendada para configurar un cortafuegos es la de
tomar una aproximaci&oacute;n de &laquo;denegaci&oacute;n
d321 5
a325 5
de ah&iacute; ir permitiendo el paso a trav&eacute;s del cortafuegos de
forma selectiva a cierto tr&aacute;fico.  Esta aproximaci&oacute;n es la
recomendada ya que los posibles fallos se cometer&iacute;an a favor de
la seguridad, y tambi&eacute;n por que hace m&aacute;s f&aacute;cil la
creaci&oacute;n de grupos de reglas.
d328 1
a328 1
Para crear una pol&iacute;tica de filtrado de denegaci&oacute;n
d338 2
a339 2
Con esto se bloquea todo el tr&aacute;fico en todas las interfaces en
cualquier direcci&oacute;n, y desde cualquier origen, hasta cualquier
d343 1
a343 1
<h2>Paso de Tr&aacute;fico</h2>
d345 5
a349 5
Ahora hay que permitir de forma expl&iacute;cita y selectiva el paso del
tr&aacute;fico a trav&eacute;s del cortafuegos, o de lo contrario
ser&aacute; bloqueado por la pol&iacute;tica de denegaci&oacute;n
predeterminada.  Aqu&iacute; es donde entran en juego los criterios del
paquete, como son el puerto de origen/destino, la direcci&oacute;n de
d351 1
a351 1
cierto tr&aacute;fico a trav&eacute;s del cortafuegos hay que escribir
d353 2
a354 2
asegurarse de que s&oacute;lo pasar&aacute; el tr&aacute;fico que se
permita, y ning&uacute;n otro.
d360 3
a362 3
# Permitir el paso al tr&aacute;fico entrante en la interfaz dc0 de la red local,<br>
# 192.168.0.0/24, hacia la direcci&oacute;n IP 192.168.0.1 de la m&aacute;quina de OpenBSD.<br>
# Tambi&eacute;n permitir el paso al tr&aacute;fico saliente que es enviado de vuelta en dc0.<br>
d367 4
a370 4
# Permitir el paso al tr&aacute;fico entrante TCP en la interfaz fxp0 del servidor<br>
# de <i>web</i> que se encuentra en la m&aacute;quina de OpenBSD.  El nombre de la<br>
# interfaz, fxp0, se usa como la direcci&oacute;n de destino para que los paquetes<br>
# s&oacute;lo concuerden con esta regla si tienen como destino la m&aacute;quina de OpenBSD.<br>
d376 1
a376 1
<h2>La Clave <tt>quick</tt></h2>
d378 2
a379 2
Como se ha indicado anteriormente, cada paquete se eval&uacute;a con el
grupo de reglas de filtrado, desde la primera hasta la &uacute;ltima.
d382 4
a385 4
las que pasa, y podr&iacute;a cambiar varias veces antes de llegar al
final de las reglas de filtrado.  <b>La &uacute;ltima regla con la que
concuerde marcar&aacute; el resultado.</b>  Existe una excepci&oacute;n
para esto:  la opci&oacute;n <tt>quick</tt> en una regla de filtrado
d387 2
a388 2
consiguiente, y provoca que se ejecute la acci&oacute;n especificada sin
m&aacute;s dilaci&oacute;n.  Veamos un par de ejemplos:
d394 1
a394 1
block in on fxp0 proto tcp from any to any port ssh<br>
d400 3
a402 3
En este caso, la l&iacute;nea <tt>block</tt> puede ser evaluada, pero
nunca tendr&aacute; ning&uacute;n efecto, ya que va seguida por una
l&iacute;nea que permite el paso de todo.
d408 1
a408 1
block in quick on fxp0 proto tcp from any to any port ssh<br>
d414 4
a417 4
Estas reglas se eval&uacute;an de una forma algo diferente.  Si un
paquete concuerda con la l&iacute;nea <tt>block</tt>, debido a la
naturaleza de la opci&oacute;n <tt>quick</tt>, se bloquear&aacute; el
paso a dicho paquete y se ignorar&aacute; el resto del grupo de reglas.
d420 1
a420 1
<h2>Mantenimiento del Estado</h2>
d424 2
a425 2
&laquo;inspecci&oacute;n completa del estado&raquo; (<i>stateful
inspection</i>).  La inspecci&oacute;n del estado se refiere a la
d427 6
a432 6
una conexi&oacute;n de red.  Almacenando informaci&oacute;n sobre cada
conexi&oacute;n en una tabla de estado, PF puede determinar
r&aacute;pidamente si un paquete que est&aacute; pasando a trav&eacute;s
del cortafuegos pertenece a una conexi&oacute;n ya establecida.  Si es
as&iacute;, se le permite pasar a trav&eacute;s del cortafuegos sin
tener que pasar a trav&eacute;s de la evaluaci&oacute;n del grupo de
d437 3
a439 3
grupos de reglas son m&aacute;s simples y se obtiene un rendimiento
m&aacute;s alto del filtrado de paquetes.  PF puede puede hacer que los
paquetes que vayan en <i>cualquier</i> direcci&oacute;n concuerden con
d441 1
a441 1
escribir reglas de filtrado que permitan el paso del tr&aacute;fico de
d443 1
a443 1
<i>stateful</i> no pasan a trav&eacute;s de la evaluaci&oacute;n del
d448 4
a451 4
Cuando una regla tiene la opci&oacute;n <tt>keep state</tt>, el primer
paquete que concuerda con ella crea un <b>estado</b> entre el remitente
y el destinatario.  A partir de ah&iacute;, los paquetes que vayan desde
el remitente hacia el destinatario no ser&aacute;n los &uacute;nicos que
d453 9
a461 3
evaluaci&oacute;n de las reglas, sino que tambi&eacute;n lo har&aacute;n
los paquetes de respuesta desde el destinatario hacia el remitente.  Por
ejemplo:
d464 1
a464 1
pass out on fxp0 proto tcp from any to any keep state
d469 7
a475 7
Esta regla permite el paso de cualquier tr&aacute;fico TCP saliente en
la interfaz <tt>fxp0</tt>, y tambi&eacute;n permite que el
tr&aacute;fico de respuesta pase de vuelta a trav&eacute;s del
cortafuegos.  El mantenimiento del estado es una funcionalidad muy
&uacute;til, y su uso mejora de forma significativa el rendimiento del
cortafuegos, ya que las b&uacute;squedas de estados son mucho m&aacute;s
r&aacute;pidas que la evaluaci&oacute;n de un paquete a trav&eacute;s de
d479 3
a481 3
La opci&oacute;n de &laquo;modulaci&oacute;n del estado&raquo;,
<tt>modulate state</tt>, funciona como <tt>keep state</tt>, con la
diferencia que s&oacute;lo es v&aacute;lida para paquetes TCP.  Con
d483 1
a483 1
aleatorio.  Esta opci&oacute;n es &uacute;til para proteger conexiones
d486 3
a488 2
A partir de OpenBSD 3.5, la opción <tt>modulate state</tt> puede usar usada
en aquellas reglas que especifican protocolos diferentes de TCP.
d491 1
a491 1
Mantenimiento del estado en paquetes TCP, UDP y ICMP salientes y ISN TCP
d501 15
a515 19
Otra ventaja del mantenimiento del estado es que el tr&aacute;fico ICMP
correspondiente pasar&aacute; a trav&eacute;s del cortafuegos.  Por
ejemplo, si se especifica <tt>keep state</tt> para una conexi&oacute;n
TCP y llega un mensaje ICMP de &laquo;requerimiento de
ralentizaci&oacute;n&raquo; (<i>source quench ICMP message</i>;  es un
mensaje de respuesta generado por una pasarela o por el anfitri&oacute;n
de destino, y avisando al anfitri&oacute;n de origen de la
conexi&oacute;n para que ralentice el env&iacute;o de datos) con
referencia a esta conexi&oacute;n TCP, se buscar&aacute; su concordancia
con la entrada apropiada de la tabla de estado y pasar&aacute; a
trav&eacute;s del cortafuegos.

<p>
El ámbito de un estado es controlado globalmente por la opción de tiempo
de ejecución <a href="options.html#state-policy"><tt>state-policy</tt></a>
y por cada regla con las claves de opciones de estado <tt>if-bound</tt>,
<tt>group-bound</tt> y <tt>floating</tt>.
Estas claves por regla tienen el mismo significado que cuando se usan
con la opción <tt>state-policy</tt>. Ejemplo:
d525 2
a526 9
Esta regla dictaminaría que para que los paquetes concuerden con el estado
deben transitar por la interfaz <tt>fxp0</tt>.

<p>
N&oacute;tese que las reglas de <a href="nat.html"><tt>nat</tt></a>, 
<a href="nat.html#binat"><tt>binat</tt></a>, y
<a href="rdr.html"><tt>rdr</tt></a> crean un estado impl&iacute;cito
para las conexiones que concuerden, siempre que la conexi&oacute;n pase
por el filtro del grupo de reglas.
d529 1
a529 1
<h2>Mantenimiento del Estado para UDP</h2>
d532 5
a536 5
un protocolo sin estado&raquo;.  Aunque es cierto que una sesi&oacute;n
de comunicaci&oacute;n de UDP no tiene ning&uacute;n concepto de estado
(un comienzo y un final de las comunicaciones expl&iacute;cito), esto no
tiene ning&uacute;n impacto en la capacidad de PF para crear estado para
una sesi&oacute;n de UDP.  En el caso de protocolos sin paquetes de
d540 1
a540 1
configurar en la secci&oacute;n de <a href="options.html">opciones</a>
d543 57
a599 2
<a name="tcpflags"></a>
<h2>Indicadores de TCP</h2>
d601 9
a609 15
La concordancia de paquetes TCP basada en indicadores es algo que se
suele usar para filtrar paquetes TCP que est&eacute;n intentando abrir
una nueva conexi&oacute;n.  Aqu&iacute; se puede ver una lista de
indicadores TCP y sus significados:
<ul>
<li><b>F</b> : FIN  - <i>Finish</i>; final de la sesi&oacute;n
<li><b>S</b> : SYN  - <i>Synchronize</i>; indica un requerimiento para
iniciar la sesi&oacute;n
<li><b>R</b> : RST  - <i>Reset</i>; abandonar una conexi&oacute;n
<li><b>P</b> : PUSH - <i>Push</i>; el paquete es  enviado inmediatamente
<li><b>A</b> : ACK  - <i>Acknowledgement</i>
<li><b>U</b> : URG  - <i>Urgent</i>
<li><b>E</b> : ECE  - <i>Explicit Congestion Notification Echo</i>
<li><b>W</b> : CWR  - <i>Congestion Window Reduced</i>
</ul>
d612 2
a613 2
Para que PF inspeccione los indicadores TCP durante la evaluaci&oacute;n
de una regla se usa la clave <tt>flags</tt> con la sintaxis siguiente:
d616 4
a619 1
flags <i>check</i>/<i>mask</i>
d624 52
a675 4
La parte <tt><i>mask</i></tt> indica a PF que s&oacute;lo inspeccione
los indicadores especificados, y la parte <tt><i>check</i></tt>
especifica qu&eacute; indicadores deben estar activos (&quot;on&quot;)
en la cabecera para que ocurra una concordancia.
d678 7
a684 1
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
d689 10
a698 5
Esta regla permite el paso de tr&aacute;fico TCP con el indicador SYN
activo, y s&oacute;lo mira a los indicadores SYN y ACK.  Un paquete con
los indicadores SYN y ECE concordar&iacute;a con la regla anterior,
mientras que un paquete con SYN y ACK, o s&oacute;lo con ACK, no
concordar&iacute;a.
d700 2
d703 19
a721 2
Nota:  la siguiente sintaxis ten&iacute;a soporte en versiones
anteriores de OpenBSD:
d724 2
a725 1
. . . flags S
d730 6
a735 6
Este soporte ya no existe.  Ahora hay que especificar <i>siempre</i> una
m&aacute;scara.

<p>
Los indicadores se suelen usar junto con reglas <tt>keep state</tt> para
ayudar a controlar la creaci&oacute;n de entradas de estado:
d738 2
a739 1
pass out on fxp0 proto tcp all flags S/SA keep state
d744 12
a755 3
Esto permitir&iacute;a la creaci&oacute;n de estado en cualquier paquete
TCP saliente, con el indicador SYN activado entre los indicadores SYN y
ACK.
d759 1
a759 1
qu&eacute; es lo que se est&aacute; haciendo y porqu&eacute;, y tener
d761 3
a763 3
err&oacute;neos.  Algunas personas han sugerido la creaci&oacute;n de
estado &laquo;s&oacute;lo si est&aacute; activado el indicador SYN, y no
otros&raquo;.  Una regla de este tipo terminar&iacute;a as&iacute;
d765 1
a765 1
     . . . flags S/FSRPAUEW  <i>&iexcl;&iexcl;mala idea!!</i>
d769 10
a778 6
La teor&iacute;a es crear estado s&oacute;lo en el inicio de la
sesi&oacute;n TCP, y la sesi&oacute;n deber&iacute;a iniciarse con un
indicador SYN, y ninguno otro.  El problema es que algunos sitios
est&aacute;n empezando a usar el indicador ECN, y cualquier sitio que
use ECN e intentara conectar con nosotros ser&iacute;a rechazado por una
regla de ese tipo.  Una directiva mucho mejor es:
d786 9
a794 18
Aunque esto es pr&aacute;ctico y seguro, tambi&eacute;n es necesario
comprobar los indicadores FIN y RST si se est&aacute; aplicando la
<a href="scrub.html">normalizaci&oacute;n de paquetes</a> (<i>scrub</i>)
sobre el tr&aacute;fico.  El proceso de normalizaci&oacute;n de paquetes
har&aacute; que PF bloquee cualquier paquete entrante que lleve una
combinaci&oacute;n ilegal del indicador TCP (como SYN y FIN o SYN y
RST).  Es muy recomendable que se normalice siempre el tr&aacute;fico
entrante:
<blockquote>
<tt>
scrub in on fxp0<br>
.<br>
.<br>
.<br>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state
</tt>
</blockquote>
d797 1
a797 1
<h2>Proxy TCP SYN</h2>
d799 1
a799 1
Normalmente, cuando un cliente inicia una conexi&oacute;n TCP a un
d801 7
a807 7
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/connections.html"
>(<i>handshake</i>)</a> entre los dos extremos seg&uacute;n llegan.
Sin embargo, PF tambi&eacute;n puede hacer de proxy para el saludo
inicial.  Con el modo proxy, PF completar&aacute; el saludo inicial con
el cliente, iniciar&aacute; un saludo inicial con el servidor, y
pasar&aacute; los paquetes entre los dos.  La ventaja de este proceso es
que no se enviar&aacute; ning&uacute;n paquete al servidor antes de que
d810 1
a810 1
que una conexi&oacute;n de un cliente falseado no podr&aacute; completar
d814 1
a814 1
La proxy TCP SYN se activa usando la clave <tt>synproxy state</tt> en
d819 1
a819 2
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
d824 2
a825 2
En este ejemplo, PF har&aacute; de proxy TCP para las conexiones del
servidor de web.
d828 1
a828 1
Debido al modo en que funciona <tt>synproxy state</tt>, tambi&eacute;n
d833 2
a834 2
La proxy SYN no funcionar&aacute; si PF est&aacute; funcionando sobre un
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.5"
d838 1
a838 1
<h2>Bloqueo de Paquetes Falsificados (<i>Spoofed Packets</i>)</h2>
d840 2
a841 2
La falsificaci&oacute;n de direcciones (<i>spoofing</i>) es cuando un
usuario con malas intenciones falsifica la direcci&oacute;n IP de origen
d843 4
a846 4
direcci&oacute;n real o de suplantar otro nodo en la red.  Una vez que
el usuario ha falsificado su direcci&oacute;n, puede lanzar un ataque a
nivel de red sin revelar la direcci&oacute;n real de origen del ataque,
o intentar obtener acceso a servicios de la red que est&eacute;n
d850 2
a851 2
PF ofrece cierto nivel de protecci&oacute;n contra la
falsificaci&oacute;n de direcciones mediante la clave
d863 3
a865 2
fichero a trav&eacute;s de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.5">pflogd(8)</a>.
d869 2
a870 2
considerar&aacute; que es la regla &laquo;ganadora&raquo;, y
finalizar&aacute; la evaluaci&oacute;n del grupo de reglas.
d873 2
a874 2
<dd>La interfaz de red en la que se va a activar la protecci&oacute;n
contra las falsificaciones.  Tambi&eacute;n puede ser una
d879 2
a880 2
protecci&oacute;n contra las falsificaciones, y que puede ser
<tt>inet</tt> para IPv4 &oacute; <tt>inet6</tt> para IPv6.
d893 5
a897 5
<tt>antispoof</tt> se expandir&aacute; en dos reglas de filtrado.
Asumiendo que la interfaz <tt>fxp0</tt> tuviera una direcci&oacute;n IP
10.0.0.1 y una m&aacute;scara de subred de 255.255.255.0 (o sea, un
/24), la regla <tt>antispoof</tt> anterior se expandir&iacute;a
as&iacute;:
d910 8
a917 8
<li>Bloquean todo el tr&aacute;fico que viene desde la red 10.0.0.0/24
que <i>no</i> pase a trav&eacute;s de <tt>fxp0</tt>.  Como la red
10.0.0.0/24 est&aacute; en la interfaz <tt>fxp0</tt>, los paquetes que
tengan una direcci&oacute;n de origen en ese bloque de red nunca
entrar&aacute;n por ninguna otra interfaz.
<li>Bloquean todo el tr&aacute;fico entrante desde 10.0.0.1, la
direcci&oacute;n IP en <tt>fxp0</tt>.  La m&aacute;quina anfitriona no
deber&iacute;a enviar nunca paquetes a s&iacute; misma a trav&eacute;s
d919 2
a920 2
cualquier paquete entrante con una direcci&oacute;n de origen que
pertenezca a la m&aacute;quina es malicioso.
d924 7
a930 6
<b>NOTA</b>:  Las reglas de filtrado resultantes de la expansi&oacute;n
de la regla <tt>antispoof</tt> tambi&eacute;n bloquear&aacute;n los
paquetes que se env&iacute;en por la interfaz de <i>loopback</i> hacia
direcciones locales.  Es necesario permitir el paso de estas direcciones
de forma expl&iacute;cita.  Por ejemplo:

d933 1
a933 1
pass quick on lo0 all<br>
d941 3
a943 4
que se les haya asignado una direcci&oacute;n IP.  El uso de
<tt>antispoof</tt> en una interfaz sin una direcci&oacute;n IP
resultar&aacute; en reglas de filtrado como:

d953 33
a985 1
tr&aacute;fico entrante en <i>todas</i> las interfaces.
d988 1
a988 1
<h2>Identificación Pasiva del Sistemas Operativo</h2>
d991 4
a994 3
La identificación pasiva del sistema operativo (OSFP por sus siglas en inglés)
es un método para detectar pasivamente el sistema operativo de un host remoto
basado en ciertas características contenidas en sus paquetes SYN TCP.
d1000 1
a1000 1
<a href="options.html#fingerprints">archivo de <i>fingerprints</i></a>,
d1002 4
a1005 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+3.5"><tt>/etc/pf.os</tt></a>. 
Una vez que PF está habilitado, la lista actual de <i>fingerprints</i>
d1015 1
a1015 1
Dentro de una regla de filtro, un <i>fingerprint</i> puede especificarse
d1018 1
a1018 1
<tt>pfctl</tt> de arriba. Para especificar un <i>fingerprint</i> en una regla
d1023 4
a1026 4
pass &nbsp;in on $ext_if any os OpenBSD keep state<br>
block in on $ext_if any os "Windows 2000"<br>
block in on $ext_if any os "Linux 2.4 ts"<br>
block in on $ext_if any os unknown
d1032 2
a1033 2
concuerden con la regla si el <i>fingerprint</i> del sistema operativo es
desconocido.
d1038 2
a1039 2
   <li>Los <i>fingerprints</i> de los sistemas operativos de vez en cuando
   son incorrectos debido a paquetes falsificados y/o fabricados que
d1044 1
a1044 1
   con el archivo de <i>fingerprints</i> o que concuerde con algún otro
d1053 5
a1057 5
Por definici&oacute;n, PF bloquea los paquetes con las opciones IP
activadas.  Esto puede hacer las cosas m&aacute;s dif&iacute;ciles para
utilidades de detecci&oacute;n de sistemas operativos (<i>OS
fingerprinting</i>) como nmap.  Si se tiene una aplicaci&oacute;n que
requiere el paso de estos paquetes, como multidifusi&oacute;n o IGMP, se
d1066 1
a1066 1
<h2>Ejemplo de Reglas de Filtrado</h2>
d1068 4
a1071 4
A continuaci&oacute;n tenemos un ejemplo de un grupo de reglas de
filtrado.  La m&aacute;quina en la que est&aacute; funcionando PF
act&uacute;a como cortafuegos entre una red interna peque&ntilde;a e
Internet.  S&oacute;lo se muestran las reglas de filtrado;  las reglas
d1081 3
a1083 3
ext_if  = &quot;fxp0&quot;
int_if  = &quot;dc0&quot;
lan_net = &quot;192.168.0.0/24&quot;
d1085 1
a1085 1
# tabla que contiene todas las direcciiones IP asignadas al firewall
d1088 3
d1092 1
a1092 1
scrub in all
d1094 2
a1095 3
# configurar una pol&iacute;tica de denegaci&oacute;n predeterminada
block in  all
block out all
d1097 7
a1103 11
# permitir el paso del tr&aacute;fico en la interfaz de <i>loopback</i>
# en cualquier direcci&oacute;n
pass quick on lo0 all

# activar la protecci&oacute;n contra la falsificaci&oacute;n de direcciones
# para la interfaz interna
antispoof quick for $int_if inet

# permitir s&oacute;lo conexiones por ssh si provienen
# desde la m&aacute;quina de confianza, 192.168.0.15;
# usar &quot;block return&quot; para que se env&iacute;e un TCP RST
d1105 2
a1106 2
# usar &quot;quick&quot; para que las reglas &quot;pass&quot; que
# vienen a continuaci&oacute;n no anulen esta regla.
d1108 1
a1108 1
   to $int_if port ssh flags S/SA
d1110 5
a1114 3
# permitir el paso del tr&aacute;fico hacia y desde la red local
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net
d1116 1
a1116 1
# permitir el paso de paquetes tcp, udp y icmp
d1118 2
a1119 4
# mantener el estado en udp y icmp, y modular
# el estado en tcp.
pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state
d1123 8
a1130 6
# el cortafuegos (o sea, aqu&eacute;llas cuyo destino sea
# una m&aacute;quina en la red local);  registrar el paquete inicial
# para que podamos ver m&aacute;s tarde qui&eacute;n intenta conectar.
# Usar el proxy tcp syn para la conexi&oacute;n.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh flags S/SA synproxy state
d1138 1
a1138 1
[<a href="nat.html">Siguiente: Traducci&oacute;n de Direcciones de
d1143 1
a1143 1
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[&Iacute;ndice]"></a> 
d1147 4
a1150 2
Originally [OpenBSD: filter.html,v 1.21 ]<br>
$Translation: filter.html,v 1.14 2004/08/31 16:29:51 santana Exp $<br>
d1153 1
d1155 1
a1155 1
</html> 
@


1.12
log
@Sync with Steelix CVS
@
text
@a11 1
<meta name="copyright"     content="Este documento es copyright 2002-2004 de OpenBSD.">
d14 17
d58 1
d71 1
a71 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.4">pf(4)</a>
d74 2
a75 2
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.4">IPv4</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.4">IPv6</a>)
d77 4
a80 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.4">TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.4">UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.4">ICMP</a>, y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.4">ICMPv6</a>)
d95 1
a95 1
qu&eacute; acci&oacute;n se tomar&aacute; con el paquete.  Al final del
d135 1
a135 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.4">pflogd(8)</a>.
d150 1
a150 1
<dd>El nombre de la interfaz de red a trav&eacute;s de la cual se mueve
d152 5
d172 1
a172 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.4"><tt>/etc/protocols</tt></a>
d203 21
a223 5
<li>El nombre de una interfaz de red seguido por las claves
<tt>:network</tt> o <tt>:broadcast</tt>.  La red CIDR resultante (o sea,
192.168.0.0/24) o la direcci&oacute;n de multidifusi&oacute;n
(<i>broadcast</i>) (o sea, 192.168.0.255) se sustituir&aacute;n dentro
de la regla cuando se carguen las reglas.
d240 1
a240 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.4"><tt>/etc/services</tt></a>
d250 2
a251 3
	<li><tt>&gt;&lt;</tt> (dentro del campo... menor que y mayor que)
	<li><tt>&lt;&gt;</tt> (campo inverso)
	</ul>
d256 6
d453 2
d461 2
a462 2
pass out on fxp0 proto tcp from any to any modulate state<br>
pass out on fxp0 proto { udp, icmp } from any to any keep state
d480 17
a496 8
Es importante tener en cuenta que las conexiones con estado est&aacute;n
limitadas a la interfaz en las que han sido creadas.  Esto es importante
sobre todo en enrutadores y cortafuegos con PF, en especial cuando se ha
implementado una pol&iacute;tica de denegaci&oacute;n predeterminada
como la que se ha detallado anteriormente.  Si un cortafuegos
est&aacute; manteniendo el estado en todas las conexiones salientes en
la interfaz externa, hay que permitir el paso de esos paquetes a
trav&eacute;s de la interfaz interna de forma expl&iacute;cita.
d676 1
a676 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.4"
d706 1
a706 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.4">pflogd(8)</a>.
d773 1
a773 1
pass in quick on lo0 all<br>
d796 60
d891 3
d934 2
a935 2
# Usar la proxy tcp syn para la conexi&oacute;n.
pass in log on $ext_if proto tcp from any to { !$ext_if, !$int_if } \
d953 2
a954 2
Originally [OpenBSD: filter.html,v 1.16 ]<br>
$Translation: filter.html,v 1.13 2004/01/04 21:32:07 horacio Exp $<br>
@


1.11
log
@Sync with Steelix CVS
@
text
@d12 1
a12 1
<meta name="copyright"     content="Este documento es copyright 2002-2003 de OpenBSD.">
d836 2
a837 2
Originally [OpenBSD: filter.html,v 1.15 ]<br>
$Translation: filter.html,v 1.12 2003/12/01 22:53:16 horacio Exp $<br>
@


1.10
log
@Sync with Steelix CVS
@
text
@d21 1
a21 1
[<a href="rdr.html">Anterior: Redireccionamiento de Tr&aacute;fico</a>]
d23 2
a24 1
[<a href="logging.html">Siguiente: Registros de Bit&aacute;cora</a>]
d36 1
d40 1
a40 1
<li><a href="#quick">La Clave <tt>quick</tt></a>
d91 1
a91 1
<i>action</i> <i>direction</i> [log] [quick] on <i>int</i> [<i>af</i>] 
d119 5
a123 4
Si la regla especifica la opci&oacute;n <tt>keep state</tt> o
<tt>modulate state</tt>, entonces s&oacute;lo se registrar&aacute; el
paquete que establezca el estado.  Para registrar todos los paquetes hay
que usar la opci&oacute;n <tt>log-all</tt>.
d129 2
a130 1
acci&oacute;n que se lleve especificada sin m&aacute;s dilaci&oacute;n.
d132 1
a132 1
<dt><tt><i>int</i></tt>
d238 4
d305 44
d464 1
a464 1
del fichero <tt>/etc/pf.conf</tt>.
d583 2
a584 2
<a name="quick"></a>
<h2>La Clave <tt>quick</tt></h2>
d586 13
a598 11
Como se ha indicado anteriormente, cada paquete se eval&uacute;a con el
grupo de reglas de filtrado, desde la primera hasta la &uacute;ltima.
El resultado predeterminado es el de marcar el paquete para que se le
permita el paso;  esto puede cambiar con cualquiera de las reglas por
las que pasa, y podr&iacute;a cambiar varias veces antes de llegar al
final de las reglas de filtrado.  <b>La &uacute;ltima regla con la que
concuerde marcar&aacute; el resultado.</b>  Existe una excepci&oacute;n
para esto:  la opci&oacute;n <tt>quick</tt> en una regla de filtrado
tiene el efecto de cancelar el procesamiento de cualquier regla
consiguiente, y provoca que se ejecute la acci&oacute;n especificada sin
m&aacute;s dilaci&oacute;n.  Veamos un par de ejemplos:
d601 3
a603 1
Mal:
d606 2
a607 2
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
d612 2
a613 3
En este caso, la l&iacute;nea <tt>block</tt> puede ser evaluada, pero
nunca tendr&aacute; ning&uacute;n efecto, ya que va seguida por una
l&iacute;nea que permite el paso de todo.
d616 3
a618 7
Mejor:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>
d621 3
a623 4
Estas reglas se eval&uacute;an de una forma algo diferente.  Si un
paquete concuerda con la l&iacute;nea <tt>block</tt>, debido a la
naturaleza de la opci&oacute;n <tt>quick</tt>, se bloquear&aacute; el
paso a dicho paquete y se ignorar&aacute; el resto del grupo de reglas.
d681 4
a684 3
Asumiendo que la interfaz fxp0 tuviera una direcci&oacute;n IP 10.0.0.1
y una m&aacute;scara de subred de 255.255.255.0 (o sea, un /24), la
regla <tt>antispoof</tt> anterior se expandir&iacute;a as&iacute;:
d698 4
a701 4
que <i>no</i> pase a trav&eacute;s de fxp0.  Como la red 10.0.0.0/24
est&aacute; en la interfaz fxp0, los paquetes que tengan una
direcci&oacute;n de origen en ese bloque de red nunca entrar&aacute;n
por ninguna otra interfaz.
d703 1
a703 1
direcci&oacute;n IP en fxp0.  La m&aacute;quina anfitriona no
d817 1
d819 1
a819 1
   port ssh flags S/SA keep state
d825 1
a825 1
[<a href="rdr.html">Anterior: Redireccionamiento de Tr&aacute;fico</a>]
d827 2
a828 1
[<a href="logging.html">Next: Registros de Bit&aacute;cora</a>]
d836 2
a837 2
Originally [OpenBSD: filter.html,v 1.14 ]<br>
$Translation: filter.html,v 1.11 2003/11/17 19:22:08 horacio Exp $<br>
@


1.9
log
@sync with steelix cvs
@
text
@d52 1
a52 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.3">pf(4)</a>
d55 2
a56 2
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.3">IPv4</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.3">IPv6</a>)
d58 4
a61 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.3">TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.3">UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.3">ICMP</a>, y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.3">ICMPv6</a>)
d116 1
a116 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">pflogd(8)</a>.
d146 1
a146 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.3"><tt>/etc/protocols</tt></a>
d198 1
a198 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.3"><tt>/etc/services</tt></a>
d602 1
a602 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">pflogd(8)</a>.
d783 2
a784 2
Originally [OpenBSD: filter.html,v 1.13 ]<br>
$Translation: filter.html,v 1.10 2003/09/27 13:46:08 horacio Exp $<br>
@


1.8
log
@sync with steelix cvs
@
text
@d166 1
a166 1
como sigue: <i><tt>/netmask</tt></i> (o sea, <tt>/24</tt>).  Cada
d254 1
a254 1
block in  all<br>
d713 4
a716 2
de <a href="queueing.html">queueing</a>, <a href="nat.html">NAT</a>, 
<a href="rdr.html">rdr</a>, etc.. se han omitido en este ejemplo.
d783 3
a785 3
Originally [OpenBSD: filter.html,v 1.12 2003/09/16 01:23:49 nick Exp ]<br>
$OpenBSD$<br>
$Translation: filter.html,v 1.9 2003/09/19 22:10:58 horacio Exp $
@


1.7
log
@sync with steelix translation CVS
@
text
@d402 4
a405 4
Se dice que &laquo;no se puede crear estado con UDP, ya que UDP es un
protocolo sin estado&raquo;.  Aunque es cierto que una sesi&oacute;n de
comunicaci&oacute;n de UDP no tiene ning&uacute;n concepto de estado (un
comienzo y un final de las comunicaciones expl&iacute;cito), esto no
d781 1
a781 1
Originally [OpenBSD: filter.html,v 1.11 2003/08/08 22:12:50 nick Exp ]<br>
d783 1
a783 1
$Translation: filter.html,v 1.8 2003/08/11 10:13:10 horacio Exp $
@


1.6
log
@sync with steelix translation CVS
@
text
@d748 3
a750 4
# permitir el paso del tr&aacute;fico hacia y desde la
# red local con destino a la m&aacute;quina de cortafuegos.
pass in  on $int_if from $lan_net to $int_if 
pass out on $int_if from $int_if to $lan_net
d781 1
a781 1
Originally [OpenBSD: filter.html,v 1.10 2003/06/15 16:40:06 nick Exp ]<br>
d783 1
a783 1
$Translation: filter.html,v 1.7 2003/07/06 17:23:44 horacio Exp $
@


1.5
log
@sync with steelix translation CVS
@
text
@d373 8
a380 4
TCP y llega un mensaje ICMP de origen que se refiere a esta
conexi&oacute;n TCP, se buscar&aacute; su concordancia con la entrada
apropiada de la tabla de estado y pasar&aacute; a trav&eacute;s del
cortafuegos.
d784 1
a784 1
$Translation: filter.html,v 1.6 2003/07/06 10:54:42 horacio Exp $
@


1.4
log
@sync with steelix translation CVS
@
text
@d35 2
a36 2
<li><a href="#state">Mantenimiento de Estado</a>
<li><a href="#udpstate">Mantenimiento de Estado para UDP</a>
d49 3
a51 3
Filtrar paquetes es pasar o bloquear los paquetes de datos de forma
selectiva seg&uacute;n llegan a de una interfaz de red.  Los criterios
que usa
d53 3
a55 2
para inspeccionar los paquetes se basan en la Layer 3 de las cabeceras
de (<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.3">IPv4</a> y
d57 1
a57 1
y en la Layer 4 de las cabeceras de
d61 4
a64 4
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.3">ICMPv6</a>).
Los criterios que m&aacute;s se utilizan son los de la direcci&oacute;n
de origen y de destino, el puerto de origen y de destino, y el
protocolo.
d68 13
a80 13
coincidir un paquete y la acci&oacute;n a seguir, bien sea bloquearlo o
pasarlo, que se toma cuando se encuentra una coincidencia.  Las reglas
de filtrado se eval&uacute;an por orden de secuencia, de la primera a la
&uacute;ltima.  A menos que el paquete coincida con una regla que
contenga la clave <tt>quick</tt>, se evaluar&aacute; el paquete
compar&aacute;ndolo con <i>todas</i> las reglas de filtrado antes de
decidir una acci&oacute;n final.  La &uacute;ltima regla que coincida
ser&aacute; la &laquo;ganadora&raquo; y la que dictamine qu&eacute;
acci&oacute;n se tomar&aacute; con el paquete.  Al final del grupo de
reglas de filtrado hay un <tt>pass all</tt> impl&iacute;cito que indica
que si alg&uacute;n paquete no coincide con ninguna de las reglas de
filtrado, la acci&oacute;n a seguir ser&aacute; <tt>pass</tt>, o sea
pasarlo.
d99 1
a99 1
<dd>La acci&oacute;n a seguir para los paquetes que coincidan, ya sea
d101 8
a108 8
pasar&aacute; el paquete de vuelta al n&uacute;cleo del sistema, para
que lo procese, mientras que la acci&oacute;n <tt>block</tt>
actuar&aacute; seg&uacute;n se indique en la configuraci&oacute;n de la
opci&oacute;n de la pol&iacute;tica de bloqueo,
<a href="options.html#block-policy"><tt>block-policy</tt></a>.
La acci&oacute;n predeterminada se puede anular especificando
<tt>block drop</tt> (bloquear y eliminar el paquete) o
<tt>block return</tt> (bloquear y devolver el paquete).
d123 1
a123 1
<dd>Si un paquete coincide con una regla que especifique la
d125 2
a126 2
regla final de coincidencia para el paquete, y se tomar&aacute; la
acci&oacute;n que se haya especificado sin m&aacute;s dilaci&oacute;n.
d133 3
a135 3
<dd>La familia de direcciones del paquete, bien <tt>inet</tt> para IPv4
&oacute; <tt>inet6</tt> para IPv6.  Generalmente, PF es capaz de
determinar este par&aacute;metro bas&aacute;ndose en la
d139 1
a139 1
<dd>El protocolo de la capa Layer 4 del paquete:
d174 3
a176 3
medio de DHCP o de una conexi&oacute;n tipo <i>dial-up</i>, ya que no
hay que volver a cargar las reglas cada vez que cambie la
direcci&oacute;n.
d193 2
a194 2
<dd>El puerto de origen y/o de destino en la capa Layer 4 de la cabecera
IP.  Los puertos se pueden especificar como:
d222 1
a222 1
(SYN y ACK), y que acepte la coincidencia si el indicador SYN
d227 1
a227 1
paquetes que coincidan con esta regla.
d232 2
a233 2
<i>Initial Sequence Numbers</i>) fuertes para los paquetes que coincidan
con esta regla.
d245 1
a245 1
recomendada por que los posibles fallos se cometer&iacute;an a favor de
d261 1
a261 1
cualquier direcci&oacute;n, y desde cualquier origen hasta cualquier
d271 1
a271 1
paquete, como el puerto de origen/destino, la direcci&oacute;n de
d273 1
a273 1
cierto tr&aacute;fico a trav&eacute;s del cortafuegos, hay que escribir
d282 1
a282 1
# Dejar pasar el tr&aacute;fico entrante en la interfaz dc0 de la red local,<br>
d284 1
a284 1
# Tambi&eacute;n dejar pasar el tr&aacute;fico saliente que es enviado de vuelta en dc0.<br>
d289 1
a289 1
# Dejar pasar el tr&aacute;fico entrante TCP en la interfaz fxp0 del servidor<br>
d292 1
a292 1
# s&oacute;lo coincidan con esta regla si tienen como destino la m&aacute;quina de OpenBSD.<br>
d298 1
a298 1
<h2>Mantenimiento de Estado</h2>
d300 24
a323 22
Una de las capacidades importantes de PF es la de &laquo;mantener el
estado&raquo; (<i>keeping state</i>) o &laquo;inspecci&oacute;n completa
del estado&raquo; (<i>stateful inspection</i>).  La inspecci&oacute;n
del estado se refiere a la capacidad de PF de llevar un seguimiento del
estado, o del progreso, de una conexi&oacute;n de red.  Almacenando
informaci&oacute;n sobre cada conexi&oacute;n en una tabla de estado, PF
puede determinar r&aacute;pidamente si un paquete que est&aacute;
pasando a trav&eacute;s del cortafuegos pertenece a una conexi&oacute;n
ya establecida.  Si es as&iacute;, se le permite pasar a trav&eacute;s
del cortafuegos sin tener que pasar a trav&eacute;s de la
evaluaci&oacute;n del grupo de reglas.

<p>
El mantenimiento de estado tiene muchas ventajas, entre otras unos
grupos de reglas son m&aacute;s simples y un mejor rendimiento del
filtrado de paquetes.  PF puede puede hacer que los paquetes que vayan
en <i>cualquier</i> direcci&oacute;n coincidan con entradas en la tabla
de estado, lo que quiere decir que no es necesario escribir las reglas
de filtrado que permiten el paso del tr&aacute;fico de vuelta.  Y, como
los paquetes que coinciden con conexiones <i>stateful</i> no pasan a
trav&eacute;s de la evaluaci&oacute;n del grupo de reglas, el tiempo que
tarda PF en procesarlos se puede reducir considerablemente.
d327 7
a333 7
paquete que coincide con ella crea un &laquo;estado&raquo; entre el
remitente y el destinatario.  Ahora los paquetes que vayan entre el
remitente y el destinatario no ser&aacute;n los &uacute;nicos que
coincidir&aacute;n con la entrada de estado y que circunvalar&aacute;n
la evaluaci&oacute;n de las reglas, sino que tambi&eacute;n lo
har&aacute;n los paquetes de respuesta desde el destinatario hacia el
remitente.  Por ejemplo:
d344 1
a344 1
cortafuegos.  El mantenimiento de estado es una funcionalidad muy
d347 2
a348 2
r&aacute;pidas que pasar un paquete a trav&eacute;s de las reglas de
filtrado.
d351 5
a355 4
La opci&oacute;n <tt>modulate state</tt> funciona como <tt>keep
state</tt>, con la diferencia que s&oacute;lo es v&aacute;lida para
paquetes TCP.  Con <tt>modulate state</tt>, el ISN de las conexiones
salientes es aleatorio.  Esto es &uacute;til para proteger conexiones
d360 1
a360 1
Mantenimiento de estado en paquetes TCP, UDP y ICMP salientes y ISN TCP
d370 1
a370 1
Otra ventaja del mantenimiento de estado es que el tr&aacute;fico ICMP
d374 1
a374 1
conexi&oacute;n TCP, se buscar&aacute; su coincidencia con la entrada
d392 1
a392 1
para las conexiones que coincidan, siempre que la conexi&oacute;n pase
d396 1
a396 1
<h2>Mantenimiento de Estado para UDP</h2>
d404 3
a406 3
&laquo;comienzo&raquo; ni &laquo;final&raquo;, PF se limita a mantener
un seguimiento del tiempo transcurrido desde que ha pasado un paquete
que coincida.  Los valores del tiempo muerto (<i>timeout</i>) se pueden
d413 1
a413 1
La coincidencia de paquetes TCP basada en indicadores es algo que se
d442 1
a442 1
en la cabecera para que ocurra una coincidencia.
d452 1
a452 1
los indicadores SYN y ECE coincidir&iacute;a con la regla anterior,
d454 1
a454 1
coincidir&iacute;a.
d458 1
a458 1
anteriores de OpenBSD.
d480 1
a480 1
TCP saliente con el indicador SYN activado entre los indicadores SYN y
d486 1
a486 1
cuidado con los consejos dados por otros ya que muchos suelen ser
d491 1
a491 1
     . . . flags S/FSRPAUEW  <i>&iquest;&iquest;mala idea!!</i>
d499 1
a499 1
use ECN e intente conectar con nosotros ser&iacute;a rechazado por una
d509 1
a509 1
comprobar los indicadores FIN y RST si se est&aacute;n aplicando la
d511 5
a515 4
sobre el tr&aacute;fico.  El proceso de <i>scrubbing</i> har&aacute; que
PF bloquee cualquier paquete entrante que lleve una combinaci&oacute;n
ilegal del indicador TCP (como SYN y FIN o SYN y RST).  Es muy
recomendable que se normalicen siempre el tr&aacute;fico entrante:
d531 2
a532 2
grupo de reglas filtrado, desde la primera hasta la &uacute;ltima.  El
resultado predeterminado es el de marcar el paquete para que se le
d536 1
a536 1
coincida marcar&aacute; el resultado.</b>  Existe una excepci&oacute;n
d566 2
a567 2
Estas reglas se eval&uacute;an de un forma algo diferente.  Si un
paquete coincide en la l&iacute;nea <tt>block</tt>, debido a la
d578 4
a581 4
el usuario ha falsificado su direcci&oacute;n, puede lanzar un ataque de
red sin revelar el origen real del ataque, o intentar obtener acceso a
servicios de la red que est&eacute;n restringidos para ciertas
direcciones IP.
d584 3
a586 2
PF ofrece algo de protecci&oacute;n contra la falsificaci&oacute;n de
direcciones, a trav&eacute;s de la clave <tt>antispoof</tt>:
d639 1
a639 1
Estas reglas llevan a cabo dos cosas:
d642 1
a642 1
<li>Bloquea todo el tr&aacute;fico que viene desde la red 10.0.0.0/24
d647 1
a647 1
<li>Bloquea todo el tr&aacute;fico entrante desde 10.0.0.1, la
d658 1
a658 1
paquetes que se env&iacute;n por la interfaz de <i>loopback</i> hacia
d671 2
a672 2
Debe restringirse el uso de <tt>antispoof</tt> a las interfaces a las
que se les ha asignado una direcci&oacute;n IP.  El uso de
d692 4
a695 4
utilidades de <i>fingerprinting</i> de sistemas operativos como nmap.
Si se tiene una aplicaci&oacute;n que requiere el paso de estos
paquetes, como multidifusi&oacute;n o IGMP, se puede usar la directiva
<tt>allow-opts</tt>:
d708 2
a709 2
Internet.  S&oacute;lo se muestran las reglas de filtrado:
<a href="queueing.html">queueing</a>, <a href="nat.html">NAT</a>, 
d780 1
a780 1
$Translation: filter.html,v 1.5 2003/06/15 18:36:50 horacio Exp $
@


1.3
log
@sync with steelix translation CVS
@
text
@d448 1
a448 1
los indicadores SYN y URG coincidir&iacute;a con la regla anterior,
d470 1
a470 1
pass out on fxp0 proto tcp all flags S/SAFR keep state
d476 2
a477 2
TCP saliente con el indicador SYN activado entre los indicadores SYN,
ACK, FIN y RST.
d504 17
a520 2
Esto significa que el paquete coincide <i>s&oacute;lo si</i> lleva
activado SYN, y si no lleva activado ACK, FIN y RST.
d714 3
d772 1
a772 1
Originally [OpenBSD: filter.html,v 1.9 2003/06/14 03:24:32 nick Exp ]<br>
d774 1
a774 1
$Translation: filter.html,v 1.4 2003/06/15 11:40:23 horacio Exp $
@


1.2
log
@
sync with steelix translation CVS
@
text
@d713 1
a713 1
# usar &quot;block drop&quot; para que se env&iacute;e un TCP RST
d717 1
a717 1
block drop in quick on $int_if proto tcp from ! 192.168.0.15 \
d754 1
a754 1
Originally [OpenBSD: filter.html,v 1.7 2003/06/07 01:18:11 nick Exp ]<br>
d756 1
a756 1
$Translation: filter.html,v 1.3 2003/06/08 10:41:34 horacio Exp $
@


1.1
log
@
initial translation from horacio
@
text
@d39 1
d551 115
d695 3
a697 3
ext_if  = fxp0
int_if  = dc0
lan_net = 192.168.0.0/24
d703 8
d754 1
a754 1
Originally [OpenBSD: filter.html,v 1.6 2003/05/25 01:35:07 nick Exp ]<br>
d756 1
a756 1
$Translation: filter.html,v 1.2 2003/05/26 09:12:05 horacio Exp $
@

