head	1.20;
access;
symbols;
locks; strict;
comment	@# @;


1.20
date	2014.04.01.17.14.11;	author nick;	state dead;
branches;
next	1.19;

1.19
date	2013.12.06.20.52.46;	author ajacoutot;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.03.05.53.48;	author ajacoutot;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.05.08.24.21;	author ajacoutot;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.30.13.23.49;	author ajacoutot;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.16.12.38.13;	author ajacoutot;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.07.07.32.54;	author ajacoutot;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.19.09.39.59;	author ajacoutot;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.17.15.58.26;	author ajacoutot;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.16.08.59.12;	author ajacoutot;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.16.20.24.23;	author tobias;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.01.10.39.11;	author tobias;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.29.11.06.11;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.24.10.04.36;	author saad;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.18.20.48.47;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.26.19.06.04;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.08.17.38.20;	author saad;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.26.10.39.12;	author jufi;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.06.09.27.06;	author saad;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.06.20.03.30;	author jufi;	state Exp;
branches;
next	;


desc
@@


1.20
log
@
Abandon translations, per deraadt@@ and ajacoutot@@.
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtragem de Pacotes</title>
<link rev="made" href="mailto:www@@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="nat.html">Próximo: Tradução do Endereço de Rede (NAT)</a>]

<h1><font color="#e00000">PF: Filtragem de Pacotes</font></h1>

<hr>

<h3>Conteúdo</h3>
<ul>
<li><a href="#intro">Introdução</a>
<li><a href="#syntax">Sintaxe das Regras</a>
<li><a href="#defdeny">Negar por Padrão</a>
<li><a href="#pass">Passando o Tráfego</a>
<li><a href="#quick">A Palavra-chave <tt>quick</tt></a>
<li><a href="#state">Mantendo o Estado</a>
<li><a href="#udpstate">Mantendo o Estado para UDP</a>
<li><a href="#stateopts">Opções de Rastreamento de Estado</a>
<li><a href="#tcpflags">Sinalizadores TCP</a>
<li><a href="#synproxy">Proxy de Pacotes TCP SYN</a>
<li><a href="#antispoof">Bloqueio de Pacotes Falsificados</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Detecção Passiva de Sistema Operacional</a>
<li><a href="#ipopts">Opções IP</a>
<li><a href="#example">Exemplo de Conjunto de Regras de Filtragem</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Introdução</h2>
Filtragem de pacotes é o bloqueio ou liberação de maneira seletiva da
passagem de pacotes de dados, conforme eles atravessam uma interface de
rede. O critério que o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+5.4"
>pf(4)</a> usa quando inspeciona pacotes é baseado na Camada 3
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) e na Camada 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>). Os critérios mais usados são os endereços de origem e
destino, porta de origem e destino, e protocolo.

<p>
Regras de filtragem especificam o critério em que o pacote deve se
enquadrar e a ação resultante que é tomada quando o pacote corresponde
à regra, que pode ser o bloqueio ou a liberação.
As regras de filtragem são avaliadas em sequência, da primeira até a
última.
A menos que o pacote corresponda a uma regra contendo a palavra-chave
<tt>quick</tt>, ele é avaliado por <i>todas</i> as regras de
filtragem antes da ação final ser tomada. A última regra a corresponder
é a "vencedora" e dita qual ação tomar. Existe um <tt>pass all</tt>
implícito no início de um conjunto de regras de filtragem, que significa
que caso o pacote não corresponda a nenhuma regra a ação resultante será
<tt>pass</tt>.

<a name="syntax"></a>
<h2>Sintaxe das Regras</h2>
A forma geral <i>altamente simplificada</i> da sintaxe para regras de
filtragem é:
<blockquote>
<tt>
<i>ação</i> [<i>direção</i>] [log] [quick] [on <i>interface</i>]
[<i>fam_de_end</i>] [proto <i>protocolo</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>end_de_or</i> [port <i>porta_de_or</i>]] [to
<i>end_de_dest</i> [port <i>porta_de_dest</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>sinalizadores_tcp</i>] [<i>estado</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>ação</i></tt>
<dd>A ação executada em pacotes que correspondem à regra; pode ser
<tt>pass</tt> ou <tt>block</tt>. A ação <tt>pass</tt> libera a
passagem do pacote para posterior processamento pelo kernel, enquanto
a ação <tt>block</tt> reage com base na definição da opção
<a href="options.html#block-policy"><tt>block-policy</tt></a>.
A reação padrão pode ser sobrescrita especificando <tt>block drop</tt>
ou <tt>block return</tt> na regra.

<dt><tt><i>direção</i></tt>
<dd>A direção em que o pacote está se movendo em uma interface, pode ser
<tt>in</tt> (entrando) ou <tt>out</tt> (saindo).

<dt><tt>log</tt>
<dd>Especifica que o pacote deve ser registrado via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+5.4"
>pflogd(8)</a>. Se a regra cria um estado, somente o pacote que
estabeleceu o estado é registrado.
Para registrar todos pacotes, use <tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Se um pacote corresponde a uma regra especificada com
<tt>quick</tt>, então essa regra é considerada final e a
<tt><i>ação</i></tt> especificada é executada.

<dt><tt><i>interface</i></tt>
<dd>O nome ou grupo da interface de rede onde o pacote está passando.
Interfaces podem ser adicionadas a um grupo usando o comando
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
Vários grupos também são criados automaticamente pelo kernel:
<ul>
<li>O grupo <tt>egress</tt>, que contém a(s) interface(s) que guarda(m)
    a(s) rota(s) padrão.
<li>O grupo da família de interfaces das interfaces clonadas.
    Por exemplo: <tt>ppp</tt> ou <tt>carp</tt>.
</ul>
Isso faria com que a regra correspondesse a qualquer pacote atravessando
qualquer interface <tt>ppp</tt> ou <tt>carp</tt>, respectivamente.

<dt><tt><i>fam_de_end</i></tt>
<dd>A família de endereços do pacote, <tt>inet</tt> para IPv4 ou
<tt>inet6</tt> para IPv6. Geralmente o PF pode determinar essa
informação com base no(s) endereço(s) de origem e/ou destino do pacote.

<dt><tt><i>protocolo</i></tt>
<dd>O protocolo da Camada 4 do pacote:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Um nome de protocolo válido de
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
    ><tt>/etc/protocols</tt></a>
<li>Um número de protocolo entre 0 e 255
<li>Um conjunto de protocolos utilizando uma
    <a href="macros.html#lists">lista</a>.
</ul>

<dt><tt><i>end_de_or</i></tt>, <tt><i>end_de_dest</i></tt>
<dd>Os endereços de origem/destino no cabeçalho IP. Endereços podem ser
especificados como:
<ul>
<li>Um único endereço IPv4 ou IPv6.
<li>Um bloco de rede <a href="http://public.swbell.net/dedicated/cidr.html"
    >CIDR</a>.
<li>Um nome de domínio totalmente qualificado que será resolvido pelo
    DNS quando o conjunto de regras for carregado. Todos os endereços IP
    resultantes serão substituídos na regra.
<li>O nome de uma interface de rede ou grupo. Quaisquer endereços IP na
    interface serão substituídos na regra.
<li>O nome de uma interface de rede seguido de uma
    <tt>/<i>máscara</i></tt> (ou seja, <tt>/24</tt>). Cada endereço IP
    na interface é combinado com a máscara para formar um bloco de rede
    CIDR que será substituído na regra.
<li>O nome de uma interface de rede ou grupo entre parêntesis
    <tt>( )</tt>. Isso informa ao PF para atualizar a regra caso o(s)
    endereço(s) da interface em questão mude(m). Isso é útil em uma
    interface que obtém seu endereço IP via DHCP ou discada, pois o
    conjunto de regras não precisa ser recarregado toda vez que o
    endereço mudar.
<li>O nome de uma interface de rede seguido de um destes modificadores:
    <ul>
    <li><tt>:network</tt> - substitui o bloco de rede CIDR (por exemplo,
        192.168.0.0/24)
    <li><tt>:broadcast</tt> - substitui o endereço de broadcast
        (por exemplo, 192.168.0.255)
    <li><tt>:peer</tt> - substitui o endereço IP da outra ponta em um
        link ponto a ponto
    </ul>
    <dl>
    <dd>Além disso, o modificador <tt>:0</tt> pode ser acrescentado a um
    nome de interface ou a qualquer um dos modificadores acima para
    dizer ao PF para não incluir apelidos de endereços IP na
    substituição.
    Esses modificadores também podem ser usados quando a interface está
    entre parêntesis.
    Exemplo: <tt>fxp0:network:0</tt>
    </dl>
<li>Uma <a href="tables.html">tabela</a>.
<li>A palavra-chave <tt>urpf-failed</tt> pode ser usada no
    endereço de origem para indicar que ele deve continuar
    através de uma <a href="#urpf">verificação uRPF</a>.
<li>Qualquer um dos apresentados acima, mas negado usando o modificador
    <tt>!</tt> ("não").
<li>Um grupo de endereços usando-se uma <a href="macros.html#lists">
    lista</a>.
<li>A palavra-chave <tt>any</tt>, indicando todos os endereços
<li>A palavra-chave <tt>all</tt>, que é um atalho para <tt>from any to
    any</tt>.
</ul>

<dt><tt><i>porta_de_or</i></tt>, <tt><i>porta_de_dest</i></tt>
<dd>A porta de origem/destino no cabeçalho da Camada 4 do pacote. Portas
podem ser especificadas da seguinte forma:
<ul>
<li>Um número entre 1 e 65535
<li>Um nome de serviço válido de
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
    ><tt>/etc/services</tt></a>
<li>Um grupo de portas usando-se uma <a href="macros.html#lists">lista</a>
<li>Uma faixa:
	<ul>
	<li><tt>!=</tt> (diferente de)
	<li><tt>&lt;</tt> (menor que)
	<li><tt>&gt;</tt> (maior que)
	<li><tt>&lt;=</tt> (menor ou igual a)
	<li><tt>&gt;=</tt> (maior ou igual a)
	<li><tt>&gt;&lt;</tt> (faixa)
	<li><tt>&lt;&gt;</tt> (faixa inversa)
	<dl>
	<dd>Os dois últimos são operadores binários (recebem dois
	argumentos) e não incluem os argumentos na faixa.
	</dl>
	<li><tt>:</tt> (faixa inclusiva)
	<dl>
	<dd>O operador de faixa inclusiva também é um operador binário
	e inclui os argumentos na faixa.
	</dl>
	</ul>
</ul>

<dt><tt><i>sinalizadores_tcp</i></tt>
<dd>Especifica os sinalizadores que precisam estar definidos no
cabeçalho TCP quando <tt>proto tcp</tt> for utilizado. Sinalizadores
são especificados como:
<tt>flags <i>a_verificar</i>/<i>máscara</i></tt>. Por exemplo: <tt>flags
S/SA</tt> - instrui o PF a verificar somente os sinalizadores S e A
(SYN e ACK) e corresponder somente se apenas o sinalizador SYN estiver
"ligado" (e é aplicado, por padrão, em todas as regras que referenciem 
o protocolo TCP). No OpenBSD 4.1 e versões recentes, os sinalizadores padrão
<tt>S/SA</tt> são aplicados em todas as regras de filtragem TCP.
<tt>flags <i>any</i></tt> diz ao PF para não checar as flags.

<dt><tt><i>estado</i></tt>
<dd>Especifica se a informação de estado deve ser mantida em pacotes
que correspondam à regra.
<ul>
<li><tt>no state</tt> - funciona com TCP, UDP e ICMP. Assim o PF 
não tratará a conexão como statefull. Para conexões TCP, o uso 
de <tt>flags any</tt> também é necessário.
<li><tt>keep state</tt> - funciona com TCP, UDP e ICMP.
    Essa opção é o padrão para todas as regras de filtragem.
<li><tt>modulate state</tt> - funciona apenas com TCP. O PF irá gerar
    Números de Sequência Inicial (ISN - "Initial Sequence Number")
    seguros para os pacotes que correspondam à regra.
<li><tt>synproxy state</tt> - faz proxy de pedidos de conexão TCP para
    ajudar a proteger servidores contra a inundação de pacotes TCP SYN
    falsificados. Essa opção inclui a funcionalidade <tt>keep state</tt>
    e <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Negar por Padrão</h2>
A prática recomendada ao configurar um firewall é usar uma política
"negar por padrão". Isto é, bloquear <i>tudo</i> e depois ir
permitindo certos tipos de tráfego através do firewall. Essa é a
abordagem recomendada por ser mais cautelosa, além de facilitar a
configuração do conjunto de regras.

<p>
Para criar uma política de filtragem de negar por padrão, as primeiras
duas regras de filtragem devem ser:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Isso bloqueia todo o tráfego em todas interfaces em qualquer direção,
de qualquer lugar para qualquer lugar.

<a name="pass"></a>
<h2>Passando o Tráfego</h2>
O tráfego agora deve ser explicitamente permitido ou será barrado pela
política padrão do firewall. É aqui que os critérios de filtragem
como porta de origem/destino, endereço de origem/destino e protocolo
entram em cena. Sempre que o tráfego tiver permissão de cruzar o
firewall, as regras devem ser escritas da maneira mais restritiva
possível. Isso é para nos certificarmos de que o tráfego válido, e
somente tráfego válido, terá permissão para passar.

<p>
Alguns exemplos:
<blockquote>
<tt>
# Libera o tráfego entrando na interface dc0, vindo da rede local<br>
# 192.168.0.0/24 e indo para a máquina OpenBSD com o endereço IP<br>
# 192.168.0.1. Também permite o tráfego de retorno saindo da dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Libera o tráfego TCP chegando em fxp0 e indo para o servidor Web<br>
# em execução na máquina OpenBSD. O nome da interface, fxp0, é usado<br>
# como endereço de destino, de modo que aqueles pacotes somente<br>
# correspondam à regra se eles têm como destino a máquina OpenBSD.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>A palavra-chave <tt>quick</tt></h2>
Como dito anteriormente, cada pacote é avaliado pelo conjunto de regras
de filtragem de cima para baixo. Por padrão, o pacote é marcado para
passagem, o que pode ser alterado por qualquer regra e depois alterado
novamente várias vezes antes do fim das regras de filtragem. <b>A última
regra que corresponde "vence".</b>  Mas, há uma exceção à regra: a
opção <tt>quick</tt> em uma regra de filtragem tem o efeito de cancelar
o processamento de qualquer outra regra que venha em seguida e executa
imediatamente a ação especificada.
Vejamos alguns exemplos:

<p>
Errado:
<blockquote>
<tt>
block in on fxp0 proto tcp to port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Nesse caso, a linha <tt>block</tt> será avaliada, mas jamais terá efeito
algum, pois é seguida de uma linha que permite a passagem de tudo.

<p>
Melhor:
<blockquote>
<tt>
block in quick on fxp0 proto tcp to port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Essas regras são avaliadas de maneira ligeiramente diferente.
Caso a linha <tt>block</tt> corresponda à regra, devido ao uso da opção
<tt>quick</tt>, o pacote será bloqueado e o restante do
conjunto de regras será ignorado.

<a name="state"></a>
<h2>Mantendo o Estado</h2>
Uma das características importantes do Packet Filter é manter o estado
das conexões. O PF é capaz de registrar o estado, ou progresso, de
uma conexão de rede. Ao armazenar informações sobre o estado de cada
conexão em uma tabela de estados, o PF pode rapidamente determinar se um
pacote passando pelo firewall pertence a uma conexão já estabelecida.
Caso afirmativo, o pacote passa direto pelo firewall sem ser avaliado
pelo conjunto de regras.

<p>
Manter informações do estado das conexões traz muitas vantagens,
incluindo simplicidade na configuração do conjunto de regras e melhor
desempenho na filtragem de pacotes. O PF é capaz de comparar os pacotes,
indo em <i>qualquer</i> direção, com as entradas na tabela de estados,
o que significa que regras de filtragem que autorizam o tráfego de
retorno não precisam ser escritas. E, como pacotes que correspondem às
conexões com o estado mantido não são avaliados pelo conjunto de regras,
o tempo que o PF gasta processando aqueles pacotes pode ser reduzido
drasticamente.

<p>
Quando uma regra cria estado, o primeiro pacote que corresponde à regra
cria um "estado" entre o transmissor e o receptor.
Agora, não somente os pacotes do transmissor para o receptor
correspondem à entrada na tabela e passam direto pela avaliação do
conjunto de regras, mas também os pacotes de resposta do receptor
para o transmissor.

<p>
Todas as regras <i>pass</i> automaticamente criam um registro 
de estado quando um pacote corresponde aquela regra. 
Esse comportamento pode ser explicitamente desabilitado 
utilizando <tt>no state</tt>.

<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Isso permite que qualquer tráfego TCP saia pela interface <tt>fxp0</tt>,
bem como o tráfego retornando em resposta ao firewall. 
Manter estados de conexões dão um aumento significativo na performance 
do seu firewall, uma vez que consultas aos registros de estados já 
existentes é muito mais rápido que fazer o pacote percorrer outras 
regras de filtragem.

<p>
A opção <tt>modulate state</tt> funciona como a <tt>keep state</tt>,
exceto que ela se aplica apenas a pacotes TCP. Com
<tt>modulate state</tt>, o Número de Sequência Inicial
de conexões saindo do firewall é aleatório.
Isso é útil para proteger conexões iniciadas por certos
sistemas operacionais que não fazem um bom trabalho ao escolher ISNs.
Com intuito de criar conjuntos de regras mais simples, utilizar 
<tt>modulate state</tt> como uma opção na regra pode ser feito para 
regras que não especifiquem o protocolo TCP; nesses casos o PF 
tratará a regra como <tt>keep state</tt>.

<p>
Para manter o estado em pacotes TCP, UDP e ICMP, e modular ISNs TCP:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Outra vantagem de se manter o estado é que o tráfego ICMP correspondente
também passa pelo firewall. Por exemplo, se existe uma conexão TCP
passando através do firewall, com o estado sendo mantido, e chega
uma mensagem de congestionamento ("source-quench") ICMP referenciando
esta conexão TCP, ela será correspondida à entrada apropriada na
tabela de estados e passará direto pelo firewall.

<p>
O escopo de uma entrada na tabela de estados é controlado globalmente
pela opção em tempo de execução
<a href="options.html#state-policy"><tt>state-policy</tt></a>
e ao nível de cada regra pelas palavras-chave de opções de estado
<tt>if-bound</tt> e <tt>floating</tt>.
Essas palavras-chave usadas nas regras têm o mesmo efeito de
quando são usadas na opção <tt>state-policy</tt>. Exemplo:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Essa regra define que para um pacote corresponder à entrada na tabela de
estados, ele deve estar transitando na interface <tt>fxp0</tt>.

<a name="udpstate"></a>
<h2>Mantendo o Estado Para UDP</h2>
Algumas vezes você pode ouvir que: "Não se pode criar estados para
conexões UDP, pelo fato do UDP ser um protocolo que não mantém o
estado das conexões!". Enquanto é verdade que uma sessão de
comunicação UDP não possui nenhum conceito de estado (um início e fim
explícito na comunicação), isso não causa nenhum impacto na habilidade
do PF em criar estados para sessões UDP. No caso de protocolos sem
pacotes de "início" e "fim", o PF simplesmente mantém um registro do
tempo desde a última ocorrência de um pacote para dada conexão. Caso
o tempo de expiração seja atingido, o registro de estado é eliminado.
Valores para esse intervalo podem ser definidos na seção de
<a href="options.html">opções</a> do arquivo <tt>pf.conf</tt>.

<a name="stateopts"></a>
<h2>Opções de Rastreamento de Estado</h2>
Regras de filtragem que criam entradas na tabela de estados podem
especificar várias opções para controlar o comportamento resultante
da criação de estado.
As seguintes opções estão disponíveis:

<dl>
<dt><tt>max <i>número</i></tt>
<dd>Limita o número máximo de entradas de estado que a regra pode
criar para <i>número</i>.
Se o máximo for alcançado, pacotes que normalmente criariam estados
falham na correspondência à regra até que o número de estados existentes
diminua abaixo do limite.

<dt><tt>no state</tt>
<dd>Previne a regra de criar automaticamente uma entrada na tabela de
estados.

<dt><tt>source-track</tt>
<dd>Essa opção habilita o rastreamento do número de estados criados
por endereço IP de origem.
Essa opção tem dois formatos:
       <ul>
       <li><tt>source-track rule</tt> - O número máximo de estados
           criados por essa regra é limitado pelas opções
           <tt>max-src-nodes</tt> e <tt>max-src-states</tt>
           da regra. Somente entradas de estado criadas por essa regra
           em particular conta para os limites da regra.
       <li><tt>source-track global</tt> - O número de estados criados
           por todas as regras que usam essa opção é limitado.
           Cada regra pode especificar diferentes opções
           <tt>max-src-nodes</tt> e <tt>max-src-states</tt>,
           no entanto, entradas de estado criadas por qualquer regra
           participante conta para os limites individuais da regra.
       </ul>
O número total de endereços IP de origem rastreados globalmente pode
ser controlado pela
<a href="options.html#limit">opção em tempo de execução <tt>src-nodes</tt></a>.

<dt><tt>max-src-nodes <i>número</i></tt>
<dd>Quando a opção <tt>source-track</tt> é usada,
<tt>max-src-nodes</tt> limita o número de endereços IP de origem que
podem criar estados simultaneamente.
Essa opção só pode ser usada com <tt>source-track rule</tt>.

<dt><tt>max-src-states <i>número</i></tt>
<dd>Quando a opção <tt>source-track</tt> é usada,
<tt>max-src-states</tt> limita o número de estados simultâneos que podem
ser criados por endereço IP de origem.
O escopo desse limite (ou seja, estados criados por somente essa regra
ou estados criados por todas as regras que usam  <tt>source-track</tt>)
é dependente da opção <tt>source-track</tt> especificada.
</dl>

<p>
Opções são especificadas dentro de parêntesis e imediatamente depois
de uma das palavras-chave de estado (<tt>keep state</tt>,
<tt>modulate state</tt> ou <tt>synproxy state</tt>).
Múltiplas opções são separadas por vírgulas.
No OpenBSD 4.1 e versões recentes, a opção <tt>keep state</tt> se tornou
o padrão implícito para todas as regras de filtragem.
Apesar disso, quando se especifica opções de manter estado, uma
das palavras-chave deve ainda ser usada antes das opções.


<p>
Uma regra de exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
A regra acima define o seguinte comportamento:

<ul>
<li>Limita o número máximo de estados que essa regra pode criar para 200
<li>Habilita o rastreamento por origem; limita a criação de estados
    baseando-se em estados criados apenas por essa regra
<li>Limita o número máximo de nós que podem criar estados
    simultaneamente para 100
<li>Limita o número máximo de estados simultâneos por
    IP de origem para 3
</ul>

<p>
Um conjunto separado de restrições pode ser colocado em conexões TCP,
com o estado mantido, que completaram o aperto de mão triplo
("3-way handshake").

<dl>
<dt><tt>max-src-conn <i>número</i></tt>
<dd>Limita o número máximo de conexões TCP simultâneas, que completaram
o aperto de mão triplo, que uma única máquina pode fazer.
<dt><tt>max-src-conn-rate <i>número</i> / <i>intervalo</i></tt>
<dd>Limita a taxa de novas conexões a uma certa quantidade por
intervalo de tempo.
</dl>

<p>
Ambas as opções chamam automaticamente a opção
<tt>source-track rule</tt> e são incompatíveis com
<tt>source-track global</tt>.

<p>
Uma vez que esses limites são colocados em conexões TCP que completaram
o aperto de mão triplo, ações mais agressivas podem ser tomadas em
endereços IP ofensivos.

<dl>
<dt><tt>overload &lt;<i>tabela</i>&gt;</tt>
<dd>Coloca um endereço IP de uma máquina ofensiva na tabela nomeada.
<dt><tt>flush [global]</tt>
<dd>Mata qualquer outro estado que corresponda à regra e que foi
criado por esse IP de origem.
Quando <tt>global</tt> é especificado, mata todos os estados que
correspondam a esse IP de origem, sem levar em consideração qual regra
criou o estado.
</dl>

<p>
Um exemplo:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Isso faz o seguinte:

<ul>
<li>Limita o número máximo de conexões por origem para 100
<li>Limita a taxa de número de conexões para 15, em medições de
    5 segundos
<li>Coloca o endereço IP de qualquer máquina que quebre esses limites na
    tabela <tt>&lt;abusive_hosts&gt;</tt>
<li>Para qualquer endereço IP ofensivo, libera quaisquer estados criados
    por essa regra.
</ul>

<a name="tcpflags"></a>
<h2>Sinalizadores TCP</h2>
Comparar pacotes TCP com base em seus sinalizadores é geralmente usado
na filtragem de pacotes que tentam abrir novas conexões.
Os sinalizadores TCP e seus significados são listados aqui:
<ul>
<li><b>F</b> : FIN  - "Finish" (Fim); término da sessão
<li><b>S</b> : SYN  - "Synchronize" (Sincronização); indica a requisição
    de conexão
<li><b>R</b> : RST  - "Reset" (Reconfiguração); derruba uma conexão
<li><b>P</b> : PUSH - "Push" (Passar adiante); o pacote é enviado
    imediatamente
<li><b>A</b> : ACK  - "Acknowledgement" (Reconhecimento)
<li><b>U</b> : URG  - "Urgent" (Urgente)
<li><b>E</b> : ECE  - "Explicit Congestion Notification Echo" (Mensagem
    de Notificação de Congestionamento Explícita)
<li><b>W</b> : CWR  - "Congestion Window Reduced" (Janela de
    Congestionamento Reduzida)
</ul>

<p>
Para que o PF inspecione os sinalizadores TCP durante a avaliação de uma
regra, a palavra-chave <tt>flags</tt> é usada com a seguinte sintaxe:
<blockquote>
<tt>
flags <i>a_verificar</i>/<i>máscara</i><br>
flags any
</tt>
</blockquote>

<p>
A parte <tt><i>máscara</i></tt> diz ao PF para verificar apenas os
sinalizadores indicados, e a parte <tt><i>a_verificar</i></tt> informa
o(s) sinalizador(s) que deve(m) estar "ligado(s)" no cabeçalho para que
o pacote corresponda à regra.
O uso da palavra-chave <tt>any</tt> permite que qualquer combinação de
sinalizadores esteja definida no cabeçalho.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA <br>
pass in on fxp0 proto tcp from any to any port ssh
</tt>
</blockquote>

<p>
Como <tt>flags S/SA</tt> é utilizado por padrão, ambas as regras 
são equivalentes. As duas regras acima deixam passar o tráfego TCP 
com a flag SYN habilitada, preocupando-se em checar apenas as 
flags SYN e ACK. Um pacote que tenha as flags SYN e ECE habilitadas 
também cairá nas regras acima, enquanto um pacote com ambas as flags 
habilitadas (SYN+ACK) ou apenas com a flag ACK habilitada não 
corresponderá a nenhuma das regras acima.

<p>
O sinalizador de flags padrão pode ser sobrescrito usando a 
opção <tt>flags</tt> conforme descrito anteriormente.

<p>
Deve-se tomar cuidado ao usar sinalizadores - entenda o que você está
fazendo e o porquê de estar fazendo isso - tenha cuidado com 
conselhos dados pelos outros, pois grande parte deles são incorretos.
Algumas pessoas sugerem a criação de estado 
"somente se o sinalizador SYN estiver marcado, e nenhum outro". 
Fique atento! Se seguir esse conselho, a regra ficaria assim:
<pre>
. . . flags S/FSRPAUEW <i>UMA PÉSSIMA IDÉIA!!!</i>
</pre>

<p>
A teoria é criar estado apenas no início da sessão TCP, e a sessão
deve ser iniciada somente com um sinalizador SYN, e nenhum outro.
O problema é que alguns lugares estão começando a usar o
sinalizador ECN, e qualquer um que use ECN e tente se conectar ao seu
servidor seria rejeitado por essa regra. Uma abordagem muito melhor
seria não especificar sinalizador nenhum e deixar o PF aplicar os
sinalizadores padrão nas suas regras.
Se você realmente necessita de especificar os sinalizadores você mesmo,
então esta combinação seria segura:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
<!--XXX scrub changes may have invalidated this-->
Embora seja prático e seguro, também é totalmente desnecessário verificar os
sinalizadores FIN e RST caso o tráfego passe antes por regras de <tt>scrub</tt>. 
O processo de normalização adotado pelo uso de <tt>scrub</tt> fará com que o 
PF discarte quaisquer combinações ilegais nas flags do protocolo TCP 
(tais como SYN+RST) e normalizará potenciais combinações ambiguas 
(tais como SYN+FIN).

<a name="synproxy"></a>
<h2>Proxy de Pacotes TCP SYN</h2>
<p>
Normalmente quando um cliente inicia uma conexão TCP com o servidor,
o PF transfere os pacotes de
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>aperto de mão ("handshake")</a>
da forma como eles vieram. O PF, porém, possui a habilidade de fazer
proxy no aperto de mão. Com o uso de proxy no aperto de mão, o próprio
PF completa o aperto de mão com o cliente, inicia um aperto de mão com
o servidor, e então transfere pacotes entre os dois.
No caso de um ataque de flood SYN em TCP (jamais ocorrerá o "handshake" 
completo) os pacotes de flood nunca chegarão ao servidor protegido, 
mas clientes verdadeiros que tentem se conectar ao servidor 
terão uma conexão estabelecida normalmente.
Isso minimiza o impacto de floods de SYN em TCP forjados (spoofados) 
destinados ao serviço protegido, tratando dos pacotes diretamente no PF. 
O uso rotineiro desta opção não é recomendado, pois ele quebra o 
comportamento esperado do protocolo TCP quando o servidor não pode 
processar a solicitação e quando existe algum tipo de balanceamento de 
carga relacionado so serviço provido por um determinado servidor.

<p>
O proxy de pacotes TCP SYN é habilitado usando as palavras-chave
<tt>synproxy state</tt> em regras de filtragem. Exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server port www synproxy state
</tt>
</blockquote>

<p>
Aqui as conexões para o servidor Web passarão pelo proxy TCP do PF.

<p>
Pela forma como o <tt>synproxy state</tt> funciona, ele também inclui as
mesmas funcionalidades de <tt>keep state</tt> e <tt>modulate state</tt>.

<p>
O proxy de pacotes SYN não funciona caso o PF esteja atuando em uma
ponte
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>).

<a name="antispoof"></a>
<h2>Bloqueio de Pacotes Falsificados</h2>
"Spoofing" (dissimulação, falsificação) é quando um usuário malicioso
falsifica o endereço IP de origem nos pacotes transmitidos por ele para
esconder seu endereço real ou personificar outro nó na rede. Uma vez
que o usuário tenha falsificado seu endereço, ele pode lançar um ataque
na rede sem que sua verdadeira origem seja descoberta, ou ainda tentar
ganhar acesso a serviços restritos a determinados endereços IP.

<p>
O PF oferece uma proteção contra falsificações através do uso da
palavra-chave <tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>fam_de_end</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Especifica que os pacotes que correspondam à regra devem ser
registrados via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+5.4"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Caso um pacote corresponda à regra, ela é considerada a regra
"vencedora" e a avaliação do conjunto de regras termina.

<dt><tt><i>interface</i></tt>
<dd>A interface de rede onde ativar a proteção contra falsificações.
Pode ser também uma <a href="macros.html#lists">lista</a> de interfaces.

<dt><tt><i>fam_de_end</i></tt>
<dd>A família de endereços onde se deve ativar a proteção
contra falsificações, <tt>inet</tt> para IPv4 ou
<tt>inet6</tt> para IPv6.
</dl>

<p>
Exemplo:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Quando um conjunto de regras é carregado, quaisquer ocorrências da
palavra-chave <tt>antispoof</tt> são expandidas em duas regras de
filtragem.
Assumindo que a interface <tt>fxp0</tt> possui o endereço IP 10.0.0.1 e
a máscara de sub-rede 255.255.255.0 (ou seja, /24), a regra
<tt>antispoof</tt> acima expandiria para:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Essas regras fazem duas coisas:
<ul>
<li>Bloqueia todo tráfego vindo da rede 10.0.0.0/24 que <i>não</i> venha
    por <tt>fxp0</tt>. Como a rede 10.0.0.0/24 está na interface
    <tt>fxp0</tt>, pacotes com endereço de origem nesse bloco de rede
    jamais devem ser vistos em qualquer outra interface.
<li>Bloqueia todo tráfego vindo de 10.0.0.1, o endereço IP em
    <tt>fxp0</tt>. A máquina nunca deve enviar pacotes para ela mesma
    pela interface externa, portanto qualquer pacote chegando com
    endereço de origem da própria máquina deve ser considerado
    malicioso.
</ul>

<p>
<b>NOTA</b>: As regras de filtragem <tt>antispoof</tt> expandidas
também bloquearão pacotes enviados pela interface de loopback para
o endereço local.
Recomenda-se evitar qualquer tipo de filtragem na interface de
loopback, mas isso se torna uma necessidade quando usamos regras
contra falsificações:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
O uso de <tt>antispoof</tt> deve ser restrito à interfaces que possuam
um endereço IP. Usar <tt>antispoof</tt> em uma interface sem um endereço
IP resulta em regras como:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Nessas regras existe o risco de se bloquear <i>todo</i> o tráfego
de entrada em <i>todas</i> as interfaces.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
O PF oferece o recurso de "Unicast Reverse Path Forwarding" (uRPF).
Quando um pacote passa por uma verificação uRPF, o endereço
de origem do pacote é procurado na tabela de roteamento.
Se a interface de saída encontrada na entrada da tabela de roteamento
é a mesma que a interface que o pacote está chegando, então a
verificação uRPF libera a passagem do pacote.
Se as interfaces não correspondem, então é possível que o pacote teve
seu endereço de origem falsificado.

<p>
A verificação uRPF pode ser feita nos pacotes usando a palavra-chave
<tt>urpf-failed</tt> nas regras de filtragem:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Note que a verificação uRPF somente faz sentido em um ambiente onde
as rotas são simétricas.

<p>
uRPF fornece a mesma funcionalidade das regras
<a href="#antispoof">antispoof</a>.

<a name="osfp"></a>
<h2>Detecção Passiva de Sistema Operacional</h2>

<p>
"Passive OS Fingerprinting" (OSFP) é um método para identificar de
maneira passiva o sistema operacional de uma máquina remota com
base em certas características dos pacotes TCP SYN gerados pela máquina.
Essa informação pode então ser usada como critério em regras de
filtragem.

<p>
O PF determina o sistema operacional remoto comparando as
características do pacote TCP SYN contra um
<a href="options.html#fingerprints">arquivo de impressões digitais</a>,
que por padrão é o
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+5.4"
><tt>/etc/pf.os</tt></a>.
Quando o PF está habilitado, a lista atual de impressões digitais pode
ser vista com o comando:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Em uma regra de filtragem, a impressão digital pode ser especificada
pela classe do SO, versão ou subtipo/revisão.
Cada um dos itens é listado na saída do comando <tt>pfctl</tt>
mostrado acima. Para especificar uma impressão digital em uma regra
de filtragem, a palavra-chave <tt>os</tt> é usada:

<blockquote>
<tt>
pass &nbsp;in on $ext_if proto tcp from any os OpenBSD keep state<br>
block in on $ext_if proto tcp from any os "Windows 2000"<br>
block in on $ext_if proto tcp from any os "Linux 2.4 ts"<br>
block in on $ext_if proto tcp from any os unknown
</tt>
</blockquote>

<p>
A classe de sistema operacional <tt>unknown</tt> permite o enquadramento
de pacotes quando a impressão digital do SO não é conhecida.

<p>
<font color="#ff0000">TOME NOTA</font>:
<ul>
  <li>Impressões digitais de sistemas operacionais ocasionalmente
      podem estar erradas, devido à pacotes falsificados e/ou
      trabalhados para que pareçam-se originados de um
      sistema operacional em específico.
  <li>Determinadas revisões ou níveis de correção de um sistema
      operacional podem alterar o comportamento da pilha, fazendo com
      que ela não corresponda à impressão digital do arquivo ou até
      mesmo fique igual a de outro.
  <li>OSFP funciona apenas com pacotes TCP SYN; ele não funciona com
      outros protocolos ou em conexões já estabelecidas.
</ul>

<a name="ipopts"></a>
<h2>Opções IP</h2>
Por padrão, o PF bloqueia pacotes com opções IP definidas. Isso pode
dificultar o trabalho de ferramentas de "detecção de sistema
operacional", como o nmap. Caso você possua algum aplicativo que faça
uso desses pacotes, como multicast ou IGMP, você pode usar a diretiva
<tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Exemplo de Conjunto de Regras de Filtragem</h2>
Abaixo está um exemplo de conjunto de regras de filtragem. A máquina
executando o PF funciona como firewall entre uma pequena rede interna
e a Internet. São mostradas apenas as regras de filtragem; regras de
<a href="queueing.html"><tt>enfileiramento</tt></a>,
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>,
etc., foram deixadas de fora deste exemplo.
<br>
<br>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# Tabela contendo todos os endereços IP atribuídos ao firewall
table &lt;firewall&gt; const { self }

# Não filtra na interface loopback
set skip on lo0

# Faz scrub em pacotes que chegam
match in all scrub (no-df)

# Define a política "negar por padrão"
block all

# Ativa a proteção contra falsificações para todas as interfaces
block in quick from urpf-failed

# Permite conexões ssh vindas apenas da rede interna e se forem
# de um computador confiável, 192.168.0.15. "block return" faz com que
# um pacote TCP RST seja enviado para derrubar conexões bloqueadas.
# "quick" assegura que esta regra não seja invalidada por alguma
# regra "pass" abaixo.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# Permite tráfego indo para e vindo da rede interna.
# Estas regras criam entradas na tabela de estados devido
# à opção padrão "keep state" que é aplicada automaticamente.
pass in  on $int_if from $lan_net
pass out on $int_if to $lan_net

# Permite tráfego tcp, udp e icmp saindo pela interface externa (Internet).
# Conexões tcp serão moduladas, udp/icmp manterão o estado.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# Permite conexões ssh na interface externa contanto que NÃO sejam
# destinadas ao firewall (ou seja, conexões destinadas à máquinas na
# rede local). Registra o pacote inicial para que mais tarde possamos
# saber quem tentou se conectar. 
# Descomente a última parte (synproxy state) para utilizar o synproxy 
# para gerenciar a conexão.
pass in log on $ext_if proto tcp to ! &lt;firewall&gt; \
   port ssh # synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="nat.html">Próximo: Tradução do Endereço de Rede (NAT)</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[voltar]"></a>
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.68 ]<br>
$Translation: filter.html,v 1.19 2013/12/01 12:44:32 egypcio Exp $<br>
-->
$OpenBSD: filter.html,v 1.19 2013/12/06 20:52:46 ajacoutot Exp $
</small>

</body>
</html>
@


1.19
log
@Sync with Steelix CVS
@
text
@d1078 1
a1078 1
$OpenBSD$
@


1.18
log
@Sync with Steelix CVS
@
text
@d72 1
a72 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+5.3"
d132 1
a132 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+5.3"
d810 1
a810 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+5.3"
d941 1
a941 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+5.3"
d1075 2
a1076 2
Originally [OpenBSD: filter.html,v 1.67 ]<br>
$Translation: filter.html,v 1.18 2013/05/02 22:48:46 renato Exp $<br>
@


1.17
log
@Sync with Steelix CVS
@
text
@d72 1
a72 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+5.2"
d132 1
a132 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+5.2"
d810 1
a810 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+5.2"
d941 1
a941 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+5.2"
d1075 2
a1076 2
Originally [OpenBSD: filter.html,v 1.66 ]<br>
$Translation: filter.html,v 1.17 2013/04/03 22:35:05 egypcio Exp $<br>
@


1.16
log
@Sync with Steelix CVS
@
text
@d72 1
a72 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.6"
d132 1
a132 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
d183 1
a183 1
<li>Um bloco de rede <a href="http://public.pacbell.net/dedicated/cidr.html"
d268 2
a269 1
"ligado". No OpenBSD 4.1 e versões recentes, os sinalizadores padrão
d271 1
d277 3
d281 1
a281 2
    No OpenBSD 4.1 e versões recentes, essa opção é o padrão para todas
    as regras de filtragem.
d359 1
a359 1
block in on fxp0 proto tcp from any to any port ssh<br>
d372 1
a372 1
block in quick on fxp0 proto tcp from any to any port ssh<br>
d413 4
a416 5
A partir do OpenBSD 4.1, todas as regras de filtragem criam
automaticamente uma entrada de estado quando um pacote corresponde à
regra.
Em versões antigas do OpenBSD, a regra de filtragem tinha que
usar explicitamente a opção <tt>keep state</tt>.
a417 2
<p>
Exemplo de uso no OpenBSD 4.1 e versões recentes:
d425 6
a430 14
Exemplo de uso no OpenBSD 4.0 e versões anteriores:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Isso permite qualquer tráfego TCP saindo pela interface <tt>fxp0</tt>,
bem como o tráfego retornando em resposta ao firewall. Além do recurso
de manter estado ser uma excelente característica, seu uso ainda
melhora o desempenho do firewall, pois pesquisas na tabela de estados
são muito mais rápidas do que passar o pacote por todas as regras de
filtragem.
d439 4
a442 2
Desde o OpenBSD 3.5, a opção <tt>modulate state</tt> pode ser usada
também em regras que especifiquem protocolos diferentes do TCP.
a480 9

<p>
Perceba que para regras
<a href="nat.html"><tt>nat</tt></a>,
<a href="nat.html#binat"><tt>binat</tt></a> e
<a href="rdr.html"><tt>rdr</tt></a> é implícita
a criação de estados para conexões válidas desde que os pacotes tenham
passado pelo conjunto de regras de filtragem.

d688 2
a689 1
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
d694 7
a700 4
A regra acima autoriza tráfego TCP com o sinalizador SYN definido, mas
verifica somente os sinalizadores SYN e ACK. Um pacote com os
sinalizadores SYN e ECE corresponderia à regra acima, enquanto um pacote
com SYN e ACK ou somente ACK não corresponderia.
d703 2
a704 29
No OpenBSD 4.1 e versões recentes, os sinalizadores aplicados por padrão
nas regras TCP são <tt>flags S/SA</tt>.
Combinando com o padrão do OpenBSD 4.1 de "<tt>keep state</tt>" (manter
o estado) nas regras de filtragem, estas duas regras se tornaram
equivalentes:
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state<br>
pass out on fxp0 proto tcp all
</tt>
</blockquote>

<p>
Cada regra corresponde à pacotes TCP com o sinalizador SYN marcado
e o sinalizador ACK desmarcado, e cada uma cria um estado para os
pacotes que corresponderam.
Os sinalizadores padrão podem ser sobrescritos usando a opção
<tt>flags</tt> conforme descrito acima.

<p>
No OpenBSD 4.0 e versões anteriores, não existiam sinalizadores padrão
aplicados a nenhuma regra de filtragem.
Cada regra tinha que especificar qual(is) sinalizador(es) corresponder,
e também tinha que explicitar o uso da opção <tt>keep state</tt>.
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>
d707 6
a712 5
Deve-se tomar cuidado ao usar sinalizadores -- entenda o que você está
fazendo e o porquê, e tenha cuidado com conselhos dados pelos outros,
pois grande parte deles são incorretos. Algumas pessoas sugerem a
criação de estado "somente se o sinalizador SYN estiver marcado, e
nenhum outro". Essa regra deve ficar assim:
d714 1
a714 1
     . . . flags S/FSRPAUEW  <i>má ideia!!</i>
d734 7
a740 7
Além de ser prático e seguro, também não é necessário verificar os
sinalizadores FIN e RST caso o tráfego passe antes por regras de
<!--XXX scrub-->
scrub. No processo de normalização o PF descarta quaisquer pacotes que
cheguem com combinações de sinalizadores TCP inválidas (como SYN e RST)
e normaliza combinações ambíguas em potencial (como SYN e FIN).

d753 10
a762 5
O benefício desse procedimento é que nenhum pacote é enviado ao servidor
antes do cliente completar o aperto de mão.
Isso evita que ataques de inundação de pacotes TCP SYN falsificados
atinjam o servidor porque uma conexão falsificada não conseguirá
completar o aperto de mão.
d770 1
a770 2
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
d810 1
a810 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
d898 1
a898 2
A partir do <a href="../../../40.html">OpenBSD 4.0</a>, o PF oferece o
recurso de "Unicast Reverse Path Forwarding" (uRPF).
d941 1
a941 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.6"
d961 4
a964 4
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
d1005 1
a1005 1
<a href="queueing.html">enfileiramento</a>,
d1044 2
a1045 2
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net
d1054 5
a1058 5
# saber quem tentou se conectar. Usa o tcp syn proxy nas conexões.
# Os sinalizadores "S/SA" padrão serão aplicados automaticamente na
# regra pelo PF.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh synproxy state
d1075 2
a1076 2
Originally [OpenBSD: filter.html,v 1.53 ]<br>
$Translation: filter.html,v 1.16 2009/11/30 09:29:57 alan Exp $<br>
@


1.15
log
@Sync with Steelix CVS
@
text
@d471 1
a471 1
<tt>if-bound</tt>, <tt>group-bound</tt> e <tt>floating</tt>.
d1108 2
a1109 2
Originally [OpenBSD: filter.html,v 1.52 ]<br>
$Translation: filter.html,v 1.15 2009/11/12 10:00:47 alan Exp $<br>
@


1.14
log
@Sync with Steelix CVS
@
text
@d159 1
a159 1
<dd>A família de endereço do pacote, <tt>inet</tt> para IPv4 ou
d854 1
a854 1
<dd>A família de endereço onde se deve ativar a proteção
d1109 1
a1109 1
$Translation: filter.html,v 1.14 2009/11/06 15:21:51 alan Exp $<br>
@


1.13
log
@Sync with Steelix CVS
@
text
@d505 1
a505 1
o tempo de espera seja atingido, o registro de estado é eliminado.
d1109 1
a1109 1
$Translation: filter.html,v 1.13 2009/10/18 16:52:52 alan Exp $<br>
@


1.12
log
@Sync with Steelix CVS
@
text
@d72 1
a72 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.5"
d132 1
a132 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.5"
d279 1
a279 1
    Números de Sequência Inicial (ISN, "Initial Sequence Number")
d443 2
a444 2
(ISN, "Initial Sequence Number") de conexões saindo do firewall é
aleatório. Isso é útil para proteger conexões iniciadas por certos
d771 5
a775 5
sinalizadores FIN e RST caso o tráfego passe antes por regras
<a href="scrub.html">scrub</a>. No processo de normalização o PF
descarta quaisquer pacotes que cheguem com combinações de sinalizadores
TCP inválidas (como SYN e RST) e normaliza combinações ambíguas em
potencial (como SYN e FIN).
d842 1
a842 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.5"
d974 1
a974 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.5"
d1058 1
a1058 1
scrub in all
d1108 2
a1109 2
Originally [OpenBSD: filter.html,v 1.51 ]<br>
$Translation: filter.html,v 1.12 2009/10/13 19:12:27 alan Exp $<br>
@


1.11
log
@Sync with Steelix CVS
@
text
@d40 1
a40 1
[<a href="nat.html">Próximo: Tradução do Endereço de Rede ("NAT")</a>]
d51 2
a52 2
<li><a href="#pass">Passando Tráfego</a>
<li><a href="#quick">A Palavra-Chave <tt>quick</tt></a>
d56 3
a58 3
<li><a href="#tcpflags">Flags TCP</a>
<li><a href="#synproxy">TCP SYN Proxy</a>
<li><a href="#antispoof">Bloqueando Pacotes Spoofados</a>
d62 1
a62 1
<li><a href="#example">Exemplo de Arquivo de Regras</a>
d70 1
a70 1
passagem de pacotes de dados, conforme eles atravessam a interface de
d77 1
a77 1
>IPv6</a>) e Camada 4
d86 1
a86 1
destino, porta de origem e destino e protocolo.
d90 11
a100 9
enquadrar e a ação resultante, que pode ser bloqueio ou liberação,
tomada quando o pacote casa com a regra. As regras de filtragem
são avaliadas em sequência, da primeira até a última.
A não ser que o pacote encontre um regra contendo a palavra-chave
<tt>quick</tt>, o mesmo será avaliado por <i>todas</i> as regras de
filtragem antes da ação final ser tomada. A última regra a casar é a
"vencedora" e dita qual ação tomar. Existe um <tt>pass all</tt>
implícito no início das regras de filtragem, que significa que caso o
pacote não case com nenhuma regra a ação resultante será <tt>pass</tt>.
d109 4
a112 4
[<i>af</i>] [proto <i>protocolo</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
d118 2
a119 2
<dd>A ação executada em pacotes que casem com a regra, pode ser
<tt>pass</tt> ou <tt>block</tt>. A ação <tt>pass</tt> irá liberar a
d121 1
a121 1
que a ação <tt>block</tt> reagirá com base na opção
d127 2
a128 2
<dd>A direção em que o pacote está se movendo na interface, pode ser
<tt>in</tt> ou <tt>out</tt>.
d131 1
a131 1
<dd>Especifica que o pacote deve ser logado via
d134 2
a135 2
estabeleceu o estado é logado.
Para logar todos pacotes, use <tt>log (all)</tt>.
d138 3
a140 3
<dd>Se um pacote casar uma regra especificada com <tt>quick</tt>,
então essa regra é considerada final e a <tt><i>ação</i></tt>
especificada é executada.
d148 1
a148 1
Muitos grupos também são criados automaticamente pelo kernel:
d150 3
a152 3
<li>O grupo <tt>egress</tt>, que contém a(s) interface(s) relativa(s)
    à rota padrão.
<li>O grupo da família de interfaces para as interfaces clonadas.
d155 2
a156 2
Fará com que a regra case com qualquer pacote atravessando qualquer
interface <tt>ppp</tt> ou <tt>carp</tt>, respectivamente.
d158 2
a159 2
<dt><tt><i>af</i></tt>
<dd>A família de endereços do pacote, <tt>inet</tt> para IPv4 ou
d170 1
a170 1
<li>Um nome de protocolo válido em
d174 1
a174 1
<li>Um grupo de protocolos utilizando uma
d178 3
a180 3
<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt>
<dd>Os endereços de origem/destino no cabeçalho IP. Endereços podem
ser especificados como:
d182 1
a182 1
<li>Um Endereço IPv4 ou IPv6 simples.
d185 2
a186 2
<li>Um nome de domínio totalmente qualificado, que será resolvido pelo
    DNS quando as regras forem carregadas. Todos os endereços IP
d190 1
a190 1
<li>O nome de uma interface de rede seguido por uma
d194 7
a200 7
<li>O nome de uma interface de rede entre parênteses <tt>( )</tt>. Isso
    informa ao PF para atualizar a regra caso o(s) endereço(s) da
    interface em questão mude(m). Útil em interfaces que obtém seu
    endereço IP via DHCP ou dial-up, pois as outras regras não
    precisarão serem recarregadas toda vez que o endereço mudar.
<li>O nome de uma interface de rede seguido por algum destes
    modificadores:
d206 2
a207 2
    <li><tt>:peer</tt> - substitui o endereço da outra ponta num
        link ponto-a-ponto
d210 6
a215 5
    <dd>Além disso, o modificador <tt>:0</tt> pode ser adicionado a um
    nome de interface ou qualquer um dos modificadores acima para dizer
    ao PF para não incluir aliases de endereços IP na substituição.
    Esses modificadores também podem ser usados quando a interface
    está entre parênteses.
d222 2
a223 2
<li>Qualquer dos apresentados acima, mas negado usando o modificador
    <tt>!</tt> ("not") .
d226 2
a227 2
<li>A palavra-chave <tt>any</tt> indicando todos os endereços
<li>A palavra-chave <tt>all</tt> que é um atalho para <tt>from any to
d231 1
a231 1
<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
d236 1
a236 1
<li>Nome de serviço válido em
d239 1
a239 1
<li>Um grupo de portas usando uma <a href="macros.html#lists">lista</a>
d242 1
a242 1
	<li><tt>!=</tt> (diferente)
d261 9
a269 8
<dt><tt><i>tcp_flags</i></tt>
<dd>Especifica as flags que precisam estar definidas no cabeçalho TCP
quando for usado <tt>proto tcp</tt>. Flags são especificadas na forma:
<tt>flags <i>check</i>/<i>mask</i></tt>. Por exemplo: <tt>flags
S/SA</tt> - instrui o PF a verificar somente as flags S e A (SYN e ACK)
e casar somente se apenas a flag SYN estiver "ligada".
No OpenBSD 4.1 e versões recentes, as flags padrão <tt>S/SA</tt> são
aplicadas em todas as regras de filtragem TCP.
d271 1
a271 1
<dt><tt><i>state</i></tt>
d273 1
a273 1
que casem com a regra.
d279 2
a280 2
    Números de Sequência Inicial (ISNs) seguros para pacotes que casem
    com essa regra.
d282 3
a284 3
    ajudar a proteger servidores contra floods de pacotes SYN TCP
    spoofados. Essa opção inclui a funcionalidade <tt>keep state</tt> e
    <tt>modulate state</tt>.
d294 1
a294 1
configuração das regras.
d297 1
a297 1
Para criar uma política de filtragem negar por padrão, as primeiras
d307 2
a308 2
Isso irá bloquear todo o tráfego em todas interfaces em qualquer
direção, de qualquer lugar para qualquer lugar.
d311 1
a311 1
<h2>Passando Tráfego</h2>
d324 3
a326 4
# Autoriza o tráfego entrando na interface dc0<br>
# vindo da rede local 192.168.0.0/24,<br>
# e indo para a máquina OpenBSD com endereço IP 192.168.0.1.<br>
# Também permite o tráfego de retorno saindo da interface dc0.<br>
d331 4
a334 4
# Autoriza o tráfego TCP chegando em fxp0 e indo para o servidor web<br>
# rodando na máquina OpenBSD. O nome da interface, fxp0, é usado como<br>
# endereço de destino, para que apenas pacotes destinados à<br>
# máquina OpenBSD casem com a regra.<br>
d341 2
a342 2
Como dito anteriormente, cada pacote é avaliado pelas regras de
filtragem de cima para baixo. Por padrão, o pacote é marcado para
d345 3
a347 3
regra que casa "vence".</b>  Mas, há uma exceção à regra: A opção
<tt>quick</tt> numa regra de filtragem tem o efeito de cancelar o
processamento de qualquer outra regra que venha em seguida e executa
d375 3
a377 3
Caso a linha <tt>block</tt> case com a regra, devido ao uso da opção
<tt>quick</tt>, o pacote será bloqueado e o restante das regras serão
ignoradas.
d381 4
a384 5
Uma das características importantes do Packet Filter é
"manter o estado das conexões" ou "stateful inspection". Stateful
inspection é a habilidade do PF em registrar o estado, ou progresso de
uma conexão de rede. Armazenando informações sobre o estado de cada
conexão numa tabela de estados, o PF pode rapidamente determinar se um
d386 2
a387 2
Caso afirmativo, ele passa direto pelo firewall sem ser avaliado pelas
regras.
d391 16
a406 14
incluindo simplicidade na configuração das regras e melhor desempenho
na filtragem de pacotes. O PF pode criar entradas na tabela de estado
para pacotes indo em <i>qualquer</i> direção, o que significa que
regras de filtragem que autorizam o tráfego de retorno não precisam ser
escritas. E, como pacotes que possuem entradas na tabela de estado não
são avaliadas pelas regras, o tempo que o PF gasta no processamento
destes pode ser drasticamente reduzido.

<p>
Quando uma regra cria estado, o primeiro pacote
que casa com a regra cria um "estado" entre o transmissor e o receptor.
Agora, não somente os pacotes do transmissor para o receptor combinam
com a entrada na tabela e passam direto pelas regras, como também as
respostas do receptor.
d410 2
a411 1
automaticamente uma entrada de estado quando um pacote casa com a regra.
d413 1
a413 1
explicitamente usar a opção <tt>keep state</tt>.
d416 1
a416 1
Exemplo usando OpenBSD 4.1 e versões recentes:
d424 1
a424 1
Exemplo usando OpenBSD 4.0 e versões anteriores:
d434 4
a437 4
de manutenção de estado ser uma excelente característica, seu uso ainda
melhora o desempenho do firewall, pois pesquisas na tabela de estado
são muito mais rápidas do que comparar o pacote contra todas as regras
de filtragem.
d442 4
a445 4
<tt>modulate state</tt>, o Número de Sequência Inicial (ISN) de
conexões saindo do firewall é aleatório. Isso é útil para proteger
conexões iniciadas por certos sistemas operacionais que não fazem
um bom trabalho ao escolher ISNs.
d450 1
a450 1
Mantendo estado em pacotes TCP, UDP e ICMP, e modulando ISNs TCP:
d459 1
a459 1
Outra vantagem de manter o estado é que o tráfego ICMP correspondente
d461 4
a464 4
passando através do firewall como "statefully" e chegar uma mensagem
ICMP "source-quench" referenciando essa conexão TCP, ela será
identificada como pertencendo a uma entrada válida na tabela de estado
e passará direto pelo firewall.
d467 5
a471 5
O escopo de uma entrada na tabela de estado é controlado globalmente
pela opção <a href="options.html#state-policy"><tt>state-policy</tt></a>
em tempo de execução, e com base nas regras de estado pelas
palavras-chave <tt>if-bound</tt>, <tt>group-bound</tt> e
<tt>floating</tt>.
d483 2
a484 2
Essa regra define que para um pacote casar com a entrada na tabela de
estado, ele deve estar transitando na interface <tt>fxp0</tt>.
d491 3
a493 3
<a href="rdr.html"><tt>rdr</tt></a>, é implícita
a criação de estados para conexões válidas desde que os pacotes passem
pelas regras de filtragem.
d496 2
a497 2
<h2>Mantendo Estado Para UDP</h2>
Algumas vezes você pode ouvir que, "Não se pode criar estados para
d499 1
a499 1
estado nas conexões!". Enquanto é verdade que uma sessão de
d506 1
a506 1
Valores para esse intervalo podem ser definidos na seção
d513 1
a513 1
da criação de estados.
d518 2
a519 2
<dd>Limita o número máximo de estados que a regra pode criar para
<i>número</i>.
d521 2
a522 2
decaem para casar com a regra até que o número de estados existentes
diminua até um número abaixo do limite.
d536 2
a537 2
           da regra. Somente estados criados por essa regra em
           particular conta para o limite da regra.
d541 3
a543 3
           para <tt>max-src-nodes</tt> e <tt>max-src-states</tt>,
           contudo estados criados por qualquer regra participante
           conta cada limite de regra individualmente.
d546 2
a547 2
ser controlado pela opção
<a href="options.html#limit"><tt>src-nodes</tt> em tempo de execução</a>.
d551 3
a553 3
<tt>max-src-nodes</tt> limitará o número de endereços IP de origem
que podem criar estados simultaneamente.
Essa opção só pode ser usada com uma regra <tt>source-track</tt>.
d557 2
a558 2
<tt>max-src-states</tt> limitará o número de estados simultâneos
que podem ser criados por endereço IP de origem.
d565 1
a565 1
Opções são especificadas dentro de parênteses e imediatamente depois
d567 1
a567 1
<tt>modulate state</tt>, ou <tt>synproxy state</tt>).
d571 2
a572 2
A despeito disso, quando especifica opções stateful, uma das
palavras-chave deve ainda ser usada antes das opções.
d592 2
a593 2
<li>Habilita rastreamento por origem; limita a criação de estados
    baseada em estados criados apenas por essa regra
d601 3
a603 2
Um conjunto separado de restrições pode ser colocado em conexões
TCP stateful que completaram o "3-way handshake".
d607 2
a608 2
<dd>Limita o número máximo de conexões TCP simultâneas que completaram
o "3-way handshake" que um único host pode fazer.
d615 1
a615 1
Ambas as opções invocam automaticamente a opção
d620 3
a622 3
Uma vez que esses limites são colocados em conexões TCP que
completaram o "3-way handshake", ações mais agressivas podem ser
tomadas em endereços IP ofensivos.
d626 1
a626 1
<dd>Coloca um endereço IP de um host ofensivo em uma tabela.
d628 1
a628 1
<dd>Mata qualquer outro estado que case com essa regra e que foi
d630 3
a632 3
Quando <tt>global</tt> é especificado, mata todos os estados que casem
com esse IP de origem, sem levar em consideração qual regra criou o
estado.
d655 3
a657 2
<li>Limita a taxa de número de conexões para 15 em medição de 5 segundos
<li>Coloca o endereço IP de qualquer host que quebre esses limites na
d659 1
a659 1
<li>Para qualquer endereço IP ofensivo, limpa qualquer estado criado
d664 4
a667 4
<h2>Flags TCP</h2>
Comparar pacotes TCP com base em suas flags é geralmente usado na
filtragem de pacotes tentando abrir novas conexões. As flags TCP e
seus significados são listados aqui:
d669 11
a679 9
<li><b>F</b> : FIN  - Finish (Final); término da sessão
<li><b>S</b> : SYN  - Synchronize; indica requisição de conexão
<li><b>R</b> : RST  - Reset; derruba uma conexão
<li><b>P</b> : PUSH - Push; o pacote é enviado imediatamente
<li><b>A</b> : ACK  - Acknowledgement (Reconhecimento)
<li><b>U</b> : URG  - Urgent (Urgente)
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo (Mensagem de
    Notificação de Congestionamento Explícita)
<li><b>W</b> : CWR  - Congestion Window Reduced (Janela de
d684 2
a685 2
Para que o PF inspecione as flags TCP durante a avaliação de uma regra,
a palavra-chave <tt>flags</tt> é usada com a seguinte sintaxe:
d688 1
a688 1
flags <i>check</i>/<i>mask</i><br>
d694 4
a697 3
A parte <tt><i>mask</i></tt> diz ao PF para verificar apenas as flags
indicadas e a parte <tt><i>check</i></tt> informa a(s) flag(s) que devem
estar "ligadas" no cabeçalho para que o pacote case com a regra.
d699 1
a699 1
flags estejam definidas no cabeçalho.
d707 4
a710 4
A regra acima autoriza tráfego TCP com a flag SYN definida, mas verifica
somente as flags SYN e ACK. Um pacote com as flags SYN e ECE casa
com a regra acima, enquanto um pacote com SYN e ACK ou somente ACK não
casa.
d713 5
a717 4
No OpenBSD 4.1 e versões recentes, as flags aplicadas por padrão nas
regras TCP é <tt>flags S/SA</tt>.
Combinando com o padrão do OpenBSD 4.1 de <tt>"manter o estado"</tt> nas
regras de filtragem, estas duas regras se tornaram equivalente:
d726 5
a730 5
Cada regra vai casar pacotes TCP com a flag SYN "definida" e a flag ACK
"limpa" e cada um criará uma entrada de estado para os pacotes que
casaram.
As flags por padrão podem ser sobrescritas usando a opção <tt>flags</tt>
conforme descrito acima.
d733 4
a736 4
No OpenBSD 4.0 e versões anteriores, não existiam flags por padrão
aplicadas a nenhuma regra de filtragem.
Cada regra tinha que especificar a(s) flag(s) para casar e também
tinha que explicitar o uso da opção <tt>keep state</tt>.
d744 5
a748 5
Deve-se tomar cuidado ao usar flags -- entenda o que você está fazendo
e o porquê, e tenha cuidado com conselhos dados pelos outros, pois
grande parte deles são incorretos. Algumas pessoas sugerem a criação de
estado "somente se a flag SYN estiver definida e nenhuma outra". Essa
regra deve ficar assim:
d750 1
a750 1
     . . . flags S/FSRPAUEW  <i>má idéia!!</i>
d754 9
a762 9
A teoria é, crie estado apenas no início da sessão TCP, e a sessão
deve ser iniciada somente com uma flag SYN, nada mais. O problema é que
alguns sites estão começando a usar a flag ECN e qualquer um que use
ECN e tente se conectar ao seu servidor terá os pacotes rejeitados por
essa regra. Uma abordagem muito melhor seria não especificar nenhuma
regra como um todo e deixar o PF aplicar as flags por padrão nas
suas regras.
Se você realmente necessita especificar suas próprias flags, então esta
combinação será segura:
d770 2
a771 2
Além de ser prático e seguro, também não é necessário verificar as
flags FIN e RST caso o tráfego passe antes por regras
d773 3
a775 3
descartará quaisquer pacotes que cheguem com combinações
de flags TCP inválidas (como SYN e RST) e normalizará combinações
ambíguas em potencial (como SYN e FIN).
d779 1
a779 1
<h2>TCP SYN Proxy</h2>
d782 1
a782 1
o PF transfere os pacotes
d784 1
a784 1
>handshake</a>
d786 3
a788 3
proxy no handshake. Com o uso de proxy no handshake, o próprio PF
completará o handshake com o cliente, iniciará um handshake com o
servidor, e então transferirá pacotes entre os dois.
d790 4
a793 3
antes do cliente completar o handshake.
Isso evita que ataques TCP SYN flood spoofados atinjam o servidor
porque uma conexão spoofada não conseguirá completar o handshake.
d796 1
a796 1
O TCP SYN proxy é habilitado usando as palavras-chave
d807 1
a807 1
Aqui, as conexões para o servidor web passarão pelo proxy do PF.
d814 4
a817 3
O SYN proxy não funcionará caso o PF esteja atuando numa
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>.
d820 7
a826 7
<h2>Bloqueando Pacotes Spoofados</h2>
"Spoofing" é quando um usuário malicioso falsifica o endereço IP de
origem nos pacotes transmitidos por ele para esconder seu endereço real
ou personificar outro nó na rede. Uma vez que o usuário tenha spoofado
seu endereço, ele pode lançar um ataque na rede sem que sua verdadeira
origem seja descoberta, ou ainda tentar ganhar acesso a serviços
restritos a determinados endereços IP.
d829 1
a829 1
O PF oferece alguma proteção contra spoofing através do uso da
d834 1
a834 1
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
d840 2
a841 1
<dd>Especifica que, pacotes que casem com a regra devem ser logados via
d846 2
a847 2
<dd>Caso um pacote case com a regra, ela será considerada a regra
"vencedora" e a avaliação das regras terminará.
d850 2
a851 2
<dd>A interface de rede onde ativar a proteção antispoof. Pode ser
também uma <a href="macros.html#lists">lista</a> de interfaces.
d853 4
a856 3
<dt><tt><i>af</i></tt>
<dd>A família de endereçamento onde se deve ativar a proteção
antispoof, <tt>inet</tt> para IPv4 ou <tt>inet6</tt> para IPv6.
d868 6
a873 5
Quando as regras são carregadas, quaisquer ocorrências da palavra
<tt>antispoof</tt> são expandidas em duas regras de filtragem.
Assumindo que a interface <tt>fxp0</tt> possui endereço IP 10.0.0.1 e
máscara de rede 255.255.255.0 (ou seja, /24), a regra <tt>antispoof</tt>
acima será expandida para:
d902 1
a902 1
antispoof:
d913 2
a914 2
endereço IP. Usar <tt>antispoof</tt> numa interface sem um endereço
IP resultará em regras como:
d923 2
a924 2
Nessas regras existe o risco de se bloquear <i>todo</i> tráfego
entrante em <i>todas</i> as interfaces.
d930 9
a938 9
A partir do <a href="../../../40.html">OpenBSD 4.0</a>, o PF oferece a
característica de "Unicast Reverse Path Forwarding" (uRPF).
Quando um pacote passa por uma checagem uRPF, o endereço
de origem do pacote é procurado na tabela de rotas.
Se a interface de saída encontrada na entrada da tabela de rotas é a
mesma que a interface que o pacote está chegando, então a checagem
uRPF libera a passagem do pacote.
Se as interfaces não casam, então é possível que o pacote teve seu
endereço de origem spoofado.
d941 1
a941 1
A checagem uRPF pode ser feita nos pacotes usando a palavra-chave
d951 1
a951 1
Note que a checagem uRPF somente faz sentido em um ambiente onde
d962 3
a964 3
Passive OS Fingerprinting (OSFP) é um método para identificar de maneira
passiva o sistema operacional de um host remoto com base em certas
características dos pacotes TCP SYN gerados pelo host.
d972 1
a972 1
que por padrão é
d986 1
a986 1
Numa regra de filtragem, a impressão digital pode ser especificada
d988 2
a989 2
Cada um dos itens é listado como saída do comando <tt>pfctl</tt>
mostrado acima. Para especificar uma impressão digital numa regra
d1009 9
a1017 9
      podem estar erradas, devido a pacotes spoofados e/ou trabalhados
      para que pareçam originados de um sistema operacional em
      específico.
  <li>Determinadas revisões ou patches de um sistema operacional podem
      alterar o comportamento da pilha, fazendo com que ela não
      case com a impressão digital do arquivo ou até mesmo fique
      igual a de outro.
  <li>OSFP funciona apenas com pacotes TCP SYN; não funcionará
      com outros protocolos ou em conexões já estabelecidas.
d1024 2
a1025 2
operacional", como o nmap. Caso possua alguma aplicação que faça uso
desses pacotes, como multicast ou IGMP, você pode usar a diretiva
d1034 5
a1038 5
<h2>Exemplo de Arquivo de Regras</h2>
Abaixo está um arquivo de exemplo para regras de filtragem. A máquina
rodando PF funciona como firewall entre uma pequena rede interna e a
Internet. São mostradas apenas as regras de filtragem;
<a href="queueing.html">queueing</a>,
d1041 1
a1041 1
etc., foram deixadas fora deste exemplo.
d1051 1
a1051 1
# Tabela contendo todos endereços IP atribuídos ao firewall
d1060 1
a1060 1
# Define a política negar por padrão
d1063 1
a1063 1
# Ativa proteção contra spoof para todas as interfaces
d1066 1
a1066 1
# Permite conexões ssh vindas apenas da rede interna, e se for
d1074 3
a1076 3
# Aceita tráfego indo e vindo para a rede interna.
# Estas regras criarão entradas na tabela de estado devido à opção
# padrão "keep state" que será aplicada automaticamente.
d1080 1
a1080 1
# Aceita tcp, udp, e icmp saindo pela interface externa (Internet).
d1086 1
a1086 1
# rede local). Loga os pacotes iniciais para que mais tarde possamos
d1088 2
a1089 2
# As flags "S/SA" padrão serão aplicadas automaticamente na regra
# pelo PF.
d1099 1
a1099 1
[<a href="nat.html">Próximo: Tradução do Endereço de Rede ("NAT")</a>]
d1109 1
a1109 1
$Translation: filter.html,v 1.11 2009/05/10 17:44:16 alan Exp $<br>
@


1.10
log
@Sync with Steelix CVS
@
text
@d72 1
a72 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.4"
d92 1
a92 1
são avaliadas em seqüência, da primeira até a última.
d130 1
a130 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.4"
d154 1
a154 1
interface <tt>ppp</tt> ou <tt>carp</tt> respectivamente.
d180 1
a180 1
<li>Um endereço IPv4 ou IPv6 simples.
d189 3
a191 3
    <tt>/<i>máscara</i></tt> (i.e., <tt>/24</tt>). Cada endereço IP na
    interface é combinado com a máscara para formar um bloco de rede CIDR
    que será substituído na regra.
d200 1
a200 1
    <li><tt>:network</tt> - substitui o bloco de rede CIDR (ex.,
d203 1
a203 1
        (ex., 192.168.0.255)
d275 1
a275 1
    Números de Seqüência Inicial (ISNs) seguros para pacotes que casem
d313 1
a313 1
possível. Isso é para nos certificarmos de que o tráfego válido e
d437 1
a437 1
<tt>modulate state</tt>, o Número de Seqüência Inicial (ISN) de
d445 1
a445 1
Mantendo estado em pacotes TCP, UDP, ICMP e modulando ISNs TCP:
d554 2
a555 2
O escopo desse limite (i.e., estados criados por somente essa regra ou
estados criados por todas as regras que usam  <tt>source-track</tt>)
d828 1
a828 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.4"
d856 1
a856 1
máscara de rede 255.255.255.0 (i.e. /24), a regra <tt>antispoof</tt>
d958 1
a958 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.4"
d1069 3
a1071 3
# destinadas ao firewall (ex., conexões destinadas à máquinas na rede
# local). Loga os pacotes iniciais para que mais tarde possamos saber
# quem tentou se conectar. Usa o tcp syn proxy nas conexões.
d1092 2
a1093 2
Originally [OpenBSD: filter.html,v 1.50 ]<br>
$Translation: filter.html,v 1.10 2009/03/11 00:52:55 dsantos Exp $<br>
@


1.9
log
@Sync with Steelix CVS
@
text
@d8 3
a10 3
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq,pf">
<meta name="distribution" content="global">
a29 1

d39 2
a40 2
[<a href="index.html">Conte&uacute;do</a>]
[<a href="nat.html">Pr&oacute;ximo: Tradu&ccedil;&atilde;o do Endere&ccedil;o de Rede (NAT)</a>]
d46 1
a46 1
<h3>Conte&uacute;do</h3>
d48 1
a48 1
<li><a href="#intro">Introdu&ccedil;&atilde;o</a>
d50 2
a51 2
<li><a href="#defdeny">Negar por Padr&atilde;o</a>
<li><a href="#pass">Passando Tr&aacute;fego</a>
d55 1
a55 1
<li><a href="#stateopts">Op&ccedil;&otilde;es de Rastreamento de Estado</a>
d59 3
a61 3
<li><a href="#urpf">Encaminhamento Unicast Reverso</a>
<li><a href="#osfp">Detec&ccedil;&atilde;o Passiva de Sistema Operacional</a>
<li><a href="#ipopts">Op&ccedil;&otilde;es IP</a>
d68 9
a76 12
<h2>Introdu&ccedil;&atilde;o</h2>
Filtragem de pacotes &eacute; o bloqueio ou libera&ccedil;&atilde;o da passagem 
de pacotes de dados de maneira seletiva, conforme eles atravessam 
a interface de rede. O crit&eacute;rio usado pelo 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.2"
>pf(4)</a> ao inspecionar pacotes s&atilde;o baseados nos cabe&ccedil;alhos da Camada 3 
(<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> e 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
d78 1
a78 2
(<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
d80 1
a80 2
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
d82 17
a98 20
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a>, e
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>). Os crit&eacute;rios mais usados s&atilde;o endere&ccedil;o de origem e destino, 
porta de origem e destino e protocolo.

<p>
Regras de filtragem especificam o crit&eacute;rio em que o pacote deve se 
enquadrar e a a&ccedil;&atilde;o resultante, que pode ser bloqueio ou libera&ccedil;&atilde;o, 
tomada quando o pacote casa com a regra. As regras de filtragem 
s&atilde;o avaliadas em sequ&ecirc;ncia da primeira a &uacute;ltima.
A n&atilde;o ser que o pacote encontre um regra contendo a palavra-chave 
<tt>quick</tt>, o mesmo ser&aacute; avaliado contra <i>todas</i> as regras de
filtragem antes da a&ccedil;&atilde;o final ser tomada. A &uacute;ltima regra a casar &eacute; a 
"vencedora" e dita qual a&ccedil;&atilde;o tomar. Existe um 
<tt>pass all</tt> impl&iacute;cito no in&iacute;cio das regras de 
filtragem, que significa que caso o pacote n&atilde;o case com nenhuma regra 
a a&ccedil;&atilde;o resultante ser&aacute; <tt>pass</tt>.
d102 2
a103 1
A forma geral <i>simplificada</i> da sintaxe para regras de filtragem &eacute;:
d106 1
a106 1
<i>a&ccedil;&atilde;o</i> [<i>dire&ccedil;&atilde;o</i>] [log] [quick] [on <i>interface</i>]
d108 1
a108 1
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to 
d115 8
a122 8
<dt><tt><i>a&ccedil;&atilde;o</i></tt>
<dd>A a&ccedil;&atilde;o executada em pacotes que combinem com a regra, pode ser
<tt>pass</tt> ou <tt>block</tt>. A a&ccedil;&atilde;o <tt>pass</tt> libera a passagem do 
pacote para processamento posterior pelo kernel, enquanto que a a&ccedil;&atilde;o 
<tt>block</tt> reagir&aacute; com base na op&ccedil;&atilde;o
<a href="options.html#block-policy"><tt>block-policy</tt></a>. 
A rea&ccedil;&atilde;o padr&atilde;o pode ser sobrescrita especificando 
<tt>block drop</tt> ou <tt>block return</tt> na regra.
d124 2
a125 2
<dt><tt><i>dire&ccedil;&atilde;o</i></tt>
<dd>A dire&ccedil;&atilde;o em que o pacote est&aacute; se movendo na interface, pode ser 
d130 3
a132 4
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.2"
>pflogd(8)</a>. Caso a regra crie estados ent&atilde;o somente o pacote que estabelece 
a conex&atilde;o &eacute; logado.
d136 3
a138 3
<dd>Se um pacote casar com uma regra que especifique a palavra <tt>quick</tt>,
esta regra &eacute; considerada final e a <tt><i>a&ccedil;&atilde;o</i></tt> especificada 
&eacute; executada.
d141 2
a142 2
<dd>O nome ou grupo da interface de rede onde o pacote passa.
Interfaces podem ser adicionadas aos grupos usando o comando
d146 1
a146 2
V&aacute;rios grupos tamb&eacute;m s&atilde;o criados automatiamente pelo
kernel:
d148 4
a151 4
<li>O grupo <tt>egress</tt>, que cont&eacute;m a(s) interface(s) que
possui(em) a(s) rota(s) default.
<li>Grupo da fam&iacute;lia de interfaces clonadas.
Por exemplo: <tt>ppp</tt> ou <tt>carp</tt>.
d153 2
a154 2
Far&aacute; com que a regra case com qualquer pacote atravessando qualquer 
interface <tt>ppp</tt> ou <tt>carp</tt> respectivamente. 
d157 3
a159 3
<dd>A fam&iacute;lia de endere&ccedil;os a que o pacote pertence, <tt>inet</tt> 
para IPv4 ou <tt>inet6</tt> para IPv6. Geralmente o PF pode determinar essa 
informa&ccedil;&atilde;o com base no(s) endere&ccedil;o(os) de origem e/ou destino do pacote.
d162 1
a162 1
<dd>O protocolo de Camada 4 do pacote:
d168 6
a173 5
<li>Um nome de protocolo v&aacute;lido em 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"><tt>/etc/protocols</tt></a>
<li>Um n&uacute;mero de protocolo entre 0 e 255
<li>Um grupo de protocolos utilizando uma <a href="macros.html#lists">lista</a>.
d176 3
a178 3
<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>Os endere&ccedil;os de origem/destino no cabe&ccedil;alho do IP. Endere&ccedil;os podem ser 
especificados como:
d180 35
a214 33
<li>Endere&ccedil;o IPv4 ou IPv6 simples.
<li>Um bloco de rede <a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<li>Nome de dom&iacute;nio totalmente qualificado, que ser&aacute; resolvido pelo DNS 
quando as regras forem carregadas. Todos endere&ccedil;os IP resultantes ser&atilde;o 
substitu&iacute;dos na regra.
<li>O nome de uma interface de rede ou grupo. 
Quaisquer endere&ccedil;os IP na interface substituir&atilde;o a regra.
<li>O nome de uma interface de rede seguido por uma 
<tt>/<i>m&aacute;scara</i></tt> (ex., <tt>/24</tt>). Cada endere&ccedil;o IP na interface 
&eacute; combinado com a m&aacute;scara para formar um bloco de rede CIDR que ser&aacute; 
substitu&iacute;do na regra.
<li>O nome de uma interface de rede ou grupo entre par&ecirc;nteses <tt>( )</tt>. 
Isto informa ao PF para atualizar a regra caso o endere&ccedil;o(os) da interface sofra 
altera&ccedil;&atilde;o. &Uacute;til em interfaces que obt&eacute;m seu endere&ccedil;o IP 
via DHCP ou dial-up, pois as outras regras n&atilde;o precisar&atilde;o ser recarregadas toda 
vez que o endere&ccedil;o mudar.
<li>O nome de uma interface de rede seguido por algum dos modificadores:
  <ul>
  <li><tt>:network</tt> - substitui o bloco de rede CIDR (ex.,
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - substitui o endere&ccedil;o de broadcast
  (ex., 192.168.0.255)
  <li><tt>:peer</tt> - substitui o endere&ccedil;o da outra ponta num link 
  ponto-a-ponto 
  </ul>
  <dl>
  <dd>Al&eacute;m disso, o modificador <tt>:0</tt> pode ser adicionado a um nome 
  de interface ou qualquer um dos modificadores acima para indicar ao PF 
  para n&atilde;o incluir endere&ccedil;os IP de aliases na substitui&ccedil;&atilde;o.
  Estes modificadores tamb&eacute;m podem ser usados quando o nome da interface 
  est&aacute; entre par&ecirc;nteses.
  Exemplo: <tt>fxp0:network:0</tt>
  </dl>
d216 10
a225 8
<li>A palavra-chave <tt>urpf-failed</tt> pode ser usada para endere&ccedil;os
de origem para indicar que devem passar pelo
<a href="#urpf">uRPF</a>.
<li>Qualquer dos apresentados acima, negado usando o modificador <tt>!</tt> ("not") .
<li>Um grupo de endere&ccedil;os usando-se uma <a href="macros.html#lists">lista</a>.
<li>A palavra-chave <tt>any</tt> indicando todos os endere&ccedil;os
<li>A palavra-chave <tt>all</tt> que &eacute; um atalho para <tt>from any to
any</tt>.
d229 1
a229 1
<dd>A porta de origem/destino no cabe&ccedil;alho da Camada 4 do pacote. Portas 
d232 5
a236 5
<li>Um n&uacute;mero entre 1 e 65535
<li>Nome de servi&ccedil;o v&aacute;lido em 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"><tt>/etc/services</tt></a>
<li>Lista de portas usando uma <a href="macros.html#lists">lista</a>
d247 2
a248 2
	<dd>Os dois &uacute;ltimo s&atilde;o operadores bin&aacute;rios (recebem dois argumentos) 
	e n&atilde;o incluem os argumentos na faixa.
d252 1
a252 1
	<dd>O operador de faixa inclusiva tamb&eacute;m &eacute; um operador bin&aacute;rio
d259 2
a260 2
<dd>Especifica os flags que devem estar setados no cabe&ccedil;alho 
TCP quando for usado <tt>proto tcp</tt>. Flags s&atilde;o especificados na forma: 
d262 4
a265 4
S/SA</tt> - instrui o PF a verificar somente os flags S e A (SYN e ACK)
e casar, se apenas o flag SYN estiver "setado".
No OpenBSD 4.1 e posteriores, a flag padr&atilde;o <tt>S/SA</tt> &eacute;
aplicada a todas as regras de filtragem TCP.
d268 1
a268 1
<dd>Especifica se a informa&ccedil;&atilde;o de estado deve ser mantida em pacotes 
d271 10
a280 11
<li><tt>keep state</tt> - funciona com TCP, UDP, e ICMP.
No OpenBSD 4.1 e posteriores, esta op&ccedil;&atilde;o &eacute; o padr&atilde;o
para todas as regras de filtragem.
<li><tt>modulate state</tt> - funciona apenas com TCP. PF ir&aacute; gerar 
N&uacute;meros de Sequ&ecirc;ncia Inicial (ISNs) seguros para pacotes que combinem 
com esta regra.
<li><tt>synproxy state</tt> - faz proxy de pedidos de conex&atilde;o TCP 
para ajudar a proteger servidores contra floods de pacotes SYN TCP 
spoofados.
Essa op&ccedil;&atilde;o inclui a funcionalidade <tt>keep state</tt> e
<tt>modulate state</tt>.
d285 6
a290 6
<h2>Negar por Padr&atilde;o</h2>
A pr&aacute;tica recomendada ao configurar um firewall &eacute; usar uma pol&iacute;tica
"negar por padr&atilde;o". Isto &eacute;, bloquear <i>tudo</i>, e depois ir permitindo 
certos tipos de tr&aacute;fego atrav&eacute;s do firewall. Esta &eacute; a abordagem 
recomendada por ser mais cautelosa, al&eacute;m de facilitar a configura&ccedil;&atilde;o
das regras.
d293 2
a294 2
Para criar uma pol&iacute;tica de filtragem negar por padr&atilde;o, as primeiras duas regras de 
filtragem devem ser:
d303 2
a304 2
Isto ir&aacute; bloquear todo o tr&aacute;fego em todas interfaces em qualquer 
dire&ccedil;&atilde;o, de qualquer lugar para qualquer lugar.
d307 8
a314 8
<h2>Passando Tr&aacute;fego</h2>
O tr&aacute;fego agora deve ser explicitamente permitido ou ser&aacute; barrado pela
pol&iacute;tica padr&atilde;o do firewall. &Eacute; aqui que os crit&eacute;rios de 
filtragem como porta de origem/destino, endere&ccedil;o de origem/destino e protocolo entram 
em cena. Sempre que o tr&aacute;fego tiver permiss&atilde;o de cruzar o firewall as 
regras devem ser escritas da maneira mais restritiva poss&iacute;vel. Isso &eacute; 
para nos certificarmos de que o tr&aacute;fego v&aacute;lido, e, somente tr&aacute;fego 
v&aacute;lido ter&aacute; permiss&atilde;o de passagem.
d320 4
a323 3
# Autoriza passagem de tr&aacute;fego chegando em dc0 vindo da rede local 192.168.0.0/24,<br>
# e indo para a m&aacute;quina OpenBSD com endere&ccedil;o IP 192.168.0.1. Tamb&eacute;m permite<br>
# tr&aacute;fego de retorno saindo via dc0.<br>
d328 4
a331 4
# Permite tr&aacute;fego TCP chegando em fxp0 e indo para o servidor web<br>
# rodando na m&aacute;quina OpenBSD. O nome da interface, fxp0, &eacute; usado como<br>
# endere&ccedil;o de destino, para que apenas pacotes destinados &agrave;<br>
# m&aacute;quina OpenBSD casem com a regra.<br>
d338 8
a345 7
Como dito anteriormente, cada pacote &eacute; avaliado contra as regras de 
filtragem de cima para baixo.  Por padr&atilde;o, o pacote &eacute; marcado para passagem, 
o que pode ser alterado por qualquer regra, e depois alterado novamente 
v&aacute;rias vezes antes do fim das regras de filtragem. <b>A &uacute;ltima regra que casa 
"vence".</b>  Mas, h&aacute; uma excess&atilde;o &agrave; regra: A op&ccedil;&atilde;o 
<tt>quick</tt> numa regra de filtragem tem o efeito de cancelar o processamento de qualquer 
outra regra que venha em seguida e executa imediatamente a a&ccedil;&atilde;o especificada. 
d358 2
a359 2
Neste caso, a linha <tt>block</tt> ser&aacute; avaliada, mas jamais ter&aacute; efeito 
algum, pois &eacute; seguida de uma linha que permite a passagem de tudo.
d371 3
a373 3
Essas regras s&atilde;o avaliadas de maneira ligeiramente diferente. 
Caso a linha <tt>block</tt> case com a regra, devido o uso da op&ccedil;&atilde;o
<tt>quick</tt>, o pacote ser&aacute; bloqueado, e o restante das regras ser&atilde;o 
d378 7
a384 7
Uma das caracter&iacute;sticas importantes do Packet Filter &eacute;  
"manter o estado das conex&otilde;es", ou "stateful inspection". Stateful
inspection &eacute; a habilidate do PF em registrar o estado, ou progresso de uma 
conex&atilde;o de rede. Armazenando informa&ccedil;&otilde;es sobre o estado de cada 
conex&atilde;o numa tabela, o PF pode rapidamente determinar se um pacote 
passando pelo firewall pertence a uma conex&atilde;o j&aacute; estabelecida. Caso 
afirmativo, ele passa direto pelo firewall sem ser avaliado pelas 
d388 8
a395 8
Manter informa&ccedil;&otilde;es de estado das conex&otilde;es traz muitas vantagens incluindo 
simplicidade na configura&ccedil;&atilde;o das regras e melhor performance na filtragem 
de pacotes. O PF pode criar entradas na tabela de estado para pacotes 
indo em <i>qualquer</i> dire&ccedil;&atilde;o, o que significa que regras de filtragem 
que autorizam o tr&aacute;fego de retorno n&atilde;o precisam ser escritas. E, como 
pacotes que possuem entradas na tabela de estado n&atilde;o s&atilde;o avaliados pelas 
regras, o tempo que o PF gasta no processamento destes pode ser drasticamente 
reduzido.
d398 4
a401 4
Quando uma regra cria estados, o primeiro pacote 
que casa com a regra cria um "estado" entre transmissor e receptor.
Agora, n&atilde;o somente os pacotes do transmissor para o receptor combinam 
com a entrada na tabela e passam direto pelas regras, como tamb&eacute;m as 
d405 4
a408 5
A partir do OpenBSD 4.1, todas as regras de filtragem automaticamente
criam um estado quando um pacote combinar com a regra.
Nas vers&otilde;es anteriores do OpenBSD a regra de filtragem precisava
explicitamente usar a op&ccedil;&atilde;o
<tt>keep state</tt>.
d411 1
a411 1
Exemplo usando OpenBSD 4.1 e posteriores:
d419 1
a419 1
Exemplo ussando OpenBSD 4.0 e anteriores:
d427 5
a431 5
Estas regrais permitem qualquer tr&aacute;fego TCP saindo pela interface <tt>fxp0</tt>, 
bem como o tr&aacute;fego retornando em resposta ao firewall. Al&eacute;m do recurso 
de manuten&ccedil;&atilde;o de estado ser uma excelente caracter&iacute;stica, seu uso ainda
melhora a performance do firewall, pois pesquisas na tabela de estado 
s&atilde;o muito mais r&aacute;pidas do que comparar o pacote contra todas as regras
d435 5
a439 5
A op&ccedil;&atilde;o <tt>modulate state</tt> funciona como a <tt>keep state</tt>
exceto que ela se aplica apenas a pacotes TCP. Com <tt>modulate state</tt>,
o N&uacute;mero de Sequ&ecirc;ncia Inicial (ISN) de conex&otilde;es saindo do 
firewall &eacute; aleat&oacute;rio. Isso &eacute; &uacute;til para proteger 
conex&otilde;es iniciadas por certos sistemas operacionais que n&atilde;o fazem 
d441 2
a442 2
Desde o OpenBSD 3.5, a op&ccedil;&atilde;o <tt>modulate state</tt> pode ser usada 
tamb&eacute;m em regras que especifiquem protocolos diferentes do TCP.
d445 1
a445 1
Mantendo estado em pacotes TCP, UDP e ICMP e modulanto ISNs TCP:
d454 6
a459 6
Outra vantagem de manter o estado &eacute; que o tr&aacute;fego ICMP correspondente 
tamb&eacute;m passa pelo firewall. 
Por exemplo, se uma conex&atilde;o TCP passando pelo firewall for rastreada
como stateful e chegar uma mensagem ICMP source-quench
referenciando esta conex&atilde;o, ela ser&aacute; identificada como pertencendo a 
uma entrada v&aacute;lida na tabela de estado e passar&aacute; direto pelo firewall.
d462 7
a468 6
O escopo de uma entrada na tabela de estado &eacute; controlado globalmente 
pela op&ccedil;&atilde;o <a href="options.html#state-policy"><tt>state-policy</tt></a>
em tempo de execu&ccedil;&atilde;o, e com base nas regras de estado pelas palavras-chave 
<tt>if-bound</tt>, <tt>group-bound</tt> e <tt>floating</tt>.
Essas palavras-chave usadas nas regras tem o mesmo efeito de  
quando s&atilde;o usadas na op&ccedil;&atilde;o <tt>state-policy</tt>. Exemplo:
d478 1
a478 1
Essa regra define que para um pacote casar com a entrada na tabela de 
d483 2
a484 2
Perceba que para regras 
<a href="nat.html"><tt>nat</tt></a>, 
d486 3
a488 3
<a href="rdr.html"><tt>rdr</tt></a> &eacute; impl&iacute;cita 
a cria&ccedil;&atilde;o de estados para conex&otilde;es v&aacute;lidas desde que os 
pacotes passem pelas regras de filtragem.
d492 11
a502 11
Algumas vezes voc&ecirc; pode ouvir que, "N&atilde;o se pode criar estados para 
conex&otilde;es UDP, pelo fato do UDP ser um protocolo que n&atilde;o mant&eacute;m o 
estado nas conex&otilde;es!". Enquanto &eacute; verdade que uma sess&atilde;o de 
comunica&ccedil;&atilde;o UDP n&atilde;o possui nenhum conceito de estado (um in&iacute;cio e fim 
expl&iacute;cito na comunica&ccedil;&atilde;o), isso n&atilde;o causa nenhum impacto na habilidade 
do PF em criar estados para sess&otilde;es UDP.  No caso de protocolos sem 
pacotes de "in&iacute;cio" e "fim", o PF simplesmente mant&eacute;m um registro do 
tempo desde a &uacute;ltima ocorr&ecirc;ncia de um pacote para dada conex&atilde;o.  Caso 
o tempo de espera seja atingido, o registro de estado &eacute; eliminado. 
Valores para esse intervalo podem ser definidos n&atilde;o se&ccedil;&atilde;o
<a href="options.html">op&ccedil;&otilde;es</a> do arquivo <tt>pf.conf</tt> .
d505 5
a509 5
<h2>Op&ccedil;&otilde;es de Rastreamento de Estado</h2>
Regras de filtragem que criam estados podem especificar varias
op&ccedil;&otilde;es para controlar o comportamento da tabela de estados
resultante.
As seguintes op&ccedil;&otilde;es est&atilde;o dispon&iacute;veis:
d512 6
a517 6
<dt><tt>max <i>n&uacute;mero</i></tt>
<dd>Limita o n&uacute;mero m&aacute;ximo de estados que a regra pode criar para
<i>n&uacute;mero</i>.
Se o m&aacute;ximo for alcan&ccedil;ado, pacotes que normalmente criariam
estados s&atilde;o descartados at&eacute; que o n&uacute;mero de estados
existentes diminua.
d520 3
a522 2
<dd>Evita que a regra crie estados automaticamente.
 
d524 3
a526 3
<dd>Esta op&ccedil;&atilde;o habilita o rastreamento do n&uacute;mero 
de estados criados por endere&ccedil;o IP de origem.
Esta op&ccedil;&atilde;o tem dois formatos: 
d528 11
a538 11
       <li><tt>source-track rule</tt> - O n&uacute;mero m&aacute;ximo de
       estados criados por esta regra &eacute; limitado pelas 
       op&ccedil;&otilde;es <tt>max-src-nodes</tt> e <tt>max-src-states</tt> 
       da regra. Somente estados criados por esta regra em particular
       conta para o limite da regra. 
       <li><tt>source-track global</tt> - O n&uacute;mero de estados
       criados por todas as regras que usam esta op&ccedil;&atilde;o &eacute;
       limitado. Cada regra pode especificar diferentes op&ccedil;&otilde;es
       para <tt>max-src-nodes</tt> e <tt>max-src-states</tt>, contudo estados
       criados por qualquer regra participante conta cada limite de regra
       individualmente. 
d540 17
a556 18
O n&uacute;mero total de endere&ccedil;os IP de origem rastreados globalmente
podem ser controlados pela op&ccedil;&atilde;o 
<a href="options.html#limit"><tt>src-nodes</tt> em tempo de execu&ccedil;&atilde;o</a>.

<dt><tt>max-src-nodes <i>n&uacute;mero</i></tt>
<dd>Quando op&ccedil;&atilde;o <tt>source-track</tt> &eacute; usada,
<tt>max-src-nodes</tt> limitar&aacute; o n&uacute;mero de endere&ccedil;os 
IP de origem que podem criar estados simult&acirc;neamente.
Esta op&ccedil;&atilde;o s&oacute; pode ser usada com  
<tt>source-track rule</tt>.

<dt><tt>max-src-states <i>n&uacute;mero</i></tt>
<dd>Quanto a op&ccedil;&atilde;o <tt>source-track</tt> &eacute; usada,
<tt>max-src-states</tt> limitar&aacute; o n&uacute;mero de estados
simult&acirc;neos que podem ser criados por endere&ccedil;os IP de origem. 
O escopo deste limite (ex., somente estados criados por esta regra ou
estados criados por todas a regras que usam  <tt>source-track</tt>)
&eacute; dependente da op&ccedil;&atilde;o <tt>source-track</tt> especificada.
d560 9
a568 8
Op&ccedil;&otilde;es s&atilde;o especificadas dentro de par&ecirc;nteses e
imediatemente depois de uma das palavras-chave
(<tt>keep state</tt>, <tt>modulate state</tt> ou <tt>synproxy state</tt>).
M&uacute;ltiplas op&ccedil;&otilde;es s&atilde;o separadas por virgulas.
No OpenBSD 4.1 e posterior, a opc&atilde;o <tt>keep state</tt> se tornou
padr&atilde;o para todas as regras de filtragem.
Apesar disso, quanto estiver especificando op&ccedil;&otilde;es stateful, uma
das palavras-chave ainda deve ser usada na frente das op&ccedil;&otilde;es
d586 7
a592 6
<li>Limita o n&uacute;mero m&aacute;ximo de estados que esta regra pode criar para 200
<li>Habilita rastreamento por origem; limita a cria&ccedil;&atilde;o de estados baseada em estados criados apenas por esta regra
<li>Limita o n&uacute;mero m&aacute;ximo de n&oacute;s que podem criar
estados simult&acirc;neamente para 100
<li>Limita o n&uacute;mero m&aacute;ximo de estados simult&acirc;neos por
IP de origem para 3
d596 2
a597 2
Um conjunto separado de restri&ccedil;&otilde;es pode ser colodado em
conex&otilde;es TCP stateful que completaram o 3-way handshake.
d600 6
a605 4
<dt><tt>max-src-conn <i>n&uacute;mero</i></tt>
<dd>Limita o n&uacute;mero m&aacute;ximo de conex&otilde;es TCP simult&acirc;neas que completaram o 3-way handshake que um &uacute;nico host pode fazer.
<dt><tt>max-src-conn-rate <i>n&uacute;mero</i> / <i>intervalo</i></tt>
<dd>Limita a taxa de novas conex&otilde;es a uma certa quantidade por intervalo de tempo.
d609 3
a611 2
Ambas as op&ccedil;&otilde;es invocam automaticamente a op&ccedil;&atilde;o
<tt>source-track rule</tt> e s&atilde;o incompat&iacute;veis com <tt>source-track global</tt>. 
d614 3
a616 3
Uma vez que estes limites s&atilde;o colocados em conex&otilde;es TCP que
completaram o 3-way handshake, a&ccedil;&otilde;es mais agressivas
podem ser tomadas em endere&ccedil;os IP ofensivos. 
d620 1
a620 1
<dd>Coloca um endere&ccedil;o IP de um host ofensivo em uma tabela.
d622 5
a626 4
<dd>Mata qualquer outro estado que combine com esta regra e que foi criado
por este IP de origem.
Quando <tt>global</tt> &eacute; especificado, mata todos os estados combinando
este IP de origem, 
d645 1
a645 1
Isto faz o seguinte:
d648 6
a653 4
<li>Limita o n&uacute;mero m&aacute;ximo de conex&otilde;es por origem para 100
<li>Limita a taxa de n&uacute;mero de conex&otilde;es para 15 em medi&ccedil;&atilde;o de 5 segundos
<li>Coloca o endere&ccedil;o IP de qualquer host que quebre estes limites na tabela <tt>&lt;abusive_hosts&gt;</tt>
<li>Para qualquer endere&ccedil;o IP ofensivo, limpa qualquer estado criado por esta regra. 
d658 3
a660 3
Comparar pacotes TCP com base em seus flags &eacute; geralmente usado na 
filtragem de pacotes tentando abrir novas conex&otilde;es. Os flags TCP e 
seu significado s&atilde;o listados aqui:
d662 4
a665 4
<li><b>F</b> : FIN  - Finish (Final); t&eacute;rmino da sess&atilde;o
<li><b>S</b> : SYN  - Synchronize; indica requisi&ccedil;&atilde;o de conex&atilde;o
<li><b>R</b> : RST  - Reset; derruba uma conex&atilde;o
<li><b>P</b> : PUSH - Push; o pacote &eacute; enviado imediatamente
d668 4
a671 3
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo (Mensagem de Notifica&ccedil;&atilde;o 
de Congestionamento Expl&iacute;cita)
<li><b>W</b> : CWR  - Congestion Window Reduced (Janela de Congestionamento Reduzida)
d675 2
a676 2
Para que o PF inspecione os flags TCP durante a avalia&ccedil;&atilde;o de uma regra, 
a palavra-chave <tt>flags</tt> &eacute; usada com a seguinte sintaxe:
d685 5
a689 5
A parte <tt><i>mask</i></tt> diz ao PF para verificar apenas os flags indicados
e a parte <tt><i>check</i></tt> informa qual(is) flag(s) devem estar "setados" no 
cabe&ccedil;alho para que o pacote case com a regra.
Usando a palavra-chave <tt>any</tt> permite que qualquer combina&ccedil;&atilde;o
de flags seja configurada no cabe&ccedil;lho.
d697 4
a700 4
A regra acima autoriza tr&aacute;fego TCP com a flag SYN setada, mas verifica 
somente os flags SYN e ACK. Um pacote com os flags SYN e ECE combinam 
com a regra acima, enquanto um pacote com SYN e ACK ou somente ACK n&atilde;o 
combina.
d703 4
a706 4
No OpenBSD 4.1 e posterior, a flag padr&atilde;o aplicada em regras TCP &eacute; 
<tt>flags S/SA</tt>.
Cobinado com o padr&atilde;o de regras de filtragem <tt>keep state</tt> do OpenBSD 4.1,
estas duas regras s&atilde;o equivalentes:
d715 5
a719 4
Cada regra ir&aacute; combinar com pacotes TCP com a flag SYN configurada e a
flag ACK limpa e criar&aacute; uma entrada na tabela de estados.
A flag padr&atilde;o pode ser substitu&iacute;da usado a op&ccedil;&atilde;o
<tt>flags</tt> como descrito acima.
d722 4
a725 4
No OpenBSD 4.0 e anteriores, n&atilde;o existia uma flag padr&atilde;o aplicada
em todas as regras de filtragem.
Cada regra tinha que especificar qual(ais) flag(s) e tamb&eacute;m tinham que
usar explicitamente a op&ccedil;&atilde;o <tt>keep state</tt>.
d733 7
a739 7
Deve-se tomar cuidado ao usar flags -- entenda o que voc&ecirc; est&aacute; fazendo e o 
porqu&ecirc;, e tenha cuidado com conselhos dados pelos outros, pois grande 
parte deles &eacute; incorreto.  Algumas pessoas sugerem a cria&ccedil;&atilde;o de estado
"somente se o flag SYN estiver setado e nenhum outro". Esta regra deve 
ficar asssim:
<pre>     
     . . . flags S/FSRPAUEW  <i>m&aacute; id&eacute;ia!!</i>
d743 9
a751 9
A  teoria &eacute;, crie estado apenas no in&iacute;cio da sess&atilde;o TCP, e a 
sess&atilde;o deve ser iniciada somente com um flag SYN, nada mais.  O problema &eacute; que 
alguns sites est&atilde;o come&ccedil;ando a usar o flag ECN e qualquer um que use 
ECN e tente se conectar ao seu servidor ter&aacute; os pacotes rejeitados por 
esta regra. 
Uma abordagem muito melhor seria n&atilde;o especificar uma flag e deixar que o
PF aplique a flag padr&atilde;o para suas regras.
Se voc&ecirc; realmente precisa especificar flags ent&atilde;o esta
combina&ccedil;&atilde;o deve ser segura:
d759 6
a764 6
Al&eacute;m de ser pr&aacute;tico e seguro, tamb&eacute;m n&atilde;o &eacute; necess&aacute;rio 
verificar os flags FIN e RST caso o tr&aacute;fego passe antes por regras 
<a href="scrub.html">scrub</a>. No processo de normaliza&ccedil;&atilde;o o PF 
descartar&aacute; quaisquer pacotes que cheguem com combina&ccedil;&otilde;es 
de flags TCP inv&aacute;lidas (como SYN e RST) e normalizar&aacute; 
combina&ccedil;&atilde;oes ambiguas em potencial (como SYN e FIN).
d770 12
a781 13
Normalmente quando um cliente inicia uma conex&atilde;o TCP com o servidor, 
o PF transfere os pacotes do 
<a href=<a
href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>handshake</a> da forma como eles vieram. O PF, por&eacute;m possui a
habilidade de fazer proxy no handshake. 
Com o uso de proxy no handshake, o pr&oacute;prio PF completar&aacute; o handshake 
com o cliente, iniciar&aacute; um handshake com o servidor, e ent&atilde;o 
transferir&aacute; pacotes entre os dois.
O benef&iacute;cio deste procedimento &eacute; que nenhum pacote &eacute; enviado ao servidor 
antes do cliente completar o handshake. 
Isso evita que ataques TCP SYN flood spoofados atinjam o servidor 
porque uma conex&atilde;o spoofada n&atilde;o conseguir&aacute; completar o handshake. 
d784 1
a784 1
O TCP SYN proxy &eacute; habilitado usando as palavras-chave 
d795 1
a795 1
Aqui, as conex&otilde;es para o servidor web passar&atilde;o pelo proxy do PF.
d798 1
a798 1
Pela forma como o <tt>synproxy state</tt> funciona, ele tamb&eacute;m inclui as 
d802 2
a803 3
O SYN proxy n&atilde;o funcionar&aacute; caso o PF esteja atuando numa 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
d808 6
a813 6
"Spoofing" &eacute; quando um usu&aacute;rio malicioso falsifica o endere&ccedil;o IP de origem 
nos pacotes transmitidos por ele para esconder seu endere&ccedil;o real ou
personificar outro n&oacute; na rede. Uma vez que o usu&aacute;rio tenha spoofado seu 
endere&ccedil;o ele pode lan&ccedil;ar um ataque na rede sem que sua verdadeira origem seja 
descoberta, ou ainda tentar ganhar acesso a servi&ccedil;os restritos a determinados
endere&ccedil;os IP.
d816 2
a817 2
O PF oferece alguma prote&ccedil;&atilde;o contra spoofing atrav&eacute;s do uso da palavra-chave
<tt>antispoof</tt>:
d827 2
a828 3
<dd>Especifica que, pacotes combinando com a regra devem ser logados via
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.2"
d832 2
a833 2
<dd>Caso um pacote case com a regra ela ser&aacute; considerada a regra 
"vencedora" e a avalia&ccedil;&atilde;o das regras terminar&aacute;. 
d836 2
a837 2
<dd>A interface de rede onde ativar a prote&ccedil;&atilde;o antispoof. Pode ser
tamb&eacute;m uma <a href="macros.html#lists">lista</a> de interfaces.
d840 1
a840 1
<dd>A fam&iacute;lia de endere&ccedil;amento onde se deve ativar a prote&ccedil;&atilde;o 
d853 5
a857 4
Quando as regras s&atilde;o carregadas, quaisquer ocorr&ecirc;ncias da palavra 
<tt>antispoof</tt> s&atilde;o expandidas em duas regras de filtragem. Assumindo que 
a interface <tt>fxp0</tt> possui endere&ccedil;o IP 10.0.0.1 e m&aacute;scara de rede 
255.255.255.0 (ex. /24), a regra <tt>antispoof</tt> acima ser&aacute; expandida para:
d867 1
a867 1
Estas regras fazem duas coisas:
d869 9
a877 9
<li>Bloqueia todo tr&aacute;fego vindo da rede 10.0.0.0/24 que <i>n&atilde;o</i> venha
por <tt>fxp0</tt>. Como a rede 10.0.0.0/24 est&aacute; na interface <tt>fxp0</tt>, 
pacotes com endere&ccedil;o de origem neste bloco de rede jamais devem ser vistos 
em qualquer outra interface.
<li>Bloqueia todo tr&aacute;fego vindo de 10.0.0.1, o endere&ccedil;o IP 
em <tt>fxp0</tt>.
A m&aacute;quina nunca deve enviar pacotes para ela mesma pela interface externa, 
portanto qualquer pacote chegando com endere&ccedil;o de origem da pr&oacute;pria 
m&aacute;quina deve ser considerado malicioso.
d881 5
a885 6
<b>NOTA</b>: As regras de filtragem <tt>antispoof</tt> expandidas 
tamb&eacute;m ir&atilde;o bloquear pacotes enviados pela interface de 
loopback para 
o endere&ccedil;o local. 
Recomenda-se evitar qualquer tipo de filtragem na interface de 
loopback, mas isto se torna uma necessidade quando usamos regras 
d896 3
a898 3
O uso de <tt>antispoof</tt> deve ser restrito a interfaces que possuam
endere&ccedil;o IP. Usar <tt>antispoof</tt> numa interface sem um 
endere&ccedil;o IP resultar&aacute; em regras como:
d907 1
a907 1
Nestas regras existe o risco de se bloquear <i>todo</i> tr&aacute;fego 
d911 1
a911 1
<h2>Encaminhamento Unicast Reverso</h2>
d914 9
a922 9
A partir do <a href="../../../40.html">OpenBSD 4.0</a>, PF oferece
Encaminhamento Unicast Reverso (uRPF).
Quanto um pacote &eacute; verificado pelo uRPF, o endere&ccedil;o IP de origem
do pacote &eacute; procurado na tabela de roteamento.
Se a interface de sa&iacute;da encontrada na tabela de roteamento &eacute; a
mesma da interface que o pacote entrou, ent&atilde;o a
verifica&ccedil;&atilde;o uRPF passa.
Se a interface n&atilde;o combinar, ent&atilde;o &eacute; poss&iacute;vel que o
pacote tenha seu endere&ccedil;o de origem falsificado (spoofed).
d925 1
a925 1
A verifica&ccedil;&atilde;o uRPF pode ser aplicada aos pacotes usando a palavra-chave
d935 2
a936 2
Note que a verifica&ccedil;&atilde;o uRPF s&oacute; faz sentido em um ambiente
onde o roteamento seja sim&eacute;trico.
d939 1
a939 1
uRPF oferece a mesma funcionalidade que as regras
d942 2
d945 6
a950 2
<a name="osfp"></a>
<h2>Detec&ccedil;&atilde;o Passiva de Sistema Operacional</h2>
d953 9
a961 17
Passive OS Fingerprinting (OSFP) &eacute; um m&eacute;todo para 
identificar de maneira passiva o sistema operacional de um host remoto 
com base em certas caracter&iacute;sticas dos pacotes TCP SYN gerados 
pelo host.
Esta informa&ccedil;&atilde;o pode ent&atilde;o ser usada como
crit&eacute;rio em regras de filtragem.

<p>
O PF determina o sistema operacional remoto comparando as caracter&iacute;sticas 
do pacote TCP SYN contra um 
<a href="options.html#fingerprints">arquivo de impress&otilde;es digitais</a>, que por 
padr&atilde;o &eacute; 
<a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.2"
><tt>/etc/pf.os</tt></a>. 
Quando o PF est&aacute; habilitado, a lista atual de impress&otilde;es digitais pode ser vista 
com o comando:
d970 5
a974 5
Numa regra de filtragem, a impress&atilde;o digital pode ser especificada 
pela classe do SO, vers&atilde;o ou subtipo/revis&atilde;o.
Cada um dos itens &eacute; listado como sa&iacute;da do comando <tt>pfctl</tt> 
mostrado acima. Para especificar uma impress&atilde;o digital numa regra 
de filtragem, a palavra-chave <tt>os</tt> deve ser usada.
d986 2
a987 3
A classe de sistema operacional <tt>unknown</tt> permite o enquadramento 
de pacotes quanto a impress&atilde;o digital do SO n&atilde;o &eacute;
conhecida.
d992 10
a1001 9
  <li>Impress&otilde;es digitais de sistemas operacionais ocasionalmente 
  podem estar erradas, devido a pacotes spoofados e/ou trabalhados 
  para que pare&ccedil;am originados de um sistema operacional em espec&iacute;fico.
  <li>Determinadas revis&otilde;es ou patches de um sistema operacional 
  podem alterar o comportamento da pilha, fazendo com que ela n&atilde;o 
  combine com a impress&atilde;o digital do arquivo ou at&eacute; mesmo fique igual 
  a de outro.
  <li>OSFP funciona apenas com pacotes TCP SYN; n&atilde;o funcionar&aacute; 
  com outros protocolos ou em conex&otilde;es j&aacute; estabelecidas.
d1005 6
a1010 5
<h2>Op&ccedil;&otilde;es IP</h2>
Por padr&atilde;o, o PF bloqueia pacotes com op&ccedil;&otilde;es IP setadas. Isso pode 
dificultar o trabalho de ferramentas de "detec&ccedil;&atilde;o de sistema operacional" 
como nmap. Caso possua alguma aplica&ccedil;&atilde;o que fa&ccedil;a uso destes pacotes, como 
multicast ou IGMP, voc&ecirc; pode usar a diretiva <tt>allow-opts</tt>:
d1019 6
a1024 6
Abaixo est&aacute; um arquivo de exemplo para regras de filtragem. A m&aacute;quina 
rodando PF funciona como firewall entre uma pequena rede interna e a Internet. 
S&atilde;o mostradas apenas as regras de filtragem;
<a href="queueing.html">queueing</a>, 
<a href="nat.html"><tt>nat</tt></a>, 
<a href="rdr.html"><tt>rdr</tt></a>, 
d1035 1
a1035 1
# tabela contendo todos endere&ccedil;os IP atribu&iacute;dos ao firewall
d1038 1
a1038 1
# n&atilde;o filtra na interface loopback
d1041 1
a1041 1
# faz scrub em pacotes que chegam
d1044 1
a1044 1
# define o pol&iacute;tica padr&atilde;o
d1047 1
a1047 1
# ativa prote&ccedil;&atilde;o contra spoof para todas as interfaces
d1050 4
a1053 4
# permite conex&otilde;es ssh vindas apenas da rede interna, e se for 
# de um computador confi&aacute;vel, 192.168.0.15. usa "block return" de 
# forma que um TCP RST &eacute; enviado para derrubar conex&otilde;es bloqueadas.
# usa "quick" para que esta regra n&atilde;o seja invalidada por alguma 
d1056 1
a1056 1
   to $int_if port ssh 
d1058 3
a1060 3
# aceita tr&aacute;fego indo e vindo para a rede interna.
# estas regras criar&atilde;o estados devido a op&ccedil;&atilde;o
# padr&atilde;o "keep state" que ser&aacute; automaticamente aplicada.
d1064 2
a1065 3
# aceita tcp, udp, e icmp saindo pela interface externa (Internet). 
# conex&otilde;es tcp configuradas com modulate, udp/icmp ser&atilde;o
# rastredos de forma stateful.
d1068 5
a1072 5
# permite conex&otilde;es ssh na interface externa contanto que N&Atilde;O sejam 
# destinadas ao firewall (ex., conex&otilde;es destinadas a m&aacute;quinas na rede
# local). loga os pacotes iniciais para que mais tarde possamos saber
# quem tentou se conectar. usa tcp syn proxy nas conex&otilde;es.
# A flag padr&atilde;o "S/SA" ser&aacute; automaticamente aplicada na regra
d1082 2
a1083 2
[<a href="index.html">Conte&uacute;do</a>]
[<a href="nat.html">Pr&oacute;ximo: Tradu&ccedil;&atilde;o do Endere&ccedil;o de Rede (NAT)</a>]
d1092 2
a1093 2
Originally [OpenBSD: filter.html,v 1.47 ]<br>
$Translation: filter.html,v 1.9 2007/11/29 02:01:46 dsantos Exp $<br>
d1095 1
a1095 1
$OpenBSD$ 
@


1.8
log
@sync with steelix translation CVS
@
text
@d14 1
a14 1
Copyright (c) 2003-2005 Joel Knight <enabled@@myrealbox.com>
d60 1
d74 1
a74 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.9"
d77 1
a77 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.9"
d80 1
a80 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.9"
d83 1
a83 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.9"
d86 1
a86 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.9"
d89 1
a89 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.9"
d92 1
a92 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.9"
d139 2
a140 3
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.9"
>pflogd(8)</a>. Caso a regra especifique as op&ccedil;&otilde;es <tt>keep state</tt>,
<tt>modulate state</tt> ou <tt>synproxy state</tt> somente o pacote que estabelece 
d151 12
a162 3
Um grupo de interface &eacute; especificado com o nome da interface mas sem o 
n&uacute;mero no final.
Por exemplo: <tt>ppp</tt> ou <tt>fxp</tt>.
d164 1
a164 1
interface <tt>ppp</tt> ou <tt>fxp</tt> respectivamente. 
d169 1
a169 1
informa&ccedil;&atilde;o com base no endere&ccedil;o(os) de origem e/ou destino do pacote.
d180 1
a180 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.9"><tt>/etc/protocols</tt></a>
d193 3
a195 3
substituidos na regra.
<li>O nome de uma interface de rede. Quaisquer endere&ccedil;os IP na interface 
substituir&atilde;o a regra.
d199 3
a201 3
substituido na regra.
<li>O nome de uma interface de rede entre parenteses <tt>( )</tt>. Isto
informa ao PF para atualizar a regra caso o endere&ccedil;o(os) da interface sofra 
d223 3
d240 1
a240 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.9"><tt>/etc/services</tt></a>
d269 2
d277 2
d402 1
a402 1
Quando uma regra possui a op&ccedil;&atilde;o <tt>keep state</tt>, o primeiro pacote 
d406 19
a424 1
respostas do receptor. Por exemplo:
d432 2
a433 2
Isto permite qualquer tr&aacute;fego TCP saindo pela interface <tt>fxp0</tt>, bem 
como o tr&aacute;fego retornando em resposta ao firewall. Al&eacute;m do recurso 
d460 3
a462 2
tamb&eacute;m passa pelo firewall. Por exemplo, se for especificado 
<tt>keep state</tt> para uma conex&atilde;o TCP e chegar uma mensagem ICMP source-quench
d510 3
a512 5
Quanto uma regra de filtragem cria uma entrada na tabela de estados
atrav&eacute;s do uso de qualquer uma das palavras-chave
<tt>keep state</tt>, <tt>modulate state</tt> ou <tt>synproxy state</tt>,
algumas op&ccedil;&otilde;es podem ser especificadas que controlam
o comportamento da cria&ccedil;&atilde;o de estados.
d523 3
d564 10
d579 1
a579 1
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
d590 1
a590 1
<li>Habilida rastreamento por origem; limita a cria&ccedil;&atilde;o de estados baseada em estados criados apenas por esta regra
d674 2
a675 1
flags <i>check</i>/<i>mask</i>
d681 1
a681 1
e a parte <tt><i>check</i></tt> informa quais flag(s) devem estar "setados" no 
d683 2
d692 1
a692 1
A regra acima autoriza tr&aacute;fego TCP com o flag SYN setado, mas verifica 
d698 4
a701 1
Nota: em vers&otilde;es anteriores do OpenBSD, a sintaxe a seguir era suportada:
d704 2
a705 1
. . . flags S
d710 4
a713 1
Isso n&atilde;o se aplica mais. Agora uma m&aacute;scara <i>sempre</i> deve ser especificada.
d716 4
a719 2
Geralmente os flags s&atilde;o usados em conjunto com regras <tt>keep state</tt> 
para ajudar a controlar a cria&ccedil;&atilde;o de entradas na tabela de estado:
a726 4
Isso permitir&aacute; a cria&ccedil;&atilde;o de estado para todos pacotes TCP saindo 
com o flag SYN setado, na verifica&ccedil;&atilde;o dos flags SYN e ACK.

<p>
d741 5
a745 1
esta regra. Uma abordagem muito melhor seria:
d759 1
a759 12
&Eacute; altamente recomendado sempre usar 
<tt>scrub</tt> para tr&aacute;fego entrante:
<blockquote>
<tt>
scrub in on fxp0<br>
.<br>
.<br>
.<br>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state
</tt>
</blockquote>
d766 4
a769 2
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/connections.html">handshake</a>
da forma como eles vieram. O PF, por&eacute;m possui a habilidade de fazer proxy no handshake.
d799 1
a799 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.9"
d825 1
a825 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.9"
d907 33
d957 1
a957 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+3.9"
d1045 2
a1046 2
# ativa prote&ccedil;&atilde;o contra spoof na interface interna
antispoof quick for $int_if inet
d1054 1
a1054 1
   to $int_if port ssh flags S/SA
d1056 3
a1058 1
# aceita tr&aacute;fego indo e vindo para a rede interna
d1063 3
a1065 3
# mant&eacute;m o estado em udp e icmp e usa modulate state em tcp.
pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state
d1071 2
d1074 1
a1074 1
   port ssh flags S/SA synproxy state
d1091 2
a1092 2
Originally [OpenBSD: filter.html,v 1.36 ]<br>
$Translation: filter.html,v 1.8 2006/05/28 17:23:02 dsantos Exp $<br>
@


1.7
log
@sync with Steelix CVS
@
text
@d73 1
a73 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.8"
d76 1
a76 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.8"
d79 1
a79 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.8"
d82 1
a82 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.8"
d85 1
a85 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.8"
d88 1
a88 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.8"
d91 1
a91 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.8"
d138 1
a138 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.8"
d142 1
a142 1
Para logar todos pacotes, use <tt>log-all</tt>.
d171 1
a171 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.8"><tt>/etc/protocols</tt></a>
d228 1
a228 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.8"><tt>/etc/services</tt></a>
d750 1
a750 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.8"
d776 1
a776 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.8"
d829 6
a834 3
tamb&eacute;m ir&atilde;o bloquear pacotes enviados pela interface de loopback para 
o endere&ccedil;o local. Esses endere&ccedil;os devem ser permitidos explicitamente.
Exemplo:
d837 1
a837 1
pass quick on lo0 all<br>
d845 2
a846 2
endere&ccedil;o IP. Usar <tt>antispoof</tt> numa interface sem um endere&ccedil;o IP 
resultar&aacute; em regras como:
d855 2
a856 2
Nestas regras existe o risco de se bloquear <i>todo</i> tr&aacute;fego entrante 
em <i>todas</i> as interfaces.
d862 6
a867 5
Passive OS Fingerprinting (OSFP) &eacute; um m&eacute;todo para identificar de maneira 
passiva o sistema operacional de um host remoto com base em certas 
caracter&iacute;sticas dos pacotes TCP SYN gerados pelo host.
Esta informa&ccedil;&atilde;o pode ent&atilde;o ser usada como crit&eacute;rio em regras de 
filtragem.
d875 1
a875 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+3.8"
d954 3
d961 1
a961 5
block in  all
block out all

# aceita tr&aacute;fego em qualquer dire&ccedil;&atilde;o na interface de loopback 
pass quick on lo0 all
d1005 2
a1006 2
Originally [OpenBSD: filter.html,v 1.33 ]<br>
$Translation: filter.html,v 1.7 2005/12/22 21:21:45 dsantos Exp $<br>
@


1.6
log
@sync with steelix translation CVS
@
text
@d297 1
a297 1
</p><h2>Passando Tr&aacute;fego</h2>
d439 1
a439 1
</p><blockquote>
d636 1
a636 1
</p><blockquote>
d650 1
a650 1
</p><blockquote>
d1003 1
a1003 1
$Translation: filter.html,v 1.6 2005/11/15 14:36:42 dsantos Exp $<br>
@


1.5
log
@sync with steelix translation CVS
@
text
@d72 2
a73 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.7"
d75 2
a76 1
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.7"
d78 2
a79 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.7"
d81 2
a82 1
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.7"
d84 2
a85 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.7"
d87 2
a88 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.7"
d90 2
a91 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.7"
d137 2
a138 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.7"
d170 2
a171 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.7"><tt>/etc/protocols</tt></a>
d227 2
a228 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.7"><tt>/etc/services</tt></a>
d749 2
a750 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.7"
d775 2
a776 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.7"
d871 1
a871 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+3.7"
d1001 4
a1004 2
Originally [OpenBSD: filter.html,v 1.32 ]<br>
$Translation: filter.html,v 1.5 2005/10/25 23:47:46 dsantos Exp $<br>
@


1.4
log
@sync with Steelix CVS
@
text
@d687 5
a691 4
<a href="scrub.html">scrub</a>. No processo de normaliza&ccedil;&atilde;o o PF descartar&aacute; 
quaisquer pacotes que cheguem com combina&ccedil;&otilde;es de flags TCP 
inv&aacute;lidas (como SYN e FIN ou SYN e RST).
&Eacute; sempre recomendado o uso de 
d989 2
a990 2
Originally [OpenBSD: filter.html,v 1.31 ]<br>
$Translation: filter.html,v 1.4 2005/06/06 13:06:29 dsantos Exp $<br>
@


1.3
log
@Sync with Steelix CVS
@
text
@d14 1
a14 1
Copyright (c) 2003, 2004 Joel Knight <enabled@@myrealbox.com>
d56 1
d72 1
a72 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.6"
d74 1
a74 1
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.6"
d76 1
a76 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.6"
d78 1
a78 1
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
d80 1
a80 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
d82 1
a82 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
d84 1
a84 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.6"
d130 1
a130 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.6"
d162 1
a162 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.6"><tt>/etc/protocols</tt></a>
d218 1
a218 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.6"><tt>/etc/services</tt></a>
d463 133
d738 1
a738 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.6"
d763 1
a763 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.6"
d858 1
a858 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+3.6"
d878 4
a881 4
pass &nbsp;in on $ext_if any os OpenBSD keep state<br>
block in on $ext_if any os "Windows 2000"<br>
block in on $ext_if any os "Linux 2.4 ts"<br>
block in on $ext_if any os unknown
d988 2
a989 2
Originally [OpenBSD: filter.html,v 1.28 ]<br>                                                      
$Translation: filter.html,v 1.3 2005/02/23 03:54:54 dsantos Exp $<br>                 
@


1.2
log
@sync with Steelix CVS
@
text
@d72 1
a72 1
>pf(4)</a> ao inspecionar pacotes &eacute; baseado nos cabe&ccedil;alhos da Camada 3 
d854 2
a855 2
Originally [OpenBSD: filter.html,v 1.27 ]<br>                                                      
$Translation: filter.html,v 1.2 2005/02/05 18:56:18 dsantos Exp $<br>                 
@


1.1
log
@sync with steelix translation CVS
@
text
@d105 4
a108 3
<i>a&ccedil;&atilde;o</i> <i>dire&ccedil;&atilde;o</i> [log] [quick] on <i>interface</i> [<i>af</i>] [proto <i>protocolo</i>] \<br>
&nbsp;&nbsp;&nbsp;from <i>src_addr</i> [port <i>src_port</i>] to 
<i>dst_addr</i> [port <i>dst_port</i>] \<br>
d854 2
a855 2
Originally [OpenBSD: filter.html,v 1.26 ]<br>                                                      
$Translation: filter.html,v 1.1 2005/01/04 17:09:07 dsantos Exp $<br>                 
@

