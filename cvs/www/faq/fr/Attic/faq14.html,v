head	1.90;
access;
symbols;
locks; strict;
comment	@# @;


1.90
date	2014.04.01.17.03.09;	author nick;	state dead;
branches;
next	1.89;

1.89
date	2013.11.11.07.18.59;	author ajacoutot;	state Exp;
branches;
next	1.88;

1.88
date	2013.11.01.18.04.04;	author ajacoutot;	state Exp;
branches;
next	1.87;

1.87
date	2013.10.16.07.49.01;	author ajacoutot;	state Exp;
branches;
next	1.86;

1.86
date	2013.08.29.06.30.40;	author ajacoutot;	state Exp;
branches;
next	1.85;

1.85
date	2013.08.15.15.14.54;	author ajacoutot;	state Exp;
branches;
next	1.84;

1.84
date	2013.07.23.06.21.49;	author ajacoutot;	state Exp;
branches;
next	1.83;

1.83
date	2013.07.15.06.56.19;	author ajacoutot;	state Exp;
branches;
next	1.82;

1.82
date	2013.05.12.16.04.55;	author ajacoutot;	state Exp;
branches;
next	1.81;

1.81
date	2013.05.09.13.43.01;	author ajacoutot;	state Exp;
branches;
next	1.80;

1.80
date	2013.02.22.07.53.37;	author ajacoutot;	state Exp;
branches;
next	1.79;

1.79
date	2013.02.15.07.08.31;	author ajacoutot;	state Exp;
branches;
next	1.78;

1.78
date	2013.01.20.07.39.01;	author ajacoutot;	state Exp;
branches;
next	1.77;

1.77
date	2013.01.05.15.19.49;	author ajacoutot;	state Exp;
branches;
next	1.76;

1.76
date	2012.12.31.11.21.08;	author ajacoutot;	state Exp;
branches;
next	1.75;

1.75
date	2012.11.02.07.24.05;	author ajacoutot;	state Exp;
branches;
next	1.74;

1.74
date	2012.07.06.16.02.18;	author ajacoutot;	state Exp;
branches;
next	1.73;

1.73
date	2012.06.09.08.27.50;	author ajacoutot;	state Exp;
branches;
next	1.72;

1.72
date	2010.12.17.16.43.15;	author ajacoutot;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.16.20.33.43;	author ajacoutot;	state Exp;
branches;
next	1.70;

1.70
date	2010.03.14.17.14.04;	author ajacoutot;	state Exp;
branches;
next	1.69;

1.69
date	2010.03.08.12.37.15;	author ajacoutot;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.23.11.37.13;	author ajacoutot;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.22.17.49.10;	author ajacoutot;	state Exp;
branches;
next	1.66;

1.66
date	2009.12.09.08.30.06;	author ajacoutot;	state Exp;
branches;
next	1.65;

1.65
date	2009.11.10.13.38.42;	author ajacoutot;	state Exp;
branches;
next	1.64;

1.64
date	2009.10.31.07.55.59;	author ajacoutot;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.26.20.27.01;	author ajacoutot;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.20.20.44.41;	author ajacoutot;	state Exp;
branches;
next	1.61;

1.61
date	2009.05.01.13.16.22;	author tobias;	state Exp;
branches;
next	1.60;

1.60
date	2009.04.26.15.44.20;	author tobias;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.09.20.38.02;	author tobias;	state Exp;
branches;
next	1.58;

1.58
date	2009.03.02.19.44.49;	author tobias;	state Exp;
branches;
next	1.57;

1.57
date	2009.02.22.20.35.21;	author tobias;	state Exp;
branches;
next	1.56;

1.56
date	2008.12.01.07.52.52;	author tobias;	state Exp;
branches;
next	1.55;

1.55
date	2008.04.28.08.25.41;	author tobias;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.24.20.43.26;	author saad;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.20.18.26.40;	author saad;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.02.15.10.00;	author jufi;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.18.23.01.09;	author saad;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.09.05.15.24;	author saad;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.04.08.19.55;	author saad;	state Exp;
branches;
next	1.48;

1.48
date	2007.01.25.10.26.14;	author jufi;	state Exp;
branches;
next	1.47;

1.47
date	2007.01.01.10.53.28;	author jufi;	state Exp;
branches;
next	1.46;

1.46
date	2006.11.22.15.14.06;	author saad;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.12.16.09.22;	author jufi;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.03.14.23.31;	author jufi;	state Exp;
branches;
next	1.43;

1.43
date	2006.10.27.07.04.44;	author jufi;	state Exp;
branches;
next	1.42;

1.42
date	2006.09.08.20.49.53;	author saad;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.12.15.36.36;	author jufi;	state Exp;
branches;
next	1.40;

1.40
date	2006.06.26.18.32.12;	author jufi;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.23.09.12.14;	author saad;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.02.17.09.33;	author jufi;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.08.15.13.14;	author saad;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.30.18.51.33;	author saad;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.07.13.14.10;	author saad;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.27.21.23.27;	author saad;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.30.11.33.43;	author jufi;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.24.10.04.35;	author saad;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.18.18.03.08;	author saad;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.18.12.05.07;	author jufi;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.12.10.18.52;	author saad;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.07.15.31.45;	author saad;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.29.15.13.39;	author saad;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.25.00.26.21;	author saad;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.11.06.17.58;	author saad;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.03.19.33.40;	author jufi;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.03.11.30.52;	author saad;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.01.19.05.39;	author jufi;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.31.12.06.18;	author saad;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.19.19.09.20;	author jufi;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.28.09.54.34;	author saad;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.15.04.26.14;	author saad;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.16.13.01.09;	author saad;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.04.08.43.13;	author saad;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.30.13.52.07;	author saad;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.20.14.55.34;	author jufi;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.19.18.23.05;	author jufi;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.18.14.52.24;	author saad;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.04.17.52.25;	author jufi;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.22.16.47.21;	author saad;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.13.11.12.00;	author jufi;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.18.09.54.29;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.02.11.46.26;	author jufi;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.27.19.43.40;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.29.20.06.45;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.28.16.09.12;	author jufi;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.23.09.01.34;	author jufi;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.21.17.12.08;	author jufi;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.21.11.10.49;	author jufi;	state Exp;
branches;
next	;


desc
@@


1.90
log
@
Abandon translations, per deraadt@@ and ajacoutot@@.
Thanks to all those that did the translation work, and my appologies to
those who had to translate my writing!
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Configuration des disques</title>
<link rev= "made" href= "mailto:www@@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 14 - Disk Setup">
<meta name= "keywords"      content= "openbsd,faq14">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2013 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../fr/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a>
<a href= "faq13.html">[Section 13 - Multimédia]</a>
<a href= "faq15.html">[Section 15 - Paquetages et Ports]</a>
</font>

<h1><font color="#e00000">14 - Configuration des disques</font></h1><hr>
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Remarque Importante :</font></b> Le contenu de
   ce fichier est obsolète. Consultez la version anglaise 
   <a href="../faq14.html">ici</a> pour des informations à jour.

<p>
Si vous souhaitez contribuer à l'effort de traduction, prière de consulter
<a href="../../fr/translation.html">la page de traduction</a>.

-->

<h3>Table des matières</h3>
<ul>
<li><a href="#intro"      >14.1 - Disques et Partitions</a>
<li><a href="#fdisk"      >14.2 - Utilisation de fdisk(8) sous OpenBSD</a>
<li><a href="#disklabel"  >14.3 - Utilisation de disklabel(8) sous OpenBSD</a>
<li><a href="#NewDisk"    >14.4 - Ajout de nouveaux disques sous OpenBSD</a>
<li><a href="#Swap"       >14.5 - Comment gérer l'espace de pagination</a>
<li><a href="#SoftUpdates">14.6 - Soft Updates</a>
<li><a href="#Boot386"    >14.7 - Comment se déroule le processus de démarrage
    d'OpenBSD/i386 et d'OpenBSD/amd64 ?</a>
<li><a href="#LargeDrive" >14.8 - Quels sont les problèmes liés aux disques de
    grande capacité sous OpenBSD ?</a>
<li><a href="#InstBoot"   >14.9 - Installation des blocs de démarrage
    ("Bootblocks") - spécifique à i386/amd64</a>
<li><a href="#Backup"     >14.10 - Se préparer au désastre : faire une sauvegarde
    vers une bande et effectuer une restauration</a>
<li><a href="#MountImage" >14.11 - Montage des images disque sous OpenBSD</a>
<li><a href="#pciideErr"  >14.12 - À l'aide ! J'ai des erreurs avec IDE DMA !</a>
<li><a href="#NegSpace"   >14.14 - Pourquoi est-ce que <tt>df(1)</tt> me dit que j'ai
    plus de 100% d'espace disque utilisé ?</a>
<li><a href="#OhBugger"   >14.15 - Récupération de partitions après une
    suppression du disklabel</a>
<li><a href="#foreignfs"  >14.16 - Est-il possible d'accéder aux données
    présentes sur des systèmes de fichiers autres que FFS ?</a>
<ul>
<li><a href="#foreignfsafter">14.16.1 - Les partitions n'apparaissent
    pas dans mon disklabel ! Que dois-je faire ?</a>
</ul>
<li><a href="#flashmem"   >14.17 - Est-il possible d'utiliser un
    périphérique de masse ('flash memory device') sous OpenBSD ?</a>
  <ul>
  <li><a href="#flashmemPortable">14.17.1 - Mémoire Flash comme périphérique
  de stockage portable</a> 
  <li><a href="#flashmemBoot"    >14.17.2 -  Mémoires Flash comme disque de
  démarrage</a>
  <li><a href="#flashmemLive"    >14.17.3 - Comment puis-je créer un
  périphérique de démarrage USB "Live" ?</a>
  </ul>
<li><a href="#DiskOpt"    >14.18 - Optimiser les performances des disques durs</a>
<li><a href="#Async"      >14.19 - Pourquoi nous n'utilisons pas de Montage
    Asynchrone ?</a>
<li><a href="#altroot"    >14.20 - Dupliquer sa partition root: altroot</a>
<li><a href="#softraid"   >14.21 - Comment puis-je utiliser softraid(4)?</a>

</ul>
<hr>

<a name="intro"></a>
<h2>14.1 - Disques et Partitions</h2>

<p>
Les détails de la mise en place des disques dans OpenBSD varie selon les
plates-formes, donc vous devriez lire les instructions d'installation dans
le fichier <tt>INSTALL.&lt;arch&gt;</tt> de votre
<a href="../fr/plat.html">plate-forme</a> afin de déterminer les spécificités
pour votre système.

<p>
<h3>Identification du disque</h3>
OpenBSD gère le stockage de masse avec deux pilotes sur la plupart des plates-formes,
en fonction de l'ensemble des commandes que ce genre de périphérique supporte:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4):</a>
disques IDE (et périphériques ressemblant à des disques IDE, par exemple les disques SATA, MFM
ou ESDI, ou un périphérique flash avec un adaptateur approprié) attachés à une interface
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wdc&amp;sektion=4">wdc(4)</a>
ou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4">sd(4):</a>
périphériques utilisant des commandes SCSI, comme les disques SCSI attachés à un adaptateur
SCSI, des clés USB, des disques SATA attachés à une interface
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4">ahci(4)</a>,
et des baies de disques connectées à un contrôleur RAID.
</ul>

Le premier disque d'un disque de type particulier identifié par OpenBSD
sera '0', le second sera '1', etc.
Donc le premier disque IDE sera wd0, le troisième disque SCSI sera sd2.
Si vous avez deux disques SCSI et trois disques IDE sur une machine,
vous auriez avoir sd0, sd1, wd0, wd1, et wd2 sur celle-ci.
L'ordre est celui de leur apparition durant la phase de détection
du matériel au démarrage. Il y a quelques points clés à garder à l'esprit:
<ul>
<li>Les disques peuvent ne pas être numérotés dans le même ordre que
la ROM de boot compte les démarrer (i.e., le système pourrait booter sur
ce qu'OpenBSD identifie en tant que wd2 ou sd1).
Parfois, vous pourrez changer cela, parfois non.
<li>Enlever ou ajouter un disque peut impacter l'identité des autres
périphériques du système.
</ul>


<h3>Partitionnement</h3>

À cause de raisons historiques, le terme "partition" est régulièrement
utilisé pour deux choses différentes dans OpenBSD et cela amène à quelques
confusions.

<p>
Les deux types de "partitions" sont:
<ul>
<li> "disklabel partitions" créées avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
(souvent appelées "filesystem partitions").
<li> "fdisk partitions" créées avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(souvent appelées "partition table partitions" ou "Master Boot Record (MBR) partitions").
</ul>

<p>
Toutes les plates-formes OpenBSD utilisent disklabel(8) comme principal
moyen pour gérer les partitions du système de fichier OpenBSD, mais seules
certaines plates-formes requièrent l'utilisation de fdisk(8) pour gérer
les Tables de Partitions. Sur les plates-formes utilisant des partitions
fdisk, une partition fdisk est utilisée pour contenir tous les systèmes
de fichiers OpenBSD, cette partition est ensuite découpée vers le haut
dans le disklabel. Ces partitions disklabel sont étiquetées de "a" à "p".
Quelques-unes de celles-ci sont "spéciales":
<ul>
<li><b>a</b> -- Sur le disque de boot, la partition 'a' est la racine.
<li><b>b</b> -- Sur le disque de boot, la partition 'b' est automatiquement
utilisée en tant que swap.
<li><b>c</b> -- Sur tous les disques, la partition 'c' représente le disque tout
entier, du premier secteur au dernier.
(Astuce: si vous souhaitez effacer totalement un disque, écrivez des zéros sur
la partition 'c' du disque.
Plus généralement, la partition 'c' est utilisée par des utilitaires tels que 'fdisk'
pour installer les chargeurs de démarrage, des tables de partitions, etc.)
</ul>

<h3>Identification des partitions</h3>
Un système de fichiers OpenBSD est identifié par le disque sur lequel
il est, plus le fichier de partition système sur ce disque. Donc, les
systèmes de fichiers peuvent être identifiés avec des identifiants
comme "sd0a" (la partition "a" du premier périphérique "sd"), "wd2h"
(la partition "h" du troisième périphérique "wd"), ou "sd1c" (l'intégralité
du second périphérique).
Le fichier de périphérique serait <tt>/dev/sd0a</tt> pour le block device,
et <tt>/dev/rsd0a</tt> serait le fichier de périphérique pour le périphérique
brut.

<p>
Quelques utilitaires vous permettront d'utiliser le nom "raccourcis"
d'une partition (i.e., "sd0d") ou d'un disque (i.e., "wd1") à la place
du nom actuel du périphérique ("<tt>/dev/sd0d</tt>" ou "<tt>/dev/wd1c</tt>",
respectivement).


<p>
Notez encore une fois que si vous mettez des données sur <tt>wd2d</tt>,
puis que vous enlevez <tt>wd1</tt> du système et que vous redémarrez,
vos données seront à présent sur <tt>wd1d</tt>, car votre ancien <tt>wd2</tt>
sera devenu <tt>wd1</tt>.

Cependant, une identification de disque ne va pas changer après le démarrage,
donc si une clé USB est débranchée ou plante, cela ne va pas changer l'identification
des autres disques jusqu'au redémarrage.

<a name="DUID"></a>
<h3>Disklabel Unique Identifiers</h3>
Les disques peuvent aussi être identifiés par les Disklabel Unique Identifiers
(DUIDs), un nombre de 16 chiffres hexadécimaux, gérés par le périphérique
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskmap&amp;sektion=4">diskmap(4)</a>.
Ce nombre est généré automatiquement et aléatoirement lorsqu'un disklabel
est pour la première fois créé, mettant par défaut des zéros sur un label
existant (pre OpenBSD 4.8).
disklabel(8) peut être utilisé pour changer l'UID si désiré.
Ces UIDs sont "persistants" -- si vous identifiez vos disques
de cette façon, le disque "<tt>f18e359c8fa2522b</tt>" sera
toujours <tt>f18e359c8fa2522b</tt>, peut importe l'ordre ou
le moment où il est attaché. Vous pouvez spécifier les partitions
sur le disque en ajoutant une période et la lettre de partition,
par exemple, <tt>f18e359c8fa2522b.d</tt> est la partition 'd' du
disque <tt>f18e359c8fa2522b</tt> et se référera TOUJOURS au même
bloc de stockage, peut importe l'ordre dans lequel le périphérique
est attaché, ou le type d'interface auquel il est attaché.

<p>
Ces UIDs peuvent être utilisé pour identifier les disques presque
partout où une partition ou un périphérique devraient être spécifiés,
par exemple dans <tt>/etc/fstab</tt> ou dans les lignes de commande.
Bien sûr, les disques et les partitions peuvent aussi être identifiés
de façon traditionnelle, par le périphérique, le numéro et la partition
(i.e., /dev/sd1f), et de manière interchangeable.

<p>
Il est à noter que le DUID est une propriété du disklabel, bien que
cela soit surtout académique, comme OpenBSD ne supporte qu'un seul
disklabel par disque.


<p>
<a name="fdisk"></a>
<h2>14.2 - Utilisation de fdisk(8) sous OpenBSD</h2>

Avant de commencer, lisez le manuel de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.

<p>
fdisk(8) est utilisé sur certaines plates-formes (i386, amd64, macppc, zaurus et
armich) pour créer une partition reconnue par la ROM de démarrage du système dans
laquelle les partitions disklabel d'OpenBSD peuvent être inscrites. Les autres
plates-formes n'ont pas besoin d'utiliser fdisk(8).
fdisk(8) peut également être utilisé pour la manipulation du MBR ("Master boot
record") pouvant avoir un impact sur tous les systèmes présents sur la machine.
À l'inverse de certains programmes dont les fonctionnalités sont proches de
celles de fdisk, sous OpenBSD cette commande assume que vous savez ce que vous
voulez faire et en règle générale n'interviendra pas dans vos décisions, ce qui
en fait un outil très puissant. Il vous laissera également faire des choses que
vous n'aviez pas forcément prévues et doit donc être utilisé avec précaution.

<p>
Normalement, seule une partition fdisk OpenBSD sera inscrite sur le disque.
Cette partition sera divisée par <a href="#disklabel">disklabel</a> en
différentes partitions systèmes de fichiers OpenBSD.

<p>

<p>
Pour simplement voir votre table de partition avec fdisk, utilisez:

<blockquote><pre>
# <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Ce qui vous donnera une sortie similaire à celle-ci:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD     
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
</pre></blockquote>

<p>
Dans cet exemple, nous voyons la sortie de fdisk concernant le premier
lecteur SCSI. Nous pouvons voir les partitions OpenBSD (A6). Le *
indique que la partition OpenBSD est amorçable.

<p>
Dans l'exemple précédent, nous avons simplement accédé à une
information. Qu'en est-il si nous souhaitons éditer notre table de
partition ? Et bien, pour ce faire, nous devons utiliser l'option <b>-
e</b>. Ceci fera apparaître une invite de commandes pour interagir avec
fdisk.

<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        swap            Swap two partition entries
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre></blockquote>

<p> 

Voici un aperçu des commandes disponibles lorsque vous utilisez l'option
<b>-e</b>.

<ul>
<li><b>help</b> Affiche la liste des commandes utilisables par fdisk en
    mode d'édition interactif.
<li><b>reinit</b> Initialise la copie en mémoire du bloc de démarrage
    actuellement sélectionné. Pratique pour initialiser une partition OpenBSD
    sur tout le disque, mettre à jour le code de démarrage et, de manière
    générale, préparer le système pour OpenBSD (et OpenBSD seulement).
<li><b>disk</b> Affiche la géométrie actuelle du disque détectée par
    fdisk. Vous pouvez l'éditer selon vos désirs.
<li><b>setpid</b> Change l'identifiant de partition de l'entrée
    sélectionnée de la table de partition. Cette commande est particulièrement
    utile pour réassigner une partition existante à OpenBSD.
<li><b>edit</b> Édite l'entrée sélectionnée de la table dans la copie
    mémoire du bloc de démarrage actuel. Vous pouvez entrer les valeurs
    en géométrie BIOS ou en secteurs, offsets et tailles.
<li><b>flag</b> Rend amorçable la partition sélectionnée. Seule une
    entrée peut être marquée comme amorçable. Si vous souhaitez démarrer
    à partir d'une partition étendue, vous devez la marquer comme
    amorçable.
<li><b>update</b> Met à jour le code machine dans la copie mémoire du
    bloc de démarrage actuellement sélectionné.
<li><b>select</b> Sélectionne et charge en mémoire le bloc de démarrage
    désigné par la table de partition étendue dans le bloc de démarrage
    actuel.
<li><b>swap</b> Échange deux entrées MBR afin que vous puissiez le réordonner.
<li><b>print</b> Affiche la copie en mémoire actuelle du bloc de
    démarrage et de son MBR sur le terminal.
<li><b>write</b> Écrit la copie en mémoire actuelle du bloc de démarrage
    sur le disque. Vous serez amené à confirmer cette action.
<li><b>exit</b> Quitte le niveau actuel de fdisk, revenant à la copie
    précédente du bloc de démarrage ou sortant du programme si une telle
    copie n'existe pas.
<li><b>quit</b> Quitte le niveau actuel de fdisk, revenant à la copie
    précédente du bloc de démarrage ou sortant du programme si une telle
    copie n'existe pas. À l'inverse d'"exit", le bloc de démarrage
    modifié est inscrit sur le disque.
<li><b>abort</b> Quitte le programme sans sauvegarder les changements.
</ul>

<h3>trucs et astuces de fdisk</h3>
<ul>
<!-- <li>On OpenBSD platforms which use fdisk, you should leave the first
track free.
This leaves room for the Master Boot Record, which is where the fdisk
partition table resides.  (not sure if this is true) -->
<li>fdisk(8) permet d'éditer les partitions soit en mode secteurs purs, soit en
utilisant les Cylindres/Têtes/Secteurs. Ces deux options sont disponibles pour
une raison -- certaines tâches sont plus simples à effectuer d'une façon ou d'une
autre. Ne vous limitez pas à l'utilisation d'une seule de ces deux options.
<li>Un disque vierge aura besoin qu'on y inscrive le code de démarrage dans le
MBR avant qu'il ne puisse booter. Pour ce faire, vous pouvez utiliser les
options "reinit" ou "update". Si vous ne le faites pas, vous écrirez une table
de partitions valide avec fdisk mais vous ne pourrez pas démarrer. Si vous ne
savez pas d'où vient le code de démarrage présent sur votre disque, il est
possible que vous souhaitiez le mettre à jour de toutes façons.
<li>Si votre système possède une partition de "maintenance" ou de
"diagnostic", il est recommandé de la laisser en place ou de l'inscrire AVANT
d'installer OpenBSD.
<li>Pour des raisons historiques, "q" enregistre les changements et quitte le
programme alors que "x" quitte sans sauvegarder. C'est l'opposé de ce que
beaucoup de gens peuvent voir sous d'autres environnements. fdisk(8) ne demandera
aucune confirmation avant d'enregistrer les changements alors utilisez cette
commande avec précaution

</ul>


<a name="disklabel"></a>
<h2>14.3 - Utilisation de disklabel(8) sous OpenBSD</h2>

<a name="disklabel.1"></a>
<h3>Qu'est-ce que disklabel(8) ?</h3>

<p>
Pour commencer, lisez le manuel de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
La façon de configurer les disques sous OpenBSD diffère légèrement selon
les plates-formes. Sous <a href="../../fr/i386.html">i386</a>,
<a href="../../fr/amd64.html">amd64</a>, <a href="../../fr/macppc.html">macppc</a>,
<a href="../../fr/zaurus.html">zaurus</a> et <a
href="../../fr/armish.html">armish</a>,
la configuration se déroule en deux étapes. Tout d'abord, la tranche
contenant OpenBSD sur le disque est définie en utilisant fdisk(8) et
ensuite divisée en partitions OpenBSD avec disklabel(8).

<p>
Toutes les autres plates-formes utilisent disklabel(8) pour la gestion
complète des partitions OpenBSD. Les plates-formes qui utilisent aussi
fdisk(8) placent toutes les partitions disklabel(8) dans une tranche
fdisk.

<p>
Les labels contiennent certaines informations sur votre disque, comme sa
géométrie ou les systèmes de fichiers présents sur celui-ci. Le
disklabel est utilisé par le programme de bootstrap pour accéder aux
disques et connaître le type de systèmes de fichiers présents. Vous
pouvez accéder à de plus amples informations sur disklabel en lisant le
manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>.

<p>
Sur certaines plates-formes, l'utilisation de disklabel permet de passer
outre les limitations de partitionnement liées aux types d'architectures.
Par exemple, sur i386, vous pouvez avoir 4 partitions primaires mais
avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a>, vous utilisez une de ces partitions 'primaires' pour
stocker toutes vos partitions OpenBSD (par exemple, 'swap', '/',
'/usr', '/var', etc...) et il vous reste encore 3 partitions disponibles
pour d'autres systèmes d'exploitation !

<a name="disklabel.2"></a>
<h3>disklabel(8) à l'installation d'OpenBSD</h3>

<p>
Une partie importante de l'installation d'OpenBSD est la création
initiale des labels. À l'installation, vous utiliserez disklabel(8) afin
de créer les différentes partitions. Vous pourrez définir vos points de
montage à partir de disklabel(8) et les changer plus tard pendant
l'installation ou même après celle-ci.

<p>
Il n'existe pas de "bonne" façon de créer un label disque mais il en
existe beaucoup de mauvaises. Avant de créer un label sur votre disque,
lisez <a href="faq4.html#Partitioning">ce chapitre</a> sur le
partitionnement.

<p>
Pour un exemple d'utilisation de disklabel(8) pendant l'installation,
référez-vous à <a href="faq4.html#Moredisklabel">la configuration des
disques</a> du <a href="faq4.html">guide d'installation</a>.

<p>

<a name="disklabel.3"></a>
<h3>Utilisations de disklabel(8) après l'installation</h3>

<p>
Après l'installation, un des usages les plus courants de disklabel(8)
est de vérifier la disposition de votre disque. La commande suivante
affichera le disklabel courant sans le modifier :

<blockquote><pre>
# <b>disklabel wd0</b> &lt;-- <i>Selon le disque que vous souhaitez vérifier</i>
type: ESDI
disk: ESDI/IDE disk
label: SAMSUNG HD154UI 
duid: d920a43a5a56ad5f
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2907021
total sectors: 2930277168
boundstart: 64
boundend: 2930272065
drivedata: 0 

16 partitions:
#                size           offset  fstype [fsize bsize  cpg]
  a:          1024064               64  4.2BSD   2048 16384    1 # /
  b:          4195296          1024128    swap                   
  c:       2930277168                0  unused                   
  d:          4195296          5219424  4.2BSD   2048 16384    1 # /usr
  e:          4195296          9414720  4.2BSD   2048 16384    1 # /tmp
  f:         20972448         13610016  4.2BSD   2048 16384    1 # /var
  h:          2097632         34582464  4.2BSD   2048 16384    1 # /home
</pre></blockquote>

<p>
Notez que, pour le moment, ce disque n'a qu'une partie de son espace
disponible allouée.

Disklabel offre deux modes d'édition différents, un mode de commandes
(utiliser à l'installation d'OpenBSD) et un éditeur complet tel que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">
vi(1)</a>. Le mode de commandes peut paraître plus simple puisqu'il vous
guide à travers les différentes étapes et propose une aide intégrée,
mais le mode éditeur possède également une véritable utilité.

<p>
Ajoutons une partition au système précédent.

<p>
<blockquote>
<i>Attention : chaque fois que vous touchez à votre disklabel, vous
mettez en danger toutes les données présentes sur le disque. Soyez sûr
que vos données sont sauvegardées avant d'éditer un disklabel
existant !</i>
</blockquote>
<p>
Nous utiliserons le mode de commandes intégré qui est lancé avec
l'option "-E" de disklabel(8)

<blockquote><pre>
# <b>disklabel -E wd0</b>
...
> a k
offset: [36680096] 
size: [2893591969] 1T
Rounding to cylinder: 2147483536
FS type: [4.2BSD]
> p m
OpenBSD area: 64-2930272065; size: 1430796.9M; free: 364310.8M
#                size           offset  fstype [fsize bsize  cpg]
  a:           500.0M               64  4.2BSD   2048 16384    1 # /
  b:          2048.5M          1024128    swap                   
  c:       1430799.4M                0  unused                   
  d:          2048.5M          5219424  4.2BSD   2048 16384    1 # /usr
  e:          2048.5M          9414720  4.2BSD   2048 16384    1 # /tmp
  f:         10240.5M         13610016  4.2BSD   2048 16384    1 # /var
  h:          1024.2M         34582464  4.2BSD   2048 16384    1 # /home
  k:       1048575.9M         36680192  4.2BSD   8192 65536    1 
> q
Write new label?: [y]
</pre></blockquote>

Dans ce cas, disklabel(8) a été capable de calculer un bon point de
départ pour la partition. La plupart du temps ce sera le cas mais si
vous avez des "trous" dans votre disklabel (ex. vous avez supprimez
votre partition ou vous aimez simplement vous compliquer la vie) il vous
faudra prendre le temps de calculer un offset correct. Notez que même si
disklabel(8) effectue certaines vérifications il est très possible de
faire de grosses erreurs. Faites attention et comprenez bien les valeurs
que vous utilisez.

<p>
Sur la plupart des plates-formes OpenBSD, il y 16 partitions disklabel
disponibles, notées de "a" à "p" (certains systèmes "spécialisés" n'en
ont que huit). Chaque disklabel doit avoir une partition 'c' avec un
"fstype" défini à "unused" qui couvre l'ensemble du disque physique. Si
ce n'est pas le cas de votre disklabel, il doit être fixé, l'option "D"
(plus bas) peut être utilisée. Ne tentez jamais d'utiliser la partition
"c" pour autre chose que l'accès en mode raw des secteurs du disque et
n'essayez pas de créer un système de fichiers sur "c". Sur le
périphérique de démarrage et seulement sur celui-ci, "a" est réservé
pour la partition racine et "b" pour le swap. Tous les autres
périphériques peuvent utiliser l'ensemble des quinze partitions en
dehors de 'c' pour leur système de fichiers.

<p>
<h3>Trucs et astuces sur disklabel</h3>
<ul>
<li><b>Obtenir de l'aide :</b> en mode commandes, taper "?" affichera
une liste des commandes disponibles. "M" affichera la page manuel de
disklabel(8).

<li><b>Valeurs par défaut :</b> dans certains cas, vous pourriez avoir
besoin de commencer avec disklabel par défaut. La commande "D" écrasera
l'ancien disklabel comme s'il n'avait jamais existé pour le remplacer
par un nouveau.

<li><b>Dupliquer un disklabel :</b> dans certains cas, vous pourriez
avoir besoin de dupliquer le partitionnement d'un disque sur un autre
mais par précisément (par exemple, vous voudriez avoir les même
partitions mais sur des disques de taille différente). Utilisez l'option
'-e' (mode éditeur en plein écran) de disklabel(8) pour enregistrer les
partitions du disque "source", copiez-les sur le nouveau disque,
supprimez la partition 'c' du disque "source", enregistrez et vous aurez
copié la disposition des partitions sur le sur le nouveau disque sans
altérer ses paramètres de base.

<li>(sparc/sparc64) <b> Ne placez pas la partition swap au début du
disque.</b>
Quand Solaris met souvent la swap au tout début d'un disque, OpenBSD
requiert que la partition de boot soit au début du disque.

<li>(plates-formes fdisk) <b> laissez la première piste ("track") libre :</b>
sur certaines plates-formes utilisant fdisk(8), vous devriez laisser la première piste
logique inutilisée dans disklabel(8) et fdisk(8).
Sur les ordinateurs "modernes" (i.e., presque tous ceux capables de faire
fonctionner OpenBSD), le montant exact n'a pas vraiment d'importance, mais
pour des raisons de performance sur les nouveaux disques, avoir des partitions
alignées sur des limites de 4k est bon pour la performance.
Pour cette raison, OpenBSD démarre désormais par défaut la première partition
au bloc 64 au lieu du 63.

<li><b>Disques sans disklabel :</b> si un périphérique ne possède pas
de disklabel OpenBSD mais a déjà un autre système de fichiers (par
exemple, un disque avec un système de fichiers FAT32 déjà existant),
OpenBSD va en "créer" un en mémoire qui posera les bases d'un disklabel
à enregistrer sur le disque. Cependant, si un disklabel OpenBSD est créé
et enregistrer sur le disque et qu'un système de fichiers non OpenBSD
est ajouté par la suite, le disklabel ne sera pas automatiquement mis à
jour. Vous devrez l'éditer vous-même si vous souhaitez que OpenBSD puisse
y accéder. Plus d'informations sont disponibles
<a href="faq14.html#foreignfsafter">plus bas</a>.

<li><b>"q" ou "x":</b>
Pour des raisons historiques, en mode de commandes, "q" enregistre les
changements et quitte le programme alors que "x" quitte sans sauvegarder. C'est
l'opposé de ce que beaucoup de gens peuvent voir sous d'autres environnements.
disklabel(8) demandera confirmation avant d'enregistrer les changements mais
n'affichera aucune alerte si "x" est utilisée.

<li><b>Auto-partitionnement:</b>
Les nouveaux utilisateurs sont encouragés à utiliser la commande 'A' pour créer
automatiquement un disklabel recommandé. Vous pouvez ensuite éditer le label auto-créé
de la façon que vous voulez.


</ul>


<a name="NewDisk"></a>
<h2>14.4 - Ajout de nouveaux disques sous OpenBSD</h2>
<!-- XXX whoa. this section needs rework -->
<p>
Une fois votre disque <b>CORRECTEMENT</b> installé, vous devez utiliser <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a> (<i>i386 seulement</i>) et <a
href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a> afin de le configurer pour OpenBSD.

<p>
Pour les utilisateurs i386, commencez avec fdisk. Les autres
architectures peuvent ignorer cette étape. Dans l'exemple suivant, nous
ajouterons un troisième disque SCSI au système.

<blockquote><pre>
# <b>fdisk -i sd2</b>
</pre></blockquote>

Cette commande va initialiser la "véritable" table de partition du
disque pour un usage exclusif par OpenBSD. Ensuite, vous devez créer un
disklabel. Ceci risque de sembler confus.

<blockquote><pre>
# <b>disklabel -e sd2</b>

<i>(screen goes blank, your $EDITOR comes up)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></blockquote>

Tout d'abord, ignorez la partition 'c', celle-ci est toujours présente
et est nécessaire au fonctionnement de programmes comme disklabel ! Le
type de système de fichiers ("fstype") pour OpenBSD est 4.2BSD. Le
nombre total de secteurs ("total sectors") représente la taille du
disque. Admettons qu'il s'agit d'un disque de 3 gigaoctets. 3 gigaoctets
en terme de constructeur de disques représente 3000 mégaoctets. Divisons
6185088 par 3000 (on utilise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1)</a>).
Vous obtenez 2061. Ainsi, pour décider des tailles des partitions a, d,
e, f, g, ... multipliez simplement X par 2061 afin d'avoir X mégaoctets
d'espace sur cette partition. L'offset de votre première partition doit
être égal à "sectors/track" comme rapporté par disklabel. Pour nous,
cette valeur est égale à 63. L'offset de chaque partition suivante
résultera de la combinaison de la taille et de l'offset de chacune
d'elle (sauf la partition 'c' qui n'intervient pas dans cette équation).

<p>
Ou, si vous souhaitez simplement une partition couvrant tout le disque,
afin d'offrir un espace de stockage web, un répertoire d'utilisateurs
("home") ou autre chose, ôtez simplement la valeur "sectors/track" à la
taille totale du disque. 6185088-63 = 6185025. Votre partition est :

<blockquote><pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre></blockquote>

<b>Si tout ceci vous semble inutilement complexe, vous pouvez simplement
utiliser disklabel -E pour entrer dans le même mode de partitionnement
dont vous disposiez à l'installation !</b> Dans celui- ci, vous pouvez
utiliser "96M" pour spécifier "96 mégaoctets" ou, 96G pour 96 gigaoctets.

<p>
Voilà qui était dense. Mais tout n'est pas terminé. Vous devez à présent
créer un système de fichiers sur ce disque en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<blockquote><pre>
# <b>newfs sd2d </b>
</pre></blockquote>

<p>
Ou autre, selon le nom donné à votre disque par le système de nommage
d'OpenBSD (regardez la sortie de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">
dmesg(8)</a> pour voir comment OpenBSD a nommé votre disque).

<p>
Maintenant, il vous faut décider où vous souhaitez monter cette
partition nouvellement créée. Disons que vous vouliez la monter sur /u.
Tout d'abord, créez le répertoire /u. Puis montez-le.

<blockquote><pre>
# <b>mount /dev/sd2d /u</b>
</pre></blockquote>

<p>
Enfin, ajoutez-le a <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">
/etc/fstab(5)</a>.

<blockquote><pre>/dev/sd2d /u ffs rw 1 1</pre></blockquote>

<p>
Et si vous souhaitiez migrer un répertoire existant comme /usr/local ?
Vous devriez monter le nouveau disque sur /mnt et copier /usr/local dans
le dossier /mnt. Exemple:

<blockquote><pre>
# <b>cd /usr/local && pax -rw -p e . /mnt</b>
</pre></blockquote>

Éditez le fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">
/etc/fstab(5)</a>
afin de préciser que votre partition /usr/local est maintenant /dev/sda2d
(votre nouvelle partition formatée). Exemple :

<blockquote><pre>
<b>/dev/sd2d /usr/local ffs rw 1 1</b>
</pre></blockquote>

<p>
Redémarrez en mode single user avec <b>boot -s</b>, déplacez le
répertoire /usr/local vers /usr/local-backup (ou si vous vous sentez en
veine, supprimez-le) et créez un répertoire /usr/local vide. Enfin,
redémarrez le système et voilà, les fichiers sont présents !

<p>
<a name="SwapFile"></a>
<a name="Swap"></a>
<h2>14.5 - Comment gérer l'espace de pagination ?</h2>
 
<h3>14.5.1 - À propos de la pagination</h3>
Historiquement, toutes sortes de règles ont été expliquées pour guider
l'administrateur sur la quantité d'espace de pagination à configurer
sur leurs machines.
Le problème, bien sûr, c'est qu'il y a peu d'applications "normales".

<p>
Une non-utilisation manifeste de l'espace de pagination est d'être un lieu ou 
le noyau peut générer une copie du système de base en cas de mode panique 
pour une analyse ultérieure.
Pour que cela fonctionne vous devez avoir une partition de pagination (pas
un fichier de pagination) au moins aussi grand que la taille de votre RAM.
Par défaut, le système sauvera une copie de ce vidage mémoire dans
<tt>/var/crash</tt> au redémarrage, donc si vous désirez faire cela
automatiquement, vous devez avoir assez d'espace <i>libre</i> dans
<tt>/var</tt>.
Cependant, vous pouvez aussi démarrer le système en mode mono-utilisateur et
utiliser
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8">savecore(8)</a>
pour faire le vidage ailleurs.

<p>
Plusieurs types de systèmes peuvent être configurés de façon approprié
sans aucun espace de pagination.
Par exemple, les pare-feu ne doivent pas paginer en fonctionnement normal.
Les machines avec un stockage flash ne doivent généralement pas paginer.
Si votre pare-feu est basé sur une flash, vous bénéficierez (légèrement)
par la non allocation d'une partition d'espace de pagination, mais dans
la plupart des cas, une partition d'espace de pagination ne fera de mal
à personne; la plupart des disques possèdent assez d'espace pour en allouer
un petit peu à l'espace de pagination.

<p>
Il y a toutes sortes d'astuces pour optimiser l'espace de pagination (ou sur
le disque, disques séparés, etc...), mais si vous vous trouvez vous-même
dans une situation où l'espace de pagination est une solution, vous avez
probablement besoin de plus de RAM.
En général, la meilleure optimisation pour l'espace de pagination est de ne
pas en avoir besoin.

<p>
Sur OpenBSD, l'espace de pagination est géré par le programme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
qui ajoute, supprime, affiche et donne des priorités sur les fichiers et
périphériques d'espace de pagination.


<h3>14.5.2 - Paginer sur une partition</h3>
<p>
Sur OpenBSD, la partition 'b' du disque de démarrage est utilisée par défaut et
automatiquement pour l'espace de pagination.
Pas de configuration est nécessaire pour mettre cela en place.
Si vous ne désirez pas utiliser d'espace de pagination sur le disque de
démarrage, ne définissez pas une partition "b".
Si vous désirez utiliser l'espace de pagination sur une autre partition ou
sur un autre disque, vous devez définir ces partitions dans <tt>/etc/fstab</tt>
avec des lignes ressemblant à cela :

<blockquote><pre>
/dev/sd3b none swap sw 0 0
/dev/sd3d none swap sw 0 0
</pre></blockquote>


<h3>14.5.3 - Paginer dans un fichier</h3> 

<p>
(Note : si vous souhaitez ajouter un espace de pagination dans un
fichier parce que vous recevez des erreurs du type &quot;virtual memory
exhausted&quot;, vous devriez d'abord essayer d'augmenter la limite des
processus avec unlimit pour
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh(1)</a>
ou ulimit pour
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh(1)</a>)

<p>
Quelquefois, votre envie initiale sur la quantité de swap nécessaire est
fausse, et vous devez ajouter plus d'espace de pagination, occasionnellement
dans l'urgence (comme dans "Geez, at the rate it is burning swap, we'll be wedged
in five minutes").
Si vous vous retrouvez dans cette situation, ajouter de l'espace de
pagination dans un fichier sur un système de fichier existant peut-être une
solution rapide.

<p>
Ce fichier ne doit pas résider sur un système de fichiers dont l'option
"SoftUpdates" est activée (cette option est désactivée par défaut). Pour
commencer, vous pouvez voir la taille totale et utilisée de votre swap
actuel en utilisant l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">
swapctl(8)</a>. Pour ce faire, lancez la commande :

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></blockquote>

<p>
Cela vous affiche les différents dispositifs utilisés pour la pagination
ainsi que leurs statistiques actuelles. Dans l'exemple précédent, il n'y
a qu'un seul dispositif nommé &quot;swap_device&quot;. Il s'agit de
l'espace disque prédéfini utilisé pour paginer (partition b visible sous
disklabel). Comme vous pouvez le constater dans l'exemple précédent, cet
espace n'est pas beaucoup utilisé pour le moment. Mais pour les besoins
de ce document, nous imaginerons que 32Mo supplémentaires sont
nécessaires.

<p>
La première chose à faire pour configurer un fichier en tant que
dispositif de pagination est de créer ce fichier. Le mieux est
d'utiliser la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Voici un exemple montrant la création d'un fichier <i>/var/swap</i> d'une
taille de 32Mo.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Une fois que cela est fait, nous pouvons activer la pagination vers ce
fichier. Pour ce faire, utilisez la commande suivante :

<blockquote><pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre></blockquote>

<p>
À présent, vérifions que ce fichier a bien été ajouté à la liste des
dispositifs de pagination disponibles.

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>

<p>
Maintenant que le fichier de pagination est activé, vous devez ajouter
une ligne à votre fichier <i>/etc/fstab</i> afin que les changements
soient pris en compte au prochain redémarrage. Si cette ligne n'est pas
ajoutée, ce dispositif ne sera plus activé au prochain reboot.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></blockquote>


<a name="SoftUpdates"></a>
<h2>14.6 - Soft Updates</h2>

<p>
Les "Soft Updates" sont basés sur une idée de <a
href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger et Yale
Patt</a> et ont été développés pour FreeBSD par <a
href="http://www.mckusick.com/softdep/">Kirk McKusick</a>.
Les Soft Updates imposent une réorganisation partielle des opérations
sur le tampon permettant la suppression du code FFS, des écritures
synchrones des entrées. Une augmentation des performances est ainsi
réalisée lors des écritures sur disque.

<p>
L'activation des Soft Updates est effectuée par une option de montage. Lors du
montage d'une partition avec l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>,
vous pouvez activer les Soft Updates sur celle-ci. Voici l'exemple d'une entrée
dans le fichier
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i>
permettant de monter la partition <i>sd0a</i> avec les Soft Updates activés.

<blockquote><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></blockquote>

<p>
Note aux utilisateur sparc : n'activez pas Soft Updates sur les machines
de type sun4 ou sun4c. Ces architectures ne supportent qu'un montant
très faible de mémoire noyau et ne peuvent utiliser cette
fonctionnalité. En revanche, les machines de type sun4m ne posent pas de
problème.

<p>
<a name="Boot386"></a>
<a name="BootAmd64"></a>
<h2>14.7 - Comment se déroule le processus de démarrage d'OpenBSD/i386 et d'OpenBSD/amd64 ?</h2>
Le processus de démarrage d'un système OpenBSD/i386 et OpenBSD/amd64
est loin d'être simple et une bonne compréhension de celui-ci peut être
utile afin de diagnostiquer un problème lorsque les choses ne fonctionnent
pas. Ce processus comporte quatre étapes clefs :
<ol>
<li><b><i>Master Boot Record (MBR) :</i></b> Le "Master Boot Record"
    (enregistrement de démarrage principal) représente les 512 premiers
    octets du disque. Il contient la table de partition primaire et un
    petit programme permettant de charger le "Partition Boot Record"
    (PBR - enregistrement de démarrage des partitions). Notez que dans
    certains environnements, le terme "MBR" se réfère uniquement à la
    portion de code comprise dans le premier bloc du disque et non pas
    au bloc entier (incluant la table de partition). Il est primordial
    de comprendre le sens d'"initialiser le MBR" ; la terminologie sous
    OpenBSD sous-entend la réécriture complète du secteur MBR, effaçant
    la table de partition existante, et pas seulement son code, comme
    cela peut être le cas avec certains systèmes.
    Vous n'aurez pas souvent envie de le faire.
    Pour ce faire, utilisez l'option "-u" de la commande fdisk(8)
    ("<tt>fdisk -u wd0</tt>") pour (ré)installer le code du MBR.

<p>
Bien qu'OpenBSD inclue son propre MBR, vous n'êtes pas obligé de
l'utiliser puisque virtuellement, n'importe quel MBR est capable de le
faire démarrer. Le MBR se manipule avec l'aide du programme fdisk(8) qui
est utilisé pour éditer la table de partition mais également pour
installer le code MBR sur le disque.

<p>
Le MBR d'OpenBSD s'annonce avec le message suivant :

<blockquote><pre>
    Using drive 0, partition 3.
</pre></blockquote>

montrant le disque ainsi que la partition d'où il s'apprête à charger le
PBR. On peut également voir un point (".") en fin de ligne, ce qui
signifie que la machine est capable d'utiliser la conversion LBA
("Logical Block Adressing") au démarrage. Si la machine avait été
incapable d'une telle conversion, le point aurait été remplacé par un
point-virgule (";"), indiquant une conversion CHS 
("Cylinder-Head-Sector") :

<blockquote><pre>
    Using drive 0, partition 3;
</pre></blockquote>
Notez que le point ou le point-virgule en fin de ligne peut servir
d'indicateur du "nouveau" MBR OpenBSD introduit à partir de la version
3.5.

<p>
<li><b><i>Partition Boot Record (PBR) :</i></b> Le "Partition Boot
Record" (enregistrement de démarrage de partition), aussi appelé PBR
ou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(d'après le nom du fichier contenant le code) représente les 512
premiers octets de la partition OpenBSD du disque. Le PBR est le
"first-stage boot loader" (chargeur de démarrage de niveau un)
d'OpenBSD. Il est exécuté par le code MBR et se charge de lancer le
"second- stage boot loader" (chargeur de démarrage de niveau deux),
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
Comme le MBR, le PBR est constitué d'une toute petite quantité de
code et de données d'une taille totale de 512 octets. Ce n'est pas
suffisant pour avoir une application reconnaissant un système de
fichiers, donc, plutôt que de demander au PBR de localiser
<tt>/boot</tt> sur le disque, la localisation de <tt>/boot</tt> accessible
par le BIOS est codée physiquement dans le PBR lors de l'installation.

<p>
Le PBR est installé par <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>, décrit dans
<a href="faq14.html#InstBoot">plus en détails dans la
suite de ce document</a>. Le PBR s'annonce avec le message suivant :

<blockquote><pre>
    Loading...
</pre></blockquote>

affichant un point pour chaque bloc qu'il essaye de charger. Comme
précédemment, le PBR montre s'il utilise une conversion LBA ou CHS pour
s'exécuter. Dans le cas de CHS, il affichera un message suivi d'un point-
virgule :

<blockquote><pre>
    Loading;... 
</pre></blockquote>

<p>
<li><b><i>Second Stage Boot Loader, <tt>/boot</tt> :</i></b>
    <tt>/boot</tt> est chargé par le PBR et se charge d'accéder au
    système de fichiers OpenBSD par le BIOS de la machine afin de
    localiser et de lancer le noyau. boot(8) permet également de passer
    plusieurs options et informations au noyau.

<p>
boot(8) est un programme interactif. Après son exécution, il tente de
localiser et lire <tt>/etc/boot.conf</tt> si celui-ci existe (ce qui
n'est pas le cas dans une installation par défaut) puis lance les
commandes qui y sont indiquées. A moins que le fichier
<tt>/etc/boot.conf</tt> ne l'en empêche, boot(8) offre à l'utilisateur
une invite de commandes similaire à celle-ci :

<blockquote><pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 3.21
     boot>
</pre></blockquote>

Par défaut, l'utilisateur a cinq secondes pour entrer une commande avant
le démarrage du noyau, <tt>bsd</tt>, à partir de la partition racine du
premier disque dur, ce qui représente le comportement par défaut. Le "second-
stage boot loader" détecte (et examine) votre matériel grâce au BIOS
(puisque le noyau OpenBSD n'est pas encore chargé). Précédemment on peut
voir qu'il a détecté :
<ul>
<li><b>pc0</b> - Clavier et affichage vidéo d'un système i386 standard.
<li><b>com0, com1</b> - Deux ports série.
<li><b>apm</b> - BIOS compatible APM ("Advanced Power Management" - gestion de
courant évoluée).
<li><b>636k 190M</b> - Le montant de mémoire conventionnelle (sous 1Mo) et
étendue (au-dessus d'1Mo) trouvée.
<li><b>fd0 hd0+</b> - Les disques accessibles par le BIOS, dans ce cas, un
lecteur de disquettes et un disque dur.
</ul>

Le signe '+' après "hd0" signifie que le BIOS a indiqué à <tt>/boot</tt> que ce
disque peut être accessible par LBA. Lors d'une première installation, vous
verrez souvent un '*' après un disque dur ; ceci signifie que ce disque ne
possède pas de label OpenBSD valide.

<p>
<li><b><i>Noyau : <tt>/bsd</tt></i>:</b> il s'agit de la finalité du processus
de démarrage, avoir le noyau OpenBSD chargé en mémoire RAM et fonctionnant
correctement. Une fois le noyau exécuté, OpenBSD peut accéder directement au
matériel sans passer par le BIOS.

</ol>

Ainsi, le tout début du processus de démarrage pourrait ressembler à ceci :
<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.21
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Noyau</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2013 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 5.4 (GENERIC) #37: Tue Jul 30 12:05:01 MDT 2013
    deraadt@@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
   ...
</pre></blockquote>


<h3>Ce qui peut mal se passer</h3>
<ul>
<li><b>Bad/invalid/incompatible MBR :</b> habituellement, un disque déjà utilisé
possède un code MBR, mais s'il est neuf ou déplacé à partir d'une plate-forme
différente ET que vous ne répondez pas "w" à la question "Use (W)hole disk
or (E)dit the MBR?" lors de l'<a href="faq4.html#InstDisks">installation</a>,
vous pourriez vous retrouver avec un disque sans MBR valide, le rendant ainsi
non-bootable même si sa table de partition est correcte.

<p>
Vous pouvez installer le MBR OpenBSD sur votre disque dur à l'aide du programme
fdisk. Démarrez à l'aide du médium d'installation; choisissez "Shell" pour vous
retrouver en ligne de commandes :

<blockquote><pre>
    # <b>fdisk -u wd0</b>
</pre></blockquote>

Vous pouvez également installer un MBR particulier avec fdisk :
<blockquote><pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre></blockquote> 

ce qui installera le fichier <tt>/usr/mdec/mbr</tt> en tant que MBR de votre
système. Dans une installation standard d'OpenBSD, ce fichier représente le MBR
par défaut codé dans fdisk, mais n'importe quel autre MBR pourrait ici être
spécifié.

<li><b>Invalid <tt>/boot</tt> location installed in PBR :</b>
lorsqu'installboot(8) installe le PBR, il inscrit l'offset et le numéro du bloc
de l'inode de <tt>/boot</tt> dans le celui-ci. Ainsi, supprimer puis remplacer
<tt>/boot</tt> sans relancer <a href="faq14.html#InstBoot">installboot(8)</a>
empêchera votre système de redémarrer puisque le PBR chargera ce qui se trouve
à l'ancien inode spécifié, ce qui ne sera certainement plus le "second-stage
boot loader" désiré !

Puisque que <tt>/boot</tt> est accédé au travers d'appels BIOS, les anciennes
versions de PBR étaient dépendantes de la conversion BIOS des disques. Si vous
avez altéré la géométrie (à savoir, pris un disque d'un ordinateur utilisant la
conversion CHS pour le mettre dans une machine utilisant LBA, ou simplement
changé l'option de conversion dans votre BIOS), il <i>apparaîtra au niveau du
BIOS</i> comme étant déplacé vers une autre location (un bloc numérique
différent doit être accédé afin de récupérer les mêmes informations du disque)
et vous devrez donc relancer installboot(8) avant que le système ne puisse être
redémarré. Le nouveau PBR (OpenBSD 3.5 et plus) est beaucoup plus tolérant dans
les changements de conversion.
</ul>

Le PBR étant très petit, son éventail de messages d'erreur est limité et
quelque peu complexe. La plupart des messages ressemblent à :

<ul>
<li><b>ERR R</b> - Le BIOS a retourné une erreur en tentant de lire un bloc à
partir du disque. Habituellement, ceci est assez explicite : votre disque
n'était pas lisible.
<li><b>ERR M</b> - Un nombre <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)
</a> invalide a été lu dans l'entête du "second-stage bootloader". Ceci signifie
généralement que ce qui a été lu n'était PAS <tt>/boot</tt>, à savoir
qu'installboot(8) n'a pas été correctement exécuté, que le fichier /boot a été
altéré ou encore que vous avez excédé la capacité de votre BIOS à lire les
<a href="#LargeDrive">disques de grande capacité</a>.

</ul>
Les autres messages d'erreur sont expliqués en détail dans le manuel de 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>.

<p>
Pour plus d'informations sur le processus de démarrage pour i386, référez-vous
à :
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.html">http://www.ata-atapi.com/hiw.html
</a> - Documents "How it Works" (comment cela fonctionne) de Hale Landis.
</ul>

<a name="LargeDrive"></a>
<h2>14.8 - Quels sont les problèmes liés aux disques de grande capacité sous
OpenBSD ?</h2>

<p>
OpenBSD supporte les systèmes de fichiers FFS et FFS2 (aussi connus sous
les noms de UFS et UFS2).
FFS est le système de fichiers historique de OpenBSD, FFS2 est nouveau
depuis la 4.3.
Avant de regarder les limites de chaque système, nous avons besoin de
regarder à des limites système plus générales.

<p>
Bien entendu, les capacités du système de fichiers et celles d'un
matériel défini sont deux choses bien différentes. Un nouveau disque dur
IDE de 250Go pourrait provoquer des problèmes sur des interfaces trop
anciennes (d'une capacité standard de 137Go maximum, mais il fonctionne
très bien), certains
adaptateurs SCSI très anciens peuvent avoir des problèmes avec des
lecteurs modernes et des BIOS un peu trop vieux peuvent se figer
lorsqu'ils tombent sur un disque dur de trop grande capacité. De fait,
vous devez respecter les possibilités de votre matériel et boot code.

<h3>Taille des partitions et limitations au niveau de la localisation</h3>
Malheureusement, les fonctionnalités du système d'exploitation ne sont
accessibles qu'une fois celui-ci chargé en mémoire. Le processus de
démarrage devra se contenter de la ROM de lancement du système (bien
plus limitée).
 
<p>
Pour cette raison, le fichier /bsd (le noyau) doit se trouver dans
l'espace disque adressable par la ROM. Cela signifie que sur certains
systèmes i386, la partition racine doit se situer dans les premiers
504Mo, mais les ordinateurs plus récents peuvent avoir des limites de
l'ordre de 2Go, 8Go, 32Go, 128Go ou plus. Il est important de noter que de
nombreux ordinateurs récents supportant un adressage au delà de 128Go
sont en fait limités par le BIOS et ne peuvent démarrer que sur les 128
premiers gigaoctets. Vous pouvez utiliser ces systèmes avec de gros disques
durs, mais la partition racine devra être placée dans l'espace supporté
par la ROM de démarrage.
 
<p>
Notez qu'il est toujours possible d'installer un disque dur de 40Go sur un vieux
486 et d'y placer OpenBSD sur une seule et énorme partition ; vous pourriez
penser avoir réussi à violer la règle précédente. Cependant, un beau jour,
celle-ci risque de revenir vous hanter de manière peu plaisante :

<ul>
  <li>Vous installez tout sur une partition / de 40Go. Cela fonctionne car le
système de base et ses fichiers (/bsd inclut) se situent dans les premiers 504Mo.
  <li>Vous utilisez le système et finissez par avoir plus de 504Mo de données
dessus.
  <li>Vous mettez à jour et vous copiez votre nouveau /bsd à la place de l'ancien.
  <li>Vous redémarrez.
  <li>C'est alors que vous recevez un message tel que "ERR M" ou rencontrez des
problèmes lors du démarrage.
</ul>
<p>
Pourquoi ? Simplement parce que vous avez "écrasé" l'ancien /bsd par le nouveau,
ce fichier n'a pas été écrit au-dessus de l'autre, mais a été relocalisé vers un
autre endroit sur le disque, probablement au-delà des 504 premiers Mo supportés
par le bios. Le chargeur de démarrage se voit alors dans l'impossibilité
d'atteindre /bsd et le système se fige.

<p>
Afin de permettre le lancement d'OpenBSD, les chargeurs de démarrage
(biosboot(8) et <tt>/boot</tt> dans le cas d'un i386/amd64) ainsi que le noyau
(<tt>/bsd</tt>) doivent se situer à l'intérieur de l'espace d'adressage supporté
par la ROM de boot et par leurs propres capacités. Afin de ne jamais rencontrer
de problèmes, la règle est simple :

<blockquote>
<b>La partition racine dans son ensemble doit se situer dans l'espace
d'adressage supporté par le BIOS (ou la ROM de démarrage).</b>
</blockquote>

<p>
Certains utilisateurs n'utilisant pas d'i386 peuvent penser qu'ils sont
immunisés contre ce problème, cependant, de nombreuses plates-formes possèdent une
certaine limite fixée par la ROM de démarrage concernant la taille du disque.
Trouver cette limite peut être compliquée.

<p>
Et c'est une autre raison pour <a href="faq4.html#Partitioning">partitionner
votre disque dur</a>, plutôt que d'utiliser une seule grosse partition.

<h3>fsck(8) : impératifs de durée et de mémoire</h3>
Les autres points à prendre en considération avec les gros systèmes de fichiers
sont le temps et la mémoire nécessaires à l'utilisation de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)
</a> après un crash ou une coupure de courant. On ne peut pas créer un
système de fichiers de 120Go sur un disque et espérer utiliser fsck(1) avec
succès après un crash. Une règle simple à appliquer est de considérer que le
système doit posséder au moins 1Mo de mémoire libre pour chaque 1Go d'espace
disque afin d'utiliser fsck sans problème. La partition de swap peut
être mise à contribution mais avec un coût tellement élevé au niveau des
performances que cela en devient généralement inacceptable excepté dans
certains cas. 

<p>
Le temps nécessaire à l'utilisation de fsck peut devenir
un problème au fur et à mesure que le système de fichiers grossit, mais
vous n'avez besoin d'utiliser fsck que sur les systèmes de fichiers montés.
C'est une autre raison de NE pas allouer tout l'espace disque Juste Parce
Qu'il Est Là.
Garder le système de fichier monté en Read-Only ou ne pas le monter du tout
permet d'éviter de le fsck(8)er après l'arrachage du câble d'alimentation.
Réduire le nombre d'inodes (en utilisant l'option -i de newfs)
peut aussi améliorer le temps de fsck -- en supposant que vous
n'avez vraiment pas besoins d'eux.

<p>
N'oubliez pas que si vous avez plusieurs disques sur le système, ils
pourraient se retrouver tous à devoir subir un fsck(8) en même temps
après un crash et donc demander plus de RAM qu'un disque seul.

<h3>FFS vs. FFS2</h3>
Utilisant FFS, OpenBSD supporte un système de fichiers individuel avec
2<sup>31</sup>-1 (soit 2,147,483,647) blocs et chaque secteur possède une
taille de 512 octets, ce qui est un petit peu moins que 1To.
FFS2 est capable de supporter des disques beaucoup plus grands, donc il
faudra longtemps avant d'atteindre les nouvelles limites du système de
fichiers.

<p>
Les noyaux de démarrage/installation <i>supportent seulement FFS</i>, pas
FFS2, donc les partitions systèmes clés (<tt>/, /usr, /var, /tmp</tt>) ne
doivent pas être en FFS2 ou de sérieux problèmes de maintenance arriveront
(il n'y a aucune raison pour avoir ces partitions aussi large de toute façon).
Pour cette raison, les partitions très grandes doivent être utilisées 
uniquement pour des partitions "non-système", par exemple <tt>/home, /var/www/
,/bigarray</tt>, etc.

<p>
Il faut remarquer que tous les contrôleurs et pilotes ne supportent pas les
grands disques.
Par exemple,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ami&amp;sektion=4">ami(4)</a>
a une limite de 2To par volume logique.
Faites toujours attention à ce qui était disponible quand un contrôleur ou une
interface a été fabriqué, et ne vous fiez pas seulement à "l'adéquation des connecteurs".

<p>
<h3>Disques de plus de 2To</h3>
Le système MBR utilisé sur les ordinateurs repère uniquement les disques
jusqu'à 2To de taille.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8">fdisk(8)</a>
va reporter une taille de 2To pour les disques de plus de 2To.
Cela ne nuit en aucune façon à la capacité d'OpenBSD à utiliser
des disques plus grands. Comme le MBR est utilisé uniquement pour
l'amorçage de l'OS, une fois que l'OS est en cours d'exécution, les
systèmes de fichiers sont définis par le disklabel, qui n'a pas de
limite de 2To.

<p>
Pour utiliser un disque de plus de 2To, créez une partition OpenBSD
sur le disque en utilisant fdisk, quelle que soit la taille que fdisk
vous affichera. Lorsque vous étiquetez le disque avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>,
utilisez l'option "b" pour mettre les limites d'OpenBSD (qui sont
par défaut à la taille de la partition fdisk OpenBSD) pour couvrir
le disque entier. Maintenant, vous pouvez créer vos partitions
comme bon vous semble.
Vous devez toujours respecter les capacités de votre BIOS, 
qui aura la limitation de seulement comprendre les partitions fdisk,
donc votre partition 'a' devrait entièrement être dans la partie
du disque gérée par fdisk, en plus de toutes les limitations du BIOS.


<p>
<a name="InstBoot"></a>
<h2>14.9 - Installation des blocs de démarrage ("Bootblocks") - spécifique
à i386/amd64</h2>

<p>
OpenBSD possède un boot loader très robuste qui est indifférent à la géométrie
des disques, mais pas indifférent à l'endroit où le fichier
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>/boot</a></tt> se situe sur le disque.
Si vous effectuez une manipulation ayant pour cause de déplacer boot(8)
vers un autre endroit sur le disque (en fait un nouvel inode), vous
"casserez" votre système l'empêchant de démarrer normalement.
Pour réparer votre bloc de démarrage afin que vous puissiez booter
normalement, insérez un CDROM dans votre lecteur (ou utilisez une
disquette bootable) et à l'invite de commandes, tapez "<tt>boot hd0a:/bsd</tt>"
afin de le forcer à démarrer sur le premier disque (et non sur le CD ou la disquette).
Votre machine devrait se lancer normalement. Vous devez à présent
réinstaller le chargeur de premier niveau
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>) en se basant sur le nouvel emplacement du fichier
<tt>/boot</tt> en utilisant le programme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>.

<p>
Notre exemple suppose que votre disque de démarrage est sd0 (mais pour
de l'IDE, ce pourrait être wd0, etc...) :

<blockquote><pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre></blockquote>

Notez que "/boot" est l'emplacement physique du fichier "boot" que vous
souhaitez utiliser étant donné que le système est actuellement monté.
Si votre situation était un peu différente et que vous avez booté depuis
le CD et monté la partition 'a' sur /mnt, cela devrait probablement être
"/mnt/boot" à la place.
installboot(8) fait deux choses ici -- il installe le fichier "biosboot"
où cela est nécessaire pour être dans la partition Boot Record, et le
modifie avec l'emplacement physique du fichier "/boot".

<a name="Backup"></a>
<h2>14.10 - Se préparer au désastre : faire une sauvegarde vers une bande et
effectuer une restauration</h2>

<h3>Introduction :</h3>

<p>
Si vous envisagez d'administrer ce que l'on pourrait appeler un serveur de
production, il est préférable d'avoir une sauvegarde au cas où l'un de vos
disques durs tomberait en panne ou que les données seraient perdues d'une
autre façon.

<p>
Cette documentation vous assistera dans l'utilisation des utilitaires standards
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">
dump(8)</a>/<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">
restore(8)</a> fournis avec OpenBSD. Des utilitaires de sauvegarde plus avancés,
comme "<a href="http://www.amanda.org">Amanda</a>" et
"<a href="http://www.bacula.org">Bacula</a>" sont disponibles
via les <a href="../fr/faq15.html#PkgMgmt">ports</a> afin de sauvegarder plusieurs
serveurs vers des disques et lecteurs de bandes.

<h3>Sauvegarder vers une bande :</h3>

<p>
Sauvegarder sur bande demande de savoir exactement où vos systèmes de fichiers
sont montés. Vous pouvez le déterminer en utilisant la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)
</a> dans un terminal. Vous devriez obtenir une sortie similaire à celle-ci :

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
Dans cet exemple, le système de fichiers racine (/) réside physiquement sur
sd0a, ce qui désigne la partition 'a' du disque de type SCSI fixé à 0. Le système de
fichiers /usr réside sur sd0h, la partition h du disque de type SCSI fixé à 0.

<p>
Un autre exemple de ce qu'une table de montage plus avancée pourrait être :

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
Dans cet exemple plus compliqué, le système de fichiers racine (/) réside
physiquement sur sd0a ; /var sur sd0d; /home sur sd0e et enfin /usr sur sd0h.

<p>
Afin de sauvegarder votre machine, vous aurez besoin de renseigner dump avec le
nom exact de chaque partition fixe. Voici un exemple des commandes nécessaires
pour sauvegarder la table de montage simple vue plus haut :

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Pour la table de montage plus avancée, vous utiliserez des commandes similaires
à :

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Vous pouvez vous référer à la page de manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)
</a> afin de connaître les fonctionnalités de chaque option. Voici une brève
description des paramètres utilisés :

<ul>
<li><b>0</b> - Effectue un dump de niveau 0, sauvegarde tout.
<li><b>a</b> - Tente de détecter automatiquement la taille de la bande.
<li><b>u</b> - Met à jour le fichier /etc/dumpdates afin de savoir quand la
dernière sauvegarde a été effectuée.
<li><b>f</b> - Lecteur de bande à utiliser (ici /dev/nrst0).
</ul>

<p>
Et finalement, la partition à sauvegarder (/dev/rsd0a, etc...).

<p>
La commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
est utilisée à la fin pour rembobiner la bande. Référez-vous au manuel de mt
afin de connaître les options disponibles (comme eject).

<p>
Si vous n'êtes pas sûr du nom de périphérique du lecteur, utilisez dmesg pour le
localiser. Un lecteur de bande peut, par exemple, apparaître ainsi dans dmesg :

<blockquote><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></blockquote>

<p>
Vous avez peut-être noté que, lors d'une sauvegarde, le lecteur est accédé par
son nom de périphérique "<tt>nrst0</tt>" au lieu de "<tt>st0</tt>" qui apparaît
dans dmesg. Lorsque vous accédez <tt>st0</tt> à la place de <tt>nrst0</tt>, vous
accédez au même lecteur bande mais en mode "raw" et en lui indiquant de ne pas
rembobiner la bande à la fin du travail. Pour sauvegarder plusieurs systèmes de
fichiers sur une même bande, soyez certains d'utiliser le périphérique de
non-rembobinage ; dans le cas contraire (si vous utilisez <tt>rst0</tt>), la
sauvegarde du système de fichiers précédent sera écrasée à la prochaine écriture
sur la bande. Vous pouvez trouver une description plus conséquente de plusieurs
lecteurs de bande dans la page de manuel de dump.

<p>
Si vous souhaitez écrire un petit script appelé "backup", il pourrait ressembler
à celui-ci :

<blockquote><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre></blockquote>

<p>
Si des sauvegardes nocturnes planifiées sont nécessaires, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)
</a> pourra être utilisé pour lancer votre utilitaire de sauvegarde
automatiquement.

<p>
Il serait également utile de préciser (sur un bout de papier) la taille que
devrait avoir chaque système de fichiers. Vous pouvez utiliser "<tt>df -h</tt>"
afin de connaître l'espace actuellement utilisé par chaque partition. En effet,
ceci pourra vous aider lorsque votre disque dur tombera en panne et que vous
devrez recréer la table de partition sur le nouveau disque.

<p>
Restaurer vos données aidera aussi à réduire la fragmentation. Afin d'être sûr
de récupérer tous les fichiers, le meilleur moyen de sauvegarder est de
redémarrer votre système en mode "single user". Les systèmes de fichiers n'ont
pas besoin d'être montés pour être sauvegardés. N'oubliez pas de monter la
racine (/) en mode r/w (lecture/écriture) après avoir redémarré en mode "single
user" ou dump retournera une erreur lorsqu'il essayera d'écrire les "dumpdates".
Au démarrage, entrez "<tt>bsd -s</tt>" à l'invite de commandes boot&gt; pour
lancer le système en mode "single user".

<h3>Voir le contenu d'une sauvegarde sur bande :</h3>


<p>
Après avoir sauvegardé votre système de fichiers pour la première fois, il est
bon de vérifier rapidement votre bande afin d'être certain que les données
sont bien présentes.

<p>
Vous pouvez utiliser l'exemple suivant afin de voir le catalogue de fichiers
présents sur une bande :

<blockquote><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></blockquote>

<p>
Cette commande affichera la liste des fichiers présents sur la première
partition de la bande. Si l'on se réfère à l'exemple précédent, 1 serait votre
système de fichiers racine (/).

<p>
Pour afficher se qui est présent sur la deuxième partition vers un fichier, vous
utiliserez une commande similaire à :

<blockquote><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></blockquote>

<p>
Pour une table de partition assez simple, 2 serait /usr ; si la vôtre est plus
compliquée, 2 pourrait être /var/ ou un autre système de fichiers. L'ordre des
séquences est similaire à celui utilisé pour sauvegarder les systèmes de
fichiers sur la bande.


<h3>Restaurer à partir d'une bande :</h3>

<p>
Le scénario de l'exemple suivant pourrait être utile si votre disque tombait
complètement en panne. Dans le cas où vous ne souhaiteriez récupérer qu'un seul
fichier à partir de la bande, référez-vous à la page de manuel de la commande
restore et soyez attentifs aux instructions concernant le mode interactif.

<p>
Si vous avez bien tout préparé, remplacer un disque et restaurer vos données à
partir d'une bande peut être une procédure très rapide. La disquette standard
install/boot sous OpenBSD contient déjà l'utilitaire restore ainsi que les
exécutables nécessaires au partitionnement de votre nouveau disque et permettant
de le rendre bootable. Dans la plupart des cas, cette disquette et votre bande
de sauvegarde la plus récente sont tout ce dont vous avez besoin pour remettre
votre machine en production.

<p>
Après avoir remplacé le disque en panne, suivez les étapes suivantes afin de
restaurer vos données :

<ul>
<li>
<p>
Démarrez à partir de la disquette install/boot d'OpenBSD. Au menu, choisissez
Shell. Insérez la bande de votre sauvegarde la plus récente bande, en lecture
seule, dans votre lecteur.
<br>
<li>
<p>
En vous aidant de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">
fdisk(8)</a>, créez une partition primaire OpenBSD sur le nouveau disque. Par
exemple :

<blockquote><pre>
# <b>fdisk -e sd0</b>
</pre></blockquote>

<p>
Référez-vous à l'<a href="#fdisk">Utilisation de fdisk(8) sous OpenBSD</a> pour
de plus amples informations.

<li>
<p>
Avec la commande disklabel, recréez votre table de partition OpenBSD à
l'intérieur de la partition primaire que vous venez de créer avec fdisk. Par
exemple :

<blockquote><pre>
# <b>disklabel -E sd0</b>
</pre></blockquote>

<p>
(N'oubliez pas la partition d'échange, swap, référez-vous à <a
href="#disklabel">Utilisation de disklabel</a> pour plus d'informations)

<li>
<p>
Utilisez la commande newfs pour créer un système de fichier vierge sur chaque
partition que vous venez de créer. Par exemple :

<blockquote><pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre></blockquote>

<li>
<p>
Monter votre nouvelle partition racine (/) sur /mnt. Par exemple :

<blockquote><pre>
# <b>mount /dev/sd0a /mnt</b>
</pre></blockquote>

<li>
<p>
Allez dans le nouveau répertoire racine et démarrez la procédure de
restauration. Par exemple :

<blockquote><pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre></blockquote>

<li>
<p>
Vous aurez besoin de rendre ce disque bootable, inspirez-vous la commande
suivante pour y inscrire un nouveau MBR. Par exemple :

<blockquote><pre>
# <b>fdisk -i sd0</b>
</pre></blockquote>

<li>
<p>
En plus d'inscrire un nouveau MBR, vous aurez besoin d'installer les blocs de
démarrage afin de pouvoir lancer la machine. Voici un bref exemple :

<blockquote><pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></blockquote>

<li>
<p>
Votre nouveau système de fichiers racine devrait être suffisamment prêt pour
que vous puissiez démarrer dessus et continuer de restaurer le reste de vos
systèmes de fichiers. Puisque votre système d'exploitation n'est pas encore
complet, soyez sûrs de redémarrer en mode single-user. À l'invite de commandes,
effectuez la procédure suivante afin de démonter et redémarrer le système :

<blockquote><pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre></blockquote>

<li>
<p>
Retirez la disquette install/boot du lecteur et redémarrez votre machine. À
l'invite de commandes de boot d'OpenBSD, lancez les commandes suivantes :

<blockquote><pre>
boot&gt; <b>bsd -s</b>
</pre></blockquote>

<p>
La commande "bsd -s" ordonnera au noyau de démarrer en mode single-user qui ne
nécessite que le système de fichiers racine (/).

<li>
<p>
En admettant que vous ayez effectué correctement les étapes précédentes et que
tout se soit bien passé, vous devriez vous retrouver à une invite de commandes
vous demandant le chemin d'accès à un shell ou d'appuyer sur entrée. Appuyez sur
entrée pour utiliser sh. Ensuite, vous devrez remonter la racine en mode r/w
plutôt qu'en lecture seule. Lancez la commande suivante :

<blockquote><pre>
# <b>mount -u -w /</b>
</pre></blockquote>

<li>
<p>
Une fois la racine en mode r/w, vous pourrez continuer à restaurer vos autres
systèmes de fichiers. Par exemple :

<blockquote><pre>
<i>(table de montage simple)</i>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

<i>(table de montage avancée)</i>
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></blockquote>

<p>
À la place, vous pourriez utiliser "<b>restore rvsf</b>" ou juste rsf pour voir
le nom des fichiers extraits de la sauvegarde.

<li>
<p>
Pour terminer, après avoir restauré tous vos systèmes de fichiers sur le disque,
redémarrez en mode multi-utilisateurs. Si tout s'est déroulé comme prévu, votre
système devrait se retrouver dans l'état dans lequel il se trouvait à la date
de votre sauvegarde la plus récente et être totalement fonctionnel.
</ul>

<a name="MountImage"></a>
<h2>14.11 - Montage des images disque sous OpenBSD</h2>

<p>
Pour monter une image disque (images ISO, images disques créées avec dd, etc...)
sous OpenBSD, vous devez configurer un périphérique <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)
</a>. Par exemple, si vous avez une image ISO localisée dans <i>/tmp/ISO.image
</i>, voici les étapes nécessaires pour la monter :

<blockquote><pre>
# <b>vnconfig vnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/vnd0c /mnt</b>
</pre></blockquote>

<p>
Remarquez que, puisqu'il s'agit d'une image ISO-9660 utilisée sur les
CDs et DVDs, vous devez spécifier le type <i>cd9660</i> lors du montage.
Ceci est vrai peut importe le type, par exemple, vous devez utiliser
<i>ext2fs</i> lors du montage d'images disque Linux.

<p>
Pour démonter une image, utilisez les commandes suivantes.

<blockquote><pre>
# <b>umount /mnt</b>
# <b>vnconfig -u vnd0</b>
</pre></blockquote>

<p>
Pour plus d'information, référez-vous à la page de manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">
vnconfig(8)</a>.

<p>
<a name="pciideErr"></a>
<h2>14.12 - À l'aide ! J'ai des erreurs avec IDE DMA !</h2>

<p>
Les transferts IDE DMA supportés par <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">
pciide(4)</a> ne sont pas fiables avec plusieurs combinaisons de matériel
ancien.

<p>
OpenBSD est agressif et tente d'utiliser le mode DMA le plus haut qu'il puisse
configurer. Ceci pourrait engendrer une corruption dans le transfert des données
sur certaines configurations à cause de certaines puces ("chipsets") de cartes
mères, de disques de mauvaise qualité et/ou de la friture sur les câbles.
Heureusement, les modes Ultra-DMA protègent les transferts de données avec CRC
afin de détecter une éventuelle corruption. Si le CRC de l'Ultra-DMA échoue,
OpenBSD affichera un message d'erreur et recommencera l'opération de transfert.

<blockquote><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></blockquote>

<p>
Après plusieurs échecs, OpenBSD fera descendre le mode Ultra-DMA (à priori plus
fiable). Lorsqu'un mode Ultra-DMA atteint 0, le mode PIO prendra le relais.

<p>
Les erreurs UDMA sont souvent causées par des câbles endommagés ou de mauvaise
qualité. C'est pourquoi les câbles devraient être les premiers suspectés si vous
avez de nombreuses erreurs de DMA ou des performances dégradées. De plus, il
n'est pas conseillé de placer un lecteur de CD-ROM sur la même nappe qu'un
disque dur.

<p>
Si le remplacement des câbles ne résout pas le problème et qu'OpenBSD n'arrive
pas à faire descendre le niveau UDMA, que votre machine se fige ou que vous
obtenez trop de messages d'erreur sur la console et dans les logs, vous pouvez
forcer le système à utiliser un mode DMA ou UDMA inférieur par défaut. Ceci peut
être effectué avec <a href="faq5.html#BootConfig">UKC</a> ou <a
href="faq5.html#config">config(8)</a> afin de changer les options du
périphérique <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>.


<p>
<a name="NegSpace"></a>
<h2>14.14 - Pourquoi est-ce que <tt>df(1)</tt> me dit que j'ai plus de 100%
d'espace disque utilisé ?</h2>
Certaines personnes sont parfois surprises de voir qu'elles ont un
espace disque disponible <i>négatif</i> ou que plus de 100% de l'espace
d'un système de fichiers est utilisé, comme on peut le voir avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>.

<p>
Lorsqu'un système de fichiers est créé avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)
</a>, un certain montant d'espace disque inaccessible aux utilisateurs
est réservé. Cela permet d'avoir une marge d'erreur en cas de
remplissage accidentel du disque et de garder la fragmentation au
minimum. Par défaut, l'espace réservé correspond à 5% de la capacité du
disque ce qui signifie que si root a imprudemment rempli le disque, vous
pouvez vous retrouver avec 105% de capacité disponible utilisée.

<p>
Si une valeur de 5% ne vous semble pas appropriée, vous pouvez la
changer avec la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">
tunefs(8)</a>.

<p>
<a name="OhBugger"></a>
<h2>14.15 - Récupération de partitions après une suppression du
disklabel</h2>

<p>
Si vous avez une table de partitions endommagée, vous disposez de
plusieurs moyens afin d'essayer de la récupérer.

<p>
Premièrement, paniquez.
Vous le faites relativement souvent, et ceci devrait donc bien se
passer.
Cependant, ne faites rien de stupide.
Paniquez à l'écart de votre machine.
Ensuite, relaxez-vous, et voyez si les étapes suivantes ne pourraient
pas vous aider.

<p>
Une copie de votre disklabel est sauvegardée pour chaque disque dans
<tt>/var/backups</tt> via la maintenance système journalière. À
condition d'avoir encore votre partition var, vous pouvez simplement
lire la sortie, et la réintégrer dans disklabel.

<p>
Dans le cas où vous ne pouvez plus voir cette partition, il y a deux
options. Corriger une assez grande partie du disque afin de la voir, ou
fixer une partie suffisamment grande du disque afin de pouvoir récupérer
vos données.

Selon ce qui s'est passé, l'une ou l'autre de ces deux solutions serait
préférable (avec des disques mourants vous voudrez en premier les
données, avec des doigts mouillés vous ne pourrez avoir que le label).

<p>

Le premier bon outil dont vous avez besoin est
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(remarquez l'underscore, il ne s'appelle pas "scanffs").
scan_ffs(8) regardera au travers du disque, et essaiera de trouver les
partitions, en vous avertissant des informations qu'il trouve sur
celles-ci).
Vous pouvez utiliser ces informations pour recréer le disklabel. Si vous
voulez uniquement restaurer <tt>/var</tt>, vous pouvez recréer la
partition pour <tt>/var</tt>, et ensuite récupérer le label et ajouter
le reste.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
mettra à jour à la fois la compréhension du disklabel par le noyau, et
essaiera également d'écrire le label sur le disque. Ainsi, même si la
partie du disque qui contient le disklabel est illisible, vous serez en
mesure de la monter avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
jusqu'au prochain redémarrage.

<p>
<a name="foreignfs"></a>
<h2>14.16 - Est-il possible d'accéder aux données présentes sur des
systèmes de fichiers autres que FFS ?</h2>
<!-- This article written by Steven Mestdagh,
steven@@openbsd.org, and released under the BSD license -->

Oui. Les systèmes de fichiers supportés sont : ext2 (Linux), ISO9660 et
UDF (CD-ROM, DVD), FAT (MS-DOS et Windows), NFS, et NTFS (Windows).
Certains n'ont qu'un support limité, comme par exemple l'accès
en lecture uniquement.

<p>
Nous allons donner un aperçu sur la façon d'utiliser un de ces systèmes
de fichiers sous OpenBSD. Afin d'utiliser un système de fichiers,
celui-ci doit être monté. Pour plus de détails sur les options de
montage, référez-vous au manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">
mount(8)</a> ainsi qu'à celui correspondant au système de fichiers que
vous souhaitez monter. Par exemple, mount_msdos, mount_ext2fs, ...

<p>
Tout d'abord, vous devez connaître le périphérique sur lequel votre
système de fichiers est présent. Cela peut être tout simplement votre
disque dur, <tt>wd0</tt> ou <tt>sd0</tt>, mais ça n'est pas toujours
évident. Tous les périphériques reconnus et configurés par votre système
apparaissent dans la sortie de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">
dmesg(1)</a> : un nom de périphérique, suivi par une ligne descriptive.
Ainsi, mon premier CD-ROM est reconnu de la façon suivante :

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Afin d'obtenir une liste beaucoup plus courte des disques disponibles,
vous pouvez utiliser
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.
La commande

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

affichera tous les disques reconnus par votre système, par exemple :

<blockquote><pre>
hw.disknames=cd0:,cd1:,wd0:,fd0:,cd2:
</pre></blockquote>

<p>
À présent, il est temps de déterminer quelles partitions sont présentes
sur le périphérique et sur quelle partition le système de fichiers qui
nous intéresse est présent. Nous examinerons le périphérique en
utilisant <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a>. Le 'disklabel' comporte une liste de partitions, 16 au
maximum. La partition c désigne toujours le périphérique dans son
ensemble. Les partitions a-b et d-p sont utilisées par OpenBSD. Les
partitions i-p peuvent être allouées automatiquement aux systèmes de
fichiers d'autres systèmes d'exploitation. Dans notre cas, j'analyserai
le 'disklabel' de mon disque dur qui contient un certain nombre de
systèmes de fichiers.

<p>
<b>REMARQUE : OpenBSD a été installé après les autres systèmes
d'exploitation</b> sur cette machine et pendant l'installation, le
disklabel contenant les partitions pour systèmes de fichiers natifs et
étrangers a été installé. Cependant, si vous ajoutez des systèmes de
fichiers étrangers après l'installation du disklabel d'OpenBSD vous
devrez probablement les ajouter ou les modifier ultérieurement. Cette
procédure est expliquée <a href="#foreignfsafter">ici</a>.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A
duid: d920a43a5a56ad5f
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
boundstart: 20338290
boundend: 49656915
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # /
  b:       1638000      20746656    swap
  c:      78165360             0  unused
  d:       4194288      22384656  4.2BSD   2048 16384   16 # /usr
  e:        409248      26578944  4.2BSD   2048 16384   16 # /tmp
  f:      10486224      26988192  4.2BSD   2048 16384   16 # /var
  g:      12182499      37474416  4.2BSD   2048 16384   16 # /home
  i:         64197            63 unknown
  j:      20274030         64260 unknown
  k:       1975932      49656978   MSDOS
  l:       3919797      51632973 unknown
  m:       2939832      55552833  ext2fs
  n:       5879727      58492728  ext2fs
  o:      13783707      64372518  ext2fs 

</pre></blockquote>

<p>
Comme on peut le constater, les partitions OpenBSD sont affichées en
premier. Puis l'on peut voir un certain nombre de partitions ext2, une
partition MSDOS ainsi que plusieurs partitions inconnues ('unknown').
Sous i386 ou amd64, vous pouvez généralement en savoir plus sur
celles-ci en utilisant l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">
fdisk(8)</a>. Pour le lecteur curieux, la partition i est une partition
de maintenance créée par le revendeur, la partition j est une partition
NTFS et la partition l est une partition d'échange Linux ('Linux swap').

<p>
Après avoir déterminée la partition que vous souhaitez utiliser, vous
pouvez enfin monter le système de fichiers qu'elle contient. La plupart
des systèmes de fichiers sont supportés par de noyau GENERIC :
référez-vous à son fichier de configuration situé dans le répertoire
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt>. Si vous souhaitez
utiliser un de ces systèmes de fichiers, vous devrez
<a href="faq5.html#Options">recompiler votre noyau</a>.

<p>
Une fois les informations nécessaires entre vos mains, il est temps de
monter le système de fichiers. Imaginons que le répertoire
<tt>/mnt/otherfs</tt> existe, nous l'utiliserons pour monter le système
de fichiers souhaité. Dans l'exemple suivant, nous monterons un système
de fichiers ext2 dans la partition m :

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

<p>
Si vous souhaitez utiliser ce système de fichiers régulièrement, vous
gagnerez du temps en insérant la ligne suivante dans votre fichier
<tt>/etc/fstab</tt> :

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Notez les valeurs 0 dans les cinquièmes et sixièmes champs. Cela indique
que nous ne souhaitons pas que le système de fichiers soit sauvegardé
(avec dump) ni vérifié avec fsck. Généralement, il est préférable de
laisser le système d'exploitation associé à ces systèmes de fichiers
s'occuper de cela.

<p>
<a name="foreignfsafter"></a>
<h3>14.16.1 - Les partitions n'apparaissent pas dans mon disklabel ! Que
dois-je faire ?</h3>

Si vous installez des systèmes de fichiers étrangers sur votre machine
(souvent suite à l'ajout d'un système d'exploitation) après
l'installation d'OpenBSD, un disklabel sera présent mais ne sera pas mis
à jour automatiquement pour prendre en compte les nouveaux systèmes de
fichiers. Si vous souhaitez pouvoir y accéder, vous aurez besoin
d'ajouter ou de modifier ces partitions manuellement en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Pour prendre un exemple, j'ai modifié une de mes partitions ext2
existantes : en utilisant le programme fdisk de Linux, j'ai réduit la
taille de la partition 'o' (voir la sortie de disklabel plus haut) à 1Go.
Il sera facile de la reconnaître grâce à sa position de départ
(offset: 64372518) et sa taille (13783707) sur le disque. Notez que ces
valeurs sont exprimées en numéros de secteurs (et pas en mégaoctets ou
autre mesure) et qu'utiliser de tels nombres reste le moyen le plus sûr
et le plus précis d'obtenir ces informations.

<p>
Avant notre changement, la partition ressemblait à ceci (en utilisant le
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
d'OpenBSD et en ne gardant que ce qui nous intéresse) :

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Comme vous pouvez le voir, la position de départ et la taille sont
exactement les mêmes que celles rapportées précédemment par
disklabel(8) (ne vous méprenez pas sur par la valeur indiquée par
"Offset" : il s'agit de la position de départ de la partition étendue à
laquelle la partition ext2 fait partie).

<p>
Après avoir changé la taille de la partition sous Linux, elle ressemble
à ceci :

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Ceci doit être changé par disklabel(8). Vous pouvez, par exemple,
utiliser <tt>disklabel -e wd0</tt> qui lancera l'éditeur correspondant à
la variable d'environnement EDITOR (par défaut il s'agit de vi). Une
fois dans l'éditeur, changez la dernière ligne du disklabel afin qu'elle
corresponde à la nouvelle taille :

<blockquote><pre>
  o:       2104452      64372518  ext2fs
</pre></blockquote>

Pour terminer, enregistrez le disklabel sur le disque. Maintenant que le
disklabel est à jour, vous devriez pouvoir monter vos partitions comme
indiqué précédemment.

<p>
Vous pouvez suivre une procédure similaire afin d'ajouter de nouvelles
partitions.

<p>
<a name="flashmem"></a>
<h2>14.17 - Est-il possible d'utiliser un périphérique de masse 
('flash memory device') sous OpenBSD ?</h2>
<a name="flashmemPortable"></a>
<h3>14.17.1 - mémoire flash comme périphérique de stockage portable</h3>
<!-- This article written by Steven Mestdagh,
steven@@openbsd.org, and released under the BSD license -->

Théoriquement, un périphérique mémoire devrait être reconnu dès son
insertion dans la machine. Peu après l'avoir branché, un certain nombre
de messages du noyau devraient apparaître sur la console. Ainsi, lorsque
je branche mon périphérique USB, voici ce qui apparaît sur la console :

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Ces lignes indiquent que le pilote <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">
umass(4)</a> (périphérique de masse USB -'USB mass storage') a été
rattaché au périphérique mémoire et qu'il utilise le système SCSI. Les
deux dernières lignes sont les plus importantes : elles indiquent sur
quel fichier de périphérique le matériel a été rattaché ainsi que le
montant total d'espace de stockage. Si vous avez manqué ces lignes, vous
pouvez vous y référer plus tard à l'aide de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">
dmesg(1)</a>. La géométrie CHS est fictive puisque le périphérique USB
est traité comme un disque SCSI classique.

<p>
Nous allons voir deux scénarios possibles.

<h4>Le périphérique est nouveau/vide et vous souhaitez l'utiliser
exclusivement avec OpenBSD.</h4>

Vous allez devoir initialiser un 'disklabel' sur le périphérique et
créer au minimum une partition. Pour plus de détails, lisez
<a href="#disklabel">Utilisation de disklabel(8) sous OpenBSD</a> ainsi
que sa <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
page de manuel</a>.

<p>
Dans cet exemple, je ne vais créer qu'une seule partition <i>a</i> dans
laquelle je placerai un système de fichiers FFS :

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Montons le système de fichiers créé dans la partition <i>a</i> sur
<tt>/mnt/flashmem</tt>. Si le point de montage n'existe pas, créez-le.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h4>Vous avez reçu le périphérique de quelqu'un avec qui vous souhaitez
échanger des données.</h4>

<p>
Il y a une grande chance que la personne en question n'utilise pas
OpenBSD, ce qui signifie qu'un système de fichiers étranger doit être
présent sur le périphérique. Nous allons donc devoir découvrir quelles
partitions sont présentes, comme décrit dans la section précédente :
<a href="#foreignfs">Est-il possible d'accéder aux données présentes sur
des systèmes de fichiers autres que FFS ?</a>.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122 
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Le 'disklabel' nous apprend qu'il n'y a qu'une seule partition <i>i</i>,
contenant un système de fichiers FAT créé sur une machine Windows.
Comme d'habitude, la partition <i>c</i> représente l'ensemble du disque.

<p>
À présent, nous allons monter le système de fichiers présent dans la
partition <i>i</i> vers <tt>/mnt/flashmem</tt>.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Vous pouvez désormais l'utiliser comme n'importe quel autre disque.

<p>
<b>ATTENTION :</b>
Vous devriez toujours <b>démonter</b> le système de fichiers <b>avant de
débrancher</b> le périphérique de masse. Si vous ne le faites pas, le
système de fichiers pourrait être laissé dans un état inconsistant ce
qui aurait pour résultat d'avoir des données corrompues.

<p>
Après avoir débranché le périphérique de votre machine, vous verrez à
nouveau des messages du noyau sur la console :

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<a name="flashmemBoot"></a>
<h3>14.17.2 - Mémoires Flash comme disque de démarrage</h3>
<!-- This article written by Nick Holland
nick@@openbsd.org, and released under the BSD license -->
On peut utiliser les mémoires flash de différentes façons comme
disque de démarrage avec OpenBSD.
Cela peut être fait avec des périphériques USB (en s'assurant que
votre ordinateur peut démarrer sur un périphérique flash USB, ce qui
n'est pas le cas pour tous) ou non USB (par exemple CF) avec des
adaptateurs IDE ou SATA.
(Les périphériques non USB attachés a un adaptateur USB sont traités comme
un périphérique USB.)
Dans certains cas, vous pouvez actuellement utiliser un périphérique des
deux façons (chargez le média dans l'adaptateur USB, mais utilisez
un adaptateur IDE).

<p>
Un périphérique flash attaché à un port USB sera visible comme un périphérique
SCSI 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4">sd(4)</a>.
Attaché à une adaptateur IDE, il sera visible comme un périphérique
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>.

<p>
Dans le cas d'un média flash dans un adaptateur IDE, il pourra être
démarré de tout système qui peut démarrer un disque dur IDE sur le même
adaptateur. D'un certain sens, le système voit le média flash comme un
disque IDE. Configurez simplement le matériel de manière appropriée,
et installez OpenBSD sur le disque flash comme d'habitude.

<p>
Dans le cas de démarrage d'un périphérique USB, votre système doit être
capable de démarrer d'un périphérique USB sans être distrait par un autre
périphérique sur le système.
Il faut remarquer que si votre intention est de faire un environnement
portable de démarrage sur un périphérique USB, vous préférerez vraiment
utiliser les <a href="#DUID">DUIDs</a>, plus que la traditionnelle notation
"<tt>/dev/sd0X</tt>". Le périphérique USB va apparaître comme un disque
SCSI, parfois sd0. Sans les DUIDs, si vous branchez ce périphérique dans un
système ayant déjà quelques disques de type SCSI (i.e., périphériques
attachés à une interface ahci(4)) branchés, il se terminera probablement
par un identifiant différent, ce qui compliquera l'utilisation de ce
périphérique flash de système en système, vous devriez donc mettre
à jour <tt>/etc/fstab</tt>. L'utilisation des DUIDs résout ce problème.

<p>
Quelques remarques :
<ul>
<li><b>Vitesse :</b> En général, les périphériques flash sont beaucoup plus
lents que les disques durs, spécialement en cas d'écriture.
Utiliser <a href="#SoftUpdates">soft updates</a> aidera considérablement,
en utilisant aussi l'option de montage "noatime".

<li><b>"fatigue d'écriture" :</b>
Beaucoup ont écris sur le nombre de fois qu'une cellule flash individuelle
peut-être réécrite avant incident.
En pratique cependant, il y a plusieurs façons pour qu'un périphérique flash
dysfonctionne, la fatigue d'écriture et juste l'une d'elle.
Les périphériques flash modernes vérifient l'écriture, et en cas de 
problème, realloueront le secteur défectueux avec un autre disponible.
La plupart des utilisateurs de périphériques flash ne seront jamais ennuyés
avec la "fatigue d'écriture".
Vous ferez probablement l'expérience de moins d'arrêt de service du à
des erreurs d'astuces "saines" utilisées pour éviter d'écrire sur le disque
flash plutôt que d'utiliser les disques comme média en lecture-écriture.


<li><b>Fiabilité :</b>
Le fait que les médias flash ne possèdent pas de partie mobile a fait croire
à beaucoup de personnes que les médias flash sont plus fiables que les disques
durs. 
Il n'est pas prouvé que l'utilisation de flash vous évitera les pertes de
données ou les disques défectueux.
Les gens ont rapporté de considérables variations dans la qualité des médias
flash, il est plus probable de considérer le stockage flash comme silencieux
et une alternative faible consommation au disque plutôt qu'un stockage sans
erreurs.

<li><b>Créer un disque flash USB de démarrage :</b>
Bien qu'un périphérique USB ne peut seulement démarrer que sur une machine
supportant les disques USB, il peut être crée sur n'importe quelle machine
qui supporte le matériel USB.
Vous pourrez, bien sûr, être incapable de tester votre travail tant que vous
ne posséderez pas un système démarrant sur USB.

<li><b>Aller d'une interface IDE vers USB :</b>
Depuis que le média flash peut-être lu et écrit aussi bien d'un adaptateur 
USB et IDE, vous pouvez créer un média pour démarrer avec un de ces types
d'adaptateurs mais le maintenir ou l'utiliser avec un autre type d'adaptateur.

<li><b>Partager OpenBSD et d'autres partitions sur un périphérique :</b>
OpenBSD considère les disques flash comme tous les autres disques donc vous
pouvez utiliser 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8">fdisk(8)</a>
pour partitionner le périphérique flash, comme sur un disque dur.
Vous pouvez avoir un système de fichiers OpenBSD sur une partition et utiliser
une autre partition pour d'autres systèmes de fichiers, par exemple FAT32.
Cependant tous les systèmes de fichiers ne sont pas traités en USB de façon 
"égale".
Windows, en particulier, ne voudra pas utiliser ou créer une partition qui
ne commencera pas au début du périphérique, tout comme les outils de 
partionnement Windows ne vous permettront pas de partitionner le disque,
ils respecteront les partitions existantes.
Donc, si vous souhaitez créer un disque flash USB qui puisse démarrer avec
OpenBSD, mais aussi fonctionne comme un périphérique FAT32 sur d'autres OS,
vous voudrez faire quelque chose comme cela :

  <ol>
  <li>Partitionnez le média avec le fdisk d'OpenBSD, créer une partition du
      type désiré pour Windows qui utilise le début du disque et une
      partition OpenBSD à la fin du disque.
  <li>Installez OpenBSD comme d'habitude sur la partition fdisk OpenBSD,
      n'oubliez pas de marquer la partition OpenBSD comme "Active" pour
      démarrer.
  <li>Formatez les autres partitions.
      Cela peut être (et doit l'être) fait sur l'OS "cible" (Windows dans
      notre cas).
  </ol>

Il faut remarquer que si le type de l'autre partition est choisi de 
manière appropriée, il est possible qu'OpenBSD accède aux deux partitions
sur le périphérique.
Donc, un utilisateur Windows peut mettre sur la partition FAT32 des fichiers
MP3 qui pourront être joués quand ils seront démarrés de la partition OpenBSD.

</ul>

<a name="flashmemLive"></a>
<h3>14.17.3 -  Comment puis-je créer un périphérique de démarrage USB "Live" ?</h3>
Il est très facile de créer un disque flash USB de démarrage (ou autre !)
qui puisse être utilisé comme un système OpenBSD "live" sans installer OpenBSD
sur le disque dur local de la machine.
Évidemment, la machine cible doit pouvoir démarrer d'un périphérique USB,
mais le chargement initial peut-être fait de n'importe quelle machine avec
une interface USB.
 
<p>
Des raisons pour lesquelles vous voudriez le faire :
<ul>
<li>Une "machine" sécurisée, portable que vous pouvez emporter dans votre poche.

<li>Résoudre des problèmes dans OpenBSD et d'autres installations avec des
outils qui ne sont pas disponibles dans <a href="faq4.html#bsd.rd">bsd.rd</a>.

<li>Évaluer le matériel pour une compatibilité avec OpenBSD au moment de l'achat.

<li>Installer les machines qui manquent de toute autre forme de média de démarrage. 

<li>Collectez des sorties <a href="faq4.html#SendDmesg">dmesg</a> des
ordinateurs de vos amis !
(Les dmesg d'OpenBSD sont utiles pour identifier le matériel, cela peut être
un bonne façon de préparer l'installation pour d'AUTRES OS sur une machine
-- soyez sûr d'avoir tous les bons pilotes nécessaires avec de démarrer).

</ul>

Créer un tel "disque OpenBSD live" est simple.
<ul>
<li>Montez le périphérique USB sur la machine sur laquelle vous allez l'installer.
<li>Démarrez votre média d'installation favoris d'OpenBSD.
<li><a href="faq4.html">Installez</a> normalement, soyez attentionné en
sélectionnant votre disque flash comme cible d'installation.
<li>Démarrez votre nouveau périphérique USB crée.
</ul>

Voilà !

<p>
Il y a certaines choses que vous voudrez faire après l'installation pour
améliorer vos résultats :

<ul>
<li>Installez tous les paquetages et utilitaires que vous désirez
disponibles.
<li>Des machines cibles différentes auront des NICs différents.
Vous pouvez créer plusieurs fichiers
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
dans <tt>/etc</tt>, chacun contenant uniquement <tt>dhcp</tt>, pour tous les
NICs que vous rencontrerez (fxp0, re0, rl0, bge0, bnx0, em0, etc...)
sur les machines démarrant en USB, plus peut-être des exemples de fichiers
de configuration sans-fil bien évidemment.
OpenBSD ignorera tous les fichiers hostname.if(5) pour les périphériques non
présent au démarrage.

<li>Vous pouvez avoir envie de posséder une copie des fichiers
d'installation et peut-être aussi de fichiers paquetage .tgz comme cela vous
pourrez utiliser le disque comme média d'installation (démarrez bsd.rd à la
place de le laisser démarrer normalement). 

<li>Sur la plupart des machines, X "fonctionnera" sans fichier de configuration,
mais vous pouvez avoir envie de collecter les fichiers de configuration X
pour les systèmes qui en ont besoin.

<li><a href="#SoftUpdates">Soft updates</a> sera quelque chose que vous
voudrez utiliser.

<li>Pour un maximum de flexibilité, vous voudrez plutôt utiliser
<a href="../../fr/i386.html">i386</a> plutôt que
<a href="../../fr/amd64.html">amd64</a>.
Cependant, si vous voulez l'utiliser comme média d'installation, vous pouvez
avoir un amd64 bsd.rd et les fichiers d'installation en plus de i386.

<li>Utilisez les <a href="#DUID">DUIDs</a> pour identifier vos partitions.
<li>Vous pouvez désirer avoir une partition FAT sur le disque USB, créez la
comme détaillé <a href="#flashmemBoot">ci-dessus</a>.

<li>Vous pouvez avoir envie d'utiliser 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">softraid(4)</a>
pour chiffrer une partition de données.

</ul>
  
<p>
<a name= "DiskOpt"></a>
<h2>14.18 - Optimiser les performances des disques durs</h2>

<p>
La performance des disques est un facteur significatif de la
vitesse globale de votre machine. Ce facteur devient de plus en plus
important quand votre machine héberge un environnement multi utilisateur
(des utilisateurs de toutes les catégories tels que les utilisateurs qui
se connectent de manière interactive et les utilisateurs qui voient
votre machine comme un serveur de fichiers ou un serveur Web). Le
stockage de données demande une attention constante et particulièrement
quand vos partitions ne contiennent plus d'espace libre ou quand vos
disques ne fonctionnent plus. OpenBSD possède peu d'options pour
augmenter la vitesse des opérations sur disque.

<p>
<ul>
<li><a href="#Optsoftu">Soft Updates</a>
<li><a href="#Optmaxvnodes">Taille du cache namei()</a>
</ul>

<p>
<a name="Optsoftu"></a>
<h3>14.18.1 - Soft Updates</h3>

Un outil important qui peut être utilisé pour accélérer la vitesse de votre
système est softupdates. La mise à jour des informations meta ou
metainfo (qui a lieu quand vous créez ou supprimez des fichiers et des
répertoires entre autres) est une des opérations les plus lentes du
système de fichiers BSD traditionnel. Softupdates tente de mettre à jour
les metainfo dans la RAM au lieu d'écrire chaque mise à jour de metainfo
sur le disque. Une autre conséquence est que les metainfo sur le disque
devraient être toujours complètes, mais pas forcément à jour.
Pour en savoir plus, consultez <a href="#SoftUpdates">La FAQ Softupdates
</a>.

<p>
<a name="Optmaxvnodes"></a>
<h3>14.18.2 - Taille du cache namei()</h3>

Le cache de traduction nom-vers-inode (alias name-to-inode ou <!-- need to
write the manual page first... <a href="">namei(3)</a> -->namei()) contrôle 
la vitesse de la traduction chemin vers 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>.
Un moyen raisonnable de fixer une valeur pour le cache, si on venait
à remarquer à l'aide d'un outil comme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>
des erreurs d'allocation au niveau du cache, est d'examiner la valeur
courante générée avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
(qui appelle ce paramètre "<tt>kern.maxvnodes</tt>"), et d'augmenter
cette valeur soit jusqu'à ce que le taux de réponse à partir du
cache namei s'améliore, soit jusqu'à ce qu'on détermine que le système ne
bénéficie plus substantiellement de l'augmentation de la taille du cache
namei. Une fois que la valeur est déterminée, vous pouvez la fixer au
démarrage du système à l'aide de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>.

<p>
<a name= "Async"></a>
<h2>14.19 - Pourquoi nous n'utilisons pas de montage asynchrone ("async
       mount") ?</h2>

<p>
Question : &quot;Je fais simplement &quot;mount -u -o async /&quot; ce
qui rend un paquetage dont j'ai besoin (qui touche à une centaine
de chose de temps à autre) utilisable. Pourquoi le montage
asynchrone n'est pas vu d'un bon &#156;il et n'est pas activé par
défaut (comme c'est le cas sur d'autres versions d'Unix) ? C'est
un mécanisme sûrement plus simple et plus sûr
d'améliorer les performances de certaines applications.&quot;

<p>
Réponse : "les montages asynchrones sont en effet plus rapides que
des montages synchrones, mais ils sont aussi moins sûrs. Qu'arrive-t-il
dans le cas d'une panne de courant ? Ou un problème matériel ? la quête
de la vitesse ne doit pas sacrifier la fiabilité et la stabilité du
système. Reportez-vous à la page du manuel de
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>."

<pre>
             async   All I/O to the file system should be done asynchronously.
                     This is a dangerous flag to set since it does not guaran-
                     tee to keep a consistent file system structure on the
                     disk.  You should not use this flag unless you are pre-
                     pared to recreate the file system should your system
                     crash.  The most common use of this flag is to speed up
                     restore(8) where it can give a factor of two speed in-
                     crease.
</pre>

<p>
D'un autre côté, quand vous travaillez avec des données temporaires que
vous pouvez recréer après un plantage, vous pouvez gagner en vitesse en
utilisant une partition à part montée en asynchrone, utilisée uniquement
pour ce type de données. Encore une fois, n'effectuez cette opération
<i>que si</i> vous ne voyez pas d'inconvénient à perdre toutes les
données de cette partition si quelque chose va mal. Pour cette raison,
les partitions
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
sont montées en mode asynchrone vu que de toute façon, elles vont être
écrasées et recréées après un redémarrage.

<a name="altroot"></a>
<h2>14.20 - Dupliquer sa partition root: altroot</h2>
OpenBSD fournit un dispositif "altroot" dans les scripts
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily&amp;sektion=8">daily</a>.
Si la variable d'environnement <tt>ROOTBACKUP=1</tt> est définie
soit dans <tt>/etc/daily.local</tt> soit dans le
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=5">crontab(5)</a>
de l'utilisateur root, et qu'une partition est spécifiée dans
<tt>/etc/fstab</tt> comme étant à monter dans <tt>/altroot</tt> avec les
options de montage "xx", le contenu entier de la partition root sera dupliqué
chaque nuit sur la partition <tt>/altroot</tt>.
En supposant que l'on veuille sauvegarder notre partition root vers
wd1a, nous devons ajouter les lignes suivantes dans <tt>/etc/fstab</tt>

<blockquote><pre>
/dev/wd1a /altroot ffs xx 0 0
</pre></blockquote>

et définir la variable d'environnement appropriée dans <tt>/etc/daily.local</tt>:
<blockquote><pre>
# <b>echo ROOTBACKUP=1 >>/etc/daily.local</b>
</pre></blockquote>

Étant donné que le processus altroot va également <i>capturer</i> le dossier
<tt>/etc</tt>, les changements dans les fichiers de configuration seront mis
à jour quotidiennement.

<p>
C'est une copie d'"image disque" effectuée avec dd(8), et non pas une copie
fichier-par-fichier. La taille de votre partition <tt>/altroot</tt> doit
être exactement la même que celle de la partition root, ou plus grande.
Aussi, les partitions root très grandes devraient être évitées pour ne pas
que le processus prenne trop de temps.

<p>
Pour une redondance complète, le reste des partitions devrait être
dupliqué également, via <a href="#softraid">softraid</a>, dump(8)/restore(8),
rsync, etc.
Cela peut être effectué manuellement ou automatiquement, par exemple avec
les scripts <tt>weekly.local</tt>, <tt>daily.local</tt>, ou <tt>monthly.local</tt>.

<p>
De manière générale, vous préférerez que votre partition "altroot" soit
sur un disque différent qui a été configuré pour être pleinement bootable,
au cas où le disque primaire crasherait.
Il est possible de disposer d'une partition "altroot" sur le même disque,
mais les bénéfices d'une telle configuration sont limités.

<p>
Notez que nous n'avons pas spécifié le périphérique altroot par son DUID,
mais par son nom de périphérique.
Nous voudrons probablement passer du périphérique primaire au périphérique
secondaire en cas de problème, et il est possible que ce périphérique
secondaire change si l'ordre des disques change également. Pour cette
raison, nous avons spécifié les partitions root et altroot dans
<tt>/etc/fstab</tt> par leurs noms de périphériques, et pas par leurs
DUIDs.


<a name="softraid"></a>
<h2>14.21 - Comment puis-je utiliser softraid(4)?</h2>
Le fonctionnement de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">Softraid(4)</a>
se définit par l'émulation d'un
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scsibus&amp;sektion=4">scsibus(4)</a>
avec des périphériques
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4">sd(4)</a>
effectuée en combinant un certain nombre de partitions
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
("chunks") dans un disque virtuel ("volume") avec la configuration RAID désirée (aussi
appelée "discipline"), comme par exemple RAID0, RAID1, RAID4, RAID5 ou Crypto.
(Note: pour le moment, seules les configurations RAID0, RAID1 et Crypto sont
pleinement supportées.)

<p>
Ce disque virtuel est traité comme tout autre disque; il est d'abord
partitionné avec <a href="#fdisk">fdisk(8)</a> (sur les plates-formes
qui disposent de fdisk) et avec <a href="#disklabel">disklabel(8)</a>,
puis il peut être monté et utilisé.

<p>
<h4>Quelques mots sur RAID en général:</h4>
<ul>
<li>Avant d'implémenter une solution RAID, comprenez bien ce que cela
    va et ne va pas faire pour vous.
    RAID n'est pas un remplacement pour une bonne stratégie de sauvegarde.
    RAID ne va pas forcément empêcher votre système de planter si
    une erreur de hardware survient.
    En fait, RAID pourrait ne pas empêcher un plantage du système après
    une simple erreur de disque.
    Dans le cas d'une solution RAID logicielle, cela ne va pas garantir
    la capacité à booter sur le disque qui a <i>survécu</i> si votre
    ordinateur ne peut pas faire autrement.

<li>Avant de mettre RAID en production, vous devez comprendre comment
    utiliser RAID pour prendre en charge les erreurs de disques.
    Il faut comprendre cela AVANT qu'une erreur survienne. Les RAID
    mal implémentés vont causer plus de dégâts qu'ils n'en empêcheront.
    Et c'est d'autant plus vrai si RAID vous fait croire que vous pouvez
    dormir sur vos deux oreilles sans craindre de désastre.

<li>Plus vos partitions RAID seront grosses, plus le temps de récupération
    d'une erreur sera long.
    En d'autres termes, évitez d'allouer la totalité de vos disques de
    500GO juste parce qu'ils sont disponibles.
    Remirrorer des disques de 500GO prend bien plus de temps que de
    remirrorer les 4GO que vous utilisez réellement.
    Un avantage des miroirs logiciels est que l'on peut contrôler
    quelle quantité de ces "grands" disques est réellement utilisée
    dans un RAID.

<li>Il y a un réflexe à vouloir RAIDer son système le plus possible.
    Mirrorer sa partition de boot dans un RAID logiciel est difficile,
    et souvent inutile, étant donné que la plupart des hardware PC ont
    des difficultés à booter sur un disque qui n'est pas le disque de
    boot primaire.
    Même le matériel qui PEUT booter sur d'autres disques va souvent
    avoir des difficultés à déterminer quand est-ce qu'un disque a
    planté pour éviter de booter dessus.
    Le système "<a href="#altroot">altroot</a>" d'OpenBSD peut s'avérer
    plus efficace pour certaines applications, étant donné qu'il fournit
    une copie des vieilles informations de configuration au cas où un
    changement ne fonctionnerait pas comme on s'y attendrait.

<li>RAID fournit de la redondance uniquement pour le système de disque.
    Plein d'installations ont besoin d'une redondance qui va au-delà de
    la simple redondance des disques, et pour certaines de ces installations,
    RAID pourrait s'avérer néfaste.
    Par exemple, prenons un ensemble de pare-feux <a href="faq6.html#CARP">CARP</a>és
    fournissant une redondance complète en cas d'erreur. Ici, l'ajout
    d'un RAID (matériel ou logiciel) ne fera que compliquer la
    configuration.
</ul>

<h3>14.21.1 - Effectuer l'installation</h3>
Les disques softraid peuvent être créés en utilisant les chunks
libres (ou ajoutés) après l'installation, mais ce qui suit est juste
un cas particulier (et simple) de l'ajout de softraid durant
l'installation.

<p>
Les outils pour assembler votre système softraid sont fournis dans
le système de base d'OpenBSD (pour ajouter des périphériques softraid
après l'installation), mais ils sont également disponibles sur le
CD-ROM et les kernels d'installation <a href="faq4.html#bsd.rd">bsd.rd</a>.
Ils ne sont pas fournis sur les disquettes par manque d'espace; mais
pour contourner le problème vous pouvez installer OpenBSD depuis votre
disquette, et ensuite booter depuis bsd.rd sur votre système installé
et poursuivre comme voulu.

<p>
Le processus d'installation diffère légèrement de celui
<a href="faq4.html">habituel</a>, car il faudra ici ouvrir un shell et
créer un disque softraid(4) avant d'effectuer l'installation. Une
fois le disque softraid(4) créé, vous pourrez poursuivre l'installation
(qui ne différera pas du processus habituel); vous prendrez toutefois
garde à bien placer les partitions que vous voulez RAIDer dans le
disque softraid que vous avez précédemment configuré.

<p>
Vous pouvez simplement pré-créer les partitions RAID, les assembler
dans un volume softraid(4) et laisser l'installeur se charger du reste,
mais il est probablement plus facile de créer vos partitions root, swap
et RAID avant d'invoquer l'installeur.

<p>
Cela signifie que vous allez devoir configurer soigneusement le disque
avant de lancer l'installeur.

<p>
Au démarrage, le kernel d'installation a des entrées <tt>/dev</tt> seulement
pour un périphérique wd(4) et un périphérique sd(4), donc vous allez devoir
créer plus de disques pour mettre en place votre périphérique softraid.

Ceci est normalement effectué automatiquement par l'installeur, mais vous
n'avez pas encore lancé l'installeur, et vous allez ajouter un disque
qui n'existait pas au démarrage.

Par exemple, si vous avez besoin d'un deuxième ou troisième périphérique
wd(4) et d'un deuxième périphérique sd(4) (souvenez-vous, les périphériques
softraid seront des périphériques sd(4)), vous pouvez taper ceci à
l'invite:

<blockquote><pre>
# <b>cd /dev</b>
# <b>sh MAKEDEV wd1 wd2 sd1</b>
</pre></blockquote>

Vous aurez maintenant un support complet pour sd0, sd1, wd0, wd1 et wd2.

<p>
Vous allez devoir <a href="#fdisk">fdisk(1)</a>er les disques physiques
(si approprié pour votre plate-forme -- soyez sûr de configurer le
deuxième disque de telle façon qu'il soit bootable!) et utiliser ensuite
<a href="#disklabel">disklabel</a> pour configurer les partitions.

<p>
Les étapes fdisk(8) qui suivent vont placer un MBR sur le disque et
une partition OpenBSD sur ce même disque.
Si vous souhaitez utiliser le disque entier pour OpenBSD (c'est-à-dire
que vous n'avez RIEN d'autre sur le disque), vous pouvez taper:

<blockquote><pre>
# <b>fdisk -iy wd0</b>
# <b>fdisk -iy wd1</b>
</pre></blockquote>

(Soyez sûr de comprendre ce que ces lignes signifient vis-à-vis de vos
données avant de les taper aveuglément!)
Sinon, vous allez devoir créer une partition OpenBSD à l'intérieur des
nouveaux disques.

<h4>Créer les partitions pour softraid</h4>
Lors de la création de la partition softraid(4), donnez-lui le type
"RAID" au lieu des habituels "4.2BSD" et "swap". Dans notre exemple,
nous allons créer nos partitions sur wd0:

<ul>
<li>wd0a  500M /
<li>wd0b  500M swap
<li>wd0m  10G RAID
</ul>

<blockquote><pre>
# <b>disklabel -E wd0</b>
Label editor (enter '?' for help at any prompt)
> <b>a a</b>
offset: [64] <b><i>ENTER</i></b> 
size: [30282461] <b>500m</b>
Rounding to cylinder (16065 sectors): 1028096
FS type: [4.2BSD] <b><i>ENTER</i></b> 
> <b>a b</b>
offset: [1028160]  <b><i>ENTER</i></b> 
size: [29254365] <b>500m</b>
Rounding to cylinder (16065 sectors): 1028160
FS type: [swap] <b><i>ENTER</i></b> 
> <b>a m</b>
offset: [3148740]  <b><i>ENTER</i></b>
size: [28226205] <b>10g</b>
Rounding to cylinder (16065 sectors): 20980890
FS type: [4.2BSD] <b>RAID</b>
> <b>q</b>
Write new label?: [y] <b><i>ENTER</i></b>
</pre></blockquote>

<p>
Maintenant, nous devons préparer le deuxième disque pour qu'il corresponde
à l'agencement du premier disque.
Étant donné que l'on utilise le système <tt>/altroot</tt>, nous voudrons
une partition 'a' sur le deuxième disque dont la taille sera la même que
celle de la partition 'a' du premier disque. 
On veut que le système puisse fonctionner avec le deuxième disque autant
qu'il fonctionne avec le premier, donc nous voudrons une partition swap
de taille similaire (bien qu'une taille un peu plus grande ou un peu plus
petite n'ait pas d'impact).
Nous voudrons également une partition RAID de la même taille que pour le
premier disque. Si les partitions RAID ne sont pas de la même taille, la
plus petite de ces deux partitions dictera la taille du volume RAID.

<p>
En clair, il suffit de répéter l'opération précédente sur le deuxième
disque, wd1.

<h4>Assembler le volume RAID</h4>
On suppose ici que vos deux partitions RAID sont wd0m et wd1m. Notez que
la lettre de la partition RAID est arbitraire, et n'est pas nécessairement
la même sur le deuxième disque; mais garder les mêmes lettres simplifie
bien souvent la résolution de problèmes.

<p>
Étant donné que softraid(4) cherche les disques qu'il doit assembler,
si votre disque a déjà été utilisé pour softraid, il est souvent
préférable d'utiliser dd(1) pour effacer le premier octet de chaque
partition avant d'aller plus loin:

<blockquote><pre>
# <b>dd if=/dev/zero of=/dev/rwd0m bs=1m count=1</b>
   ...
# <b>dd if=/dev/zero of=/dev/rwd1m bs=1m count=1</b>
   ...
</pre></blockquote>

<p>
Maintenant on crée notre nouveau disque softraid(4) en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8">bioctl(8)</a>:

<blockquote><pre>
# <b>bioctl -c 1 -l /dev/wd0m,/dev/wd1m softraid0</b>
</pre></blockquote>

Cela va créer un volume RAID1 ("<tt>-c 1</tt>") utilisant les
partitions listées ("<tt>-l /dev/wd0m,/dev/wd1m</tt>"), via
le driver <tt>softraid0</tt>.
S'il n'y a pas de périphériques sd(4) sur le système, cela va
devenir sd0.
Notez que si vous créez plusieurs périphériques RAID, soit sur un disque
soit sur plusieurs disques, vous devrez toujours utiliser le driver de
disque virtuel softraid0, et non pas "softraid1".
Retenez bien que "softraid0" est un contrôleur RAID virtuel; vous pouvez
gérer plusieurs disques virtuels via ce contrôleur.

<p>
Cela va donc créer un nouveau disque: "sd0" (si l'on suppose qu'il n'y
a pas d'autre périphérique sd(4) sur votre système).
Ce périphérique va désormais apparaître dans le dmesg en tant que nouveau
périphérique installé:

<blockquote><pre>
scsibus1 at softraid0: 1 targets
sd0 at scsibus2 targ 0 lun 0: &lt;OPENBSD, SR RAID 1, 005&gt; SCSI2 0/direct fixed
sd0: 10244MB, 512 bytes/sec, 20980362 sec total
</pre></blockquote>

montrant que nous avons maintenant un nouveau bus SCSI, et un nouveau disque.
Dorénavant, ce volume sera automatiquement détecté et assemblé au démarrage
du système.

<p>
À cause du fait que le nouveau périphérique puisse avoir des octets aléatoires
là où vous vous attendriez à un MBR et un disklabel, zéroer (c'est-à-dire
écrire des octets nuls, ou égaux à zéro) les premiers octets du nouveau
disque est hautement recommandé, si vous ne l'avez pas fait précédemment:

<blockquote><pre>
# dd if=/dev/zero of=/dev/rsd0c bs=1m count=1
</pre></blockquote>

Vous êtes maintenant prêt à installer OpenBSD sur votre système.
Continuez l'installation selon la méthode habituelle en invoquant
"install" à l'invite de commande.
Prenez soin de sélectionner "custom" pour disklabel, sinon votre
partition RAID sera écrasée!
Utilisez l'option 'n' de disklabel pour définir le point de montage
pour votre partition root, et créez les partitions sur votre nouveau
disque softraid (sd0 dans notre exemple) au lieu des disques non-RAID.

<p>
Maintenant vous pouvez redémarrer votre système, et si vous avez tout
fait correctement, il va automatiquement assembler l'ensemble RAID, et
monter les partitions appropriées.

<h3>14.21.3 - Notes à propos de Softraid</h3>
<h4>Complications quand d'autres disques sd(4) sont déjà présents</h4>
Les disques softraid sont assemblés <i>après</i> les disques IDE, SATA,
SAS et SCSI.
De ce fait, si le nombre de périphériques sd(4) change (ajout ou suppression
de périphérique -- ou si un périphérique plante), l'identifiant du disque
softraid va changer.

Pour cette raison, il est vraiment important d'utiliser les
<a href="faq14.html#DUID">DUID</a>s plutôt que les noms de disques dans
votre fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">fstab(5)</a>.

<p>
Cependant, vous ne voudrez probablement pas spécifier le périphérique root
par son DUID.

<h4>RAID1 avec trois disques?</h4>
Softraid supporte le RAID1 avec plus de deux "chunks", et les exemples de
la page de manuel montrent une configuration RAID1 à trois disques.
Le RAID1 duplique simplement les données sur tous les chunks; deux chunks
offrent une redondance complète, trois proposent une meilleure tolérance
à la panne. L'avantage de RAID1 avec trois disques (ou plus!) ou chunks est
que si l'un des disques tombe en panne, vous avez TOUJOURS une redondance
complète.
Voyez cela comme un hot spare qui n'a pas besoin de se reconstruire!
En théorie, un RAID1 avec trois disques est plus lent à l'écriture qu'un
RAID1 à deux disques, bien qu'il soit plus rapide à l'écriture que de
reconstruire deux disques en RAID1.

<a name="softraidDR"></a>
<h3>14.21.4 - Récupérer d'un désastre</h3>
C'est la section que vous voudrez passer, mais ne la passez pas.
C'est la raison de RAID: si les disques ne tombaient jamais en panne,
vous n'ajouteriez pas un RAID complexe à votre système !
Malheureusement, étant donné que les pannes sont difficiles à lister,
il y a une forte probabilité pour que le problème que vous rencontrez
ne soit pas décrit de manière exacte ici, mais si vous prenez le temps
de comprendre les stratégies ici et le pourquoi du comment, vous pouvez
espérer récupérer convenablement de n'importe quelle panne qui puisse
survenir.

<p>
Gardez à l'esprit que les pannes ne sont pas souvent simples à gérer.

L'auteur de cet article avait un disque dans une solution RAID hardware,
et lorsqu'un court-circuit est survenu il a dû remplacer d'une part le
disque, mais également l'alimentation électrique, l'enclos RAID et
l'alimentation électrique d'un second ordinateur dont le disque était
aussi tombé en panne. Il a également dû dire adieu aux sauvegardes,
étant donné qu'il avait mal configuré l'enclos de remplacement.
<!-- Hum hum hum ... -->

<p>
Les étapes nécessaires pour recouvrer le système peuvent être appliquées
en <a href="faq8.html#LostPW">mode utilisateur unique</a> ou depuis le
<a href="faq4.html#bsd.rd">noyau d'installation (bsd.rd)</a>.

<p>
Si vous avez l'intention de vous entraîner à récupérer d'une erreur
softraid (et nous vous incitons VIVEMENT à le faire !), vous
trouverez sans doute utile de zéroer un disque que vous venez de
retirer de l'ensemble RAID avant d'essayer de le remettre dans ce
même ensemble. D'une part, cela simule le remplacement d'un disque
avec un nouveau; d'autre part, cela évite toute confusion au cas où
le système détecterait des restes de RAID sur le disque.

<p>

Récupérer d'une panne sera souvent un événement en deux étapes: la
première est de remettre le système en marche, la seconde de reconstruire
l'ensemble qui est tombé en panne.
Ces deux étapes peuvent être séparées par un certain temps si vous
n'avez pas de disque de remplacement sous la main.

<h4>Récupérer d'une panne: disque secondaire</h4>
Cela est relativement simple. Vous pourriez avoir à enlever le disque
qui est tombé en panne pour remettre le système sur pieds.

<p>
Lorsque vous êtes prêt à réparer le système, vous devrez remplacer
le disque qui est tombé en panne, créer le RAID et les autres partitions
disklabel, puis reconstruire l'ensemble RAID.

En supposant que votre volume RAID est <tt>sd0</tt>, et que vous
souhaitez remplacer le disque qui est tombé en panne par <tt>wd1m</tt>,
les étapes suivantes devraient fonctionner:

<ul>
<li>Bootez le système.
<li>Créez les partitions appropriées sur votre nouveau disque
<li>Reconstruisez votre partition RAID:
<blockquote><pre>
# <b>bioctl -R /dev/wd1m sd0</b> 
</pre></blockquote>
<li>Redémarrez.
</ul>

<h4>Récupérer d'une panne: disque primaire</h4>
De nombreux ordinateurs ne peuvent pas booter depuis un disque secondaire
si le disque primaire est tombé en panne et est toujours branché (à moins
qu'il soit tellement en panne qu'il ne soit même plus détecté...).

Certains ordinateurs ne peuvent tout simplement pas booter sur un disque
qui n'est pas le disque primaire.

<p>
En général, si votre disque primaire tombe en panne, vous devrez l'enlever,
et bien souvent faire de votre disque secondaire un disque primaire. Cela
pourrait impliquer de <i>re-jumper</i> le disque (le <i>jumper</i> étant
une pièce métallique), ou de le brancher sur un autre port.
Bien évidemment, votre disque secondaire doit inclure votre partition RAID
et doit être bootable.

<p>
Une fois que votre système est remis en marche sur le disque secondaire
et qu'un nouveau disque a été introduit, reconstruisez votre RAID comme
décrit précédemment.


<h4>Récupérer d'un "mélangeage" de vos disques</h4>
Que se passe-t-il si vous avez quatre disques, disons sd0, sd1, sd2 et sd3,
et que pour quelque raison d'upgrade ou autre, vous en venez à enlever
tous vos disques et à ne plus vous souvenir du quel était lequel ?

<p>
Heureusement, softraid gère ce cas à merveille: il considère les
disques comme étant "vagabonds", mais sait tout de même reconstruire
l'ensemble RAID.
Cependant, le disque de boot de la machine doit être bootable, et si vous
avez effectué des changements dans la partition root avant de faire cela,
vous voudrez probablement vous assurer que vous n'avez pas booté sur votre
partition altroot par erreur.

<h3>14.21.5 - Softraid Crypto</h3>
Les volumes softraid(4) cryptés peuvent être mis en place très simplement:

<ul>
<li>Créez la partition désirée avec disklabel(8) et assignez-lui le type RAID
<li>Zéroez le début de la partition comme décrit plus haut.
<li><tt># <b>bioctl -c C -l /dev/sd0m softraid0</b><br>
New passphrase: <b><i>My Crypto Pass Phrase</i></b><br>
Re-type passphrase: <b><i>My Crypto Pass Phrase</i></b><br>
softraid0: CRYPTO volume attached as sd1</tt>
<li>fdisk(8)ez, disklabel(8)ez et newfs(8)ez ce nouveau volume.
</ul>

Une fois cela en place, vous pouvez "déverrouiller" le volume crypto avec:
<blockquote><pre>
# <b>bioctl -c C -l /dev/sd1m softraid0</b>
Passphrase: <b><i>My Crypto Pass Phrase</i></b>
softraid0: CRYPTO volume attached as sd1
</pre></blockquote>
Vous pouvez ensuite monter les partitions du volume crypté en utilisant
mount, comme d'habitude.

<p>
Pour déconnecter un disque crypto (et le rendre ainsi inutilisable),
démontez tous les systèmes de fichiers et utilisez la commande suivante
(où le volume crypté est sd1):
<blockquote><pre>
# <b>bioctl -d sd1</b>
</pre></blockquote>

La page de manuel pour cette commande peut faire peur, étant donné que la
commande -d y est décrite comme supprimant ("deleting") le volume; mais
dans le cas des disques crypto, cela désactive juste le volume encrypté
de telle façon que les données qu'il contient ne puissent pas être
accessibles sans mot de passe.

<p>
Bien d'autres options sont disponibles pour softraid, et de nouvelles
fonctionnalités apparaissent au fil du temps; prenez donc soin de consulter
les pages de manuel pour
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8">bioctl(8)</a>
et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">softraid(4)</a>.

<h4>J'ai oublié mon mot de passe!</h4>
Désolé, mais ça, c'est du vrai cryptage. Il n'y a ni backdoor ni outil
magique de déverrouillage. Si vous avez perdu le mot de passe de votre
volume softraid crypté, les données qu'il contient resteront
inutilisables.


<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a>
<a href= "faq13.html">[Section 13 - Multimédia]</a>
<a href= "faq15.html">[Section 15 - Paquetages et Ports]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.240 ]<br>
$Translation: faq14.html,v 1.112 2013/11/08 20:22:42 rustybsd Exp $<br>
-->
$OpenBSD: faq14.html,v 1.89 2013/11/11 07:18:59 ajacoutot Exp $
</small>

</body>
</html>
@


1.89
log
@Sync with Steelix CVS
@
text
@d3164 1
a3164 1
$OpenBSD$
@


1.88
log
@Sync with Steelix CVS
@
text
@d2463 2
a2464 3
<li>Montez le disque USB sur la machine sur laquelle vous allez l'installer.
<li>Démarrer votre média d'installation favoris d'OpenBSD.
<li>
d3162 1
a3162 1
$Translation: faq14.html,v 1.111 2013/11/01 16:50:38 rustybsd Exp $<br>
@


1.87
log
@Sync with Steelix CVS
@
text
@d1106 1
a1106 1
OpenBSD 5.3 (GENERIC) #50: Tue Mar 12 18:35:23 MDT 2013
d3162 2
a3163 2
Originally [OpenBSD: faq14.html,v 1.239 ]<br>
$Translation: faq14.html,v 1.110 2013/10/11 15:59:33 rustybsd Exp $<br>
@


1.86
log
@Sync with Steelix CVS
@
text
@a3095 4
Le système "<a href="#altroot">altroot</a>" d'OpenBSD peut s'avérer
plus efficace pour certaines applications, étant donné qu'il fournit
une copie des vieilles informations de configuration au cas où un
changement ne fonctionnerait pas comme on s'y attendrait.
d3162 2
a3163 2
Originally [OpenBSD: faq14.html,v 1.238 ]<br>
$Translation: faq14.html,v 1.109 2013/08/24 10:03:26 rustybsd Exp $<br>
@


1.85
log
@Sync with Steelix CVS
@
text
@d50 1
a50 1
d'OpenBSD/i386 et d'OpenBSD/amd64 ?</a>
d52 1
a52 1
grande capacité sous OpenBSD ?</a>
d54 1
a54 1
("Bootblocks") - spécifique à i386/amd64</a>
d56 1
a56 1
vers une bande et effectuer une restauration</a>
d58 3
a60 3
<li><a href="#pciideErr"  >14.12 - À l'aide ! J'ai des erreurs avec IDE DMA !
<li><a href="#NegSpace"   >14.14 - Pourquoi <tt>df(1)</tt> me dit que j'ai plus
de 100% d'espace disque utilisé ?</a>
d62 1
a62 1
suppression du disklabel</a>
d64 1
a64 1
présentes sur des systèmes de fichiers autres que FFS ?</a>
d67 1
a67 1
pas dans mon disklabel ! Que dois-je faire ?</a>
d70 1
a70 1
périphérique de masse ('flash memory device') sous OpenBSD ?</a>
d81 1
a81 1
Asynchrone ?</a>
d1848 2
a1849 2
<h2>14.14 - Pourquoi <tt>df(1)</tt> me dit que j'ai plus de 100% d'espace disque
utilisé ?</h2>
d3017 1
a3017 1
Les étapes nécessaires pour recouvrer le système peuvent êtres appliquées
d3167 1
a3167 1
$Translation: faq14.html,v 1.107 2013/08/15 13:29:45 rustybsd Exp $<br>
@


1.84
log
@Sync with Steelix CVS
@
text
@d27 1
a27 1
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC -->
d39 1
a39 1
<!-- -->
d43 1
a43 1
<li><a href="#intro"  >14.1 - Disques et Partitions</a>
d74 1
a74 1
  <li><a href="#flashmemBoot">14.17.2 -  Mémoires Flash comme disque de
d76 1
a76 1
  <li><a href="#flashmemLive">14.17.3 - Comment puis-je créer un
d79 2
a80 2
<li><a href="#DiskOpt">14.18 - Optimiser les performances des disques durs</a>
<li><a href="#Async">14.19 - Pourquoi nous n'utilisons pas de Montage
d82 2
d143 1
a143 1
<li> "disklabel partitions" créées avec 
d146 1
a146 1
<li> "fdisk partitions" créées avec 
d2622 530
d3166 2
a3167 2
Originally [OpenBSD: faq14.html,v 1.230 ]<br>
$Translation: faq14.html,v 1.106 2013/07/23 03:18:40 rustybsd Exp $<br>
@


1.83
log
@Sync with Steelix CVS
@
text
@d1290 3
a1292 3
Ce Qu'il Est La.
Garder le système de fichier monté RO ou pas monté aide à les garder du
besoin d'être fsck(8) après l'arrachage du câble d'alimentation.
d1380 1
a1380 1
Notre exemple assume que votre disque de démarrage est sd0 (mais pour
d2635 1
a2635 1
$Translation: faq14.html,v 1.105 2013/07/15 06:25:31 rustybsd Exp $<br>
@


1.82
log
@Sync with Steelix CVS
@
text
@d27 1
a27 1
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC
d33 1
a33 1
   <a href="../faq6.html">ici</a> pour des informations à jour.
d36 1
a36 1
Si vous souhaitez contribuez à l'effort de traduction, prière de consulter
d39 1
a39 1
-->
d2568 2
a2569 2
cette valeur soit jusqu'à ce que les le taux de réponse à partir du
cache namei s'améliore soit jusqu'à ce qu'on détermine que le système ne
d2635 1
a2635 1
$Translation: faq14.html,v 1.103 2013/05/12 15:51:40 rustybsd Exp $<br>
@


1.81
log
@Sync with Steelix CVS
@
text
@d439 1
a439 1
montage à partir de disklabel(8) et le changer plus tard pendant
d464 1
a464 2
# <b>disklabel wd0</b> &lt;-- <i>Selon le disque que vous souhaitez
vérifier</i>
d509 1
a509 1
que vos données soient sauvegardées avant d'éditer un disklabel
d1191 2
a1192 2
OpenBSD supporte les systèmes de fichiers FFS et FFS2 (aussi connu comme
UFS et UFS2).
d1196 1
a1196 1
regarder à des limites système plus générale. 
d1304 1
a1304 1
2<sup>31</sup>-1, ou 2,147,483,647 blocs et chaque secteur possède une
d1361 1
a1361 1
OpenBSD a un boot loader très robuste qui est indifférent à la géométrie
d2154 1
a2154 1
Pour terminer, enregistrez le disklabel sur le disque. À présent que le
d2172 2
a2173 2
insertion dans la machine. Peut après l'avoir branché, un certain nombre
de messages du noyau devrait apparaître sur la console. Ainsi, lorsque
d2187 1
a2187 1
umass(4)</a> (périphérique de masse USB -'USB mass storage') à été
d2192 1
a2192 1
pouvez vous y référez plus tard à l'aide de la commande <a
d2558 1
a2558 2
write the manual
page first... <a href="">namei(3)</a> -->namei()) contrôle 
d2561 1
a2561 1
Une valeur raisonnable de fixer une valeur pour le cache, si on venait
d2564 1
a2564 1
, des erreurs d'allocation au niveau du cache, est d'examiner la valeur
d2567 1
a2567 1
, (qui appelle ce paramètre "<tt>kern.maxvnodes</tt>") et d'augmenter
d2635 1
a2635 1
$Translation: faq14.html,v 1.102 2013/05/09 08:13:31 rustybsd Exp $<br>
@


1.80
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2012 by OpenBSD.">
d1055 1
a1055 1
     >> OpenBSD/i386 BOOT 3.18
d1095 1
a1095 1
>> OpenBSD/i386 BOOT 3.18
d1103 1
a1103 1
Copyright (c) 1995-2012 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1105 1
a1105 1
OpenBSD 5.2 (GENERIC) #278: Wed Aug  1 10:04:16 MDT 2012
d1334 1
a1334 3
va typiquement reporter une taille de disque du modulo de 2To, donc votre
disque de 2.7To (vendu en tant que 3To) s'affichera dans fdisk(8) avec
une taille aux alentours de 700Go.
d2636 2
a2637 2
Originally [OpenBSD: faq14.html,v 1.229 ]<br>
$Translation: faq14.html,v 1.101 2013/02/21 16:23:32 rustybsd Exp $<br>
@


1.79
log
@Sync with Steelix CVS
@
text
@d2638 2
a2639 2
Originally [OpenBSD: faq14.html,v 1.228 ]<br>
$Translation: faq14.html,v 1.100 2013/02/14 18:12:40 rustybsd Exp $<br>
@


1.78
log
@Sync with Steelix CVS
@
text
@d2638 2
a2639 2
Originally [OpenBSD: faq14.html,v 1.227 ]<br>
$Translation: faq14.html,v 1.99 2013/01/18 14:11:26 rustybsd Exp $<br>
@


1.77
log
@Sync with Steelix CVS
@
text
@d728 8
a735 3
Vous devriez monter le nouveau disque sur /mnt et utiliser <tt>cpio -
pdum</tt> pour copier /usr/local vers le répertoire /mnt. Éditez le
fichier
d2638 2
a2639 2
Originally [OpenBSD: faq14.html,v 1.226 ]<br>
$Translation: faq14.html,v 1.98 2013/01/05 09:01:34 rustybsd Exp $<br>
@


1.76
log
@Sync with Steelix CVS
@
text
@d450 1
a450 1
référez-vous à <a href="faq4.html#Disks">la configuration des
d2633 2
a2634 2
Originally [OpenBSD: faq14.html,v 1.225 ]<br>
$Translation: faq14.html,v 1.97 2012/12/30 07:57:33 ajacoutot Exp $<br>
@


1.75
log
@Sync with Steelix CVS
@
text
@d1232 1
a1232 1
  <li>Vous utilisez le système et finissez par avoir pus de 504Mo de données
d2634 1
a2634 1
$Translation: faq14.html,v 1.96 2012/11/01 19:46:20 rustybsd Exp $<br>
@


1.74
log
@Sync with Steelix CVS
@
text
@d388 1
a388 1
   
d693 1
a693 1
utiliser "96M" pour spécifier "96 mégaoctets" ou, 96G pour 96 gigaoctets. 
d767 2
a768 2
Cependant, vous pouvez aussi démarrer le système en mode mono-utilisateur et 
utiliser 
d806 1
a806 1
sur un autre disque, vous devez définir ces partitions dans <tt>/etc/fstab</tt> 
d864 1
a864 1
Voici un exemple montrant la création d'un fichier <i>/var/swap</i> d'une 
d1050 1
a1050 1
     >> OpenBSD/i386 BOOT 3.17
d1090 1
a1090 1
>> OpenBSD/i386 BOOT 3.17
d1100 1
a1100 1
OpenBSD 5.1 (GENERIC) #160: Sun Feb 12 09:46:33 MST 2012
d1111 2
a1112 2
or (E)dit the MBR?" lors de l'<a href="faq4.html#InstDisks">installation</a>, 
vous pourriez vous retrouver avec un disque sans MBR valide, le rendant ainsi 
d1285 1
a1285 1
C'est une autre raison de NE pas allouer tout l'espace disque Juste Parce 
d1289 1
a1289 1
Réduire le nombre d'inodes (en utilisant l'option -i de newfs)   
d1712 1
a1712 1
Retirez la disquette install/boot du lecteur et redémarrez votre machine. A
d2589 1
a2589 1
Réponse : &quot; les montages asynchrones sont en effet plus rapides que
d2633 2
a2634 2
Originally [OpenBSD: faq14.html,v 1.224 ]<br>
$Translation: faq14.html,v 1.95 2012/07/02 09:42:45 rustybsd Exp $<br>
@


1.73
log
@Sync with Steelix CVS
@
text
@d2633 2
a2634 2
Originally [OpenBSD: faq14.html,v 1.223 ]<br>
$Translation: faq14.html,v 1.94 2012/06/06 12:51:43 rustybsd Exp $<br>
@


1.72
log
@Sync with Steelix CVS
@
text
@d7 2
a8 2
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2009 by OpenBSD.">
d43 1
a43 1
<li><a href="#disklabel"  >14.1 - Utilisation de disklabel(8) sous OpenBSD</a>
d45 7
a51 6
<li><a href="#NewDisk"    >14.3 - Ajout de nouveaux disques sous OpenBSD</a>
<li><a href="#Swap"       >14.4 - Comment gérer l'espace de pagination</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Comment se déroule le processus de démarrage
d'OpenBSD/i386 ?</a>
<li><a href="#LargeDrive" >14.7 - Quels sont les problèmes liés aux disques de
d53 3
a55 3
<li><a href="#InstBoot"   >14.8 - Installation des blocs de démarrage
("Bootblocks") - spécifique i386/amd64</a>
<li><a href="#Backup"     >14.9 - Se préparer au désastre : faire une sauvegarde
d57 2
a58 4
<li><a href="#MountImage" >14.10 - Montage des images disque sous OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - A l'aide ! J'ai des erreurs avec IDE DMA !
</a>
<li><a href="#RAID"       >14.13 - Options RAID avec OpenBSD</a>
d86 300
d387 1
a387 1
<h2>14.1 - Utilisation de disklabel(8) sous OpenBSD</h2>
d414 1
a414 4
géométrie ou les systèmes de fichiers présents sur celui-ci. Ils
contiennent également des données sur le disque lui-même comme la
vitesse de rotation, l'ordonnancement etc, présentent pour des raisons
historiques et souvent incorrectes. Il est inutile de s'en inquiéter. Le
d428 1
a428 1
stocker *toutes* vos partitions OpenBSD (par exemple, 'swap', '/',
d437 1
a437 1
initiale des labels. A l'installation, vous utiliserez disklabel(8) afin
a465 3
# Inside MBR partition 3: type A6 start 63 size 29880837

# /dev/rwd0c:
d468 2
a469 1
label: Maxtor 51536H2
d475 4
a478 8
cylinders: 16383
total sectors: 29888820
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
d482 8
a489 8
#             size        offset  fstype [fsize bsize  cpg]
  a:        614817            63  4.2BSD   2048 16384  328 # Cyl     0*-   609 
  b:        409248        614880    swap                   # Cyl   610 -  1015 
  c:      29888820             0  unused      0     0      # Cyl     0 - 29651*
  d:       6291936       1024128  4.2BSD   2048 16384  328 # Cyl  1016 -  7257 
  e:        409248       7316064  4.2BSD   2048 16384  328 # Cyl  7258 -  7663 
  f:       1024128       9822960  4.2BSD   2048 16384  328 # Cyl  9745 - 10760 
  h:       2097648       7725312  4.2BSD   2048 16384  328 # Cyl  7664 -  9744 
d521 3
a523 3
offset: [10847088]
size: [19033812] 2g
Rounding to nearest cylinder: 4194288
d526 10
a535 23
device: /dev/rwd0c
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2  
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total bytes: 14594.2M
free bytes: 7245.9M
rpm: 3600

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        300.2M          0.0M  4.2BSD   2048 16384  328 # Cyl     0*-   609
  b:        199.8M        300.2M    swap                   # Cyl   610 -  1015
  c:      14594.2M          0.0M  unused      0     0      # Cyl     0 - 29651*
  d:       3072.2M        500.1M  4.2BSD   2048 16384  328 # Cyl  1016 -  7257
  e:        199.8M       3572.3M  4.2BSD   2048 16384  328 # Cyl  7258 -  7663
  f:        500.1M       4796.4M  4.2BSD   2048 16384  328 # Cyl  9745 - 10760
  h:       1024.2M       3772.1M  4.2BSD   2048 16384  328 # Cyl  7664 -  9744
  k:       2048.0M       5296.4M  4.2BSD   2048 16384   16 # Cyl 10761 - 14921
d585 1
a585 1
<li>(sparc/sparc64) <b> ne placez pas la partition swap au début du
d587 2
d590 9
a598 9
<li>(i386, amd64) <b> laissez la première piste ("track") libre :</b>
sur certaines plates-formes, vous devriez laisser la première piste
logique inutilisée dans disklabel(8) et fdisk(8). Cette recommandation
est parfois injustement précisée par "démarrez les partitions au secteur
63", ce qui n'est SEULEMENT valable que si elle correspond bien à la
taille d'une piste sur votre matériel. N'assumez en rien que cela soit
vrai, disklabel vous dira quel est le nombre de secteurs par piste. De
nombreuses autres plates-formes s'attendent à voir les partitions OpenBSD
démarrer au secteur 0.
d618 4
a621 53
</ul>

<a name="fdisk"></a>
<h2>14.2 - Utilisation de fdisk(8) sous OpenBSD</h2>

Avant de commencer, lisez le manuel de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.

<p>
fdisk(8) est utilisé sur certaines plates-formes (i386, amd64, macppc, zaurus et
armich) pour créer une partition reconnue par la ROM de démarrage du système dans
laquelle les partitions disklabel d'OpenBSD peuvent être inscrites. Les autres
plates-formes n'ont pas besoin d'utiliser fdisk(8).
fdisk(8) peut également être utilisé pour la manipulation du MBR ("Master boot
record") pouvant avoir un impact sur tous les systèmes présents sur la machine.
A l'inverse de certains programmes dont les fonctionnalités sont proches de
celles de fdisk, sous OpenBSD cette commande assume que vous savez ce que vous
voulez faire et en règle générale n'interviendra pas dans vos décisions, ce qui
en fait un outil très puissant. Il vous laissera également faire des choses que
vous n'aviez pas forcément prévues et doit donc être utilisé avec précaution.

<p>
Normalement, seule une partition fdisk OpenBSD sera inscrite sur le disque.
Cette partition sera divisée par <a href="#disklabel">disklabel</a> en
différentes partitions systèmes de fichiers OpenBSD.

<p>

<p>
Pour simplement voir votre table de partition avec fdisk, utilisez :

<blockquote><pre># <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Ce qui vous donnera une sortie similaire à celle-ci :

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD     
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
</pre></blockquote>

<p>
Dans cet exemple, nous voyons la sortie de fdisk concernant le premier
lecteur SCSI. Nous pouvons voir les partitions OpenBSD (A6). Le *
indique que la partition OpenBSD est amorçable.
a622 6
<p>
Dans l'exemple précédent, nous avons simplement accédé à une
information. Qu'en est-il si nous souhaitons éditer notre table de
partition ? Et bien, pour ce faire, nous devons utiliser l'option <b>-
e</b>. Ceci fera apparaître une invite de commandes pour interagir avec
fdisk.
a623 66
<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        swap            Swap two partition entries
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre></blockquote>

<p> 

<p>
Voici un aperçu des commandes disponibles lorsque vous utilisez l'option
<b>-e</b>.

<ul>
<li><b>help</b> Affiche la liste des commandes utilisables par fdisk en
    mode d'édition interactif.
<li><b>reinit</b> Initialise la copie en mémoire du bloc de démarrage
    actuellement sélectionné. Pratique pour initialiser une partition OpenBSD
    sur tout le disque, mettre à jour le code de démarrage et, de manière
    générale, préparer le système pour OpenBSD (et OpenBSD seulement).
<li><b>disk</b> Affiche la géométrie actuelle du disque détectée par
    fdisk. Vous pouvez l'éditer selon vos désirs.
<li><b>setpid</b> Change l'identifiant de partition de l'entrée
    sélectionnée de la table de partition.
<li><b>edit</b> Edite l'entrée sélectionnée de la table dans la copie
    mémoire du bloc de démarrage actuel. Vous pouvez entrer les valeurs
    en géométrie BIOS ou en secteurs, offsets et tailles.
<li><b>flag</b> Rend amorçable la partition sélectionnée. Seule une
    entrée peut être marquée comme amorçable. Si vous souhaitez démarrer
    à partir d'une partition étendue, vous devez la marquer comme
    amorçable.
(OpenBSD ne peut démarrer qu'à partir de partitions primaires, mais vous
pouvez marquer n'importe quelle partition comme étant amorçable).
<li><b>update</b> Met à jour le code machine dans la copie mémoire du
    bloc de démarrage actuellement sélectionné.
<li><b>select</b> Sélectionne et charge en mémoire le bloc de démarrage
    désigné par la table de partition étendue dans le bloc de démarrage
    actuel.
<li><b>swap</b> Echange deux entrées MBR afin que vous puissiez le réordonner.
<li><b>print</b> Affiche la copie en mémoire actuelle du bloc de
    démarrage et de son MBR sur le terminal.
<li><b>write</b> Ecrit la copie en mémoire actuelle du bloc de démarrage
    sur le disque. Vous serez amené à confirmer cette action.
<li><b>exit</b> Quitte le niveau actuel de fdisk, revenant à la copie
    précédente du bloc de démarrage ou sortant du programme si une telle
    copie n'existe pas.
<li><b>quit</b> Quitte le niveau actuel de fdisk, revenant à la copie
    précédente du bloc de démarrage ou sortant du programme si une telle
    copie n'existe pas. A l'inverse d'"exit", le bloc de démarrage
    modifié est inscrit sur le disque.
<li><b>abort</b> Quitte le programme sans sauvegarder les changements.
a625 26
<h3>trucs et astuces fdisk</h3>
<ul>
<!-- <li>On OpenBSD platforms which use fdisk, you should leave the first
track free.
This leaves room for the Master Boot Record, which is where the fdisk
partition table resides.  (not sure if this is true) -->
<li>fdisk(8) permet d'éditer les partitions soit en mode secteurs purs, soit en
utilisant les Cylindres/Têtes/Secteurs. Ces deux options sont disponibles pour
une raison ; certaines tâches sont plus simples à effectuer d'une façon ou d'une
autre. Ne vous limitez pas à l'utilisation d'une seule de ces deux options.
<li>Un disque vierge aura besoin qu'on y inscrive le code de démarrage dans le
MBR avant qu'il ne puisse booter. Pour ce faire, vous pouvez utiliser les
options "reinit" ou "update". Si vous ne le faites pas, vous écrirez une table
de partitions valide avec fdisk mais vous ne pourrez pas démarrer. Si vous ne
savez pas d'où vient le code de démarrage présent sur votre disque, il est
possible que vous souhaitiez le mettre à jour de toutes façons.
<li>Si votre système possède une partition de "maintenance" ou de
"diagnostique", il est recommandé de la laisser en place ou de l'inscrire avant
d'installer OpenBSD.
<li>Pour des raisons historiques, "q" enregistre les changements et quitte le
programme alors que "x" quitte sans sauvegarder. C'est l'opposé de ce que
beaucoup de gens peuvent voir sous d'autres environnements. fdisk(8) ne demandera
aucune confirmation avant d'enregistrer les changements alors utilisez cette
commande avec précaution

</ul>
d628 1
a628 1
<h2>14.3 - Ajout de nouveaux disques sous OpenBSD</h2>
d669 1
a669 1
en terme de constructeur de disques représente 3000 megaoctets. Divisons
d673 1
a673 1
e, f, g, ... multipliez simplement X par 2061 afin d'avoir X megaoctets
d693 1
a693 1
utiliser "96M" pour spécifier "96 megaoctets" ou, 96G pour 96 gigaoctets. 
d729 1
a729 1
pdum</tt> pour copier /usr/local vers le répertoire /mnt. Editez le
d746 2
a747 1

d749 1
a749 1
<h2>14.4 - Comment gérer l'espace de pagination ?</h2>
d751 1
a751 1
<h3>14.4.1 - A propos de la pagination</h3>
d755 1
a755 1
Le problème, bien sur, c'est qu'il y a peu d'applications "normales".
d777 1
a777 1
Si votre pare-feu est basé sur une flash, vous bénéficierez (légérement)
d780 1
a780 1
à personne; la plupart des disques possédent assez d'espace pour en allouer
d786 1
a786 1
dans une situation ou l'espace de pagination est une solution, vous avez
d798 1
a798 1
<h3>14.4.2 - Paginer sur une partition</h3>
d815 1
a815 1
<h3>14.4.3 - Paginer dans un fichier</h3> 
d821 4
a824 5
processus avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">
unlimit(1)</a> pour csh ou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">
ulimit(1)</a> pour sh)
d828 1
a828 1
fausse, et vous devez ajouter plus d'espace de pagination, occasionnelement
d884 1
a884 1
A présent, vérifions que ce fichier a bien été ajouté à la liste des
d909 1
a909 1
<h2>14.5 - Soft Updates</h2>
d941 1
d943 6
a948 5
<h2>14.6 - Comment se déroule le processus de démarrage d'OpenBSD/i386 ?</h2>
Le processus de démarrage d'un système OpenBSD/i386 est loin d'être
simple et une bonne compréhension de celui-ci peut être utile afin de
diagnostiquer un problème lorsque les choses ne fonctionnent pas. Ce
processus comporte quatre étapes clefs :
d951 2
a952 2
    (enregistrement de démarrage principal) est le premier secteur (512
    octets) du disque. Il contient la table de partition primaire et un
d959 6
a964 5
    OpenBSD sous-entend la réécriture complète du secteur MBR et pas
    seulement son code, comme cela peut être le cas avec certains
    systèmes. Vous n'en aurez l'utilité que très rarement. Pour ce
    faire, utilisez l'option "-u" de la commande fdisk(8) ("<tt>fdisk -u
    wd0</tt>").
d967 1
a967 1
Bien qu'un MBR soit inclut avec OpenBSD, vous n'êtes pas obligé de
d995 1
d1000 2
a1001 2
(d'après le nom du fichier contenant le code) représente le premier
secteur physique de la partition OpenBSD du disque. Le PBR est le
d1032 1
a1032 4
L'ancien biosboot(8) (avant la version 3.5) affichait le message
"<tt>reading boot...</tt>".


d1040 1
a1040 1
boot(8) est un programme intéractif. Après son exécution, il tente de
d1050 1
a1050 1
     >> OpenBSD/i386 BOOT 3.02
d1076 1
a1076 1

d1090 1
a1090 1
>> OpenBSD/i386 BOOT 3.02
d1098 1
a1098 1
Copyright (c) 1995-2008 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1100 2
a1101 2
OpenBSD 4.6 (GENERIC.MP) #89: Thu Jul  9 21:32:39 MDT 2009
   deraadt@@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC.MP
d1183 1
a1183 1
<h2>14.7 - Quels sont les problèmes liés aux disques de grande capacité sous
d1199 1
a1199 1
trés bien), certains
d1203 1
a1203 1
vous devez respecter les possibilités de votre matériel.
d1234 1
a1234 2
  <li>Vous mettez à jour, compilez un nouveau noyau et vous copiez votre
nouveau /bsd sur l'ancien.
d1253 2
a1254 2
<p>
<b>la partition racine dans son ensemble doit se situer dans l'espace
d1256 1
d1288 4
a1291 1
besoin d'être fsck(8) aprés l'arrachage du cable d'alimentation.
a1297 7
<p>
Avec le temps avoir un disque avec un système de fichiers plus grand que 1To
avec la taille de blocs et fragmentation par défaut, demande à fsck 1Go
de RAM pour fonctionner, qui sont les limites d'une application sous OpenBSD.
Des fragments et/ou blocs plus grands réduira le nombre d'inodes et
permettra des systèmes de fichiers plus grand.
 
d1300 1
a1300 1
2<sup>31</sup>-1, ou 2,147,483,647 secteurs et chaque secteur posséde une
d1311 1
a1311 1
Pour cette raison, les partitions trés grandes doivent être utilisées 
a1315 5
Avant de mettre à jour, vous devez marquer toutes les partitions FFS2 comme
"noauto" pour qu'elles ne soient (pas) prisent en compte par le noyau
d'installation (qui ne supporte pas les partitions FFS2).

<p>
d1320 32
a1351 4
a une limite de 2To ppar volume logique.
Beaucoup n'ont pas encore été testés, par exemple, à la date de rédaction de
ce document, il n'y a pas de disque IDE ou SATA >1To disponibles pour des tests,
donc nous ne pouvons pas affirmer que tout fonctionne correctement.
d1353 1
d1355 2
a1356 2
<h2>14.8 - Installation des blocs de démarrage ("Bootblocks") - spécifique
i386/amd64</h2>
d1359 2
a1360 4
Les versions récentes d'OpenBSD (3.5 et plus) possèdent un chargeur de
démarrage très robuste qui est beaucoup moins sensible à la géométrie
des disques que l'ancien. Cependant, il reste sensible à l'emplacement
du fichier
d1362 1
a1362 1
>/boot</a></tt> sur le disque.
d1365 5
a1369 5
"casserez" votre système l'empêchant de démarrer normalement. Pour
réparer votre bloc de démarrage afin que vous puissiez booter
normalement, insérez une disquette dans votre lecteur (ou utilisez un
CD-ROM bootable) et à l'invite de commandes, tapez "b hd0a:/bsd" afin de
le forcer à démarrer sur le premier disque (et non sur la disquette).
d1385 8
a1392 11
<p>
Si une nouvelle version des blocs de démarrage est nécessaire, vous devrez la
compiler vous même. Pour ce faire, tapez simplement :

<blockquote><pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (ou quelque soit le périphérique
désignant votre disque dur)
</pre></blockquote>
d1395 1
a1395 1
<h2>14.9 - Se préparer au désastre : faire une sauvegarde vers une bande et
d1403 2
a1404 1
disques durs tomberait en panne.
d1411 3
a1413 2
restore(8)</a> fournis avec OpenBSD. Un autre utilitaire de sauvegarde plus
avancé nommé "<a href="http://www.amanda.org">Amanda</a>" est également disponible
d1415 1
a1415 15
serveurs vers un unique lecteur de bandes. Dans la plupart des environnements, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)
</a>/<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">
restore(8)</a> suffit. Cependant, si vous avez besoin de sauvegarder plusieurs
machines, il peut être utile de se documenter sur Amanda.

<p>
Les périphériques utilisés en exemple dans ce document se réfèrent à une
configuration utilisant des disques et lecteurs de bandes SCSI. En environnement
de production, les disques SCSI sont recommandés en place des disques IDE pour
la façon dont ils gèrent les blocs défectueux. Ceci ne signifie pas pour autant
que ce document est sans intérêt pour les possesseurs de disques IDE ou d'autres
types de lecteurs de bandes, les noms de vos périphériques changeront
légèrement. Par exemple, sd0a deviendra wd0a dans un système à base d'IDE.
d1433 2
a1434 2
sd0a, ce qui désigne la partition a du disque SCSI fixe 0. Le système de
fichiers /usr réside sur sd0h, ma partition h du disque SCSI fixe 0.
d1597 1
a1597 1
complètement en panne. Dans le cas ou vous ne souhaiteriez récupérer qu'un seul
d1702 1
a1702 1
complet, soyez sûrs de redémarrer en mode single-user. A l'invite de commandes,
d1751 1
a1751 1
A la place, vous pourriez utiliser "<b>restore rvsf</b>" ou juste rsf pour voir
d1763 1
a1763 1
<h2>14.10 - Montage des images disque sous OpenBSD</h2>
d1773 2
a1774 2
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
d1788 1
a1788 1
# <b>vnconfig -u svnd0</b>
d1796 1
a1796 1

d1798 1
a1798 1
<h2>14.11 - A l'aide ! J'ai des erreurs avec IDE DMA !</h2>
d1803 2
a1804 5
pciide(4)</a> ne sont pas fiables avec plusieurs combinaisons de matériel.
Jusqu'à récemment, la plupart des "principaux" systèmes d'exploitation
prétendant supporter les transferts DMA sur périphériques IDE n'activaient pas
cette fonctionnalité par défaut à cause de certains matériels peu fiables. A
présent, beaucoup de ces machines sont utilisées sous OpenBSD.
d1842 1
a1842 87
<a name="RAID"></a>
<h2>14.13 - Options RAID avec OpenBSD</h2>
Un ensemble redondant de disques durs indépendants (RAID - "Redundant Array of
Inexpensive Disks") vous offre la possibilité d'utiliser plusieurs disques afin
d'améliorer les performances, la capacité et/ou la redondance qu'un disque seul
ne serait pas capable d'apporter. Bien qu'une description des avantages ou des
risques apportés par une configuration RAID ne soit pas le propos de cet
article, il est important de noter les points suivants :

<ul>
<li>Un RAID ne constitue pas un système de sauvegarde.
<li>Seul, un RAID n'éliminera pas le délais d'indisponibilité.
</ul>

Si ces informations sont nouvelles pour vous, ce document n'est pas un bon point
de départ pour débuter avec un RAID.

<h3>Options logicielles</h3>
OpenBSD inclut
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">softraid(4)</a>,
un framework supportant plusieurs types de transformations I/O, incluant le
RAID et différents chiffrements.
Softraid(4) est configuré en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8">bioctl(8)</a>.

OpenBSD inclut aussi RAIDFRAME
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
nécessite un noyau personnalisé), et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a> 
une implémentation historique de RAID, mais actuellement OpenBSD ne vous le
suggére pas pour implémenter une solution RAID pour une nouvelle
installation ou réinstallation.

<h3>Options matérielles</h3>
<p>
De nombreuses <a href="../../fr/plat.html">plates-formes</a> OpenBSD supportent
plusieurs contrôleurs RAID matériels. Ceux-ci varient selon les plates-formes,
référez-vous à la page des plates-formes supportées 
(listées <a href="../../fr/plat.html">ici</a>).

<p>
Remarquez que plusieurs contrôleurs RAID peuvent être configuré via le
pilote
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bio&amp;sektion=4">bio(4)</a>
et l'application
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8">bioctl(8)</a>.
Cela permet de surveiller et contrôler le système RAID d'une maniére
standard dans OpenBSD.

<p>
Une autre option accessible à plusieurs plates-formes est l'un des
nombreux produits qui font apparaître plusieurs disques comme un seul
disque IDE ou SCSI et sont ensuite branchés sur un contrôleur IDE ou
SCSI standard. Ces périphériques peuvent virtuellement fonctionner sur
n'importe quelle plate-forme supportant IDE ou SCSI.

<p>
Quelques fabriquants de ce type de produits :
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Note : ce sont des produits que certains utilisateurs d'OpenBSD
utilisent ; il ne s'agit en aucun cas d'une liste exhaustive ni de
matériels certifiés).


<h3>Options non valides</h3>
<p>
Une question récurrente sur les <a href="../../fr/mail.html">listes de
diffusion</a> consiste à savoir si "les contrôleurs RAID IDE ou SATA peu
coûteux (tels que les contrôleurs HighPoint, Promise ou Adaptec HostRAID) sont
supportés ?". La réponse est "Non". Ces cartes et puces ne sont pas de
véritables contrôleurs RAID matériels mais plutôt des RAID logiciels assistés
par un BIOS. Puisqu'OpenBSD supporte déjà le RAID logiciel indépendamment du
type de matériel, il n'y a pas de volonté parmi les développeurs OpenBSD
d'implémenter un support spécifique à ces cartes.

<p>
Presque tous ces contrôleurs "RAID" SATA ou IDE embarqués sont de type
logiciel et fonctionneront sans problème comme contrôleur SATA ou IDE
en utilisant le pilote IDE standard
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>),
mais ne fonctionneront pas comme RAID matériel sous OpenBSD.

d1867 1
d1882 1
a1882 1
Ensuite, relaxez vous, et voyez si les étapes suivantes ne pourraient
d1887 1
a1887 1
<tt>/var/backups</tt> via la maintenance système journalière. A
d1892 1
a1892 1
Dans le cas ou vous ne pouvez plus voir cette partition, il y a deux
d1923 1
a1923 1

d1931 2
a1932 2
UDF (CD-ROM, DVD), FAT (MS-DOS et Windows), NFS, NTFS (Windows) et
AmigaDOS. Certains n'ont qu'un support limité, comme par exemple l'accès
d1971 1
a1971 1
hw.disknames=cd0,cd1,wd0,fd0,cd2
d1975 1
a1975 1
A présent, il est temps de déterminer quelles partitions sont présentes
d2005 1
d2013 2
a2014 6
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
d2019 14
a2032 14
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581 
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206 
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544 
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367 
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773 
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176 
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*
d2052 3
a2054 5
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt>. Cependant, certains
dont le support est expérimental (comme NTFS) ne sont pas inclus dans le
noyau GENERIC. Si vous souhaitez utiliser un de ces systèmes de
fichiers, vous devrez <a href="faq5.html#Options">recompiler votre noyau
</a>.
d2082 1
d2101 1
a2101 1
valeurs sont exprimées en numéros de secteurs (et pas en megaoctets ou
d2152 1
a2152 1
Pour terminer, enregistrez le disklabel sur le disque. A présent que le
d2160 1
d2180 1
a2180 1
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
d2274 1
a2274 1
A présent, nous allons monter le système de fichiers présent dans la
d2307 1
a2307 1
Cela peut-être fait avec des périphériques USB (en s'assurant que
d2312 1
a2312 1
un périphérique USB).
d2314 2
a2315 2
deux façons (chargez le média dans l'adaptateur USB, pour utilisez le dans
un adaptateur IDE)
d2318 1
a2318 1
Un périphérique flash attaché a un port USB sera visible comme un périphérique
d2326 4
a2329 4
demarré de tout système qui peut démarrer un disque dur IDE. 
D'un certain sens, le système voit le média flash comme un disque IDE.
Configurez simplement le matériel de maniére appropriée, et installez
OpenBSD sur le disque flash comme d'habitude.
d2336 9
a2344 6
portable de démarrage sur un périphérique USB, le périphérique USB doit être
vu comme un disque SCSI, habituellement sd0.
Cependant, si vous insérez ce périphérique dans un système qui posséde
déjà quelques disques SCSI, il sera surement pris en compte avec un identifiant
différent, ce qui compliquera l'utilisation de ce périphérique flash de 
système en système, vous devrez donc mettre à jour <tt>/etc/fstab</tt>.
d2349 1
a2349 1
<li><b>Vitesse :</b> En general, les périphériques flash sont beaucoup plus
d2356 1
a2356 1
peut-être reécrite avant incident.
d2358 1
a2358 1
disfonctionne, la fatigue d'écriture et juste l'une d'elle.
d2360 1
a2360 1
problème, realloueront le secteur defectueux avec un autre disponible.
d2369 1
a2369 1
Le fait que les médias flash ne possédent pas de partie mobile a fait croire
d2372 2
a2373 2
Il n'est probablement pas prouvé que l'utilisation de flash vous évitera les
pertes de données ou les disques defectueux.
d2383 1
a2383 1
Vous pourrez, bien sur, être incapable de tester votre travail tant que vous
d2392 1
a2392 1
OpenBSD considére les disques flash comme tous les autres disques donc vous
d2415 2
a2416 2
  <li>Formattez les autres partitions?
      Cela peut-être (et doit l'être) fait sur l'OS "cible" (Windows dans
d2421 1
a2421 1
maniére appropriée, il est possible que OpenBSD accéde aux deux partitions
d2430 2
a2431 2
Il est trés facile de créer un disque flash USB de démarrage (ou autre !)
qui peut-être utilisé comme un système OpenBSD "live" sans installer OpenBSD
d2433 1
a2433 1
Evidemment, la machine cible doit pouvoir démarrer d'un périphérique USB,
d2443 1
a2443 1
outils qui ne sont pas disponibles dans <a href="faq4.html#bsd.rd">bsd.rd</a>
d2445 1
a2445 1
<li>Evaluer le matériel pour une compatibilité avec OpenBSD au moment de l'achat.
d2449 1
a2449 1
<li>Collecter des sorties <a href="faq4.html#SendDmesg">dmesg</a> des
d2451 1
a2451 1
(Les dmesg d'OpenBSD sont utiles pour identifier le matériel, cela peut-être
d2470 1
a2470 1
Il y a certaines choses que vous voudrez faire aprés l'installation pour
d2504 1
a2504 6
<li>Si votre machine cible posséde une interface SCSI ou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4">ahci(4)</a>
, vous verrez surement l'identifiant de votre disque USB changer.
Posséder plusieurs versions de votre fichier <tt>/etc/fstab</tt> permettra
de "corriger" cela plus facilement (en mode mono-utilisateur).

d2609 1
a2609 1
vous pouvez recréer après un plantage, vous pouvez gagnez en vitesse en
d2633 2
a2634 2
Originally [OpenBSD: faq14.html,v 1.199 ]<br>
$Translation: faq14.html,v 1.92 2010/12/17 11:27:46 ajacoutot Exp $<br>
@


1.71
log
@Sync with Steelix CVS
@
text
@d2533 1
a2533 1
<h2>11.3 - Pourquoi nous n'utilisons pas de montage asynchrone ("async
d2591 1
a2591 1
$Translation: faq14.html,v 1.91 2010/05/16 20:16:02 gapz Exp $<br>
@


1.70
log
@Sync with Steelix CVS
@
text
@d622 1
a622 1
Le probléme, bien sur, c'est qu'il y a peu d'applications "normales".
d2312 1
a2312 1
probléme, realloueront le secteur defectueux avec un autre disponible.
d2394 1
a2394 1
<li>Résoudre des problémes dans OpenBSD et d'autres installations avec des
d2591 1
a2591 1
$Translation: faq14.html,v 1.90 2010/03/13 06:55:21 benoit Exp $<br>
@


1.69
log
@Sync with Steelix CVS
@
text
@d2339 3
a2341 4
Comme le média peut-être lu et écrit aussi bien d'un adaptateur USB et IDE,
vous pouvez utiliser le média crée pour démarrer dans un adaptateur IDE mais
le maintenir dans un adaptateur USB sur une machine différente 
(ou inversement).
d2590 2
a2591 2
Originally [OpenBSD: faq14.html,v 1.198 ]<br>
$Translation: faq14.html,v 1.89 2010/03/04 06:36:31 benoit Exp $<br>
@


1.68
log
@Sync with Steelix CVS
@
text
@d2400 2
d2591 2
a2592 2
Originally [OpenBSD: faq14.html,v 1.197 ]<br>
$Translation: faq14.html,v 1.88 2010/01/18 06:04:36 benoit Exp $<br>
@


1.67
log
@Sync with Steelix CVS
@
text
@d2373 1
a2373 1
Il faut remarquer que si le type de la seconde partition est choisi de 
d2377 1
a2377 1
MP3 qui pourront être joué quand ils seront démarrés de la partition OpenBSD.
d2589 2
a2590 2
Originally [OpenBSD: faq14.html,v 1.196 ]<br>
$Translation: faq14.html,v 1.87 2009/12/16 11:09:35 benoit Exp $<br>
@


1.66
log
@Sync with Steelix CVS
@
text
@d72 8
d2117 3
d2381 89
d2589 2
a2590 2
Originally [OpenBSD: faq14.html,v 1.195 ]<br>
$Translation: faq14.html,v 1.86 2009/11/30 15:07:47 benoit Exp $<br>
@


1.65
log
@Sync with Steelix CVS
@
text
@d2489 2
a2490 2
Originally [OpenBSD: faq14.html,v 1.194 ]<br>
$Translation: faq14.html,v 1.85 2009/11/09 10:05:10 benoit Exp $<br>
@


1.64
log
@Sync with Steelix CVS
@
text
@d846 1
a846 1
    Using Drive 0, Partition 3;
d1877 1
a1877 2
en lecture uniquement. Notez que le système de fichiers UFS2 de FreeBSD
n'est pas supporté.
d2489 2
a2490 2
Originally [OpenBSD: faq14.html,v 1.192 ]<br>
$Translation: faq14.html,v 1.84 2009/10/30 07:14:05 benoit Exp $<br>
@


1.63
log
@Sync with Steelix CVS
@
text
@d1719 14
a1732 31
OpenBSD inclut RAIDframe, une solution logicielle de RAID. La documentation est
disponible ici :

<ul>
<li><a href="#Optraid">Optimisation des disques, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">Page d'accueil de RAIDframe</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">manuel
de raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">
manuel de raid(4)</a>
</ul>

<p>
La partition racine peut être directement configurée en miroir par OpenBSD en
utilisant l'option "Autoconfiguration" de RAIDframe.

<p>
A partir d'OpenBSD 3.7-stable, le pilote <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">
ccd(4)</a> inclut également une fonction de "mirroring". Ce système est
inclut dans le noyau GENERIC et est présent dans le noyau bsd.rd sur certaines
plates-formes (amd64, hppa, hppa64, i386), ce qui
facilite son utilisation même s'il possède certaines limitations dans la
reconstruction de l'array. Référez-vous aux manuels :
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">
ccd(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">
ccdconfig(8)</a>
</ul>
d1738 11
a1748 2
référez-vous à la page des plates-formes supportées (listées <a
href="../../fr/plat.html">ici</a>).
d2384 2
a2385 3
disques ne fonctionnent plus. OpenBSD possède plusieurs options pour
augmenter la vitesse des opérations sur disque. De plus il fournit des
fonctionnalités de tolérance aux pannes.
a2388 2
<li><a href="#Optccd">CCD</a> - Pilote de Disques Concaténés.
<li><a href="#Optraid">RAID</a>
a2393 99
<a name="Optccd"></a>
<h3>14.18.1 - CCD</h3>

La première option consiste à utiliser 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
, le Pilote de Disques Concaténés. Il vous permet de
grouper plusieurs partitions en un seul disque virtuel (ainsi vous
pouvez rendre plusieurs disques visibles comme un seul disque). Ce
concept est similaire au concept de LVM (gestion de volumes logiques) se
trouvant dans plusieurs versions Unix commerciales.

<p>
Si vous utilisez le noyau GENERIC, ccd est déjà activé (dans
<tt>/usr/src/sys/conf/GENERIC</tt>). Si vous avez personnalisé votre
noyau, vous aurez éventuellement besoin de refaire la configuration de
votre noyau. Dans tous les cas, la ligne suivante devra figurer dans
votre fichier de configuration noyau :

<blockquote><pre>
<strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre></blockquote>

<p>
La ligne précédente vous permet de configurer jusqu'à 4 périphériques
ccd (disques virtuels). L'étape suivante consiste à choisir les
partitions sur vos disques physiques que vous voulez consacrer à ccd.
Utilisez disklabel pour marquer ces partitions en type 'ccd'. Sous
certaines architectures, disklabel ne vous autorisera pas à effectuer
cette opération. Dans ce cas, marquez les en 'ffs'.

<p>
Si vous utilisez ccd pour améliorer les performances à travers la
technique du striping, il est à noter que vous n'aurez pas de
performance optimale à moins que vous n'utilisiez le même modèle de
disques avec le même paramétrage disklabel.

<p>
Editez le fichier /etc/ccd.conf afin qu'il ressemble à ce qui suit :
(pour plus d'informations sur la configuration ccd, veuillez consulter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
Pour que vos modifications prennent effet, exécutez :

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Aussi longtemps que /etc/cdd.conf existera, ccd se configurera
automatiquement lors du démarrage de la machine. A ce point, vous avez
un nouveau disque dénommé ccd0; combinaison de /dev/sd2e et /dev/sd3e.
Pour le partitionner, utilisez disklabel normalement. Nous vous
rappelons qu'il ne faut pas utiliser la partition 'c' comme une
partition réelle sur laquelle vous pouvez stocker des données. Assurez-
vous que vos partitions soient au moins décalées d'un cylindre par
rapport au début du disque.

<p>
<a name="Optraid"></a>
<h3>14.18.2 - RAID</h3>

<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>
est une autre solution. Elle nécessitera l'utilisation de la commande 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
pour contrôler vos périphériques raid. Le RAID OpenBSD est basé sur le
<a href="http://www.cs.usask.ca/staff/oster/raid.html">port NetBSD</a>
du logiciel CMU 
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> par Greg
Oster. OpenBSD supporte les niveaux RAID 0, 1, 4 et 5.

<p>
Comme pour ccd, le support raid doit être configuré dans le NOYAU. Mais
contrairement à ccd, le support RAID n'est pas configuré par défaut dans
GENERIC. Il doit compilé au niveau du noyau (le support RAID ajoute 500k
à la taille d'un noyau i386) :

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
Consultez les pages de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>
et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
pour des informations complètes. Il y a plusieurs options et
configurations possibles. Une explication détaillée est au-delà du
périmètre du présent document.

<p>
d2395 1
a2395 1
<h3>14.18.3 - Soft Updates</h3>
d2397 1
a2397 1
Un autre outil qui peut être utilisé pour accélérer la vitesse de votre
d2404 2
a2405 9
devraient être toujours complètes, mais pas forcément à jour. Un crash
système ne devrait donc pas nécessiter une opération fsck lors du
démarrage de la machine, mais seulement une version d'arrière-plan de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
qui effectue des modifications aux metainfo en RAM (comme softupdates).
Ce qui veut dire que le redémarrage d'un serveur est beaucoup plus
rapide puisque vous n'avez pas besoin d'attendre que fsck finisse !
(OpenBSD ne possède pas encore cette fonctionnalité). Pour en savoir
plus, consultez <a href="#SoftUpdates">La FAQ Softupdates
d2410 1
a2410 1
<h3>14.18.4 - Taille du cache namei()</h3>
d2490 2
a2491 2
Originally [OpenBSD: faq14.html,v 1.190 ]<br>
$Translation: faq14.html,v 1.83 2009/10/25 20:13:48 benoit Exp $<br>
@


1.62
log
@Sync with Steelix CVS
@
text
@d969 4
a972 4
différente ET que vous ne répondez pas "Yes" à la question "Use entire disk"
lors de l'<a href="faq4.html#Disks">installation</a>, vous pourriez vous
retrouver avec un disque sans MBR valide, le rendant ainsi non-bootable même si
sa table de partition est correcte.
d2607 2
a2608 2
Originally [OpenBSD: faq14.html,v 1.189 ]<br>
$Translation: faq14.html,v 1.82 2009/10/19 13:42:03 benoit Exp $<br>
@


1.61
log
@Sync with Steelix CVS
@
text
@d959 2
a960 2
OpenBSD 4.5 (GENERIC) #1749: Sat Feb 28 14:51:18 MST 2009
   deraadt@@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
d2607 2
a2608 2
Originally [OpenBSD: faq14.html,v 1.188 ]<br>
$Translation: faq14.html,v 1.81 2009/04/30 23:04:33 benoit Exp $<br>
@


1.60
log
@Sync with Steelix CVS -- we are back to normal operation!
@
text
@d959 1
a959 1
OpenBSD 4.4 (GENERIC) #1021: Tue Aug 12 17:16:55 MDT 2008
d2607 2
a2608 2
Originally [OpenBSD: faq14.html,v 1.187 ]<br>
$Translation: faq14.html,v 1.80 2009/04/07 07:11:25 benoit Exp $<br>
@


1.59
log
@Sync with Steelix CVS
@
text
@d617 15
d1037 1
a1037 1
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm
d1047 1
a1047 1
FFS et FFS2).
d2607 2
a2608 2
Originally [OpenBSD: faq14.html,v 1.185 ]<br>
$Translation: faq14.html,v 1.77 2009/03/05 12:53:34 benoit Exp $<br>
@


1.58
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
d46 1
a46 2
<li><a href="#SwapFile"   >14.4 - Comment créer un espace de pagination dans un
fichier</a>
d607 53
a659 2
<a name="SwapFile"></a>
<h2>14.4 - Comment créer un espace de pagination dans un fichier</h2>
d672 7
a678 5
Il n'est pas nécessaire de recompiler le noyau pour utiliser un fichier
comme espace de pagination, même si cela peut être effectué à des fins
de personnalisation, cette faq vous montrera les deux façons de faire.

<h3>Paginer dans un fichier</h3>
d681 1
a681 3
L'utilisation d'un fichier d'échange est le moyen le plus simple et le
plus rapide pour augmenter l'espace de pagination (swap) disponible. Ce
fichier ne doit pas résider sur un système de fichiers dont l'option
d709 2
a710 1
Voici un exemple montrant la création d'un fichier <i>/var/swap</i> de 32Mo.
a751 65
<h3>Paginer via un périphérique vnode</h3>

<p>
Il s'agit d'une solution plus définitive pour ajouter de l'espace de
pagination. Afin de paginer vers un fichier de façon permanente,
commencez par créer un noyau avec vnd0c comme swap. Si votre système de
fichiers racine est wd0a, alors wd0b est votre ancien swap ; utilisez la
ligne suivante dans le fichier de configuration du noyau (référez-vous à
la section de compilation d'un nouveau noyau en cas de doute) :

<blockquote><pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre></blockquote>

<p>
Après cela, le fichier qui sera utilisé pour paginer devra être créé.
Pour ce faire, utilisez la même commande que pour l'exemple précédent.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
A présent que votre fichier est en place, vous devez l'ajouter dans
votre fichier <i>/etc/fstab</i>. Voici une ligne d'exemple pour démarrer
la machine avec ce dispositif de pagination activé.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre></blockquote>

<p>
Votre ordinateur doit maintenant être redémarré afin que les changements
effectués sur le noyau soient pris en compte. Une fois que cela est
fait, il est temps de configurer le dispositif pour paginer. On
utilisera la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">
vnconfig(8)</a>.

<blockquote><pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre></blockquote>

<p>
La dernière étape consiste à activer la pagination vers ce dispositif.
Cela s'effectue de la même façon que dans les exemples précédents, en
utilisant using swapctl(8). Puis nous vérifierons qu'il a bien été
ajouté à la liste des dispositifs de pagination disponibles.

<blockquote><pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>


d2592 2
a2593 2
Originally [OpenBSD: faq14.html,v 1.183 ]<br>
$Translation: faq14.html,v 1.75 2009/02/26 21:20:06 benoit Exp $<br>
@


1.57
log
@Sync with Steelix CVS
@
text
@d562 1
a562 1
# <b>newfs sd2a </b>
d577 1
a577 1
# <b>mount /dev/sd2a /u</b>
d585 1
a585 1
<blockquote><pre>/dev/sd2a /u ffs rw 1 1</pre></blockquote>
d594 1
a594 1
afin de préciser que votre partition /usr/local est maintenant /dev/sda2
d598 1
a598 1
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
d2606 2
a2607 2
Originally [OpenBSD: faq14.html,v 1.182 ]<br>
$Translation: faq14.html,v 1.74 2009/02/05 13:10:07 benoit Exp $<br>
@


1.56
log
@Sync with Steelix CVS
@
text
@d2300 1
a2300 1
Utiliser <a href="faq8.html#softdep">soft updates</a> aidera considérablement,
d2606 2
a2607 2
Originally [OpenBSD: faq14.html,v 1.181 ]<br>
$Translation: faq14.html,v 1.73 2008/11/30 12:56:25 benoit Exp $<br>
@


1.55
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2007 by OpenBSD.">
d490 1
a490 1

d908 1
a908 1
     >> OpenBSD/i386 BOOT 2.10
d948 1
a948 1
>> OpenBSD/i386 BOOT 2.10
d956 1
a956 1
Copyright (c) 1995-2007 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d958 1
a958 1
OpenBSD 4.2 (GENERIC) #375: Tue Aug 28 10:38:44 MDT 2007
d1045 6
a1050 8
OpenBSD supporte les systèmes de fichiers jusqu'à 2<sup>31</sup>-1, soit
2,147,483,647 secteurs, et puisque chaque secteur équivaut à 512 octets,
cela correspond à un peu moins de 1To.

<p>
Il existe aussi une taille limite de 1To pour le disque physique bien
que sous *certaines* conditions, vous ne rencontrerez pas de problèmes
avant 2To, mais ceci n'est <b>pas</b> garanti.
d1056 2
a1057 1
anciennes (d'une capacité standard de 137Go maximum), certains
d1078 2
a1079 1
durs, mais la partition racine devra être placée dans les premiers 128Go.
d1107 1
a1107 1
(biosboot(8) et <tt>/boot</tt> dans le cas d'un i386) ainsi que le noyau
d1137 4
a1140 1
certains cas. Le temps nécessaire à l'utilisation de fsck peut devenir
d1143 6
d1153 39
d2117 1
a2117 2
<h2>14.17 - Est-il possible d'utiliser un périphérique de masse ('flash
memory device') sous OpenBSD ?</h2>
d2150 2
a2151 2
<h3>Le périphérique est nouveau/vide et vous souhaitez l'utiliser
exclusivement avec OpenBSD.</h3>
d2182 2
a2183 2
<h3>Vous avez reçu le périphérique de quelqu'un avec qui vous souhaitez
échanger des données.</h3>
d2253 125
d2606 2
a2607 2
Originally [OpenBSD: faq14.html,v 1.169 ]<br>
$Translation: faq14.html,v 1.71 2008/04/21 00:28:06 gapz Exp $<br>
@


1.54
log
@Sync with Steelix CVS
@
text
@d439 1
a439 1
(OpenBSD ne peut démarrer qu'à patir de partitions primaires, mais vous
d482 1
a482 1
beaucoup de gens peuvent voir sous d'autres environnements. disk(8) ne demandera
d554 1
a554 8
utiliser "96M" pour spécifier "96 megaoctets" (ou, si vous possédez un
disque suffisamment gros, 96G pour 96 gigaoctets). En revanche, le mode
-E utilise la géométrie BIOS du disque, pas sa véritable géométrie, et
souvent ces deux valeurs sont différentes. Pour passer outre cette
limitation, tapez 'g d' pour "geometry disk" (géométrie disque). Les
autres options sont 'g b' for "geometry bios" (géométrie bios) et 'g u'
pour "geometry user" (géométrie utilisateur) ou simplement, ce que le
label affichait avant que disklabel n'effectue des changements.
d870 1
a870 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>, décrit dans
d1028 2
a1029 4
Les autres messages d'erreur sont expliqués en détail dans le manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">
biosboot(8)</a>.

d1031 1
d1167 1
a1167 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386"
>installboot(8)</a>.
d1691 1
a1691 1
inclu dans le noyau GENERIC et est présent dans le noyau bsd.rd sur certaines
d2434 2
a2435 2
Originally [OpenBSD: faq14.html,v 1.167 ]<br>
$Translation: faq14.html,v 1.70 2008/01/23 15:49:56 ajacoutot Exp $<br>
@


1.53
log
@Sync with Steelix CVS
@
text
@d95 1
a95 1
href="../../fr/armich.html">armish</a>,
d2444 1
a2444 1
$Translation: faq14.html,v 1.69 2008/01/20 17:32:54 saad Exp $<br>
@


1.52
log
@Sync with steelix translation CVS
@
text
@d94 2
a95 1
<a href="../../fr/zaurus.html">zaurus</a> et <a href="../../fr/cats.html">cats</a>,
d342 1
a342 1
cats) pour créer une partition reconnue par la ROM de démarrage du système dans
d439 2
d965 1
a965 1
OpenBSD 4.1 (GENERIC) #1434: Thu Mar  8 22:56:57 MST 2007
d2443 2
a2444 2
Originally [OpenBSD: faq14.html,v 1.164 ]<br>
$Translation: faq14.html,v 1.68 2007/05/02 10:01:34 ajacoutot Exp $<br>
@


1.51
log
@sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2006 by OpenBSD.">
d960 1
a960 1
Copyright (c) 1995-2006 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d962 2
a963 1
OpenBSD 4.0 (GENERIC) #1107: Sat Sep 16 19:15:58 MDT 2006
d2440 2
a2441 2
Originally [OpenBSD: faq14.html,v 1.163 ]<br>
$Translation: faq14.html,v 1.67 2007/02/18 10:54:13 ajacoutot Exp $<br>
@


1.50
log
@sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2007 by OpenBSD.">
d2440 1
a2440 1
$Translation: faq14.html,v 1.66 2007/02/07 10:37:37 benoit Exp $<br>
@


1.49
log
@sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2006 by OpenBSD.">
d118 1
a118 1
Sur certaines plateformes, l'utilisation de disklabel permet de passer
d125 1
a125 1
'/usr', '/var', etc) et il vous reste encore 3 partitions disponibles
d157 1
a157 1
affichera le disklabel courrant sans le modifier :
d304 1
a304 1
sur certaines plateformes, vous devriez laisser la première piste
d318 1
a318 1
et enregistrer sur les disque et qu'un système de fichiers non OpenBSD
d343 1
a343 1
plateformes n'ont pas besoin d'utiliser fdisk(8).
d472 1
a472 1
savez pas d'où vient de code de démarrage présent sur votre disque, il est
d526 2
a527 2
disque. Admettons qu'il s'agit d'un disque de 3 gigabytes. 3 gigabytes
en terme de constructeur de disques représente 3000 megabytes. Divisons
d531 1
a531 1
e, f, g, ... multipliez simplement X par 2061 afin d'avoir X megabytes
d551 2
a552 2
utiliser "96M" pour spécifier "96 megabytes" (ou, si vous possédez un
disque suffisamment gros, 96G pour 96 gigabytes). En revanche, le mode
d630 1
a630 1
<h3>Paginer dans un fichier.</h3>
d655 1
a655 1
de ce document, nous imaginerons que 32M supplémentaires sont
d663 1
a663 1
Voici un exemple montrant la création d'un fichier <i>/var/swap</i> de 32M.
d813 1
a813 1
    bytes) du disque. Il contient la table de partition primaire et un
d866 1
a866 1
code et de données d'une taille totale de 512 bytes. Ce n'est pas
d927 2
a928 2
<li><b>636k 190M</b> - Le montant de mémoire conventionnelle (sous 1M) et
étendue (au-dessus d'1M) trouvée.
d978 1
a978 1
fdisk. Démarrez à l'aide du medium d'installation; choisissez "Shell" pour vous
d1050 2
a1051 2
2,147,483,647 secteurs, et puisque chaque secteur équivaut à 512 bytes,
cela correspond à un peu moins de 1T.
d1054 1
a1054 1
Il existe aussi une taille limite de 1T pour le disque physique bien
d1056 1
a1056 1
avant 2T, mais ceci n'est <b>pas</b> garanti.
d1061 2
a1062 2
IDE de 250G pourrait provoquer des problèmes sur des interfaces trop
anciennes (d'une capacité standard de 137G maximum), certains
d1078 3
a1080 3
504M, mais les ordinateurs plus récents peuvent avoir des limites de
l'ordre de 2G, 8G, 32G, 128G ou plus. Il est important de noter que de
nombreux ordinateurs récents supportant un adressage au delà de 128G
d1082 2
a1083 2
premiers G. Vous pouvez utiliser ces systèmes avec de gros disques durs,
mais la partition racine devra être placée dans les premiers 128G.
d1086 1
a1086 1
Notez qu'il est toujours possible d'installer un disque dur de 40G sur un vieux
d1092 3
a1094 3
  <li>Vous installez tout sur une partition / de 40G. Cela fonctionne car le
système de base et ses fichiers (/bsd inclut) se situent dans les premiers 504M.
  <li>Vous utilisez le système et finissez par avoir pus de 504M de données
d1096 2
a1097 2
  <li>Vous mettez à jour, compilez un nouveau noyau, au autre, et vous copiez
votre nouveau /bsd sur l'ancien.
d1105 1
a1105 1
autre endroit sur le disque, probablement au-delà des 504 premiers M supportés
d1134 2
a1135 2
</a> après un crash ou à une coupure de courant. On ne peut pas créer un
système de fichiers de 120G sur un disque et espérer utiliser fsck(1) avec
d1137 1
a1137 1
système doit posséder au moins 1M de mémoire libre pour chaque 1G d'espace
d1139 2
a1140 2
être mise à contribution mais avec un coût tellement au niveau des
performances que cela en devient généralement innacceptable exepté dans
d1170 1
a1170 1
<tt>/boot</tt> en utilisany le programme
d1176 1
a1176 1
de l'IDE, ce pourrait être wd0, etc) :
d1297 1
a1297 1
<li><b>f</b> - Lecteur de bande à utiliser (ici, /dev/nrst0).
d1301 1
a1301 1
Et finalement, la partition à sauvegarder (/dev/rsd0a, etc).
d1578 1
a1578 1
Pour monter une image disque (images ISO, images disques créées avec dd, etc)
d1719 1
a1719 1
n'importe quelle plateforme supportant IDE ou SCSI.
d1839 1
a1839 1
UDF (CD-ROM, DVD), FAT (MS-DOS et Windows), NFS, NTFS (Windows),
d1957 1
a1957 2
NTFS et et la partition l est une partition d'échange Linux
('Linux swap').
d2011 1
a2011 1
taille de la partition 'o' (voir la sortie de disklabel plus haut) à 1G.
d2014 1
a2014 1
valeurs sont exprimées en numéros de secteurs (et pas en megabytes ou
d2079 1
a2079 1
Théoriquement, un périphérique mémoire devrait être reconnu dès sont
d2196 3
a2198 3
débrancher</b> le périphérique de masse. Si vous ne le faites, le
système de fichiers pourrait être laissé dans un état inconsistant
pouvant emmener de la corruption dans vos données.
d2310 1
a2310 1
pour contrôler vos périphériques raid. le RAID OpenBSD est basé sur le
d2331 1
a2331 1
Pour des informations complètes. Il y a plusieurs options et
d2353 1
a2353 1
(OpenBSD ne possède pas cette fonctionnalité encore). Pour en savoir
d2440 1
a2440 1
$Translation: faq14.html,v 1.64 2007/02/02 14:20:59 ajacoutot Exp $<br>
@


1.48
log
@sync with steelix translation CVS
@
text
@d23 1
a23 1
<a href= "../faq15.html">[Section 15 - Paquetages et Ports]</a>
d1212 1
a1212 1
via les <a href="../faq15.html#PkgMgmt">ports</a> afin de sauvegarder plusieurs
d2430 1
a2430 1
<a href= "../faq15.html">[Section 15 - Paquetages et Ports]</a>
d2441 1
a2441 1
$Translation: faq14.html,v 1.63 2007/01/24 13:01:36 ajacoutot Exp $<br>
@


1.47
log
@sync with steelix translation CVS
@
text
@d23 1
a23 1
<a href= "faq15.html">[Section 15 - Paquetages et Ports]</a>
d2430 1
a2430 1
<a href= "faq15.html">[Section 15 - Paquetages et Ports]</a>
d2441 1
a2441 1
$Translation: faq14.html,v 1.62 2007/01/01 10:31:38 ajacoutot Exp $<br>
@


1.46
log
@sync with Steelix CVS
@
text
@d1143 1
a1143 1
vous n'avez besoin d'utiliser fsck que sur les partitions allouées.
d2440 2
a2441 2
Originally [OpenBSD: faq14.html,v 1.162 ]<br>
$Translation: faq14.html,v 1.61 2006/11/20 08:46:42 ajacoutot Exp $<br>
@


1.45
log
@sync with steelix translation CVS
@
text
@d54 1
a54 1
("Bootblocks") - spécifique i386</a>
d1150 1
a1150 1
i386</h2>
d1153 24
a1176 24
Les anciennes versions de MS-DOS n'étaient capables d'interagir qu'avec les
disques dont la géométrie était de 1024 cylindres ou moins. Puisque de nos jours
tous les disques ont plus de 1024 cylindres, la plupart des BIOS SCSI (qui sont
présents sur les cartes contrôleur SCSI) et IDE (qui sont inclus avec le reste
du BIOS du PC) possèdent une option qui "traduit" la véritable géométrie du
disque en une géométrie compatible 'MS-DOS'. Cependant, tous les BIOS ne
"traduisent" pas cette géométrie de la même manière. Si vous changez votre BIOS
(en installant une nouvelle carte mère ou un nouveau contrôleur SCSI) et que le
nouveau utilise une "traduction" de géométrie différente, vous ne pourrez pas
lancer le chargeur de démarrage de niveau 2 ("second-stage boot loader") et donc
le noyau. Cela est du au fait que le chargeur de démarrage de niveau 1
("first-stage boot loader") contient la liste des blocs comprenant /boot
formatée selon l'ancienne géométrie "traduite". Si vous utilisez des disques
IDE et effectuez des changements dans la configuration de votre BIOS, vous
pouvez (sans le savoir) changer aussi la traduction de la géométrie (la plupart
des BIOS proposent 3 types de traductions différentes).Pour réparer votre bloc
de démarrage afin que vous puissiez booter normalement, insérez une disquette
dans votre lecteur (ou utilisez un CD-ROM bootable) et à l'invite de commandes,
tapez "b hd0a:/bsd" afin de le forcer à démarrer sur le premier disque (et non
sur la disquette). Votre machine devrait se lancer normalement. Vous devez à
présent mettre à jour le chargeur de premier niveau pour qu'il voit la nouvelle
géométrie (et récrive le bloc de démarrage en conséquence). <br>Notre exemple
assume que votre disque de démarrage est sd0 (mais pour de l'IDE, ce pourrait
être wd0, etc) :
d2440 2
a2441 2
Originally [OpenBSD: faq14.html,v 1.161 ]<br>
$Translation: faq14.html,v 1.60 2006/11/11 09:21:31 ajacoutot Exp $<br>
@


1.44
log
@sync with steelix translation CVS
@
text
@d1061 6
a1066 6
IDE de 250G ne fonctionnera pas sur des interfaces trop anciennes (d'une
capacité standard de 137G maximum), certains adaptateurs SCSI très
anciens peuvent avoir des problèmes avec des lecteurs modernes et des
BIOS un peu trop vieux peuvent se figer lorsqu'ils tombent sur un disque
dur de trop grande capacité. De fait, vous devez respecter les
possibilités de votre matériel.
d1138 9
a1146 4
disque afin d'utiliser fsck sans problème. Le temps nécessaire à l'utilisation
de fsck peut devenir un problème au fur et à mesure que le système de fichiers
grossit.

d2440 2
a2441 2
Originally [OpenBSD: faq14.html,v 1.160 ]<br>
$Translation: faq14.html,v 1.59 2006/11/03 10:18:49 ajacoutot Exp $<br>
@


1.43
log
@sync with steelix translation CVS
@
text
@d962 1
a962 1
OpenBSD 3.9 (GENERIC) #617: Thu Mar  2 02:26:48 MST 2006
d2435 2
a2436 2
Originally [OpenBSD: faq14.html,v 1.159 ]<br>
$Translation: faq14.html,v 1.58 2006/10/26 07:42:36 ajacoutot Exp $<br>
@


1.42
log
@sync with Steelix CVS
@
text
@d1752 1
a1752 1
d'une partition est utilisé, comme on peut le voir avec <a
d1756 1
a1756 1
Lorsqu'une partition est créée avec <a
d2435 2
a2436 2
Originally [OpenBSD: faq14.html,v 1.158 ]<br>
$Translation: faq14.html,v 1.57 2006/09/08 20:41:18 saad Exp $<br>
@


1.41
log
@sync with steelix translation CVS
@
text
@d92 1
a92 1
les plate-formes. Sous <a href="../../fr/i386.html">i386</a>,
d100 2
a101 2
Toutes les autres plate-formes utilisent disklabel(8) pour la gestion
complète des partitions OpenBSD. Les plate-formes qui utilisent aussi
d118 2
a119 2
Sur certaines platerformes, l'utilisation de disklabel permet de passer
outre les limitations de partitionnement liées aux types d'achitectures.
d134 1
a134 1
de créer les différentes partitions. Vous pourrer définir vos points de
d203 1
a203 1
mais le mode éditeur possède également une véritable utilitée.
d265 1
a265 1
Sur la plupart des plate-formes OpenBSD, il y 16 partitions disklabel
d285 2
a286 2
<li><b>Valeurs par défault :</b> dans certains cas, vous pourriez avoir
besoin de commencer avec disklabel par défault. La commande "D" écrasera
d304 2
a305 2
sur certaines platerformes, vous devriez laisser la première piste
logique inutilisée dans disklabel(8) et fdisk(8). Cette recommendation
d310 1
a310 1
nombreuses autres plate-formes s'attendent à voir les partitions OpenBSD
d314 2
a315 2
de disklabel OpenBSD mais a déja un autre système de fichiers (par
exemple, un disque avec un système de fichiers FAT32 déja existant),
d318 1
a318 1
et enregistrer sur les disque et qu'un systme de fichiers non OpenBSD
d340 1
a340 1
fdisk(8) est utilisé sur certaines plate-formes (i386, amd64, macppc, zaurus et
d343 1
a343 1
platerformes n'ont pas besoin d'utiliser fdisk(8).
d347 1
a347 1
celles de fidsk, sous OpenBSD cette commande assume que vous savez ce que vous
d389 1
a389 1
e</b>. Ceci fera apparaître une invite de commandes pour intéragir avec
d422 1
a422 1
    mode d'édition intéractif.
d424 1
a424 1
    actuellement sélectionné. Pratique pour initialiser une parition OpenBSD
d443 1
a443 1
<li><b>swap</b> Echange deux entrées MBR afin que vous puissier le réordonner.
d468 1
a468 1
<li>Un disque vièrge aura besoin qu'on y inscrive le code de démarrage dans le
d532 1
a532 1
d'expace sur cette partition. L'offset de votre première partition doit
d812 1
a812 1
    (enregistrement de démarrage principal) est le premier seceur (512
d820 1
a820 1
    OpenBSD sous-entend la ré-écriture complète du secteur MBR et pas
d827 1
a827 1
Bien qu'un MBR soit inclu avec OpenBSD, vous n'êtes pas obligé de
d969 1
a969 1
<li><b>Bad/invalid/incompatible MBR :</b> habituellement, un disque déja utilisé
d1007 1
a1007 1
changé l'option de conversion dans votre BIOS), il <i>apparaitra au niveau du
d1027 1
a1027 1
altéré ou encore que vous avez exédé la capacité de votre BIOS à lire les
d1093 1
a1093 1
système de base et ses fichiers (/bsd inclu) se situent dans les premiers 504M.
d1148 1
a1148 1
Les anciennes versions de MS-DOS n'étaient capables d'intéragir qu'avec les
d1159 1
a1159 1
("first-stage boot loader") contient la liste des blocs conprenant /boot
d1305 1
a1305 1
Si vous n'êtes pas sûr du nom de périphérique du lecteur, utilisez dmegs pour le
d1314 1
a1314 1
son nom de périphérique "<tt>nrst0</tt>" au lieu de "<tt>st0</tt>" qui apparait
d1369 1
a1369 1
bon de vérifier rapidement votre bande afin d'être certain que que les données
d1406 1
a1406 1
restore et soyez attentifs aux instructions concernant le mode intéractif.
d1411 1
a1411 1
install/boot sous OpenBSD contient déja l'utilitaire restore ainsi que les
d1459 1
a1459 1
Utilisez la commande newfs pour créer un système de fichier vièrge sur chaque
d1588 1
a1588 1
<i>ext2fs</i> lors du montage d'images dique Linux.
d1646 1
a1646 1
être effectuté avec <a href="faq5.html#BootConfig">UKC</a> ou <a
d1670 1
a1670 1
OpenBSD inclu RAIDframe, une solution logicielle de RAID. La documentation est
d1690 1
a1690 1
ccd(4)</a> inclu également une fonction de "mirroring". Ce système est
d1692 1
a1692 1
plate-formes (amd64, hppa, hppa64, i386), ce qui
d1714 1
a1714 1
n'importe quelle platerforme supportant IDE ou SCSI.
d1717 1
a1717 1
Quelques manufactureurs de ce type de produits :
d1736 1
a1736 1
par un BIOS. Puisqu'OpenBSD supporte déja le RAID logiciel indépendamment du
d1751 1
a1751 1
espace disque disponible <i>negatif</i> ou que plus de 100% de l'espace
d1797 1
a1797 1
fixer une partie suffisament grande du disque afin de pouvoir récupérer
d1801 1
a1801 1
préférable (avec des disques mourrants vous voudrez en premier les
d1950 1
a1950 1
fdisk(8)</a>. Pour le lecteur curieux, la parition i est une partition
d1952 1
a1952 1
NTFS et et la parition l est une partition d'échange Linux
d2006 1
a2006 1
existantes : en utilisant le program fdisk de Linux, j'ai réduit la
d2053 1
a2053 1
la variable d'environnement EDITOR (par défault il s'agit de vi). Une
d2078 1
a2078 1
je branche mon périphérique USB, voici ce qui apparait sur la console :
d2335 1
a2335 1
Un autre outil qui peut être utilisé pour accélerer la vitesse de votre
d2387 1
a2387 1
un mécanismesûrement plus simple et plus sûr
d2436 1
a2436 1
$Translation: faq14.html,v 1.56 2006/08/12 11:54:12 ajacoutot Exp $<br>
@


1.40
log
@sync with steelix translation CVS
@
text
@a11 5
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
d159 1
a159 1
<pre>
d192 1
a192 1
</pre>
d219 1
a219 1
<pre>
d253 1
a253 1
</pre>
d362 2
a363 2
<pre># <b>fdisk sd0</b><br>
</pre>
d368 1
a368 1
<pre>
d378 1
a378 1
</pre>
d392 1
a392 1
<pre>
d412 1
a412 1
</pre>
d498 1
a498 1
<pre>
d500 1
a500 1
</pre>
d506 1
a506 1
<pre>
d520 1
a520 1
</pre>
d544 1
a544 1
<pre>
d546 1
a546 1
</pre>
d565 1
a565 1
<pre>
d567 1
a567 1
</pre>
d580 1
a580 1
<pre>
d582 1
a582 1
</pre>
d589 1
a589 1
<pre>/dev/sd2a /u ffs rw 1 1</pre>
d601 1
a601 1
<pre>
d603 1
a603 1
</pre>
d642 1
a642 1
<pre>
d646 1
a646 1
</pre>
d665 1
a665 1
<pre>
d670 1
a670 1
</pre>
d676 1
a676 1
<pre>
d679 1
a679 1
</pre>
d685 1
a685 1
<pre>
d691 1
a691 1
</pre>
d699 1
a699 1
<pre>
d703 1
a703 1
</pre>
d715 1
a715 1
<pre>
d717 1
a717 1
</pre>
d723 1
a723 1
<pre>
d728 1
a728 1
</pre>
d735 1
a735 1
<pre>
d739 1
a739 1
</pre>
d749 1
a749 1
<pre>
d752 1
a752 1
</pre>
d760 1
a760 1
<pre>
d767 1
a767 1
</pre>
d793 1
a793 1
<pre>
d795 1
a795 1
</pre>
d836 1
a836 1
<pre>
d838 1
a838 1
</pre>
d848 1
a848 1
<pre>
d850 1
a850 1
</pre>
d878 1
a878 1
<pre>
d880 1
a880 1
</pre>
d887 1
a887 1
<pre>
d889 1
a889 1
</pre>
d909 1
a909 1
<pre>
d914 1
a914 1
</pre>
d981 1
a981 1
<pre>
d983 1
a983 1
</pre>
d986 1
a986 1
<pre>
d988 1
a988 1
</pre> 
d1173 1
a1173 1
<pre>
d1175 1
a1175 1
</pre>
d1181 1
a1181 1
<pre>
d1187 1
a1187 1
</pre>
d1232 1
a1232 1
<pre>
d1236 1
a1236 1
</pre>
d1246 1
a1246 1
<pre>
d1252 1
a1252 1
</pre>
d1263 1
a1263 1
<pre>
d1267 1
a1267 1
</pre>
d1273 1
a1273 1
<pre>
d1279 1
a1279 1
</pre>
d1308 1
a1308 1
<pre>
d1310 1
a1310 1
</pre>
d1328 1
a1328 1
<pre>
d1339 1
a1339 1
</pre>
d1376 1
a1376 1
<pre>
d1378 1
a1378 1
</pre>
d1389 1
a1389 1
<pre>
d1391 1
a1391 1
</pre>
d1435 1
a1435 1
<pre>
d1437 1
a1437 1
</pre>
d1449 1
a1449 1
<pre>
d1451 1
a1451 1
</pre>
d1462 1
a1462 1
<pre>
d1465 1
a1465 1
</pre>
d1471 1
a1471 1
<pre>
d1473 1
a1473 1
</pre>
d1480 1
a1480 1
<pre>
d1483 1
a1483 1
</pre>
d1490 1
a1490 1
<pre>
d1492 1
a1492 1
</pre>
d1499 1
a1499 1
<pre>
d1502 1
a1502 1
</pre>
d1512 1
a1512 1
<pre>
d1515 1
a1515 1
</pre>
d1522 1
a1522 1
<pre>
d1524 1
a1524 1
</pre>
d1538 1
a1538 1
<pre>
d1540 1
a1540 1
</pre>
d1547 2
a1548 2
<pre>
(table de montage simple)
d1551 1
a1551 1
(table de montage avancée)
d1555 1
a1555 1
</pre>
d1579 1
a1579 4
<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
d1582 1
a1582 4
</pre>
                </td>
        </tr>
</table>
d1593 1
a1593 4
<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
d1596 1
a1596 4
</pre>
                </td>
        </tr>
</table>
d1625 1
a1625 1
<pre>
d1628 1
a1628 1
</pre>
d2435 2
a2436 2
Originally [OpenBSD: faq14.html,v 1.157 ]<br>
$Translation: faq14.html,v 1.55 2006/06/26 12:40:13 ajacoutot Exp $<br>
@


1.39
log
@sync with Steelix CVS
@
text
@d2400 1
a2400 1
qui rend un package dont j'ai besoin (qui touche à une centaine
d2453 1
a2453 1
$Translation: faq14.html,v 1.54 2006/06/21 07:22:51 ajacoutot Exp $<br>
@


1.38
log
@sync with steelix translation CVS
@
text
@d468 1
a468 1
partition table resides.  -- not sure if this is true -->
d2452 2
a2453 2
Originally [OpenBSD: faq14.html,v 1.156 ]<br>
$Translation: faq14.html,v 1.53 2006/05/02 10:00:48 ajacoutot Exp $<br>
@


1.37
log
@sync with Steelix CVS
@
text
@d97 1
a97 1
les plateformes. Sous <a href="../../fr/i386.html">i386</a>,
d105 2
a106 2
Toutes les autres plateformes utilisent disklabel(8) pour la gestion
complète des partitions OpenBSD. Les plateformes qui utilisent aussi
d270 1
a270 1
Sur la plupart des plateformes OpenBSD, il y 16 partitions disklabel
d315 1
a315 1
nombreuses autres plateformes s'attendent à voir les partitions OpenBSD
d345 1
a345 1
fdisk(8) est utilisé sur certaines plateformes (i386, amd64, macppc, zaurus et
d965 1
a965 1
Copyright (c) 1995-2005 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d967 1
a967 1
OpenBSD 3.8 (GENERIC) #138: Sat Sep 10 15:41:37 MDT 2005
d975 1
a975 1
possède un code MBR, mais s'il est neuf ou déplacé à partir d'une plateforme
d1709 1
a1709 1
plateformes (amd64, hppa, hppa64, i386), ce qui
d2452 2
a2453 2
Originally [OpenBSD: faq14.html,v 1.155 ]<br>
$Translation: faq14.html,v 1.51 2006/04/07 09:15:52 ajacoutot Exp $<br>
@


1.36
log
@sync with Steelix CVS
@
text
@d1758 2
a1759 2
Presque tous ces contrôlleurs "RAID" SATA ou IDE embarqués sont de type
logiciel et fonctionneront sans problème comme contrôlleur SATA ou IDE
d2453 1
a2453 1
$Translation: faq14.html,v 1.50 2006/03/29 07:59:19 ajacoutot Exp $<br>
@


1.35
log
@sync with Steelix CVS
@
text
@d1212 1
a1212 1
via les <a href="faq15.html#PkgMgmt">ports</a> afin de sauvegarder plusieurs
d2453 1
a2453 1
$Translation: faq14.html,v 1.49 2006/03/04 09:50:28 ajacoutot Exp $<br>
@


1.34
log
@sync with Steelix CVS
@
text
@d146 1
a146 1
lisez <a href="faq4.html#SpaceNeeded">ce chapitre</a> sur le
d1132 1
a1132 1
Et c'est une autre raison pour <a href="faq4.html#SpaceNeeded">partitionner
d1708 2
a1709 1
inclu dans le noyau GENERIC et est présent dans le noyau bsd.rd, ce qui
d2452 2
a2453 2
Originally [OpenBSD: faq14.html,v 1.153 ]<br>
$Translation: faq14.html,v 1.47 2006/02/27 09:04:42 ajacoutot Exp $<br>
@


1.33
log
@sync with steelix translation CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
d78 3
d106 1
a106 1
complête des partitions OpenBSD. Les plateformes qui utilisent aussi
d1691 1
a1691 1
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
d2224 214
d2451 2
a2452 2
Originally [OpenBSD: faq14.html,v 1.150 ]<br>
$Translation: faq14.html,v 1.46 2005/12/29 13:39:35 ajacoutot Exp $<br>
@


1.32
log
@sync with Steelix CVS
@
text
@d326 7
d338 20
a357 2
Avant de commencer, soyez sûr d'avoir lu le manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.
a359 13
Fdisk est un programme d'aide à la maintenance de vos partitions. Ce
programme est utilisé à l'installation afin de mettre en place vos
partitions OpenBSD (cette partition peut contenir <u>plusieurs</u>
labels, chacun avec un système de fichiers, partition d'échange (swap),
etc). Il permet de diviser l'espace de vos disques et d'activer une
partition. Ce programme pourra éventuellement être utilisé en mode
"Single User" (boot -s). Fdisk permet également d'inscrire le MBR
("Master boot record") sur vos différents disques.

<p>
Pour les besoins de l'installation, vous ne nécessiterez, la plupart du
temps, que d'<b>UNE</b> partition OpenBSD dans laquelle vous ajouterez
le swap et les systèmes de fichiers à l'aide de disklabel.
d407 1
a416 3
Il est parfaitement sans danger d'explorer les diverses commande sous
fdisk, à condition de répondre <b>N</b> à la sauvegarde des changements
et de ne *PAS* utiliser la commande <b>write</b>.
d426 3
a428 1
    actuellement sélectionné.
d445 1
d460 27
a775 1

a786 8
Pour utiliser les Soft Updates, votre noyau doit avoir

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
compilé, ce qui est le cas du noyau GENERIC.

<p>
d788 6
a793 7
montage d'une partition avec l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)
</a>, vous pouvez activer les Soft Updates sur celle-ci. Voici l'exemple
d'une entrée dans le fichier <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">
/etc/fstab(5)</a></i> permettant de monter la partition <i>sd0a</i> avec
les Soft Updates activés.
d2234 2
a2235 2
Originally [OpenBSD: faq14.html,v 1.147 ]<br>
$Translation: faq14.html,v 1.44 2005/12/22 09:47:36 ajacoutot Exp $<br>
@


1.31
log
@sync with Steelix CVS
@
text
@d94 3
a96 3
les plateformes. Sous <a href="../i386.html">i386</a>,
<a href="../amd64.html">amd64</a>, <a href="../macppc.html">macppc</a>,
<a href="../zaurus.html">zaurus</a> et <a href="../cats.html">cats</a>,
d318 7
a324 6
OpenBSD va en "créer" un imaginaire qui posera les bases d'un disklabel
plus formel. Cependant, si un disklabel OpenBSD est créé et qu'un
système de fichiers non OpenBSD est ajouté par la suite, le disklabel ne
sera pas automatiquement mis à jour et vous devrez l'éditer vous-même si
vous souhaitez que OpenBSD puisse y accéder. Plus d'informations sont
disponibles <a href="faq14.html#foreignfsafter">plus bas</a>.
d623 3
a625 3
d'utiliser la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Voici un exemple montrant la création d'un fichier /var/swap de 32M.
d828 2
a829 2
    Record" (enregistrement de démarrage de partition), aussi appelé PBR
    ou
d831 5
a835 5
    (d'après le nom du fichier contenant le code) représente le premier
    secteur physique de la partition OpenBSD du disque. Le PBR est le
    "first-stage boot loader" (chargeur de démarrage de niveau un)
    d'OpenBSD. Il est exécuté par le code MBR et se charge de lancer le
    "second- stage boot loader" (chargeur de démarrage de niveau deux),
d837 6
a842 6
    Comme le MBR, le PBR est constitué d'une toute petite quantité de
    code et de données d'une taille totale de 512 bytes. Ce n'est pas
    suffisant pour avoir une application reconnaissant un système de
    fichiers, donc, plutôt que de demander au PBR de localiser
    <tt>/boot</tt> sur le disque, sa localisation accessible par le BIOS
    est codée physiquement dans le PBR lors de l'installation.
d2204 2
a2205 2
Originally [OpenBSD: faq14.html,v 1.146 ]<br>
$Translation: faq14.html,v 1.42 2005/12/18 11:55:23 ajacoutot Exp $<br>
@


1.30
log
@sync with steelix translation CVS
@
text
@d104 1
a104 1
fdisk(1) placent toutes les partitions disklabel(8) dans une tranche
d2203 2
a2204 2
Originally [OpenBSD: faq14.html,v 1.145 ]<br>
$Translation: faq14.html,v 1.41 2005/12/17 18:15:36 ajacoutot Exp $<br>
@


1.29
log
@sync with Steelix CVS
@
text
@a83 8
<h3>Table des matières</h3>

<ul>
<li><a href="#disklabel.1">Qu'est-ce que disklabel(8) ?</a>
<li><a href="#disklabel.2">disklabel(8) à l'installation d'OpenBSD</a>
<li><a href="#disklabel.3">Utilisations courantes de disklabel(8)</a>
</ul>

d87 1
a87 1
  
d93 24
a116 9
Les "Disklabels" sont créés afin d'interfacer efficacement un disque
avec les pilotes inclus dans le noyau. Les "labels" (partitions)
contiennent plusieurs informations à propos de vos disques, comme la
géométrie du lecteur et le type de système de fichiers. Ceux-ci sont
utilisés par le programme d'amorçage pour démarrer le disque et
connaître les systèmes de fichiers présents sur celui-ci. Ces partitions
sont également utilisées en conjonction avec le système de fichiers afin
de créer un environnement optimisé. Vous pouvez accéder à de plus amples
informations sur disklabel en lisant le manuel
d120 4
a123 5
De plus, l'utilisation de disklabel permet de passer outre les
limitations de partitionnement liées aux types d'achitectures. Par
exemple, sur i386, vous ne pouvez avoir que 4 partitions primaires. (Les
partitions que les autres systèmes d'exploitation, comme Windows NT ou
DOS, peuvent voir.) Avec
d126 3
a128 3
stocker *toutes* vos partitions OpenBSD (ex. 'swap', '/', '/usr' et
'/var'). Et il vous reste encore 3 partitions disponibles pour d'autres
systèmes d'exploitation !
d135 4
a138 114
initiale des labels. Celle-ci intervient (pour les utilisateurs de i386)
juste après avoir utilisé <a href="#fdisk">fdisk(1)</a>. A
l'installation, vous utilisez disklabel afin de créer les différentes
partitions qui contiendront vos points de montage. Vous pouvez définir
ces points de montage à l'installation lorsque vous êtes sous
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a> bien que ce ne soit pas nécessaire puisque vous serez
amené à confirmer ces choix plus tard. Mais cela permettra d'accélérer
votre installation.

<p>
Puisque vous en êtes à l'installation, vous n'aurez aucun label existant
et devrez les créer. Le premier label à créer est le label 'a'. Celui-ci
DEVRA correspondre au point de montage /. Vous pouvez connaître quels
labels il est recommandé de créer en lisant la
<a href="faq4.html#SpaceNeeded">FAQ 4, De combien d'espace ai-je besoin pour une installation OpenBSD ?</a>. Pour les
serveurs, il est recommandé de créer des labels séparés. Pour une
utilisation bureautique, créer un point de montage / sera probablement
suffisant. A la création initiale de votre partition racine (label 'a'),
gardez à l'esprit que vous aurez besoin d'un CERTAIN espace libre pour
votre partition d'échange (label 'SWAP'). Maintenant que les bases ont
été abordées, voici un exemple d'utilisation de disklabel à
l'installation. Dans cet exemple, on assumera qu'OpenBSD est le seul
système présent dans l'ordinateur et qu'une installation complète sera
réalisée.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
A ce niveau, nous avons créé une partition racine de 64M montée sur / et
une partition d'échange de 64M. Notez que l'offset (calage du disque)
débute au secteur 63 ; c'est ce qu'il faut. En ce qui concerne la
taille, disklabel vous la présentera sous forme de secteurs, cependant,
vous n'avez pas besoin de rentrer la taille dans ce même format. Comme
dans l'exemple précédent, vous pouvez entrer une taille sous la forme
<i>64 Megabytes = 64M</i> et <i>2 Gigabytes = 2G</i>. Disklabel en fera
l'approximation au secteur le plus proche. Dans cet exemple, vous
noterez également que disklabel assume que le label 'b' correspond à une
partition d'échange (SWAP). Cette assomption est correcte puisque, par
défaut, le noyau GENERIC est configuré pour rechercher une partition
d'échange sur le label 'b' ; vous devriez suivre cette recommandation et
utiliser 'b' pour votre partition swap.

<p>
L'exemple suivant vous montrera la création de deux labels
supplémentaires. Cela signifie qu'il ne s'agit pas d'une installation
complète puisque la taille de ces labels ne sera pas suffisante pour
contenir la totalité d'OpenBSD. Montrer la création de toutes les
partitions serait répétitif.

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
Deux choses sont à noter dans l'exemple précédent. La première est que
l'offset est automatiquement défini pour vous en se basant sur le
prochain disponible (dans l'ordre). Dans une telle installation, vous
n'aurez pas à vous soucier de changer les offsets. La deuxième chose que
vous noterez est que le label 'c' a été évité. La raison en est que ce
label représente la totalité du disque. C'est pourquoi vous ne devriez
jamais toucher au label 'c' de quelque sorte que ce soit.

<p>
Une fois vos labels créés, tout ce qu'il reste à faire est de les
inscrire sur le disque et poursuivre l'installation. Pour sauvegarder le
tout et quitter disklabel (et ainsi continuer l'installation), tapez :
d140 5
d146 4
a149 4
<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>
d154 1
a154 1
<h3>Utilisations courantes disklabel(8)</h3>
d157 3
a159 5
Une fois votre système installé, vous ne devriez pas avoir à utiliser
disklabel trop souvent. Mais parfois, vous aurez besoin de l'utiliser
afin d'ajouter, de supprimer ou de supprimer des disques. Une des
premières choses que vous aurez besoin de faire sera de voir le
disklabel actuel. Pour ce faire, tapez simplement :
d162 3
a164 1
# <b>disklabel wd0</b> &gt;----- Or whatever disk device you'd like to view
a165 1
# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
d168 2
a169 2
disk:
label: TOSHIBA MK2720FC
d175 2
a176 2
cylinders: 2633
total sectors: 2654064
d181 2
a182 2
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
d186 8
a193 5
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
d197 23
a219 5
Cette commande permet simplement de voir le disklabel existant afin de
nous empêcher d'effectuer des manipulations hasardeuses (un conseil dont
nous avons tous besoin de temps en temps). Pour avoir la possibilité
d'effectuer des changements avec disklabel, il faut utiliser l'otion -E
comme suit :
d223 56
a278 1
</pre>
d281 45
a325 10
Vous retrouverez alors une invite de commandes similaire à celle
rencontrée à l'installation d'OpenBSD. A priori, la commande la plus
importante à connaître est '?'. Celle-ci vous donnera la liste des
options utilisables sous disklalbel. Vous pouvez aussi voir le manuel
complet de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
en tapant la commande 'M'. C'est à partir de cette invite de commandes
que vous ajouterez, supprimerez et modifierez vos labels. Si vous
souhaitez d'avantage d'information, lisez le manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
d2203 2
a2204 2
Originally [OpenBSD: faq14.html,v 1.143 ]<br>
$Translation: faq14.html,v 1.39 2005/12/12 07:53:33 ajacoutot Exp $<br>
@


1.28
log
@sync with Steelix CVS
@
text
@d1802 1
a1802 1
steven.mestdagh@@esat.kuleuven.be, and released under the BSD license -->
d2044 1
a2044 1
steven.mestdagh@@esat.kuleuven.be, and released under the BSD license -->
d2192 2
a2193 2
Originally [OpenBSD: faq14.html,v 1.142 ]<br>
$Translation: faq14.html,v 1.38 2005/12/06 09:02:44 ajacoutot Exp $<br>
@


1.27
log
@sync with Steelix CVS
@
text
@d1807 2
a1808 1
en lecture uniquement.
d2192 2
a2193 2
Originally [OpenBSD: faq14.html,v 1.141 ]<br>
$Translation: faq14.html,v 1.37 2005/11/26 22:26:30 ajacoutot Exp $<br>
@


1.26
log
@sync with Steelix CVS
@
text
@d1551 4
a1554 4
Remarquez que, puisque cette image est une image CD, vous devez spécifier le
type <i>cd9660</i> lors du montage. Ceci est vrai peut importe le type, par
exemple, vous devez utiliser <i>ext2fs</i> lors du montage d'images
dique Linux.
d2191 2
a2192 2
Originally [OpenBSD: faq14.html,v 1.140 ]<br>
$Translation: faq14.html,v 1.36 2005/11/24 08:20:32 ajacoutot Exp $<br>
@


1.25
log
@sync with Steelix CVS
@
text
@d1167 2
a1168 2
via les <a href="faq8.html#Ports">ports</a> afin de sauvegarder plusieurs serveurs
vers un unique lecteur de bandes. Dans la plupart des environnements, <a
d2191 2
a2192 2
Originally [OpenBSD: faq14.html,v 1.139 ]<br>
$Translation: faq14.html,v 1.35 2005/11/10 09:11:51 ajacoutot Exp $<br>
@


1.24
log
@sync with steelix translation CVS
@
text
@d1014 5
d2191 2
a2192 2
Originally [OpenBSD: faq14.html,v 1.138 ]<br>
$Translation: faq14.html,v 1.34 2005/11/03 12:42:43 ajacoutot Exp $<br>
@


1.23
log
@sync with Steelix CVS
@
text
@d71 5
a75 1
présentes sur des systèmes de fichiers autres que FFS ?</a>
d1860 5
a1864 5
disklalbel contenant les systèmes de fichiers natifs et étrangers a été
installé. Cependant, si vous ajoutez des systèmes de fichiers étrangers
après l'installation du disklabel d'OpenBSD vous devrez probablement les
ajouter ou les modifier ultérieurement. Cette procédure est expliquée
<a href="#foreignfsafter">ici</a>.
d2186 2
a2187 2
Originally [OpenBSD: faq14.html,v 1.137 ]<br>
$Translation: faq14.html,v 1.33 2005/11/03 07:57:36 ajacoutot Exp $<br>
@


1.22
log
@sync with steelix translation CVS
@
text
@d918 1
a918 1
OpenBSD 3.8-current (GENERIC) #209: Tue Oct 25 17:42:53 MDT 2005
d1795 4
a1798 4
Oui. Les systèmes de fichiers supportés sont : ext2 (Linux), ISO9660
(CD-ROM, DVD), FAT (MS-DOS et Windows), NFS, NTFS (Windows), AmigaDOS.
Certains n'ont qu'un support limité, comme par exemple l'accès en
lecture uniquement.
d1853 9
d1951 49
a1999 1
s'occuper de ces choses.
d2001 28
d2182 2
a2183 2
Originally [OpenBSD: faq14.html,v 1.135 ]<br>
$Translation: faq14.html,v 1.31 2005/11/01 12:54:03 ajacoutot Exp $<br>
@


1.21
log
@sync with Steelix CVS
@
text
@d28 1
d868 1
a868 1
     >> OpenBSD/i386 BOOT 2.06
d908 1
a908 1
>> OpenBSD/i386 BOOT 2.06
d916 1
a916 1
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d918 1
a918 1
OpenBSD 3.7 (GENERIC) #50: Sun Mar 20 00:01:57 MST 2005
d1653 4
a1656 6
ccd(4)</a> inclu également une fonction de "mirroring". Il n'est pas
recommandé d'utiliser 3.7-release pour ceci, un bug ayant été corrigé
dans 3.7-stable. Ce système est inclu dans le noyau GENERIC et est
présent dans le noyau bsd.rd, ce qui facilite son utilisation même s'il
possède certaines limitations dans la reconstruction de l'array.
Référez-vous aux manuels :
d1751 3
a1753 4
Depuis OpenBSD 3.6, une copie de votre disklabel est sauvegardée pour
chaque disque dans <tt>/var/backups</tt> via la maintenance système
journalière.
A condition d'avoir encore votre partition var, vous pouvez simplement
d2087 1
d2097 2
a2098 2
Originally [OpenBSD: faq14.html,v 1.134 ]<br>
$Translation: faq14.html,v 1.30 2005/10/30 18:14:20 saad Exp $<br>
@


1.20
log
@sync with steelix translation CVS
@
text
@d1072 1
a1072 1
immunisés contre ce problème, cependant, de nombreuses plateformes possèdent une
d1667 3
a1669 3
De nombreuses <a href="../../fr/plat.html">plateformes</a> OpenBSD supportent
plusieurs contrôleurs RAID matériels. Ceux-ci varient selon les plateformes,
référez-vous à la page des plateformes supportées (listées <a
d1673 1
a1673 1
Une autre option accessible à plusieurs plateformes est l'un des
d2099 1
a2099 1
$Translation: faq14.html,v 1.29 2005/10/19 15:48:37 ajacoutot Exp $<br>
@


1.19
log
@sync with Steelix CVS
@
text
@d1826 16
d2098 2
a2099 2
Originally [OpenBSD: faq14.html,v 1.133 ]<br>
$Translation: faq14.html,v 1.28 2005/07/28 07:44:14 ajacoutot Exp $<br>
@


1.18
log
@sync with Steelix CVS
@
text
@d1156 3
a1158 3
avancé nommé "Amanda" est également disponible via les <a
href="faq8.html#Ports">ports</a> afin de sauvegarder plusieurs serveurs vers un
unique lecteur de bandes. Dans la plupart des environnements, <a
d1163 1
a1163 2
machines vers une seule bande, il peut être utile de se documenter sur Amanda
dans le futur.
d2082 2
a2083 2
Originally [OpenBSD: faq14.html,v 1.132 ]<br>
$Translation: faq14.html,v 1.27 2005/07/14 07:45:50 ajacoutot Exp $<br>
@


1.17
log
@sync with Steelix CVS
@
text
@a730 7
La possibilité d'effectuer un fsck(8) en arrière plan avec Soft Updates
n'a pas encore été implémentée sous OpenBSD, donc l'utilisation de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)
</a> est toujours nécessaire lors d'un arrêt brutal. Les futures
versions pourraient inclure cette fonctionnalité.

<p>
d2083 2
a2084 2
Originally [OpenBSD: faq14.html,v 1.131 ]<br>
$Translation: faq14.html,v 1.26 2005/06/15 16:21:01 ajacoutot Exp $<br>
@


1.16
log
@sync with Steelix CVS
@
text
@d1980 1
a1980 1
que sa page de manuel, <a
d1982 1
d2091 1
a2091 1
$Translation: faq14.html,v 1.25 2005/06/01 10:39:03 ajacoutot Exp $<br>
@


1.15
log
@sync with Steelix CVS
@
text
@d69 4
d1657 16
d1798 278
d2089 2
a2090 2
Originally [OpenBSD: faq14.html,v 1.127 ]<br>
$Translation: faq14.html,v 1.22 2005/05/30 06:39:35 ajacoutot Exp $<br>
@


1.14
log
@sync with steelix translation CVS
@
text
@d431 1
a431 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;&amp;sektion=8&amp;arch=i386">fdisk(8)</a> (<i>i386 seulement</i>) et <a
d1791 2
a1792 2
Originally [OpenBSD: faq14.html,v 1.126 ]<br>
$Translation: faq14.html,v 1.21 2005/05/20 06:32:34 ajacoutot Exp $<br>
@


1.13
log
@sync with steelxi translation CVS
@
text
@d920 1
a920 1
OpenBSD 3.6 (GENERIC) #59: Fri Sep 17 12:32:57 MDT 2004
d1791 2
a1792 2
Originally [OpenBSD: faq14.html,v 1.125 ]<br>
$Translation: faq14.html,v 1.20 2005/05/18 03:44:41 saad Exp $<br>
@


1.12
log
@sync with Steelix CVS
@
text
@@


1.11
log
@huge sync from the translators
@
text
@d89 1
a89 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a>.
d92 22
a113 20
Les "Disklabels" sont créés afin d'interfacer efficacement un disque avec les
pilotes inclus dans le noyau. Les "labels" (partitions) contiennent plusieurs
informations à propos de vos disques, comme la géométrie du lecteur et le type
de système de fichiers. Ceux-ci sont utilisés par le programme d'amorçage pour
démarrer le disque et connaître les systèmes de fichiers présents sur celui-ci.
Ces partitions sont également utilisées en conjonction avec le système de
fichiers afin de créer un environnement optimisé. Vous pouvez accéder à de
plus amples informations sur disklabel en lisant le manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">
disklabel(5)</a>.

<p>
De plus, l'utilisation de disklabel permet de passer outre les limitations de
partitionnement liées aux types d'achitectures. Par exemple, sur i386, vous ne
pouvez avoir que 4 partitions primaires. (Les partitions que les autres systèmes
d'exploitation, comme Windows NT ou DOS, peuvent voir.) Avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a>, vous utilisez une de ces partitions 'primaires' pour stocker
*toutes* vos partitions OpenBSD (ex. 'swap', '/', '/usr' et '/var'). Et il vous
reste encore 3 partitions disponibles pour d'autres systèmes d'exploitation !
d119 25
a143 25
Une partie importante de l'installation d'OpenBSD est la création initiale des
labels. Celle-ci intervient (pour les utilisateurs de i386) juste après avoir
utilisé <a href="#fdisk">fdisk(1)</a>. A l'installation, vous utilisez disklabel
afin de créer les différentes partitions qui contiendront vos points de montage.
Vous pouvez définir ces points de montage à l'installation lorsque vous êtes
sous <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a> bien que ce ne soit pas nécessaire puisque vous serez amené à
confirmer ces choix plus tard. Mais cela permettra d'accélérer votre
installation.

<p>
Puisque vous en êtes à l'installation, vous n'aurez aucun label existant et
devrez les créer. Le premier label à créer est le label 'a'. Celui-ci DEVRA
correspondre au point de montage /. Vous pouvez connaître quels labels il est
recommandé de créer en lisant la <a href="faq4.html#SpaceNeeded">FAQ 4, De
combien d'espace ai-je besoin pour une installation OpenBSD ?</a>. Pour les
serveurs, il est recommandé de créer des labels séparés. Pour une utilisation
bureautique, créer un point de montage / sera probablement suffisant. A la
création initiale de votre partition racine (label 'a'), gardez à l'esprit que
vous aurez besoin d'un CERTAIN espace libre pour votre partition d'échange
(label 'SWAP'). Maintenant que les bases ont été abordées, voici un exemple
d'utilisation de disklabel à l'installation. Dans cet exemple, on assumera
qu'OpenBSD est le seul système présent dans l'ordinateur et qu'une installation
complète sera réalisée.
d179 20
a198 18
A ce niveau, nous avons créé une partition racine de 64M montée sur / et une
partition d'échange de 64M. Notez que l'offset (calage du disque) débute au
secteur 63 ; c'est ce qu'il faut. En ce qui concerne la taille, disklabel vous
la présentera sous forme de secteurs, cependant, vous n'avez pas besoin de
rentrer la taille dans ce même format. Comme dans l'exemple précédent, vous
pouvez entrer une taille sous la forme <i>64 Megabytes = 64M</i> et <i>2
Gigabytes = 2G</i>. Disklabel en fera l'approximation au secteur le plus proche.
Dans cet exemple, vous noterez également que disklabel assume que le label 'b'
correspond à une partition d'échange (SWAP). Cette assomption est correcte
puisque, par défaut, le noyau GENERIC est configuré pour rechercher une
partition d'échange sur le label 'b' ; vous devriez suivre cette recommandation
et utiliser 'b' pour votre partition swap.

<p>
L'exemple suivant vous montrera la création de deux labels supplémentaires. Cela
signifie qu'il ne s'agit pas d'une installation complète puisque la taille de
ces labels ne sera pas suffisante pour contenir la totalité d'OpenBSD. Montrer
la création de toutes les partitions serait répétitif.
d222 7
a228 7
Deux choses sont à noter dans l'exemple précédent. La première est que l'offset
est automatiquement défini pour vous en se basant sur le prochain disponible
(dans l'ordre). Dans une telle installation, vous n'aurez pas à vous soucier de
changer les offsets. La deuxième chose que vous noterez est que le label 'c' a
été évité. La raison en est que ce label représente la totalité du disque. C'est
pourquoi vous ne devriez jamais toucher au label 'c' de quelque sorte que ce
soit.
d231 3
a233 3
Une fois vos labels créés, tout ce qu'il reste à faire est de les inscrire sur
le disque et poursuivre l'installation. Pour sauvegarder le tout et quitter
disklabel (et ainsi continuer l'installation), tapez :
d247 5
a251 5
Une fois votre système installé, vous ne devriez pas avoir à utiliser disklabel
trop souvent. Mais parfois, vous aurez besoin de l'utiliser afin d'ajouter, de
supprimer ou de supprimer des disques. Une des premières choses que vous aurez
besoin de faire sera de voir le disklabel actuel. Pour ce faire, tapez
simplement :
d285 5
a289 4
Cette commande permet simplement de voir le disklabel existant afin de nous
empêcher d'effectuer des manipulations hasardeuses (un conseil dont nous avons
tous besoin de temps en temps). Pour avoir la possibilité d'effectuer des
changements avec disklabel, il faut utiliser l'otion -E comme suit :
d296 8
a303 7
Vous retrouverez alors une invite de commandes similaire à celle rencontrée à
l'installation d'OpenBSD. A priori, la commande la plus importante à connaître
est '?'. Celle-ci vous donnera la liste des options utilisables sous disklalbel.
Vous pouvez aussi voir le manuel complet de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a> en tapant la commande 'M'. C'est à partir de cette invite de
commandes que vous ajouterez, supprimerez et modifierez vos labels. Si vous
d305 1
a305 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a>.
d311 1
a311 11
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">
fdisk(8)</a>.

<p>
Fdisk est un programme d'aide à la maintenance de vos partitions. Ce programme
est utilisé à l'installation afin de mettre en place vos partitions OpenBSD
(cette partition peut contenir <u>plusieurs</u> labels, chacun avec un système
de fichiers, partition d'échange (swap), etc). Il permet de diviser l'espace de
vos disques et d'activer une partition. Ce programme pourra éventuellement être
utilisé en mode "Single User" (boot -s). Fdisk permet également d'inscrire le
MBR ("Master boot record") sur vos différents disques.
d314 13
a326 3
Pour les besoins de l'installation, vous ne nécessiterez, la plupart du temps,
que d'<b>UNE</b> partition OpenBSD dans laquelle vous ajouterez le swap et les
systèmes de fichiers à l'aide de disklabel.
d350 3
a352 3
Dans cet exemple, nous voyons la sortie de fdisk concernant le premier lecteur
SCSI. Nous pouvons voir les partitions OpenBSD (A6). Le * indique que la
partition OpenBSD est amorçable.
d355 5
a359 4
Dans l'exemple précédent, nous avons simplement accédé à une information. Qu'en
est-il si nous souhaitons éditer notre table de partition ? Et bien, pour ce
faire, nous devons utiliser l'option <b>-e</b>. Ceci fera apparaître une invite
de commandes pour intéragir avec fdisk.
d383 3
a385 3
Il est parfaitement sans danger d'explorer les diverses commande sous fdisk, à
condition de répondre <b>N</b> à la sauvegarde des changements et de ne *PAS*
utiliser la commande <b>write</b>.
d387 2
a388 1
<p>Voici un aperçu des commandes disponibles lorsque vous utilisez l'option
d392 2
a393 2
<li><b>help</b> Affiche la liste des commandes utilisables par fdisk en mode
d'édition intéractif.
d395 28
a422 24
actuellement sélectionné.
<li><b>disk</b> Affiche la géométrie actuelle du disque détectée par fdisk. Vous
pouvez l'éditer selon vos désirs.
<li><b>setpid</b> Change l'identifiant de partition de l'entrée sélectionnée de
la table de partition.
<li><b>edit</b> Edite l'entrée sélectionnée de la table dans la copie mémoire du
bloc de démarrage actuel. Vous pouvez entrer les valeurs en géométrie BIOS ou
en secteurs, offsets et tailles.
<li><b>flag</b> Rend amorçable la partition sélectionnée. Seule une entrée peut
être marquée comme amorçable. Si vous souhaitez démarrer à partir d'une
partition étendue, vous devez la marquer comme amorçable.
<li><b>update</b> Met à jour le code machine dans la copie mémoire du bloc de
démarrage actuellement sélectionné.
<li><b>select</b> Sélectionne et charge en mémoire le bloc de démarrage désigné
par la table de partition étendue dans le bloc de démarrage actuel.
<li><b>print</b> Affiche la copie en mémoire actuelle du bloc de démarrage et
de son MBR sur le terminal.
<li><b>write</b> Ecrit la copie en mémoire actuelle du bloc de démarrage sur
le disque. Vous serez amené à confirmer cette action.
<li><b>exit</b> Quitte le niveau actuel de fdisk, revenant à la copie précédente
du bloc de démarrage ou sortant du programme si une telle copie n'existe pas.
<li><b>quit</b> Quitte le niveau actuel de fdisk, revenant à la copie précédente
du bloc de démarrage ou sortant du programme si une telle copie n'existe pas. A
l'inverse d'"exit", le bloc de démarrage modifié est inscrit sur le disque.
d431 2
a432 4
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;&amp;sektion=8&amp;arch=i386">
fdisk(8)</a> (<i>i386 seulement</i>) et <a
href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a> afin de le configurer pour OpenBSD.
d435 4
a438 3
Pour les utilisateurs i386, commencez avec fdisk. Les autres architectures
peuvent ignorer cette étape. Dans l'exemple suivant, nous ajouterons un
troisième disque SCSI au système.
d442 5
a446 3
Cette commande va initialiser la "véritable" table de partition du disque pour
un usage exclusif par OpenBSD. Ensuite, vous devez créer un disklabel. Ceci
risque de sembler confus.
d463 21
a483 20
Tout d'abord, ignorez la partition 'c', celle-ci est toujours présente et est
nécessaire au fonctionnement de programmes comme disklabel ! Le type de
système de fichiers ("fstype") pour OpenBSD est 4.2BSD. Le nombre total de
secteurs ("total sectors") représente la taille du disque. Admettons qu'il
s'agit d'un disque de 3 gigabytes. 3 gigabytes en terme de constructeur de
disques représente 3000 megabytes. Divisons 6185088 par 3000 (on utilise <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1)</a>).
Vous obtenez 2061. Ainsi, pour décider des tailles des partitions a, d, e, f, g,
... multipliez simplement X par 2061 afin d'avoir X megabytes d'expace sur cette
partition. L'offset de votre première partition doit être égal à "sectors/track"
comme rapporté par disklabel. Pour nous, cette valeur est égale à 63. L'offset
de chaque partition suivante résultera de la combinaison de la taille et de
l'offset de chacune d'elle (sauf la partition 'c' qui n'intervient pas dans
cette équation).

<p>
Ou, si vous souhaitez simplement une partition couvrant tout le disque, afin
d'offrir un espace de stockage web, un répertoire d'utilisateurs ("home") ou
autre chose, ôtez simplement la valeur "sectors/track" à la taille totale du
disque. 6185088-63 = 6185025. Votre partition est :
d490 9
a498 8
utiliser disklabel -E pour entrer dans le même mode de partitionnement dont vous
disposiez à l'installation !</b> Dans celui-ci, vous pouvez utiliser "96M" pour
spécifier "96 megabytes" (ou, si vous possédez un disque suffisamment gros, 96G
pour 96 gigabytes). En revanche, le mode -E utilise la géométrie BIOS du disque,
pas sa véritable géométrie, et souvent ces deux valeurs sont différentes. Pour
passer outre cette limitation, tapez 'g d' pour "geometry disk" (géométrie
disque). Les autres options sont 'g b' for "geometry bios" (géométrie bios) et
'g u' pour "geometry user" (géométrie utilisateur) ou simplement, ce que le
d502 3
a504 4
Voilà qui était dense. Mais tout n'est pas terminé. Vous devez à présent créer
un système de fichiers sur ce disque en utilisant <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">
newfs(8)</a>.
d511 3
a513 3
Ou autre, selon le nom donné à votre disque par le système de nommage d'OpenBSD
(regardez la sortie de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">
d517 3
a519 3
Maintenant, il vous faut décider où vous souhaitez monter cette partition
nouvellement créée. Disons que vous vouliez la monter sur /u. Tout d'abord,
créez le répertoire /u. Puis montez-le.
d533 8
a540 6
Et si vous souhaitiez migrer un répertoire existant comme /usr/local ? Vous
devriez monter le nouveau disque sur /mnt et utiliser <tt>cpio -pdum</tt> pour
copier /usr/local vers le répertoire /mnt. Editez le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">
/etc/fstab(5)</a> afin de préciser que votre partition /usr/local est maintenant
/dev/sda2 (votre nouvelle partition formatée). Exemple :
d547 4
a550 4
Redémarrez en mode single user  avec <b>boot -s</b>, déplacez le répertoire
/usr/local vers /usr/local-backup (ou si vous vous sentez en veine,
supprimez-le) et créez un répertoire /usr/local vide. Enfin, redémarrez le
système et voilà, les fichiers sont présents !
d557 7
a563 6
(Note : si vous souhaitez ajouter un espace de pagination dans un fichier parce
que vous recevez des erreurs du type &quot;virtual memory exhausted&quot;, vous
devriez d'abord essayer d'augmenter la limite des processus avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">
unlimit(1)</a> pour csh ou <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">
d567 3
a569 3
Il n'est pas nécessaire de recompiler le noyau pour utiliser un fichier comme
espace de pagination, même si cela peut être effectué à des fins de
personnalisation, cette faq vous montrera les deux façons de faire.
d574 6
a579 5
L'utilisation d'un fichier d'échange est le moyen le plus simple et le plus
rapide pour augmenter l'espace de pagination (swap) disponible. Ce fichier ne
doit pas résider sur un système de fichiers dont l'option "SoftUpdates" est
activée (cette option est désactivée par défaut). Pour commencer, vous pouvez
voir la taille totale et utilisée de votre swap actuel en utilisant l'utilitaire
d590 8
a597 7
Cela vous affiche les différents dispositifs utilisés pour la pagination ainsi
que leurs statistiques actuelles. Dans l'exemple précédent, il n'y a qu'un seul
dispositif nommé &quot;swap_device&quot;. Il s'agit de l'espace disque
prédéfini utilisé pour paginer (partition b visible sous disklabel). Comme vous
pouvez le constater dans l'exemple précédent, cet espace n'est pas beaucoup
utilisé pour le moment. Mais pour les besoins de ce document, nous imaginerons
que 32M supplémentaires sont nécessaires.
d600 3
a602 2
La première chose à faire pour configurer un fichier en tant que dispositif de
pagination est de créer ce fichier. Le mieux est d'utiliser la commande <a
d614 2
a615 2
Une fois que cela est fait, nous pouvons activer la pagination vers ce fichier.
Pour ce faire, utilisez la commande suivante :
d623 2
a624 2
A présent, vérifions que ce fichier a bien été ajouté à la liste des dispositifs
de pagination disponibles.
d635 4
a638 4
Maintenant que le fichier de pagination est activé, vous devez ajouter une
ligne à votre fichier <i>/etc/fstab</i> afin que les changements soient pris en
compte au prochain redémarrage. Si cette ligne n'est pas ajoutée, ce dispositif
ne sera plus activé au prochain reboot.
d649 6
a654 6
Il s'agit d'une solution plus définitive pour ajouter de l'espace de pagination.
Afin de paginer vers un fichier de façon permanente, commencez par créer un
noyau avec vnd0c comme swap. Si votre système de fichiers racine est wd0a, alors
wd0b est votre ancien swap ; utilisez la ligne suivante dans le fichier de
configuration du noyau (référez-vous à la section de compilation d'un nouveau
noyau en cas de doute) :
d661 2
a662 2
Après cela, le fichier qui sera utilisé pour paginer devra être créé. Pour ce
faire, utilisez la même commande que pour l'exemple précédent.
d672 3
a674 3
A présent que votre fichier est en place, vous devez l'ajouter dans votre
fichier <i>/etc/fstab</i>. Voici une ligne d'exemple pour démarrer la machine
avec ce dispositif de pagination activé.
d684 3
a686 2
effectués sur le noyau soient pris en compte. Une fois que cela est fait, il est
temps de configurer le dispositif pour paginer. On utilisera la commande <a
d696 4
a699 4
La dernière étape consiste à activer la pagination vers ce dispositif. Cela
s'effectue de la même façon que dans les exemples précédents, en utilisant
using swapctl(8). Puis nous vérifierons qu'il a bien été ajouté à la liste des
dispositifs de pagination disponibles.
d720 5
a724 4
href="http://www.mckusick.com/softdep/">Kirk McKusick</a>. Les Soft Updates
imposent une réorganisation partielle des opérations sur le tampon permettant la
suppression du code FFS, des écritures synchrones des entrées. Une augmentation
des performances est ainsi réalisée lors des écritures sur disque.
d727 2
a728 2
La possibilité d'effectuer un fsck(8) en arrière plan avec Soft Updates n'a pas
encore été implémentée sous OpenBSD, donc l'utilisation de <a
d730 2
a731 2
</a> est toujours nécessaire lors d'un arrêt brutal. Les futures versions
pourraient inclure cette fonctionnalité.
d745 2
a746 2
</a>, vous pouvez activer les Soft Updates sur celle-ci. Voici l'exemple d'une
entrée dans le fichier <i><a
d748 2
a749 2
/etc/fstab(5)</a></i> permettant de monter la partition <i>sd0a</i> avec les
Soft Updates activés.
d756 5
a760 4
Note aux utilisateur sparc : n'activez pas Soft Updates sur les machines de type
sun4 ou sun4c. Ces architectures ne supportent qu'un montant très faible de
mémoire noyau et ne peuvent utiliser cette fonctionnalité. En revanche, les
machines de type sun4m ne posent pas de problème.
d764 4
a767 4
Le processus de démarrage d'un système OpenBSD/i386 est loin d'être simple et
une bonne compréhension de celui-ci peut être utile afin de diagnostiquer un
problème lorsque les choses ne fonctionnent pas. Ce processus comporte quatre
étapes clefs :
d770 20
a789 17
(enregistrement de démarrage principal) est le premier seceur (512 bytes) du
disque. Il contient la table de partition primaire et un petit programme
permettant de charger le "Partition Boot Record" (PBR - enregistrement de
démarrage des partitions). Notez que dans certains environnements, le terme
"MBR" se réfère uniquement à la portion de code comprise dans le premier bloc
du disque et non pas au bloc entier (incluant la table de partition). Il est
primordial de comprendre le sens d'"initialiser le MBR" ; la terminologie sous
OpenBSD sous-entend la ré-écriture complète du secteur MBR et pas seulement son
code, comme cela peut être le cas avec certains systèmes. Vous n'en aurez
l'utilité que très rarement. Pour ce faire, utilisez l'option "-u" de la
commande fdisk(8) ("<tt>fdisk -u wd0</tt>").

<p>
Bien qu'un MBR soit inclu avec OpenBSD, vous n'êtes pas obligé de l'utiliser
puisque virtuellement, n'importe quel MBR est capable de le faire démarrer. Le
MBR se manipule avec l'aide du programme fdisk(8) qui est utilisé pour éditer la
table de partition mais également pour installer le code MBR sur le disque.
d793 1
d797 7
a803 5
montrant le disque ainsi que la partition d'où il s'apprête à charger le PBR. On
peut également voir un point (".") en fin de ligne, ce qui signifie que la
machine est capable d'utiliser la conversion LBA ("Logical Block Adressing") au
démarrage. Si la machine avait été incapable d'une telle conversion, le point
aurait été remplacé par un point-virgule (";"), indiquant une conversion CHS
d805 1
d809 20
a828 18
Notez que le point ou le point-virgule en fin de ligne peut servir d'indicateur
du "nouveau" MBR OpenBSD introduit à partir de la version 3.5.

<li><b><i>Partition Boot Record (PBR) :</i></b> Le "Partition Boot Record"
(enregistrement de démarrage de partition), aussi appelé PBR ou <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">
biosboot(8)</a> (d'après le nom du fichier contenant le code) représente le
premier secteur physique de la partition OpenBSD du disque. Le PBR est le
"first-stage boot loader" (chargeur de démarrage de niveau un) d'OpenBSD. Il est
exécuté par le code MBR et se charge de lancer le "second-stage boot loader"
(chargeur de démarrage de niveau deux), <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">
boot(8)</a>. Comme le MBR, le PBR est constitué d'une toute petite quantité de
code et de données d'une taille totale de 512 bytes. Ce n'est pas suffisant pour
avoir une application reconnaissant un système de fichiers, donc, plutôt que de
demander au PBR de localiser <tt>/boot</tt> sur le disque, sa localisation
accessible par le BIOS est codée physiquement dans le PBR lors de
l'installation.
d832 2
a833 2
href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">
installboot</a>, décrit <a href="faq14.html#InstBoot">plus en détails dans la
d835 1
d839 6
a844 3
affichant un point pour chaque bloc qu'il essaye de charger. Comme précédemment,
le PBR montre s'il utilise une conversion LBA ou CHS pour s'exécuter. Dans le
cas de CHS, il affichera un message suivi d'un point-virgule :
a847 2
L'ancien biosboot(8) (avant la version 3.5) affichait le message "<tt>reading
boot...</tt>".
d849 2
d852 14
a865 10
<li><b><i>Second Stage Boot Loader, <tt>/boot</tt> :</i></b> <tt>/boot</tt> est
chargé par le PBR et se charge d'accéder au système de fichiers OpenBSD par le
BIOS de la machine afin de localiser et de lancer le noyau. boot(8) permet
également de passer plusieurs options et informations au noyau.
<p>
boot(8) est un programme intéractif. Après son exécution, il tente de localiser
et lire <tt>/etc/boot.conf</tt> si celui-ci existe (ce qui n'est pas le cas dans
une installation par défaut) puis lance les commandes qui y sont indiquées. A
moins que le fichier <tt>/etc/boot.conf</tt> ne l'en empêche, boot(8) offre à
l'utilisateur une invite de commandes similaire à celle-ci :
d873 7
a879 5
Par défaut, l'utilisateur a cinq secondes pour entrer une commande avant le
démarrage du noyau, <tt>bsd</tt>, à partir de la partition racine du premier
disque dur, ce qui représente le comportement par défaut. Le "second-stage boot
loader" détecte (et examine) votre matériel grâce au BIOS (puisque le noyau
OpenBSD n'est pas encore chargé). Précédemment on peut voir qu'il a détecté :
d1008 2
a1009 2
2,147,483,647 secteurs, et puisque chaque secteur équivaut à 512 bytes, cela
correspond à un peu moins de 1T.
d1012 8
a1019 7
Bien entendu, les capacités du système de fichiers et celles d'un matériel
défini sont deux choses bien différentes. Un nouveau disque dur IDE de 250G ne
fonctionnera pas sur des interfaces trop anciennes (d'une capacité standard de
137G maximum), certains adaptateurs SCSI très anciens peuvent avoir des
problèmes avec des lecteurs modernes et des BIOS un peu trop vieux peuvent se
figer lorsqu'ils tombent sur un disque dur de trop grande capacité. De fait,
vous devez respecter les possibilités de votre matériel.
d1023 3
a1025 2
accessibles qu'une fois celui-ci chargé en mémoire. Le processus de démarrage
devra se contenter de la ROM de lancement du système (bien plus limitée).
d1028 9
a1036 9
Pour cette raison, le fichier /bsd (le noyau) doit se trouver dans l'espace
disque adressable par la ROM. Cela signifie que sur certains systèmes i386, la
partition racine doit se situer dans les premiers 504M, mais les ordinateurs
plus récents peuvent avoir des limites de l'ordre de 2G, 8G, 32G, 128G ou plus.
Il est important de noter que de nombreux ordinateurs récents supportant un
adressage au delà de 128G sont en fait limités par le BIOS et ne peuvent
démarrer que sur les 128 premiers G. Vous pouvez utiliser ces systèmes avec de
gros disques durs, mais la partition racine devra être placée dans les premiers
128G.
d1661 5
a1665 5
Une autre option accessible à plusieurs plateformes est l'un des nombreux
produits qui font apparaître plusieurs disques comme un seul disque IDE ou SCSI
et sont ensuite branchés sur un contrôleur IDE ou SCSI standard. Ces
périphériques peuvent virtuellement fonctionner sur n'importe quelle platerforme
supportant IDE ou SCSI.
d1675 3
a1677 2
(Note : ce sont des produits que certains utilisateurs d'OpenBSD utilisent ; il
ne s'agit en aucun cas d'une liste exhaustive ni de matériels certifiés).
d1683 1
a1683 1
diffusion</a> consiste à savoir si "les contrôleurs RAID IDE ou SATA peut
d1692 3
a1694 3
Presque tous ces contrôlleurs "RAID" SATA ou IDE embarqués sont de type logiciel
et fonctionneront sans problème comme contrôlleur SATA ou IDE en utilisant le
pilote IDE standard
d1701 3
a1703 3
Certaines personnes sont parfois surprises de voir qu'elles ont un espace disque
disponible <i>negatif</i> ou que plus de 100% de l'espace d'une partition est
utilisé, comme on peut le voir avec <a
d1709 6
a1714 6
</a>, un certain montant d'espace disque inaccessible aux utilisateurs est
réservé. Cela permet d'avoir une marge d'erreur en cas de remplissage accidentel
du disque et de garder la fragmentation au minimum. Par défaut, l'espace réservé
correspond à 5% de la capacité du disque ce qui signifie que si root a
imprudemment rempli le disque, vous pouvez vous retrouver avec 105% de capacité
disponible utilisée.
d1717 3
a1719 3
Si une valeur de 5% ne vous semble pas appropriée, vous pouvez la changer avec
la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">
d1741 1
a1741 1
chaque disque dans <tt>/var/backups</tt> via la maitenance système
d1764 4
a1767 4
Vous pouvez utiliser ces informations pour recréer le disklabel.
Si vous voulez uniquement restaurer <tt>/var</tt>, vous pouvez recréer
la partition pour <tt>/var</tt>, et ensuite récupérer le label et
ajouter le reste.
d1772 4
a1775 4
essaiera également d'écrire le label sur le disque.
Ainsi, même si la partie du disque qui contient le disklabel est
illisible, vous serez en mesure de la
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>er
d1791 2
a1792 2
Originally [OpenBSD: faq14.html,v 1.124 ]<br>
$Translation: faq14.html,v 1.18 2005/05/02 21:27:54 aanriot Exp $<br>
@


1.10
log
@sync with Steelix CVS
@
text
@d27 1
a27 1
<a href= "faq12.html">[Section 12 - Questions Spécifiques Aux Plates-Formes]</a>
d67 3
d1505 2
a1506 1
exemple, vous devez spécifier ffs pour monter une image disque.
d1679 55
d1738 1
a1738 1
<a href= "faq12.html">[Section 12 - Questions Spécifiques Aux Plates-Formes]</a>
d1748 2
a1749 2
Originally [OpenBSD: faq14.html,v 1.119 ]<br>
$Translation: faq14.html,v 1.14 2005/02/22 16:19:07 saad Exp $<br>
@


1.9
log
@Sync with Steelix CVS
@
text
@d942 1
a942 1
altéré ou encore que vous avez exédé la capacité de votre BIOS à lire les <a
d1690 1
a1690 1
$Translation: faq14.html,v 1.13 2005/02/13 09:43:29 ajacoutot Exp $<br>
@


1.8
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
d1689 2
a1690 2
Originally [OpenBSD: faq14.html,v 1.118 ]<br>
$Translation: faq14.html,v 1.12 2005/01/17 21:31:58 aanriot Exp $<br>
@


1.7
log
@Sync with Steelix CVS
@
text
@d1688 1
d1690 2
a1691 1
$Translation: faq14.html,v 1.11 2005/01/01 20:59:04 ajacoutot Exp $<br>
@


1.6
log
@Sync with Steelix CVS
@
text
@d1636 3
a1638 2
diffusion</a> consiste à savoir si "Les contrôleurs Promise ou HighPoint IDE
RAID sont supportés ?". La réponse est "Non". Ces cartes et puces ne sont pas de
d1644 6
d1688 2
a1689 2
Originally [OpenBSD: faq14.html,v 1.117 ]<br>
$Translation: faq14.html,v 1.10 2004/12/25 19:12:27 ajacoutot Exp $<br>
@


1.5
log
@Sync with Steelix CVS
@
text
@d812 1
a812 1
boot...</tt>.
d1681 2
a1682 2
Originally [OpenBSD: faq14.html,v 1.116 ]<br>
$Translation: faq14.html,v 1.9 2004/11/28 23:49:06 ajacoutot Exp $<br>
@


1.4
log
@Sync with Steelix CVS
@
text
@d227 1
a227 1
disklabel (et ainsi continuer l'installation), tapez:
d245 1
a245 1
simplement:
d282 1
a282 1
changements avec disklabel, il faut utiliser l'otion -E comme suit:
d322 1
a322 1
Pour simplement voir votre table de partition avec fdisk, utilisez:
d328 1
a328 1
Ce qui vous donnera une sortie similaire à celle-ci:
d468 1
a468 1
disque. 6185088-63 = 6185025. Votre partition est:
d523 1
a523 1
/dev/sda2 (votre nouvelle partition formatée). Exemple:
d540 1
a540 1
(Note: si vous souhaitez ajouter un espace de pagination dans un fichier parce
d562 1
a562 1
swapctl(8)</a>. Pour ce faire, lancez la commande:
d594 1
a594 1
Pour ce faire, utilisez la commande suivante:
d633 1
a633 1
noyau en cas de doute):
d733 1
a733 1
Note aux utilisateur sparc: n'activez pas Soft Updates sur les machines de type
d743 1
a743 1
étapes clefs:
d745 1
a745 1
<li><b><i>Master Boot Record (MBR):</i></b> Le "Master Boot Record"
d765 1
a765 1
Le MBR d'OpenBSD s'annonce avec le message suivant:
d774 1
a774 1
("Cylinder-Head-Sector"):
d781 1
a781 1
<li><b><i>Partition Boot Record (PBR):</i></b> Le "Partition Boot Record"
d801 1
a801 1
suite de ce document</a>. Le PBR s'annonce avec le message suivant:
d807 1
a807 1
cas de CHS, il affichera un message suivi d'un point-virgule:
d815 1
a815 1
<li><b><i>Second Stage Boot Loader, <tt>/boot</tt>:</i></b> <tt>/boot</tt> est
d824 1
a824 1
l'utilisateur une invite de commandes similaire à celle-ci:
d836 1
a836 1
OpenBSD n'est pas encore chargé). Précédemment on peut voir qu'il a détecté:
d854 2
a855 2
<li><b><i>Noyau: <tt>/bsd</tt></i>:</b> il s'agit de la finalité du processus de
démarrage, avoir le noyau OpenBSD chargé en mémoire RAM et fonctionnant
d861 1
a861 1
Ainsi, le tout début du processus de démarrage pourrait ressembler à ceci:
d884 1
a884 1
<li><b>Bad/invalid/incompatible MBR:</b> habituellement, un disque déja utilisé
d894 1
a894 1
retrouver en ligne de commandes:
d900 1
a900 1
Vous pouvez également installer un MBR particulier avec fdisk:
d910 1
a910 1
<li><b>Invalid <tt>/boot</tt> location installed in PBR:</b>
d931 1
a931 1
quelque peu complexe. La plupart des messages ressemblent à:
d935 2
a936 2
partir du disque. Habituellement, ceci est assez explicite: votre disque n'était
pas lisible.
d952 1
a952 1
à:
d997 1
a997 1
celle-ci risque de revenir vous hanter de manière peu plaisante:
d1022 1
a1022 1
de problèmes, la règle est simple:
d1038 1
a1038 1
<h3>fsck(8): impératifs de durée et de mémoire</h3>
d1079 1
a1079 1
être wd0, etc):
d1087 1
a1087 1
compiler vous même. Pour ce faire, tapez simplement:
d1101 1
a1101 1
<h3>Introduction:</h3>
d1133 1
a1133 1
<h3>Sauvegarder vers une bande:</h3>
d1139 1
a1139 1
</a> dans un terminal. Vous devriez obtenir une sortie similaire à celle-ci:
d1153 1
a1153 1
Un autre exemple de ce qu'une table de montage plus avancée pourrait être:
d1170 1
a1170 1
pour sauvegarder la table de montage simple vue plus haut:
d1180 1
a1180 1
à:
d1194 1
a1194 1
description des paramètres utilisés:
d1215 1
a1215 1
localiser. Un lecteur de bande peut, par exemple, apparaître ainsi dans dmesg:
d1235 1
a1235 1
à celui-ci:
d1273 1
a1273 1
<h3>Voir le contenu d'une sauvegarde sur bande:</h3>
d1283 1
a1283 1
présents sur une bande:
d1296 1
a1296 1
utiliserez une commande similaire à:
d1309 1
a1309 1
<h3>Restaurer à partir d'une bande:</h3>
d1328 1
a1328 1
restaurer vos données:
d1342 1
a1342 1
exemple:
d1356 1
a1356 1
exemple:
d1369 1
a1369 1
partition que vous venez de créer. Par exemple:
d1378 1
a1378 1
Monter votre nouvelle partition racine (/) sur /mnt. Par exemple:
d1387 1
a1387 1
restauration. Par exemple:
d1397 1
a1397 1
suivante pour y inscrire un nouveau MBR. Par exemple:
d1406 1
a1406 1
démarrage afin de pouvoir lancer la machine. Voici un bref exemple:
d1419 1
a1419 1
effectuez la procédure suivante afin de démonter et redémarrer le système:
d1429 1
a1429 1
l'invite de commandes de boot d'OpenBSD, lancez les commandes suivantes:
d1445 1
a1445 1
plutôt qu'en lecture seule. Lancez la commande suivante:
d1454 1
a1454 1
systèmes de fichiers. Par exemple:
d1486 1
a1486 1
</i>, voici les étapes nécessaires pour la monter:
d1579 1
a1579 1
article, il est important de noter les points suivants:
d1591 1
a1591 1
disponible ici:
d1622 1
a1622 1
Quelques manufactureurs de ce type de produits:
d1629 1
a1629 1
(Note: ce sont des produits que certains utilisateurs d'OpenBSD utilisent ; il
d1682 1
a1682 1
$Translation: faq14.html,v 1.8 2004/11/28 13:44:15 ajacoutot Exp $<br>
@


1.3
log
@Sync with Steelix CVS
@
text
@d4 1
a4 1
<title>14 - Disk Setup</title>
d1682 1
a1682 1
$Translation: faq14.html,v 1.7 2004/11/22 18:05:02 ajacoutot Exp $<br>
@


1.2
log
@Sync with Steelix CVS
@
text
@d217 1
a217 1
est automatiquement définit pour vous en se basant sur le prochain disponible
d241 5
a245 5
Une fois votre système installé, vous ne devrier pas à avoir à utiliser
disklabel trop souvent. Mais parfois, vous aurez besoin de l'utiliser afin
d'ajouter, de supprimer ou de supprimer des disques. Une des premières choses
que vous aurez besoin de faire sera de voir le disklabel actuel. Pour ce faire,
tapez simplement:
d290 1
a290 1
l'installation d'OpenBSD. A priori, la commande la plus importante à connaitre
d379 1
a379 1
<p>Voici un aperçu des commandes possible lorsque vous utilisez l'option
d456 1
a456 1
Vous obtenez 2061. Ainsi, pour décider tes tailles des partitions a, d, e, f, g,
d511 1
a511 1
Anfin, ajoutez-le a <a
d574 2
a575 2
prédéfinit utilisé pour paginer (partition b visible sous disklabel). Comme vous
pouvez le constatez dans l'exemple précédent, cet espace n'est pas beaucoup
d759 1
a759 1
Bien qu'un MBR soit inclut avec OpenBSD, vous n'êtes pas obligé de l'utiliser
d800 1
a800 1
installboot</a>, décris <a href="faq14.html#InstBoot">plus en détails dans la
d807 1
a807 1
cas de CHS, il affichera un message suivit d'un point-virgule:
d843 1
a843 1
étendue (au-dessus d'1M) trouvé.
d849 1
a849 1
disque peut est accessible par LBA. Lors d'une première installation, vous
d918 10
a927 10
Puisque que <tt>/boot</tt> est accédé par au travers d'appels BIOS, les
anciennes versions de PBR étaient dépendentes de la conversion BIOS des disques.
Si vous avez altéré la géométrie (à savoir, pris un disque d'un ordinateur
utilisant la conversion CHS pour le mettre dans une machines utilisant LBA, ou
simplement changé l'option de conversion dans votre BIOS), il <i>apparaitra au
niveau du BIOS</i> comme étant déplacé vers une autre location (un bloc
numérique différent doit être accédé afin de récupérer les mêmes informations du
disque) et vous devrez donc relancer installboot(8) avant que le système ne
puisse être redémarré. Le nouveau PBR (OpenBSD 3.5 et plus) est beaucoup plus
tolérant dans les changement de conversion.
d935 1
a935 1
partir du disque. Habituellement, ceci est assez explicite: wotre disque n'était
d942 1
a942 1
altéré ou encore que vous avez exécé la capacité de votre BIOS à lire les <a
d951 2
a952 1
Pour plus d'information sur le processus de démarrage pour i386, référez-vous à:
d1030 1
a1030 1
immunisés à ce problème, cependant, de nombreuses plateformes possèdent une
d1040 1
a1040 1
sont te temps et la mémoire nécessaires à l'utilisation de <a
d1056 2
a1057 2
Les anciennes version de MS-DOS n'étaient capables d'intéragir qu'avec les
disque dont la géométrie était de 1024 cylindres ou moins. Puisque que nos jours
d1059 1
a1059 1
présents sur les cartes contrôlleur SCSI) et IDE (qui sont inclus avec le reste
d1063 1
a1063 1
(en installant une nouvelle carte mère ou un nouveau contrôlleur SCSI) et que le
d1069 1
a1069 1
IDE et effectués des changements dans la configuration de votre BIOS, vous
d1071 6
a1076 6
des BIOS proposent 3 types de traductions différents).Pour réparer votre bloc de
démarrage afin que vous puissiez booter normalement, insérez une disquette dans
votre lecteur (ou utilisez un CD-ROM bootable) et à l'invite de commandes, tapez
"b hd0a:/bsd" afin de le forcer à démarrer sur le premier disque (et non sur la
disquette). Votre machine devrait se lancer normalement. Vous devez à présent
mettre à jour le chargeur de premier niveau pour qu'il voit la nouvelle
d1104 1
a1104 1
Si envisagez d'administrer ce que l'on pourrait appeler un serveur de
d1125 1
a1125 1
Les périphériques utilisés en exemple dans ce documents se réfèrent à une
d1136 2
a1137 2
Sauvegarder sur bande demande demande de savoir exactement où vos systèmes de
fichiers sont montés. Vous pouvez le déterminer en utilisant la commande <a
d1193 1
a1193 1
</a> afin de connaitre les fonctionnalités de chaque option. Voici une brève
d1257 1
a1257 1
Il serait également utile de documenter (sur un bout de papier) la taille que
d1264 2
a1265 2
Restorer vos données aideront aussi à réduire la fragmentation. Afin d'être sûr
de récupérer tout les fichiers, le meilleur moyen de sauvegarder est de
d1313 3
a1315 4
complètement en panne. Dans le cas ou voutre ne souhaiteriez récupérer qu'un
seul fichier à partir de la bande, référez-vous à la page de manuel de la
commande restore et soyez attentifs aux instructions concernant le mode
intéractif.
d1324 1
a1324 1
votre en machine en production.
d1441 1
a1441 1
En admettant que vous ayez affectué correctement les étapes précédentes et que
d1528 1
a1528 1
Les transfers IDE DMA supportés par <a
d1532 1
a1532 1
prétendant supporter les transfers DMA sur périphériques IDE n'activaient pas
d1538 1
a1538 1
configurer. Ceci pourrait engendrer une corruption dans le transfer des données
d1541 1
a1541 1
Heureusement, les modes Ultra-DMA protègent les transfers de données avec CRC
d1543 1
a1543 1
OpenBSD affichera un message d'erreur et recommencera l'opération de transfer.
d1564 1
a1564 1
obteniez trop de messages d'erreur sur la console et dans les logs, vous pouvez
d1590 1
a1590 1
OpenBSD inclut RAIDframe, une solution logicielle de RAID. La documentation est
d1610 1
a1610 1
plusieurs contrôlleurs RAID matériels. Ceux-ci varient selon les plateformes,
d1617 1
a1617 1
et sont ensuite branchés sur un contrôlleur IDE ou SCSI standard. Ces
d1636 1
a1636 1
diffusion</a> consiste à savoir si "Les contrôlleurs Promise ou HighPoint IDE
d1638 1
a1638 1
véritables contrôlleurs RAID matériels mais plutôt des RAID logiciels assistés
d1647 3
a1649 3
Certaines personnes sont parfois surprisent de voir qu'elles ont un espace
disque disponible <i>negatif</i> ou que plus de 100% de l'espace d'une partition
est utilisé, comme on peut le voir avec <a
d1659 1
a1659 1
imprudemment remplit le disque, vous pouvez vous retrouver avec 105% de capacité
d1682 1
a1682 1
$Translation: faq14.html,v 1.6 2004/11/21 17:03:46 ajacoutot Exp $<br>
@


1.1
log
@Sync with Steelix CVS
@
text
@d45 1
a45 1
<h3>Table of Contents</h3>
d94 1
a94 1
charger le disque et connaître les systèmes de fichiers présents sur celui-ci.
d137 1
a137 1
d'utilisation de disklabel à l'installation. Dans cet exemple, on assume
d139 1
a139 1
complête sera réalisée.
d176 1
a176 1
partition d'échange de 64M. Notez que l'offset (callage du disque) débute au
d190 1
a190 1
signifie qu'il ne s'agit pas d'une installation complête puisque la taille de
d753 1
a753 1
OpenBSD sous-entend la ré-écriture complête du secteur MBR et pas seulement son
d1312 1
a1312 1
complêtement en panne. Dans le cas ou voutre ne souhaiteriez récupérer qu'un
d1418 1
a1418 1
complêt, soyez sûrs de redémarrer en mode single-user. A l'invite de commandes,
d1636 1
a1636 1
messagerie</a> consiste à savoir si "Les contrôlleurs Promise ou HighPoint IDE
d1682 1
a1682 1
$Translation: faq14.html,v 1.3 2004/11/20 12:05:37 ajacoutot Exp $<br>
@

