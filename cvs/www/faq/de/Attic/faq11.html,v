head	1.43;
access;
symbols;
locks; strict;
comment	@# @;


1.43
date	2014.04.01.17.03.08;	author nick;	state dead;
branches;
next	1.42;

1.42
date	2013.11.01.18.04.04;	author ajacoutot;	state Exp;
branches;
next	1.41;

1.41
date	2013.05.01.17.39.06;	author ajacoutot;	state Exp;
branches;
next	1.40;

1.40
date	2013.05.01.14.42.14;	author ajacoutot;	state Exp;
branches;
next	1.39;

1.39
date	2012.11.07.09.26.25;	author ajacoutot;	state Exp;
branches;
next	1.38;

1.38
date	2012.05.01.19.11.27;	author ajacoutot;	state Exp;
branches;
next	1.37;

1.37
date	2012.04.16.00.11.29;	author ajacoutot;	state Exp;
branches;
next	1.36;

1.36
date	2012.01.31.23.04.08;	author ajacoutot;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.21.19.34.37;	author ajacoutot;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.05.18.34.05;	author ajacoutot;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.22.17.47.58;	author ajacoutot;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.21.09.10.46;	author ajacoutot;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.26.08.25.02;	author tobias;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.13.18.21.55;	author tobias;	state Exp;
branches;
next	1.29;

1.29
date	2008.03.09.13.37.12;	author tobias;	state Exp;
branches;
next	1.28;

1.28
date	2008.01.06.13.57.19;	author tobias;	state Exp;
branches;
next	1.27;

1.27
date	2007.12.16.17.18.35;	author tobias;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.01.10.39.10;	author tobias;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.12.20.29.58;	author saad;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.26.03.08.02;	author jufi;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.10.10.44.44;	author jufi;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.30.13.47.18;	author jufi;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.24.12.42.01;	author jufi;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.25.08.25.48;	author saad;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.06.17.23.10;	author jufi;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.27.21.23.26;	author saad;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.14.11.35.59;	author jufi;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.30.08.23.46;	author saad;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.20.07.30.01;	author saad;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.15.04.26.14;	author saad;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.10.14.25.28;	author saad;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.30.13.52.07;	author saad;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.20.14.55.33;	author jufi;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.12.20.36.53;	author jufi;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.18.17.17.47;	author jufi;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.14.20.22.29;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.02.18.40.59;	author jufi;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.29.21.31.33;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.17.18.47.48;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.15.22.51.40;	author jufi;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.21.18.29.25;	author jufi;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.06.21.10.04;	author jufi;	state Exp;
branches;
next	1.1;

1.1
date	2002.08.05.16.39.17;	author jufi;	state Exp;
branches;
next	;


desc
@@


1.43
log
@
Abandon translations, per deraadt@@ and ajacoutot@@.
Thanks to all those that did the translation work, and my appologies to
those who had to translate my writing!
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>11 - Das X Fenstersystem</title>

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rev="made" href="mailto:www@@openbsd.org">
<meta name="resource-type" content="document">
<meta name="description" content="OpenBSD FAQ 11 - The X Window System">
<meta name="keywords" content="openbsd,faq11">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1998-2013 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" src="../../images/smalltitle.gif" border="0" height="30" width="141">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ-Index]</a>
<a href="faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href="faq12.html">[Zum Kapitel 12 - Hardware- und Plattformspezifische Fragen]</a>
</font>

<h1><font color="#e00000">11 - Das X Fenstersystem</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#Intro"       >11.1 - Einführung in X</a>
<li><a href="#ConfigX"     >11.2 - Konfiguration von X</a>
<li><a href="#amd64i386"   >11.3 - Konfiguration von X auf amd64 und i386</a>
<li><a href="#StartingX"   >11.4 - X starten</a>
<li><a href="#CustomizingX">11.5 - X anpassen</a>
</li>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>11.1 - Einführung in X</h2>

Das X Fenstersystem (»X Window System«; manchmal nur »X« oder fälschlicherweise
»X Windows« genannt) ist eine grafische Umgebung, die Grafikanwendungen unter
OpenBSD und anderen Unix-basierten Systemen benötigte Funktionen anbietet.
X selbst stellt aber nur wenig bereit: Man muss ebenfalls einen »Window
Manager« haben, um eine Benutzerschnittstelle zu schaffen. Das meiste
der sogenannten »Personality« von X wird vom Windowmanager ausgehen
statt von X selbst.
OpenBSD bringt freie Versionen der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fvwm&amp;sektion=1">fvwm(1)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cwm&amp;sektion=1">cwm(1)</a>
Fenstermanager mit.
Wenn du möchtest, kannst du auch einen der anderen
Windowmanager verwenden, die als <a href="faq15.html">Pakete</a>
bereitgestellt werden. Verwende das Suchwort »<tt>window manager</tt>«,
um eine Liste der vielen verfügbaren Windowmanager zu erhalten.

<p>
X wird als »Client-Server«-strukturiertes Protokoll aufgefasst,
obwohl die Terminologie manchmal etwas verwirrend ist.
Der Computer, der die Grafik auf dem Bildschirm anzeigt, ist der
»X-Server«. Die Anwendung, die dem X-Server mitteilt, was auf
dem Bildschirm angezeigt werden soll, ist der »X-Client«, selbst
wenn es sich hierbei um einen leistungsstärkeren Computer in einem
Rechenzentrums handelt. Dieses Modell kann genutzt werden, um
rechenintensive Anwendungen (X-Clients) auf sehr leistungsstarken
Maschinen auszuführen, die den X-Server als Benutzerschnittstelle
verwenden, der auf einer kleinen und stromsparenden Maschine auf
deinem Schreibtisch läuft.

<p>
Es ist möglich, X-Clients auf einem System auszuführen, das über
keine grafische Ausgabemöglichkeit verfügt. Man könnte zum
Beispiel eine Anwendung (den X-Client) auf einer mvme88k
ausführen und die Ausgabe auf einem Bildschirm einer Alpha anzeigen
lassen (der X-Server). Da X ein klar definiertes und
plattformübergreifendes Protokoll ist, ist es sogar möglich, eine
X-Anwendungen auf einer (beispielsweise) Solaris-Maschine auszuführen
und auf einer OpenBSD-Maschine anzeigen zu lassen.

<p>
Der Client und der Server können auch auf dem gleichen System laufen.
Im Rest dieses Kapitels gehen wir hiervon aus.

<h3>11.1.1 - Wieviel Rechenleistung benötige ich, um X verwenden zu
können?</h3>
X selbst ist ein recht großes Programm, sodass ein schneller Rechner
bestens geeignet ist, wenn du es regelmäßig an- und ausstellst. Wenn
es aber erst einmal läuft, dann reicht auch ein sehr bescheidener
Rechner.
Eine Plattformen benötigen X grundsätzlich für eine responsive
Bildschirmausgabe, sogar für die reinen Texts.
Diese Plattformen, zu denen <a href="../../de/sparc.html">sparc</a> und
<a href="../../de/sparc64.html">sparc64</a> gehören, wurden für die Benutzung
über eine grafische Oberfläche entworfen, und die Performance ihrer
Textkonsolen ist sehr schlecht.

<p>
Soweit zur Grundlage. X wird normalerweise gestartet, um X-Anwendungen
aufrufen zu können. Einige X-Applikationen sind sehr genügsam, andere
scheinen sich hingegen alle Rechenleistung und verfügbaren RAM unter
den Nagel zu reißen. Selbstverständlich gibt es auch Leute, die X
verwenden, um eine große Anzahl
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xterm&amp;sektion=1">xterm(1)</a>s
aufzurufen - hierfür reicht auch sehr schlichte Hardware.

<h3>11.1.2 - Kann ich auch Grafiken ohne X verwenden?</h3>
Angenommen dir genügen
<a href="http://en.wikipedia.org/wiki/ASCII_Art">ASCII-Grafiken</a>
nicht, so musst du auf eine Art von Framebuffer-Konsolentreibern
zurückgreifen. Einige Betriebssysteme stellen diese zur Verfügung,
doch gibt es momentan keine für OpenBSD. Unter den Entwicklern hat
auch niemand großes Interesse daran.

<p>
<a name="ConfigX"></a>
<h2>11.2 - Konfiguration von X</h2>
<b>Gute Neuigkeiten: Für die überwiegende Mehrheit an Hardware der meisten
Plattformen benötigt X überhaupt keine Konfiguration, sondern funktioniert
einfach.</b>

<p>
Die Details der manuellen Konfiguration von X unterscheidet sich deutlich
zwischen den einzelnen Plattformen.
In allen Fällen gibt es aber Anleitungen und
andere plattformspezifische Informationen in
<tt>/usr/X11R6/README</tt>, die auf einem installierten System
vorgefunden werden kann.


<p>
Viele Plattformen benötigen den X-Aperturetreiber
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xf86&amp;sektion=4">xf86(4)</a>,
der direkten Zugriff auf den Speicher und die Ein-/Ausgabeports
des VGA-Boards und der PCI-Konfigurationsregister ermöglicht, was für
die X-Server eine Voraussetzung ist. Dieser Treiber muss aktiviert
werden, bevor er genutzt werden kann - entweder indem mit »Yes« auf
die Frage

<blockquote><pre>
Do you expect to run the X window System [no]
</pre></blockquote>

geantwortet wird (diese ist während der Installation zu sehen) oder
indem man <tt>machdep.allowaperture</tt> in der
<tt>/etc/sysctl.conf</tt> auf einen der Plattform entsprechenden
Wert setzt (dieser darf nicht 0 sein) und neustartet, da diese
Sysctl aus Sicherheitsgründen nach dem Bootvorgang nicht mehr geändert
werden kann. Die Verwendung des Treibers zieht Sicherheitsbedenken
nach sich. Du solltest ihn nicht aktivieren, wenn du nicht unbedingt
auf ihn angewiesen bist.


<h3>11.2.1 - alpha</h3>
<a
href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.alpha"
>/usr/X11R6/README</a> für alpha.

<p>
Setze <tt>machdep.allowaperture=1</tt> in <tt>/etc/sysctl.conf</tt>.

<p>
Die TGA- und einige VGA-Karten werden unterstützt. Es sollte keine
weitere Konfiguration notwendig sein.

<h3>11.2.2 - amd64</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.amd64"
>/usr/X11R6/README</a> für amd64.

<p>
Setze <tt>machdep.allowaperture=2</tt> in <tt>/etc/sysctl.conf</tt>.

<p>
Für die überwiegende Mehrheit von Benutzern wird X auf amd64 erfolgreich
automatisch konfiguriert, sodass keinerlei weitere Konfiguration nötig ist.
WENN eine weiterführende Konfiguration nötig ist, benutze
<a href="#amd64i386">X&nbsp;-configure</a> wie weiter
<a href="#amd64i386example">unten</a> beschrieben.

<h3>11.2.3 - armish</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.4 - hp300</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.hp300"
>/usr/X11R6/README</a> für hp300.

<h3>11.2.5 - hppa</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.6 - i386</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.i386"
>/usr/X11R6/README</a> für i386.

<p>
Setze <tt>machdep.allowaperture=2</tt> in <tt>/etc/sysctl.conf</tt>.

<p>
Für die überwiegende Mehrheit von Benutzern wird X auf i3864 erfolgreich
automatisch konfiguriert, sodass keinerlei weitere Konfiguration nötig ist.
WENN eine weiterführende Konfiguration nötig ist, benutze
<a href="#amd64i386">X&nbsp;-configure</a> wie weiter
<a href="#amd64i386example">unten</a> beschrieben.

<h3>11.2.7 - landisk</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.8 - loongson</h3>
Es wird keine Konfiguration benötigt.

<h3>11.2.9 - luna88k</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.10 - macppc</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.macppc"
>/usr/X11R6/README</a> für macppc.

<p>
Setze <tt>machdep.allowaperture=2</tt> in <tt>/etc/sysctl.conf</tt>.

<p>
Unterstützte Macintosh-PPC-Systeme können auf zwei unterschiedliche
Weisen verwendet werden:
»beschleunigt« oder »Framebuffer« (unbeschleunigt).

<p>
Im »Framebuffer«-Modus wird das System mit 8 Bits pro Pixel arbeiten
und die Videoauflösung wird von der Macintosh-Umgebung geregelt. Das
bedeutet, dass du eine kleine MacOS-Partition auf deiner Platte
belassen möchtest, um von dort aus diese Einstellungen anzupassen.
Dieser Modus hat den Vorteil, dass er »einfach funktioniert«, doch
kann es frustrierend einschränkend sein (zum Beispiel setzt eine
Änderung der Auflösung einen Boot von MacOS voraus).

<p>
Wenn dein Macintosh ein ATI-basiertes Videosystem hat, kannst du es
mit einem beschleunigten X-Server verwenden. Dieser liefert bessere
Geschwindigkeiten und mehr Kontrolle in deiner OpenBSD-Umgebung.
Die NVIDIA-Grafikkarten einiger macppc-Systeme werden auch in vielen
Fällen funktionieren.
Die Datei README hat Details über die Konfiguration beschleunigter Treiber,
starte daher mit der dort gezeigten Beispieldatei.

<p>
Während die README-Datei detailliert auf die Verwendung der Standardmaus
von Apple mit nur einer Taste unter X eingeht, wird dir dringend dazu
geraten, dir einfach eine USB-Maus eines Drittanbieters mit drei oder mehr
Knöpfen zu kaufen - es sei denn, du verwendest einen Laptop.

<h4>Röhrenmonitor-iMacs und X</h4>
iMacs haben einen (für die heutige Zeit) sehr ungewöhnlichen Röhrenmonitor,
da dieser über eine feste horizontale Ablenkfrequenz verfügt.
Der Versuch, eine horizontale Bildaufbaugeschwindigkeit jenseits eines sehr
engen Bereichs zu nutzen, wird dazu führen, dass der Monitor nicht leuchtet.
Die folgenden Zeilen, hinzugefügt zu dem Abschnitt <tt>Section "Monitor"</tt>
der Datei xorg.conf, scheint viele Röhrenmonitor-basierte iMacs aus dem
Bereich 333 MHz bis 500 MHz (und vielleicht mehr) dazu zu bringen, ordentlich
zu laufen:

<blockquote><pre>
        HorizSync       60.0 - 60.0
        VertRefresh     43.0 - 117.0 
</pre></blockquote>

Vielleicht möchtest du die untere Grenze von <tt>VertRefresh</tt> auf Werte
beschränken, die du eher akzeptabel findest, zum Beispiel 70.

<h3>11.2.11 - mvme68k</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.12 - mvme88k</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.13 - sgi</h3>
X läuft auf dem O2 Bildpuffer (»frame buffer«) des Systems im unbeschleunigten
Modus.

<h3>11.2.14 - sparc</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.sparc"
>/usr/X11R6/README</a> für sparc.

<p>
Mit nur einem unterstützten Framebuffer wird keine Konfiguration
benötigt. Wenn du eine Multihead-Konfiguration verwenden möchtest,
wirf einen Blick auf die zuvor genannte README-Datei für weitere
Details.

<p>
Die Auflösung wird von der Firmware eingestellt, bevor OpenBSD bootet.

<h3>11.2.15 - sparc64</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.sparc64"
>/usr/X11R6/README</a> für sparc64.

<p>
Die meisten einfachen Konfigurationen »laufen einfach«.
Tut es deine nicht, oder solltest du wünschen raffiniert zu werden, lies die
oben angeführte README-Datei.

<h3>11.2.16 - vax</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.vax"
>/usr/X11R6/README</a> für vax.

<p>
Der X-Server funktioniert momentan nur auf VAXstation-4000-Modellen mit
einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lcg&amp;sektion=4&amp;arch=vax">lcg(4)</a>-
oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lcspx&amp;sektion=4&amp;arch=vax">lcspx(4)</a>-Framebuffer.

<h3>11.2.17 - zaurus</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.zaurus"
>/usr/X11R6/README</a> für zaurus.

<p>
Es wird keine Konfiguration benötigt, X »funktioniert einfach«.


<p>
<a name="amd64i386"></a>
<h2>11.3 - Konfiguration von X auf amd64 und i386</h2>
Wenn du noch nicht versucht hast,
<a href="#StartingX">X einfach zu starten</a>, so warte!
Produziere für dich selbst keine Arbeit, wenn du nicht musst!
Die meisten Nutzer von i386 und amd64 werden auch ohne manuelle Konfiguration
schlichtweg ein funktionierendes X vorfinden.

<h3>11.3.1 - Konfiguration von X.Org</h3>
Manchmal funktioniert X nicht »einfach so« wie gewünscht, und manchmal muss man
Dinge anpassen, obwohl sie funktionieren.

<p>
Funktioniert X nicht wie gewünscht auf einem System, so muss man eine
Konfigurationsdatei erzeugen.
Ein guter Startpunkt (und manchmal bereits das Ziel!) ist das Ausführen von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Xorg&amp;sektion=1"
>Xorg(1)</a> im Modus »X -configure«.
Letzterer wird alle verfügbaren Grafikkartentreiber laden, andere Hardware
austesten, und, basierend auf dem, was vorgefunden wurde, eine Datei xorg.conf
schreiben, die funktionieren kann, aber nicht muss.
Selbst wenn sie nicht funktionieren sollte, wird sie immer noch als nützliche
Grundlage für eine dienen, die funktioniert wie gewünscht.

<p>
Eine altehrwürdige Methode zur Konfiguration von X ist die Benutzung deiner
favorisierten Suchmaschine, um nach jemanden zu suchen, der dein Problem
bereits für dich gelöst hat.
Ebenfalls bemerkenswert ist, dass die <tt>xorg.conf</tt>-Dateien anderer
UNIX-ähnlicher Betriebssysteme oft nützliche Tipps darüber enthalten, was
letztendlich benötigt wird, um X auf ähnlicher Hardware zum Laufen zu bringen.
Obwohl dies kein schlechter Weg ist, wird auf diese Methode hier nicht näher
eingegangen.

<p>
<a name="amd64i386example"></a>
<h3>11.3.2 - Unsere Beispielmaschine</h3>
Als Demonstration, wie man X einrichtet, werden wir ein altes
System mit einem Celeron 400 MHz und einem AGP-Steckplatz verwenden.
Bei der Grafikkarte handelt es sich um eine alte AGP-Karte, die wie
folgt in der Dmesg aufgelistet wird:

<blockquote><pre>
vga1 at pci1 dev 0 function 0 "3DFX Interactive Banshee" rev 0x03
</pre></blockquote>

Dies war einmal eine Highend-Grafikkarte mit 16 MB RAM, doch wird
sie heutzutage von »gängigen« Betriebssystemen fast nicht mehr
unterstützt. Des Weiteren wird ein Sony Multiscan G400 19" CRT als
Monitor angeschlossen. Es wäre schön, wenn dieser Monitor bei einer
Auflösung von 1280x1024, einer angenehmen Bildwiederholrate und
24 Bit Farbtiefe genutzt werden kann.

<p>
Nachdem OpenBSD mit X installiert wurde (wir haben sichergestellt,
dass der Aperturetreiber im Kernel aktiviert wurde) werfen wir zuerst
einen Blick auf die automatische Erkennung und Konfiguration von X.Org
- vielleicht haben wir Glück. So, wir loggen uns einfach ein und rufen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=startx&amp;sektion=1">startx(1)</a>
auf. Der Bildschirm wird für ein paar Momente schwarz, dann erhalten
wir den »Schachbrett«-Hintergrund von X, den »X«-Cursor und ein
xterm-Fenster.

<p>
Es funktioniert!

<p>
Mehr oder weniger. Obwohl das System voll einsatzfähig ist, scheint es
keine Funktionalitäten des Monitors erkannt zu haben und läuft auf
einer eindeutig zu niedrigen Auflösung (640x480). Wir hoffen mal, dass
wird das noch besser hinbekommen - damit meine ich sehr viel besser.
Das heißt also, dass wir unsere eigene xorg.conf-Datei erstellen müssen.

<p>
Wir verwenden die »X -configure«-Methode, um eine Grundlage für unsere
<tt>xorg.conf</tt>-Datei zu schaffen. Du musst folgenden Befehl als
root ausführen:
<blockquote><pre>
# <b>X -configure</b>
 [...]
Your xorg.conf file is /root/xorg.conf.new

To test the server, run 'X -config /root/xorg.conf.new'
</pre></blockquote>

Im Übrigen muss die Meldung ernst genommen werden - verwende den
vollständigen Pfad zu deiner <tt>xorg.conf.new</tt>-Datei, selbst wenn
du dich im gleichen Verzeichnis befindest.
Dies nicht zu tun führt dazu, dass
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=X&amp;sektion=7">X(7)</a>
die Datei nicht findet, und ohne weitere Meldung die Standardkonfiguration
benutzen; und wenn diese funktioniert hätte, dann hättest du diesen Vorgang ja
nicht durchgeführt!
Es kann die Fehlersuche deutlich vereinfachen.
Vertraue uns in diesem Punkt.

<p>
Wir führen also aus, was uns gesagt wird:
<blockquote><pre>
# <b>X -config /root/xorg.conf.new</b>
</pre></blockquote>

Alles was wir kriegen ist ein schwarzes Bild.
Dabei hat es so gut angefangen ...

<p>
Nun ist ein guter Zeitpunkt gekommen, um über die unterschiedlichen
Möglichkeiten zu sprechen, X zu beenden, wenn es auf diese Weise
gestartet wurde. Nach Vorzug sortiert sind es:
<ul>
<li><b>STRG-ALT-Backspace</b>: Dies wird X hoffentlich sofort
terminieren - mit samt allen X-Anwendungen, die momentan laufen.
Selbstverständlich werden während der Konfiguration keine Anwendungen
laufen, sodass dies kein Problem darstellen wird (genau genommen ist
es zu diesem Zeitpunkt die <i>beste</i> Möglichkeit, X zu beenden).
<li><b>Mit SSH auf den Rechner zugreifen</b> und
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkill&amp;sektion=1">pkill</a>
Xorg« aufrufen. Dies könnte den X-Prozess beenden und dich zurück auf
eine funktionierende Konsole befördern.
<li><b>Mit SSH auf den Rechner zugreifen</b> und ihn neustarten.
<li><b>Reset oder Runterfahren.</b> Manchmal gibt es wirklich keinen
anderen Ausweg. Ja, es ist grundsätzlich eine gute Idee, X konfiguriert
zu haben, bevor du wichtige Anwendungen auf deinem System ausführst.
Manchmal kann es vorkommen, dass eine schlechte X-Konfiguration die
gesamte Maschine in die Knie zwingt, sodass nur noch aus- und wieder
anstellen das Problem beheben kann.
</ul>

Zum Glück verrichtet STRG-ALT-Backspace erfolgreich seine Dienste und
wir befinden uns wieder in der Kommandozeile. Nun müssen wir
herausfinden, was fehlgeschlagen ist. Zuerst sollten wir nachsehen, was
Xorg über die Hardware denkt. Das können wir in der Datei
<tt>/var/log/Xorg.0.log</tt> nachlesen. In diesem Fall denkt X, dass
alles einwandfrei läuft - keine offensichtlich schwerwiegenden
Fehler werden in der Logdatei aufgeführt (Zeilen, die mit
»<tt>EE</tt>« beginnen, sind Fehler).

<p>
An dieser Stelle kommt unser Wissen über die Hardware ins Spiel. Wenn
wir das System an einen anderen Monitor anschließen, während ein
schwarzes Bild angezeigt wird, gibt er uns eine
»Sync. out of Range«-Meldung auf dem Bildschirm aus. Offensichtlich
scheint die Konfiguration von X nicht mit diesem Monitor zu
funktionieren. Eventuell läuft diese Konfiguration auf KEINEM Monitor,
wenn ein Videomodus ausgewählt wurde, der mit der Karte nicht zusammen
funktioniert (beachte bitte, dass X sich am Chip auf der Karte
und dessen Leistung orientiert - nicht daran, wie der Hersteller die
Komponenten zusammengestellt hat). Unterschiedliche Monitore werden
verschieden reagieren, wenn die Rate falsch ist. Einige werden
versuchen, das Bild anzuzeigen, andere werden in den Energiesparmodus
wechsel, andere schreckliche Geräusche von sich geben und wieder
andere werden hilfreiche Meldungen auf dem Bildschirm angeben. Dieser
Bildschirm scheint zu keiner der zuvor genannten Arten gehören. Wir
merken uns einfach, diesen Monitor NIE wieder für grundlegende
X-Konfigurationen zu verwenden.

<p>
Während wir durch die erstellte xorg.conf.new-Datei gehen, sehen wir
folgenden Eintrag:
<blockquote><pre>
Section "Monitor"
        #DisplaySize      370   270     # mm
        Identifier   "Monitor0"
        VendorName   "SNY"
        ModelName    "SONY CPD-G400"
 ### Comment all HorizSync and VertSync values to use DDC:
        HorizSync    30.0 - 107.0
        VertRefresh  48.0 - 120.0
        Option      "DPMS"
EndSection
</pre></blockquote>

Zum Testen werden wir einen DDC-Monitor (»Data Display Channel« - damit
kann der Monitor dem Computer und der Grafikkarte mitteilen, wozu er
in der Lage ist) verwenden und sehen, was geschieht. Dieses Mal erhalten
wir wieder das Schachbrettmuster von X und einen beweglichen Cursor. Das
ist alles, was wir von X erwarten, wenn wir es so aufrufen (wir beenden
X mit dem STRG-ALT-Backspace-Trick von vorhin). Es ist (wieder) eine
niedrige Auflösung, doch es funktioniert. Wir können also davon
ausgehen, dass wir ein Raten- und Auflösungsproblem haben. Wir werden
zuerst die »HorizSync«- und »VertRefresh«-Zeilen wiederherstellen,
da wir die Spezifikationen des Monitors im Internet gefunden und
überprüft haben.

<p>
Wir werden nun versuchen, Xorg auf eine bestimmte Auflösung zu trimmen
und zu sehen, ob wir damit Glück haben. In <tt>Section "Screen"</tt>
der xorg.conf-Datei werden wir ein paar Zeilen hinzufügen, die hier
fett gedruckt sind:

<blockquote><pre>
Section "Screen"
        Identifier "Screen0"
        Device     "Card0"
        Monitor    "Monitor0"
<b>        DefaultDepth   24</b>
        SubSection "Display"
                Viewport   0 0
                Depth     1
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     4
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     8
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     15
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     16
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     24
<b>                Modes	"1280x1024"</b>
        EndSubSection
EndSection
</pre></blockquote>

Diese beiden Änderungen teilen X mit, dass wir eine Farbtiefe von
24 Bit verwenden möchten und für 24 Bit Farbtiefe eine Auflösung
von 1280x1024. Da keine andere Auflösung unter »Depth 24« aufgelistet
ist, wird das System dazu gezwungen sein, diese Auflösung zu
verwenden.

<p>
Wir testen die neue Konfiguration und ... ERFOLG!
Wir scheinen ein schönes und hoch auflösendes Display zu besitzen.
Beachte, dass wir NUR ein Schachbrettmuster (das sehr gut geeignet ist,
um die Qualität deines Bildschirms zu prüfen und um LCDs zu kalibrieren
[»<a href="http://www.openbsd.org/cgi-bin/cvsweb/xenocara/data/bitmaps/root_weave">root
weave</a>«]) und einen beweglichen Cursor erwarten. An diesem Punkt
erwarten wir noch keine voll einsatzfähige Oberfläche.

<p>
Nun werden wir die xorg.conf-Datei installieren, sodass wir den
alltäglichen Aufruf von X testen können.

<blockquote><pre>
# cp xorg.conf.new /etc/X11/xorg.conf
</pre></blockquote>

Wir können nun versuchen, X mit dem normalen startx(1)-Kommando zu
starten. Es funktioniert!

<p>
Es wäre auch nicht schlecht, zu überprüfen, ob es sich wirklich um
die Auflösung und Farbtiefe handelt, die wir angestrebt haben. Das
ganze soll selbstverständlich auch mit einer angenehmen
Bildwiederholrate angezeigt werden. Wir können dies mit den Kommandos
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xrandr&amp;sektion=1">xrandr(1)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdpyinfo&amp;sektion=1">xdpyinfo(1)</a>
überprüfen. Neben anderen Informationen liefert xdpyinfo(1):
<blockquote><pre>
    [...]
screen #0:
  print screen:    no
  dimensions:    1280x1024 pixels (433x347 millimeters)
  resolution:    75x75 dots per inch
  depths (7):    24, 1, 4, 8, 15, 16, 32
  root window id:    0x44
  depth of root window:    24 planes
    [...]
</pre></blockquote>

Die Antwort ist also »ja, wir verwenden 1280x1024 mit einer Tiefe von
24 Ebenen (Bits).«

<p>
Folgende Ausgabe liefert xrandr(4):
<blockquote><pre>
 SZ:    Pixels          Physical       Refresh
*0   1280 x 1024   ( 433mm x 347mm )  *85   75   60
 1   1280 x 960    ( 433mm x 347mm )   85   60
    [...]
</pre></blockquote>

Das sagt uns, dass wir mit einer Bildwiederholrate von 85 Hz arbeiten.
Die meisten Anwender empfinden dies als eine sehr angenehme Einstellung.

<p>
<h3>11.3.3 - Was ist, wenn es nicht so »einfach« ist?</h3>
Manchmal passen Dinge einfach nicht zusammen. Hier sind ein paar Tipps.

<ul>
<li>Lies die Handbuchseite des X-Servers, den du einsetzt. In unserem
Beispiel können wir aus der <tt>/var/log/Xorg.0.log</tt>-Datei
entnehmen, dass wir TDFX als Treiber verwenden. Wir sollten also in
der <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tdfx&amp;sektion=4">tdfx(4)</a>-Handbuchseite
nachsehen. Dort wirst du meistens Tipps, Einschränkungen und
Konfigurationsoptionen für deine Grafikkarte finden. Diese variieren
aber von Treiber zu Treiber, sodass du nicht davon ausgehen solltest,
nicht weiter auf die Handbuchseite angewiesen zu sein, nur weil du bereits
eine andere gelesen hast.

<li>Probiere unterschiedliche Monitore aus. Wie wir in unserem
Beispiel gelernt haben, liefern unterschiedliche Monitor verschiedene
Lösungsansätze.

<li>Teste den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vesa&amp;sektion=4">vesa(4)</a>-X-Treiber.
Dieser ist zwar aus Geschwindigkeitsgründen definitiv eine »letzte
Möglichkeit«, doch funktioniert er mit den meisten Grafikkarten -
selbst mit denen, die über keinen »besseren« Treiber für den X-Server
verfügen.

<li>Teste unterschiedliche Hardware. Wenn du über mehrere Grafikkarten
verfügst, probiere ein paar andere.


</ul>

<a name="StartingX"></a>
<h2>11.4 - X starten</h2>
Es gibt zwei übliche Wege, X auszuführen:

<h3>11.4.1 - nach Bedarf:</h3>
Melde dich wie gewöhnlich an einer Konsole an und führe dann
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=startx&amp;sektion=1">startx(1)</a>
aus.

<h3>11.4.2 - boote direkt in X:</h3>
Dies wird mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdm&amp;sektion=1">xdm(1)</a>
realisiert, dem X Display Manager.
xdm(1) wird als root ausgeführt (normalerweise über
<a href="faq10.html#rc">rc</a>) und zeigt einen Anmeldeprompt an.
Nach erfolgreicher Anmeldung wird eine X-Sitzung für diesen Benutzer
erstellt. Wenn diese X-Sitzung beendet werden soll (zum Beispiel über
STRG-ALT-Backspace), wird xdm(1) wieder die Kontrolle übernehmen und
den Benutzer erneut nach seinen Anmeldedaten fragen. Aus diesem Grund
sollte xdm(1) NICHT von <tt>/etc/rc.conf.local</tt> aus aufgerufen
werden, bis du dir sicher bist, dass X so läuft wie du es dir gedacht
hast - ansonsten wird deine Maschine sehr schlecht zu warten sein!
(Schlimmster Fall: Boote in den Singleuser-Modus als hättest du
<a href="faq8.html#LostPW">dein Passwort vergessen</a> und editiere
die xdm_flags-Zeile deiner <tt>/etc/rc.conf.local</tt>-Datei.)

<p>
Auf einigen Plattformen musst du das für die Konsolen zuständige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8">getty(8)</a>
deaktivieren, um xdm(1) starten zu können.

<p>
<a name="CustomizingX"></a>
<h2>11.5 - X anpassen</h2>

<h3>11.5.1 - Einführung</h3>
Die standardmäßige X-Umgebung von OpenBSD ist voll funktionsfähig,
aber du könntest es anpassen wollen.
Du könntest das Muster oder die Farbe des Hintergrunds ändern wollen,
oder es könnte dir einfallen, den Fensterverwalter (das Programm, das deine
X-Umgebung am meisten definiert) zu ändern, oder aber welche Programme
automatisch gestartet werden, wenn X gestartet wird.

<p>
Der Standard-Fensterverwalter von OpenBSD ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fvwm&amp;sektion=1"
>fvwm(1)</a>.
fvwm ist ein guter Allzweck-Fensterverwalter, aber keineswegs deine einzige
Auswahl; es ist noch nicht einmal der einzige Fensterverwalter, der
standardmäßig in OpenBSD vorhanden ist (siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cwm&amp;sektion=1"
>cwm(1)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=twm&amp;sektion=1"
>twm(1)</a>).
Eine große Auswahl an Fensterverwaltern ist außerdem als
<a href="faq15.html">Paket</a> verfügbar.

<p>
Ähnlich den <a href="faq10.html#rc">Systemstart-Skripts</a> folgt X einem
definierten Ablaufplan, um die Benutzerumgebung einzurichten.
Genauer gesagt existieren mehrere solche Startprozedere; welchem gefolgt wird,
hängt davon ab, wie <a href="#StartingX">X gestartet wird</a>.
Zu verstehen, wie X startet, wird dir helfen zu verstehen, wie deine
Arbeitsumgebung exakt so anzupassen ist, dass es deinen Wünschen entspricht.

<p>
Man kann die Umgebung sowohl auf System-, als auch auf Benutzerebene anpassen.
Es ist vielleicht besser, Änderungen auf Benutzer-, als auf Systemebene
durchzuführen, da die Benutzerskripte in dem Heimatverzeichnis des Benutzers
gespeichert werden, sodass weniger Dateien vereinigt werden müssen, wenn du
dein OpenBSD auf eine neue Version nachrüstest (»upgrade«).

<!--XXX version -->
Die systemweit gültigen Standards befinden sich in <tt>/etc/X11</tt> und werden
ursprünglich von dem <a href="faq4.html#FilesNeeded">xetcXX.tgz</a> Dateiset
installiert, welches von dem
<a href="../upgrade54.html">vorgeschlagenen Upgradeprozedere</a> nicht erfaßt
wird, d.&nbsp;h. werden Änderungen an den systemweiten Daten vorgenommen, so
werden diese zwar bestehen, jedoch wird es eventuell nötig sein, diese
Änderungen manuell in spätere Versionen der entsprechenden Dateien einfließen
zu lassen.


<h3>11.5.2 - startx(1)-Start</h3>
startx(1) sucht die Datei <tt>.xinitrc</tt> in dem Heimatverzeichnis des
Benutzers.
<tt>.xinitrc</tt> ist normalerweise ein Shellskript, der so viele X »Klienten«
(Anwendungen, die X benutzen) starten kann wie gewünscht.
Wird dieser Skript beendet, schließt sich der X-Server.
Im Allgemeinen sollten die meisten Programme, die von diesem Skript gestartet
werden, im Hintergrund laufen, obgleich das Letzte im Vordergrund laufen sollte
(typischerweise ist dies der Fensterverwalter); wird es beendet, beendet sich
der Skript, und X wird geschlossen.

<p>
Im einfachsten Fall braucht es aus nicht mehr als dem Namen des gewünschten
Fensterverwalters zu bestehen, der ausgeführt werden soll:

<blockquote><pre>
cwm
</pre></blockquote>

Oder man kann ein wenig ausgefallener sein:

<blockquote><pre>
xconsole -geometry -0+0 -fn 5x7 &
oclock -geometry 75x75-0-0 &
xsetroot -solid grey &
cwm
</pre></blockquote>

Dies startet die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xconsole&amp;sektion=1"
>xconsole(1)</a>, die eine Kopie ein jeden Texts zeigt, den der Kernel auf die
Konsole geschrieben hätte (die jetzt ja von einem grafischen Bildschirm
eingenommen wird), eine analoge Uhr,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=oclock&amp;sektion=1"
>oclock(1)</a>, und konfiguriert den Hintergrund zu einer geschlossenen grauen
Fläche mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xsetroot&amp;sektion=1"
>xsetroot(1)</a>, und dies alles bevor der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cwm&amp;sektion=1"
>cwm(1)</a> Fensterverwalter gestartet wird.
Beachte, wie einzig der Fensterverwalter nicht durch das Anhängen eines
»&amp;«-Zeichens »in den Hintergrund geschickt wird«.
Dies bedeutet, das X solange laufen wird, bis cwm(1) beendet wird.

<p>
Besitzt das Heimatverzeichnis eines Benutzers keine Datei <tt>.xinitrc</tt>,
so wird die des Systems, <tt>/etc/X11/xinit/xinitrc</tt>, benutzt.
Diese Datei kann dich mit einigen zusätzlichen Ideen für deinen eigenen
.xinitrc-Skript versorgen.


<h3>11.5.3 - xdm(1)-Start</h3>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdm&amp;sektion=1"
>xdm(1)</a> wird normalerweise von den
<a href="faq10.html#rc">Systemstart-Skripten</a> gestartet, aber für Testzwecke
(empfohlen, es sei denn du weißt, dass deine X-Konfiguration in Ordnung ist)
kann man ihn als root starten.

<p>
xdm(1) besitzt viel mehr Funktionalität als hier besprochen wird,
aber für unsere Zwecke gilt, dass xdm dem Benutzer einen Anmeldebildschirm
präsentieren wird, den Namen und das Passwort eines Benutzers abfragen und
verifizieren wird, um letztlich dem Benutzer seine X-Umgebung zur Verfügung zu
stellen.
Beendet sich X, entweder absichtlich oder aus Versehen, so wird xdm es erneut
starten.
Dies ist der Grund, warum man sicherstellen sollte, dass X korrekt konfiguriert
ist, bevor man xdm(1) benutzt, und in jedem Fall bevor xdm(1) beim
Systemstart gestartet wird, das es ansonsten schwierig werden könnte, die
Kontrolle über die Maschine zu erlangen.

<p>
Wenn xdm(1) startet, führt es <tt>/etc/X11/xdm/Xsession</tt> aus;
dies wiederum wird versuchen, eine Datei <tt>.xsession</tt> in dem
Heimatverzeichnis des Benutzers zu finden.
D.&nbsp;h., wünschst du die Änderung deines standardmäßigen Fensterverwalters,
führe ihn (und möglicherweise andere Sachen) in <tt>.xsession</tt> aus.
Wieder gilt, dass alle Programme, die mit X gestartet werden sollen (zum
Beispiel drei xterm(1)s), hier platziert werden müssen, dass alle im
Hintergrund auszuführen sind, ausgenommen des Fensterverwalters, der, wie
zuvor, wenn beendet, die X-Sitzung ebenfalls beendet.
In letzterem Fall wird xdm(1) X erneut starten und einen Anmeldebildschirm
präsentieren.

<h3>11.5.4 - Das Ausprobieren eines neuen Fensterverwalters</h3>
Man kann einen speziellen Fensterverwalter beim Start von X ausführen,
ohne jegliche Standardwerte anzupassen, und zwar so:

<blockquote><pre>
$ startx /usr/local/bin/fluxbox
</pre></blockquote>

Verschiedene Fensterverwalter (einschließlich cwm(1) und fvwm(1)) bieten die
Möglichkeit der Änderung des Fensterverwalters vom Fleck weg, ohne das X oder
eine andere Anwendung neu gestartet werden müssen.
Der neue Fensterverwalter ersetzt den alten; das Beenden des neu gestarteten
Fensterverwalters beendet X, und führt nicht zum Vorherigen zurück.
fvwm(1) erlaubt das Starten eines anderen Fensterverwalters durch einen
Linksklick auf den Hintergrund (»root window«), der Auswahl von »(Re)Start«
und dann des gewünschten Fensterverwalters (es ist allerdings anzumerken, dass
dafür die alternativen Fensterverwalter in der <tt>.fvwmrc</tt>-Datei des
Benutzers angeführt sein müssen [die systemweiten Standards sind in
<tt>/usr/X11R6/lib/X11/fvwm/.fvwmrc</tt>]).
cwm(1) erlaubt das Ausführen eines anderen Fenstermanagers durch Nutzung der
Tastenkombination Ctrl-Alt-w (Steuerungstaste-Meta-w), und Eingabe des
Verwalters, zu dem gewechselt werden soll.

<p>
Sobald du den Fensterverwalter gefunden hast, den du magst, kannst du ihn als
zuletzt auszuführendes Programm in deine Startskripte schreiben, wie oben
beschrieben.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Hardware- und Plattformspezifische Fragen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq11.html,v 1.97 ]<br>
$Translation: faq11.html,v 1.44 2013/11/01 17:42:27 steffen Exp $<br>
-->
$OpenBSD: faq11.html,v 1.42 2013/11/01 18:04:04 ajacoutot Exp $
</small>
</body>
</html>
@


1.42
log
@Sync with Steelix CVS
@
text
@d854 1
a854 1
$OpenBSD$
@


1.41
log
@Sync with Steelix CVS
@
text
@d718 1
a718 1
<a href="../upgrade53.html">vorgeschlagenen Upgradeprozedere</a> nicht erfaßt
d851 2
a852 2
Originally [OpenBSD: faq11.html,v 1.96 ]<br>
$Translation: faq11.html,v 1.43 2013/05/01 16:30:37 steffen Exp $<br>
@


1.40
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name="copyright" content="This document copyright 1998-2012 by OpenBSD.">
d851 2
a852 2
Originally [OpenBSD: faq11.html,v 1.95 ]<br>
$Translation: faq11.html,v 1.42 2013/05/01 13:35:07 steffen Exp $<br>
@


1.39
log
@Sync with Steelix CVS
@
text
@d718 1
a718 1
<a href="../upgrade52.html">vorgeschlagenen Nachrüstprozedere</a> nicht erfaßt
d852 1
a852 1
$Translation: faq11.html,v 1.41 2012/11/05 10:36:32 steffen Exp $<br>
@


1.38
log
@Sync with Steelix CVS
@
text
@d714 1
d718 1
a718 1
<a href="../upgrade50.html">vorgeschlagenen Nachrüstprozedere</a> nicht erfaßt
d851 2
a852 2
Originally [OpenBSD: faq11.html,v 1.94 ]<br>
$Translation: faq11.html,v 1.40 2012/05/01 17:47:05 tobias Exp $<br>
@


1.37
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name="copyright" content="This document copyright 1998-2011 by OpenBSD.">
d850 2
a851 2
Originally [OpenBSD: faq11.html,v 1.93 ]<br>
$Translation: faq11.html,v 1.39 2012/04/14 21:08:00 steffen Exp $<br>
@


1.36
log
@Sync with Steelix CVS
@
text
@d58 1
a58 1
Windowmanager verwenden, die als <a href="faq15.html">Packages</a>
d696 2
a697 2
Eine große Auswahl an Fensterverwaltern ist außerdem in den
»<a href="faq15.html">Packages</a>« verfügbar.
d851 1
a851 1
$Translation: faq11.html,v 1.38 2012/01/31 21:20:31 tobias Exp $<br>
@


1.35
log
@Sync with Steelix CVS
@
text
@d614 1
a614 1
<li>Lies die Manualseite des X-Servers, den du einsetzt. In unserem
d618 1
a618 1
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tdfx&amp;sektion=4">tdfx(4)</a>-Manualseite
d622 1
a622 1
nicht weiter auf die Manualseite angewiesen zu sein, nur weil du bereits
d851 1
a851 1
$Translation: faq11.html,v 1.37 2012/01/21 17:24:03 steffen Exp $<br>
@


1.34
log
@Sync with Steelix CVS
@
text
@d31 4
a34 5
<li><a href="#Intro">11.1 - Einführung in X</a>
<li><a href="#ConfigX">11.2 - Konfiguration von X</a>
<li><a href="#amd64i386">11.3 - Konfiguration von X auf amd64 und
    i386</a>
<li><a href="#StartingX">11.4 - X starten</a>
d851 1
a851 1
$Translation: faq11.html,v 1.36 2012/01/05 18:02:37 steffen Exp $<br>
@


1.33
log
@Sync with Steelix CVS
@
text
@d22 1
a22 1
<a href="faq12.html">[Zum Kapitel 12 - Hardware- und plattformspezifische Fragen]</a>
d841 1
a841 1
<a href= "faq12.html">[Zum Kapitel 12 - Hardware- und plattformspezifische Fragen]</a>
d852 1
a852 1
$Translation: faq11.html,v 1.35 2011/12/22 12:50:21 steffen Exp $<br>
@


1.32
log
@Sync with Steelix CVS
@
text
@d2 1
a2 1
<html><head><title>11 - Das X Window System</title>
d25 1
a25 1
<h1><font color="#e00000">11 - Das »X Window System«</font></h1>
d46 4
a49 4
Das X Window System (manchmal nur »X« oder fälschlicherweise »X Windows«
genannt) ist die Umgebung, die Grafikanwendungen unter OpenBSD und
anderen Unix-basierten Systemen benötigte Funktionen anbietet. X
selbst stellt aber nur wenig bereit: Man muss ebenfalls einen »Window
d851 2
a852 2
Originally [OpenBSD: faq11.html,v 1.92 ]<br>
$Translation: faq11.html,v 1.34 2011/12/20 16:16:18 steffen Exp $<br>
@


1.31
log
@Sync with Steelix CVS
@
text
@d7 2
a8 2
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq">
d10 1
a10 1
<meta name="copyright" content="This document copyright 1998-2006 by OpenBSD.">
d25 1
a25 1
<h1><font color="#e00000">11 - Das X Window System</font></h1>
d36 1
a36 2
<!-- li><a href="#TuningRes">11.9 - Deine Monitorauflösung
    unter X optimieren</a -->
d52 2
a53 2
statt von X selbst. OpenBSD wird mit einer freien Version des
Windowmanagers
d55 4
a58 1
ausgeliefert. Wenn du möchtest, kannst du auch einen der anderen
d95 7
a101 6
Rechner. Um stotternde Bildschirmausgaben zu verhindern, musst du auf
einigen Plattformen sogar auf X zurückgreifen. Solche Plattformen, zu
denen auch <a href="../../de/sparc.html">sparc</a> und
<a href="../../de/sparc64.html">sparc64</a> gehören, wurden für eine
grafische Oberfläche entworfen, sodass die Konsole selbst nur sehr
schlechte Resultate liefert.
d120 1
d123 8
a130 2
Die Konfiguration von X unterscheidet sich deutlich zwischen den
einzelnen Plattformen. In allen Fällen gibt es aber Anleitungen und
d179 3
a181 3
X wird auf amd64 meist erfolgreich automatisch konfiguriert, so
dass in den meisten Fällen keine weitere Konfiguration notwendig ist.
Sollte weitere Konfiguration benötigt werden, rufe
d183 1
a183 1
<a href="#amd64i386example">unten</a> beschrieben auf.
d203 5
a207 11
Aufgrund der unglaublich vielen verfügbaren Grafikkarten, Mäusen,
Tastaturen und anderer Hardware kann die Konfiguration auf einem
i386-System recht abenteuerlich sein. Abenteuerlich genug, um diesem
Thema eine <a href="#amd64i386">separate Sektion</a> zu widmen.

<p>
Zum Glück ist es meist gar nicht so schlimm wie es im ersten Augenblick
scheint - in vielen Fällen »funktionierts einfach«, wenn man »startx«
eingibt. In diesen Fällen wird deine Hardware erfolgreich erkannt und
ausgewertet; X läuft ohne Probleme.

d212 2
a213 2
<h3>11.2.8 - luna88k</h3>
Es stehen keine X-Server bereit, nur X-Clients.
d215 1
a215 1
<h3>11.2.9 - mac68k</h3>
d244 3
a246 3
Fällen funktionieren. Die README-Datei beinhaltet Details über die
Konfiguration des beschleunigten Treibers - verwende erst einmal die
Beispieldatei dort.
d251 2
a252 2
geraten, dir einfach eine USB-Maus eines Drittanbieters zu kaufen -
es sei denn, du verwendest einen Laptop.
d254 17
d279 2
a280 1
Es stehen keine X-Server bereit, nur X-Clients.
d300 3
a302 7
Unter diesen Maschinen gibt es viele Variationen, sodass du wissen
musst, welchen Bustyp dein System verwendet (PCI oder SBus), an
welcher Schnittstelle deine Maus angeschlossen ist (zstty, com oder
USB/PS2) und welche Grafikkarte du hast. Beginne mit der
<tt>xorg.conf</tt>-Datei in der <tt>README</tt>. Modifiziere sie
entsprechend deiner Hardware und deinen Bedürfnissen. <i>Erwarte nicht,
dass die Beispieldatei ohne Anpassung auf deiner Maschine läuft!</i>
d326 5
a330 2
Aufgrund der großen Hardwareauswahl für diese Plattformen ist die
Konfiguration recht »knifflig«.
d333 2
a334 4
X.Org hat erhebliche Verbesserungen vorgenommen, sodass ihre Server
»einfach funktionieren«. In vielen Fällen funktioniert es sogar ohne
<tt>/etc/X11/xorg.conf</tt>-Datei. Aber leider nicht immer - und
manchmal muss man Dinge trotzdem anpassen.
d337 20
a356 26
Es gibt zwei Programme, die für eine pseudo-automatische Erstellung
der Konfigurationsdatei für X.Orgs i386-X-Server genutzt werden können.
Leider gibt es für keines der beiden Programme Garantie, dass eine
einsetzbare xorg.conf-Datei erzeugt wird.


<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Xorg&amp;sektion=1">Xorg(1)</a>
im »X -configure«-Modus gestartet wird alle verfügbaren
Grafiktreibermodule laden, nach Hardware suchen und (basierend auf
der gefundenen Hardware) eine xorg.conf-Datei schreiben. Vielleicht
funktioniert sie nicht, doch selbst dann ist es eine gute Grundlage,
um eigene Änderungen vorzunehmen, statt eine Datei vollkommen selbst
schreiben zu müssen.

<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xorgconfig&amp;sektion=1">xorgconfig</a>
ist ein weiteres Programm, mit dem man interaktiv eine xorg.conf-Datei
erstellen kann - eine vollständig textbasierte Anwendung.

</ul>

Zusätzlich zu den genannten Anwendungen gibt es eine weitere
zeitaufwendige Methode, X zu konfigurieren: Verwende eine Suchmaschine
deiner Wahl und sieh nach, ob jemand anderes bereits dein Problem
gelöst hat. Obwohl dies keine so schlechte Idee ist, wird auf diese
Methode nicht weiter eingegangen.
a358 1

d411 2
a412 2
du dich im gleichen Verzeichnis befindest. Wenn du dies nicht machst,
dann wird
d414 5
a418 5
die Datei nicht finden und ohne weiteren Kommentar die
Standardkonfiguration verwenden, die nicht im Geringsten etwas mit
deiner aktuell bearbeiteten Konfiguration zu tun haben muss.
Dies kann die Fehlersuche später deutlich vereinfachen. Vertrau uns
einfach.
d674 61
d737 2
a738 2
<!-- a name= "TuningRes"></a>
<h2>11.9 - Deine Monitorauflösung unter X optimieren</h2>
d740 3
a742 117
<i>Hinweis: Die meisten Benutzer müssen sich NICHT um die Erstellung einer
ModeLine in modernen Versionen von X sorgen.
TROTZDEM: Manchmal ist es in ungewöhnlichen Situationen notwendig.</i>

<p>
Es ist durchaus mit vielen Multisyncmonitoren möglich, einen X-Server
in einer akzeptablen Auflösung zum Laufen zu kriegen. Mit den
Standardkonfigurationswerkzeugen xorgconfig oder XF86Setup ist es aber
recht schwierig, ein gutes Ergebnis zu erhalten. Einer der
schmerzvolleren Punkte ist es, deinen Monitor zur gewünschten Auflösung
zu bewegen und dann eine vertikale Scanrate von mindestens 72 - 75 Hz zu
bekommen; eine Rate, bei der das Bildschirmgeflacker wesentlich geringer
sichtbar für das menschliche Auge ist. Was passiert aber, wenn du die
vertikale Scanfate sehr niedrig einstellst? So könntest du den
Bildschirm zum Beispiel ohne Flackern auf Video filmen - aber auch dazu
sind die Methoden mit den Standardwerkzeugen von X eher nicht intuitiv.

<p>
Schlussendlich ist es bei den Auflösungen
(800x600, 1024x768, 1152x900,1280x1024), die die meisten Leute heute
mit preiswerten VGA-Monitoren benutzen (zumindest mit neueren Modellen)
bestens möglich, vertikale Wiederholungsraten von 85 Hz und mehr
zu bekommen, um ein wirklich klares und ansehnliches Bild zu erhalten.
Der X-Server hat einen Mechanismus, der dir erlaubt, im Detail
den Grafikmodus zu beschreiben, den du benutzen willst: Dies nennt
sich ModeLine. Eine ModeLine hat vier Sektionen: eine einzelne Nummer
für die Pixelclock, vier Nummern für horizontales Timing, vier Nummern
für vertikales Timing und eine optionale Sektion mit einer Liste der
Flags für weitere Charakteristika wie etwa den Modus (z.&nbsp;B.
Interlace, DoubleScan und weitere&nbsp;... mehr Details gibt es in der
xorg.conf(5)-Manualseite)

<p>
Das Erzeugen einer ModeLine ist eine schwarze Kunst. Glücklicherweise
gibt es mehrere Skripte, die das für dich erledigen können.
Eines davon ist
<a href="http://koala.ilog.fr/cgi-bin/nph-colas-modelines">
Colas XFree86 ModeLine Generator</a>.  Ein weiteres ist
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline
Generator</a>, der bei SourceForge gehostet wird. Es gibt weitere bei
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Bevor du diese ModeLinegeneratoren benutzen kannst, musst du die
vertikalen und horizontalen Syncgrenzen für deinen Monitor herausfinden.
Diese Angaben finden sich oftmals im Handbuch oder auf der Webseite des
Monitorherstellers. Wenn du sie dort nicht finden kannst, suche einfach
im Web nach deinem Modell und Hersteller. Viele Leute waren so
freundlich, Listen mit den entsprechenden Angaben zu erstellen.

<p>
Sagen wir zum Beispiel, du hättest einen Dell-D1226H-Monitor. Du hast
auf Dells Website herausgefunden, dass er einen Bereich von 30 - 95 kHz
horizontal und 50 - 160 Hz vertikal hat. Besuche die
ModeLinegeneratorseite und gib diese Informationen ein. Als nächstes
musst du die minimale vertikale Scanrate eingeben, die du haben
willst. Jede Rate ab 72 Hz und größer sollte im Allgemeinen wenig
flackern. Je mehr, desto besser wird das Bild.

<p>
Mit all diesen Informationen wird das Skript eine ModeLine für jede
mögliche 4x3-Auflösung generieren, die dein Monitor unterstützen
kann. Wenn jemand die Dell-Spezifikationen von oben und eine minimale
vertikale Rate von 75 Hz eingibt, gibt das Skript etwas ähnliches wie
das Folgende aus:

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
Dieser Monitor gibt nun vor, 1600x1200 @@ 75 Hz machen zu können.
Das Skript sagt aber nicht, dass das innerhalb der 75 Hz sei.
Wenn du also exakt 1600x1200 haben willst, geh ein wenig mit deiner
minimalen vertikalen Rate herunter. (Hier z.&nbsp;B. kannst du bis
70 Hz heruntergehen)

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
Hier sehen wir, dass der Monitor tatsächlich 1600x1200 @@ 74 Hz macht,
wenn die Bandbreite (dot clock) auf 200 MHz begrenzt ist. Setze die
Bandbreite gemäß der Grenzen, die vom Monitor definiert werden.

<p>
Nachdem du einmal die ModeLines hast, schreibe sie in deine
/etc/X11/xorg.conf-Datei. Kommentiere die alten ModeLines aus, sodass
du sie noch benutzen kannst, falls die neuen nicht funktionieren.
Als nächstes wähle aus, mit welcher Auflösung du nun arbeiten willst.
Als erstes musst du nun herausfinden, ob X im beschleunigten Modus
läuft oder nicht (das tut es mit den meisten Grafikkarten), sodass
du auch weißt, welche <tt>"Screen"</tt>-Sektion der xorg.conf-Datei du
modifizieren musst. Alternativ kannst du selbstverständlich einfach alle
Screensektionen modifizieren.
d744 92
a835 67
<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
Die erste Auflösung nach dem "Modes"-Stichwort ist die Auflösung,
in der X startet. Mit dem Drücken von STRG-ALT-NUMMERN_BLOCK_MINUS oder
STRG-ALT-NUMMERN_BLOCK_PLUS kannst du zwischen den hier aufgeführten
Auflösungen hin- und herschalten. Gemäß der Angaben oben wird X
versuchen, im 32-Bit-Modus zu starten (wegen der
DefaultColorDepth-Direktive - ohne sie würde X im 8-Bit-Modus
starten). Die erste Auflösung, die versucht wird, ist 1280x1024 (es
wird einfach der Reihenfolge in der Modeszeile gefolgt). Denke daran,
dass »1280x1024« einfach ein Label für die Werte in der ModeLine ist.

<p>
Du solltest wissen, dass das ModeLinegeneratorskript Optionen hat, um
seine Timings für ältere oder kleinere Monitore etwas zu lockern, und
dass es die Möglichkeit hat, ModeLines für spezielle Monitore
anzubieten. Abhängig davon, was für eine Hardware du hast, ist sie
vielleicht nur schwer mit den Standardoptionen zu betreiben. Wenn das
Bild zu groß, zu breit oder zu klein ist oder nicht genügend
horizontal oder vertikal gekippt ist und die Monitorkontrollen zur
Kompensierung nicht ausreichen, kann man mittels xvidtune(1) die
ModeLine besser dem Monitor anpassen.

<p>
In den meisten modernen Monitoren gibt es kein festes Limit der
Bandbreite, daher ist sie auch oftmals nicht in den Spezifikationen
aufgeführt. Aber je mehr du in der Bandbreite nach oben gehst, desto
verschwommener wird das Bild. Du könntest also zum Testen die
Bandbreite deiner Grafikkarte (auch dotclock genannt) eingeben (so
kannst du deinen Monitor nicht beschädigen) und Schritt für Schritt in
Bandbreite heruntergehen, bis du ein schönes, klares Bild hast.

<p>
Wenn dir das unnötig kompliziert erscheint, liegt das daran,
dass es genau das ist. X.Org kümmert sich darum und macht diesen
Prozess bedeutend einfacher, da es viele eingebaute Modi hat und außerdem
in der Lage ist, Angaben aus vielen Plug-and-play-DDC- und
-DDC2-Monitoren auszulesen.

<p>
Du kannst das »Colas XFree86 ModeLine Generator script« hier
herunterladen:
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>.
Du brauchst den Kloneinterpreter und musst ihn kompilieren. Er ist als
<tt>lang/klone</tt> in den Ports. Die Skripte existieren im Verzeichnis
scripts der Klonedistribution. (Der Port installiert sie nach
/usr/local/lib/klone/scripts.)

<p>
Es sind zwei Versionen des Skriptes dabei: die erste ist eine
CGI-Version, die identisch zu der obigen Webseite ist, die zweite ist
eine Nicht-CGI-Version, die deine komplette X.org-Datei nimmt, die
Monitorspezifikationen dekodiert, die du in xorgconfig/XF86Setup
eingegeben hast (Hast du eigentlich die echten Spezifikationen für
deinen Monitor eingegeben, oder die generischen benutzt?) und passt die
existierenden ModeLines an.
d837 1
a837 1
<p -->
d851 2
a852 2
Originally [OpenBSD: faq11.html,v 1.76 ]<br>
$Translation: faq11.html,v 1.33 2008/11/22 11:01:55 paldium Exp $<br>
@


1.30
log
@Sync with Steelix CVS
@
text
@d867 2
a868 2
Originally [OpenBSD: faq11.html,v 1.75 ]<br>
$Translation: faq11.html,v 1.32 2008/07/12 09:39:36 paldium Exp $<br>
@


1.29
log
@Sync with Steelix CVS
@
text
@d212 1
a212 15
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.mac68k"
>/usr/X11R6/README</a> für mac68k.

<p>
Mac68k-Systeme »funktionieren einfach« mit X, sodass keine
Konfiguration benötigt wird.

<p>
Maus: Die standardmäßige Macintosh-Maus hat nur eine Taste. Dies
stellt ein Problem dar, denn X geht von einer Dreitasten-Maus aus.
Einige Mäuse von Drittanbietern haben eine zweite Taste, die auch
mit X funktioniert. Falls dies nicht möglich ist, wirf einen Blick
auf die Xmac68k(1)-Seite für weitere Informationen über die Emulation
von Maustasten.

d867 2
a868 2
Originally [OpenBSD: faq11.html,v 1.74 ]<br>
$Translation: faq11.html,v 1.31 2008/03/04 23:03:08 paldium Exp $<br>
@


1.28
log
@Sync with Steelix CVS
@
text
@d131 1
a131 1
die X-Server eine Voraussetung ist. Dieser Treiber muss aktiviert
d259 1
a259 1
Während die README-Datei detailiert auf die Verwendung der Standardmaus
d411 1
a411 1
Im Übrigen muss die Meldung ernstgenommen werden - verwende den
d514 1
a514 1
fettgedruckt sind:
d882 1
a882 1
$Translation: faq11.html,v 1.30 2008/01/02 15:51:47 paldium Exp $<br>
@


1.27
log
@Sync with Steelix CVS
@
text
@d332 1
a332 1
Es gibt drei Programme, die für eine pseudo-automatische Erstellung
d334 2
a335 2
Leider gibt es für keines dieser Programme Garantie, dass es eine
einsetzbare xorg.conf-Datei erzeugt.
a346 6
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xorgcfg&amp;sektion=1">xorgcfg(1)</a>
hat sowohl einen grafischen als auch einen textbasierten Modus, doch
ist der grafische Modus noch nicht vollständig einsatzfähig. Aus diesem
Grund wird dir zur textbasierten Variante geraten, die mit
»xorgcfg -textmode« aufgerufen wird.

d881 2
a882 2
Originally [OpenBSD: faq11.html,v 1.73 ]<br>
$Translation: faq11.html,v 1.29 2007/12/09 19:18:58 paldium Exp $<br>
@


1.26
log
@Sync with Steelix CVS
@
text
@d567 1
a567 1
[»<a href="http://www.openbsd.org/cgi-bin/cvsweb/xenocara/xc/include/bitmaps/root_weave">root
d888 1
a888 1
$Translation: faq11.html,v 1.28 2007/11/30 16:48:54 paldium Exp $<br>
@


1.25
log
@Sync with Steelix CVS
@
text
@d22 1
a22 1
<a href="faq12.html">[Zum Kapitel 12 - Plattformspezifische Fragen]</a>
d877 1
a877 1
<a href= "faq12.html">[Zum Kapitel 12 - Plattformspezifische Fragen]</a>
d887 2
a888 2
Originally [OpenBSD: faq11.html,v 1.72 ]<br>
$Translation: faq11.html,v 1.27 2007/11/08 21:44:16 paldium Exp $<br>
@


1.24
log
@Sync with steelix translation CVS
@
text
@d50 1
a50 1
selbst stellt aber nur wenig bereit: man muss ebenfalls einen »Window
d90 1
a90 1
X selbst ist ein recht großes Programm, so dass ein schneller Rechner
d97 1
a97 1
grafische Oberfläche entworfen, so dass die Konsole selbst nur sehr
d105 1
a105 1
verwenden, um eine große Anzahl an
d129 1
a129 1
der direkten Zugriff auf den Speicher und die Ein/Ausgabeports
d151 1
a151 1
href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.alpha"
d162 1
a162 1
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.amd64"
d175 2
a176 2
<h3>11.2.3 - cats</h3>
Es steht momentan kein X zur Verfügung.
d179 1
a179 1
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.hp300"
d183 1
a183 2
Es steht momentan kein X-Server für HPPA zur Verfügung, doch gibt
es Unterstützung für X-Clients.
d186 1
a186 1
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.i386"
d190 1
a190 2
Setze <tt>machdep.allowaperture=2</tt> in <tt>/etc/sysctl.conf</tt>
für X.Org-Server oder »1« für XFree86-v3-Server.
d205 2
a206 12
<h4>X.Org gegen XFree86 v3</h4>
Unter OpenBSD/i386 stehen sowohl X.Org- als auch XFree86-v3.3.6-Server
zur Verfügung. Es gibt ältere Grafikkarten, die mit den älteren
XFree86-v3-Servern besser (oder sogar nur unter diesen) laufen, da
ihre Treiber nie auf aktuellere Versionen von X portiert wurden. Man
sollte dennoch auf neuere X.Org-Server zurückgreifen - es sei denn, sie
funktionieren nicht oder liefern schlechte Ergebnisse. Wenn du Probleme
mit einem modernen Rechner oder einer aktuellen Grafikkarte hast,
ziehe einen Einsatz von XFree86-v3-Servern nicht einmal in Erwägung -
die Entwicklung von XFree86 v3 wurde vor vielen Jahren eingestellt.
Solltest du aber ein zehn Jahre altes System haben, so bist du
eventuell darauf angewiesen, einen der XFree86-v3-Server einzusetzen.
d208 1
a208 1
<h3>11.2.7 - luna88k</h3>
d211 2
a212 2
<h3>11.2.8 - mac68k</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.mac68k"
d216 1
a216 1
Mac68k-Systeme »funktionieren einfach« mit X, so dass keine
d220 1
a220 1
Maus: die standardmäßige Macintosh-Maus hat nur eine Taste. Dies
d228 2
a229 2
<h3>11.2.9 - macppc</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.macppc"
d265 1
a265 1
<h3>11.2.10 - mvme68k</h3>
d268 1
a268 1
<h3>11.2.11 - mvme88k</h3>
d271 5
a275 2
<h3>11.2.12 - sparc</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.sparc"
d287 2
a288 2
<h3>11.2.13 - sparc64</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.sparc64"
d292 1
a292 1
Unter diesen Maschinen gibt es viele Variationen, so dass du wissen
d300 2
a301 2
<h3>11.2.14 - vax</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.vax"
d311 2
a312 2
<h3>11.2.15 - zaurus</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/XF4/distrib/notes/README.zaurus"
d325 2
a326 17

<h3>11.3.1 - Konfiguration von XFree86 v3.3.6 <i>(nur i386)</i></h3>
Wenn du eine sehr alte Grafikkarte hast und diese unter X einsetzen
möchtest, musst du eventuell die XFree86-v3-Server konfigurieren und
verwenden. Normalerweise geschieht das mit den Programmen <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=XF86Setup&amp;sektion=1&amp;plat=i386"
>XF86Setup(1)</a> (grafisch) oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xf86config3&amp;sektion=1&amp;plat=i386"
>xf86config3(1)</a> (textbasiert).

<p>
Das ist aber auch schon alles, was wir über XFree86 v3 sagen. Alte
X-Server auf alter Hardware laufen zu lassen ist eine Kunst für sich -
wir würden dir nur ungern den Spaß nehmen, indem wir es dir einfach
machen.

<h3>11.3.2 - Konfiguration von X.Org</h3>
X.Org hat erhebliche Verbesserungen vorgenommen, so dass ihre Server
d360 1
a360 1
zeitaufwendige Methode, X zu konfigurieren: verwende eine Suchmaschine
d368 1
a368 1
<h3>11.3.3 - Unsere Beispielmaschine</h3>
d370 1
a370 1
System mit einem Celeron 400 Mhz und einem AGP-Steckplatz verwenden.
d445 1
a445 1
laufen, so dass dies kein Problem darstellen wird (genau genommen ist
d456 1
a456 1
gesamte Maschine in die Knie zwingt, so dass nur noch aus- und wieder
d567 1
a567 1
[»<a href="http://www.openbsd.org/cgi-bin/cvsweb/XF4/xc/include/bitmaps/root_weave">root
d572 1
a572 1
Nun werden wir die xorg.conf-Datei installieren, so dass wir den
d619 1
a619 1
<h3>11.3.4 - Was ist, wenn es nicht so »einfach« ist?</h3>
d630 1
a630 1
aber von Treiber zu Treiber, so dass du nicht davon ausgehen solltest,
d689 1
a689 1
TROTZDEM: manchmal ist es in ungewöhnlichen Situationen notwendig.</i>
d711 1
a711 1
den Grafikmodus zu beschreiben, den du benutzen willst: dies nennt
d796 1
a796 1
/etc/X11/xorg.conf-Datei. Kommentiere die alten ModeLines aus, so dass
d800 1
a800 1
läuft oder nicht (das tut es mit den meisten Grafikkarten), so dass
d802 1
a802 1
modifizieren musst. Alternativ kannst du natürlich einfach alle
d825 1
a825 1
wird einfach der Reihenfolge in der 'Modes'-Zeile gefolgt). Denke daran,
d887 2
a888 2
Originally [OpenBSD: faq11.html,v 1.67 ]<br>
$Translation: faq11.html,v 1.24 2007/04/25 15:41:11 paldium Exp $<br>
@


1.23
log
@sync with steelix translation CVS
@
text
@d16 1
a16 1
<img alt="[OpenBSD]" src="../../images/smalltitle.gif" border="0" height="30" width="141">    
d569 1
a569 1
                Viewport   0 0 
d634 2
a635 2
*0   1280 x 1024   ( 433mm x 347mm )  *85   75   60  
 1   1280 x 960    ( 433mm x 347mm )   85   60  
d730 1
a730 1
(800x600, 1024x768, 1152x900,1280x1024), die die meisten Leute heute 
d732 1
a732 1
bestens möglich, vertikale Wiederholungsraten von 85 Hz und mehr 
d736 1
a736 1
sich ModeLine. Eine ModeLine hat vier Sektionen: eine einzelne Nummer 
d752 1
a752 1
Bevor du diese ModeLinegeneratoren benutzen kannst, musst du die 
d824 2
a825 2
läuft oder nicht (das tut es mit den meisten Grafikkarten), so dass 
du auch weißt, welche <tt>"Screen"</tt>-Sektion der xorg.conf-Datei du 
d857 2
a858 2
vielleicht nur schwer mit den Standardoptionen zu betreiben. Wenn das 
Bild zu groß, zu breit oder zu klein ist oder nicht genügend 
d912 1
a912 1
$Translation: faq11.html,v 1.23 2006/11/09 18:01:12 paldium Exp $<br>
@


1.22
log
@sync with steelix translation CVS
@
text
@d310 9
a318 1
Es stehen keine X-Server bereit, nur X-Clients.
d911 2
a912 2
Originally [OpenBSD: faq11.html,v 1.66 ]<br>
$Translation: faq11.html,v 1.22 2006/08/28 19:07:02 paldium Exp $<br>
@


1.21
log
@sync with steelix translation CVS
@
text
@d149 1
a149 1
<h3>11.2.1 - Alpha</h3>
d152 1
a152 1
>/usr/X11R6/README</a> für Alpha.
d459 1
a459 1
terminieren - mit samt allen Anwendungen, die momentan laufen.
d903 2
a904 2
Originally [OpenBSD: faq11.html,v 1.64 ]<br>
$Translation: faq11.html,v 1.21 2006/08/24 08:47:20 paldium Exp $<br>
@


1.20
log
@sync with Steelix CVS
@
text
@d2 2
a3 3
<html>
<head>
<title>11 - Leistungstuning</title>
d5 6
a10 6
<link rev= "made" href= "mailto:www@@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2006 by OpenBSD.">
d13 1
a13 1
<body bgcolor= "#ffffff" text= "#000000">
d16 1
a16 1
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
d19 4
a22 4
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Plattformspezifische Fragen]</a>
d25 1
a25 1
<h1><font color="#e00000">11 - Diese Sektion wird überarbeitet</font></h1>
d31 8
a38 2
<li><a href="#XF86"   >11.4 - Deine Monitorauflösung unter X
      tunen</a>
d44 658
a701 2
<a name= "XF86"></a>
<h2>11.4 - Deine Monitorauflösung unter X tunen</h2>
d739 1
a739 1
<a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">
d866 1
a866 1
dass es genau das ist. X.org kümmert sich darum und macht diesen
d889 1
a889 1
<p>
d903 2
a904 2
Originally [OpenBSD: faq11.html,v 1.61 ]<br>
$Translation: faq11.html,v 1.20 2006/04/24 17:44:28 paldium Exp $<br>
@


1.19
log
@sync with steelix translation CVS
@
text
@a4 1
<meta http-equiv="Content-Language" content="de">
d8 1
a8 1
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
d11 1
a11 1
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2006.">
d242 2
a243 2
Originally [OpenBSD: faq11.html,v 1.61 ]
$Translation: faq11.html,v 1.19 2006/04/06 13:52:52 paldium Exp $
@


1.18
log
@sync with Steelix CVS
@
text
@d27 1
a27 1
<h1><font color="#e00000">11 - Leistungstuning</font></h1>
d243 2
a244 2
Originally [OpenBSD: faq11.html,v 1.60 ]
$Translation: faq11.html,v 1.18 2006/02/27 18:06:17 paldium Exp $
@


1.17
log
@sync with steelix translation CVS
@
text
@d12 1
a12 1
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2005.">
a32 4
<li><a href="#Disk"   >11.1 - Festplatten-E/A</a>
<li><a href="#HW"     >11.2 - Hardwareauswahl</a>
<li><a href="#Async"  >11.3 - Wieso benutzen wir keine »async
      mounts«?</a>
a38 338

<p>
<a name= "Disk"></a>
<h2>11.1 - Festplatten-E/A</h2>

<p>
Festplatten-E/A-Geschwindigkeit ist ein wichtiger Faktor in der 
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multiuserumgebung beheimatet
(Benutzer aller Arten - von solchen, die sich einloggen, bis zu denen,
die Serverdienste nutzen). Datenspeicher brauchen ständige
Aufmerksamkeit; insbesondere, wenn deine Partition überläuft
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erhöhen
und Fehlertoleranz zu bieten.

<p>
Inhaltsverzeichnis
<ul>
<li><a href="#ccd">CCD</a> - Concatenated Disk Driver.
<li><a href="#raid">RAID</a>
<li><a href="#softu">Softupdates</a>
<li><a href="#maxvnodes">Größe des namei()-Caches</a>
</ul>

<p>
<a name="ccd"></a>
<h3>11.1.1 - CCD</h3>

<blockquote>
Die erste Option ist die Benutzung des 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
- des Concatenated Disk Driver.
Dieser erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu
verwandeln (und damit kannst dafür sorgen, dass mehrere Festplatten wie
eine einzige aussehen). Dieses Konzept ist ähnlich wie das von LVM
(logical volume management), das in mehreren kommerziellen Unix-Arten
zu finden ist. 

<p>
Wenn du GENERIC benutzt, ist ccd bereits eingeschaltet (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  Wenn du einen veränderten
Kernel benutzt, musst du ihn vielleicht wieder in deine
Kernelkonfiguration einfügen. Wie auch immer, auf jeden Fall muss sich
eine Zeile wie die folgende in deiner Konfigurationsdatei befinden:

<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
Das obige Beispiel gibt dir bis zu 4 ccd-Devices (virtuelle Platten).
Jetzt musst du festlegen, welche Partitionen auf deinen realen
Festplatten du in den ccd einbinden willst. Benutze disklabel, um diese
Partitionen als ccd-Typ zu markieren. Auf einigen Architekturen
erlaubt dir disklabel das vielleicht nicht. In diesem Fall markiere sie
einfach als ffs. 

<p>
Wenn du ccd dazu benutzt, um mittels striping Leistung zu gewinnen,
solltest du wissen, dass du keine optimale Leistung bekommst, bis du das
gleiche Festplattenmodell mit den gleichen Disklabeleinstellungen benutzt.

<p>
Editiere /etc/ccd.conf, bis sie etwa so aussieht:
(Mehr Informationen über das Konfigurieren von ccd findest du unter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
Um die Änderungen wirksam zu machen, führe das hier aus:

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Solange /etc/ccd.conf existiert, wird sich ccd automatisch beim Booten 
konfigurieren.
Jetzt hast du eine neue Festplatte (ccd0): eine Kombination von
/dev/sd2e und /dev/sd3e. Benutze disklabel einfach wie gewöhnlich, um
die Partition oder Partitionen zu erzeugen, die du benutzen willst.
Nutze erneut die Partition c nicht, um darauf irgendetwas zu speichern.
Stelle sicher, dass deine benutzten Partitionen mindestens einen
Zylinder vom Anfang der Disk weg ist.
</blockquote>

<p>
<a name="raid"></a>
<h3>11.1.2 - RAID</h3>

<blockquote>
Eine weitere Lösung ist
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
wofür du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
nutzen musst, um deine RAID-Geräte zu kontrollieren. OpenBSDs RAID
basiert auf Greg Osters
<a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD-Port</a>
der
CMU-<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a>-Software.
OpenBSD hat Unterstützung für die RAID-Level
0, 1, 4 und 5.<p> Für raid muss - wie auch bei ccd - Unterstützung
im KERNEL sein.
Diese Treiberunterstützung für RAID ist im Gegensatz zu ccd allerdings
nicht im GENERIC-Kernel enthalten; sie muss also extra in deinen Kernel
einkompiliert werden (RAID-Unterstützung vergrößert deinen
i386-Kernel um gute 500k).

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
Ein RAID aufzusetzen ist mit einigen Betriebssystemen verwirrend und 
schmerzhaft, um es sanft auszudrücken. Nicht jedoch mit RAIDframe.
Lies die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>- und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>-Manualseiten
für die kompletten Details. Es gibt dafür viele Optionen und mögliche
Konfigurationen, und ein detaillierter Überblick sprengt den Rahmen
dieses Dokumentes.
</blockquote>

<p>
<a name="softu"></a>
<h3>11.1.3 - Softupdates</h3>

<blockquote>
Ein weiteres Werkzeug zum Erhöhen der Systemgeschwindigkeit sind
Softupdates. Eine der langsamsten Operationen im traditionellen
BSD-Dateisystem ist das Aktualisieren der Metainfos (was unter anderem
immer dann geschieht, wenn du Dateien oder Verzeichnisse erzeugst oder
löschst). Softupdates versucht die Metainfo im RAM zu aktualisieren,
statt jedes einzelne Metainfoupdate auf die Platte zu schreiben. Ein
weiterer Nebeneffekt ist, dass die Metainfos auf der Festplatte immer
auf dem aktuellen Stand sind. Das heißt, ein Systemabsturz sollte kein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
beim folgende Booten benötigen, sondern eine einfache Hintergrundversion
von fsck, die Änderungen an den Metainfos im RAM macht (a la
Softupdates). Das heißt, dass Reboots viel schneller sind, da 
nicht mehr auf fsck gewartet werden muss! (OpenBSD hat diese
Funktionalität leider noch nicht.) Mehr über Softupdates findest du im 
<a href="faq14.html#SoftUpdates">Softupdates-FAQ</a>-Eintrag.
</blockquote>

<p>
<a name="maxvnodes"></a>
<h3>11.1.4 - Größe des namei()-Caches</h3>

<dl>
<dd>
Hinweis: Bisher hat die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>-Manualseite
empfohlen, die Kerneloption <tt>NVNODE=integer</tt> zu setzen. Das wird
nicht mehr empfohlen; du solltest stattdessen das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
benutzen. 
<p>
Die name-to-inode-Übersetzung (a.&nbps;k.&nbsp;a. <!-- need to write
the manual page first... <a href="">namei(3)</a> --> namei()-Cache)
kontrolliert die Geschwindigkeit der
pathname-to-<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>-Übersetzung.
Ein sinnvoller Weg zum Herausfinden der passenden Größe des Caches
wäre eine große Anzahl namei()-Cachemisses, die man mit einem 
Werkzeug wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a> 
messen könnte (was eine Untersuchung des momentanen berechneten Wertes
mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> voraussetzt, das diesen Parameter <tt>kern.maxvnodes</tt>
nennt) und diesen Wert zu vergrößern, bis sich entweder die Hitrate des
namei()-Caches verbessert oder es bewiesen ist, dass das System nicht
wesentlich von einer Erhöhung der Größe des namei()-Caches profitiert.
Nachdem der Wert festgestellt wurde, kannst du ihn für die nächsten 
Systemstarts mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>
setzen.
</dd>
</dl>


<p>
<a name= "HW"></a>
<h2>11.2 - Hardwareauswahl</h2>
<!-- XXXchanges - check every OpenBSD release -->

<p>
<i>(Hinweis - diese Sektion dreht sich fast ausschließlich um die i386-
oder PC-Architektur. Andere Architekturen geben dir sozusagen keine so
große Auswahl!)</i>

<p>
Die Leistung deiner Anwendungen hängt stark von deinem Betriebssystem
und den Fähigkeiten ab, die es bereitstellt. Das mag ein Grund dafür
sein, dass du OpenBSD benutzt. Die Leistung deiner Anwendungen hängt
aber auch stark von deiner Hardware ab. Für viele Leute ist das
Preisleistungsverhältnis eines brandneuen PCs mit einem
Intel-Pentium-IV oder AMD-Athlon-Prozessors viel besser als das
Preisleistungsverhältnis einer Sun UltraSPARC 60!  Der Preis von OpenBSD
ist natürlich unschlagbar.

<p>
Wenn du einen neuen PC kaufen willst (ob nun in einem Komplettangebot,
oder Einzelteil für Einzelteil), solltest du sicherstellen, dass du 
unbedingt nur zuverlässige Teile bekommst. In der Welt der PCs ist 
das leichter gesagt als getan. 
<b>Schlechte oder sonstig unzuverlässige oder unpassende Teile
können dazu führen, dass OpenBSD schlecht läuft und oft
abstürzt</b>.  Der beste Rat, den wir geben können, ist, vorsichtig 
zu sein und Marken und Teile zu kaufen, die von jemandem empfohlen
werden, dem du trauen kannst. Wenn du nur auf den Preis eines PCs
achtest, wirst du wahrscheinlich auch an Qualität verlieren!

<p>
Es gibt ein paar Dinge, die dir helfen können, die maximale 
Leistung aus deiner Hardware zu holen:

<ul>
<li><b>Benutze mehrere Festplatten.</b>
Statt nur eine große Platte zu kaufen, kaufe mehrere kleine Platten.
Wenn das auch mehr kostet, wird es doch die Last auf mehrere Spindeln
verteilen und somit die Zeitspanne verringern, die ein Datenzugriff
benötigt.  Außerdem kannst du mit mehreren Platten auch mehr
Zuverlässigkeit und schnelleren Datenzugriff mit RAID bekommen.
<p>
<li><b>Benutze SCSI, wenn du hohe Festplatten-E/A-Geschwindigkeit
brauchst.</b> IDE-Festplatten laufen normalerweise mit 5400 RPM bis 7200
RPM. Selbst bei hochwertigen IDE-Platten ist es manchmal zu viel
verlangt, wenn man mehr als 15 bis 20 MB pro Sekunde an Datendurchsatz
von einer einzelnen Platte verlangt. Mit hochwertigen SCSI-Platten (10k
RPM oder 15k RPM) kannst du mehr Durchsatz bekommen. Im Gegensatz dazu
ist es eine Verschwendung von Geld, wenn du mittlere oder langsame
SCSI-Platten benutzt, da dann IDE die gleiche oder bessere Leistung
bringt.
<p>Wenn du einen Server und mehr als ein Laufwerk brauchst, solltest du
über SCSI nachdenken. IDE beschränkt dich auf zwei Platten pro
Controller. Gleichzeitige Zugriffe auf diese Platten haben vermutlich
einen negativen Effekt auf die E/A-Leistung dieser Platten. Mit Wide
SCSI kannst du 15 Platten pro Controller anschließen und es hat bessere
Unterstützung für gleichzeitigen Zugriff als IDE.
<p>
<li><b>Benutze SDRAM statt DRAM.</b>
Diese Option trifft fast nur auf PCs zu. Bei den meisten anderen
Architekturen hast du keinerlei Auswahl, welche Art von RAM du benutzen
kannst. Bei den meisten PCs schon. Mit SDRAM bekommst du eine bessere
Leistung als mit DRAMs (SIMMs). Wenn dein System RDRAM unterstützt oder
vielleicht DDR oder eine andere neue Art von RAM bist du sogar noch
besser dran.
<p>
<li><b>Benutze ECC- oder Parity-RAM.</b>
Parity fügt einen Mechanismus hinzu, der prüft, ob die Daten im RAM noch
in Ordnung sind. ECC baut das noch dahingehend aus, dass es versucht,
Fehler bei einzelnen Bits automatisch zu korrigieren. Diese Option gibt
es wieder fast nur bei PCs. Die meisten anderen Architekturen brauchen
einfach ECC- oder Parity-RAM. Einige Nicht-PC-Computer booten nicht
einmal mit Nicht-Parity-RAM. Wenn du kein ECC-/Parity-RAM benutzt, kann
es zu Datenkorrumpierung und anderen Abnormitäten kommen. Einige
Herstelle von billigem PC-RAM stellen nicht einmal eine ECC-Variante
her! Das hilft dir, sie zu vermeiden! PC-Hersteller verkaufen oftmals
mehrere Produktlinien - in Server und Workstations aufgeteilt. Die
Server haben Parity (und jetzt ECC) seit vielen Jahren beinhaltet.
Unixworkstationhersteller benutzen Parity (und nun ECC) seit vielen
Jahren in all ihren Produktlinien.
<p>
<li><b>Vermeide ISA-Karten.</b>
Während die meisten Leute ISA-Karten schon deshalb meiden, weil
sie veraltet und zudem noch schwer zu konfigurieren sind, gibt es aber
trotzdem noch eine ganze Menge davon. Wenn du den ISA-Bus für deine
Festplatte oder Netzwerkkarte benutzt (oder noch schlimmer, für beides)
denke daran, dass der ISA-Bus vermutlich ein Flaschenhals ist. Wenn du
Geschwindigkeit brauchst, benutze PCI. Natürlich gibt es noch 
zahllose ISA-Karten, die einfach gut funktionieren. Unglücklicherweise 
sind das meist Soundkarten oder solche für serielle Ports.
<p>
<li><b>Vermeide billige PCI-Netzwerkkarten.</b>
OpenBSD unterstützt eine ganze Menge billige PCI-Netzwerkkarten.
Diese Karten funktionieren prima in einfachen Heimsystemen, oder 
solchen mit wenig oder moderater Netzwerklast im Geschäfts-
oder Forschungsbereich. Wenn du aber hohen Durchsatz und
wenig Belastung deines Servers benötigst, bist du mit einer
Qualitätsnetzwerkkarte besser dran. Unglücklicherweise sind einige
Serien teurer Markenhersteller nicht besser als die billigen Karten.
Gigabitkarten sind wegen dem besseren Buffering meist leistungsfähiger
als 10-Mbps-/100-Mbps-Adapter, selbst wenn sie mit langsameren
Netzwerkgeschwindigkeiten genutzt werden.
</ul>


<p>
<a name= "Async"></a>
<h2>11.3 - Wieso benutzen wir keine »async mounts«?</h2>

<p>
Frage: »Ich gebe einfach ein ,mount -u -o async /' ein, was ein Paket,
welches ich brauche, benutzbar macht (das darauf besteht alle paar
Momente ein paar hundert Dateien zu ändern).

Wieso wird ,async mounting' abgelehnt und ist nicht standardmäßig
aktiviert (wie in manchen anderen Unixen)? Wäre das nicht ein
einfacherer und daher auch ein sichererer Weg, die Leistung mancher
Applikation zu erhöhen?«

<p>
Antwort: »Asynchrone Mounts sind tatsächlich schneller als synchrone 
Mounts - aber auch unsicherer. Was passiert im Falle eines
Stromausfalls - oder bei einem Hardwareproblem? Die Suche nach
Geschwindigkeit darf nicht auf Kosten der Stabilität und Zuverlässigkeit
des Systems gehen. Siehe auch die Manualseite von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>.«

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
Auf der anderen Seite kannst du mehr Geschwindigkeit erhalten, wenn du
sowieso nur mit temporären Daten umgehst, die du nach einem Crash wieder
rekonstruieren kannst, indem du eine separate Partition nur für 
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur,
wenn</i> dir der Verlust aller Daten in der Partition nach irgendeinem
Problem nichts ausmacht. Daher sind
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>-Partitionen
asynchron gemountet, weil sie ja nach jedem Neustart sowieso gelöscht
und neu erzeugt werden.


d243 2
a244 2
Originally [OpenBSD: faq11.html,v 1.57 ]
$Translation: faq11.html,v 1.17 2006/01/13 21:58:46 paldium Exp $
@


1.16
log
@sync with Steelix CVS
@
text
@d275 1
a275 1
RPM. Selbst bei hochwertigen IDE-Platten ist es manchmal zuviel
d586 1
a586 1
$Translation: faq11.html,v 1.16 2005/10/29 10:44:51 paldium Exp $
@


1.15
log
@sync with Steelix CVS
@
text
@d22 1
a22 1
<a href= "index.html">[FAQ Index]</a>
d24 1
a24 1
<a href= "faq12.html">[Zum Kapitel 12 - Plattform-spezifische Fragen]</a>
d27 1
a27 1
<h1><font color="#e00000">11 - Leistungs Tuning</font></h1>
d33 6
a38 5
<li><a href="#Disk"   >11.1 - Festplatten E/A</a>
<li><a href="#HW"     >11.2 - Hardware Auswahl</a>
<li><a href="#Async"  >11.3 - Wieso benutzen wir keine ,async mounts'?</a>
<li><a href="#XF86"   >11.4 - Deine Monitor-Auflösung unter X
tunen</a>
d46 1
a46 1
<h2>11.1 - Festplatten E/A</h2>
d49 1
a49 1
Festplatten E/A Geschwindigkeit ist ein wichtiger Faktor in der 
d51 4
a54 4
wenn dein Computer eine Multi-User-Umgebung beheimatet
(User aller Arten, von solchen, die sich einloggen, bis zu denen
die Serverdienste nutzen). Datenspeicher brauchen ständige 
Aufmerksamkeit. Insbesondere, wenn deine Partition überläuft
d64 2
a65 2
<li><a href="#softu">Soft Updates</a>
<li><a href="#maxvnodes">Größe des namei() Cache</a>
d74 5
a78 5
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>, 
des Concatenated Disk Driver.
Dieser erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu verwandeln 
(und damit kannst dafür sorgen, dass mehrere Festplatten wie eine 
einzige aussehen). Dieses Konzept ist ähnlich wie das von LVM
d85 3
a87 3
Kernel benutzt, musst du ihn vielleicht wieder in deine Kernel-Konfiguration
einfügen. Wie auch immer, auf jeden Fall muss sich eine
Zeile wie die folgende in deiner Konfigurationsdatei befinden:
d94 4
a97 4
Das obige Beispiel gibt dir bis zu 4 ccd Devices (virtuelle Platten).
Jetzt musst du festlegen, welche Partitionen auf deinen realen Festplatten
du in den ccd einbinden willst. Benutze disklabel, um diese
Partitionen als ,ccd'-Typ zu markieren. Auf einigen Architekturen
d99 1
a99 1
einfach als ,ffs'. 
d102 1
a102 1
Wenn du ccd dazu benutzt, um mittels striping Performance zu gewinnen,
d104 1
a104 1
gleiche Festplatten-Modell mit den gleichen disklabel Einstellungen benutzt.
d128 6
a133 7
Jetzt hast du eine neue Festplatte, ccd0, eine Kombination von /dev/sd2e
und /dev/sd3e.
Benutze disklabel einfach wie gewöhnlich, um die Partition oder 
Partitionen zu erzeugen, die du benutzen willst. Nutze erneut die ,c'
Partition nicht, um darauf irgendetwas zu speichern. Stelle sicher, dass 
deine benutzten Partitionen mindestens einen Zylinder vom Anfang
der Disk weg ist.
d141 2
a142 1
Eine weitere Lösung ist <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
d144 5
a148 4
nutzen musst, um deine RAID Geräte zu kontrollieren. OpenBSDs RAID basiert auf 
Greg Osters <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD Port</a>
der CMU
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> Software.
d150 1
a150 1
0, 1, 4 und 5.<p> Für raid muss, wie auch bei ccd, Unterstützung
d152 2
a153 2
Diese Treiber-Unterstützung für RAID ist im Gegensatz zu ccd allerdings nicht 
im GENERIC-Kernel enthalten, also muss sie extra in deinen Kernel
d155 1
a155 1
i386 Kernel um gute 500k).
d165 5
a169 5
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
Manual Seiten für die kompletten Details. Es gibt dafür viele 
Optionen und mögliche Konfigurationen, und ein detaillierter
Überblick sprengt den Rahmen dieses Dokumentes.
d174 1
a174 1
<h3>11.1.3 - Soft Updates</h3>
d177 8
a184 8
Ein weiteres Tool zum Erhöhen der Systemgeschwindigkeit sind Soft Updates.
Eine der langsamsten Operationen im traditionellen BSD Dateisystem ist 
das Updaten der Metainfos (was unter anderem immer dann geschieht, wenn 
du Dateien oder Verzeichnisse erzeugst oder löschst). Soft Updates
versucht die Metainfo im RAM upzudaten, statt jedes einzelne Metainfo-Update 
auf die Platte zu schreiben. Ein weiterer Nebeneffekt ist, dass die 
Metainfos auf der Festplatte immer auf dem aktuellen Stand sind. Das
heißt,  ein Systemcrash sollte kein
d186 6
a191 6
beim folgende Booten benötigen, sondern eine einfache 
Hintergrund-Version von fsck, die Änderungen an den Metainfos im RAM macht
(a la softupdates). Das heißt, dass Reboots viel schneller sind, da 
nicht mehr auf fsck gewartet werden muss! (OpenBSD hat dieses Feature 
leider noch nicht.) Mehr über Soft Updates findest du im 
<a href="faq14.html#SoftUpdates">Soft Updates FAQ</a> Eintrag.
d196 1
a196 1
<h3>11.1.4 - Größe des namei() Cache</h3>
d200 4
a203 4
Hinweis: Vorher hat die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>
Manual Seite empfohlen, die <tt>NVNODE=integer</tt> Kernel Option zu setzen.
Das wird nicht mehr empfohlen; du solltest stattdessen das
d205 1
a205 1
Kommando benutzen. 
d207 7
a213 8
Die name-to-inode Übersetzung (a.k.a., <!-- need to write the manual
page first... <a href="">namei(3)</a> --> namei() Cache) kontrolliert die
Geschwindigkeit der pathname zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>
Übersetzung.
Ein sinnvoller Weg zum Herausfinden der passenden Größe des Cache 
wäre, eine große Anzahl von namei() ,cache misses', die man mit einem 
Tool wie   
d215 7
a221 8
messen könnte, vorausgesetzt, eine Untersuchung des momentanen 
berechneten Wertes mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>,
(das diesen Parameter "<tt>kern.maxvnodes</tt>" nennt) und diesen Wert zu 
vergrößern, bis sich entweder die namei() Cache ,hit rate'
verbessert, oder es bewiesen ist, dass das System nicht wesentlich von einer
Erhöhung der Größe des namei() Cache profitiert. Nachdem der 
Wert festgestellt wurde, kannst du ihn für die nächsten 
d231 1
a231 1
<h2>11.2 - Hardware Auswahl</h2>
d235 2
a236 2
<i>(Hinweis - diese Sektion dreht sich fast ausschließlich um die i386
oder PC Architektur. Andere Architekturen geben dir sozusagen keine so
d240 8
a247 9
Die Leistung deiner Anwendungen hängt stark von deinem 
Betriebssystem und den Fähigkeiten ab, die es bereitstellt. Das mag
ein Grund dafür sein, dass du OpenBSD benutzt.
Die Leistung deiner Anwendungen hängt aber auch stark von deiner 
Hardware ab.
Für viele Leute ist das Preis-Leistungs-Verhältnis eines 
brandneuen PCs mit einem Intel Pentium IV oder AMD Athlon Prozessors viel
besser als das Preis-Leistungs-Verhältnis einer Sun UltraSPARC 60!
Der Preis von OpenBSD ist natürlich unschlagbar.
d250 2
a251 2
Wenn du einen neuen PC kaufen willst, ob nun in einem Komplettangebot,
oder Einzelteil für Einzelteil, solltest du sicherstellen, dass du 
d254 1
a254 1
<b>Schlechte oder sonstige unzuverlässige oder unpassende Teile
d257 3
a259 3
zu sein und Marken und Teile zu kaufen, die von jemandem empfohlen werden,
dem du trauen kannst. Wenn du nur auf den Preis eines PCs achtest, wirst 
du wahrscheinlich auch an Qualität verlieren!
d267 14
a280 14
Statt nur eine große Platte zu kaufen, kaufe mehrere kleine Platten. Wenn 
das auch mehr kostet, wird es doch die Last auf mehrere Spindeln verteilen
und somit die Zeitspanne verringern, die ein Datenzugriff benötigt.
Außerdem kannst du mit mehreren Platten auch mehr Zuverlässigkeit
und schnelleren Datenzugriff mit RAID bekommen.
<p>
<li><b>Benutze SCSI, wenn du hohe Festplatten-EA-Geschwindigkeit brauchst.</b>
IDE Festplatten laufen normalerweise mit 5400 RPM bis 7200 RPM.  
Selbst bei hochwertigen IDE Platten ist es manchmal zu viel verlangt, wenn
man mehr als 15 bis 20 MB pro Sekunde an Datendurchsatz von einer einzelnen
Platte verlangt. Mit hochwertigen SCSI-Platten (10k RPM oder 15k RPM)
kannst du mehr Durchsatz bekommen. 
Im Gegensatz dazu ist es eine Verschwendung von Geld, wenn du mittlere oder
langsame SCSI-Platten benutzt, da dann IDE die gleiche oder bessere Leistung
d282 6
a287 7
<p>Wenn du einen Server und mehr als ein Laufwerk brauchst, 
solltest du über SCSI nachdenken. IDE beschränkt dich auf zwei
Platten pro Controller. Gleichzeitige Zugriffe auf diese Platten haben
vermutlich einen negativen Effekt auf die E/A Leistung dieser 
Platten. Mit Wide SCSI kannst du 15 Platten pro Controller anschließen
und es hat bessere Unterstützung für gleichzeitigen Zugriff 
als IDE.
d290 21
a310 20
Diese Option trifft fast nur auf PCs zu. Bei den meisten anderen Architekturen
hast du keinerlei Auswahl welche Art von RAM du benutzen kannst. Bei den
meisten PCs schon. Mit SDRAM bekommst du eine bessere Leistung als mit
DRAMs (SIMMs). Wenn dein System RDRAM unterstützt oder vielleicht
DDR oder eine andere neue Art von RAM bist du sogar noch besser dran.
<p>
<li><b>Benutze ECC oder Parity RAM.</b>
Parity fügt einen Mechanismus hinzu, der prüft, ob die Daten im 
RAM noch in Ordnung sind. ECC baut das noch dahingehend aus, dass es 
versucht, Fehler bei einzelnen Bits automatisch zu korrigieren. 
Diese Option gibt es wieder fast nur bei PCs. Die meisten anderen 
Architekturen brauchen einfach ECC oder Parity RAM. Einige nicht-PC-Computer
booten nicht einmal mit nicht-Parity-RAM. 
Wenn du kein ECC/Parity RAM benutzt, kann es zu Daten-Korrumpierung und
anderen Abnormitäten kommen. Einige Herstelle von "billigem  PC RAM"
stellen nicht einmal eine ECC-Variante her! Das hilft dir, sie zu vermeiden!
PC Hersteller verkaufen oftmals mehrere Produktlinien, in "Server" und
"Workstations" aufgeteilt. Die Server haben Parity (und jetzt ECC) seit 
vielen Jahren beinhaltet. Unix-Workstation-Hersteller benutzen Parity 
(und nun ECC) seit vielen Jahren in all ihren Produktlinien.
d315 1
a315 1
trotzdem noch eine ganze Menge davon. Wenn du den ISA Bus für deine
d317 1
a317 1
denke daran, dass der ISA Bus vermutlich ein Flaschenhals ist. Wenn du
d322 11
a332 11
<li><b>Vermeide billige PCI Netzwerkkarten.</b>
OpenBSD unterstützt eine ganze Menge von billigen PCI Netzwerkkarten.
Diese Karten funktionieren prima in einfachen Heim-Systemen, oder 
solchen mit wenig oder moderater Netzwerk-Last im Geschäfts-
oder Forschungs-Bereich. Aber, wenn du hohen Durchsatz brauchst, und
wenig Belastung deines Servers, bist du mit einer 
Qualitäts-Netzwerkkarte besser dran. Unglücklicherweise
sind einige Serien von teuren Marken-Herstellern nicht besser als die billigen
Karten. Gigabit Karten sind wegen dem besseren Buffering meist
leistungsfähiger als 10Mbps/100Mbps Adapter, selbst wenn sie mit
langsameren Netzwerkgeschwindigkeiten genutzt werden.
d338 1
a338 1
<h2>11.3 - Wieso benutzen wir keine ,async mounts'?</h2>
d341 3
a343 3
Frage: "Ich gebe einfach ein "mount -u -o async /" ein, was ein Paket, was ich 
brauche, benutzbar macht. 
(das darauf besteht alle paar Momente ein paar hundert Dateien zu ändern.)
d345 4
a348 4
Wieso wird ,async mounting' abgelehnt und ist nicht
standardmäßig aktiviert (wie in manchen anderen Unixen)?
Wäre das nicht ein einfacherer, und daher auch ein sichererer Weg,
die Leistung mancher Applikation zu erhöhen?"
d351 6
a356 6
Antwort: "Asynchrone mounts sind tatsächlich schneller als synchrone 
mounts, aber sie sind unsicherer. Was passiert im Falle eine Stromausfalls?
Oder bei einem Hardwareproblem? Die Suche nach Geschwindigkeit darf nicht
auf Kosten von Stabilität und Zuverlässigkeit des Systems gehen.
Siehe auch die Manualseite von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>."
d370 3
a372 3
Auf der anderen Seite, wenn du sowieso nur mit temporären Daten 
umgehst, die du nach einem Crash wieder rekonstruieren kannst, kannst du
mehr Geschwindigkeit erhalten, indem du eine separate Partition nur für 
d376 3
a378 3
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
Partitionen asynchron gemountet, weil sie ja nach jedem Reboot sowieso
gelöscht und neu erzeugt werden.
d383 1
a383 1
<h2>11.4 - Deine Monitor-Auflösung unter X tunen</h2>
d387 1
a387 1
TROTZDEM, manchmal ist es in ungewöhnlichen Situationen notwendig.</i>
d390 11
a400 12
Es ist durchaus mit vielen multi-Sync-Monitoren möglich, einen
X-Server in einer akzeptablen Auflösung zum Laufen zu kriegen.
Mit den Standard-Konfigurations-Werkzeugen xorgconfig oder XF86Setup ist
es aber recht schwierig, ein gutes Ergebnis zu erhalten. Einer der 
schmerzvolleren Punkte ist es, deinen Monitor zur gewünschten
Auflösung zu bewegen, und dann eine vertikale Scan-Rate von
mindestens 72-75 Hz zu bekommen, eine Rate, bei der das Bildschirmgeflacker
wesentlich geringer sichtbar für menschliche Augen ist.
Was passiert aber, wenn du die vertikale Scan-Rate sehr niedrig einstellst?
So könntest du den Bildschirm zum Beispiel ohne Flackern auf Video
filmen, aber auch dazu sind die Methoden mit den Standard-Werkzeugen von
X eher nicht intuitiv.
d403 1
a403 1
Schlussendlich ist es bei den Auflösungen, 
d409 7
a415 7
den Grafik-Modus zu beschreiben, den du benutzen willst, dies nennt
sich ModeLine. Eine ModeLine hat vier Sektionen, eine einzelne Nummer 
für die Pixel Clock, vier Nummern für horizontales Timing,
vier Nummern für vertikales Timing und eine optionale Sektion
mit einer Liste von Flags für weitere Charakteristika wie etwa 
den Modus (z.B. Interlace, DoubleScan und weitere... mehr Details
gibt es in der xorg.conf(5)-Manualseite)
d420 2
a421 1
Eines davon ist der <a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">
d423 2
a424 2
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline Generator</a>,
der bei SourceForge gehostet wird, und es gibt weitere bei
d426 2
a427 2
Bevor du diese ModeLine-Generatoren benutzen kannst, musst du die 
vertikalen und horizontalen sync Grenzen für deinen Monitor herausfinden.
d429 3
a431 3
Monitor-Herstellers. Wenn du sie dort nicht finden kannst, suche einfach im
Web nach deinem Modell und Hersteller, viele Leute waren so freundlich, Listen
mit den entsprechenden Angaben zu erstellen.
d434 7
a440 7
Sagen wir zum Beispiel, du hättest einen Dell D1226H Monitor.  Du hast auf
Dells Website herausgefunden, dass er einen Bereich von 30-95 kHz horizontal 
und 50-160 Hz vertikal hat. Besuche die ModeLine Generator Page,
und gib diese Informationen ein. Als nächstes musst du die minimale
vertical scan rate eingeben, die du haben willst. Jede Rate ab 72 Hz und 
größer sollte im Allgemeinen wenig flackern. Je mehr, desto besser 
wird das Bild.
d444 4
a447 4
mögliche 4x3 Auflösung generieren, die dein Monitor unterstützen
kann. Wenn jemand die Dell Spezifikationen von oben und eine minimale vertikale
Rate von 75 Hz eingibt, gibt das Skript etwas ähnliches wie das folgende
aus:
d470 2
a471 2
Dieser Monitor gibt nun vor, 1600x1200 @@ 75 Hz machen zu können, 
aber das Skript sagt nicht, dass das innerhalb der  75 Hz sei.
d473 1
a473 1
minimalen vertikalen Rate herunter. (Hier z.B. kannst du bis
d489 2
a490 2
wenn die Bandbreite (dot clock) auf 200MHz begrenzt ist. Setze die Bandbreite
gemäß der Grenzen, die vom Monitor definiert werden.
d494 8
a501 9
/etc/X11/xorg.conf-Datei. 
Kommentiere die alten ModeLines aus, so dass du sie noch benutzen kannst, 
falls die neuen nicht funktionieren.
Als nächstes wähle aus, mit welcher Auflösung du nun 
arbeiten willst. Als erstes musst du nun herausfinden, ob X im "accelerated
mode" läuft, oder nicht (das tut es mit den meisten Grafik-Karten), so dass 
du auch weißt, welche <tt>"Screen"</tt> Sektion der xorg.conf-Datei du 
modifizieren musst. Alternativ kannst du natürlich einfach alle Screen-Sektionen
modifizieren.
d516 9
a524 9
Die erste Auflösung nach dem "Modes" Stichwort ist die Auflösung,
in der X startet. Mit dem Drücken von STRG-ALT-NUMMERN_BLOCK MINUS oder
STRG-ALT-NUMMERN_BLOCK PLUS kannst du zwischen den hier aufgeführten
Auflösungen hin- und herschalten. Gemäß der Angaben oben wird X versuchen im
32-Bit-Modus zu starten (wegen der DefaultColorDepth Direktive, ohne sie
würde X im 8-Bit-Modus starten). Die erste Auflösung, die versucht wird, ist
1280x1024 (es wird einfach der Reihenfolge in der 'Modes'-Zeile gefolgt).
Denke daran, dass "1280x1024" einfach ein Label für die Werte in der
ModeLine ist.
d527 2
a528 2
Du solltest wissen, dass das ModeLine Generator-Skript Optionen hat, um seine
Timings für ältere oder kleinere Monitore etwas zu lockern, und
d531 1
a531 1
vielleicht nur schwer mit den Standard-Optionen zu betreiben. Wenn das 
d533 3
a535 3
horizontal oder vertikal gekippt ist und die Monitor-Kontrollen zur
Kompensierung nicht ausreichen, kann man mittels xvidtune(1) die ModeLine 
besser dem Monitor anpassen.
d538 7
a544 7
In den meisten modernen Monitoren gibt es kein festes Limit der Bandbreite,
daher ist sie auch oftmals nicht in den Spezifikationen aufgeführt.
Aber je mehr du in der Bandbreite nach oben gehst, desto  verschwommener
wird das Bild. Du könntest also zum Testen die Bandbreite deiner Grafikkarte
(auch "dotclock" genannt) eingeben (so kannst du deinen Monitor nicht
beschädigen) und Schritt-für-Schritt in Bandbreite heruntergehen, bis du
ein schönes, klares Bild hast.
d550 2
a551 2
in der Lage ist, Angaben aus vielen "plug and play" DDC und DDC2 
Monitoren auszulesen.
d554 2
a555 1
Du kannst das "Colas XFree86 ModeLine Generator script" hier herunterladen:
d557 3
a559 3
Du brauchst den Klone Interpreter und musst ihn kompilieren. Er ist als
<tt>lang/klone</tt> in den Ports. Die Skripte existieren im "scripts" 
Verzeichnis der Klone Distribution. (Der Port installiert sie nach
d563 7
a569 6
Es sind zwei Versionen des Skriptes dabei, die erste ist eine CGI Version,
die identisch zu der obigen Webseite ist. Die zweite ist eine nicht-CGI Version,
die deine komplette X.org-Datei nimmt, die Monitor-Spezifikationen
dekodiert, die du in xorgconfig/XF86Setup eingegeben hast (Hast du eigentlich
die echten Spezifikationen für deinen Monitor eingegeben, oder die
generischen benutzt?) und passt die existierenden ModeLines an.
d573 1
a573 1
<a href= "index.html">[FAQ Index]</a>
d586 1
a586 1
$Translation: faq11.html,v 1.15 2005/09/14 16:16:37 paldium Exp $
@


1.14
log
@sync with Steelix CVS
@
text
@d4 2
a5 1
<title>11 - Leistungs Tuning</title>
a8 1
<meta http-equiv="Content-Language" content="de">
d12 1
a12 1
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
d586 1
a586 1
$Translation: faq11.html,v 1.14 2005/07/11 16:43:16 paldium Exp $
@


1.13
log
@sync with Steelix CVS
@
text
@d417 1
a417 1
gibt es in der XF86Config(5) Manual Seite)
d494 2
a495 1
Nachdem du einmal die ModeLines hast, schreibe sie in deine /etc/X11/XF86Config Datei. 
d501 1
a501 1
du auch weißt, welche <tt>"Screen"</tt> Sektion der XF86Config-Datei du 
d585 2
a586 2
Originally [OpenBSD: faq11.html,v 1.56 ]
$Translation: faq11.html,v 1.13 2005/06/09 16:30:09 paldium Exp $
@


1.12
log
@sync with Steelix CVS
@
text
@d23 1
a23 1
<a href= "../faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
d573 1
a573 1
<a href= "../faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
d585 1
a585 1
$Translation: faq11.html,v 1.12 2005/05/29 12:21:52 paldium Exp $
@


1.11
log
@sync with steelix translation CVS
@
text
@d24 1
a24 1
<a href= "../faq12.html">[Zum Kapitel 12 - Plattform-spezifische Fragen]</a>
d69 1
a69 1
<H3>11.1.1 - CCD</H3>
d148 1
a148 1
0, 1, 4 und 5. Für raid muss, wie auch bei ccd, Unterstützung
d356 2
a357 2
Siehe auch die Manual Seite von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;apropos=0&amp;sektion=8">mount(8)</a>."
d585 1
a585 1
$Translation: faq11.html,v 1.11 2005/05/20 10:58:57 paldium Exp $
@


1.10
log
@Sync with Steelix CVS
@
text
@d36 1
a36 1
<li><a href="#XF86"   >11.4 - Deine Monitor-Auflösung unter XFree86
d384 1
a384 1
<h2>11.4 - Deine Monitor-Auflösung unter XFree86 tunen</h2>
d391 3
a393 3
Es ist durchaus mit vielen multi-Sync-Monitoren möglich, einen X 
Server in einer akzeptablen Auflösung zum Laufen zu kriegen.
Mit den Standard-Konfigurations-Werkzeugen xf86config oder XF86Setup ist
d402 1
a402 1
XFree86 eher nicht-intuitiv.
d410 1
a410 1
Der XFree86 X Server hat einen Mechanismus, der dir erlaubt, im Detail
d549 1
a549 1
dass es genau das ist. XFree86 4.0 kümmert sich darum und macht diesen
d565 2
a566 2
die deine komplette XF86Config-Datei nimmt, die Monitor-Spezifikationen
dekodiert, die du in xf86config/XF86Setup eingegeben hast (Hast du eigentlich
d584 2
a585 2
Originally [OpenBSD: faq11.html,v 1.55 ]
$Translation: faq11.html,v 1.10 2005/02/12 20:20:48 paldium Exp $
@


1.9
log
@Sync with Steelix CVS
@
text
@d12 1
a12 1
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
d544 1
a544 1
beschädigen) und Schritt-für-Schritt in BW heruntergehen, bis du
d584 2
a585 2
Originally [OpenBSD: faq11.html,v 1.54 ]
$Translation: faq11.html,v 1.9 2005/01/18 14:33:45 paldium Exp $
@


1.8
log
@Sync with Steelix CVS
@
text
@d9 1
a9 1
<meta name= "description"   content= "Die OpenBSD FAQ Seite">
d583 1
d585 4
a588 4
<br>
$Translation: faq11.html,v 1.8 2004/11/14 12:54:04 paldium Exp $
<br></small>
<small>$OpenBSD: faq11.html,v 1.54 2004/10/20 23:04:26 nick Exp $</small>
@


1.7
log
@more work from Tobias Stoeckmann, thanks !
@
text
@d9 2
a10 2
<meta name= "description"   content= "Die OpenBSD FAQ Seiten - FAQ 11: Performance Tuning">
<meta name= "keywords"      content= "openbsd,faq,performance,tuning ">
a26 1

d45 1
a45 2
<a name= "11.2"></a>
<h2>11.2 - Festplatten E/A</h2>
d53 1
a53 1
Aufmerksamkeit. Insbesondere, wenn deine Partition überläuft,
d101 3
a103 3
Wenn du ccd dazu benutzt, um mittels striping Performance zu gewinnen, solltest du wissen,
dass du keine optimale Performance bekommst, bis du das gleiche Festplatten-Modell mit den 
gleichen disklabel Einstellungen benutzt.
d110 1
a110 2
<blockquote>
<pre>
d120 1
a120 2
<blockquote>
<pre>
d127 2
a128 1
Jetzt hast du eine neue Festplatte, ccd0, eine Kombination von /dev/sd2e und /dev/sd3e.
a149 1
<p> 
a154 1
<p>
d170 1
d176 1
a176 1
Eine der langsamsten Operationen im traditionellen BSD Dateisysteme ist 
d178 1
a178 1
du Dateien oder Verzeichnisse erzeugst oder löschst.) Soft Updates
d189 1
a189 1
<a href="../faq14.html#SoftUpdates">Soft Updates FAQ</a> Eintrag.
d192 1
d200 2
a201 2
Manual Seite empfohlen, die <tt>NVNODE=integer</tt> Kernel Option zu setzen. Das wird nicht mehr
empfohlen; du solltest stattdessen das
d206 2
a207 2
page first... <a href="">namei(3)</a> --> namei() cache) kontrolliert die Geschwindigkeit
der pathname zu
d228 1
d230 1
d235 3
a237 2
<i>(Hinweis - diese Sektion dreht sich fast ausschließlich um die i386 oder PC Architektur.
Andere Architekturen geben dir sozusagen keine so große Auswahl!)</i>
d240 1
a240 1
Die Performance deiner Anwendungen hängt stark von deinem 
d243 1
a243 1
Die Performance deiner Anwendungen hängt aber auch stark von deiner 
d258 1
a258 1
zu sein, und Marken und Teile zu kaufen, die von jemandem empfohlen werden,
d269 1
a269 1
das auch mehr kostet, wird es doch die Last auf mehrere Spindeln verteilen,
d294 2
a295 2
meisten PCs schon. Mit SDRAM bekommst du eine bessere Performance als mit
DRAMs (SIMMs). Wenn dein System RDRAM unterstützt, oder vielleicht
d317 1
a317 1
Festplatte oder Netzwerk-Karte benutzt (oder noch schlimmer, für beides)
d321 1
a321 1
sind das meist Sound-Karten oder solche für serielle Ports.
d323 2
a324 2
<li><b>Vermeide billige PCI Netzwerk-Karten.</b>
OpenBSD unterstützt eine ganze Menge von billigen PCI Netzwerk-Karten.  
d329 1
a329 1
Qualitäts-Netzwerk-Karte besser dran. Unglücklicherweise
d340 1
d374 2
a375 2
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur</i>,
wenn dir der Verlust aller Daten in der Partition nach irgendeinem
d414 1
a414 1
vier Nummern für vertikales Timing, und eine optionale Sektion
d416 1
a416 1
den Modus (z.B. Interlace, DoubleScan, und weitere... mehr Details
d423 3
a425 3
Colas XFree86 ModeLine Generator</a>.  Ein weiteres ist der 
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline Generator</a>
, der bei SourceForge gehostet wird, und es gibt weitere bei
d428 4
a431 4
vertikalen und horizontalen sync Limits für deinen Monitor herausfinden.
Diese Angaben finden sich oftmals im Handbuch, oder auf der Webseite des
Monitor-Herstellers. Wenn du sie dort nicht finden kannst, suche einfach im Web nach
deinem Modell und Hersteller, viele Leute waren so freundlich, Listen
d490 1
a490 1
wenn die dot clock (Bandbreite) auf 200MHz begrenzt ist. Setze die Bandbreite
d498 2
a499 2
arbeiten willst. Als erstes musst du nun herausfinden, ob X im "accelerated mode"
läuft, oder nicht (das tut es mit den meisten Grafik-Karten), so dass 
d518 6
a523 6
in der X startet. Mit dem Drücken von STRG-ALT-NUMMERN_BLOCK MINUS oder CTRL-ALT-NUMMERN_BLOCK
PLUS kannst du zwischen den hier aufgeführten Auflösungen hin-
und herschalten. Gemäß der Angaben oben wird X versuchen im
32-Bit-Modus  (wegen der DefaultColorDepth Direktive, ohne sie würde X im
8-Bit-Modus starten.) Die erste Auflösung, die versucht wird, ist
1280x1024 (es wird einfach der Reihenfolge in der 'Modes'-Zeile gefolgt.)
d539 1
a539 1
In den meisten modernen Monitoren gibt es kein fixes Limit der Bandbreite,
d563 2
a564 2
Es sind zwei Versionen des Skriptes dabei, die erste ist eine CGI Version 
die identisch zu der obigen Webseite ist. Die zweite ist eine nicht-CGI Version
d585 1
a585 1
$Translation: faq11.html,v 1.7 2004/11/02 18:04:29 jufi Exp $
@


1.6
log
@Sync with Steelix CVS
@
text
@d4 2
a5 1
<title>11.0 - Performance Tuning</title>
a7 1
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
d12 1
a12 1
<meta name= "copyright"     content= "This document copyright 1998-2002 by OpenBSD.">
d17 3
a19 1
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
d21 8
a28 1
<h2><font color="#e00000">11.0 - Performance Tuning</font></h2>
a31 1
<blockquote>
a32 1
</blockquote>
d34 5
a38 6
<li><a href="#Network">11.1 - Netzwerk</a></li>
<li><a href="#Disk"   >11.2 - Festplatten I/O</a></li>
<!-- li><a href="#kmem"   >11.3 - Tuning kmem</a></li -->
<li><a href="#HW"     >11.4 - Hardware Auswahl</a></li>
<li><a href="#Async"  >11.5 - Wieso benutzen wir keine async mounts?</a></li>
<li><a href="#XF86"   >11.6 - Tunen deiner Monitorauflösung unter XFree86</a></li>
d40 1
a42 33
<p>
Wenn du einen vielbesuchten Server, ein Gateway oder eine Firewall administrierst, 
möchtest oder musst du vielleicht einige der standardmässigen 
Parameter anpassen, um eine optimale Performance zu erhalten.
Die <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a> 
man page berichtet über die angebotenen Kerneloptionen. Diese Optionen werden in der 
Kernel-Konfigurationsdatei plaziert, bevor du einen eigenen Kernel kompilierst. 
Mehr Details dazu erhälst du in der <a href="faq5.html">FAQ 5</a>.
<p>
<a name= "Network"></a>
<a name= "11.1"></a>
<h2>11.1 - Netzwerk</h2>

<p>
Ein Parameter, der bei einem besonders belasteten Server, Gateway oder 
Firewall vielleicht angepasst werden muss, ist NMBCLUSTERS.  Er 
kontrolliert die Grösse der kernel mbuf cluster map. Wenn du Meldungen
wie "mb_map full" auf deinem Computer bekommst, musst du die Werte für
diesen Parameter vergrössern. Wenn ohne ersichtlichen Grund der 
Traffic auf einem Netzwerk aufhört, kann das ebenfalls ein Zeichen
für zu kleine NMBCLUSTERS sein.  Ein sinnvoller Wert beim i386 port 
mit mindestens 100Mbps ethernet Interfaces (egal wieviele davon
die Maschine hat) ist 8192.  

<blockquote>
<strong>
option NMBCLUSTERS=8192<BR>
</strong>
</blockquote>
Die Standard-Anzahl von NMBCLUSTERS variiert von Plattform zu Plattform, 
und reicht von 256 bis 2048.  Sie werden in einer plattform-abhängigen 
Header-Datei gesetzt, es sei denn, sie werden von einer "option"-Zeile 
in einer Kernel-Konfigurations-Datei überschrieben.
d47 1
a47 1
<h2>11.2 - Festplatten I/O</h2>
d50 1
a50 1
Festplatten I/O Geschwindigkeit ist ein wichtiger Faktor in der 
d60 1
a60 1
<blockquote>
a61 1
</blockquote>
d63 4
a66 5
	<li><a href="#ccd">CCD</a> - Concatenated Disk Driver.
	<li><a href="#raid">RAID</a>
	<li><a href="#buf">Filesystem Buffer</a>
	<li><a href="#softu">Soft Updates</a>
	<li><a href="#maxvnodes">Grösse des namei() cache</a>
d71 2
a72 1
<H3>11.2.1 - CCD</H3>
a73 1
<p>
d75 1
a75 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;apropos=0&amp;sektion=4&amp;format=html">ccd(4)</a>, 
d77 1
a77 1
Das erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu verwandeln 
d82 1
d86 1
a86 1
Kernel benutzt, musst du es vielleicht wieder in deine Kernel-Konfiguration
a89 1
<p>
d95 1
a95 1
Das obige Beispiel gibt die bis zu 4 ccd Devices (virtuelle Platten).
d98 1
a98 1
Partitionen als 'ccd'-Typ zu markieren. Auf einigen Architekturen
d100 2
a101 1
einfach als 'ffs'. 
d106 3
a108 2
<P>
Editiere /etc/ccd.conf, bis sie etwa so aussieht :
d110 2
a111 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;apropos=0&amp;sektion=8&amp;format=html">ccdconfig(8)</a>)
d118 3
a120 2
</pre>
</blockquote>
d122 1
d127 2
d133 1
a133 1
Partitionen zu erzeugen, die du benutzen willst. Nutze erneut die 'c' 
d136 1
a136 1
der Disc weg ist.
a137 1
<br>
d139 1
d141 2
a142 1
<H3>11.2.2 - RAID</H3>
d144 4
a147 5
<p>
Eine weitere Lösung ist <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;apropos=0&amp;sektion=4&amp;format=html">raid(4)</a>,
wofür du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;apropos=0&amp;sektion=8&amp;format=html">raidctl(8)</a>
nutzen musst, um deine RAID Geräte zu kontrollieren. OpenBSD's RAID basiert auf 
Greg Oster's <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD port</a>
d151 2
a152 1
0, 1, 4, und 5.
a153 2
Für RAID muss, wie auch bei ccd, Unterstützung
im KERNEL sein.
d156 2
a157 3
einkompiliert werden (RAID-Unterstützung vergrössert deinen
i386 Kernel um gute 500k!)
</p>
d160 1
a160 2
<blockquote>
<pre>
d162 3
a164 3
</pre>
</blockquote>
<P>
d168 5
a172 5
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;apropos=0&amp;sektion=4&amp;format=html">raid(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;apropos=0&amp;sektion=8&amp;format=html">raidctl(8)</a>
man pages für die kompletten Details. Es gibt dafür viele 
Optionen und mögliche Konfiguationen, und ein detaillierter Überblick 
sprengt den Rahmen dieses Dokumentes.
a173 1
<BR>
d175 2
a176 11
<a name="buf"></a>
<H3>11.2.3 - Filesystem Buffer</H3>
<blockquote>
Fileserver, die noch Speicher überhaben, können die BUFCACHEPERCENT 
erhöhen. Das heisst, welcher Prozentsatz deines RAM als 
"file system buffer" (Dateisystem-Puffer) genutzt werden soll.
Diese Option wird vielleicht geändert, wenn der Unified Buffer Cache 
komplett und ein Teil von OpenBSD ist. In der Zwischenzeit solltest du 
eine Zeile wie diese zu deiner Kernel-Konfiguration hinzufügen, 
um BUFCACHEPERCENT zu erhöhen:
</blockquote>
a177 13
<p>
<blockquote>
<strong>option	BUFCACHEPERCENT=30</strong><BR>
</blockquote>
<blockquote>
<p>
Natürlich kannst du ihn auch auf 5 Prozent setzen (dem Standard) oder auch so hoch
wie 50 Prozent (oder auch mehr.)
</blockquote>
<br>

<a name="softu"></a>
<H3>11.2.4 - Soft Updates</H3>
d185 2
a186 2
Metainfos auf der Festplatte immer auf dem aktuellen Stand sind. Das heisst, 
ein Systemcrash sollte kein
d190 1
a190 1
(a la softupdates). Das heisst, dass Reboots viel schneller sind, da 
a194 1
<BR>
d197 4
a200 4
<H3>11.2.5 - Grösse des namei() cache</H3>
<DL>
<DD>
<p>
d202 2
a203 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4&amp;format=html">options(4)</a>
manual page empfohlen, die <TT>NVNODE=integer</TT> Kernel Option zu setzen. Das wird nicht mehr
d205 1
a205 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>
a206 1
</p>
d209 1
a209 1
page first... <a href="">namei(3)</a> --> namei()) cache kontrolliert die Geschwindigkeit
d211 4
a214 7
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5&amp;format=html">inode(5)</a>
Übersetzung. Standardmässig hat dieser Cache <TT>NPROC * (80 + NPROC / 8)</TT> 
Einträge. <TT>NPROC</TT> ist auf <TT>20 + 16 * MAXUSERS</TT> gesetzt; in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a>
manual page steht eine Erklärugn der <TT>maxusers</TT> Kernel-Konfigurations-Parameter.
Ein sinnvoller Weg zum Herausfinden der passenden Grösse des Cache 
wäre, eine große Anzahl von namei() cache misses vorrausgesetzt, die man mit einem 
d216 2
a217 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1&amp;format=html">systat(1)</a> 
messen könnte, wäre eine Untersuchung des momentanen 
d219 6
a224 6
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>,
(das diesen Parameter "<TT>kern.maxvnodes</TT>" nennt) und diesen Wert zu 
vergössern, bis sich entweder die namei() cache hit rate verbessert,
oder es bewiesen ist, dass das System nicht wesentlich von einer
Erhöhung der Grösse des namei() cache profitiert. Nachdem der 
Wert gestgestellt wurde, kannst du ihn für die nächsten 
d226 1
a226 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a>
d228 10
a237 3
</DD>
</DL>
<BR>
a239 13
<!-- a name= "kmem"></a>
<a name= "11.3"></a>
<h2>11.3 - Tuning kmem</h2>
</p>
This was moved to the <a href="faq11-2.5.html#11.2">OpenBSD 2.5 information section</a>.
<br>
<p -->
<a name= "HW"></a>
<a name= "11.4"></a>
<h2>11.4 - Hardware Auswahl</h2>
<i>(Hinweis - diese Sektion dreht sich fast ausschliesslich um die i386 oder PC Architektur.
Andere Architekturen geben dir sozusagen keine so grosse Auswahl!)</i>
<P>
d246 2
a247 2
brandneuen PC mit einem Intel Pentium IV oder AMD Athlon Prozessors viel
besser als das Preis-Leistungs-Verhältnis einer Sun UltraSparc 60!
d249 2
a250 1
<P>
d260 3
a262 2
du wahrscheinlich auch an Qualitält verlieren!
<P>
d264 5
a268 4
Performance aus deiner Hardware zu holen:
<UL>
<LI>Benutze mehrere Festplatten.
<P>Statt nur eine 20GB Platte zu kaufen, kaufe mehrere 9GB Platten. Wenn 
d271 1
a271 1
Ausserdem kannst du mit mehreren Platten auch mehr Zuverlässigkeit
d274 2
a275 2
<LI>Benutze SCSI, wenn du hohe Festplatten-IO-Geschwindigkeit brauchst.
<P>IDE Festplatten laufen normalerweise mit 5400 RPM bis 7200 RPM.  
d283 1
a283 1
<P>Wenn du einen Server baust, und mehr als 20 GB Plattenplatz brauchst, 
d286 2
a287 2
vermutlich einen negativen Effekt auf die I/O Performance dieser 
Platten. Mit Wide SCSI kannst du 15 Platten pro Controller anschliessen,
d290 3
a292 4
<P>
<li>Benutze SDRAM statt DRAM.
<P>
Diese Option trift fast nur auf PCs zu. Bei den meisten anderen Architekturen
d296 3
a298 4
DDR oder eine andere neue Art von RAM bist du sogar noch besser dran..  
<P>
<li>Benutze ECC oder parity RAM.
<P>
d303 3
a305 3
Architekturen brauchen einfach ECC oder parity RAM. Einige nicht-PC-Computer
booten nicht einmal mit nicht-parity-RAM. 
Wenn du kein ECC/parity RAM benutzt, kann es zu Daten-Korrumpierung und
d309 2
a310 2
"Workstations" aufgeteilt. Die Server haben parity (und jetzt ECC) seit 
vielen Jahren beinhaltet. Unix-Workstation-Hersteller benutzen parity 
d312 2
a313 3
<P>
<LI>Vermeide ISA-Karten.
<P>
d322 2
a323 3
<P>
<LI> Vermeide billige PCI Netzwerk-Karten.
<P>
d330 4
a333 5
sind einige Serien von teuren Marken-Herstellern (wie die 3com XL Serie) 
nicht besser als die billigen Karten.
Ein echter Favorit unter den 10/100Mbps Netzwerk-Karten ist dagegen die 
Intel EtherExpress PRO/100.
<P>
d335 2
a336 1
<br>
d339 1
a339 2
<a name= "11.5"></a>
<h2>11.5 - Wieso benutzen wir keine async mounts?</h2>
d341 1
a341 1
Frage: "Ich gebe einfach ein "mount -u -o async /"ein, was ein Paket, was ich 
d345 5
a349 5
Wieso wird asynchrones mounting abgelehnt und ist nicht standardmässig 
aktiviert (wie in manchen anderen Unixen) ? Wäre das nicht ein 
einfacherer, und daher auch sichererer Weg, die Performance mancher 
Applikation zu erhöhen ?"
</p>
d353 1
a353 1
Oder bei einem Hardwareproblem ? Die Suche nach Geschwindigkeit darf nicht
d355 3
a357 3
Siehe auch die man page von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;apropos=0&amp;sektion=8&amp;format=html">mount(8)</a>."
</p>
d368 1
d379 2
a380 2
</p>
<br>
d383 6
a388 2
<a name= "11.6"></a>
<h2>11.6 - Tunen deiner Monitorauflösung unter XFree86</h2>
d391 1
a391 1
Server in einer azeptablen Auflösung zum Laufen zu kriegen.
d402 2
a403 1
<P>
d415 5
a419 4
den Modus (z.B. Interlace, DoubleScan, und weitere.. mehr Details
gibt es in der XF86Config(5) manual page)
<P>
Das Erzeugen einer ModeLine ist eine schwarze Kunst.. Glücklicherweise
d432 2
a433 1
<P>
d435 1
a435 1
Dell's Website herausgefunden, das er einen Bereich  von 30-95 kHz horizontal 
d439 1
a439 1
grösser sollte im allgemeinen wenig flackern. Je mehr, desto besser 
d441 2
a442 1
<P>
d448 2
a449 2
<P>
<PRE>
d467 3
a469 2
</PRE>
<P>
d473 1
a473 1
minimalen vertikalen Rate herunter.. (Hier z.B. kannst du bis
d475 2
a476 1
<Pre>
d485 3
a487 2
</PRE>
<P>
d490 4
a493 3
gemäss der Grenzen, die vom Monitor definiert werden.
<P>
Nachdem du einmal die ModeLines hast, schreibe sie in deine /etc/XF86Config Datei. 
d499 1
a499 1
du auch weisst, welche <TT>"Screen"</tt> Sektion der XF86Config-Datei du 
d502 2
a503 1
<PRE>
d513 3
a515 1
</PRE>
d517 1
a517 1
in der X startet. Mit dem Drücken von CTRL-ALT-KEYPAD MINUS oder CTRL-ALT-KEYPAD
d519 8
a526 6
und herschalten. Gemäss der Angaben oben wird X versuchen im 32-Bit-Modus 
(wegen der DefaultColorDepth Direktive, ohne sie würde X im 8-Bit-Modus 
starten.) Die erste Auflösung, die versucht wird, ist 1280x1024 (es
wird einfach der Reihenfolge in der 'Modes'-Zeile gefolgt.)  Denke daran, dass
"1280x1024" einfach ein Label für die Werte in der ModeLine ist.
<P>
d532 2
a533 2
Bild zu gross ist, zu breit oder zu klein, oder nicht genügend 
horizontal oder vertikal gekippt ist, und die Monitor-Kontrollen zur
d536 2
a537 1
<P>
d545 2
a546 1
<P>
d548 2
a549 2
dass es genau das ist. XFree86 4.0 kümmert sich darum, und macht diesen
Prozess bedeutend einfacher, da es viele eingebaute Modi hat, und ausserdem
d552 2
a553 1
<P>
d556 3
a558 3
Du brauchst den Klone Interpreter, und musst ihn kompilieren. Er ist in als
<tt>lang/klone</tt> in den ports. Die Skripte existieren im "scripts" 
Verzeichnis der Klone Distribution.  (Der port installiert sie nach
d560 2
a561 1
<P>
d563 6
a568 5
die identisch zu der obigen Webseite ist. Die zweite ist eine nicht-CGI-Version
die deine komplette XF86Config-Datei nimmt, dekodiere die Monitor-Spezifikationen,
die du in xf86config/XF86Setup eingegeben hast (Hast du eigentlich die echten
Spezifikationen für deinen Monitor eingegeben, oder die generischen
benutzt?) und passe die existierenden ModeLines an.
d571 3
a573 3
<a href= "index.html">[Back to Main Index]</a>
<a href= "../faq10.html">[To Section 10.0 - System Administration]</a>
<a href= "faq12.html">[To Section 12.0 - Für fortgeschrittene Users]</a>
a574 1
</p>
d582 1
a582 1
Originally [OpenBSD: faq11.html,v 1.29 ]
d584 1
a584 1
$Translation: faq11.html,v 1.6 2004/10/29 21:28:08 jufi Exp $
d586 1
a586 1
<small>$OpenBSD: faq11.html,v 1.29 2002/07/25 08:05:08 jufi Exp $</small>
@


1.5
log
@
cleaning up keywords and description
@
text
@d32 1
a32 1
<li><a href="#XF86"   >11.6 - Tunen deiner Monitoraufl&ouml;sung unter XFree86</a></li>
d38 1
a38 1
m&ouml;chtest oder musst du vielleicht einige der standardm&auml;ssigen 
d41 1
a41 1
man page berichtet &uuml;ber die angebotenen Kerneloptionen. Diese Optionen werden in der 
d43 1
a43 1
Mehr Details dazu erh&auml;lst du in der <a href="faq5.html">FAQ 5</a>.
d52 5
a56 5
kontrolliert die Gr&ouml;sse der kernel mbuf cluster map. Wenn du Meldungen
wie "mb_map full" auf deinem Computer bekommst, musst du die Werte f&uuml;r
diesen Parameter vergr&ouml;ssern. Wenn ohne ersichtlichen Grund der 
Traffic auf einem Netzwerk aufh&ouml;rt, kann das ebenfalls ein Zeichen
f&uuml;r zu kleine NMBCLUSTERS sein.  Ein sinnvoller Wert beim i386 port 
d66 1
a66 1
und reicht von 256 bis 2048.  Sie werden in einer plattform-abh&auml;ngigen 
d68 1
a68 1
in einer Kernel-Konfigurations-Datei &uuml;berschrieben.
d80 2
a81 2
die Serverdienste nutzen). Datenspeicher brauchen st&auml;ndige 
Aufmerksamkeit. Insbesondere, wenn deine Partition &uuml;berl&auml;uft,
d83 1
a83 1
die Geschwindigkeit deiner Festplattenoperationen zu erh&ouml;hen
d94 1
a94 1
	<li><a href="#maxvnodes">Gr&ouml;sse des namei() cache</a>
d106 2
a107 2
(und damit kannst daf&uuml;r sorgen, dass mehrere Festplatten wie eine 
einzige aussehen). Dieses Konzept ist &auml;hnlich wie das von LVM
d112 1
a112 1
<tt>/usr/src/sys/conf/GENERIC</tt>).  Wenn du einen ver&auml;nderten
d114 1
a114 1
einf&uuml;gen. Wie auch immer, auf jeden Fall muss sich eine
d135 1
a135 1
(Mehr Informationen &uuml;ber das Konfigurieren von ccd findest du unter
d145 1
a145 1
Um die &Auml;nderungen wirksam zu machen, f&uuml;hre das hier aus:
d153 1
a153 1
Benutze disklabel einfach wie gew&ouml;hnlich, um die Partition oder 
d165 3
a167 3
Eine weitere L&ouml;sung ist <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;apropos=0&amp;sektion=4&amp;format=html">raid(4)</a>,
wof&uuml;r du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;apropos=0&amp;sektion=8&amp;format=html">raidctl(8)</a>
nutzen musst, um deine RAID Ger&auml;te zu kontrollieren. OpenBSD's RAID basiert auf 
d171 1
a171 1
OpenBSD hat Unterst&uuml;tzung f&uuml;r die RAID-Level
d174 1
a174 1
F&uuml;r RAID muss, wie auch bei ccd, Unterst&uuml;tzung
d176 1
a176 1
Diese Treiber-Unterst&uuml;tzung f&uuml;r RAID ist im Gegensatz zu ccd allerdings nicht 
d178 1
a178 1
einkompiliert werden (RAID-Unterst&uuml;tzung vergr&ouml;ssert deinen
d190 1
a190 1
schmerzhaft, um es sanft auszudr&uuml;cken. Nicht jedoch mit RAIDframe.
d194 2
a195 2
man pages f&uuml;r die kompletten Details. Es gibt daf&uuml;r viele 
Optionen und m&ouml;gliche Konfiguationen, und ein detaillierter &Uuml;berblick 
d203 2
a204 2
Fileserver, die noch Speicher &uuml;berhaben, k&ouml;nnen die BUFCACHEPERCENT 
erh&ouml;hen. Das heisst, welcher Prozentsatz deines RAM als 
d206 1
a206 1
Diese Option wird vielleicht ge&auml;ndert, wenn der Unified Buffer Cache 
d208 2
a209 2
eine Zeile wie diese zu deiner Kernel-Konfiguration hinzuf&uuml;gen, 
um BUFCACHEPERCENT zu erh&ouml;hen:
d218 1
a218 1
Nat&uuml;rlich kannst du ihn auch auf 5 Prozent setzen (dem Standard) oder auch so hoch
d226 1
a226 1
Ein weiteres Tool zum Erh&ouml;hen der Systemgeschwindigkeit sind Soft Updates.
d229 1
a229 1
du Dateien oder Verzeichnisse erzeugst oder l&ouml;schst.) Soft Updates
d235 2
a236 2
beim folgende Booten ben&ouml;tigen, sondern eine einfache 
Hintergrund-Version von fsck, die &Auml;nderungen an den Metainfos im RAM macht
d239 1
a239 1
leider noch nicht.) Mehr &uuml;ber Soft Updates findest du im 
d245 1
a245 1
<H3>11.2.5 - Gr&ouml;sse des namei() cache</H3>
d257 1
a257 1
Die name-to-inode &Uuml;bersetzung (a.k.a., <!-- need to write the manual
d261 2
a262 2
&Uuml;bersetzung. Standardm&auml;ssig hat dieser Cache <TT>NPROC * (80 + NPROC / 8)</TT> 
Eintr&auml;ge. <TT>NPROC</TT> ist auf <TT>20 + 16 * MAXUSERS</TT> gesetzt; in der
d264 3
a266 3
manual page steht eine Erkl&auml;rugn der <TT>maxusers</TT> Kernel-Konfigurations-Parameter.
Ein sinnvoller Weg zum Herausfinden der passenden Gr&ouml;sse des Cache 
w&auml;re, eine gro&szlig;e Anzahl von namei() cache misses vorrausgesetzt, die man mit einem 
d269 1
a269 1
messen k&ouml;nnte, w&auml;re eine Untersuchung des momentanen 
d273 1
a273 1
verg&ouml;ssern, bis sich entweder die namei() cache hit rate verbessert,
d275 2
a276 2
Erh&ouml;hung der Gr&ouml;sse des namei() cache profitiert. Nachdem der 
Wert gestgestellt wurde, kannst du ihn f&uuml;r die n&auml;chsten 
d298 4
a301 4
Die Performance deiner Anwendungen h&auml;ngt stark von deinem 
Betriebssystem und den F&auml;higkeiten ab, die es bereitstellt. Das mag
ein Grund daf&uuml;r sein, dass du OpenBSD benutzt.
Die Performance deiner Anwendungen h&auml;ngt aber auch stark von deiner 
d303 1
a303 1
F&uuml;r viele Leute ist das Preis-Leistungs-Verh&auml;ltnis eines 
d305 2
a306 2
besser als das Preis-Leistungs-Verh&auml;ltnis einer Sun UltraSparc 60!
Der Preis von OpenBSD ist nat&uuml;rlich unschlagbar.
d309 2
a310 2
oder Einzelteil f&uuml;r Einzelteil, solltest du sicherstellen, dass du 
unbedingt nur zuverl&auml;ssige Teile bekommst. In der Welt der PCs ist 
d312 3
a314 3
<b>Schlechte oder sonstige unzuverl&auml;ssige oder unpassende Teile
k&ouml;nnen dazu f&uuml;hren, dass OpenBSD schlecht l&auml;uft und oft
abst&uuml;rzt</b>.  Der beste Rat, den wir geben k&ouml;nnen, ist, vorsichtig 
d317 1
a317 1
du wahrscheinlich auch an Qualit&auml;lt verlieren!
d319 1
a319 1
Es gibt ein paar Dinge, die dir helfen k&ouml;nnen, die maximale 
d325 2
a326 2
und somit die Zeitspanne verringern, die ein Datenzugriff ben&ouml;tigt.
Ausserdem kannst du mit mehreren Platten auch mehr Zuverl&auml;ssigkeit
d339 1
a339 1
solltest du &uuml;ber SCSI nachdenken. IDE beschr&auml;nkt dich auf zwei
d343 1
a343 1
und es hat bessere Unterst&uuml;tzung f&uuml;r gleichzeitigen Zugriff 
d351 1
a351 1
DRAMs (SIMMs). Wenn dein System RDRAM unterst&uuml;tzt, oder vielleicht
d356 1
a356 1
Parity f&uuml;gt einen Mechanismus hinzu, der pr&uuml;ft, ob die Daten im 
d363 1
a363 1
anderen Abnormit&auml;ten kommen. Einige Herstelle von "billigem  PC RAM"
d372 1
a372 1
W&auml;hrend die meisten Leute ISA-Karten schon deshalb meiden, weil
d374 2
a375 2
trotzdem noch eine ganze Menge davon. Wenn du den ISA Bus f&uuml;r deine
Festplatte oder Netzwerk-Karte benutzt (oder noch schlimmer, f&uuml;r beides)
d377 3
a379 3
Geschwindigkeit brauchst, benutze PCI. Nat&uuml;rlich gibt es noch 
zahllose ISA-Karten, die einfach gut funktionieren. Ungl&uuml;cklicherweise 
sind das meist Sound-Karten oder solche f&uuml;r serielle Ports.
d383 1
a383 1
OpenBSD unterst&uuml;tzt eine ganze Menge von billigen PCI Netzwerk-Karten.  
d385 1
a385 1
solchen mit wenig oder moderater Netzwerk-Last im Gesch&auml;fts-
d388 1
a388 1
Qualit&auml;ts-Netzwerk-Karte besser dran. Ungl&uuml;cklicherweise
d403 1
a403 1
(das darauf besteht alle paar Momente ein paar hundert Dateien zu &auml;ndern.)
d405 2
a406 2
Wieso wird asynchrones mounting abgelehnt und ist nicht standardm&auml;ssig 
aktiviert (wie in manchen anderen Unixen) ? W&auml;re das nicht ein 
d408 1
a408 1
Applikation zu erh&ouml;hen ?"
d411 1
a411 1
Antwort: "Asynchrone mounts sind tats&auml;chlich schneller als synchrone 
d414 1
a414 1
auf Kosten von Stabilit&auml;t und Zuverl&auml;ssigkeit des Systems gehen.
d429 1
a429 1
Auf der anderen Seite, wenn du sowieso nur mit tempor&auml;ren Daten 
d431 1
a431 1
mehr Geschwindigkeit erhalten, indem du eine separate Partition nur f&uuml;r 
d437 1
a437 1
gel&ouml;scht und neu erzeugt werden.
d443 1
a443 1
<h2>11.6 - Tunen deiner Monitoraufl&ouml;sung unter XFree86</h2>
d445 2
a446 2
Es ist durchaus mit vielen multi-Sync-Monitoren m&ouml;glich, einen X 
Server in einer azeptablen Aufl&ouml;sung zum Laufen zu kriegen.
d449 2
a450 2
schmerzvolleren Punkte ist es, deinen Monitor zur gew&uuml;nschten
Aufl&ouml;sung zu bewegen, und dann eine vertikale Scan-Rate von
d452 1
a452 1
wesentlich geringer sichtbar f&uuml;r menschliche Augen ist.
d454 1
a454 1
So k&ouml;nntest du den Bildschirm zum Beispiel ohne Flackern auf Video
d458 1
a458 1
Schlussendlich ist es bei den Aufl&ouml;sungen, 
d461 1
a461 1
bestens m&ouml;glich, vertikale Wiederholungsraten von 85 Hz und mehr 
d466 3
a468 3
f&uuml;r die Pixel Clock, vier Nummern f&uuml;r horizontales Timing,
vier Nummern f&uuml;r vertikales Timing, und eine optionale Sektion
mit einer Liste von Flags f&uuml;r weitere Charakteristika wie etwa 
d472 2
a473 2
Das Erzeugen einer ModeLine ist eine schwarze Kunst.. Gl&uuml;cklicherweise
gibt es mehrere Skripte, die das f&uuml;r dich erledigen k&ouml;nnen.
d480 1
a480 1
vertikalen und horizontalen sync Limits f&uuml;r deinen Monitor herausfinden.
d486 1
a486 1
Sagen wir zum Beispiel, du h&auml;ttest einen Dell D1226H Monitor.  Du hast auf
d489 1
a489 1
und gib diese Informationen ein. Als n&auml;chstes musst du die minimale
d491 1
a491 1
gr&ouml;sser sollte im allgemeinen wenig flackern. Je mehr, desto besser 
d494 2
a495 2
Mit all diesen Informationen wird das Skript eine ModeLine f&uuml;r jede
m&ouml;gliche 4x3 Aufl&ouml;sung generieren, die dein Monitor unterst&uuml;tzen
d497 1
a497 1
Rate von 75 Hz eingibt, gibt das Skript etwas &auml;hnliches wie das folgende
d520 1
a520 1
Dieser Monitor gibt nun vor, 1600x1200 @@ 75 Hz machen zu k&ouml;nnen, 
d536 1
a536 1
Hier sehen wir, dass der Monitor tats&auml;chlich 1600x1200 @@ 74 Hz macht,
d538 1
a538 1
gem&auml;ss der Grenzen, die vom Monitor definiert werden.
d543 1
a543 1
Als n&auml;chstes w&auml;hle aus, mit welcher Aufl&ouml;sung du nun 
d545 1
a545 1
l&auml;uft, oder nicht (das tut es mit den meisten Grafik-Karten), so dass 
d547 1
a547 1
modifizieren musst. Alternativ kannst du nat&uuml;rlich einfach alle Screen-Sektionen
d560 6
a565 6
Die erste Aufl&ouml;sung nach dem "Modes" Stichwort ist die Aufl&ouml;sung,
in der X startet. Mit dem Dr&uuml;cken von CTRL-ALT-KEYPAD MINUS oder CTRL-ALT-KEYPAD
PLUS kannst du zwischen den hier aufgef&uuml;hrten Aufl&ouml;sungen hin-
und herschalten. Gem&auml;ss der Angaben oben wird X versuchen im 32-Bit-Modus 
(wegen der DefaultColorDepth Direktive, ohne sie w&uuml;rde X im 8-Bit-Modus 
starten.) Die erste Aufl&ouml;sung, die versucht wird, ist 1280x1024 (es
d567 1
a567 1
"1280x1024" einfach ein Label f&uuml;r die Werte in der ModeLine ist.
d570 3
a572 3
Timings f&uuml;r &auml;ltere oder kleinere Monitore etwas zu lockern, und
dass es die M&ouml;glichkeit hat, ModeLines f&uuml;r spezielle Monitore
anzubieten. Abh&auml;ngig davon, was f&uuml;r eine Hardware du hast, ist sie
d574 1
a574 1
Bild zu gross ist, zu breit oder zu klein, oder nicht gen&uuml;gend 
d580 1
a580 1
daher ist sie auch oftmals nicht in den Spezifikationen aufgef&uuml;hrt.
d582 1
a582 1
wird das Bild. Du k&ouml;nntest also zum Testen die Bandbreite deiner Grafikkarte
d584 2
a585 2
besch&auml;digen) und Schritt-f&uuml;r-Schritt in BW heruntergehen, bis du
ein sch&ouml;nes, klares Bild hast.
d587 2
a588 2
Wenn dir das unn&ouml;tig kompliziert erscheint, liegt das daran,
dass es genau das ist. XFree86 4.0 k&uuml;mmert sich darum, und macht diesen
d604 1
a604 1
Spezifikationen f&uuml;r deinen Monitor eingegeben, oder die generischen
d610 1
a610 1
<a href= "faq12.html">[To Section 12.0 - F&uuml;r fortgeschrittene Users]</a>
d622 1
a622 1
$Translation: faq11.html,v 1.5 2003/01/17 14:02:59 jufi Exp $
@


1.4
log
@
sync with steelix translation CVS
@
text
@d9 1
a9 1
<meta name= "description"   content= "Die OpenBSD FAQ Seiten - FAQ 11">
d622 1
a622 1
$Translation: faq11.html,v 1.4 2003/01/15 22:42:16 jufi Exp $
@


1.3
log
@
clean up
@
text
@d9 2
a10 2
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
d622 1
a622 1
$Translation: faq11.html,v 1.3 2002/11/21 18:10:32 jufi Exp $
@


1.2
log
@
sync with badlands translation CVS
@
text
@d1 1
d7 2
d19 2
a20 2
<h2><font color=#e00000>11.0 - Performance Tuning</font><hr></h2>
</p>
d23 4
a26 1
<ul><h3>Inhaltsverzeichnis</h3>
a33 1
</p> 
d40 1
a40 1
Die <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&sektion=4">options(4)</a> 
a47 1
</p>
a58 1
</p>
d60 1
a60 1
<ul>
d64 1
a64 1
</ul>
a68 1
<br>
a73 1
</p>
a84 1
</p>
d86 4
a89 1
<ul>Inhaltsverzeichnis
d96 1
d99 2
a100 1
<H3>11.2.1 - CCD</H3><UL>
d103 1
a103 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&apropos=0&sektion=4&format=html">ccd(4)</a>, 
d110 1
a110 1
<P>
a115 1
</p>
a120 1
</p>
d136 3
a138 3
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&apropos=0&sektion=8&format=html">ccdconfig(8)</a>)
<UL>
<PRE>
d143 2
a144 1
</PRE></UL>
d146 4
a149 2
<UL><PRE># ccdconfig -C
</PRE></UL>
d158 1
a158 2
</p>
</UL>
d163 1
a163 1
<UL>
d165 2
a166 2
Eine weitere L&ouml;sung ist <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&apropos=0&sektion=4&format=html">raid(4)</a>,
wof&uuml;r du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&apropos=0&sektion=8&format=html">raidctl(8)</a>
d183 1
a183 1
<UL>
d187 1
a187 1
</UL>
d192 2
a193 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&apropos=0&sektion=4&format=html">raid(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&apropos=0&sektion=8&format=html">raidctl(8)</a>
d197 1
a197 1
</UL>
d202 1
a202 1
<UL>
d210 1
a210 2
</UL>
</p>
d213 1
a213 1
<UL>
d215 2
a216 3
</UL>
</p>
<ul>
d220 1
a220 2
</p>
</ul>
d224 2
a225 1
<H3>11.2.4 - Soft Updates</H3><UL>
d241 1
a241 2
</UL>
</p>
d250 1
a250 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&sektion=4&format=html">options(4)</a>
d253 1
a253 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8&format=html">sysctl(8)</a>
d260 1
a260 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&sektion=5&format=html">inode(5)</a>
d263 1
a263 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&sektion=8&format=html">config(8)</a>
d268 1
a268 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&sektion=1&format=html">systat(1)</a> 
d271 1
a271 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8&format=html">sysctl(8)</a>,
d278 1
a278 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5&format=html">sysctl.conf(5)</a>
a281 1
</p>
a294 1
</p>
d416 1
a416 1
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&apropos=0&sektion=8&format=html">mount(8)</a>."
d435 1
a435 1
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&sektion=8">mfs(8)</a>
d622 1
a622 1
$Translation: faq11.html,v 1.2 2002/08/05 17:49:41 jufi Exp $
a624 1
</p>
@


1.1
log
@
sync with badlands translation CVS
@
text
@d620 1
a620 1
Originally [OpenBSD: faq11.html,v 1.28 ]
d622 1
a622 1
$Translation: faq11.html,v 1.1 2002/08/05 16:35:54 jufi Exp $
d624 1
a624 1
<small>$OpenBSD: faq11.html,v 1.28 2002/05/29 19:17:41 nick Exp $</small>
@

