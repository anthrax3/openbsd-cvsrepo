head	1.102;
access;
symbols;
locks; strict;
comment	@# @;


1.102
date	2014.04.01.17.03.08;	author nick;	state dead;
branches;
next	1.101;

1.101
date	2013.11.01.18.04.04;	author ajacoutot;	state Exp;
branches;
next	1.100;

1.100
date	2013.11.01.07.35.18;	author ajacoutot;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.16.07.48.59;	author ajacoutot;	state Exp;
branches;
next	1.98;

1.98
date	2013.08.14.16.16.19;	author ajacoutot;	state Exp;
branches;
next	1.97;

1.97
date	2013.08.06.06.36.26;	author ajacoutot;	state Exp;
branches;
next	1.96;

1.96
date	2013.07.24.21.14.57;	author ajacoutot;	state Exp;
branches;
next	1.95;

1.95
date	2013.07.23.06.21.48;	author ajacoutot;	state Exp;
branches;
next	1.94;

1.94
date	2013.06.05.12.30.47;	author ajacoutot;	state Exp;
branches;
next	1.93;

1.93
date	2013.06.02.19.35.33;	author ajacoutot;	state Exp;
branches;
next	1.92;

1.92
date	2013.05.12.16.04.55;	author ajacoutot;	state Exp;
branches;
next	1.91;

1.91
date	2013.05.01.17.39.06;	author ajacoutot;	state Exp;
branches;
next	1.90;

1.90
date	2013.05.01.14.42.14;	author ajacoutot;	state Exp;
branches;
next	1.89;

1.89
date	2013.02.22.07.53.37;	author ajacoutot;	state Exp;
branches;
next	1.88;

1.88
date	2013.02.13.19.42.18;	author ajacoutot;	state Exp;
branches;
next	1.87;

1.87
date	2013.01.18.07.15.55;	author ajacoutot;	state Exp;
branches;
next	1.86;

1.86
date	2012.12.28.18.32.14;	author ajacoutot;	state Exp;
branches;
next	1.85;

1.85
date	2012.11.02.07.24.04;	author ajacoutot;	state Exp;
branches;
next	1.84;

1.84
date	2012.06.29.14.35.07;	author ajacoutot;	state Exp;
branches;
next	1.83;

1.83
date	2012.06.09.08.27.49;	author ajacoutot;	state Exp;
branches;
next	1.82;

1.82
date	2012.06.05.22.29.42;	author ajacoutot;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.26.08.43.41;	author ajacoutot;	state Exp;
branches;
next	1.80;

1.80
date	2012.05.01.19.11.27;	author ajacoutot;	state Exp;
branches;
next	1.79;

1.79
date	2012.04.19.23.56.50;	author ajacoutot;	state Exp;
branches;
next	1.78;

1.78
date	2012.02.03.12.44.14;	author ajacoutot;	state Exp;
branches;
next	1.77;

1.77
date	2012.01.31.23.04.08;	author ajacoutot;	state Exp;
branches;
next	1.76;

1.76
date	2012.01.21.19.34.37;	author ajacoutot;	state Exp;
branches;
next	1.75;

1.75
date	2012.01.17.11.13.00;	author ajacoutot;	state Exp;
branches;
next	1.74;

1.74
date	2012.01.13.12.55.41;	author ajacoutot;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.26.08.25.02;	author tobias;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.01.11.02.21;	author tobias;	state Exp;
branches;
next	1.71;

1.71
date	2008.07.13.18.21.55;	author tobias;	state Exp;
branches;
next	1.70;

1.70
date	2008.05.27.10.00.23;	author tobias;	state Exp;
branches;
next	1.69;

1.69
date	2008.05.01.10.01.51;	author tobias;	state Exp;
branches;
next	1.68;

1.68
date	2008.04.28.08.25.40;	author tobias;	state Exp;
branches;
next	1.67;

1.67
date	2008.03.09.13.37.12;	author tobias;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.12.20.29.58;	author saad;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.23.18.29.30;	author jufi;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.20.09.29.46;	author jufi;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.18.13.02.50;	author jufi;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.01.19.09.08;	author jufi;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.26.03.08.02;	author jufi;	state Exp;
branches;
next	1.60;

1.60
date	2007.03.08.05.54.06;	author saad;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.10.05.22.16;	author saad;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.16.15.56.37;	author jufi;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.01.11.30.44;	author jufi;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.29.10.58.52;	author jufi;	state Exp;
branches;
next	1.55;

1.55
date	2006.08.12.15.36.36;	author jufi;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.29.09.33.04;	author saad;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.23.09.12.14;	author saad;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.01.12.19.17;	author jufi;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.25.08.25.48;	author saad;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.07.13.14.10;	author saad;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.01.10.48.42;	author saad;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.14.11.35.59;	author jufi;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.06.12.42.40;	author jufi;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.18.12.05.07;	author jufi;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.07.15.31.45;	author saad;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.29.15.13.40;	author saad;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.25.00.26.22;	author saad;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.12.15.54.53;	author jufi;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.04.20.24.23;	author jufi;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.30.08.23.46;	author saad;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.22.11.26.07;	author jufi;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.20.07.30.01;	author saad;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.13.07.55.55;	author saad;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.03.15.20.13;	author saad;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.15.04.26.14;	author saad;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.08.17.38.20;	author saad;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.30.13.52.07;	author saad;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.20.14.55.33;	author jufi;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.19.18.23.05;	author jufi;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.09.16.29.30;	author saad;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.04.17.52.25;	author jufi;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.12.20.36.53;	author jufi;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.18.17.17.47;	author jufi;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.31.09.15.27;	author jufi;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.27.19.32.46;	author jufi;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.14.20.22.29;	author jufi;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.10.19.43.30;	author jufi;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.09.15.24.14;	author jufi;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.02.18.40.59;	author jufi;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.29.21.31.33;	author jufi;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.17.18.47.48;	author jufi;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.15.22.51.40;	author jufi;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.04.11.53.39;	author jufi;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.20.13.42.05;	author jufi;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.03.16.04.38;	author jufi;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.19.18.25.39;	author jufi;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.25.10.50.58;	author jufi;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.14.21.06.40;	author jufi;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.27.20.23.43;	author jufi;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.10.17.16.10;	author jufi;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.25.23.07.32;	author jufi;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.25.20.08.13;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.07.19.06.32;	author jufi;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.06.16.52.58;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.27.18.16.19;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.27.16.20.56;	author reinhard;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.07.21.31.05;	author jufi;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.17.20.26.35;	author jufi;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.17.18.16.36;	author jufi;	state Exp;
branches;
next	;


desc
@@


1.102
log
@
Abandon translations, per deraadt@@ and ajacoutot@@.
Thanks to all those that did the translation work, and my appologies to
those who had to translate my writing!
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Festplattenkonfiguration</title>
<link rev= "made" href= "mailto:www@@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "OpenBSD FAQ 14 - Disk Setup">
<meta name= "keywords"      content= "openbsd,faq14">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2013 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq13.html">[Zum Kapitel 13 - Multimedia]</a>
<a href= "faq15.html">[Zum Kapitel 15 - Pakete und Portierungen]</a>
</font>

<h1><font color="#e00000">14 - Festplattenkonfiguration</font></h1><hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#intro"      >14.1 - Festplatten und Partitionen</a>
<li><a href="#fdisk"      >14.2 - Benutzung von OpenBSDs fdisk(8)</a>
<li><a href="#disklabel"  >14.3 - Benutzung von OpenBSDs disklabel(8)</a>
<li><a href="#NewDisk"    >14.4 -
    Hinzufügen weiterer Festplatten unter OpenBSD</a>
<li><a href="#Swap"       >14.5 - Wie wird Auslagerung gehandhabt?</a>
<li><a href="#SoftUpdates">14.6 - »Soft Updates«</a>
<li><a href="#Boot386"    >14.7 - Wie booten OpenBSD/i386 und OpenBSD/amd64?</a>
<li><a href="#LargeDrive" >14.8 -
    Welche Probleme treten bei großen Festplatten mit OpenBSD auf?</a>
<li><a href="#InstBoot"   >14.9 -
    Installieren von Bootblocks - i386/amd64-spezifisch</a>
<li><a href="#Backup"     >14.10 -
    Vorbereitung auf Katastrophen -
    Erzeugen von Backups und Wiederherstellung vom Band.</a>
<li><a href="#MountImage" >14.11 - Laufwerksabbilder in OpenBSD einhängen</a>
<li><a href="#pciideErr"  >14.12 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</a>
<li><a href="#NegSpace"   >14.14 -
    Warum sagt mir <tt>df(1)</tt>,
    dass ich mehr als 100&nbsp;% von meinem Laufwerk belegt habe?</a>
<li><a href="#OhBugger"   >14.15 -
    Partitionen wiederherstellen,
    nachdem das Disklabel gelöscht wurde</a>
<li><a href="#foreignfs"  >14.16 -
    Kann ich auf Daten zugreifen,
    die auf anderen Dateisystemen als FFS liegen?</a>
<ul>
  <li><a href="#foreignfsafter">14.16.1 -
        Die Partitionen sind nicht in meinem Disklabel verzeichnet!
        Was kann ich tun?</a>
</ul>
<li><a href="#flashmem"   >14.17 -
    Kann ich ein Flash-Speicher-Gerät mit OpenBSD benutzen?</a>
  <ul>
  <li><a href="#flashmemPortable">14.17.1 -
        Flash-Speicher als portables Speichergerät</a>
  <li><a href="#flashmemBoot"    >14.17.2 -
        Flash-Speicher als startbarer Speicherplatz</a>
  <li><a href="#flashmemLive"    >14.17.3 -
        Wie kann ich ein startbares »Live« USB-Gerät erzeugen?</a>
  </ul>
<li><a href="#DiskOpt"    >14.18 - Optimierung der Laufwerksleistung</a>
<li><a href="#Async"      >14.19 -
    Warum verwenden wir keine »async«hrone Einhängemodi?</a>
<li><a href="#altroot"    >14.20 -
		Duplikation deiner Wurzelpartition: »altroot«</a>
<li><a href="#softraid"   >14.21 - Wie nutze ich softraid(4)?</a>
</ul>
<hr>

<a name="intro"></a>
<h2>14.1 - Festplatten und Partitionen</h2>

<p>
Die Details der Einrichtung von Festplatten unter OpenBSD variieren zwischen
den Plattformen, sodass die spezifischen Installationsanweisungen der Datei
<tt>INSTALL.&lt;arch&gt;</tt> für die <a href="../../de/plat.html">Plattform</a>
gelesen werden sollten, um die Besonderheiten des Systems festzustellen.

<p>
<h3>Identifikation der Festplatte</h3>
OpenBSD handhabt Massenspeicher auf den meisten Plattformen mit zwei Treibern,
und zwar in Abhängigkeit des von dem Gerät unterstützten normalen
Befehlssatzes:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4"
>wd(4):</a> IDE-Festplatten (und Geräte die wie IDE-Platten aussehen, zum
Beispiel SATA-, MFM- oder ESFI-Festplatten, oder ein Flash-Speichergerät mit
einem entsprechendem Adapter), die an
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wdc&amp;sektion=4"
>wdc(4)</a>- oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4"
>pciide(4)</a>-Schnittstellen angeschlossen sind.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4"
>sd(4):</a> Geräte die SCSI-Kommandos nutzen, wie zum Beispiel
SCSI-Festplatten, die an SCSI-Adapter angeschlossen sind, USB-Festplatten,
SATA-Festplatten, die an eine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4"
>ahci(4)</a>-Schnittstelle angeschlossen sind, sowie Festplattenverbünde, die
durch einen RAID-Kontroller angesteuert werden.
</ul>

Die erste von OpenBSD identifizierte Platte eines bestimmten Types wird Platte
»0«, die zweite wird »1« etc.
Also wird die erste IDE-ähnliche Festplatte zu wd0, und die dritte
SCSI-ähnliche Festplatte zu sd2.
Wenn auf einem System zwei SCSI-ähnliche Platten und drei IDE-ähnliche Platten
vorhanden wären, so gäbe es auf dieser Maschine sd0, sd1, wd0, wd1 und wd2.
Die Anordnung hängt von der Reihenfolge ab, in der sie die Hardwareerfassung
während des Systemstarts gefunden hat.
Es gibt ein paar wichtige Punkte zu beachten:
<ul>
<li>Festplatten sind möglicherweise nicht in derselben Anordnung nummeriert, in
der das Boot-ROM versucht hat, sie zu booten (d.&nbsp;h. das System kann
etwas zu booten versuchen, dass OpenBSD als wd2 oder sd1 identifiziert).
Manchmal mag es dir möglich sein dies zu ändern, manchmal auch nicht.
<li>Das Entfernen oder Hinzufügen von Festplatten kann die Identität anderer
Laufwerke auf dem System verändern.
</ul>

<h3>Partitionierung</h3>

Aus historischen Gründen wird der Begriff »Partition« in OpenBSD für zwei
verschiedene Dinge benutzt, und dies führt zu einiger Verwirrung.

<p>
Die zwei als »Partition« bezeichneten Typen sind:
<ul>
<li>»disklabel-Partitionen«, die mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a> erzeugt werden (oft auch »Dateisystem-Partitionen« genannt).
<li>»fdisk-Partitionen«, erzeugt mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386"
>fdisk(8)</a> (oft »Partitionstabellen-Partitionen« oder »Master Boot Record
(MBR)-Partitionen« genannt).
</ul>

<p>
Alle von OpenBSD unterstützten Plattformen benutzen disklabel(8) als Königsweg,
um OpenBSD-Dateisystem-Partitionen zu verwalten, aber einige Plattformen
benötigen zusätzlich fdisk(8), um Partitionstabellen-Partitionen zu verwalten.
Auf den fdisk-Partitionen nutzenden Plattformen nimmt eine fdisk-Partition
alle OpenBSD-Dateisysteme auf, da diese eine Partition in disklabel-Partitionen
aufgeteilt wird.
Die disklabel-Partitionen sind mit den Buchstaben »a« bis »p« etikettiert.
Einige von ihnen sind speziell:
<ul>
<li><b>a</b> -- Auf dem Bootlaufwerk ist Partition »a« die root-Partition.
<li><b>b</b> -- Auf dem Bootlaufwerk wird Partition »b« automatisch als
Auslagerungs-Partition genutzt.
<li><b>c</b> -- Auf allen Laufwerken bezeichnet Partition »c« das gesamte
Laufwerk, vom ersten bis zum letzten Sektor.
(Hinweis: wenn du ein Laufwerk komplett löschen möchtest, brauchst du nur die
Partition »c« mit Nullen zu beschreiben.
Häufiger jedoch wird Partition »c« von Dienstprogrammen wie »fdisk« benutzt, um
»Bootloader«, Partitionstabellen usw. zu installieren.)
</ul>

<h3>Partitionsidentifizierung</h3>
Ein OpenBSD-Dateisystem wird durch die Festplatte identifiziert, auf der es
sich befindet, und zusätzlich durch die Dateisystem-Partition auf dieser
Festplatte.
Also können Dateisysteme durch Bezeichner wie »sd0a« (die Partition »a« des
ersten »sd«-Geräts), »wd2h« (Partition »h« des dritten »wd«-Geräts) oder »sd1c«
(das gesamte zweite »sd«-Gerät) gekennzeichnet sein.
Die Gerätedateien wären <tt>/dev/sd0a</tt> für das »block«-Gerät, und
<tt>/dev/rsd0a</tt> wäre die Gerätedatei für das »unverarbeitete« Gerät
(»Character-Device«).

<p>
Einige Dienstprogramme erlauben die Benutzung der verkürzten Namensform einer
Partition (d.&nbsp;h. »sd0d«) oder eines Geräts (d.&nbsp;. »wd1«), anstatt des
tatsächlichen, ausgeschriebenen Gerätenamens
(»<tt>/dev/sd0d</tt>« oder »<tt>/dev/wd1c</tt>«, respektive).

<p>
Erneut: es ist zu beachten, dass, wenn du Daten auf <tt>wd2d</tt> platzierst,
und dann später <tt>wd1</tt> aus dem System entfernst und neu startest, sich
deine Daten nun auf <tt>wd1d</tt> befinden, da dein vorheriges <tt>wd2</tt> nun
<tt>wd1</tt> ist.
Dagegen ändern sich die Kennungen eines Geräts nach dem Systemstart nicht
mehr, sodass für den Fall, dass ein USB-Gerät entfernt wird oder ausfällt, sich
die Kennungen für die anderen Geräte bis zum Neustart des Systems nicht ändern.

<a name="DUID"></a>
<h3>Eindeutige Disklabel-Kennungen</h3>
Laufwerke können ebenso durch eindeutige Disklabel-Kennungen
(»Disklabel Unique Identifiers«, DUIDs) identifiziert werden;
dies sind 16-stellige hexadezimale Zahlen, die von dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskmap&amp;sektion=4"
>diskmap(4)</a>-Gerät verwaltet werden.
Diese Zahl wird automatisch als Zufallszahl erzeugt, wenn ein Disklabel zum
ersten Mal geschrieben wird, der Standardwert auf existierenden (vor-OpenBSD
4.8) Labels ist jedoch (eine Reihe von 16) Null(en).
disklabel(8) kann benutzt werden, um die UID zu ändern, wenn gewünscht.
Diese UIDs sind »persistent« - identifizierst du deine Laufwerke auf diese
Weise, wird Laufwerk »<tt>f18e359c8fa2522b</tt>« immer Laufwerk
<tt>f18e359c8fa2522b</tt> bleiben, egal in welcher Reihenfolge oder auf welche
Weise es angeschlossen wird.
Du kannst auf dem Laufwerk Partitionen durch das Anhängen eines Punkts und dem
Partitions-Buchstaben spezifizieren; so bezeichnet zum Beispiel
<tt>f18e359c8fa2522b.d</tt> die Partition »d« des Laufwerks
<tt>f18e359c8fa2522b</tt> und wird IMMER auf denselben Speicherplatz verweisen,
ganz egal in welcher Reihenfolge das Gerät an das System angeschlossen wird,
oder an welche Schnittstellenart es angeschlossen wird.

<p>
Diese UIDs können fast überall dort zur Identifikation benutzt werden, wo eine
Partition oder ein Gerät spezifiziert werden muss, zum Beispiel in
<tt>/etc/fstab</tt> oder auf den Kommandozeilen.
Natürlich können Festplatten und Partitionen auch auf traditionelle Weise
identifiziert werden, also nach Gerät, Nummer der Einheit und Partition
(z.&nbsp;B. /dev/sd1f), und dies kann völlig transparent, also austauschbar
geschehen.

<p>
Es ist anzumerken, dass die DUID eine Eigenschaft des Disklabel ist, obwohl, da
OpenBSD nur ein Disklabel pro Laufwerk unterstützt, dies eher eine akademische
Feststellung ist.

<p>
<a name="fdisk"></a>
<h2>14.2 - Benutzung von OpenBSDs fdisk(8)</h2>

Lies zuerst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386"
>fdisk(8)</a>-Handbuchseite.

<p>
Auf einigen Plattformen (i386, amd64, macppc, zaurus und armish) wird
fdisk(8) verwendet, um eine Partition zu erstellen, die vom
Boot-ROM des Systems erkannt werden kann und die Disklabelpartitionen
von OpenBSD aufnehmen wird. Andere Plattformen benötigen oder verwenden
fdisk(8) nicht. Mit fdisk(8) kann auch der Masterbootrecord (MBR)
editiert werden, wodurch alle Betriebssysteme auf einem Computer
betroffen sind. Im Gegensatz zu anderen fdisk-ähnlichen Programmen
einiger anderen Betriebssysteme nimmt OpenBSDs fdisk an, dass du weißt
was du tust, und wird dich die meiste Zeit machen lassen was du willst
- somit steht dir ein sehr mächtiges Werkzeug zur Verfügung.
Andererseits lässt es dich eben auch Dinge machen, die du entweder
nicht machen solltest oder die du auch nicht gar nicht vorhattest.
Bei der Verwendung ist also Vorsicht geboten.

<p>
Normalerweise wird nur eine fdisk-Partition für OpenBSD auf einer Platte
angelegt. Diese Partition wird dann mit
<a href="#disklabel">disklabel</a> in weitere
OpenBSD-Dateisystempartitionen aufgeteilt.

<p>


<p>
Um dir nur deine Partitionstabelle mit fdisk anzugucken, verwende:

<blockquote><pre>
# <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Was dann eine ähnliche Ausgabe wie diese hier erzeugt:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre></blockquote>

<p>
In diesem Beispiel betrachten wir die Ausgabe des ersten
SCSI-Laufwerks. Wir können die OpenBSD-Partition (A6) und ihre Größe
sehen. Der * sagt uns, dass die OpenBSD-Partition eine bootbare
Partition ist.

<p>
Im vorherigen Beispiel haben wir uns die Informationen nur angesehen.
Was aber, wenn wir unsere Partitionstabelle verändern wollen? Nun, dazu
müssen wir zunächst die Option <b>-e</b> benutzen. Diese bringt uns dann
zu einer Kommandozeile, die uns mit fdisk interagieren lässt.

<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        swap            Swap two partition entries
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt;
</pre></blockquote>

<p>

<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe
der Option <b>-e</b> benutzen kann.

<ul>
<li><b>help</b>  Zeigt eine Liste der Kommandos an, die fdisk im
interaktiven Editmodus versteht.
<li><b>reinit</b>  Initialisiert die momentane im Speicher befindliche
Kopie des Bootblocks. Hiermit kannst du auf elegante und schnelle Weise
eine - die gesamte Platte in Anspruch nehmende - OpenBSD-Partition
erstellen, den Bootcode aktualisieren und - im Allgemeinen gesagt -
das System für OpenBSD vorbereiten (und nichts weiter außer OpenBSD).
<li><b>disk</b>  Zeigt die momentane Plattengeometrie an, die fdisk
ermittelt hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du
willst.
<li><b>setpid</b>  Ändert eine Partitionsidentifizierung des angegebenen
Partitionstabelleneintrages. Dieses Kommando ist insbesondere nützlich,
um eine existierende Partition OpenBSD wieder zugänglich zu machen.
<li><b>edit</b>  Ändere eine ausgewählte Plattengeometrie in der Kopie
des momentanen Bootblocks.  Das geschieht entweder im
BIOS-Geometriemodus oder in Sektoroffsets und -größen.
<li><b>flag</b>  Macht den jetzigen Partitionstabelleneintrag bootbar.
Nur ein Eintrag kann gleichzeitig bootbar sein. Wenn du von einer
erweiterten Partition booten willst, musst du auch den entsprechenden
Eintrag als bootbar markieren
(OpenBSD selbst kann nur von einer primären Partition gebootet werden,
auch wenn andere Partitionen als aktiv markiert werden können).
<li><b>update</b>  Bringt den Maschinencode in der Speicherkopie des
momentanen Bootblocks auf den aktuellen Stand.
<li><b>select</b>  Wählt und lädt den Bootblock, auf den der Eintrag der
erweiterten Partitionstabelle im momentanen Bootblock zeigt.
<li><b>swap</b>  Tauscht zwei MBR-Einträge miteinander aus, sodass du
den MBR neu ordnen kannst.
<li><b>print</b>  Gibt die momentan im RAM befindliche und gewählte
Kopie des Bootblocks und seinen MBR auf dem Bildschirm aus.
<li><b>write</b>  Schreibt die RAM-Version des Bootblocks auf
die Platte. Du wirst um eine Bestätigung gebeten.
<li><b>exit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt.
<li><b>quit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt. Im Gegensatz zu exit schreibt diese
Variante den modifizierten Block auf die Platte.
<li><b>abort</b>  Verlässt das Programm ohne Änderungen zu speichern.
</ul>

<h3>Tipps und Tricks für fdisk</h3>
<ul>
<!-- <li>Auf OpenBSD-Plattformen, die fdisk verwenden, solltest du die
erste Spur ungenutzt lassen. Hiermit lässt du Platz für den
Masterbootrecord, in dem sich die fdisk-Partitionstabelle befindet
(bin mir nicht sicher, ob das wahr ist). -->
<li>fdisk(8) bietet die Möglichkeit an, die Partitionen sowohl direkt
in Sektoren als auch im Zylinder/Kopf/Sektor-Format anzugeben. Für beide
Optionen gibt es gute Gründe - einige Aufgaben werden auf die eine Weise
leichter gelöst, andere auf die andere. Beschränke dich nicht darauf,
nur eine von beiden einzusetzen.
<li>Eine völlig geleerte Platte setzt voraus, dass der Bootcode des
Masterbootrecords geschrieben werden muss, bevor von ihr gebootet werden
kann. Du möchtest den vorhandenen Bootcode eventuell sowieso erneuern
falls dir seine Herkunft unbekannt ist.
<li>Wenn dein System eine Verwaltungs- oder Diagnosepartition besitzt,
dann wird dazu geraten, diese bestehen zu lassen oder sie VOR der
Installation von OpenBSD zu installieren.
<li>Aus historischen Gründen speichert »q« Änderungen ab und verlässt
das Programme - »x« hingegen verlässt das Programme ohne zu speichern.
Dies ist genau das Gegenteil von dem, was Leute von anderen Umgebungen
her gewohnt sind. Vor dem Speichern von Änderungen fragt fdisk(8) nicht
nach - sei bei der Verwendung also sorgfältig.

</ul>

<a name="disklabel"></a>
<h2>14.2 - Benutzung von OpenBSDs disklabel(8)</h2>
<a name="disklabel.1"></a>
<h3>Was ist disklabel(8)?</h3>

<p>
Lies zunächst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a>-Handbuchseite.

<p>
Die Details wie Platten unter OpenBSD eingerichtet werden
unterscheiden sich auf den einzelnen Plattformen. Auf den Plattformen
<a href="../../de/i386.html">i386</a>,
<a href="../../de/amd64.html">amd64</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/zaurus.html">zaurus</a>
und <a href="../../de/armish.html">armish</a> findet die Platteneinrichtung in
zwei Phasen statt. Zuerst wird das OpenBSD-Slice unter Verwendung von
fdisk(8) auf der Festplatte definiert und dann mit disklabel(8) in
OpenBSD-Partitionen unterteilt.

<p>
Alle OpenBSD-Plattformen verwenden jedoch primär disklabel(8) für die
Verwaltung von OpenBSD-Partitionen. Plattformen, die ebenfalls fdisk(8)
einsetzen, legen alle disklabel(8)-Partitionen in einer einzelnen
fdisk-Partition an.

<p>
Labels beinhalten bestimmte Informationen über deine Festplatte; unter
anderem deine Plattengeometrie und Informationen über die Dateisysteme
auf deiner Platte. Sie beinhalten auch Informationen über deine Platte
selbst wie zum Beispiel Umdrehungsgeschwindigkeit, Interleave etc.
Diese Einträge existieren auf Grund früherer Notwendigkeiten und sind
meist nicht einmal korrekt: Mach dir also keine Gedanken darüber. Das
Disklabel wird dann vom Bootstrapprogramm genutzt, um das Laufwerk
anzusprechen und zu wissen, welche Dateisysteme sich auf dem Laufwerk
befinden. Weitere Informationen über Disklabel kannst du in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>-Handbuchseite
nachlesen.

<p>
Auf einigen Plattformen hilft disklabel, Architekturbegrenzungen bei
der Plattenpartitionierung zu überwinden. Zum Beispiel kann man auf
i386 nur vier primäre Partitionen anlegen;
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
benutzt eine dieser primären Partitionen, die dann *alle* deine
OpenBSD-Partitionen enthält (z.&nbsp;B. »swap«, »/«, »/usr«, »/var«
etc.) - und du hast noch drei weitere für andere Betriebssysteme übrig.

<a name="disklabel.2"></a>
<h3>disklabel(8) während der OpenBSD-Installation</h3>

<p>
Einer der Hauptteile der OpenBSD-Installation ist das erstmalige
Erzeugen der Labels. Während der Installation kannst du disklabel(8)
verwenden, um separate Partitionen zu erstellen. Als Teil des
Installationsprozesses kannst du deine Mountpunkte in disklabel(8)
definieren - im weiteren Verlauf oder auch nach der Installation kannst
du sie aber weiterhin ändern.

<p>
Obwohl es keinen »richtigen« Weg gibt, wie man ein Disklabel anlegt,
gibt es viele falsche. Bevor du versuchst, ein Label für deine Platte
anzulegen, wirf einen Blick auf <a href="faq4.html#Partitioning">diese
Diskussion</a> über das Partitionieren und Partitionsgrößen.

<p>
Um ein Beispiel für die Verwendung von disklabel(8) während der
Installation zu sehen, wirf einen Blick auf das Kapitel
<a href="faq4.html#Moredisklabel">Festplatte(n) einrichten</a>, das Teil der
<a href="faq4.html">Installationsanleitung</a> ist.


<p>

<a name="disklabel.3"></a>
<h3>disklabel(8) nach der Installation verwenden</h3>

<p>
Wenn dein System erst einmal installiert ist, solltest du disklabel
nicht mehr allzu oft benutzen müssen. Aber du kannst es gebrauchen, wenn
du z.&nbsp;B. Festplatten hinzufügen, welche entfernen oder auch einfach
umstrukturieren möchtest. Eines der ersten Dinge, die du dann machst,
ist dir den momentanen gültigen Disklabel anzusehen. Und das geht so:

<blockquote><pre>
# <b>disklabel wd0</b> &lt;-- <i>Or whatever disk device you'd like to view</i>
type: ESDI
disk: ESDI/IDE disk
label: SAMSUNG HD154UI 
duid: d920a43a5a56ad5f
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2907021
total sectors: 2930277168
boundstart: 64
boundend: 2930272065
drivedata: 0 

16 partitions:
#                size           offset  fstype [fsize bsize  cpg]
  a:          1024064               64  4.2BSD   2048 16384    1 # /
  b:          4195296          1024128    swap                   
  c:       2930277168                0  unused                   
  d:          4195296          5219424  4.2BSD   2048 16384    1 # /usr
  e:          4195296          9414720  4.2BSD   2048 16384    1 # /tmp
  f:         20972448         13610016  4.2BSD   2048 16384    1 # /var
  h:          2097632         34582464  4.2BSD   2048 16384    1 # /home
</pre></blockquote>

<p>
Beachte, dass bisher nur ein Teil des zur Verfügung stehenden
Plattenspeichers zugewiesen wurde.

Mit disklabel gibt es zwei verschiedene Modi für die Editierung des
Disklabels: ein eingebauter kommandozeilenbasierter Editor (mit diesem
hast du OpenBSD ursprünglich installiert) und ein vollständiger Editor
wie beispielsweise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">vi(1)</a>.
Den eingebauten kommandozeilenbasierten Editor wirst du vermutlich als
einfacher zu bedienen empfinden, da er dich durch alle Schritte führt
und nach Bedarf weitere Hilfe ausgibt - der Vollbildeditor hat
selbstverständlich auch seine Daseinsberechtigung.

<p>
Lass uns eine Partition zum gerade gezeigten System hinzufügen.

<p>
<blockquote>
<i>Warnung: Jedes Mal wenn du dein Disklabel editierst setzt du die
gesamten Daten auf deiner Platte einer großen Gefahr aus. Stell sicher,
dass du deine Daten gesichert hast, bevor du ein bestehendes Disklabel
modifizierst!</i>
</blockquote>

<p>
Wir werden hierfür den eingebauten kommandozeilenbasierten Editor
verwenden, der mit der Option -E von disklabel(8) aufgerufen wird.

<blockquote><pre>
# <b>disklabel -E wd0</b>
...
> a k
offset: [36680096] 
size: [2893591969] 1T
Rounding to cylinder: 2147483536
FS type: [4.2BSD] 
> p m
OpenBSD area: 64-2930272065; size: 1430796.9M; free: 364310.8M
#                size           offset  fstype [fsize bsize  cpg]
  a:           500.0M               64  4.2BSD   2048 16384    1 # /
  b:          2048.5M          1024128    swap                   
  c:       1430799.4M                0  unused                   
  d:          2048.5M          5219424  4.2BSD   2048 16384    1 # /usr
  e:          2048.5M          9414720  4.2BSD   2048 16384    1 # /tmp
  f:         10240.5M         13610016  4.2BSD   2048 16384    1 # /var
  h:          1024.2M         34582464  4.2BSD   2048 16384    1 # /home
  k:       1048575.9M         36680192  4.2BSD   8192 65536    1 
> q
Write new label?: [y] 
</pre></blockquote>

In diesem Fall war disklabel(8) nett und hat einen guten Startoffset
für die Partition berechnet. In den meisten Fällen wird das auch
funktionieren - falls du aber »Löcher« im Disklabel hast (d.&nbsp;h.
falls du eine Partition gelöscht hast oder dir das Leben unnötig schwer
machen willst) musst du eventuell zu Papier und Bleistift greifen und
den passenden Offset selbst ausrechnen.
Beachte, dass es gut möglich ist, dass Dinge hier fehlschlagen, obwohl
disklabel(8) einige Gültigkeitsüberprüfungen durchführt. Sei sicher,
dass du genau weißt, was die Bedeutung dieser Zahlen ist, die du gerade
eingibst.

<p>
Auf den meisten OpenBSD-Plattformen stehen sechzehn Disklabelpartitionen
zur Verfügung: von a bis p (einige »besondere« Systeme haben nur acht).
Jedes Disklabel sollte eine Partition namens c mit dem Dateisystemtyp
(fstype) »unused« aufweisen. Versuche niemals, ein Dateisystem auf c
zu erstellen. Auf dem Bootdevice ist a für die Rootpartition reserviert
und b für die Swappartition. Diese Einschränkung gilt nur für das
Bootdevice. Andere Devices können alle fünfzehn Partitionen außer c für
Dateisysteme nutzen.

<p>
<h3>Tipps und Tricks für disklabel</h3>
<ul>
<li><b>Hilfe erhalten:</b> Im kommandozeilenbasierten Modus kann man
mit Drücken von »?« eine Liste aller verfügbaren Kommandos anzeigen
lassen. »M« gibt die Handbuchseite von disklabel(8) aus.

<li><b>Auf Standardwerte zurücksetzen:</b> In einigen Fällen möchtest
du vielleicht komplett von vorne beginnen und alle bestehenden
Disklabelinformationen löschen. Das Kommando »D« wird das Label zurück
auf die Standardwerte setzen - als wenn noch nie ein Disklabel auf dem
Laufwerk gewesen wäre.

<li><b>Ein Disklabel duplizieren:</b> In einigen Fällen möchtest du
vielleicht die Partitionierung von einer Platte auf eine andere kopieren
- allerdings nicht 100%ig (zum Beispiel möchtest du zwar die gleichen
Partitionen haben, diese aber auf unterschiedlich großen Laufwerken).
Verwende den Modus -e (Vollbildeditor) von disklabel(8), kopiere die
Partitionen des Ausgangslaufwerks und füge die Zeilen in das neue
Laufwerk ein. Entferne dann die Partition c vom Ausgangslaufwerk und
speicher ab. Somit hast du nun das Plattenlayout auf das andere
Laufwerk kopiert, ohne die Basisparameter geändert zu haben.

<li>(sparc/sparc64) <b>Lege die Swappartition nicht am Anfang deiner
Platte an.</b>

<li>(i386, amd64) <b>Belasse die erste Spur ungenutzt:</b>
Auf einigen Plattformen muss die erste logische Spur ungenutzt
bleiben - sowohl von disklabel(8) als auch von fdisk(8). Dieser
Leitfaden wird manchmal umformuliert in »beginne mit deinen Partitionen
beim Sektor 63«, doch ist das NUR wahr, wenn es sich dabei auch um die
Größe einer Spur auf deiner Hardware handelt. Nimm niemals an, dass
das immer der Fall ist - disklabel wird dir mitteilen, wie viele Sektoren
vermutlich pro Spur vorliegen. Viele andere Plattformen gehen davon
aus, dass OpenBSD-Partitionen beim Sektor 0 beginnen.

<li><b>Devices ohne Disklabel:</b>
Falls ein Device momentan kein OpenBSD-Disklabel hat, dafür aber andere
Dateisysteme (zum Beispiel eine Platte mit zuvor angelegtem
FAT32-Dateisystem) wird der OpenBSD-Kernel ein Disklabel im Speicher
»anlegen«. Hiermit ist eine Grundlage für ein OpenBSD-Disklabel gegeben,
das dann auf die Platte geschrieben werden kann. Fall ein Disklabel
jedoch erstellt und auf die Platte geschrieben wurde und danach ein
Dateisystem angelegt wird, das nicht zu OpenBSD gehört, wird das
Disklabel nicht automatisch aktualisiert. Du musst dies manuell machen,
wenn du möchtest, dass OpenBSD auf dieses Dateisystem zugreifen kann.
Weitere Informationen hierüber befinden sich
<a href="faq14.html#foreignfsafter">weiter unten</a>.

<li><b>»q« gegen »x«:</b>
Aus historischen Gründen speichert »q« im kommandobasierten Editormodus
alle Änderungen ab und verlässt das Programm - »x« hingegen verlässt
das Programm, ohne zu speichern. Dies ist genau das Gegenteil von dem,
was viele Leute aus anderen Umgebungen gewohnt sind. Vor dem Speichern
von Änderungen warnt disklabel(8) jedoch, sodass »x« schnell und
ohne jeglichen Kommentar ausgeführt wird.

<li><b>Automatische Partitionierung:</b>
Neue Benutzer werden ermutigt, das Kommando »A« zur automatischen Erzeugung
eines empfohlenen disklabels zu nutzen.
Du kannst danach das automatisch erzeugte Label editieren oder verändern, wenn
die Notwendigkeit dafür besteht.

</ul>


<a name="NewDisk"></a>
<h2>14.4 - Hinzufügen weiterer Festplatten unter OpenBSD</h2>
<!-- XXX whoa. this section needs rework -->
<p>
Nun, nachdem du deine Festplatte <b>ORDNUNGSGEMÄSS</b> eingebaut hast,
musst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>nur i386 </i>) und auch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
verwenden, um deine Festplatte unter OpenBSD benutzen zu können.

<p>
Besitzer eines i386-Systems starten mit fdisk. Besitzer anderer
Architekturen können diesen Schritt einfach ignorieren. In dem Beispiel
weiter unten werden wir dem System ein drittes SCSI-ähnliches Laufwerk
hinzufügen.

<blockquote><pre>
# <b>fdisk -i sd2</b>
</pre></blockquote>

Das wird die »echte« Partitionstabelle der Festplatte für eine
ausschließliche Benutzung von OpenBSD initialisieren. Als nächstes musst
du ein Disklabel dafür erzeugen. Das wird wohl etwas verwirrend wirken.

<blockquote><pre>
# <b>disklabel -e sd2</b>

<i>(der Bildschirm wird leer, dein $EDITOR erscheint)</i>
type: SCSI
<i>... Bla ...</i>
sectors/track: 63
total sectors: 6185088
<i>... Bla ...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></blockquote>

Zunächst einmal ignoriere die Partition c - sie ist immer da und
Programme wie disklabel benötigen sie, um zu funktionieren!
Für OpenBSD ist fstype 4.2BSD. Die gesamte Größe der Festplatte ist
wird unter total sectors angegeben. Nehmen wir an, es handelt sich um
eine 3 Gigabyte große Festplatte. Drei Gigabytes in der Sprache der
Festplattenhersteller sind 3000 Megabytes. Dividiere also
6185088 mit 3000 (benutze
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1"
>bc(1)</a>).
Du erhältst 2061. Um jetzt Partitionsgrößen für a, d, e, f, g, ... zu
erstellen, rechne einfach X * 2061, um X Megabyte Platz auf dieser
Partition zu erhalten. Der Offset für deine erste Partition sollte
derselbe sein, wie unter sectors/track vorher in disklabels Ausgabe
angegeben. Bei uns ist es 63. Der Offset für jede Partition ist
hinterher eine Kombination aus der Größe und dem Offset jeder anderen
Partition (mit Ausnahme der Partition c, da sie keine Rolle in dieser
Gleichung spielt).

<p>
Wenn du aber nur eine Partition auf deiner Festplatte brauchst, zum
Beispiel, wenn du das ganze Ding nur zum Ablegen von Webseiten oder
einem Heimatverzeichnis oder etwas anderem nutzen willst, nimm einfach
die gesamte Größe der Platte und ziehe die Sektoren pro Spur davon ab:
6185088 - 63 = 6185025.  Deine Partition ist:

<blockquote><pre>
    d:  6185025       63    4.2BSD     1024  8192    16
</pre></blockquote>

<b>Wenn dir das alles unnötig komplex erscheint, kannst du disklabel -E
benutzten, um den selben Partitionierungsmodus zu erhalten, den du auf
deiner Installationsdisk hattest!</b>
Dort kannst du 96M benutzen, um 96 Megabytes anzugeben (oder 96G für 96
Gigabytes).

<p>
Das war eine Menge. Aber du bist noch nicht fertig. Zuletzt musst du
noch das Dateisystem auf der Festplatte mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
anlegen.

<blockquote><pre>
# <b>newfs sd2d </b>
</pre></blockquote>

<p>
Oder wie auch immer deine Festplatte nach dem
OpenBSD-Plattennummerierungsschema heißen mag. (Siehe einfach in der
Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
nach, um zu sehen, wie die Platte von OpenBSD benannt wurde.)

<p>
Nun überleg dir, wohin du deine gerade neu geschaffene Partition mounten
willst. Sagen wir einfach mal /u. Erzeuge zunächst erstmal /u. Dann
mounte sie.

<blockquote><pre>
# <b>mount /dev/sd2d /u</b>
</pre></blockquote>

<p>
Zuletzt musst du sie noch zur
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
hinzufügen.

<blockquote><pre>
/dev/sd2d /u ffs rw 1 1
</pre></blockquote>

<p>
Was aber, wenn du ein existierendes Verzeichnis wie zum Beispiel
/usr/local auslagern willst?
In diesem Falle solltest du die neue Platte als /mnt einhängen und /usr/local
nach /mnt kopieren.
Beispiel:

<blockquote><pre>
# <b>cd /usr/local && pax -rw -p e . /mnt</b>
</pre></blockquote>

Editiere
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"
>/etc/fstab(5)</a> dergestalt, dass die Partition /usr/local nun auf /dev/sd2d
(deine frisch formatierte Partition) zeigt.
Beispiel:

<blockquote><pre>
<b>/dev/sd2d /usr/local ffs rw 1 1</b>
</pre></blockquote>

<p>
Starte in den Singleuser-Modus mit <b>boot -s</b> neu, verschiebe
das existierende /usr/local nach /usr/local-backup (oder lösche es
gleich, wenn du mutig bist) und lege ein leeres Verzeichnis namens
/usr/local an. Starte dann das System neu und voila: Die Dateien sind
da!

<p>
<a name="SwapFile"></a>
<a name="Swap"></a>
<h2>14.5 - Wie wird Auslagerung gehandhabt?</h2>

<h3>14.5.1 - Über Auslagerung</h3>
Historisch betrachtet wurden alle Arten von Regeln aufgestellt, um
Administratoren eine Richtschnur darüber zur Hand zu geben, wieviel
Auslagerungsspeicher sie auf ihren Maschinen zu konfigurieren hätten.
Das Problem dabei ist, natürlich, dass es wenige »normale« Anwendungen gibt.

<p>
Eine nicht-offensichtliche Nutzung von Auslagerung ist, dass es ein Platz ist,
an den der Kernel eine Kopie darüber, was sich im Moment einer Systempanik im
Speicher befindet, für die spätere Analyse abladen kann.
Damit dies funktionieren kann, muss eine Auslagerungs-Partition (keine
Auslagerungs-Datei) vorhanden sein, die mindestens so groß ist wie der
Hauptspeicher.
Im Normalfall wird das System eine Kopie dieses Dumps während des
Systemneustarts nach <tt>/var/crash</tt> kopieren, sodass, wenn du möchtest,
dass all dies automatisch geschieht, du ausreichenden <i>freien</i>
Speicherplatz auf <tt>/var</tt> benötigst.
Allerdings kannst du das System auch in den Ein-Benutzer-Modus booten und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8"
>savecore(8)</a> benutzen, um den Dump an eine andere Stelle zu verfrachten.

<p>
Viele Arten von Systemen können auch ohne Auslagerung passend konfiguriert
sein.
So sollten zum Beispiel Firewalls im normalen Betrieb nicht auslagern.
Basiert deine Firewall auf Flash-Speicher, so magst du einen (kleinen) Nutzen
davon haben, keine Auslagerungs-Partition zu allozieren, obwohl, in den meisten
Fällen, eine Auslagerungs-Partition auch nicht wirklich schmerzt;
die meisten Laufwerke haben mehr als genug Platz, um ein kleines bisschen davon
für Auslagerung zu allozieren.

<p>
Es gibt alle Arten von Tipps für die Optimierung von Auslagerung (wo auf der
Platte, separate Platte, etc.), aber wenn du dich in einer Situation befindest,
in der die Optimierung von Auslagerung ein Thema ist, so benötigst du
vielleicht mehr Hauptspeicher.
Generell gesagt ist die beste Optimierung von Auslagerung, keine solche zu
benötigen.

<p>
Unter OpenBSD wird Auslagerung von dem Programm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8"
>swapctl(8)</a> verwaltet, das Auslagerungs-Geräte und -Dateien hinzufügt,
entfernt, auflistet und priorisiert.

<h3>14.5.2 - Auf eine Partition auslagern</h3>

<p>
Unter OpenBSD wird die Partition »b« des Bootlaufwerks standardmäßig und
automatisch für Auslagerung genutzt.
Hierfür wird keinerlei Konfiguration benötigt.
Wünschst du keine Auslagerung auf dem Boolaufwerk zu nutzen, definiere keine
Partition »b«.
Wünschst du die Nutzung von Auslagerung auf einer anderen Partition oder auf
anderen Laufwerken, so musst du diese Partitionen in <tt>/etc/fstab</tt> mit
Zeilen wie den Folgenden definieren:

<blockquote><pre>
/dev/sd3b none swap sw 0 0
/dev/sd3d none swap sw 0 0
</pre></blockquote>

<h3>14.5.3 - In eine Datei auslagern</h3>

(Hinweis: Wenn du in eine Datei swappen willst, weil du immer
»virtual memory exhausted«-Fehler bekommst, solltest du lieber
versuchen, deine Begrenzungen auf Prozessebene mittels

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1"
>csh(1)</a>'s unlimit,
oderr
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1"
>sh(1)</a>'s ulimit zu erhöhen.)

<p>
Manchmal erweist sich deine erste Vermutung darüber, wieviel Auslagerung du
brauchst, als falsch, und du musst zusätzlichen Auslagerungs-Speicherplatz
hinzufügen, zuweilen in Eile (wie in »Jungs, wenn es in dieser Geschwindigkeit
Auslagerung verbrennt, sind wir in fünf Minuten eingekeilt«).
Findest du dich in dieser Situation, mag das Hinzufügen von zusätzlichem
Auslagerungs-Speicherplatz in Form einer Datei auf einem existierenden
Dateisystem eine schnelle Hilfe sein.

<p>
Die Datei darf nicht auf einem
Dateisystem mit Softupdates liegen (was ja standardmäßig deaktiviert
ist). Finde zunächst einmal heraus, wie viel Swap du momentan hast
und wie viel du davon benutzt. Das geht mit dem Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
recht einfach. Zum Beispiel mit diesem Aufruf:

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></blockquote>

<p>
Das zeigt sowohl alle Geräte, die momentan für das Swappen benutzt
werden, als auch ihre momentane Statistik an. Im obigen Beispiel gibt es
nur ein Gerät namens swap_device. Das ist der vordefinierte Bereich auf
der Platte, der für das Swappen benutzt wird (wird im Übrigen als
Partition b bei Disklabels angezeigt). Wie du auch sehen kannst, wird
das Gerät zurzeit nicht sonderlich belastet oder vielmehr benutzt.
Aber für den Zweck dieses Dokumentes tun wir einfach so, als wenn noch
weitere 32 MB benötigt werden würden.

<p>
Der erste Schritt, um eine Datei als Swapbereich zu nutzen, ist die
Datei zu erzeugen. Am besten macht man das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Hier ist ein Beispiel, das die 32 M große Datei <i>/var/swap</i>
erzeugt.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Nachdem das erledigt ist, können wir jetzt das Swappen auf dieses Device
richten. Benutze einfach das folgende Kommando, um das Swappen auf
dieses Device zu lenken:

<blockquote><pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre></blockquote>

<p>
Jetzt müssen wir noch prüfen, ob sie auch korrekt zu unserer Liste der
Swapdevices hinzugefügt wurde.

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>

<p>
Jetzt, da die Datei erzeugt wurde und in sie hinein geswappt wird, musst
du noch eine Zeile in deine <i>/etc/fstab</i> hineinschreiben, so
dass die Datei beim nächsten Booten auch benutzt wird. Wenn diese Zeile
nicht hinzugefügt wird, wird dieses Swapdevice nicht konfiguriert.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></blockquote>

<a name="SoftUpdates"></a>
<h2>14.6 - Softupdates</h2>

<p>
Softupdates basieren auf einer Idee, die von
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg&nbsp;Ganger
und Yale&nbsp;Patt</a> vorgeschlagen wurde, und wurden für FreeBSD von
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a> entwickelt.
Softupdates erzwingen eine gewisse Reihenfolge der
Buffercacheoperationen, was die Anforderungen für das Entfernen des
FFS-Codes ermöglicht, der für das synchrone Schreiben von
Verzeichniseinträgen zuständig ist. Daher konnte ein großer
Geschwindigkeitsanwachs in der Leistung der Schreibzugriffe auf Platten
festgestellt werden.

<p>
Die Aktivierung von Softupdates muss mit einer Option während dem
Mounten ausgeführt werden. Wenn eine Partition mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
gemountet wird, kannst du angeben, dass du Softupdates auf dieser
Partition aktivieren möchtest. Dies ist ein Beispieleintrag für
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i>,
der eine Partition <i>sd0a</i> auflistet, die wir mit Softupdates
gemountet haben möchten.

<blockquote><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></blockquote>

<p>
Hinweis für Sparc-Anwender: Aktiviere Softupdates nicht auf sun4- oder
sun4c-Maschinen. Diese Architekturen unterstützen nur eine sehr
begrenzte Menge Kernelspeicher und können diese Funktion nicht
verwenden. Trotzdem sind sun4m-Maschinen in Ordnung.

<p>
<a name="Boot386"></a>
<a name="BootAmd64"></a>
<h2>14.7 - Wie booten OpenBSD/i386 und OpenBSD/amd64?</h2>
Der Bootprozess für OpenBSD/i386 und OpenBSD/amd64 ist nicht einfach und verstehen, wie es funktioniert, kann nützlich sein, um ein Problem zu lösen, wenn Dinge
nicht laufen.
Während des Bootprozesses gibt es vier Schlüsselereignisse:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> Der »Master Boot Record« ist,
was sich in den ersten 512 Bytes des Laufwerks findet.
Er beinhaltet
die primäre Partitionstabelle und ein kleines Programm, um den Partition
Boot Record (PBR) zu laden. Bedenke, dass in einigen Umgebungen der
Begriff MBR verwendet wird, um nur auf den Codeteil dieses ersten Blocks
auf der Platte zu verweisen, statt auf den gesamten ersten Block
(einschließlich der Partitionstabelle).
Es ist äußerst wichtig, die Bedeutung von »initialize the MBR« zu verstehen -
in der Terminologie von OpenBSD bedeutet es, den kompletten MBR neu zu
schreiben und die existierende Partitionstabelle zu löschen, und nicht nur den
Code, wie es eventuell einige andere Systeme machen.
Oft wirst du dies nicht tun wollen.
Darum benutze stattdessen fdisk(8)s Kommandozeilenoption »-u«
(»<tt>fdisk -u wd0</tt>«), um den MBR-Boot-Code (erneut) zu installieren.

<p>
Obwohl OpenBSD seinen eigenen MBR-Code besitzt, wirst du nicht gezwungen, ihn
zu verwenden, da so gut wie jeder MBR OpenBSD booten kann.
Der MBR wird von
dem Programm fdisk(8) verändert, welches verwendet wird, um die
Partitionstabelle zu editieren und um ebenfalls den MBR-Code auf die
Platte zu schreiben.

<p>
OpenBSDs MBR kündigt sich selbst mit der Meldung an:

<blockquote><pre>
Using drive 0, partition 3.
</pre></blockquote>

die die Platte und Partition anzeigt, von der er den PBR laden wird.
Zusätzlich zu dem Offensichtlichen, zeigt er ebenfalls einen angehängten
Punkt ("."), welcher darauf deutet, dass diese Maschine in der Lage ist,
LBA-Übersetzung zum Booten zu verwenden. Wenn die Maschine nicht in der
Lage ist, LBA-Übersetzung zu verwenden, wäre der obige Punkt mit einem
Semikolon (»;«) ausgewechselt worden, das auf CHS-Übersetzung deutet:

<blockquote><pre>
Using Drive 0, Partition 3;
</pre></blockquote>

Bedenke, dass der angehängte Punkt oder das angehängte Semikolon als ein
Indikator für den neuen OpenBSD-MBR angesehen werden kann, der mit
OpenBSD 3.5 eingeführt wurde.

<p>
<li><b><i>Partition Boot Record (PBR):</i></b>
Der »Partition Boot Record«, auch der PBR oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a> genannt wird (nach dem Namen der Datei, der den Code
beinhaltet), ist, was sich in den ersten 512 Byte einer OpenBSD-Partition
findet.
Der PBR ist der »First-Stage Boot-Lader« für OpenBSD.
Er wird vom MBR-Code geladen und hat die Aufgabe, OpenBSDs
Secondstage-Bootloader
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
zu laden.
Wie der MBR ist auch der PBR eine sehr kleine Sektion von Code und Daten
- insgesamt nur 512 Byte. Das ist nicht genug, um eine vollständig
dateisystembewusste Applikation zu laden, sodass, statt den PBR
<tt>/boot</tt> auf der Platte ausfindig machen zu lassen, die
BIOS-verfügbare Stelle von <tt>/boot</tt> physikalisch in den PBR
während der Installation eingetragen wird.

<p>
Der PBR wird von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>
installiert, das
<a href="faq14.html#InstBoot">später in diesem Dokument</a> genauer
beschrieben wird.
Der PBR kündigt sich selbst mit der Meldung an:
<blockquote><pre>
Loading...
</pre></blockquote>
die einen Punkt für jeden Dateisystemblock anzeigt, den er versucht
auszulesen. Ebenfalls zeigt der PBR an, ob er LBA oder CHS zum Laden
verwendet - wenn er CHS-Übersetzung verwendet, zeigt er eine Nachricht
mit einem Semikolon an:
<blockquote><pre>
Loading;...
</pre></blockquote>

<p>
<li><b><i>Secondstage-Bootloader, <tt>/boot</tt>:</i></b> <tt>/boot</tt>
wird vom PBR geladen und hat die Aufgabe, auf das OpenBSD-Dateisystem
durch das BIOS der Maschine zuzugreifen und den aktuellen Kernel
ausfindig zu machen und zu laden. boot(8) übergibt ebenfalls
verschiedene Optionen und Informationen an den Kernel.
<p>
boot(8) ist ein interaktives Programm. Nachdem es geladen ist versucht
es, <tt>/etc/boot.conf</tt> ausfindig zu machen und zu laden, wenn sie
existiert (was auf einer standardmäßigen Installation nicht der Fall
sein muss) und verarbeitet sämtliche Kommandos in ihr. Wenn es durch
<tt>/etc/boot.conf</tt> nicht anders angeordnet wurde, gibt es dem
Benutzer einen Prompt aus:

<blockquote><pre>
probing: pc0 com0 com1 apm mem[636k 190M a20=on]
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.21
boot>
</pre></blockquote>

Es gibt dem Benutzer (standardmäßig) fünf Sekunden lang die Möglichkeit,
andere Aufgaben auszuführen, aber wenn keine vor dem Ablauf der Zeit
eingegeben wurde, startet es sein normales Verhalten: Den Kernel
<tt>bsd</tt> von der root-Partition der ersten Festplatte laden.
Der Secondstage-Bootloader untersucht deine Systemhardware durch das
BIOS (da der OpenBSD-Kernel noch nicht geladen ist). Oben kannst du ein
paar Dinge sehen, die er gesucht und gefunden hat:
<ul>
<li><b>pc0</b> - Die Standardtastatur und -bildschirmausgabe eines
i386-Systems.
<li><b>com0, com1</b> - Zwei serielle Schnittstellen
<li><b>apm</b> - »Advanced Power Management«-BIOS-Funktionen
<li><b>636k 190M</b> - Die Menge des herkömmlichen (unterhalb von 1 M)
und erweiterten (oberhalb von 1 M) Speichers, den er gefunden hat
<li><b>fd0 hd0+</b> - Die BIOS-Laufwerke, die er gefunden hat: in diesem
Fall ein Disketten- und ein Festplattenlaufwerk.
</ul>

Das »+«-Zeichen nach hd0 zeigt an, dass das BIOS <tt>/boot</tt>
mitgeteilt hat, dass diese Festplatte über LBA angesprochen werden kann.
Wenn eine erstmalige Installation ausgeführt wird, siehst du ab und zu
einen * nach einer Festplatte - dies deutet auf eine Platte hin, die so
scheint, als wenn sie kein OpenBSD-Disklabel beinhaltet.

<p>
<li><b><i>Kernel: <tt>/bsd</tt></i>:</b> Dies ist das Ziel des
Bootprozesses: Den OpenBSD Kernel in den RAM laden und sauber
auszuführen.  Wenn der Kernel einmal geladen wurde, kann OpenBSD direkt
auf die Hardware zugreifen, nicht mehr durch das BIOS.

</ol>

So, der Anfang vom Start des Bootprozesses könnte wie folgt aussehen:

<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.21
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2013 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 5.4 (GENERIC) #37: Tue Jul 30 12:05:01 MDT 2013
    deraadt@@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
   ...
</pre></blockquote>


<h3>Was fehlschlagen kann</h3>
<ul>
<li><b>Beschädigter/ungültiger/inkompatibler MBR:</b>
Normalerweise hat eine gebrauchte Festplatte irgendeinen MBR-Code
installiert, aber wenn die Platte neu ist oder von einer anderen
Plattform übernommen wurde,
UND du nicht mit »w« auf die Frage »Use (W)hole disk or (E)dit the MBR?«
des <a href="faq4.html#InstDisks">Installations-Prozesses</a> geantwortet hast,
so kann es sein, dass am Ende das Laufwerk keinen gültigen MBR besitzt, und
daher nicht startbar ist, obwohl es eine gültige Partitionstabelle besitzt.

<p>
Du kannst den OpenBSD-MBR auf deine Festplatte unter Verwendung vom
Programm fdisk installieren. Boote dein Installationsmedium und wähle
Shell aus, um auf den Kommandoprompt zu gelangen:

<blockquote><pre>
# <b>fdisk -u wd0</b>
</pre></blockquote>

Du kannst auch einen bestimmten MBR auf deine Platte mit fdisk
schreiben:
<blockquote><pre>
# <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre></blockquote>

Hiermit wird die Datei <tt>/usr/mdec/mbr</tt> als dein System-MBR
installiert. Diese bestimmte Datei einer standardmäßigen
OpenBSD-Installation ist ebenfalls der standardmäßige MBR, der in
fdisk integriert wurde. Es könnte aber jeder andere MBR hier angegeben
werden.

<li><b>Ungültige <tt>/boot</tt>-Ortsangabe im PBR installiert:</b>
Wenn installboot(8) den Partition Boot Record installiert, schreibt er
die Blocknummer und den Offset von <tt>/boot</tt>s Inode in den PBR.
Daher wird das Löschen oder Ersetzen von <tt>/boot</tt> ohne
erneutes Ausführen von <a href="faq14.html#InstBoot">installboot(8)</a>
dein System in einen Zustand versetzen, in dem es nicht mehr booten
kann, da der PBR laden wird, auf was auch immer die Inode zeigt, die
angegeben wurde. Das wird vermutlich nicht mehr der erhoffte
Secondstage-Bootloader sein!

Seit <tt>/boot</tt> unter Verwendung von BIOS-Aufrufen ausgelesen wird,
waren ältere Versionen vom PBR sehr sensibel auf
BIOS-Plattenübersetzungen. Wenn du die Plattengeometrie (z.&nbsp;B.
wenn du die Platte aus einem Computer genommen hast, der
CHS-Übersetzung verwendet hat, und es in einen steckst, der
LBA-Übersetzung verwendet oder sogar die Übersetzungsoption im BIOS
geändert hast) geändert hast, wird es <i>für das BIOS so wirken</i>, als
wenn sie an einem anderen Ort liegen würde (es muss auf einen anderen
nummerischen Block zugegriffen werden, um die gleichen Daten von der
Platte zu erhalten), sodass du installboot(8) erneut ausführen musst,
bevor das System neugestartet werden kann. Der neue (von OpenBSD 3.5 und
später) PBR ist sehr viel toleranter im Bezug auf Übersetzungsänderungen.
</ul>

Da der PBR sehr klein ist, ist die Anzahl der Fehlermeldungen sehr
begrenzt und recht kryptisch. Typische Nachrichten sind:

<ul>
<li><b>ERR R</b> - Das BIOS gab einen Fehler zurück als es versucht hat,
einen Block von der Platte zu lesen.
Es bedeutet meistens genau das, was es aussagt: Von deiner Platte konnte
nicht gelesen werden.
<li><b>ERR M</b> - Eine ungültige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>-Nummer
wurde aus dem Header des Secondstage-Bootloaders gelesen. Dies bedeutet
normalerweise, dass, was auch immer eingelesen wurde, NICHT
<tt>/boot</tt> war, was darauf hinweist, dass installboot(8) nicht
korrekt ausgeführt wurde, die /boot-Datei geändert wurde oder du die
Fähigkeit deines BIOS erschöpft hast, um von einer
<a href="#LargeDrive">großen Platte</a> zu lesen.

</ul>
Andere Fehlermeldungen werden in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>-Handbuchseite ausführlich besprochen.

<p>
Für weitere Informationen über den i386-Bootprozess, siehe:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.html"
>http://www.ata-atapi.com/hiw.htm</a> Hale Landis' »How it Works«-Dokumente.
</ul>

<a name="LargeDrive"></a>
<h2>14.8 - Welche Probleme treten bei großen Festplatten mit OpenBSD
auf?</h2>

<p>
OpenBSD unterstützt sowohl FFS- als auch FFS2- (ebenfalls bekannt als
UFS und UFS2) Dateisysteme. FFS ist das historische OpenBSD-Dateisystem,
FFS2 seit Version 4.3 verfügbar. Bevor die speziellen Grenzen der
jeweiligen Systeme betrachtet werden, müssen wir zuerst auf ein paar
generelle Systemeinschränkungen eingehen.

<p>
Selbstverständlich sind die Fähigkeit eines Dateisystems und die
Fähigkeit einer bestimmten Hardware zwei unterschiedliche Dinge.
Eine neuere 250 G große IDE-Festplatte kann unter Umständen nicht mit
älteren (vor >137G-Standard) Interfaces funktionieren (obwohl sie
meistens einwandfrei arbeiten) und einige sehr alte SCSI-Adapter sind
bekannt dafür, dass sie Probleme mit moderneren Laufwerken haben und
einige alte BIOSe werden hängen, wenn sie einer modern bestückten
Festplatte begegnen.
Du musst natürlich die Fähigkeiten deiner Hardware und deines Starter-Codes
respektieren.

<h3>Partitionsgröße und Lokalitätsbegrenzungen</h3>
Leider ist die volle Funktionalität des OS nicht verfügbar, bis
NACHDEM das OS in den Speicher geladen wurde. Der Bootprozess verwendet
(und ist daher auch darauf beschränkt) die Boot-ROM des Systems.

<p>
Aus diesem Grund muss die /bsd-Datei (der Kernel) innerhalb des vom
Boot-ROM adressierbarem Bereich liegen. Das bedeutet für einige ältere
i386-Systeme, dass die root-Partition vollständig innerhalb der ersten
504 M liegen muss, aber neuere Computer können diese Grenze bei 2 G,
8 G, 32 G, 128 G oder mehr haben. Es ist ebenfalls sinnvoll zu erwähnen,
dass viele relativ neue Computer, die Laufwerke mit mehr als 128 G
Speicher unterstützen tatsächlich eine BIOS-Begrenzung für die ersten
128 G für das Booten haben. Du kannst diese Systeme mit großen
Laufwerken betreiben, aber deine root-Partition muss in dem Bereich
liegen, der vom Boot-ROM unterstützt wird.

<p>
Bedenke, dass es möglich ist, ein 40 G großes Laufwerk in einen alten
486er einzubauen und auf diesem OpenBSD mit einer großen Partition zu
installieren und zu denken, dass du erfolgreich die vorherige Regel
gebrochen hast. Trotzdem kann es dich auf einem höchst unangenehmen Weg
verfolgen:

<ul>
 <li>Du installiert eine 40 G /-Partition. Es funktioniert, da das
 Basis-OS und alle seine Dateien (einschließlich /bsd) innerhalb der
 ersten 504 M liegen.
 <li>Du benutzt das System und endest mit mehr als 504 M Dateien auf
 ihm.
 <li>Du aktualisiert und kopierst deinen neuen /bsd über den alten.
 <li>Du startest neu.
 <li>Du bekommst eine Meldung wie »ERR M« oder andere Probleme während
 dem Booten.
</ul>
<p>
Warum? Weil, wenn du eine neue /bsd-Datei »über« die alte kopierst,
überschreibt sie nicht die alte - ihr wird einem neuen Ort auf der Platte
zugewiesen, möglicherweise außerhalb der 504-M-Grenze, die das
BIOS hat. Der Bootloader wird nun nicht mehr in der Lage sein, die
/bsd-Datei zu erhalten und das System hängt.

<p>
Um OpenBSD zum Booten zu bringen, müssen die Bootloader (biosboot(8) und
<tt>/boot</tt> im Falle von i386/amd64) und der Kernel (<tt>/bsd</tt>)
innerhalb des Bereiches sein, den die Boot-ROM unterstützt und
innerhalb ihrer eigenen Fähigkeiten. Um sicher zu gehen, ist die Regel
einfach:

<blockquote>
<b>Die gesamte root-Partition muss innerhalb des vom Computer-BIOS
(oder Boot-ROM) adressierbaren Speichers liegen.</b>
</blockquote>

<p>
Einige Nicht-i386-Anwender denken, dass sie dies nicht betrifft, jedoch
haben die meisten Plattformen eine Art Begrenzung des ROMs bezüglich der
Plattengröße. Herauszufinden, wie groß diese Begrenzung denn nun
tatsächlich ist, kann schwer sein.

<p>
Dies ist ein weiterer guter Grund <a href="faq4.html#Partitioning">deine
Festplatte zu partitionieren</a>, statt nur eine große Partition zu
verwenden.

<h3>Zeit- und Speicheranforderungen von fsck(8)</h3>
Eine weitere Überlegung mit großen Dateisystemen ist die Zeit und der
Speicher, die benötigt werden, um as Dateisystem nach einem Crash oder
einer Stromunterbrechung einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
zu unterziehen.
Man sollte nicht ein 120 G großes Dateisystem auf ein System mit 32 M
RAM setzen und erwarten, dass es fsck(1) erfolgreich nach einem Crash
ausführt. Eine grobe Richtlinie ist, dass das System zumindest 1 M
Arbeitsspeicher für jedes 1 G des Plattenspeichers haben sollte, um
erfolgreich fsck gegen die Platte auszuführen. Zu diesem Zeitpunkt
kann zwar geswappt werden, doch wird dies mit einem großen
Geschwindigkeitseinbruch geschehen. In den meisten Fällen ist daher
davon abzuraten - es sei denn es gibt spezielle Gründe dafür.

<p>
Die benötigte Zeit, um fsck gegen ein Laufwerk auszuführen kann ein
Problem werden, sobald das Dateisystem an Größe gewinnt. Du musst fsck
aber nur auf den Plattenspeicher anwenden, der tatsächlich zu
gemounteten Dateisystemen gehört. Dies ist ein weiterer Grund, NICHT
sofort deinen gesamten Plattenbereich zu allokieren, nur weil er
vorhanden ist.
Dateisysteme nur lesend oder gar nicht gemountet zu
haben hilft dabei, sie beim nächsten Stolpern über das Stromkabel
keinem erneuten fsck(8) zu unterziehen.
Die Anzahl an »inodes« (durch Nutzung der newfs-Option -i) zu reduzieren kann
ebenfalls den Zeitbedarf von fsck verbessern -- vorausgesetzt, dass du sie
wirklich nicht benötigst.

<p>
Falls du mehrere Platten in deinem System hast denke bitte daran, dass
nach einem Absturz alle Platten gleichzeitig mit fsck(8) überprüft
werden, sodass deutlich mehr RAM pro Platte benötigt wird.

<h3>FFS gegen FFS2</h3>
Mit FFS unterstützt OpenBSD ein individuelles Dateisysteme von bis zu
2<sup>31</sup>-1 oder 2.147.483.647 Blocks, und da jeder Block 512 Byte groß
ist, ist dies ein bisschen weniger als 1&nbsp;TB.
FFS2 ist in der Lage, deutlich größere Dateisysteme zu unterstützen,
obwohl andere Grenzen längst erreicht sind, bevor das Dateisystem voll
ausgereizt ist.

<p>
Der Boot-/Installationskernel <i>unterstützt nur FFS</i> (kein FFS2),
sodass wichtige Systempartitionen (<tt>/, /usr, /var, /tmp</tt>) nicht
mit FFS2 formatiert werden sollten, da ansonsten Wartungsprobleme
auftreten könnten (es sollte ohnehin keinen Grund geben, warum diese
Partitionen so riesig sein sollten). Deshalb sollten sehr große
Partitionen nur für Partitionen wie <tt>/home, /var/www, /bigarray</tt>
etc. genutzt werden, die nicht entscheidend für das System sind.

<p>
Beachte, dass nicht alle Controller und Laufwerke große Platten
unterstützten. <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ami&amp;sektion=4"
>ami(4)</a> zum Beispiel unterstützt maximal 2&nbsp;TB pro logischem
Volumen.
Sei dir immer bewußt, was verfügbar war, wenn ein Kontroller oder eine
Schnittstelle produziert wurde, und verlasse dich nicht auf »die Stecker
passen«.

<p>
<h3>Laufwerke größer als 2&nbsp;TB</h3>
Das MBR-System, das auf PCs genutzt wird, versteht sich nur im Umgang mit
Laufwerken von bis zu 2&nbsp;TB Größe.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8"
>fdisk(8)</a> zeigt die Größe von Laufwerken größer 2&nbsp;TB als 2&nbsp;TB an.
Dies behindert in keinster Weise OpenBSD's Fähigkeit, größere Laufwerke nutzen
zu können, da der MBR nur benutzt wird, um das Betriebssystem urzuladen; ist
jedoch das Betriebssystem einmal in Betrieb, so werden die Dateisysteme durch
das »disklabel« definiert, welches kein 2&nbsp;TB Limit besitzt.

<p>
Um ein Laufwerk zu nutzen, das größer als 2&nbsp;TB ist, erzeuge auf dem
Laufwerk eine OpenBSD-Partition mit Hilfe von fdisk, und zwar in der Größe, die
dir fdisk ermöglicht.
Kennzeichnest du dann das Laufwerk mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a>, so nutze die Option "b", um die OpenBSD-Grenzen
(die standardmäßig auf die Größe der OpenBSD-fdisk-Partition eingestellt sind)
so zu definieren, dass sie das gesamte Laufwerk einschließen.
Nun kannst du deine Partitionen genauso erzeugen, wie du es wünschst.
Allerdings musst du natürlich die Möglichkeiten deines BIOS respektieren, dass
die Einschränkung haben wird, einzig die fdisk-Partitionen zu verstehen, sodass
deine Partition "a" komplett innerhalb der von fdisk verwalteten Bereiche des
Laufwerks liegen sollte, zusätzlich zu anderen Einschränkungen des BIOS.

<p>
<a name="InstBoot"></a>
<h2>14.9 - Installieren von Bootblocks - i386/amd64-spezifisch</h2>

<p>
OpenBSD besitzt ein sehr robustes Systemladeprogramm (»Bootloader«), das
recht gleichgültig gegenüber verschiedenen Laufwerksgeometrien ist,
allerdings ist es hochsensibel gegenüber der Position von
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>/boot</a></tt> auf der Festplatte. Falls du Änderungen durchführst,
die boot(8) auf der Platte verschieben (tatsächlich oder nur eine neue
I-Node), so wirst du dein System »beschädigen« - es wird nicht mehr
hochfahren.
Um den »Bootblock« zu reparieren, sodass du einen normalen Systemstart
durchführen kannst, lege einfach eine startbare CD-ROM in dein Laufwerk (oder
nutze eine startbare Diskette), und gib am Bootprompt »<tt>boot hd0a:/bsd</tt>«
ein, um den Systemstart von der ersten Festplatte (nicht der CD-ROM oder der
Diskette) zu erzwingen.
Deine Maschine sollte normal starten.
Nun musst du den Firststage-Bootloader
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>) basierend auf der neuen Position von <tt>/boot</tt>
erneut installieren, indem du das Programm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386"
>installboot(8)</a> aufrufst.

<p>
In unserem Beispiel gehen wird davon aus, dass du von sd0
bootest (für IDE wäre es wd0 etc.).

<blockquote><pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre></blockquote>

Beachte, da dass Dateisystem im Moment eingehängt ist, dass »/boot« die
physische Position der Datei »boot« ist, die du benutzen möchtest, wenn das
System normal startet.
Wäre deine Situation ein wenig anders, und hättest du von CD-ROM gestartet und
deine Partition »a« unter /mnt eingehängt, so würde dies stattdessen
wahrscheinlich »/mnt/boot« sein.
installboot(8) macht hier zwei Dinge - es installiert die Datei »biosboot«
dahin, wo es im »Partition Boot Record« stehen muss, und modifiziert es für die
tatsächlichen physischen Position der Datei «/boot«.

<a name="Backup"></a>
<h2>14.10 - Vorbereitung auf Katastrophen -
Erzeugen von Backups und Wiederherstellung vom Band.</h2>

<h3>Einführung:</h3>

<p>
Wenn du so etwas wie einen Produktionsserver laufen lassen willst, ist
es ratsam, irgendeine Form des Backups für den Fall zu haben, dass eine
deiner Festplatten ausfällt, oder die Daten aus einem anderen Grund verloren
sind.

<p>
Diese Information wird dir helfen, die Standardwerkzeuge
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
zu benutzen, die als Teil von OpenBSD ausgeliefert werden.
Fortgeschrittenere Backup-Dienstprogramme, wie
»<a href="http://www.amanda.org">Amanda</a>« und
»<a href="http://www.bacula.org">Bacula</a>« sind als
<a href="faq15.html#PkgMgmt">Pakete</a> verfügbar, um mehrere Sever auf
Festplatte und Bandlaufwerk zu sichern.

<h3>Backup aufs Band bringen:</h3>

<p>
Um sein Backup auf ein Band zu bringen, muss man wissen, wo die
Dateisysteme gemountet sind. Das findet man mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)"</a>-Kommando
am Shellprompt heraus. Dabei sollte eine Ausgabe wie diese
herauskommen:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a,
was ein SCSI-ähnliches, wahrscheinlich fest installiertes Laufwerk 0, Partition
a indiziert.
Das Dateisystem /usr befindet sich auf sd0h, was ein SCSI-ähnliches,
wahrscheinlich fest installiertes Laufwerk 0, Partition h indiziert.

<p>
Ein weiteres Beispiel einer etwas größeren Mounttabelle könnte so
aussehen:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
In diesem fortgeschritteneren Beispiel befindet sich das root- (/)
Dateisystem auf sd0a. Das /var-Dateisystem befindet sich auf sd0d, das
/home-Dateisystem auf sd0e und schlussendlich /usr auf sd0h.

<p>
Um ein Backup deiner Maschine zu machen, musst du dump mit jeder
festgelegten Partition füttern. Hier ist ein Beispiel der Kommandos, um
die einfachere Mounttabelle weiter oben zu sichern:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Für die etwas fortgeschrittenere Mounttabelle würde man etwas wie das
hier benutzen:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Du kannst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>-Handbuchseite
ansehen, um genau zu erfahren, was jede Kommandozeilenoption macht. Hier
ist eine kurze Übersicht der Parameter, die oben verwendet wurden:

<ul>
<li><b>0</b> - Führe einen Level-0-Dump durch - hole alles
<li><b>a</b> - Versuche automatisch die Bandlänge herauszufinden
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand,
um zu reflektieren, wann die letzte Sicherung gemacht wurde
<li><b>f</b> - Welches Bandlaufwerk benutzt werden soll (/dev/nrst0 in
diesem Fall)
</ul>

<p>
Zuletzt welche Partition gesichert werden soll (/dev/rsd0a usw.)

<p>
Das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
wird am Ende benutzt, um das Band zurückzuspulen. Sieh dir die
mt-Handbuchseite an, wenn du mehr Informationen haben willst (wie etwa
eject).

<p>
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heißt, benutze
einfach dmesg, um das herauszufinden. Ein Beispieleintrag von dmesg für
ein Bandlaufwerk könnte so aussehen:

<blockquote><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></blockquote>

<p>
Du hast vielleicht bemerkt, dass bei der Sicherung das Bandlaufwerk als
<tt>nrst0</tt> anstatt von <tt>st0</tt> bezeichnet wird, wie man es
in dmesg sieht. Wenn du auf <tt>st0</tt> statt <tt>nrst0</tt> zugreifst,
benutzt du das selbe physikalische Gerät, sagst ihm aber, dass es nicht
zurückspulen soll, nachdem der Job im raw-Modus beendet wurde. Um
mehrere Dateien auf ein einziges Band zu sichern, stelle sicher, dass du
nicht zurückspulst - sprich das richtige Gerät (<tt>rst0</tt>) benutzt -
ansonsten wirst du mit der zweiten Sicherung die erste überschreiben
usw. Du findest in der Handbuchseite zu dump eine ausführlichere
Beschreibung.

<p>
Wenn du ein kleines Skript namens backup schreiben würdest, könnte es
z.&nbsp;B. so aussehen:

<blockquote><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre></blockquote>

<p>
Wenn regelmäßige nächtliche Backups gefordert sind, könnte man
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
benutzen, um das Backup jede Nacht automatisch zu starten.

<p>
Es ist außerdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie
groß jedes Dateisystem sein muss. Du kannst »<tt>df -h</tt>« benutzen,
um herauszufinden, wie viel Platz jede Partition momentan verbraucht. Das
ist dann nützlich, wenn eine Platte versagt und du die Partitionstabelle
auf der neuen Platte wieder erstellen musst.

<p>
Deine Daten wiederherzustellen hilft außerdem noch gegen Fragmentierung.
Der beste Weg, um sicherzustellen, dass du alle Dateien erwischst, ist
es, im Singleuser-Modus zu booten. Dateisysteme müssen nicht gemountet
werden, um gesichert zu werden. Vergiss aber nicht, root (/) zu mounten,
denn sonst wird dein dump versagen, wenn er versucht, Dumpdaten zu
schreiben. Gib einfach »<tt>bsd -s</tt>« am boot&gt;-Prompt ein, um in
den Singleuser-Modus zu gelangen.

<h3>Den Inhalt eines dump-Bandes ansehen:</h3>


<p>
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es
sicher eine gute Idee, dein Band zu testen und sicherzustellen, dass es
auch die Daten enthält, die darauf sein sollen.

<p>
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien
auf einem dump-Band zu erhalten:

<blockquote><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></blockquote>

<p>
Das listet die Dateien auf der 1. Partition des dump-Bandes (des
Sicherungsbands) auf. Wie in den Beispielen weiter oben ist 1 dein root-
(/) Dateisystem.

<p>
Um den Inhalt der 2. Partition zu sehen und die Ausgabe in eine Datei
umzulenken, würde man z.&nbsp;B. solch ein Kommando benutzen:

<blockquote><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></blockquote>

<p>
Wenn du eine Mounttabelle wie die oben aufgeführte hättest, wäre 2 /usr
- wenn deine aber etwas größer wäre, könnte 2 auch /var sein oder
irgendwas anderes. Die Sequenznummer unterliegt auf jeden Fall der
gleichen Reihenfolge, mit der das Dateisystem auf das Band gesichert
wurde.


<h3>Wiederherstellen vom Band:</h3>

<p>
Das Beispielszenario wäre sinnvoll, wenn deine eigentliche Festplatte
komplett ausgefallen wäre. Falls du aber nur eine einzige Datei
wiederherstellen willst, sieh dir die restore-Handbuchseite genau an und
achte besonders auf die Anweisungen für den interaktiven Modus.

<p>
Wenn du gut vorbereitet bist, kann der Prozess des Ersetzens einer
Festplatte sehr schnell von statten gehen. Die normale
OpenBSD-Installations/Bootdiskette enthält bereits das benötigte
restore-Werkzeug genauso wie die ausführbaren Dateien, um neue
Partitionen zu erstellen und deine Festplatte bootbar zu machen. In
den meisten Fällen sind diese Disketten und dein Sicherungsband alles,
was du brauchst, um wieder alles betriebsbereit zu bekommen.

<p>
Nachdem du das kaputte Laufwerk physikalisch ersetzt hast, sind die
grundlegenden Schritte zur Wiederherstellung folgende:

<ul>
<li>
<p>
Boote von der OpenBSD-Installations/Bootdiskette. Wähle Shell aus dem
Menü aus. Nimm dein neuestes und schreibgeschütztes Band und lege es in
dein Laufwerk ein.
<br>
<li>
<p>
Benutze das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Kommando,
um eine primäre OpenBSD-Partition auf dieser neu installierten
Festplatte zu erzeugen. Beispiel:

<blockquote><pre>
# <b>fdisk -e sd0</b>
</pre></blockquote>

<p>
Sieh einfach in die <a href="#fdisk">fdisk-FAQ</a>, um genaueres zu
erfahren.

<li>
<p>
Mit dem disklabel-Kommando stellst du dann deine
OpenBSD-Partitionstabelle in der primären OpenBSD-Partition wieder her,
die du gerade mit fdisk erzeugt hast. Beispiel:

<blockquote><pre>
# <b>disklabel -E sd0</b>
</pre></blockquote>

<p>
(Vergiss den Swap nicht; siehe dazu die
<a href="#disklabel">disklabel-FAQ</a> für weitere Informationen)

<li>
<p>
Benutze das newfs-Kommando, um ein neues sauberes Dateisystem auf jeder
Partition zu erstellen, die du mit den oben aufgeführten Schritten
erstellt hast. Beispiel:

<blockquote><pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre></blockquote>

<li>
<p>
Mounte dein neu vorbereitetes root- (/) Dateisystem auf /mnt. Beispiel:

<blockquote><pre>
# <b>mount /dev/sd0a /mnt</b>
</pre></blockquote>

<li>
<p>
Wechsel in das gemountete root-Dateisystem und beginne mit dem
Wiederherstellungsprozess. Beispiel:

<blockquote><pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre></blockquote>

<li>
<p>
Wenn die Platte bootbar sein soll, schreibe mit dem folgenden Befehl
einen neuen MBR auf deine Festplatte. Beispiel:

<blockquote><pre>
# <b>fdisk -i sd0</b>
</pre></blockquote>

<li>
<p>
Zusätzlich zum Schreiben eines neuen MBR musst du Bootblöcke
installieren, um von ihr booten zu können. Das Folgende ist ein
kurzes Beispiel:

<blockquote><pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></blockquote>

<li>
<p>
Dein neues root-Dateisystem auf der eingebauten Festplatte sollte jetzt
fertig sein, sodass du davon booten und damit beginnen kannst, den Rest
der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht
komplett ist, solltest du alles im Singleuser-Modus wiederherstellen.
Benutze die folgenden Kommandos am Shellprompt, um deine Festplatten
zu unmounten und das System anzuhalten:

<blockquote><pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre></blockquote>

<li>
<p>
Entferne die Installations/Bootdiskette aus dem Laufwerk und starte
dein System neu. Benutze das folgende Kommando am
OpenBSD-boot&gt;-Prompt:

<blockquote><pre>
boot&gt; <b>bsd -s</b>
</pre></blockquote>

<p>
Das bsd -s führt dazu, dass der Kernel im Singleuser-Modus gestartet
wird, der nur ein root- (/) Dateisystem braucht.

<li>
<p>
Unter der Annahme, dass du die obigen Schritte richtig ausgeführt hast
und nichts schief gegangen ist, solltest du von einem Prompt begrüßt
werden, der dich nach einem Pfad zu einer Shell fragt, oder du Return
drücken sollst. Drücke Return, um die sh zu benutzen. Als nächstes
willst du sicherlich root im Lese/Schreibmodus (rw) remounten und nicht
mehr im schreibgeschützten Modus benutzen (ro). Dazu benutze
Folgendes:

<blockquote><pre>
# <b>mount -u -w /</b>
</pre></blockquote>

<li>
<p>
Sobald du im Lese/Schreibmodus remountet hast kannst du fortfahren,
deine restlichen Dateisysteme wiederherzustellen. Beispiel:

<blockquote><pre>
<i>(einfache Mounttabelle)</i>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

<i>(umfassendere Mounttabelle)</i>
#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></blockquote>

<p>
Benutze »<b>restore rvsf</b>« statt eines einfachen rsf, um die Namen
von Objekten zu sehen, während sie vom dump-Set ausgepackt werden.

<li>
<p>
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme
wiederhergestellt hast, führe einen Neustart in den Multiuser-Modus
durch. Wenn alles geklappt hat, sollte dein System wieder genau so
sein, wie zum Zeitpunkt deiner letzten Sicherung, und bereit, wieder
eingesetzt zu werden.
</ul>

<a name="MountImage"></a>
<h2>14.11 - Laufwerksabbilder in OpenBSD einhängen</h2>

<p>
Um ein Laufwerks-Abbild (ISO-Abbild, Abbilder, die mit dd erstellt wurden
etc.) unter OpenBSD einzuhängen (zu »mounten«), musst du ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4"
>vnd(4)</a>-Gerät konfigurieren.
Zum Beispiel, wenn du ein ISO-Abbild unter <i>/tmp/ISO.image</i> hast, würdest
du die folgenden Schritte gehen, um es einzuhängen:

<blockquote><pre>
# <b>vnconfig vnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/vnd0c /mnt</b>
</pre></blockquote>

<p>
Bedenke bitte, dass du den Typ <i>cd9660</i> angeben musst, wenn es
eine CD ist. Das gilt aber auch für die anderen Typen. Du musst also
z.&nbsp;B. <i>ext2fs</i> beim Mounten eines Linux-Diskimages angeben.

<p>
Um das Abbild wieder auszuhängen, benutze die folgenden Kommandos.

<blockquote><pre>
# <b>umount /mnt</b>
# <b>vnconfig -u vnd0</b>
</pre></blockquote>

<p>
Mehr Informationen gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>-Handbuchseite.

<p>
<a name="pciideErr"></a>
<h2>14.12 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</h2>

<p>
DMA-IDE-Übertragungen, die durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4"
>pciide(4)</a> unterstützt werden, sind in vielen Konfigurationen alter
Hardware unzuverlässig.

<p>
OpenBSD ist aggressiv und versucht, den höchsten DMA-Modus zu benutzen,
den es konfigurieren kann. Dies führt in einigen Konfigurationen zu
Datenkorruptionen aufgrund von defekten Motherboardchipsets,
fehlerhaften Treibern, die Probleme verursachen und/oder Lärm auf den
Kabeln. Glücklicherweise schützt Ultra-DMA die Datenübertragungen mit
einem CRC, um Korruptionen zu entdecken. Falls ein Fehler bei einem
solchen Ultra-DMA CRC geschieht, wird OpenBSD eine Fehlermeldung
ausgeben und erneut versuchen, die Daten zu übertragen.

<blockquote><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></blockquote>

<p>
Nach ein paar Fehlversuchen wird OpenBSD zu einem langsameren (und damit
hoffentlich zuverlässigeren) DMA-Modus herunterschalten. Nach den
Ultra-DMA-Modi wird dann zu einem PIO-Modus heruntergeschaltet.

<p>
UDMA-Fehler werden meistens durch minderwertige oder beschädigte Kabel
verursacht. Kabelprobleme sollten normalerweise zuerst in Betracht
gezogen werden, wenn du viele DMA-Fehler oder unerwartet niedrige
DMA-Leistung erhältst. Es ist ebenfalls eine schlechte Idee, das CD-ROM
an den gleichen Kanal wie die Festplatte zu stecken.

<p>
Wenn das Ersetzen der Kabel nicht zur Lösung des Problems führt und
OpenBSD nicht erfolgreich herunterschaltet oder der Prozess zu einem
Einfrieren deiner Maschine führt, möchtest du vielleicht dein System
auf einen niedrigeren DMA- oder UDMA-Level standardmäßig begrenzen.
Dies kann unter Verwendung von <a href="faq5.html#BootConfig">UKC</a>
oder <a href="faq5.html#config">config(8)</a> realisiert werden, indem
man die Optionen des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>-Devices
ändert.

<p>
<a name="NegSpace"></a>
<h2>14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich mehr als 100&nbsp;%
von meinem Laufwerk belegt habe?</h2>
Leute sind manchmal erstaunt darüber, herausfinden zu müssen, dass sie
<i>negativen</i> verfügbaren Plattenspeicher haben oder mehr als
100&nbsp;% eines Dateisystems in Verwendung ist, wie es von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>
angezeigt wird.

<p>
Wenn ein Dateisystem mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
erstellt wird, wird ein Teil des verfügbaren Speichers vor den normalen
Benutzern in Reserve gehalten. Dies stellt einen Spielraum für Fehler
bereit, wenn du versehentlich die Platte füllst und hilft, die
Plattenfragmentierung auf einem Minimum zu halten. Standardwert hierfür
ist 5&nbsp;% der Plattenkapazität, sodass, falls der
Systemadministrator sorglos die Platte auffüllt, du bis zu 105&nbsp;%
Speicher sehen kannst, der verwendet wird.

<p>
Wenn der 5-%-Wert für dich nicht angemessen erscheint, kannst du ihn mit
dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>
ändern.

<p>
<a name="OhBugger"></a>
<h2>14.15 - Partitionen wiederherstellen, nachdem das Disklabel gelöscht
wurde</h2>

<p>
Wenn du eine Partitionstabelle beschädigt hast, gibt es einige Dinge,
die du versuchen kannst, um sie wiederherzustellen.

<p>
Zu aller erst Panik. Das würde sowieso passieren - aber dann hast du
es jedenfalls hinter dir. Mach einfach nichts Unvernünftiges. Halte
deine Panik von der Maschine fern. Dann entspanne dich und guck, ob dir
die unten stehenden Schritte vielleicht weiterhelfen.

<p>
Eine Kopie des Disklabels wird für jede Platte als Teil der täglichen
Systemverwaltung unter <tt>/var/backups</tt> gespeichert. Angenommen,
dass du die var-Partition weiterhin hast, kannst du einfach die Ausgabe
lesen und sie zurück in das Disklabel schreiben.

<p>
Falls du die Partition nicht mehr sehen kannst, gibt es zwei
Möglichkeiten. Behebe genug Fehler der Platte, bis du sie sehen kannst
oder behebe genug Fehler der Platte, um deine Daten von ihr zu bekommen.

Abhängig davon, was passiert ist, könnte der eine oder ein anderer
Weg bevorzugt sein (mit sterbenden Platten, von denen du zuerst
die Daten haben willst, könntest du mit schlampigen Fingern nur das
Label bekommen).

<p>

Das erste Werkzeug, das du brauchst, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(achte auf den Unterstrich, es wird nicht »scanffs« genannt).
Das Werkzeug scan_ffs(8) durchsucht die Platte und versucht,
Partitionen zu finden, und teilt dir die Informationen mit, die es über
sie herausgefunden hat. Du kannst diese Informationen nutzen, um das
Disklabel neu zu erstellen. Wenn du einfach nur <tt>/var</tt>
zurückhaben willst, kannst du die Partition für <tt>/var</tt> wieder
erstellen und dann das gesicherte Label nutzen, um den Rest von diesem
aus zu erstellen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
wird sowohl die Erkenntnis des Kernels über das Disklabel erneuern
als auch versuchen, das Label auf die Platte zu schreiben.
Selbst wenn der Bereich der Platte, in dem das Disklabel liegt, nicht
lesbar ist, wirst du trotzdem in der Lage sein, bis zum nächsten
Neustart
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
aufzurufen.

<p>
<a name="foreignfs"></a>
<h2>14.16 - Kann ich auf Daten zugreifen, die auf anderen Dateisystemen
als FFS liegen?</h2>
<!-- This article written by Steven Mestdagh,
steven@@openbsd.org, and released under the BSD license -->

Ja. Andere unterstützte Dateisysteme sind unter anderem: ext2 (Linux),
ISO9660 und UDF (CD-ROM-, DVD-Medien), FAT (MS-DOS und Windows), NFS,
NTFS (Windows).
Einige von ihnen haben eingeschränkte - zum
Beispiel nur schreibgeschützte - Unterstützung.

<p>
Wir werden hier einen allgemeinen Überblick darüber geben, wie man eines
dieser Dateisysteme unter OpenBSD verwendet. Um in der Lage zu sein, ein
Dateisystem zu benutzen, muss es gemountet sein. Für Details und
Optionen für mount, konsultiere bitte die Handbuchseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
und die Handbuchseite zum mount-Kommando für das Dateisystem, das du
mounten möchtest, z.&nbsp;B. mount_msdos, mount_ext2fs,&nbsp;...

<p>
Zu aller erst musst du wissen, auf welchem Device sich dein Dateisystem
befindet. Vielleicht einfach deine erste Festplatte (<tt>wd0</tt> oder
<tt>sd0</tt>), es könnte aber auch weniger offensichtlich sein.
Alle erkannten und konfigurierten Devices deines Systems werden in der
Ausgabe vom Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
aufgeführt: ein Devicename, gefolgt von einer einzeiligen Beschreibung
des Devices. Mein erstes CD-ROM-Laufwerk wird beispielsweise wie folgt
erkannt:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Du kannst
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
verwenden, um eine viel kürzere Liste der verfügbaren Platten zu
erhalten. Das Kommando

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

wird alle Platten anzeigen, die deinem System momentan bekannt sind,
z.&nbsp;B.:

<blockquote><pre>
hw.disknames=cd0:,cd1:,wd0:,fd0:,cd2:
</pre></blockquote>

<p>
An diesem Punkt angekommen ist es Zeit dafür, herauszufinden, welche
Partitionen sich auf dem Device befinden, und auf welcher Partition das
gewünschte Dateisystem liegt. Daher untersuchen wir das Device mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Das Disklabel beinhaltet eine Liste, die aus maximal 16 Partitionen
besteht. Partition c steht immer für das gesamte Device. Partitionen
a - b und d - p werden von OpenBSD genutzt. Partitionen i - p können
automatisch für Dateisysteme anderer Betriebssysteme allokiert werden.
In diesem Fall werde ich mir das Disklabel meiner Festplatte betrachten,
welches eine Anzahl verschiedener Dateisysteme beinhaltet.

<p>
<b>HINWEIS: OpenBSD wurde nach allen anderen Betriebssystemen
installiert</b> und während der Installation wurde ein Disklabel
erstellt, das alle Partitionen der nativen als auch der anderen
Dateisysteme enthält, die sich auf der Platte befanden. Wenn du jedoch
andere Dateisysteme installiert nachdem das OpenBSD-Disklabel bereits
auf der Platte installiert wurde, musst du sie nachträglich manuell
hinzufügen oder ändern. Dies wird in <a href="#foreignfsafter">diesem
Unterkapitel</a> behandelt.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A       
duid: d920a43a5a56ad5f
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
boundstart: 20338290
boundend: 49656915
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # /
  b:       1638000      20746656    swap
  c:      78165360             0  unused
  d:       4194288      22384656  4.2BSD   2048 16384   16 # /usr
  e:        409248      26578944  4.2BSD   2048 16384   16 # /tmp
  f:      10486224      26988192  4.2BSD   2048 16384   16 # /var
  g:      12182499      37474416  4.2BSD   2048 16384   16 # /home
  i:         64197            63 unknown
  j:      20274030         64260 unknown
  k:       1975932      49656978   MSDOS
  l:       3919797      51632973 unknown
  m:       2939832      55552833  ext2fs
  n:       5879727      58492728  ext2fs
  o:      13783707      64372518  ext2fs 

</pre></blockquote>

<p>
Wie du in dieser Ausgabe erkennen kannst, werden die OpenBSD-Partitionen
zuerst aufgelistet. Nach diesen werden einige ext2-Partitionen und
eine MSDOS-Partition aufgelistet, sowie ein paar unbekannte (unknown)
Partitionen. Auf i386- und amd64-Systemen kannst du mehr über diese
unter Verwendung des Werkzeugs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
in Erfahrung bringen.
Für den neugierigen Leser: Partition i ist eine Wartungspartition, die
vom Hersteller erzeugt wurde, Partition j ist eine NTFS-Partition und
Partition l ist eine Swappartition für Linux.

<p>
Sobald du herausgefunden hast, welche dieser Partitionen die ist, die du
benutzen möchtest, kannst du den letzten Schritt durchführen: das
Dateisystem, das sich auf dieser befindet, mounten. Die meisten
Dateisysteme werden vom GENERIC-Kernel unterstützt: Wirf einfach einen
Blick in die Kernelkonfigurationsdatei, die sich im Verzeichnis
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt> befindet.
Wenn du eines der Dateisysteme nutzen möchtest, die nicht in GENERIC
unterstützt werden, musst du <a href="faq5.html#Options">einen
angepassten Kernel erzeugen</a>.

<p>
Wenn du die Informationen auf zuvor beschriebene Weise gesammelt hast,
ist es nun an der Zeit, das Dateisystem zu mounten.
Lass uns annehmen, dass ein Verzeichnis namens <tt>/mnt/otherfs</tt>
existiert, welches wir als Mountpunkt nutzen werden, unter dem wir das
gewünschte Dateisystem mounten werden.
In diesem Beispiel werden wir das ext2-Dateisystem von Partition m
mounten:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

<p>
Wenn du vorhast, dieses Dateisystem regulär zu nutzen, kannst du etwas
Zeit sparen, indem du eine Zeile in <tt>/etc/fstab</tt> schreibst; zum
Beispiel etwas wie:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Beachte den Wert 0 im fünften und sechsten Feld. Diese bedeuten, dass
wir nicht möchten, dass die Dateisysteme mit dump gesichert oder unter
Verwendung von fsck überprüft werden. Generell gilt, dass du solche
Aufgaben eher mit dem dazugehörigem Betriebssystem machen möchtest.

<p>
<a name="foreignfsafter"></a>
<h3>14.16.1 - Die Partitionen sind nicht in meinem Disklabel verzeichnet!
Was kann ich tun?</h3>

Wenn du andere Dateisysteme auf deinem System angelegt hast (resultiert
meist aus der Installation eines anderen Betriebssystems) nachdem du
OpenBSD bereits installiert hast, wird ein Disklabel bereits vorliegen
und nicht automatisch aktualisiert, sodass es die neuen fremden
Dateisystempartionen enthielte. Wenn du diese verwenden möchtest,
dann musst du diese Partitionen manuell unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
hinzufügen oder editieren.

<p>
Beispielsweise habe ich eine meiner bestehenden ext2fs-Partitionen
geändert: Unter Verwendung von Linux' fdisk-Programm habe ich die
Größe der o-Partition (siehe die Disklabelausgabe weiter oben) auf 1 G
reduziert. Wir können dies leicht sehen, indem wir einen Blick auf die
Startposition (Offset: 64372518) und die Größe (13783707) werfen.
Beachte, dass diese Werte Sektornummern und dass die Verwendung von
Sektornummern (nicht Megabyte oder ein anderes Maß) die genaueste
Angabe ist und der sicherste Weg, um diese Informationen zu lesen.

<p>
Vor dem Ändern sah die Partition wie diese aus (Ausgabe von OpenBSDs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Werkzeug
[nur die wichtigen Informationen werden hier angegeben]):

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Wie du sehen kannst sind die Startposition und die Größe genau so, wie
sie zuvor von disklabel(8) angegeben wurden. (Sei jetzt nicht wegen dem
Wert verwirrt, der als Offset angegeben wird: der Wert bezieht sich auf
die Startposition der erweiterten Partition, in der sich die
ext2-Partition befindet.)

<p>
Nachdem die Partitionsgröße unter Linux geändert wurde, sieht sie wie
folgt aus:

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Dies muss nun unter Verwendung von disklabel(8) geändert werden.
Zum Beispiel kannst du <tt>disklabel -e wd0</tt> aufrufen, womit du
einen Editor startest, der mit der Umgebungsvariable EDITOR (Standard
ist vi) angegeben wird. Ändere mit diesem Editor die Zeile des
Disklabels, um diese auf die neue Größe anzupassen:

<blockquote><pre>
  o:       2104452      64372518  ext2fs
</pre></blockquote>

Schreibe das Disklabel auf die Platte, wenn du fertig bist. Nun, da das
Disklabel wieder aktuell ist, solltest du in der Lage sein, die
Partitionen wie oben beschrieben wieder mounten zu können.

<p>
Du kannst einen sehr ähnlichen Prozess ausführen, um neue Partitionen
hinzuzufügen.

<p>
<a name="flashmem"></a>
<h2>14.17 - Kann ich ein Flash-Speicher-Gerät mit OpenBSD benutzen?</h2>
<a name="flashmemPortable"></a>
<h3>14.17.1 - Flash-Speicher als portables Speichergerät</h3>
<!-- This article written by Steven Mestdagh,
steven@@openbsd.org, and released under the BSD license -->

Normalerweise sollte ein Speichergerät erkannt werden, wenn es an eine
Schnittstelle deiner Maschine angeschlossen wird. Kurz nach dem
Anschließen werden einige Nachrichten auf der Konsole des Kernels
angezeigt. Wenn ich zum Beispiel meinen USB-Flashspeicher anschließe,
sehe ich Folgendes auf meiner Konsole:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Diese Zeilen deuten darauf, dass der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>-
(USB-Massenspeicher-) Treiber an das Speichergerät angehängt wurde und
dass es das SCSI-System nutzt. Die beiden letzten Zeilen sind die
wichtigsten: Sie sagen, an welche Gerätedatei das Speichergerät
angehängt wurde, und wie groß der gesamte Speicherplatz ist.
Wenn du diese Zeilen - warum auch immer - verpasst haben solltest,
kannst du sie nachträglich mit dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
betrachten. Die angegebene CHS-Geometrie ist eine fiktive, da der
Flashspeicher wie eine normale SCSI-Platte verarbeitet wird.

<p>
Wir werden nun zwei Szenarien besprechen.

<h4>Das Gerät ist neu/leer und du möchtest es nur mit OpenBSD nutzen</h4>

Du musst ein Disklabel und mindestens eine Partition auf diesem Gerät
erstellen. Bitte lies <a href="#disklabel">OpenBSDs disklabel
verwenden</a> und die Handbuchseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
für Details hierüber.

<p>
In diesem Beispiel habe ich nur die Partition <i>a</i> erstellt, auf
der ich ein FFS-Dateisystem erstellen werde:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Lass uns das Dateisystem, das wir auf der Partition <i>a</i> erstellt
haben, unter <tt>/mnt/flashmem</tt> mounten.
Erstelle zuerst einen Mountpunkt, wenn er noch nicht existiert.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h4>Du hast das Speichergerät von jemandem erhalten, mit dem du Daten
austauschen möchtest</h4>

<p>
Möglicherweise wird diese andere Person nicht OpenBSD nutzen, sodass
sich ein fremdes Dateisystem auf diesem Speichergerät befinden kann.
Daher müssen wir zuerst alle Partitionen auf diesem Gerät finden, so
wie es in <a href="#foreignfs">FAQ 14 - Fremde Dateisysteme</a>
beschrieben steht.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Wie man in der Ausgabe von disklabel sehen kann, gibt es nur eine
Partition names <i>i</i>, das ein FAT-Dateisystem beinhaltet, das von
einer Windows-Maschine erstellt wurde. Wie gewöhnlich stellt die
Partition <i>c</i> das gesamte Gerät dar.

<p>
Lass uns nun das Dateisystem auf der Partition <i>i</i> unter
<tt>/mnt/flashmem</tt> mounten.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Nun können wir damit beginnen, es wie jede andere Platte anzusprechen.

<p>
<b>WARNUNG:</b>
Du solltest das Dateisystem <b>vor dem Herausziehen</b> des Geräts
<b>immer erst unmounten</b>.
Wenn du das nichts tust, könnte das Dateisystem in einem nicht
konsistenten Zustand zurückgelassen werden, was im schlimmsten Fall
Datenverlust bedeutet.

<p>
Nach dem Entfernen des Speichergeräts von deiner Maschine wirst du
wieder sehen, dass der Kernel Meldungen hierüber auf der Konsole
ausgibt:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<a name="flashmemBoot"></a>
<h3>14.17.2 - Flash-Speicher als startbarer Speicherplatz</h3>
<!-- This article written by Nick Holland
nick@@openbsd.org, and released under the BSD license -->
Man kann ebenfalls Flash-Speicher in vielfacher Form als startbares Laufwerk
mit OpenBSD benutzen.
Dies kann sowohl mit USB-Geräten (vorausgesetzt dein Computer kann von einem
USB-Flash-Speicher-Gerät starten, was nicht für alle gilt), als auch mit
nicht-USB-Geräten (z.&nbsp;B. »CompactFlash«) mit einem IDE- oder SATA-Adapter
geschehen.
(Nicht-USB-Geräte, die an einen USB-Adapter angeschlossen sind, werden als
USB-Geräte behandelt.)
In einigen Fällen kann man das Gerät auf beide Arten nutzen (laden des Mediums
mit einem USB-Adapter, laufenlassen mit einem IDE-Adapter).

<p>
Ein Flash-Gerät, das an einen USB-Anschluss angeschlossen wird, taucht als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4"
>sd(4)</a> SCSI-ähnliches Gerät auf.
Wird es an einen IDE-Adapter angeschlossen, so tauch es als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4"
>wd(4)</a>-Gerät auf.

<p>
In dem Fall, dass das Flash-Medium über einen IDE-Adapter angeschlossen wird,
kann man von ihm jedes System starten, dass von einer IDE-Festplatte über
denselben Adapter starten könnte.
Das System betrachtet dieses Flash-Medium in jeder Hinsicht als IDE-Laufwerk.
Konfiguriere einfach deine Hardware entsprechend, und OpenBSD wird sich ganz
normal auf das Flash-Laufwerk installieren.

<p>
In dem Fall des Startens von einem USB-Gerät muss das System in der Lage sein,
von einem USB-Gerät starten zu können, ohne von anderen Geräten des Systems
abgelenkt zu werden.
Beachte das, sollte deine Intention sein, eine portable Systemstart-Umgebung
auf einem USB-Gerät zu kreieren, du wirklich <a href="#DUID">DUIDs</a> anstatt
der traditionellen »<tt>/dev/sd0X</tt>«-Notation benutzen solltest.
Das USB-Gerät wird als SCSI-Laufwerk auftauchen, manchmal sd0.
Ohne DUIDs wird es, wenn du es an ein Gerät anschließt, das bereits einige
SCSI-ähnliche Laufwerke (d.&nbsp;h. Geräte, die an eine ahci(4)-Schnittstelle
angeschlossen sind) aufweist, wahrscheinlich mit einer anderen Kennzeichnung
registriert werden, was das Übertragen des Flash-Geräts von System zu System
verkompliziert, da <tt>/etc/fstab</tt> entsprechend angepaßt werden muss.
Die Benutzung von DUIDs beseitigt diesen Problembereich.

<p>
Einige Anmerkungen:
<ul>
<li><b>Geschwindigkeit:</b> Generell sind Flash-Geräte viel langsamer als
Festplatten, besonders hinsichtlich des Schreibens von Daten.
Das Benutzen von »<a href="#SoftUpdates">Soft-Updates</a>« hilft hier
beachtlich, ebenso wie die mount-Option »noatime«.

<li><b>»Schreibmüdigkeit«:</b>
Viel wurde über die endliche Anzahl Schreiboperationen auf eine Flash-Zelle
bis zu ihrem Ausfall geschrieben.
Jedoch gibt es, praktisch gesprochen, viele Möglichkeiten, wie ein Flash-Gerät
ausfallen kann, und Schreibmüdigkeit ist nur eine davon.
Moderne Flash-Geräte verifizieren Schreiboperationen und ersetzen im Falle
eines Fehlers automatisch den ausgefallenen Sektor mit einem der vielen
Reservesektoren.
Die meisten Benutzer moderner Flash-Geräte werden sich über »Schreibmüdigkeit«
keinerlei Gedanken machen müssen.
Du wirst möglicherweise mehr Ausfallzeiten durch Probleme haben, die sich aus
»cleveren« Tricks zur Minimierung von Schreiboperationen auf Flash-Geräte
ergeben, als wenn du diese Laufwerke einfach als les- und schreibbares Medium
benutzt.

<li><b>Zuverlässigkeit:</b>
Der Umstand das Flash-Medien keinerlei bewegliche Teile haben, hat viele Leute
glauben lassen, dass Flash-Medien inhärent sicherer sind als Festplatten.
Es ist nicht klug anzunehmen, dass der Wechsel auf Flash bedeutet, dass man
sich keinerlei Gedanken mehr über Datenverlust oder Laufwerksausfälle machen
muss.
Personen berichteten von bemerkenswert schwankender Qualität von Flash-Medien,
und es ist wahrscheinlich am besten, Flash-Speicher als leise und stromsparende
Alternative zu Festplatten anzusehen, als als fehlerfreies Speichermedium.

<li><b>Erzeugung eines startbaren USB-Flash-Laufwerks:</b>
Obwohl ein USB-Gerät nur von einer Maschine gestartet werden kann, die von
USB-Geräten starten kann, so kann es doch auf jeder Maschine erzeugt werden,
welche USB-Hardware unterstützt.
Du kannst natürlich deine Arbeit solange nicht testen, bis du ein von USB
startbares System bekommst.

<li><b>Wechsel von IDE- zu USB-Schnittstellen:</b>
Da Flash-Medien von USB-, IDE- und anderen Adaptern gelesen und geschrieben
werden können, kannst du ein startbares Medium mit dem einen Adaptertyp
erzeugen, es aber mit einem anderen Typ verwalten und benutzen.

<li><b>Das Mischen von OpenBSD- und anderen Partitionen auf einem Gerät:</b>
OpenBSD behandelt das Flash-Laufwerk wie jedes Andere, sodass du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8"
>fdisk(8)</a> benutzen kannst, um ein Flash-Gerät zu partitionieren, genauso
wie du es für eine Festplatte machen würdest.
Du kannst dann OpenBSD-Dateisysteme auf einer Partition haben, und eine andere
Partition für ein anderes Dateisystem benutzen, zum Beispiel FAT32.
Jedoch behandeln nicht alle Betriebssysteme USB-Geräte »gleich«.
Windows, zumindest, versucht erst gar nicht eine Partition zu nutzen oder zu
erzeugen, die nicht am Anfang des Geräts startet, noch wird es das
Partitionierungs-Werkzeug von Windows erlauben, das Laufwerk zu partitionieren,
obwohl es existierende Partitionen respektiert.
Also, wenn du ein USB-Flash-Laufwerk erzeugen willst, dass mit OpenBSD startbar
ist, aber ebenfalls als FAT32-taugliches Gerät unter anderen Betriebssystemen
nutzbar ist, so musst du so etwas machen wie dies:

  <ol>
  <li>Partitioniere das Medium mit OpenBSD's fdisk, und erzeuge eine Partition
    des mit und für Windows gewünschten Typs am Anfang des Laufwerks, und
    eine OpenBSD-Partition am Ende des Laufwerks.
  <li>Installiere OpenBSD wie normal in die OpenBSD-fdisk-Partition, und
    vergesse nicht, diese Partition als »Active«, d.&nbsp;h. startbar zu
    markieren.
  <li>Formatiere die andere Partition.
    Dies kann (und vielleicht sollte es auch) auf dem »Ziel«-Betriebssystem (in
    diesem Fall Windows) geschehen.
  </ol>

Beachte das es, wenn der andere Partitionstyp passend gewählt ist, für OpenBSD
möglich ist, beide Partitionen auf dem Gerät anzusprechen.
Also könnte ein Windows-Benutzer die FAT32-Partition mit MP3-Dateien füllen,
welche dann abgespielt werden, wenn sie von der OpenBSD-Partition aus geladen
werden.

</ul>

<a name="flashmemLive"></a>
<h3>14.17.3 - Wie kann ich ein startbares »Live«-USB-Gerät erzeugen?</h3>
Es ist sehr einfach ein startbares USB-Flash-Laufwerk (oder ein anderes!) zu
erzeugen, das als sogenanntes »Live«-OpenBSD-System benutzt werden kann, ohne
das OpenBSD auf der lokalen Festplatte der Maschine installiert werden muss.
Augenscheinlich muss die Zielmaschine von einem USB-Gerät startbar sein, aber
die Vorarbeit kann auf jeder Maschine mit einer USB-Schnittstelle geleistet
werden.

<p>
Einige Gründe, warum du dies machen können wolltest:
<ul>
<li>Eine portable, sichere »Maschine«, die du in deiner Tasche mit dir tragen
kannst.

<li>Lösen von Problemen in OpenBSD und anderen Installationen mit Werkzeugen,
die in einem <a href="faq4.html#bsd.rd">bsd.rd</a> nicht vorhanden sind.

<li>Bewertung von Hardware auf OpenBSD-Kompatibilität zum Zeitpunkt des Kaufs.

<li>Installation auf Maschinen die eine andere Form von Startmedium missen
lassen.

<li>Sammeln von <a href="faq4.html#SendDmesg">dmesg</a>-Ausgaben von den
Computern deiner Freunde!
(Da OpenBSD's »dmesg«-Ausgaben nützlich zur Identifikation von Hardware sind,
kann dies eine guter Weg der Vorbereitung zur Installation ANDERER
Betriebssysteme auf der Maschine sein - stelle sicher, dass du alle benötigten
Treiber hast, bevor du startest).

</ul>

Das Erzeugen eines solchen »Live-OpenBSD-Laufwerks« ist einfach.
<ul>
<li>Hänge dein USB-Laufwerk in die Maschine ein, von der du installieren willst.
<li>Starte dein favorisiertes OpenBSD-Installationsmedium.
<li><a href="faq4.html">Installiere</a> wie normal, versichere dich, dass du
das Flash-Laufwerk als Installationsziel auswählst.
<li>Starte von deinem neu erzeugten USB-Gerät.
</ul>

Das ist alles!

<p>
Es gibt einige Dinge, die du eventuell nach der Installation machen möchtest,
um deine Ergebnisse zu verbessern:

<ul>
<li>Installiere alle Pakete und Dienstprogramme, die du wahrscheinlich
verfügbar haben möchtest.
<li>Unterschiedliche Zielmaschinen werden wahrscheinlich unterschiedliche NICs
haben.
Du könntest eine Reihe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a>-Dateien in <tt>/etc</tt> erzeugen, jede einzig mit dem
Inhalt <tt>dhcp</tt>, und zwar für alle jene NICs, die dir wahrscheinlich
auf von USB startbaren Maschinen begegnen werden (fxp0, re0, rl0, bge0, bnx0,
em0, etc.), und zusätzlich einige Beispiel-Konfigurationsdateien für drahtlose
Netzwerke.
OpenBSD ignoriert alle hostname.if(5)-Dateien für Geräte, die während des
Systemstarts nicht vorhanden sind.

<li>Du könntest den Wunsch verspüren, eine Kopie aller Installationsdateien und
vielleicht aller gewünschte Paket-.tgz-Dateien zu haben, so dass du das
Laufwerk als Installationsmedium nutzen kannst (starte dafür bsd.rd, anstatt
den normalen Startprozess ablaufen zu lassen).

<li>Auf vielen Maschinen wird X »einfach funktionieren«, selbst ohne
Konfigurationsdatei, aber du möchtest vielleicht X-Konfigurationsdateien für
jene Systeme sammeln, die sie benötigen.

<li><a href="#SoftUpdates">Soft-Updates</a> könnte etwas sein, dass du nutzen
möchtest.

<li>Für die maximale Flexibilität möchtest du eventuell
<a href="../../de/i386.html">i386</a> anstatt
<a href="../../de/amd64.html">amd64</a> benutzen.
Wenn du es als Installationsmedium benutzen möchtest, so kannst du natürlich
einen amd64 bsd.rd und amd64 Installationsdateien zusätzlich zu jenen für i386
haben.

<li>Benutze <a href="#DUID">DUIDs</a> zur Identifikation von Parititionen.
<li>Du könntest es für wünschenswert erachten, eine FAT-Partition auf dem
USB-Laufwerk zu haben, erzeuge es wie <a href="#flashmemBoot">oben</a>
detailliert beschrieben.

<li>Du könntest
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4"
>softraid(4)</a> zur Verschlüsselung einer Datenpartition nutzen wollen.

</ul>

<p>
<a name= "DiskOpt"></a>
<h2>14.18 - Optimierung der Laufwerksleistung</h2>

<p>
Die Festplattenleistung ist ein wichtiger Faktor in der
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multiuserumgebung beheimatet
(Benutzer aller Arten - von solchen, die sich einloggen, bis zu denen,
die Serverdienste nutzen). Datenspeicher brauchen ständige
Aufmerksamkeit; insbesondere, wenn deine Partition überläuft
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erhöhen
und Fehlertoleranz zu bieten.

<p>
<ul>
<li><a href="#Optsoftu">Softupdates</a>
<li><a href="#Optmaxvnodes">Größe des namei()-Caches</a>
</ul>

<p>
<a name="Optsoftu"></a>
<h3>14.18.1 - Softupdates</h3>

Ein wichtiges Werkzeug zum Erhöhen der Systemgeschwindigkeit sind
Softupdates. Eine der langsamsten Operationen im traditionellen
BSD-Dateisystem ist das Aktualisieren der Metainfos (was unter anderem
immer dann geschieht, wenn du Dateien oder Verzeichnisse erzeugst oder
löschst). Softupdates versucht die Metainfo im RAM zu aktualisieren,
statt jedes einzelne Metainfoupdate auf die Platte zu schreiben. Ein
weiterer Nebeneffekt ist, dass die Metainfos auf der Festplatte immer
komplett, wenn auch nicht immer auf dem aktuellen Stand sind.
Du kannst mehr über Softupdates in dem
<a href="#SoftUpdates">Softupdates-FAQ</a>-Eintrag finden.

<p>
<a name="Optmaxvnodes"></a>
<h3>14.18. - Größe des namei()-Caches</h3>

Die name-to-inode-Übersetzung (a.&nbsp;k.&nbsp;a. <!-- need to write
the manual page first... <a href="">namei(3)</a> --> namei()-Cache)
kontrolliert die Geschwindigkeit der
pathname-to-<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>-Übersetzung.
Ein sinnvoller Weg zum Herausfinden der passenden Größe des Caches
wäre eine große Anzahl namei()-Cachemisses, die man mit einem
Werkzeug wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>
messen könnte (was eine Untersuchung des momentanen berechneten Wertes
mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> voraussetzt, das diesen Parameter <tt>kern.maxvnodes</tt>
nennt) und diesen Wert zu vergrößern, bis sich entweder die Hitrate des
namei()-Caches verbessert oder es bewiesen ist, dass das System nicht
wesentlich von einer Erhöhung der Größe des namei()-Caches profitiert.
Nachdem der Wert festgestellt wurde, kannst du ihn für die nächsten
Systemstarts mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>
setzen.

<p>
<a name= "Async"></a>
<h2>14.19 - Warum verwenden wir keine »async«hronen Einhängemodi?</h2>

<p>
Frage: »Ich gebe einfach ein ,mount -u -o async /' ein, was ein Paket,
welches ich brauche, benutzbar macht (das darauf besteht alle paar
Momente ein paar hundert Dateien zu ändern).

Wieso wird asynchrones Mounting abgelehnt und ist nicht standardmäßig
aktiviert (wie in manchen anderen Unixen)? Wäre das nicht ein
einfacherer und daher auch ein sichererer Weg, die Leistung mancher
Applikation zu erhöhen?«

<p>
Antwort: »Asynchrone Mounts sind tatsächlich schneller als synchrone
Mounts - aber auch unsicherer. Was passiert im Falle eines
Stromausfalls - oder bei einem Hardwareproblem? Die Suche nach
Geschwindigkeit darf nicht auf Kosten der Stabilität und Zuverlässigkeit
des Systems gehen. Siehe auch die Handbuchseite von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>.«

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
Auf der anderen Seite kannst du mehr Geschwindigkeit erhalten, wenn du
sowieso nur mit temporären Daten umgehst, die du nach einem Crash wieder
rekonstruieren kannst, indem du eine separate Partition nur für
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur,
wenn</i> dir der Verlust aller Daten in der Partition nach irgendeinem
Problem nichts ausmacht. Daher sind
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>-Partitionen
asynchron gemountet, weil sie ja nach jedem Neustart sowieso gelöscht
und neu erzeugt werden.

<a name="altroot"></a>
<h2>14.20 - Duplikation deiner Wurzelpartition: »altroot«</h2>

OpenBSD bietet die Möglichkeit einer alternativen Wurzelpartition, "altroot"
genannt; dies ist Teil der 
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily&amp;sektion=8"
>daily</a>« Skripte.
Wenn die Umgebungsvariable <tt>ROOTBACKUP=1</tt> gesetzt ist, und zwar entweder
in <tt>/etc/daily.local</tt> oder aber in root's
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=5"
>crontab(5)</a>,
und in <tt>/etc/fstab</tt> eine Partition angegeben ist, die mit den Optionen
»xx« als <tt>/altroot</tt> eingehängt wird, so wird jede Nacht der gesamte
Inhalt der Wurzelpartition auf die Partition <tt>/altroot</tt> gespiegelt.
Angenommen, wir wollen unsere Wurzelpartition nach wd1a sichern, so fügen wir
Folgendes zu <tt>/etc/fstab</tt> hinzu

<blockquote><pre>
/dev/wd1a /altroot ffs xx 0 0
</pre></blockquote>

und setzen die dazugehörigen Umgebungsvariablen in <tt>/etc/daily.local</tt>:
<blockquote><pre>
# <b>echo ROOTBACKUP=1 >>/etc/daily.local</b>
</pre></blockquote>

Da der »altroot«-Prozess auch dein <tt>/etc</tt> Verzeichnis erfasst, wird dies
sicherstellen, dass jedwede Konfigurationsänderung täglich aktualisiert und
gesichert wird.

<p>
»altroot« ist eine »Mediumsabbildskopie« die mit Hilfe von dd(8) vorgenommen
wird, keine Kopie »Datei-für-Datei«, sodass deine als <tt>/altroot</tt>
eingehängte Partition entweder exakt dieselbe Größe wie deine Wurzelpartition
aufweisen, oder aber größer als diese sein sollte.
Ebenfalls sollten übertrieben große Wurzelpartition vermieden werden, um die
Zeitdauer des Prozesses zu reduzieren.

<p>
Für vollständige Redundanz sollten die übrigen Partitionen ebenfalls dupliziert
werden, was mit Hilfe von »<a href="#softraid">softraid</a>«-Medien,
dump(8)/restore(8), rsync etc. bewerkstelligt werden kann.
Dies ist sowohl manuell möglich, als auch als Teil eines regelmäßigen
Zeitplans, wie z.&nbsp;B. mit Hilfe der <tt>weekly.local</tt>,
<tt>daily.local</tt> oder <tt>monthly.local</tt> Skripte.

<p>
Generell gesagt ist es in deinem Interesse, die Partition »altroot« auf einem
separaten Laufwerk zu haben, dass voll startfähig konfiguriert ist, sodass es
dein primäres Laufwerk vollständig ersetzen kann.
Es ist zwar möglich, ein »altroot« auf demselben Laufwerk wie deine
Startpartition zu platzieren, jedoch ist der Nutzen einer solchen Konfiguration
gering.

<p>
Beachte, dass wir das Laufwerk für die Partition »altroot« nicht via DUID
angesteuert haben, sondern über den Gerätenamen.
Wir möchten oder müssen vielleicht das Startlaufwerk und das zweite Laufwerk
tauschen.
Aus diesem Grund möchtest du eventuell sowohl die Wurzelpartition als auch jene
von »altroot« in <tt>/etc/fstab</tt> über den Laufwerksnames anstatt einer DUID
ansprechen.

<a name="softraid"></a>
<h2>14.21 - Wie nutze ich softraid(4)?</h2>

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4"
>Softraid(4)</a> emuliert einen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scsibus&amp;sektion=4"
>scsibus(4)</a> mit angeschlossenen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4"
>sd(4)</a>-Geräten, die mit Hilfe einer Anzahl von OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8"
>disklabel(8)</a>-Partitionen (»chunks«) zu einem virtuellen Datenträger
(»volume«) kombiniert wurden, und zwar mit Hilfe der gewünschten RAID Strategie
(»discipline«), wie, z.&nbsp;B., RAID0, RAID1, RAID4, RAID5 oder Crypto.
(Anmerkung: nur RAID0, RAID1 und Crypto werden im Moment voll unterstützt.)

<p>
Dieser virtuelle Datenträger wird wie jedes andere Laufwerk behandelt --
zuerst wird es mittels <a href="#fdisk">fdisk(8)</a> (auf fdisk-Plattformen)
und dann <a href="#disklabel">disklabel(8)</a> partitioniert, Partitionen
werden in Dateisysteme aufgebrochen, eingehängt, dann genutzt.

<p>
<h4>Einige generelle Worte zu RAID:</h4>
<ul>
<li>
Bevor du eine RAID-Lösung implementierst, solltest du verstehen, was es für
dich tun kann, und was nicht.
Es ist kein Ersatz für eine gute Datensicherungs-Strategie.
Es wird dein System nicht sicher durch jeden Hardware-Ausfall leiten.
Es mag sein, dass es noch nicht einmal dein System sicher über einen einfachen
Laufwerksausfall hinüberrettet.
Im Falle von in Software implementierten RAID kann es nicht garantieren, dass
das System vom überlebenden Laufwerk gestartet werden kann, wenn dein Computer
es nicht auf andere Weise konnte.

<li>
Bevor du sie im Produktiv-Einsatz verwendest, solltest du verstehen, wie du
mit deiner RAID-Lösung deine Daten im Fehlerfalle wieder herstellen kannst.
Die Zeit, dies zu tun, ist BEVOR dein System einen Zwischenfall hatte.
Schlecht implementiertes RAID produziert oft mehr Ausfallzeit als es nützt.
Dies ist umso wahrer, solltes du selbstgefällig mit deiner Datensicherung oder
deiner Fehlerfallplanung umgehen.

<li>
Je größer deine im RAID-Verbund eingebundenen Partitionen sind, je länger wird
es dauern, sie nach einem »Zwischenfall« wiederherzustellen.
In anderen Worten, dies ist eine denkbar schlechte Zeit, den gesamten
Speicherplatz deiner billigen 500 G Laufwerke zu nutzen, nur, weil er da ist.
Die Wiederherstellung von 500 G Laufwerken dauert viel länger, als jene der
4 G, die du tatsächlich nutzt.
Ein Vorteil von in Software implementierter Datenspiegelung ist, dass du es
kontrollieren kannst, wie viel dieser »riesigen« Laufwerke tatsächlich für
einen RAID-Verbund genutzt werden.

<li>
Es gibt diesen Reflex, so viel wie möglich von deinem System via RAID
abzusichern.
Das Spiegeln deiner Wurzelpartition ist mit einem Software-RAID schwer zu
machen, und oft zwecklos, da ein nicht unbeträchtlicher Teil der PC-Hardware
Schwierigkeiten hat, von einer anderen als der primären Startpartition zu
starten.
Sogar Hardware, die von anderen Laufwerken starten KÖNNTE, hat oft
Schwierigkeiten festzustellen, ob ein Laufwerk einen Schaden hat, was jedoch
nötig wäre, um im Anschluß daran den Systemstart von eben jenem Laufwerk zu
vermeiden.
OpenBSD's «<a href="#altroot">altroot</a>»-System kann für einige Anwendungen
sehr viel BESSER sein, da es eine Kopie der alten Konfigurationsinformationen
vorhält, für den Fall, dass eine Änderung nicht wie gewünscht funktioniert.

<li>
RAID bietet Redundanz einzig für Laufwerke.
Viele Anwendungen benötigen mehr Redundanz als nur für Laufwerke, und für
einige Anwendungen kann RAID auch nichts anderes als Verkomplizierung der Dinge
anstatt eines echten Mehrwerts bedeuten.
Ein Beispiel dafür wäre ein Verbund von <a href="faq6.html#CARP">CARP</a>
Firewalls, der eine komplette Ausfallredundanz bietet.
In diesem Fall bedeutet RAID (ob via Hard- oder Software) einzig hinzugefügte
Verkomplizierung.
</ul>

<h3>14.21.1 - Installation</h3>

Laufwerksspeicherplatz für »softraid« kann durch Nutzung von freien (oder
hinzugefügten!) Batzen Laufwerksspeicherplatz nach der Installation erzeugt
werden, jedoch ist auch dies nur ein spezieller (und einfacher) Aspekt des
Hinzufügens von »softraid« während der Installation.

<p>
Die Werkzeuge, die benötigt werden, um dein »softraid«-System
zusammenzustellen, finden sich sämtlich in einer OpenBSD-Basisinstallation (zum
Hinzufügen von »softraid«-Geräten nach der Installation), sind jedoch ebenfalls
Teil der CD-ROM- und <a href="faq4.html#bsd.rd">bsd.rd</a>-Installationskernel.
Aus Platzgründen finden sie sich nicht auf den Disketten;
ein einfacher Weg, diese Restriktion zu umschiffen, ist die Installation eines
minimalen OpenBSD von Diskette, gefolgt vom Start des bsd.rd des installierten
Systems, gefolgt von einer Neuübersetzung mit allen gewünschten Eigenschaften.

<p>
Der Installationsprozess wird ein wenig anders sein als eine standardmäßige
OpenBSD-<a href="faq4.html">Installation</a>, da du währenddessen zum
Kommandozeileninterpreter wechseln und deine softraid(4)-Geräte erzeugen musst,
und zwar bevor die eigentliche Installation startet.
Sind die softraid(4)-Laufwerke erst einmal erzeugt, so kannst du die
Installation relativ normal durchführen, und die von dir gewünschten
Partitionen als RAID auf den neu konfigurierten Laufwerken platzieren.

<p>
Du kannst die RAID-Partitionen vorerzeugen, sie zu einem
softraid(4)-Datenträger zusammenstellen und dem Installationsprogramm den Rest
überlassen, jedoch ist es vielleicht einfacher, sowohl dein Wurzelverzeichnis,
als auch die Auslagerungs-Partitionen ebenfalls manuell zu erzeugen, bevor du
das Installationsprogramm startest.

<p>
Dies bedeutet, dass du das Laufwerk vorsichtig vorbereiten musst, bevor du den
Installationsprozess startest, und sicherstellst, dass du einige wenige
Schritte manuell unternimmst, die dir normalerweise vom Installationsprogramm
abgenommen werden.

<p>
Der Installationskernel besitzt in <tt>/dev</tt> zur Systemstartzeit nur
Einträge für ein wd(4)- und ein sd(4)-Gerät, sodass du mehr
Laufwerksgerätedateien erzeugen musst, um dein »softraid«-Gerät einrichten zu
können.

Dieser Prozess wird zwar normalerweise vom Installationsprogramm automatisch
vollzogen, jedoch ist dieses noch gar nicht gelaufen, und außerdem wirst du
ein Laufwerk erzeugen, dass zur Systemstartzeit noch gar nicht existierte.
Zum Beispiel, wenn wir ein zweites und gar drittes wd(4)-Gerät, und ein zweites
sd(4)-Gerät benötigen würden (erinnere den Umstand, dass »softraid«-Geräte als
sd(4)-Geräte geführt werden), so könnten wir Folgendes am
Kommandozeileninterpreter-Prompt eingeben:

<blockquote><pre>
# <b>cd /dev</b>
# <b>sh MAKEDEV wd1 wd2 sd1</b>
</pre></blockquote>

Danach besteht vollständige Unterstützung für sd0, sd1, wd0, wd1 und wd2.

<p>
Sodann ist es notwendig die physischen Laufwerke korrekt zu
»<a href="#fdisk">fdisk(1)</a>en« (wenn dies für deine Plattform approbat ist
-- stelle sicher, das zweite Laufwerk so einzurichten, dass von ihm gestartet
werden kann!), um dann mit Hilfe von <a href="#disklabel">disklabel</a> die
Partitionen einzurichten.

<p>
Die unten gezeigten fdisk(8) Schritte platzieren einen MBR und eine
OpenBSD-Partition auf dem Laufwerk.
WENN du die Gesamtheit des Laufwerks für OpenBSD nutzen willst (d.&nbsp;h., du
möchtest NICHTS anderes dortselbst sehen), so ist exakt dies mit einem
einfachen Einzeiler für jedes Laufwerk möglich:

<blockquote><pre>
# <b>fdisk -iy wd0</b>
# <b>fdisk -iy wd1</b>
</pre></blockquote>

(Sei dir bewußt und verstehe, was diese Zeilen mit allen vorher auf dem
Laufwerk vorhandenen Daten anstellen, bevor du sie blind benutzt!)
Anderenfalls musst du OpenBSD-Partitionen innerhalb der neuen Laufwerke
erzeugen.

<h4>Erzeuge die Partitionen für »softraid«</h4>

Wenn du die softraid(4)-Partition erzeugst, gib ihr den Typ »RAID« anstatt der
normalen »4.2BSD« oder »swap«.
In diesem Fall werden wir unsere Wunschpartitionen auf wd0 erzeugen:

<ul>
<li>wd0a  500M /
<li>wd0b  500M swap
<li>wd0m  10G RAID
</ul>

<blockquote><pre>
# <b>disklabel -E wd0</b>
Label editor (enter '?' for help at any prompt)
> <b>a a</b>
offset: [64] <b><i>ENTER</i></b> 
size: [30282461] <b>500m</b>
Rounding to cylinder (16065 sectors): 1028096
FS type: [4.2BSD] <b><i>ENTER</i></b> 
> <b>a b</b>
offset: [1028160]  <b><i>ENTER</i></b> 
size: [29254365] <b>500m</b>
Rounding to cylinder (16065 sectors): 1028160
FS type: [swap] <b><i>ENTER</i></b> 
> <b>a m</b>
offset: [3148740]  <b><i>ENTER</i></b>
size: [28226205] <b>10g</b>
Rounding to cylinder (16065 sectors): 20980890
FS type: [4.2BSD] <b>RAID</b>
> <b>q</b>
Write new label?: [y] <b><i>ENTER</i></b>
</pre></blockquote>

<p>
Nun müssen wir das zweite Laufwerk so aufbereiten, dass es an den
Schlüsselstellen dem Layout des ersten Laufwerks entspricht.
Da wir das <tt>/altroot</tt>-System nutzen, möchten wir eine Partition »a« auf
dem zweiten Laufwerk, die dieselbe Größe hat wie die Partition »a« des ersten
Laufwerks.
Wir möchten, dass das System von dem zweiten Laufwerk exakt so läuft, wie es
das von dem ersten macht, weshalb wir gleichsam eine ähnlich dimensionierte
Auslagerungspartition benötigen (ein wenig größer oder kleiner spielt in diesem
Fall eine untergeordnete Rolle).
Wir möchten ebenso, dass die RAID-Partition dieselbe Größe aufweist wie die der
Primären.
Besitzen die RAID-Partitionen nicht dieselbe Größe, so wird die kleinere der
Beiden am Ende die Größe des RAID Datenträgers bestimmen.

<p>
Zusammengefasst ... wiederhole einfach den kompletten, oben beschriebenen
Aufteilungsprozess für das zweite Laufwerk, wd1.

<h4>Zusammenstellung des RAID Datenträgers</h4>

Wir nehmen im Folgenden an, dass sich deine zwei RAID-Partitionen auf wd0m und
wd1m befinden.
Beachte, dass der RAID-Partitionsbuchstabe beliebig ist, es muss auf dem
zweiten Laufwerk nicht derselbe Buchstabe sein, aber natürlich machst du dir
die Dinge deutlich übersichtlicher, wenn es doch so ist.

<p>
Beachte außerdem das softraid(4) sich ein wenig nach Hinweisen auf Bereiche
umschaut, die es zusammenzustellen hat, sodass du es, für den Fall, dass dein
Laufwerk bereits für softraid(4) genutzt wurde, hilfreich finden könntest,
das erste Megabyte jeder Partition mit Hilfe von dd(1) zu löschen:

<blockquote><pre>
# <b>dd if=/dev/zero of=/dev/rwd0m bs=1m count=1</b>
   ...
# <b>dd if=/dev/zero of=/dev/rwd1m bs=1m count=1</b>
   ...
</pre></blockquote>

<p>
Wir erzeugen nun unser neues softraid(1)-Laufwerk mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8"
>bioctl(8)</a>:

<blockquote><pre>
# <b>bioctl -c 1 -l /dev/wd0m,/dev/wd1m softraid0</b>
</pre></blockquote>

Dies erzeugt einen RAID1 Datenträger (»<tt>-c 1</tt>«) unter Einbeziehung der
aufgeführten Partitionen (»<tt>-l /dev/wd0m,/dev/wd1m</tt>«) und Nutzung des 
<tt>softraid0</tt>-Treibers.
Befinden sich keine weiteren sd(4)-Geräte auf diesem System, so wird es als sd0
ansprechbar sein.
Für den Fall, dass du mehrere RAID Geräte auf einem Laufwerk oder auf mehreren
Geräten erzeugen möchtest, ist anzumerken, dass du stets den virtuellen
softraid0 Laufwerksschnittstellen-Treiber zu nutzen hast, nicht jedoch
»softraid1« oder andere.
Merke dir, dass »softraid0« ein virtueller RAID-Steuerbaustein ist, an den du
viele virtuelle Laufwerke anhängen kannst.

<p>
Dies wird ein neues Laufwerk erzeugen, »sd0« (immer noch in der Annahme, dass
sich keine weiteren sd(4)-Geräte auf diesem System befinden).
Dieses Gerät wird nun auf der Systemkonsole und in der »dmesg« als neu
installiertes Gerät auftauchen:

<blockquote><pre>
scsibus1 at softraid0: 1 targets
sd0 at scsibus2 targ 0 lun 0: &lt;OPENBSD, SR RAID 1, 005&gt; SCSI2 0/direct
 fixed
sd0: 10244MB, 512 bytes/sec, 20980362 sec total
</pre></blockquote>

Dies zeigt, dass wir nun sowohl einen neuen SCSI-Datenbus als auch ein neues
Laufwerk haben.
Dieser Datenträger wird von nun an automatisch erkannt und zusammengestellt,
wenn das System startet.

<p>
Solltest du die Komponentenabschnitte nicht gelöscht haben, so wie weiter oben
gezeigt, ist es sehr empfehlenswert, nun den ersten Abschnitt des neuen
Laufwerks zu löschen, da das neue Gerät möglicherweise dort eine Menge Müll
enthält, wo eigentlich ein MBR und ein disklabel erwartet werden:

<blockquote><pre>
# dd if=/dev/zero of=/dev/rsd0c bs=1m count=1
</pre></blockquote>

An diesem Punkt bist du bereit dazu, OpenBSD auf deinem System zu installieren.
Führe die Installation wie üblich durch die Ausführung von »install« am
Kommandozeileninterpreter-Prompt des Startmediums durch.
Sei vorsichtig und wähle den »custom« Belegungsplan für disklabel, wenn du
danach gefragt wirst, sonst wird deine RAID-Partition überschrieben!
Nutze die Option »n« innerhalb von disklabel, um den Einhängepunkt für deine
Wurzelpartition zu definieren, und erzeuge alle gewünschten Partitionen auf
deinem neuen softraid-Laufwerk (sd0 in unserem Beispiel hier), anstatt dies auf
deinen nicht-RAID Laufwerken zu tun.

<p>
Nun kannst du dein System neu starten, und wenn du alles ordentlich gemacht
hast, so wird es deinen RAID Datenträger automatisch zusammenstellen, und die
dazugehörigen Partitionen in das System einhängen.

<h3>14.21.3 - Bemerkungen zu »softraid«</h3>

<h4>Komplikationen, wenn andere sd(4)-Laufwerke existieren</h4>

»Softraid«-Laufwerke werden zusammengestellt, <i>nachdem</i> alle anderen IDE,
SATA, SAS und SCSI Laufwerke zugewiesen wurden.
Als Resultat davon ändert sich die Identifikation des »softraid«-Laufwerks,
wenn sich die Nummer des sd(4)-Geräts ändert (entweder weil Geräte hinzugefügt
oder entfernt wurden -- oder weil ein Gerät ausfällt).
Aus diesem Grunde ist es sehr wichtig, <a href="faq14.html#DUID">DUID</a>s
(»Disklabel Unique Identifiers«, eindeutige »disklabel« Kennungen) in deiner
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"
>fstab(5)</a>-Datei zu nutzen.

<p>
Du möchtest vielleicht nicht das Wurzelverzeichnis per DUID ansprechen.

<h4>Ein Drei-Laufwerke RAID1?</h4>

»softraid« unterstützt RAID1 mit mehr als zwei »Stücken«, und die Beispiele der
Handbuchseite zeigen auch eine RAID1 Konfiguration mit drei Laufwerken.
RAID1 dupliziert einfach die Daten über alle angeschlossenen Speicherstücke,
sodass deren zwei volle Redundanz und deren drei zusätzliche Fehlertoleranz
ergeben.
Der Vorteil von RAID mit drei (oder mehr!) Laufwerken oder Speicherstücken ist,
dass im Falle des Ausfalls eines Laufwerks IMMER NOCH komplette Redundanz
gegeben ist.
Betrachte es als Ersatzlaufwerk das keinerlei Zeit zum Neuaufbau benötigt!
Theoretisch ist ein Drei-Laufwerks RAID1 beim Schreiben langsamer als ein
Verbund aus zwei Laufwerken, jedoch sollte es beim Schreiben viel schneller
sein, als der Neuaufbau eines Zwei-Laufwerks RAID1.

<a name="softraidDR"></a>
<h3>14.21.4 - Notfallwiederherstellung</h3>

Dies ist die Rubrik, die du überspringen möchtest, jedoch -- tue es nicht.
Es ist dies der Existenzgrund für RAID -- wenn Laufwerke niemals ausfallen
würden, so würdest du deinem System nicht die Verkomplizierung durch RAID
zukommen lassen!
Da es sehr schwierig ist, Ausfälle umfassend aufzuführen, besteht leider die
große Wahrscheinlichkeit, dass das Ereignis, dass du erlebst, hier nicht exakt
beschrieben wird, aber wenn du dir die Zeit nimmst, die hier aufgeführten
Strategien zu verstehen, und das WARUM, so kannst du sie hoffentlich nutzen,
um aus jedweder Situation einen rettenden Weg zu finden.

<p>
Behalte im Hinterkopf, dass Ausfälle oft nicht einfach sind.
Der Autor dieses Artikels hatte einen Kurzschluss an der Stromzuführung eines
in eine Hardware-RAID-Lösung eingebundenen Laufwerks, was, zusätzlich zu dem
Laufwerk selbst, den Ersatz des Netzteils, des RAID-Gehäuses und des Netzteils
eines zweiten Computers, den er nutzte, um zu verifizieren, dass das Laufwerk
tatsächlich verendet war, als auch, da er das Ersatzgehäuse nicht ordentlich
konfigurierte, die Wiederherstellung der Daten aus der Datensicherung
erforderte.

<p>
Die Schritte, die zur Wiederherstellung des Systems erforderlich sind, können
sowohl im <a href="faq8.html#LostPW">Einbenutzermodus</a> als auch ausgehend
von einem <a href="faq4.html#bsd.rd">Installationskernel (bsd.rd)</a>
vorgenommen werden.

<p>
Solltest du vorhaben, die Wiederherstellung von »softraid« zu trainieren (und
dies wird von uns HÖCHSTENS empfohlen!), so magst du es hilfreich finden, ein
Laufwerk, dass du aus dem Verbund nimmst, komplett zu löschen, bevor du
versuchst, es wieder dem Verbund hinzuzufügen.
Nicht nur, dass dies den Grad der Simulation des Ersetzens eines Laufwerks mit
einem neuen erhöht, es vermeidet ebenso die Konfusion, die daraus resultieren
kann, dass das System Überreste eines »softraid«-Verbundes vorfindet.

<p>
Die Wiederherstellung nach einem Ausfall wird oftmals ein zweistufiger Vorgang
sein -- die erste Stufe ist es, das System in einen lauffähigen Zustand
zurückzubringen, die Zweite ist der Neuaufbau des ausgefallenen Verbundes.
Diese zwei Stufen können eine gewisse zeitliche Distanz aufweisen, wenn du kein
Ersatzlaufwerk zu Hand hast.

<h4>Wiederherstellung nach einem Laufwerksfehler: Sekundär</h4>

Dies ist relativ einfach.
Es kann sein, dass du das ausgefallene Laufwerk entfernen musst, um das System
wieder anfahren zu können.

<p>
Wenn du dazu bereit bist, das System zu reparieren, so wirst du das
ausgefallene Laufwerk ersetzen, die RAID- und andere disklabel-Partitionen
erzeugen, und dann den Spiegelverbund neu aufbauen.
Angenommen dein RAID-Datenträger ist <tt>sd0</tt>, und du ersetzt das
ausgefallene Laufwerk mit <tt>wd1m</tt>, so sollte das folgende Verfahren
funktionieren:

<ul>
<li>Starte das System neu.
<li>Erzeuge die entsprechenden Partitionen auf deinem neuen Laufwerk.
<li>Stelle deine RAID-Partition wieder her:
<blockquote><pre>
# <b>bioctl -R /dev/wd1m sd0</b> 
</pre></blockquote>
<li>Starte neu.
</ul>

<h4>Wiederherstellung nach einem Laufwerksfehler: Primär</h4>

Viele PC-ähnliche Computer können nicht von einem sekundären Laufwerk starten,
wenn das Primäre ausgefallen-, aber immer noch angeschlossen ist, es sei denn
es ist so mausetot, dass es gar nicht erkannt wird.
Viele können von keinem Laufwerk starten, das nicht als »primär« markiert
wurde, selbst wenn kein anderes Laufwerk vorhanden ist.

<p>
Generell gesagt, wenn dein primäres Laufwerk ausfällt, so wirst du es
entfernen, und in vielen Fällen dein sekundäres Laufwerk zu einem primären
Solchen »befördern« müssen, damit dein System starten kann.
Dies mag auch das Umstecken von Steckbrücken (»Jumper«) des Laufwerks, das
Anschließen des Laufwerks an einen anderen Anschluß oder einige andere
Variationen beinhalten.
Es ist selbstverständlich, dass das, was sich auf dem sekundären Laufwerk
befindet, nicht nur deine RAID-Partition beinhalten, sondern auch funktional
startfähig sein muss.

<p>
Läuft dein System erst einmal wieder auf dem sekundären Laufwerk, und ist ein
neues Laufwerk an Ort und Stelle, verfahre wie oben beschrieben.

<h4>Wiederherstellung nach dem »Mischen« deiner Laufwerke</h4>

Wenn du vier Laufwerke in deinem System besitzt, sagen wir mal, sd0, sd1, sd2
und sd3, und du endest, aus Gründen des Ersetzens von Hardware oder einer
Aufrüstung, mit ausgebauten Laufwerken, und hast vergessen, welches jetzt
welches war?

<p>
Glücklicherweise kann »softraid« mit dieser Situation sehr gut umgehen, da es
die Laufwerke als »frei schwebend« betrachtet, und wird daher deine Verbünde
erfolgreich wiederherstellen.
Das Startlaufwerk deiner Maschine jedoch muss startfähig sein, und wenn du
gerade erst Änderungen an deiner Wurzelpartition vorgenommen hast, bevor du in
diese Situation geraten bist, so möchtest du sicherlich nicht aus einem Irrtum
heraus von deiner »altroot«-Partition starten.

<h3>14.21.5 - »softraid crypto«</h3>

Das Einrichten von kryptographischen softraid(4) Datenträgern ist ziemlich
einfach:

<ul>
<li>Erzeuge die gewünschte Partition mit disklabel(8) als Typ RAID.
<li>Lösche den Beginn der Partition, wie oben beschrieben.
<li><tt># <b>bioctl -c C -l /dev/sd0m softraid0</b><br>
New passphrase: <b><i>My Crypto Pass Phrase</i></b><br>
Re-type passphrase: <b><i>My Crypto Pass Phrase</i></b><br>
softraid0: CRYPTO volume attached as sd1</tt>
<li>fdisk(8), disklabel(8) und newfs(8) diesen neuen Datenträger, sd1, wie
	gewünscht.
</ul>

Nachdem dies eingerichtet ist, kannst du den »crypto«-Datenträger, wenn
gewünscht, freischalten, und zwar mit:

<blockquote><pre>
# <b>bioctl -c C -l /dev/sd1m softraid0</b>
Passphrase: <b><i>My Crypto Pass Phrase</i></b>
softraid0: CRYPTO volume attached as sd1
</pre></blockquote>

Danach kannst du die Partitionen des verschlüsselten Datenträgers wie üblich in
das System einhängen.

<p>
Um den verschlüsselten Datenträger auszuhängen (und ihn damit wieder
unbenutzbar zu machen), hänge alle eingehängten Dateisysteme aus und mache
Folgendes (angenommen, der verschlüsselte Datenträger wäre sd1):

<blockquote><pre>
# <b>bioctl -d sd1</b>
</pre></blockquote>

Die entsprechende Handbuchseite sieht ein wenig beängstigend aus, da
beschrieben wird, dass das Kommando -d den Datenträger »löscht«, aber im Falle
von »crypto« wird einzig und alleine der verschlüsselte Datenträger
deaktiviert, sodass solange nicht wieder auf ihn zugegriffen werden kann, bis
er mit der Passphrase erneut aktiviert wird.

<p>
Es sind viele andere Optionen für »softraid« verfügbar, neue Eigenschaften
werden hinzugefügt und Verbesserungen gemacht, sodass eine Konsultation der
Handbuchseiten von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8"
>bioctl(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4"
>softraid(4)</a> auf deinem System empfohlen wird.

<h4>Ich habe meine Passphrase vergessen!</h4>

Bedaure.
Dies ist echte Verschlüsselung, es gibt keinerlei Hintertür oder ein
magisches Entriegelungswerkzeug.
Solltest du deine Passphrase vergessen, so sind deine auf dem
»softraid-crypto«-Datenträger gespeicherten Daten unbenutzbar geworden.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq13.html">[Zum Kapitel 13 - Multimedia]</a>
<a href= "faq15.html">[Zum Kapitel 15 - Pakete und Portierungen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.240 ]<br>
$Translation: faq14.html,v 1.120 2013/11/01 17:42:27 steffen Exp $<br>
-->
$OpenBSD: faq14.html,v 1.101 2013/11/01 18:04:04 ajacoutot Exp $
</small>

</body>
</html>
@


1.101
log
@Sync with Steelix CVS
@
text
@d3285 1
a3285 1
$OpenBSD$
@


1.100
log
@Sync with Steelix CVS
@
text
@d1141 1
a1141 1
OpenBSD 5.3 (GENERIC) #50: Tue Mar 12 18:35:23 MDT 2013
d3282 2
a3283 2
Originally [OpenBSD: faq14.html,v 1.239 ]<br>
$Translation: faq14.html,v 1.119 2013/10/28 10:03:03 steffen Exp $<br>
@


1.99
log
@Sync with Steelix CVS
@
text
@d2824 1
a2824 1
machen, und oft zwecklos, das ein nicht unbeträchtlicher Teil der PC-Hardware
d2827 7
a2833 3
Sogar Hardware, die von anderen Laufwerken starten KANN, hat oft
Schwierigkeiten festzustellen, wann ein Laufwerk einen Zwischenfall hatte, und
daraufhin vermeidet, davon zu starten.
a3206 3
OpenBSD's »<a href="#altroot">altroot</a>«-System kann für einige Anwendungen
sehr viel BESSER sein, da es eine Kopie der alten Konfigurationsinformationen
vorhält, für den Fall, dass eine Änderung nicht wie gewünscht funktioniert.
d3283 1
a3283 1
$Translation: faq14.html,v 1.118 2013/10/07 19:29:51 steffen Exp $<br>
@


1.98
log
@Sync with Steelix CVS
@
text
@a2829 3
OpenBSD's »<a href="#altroot">altroot</a>«-System kann für einige Anwendungen
BESSER sein, da es eine Kopie alter Konfigurationsdaten vorhält, sollte ein
Wechsel nicht wie erwartet funktionieren.
d3281 2
a3282 2
Originally [OpenBSD: faq14.html,v 1.238 ]<br>
$Translation: faq14.html,v 1.117 2013/08/10 16:21:07 steffen Exp $<br>
@


1.97
log
@Sync with Steelix CVS
@
text
@d2791 2
a2792 2
Bevor du eine RAID-Lösung implementierst, solltest du verstehen was es für dich
tun kann, und was nicht.
d2796 1
a2796 1
Laufwerksausfall hinübergeleitet.
d2872 5
a2876 4
Du kannst die RAID-Partitionen einfach vorerzeugen und dem
Installationsprogramm den Rest überlassen, jedoch ist es vielleicht einfacher,
sowohl dein Wurzelverzeichnis, als auch die Auslagerungs- und RAID-Partitionen
zu erzeugen, bevor du das Installationsprogramm startest.
d3284 2
a3285 2
Originally [OpenBSD: faq14.html,v 1.236 ]<br>
$Translation: faq14.html,v 1.116 2013/08/05 10:16:59 steffen Exp $<br>
@


1.96
log
@Sync with Steelix CVS
@
text
@d3102 3
a3104 3
Dies ist der Existenzgrund für RAID -- wenn Laufwerke niemals ausfallen würden,
so würdest du deinem System nicht die Verkomplizierung durch RAID zukommen
lassen!
d3108 2
a3109 2
Strategien zu verstehen, und das WARUM, so kannst du sie hoffentlich nutzen, um
aus jedweder Situation einen rettenden Weg zu finden.
d3112 2
a3113 2
Behalte im Hinterkopf das Ausfälle oft nicht einfach sind.
Der Author dieses Artikels hatte einen Kurzschluss an der Stromzuführung eines
d3150 1
a3150 1
Wenn du bereit dazu bist, das System zu reparieren, so wirst du das
d3153 1
a3153 1
Angenommen dein RAID-Datenträger is <tt>sd0</tt>, und du ersetzt das
d3170 2
a3171 2
wenn das Primäre ausgefallen, aber immer noch angeschlossen ist, es sei denn es
ist so tot, dass es nicht erkannt wird.
d3284 1
a3284 1
$Translation: faq14.html,v 1.114 2013/07/23 08:47:59 steffen Exp $<br>
@


1.95
log
@Sync with Steelix CVS
@
text
@d3075 1
a3075 1
Aus diesem Grunde ist es sehr wichtig, <a href="faq14.html">DUID</a>s
d3283 2
a3284 2
Originally [OpenBSD: faq14.html,v 1.235 ]<br>
$Translation: faq14.html,v 1.113 2013/07/15 09:36:37 steffen Exp $<br>
@


1.94
log
@Sync with Steelix CVS
@
text
@d2846 5
a2850 3
TODO Softraid disk space can be created using free (or added!) chunks of<br>
TODO disk space after install, but that is just a special (and simple)<br>
TODO case of adding softraid during install.
d2872 4
a2875 3
TODO You can just pre-create the just the RAID partitions and let the<br>
TODO installer do the rest, but it is probably easier to create your root,<br>
TODO swap and RAID partitions before invoking the installer.
d3229 1
a3229 1
# <b>bioctl -c C -l /dev/sd1m</b>
d3283 2
a3284 2
Originally [OpenBSD: faq14.html,v 1.234 ]<br>
$Translation: faq14.html,v 1.112 2013/06/04 21:32:54 steffen Exp $<br>
@


1.93
log
@Sync with Steelix CVS
@
text
@d76 1
d2743 1
a2743 1
werden, was mit Hilfe von <a href="#softraid">softraid</a>-Medien,
d2766 500
d3280 2
a3281 2
Originally [OpenBSD: faq14.html,v 1.232 ]<br>
$Translation: faq14.html,v 1.111 2013/05/31 18:07:33 steffen Exp $<br>
@


1.92
log
@Sync with Steelix CVS
@
text
@d74 2
d2702 62
d2779 2
a2780 2
Originally [OpenBSD: faq14.html,v 1.230 ]<br>
$Translation: faq14.html,v 1.110 2013/05/11 11:41:55 steffen Exp $<br>
@


1.91
log
@Sync with Steelix CVS
@
text
@a764 4
Mounte die neue Platte unter /mnt und
benutze <tt>cpio -pdum</tt>, um /usr/local in das Verzeichnis /mnt zu
kopieren. Passe die Datei

d2716 1
a2716 1
$Translation: faq14.html,v 1.109 2013/05/01 16:30:37 steffen Exp $<br>
@


1.90
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2012 by OpenBSD.">
d1089 1
a1089 1
>> OpenBSD/i386 BOOT 3.18
d1132 1
a1132 1
>> OpenBSD/i386 BOOT 3.18
d1140 1
a1140 1
Copyright (c) 1995-2012 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1142 1
a1142 1
OpenBSD 5.3 (GENERIC) #42: Fri Feb  1 10:04:16 MDT 2013
d1388 1
a1388 4
>fdisk(8)</a> wird normalerweise eine Laufwerksgröße melden, die der
tatsächlichen Größe modulo 2&nbsp;TB entspricht, sodass dein 2.7&nbsp;TB
Laufwerk (das dir als 3&nbsp;TB verkauft wurde) in fdisk(8) als zirka
700&nbsp;GB großes Laufwerk auftauchen wird.
d2719 2
a2720 2
Originally [OpenBSD: faq14.html,v 1.229 ]<br>
$Translation: faq14.html,v 1.108 2013/05/01 13:35:07 steffen Exp $<br>
@


1.89
log
@Sync with Steelix CVS
@
text
@d1142 1
a1142 1
OpenBSD 5.2 (GENERIC) #278: Wed Aug  1 10:04:16 MDT 2012
d2723 1
a2723 1
$Translation: faq14.html,v 1.107 2013/02/21 11:27:20 steffen Exp $<br>
@


1.88
log
@Sync with Steelix CVS
@
text
@d2722 2
a2723 2
Originally [OpenBSD: faq14.html,v 1.228 ]<br>
$Translation: faq14.html,v 1.106 2013/02/13 19:10:41 steffen Exp $<br>
@


1.87
log
@Sync with Steelix CVS
@
text
@d2722 2
a2723 2
Originally [OpenBSD: faq14.html,v 1.227 ]<br>
$Translation: faq14.html,v 1.105 2013/01/14 11:20:36 steffen Exp $<br>
@


1.86
log
@Sync with Steelix CVS
@
text
@d756 10
a765 1
/usr/local auslagern willst? Mounte die neue Platte unter /mnt und
d768 6
a773 3
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
so an, dass die /usr/local-Partition nun /dev/sd2d ist (deine frisch
formatierte Partition). Beispiel:
d2722 2
a2723 2
Originally [OpenBSD: faq14.html,v 1.226 ]<br>
$Translation: faq14.html,v 1.104 2012/12/28 17:59:22 steffen Exp $<br>
@


1.85
log
@Sync with Steelix CVS
@
text
@d460 1
a460 1
<a href="faq4.html#Disks">Festplatte(n) einrichten</a>, das Teil der
d2710 2
a2711 2
Originally [OpenBSD: faq14.html,v 1.225 ]<br>
$Translation: faq14.html,v 1.103 2012/11/01 20:33:44 steffen Exp $<br>
@


1.84
log
@Sync with Steelix CVS
@
text
@d1077 1
a1077 1
>> OpenBSD/i386 BOOT 3.17
d1120 1
a1120 1
>> OpenBSD/i386 BOOT 3.17
d1130 1
a1130 1
OpenBSD 5.1 (GENERIC) #160: Sun Feb 12 09:46:33 MST 2012
d2710 2
a2711 2
Originally [OpenBSD: faq14.html,v 1.224 ]<br>
$Translation: faq14.html,v 1.102 2012/06/29 09:47:13 steffen Exp $<br>
@


1.83
log
@Sync with Steelix CVS
@
text
@d2710 2
a2711 2
Originally [OpenBSD: faq14.html,v 1.223 ]<br>
$Translation: faq14.html,v 1.101 2012/06/06 10:31:44 steffen Exp $<br>
@


1.82
log
@Sync with Steelix CVS
@
text
@d2710 2
a2711 2
Originally [OpenBSD: faq14.html,v 1.222 ]<br>
$Translation: faq14.html,v 1.100 2012/06/05 09:46:12 steffen Exp $<br>
@


1.81
log
@Sync with Steelix CVS
@
text
@d1331 2
a1332 1
vorhanden ist. Dateisysteme nur lesend oder gar nicht gemountet zu
d1335 3
a1343 7
<p>
Wenn man eines Tages Dateisysteme mit etwas mehr als 1&nbsp;TB unter
Verwendung von Standardfragment- und Blockgrößen hat, wird fsck
1&nbsp;GB RAM benötigen; das ist das Applikationslimit unter OpenBSD.
Größere Fragmente und/oder Blöcke werden die Anzahl Inodes verringern
und größere Dateisysteme ermöglichen.

d1372 29
d2710 2
a2711 2
Originally [OpenBSD: faq14.html,v 1.221 ]<br>
$Translation: faq14.html,v 1.99 2012/05/22 11:09:06 steffen Exp $<br>
@


1.80
log
@Sync with Steelix CVS
@
text
@d481 1
a481 1
uid: d920a43a5a56ad5f
d2045 1
a2045 1
uid: d920a43a5a56ad5f
d2684 2
a2685 2
Originally [OpenBSD: faq14.html,v 1.219 ]<br>
$Translation: faq14.html,v 1.97 2012/05/01 17:47:05 tobias Exp $<br>
@


1.79
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2011 by OpenBSD.">
d1128 1
a1128 1
Copyright (c) 1995-2008 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d1130 1
a1130 1
OpenBSD 5.0 (GENERIC) #43: Wed Aug 17 10:10:52 MDT 2011
d1275 1
a1275 2
 <li>Du aktualisiert und erstellst deinen eigenen Kernel, was auch
 immer, und kopierst deinen neuen /bsd über den alten.
d2684 2
a2685 2
Originally [OpenBSD: faq14.html,v 1.218 ]<br>
$Translation: faq14.html,v 1.96 2012/04/19 18:42:36 steffen Exp $<br>
@


1.78
log
@Sync with Steelix CVS
@
text
@d1804 6
a1809 6
Um ein Diskimage (ISO-Images, Diskimages, die mit dd erstellt wurden
etc.) unter OpenBSD zu mounten, musst du ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>-Device
konfigurieren. Zum Beispiel, wenn du ein ISO-Image unter
<i>/tmp/ISO.image</i> hast, würdest du die folgenden Schritte machen,
um es zu mounten:
d1822 1
a1822 1
Um das Image wieder zu unmounten, benutze die folgenden Kommandos.
d2686 1
a2686 1
$Translation: faq14.html,v 1.95 2012/02/02 14:11:23 steffen Exp $<br>
@


1.77
log
@Sync with Steelix CVS
@
text
@d1380 3
a1382 4
Aktuelle Versionen von OpenBSD (3.5 und später) verfügen über einen
sehr robusten Bootloader, der mit den unterschiedlichen
Plattengeometrien besser umgehen kann als der frühere Bootloader.
Allerdings sind beide empfindlich gegenüber der Position von
d1387 7
a1393 5
hochfahren. Um den Bootblock zu reparieren, damit du wieder normal
booten kannst, lege einfach eine Bootdiskette in dein Diskettenlaufwerk
ein und gib am Bootprompt »b hd0a:/bsd« ein, um ihn zu zwingen, von der
ersten Festplatte zu booten (und nicht von der Diskette). Deine Maschine
sollte normal booten.
d1409 9
a1417 10
<p>
Wenn eine neuere Version des Bootblocks benötigt wird, wirst du diese
selber kompilieren müssen. Und das geht so:

<blockquote><pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (oder wie deine Festplatte auch immer heißen mag)
</pre></blockquote>
d2685 2
a2686 2
Originally [OpenBSD: faq14.html,v 1.217 ]<br>
$Translation: faq14.html,v 1.94 2012/01/31 21:20:31 tobias Exp $<br>
@


1.76
log
@Sync with Steelix CVS
@
text
@d428 1
a428 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>-Manualseite
d582 1
a582 1
lassen. »M« gibt die Manualseite von disklabel(8) aus.
d1212 1
a1212 1
>biosboot(8)</a>-Manualseite ausführlich besprochen.
d1505 1
a1505 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>-Manualseite
d1525 1
a1525 1
mt-Manualseite an, wenn du mehr Informationen haben willst (wie etwa
d1546 1
a1546 1
usw. Du findest in der Manualseite zu dump eine ausführlichere
d1629 1
a1629 1
wiederherstellen willst, sieh dir die restore-Manualseite genau an und
d1831 1
a1831 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>-Manualseite.
d1979 1
a1979 1
Optionen für mount, konsultiere bitte die Manualseite zu
d1981 1
a1981 1
und die Manualseite zum mount-Kommando für das Dateisystem, das du
d2248 1
a2248 1
verwenden</a> und die Manualseite zu
d2645 1
a2645 1
des Systems gehen. Siehe auch die Manualseite von
d2686 1
a2686 1
$Translation: faq14.html,v 1.93 2012/01/21 17:24:03 steffen Exp $<br>
@


1.75
log
@Sync with Steelix CVS
@
text
@d33 2
a34 2
<li><a href="#NewDisk"    >14.4 - Hinzufügen weiterer Festplatten unter
    OpenBSD</a>
d38 6
a43 5
<li><a href="#LargeDrive" >14.8 - Welche Probleme treten bei großen
    Festplatten mit OpenBSD auf?</a>
<li><a href="#InstBoot"   >14.9 - Installieren von Bootblocks -
    i386/amd64-spezifisch</a>
<li><a href="#Backup"     >14.10 - Vorbereitung auf Katastrophen -
d47 9
a55 6
<li><a href="#NegSpace"   >14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich
    mehr als 100&nbsp;% von meinem Laufwerk belegt habe?</a>
<li><a href="#OhBugger"   >14.15 - Partitionen wiederherstellen, nachdem
    das Disklabel gelöscht wurde</a>
<li><a href="#foreignfs"  >14.16 - Kann ich auf Daten zugreifen, die auf
    anderen Dateisystemen als FFS liegen?</a>
d57 3
a59 2
  <li><a href="#foreignfsafter">14.16.1 - Die Partitionen sind nicht in meinem
      Disklabel verzeichnet!  Was kann ich tun?</a>
d61 2
a62 2
<li><a href="#flashmem"   >14.17 - Kann ich ein Flash-Speicher-Gerät mit
    OpenBSD benutzen?</a>
d64 6
a69 6
  <li><a href="#flashmemPortable">14.17.1 - Flash-Speicher als portables
        Speichergerät</a>
  <li><a href="#flashmemBoot">14.17.2 - Flash-Speicher als startbarer
        Speicherplatz</a>
  <li><a href="#flashmemLive">14.17.3 - Wie kann ich ein startbares »Live«
        USB-Gerät erzeugen?</a>
d72 2
a73 2
<li><a href="#Async">     >14.19 - Warum verwenden wir keine »async«hrone
        Einhängemodi?</a>
d2686 1
a2686 1
$Translation: faq14.html,v 1.92 2012/01/14 14:00:53 steffen Exp $<br>
@


1.74
log
@Sync with Steelix CVS
@
text
@d2680 2
a2681 2
Originally [OpenBSD: faq14.html,v 1.216 ]<br>
$Translation: faq14.html,v 1.91 2012/01/11 20:53:12 steffen Exp $<br>
@


1.73
log
@Sync with Steelix CVS
@
text
@d4 1
a4 1
<title>14 - Platteneinrichtung</title>
d7 2
a8 2
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
d23 1
a23 1
<a href= "faq15.html">[Zum Kapitel 15 - Packages und Ports]</a>
d26 1
a26 1
<h1><font color="#e00000">14 - Platteneinrichtung</font></h1><hr>
d30 1
a30 1
<li><a href="#disklabel"  >14.1 - Benutzung von OpenBSDs disklabel(8)</a>
d32 2
a33 1
<li><a href="#NewDisk"    >14.3 - Hinzufügen von weiteren Festplatten unter
d35 4
a38 4
<li><a href="#SwapFile"   >14.4 - Wie man in eine Datei swappt</a>
<li><a href="#SoftUpdates">14.5 - Softupdates</a>
<li><a href="#Boot386"    >14.6 - Wie bootet OpenBSD/i386?</a>
<li><a href="#LargeDrive" >14.7 - Welche Probleme treten bei großen
d40 1
a40 1
<li><a href="#InstBoot"   >14.8 - Installieren von Bootblocks -
d42 4
a45 6
<li><a href="#Backup"     >14.9 - Sich auf das Schlimmste vorbereiten:
    Backups und Wiederherstellen von Band.</a>
<li><a href="#MountImage" >14.10 - Diskimages unter OpenBSD mounten</a>
<li><a href="#pciideErr"  >14.11 - Hilfe! Ich erhalte Fehler mit
    IDE-DMA!</a>
<li><a href="#RAID"       >14.13 - RAID-Optionen unter OpenBSD</a>
d47 1
a47 1
    mehr als 100&nbsp;% von meiner Platte belegt habe?</a>
d53 2
a54 2
  <li><a href="#foreignfsafter">14.16.1 - Die Partitionen befinden sich
      nicht in meinem Disklabel! Was kann ich tun?</a>
d56 326
a381 6
<li><a href="#flashmem"   >14.17 - Kann ich ein Gerät mit Flashspeicher
    unter OpenBSD benutzen?</a>
<li><a href="#DiskOpt"    >14.18 - Die Festplattenleistung
    optimieren</a>
<li><a href="#Async">     >14.19 - Warum verwenden wir keine »async
    mounts«?</a>
a383 1
<hr>
d386 1
a386 1
<h2>14.1 - Benutzung von OpenBSDs disklabel(8)</h2>
d392 2
a393 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>-Manualseite.
d399 1
a399 1
<a href="../../amd64.html">amd64</a>,
d472 1
a472 3
# <b>disklabel wd0</b> &lt;-- <i>Oder ein anderes Device, das du dir anzeigen lassen möchtest</i>
# Inside MBR partition 3: type A6 start 63 size 29880837
# /dev/rwd0c:
d475 2
a476 1
label: Maxtor 51536H2
d482 5
a486 9
cylinders: 16383
total sectors: 29888820
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0
d489 8
a496 8
#             size        offset  fstype [fsize bsize  cpg]
  a:        614817            63  4.2BSD   2048 16384  328 # Cyl     0*-   609
  b:        409248        614880    swap                   # Cyl   610 -  1015
  c:      29888820             0  unused      0     0      # Cyl     0 - 29651*
  d:       6291936       1024128  4.2BSD   2048 16384  328 # Cyl  1016 -  7257
  e:        409248       7316064  4.2BSD   2048 16384  328 # Cyl  7258 -  7663
  f:       1024128       9822960  4.2BSD   2048 16384  328 # Cyl  9745 - 10760
  h:       2097648       7725312  4.2BSD   2048 16384  328 # Cyl  7664 -  9744
d532 4
a535 4
offset: [10847088]
size: [19033812] 2g
Rounding to nearest cylinder: 4194288
FS type: [4.2BSD]
d537 10
a546 23
device: /dev/rwd0c
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total bytes: 14594.2M
free bytes: 7245.9M
rpm: 3600

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        300.2M          0.0M  4.2BSD   2048 16384  328 # Cyl     0*-   609
  b:        199.8M        300.2M    swap                   # Cyl   610 -  1015
  c:      14594.2M          0.0M  unused      0     0      # Cyl     0 - 29651*
  d:       3072.2M        500.1M  4.2BSD   2048 16384  328 # Cyl  1016 -  7257
  e:        199.8M       3572.3M  4.2BSD   2048 16384  328 # Cyl  7258 -  7663
  f:        500.1M       4796.4M  4.2BSD   2048 16384  328 # Cyl  9745 - 10760
  h:       1024.2M       3772.1M  4.2BSD   2048 16384  328 # Cyl  7664 -  9744
  k:       2048.0M       5296.4M  4.2BSD   2048 16384   16 # Cyl 10761 - 14921
d548 1
a548 1
Write new label?: [y]
d598 9
a606 121
<li>(i386, amd64) <b>Belasse die erste Spur ungenutzt:</b>
Auf einigen Plattformen muss die erste logische Spur ungenutzt
bleiben - sowohl von disklabel(8) als auch von fdisk(8). Dieser
Leitfaden wird manchmal umformuliert in »beginne mit deinen Partitionen
beim Sektor 63«, doch ist das NUR wahr, wenn es sich dabei auch um die
Größe einer Spur auf deiner Hardware handelt. Nimm niemals an, dass
das immer der Fall ist - disklabel wird dir mitteilen, wie viele Sektoren
vermutlich pro Spur vorliegen. Viele andere Plattformen gehen davon
aus, dass OpenBSD-Partitionen beim Sektor 0 beginnen.

<li><b>Devices ohne Disklabel:</b>
Falls ein Device momentan kein OpenBSD-Disklabel hat, dafür aber andere
Dateisysteme (zum Beispiel eine Platte mit zuvor angelegtem
FAT32-Dateisystem) wird der OpenBSD-Kernel ein Disklabel im Speicher
»anlegen«. Hiermit ist eine Grundlage für ein OpenBSD-Disklabel gegeben,
das dann auf die Platte geschrieben werden kann. Fall ein Disklabel
jedoch erstellt und auf die Platte geschrieben wurde und danach ein
Dateisystem angelegt wird, das nicht zu OpenBSD gehört, wird das
Disklabel nicht automatisch aktualisiert. Du musst dies manuell machen,
wenn du möchtest, dass OpenBSD auf dieses Dateisystem zugreifen kann.
Weitere Informationen hierüber befinden sich
<a href="faq14.html#foreignfsafter">weiter unten</a>.

<li><b>»q« gegen »x«:</b>
Aus historischen Gründen speichert »q« im kommandobasierten Editormodus
alle Änderungen ab und verlässt das Programm - »x« hingegen verlässt
das Programm, ohne zu speichern. Dies ist genau das Gegenteil von dem,
was viele Leute aus anderen Umgebungen gewohnt sind. Vor dem Speichern
von Änderungen warnt disklabel(8) jedoch, sodass »x« schnell und
ohne jeglichen Kommentar ausgeführt wird.

</ul>


<a name="fdisk"></a>
<h2>14.2 - Benutzung von OpenBSDs fdisk(8)</h2>

Lies zuerst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Manualseite.

<p>
Auf einigen Plattformen (i386, amd64, macppc, zaurus und armish) wird
fdisk(8) verwendet, um eine Partition zu erstellen, die vom
Boot-ROM des Systems erkannt werden kann und die Disklabelpartitionen
von OpenBSD aufnehmen wird. Andere Plattformen benötigen oder verwenden
fdisk(8) nicht. Mit fdisk(8) kann auch der Masterbootrecord (MBR)
editiert werden, wodurch alle Betriebssysteme auf einem Computer
betroffen sind. Im Gegensatz zu anderen fdisk-ähnlichen Programmen
einiger anderen Betriebssysteme nimmt OpenBSDs fdisk an, dass du weißt
was du tust, und wird dich die meiste Zeit machen lassen was du willst
- somit steht dir ein sehr mächtiges Werkzeug zur Verfügung.
Andererseits lässt es dich eben auch Dinge machen, die du entweder
nicht machen solltest oder die du auch nicht gar nicht vorhattest.
Bei der Verwendung ist also Vorsicht geboten.

<p>
Normalerweise wird nur eine fdisk-Partition für OpenBSD auf einer Platte
angelegt. Diese Partition wird dann mit
<a href="#disklabel">disklabel</a> in weitere
OpenBSD-Dateisystempartitionen aufgeteilt.

<p>


<p>
Um dir nur deine Partitionstabelle mit fdisk anzugucken, verwende:

<blockquote><pre>
# <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Was dann eine ähnliche Ausgabe wie diese hier erzeugt:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre></blockquote>

<p>
In diesem Beispiel betrachten wir die Ausgabe des ersten
SCSI-Laufwerks. Wir können die OpenBSD-Partition (A6) und ihre Größe
sehen. Der * sagt uns, dass die OpenBSD-Partition eine bootbare
Partition ist.

<p>
Im vorherigen Beispiel haben wir uns die Informationen nur angesehen.
Was aber, wenn wir unsere Partitionstabelle verändern wollen? Nun, dazu
müssen wir zunächst die Option <b>-e</b> benutzen. Diese bringt uns dann
zu einer Kommandozeile, die uns mit fdisk interagieren lässt.

<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        swap            Swap two partition entries
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt;
</pre></blockquote>

<p>
d608 12
a619 2
<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe
der Option <b>-e</b> benutzen kann.
d621 7
a627 42
<ul>
<li><b>help</b>  Zeigt eine Liste der Kommandos an, die fdisk im
interaktiven Editmodus versteht.
<li><b>reinit</b>  Initialisiert die momentane im Speicher befindliche
Kopie des Bootblocks. Hiermit kannst du auf elegante und schnelle Weise
eine - die gesamte Platte in Anspruch nehmende - OpenBSD-Partition
erstellen, den Bootcode aktualisieren und - im Allgemeinen gesagt -
das System für OpenBSD vorbereiten (und nichts weiter außer OpenBSD).
<li><b>disk</b>  Zeigt die momentane Plattengeometrie an, die fdisk
ermittelt hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du
willst.
<li><b>setpid</b>  Ändert eine Partitionsidentifizierung des angegebenen
Partitionstabelleneintrages. Dieses Kommando ist insbesondere nützlich,
um eine existierende Partition OpenBSD wieder zugänglich zu machen.
<li><b>edit</b>  Ändere eine ausgewählte Plattengeometrie in der Kopie
des momentanen Bootblocks.  Das geschieht entweder im
BIOS-Geometriemodus oder in Sektoroffsets und -größen.
<li><b>flag</b>  Macht den jetzigen Partitionstabelleneintrag bootbar.
Nur ein Eintrag kann gleichzeitig bootbar sein. Wenn du von einer
erweiterten Partition booten willst, musst du auch den entsprechenden
Eintrag als bootbar markieren
(OpenBSD selbst kann nur von einer primären Partition gebootet werden,
auch wenn andere Partitionen als aktiv markiert werden können).
<li><b>update</b>  Bringt den Maschinencode in der Speicherkopie des
momentanen Bootblocks auf den aktuellen Stand.
<li><b>select</b>  Wählt und lädt den Bootblock, auf den der Eintrag der
erweiterten Partitionstabelle im momentanen Bootblock zeigt.
<li><b>swap</b>  Tauscht zwei MBR-Einträge miteinander aus, sodass du
den MBR neu ordnen kannst.
<li><b>print</b>  Gibt die momentan im RAM befindliche und gewählte
Kopie des Bootblocks und seinen MBR auf dem Bildschirm aus.
<li><b>write</b>  Schreibt die RAM-Version des Bootblocks auf
die Platte. Du wirst um eine Bestätigung gebeten.
<li><b>exit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt.
<li><b>quit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt. Im Gegensatz zu exit schreibt diese
Variante den modifizierten Block auf die Platte.
<li><b>abort</b>  Verlässt das Programm ohne Änderungen zu speichern.
</ul>
d629 5
a633 23
<h3>Tipps und Tricks für fdisk</h3>
<ul>
<!-- <li>Auf OpenBSD-Plattformen, die fdisk verwenden, solltest du die
erste Spur ungenutzt lassen. Hiermit lässt du Platz für den
Masterbootrecord, in dem sich die fdisk-Partitionstabelle befindet
(bin mir nicht sicher, ob das wahr ist). -->
<li>fdisk(8) bietet die Möglichkeit an, die Partitionen sowohl direkt
in Sektoren als auch im Zylinder/Kopf/Sektor-Format anzugeben. Für beide
Optionen gibt es gute Gründe - einige Aufgaben werden auf die eine Weise
leichter gelöst, andere auf die andere. Beschränke dich nicht darauf,
nur eine von beiden einzusetzen.
<li>Eine völlig geleerte Platte setzt voraus, dass der Bootcode des
Masterbootrecords geschrieben werden muss, bevor von ihr gebootet werden
kann. Du möchtest den vorhandenen Bootcode eventuell sowieso erneuern
falls dir seine Herkunft unbekannt ist.
<li>Wenn dein System eine Verwaltungs- oder Diagnosepartition besitzt,
dann wird dazu geraten, diese bestehen zu lassen oder sie VOR der
Installation von OpenBSD zu installieren.
<li>Aus historischen Gründen speichert »q« Änderungen ab und verlässt
das Programme - »x« hingegen verlässt das Programme ohne zu speichern.
Dies ist genau das Gegenteil von dem, was Leute von anderen Umgebungen
her gewohnt sind. Vor dem Speichern von Änderungen fragt fdisk(8) nicht
nach - sei bei der Verwendung also sorgfältig.
d639 1
a639 1
<h2>14.3 - Hinzufügen von weiteren Festplatten unter OpenBSD</h2>
d652 2
a653 1
weiter unten werden wir dem System ein drittes SCSI-Laufwerk hinzufügen.
d687 1
a687 1
>bc(1)</a>.
d721 1
a721 1
# <b>newfs sd2a </b>
d737 1
a737 1
# <b>mount /dev/sd2a /u</b>
d746 1
a746 1
/dev/sd2a /u ffs rw 1 1
d755 1
a755 1
so an, dass die /usr/local-Partition nun /dev/wd1a ist (deine frisch
d759 1
a759 1
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
d769 61
d831 6
a836 2
<a name="SwapFile"></a>
<h2>14.4 - Wie man in eine Datei swappt</h2>
a837 1
<p>
a840 9
cshs <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>
oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>
zu erhöhen.)

<p>
In eine Datei zu swappen benötigt keinen angepassten Kernel, obwohl das
weiterhin gemacht werden könnte, zeigt dir diese FAQ, wie man den
Swapbereich auf beide Arten hinzufügen kann.
d842 14
a855 1
<h3>In eine Datei swappen.</h3>
d858 1
a858 2
In eine Datei zu swappen ist der einfachste und schnellste Weg, um
zusätzlichen Swap zu bekommen. Die Datei darf aber nicht auf einem
a928 65
<h3>Swappen über ein vnode-device</h3>

<p>
Dies ist eine dauerhaftere Lösung, um mehr Swapbereich zu erhalten.
Um in eine Datei zu swappen, erzeuge zunächst einen Kernel mit vnd0c als
Swap. Wenn du wd0a als root-Dateisystem hast und wd0b als bisherigen
Swap, benutze diese Zeile in deiner Kernelkonfigurationsdatei (wenn du
dir nicht sicher bist, siehe dir das Kapitel »Einen neuen Kernel
kompilieren« in dieser FAQ an):

<blockquote><pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre></blockquote>

<p>
Nachdem das erledigt ist, muss die Datei erzeugt werden, in die geswappt
werden soll. Du solltest dies mit dem selben Kommando wie in den
vorherigen Beispielen machen.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Da deine Datei jetzt an ihrem Platz ist, musst du die Datei in deine
<i>/etc/fstab</i> eintragen. Hier ist eine Beispielzeile, mit der man
dieses Device beim Booten als Swap benutzt.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0
</pre></blockquote>

<p>
An diesem Punkt angekommen musst du deinen Computer neustarten, sodass
die Änderungen am Kernel Effekt haben. Nachdem das passiert ist, ist es
an der Zeit, das Device als Swap zu konfigurieren. Dazu wirst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
benutzen.

<blockquote><pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre></blockquote>

<p>
Als letzten Schritt musst du den Swap auf diesem Gerät noch einschalten.
Wir machen das genau wie in dem Beispiel oben mit swapctl(8). Und zuletzt
prüfen wir wieder, ob es auch korrekt in unsere Liste der Swapdevices
eingetragen wurde.

<blockquote><pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>


d930 1
a930 1
<h2>14.5 - Softupdates</h2>
d964 1
d966 5
a970 4
<h2>14.6 - Wie bootet OpenBSD/i386?</h2>
Der Bootprozess für OpenBSD/i386 ist nicht einfach und verstehen, wie es
funktioniert, kann nützlich sein, um ein Problem zu lösen, wenn Dinge
nicht laufen. Während dem Bootprozess gibt es vier Schlüsselereignisse:
d972 3
a974 2
<li><b><i>Master Boot Record (MBR):</i></b> Der Master Boot Record ist
der erste physikalische Sektor (512 Byte) auf der Platte. Er beinhaltet
d979 8
a986 6
(einschließlich der Partitionstabelle). Es ist äußerst wichtig, die
Bedeutung von »initialize the MBR« zu verstehen - in der Terminologie
von OpenBSD würde es den gesamten MBR-Sektor neu schreiben, nicht nur
den Code, so wie es auf anderen Systemen der Fall sein könnte. Du wirst
das nur selten machen wollen. Verwende stattdessen fdisk(8)s
Kommandozeilenoption -u (»<tt>fdisk -u wd0</tt>«).
d989 3
a991 2
Obwohl OpenBSD einen MBR beinhaltet, wirst du nicht gezwungen, ihn zu
verwenden, da so gut wie jeder MBR OpenBSD booten kann. Der MBR wird von
d1018 1
d1020 6
a1025 5
Der Partition Boot Record, auch der PBR oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
genannt wird (benannt nach dem Namen der Datei, der den Code
beinhaltet), ist der erste physikalische Sektor der OpenBSD-Partition
auf der Platte. Der PBR ist der Firststage-Bootloader für OpenBSD.
a1053 2
Das ältere (vor v3.5) biosboot(8) zeigte die Nachricht »<tt>reading
boot...</tt>« an.
d1055 1
d1072 1
a1072 1
>> OpenBSD/i386 BOOT 2.10
d1100 1
d1115 1
a1115 1
>> OpenBSD/i386 BOOT 2.10
d1125 1
a1125 1
OpenBSD 4.4 (GENERIC) #1021: Tue Aug 12 17:16:55 MDT 2008
d1136 5
a1140 6
Plattform übernommen wurde UND du nicht mit Yes auf die Frage »Use
entire disk« Frage vom
<a href="faq4.html#Disks">Installationsprozess</a> geantwortet hast,
kann es sein, dass du mit einer Platte ohne gültigem MBR da stehst und
daher nicht in der Lage sein wirst zu booten, obwohl sie eine gültige
Partitionstabelle hat.
d1213 2
a1214 2
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
  Hale Landis' »How it Works«-Dokumente.
d1218 1
a1218 1
<h2>14.7 - Welche Probleme treten bei großen Festplatten mit OpenBSD
d1231 1
a1231 1
Eine neue 250 G große IDE-Festplatte kann unter Umständen nicht mit
d1236 2
a1237 1
Festplatte begegnen. Du musst die Fähigkeiten deiner Hardware
d1290 4
a1293 3
<p>
<b>Die gesamte root-Partition muss innerhalb des BIOS (oder Boot-ROM)
vom Computer adressierbaren Speicher liegen.</b>
d1345 2
a1346 2
2<sup>31</sup>-1 oder 2.147.483.647 Sektoren. Jeder dieser Sektoren ist
512 Byte groß, womit man ein kleines bisschen unter 1&nbsp;T liegt.
a1360 5
Bevor du Upgrades durchführst, setze alle FFS2-Partitionen auf »noauto«,
damit der Installationskernel sie nicht (miss)handelt (der eben keine
FFS2-Partitionen unterstützt).

<p>
d1365 4
a1368 4
Volumen. Viele wurden bisher einfach noch nicht getestet. Zu dem
Zeitpunkt, als dieser Text verfasst wurde, standen noch keine IDE- oder
SATA-Laufwerke mit eine Speicherkapazität über 1&nbsp;TB für Tests
bereit, sodass wir nicht sicher sagen können, ob alles perfekt läuft.
d1370 1
d1372 1
a1372 1
<h2>14.8 - Installieren von Bootblocks - i386/amd64-spezifisch</h2>
d1415 2
a1416 2
<h2>14.9 - Sich auf das Schlimmste vorbereiten: Backups und
Wiederherstellen von Band.</h2>
d1423 2
a1424 1
deiner Festplatten versagt oder einen Crash hat.
d1429 6
a1434 16
zu benutzen, die als Teil von OpenBSD ausgeliefert werden. Ein
fortgeschritteneres Werkzeug ist
<a href="http://www.amanda.org">Amanda</a>, das über
<a href="faq15.html#PkgMgmt">Packages</a> verfügbar ist und auch mehrere
Server auf ein Bandlaufwerk sichern kann. In den meisten Umgebungen sind
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
aber ausreichend. Wenn du aber mehrere Maschinen sichern willst,
ist Amanda auf jeden Fall einen Blick wert.

<p>
Die Beispiele in diesem Dokument benutzen sowohl SCSI-Festplatten als
auch Bänder. In einer Produktionsumgebung empfehlen wir SCSI und kein
IDE wegen der Art und Weise, wie IDE mit Badblocks umgeht. Das heißt
aber nicht, dass diese Informationen nutzlos sind, wenn du IDE benutzt,
sondern einzig deine Gerätenamen werden sich leicht unterscheiden. Zum
Beispiel wäre sd0a in einem IDE-basierten System wd0a.
d1452 5
a1456 3
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a -
also auf der SCSI-Festplatte 0, Partition a. Das /usr-Dateisystem
befindet sich auf sd0h - also SCSI-Festplatte 0, Partition h.
d1796 1
a1796 1
<h2>14.10 - Diskimages unter OpenBSD mounten</h2>
d1807 2
a1808 2
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
d1821 1
a1821 1
# <b>vnconfig -u svnd0</b>
d1828 1
d1830 1
a1830 1
<h2>14.11 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</h2>
d1834 3
a1836 7
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>
unterstützt werden, sind unzuverlässig. Bis vor kurzem wurden die
meisten Mainstreambetriebssysteme, die behaupteten, dass sie
DMA-Übertragungen mit IDE-Laufwerken unterstützen, nicht mit
standardmäßig aktivierter Unterstützung wegen unzuverlässiger Hardware
ausgeliefert. Nun werden viele dieser gleichen Maschinen mit OpenBSD
verwendet.
a1875 53

<a name="RAID"></a>
<h2>14.13 - RAID-Optionen unter OpenBSD</h2>
RAID (Redundant Array of Inexpensive Disks) gibt die Möglichkeit,
mehrere Laufwerke zu verwenden, um bessere Leistung, Kapazität und/oder
Redundanz zu erhalten, als man aus einem einzelnen Laufwerk herausholen
kann. Während eine vollständige Diskussion über die Vorteile und Risiken
von RAID außerhalb des Rahmens dieses Artikels liegt, existieren einige
Punkte, die so wichtig sind, dass sie nun besprochen werden sollten:

<ul>
<li>RAID hat nichts mit Backup zu tun.
<li>RAID allein wird die Ausfallzeit nicht eliminieren.
</ul>

Wenn diese Information neu für dich ist, ist das kein guter
Ausgangspunkt, um RAID zu erforschen.

<h3>Software Möglichkeiten</h3>
OpenBSD beinhaltet RAIDframe - eine software-basierte RAID-Lösung.
Dokumentation hierfür kann an folgenden Stellen gefunden werden:

<ul>
<li><a href="#Optraid">Plattenoptimierung, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe-Homepage</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">Manualseite
     für raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">Manualseite
     für raid(4)</a>
</ul>

<p>
Die root-Partition kann direkt von OpenBSD unter Verwendung der
Option Autoconfiguration von RAIDframe gespiegelt werden.

<p>
OpenBSD 3.7-stable und neuer beinhaltet ebenfalls Mirroring als
Funktionalität des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>-Treibers.
Dieses System wurde in den GENERIC-Kernel integriert und befindet sich
im bsd.rd-Kernel einiger Plattformen (amd64, hppa, hppa64, i386), so
dass es viel einfacher genutzt werden kann, obwohl es einige
Begrenzungen im Bezug auf das Neuerzeugen des Arrays hat.

Siehe:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">Manualseite
zu ccd(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">Manualseite
zu ccdconfig(8)</a>
</ul>

<h3>Hardwaremöglichkeiten</h3>
a1876 48
Viele OpenBSD-<a href="../../de/plat.html">Plattformen</a> beinhalten
Unterstützung für etliche Hardware-RAID-Produkte. Die Möglichkeiten
variieren von Plattform zu Plattform: Siehe die passende
Hardwareunterstützungsseite (<a href="../../de/plat.html">hier</a>
aufgelistet).

<p>
Eine andere Möglichkeit, die für viele Plattformen bereit steht, ist
eine der vielen Produkte, die mehrere Laufwerke dazu bringt, wie ein
großes IDE- oder SCSI-Laufwerk zu agieren und die dann in einen
standardmäßigen IDE- oder SCSI-Adapter gesteckt werden. Diese Geräte
können nahezu auf jeder Hardwareplattform funktionieren, die entweder
SCSI oder IDE verwenden.

<p>
Einige Hersteller dieser Produkte:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Hinweis: Dies sind nur Produkte, die von OpenBSD-Anwendern verwendet
und gemeldet wurden - dies ist weder eine Art Werbung noch ist es eine
ausführliche Liste.)

<h3>Keine Möglichkeit</h3>
<p>
Eine häufig gestellte Frage in den
<a href="../../de/mail.html">Mailinglisten</a> ist »Werden die
kostengünstigen IDE- oder SATA-RAID-Controller (wie zum Beispiel jene,
die die Highpoint-, Promise- oder Adaptec-HostRAID-Chips benutzen)
unterstützt?« Die Antwort ist »Nein«. Diese Karten und Chips sind nicht
echte Hardware-RAID-Controller sondern eher BIOS-assistierte Bots für
ein Software-RAID. Da OpenBSD bereits Software-RAID auf eine
hardwareunabhängige Art und Weise unterstützt, besteht kein großes
Verlangen bei den OpenBSD-Entwicklern, diese spezielle Unterstützung
für diese Karten zu implementieren.

<p>
Fast alle Onboard-SATA- oder -IDE-»RAID«-Controller sind von diesem
softwarebasierten Stil und funktionieren normalerweise einwandfrei als
SATA- oder IDE-Controller unter Verwendung des standardmäßigen
IDE-Treibers
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>).
Sie werden aber nicht als Hardware-RAID-System unter OpenBSD
funktionieren.

d1879 1
a1879 1
von meiner Platte belegt habe?</h2>
d1903 1
d1957 1
a1957 1

d1966 3
a1968 3
NTFS (Windows) und AmigaDOS. Einige von ihnen haben eingeschränkte - zum
Beispiel nur schreibgeschützte - Unterstützung.  Beachte, dass FreeBSDs
UFS2-Dateisystem nicht unterstützt wird.
d2008 1
a2008 1
hw.disknames=cd0,cd1,wd0,fd0,cd2
d2040 2
a2041 1
label: ST340016A
d2049 3
a2051 7
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0
d2055 14
a2068 14
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*
a2090 2
Einige werden jedoch nicht unterstützt, z.&nbsp;B. ist die
NTFS-Unterstützung experimentell und daher nicht im GENERIC.
d2122 1
d2124 2
a2125 2
<h3>14.16.1 - Die Partitionen sind nicht in meinem Disklabel! Was kann
ich tun?</h3>
d2201 1
a2201 1

d2203 3
a2205 2
<h2>14.17 - Kann ich ein Gerät mit Flashspeicher unter OpenBSD
benutzen?</h2>
d2221 1
a2221 1
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
d2239 1
a2239 2
<h3>Das Gerät ist neu/leer und du möchtest es nur mit OpenBSD
nutzen</h3>
d2270 2
a2271 2
<h3>Du hast das Speichergerät von jemandem erhalten, mit dem du Daten
austauschen möchtest</h3>
d2343 45
a2387 3
<p>
<a name= "DiskOpt"></a>
<h2>14.18 - Die Festplattenleistung optimieren</h2>
d2390 77
a2466 9
Die Festplattenleistung ist ein wichtiger Faktor in der
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multiuserumgebung beheimatet
(Benutzer aller Arten - von solchen, die sich einloggen, bis zu denen,
die Serverdienste nutzen). Datenspeicher brauchen ständige
Aufmerksamkeit; insbesondere, wenn deine Partition überläuft
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erhöhen
und Fehlertoleranz zu bieten.
a2467 6
<p>
<ul>
<li><a href="#Optccd">CCD</a> - Concatenated Disk Driver.
<li><a href="#Optraid">RAID</a>
<li><a href="#Optsoftu">Softupdates</a>
<li><a href="#Optmaxvnodes">Größe des namei()-Caches</a>
d2470 9
d2480 4
a2483 2
<a name="Optccd"></a>
<h3>14.18.1 - CCD</h3>
d2485 2
a2486 8
Die erste Option ist die Benutzung des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
- des Concatenated Disk Driver.
Dieser erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu
verwandeln (und damit kannst dafür sorgen, dass mehrere Festplatten wie
eine einzige aussehen). Dieses Konzept ist ähnlich wie das von LVM
(logical volume management), das in mehreren kommerziellen Unix-Arten
zu finden ist.
d2488 1
a2488 6
<p>
Wenn du GENERIC benutzt, ist ccd bereits eingeschaltet (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  Wenn du einen veränderten
Kernel benutzt, musst du ihn vielleicht wieder in deine
Kernelkonfiguration einfügen. Wie auch immer, auf jeden Fall muss sich
eine Zeile wie die folgende in deiner Konfigurationsdatei befinden:
d2490 9
a2498 3
<blockquote><pre>
<strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre></blockquote>
d2500 1
a2500 7
<p>
Das obige Beispiel gibt dir bis zu 4 ccd-Devices (virtuelle Platten).
Jetzt musst du festlegen, welche Partitionen auf deinen realen
Festplatten du in den ccd einbinden willst. Benutze disklabel, um diese
Partitionen als ccd-Typ zu markieren. Auf einigen Architekturen
erlaubt dir disklabel das vielleicht nicht. In diesem Fall markiere sie
einfach als FFS.
d2502 8
a2509 4
<p>
Wenn du ccd dazu benutzt, um mittels striping Leistung zu gewinnen,
solltest du wissen, dass du keine optimale Leistung bekommst, bis du das
gleiche Festplattenmodell mit den gleichen Disklabeleinstellungen benutzt.
d2511 1
a2511 11
<p>
Editiere /etc/ccd.conf, bis sie etwa so aussieht:
(Mehr Informationen über das Konfigurieren von ccd findest du unter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>
d2514 2
a2515 1
Um die Änderungen wirksam zu machen, führe das hier aus:
d2517 42
a2558 3
<blockquote><pre>
# ccdconfig -C
</pre></blockquote>
d2560 1
a2560 9
<p>
Solange /etc/ccd.conf existiert, wird sich ccd automatisch beim Booten
konfigurieren.
Jetzt hast du eine neue Festplatte (ccd0): eine Kombination von
/dev/sd2e und /dev/sd3e. Benutze disklabel einfach wie gewöhnlich, um
die Partition oder Partitionen zu erzeugen, die du benutzen willst.
Nutze erneut die Partition c nicht, um darauf irgendetwas zu speichern.
Stelle sicher, dass deine benutzten Partitionen mindestens einen
Zylinder vom Anfang der Disk weg ist.
d2563 2
a2564 13
<a name="Optraid"></a>
<h3>14.18.2 - RAID</h3>

Eine weitere Lösung ist
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
wofür du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
nutzen musst, um deine RAID-Geräte zu kontrollieren. OpenBSDs RAID
basiert auf Greg Osters
<a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD-Port</a>
der
CMU-<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a>-Software.
OpenBSD hat Unterstützung für die RAID-Level
0, 1, 4 und 5.
d2567 9
a2575 9
Für raid muss - wie auch bei ccd - Unterstützung im KERNEL sein.
Diese Treiberunterstützung für RAID ist im Gegensatz zu ccd allerdings
nicht im GENERIC-Kernel enthalten; sie muss also extra in deinen Kernel
einkompiliert werden (RAID-Unterstützung vergrößert deinen
i386-Kernel um gute 500k).

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>
d2578 4
a2581 6
Lies die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>- und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>-Manualseiten
für die kompletten Details. Es gibt dafür viele Optionen und mögliche
Konfigurationen, und ein detaillierter Überblick sprengt den Rahmen
dieses Dokumentes.
d2585 1
a2585 1
<h3>14.18.3 - Softupdates</h3>
d2587 1
a2587 1
Ein weiteres Werkzeug zum Erhöhen der Systemgeschwindigkeit sind
d2594 3
a2596 8
auf dem aktuellen Stand sind. Das heißt, ein Systemabsturz sollte kein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
beim folgende Booten benötigen, sondern eine einfache Hintergrundversion
von fsck, die Änderungen an den Metainfos im RAM macht (a la
Softupdates). Das heißt, dass Reboots viel schneller sind, da
nicht mehr auf fsck gewartet werden muss! (OpenBSD hat diese
Funktionalität leider noch nicht.) Mehr über Softupdates findest du im
<a href="#SoftUpdates">Softupdates-FAQ</a>-Eintrag.
d2600 1
a2600 1
<h3>11.1.4 - Größe des namei()-Caches</h3>
d2623 1
a2623 1
<h2>14.19 - Wieso benutzen wir keine »async mounts«?</h2>
d2670 1
a2670 1
<a href= "faq15.html">[Zum Kapitel 15 - Packages und Ports]</a>
d2680 2
a2681 2
Originally [OpenBSD: faq14.html,v 1.176 ]<br>
$Translation: faq14.html,v 1.90 2008/11/22 11:01:56 paldium Exp $<br>
@


1.72
log
@Sync with Steelix CVS
@
text
@d494 1
a494 1

d539 2
a540 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1))</a>.
d2528 2
a2529 2
Originally [OpenBSD: faq14.html,v 1.175 ]<br>
$Translation: faq14.html,v 1.89 2008/10/31 19:20:40 simon Exp $<br>
@


1.71
log
@Sync with Steelix CVS
@
text
@d967 1
a967 1
OpenBSD 4.3 (GENERIC) #698: Wed Mar 12 11:07:05 MDT 2008
d2527 2
a2528 2
Originally [OpenBSD: faq14.html,v 1.174 ]<br>
$Translation: faq14.html,v 1.88 2008/07/12 09:39:36 paldium Exp $<br>
@


1.70
log
@Sync with Steelix CVS
@
text
@d2527 2
a2528 2
Originally [OpenBSD: faq14.html,v 1.172 ]<br>
$Translation: faq14.html,v 1.87 2008/05/23 10:37:21 paldium Exp $<br>
@


1.69
log
@Sync with Steelix CVS
@
text
@d1178 5
a1182 5
Wenn man eines Tages 2-TB-Dateisysteme mit Standardfragment- und
Blockgrößen hat, wird fsck 1&nbsp;GB RAM benötigen; das ist das
Applikationslimit unter OpenBSD. Größere Fragmente und/oder Blöcke
werden die Anzahl Inodes verringern und größere Dateisysteme
ermöglichen.
d2527 2
a2528 2
Originally [OpenBSD: faq14.html,v 1.170 ]<br>
$Translation: faq14.html,v 1.86 2008/05/01 09:35:33 paldium Exp $<br>
@


1.68
log
@Sync with Steelix CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2007 by OpenBSD.">
d965 1
a965 1
Copyright (c) 1995-2007 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d967 1
a967 1
OpenBSD 4.2 (GENERIC) #375: Tue Aug 28 10:38:44 MDT 2007
d1065 5
a1069 8
OpenBSD unterstützt ein individuelles Dateisystem von bis zu
2<sup>31</sup>-1, oder 2,147,483,647 Sektoren und da jeder Sektor 512
Byte groß ist, ist das etwas unterhalb von 1 T.

<p>
Es gibt auch eine 1-T-Begrenzung für die physikalische Größe der Platte
obwohl es unter *einigen* Umständen möglich ist, dass es selbst bis zu
2 T keine Probleme gibt, wobei das <b>nicht</b> garantiert wird.
d1075 6
a1080 5
älteren (vor >137G-Standard) Interfaces funktionieren und einige sehr
alte SCSI-Adapter sind bekannt dafür, dass sie Probleme mit moderneren
Laufwerken haben und einige alte BIOSe werden hängen, wenn sie einer
modern bestückten Festplatte begegnen. Du musst die Fähigkeiten deiner
Hardware respektieren.
d1096 2
a1097 2
Laufwerken betreiben, aber deine root-Partition muss innerhalb der
ersten 128 G liegen.
d1127 1
a1127 1
<tt>/boot</tt> im Falle von i386) und der Kernel (<tt>/bsd</tt>)
d1161 2
d1166 7
a1172 1
gemounteten Dateisystemen gehört.
d1177 39
d2527 2
a2528 2
Originally [OpenBSD: faq14.html,v 1.169 ]<br>
$Translation: faq14.html,v 1.82 2008/04/27 07:44:47 paldium Exp $<br>
@


1.67
log
@Sync with Steelix CVS
@
text
@d563 2
a564 8
Dort kannst du 96M benutzen, um 96 Megabytes anzugeben (oder, wenn
deine Festplatte groß genug ist, 96G für 96 Gigabytes!).
Unglücklicherweise benutzt der Modus -E die BIOS-Plattengeometrie und
nicht die reale - oft sind die beiden nicht deckungsgleich. Um dieses
Problem zu umgehen, tippe »g d« für »geometry disk«. (Andere
Möglichkeiten sind »g b« für »Geometry BIOS« und »g u« für »geometry
user« oder einfach das, was das Label gesagt hat, bevor disklabel
irgendwelche Änderungen gemacht hat.)
d881 1
a881 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>
d1049 2
a1050 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">biosboot(8)-Manualseite</a>
ausführlich besprochen.
d1052 2
a1053 1
Für weitere Informationen über den i386-Bootprozess, siehe
d2482 2
a2483 2
Originally [OpenBSD: faq14.html,v 1.167 ]<br>
$Translation: faq14.html,v 1.80 2008/03/05 20:10:36 paldium Exp $<br>
@


1.66
log
@Sync with Steelix CVS
@
text
@d310 1
a310 1
FAT32-Dateisytem) wird der OpenBSD-Kernel ein Disklabel im Speicher
d561 1
a561 1
benutzten, um den selben Patitionierungsmodus zu erhalten, den du auf
d938 1
a938 1
und erweiterten (überhalb von 1 M) Speichers, den er gefunden hat
d1033 1
a1033 1
später) PBR ist sehr viel tolleranter im Bezug auf Übersetzungsänderungen.
d1337 1
a1337 1
einfach dmesg, um das herauzufinden. Ein Beispieleintrag von dmesg für
d1677 1
a1677 1
DMA-Leistung erhältst. Es ist ebenfals eine schlechte Idee, das CD-ROM
d2050 2
a2051 2
Dateissystempartionen enthielte. Wenn du diese verwenden möchtest,
dann musst du diese Partionen manuell unter Verwendung von
d2062 1
a2062 1
Sektornummern (nicht Megabyte oder ein anderes Maß) die exakteste
d2409 1
a2409 1
Die name-to-inode-Übersetzung (a.&nbps;k.&nbsp;a. <!-- need to write
d2488 1
a2488 1
$Translation: faq14.html,v 1.78 2007/11/04 09:57:23 paldium Exp $<br>
@


1.65
log
@sync with steelix translation CVS
@
text
@d83 1
a83 1
und <a href="../../cats.html">cats</a> findet die Platteneinrichtung in
d100 1
a100 1
meist nicht einmal korrekt: mach dir also keine Gedanken darüber. Das
d263 1
a263 1
zu Verfügung: von a bis p (einige »besondere« Systeme haben nur acht).
d325 1
a325 1
von Änderungen warnt disklabel(8) jedoch, so dass »x« schnell und
d338 1
a338 1
Auf einigen Plattformen (i386, amd64, macppc, zaurus und cats) wird
d442 3
a444 1
Eintrag als bootbar markieren.
d449 1
a449 1
<li><b>swap</b>  Tauscht zwei MBR-Einträge miteinander aus, so dass du
d624 1
a624 1
/usr/local an. Starte dann das System neu und voila: die Dateien sind
d632 1
a632 1
(Hinweis: wenn du in eine Datei swappen willst, weil du immer
d758 1
a758 1
An diesem Punkt angekommen musst du deinen Computer neustarten, so dass
d817 1
a817 1
begrenzte Menge an Kernelspeicher und können diese Funktion nicht
d880 1
a880 1
dateisystembewusste Applikation zu laden, so dass, statt den PBR
d927 1
a927 1
eingegeben wurde, startet es sein normales Verhalten: den Kernel
d937 2
a938 2
<li><b>636k 190M</b> - Die Menge vom herkömmlichen (unterhalb von 1 M)
und erweiterten (überhalb von 1 M) Speicher, den er gefunden hat
d950 1
a950 1
Bootprozesses: den OpenBSD Kernel in den RAM laden und sauber
d973 1
a973 1
OpenBSD 4.1 (GENERIC) #1434: Thu Mar  8 22:56:57 MST 2007
d1031 1
a1031 1
Platte zu erhalten), so dass du installboot(8) erneut ausführen musst,
d1036 1
a1036 1
Da der PBR sehr klein ist, ist die Anzahl von Fehlermeldungen sehr
d1042 1
a1042 1
Es bedeutet meistens genau das, was es aussagt: von deiner Platte konnte
d1127 1
a1127 1
überschreibt sie nicht die alte: ihr wird einem neuen Ort auf der Platte
d1174 1
a1174 1
werden, so dass deutlich mehr RAM pro Platte benötigt wird.
d1540 1
a1540 1
fertig sein, so dass du davon booten und damit beginnen kannst, den Rest
d1684 1
a1684 1
auf einen niedrigereren DMA- oder UDMA-Level standardmäßig begrenzen.
d1747 1
a1747 1
variieren von Plattform zu Plattform: siehe die passende
d1767 1
a1767 1
(Hinweis: dies sind nur Produkte, die von OpenBSD-Anwendern verwendet
d1786 1
a1786 1
softwarebasierendem Stil und funktionieren normalerweise einwandfrei als
d1809 1
a1809 1
ist 5&nbsp;% der Plattenkapazität, so dass, falls der
d1992 1
a1992 1
zuerst aufgelistet. Nach diesen ist eine Anzahl von ext2-Partitionen und
d2006 1
a2006 1
Dateisysteme werden vom GENERIC-Kernel unterstützt: wirf einfach einen
d2049 1
a2049 1
und nicht automatisch aktualisiert, so dass es die neuen fremden
d2057 1
a2057 1
geändert: unter Verwendung von Linux' fdisk-Programm habe ich die
d2146 1
a2146 1
wichtigsten: sie sagen, an welche Gerätedatei das Speichergerät
d2193 1
a2193 1
Möglicherweise wird diese andere Person nicht OpenBSD nutzen, so dass
d2315 1
a2315 1
einfach als ffs.
d2437 1
a2437 1
Wieso wird ,async mounting' abgelehnt und ist nicht standardmäßig
d2487 2
a2488 2
Originally [OpenBSD: faq14.html,v 1.164 ]<br>
$Translation: faq14.html,v 1.75 2007/06/20 17:41:07 paldium Exp $<br>
@


1.64
log
@Sync with steelix translation CVS
@
text
@d535 1
a535 1
Festplattenhersteller sind 3000 Megabytes.  Dividiere also
d539 1
a539 1
erstellen, rechne einfach X * 2061, um X Megabytes Platz auf dieser
d561 2
a562 2
Dort kannst du 96M benutzen, um 96 Megabytes anzugeben.  (Oder, wenn
deine Festplatte groß genug ist, 96G für 96 Gigabytes!)
d825 1
a825 1
der erste physikalische Sektor (512 Bytes) auf der Platte. Er beinhaltet
d877 1
a877 1
- insgesamt nur 512 Bytes. Das ist nicht genug, um eine vollständig
d1070 1
a1070 1
Bytes groß ist, ist das etwas unterhalb von 1 T.
d1440 1
a1440 1
OpenBSD-Installations-/Bootdiskette enthält bereits das benötigte
d1453 1
a1453 1
Boote von der OpenBSD-Installations-/Bootdiskette. Wähle Shell aus dem
d1551 1
a1551 1
Entferne die Installations-/Bootdiskette aus dem Laufwerk und starte
d1569 1
a1569 1
willst du sicherlich root im Lese-/Schreibmodus (rw) remounten und nicht
d1579 1
a1579 1
Sobald du im Lese-/Schreibmodus remountet hast kannst du fortfahren,
d2060 1
a2060 1
Sektornummern (nicht Megabytes oder ein anderes Maß) die exakteste
d2486 1
a2486 1
$Translation: faq14.html,v 1.73 2007/06/19 22:31:33 paldium Exp $<br>
@


1.63
log
@Sycn with steelix translation CVS
@
text
@d1675 2
a1676 2
DMA-Leistung erhälst. Es ist ebenfals eine schlechte Idee, das CD-ROM an
den gleichen Kanal wie die Festplatte zu stecken.
d2486 1
a2486 1
$Translation: faq14.html,v 1.72 2007/06/15 16:53:38 paldium Exp $<br>
@


1.62
log
@Sync with steelix translation CVS
@
text
@d386 1
a386 1
sehen. Der * sagt uns, dass die OpenBSD-Partition eine bootfähige
d439 2
a440 2
<li><b>flag</b>  Macht den jetzigen Partitionstabelleneintrag bootfähig.
Nur ein Eintrag kann gleichzeitig bootfähig sein. Wenn du von einer
d442 1
a442 1
Eintrag als bootfähig markieren.
d1442 1
a1442 1
Partitionen zu erstellen und deine Festplatte bootfähig zu machen. In
d1517 1
a1517 1
Wenn die Platte bootfähig sein soll, schreibe mit dem folgenden Befehl
d2486 1
a2486 1
$Translation: faq14.html,v 1.71 2007/05/01 18:47:25 paldium Exp $<br>
@


1.61
log
@Sync with steelix translation CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2006 by OpenBSD.">
d969 1
a969 1
Copyright (c) 1995-2006 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d971 2
a972 1
OpenBSD 4.0 (GENERIC) #1107: Sat Sep 16 19:15:58 MDT 2006
d2485 2
a2486 2
Originally [OpenBSD: faq14.html,v 1.163 ]<br>
$Translation: faq14.html,v 1.70 2007/04/25 15:41:12 paldium Exp $<br>
@


1.60
log
@sync with Steelix CVS
@
text
@d71 1
a71 1
  
d73 1
a73 1
Lies zunächst die 
d172 1
a172 1
drivedata: 0 
d218 1
a218 1
offset: [10847088] 
d221 1
a221 1
FS type: [4.2BSD] 
d226 1
a226 1
label: Maxtor 51536H2  
d238 2
a239 2
  a:        300.2M          0.0M  4.2BSD   2048 16384  328 # Cyl     0*-   609 
  b:        199.8M        300.2M    swap                   # Cyl   610 -  1015 
d241 5
a245 5
  d:       3072.2M        500.1M  4.2BSD   2048 16384  328 # Cyl  1016 -  7257 
  e:        199.8M       3572.3M  4.2BSD   2048 16384  328 # Cyl  7258 -  7663 
  f:        500.1M       4796.4M  4.2BSD   2048 16384  328 # Cyl  9745 - 10760 
  h:       1024.2M       3772.1M  4.2BSD   2048 16384  328 # Cyl  7664 -  9744 
  k:       2048.0M       5296.4M  4.2BSD   2048 16384   16 # Cyl 10761 - 14921 
d247 1
a247 1
Write new label?: [y] 
d417 1
a417 1
<p> 
d495 1
a495 1
musst du 
d499 1
a499 1
verwenden, um deine Festplatte unter OpenBSD benutzen zu können. 
d510 1
a510 1
Das wird die »echte« Partitionstabelle der Festplatte für eine 
d555 1
a555 1
    d:  6185025       63    4.2BSD     1024  8192    16 
d630 1
a630 1
(Hinweis: wenn du in eine Datei swappen willst, weil du immer 
d646 1
a646 1
In eine Datei zu swappen ist der einfachste und schnellste Weg, um 
d726 1
a726 1
kompilieren« in dieser FAQ an): 
d752 1
a752 1
/dev/vnd0c none swap sw 0 0 
d771 1
a771 1
eingetragen wurde. 
d1251 1
a1251 1
Dateisysteme gemountet sind. Das findet man mit dem 
d1259 1
a1259 1
/dev/sd0h on /usr type ffs (local)  
d1276 1
a1276 1
/dev/sd0h on /usr type ffs (local)  
d1367 1
a1367 1
echo                      
d1472 1
a1472 1
<p>  
d1507 1
a1507 1
Wiederherstellungsprozess. Beispiel: 
d1952 1
a1952 1
label: ST340016A       
d1966 1
a1966 1
drivedata: 0 
d1970 6
a1975 6
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581 
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206 
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544 
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367 
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773 
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176 
d2202 1
a2202 1
label: DIGITAL FILM    
d2216 1
a2216 1
drivedata: 0 
d2220 1
a2220 1
  c:        251904             0  unused      0     0      # Cyl     0 -   122 
d2264 1
a2264 1
Die Festplattenleistung ist ein wichtiger Faktor in der 
d2286 1
a2286 1
Die erste Option ist die Benutzung des 
d2293 1
a2293 1
zu finden ist. 
d2312 1
a2312 1
einfach als ffs. 
d2339 1
a2339 1
Solange /etc/ccd.conf existiert, wird sich ccd automatisch beim Booten 
d2375 1
a2375 1
Lies die 
d2397 1
a2397 1
Softupdates). Das heißt, dass Reboots viel schneller sind, da 
d2399 1
a2399 1
Funktionalität leider noch nicht.) Mehr über Softupdates findest du im 
d2411 1
a2411 1
wäre eine große Anzahl namei()-Cachemisses, die man mit einem 
d2413 1
a2413 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a> 
d2420 1
a2420 1
Nachdem der Wert festgestellt wurde, kannst du ihn für die nächsten 
d2440 1
a2440 1
Antwort: »Asynchrone Mounts sind tatsächlich schneller als synchrone 
d2461 1
a2461 1
rekonstruieren kannst, indem du eine separate Partition nur für 
d2482 1
a2482 1
<small> 
d2485 1
a2485 1
$Translation: faq14.html,v 1.69 2007/03/06 15:39:50 paldium Exp $<br>
@


1.59
log
@sync with Steelix CVS
@
text
@d40 1
a40 1
    i386-spezifisch</a>
d1079 3
a1081 3
Eine neue 250 G große IDE-Festplatte wird nicht mit älteren (vor
>137G-Standard) Interfaces funktionieren und einige sehr alte
SCSI-Adapter sind bekannt dafür, dass sie Probleme mit moderneren
d1161 11
a1171 3
erfolgreich fsck gegen die Platte auszuführen. Die benötigte Zeit, um
fsck gegen ein Laufwerk auszuführen kann ein Problem werden, sobald das
Dateisystem an Größe gewinnt.
d1174 1
a1174 1
<h2>14.8 - Installieren von Bootblocks - i386-spezifisch</h2>
d1177 23
a1199 25
Ältere Versionen von MS-DOS können nur mit Festplattengeometrien von
1024 Zylindern oder weniger umgehen. Da nahezu alle modernen
Betriebssysteme mehr als 1024 Zylinder haben, haben die meisten
SCSI-BIOS-Chips (die auf den SCSI-Controllerkarten) und IDE-BIOSe (was
Teil des restlichen PC-BIOS ist) eine Option (manchmal auch als
Grundeinstellung), die wirkliche Geometrie in etwas zu übersetzen, mit
dem MS-DOS umgehen kann. Wie dem auch sei, nicht alle BIOS-Chips
übersetzen die Geometrie in der selben Weise. Wenn du dein BIOS
wechselst (entweder mit einem neuen Motherboard oder einem neuen
SCSI-Controller) und das neue benutzt eine andere übersetzte Geometrie,
wirst du nicht in der Lage sein, den Secondstage-Bootloader zu laden
- und kannst daher den Kernel auch nicht laden (das liegt daran, dass
der Firststage-Bootloader eine Liste der Blöcke enthält, die /boot in
der übersetzten Geometrie enthalten). Falls du IDE-Platten benutzt und
du Änderungen an deinen BIOS-Einstellungen machst, kannst du seine
Übersetzung ebenfalls (ungewollt) ändern (die meisten IDE-BIOSe bieten
3 verschiedene Übersetzungen). Um deinen Bootblock zu reparieren, damit
du normal booten kannst, lege einfach eine Bootdiskette in dein
Diskettenlaufwerk ein und gib am Bootprompt »b hd0a:/bsd« ein, um ihn
zu zwingen, von der ersten Festplatte zu booten (und nicht von der
Diskette). Deine Maschine sollte normal booten. Jetzt musst du die erste
Stufe des Bootloaders auf den neuen Stand bringen. (Und dazu passend
den Bootblock schreiben.) <br>
Unser Beispiel geht davon aus, dass deine Bootdisk sd0
ist (bei IDE wäre es wd0 etc.):
d2484 2
a2485 2
Originally [OpenBSD: faq14.html,v 1.160 ]<br>
$Translation: faq14.html,v 1.68 2007/02/09 18:13:47 paldium Exp $<br>
@


1.58
log
@sync with steelix translation CVS
@
text
@d98 1
a98 1
selbst wie zum Beispiel Umdrehungsgeschwindigkeit, Interleave, etc.
d113 1
a113 1
OpenBSD-Partitionen enthält (z.&nbsp;B. »swap«, »/«, »/usr«, »/var«,
d1193 1
a1193 1
ist (bei IDE wäre es wd0, etc.):
d1317 1
a1317 1
Zuletzt welche Partition gesichert werden soll (/dev/rsd0a, usw.)
d1343 1
a1343 1
ansonsten wirst du mit der zweiten Sicherung die erste überschreiben,
d1602 1
a1602 1
Um ein Diskimage (ISO-Images, Diskimages, die mit dd erstellt wurden,
d2479 1
a2479 1
$Translation: faq14.html,v 1.67 2006/11/16 12:16:43 jufi Exp $<br>
@


1.57
log
@sync with steelix translation CVS
@
text
@d1246 1
a1246 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)"></a>-Kommando
d2479 1
a2479 1
$Translation: faq14.html,v 1.66 2006/11/01 09:15:00 paldium Exp $<br>
@


1.56
log
@sync with steelix translation CVS
@
text
@d971 1
a971 1
OpenBSD 3.9 (GENERIC) #617: Thu Mar 2 02:26:48 MST 2006
d2478 2
a2479 2
Originally [OpenBSD: faq14.html,v 1.159 ]<br>
$Translation: faq14.html,v 1.65 2006/10/29 09:44:47 paldium Exp $<br>
@


1.55
log
@sync with steelix translation CVS
@
text
@d1789 1
a1789 1
100&nbsp;% einer Partition in Verwendung ist, wie es von
d1794 1
a1794 1
Wenn eine Partition mit
d2478 2
a2479 2
Originally [OpenBSD: faq14.html,v 1.158 ]<br>
$Translation: faq14.html,v 1.64 2006/08/11 09:14:53 paldium Exp $<br>
@


1.54
log
@sync
@
text
@a11 5
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
d152 1
a152 1
<pre>
d183 1
a183 1
</pre>
d209 1
d214 1
a214 1
<pre>
d248 1
a248 1
</pre>
d364 3
a366 2
<pre># <b>fdisk fd0</b><br>
</pre>
d371 1
a371 1
<pre>
d381 1
a381 1
</pre>
d395 1
a395 1
<pre>
d415 1
a415 1
</pre>
d505 2
a506 1
<pre>
d508 2
a509 1
</pre>
d513 2
a514 1
<pre>
d528 1
a528 1
</pre>
d554 1
a554 1
<pre>
d556 1
a556 1
</pre>
d576 1
a576 1
<pre>
d578 1
a578 1
</pre>
d592 1
a592 1
<pre>
d594 1
a594 1
</pre>
d601 3
a603 1
<pre>/dev/sd2a /u ffs rw 1 1</pre>
d614 1
a614 1
<pre>
d616 1
a616 1
</pre>
d654 1
a654 1
<pre>
d658 1
a658 1
</pre>
d677 1
a677 1
<pre>
d682 1
a682 1
</pre>
d689 1
a689 1
<pre>
d692 1
a692 1
</pre>
d698 1
a698 1
<pre>
d704 1
a704 1
</pre>
d712 1
a712 1
<pre>
d716 1
a716 1
</pre>
d728 1
a728 1
<pre>
d730 1
a730 1
</pre>
d737 1
a737 1
<pre>
d742 1
a742 1
</pre>
d749 1
a749 1
<pre>
d753 1
a753 1
</pre>
d762 1
a762 1
<pre>
d765 1
a765 1
</pre>
d773 1
a773 1
<pre>
d780 1
a780 2
</pre>

d808 1
a808 1
<pre>
d810 1
a810 1
</pre>
d846 5
a850 3
<pre>
    Using drive 0, partition 3.
</pre>
d857 5
a861 3
<pre>
    Using Drive 0, Partition 3;
</pre>
d890 3
a892 3
<pre>
    Loading...
</pre>
d897 3
a899 3
<pre>
    Loading;...
</pre>
d916 7
a922 6
<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.10
     boot>
</pre>
d955 1
d993 3
a995 3
<pre>
    # <b>fdisk -u wd0</b>
</pre>
d999 3
a1001 3
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre>
d1195 1
a1195 1
<pre>
d1197 1
a1197 1
</pre>
d1203 1
a1203 1
<pre>
d1208 1
a1208 1
</pre>
d1250 1
a1250 1
<pre>
d1254 1
a1254 1
</pre>
d1265 1
a1265 1
<pre>
d1271 1
a1271 1
</pre>
d1283 1
a1283 1
<pre>
d1287 1
a1287 1
</pre>
d1293 1
a1293 1
<pre>
d1299 1
a1299 1
</pre>
d1331 1
a1331 1
<pre>
d1333 1
a1333 1
</pre>
d1351 1
a1351 1
<pre>
d1362 1
a1362 1
</pre>
d1397 1
a1397 1
<pre>
d1399 1
a1399 1
</pre>
d1410 1
a1410 1
<pre>
d1412 1
a1412 1
</pre>
d1457 1
a1457 1
<pre>
d1459 1
a1459 1
</pre>
d1471 1
a1471 1
<pre>
d1473 1
a1473 1
</pre>
d1485 1
a1485 1
<pre>
d1488 1
a1488 1
</pre>
d1494 1
a1494 1
<pre>
d1496 1
a1496 1
</pre>
d1503 1
a1503 1
<pre>
d1506 1
a1506 1
</pre>
d1513 1
a1513 1
<pre>
d1515 1
a1515 1
</pre>
d1523 1
a1523 1
<pre>
d1526 1
a1526 1
</pre>
d1537 1
a1537 1
<pre>
d1540 1
a1540 1
</pre>
d1548 1
a1548 1
<pre>
d1550 1
a1550 1
</pre>
d1566 1
a1566 1
<pre>
d1568 1
a1568 1
</pre>
d1575 2
a1576 2
<pre>
(einfache Mounttabelle)
d1579 1
a1579 1
(umfassendere Mounttabelle)
d1583 1
a1583 1
</pre>
d1609 1
a1609 4
<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
d1612 1
a1612 4
</pre>
                </td>
        </tr>
</table>
d1622 1
a1622 4
<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
d1625 1
a1625 4
</pre>
                </td>
        </tr>
</table>
d1654 1
a1654 1
<pre>
d1657 1
a1657 1
</pre>
d2478 2
a2479 2
Originally [OpenBSD: faq14.html,v 1.157 ]<br>
$Translation: faq14.html,v 1.62 2006/07/27 17:42:07 paldium Exp $<br>
@


1.53
log
@sync with Steelix CVS
@
text
@d1642 1
a1642 1
unterstützt werden, sind unzuverlässig. Bis vor Kurzem wurden die
d2484 1
a2484 1
$Translation: faq14.html,v 1.61 2006/06/22 17:52:26 paldium Exp $<br>
@


1.52
log
@3.9 release time.
@
text
@d470 2
a471 2
Masterbootrecord, in dem sich die fdisk-Partitionstabelle befindet.
-- bin mir nicht sicher, ob das wahr ist -->
d2483 2
a2484 2
Originally [OpenBSD: faq14.html,v 1.156 ]<br>
$Translation: faq14.html,v 1.60 2006/05/01 11:17:10 paldium Exp $<br>
@


1.51
log
@sync with Steelix CVS
@
text
@d962 1
a962 1
Copyright (c) 1995-2005 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d964 1
a964 1
OpenBSD 3.8 (GENERIC) #138: Sat Sep 10 15:41:37 MDT 2005
d2483 2
a2484 2
Originally [OpenBSD: faq14.html,v 1.155 ]<br>
$Translation: faq14.html,v 1.59 2006/04/24 17:44:28 paldium Exp $<br>
@


1.50
log
@sync with Steelix CVS
@
text
@d7 1
a7 1
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
d10 1
a10 1
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2006.">
a11 1
<meta http-equiv="Content-Language" content="de">
d2483 2
a2484 2
Originally [OpenBSD: faq14.html,v 1.155 ]
$Translation: faq14.html,v 1.58 2006/03/04 10:18:49 paldium Exp $
@


1.49
log
@sync with Steelix CVS
@
text
@d136 1
a136 1
anzulegen, wirf einen Blick auf <a href="faq4.html#SpaceNeeded">diese
d1141 1
a1141 1
Dies ist ein weiterer guter Grund <a href="faq4.html#SpaceNeeded">deine
d1728 4
a1731 2
im Kernel bsd.rd, so dass es viel einfacher genutzt werden kann, obwohl
es einige Begrenzungen im Bezug auf das Neuerzeugen des Arrays hat.
d2484 2
a2485 2
Originally [OpenBSD: faq14.html,v 1.153 ]
$Translation: faq14.html,v 1.57 2006/02/28 08:19:37 paldium Exp $
@


1.48
log
@sync with steelix translation CVS
@
text
@d10 1
a10 1
<meta name= "copyright"     content= "Dieses Dokument unterliegt dem Copyright von OpenBSD 1998 - 2005.">
d50 2
a51 1
<li><a href="#pciideErr"  >14.11 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</a>
d65 4
d1711 1
a1711 1
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
d2258 211
d2482 2
a2483 2
Originally [OpenBSD: faq14.html,v 1.150 ]
$Translation: faq14.html,v 1.56 2006/01/13 21:58:46 paldium Exp $
@


1.47
log
@sync with steelix translation CVS
@
text
@d148 1
a148 1
nicht mehr allzuoft benutzen müssen. Aber du kannst es gebrauchen, wenn
d303 1
a303 1
das immer der Fall ist - disklabel wird dir mitteilen, wieviele Sektoren
d643 2
a644 2
ist). Finde zunächst einmal heraus, wieviel Swap du momentan hast
und wieviel du davon benutzt. Das geht mit dem Werkzeug
d1361 1
a1361 1
um herauszufinden, wieviel Platz jede Partition momentan verbraucht. Das
d1638 1
a1638 1
unterstützt werden, sind unzuverlässig. Bis vor kurzem wurden die
d2121 1
a2121 1
sehe ich folgendes auf meiner Konsole:
d2267 1
a2267 1
$Translation: faq14.html,v 1.55 2006/01/05 18:18:15 paldium Exp $
@


1.46
log
@sync with steelix translation CVS
@
text
@a69 9
<h3>Inhaltsverzeichnis</h3>

<ul>
<li><a href="#disklabel.1">Was ist disklabel(8)?</a>
<li><a href="#disklabel.2">disklabel(8) während der OpenBSD-Installation</a>
<li><a href="#disklabel.3">Gebräuchliche Verwendungen von disklabel(8).</a>
</ul>

   
d78 34
a111 16
Disklabels werden erzeugt, um ein effizientes Interface zwischen deiner
Festplatte und den Festplattentreibern zu erzeugen, die im Kernel
enthalten sind. Labels enthalten bestimmte Informationen über deine
Festplatte, wie z.&nbsp;B. die Plattengeometrie und Informationen über
deine Dateisysteme. Dies wird dann vom Bootstrapprogramm benutzt, um die
Festplatte zu laden und zu wissen, wo auf der Platte die Dateisysteme
sind. Labels werden auch zusammen mit den Dateisystemen benutzt, um eine
effizientere Umgebung zu erzeugen. Tiefergehende Informationen über
disklabel gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>-Manualseite.

<p>
Zusätzlich führt die Benutzung von disklabel zur Überwindung
der Architekturgrenzen beim Partitionieren von Festplatten. Auf i386
kann man z.&nbsp;B. nur 4 primäre Partitionen haben (Partitionen, so
wie sie andere Betriebssysteme wie Windows NT oder DOS sehen). Mit 
d113 3
a115 3
benutzt du eine dieser primären Partitionen, die dann *alle* deine
OpenBSD-Partitionen enthält (z.&nbsp;B. »swap«, »/«, »/usr« und »/var«).
Und du hast noch 3 weitere für andere Betriebssysteme übrig!
d121 18
a138 117
Einer der Hauptteile der OpenBSD-Installation ist das erstmalige Erzeugen
der Labels. Das kommt (für i386-Benutzer) direkt nach der Benutzung von
<a href="#fdisk">fdisk(8)</a>.
Während der Installation benutzt du disklabel, um deine separaten Labels
zu erzeugen, die deine separaten Mountpoints enthalten. Während der
Installation kannst du mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a> 
deine Mountpoints setzen. Das ist aber eigentlich nicht nötig, da du
deine Änderungen später sowieso bestätigen musst. Aber es macht deine
Installation schon etwas geradliniger.

<p>
Da das während der Installation geschieht, hast du noch keine
funktionierenden Labels und sie müssen erst erzeugt werden. Das erste
Label, das du erzeugst, ist das Label a. Das SOLLTE das Label sein, auf
dem dann / gemountet wird. Die empfohlenen Partitionen und ihren Größen
kannst du dir unter <a href="faq4.html#SpaceNeeded">FAQ4, Wieviel Platz
brauche ich für eine OpenBSD-Installation?</a> ansehen. Für Server wird
empfohlen, zumindest diese Labels separat zu halten. Für Desktopanwender
reicht vermutlich ein einzelner Mountpoint /. Wenn du deine
root-Partition (,a' Label)
erzeugst, denk dran, dass du in jedem Fall noch ETWAS Platz für dein
Swap Label benötigst. Jetzt kennst du die Grundlagen und daher geben wir
hier jetzt mal ein Beispiel für das Benutzen von disklabel. In diesem
ersten Beispiel wird angenommen, dass OpenBSD das einzige Betriebssystem
auf diesem Computer ist und eine vollständige Installation gemacht
wird.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
An diesem Punkt angekommen hast du eine 64 MB große root-Partition, die
mit / gemountet wird, und eine 64 Meg Swappartition erzeugt. In diesem
Fall beginnt der Offset bei Sektor 63. So willst du es haben. Wenn es
bei der Größe angekommen ist, wird dir Disklabel die Größen in Sektoren
angeben; du musst aber die Größen nicht ebenfalls im gleichen Format
eingeben. Wie im Beispiel oben kannst du Größen zum Beispiel so
eingeben: <i>64 Megabytes = 64M</i> und <i>2 Gigabytes = 2G</i>.
Disklabel wird dann einfach auf den naheliegendsten Zylinder runden. Im
obigen Beispiel kann man auch sehen, dass disklabel annimmt, dass Label
b Swapbereich sein wird. Das ist eine korrekte Annahme, da im
GENERIC-Kernel Swap auf Label b festgelegt ist. Du solltest daher
dieser Richtlinie ebenfalls folgen und b als Swapbereich benutzen. 

<p>
Das nächste Beispiel wird dich durch die Erzeugung zweier weiterer
Labels führen. Im Übrigen kann das keine komplette Installation sein, da
die Größe dieser beiden Partitionen nicht ausreicht, um OpenBSD komplett
zu installieren. Das Erzeugen dieser ganzen Partitionen dient nur zur
Wiederholung und Vertiefung. 

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
Im obigen Beispiel fallen dir vermutlich zwei Dinge auf. Zum einen, dass
der Offset, der als nächstes an der Reihe ist, automatisch für dich
errechnet wird; wenn du eine solche Installation machst, musst du dich
mit dem Ändern der Offsets nicht herumschlagen. Zum anderen, dass das
Label c übersprungen wurde. Das ist aber Absicht, und zwar deshalb, weil
Label c die ganze Festplatte repräsentiert. Aus diesem Grund solltest du
Label c vollkommen in Ruhe lassen.

<p>
Sind deine Label erst einmal alle erzeugt, ist alles, was noch nötig ist,
die Label auf die Festplatte zu schreiben und einfach mit dem
Installationsprozess fortzufahren. Um alles zu schreiben und disklabel zu
beenden (und mit der Installation weiterzumachen), tippe Folgendes:
a139 4
<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>
d144 1
a144 1
<h3>Gebräuchliche Verwendungen von disklabel(8)</h3>
d154 2
a155 3
# <b>disklabel wd0</b> &gt;----- Oder was du dir auch immer für eine Platte ansehen willst

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
d158 2
a159 2
disk:
label: TOSHIBA MK2720FC
d165 2
a166 2
cylinders: 2633
total sectors: 2654064
d171 2
a172 2
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
d176 8
a183 5
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
d187 26
a212 4
Der obige Befehl zeigt dir einfach den existierenden Disklabel und stellt
sicher, dass du nichts kaputt machst oder durcheinanderbringst (was wir
alle von Zeit zu Zeit mal brauchen). Um aber Veränderungen durchzuführen,
musst du die Option -E wie folgt mit angeben:
d216 54
a269 1
</pre>
d272 58
a329 10
Das wird dich an den gleichen Prompt bringen, den du schon während der
OpenBSD-Installation benutzt hast. Das wahrscheinlich wichtigste
Kommando an diesem Prompt ist ?. Das erzeugt nämlich eine Liste mit
möglichen Optionen für Disklabel. Mit Hilfe von M kannst du dir sogar
die gesamte 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>-Manualseite
ansehen. Von diesem Prompt aus wirst du dein gesamtes Hinzufügen,
Löschen und Ändern der Partitionen vornehmen. Zusätzliche Informationen
gibt es in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>-Manualseite.
d333 2
a334 1
Um sicher zu sein, lies zuerst die
d338 19
a356 8
Das Programm fdisk dient dazu, bei der Wartung deiner Partitionen
zu helfen. Dieses Programm wird auch bei der Installation benutzt, um
deine OpenBSD-Partition einzurichten (diese Partition kann
<u>mehrere</u> Labels enthalten, jedes mit Dateisystemen/Swap/etc.). Es
kann den Platz auf deiner Festplatte aufteilen und eine Partition als
aktiv markieren. Dieses Programm wird für gewöhnlich im Singleuser-Modus
benutzt (boot -s). Der MBR wird auf deinen verschiedenen Festplatten von
fdisk gesetzt.
d359 1
a359 3
Für Installationszwecke braucht man meistens nur <b>EINE</b>
OpenBSD-Partition und benutzt dann disklabel, um Swap und Dateisysteme
darauf zu installieren.
d407 1
a416 4
Es ist absolut sicher, in fdisk ein wenig rumzuwandern und zu probieren,
solange man auf die Frage, ob die Änderungen abgespeichert werden
sollen, mit <b>N</b> antwortet und das Kommando <b>write</b> *NICHT*
benutzt.
d425 4
a428 1
Kopie des Bootblocks.
d446 2
d462 27
a780 1

a793 8
Um Softupdates aktivieren zu können, muss in deinen Kernel

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
einkompiliert sein. In GENERIC ist dies bereits der Fall.

<p>
d2266 2
a2267 2
Originally [OpenBSD: faq14.html,v 1.143 ]
$Translation: faq14.html,v 1.52 2005/12/12 09:37:44 paldium Exp $
@


1.45
log
@sync with Steelix CVS
@
text
@d1806 1
a1806 1
steven.mestdagh@@esat.kuleuven.be, and released under the BSD license -->
d2054 1
a2054 1
steven.mestdagh@@esat.kuleuven.be, and released under the BSD license -->
d2205 2
a2206 2
Originally [OpenBSD: faq14.html,v 1.142 ]
$Translation: faq14.html,v 1.51 2005/12/06 20:37:27 paldium Exp $
@


1.44
log
@sync with Steelix CVS
@
text
@d590 1
a590 1
das Gerät zur Zeit nicht sonderlich belastet oder vielmehr benutzt.
d1811 2
a1812 1
Beispiel nur schreibgeschützte - Unterstützung.
d2205 2
a2206 2
Originally [OpenBSD: faq14.html,v 1.141 ]
$Translation: faq14.html,v 1.49 2005/11/27 18:40:54 paldium Exp $
@


1.43
log
@sync with Steelix CVS
@
text
@d2204 2
a2205 2
Originally [OpenBSD: faq14.html,v 1.140 ]
$Translation: faq14.html,v 1.48 2005/11/24 14:01:39 paldium Exp $
@


1.42
log
@sync with steelix translation CVS
@
text
@d1155 1
a1155 1
<a href="faq8.html#Ports">Ports</a> verfügbar ist und auch mehrere
d2204 2
a2205 2
Originally [OpenBSD: faq14.html,v 1.139 ]
$Translation: faq14.html,v 1.47 2005/11/12 10:27:52 paldium Exp $
@


1.41
log
@sync with steelix translation CVS
@
text
@d1000 5
d2204 2
a2205 2
Originally [OpenBSD: faq14.html,v 1.138 ]
$Translation: faq14.html,v 1.46 2005/11/04 14:03:54 paldium Exp $
@


1.40
log
@sync with Steelix CVS
@
text
@d28 2
a29 1
<a href= "../faq13.html">[Zum Kapitel 13 - Multimedia]</a>
d58 4
d849 1
a849 1
     >> OpenBSD/i386 BOOT 2.06
d889 1
a889 1
>> OpenBSD/i386 BOOT 2.06
d897 1
a897 1
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org
d899 1
a899 1
OpenBSD 3.7 (GENERIC) #50: Sun Mar 20 00:01:57 MST 2005
a1655 2
Es wird nicht empfohlen, dass man 3.7-release hierfür einsetzt: es
gab einen Fehler, der mit 3.7-stable behoben wurde.
d1758 4
a1761 5
Seit OpenBSD 3.6 wird eine Kopie des Disklabels für jede Platte als
Teil der täglichen Systemverwaltung unter <tt>/var/backups</tt>
gespeichert. Angenommen, dass du die var-Partition weiterhin hast,
kannst du einfach die Ausgabe lesen und sie zurück in das Disklabel
schreiben.
d1804 2
a1805 2
ISO9660 (CD-ROM-, DVD-Medien), FAT (MS-DOS und Windows), NFS, NTFS
(Windows) und AmigaDOS. Einige von ihnen haben eingeschränkte - zum
d1859 11
a1869 1
welches eine Anzahl verschiedener Dateisysteme beinhaltet:
d1965 78
d2188 2
a2189 1
<a href= "../faq13.html">[Zum Kapitel 13 - Multimedia]</a>
d2199 2
a2200 2
Originally [OpenBSD: faq14.html,v 1.134 ]
$Translation: faq14.html,v 1.45 2005/10/29 10:44:51 paldium Exp $
@


1.39
log
@sync with steelix translation CVS
@
text
@d4 1
a4 1
<title>14 - Platten Einrichtung</title>
d27 1
a27 1
<a href= "index.html">[FAQ Index]</a>
d31 1
a31 1
<h1><font color="#e00000">14 - Platten Einrichtung</font></h1><hr>
d40 1
a40 1
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
d44 2
a45 2
<li><a href="#InstBoot"   >14.8 - Installieren von Bootblocks - i386
    spezifisch</a>
d49 2
a50 2
<li><a href="#pciideErr"  >14.11 - Hilfe! Ich erhalte Fehler mit IDE DMA!</a>
<li><a href="#RAID"       >14.13 - RAID Optionen unter OpenBSD</a>
d52 1
a52 1
    mehr als 100% von meiner Platte belegt habe?</a>
d54 1
a54 1
    das disklabel gelöscht wurde</a>
d69 1
a69 1
<li><a href="#disklabel.2">disklabel(8) während der OpenBSD Installation</a>
d78 2
a79 3
Lese zunächst die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
Manual Seite.
d83 9
a91 9
Festplatte und den Festplattentreibern, die im Kernel enthalten sind, zu
erzeugen. Labels enthalten bestimmte Informationen über deine Festplatte,
wie z.B. die Plattengeometrie und Informationen über deine Dateisysteme. Dies
wird dann vom ,bootstrap' Programm benutzt, um die Festplatte zu laden und um
zu wissen, wo auf der Platte die Dateisysteme sind. Labels werden auch
zusammen mit den Dateisystemen benutzt, um eine effizientere Umgebung
zu erzeugen. Tiefergehende Informationen über disklabel gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>
Manual Seite.
d95 3
a97 3
der Architekturgrenzen beim Partitionieren von Festplatten. Auf i386 kann man
z.B. nur 4 primäre Partitionen haben. (Partitionen, so wie sie andere
Betriebssysteme wie Windows NT oder DOS sehen.) Mit 
d99 3
a101 3
benutzt du eine dieser ,primären' Partitionen, die dann *alle* deine OpenBSD
Partitionen enthält (z.B. ,swap', ,/', ,/usr' und ,/var'). Und du hast noch 3
weitere für andere Betriebssysteme über!
d104 1
a104 1
<h3>disklabel(8) während der OpenBSD Installation</h3>
d107 2
a108 2
Einer der Hauptteile der OpenBSD Installation ist das erstmalige Erzeugen
der Labels. Das kommt (für i386 Benutzer) direkt nach der Benutzung von
d110 3
a112 3
Während der Installation benutzt du disklabel, um deine separaten Labels zu
erzeugen, die deine separaten Mount Points enthalten. Während der Installation
kannst du mittels 
d114 3
a116 3
deine Mount Points setzen, aber das ist eigentlich nicht nötig, da du deine
Änderungen später sowieso bestätigen musst. Aber es macht deine Installation
schon etwas geradliniger.
d119 9
a127 8
Da das während der Installation geschieht, hast du noch keine funktionierenden
Labels und sie müssen erst erzeugt werden. Das erste Label, das du erzeugst,
ist das Label ,a'. Das SOLLTE das Label sein, auf dem dann / gemountet wird.
Die empfohlenen Partitionen und ihren Größen kannst du dir unter
<a href="faq4.html#SpaceNeeded">FAQ4, Wieviel Platz brauche ich für eine
OpenBSD Installation?</a> ansehen. Für Server wird empfohlen,
zumindest diese Labels separat zu halten. Für Desktop User reicht vermutlich
ein einzelner Mountpoint /. Wenn du deine root-Partition (,a' Label)
d169 18
a186 17
An diesem Punkt hast du eine 64MB root Partition erzeugt, die mit / gemountet
wird und eine 64Meg Swap Partition. In diesem Fall startet der Offset bei
Sektor 63. So willst du es haben. Wenn es bei der Größe angekommen ist,
wird dir Disklabel die Größen in Sektoren angeben, du musst aber die Größen
nicht ebenfalls im gleichen Format eingeben. Wie im Beispiel oben kannst du
Größen zum Beispiel so eingeben: <i>64 Megabytes = 64M</i> und
<i>2 Gigabytes = 2G</i>. Disklabel wird dann einfach auf den naheliegendsten
Zylinder runden. Im obigen Beispiel kann man auch sehen, dass disklabel annimmt,
dass Label ,b' Swapbereich sein wird. Das ist eine korrekte Annahme,
da im GENERIC Kernel Swap auf Label ,b' festgelegt ist, und daher solltest
du dieser Richtlinie ebenfalls folgen und ,b' als Swapbereich benutzen. 

<p>
Das nächste Beispiel wird dich durch die Erzeugung zweier weiterer Labels
führen. Im Übrigen kann das keine komplette Installation sein, da die Größe
dieser beiden Partitionen nicht ausreicht, um OpenBSD komplett zu
installieren. Das Erzeugen dieser ganzen Partitionen dient nur zur
d211 7
a217 7
Im obigen Beispiel fallen dir vermutlich zwei Dinge auf. Zum einen, dass der
Offset, der als nächstes an der Reihe ist, automatisch für dich errechnet
wird. Wenn du eine solche Installation machst, musst du dich mit dem Ändern
der Offsets nicht herumschlagen. Ein weiterer Unterschied, der dir vielleicht
auffällt, ist, dass Label ,c' übersprungen wurde. Das ist aber Absicht, und
zwar deshalb, weil Label ,c' die ganze Festplatte repräsentiert. Aus diesem
Grund solltest du Label ,c' vollkommen in Ruhe lassen.
d223 1
a223 1
beenden (und mit der Installation weiterzumachen), tippe folgendes:
d236 5
a240 5
Wenn dein System erst einmal installiert ist, solltest du disklabel nicht
mehr allzuoft benutzen müssen. Aber du kannst es gebrauchen, wenn du z.B.
Festplatten hinzufügen willst, welche entfernen willst oder auch einfach
umstrukturieren möchtest. Eines der ersten Dinge, die du dann machst, ist,
dir den momentanen gültigen Disklabel anzusehen. Und das geht so:
d275 3
a277 3
sicher, dass du nichts kaputt machst oder durcheinanderbringst. (Was wir
alle von Zeit zu Zeit mal brauchen.) Um aber Veränderungen durchzuführen,
musst du die -E Option wie folgt mit angeben:
d284 10
a293 11
Das wird dich an einen Prompt bringen, und zwar den selben, den du
schon während der OpenBSD Installation benutzt hast. Das wahrscheinlich
wichtigste Kommando an diesem Prompt ist ,?'. Das erzeugt nämlich eine
Liste mit möglichen Optionen für Disklabel. Mit Hilfe von ,M' kannst du
dir sogar die gesamte 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
Manual Seite ansehen. Von diesem Prompt aus wirst du dein gesamtes
Hinzufügen, Löschen und Ändern der Partitionen vornehmen. Zusätzliche
Informationen gibt es in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
Manual Seite.
d297 2
a298 12
Um sicher zu sein, lese zuerst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
Manual Seite.

<p>
Fdisk ist ein Programm, das bei der Wartung deiner Partitionen
helfen soll. Dieses Programm wird auch bei der Installation benutzt, um
deine OpenBSD Partition einzurichten (diese Partition kann <u>mehrere</u>
Labels enthalten, jedes mit Dateisystemen/Swap/etc.). Es kann den Platz auf
deiner Festplatte aufteilen und eine Partition als aktiv markieren. Dieses
Programm wird für gewöhnlich im ,single user' Modus benutzt (boot -s).
Fdisk setzt auch den MBR auf deinen verschiedenen Festplatten.
d301 13
a313 3
Für Installationszwecke braucht man meistens nur <b>EINE</b> OpenBSD
Partition und benutzt dann disklabel, um Swap und Dateisysteme darauf zu
installieren.
d337 4
a340 3
In diesem Beispiel betrachten wir die Ausgabe des ersten SCSI Laufwerks.
Wir können die OpenBSD Partition (A6) und ihre Größe sehen. Der * sagt uns,
dass die OpenBSD Partition eine bootfähige Partition ist.
d343 4
a346 4
Im vorherigen Beispiel haben wir uns die Informationen nur angesehen. Was aber,
wenn wir unsere Partitionstabelle verändern wollen? Nun, dazu müssen wir
zunächst das <b>-e</b> Flag benutzen. Das bringt uns dann zu einer
Kommandozeile, die uns mit fdisk interagieren lässt.
d371 3
a373 2
solange man <b>N</b> auf die Frage antwortet, ob die Änderungen
abgespeichert werden sollen und *NICHT* das <b>write</b> Kommando benutzt.
d375 2
a376 2
<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe des
<b>-e</b> Flags benutzen kann.
d379 3
a381 3
<li><b>help</b>  Zeige eine Liste der Kommandos an, die fdisk im
interaktiven ,edit' Modus versteht.
<li><b>reinit</b>  Initialisiere die momentane im Speicher befindliche
d383 5
a387 4
<li><b>disk</b>  Zeige die momentane Plattengeometrie an, die fdisk
herausgefunden hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du willst.
<li><b>setpid</b> Ändere eine Partitionsidentifizierung des angegebenen
Partitionstabellen Eintrages. Dieses Kommando ist insbesondere nützlich,
d390 9
a398 9
des momentanen Bootblocks.  Das geschieht entweder im BIOS ,geometry' Modus
oder in Sektor-Offsets und Größen.
<li><b>flag</b>  Den jetzigen Partitionstabelleneintrag bootfähig machen.
Nur ein Eintrag zur Zeit kann bootbar sein. Wenn du von einer erweiterten
Partition booten willst, musst du auch den entsprechenden Eintrag als
bootfähig markieren.
<li><b>update</b>  Bringe den Maschinencode in der Speicherkopie des
momentanen Bootblocks auf aktuellen Stand.
<li><b>select</b>  Wähle und lade den Bootblock, auf den der Eintrag der
d400 1
a400 1
<li><b>print</b>  Gebe die momentan im RAM befindlichen und gewählte
d402 1
a402 1
<li><b>write</b>  Schreibe die RAM-Version des Bootblocks auf
d404 2
a405 2
<li><b>exit</b>  Verlasse den momentanen Level von fdisk, kehre entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlasse
d407 5
a411 5
<li><b>quit</b>  Verlasse den momentanen Level von fdisk, kehre entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlasse
das Programm, wenn es keinen gibt. Anders als exit schreibt diese Variante
den modifizierten Block auf die Platte.
<li><b>abort</b>  Verlasse das Programm ohne Änderungen zu speichern.
d418 2
a419 1
Nun, nachdem du deine Festplatte <b>SAUBER</b> eingebaut hast, musst du 
d421 1
a421 1
(<i> nur i386 </i>) und auch
d426 3
a428 3
Die i386 Leute starten mit fdisk. Andere Architekturen können das einfach
ignorieren. In dem Beispiel weiter unten werden wir dem System ein drittes
SCSI Laufwerk hinzufügen.
d432 3
a434 4
Das wird die "echte" Partitionstabelle der Festplatte für eine 
ausschließliche Benutzung von OpenBSD initialisieren.
Als nächstes musst du ein Disklabel dafür erzeugen.
Das wird wohl etwas verwirrend wirken.
d440 1
a440 1
<i>...bla...</i>
d443 1
a443 1
<i>...bla...</i>
d451 1
a451 1
Zunächst einmal ignoriere die ,c' Partition, sie ist immer da und
d453 5
a457 4
,fstype' für OpenBSD ist 4.2BSD. ,total sectors' ist die gesamte
Größe der Festplatte. Nehmen wir an, es handelt sich um eine 3 Gigabyte
Festplatte. Drei Gigabytes in der Sprache der Festplattenhersteller sind
3000 Megabytes.  Dividiere also 6185088/3000 (benutze
d460 7
a466 6
erstellen, rechne einfach X*2061, um X Megabytes Platz auf dieser Partition
zu erhalten. Der Offset für deine erste Partition sollte derselbe sein, wie
unter "sectors/track" vorher in disklabels Ausgabe angegeben. Bei uns ist es
63. Der Offset für jede Partition ist hinterher eine Kombination aus der
Größe und dem Offset jeder anderen Partition (mit Ausnahme der C Partition,
da sie keine Rolle in dieser Gleichung spielt).
d470 4
a473 4
Beispiel, wenn du das ganze Ding nur zum Ablegen von Webseiten oder einem
Heimatverzeichnis oder etwas anderem nutzen willst, nimm einfach die gesamte
Größe der Platte und ziehe die Sektoren pro Spur davon ab.
6185088-63 = 6185025.  Deine Partition ist
d482 8
a489 7
Dort kannst du "96M" benutzen, um "96 Megabytes" anzugeben.  (Oder, wenn
deine Festplatte groß genug ist, 96G für 96 Gigabytes!) Unglücklicherweise
benutzt der -E Modus die BIOS Plattengeometrie und nicht die reale, und
oft sind die beiden nicht deckungsgleich. Um dieses Problem zu umgehen,
tippe ,g d' für ,geometry disk'. (Andere Möglichkeiten sind ,g b' für
,Geometry BIOS' und ,g u' für ,geometry user' oder einfach das, was das
Label gesagt hat, bevor disklabel irgendwelche Änderungen gemacht hat.)
d492 2
a493 2
Das war eine Menge.  Aber du bist noch nicht fertig.  
Zuletzt musst du noch das Dateisystem auf der Festplatte mittels
d495 1
a495 1
erzeugen.
d502 3
a504 2
Oder wie auch immer deine Festplatte nach dem OpenBSD
Plattennummerierungs-Schema heißen mag. (Siehe einfach in der Ausgabe von
d510 1
a510 1
willst. Sagen wir einfach mal /u.  Daher erzeuge zunächst einmal /u. Dann
d518 1
a518 1
Zuletzt musst du sie noch zu
d525 4
a528 3
Was aber, wenn du ein existierendes Verzeichnis, wie zum Beispiel /usr/local
auslagern willst? Mounte die neue Platte unter /mnt und benutze <tt>cpio
-pdum</tt>, um /usr/local in das /mnt Verzeichnis zu kopieren. Passe die
d530 2
a531 2
Datei so an, dass die /usr/local Partition nun /dev/wd1a ist
(deine frisch formatierte Partition). Beispiel:
d538 5
a542 4
Reboote in den ,single user' Modus mit <b>boot -s</b>, verschiebe
das existierende /usr/local nach /usr/local-backup (oder lösche es gleich,
wenn du mutig bist) und erzeuge ein leeres Verzeichnis /usr/local.
Dann starte das System neu und voila, die Dateien sind da!
d550 2
a551 2
&quot;virtual memory exhausted&quot; Fehler bekommst, solltest du lieber
versuchen, deine ,per-process limits' zu erhöhen und zwar mit
d553 3
a555 2
oder auch mit
shs <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>.)
d562 1
a562 1
<h3>In eine Datei swappen. </h3>
d567 3
a569 3
Dateisystem mit SoftUpdates liegen (was ja standardmäßig deaktiviert ist).
Für den Anfang findest du erstmal heraus, wieviel Swap du momentan hast
und wieviel du davon benutzt, und das geht einfach mit dem
d571 1
a571 1
Werkzeug. Zum Beispiel mit diesem Kommando:
d580 8
a587 8
Das zeigt alle Geräte, die momentan für das swappen benutzt werden,
und ihre momentane Statistik an. Im obigen Beispiel gibt es nur ein Gerät
namens &quot;swap_device&quot;. Das ist der vordefinierte Bereich auf der
Platte, der für das Swappen benutzt wird. (Wird im Übrigen als Partition
,b' bei Disklabels angezeigt) Wie du auch sehen kannst, wird das Gerät
zur Zeit nicht sonderlich belastet oder vielmehr benutzt. Aber für den Zweck
dieses Dokumentes tun wir einfach so, als wenn noch weitere 32MB benötigt
werden würden.
d590 1
a590 1
Der erste Schritt, um eine Datei als Swapbereich zu nutzen, ist, die
d593 2
a594 1
Hier ist ein Beispiel, das die 32M große Datei <i>/var/swap</i> erzeugt.
d606 1
a606 1
dieses Device zu lenken
d615 1
a615 1
Swap-Devices hinzugefügt wurde.
d627 1
a627 1
du noch eine Zeile in deine <i>/etc/fstab</i> Datei hineinschreiben, so
d629 1
a629 1
nicht hinzugefügt wird, wird dieses Swap-Device eben nicht konfiguriert.
d637 1
a637 1
<h3>Swappen über ein vnode Device</h3>
d642 4
a645 4
Swap. Wenn du wd0a als root Dateisystem hast, und wd0b als bisherigen Swap, 
benutze diese Zeile in deiner Kernel Konfigurationsdatei (wenn du dir
nicht sicher bist, siehe dir das Kapitel "Einen neuen Kernel kompilieren"
in dieser FAQ an): 
d653 2
a654 2
werden soll. Du solltest dies mit dem selben Kommando wie in den vorherigen
Beispielen machen.
d675 3
a677 3
An diesem Punkt muss dein Computer neu gebootet werden, so dass die
Änderungen am Kernel Effekt haben. Nachdem das passiert ist, ist es an
der Zeit, das Gerät als Swap zu konfigurieren. Dazu wirst du
d689 1
a689 1
prüfen wir wieder, ob es auch korrekt in unsere Liste der Swap Devices
d704 1
a704 1
<h2>14.5 - Soft Updates</h2>
d708 3
a710 3
Soft Updates basieren auf einer Idee, die von
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
und Yale Patt</a> vorgeschlagen wurde, und wurden für FreeBSD von
d712 6
a717 5
SoftUpdates erzwingen eine gewisse Reihenfolge der Buffer Cache Operationen,
was die Anforderungen für das Entfernen des FFS Codes ermöglicht, der für
das synchrone Schreiben von Verzeichniseinträgen zuständig ist. Daher
konnte ein großer Geschwindigkeitsanwachs in der Leistung der Schreibzugriffe
auf Platten festgestellt werden.
d720 1
a720 1
Um Softupdates aktivieren zu können, muss in deinen Kernel folgende Option
d725 1
a725 1
einkompiliert sein, dies ist bereits in GENERIC eingetragen.
d728 2
a729 2
Die Aktivierung von Soft Updates muss mit einer mount-zeit Option
ausgeführt werden. Wenn eine Partition mit
d731 4
a734 4
gemountet wird, kannst du angeben, dass du Soft Updates auf dieser Partition
aktivieren möchtest. Unten ist ein Beispiel
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i>
Eintrag, der eine Partition <i>sd0a</i> hat, die wir mit Soft Updates
d742 4
a745 4
Hinweis für Sparc Anwender: Aktiviere Soft Updates nicht auf sun4 oder
sun4c Maschinen. Diese Architekturen unterstützen nur eine sehr begrenzte
Menge an Kernelspeicher und können diese Funktion nicht verwenden. Trotzdem
sind sun4m Maschinen in Ordnung.
d750 2
a751 2
funktioniert, kann brauchbar sein, um ein Problem zu lösen, wenn Dinge
nicht laufen. Es existieren vier Schlüsselmomente im Bootprozess:
d753 19
a771 20
<li><b><i>Master Boot Record (MBR):</i></b> Der Master Boot Record ist der
erste physikalische Sektor (512 Bytes) auf der Platte.
Er beinhaltet die primäre Partitionstabelle und ein kleines Programm, um
den Partition Boot Record (PBR) zu laden.
Bedenke, dass in einigen Umgebungen der Begriff "MBR" verwendet wird, um
nur auf den Code Teil dieses ersten Blockes auf der Platte zu verweisen,
statt auf den gesamten ersten Block (einschließlich der Partitionstabelle).
Es ist äußerst wichtig, die Bedeutung von "initialize the MBR" zu verstehen
-- in der Terminologie von OpenBSD würde es den gesamten MBR Sektor neu
schreiben, nicht nur den Code, so wie es auf anderen Systemen der Fall
sein könnte. Du wirst das nur selten machen wollen.
Verwende stattdessen fdisk(8)s "-u" Kommandozeilen Option
("<tt>fdisk -u wd0</tt>").

<p>
Während OpenBSD einen MBR beinhaltet, wirst du nicht gezwungen, ihn zu
verwenden, da so gut wie jeder MBR OpenBSD booten kann.
Der MBR wird von dem fdisk(8) Programm verändert, welches verwendet wird um
die Partitionstabelle zu editieren und ebenfalls um den MBR Code auf die
Platte zu installieren.
d779 1
a779 1
Zusätzlich zu dem Offensichtlichen, zeigt sie ebenfalls einen angehängten
d781 3
a783 3
LBA Übersetzung zum Booten zu verwenden. Wenn die Maschine nicht in der
Lage ist, LBA Übersetzung zu verwenden, wäre der obige Punkt mit einem
Semikolon (";") ausgewechselt worden, das auf CHS Übersetzung deutet:
d788 1
a788 1
Indikator für den "neuen" OpenBSD MBR angesehen werden kann, der mit
d794 5
a798 5
(benannt nach dem Namen der Datei, der den Code beinhaltet) genannt wird,
ist der erste physikalische Sektor der OpenBSD Partition auf der Platte.
Der PBR ist der "first-stage Bootloader" für OpenBSD.
Er wird vom MBR Code geladen und hat die Aufgabe, den OpenBSD ,second-stage'
Bootloader
d801 6
a806 7
Wie der MBR ist auch der PBR eine sehr kleine Sektion von Code und Daten,
insgesamt nur 512 Bytes.
Das ist nicht genug, um eine vollständig Dateisystem-bewusste
Applikation zu laden, so dass, statt den PBR <tt>/boot</tt> auf der
Platte ausfindig machen zu lassen, die BIOS-verfügbare Stelle von
<tt>/boot</tt> physikalisch in den PBR während der Installation
eingetragen wird.
d820 1
a820 1
verwendet, wenn er CHS Übersetzung verwendet, zeigt er eine Nachricht
d825 2
a826 2
Das ältere (vor v3.5) biosboot(8) zeigte die Nachricht "<tt>reading
boot...</tt>" an.
d828 12
a839 12
<li><b><i>Second Stage Bootloader, <tt>/boot</tt>:</i></b> <tt>/boot</tt> wird
vom PBR geladen und hat die Aufgabe, auf das OpenBSD Dateisystem durch das
BIOS der Maschine zuzugreifen und den aktuellen Kernel ausfindig zu machen
und zu laden. boot(8) übergibt ebenfalls verschiedene Optionen und
Informationen an den Kernel.
<p>
boot(8) ist ein interaktives Programm. Nachdem es geladen ist, versucht es,
<tt>/etc/boot.conf</tt> ausfindig zu machen und zu laden, wenn sie existiert
(was auf einer standardmäßigen Installation nicht der Fall sein muss) und
verarbeitet sämtliche Kommandos in ihr. Wenn es durch
<tt>/etc/boot.conf</tt> nicht anders angeordnet wurde, gibt es dem Benutzer
einen Prompt aus:
d849 5
a853 5
eingegeben wurde, startet es sein normales Verhalten: den Kernel, <tt>bsd</tt>,
von der root Partition der ersten Festplatte laden.
Der second-stage Bootloader untersucht (examines) deine Systemhardware durch
das BIOS (da der OpenBSD Kernel noch nicht geladen ist).
Oben kannst du ein paar Dinge sehen, die er gesucht und gefunden hat:
d855 2
a856 1
<li><b>pc0</b> - Die Standard-Tastatur und Bildschirmausgabe eines i386 Systems.
d858 5
a862 5
<li><b>apm</b> - Advanced Power Management BIOS Funktionen
<li><b>636k 190M</b> - Die Menge vom herkömmlichen (unterhalb von 1M) und
erweiterten (überhalb von 1M) Speicher, den er gefunden hat
<li><b>fd0 hd0+</b> - Die BIOS Laufwerke, die er gefunden hat, in diesem
Fall ein Floppy und ein Festplatten Laufwerk.
d865 10
a874 10
Das ,+' Zeichen nach "hd0" zeigt an, dass das BIOS <tt>/boot</tt> mitgeteilt
hat, dass diese Festplatte über LBA angesprochen werden kann.
Wenn eine erstmalige Installation ausgeführt wird, siehst du ab und zu einen
,*' nach einer Festplatte -- dies deutet auf eine Platte hin, die so scheint,
als wenn sie kein OpenBSD Disklabel beinhaltet.

<li><b><i>Kernel: <tt>/bsd</tt></i>:</b> Dies ist das Ziel des Bootprozesses,
den OpenBSD Kernel in den RAM zu laden und sauber auszuführen.
Wenn der Kernel einmal geladen wurde, kann OpenBSD direkt auf die Hardware
zugreifen, nicht mehr durch das BIOS.
d899 1
a899 1
<h3>Was kann fehlschlagen</h3>
d901 9
a909 7
<li><b>Schlechter/ungültiger/inkompatibler MBR:</b>
Normalerweise hat eine gebrauchte Festplatte irgendeinen MBR Code installiert,
aber wenn die Platte neu ist oder von einer anderen Plattform übernommen wurde
UND du nicht mit "Yes" auf die "Use entire disk" Frage vom
<a href="faq4.html#Disks">Installationsprozess</a> geantwortet hast, kann es
sein, dass du mit einer Platte ohne gültigem MBR da stehst und daher nicht
in der Lage sein wirst zu Booten, obwohl sie eine gültige Partitionstabelle hat.
d912 3
a914 3
Du kannst den OpenBSD MBR auf deine Festplatte unter Verwendung vom fdisk
Programm installieren. Boote dein Installationsmedium, wähle "Shell" aus, um
auf den Kommando-Prompt zu gelangen:
d920 2
a921 1
Du kannst auch einen spezifischen MBR auf deine Platte mit fdisk installieren:
d926 22
a947 19
das die Datei <tt>/usr/mdec/mbr</tt> als deinen System-MBR installieren wird.
Diese bestimmte Datei einer standardmäßigen OpenBSD Installation ist ebenfalls
der standardmäßige MBR, der in fdisk integriert wurde, aber jeder andere MBR
könnte hier angegeben werden.

<li><b>Ungültige <tt>/boot</tt> Ortsangabe im PBR installiert:</b>
Wenn installboot(8) den Partition Boot Record installiert, schreibt er die
Blocknummer und den Offset von <tt>/boot</tt>s Inode in den PBR.
Daher wird das Löschen oder Ersetzen von <tt>/boot</tt>, ohne
<a href="faq14.html#InstBoot">installboot(8)</a> erneut auszuführen, dein
System in eine Situation versetzen, in der es nicht mehr booten kann, da der
PBR laden wird, auf was auch immer die Inode zeigt, die angegeben wurde,
was vermutlich nicht mehr der erhoffte second-stage Bootloader sein wird!

Seit <tt>/boot</tt> unter Verwendung von BIOS Aufrufen ausgelesen wird, waren
ältere Versionen vom PBR sehr sensibel auf BIOS Plattenübersetzungen.
Wenn du die Plattengeometrie (z.B., wenn du die Platte aus einem Computer
genommen hast, der CHS Übersetzung verwendet hat, und es in einen steckst,
der LBA Übersetzung verwendet oder sogar die Übersetzungsoption im BIOS
d950 4
a953 5
nummerischen Block zugegriffen werden, um die gleichen Daten von der Platte
zu erhalten), so dass du installboot(8) erneut ausführen musst, bevor das
System neugestartet werden kann.
Der neue (von OpenBSD 3.5 und später) PBR ist sehr viel tolleranter im Bezug
auf Übersetzungsänderungen.
d956 2
a957 2
Da der PBR sehr klein ist, ist die Anzahl von Fehlermeldungen sehr begrenzt
und recht kryptisch. Typische Nachrichten sind:
d960 1
a960 1
<li><b>ERR R</b> -- Das BIOS gab einen Fehler zurück, als es versucht hat,
d964 8
a971 8
<li><b>ERR M</b> -- Eine ungültige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>
Nummer wurde aus dem second-stage Bootloader Header gelesen.
Dies bedeutet normalerweise, dass, was auch immer eingelesen wurde, NICHT
<tt>/boot</tt> war, was darauf hinweist, dass installboot(8) nicht korrekt
ausgeführt wurde, die /boot Datei geändert wurde oder du die Fähigkeit deines
BIOS erschöpft hast, um von einer <a href="#LargeDrive">großen Platte</a> zu
lesen.
d975 2
a976 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">biosboot(8)
Manual Seite</a> ausführlich besprochen.
d978 1
a978 1
Für weitere Informationen über den i386 Bootprozess, siehe
d982 1
a982 1
  Hale Landis' "How it Works" documents.
d986 2
a987 1
<h2>14.7 - Welche Probleme treten bei großen Festplatten mit OpenBSD auf?</h2>
d991 2
a992 2
2<sup>31</sup>-1, oder 2,147,483,647, Sektoren und da jeder Sektor 512 Bytes
groß ist, ist das ein kleiner Betrag unterhalb von 1T.
d995 8
a1002 7
Natürlich sind die Fähigkeit eines Dateisystems und die Fähigkeit einer
bestimmten Hardware zwei unterschiedliche Dinge.
Eine neue 250G IDE Festplatte wird nicht mit älteren (vor >137G Standard)
Interfaces funktionieren und einige sehr alte SCSI Adapter sind bekannt dafür,
dass sie Probleme mit moderneren Laufwerken haben und einige alte BIOSe
werden hängen, wenn sie einer modern-bestückten Festplatte begegnen.
Du musst die Fähigkeiten deiner Hardware natürlich respektieren.
d1005 22
a1026 22
Leider ist die volle Funktionalität des OS nicht verfügbar, bis NACHDEM das
OS in den Speicher geladen wurde.
Der Bootprozess verwendet (und ist daher auch darauf beschränkt) die Boot ROM
des Systems.

<p>
Aus diesem Grund muss die /bsd Datei (der Kernel) innerhalb des vom boot ROM
adressierbarem Bereich liegen.
Das bedeutet für einige ältere i386 Systeme, dass die root Partition
vollständig innerhalb der ersten 504M liegen muss, aber neuere Computer können
diese Grenze bei 2G, 8G, 32G, 128G oder mehr haben.
Es ist ebenfalls sinnvoll zu erwähnen, dass viele relativ neue Computer, die
Laufwerke mit mehr als 128G Speicher unterstützen tatsächlich eine BIOS
Begrenzung für die ersten 128G für das Booten haben.
Du kannst diese Systeme mit großen Laufwerken betreiben, aber deine root
Partition muss innerhalb der ersten 128G liegen.

<p>
Bedenke, dass es möglich ist, ein 40G Laufwerk in einen alten 486er einzubauen
und auf diesem OpenBSD mit einer großen Partition zu installieren und zu
denken, dass du erfolgreich die vorherige Regel gebrochen hast. Trotzdem
kann es dich auf einem höchst unangenehmen Weg verfolgen:
d1029 7
a1035 5
 <li>Du installiert eine 40G / Partition. Es funktioniert, da das Basis OS
und alle seine Dateien (einschließlich /bsd) innerhalb der ersten 504M liegen.
 <li>Du benutzt das System und endest mit mehr als 504M Dateien auf ihm.
 <li>Du aktualisiert und erstellst deinen eigenen Kernel, was auch immer, und
   kopierst deinen neuen /bsd über den alten.
d1037 2
a1038 2
 <li>Du bekommst eine Meldung wie "ERR M" oder andere Probleme während dem
   Booten.
d1041 5
a1045 5
Warum? Weil, wenn du eine neue /bsd Datei "über" die alte kopierst,
überschreibt sie nicht die alte, ihr wird einem neuen Ort auf der Platte
zugewiesen, möglicherweise außerhalb der 504M Grenze, die das
BIOS hat. Der Bootloader wird nun nicht mehr in der Lage sein, die /bsd Datei
zu erhalten und das System hängt.
d1049 4
a1052 4
<tt>/boot</tt> im Falle von i386) und der Kernel (<tt>/bsd</tt>) innerhalb
des Bereiches sein, den die Boot ROM unterstützt und innerhalb ihrer
eigenen Fähigkeiten.
Um sicher zu gehen, ist die Regel einfach:
d1055 1
a1055 1
<b>Die gesamte root Partition muss innerhalb des BIOS (oder Boot ROM)
d1059 1
a1059 1
Einige nicht-i386 Anwender denken, dass sie dies nicht betrifft, jedoch
d1061 2
a1062 2
Plattengröße. Herauszufinden, wie groß diese Begrenzung denn nun tatsächlich
ist, kann schwer sein.
d1069 1
a1069 1
<h3>fsck(8) Zeit- und Speicheranforderungen</h3>
d1075 7
a1081 6
Man sollte nicht ein 120G Dateisystem auf ein System mit 32M RAM setzen und
erwarten, dass es fsck(1) erfolgreich nach einem Crash ausführt.
Eine grobe Richtlinie ist, dass das System zumindest 1M Arbeitsspeicher für
jedes 1G des Plattenspeichers haben sollte, um erfolgreich fsck gegen die
Platte auszuführen. Die benötigte Zeit, um fsck gegen ein Laufwerk auszuführen
kann ein Problem werden, sobald das Dateisystem an Größe gewinnt.
d1084 1
a1084 1
<h2>14.8 - Installieren von Bootblocks - i386 spezifisch</h2>
d1087 25
a1111 23
Ältere Versionen von MS-DOS können nur mit Festplattengeometrien von 1024
Zylindern oder weniger klarkommen.  Da nahezu alle modernen Betriebssysteme
mehr als 1024 Zylinder haben, haben die meisten SCSI BIOS Chips (die auf
den SCSI Controller Karten) und IDE BIOSe (was Teil des restlichen PC BIOS
ist) eine Option, manchmal auch als Grundeinstellung, die wirkliche Geometrie
in etwas zu übersetzen, mit dem MS-DOS umgehen kann. Wie dem auch sei, nicht
alle BIOS Chips "übersetzen" die Geometrie in der selben Weise. Wenn du dein
BIOS wechselst (entweder mit einem neuen Motherboard oder einem neuen SCSI
Controller), und das neue benutzt eine andere "übersetzte" Geometrie, wirst
du nicht in der Lage sein, den ,second stage' Bootloader zu laden (und kannst
daher den Kernel auch nicht laden) (Das liegt daran, dass der ,first stage'
Bootloader eine Liste der Blöcke enthält, die /boot in der "übersetzten"
Geometrie enthalten.) Falls du IDE Platten benutzt und du Änderungen an
deinen BIOS Einstellungen machst, kannst du seine Übersetzung ebenfalls
(ungewollt) ändern. (die meisten IDE BIOSe bieten 3 verschiedene
Übersetzungen.) Um deinen Bootblock zu reparieren, damit du normal booten
kannst, stecke einfach eine Bootfloppy in dein Diskettenlaufwerk und gib
am Bootprompt "b hd0a:/bsd" ein, um ihn zu zwingen, von der ersten
Festplatte zu booten (und nicht von der Floppy).
Deine Maschine sollte normal booten. Jetzt musst du die erste Stufe des
Bootloaders auf den neuen Stand bringen. (Und dazu passend den Bootblock
schreiben.) <br> Unser Beispiel geht davon aus, dass deine Bootdisk sd0
ist (bei IDE wäre es wd0, etc..):
d1118 2
a1119 2
Wenn eine neuere Version von bootblocks benötigt wird, wirst du diese selber
kompilieren müssen. Und das geht so:
d1129 2
a1130 2
<h2>14.9 - Sich auf das Schlimmste vorbereiten: Backups und Wiederherstellen
von Band.</h2>
d1135 3
a1137 3
Wenn du so etwas wie einen Produktionsserver laufen lassen willst, ist es
ratsam, irgendeine Form von Backup zu haben, für den Fall, dass eine deiner
Festplatten versagt oder einen Crash hat.
d1140 1
a1140 1
Diese Information wird dir helfen, die Standard-Werkzeuge
d1144 1
a1144 1
,<a href="http://www.amanda.org">Amanda</a>', das über
d1152 6
a1157 6
Die Beispiele in diesem Dokument benutzen sowohl SCSI Festplatten als auch
Bänder. In einer Produktionsumgebung empfehlen wir SCSI und kein IDE wegen
der Art und Weise, wie IDE mit ,bad blocks' umgeht. Das heißt aber nicht,
dass diese Informationen nutzlos sind, wenn  du IDE benutzt,  sondern
einzig deine Gerätenamen werden sich leicht unterscheiden.  Zum Beispiel
wäre sd0a in einem IDE-basierten System wd0a.
d1159 1
a1159 1
<h3>Backup auf's Band bringen:</h3>
d1165 1
a1165 1
am Shell-Prompt heraus. Dabei sollte eine Ausgabe wie diese
d1175 3
a1177 3
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a, also
auf der SCSI-Festplatte 0, Partition a. Das /usr Dateisystem befindet sich
auf sd0h, also SCSI Festplatte 0, Partition h.
d1180 2
a1181 1
Ein weiteres Beispiel einer etwas größeren mount-Tabelle könnte so aussehen:
d1192 3
a1194 3
In diesem fortgeschritteneren Beispiel befindet sich das root (/) Dateisystem
auf sd0a. Das /var Dateisystem befindet sich auf sd0d, das /home Dateisystem
auf sd0e und schlussendlich /usr auf sd0h.
d1197 3
a1199 3
Um ein Backup deiner Maschine zu machen, musst du dump mit jeder festgelegten
Partition füttern. Hier ist ein Beispiel der Kommandos, um die einfachere
mount-Tabelle weiter oben zu sichern:
d1208 1
a1208 1
Für die etwas fortgeschrittenere mount-Tabelle würde man etwas wie das
d1221 3
a1223 4
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
Manual Seite ansehen, um genau zu erfahren, was jede Kommandozeilenoption
macht. Hier ist eine kurze Übersicht über die Parameter, die oben verwendet
wurden:
d1226 1
a1226 1
<li><b>0</b> - Führe einen Level 0 Dump durch, hole alles
d1228 4
a1231 3
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand, um zu
reflektieren, wann die letzte Sicherung gemacht wurde
<li><b>f</b> - Welches Bandlaufwerk benutzt werden soll (/dev/nrst0 in diesem Fall)
d1238 2
a1239 2
Das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>-Kommando
d1241 2
a1242 1
mt Manual Seite an, wenn du mehr Informationen haben willst (wie etwa eject).
d1245 3
a1247 3
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heißt, benutze einfach
dmesg, um das herauzufinden. Ein Beispieleintrag von dmesg für ein
Bandlaufwerk könnte so aussehen:
d1255 1
a1255 1
"<tt>nrst0</tt>" anstatt von "<tt>st0</tt>" bezeichnet wird, wie man es
d1257 4
a1260 4
benutzt du das selbe physikalische Gerät, aber sagst ihm, es soll nicht
zurückspulen, nachdem der Job im ,raw'-Modus beendet wurde. Um mehrere
Dateien auf ein einziges Band zu sichern, stelle sicher, dass du nicht
zurückspulst, sprich das richtige Gerät (<tt>rst0</tt>) benutzt,
d1266 2
a1267 2
Wenn du ein kleines Skript namens "backup" schreiben würdest, könnte es
z.B. so aussehen:
d1289 1
a1289 1
groß jedes Dateisystem sein muss. Du kannst ,<tt>df -h</tt>' benutzen,
d1295 7
a1301 7
Deine Daten wiederherzustellen hilft außerdem noch gegen Fragmentierung. Der
beste Weg, um sicherzustellen, dass du alle Dateien erwischst, ist es, im
,single user' Modus zu booten. Dateisysteme müssen nicht gemountet werden,
um gesichert zu werden. Vergiss aber nicht root (/) zu mounten, denn sonst
wird dein dump versagen, wenn er versucht, Dumpdaten zu schreiben. Gib
einfach "<tt>bsd -s</tt>" am boot&gt; Prompt ein, um in den ,single user'
Modus zu kommen.
d1303 1
a1303 1
<h3>Den Inhalt eines dump Bandes ansehen:</h3>
d1307 3
a1309 3
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es sicher
eine gute Idee, dein Band zu testen und sicherzustellen, dass es auch die
Daten enthält, die darauf sein sollen.
d1312 2
a1313 2
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien auf
einem dump Band zu bekommen:
d1320 2
a1321 2
Das listet die Dateien auf der 1. Partition auf dem dump Band (dem
Sicherungsband) auf. Wie in den Beispielen weiter oben, ist 1 dein root
d1326 1
a1326 1
umzulenken, würde man z.B. solch ein Kommando benutzen:
d1333 5
a1337 4
Wenn du eine mount-Tabelle wie die oben aufgeführte hast, wäre 2 /usr,
wenn deine aber etwas größer wäre, könnte 2 auch /var sein oder irgendwas
anderes. Die Sequenznummer ist auf jeden Fall die gleiche Reihenfolge, in
der das Dateisystem auf Band gesichert wird.
d1345 2
a1346 2
wiederherstellen willst, sieh dir die restore Manual Seite genau an und achte
besonders auf die Anweisungen zum interaktiven Modus.
d1350 6
a1355 6
Festplatte sehr schnell von statten gehen. Die Standard OpenBSD 
install/boot Floppy enthält bereits das benötigte restore Werkzeug, genauso
wie die ausführbaren Dateien, um neue Partitionen zu erstellen und deine
Festplatte bootfähig zu machen. In den meisten Fällen sind diese Floppies
und dein Sicherungsband alles, was du brauchst, um wieder alles
betriebsbereit zu bekommen.
d1364 3
a1366 3
Boote von der OpenBSD install/boot Floppy. An der Menüauswahl wähle Shell.
Nimm dein neuestes und schreibgeschütztes Band und lege es in dein Laufwerk
ein.
d1380 2
a1381 1
Sieh einfach in die <a href="#fdisk">fdisk FAQ</a>, um genaueres zu erfahren.
d1385 3
a1387 3
Mit dem disklabel Kommando stellst du dann deine OpenBSD Partitionstabelle
in der primären OpenBSD Partition wieder her, die du gerade mit fdisk
erzeugt hast. Beispiel:
d1394 2
a1395 2
(Vergiss den Swap nicht, siehe dazu die <a href="#disklabel">disklabel FAQ</a>
für weitere Informationen)
d1399 3
a1401 3
Benutze das newfs Kommando, um ein neues sauberes Dateisystem auf jeder
Partition zu erstellen, die du mit dem oben aufgeführten Schritten erstellt
hast. Beispiel:
d1410 1
a1410 1
Mounte dein neu vorbereitetes root (/) Dateisystem auf /mnt. Beispiel:
d1418 2
a1419 2
Wechsel in das gemountete root Dateisystem und beginne mit dem restore
Prozess. Beispiel: 
d1437 3
a1439 2
Zusätzlich zum Schreiben eines neuen MBR musst du Bootblöcke installieren,
um davon booten zu können. Das folgende ist ein kurzes Beispiel:
d1448 1
a1448 1
Dein neues root Dateisystem auf der eingebauten Festplatte sollte jetzt
d1450 4
a1453 4
der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht komplett
ist, solltest du alles im ,single user' Modus wiederherstellen. Am
Shellprompt benutze die folgende Kommandos, um deine Festplatten
"abzumelden" (umount) und das System anzuhalten:
d1462 3
a1464 2
Entferne die install/boot Floppy aus dem Laufwerk und reboote dein System.
Am OpenBSD boot&gt; Prompt benutze das folgende Kommando:
d1471 2
a1472 2
Das bsd -s führt dazu, dass der Kernel im ,single user' Modus gestartet
wird, der nur ein root (/) Dateisystem braucht.
d1476 7
a1482 6
Unter der Annahme, das du die obigen Schritte richtig ausgeführt hast und
nichts schief gegangen ist, solltest du von einem Prompt begrüßt werden,
der dich nach einem Pfad zu einer Shell fragt, oder du sollst Return
drücken. Drücke Return, um die sh zu benutzen. Als nächstes willst du sicher
root im r/w Modus (Schreib/Lese) remounten und nicht mehr im Nur-Lese-Modus
benutzen (ro). Dazu benutze folgendes: 
d1490 2
a1491 2
Sobald du im r/w Modus remountet hast, kannst du fortfahren, deine
restlichen Dateisysteme wiederherzustellen. Beispiel:
d1494 1
a1494 1
(einfache mount-Tabelle)
d1497 1
a1497 1
(umfassendere mount-Tabelle)
d1504 2
a1505 2
Benutze "<b>restore rvsf</b>" statt eines einfachen rsf, um die Namen
von Objekten zu sehen, während sie vom dump Set ausgepackt werden.
d1509 5
a1513 4
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme wiederhergestellt
hast, führe einen Reboot in den ,multi user' Modus durch. Wenn alles geklappt
hat, sollte dein System wieder genauso sein, wie zum Zeitpunkt deiner
letzten Sicherung, und bereit, wieder eingesetzt zu werden.
d1520 6
a1525 6
Um ein Diskimage (ISO-Images, Diskimages, die mit dd erstellt wurden, etc)
unter OpenBSD zu mounten, musst du ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>
Device konfigurieren. 
Zum Beispiel, wenn du ein ISO-Image unter <i>/tmp/ISO.image</i> hast,
würdest du die folgenden Schritte machen, um es zu mounten:
d1540 2
a1541 2
eine CD ist. Das gilt aber auch für die anderen Typen, also musst du
z.B. <i>ext2fs</i> beim Mounten eines Linux-Diskimages angeben. 
d1562 1
a1562 1
<h2>14.11 - Hilfe! Ich erhalte Fehler mit IDE DMA!</h2>
d1565 1
a1565 1
DMA IDE Übertragungen, die durch
d1567 6
a1572 5
unterstützt werden, sind unzuverlässig. Bis vor kurzem wurden die meisten
"mainstream" Betriebssysteme, die behaupteten, dass sie DMA Übertragungen
mit IDE Laufwerken unterstützen, nicht mit standardmäßig aktivierter
Unterstützung wegen unzuverlässiger Hardware ausgeliefert.
Nun werden viele dieser gleichen Maschinen mit OpenBSD verwendet.
d1575 1
a1575 1
OpenBSD ist aggressiv und versucht, den höchsten DMA Modus zu benutzen,
d1577 6
a1582 6
Datenkorruptionen aufgrund von defekten Motherboard Chipsets, fehlerhaften
Treibern, die buggy sind und/oder Lärm auf den Kabeln. Glücklicherweise
schützt Ultra-DMA die Datenübertragungen mit einem CRC, um Korruptionen
zu entdecken. Falls ein Fehler bei einem solchen Ultra-DMA CRC geschieht,
wird OpenBSD eine Fehlermeldung ausgeben und erneut versuchen, die Daten
zu übertragen.
d1592 1
a1592 1
Ultra-DMA Modi wird dann zu einem PIO Modus heruntergeschaltet.
d1595 16
a1610 16
UDMA Fehler werden meistens durch minderwertige oder beschädigte Kabel
verursacht. Kabelprobleme sollten normalerweise zuerst in Betracht gezogen
werden, wenn du viele DMA Fehler oder unerwartet niedrige DMA Leistung
erhälst. Es ist ebenfals eine schlechte Idee, das CD-ROM an den gleichen
Kanal wie die Festplatte zu stecken.

<p>
Wenn das Ersetzen der Kabel nicht zur Lösung des Problems führt und OpenBSD
nicht erfolgreich herunterschaltet oder der Prozess zu einem ,hard lock'
deiner Maschine führt, möchtest du vielleicht dein System auf einen
niedrigereren DMA oder UDMA Level standardmäßig begrenzen. Dies kann unter
Verwendung von <a href="faq5.html#BootConfig">UKC</a> oder
<a href="faq5.html#config">config(8)</a> realisiert werden, indem man die
Optionen des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>
Device ändert.
d1614 7
a1620 7
<h2>14.13 - RAID Optionen unter OpenBSD</h2>
RAID (Redundant Array of Inexpensive Disks) gibt die Möglichkeit, mehrere
Laufwerke zu verwenden, um bessere Leistung, Kapazität und/oder Redundanz
zu erhalten, als man aus einem einzelnen Laufwerk herausholen kann. Während
eine vollständige Diskussion über die Vorteile und Risiken von RAID außerhalb
des Rahmens dieses Artikels liegt, existieren einige Punkte, die so wichtig
sind, dass sie nun besprochen werden sollten:
d1627 2
a1628 2
Wenn diese Information neu für dich ist, ist das kein guter Ausgangspunkt,
um RAID zu erforschen.
d1631 1
a1631 1
OpenBSD beinhaltet RAIDframe, eine software-basierende RAID Lösung.
d1636 5
a1640 5
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe Homepage</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">Manual
     Seite für raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">Manual
     Seite für raid(4)</a>
d1644 2
a1645 2
Die root Partition kann direkt von OpenBSD unter Verwendung der
"Autoconfiguration" Option von RAIDframe gespiegelt werden.
d1648 1
a1648 1
OpenBSD 3.7-stable und neuer beinhaltet ebenfalls ,mirroring' als
d1651 1
a1651 1
Es wird nicht empfohlen, dass man 3.7-release hierfür einsetzt, es
d1664 1
a1664 1
<h3>Hardware Möglichkeiten</h3>
d1666 5
a1670 4
Viele OpenBSD <a href="../../de/plat.html">Plattformen</a> beinhalten
Unterstützung für etliche Hardware RAID Produkte. Die Möglichkeiten variieren
von Plattform zu Plattform, siehe die passende Hardwareunterstützungsseite
(<a href="../../de/plat.html">hier</a> aufgelistet).
d1673 6
a1678 5
Eine andere Möglichkeit, die für viele Plattformen bereit steht, ist eine
der vielen Produkte, die mehrere Laufwerke dazu bringt, wie ein großes IDE
oder SCSI Laufwerk zu agieren und die dann in einen standardmäßigen IDE
oder SCSI Adapter gesteckt werden. Diese Geräte können nahezu auf jeder
Hardwareplattform funktionieren, die entweder SCSI oder IDE verwenden.
d1688 2
a1689 2
(Hinweis: dies sind nur Produkte, die von OpenBSD Anwendern verwendet und
gemeldet wurden -- dies ist weder eine Art von Werbung noch ist es eine
d1695 1
a1695 1
<a href="../../de/mail.html">Mailinglisten</a> ist "Werden die
d1698 5
a1702 5
unterstützt?" Die Antwort ist "Nein". Diese Karten und
Chips sind nicht echte Hardware RAID Controller, stattdessen
eher BIOS-assistierte Bots für ein Software RAID. Da OpenBSD bereits
Software RAID in einem Hardware-unabhängigen Weg unterstützt, besteht kein
großes Verlangen bei den OpenBSD Entwicklern, diese spezielle Unterstützung
d1706 1
a1706 1
Fast alle on-board SATA- oder IDE-,RAID'-Controller sind von diesem
d1708 5
a1712 3
SATA- oder IDE-Controller unter Verwendung des standardmäßigen IDE-Treibers
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>),
aber werden nicht als Hardware-RAID-System unter OpenBSD funktionieren.
d1715 2
a1716 2
<h2>14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich mehr als 100% von
meiner Platte belegt habe?</h2>
d1718 2
a1719 2
<i>negativen</i> verfügbaren Plattenspeicher haben oder mehr als 100% einer
Partition in Verwendung ist, wie es von
d1727 6
a1732 6
Benutzern in Reserve gehalten. Dies stellt einen Spielraum für Fehler bereit,
wenn du versehentlich die Platte füllst und hilft, die Plattenfragmentierung
auf einem Minimum zu halten.
Standardwert hierfür ist 5% der Plattenkapazität, so dass, falls der root
Anwender sorglos die Platte auffüllt, du bis zu 105% Speicher sehen kannst,
der verwendet wird.
d1735 2
a1736 1
Wenn der 5% Wert für dich nicht angemessen erscheint, kannst du ihn mit dem
d1738 1
a1738 1
Kommando ändern.
d1741 1
a1741 1
<h2>14.15 - Partitionen wiederherstellen, nachdem das disklabel gelöscht
d1749 4
a1752 6
Zu aller erst Panik.
Das würde sowieso passieren, aber dann hast du es jedenfalls hinter dir.
Mach einfach nichts unvernünftiges.
Halte deine Panik von der Maschine fern.
Dann entspanne dich und guck, ob dir die unten stehenden Schritte
vielleicht weiterhelfen.
d1755 2
a1756 2
Seit OpenBSD 3.6 wird eine Kopie des disklabels für jede Platte als
Teil der täglichen Systemverwaltung in <tt>/var/backups</tt>
d1758 1
a1758 1
kannst du einfach die Ausgabe lesen und sie zurück in das disklabel
d1763 2
a1764 3
Möglichkeiten.
Behebe genug Fehler der Platte, bis du sie sehen kannst oder behebe
genug Fehler der Platte, um deine Daten von ihr zu bekommen.
d1766 1
a1766 1
Abhängig davon, was passiert ist, könnt der eine oder ein anderer
d1773 1
a1773 1
Das erste Tool, das du brauchst, ist
d1775 8
a1782 7
(achte auf den Unterstrich, es wird nicht ,scanffs' genannt).
scan_ffs(8) durchsucht die Platte und versucht, Partitionen zu finden,
und teilt dir die Informationen mit, die es über sie herausgefunden hat.
Du kannst diese Informationen nutzen, um das disklabel neu zu erstellen.
Wenn du einfach nur <tt>/var</tt> zurückhaben willst, kannst du die
Partition für <tt>/var</tt> wieder erstellen und dann das gesicherte
label nutzen, um den Rest von diesem aus zu erstellen.
d1786 3
a1788 3
wird sowohl die Erkenntnis des Kernels über das disklabel erneuern
als auch versuchen, das label auf die Platte zu schreiben.
Selbst wenn der Bereich der Platte, in dem das disklabel liegt, nicht
d1803 2
a1804 2
(Windows), AmigaDOS. Einige von ihnen haben eingeschränkte, zum
Beispiel nur lesbare, Unterstützung.
d1809 2
a1810 3
Dateisystem zu benutzen, muss es gemountet sein.
Für Details und Optionen für mount, konsultiere bitte die
Manualseite zu
d1813 1
a1813 1
mounten möchtest, z.B. mount_msdos, mount_ext2fs, ...
d1817 2
a1818 3
befindet. Vielleicht einfach deine erste Festplatte,
<tt>wd0</tt> oder <tt>sd0</tt>, aber es könnte auch weniger
offensichtlich sein.
d1822 1
a1822 1
aufgeführt: ein Device-Name, gefolgt von einer einzeiligen Beschreibung
d1849 2
a1850 3
Partitionen sich auf dem Device befinden, und auf welcher Partition sich
das gewünschte Dateisystem liegt.
Daher untersuchen wir das Device mit
d1852 4
a1855 5
Das Disklabel beinhaltet eine Liste von Partitionen, mit einer maximalen
Anzahl von 16. Partition c steht immer für das gesamte Device.
Partitionen a-b und d-p werden von OpenBSD genutzt.
Partitionen i-p können automatisch für Dateisysteme anderer
Betriebssysteme allokiert werden.
d1904 3
a1906 3
eine MSDOS-Partition aufgelistet, sowie ein paar ,unknown' Partitionen.
Auf i386- und amd64-Systemen kannst du mehr über diese unter Verwendung
des Werkzeugs
d1915 1
a1915 1
benutzen möchtest, kannst du den letzten Schritt durchführen: Das
d1917 1
a1917 1
Dateisysteme werden vom GENERIC-Kernel unterstützt: Werfe einfach einen
d1920 2
a1921 2
Einige werden jedoch nicht unterstützt, z.B. ist die NTFS-Unterstützung
experimentell und daher nicht im GENERIC.
d1940 1
a1940 1
Wenn du vor hast, dieses Dateisystem regulär zu nutzen, kannst du etwas
d1948 4
a1951 5
Beachte den Wert 0 im fünften und sechsten Feld.
Diese bedeuten, dass wir nicht möchten, dass die Dateisysteme mit
dump gesichert oder unter Verwendung von fsck überprüft werden.
Generell gilt, dass du solche Aufgaben eher mit dem dazugehörigem
Betriebssystem machen möchtest.
d1961 4
a1964 5
Schnittstelle deiner Maschine angeschlossen wird.
Kurz nach dem Anschließen werden einige Nachrichten auf der Konsole des
Kernels angezeigt.
Wenn ich zum Beispiel meinen USB-Flashspeicher anschließe, sehe ich
folgendes auf meiner Konsole:
d1977 6
a1982 7
(USB-Massenspeicher) -Treiber an das Speichergerät angehängt wurde und
dass es das SCSI-System nutzt.
Die beiden letzten Zeilen sind die wichtigsten: sie sagen, an welchem
Deviceknoten das Speichergerät angehängt wurde, und wie groß der gesamte
Speicherplatz ist.
Wenn du diese Zeilen warum auch immer verpasst haben solltest, kannst du
sie nachträglich mit dem Kommando
d1984 2
a1985 3
betrachten.
Die angegebene CHS-Geometrie ist eine fiktive, da der Flashspeicher
wie eine normale SCSI-Platte verarbeitet wird.
d1988 1
a1988 1
Wir werden zwei Szenarien weiter unten besprechen.
d1994 2
a1995 3
erstellen.
Bitte lese <a href="#disklabel">OpenBSDs disklabel verwenden</a> und die
Manualseite zu
d2000 1
a2000 1
In diesem Beispiel habe ich nur eine Partition <i>a</i> erstellt, auf
d2014 1
a2014 1
haben, unter <tt>/mnt/flashmem</tt> speichern.
d2061 3
a2063 3
Partition <i>i</i>, das ein FAT-Dateisystem beinhaltet, das von einer
Windows-Maschine erstellt wurde. Wie gewöhnlich stellt die Partition
<i>c</i> das gesamte Gerät dar.
d2080 2
a2081 2
konsistenten Zustand zurückgelassen werden, was in Datenverlusten
enden kann.
d2097 1
a2097 1
<a href= "index.html">[FAQ Index]</a>
d2109 1
a2109 1
$Translation: faq14.html,v 1.44 2005/10/21 14:19:59 paldium Exp $
@


1.38
log
@sync with Steelix CVS
@
text
@d1798 17
d2082 2
a2083 2
Originally [OpenBSD: faq14.html,v 1.133 ]
$Translation: faq14.html,v 1.43 2005/09/14 16:16:37 paldium Exp $
@


1.37
log
@sync with Steelix CVS
@
text
@a6 1
<meta http-equiv="Content-Language" content="de">
d10 1
a10 1
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
d12 1
d1122 1
a1122 1
<a href="faq1.html#Ports">Ports</a> verfügbar ist und auch mehrere
d2066 1
a2066 1
$Translation: faq14.html,v 1.42 2005/08/09 20:49:17 paldium Exp $
@


1.36
log
@sync with Steelix CVS
@
text
@a1222 1
</p>
d2066 1
a2066 1
$Translation: faq14.html,v 1.41 2005/07/31 14:45:41 paldium Exp $
@


1.35
log
@sync with Steelix CVS
@
text
@d1112 1
a1112 1
Wenn du so etwas wie einen Poduktionsserver laufen lassen willst, ist es
d1120 2
a1121 1
fortgeschritteneres Werkzeug ist ,Amanda', das über
d1125 1
a1125 1
aber ausreichend. Wenn du aber mehrere Maschinen auf ein Band sichern willst,
d2066 2
a2067 2
Originally [OpenBSD: faq14.html,v 1.132 ]
$Translation: faq14.html,v 1.40 2005/07/14 21:40:02 paldium Exp $
@


1.34
log
@sync with Steelix CVS
@
text
@a707 7
Das Potential eines Hintergrund fsck(8) unter Verwendung von Soft Updates
ist in OpenBSD noch nicht realisiert, so dass
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
weiterhin nach einem unsauberen Shutdown benötigt wird. Dies kann sich
in zukünftigen Versionen ändern.

<p>
d2065 2
a2066 2
Originally [OpenBSD: faq14.html,v 1.131 ]
$Translation: faq14.html,v 1.39 2005/06/08 17:04:49 paldium Exp $
@


1.33
log
@sync with Steelix CVS
@
text
@d55 4
d1622 17
d1766 293
d2072 2
a2073 2
Originally [OpenBSD: faq14.html,v 1.127 ]
$Translation: faq14.html,v 1.38 2005/05/30 09:56:43 paldium Exp $
@


1.32
log
@sync with steelix translation CVS
@
text
@d294 1
a294 1
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
d506 1
a506 1
<P>
a737 1
<p>
d795 5
a799 3
Das ist genug, um eine vollständig Dateisystem-bewusste Applikation zu laden,
die BIOS-verfügbare Stelle von <tt>/boot</tt> wird physikalisch in den
PBR während der Installation eingetragen.
a1107 1
<p>
d1121 1
a1121 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a> und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a>
d1123 4
a1126 3
fortgeschritteneres Werkzeug ist "Amanda", das auch mehrere Server auf
ein Bandlaufwerk sichern kann. In den meisten Umgebungen sind 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a>/<a href=http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a>
d1142 4
a1145 2
Dateisysteme gemountet sind. Das findet man mit dem  "mount"-Kommando am
Shell-Prompt heraus. Dabei sollte eine Ausgabe wie diese herauskommen:
d1167 1
a1167 1
</pre></ul>
d1217 2
a1218 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
Kommando wird am Ende benutzt, um das Band zurückzuspulen. Sieh dir die
d1233 8
a1240 7
"nrst0" anstatt von "st0" bezeichnet wird, wie man es in dmesg sieht.
Wenn du auf st0 statt nrst0 zugreifst, benutzt du das selbe physikalische
Gerät, aber sagst ihm, es soll nicht zurückspulen, nachdem der Job im
,raw' Modus beendet wurde. Um mehrere Dateien auf ein einziges Band zu
sichern, stelle sicher, dass du nicht zurückspulst, sprich das richtige
Gerät benutzt, ansonsten wirst du mit der zweiten Sicherung die erste
überschreiben, usw. Du findest in der dump Manual Seite eine ausführlichere
d1262 1
a1262 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&sektion=8">cron(8)</a>
a1263 1
</p>
d1266 5
a1270 5
Es ist außerdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie groß
jedes Dateisystem sein muss. Du kannst df -h benutzen, um herauszufinden,
wieviel Platz jede Partition momentan verbraucht. Das ist dann nützlich,
wenn eine Platte versagt und du die Partitionstabelle auf der neuen Platte
wieder erstellen musst.
d1348 2
a1349 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a>
Kommando, um eine primäre OpenBSD Partition auf dieser neu installierten
d1357 1
a1357 1
Sieh einfach in die <a href="#14.2">fdisk FAQ</a>, um genaueres zu erfahren.
d1370 1
a1370 1
(Vergiss den Swap nicht, siehe dazu die <a href="#14.1">disklabel FAQ</a>
d1499 1
a1499 1
<table border=0 width="800">
d1518 1
a1518 1
<table border=0 width="800">
d1531 1
a1531 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8">vnconfig(8)</a>
Manual Seite.
d1606 1
a1606 1
<li><a href="../faq11.html#raid">FAQ 11, RAID</a>
d1758 2
a1759 2
Originally [OpenBSD: faq14.html,v 1.126 ]
$Translation: faq14.html,v 1.36 2005/05/20 10:58:57 paldium Exp $
@


1.31
log
@sync with steelxi translation CVS
@
text
@d885 1
a885 1
OpenBSD 3.6 (GENERIC) #59: Fri Sep 17 12:32:57 MDT 2004
d1756 2
a1757 2
Originally [OpenBSD: faq14.html,v 1.125 ]
$Translation: faq14.html,v 1.35 2005/05/19 14:25:06 paldium Exp $
@


1.30
log
@sync with Steelix CVS
@
text
@d1756 2
a1757 2
Originally [OpenBSD: faq14.html,v 1.124 ]
$Translation: faq14.html,v 1.34 2005/05/09 11:40:13 paldium Exp $
@


1.29
log
@huge sync from the translators
@
text
@d1510 1
a1510 1
z.B. ffs beim Mounten eines Diskimages angeben. 
d1756 2
a1757 2
Originally [OpenBSD: faq14.html,v 1.123 ]
$Translation: faq14.html,v 1.33 2005/04/25 18:16:46 paldium Exp $
@


1.28
log
@Sync with Steelix CVS
@
text
@d28 1
a28 1
<a href= "faq12.html">[Zum Kapitel 12 - Plattform-spezifische Fragen]</a>
d53 3
d133 7
a139 10
Wenn die Festplatte mit anderen Betriebssystemen geteilt wird, sollten diese
Betriebssysteme einen BIOS Partitionseintrag haben, der den kompletten Platz
umfasst, den sie beanspruchen. Aus Sicherheitsgründen solltest du auch
sicherstellen, dass alle OpenBSD Dateisysteme innerhalb des Offsets und der
Größe sind, die in der ,A6' BIOS Partitionstabelle angegeben sind.
(Standardmäßig wird der disklabel Editor versuchen, das zu erzwingen). Wenn
du dir nicht sicher bist, wie man mehrere Partitionen sauber benutzt
(also wie man /, /usr, /tmp, /var, /usr/local und andere Dinge voneinander
trennt), belasse es jetzt erstmal bei einem root und einem Swap
Label.
d942 1
a942 1
Da der PBR sehr klein ist, ist die Anzahl an Fehlermeldungen sehr begrenzt
d1687 55
d1746 1
a1746 1
<a href= "../faq13.html">[Zum Kapitel 12 - Plattform-spezifische Fragen]</a>
d1756 2
a1757 2
Originally [OpenBSD: faq14.html,v 1.119 ]
$Translation: faq14.html,v 1.31 2005/02/12 20:20:48 paldium Exp $
@


1.27
log
@Sync with Steelix CVS
@
text
@d11 1
a11 1
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
d982 2
a983 2
Eine neue 250G IDE Festplatte wird nicht mit einem alten (vor >137G Standard)
Interface funktionieren und einige sehr alte SCSI Adapter sind bekannt dafür,
d1701 2
a1702 2
Originally [OpenBSD: faq14.html,v 1.118 ]
$Translation: faq14.html,v 1.30 2005/01/18 14:33:45 paldium Exp $
@


1.26
log
@Sync with Steelix CVS
@
text
@d8 1
a8 1
<meta name= "description"   content= "Die OpenBSD FAQ Seite">
d1700 5
a1704 3
Originally [OpenBSD: faq14.html,v 1.118 ]<br>
$Translation: faq14.html,v 1.29 2004/12/29 22:18:37 paldium Exp $<br>
$OpenBSD: faq14.html,v 1.118 2004/12/29 18:02:32 nick Exp $
@


1.25
log
@Sync with Steelix CVS
@
text
@d1642 1
a1642 1
<h3>Keine-Möglichkeit</h3>
d1645 5
a1649 3
<a href="../../de/mail.html">Mailinglisten</a> ist "Sind die Promise oder
HighPoint IDE RAID Controller unterstüzt?". Die Antwort ist "Nein". Diese
Karten und Chips sind nicht echte Hardware RAID Controller, stattdessen
d1655 6
d1700 3
a1702 3
Originally [OpenBSD: faq14.html,v 1.117 ]<br>
$Translation: faq14.html,v 1.28 2004/12/25 20:31:01 paldium Exp $<br>
$OpenBSD: faq14.html,v 1.117 2004/12/25 18:13:31 nick Exp $
@


1.24
log
@Sync with Steelix CVS
@
text
@d1692 3
a1694 3
Originally [OpenBSD: faq14.html,v 1.116 ]
<br>
$Translation: faq14.html,v 1.27 2004/11/14 12:57:36 paldium Exp $
a1695 3
<br>
<small>$OpenBSD: faq14.html,v 1.116 2004/11/10 13:32:55 otto Exp $</small>
</p>
@


1.23
log
@Sync with Steelix CVS
@
text
@d101 1
a101 1
Einer der Hauptteile der OpenBSD Installation ist das erste erstmalige Erzeugen
d104 2
a105 2
Während der Installation benutzt du disklabel, um deine separaten Label zu
erzeugen, die deine separaten Mountpoints enthalten. Während der Installation
d108 1
a108 1
deine Mountpoints setzen, aber das ist eigentlich nicht nötig, da du deine
d114 1
a114 1
Labels und sie müssen erst erzeugt werden. Das erste Label, das du erzeugt,
d119 1
a119 1
zumindest diese Label separat zu halten. Für Desktop User reicht vermutlich
d172 1
a172 1
Zylinder runden. Im obigen Beispiel kann man auch sehen, dass disklabel annimmt
d179 1
a179 1
führen. Im übrigen kann das keine komplette Installation sein, da die Größe
d303 1
a303 1
Programm wird für gewöhnlich im ,Single User' Modus benutzt (boot -s).
d335 1
a335 1
dass die OpenBSD Partition eine bootbare Partition ist.
d365 1
a365 1
Es ist absolut sicher in fdisk ein wenig rumzuwandern und zu probieren,
d376 1
a376 1
Kopie des Boot-Blocks.
d382 1
a382 1
<li><b>edit</b>  Ändere eine ausgewählte Plattengeometrie in Kopie
d385 1
a385 1
<li><b>flag</b>  Den jetzigen Partitionstabelleneintrag bootbar machen.
d391 2
a392 2
<li><b>select</b>  Wähle und lade den Boot block, auf den der Eintrag der
erweiterten Partitionstabelle im momentanen Boot-Block zeigt.
d394 2
a395 2
Kopie des Boot-Blocks und seinen MBR auf dem Bildschirm aus.
<li><b>write</b>  Schreibe die RAM-Version des Boot-Blocks auf
d398 1
a398 1
zur vorher gewählten Kopie eines Boot-Blocks im RAM zurück oder verlasse
d401 1
a401 1
zur vorher gewählten Kopie eines Boot-Blocks im RAM zurücke oder verlasse
d461 1
a461 1
Beispiel wenn das ganze Ding nur zum Ablegen von Webpages oder einem
d463 1
a463 1
Größe der Platte und ziehe die Sektoren pro Track davon ab.
d478 1
a478 1
Geometry BIOS' und ,g u' für ,geometry user' oder einfach das, was das
d519 1
a519 1
(deine frisch formatierte Partition.) Beispiel:
d554 1
a554 1
Für den Anfang findest du erstmal heraus, wieviel Swap du momentan hast,
d627 1
a627 1
swap. Wenn du wd0a als root Dateisystem hast, und wd0b als bisherigen swap, 
d747 1
a747 1
Es beinhaltet die primäre Partitionstabelle und ein kleines Programm, um
d752 1
a752 1
Es ist äußerst wichtig die Bedeutung von "initialize the MBR" zu verstehen
d772 1
a772 1
Zusätzlich zu dem Offensichtlichen, zeigt es ebenfalls einen angehängten
d774 1
a774 1
LBA Übersetzung zum Booten verwenden kann. Wenn die Maschine nicht in der
d790 1
a790 1
Es wird vom MBR Code geladen und hat die Aufgabe, den OpenBSD ,second-stage'
d828 2
a829 2
(was auf einer standardmäßigen Installation nicht der Fall sein muss),
verarbeitet es sämtliche Kommandos in ihr. Wenn es durch
d841 1
a841 1
eingegeben wurde, startet es sein normales verhalten: den Kernel, <tt>bsd</tt>,
d847 1
a847 1
<li><b>pc0</b> - Die Standard-Tastatur und Bildschirmausgabe eine i386 Systems.
d920 1
a920 1
Wenn installboot(8) den Partition Boot Record installiert, schreibt es die
d953 1
a953 1
Dies bedeutet normalerweise, dass was auch immer eingelesen wurde, NICHT
d956 1
a956 1
BIOS erschöpft hast, um von eomer <a href="#LargeDrive">großen Platte</a> zu
d980 1
a980 1
Natürlich ist die Fähigkeit eines Dateisystems und die Fähigkeit einer
d983 1
a983 1
Interfaces funktionieren und einige sehr alte SCSI Adapter sind bekannt dafür,
d1024 1
a1024 1
überschreibt sie nicht die alte, es wird einem neuen Ort auf der Platte
d1027 1
a1027 1
zu erhalten und das System hing.
d1032 1
a1032 1
des Bereiches sein, dass die Boot ROM unterstützt und innerhalb ihrer
d1057 1
a1057 1
Man sollte nicht ein 120G Dateisystem auf ein System mit 32M Ram setzen und
d1077 1
a1077 1
du nicht in der Lage sein den ,second stage' Bootloader zu laden (und kannst
d1080 1
a1080 1
Geometrie enthalten.) Falls du IDE Platten benutzt, und du Änderungen an
d1082 1
a1082 1
(ungewollt) ändern. (die meisten IDE BIOSse bieten 3 verschiedene
d1123 1
a1123 1
fortgeschritteneres Werkzeug ist "Amanda", das auch multiple Server auf
d1126 1
a1126 1
aber ausreichend. Wenn du aber multiple Maschinen auf ein Band sichern willst,
d1204 2
a1205 1
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand, um zu reflektieren, wann die letzte Sicherung gemacht wurde
d1230 4
a1233 4
"nrst0" anstatt von "sto" bezeichnet wird, wie man es in dmesg sieht.
Wenn du auf st0 als nrst0 zugreifst, benutzt du das selbe physikalische
Gerät, aber sagst ihm, es solle nicht zurückspulen, nachdem der Job im
,raw' Modus beendet wurde. Um multiple Dateien auf ein einziges Band zu
d1258 1
a1258 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&sektion=8&format=html">cron(8)</a>
d1266 1
a1266 1
wenn eine Platte versagt, und du die Partitionstabelle auf der neuen Platte
d1274 1
a1274 1
wird dein dump versagen, wenn er versucht Dumpdaten zu schreiben. Gib
d1318 2
a1319 2
komplett ausgefallen wäre. Falls du aber nur eine einzige Datei wieder
herstellen willst, sieh dir die restore man page genau an, und achte
d1354 1
a1354 1
Sieh einfach in die <a href="#14.2">fdisk FAQ</a> um genaueres zu erfahren.
d1367 1
a1367 1
(Vergiss den swap nicht, siehe dazu die <a href="#14.1">disklabel FAQ</a>
d1450 2
a1451 2
drücken. Drücke return, um die sh zu benutzen. Als nächstes willst du sicher
root im r/w Modus (Schreib/Lese) remounten, und nicht mehr im Nur-Lese-Modus
d1489 1
a1489 1
Um ein Disk Image (ISO-Images, Diskimages, die mit dd erstellt wurden, etc)
d1544 1
a1544 1
OpenBSD ist aggressiv und versucht den höchsten DMA Modus zu benutzen,
d1550 1
a1550 1
wird OpenBSD eine Fehlermeldung ausgeben, und erneut versuchen die Daten 
d1584 1
a1584 1
RAID (Redundant Array of Inexpensive Disks) gibt die Möglichkeit, multiple
d1587 2
a1588 2
eine volständige Diskussion über die Vorteile und Risiken von RAID außerhalb
des Ramens dieses Artikels liegt, existieren einige Punkte, die so wichtig
d1628 1
a1628 1
Hardwareplattform, die entweder SCSI oder IDE verwenden, funktionieren.
d1694 1
a1694 1
$Translation: faq14.html,v 1.26 2004/11/10 15:47:22 jufi Exp $
d1699 1
@


1.22
log
@Sync with Steelix CVS
@
text
@d1691 1
a1691 1
Originally [OpenBSD: faq14.html,v 1.115 ]
d1693 1
a1693 1
$Translation: faq14.html,v 1.25 2004/11/08 20:16:13 jufi Exp $
d1696 1
a1696 1
<small>$OpenBSD: faq14.html,v 1.115 2004/11/04 10:20:57 otto Exp $</small>
@


1.21
log
@more work from Tobias Stoeckmann, thanks !
@
text
@d8 2
a9 2
<meta name= "description"   content= "Die OpenBSD FAQ Seiten - FAQ 14: Einrichten von Festplatten">
<meta name= "keywords"      content= "openbsd,faq,festplatten,setup,partition">
d26 6
a31 2
<h2><font color=#e00000>14.0 - Disk Setup</font><hr></h2>
</p>
d33 20
a52 14
<p>
<ul><h3>Inhaltsverzeichnis</h3>
<li><a href="#14.1">14.1 - Benutzung von OpenBSD's disklabel</a></li>
<li><a href="#14.2">14.2 - Benutzung von OpenBSD's fdisk</a></li>
<li><a href="#14.3">14.3 - Zusätzliche Festplatten unter OpenBSD installieren</a></li>
<li><a href="#14.4">14.4 - Wie man in eine Datei 'swapt'</a></li>
<li><a href="#14.5">14.5 - Soft Updates</a></li>
<li><a href="#14.6">14.6 - Wenn ich nach der Installation von OpenBSD/i386 boote, stoppt der Rechner bei 
"Using partition 3 id 0".</a></li>
<li><a href="#14.7">14.7 - Wie man ein dmesg von einer Boot Floppy bekommt</a></li>
<li><a href="#14.8">14.8 - Bootblocks installieren- i386 spezifisch</a></li>
<li><a href="#14.9">14.9 - Auf das Disaster vorbereiten: Backups machen und Wiederherstellen mit Bändern.</a></li>
<li><a href="#14.10">14.10 - Disk images unter OpenBSD mounten</a></li>
<li><a href="#14.11">14.11 - Hilfe! Ich erhalte Fehler mit PCIIDE!</a></li>
a53 1
</p> 
d56 4
a59 5
<a name="14.1"></a>
<h2>Benutzung von OpenBSD's disklabel</h2>
   
<p>
<h3>Inhaltsangabe</h3>
d61 3
a63 3
<li><a href="#14.1.1">Was ist disklabel(8)?</a>
<li><a href="#14.1.2">Disklabel während der OpenBSD Installation</a>
<li><a href="#14.1.3">Gebräuchliche disklabel(8) Varianten</a>
d65 1
a65 1
</p>
d67 1
a67 2
<p>
<a name="14.1.1"></a>
a68 1
   
d72 2
a73 3
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page.
</p>
d76 10
a85 10
Disklabels werden erzeugt, um ein effizientes Interface zwischen deiner Festplatte
und den Festplattentreibern, die im Kernel enthalten sind, zu erzeugen. 'Labels' enthalten
bestimmte Informationen über dein Dateisystem, wie z.B. die 'drive geometry' und 
Informationen über deine Dateisysteme. Dies wird dann vom 'bootstrap' Programm benutzt,
um die Festplatte zu laden und um zu wissen, wo auf der Platte die Dateisysteme sind.
Labels werden auch zusammen mit den Dateisystemen benutzt, um eine effizientere Umgebung
zu erzeugen. Tiefergehende Informationen über 'disklabel' gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=5&format=html">disklabel(5)</a>
man page.
</p> 
d89 6
a94 7
der Architekturgrenzen beim Partitionieren von Festplatten. Auf i386 kann man z.B.
nur 4 primäre Partitionen haben. (Partitionen, so wie sie andere BS wie
Windows NT oder DOS sehen.) Mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
benutzt du eine dieser
'primären' Partitionen, die dann *alle* deine OpenBSD Partitionen 
enthält (z.B. 'swap','/','/usr' und '/var'). Und du hast noch 3
a95 1
</p>
d97 2
a98 12
<a name="14.1.2"></a>
<h3>disklabel während der OpenBSD Installation</h3>

<p>
Einer der Hauptteile der OpenBSD Installation ist das erste Erzeugen der 
'labels'. Das kommt (für i386 Benutzer) direkt nach der Benutzung von <a href="#14.2">fdisk(1)</a>.
Während der Installation benutzt du 'disklabel' um deine separaten 'label' zu erzeugen, die deine
separaten 'mountpoints' enthalten. Während der Installation kannst du mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a> 
deine Mountpoints setzen, aber das ist eigentlich nicht nötig, da du deine Änderungen später
sowieso bestätigen musst. Aber es macht deine Installation schon etwas geradliniger.
</p>
d101 25
a125 9
Da das während der Installation geschieht, hast du noch keine funktionierenden 'labels', und
sie müssen erst erzeugt werden. Das erste 'label', das du erzeugt, ist das Label 'a'. Das sollte
das Label sein, auf dem dann '/' gemountet wird. Die empfohlenen Partitionen und ihren Grössen 
kannst du dir auf <a href="faq4.html#4.3">faq4.3</a> ansehen. Für Server wird empfohlen zumindest diese
'label' separat zu halten. Für Desktop User reicht vermutlich ein einzelner Mountpoint '/'. 
Wenn du deine root-Partition ('a' Label) erzeugst, denk dran, dass du in jedem Fall noch etwas Platz für 
deine Swap-Partition benötigst. Jetzt kennst du die Grundlagen, und daher geben wir hier jetzt mal ein
Beispiel für das Benutzen von disklabel. In diesem ersten Beispiel wird angenommen, dass 
OpenBSD das einzige Betriebssystem auf diesem Computer ist, und eine volle/komplette Installation gemacht
a126 1
</p>
d128 1
a128 1
<ul><pre>
d130 10
a139 8
Wenn die Festplatte mit anderen Betriebssystemen geteilt wird, sollten diese BS einen
BIOS Partitionseintrag haben, der den kompletten Platz umfasst, den sie beanspruchen. 
Aus Sicherheitsgründen solltest du auch sicherstellen, dass alle OpenBSD Dateisysteme innerhalb 
des 'offset' und der Grösse sind, die in der 'A6' BIOS Partitionstabelle angegeben sind.
(Standardmässig wird der disklabel Editor das versuchen zu erzwingen). Wenn du dir nicht
sicher bist, wie man mehrere Partitionen sauber benutzt (also wie man /, /usr, /tmp, /var, /usr/local
und andere Dinge voneinander trennt), dann belasse es jetzt erstmal bei einer root und einer 
swap Partition.
d147 4
a150 4
&gt; <strong>d a</strong>
&gt; <strong>a a</strong>
offset: [63] <strong>&lt;Enter&gt;</strong>
size: [16386237] <strong>64M</strong>
d152 8
a159 8
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
&gt; <strong>a b</strong>
offset: [131103] <strong>&lt;Enter&gt;</strong>
size: [16255197] <strong>64M</strong>
d161 2
a162 2
FS type: [swap] <strong>&lt;Enter&gt;</strong>
</pre></ul>
d165 18
a182 9
An diesem Punkt hast du eine 64MB root Partition erzeugt, die mit / gemountet wird, und eine 64MB Swap Partition. 
In diesem Fall startet der Offset bei Sektor 63. So willst du es haben. Wenn es bei der Grösse angekommen
ist, wird dir Disklabel die Grössen in Sektoren angeben, du musst aber die Grössen nicht ebenfalls
im gleichen Format eingeben. Wie im Beispiel oben kannst du Grössen zum Beispiel so eingeben:
<i>64 Megabytes = 64M</i> und <i>2 Gigabytes = 2G</i>. Disklabel wird dann einfach auf den nächsten
Zylinder runden. Im obigen Beispiel kann man auch sehen, dass Disklabel annimmt, dass Label 'b' eine
Swap-Partition sein wird. Das ist eine korrekte Annahme, da im GENERIC Kernel Swap auf Label 'b' festgelegt
ist, und daher solltest du dieser Richtlinie ebenfalls folgen und 'b' als SwapBereich benutzen. 
</p>
d184 4
a187 10
<p>
Das nächste Beispiel wird dich durch die Erzeugung zweier weiterer Labels führen. Im übrigen kann
das keine komplette Installation sein, da die Grösse dieser beiden Partitionen nicht ausreicht, um OpenBSD
komplett zu installieren. Das Ganze dient nur zur Wiederholung und Vertiefung. 
</p>

<ul><pre>
&gt; <strong>a d</strong>
offset: [262143] <strong>&lt;Enter&gt;</strong>
size: [16124157] <strong>64M</strong>
d189 8
a196 8
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/tmp</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
&gt; <strong>a e</strong>
offset: [393183] <strong>&lt;Enter&gt;</strong>
size: [15993117] <strong>64M</strong>
d198 6
a203 6
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/var</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
</pre></ul>
d206 7
a212 6
Im obigen Beispiel fallen dir vermutlich zwei Dinge auf. Zum einen, dass der offset automatisch 
für dich errrechnet wird. Wenn du eine solche Installation machst, musst du dich mit dem
Ändern der Offsets nicht herumschlagen. Ein weiterer Unterschied, der dir vielleicht auffällt,
ist, dass Label 'c' übersprungen wurde. Das ist aber Absicht, und zwar deshalb, weil Label 'c' die ganze
Festplatte repräsentiert. Aus diesem Grund solltest du Label 'c' vollkommen in Ruhe lassen.
</p>
d215 4
a218 4
Sind deine Label erst einmal alle erzeugt, ist alles, was noch nötig ist, die Label auf die Festplatte 
zu schreiben, und einfach mit dem Installationsprozess fortzufahren. Um alles zu schreiben und disklabel zu
beenden (und mit der Installation weiterzumachen) tippe folgendes:
</p>
d220 4
a223 4
<ul><pre>
&gt; <strong>w</strong>
&gt; <strong>q</strong>
</pre></ul>
a225 6
<strong>*HINWEIS*</strong> - Für User mit grossen Festplatten: Wenn dein BIOS nicht in der Lage ist, eine
so grosse Festplatte zu unterstützen, kann OpenBSD das auch nicht. Ansonsten sollte OpenBSD keine 
Schwierigkeiten mit deiner Festplatte haben. Wenn dein BIOS das nicht kann, könntest du es mit
Maxtor EZ-Drive oder einem anderen 'Overlay' Produkt ausprobieren.
</p>

d227 2
a228 2
<a name="14.1.3"></a>
<h3>Gebräuchliche Benutzung von disklabel(8)</h3>
d231 5
a235 5
Wenn dein System erst einmal installiert ist, solltest du disklabel nicht mehr allzuoft benutzen müssen.
Aber du kannst es gebrauchen, wenn du z.B. Festplatten hinzufügen willst, welche entfernen willst oder
auch einfach umstrukturieren. Eines der ersten Dinge, die du dann machst, ist, dir den momentanen gültigen
Disklabel anzusehen. Und das geht so:
</p>
d237 2
a238 2
<ul><pre>
# <strong>disklabel wd0</strong> &gt;----- Oder was du dir auch immer für eine Platte ansehen willst
d266 1
a266 1
</pre></ul>
d269 4
a272 4
Der obige Befehl zeigt dir einfach den existierenden Disklabel, und stellt sicher, dass du nichts kaputt machst
oder durcheinanderbringst. (Was wir alle von Zeit zu Zeit mal brauchen.) Um aber Veränderungen 
durchzuführen, musst du die -E option mit angeben:
</p>
d274 3
a276 15
<ul><pre>
# <strong>disklabel -E wd0</strong>
</pre></ul>

<p>
Das wird dich einfach an einen Prompt bringen, und zwar den selben, den du schon während der OpenBSD Installation
benutzt hast. Das wahrscheinlich wichtigste Kommando ist '?'. Das erzeugt nämlich eine Liste mit möglichen
Optionen für Disklabel. Mit Hilfe von 'M' kannst du dir sogar die gesamte 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page ansehen. Von
diesem Prompt aus wirst du dein gesamtes Hinzufügen, Löschen und Ändern der Partitionen
vornehmen. Zusätzliche Informationen gibt es in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page.
</p>
d279 25
a303 13
<a name="14.2"></a>
<h2>14.2 - Benutzung von OpenBSD's fdisk</h2>
</p>
<p>
Um sicher zu sein, prüfe zuerst die fdisk man page:
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
</p>
<p>
Fdisk ist ein Programm, dass bei der Pflege und Wartung deiner Partitionen helfen soll.
Dieses Programm wird auch bei der Installation benutzt, um deine OpenBSD Partition einzurichten (
diese Partition kann <u>mehrere</u> Labels enthalten, jedes mit Dateisystemen/Swap/etc.).
Es kann den Platz auf deiner Festplatte aufteilen und eine Partition als aktiv setzen.
Dieses Programm wird für gewöhnlich im 'Single User Mode' benutzt werden (boot -s).
a304 1
</p>
d308 2
a309 2
Partition und benutzt dann disklabel, um Swap und Dateisysteme darauf zu installieren.
</p>
d312 3
a314 3
Um dir nur deine Partitionstabelle mit fdisk anzugucken:<br>
<ul>
<pre># <strong>fdisk fd0</strong><br>
a315 1
</ul>
d317 1
a318 1
</p>
a319 1
<ul>
d321 9
a329 9
         Disk: fd0       geometry: 80/2/18 [2880 sectors]
         Offset: 0       Signatures: 0xAA55,0x0
                  Starting        Ending
          #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
----------------------------------------------------------------------
         *0: A6    0   0   1 -   79   1  18 [         0 -       2880] OpenBSD
          1: 00    0   0   0 -    0   0   0 [         0 -          0] unused
          2: A7    0   0   2 -   79   1  18 [         1 -       2879] NEXTSTEP
          3: 00    0   0   0 -    0   0   0 [         0 -          0] unused
a330 1
</ul>
d333 3
a335 4
In diesem Beispiel betrachten wir die Ausgabe der Floppy Disk. Wir können die
OpenBSD Partition (A6) und ihre Grösse sehen. Der * sagt uns, dass die OpenBSD
Partition bootbar ist.
</p>
d338 4
a341 4
Im vorigen Beispiel haben wir uns die Informationen nur angesehen. Was aber, wenn wir unsere
Partitionstabelle verändern wollen? Nunja, dazu müssen wir zunächst das <b>-e</b>
flag benutzen. Das bringt uns dann zu einer Kommandozeile, die uns mit fdisk interagieren läßt.
</p>
d343 2
a344 3
<ul>
<PRE>
# <strong>fdisk -e wd0</strong>
d346 1
a346 1
fdisk: 1&gt; <strong>help</strong>
d350 1
d362 1
a362 2
</PRE>
</ul>
d365 6
a370 4
Es ist absolut sicher in fdisk ein wenig rumzuwandern und zu probieren, solange man <Strong>N</strong> auf die
Frage antwortet, ob die Änderungen abgespeichert werden sollen und *NICHT* das <strong>write</strong> 
Kommando benutzt.
</p>
a371 1
<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe des <b>-e</b> flags benutzen kann.<br>
d373 32
a404 15
<li><strong>help</strong>    Zeige eine Liste der Kommandos an, die fdisk im interaktiven 'edit mode' versteht.</li>
<li><strong>reinit</strong>  Initialisiere die momentane, im Speicher befindliche Kopie des Boot-Blocks.</li>
<li><strong>disk</strong>    Zeige die momentane Platten-Geometrie an, die fdisk herausgefunden hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du willst.</li>
<li><strong>edit</strong>     Ändere eine ausgewählte Platten-Geometrie in Kopie des momentanen Bootblocks.  Das geschieht entweder im BIOS geometry mode oder in sector offsets und Grössen.</li>
<li><strong>flag</strong>    Den jetzigen Partitionstabelleneintrag bootbar machen. Nur ein Eintrag zur Zeit kann bootbar sein. 
Wenn du von einer extended Partition booten willst, musst du auch den entsprechenden Eintrag als bootbar markieren. </li>
<li><strong>update</strong>  Bringe den Maschinencode in der Speicherkopie des momentanen Bootblocks auf aktuellen Stand.</li>
<li><strong>select</strong>  Wähle und lade den Boot block, auf den der Eintrag der erweiterten Partitionstabelle im momentanen Boot-Block zeigt.</li>
<li><strong>print</strong>   Gebe die momentan im RAM befindlichen und gewählte Kopie des Boot Blocks und seinen MBR auf dem Bildschirm aus.</li>
<li><strong>write</strong>   Schreibe die RAM-Version des Boot Blocks auf die Platte. Du wirst um eine Bestätigung gebeten.</li>
<li><strong>exit</strong>    Verlasse den momentanen Level von fdisk, kehre entweder zur vorher gewählten Kopie eines BootBlocks im RAM zurücke oder verlasse das Programm, wenn es keinen gibt.</li>
<li><strong>quit</strong>    Verlasse den momentanen Level von fdisk, kehre entweder zur vorher 
gewählten Kopie eines BootBlocks im RAM zurücke oder verlasse
das Programm, wenn es keinen gibt. Anders als exit schreibt diese Variante den modifizierten Block auf die Platte.</li>
<li><strong>abort</strong>   Verlasse das Programm ohne Änderungen zu speichern.</li>
d406 3
a408 2
</p>
<br>
d411 5
a415 3
<a name="14.3"></a>
<h2>14.3 - Zusätzliche Festplatten unter OpenBSD installieren</h2>
</p>
d418 6
a423 11
Nun, nachdem du deine Festplatte <strong>SAUBER</strong> eingebaut hast, musst du 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
(<i> nur bei i386 </i
>) und auch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&apropos=0&sektion=8&format=html">
disklabel(8)</a>, um deine Festplatte unter OpenBSD benutzen zu können. 
<P>
Die i386 Leute starten mit fdisk.  Andere Architekturen ignorieren das einfach.
<ul><pre>
# <Strong>fdisk -i sd2</strong>
</pre></ul>
d425 5
a429 5
ausschliessliche Benutzung mit OpenBSD initialisieren.
Als nächstes musst du einen disklabel dafür erzeugen.
Das wird wohl etwas verwirrend sein.
<UL><PRE>
# <strong>disklabel -e sd2</strong>
d442 22
a463 18
</pre></ul>
Zunächst einmal ignoriere die 'c' Partition, sie ist immer da und Programme wie disklabel
benötigen sie, um zu funktionieren.
Für den normalen Betrieb sollte die fsize immer 1024 sein, bsize immer 8192
und cpg immer 16.  Der Fstype ist 4.2BSD.  Total sectors ist die gesamte Grösse der Festplatte.
Nehmen wir an, es handelt sich um eine 3 Gigabyte Festplatte.  Drei Gigabytes in der Sprache der 
FestplattenHersteller sind 3000 Megabytes.  Rechne also 6185088/3000 (benutze bc(1)).  Du erhältst 2061.
um jetzt Partitionsgrössen für a, d, e, f, g, ... zu erhalten, rechne einfach X*2061
um X Megabytes Platz auf dieser Partition zu erhalten.  Der offset für deine erste Partition
sollte derselbe sein, wie von "sectors/track" vorher in disklabel's Ausgabe angegeben.
Bei uns ist es 63.  Der offset für jede Partition ist hinterher eine Kombination aus der
Grösse und dem Offset jeder anderen Partition (mit Ausnahme der C Partition, da sie keine
Rolle in dieser Gleichung spielt.)
<P>
Wenn du aber nur eine Partition auf deiner Festplatte brauchst, zum Beispiel wenn
das ganze Ding nur zum Ablegen von Webpages oder einem Homedirectory oder etwas anderem 
nutzen willst, nimm einfach die gesamte Grösse der Platte und ziehe die Sektoren pro Track
davon ab.
d465 2
a466 1
<UL><PRE>
d468 14
a481 12
</PRE></UL>
<P>
<b>Wenn dir das alles unnötig komplex erscheint, kannst du disklabel -E benutzten, um 
den selben Patitionierungsmodus zu erhalten, den du auf deiner Installationsdisk hattest!</b>
Dort kannst du "96M" benutzen, um "96 megabytes" anzugeben.  (Oder, wenn deine Festplatte gross
genug ist, 96G für 96 Gigabyte!) Unglücklicherweise benutzt der -E Modus die 
BIOS Platten-Geometrie und nicht die reale, und oft sind die beiden nicht deckungsgleich.
Um dieses Problem zu umgehen tippe 'g d' für 'geometry disk'.
(Andere Möglichkeiten sind 'g b' für Geometry BIOS' und 'g u' für 
geometry user, oder einfach das, was das Label gesagt hat, bevor disklabel irgendwelche
Änderungen gemacht hat.)
<P>
d483 3
a485 4
Zuletzt musst du noch das Dateisystem auf der Festplatte mittels <a href=
"http://www.openbsd.org/cgi-bin/man.cgi?query=newfs
&apropos=0&sektion=8&format=html">newfs(8)</a> erzeugen.
</p>
d487 3
a489 4
<p>
<ul><pre>
bsd# <strong>newfs wd1a </strong></pre></ul>
</p>
d492 4
a495 3
Oder wie deine Festplatte auch immer nach dem OpenBSD Plattennummerierungs-Schema heissen mag.  (Guck einfach
in der Ausgabe von dmesg(1) nach, da steht es drin.)
</p>
d498 3
a500 3
Nun überleg dir, wohin du deine gerade neu geschaffene Partition mounten willst.
Sagen wir einfach mal /u.  Daher erzeuge zunächst einmal /u mit 'mkdir'. Dann mounte sie.
</p>
d502 3
a504 3
<UL><PRE>
mount /dev/wd1a /u
</PRE></UL>
d507 5
a511 3
Zuletzt musst du sie noch zu /etc/fstab hinzufügen.
</p>
<UL><PRE>/dev/wd1a /u ffs rw 1 1</PRE></UL>
d514 6
a519 6
Was aber, wenn du ein existierendes Verzeichnis, wie zum Beispiel /usr/local auslagern willst? Mounte
die neue Platte unter /mnt und benutze cpio -pdum, um /usr/local in das /mnt Verzeichnis zu kopieren.
Passe  die /etc/fstab so an, dass jetzt die /usr/local Partition auf /dev/wd1a zu finden ist.
(Deine frisch formatierte Partition.) 
Beispiel:
</p>
d521 3
a523 3
<ul>
<strong>/dev/wd1a /usr/local ffs rw 1 1</strong>
</ul>
d526 4
a529 4
Reboote in den single user Mode.. <strong>boot -s</strong> Verschiebe das existierende
/usr/local nach /usr/local-backup (oder lösche es gleich, wenn du mutig bist) und erzeuge ein
leeres Verzeichnis /usr/local. Dann reboote das System, und voila! Die Dateien sind da!
</p>
a530 1
<br>
d532 2
a533 4
<p>
<a name="14.4"></a>
<h2>14.4 - Wie man in eine Datei swapt</h2>
</p>
d536 1
a536 1
(Hinweis: wenn du deshalb in eine Datei swappen willst, weil du immer 
d538 2
a539 2
versuchen deine 'per-process limits' zu erhöhen und zwar mit
csh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&sektion=1&format=html">unlimit(1)</a>,
d541 1
a541 2
sh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&sektion=1&format=html">ulimit(1)</a>.)
</p>
d544 3
a546 7
Nach der Veröffentlichung von OpenBSD 2.5 kam
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a> heraus, 
was den Umgang mit swap devices viel leichter machte. Falls du auf einem OpenBSD 2.5 System arbeitest, tausche swapctl mit swapon, und benutze pstat -s, um 
deine "swap devices" aufzulisten. Das Swappen in eine Datei benötigt keinen
selber gebauten Kernel, obwohl man das natürlich  trotzdem machen kann,
diese FAQ zeigt dir beide Wege den Swap zu erhöhen.
</p>
d552 2
a553 2
zusätzlichen Swap zu bekommen. Das gilt aber nicht für Benutzer von 
Soft Updates (was ja standardmässig nicht aktiviert ist).
d556 1
a556 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a>
a557 1
</p>
d559 2
a560 2
<ul><pre>
ericj@@oshibana&gt; <strong>swapctl -l</strong>
d563 1
a563 1
</pre></ul>
d567 8
a574 6
und ihre momentane Statistik. Im obigen Beispiel gibt es nur ein Gerät namens 
&quot;swap_device&quot;. Das ist der vordefinierte Bereich auf der Platte, der für das Swappen benutzt wird. 
(Wird im übrigen als Partition 'b' bei 'disklabel' angezeigt). Wie du auch sehen kannst, wird das Gerät
zur Zeit nicht sonderlich belastet oder vielmehr benutzt. Aber für den Zweck dieses Dokumentes tun wir einfach
so, als wenn noch weitere 32MB benötigt würden.
</p>
d576 4
a579 5
Der erste Schritt um eine Datei als Swap-Bereich zu nutzen, ist, die Datei zu erzeugen. Am besten macht man
das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&sektion=1&format=html">dd(1)</a>
Hier ist ein Beispiel, das eine Datei <i>/var/swap</i> mit der Grösse von 32MB erzeugt.
</p>
d581 2
a582 2
<ul><pre>
ericj@@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
d586 1
a586 1
</pre></ul>
d589 3
a591 3
Nachdem das erledigt ist, können wir jetzt das swappen auf diese Datei richten. Benutze einfach das folgende
Kommando, um das Swappen auf diese Datei zu lenken
</p>
d593 4
a596 4
<ul><pre>
ericj@@oshibana&gt; <strong>sudo chmod 600 /var/swap</strong>
ericj@@oshibana&gt; <strong>sudo swapctl -a /var/swap</strong>
</pre></ul>
d599 2
a600 2
Jetzt müssen wir noch prüfen, ob sie auch korrekt zu unserer Liste der Swap-Geräte hinzugefügt wurde.
</p>
d602 2
a603 2
<ul><pre>
ericj@@oshibana&gt; <strong>swapctl -l</strong>
d608 1
a608 1
</pre></ul>
d611 4
a614 4
Jetzt, wo die Datei erzeugt wurde und in sie hinein geswappt wird, musst du noch eine Zeile in deine
<i>/etc/fstab</i> Datei hineinschreiben, so dass die Datei beim nächsten Booten auch benutzt wird.
Wenn diese Zeile nicht hinzugefügt wird, wird dieses Swap-Gerät eben nicht konfiguriert.
</p>
d616 2
a617 2
<ul><pre>
ericj@@oshibana&gt; <strong>cat /etc/fstab</strong>
d620 1
a620 1
</pre></ul>
d622 1
a622 1
<h3>Swappen über ein vnode Gerät</h3>
d625 6
a630 5
Dies ist eine dauerhaftere Lösung, um mehr Swap-Speicher zu erhalten. Um in eine Datei zu swappen,
erzeuge zunächst einen Kernel mit vnd0c als swap. Wenn du wd0a als root Dateisystem hast, und wd0b als bisherigen swap, 
benutze diese Zeile in deiner Kernel Konfigurations-Datei (wenn du dir nicht sicher bist, sieh dir die Sektion "Einen neuen
Kernel kompilieren" in dieser FAQ an): 
</p>
d632 1
a632 1
<ul><pre>
d634 1
a634 1
</pre></ul>
d637 3
a639 3
Nachdem das erledigt ist, muss die Datei, in die geswappt werden soll, erzeugt werden. Du solltest mit dem selben Kommando wie 
im Beispiel oben machen.
</p>
d641 2
a642 2
<ul><pre>
ericj@@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
d646 1
a646 1
</pre></ul>
d649 3
a651 3
Da deine Datei jetzt an ihrem Platz ist, musst du die Datei in die <i>/etc/fstab</i> eintragen. Hier ist eine Beispielzeile,
mit der man dieses Gerät beim booten als Swap benutzt.
</p>
d653 2
a654 2
<ul><pre>
ericj@@oshibana&gt; <strong>cat /etc/fstab</strong>
d657 1
a657 1
</pre></ul>
d660 5
a664 4
An diesem Punkt muss dein Computer neu gebootet werden, so dass die Änderungen am Kernel Effekt haben. Nachdem das 
passiert ist, ist es an der Zeit, das Gerät als swap zu konfigurieren. Dazu wirst du <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8&format=html">vnconfig(8)</a> benutzen.
</p>
d666 2
a667 2
<ul><pre>
ericj@@oshibana&gt; <strong>sudo vnconfig -c -v vnd0 /var/swap</strong>
d669 1
a669 1
</pre></ul>
d672 4
a675 3
Als letzten Schritt, musst du den Swap auf diesem Gerät noch einschalten. Wir machen das genau wie in dem Beispiel oben mit
swapctl(8). Und zuletzt prüfen wir wieder, ob es auch korrekt in unsere Tabelle eingetragen wurde. 
</p>
d677 3
a679 3
<ul><pre>
ericj@@oshibana&gt; <strong>sudo swapctl -a /dev/vnd0c</strong>
ericj@@oshibana&gt; <strong>swapctl -l</strong>
d684 1
a684 1
</pre></ul>
d688 1
a688 1
<p><a name="14.5"></a>
d690 1
a690 1
</p>
d693 9
a701 12
In den letzten paar Jahren hat Kirk McKusick an etwas gearbeitet, was 
"Soft Updates" genannt wird. Es basiert auf einer Idee von Greg Ganger und Yale
Patt, die besagt, dass ein teilweises Ordnen der "buffer cache" Operationen die
Notwendigkeit des synchronen Schreibens von Verzeichnis Einträgen im FFS
Code überflüssig machen würde. Ergo ein großer Performance-Gewinn
beim Schreiben auf Festplatten.<br>
Da Soft Updates sich im Ganzen noch in Entwicklung befinden, wird ein fsck nach einem 
abrupten Abschalten des Computers ohne saubere Shutdown Sequenz immer noch notwendig sein,
das wird aber in zukünftigen Versionen entfallen.<p>
Mehr Interna und Details über Soft Updates kann man in den Untersuchungen von
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Ganger und Patt</a> 
und auch von <a href="http://www.mckusick.com/softdep/index.html">McKusick</a> finden. 
d703 6
a708 1
</p>
d711 1
a711 2
Um Softupdates aktivieren zu können, muss dein Kernel folgende Option haben:
</p>
d714 1
a714 3
<strong>option FFS_SOFTUPDATES</strong>
</p>

d716 1
a716 3
Diese Option ist beginnend mit OpenBSD Version 2.9 im GENERIC Kernel enthalten. Trotzdem musst du sie pro 
mount-Point mit Hilfe einer mount-Option aktivieren.
</p>
d719 8
a726 6
Beginnend mit 2.9 werden die soft updates durch eine "mount time" Option anstelle von 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&sektion=8">tunefs(8)</a> aktiviert. Wenn du jetzt 
eine Partition mit dem  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&sektion=8">mount(8)</a> 
Utility mountest, kannst du angeben, dass soft updates auf dieser Partition aktiviert sein sollen. Unten ein 
beispielhafter <i>/etc/fstab</i> Eintrag, der eine Partition <i>sd0a</i> hat, die wir mit soft updates gemountet haben wollen.
</p>
d728 1
a728 1
<ul><pre>
d730 1
a730 1
</pre></ul>
d733 32
a764 2
Wenn du eine ältere OpenBSD Version als 2.9 verwendest, boote in den single-user mode:
</p>
d766 48
a813 1
<ul>
d815 1
a815 4
        boot> <strong>boot -s</strong>
        [snip]
        bsd# <strong>tunefs -s enable &lt;raw device&gt;</strong>
        bsd# <strong>reboot -n</strong>
d817 2
a818 1
</ul>
d820 12
a831 5
<p>
Hinweis für Sparc User: Auf sun4 und sun4c Maschinen sollten soft updates nicht eingeschaltet werden.
Diese Archiktekturen unterstützen nur eine sehr begrenzte Menge an Kernel Speicher und können dieses Feature
nicht nutzen.
</p>
d833 22
a854 48
<p>
<a name="4.6"></a>
<h2>14.6 -  Wenn ich nach der Installation von OpenBSD/i386 boote, stoppt der Rechner bei "Using partition 3 id 0".</h2>
</p>
<p>
Das bedeutet, dass dein MBR (Master Boot Record) nicht sauber installiert wurde oder dass dein 
BIOS eine andere Idee hat, was die Geometrie deiner Fesplatte angeht, und zwar eine die nicht kompatibel ist
mit deinem jetzigen MBR. Um das Problem zu lösen, solltest du zuerst versuchen, den OpenBSD boot block erneut
zu installieren. Dazu lese
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&sektion=8&arch=i386&format=html">installboot(8)</a>.
<P>
Um es zunächst zum Laufen zu kriegen, musst du deine boot disk als bootstrap benutzen.
Danach tust du deine Install Disk rein, und bevor sie den Kernel und die ramdisk lädt, bekommst
du einen <tt>boot&gt;</tt> Prompt von der Floppy Disk.  Benutze ihn, um OpenBSD von deiner Festplatte zu booten.
<ul><pre>
booting...
OpenBSD boot 1.2.3
probing hd0 fd0...
boot&gt; <b>boot hd0a:/bsd</b>
</pre></ul>
Jetzt, da du gebootet hast, und unter der Vorraussetzung, dass du deine ganze
Festplatte für OpenBSD reserviert hast, kannst du den Master Boot Record  mit fdisk(8) reinitialisieren.
(Falls du auf deiner Festplatte Partitionen für andere Betriebssystem hast, kannst du auf keinen Fall 
<tt>installboot</tt> verwenden, stattdessen musst du dir eine andere Option wie z.B. OS-BS ansehen,
siehe weiter unten)
<UL><PRE>
# <b>fdisk -i wd0</b>
</PRE></UL>
Jetzt musst du die boot blocks wieder schreiben.
<UL><PRE>
# <strong>cp /usr/mdec/boot /boot</strong>
# <strong>/usr/mdec/installboot -v /boot /usr/mdec/biosboot wd0</strong>
</PRE></UL>
Und zum Schluss musst du rebooten und es testen.
<p>
Wenn das nicht funktioniert hat, hast du immer noch ein paar Optionen. Deine Glückssträhne ist
also noch nicht zu Ende. Die erste ist, einen Bootloader wie OS-BS zu verwenden. Auf der OpenBSD CD-ROM 
ist der os-bs Bootloader im 'tools' Verzeichnis. Wenn du keine CD-ROM gekauft hast, kannst du os-bs von jedem
OpenBSD ftp-Mirror herunterladen. Die benötigte Datei ist 
<tt>pub/OpenBSD/2.8/tools/osbs135.exe</tt>
</p>

<p>
Nimm dir auch die Zeit, dir die OS-BS Webseiten anzusehen: 
<a href="http://www.prz.tu-berlin.de/~wolf/os-bs.html">
         http://www.prz.tu-berlin.de/~wolf/os-bs.html</a>
</p>
d856 32
a887 4
<p>
Es gibt auch einige andere kommerzielle Bootloader oder auch lilo, die du für das 
multi-booting nehmen kannst.
</p>
a888 3
<p>
Hier ist eine kleine Anweisung, wie du lilo auf dein System bekommst.
</p>
d890 1
a890 1
<p>
d892 7
a898 7
<li>Boote mit einer DOS floppy und gib ein "fdisk /MBR" ein. Stelle sicher, dass du auch auf
der Festplatte bist, von der du booten willst.</li>
<li>Boote von einer Linux Disk, installiere LILO &amp; und verknüpfe es mit deinem OpenBSD 
Bootblock.
</li>
</ul>
</p>
d901 3
a903 2
Ausführlichere Anweisungen gibt es in <a href="ftp://ftp.openbsd.org/pub/OpenBSD/2.8/i386/INSTALL.linux">INSTALL.linux</a>
</p>
d905 3
a907 1
<br>
d909 4
a912 3
<p>
<a name="14.7"></a>
<h2>14.7 - Wie man ein dmesg von einer Boot-Floppy bekommt</h2>
d914 27
a940 6
</p>
<p>
RAMDISK Images (boot floppies) enthalten das <i>dmesg</i> Werkzeug leider nicht.
Sie mounten aber das <code>/kern</code> Dateisystem. Um die dmesg Informationen in eine
Datei zu kopieren kannst du z.B. folgendes eingeben:
</p>
d942 2
a943 8
<ul><pre>
# <strong>cat /kern/msgbuf >mydmesg</strong>
</pre></ul>
<P>
Boot disks enthalten aber 'more', um seitenweise durch die Ausgabe zu scrollen :
<pre><ul>
# <strong>more /kern/msgbuf</strong>
</pre></ul>
d945 13
a957 1
Prüfe auch die <a href="faq4.html#4.5">Sektion 4.5</a>
d959 4
a962 4
<p>
<a name="14.8"></a>
<h2>14.8 - Bootblocks installieren - i386 spezifisch</h2>
</p>
d964 1
a964 22
<p>
Ältere Versionen von MS-DOS können nur mit Festplattengeometrien von 1024 Zylindern
oder weniger klarkommen.  Da nahezu alle modernen Betriebssysteme mehr als 1024 Zylinder haben,
haben die meisten SCSI BIOS Chips (die auf den SCSI Controller Karten) und IDE BIOSse
(was Teil des restlichen PC BIOS ist) eine Option, manchmal auch als Grundeinstellung, die 
wirkliche Geometrie in etwas zu übersetzen, mit dem MS-DOS umgehen kann.
Wie dem auch sei, nicht alle BIOS Chips "übersetzen" die Geometrie in der selben Weise.
Wenn du dein BIOS wechselst (entweder mit einem neuen Motherboard oder einem neuen SCSI
Controller), und das neue benutzt eine andere "übersetzte" Geometrie, wirst du nicht
in der Lage sein den 'second stage boot loader' zu laden (und kannst daher den Kernel auch nicht laden)
(Das liegt daran, dass der 'first stage boot loader' eine Liste der Blöcke enthält, die
/boot in der "übersetzten" Geometrie enthalten.)
Falls du IDE Platten benutzt, und du Änderungen an deinen BIOS Einstellungen machst,
kannst du seine Übersetzung ebenfalls (ungewollt) ändern. (die meisten IDE BIOSse bieten 3 verschiedene
Übersetzungen.) Um deinen Bootblock zu reparieren, damit du normal booten kannst,
stecke einfach eine Boot floppy in dein Floppy-Laufwerk und gib am Bootprompt
"b hd0a:/bsd" ein, um ihn zu zwingen, von der ersten Festplatte zu booten (und nicht von der Floppy).
Deine Maschine sollte normal booten. Jetzt musst du die erste Stufe des Bootloaders auf den neuen Stand bringen.
(und dazu passend den Boot block schreiben).
<br>
Unser Beispiel geht davon aus, dass deine boot disk sd0 ist (bei IDE wäre es wd0, etc..) :
</p>
d966 3
a968 3
<pre>
# <strong>cd /usr/mdec; ./installboot /boot biosboot sd0</strong>
</pre>
d970 3
a972 10
<p>
Wenn installboot sich darüber beschwert, dass es die BIOS Geometrie nicht lesen kann, kannst du 
am boot&gt; Prompt das &quot;machine diskinfo&quot; (oder kürzer
&quot;ma di&quot; ) Kommando eingeben, damit es die Informationen ausgibt, die du brauchst.
Füttere die &quot;heads&quot; und &quot;secs&quot; Werte in installboot's -h
und -s Flags, so dass das modifizierte installboot Kommando wie folgt aussieht:
</p>
<ul><pre>
#<strong> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</strong>
</pre></ul>
d975 36
a1010 9
Wenn eine neuere Version von bootblocks benötigt wird, wirst du diese selber kompilieren müssen. Und das geht so:
</p>

<ul><pre>
# <strong>cd /sys/arch/i386/stand/</strong>
# <strong>make && make install </strong>
# <strong>cd /usr/mdec; cp ./boot /boot</strong>
# <strong>./installboot /boot biosboot sd0</strong> (oder wie deine Festplatte auch immer heissen mag)
</pre></ul>
d1012 10
d1023 68
a1090 3
<a name="14.9"></a>
<h2>14.9 - Auf die Katastrophe vorbereiten: Backups machen und Wiederherstellen mit Bändern (tapes)</h2>
</p>
d1092 3
a1094 1
<h3>Einführung:</h3>
d1097 2
a1098 3
Wenn du so etwas wie einen Poduktionsserver laufen lassen willst, ist es ratsam irgendeine Form von Backup zu haben,
für den Fall, dass eine deiner Festplatten versagt oder einen Crash hat.
</p>
d1100 6
a1105 6
<p>
Diese Information wird dir helfen die Standard-Werkzeuge <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a> und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> zu benutzen, die als Teil von OpenBSD ausgeliefert werden. 
Ein fortgeschritteneres Werkzeug ist "Amanda", das auch multiple Server auf ein Tape-Drive sichern kann. In den meisten Umgebungen sind 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a>/<a href=http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> aber ausreichend. 
Wenn du aber multiple Maschinen auf ein Band sichern willst, ist Amanda auf jeden Fall einen Blick wert.
</p>
d1108 3
a1110 5
Die Beispiele in diesem Dokument benutzen sowohl SCSI Festplatten, als auch Tapes. In einer Produktionsumgebung empfehlen wir SCSI und kein
IDE wegen der Art und Weise, wie IDE mit 'bad blocks' umgeht. Das heisst aber nicht, dass diese Informationen nutzlos sind, wenn 
du IDE benutzt,  sondern einzig deine Gerätenamen werden sich leicht unterscheiden.  Zum Beispiel wäre sd0a in einem
IDE-basierten System wd0a.
</p>
d1112 1
a1112 1
<h3>Backup auf's Tape bringen:</h3>
d1115 28
a1142 3
Um sein Backup auf ein Band zu bringen, muss man wissen, wo seine Dateisysteme gemountet sind. Das findet man mit dem 
"mount"-Kommando am Shell-Prompt heraus. Dabei sollte eine Ausgabe wie diese herauskommen:
</p>
d1144 2
a1145 2
<ul><pre>
shell# <b>mount</b>
d1148 1
a1148 1
</pre></ul>
d1151 3
a1153 3
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a, also auf der SCSI-Festplatte 0, Partition a. Das /usr 
Dateisystem befindet sich auf sd0h, also SCSI Festplatte 0, Partition h.
</p>
d1156 1
a1156 2
Ein weiteres Beispiel einer etwas grösseren mount-Tabelle könnte so aussehen:
</p>
d1158 2
a1159 2
<ul><pre>
shell# <b>mount</b>
d1167 3
a1169 3
In diesem fortgeschritteneren Beispiel befindet sich das root (/) Dateisystem auf sd0a. Das /var Dateisystem befindet sich auf sd0d, das /home 
Dateisystem auf sd0e und /usr auf sd0h.
</p>
d1172 3
a1174 3
Um ein Backup deiner Maschine zu machen, musst du 'dump' mit jeder festgelegten Partition füttern. Hier ist ein
Beispiel der Kommandos, um die einfachere mount-Tabelle weiter oben zu sichern:
</p>
d1176 1
a1176 1
<ul><pre>
d1180 1
a1180 1
</pre></ul>
d1183 2
a1184 2
Für die etwas fortgeschrittenere mount-Tabelle würde man etwas wie das hier benutzen:
</p>
d1186 1
a1186 1
<ul><pre>
d1192 1
a1192 1
</pre></ul>
d1195 5
a1199 2
Sieh dir einfach die dump-man-page für genauere Angaben über jedes Befehlsargument an.
</p>
a1209 1
</p>
d1212 4
a1215 3
Das mt Kommando wird am Ende benutzt, um das Band zurückzuspulen. Sieh dir die mt man page an, wenn du mehr Informationen
haben willst (wie etwa eject).
</p>
d1218 3
a1220 2
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heisst, benutze einfach dmesg, um das herauzufinden. Ein Beispiel-Eintrag von
dmesg für ein Bandlaufwerk könnte so aussehen:
d1223 3
a1225 3
<ul><pre>
st0 at scsibus0 targ 5 lun 0: <ARCHIVE, Python 28388-XXX, 5.28>
</pre></ul>
d1228 9
a1236 6
Du hast vielleicht bemerkt, dass bei der Sicherung das Bandlaufwerk als "nrst0" anstatt von "sto" bezeichnet wird, wie man es in dmesg sieht.
Wenn du auf st0 als nrst0 zugreifst, benutzt du das selbe physikalische Gerät, aber sagst dem Gerät, es solle nicht 
zurückspulen, nachdem der Job im raw mode beendet wurde. Um multiple Dateien auf ein einziges Band zu sichern, stelle sicher, dass du 
nicht zurückspulst, sprich das richtige Gerät benutzt, ansonsten wirst du mit der zweiten Sicherung die erste überschreiben,
usw. Du findest in der dump man page eine ausführlichere Beschreibung.
</p>
d1239 2
a1240 2
Wenn du ein kleines Skript namens "backup" schreiben würdest, könnte es z.B. so aussehen:
</p>
d1242 1
a1242 1
<ul><pre>
d1253 1
a1253 5
</pre></ul>

<p>
Wenn regelmässige nächtliche Backups gefordert sind, könnte man <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&sektion=8&format=html">cron(8)</a> benutzen, um das Backup jede Nacht automatisch zu starten.
</p>
d1256 3
a1258 3
Es ist ausserdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie groß jedes Dateisystem sein muss. Du kannst df -h benutzen,
um herauszufinden, wieviel Platz jede Partition momentan verbraucht. Das ist dann nützlich, wenn eine Platte versagt, und
du die Partitionstabelle auf der neuen Platte wieder erstellen musst.
d1262 14
a1275 5
Deine Daten wiederherzustellen hilft ausserdem noch gegen Fragmentierung. Der beste Weg, um sicherzustellen, dass du alle Dateien erwischst, 
ist es, im Single-User-Mode zu booten. Dateisysteme müssen nicht gemountet werden, um gesichert zu werden. Vergiss aber nicht root (/)
zu mounten, denn sonst wird dein dump versagen, wenn er versucht Dumpdaten zu schreiben. Gib einfach bsd -s am Boot-Prompt ein, um in
den Single-User-Modus zu kommen.
</p>
d1281 3
a1283 3
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es sicher eine gute Idee dein Band zu testen und sicherzustellen,
dass es auch die Daten enthält, die darauf sein sollen.
</p>
d1286 2
a1287 2
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien auf einem 'dump' Band zu bekommen:
</p>
d1289 1
a1289 1
<ul><pre>
d1291 1
a1291 1
</pre></ul>
d1294 3
a1296 3
Das listet die Dateien auf der 1. Partition auf dem dump Band (dem Sicherungsband) auf. Wie in den Beispielen weiter oben, ist 1 
dein root (/) Dateisystem.
</p>
d1299 2
a1300 3
Um den Inhalt der zweiten Partition zu sehen und die Ausgabe in eine Datei umzulenken, würde man z.B. solch ein Kommando 
benutzen:
</p>
d1302 1
a1302 1
<ul><pre>
d1304 1
a1304 1
</pre></ul>
d1307 4
a1310 4
Wenn du eine mount-Tabelle wie die oben aufgeführte hast, wäre 2 /usr, wenn deine aber etwas grösser wäre, könnte
2 auch /var sein oder irgendwas anderes. Die Sequenznummer ist auf jeden Fall die gleiche Reihenfolge, in der das Dateisystem auf Band 
gesichert wird.
</p>
d1316 13
a1328 10
Das Beispielszenario wäre sinnvoll, wenn deine eigentliche Festplatte komplett ausgefallen wäre. Falls du aber nur eine einzige 
Datei wieder herstellen willst, sieh dir die restore man page genau an, und achte besonders auf die Anweisungen zum interaktiven Modus.
</p>

<p>
Wenn du gut vorbereitet bist, kann der Prozess des Ersetzens einer Festplatte sehr schnell von statten gehen. Die Standard OpenBSD 
install/boot floppy enthält bereits das benötigte restore Werkzeug, genauso wie die ausführbaren Dateien, um neue Partitionen
zu erstellen, und deine Festplatte bootbar zu machen. In den meisten Fällen sind diese Floppy und dein Sicherungsband alles, was
du brauchst, um wieder alles betriebsbereit zu bekommen.
</p>
d1331 2
a1332 2
Nachdem du das kaputte Laufwerk physikalisch ersetzt hast, sind die grundlegenden Schritte zur Wiederherstellung folgende:
</p>
d1337 3
a1339 2
Boote von der OpenBSD install/boot floppy. An der Menüauswahl wähle Shell. Nimm dein neuestes und schreibgeschütztes
Band und packe es in dein Laufwerk.
a1340 2
</p>

d1343 4
a1346 3
Benutze das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> Kommando, um eine primäre
OpenBSD Partition auf dieser neu installierten Festplatte zu erzeugen. Z.B.:
</p>
d1348 3
a1350 3
<ul><pre>
shell# <b>fdisk -e sd0</b>
</pre></ul>
a1353 1
</p>
d1357 3
a1359 3
Mit dem disklabel Kommando stellst du dann deine OpenBSD Partitionstabelle in der primären OpenBSD Partition wieder her, die du gerade 
mit fdisk erzeugt hast. Z.B.:
</p>
d1361 3
a1363 3
<ul><pre>
shell# <b>disklabel -E sd0</b>
</pre></ul>
d1366 2
a1367 2
(Vergiss den swap nicht, siehe dazu die <a href="#14.1">disklabel FAQ</a>)
</p>
d1371 3
a1373 3
Benutze das newfs Kommando, um ein neues sauberes Dateisystem auf jeder Partition zu erstellen, die du mit dem oben aufgeführten 
Schritt erstellt hast. Z.B.:
</p>
d1375 4
a1378 4
<ul><pre>
shell# <b>newfs /dev/rsd0a</b>
shell# <b>newfs /dev/rsd0h</b>
</pre></ul>
a1382 1
</p>
d1384 3
a1386 3
<ul><pre>
shell# <b>mount /dev/sd0a /mnt</b>
</pre></ul>
d1390 2
a1391 2
Gehe in das gemountete root Dateisystem und beginne mit dem restore Prozess. Beispiel: 
</p>
d1393 4
a1396 4
<ul><pre>
shell# <b>cd /mnt</b>
shell# <b>restore -rs 1 -f /dev/rst0</b>
</pre></ul>
d1400 2
a1401 2
Wenn die Platte bootbar sein soll, schreibe mit dem folgenden Befehl einen neuen MBR auf deine Festplatte:
</p>
d1403 3
a1405 3
<ul><pre>
shell# <b>fdisk -i sd0</b>
</pre></ul>
d1409 2
a1410 3
Zusätzlich zum Schreiben eines neuen MBR musst du boot blocks installieren, um davon booten zu können.
Das folgende ist ein kurzes Beispiel:
</p>
d1412 4
a1415 4
<ul><pre>
shell# <b>cp /usr/mdec/boot /mnt/boot</b>
shell# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></ul>
d1419 6
a1424 5
Dein neues root Dateisystem auf der eingebauten Festplatte sollte jetzt fertig sein, so dass du davon booten kannst und damit beginnen
kannst, den Rest der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht komplett ist, solltest du alles im single-User Modus
wiederherstellen. Am shell prompt benutze die folgende Kommandos, um deine Festplatten "abzumelden" (umount) und das
System anzuhalten:
</p>
d1426 4
a1429 4
<ul><pre>
shell# <b>umount /mnt</b>
shell# <b>halt</b>
</pre></ul>
d1433 2
a1434 2
Entferne die Install/boot floppy aus dem Laufwerk und reboote dein System. Am OpenBSD boot&gt; prompt benutze das folgende Kommando:
</p>
d1436 1
a1436 1
<ul><pre>
d1438 1
a1438 1
</pre></ul>
d1441 2
a1442 2
Das bsd -s führt dazu, dass der Kernel im Single-User-Modus gestartet wird, der nur ein root (/) Dateisystem braucht.
</p>
d1446 6
a1451 5
Unter der Annahme, das du die obigen Schritte  richtig ausgführt hast und nichts schief gegangen ist, solltest du von einem Prompt begrüsst
werden, der dich nach einem Pfad zu einer Shell fragt, oder du sollst Return drücken. Drücke return, um die sh zu benutzen.
Als nächstes willst du sicher root im r/w Modus (Schreib/Lese) remounten, und nicht mehr im Nur-Lese-Modus benutzen (ro)
Dazu benutze folgendes: 
</p>
d1453 3
a1455 3
<ul><pre>
shell# <b>mount -u -w /</b>
</pre></ul>
d1459 6
a1464 2
Sobald du im r/w Modus remountet hast, kannst du fortfahren deine restlichen Dateisysteme wiederherzustellen. Beispiel:
</p>
d1466 5
a1470 9
<ul><pre>
(einfache mount Tabelle)
shell# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(etwas umfassendere mount Tabelle)
shell#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></ul>
d1473 2
a1474 3
Benutze "<b>restore rvsf</b>" anstatt eines einfachen rsf um die Namen von Objekten zu sehen, während sie vom dump set
ausgepackt werden.
</p>
d1478 4
a1481 3
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme wiederhergestellt hast, führe einen reboot in den Multi-User-Modus durch.
Wenn alles geklappt hat, sollte dein System wieder genauso sein, wie zum Zeitpunkt deiner letzten Sicherung, und wieder normal zu benutzen.
</p>
d1484 2
a1485 5
<p>

<a name=14.10></a>
<h2>14.10 - Disk Images in OpenBSD mounten</h2>
</p>
d1488 6
a1493 4
Um ein Disk Image (ISO images, Disk images, die mit  dd erstellt wurden, etc) in OpenBSD
zu moutnen, musst du ein <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&sektion=4">vnd(4)</a> Device/Gerät konfigurieren. 
Zum Beispiel, wenn du ein ISO Image unter <i>/tmp/ISO.image</i> hast, würdest du die folgenden Schritte machen, um es zu mounten:
</p>
a1494 1
<ul>
d1499 2
a1500 2
# <strong>vnconfig svnd0 /tmp/ISO.image</strong>
# <strong>mount -t cd9660 /dev/svnd0c /mnt</strong>
a1504 1
</ul>
d1507 3
a1509 3
Bedenke bitte, daß du den Typ <i>cd9660</i> angeben musst, wenn es eine CD ist. Das gilt aber auch für die 
anderen Typen, also musst du z.B. ffs beim mounten eines disk images angeben. 
</p>
d1512 1
a1512 2
Um das Image wieder 'unzumounten' benutze die folgenden Kommandos:
</p>
a1513 1
<ul>
d1518 2
a1519 2
# <strong>umount /mnt</strong>
# <strong>vnconfig -u svnd0</strong>
a1523 1
</ul>
d1527 2
a1528 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8">vnconfig(8)</a> man page.
</p>
d1530 2
d1534 22
a1555 3
<a name=14.11></a>
<h2>14.11 - Hilfe! Ich erhalte Fehler mit PCIIDE!</h2>
</p>
d1558 52
a1609 3
PCI IDE DMA ist unzuverlässig. Darum schaltet Microsoft es auch bei seinen
Betriebssystemen grundsätzlich ab.
</p>
d1612 2
a1613 7
OpenBSD ist aggressiv und versucht den höchsten DMA Modus zu benutzen, den es kriegen kann.
Dies führt in einigen Konfigurationen zu Datenkorruptionen aufgrund von defekten Motherboard Chipsets,
Treibern, die buggy sind und/oder Lärm auf den Kabeln. Glücklicherweise schützt Ultra-DMA
die Daten Transfers mit einem CRC, um Korruptionen zu entdecken. Falls ein Fehler bei einem solchen 
Ultra-DMA CRC geschieht, wird OpenBSD eine Fehlermeldung ausgeben, und erneut versuchen die Daten 
zu übertragen.
</p>
d1615 6
a1620 3
<ul><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79 (wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></ul>
d1623 5
a1627 4
Nach ein paar Fehlversuchen, wird OpenBSD zu einem langsameren (und damit hoffentlich 
zuverlässigeren) DMA-Modus herunterschalten. Nach den Ultra-DMA Modi wird 
dann zu einem PIO Modus heruntergeschaltet.
</p>
d1630 48
a1677 4
Falls OpenBSD nicht erfolgreich herunterschalten kann, oder der Prozess zu einem "Hard-Lock"
deiner Maschine führt, schicke uns bitte einen 
<a href="../../de/report.html">bug report</a>.
</p>
d1681 2
a1682 2
<a href= "index.html">[Zurück zu Haupt-Index]</a>
<a href= "../faq13.html">[Zu Sektion 13.0 - IPsec]</a>
a1683 1
</p>
d1691 4
a1694 1
Originally [OpenBSD: faq14.html,v 1.48 ]
d1696 1
a1696 3
$Translation: faq14.html,v 1.23 2004/11/02 18:04:29 jufi Exp $
<br></small>
<small>$OpenBSD: faq14.html,v 1.48 2001/10/03 14:52:56 jufi Exp $</small>
@


1.20
log
@Sync with Steelix CVS
@
text
@d1 1
d4 1
a4 1
<title>14.0 - Disk Setup</title>
d11 7
a17 1
<meta name= "copyright"     content= "This document copyright 1998-2001 by OpenBSD.">
d20 1
a20 1
<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">
d22 3
a24 1
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
d1345 1
a1345 1
$Translation: faq14.html,v 1.22 2004/10/29 21:28:08 jufi Exp $
@


1.19
log
@
cleaning up keywords and description
@
text
@d24 1
a24 1
<li><a href="#14.3">14.3 - Zus&auml;tzliche Festplatten unter OpenBSD installieren</a></li>
d31 1
a31 1
<li><a href="#14.9">14.9 - Auf das Disaster vorbereiten: Backups machen und Wiederherstellen mit B&auml;ndern.</a></li>
d45 2
a46 2
<li><a href="#14.1.2">Disklabel w&auml;hrend der OpenBSD Installation</a>
<li><a href="#14.1.3">Gebr&auml;uchliche disklabel(8) Varianten</a>
d56 1
a56 1
Lese zun&auml;chst die 
d64 2
a65 2
bestimmte Informationen &uuml;ber dein Dateisystem, wie z.B. die 'drive geometry' und 
Informationen &uuml;ber deine Dateisysteme. Dies wird dann vom 'bootstrap' Programm benutzt,
d68 1
a68 1
zu erzeugen. Tiefergehende Informationen &uuml;ber 'disklabel' gibt es in der
d74 1
a74 1
Zus&auml;tzlich f&uuml;hrt die Benutzung von disklabel zur &Uuml;berwindung
d76 1
a76 1
nur 4 prim&auml;re Partitionen haben. (Partitionen, so wie sie andere BS wie
d80 3
a82 3
'prim&auml;ren' Partitionen, die dann *alle* deine OpenBSD Partitionen 
enth&auml;lt (z.B. 'swap','/','/usr' und '/var'). Und du hast noch 3
weitere f&uuml;r andere Betriebssysteme &uuml;ber!
d86 1
a86 1
<h3>disklabel w&auml;hrend der OpenBSD Installation</h3>
d90 3
a92 3
'labels'. Das kommt (f&uuml;r i386 Benutzer) direkt nach der Benutzung von <a href="#14.2">fdisk(1)</a>.
W&auml;hrend der Installation benutzt du 'disklabel' um deine separaten 'label' zu erzeugen, die deine
separaten 'mountpoints' enthalten. W&auml;hrend der Installation kannst du mittels 
d94 2
a95 2
deine Mountpoints setzen, aber das ist eigentlich nicht n&ouml;tig, da du deine &Auml;nderungen sp&auml;ter
sowieso best&auml;tigen musst. Aber es macht deine Installation schon etwas geradliniger.
d99 8
a106 8
Da das w&auml;hrend der Installation geschieht, hast du noch keine funktionierenden 'labels', und
sie m&uuml;ssen erst erzeugt werden. Das erste 'label', das du erzeugt, ist das Label 'a'. Das sollte
das Label sein, auf dem dann '/' gemountet wird. Die empfohlenen Partitionen und ihren Gr&ouml;ssen 
kannst du dir auf <a href="faq4.html#4.3">faq4.3</a> ansehen. F&uuml;r Server wird empfohlen zumindest diese
'label' separat zu halten. F&uuml;r Desktop User reicht vermutlich ein einzelner Mountpoint '/'. 
Wenn du deine root-Partition ('a' Label) erzeugst, denk dran, dass du in jedem Fall noch etwas Platz f&uuml;r 
deine Swap-Partition ben&ouml;tigst. Jetzt kennst du die Grundlagen, und daher geben wir hier jetzt mal ein
Beispiel f&uuml;r das Benutzen von disklabel. In diesem ersten Beispiel wird angenommen, dass 
d115 3
a117 3
Aus Sicherheitsgr&uuml;nden solltest du auch sicherstellen, dass alle OpenBSD Dateisysteme innerhalb 
des 'offset' und der Gr&ouml;sse sind, die in der 'A6' BIOS Partitionstabelle angegeben sind.
(Standardm&auml;ssig wird der disklabel Editor das versuchen zu erzwingen). Wenn du dir nicht
d147 4
a150 4
In diesem Fall startet der Offset bei Sektor 63. So willst du es haben. Wenn es bei der Gr&ouml;sse angekommen
ist, wird dir Disklabel die Gr&ouml;ssen in Sektoren angeben, du musst aber die Gr&ouml;ssen nicht ebenfalls
im gleichen Format eingeben. Wie im Beispiel oben kannst du Gr&ouml;ssen zum Beispiel so eingeben:
<i>64 Megabytes = 64M</i> und <i>2 Gigabytes = 2G</i>. Disklabel wird dann einfach auf den n&auml;chsten
d157 2
a158 2
Das n&auml;chste Beispiel wird dich durch die Erzeugung zweier weiterer Labels f&uuml;hren. Im &uuml;brigen kann
das keine komplette Installation sein, da die Gr&ouml;sse dieser beiden Partitionen nicht ausreicht, um OpenBSD
d185 4
a188 4
f&uuml;r dich errrechnet wird. Wenn du eine solche Installation machst, musst du dich mit dem
&Auml;ndern der Offsets nicht herumschlagen. Ein weiterer Unterschied, der dir vielleicht auff&auml;llt,
ist, dass Label 'c' &uuml;bersprungen wurde. Das ist aber Absicht, und zwar deshalb, weil Label 'c' die ganze
Festplatte repr&auml;sentiert. Aus diesem Grund solltest du Label 'c' vollkommen in Ruhe lassen.
d192 1
a192 1
Sind deine Label erst einmal alle erzeugt, ist alles, was noch n&ouml;tig ist, die Label auf die Festplatte 
d203 3
a205 3
<strong>*HINWEIS*</strong> - F&uuml;r User mit grossen Festplatten: Wenn dein BIOS nicht in der Lage ist, eine
so grosse Festplatte zu unterst&uuml;tzen, kann OpenBSD das auch nicht. Ansonsten sollte OpenBSD keine 
Schwierigkeiten mit deiner Festplatte haben. Wenn dein BIOS das nicht kann, k&ouml;nntest du es mit
d211 1
a211 1
<h3>Gebr&auml;uchliche Benutzung von disklabel(8)</h3>
d214 3
a216 3
Wenn dein System erst einmal installiert ist, solltest du disklabel nicht mehr allzuoft benutzen m&uuml;ssen.
Aber du kannst es gebrauchen, wenn du z.B. Festplatten hinzuf&uuml;gen willst, welche entfernen willst oder
auch einfach umstrukturieren. Eines der ersten Dinge, die du dann machst, ist, dir den momentanen g&uuml;ltigen
d221 1
a221 1
# <strong>disklabel wd0</strong> &gt;----- Oder was du dir auch immer f&uuml;r eine Platte ansehen willst
d253 2
a254 2
oder durcheinanderbringst. (Was wir alle von Zeit zu Zeit mal brauchen.) Um aber Ver&auml;nderungen 
durchzuf&uuml;hren, musst du die -E option mit angeben:
d262 3
a264 3
Das wird dich einfach an einen Prompt bringen, und zwar den selben, den du schon w&auml;hrend der OpenBSD Installation
benutzt hast. Das wahrscheinlich wichtigste Kommando ist '?'. Das erzeugt n&auml;mlich eine Liste mit m&ouml;glichen
Optionen f&uuml;r Disklabel. Mit Hilfe von 'M' kannst du dir sogar die gesamte 
d267 2
a268 2
diesem Prompt aus wirst du dein gesamtes Hinzuf&uuml;gen, L&ouml;schen und &Auml;ndern der Partitionen
vornehmen. Zus&auml;tzliche Informationen gibt es in der 
d278 1
a278 1
Um sicher zu sein, pr&uuml;fe zuerst die fdisk man page:
d286 1
a286 1
Dieses Programm wird f&uuml;r gew&ouml;hnlich im 'Single User Mode' benutzt werden (boot -s).
d291 1
a291 1
F&uuml;r Installationszwecke braucht man meistens nur <b>EINE</b> OpenBSD
d302 1
a302 1
Was dann eine &auml;hnliche Ausgabe wie diese hier erzeugt:
d320 2
a321 2
In diesem Beispiel betrachten wir die Ausgabe der Floppy Disk. Wir k&ouml;nnen die
OpenBSD Partition (A6) und ihre Gr&ouml;sse sehen. Der * sagt uns, dass die OpenBSD
d327 2
a328 2
Partitionstabelle ver&auml;ndern wollen? Nunja, dazu m&uuml;ssen wir zun&auml;chst das <b>-e</b>
flag benutzen. Das bringt uns dann zu einer Kommandozeile, die uns mit fdisk interagieren l&auml;&szlig;t.
d355 1
a355 1
Frage antwortet, ob die &Auml;nderungen abgespeichert werden sollen und *NICHT* das <strong>write</strong> 
d359 1
a359 1
<p>Hier ist eine &Uuml;bersicht &uuml;ber die Kommandos, die man nach der Eingabe des <b>-e</b> flags benutzen kann.<br>
d363 2
a364 2
<li><strong>disk</strong>    Zeige die momentane Platten-Geometrie an, die fdisk herausgefunden hat. Du bekommst eine M&ouml;glichkeit sie zu &auml;ndern, wenn du willst.</li>
<li><strong>edit</strong>     &Auml;ndere eine ausgew&auml;hlte Platten-Geometrie in Kopie des momentanen Bootblocks.  Das geschieht entweder im BIOS geometry mode oder in sector offsets und Gr&ouml;ssen.</li>
d368 4
a371 4
<li><strong>select</strong>  W&auml;hle und lade den Boot block, auf den der Eintrag der erweiterten Partitionstabelle im momentanen Boot-Block zeigt.</li>
<li><strong>print</strong>   Gebe die momentan im RAM befindlichen und gew&auml;hlte Kopie des Boot Blocks und seinen MBR auf dem Bildschirm aus.</li>
<li><strong>write</strong>   Schreibe die RAM-Version des Boot Blocks auf die Platte. Du wirst um eine Best&auml;tigung gebeten.</li>
<li><strong>exit</strong>    Verlasse den momentanen Level von fdisk, kehre entweder zur vorher gew&auml;hlten Kopie eines BootBlocks im RAM zur&uuml;cke oder verlasse das Programm, wenn es keinen gibt.</li>
d373 1
a373 1
gew&auml;hlten Kopie eines BootBlocks im RAM zur&uuml;cke oder verlasse
d375 1
a375 1
<li><strong>abort</strong>   Verlasse das Programm ohne &Auml;nderungen zu speichern.</li>
d382 1
a382 1
<h2>14.3 - Zus&auml;tzliche Festplatten unter OpenBSD installieren</h2>
d391 1
a391 1
disklabel(8)</a>, um deine Festplatte unter OpenBSD benutzen zu k&ouml;nnen. 
d397 1
a397 1
Das wird die "echte" Partitionstabelle der Festplatte f&uuml;r eine 
d399 1
a399 1
Als n&auml;chstes musst du einen disklabel daf&uuml;r erzeugen.
d416 4
a419 4
Zun&auml;chst einmal ignoriere die 'c' Partition, sie ist immer da und Programme wie disklabel
ben&ouml;tigen sie, um zu funktionieren.
F&uuml;r den normalen Betrieb sollte die fsize immer 1024 sein, bsize immer 8192
und cpg immer 16.  Der Fstype ist 4.2BSD.  Total sectors ist die gesamte Gr&ouml;sse der Festplatte.
d421 3
a423 3
FestplattenHersteller sind 3000 Megabytes.  Rechne also 6185088/3000 (benutze bc(1)).  Du erh&auml;ltst 2061.
um jetzt Partitionsgr&ouml;ssen f&uuml;r a, d, e, f, g, ... zu erhalten, rechne einfach X*2061
um X Megabytes Platz auf dieser Partition zu erhalten.  Der offset f&uuml;r deine erste Partition
d425 2
a426 2
Bei uns ist es 63.  Der offset f&uuml;r jede Partition ist hinterher eine Kombination aus der
Gr&ouml;sse und dem Offset jeder anderen Partition (mit Ausnahme der C Partition, da sie keine
d431 1
a431 1
nutzen willst, nimm einfach die gesamte Gr&ouml;sse der Platte und ziehe die Sektoren pro Track
d438 1
a438 1
<b>Wenn dir das alles unn&ouml;tig komplex erscheint, kannst du disklabel -E benutzten, um 
d441 1
a441 1
genug ist, 96G f&uuml;r 96 Gigabyte!) Ungl&uuml;cklicherweise benutzt der -E Modus die 
d443 2
a444 2
Um dieses Problem zu umgehen tippe 'g d' f&uuml;r 'geometry disk'.
(Andere M&ouml;glichkeiten sind 'g b' f&uuml;r Geometry BIOS' und 'g u' f&uuml;r 
d446 1
a446 1
&Auml;nderungen gemacht hat.)
d465 2
a466 2
Nun &uuml;berleg dir, wohin du deine gerade neu geschaffene Partition mounten willst.
Sagen wir einfach mal /u.  Daher erzeuge zun&auml;chst einmal /u mit 'mkdir'. Dann mounte sie.
d474 1
a474 1
Zuletzt musst du sie noch zu /etc/fstab hinzuf&uuml;gen.
d492 1
a492 1
/usr/local nach /usr/local-backup (oder l&ouml;sche es gleich, wenn du mutig bist) und erzeuge ein
d506 1
a506 1
versuchen deine 'per-process limits' zu erh&ouml;hen und zwar mit
d513 1
a513 1
Nach der Ver&ouml;ffentlichung von OpenBSD 2.5 kam
d516 3
a518 3
deine "swap devices" aufzulisten. Das Swappen in eine Datei ben&ouml;tigt keinen
selber gebauten Kernel, obwohl man das nat&uuml;rlich  trotzdem machen kann,
diese FAQ zeigt dir beide Wege den Swap zu erh&ouml;hen.
d525 3
a527 3
zus&auml;tzlichen Swap zu bekommen. Das gilt aber nicht f&uuml;r Benutzer von 
Soft Updates (was ja standardm&auml;ssig nicht aktiviert ist).
F&uuml;r den Anfang findest du erstmal heraus, wieviel Swap du momentan hast,
d540 6
a545 6
Das zeigt alle Ger&auml;te, die momentan f&uuml;r das swappen benutzt werden,
und ihre momentane Statistik. Im obigen Beispiel gibt es nur ein Ger&auml;t namens 
&quot;swap_device&quot;. Das ist der vordefinierte Bereich auf der Platte, der f&uuml;r das Swappen benutzt wird. 
(Wird im &uuml;brigen als Partition 'b' bei 'disklabel' angezeigt). Wie du auch sehen kannst, wird das Ger&auml;t
zur Zeit nicht sonderlich belastet oder vielmehr benutzt. Aber f&uuml;r den Zweck dieses Dokumentes tun wir einfach
so, als wenn noch weitere 32MB ben&ouml;tigt w&uuml;rden.
d551 1
a551 1
Hier ist ein Beispiel, das eine Datei <i>/var/swap</i> mit der Gr&ouml;sse von 32MB erzeugt.
d562 1
a562 1
Nachdem das erledigt ist, k&ouml;nnen wir jetzt das swappen auf diese Datei richten. Benutze einfach das folgende
d572 1
a572 1
Jetzt m&uuml;ssen wir noch pr&uuml;fen, ob sie auch korrekt zu unserer Liste der Swap-Ger&auml;te hinzugef&uuml;gt wurde.
d585 2
a586 2
<i>/etc/fstab</i> Datei hineinschreiben, so dass die Datei beim n&auml;chsten Booten auch benutzt wird.
Wenn diese Zeile nicht hinzugef&uuml;gt wird, wird dieses Swap-Ger&auml;t eben nicht konfiguriert.
d595 1
a595 1
<h3>Swappen &uuml;ber ein vnode Ger&auml;t</h3>
d598 2
a599 2
Dies ist eine dauerhaftere L&ouml;sung, um mehr Swap-Speicher zu erhalten. Um in eine Datei zu swappen,
erzeuge zun&auml;chst einen Kernel mit vnd0c als swap. Wenn du wd0a als root Dateisystem hast, und wd0b als bisherigen swap, 
d622 1
a622 1
mit der man dieses Ger&auml;t beim booten als Swap benutzt.
d632 2
a633 2
An diesem Punkt muss dein Computer neu gebootet werden, so dass die &Auml;nderungen am Kernel Effekt haben. Nachdem das 
passiert ist, ist es an der Zeit, das Ger&auml;t als swap zu konfigurieren. Dazu wirst du <a
d643 2
a644 2
Als letzten Schritt, musst du den Swap auf diesem Ger&auml;t noch einschalten. Wir machen das genau wie in dem Beispiel oben mit
swapctl(8). Und zuletzt pr&uuml;fen wir wieder, ob es auch korrekt in unsere Tabelle eingetragen wurde. 
d666 2
a667 2
Notwendigkeit des synchronen Schreibens von Verzeichnis Eintr&auml;gen im FFS
Code &uuml;berfl&uuml;ssig machen w&uuml;rde. Ergo ein gro&szlig;er Performance-Gewinn
d671 2
a672 2
das wird aber in zuk&uuml;nftigen Versionen entfallen.<p>
Mehr Interna und Details &uuml;ber Soft Updates kann man in den Untersuchungen von
d679 1
a679 1
Um Softupdates aktivieren zu k&ouml;nnen, muss dein Kernel folgende Option haben:
d704 1
a704 1
Wenn du eine &auml;ltere OpenBSD Version als 2.9 verwendest, boote in den single-user mode:
d717 2
a718 2
Hinweis f&uuml;r Sparc User: Auf sun4 und sun4c Maschinen sollten soft updates nicht eingeschaltet werden.
Diese Archiktekturen unterst&uuml;tzen nur eine sehr begrenzte Menge an Kernel Speicher und k&ouml;nnen dieses Feature
d729 1
a729 1
mit deinem jetzigen MBR. Um das Problem zu l&ouml;sen, solltest du zuerst versuchen, den OpenBSD boot block erneut
d734 2
a735 2
Um es zun&auml;chst zum Laufen zu kriegen, musst du deine boot disk als bootstrap benutzen.
Danach tust du deine Install Disk rein, und bevor sie den Kernel und die ramdisk l&auml;dt, bekommst
d744 2
a745 2
Festplatte f&uuml;r OpenBSD reserviert hast, kannst du den Master Boot Record  mit fdisk(8) reinitialisieren.
(Falls du auf deiner Festplatte Partitionen f&uuml;r andere Betriebssystem hast, kannst du auf keinen Fall 
d758 1
a758 1
Wenn das nicht funktioniert hat, hast du immer noch ein paar Optionen. Deine Gl&uuml;cksstr&auml;hne ist
d761 1
a761 1
OpenBSD ftp-Mirror herunterladen. Die ben&ouml;tigte Datei ist 
d772 1
a772 1
Es gibt auch einige andere kommerzielle Bootloader oder auch lilo, die du f&uuml;r das 
d784 1
a784 1
<li>Boote von einer Linux Disk, installiere LILO &amp; und verkn&uuml;pfe es mit deinem OpenBSD 
d791 1
a791 1
Ausf&uuml;hrlichere Anweisungen gibt es in <a href="ftp://ftp.openbsd.org/pub/OpenBSD/2.8/i386/INSTALL.linux">INSTALL.linux</a>
d816 1
a816 1
Pr&uuml;fe auch die <a href="faq4.html#4.5">Sektion 4.5</a>
d824 1
a824 1
&Auml;ltere Versionen von MS-DOS k&ouml;nnen nur mit Festplattengeometrien von 1024 Zylindern
d828 2
a829 2
wirkliche Geometrie in etwas zu &uuml;bersetzen, mit dem MS-DOS umgehen kann.
Wie dem auch sei, nicht alle BIOS Chips "&uuml;bersetzen" die Geometrie in der selben Weise.
d831 1
a831 1
Controller), und das neue benutzt eine andere "&uuml;bersetzte" Geometrie, wirst du nicht
d833 5
a837 5
(Das liegt daran, dass der 'first stage boot loader' eine Liste der Bl&ouml;cke enth&auml;lt, die
/boot in der "&uuml;bersetzten" Geometrie enthalten.)
Falls du IDE Platten benutzt, und du &Auml;nderungen an deinen BIOS Einstellungen machst,
kannst du seine &Uuml;bersetzung ebenfalls (ungewollt) &auml;ndern. (die meisten IDE BIOSse bieten 3 verschiedene
&Uuml;bersetzungen.) Um deinen Bootblock zu reparieren, damit du normal booten kannst,
d843 1
a843 1
Unser Beispiel geht davon aus, dass deine boot disk sd0 ist (bei IDE w&auml;re es wd0, etc..) :
d851 2
a852 2
Wenn installboot sich dar&uuml;ber beschwert, dass es die BIOS Geometrie nicht lesen kann, kannst du 
am boot&gt; Prompt das &quot;machine diskinfo&quot; (oder k&uuml;rzer
d854 1
a854 1
F&uuml;ttere die &quot;heads&quot; und &quot;secs&quot; Werte in installboot's -h
d862 1
a862 1
Wenn eine neuere Version von bootblocks ben&ouml;tigt wird, wirst du diese selber kompilieren m&uuml;ssen. Und das geht so:
d874 1
a874 1
<h2>14.9 - Auf die Katastrophe vorbereiten: Backups machen und Wiederherstellen mit B&auml;ndern (tapes)</h2>
d877 1
a877 1
<h3>Einf&uuml;hrung:</h3>
d881 1
a881 1
f&uuml;r den Fall, dass eine deiner Festplatten versagt oder einen Crash hat.
d894 1
a894 1
du IDE benutzt,  sondern einzig deine Ger&auml;tenamen werden sich leicht unterscheiden.  Zum Beispiel w&auml;re sd0a in einem
d917 1
a917 1
Ein weiteres Beispiel einer etwas gr&ouml;sseren mount-Tabelle k&ouml;nnte so aussehen:
d934 1
a934 1
Um ein Backup deiner Maschine zu machen, musst du 'dump' mit jeder festgelegten Partition f&uuml;ttern. Hier ist ein
d945 1
a945 1
F&uuml;r die etwas fortgeschrittenere mount-Tabelle w&uuml;rde man etwas wie das hier benutzen:
d957 1
a957 1
Sieh dir einfach die dump-man-page f&uuml;r genauere Angaben &uuml;ber jedes Befehlsargument an.
d961 2
a962 2
<li><b>0</b> - F&uuml;hre einen Level 0 Dump durch, hole alles
<li><b>a</b> - Versuche automatisch die Bandl&auml;nge herauszufinden
d972 1
a972 1
Das mt Kommando wird am Ende benutzt, um das Band zur&uuml;ckzuspulen. Sieh dir die mt man page an, wenn du mehr Informationen
d978 1
a978 1
dmesg f&uuml;r ein Bandlaufwerk k&ouml;nnte so aussehen:
d987 4
a990 4
Wenn du auf st0 als nrst0 zugreifst, benutzt du das selbe physikalische Ger&auml;t, aber sagst dem Ger&auml;t, es solle nicht 
zur&uuml;ckspulen, nachdem der Job im raw mode beendet wurde. Um multiple Dateien auf ein einziges Band zu sichern, stelle sicher, dass du 
nicht zur&uuml;ckspulst, sprich das richtige Ger&auml;t benutzt, ansonsten wirst du mit der zweiten Sicherung die erste &uuml;berschreiben,
usw. Du findest in der dump man page eine ausf&uuml;hrlichere Beschreibung.
d994 1
a994 1
Wenn du ein kleines Skript namens "backup" schreiben w&uuml;rdest, k&ouml;nnte es z.B. so aussehen:
d1011 1
a1011 1
Wenn regelm&auml;ssige n&auml;chtliche Backups gefordert sind, k&ouml;nnte man <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&sektion=8&format=html">cron(8)</a> benutzen, um das Backup jede Nacht automatisch zu starten.
d1015 2
a1016 2
Es ist ausserdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie gro&szlig; jedes Dateisystem sein muss. Du kannst df -h benutzen,
um herauszufinden, wieviel Platz jede Partition momentan verbraucht. Das ist dann n&uuml;tzlich, wenn eine Platte versagt, und
d1022 1
a1022 1
ist es, im Single-User-Mode zu booten. Dateisysteme m&uuml;ssen nicht gemountet werden, um gesichert zu werden. Vergiss aber nicht root (/)
d1032 1
a1032 1
dass es auch die Daten enth&auml;lt, die darauf sein sollen.
d1049 1
a1049 1
Um den Inhalt der zweiten Partition zu sehen und die Ausgabe in eine Datei umzulenken, w&uuml;rde man z.B. solch ein Kommando 
d1058 1
a1058 1
Wenn du eine mount-Tabelle wie die oben aufgef&uuml;hrte hast, w&auml;re 2 /usr, wenn deine aber etwas gr&ouml;sser w&auml;re, k&ouml;nnte
d1067 1
a1067 1
Das Beispielszenario w&auml;re sinnvoll, wenn deine eigentliche Festplatte komplett ausgefallen w&auml;re. Falls du aber nur eine einzige 
d1073 2
a1074 2
install/boot floppy enth&auml;lt bereits das ben&ouml;tigte restore Werkzeug, genauso wie die ausf&uuml;hrbaren Dateien, um neue Partitionen
zu erstellen, und deine Festplatte bootbar zu machen. In den meisten F&auml;llen sind diese Floppy und dein Sicherungsband alles, was
d1085 1
a1085 1
Boote von der OpenBSD install/boot floppy. An der Men&uuml;auswahl w&auml;hle Shell. Nimm dein neuestes und schreibgesch&uuml;tztes
d1092 1
a1092 1
Benutze das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> Kommando, um eine prim&auml;re
d1106 1
a1106 1
Mit dem disklabel Kommando stellst du dann deine OpenBSD Partitionstabelle in der prim&auml;ren OpenBSD Partition wieder her, die du gerade 
d1120 1
a1120 1
Benutze das newfs Kommando, um ein neues sauberes Dateisystem auf jeder Partition zu erstellen, die du mit dem oben aufgef&uuml;hrten 
d1159 1
a1159 1
Zus&auml;tzlich zum Schreiben eines neuen MBR musst du boot blocks installieren, um davon booten zu k&ouml;nnen.
d1191 1
a1191 1
Das bsd -s f&uuml;hrt dazu, dass der Kernel im Single-User-Modus gestartet wird, der nur ein root (/) Dateisystem braucht.
d1196 3
a1198 3
Unter der Annahme, das du die obigen Schritte  richtig ausgf&uuml;hrt hast und nichts schief gegangen ist, solltest du von einem Prompt begr&uuml;sst
werden, der dich nach einem Pfad zu einer Shell fragt, oder du sollst Return dr&uuml;cken. Dr&uuml;cke return, um die sh zu benutzen.
Als n&auml;chstes willst du sicher root im r/w Modus (Schreib/Lese) remounten, und nicht mehr im Nur-Lese-Modus benutzen (ro)
d1222 1
a1222 1
Benutze "<b>restore rvsf</b>" anstatt eines einfachen rsf um die Namen von Objekten zu sehen, w&auml;hrend sie vom dump set
d1228 1
a1228 1
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme wiederhergestellt hast, f&uuml;hre einen reboot in den Multi-User-Modus durch.
d1241 2
a1242 2
zu moutnen, musst du ein <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&sektion=4">vnd(4)</a> Device/Ger&auml;t konfigurieren. 
Zum Beispiel, wenn du ein ISO Image unter <i>/tmp/ISO.image</i> hast, w&uuml;rdest du die folgenden Schritte machen, um es zu mounten:
d1259 1
a1259 1
Bedenke bitte, da&szlig; du den Typ <i>cd9660</i> angeben musst, wenn es eine CD ist. Das gilt aber auch f&uuml;r die 
d1292 2
a1293 2
PCI IDE DMA ist unzuverl&auml;ssig. Darum schaltet Microsoft es auch bei seinen
Betriebssystemen grunds&auml;tzlich ab.
d1297 3
a1299 3
OpenBSD ist aggressiv und versucht den h&ouml;chsten DMA Modus zu benutzen, den es kriegen kann.
Dies f&uuml;hrt in einigen Konfigurationen zu Datenkorruptionen aufgrund von defekten Motherboard Chipsets,
Treibern, die buggy sind und/oder L&auml;rm auf den Kabeln. Gl&uuml;cklicherweise sch&uuml;tzt Ultra-DMA
d1302 1
a1302 1
zu &uuml;bertragen.
d1311 1
a1311 1
zuverl&auml;ssigeren) DMA-Modus herunterschalten. Nach den Ultra-DMA Modi wird 
d1317 1
a1317 1
deiner Maschine f&uuml;hrt, schicke uns bitte einen 
d1323 1
a1323 1
<a href= "index.html">[Zur&uuml;ck zu Haupt-Index]</a>
d1336 1
a1336 1
$Translation: faq14.html,v 1.21 2003/01/17 14:02:59 jufi Exp $
@


1.18
log
@
sync with steelix translation CVS
@
text
@d7 1
a7 1
<meta name= "description"   content= "Die OpenBSD FAQ Seiten - FAQ 14">
d1336 1
a1336 1
$Translation: faq14.html,v 1.20 2003/01/15 22:42:16 jufi Exp $
@


1.17
log
@
links to report.html
@
text
@d7 2
a8 2
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
d1336 1
a1336 1
$Translation: faq14.html,v 1.19 2002/07/04 11:51:08 jufi Exp $
@


1.16
log
@
sync with badlands translation CVS
@
text
@d1318 1
a1318 1
<a href="../../report.html">bug report</a>.
d1336 1
a1336 1
$Translation: faq14.html,v 1.18 2002/05/20 13:21:05 jufi Exp $
@


1.15
log
@more Soft Updates informations
@
text
@d6 1
d1336 1
a1336 1
$Translation: faq14.html,v 1.17 2001/10/03 15:39:32 jufi Exp $
@


1.14
log
@
sync with translation CVS.
@
text
@d25 1
a25 1
<li><a href="#14.5">14.5 - Soft-updates</a></li>
d525 1
a525 1
Softupdates (was ja standardm&auml;ssig nicht aktiviert ist).
d658 1
a658 1
<h2>14.5 - Soft-updates</h2>
d663 1
a663 1
"soft updates" genannt wird. Es basiert auf einer Idee von Greg Ganger und Yale
d667 8
a674 1
beim Schreiben auf Festplatten.
d687 1
a687 1
Festplatte und Partition als mount-Option aktivieren.
d1333 1
a1333 1
Originally [OpenBSD: faq14.html,v 1.46 ]
d1335 1
a1335 1
$Translation: faq14.html,v 1.15 2001/09/19 17:41:59 jufi Exp $
d1337 1
a1337 1
<small>$OpenBSD: faq14.html,v 1.46 2001/09/19 11:45:54 espie Exp $</small>
@


1.13
log
@
copyrighted extended and updated.
@
text
@d199 1
a199 1
</ul></pre>
d568 1
a568 1
</ul></pre>
d592 1
a592 1
</ul></pre>
d729 1
a729 1
<UL><PRE>
d734 1
a734 1
</UL></PRE>
d806 1
a806 1
</ul></pre>
d901 1
a901 1
</ul></pre>
d918 1
a918 1
</ul></pre>
d934 1
a934 1
</ul></pre>
d946 1
a946 1
</ul></pre>
d975 1
a975 1
</ul></pre>
d1000 1
a1000 1
</ul></pre>
d1033 1
a1033 1
</ul></pre>
d1047 1
a1047 1
</ul></pre>
d1090 1
a1090 1
</ul></pre>
d1104 1
a1104 1
</ul></pre>
d1119 1
a1119 1
</ul></pre>
d1128 1
a1128 1
</ul></pre>
d1138 1
a1138 1
</ul></pre>
d1147 1
a1147 1
</ul></pre>
d1158 1
a1158 1
</ul></pre>
d1171 1
a1171 1
</ul></pre>
d1180 1
a1180 1
</ul></pre>
d1196 1
a1196 1
</ul></pre>
d1211 1
a1211 1
</ul></pre>
d1326 1
a1326 1
Originally [OpenBSD: faq14.html,v 1.45 ]
d1328 1
a1328 1
$Translation: faq14.html,v 1.14 2001/08/25 09:43:31 jufi Exp $
d1330 1
a1330 1
<small>$OpenBSD: faq14.html,v 1.45 2001/08/25 09:31:33 jufi Exp $</small>
@


1.12
log
@
sync with badlands translation CVS.
@
text
@d9 1
a9 1
<meta name= "copyright"     content= "This document copyright 1998,1999 by OpenBSD.">
d1326 1
a1326 1
Originally [OpenBSD: faq14.html,v 1.44 ]
d1328 1
a1328 1
$Translation: faq14.html,v 1.13 2001/08/14 19:17:46 jufi Exp $
d1330 1
a1330 1
<small>$OpenBSD: faq14.html,v 1.44 2001/08/08 21:06:32 jsyn Exp $</small>
@


1.11
log
@
typos, found by Oliver-Dominik Schober
@
text
@d21 1
a21 1
<li><a href="#14.1">14.1 - Benutzung von OpenBSD's Disklabel</a></li>
d38 1
a38 1
<h2>Benutzung von OpenBSD's Disklabel</h2>
d43 1
a43 1
<li><a href="#14.1.1">Was ist Disklabel(8)?</a>
d51 1
a51 1
<h3>Was ist Disklabel(8)?</h3>
d53 7
d76 3
a78 1
Windows NT oder DOS sehen.) Mit disklabel(8), benutzt du eine dieser
d85 1
a85 1
<h3>disklabel(8) w&auml;hrend der OpenBSD Installation</h3>
d91 3
a93 2
separaten 'mountpoints' enthalten. W&auml;hrend der Installation kannst du mittels disklabel (8) deine
Mountpoints setzen, aber das ist eigentlich nicht n&ouml;tig, da du deine &Auml;nderungen sp&auml;ter
d263 3
a265 1
Optionen f&uuml;r Disklabel. Mit Hilfe von 'M' kannst du dir sogar die gesamte disklabel(8) man page ansehen. Von
d492 1
a492 1
leeres Verzeichnis /usr/local. Dann reboote das System, und voila!! Die Dateien sind da!
d1326 1
a1326 1
Originally [OpenBSD: faq14.html,v 1.41 ]
d1328 1
a1328 1
$Translation: faq14.html,v 1.12 2001/07/27 20:10:15 jufi Exp $
d1330 1
a1330 1
<small>$OpenBSD: faq14.html,v 1.41 2001/06/09 16:39:05 pvalchev Exp $</small>
@


1.10
log
@
corrections
@
text
@d726 1
a726 1
<tt>installboot</tt> verwenden, anstattdessen musst du dir eine andere Option wie z.B. OS-BS ansehen,
d738 1
a738 1
Wenn das nicht funktioniert hat, hast du imemr noch ein paar Optionen. Deine Gl&uuml;cksstr&auml;hne ist
d1216 1
a1216 1
<h2>14.10 - Disk mages in OpenBSD mounten</h2>
d1239 1
a1239 1
Bedenke bitte, da&szlig; du den Typ <i>cd9660</i> angeben musst, wenn es eine CD ist. Das gilt aber auch f&uuml;r Das gilt aber auch f&uuml;r die 
d1316 1
a1316 1
$Translation: faq14.html,v 1.11 2001/06/10 15:18:20 jufi Exp $
@


1.9
log
@
Cleanup.
@
text
@d81 2
a82 2
W&auml;hrend der Installation benutzt du 'disklabel' um deine seperaten 'label' zu erzeugen, die deine
seperaten 'mountpoints' enthalten. W&auml;hrend der Installation kannst du mittels disklabel (8) deine
d92 1
a92 1
'label' seperat zu halten. F&uuml;r Desktop User reicht vermutlich ein einzelner Mountpoint '/'. 
d1314 1
a1314 1
Originally [OpenBSD: faq14.html,v 1.40 ]
d1316 1
a1316 1
$Translation: faq14.html,v 1.10 2001/05/25 22:56:36 jufi Exp $
d1318 1
a1318 1
<small>$OpenBSD: faq14.html,v 1.40 2001/05/06 23:51:45 ericj Exp $</small>
@


1.8
log
@
small cleanup.
@
text
@d747 2
a748 2
<a href= "http://www.prz.tu-berlin.de/~wolf/os-bs.html">
          http://www.prz.tu-berlin.de/~wolf/os-bs.html</a>
d1316 1
a1316 1
$Translation: faq14.html,v 1.9 2001/05/25 19:24:34 jufi Exp $
@


1.7
log
@
Sync with badlands translation CVS.
@
text
@d796 1
a796 1
Pr&uuml;fe auch die <a href= "faq4.html#4.5">Sektion 4.5</a>
d1316 1
a1316 1
$Translation: faq14.html,v 1.8 2001/05/07 19:01:20 jufi Exp $
@


1.6
log
@
Updated.
@
text
@d659 1
a659 3
Um Softupdates aktivieren zu k&ouml;nnen, muss dein Kernel folgende Option haben:<br>
<b>HINWEIS:</b> Diese Option ist seit OpenBSD Version 2.7 standardm&auml;ssig aktiviert. Trotzdem musst du sie
auf Basis der Platten-Partitionen noch aktivieren.
d667 10
a676 1
Beginnend mit 2.9 werden die soft updates durch eine "mount time" Option anstelle von <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&sektion=8">tunefs(8)</a> aktiviert. Wenn du jetzt eine Partition mit dem  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&sektion=8">mount(8)</a> Utility mountest, kannst du angeben, dass soft updates auf dieser Partition aktiviert sein sollen. Unten ein beispielhafter <i>/etc/fstab</i> Eintrag, der eine Partition <i>sd0a</i> hat , die wir mit soft updates gemountet haben wollen.
d697 7
a703 1
<a name="14.6"></a>
d1277 2
a1278 2
OpenBSD ist aggressiv und versucht den h&uoml;chsten DMA Modus zu benutzen, den es kriegen kann.
Dies wird in einigen Konfigurationen zu Datenkorruptionen aufgrund von defekten Motherboard Chipsets,
d1280 3
a1282 2
die Daten Transfers mit einem CRC, um Korruptionen zu entdecken. Falls ein solcher Ultra-DMA CRC geschieht, 
wir OpenBSD eine Fehlermedlung ausgeben, und erneut versuchen die Daten zu &uuml;bertragen.
d1291 1
a1291 1
zuverl&auml;ssigeren) DMA-Modus herunterschalten. Nach Ultra-DMA Modus wird 
d1314 1
a1314 1
Originally [OpenBSD: faq14.html,v 1.39 ]
d1316 1
a1316 1
$Translation: faq14.html,v 1.7 2001/05/06 14:48:25 jufi Exp $
d1318 1
a1318 1
<small>$OpenBSD: faq14.html,v 1.39 2001/05/06 14:39:37 jufi Exp $</small>
@


1.5
log
@
Updates and typos.
@
text
@d32 1
d669 9
a677 1
dann musst du in den single-user mode booten:
a680 1
<strong>
d682 1
a682 1
        boot> boot -s
d684 2
a685 2
        bsd# tunefs -s enable &lt;raw device&gt;
        bsd# reboot -n
a686 1
</strong>
d1252 35
d1300 1
a1300 1
Originally [OpenBSD: faq14.html,v 1.36 ]
d1302 1
a1302 1
$Translation: faq14.html,v 1.6 2001/03/27 18:02:14 jufi Exp $
d1304 1
a1304 1
<small>$OpenBSD: faq14.html,v 1.36 2001/03/26 17:14:09 todd Exp $</small>
@


1.4
log
@Sync with Badlands Translation CVS.
@
text
@d71 1
a71 1
weitere f&uuml;r andere Betriebssystem &uuml;ber!
d199 1
a199 1
<h3>Gebr&auml;chliche Benutzung von disklabel(8)</h3>
d1258 1
a1258 1
Originally [OpenBSD: faq14.html,v 1.35 ]
d1260 1
a1260 1
$Translation: faq14.html,v 1.5 2001/03/27 14:19:05 reinhard Exp $
d1262 1
a1262 1
<small>$OpenBSD: faq14.html,v 1.3 2001/03/07 21:31:05 jufi Exp $</small>
@


1.3
log
@
Updated.
@
text
@d20 1
a20 1
<ul><h3>Table of Contents</h3>
d54 1
a54 1
und den Festplattentreibern,die im Kernel enthalten sind, zu erzeugen. 'Labels' enthalten
d209 1
a209 1
# <strong>disklabel wd0</strong> &gt;----- Oder was du dir ach immer f&uuml;r eine Platte ansehen willst
d466 1
a466 1
die neue Platte unter /mnt und benutze cpio -pdum,um /usr/local in das /mnt Verzeichnis zu kopieren.
d619 1
a619 1
passiert ist, ist es an der Zeit, das Ger&auml;t als swap zu konfigurieren. Dazu wirst du 
d688 1
a688 1
BIOS eine andere Idee hat, was die Geometrie deiner Fespltatte angeht, und zwar eine die nicht kompatibel ist
d917 1
a917 1
Sieh dier einfach die dump-man-page f&uuml;r genauere Angaben &uuml;ber jedes Befehlsargument an.
d976 1
a976 1
um herauszufinden, wieviel Platz jede Partition momentan verbraucht. Das ist dann n&uuml;tzlich ,wenn eine Platte versagt, und
d1189 1
a1189 1
Wenn alles geklappt hat, sollte dein Sytem wieder genauso sein, wie zum Zeitpunkt deiner letzten Sicherung und wieder normal zu benutzen.
d1260 1
a1260 1
$Translation: faq14.html,v 1.4 2001/03/07 21:28:28 jufi Exp $
d1262 1
a1262 1
<small>$OpenBSD: faq14.html,v 1.35 2001/03/07 21:28:30 jufi Exp $</small>
@


1.2
log
@
Updated.
@
text
@d264 1
a264 1
Um sicher zu sein, pr&uuml;fe zuerst die fdisk Hauptseite. 
d1258 1
a1258 1
Originally [OpenBSD: faq14.html,v 1.34 ]
d1260 1
a1260 1
$Translation: faq14.html,v 1.3 2001/02/17 19:56:51 jufi Exp $
d1262 1
a1262 1
<small>$OpenBSD: faq14.html,v 1.34 2001/01/27 22:19:47 ericj Exp $</small>
@


1.1
log
@
Simply added.
@
text
@d31 1
d53 1
a53 1
Disklabel's werden erzeugt, um ein effizientes Interface zwischen deiner Festplatte
d116 2
a117 2
> <strong>d a</strong>
> <strong>a a</strong>
d126 1
a126 1
> <strong>a b</strong>
d131 1
a131 1
</ul></pre>
d151 1
a151 1
> <strong>a d</strong>
d160 1
a160 1
> <strong>a e</strong>
d169 1
a169 1
</ul></pre>
d186 2
a187 2
> <strong>w</strong>
> <strong>q</strong>
d209 1
a209 1
# <strong>disklabel wd0</strong> <----- Oder welche Festplatte du dir auch immer ansehen willst
d237 1
a237 1
</ul></pre>
d247 1
a247 1
</ul></pre>
a249 1
<p>
d260 1
a260 1
<a name="14.2">
d265 1
a265 1
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&format=html">fdisk(8)</a>
d321 1
a321 1
fdisk: 1> <strong>help</strong>
d335 1
a335 1
fdisk: 1> 
a338 1
</p>
d367 1
a367 1
<a name="14.3">
d373 1
a373 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&format=html">fdisk(8)</a> benutzen
d380 1
a380 1
<UL><PRE>
d382 1
a382 1
</ul></pre>
d401 1
a401 1
</PRE></ul>
d442 1
a442 1
bsd# <strong>newfs wd1a </strong></ul></pre>
d485 1
a485 1
<a name="14.4">
d520 1
a520 1
ericj@@oshibana> <strong>swapctl -l</strong>
d541 1
a541 1
ericj@@oshibana> <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
d545 1
a545 1
</ul></pre>
d553 2
a554 2
ericj@@oshibana> <strong>sudo chmod 600 /var/swap</strong>
ericj@@oshibana> <strong>sudo swapctl -a /var/swap</strong>
d562 1
a562 1
ericj@@oshibana> <strong>swapctl -l</strong>
d567 1
a567 1
</ul></pre>
d576 1
a576 1
ericj@@oshibana> <strong>cat /etc/fstab</strong>
d578 1
a578 1
/var/swap /var/swap sw 0 0
d592 1
a592 1
</ul></pre>
d600 1
a600 1
ericj@@oshibana> <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
d604 1
a604 1
</ul></pre>
d612 1
a612 1
ericj@@oshibana> <strong>cat /etc/fstab</strong>
d615 1
a615 1
</ul></pre>
d620 1
a620 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=1&format=html">vnconfig(1)</a> benutzen.
d624 1
a624 1
ericj@@oshibana> <strong>sudo vnconfig -c -v vnd0 /var/swap</strong>
d626 1
a626 1
</ul></pre>
d634 2
a635 2
ericj@@oshibana> <strong>sudo swapctl -a /dev/vnd0c</strong>
ericj@@oshibana> <strong>swapctl -l</strong>
d640 1
a640 1
</ul></pre>
d674 1
a674 1
        boot>boot -s
d683 1
a683 1
<a name="14.6">
d691 2
a692 2
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&format=html">fdisk(8)</a> and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&sektion=8&format=html">installboot(8)</a>.
d701 1
a701 1
boot> <b>boot hd0a:/bsd</b>
d713 2
a714 2
# <strong>cp /usr/mdec/boot /boot</li></strong>
# <strong>/usr/mdec/installboot -v /boot /usr/mdec/biosboot wd0</li></strong>
d744 3
a746 2
<li>Boote von einer linux disk und installiere LILO & verbinde es mit deinem OpenBSD
boot block.</li>
d751 1
a751 1
Ausf&uuml;hrlichere Anweisungen gibt es in <a href="INSTALL.linux">INSTALL.linux</a>
d757 1
a757 1
<a name="14.7">
d767 1
a767 1
<pre><ul>
d779 1
a779 1
<a name="14.8">
d812 1
a812 1
am boot> Prompt das &quot;machine diskinfo&quot; (oder k&uuml;rzer
d847 1
a847 1
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&sektion=html">dump(8)</a>/<a href=http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> aber ausreichend. 
d1052 1
a1052 1
Benutze das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&format=html">fdisk(8)</a> Kommando, um eine prim&auml;re
d1143 1
a1143 1
Entferne die Install/boot floppy aus dem Laufwerk und reboote dein System. Am OpenBSD boot> prompt benutze das folgende Kommando:
d1147 1
a1147 1
boot> <b>bsd -s</b>
d1194 52
d1258 1
a1258 1
Originally [OpenBSD: faq14.html,v 1.24 ]
d1260 1
a1260 1
$Translation: faq14.html,v 1.2 2001/02/17 15:06:17 jufi Exp $
d1262 1
a1262 1
<small>$OpenBSD: faq14.html,v 1.24 2000/09/14 19:28:19 ericj Exp $</small>
@

