head	1.13;
access;
symbols;
locks; strict;
comment	@# @;


1.13
date	2011.01.25.20.42.54;	author ajacoutot;	state dead;
branches;
next	1.12;

1.12
date	2009.05.26.21.30.39;	author ajacoutot;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.11.09.33.16;	author jufi;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.08.20.43.47;	author jufi;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.25.21.41.20;	author jufi;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.09.17.33.00;	author jufi;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.10.11.45.33;	author jufi;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.16.55.58;	author jufi;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.29.06.23.08;	author jufi;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.22.17.56.54;	author jufi;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.02.22.46.36;	author wvdputte;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.05.21.00.48;	author wvdputte;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.10.03.57.46;	author wvdputte;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Sync with Steelix CVS
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
       "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="es">
<meta name="resource-type" content="documento">
<meta name="description" content="cómo portar aplicaciones de audio a OpenBSD">
<meta name="keywords" content="openbsd,portes,audio">
<meta name="distribution" content="global">
<meta name="copyright" content="Este documento es copyright 1998-2002 de OpenBSD">

<title>C&oacute;mo portar aplicaciones de audio a OpenBSD</title>
<link rev="made" href="mailto:www@@openbsd.org">
</head>

<body text="#000000" bgcolor="#ffffff" link="#23238e">
<!-- máx. 72 caracteres por línea -->
<a href="index.html"><img alt="[OpenBSD]" height="30" width="141" src="../images/smalltitle.gif" border="0"></a>

<h1>C&oacute;mo portar aplicaciones de audio a OpenBSD</h1>

<p>
En la actualidad este documento s&oacute;lo trata sobre temas
relacionados con muestras de sonido, pero se aceptan contribuciones
sobre sintetizadores y tablas de ondas.

<p>
Las aplicaciones de audio suelen ser dif&iacute;ciles de portar ya que
&eacute;ste es un terreno en donde no existen normativas que regulen las
interfaces, aunque no existe mucha diferencia entre c&oacute;mo se
aborda el tema en diferentes sistemas operativos.

<p>
<h2><font color="#e00000">Utilizaci&oacute;n de
<code>ossaudio</code></font></h2>

<p>
La emulaci&oacute;n <code>ossaudio</code> es la posibilidad m&aacute;s
simple, pero no siempre funciona y generalmente no es una buena idea.

<ul>
   <li>Redefine <code>ioctl</code>.  Si el c&oacute;digo que va a ser
   portado usa <code>ioctl</code> para m&aacute;s de un audio,
   tendr&aacute; que <code>#undef ioctl</code> y usar la forma simple
   <code>_ossioctl</code>.
    
   <li>Algunas funciones de sonido de linux no son emuladas.

   <li>Las aplicaciones con el correcto soporte para sonido de linux que
   no sean espec&iacute;ficas de la arquitectura intel, tienden a usar
   estas funciones.
</ul>

<p>
<h2><font color="#e00000">Utilizaci&oacute;n de c&oacute;digo de NetBSD
o FreeBSD ya existente</font></h2>

<p>
Como compartimos parte de la interfaz de audio con NetBSD y FreeBSD,
comenzar con un porte de NetBSD es razonable.  Hay que tener cuidado por
que algunos ficheros cambian de sitio, y algunas entradas en
<code>sys/audioio.h</code> son obsoletas.  Adem&aacute;s, muchos portes
tienden a estar codificados de modo incorrecto y s&oacute;lo funcionan
en un tipo de m&aacute;quina.  Algunos cambios son necesarios.  Siga
leyendo.

<p>
<h2><font color="#e00000">C&oacute;mo escribir c&oacute;digo de
OpenBSD</font></h2>

<p>
<h3><font color="#0000e0">Independencia del <em>hardware</em></font></h3>

<p>
<strong>NO SE DEBE ASUMIR NADA SOBRE EL HARDWARE DE AUDIO QUE SE
UTILICE</strong><br>
C&oacute;digo incorrecto es el c&oacute;digo que s&oacute;lo verifica el
campo <code>a_info.play.precision</code> con 8 &oacute; 16 bits, y que
asume como buenas las muestras de audio firmadas o no, bas&aacute;ndose
en el comportamiento de soundblaster.  Siempre se debe verificar el tipo
de muestra de modo expl&iacute;cito, y codificar de acuerdo con
&eacute;sta.  Un ejemplo simple:

<pre>
AUDIO_INIT_INFO(&amp;a_info);
a_info.play.encoding = AUDIO_ENCODING_SLINEAR;
a_info.play.precision = 16;
a_info.play.sample_rate = 22050;
error = ioctl(audio, AUDIO_SETINFO, &amp;a_info);
if (error)
	/* deal with it */
error = ioctl(audio, AUDIO_GETINFO, &amp;a_info);
switch(a_info.play.encoding)
	{
case AUDIO_ENCODING_ULINEAR_LE:
case AUDIO_ENCODING_ULINEAR_BE:
	if (a_info.play.precision == 8)
	    /* ... */
	else 
	    /* ... */
	break;
case ...

default:
	/* don't forget to deal with what you don't know !!! For instance, */
	fprintf(stderr, 
		"Unsupported audio format (%d), ask ports@@ about that\n",
		a_info.play.encoding);

	}
/* now don't forget to check what sampling frequency you actually got */
</pre>

<p>
Esto viene a ser el fragmento de c&oacute;digo m&aacute;s peque&ntilde;o
con que se tendr&aacute; que tratar en la mayor&iacute;a de casos.

<p>
<h3><font color="#0000e0">Formatos de 16 bits y
&quot;endian&quot;</font></h3>

<p>
Para uso normal simplemente se pide el tipo de condificaci&oacute;n
(v.g., <code>AUDIO_ENCODING_SLINEAR</code>) y se saca una
codificaci&oacute;n con tipo de &quot;endian&quot; (v.g.,
<code>AUDIO_ENCODING_SLINEAR_LE</code>).

<p>
Teniendo en cuenta que una tarjeta de sonido no tiene que usar el mismo
tipo de &quot;endian&quot; que la plataforma, hay que estar preparado
para esto.  El modo m&aacute;s f&aacute;cil es, probablemente, preparar
una memoria intermedia de audio entera, y usar <code>swab(3)</code> si
se requiere un cambio del tipo de &quot;endian&quot;.  Al tratar con
muestras externas suele ser:

<ol>
   <li>analizar el formato de la muestra,
   <li>introducir la muestra,
   <li>cambiar el tipo de &quot;endian&quot; si no corresponde al de
   nuestro formato,
   <li>computar la salida deseada en la memoria intermedia,
   <li>cambiar el tipo de &quot;endian&quot; si la tarjeta de sonido no
   corresponde a nuestro formato,
   <li>y jugar con la memoria intermedia.
</ol>

<p>
Si se est&aacute; jugando con una muestra de sonido que se encuentra en
el formato de la tarjeta de sonido, se pueden eliminar los pasos 3 y 5.

<p>
<h3><font color="#0000e0">Calidad de audio</font></h3>

<p>
El <em>hardware</em> puede tener unas limitaciones extra&ntilde;as, como
que no pueda obtener más de 22050 Hz en est&eacute;reo y sin embargo
obtenga hasta 44100 en mono.  En casos como &eacute;ste y similares hay
que ofrecer un cambio al usuario para que escoja sus preferencias, e
intentar dar el mejor rendimiento posible.  Por ejemplo, ser&iacute;a
est&uacute;pido limitar la frecuencia a 22050 Hz ya que la salida es en
est&eacute;reo.  &iquest;Y si el usuario no tiene un sistema de sonido
en est&eacute;reo conectado a la salida de su tarjeta de audio?

<p>
Tambi&eacute;n ser&iacute;a est&uacute;pido codificar las limitaciones
de soundblaster en su programa.  Intente sobrepasar la barrera de
22050&nbsp;Hz/stereo y verifique los resultados.

<p>
<h4>Muestras de frecuencia</h4>

<p>
Las muestras de frecuencia devueltas por la tarjeta de sonido siempre
deben ser verificadas.  Una discrepancia del 5% es medio tono, y algunas
personas tienen un o&iacute;do m&aacute;s fino que eso, aunque la
mayor&iacute;a de nosotros no notemos nada.  Su aplicaci&oacute;n
deber&iacute;a ser capaz de llevar a cabo un &laquo;remuestreo&raquo; al
instante, posiblemente de forma nativa o a trav&eacute;s de aplicaciones
de &laquo;remuestreo&raquo; de Shannon.

<p>
<h4>Campo din&aacute;mico</h4>

<p>
Los muestreos no siempre usan el campo de valores entero.  Primero, las
muestras grabadas con un volumen bajo no sonar&aacute;n muy altas en la
m&aacute;quina, forzando al usuario a subir el volumen.  Segundo, en
m&aacute;quinas con audio mal aislado, la salida de sonido bajo
significa que la mayor parte de lo que se oye es el latido de la
m&aacute;quina y no el sonido esperado.  Finalmente, la
conversi&oacute;n muda de 16 bits a 8 bits le puede dejar con tan
s&oacute;lo 4 bits de audio utilizables, lo que da como resultado una
p&eacute;sima calidad.

<p>
Si es posible, la mejor soluci&oacute;n est&aacute; en escanear todo lo
que se vaya a escuchar con anterioridad, y ponerlo en escala de modo que
entre dentro del campo din&aacute;mico.  Si no se puede permitir esto
pero puede planear con anterioridad lo que vaya a escuchar, puede
ajustar la potencia del volumen;  s&oacute;lo debe asegurarse de que el
factor de potencia se mantiene en una frecuencia baja en
comparaci&oacute;n con la del sonido que quiera escuchar, y que no haya
ning&uacute;n <em>desbordamiento</em> (&eacute;stos siempre
sonar&aacute;n mucho peor que la mejora que intente conseguir).<br>
Ya que la percepci&oacute;n del volumen del sonido es
logar&iacute;tmica, generalmente bastar&aacute; con usar cambios
aritm&eacute;ticos.  Si sus datos est&aacute;n firmados, deber&iacute;a
codificar el cambio de forma expl&iacute;cita como una divisi&oacute;n,
ya que el operador de C <code>&gt;&gt;</code> no se puede portar a datos
firmados.

<p>
Si lo dem&aacute;s fallara, deber&iacute;a por lo menos intentar proveer
al usuario con una opci&oacute;n escalable de sonido.

<p>
<h3><font color="#0000e0">Rendimiento del audio</font></h3>

<p>
Las aplicaciones de poca demanda no deben preocupar mucho.  Tenga en
cuenta que algunos de nosotros usamos OpenBSD en 68030 de baja demanda,
y que si una aplicaci&oacute;n de sonido puede funcionar, deber&iacute;a
hacerlo.

<p>
No se olvide de llevar a cabo bancos de pruebas.  Las optimizaciones
teor&eacute;ticas son s&oacute;lo eso:  teor&iacute;a.  Deber&iacute;a
recolectar algunas cifras para poder comprobar qu&eacute; se puede
mejorar ampliamente y qu&eacute; no.

<p>
Para aplicaciones de audio de alto rendimiento, como mpegI-layer3, hay
que tener en consideraci&oacute;n algunos puntos:

<ul>
   <li>La interfaz de audio le proveer&aacute; con el tama&ntilde;o de
   bloque natural del <em>hardware</em>.  Tenga en cuenta que
   <code>write</code>, como una llamada del sistema, incurre en un coste
   alto comparado con el proceso interno de audio.

   <li>El ancho de banda es un factor muy importante a tener en cuenta
   cuando se trata sobre audio.  Una forma &uacute;til para optimizar un
   aparato de audio es verlo como un descompresor.  Cuanto m&aacute;s
   tiempo pueda mantener los datos comprimidos, mejor.  Los bucles muy
   cortos que aportan muy poco procesamiento son por lo general una mala
   idea.  Es mucho mejor combinar todo el procesamiento en un bucle.

   <li>Algunos formatos incurren en m&aacute;s suspensi&oacute;n que
   otros.  Se debe usar el <code>ioctl</code> <code>AUDIO_GETENC</code>
   para obtener todos los formatos con los que est&eacute; provisto el
   dispositivo de audio.  Tenga un cuidado especial con el indicador
   <code>AUDIO_ENCODINGFLAG_EMULATED</code>.  Si ya puede obtener
   salidas de todo tipo de formatos extra&ntilde;os de su
   aplicaci&oacute;n y se encuentra bastante optimizada para ello,
   intente usar un formato nativo a cualquier coste.  Por otra parte, el
   c&oacute;digo de emulaci&oacute;n presente en el dispositivo de audio
   se puede decir que est&aacute; suficientemente optimizado en ese
   caso, y no tiene porqu&eacute; substituirlo con c&oacute;digo nuevo
   programado con prisas.
</ul>

<p>
Un modelo que es posible que tenga que seguir para obtener resultados
&oacute;ptimos es el de compilar primero un peque&ntilde;o programa de
pruebas que investigue sobre el <em>hardware</em> de audio disponible, y
entonces pasar a configurar su programa de modo que trate de forma
&oacute;ptima con este <em>hardware</em>.  Se puede asumir que los
usuarios que esperan unos resultados de audio buenos recompilar&aacute;n
su porte cuando cambien de <em>hardware</em>.

<p>
<h3><font color="#0000e0">Tiempo real o sincronizado</font></h3>

<p>
Aun cuando OpenBSD no sea un sistema en tiempo real, es posible
programar aplicaciones de audio para tiempo real, como puedan ser
juegos.  En tal caso es necesario rebajar el tama&ntilde;o de los
bloques para que los efectos de sonido no se desincronicen con el juego.
El problema con esto es que el dispositivo de audio puede sufrir
&laquo;inanici&oacute;n&raquo;, lo que dar&iacute;a unos resultados
terribles.

<p>
Si solamente quiere sincronizar el audio con la salida de algunos
gr&aacute;ficos, pero se puede predecir el comportamiento de su
programa, es m&aacute;s f&aacute;cil alcanzar la sincronizaci&oacute;n.
Ejecute las muestras de audio y pregunte al dispositivo de audio
qu&eacute; es lo que est&aacute; ejecutando con
<code>AUDIO_GETOOFFS</code>, y entonces use esa informaci&oacute;n para
postsicronizar los gr&aacute;ficos.  Si se lo pide con bastante
frecuencia (digamos que cada d&eacute;cima de segundo), y siempre que
tenga suficiente potencia para ejecutar su aplicaci&oacute;n, puede
obtener una sincronizaci&oacute;n bastante buena de este modo.  Es
posible que tenga que trastocar un poco las cifras por una constante de
contrapeso, ya que existe desincronizaci&oacute;n entre los informes del
audio, lo que se est&aacute; ejecutando, y el tiempo que tarda XWindow
en mostrar algo.

<p>
<h2><font color="#e00000">Aportaci&oacute;n del
c&oacute;digo</font></h2>

<p>
En el caso de las aplicaciones de audio, trabajar con el autor del
programa original es muy importante.  Si su c&oacute;digo s&oacute;lo
funciona, por ejemplo, con tarjetas soundblaster, es muy posible que
tenga que tratar con otra tecnolog&iacute;a en breve.

<p>
<strong>Si no le env&iacute;a sus comentarios en ese momento, el trabajo
que Vd. haga habr&aacute; sido en vano</strong>.

<p>
Tambi&eacute;n es posible que el autor ya se haya dado cuenta de los
problemas con los que est&eacute; tratando y que est&eacute; trabajando
en ellos en su &aacute;rbol de desarrollo actual.  Si los parches que
Vd. est&aacute; escribiendo son de m&aacute;s de un par de
l&iacute;neas, es una buena idea que intente cooperar.


<hr>
<a href="porting.html"><img height="24" width="24" src="../back.gif" border="0" alt="Porting"></a> 
<a href="mailto:www@@openbsd.org">www@@openbsd.org</a>

<br><small>
Originally [OpenBSD: audio-port.html,v 1.8 2003/03/06 13:51:31 naddy Exp ]<br>
$Translation: audio-port.html,v 1.16 2009/05/26 22:53:51 ajacoutot Exp $<br>
$OpenBSD: audio-port.html,v 1.12 2009/05/26 21:30:39 ajacoutot Exp $
</small>

</body>
</html>
@


1.12
log
@Sync with Steelix CVS
@
text
@d329 1
a329 1
$OpenBSD$
@


1.11
log
@
sync with steelix translation CVS
@
text
@d328 1
a328 1
$Translation: audio-port.html,v 1.12 2003/03/09 21:32:48 horacio Exp $<br>
@


1.10
log
@
sync with steelix translation CVS, work by Horacio
@
text
@d1 2
d327 2
a328 2
Originally [OpenBSD: audio-port.html,v 1.7 2002/06/18 01:44:05 jsyn Exp ]<br>
$Translation: audio-port.html,v 1.11 2003/01/08 19:26:51 horacio Exp $<br>
@


1.9
log
@
sync with badlands translation CVS
@
text
@d16 1
a16 1

d22 3
a24 3
Actualmente este documento s&oacute;lo trata sobre temas de muestras de
sonido, pero se aceptar&aacute;n contribuciones sobre sintetizadores y
tablas de ondas.
d28 1
a28 1
&eacute;ste es un terreno en donde no existen normativas para las
d41 4
a44 4
   <li>Redefine <code>ioctl</code>.
       Si el c&oacute;digo que va a ser portado usa <code>ioctl</code>
       para m&aacute;s de un audio, tendr&aacute; que <code>#undef
       ioctl</code> y usar la forma simple <code>_ossioctl</code>.
d46 1
a46 1
    <li>Algunas funciones de sonido de linux no son emuladas.
d48 3
a50 3
    <li>Las aplicaciones con el correcto soporte para sonido de linux
	que no sean espec&iacute;ficas de la arquitectura intel,
	tienden a usar estas funciones.
d59 2
a60 2
comenzar con un porte de NetBSD es razonable.  Tenga cuidado ya que
algunos ficheros cambian de sitio, y algunas entradas en
d75 7
a81 8
USE</strong>
<br>
C&oacute;digo incorrecto es el c&oacute;digo que s&oacute;lo verifica
el campo <code>a_info.play.precision</code> con 8 &oacute; 16 bits, y
que asume como buenas las muestras de audio firmadas o no,
bas&aacute;ndose en el comportamiento de soundblaster.  Siempre se debe
verificar el tipo de muestra de modo expl&iacute;cito, y codificar de
acuerdo con &eacute;sta.  Un ejemplo simple:
d114 2
a115 3
Esto viene a ser el fragmento de c&oacute;digo m&aacute;s
peque&ntilde;o con que se tendr&aacute; que tratar en la mayor&iacute;a
de casos.
d128 6
a133 6
Considerando que una tarjeta de sonido no tiene que usar el mismo tipo
de &quot;endian&quot; que su plataforma, debe prepararse para ello.  El
modo m&aacute;s f&aacute;cil es, probablemente, preparar una memoria
intermedia de audio entera, y usar <code>swab(3)</code> si se requiere
un cambio del tipo de &quot;endian&quot;.  Al tratar con muestras
externas suele ser:
d139 1
a139 1
       nuestro formato,
d142 1
a142 1
       corresponde a nuestro formato,
d147 2
a148 2
Si est&aacute; jugando con una muestra de sonido que se encuentra en el
formato de su tarjeta de sonido, puede eliminar los pasos 3 y 5.
d154 8
a161 9
El <em>hardware</em> puede tener unas limitaciones extra&ntilde;as,
como que no pueda obtener más de 22050 Hz en est&eacute;reo y sin
embargo obtenga hasta 44100 en mono.  En casos como &eacute;ste y
similares debe ofrecer un cambio al usuario para que escoja sus
preferencias, e intentar dar el mejor rendimiento posible.  Por
ejemplo, ser&iacute;a est&uacute;pido limitar la frecuencia a 22050 Hz
ya que la salida es en est&eacute;reo.  &iquest;Y si el usuario no
tiene un sistema de sonido en est&eacute;reo conectado a la salida de
su tarjeta de audio?
d173 6
a178 6
deben ser verificadas.  Una discrepancia del 5% es medio tono, y
algunas personas tienen un o&iacute;do m&aacute;s fino que eso, aunque
la mayor&iacute;a de nosotros no notemos nada.  Su aplicaci&oacute;n
deber&iacute;a ser capaz de llevar a cabo un &laquo;remuestreo&raquo;
al instante, posiblemente de forma nativa o a trav&eacute;s de
aplicaciones de &laquo;remuestreo&raquo; de Shannon.
d196 3
a198 3
que se vaya a escuchar con anterioridad, y ponerlo en escala de modo
que entre dentro del campo din&aacute;mico.  Si no se puede permitir
esto pero puede planear con anterioridad lo que vaya a escuchar, puede
d203 1
a203 2
sonar&aacute;n mucho peor que la mejora que intente conseguir).
<br>
d208 2
a209 2
ya que el operador de C <code>&gt;&gt;</code> no se puede portar a
datos firmados.
d212 2
a213 2
Si lo dem&aacute;s fallara, deber&iacute;a por lo menos intentar
proveer al usuario con una opci&oacute;n escalable de sonido.
d221 2
a222 2
y que si una aplicaci&oacute;n de sonido puede funcionar,
deber&iacute;a hacerlo.
d236 3
a238 3
       bloque natural del <em>hardware</em>.  Tenga en cuenta que
       <code>write</code>, como una llamada del sistema, incurre en un
       coste alto comparado con el proceso interno de audio.
d241 5
a245 6
       cuando se trata sobre audio.  Una forma &uacute;til para
       optimizar un aparato de audio es verlo como un descompresor.
       Cuanto m&aacute;s tiempo pueda mantener los datos comprimidos,
       mejor.  Los bucles muy cortos que aportan muy poco procesamiento
       son por lo general una mala idea.  Es mucho mejor combinar todo
       el procesamiento en un bucle.
d248 11
a258 12
       otros.  Se debe usar el <code>ioctl</code>
       <code>AUDIO_GETENC</code> para obtener todos los formatos con
       los que est&eacute; provisto el dispositivo de audio.  Tenga un
       cuidado especial con el indicador
       <code>AUDIO_ENCODINGFLAG_EMULATED</code>.  Si ya puede obtener
       salidas de todo tipo de formatos extra&ntilde;os de su
       aplicaci&oacute;n y se encuentra bastante optimizada para ello,
       intente usar un formato nativo a cualquier coste.  Por otra
       parte, el c&oacute;digo de emulaci&oacute;n presente en el
       dispositivo de audio se puede decir que est&aacute;
       suficientemente optimizado en ese caso, y no tiene porqu&eacute;
       substituirlo con c&oacute;digo nuevo programado con prisas.
d264 2
a265 2
pruebas que investigue sobre el <em>hardware</em> de audio disponible,
y entonces pasar a configurar su programa de modo que trate de forma
d267 2
a268 2
usuarios que esperan unos resultados de audio buenos
recompilar&aacute;n su porte cuando cambien de <em>hardware</em>.
d277 4
a280 4
bloques para que los efectos de sonido no se desincronicen con el
juego.  El problema con esto es que el dispositivo de audio puede
sufrir &laquo;inanici&oacute;n&raquo;, lo que dar&iacute;a unos
resultados terribles.
d294 3
a296 3
contrapeso, ya que existe desincronizaci&oacute;n entre los informes
del audio, lo que se est&aacute; ejecutando, y el tiempo que tarda
XWindow en mostrar algo.
d309 2
a310 2
<strong>Si no le env&iacute;a sus comentarios en ese momento, el
trabajo que Vd. haga habr&aacute; sido en vano</strong>.
d326 1
a326 1
$Translation: audio-port.html,v 1.10 2002/06/25 21:25:11 horacio Exp $<br>
@


1.8
log
@
sync with badlands translation CVS
@
text
@d17 1
a17 1
<img height="30" width="141" src="../images/smalltitle.gif" alt="[OpenBSD]">
d331 2
a332 2
Originally [OpenBSD: audio-port.html,v 1.6 2002/01/29 22:08:36 horacio Exp ]<br>
$Translation: audio-port.html,v 1.9 2002/04/08 20:33:41 horacio Exp $<br>
@


1.7
log
@
sync with badlands translation CVS
@
text
@d4 1
d6 1
a6 1
<meta name="description" CONTENT="cómo portar aplicaciones de audio a OpenBSD">
d12 1
a12 1
<link rev="made" HREF="mailto:www@@openbsd.org">
d332 1
a332 1
$Translation: audio-port.html,v 1.8 2002/02/01 21:17:51 horacio Exp $<br>
@


1.6
log
@
sync with badlands translation CVS.
@
text
@d8 1
a8 1
<meta name="copyright" content="Este documento es copyright 1998-2001 de OpenBSD">
d330 2
a331 2
Originally [OpenBSD: audio-port.html,v 1.5 2001/09/10 19:26:32 jufi Exp ]<br>
$Translation: audio-port.html,v 1.7 2001/09/19 16:15:32 horacio Exp $<br>
@


1.5
log
@
sync with badlands translation CVS.
@
text
@d330 2
a331 2
Originally [OpenBSD: audio-port.html,v 1.4 2001/08/25 11:25:42 jufi Exp ]<br>
$Translation: audio-port.html,v 1.6 2001/08/28 17:55:03 horacio Exp $<br>
@


1.4
log
@
Sync with badlands translation CVS. Work by Horacio.
@
text
@d4 3
a6 3
<meta name="resource-type" content="document">
<meta name="description" CONTENT="How to make an OpenBSD port; audio">
<meta name="keywords" content="openbsd,ports,audio">
d8 3
a10 2
<meta name="copyright" content="This document copyright 1998 by the OpenBSD project">
<title>Portar Aplicaciones de Audio a OpenBSD</title>
d14 1
a14 1
<body text="#000000" bgcolor="#FFFFFF" link="#23238E">
d18 1
a18 1
<h1>Portar Aplicaciones de Audio a OpenBSD</h1>
d32 2
a33 1
<h2><font color="#e00000">Usar <code>ossaudio</code></font></h2>
d53 2
a54 2
<h2><font color="#e00000">Usar C&oacute;digo de NetBSD o FreeBSD ya
Existente</font></h2>
d66 2
a67 1
<h2><font color="#e00000">Escribir C&oacute;digo de OpenBSD</font></h2>
d70 1
a70 1
<h3><font color="#0000e0">Independencia del Hardware</font></h3>
d152 1
a152 1
<h3><font color="#0000e0">Calidad de Audio</font></h3>
d155 9
a163 8
El hardware puede tener unas limitaciones extra&ntilde;as, como que no
pueda obtener más de 22050 Hz en est&eacute;reo y sin embargo obtenga
hasta 44100 en mono.  En casos como &eacute;ste y similares debe
ofrecer un cambio al usuario para que escoja sus preferencias, e
intentar dar el mejor rendimiento posible.  Por ejemplo, ser&iacute;a
est&uacute;pido limitar la frecuencia a 22050 Hz ya que la salida es en
est&eacute;reo.  &iquest;Y si el usuario no tiene un sistema de sonido
en est&eacute;reo conectado a la salida de su tarjeta de audio?
d171 1
a171 1
<h4>Muestras de Frecuencia</h4>
d183 1
a183 1
<h4>Campo Din&aacute;mico</h4>
d219 1
a219 1
<h3><font color="#0000e0">Rendimiento del Audio</font></h3>
d239 1
a239 1
       bloque natural del hardware.  Tenga en cuenta que
d269 5
a273 5
pruebas que investigue sobre el hardware de audio disponible, y
entonces pasar a configurar su programa de modo que trate de forma
&oacute;ptima con este hardware.  Se puede asumir que los usuarios que
esperan unos resultados de audio buenos recompilar&aacute;n su porte
cuando cambien de hardware.
d276 1
a276 1
<h3><font color="#0000e0">Tiempo Real o Sincronizado</font></h3>
d304 2
a305 1
<h2><font color="#e00000">Aportar el C&oacute;digo</font></h2>
d330 2
a331 2
Originally [OpenBSD: audio-port.html,v 1.3 2000/11/17 19:11:33 jufi Exp ]<br>
$Translation: audio-port.html,v 1.5 2000/11/20 17:41:51 horacio Exp $<br>
@


1.3
log
@
Sync with Badlands Translation CVS. Work by Horacio.
@
text
@d15 1
a15 1
<img height="30" width="141" src="../images/smalltitle.gif" alt="[OpenBSD]" >
d325 2
a326 2
Originally [OpenBSD: audio-port.html,v 1.2 2000/03/25 02:29:49 wvdputte Exp ]<br>
$Translation: audio-port.html,v 1.4 2000/06/02 19:47:21 horacio Exp $<br>
@


1.2
log
@Sync Spanish translation up to date. A lot of work by Horacio
@
text
@d20 3
a22 2
Actualmente este documento sólo trata sobre temas de muestras de sonido, pero
se aceptarán contribuciones sobre sintetizadores y tablas de ondas.
d25 4
a28 4
Las aplicaciones de audio suelen ser difíciles de portar ya que éste es un
terreno en donde no existen normativas para las interfaces, aunque no existe
mucha diferencia entre cómo se aborda el tema en diferentes sistemas
operativos.
d34 2
a35 2
La emulación <code>ossaudio</code> es la posibilidad más simple, pero no
siempre funciona y generalmente no es una buena idea.
d39 3
a41 3
       Si el código que va a ser portado usa <code>ioctl</code> para más de
       un audio, tendrá que <code>#undef ioctl</code> y usar la forma simple
       <code>_ossioctl</code>.
d45 3
a47 3
    <li>Las aplicaciones con el correcto soporte para sonido de linux que no
        sean específicas de la arquitectura intel, tienden a usar estas
	funciones.
d51 2
a52 1
<h2><font color="#e00000">Usar Código de NetBSD o FreeBSD ya Existente</font></h2>
d55 7
a61 8
Como compartimos parte de la interfaz de audio con NetBSD y FreeBSD, comenzar
con un porte de NetBSD es razonable.
Tenga cuidado ya que algunos ficheros cambian de sitio, y algunas entradas en
<code>sys/audioio.h</code> son obsoletas.
Además, muchos portes tienden a estar codificados de modo incorrecto y sólo
funcionan en un tipo de máquina.
Algunos cambios son necesarios.
Siga leyendo.
d64 1
a64 1
<h2><font color="#e00000">Escribir Código de OpenBSD</font></h2>
d70 2
a71 1
<strong>NO SE DEBE ASUMIR NADA SOBRE EL HARDWARE DE AUDIO QUE SE USE</strong>
d73 6
a78 7
Código incorrecto es el código que sólo verifica el campo 
<code>a_info.play.precision</code> con 8 ó 16 bits, y que asume como buenas
las muestras de audio firmadas o no, basándose en el comportamiento de
soundblaster.
Siempre se debe verificar el tipo de muestra de modo explícito, y codificar
de acuerdo con ésta.
Un ejemplo simple:
d111 3
a113 2
Esto viene a ser el fragmento de código más pequeño con que se tendrá que
tratar en la mayoría de casos.
d116 2
a117 1
<h3><font color="#0000e0">Formatos de 16 bits y &quot;endian&quot;</font></h3>
d120 4
a123 3
Para uso normal simplemente se pide el tipo de condificación (v.g.,
<code>AUDIO_ENCODING_SLINEAR</code>) y se saca una codificación con tipo de
&quot;endian&quot; (v.g., <code>AUDIO_ENCODING_SLINEAR_LE</code>).
d126 6
a131 6
Considerando que una tarjeta de sonido no tiene que usar el mismo tipo de
&quot;endian&quot; que su plataforma, debe prepararse para ello.
El modo más fácil es, probablemente, preparar una memoria intermedia de audio
entera, y usar <code>swab(3)</code> si se requiere un cambio del tipo de
&quot;endian&quot;.
Al tratar con muestras externas suele ser:
d136 2
a137 2
   <li>cambiar el tipo de &quot;endian&quot; si no corresponde al de nuestro
       formato,
d139 1
a139 1
   <li>cambiar el tipo de &quot;endian&quot; se la tarjeta de sonido no
d145 2
a146 2
Si está jugando con una muestra de sonido que se encuentra en el formato de
su tarjeta de sonido, puede eliminar los pasos 3 y 5.
d152 8
a159 8
El hardware puede tener unas limitaciones extrañas, como que no pueda obtener
más de 22050 Hz en estéreo y sin embargo obtenga hasta 44100 en mono.
En casos como éste y similares debe ofrecer un cambio al usuario para que
escoja sus preferencias, e intentar dar el mejor rendimiento posible.
Por ejemplo, sería estúpido limitar la frecuencia a 22050 Hz ya que la salida 
es en estéreo.
¿Y si el usuario no tienen un sistema de sonido en estéreo conectado a la
salida de su tarjeta de audio?
d162 3
a164 4
También sería estúpido codificar las limitaciones de soundblaster en su
programa.
Intente sobrepasar la barrera de 22050&nbsp;Hz/stereo y verifique los
resultados.
d170 32
a201 32
Las muestras de frecuencia devueltas por la tarjeta de sonido siempre deben
ser verificadas.
Una discrepancia del 5% es medio tono, y algunas personas tienen un oído más
fino que eso, aunque la mayoría de nosotros no notemos nada.
Su aplicación debería ser capaz de llevar a cabo un &laquo;remuestreo&raquo; 
al instante, posiblemente de forma nativa o a través de aplicaciones de
&laquo;remuestreo&raquo; de Shannon.

<p>
<h4>Campo Dinámico</h4>

<p>
Los muestreos no siempre usan el campo de valores entero.
Primero, las muestras grabadas con un volumen bajo no sonarán muy altas en la
máquina, forzando al usuario a subir el volumen.
Segundo, en máquinas con audio mal aislado, la salida de sonido bajo
significa que la mayor parte de lo que se oye es el latido de la máquina y no
el sonido esperado.
Finalmente, la conversión muda de 16 bits a 8 bits le puede dejar con tan
sólo 4 bits de audio utilizables, lo que da como resultado una pésima
calidad.

<p>
Si es posible, la mejor solución está en escanear todo lo que se vaya a
escuchar con anterioridad, y ponerlo en escala de modo que entre dentro del
campo dinámico.
Si no se puede permitir esto pero puede planear con anterioridad lo que vaya
a escuchar, puede ajustar la potencia del volumen;  sólo debe asegurarse de
que el factor de potencia se mantiene en una frecuencia baja en comparación
con la del sonido que quiera escuchar, y que no haya ningún
<em>desbordamiento</em> (éstos siempre sonarán mucho peor que la mejora que
intente conseguir).
d203 6
a208 5
Ya que la percepción del volumen del sonido es logarítmica, generalmente
bastará con usar cambios aritméticos.
Si sus datos están firmados, debería codificar el cambio de forma explícita
como una división, ya que el operador de C <code>&gt;&gt;</code> no se puede
portar a datos firmados.
d211 2
a212 2
Si lo demás falla, debería por lo menos intentar proveer al usuario con una
opción escalable de sonido.
d218 4
a221 3
Las aplicaciones de poca demanda no deben preocupar mucho.
Tenga en cuenta que algunos de nosotros usamos OpenBSD en 68030 de baja
demanda, y que si una aplicación de sonido puede funcionar, debería hacerlo.
d224 4
a227 4
No se olvide de llevar a cabo bancos de pruebas.
Las optimizaciones teoréticas son sólo eso:  teoría.
Debería recolectar algunas cifras para poder comprobar qué se puede mejorar
ampliamente y qué no.
d230 2
a231 2
Para aplicaciones de audio de alto rendimiento, como mpegI-layer3, hay que
tener en consideración algunos puntos:
d234 26
a259 26
   <li>La interfaz de audio le proveerá con el tamaño de bloque natural del
       hardware.
       Tenga en cuenta que <code>write</code>, como una llamada del sistema,
       incurre en un coste alto comparado con el proceso interno de audio.

   <li>El ancho de banda es un factor muy importante a tener en cuenta cuando
       se trata sobre audio.
       Una forma útil para optimizar un aparato de audio es verlo como un
       descompresor.
       Cuanto más tiempo pueda mantener los datos comprimidos, mejor.
       Los bucles muy cortos que aportan muy poco procesamiento son por lo
       general una mala idea.
       Es mucho mejor combinar todo el procesamiento en un bucle.

   <li>Algunos formatos incurren en más suspensión que otros.
       Se debe usar el <code>ioctl</code> <code>AUDIO_GETENC</code> para
       obtener todos los formatos con los que esté provisto el dispositivo de
       audio.
       Tenga un cuidado especial con el indicador
       <code>AUDIO_ENCODINGFLAG_EMULATED</code>.
       Si ya puede obtener salidas de todo tipo de formatos extraños de su
       aplicación y se encuentra bastante optimizada para ello, intente usar
       un formato nativo a cualquier coste.
       Por otra parte, el código de emulación presente en el dispositivo de
       audio se puede decir que está suficientemente optimizado en ese caso,
       y no tiene porqué substituirlo con código nuevo programado con prisas.
d263 7
a269 6
Un modelo que es posible que tenga que seguir para obtener resultados óptimos
es el de compilar primero un pequeño programa de pruebas que investigue sobre
el hardware de audio disponible, y entonces pasar a configurar su programa de
modo que trate de forma óptima con este hardware.
Se puede asumir que los usuarios que esperan unos resultados de audio buenos
recompilarán su porte cuando cambien de hardware.
d275 43
a317 40
Aun cuando OpenBSD no sea un sistema en tiempo real, es posible programar
aplicaciones de audio para tiempo real, como pueden ser los juegos.
En tal caso es necesario rebajar el tamaño de los bloques para que los
efectos de sonido no se desincronicen con el juego.
El problema con esto es que el dispositivo de audio puede sufrir
&laquo;inanición&raquo;, lo que daría unos resultados terribles.

<p>
Si solamente quiere sincronizar el audio con la salida de algunos gráficos,
pero se puede predecir el comportamiento de su programa, es más fácil
alcanzar la sincronización.
Ejecute las muestras de audio y pregunte al dispositivo de audio qué es lo
que está ejecutando con <code>AUDIO_GETOOFFS</code>, y entonces use esa
información para postsicronizar los gráficos.
Si se lo pide con bastante frecuencia (digamos que cada décima de segundo), y
siempre que tenga suficiente potencia para ejecutar su aplicación, puede
obtener una sincronización bastante buena de este modo.
Es posible que tenga que trastocar un poco las cifras por una constante de
contrapeso, ya que existe retardo entre los informes del audio, lo que se
está ejecutando, y el tiempo que tarda XWindow en mostrar algo.

<p>
<h2><font color="#e00000">Aportar el Código</font></h2>

<p>
En el caso de las aplicaciones de audio, trabajar con el autor del programa
original es muy importante.
Si su código sólo funciona, por ejemplo, con tarjetas soundblaster, es muy
posible que tenga que tratar con otra tecnología en breve.

<p>
<strong>Si no le envía sus comentarios en ese momento, el trabajo que Vd.
haga habrá sido en vano</strong>.

<p>
También es posible que el autor ya se haya dado cuenta de los problemas con
los que esté tratando y que esté trabajando en ellos en su árbol de
desarrollo actual.
Si los parches que Vd. está escribiendo son de más de un par de líneas, es
una buena idea que intente cooperar.
d326 1
a326 1
$Translation: audio-port.html,v 1.3 2000/04/03 20:42:18 horacio Exp $<br>
@


1.1
log
@Spanish translation of OpenBSD.org webpages, a *lot* of work by:

Horacio MG <homega@@ciberia.es>
@
text
@d316 2
a317 2
Originally [OpenBSD: audio-port.html,v 1.1 1998/12/07 23:06:48 espie Exp ]
<br>
@

