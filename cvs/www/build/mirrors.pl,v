head	1.42;
access;
symbols;
locks; strict;
comment	@# @;


1.42
date	2017.03.05.13.12.44;	author sthen;	state Exp;
branches;
next	1.41;
commitid	jS2W3Da61p0VsT6z;

1.41
date	2017.02.24.00.34.22;	author sthen;	state Exp;
branches;
next	1.40;
commitid	ls9THa4FcPPBl1IQ;

1.40
date	2017.02.23.12.47.13;	author sthen;	state Exp;
branches;
next	1.39;
commitid	SLox1WjMIhaU0280;

1.39
date	2016.12.31.20.35.13;	author sthen;	state Exp;
branches;
next	1.38;
commitid	ZvG5EfCuZMSWJWLG;

1.38
date	2016.12.21.21.13.42;	author sthen;	state Exp;
branches;
next	1.37;
commitid	Q4YTYc2GTaGTqtW7;

1.37
date	2016.04.21.23.03.40;	author sthen;	state Exp;
branches;
next	1.36;
commitid	ob6Epg6PwD4Fs4fu;

1.36
date	2016.04.20.08.11.29;	author sthen;	state Exp;
branches;
next	1.35;
commitid	DcZZhnOgddgnhZQ5;

1.35
date	2016.01.21.20.07.59;	author sthen;	state Exp;
branches;
next	1.34;
commitid	1mBT1q3F1cIM3hXm;

1.34
date	2015.10.16.13.45.39;	author sthen;	state Exp;
branches;
next	1.33;
commitid	4qjfIFfQ2YNWmftB;

1.33
date	2014.12.23.15.44.23;	author naddy;	state Exp;
branches;
next	1.32;
commitid	irWRZoFvunCwwCax;

1.32
date	2014.03.02.19.37.02;	author sthen;	state Exp;
branches;
next	1.31;

1.31
date	2014.02.27.20.31.30;	author sthen;	state Exp;
branches;
next	1.30;

1.30
date	2014.01.14.10.11.32;	author sthen;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.14.09.53.45;	author sthen;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.14.09.44.26;	author sthen;	state Exp;
branches;
next	1.27;

1.27
date	2012.04.20.14.57.19;	author sthen;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.27.07.34.26;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.14.23.45.56;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.28.20.44.24;	author sthen;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.24.20.40.02;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.08.03.32.11;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.08.01.15.21;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.08.00.11.07;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.19.20.11.44;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.19.20.04.25;	author sthen;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.22.22.17.27;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.22.22.00.35;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.18.21.18.26;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.18.21.17.35;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.07.15.48.43;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.13.19.52.03;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.03.22.36.08;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.24.18.08.41;	author grunk;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.17.06.08.46;	author steven;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.23.07.39.34;	author steven;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.06.06.02.59;	author steven;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.26.06.49.33;	author steven;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.02.19.11.50;	author steven;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.31.21.53.37;	author steven;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.28.14.14.53;	author steven;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.28.14.01.29;	author steven;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.27.17.42.19;	author grunk;	state Exp;
branches;
next	;


desc
@@


1.42
log
@since /etc/examples/pkg.conf was removed, get rid of the code that generates it
@
text
@#!/usr/bin/perl
# Placed in the public domain by
# Alexander von Gernler <grunk@@openbsd.org> in 2005
#
# processes mirror data for www tree, ftplist and online mirror testing

use strict;
use warnings 'all';
use IO::Handle;		# for $fh->getlines()
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.41 2017/02/24 00:34:22 sthen Exp $';

my %format;
$format{'alias'}	= 'Host also known as <strong>%s</strong>.';
$format{'location'}	= 'Location: %s.';
$format{'maintainer'}	= 'Maintained by <a href="mailto:%s">%s</a>.';
$format{'proto'}	= 'Protocols: %s.';
$format{'updated'}	= 'Updated every %s hours.';
$format{'updated_from'}	= 'Updated every %s hours from %s.';
$format{'fingerprints'}	= 'SSH fingerprints:';
$format{'cvsroot'}	= '<strong>CVSROOT=%s@@%s:%s</strong>';

# note: some files are being reused because they would be identical
my $sources = {
	'mirrors.dat'	=> 'mirrors.dat',

	'openbsd-ftp-head'	=> 'mirrors/ftp.html.head',
	'openbsd-ftp-mid0'	=> 'mirrors/ftp.html.mid0',
	'openbsd-ftp-mid1'	=> 'mirrors/ftp.html.mid1',
	'openbsd-ftp-mid2'	=> 'mirrors/ftp.html.mid2',
	'openbsd-ftp-end'	=> 'mirrors/ftp.html.end',

	'openbgpd-ftp-head'	=> 'mirrors/openbgpd-ftp.html.head',
	'openbgpd-ftp-mid0'	=> 'mirrors/ftp.html.mid0',
	'openbgpd-ftp-mid1'	=> 'mirrors/ftp.html.mid1',
	'openbgpd-ftp-mid2'	=> 'mirrors/ftp.html.mid2',
	'openbgpd-ftp-end'	=> 'mirrors/openbgpd-ftp.html.end',

	'openntpd-portable-head'=> 'mirrors/openntpd-portable.html.head',
	'openntpd-portable-mid0'=> 'mirrors/ftp.html.mid0',
	'openntpd-portable-mid1'=> 'mirrors/ftp.html.mid1',
	'openntpd-portable-mid2'=> 'mirrors/ftp.html.mid2',
	'openntpd-portable-end'	=> 'mirrors/openntpd-portable.html.end',

	'openssh-ftp-head'	=> 'mirrors/openssh-ftp.html.head',
	'openssh-ftp-mid0'	=> 'mirrors/ftp.html.mid0',
	'openssh-ftp-mid1'	=> 'mirrors/ftp.html.mid1',
	'openssh-ftp-mid2'	=> 'mirrors/ftp.html.mid2',
	'openssh-ftp-end'	=> 'mirrors/openssh-ftp.html.end',
	'openssh-portable-head' => 'mirrors/openssh-portable.html.head',
	'openssh-portable-mid0' => 'mirrors/ftp.html.mid0',
	'openssh-portable-mid1' => 'mirrors/openssh-portable.html.mid1',
	'openssh-portable-mid2' => 'mirrors/ftp.html.mid2',
	'openssh-portable-end'	=> 'mirrors/openssh-ftp.html.end',

	'anoncvs-head'		=> 'mirrors/anoncvs.html.head',
	'anoncvs-end'		=> 'mirrors/anoncvs.html.end',
	'cvsync-head'		=> 'mirrors/cvsync.html.head',
	'cvsync-end'		=> 'mirrors/cvsync.html.end',
};
my $srcdir = $ENV{BSDSRCDIR};
$srcdir //= '/usr/src';
my $targets = {
	'ftplist'		=> '../ftplist',
	'httpslist'		=> '../httpslist',
	'mirror_list'		=> '../mirror_list',
	'openbsd-ftp'		=> '../ftp.html',
	'openbgpd-ftp'		=> '../openbgpd/ftp.html',
	'openntpd-portable'	=> '../openntpd/portable.html',
	'openssh-ftp'		=> '../openssh/ftp.html',
	'openssh-portable'	=> '../openssh/portable.html',
	'anoncvs'		=> '../anoncvs.html',
	'cvsync'		=> '../cvsync.html'
};

# read in mirror list from given file into an array of hash references.
# each hash represents one mirror and contains key/value pairs for given mirror
sub read_mirrors ($) {
	my $filename = shift;

	open(my $fh, '<', $filename) or die "open $filename: $!";
	my @@mirrors;
	my $record = {};
	my $lineno = 0;
	while (my $line = <$fh>) {
		$lineno++;
		next if $line =~ /^#/;		# skip comments
		next if $line =~ /^\s*$/;	# skip empty lines
		if ($line =~ /^0$/) {		# delimiter -- start new record
			# XXX more validity checks on contents of mirror record
			# before pushing, else die
			push(@@mirrors, $record) if (int(keys(%$record)));
			$record = {};		# new empty one
		} elsif ($line =~ /^(S[DER2])\s+(.*)/) {
			if ($record->{$1}) {
				$record->{$1} .= ", <tt>".$2."</tt>";	# append key/value pair
			} else {
				$record->{$1} = "<tt>".$2."</tt>";	# add key/value pair
			}
		} elsif ($line =~ /^([A-Z0-9]{2,3})\s+(.*)/) {
			($record->{$1})
				and die "dupe $1 in $filename:$lineno";
			$record->{$1} = $2;	# add key/value pair
		} else {
			die "parse error $filename:$lineno: $line";
		}
	}
	close($fh) or die "close $filename: $!";

	# don't forget the last record
	push(@@mirrors, $record) if (int(keys(%$record)));
	return @@mirrors;
}


# writes out the ftplist file to a given filename using the mirrors
# array referenced by the second argument
sub write_ftplist($$$$) {
	my ($filename, $ver, $mirrorref, $type) = @@_;

	# ftplist is displayed in the installer (with the protocol stripped
	# off) with cat -n, so 71 char max after removing the protocol.
	my $MAXWIDTH = 71 + length("ftp://");

	open(my $fh, '>', $filename) or die "open $filename: $!";

	foreach my $mirror (sort _by_country @@$mirrorref) {
		next unless ($mirror->{$type});
		my $loc = '';
		$loc .= "$mirror->{'GT'}, " if $mirror->{'GT'};
		$loc .= "$mirror->{'GS'}, " if $mirror->{'GS'};
		$loc .= "$mirror->{'GC'}" if $mirror->{'GC'};
		$loc =~ s/&auml;/a/g ;
		$loc =~ s/&ouml;/o/g ;
		$loc =~ s/&uuml;/u/g ;
		$loc =~ s/&eacute;/e/g ;
		$loc =~ s/&ntilde;/n/g ;
		(my $url = $mirror->{$type}) =~ s,/$,,;
		my $pad = $MAXWIDTH - length($url) - 1;
		# + 4 for aesthetics; force some whitespace
		if (length($url) + length($loc) + 4 > $MAXWIDTH) {
			die "Entry for $url too long";
		}
		printf $fh "%s %" . $pad . "s\n", $url, $loc;
	}

	close($fh) or die "close $filename: $!";
}


# writes out the ftplist in mirmon format
sub write_mirror_list($$) {
	my ($filename, $mirrorref) = @@_;

	open(my $fh, '>', $filename) or die "open $filename: $!";

	for my $type ('UH', 'UHS', 'UF', 'UR') {
		foreach my $mirror (sort _by_country @@$mirrorref) {
			next unless ($mirror->{$type});
			(my $url = $mirror->{$type}) =~ s,/$,,;
			my $loc = '';
			if (defined $mirror->{'GZ'}) {
				if ((defined $mirror->{'LF'})
				    && ($mirror->{'LF'} == 2)) {
					$loc .= 'L2';
				} else {
					$loc .= "$mirror->{'GZ'}";
				}
			} else {
				warn('no GZ for '.$mirror->{$type});
			}
			if (($type eq 'UH'  && not $url =~ m,^http://,) ||
			    ($type eq 'UHS' && not $url =~ m,^https://,) ||
			    ($type eq 'UF'  && not $url =~ m,^ftp://,) ||
			    ($type eq 'UR'  && not $url =~ m,^rsync://,)) {
				warn('bad URL format for '.$type.': '.$url);
			}
			printf $fh "%s %s\n", $loc, $mirror->{$type};
		}
	}

	close($fh) or die "close $filename: $!";
}


# helper function for just slurping template files into an open
# filedescriptor
sub _paste_in($$) {
	my ($fh, $filename) = @@_;

	open(my $rfh, '<', $filename) or die "open $filename: $!";
	print $fh $rfh->getlines();
	close($rfh) or die "close $filename: $!";
}


# writes out the FTP/HTTP mirrorlist to a given filehandle
sub _paste_mirrorlist($$$$$$) {
	my ($fh, $mirrorref, $type, $proj, $version, $links) = @@_;

	# indent for first <td> to come
	print $fh ' ' x 4 if ($type eq 'UH' || $type eq 'UF' || $type eq 'UR');
	foreach my $mirror (sort _by_country @@$mirrorref) {
		next unless ($mirror->{$type});

		# if this mirror already has https, don't bother listing http
		next if ($type eq 'UH' && defined $mirror->{'UHS'});

		my $loc = _get_location ($type, $mirror);
		if ($type =~ m/^(UH|UHS|UF|UR)$/) {
			my $url = $mirror->{$type};
			if ($proj eq 'openbgpd-ftp') {
				$url .= "OpenBGPD/openbgpd-${version}.tgz";
			}
			elsif ($proj eq 'openssh-ftp') {
				#next if ($type eq 'UR');
				$url .= "OpenSSH/openssh-${version}.tar.gz";
			}
			elsif ($proj eq 'openssh-portable') {
				#next if ($type eq 'UR');
				$url .= "OpenSSH/portable/";
			}
			elsif ($proj eq 'openntpd-portable') {
				$url .= "OpenNTPD/openntpd-${version}.tar.gz";
			}
			print $fh "<tr>\n\t<td>\n\t<strong>$loc</strong>\n";
			print $fh "\t</td><td>\n";
			($links) && print $fh "	<a href=\"$url\" rel=\"nofollow\">\n";
			print $fh "\t$url";
			($links) && print $fh "</a>";
			print $fh "\n\t</td>\n    </tr>";
		}
		elsif ($type eq 'AH') {
			if ($mirror->{'AH'} && $mirror->{'AU'} && $mirror->{'AR'}) {
				printf $fh "<li>".$format{'cvsroot'}."<br>\n",
					$mirror->{'AU'}, $mirror->{'AH'},
					$mirror->{'AR'};
			} else {
				die "Unable to determine CVSROOT for $mirror->{AH}.\nCheck for missing fields.\n";
			}
			if ($mirror->{'HA'}) {
				printf $fh $format{'alias'}."<br>\n",
				join(", ", split(/\s+/, $mirror->{'HA'}));
			}
			printf $fh $format{'location'}."<br>\n", $loc;
			printf $fh $format{'maintainer'}."<br>\n",
					$mirror->{'ME'}, $mirror->{'MN'}
				if ($mirror->{'ME'} && $mirror->{'MN'});
			printf $fh $format{'proto'}."<br>\n", $mirror->{'AP'}
				if ($mirror->{'AP'});
			if ($mirror->{'CE'}) {
				my $f;
				if ($mirror->{'CF'}) {
					$f = sprintf $format{'updated_from'},
					$mirror->{'CE'}, $mirror->{'CF'};
				} else {
					$f = sprintf $format{'updated'},
					$mirror->{'CE'};
				}
				$f =~ s/every 1 hours/hourly/;
				print $fh $f."<br>\n";
			}
			printf $fh $format{'fingerprints'}."<br>\n"
				if ($mirror->{'SD'} || $mirror->{'SR'} ||
					$mirror->{'SE'} || $mirror->{'S2'});
			print $fh "(RSA) $mirror->{'SR'}<br>\n"
				if ($mirror->{'SR'});
			print $fh "(DSA) $mirror->{'SD'}<br>\n"
				if ($mirror->{'SD'});
			print $fh "(ECDSA) $mirror->{'SE'}<br>\n"
				if ($mirror->{'SE'});
			print $fh "(ED25519) $mirror->{'S2'}<br>\n"
				if ($mirror->{'S2'});
			print $fh "<p>\n";
		}
		elsif ($type eq 'VH') {
			if ($mirror->{'VH'}) {
				print $fh "<li>";
				if ($mirror->{'VU'}) {
					printf $fh '<a href="%s"><strong>%s</strong></a>',
						$mirror->{'VU'}, $mirror->{'VH'};
				} else {
					printf $fh '<strong>%s</strong>',
						$mirror->{'VH'};
				}
				print $fh "<br>\n";
			} else {
				die "Unable to determine CVSync hostname.\nCheck for missing fields.\n";
			}
			if ($mirror->{'HA'}) {
				printf $fh $format{'alias'}."<br>\n",
				join(", ", split(/\s+/, $mirror->{'HA'}));
			}
			printf $fh $format{'location'}."<br>\n", $loc;
			printf $fh $format{'maintainer'}."<br>\n",
					$mirror->{'ME'}, $mirror->{'MN'}
				if ($mirror->{'ME'} && $mirror->{'MN'});
			if ($mirror->{'CE'}) {
				my $f;
				if ($mirror->{'CF'}) {
					$f = sprintf $format{'updated_from'},
					$mirror->{'CE'}, $mirror->{'CF'};
				} else {
					$f = sprintf $format{'updated'},
					$mirror->{'CE'};
				}
				$f =~ s/every 1 hours/hourly/;
				print $fh $f."<br>\n";
			}
			print $fh "<p>\n";
		}
	}
	print $fh "\n";
}


# writes out the ftplist file to a given filename using the mirrors
# array referenced by the second argument
sub write_ftphtml($$$$) {
	my ($what, $filename, $ver, $mirrorref) = @@_;

	open(my $fh, '>', $filename) or die "open $filename: $!";
	_paste_in($fh, $sources->{"${what}-head"});
	_paste_mirrorlist($fh, $mirrorref, 'UHS', $what, $ver, 1);
	_paste_in($fh, $sources->{"${what}-mid0"});
	_paste_mirrorlist($fh, $mirrorref, 'UH', $what, $ver, 1);
	_paste_in($fh, $sources->{"${what}-mid1"});
	_paste_mirrorlist($fh, $mirrorref, 'UF', $what, $ver, 1);
	_paste_in($fh, $sources->{"${what}-mid2"});
	_paste_mirrorlist($fh, $mirrorref, 'UR', $what, $ver, 0);
	_paste_in($fh, $sources->{"${what}-end"});
	close($fh) or die "close $filename: $!";
}

sub write_cvshtml($$$$) {
	my ($what, $filename, $ver, $mirrorref) = @@_;
	my $code;

	if ($what eq 'anoncvs') {
		$code = 'AH';
	} elsif ($what eq 'cvsync') {
		$code = 'VH';
	} else {
		die "illegal command: $what\n";
	}

	open(my $fh, '>', $filename) or die "open $filename: $!";
	_paste_in($fh, $sources->{"${what}-head"});
	# produce anoncvs/cvsync mirror list
	_paste_mirrorlist($fh, $mirrorref, $code, 'openbsd', $ver, 1);
	_paste_in($fh, $sources->{"${what}-end"});
	close($fh) or die "close $filename: $!";
}


# helper function to sort entries by country
sub _by_country {
	my ($x, $y) = ($a->{GC}, $b->{GC});
	$x =~ s/^the\s+//i;	# ignore leading 'the' as in 'The Netherlands'
	$y =~ s/^the\s+//i;
	if (($x eq $y) and $a->{GS} and $b->{GS}) {
		return lc($a->{GS}) cmp lc($b->{GS})
	}
	return lc($x) cmp lc($y);
}

# helper function to make a location string
sub _get_location($$) {
	my $type = shift;
	my $m = shift;

	my $location = "";
	if ($type =~ m/^(UH|UHS|UF|UR)$/) {
		$location = "$m->{'GC'}";
		$location .= " ($m->{'GT'}" if ($m->{'GT'});
		$location .= ", $m->{'GS'}" if ($m->{'GS'});
		$location .= ')' if ($m->{'GT'});
	}
	else {
		if ($type eq 'AH' || $type eq 'VH') {
			$location .= "$m->{'GI'}, " if ($m->{'GI'});
		}
		if ($type eq 'AH' || $type eq 'VH' || $type =~ /^mirlist/) {
			$location .= "$m->{'GT'}, " if ($m->{'GT'});
			$location .= "$m->{'GS'}, " if ($m->{'GS'});
		}
		if ($type eq 'AH' || $type eq 'VH' || $type eq 'mirlist1') {
			$location .= "$m->{'GC'}" if ($m->{'GC'});
		}
		$location =~ s/, , /, /g;
		$location =~ s/, $//g;
	}

	return $location;
}

# main()
my @@mirrors = read_mirrors($sources->{'mirrors.dat'});

# XXX write_ftplist() works, but HTML entities have to be converted in
# output, and grunk has to find a proper way of getting ftplist into the
# FTP distribution.

if (@@ARGV == 2) {
	my $cmd = $ARGV[0];
	my $ver = $ARGV[1];

	if ($cmd eq 'ftplist') {
		write_ftplist($targets->{'ftplist'}, $ver, \@@mirrors, 'UH');
		write_ftplist($targets->{'httpslist'}, $ver, \@@mirrors, 'UHS');
		write_mirror_list($targets->{'mirror_list'}, \@@mirrors);
	} elsif ($cmd eq 'openbsd-ftp' || $cmd eq 'openbgpd-ftp' ||
		 $cmd eq 'openntpd-portable' ||
		 $cmd eq 'openssh-ftp' || $cmd eq 'openssh-portable') {
		write_ftphtml($cmd, $targets->{"$cmd"}, $ver, \@@mirrors);
	} elsif ($cmd eq 'anoncvs' || $cmd eq 'cvsync') {
		write_cvshtml($cmd, $targets->{"$cmd"}, $ver, \@@mirrors);
	} else {
		die "Unknown mirror target.\n"
	}
} else {
	die "Wrong number of arguments.\n"
}
@


1.41
log
@Adjust ftp list generation to include https URLs (not previously shown here),
putting them first in the list, and suppressing the http version for those sites.
beck@@ deraadt@@ liked it, tweaks suggested by tj@@ tb@@ - I've incorporated some,
they may want to tweak some more but this seems a good starting point.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.40 2017/02/23 12:47:13 sthen Exp $';
a62 1
	'pkg_conf'		=> $srcdir.'/etc/examples/pkg.conf',
a184 31
# writes out the ftplist in pkg.conf format
sub write_pkg_conf($$) {
	my ($filename, $mirrorref) = @@_;
	my $lastloc = '';

	open(my $fh, '>', $filename) or die "open $filename: $!";

	printf $fh "# \$OpenBSD\$\n#\n";
	printf $fh "# Mirrors update at differing schedules. If using snapshots, sticking\n";
	printf $fh "# with one host will reduce risk of fetching out-of-sync packages.\n"; 
	foreach my $mirror (sort _by_country @@$mirrorref) {
		my $loc;
		next unless ($mirror->{'UH'});
		if (defined($mirror->{'GS'}) and $mirror->{'GC'} eq 'USA') {
			$loc = $mirror->{'GS'}.', ';
		}
		$loc .= $mirror->{'GC'};
		if ($lastloc ne $loc) {
			printf $fh "\n# %s\n", $loc;
		}
		my $url = $mirror->{'UH'};
	       	$url =~ s/http:\/\/([^\/]*)\/pub\/OpenBSD\/$/$1/;
	       	$url =~ s/(http:\/\/.*)/$1%c\/packages\/%a\//;
		printf $fh "#installpath = %s\n", $url;
		$lastloc = $loc;
	}

	close($fh) or die "close $filename: $!";
}


a410 1
		write_pkg_conf($targets->{'pkg_conf'}, \@@mirrors);
@


1.40
log
@check URL scheme matches URL type
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.39 2016/12/31 20:35:13 sthen Exp $';
d27 1
d33 1
d39 1
d45 1
d50 1
d236 4
d241 1
a241 1
		if ($type eq 'UH' || $type eq 'UF' || $type eq 'UR') {
d355 2
d404 1
a404 1
	if ($type eq 'UH' || $type eq 'UF' || $type eq 'UR') {
@


1.39
log
@Honour BSDSRCDIR in environment (including coming from make(1)'s command
line) if present; used when generating /usr/src/etc/examples/pkg.conf.
Reported by / ok ajacoutot@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.38 2016/12/21 21:13:42 sthen Exp $';
d166 6
@


1.38
log
@add separate UHS lines for https with the url.
add code to mirrors.pl to write out ../httpslist from these.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.37 2016/04/21 23:03:40 sthen Exp $';
d55 2
d58 1
a58 1
	'pkg_conf'		=> '/usr/src/etc/examples/pkg.conf',
@


1.37
log
@fix sort helper
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.36 2016/04/20 08:11:29 sthen Exp $';
d58 1
d111 2
a112 2
sub write_ftplist($$$) {
	my ($filename, $ver, $mirrorref) = @@_;
d121 1
a121 1
		next unless ($mirror->{'UH'});
d131 1
a131 1
		(my $url = $mirror->{'UH'}) =~ s,/$,,;
d150 1
a150 1
	for my $type ('UH', 'UF', 'UR') {
d421 2
a422 1
		write_ftplist($targets->{'ftplist'}, $ver, \@@mirrors);
@


1.36
log
@mop up. PLEASE run make ftp when changing mirrors.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.35 2016/01/21 20:07:59 sthen Exp $';
d369 1
a369 1
	my ($x, $y) = ($a->{'GC'}, $b->{'GC'});
d372 2
a373 2
	if (($x eq $y) and defined($a->{'GS'} and defined($b->{'GS'}))) {
		return lc($a->{'GS'}) cmp lc($b->{'GS'})
@


1.35
log
@mirrors.pl tweaks:
- sort by state within a country
- add WIP pkg.conf bits, may need tweaking after review of pkg_add diff
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.34 2015/10/16 13:45:39 sthen Exp $';
d33 1
a33 1
	'openbgpd-ftp-mid2'	=> 'mirrors/openntpd-ftp.html.mid2',
a35 4
	'openntpd-ftp-head'	=> 'mirrors/openntpd-ftp.html.head',
	'openntpd-ftp-mid1'	=> 'mirrors/ftp.html.mid1',
	'openntpd-ftp-mid2'	=> 'mirrors/openntpd-ftp.html.mid2',
	'openntpd-ftp-end'	=> 'mirrors/openntpd-ftp.html.end',
d38 2
a39 2
	'openntpd-portable-mid2'=> 'mirrors/openntpd-ftp.html.mid2',
	'openntpd-portable-end'	=> 'mirrors/openntpd-ftp.html.end',
d43 1
a43 1
	'openssh-ftp-mid2'	=> 'mirrors/openntpd-ftp.html.mid2',
d47 1
a47 1
	'openssh-portable-mid2' => 'mirrors/openntpd-ftp.html.mid2',
a60 1
	'openntpd-ftp'		=> '../openntpd/ftp.html',
a227 3
			elsif ($proj eq 'openntpd-ftp') {
				$url .= "OpenNTPD/openntpd-${version}.tgz";
			}
d424 1
a424 1
		 $cmd eq 'openntpd-ftp' || $cmd eq 'openntpd-portable' ||
@


1.34
log
@stop generating ftp:// URLs in the ftplist file, it's only for the installer
which now only does http
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.33 2014/12/23 15:44:23 naddy Exp $';
d60 1
d177 31
d380 3
d430 1
@


1.33
log
@handle multiple fingerprint entries and add SHA256 fingerprints for
anoncvs.spacehopper.org; from sthen@@, slightly tweaked
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.32 2014/03/02 19:37:02 sthen Exp $';
d123 16
a138 19
	for my $type ('UH', 'UF') {
		foreach my $mirror (sort _by_country @@$mirrorref) {
			next unless ($mirror->{$type});
			my $loc = '';
			$loc .= "$mirror->{'GT'}, " if $mirror->{'GT'};
			$loc .= "$mirror->{'GS'}, " if $mirror->{'GS'};
			$loc .= "$mirror->{'GC'}" if $mirror->{'GC'};
			$loc =~ s/&auml;/a/g ;
			$loc =~ s/&ouml;/o/g ;
			$loc =~ s/&uuml;/u/g ;
			$loc =~ s/&eacute;/e/g ;
			$loc =~ s/&ntilde;/n/g ;
			(my $url = $mirror->{$type}) =~ s,/$,,;
			my $pad = $MAXWIDTH - length($url) - 1;
			# + 4 for aesthetics; force some whitespace
			if (length($url) + length($loc) + 4 > $MAXWIDTH) {
				die "Entry for $url too long";
			}
			printf $fh "%s %" . $pad . "s\n", $url, $loc;
d140 1
@


1.32
log
@stop trying to use the now-nonexistent code to write out the file to
merge into distrib/notes, found by nick@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.31 2014/02/27 20:31:30 sthen Exp $';
d90 6
@


1.31
log
@Other parts to go with the distrib/notes/mirrors removal
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.30 2014/01/14 10:11:32 sthen Exp $';
a389 1
		write_mirrors($targets->{'mirrors'}, \@@mirrors);
@


1.30
log
@no anoncvs mirrors listing key fingerprints in this file offer SSH1; just kill
support for printing it. (anoncvs.jp *does* offer it, but doesn't have FPs
listed, and we don't want to encourage SSH1 anyway.)
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.29 2014/01/14 09:53:45 sthen Exp $';
a57 2
	'mirrors-head'		=> 'mirrors/mirrors-notes.head',
	'mirrors-end'		=> 'mirrors/mirrors-notes.end'
a60 1
	'mirrors'		=> '../mirrors-notes',
a138 30
	close($fh) or die "close $filename: $!";
}

# writes out the ftplist in format for src/distrib/notes/mirrors
sub write_mirrors($$) {
	my ($filename, $mirrorref) = @@_;

	open(my $fh, '>', $filename) or die "open $filename: $!";
	_paste_in($fh, $sources->{"mirrors-head"});

	my $oldcountry='';
	foreach my $mirror (sort _by_country @@$mirrorref) {
		for my $type ('UH', 'UF') {
			next unless ($mirror->{$type});
			if($mirror->{'GC'} ne $oldcountry) {
				printf $fh "\n%s:\n", $mirror->{'GC'};
				$oldcountry=$mirror->{'GC'};
			}
			(my $url = $mirror->{$type}) =~ s,/$,,;
			my $loc = _get_location ('mirlist2', $mirror);
			$loc =~ s/&auml;/a/g ;
			$loc =~ s/&ouml;/o/g ;
			$loc =~ s/&uuml;/u/g ;
			$loc =~ s/&eacute;/e/g ;
			$loc =~ s/&ntilde;/n/g ;
			printf $fh "    %s%s\n", $url, $loc ? ' ('.$loc.')' : '';
		}
	}

	_paste_in($fh, $sources->{"mirrors-end"});
@


1.29
log
@support ED25519 fingerprints for anoncvs
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.28 2014/01/14 09:44:26 sthen Exp $';
d283 1
a283 4
					$mirror->{'SO'} || $mirror->{'SE'} ||
					$mirror->{'S2'});
			print $fh "(RSA1) $mirror->{'SO'}<br>\n"
				if ($mirror->{'SO'});
@


1.28
log
@add some whitespace to group the template files in $sources
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.27 2012/04/20 14:57:19 sthen Exp $';
d93 1
a93 1
		} elsif ($line =~ /^([A-Z]{2,3})\s+(.*)/) {
d283 2
a284 1
					$mirror->{'SO'} || $mirror->{'SE'});
d293 2
@


1.27
log
@use rel="nofollow"
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.26 2010/09/27 07:34:26 sthen Exp $';
d25 1
d30 1
d35 1
d44 1
d53 1
@


1.26
log
@add support for ECDSA fingerprints
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.25 2010/07/14 23:45:56 sthen Exp $';
d241 1
a241 1
			($links) && print $fh "	<a href=\"$url\">\n";
@


1.25
log
@reorder output files for mirror lists (http first, stop distinguishing
second-levels), adjust notes. following a discussion with deraadt@@.
ok deraadt@@ beck@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.24 2010/06/28 20:44:24 sthen Exp $';
d278 1
a278 1
					$mirror->{'SO'});
d285 2
@


1.24
log
@don't like ftp.ca as L2 in mirmon
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.23 2010/06/24 20:40:02 sthen Exp $';
d115 1
a115 2
	for my $lv (1, 2, 3) {
	for my $type ('UF', 'UH') {
a116 4
			next if (($lv <= 2) &&
			    (! defined $mirror->{'LF'}));
			next if ((defined $mirror->{'LF'})
			    && ($mirror->{'LF'} != $lv));
a135 1
	}
d147 7
a153 28
	for my $lv (1, 2, 3) {
		printf $fh "Main server in Canada:\n" if ($lv == 1);
		printf $fh "\n2nd level mirrors:\n" if ($lv == 2);
		my $oldcountry='';
		foreach my $mirror (sort _by_country @@$mirrorref) {
			for my $type ('UF', 'UH') {
				next if (($lv <= 2) &&
				    (! defined $mirror->{'LF'}));
				next if ((defined $mirror->{'LF'})
				    && ($mirror->{'LF'} != $lv));
				next unless ($mirror->{$type});
				if($lv > 2 && $mirror->{'GC'} ne $oldcountry) {
					printf $fh "\n%s:\n", $mirror->{'GC'};
					$oldcountry=$mirror->{'GC'};
				}
				(my $url = $mirror->{$type}) =~ s,/$,,;
				my $loc;
				if ($lv == 2) {
					$loc = _get_location ('mirlist1', $mirror);
				} else {
					$loc = _get_location ('mirlist2', $mirror);
				}
				$loc =~ s/&auml;/a/g ;
				$loc =~ s/&ouml;/o/g ;
				$loc =~ s/&uuml;/u/g ;
				$loc =~ s/&eacute;/e/g ;
				$loc =~ s/&ntilde;/n/g ;
				printf $fh "    %s%s\n", $url, $loc ? ' ('.$loc.')' : '';
d155 8
d216 1
a216 2
	print $fh ' ' x 4 if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR');
	for my $lv (1, 2, 3) {
a217 8
		if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR') {
			next if (($lv <= 2) && !defined $mirror->{'LF'});
			next if ((defined $mirror->{'LF'}) && ($mirror->{'LF'} != $lv));
		}
		elsif ($type eq 'AH' || $type eq 'VH') {
			next if (($lv <= 2) && !defined $mirror->{'LC'});
			next if ((defined $mirror->{'LC'}) && ($mirror->{'LC'} != $lv));
		}
d220 1
a220 1
		if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR') {
a323 1
	}
d335 2
a337 2
	_paste_in($fh, $sources->{"${what}-mid1"});
	_paste_mirrorlist($fh, $mirrorref, 'UH', $what, $ver, 1);
d339 1
a339 3
	if (not $what =~ /^openssh.*/) {
		_paste_mirrorlist($fh, $mirrorref, 'UR', $what, $ver, 0);
	}
d379 5
a383 19
	if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR') {
		# first/second level mirrors have different title
		if ((defined $m->{'LF'}) && ($m->{'LF'} == 1)) {
			$location = "Master Fanout Site ($m->{'GC'})";
		} elsif ((defined $m->{'LF'}) && ($m->{'LF'} == 2)) {
			$location = "Second Level Mirror<br>";
			$location .= '(' if ($m->{'GT'} || $m->{'GS'} ||
				$m->{'GC'});
			$location .= $m->{'GT'} if $m->{'GT'};
			$location .= ", $m->{'GS'}" if $m->{'GS'};
			$location .= ", $m->{'GC'}" if $m->{'GC'};
			$location .= ')' if ($m->{'GT'} || $m->{'GS'} ||
				$m->{'GC'});
		} else {
			$location = "$m->{'GC'}";
			$location .= " ($m->{'GT'}" if ($m->{'GT'});
			$location .= ", $m->{'GS'}" if ($m->{'GS'});
			$location .= ')' if ($m->{'GT'});
		}
@


1.23
log
@- adjust mirrors.dat for new mirroring policy; lots of this from deraadt@@
- simplify scripts and mirrors.dat
- regen html
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.22 2010/06/08 03:32:11 sthen Exp $';
d203 1
a203 1
				    && ($mirror->{'LF'} <= 2)) {
@


1.22
log
@Include rsync mirrors in mirmon output
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.21 2010/06/08 01:15:21 sthen Exp $';
d196 10
a205 11
	for my $lv (1, 2, 3) {
		for my $type ('UH', 'UF', 'UR') {
			foreach my $mirror (sort _by_country @@$mirrorref) {
				next if (($lv <= 2) &&
				    (! defined $mirror->{'LF'}));
				next if ((defined $mirror->{'LF'})
				    && ($mirror->{'LF'} != $lv));
				next unless ($mirror->{$type});
				(my $url = $mirror->{$type}) =~ s,/$,,;
				my $loc = '';
				if (defined $mirror->{'GZ'}) {
a206 2
				} else {
					warn('no GZ for '.$mirror->{$type});
d208 2
a209 1
				printf $fh "%s %s\n", $loc, $mirror->{$type};
d211 1
d235 1
a235 2
	print $fh ' ' x 4 if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR'
	    || $type eq 'USF' || $type eq 'USH' || $type eq 'USR');
d238 1
a238 2
		if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR'
		    || $type eq 'USF' || $type eq 'USH' || $type eq 'USR') {
d248 1
a248 2
		if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR'
		    || $type eq 'USF' || $type eq 'USH' || $type eq 'USR') {
d257 2
a258 1
				$url .= "openssh-${version}.tar.gz";
d261 2
a262 2
				#$url .= "portable/openssh-${version}.tar.gz";
				$url .= "portable/";
d364 1
a364 6
	# produce ftp mirror list
	if($what eq 'openssh-ftp' || $what eq 'openssh-portable') {
		_paste_mirrorlist($fh, $mirrorref, 'USF', $what, $ver, 1);
	} else {
		_paste_mirrorlist($fh, $mirrorref, 'UF', $what, $ver, 1);
	}
d366 3
a368 7
	# produce http mirror list
	if($what eq 'openssh-ftp' || $what eq 'openssh-portable') {
		_paste_mirrorlist($fh, $mirrorref, 'USH', $what, $ver, 1);
	} else {
		_paste_mirrorlist($fh, $mirrorref, 'UH', $what, $ver, 1);
		_paste_in($fh, $sources->{"${what}-mid2"});
		# produce rsync mirror list, not for OpenSSH
d410 1
a410 2
	if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR' ||
	    $type eq 'USF' || $type eq 'USH') {
@


1.21
log
@on second thoughts, generate the file for src/distrib/notes/mirrors
within www/ rather than in-place.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.20 2010/06/08 00:11:07 sthen Exp $';
d197 1
a197 1
		for my $type ('UH', 'UF') {
@


1.20
log
@add mirror list output formats; suitable for use in src/distrib/notes/mirrors
and with ports/net/mirmon.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.14 2009/11/18 21:17:35 sthen Exp $';
d58 1
a58 1
	'mirrors'		=> '/usr/src/distrib/notes/mirrors',
@


1.19
log
@Same as last fix, but for cvsync instead of anoncvs.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.18 2010/04/19 20:04:25 sthen Exp $';
d52 3
a54 1
	'cvsync-end'		=> 'mirrors/cvsync.html.end'
d58 2
d146 73
d443 13
a455 5
	elsif ($type eq 'AH' || $type eq 'VH') {
		$location .= "$m->{'GI'}, " if ($m->{'GI'});
		$location .= "$m->{'GT'}, " if ($m->{'GT'});
		$location .= "$m->{'GS'}, " if ($m->{'GS'});
		$location .= "$m->{'GC'}" if ($m->{'GC'});
d474 2
@


1.18
log
@Fix output for cvs mirrors when listed as mirroring hourly when an
upstream server is shown (avoids printing 'Updated hourly from 1').
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.17 2010/01/22 22:17:27 sthen Exp $';
a17 1
$format{'updated_1h'}	= 'Updated hourly.';
a18 1
$format{'updated_from_1h'} = 'Updated hourly from %s.';
d264 1
a264 2
				my $f = '';
				$f .= '_1h' if ($mirror->{'CE'} == 1);
d266 1
a266 1
					printf $fh $format{'updated_from'.$f},
d269 1
a269 1
					printf $fh $format{'updated'.$f},
d272 2
a273 1
				print $fh "<br>\n";
@


1.17
log
@Also print "hourly" for cvsync.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.16 2010/01/22 22:00:35 sthen Exp $';
d221 1
a221 2
				my $f = '';
				$f .= '_1h' if ($mirror->{'CE'} == 1);
d223 1
a223 1
					printf $fh $format{'updated_from'.$f},
d226 1
a226 1
					printf $fh $format{'updated'.$f},
d229 2
a230 1
				print $fh "<br>\n";
@


1.16
log
@Say 'updated hourly' instead of 'updated every 1 hours' where
appropriate. Suggested by Brad.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.15 2009/11/18 21:18:26 sthen Exp $';
d266 2
d269 1
a269 1
					printf $fh $format{'updated_from'},
d272 1
a272 1
					printf $fh $format{'updated'},
@


1.15
log
@oops, this should not have been committed - revert
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.13 2009/05/07 15:48:43 sthen Exp $';
d18 1
d20 1
d221 2
d224 1
a224 1
					printf $fh $format{'updated_from'},
d227 1
a227 1
					printf $fh $format{'updated'},
@


1.14
log
@add new mirror in Chicago USA, thanks to maintainer Neal Hogan
@
text
@d52 1
a52 3
	'cvsync-end'		=> 'mirrors/cvsync.html.end',
	'mirrors-head'		=> 'mirrors/mirrors-notes.head',
	'mirrors-end'		=> 'mirrors/mirrors-notes.end'
a55 2
	'mirrors'		=> '/usr/src/distrib/notes/mirrors',
	'mirror_list'		=> '../mirror_list',
a141 73
# writes out the ftplist in mirmon format
sub write_mirrors($$) {
	my ($filename, $mirrorref) = @@_;

	open(my $fh, '>', $filename) or die "open $filename: $!";
	_paste_in($fh, $sources->{"mirrors-head"});

	for my $lv (1, 2, 3) {
		printf $fh "Main server in Canada:\n" if ($lv == 1);
		printf $fh "\n2nd level mirrors:\n" if ($lv == 2);
		for my $type ('UF') {
			my $oldcountry='';
			foreach my $mirror (sort _by_country @@$mirrorref) {
				next if (($lv <= 2) &&
				    (! defined $mirror->{'LF'}));
				next if ((defined $mirror->{'LF'})
				    && ($mirror->{'LF'} != $lv));
				next unless ($mirror->{$type});
				if($lv > 2 && $mirror->{'GC'} ne $oldcountry) {
					printf $fh "\n%s:\n", $mirror->{'GC'};
					$oldcountry=$mirror->{'GC'};
				}
				(my $url = $mirror->{$type}) =~ s,/$,,;
				my $loc;
				if ($lv == 2) {
					$loc = _get_location ('mirlist1', $mirror);
				} else {
					$loc = _get_location ('mirlist2', $mirror);
				}
				$loc =~ s/&auml;/a/g ;
				$loc =~ s/&ouml;/o/g ;
				$loc =~ s/&uuml;/u/g ;
				$loc =~ s/&eacute;/e/g ;
				$loc =~ s/&ntilde;/n/g ;
				printf $fh "    %s%s\n", $url, $loc ? ' ('.$loc.')' : '';
			}
		}
	}

	_paste_in($fh, $sources->{"mirrors-end"});
	close($fh) or die "close $filename: $!";
}


# writes out the ftplist in mirmon format
sub write_mirror_list($$) {
	my ($filename, $mirrorref) = @@_;

	open(my $fh, '>', $filename) or die "open $filename: $!";

	for my $lv (1, 2, 3) {
		for my $type ('UF', 'UH') {
			foreach my $mirror (sort _by_country @@$mirrorref) {
				next if (($lv <= 2) &&
				    (! defined $mirror->{'LF'}));
				next if ((defined $mirror->{'LF'})
				    && ($mirror->{'LF'} != $lv));
				next unless ($mirror->{$type});
				(my $url = $mirror->{$type}) =~ s,/$,,;
				my $loc = '';
				if (defined $mirror->{'GZ'}) {
					$loc .= "$mirror->{'GZ'}";
				} else {
					warn('no GZ for '.$mirror->{$type});
				}
				printf $fh "%s %s\n", $loc, $mirror->{$type};
			}
		}
	}

	close($fh) or die "close $filename: $!";
}

d362 5
a366 13
	else {
		if ($type eq 'AH' || $type eq 'VH') {
			$location .= "$m->{'GI'}, " if ($m->{'GI'});
		}
		if ($type eq 'AH' || $type eq 'VH' || $type =~ /^mirlist/) {
			$location .= "$m->{'GT'}, " if ($m->{'GT'});
			$location .= "$m->{'GS'}, " if ($m->{'GS'});
		}
		if ($type eq 'AH' || $type eq 'VH' || $type eq 'mirlist1') {
			$location .= "$m->{'GC'}" if ($m->{'GC'});
		}
		$location =~ s/, , /, /g;
		$location =~ s/, $//g;
a384 2
		write_mirrors($targets->{'mirrors'}, \@@mirrors);
		write_mirror_list($targets->{'mirror_list'}, \@@mirrors);
@


1.13
log
@right-align ftplist, and enforce that lines won't wrap in the installer.
discussed with deraadt.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.12 2008/10/13 19:52:03 sthen Exp $';
d52 3
a54 1
	'cvsync-end'		=> 'mirrors/cvsync.html.end'
d58 2
d146 73
d439 13
a451 5
	elsif ($type eq 'AH' || $type eq 'VH') {
		$location .= "$m->{'GI'}, " if ($m->{'GI'});
		$location .= "$m->{'GT'}, " if ($m->{'GT'});
		$location .= "$m->{'GS'}, " if ($m->{'GS'});
		$location .= "$m->{'GC'}" if ($m->{'GC'});
d470 2
@


1.12
log
@Add infrastructure to build OpenSSH ftp site lists from mirrors.dat.
ok grunk@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.11 2008/09/03 22:36:08 sthen Exp $';
d105 3
a107 3
	my $MAXWIDTH = 72;
	my $URLLEN = 54;
	my $LOCLEN = $MAXWIDTH - $URLLEN - 1;
d129 4
a132 6
			if ((length($url) + 1 + length($loc) <= $MAXWIDTH)
					&& (length($loc) > $LOCLEN)) {
				my $lr = $URLLEN - length($url) + $LOCLEN;
				printf $fh "%s %" . $lr . "s\n", $url, $loc;
			} else {
				printf $fh "%-". $URLLEN ."s %s\n", $url, $loc;
d134 1
@


1.11
log
@for ftplist, s/&ntilde;/n/ as done for umlauts/eacute
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.10 2006/10/24 18:08:41 grunk Exp $';
d41 8
d60 2
d84 1
a84 1
		} elsif ($line =~ /^([A-Z]{2})\s+(.*)/) {
d160 2
a161 1
	print $fh ' ' x 4 if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR');
d164 2
a165 1
		if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR') {
d175 2
a176 1
		if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR') {
d184 7
d288 5
a292 1
	_paste_mirrorlist($fh, $mirrorref, 'UF', $what, $ver, 1);
d295 8
a302 4
	_paste_mirrorlist($fh, $mirrorref, 'UH', $what, $ver, 1);
	_paste_in($fh, $sources->{"${what}-mid2"});
	# produce rsync mirror list
	_paste_mirrorlist($fh, $mirrorref, 'UR', $what, $ver, 0);
d342 2
a343 1
	if ($type eq 'UF' || $type eq 'UH' || $type eq 'UR') {
d387 2
a388 1
		 $cmd eq 'openntpd-ftp' || $cmd eq 'openntpd-portable') {
@


1.10
log
@print ftplist in correct format:  lines 72 chars max (else they'll wrap
in install.sub), and replace umlauts and other scary stuff by normal characters

ok steven@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.9 2006/09/17 06:08:46 steven Exp $';
d117 1
@


1.9
log
@use printf and define some stuff at the top, as a first step toward
easing translation

ok grunk
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.8 2006/08/23 07:39:34 steven Exp $';
d95 4
d113 4
d118 3
a120 3
			if ((length($url) + length($loc) < 78)
					&& (length($loc) > 25)) {
				my $lr = 78 - length($url);
d123 1
a123 1
				printf $fh "%-54s %s\n", $url, $loc;
@


1.8
log
@generate cvsync mirror list from the mirror database, so from now on please
edit mirrors.dat and 'make cvsync'.

ok grunk@@
@
text
@d10 11
a20 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.7 2006/05/06 06:02:59 steven Exp $';
d174 3
a176 4
				print $fh "<li><strong>CVSROOT=",
					$mirror->{'AU'}, '@@',
					$mirror->{'AH'}, ':',
					$mirror->{'AR'}, "</strong><br>\n";
d181 6
a186 8
				print $fh "Host also known as <strong>",
				join(", ", split(/\s+/, $mirror->{'HA'})),
				"</strong>.<br>\n";
			}
			print $fh "Location: $loc.<br>\n";
			print $fh "Maintained by <a href=\"mailto:",
					$mirror->{'ME'}, "\">",
					$mirror->{'MN'}, "</a>.<br>\n"
d188 1
a188 1
			print $fh "Protocols: $mirror->{'AP'}.<br>\n"
d191 8
a198 4
				print $fh "Updated every $mirror->{'CE'} hours";
				print $fh " from $mirror->{'CF'}"
					if ($mirror->{'CF'});
				print $fh ".<br>\n";
d200 1
a200 1
			print $fh "SSH fingerprints:<br>\n"
d214 7
a220 5
				print $fh "<a href=\"", $mirror->{'VU'}, "\">"
					if ($mirror->{'VU'});
				print $fh "<strong>", $mirror->{'VH'},
					"</strong>";
				print $fh "</a>" if ($mirror->{'VU'});
d226 6
a231 8
				print $fh "Host also known as <strong>",
				join(", ", split(/\s+/, $mirror->{'HA'})),
				"</strong>.<br>\n";
			}
			print $fh "Location: $loc.<br>\n";
			print $fh "Maintained by <a href=\"mailto:",
					$mirror->{'ME'}, "\">",
					$mirror->{'MN'}, "</a>.<br>\n"
d234 8
a241 4
				print $fh "Updated every $mirror->{'CE'} hours";
				print $fh " from $mirror->{'CF'}"
					if ($mirror->{'CF'});
				print $fh ".<br>\n";
@


1.7
log
@generate OpenNTPD and OpenBGPD ftp pages from the mirror database.
"looks good" grunk@@, "go for it" henning@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.6 2006/04/26 06:49:33 steven Exp $';
d32 3
a34 1
	'anoncvs-end'		=> 'mirrors/anoncvs.html.end'
d42 2
a43 1
	'anoncvs'		=> '../anoncvs.html'
d130 2
a131 1
	print $fh ' ' x 4;		# indent for first <td> to come
d138 1
a138 1
		elsif ($type eq 'AH') {
d200 30
d255 11
a265 2
sub write_anoncvshtml($$$) {
	my ($filename, $ver, $mirrorref) = @@_;
d268 4
a271 4
	_paste_in($fh, $sources->{'anoncvs-head'});
	# produce cvsync mirror list
	_paste_mirrorlist($fh, $mirrorref, 'AH', 'openbsd', $ver, 1);
	_paste_in($fh, $sources->{'anoncvs-end'});
d310 1
a310 1
	elsif ($type eq 'AH') {
d336 2
a337 2
	} elsif ($cmd eq 'anoncvs') {
		write_anoncvshtml($targets->{'anoncvs'}, $ver, \@@mirrors);
@


1.6
log
@extend the mirror infrastructure to generate anoncvs.html.
please enter any new anoncvs mirrors in mirrors.dat from now.
ok grunk@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.5 2006/03/02 19:11:50 steven Exp $';
d12 1
d15 18
a32 6
	'ftp-head'	=> 'mirrors/ftp.html.head',
	'ftp-mid1'	=> 'mirrors/ftp.html.mid1',
	'ftp-mid2'	=> 'mirrors/ftp.html.mid2',
	'ftp-end'	=> 'mirrors/ftp.html.end',
	'anoncvs-head'	=> 'mirrors/anoncvs.html.head',
	'anoncvs-end'	=> 'mirrors/anoncvs.html.end'
d35 6
a40 3
	'ftplist'	=> '../ftplist',
	'ftp.html'	=> '../ftp.html',
	'anoncvs.html'	=> '../anoncvs.html'
d79 2
a80 2
sub write_ftplist($$) {
	my ($filename, $mirrorref) = @@_;
d124 2
a125 2
sub _paste_mirrorlist($$$$) {
	my ($fh, $mirrorref, $type, $links) = @@_;
d141 10
d153 2
a154 2
			($links) && print $fh "	<a href=\"$mirror->{$type}\">\n";
			print $fh "\t$mirror->{$type}";
d204 2
a205 2
sub write_ftphtml($$) {
	my ($filename, $mirrorref) = @@_;
d208 1
a208 1
	_paste_in($fh, $sources->{'ftp-head'});
d210 2
a211 2
	_paste_mirrorlist($fh, $mirrorref, 'UF', 1);
	_paste_in($fh, $sources->{'ftp-mid1'});
d213 2
a214 2
	_paste_mirrorlist($fh, $mirrorref, 'UH', 1);
	_paste_in($fh, $sources->{'ftp-mid2'});
d216 2
a217 2
	_paste_mirrorlist($fh, $mirrorref, 'UR', 0);
	_paste_in($fh, $sources->{'ftp-end'});
d221 2
a222 2
sub write_anoncvshtml($$) {
	my ($filename, $mirrorref) = @@_;
d227 1
a227 1
	_paste_mirrorlist($fh, $mirrorref, 'AH', 1);
d284 1
a284 1
if (@@ARGV == 1) {
d286 1
d289 4
a292 3
		write_ftplist($targets->{'ftplist'}, \@@mirrors);
	} elsif ($cmd eq 'ftp') {
		write_ftphtml($targets->{'ftp.html'}, \@@mirrors);
d294 1
a294 1
		write_anoncvshtml($targets->{'anoncvs.html'}, \@@mirrors);
@


1.5
log
@sort by lower case country names, makes Ukraine end up before USA again.
requested by and ok grunk@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.4 2006/01/31 21:53:37 steven Exp $';
d18 2
d23 2
a24 1
	'ftp.html'	=> '../ftp.html'
d114 8
a121 2
		next if (($lv <= 2) && (! defined $mirror->{'LF'}));
		next if ((defined $mirror->{'LF'}) && ($mirror->{'LF'} != $lv));
d123 47
a169 25
		# first/second level mirrors have different title
		my $title;
		if ((defined $mirror->{'LF'}) && ($mirror->{'LF'} == 1)) {
			$title = "Master Fanout Site ($mirror->{'GC'})";
		} elsif ((defined $mirror->{'LF'}) && ($mirror->{'LF'} == 2)) {
			$title = "Second Level Mirror<br>";
			$title .= '(' if ($mirror->{'GT'} || $mirror->{'GS'}
			    || $mirror->{'GC'});
			$title .= $mirror->{'GT'} if $mirror->{'GT'};
			$title .= ", $mirror->{'GS'}" if $mirror->{'GS'};
			$title .= ", $mirror->{'GC'}" if $mirror->{'GC'};
			$title .= ')' if ($mirror->{'GT'} || $mirror->{'GS'}
			    || $mirror->{'GC'});
		} else {
			$title = "$mirror->{'GC'}";
			$title .= " ($mirror->{'GT'}" if ($mirror->{'GT'});
			$title .= ", $mirror->{'GS'}" if ($mirror->{'GS'});
			$title .= ')' if ($mirror->{'GT'});
		}
		print $fh "<tr>\n	<td>\n	<strong>$title</strong>\n";
		print $fh "	</td><td>\n";
		($links) && print $fh "	<a href=\"$mirror->{$type}\">\n";
		print $fh "	$mirror->{$type}";
		($links) && print $fh "</a>";
		print $fh "\n	</td>\n    </tr>";
d195 11
d215 36
a256 1
#write_ftplist($targets->{'ftplist'}, \@@mirrors);
d258 15
a272 1
write_ftphtml($targets->{'ftp.html'}, \@@mirrors);
@


1.4
log
@ignore leading "the" in country name when sorting mirrors.
feedback/ok grunk@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.3 2006/01/28 14:14:53 steven Exp $';
d170 1
a170 1
	return $x cmp $y;
@


1.3
log
@sort somehow ended up in unused function, really sort the list now.
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.2 2006/01/28 14:01:29 steven Exp $';
d167 4
a170 1
	$a->{'GC'} cmp $b->{'GC'}
@


1.2
log
@sort mirrors by country. provides nicer translated versions of the list.
ok grunk@@
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD: mirrors.pl,v 1.1 2006/01/27 17:42:19 grunk Exp $';
d110 1
a110 1
	foreach my $mirror (@@$mirrorref) {
d167 1
a167 1
        $a->{'GC'} cmp $b->{'GC'}
@


1.1
log
@mirrors will be managed by a framework similar to that of groups/support
and pkg-stable from now on.  In this commit, introduce the tools and the
mirror database.  At the moment, we are capable of generating ftp.html
(FTP/HTTP/RSYNC mirrors).  This will soon be extended to doing the rest
of the mirror pages, ftplist, and also the mirrors of the subprojects that
want to use this database.

Help, discussion and ok steven@@, and no protest from other www people
@
text
@d10 1
a10 1
my $RCS_ID = '$OpenBSD$';
d67 1
a67 1
		foreach my $mirror (@@$mirrorref) {
d164 5
@

