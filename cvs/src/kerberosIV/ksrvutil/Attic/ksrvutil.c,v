head	1.7;
access;
symbols
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	initial:1.1.1.1
	KTH/tholo:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2000.02.25.15.15.08;	author hin;	state dead;
branches;
next	1.6;

1.6
date	99.05.23.17.19.24;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	97.12.17.07.50.16;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.04.08.22.40.52;	author rees;	state Exp;
branches;
next	1.3;

1.3
date	96.09.16.18.49.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.08.43.56;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.06.52.53;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.14.06.52.53;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove old KerberosIV code. (art@@ ok)
@
text
@/*	$OpenBSD: ksrvutil.c,v 1.6 1999/05/23 17:19:24 aaron Exp $	*/
/* $KTH: ksrvutil.c,v 1.39 1997/05/02 14:28:52 assar Exp $ */

/* 
 *  Copyright (C) 1989 by the Massachusetts Institute of Technology
 *
 *  Export of this software from the United States of America is assumed
 *  to require a specific license from the United States Government.
 *  It is the responsibility of any person or organization contemplating
 *  export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 */

/*
 * list and update contents of srvtab files
 */

/*
 * ksrvutil
 * list and update the contents of srvtab files
 */

#include "kadm_locl.h"

#include "ksrvutil.h"

#ifdef NOENCRYPTION
#define read_long_pw_string placebo_read_pw_string
#else /* NOENCRYPTION */
#define read_long_pw_string des_read_pw_string
#endif /* NOENCRYPTION */

#define SRVTAB_MODE 0600	/* rw------- */
#define PAD "  "
#define VNO_HEADER "Version"
#define VNO_FORMAT "%4d   "
#define KEY_HEADER "       Key       " /* 17 characters long */
#define PRINC_HEADER "  Principal\n"
#define PRINC_FORMAT "%s"

char u_name[ANAME_SZ];
char u_inst[INST_SZ];
char u_realm[REALM_SZ];

char progname[] = "ksrvutil";

int destroyp = FALSE;		/* Should the ticket file be destroyed? */

static unsigned short
get_mode(char *filename)
{
    struct stat statbuf;
    unsigned short mode;

    memset(&statbuf, 0, sizeof(statbuf));
    
    if (stat(filename, &statbuf) < 0) 
	mode = SRVTAB_MODE;
    else
	mode = statbuf.st_mode;

    return(mode);
}

static void
copy_keyfile(char *keyfile, char *backup_keyfile)
{
    int keyfile_fd;
    int backup_keyfile_fd;
    int keyfile_mode;
    char buf[BUFSIZ];		/* for copying keyfiles */
    int rcount;			/* for copying keyfiles */
    int try_again;
    
    memset(buf, 0, sizeof(buf));
    
    do {
	try_again = FALSE;
	if ((keyfile_fd = open(keyfile, O_RDONLY, 0)) < 0) {
	    if (errno != ENOENT)
		err (1, "read %s", keyfile);
	    else {
		try_again = TRUE;
		if ((keyfile_fd = 
		     open(keyfile, 
			  O_WRONLY | O_TRUNC | O_CREAT, SRVTAB_MODE)) < 0)
		    err(1, "create %s", keyfile);
		else
		    if (close(keyfile_fd) < 0)
			err (1, "close %s", keyfile);
	    }
	}
    } while(try_again);

    keyfile_mode = get_mode(keyfile);

    if ((backup_keyfile_fd = 
	 open(backup_keyfile, O_WRONLY | O_TRUNC | O_CREAT, 
	      keyfile_mode)) < 0)
	err (1, "write %s", backup_keyfile);
    do {
	if ((rcount = read(keyfile_fd, buf, sizeof(buf))) < 0)
	    err (1, "read %s", keyfile);
	if (rcount && (write(backup_keyfile_fd, buf, rcount) != rcount))
	    err (1, "write %s", backup_keyfile);
    } while (rcount);
    if (close(backup_keyfile_fd) < 0)
	err(1, "close %s", backup_keyfile);
    if (close(keyfile_fd) < 0)
	err(1, "close %s", keyfile);
}

void
leave(char *str, int x)
{
    if (str)
	fprintf(stderr, "%s\n", str);
    if (destroyp)
	 dest_tkt();
    exit(x);
}

void
safe_read_stdin(char *prompt, char *buf, size_t size)
{
    printf("%s", prompt);
    fflush(stdout);
    memset(buf, 0, size);
    if (read(0, buf, size - 1) < 0) {
	warn("read stdin");
	leave(NULL, 1);
    }
    buf[strlen(buf)-1] = 0;
}

void
safe_write(char *filename, int fd, void *buf, size_t len)
{
    if (write(fd, buf, len) != len) {
	warn("write %s", filename);
	close(fd);
	leave("In progress srvtab in this file.", 1);
    }
}

static int
yes_no(char *string, int dflt)
{
  char ynbuf[5];
  
  printf("%s (y,n) [%c]", string, dflt?'y':'n');
  for (;;) {
    safe_read_stdin("", ynbuf, sizeof(ynbuf));
    
    if ((ynbuf[0] == 'n') || (ynbuf[0] == 'N'))
      return(0);
    else if ((ynbuf[0] == 'y') || (ynbuf[0] == 'Y'))
      return(1);
    else if(ynbuf[0] == 0)
      return dflt;
    else {
      printf("Please enter 'y' or 'n': ");
      fflush(stdout);
    }
  }
}

int yn(char *string)
{
  return yes_no(string, 1);
}

int ny(char *string)
{
  return yes_no(string, 0);
}

static void
append_srvtab(char *filename, int fd, char *sname, char *sinst, char *srealm, unsigned char key_vno, unsigned char *key)
{
  /* Add one to append null */
    safe_write(filename, fd, sname, strlen(sname) + 1);
    safe_write(filename, fd, sinst, strlen(sinst) + 1);
    safe_write(filename, fd, srealm, strlen(srealm) + 1);
    safe_write(filename, fd, &key_vno, 1);
    safe_write(filename, fd, key, sizeof(des_cblock));
    fsync(fd);
}    

static void
print_key(unsigned char *key)
{
    int i;

    for (i = 0; i < 4; i++)
	printf("%02x", key[i]);
    printf(" ");
    for (i = 4; i < 8; i++)
	printf("%02x", key[i]);
}

static void
print_name(char *name, char *inst, char *realm)
{
    printf("%s", krb_unparse_name_long(name, inst, realm));
}

static int
get_svc_new_key(des_cblock *new_key, char *sname, char *sinst,
		char *srealm, char *keyfile)
{
    int status = KADM_SUCCESS;

    if (((status = krb_get_svc_in_tkt(sname, sinst, srealm, PWSERV_NAME,
				      KADM_SINST, 1, keyfile)) == KSUCCESS) &&
	((status = kadm_init_link(PWSERV_NAME, KRB_MASTER, srealm)) == 
	 KADM_SUCCESS)) {
#ifdef NOENCRYPTION
	memset(new_key, 0, sizeof(des_cblock));
	(*new_key)[0] = (unsigned char) 1;
#else /* NOENCRYPTION */
	des_new_random_key(new_key);
#endif /* NOENCRYPTION */
	return(KADM_SUCCESS);
    }
    
    return(status);
}

static void
get_key_from_password(des_cblock (*key), char *cellname)
{
    char password[MAX_KPW_LEN];	/* storage for the password */

    if (read_long_pw_string(password, sizeof(password)-1, "Password: ", 1))
	leave("Error reading password.", 1);

#ifdef NOENCRYPTION
    memset(key, 0, sizeof(des_cblock));
    (*key)[0] = (unsigned char) 1;
#else /* NOENCRYPTION */
    if (strlen(cellname) == 0)
      des_string_to_key(password, key);
    else
      afs_string_to_key(password, cellname, key);
#endif /* NOENCRYPTION */
    memset(password, 0, sizeof(password));
}    

static void
usage(void)
{
    fprintf(stderr, "Usage: ksrvutil [-f keyfile] [-i] [-k] ");
    fprintf(stderr, "[-p principal] [-r realm] ");
    fprintf(stderr, "[-c AFS cellname] ");
    fprintf(stderr, "{list | change | add | get}\n");
    fprintf(stderr, "   -i causes the program to ask for ");
    fprintf(stderr, "confirmation before changing keys.\n");
    fprintf(stderr, "   -k causes the key to printed for list or ");
    fprintf(stderr, "change.\n");
    exit(1);
}

int
main(int argc, char **argv)
{
    char sname[ANAME_SZ];	/* name of service */
    char sinst[INST_SZ];	/* instance of service */
    char srealm[REALM_SZ];	/* realm of service */
    unsigned char key_vno;	/* key version number */
    int status;			/* general purpose error status */
    des_cblock new_key;
    des_cblock old_key;
    char change_tkt[MAXPATHLEN]; /* Ticket to use for key change */
    char keyfile[MAXPATHLEN];	/* Original keyfile */
    char work_keyfile[MAXPATHLEN]; /* Working copy of keyfile */
    char backup_keyfile[MAXPATHLEN]; /* Backup copy of keyfile */
    unsigned short keyfile_mode; /* Protections on keyfile */
    int work_keyfile_fd = -1;	/* Initialize so that */
    int backup_keyfile_fd = -1;	/* compiler doesn't complain */
    char local_realm[REALM_SZ];	/* local kerberos realm */
    char cellname[1024];         /* AFS cell name */
    int c;
    int interactive = FALSE;
    int list = FALSE;
    int change = FALSE;
    int add = FALSE;
    int get = FALSE;
    int key = FALSE;		/* do we show keys? */
    int arg_entered = FALSE;
    int change_this_key = FALSE;
    char databuf[BUFSIZ];
    int first_printed = FALSE;	/* have we printed the first item? */
    
    memset(sname, 0, sizeof(sname));
    memset(sinst, 0, sizeof(sinst));
    memset(srealm, 0, sizeof(srealm));
    	  
    memset(change_tkt, 0, sizeof(change_tkt));
    memset(keyfile, 0, sizeof(keyfile));
    memset(work_keyfile, 0, sizeof(work_keyfile));
    memset(backup_keyfile, 0, sizeof(backup_keyfile));
    memset(local_realm, 0, sizeof(local_realm));
    memset(cellname, 0, sizeof(cellname));
    
    if (krb_get_default_principal(u_name, u_inst, u_realm) < 0)
	errx (1, "could not get default principal");

    /* This is used only as a default for adding keys */
    if (krb_get_lrealm(local_realm, 1) != KSUCCESS) {
	strncpy(local_realm, KRB_REALM, REALM_SZ - 1);
	local_realm[REALM_SZ - 1] = '\0';
    }
    
    while((c = getopt(argc, argv, "ikc:f:p:r:")) != -1) {
	 switch (c) {
	      case 'i':
	      interactive++;
	      break;
	      case 'k':
	      key++;
	      break;
	      case 'c':
	      strcpy(cellname, optarg);
	      break;
	      case 'f':
	      strcpy(keyfile, optarg);
	      break;
	      case 'p':
	      if((status = kname_parse (u_name, u_inst, u_realm, optarg)) !=
		 KSUCCESS)
		  errx (1, "principal %s: %s", optarg,
			krb_get_err_text(status));
	      break;
	      case 'r':
	      strcpy(u_realm, optarg);
	      break;
	      case '?':
	      usage();
	 }
    }
    if (optind >= argc)
	 usage();
    if (*u_realm == '\0')
	 strcpy (u_realm, local_realm);
    if (strcmp(argv[optind], "list") == 0) {
	 if (arg_entered)
	      usage();
	 else {
	      arg_entered++;
	      list++;
	 }
    }
    else if (strcmp(argv[optind], "change") == 0) {
	 if (arg_entered)
	      usage();
	 else {
	      arg_entered++;
	      change++;
	 }
    }
    else if (strcmp(argv[optind], "add") == 0) {
	 if (arg_entered)
	      usage();
	 else {
	      arg_entered++;
	      add++;
	 }
    }
    else if (strcmp(argv[optind], "get") == 0) {
	 if (arg_entered)
	      usage();
	 else {
	      arg_entered++;
	      get++;
	 }
    }
    else
	 usage();
    ++optind;
    
    if (!arg_entered)
	usage();

    if (!keyfile[0])
	strcpy(keyfile, KEYFILE);
    
    strcpy(work_keyfile, keyfile);
    strcpy(backup_keyfile, keyfile);
    
    if (change || add || get) {
	strcat(work_keyfile, ".work");
	strcat(backup_keyfile, ".old");
	
	copy_keyfile(keyfile, backup_keyfile);
    }
    
    if (add || get)
	copy_keyfile(backup_keyfile, work_keyfile);

    keyfile_mode = get_mode(keyfile);

    if (change || list)
	if ((backup_keyfile_fd = open(backup_keyfile, O_RDONLY, 0)) < 0)
	    err (1, "open %s", backup_keyfile);

    if (change) {
	if ((work_keyfile_fd = 
	     open(work_keyfile, O_WRONLY | O_CREAT | O_TRUNC, 
		  SRVTAB_MODE)) < 0)
	    err (1, "creat %s", work_keyfile);
    }
    else if (add) {
	if ((work_keyfile_fd =
	     open(work_keyfile, O_APPEND | O_WRONLY, SRVTAB_MODE)) < 0)
	    err (1, "open with append %s", work_keyfile );
    }
    else if (get) {
	if ((work_keyfile_fd =
	     open(work_keyfile, O_RDWR | O_CREAT, SRVTAB_MODE)) < 0)
	    err (1, "open for writing %s", work_keyfile);
    }
    
    if (change || list) {
	while ((getst(backup_keyfile_fd, sname, SNAME_SZ) > 0) &&
	       (getst(backup_keyfile_fd, sinst, INST_SZ) > 0) &&
	       (getst(backup_keyfile_fd, srealm, REALM_SZ) > 0) &&
	       (read(backup_keyfile_fd, &key_vno, 1) > 0) &&
	       (read(backup_keyfile_fd, old_key, sizeof(old_key)) > 0)) {
	    if (list) {
		if (!first_printed) {
		    printf(VNO_HEADER);
		    printf(PAD);
		    if (key) {
			printf(KEY_HEADER);
			printf(PAD);
		    }
		    printf(PRINC_HEADER);
		    first_printed = 1;
		}
		printf(VNO_FORMAT, key_vno);
		printf(PAD);
		if (key) {
		    print_key(old_key);
		    printf(PAD);
		}
		print_name(sname, sinst, srealm);
		printf("\n");
	    }
	    else if (change) {
		snprintf(change_tkt, sizeof(change_tkt),
			 TKT_ROOT "_ksrvutil.%u",
			 (unsigned)getpid());
		krb_set_tkt_string(change_tkt);
		destroyp = TRUE;

		printf("\nPrincipal: ");
		print_name(sname, sinst, srealm);
		printf("; version %d\n", key_vno);
		if (interactive)
		    change_this_key = yn("Change this key?");
		else if (change)
		    change_this_key = 1;
		else
		    change_this_key = 0;
		
		if (change_this_key)
		    printf("Changing to version %d.\n", key_vno + 1);
		else if (change)
		    printf("Not changing this key.\n");
		
		if (change_this_key) {
		    /*
		     * This is not a good choice of seed when/if the
		     * key has been compromised so we also use a
		     * random sequence number!
		     */
		    des_init_random_number_generator(&old_key);
#if 0 /* kth-krb has own addidtions to libdes */
		    {
		        des_cblock seqnum;
			des_generate_random_block(&seqnum);
			des_set_sequence_number((unsigned char *)&seqnum);
		    }
#endif
		    /* 
		     * Pick a new key and determine whether or not
		     * it is safe to change
		     */
		    if ((status = 
			 get_svc_new_key(&new_key, sname, sinst, 
					 srealm, keyfile)) == KADM_SUCCESS)
			key_vno++;
		    else {
		        memcpy(new_key, old_key, sizeof(new_key));
			warnx ("Key NOT changed: %s\n",
			       krb_get_err_text(status));
			change_this_key = FALSE;
		    }
		}
		else 
		    memcpy(new_key, old_key, sizeof(new_key));
		append_srvtab(work_keyfile, work_keyfile_fd, 
			      sname, sinst, srealm, key_vno, new_key);
		if (key && change_this_key) {
		    printf("Old key: ");
		    print_key(old_key);
		    printf("; new key: ");
		    print_key(new_key);
		    printf("\n");
		}
		if (change_this_key) {
		    if ((status = kadm_change_pw(new_key)) == KADM_SUCCESS) {
			printf("Key changed.\n");
			dest_tkt();
		    }
		    else {
			com_err(progname, status, 
				" attempting to change password.");
			dest_tkt();
			/* XXX This knows the format of a keyfile */
			if (lseek(work_keyfile_fd, -9, SEEK_CUR) >= 0) {
			    key_vno--;
			    safe_write(work_keyfile,
				       work_keyfile_fd, &key_vno, 1);
			    safe_write(work_keyfile, work_keyfile_fd,
				       old_key, sizeof(des_cblock));
			    fsync(work_keyfile_fd);
			    fprintf(stderr,"Key NOT changed.\n");
			} else {
			    warn ("Unable to revert keyfile");
			    leave("", 1);
			}
		    }
		}
	    }
	    memset(old_key, 0, sizeof(des_cblock));
	    memset(new_key, 0, sizeof(des_cblock));
	}
    }
    else if (add) {
	do {
	    do {
		safe_read_stdin("Name: ", databuf, sizeof(databuf));
		strncpy(sname, databuf, sizeof(sname) - 1);
		sname[sizeof(sname) - 1] = '\0';
		if (strchr(sname, '.') != 0) {
		  strncpy(sinst, strchr(sname, '.') + 1, sizeof(sinst) - 1);
		  sinst[sizeof(sinst) - 1] = '\0';
		  *(strchr(sname, '.')) = 0;
		} else {
		  safe_read_stdin("Instance: ", databuf, sizeof(databuf));
		  strncpy(sinst, databuf, sizeof(sinst) - 1);
		  sinst[sizeof(sinst) - 1] = '\0';
		}
		safe_read_stdin("Realm: ", databuf, sizeof(databuf));
		strncpy(srealm, databuf, sizeof(srealm) - 1);
		srealm[sizeof(srealm) - 1] = '\0';
		safe_read_stdin("Version number: ", databuf, sizeof(databuf));
		key_vno = atoi(databuf);
		if (key_vno == 0)
		    key_vno = 1; /* Version numbers are never 0 */
		if (!srealm[0]) {
		    strncpy(srealm, local_realm, sizeof(srealm) - 1);
		    srealm[sizeof(srealm) - 1] = '\0';
		}
		printf("New principal: ");
		print_name(sname, sinst, srealm);
		printf("; version %d\n", key_vno);
	    } while (!yn("Is this correct?"));
	    get_key_from_password(&new_key, cellname);
	    if (key) {
		printf("Key: ");
		print_key(new_key);
		printf("\n");
	    }
	    append_srvtab(work_keyfile, work_keyfile_fd, 
			  sname, sinst, srealm, key_vno, new_key);
	    printf("Key successfully added.\n");
	} while (yn("Would you like to add another key?"));
    }
    else if (get) {
        ksrvutil_get(work_keyfile_fd, work_keyfile,
		     argc - optind, argv + optind);
    }

    if (change || list) 
	if (close(backup_keyfile_fd) < 0)
	    warn ("close %s", backup_keyfile);
    
    if (change || add || get) {
	if (close(work_keyfile_fd) < 0)
	    err (1, "close %s", work_keyfile);
	if (rename(work_keyfile, keyfile) < 0)
	    err (1, "rename(%s, %s)", work_keyfile, keyfile);
	chmod(backup_keyfile, keyfile_mode);
	chmod(keyfile, keyfile_mode);
	printf("Old keyfile in %s.\n", backup_keyfile);
    }
    return 0;
}
@


1.6
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: ksrvutil.c,v 1.5 1997/12/17 07:50:16 art Exp $	*/
@


1.5
log
@another upgrade.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d326 1
a326 1
    while((c = getopt(argc, argv, "ikc:f:p:r:")) != EOF) {
@


1.4
log
@add '-a' flag for afs string-to-key.
@
text
@d1 2
a2 1
/*	$Id: ksrvutil.c,v 1.3 1996/09/16 18:49:03 millert Exp $	*/
d4 2
a5 2
/*-
 * Copyright (C) 1989 by the Massachusetts Institute of Technology
d7 4
a10 4
 * Export of this software from the United States of America is assumed
 * to require a specific license from the United States Government.
 * It is the responsibility of any person or organization contemplating
 * export to obtain such a license before exporting.
d22 1
d34 1
a34 3
#ifndef FALSE
#define FALSE 0
#endif
d36 1
a36 6
#ifndef TRUE
#define TRUE 1
#endif

#include <kadm_locl.h>
#include <sys/param.h>
d52 8
d66 1
a66 1
    (void) bzero((char *)&statbuf, sizeof(statbuf));
d77 1
a77 1
copy_keyfile(char *progname, char *keyfile, char *backup_keyfile)
d86 1
a86 1
    (void) bzero((char *)buf, sizeof(buf));
d91 2
a92 5
	    if (errno != ENOENT) {
		(void)fprintf(stderr, "%s: Unable to read %s: %s\n", progname, 
			      keyfile, strerror(errno));
		exit(1);
	    }
d97 2
a98 5
			  O_WRONLY | O_TRUNC | O_CREAT, SRVTAB_MODE)) < 0) {
		    (void) fprintf(stderr, "%s: Unable to create %s: %s\n", 
				   progname, keyfile, strerror(errno));
		    exit(1);
		}
d100 2
a101 5
		    if (close(keyfile_fd) < 0) {
			(void) fprintf(stderr, "%s: Failure closing %s: %s\n",
				       progname, keyfile, strerror(errno));
			exit(1);
		    }
d110 2
a111 5
	      keyfile_mode)) < 0) {
	(void) fprintf(stderr, "%s: Unable to write %s: %s\n", progname, 
		       backup_keyfile, strerror(errno));
	exit(1);
    }
d113 4
a116 10
	if ((rcount = read(keyfile_fd, (char *)buf, sizeof(buf))) < 0) {
	    (void) fprintf(stderr, "%s: Error reading %s: %s\n", progname,
			   keyfile, strerror(errno));
	    exit(1);
	}
	if (rcount && (write(backup_keyfile_fd, buf, rcount) != rcount)) {
	    (void) fprintf(stderr, "%s: Error writing %s: %s\n", progname,
			   backup_keyfile, strerror(errno));
	    exit(1);
	}
d118 4
a121 10
    if (close(backup_keyfile_fd) < 0) {
	(void) fprintf(stderr, "%s: Error closing %s: %s\n", progname,
		       backup_keyfile, strerror(errno));
	exit(1);
    }
    if (close(keyfile_fd) < 0) {
	(void) fprintf(stderr, "%s: Error closing %s: %s\n", progname,
		       keyfile, strerror(errno));
	exit(1);
    }
d124 1
a124 1
static void
d128 3
a130 2
	(void) fprintf(stderr, "%s\n", str);
    (void) dest_tkt();
d134 2
a135 2
static void
safe_read_stdin(char *prompt, char *buf, int size)
d137 3
a139 3
    (void) printf(prompt);
    (void) fflush(stdout);
    (void) bzero(buf, size);
d141 2
a142 3
	(void) fprintf(stderr, "Failure reading from stdin: %s\n", 
		       strerror(errno));
	leave((char *)NULL, 1);
a143 1
    fflush(stdin);
d145 1
a145 2
}	
  
d147 2
a148 2
static void
safe_write(char *progname, char *filename, int fd, char *buf, int len)
d151 2
a152 3
	(void) fprintf(stderr, "%s: Failure writing to %s: %s\n", progname,
		       filename, strerror(errno));
	(void) close(fd);
d155 1
a155 1
}	
d158 1
a158 1
yn(char *string)
d160 18
a177 1
    char ynbuf[5];
d179 8
a186 13
    (void) printf("%s (y,n) [y] ", string);
    for (;;) {
	safe_read_stdin("", ynbuf, sizeof(ynbuf));
	
	if ((ynbuf[0] == 'n') || (ynbuf[0] == 'N'))
	    return(0);
	else if ((ynbuf[0] == 'y') || (ynbuf[0] == 'Y') || (ynbuf[0] == 0))
	    return(1);
	else {
	    (void) printf("Please enter 'y' or 'n': ");
	    fflush(stdout);
	}
    }
d190 1
a190 1
append_srvtab(char *progname, char *filename, int fd, char *sname, char *sinst, char *srealm, unsigned char key_vno, unsigned char *key)
d192 7
a198 7
    /* Add one to append null */
    safe_write(progname, filename, fd, sname, strlen(sname) + 1);
    safe_write(progname, filename, fd, sinst, strlen(sinst) + 1);
    safe_write(progname, filename, fd, srealm, strlen(srealm) + 1);
    safe_write(progname, filename, fd, (char *)&key_vno, 1);
    safe_write(progname, filename, fd, (char *)key, sizeof(des_cblock));
    (void) fsync(fd);
d207 2
a208 2
	(void) printf("%02x", key[i]);
    (void) printf(" ");
d210 1
a210 1
	(void) printf("%02x", key[i]);
d216 1
a216 2
    (void) printf("%s%s%s%s%s", name, inst[0] ? "." : "", inst,
		  realm[0] ? "@@" : "", realm);
d220 2
a221 1
get_svc_new_key(unsigned char *new_key, char *sname, char *sinst, char *srealm, char *keyfile)
d223 1
a223 2
    char *dot, admin[MAXHOSTNAMELEN];
    int status;
a224 5
    if ((status = krb_get_admhst(admin, srealm, 1)) != KSUCCESS)
	return(status);
    if ((dot = strchr(admin, '.')) != NULL)
	*dot = '\0';
    status = KADM_SUCCESS;
d227 1
a227 1
	((status = kadm_init_link("changepw", admin, srealm)) == 
d230 2
a231 2
	(void) bzero((char *) new_key, sizeof(des_cblock));
	new_key[0] = (unsigned char) 1;
d233 1
a233 1
	(void) des_new_random_key((des_cblock*)&new_key);
d242 1
a242 1
get_key_from_password(des_cblock (*key), int afskey, char *srealm)
a244 1
    char cell[REALM_SZ], *p;
d250 2
a251 2
    (void) bzero((char *) key, sizeof(des_cblock));
    key[0] = (unsigned char) 1;
d253 4
a256 8
    if (afskey) {
	strcpy(cell, srealm);
	for (p = cell; *p; p++)
	    if (isupper(*p))
		*p = tolower(*p);
	afs_string_to_key(password, cell, key);
    } else
	(void) des_string_to_key(password, key);
d258 1
a258 1
    (void) bzero((char *)password, sizeof(password));
d264 8
a271 7
    (void) fprintf(stderr, "Usage: ksrvutil [-f keyfile] [-i] [-k] [-a] ");
    (void) fprintf(stderr, "{list | change | add | get}\n");
    (void) fprintf(stderr, "   -i causes the program to ask for ");
    (void) fprintf(stderr, "confirmation before changing keys.\n");
    (void) fprintf(stderr, "   -k causes the key to printed for list or ");
    (void) fprintf(stderr, "change.\n");
    (void) fprintf(stderr, "   -a uses the AFS string-to-key.\n");
d293 2
a294 1
    int i;
a300 1
    int afskey = FALSE;		/* do we use AFS string-to-key? */
d306 13
a318 13
    (void) bzero((char *)sname, sizeof(sname));
    (void) bzero((char *)sinst, sizeof(sinst));
    (void) bzero((char *)srealm, sizeof(srealm));
    
    (void) bzero((char *)change_tkt, sizeof(change_tkt));
    (void) bzero((char *)keyfile, sizeof(keyfile));
    (void) bzero((char *)work_keyfile, sizeof(work_keyfile));
    (void) bzero((char *)backup_keyfile, sizeof(backup_keyfile));
    (void) bzero((char *)local_realm, sizeof(local_realm));
    
    (void) snprintf(change_tkt, sizeof(change_tkt), "/tmp/tkt_ksrvutil.%d",
		    (int)getpid());
    krb_set_tkt_string(change_tkt);
d322 2
a323 2
	(void) fprintf(stderr, "%s: Unable to find local realm name\n", argv[0]);
	exit(1);
d326 62
a387 47
    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-i") == 0) 
	    interactive++;
	else if (strcmp(argv[i], "-k") == 0) 
	    key++;
	else if (strcmp(argv[i], "list") == 0) {
	    if (arg_entered)
		usage();
	    else {
		arg_entered++;
		list++;
	    }
	}
	else if (strcmp(argv[i], "change") == 0) {
	    if (arg_entered)
		usage();
	    else {
		arg_entered++;
		change++;
	    }
	}
	else if (strcmp(argv[i], "add") == 0) {
	    if (arg_entered)
		usage();
	    else {
		arg_entered++;
		add++;
	    }
	}
	else if (strcmp(argv[i], "get") == 0) {
	    if (arg_entered)
		usage();
	    else {
		arg_entered++;
		get++;
	    }
	}
	else if (strcmp(argv[i], "-f") == 0) {
	    if (++i == argc)
		usage();
	    else
		(void) strcpy(keyfile, argv[i]);
	}
	else if (strcmp(argv[i], "-a") == 0) 
	    afskey++;
	else
	    usage();
d389 3
d397 1
a397 1
	(void) strcpy(keyfile, KEYFILE);
d399 2
a400 2
    (void) strcpy(work_keyfile, keyfile);
    (void) strcpy(backup_keyfile, keyfile);
d403 2
a404 2
	(void) strcat(work_keyfile, ".work");
	(void) strcat(backup_keyfile, ".old");
d406 1
a406 1
	copy_keyfile(argv[0], keyfile, backup_keyfile);
d410 1
a410 1
	copy_keyfile(argv[0], backup_keyfile, work_keyfile);
d414 3
a416 7
    if (change || list) {
	if ((backup_keyfile_fd = open(backup_keyfile, O_RDONLY, 0)) < 0) {
	    (void) fprintf(stderr, "%s: Unable to read %s: %s\n", argv[0],
			   backup_keyfile, strerror(errno));
	    exit(1);
	}
    }
d421 7
a427 5
		  SRVTAB_MODE)) < 0) {
	    (void) fprintf(stderr, "%s: Unable to write %s: %s\n", argv[0],
			   work_keyfile, strerror(errno));
	    exit(1);
	}
d429 1
a429 1
    else if (add || get) {
d431 2
a432 5
	     open(work_keyfile, O_APPEND | O_WRONLY, SRVTAB_MODE)) < 0) {
	    (void) fprintf(stderr, "%s: Unable to open %s for append: %s\n",
			   argv[0], work_keyfile, strerror(errno));
	    exit(1);
	}
d440 1
a440 1
	       (read(backup_keyfile_fd,(char *)old_key,sizeof(old_key)) > 0)) {
d443 2
a444 2
		    (void) printf(VNO_HEADER);
		    (void) printf(PAD);
d446 2
a447 2
			(void) printf(KEY_HEADER);
			(void) printf(PAD);
d449 1
a449 1
		    (void) printf(PRINC_HEADER);
d452 2
a453 2
		(void) printf(VNO_FORMAT, key_vno);
		(void) printf(PAD);
d456 1
a456 1
		    (void) printf(PAD);
d459 1
a459 1
		(void) printf("\n");
d462 7
a468 1
		(void) printf("\nPrincipal: ");
d470 1
a470 1
		(void) printf("; version %d\n", key_vno);
d479 1
a479 1
		    (void) printf("Changing to version %d.\n", key_vno + 1);
d481 1
a481 1
		    (void) printf("Not changing this key.\n");
d484 5
a488 1
		    /* Initialize non shared random sequence old key. */
d490 7
a496 1
		    
d502 1
a502 1
			 get_svc_new_key(new_key, sname, sinst, 
d506 3
a508 3
			(void) bcopy(old_key, new_key, sizeof(new_key));
			(void) fprintf(stderr, "%s: Key NOT changed: %s\n",
				       argv[0], krb_err_txt[status]);
d513 2
a514 2
		    (void) bcopy(old_key, new_key, sizeof(new_key));
		append_srvtab(argv[0], work_keyfile, work_keyfile_fd, 
d517 1
a517 1
		    (void) printf("Old key: ");
d519 1
a519 1
		    (void) printf("; new key: ");
d521 1
a521 1
		    (void) printf("\n");
d525 2
a526 2
			(void) printf("Key changed.\n");
			(void) dest_tkt();
d529 1
a529 1
			com_err(argv[0], status, 
d531 1
a531 1
			(void) dest_tkt();
d535 8
a542 11
			    safe_write(argv[0], work_keyfile,
				       work_keyfile_fd, (char *)&key_vno, 1);
			    safe_write(argv[0], work_keyfile, work_keyfile_fd,
				       (char *)old_key, sizeof(des_cblock));
			    (void) fsync(work_keyfile_fd);
			    (void) fprintf(stderr,"Key NOT changed.\n");
			}
			else {
			    (void)fprintf(stderr, 
					  "%s: Unable to revert keyfile: %s\n",
					  argv[0], strerror(errno));
d548 2
a549 2
	    bzero((char *)old_key, sizeof(des_cblock));
	    bzero((char *)new_key, sizeof(des_cblock));
d556 11
a566 3
		(void) strncpy(sname, databuf, sizeof(sname) - 1);
		safe_read_stdin("Instance: ", databuf, sizeof(databuf));
		(void) strncpy(sinst, databuf, sizeof(sinst) - 1);
d568 2
a569 1
		(void) strncpy(srealm, databuf, sizeof(srealm) - 1);
d572 7
a578 3
		if (!srealm[0])
		    (void) strcpy(srealm, local_realm);
		(void) printf("New principal: ");
d580 1
a580 1
		(void) printf("; version %d\n", key_vno);
d582 1
a582 1
	    get_key_from_password(&new_key, afskey, srealm);
d584 1
a584 1
		(void) printf("Key: ");
d586 1
a586 1
		(void) printf("\n");
d588 1
a588 1
	    append_srvtab(argv[0], work_keyfile, work_keyfile_fd, 
d590 1
a590 1
	    (void) printf("Key successfully added.\n");
d594 2
a595 1
        ksrvutil_get();
d599 2
a600 5
	if (close(backup_keyfile_fd) < 0) {
	    (void) fprintf(stderr, "%s: Failure closing %s: %s\n",
			   argv[0], backup_keyfile, strerror(errno));
	    (void) fprintf(stderr, "continuing...\n");
	}
d603 7
a609 14
	if (close(work_keyfile_fd) < 0) {
	    (void) fprintf(stderr, "%s: Failure closing %s: %s\n",
			   argv[0], work_keyfile, strerror(errno));
	    exit(1);
	}
	if (rename(work_keyfile, keyfile) < 0) {
	    (void) fprintf(stderr, "%s: Failure renaming %s to %s: %s\n",
			   argv[0], work_keyfile, keyfile, 
			   strerror(errno));
	    exit(1);
	}
	(void) chmod(backup_keyfile, keyfile_mode);
	(void) chmod(keyfile, keyfile_mode);
	(void) printf("Old keyfile in %s.\n", backup_keyfile);
d611 1
a611 42

    exit(0);
}

ksrvutil_get()
{
  char sname[ANAME_SZ];		/* name of service */
  char sinst[INST_SZ];		/* instance of service */
  char srealm[REALM_SZ];	/* realm of service */
  char databuf[BUFSIZ];
  char local_realm[REALM_SZ];	/* local kerberos realm */
  char local_hostname[100];

  if (krb_get_lrealm(local_realm, 1) != KSUCCESS)
    strcpy(local_realm, "");
  gethostname(local_hostname, sizeof(local_hostname));
  strcpy(local_hostname, krb_get_phost(local_hostname));
  do {
    do {
      safe_read_stdin("Name [rcmd]: ", databuf, sizeof(databuf));
      if (databuf[0])
	strncpy(sname, databuf, sizeof(sname) - 1);
      else
	strcpy(sname, "rcmd");

      safe_read_stdin("Instance [hostname]: ", databuf, sizeof(databuf));
      if (databuf[0])
	strncpy(sinst, databuf, sizeof(sinst) - 1);
      else
	strcpy(sinst, local_hostname);

      safe_read_stdin("Realm [localrealm]: ", databuf, sizeof(databuf));
      if (databuf[0])
	strncpy(srealm, databuf, sizeof(srealm) - 1);
      else
	strcpy(srealm, local_realm);

      printf("New principal: ");
      print_name(sname, sinst, srealm);
    } while (!yn("Is this correct?"));
    printf("NOT adding anything!!! Key successfully added.\n");
  } while (yn("Would you like to add another key?"));
@


1.3
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$Id: ksrvutil.c,v 1.2 1995/12/14 08:43:56 tholo Exp $	*/
d260 1
a260 1
get_key_from_password(des_cblock (*key))
d263 1
d272 8
a279 1
    (void) des_string_to_key(password, key);
d287 1
a287 1
    (void) fprintf(stderr, "Usage: ksrvutil [-f keyfile] [-i] [-k] ");
d293 1
d322 1
d391 2
d565 1
a565 1
	    get_key_from_password(&new_key);
@


1.2
log
@Do not use hardcoded realm or host names
@
text
@d1 1
a1 1
/*	$Id: ksrvutil.c,v 1.1.1.1 1995/12/14 06:52:53 tholo Exp $	*/
d328 2
a329 1
    (void) sprintf(change_tkt, "/tmp/tkt_ksrvutil.%d", (int)getpid());
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id$	*/
d235 2
a236 1
    int status = KADM_SUCCESS;
d238 5
d245 1
a245 1
	((status = kadm_init_link("changepw", KRB_MASTER, srealm)) == 
d332 4
a335 2
    if (krb_get_lrealm(local_realm, 1) != KSUCCESS)
	(void) strcpy(local_realm, KRB_REALM);
d604 1
a604 1
    strcpy(local_realm, KRB_REALM);
@


1.1.1.1
log
@Kerberos IV code, based on a merge of fixed code from KTH and original
4.4BSD Lite code (international edition).  Provides all functionality
from the original 4.4BSD code plus standard Kerberos elements that were
omitted in the 4.4BSD code.
@
text
@@
