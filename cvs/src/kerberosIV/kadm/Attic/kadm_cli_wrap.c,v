head	1.8;
access;
symbols
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	initial:1.1.1.1
	KTH/tholo:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2000.02.25.15.14.48;	author hin;	state dead;
branches;
next	1.7;

1.7
date	99.03.03.08.41.27;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	98.08.16.02.42.05;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.12.15.17.56.17;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.12.12.10.48.17;	author art;	state Exp;
branches;
next	1.3;

1.3
date	97.12.01.04.46.58;	author art;	state Exp;
branches;
next	1.2;

1.2
date	96.09.16.03.16.27;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.06.52.45;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.14.06.52.45;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Remove old KerberosIV code. (art@@ ok)
@
text
@/*	$OpenBSD: kadm_cli_wrap.c,v 1.7 1999/03/03 08:41:27 csapuntz Exp $	*/
/*	$KTH: kadm_cli_wrap.c,v 1.22 1997/08/17 07:30:04 assar Exp $	*/

/*
 * This source code is no longer held under any constraint of USA
 * `cryptographic laws' since it was exported legally.  The cryptographic
 * functions were removed from the code and a "Bones" distribution was
 * made.  A Commodity Jurisdiction Request #012-94 was filed with the
 * USA State Department, who handed it to the Commerce department.  The
 * code was determined to fall under General License GTDA under ECCN 5D96G,
 * and hence exportable.  The cryptographic interfaces were re-added by Eric
 * Young, and then KTH proceeded to maintain the code in the free world.
 *
 */

/* 
  Copyright (C) 1989 by the Massachusetts Institute of Technology

   Export of this software from the United States of America is assumed
   to require a specific license from the United States Government.
   It is the responsibility of any person or organization contemplating
   export to obtain such a license before exporting.

WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
distribute this software and its documentation for any purpose and
without fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation, and that
the name of M.I.T. not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.  M.I.T. makes no representations about the suitability of
this software for any purpose.  It is provided "as is" without express
or implied warranty.

  */

/*
 * Kerberos administration server client-side routines
 */

/*
 * kadm_cli_wrap.c the client side wrapping of the calls to the admin server 
 */

#include "kadm_locl.h"

#ifndef NULL
#define NULL 0
#endif

static Kadm_Client client_parm;

/* Macros for use in returning data... used in kadm_cli_send */
#define RET_N_FREE(r) {clear_secrets(); free((char *)act_st); act_st = NULL; free((char *)priv_pak); priv_pak = NULL; return r;}

/* Keys for use in the transactions */
static des_cblock sess_key;	       /* to be filled in by kadm_cli_keyd */
static des_key_schedule sess_sched;

static void
clear_secrets(void)
{
    memset(sess_key, 0, sizeof(sess_key));
    memset(sess_sched, 0, sizeof(sess_sched));
}

static void (*opipe)();

static void
kadm_cli_disconn(void)
{
    close(client_parm.admin_fd);
    signal(SIGPIPE, opipe);
}

/*
 * kadm_init_link
 *	receives    : name, inst, realm
 *
 * initializes client parm, the Kadm_Client structure which holds the 
 * data about the connection between the server and client, the services 
 * used, the locations and other fun things 
 */

int
kadm_init_link(char *n, char *i, char *r)
{
    struct hostent *hop;	       /* host we will talk to */
    char adm_hostname[MAXHOSTNAMELEN];
    
    init_kadm_err_tbl();
    init_krb_err_tbl();
    strncpy(client_parm.sname, n, ANAME_SZ - 1);
    client_parm.sname[ANAME_SZ - 1] = '\0';
    strncpy(client_parm.sinst, i, INST_SZ - 1);
    client_parm.sinst[INST_SZ - 1] = '\0';
    strncpy(client_parm.krbrlm, r, REALM_SZ - 1);
    client_parm.krbrlm[REALM_SZ - 1] = '\0';
    client_parm.admin_fd = -1;
    
    /* set up the admin_addr - fetch name of admin host */
    if (krb_get_admhst(adm_hostname, client_parm.krbrlm, 1) != KSUCCESS)
	return KADM_NO_HOST;
    if ((hop = gethostbyname(adm_hostname)) == NULL)
	return KADM_UNK_HOST;
    memset(&client_parm.admin_addr, 0, sizeof(client_parm.admin_addr));
    client_parm.admin_addr.sin_port = 
	k_getportbyname(KADM_SNAME, "tcp", htons(KADM_PORT));
    client_parm.admin_addr.sin_family = hop->h_addrtype;
    memcpy(&client_parm.admin_addr.sin_addr, hop->h_addr,
	   sizeof(client_parm.admin_addr.sin_addr));
    
    return KADM_SUCCESS;
}

static int
kadm_cli_conn(void)
{					/* this connects and sets my_addr */
    int on = 1;
    
    if ((client_parm.admin_fd =
	 socket(client_parm.admin_addr.sin_family, SOCK_STREAM,0)) < 0)
	return KADM_NO_SOCK;		/* couldnt create the socket */

    if (connect(client_parm.admin_fd,
		(struct sockaddr *) & client_parm.admin_addr,
		sizeof(client_parm.admin_addr))) {
	close(client_parm.admin_fd);
	client_parm.admin_fd = -1;
	return KADM_NO_CONN;		/* couldnt get the connect */
    }

    opipe = signal(SIGPIPE, SIG_IGN);

    client_parm.my_addr_len = sizeof(client_parm.my_addr);
    if (getsockname(client_parm.admin_fd,
		    (struct sockaddr *) & client_parm.my_addr,
		    &client_parm.my_addr_len) < 0) {
	close(client_parm.admin_fd);
	client_parm.admin_fd = -1;
	signal(SIGPIPE, opipe);
	return KADM_NO_HERE;		/* couldnt find out who we are */
    }

    if (setsockopt(client_parm.admin_fd, SOL_SOCKET, SO_KEEPALIVE,
		   (void *)&on,
		   sizeof(on)) < 0) {
	close(client_parm.admin_fd);
	client_parm.admin_fd = -1;
	signal(SIGPIPE, opipe);
	return KADM_NO_CONN;		/* XXX */
    }

    return KADM_SUCCESS;
}

/* takes in the sess_key and key_schedule and sets them appropriately */
static int
kadm_cli_keyd(des_cblock (*s_k), struct des_ks_struct *s_s)
                			       /* session key */
                                               /* session key schedule */
{
    CREDENTIALS cred;	       /* to get key data */
    int stat;

    /* want .sname and .sinst here.... */
    if ((stat = krb_get_cred(client_parm.sname, client_parm.sinst,
			     client_parm.krbrlm, &cred)))
	return stat + krb_err_base;
    memcpy(s_k, cred.session, sizeof(des_cblock));
    memset(cred.session, 0, sizeof(des_cblock));
#ifdef NOENCRYPTION
    memset(s_s, 0, sizeof(des_key_schedule));
#else
    if ((stat = des_key_sched(s_k,s_s)))
	return(stat+krb_err_base);
#endif
    return KADM_SUCCESS;
}				       /* This code "works" */

static int
kadm_cli_out(u_char *dat, int dat_len, u_char **ret_dat, int *ret_siz)
{
    u_int16_t dlen;
    int retval;
    char tmp[4];

    dlen = (u_int16_t) dat_len;

    if (dat_len != (int)dlen)
	return (KADM_NO_ROOM);

    tmp[0] = (dlen >> 8) & 0xff;
    tmp[1] = dlen & 0xff;
    if (krb_net_write(client_parm.admin_fd, tmp, 2) != 2)
	return (errno);	       /* XXX */

    if (krb_net_write(client_parm.admin_fd, (char *) dat, dat_len) < 0)
	return (errno);	       /* XXX */

	
    if ((retval = krb_net_read(client_parm.admin_fd, tmp, 2)) != 2){
	if (retval < 0)
	    return(errno);		/* XXX */
	else
	    return(EPIPE);		/* short read ! */
    }
    dlen = (tmp[0] << 8) | tmp[1];

    *ret_dat = (u_char *)malloc((unsigned)dlen);
    if (*ret_dat == NULL)
	return(KADM_NOMEM);

    if ((retval = krb_net_read(client_parm.admin_fd,  *ret_dat,
			       dlen) != dlen)) {
	if (retval < 0)
	    return(errno);		/* XXX */
	else
	    return(EPIPE);		/* short read ! */
    }
    *ret_siz = (int) dlen;
    return KADM_SUCCESS;
}

/*
 * kadm_cli_send
 *	recieves   : opcode, packet, packet length, serv_name, serv_inst
 *	returns    : return code from the packet build, the server, or
 *			 something else 
 *
 * It assembles a packet as follows:
 *	 8 bytes    : VERSION STRING
 *	 4 bytes    : LENGTH OF MESSAGE DATA and OPCODE
 *		    : KTEXT
 *		    : OPCODE       \
 *		    : DATA          > Encrypted (with make priv)
 *		    : ......       / 
 *
 * If it builds the packet and it is small enough, then it attempts to open the
 * connection to the admin server.  If the connection is succesfully open
 * then it sends the data and waits for a reply. 
 */
static int
kadm_cli_send(u_char *st_dat, int st_siz, u_char **ret_dat, int *ret_siz)
               				/* the actual data */
           				/* length of said data */
                 			/* to give return info */
             				/* length of returned info */
{
    int act_len, retdat;	       /* current offset into packet, return
				        * data */
    KTEXT_ST authent;	       /* the authenticator we will build */
    u_char *act_st;		       /* the pointer to the complete packet */
    u_char *temp;
    u_char *priv_pak;	       /* private version of the packet */
    int priv_len;		       /* length of private packet */
    u_int32_t cksum;		       /* checksum of the packet */
    MSG_DAT mdat;
    u_char *return_dat;

    act_st = (u_char *) malloc(KADM_VERSIZE); /* verstr stored first */
    if (act_st == NULL) {
	clear_secrets();
	return KADM_NOMEM;
    }
    
    strncpy((char *)act_st, KADM_VERSTR, KADM_VERSIZE);
    act_len = KADM_VERSIZE;

    if ((retdat = kadm_cli_keyd(&sess_key, sess_sched)) != KADM_SUCCESS) {
	free(act_st);
	act_st = NULL;
	clear_secrets();
	return retdat;	       /* couldnt get key working */
    }

    priv_pak = (u_char *) malloc((unsigned)(st_siz + 200));
    if (priv_pak == NULL) {
	free(act_st);
	act_st = NULL;
	clear_secrets();
	return KADM_NOMEM;
    }

    /* 200 bytes for extra info case */
    if ((priv_len = krb_mk_priv(st_dat, priv_pak, (u_int32_t)st_siz,
				sess_sched, &sess_key, &client_parm.my_addr,
				&client_parm.admin_addr)) < 0)
	RET_N_FREE(KADM_NO_ENCRYPT);	/* whoops... we got a lose
					 * here */

    /* here is the length of priv data.  receiver calcs
       size of authenticator by subtracting vno size, priv size, and
       sizeof(u_int32_t) (for the size indication) from total size */

    act_len += vts_long((u_int32_t) priv_len, &act_st, act_len);
#ifdef NOENCRYPTION
    cksum = 0;
#else
    cksum = des_quad_cksum((des_cblock *)priv_pak, (des_cblock *)0,
			   (long)priv_len, 0, &sess_key);
#endif
    if ((retdat = krb_mk_req(&authent, client_parm.sname, client_parm.sinst,
			     client_parm.krbrlm, cksum))) {
	/* authenticator? */
	RET_N_FREE(retdat + krb_err_base);
    }

    temp = (u_char *) realloc(act_st,
				act_len + authent.length + priv_len);
    if (temp == NULL) {
	clear_secrets();
	free(priv_pak);
	free(act_st);
	priv_pak = NULL;
	return KADM_NOMEM;
    }
    act_st = temp;

    memcpy((char *)act_st + act_len, authent.dat, authent.length);
    memcpy((char *)act_st + act_len + authent.length, priv_pak, priv_len);
    free(priv_pak);
    priv_pak = NULL;

    if ((retdat = kadm_cli_out(act_st,
			       act_len + authent.length + priv_len,
			       ret_dat, ret_siz)) != KADM_SUCCESS)
	RET_N_FREE(retdat);
    free(act_st);
    act_st = NULL;
#define RET_N_FREE2(r) {free(*ret_dat); *ret_dat = NULL; *ret_siz = 0; clear_secrets(); return(r);}

    /* first see if it's a YOULOUSE */
    if ((*ret_siz >= KADM_VERSIZE) &&
	!strncmp(KADM_ULOSE, (char *)*ret_dat, KADM_VERSIZE)) {
	unsigned char *p;
	/* it's a youlose packet */
	if (*ret_siz < KADM_VERSIZE + 4)
	    RET_N_FREE2(KADM_BAD_VER);
	p = (*ret_dat)+KADM_VERSIZE;
	retdat = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
	RET_N_FREE2(retdat);
    }
    /* need to decode the ret_dat */
    if ((retdat = krb_rd_priv(*ret_dat, (u_int32_t)*ret_siz, sess_sched,
			      &sess_key, &client_parm.admin_addr,
			      &client_parm.my_addr, &mdat)))
	RET_N_FREE2(retdat+krb_err_base);
    if (mdat.app_length < KADM_VERSIZE + 4)
	/* too short! */
	RET_N_FREE2(KADM_BAD_VER);
    if (strncmp((char *)mdat.app_data, KADM_VERSTR, KADM_VERSIZE))
	/* bad version */
	RET_N_FREE2(KADM_BAD_VER);
    {
	unsigned char *p = mdat.app_data+KADM_VERSIZE;
	retdat = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
    }
    {
	int s=mdat.app_length - KADM_VERSIZE - 4;
	if(s<=0) s=1;
	if (!(return_dat = (u_char *)malloc(s)))
	    RET_N_FREE2(KADM_NOMEM);
    }
    memcpy(return_dat,
	   (char *) mdat.app_data + KADM_VERSIZE + 4,
	   mdat.app_length - KADM_VERSIZE - 4);
    free(*ret_dat);
    *ret_dat = NULL;
    clear_secrets();
    *ret_dat = return_dat;
    *ret_siz = mdat.app_length - KADM_VERSIZE - 4;
    return retdat;
}



/* 
 * kadm_change_pw_plain
 *
 * see kadm_change_pw
 *
 */
int kadm_change_pw_plain(unsigned char *newkey, char *password, char **pw_msg)
{
    int stsize, retc;	       /* stream size and return code */
    u_char *send_st;	       /* send stream */
    u_char *temp;
    u_char *ret_st;
    int ret_sz;
    int status;
    static char msg[128];

    if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	return retc ;
    /* possible problem with vts_long on a non-multiple of four boundary */

    stsize = 0;		       /* start of our output packet */
    send_st = (u_char *) malloc(1);/* to make it reallocable */
    if (send_st == NULL)
	return KADM_NOMEM;

    send_st[stsize++] = (u_char) CHANGE_PW;

    /* change key to stream */

    temp = realloc(send_st, stsize + 8);
    if (temp == NULL) {
        free(send_st);
	return KADM_NOMEM;
    }
    send_st = temp;

    memcpy(send_st + stsize + 4, newkey, 4); /* yes, this is backwards */
    memcpy(send_st + stsize, newkey + 4, 4);
    stsize += 8;
	
    if(password != NULL && password[0] != '\0')
	stsize += vts_string(password, &send_st, stsize);

    retc = kadm_cli_send(send_st, stsize, &ret_st, &ret_sz);
    free(send_st);
    send_st = NULL;
	
    if(retc != KADM_SUCCESS){
	status = stv_string(ret_st, msg, 0, sizeof(msg), ret_sz);
	if(status<0)
	    msg[0]=0;
	*pw_msg=msg;
    }

    if (ret_st != NULL) {
	free(ret_st);
	ret_st = NULL;
    }
	
    kadm_cli_disconn();
    return(retc);
}

/*
 * This function is here for compatibility with CNS
 */

int kadm_change_pw2(unsigned char *newkey, char *password, char **pw_msg)
{
    return kadm_change_pw_plain (newkey, password, pw_msg);
}


/*
 * kadm_change_pw
 * recieves    : key 
 *
 * Replaces the password (i.e. des key) of the caller with that specified in
 * key. Returns no actual data from the master server, since this is called
 * by a user 
 */

int kadm_change_pw(unsigned char *newkey)
{
    char *pw_msg;
    return kadm_change_pw_plain(newkey, "", &pw_msg);
}

/*
 * kadm_add
 * 	receives    : vals
 * 	returns     : vals 
 *
 * Adds and entry containing values to the database returns the values of the
 * entry, so if you leave certain fields blank you will be able to determine
 * the default values they are set to 
 */
int
kadm_add(Kadm_vals *vals)
{
    u_char *st, *st2;	       /* st will hold the stream of values */
    int st_len;		       /* st2 the final stream with opcode */
    int retc;		       /* return code from call */
    u_char *ret_st;
    int ret_sz;

    if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	return(retc);
    st_len = vals_to_stream(vals, &st);
    st2 = (u_char *) malloc((unsigned)(1 + st_len));
    if (st2 == NULL)
	return KADM_NOMEM;
    
    *st2 = (u_char) ADD_ENT;       /* here's the opcode */
    memcpy((char *) st2 + 1, st, st_len);	/* append st on */
    retc = kadm_cli_send(st2, st_len + 1, &ret_st, &ret_sz);
    free(st);
    st = NULL;
    free(st2);
    st2 = NULL;

    if (retc == KADM_SUCCESS) {
	/* ret_st has vals */
	if (stream_to_vals(ret_st, vals, ret_sz) < 0)
	    retc = KADM_LENGTH_ERROR;
	free(ret_st);
	ret_st = NULL;
    }
    kadm_cli_disconn();
    return(retc);
}

/*
 * kadm_mod
 * 	receives    : KTEXT, {values, values}
 *	returns     : CKSUM,  RETCODE, {values} 
 *	acl         : su, sms (as register or dealloc) 
 *
 * Modifies all entries corresponding to the first values so they match the
 * second values. returns the values for the changed entries in vals2
 */
int
kadm_mod(Kadm_vals *vals1, Kadm_vals *vals2)
{
    u_char *st, *st2;	       /* st will hold the stream of values */
    int st_len, nlen;	       /* st2 the final stream with opcode */
    u_char *ret_st;
    u_char *temp;
    int ret_sz;

    /* nlen is the length of second vals */
    int retc;		       /* return code from call */

    if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	return(retc);

    st_len = vals_to_stream(vals1, &st);
    st2 = (u_char *) malloc((unsigned)(1 + st_len));
    if (st2 == NULL)
	return KADM_NOMEM;
    
    *st2 = (u_char) MOD_ENT;       /* here's the opcode */
    memcpy((char *)st2 + 1, st, st_len++); /* append st on */
    free(st);
    st = NULL;

    nlen = vals_to_stream(vals2, &st);
    temp = (u_char *) realloc((char *) st2, (unsigned)(st_len + nlen));
    if (temp == NULL) {
         free(st2);
	 return KADM_NOMEM;
    }
    st2 = temp;
        
    memcpy((char *) st2 + st_len, st, nlen); /* append st on */
    retc = kadm_cli_send(st2, st_len + nlen, &ret_st, &ret_sz);

    free(st);
    st = NULL;
    free(st2);
    st2 = NULL;

    if (retc == KADM_SUCCESS) {
	/* ret_st has vals */
	if (stream_to_vals(ret_st, vals2, ret_sz) < 0)
	    retc = KADM_LENGTH_ERROR;
	free(ret_st);
	ret_st = NULL;
    }
    kadm_cli_disconn();
    return retc;
}


int
kadm_del(Kadm_vals *vals)
{
    unsigned char *st, *st2;	       /* st will hold the stream of values */
    int st_len;		       /* st2 the final stream with opcode */
    int retc;		       /* return code from call */
    u_char *ret_st;
    int ret_sz;
    
    if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	return retc;
    st_len = vals_to_stream(vals, &st);
    st2 = (unsigned char *) malloc(st_len + 1);
    if (st2 == NULL)
	return KADM_NOMEM;

    *st2 = DEL_ENT;       /* here's the opcode */
    memcpy(st2 + 1, st, st_len);	/* append st on */
    retc = kadm_cli_send(st2, st_len + 1, &ret_st, &ret_sz);
    free(st);
    st = NULL;
    free(st2);
    st2 = NULL;
    kadm_cli_disconn();
    return(retc);
}


/*
 * kadm_get
 * 	receives   : KTEXT, {values, flags} 
 *	returns    : CKSUM, RETCODE, {count, values, values, values}
 *	acl        : su 
 *
 * gets the fields requested by flags from all entries matching values returns
 * this data for each matching recipient, after a count of how many such
 * matches there were 
 */
int
kadm_get(Kadm_vals *vals, u_char *fl)
{
    int loop;		       /* for copying the fields data */
    u_char *st, *st2;	       /* st will hold the stream of values */
    int st_len;		       /* st2 the final stream with opcode */
    int retc;		       /* return code from call */
    u_char *ret_st;
    int ret_sz;

    if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	return(retc);
    st_len = vals_to_stream(vals, &st);
    st2 = (u_char *) malloc((unsigned)(1 + st_len + FLDSZ));
    if (st2 == NULL)
	return KADM_NOMEM;

    *st2 = (u_char) GET_ENT;       /* here's the opcode */
    memcpy((char *)st2 + 1, st, st_len); /* append st on */
    for (loop = FLDSZ - 1; loop >= 0; loop--)
	*(st2 + st_len + FLDSZ - loop) = fl[loop]; /* append the flags */
    retc = kadm_cli_send(st2, st_len + 1 + FLDSZ,  &ret_st, &ret_sz);
    free(st);
    st = NULL;
    free(st2);
    st2 = NULL;
    if (retc == KADM_SUCCESS) {
	/* ret_st has vals */
	if (stream_to_vals(ret_st, vals, ret_sz) < 0)
	    retc = KADM_LENGTH_ERROR;
	free(ret_st);
	ret_st = NULL;
    }
    kadm_cli_disconn();
    return(retc);
}
@


1.7
log
@

If ret_size !=0 on return, a seg fault could ensue in some of the clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: kadm_cli_wrap.c,v 1.6 1998/08/16 02:42:05 art Exp $	*/
@


1.6
log
@realloc fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: kadm_cli_wrap.c,v 1.5 1997/12/15 17:56:17 art Exp $	*/
d331 1
a331 1
#define RET_N_FREE2(r) {free(*ret_dat); *ret_dat = NULL; clear_secrets(); return(r);}
@


1.5
log
@Upgrades, sanity checks, cleanup, etc.
@
text
@d1 14
a14 2
/*	$OpenBSD: kadm_cli_wrap.c,v 1.4 1997/12/12 10:48:17 art Exp $	*/
/* $KTH: kadm_cli_wrap.c,v 1.22 1997/08/17 07:30:04 assar Exp $ */
d254 1
d309 1
a309 1
    act_st = (u_char *) realloc(act_st,
d311 1
a311 1
    if (act_st == NULL) {
d314 1
d318 2
d388 1
d407 3
a409 2
    send_st = realloc(send_st, stsize + 8);
    if (send_st == NULL)
d411 2
d525 1
d545 7
a551 1
    st2 = (u_char *) realloc((char *) st2, (unsigned)(st_len + nlen));
@


1.4
log
@clean up, check pointer, remove strcpys, etc..
I should really get a monkey to do these things.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
#define RET_N_FREE(r) {clear_secrets(); free((char *)act_st); free((char *)priv_pak); return r;}
d84 1
a84 1
    client_parm.sname[ANAME_SZ - 1] = '\0';
d254 1
a254 2
    strncpy((char *)act_st, KADM_VERSTR, KADM_VERSIZE - 1);
    act_st[KADM_VERSIZE - 1] = '\0';
d315 1
a315 1
#define RET_N_FREE2(r) {free(*ret_dat); clear_secrets(); return(r);}
d353 1
a353 1
    ret_dat = NULL;
@


1.3
log
@Another minimal upgrade to kth-krb4-0.9.7.
@
text
@d1 1
d51 2
a52 3
	memset(sess_key, 0, sizeof(sess_key));
	memset(sess_sched, 0, sizeof(sess_sched));
	return;
a61 1
    return;
d76 26
a101 23
	struct hostent *hop;	       /* host we will talk to */
	char adm_hostname[MAXHOSTNAMELEN];

	init_kadm_err_tbl();
	init_krb_err_tbl();
	strcpy(client_parm.sname, n);
	strcpy(client_parm.sinst, i);
	strcpy(client_parm.krbrlm, r);
	client_parm.admin_fd = -1;

	/* set up the admin_addr - fetch name of admin host */
	if (krb_get_admhst(adm_hostname, client_parm.krbrlm, 1) != KSUCCESS)
		return KADM_NO_HOST;
	if ((hop = gethostbyname(adm_hostname)) == NULL)
		return KADM_UNK_HOST;
	memset(&client_parm.admin_addr, 0, sizeof(client_parm.admin_addr));
	client_parm.admin_addr.sin_port = 
	  k_getportbyname(KADM_SNAME, "tcp", htons(KADM_PORT));
	client_parm.admin_addr.sin_family = hop->h_addrtype;
	memcpy(&client_parm.admin_addr.sin_addr, hop->h_addr,
	       sizeof(client_parm.admin_addr.sin_addr));

	return KADM_SUCCESS;
d108 1
a108 1

d112 1
d120 1
d122 1
d132 1
d141 1
d149 1
a149 1
                     		       /* session key schedule */
d151 2
a152 2
	CREDENTIALS cred;	       /* to get key data */
	int stat;
d154 6
a159 6
	/* want .sname and .sinst here.... */
	if ((stat = krb_get_cred(client_parm.sname, client_parm.sinst,
				client_parm.krbrlm, &cred)))
		return stat + krb_err_base;
	memcpy(s_k, cred.session, sizeof(des_cblock));
	memset(cred.session, 0, sizeof(des_cblock));
d161 1
a161 1
	memset(s_s, 0, sizeof(des_key_schedule));
d163 2
a164 2
	if ((stat = des_key_sched(s_k,s_s)))
		return(stat+krb_err_base);
d166 1
a166 1
	return KADM_SUCCESS;
d172 13
a184 13
	u_int16_t dlen;
	int retval;
	char tmp[4];

	dlen = (u_int16_t) dat_len;

	if (dat_len != (int)dlen)
		return (KADM_NO_ROOM);

	tmp[0] = (dlen >> 8) & 0xff;
	tmp[1] = dlen & 0xff;
	if (krb_net_write(client_parm.admin_fd, tmp, 2) != 2)
	    return (errno);	       /* XXX */
d186 2
a187 2
	if (krb_net_write(client_parm.admin_fd, (char *) dat, dat_len) < 0)
		return (errno);	       /* XXX */
d190 21
a210 21
	if ((retval = krb_net_read(client_parm.admin_fd, tmp, 2)) != 2){
	    if (retval < 0)
		return(errno);		/* XXX */
	    else
		return(EPIPE);		/* short read ! */
	}
	dlen = (tmp[0] << 8) | tmp[1];

	*ret_dat = (u_char *)malloc((unsigned)dlen);
	if (!*ret_dat)
	    return(KADM_NOMEM);

	if ((retval = krb_net_read(client_parm.admin_fd,  *ret_dat,
				  dlen) != dlen)) {
	    if (retval < 0)
		return(errno);		/* XXX */
	    else
		return(EPIPE);		/* short read ! */
	}
	*ret_siz = (int) dlen;
	return KADM_SUCCESS;
d238 1
a238 1
	int act_len, retdat;	       /* current offset into packet, return
d240 7
a246 26
	KTEXT_ST authent;	       /* the authenticator we will build */
	u_char *act_st;		       /* the pointer to the complete packet */
	u_char *priv_pak;	       /* private version of the packet */
	int priv_len;		       /* length of private packet */
	u_int32_t cksum;		       /* checksum of the packet */
	MSG_DAT mdat;
	u_char *return_dat;

	act_st = (u_char *) malloc(KADM_VERSIZE); /* verstr stored first */
	strncpy((char *)act_st, KADM_VERSTR, KADM_VERSIZE);
	act_len = KADM_VERSIZE;

	if ((retdat = kadm_cli_keyd(&sess_key, sess_sched)) != KADM_SUCCESS) {
		free(act_st);
		return retdat;	       /* couldnt get key working */
	}
	priv_pak = (u_char *) malloc((unsigned)(st_siz + 200));
	/* 200 bytes for extra info case */
	if ((priv_len = krb_mk_priv(st_dat, priv_pak, (u_int32_t)st_siz,
				    sess_sched, &sess_key, &client_parm.my_addr,
				    &client_parm.admin_addr)) < 0)
		RET_N_FREE(KADM_NO_ENCRYPT);	/* whoops... we got a lose
						 * here */
	/* here is the length of priv data.  receiver calcs
	 size of authenticator by subtracting vno size, priv size, and
	 sizeof(u_int32_t) (for the size indication) from total size */
d248 37
a284 1
	act_len += vts_long((u_int32_t) priv_len, &act_st, act_len);
d286 1
a286 1
	cksum = 0;
d288 2
a289 2
	cksum = des_quad_cksum((des_cblock *)priv_pak, (des_cblock *)0, (long)priv_len, 0,
			   &sess_key);
d291 10
a300 15
	if ((retdat = krb_mk_req(&authent, client_parm.sname, client_parm.sinst,
				client_parm.krbrlm, cksum))) {
	    /* authenticator? */
	    RET_N_FREE(retdat + krb_err_base);
	}

	act_st = (u_char *) realloc(act_st,
				    act_len + authent.length + priv_len);
	if (!act_st) {
	    clear_secrets();
	    free(priv_pak);
	    return(KADM_NOMEM);
	}
	memcpy((char *)act_st + act_len, authent.dat, authent.length);
	memcpy((char *)act_st + act_len + authent.length, priv_pak, priv_len);
d302 14
a315 5
	if ((retdat = kadm_cli_out(act_st,
				   act_len + authent.length + priv_len,
				   ret_dat, ret_siz)) != KADM_SUCCESS)
	    RET_N_FREE(retdat);
	free(act_st);
d318 6
a323 18
	/* first see if it's a YOULOUSE */
	if ((*ret_siz >= KADM_VERSIZE) &&
	    !strncmp(KADM_ULOSE, (char *)*ret_dat, KADM_VERSIZE)) {
	    unsigned char *p;
	    /* it's a youlose packet */
	    if (*ret_siz < KADM_VERSIZE + 4)
		RET_N_FREE2(KADM_BAD_VER);
	    p = (*ret_dat)+KADM_VERSIZE;
	    retdat = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
	    RET_N_FREE2(retdat);
	}
	/* need to decode the ret_dat */
	if ((retdat = krb_rd_priv(*ret_dat, (u_int32_t)*ret_siz, sess_sched,
				 &sess_key, &client_parm.admin_addr,
				 &client_parm.my_addr, &mdat)))
	    RET_N_FREE2(retdat+krb_err_base);
	if (mdat.app_length < KADM_VERSIZE + 4)
	    /* too short! */
d325 23
a347 11
	if (strncmp((char *)mdat.app_data, KADM_VERSTR, KADM_VERSIZE))
	    /* bad version */
	    RET_N_FREE2(KADM_BAD_VER);
	{
	    unsigned char *p = mdat.app_data+KADM_VERSIZE;
	    retdat = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
	}
	{
	  int s=mdat.app_length - KADM_VERSIZE - 4;
	  if(s<=0) s=1;
	  if (!(return_dat = (u_char *)malloc(s)))
d349 10
a358 9
	}
	memcpy(return_dat,
	       (char *) mdat.app_data + KADM_VERSIZE + 4,
	       mdat.app_length - KADM_VERSIZE - 4);
	free(*ret_dat);
	clear_secrets();
	*ret_dat = return_dat;
	*ret_siz = mdat.app_length - KADM_VERSIZE - 4;
	return retdat;
d371 27
a397 21
	int stsize, retc;	       /* stream size and return code */
	u_char *send_st;	       /* send stream */
	u_char *ret_st;
	int ret_sz;
	int status;
	static char msg[128];

	if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	    return(retc);
	/* possible problem with vts_long on a non-multiple of four boundary */

	stsize = 0;		       /* start of our output packet */
	send_st = (u_char *) malloc(1);/* to make it reallocable */
	send_st[stsize++] = (u_char) CHANGE_PW;

	/* change key to stream */

	send_st = realloc(send_st, stsize + 8);
	memcpy(send_st + stsize + 4, newkey, 4); /* yes, this is backwards */
	memcpy(send_st + stsize, newkey + 4, 4);
	stsize += 8;
d399 2
a400 2
	if(password && *password)
	  stsize += vts_string(password, &send_st, stsize);
d402 3
a404 2
	retc = kadm_cli_send(send_st, stsize, &ret_st, &ret_sz);
	free(send_st);
d406 3
a408 3
	if(retc != KADM_SUCCESS){
	  status = stv_string(ret_st, msg, 0, sizeof(msg), ret_sz);
	  if(status<0)
d410 2
a411 2
	  *pw_msg=msg;
	}
d413 4
a416 2
	if (ret_st)
	    free(ret_st);
d418 2
a419 2
	kadm_cli_disconn();
	return(retc);
d443 2
a444 2
  char *pw_msg;
  return kadm_change_pw_plain(newkey, "", &pw_msg);
d459 7
a465 22
	u_char *st, *st2;	       /* st will hold the stream of values */
	int st_len;		       /* st2 the final stream with opcode */
	int retc;		       /* return code from call */
	u_char *ret_st;
	int ret_sz;

	if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	    return(retc);
	st_len = vals_to_stream(vals, &st);
	st2 = (u_char *) malloc((unsigned)(1 + st_len));
	*st2 = (u_char) ADD_ENT;       /* here's the opcode */
	memcpy((char *) st2 + 1, st, st_len);	/* append st on */
	retc = kadm_cli_send(st2, st_len + 1, &ret_st, &ret_sz);
	free(st);
	free(st2);
	if (retc == KADM_SUCCESS) {
	    /* ret_st has vals */
	    if (stream_to_vals(ret_st, vals, ret_sz) < 0)
		retc = KADM_LENGTH_ERROR;
	    free(ret_st);
	}
	kadm_cli_disconn();
d467 22
d503 9
a511 29
	u_char *st, *st2;	       /* st will hold the stream of values */
	int st_len, nlen;	       /* st2 the final stream with opcode */
	u_char *ret_st;
	int ret_sz;

	/* nlen is the length of second vals */
	int retc;		       /* return code from call */

	if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	    return(retc);

	st_len = vals_to_stream(vals1, &st);
	st2 = (u_char *) malloc((unsigned)(1 + st_len));
	*st2 = (u_char) MOD_ENT;       /* here's the opcode */
	memcpy((char *)st2 + 1, st, st_len++); /* append st on */
	free(st);
	nlen = vals_to_stream(vals2, &st);
	st2 = (u_char *) realloc((char *) st2, (unsigned)(st_len + nlen));
	memcpy((char *) st2 + st_len, st, nlen); /* append st on */
	retc = kadm_cli_send(st2, st_len + nlen, &ret_st, &ret_sz);
	free(st);
	free(st2);
	if (retc == KADM_SUCCESS) {
	    /* ret_st has vals */
	    if (stream_to_vals(ret_st, vals2, ret_sz) < 0)
		retc = KADM_LENGTH_ERROR;
	    free(ret_st);
	}
	kadm_cli_disconn();
d513 30
d556 1
a556 1
	return(retc);
d559 3
d566 1
d568 1
d587 8
a594 25
	int loop;		       /* for copying the fields data */
	u_char *st, *st2;	       /* st will hold the stream of values */
	int st_len;		       /* st2 the final stream with opcode */
	int retc;		       /* return code from call */
	u_char *ret_st;
	int ret_sz;

	if ((retc = kadm_cli_conn()) != KADM_SUCCESS)
	    return(retc);
	st_len = vals_to_stream(vals, &st);
	st2 = (u_char *) malloc((unsigned)(1 + st_len + FLDSZ));
	*st2 = (u_char) GET_ENT;       /* here's the opcode */
	memcpy((char *)st2 + 1, st, st_len); /* append st on */
	for (loop = FLDSZ - 1; loop >= 0; loop--)
		*(st2 + st_len + FLDSZ - loop) = fl[loop]; /* append the flags */
	retc = kadm_cli_send(st2, st_len + 1 + FLDSZ,  &ret_st, &ret_sz);
	free(st);
	free(st2);
	if (retc == KADM_SUCCESS) {
	    /* ret_st has vals */
	    if (stream_to_vals(ret_st, vals, ret_sz) < 0)
		retc = KADM_LENGTH_ERROR;
	    free(ret_st);
	}
	kadm_cli_disconn();
d596 23
@


1.2
log
@Fix warnings
@
text
@d1 1
a1 1
/*	$Id: kadm_cli_wrap.c,v 1.1.1.1 1995/12/14 06:52:45 tholo Exp $	*/
d3 20
a22 20
/*-
 * Copyright (C) 1989 by the Massachusetts Institute of Technology
 *
 * Export of this software from the United States of America is assumed
 * to require a specific license from the United States Government.
 * It is the responsibility of any person or organization contemplating
 * export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 */
d32 1
a32 1
#include "kadm_local.h"
d48 1
a48 1
clear_secrets()
d50 2
a51 2
	bzero((char *)sess_key, sizeof(sess_key));
	bzero((char *)sess_sched, sizeof(sess_sched));
d58 1
a58 1
kadm_cli_disconn()
d60 2
a61 2
    (void) close(client_parm.admin_fd);
    (void) signal(SIGPIPE, opipe);
d73 1
d75 1
a75 4
kadm_init_link(n, i, r)
	char *n;
	char *i;
	char *r;
a76 1
	struct servent *sep;	       /* service we will talk to */
d80 5
a84 5
	(void) init_kadm_err_tbl();
	(void) init_krb_err_tbl();
	(void) strcpy(client_parm.sname, n);
	(void) strcpy(client_parm.sinst, i);
	(void) strcpy(client_parm.krbrlm, r);
d91 4
a94 6
		return KADM_UNK_HOST;  /* couldnt find the admin servers
				        * address */
	if ((sep = getservbyname(KADM_SNAME, "tcp")) == NULL)
		return KADM_NO_SERV;   /* couldnt find the admin service */
	bzero((char *) &client_parm.admin_addr,
	      sizeof(client_parm.admin_addr));
d96 2
a97 3
	bcopy((char *) hop->h_addr, (char *) &client_parm.admin_addr.sin_addr,
	      hop->h_length);
	client_parm.admin_addr.sin_port = sep->s_port;
d100 1
a100 1
}				       /* procedure kadm_init_link */
d103 1
a103 1
kadm_cli_conn()
d113 1
a113 1
	(void) close(client_parm.admin_fd);
d122 1
a122 1
	(void) close(client_parm.admin_fd);
d124 1
a124 1
	(void) signal(SIGPIPE, opipe);
d127 2
a128 1
    if (setsockopt(client_parm.admin_fd, SOL_SOCKET, SO_KEEPALIVE, &on,
d130 1
a130 1
	(void) close(client_parm.admin_fd);
d132 1
a132 1
	(void) signal(SIGPIPE, opipe);
d140 3
a142 3
kadm_cli_keyd(s_k, s_s)
	des_cblock *s_k;	/* session key */
	struct des_ks_struct *s_s; /* session key schedule */
d151 2
a152 2
	bcopy((char *) cred.session, (char *) s_k, sizeof(des_cblock));
	bzero((char *) cred.session, sizeof(des_cblock));
d154 1
a154 1
	bzero(s_s, sizeof(des_key_schedule));
d163 1
a163 5
kadm_cli_out(dat, dat_len, ret_dat, ret_siz)
	u_char *dat;
	int dat_len;
	u_char **ret_dat;
	int *ret_siz;
d165 1
a165 1
	u_short dlen;
d167 1
d169 1
a169 1
	dlen = (u_short) dat_len;
d174 4
a177 4
	dlen = htons(dlen);
	if (krb_net_write(client_parm.admin_fd, (char *) &dlen,
			  sizeof(u_short)) < 0)
		return (errno);	       /* XXX */
d182 2
a183 2
	if ((retval = krb_net_read(client_parm.admin_fd, (char *) &dlen,
				  sizeof(u_short)) != sizeof(u_short))) {
d189 1
a190 1
	dlen = ntohs(dlen);
d195 2
a196 2
	if ((retval = krb_net_read(client_parm.admin_fd, (char *) *ret_dat,
				  (int) dlen) != dlen)) {
d225 5
a229 5
kadm_cli_send(st_dat, st_siz, ret_dat, ret_siz)
	u_char *st_dat;		/* the actual data */
	int st_siz;		/* length of said data */
	u_char **ret_dat;	/* to give return info */
	int *ret_siz;		/* length of returned info */
d242 1
a242 1
	(void) strncpy((char *)act_st, KADM_VERSTR, KADM_VERSIZE);
d245 2
a246 2
	if ((retdat = kadm_cli_keyd((des_cblock *)&sess_key, sess_sched)) != KADM_SUCCESS) {
		free((char *)act_st);
d268 1
a268 1
				client_parm.krbrlm, (long)cksum))) {
d273 2
a274 3
	act_st = (u_char *) realloc((char *) act_st,
				    (unsigned) (act_len + authent.length
						+ priv_len));
d277 1
a277 1
	    free((char *)priv_pak);
d280 3
a282 4
	bcopy((char *) authent.dat, (char *) act_st + act_len, authent.length);
	bcopy((char *) priv_pak, (char *) act_st + act_len + authent.length,
	      priv_len);
	free((char *)priv_pak);
d287 2
a288 2
	free((char *)act_st);
#define RET_N_FREE2(r) {free((char *)*ret_dat); clear_secrets(); return(r);}
d293 1
a293 1
	    u_int32_t errcode;
d295 1
a295 1
	    if (*ret_siz < KADM_VERSIZE + sizeof(u_int32_t))
d297 2
a298 3
	    bcopy((char *)(*ret_dat) + KADM_VERSIZE, (char *)&errcode,
		  sizeof(u_int32_t));
	    retdat = (int) ntohl(errcode);
d312 8
a319 5
	bcopy((char *)mdat.app_data+KADM_VERSIZE,
	      (char *)&retdat, sizeof(u_int32_t));
	retdat = ntohl((u_int32_t)retdat);
	if (!(return_dat = (u_char *)malloc((unsigned)(mdat.app_length -
					    KADM_VERSIZE - sizeof(u_int32_t)))))
d321 5
a325 4
	bcopy((char *) mdat.app_data + KADM_VERSIZE + sizeof(u_int32_t),
	      (char *)return_dat,
	      (int)mdat.app_length - KADM_VERSIZE - sizeof(u_int32_t));
	free((char *)*ret_dat);
d328 1
a328 1
	*ret_siz = mdat.app_length - KADM_VERSIZE - sizeof(u_int32_t);
d332 6
a337 3
/*
 * kadm_change_pw
 * recieves    : key 
a338 3
 * Replaces the password (i.e. des key) of the caller with that specified in
 * key. Returns no actual data from the master server, since this is called
 * by a user 
d340 1
a340 3
int
kadm_change_pw(newkey)
	unsigned char *newkey;	/* The DES form of the users key */
d346 2
a347 1
	u_int32_t keytmp;
d359 4
a362 7
	bcopy((char *) (((long *) newkey) + 1), (char *) &keytmp, 4);
	keytmp = htonl(keytmp);
	stsize += vts_long(keytmp, &send_st, stsize);

	bcopy((char *) newkey, (char *) &keytmp, 4);
	keytmp = htonl(keytmp);
	stsize += vts_long(keytmp, &send_st, stsize);
d364 3
d368 7
a374 3
	free((char *)send_st);
	if (retc == KADM_SUCCESS) {
	    free((char *)ret_st);
d376 4
d385 25
d419 1
a419 2
kadm_add(vals)
	Kadm_vals *vals;
d432 1
a432 1
	bcopy((char *) st, (char *) st2 + 1, st_len);	/* append st on */
d434 2
a435 2
	free((char *)st);
	free((char *)st2);
d440 1
a440 1
	    free((char *)ret_st);
d456 1
a456 3
kadm_mod(vals1, vals2)
	Kadm_vals *vals1;
	Kadm_vals *vals2;
d472 2
a473 2
	bcopy((char *) st, (char *) st2 + 1, st_len++);	/* append st on */
	free((char *)st);
d476 1
a476 1
	bcopy((char *) st, (char *) st2 + st_len, nlen); /* append st on */
d478 2
a479 2
	free((char *)st);
	free((char *)st2);
d484 1
a484 1
	    free((char *)ret_st);
d490 24
d525 1
a525 3
kadm_get(vals, fl)
	Kadm_vals *vals;
	u_char *fl;
d539 1
a539 1
	bcopy((char *) st, (char *) st2 + 1, st_len);	/* append st on */
d543 2
a544 2
	free((char *)st);
	free((char *)st2);
d549 1
a549 1
	    free((char *)ret_st);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id$	*/
d253 1
a253 1
	if ((retdat = kadm_cli_keyd(&sess_key, sess_sched)) != KADM_SUCCESS) {
@


1.1.1.1
log
@Kerberos IV code, based on a merge of fixed code from KTH and original
4.4BSD Lite code (international edition).  Provides all functionality
from the original 4.4BSD code plus standard Kerberos elements that were
omitted in the 4.4BSD code.
@
text
@@
