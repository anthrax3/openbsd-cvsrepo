head	1.4;
access;
symbols
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	initial:1.1.1.1
	KTH/tholo:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2000.02.25.15.14.50;	author hin;	state dead;
branches;
next	1.3;

1.3
date	97.12.15.17.56.21;	author art;	state Exp;
branches;
next	1.2;

1.2
date	96.09.16.18.48.49;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.06.52.49;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.14.06.52.49;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Remove old KerberosIV code. (art@@ ok)
@
text
@/*	$OpenBSD: kadm_funcs.c,v 1.3 1997/12/15 17:56:21 art Exp $	*/
/* $KTH: kadm_funcs.c,v 1.16 1997/05/02 14:28:49 assar Exp $ */

/* 
  Copyright (C) 1989 by the Massachusetts Institute of Technology

   Export of this software from the United States of America is assumed
   to require a specific license from the United States Government.
   It is the responsibility of any person or organization contemplating
   export to obtain such a license before exporting.

WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
distribute this software and its documentation for any purpose and
without fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation, and that
the name of M.I.T. not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.  M.I.T. makes no representations about the suitability of
this software for any purpose.  It is provided "as is" without express
or implied warranty.

*/

/*
 * Kerberos administration server-side database manipulation routines
 */

/*
 * kadm_funcs.c
 * the actual database manipulation code
 */

#include "kadm_locl.h"

static int
check_access(char *pname, char *pinst, char *prealm, enum acl_types acltype)
{
    char checkname[MAX_K_NAME_SZ];
    char filename[MAXPATHLEN];

    snprintf(checkname, sizeof(checkname), "%s.%s@@%s", pname, pinst, prealm);
    
    switch (acltype) {
    case ADDACL:
	snprintf(filename, sizeof(filename), "%s%s", acldir, ADD_ACL_FILE);
	break;
    case GETACL:
	snprintf(filename, sizeof(filename), "%s%s", acldir, GET_ACL_FILE);
	break;
    case MODACL:
	snprintf(filename, sizeof(filename), "%s%s", acldir, MOD_ACL_FILE);
	break;
    case DELACL:
	snprintf(filename, sizeof(filename), "%s%s", acldir, DEL_ACL_FILE);
	break;
    default:
	krb_log("WARNING in check_access: default case in switch");
	return 0;
    }
    return(acl_check(filename, checkname));
}

static int
wildcard(char *str)
{
    if (!strcmp(str, WILDCARD_STR))
	return(1);
    return(0);
}

static int
fail(int code, char *oper, char *princ)
{
    krb_log("ERROR: %s: %s (%s)", oper, princ, error_message(code));
    return code;
}

#define failadd(code) { fail(code, "ADD", victim); return code; }
#define faildelete(code) { fail(code, "DELETE", victim); return code; }
#define failget(code) { fail(code, "GET", victim); return code; }
#define failmod(code) { fail(code, "MOD", victim); return code; }
#define failchange(code) { fail(code, "CHANGE", admin); return code; }

int
kadm_add_entry (char *rname, char *rinstance, char *rrealm, 
		Kadm_vals *valsin, Kadm_vals *valsout)
{
    long numfound;		/* check how many we get written */
    int more;			/* pointer to more grabbed records */
    Principal data_i, data_o;		/* temporary principal */
    u_char flags[4];
    des_cblock newpw;
    Principal default_princ;
  
    char admin[MAX_K_NAME_SZ], victim[MAX_K_NAME_SZ];

    strncpy(admin, 
	    krb_unparse_name_long(rname, rinstance, rrealm), 
	    MAX_K_NAME_SZ -1);
    admin[MAX_K_NAME_SZ -1] = '\0';

    strncpy(victim, 
	    krb_unparse_name_long(valsin->name, valsin->instance, NULL),
	    MAX_K_NAME_SZ -1);
    victim[MAX_K_NAME_SZ -1] = '\0';

    krb_log("ADD: %s by %s", victim, admin);

    if (!check_access(rname, rinstance, rrealm, ADDACL)) {
	krb_log("WARNING: ADD: %s permission denied", admin);
	return KADM_UNAUTH;
    }
  
    /* Need to check here for "legal" name and instance */
    if (wildcard(valsin->name) || wildcard(valsin->instance)) {
	failadd(KADM_ILL_WILDCARD);
    }

    numfound = kerb_get_principal(KERB_DEFAULT_NAME, KERB_DEFAULT_INST,
				  &default_princ, 1, &more);
    if (numfound == -1) {
	failadd(KADM_DB_INUSE);
    } else if (numfound != 1) {
	failadd(KADM_UK_RERROR);
    }

    kadm_vals_to_prin(valsin->fields, &data_i, valsin);
    strncpy(data_i.name, valsin->name, ANAME_SZ - 1);
    data_i.name[ANAME_SZ - 1] = '\0';
    strncpy(data_i.instance, valsin->instance, INST_SZ - 1);
    data_i.instance[INST_SZ - 1] = '\0';

    if (!IS_FIELD(KADM_EXPDATE,valsin->fields))
	data_i.exp_date = default_princ.exp_date;
    if (!IS_FIELD(KADM_ATTR,valsin->fields))
	data_i.attributes = default_princ.attributes;
    if (!IS_FIELD(KADM_MAXLIFE,valsin->fields))
	data_i.max_life = default_princ.max_life; 

    memset(&default_princ, 0, sizeof(default_princ));

    /* convert to host order */
    data_i.key_low = ntohl(data_i.key_low);
    data_i.key_high = ntohl(data_i.key_high);


    copy_to_key(&data_i.key_low, &data_i.key_high, newpw);

    /* encrypt new key in master key */
    kdb_encrypt_key (&newpw, &newpw, &server_parm.master_key,
		     server_parm.master_key_schedule, DES_ENCRYPT);
    copy_from_key(newpw, &data_i.key_low, &data_i.key_high);
    memset(newpw, 0, sizeof(newpw));

    data_o = data_i;
    numfound = kerb_get_principal(valsin->name, valsin->instance, 
				  &data_o, 1, &more);
    if (numfound == -1) {
	failadd(KADM_DB_INUSE);
    } else if (numfound) {
	failadd(KADM_INUSE);
    } else {
	data_i.key_version++;
	data_i.kdc_key_ver = server_parm.master_key_version;
	strncpy(data_i.mod_name, rname, sizeof(data_i.mod_name) - 1);
	data_i.mod_name[sizeof(data_i.mod_name) - 1] = '\0';
	strncpy(data_i.mod_instance, rinstance,
		sizeof(data_i.mod_instance) - 1);
	data_i.mod_instance[sizeof(data_i.mod_instance - 1)] = '\0';

	numfound = kerb_put_principal(&data_i, 1);
	if (numfound == -1) {
	    failadd(KADM_DB_INUSE);
	} else if (numfound) {
	    failadd(KADM_UK_SERROR);
	} else {
	    numfound = kerb_get_principal(valsin->name, valsin->instance, 
					  &data_o, 1, &more);
	    if ((numfound!=1) || (more!=0)) {
		failadd(KADM_UK_RERROR);
	    }
	    memset(flags, 0, sizeof(flags));
	    SET_FIELD(KADM_NAME,flags);
	    SET_FIELD(KADM_INST,flags);
	    SET_FIELD(KADM_EXPDATE,flags);
	    SET_FIELD(KADM_ATTR,flags);
	    SET_FIELD(KADM_MAXLIFE,flags);
	    kadm_prin_to_vals(flags, valsout, &data_o);
	    krb_log("ADD: %s added", victim);
	    return KADM_DATA;		/* Set all the appropriate fields */
	}
    }
}

int
kadm_delete_entry (char *rname, char *rinstance, char *rrealm, 
		   Kadm_vals *valsin)
{
    int ret;

    char admin[MAX_K_NAME_SZ], victim[MAX_K_NAME_SZ];
    
    strncpy(admin,
	    krb_unparse_name_long(rname, rinstance, rrealm),
	    MAX_K_NAME_SZ - 1);
    admin[MAX_K_NAME_SZ - 1] = '\0';
    strncpy(victim,
	    krb_unparse_name_long(valsin->name, valsin->instance, NULL),
	    MAX_K_NAME_SZ - 1);
    victim[MAX_K_NAME_SZ - 1] = '\0';

    krb_log("DELETE: %s by %s", victim, admin);

    if (!check_access(rname, rinstance, rrealm, DELACL)) {
	krb_log("WARNING: DELETE: %s permission denied", admin);
	return KADM_UNAUTH;
    }
    
    /* Need to check here for "legal" name and instance */
    if (wildcard(valsin->name) || wildcard(valsin->instance)) {
	faildelete(KADM_ILL_WILDCARD);
    }
  
#define EQ(V,N,I) (strcmp((V)->name, (N)) == 0 && strcmp((V)->instance, (I)) == 0)

    if(EQ(valsin, PWSERV_NAME, KRB_MASTER) ||
       EQ(valsin, "K", "M") ||
       EQ(valsin, "default", "") ||
       EQ(valsin, KRB_TICKET_GRANTING_TICKET, server_parm.krbrlm)){
	krb_log("WARNING: DELETE: %s is immutable", victim);
	return KADM_IMMUTABLE; /* XXX */
    }
    
    ret = kerb_delete_principal(valsin->name, valsin->instance);
    if(ret == -1)
	return KADM_DB_INUSE; /* XXX */
    krb_log("DELETE: %s removed.", victim);
    return KADM_SUCCESS;
}


int
kadm_get_entry (char *rname, char *rinstance, char *rrealm, 
		Kadm_vals *valsin, u_char *flags, Kadm_vals *valsout)
{
    long numfound;		/* check how many were returned */
    int more;			/* To point to more name.instances */
    Principal data_o;		/* Data object to hold Principal */
    
    char admin[MAX_K_NAME_SZ], victim[MAX_K_NAME_SZ];
    
    strncpy(admin, 
	    krb_unparse_name_long(rname, rinstance, rrealm),
	    MAX_K_NAME_SZ - 1);
    admin[MAX_K_NAME_SZ - 1] = '\0';
    strncpy(victim,
	    krb_unparse_name_long(valsin->name, valsin->instance, NULL),
	    MAX_K_NAME_SZ - 1);
    victim[MAX_K_NAME_SZ - 1] = '\0';
    
    krb_log("GET: %s by %s", victim, admin);

    if (!check_access(rname, rinstance, rrealm, GETACL)) {
	krb_log("WARNING: GET: %s permission denied", admin);
	return KADM_UNAUTH;
    }
  
    if (wildcard(valsin->name) || wildcard(valsin->instance)) {
	failget(KADM_ILL_WILDCARD);
    }

    /* Look up the record in the database */
    numfound = kerb_get_principal(valsin->name, valsin->instance, 
				  &data_o, 1, &more);
    if (numfound == -1) {
	failget(KADM_DB_INUSE);
    }  else if (numfound) {	/* We got the record, let's return it */
	kadm_prin_to_vals(flags, valsout, &data_o);
	krb_log("GET: %s retrieved", victim);
	return KADM_DATA; /* Set all the appropriate fields */
    } else {
	failget(KADM_NOENTRY);	/* Else whimper and moan */
    }
}

int
kadm_mod_entry (char *rname, char *rinstance, char *rrealm, 
		Kadm_vals *valsin, Kadm_vals *valsin2, Kadm_vals *valsout)
{
    long numfound;
    int more;
    Principal data_o, temp_key;
    u_char fields[4];
    des_cblock newpw;

    char admin[MAX_K_NAME_SZ], victim[MAX_K_NAME_SZ];
    
    strncpy(admin, 
	    krb_unparse_name_long(rname, rinstance, rrealm),
	    MAX_K_NAME_SZ - 1);
    admin[MAX_K_NAME_SZ - 1] = '\0';
    strncpy(victim,
	    krb_unparse_name_long(valsin->name, valsin->instance, NULL),
	    MAX_K_NAME_SZ - 1);
    victim[MAX_K_NAME_SZ - 1] = '\0';

    
    krb_log("MOD: %s by %s", victim, admin);

    if (wildcard(valsin->name) || wildcard(valsin->instance)) {
	failmod(KADM_ILL_WILDCARD);
    }
  
    if (!check_access(rname, rinstance, rrealm, MODACL)) {
	krb_log("WARNING: MOD: %s permission denied", admin);
	return KADM_UNAUTH;
    }
    
    numfound = kerb_get_principal(valsin->name, valsin->instance, 
				  &data_o, 1, &more);
    if (numfound == -1) {
	failmod(KADM_DB_INUSE);
    } else if (numfound) {
	kadm_vals_to_prin(valsin2->fields, &temp_key, valsin2);
	strncpy(data_o.name, valsin->name, ANAME_SZ - 1);
	data_o.name[ANAME_SZ - 1] = '\0';
	strncpy(data_o.instance, valsin->instance, INST_SZ - 1);
	data_o.instance[INST_SZ - 1] = '\0';
	if (IS_FIELD(KADM_EXPDATE,valsin2->fields))
	    data_o.exp_date = temp_key.exp_date;
	if (IS_FIELD(KADM_ATTR,valsin2->fields))
	    data_o.attributes = temp_key.attributes;
	if (IS_FIELD(KADM_MAXLIFE,valsin2->fields))
	    data_o.max_life = temp_key.max_life; 
	if (IS_FIELD(KADM_DESKEY,valsin2->fields)) {
	    data_o.key_version++;
	    data_o.kdc_key_ver = server_parm.master_key_version;


	    /* convert to host order */
	    temp_key.key_low = ntohl(temp_key.key_low);
	    temp_key.key_high = ntohl(temp_key.key_high);


	    copy_to_key(&temp_key.key_low, &temp_key.key_high, newpw);

	    /* encrypt new key in master key */
	    kdb_encrypt_key (&newpw, &newpw, &server_parm.master_key,
			     server_parm.master_key_schedule, DES_ENCRYPT);
	    copy_from_key(newpw, &data_o.key_low, &data_o.key_high);
	    memset(newpw, 0, sizeof(newpw));
	}
	memset(&temp_key, 0, sizeof(temp_key));

	strncpy(data_o.mod_name, rname, sizeof(data_o.mod_name)-1);
	data_o.mod_name[sizeof(data_o.mod_name) - 1] = '\0';
	strncpy(data_o.mod_instance, rinstance,
		sizeof(data_o.mod_instance)-1);
	data_o.mod_instance[sizeof(data_o.mod_instance) - 1] = '\0';
	more = kerb_put_principal(&data_o, 1);

	memset(&data_o, 0, sizeof(data_o));

	if (more == -1) {
	    failmod(KADM_DB_INUSE);
	} else if (more) {
	    failmod(KADM_UK_SERROR);
	} else {
	    numfound = kerb_get_principal(valsin->name, valsin->instance, 
					  &data_o, 1, &more);
	    if ((more!=0)||(numfound!=1)) {
		failmod(KADM_UK_RERROR);
	    }
	    memset(fields, 0, sizeof(fields));
	    SET_FIELD(KADM_NAME,fields);
	    SET_FIELD(KADM_INST,fields);
	    SET_FIELD(KADM_EXPDATE,fields);
	    SET_FIELD(KADM_ATTR,fields);
	    SET_FIELD(KADM_MAXLIFE,fields);
	    kadm_prin_to_vals(fields, valsout, &data_o);
	    krb_log("MOD: %s modified", victim);
	    return KADM_DATA;		/* Set all the appropriate fields */
	}
    }
    else {
	failmod(KADM_NOENTRY);
    }
}

int
kadm_change (char *rname, char *rinstance, char *rrealm, unsigned char *newpw)
{
    long numfound;
    int more;
    Principal data_o;
    des_cblock local_pw;

    char admin[MAX_K_NAME_SZ];
    
    strncpy(admin, 
	    krb_unparse_name_long(rname, rinstance, rrealm), 
	    MAX_K_NAME_SZ - 1);
    admin[MAX_K_NAME_SZ - 1] = '\0';
        
    krb_log("CHANGE: %s", admin);

    if (strcmp(server_parm.krbrlm, rrealm)) {
	krb_log("ERROR: CHANGE: request from wrong realm %s", rrealm);
	return(KADM_WRONG_REALM);
    }

    if (wildcard(rname) || wildcard(rinstance)) {
	failchange(KADM_ILL_WILDCARD);
    }

    memcpy(local_pw, newpw, sizeof(local_pw));
  
    /* encrypt new key in master key */
    kdb_encrypt_key (&local_pw, &local_pw, &server_parm.master_key,
		     server_parm.master_key_schedule, DES_ENCRYPT);

    numfound = kerb_get_principal(rname, rinstance, 
				  &data_o, 1, &more);
    if (numfound == -1) {
	failchange(KADM_DB_INUSE);
    } else if (numfound) {
	copy_from_key(local_pw, &data_o.key_low, &data_o.key_high);
	data_o.key_version++;
	data_o.kdc_key_ver = server_parm.master_key_version;
	strncpy(data_o.mod_name, rname, sizeof(data_o.mod_name)-1);
	data_o.mod_name[sizeof(data_o.mod_name) - 1] = '\0';
	strncpy(data_o.mod_instance, rinstance,
		sizeof(data_o.mod_instance)-1);
	data_o.mod_instance[sizeof(data_o.mod_instance) - 1] = '\0';
	more = kerb_put_principal(&data_o, 1);
	memset(local_pw, 0, sizeof(local_pw));
	memset(&data_o, 0, sizeof(data_o));
	if (more == -1) {
	    failchange(KADM_DB_INUSE);
	} else if (more) {
	    failchange(KADM_UK_SERROR);
	} else {
	    krb_log("CHANGE: %s's password changed", admin);
	    return KADM_SUCCESS;
	}
    }
    else {
	failchange(KADM_NOENTRY);
    }
}
@


1.3
log
@Upgrades, sanity checks, cleanup, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@sprintf -> snprintf paranoia
@
text
@d1 2
a2 1
/*	$Id: kadm_funcs.c,v 1.1.1.1 1995/12/14 06:52:49 tholo Exp $	*/
d4 20
a23 19
/*-
 * Copyright (C) 1989 by the Massachusetts Institute of Technology
 *
 * Export of this software from the United States of America is assumed
 * to require a specific license from the United States Government.
 * It is the responsibility of any person or organization contemplating
 * export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 */
d30 3
a32 3
kadm_funcs.c
the actual database manipulation code
*/
d34 1
a34 2
#include <kadm_locl.h>
#include <sys/param.h>
d42 1
a42 2
    (void) snprintf(checkname, sizeof(checkname), "%s.%s@@%s", pname, pinst,
		    prealm);
d46 1
a46 1
	(void) snprintf(filename, sizeof(filename), "%s%s", acldir, ADD_ACL_FILE);
d49 1
a49 1
	(void) snprintf(filename, sizeof(filename), "%s%s", acldir, GET_ACL_FILE);
d52 4
a55 1
	(void) snprintf(filename, sizeof(filename), "%s%s", acldir, MOD_ACL_FILE);
d57 3
d72 12
a83 1
#define failadd(code) {  (void) log("FAILED addding '%s.%s' (%s)", valsin->name, valsin->instance, error_message(code)); return code; }
d86 2
a87 6
kadm_add_entry (char *rname, char *rinstance, char *rrealm, Kadm_vals *valsin, Kadm_vals *valsout)
            				/* requestors name */
                			/* requestors instance */
             				/* requestors realm */
                  
                   
d89 6
a94 12
  long numfound;		/* check how many we get written */
  int more;			/* pointer to more grabbed records */
  Principal data_i, data_o;		/* temporary principal */
  u_char flags[4];
  des_cblock newpw;
  Principal default_princ;

  if (!check_access(rname, rinstance, rrealm, ADDACL)) {
    (void) log("WARNING: '%s.%s@@%s' tried to add an entry for '%s.%s'",
	       rname, rinstance, rrealm, valsin->name, valsin->instance);
    return KADM_UNAUTH;
  }
d96 1
a96 4
  /* Need to check here for "legal" name and instance */
  if (wildcard(valsin->name) || wildcard(valsin->instance)) {
      failadd(KADM_ILL_WILDCARD);
  }
d98 16
a113 2
  (void) log("request to add an entry for '%s.%s' from '%s.%s@@%s'",
		 valsin->name, valsin->instance, rname, rinstance, rrealm);
d115 12
a126 24
  numfound = kerb_get_principal(KERB_DEFAULT_NAME, KERB_DEFAULT_INST,
				&default_princ, 1, &more);
  if (numfound == -1) {
      failadd(KADM_DB_INUSE);
  } else if (numfound != 1) {
      failadd(KADM_UK_RERROR);
  }

  kadm_vals_to_prin(valsin->fields, &data_i, valsin);
  (void) strncpy(data_i.name, valsin->name, ANAME_SZ);
  (void) strncpy(data_i.instance, valsin->instance, INST_SZ);

  if (!IS_FIELD(KADM_EXPDATE,valsin->fields))
	  data_i.exp_date = default_princ.exp_date;
  if (!IS_FIELD(KADM_ATTR,valsin->fields))
      data_i.attributes = default_princ.attributes;
  if (!IS_FIELD(KADM_MAXLIFE,valsin->fields))
      data_i.max_life = default_princ.max_life; 

  bzero((char *)&default_princ, sizeof(default_princ));

  /* convert to host order */
  data_i.key_low = ntohl(data_i.key_low);
  data_i.key_high = ntohl(data_i.key_high);
d128 18
a146 2
  bcopy(&data_i.key_low,newpw,4);
  bcopy(&data_i.key_high,(char *)(((long *) newpw) + 1),4);
d148 4
a151 2
  /* encrypt new key in master key */
  kdb_encrypt_key (&newpw, &newpw, &server_parm.master_key,
d153 2
a154 17
  bcopy(newpw,&data_i.key_low,4);
  bcopy((char *)(((long *) newpw) + 1), &data_i.key_high,4);
  bzero((char *)newpw, sizeof(newpw));

  data_o = data_i;
  numfound = kerb_get_principal(valsin->name, valsin->instance, 
				&data_o, 1, &more);
  if (numfound == -1) {
      failadd(KADM_DB_INUSE);
  } else if (numfound) {
      failadd(KADM_INUSE);
  } else {
    data_i.key_version++;
    data_i.kdc_key_ver = server_parm.master_key_version;
    (void) strncpy(data_i.mod_name, rname, sizeof(data_i.mod_name)-1);
    (void) strncpy(data_i.mod_instance, rinstance,
		   sizeof(data_i.mod_instance)-1);
d156 3
a158 1
    numfound = kerb_put_principal(&data_i, 1);
d162 1
a162 1
	failadd(KADM_UK_SERROR);
d164 29
a192 14
      numfound = kerb_get_principal(valsin->name, valsin->instance, 
				    &data_o, 1, &more);
      if ((numfound!=1) || (more!=0)) {
	  failadd(KADM_UK_RERROR);
      }
      bzero((char *)flags, sizeof(flags));
      SET_FIELD(KADM_NAME,flags);
      SET_FIELD(KADM_INST,flags);
      SET_FIELD(KADM_EXPDATE,flags);
      SET_FIELD(KADM_ATTR,flags);
      SET_FIELD(KADM_MAXLIFE,flags);
      kadm_prin_to_vals(flags, valsout, &data_o);
      (void) log("'%s.%s' added.", valsin->name, valsin->instance);
      return KADM_DATA;		/* Set all the appropriate fields */
a193 1
  }
a194 3
#undef failadd

#define failget(code) {  (void) log("FAILED retrieving '%s.%s' (%s)", valsin->name, valsin->instance, error_message(code)); return code; }
d197 2
a198 7
kadm_get_entry (char *rname, char *rinstance, char *rrealm, Kadm_vals *valsin, u_char *flags, Kadm_vals *valsout)
            				/* requestors name */
                			/* requestors instance */
             				/* requestors realm */
                  			/* what they wannt to get */
              				/* which fields we want */
                   			/* what data is there */
d200 1
a200 3
  long numfound;		/* check how many were returned */
  int more;			/* To point to more name.instances */
  Principal data_o;		/* Data object to hold Principal */
d202 22
d225 1
a225 9
  if (!check_access(rname, rinstance, rrealm, GETACL)) {
    (void) log("WARNING: '%s.%s@@%s' tried to get '%s.%s's entry",
	    rname, rinstance, rrealm, valsin->name, valsin->instance);
    return KADM_UNAUTH;
  }
  
  if (wildcard(valsin->name) || wildcard(valsin->instance)) {
      failget(KADM_ILL_WILDCARD);
  }
d227 13
a239 15
  (void) log("retrieve '%s.%s's entry for '%s.%s@@%s'",
	     valsin->name, valsin->instance, rname, rinstance, rrealm);
  
  /* Look up the record in the database */
  numfound = kerb_get_principal(valsin->name, valsin->instance, 
				&data_o, 1, &more);
  if (numfound == -1) {
      failget(KADM_DB_INUSE);
  }  else if (numfound) {	/* We got the record, let's return it */
    kadm_prin_to_vals(flags, valsout, &data_o);
    (void) log("'%s.%s' retrieved.", valsin->name, valsin->instance);
    return KADM_DATA;		/* Set all the appropriate fields */
  } else {
      failget(KADM_NOENTRY);	/* Else whimper and moan */
  }
a240 1
#undef failget
a241 1
#define failmod(code) {  (void) log("FAILED modifying '%s.%s' (%s)", valsin1->name, valsin1->instance, error_message(code)); return code; }
d244 2
a245 7
kadm_mod_entry (char *rname, char *rinstance, char *rrealm, Kadm_vals *valsin1, Kadm_vals *valsin2, Kadm_vals *valsout)
            				/* requestors name */
                			/* requestors instance */
             				/* requestors realm */
                             		/* holds the parameters being
					   passed in */
                   		/* the actual record which is returned */
d247 21
a267 9
  long numfound;
  int more;
  Principal data_o, temp_key;
  u_char fields[4];
  des_cblock newpw;

  if (wildcard(valsin1->name) || wildcard(valsin1->instance)) {
      failmod(KADM_ILL_WILDCARD);
  }
d269 45
a313 5
  if (!check_access(rname, rinstance, rrealm, MODACL)) {
    (void) log("WARNING: '%s.%s@@%s' tried to change '%s.%s's entry",
	       rname, rinstance, rrealm, valsin1->name, valsin1->instance);
    return KADM_UNAUTH;
  }
d315 74
a388 70
  (void) log("request to modify '%s.%s's entry from '%s.%s@@%s' ",
	     valsin1->name, valsin1->instance, rname, rinstance, rrealm);
  
  numfound = kerb_get_principal(valsin1->name, valsin1->instance, 
				&data_o, 1, &more);
  if (numfound == -1) {
      failmod(KADM_DB_INUSE);
  } else if (numfound) {
      kadm_vals_to_prin(valsin2->fields, &temp_key, valsin2);
      (void) strncpy(data_o.name, valsin1->name, ANAME_SZ);
      (void) strncpy(data_o.instance, valsin1->instance, INST_SZ);
      if (IS_FIELD(KADM_EXPDATE,valsin2->fields))
	  data_o.exp_date = temp_key.exp_date;
      if (IS_FIELD(KADM_ATTR,valsin2->fields))
	  data_o.attributes = temp_key.attributes;
      if (IS_FIELD(KADM_MAXLIFE,valsin2->fields))
	  data_o.max_life = temp_key.max_life; 
      if (IS_FIELD(KADM_DESKEY,valsin2->fields)) {
	  data_o.key_version++;
	  data_o.kdc_key_ver = server_parm.master_key_version;


	  /* convert to host order */
	  temp_key.key_low = ntohl(temp_key.key_low);
	  temp_key.key_high = ntohl(temp_key.key_high);


	  bcopy(&temp_key.key_low,newpw,4);
	  bcopy(&temp_key.key_high,(char *)(((long *) newpw) + 1),4);

	  /* encrypt new key in master key */
	  kdb_encrypt_key (&newpw, &newpw, &server_parm.master_key,
			   server_parm.master_key_schedule, DES_ENCRYPT);
	  bcopy(newpw,&data_o.key_low,4);
	  bcopy((char *)(((long *) newpw) + 1), &data_o.key_high,4);
	  bzero((char *)newpw, sizeof(newpw));
      }
      bzero((char *)&temp_key, sizeof(temp_key));

      (void) strncpy(data_o.mod_name, rname, sizeof(data_o.mod_name)-1);
      (void) strncpy(data_o.mod_instance, rinstance,
		     sizeof(data_o.mod_instance)-1);
      more = kerb_put_principal(&data_o, 1);

      bzero((char *)&data_o, sizeof(data_o));

      if (more == -1) {
	  failmod(KADM_DB_INUSE);
      } else if (more) {
	  failmod(KADM_UK_SERROR);
      } else {
	  numfound = kerb_get_principal(valsin1->name, valsin1->instance, 
					&data_o, 1, &more);
	  if ((more!=0)||(numfound!=1)) {
	      failmod(KADM_UK_RERROR);
	  }
	  bzero((char *) fields, sizeof(fields));
	  SET_FIELD(KADM_NAME,fields);
	  SET_FIELD(KADM_INST,fields);
	  SET_FIELD(KADM_EXPDATE,fields);
	  SET_FIELD(KADM_ATTR,fields);
	  SET_FIELD(KADM_MAXLIFE,fields);
	  kadm_prin_to_vals(fields, valsout, &data_o);
	  (void) log("'%s.%s' modified.", valsin1->name, valsin1->instance);
	  return KADM_DATA;		/* Set all the appropriate fields */
      }
  }
  else {
      failmod(KADM_NOENTRY);
  }
a389 3
#undef failmod

#define failchange(code) {  (void) log("FAILED changing key for '%s.%s@@%s' (%s)", rname, rinstance, rrealm, error_message(code)); return code; }
d394 24
a417 18
  long numfound;
  int more;
  Principal data_o;
  des_cblock local_pw;

  if (strcmp(server_parm.krbrlm, rrealm)) {
      (void) log("change key request from wrong realm, '%s.%s@@%s'!\n",
		 rname, rinstance, rrealm);
      return(KADM_WRONG_REALM);
  }

  if (wildcard(rname) || wildcard(rinstance)) {
      failchange(KADM_ILL_WILDCARD);
  }
  (void) log("'%s.%s@@%s' wants to change its password",
	     rname, rinstance, rrealm);
  
  bcopy(newpw, local_pw, sizeof(local_pw));
d419 2
a420 2
  /* encrypt new key in master key */
  kdb_encrypt_key (&local_pw, &local_pw, &server_parm.master_key,
d423 3
a425 16
  numfound = kerb_get_principal(rname, rinstance, 
				&data_o, 1, &more);
  if (numfound == -1) {
      failchange(KADM_DB_INUSE);
  } else if (numfound) {
    bcopy(local_pw,&data_o.key_low,4);
    bcopy((char *)(((long *) local_pw) + 1), &data_o.key_high,4);
    data_o.key_version++;
    data_o.kdc_key_ver = server_parm.master_key_version;
    (void) strncpy(data_o.mod_name, rname, sizeof(data_o.mod_name)-1);
    (void) strncpy(data_o.mod_instance, rinstance,
		   sizeof(data_o.mod_instance)-1);
    more = kerb_put_principal(&data_o, 1);
    bzero((char *) local_pw, sizeof(local_pw));
    bzero((char *) &data_o, sizeof(data_o));
    if (more == -1) {
d427 23
a449 5
    } else if (more) {
	failchange(KADM_UK_SERROR);
    } else {
	(void) log("'%s.%s@@%s' password changed.", rname, rinstance, rrealm);
	return KADM_SUCCESS;
a450 4
  }
  else {
      failchange(KADM_NOENTRY);
  }
a451 1
#undef failchange
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id$	*/
d41 2
a42 1
    (void) sprintf(checkname, "%s.%s@@%s", pname, pinst, prealm);
d46 1
a46 1
	(void) sprintf(filename, "%s%s", acldir, ADD_ACL_FILE);
d49 1
a49 1
	(void) sprintf(filename, "%s%s", acldir, GET_ACL_FILE);
d52 1
a52 1
	(void) sprintf(filename, "%s%s", acldir, MOD_ACL_FILE);
@


1.1.1.1
log
@Kerberos IV code, based on a merge of fixed code from KTH and original
4.4BSD Lite code (international edition).  Provides all functionality
from the original 4.4BSD code plus standard Kerberos elements that were
omitted in the 4.4BSD code.
@
text
@@
