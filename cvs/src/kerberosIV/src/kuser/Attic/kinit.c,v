head	1.5;
access;
symbols
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	KRB4_1_1_1:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	KRB4_1_0_8:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	KRB4_1_0_4:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	KRB4_1_0_2:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	KRB4_1_0:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.05.16.18.45.37;	author mho;	state dead;
branches;
next	1.4;

1.4
date	2002.06.08.22.13.18;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.08.21.49.01;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.03.10.17;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.15.35.01;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.15.35.01;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.08.21.07.36;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Bye, bye, kerberosIV; ok hin@@
@
text
@/*
 * Copyright 1987, 1988 by the Massachusetts Institute of Technology. 
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>. 
 *
 * Routine to initialize user to Kerberos.  Prompts optionally for
 * user, instance and realm.  Authenticates user and gets a ticket
 * for the Kerberos ticket-granting service for future use. 
 *
 * Options are: 
 *
 *   -i[instance]
 *   -r[realm]
 *   -v[erbose]
 *   -l[ifetime]
 *   -p
 */

#include "kuser_locl.h"

RCSID("$KTH: kinit.c,v 1.18 2001/02/20 23:07:56 assar Exp $");

#define	LIFE	DEFAULT_TKT_LIFE /* lifetime of ticket in 5-minute units */
#define CHPASSLIFE 2

static void
get_input(char *s, int size, FILE *stream)
{
    char *p;

    if (fgets(s, size, stream) == NULL)
	exit(1);
    if ( (p = strchr(s, '\n')) != NULL)
	*p = '\0';
}


static void
usage(void)
{
    fprintf(stderr, "Usage: %s [-irvlp] [name]\n", __progname);
    exit(1);
}

int
main(int argc, char **argv)
{
    char    aname[ANAME_SZ];
    char    inst[INST_SZ];
    char    realm[REALM_SZ];
    char    buf[MaxHostNameLen];
    char    name[MAX_K_NAME_SZ];
    char   *username = NULL;
    int     iflag, rflag, vflag, lflag, pflag, lifetime, k_errno;
    int	    i;

    *inst = *realm = '\0';
    iflag = rflag = vflag = lflag = pflag = 0;
    lifetime = LIFE;

    while (--argc) {
	if ((*++argv)[0] != '-') {
	    if (username)
		usage();
	    username = *argv;
	    continue;
	}
	for (i = 1; (*argv)[i] != '\0'; i++)
	    switch ((*argv)[i]) {
	    case 'i':		/* Instance */
		++iflag;
		continue;
	    case 'r':		/* Realm */
		++rflag;
		continue;
	    case 'v':		/* Verbose */
		++vflag;
		continue;
	    case 'l':
		++lflag;
		continue;
	    case 'p':
		++pflag;	/* chpass-tickets */
		lifetime = CHPASSLIFE;
		break;
	    default:
		usage();
	    }
    }
    if (username &&
	(k_errno = kname_parse(aname, inst, realm, username)) != KSUCCESS) {
	warnx("%s", krb_get_err_text(k_errno));
	iflag = rflag = 1;
	username = NULL;
    }
    if (gethostname(buf, MaxHostNameLen)) 
	err(1, "gethostname failed");
    printf("%s (%s)\n", ORGANIZATION, buf);
    if (username) {
	printf("Kerberos Initialization for \"%s", aname);
	if (*inst)
	    printf(".%s", inst);
	if (*realm)
	    printf("@@%s", realm);
	printf("\"\n");
    } else {
	printf("Kerberos Initialization\n");
	printf("Kerberos name: ");
	get_input(name, sizeof(name), stdin);
	if (!*name)
	    return 0;
	if ((k_errno = kname_parse(aname, inst, realm, name)) != KSUCCESS )
	    errx(1, "%s", krb_get_err_text(k_errno));
    }
    /* optional instance */
    if (iflag) {
	printf("Kerberos instance: ");
	get_input(inst, sizeof(inst), stdin);
	if (!k_isinst(inst))
	    errx(1, "bad Kerberos instance format");
    }
    if (rflag) {
	printf("Kerberos realm: ");
	get_input(realm, sizeof(realm), stdin);
	if (!k_isrealm(realm))
	    errx(1, "bad Kerberos realm format");
    }
    if (lflag) {
	 printf("Kerberos ticket lifetime (minutes): ");
	 get_input(buf, sizeof(buf), stdin);
	 lifetime = atoi(buf);
	 if (lifetime < 5)
	      lifetime = 1;
	 else
	      lifetime = krb_time_to_life(0, lifetime*60);
	 /* This should be changed if the maximum ticket lifetime */
	 /* changes */
	 if (lifetime > 255)
	      lifetime = 255;
    }
    if (!*realm && krb_get_lrealm(realm, 1))
	errx(1, "krb_get_lrealm failed");
    k_errno = krb_get_pw_in_tkt(aname, inst, realm,
				pflag ? PWSERV_NAME : 
				KRB_TICKET_GRANTING_TICKET,
				pflag ? KADM_SINST  : realm,
				lifetime, 0);
    if (vflag) {
	printf("Kerberos realm %s:\n", realm);
	printf("%s\n", krb_get_err_text(k_errno));
    } else if (k_errno)
	errx(1, "%s", krb_get_err_text(k_errno));
    exit(0);
}
@


1.4
log
@cvs put set/getprogname() stuff back. remove it once again.
@
text
@@


1.3
log
@Merge krb4-1.1.1
@
text
@d42 1
a42 1
    fprintf(stderr, "Usage: %s [-irvlp] [name]\n", getprogname());
@


1.2
log
@set_progname/get_progname cleanup
@
text
@d22 1
a22 1
RCSID("$KTH: kinit.c,v 1.17 1997/12/12 04:48:44 assar Exp $");
d42 1
a42 1
    fprintf(stderr, "Usage: %s [-irvlp] [name]\n", __progname);
@


1.1
log
@Initial revision
@
text
@a57 2
    set_progname (argv[0]);

@


1.1.1.1
log
@Importing KTH Kerberos4 version 1.0
(art@@ ok)
@
text
@@


1.1.1.2
log
@Import of krb4-1.1.1
@
text
@d22 1
a22 1
RCSID("$KTH: kinit.c,v 1.18 2001/02/20 23:07:56 assar Exp $");
d42 1
a42 1
    fprintf(stderr, "Usage: %s [-irvlp] [name]\n", getprogname());
d58 1
a58 1
    setprogname (argv[0]);
@

