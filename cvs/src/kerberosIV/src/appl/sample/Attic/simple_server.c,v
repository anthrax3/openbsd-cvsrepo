head	1.5;
access;
symbols
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	KRB4_1_1_1:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	KRB4_1_0_8:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	KRB4_1_0_4:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	KRB4_1_0_2:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	KRB4_1_0:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.05.16.18.45.35;	author mho;	state dead;
branches;
next	1.4;

1.4
date	2002.06.08.22.13.18;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.08.21.49.00;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.03.10.17;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.15.32.49;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.15.32.49;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.08.21.07.19;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Bye, bye, kerberosIV; ok hin@@
@
text
@/*
 *
 * Copyright 1989 by the Massachusetts Institute of Technology.
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 *
 * Simple UDP-based server application.  For demonstration.
 * This program performs no useful function.
 */

#include "sample.h"

RCSID("$KTH: simple_server.c,v 1.13 2001/09/17 05:01:30 assar Exp $");

static void
usage (void)
{
    fprintf (stderr, "Usage: %s [-p port] [-s service] [-t srvtab]\n",
	     __progname);
    exit (1);
}

int
main(int argc, char **argv)
{
    char service[SNAME_SZ];
    char instance[INST_SZ];
    int port;
    char srvtab[MaxPathLen];
    struct sockaddr_in addr, otheraddr;
    int c;
    int sock;
    int i;
    socklen_t len;
    KTEXT_ST k;
    KTEXT ktxt = &k;
    AUTH_DAT ad;
    MSG_DAT msg_data;
    des_key_schedule sched;

    strlcpy (service, SAMPLE_SERVICE, sizeof(service));
    strlcpy (instance, "*", sizeof(instance));
    *srvtab = '\0';
    port = 0;

    while ((c = getopt (argc, argv, "p:s:t:")) != -1)
	switch (c) {
	case 'p' : {
	    struct servent *sp;

	    sp = getservbyname (optarg, "udp");
	    if (sp)
		port = sp->s_port;
	    else
		port = htons(atoi(optarg));
	    break;
	}
	case 's' :
	    strlcpy (service, optarg, sizeof(service));
	    break;
	case 't' :
	    strlcpy (srvtab, optarg, sizeof(srvtab));
	    break;
	case '?' :
	default :
	    usage ();
	}

    if(port == 0)
	port = k_getportbyname (SAMPLE_SERVICE, "udp", htons(SAMPLE_PORT));

    memset (&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = port;

    sock = socket (AF_INET, SOCK_DGRAM, 0);
    if (sock < 0)
	err (1, "socket");

    if (bind (sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	err (1, "bind");

    /* GET KRB_MK_REQ MESSAGE */

    i = read(sock, ktxt->dat, MAX_KTXT_LEN);
    if (i < 0)
	err (1, "read");

    printf("Received %d bytes\n", i);
    ktxt->length = i;

    /* Check authentication info */
    i = krb_rd_req(ktxt, service, instance, 0, &ad, "");
    if (i != KSUCCESS)
	errx (1, "krb_rd_req: %s", krb_get_err_text(i));
    printf("Got authentication info from %s%s%s@@%s\n", ad.pname,
	   *ad.pinst ? "." : "", ad.pinst, ad.prealm);
	
    /* GET KRB_MK_SAFE MESSAGE */

    /* use "recvfrom" so we know client's address */
    len = sizeof(otheraddr);
    i = recvfrom(sock, ktxt->dat, MAX_KTXT_LEN, 0,
		 (struct sockaddr *)&otheraddr, &len);
    if (i < 0)
	err (1, "recvfrom");
    printf("Received %d bytes\n", i);

    /* Verify the checksummed message */
    i = krb_rd_safe(ktxt->dat, i, &ad.session, &otheraddr,
		    &addr, &msg_data);
    if (i != KSUCCESS)
	errx (1, "krb_rd_safe: %s", krb_get_err_text(i));
    printf("Safe message is: %s\n", msg_data.app_data);
	
    /* NOW GET ENCRYPTED MESSAGE */

#ifdef NOENCRYPTION
    memset(sched, 0, sizeof(sched));
#else
    /* need key schedule for session key */
    des_key_sched(&ad.session, sched);
#endif

    /* use "recvfrom" so we know client's address */
    len = sizeof(otheraddr);
    i = recvfrom(sock, ktxt->dat, MAX_KTXT_LEN, 0,
		 (struct sockaddr *)&otheraddr, &len);
    if (i < 0)
	err (1, "recvfrom");
    printf("Received %d bytes\n", i);
    i = krb_rd_priv(ktxt->dat, i, sched, &ad.session, &otheraddr,
		    &addr, &msg_data);
    if (i != KSUCCESS)
	errx (1, "krb_rd_priv: %s", krb_get_err_text(i));
    printf("Decrypted message is: %s\n", msg_data.app_data);
    return(0);
}
@


1.4
log
@cvs put set/getprogname() stuff back. remove it once again.
@
text
@@


1.3
log
@Merge krb4-1.1.1
@
text
@d20 1
a20 1
	     getprogname());
@


1.2
log
@set_progname/get_progname cleanup
@
text
@d14 1
a14 1
RCSID("$KTH: simple_server.c,v 1.11 1999/11/13 06:29:24 assar Exp $");
d20 1
a20 1
	     __progname);
d35 1
a35 1
    int len;
@


1.1
log
@Initial revision
@
text
@a41 1
    set_progname (argv[0]);
@


1.1.1.1
log
@Importing KTH Kerberos4 version 1.0
(art@@ ok)
@
text
@@


1.1.1.2
log
@Import of krb4-1.1.1
@
text
@d14 1
a14 1
RCSID("$KTH: simple_server.c,v 1.13 2001/09/17 05:01:30 assar Exp $");
d20 1
a20 1
	     getprogname());
d35 1
a35 1
    socklen_t len;
d42 1
a42 1
    setprogname (argv[0]);
@

