head	1.5;
access;
symbols
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	KRB4_1_1_1:1.1.1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.1.1.3.0.4
	OPENBSD_3_0_BASE:1.1.1.3
	KRB4_1_0_8:1.1.1.3
	OPENBSD_2_9:1.1.1.3.0.2
	OPENBSD_2_9_BASE:1.1.1.3
	KRB4_1_0_4:1.1.1.3
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	KRB4_1_0_2:1.1.1.2
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	KRB4_1_0:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2003.05.16.18.45.34;	author mho;	state dead;
branches;
next	1.4;

1.4
date	2002.06.08.21.49.00;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.02.02.34.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.18.00.48.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.25.15.32.39;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.15.32.39;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.07.11.09.05.58;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.12.10.19.02.55;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.08.21.07.17;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Bye, bye, kerberosIV; ok hin@@
@
text
@/*
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kip.h"

RCSID("$KTH: common.c,v 1.19 2001/09/17 04:58:48 assar Exp $");

volatile sig_atomic_t disconnect = 0;
int isserver = 0;

/*
 * Copy packets from `tundev' to `netdev' or vice versa.
 * Mode is used when reading from `tundev'
 */

int
copy_packets (int tundev, int netdev, int mtu, des_cblock *iv,
	      des_key_schedule schedule)
{
     des_cblock iv1, iv2;
     int num1 = 0, num2 = 0;
     u_char *buf;

     buf = malloc (mtu + 2);
     if (buf == NULL) {
	 warnx("malloc(%d) failed", mtu);
	 return 1;
     }

     memcpy (&iv1, iv, sizeof(iv1));
     memcpy (&iv2, iv, sizeof(iv2));
     while(!disconnect) {
	  fd_set fdset;
	  int ret, len;

	  if (tundev >= FD_SETSIZE || netdev >= FD_SETSIZE) {
	      warnx ("fd too large");
	      return 1;
	  }

	  FD_ZERO(&fdset);
	  FD_SET(tundev, &fdset);
	  FD_SET(netdev, &fdset);

	  ret = select (max(tundev, netdev)+1, &fdset, NULL, NULL, NULL);
	  if (ret < 0) {
	      if (errno == EINTR)
		  continue;
	      warn ("select");
	      return 1;
	  }
	  if (FD_ISSET(tundev, &fdset)) {
	       ret = read (tundev, buf + 2, mtu);
	       if (ret == 0)
		    return 0;
	       if (ret < 0) {
		    if (errno == EINTR)
			 continue;
		    else { 
			warn("read");
			return ret;
		    }
	       }
	       buf[0] = ret >> 8;
	       buf[1] = ret & 0xFF;
	       ret += 2;
	       des_cfb64_encrypt (buf, buf, ret, schedule,
				  &iv1, &num1, DES_ENCRYPT);
	       ret = krb_net_write (netdev, buf, ret);
	       if (ret < 0) {
		   warn("write");
		   return ret;
	       }
	  }
	  if (FD_ISSET(netdev, &fdset)) {
	       ret = read (netdev, buf, 2);
	       if (ret == 0)
		    return 0;
	       if (ret < 0) {
		    if (errno == EINTR)
			 continue;
		    else { 
			warn("read");
			return ret;
		    }
	       }
	       des_cfb64_encrypt (buf, buf, 2, schedule,
				  &iv2, &num2, DES_DECRYPT);
	       len = (buf[0] << 8 ) | buf[1];
	       if (len > mtu) {
		   fatal (-1, "buffer too large", schedule, &iv2);
		   return -1;
	       }

	       if (len == 0) {
		   len = read (netdev, buf, mtu);
		   if (len < 1)
		       len = 1;
		   buf[len-1] = '\0';

		   fatal (-1, (const char *)buf, schedule, &iv2);
		   return -1;
	       }

	       ret = krb_net_read (netdev, buf + 2, len);
	       if (ret == 0)
		    return 0;
	       if (ret < 0) {
		    if (errno == EINTR)
			 continue;
		    else { 
			warn("read");
			return ret;
		    }
	       }
	       des_cfb64_encrypt (buf + 2, buf + 2, len, schedule,
				  &iv2, &num2, DES_DECRYPT);
	       ret = krb_net_write (tundev, buf + 2, len);
	       if (ret < 0) {
		   warn("write");
		   return ret;
	       }
	  }
     }
     return 0;
}

/*
 * Signal handler that justs waits for the children when they die.
 */

RETSIGTYPE
childhandler (int sig)
{
     int save_errno = errno;
     pid_t pid;
     int status;

     do { 
	  pid = waitpid (-1, &status, WNOHANG|WUNTRACED);
     } while(pid > 0);
     signal (SIGCHLD, childhandler);
     errno = save_errno;
     SIGRETURN(0);
}

/*
 * Find a free tunnel device and open it.
 * Return the interface name in `name, len'.
 */

int
tunnel_open (char *name, size_t len)
{
     int fd;
     int i;
     char devname[256];

     for (i = 0; i < 256; ++i) {
	  snprintf (devname, len, "%s%s%d", _PATH_DEV, TUNDEV, i);
	  fd = open (devname, O_RDWR, 0);
	  if (fd >= 0)
	       break;
	  if (errno == ENOENT || errno == ENODEV) {
	      warn("open %s", name);
	      return fd;
	  }
     }
     if (fd < 0)
	 warn("open %s" ,name);
     else
	 snprintf (name, len, "%s%d", TUNDEV, i);
     return fd;
}

/*
 * run the command `cmd' with (...).  return 0 if succesful or error
 * otherwise (and copy an error messages into `msg, len')
 */

int
kip_exec (const char *cmd, char *msg, size_t len, ...)
{
    pid_t pid;
    char **argv;
    va_list ap;

    va_start(ap, len);
    argv = vstrcollect(&ap);
    va_end(ap);

    pid = fork();
    switch (pid) {
    case -1:
	snprintf (msg, len, "fork: %s", strerror(errno));
	return errno;
    case 0: {
	int fd = open (_PATH_DEVNULL, O_RDWR, 0600);
	if (fd < 0) {
	    snprintf (msg, len, "open " _PATH_DEVNULL ": %s", strerror(errno));
	    return errno;
	}

	close (STDIN_FILENO);
	close (STDOUT_FILENO);
	close (STDERR_FILENO);
	
	dup2 (fd, STDIN_FILENO);
	dup2 (fd, STDOUT_FILENO);
	dup2 (fd, STDERR_FILENO);

	execvp (cmd, argv);
	snprintf (msg, len, "execvp %s: %s", cmd, strerror(errno));
	return errno;
    }
    default: {
	int status;

	while (waitpid(pid, &status, 0) < 0)
	    if (errno != EINTR) {
		snprintf (msg, len, "waitpid: %s", strerror(errno));
		return errno;
	    }

	if (WIFEXITED(status)) {
	    if (WEXITSTATUS(status) == 0) {
		return 0;
	    } else {
		snprintf (msg, len, "child returned with %d", 
			  WEXITSTATUS(status));
		return 1;
	    }
	} else if (WIFSIGNALED(status)) {
#ifndef WCOREDUMP
#define WCOREDUMP(X) 0
#endif
	    snprintf (msg, len, "terminated by signal num %d %s",
		      WTERMSIG(status), 
		      WCOREDUMP(status) ? " coredumped" : "");
	    return 1;
	} else if (WIFSTOPPED(status)) {
	    snprintf (msg, len, "process stoped by signal %d",
		      WSTOPSIG(status));
	    return 1;
	} else {
	    snprintf (msg, len, "child died in mysterious circumstances");
	    return 1;
	}
    }
    }
}

/*
 * fatal error `s' occured.
 */

void
fatal (int fd, const char *s, des_key_schedule schedule, des_cblock *iv)
{
     int16_t err = 0;
     int num = 0;

     if (fd != -1) {
	 des_cfb64_encrypt ((unsigned char*) &err, (unsigned char*) &err,
			    sizeof(err), schedule, iv, &num, DES_ENCRYPT);

	 write (fd, &err, sizeof(err));
	 write (fd, s, strlen(s)+1);
     }
     if (isserver)
	 syslog(LOG_ERR, "%s", s);
     else
	 warnx ("fatal error: %s", s);
}
@


1.4
log
@Merge krb4-1.1.1
@
text
@@


1.3
log
@fix simple signal handlers
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: common.c,v 1.13.2.4 2000/10/18 23:31:51 assar Exp $");
d131 1
a131 1
		   fatal (-1, buf, schedule, &iv2);
@


1.2
log
@volatile sig_atomic_t
@
text
@d165 1
d173 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997 Kungliga Tekniska Högskolan
d36 4
a39 1
RCSID("$KTH: common.c,v 1.13 1999/12/02 16:58:31 joda Exp $");
d62 1
a62 1
     for (;;) {
d66 5
d76 3
a78 1
	  if (ret < 0 && errno != EINTR) {
d120 15
d155 1
d177 1
d181 1
a181 1
tunnel_open (void)
d185 1
a185 1
     char name[64];
d188 2
a189 2
	  snprintf (name, sizeof(name), "%s%s%d", _PATH_DEV, TUNDEV, i);
	  fd = open (name, O_RDWR, 0);
d199 2
d202 100
@


1.1.1.1
log
@Importing KTH Kerberos4 version 1.0
(art@@ ok)
@
text
@@


1.1.1.2
log
@Import of KTH Kerberos4 1.0.2
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 4
RCSID("$KTH: common.c,v 1.13.2.2 2000/06/28 19:07:59 assar Exp $");

sig_atomic_t disconnect = 0;
int isserver = 0;
d59 1
a59 1
     while(!disconnect) {
d68 1
a68 3
	  if (ret < 0) {
	      if (errno == EINTR)
		  continue;
a109 15
	       if (len > mtu) {
		   fatal (-1, "buffer too large", schedule, &iv2);
		   return -1;
	       }

	       if (len == 0) {
		   len = read (netdev, buf, mtu);
		   if (len < 1)
		       len = 1;
		   buf[len-1] = '\0';

		   fatal (-1, buf, schedule, &iv2);
		   return -1;
	       }

a129 1
     return 0;
a150 1
 * Return the interface name in `name, len'.
d154 1
a154 1
tunnel_open (char *name, size_t len)
d158 1
a158 1
     char devname[256];
d161 2
a162 2
	  snprintf (devname, len, "%s%s%d", _PATH_DEV, TUNDEV, i);
	  fd = open (devname, O_RDWR, 0);
a171 2
     else
	 snprintf (name, len, "%s%d", TUNDEV, i);
a172 97
}

/*
 * run the command `cmd' with (...).  return 0 if succesful or error
 * otherwise (and copy an error messages into `msg, len')
 */

int
kip_exec (const char *cmd, char *msg, size_t len, ...)
{
    pid_t pid;
    char **argv;
    va_list ap;

    va_start(ap, len);
    argv = vstrcollect(&ap);
    va_end(ap);

    pid = fork();
    switch (pid) {
    case -1:
	snprintf (msg, len, "fork: %s", strerror(errno));
	return errno;
    case 0: {
	int fd = open (_PATH_DEVNULL, O_RDWR, 0600);
	if (fd < 0) {
	    snprintf (msg, len, "open " _PATH_DEVNULL ": %s", strerror(errno));
	    return errno;
	}

	close (STDIN_FILENO);
	close (STDOUT_FILENO);
	close (STDERR_FILENO);
	
	dup2 (fd, STDIN_FILENO);
	dup2 (fd, STDOUT_FILENO);
	dup2 (fd, STDERR_FILENO);

	execvp (cmd, argv);
	snprintf (msg, len, "execvp %s: %s", cmd, strerror(errno));
	return errno;
    }
    default: {
	int status;

	while (waitpid(pid, &status, 0) < 0)
	    if (errno != EINTR) {
		snprintf (msg, len, "waitpid: %s", strerror(errno));
		return errno;
	    }

	if (WIFEXITED(status)) {
	    if (WEXITSTATUS(status) == 0) {
		return 0;
	    } else {
		snprintf (msg, len, "child returned with %d", 
			  WEXITSTATUS(status));
		return 1;
	    }
	} else if (WIFSIGNALED(status)) {
	    snprintf (msg, len, "terminated by signal num %d %s",
		      WTERMSIG(status), 
		      WCOREDUMP(status) ? " coredumped" : "");
	    return 1;
	} else if (WIFSTOPPED(status)) {
	    snprintf (msg, len, "process stoped by signal %d",
		      WSTOPSIG(status));
	    return 1;
	} else {
	    snprintf (msg, len, "child died in mysterious circumstances");
	    return 1;
	}
    }
    }
}

/*
 * fatal error `s' occured.
 */

void
fatal (int fd, const char *s, des_key_schedule schedule, des_cblock *iv)
{
     int16_t err = 0;
     int num = 0;

     if (fd != -1) {
	 des_cfb64_encrypt ((unsigned char*) &err, (unsigned char*) &err,
			    sizeof(err), schedule, iv, &num, DES_ENCRYPT);

	 write (fd, &err, sizeof(err));
	 write (fd, s, strlen(s)+1);
     }
     if (isserver)
	 syslog(LOG_ERR, "%s", s);
     else
	 warnx ("fatal error: %s", s);
@


1.1.1.3
log
@Import kth-krb 1.0.4, with important bugfixes.
@
text
@d36 1
a36 1
RCSID("$KTH: common.c,v 1.13.2.4 2000/10/18 23:31:51 assar Exp $");
a65 5
	  if (tundev >= FD_SETSIZE || netdev >= FD_SETSIZE) {
	      warnx ("fd too large");
	      return 1;
	  }

a256 3
#ifndef WCOREDUMP
#define WCOREDUMP(X) 0
#endif
@


1.1.1.4
log
@Import of krb4-1.1.1
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: common.c,v 1.19 2001/09/17 04:58:48 assar Exp $");
d131 1
a131 1
		   fatal (-1, (const char *)buf, schedule, &iv2);
@


