head	1.2;
access;
symbols
	OPENBSD_3_3:1.1.1.1.0.14
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.12
	OPENBSD_3_2_BASE:1.1.1.1
	KRB4_1_1_1:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	KRB4_1_0_8:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	KRB4_1_0_4:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	KRB4_1_0_2:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	KRB4_1_0:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.18.45.35;	author mho;	state dead;
branches;
next	1.1;

1.1
date	2000.02.25.15.33.51;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.15.33.51;	author hin;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Bye, bye, kerberosIV; ok hin@@
@
text
@/*
 * Copyright (c) 1989 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#include <popper.h>
RCSID("$KTH: pop_user.c,v 1.15 1999/09/16 20:38:50 assar Exp $");

/* 
 *  user:   Prompt for the user name at the start of a POP session
 */

int
pop_user (POP *p)
{
    char ss[256];

    strlcpy(p->user, p->pop_parm[1], sizeof(p->user));

#ifdef OTP
    if (otp_challenge (&p->otp_ctx, p->user, ss, sizeof(ss)) == 0) {
	return pop_msg(p, POP_SUCCESS, "Password %s required for %s.",
		       ss, p->user);
    } else
#endif
    if (p->auth_level != AUTH_NONE) {
	char *s = NULL;
#ifdef OTP
	s = otp_error(&p->otp_ctx);
#endif
	return pop_msg(p, POP_FAILURE, "Permission denied%s%s",
		       s ? ":" : "", s ? s : "");
    } else
	return pop_msg(p, POP_SUCCESS, "Password required for %s.", p->user);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Importing KTH Kerberos4 version 1.0
(art@@ ok)
@
text
@@
