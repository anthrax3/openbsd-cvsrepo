head	1.2;
access;
symbols
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	KRB4_1_1_1:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	KRB4_1_0_8:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	KRB4_1_0_4:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	KRB4_1_0_2:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	KRB4_1_0:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2003.05.16.18.45.36;	author mho;	state dead;
branches;
next	1.1;

1.1
date	2000.02.25.15.37.28;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.15.37.28;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.08.21.07.57;	author hin;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Bye, bye, kerberosIV; ok hin@@
@
text
@# Make prototypes from .c files
# $KTH: make-proto.pl,v 1.11 1999/04/15 12:37:54 joda Exp $

##use Getopt::Std;
require 'getopts.pl';

$brace = 0;
$line = "";
$debug = 0;

do Getopts('o:p:d') || die "foo";

if($opt_d) {
    $debug = 1;
}

while(<>) {
    print $brace, " ", $_ if($debug);
    if(/^\#if 0/) {
	$if_0 = 1;
    }
    if($if_0 && /^\#endif/) {
	$if_0 = 0;
    }
    if($if_0) { next }
    if(/^\s*\#/) {
	next;
    }
    if(/^\s*$/) {
	$line = "";
	next;
    }
    if(/\{/){
	$_ = $line;
	while(s/\*\//\ca/){
	    s/\/\*(.|\n)*\ca//;
	}
	s/^\s*//;
	s/\s$//;
	s/\s+/ /g;
	if($line =~ /\)\s$/){
	    if(!/^static/ && !/^PRIVATE/){
		if(/(.*)(__attribute__\s?\(.*\))/) {
		    $attr = $2;
		    $_ = $1;
		} else {
		    $attr = "";
		}
		# remove outer ()
		s/\s*\(/@@/;
		s/\)\s?$/@@/;
		# remove , within ()
		while(s/\(([^()]*),(.*)\)/($1\$$2)/g){}
		s/,\s*/,\n\t/g;
		# fix removed ,
		s/\$/,/g;
		# match function name
		/([a-zA-Z0-9_]+)\s*@@/;
		$f = $1;
		# only add newline if more than one parameter
		$LP = "((";  # XXX workaround for indentation bug in emacs
		$RP = "))";
		$P = "__P((";
                if(/,/){ 
		    s/@@/ __P$LP\n\t/;
		}else{
		    s/@@/ __P$LP/;
		}
		s/@@/$RP/;
		# insert newline before function name
		s/(.*)\s([a-zA-Z0-9_]+ __P)/$1\n$2/;
		if($attr ne "") {
		    $_ .= "\n    $attr";
		}
		$_ = $_ . ";";
		$funcs{$f} = $_;
	    }
	}
	$line = "";
	$brace++;
    }
    if(/\}/){
	$brace--;
    }
    if(/^\}/){
	$brace = 0;
    }
    if($brace == 0) {
	$line = $line . " " . $_;
    }
}

sub foo {
    local ($arg) = @@_;
    $_ = $arg;
    s/.*\/([^\/]*)/$1/;
    s/[^a-zA-Z0-9]/_/g;
    "__" . $_ . "__";
}

if($opt_o) {
    open(OUT, ">$opt_o");
    $block = &foo($opt_o);
} else {
    $block = "__public_h__";
}

if($opt_p) {
    open(PRIV, ">$opt_p");
    $private = &foo($opt_p);
} else {
    $private = "__private_h__";
}

$public_h = "";
$private_h = "";

$public_h_header = "/* This is a generated file */
#ifndef $block
#define $block

#ifdef __STDC__
#include <stdarg.h>
#ifndef __P
#define __P(x) x
#endif
#else
#ifndef __P
#define __P(x) ()
#endif
#endif

";

$private_h_header = "/* This is a generated file */
#ifndef $private
#define $private

#ifdef __STDC__
#include <stdarg.h>
#ifndef __P
#define __P(x) x
#endif
#else
#ifndef __P
#define __P(x) ()
#endif
#endif

";

foreach(sort keys %funcs){
    if(/^(main)$/) { next }
    if(/^_/) {
	$private_h .= $funcs{$_} . "\n\n";
	if($funcs{$_} =~ /__attribute__/) {
	    $private_attribute_seen = 1;
	}
    } else {
	$public_h .= $funcs{$_} . "\n\n";
	if($funcs{$_} =~ /__attribute__/) {
	    $public_attribute_seen = 1;
	}
    }
}

if ($public_attribute_seen) {
    $public_h_header .= "#if !defined(__GNUC__) && !defined(__attribute__)
#define __attribute__(x)
#endif

";
}

if ($private_attribute_seen) {
    $private_h_header .= "#if !defined(__GNUC__) && !defined(__attribute__)
#define __attribute__(x)
#endif

";
}


if ($public_h ne "") {
    $public_h = $public_h_header . $public_h . "#endif /* $block */\n";
}
if ($private_h ne "") {
    $private_h = $private_h_header . $private_h . "#endif /* $private */\n";
}

if($opt_o) {
    print OUT $public_h;
} 
if($opt_p) {
    print PRIV $private_h;
} 

close OUT;
close PRIV;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Importing KTH Kerberos4 version 1.0
(art@@ ok)
@
text
@@


1.1.1.2
log
@Import of krb4-1.1.1
@
text
@d2 1
a2 1
# $KTH: make-proto.pl,v 1.12 2001/06/23 22:29:18 assar Exp $
a33 3
	if (!/\}/) {
	    $brace++;
	}
d80 1
@

