head	1.2;
access;
symbols
	OPENBSD_3_3:1.1.1.4.0.4
	OPENBSD_3_3_BASE:1.1.1.4
	OPENBSD_3_2:1.1.1.4.0.2
	OPENBSD_3_2_BASE:1.1.1.4
	KRB4_1_1_1:1.1.1.4
	OPENBSD_3_1:1.1.1.3.0.6
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.4
	OPENBSD_3_0_BASE:1.1.1.3
	KRB4_1_0_8:1.1.1.3
	OPENBSD_2_9:1.1.1.3.0.2
	OPENBSD_2_9_BASE:1.1.1.3
	KRB4_1_0_4:1.1.1.3
	OPENBSD_2_8:1.1.1.2.0.2
	OPENBSD_2_8_BASE:1.1.1.2
	KRB4_1_0_2:1.1.1.2
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	KRB4_1_0:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.18.45.38;	author mho;	state dead;
branches;
next	1.1;

1.1
date	2000.02.25.15.36.57;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.25.15.36.57;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.07.11.09.07.18;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.12.10.19.07.45;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.08.21.07.54;	author hin;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Bye, bye, kerberosIV; ok hin@@
@
text
@/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* This code is extremely ugly, and would probably be better off
   beeing completely rewritten */


#ifdef HAVE_CONFIG_H
#include<config.h>
RCSID("$KTH: pam.c,v 1.22 1999/12/02 16:58:37 joda Exp $");
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pwd.h>
#include <unistd.h>
#include <sys/types.h>

#define PAM_SM_AUTH
#define PAM_SM_SESSION
#include <security/pam_appl.h>
#include <security/pam_modules.h>

#include <netinet/in.h>
#include <krb.h>
#include <kafs.h>

static int
cleanup(pam_handle_t *pamh, void *data, int error_code)
{
    if(error_code != PAM_SUCCESS)
	dest_tkt();
    free(data);
    return PAM_SUCCESS;
}

static int
doit(pam_handle_t *pamh, char *name, char *inst, char *pwd, char *tkt)
{
    char realm[REALM_SZ];
    int ret;

    pam_set_data(pamh, "KRBTKFILE", strdup(tkt), cleanup);
    krb_set_tkt_string(tkt);
	
    krb_get_lrealm(realm, 1);
    ret = krb_verify_user(name, inst, realm, pwd, KRB_VERIFY_SECURE, NULL);
    memset(pwd, 0, strlen(pwd));
    switch(ret){
    case KSUCCESS:
	return PAM_SUCCESS;
    case KDC_PR_UNKNOWN:
	return PAM_USER_UNKNOWN;
    case SKDC_CANT:
    case SKDC_RETRY:
    case RD_AP_TIME:
	return PAM_AUTHINFO_UNAVAIL;
    default:
	return PAM_AUTH_ERR;
    }
}

static int
auth_login(pam_handle_t *pamh, int flags, char *user, struct pam_conv *conv)
{
    int ret;
    struct pam_message msg, *pmsg;
    struct pam_response *resp;
    char prompt[128];

    pmsg = &msg;
    msg.msg_style = PAM_PROMPT_ECHO_OFF;
    snprintf(prompt, sizeof(prompt), "%s's Password: ", user);
    msg.msg = prompt;

    ret = conv->conv(1, (const struct pam_message**)&pmsg, 
		     &resp, conv->appdata_ptr);
    if(ret != PAM_SUCCESS)
	return ret;
    
    {
	char tkt[1024];
	struct passwd *pw = getpwnam(user);

	if(pw){
	    snprintf(tkt, sizeof(tkt),
		     "%s%u", TKT_ROOT, (unsigned)pw->pw_uid);
	    ret = doit(pamh, user, "", resp->resp, tkt);
	    if(ret == PAM_SUCCESS)
		chown(tkt, pw->pw_uid, pw->pw_gid);
	}else
	    ret = PAM_USER_UNKNOWN;
	memset(resp->resp, 0, strlen(resp->resp));
	free(resp->resp);
	free(resp);
    }
    return ret;
}

static int
auth_su(pam_handle_t *pamh, int flags, char *user, struct pam_conv *conv)
{
    int ret;
    struct passwd *pw;
    struct pam_message msg, *pmsg;
    struct pam_response *resp;
    char prompt[128];
    krb_principal pr;
    
    pr.realm[0] = 0;
    ret = pam_get_user(pamh, &user, "login: ");
    if(ret != PAM_SUCCESS)
	return ret;
    
    pw = getpwuid(getuid());
    if(strcmp(user, "root") == 0){
	strlcpy(pr.name, pw->pw_name, sizeof(pr.name));
	strlcpy(pr.instance, "root", sizeof(pr.instance));
    }else{
	strlcpy(pr.name, user, sizeof(pr.name));
	pr.instance[0] = 0;
    }
    pmsg = &msg;
    msg.msg_style = PAM_PROMPT_ECHO_OFF;
    snprintf(prompt, sizeof(prompt), "%s's Password: ", krb_unparse_name(&pr));
    msg.msg = prompt;

    ret = conv->conv(1, (const struct pam_message**)&pmsg, 
		     &resp, conv->appdata_ptr);
    if(ret != PAM_SUCCESS)
	return ret;
    
    {
	char tkt[1024];

	snprintf(tkt, sizeof(tkt),"%s_%s_to_%s",
		 TKT_ROOT, pw->pw_name, user);
	ret = doit(pamh, pr.name, pr.instance, resp->resp, tkt);
	if(ret == PAM_SUCCESS)
	    chown(tkt, pw->pw_uid, pw->pw_gid);
	memset(resp->resp, 0, strlen(resp->resp));
	free(resp->resp);
	free(resp);
    }
    return ret;
}

int
pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
{
    char *user;
    int ret;
    struct pam_conv *conv;
    ret = pam_get_user(pamh, &user, "login: ");
    if(ret != PAM_SUCCESS)
	return ret;

    ret = pam_get_item(pamh, PAM_CONV, (void*)&conv);
    if(ret != PAM_SUCCESS)
	return ret;

    
    if(getuid() != geteuid())
	return auth_su(pamh, flags, user, conv);
    else
	return auth_login(pamh, flags, user, conv);
}

int 
pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv)
{
    return PAM_SUCCESS;
}


int
pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
{
    char *tkt, *var;
    void *user;
    const char *homedir = NULL;

    if(pam_get_item (pamh, PAM_USER, &user) == PAM_SUCCESS) {
	struct passwd *pwd;

	pwd = getpwnam ((char *)user);
	if (pwd != NULL)
	    homedir = pwd->pw_dir;
    }

    pam_get_data(pamh, "KRBTKFILE", (const void**)&tkt);
    var = malloc(strlen("KRBTKFILE=") + strlen(tkt) + 1);
    strcpy(var, "KRBTKFILE=");
    strcat(var, tkt);
    putenv(var);
    pam_putenv(pamh, var);
    if(k_hasafs()){
	k_setpag();
	krb_afslog_home(0, 0, homedir);
    }
    return PAM_SUCCESS;
}


int
pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
{
    dest_tkt();
    if(k_hasafs())
	k_unlog();
    return PAM_SUCCESS;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Importing KTH Kerberos4 version 1.0
(art@@ ok)
@
text
@@


1.1.1.2
log
@Import of KTH Kerberos4 1.0.2
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d34 4
d40 1
a40 1
RCSID("$KTH: pam.c,v 1.22.2.1 2000/03/10 23:00:14 assar Exp $");
a48 1
#include <syslog.h>
d50 2
a53 3
#ifndef PAM_AUTHTOK_RECOVERY_ERR /* Fix linsux typo. */
#define PAM_AUTHTOK_RECOVERY_ERR PAM_AUTHTOK_RECOVER_ERR
#endif
d59 2
a60 7
#if 0
/* Debugging PAM modules is a royal pain, truss helps. */
#define DEBUG(msg) (access(msg " at line", __LINE__))
#endif

static void
log_error(int level, const char *format, ...)
d62 4
a65 6
  va_list args;
  va_start(args, format);
  openlog("pam_krb4", LOG_CONS|LOG_PID, LOG_AUTH);
  vsyslog(level | LOG_AUTH, format, args);
  va_end(args);
  closelog();
d68 2
a69 17
enum {
  KRB4_DEBUG,
  KRB4_USE_FIRST_PASS,
  KRB4_TRY_FIRST_PASS,
  KRB4_IGNORE_ROOT,
  KRB4_NO_VERIFY,
  KRB4_REAFSLOG,
  KRB4_CTRLS			/* Number of ctrl arguments defined. */
};

#define KRB4_DEFAULTS  0

static int ctrl_flags = KRB4_DEFAULTS;
#define ctrl_on(x)  (krb4_args[x].flag & ctrl_flags)
#define ctrl_off(x) (!ctrl_on(x))

typedef struct
d71 2
a72 3
  const char *token;
  unsigned int flag;
} krb4_ctrls_t;
d74 17
a90 26
static krb4_ctrls_t krb4_args[KRB4_CTRLS] =
{
  /* KRB4_DEBUG          */ { "debug",          0x01 },
  /* KRB4_USE_FIRST_PASS */ { "use_first_pass", 0x02 },
  /* KRB4_TRY_FIRST_PASS */ { "try_first_pass", 0x04 },
  /* KRB4_IGNORE_ROOT    */ { "ignore_root",    0x08 },
  /* KRB4_NO_VERIFY      */ { "no_verify",      0x10 },
  /* KRB4_REAFSLOG       */ { "reafslog",       0x20 },
};

static void
parse_ctrl(int argc, const char **argv)
{
  int i, j;

  ctrl_flags = KRB4_DEFAULTS;
  for (i = 0; i < argc; i++)
    {
      for (j = 0; j < KRB4_CTRLS; j++)
	if (strcmp(argv[i], krb4_args[j].token) == 0)
	  break;
    
      if (j >= KRB4_CTRLS)
	log_error(LOG_ALERT, "unrecognized option [%s]", *argv);
      else
	ctrl_flags |= krb4_args[j].flag;
d94 2
a95 2
static void
pdeb(const char *format, ...)
d97 15
a111 24
  va_list args;
  if (ctrl_off(KRB4_DEBUG))
    return;
  va_start(args, format);
  openlog("pam_krb4", LOG_PID, LOG_AUTH);
  vsyslog(LOG_DEBUG | LOG_AUTH, format, args);
  va_end(args);
  closelog();
}

#define ENTRY(f) pdeb("%s() ruid = %d euid = %d", f, getuid(), geteuid())

static void
set_tkt_string(uid_t uid)
{
  char buf[128];

  snprintf(buf, sizeof(buf), "%s%u", TKT_ROOT, (unsigned)uid);
  krb_set_tkt_string(buf);

#if 0
  /* pam_set_data+pam_get_data are not guaranteed to work, grr. */
  pam_set_data(pamh, "KRBTKFILE", strdup(t), cleanup);
  if (pam_get_data(pamh, "KRBTKFILE", (const void**)&tkt) == PAM_SUCCESS)
d113 2
a114 3
      pam_putenv(pamh, var);
    }
#endif
d116 11
a126 8
  /* We don't want to inherit this variable.
   * If we still do, it must have a sane value. */
  if (getenv("KRBTKFILE") != 0)
    {
      char *var = malloc(sizeof(buf));
      snprintf(var, sizeof(buf), "KRBTKFILE=%s", tkt_string());
      putenv(var);
      /* free(var); XXX */
d128 1
d132 1
a132 4
verify_pass(pam_handle_t *pamh,
	    const char *name,
	    const char *inst,
	    const char *pass)
d134 30
a163 13
  char realm[REALM_SZ];
  int ret, krb_verify, old_euid, old_ruid;

  krb_get_lrealm(realm, 1);
  if (ctrl_on(KRB4_NO_VERIFY))
    krb_verify = KRB_VERIFY_SECURE_FAIL;
  else
    krb_verify = KRB_VERIFY_SECURE;
  old_ruid = getuid();
  old_euid = geteuid();
  setreuid(0, 0);
  ret = krb_verify_user(name, inst, realm, pass, krb_verify, NULL);
  if (setreuid(old_ruid, old_euid) != 0)
d165 1
a165 29
      log_error(LOG_ALERT , "setreuid(%d, %d) failed", old_ruid, old_euid);
      exit(1);
    }
    
  switch(ret) {
  case KSUCCESS:
    return PAM_SUCCESS;
  case KDC_PR_UNKNOWN:
    return PAM_USER_UNKNOWN;
  case SKDC_CANT:
  case SKDC_RETRY:
  case RD_AP_TIME:
    return PAM_AUTHINFO_UNAVAIL;
  default:
    return PAM_AUTH_ERR;
  }
}

static int
krb4_auth(pam_handle_t *pamh,
	  int flags,
	  const char *name,
	  const char *inst,
	  struct pam_conv *conv)
{
  struct pam_response *resp;
  char prompt[128];
  struct pam_message msg, *pmsg = &msg;
  int ret;
d167 8
a174 15
  if (ctrl_on(KRB4_TRY_FIRST_PASS) || ctrl_on(KRB4_USE_FIRST_PASS))
    {
      char *pass = 0;
      ret = pam_get_item(pamh, PAM_AUTHTOK, (void **) &pass);
      if (ret != PAM_SUCCESS)
        {
          log_error(LOG_ERR , "pam_get_item returned error to get-password");
          return ret;
        }
      else if (pass != 0 && verify_pass(pamh, name, inst, pass) == PAM_SUCCESS)
	return PAM_SUCCESS;
      else if (ctrl_on(KRB4_USE_FIRST_PASS))
	return PAM_AUTHTOK_RECOVERY_ERR;       /* Wrong password! */
      else
	/* We tried the first password but it didn't work, cont. */;
a175 10

  msg.msg_style = PAM_PROMPT_ECHO_OFF;
  if (*inst == 0)
    snprintf(prompt, sizeof(prompt), "%s's Password: ", name);
  else
    snprintf(prompt, sizeof(prompt), "%s.%s's Password: ", name, inst);
  msg.msg = prompt;

  ret = conv->conv(1, &pmsg, &resp, conv->appdata_ptr);
  if (ret != PAM_SUCCESS)
a176 16

  ret = verify_pass(pamh, name, inst, resp->resp);
  if (ret == PAM_SUCCESS)
    {
      memset(resp->resp, 0, strlen(resp->resp)); /* Erase password! */
      free(resp->resp);
      free(resp);
    }
  else
    {
      pam_set_item(pamh, PAM_AUTHTOK, resp->resp); /* Save password. */
      /* free(resp->resp); XXX */
      /* free(resp); XXX */
    }
  
  return ret;
d180 1
a180 4
pam_sm_authenticate(pam_handle_t *pamh,
		    int flags,
		    int argc,
		    const char **argv)
d182 10
a191 9
  char *user;
  int ret;
  struct pam_conv *conv;
  struct passwd *pw;
  uid_t uid = -1;
  const char *name, *inst;

  parse_ctrl(argc, argv);
  ENTRY("pam_sm_authenticate");
a192 17
  ret = pam_get_user(pamh, &user, "login: ");
  if (ret != PAM_SUCCESS)
    return ret;

  if (ctrl_on(KRB4_IGNORE_ROOT) && strcmp(user, "root") == 0)
    return PAM_AUTHINFO_UNAVAIL;

  ret = pam_get_item(pamh, PAM_CONV, (void*)&conv);
  if (ret != PAM_SUCCESS)
    return ret;

  pw = getpwnam(user);
  if (pw != 0)
    {
      uid = pw->pw_uid;
      set_tkt_string(uid);
    }
d194 4
a197 64
  if (strcmp(user, "root") == 0 && getuid() != 0)
    {
      pw = getpwuid(getuid());
      if (pw != 0)
	{
	  name = strdup(pw->pw_name);
	  inst = "root";
	}
    }
  else
    {
      name = user;
      inst = "";
    }

  ret = krb4_auth(pamh, flags, name, inst, conv);

  /*
   * The realm was lost inside krb_verify_user() so we can't simply do
   * a krb_kuserok() when inst != "".
   */
  if (ret == PAM_SUCCESS && inst[0] != 0)
    {
      char realm[REALM_SZ];
      uid_t old_euid = geteuid();
      uid_t old_ruid = getuid();

      realm[0] = 0;
      setreuid(0, 0);		/* To read ticket file. */
      if (krb_get_tf_fullname(tkt_string(), 0, 0, realm) != KSUCCESS)
	ret = PAM_SERVICE_ERR;
      else if (krb_kuserok(name, inst, realm, user) != KSUCCESS)
	{
	  setreuid(0, uid);	/*  To read ~/.klogin. */
	  if (krb_kuserok(name, inst, realm, user) != KSUCCESS)
	    ret = PAM_PERM_DENIED;
	}

      if (ret != PAM_SUCCESS)
	{
	  dest_tkt();		/* Passwd known, ok to kill ticket. */
	  log_error(LOG_NOTICE,
		    "%s.%s@@%s is not allowed to log in as %s",
		    name, inst, realm, user);
	}

      if (setreuid(old_ruid, old_euid) != 0)
	{
	  log_error(LOG_ALERT , "setreuid(%d, %d) failed", old_ruid, old_euid);
	  exit(1);
	}
    }

  if (ret == PAM_SUCCESS)
    chown(tkt_string(), uid, -1);

  /* Sun dtlogin unlock screen does not call any other pam_* funcs. */
  if (ret == PAM_SUCCESS
      && ctrl_on(KRB4_REAFSLOG)
      && k_hasafs()
      && (pw = getpwnam(user)) != 0)
    krb_afslog_uid_home(/*cell*/ 0,/*realm_hint*/ 0, pw->pw_uid, pw->pw_dir);

  return ret;
d203 1
a203 36
  parse_ctrl(argc, argv);
  ENTRY("pam_sm_setcred");
  pdeb("flags = 0x%x", flags);

  switch (flags & ~PAM_SILENT) {
  case 0:
  case PAM_ESTABLISH_CRED:
    if (k_hasafs())
      k_setpag();
    /* Fill PAG with credentials below. */
  case PAM_REINITIALIZE_CRED:
  case PAM_REFRESH_CRED:
    if (k_hasafs())
      {
	void *user = 0;

	if (pam_get_item(pamh, PAM_USER, &user) == PAM_SUCCESS)
	  {
	    struct passwd *pw = getpwnam((char *)user);
	    if (pw != 0)
	      krb_afslog_uid_home(/*cell*/ 0,/*realm_hint*/ 0,
				  pw->pw_uid, pw->pw_dir);
	  }
      }
    break;
  case PAM_DELETE_CRED:
    dest_tkt();
    if (k_hasafs())
      k_unlog();
    break;
  default:
    log_error(LOG_ALERT , "pam_sm_setcred: unknown flags 0x%x", flags);
    break;
  }
  
  return PAM_SUCCESS;
d206 1
d210 23
a232 4
  parse_ctrl(argc, argv);
  ENTRY("pam_sm_open_session");

  return PAM_SUCCESS;
d237 1
a237 1
pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char**argv)
d239 4
a242 9
  parse_ctrl(argc, argv);
  ENTRY("pam_sm_close_session");

  /* This isn't really kosher, but it's handy. */
  dest_tkt();
  if (k_hasafs())
    k_unlog();

  return PAM_SUCCESS;
@


1.1.1.3
log
@Import kth-krb 1.0.4, with important bugfixes.
@
text
@d36 1
a36 1
RCSID("$KTH: pam.c,v 1.22.2.2 2000/10/13 15:41:09 assar Exp $");
d63 1
a63 1
psyslog(int level, const char *format, ...)
d68 1
a68 1
  vsyslog(level, format, args);
d118 1
a118 1
	psyslog(LOG_ALERT, "unrecognized option [%s]", *argv);
d131 2
a132 2
  openlog("pam_krb4", LOG_CONS|LOG_PID, LOG_AUTH);
  vsyslog(LOG_DEBUG, format, args);
d137 1
a137 1
#define ENTRY(func) pdeb("%s() flags = %d ruid = %d euid = %d", func, flags, getuid(), geteuid())
d185 1
a185 5
  pdeb("krb_verify_user(`%s', `%s', `%s', pw, %d, NULL) returns %s",
       name, inst, realm, krb_verify,
       krb_get_err_text(ret));
  setreuid(old_ruid, old_euid);
  if (getuid() != old_ruid || geteuid() != old_euid)
d187 1
a187 2
      psyslog(LOG_ALERT , "setreuid(%d, %d) failed at line %d",
	      old_ruid, old_euid, __LINE__);
d223 1
a223 1
          psyslog(LOG_ERR , "pam_get_item returned error to get-password");
a273 2
  char realm[REALM_SZ];
  realm[0] = 0;
d319 1
d323 1
d337 3
a339 3
	  psyslog(LOG_NOTICE,
		  "%s.%s@@%s is not allowed to log in as %s",
		  name, inst, realm, user);
d342 1
a342 2
      setreuid(old_ruid, old_euid);
      if (getuid() != old_ruid || geteuid() != old_euid)
d344 1
a344 2
	  psyslog(LOG_ALERT , "setreuid(%d, %d) failed at line %d",
		  old_ruid, old_euid, __LINE__);
d350 8
a357 11
    {
      psyslog(LOG_INFO,
	      "%s.%s@@%s authenticated as user %s",
	      name, inst, realm, user);
      if (chown(tkt_string(), uid, -1) == -1)
	{
	  dest_tkt();
	  psyslog(LOG_ALERT , "chown(%s, %d, -1) failed", tkt_string(), uid);
	  exit(1);
	}
    }
a358 11
  /*
   * Kludge alert!!! Sun dtlogin unlock screen fails to call
   * pam_setcred(3) with PAM_REFRESH_CRED after a successful
   * authentication attempt, sic.
   *
   * This hack is designed as a workaround to that problem.
   */
  if (ctrl_on(KRB4_REAFSLOG))
    if (ret == PAM_SUCCESS)
      pam_sm_setcred(pamh, PAM_REFRESH_CRED, argc, argv);
  
d367 1
d374 1
a374 1
    /* Fall through, fill PAG with credentials below. */
d396 1
a396 1
    psyslog(LOG_ALERT , "pam_sm_setcred: unknown flags 0x%x", flags);
d420 3
a422 1
  pam_sm_setcred(pamh, PAM_DELETE_CRED, argc, argv);
@


1.1.1.4
log
@Import of krb4-1.1.1
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: pam.c,v 1.27 2001/02/15 04:30:05 assar Exp $");
d67 1
a67 1
  openlog("pam_krb4", LOG_PID, LOG_AUTH);
@


