head	1.7;
access;
symbols
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	KTH/tholo:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2000.02.25.15.15.06;	author hin;	state dead;
branches;
next	1.6;

1.6
date	98.06.22.15.22.27;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	97.12.09.07.57.39;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.11.28.12.49.31;	author art;	state Exp;
branches;
next	1.3;

1.3
date	97.02.15.19.57.00;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.12.16.17.09.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.06.52.37;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.14.06.52.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove old KerberosIV code. (art@@ ok)
@
text
@/*	$OpenBSD: str2key.c,v 1.6 1998/06/22 15:22:27 beck Exp $	*/
/* $KTH: str2key.c,v 1.10 1997/03/23 03:53:19 joda Exp $ */

/* This defines the Andrew string_to_key function.  It accepts a password
 * string as input and converts its via a one-way encryption algorithm to a DES
 * encryption key.  It is compatible with the original Andrew authentication
 * service password database.
 */

#include "krb_locl.h"

static void
mklower(char *s)
{
    for (; s[0] != '\0'; s++)
        if ('A' <= *s && *s <= 'Z')
            *s = *s - 'A' + 'a';
}

/*
 * Short passwords, i.e 8 characters or less.
 */
static void
afs_cmu_StringToKey (char *str, char *cell, des_cblock *key)
{
    char  password[8+1];	/* crypt is limited to 8 chars anyway */
    int   i;
    int   passlen;

    memset(key, 0, sizeof(key));
    memset(password, 0, sizeof(password));

    strncpy (password, cell, 8);
    password[8] = '\0';
    passlen = strlen (str);
    if (passlen > 8) passlen = 8;

    for (i=0; i<passlen; i++)
        password[i] = str[i] ^ cell[i];	/* make sure cell is zero padded */

    for (i=0; i<8; i++)
        if (password[i] == '\0') password[i] = 'X';

    /* crypt only considers the first 8 characters of password but for some
       reason returns eleven characters of result (plus the two salt chars). */
    strncpy((char *)key, (char *)des_crypt(password, "#~") + 2, sizeof(des_cblock));

    /* parity is inserted into the LSB so leftshift each byte up one bit.  This
       allows ascii characters with a zero MSB to retain as much significance
       as possible. */
    {   char *keybytes = (char *)key;
        unsigned int temp;

        for (i = 0; i < 8; i++) {
            temp = (unsigned int) keybytes[i];
            keybytes[i] = (unsigned char) (temp << 1);
        }
    }
    des_fixup_key_parity (key);
}

/*
 * Long passwords, i.e 9 characters or more.
 */
static void
afs_transarc_StringToKey (char *str, char *cell, des_cblock *key)
{
    des_key_schedule schedule;
    des_cblock temp_key;
    des_cblock ivec;
    char password[512];
    int  passlen;

    strncpy (password, str, sizeof(password));
    password[sizeof(password)-1] = '\0';
    if ((passlen = strlen (password)) < sizeof(password)-1)
        strncat (password, cell, sizeof(password)-passlen);
    if ((passlen = strlen(password)) > sizeof(password)) passlen = sizeof(password);

    memcpy(&ivec, "kerberos", 8);
    memcpy(&temp_key, "kerberos", 8);
    des_fixup_key_parity (&temp_key);
    des_key_sched (&temp_key, schedule);
    des_cbc_cksum ((des_cblock *)password, &ivec, passlen, schedule, &ivec);

    memcpy(&temp_key, &ivec, 8);
    des_fixup_key_parity (&temp_key);
    des_key_sched (&temp_key, schedule);
    des_cbc_cksum ((des_cblock *)password, key, passlen, schedule, &ivec);

    des_fixup_key_parity (key);
}

void
afs_string_to_key(char *str, char *cell, des_cblock *key)
{
    char realm[REALM_SZ+1];
    strncpy(realm, cell, REALM_SZ);
    realm[REALM_SZ] = 0;
    mklower(realm);

    if (strlen(str) > 8)
        afs_transarc_StringToKey (str, realm, key);
    else
        afs_cmu_StringToKey (str, realm, key);
}
@


1.6
log
@ Fix for transarc string-to-key.
@
text
@d1 1
a1 1
/*	$OpenBSD: str2key.c,v 1.5 1997/12/09 07:57:39 art Exp $	*/
@


1.5
log
@Removed one expliotable hole, one possibly exploitable hole, many buffer
overflows and lots of unchecked pointers. Tags are nice too.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
    strncpy((char *)key, (char *)crypt(password, "#~") + 2, sizeof(des_cblock));
@


1.4
log
@The first big step towards a complete upgrade to kth-krb4-0.9.7
@
text
@d1 1
d15 1
a15 1
    for (; *s; s++)
d30 1
a30 1
    memset (key, 0, sizeof(key));
d34 1
d75 1
@


1.3
log
@Rename crypt() entry in libdes to des_crypt
@
text
@d1 1
a1 7
/*
 * This software may now be redistributed outside the US.
 *
 * $Source: /cvs/src/kerberosIV/krb/str2key.c,v $
 *
 * $Locker:  $
 */
d3 1
a3 2
/*
 * This defines the Andrew string_to_key function.  It accepts a password
a10 4
/*
EXPORT void afs_string_to_key(char *passwd, char *cell, des_cblock *key);
*/

d12 1
a12 2
mklower(s)
	char *s;
d23 1
a23 4
afs_cmu_StringToKey (str, cell, key)
	char *str;
	char *cell;
	des_cblock *key;
d29 2
a30 2
    bzero (key, sizeof(key));
    bzero(password, sizeof(password));
d44 1
a44 1
    strncpy((void *)key, (char *)des_crypt(password, "#~") + 2, sizeof(des_cblock));
a59 3
#undef  BUFSIZ
#define	BUFSIZ		512

d62 1
a62 1
*/
d64 1
a64 4
afs_transarc_StringToKey (str, cell, key)
	char *str;
	char *cell;
	des_cblock *key;
d69 1
a69 1
    char password[BUFSIZ];
d72 1
a72 2
    strncpy (password, str, sizeof(password)-1);
    password[sizeof(password)-1] = '\0';
d75 1
a75 2
    if ((passlen = strlen(password)) > sizeof(password))
	passlen = sizeof(password);
d77 2
a78 2
    bcopy ("kerberos", &ivec, 8);
    bcopy ("kerberos", &temp_key, 8);
d83 1
a83 1
    bcopy (&ivec, &temp_key, 8);
a90 3
#undef  REALM_SZ
#define	REALM_SZ	41

d92 1
a92 4
afs_string_to_key(str, cell, key)
	char *str;
	char *cell;
	des_cblock *key;
d94 4
a97 3
    char  realm[REALM_SZ];
    (void)strcpy(realm, cell);
    (void)mklower(realm);
@


1.2
log
@strncat related oflows
@
text
@d59 1
a59 1
    strncpy((void *)key, (char *)crypt(password, "#~") + 2, sizeof(des_cblock));
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * $Source: /usr/src/kerberosIV/lib/krb/RCS/str2key.c,v $
d93 2
a94 1
    strncpy (password, str, sizeof(password));
d97 2
a98 1
    if ((passlen = strlen(password)) > sizeof(password)) passlen = sizeof(password);
@


1.1.1.1
log
@Kerberos IV code, based on a merge of fixed code from KTH and original
4.4BSD Lite code (international edition).  Provides all functionality
from the original 4.4BSD code plus standard Kerberos elements that were
omitted in the 4.4BSD code.
@
text
@@
