head	1.10;
access;
symbols
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.10
date	2000.02.25.15.15.01;	author hin;	state dead;
branches;
next	1.9;

1.9
date	98.07.07.19.06.47;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.05.18.00.53.39;	author art;	state Exp;
branches;
next	1.7;

1.7
date	98.05.15.00.58.54;	author art;	state Exp;
branches;
next	1.6;

1.6
date	98.03.25.21.50.11;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.12.12.05.30.21;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.12.09.14.42.50;	author art;	state Exp;
branches;
next	1.3;

1.3
date	97.12.09.08.12.30;	author art;	state Exp;
branches;
next	1.2;

1.2
date	97.12.09.07.57.16;	author art;	state Exp;
branches;
next	1.1;

1.1
date	97.11.28.12.49.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove old KerberosIV code. (art@@ ok)
@
text
@/*	$OpenBSD: get_host.c,v 1.9 1998/07/07 19:06:47 art Exp $	*/
/*	$KTH: get_host.c,v 1.37 1998/01/17 00:05:47 joda Exp $		*/

/*
 * Copyright (c) 1995, 1996, 1997 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb_locl.h"

static struct host_list {
    struct krb_host *this;
    struct host_list *next;
} *hosts;

static int krb_port = 0;

static void
free_hosts(struct host_list *h)
{
    struct host_list *t;
    while(h){
	if(h->this->realm != NULL)
	  {
	    free(h->this->realm);
	    h->this->realm = NULL;
	  }
	if(h->this->host != NULL)
	  {
	    free(h->this->host);
	    h->this->host = NULL;
	  }
	t = h;
	h = h->next;
	free(t);
	t=NULL;
    }
}

static int
parse_address(char *address, enum krb_host_proto *proto,
	      char **host, int *port)
{
    char *p, *q;
    int default_port = krb_port;

    if (proto == NULL || address == NULL || port == NULL || host == NULL)
      return -1;

    *proto = PROTO_UDP;
    if(strncmp(address, "http://", 7) == 0){
	p = address + 7;
	*proto = PROTO_HTTP;
	default_port = 80;
    }else{
	p = strchr(address, '/');
	if(p){
	    char prot[32];

	    strncpy(prot, address, MIN(p - address, 32));
	    prot[ MIN(p - address, 32-1) ] = '\0';
	    if(strcasecmp(prot, "udp") == 0)
		*proto = PROTO_UDP;
	    else if(strcasecmp(prot, "tcp") == 0)
		*proto = PROTO_TCP;
	    else if(strcasecmp(prot, "http") == 0) {
		*proto = PROTO_HTTP;
		default_port = 80;
	    } else
		krb_warning("Unknown protocol `%s', Using default `udp'.\n", 
			    prot);
	    p++;
	}else
	    p = address;
    }
    q = strchr(p, ':');
    if(q != NULL){
	*host = (char*)malloc(q - p + 1);
	if (*host == NULL)
	    return -1;
	strncpy(*host, p, q - p);
	(*host)[q - p] = '\0';
	q++;
	{
	    struct servent *sp = getservbyname(q, NULL);
	    if(sp)
		*port = ntohs(sp->s_port);
	    else
		if(sscanf(q, "%d", port) != 1){
		    krb_warning("Bad port specification `%s', using port %d.", 
				q, krb_port);
		    *port = krb_port;
		}
	}
    }else{
	*host = strdup(p);
	if(*host == NULL)
	    return -1;
	*port = default_port;
    }
    return 0;
}

static int
add_host(char *realm, char *address, int admin, int validate)
{
    struct krb_host *host;
    struct host_list *p, **last = &hosts;

    host = (struct krb_host*)malloc(sizeof(struct krb_host));
    if (host == NULL)
	return 1;
    if(parse_address(address, &host->proto, &host->host, &host->port) < 0)
	return 1;
    if (validate) {
        if (krb_dns_debug)
	    krb_warning("Getting host entry for %s...", host->host);
	if(gethostbyname(host->host) == NULL) {
	    if (krb_dns_debug)
	        krb_warning("Didn't get it.\n");
	    free(host->host);
	    host->host = NULL;
	    free(host);
	    host = NULL;
	    return 1;
	} else if (krb_dns_debug)
	    krb_warning("Got it.\n");
    }
    host->admin = admin;
    for(p = hosts; p; p = p->next){
	if(strcmp(realm, p->this->realm) == 0 &&
	   strcmp(host->host, p->this->host) == 0 && 
	   host->proto == p->this->proto &&
	   host->port == p->this->port){
	    free(host->host);
	    host->host = NULL;
	    free(host);
	    host = NULL;
	    return 1;
	}
	last = &p->next;
    }
    host->realm = strdup(realm);
    if (host->realm == NULL) {
	free(host->host);
	host->host = NULL;
	free(host);
	host = NULL;
	return 1;
    }
    p = (struct host_list*)malloc(sizeof(struct host_list));
    if (p == NULL) {
	free(host->realm);
	host->realm = NULL;
	free(host->host);
	host->host = NULL;
	free(host);
	host = NULL;
	return 1;
    }
    p->this = host;
    p->next = NULL;
    *last = p;
    return 0;
    }


static int
read_file(const char *filename, const char *r)
{
    char line[1024];
    char realm[1024];
    char address[1024];
    char scratch[1024];
    int n;
    int nhosts = 0;
    FILE *f;

    if (filename == NULL)
	return -1;
    
    f = fopen(filename, "r");
    if(f == NULL)
	return -1;
    while(fgets(line, sizeof(line), f) != NULL) {
	char *format = NULL;

	asprintf(&format, "%%%ds %%%ds admin %%%ds", sizeof(realm) - 1,
		 sizeof(address) - 1, sizeof(scratch) - 1);
	if (format == NULL) {
	    fclose(f);
	    return -1;
	}
	n = sscanf(line, format, realm, address, scratch);
	free(format);
	format = NULL;
	if(n == 2 || n == 3){
	    if(strcmp(realm, r))
		continue;
	    if(add_host(realm, address, n == 3, 0) == 0)
		nhosts++;
	}
    }
    fclose(f);
    return nhosts;
}

static int
init_hosts(char *realm)
{
    int i;
    char file[MAXPATHLEN];
    
    krb_port = ntohs(k_getportbyname (KRB_SERVICE, NULL, htons(KRB_PORT)));
    for(i = 0; krb_get_krbconf(i, file, sizeof(file)) == 0; i++)
	read_file(file, realm);
    return 0;
}

static void
srv_find_realm(char *realm, char *proto, char *service)
{
    char *domain;
    struct dns_reply *r;
    struct resource_record *rr;

    if (proto == NULL || realm == NULL || service == NULL)
	return;
    
    k_mconcat(&domain, 1024, service, ".", proto, ".", realm, ".", NULL);
    
    if(domain == NULL)
	return;
    
    r = dns_lookup(domain, "srv");
    if(r == NULL)
	r = dns_lookup(domain, "txt");
    if(r == NULL){
	free(domain);
	domain = NULL;
	return;
    }
    for(rr = r->head; rr; rr = rr->next){
	if(rr->type == T_SRV){
	    char buf[1024];

	    if (snprintf (buf,
			  sizeof(buf),
			  "%s/%s:%u",
			  proto,
			  rr->u.srv->target,
			  rr->u.srv->port) < sizeof(buf))
		add_host(realm, buf, 0, 0);
	}else if(rr->type == T_TXT)
	    add_host(realm, rr->u.txt, 0, 0);
    }
    dns_free_data(r);
    free(domain);
    domain = NULL;
}

struct krb_host*
krb_get_host(int nth, char *realm, int admin)
{
    struct host_list *p;
    static char orealm[REALM_SZ];
    if(orealm[0] == 0 || strcmp(realm, orealm)){
	/* quick optimization */
	if(realm && realm[0]){
	    strncpy(orealm, realm, sizeof(orealm) - 1);
	    orealm[sizeof(orealm) - 1] = '\0';
	}else{
	    int ret = krb_get_lrealm(orealm, 1);
	    if(ret != KSUCCESS)
		return NULL;
	}
	
	if(hosts){
	    free_hosts(hosts);
	    hosts = NULL;
	}
	
	init_hosts(orealm);
    
	srv_find_realm(orealm, "udp", KRB_SERVICE);
	srv_find_realm(orealm, "tcp", KRB_SERVICE);
	srv_find_realm(orealm, "http", KRB_SERVICE);
	
	{
	    /* XXX this assumes no one has more than 99999 kerberos
	       servers */
	    char host[REALM_SZ + sizeof("kerberos-XXXXX..")];
	    int i = 0;
	    snprintf(host, sizeof(host), "kerberos.%s.", orealm);
	    add_host(orealm, host, 1, 1);
	    do{
		i++;
		sprintf(host, "kerberos-%d.%s.", i, orealm);
	    }while(i < 100000 && add_host(orealm, host, 0, 1) == 0);
	}
    }
    
    for(p = hosts; p; p = p->next){
	if(strcmp(orealm, p->this->realm) == 0 &&
	   (!admin || p->this->admin)) {
	    if(nth == 1)
		return p->this;
	    else
		nth--;
	}
    }
    return NULL;
}

int
krb_get_krbhst(char *host, char *realm, int nth)
{
    struct krb_host *p = krb_get_host(nth, realm, 0);
    if(p == NULL)
	return KFAILURE;
    strncpy(host, p->host, MAXHOSTNAMELEN);
    host[MAXHOSTNAMELEN-1] = '\0';
    return KSUCCESS;
}

int
krb_get_admhst(char *host, char *realm, int nth)
{
    struct krb_host *p = krb_get_host(nth, realm, 1);
    if(p == NULL)
	return KFAILURE;
    strncpy(host, p->host, MAXHOSTNAMELEN);
    host[MAXHOSTNAMELEN-1] = '\0';
    return KSUCCESS;
}
@


1.9
log
@upgrade libkrb to 0.9.9
@
text
@d1 1
a1 1
/*	$OpenBSD: get_host.c,v 1.8 1998/05/18 00:53:39 art Exp $	*/
@


1.8
log
@update to a fresher libkrb
@
text
@d1 1
a1 1
/*	$OpenBSD: get_host.c,v 1.7 1998/05/15 00:58:54 art Exp $	*/
d148 13
a160 6
    if(validate && gethostbyname(host->host) == NULL){
	free(host->host);
	host->host = NULL;
	free(host);
	host = NULL;
	return 1;
d198 1
a198 1
}
@


1.7
log
@don't overflow buffers.
@
text
@d1 2
a2 2
/*	$OpenBSD: get_host.c,v 1.6 1998/03/25 21:50:11 art Exp $	*/
/* $KTH: get_host.c,v 1.31 1997/09/26 17:42:37 joda Exp $ */
d92 1
a92 1
	    struct protoent *pp;
d95 8
a102 9
	    if((pp = getprotobyname(prot)) != NULL ){
		switch(pp->p_proto){
		case IPPROTO_UDP:
		    *proto = PROTO_UDP;
		    break;
		case IPPROTO_TCP:
		    *proto = PROTO_TCP;
		    break;
		default:	
a104 4
		}
	    } else
		krb_warning("Bad protocol name `%s', Using default `udp'.\n", 
			    prot);
d238 1
a238 1
    char file[128];
d313 1
@


1.6
log
@get_ad_tkt.c : -Wall
get_host.c : "==" != "=" + -Wall
getaddrs.c : #include <err.h>
krb_locl.h : add prototypes for k_{{,v},{,v}m}concat
@
text
@d1 1
a1 1
/*	$OpenBSD: get_host.c,v 1.5 1997/12/12 05:30:21 art Exp $	*/
d217 11
a227 1
	n = sscanf(line, "%s %s admin %s", realm, address, scratch);
@


1.5
log
@Another upgrade of kth-krb + many fixes of strcpys and unchecked pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: get_host.c,v 1.4 1997/12/09 14:42:50 art Exp $	*/
d185 1
a185 1
	host->realm==NULL;
d325 1
a325 1
	   (!admin || p->this->admin))
d330 1
@


1.4
log
@I just wondered why it said "ud" instead of "udp".
@
text
@d1 1
a1 1
/*	$OpenBSD: get_host.c,v 1.3 1997/12/09 08:12:30 art Exp $	*/
d74 2
a75 1
parse_address(char *address, enum krb_host_proto *proto, char **host, int *port)
d118 1
a118 1
	  return -1;
d135 2
d147 1
d151 1
a151 1
    if (parse_address(address, &host->proto, &host->host, &host->port))
d175 1
a175 1
    if (host->realm == NULL){
d183 1
a183 1
    if (p == NULL){
d216 2
a217 2
    while(fgets(line, sizeof(line), f)){
	n = sscanf(line, "%1024s %1024s admin %1024s", realm, address, scratch);
a231 1
    static const char *files[] = KRB_CNF_FILES;
d233 2
a234 2
    char *dir = getenv("KRBCONFDIR");

d236 2
a237 7
    if(dir && getuid() != geteuid()){
	char file[MAXPATHLEN];
	if(k_concat(file, sizeof(file), dir, "/krb.conf", NULL) == 0)
	    read_file(file, realm);
    }
    for(i = 0; files[i]; i++)
	read_file(files[i], realm);
@


1.3
log
@Always those small bugs..
@
text
@d1 1
a1 1
/*	$OpenBSD: get_host.c,v 1.2 1997/12/09 07:57:16 art Exp $	*/
d93 1
a93 1
	    prot[ MIN(p - address, 32) - 1 ] = '\0';
@


1.2
log
@Removed one expliotable hole, one possibly exploitable hole, many buffer
overflows and lots of unchecked pointers. Tags are nice too.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
a93 1
	    prot[ MIN(p - address, 32) ] = '\0';
@


1.1
log
@The first big step towards a complete upgrade to kth-krb4-0.9.7
@
text
@d1 1
d56 2
a57 1
	if(h->this->realm)
d59 4
a62 1
	if(h->this->host)
d64 2
d69 1
d78 4
d92 3
a94 3
	    strncpy(prot, address, p - address);
	    prot[p - address] = 0;
	    if((pp = getprotobyname(prot))){
d114 1
a114 1
    if(q){
d116 2
d119 1
a119 1
	(*host)[q - p] = 0;
d145 4
a148 1
    parse_address(address, &host->proto, &host->host, &host->port);
d151 1
d153 1
d163 1
d165 1
d171 7
d179 9
a194 1

d204 4
d209 1
a209 1
    FILE *f = fopen(filename, "r");
d213 1
a213 1
	n = sscanf(line, "%s %s admin %s", realm, address, scratch);
d233 1
a233 1
    if(dir){
d249 3
d263 1
d282 1
d294 1
a294 1
	    orealm[sizeof(orealm) - 1] = 0;
d316 1
a316 1
	    sprintf(host, "kerberos.%s.", orealm);
d342 2
a343 1
    strcpy(host, p->host);
d353 2
a354 1
    strcpy(host, p->host);
@
