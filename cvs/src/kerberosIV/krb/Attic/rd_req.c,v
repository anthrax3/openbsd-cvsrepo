head	1.6;
access;
symbols
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	initial:1.1.1.1
	KTH/tholo:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2000.02.25.15.15.05;	author hin;	state dead;
branches;
next	1.5;

1.5
date	97.12.09.07.57.34;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.11.28.12.49.25;	author art;	state Exp;
branches;
next	1.3;

1.3
date	96.06.02.04.50.01;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.19.18.46;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.06.52.37;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.14.06.52.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Remove old KerberosIV code. (art@@ ok)
@
text
@/*	$OpenBSD: rd_req.c,v 1.5 1997/12/09 07:57:34 art Exp $	*/
/* $KTH: rd_req.c,v 1.24 1997/05/11 11:05:28 assar Exp $ */

/*
 * Copyright (c) 1995, 1996, 1997 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "krb_locl.h"

static struct timeval t_local = { 0, 0 };

/*
 * Keep the following information around for subsequent calls
 * to this routine by the same server using the same key.
 */

static des_key_schedule serv_key;	/* Key sched to decrypt ticket */
static des_cblock ky;              /* Initialization vector */
static int st_kvno;		/* version number for this key */
static char st_rlm[REALM_SZ];	/* server's realm */
static char st_nam[ANAME_SZ];	/* service name */
static char st_inst[INST_SZ];	/* server's instance */

/*
 * This file contains two functions.  krb_set_key() takes a DES
 * key or password string and returns a DES key (either the original
 * key, or the password converted into a DES key) and a key schedule
 * for it.
 *
 * krb_rd_req() reads an authentication request and returns information
 * about the identity of the requestor, or an indication that the
 * identity information was not authentic.
 */

/*
 * krb_set_key() takes as its first argument either a DES key or a
 * password string.  The "cvt" argument indicates how the first
 * argument "key" is to be interpreted: if "cvt" is null, "key" is
 * taken to be a DES key; if "cvt" is non-null, "key" is taken to
 * be a password string, and is converted into a DES key using
 * string_to_key().  In either case, the resulting key is returned
 * in the external static variable "ky".  A key schedule is
 * generated for "ky" and returned in the external static variable
 * "serv_key".
 *
 * This routine returns the return value of des_key_sched.
 *
 * krb_set_key() needs to be in the same .o file as krb_rd_req() so that
 * the key set by krb_set_key() is available in private storage for
 * krb_rd_req().
 */

int
krb_set_key(void *key, int cvt)
{
#ifdef NOENCRYPTION
    memset(ky, 0, sizeof(ky));
    return KSUCCESS;
#else /* Encrypt */
    if (cvt)
        des_string_to_key((char*)key, &ky);
    else
        memcpy((char*)ky, key, 8);
    return(des_key_sched(&ky, serv_key));
#endif /* NOENCRYPTION */
}


/*
 * krb_rd_req() takes an AUTH_MSG_APPL_REQUEST or
 * AUTH_MSG_APPL_REQUEST_MUTUAL message created by krb_mk_req(),
 * checks its integrity and returns a judgement as to the requestor's
 * identity.
 *
 * The "authent" argument is a pointer to the received message.
 * The "service" and "instance" arguments name the receiving server,
 * and are used to get the service's ticket to decrypt the ticket
 * in the message, and to compare against the server name inside the
 * ticket.  "from_addr" is the network address of the host from which
 * the message was received; this is checked against the network
 * address in the ticket.  If "from_addr" is zero, the check is not
 * performed.  "ad" is an AUTH_DAT structure which is
 * filled in with information about the sender's identity according
 * to the authenticator and ticket sent in the message.  Finally,
 * "fn" contains the name of the file containing the server's key.
 * (If "fn" is NULL, the server's key is assumed to have been set
 * by krb_set_key().  If "fn" is the null string ("") the default
 * file KEYFILE, defined in "krb.h", is used.)
 *
 * krb_rd_req() returns RD_AP_OK if the authentication information
 * was genuine, or one of the following error codes (defined in
 * "krb.h"):
 *
 *	RD_AP_VERSION		- wrong protocol version number
 *	RD_AP_MSG_TYPE		- wrong message type
 *	RD_AP_UNDEC		- couldn't decipher the message
 *	RD_AP_INCON		- inconsistencies found
 *	RD_AP_BADD		- wrong network address
 *	RD_AP_TIME		- client time (in authenticator)
 *				  too far off server time
 *	RD_AP_NYV		- Kerberos time (in ticket) too
 *				  far off server time
 *	RD_AP_EXP		- ticket expired
 *
 * For the message format, see krb_mk_req().
 *
 * Mutual authentication is not implemented.
 */

int
krb_rd_req(KTEXT authent,	/* The received message */
	   char *service,	/* Service name */
	   char *instance,	/* Service instance */
	   int32_t from_addr,	/* Net address of originating host */
	   AUTH_DAT *ad,	/* Structure to be filled in */
	   char *fn)		/* Filename to get keys from */
{
    static KTEXT_ST ticket;     /* Temp storage for ticket */
    static KTEXT tkt = &ticket;
    static KTEXT_ST req_id_st;  /* Temp storage for authenticator */
    KTEXT req_id = &req_id_st;

    char realm[REALM_SZ];	/* Realm of issuing kerberos */

    unsigned char skey[KKEY_SZ]; /* Session key from ticket */
    char sname[SNAME_SZ];	/* Service name from ticket */
    char iname[INST_SZ];	/* Instance name from ticket */
    char r_aname[ANAME_SZ];	/* Client name from authenticator */
    char r_inst[INST_SZ];	/* Client instance from authenticator */
    char r_realm[REALM_SZ];	/* Client realm from authenticator */
    u_int32_t r_time_sec;	/* Coarse time from authenticator */
    unsigned long delta_t;      /* Time in authenticator - local time */
    long tkt_age;		/* Age of ticket */
    static unsigned char s_kvno;/* Version number of the server's key
				 * Kerberos used to encrypt ticket */

    struct timeval tv;
    int status;

    int pvno;
    int type;
    int little_endian;

    unsigned char *p;

    if (authent->length <= 0)
	return(RD_AP_MODIFIED);

    p = authent->dat;

    /* get msg version, type and byte order, and server key version */

    pvno = *p++;

    if(pvno != KRB_PROT_VERSION)
	return RD_AP_VERSION;
    
    type = *p++;
    
    little_endian = type & 1;
    type &= ~1;
    
    if(type != AUTH_MSG_APPL_REQUEST && type != AUTH_MSG_APPL_REQUEST_MUTUAL)
	return RD_AP_MSG_TYPE;

    s_kvno = *p++;

    p += krb_get_string(p, realm);

    /*
     * If "fn" is NULL, key info should already be set; don't
     * bother with ticket file.  Otherwise, check to see if we
     * already have key info for the given server and key version
     * (saved in the static st_* variables).  If not, go get it
     * from the ticket file.  If "fn" is the null string, use the
     * default ticket file.
     */
    if (fn && (strcmp(st_nam,service) || strcmp(st_inst,instance) ||
               strcmp(st_rlm,realm) || (st_kvno != s_kvno))) {
        if (*fn == 0) fn = KEYFILE;
        st_kvno = s_kvno;
        if (read_service_key(service, instance, realm, s_kvno,
			     fn, (char *)skey))
            return(RD_AP_UNDEC);
        if ((status = krb_set_key((char*)skey, 0)))
	    return(status);
        strncpy(st_rlm, realm, REALM_SZ);
	st_rlm[REALM_SZ-1] = '\0';
        strncpy(st_nam, service, SNAME_SZ);
	st_nam[SNAME_SZ-1] = '\0';
        strncpy(st_inst, instance, INST_SZ);
	st_inst[INST_SZ-1] = '\0';
    }

    tkt->length = *p++;

    req_id->length = *p++;

    if(tkt->length + (p - authent->dat) > authent->length)
	return RD_AP_MODIFIED;

    memcpy(tkt->dat, p, tkt->length);
    p += tkt->length;

    if (krb_ap_req_debug)
        krb_log("ticket->length: %d",tkt->length);

    /* Decrypt and take apart ticket */
    if (decomp_ticket(tkt, &ad->k_flags, ad->pname, ad->pinst, ad->prealm,
                      &ad->address, ad->session, &ad->life,
                      &ad->time_sec, sname, iname, &ky, serv_key))
        return RD_AP_UNDEC;
    
    if (krb_ap_req_debug) {
        krb_log("Ticket Contents.");
        krb_log(" Aname:   %s.%s",ad->pname, ad->prealm);
        krb_log(" Service: %s", krb_unparse_name_long(sname, iname, NULL));
    }

    /* Extract the authenticator */
    
    if(req_id->length + (p - authent->dat) > authent->length)
	return RD_AP_MODIFIED;

    memcpy(req_id->dat, p, req_id->length);
    p = req_id->dat;
    
#ifndef NOENCRYPTION
    /* And decrypt it with the session key from the ticket */
    if (krb_ap_req_debug) krb_log("About to decrypt authenticator");

    encrypt_ktext(req_id, &ad->session, DES_DECRYPT);

    if (krb_ap_req_debug) krb_log("Done.");
#endif /* NOENCRYPTION */

    /* cast req_id->length to int? */
#define check_ptr() if ((ptr - (char *) req_id->dat) > req_id->length) return(RD_AP_MODIFIED);

    p += krb_get_nir(p, r_aname, r_inst, r_realm); /* XXX no rangecheck */

    p += krb_get_int(p, &ad->checksum, 4, little_endian);

    p++; /* time_5ms is not used */

    p += krb_get_int(p, &r_time_sec, 4, little_endian);

    /* Check for authenticity of the request */
    if (krb_ap_req_debug)
        krb_log("Principal: %s.%s@@%s / %s.%s@@%s",ad->pname,ad->pinst, ad->prealm, 
	      r_aname, r_inst, r_realm);
    if (strcmp(ad->pname, r_aname) != 0 ||
	strcmp(ad->pinst, r_inst) != 0 ||
	strcmp(ad->prealm, r_realm) != 0)
	return RD_AP_INCON;
    
    if (krb_ap_req_debug)
        krb_log("Address: %x %x", ad->address, from_addr);

    if (from_addr && (!krb_equiv(ad->address, from_addr)))
        return RD_AP_BADD;

    gettimeofday(&tv, NULL);
    delta_t = abs((int)(tv.tv_sec - r_time_sec));
    if (delta_t > CLOCK_SKEW) {
        if (krb_ap_req_debug)
            krb_log("Time out of range: %lu - %lu = %lu",
		    (unsigned long)t_local.tv_sec,
		    (unsigned long)r_time_sec,
		    (unsigned long)delta_t);
        return RD_AP_TIME;
    }

    /* Now check for expiration of ticket */

    tkt_age = tv.tv_sec - ad->time_sec;
    if (krb_ap_req_debug)
        krb_log("Time: %ld Issue Date: %lu Diff: %ld Life %x",
		(long)tv.tv_sec,
		(unsigned long)ad->time_sec,
		tkt_age,
		ad->life);
    
    if ((tkt_age < 0) && (-tkt_age > CLOCK_SKEW))
	return RD_AP_NYV;

    if (tv.tv_sec > krb_life_to_time(ad->time_sec, ad->life))
        return RD_AP_EXP;

    /* All seems OK */
    ad->reply.length = 0;

    return(RD_AP_OK);
}
@


1.5
log
@Removed one expliotable hole, one possibly exploitable hole, many buffer
overflows and lots of unchecked pointers. Tags are nice too.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4
log
@The first big step towards a complete upgrade to kth-krb4-0.9.7
@
text
@d1 1
d221 6
a226 3
        strcpy(st_rlm, realm);
        strcpy(st_nam, service);
        strcpy(st_inst, instance);
@


1.3
log
@Protect against the user overrunning and internal buffer
@
text
@d1 2
d4 35
a38 5
 * This software may now be redistributed outside the US.
 *
 * $Source: /cvs/src/kerberosIV/krb/rd_req.c,v $
 *
 * $Locker:  $
a40 21
/* 
  Copyright (C) 1989 by the Massachusetts Institute of Technology

   Export of this software from the United States of America is assumed
   to require a specific license from the United States Government.
   It is the responsibility of any person or organization contemplating
   export to obtain such a license before exporting.

WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
distribute this software and its documentation for any purpose and
without fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation, and that
the name of M.I.T. not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.  M.I.T. makes no representations about the suitability of
this software for any purpose.  It is provided "as is" without express
or implied warranty.

  */

a42 2
#include <sys/time.h>

d87 1
a87 3
krb_set_key(key, cvt)
	char *key;
	int cvt;
d90 1
a90 1
    bzero(ky, sizeof(ky));
d94 1
a94 1
        des_string_to_key(key,&ky);
d96 2
a97 2
        bcopy(key,(char *)ky,8);
    return(des_key_sched(&ky,serv_key));
d144 6
a149 7
krb_rd_req(authent, service, instance, from_addr, ad, fn)
	register KTEXT authent;	/* The received message */
	char *service;		/* Service name */
	char *instance;		/* Service instance */
	int32_t from_addr;	/* Net address of originating host */
	AUTH_DAT *ad;		/* Structure to be filled in */
	char *fn;		/* Filename to get keys from */
d154 1
a154 1
    register KTEXT req_id = &req_id_st;
d157 1
a157 1
    static des_key_schedule seskey_sched; /* Key sched for session key */
d164 1
a164 3
    unsigned int r_time_ms;     /* Fine time from authenticator */
    unsigned long r_time_sec;   /* Coarse time from authenticator */
    register char *ptr;		/* For stepping through */
a166 2
    static int swap_bytes;	/* Need to swap bytes? */
    static int mutual;		/* Mutual authentication requested? */
d169 2
d173 6
d182 1
a182 1
    ptr = (char *) authent->dat;
d186 14
a199 20
    /* check version */
    if (KRB_PROT_VERSION != (unsigned int) *ptr++)
        return(RD_AP_VERSION);

    /* byte order */
    swap_bytes = 0;
    if ((*ptr & 1) != HOST_BYTE_ORDER)
        swap_bytes++;

    /* check msg type */
    mutual = 0;
    switch (*ptr++ & ~1) {
    case AUTH_MSG_APPL_REQUEST:
        break;
    case AUTH_MSG_APPL_REQUEST_MUTUAL:
        mutual++;
        break;
    default:
        return(RD_AP_MSG_TYPE);
    }
d201 1
a201 9
#ifdef lint
    /* XXX mutual is set but not used; why??? */
    /* this is a crock to get lint to shut up */
    if (mutual)
        mutual = 0;
#endif /* lint */
    s_kvno = *ptr++;		/* get server key version */
    (void) strncpy(realm,ptr, REALM_SZ);   /* And the realm of the issuing KDC */
    ptr += strlen(ptr) + 1;     /* skip the realm "hint" */
d215 2
a216 3
#ifndef NOENCRYPTION
        if (read_service_key(service,instance,realm,(int) s_kvno,
                            fn,(char *)skey))
d218 1
a218 1
        if ((status = krb_set_key((char *)skey,0)))
d220 3
a222 4
#endif /* !NOENCRYPTION */
        (void) strcpy(st_rlm,realm);
        (void) strcpy(st_nam,service);
        (void) strcpy(st_inst,instance);
d225 9
a233 5
    /* Get ticket from authenticator */
    tkt->length = (int) *ptr++;
    if ((tkt->length + (ptr+1 - (char *) authent->dat)) > authent->length)
	return(RD_AP_MODIFIED);
    bcopy(ptr+1,(char *)(tkt->dat),tkt->length);
d236 1
a236 1
        log("ticket->length: %d",tkt->length);
a237 1
#ifndef NOENCRYPTION
d239 5
a243 7
#endif

    if (decomp_ticket(tkt,&ad->k_flags,ad->pname,ad->pinst,ad->prealm,
                      &(ad->address),ad->session, &(ad->life),
                      &(ad->time_sec),sname,iname,&ky,serv_key))
        return(RD_AP_UNDEC);

d245 3
a247 4
        log("Ticket Contents.");
        log(" Aname:   %s.%s",ad->pname,
            ((int)*(ad->prealm) ? ad->prealm : "Athena"));
        log(" Service: %s%s%s",sname,((int)*iname ? "." : ""),iname);
d251 7
a257 6
    req_id->length = (int) *(ptr++);
    if ((req_id->length + (ptr + tkt->length - (char *) authent->dat)) >
	authent->length)
	return(RD_AP_MODIFIED);
    bcopy(ptr + tkt->length, (char *)(req_id->dat),req_id->length);

d260 5
a264 5
    if (krb_ap_req_debug) log("About to decrypt authenticator");
    des_key_sched(&ad->session,seskey_sched);
    des_pcbc_encrypt((des_cblock *)req_id->dat,(des_cblock *)req_id->dat,
                 (long) req_id->length, seskey_sched,&ad->session,DES_DECRYPT);
    if (krb_ap_req_debug) log("Done.");
d267 1
d270 7
a276 25
    ptr = (char *) req_id->dat;
    (void) strcpy(r_aname,ptr);	/* Authentication name */
    ptr += strlen(r_aname)+1;
    check_ptr();
    (void) strcpy(r_inst,ptr);	/* Authentication instance */
    ptr += strlen(r_inst)+1;
    check_ptr();
    (void) strcpy(r_realm,ptr);	/* Authentication name */
    ptr += strlen(r_realm)+1;
    check_ptr();
    bcopy(ptr,(char *)&ad->checksum,4);	/* Checksum */
    ptr += 4;
    check_ptr();
    if (swap_bytes) swap_u_long(ad->checksum);
    r_time_ms = *(ptr++);	/* Time (fine) */
#ifdef lint
    /* XXX r_time_ms is set but not used.  why??? */
    /* this is a crock to get lint to shut up */
    if (r_time_ms)
        r_time_ms = 0;
#endif /* lint */
    check_ptr();
    /* assume sizeof(r_time_sec) == 4 ?? */
    bcopy(ptr,(char *)&r_time_sec,4); /* Time (coarse) */
    if (swap_bytes) swap_u_long(r_time_sec);
d280 7
a286 5
        log("Pname:   %s %s",ad->pname,r_aname);
    if (strcmp(ad->pname,r_aname) != 0)
        return(RD_AP_INCON);
    if (strcmp(ad->pinst,r_inst) != 0)
        return(RD_AP_INCON);
d288 1
a288 3
        log("Realm:   %s %s",ad->prealm,r_realm);
    if ((strcmp(ad->prealm,r_realm) != 0))
        return(RD_AP_INCON);
d290 2
a291 2
    if (krb_ap_req_debug)
        log("Address: %d %d",ad->address,from_addr);
d293 2
a294 2
    (void) gettimeofday(&t_local,(struct timezone *) 0);
    delta_t = abs((int)(t_local.tv_sec - r_time_sec));
d297 5
a301 3
            log("Time out of range: %d - %d = %d",
                t_local.tv_sec,r_time_sec,delta_t);
        return(RD_AP_TIME);
d306 1
a306 1
    tkt_age = t_local.tv_sec - ad->time_sec;
d308 8
a315 2
        log("Time: %d Issue Date: %d Diff: %d Life %x",
            t_local.tv_sec,ad->time_sec,tkt_age,ad->life);
d317 2
a318 6
    if (t_local.tv_sec < ad->time_sec) {
        if ((ad->time_sec - t_local.tv_sec) > CLOCK_SKEW)
            return(RD_AP_NYV);
    }
    else if (t_local.tv_sec > krb_life_to_time(ad->time_sec, ad->life))
        return(RD_AP_EXP);
@


1.2
log
@Make it work for multi-homed servers by default; remove need for krb.equiv
@
text
@d204 1
a204 1
    (void) strcpy(realm,ptr);   /* And the realm of the issuing KDC */
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * $Source: /usr/src/kerberosIV/lib/krb/RCS/rd_req.c,v $
a313 2
    if (from_addr && (!krb_equiv(ad->address, from_addr)))
        return(RD_AP_BADD);
@


1.1.1.1
log
@Kerberos IV code, based on a merge of fixed code from KTH and original
4.4BSD Lite code (international edition).  Provides all functionality
from the original 4.4BSD code plus standard Kerberos elements that were
omitted in the 4.4BSD code.
@
text
@@
