head	1.14;
access;
symbols
	OPENBSD_2_6:1.13.0.6
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	KTH/tholo:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2000.02.25.15.15.06;	author hin;	state dead;
branches;
next	1.13;

1.13
date	98.08.16.20.48.39;	author art;	state Exp;
branches;
next	1.12;

1.12
date	98.07.07.19.07.01;	author art;	state Exp;
branches;
next	1.11;

1.11
date	98.05.18.00.53.58;	author art;	state Exp;
branches;
next	1.10;

1.10
date	98.02.25.15.51.39;	author art;	state Exp;
branches;
next	1.9;

1.9
date	97.12.22.15.02.13;	author art;	state Exp;
branches;
next	1.8;

1.8
date	97.12.16.12.00.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.12.14.21.41.07;	author art;	state Exp;
branches;
next	1.6;

1.6
date	97.12.12.05.30.32;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.12.09.07.57.38;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.11.28.12.49.29;	author art;	state Exp;
branches;
next	1.3;

1.3
date	97.06.23.16.35.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.06.23.01.17.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.06.52.37;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.14.06.52.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove old KerberosIV code. (art@@ ok)
@
text
@/*	$OpenBSD: send_to_kdc.c,v 1.13 1998/08/16 20:48:39 art Exp $	*/
/*	$KTH: send_to_kdc.c,v 1.54 1998/02/17 23:55:35 bg Exp $		*/

/*
 * This source code is no longer held under any constraint of USA
 * `cryptographic laws' since it was exported legally.  The cryptographic
 * functions were removed from the code and a "Bones" distribution was
 * made.  A Commodity Jurisdiction Request #012-94 was filed with the
 * USA State Department, who handed it to the Commerce department.  The
 * code was determined to fall under General License GTDA under ECCN 5D96G,
 * and hence exportable.  The cryptographic interfaces were re-added by Eric
 * Young, and then KTH proceeded to maintain the code in the free world.
 *
 */

/* 
 *  Copyright (C) 1989 by the Massachusetts Institute of Technology
 *
 *  Export of this software from the United States of America is assumed
 *  to require a specific license from the United States Government.
 *  It is the responsibility of any person or organization contemplating
 *  export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 */

#include "krb_locl.h"

struct host {
    struct sockaddr_in addr;
    enum krb_host_proto proto;
};

static const char *prog = "send_to_kdc";
static send_recv(KTEXT pkt, KTEXT rpkt, int f,
		 struct sockaddr_in *adr, struct host *addrs,
		 int h_hosts);

/*
 * send_to_kdc() sends a message to the Kerberos authentication
 * server(s) in the given realm and returns the reply message.
 * The "pkt" argument points to the message to be sent to Kerberos;
 * the "rpkt" argument will be filled in with Kerberos' reply.
 * The "realm" argument indicates the realm of the Kerberos server(s)
 * to transact with.  If the realm is null, the local realm is used.
 *
 * If more than one Kerberos server is known for a given realm,
 * different servers will be queried until one of them replies.
 * Several attempts (retries) are made for each server before
 * giving up entirely.
 *
 * If an answer was received from a Kerberos host, KSUCCESS is
 * returned.  The following errors can be returned:
 *
 * SKDC_CANT    - can't get local realm
 *              - can't find "kerberos" in /etc/services database
 *              - can't open socket
 *              - can't bind socket
 *              - all ports in use
 *              - couldn't find any Kerberos host
 *
 * SKDC_RETRY   - couldn't get an answer from any Kerberos server,
 *		  after several retries
 */

/* always use the admin server */
static int krb_use_admin_server_flag = 0;

int
krb_use_admin_server(int flag)
{
    int old = krb_use_admin_server_flag;
    krb_use_admin_server_flag = flag;
    return old;
}

int
send_to_kdc(KTEXT pkt, KTEXT rpkt, char *realm)
{
    int i;
    int no_host; /* was a kerberos host found? */
    int retry;
    int n_hosts;
    int retval;
    struct hostent *host;
    char lrealm[REALM_SZ];
    struct krb_host *k_host;
    struct host *hosts = malloc(sizeof(*hosts));

    if (hosts == NULL)
	return SKDC_CANT;

    /*
     * If "realm" is non-null, use that, otherwise get the
     * local realm.
     */
    if (realm != NULL){
	strncpy(lrealm, realm, REALM_SZ);
	lrealm[REALM_SZ-1] = '\0';
    }
    else
	if (krb_get_lrealm(lrealm,1)) {
	    if (krb_debug)
		krb_warning("%s: can't get local realm\n", prog);
	    return(SKDC_CANT);
	}
    if (krb_debug)
	krb_warning("lrealm is %s\n", lrealm);

    no_host = 1;
    /* get an initial allocation */
    n_hosts = 0;
    for (i = 1; (k_host = krb_get_host(i, lrealm, krb_use_admin_server_flag)); 
	 ++i) {
	char *p;

        if (krb_debug)
	    krb_warning("Getting host entry for %s...", k_host->host);
        host = gethostbyname(k_host->host);
        if (krb_debug) {
	    krb_warning("%s.\n",
			host ? "Got it" : "Didn't get it");
        }
        if (!host)
            continue;
        no_host = 0;    /* found at least one */
	while ((p = *(host->h_addr_list)++)) {
	    struct host *temp;

	    temp = realloc(hosts, sizeof(*hosts) * (n_hosts + 1));
	    if (temp == NULL) {
	        free(hosts);
		return SKDC_CANT;
	    }
	    hosts = temp;
	    memset (&hosts[n_hosts].addr, 0, sizeof(hosts[n_hosts].addr));
	    hosts[n_hosts].addr.sin_family = host->h_addrtype;
	    hosts[n_hosts].addr.sin_port = htons(k_host->port);
	    hosts[n_hosts].proto = k_host->proto;
	    memcpy(&hosts[n_hosts].addr.sin_addr, p,
		   sizeof(hosts[n_hosts].addr.sin_addr));
	    ++n_hosts;
	    if (send_recv(pkt, rpkt, hosts[n_hosts-1].proto,
			  &hosts[n_hosts-1].addr, hosts, n_hosts)) {
		retval = KSUCCESS;
		goto rtn;
	    }
	    if (krb_debug) {
		krb_warning("Timeout, error, or wrong descriptor\n");
	    }
	}
    }
    if (no_host) {
	if (krb_debug)
	    krb_warning("%s: can't find any Kerberos host.\n",
			prog);
        retval = SKDC_CANT;
        goto rtn;
    }
    /* retry each host in sequence */
    for (retry = 0; retry < CLIENT_KRB_RETRY; ++retry) {
	for (i = 0; i < n_hosts; ++i) {
	    if (send_recv(pkt, rpkt,
			  hosts[i].proto,
			  &hosts[i].addr,
			  hosts,
			  n_hosts)) {
		retval = KSUCCESS;
		goto rtn;
	    }
        }
    }
    retval = SKDC_RETRY;
rtn:
    free(hosts);
    hosts = NULL;
    return(retval);
}

static int udp_socket(void)
{
    return socket(AF_INET, SOCK_DGRAM, 0);
}

static int udp_connect(int s, struct sockaddr_in *adr)
{
    if(krb_debug) {
	krb_warning("connecting to %s udp, port %d\n", 
		    inet_ntoa(adr->sin_addr), 
		    ntohs(adr->sin_port));
    }

    return connect(s, (struct sockaddr*)adr, sizeof(*adr));
}

static int udp_send(int s, struct sockaddr_in* adr, KTEXT pkt)
{
    if(krb_debug) {
	krb_warning("sending %d bytes to %s, udp port %d\n", 
		    pkt->length,
		    inet_ntoa(adr->sin_addr), 
		    ntohs(adr->sin_port));
    }

    return send(s, pkt->dat, pkt->length, 0);
}

static int tcp_socket(void)
{
    return socket(AF_INET, SOCK_STREAM, 0);
}

static int tcp_connect(int s, struct sockaddr_in *adr)
{
    if(krb_debug) {
	krb_warning("connecting to %s, tcp port %d\n", 
		    inet_ntoa(adr->sin_addr), 
		    ntohs(adr->sin_port));
    }

    return connect(s, (struct sockaddr*)adr, sizeof(*adr));
}

static int tcp_send(int s, struct sockaddr_in* adr, KTEXT pkt)
{
    unsigned char len[4];

    if(krb_debug) {
	krb_warning("sending %d bytes to %s, tcp port %d\n", 
		    pkt->length,
		    inet_ntoa(adr->sin_addr), 
		    ntohs(adr->sin_port));
    }

    krb_put_int(pkt->length, len, 4);
    if(send(s, len, sizeof(len), 0) != sizeof(len))
	return -1;
    return send(s, pkt->dat, pkt->length, 0);
}

static int udptcp_recv(void *buf, size_t len, KTEXT rpkt)
{
    int pktlen=MIN(len, MAX_KTXT_LEN - 1);

    if(krb_debug)
	krb_warning("recieved %d bytes on udp/tcp socket\n", len);

    memcpy(rpkt->dat, buf, pktlen);
    rpkt->length = pktlen;
    return 0;
}

static int url_parse(const char *url, char *host, size_t len, short *port)
{
    const char *p;
    if (url == NULL || host == NULL)
      return -1;
    if(strncmp(url, "http://", 7))
	return -1;
    url += 7;
    strncpy(host, url, len);
    p = strchr(url, ':');
    if(p){
	*port = atoi(p+1);
	if(p - url >= len)
	    return -1;
	host[p - url] = 0;
    }else{
	*port = 80;
	host[len - 1] = 0;
    }
    return 0;
}

#define PROXY_VAR "krb4_proxy"

static int http_connect(int s, struct sockaddr_in *adr)
{
    const char *proxy = krb_get_config_string(PROXY_VAR);
    char host[MAXHOSTNAMELEN];
    short port;
    struct hostent *hp;
    struct sockaddr_in sin;

    if (adr == NULL)
      return -1;

    if(proxy == NULL) {
	if(krb_debug)
	    krb_warning("Not using proxy.\n");
	return tcp_connect(s, adr);
    }

    if(url_parse(proxy, host, sizeof(host), &port) < 0)
	return -1;

    hp = gethostbyname(host);
    if(hp == NULL)
	return -1;

    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    memcpy(&sin.sin_addr, hp->h_addr, sizeof(sin.sin_addr));
    sin.sin_port = htons(port);
    if(krb_debug) {
	krb_warning("connecting to proxy on %s (%s) port %d\n", 
		    host, inet_ntoa(sin.sin_addr), port);
    }

    return connect(s, (struct sockaddr*)&sin, sizeof(sin));
}

static int http_send(int s, struct sockaddr_in* adr, KTEXT pkt)
{
    char *str;
    char *msg;

    if(base64_encode(pkt->dat, pkt->length, &str) < 0)
	return -1;

    if(krb_get_config_string(PROXY_VAR)){
	if(krb_debug) {
	    krb_warning("sending %d bytes to %s, tcp port %d (via proxy)\n", 
			pkt->length,
			inet_ntoa(adr->sin_addr), 
			ntohs(adr->sin_port));
	}

	asprintf(&msg, "GET http://%s:%d/%s HTTP/1.0\r\n\r\n",
		     inet_ntoa(adr->sin_addr),
		     ntohs(adr->sin_port),
		     str);
    } else {
	if(krb_debug) {
	    krb_warning("sending %d bytes to %s, http port %d\n", 
			pkt->length,
			inet_ntoa(adr->sin_addr), 
			ntohs(adr->sin_port));
	}
	asprintf(&msg, "GET %s HTTP/1.0\r\n\r\n", str);
    }
    free(str);
    str = NULL;

    if (msg == NULL)
	return -1;
	
    if(send(s, msg, strlen(msg), 0) != strlen(msg)){
	free(msg);
	msg = NULL;
	return -1;
    }
    free(msg);
    msg = NULL;
    return 0;
}

static int http_recv(void *buf, size_t len, KTEXT rpkt)
{
    char *p;
    int pktlen;
    char *tmp = malloc(len + 1);
    if (tmp == NULL)
	return -1;

    memcpy(tmp, buf, len);
    tmp[len] = 0;
    p = strstr(tmp, "\r\n\r\n");
    if(p == NULL){
	free(tmp);
	tmp = NULL;
	return -1;
    }

    p += 4;
    if(krb_debug)
	krb_warning("recieved %d bytes on http socket\n", (tmp + len) - p);
    if (p >= tmp+len) {
	free(tmp);
	tmp = NULL;
	return -1;
    }
    pktlen = MIN((tmp + len) - p, MAX_KTXT_LEN - 1);
    memcpy(rpkt->dat, p, pktlen);

    rpkt->dat[pktlen] = '\0';
    rpkt->length = pktlen;
    free(tmp);
    tmp = NULL;
    return 0;
}

static struct proto_descr {
    int proto;
    int stream_flag;
    int (*socket)(void);
    int (*connect)(int, struct sockaddr_in*);
    int (*send)(int, struct sockaddr_in*, KTEXT);
    int (*recv)(void*, size_t, KTEXT);
} protos[] = {
    { PROTO_UDP, 0, udp_socket, udp_connect, udp_send, udptcp_recv },
    { PROTO_TCP, 1, tcp_socket, tcp_connect, tcp_send, udptcp_recv },
    { PROTO_HTTP, 1, tcp_socket, http_connect, http_send, http_recv }
};

static int
send_recv(KTEXT pkt, KTEXT rpkt, int proto, struct sockaddr_in *adr,
	  struct host *addrs, int n_hosts)
{
    int i;
    int s;
    unsigned char buf[MAX_KTXT_LEN];
    int offset = 0;
    fd_set *fdsp = NULL;
    int fdsn;
    
    for(i = 0; i < sizeof(protos) / sizeof(protos[0]); i++){
	if(protos[i].proto == proto)
	    break;
    }
    if(i == sizeof(protos) / sizeof(protos[0]))
	return FALSE;
    if((s = (*protos[i].socket)()) < 0)
	return FALSE;
    if((*protos[i].connect)(s, adr) < 0){
	close(s);
	return FALSE;
    }
    if((*protos[i].send)(s, adr, pkt) < 0){
	close(s);
	return FALSE;
    }
    fdsn = howmany(s+1, NFDBITS) * sizeof(fd_mask);
    if ((fdsp = (fd_set *)malloc(fdsn)) == NULL) {
	close(s);
	return FALSE;
    }
    do{
	struct timeval timeout;
	int len;
	timeout.tv_sec = CLIENT_KRB_TIMEOUT;
	timeout.tv_usec = 0;

	memset(fdsp, 0, fdsn);
	FD_SET(s, fdsp);
	
	/* select - either recv is ready, or timeout */
	/* see if timeout or error or wrong descriptor */
	if(select(s + 1, fdsp, 0, 0, &timeout) < 1 
	   || !FD_ISSET(s, fdsp)) {
	    if (krb_debug)
		krb_warning("select failed: errno = %d\n", errno);
	    close(s);
	    free(fdsp);
	    return FALSE;
	}
	len = recv(s, buf + offset, sizeof(buf) - offset, 0);
	if(len <= 0)
	    break;
	offset += len;
    }while(protos[i].stream_flag);
    free(fdsp);
    close(s);
    if((*protos[i].recv)(buf, offset, rpkt) < 0)
	return FALSE;
    return TRUE;
}
@


1.13
log
@realloc correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: send_to_kdc.c,v 1.12 1998/07/07 19:07:01 art Exp $	*/
@


1.12
log
@upgrade libkrb to 0.9.9
@
text
@d1 1
a1 1
/*	$OpenBSD: send_to_kdc.c,v 1.11 1998/05/18 00:53:58 art Exp $	*/
d138 5
a142 2
	    hosts = realloc(hosts, sizeof(*hosts) * (n_hosts + 1));
	    if (hosts == NULL)
d144 2
@


1.11
log
@update to a fresher libkrb
@
text
@d1 1
a1 1
/*	$OpenBSD: send_to_kdc.c,v 1.10 1998/02/25 15:51:39 art Exp $	*/
d284 1
a284 1
    char *proxy = getenv(PROXY_VAR);
d326 1
a326 1
    if(getenv(PROXY_VAR)){
@


1.10
log
@nicer copyrights explaining that we are not criminals.
@
text
@d1 2
a2 2
/*	$OpenBSD: send_to_kdc.c,v 1.9 1997/12/22 15:02:13 art Exp $	*/
/* $KTH: send_to_kdc.c,v 1.47 1997/11/07 17:31:38 bg Exp $ */
d192 6
d203 7
d220 6
d232 8
d249 4
d293 3
a295 1
    if(proxy == NULL)
d297 1
d310 5
a322 1

d327 8
a334 1
	if (asprintf(&msg, "GET http://%s:%d/%s HTTP/1.0\r\n\r\n",
d337 7
a343 10
		     str) == -1){
	    free(str);
	    str = NULL;
	    return -1;
	}
    }else
	if (asprintf(&msg, "GET %s HTTP/1.0\r\n\r\n", str) == -1){
	    free(str);
	    str = NULL;
	    return -1;
d345 2
d349 3
d381 2
d417 1
a417 1
    unsigned char buf[2048];
@


1.9
log
@copyright cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: send_to_kdc.c,v 1.8 1997/12/16 12:00:08 deraadt Exp $	*/
d5 8
a12 1
 * This software may now be redistributed outside the US.
@


1.8
log
@do not use a statically sized fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: send_to_kdc.c,v 1.7 1997/12/14 21:41:07 art Exp $	*/
d4 5
d10 19
a28 19
  Copyright (C) 1989 by the Massachusetts Institute of Technology

   Export of this software from the United States of America is assumed
   to require a specific license from the United States Government.
   It is the responsibility of any person or organization contemplating
   export to obtain such a license before exporting.

WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
distribute this software and its documentation for any purpose and
without fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation, and that
the name of M.I.T. not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.  M.I.T. makes no representations about the suitability of
this software for any purpose.  It is provided "as is" without express
or implied warranty.

  */
@


1.7
log
@check the length of data in memcpy's
@
text
@d1 1
a1 1
/*	$OpenBSD: send_to_kdc.c,v 1.6 1997/12/12 05:30:32 art Exp $	*/
d358 2
d377 5
a382 1
	fd_set readfds;
d387 3
a389 2
	FD_ZERO(&readfds);
	FD_SET(s, &readfds);
d393 2
a394 2
	if(select(s + 1, &readfds, 0, 0, &timeout) < 1 
	   || !FD_ISSET(s, &readfds)) {
d398 1
d406 1
@


1.6
log
@Another upgrade of kth-krb + many fixes of strcpys and unchecked pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: send_to_kdc.c,v 1.5 1997/12/09 07:57:38 art Exp $	*/
d209 3
a211 2
    memcpy(rpkt->dat, buf, len);
    rpkt->length = len;
d307 1
d311 1
d320 1
d322 1
a322 1
    if (p >= tmp+len){
d327 5
a331 2
    memcpy(rpkt->dat, p, (tmp + len) - p);
    rpkt->length = (tmp + len) - p;
@


1.5
log
@Removed one expliotable hole, one possibly exploitable hole, many buffer
overflows and lots of unchecked pointers. Tags are nice too.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d271 4
a274 1
    base64_encode(pkt->dat, pkt->length, &str);
d279 3
a281 1
		     str) == -1)
d283 1
d307 2
@


1.4
log
@The first big step towards a complete upgrade to kth-krb4-0.9.7
@
text
@d1 1
d95 4
a98 2
    if (realm)
	strcpy(lrealm, realm);
d169 1
d217 2
d241 1
a241 1
    char host[MAXHOSTNAMELEN + 1];
d245 4
d251 1
d254 1
d258 1
d273 5
a277 4
	asprintf(&msg, "GET http://%s:%d/%s HTTP/1.0\r\n\r\n",
		 inet_ntoa(adr->sin_addr),
		 ntohs(adr->sin_port),
		 str);
d279 5
a283 1
	asprintf(&msg, "GET %s HTTP/1.0\r\n\r\n", str);
d285 1
d289 1
d293 1
d306 1
d310 5
d318 1
@


1.3
log
@oops, this is gross
@
text
@d1 1
a1 7
/*
 * This software may now be redistributed outside the US.
 *
 * $Source: /cvs/src/kerberosIV/krb/send_to_kdc.c,v $
 *
 * $Locker:  $
 */
d26 9
a34 22
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define S_AD_SZ sizeof(struct sockaddr_in)

static int krb_udp_port = 0;

/* CLIENT_KRB_TIMEOUT indicates the time to wait before
 * retrying a server.  It's defined in "krb.h".
 */
static struct timeval timeout = { CLIENT_KRB_TIMEOUT, 0};
static char *prog = "send_to_kdc";
static send_recv(KTEXT pkt, KTEXT rpkt, int f, struct sockaddr_in *_to, struct hostent *addrs);

/*
 * This file contains two routines, send_to_kdc() and send_recv().
 * send_recv() is a static routine used by send_to_kdc().
 */
d63 3
d67 1
a67 4
send_to_kdc(pkt, rpkt, realm)
	KTEXT pkt;
	KTEXT rpkt;
	char *realm;
d69 9
a77 1
    int i, f;
d82 1
a82 4
    struct sockaddr_in to;
    struct hostent *host, *hostlist;
    char *cp;
    char krbhst[MAX_HSTNM];
d84 5
d95 1
a95 1
	(void) strcpy(lrealm, realm);
d99 1
a99 1
		fprintf(stderr, "%s: can't get local realm\n", prog);
d103 1
a103 24
        printf("lrealm is %s\n", lrealm);
    if (krb_udp_port == 0) {
        register struct servent *sp;
        if ((sp = getservbyname("kerberos","udp")) == 0) {
            if (krb_debug)
                fprintf(stderr, "%s: Can't get kerberos/udp service\n",
                        prog);
            krb_udp_port = 750; /* Was return(SKDC_CANT); */
        }
        else
	    krb_udp_port = sp->s_port;
        if (krb_debug)
            printf("krb_udp_port is %d\n", krb_udp_port);
    }
    bzero((char *)&to, S_AD_SZ);
    hostlist = (struct hostent *) malloc(sizeof(struct hostent));
    if (!hostlist)
        return (/*errno */SKDC_CANT);
    if ((f = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        if (krb_debug)
            fprintf(stderr,"%s: Can't open socket\n", prog);
        return(SKDC_CANT);
    }
    /* from now on, exit through rtn label for cleanup */
d108 7
a114 7
    bzero((char *)&hostlist[n_hosts], sizeof(struct hostent));
    for (i = 1; krb_get_krbhst(krbhst, lrealm, i) == KSUCCESS; ++i) {
        if (krb_debug) {
            printf("Getting host entry for %s...",krbhst);
            (void) fflush(stdout);
        }
        host = gethostbyname(krbhst);
d116 2
a117 3
            printf("%s.\n",
                   host ? "Got it" : "Didn't get it");
            (void) fflush(stdout);
d122 20
a141 45
        n_hosts++;
        /* preserve host network address to check later
         * (would be better to preserve *all* addresses,
         * take care of that later)
         */
        hostlist = (struct hostent *)
            realloc((char *)hostlist,
                    (unsigned)
                    sizeof(struct hostent)*(n_hosts+1));
        if (!hostlist)
            return /*errno */SKDC_CANT;
        bcopy((char *)host, (char *)&hostlist[n_hosts-1],
              sizeof(struct hostent));
        host = &hostlist[n_hosts-1];
        cp = malloc((unsigned)host->h_length);
        if (!cp) {
            retval = /*errno */SKDC_CANT;
            goto rtn;
        }
        bcopy((char *)host->h_addr, cp, host->h_length);
/* At least Sun OS version 3.2 (or worse) and Ultrix version 2.2
   (or worse) only return one name ... */
#if defined(h_addr)
        host->h_addr_list = (char **)malloc(2*sizeof(char *));
        if (!host->h_addr_list) {
            retval = /*errno */SKDC_CANT;
            goto rtn;
        }
        host->h_addr_list[1] = NULL;
#endif /* defined(h_addr) */
        host->h_addr = cp;
        bzero((char *)&hostlist[n_hosts],
              sizeof(struct hostent));
        to.sin_family = host->h_addrtype;
        bcopy(host->h_addr, (char *)&to.sin_addr,
              host->h_length);
        to.sin_port = krb_udp_port;
        if (send_recv(pkt, rpkt, f, &to, hostlist)) {
            retval = KSUCCESS;
            goto rtn;
        }
        if (krb_debug) {
            printf("Timeout, error, or wrong descriptor\n");
            (void) fflush(stdout);
        }
d145 2
a146 2
	    fprintf(stderr, "%s: can't find any Kerberos host.\n",
		    prog);
d152 9
a160 8
        for (host = hostlist; host->h_name != (char *)NULL; host++) {
            to.sin_family = host->h_addrtype;
            bcopy(host->h_addr, (char *)&to.sin_addr,
                  host->h_length);
            if (send_recv(pkt, rpkt, f, &to, hostlist)) {
                retval = KSUCCESS;
                goto rtn;
            }
d165 1
a165 15
    (void) close(f);
    if (hostlist) {
        register struct hostent *hp;
        for (hp = hostlist; hp->h_name; hp++)
#if defined(h_addr)
            if (hp->h_addr_list) {
#endif /* defined(h_addr) */
                if (hp->h_addr)
                    free(hp->h_addr);
#if defined(h_addr)
                free((char *)hp->h_addr_list);
            }
#endif /* defined(h_addr) */
        free((char *)hostlist);
    }
d169 40
a208 4
/*
 * try to send out and receive message.
 * return 1 on success, 0 on failure
 */
d210 16
a225 21
static int
send_recv(pkt, rpkt, f, _to, addrs)
	KTEXT pkt;
	KTEXT rpkt;
	int f;
	struct sockaddr_in *_to;
	struct hostent *addrs;
{
    fd_set readfds;
    register struct hostent *hp;
    struct sockaddr_in from;
    int sin_size;
    int numsent;

    if (krb_debug) {
        if (_to->sin_family == AF_INET)
            printf("Sending message to %s...",
                   inet_ntoa(_to->sin_addr));
        else
            printf("Sending message...");
        (void) fflush(stdout);
d227 44
a270 6
    if ((numsent = sendto(f,(char *)(pkt->dat), pkt->length, 0, 
			  (struct sockaddr *)_to,
                          S_AD_SZ)) != pkt->length) {
        if (krb_debug)
            printf("sent only %d/%d\n",numsent, pkt->length);
        return 0;
d272 19
a290 49
    if (krb_debug) {
        printf("Sent\nWaiting for reply...");
        (void) fflush(stdout);
    }
    FD_ZERO(&readfds);
    FD_SET(f, &readfds);
    errno = 0;
    /* select - either recv is ready, or timeout */
    /* see if timeout or error or wrong descriptor */
    if (select(f + 1, &readfds, (fd_set *)0, (fd_set *)0, &timeout) < 1
        || !FD_ISSET(f, &readfds)) {
        if (krb_debug) {
	    long rfds;
	    bcopy(&readfds, &rfds, sizeof(rfds));
            fprintf(stderr, "select failed: readfds=%lx",
                    rfds);
            perror("");
        }
        return 0;
    }
    sin_size = sizeof(from);
    if (recvfrom(f, (char *)(rpkt->dat), sizeof(rpkt->dat), 0,
		 (struct sockaddr *)&from, &sin_size)
        < 0) {
        if (krb_debug)
            perror("recvfrom");
        return 0;
    }
    if (krb_debug) {
        printf("received packet from %s\n", inet_ntoa(from.sin_addr));
        fflush(stdout);
    }
    for (hp = addrs; hp->h_name != (char *)NULL; hp++) {
        if (!bcmp(hp->h_addr, (char *)&from.sin_addr.s_addr,
                  hp->h_length)) {
            if (krb_debug) {
                printf("Received it\n");
                (void) fflush(stdout);
            }
            return 1;
        }
        if (krb_debug)
            fprintf(stderr,
                    "packet not from %lx\n",
                    from.sin_addr.s_addr);
    }
    if (krb_debug)
        fprintf(stderr, "%s: received packet from wrong host! (%x)\n",
                "send_to_kdc(send_rcv)", (int)from.sin_addr.s_addr);
d292 67
@


1.2
log
@print addr in network byte order
@
text
@d318 1
a318 1
                    ntohl(hp->h_addr));
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * $Source: /usr/src/kerberosIV/lib/krb/RCS/send_to_kdc.c,v $
d318 1
a318 1
                    (long)hp->h_addr);
@


1.1.1.1
log
@Kerberos IV code, based on a merge of fixed code from KTH and original
4.4BSD Lite code (international edition).  Provides all functionality
from the original 4.4BSD code plus standard Kerberos elements that were
omitted in the 4.4BSD code.
@
text
@@

