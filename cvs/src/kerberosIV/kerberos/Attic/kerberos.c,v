head	1.17;
access;
symbols
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	initial:1.1.1.1
	KTH/tholo:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2000.02.25.15.14.57;	author hin;	state dead;
branches;
next	1.16;

1.16
date	99.05.23.17.19.24;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	98.11.28.23.41.01;	author art;	state Exp;
branches;
next	1.14;

1.14
date	98.08.16.02.42.11;	author art;	state Exp;
branches;
next	1.13;

1.13
date	98.07.13.19.57.19;	author art;	state Exp;
branches;
next	1.12;

1.12
date	98.02.25.15.50.57;	author art;	state Exp;
branches;
next	1.11;

1.11
date	98.02.18.11.53.54;	author art;	state Exp;
branches;
next	1.10;

1.10
date	97.12.15.06.43.04;	author art;	state Exp;
branches;
next	1.9;

1.9
date	97.12.15.05.09.39;	author art;	state Exp;
branches;
next	1.8;

1.8
date	97.12.12.05.30.14;	author art;	state Exp;
branches;
next	1.7;

1.7
date	97.11.29.14.09.16;	author art;	state Exp;
branches;
next	1.6;

1.6
date	97.11.28.12.48.46;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.06.29.10.32.14;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.40.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.17.23.29.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.09.16.18.48.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.06.52.52;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.14.06.52.52;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove old KerberosIV code. (art@@ ok)
@
text
@/*	$OpenBSD: kerberos.c,v 1.16 1999/05/23 17:19:24 aaron Exp $	*/
/* $KTH: kerberos.c,v 1.70 1997/09/26 18:06:38 joda Exp $ */

/*
 * This source code is no longer held under any constraint of USA
 * `cryptographic laws' since it was exported legally.  The cryptographic
 * functions were removed from the code and a "Bones" distribution was
 * made.  A Commodity Jurisdiction Request #012-94 was filed with the
 * USA State Department, who handed it to the Commerce department.  The
 * code was determined to fall under General License GTDA under ECCN 5D96G,
 * and hence exportable.  The cryptographic interfaces were re-added by Eric
 * Young, and then KTH proceeded to maintain the code in the free world.
 */

/*-
 * Copyright (C) 1989 by the Massachusetts Institute of Technology
 *
 * Export of this software from the United States of America is assumed
 * to require a specific license from the United States Government.
 * It is the responsibility of any person or organization contemplating
 * export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <sys/select.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/filio.h>

#include <netdb.h>
#include <stdarg.h>
#include <err.h>

#include <des.h>
#include <kerberosIV/krb.h>
#include <kerberosIV/krb_db.h>
#include <kerberosIV/prot.h>
#include "klog.h"

#include "version.h"
#include "krb_log.h"
#include "kdc.h"

static des_key_schedule master_key_schedule;
static des_cblock master_key;

static struct timeval kerb_time;
static u_char master_key_version;
static char k_instance[INST_SZ];
static char *lt;
static int more;

static int mflag;		/* Are we invoked manually? */
static char *log_file = KRBLOG;	/* name of alt. log file */
static int nflag;		/* don't check max age */
static int rflag;		/* alternate realm specified */

/* fields within the received request packet */
static char *req_name_ptr;
static char *req_inst_ptr;
static char *req_realm_ptr;
static u_int32_t req_time_ws;

static char local_realm[REALM_SZ];

/* options */
static int max_age = -1;
static int pause_int = -1;
static char progname[]="kerberos";

#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif /* MAX */

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif /* MIN */

/*
 * Print usage message and exit.
 */
static void
usage(void)
{
    fprintf(stderr, "Usage: %s [-s] [-m] [-n] [-p pause_seconds]"
	    " [-a max_age] [-l log_file] [-i address_to_listen_on]"
	    " [-r realm] [database_pathname]\n",
	    progname);
    exit(1);
}

/*
 * kerb_err_reply creates an error reply packet and sends it to the
 * client. 
 */

static void
kerb_err_reply(int f, struct sockaddr_in *client, int err, char *string)
{
    static KTEXT_ST e_pkt_st;
    KTEXT   e_pkt = &e_pkt_st;
    static char e_msg[128];

    strncpy(e_msg, "\nKerberos error -- ", sizeof(e_msg));
    if (strlen(e_msg) < sizeof(e_msg)) 
	strncat(e_msg, string, sizeof(e_msg) - strlen(e_msg) - 1);
    e_msg[sizeof(e_msg) - 1] = '\0';
    cr_err_reply(e_pkt, req_name_ptr, req_inst_ptr, req_realm_ptr,
		 req_time_ws, err, e_msg);
    sendto(f, (char*)e_pkt->dat, e_pkt->length, 0, (struct sockaddr *)client,
	   sizeof(*client));
}

static void
hang(void)
{
    if (pause_int == -1) {
	klog(L_KRB_PERR, "Kerberos will pause so as not to loop init");
	for (;;)
	    pause();
    } else {
	char buf[256];
	snprintf(buf, sizeof(buf),
		 "Kerberos will wait %d seconds before dying so as not to loop init",
		 pause_int);
	klog(L_KRB_PERR, buf);
	sleep(pause_int);
	klog(L_KRB_PERR, "Do svedania....\n");
	exit(1);
    }
}

static int
check_princ(char *p_name, char *instance, unsigned int lifetime, Principal *p)
{
    static int n;
    static int more;

    n = kerb_get_principal(p_name, instance, p, 1, &more);
    
    if (n < 0) {
	lt = klog(L_KRB_PERR, "Database unavailable!");
	hang();
    }
    
    /*
     * if more than one p_name, pick one, randomly create a session key,
     * compute maximum lifetime, lookup authorizations if applicable,
     * and stuff into cipher. 
     */
    if (n == 0) {
	/* service unknown, log error, skip to next request */
	lt = klog(L_ERR_UNK, "UNKNOWN %s.%s", p_name, instance);
	return KERB_ERR_PRINCIPAL_UNKNOWN;
    }
    if (more) {
	/* not unique, log error */
	lt = klog(L_ERR_NUN, "Principal not unique %s.%s", p_name, instance);
	return KERB_ERR_PRINCIPAL_NOT_UNIQUE;
    }
    /* If the user's key is null, we want to return an error */
    if ((p->key_low == 0) && (p->key_high == 0)) {
	/* User has a null key */
	lt = klog(L_ERR_NKY, "Null key %s.%s", p_name, instance);
	return KERB_ERR_NULL_KEY;
    }
    if (master_key_version != p->kdc_key_ver) {
	/* log error reply */
	lt = klog(L_ERR_MKV,
		  "Incorrect master key version for %s.%s: %d (should be %d)",
		  p->name, p->instance, p->kdc_key_ver, master_key_version);
	return KERB_ERR_NAME_MAST_KEY_VER;
    }
    /* make sure the service hasn't expired */
    if ((u_int32_t) p->exp_date < (u_int32_t) kerb_time.tv_sec) {
	/* service did expire, log it */
	time_t t = p->exp_date;
	lt = klog(L_ERR_SEXP,
		  "Principal %s.%s expired at %s", p->name, p->instance,
		  krb_stime(&t));
	return KERB_ERR_NAME_EXP;
    }
    /* ok is zero */
    return 0;
}

static void
unseal(des_cblock *key)
{
    kdb_encrypt_key(key, key, &master_key, master_key_schedule, DES_DECRYPT);
}


/* Set the key for krb_rd_req so we can check tgt */
static int
set_tgtkey(char *r)
              			/* Realm for desired key */
{
    int     n;
    static char lastrealm[REALM_SZ];
    Principal p_st;
    Principal *p = &p_st;
    des_cblock key;

    if (!strcmp(lastrealm, r))
	return (KSUCCESS);

    klog(L_ALL_REQ, "Getting key for %s", r);

    n = kerb_get_principal(KRB_TICKET_GRANTING_TICKET, r, p, 1, &more);
    if (n == 0)
	return (KFAILURE);

    /* unseal tgt key from master key */
    copy_to_key(&p->key_low, &p->key_high, key);
    unseal(&key);
    krb_set_key(key, 0);
    strncpy(lastrealm, r, sizeof(lastrealm) - 1);
    lastrealm[sizeof(lastrealm) - 1] = '\0';
    return (KSUCCESS);
}


static int
kerberos(unsigned char *buf, int len,
	 char *proto, struct sockaddr_in *client,
	 struct sockaddr_in *server,
	 KTEXT rpkt)
{
    int pvno;
    int msg_type;
    int lsb;
    int life;
    int flags = 0;
    char name[ANAME_SZ], inst[INST_SZ], realm[REALM_SZ];
    char service[SNAME_SZ], sinst[INST_SZ];
    u_int32_t req_time;
    static KTEXT_ST ticket, cipher, adat;
    KTEXT tk = &ticket, ciph = &cipher, auth = &adat;
    AUTH_DAT ad;
    des_cblock session, key;
    int err;
    Principal a_name, s_name;
    
    char *msg;
    
    
    unsigned char *p = buf;
    if(len < 2){
	strncpy((char*)rpkt->dat, "Packet too short", MAX_KTXT_LEN - 1);
	rpkt->dat[MAX_KTXT_LEN - 1] = '\0';
	return KFAILURE;
    }

    gettimeofday(&kerb_time, NULL);

    pvno = *p++;
    if(pvno != KRB_PROT_VERSION){
	msg = klog(L_KRB_PERR, "KRB protocol version mismatch (%d)", pvno);
	strncpy((char*)rpkt->dat, msg, MAX_KTXT_LEN - 1);
	rpkt->dat[MAX_KTXT_LEN - 1] = '\0';
	return KERB_ERR_PKT_VER;
    }
    msg_type = *p++;
    lsb = msg_type & 1;
    msg_type &= ~1;
    switch(msg_type){
    case AUTH_MSG_KDC_REQUEST:
	/* XXX range check */
	p += krb_get_nir(p, name, inst, realm);
	p += krb_get_int(p, &req_time, 4, lsb);
	life = *p++;
	p += krb_get_nir(p, service, sinst, NULL);
	klog(L_INI_REQ,
	     "AS REQ %s.%s@@%s for %s.%s from %s (%s/%u)", 
	     name, inst, realm, service, sinst,
	     inet_ntoa(client->sin_addr),
	     proto, ntohs(server->sin_port));
	if((err = check_princ(name, inst, 0, &a_name))){
	    strncpy((char*)rpkt->dat, krb_get_err_text(err), MAX_KTXT_LEN - 1);
	    rpkt->dat[MAX_KTXT_LEN - 1] = '\0';
	    return err;
	}
	tk->length = 0;
	if((err = check_princ(service, sinst, 0, &s_name))){
	    strncpy((char*)rpkt->dat, krb_get_err_text(err), MAX_KTXT_LEN - 1);
	    rpkt->dat[MAX_KTXT_LEN -1] = '\0';
	    return err;
	}
	life = MIN(life, s_name.max_life);
	life = MIN(life, a_name.max_life);
    
	des_new_random_key(&session);
	copy_to_key(&s_name.key_low, &s_name.key_high, key);
	unseal(&key);
	krb_create_ticket(tk, flags, a_name.name, a_name.instance, 
			  local_realm, client->sin_addr.s_addr,
			  session, 
			  life, kerb_time.tv_sec, 
			  s_name.name, s_name.instance, &key);
	copy_to_key(&a_name.key_low, &a_name.key_high, key);
	unseal(&key);
	create_ciph(ciph, session, s_name.name, s_name.instance,
		    local_realm, life, s_name.key_version, tk, 
		    kerb_time.tv_sec, &key);
	memset(&session, 0, sizeof(session));
	memset(&key, 0, sizeof(key));
	{
	    KTEXT r;
	    r = create_auth_reply(name, inst, realm, req_time, 0, 
				  a_name.exp_date, a_name.key_version, ciph);
	    memcpy(rpkt, r, sizeof(*rpkt));
	}
	return 0;
    case AUTH_MSG_APPL_REQUEST:
	strncpy(realm, (char*)buf + 3, REALM_SZ - 1);
	realm[REALM_SZ - 1] = '\0';
	if((err = set_tgtkey(realm))){
	    msg = klog(L_ERR_UNK,
		       "Unknown realm %s from %s (%s/%u)", 
		       realm, inet_ntoa(client->sin_addr),
		       proto, ntohs(server->sin_port));
	    strncpy((char*)rpkt->dat, msg, MAX_KTXT_LEN - 1);
	    rpkt->dat[MAX_KTXT_LEN -1] = '\0';
	    return err;
	}
	p = buf + strlen(realm) + 4;
	p = p + p[0] + p[1] + 2;
	auth->length = p - buf;
	memcpy(auth->dat, buf, auth->length);
	err = krb_rd_req(auth, KRB_TICKET_GRANTING_TICKET,
			 realm, client->sin_addr.s_addr, &ad, 0);
	if(err){
	    msg = klog(L_ERR_UNK,
		       "krb_rd_req from %s (%s/%u): %s", 
		       inet_ntoa(client->sin_addr),
		       proto,
		       ntohs(server->sin_port),
		       krb_get_err_text(err));
	    strncpy((char*)rpkt->dat, msg, MAX_KTXT_LEN - 1);
	    rpkt->dat[MAX_KTXT_LEN - 1] = '\0';
	    return err;
	}
	p += krb_get_int(p, &req_time, 4, lsb);
	life = *p++;
	p += krb_get_nir(p, service, sinst, NULL);
	klog(L_APPL_REQ,
	     "APPL REQ %s.%s@@%s for %s.%s from %s (%s/%u)",
	     ad.pname, ad.pinst, ad.prealm,
	     service, sinst,
	     inet_ntoa(client->sin_addr),
	     proto,
	     ntohs(server->sin_port));

	if(strcmp(ad.prealm, realm)){
	    msg = klog(L_ERR_UNK, "Can't hop realms: %s -> %s", 
		       realm, ad.prealm);
	    strncpy((char*)rpkt->dat, msg, MAX_KTXT_LEN - 1);
	    rpkt->dat[MAX_KTXT_LEN - 1] = '\0';
	    return KERB_ERR_PRINCIPAL_UNKNOWN;
	}

	if(!strcmp(service, "changepw")){
	    strncpy((char*)rpkt->dat, 
		   "Can't authorize password changed based on TGT",
		    MAX_KTXT_LEN - 1);
	    rpkt->dat[MAX_KTXT_LEN - 1] = '\0';
	    return KERB_ERR_PRINCIPAL_UNKNOWN;
	}

	err = check_princ(service, sinst, life, &s_name);
	if(err){
	    strncpy((char*)rpkt->dat, krb_get_err_text(err), MAX_KTXT_LEN - 1);
	    rpkt->dat[MAX_KTXT_LEN - 1] = '\0';
	    return err;
	}
	life = MIN(life, 
		   krb_time_to_life(kerb_time.tv_sec, 
				    krb_life_to_time(ad.time_sec, 
						     ad.life)));
	life = MIN(life, s_name.max_life);
	copy_to_key(&s_name.key_low, &s_name.key_high, key);
	unseal(&key);
	des_new_random_key(&session);
	krb_create_ticket(tk, flags, ad.pname, ad.pinst, ad.prealm,
			  client->sin_addr.s_addr, &session,
			  life, kerb_time.tv_sec,
			  s_name.name, s_name.instance,
			  &key);
	
	memset(&key, 0, sizeof(key));

	create_ciph(ciph, session, service, sinst, local_realm,
		    life, s_name.key_version, tk,
		    kerb_time.tv_sec, &ad.session);

	memset(&session, 0, sizeof(session));
	memset(ad.session, 0, sizeof(ad.session));
	{
	    KTEXT r;
	    r =create_auth_reply(ad.pname, ad.pinst, ad.prealm, 
				 req_time, 0, 0, 0, ciph);
	    memcpy(rpkt, r, sizeof(*rpkt));
	}
	memset(&s_name, 0, sizeof(s_name));
	return 0;
	
    case AUTH_MSG_ERR_REPLY:
	return -1;
    default:
	msg = klog(L_KRB_PERR,
		   "Unknown message type: %d from %s (%s/%u)", 
		   msg_type,
		   inet_ntoa(client->sin_addr),
		   proto,
		   ntohs(server->sin_port));
	strncpy((char*)rpkt->dat, msg, MAX_KTXT_LEN - 1);
	rpkt->dat[MAX_KTXT_LEN - 1] = '\0';
	return KFAILURE;
    }
}


static void
kerberos_wrap(int s, KTEXT data, char *proto, struct sockaddr_in *client, 
	      struct sockaddr_in *server)
{
    KTEXT_ST pkt;
    int http_flag = strcmp(proto, "http") == 0;
    int err = kerberos(data->dat, data->length, proto, client, server, &pkt);
    if(err == -1)
	return;
    if(http_flag){
	const char *msg = 
	    "HTTP/1.1 200 OK\r\n"
	    "Server: KTH-KRB/" VERSION "\r\n"
	    "Content-type: application/octet-stream\r\n"
	    "Content-transfer-encoding: binary\r\n\r\n";
	sendto(s, msg, strlen(msg), 0, (struct sockaddr *)client,
	       sizeof(*client));
    }
    if(err){
	kerb_err_reply(s, client, err, (char*)pkt.dat);
	return;
    }
    sendto(s, pkt.dat, pkt.length, 0, (struct sockaddr *)client,
	   sizeof(*client));
}


/*
 * setup_disc 
 *
 * disconnect all descriptors, remove ourself from the process
 * group that spawned us. 
 */

static void
setup_disc(void)
{
    int     s;

    for (s = 0; s < 3; s++) {
	close(s);
    }

    open("/dev/null", 0);
    dup2(0, 1);
    dup2(0, 2);

    setsid();

    chdir("/tmp");
    return;
}

/*
 * Make sure that database isn't stale.
 *
 * Exit if it is; we don't want to tell lies.
 */

static void
check_db_age(void)
{
    long age;
    
    if (max_age != -1) {
	/* Requires existance of kerb_get_db_age() */
	gettimeofday(&kerb_time, 0);
	age = kerb_get_db_age();
	if (age == 0) {
	    klog(L_KRB_PERR, "Database currently being updated!");
	    hang();
	}
	if ((age + max_age) < kerb_time.tv_sec) {
	    klog(L_KRB_PERR, "Database out of date!");
	    hang();
	    /* NOTREACHED */
	}
    }
}

struct descr{
    int s;
    KTEXT_ST buf;
    int type;
    int timeout;
    struct sockaddr_in addr;
};

static void
mksocket(struct descr *d, struct in_addr addr, int type, 
	 const char *service, int port)
{
    int     on = 1;
    int sock;

    memset(d, 0, sizeof(struct descr));
    if ((sock = socket(AF_INET, type, 0)) < 0)
	err (1, "socket");
    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&on,
		   sizeof(on)) < 0)
	warn ("setsockopt (SO_REUSEADDR)");
    memset(&d->addr, 0, sizeof(d->addr));
    d->addr.sin_family = AF_INET;
    d->addr.sin_port   = port;
    d->addr.sin_addr   = addr;
    if (bind(sock, (struct sockaddr *)&d->addr, sizeof(d->addr)) < 0)
	err (1, "bind '%s/%s' (%d)",
	     service, (type == SOCK_DGRAM) ? "udp" : "tcp",
	     ntohs(d->addr.sin_port));
    
    if(type == SOCK_STREAM)
	listen(sock, SOMAXCONN);
    d->s = sock;
    d->type = type;
}


static void loop(struct descr *fds, int maxfd);

struct port_spec {
    int port;
    int type;
};

static int
add_port(struct port_spec **ports, int *num_ports, int port, int type)
{
    struct port_spec *tmp;
    tmp = realloc(*ports, (*num_ports + 1) * sizeof(*tmp));
    if(tmp == NULL) {
        free(*ports);
	return ENOMEM;
    }
    *ports = tmp;
    tmp[*num_ports].port = port;
    tmp[*num_ports].type = type;
    (*num_ports)++;
    return 0;
}

void make_sockets(char *port_spec, struct in_addr *i_addr, 
		  struct descr **fds, int *nfds)
{
    int tp;
    struct in_addr *a;
    char *p, *q, *pos = NULL;
    struct servent *sp;
    struct port_spec *ports = NULL;
    int num_ports = 0;
    int i, j;
    

    for(p = strtok_r(port_spec, ", \t", &pos); 
	p; 
	p = strtok_r(NULL, ", \t", &pos)){
	if(strcmp(p, "+") == 0){
	    add_port(&ports, &num_ports, 88, SOCK_DGRAM);
	    add_port(&ports, &num_ports, 88, SOCK_STREAM);
	    add_port(&ports, &num_ports, 750, SOCK_DGRAM);
	    add_port(&ports, &num_ports, 750, SOCK_STREAM);
	}else{
	    q = strchr(p, '/');
	    if(q){
		*q = 0;
		q++;
	    }
	    sp = getservbyname(p, q);
	    if(sp)
		tp = ntohs(sp->s_port);
	    else if(sscanf(p, "%d", &tp) != 1) {
		warnx("Unknown port: %s%s%s", p, q ? "/" : "", q ? q : "");
		continue;
	    }
	    if(q){
		if(strcasecmp(q, "tcp") == 0)
		    add_port(&ports, &num_ports, tp, SOCK_STREAM);
		else if(strcasecmp(q, "udp") == 0)
		    add_port(&ports, &num_ports, tp, SOCK_DGRAM);
		else
		    warnx("Unknown protocol type: %s", q);
	    }else{
		add_port(&ports, &num_ports, tp, SOCK_DGRAM);
		add_port(&ports, &num_ports, tp, SOCK_STREAM);
	    }
	}
    }

    if(num_ports == 0)
	errx(1, "No valid ports specified!");
    
    if (i_addr) {
	*nfds = 1;
	a = malloc(sizeof(*a) * *nfds);
	if (a == NULL)
	    errx (1, "Failed to allocate %u bytes",
		  sizeof(*a) * *nfds);
	memcpy(a, i_addr, sizeof(struct in_addr));
    } else
	*nfds = k_get_all_addrs (&a);
    if (*nfds < 0) {
	struct in_addr any;

	any.s_addr = INADDR_ANY;

	warnx ("Could not get local addresses, binding to INADDR_ANY");
	*nfds = 1;
	a = malloc(sizeof(*a) * *nfds);
	if (a == NULL)
	    errx (1, "Failed to allocate %u bytes",
		  sizeof(*a) * *nfds);
	memcpy(a, &any, sizeof(struct in_addr));
    }
    *fds = malloc(*nfds * num_ports * sizeof(**fds));
    if (*fds == NULL)
	errx (1, "Failed to allocate %u bytes",
	      *nfds * num_ports * sizeof(**fds));
    for (i = 0; i < *nfds; i++) {
	for(j = 0; j < num_ports; j++) {
	    mksocket(*fds + num_ports * i + j, a[i], 
		     ports[j].type, "", htons(ports[j].port));
	}
    }
    *nfds *= num_ports;
    free(ports);
    free (a);
}


int
main(int argc, char **argv)
{
    int     child;
    int c;
    struct descr *fds;
    int nfds;
    int n;
    int     kerror;
    int i_flag = 0;
    struct in_addr i_addr;
    char *port_spec = "+";

    umask(077);		/* Create protected files */

    while ((c = getopt(argc, argv, "snmp:P:a:l:r:i:")) != -1) {
	switch(c) {
	case 's':
	    /*
	     * Set parameters to slave server defaults.
	     */
	    if (max_age == -1 && !nflag)
		max_age = ONE_DAY;	/* 24 hours */
	    if (pause_int == -1)
		pause_int = FIVE_MINUTES; /* 5 minutes */
	    break;
	case 'n':
	    max_age = -1;	/* don't check max age. */
	    nflag++;
	    break;
	case 'm':
	    mflag++;		/* running manually; prompt for master key */
	    break;
	case 'p':
	    /* Set pause interval. */
	    if (!isdigit(optarg[0]))
		usage();
	    pause_int = atoi(optarg);
	    if ((pause_int < 5) ||  (pause_int > ONE_HOUR)) {
		fprintf(stderr, "pause_int must be between 5 and 3600 seconds.\n");
		usage();
	    }
	    break;
	case 'P':
	    port_spec = optarg;
	    break;
	case 'a':
	    /* Set max age. */
	    if (!isdigit(optarg[0])) 
		usage();
	    max_age = atoi(optarg);
	    if ((max_age < ONE_HOUR) || (max_age > THREE_DAYS)) {
		fprintf(stderr, "max_age must be between one hour and three days, in seconds\n");
		usage();
	    }
	    break;
	case 'l':
	    /* Set alternate log file */
	    log_file = optarg;
	    break;
	case 'r':
	    /* Set realm name */
	    rflag++;
	    strncpy(local_realm, optarg, REALM_SZ - 1);
	    local_realm[REALM_SZ - 1] = '\0';
	    break;
	case 'i':
	    /* Only listen on this address */
	    if(inet_aton (optarg, &i_addr) == 0) {
		fprintf (stderr, "Bad address: %s\n", optarg);
		exit (1);
	    }
	    ++i_flag;
	    break;
	default:
	    usage();
	    break;
	}
    }
    
    if (optind == (argc-1)) {
	if (kerb_db_set_name(argv[optind]) != 0) {
	    fprintf(stderr, "Could not set alternate database name\n");
	    exit(1);
	}
	optind++;
    }

    if (optind != argc)
	usage();
	
    printf("Kerberos server starting\n");
    
    if ((!nflag) && (max_age != -1))
	printf("\tMaximum database age: %d seconds\n", max_age);
    if (pause_int != -1)
	printf("\tSleep for %d seconds on error\n", pause_int);
    else
	printf("\tSleep forever on error\n");
    if (mflag)
	printf("\tMaster key will be entered manually\n");
    
    printf("\tLog file is %s\n", log_file);

    kset_logfile(log_file);

    {
        char hostname[MAXHOSTNAMELEN];
        /* find our hostname, and use it as the instance */
        if (gethostname(hostname, sizeof(hostname)))
	    err (1, "gethostname");
	strncpy(k_instance, hostname, sizeof(k_instance) - 1);
	k_instance[sizeof(k_instance) - 1] = '\0';
    }

    make_sockets(port_spec, i_flag ? &i_addr : NULL, &fds, &nfds);

    /* do all the database and cache inits */
    if ((n = kerb_init())) {
	if (mflag) {
	    printf("Kerberos db and cache init ");
	    printf("failed = %d ...exiting\n", n);
	    exit (1);
	} else {
	    klog(L_KRB_PERR,
	    "Kerberos db and cache init failed = %d ...exiting", n);
	    hang();
	}
    }

    /* Make sure database isn't stale */
    check_db_age();
    
    /* setup master key */
    if (kdb_get_master_key (mflag, &master_key, master_key_schedule) != 0) {
      klog (L_KRB_PERR, "kerberos: couldn't get master key.");
      exit (1);
    }
    kerror = kdb_verify_master_key (&master_key, master_key_schedule, stdout);
    if (kerror < 0) {
      klog (L_KRB_PERR, "Can't verify master key.");
      memset(master_key, 0, sizeof (master_key));
      memset (master_key_schedule, 0, sizeof (master_key_schedule));
      exit (1);
    }

    master_key_version = (u_char) kerror;

    fprintf(stdout, "\nCurrent Kerberos master key version is %d\n",
	    master_key_version);
    des_init_random_number_generator(&master_key);

    if (!rflag) {
	/* Look up our local realm */
	krb_get_lrealm(local_realm, 1);
    }
    fprintf(stdout, "Local realm: %s\n", local_realm);
    fflush(stdout);

    if (set_tgtkey(local_realm)) {
	/* Ticket granting service unknown */
	klog(L_KRB_PERR, "Ticket granting ticket service unknown");
	fprintf(stderr, "Ticket granting ticket service unknown\n");
	exit(1);
    }
    if (mflag) {
	if ((child = fork()) != 0) {
	    printf("Kerberos started, PID=%d\n", child);
	    exit(0);
	}
	setup_disc();
    }
    
    klog(L_ALL_REQ, "Starting Kerberos for %s (kvno %d)", 
	 local_realm, master_key_version);
    
    /* receive loop */
    loop(fds, nfds);
    exit(1);
}


void
read_socket(struct descr *n)
{
    int b;
    struct sockaddr_in from;
    int fromlen = sizeof(from);
    b = recvfrom(n->s, n->buf.dat + n->buf.length, 
		 MAX_PKT_LEN - n->buf.length, 0, 
		 (struct sockaddr *)&from, &fromlen);
    if(b < 0){
	if(n->type == SOCK_STREAM){
	    close(n->s);
	    n->s = -1;
	}
	n->buf.length = 0;
	return;
    }
    n->buf.length += b;
    if(n->type == SOCK_STREAM){
	char *proto = "tcp";
	if(n->buf.length > 4 && 
	   strncmp((char *)n->buf.dat, "GET ", 4) == 0 &&
	   strncmp((char *)n->buf.dat + n->buf.length - 4, 
		   "\r\n\r\n", 4) == 0){
	    char *p;
	    char *save = NULL;

	    n->buf.dat[n->buf.length - 1] = 0;
	    strtok_r(n->buf.dat, " \t\r\n", &save);
	    p = strtok_r(NULL, " \t\r\n", &save);
	    if(p == NULL)
		p = "";
	    if(*p == '/') p++;
	    n->buf.length = base64_decode(p, n->buf.dat);
	    if(n->buf.length <= 0){
		const char *msg = 
		    "HTTP/1.1 404 Not found\r\n"
		    "Server: KTH-KRB/" VERSION "\r\n"
		    "Content-type: text/html\r\n"
		    "Content-transfer-encoding: 8bit\r\n\r\n"
		    "<TITLE>404 Not found</TITLE>\r\n"
		    "<H1>404 Not found</H1>\r\n"
		    "That page does not exist. Information about "
		    "<A HREF=\"http://www.pdc.kth.se/kth-krb\">KTH-KRB</A> "
		    "is available elsewhere.\r\n";
		fromlen = sizeof(from);
		if(getpeername(n->s,(struct sockaddr*)&from, &fromlen) == 0)
		    klog(L_KRB_PERR, "Unknown HTTP request from %s", 
			 inet_ntoa(from.sin_addr));
		else
		    klog(L_KRB_PERR, "Unknown HTTP request from <unknown>");
		write(n->s, msg, strlen(msg));
		close(n->s);
		n->s = -1;
		n->buf.length = 0;
		return;
	    }
	    proto = "http";
	    b = 0;
	}
	else if(n->buf.length >= 4 && n->buf.dat[0] == 0){
	    /* if this is a new type of packet (with
	       the length attached to the head of the
	       packet), and there is no more data to
	       be read, fake an old packet, so the
	       code below will work */
	    u_int32_t len;
	    krb_get_int(n->buf.dat, &len, 4, 0);
	    if(n->buf.length == len + 4){
		memmove(n->buf.dat, n->buf.dat + 4, len);
		b = 0;
	    }
	}
	if(b == 0){
	    /* handle request if there are 
	       no more bytes to read */
	    fromlen = sizeof(from);
	    getpeername(n->s,(struct sockaddr*)&from, &fromlen);
	    kerberos_wrap(n->s, &n->buf, proto, &from,
			  &n->addr);
	    n->buf.length = 0;
	    close(n->s);
	    n->s = -1;
	}
    }else{
	/* udp packets are atomic */
	kerberos_wrap(n->s, &n->buf, "udp", &from,
		      &n->addr);
	n->buf.length = 0;
    }
}

static void
loop(struct descr *fds, int nfds)
{
    for (;;) {
	int ret;
        fd_set readfds;
	struct timeval tv;
	int maxfd = 0;
	struct descr *n, *minfree;
	int accepted; /* accept at most one socket per `round' */
	
	FD_ZERO(&readfds);
	gettimeofday(&tv, NULL);
	maxfd = 0;
	minfree = NULL;
	/* Remove expired TCP sockets, and add all other 
	   to the set we are selecting on */
	for(n = fds; n < fds + nfds; n++){
	    if(n->s >= 0 && n->timeout && tv.tv_sec > n->timeout){
		kerb_err_reply(n->s, NULL, KERB_ERR_TIMEOUT, "Timeout");
		close(n->s);
		n->s = -1;
	    }
	    if(n->s < 0){
		if(minfree == NULL) minfree = n;
		continue;
	    }
	    FD_SET(n->s, &readfds);
	    maxfd = MAX(maxfd, n->s);
	}
	/* add more space for sockets */
	if(minfree == NULL){
	    int i = nfds;
	    struct descr *new;
	    nfds *=2;
	    new = realloc(fds, sizeof(struct descr) * nfds);
	    if(new){
		fds = new;
		minfree = fds + i;
		for(; i < nfds; i++) fds[i].s = -1;
	    }
	}
	ret = select(maxfd + 1, &readfds, 0, 0, 0);
	accepted = 0;
	for (n = fds; n < fds + nfds; n++){
	    if(n->s < 0) continue;
	    if (FD_ISSET(n->s, &readfds)){
		if(n->type == SOCK_STREAM && n->timeout == 0){
		    /* add accepted socket to list of sockets we are
                       selecting on */
		    int s;
		    if(accepted) continue;
		    accepted = 1;
		    s = accept(n->s, NULL, 0);
		    if(minfree == NULL){
			kerb_err_reply(s, NULL, KFAILURE, "Out of memory");
			close(s);
		    }else{
			minfree->s = s;
			minfree->type = SOCK_STREAM;
			gettimeofday(&tv, NULL);
			minfree->timeout = tv.tv_sec + 4; /* XXX */
			minfree->buf.length = 0;
			memcpy(&minfree->addr, &n->addr, sizeof(minfree->addr));
		    }
		}else
		    read_socket(n);
	    }
	}
    }
}
@


1.16
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: kerberos.c,v 1.15 1998/11/28 23:41:01 art Exp $	*/
@


1.15
log
@some external programs like to include prot.h, install it
@
text
@d1 1
a1 1
/*	$OpenBSD: kerberos.c,v 1.14 1998/08/16 02:42:11 art Exp $	*/
d692 1
a692 1
    while ((c = getopt(argc, argv, "snmp:P:a:l:r:i:")) != EOF) {
@


1.14
log
@realloc fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: kerberos.c,v 1.13 1998/07/13 19:57:19 art Exp $	*/
d62 1
a62 1
#include <prot.h>
@


1.13
log
@bigger buffer for gethostname
@
text
@d1 1
a1 1
/*	$OpenBSD: kerberos.c,v 1.12 1998/02/25 15:50:57 art Exp $	*/
d578 2
a579 1
    if(tmp == NULL)
d581 1
@


1.12
log
@nicer copyrights explaining that we are not criminals.
@
text
@d1 1
a1 1
/*	$OpenBSD: kerberos.c,v 1.11 1998/02/18 11:53:54 art Exp $	*/
d780 9
a788 4
    
    /* find our hostname, and use it as the instance */
    if (gethostname(k_instance, INST_SZ))
	err (1, "gethostname");
@


1.11
log
@OpenBSD-tags and corrections of copyrights
@
text
@d1 1
a1 1
/*	$OpenBSD: kerberos.c,v 1.10 1997/12/15 06:43:04 art Exp $	*/
d5 8
a12 1
 * This software may now be redistributed outside the US.
@


1.10
log
@incorrect use of strncat
@
text
@d1 1
a1 1
/*	$OpenBSD: kerberos.c,v 1.9 1997/12/15 05:09:39 art Exp $	*/
d4 3
d8 18
a25 3
/*
 * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute
 * of Technology.
a26 2
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
@


1.9
log
@cosmetic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kerberos.c,v 1.8 1997/12/12 05:30:14 art Exp $	*/
d107 2
a108 1
    strncat(e_msg, string, sizeof(e_msg));
@


1.8
log
@Another upgrade of kth-krb + many fixes of strcpys and unchecked pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 2
a108 1
    strncat(e_msg, string, 128);
@


1.7
log
@min/max-problem contiued.
@
text
@d1 1
d106 2
a107 2
    strcpy(e_msg, "\nKerberos error -- ");
    strcat(e_msg, string);
d218 2
a219 1
    strcpy(lastrealm, r);
d250 2
a251 1
	strcpy((char*)rpkt->dat, "Packet too short");
d260 2
a261 1
	strcpy((char*)rpkt->dat, msg);
d280 2
a281 1
	    strcpy((char*)rpkt->dat, krb_get_err_text(err));
d286 2
a287 1
	    strcpy((char*)rpkt->dat, krb_get_err_text(err));
d316 2
a317 1
	strcpy(realm, (char*)buf + 3);
d323 2
a324 1
	    strcpy((char*)rpkt->dat, msg);
d340 2
a341 1
	    strcpy((char*)rpkt->dat, msg);
d358 2
a359 1
	    strcpy((char*)rpkt->dat, msg);
d364 4
a367 2
	    strcpy((char*)rpkt->dat, 
		   "Can't authorize password changed based on TGT");
d373 2
a374 1
	    strcpy((char*)rpkt->dat, krb_get_err_text(err));
d417 2
a418 1
	strcpy((char*)rpkt->dat, msg);
d574 1
a574 1
    for(p = strtok_r(port_spec, " \t", &pos); 
d576 1
a576 1
	p = strtok_r(NULL, " \t", &pos)){
d615 3
d629 3
d635 3
d713 2
a714 1
	    strcpy(local_realm, optarg);
d757 1
a757 1
    if (k_gethostname(k_instance, INST_SZ))
d848 2
a849 2
	   strncmp(n->buf.dat, "GET ", 4) == 0 &&
	   strncmp(n->buf.dat + n->buf.length - 4, 
d852 2
d855 2
a856 2
	    strtok(n->buf.dat, " \t\r\n");
	    p = strtok(NULL, " \t\r\n");
a859 1
	    p = strdup(p);
a860 1
	    free(p);
d872 6
@


1.6
log
@The first big step towards a complete upgrade to kth-krb4-0.9.7
@
text
@d72 8
d284 2
a285 2
	life = min(life, s_name.max_life);
	life = min(life, a_name.max_life);
d364 1
a364 1
	life = min(life, 
d368 1
a368 1
	life = min(life, s_name.max_life);
d917 1
a917 1
	    maxfd = max(maxfd, n->s);
@


1.5
log
@reflect changes and new position of libdes
@
text
@d1 1
a1 1
/*	$Id: kerberos.c,v 1.4 1997/01/15 23:40:52 millert Exp $	*/
d3 4
a6 3
/*-
 * Copyright 1987, 1988 by the Student Information Processing Board
 *	of the Massachusetts Institute of Technology
d8 2
a9 11
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for any purpose and without fee is
 * hereby granted, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation,
 * and that the names of M.I.T. and the M.I.T. S.I.P.B. not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * M.I.T. and the M.I.T. S.I.P.B. make no representations about
 * the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
a11 2
#include "kerberosIV/site.h"

a17 1

d20 1
a20 5

#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>

d23 1
a23 1

d26 4
a29 1
#include <sys/socket.h>
d32 2
a37 1

d39 1
a39 5
#include <klog.h>
#include <kdc.h>

static struct sockaddr_in sina = {AF_INET};
int     f;
d41 3
a43 2
/* XXX several files in libkdb know about this */
char *progname;
a48 3
static Principal a_name_data;	/* for requesting user */
static Principal s_name_data;	/* for services requested */
static des_cblock session_key;
d55 1
a55 2
static int lflag;		/* Have we set an alterate log file? */
static char *log_file;		/* name of alt. log file */
a59 2
static u_char req_msg_type;
static u_char req_version;
d63 1
a63 3
static u_long req_time_ws;

int req_act_vno = KRB_PROT_VERSION; /* Temporary for version skew */
d67 1
a67 10
/* statistics */
static int q_bytes;		/* current bytes remaining in queue */
static int q_n;		/* how many consecutive non-zero
				 * q_bytes   */
static int max_q_bytes;
static int max_q_n;
static int n_auth_req;
static int n_appl_req;
static int n_packets;

d70 1
d78 4
a81 4
    fprintf(stderr, "Usage: %s [-s] [-m] [-n] [-p pause_seconds]%s%s\n", progname, 
	    " [-a max_age] [-l log_file] [-r realm]"
	    ," [database_pathname]"
	    );
d86 1
a86 1
 * kerb_er_reply creates an error reply packet and sends it to the
d91 1
a91 1
kerb_err_reply(struct sockaddr_in *client, KTEXT pkt, long int err, char *string)
a96 1
    bzero(e_msg, sizeof e_msg);
d101 2
a102 1
    sendto(f, e_pkt->dat, e_pkt->length, 0, (struct sockaddr*)client, S_AD_SZ);
d114 3
a116 3
	(void) snprintf(buf, sizeof(buf),
	    "Kerberos will wait %d seconds before dying so as not to loop init",
	    pause_int);
a123 23
/*
 * Given a pointer to a long containing the number of seconds
 * since the beginning of time (midnight 1 Jan 1970 GMT), return
 * a string containing the local time in the form:
 *
 * "25-Jan-88 10:17:56"
 */

static char *
strtime(time_t *t)
{
    static char st_data[40];
    static char *st = st_data;
    struct tm *tm;
    char *month_sname(int n);

    tm = localtime(t);
    (void) snprintf(st, sizeof(st_data), "%2d-%s-%02d %02d:%02d:%02d",
		    tm->tm_mday, month_sname(tm->tm_mon + 1), tm->tm_year,
                    tm->tm_hour, tm->tm_min, tm->tm_sec);
    return st;
}

a130 3
    klog(L_ALL_REQ,
	 "Principal: \"%s\", Instance: \"%s\" Lifetime = %d n = %d",
	 p_name, instance, lifetime, n, 0);
d144 1
a144 2
	lt = klog(L_ERR_UNK, "UNKNOWN \"%s\" \"%s\"", p_name,
	    instance, 0);
d149 1
a149 2
	lt = klog(L_ERR_NUN, "Principal NOT UNIQUE \"%s\" \"%s\"",
		  p_name, instance, 0);
d155 1
a155 2
	lt = klog(L_ERR_NKY, "Null key \"%s\" \"%s\"", p_name,
	    instance, 0);
d161 2
a162 3
	    "Key vers incorrect, KRB = %d, \"%s\" \"%s\" = %d",
	    master_key_version, p->name, p->instance, p->kdc_key_ver,
	    0);
d166 1
a166 1
    if ((u_long) p->exp_date < (u_long) kerb_time.tv_sec) {
d168 1
d170 2
a171 2
	    "EXPIRED \"%s\" \"%s\"  %s", p->name, p->instance,
	     strtime((time_t*)&(p->exp_date)), 0);
d178 7
d199 1
a199 1
    log("Getting key for %s", r);
d201 1
a201 1
    n = kerb_get_principal("krbtgt", r, p, 1, &more);
d206 2
a207 4
    bcopy(&p->key_low, key, 4);
    bcopy(&p->key_high, ((long *) key) + 1, 4);
    kdb_encrypt_key(&key, &key, &master_key,
		    master_key_schedule, DES_DECRYPT);
d213 6
a218 2
static void
kerberos(struct sockaddr_in *client, KTEXT pkt)
d220 36
a255 55
    static KTEXT_ST rpkt_st;
    KTEXT   rpkt = &rpkt_st;
    static KTEXT_ST ciph_st;
    KTEXT   ciph = &ciph_st;
    static KTEXT_ST tk_st;
    KTEXT   tk = &tk_st;
    static KTEXT_ST auth_st;
    KTEXT   auth = &auth_st;
    AUTH_DAT ad_st;
    AUTH_DAT *ad = &ad_st;


    static struct in_addr client_host;
    static int msg_byte_order;
    static int swap_bytes;
    static u_char k_flags;
    u_long  lifetime;
    int     i;
    des_cblock key;
    des_key_schedule key_s;
    char   *ptr;



    ciph->length = 0;

    client_host = client->sin_addr;

    /* eval macros and correct the byte order and alignment as needed */
    req_version = pkt_version(pkt);	/* 1 byte, version */
    req_msg_type = pkt_msg_type(pkt);	/* 1 byte, Kerberos msg type */

    req_act_vno = req_version;

    /* check packet version */
    if (req_version != KRB_PROT_VERSION) {
	lt = klog(L_KRB_PERR,
	"KRB prot version mismatch: KRB =%d request = %d",
		  KRB_PROT_VERSION, req_version, 0);
	/* send an error reply */
	kerb_err_reply(client, pkt, KERB_ERR_PKT_VER, lt);
	return;
    }
    msg_byte_order = req_msg_type & 1;

    swap_bytes = 0;
    if (msg_byte_order != HOST_BYTE_ORDER) {
	swap_bytes++;
    }
    klog(L_KRB_PINFO,
	"Prot version: %d, Byte order: %d, Message type: %d",
	 req_version, msg_byte_order, req_msg_type);

    switch (req_msg_type & ~1) {

d257 37
d295 4
a298 100
	    u_long  req_life;	/* Requested liftime */
	    char   *service;	/* Service name */
	    char   *instance;	/* Service instance */

	    n_auth_req++;
	    tk->length = 0;
	    k_flags = 0;	/* various kerberos flags */


	    /* set up and correct for byte order and alignment */
	    req_name_ptr = (char *) pkt_a_name(pkt);
	    req_inst_ptr = (char *) pkt_a_inst(pkt);
	    req_realm_ptr = (char *) pkt_a_realm(pkt);
	    bcopy(pkt_time_ws(pkt), &req_time_ws, sizeof(req_time_ws));
	    /* time has to be diddled */
	    if (swap_bytes) {
		swap_u_long(req_time_ws);
	    }
	    ptr = (char *) pkt_time_ws(pkt) + 4;

	    req_life = (unsigned char) (*ptr++);

	    service = ptr;
	    instance = ptr + strlen(service) + 1;

	    rpkt = &rpkt_st;
	    klog(L_INI_REQ,
	    "Initial ticket request Host: %s User: \"%s\" \"%s\"",
	       inet_ntoa(client_host), req_name_ptr, req_inst_ptr, 0);

	    if ((i = check_princ(req_name_ptr, req_inst_ptr, 0,
		&a_name_data))) {
		kerb_err_reply(client, pkt, i, lt);
		return;
	    }
	    tk->length = 0;	/* init */
	    if (strcmp(service, "krbtgt"))
		klog(L_NTGT_INTK,
		    "INITIAL request from %s.%s for %s.%s",
		     req_name_ptr, req_inst_ptr, service, instance, 0);
	    /* this does all the checking */
	    if ((i = check_princ(service, instance, 0,
		&s_name_data))) {
		kerb_err_reply(client, pkt, i, lt);
		return;
	    }
	    /* Bound requested lifetime with service and user */
	    lifetime = min(req_life, ((u_long) s_name_data.max_life));
	    lifetime = min(lifetime, ((u_long) a_name_data.max_life));

#ifdef NOENCRYPTION
	    bzero(session_key, sizeof(des_cblock));
#else
	    des_new_random_key(&session_key);
#endif
	    /* unseal server's key from master key */
	    bcopy(&s_name_data.key_low, key, 4);
	    bcopy(&s_name_data.key_high, ((long *) key) + 1, 4);
	    kdb_encrypt_key(&key, &key, &master_key,
			    master_key_schedule, DES_DECRYPT);
	    /* construct and seal the ticket */
	    krb_create_ticket(tk, k_flags, a_name_data.name,
		a_name_data.instance, local_realm,
		 client_host.s_addr, session_key, lifetime, kerb_time.tv_sec,
			 s_name_data.name, s_name_data.instance, &key);
	    bzero(key, sizeof(key));
	    bzero(key_s, sizeof(key_s));

	    /*
	     * get the user's key, unseal it from the server's key, and
	     * use it to seal the cipher 
	     */

	    /* a_name_data.key_low a_name_data.key_high */
	    bcopy(&a_name_data.key_low, key, 4);
	    bcopy(&a_name_data.key_high, ((long *) key) + 1, 4);

	    /* unseal the a_name key from the master key */
	    kdb_encrypt_key(&key, &key, &master_key, 
			    master_key_schedule, DES_DECRYPT);

	    create_ciph(ciph, session_key, s_name_data.name,
			s_name_data.instance, local_realm, lifetime,
		  s_name_data.key_version, tk, kerb_time.tv_sec, &key);

	    /* clear session key */
	    bzero(session_key, sizeof(session_key));

	    bzero(key, sizeof(key));



	    /* always send a reply packet */
	    rpkt = create_auth_reply(req_name_ptr, req_inst_ptr,
		req_realm_ptr, req_time_ws, 0, a_name_data.exp_date,
		a_name_data.key_version, ciph);
	    sendto(f, rpkt->dat, rpkt->length, 0, (struct sockaddr*)client, S_AD_SZ);
	    bzero(&a_name_data, sizeof(a_name_data));
	    bzero(&s_name_data, sizeof(s_name_data));
	    break;
d300 1
d302 42
a343 28
	{
	    u_long  time_ws;	/* Workstation time */
	    u_long  req_life;	/* Requested liftime */
	    char   *service;	/* Service name */
	    char   *instance;	/* Service instance */
	    int     kerno;	/* Kerberos error number */
	    char    tktrlm[REALM_SZ];

	    n_appl_req++;
	    tk->length = 0;
	    k_flags = 0;	/* various kerberos flags */

	    auth->length = 4 + strlen((char*)pkt->dat + 3);
	    auth->length += (int) *(pkt->dat + auth->length) +
		(int) *(pkt->dat + auth->length + 1) + 2;

	    bcopy(pkt->dat, auth->dat, auth->length);

	    strncpy(tktrlm, (char*)(auth->dat + 3), REALM_SZ);
	    if (set_tgtkey(tktrlm)) {
		lt = klog(L_ERR_UNK,
		    "FAILED realm %s unknown. Host: %s ",
			  tktrlm, inet_ntoa(client_host));
		kerb_err_reply(client, pkt, kerno, lt);
		return;
	    }
	    kerno = krb_rd_req(auth, "ktbtgt", tktrlm, client_host.s_addr,
		ad, 0);
d345 5
a349 19
	    if (kerno) {
		klog(L_ERR_UNK, "FAILED krb_rd_req from %s: %s",
		     inet_ntoa(client_host), krb_err_txt[kerno]);
		kerb_err_reply(client, pkt, kerno, "krb_rd_req failed");
		return;
	    }
	    ptr = (char *) pkt->dat + auth->length;

	    bcopy(ptr, &time_ws, 4);
	    ptr += 4;

	    req_life = (unsigned char) (*ptr++);

	    service = ptr;
	    instance = ptr + strlen(service) + 1;

	    klog(L_APPL_REQ, "APPL Request %s.%s@@%s on %s for %s.%s",
	     ad->pname, ad->pinst, ad->prealm, inet_ntoa(client_host),
		 service, instance, 0);
d351 4
a354 58
	    if (strcmp(ad->prealm, tktrlm)) {
		kerb_err_reply(client, pkt, KERB_ERR_PRINCIPAL_UNKNOWN,
		     "Can't hop realms");
		return;
	    }
	    if (!strcmp(service, "changepw")) {
		kerb_err_reply(client, pkt, KERB_ERR_PRINCIPAL_UNKNOWN,
		     "Can't authorize password changed based on TGT");
		return;
	    }
	    kerno = check_princ(service, instance, req_life,
		&s_name_data);
	    if (kerno) {
		kerb_err_reply(client, pkt, kerno, lt);
		return;
	    }
	    /* Bound requested lifetime with service and user */
	    lifetime = min(req_life,
	      krb_time_to_life(kerb_time.tv_sec,krb_life_to_time(ad->time_sec,ad->life)));
	    lifetime = min(lifetime, ((u_long) s_name_data.max_life));

	    /* unseal server's key from master key */
	    bcopy(&s_name_data.key_low, key, 4);
	    bcopy(&s_name_data.key_high, ((long *) key) + 1, 4);
	    kdb_encrypt_key(&key, &key, &master_key,
			    master_key_schedule, DES_DECRYPT);
	    /* construct and seal the ticket */

#ifdef NOENCRYPTION
	    bzero(session_key, sizeof(des_cblock));
#else
	    des_new_random_key(&session_key);
#endif

	    krb_create_ticket(tk, k_flags, ad->pname, ad->pinst,
			      ad->prealm, client_host.s_addr,
			      session_key, lifetime, kerb_time.tv_sec,
			      s_name_data.name, s_name_data.instance,
			      &key);
	    bzero(key, sizeof(key));
	    bzero(key_s, sizeof(key_s));

	    create_ciph(ciph, session_key, service, instance,
			local_realm,
			lifetime, s_name_data.key_version, tk,
			kerb_time.tv_sec, &ad->session);

	    /* clear session key */
	    bzero(session_key, sizeof(session_key));

	    bzero(ad->session, sizeof(ad->session));

	    rpkt = create_auth_reply(ad->pname, ad->pinst,
				     ad->prealm, time_ws,
				     0, 0, 0, ciph);
	    sendto(f, rpkt->dat, rpkt->length, 0, (struct sockaddr*)client, S_AD_SZ);
	    bzero(&s_name_data, sizeof(s_name_data));
	    break;
d356 15
d372 3
d376 2
a377 2
#ifdef notdef_DIE
    case AUTH_MSG_DIE:
d379 4
a382 4
	    lt = klog(L_DEATH_REQ,
	        "Host: %s User: \"%s\" \"%s\" Kerberos killed",
	        inet_ntoa(client_host), req_name_ptr, req_inst_ptr, 0);
	    exit(0);
d384 17
a400 1
#endif /* notdef_DIE */
d402 21
a422 8
    default:
	{
	    lt = klog(L_KRB_PERR,
		"Unknown message type: %d from %s port %u",
		req_msg_type, inet_ntoa(client_host),
		ntohs(client->sin_port));
	    break;
	}
d424 2
d428 1
d442 1
a442 1
	(void) close(s);
d445 3
a447 3
    (void) open("/dev/null", 0);
    (void) dup2(0, 1);
    (void) dup2(0, 2);
d451 1
a451 1
    (void) chdir("/tmp");
d461 2
a462 1
static void check_db_age(void)
d482 137
a621 3
    struct sockaddr_in from;
    register int n;
    int     on = 1;
d623 4
a626 4
    struct servent *sp;
    int     fromlen;
    static KTEXT_ST pkt_st;
    KTEXT   pkt = &pkt_st;
d628 3
a630 3
    int c;
    extern char *optarg;
    extern int optind;
d632 1
a632 1
    progname = argv[0];
d634 1
a634 1
    while ((c = getopt(argc, argv, "snmp:a:l:r:")) != -1) {
a643 4
	    if (lflag == 0) {
		log_file = KRBSLAVELOG;
		lflag++;
	    }
d662 3
a676 1
	    lflag++;
d684 8
d697 1
a697 1

d720 1
a720 1
    printf("\tLog file is %s\n", lflag ? log_file : KRBLOG);
d722 1
a722 2
    if (lflag)
	kset_logfile(log_file);
d725 2
a726 4
    if (gethostname(k_instance, INST_SZ)) {
	fprintf(stderr, "%s: gethostname error\n", progname);
	exit(1);
    }
d728 1
a728 5
    if ((sp = getservbyname("kerberos", "udp")) == 0) {
	fprintf(stderr, "%s: udp/kerberos unknown service\n", progname);
	exit(1);
    }
    sina.sin_port = sp->s_port;
a729 11
    if ((f = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
	fprintf(stderr, "%s: Can't open socket\n", progname);
	exit(1);
    }
    if (setsockopt(f, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
	fprintf(stderr, "%s: setsockopt (SO_REUSEADDR)\n", progname);

    if (bind(f, (struct sockaddr*)&sina, sizeof(sina)) < 0) {
	fprintf(stderr, "%s: Can't bind socket\n", progname);
	exit(1);
    }
d735 1
a735 1
	    exit(-1);
d748 2
a749 2
      klog (L_KRB_PERR, "kerberos: couldn't get master key.\n");
      exit (-1);
d754 3
a756 3
      bzero (master_key, sizeof (master_key));
      bzero (master_key_schedule, sizeof (master_key_schedule));
      exit (-1);
d785 4
d790 94
d885 65
a949 21
	fromlen = S_AD_SZ;
	n = recvfrom(f, pkt->dat, MAX_PKT_LEN, 0, (struct sockaddr*)&from, &fromlen);
	if (n > 0) {
	    pkt->length = n;
	    pkt->mbz = 0; /* force zeros to catch runaway strings */
	    /* see what is left in the input queue */
	    ioctl(f, FIONREAD, &q_bytes);
	    gettimeofday(&kerb_time, NULL);
	    q_n++;
	    max_q_n = max(max_q_n, q_n);
	    n_packets++;
	    klog(L_NET_INFO,
	 "q_byt %d, q_n %d, rd_byt %d, mx_q_b %d, mx_q_n %d, n_pkt %d",
		 q_bytes, q_n, n, max_q_bytes, max_q_n, n_packets, 0);
	    max_q_bytes = max(max_q_bytes, q_bytes);
	    if (!q_bytes)
		q_n = 0;	/* reset consecutive packets */
	    kerberos(&from, pkt);
	} else
	    klog(L_NET_ERR,
	    "%s: bad recvfrom n = %d errno = %d", progname, n, errno, 0);
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$Id: kerberos.c,v 1.3 1996/09/17 23:29:37 deraadt Exp $	*/
d45 1
a45 1
#include <kerberosIV/des.h>
@


1.3
log
@uncleansed buffer; from mudge@@l0pht.com
@
text
@d1 1
a1 1
/*	$Id: kerberos.c,v 1.2 1996/09/16 18:48:54 millert Exp $	*/
d630 1
a630 1
    while ((c = getopt(argc, argv, "snmp:a:l:r:")) != EOF) {
@


1.2
log
@sprintf -> snprintf paranoia
@
text
@d1 1
a1 1
/*	$Id: kerberos.c,v 1.1.1.1 1995/12/14 06:52:52 tholo Exp $	*/
d127 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id$	*/
d143 3
a145 1
	sprintf(buf,  "Kerberos will wait %d seconds before dying so as not to loop init", pause_int);
d170 3
a172 3
    (void) sprintf(st,"%2d-%s-%02d %02d:%02d:%02d",tm->tm_mday,
                   month_sname(tm->tm_mon + 1),tm->tm_year,
                   tm->tm_hour, tm->tm_min, tm->tm_sec);
@


1.1.1.1
log
@Kerberos IV code, based on a merge of fixed code from KTH and original
4.4BSD Lite code (international edition).  Provides all functionality
from the original 4.4BSD code plus standard Kerberos elements that were
omitted in the 4.4BSD code.
@
text
@@

