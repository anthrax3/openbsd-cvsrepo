head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.8
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.6
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.8
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.03.16.15.41.10;	author krw;	state Exp;
branches;
next	1.26;
commitid	JEVxsRygqcjPtWTf;

1.26
date	2015.11.25.00.29.15;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	kDFLN0ACrlU1wPUR;

1.25
date	2015.11.23.23.01.20;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	VgdALmHg2RTg5Jdl;

1.24
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Cz19p5I1S6mVZIjV;

1.23
date	2015.10.14.14.33.45;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	BweGlCJbPgfbxjH9;

1.22
date	2015.02.07.02.09.13;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	pzd3OPiuZ6mCFBtc;

1.21
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2014.05.21.17.52.26;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.25.06.43.20;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.12.17.50.47;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.12.15.26.34;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.20.02.24.38;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.03.05.03.50;	author jaredy;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.07.14.09.35;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.11.06.22.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.26.23.26.06;	author jasoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.22.20.24.55;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.05.23.17.19.22;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	97.06.25.18.40.42;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.14.04.16.53;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.06.14.04.06.27;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.04.33.54;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.04.33.54;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.27
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@/*	$OpenBSD: main.c,v 1.26 2015/11/25 00:29:15 deraadt Exp $	*/
/*	$NetBSD: main.c,v 1.1 1997/06/11 11:21:50 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/signal.h>
#include <sys/time.h>
#include <sys/mount.h>
#include <ufs/ext2fs/ext2fs_dinode.h>
#include <ufs/ext2fs/ext2fs.h>
#include <fstab.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <err.h>

#include "fsck.h"
#include "extern.h"
#include "fsutil.h"

volatile sig_atomic_t	returntosingle;

int	main(int, char *[]);

static int	argtoi(int, char *, char *, int);
static int	checkfilesys(char *, char *, long, int);
static  void usage(void);


int
main(int argc, char *argv[])
{
	int ch;
	int ret = 0;

	sync();
	skipclean = 1;
	while ((ch = getopt(argc, argv, "b:dfm:npy")) != -1) {
		switch (ch) {
		case 'b':
			skipclean = 0;
			bflag = argtoi('b', "number", optarg, 10);
			printf("Alternate super block location: %d\n", bflag);
			break;

		case 'd':
			debug = 1;
			break;

		case 'f':
			skipclean = 0;
			break;

		case 'm':
			lfmode = argtoi('m', "mode", optarg, 8);
			if (lfmode &~ 07777)
				errexit("bad mode to -m: %o\n", lfmode);
			printf("** lost+found creation mode %o\n", lfmode);
			break;

		case 'n':
			nflag = 1;
			yflag = 0;
			break;

		case 'p':
			preen = 1;
			break;

		case 'y':
			yflag = 1;
			nflag = 0;
			break;

		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void)signal(SIGINT, catch);
	if (preen)
		(void)signal(SIGQUIT, catchquit);

	(void)checkfilesys(blockcheck(*argv), 0, 0L, 0);

	if (returntosingle)
		ret = 2;

	exit(ret);
}

static int
argtoi(int flag, char *req, char *str, int base)
{
	char *cp;
	int ret;

	ret = (int)strtol(str, &cp, base);
	if (cp == str || *cp)
		errexit("-%c flag requires a %s\n", flag, req);
	return (ret);
}

/*
 * Check the specified filesystem.
 */
/* ARGSUSED */
static int
checkfilesys(char *filesys, char *mntpt, long auxdata, int child)
{
	daddr32_t n_bfree;
	struct dups *dp;
	struct zlncnt *zlnp;
	int i;

	if (preen && child)
		(void)signal(SIGQUIT, voidquit);
	setcdevname(filesys, NULL, preen);
	if (debug && preen)
		pwarn("starting\n");

	switch (setup(filesys)) {
	case 0:
		if (preen)
			pfatal("CAN'T CHECK FILE SYSTEM.");
	case -1:
		return (0);
	}
	/*
	 * 1: scan inodes tallying blocks used
	 */
	if (preen == 0) {
		if (sblock.e2fs.e2fs_rev > E2FS_REV0) {
			printf("** Last Mounted on %s\n",
			    sblock.e2fs.e2fs_fsmnt);
		}
		if (hotroot())
			printf("** Root file system\n");
		printf("** Phase 1 - Check Blocks and Sizes\n");
	}
	pass1();

	/*
	 * 1b: locate first references to duplicates, if any
	 */
	if (duplist) {
		if (preen)
			pfatal("INTERNAL ERROR: dups with -p");
		printf("** Phase 1b - Rescan For More DUPS\n");
		pass1b();
	}

	/*
	 * 2: traverse directories from root to mark all connected directories
	 */
	if (preen == 0)
		printf("** Phase 2 - Check Pathnames\n");
	pass2();

	/*
	 * 3: scan inodes looking for disconnected directories
	 */
	if (preen == 0)
		printf("** Phase 3 - Check Connectivity\n");
	pass3();

	/*
	 * 4: scan inodes looking for disconnected files; check reference counts
	 */
	if (preen == 0)
		printf("** Phase 4 - Check Reference Counts\n");
	pass4();

	/*
	 * 5: check and repair resource counts in cylinder groups
	 */
	if (preen == 0)
		printf("** Phase 5 - Check Cyl groups\n");
	pass5();

	/*
	 * print out summary statistics
	 */
	n_bfree = sblock.e2fs.e2fs_fbcount;

	pwarn("%d files, %d used, %d free\n",
	    n_files, n_blks, n_bfree);
	if (debug &&
		/* 9 reserved and unused inodes in FS */
	    (n_files -= maxino - 9 - sblock.e2fs.e2fs_ficount))
		printf("%d files missing\n", n_files);
	if (debug) {
		for (i = 0; i < sblock.e2fs_ncg; i++)
			n_blks +=  cgoverhead(i);
		n_blks += sblock.e2fs.e2fs_first_dblock;
		if (n_blks -= maxfsblock - n_bfree)
			printf("%d blocks missing\n", n_blks);
		if (duplist != NULL) {
			printf("The following duplicate blocks remain:");
			for (dp = duplist; dp; dp = dp->next)
				printf(" %d,", dp->dup);
			printf("\n");
		}
		if (zlnhead != NULL) {
			printf("The following zero link count inodes remain:");
			for (zlnp = zlnhead; zlnp; zlnp = zlnp->next)
				printf(" %llu,",
				    (unsigned long long)zlnp->zlncnt);
			printf("\n");
		}
	}
	zlnhead = NULL;
	duplist = NULL;
	muldup = NULL;
	inocleanup();
	if (fsmodified) {
		time_t t;
		(void)time(&t);
		sblock.e2fs.e2fs_wtime = t;
		sblock.e2fs.e2fs_lastfsck = t;
		sbdirty();
	}
	ckfini(1);
	free(blockmap);
	free(statemap);
	free((char *)lncntp);
	if (!fsmodified)
		return (0);
	if (!preen)
		printf("\n***** FILE SYSTEM WAS MODIFIED *****\n");
	if (rerun)
		printf("\n***** PLEASE RERUN FSCK *****\n");
	if (hotroot()) {
		struct statfs stfs_buf;
		/*
		 * We modified the root.  Do a mount update on
		 * it, unless it is read-write, so we can continue.
		 */
		if (statfs("/", &stfs_buf) == 0) {
			long flags = stfs_buf.f_flags;
			struct ufs_args args;
			int ret;

			if (flags & MNT_RDONLY) {
				args.fspec = 0;
				args.export_info.ex_flags = 0;
				args.export_info.ex_root = 0;
				flags |= MNT_UPDATE | MNT_RELOAD;
				ret = mount(MOUNT_EXT2FS, "/", flags, &args);
				if (ret == 0)
					return(0);
			}
		}
		if (!preen)
			printf("\n***** REBOOT NOW *****\n");
		sync();
		return (4);
	}
	return (0);
}

static void
usage(void)
{
	extern char *__progname;

	(void) fprintf(stderr,
	    "usage: %s [-dfnpy] [-b block#] [-m mode] filesystem\n",
	    __progname);
	exit(1);
}
@


1.26
log
@Do not do the early pledge, because hotroot() is a lie.  fsck_extfs
is not correct duid-aware by itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2015/11/23 23:01:20 deraadt Exp $	*/
d251 3
a253 3
	zlnhead = (struct zlncnt *)0;
	duplist = (struct dups *)0;
	muldup = (struct dups *)0;
@


1.25
log
@Cannot pledge() in the hotroot case
Discovered by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2015/11/23 19:19:30 deraadt Exp $	*/
a159 4

	if (!hotroot())
		if (pledge("stdio rpath wpath getpw disklabel", NULL) == -1)
			err(1, "pledge");
@


1.24
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2015/10/14 14:33:45 deraadt Exp $	*/
d161 3
a163 2
	if (pledge("stdio rpath wpath getpw disklabel", NULL) == -1)
		err(1, "pledge");
@


1.23
log
@Only accept one filesystem/device as argument for checking.  Few people
will be calling these directly, and not for the multiple filesystem case.
fsck(8) is generally the parent and will handle things.
ok semarie; this change will also help a goal jsing has
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2015/02/07 02:09:13 deraadt Exp $	*/
d47 1
d160 4
@


1.22
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2015/01/16 06:39:57 deraadt Exp $	*/
d114 1
a114 1
	if (!argc)
d122 1
a122 2
	while (argc-- > 0)
		(void)checkfilesys(blockcheck(*argv++), 0, 0L, 0);
d305 1
a305 1
	    "usage: %s [-dfnpy] [-b block#] [-m mode] filesystem ...\n",
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2014/05/21 17:52:26 krw Exp $	*/
d78 1
a78 1
			debug++;
d93 1
a93 1
			nflag++;
d98 1
a98 1
			preen++;
d102 1
a102 1
			yflag++;
@


1.20
log
@Nuke some trailing whitespace to shrink subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2013/04/25 06:43:20 otto Exp $	*/
d34 2
a35 1
#include <sys/param.h>
@


1.19
log
@big int_t/time_t fixes; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2011/03/12 17:50:47 deraadt Exp $	*/
a308 1

@


1.18
log
@These utilities can currently only operate with a 32-bit block number range,
so use daddr32_t
ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2010/08/12 15:26:34 jsing Exp $	*/
d244 2
a245 1
				printf(" %u,", zlnp->zlncnt);
@


1.17
log
@Print the real device name followed by the disklabel UID in parenthesis
when fsck is run against a disklabel UID. This allows a user to determine
which device is really being scanned.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2006/04/20 02:24:38 deraadt Exp $	*/
d149 1
a149 1
	daddr_t n_bfree;
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d156 1
a156 1
	setcdevname(filesys, preen);
@


1.15
log
@solve some signal races; from fsck_ffs; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2005/02/03 05:03:50 jaredy Exp $	*/
a32 18

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1986, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.2 (Berkeley) 1/23/94";
#else
#if 0
static char rcsid[] = "$NetBSD: main.c,v 1.1 1997/06/11 11:21:50 bouyer Exp $";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.14 2005/02/03 05:03:50 jaredy Exp $";
#endif
#endif
#endif /* not lint */
@


1.14
log
@sync usage output
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2004/04/07 14:09:35 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 2004/04/07 14:09:35 aaron Exp $";
d69 1
a69 1
int	returntosingle;
@


1.13
log
@Remove those option letters from the getopt string which do not have a case
handler below. millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2003/07/29 18:38:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 2003/07/29 18:38:35 deraadt Exp $";
d322 1
a322 1
	    "Usage: %s [-dfnpy] [-b block] [-c level] [-m mode] filesystem ...\n",
@


1.12
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2003/06/11 06:22:13 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 2003/06/11 06:22:13 deraadt Exp $";
d86 1
a86 1
	while ((ch = getopt(argc, argv, "b:c:dfm:npy")) != -1) {
@


1.11
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2003/06/02 20:06:15 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 2003/06/02 20:06:15 millert Exp $";
d240 1
a240 1
		
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2002/04/23 18:54:12 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 2002/04/23 18:54:12 espie Exp $";
d79 1
a79 3
main(argc, argv)
	int	argc;
	char	*argv[];
d149 1
a149 4
argtoi(flag, req, str, base)
	int flag;
	char *req, *str;
	int base;
d165 1
a165 4
checkfilesys(filesys, mntpt, auxdata, child)
	char *filesys, *mntpt;
	long auxdata;
	int child;
d317 1
a317 1
usage()
@


1.9
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2002/02/16 21:27:34 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 2002/02/16 21:27:34 millert Exp $";
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2000/04/26 23:26:06 jasoni Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 2000/04/26 23:26:06 jasoni Exp $";
d312 2
a313 2
				args.export.ex_flags = 0;
				args.export.ex_root = 0;
@


1.7
log
@Support for ext2fs rev. 1
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2000/01/22 20:24:55 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 2000/01/22 20:24:55 deraadt Exp $";
d75 1
a75 1
int	main __P((int, char *[]));
d77 3
a79 3
static int	argtoi __P((int, char *, char *, int));
static int	checkfilesys __P((char *, char *, long, int));
static  void usage __P((void));
@


1.6
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1999/05/23 17:19:22 aaron Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1999/05/23 17:19:22 aaron Exp $";
d66 1
a78 1
static int	docheck __P((struct fstab *));
a169 16
 * Determine whether a filesystem should be checked.
 */
static int
docheck(fsp)
	register struct fstab *fsp;
{

	if ( strcmp(fsp->fs_vfstype, "ext2fs") ||
	    (strcmp(fsp->fs_type, FSTAB_RW) &&
	     strcmp(fsp->fs_type, FSTAB_RO)) ||
	    fsp->fs_passno == 0)
		return (0);
	return (1);
}

/*
d182 1
a182 1
	int cylno;
d200 4
d260 2
a261 1
		n_blks += sblock.e2fs_ncg * cgoverhead;
d278 3
a280 3
	zlnhead = NULL;
	duplist = NULL;
	muldup = NULL;
@


1.5
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1997/06/25 18:40:42 kstailey Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1997/06/25 18:40:42 kstailey Exp $";
a88 2
	extern char *optarg;
	extern int optind;
@


1.4
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1997/06/14 04:16:53 downsj Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: main.c,v 1.3 1997/06/14 04:16:53 downsj Exp $";
d94 1
a94 1
	while ((ch = getopt(argc, argv, "b:c:dfm:npy")) != EOF) {
@


1.3
log
@Add tags, fix man page.  Purely cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD$";
d291 3
a293 3
	zlnhead = (struct zlncnt *)0;
	duplist = (struct dups *)0;
	muldup = (struct dups *)0;
@


1.2
log
@Sync with NetBSD.  Purely cosmetic.
@
text
@d1 1
d48 1
d50 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/*	$NetBSD: main.c,v 1.23 1996/10/22 16:35:04 christos Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d4 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: main.c,v 1.23 1996/10/22 16:35:04 christos Exp $";
@


1.1.1.1
log
@Initial import of Manuel's fsck_ext2fs, unmodified.
@
text
@@
