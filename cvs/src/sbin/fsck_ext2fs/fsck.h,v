head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.10
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.14
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.24
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.22
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.18
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.20
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.16
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.14
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.12
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.10
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.01.19.18.20.47;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	1CWwCgfv5daBoWlX;

1.11
date	2014.05.22.14.04.41;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.12.17.50.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.30.13.56.16;	author niallo;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.11.04.42.25;	author david;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.26.23.26.05;	author jasoni;	state Exp;
branches;
next	1.3;

1.3
date	97.06.14.04.16.51;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.06.14.04.06.25;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.04.33.53;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.04.33.53;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.12
log
@remove #ifndef #define blocks trying to handle lack of BUFSIZ
ok millert
@
text
@/*	$OpenBSD: fsck.h,v 1.11 2014/05/22 14:04:41 krw Exp $	*/
/*	$NetBSD: fsck.h,v 1.1 1997/06/11 11:21:47 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fsck.h	8.1 (Berkeley) 6/5/93
 */

#define	MAXDUP		10	/* limit on dup blks (per inode) */
#define	MAXBAD		10	/* limit on bad blks (per inode) */
#define	MAXBUFSPACE	80*1024	/* maximum space to allocate to buffers */
#define	INOBUFSIZE	128*1024	/* size of buffer to read inodes in pass1 */

#define	USTATE	01		/* inode not allocated */
#define	FSTATE	02		/* inode is file */
#define	DSTATE	03		/* inode is directory */
#define	DFOUND	04		/* directory found during descent */
#define	DCLEAR	05		/* directory is to be cleared */
#define	FCLEAR	06		/* file is to be cleared */

/*
 * buffer cache structure.
 */
struct bufarea {
	struct bufarea	*b_next;		/* free list queue */
	struct bufarea	*b_prev;		/* free list queue */
	daddr32_t	b_bno;
	int	b_size;
	int	b_errs;
	int	b_flags;
	union {
		char	*b_buf;			/* buffer space */
		daddr32_t	*b_indir;		/* indirect block */
		struct	ext2fs *b_fs;		/* super block */
		struct	ext2_gd *b_cgd;		/* cylinder group descriptor */
		struct	ext2fs_dinode *b_dinode;	/* inode block */
	} b_un;
	char	b_dirty;
};

#define	B_INUSE 1

#define	MINBUFS		5	/* minimum number of buffers required */
struct bufarea bufhead;		/* head of list of other blks in filesys */
struct bufarea sblk;		/* file system superblock */
struct bufarea asblk;		/* first alternate superblock */
struct bufarea *pdirbp;		/* current directory contents */
struct bufarea *pbp;		/* current inode block */
struct bufarea *getdatablk(daddr32_t, long);
struct m_ext2fs sblock;

#define	dirty(bp)	(bp)->b_dirty = 1
#define	initbarea(bp) \
	(bp)->b_dirty = 0; \
	(bp)->b_bno = (daddr32_t)-1; \
	(bp)->b_flags = 0;

#define	sbdirty()	copyback_sb(&sblk); sblk.b_dirty = 1

enum fixstate {DONTKNOW, NOFIX, FIX, IGNORE};

struct inodesc {
	enum fixstate id_fix;	/* policy on fixing errors */
	int (*id_func)		/* function to be applied to blocks of inode */
(struct inodesc *);
	ino_t id_number;	/* inode number described */
	ino_t id_parent;	/* for DATA nodes, their parent */
	daddr32_t id_blkno;	/* current block number being examined */
	int id_numfrags;	/* number of frags contained in block */
	quad_t id_filesize;	/* for DATA nodes, the size of the directory */
	int id_loc;		/* for DATA nodes, current location in dir */
	int id_entryno;		/* for DATA nodes, current entry number */
	struct ext2fs_direct *id_dirp;	/* for DATA nodes, ptr to current entry */
	char *id_name;		/* for DATA nodes, name to find or enter */
	char id_type;		/* type of descriptor, DATA or ADDR */
};
/* file types */
#define	DATA	1
#define	ADDR	2

/*
 * Linked list of duplicate blocks.
 *
 * The list is composed of two parts. The first part of the
 * list (from duplist through the node pointed to by muldup)
 * contains a single copy of each duplicate block that has been
 * found. The second part of the list (from muldup to the end)
 * contains duplicate blocks that have been found more than once.
 * To check if a block has been found as a duplicate it is only
 * necessary to search from duplist through muldup. To find the
 * total number of times that a block has been found as a duplicate
 * the entire list must be searched for occurrences of the block
 * in question. The following diagram shows a sample list where
 * w (found twice), x (found once), y (found three times), and z
 * (found once) are duplicate block numbers:
 *
 *    w -> y -> x -> z -> y -> w -> y
 *    ^		     ^
 *    |		     |
 * duplist	  muldup
 */
struct dups {
	struct dups *next;
	daddr32_t dup;
};
struct dups *duplist;		/* head of dup list */
struct dups *muldup;		/* end of unique duplicate dup block numbers */

/*
 * Linked list of inodes with zero link counts.
 */
struct zlncnt {
	struct zlncnt *next;
	ino_t zlncnt;
};
struct zlncnt *zlnhead;		/* head of zero link count list */

/*
 * Inode cache data structures.
 */
struct inoinfo {
	struct	inoinfo *i_nexthash;	/* next entry in hash chain */
	struct	inoinfo	*i_child, *i_sibling, *i_parentp;
	ino_t	i_number;		/* inode number of this entry */
	ino_t	i_parent;		/* inode number of parent */
	ino_t	i_dotdot;		/* inode number of `..' */
	u_int64_t	i_isize;		/* size of inode */
	u_int	i_numblks;		/* size of block array in bytes */
	daddr32_t	i_blks[1];		/* actually longer */
} **inphead, **inpsort;
long numdirs, listmax, inplast;

long	secsize;		/* actual disk sector size */
char	nflag;			/* assume a no response */
char	yflag;			/* assume a yes response */
int	bflag;			/* location of alternate super block */
int	debug;			/* output debugging info */
int	preen;			/* just fix normal inconsistencies */
char	havesb;			/* superblock has been read */
char	skipclean;		/* skip clean file systems if preening */
int	fsmodified;		/* 1 => write done to file system */
int	fsreadfd;		/* file descriptor for reading file system */
int	fswritefd;		/* file descriptor for writing file system */
int	rerun;			/* rerun fsck.  Only used in non-preen mode */

daddr32_t	maxfsblock;		/* number of blocks in the file system */
char	*blockmap;		/* ptr to primary blk allocation map */
ino_t	maxino;			/* number of inodes in file system */
ino_t	lastino;		/* last inode in use */
char	*statemap;		/* ptr to inode state table */
u_char	*typemap;		/* ptr to inode type table */
int16_t	*lncntp;		/* ptr to link count table */

ino_t	lfdir;			/* lost & found directory inode number */
char	*lfname;		/* lost & found directory name */
int	lfmode;			/* lost & found directory creation mode */

daddr32_t	n_blks;			/* number of blocks in use */
daddr32_t	n_files;		/* number of files in use */

#define	clearinode(dp)	(*(dp) = zino)
struct	ext2fs_dinode zino;

#define	setbmap(blkno)	setbit(blockmap, blkno)
#define	testbmap(blkno)	isset(blockmap, blkno)
#define	clrbmap(blkno)	clrbit(blockmap, blkno)

#define	STOP	0x01
#define	SKIP	0x02
#define	KEEPON	0x04
#define	ALTERED	0x08
#define	FOUND	0x10

struct ext2fs_dinode *ginode(ino_t);
struct inoinfo *getinoinfo(ino_t);
void getblk(struct bufarea *, daddr32_t, long);
ino_t allocino(ino_t, int);
void copyback_sb(struct bufarea*);
daddr32_t cgoverhead(int);	/* overhead per cg */
@


1.11
log
@Nuke pointless dev_bsize variable which is always set to 512, and just
use DEV_BSIZE.

Write sizes need to be secsize and not DEV_BSIZE, just like reads.

Equivalent to changes made in fsck_ffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.10 2011/03/12 17:50:47 deraadt Exp $	*/
a39 4

#ifndef BUFSIZ
#define BUFSIZ 1024
#endif
@


1.10
log
@These utilities can currently only operate with a 32-bit block number range,
so use daddr32_t
ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.9 2005/04/30 13:56:16 niallo Exp $	*/
a163 1
long	dev_bsize;		/* computed value of DEV_BSIZE */
@


1.9
log
@Support checking filesystems which have or once had large files (>4 GB)
on them.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.8 2003/06/02 20:06:15 millert Exp $	*/
d58 1
a58 1
	daddr_t	b_bno;
d64 1
a64 1
		daddr_t	*b_indir;		/* indirect block */
d80 1
a80 1
struct bufarea *getdatablk(daddr_t, long);
d86 1
a86 1
	(bp)->b_bno = (daddr_t)-1; \
d99 1
a99 1
	daddr_t id_blkno;	/* current block number being examined */
d135 1
a135 1
	daddr_t dup;
d160 1
a160 1
	daddr_t	i_blks[1];		/* actually longer */
d178 1
a178 1
daddr_t	maxfsblock;		/* number of blocks in the file system */
d190 2
a191 2
daddr_t	n_blks;			/* number of blocks in use */
daddr_t	n_files;		/* number of files in use */
d208 1
a208 1
void getblk(struct bufarea *, daddr_t, long);
d211 1
a211 1
daddr_t cgoverhead(int);	/* overhead per cg */
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.7 2003/03/11 04:42:25 david Exp $	*/
d158 1
a158 1
	size_t	i_isize;		/* size of inode */
@


1.7
log
@spelling
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.6 2002/06/09 08:13:05 todd Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.5 2002/02/16 21:27:34 millert Exp $	*/
d127 1
a127 1
 * the entire list must be searched for occurences of the block
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.4 2000/04/26 23:26:05 jasoni Exp $	*/
d118 1
a118 1
 * 
d121 1
a121 1
 * contains a single copy of each duplicate block that has been 
d125 1
a125 1
 * necessary to search from duplist through muldup. To find the 
@


1.4
log
@Support for ext2fs rev. 1
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.h,v 1.3 1997/06/14 04:16:51 downsj Exp $	*/
d84 1
a84 1
struct bufarea *getdatablk __P((daddr_t, long));
d100 1
a100 1
	    __P((struct inodesc *));
d210 6
a215 6
struct ext2fs_dinode *ginode __P((ino_t));
struct inoinfo *getinoinfo __P((ino_t));
void getblk __P((struct bufarea *, daddr_t, long));
ino_t allocino __P((ino_t, int));
void copyback_sb __P((struct bufarea*));
daddr_t cgoverhead __P((int));	/* overhead per cg */
@


1.3
log
@Add tags, fix man page.  Purely cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a69 1
		struct	m_ext2fs *b_fs;		/* super block */
d81 1
d85 1
d93 1
a93 4
#define	sbdirty()	sblk.b_dirty = 1
#define	cgdirty()	cgblk.b_dirty = 1
#define	sblock		(*sblk.b_un.b_fs)
#define	cgrp		(*cgblk.b_un.b_cg)
a182 1
daddr_t cgoverhead;		/* overhead per cg */
d187 1
d214 2
@


1.2
log
@Sync with NetBSD.  Purely cosmetic.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/*	$NetBSD: fsck.h,v 1.13 1996/10/11 20:15:46 thorpej Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d4 1
@


1.1.1.1
log
@Initial import of Manuel's fsck_ext2fs, unmodified.
@
text
@@
