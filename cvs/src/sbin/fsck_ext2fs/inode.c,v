head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.22
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.20
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.16
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.18
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.14
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.12
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.10
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.12.16.17.44.59;	author krw;	state Exp;
branches;
next	1.26;
commitid	q7MaMOobu9Z5raUb;

1.26
date	2016.04.28.12.17.15;	author krw;	state Exp;
branches;
next	1.25;
commitid	A4fdskp72gjrZWxe;

1.25
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Uu5nFG3wCl0LACBb;

1.24
date	2014.10.29.06.31.58;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	daycD6ptETsDdA7O;

1.23
date	2014.10.08.16.28.12;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	YPqg8fL1wpbACaEM;

1.22
date	2014.07.13.16.08.53;	author pelikan;	state Exp;
branches;
next	1.21;
commitid	tQBfngCdLJGooLWH;

1.21
date	2014.07.11.13.50.01;	author pelikan;	state Exp;
branches;
next	1.20;
commitid	myGiKUmoVoP9PH5w;

1.20
date	2014.05.21.17.52.26;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.24.13.46.27;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.17.03.33.06;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.12.17.50.47;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.06.17.43.13;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.30.13.56.16;	author niallo;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.17.06.48.47;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.18.17.43.15;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.15.19.37.55;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.26.23.26.06;	author jasoni;	state Exp;
branches;
next	1.5;

1.5
date	99.08.06.20.41.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.25.18.40.40;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.14.04.16.53;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.06.14.04.06.26;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.04.33.54;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.04.33.54;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Eliminate some gcc warnings about 'unused variables', mostly by
adding appropriate #ifdef's around declarations.

ok millert@@ (with a tweak I will commit separately)
@
text
@/*	$OpenBSD: inode.c,v 1.26 2016/04/28 12:17:15 krw Exp $	*/
/*	$NetBSD: inode.c,v 1.8 2000/01/28 16:01:46 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* btodb */
#include <sys/time.h>
#include <ufs/ext2fs/ext2fs_dinode.h>
#include <ufs/ext2fs/ext2fs_dir.h>
#include <ufs/ext2fs/ext2fs.h>

#include <ufs/ufs/dinode.h> /* for IFMT & friends */
#ifndef SMALL
#include <pwd.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <limits.h>

#include "fsck.h"
#include "fsutil.h"
#include "extern.h"

/*
 * CG is stored in fs byte order in memory, so we can't use ino_to_fsba
 * here.
 */

#define fsck_ino_to_fsba(fs, x) \
	(letoh32((fs)->e2fs_gd[ino_to_cg(fs, x)].ext2bgd_i_tables) + \
	(((x)-1) % (fs)->e2fs.e2fs_ipg)/(fs)->e2fs_ipb)

static ino_t startinum;

static int iblock(struct inodesc *, long, u_int64_t);
static int setlarge(void);

static int
setlarge(void)
{
	if (sblock.e2fs.e2fs_rev < E2FS_REV1) {
		pfatal("LARGE FILES UNSUPPORTED ON REVISION 0 FILESYSTEMS");
		return 0;
	}
	if (!(sblock.e2fs.e2fs_features_rocompat & EXT2F_ROCOMPAT_LARGEFILE)) {
		if (preen)
			pwarn("SETTING LARGE FILE INDICATOR\n");
		else if (!reply("SET LARGE FILE INDICATOR"))
			return 0;
		sblock.e2fs.e2fs_features_rocompat |= EXT2F_ROCOMPAT_LARGEFILE;
		sbdirty();
	}
	return 1;
}

u_int64_t
inosize(struct ext2fs_dinode *dp)
{
	u_int64_t size = letoh32(dp->e2di_size);

	if ((letoh16(dp->e2di_mode) & IFMT) == IFREG)
		size |= (u_int64_t)letoh32(dp->e2di_size_hi) << 32;
	if (size >= 0x80000000U)
		 (void)setlarge();
	 return size;
}

void
inossize(struct ext2fs_dinode *dp, u_int64_t size)
{
	if ((letoh16(dp->e2di_mode) & IFMT) == IFREG) {
		dp->e2di_size_hi = htole32(size >> 32);
		if (size >= 0x80000000U)
			if (!setlarge())
				return;
	} else if (size >= 0x80000000U) {
		pfatal("TRYING TO SET FILESIZE TO %llu ON MODE %x FILE\n",
		    (unsigned long long)size, letoh16(dp->e2di_mode) & IFMT);
		return;
	}
	dp->e2di_size = htole32(size);
}

int
ckinode(struct ext2fs_dinode *dp, struct inodesc *idesc)
{
	u_int32_t *ap;
	long ret, n, ndb;
	struct ext2fs_dinode dino;
	u_int64_t remsize, sizepb;
	mode_t mode;
	char pathbuf[PATH_MAX + 1];

	if (idesc->id_fix != IGNORE)
		idesc->id_fix = DONTKNOW;
	idesc->id_entryno = 0;
	idesc->id_filesize = inosize(dp);
	mode = letoh16(dp->e2di_mode) & IFMT;
	if (mode == IFBLK || mode == IFCHR || mode == IFIFO ||
	    (mode == IFLNK && (inosize(dp) < EXT2_MAXSYMLINKLEN)))
		return (KEEPON);
	dino = *dp;
	ndb = howmany(inosize(&dino), sblock.e2fs_bsize);
	for (ap = &dino.e2di_blocks[0]; ap < &dino.e2di_blocks[NDADDR];
																ap++,ndb--) {
		idesc->id_numfrags = 1;
		if (*ap == 0) {
			if (idesc->id_type == DATA && ndb > 0) {
				/* An empty block in a directory XXX */
				getpathname(pathbuf, sizeof pathbuf,
				    idesc->id_number, idesc->id_number);
				pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
				    pathbuf);
				if (reply("ADJUST LENGTH") == 1) {
					dp = ginode(idesc->id_number);
					inossize(dp,
					    (ap - &dino.e2di_blocks[0]) *
					    sblock.e2fs_bsize);
					printf(
					    "YOU MUST RERUN FSCK AFTERWARDS\n");
					rerun = 1;
					inodirty();
				}
			}
			continue;
		}
		idesc->id_blkno = letoh32(*ap);
		if (idesc->id_type == ADDR)
			ret = (*idesc->id_func)(idesc);
		else
			ret = dirscan(idesc);
		if (ret & STOP)
			return (ret);
	}
	idesc->id_numfrags = 1;
	remsize = inosize(&dino) - sblock.e2fs_bsize * NDADDR;
	sizepb = sblock.e2fs_bsize;
	for (ap = &dino.e2di_blocks[NDADDR], n = 1; n <= NIADDR; ap++, n++) {
		if (*ap) {
			idesc->id_blkno = letoh32(*ap);
			ret = iblock(idesc, n, remsize);
			if (ret & STOP)
				return (ret);
		} else {
			if (idesc->id_type == DATA && remsize > 0) {
				/* An empty block in a directory XXX */
				getpathname(pathbuf, sizeof pathbuf,
				    idesc->id_number, idesc->id_number);
				pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
				    pathbuf);
				if (reply("ADJUST LENGTH") == 1) {
					dp = ginode(idesc->id_number);
					inossize(dp, inosize(dp) - remsize);
					remsize = 0;
					printf(
					    "YOU MUST RERUN FSCK AFTERWARDS\n");
					rerun = 1;
					inodirty();
					break;
				}
			}
		}
		sizepb *= NINDIR(&sblock);
		remsize -= sizepb;
	}
	return (KEEPON);
}

static int
iblock(struct inodesc *idesc, long ilevel, u_int64_t isize)
{
	daddr32_t *ap;
	daddr32_t *aplim;
	struct bufarea *bp;
	int i, n, (*func)(struct inodesc *), nif;
	u_int64_t sizepb;
	char buf[BUFSIZ];
	char pathbuf[PATH_MAX + 1];
	struct ext2fs_dinode *dp;

	if (idesc->id_type == ADDR) {
		func = idesc->id_func;
		if (((n = (*func)(idesc)) & KEEPON) == 0)
			return (n);
	} else
		func = dirscan;
	if (chkrange(idesc->id_blkno, idesc->id_numfrags))
		return (SKIP);
	bp = getdatablk(idesc->id_blkno, sblock.e2fs_bsize);
	ilevel--;
	for (sizepb = sblock.e2fs_bsize, i = 0; i < ilevel; i++)
		sizepb *= NINDIR(&sblock);
	if (isize > sizepb * NINDIR(&sblock))
		nif = NINDIR(&sblock);
	else
		nif = howmany(isize, sizepb);
	if (idesc->id_func == pass1check &&
		nif < NINDIR(&sblock)) {
		aplim = &bp->b_un.b_indir[NINDIR(&sblock)];
		for (ap = &bp->b_un.b_indir[nif]; ap < aplim; ap++) {
			if (*ap == 0)
				continue;
			(void)snprintf(buf, sizeof(buf),
			    "PARTIALLY TRUNCATED INODE I=%llu",
			    (unsigned long long)idesc->id_number);
			if (dofix(idesc, buf)) {
				*ap = 0;
				dirty(bp);
			}
		}
		flush(fswritefd, bp);
	}
	aplim = &bp->b_un.b_indir[nif];
	for (ap = bp->b_un.b_indir; ap < aplim; ap++) {
		if (*ap) {
			idesc->id_blkno = letoh32(*ap);
			if (ilevel == 0)
				n = (*func)(idesc);
			else
				n = iblock(idesc, ilevel, isize);
			if (n & STOP) {
				bp->b_flags &= ~B_INUSE;
				return (n);
			}
		} else {
			if (idesc->id_type == DATA && isize > 0) {
				/* An empty block in a directory XXX */
				getpathname(pathbuf, sizeof pathbuf,
				    idesc->id_number, idesc->id_number);
				pfatal("DIRECTORY %s: CONTAINS EMPTY BLOCKS",
				    pathbuf);
				if (reply("ADJUST LENGTH") == 1) {
					dp = ginode(idesc->id_number);
					inossize(dp, inosize(dp) - isize);
					isize = 0;
					printf(
					    "YOU MUST RERUN FSCK AFTERWARDS\n");
					rerun = 1;
					inodirty();
					bp->b_flags &= ~B_INUSE;
					return(STOP);
				}
			}
		}
		isize -= sizepb;
	}
	bp->b_flags &= ~B_INUSE;
	return (KEEPON);
}

/*
 * Check that a block in a legal block number.
 * Return 0 if in range, 1 if out of range.
 */
int
chkrange(daddr32_t blk, int cnt)
{
	int c, overh;

	if ((unsigned)(blk + cnt) > maxfsblock)
		return (1);
	c = dtog(&sblock, blk);
	overh = cgoverhead(c);
	if (blk < sblock.e2fs.e2fs_bpg * c + overh +
	    sblock.e2fs.e2fs_first_dblock) {
		if ((blk + cnt) > sblock.e2fs.e2fs_bpg * c + overh +
		    sblock.e2fs.e2fs_first_dblock) {
			if (debug) {
				printf("blk %d < cgdmin %d;",
				    blk, sblock.e2fs.e2fs_bpg * c + overh +
				    sblock.e2fs.e2fs_first_dblock);
				printf(" blk + cnt %d > cgsbase %d\n",
				    blk + cnt, sblock.e2fs.e2fs_bpg * c +
				    overh + sblock.e2fs.e2fs_first_dblock);
			}
			return (1);
		}
	} else {
		if ((blk + cnt) > sblock.e2fs.e2fs_bpg * (c + 1) + overh +
		    sblock.e2fs.e2fs_first_dblock) {
			if (debug)  {
				printf("blk %d >= cgdmin %d;",
				    blk, sblock.e2fs.e2fs_bpg * c + overh +
				    sblock.e2fs.e2fs_first_dblock);
				printf(" blk + cnt %d > cgdmax %d\n",
				    blk+cnt, sblock.e2fs.e2fs_bpg * (c + 1) +
				    overh + sblock.e2fs.e2fs_first_dblock);
			}
			return (1);
		}
	}
	return (0);
}

/*
 * General purpose interface for reading inodes.
 */
struct ext2fs_dinode *
ginode(ino_t inumber)
{
	daddr32_t iblk;

	if ((inumber < EXT2_FIRSTINO && inumber != EXT2_ROOTINO)
		|| inumber > maxino)
		errexit("bad inode number %llu to ginode\n",
		    (unsigned long long)inumber);
	if (startinum == 0 ||
	    inumber < startinum || inumber >= startinum + sblock.e2fs_ipb) {
		iblk = fsck_ino_to_fsba(&sblock, inumber);
		if (pbp != 0)
			pbp->b_flags &= ~B_INUSE;
		pbp = getdatablk(iblk, sblock.e2fs_bsize);
		startinum = ((inumber -1) / sblock.e2fs_ipb) * sblock.e2fs_ipb + 1;
	}
	return (&pbp->b_un.b_dinode[(inumber-1) % sblock.e2fs_ipb]);
}

/*
 * Special purpose version of ginode used to optimize first pass
 * over all the inodes in numerical order.
 */
ino_t nextino, lastinum;
long readcnt, readpercg, fullcnt, inobufsize, partialcnt, partialsize;
struct ext2fs_dinode *inodebuf;

struct ext2fs_dinode *
getnextinode(ino_t inumber)
{
	long size;
	daddr32_t dblk;
	struct ext2fs_dinode *dp;
	static char *bp;

	if (inumber != nextino++ || inumber > maxino)
		errexit("bad inode number %llu to nextinode\n",
		    (unsigned long long)inumber);
	if (inumber >= lastinum) {
		readcnt++;
		dblk = fsbtodb(&sblock, fsck_ino_to_fsba(&sblock, lastinum));
		if (readcnt % readpercg == 0) {
			size = partialsize;
			lastinum += partialcnt;
		} else {
			size = inobufsize;
			lastinum += fullcnt;
		}
		(void)bread(fsreadfd, (char *)inodebuf, dblk, size);
		bp = (char *)inodebuf;
	}

	dp = (struct ext2fs_dinode *)bp;
	bp += EXT2_DINODE_SIZE(&sblock);

	return (dp);
}

void
resetinodebuf(void)
{

	startinum = 0;
	nextino = 1;
	lastinum = 1;
	readcnt = 0;
	inobufsize = blkroundup(&sblock, INOBUFSIZE);
	fullcnt = inobufsize / EXT2_DINODE_SIZE(&sblock);
	readpercg = sblock.e2fs.e2fs_ipg / fullcnt;
	partialcnt = sblock.e2fs.e2fs_ipg % fullcnt;
	partialsize = partialcnt * EXT2_DINODE_SIZE(&sblock);
	if (partialcnt != 0) {
		readpercg++;
	} else {
		partialcnt = fullcnt;
		partialsize = inobufsize;
	}
	if (inodebuf == NULL &&
	    (inodebuf = malloc((unsigned)inobufsize)) == NULL)
		errexit("Cannot allocate space for inode buffer\n");
	while (nextino < EXT2_ROOTINO)
		(void)getnextinode(nextino);
}

void
freeinodebuf(void)
{

	if (inodebuf != NULL)
		free((char *)inodebuf);
	inodebuf = NULL;
}

/*
 * Routines to maintain information about directory inodes.
 * This is built during the first pass and used during the
 * second and third passes.
 *
 * Enter inodes into the cache.
 */
void
cacheino(struct ext2fs_dinode *dp, ino_t inumber)
{
	struct inoinfo *inp;
	struct inoinfo **inpp;
	unsigned int blks;

	blks = howmany(inosize(dp), sblock.e2fs_bsize);
	if (blks > NDADDR)
		blks = NDADDR + NIADDR;
	inp = malloc(sizeof(*inp) + (blks - 1) * sizeof(daddr32_t));
	if (inp == NULL)
		return;
	inpp = &inphead[inumber % numdirs];
	inp->i_nexthash = *inpp;
	*inpp = inp;
	inp->i_child = inp->i_sibling = inp->i_parentp = 0;
	if (inumber == EXT2_ROOTINO)
		inp->i_parent = EXT2_ROOTINO;
	else
		inp->i_parent = (ino_t)0;
	inp->i_dotdot = (ino_t)0;
	inp->i_number = inumber;
	inp->i_isize = inosize(dp);
	inp->i_numblks = blks * sizeof(daddr32_t);
	memcpy(&inp->i_blks[0], &dp->e2di_blocks[0], (size_t)inp->i_numblks);
	if (inplast == listmax) {
		listmax += 100;
		inpsort = reallocarray(inpsort, listmax,
		    sizeof(struct inoinfo *));
		if (inpsort == NULL)
			errexit("cannot increase directory list\n");
	}
	inpsort[inplast++] = inp;
}

/*
 * Look up an inode cache structure.
 */
struct inoinfo *
getinoinfo(ino_t inumber)
{
	struct inoinfo *inp;

	for (inp = inphead[inumber % numdirs]; inp; inp = inp->i_nexthash) {
		if (inp->i_number != inumber)
			continue;
		return (inp);
	}
	errexit("cannot find inode %llu\n", (unsigned long long)inumber);
	return (NULL);
}

/*
 * Clean up all the inode cache structure.
 */
void
inocleanup(void)
{
	struct inoinfo **inpp;

	if (inphead == NULL)
		return;
	for (inpp = &inpsort[inplast - 1]; inpp >= inpsort; inpp--)
		free((char *)(*inpp));
	free((char *)inphead);
	free((char *)inpsort);
	inphead = inpsort = NULL;
}

void
inodirty(void)
{

	dirty(pbp);
}

void
clri(struct inodesc *idesc, char *type, int flag)
{
	struct ext2fs_dinode *dp;

	dp = ginode(idesc->id_number);
	if (flag == 1) {
		pwarn("%s %s", type,
		    (dp->e2di_mode & IFMT) == IFDIR ? "DIR" : "FILE");
		pinode(idesc->id_number);
	}
	if (preen || reply("CLEAR") == 1) {
		if (preen)
			printf(" (CLEARED)\n");
		n_files--;
		(void)ckinode(dp, idesc);
		clearinode(dp);
		statemap[idesc->id_number] = USTATE;
		inodirty();
	}
}

int
findname(struct inodesc *idesc)
{
	struct ext2fs_direct *dirp = idesc->id_dirp;
	u_int16_t namlen = dirp->e2d_namlen;

	if (letoh32(dirp->e2d_ino) != idesc->id_parent)
		return (KEEPON);
	memcpy(idesc->id_name, dirp->e2d_name, (size_t)namlen);
	idesc->id_name[namlen] = '\0';
	return (STOP|FOUND);
}

int
findino(struct inodesc *idesc)
{
	struct ext2fs_direct *dirp = idesc->id_dirp;
	u_int32_t ino = letoh32(dirp->e2d_ino);

	if (ino == 0)
		return (KEEPON);
	if (strcmp(dirp->e2d_name, idesc->id_name) == 0 &&
	    (ino == EXT2_ROOTINO || ino >= EXT2_FIRSTINO)
		&& ino <= maxino) {
		idesc->id_parent = ino;
		return (STOP|FOUND);
	}
	return (KEEPON);
}

void
pinode(ino_t ino)
{
	struct ext2fs_dinode *dp;
	char *p;
#ifndef SMALL
	struct passwd *pw;
#endif
	time_t t;
	u_int32_t uid;

	printf(" I=%llu ", (unsigned long long)ino);
	if ((ino < EXT2_FIRSTINO && ino != EXT2_ROOTINO) || ino > maxino)
		return;
	dp = ginode(ino);
	printf(" OWNER=");
	uid = letoh16(dp->e2di_uid_low) | (letoh16(dp->e2di_uid_high) << 16);
#ifndef SMALL
	if ((pw = getpwuid((int)uid)) != 0)
		printf("%s ", pw->pw_name);
	else
#endif
		printf("%u ", (unsigned)uid);
	printf("MODE=%o\n", letoh16(dp->e2di_mode));
	if (preen)
		printf("%s: ", cdevname());
	printf("SIZE=%llu ", (long long)inosize(dp));
	t = (time_t) letoh32(dp->e2di_mtime);
	p = ctime(&t);
	printf("MTIME=%12.12s %4.4s ", &p[4], &p[20]);
}

void
blkerror(ino_t ino, char *type, daddr32_t blk)
{

	pfatal("%d %s I=%llu", blk, type, (unsigned long long)ino);
	printf("\n");
	switch (statemap[ino]) {

	case FSTATE:
		statemap[ino] = FCLEAR;
		return;

	case DSTATE:
		statemap[ino] = DCLEAR;
		return;

	case FCLEAR:
	case DCLEAR:
		return;

	default:
		errexit("BAD STATE %d TO BLKERR\n", statemap[ino]);
		/* NOTREACHED */
	}
}

/*
 * allocate an unused inode
 */
ino_t
allocino(ino_t request, int type)
{
	ino_t ino;
	struct ext2fs_dinode *dp;
	time_t t;

	if (request == 0)
		request = EXT2_ROOTINO;
	else if (statemap[request] != USTATE)
		return (0);
	for (ino = request; ino < maxino; ino++) {
		if ((ino > EXT2_ROOTINO) && (ino < EXT2_FIRSTINO))
			continue;
		if (statemap[ino] == USTATE)
			break;
	}
	if (ino == maxino)
		return (0);
	switch (type & IFMT) {
	case IFDIR:
		statemap[ino] = DSTATE;
		break;
	case IFREG:
	case IFLNK:
		statemap[ino] = FSTATE;
		break;
	default:
		return (0);
	}
	dp = ginode(ino);
	dp->e2di_blocks[0] = htole32(allocblk());
	if (dp->e2di_blocks[0] == 0) {
		statemap[ino] = USTATE;
		return (0);
	}
	dp->e2di_mode = htole16(type);
	(void)time(&t);
	dp->e2di_atime = (u_int32_t)htole32(t);
	dp->e2di_mtime = dp->e2di_ctime = dp->e2di_atime;
	dp->e2di_dtime = 0;
	inossize(dp, sblock.e2fs_bsize);
	dp->e2di_nblock = htole32(btodb(sblock.e2fs_bsize));
	n_files++;
	inodirty();
	typemap[ino] = E2IFTODT(type);
	return (ino);
}

/*
 * deallocate an inode
 */
void
freeino(ino_t ino)
{
	struct inodesc idesc;
	struct ext2fs_dinode *dp;

	memset(&idesc, 0, sizeof(struct inodesc));
	idesc.id_type = ADDR;
	idesc.id_func = pass4check;
	idesc.id_number = ino;
	dp = ginode(ino);
	(void)ckinode(dp, &idesc);
	clearinode(dp);
	inodirty();
	statemap[ino] = USTATE;
	n_files--;
}
@


1.26
log
@Fix fsck'ing. ext2fs_dinode grew extra bits to support ext4
and sizeof(struct ext2fs_dinode) had to be replaced with
EXT2_DINODE_SIZE() and such.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.25 2015/01/16 06:39:57 deraadt Exp $	*/
d563 1
d565 1
@


1.25
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.24 2014/10/29 06:31:58 deraadt Exp $	*/
d361 2
a362 1
	static struct ext2fs_dinode *dp;
d378 1
a378 1
		dp = inodebuf;
d380 5
a384 1
	return (dp++);
d396 1
a396 1
	fullcnt = inobufsize / sizeof(struct ext2fs_dinode);
d399 1
a399 1
	partialsize = partialcnt * sizeof(struct ext2fs_dinode);
@


1.24
log
@remove ugly return value casts
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.23 2014/10/08 16:28:12 deraadt Exp $	*/
d34 1
a34 1
#include <sys/param.h>
d48 1
d122 1
a122 1
	char pathbuf[MAXPATHLEN + 1];
d208 1
a208 1
	char pathbuf[MAXPATHLEN + 1];
@


1.23
log
@trivial use of reallocarray
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.22 2014/07/13 16:08:53 pelikan Exp $	*/
d401 1
a401 2
	    (inodebuf = (struct ext2fs_dinode *)malloc((unsigned)inobufsize)) ==
		NULL)
d433 1
a433 2
	inp = (struct inoinfo *)
		malloc(sizeof(*inp) + (blks - 1) * sizeof(daddr32_t));
@


1.22
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.21 2014/07/11 13:50:01 pelikan Exp $	*/
d453 2
a454 2
		inpsort = (struct inoinfo **)realloc((char *)inpsort,
		    (unsigned)listmax * sizeof(struct inoinfo *));
@


1.21
log
@fix dacl->size_hi header change
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.20 2014/05/21 17:52:26 krw Exp $	*/
d59 1
a59 1
	(fs2h32((fs)->e2fs_gd[ino_to_cg(fs, x)].ext2bgd_i_tables) + \
d88 1
a88 1
	u_int64_t size = fs2h32(dp->e2di_size);
d90 2
a91 2
	if ((fs2h16(dp->e2di_mode) & IFMT) == IFREG)
		size |= (u_int64_t)fs2h32(dp->e2di_size_hi) << 32;
d100 2
a101 2
	if ((fs2h16(dp->e2di_mode) & IFMT) == IFREG) {
		dp->e2di_size_hi = h2fs32(size >> 32);
d107 1
a107 1
		    (unsigned long long)size, fs2h16(dp->e2di_mode) & IFMT);
d110 1
a110 1
	dp->e2di_size = h2fs32(size);
d127 1
a127 1
	mode = fs2h16(dp->e2di_mode) & IFMT;
d156 1
a156 1
		idesc->id_blkno = fs2h32(*ap);
d169 1
a169 1
			idesc->id_blkno = fs2h32(*ap);
d245 1
a245 1
			idesc->id_blkno = fs2h32(*ap);
d530 1
a530 1
	if (fs2h32(dirp->e2d_ino) != idesc->id_parent)
d541 1
a541 1
	u_int32_t ino = fs2h32(dirp->e2d_ino);
d568 1
a568 1
	uid = fs2h16(dp->e2di_uid_low) | (fs2h16(dp->e2di_uid_high) << 16);
d575 1
a575 1
	printf("MODE=%o\n", fs2h16(dp->e2di_mode));
d579 1
a579 1
	t = (time_t)fs2h32(dp->e2di_mtime);
d644 1
a644 1
	dp->e2di_blocks[0] = h2fs32(allocblk());
d649 1
a649 1
	dp->e2di_mode = h2fs16(type);
d651 1
a651 1
	dp->e2di_atime = (u_int32_t)h2fs32(t);
d655 1
a655 1
	dp->e2di_nblock = h2fs32(btodb(sblock.e2fs_bsize));
@


1.20
log
@Nuke some trailing whitespace to shrink subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.19 2013/04/24 13:46:27 deraadt Exp $	*/
d91 1
a91 1
		size |= (u_int64_t)fs2h32(dp->e2di_dacl) << 32;
d101 1
a101 1
		dp->e2di_dacl = h2fs32(size >> 32);
@


1.19
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.18 2013/04/17 03:33:06 deraadt Exp $	*/
d89 1
a89 1
	
@


1.18
log
@ext2fs has a 32-bit time fields.  store a u_int32_t of the real time_t --
that should tide us over for a long time.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.17 2011/03/12 17:50:47 deraadt Exp $	*/
d233 2
a234 1
			    "PARTIALLY TRUNCATED INODE I=%u", idesc->id_number);
d334 2
a335 1
		errexit("bad inode number %d to ginode\n", inumber);
d363 2
a364 1
		errexit("bad inode number %d to nextinode\n", inumber);
d474 1
a474 1
	errexit("cannot find inode %d\n", inumber);
d563 1
a563 1
	printf(" I=%u ", ino);
d588 1
a588 1
	pfatal("%d %s I=%u", blk, type, ino);
@


1.17
log
@These utilities can currently only operate with a 32-bit block number range,
so use daddr32_t
ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.16 2005/10/06 17:43:13 pedro Exp $	*/
d576 1
a576 1
	t = fs2h32(dp->e2di_mtime);
d648 1
a648 1
	dp->e2di_atime = h2fs32(t);
@


1.16
log
@Use part of the reserved space on the disk inode to scatter 16 more bits
for the UID and GID, making them 32-bit. Based on what Linux does, with
a slightly different implementation. Endianess issue in fsck noted by
miod@@, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.15 2005/04/30 13:56:16 niallo Exp $	*/
d201 2
a202 2
	daddr_t *ap;
	daddr_t *aplim;
d284 1
a284 1
chkrange(daddr_t blk, int cnt)
d329 1
a329 1
	daddr_t iblk;
d357 1
a357 1
	daddr_t dblk;
d432 1
a432 1
		malloc(sizeof(*inp) + (blks - 1) * sizeof(daddr_t));
d446 1
a446 1
	inp->i_numblks = blks * sizeof(daddr_t);
d582 1
a582 1
blkerror(ino_t ino, char *type, daddr_t blk)
@


1.15
log
@Support checking filesystems which have or once had large files (>4 GB)
on them.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.14 2003/07/29 18:38:35 deraadt Exp $	*/
d558 1
d565 1
d567 1
a567 1
	if ((pw = getpwuid((int)dp->e2di_uid)) != 0)
d571 1
a571 1
		printf("%u ", (unsigned)fs2h16(dp->e2di_uid));
@


1.14
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.13 2003/06/11 06:22:12 deraadt Exp $	*/
d65 47
d126 1
a126 1
	idesc->id_filesize = fs2h32(dp->e2di_size);
d129 1
a129 1
	    (mode == IFLNK && (fs2h32(dp->e2di_size) < EXT2_MAXSYMLINKLEN)))
d132 1
a132 1
	ndb = howmany(fs2h32(dino.e2di_size), sblock.e2fs_bsize);
d145 2
a146 1
					dp->e2di_size = h2fs32((ap - &dino.e2di_blocks[0]) *
d165 1
a165 1
	remsize = fs2h32(dino.e2di_size) - sblock.e2fs_bsize * NDADDR;
d182 1
a182 1
					dp->e2di_size = h2fs32(fs2h32(dp->e2di_size) - remsize);
d262 1
a262 1
					dp->e2di_size = h2fs32(fs2h32(dp->e2di_size) - isize);
d428 1
a428 1
	blks = howmany(fs2h32(dp->e2di_size), sblock.e2fs_bsize);
d445 1
a445 1
	inp->i_isize = fs2h32(dp->e2di_size);
d573 1
a573 1
	printf("SIZE=%u ", fs2h32(dp->e2di_size));
d649 1
a649 1
	dp->e2di_size = h2fs32(sblock.e2fs_bsize);
@


1.13
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.12 2003/06/02 20:06:15 millert Exp $	*/
d58 1
a58 1
#define fsck_ino_to_fsba(fs, x)                      \
d443 1
a443 1
	
d447 1
a447 1
	
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.11 2003/04/17 06:48:47 tedu Exp $	*/
d67 1
a67 3
ckinode(dp, idesc)
	struct ext2fs_dinode *dp;
	struct inodesc *idesc;
d151 1
a151 4
iblock(idesc, ilevel, isize)
	struct inodesc *idesc;
	long ilevel;
	u_int64_t isize;
d236 1
a236 3
chkrange(blk, cnt)
	daddr_t blk;
	int cnt;
d279 1
a279 2
ginode(inumber)
	ino_t inumber;
d306 1
a306 2
getnextinode(inumber)
	ino_t inumber;
d331 1
a331 1
resetinodebuf()
d358 1
a358 1
freeinodebuf()
d374 1
a374 3
cacheino(dp, inumber)
	struct ext2fs_dinode *dp;
	ino_t inumber;
d414 1
a414 2
getinoinfo(inumber)
	ino_t inumber;
d431 1
a431 1
inocleanup()
d445 1
a445 1
inodirty()
d452 1
a452 4
clri(idesc, type, flag)
	struct inodesc *idesc;
	char *type;
	int flag;
d474 1
a474 2
findname(idesc)
	struct inodesc *idesc;
d487 1
a487 2
findino(idesc)
	struct inodesc *idesc;
d504 1
a504 2
pinode(ino)
	ino_t ino;
d532 1
a532 4
blkerror(ino, type, blk)
	ino_t ino;
	char *type;
	daddr_t blk;
d561 1
a561 3
allocino(request, type)
	ino_t request;
	int type;
d613 1
a613 2
freeino(ino)
	ino_t ino;
@


1.11
log
@strings.  mostly from deraadt@@, some from tdeval@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.10 2002/06/09 08:13:05 todd Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.9 2002/02/16 21:27:34 millert Exp $	*/
d98 2
a99 2
				getpathname(pathbuf, idesc->id_number,
				    idesc->id_number);
d134 2
a135 2
				getpathname(pathbuf, idesc->id_number,
				    idesc->id_number);
d217 2
a218 2
				getpathname(pathbuf, idesc->id_number,
				    idesc->id_number);
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.8 2001/09/18 17:43:15 art Exp $	*/
d516 1
a516 1
	    (ino == EXT2_ROOTINO || ino >= EXT2_FIRSTINO) 
@


1.8
log
@cleanups and endianness fixes. Mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.7 2001/05/15 19:37:55 mickey Exp $	*/
d68 1
a68 1
static int iblock __P((struct inodesc *, long, u_int64_t));
d165 1
a165 1
	int i, n, (*func) __P((struct inodesc *)), nif;
@


1.7
log
@do the same as _ffs
@
text
@d1 2
a2 2
/*	$OpenBSD: inode.c,v 1.6 2000/04/26 23:26:06 jasoni Exp $	*/
/*	$NetBSD: inode.c,v 1.1 1997/06/11 11:21:49 bouyer Exp $	*/
a37 12
#ifndef lint
#if 0
static char sccsid[] = "@@(#)inode.c	8.5 (Berkeley) 2/8/95";
#else
#if 0
static char rcsid[] = "$NetBSD: inode.c,v 1.1 1997/06/11 11:21:49 bouyer Exp $";
#else
static char rcsid[] = "$OpenBSD: inode.c,v 1.6 2000/04/26 23:26:06 jasoni Exp $";
#endif
#endif
#endif /* not lint */

d51 1
d73 1
a73 1
	register struct inodesc *idesc;
d75 1
a75 1
	register u_int32_t *ap;
d162 3
a164 3
	register daddr_t *ap;
	register daddr_t *aplim;
	register struct bufarea *bp;
d249 1
a249 2
	register int c;
	int overh;
d300 1
a300 1
		iblk = ino_to_fsba(&sblock, inumber);
d329 1
a329 1
		dblk = fsbtodb(&sblock, ino_to_fsba(&sblock, lastinum));
d388 1
a388 1
	register struct ext2fs_dinode *dp;
d391 1
a391 1
	register struct inoinfo *inp;
d395 1
a395 1
	blks = howmany(dp->e2di_size, sblock.e2fs_bsize);
d400 1
a400 2
	if (inp == NULL) {
		errexit("cannot malloc inode cache entry\n");
a401 1
	}
d412 1
a412 1
	inp->i_isize = dp->e2di_size;
d432 1
a432 1
	register struct inoinfo *inp;
d449 1
a449 1
	register struct inoinfo **inpp;
d469 1
a469 1
	register struct inodesc *idesc;
d473 1
a473 1
	register struct ext2fs_dinode *dp;
d496 2
a497 1
	register struct ext2fs_direct *dirp = idesc->id_dirp;
d499 1
a499 1
	if (dirp->e2d_ino != idesc->id_parent)
d501 2
a502 2
	memcpy(idesc->id_name, dirp->e2d_name, (size_t)dirp->e2d_namlen);
	idesc->id_name[dirp->e2d_namlen] = '\0';
d510 2
a511 1
	register struct ext2fs_direct *dirp = idesc->id_dirp;
d513 1
a513 1
	if (dirp->e2d_ino == 0)
d516 3
a518 3
	    (dirp->e2d_ino == EXT2_ROOTINO || dirp->e2d_ino >= EXT2_FIRSTINO) 
		&& dirp->e2d_ino <= maxino) {
		idesc->id_parent = dirp->e2d_ino;
d528 2
a529 2
	register struct ext2fs_dinode *dp;
	register char *p;
d539 1
a539 1
	if ((pw = getpwuid(dp->e2di_uid)) != 0)
d543 2
a544 2
		printf("%u ", (unsigned)dp->e2di_uid);
	printf("MODE=%o\n", dp->e2di_mode);
d547 2
a548 2
	printf("SIZE=%u ", dp->e2di_size);
	t = dp->e2di_mtime;
d590 2
a591 2
	register ino_t ino;
	register struct ext2fs_dinode *dp;
d618 1
a618 1
	dp->e2di_blocks[0] = allocblk();
d623 1
a623 1
	dp->e2di_mode = type;
d625 1
a625 1
	dp->e2di_atime = t;
d628 2
a629 2
	dp->e2di_size = sblock.e2fs_bsize;
	dp->e2di_nblock = btodb(sblock.e2fs_bsize);
d632 1
@


1.6
log
@Support for ext2fs rev. 1
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.5 1999/08/06 20:41:05 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.5 1999/08/06 20:41:05 deraadt Exp $";
d412 2
a413 1
	if (inp == NULL)
d415 1
@


1.5
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.4 1997/06/25 18:40:40 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.4 1997/06/25 18:40:40 kstailey Exp $";
d68 9
d87 1
a87 1
	long ret, n, ndb, offset;
d96 4
a99 4
	idesc->id_filesize = dp->e2di_size;
	mode = dp->e2di_mode & IFMT;
	if (mode == IFBLK || mode == IFCHR || (mode == IFLNK &&
	    (dp->e2di_size < EXT2_MAXSYMLINKLEN)))
d102 1
a102 1
	ndb = howmany(dino.e2di_size, sblock.e2fs_bsize);
d115 2
a116 2
					dp->e2di_size = (ap - &dino.e2di_blocks[0]) *
					    sblock.e2fs_bsize;
d125 1
a125 1
		idesc->id_blkno = *ap;
d134 1
a134 1
	remsize = dino.e2di_size - sblock.e2fs_bsize * NDADDR;
d138 1
a138 1
			idesc->id_blkno = *ap;
d151 1
a151 1
					dp->e2di_size -= remsize;
d204 2
a205 2
			(void)sprintf(buf, "PARTIALLY TRUNCATED INODE I=%u",
				idesc->id_number);
d216 1
a216 1
			idesc->id_blkno = *ap;
d234 1
a234 1
					dp->e2di_size -= isize;
d261 1
d266 5
a270 4
	if (blk < sblock.e2fs.e2fs_bpg * c + cgoverhead +
											sblock.e2fs.e2fs_first_dblock) {
		if ((blk + cnt) > sblock.e2fs.e2fs_bpg * c + cgoverhead +
											sblock.e2fs.e2fs_first_dblock) {
d273 2
a274 2
				    blk, sblock.e2fs.e2fs_bpg * c + cgoverhead +
											sblock.e2fs.e2fs_first_dblock);
d276 2
a277 2
				    blk + cnt, sblock.e2fs.e2fs_bpg * c + cgoverhead +
											sblock.e2fs.e2fs_first_dblock);
d282 2
a283 2
		if ((blk + cnt) > sblock.e2fs.e2fs_bpg * (c + 1) + cgoverhead +
											sblock.e2fs.e2fs_first_dblock) {
d286 2
a287 2
				    blk, sblock.e2fs.e2fs_bpg * c + cgoverhead +
											sblock.e2fs.e2fs_first_dblock);
d289 2
a290 2
				    blk+cnt, sblock.e2fs.e2fs_bpg * (c + 1) + cgoverhead +
											sblock.e2fs.e2fs_first_dblock);
@


1.4
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: inode.c,v 1.3 1997/06/14 04:16:53 downsj Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: inode.c,v 1.3 1997/06/14 04:16:53 downsj Exp $";
d538 1
a538 1
	if ((pw = getpwuid((int)dp->e2di_uid)) != 0)
@


1.3
log
@Add tags, fix man page.  Purely cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD$";
d441 1
a441 1
	return ((struct inoinfo *)0);
@


1.2
log
@Sync with NetBSD.  Purely cosmetic.
@
text
@d1 1
d42 1
d44 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/*	$NetBSD: inode.c,v 1.23 1996/10/11 20:15:47 thorpej Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d4 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: inode.c,v 1.23 1996/10/11 20:15:47 thorpej Exp $";
@


1.1.1.1
log
@Initial import of Manuel's fsck_ext2fs, unmodified.
@
text
@@
