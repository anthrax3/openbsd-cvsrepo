head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.24
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.22
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.18
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.20
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.16
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.14
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.08.26.06.32.06;	author otto;	state Exp;
branches;
next	1.16;
commitid	4hhfUYSiPvz9jd6w;

1.16
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	0qPuuXwccpVXsXcV;

1.15
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Uu5nFG3wCl0LACBb;

1.14
date	2014.07.13.16.08.53;	author pelikan;	state Exp;
branches;
next	1.13;
commitid	tQBfngCdLJGooLWH;

1.13
date	2013.04.24.13.46.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2011.03.12.17.50.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.30.13.56.16;	author niallo;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.11.06.22.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.18.17.43.15;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.23.26.06;	author jasoni;	state Exp;
branches;
next	1.4;

1.4
date	98.11.11.08.10.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.06.14.04.16.54;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.06.14.04.06.28;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.04.33.54;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.04.33.54;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Do not check the array but its length; based  on a netbsd commit by christos@@;
also unsigned values cannot be < 0; ok millert@@
@
text
@/*	$OpenBSD: pass1.c,v 1.16 2015/08/20 22:02:20 deraadt Exp $	*/
/*	$NetBSD: pass1.c,v 1.9 2000/01/31 11:40:12 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* setbit btodb isset */
#include <sys/time.h>
#include <ufs/ext2fs/ext2fs_dinode.h>
#include <ufs/ext2fs/ext2fs_dir.h>
#include <ufs/ext2fs/ext2fs.h>

#include <ufs/ufs/dinode.h> /* for IFMT & friends */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "fsck.h"
#include "extern.h"
#include "fsutil.h"

static daddr32_t badblk;
static daddr32_t dupblk;
static void checkinode(ino_t, struct inodesc *);

void
pass1(void)
{
	ino_t inumber;
	int c, i;
	daddr32_t dbase;
	struct inodesc idesc;

	/*
	 * Set file system reserved blocks in used block map.
	 */
	for (c = 0; c < sblock.e2fs_ncg; c++) {
		dbase = c * sblock.e2fs.e2fs_bpg +
		    sblock.e2fs.e2fs_first_dblock;
		/* Mark the blocks used for the inode table */
		if (letoh32(sblock.e2fs_gd[c].ext2bgd_i_tables) >= dbase) {
			for (i = 0; i < sblock.e2fs_itpg; i++)
				setbmap(
				    letoh32(sblock.e2fs_gd[c].ext2bgd_i_tables)
				    + i);
		}
		/* Mark the blocks used for the block bitmap */
		if (letoh32(sblock.e2fs_gd[c].ext2bgd_b_bitmap) >= dbase)
			setbmap(letoh32(sblock.e2fs_gd[c].ext2bgd_b_bitmap));
		/* Mark the blocks used for the inode bitmap */
		if (letoh32(sblock.e2fs_gd[c].ext2bgd_i_bitmap) >= dbase)
			setbmap(letoh32(sblock.e2fs_gd[c].ext2bgd_i_bitmap));

		if (sblock.e2fs.e2fs_rev == E2FS_REV0 ||
		    (sblock.e2fs.e2fs_features_rocompat &
			EXT2F_ROCOMPAT_SPARSESUPER) == 0 ||
		    cg_has_sb(c)) {
			/* Mark copuy of SB and descriptors */
			setbmap(dbase);
			for (i = 1; i <= sblock.e2fs_ngdb; i++)
				setbmap(dbase+i);
		}


		if (c == 0) {
			for(i = 0; i < dbase; i++)
				setbmap(i);
		}
	}

	/*
	 * Find all allocated blocks.
	 */
	memset(&idesc, 0, sizeof(struct inodesc));
	idesc.id_type = ADDR;
	idesc.id_func = pass1check;
	inumber = 1;
	n_files = n_blks = 0;
	resetinodebuf();
	for (c = 0; c < sblock.e2fs_ncg; c++) {
		for (i = 0;
			i < sblock.e2fs.e2fs_ipg && inumber <= sblock.e2fs.e2fs_icount;
			i++, inumber++) {
			if (inumber < EXT2_ROOTINO) /* XXX */
				continue;
			checkinode(inumber, &idesc);
		}
	}
	freeinodebuf();
}

static void
checkinode(ino_t inumber, struct inodesc *idesc)
{
	struct ext2fs_dinode *dp;
	struct zlncnt *zlnp;
	int ndb, j;
	mode_t mode;

	dp = getnextinode(inumber);
	if (inumber < EXT2_FIRSTINO && inumber != EXT2_ROOTINO)
		return;

	mode = letoh16(dp->e2di_mode) & IFMT;
	if (mode == 0 || (dp->e2di_dtime != 0 && dp->e2di_nlink == 0)) {
		if (mode == 0 && (
			memcmp(dp->e2di_blocks, zino.e2di_blocks,
			(NDADDR + NIADDR) * sizeof(u_int32_t)) ||
		    dp->e2di_mode || inosize(dp))) {
			pfatal("PARTIALLY ALLOCATED INODE I=%llu",
			    (unsigned long long)inumber);
			if (reply("CLEAR") == 1) {
				dp = ginode(inumber);
				clearinode(dp);
				inodirty();
			}
		}
#ifdef notyet /* it seems that dtime == 0 is valid for a unallocated inode */
		if (dp->e2di_dtime == 0) {
			pwarn("DELETED INODE I=%llu HAS A NULL DTIME",
			    (unsigned long long)inumber);
			if (preen) {
				printf(" (CORRECTED)\n");
			}
			if (preen || reply("CORRECT")) {
				time_t t;
				time(&t);
				dp->e2di_dtime = htole32(t);
				dp = ginode(inumber);
				inodirty();
			}
		}
#endif
		statemap[inumber] = USTATE;
		return;
	}
	lastino = inumber;
	if (dp->e2di_dtime != 0) {
		time_t t = letoh32(dp->e2di_dtime);
		char *p = ctime(&t);
		pwarn("INODE I=%llu HAS DTIME=%12.12s %4.4s",
		    (unsigned long long)inumber, &p[4], &p[20]);
		if (preen) {
			printf(" (CORRECTED)\n");
		}
		if (preen || reply("CORRECT")) {
			dp = ginode(inumber);
			dp->e2di_dtime = 0;
			inodirty();
		}
	}
	if (inosize(dp) + sblock.e2fs_bsize - 1 < inosize(dp)) {
		if (debug)
			printf("bad size %llu:", (unsigned long long)inosize(dp));
		goto unknown;
	}
	if (!preen && mode == IFMT && reply("HOLD BAD BLOCK") == 1) {
		dp = ginode(inumber);
		dp->e2di_mode = htole16(IFREG|0600);
		inossize(dp, sblock.e2fs_bsize);
		inodirty();
	}
	ndb = howmany(inosize(dp), sblock.e2fs_bsize);
	if (ndb < 0) {
		if (debug)
			printf("bad size %llu ndb %d:",
			    (unsigned long long)inosize(dp), ndb);
		goto unknown;
	}
	if (mode == IFBLK || mode == IFCHR)
		ndb++;
	if (mode == IFLNK) {
		/*
		 * Fake ndb value so direct/indirect block checks below
		 * will detect any garbage after symlink string.
		 */
		if (inosize(dp) < EXT2_MAXSYMLINKLEN ||
		    (EXT2_MAXSYMLINKLEN == 0 && htole32(dp->e2di_nblock) == 0)) {
			ndb = howmany(inosize(dp), sizeof(u_int32_t));
			if (ndb > NDADDR) {
				j = ndb - NDADDR;
				for (ndb = 1; j > 1; j--)
					ndb *= NINDIR(&sblock);
				ndb += NDADDR;
			}
		}
	}
	/* Linux puts things in blocks for FIFO, so skip this check */
	if (mode != IFIFO) {
		for (j = ndb; j < NDADDR; j++)
			if (dp->e2di_blocks[j] != 0) {
				if (debug)
					printf("bad direct addr: %d\n",
					    letoh32(dp->e2di_blocks[j]));
				goto unknown;
			}
		for (j = 0, ndb -= NDADDR; ndb > 0; j++)
			ndb /= NINDIR(&sblock);
		for (; j < NIADDR; j++) {
			if (dp->e2di_blocks[j+NDADDR] != 0) {
				if (debug)
					printf("bad indirect addr: %d\n",
					    letoh32(dp->e2di_blocks[j+NDADDR]));
				goto unknown;
			}
		}
	}
	if (ftypeok(dp) == 0)
		goto unknown;
	n_files++;
	lncntp[inumber] = letoh16(dp->e2di_nlink);
	if (dp->e2di_nlink == 0) {
		zlnp = malloc(sizeof *zlnp);
		if (zlnp == NULL) {
			pfatal("LINK COUNT TABLE OVERFLOW");
			if (reply("CONTINUE") == 0)
				errexit("%s\n", "");
		} else {
			zlnp->zlncnt = inumber;
			zlnp->next = zlnhead;
			zlnhead = zlnp;
		}
	}
	if (mode == IFDIR) {
		if (inosize(dp) == 0)
			statemap[inumber] = DCLEAR;
		else
			statemap[inumber] = DSTATE;
		cacheino(dp, inumber);
	} else {
		statemap[inumber] = FSTATE;
	}
	typemap[inumber] = E2IFTODT(mode);
	badblk = dupblk = 0;
	idesc->id_number = inumber;
	(void)ckinode(dp, idesc);
	idesc->id_entryno *= btodb(sblock.e2fs_bsize);
	if (letoh32(dp->e2di_nblock) != idesc->id_entryno) {
		pwarn("INCORRECT BLOCK COUNT I=%llu (%d should be %d)",
		    (unsigned long long)inumber,
		    letoh32(dp->e2di_nblock), idesc->id_entryno);
		if (preen)
			printf(" (CORRECTED)\n");
		else if (reply("CORRECT") == 0)
			return;
		dp = ginode(inumber);
		dp->e2di_nblock = htole32(idesc->id_entryno);
		inodirty();
	}
	return;
unknown:
	pfatal("UNKNOWN FILE TYPE I=%llu", (unsigned long long)inumber);
	statemap[inumber] = FCLEAR;
	if (reply("CLEAR") == 1) {
		statemap[inumber] = USTATE;
		dp = ginode(inumber);
		clearinode(dp);
		inodirty();
	}
}

int
pass1check(struct inodesc *idesc)
{
	int res = KEEPON;
	int anyout, nfrags;
	daddr32_t blkno = idesc->id_blkno;
	struct dups *dlp;
	struct dups *new;

	if ((anyout = chkrange(blkno, idesc->id_numfrags)) != 0) {
		blkerror(idesc->id_number, "BAD", blkno);
		if (badblk++ >= MAXBAD) {
			pwarn("EXCESSIVE BAD BLKS I=%llu",
			    (unsigned long long)idesc->id_number);
			if (preen)
				printf(" (SKIPPING)\n");
			else if (reply("CONTINUE") == 0)
				errexit("%s\n", "");
			return (STOP);
		}
	}
	for (nfrags = idesc->id_numfrags; nfrags > 0; blkno++, nfrags--) {
		if (anyout && chkrange(blkno, 1)) {
			res = SKIP;
		} else if (!testbmap(blkno)) {
			n_blks++;
			setbmap(blkno);
		} else {
			blkerror(idesc->id_number, "DUP", blkno);
			if (dupblk++ >= MAXDUP) {
				pwarn("EXCESSIVE DUP BLKS I=%lluu",
				    (unsigned long long)idesc->id_number);
				if (preen)
					printf(" (SKIPPING)\n");
				else if (reply("CONTINUE") == 0)
					errexit("%s\n", "");
				return (STOP);
			}
			new = malloc(sizeof(struct dups));
			if (new == NULL) {
				pfatal("DUP TABLE OVERFLOW.");
				if (reply("CONTINUE") == 0)
					errexit("%s\n", "");
				return (STOP);
			}
			new->dup = blkno;
			if (muldup == 0) {
				duplist = muldup = new;
				new->next = 0;
			} else {
				new->next = muldup->next;
				muldup->next = new;
			}
			for (dlp = duplist; dlp != muldup; dlp = dlp->next)
				if (dlp->dup == blkno)
					break;
			if (dlp == muldup && dlp->dup != blkno)
				muldup = new;
		}
		/*
		 * count the number of blocks found in id_entryno
		 */
		idesc->id_entryno++;
	}
	return (res);
}
@


1.16
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.15 2015/01/16 06:39:57 deraadt Exp $	*/
d207 1
a207 1
		    (EXT2_MAXSYMLINKLEN == 0 && dp->e2di_blocks == 0)) {
@


1.15
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.14 2014/07/13 16:08:53 pelikan Exp $	*/
d242 1
a242 1
		zlnp = (struct zlncnt *)malloc(sizeof *zlnp);
d329 1
a329 1
			new = (struct dups *)malloc(sizeof(struct dups));
@


1.14
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.13 2013/04/24 13:46:27 deraadt Exp $	*/
d34 1
a34 1
#include <sys/param.h>
@


1.13
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.12 2011/03/12 17:50:47 deraadt Exp $	*/
d70 1
a70 1
		if (fs2h32(sblock.e2fs_gd[c].ext2bgd_i_tables) >= dbase) {
d73 1
a73 1
				    fs2h32(sblock.e2fs_gd[c].ext2bgd_i_tables)
d77 2
a78 2
		if (fs2h32(sblock.e2fs_gd[c].ext2bgd_b_bitmap) >= dbase)
			setbmap(fs2h32(sblock.e2fs_gd[c].ext2bgd_b_bitmap));
d80 2
a81 2
		if (fs2h32(sblock.e2fs_gd[c].ext2bgd_i_bitmap) >= dbase)
			setbmap(fs2h32(sblock.e2fs_gd[c].ext2bgd_i_bitmap));
d133 1
a133 1
	mode = fs2h16(dp->e2di_mode) & IFMT;
d157 1
a157 1
				dp->e2di_dtime = h2fs32(t);
d168 1
a168 1
		time_t t = fs2h32(dp->e2di_dtime);
d188 1
a188 1
		dp->e2di_mode = h2fs16(IFREG|0600);
d223 1
a223 1
					    fs2h32(dp->e2di_blocks[j]));
d232 1
a232 1
					    fs2h32(dp->e2di_blocks[j+NDADDR]));
d240 1
a240 1
	lncntp[inumber] = fs2h16(dp->e2di_nlink);
d267 1
a267 1
	if (fs2h32(dp->e2di_nblock) != idesc->id_entryno) {
d270 1
a270 1
		    fs2h32(dp->e2di_nblock), idesc->id_entryno);
d276 1
a276 1
		dp->e2di_nblock = h2fs32(idesc->id_entryno);
@


1.12
log
@These utilities can currently only operate with a 32-bit block number range,
so use daddr32_t
ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.11 2005/04/30 13:56:16 niallo Exp $	*/
d139 2
a140 1
			pfatal("PARTIALLY ALLOCATED INODE I=%u", inumber);
d149 2
a150 1
			pwarn("DELETED INODE I=%u HAS A NULL DTIME", inumber);
d170 2
a171 1
		pwarn("INODE I=%u HAS DTIME=%12.12s %4.4s", inumber, &p[4], &p[20]);
d268 3
a270 2
		pwarn("INCORRECT BLOCK COUNT I=%u (%d should be %d)",
		    inumber, fs2h32(dp->e2di_nblock), idesc->id_entryno);
d281 1
a281 1
	pfatal("UNKNOWN FILE TYPE I=%u", inumber);
d303 2
a304 2
			pwarn("EXCESSIVE BAD BLKS I=%u",
				idesc->id_number);
d321 2
a322 2
				pwarn("EXCESSIVE DUP BLKS I=%u",
					idesc->id_number);
@


1.11
log
@Support checking filesystems which have or once had large files (>4 GB)
on them.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.10 2003/06/11 06:22:13 deraadt Exp $	*/
d51 2
a52 2
static daddr_t badblk;
static daddr_t dupblk;
d60 1
a60 1
	daddr_t dbase;
d292 1
a292 1
	daddr_t blkno = idesc->id_blkno;
@


1.10
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.9 2003/06/02 20:06:15 millert Exp $	*/
d138 1
a138 1
		    dp->e2di_mode || dp->e2di_size)) {
d178 1
a178 3
	if (/* dp->di_size < 0 || */
	    fs2h32(dp->e2di_size) + sblock.e2fs_bsize - 1 <
		fs2h32(dp->e2di_size)) {
d180 1
a180 1
			printf("bad size %lu:", (u_long)fs2h32(dp->e2di_size));
a184 1
		dp->e2di_size = h2fs32(sblock.e2fs_bsize);
d186 1
d189 1
a189 1
	ndb = howmany(fs2h32(dp->e2di_size), sblock.e2fs_bsize);
d192 2
a193 2
			printf("bad size %lu ndb %d:",
			    (u_long)fs2h32(dp->e2di_size), ndb);
d203 1
a203 1
		if (fs2h32(dp->e2di_size) < EXT2_MAXSYMLINKLEN ||
d205 1
a205 1
			ndb = howmany(fs2h32(dp->e2di_size), sizeof(u_int32_t));
d251 1
a251 1
		if (dp->e2di_size == 0)
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.8 2002/06/09 08:13:05 todd Exp $	*/
d56 1
a56 1
pass1()
d122 1
a122 3
checkinode(inumber, idesc)
	ino_t inumber;
	struct inodesc *idesc;
d290 1
a290 2
pass1check(idesc)
	struct inodesc *idesc;
@


1.8
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.7 2002/02/16 21:27:34 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.6 2001/09/18 17:43:15 art Exp $	*/
d136 1
a136 1
	if (inumber < EXT2_FIRSTINO && inumber != EXT2_ROOTINO) 
@


1.6
log
@cleanups and endianness fixes. Mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.5 2000/04/26 23:26:06 jasoni Exp $	*/
d57 1
a57 1
static void checkinode __P((ino_t, struct inodesc *));
@


1.5
log
@Support for ext2fs rev. 1
@
text
@d1 2
a2 2
/*	$OpenBSD: pass1.c,v 1.4 1998/11/11 08:10:36 deraadt Exp $	*/
/*	$NetBSD: pass1.c,v 1.1 1997/06/11 11:21:51 bouyer Exp $	*/
a37 12
#ifndef lint
#if 0
static char sccsid[] = "@@(#)pass1.c	8.1 (Berkeley) 6/5/93";
#else
#if 0
static char rcsid[] = "$NetBSD: pass1.c,v 1.1 1997/06/11 11:21:51 bouyer Exp $";
#else
static char rcsid[] = "$OpenBSD: pass1.c,v 1.4 1998/11/11 08:10:36 deraadt Exp $";
#endif
#endif
#endif /* not lint */

d128 1
a128 1
	register struct inodesc *idesc;
d130 1
a130 1
	register struct ext2fs_dinode *dp;
d297 1
a297 1
	register struct inodesc *idesc;
d302 1
a302 1
	register struct dups *dlp;
@


1.4
log
@only do block checks on files that need it, therefore explicitly avoiding
fifos (which linux handles incorrectly, leaving block numbers there at
inconvenient times); patch from krw@@tcn.net
@
text
@d1 1
a1 1
/*	$OpenBSD: pass1.c,v 1.3 1997/06/14 04:16:54 downsj Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: pass1.c,v 1.3 1997/06/14 04:16:54 downsj Exp $";
d61 1
d75 2
a76 1
	int c, i, cgd;
d83 26
a108 2
		i = c * sblock.e2fs.e2fs_bpg + sblock.e2fs.e2fs_first_dblock;
		cgd = i + cgoverhead;
d110 4
a113 4
		if (c == 0)
			i = 0;
		for (; i < cgd; i++)
			setbmap(i);
a136 2
#define MODE_USES_BLOCKS( mode ) (mode == IFREG || mode == IFDIR || mode == IFLNK)

a145 1
	char *symbuf;
d151 1
a151 1
	mode = dp->e2di_mode & IFMT;
d173 1
a173 1
				dp->e2di_dtime = t;
d184 1
a184 1
		time_t t = dp->e2di_dtime;
d197 2
a198 1
	    dp->e2di_size + sblock.e2fs_bsize - 1 < dp->e2di_size) {
d200 1
a200 1
			printf("bad size %qu:", dp->e2di_size);
d205 2
a206 2
		dp->e2di_size = sblock.e2fs_bsize;
		dp->e2di_mode = IFREG|0600;
d209 22
a230 24
	if (MODE_USES_BLOCKS( mode )) {
		ndb = howmany(dp->e2di_size, sblock.e2fs_bsize);
		if (ndb < 0) {
			if (debug)
				printf("bad size %qu ndb %d:",
					dp->e2di_size, ndb);
			goto unknown;
		}
		if (mode == IFBLK || mode == IFCHR)
			ndb++;
		if (mode == IFLNK) {
			/*
		 	 * Fake ndb value so direct/indirect block checks below
		 	 * will detect any garbage after symlink string.
		 	 */
			if (dp->e2di_size < EXT2_MAXSYMLINKLEN ||
		    	(EXT2_MAXSYMLINKLEN == 0 && dp->e2di_blocks == 0)) {
				ndb = howmany(dp->e2di_size, sizeof(u_int32_t));
				if (ndb > NDADDR) {
					j = ndb - NDADDR;
					for (ndb = 1; j > 1; j--)
						ndb *= NINDIR(&sblock);
					ndb += NDADDR;
				}
d233 3
d239 2
a240 1
					printf("bad direct addr: %d\n", dp->e2di_blocks[j]);
d245 1
a245 1
		for (; j < NIADDR; j++)
d249 1
a249 1
						dp->e2di_blocks[j+NDADDR]);
d252 1
d257 2
a258 2
	lncntp[inumber] = dp->e2di_nlink;
	if (dp->e2di_nlink <= 0) {
d279 15
a293 16
	if (MODE_USES_BLOCKS( mode )) {	
		badblk = dupblk = 0;
		idesc->id_number = inumber;
		(void)ckinode(dp, idesc);
		idesc->id_entryno *= btodb(sblock.e2fs_bsize);
		if (dp->e2di_nblock != idesc->id_entryno) {
			pwarn("INCORRECT BLOCK COUNT I=%u (%d should be %d)",
		    	inumber, dp->e2di_nblock, idesc->id_entryno);
			if (preen)
				printf(" (CORRECTED)\n");
			else if (reply("CORRECT") == 0)
				return;
			dp = ginode(inumber);
			dp->e2di_nblock = idesc->id_entryno;
			inodirty();
		}
@


1.3
log
@Add tags, fix man page.  Purely cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD$";
d111 2
d185 3
a187 27
	ndb = howmany(dp->e2di_size, sblock.e2fs_bsize);
	if (ndb < 0) {
		if (debug)
			printf("bad size %qu ndb %d:",
				dp->e2di_size, ndb);
		goto unknown;
	}
	if (mode == IFBLK || mode == IFCHR)
		ndb++;
	if (mode == IFLNK) {
		/*
		 * Fake ndb value so direct/indirect block checks below
		 * will detect any garbage after symlink string.
		 */
		if (dp->e2di_size < EXT2_MAXSYMLINKLEN ||
		    (EXT2_MAXSYMLINKLEN == 0 && dp->e2di_blocks == 0)) {
			ndb = howmany(dp->e2di_size, sizeof(u_int32_t));
			if (ndb > NDADDR) {
				j = ndb - NDADDR;
				for (ndb = 1; j > 1; j--)
					ndb *= NINDIR(&sblock);
				ndb += NDADDR;
			}
		}
	}
	for (j = ndb; j < NDADDR; j++)
		if (dp->e2di_blocks[j] != 0) {
d189 2
a190 1
				printf("bad direct addr: %d\n", dp->e2di_blocks[j]);
d193 17
a209 8
	for (j = 0, ndb -= NDADDR; ndb > 0; j++)
		ndb /= NINDIR(&sblock);
	for (; j < NIADDR; j++)
		if (dp->e2di_blocks[j+NDADDR] != 0) {
			if (debug)
				printf("bad indirect addr: %d\n",
					dp->e2di_blocks[j+NDADDR]);
			goto unknown;
d211 16
d252 16
a267 14
	badblk = dupblk = 0;
	idesc->id_number = inumber;
	(void)ckinode(dp, idesc);
	idesc->id_entryno *= btodb(sblock.e2fs_bsize);
	if (dp->e2di_nblock != idesc->id_entryno) {
		pwarn("INCORRECT BLOCK COUNT I=%u (%d should be %d)",
		    inumber, dp->e2di_nblock, idesc->id_entryno);
		if (preen)
			printf(" (CORRECTED)\n");
		else if (reply("CORRECT") == 0)
			return;
		dp = ginode(inumber);
		dp->e2di_nblock = idesc->id_entryno;
		inodirty();
@


1.2
log
@Sync with NetBSD.  Purely cosmetic.
@
text
@d1 1
d42 1
d44 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/*	$NetBSD: pass1.c,v 1.16 1996/09/27 22:45:15 christos Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d4 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: pass1.c,v 1.16 1996/09/27 22:45:15 christos Exp $";
@


1.1.1.1
log
@Initial import of Manuel's fsck_ext2fs, unmodified.
@
text
@@
