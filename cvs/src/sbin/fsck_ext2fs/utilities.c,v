head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.19.0.14
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.10
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.03.16.15.41.10;	author krw;	state Exp;
branches;
next	1.26;
commitid	JEVxsRygqcjPtWTf;

1.26
date	2015.09.05.20.07.11;	author guenther;	state Exp;
branches;
next	1.25;
commitid	YONuUa04kio8ur0h;

1.25
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	0qPuuXwccpVXsXcV;

1.24
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2014.07.13.16.08.53;	author pelikan;	state Exp;
branches;
next	1.22;
commitid	tQBfngCdLJGooLWH;

1.22
date	2014.05.24.14.54.49;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.22.14.04.41;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.20.21.11.16;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2011.03.12.17.50.47;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.10.16.01.50;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.20.02.24.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.02.00.48.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.30.01.16.30;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.11.06.22.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.17.06.48.47;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.23.21.23.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.18.17.43.15;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.31.22.31.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.19.17.57.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.30.16.06.34;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.23.26.07;	author jasoni;	state Exp;
branches;
next	1.4;

1.4
date	97.06.25.18.40.43;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.14.04.17.00;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.06.14.04.06.33;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.04.33.55;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.04.33.55;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.27
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@/*	$OpenBSD: utilities.c,v 1.26 2015/09/05 20:07:11 guenther Exp $	*/
/*	$NetBSD: utilities.c,v 1.6 2001/02/04 21:19:34 christos Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE isset setbit */
#include <sys/time.h>
#include <sys/signal.h>
#include <ufs/ext2fs/ext2fs_dinode.h>
#include <ufs/ext2fs/ext2fs_dir.h>
#include <ufs/ext2fs/ext2fs.h>
#include <ufs/ufs/dinode.h> /* for IFMT & friends */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <errno.h>

#include "fsutil.h"
#include "fsck.h"
#include "extern.h"

long	diskreads, totalreads;	/* Disk cache statistics */

static void rwerror(char *, daddr32_t);

int
ftypeok(struct ext2fs_dinode *dp)
{
	switch (letoh16(dp->e2di_mode) & IFMT) {

	case IFDIR:
	case IFREG:
	case IFBLK:
	case IFCHR:
	case IFLNK:
	case IFSOCK:
	case IFIFO:
		return (1);

	default:
		if (debug)
			printf("bad file type 0%o\n", letoh16(dp->e2di_mode));
		return (0);
	}
}

int
reply(char *question)
{
	int persevere;
	int c;

	if (preen)
		pfatal("INTERNAL ERROR: GOT TO reply()");
	persevere = !strcmp(question, "CONTINUE");
	printf("\n");
	if (!persevere && (nflag || fswritefd < 0)) {
		printf("%s? no\n\n", question);
		return (0);
	}
	if (yflag || (persevere && nflag)) {
		printf("%s? yes\n\n", question);
		return (1);
	}
	do {
		printf("%s? [Fyn?] ", question);
		(void) fflush(stdout);
		c = getc(stdin);
		if (c == 'F') {
			yflag = 1;
			return (1);
		}
		while (c != '\n' && getc(stdin) != '\n')
			if (feof(stdin))
				return (0);
	} while (c != 'y' && c != 'Y' && c != 'n' && c != 'N');
	printf("\n");
	if (c == 'y' || c == 'Y')
		return (1);
	return (0);
}

/*
 * Malloc buffers and set up cache.
 */
void
bufinit(void)
{
	struct bufarea *bp;
	long bufcnt, i;
	char *bufp;

	diskreads = totalreads = 0;
	pbp = pdirbp = NULL;
	bufhead.b_next = bufhead.b_prev = &bufhead;
	bufcnt = MAXBUFSPACE / sblock.e2fs_bsize;
	if (bufcnt < MINBUFS)
		bufcnt = MINBUFS;
	for (i = 0; i < bufcnt; i++) {
		bp = malloc(sizeof(struct bufarea));
		bufp = malloc((unsigned int)sblock.e2fs_bsize);
		if (bp == NULL || bufp == NULL) {
			free(bp);
			free(bufp);
			if (i >= MINBUFS)
				break;
			errexit("cannot allocate buffer pool\n");
		}
		bp->b_un.b_buf = bufp;
		bp->b_prev = &bufhead;
		bp->b_next = bufhead.b_next;
		bufhead.b_next->b_prev = bp;
		bufhead.b_next = bp;
		initbarea(bp);
	}
	bufhead.b_size = i;	/* save number of buffers */
}

/*
 * Manage a cache of directory blocks.
 */
struct bufarea *
getdatablk(daddr32_t blkno, long size)
{
	struct bufarea *bp;

	for (bp = bufhead.b_next; bp != &bufhead; bp = bp->b_next)
		if (bp->b_bno == fsbtodb(&sblock, blkno))
			goto foundit;
	for (bp = bufhead.b_prev; bp != &bufhead; bp = bp->b_prev)
		if ((bp->b_flags & B_INUSE) == 0)
			break;
	if (bp == &bufhead)
		errexit("deadlocked buffer pool\n");
	getblk(bp, blkno, size);
	diskreads++;
	/* fall through */
foundit:
	totalreads++;
	bp->b_prev->b_next = bp->b_next;
	bp->b_next->b_prev = bp->b_prev;
	bp->b_prev = &bufhead;
	bp->b_next = bufhead.b_next;
	bufhead.b_next->b_prev = bp;
	bufhead.b_next = bp;
	bp->b_flags |= B_INUSE;
	return (bp);
}

void
getblk(struct bufarea *bp, daddr32_t blk, long size)
{
	daddr32_t dblk;

	dblk = fsbtodb(&sblock, blk);
	if (bp->b_bno != dblk) {
		flush(fswritefd, bp);
		diskreads++;
		bp->b_errs = bread(fsreadfd, bp->b_un.b_buf, dblk, size);
		bp->b_bno = dblk;
		bp->b_size = size;
	}
}

void
flush(int fd, struct bufarea *bp)
{
	int i;

	if (!bp->b_dirty)
		return;
	if (bp->b_errs != 0)
		pfatal("WRITING %sZERO'ED BLOCK %d TO DISK\n",
		    (bp->b_errs == bp->b_size / DEV_BSIZE) ? "" : "PARTIALLY ",
		    bp->b_bno);
	bp->b_dirty = 0;
	bp->b_errs = 0;
	bwrite(fd, bp->b_un.b_buf, bp->b_bno, (long)bp->b_size);
	if (bp != &sblk)
		return;
	for (i = 0; i < sblock.e2fs_ngdb; i++) {
		bwrite(fswritefd, (char *)
			&sblock.e2fs_gd[i* sblock.e2fs_bsize / sizeof(struct ext2_gd)],
		    fsbtodb(&sblock, ((sblock.e2fs_bsize>1024)?0:1)+i+1),
		    sblock.e2fs_bsize);
	}
}

static void
rwerror(char *mesg, daddr32_t blk)
{

	if (preen == 0)
		printf("\n");
	pfatal("CANNOT %s: BLK %d", mesg, blk);
	if (reply("CONTINUE") == 0)
		errexit("Program terminated\n");
}

void
ckfini(int markclean)
{
	struct bufarea *bp, *nbp;
	int cnt = 0;

	if (fswritefd < 0) {
		(void)close(fsreadfd);
		return;
	}
	flush(fswritefd, &sblk);
	if (havesb && sblk.b_bno != SBOFF / DEV_BSIZE &&
	    !preen && reply("UPDATE STANDARD SUPERBLOCKS")) {
		sblk.b_bno = SBOFF / DEV_BSIZE;
		sbdirty();
		flush(fswritefd, &sblk);
		copyback_sb(&asblk);
		asblk.b_dirty = 1;
		flush(fswritefd, &asblk);
	}
	for (bp = bufhead.b_prev; bp && bp != &bufhead; bp = nbp) {
		cnt++;
		flush(fswritefd, bp);
		nbp = bp->b_prev;
		free(bp->b_un.b_buf);
		free((char *)bp);
	}
	if (bufhead.b_size != cnt)
		errexit("Panic: lost %d buffers\n", bufhead.b_size - cnt);
	pbp = pdirbp = NULL;
	if (markclean && (sblock.e2fs.e2fs_state & E2FS_ISCLEAN) == 0) {
		/*
		 * Mark the file system as clean, and sync the superblock.
		 */
		if (preen)
			pwarn("MARKING FILE SYSTEM CLEAN\n");
		else if (!reply("MARK FILE SYSTEM CLEAN"))
			markclean = 0;
		if (markclean) {
			sblock.e2fs.e2fs_state = E2FS_ISCLEAN;
			sbdirty();
			flush(fswritefd, &sblk);
		}
	}
	if (debug)
		printf("cache missed %ld of %ld (%d%%)\n", diskreads,
		    totalreads, (int)(diskreads * 100 / totalreads));
	(void)close(fsreadfd);
	(void)close(fswritefd);
}

int
bread(int fd, char *buf, daddr32_t blk, long size)
{
	char *cp;
	int i, errs;
	off_t offset;

	offset = blk;
	offset *= DEV_BSIZE;
	if (pread(fd, buf, size, offset) == size)
		return (0);
	rwerror("READ", blk);
	errs = 0;
	memset(buf, 0, (size_t)size);
	printf("THE FOLLOWING DISK SECTORS COULD NOT BE READ:");
	for (cp = buf, i = 0; i < size; i += secsize, cp += secsize) {
		if (pread(fd, cp, secsize, offset + i) != secsize) {
			if (secsize != DEV_BSIZE)
				printf(" %lld (%lld),",
				    (long long)(offset + i) / secsize,
				    (long long)blk + i / DEV_BSIZE);
			else
				printf(" %lld,", (long long)blk +
				    i / DEV_BSIZE);
			errs++;
		}
	}
	printf("\n");
	return (errs);
}

void
bwrite(int fd, char *buf, daddr32_t blk, long size)
{
	int i;
	char *cp;
	off_t offset;

	if (fd < 0)
		return;
	offset = blk;
	offset *= DEV_BSIZE;
	if (pwrite(fd, buf, size, offset) == size) {
		fsmodified = 1;
		return;
	}
	rwerror("WRITE", blk);
	printf("THE FOLLOWING SECTORS COULD NOT BE WRITTEN:");
	for (cp = buf, i = 0; i < size; i += secsize, cp += secsize)
		if (pwrite(fd, cp, secsize, offset + i) != secsize) {
			if (secsize != DEV_BSIZE)
				printf(" %lld (%lld),",
				    (long long)(offset + i) / secsize,
				    (long long)blk + i / DEV_BSIZE);
			else
				printf(" %lld,", (long long)blk +
				    i / DEV_BSIZE);
		}
	printf("\n");
	return;
}

/*
 * allocate a data block
 */
int
allocblk(void)
{
	int i;

	for (i = 0; i < maxfsblock - 1; i++) {
		if (testbmap(i))
				continue;
		setbmap(i);
		n_blks ++;
		return (i);
	}
	return (0);
}

/*
 * Free a previously allocated block
 */
void
freeblk(daddr32_t blkno)
{
	struct inodesc idesc;

	idesc.id_blkno = blkno;
	idesc.id_numfrags = 1;
	(void)pass4check(&idesc);
}

/*
 * Find a pathname
 */
void
getpathname(char *namebuf, size_t buflen, ino_t curdir, ino_t ino)
{
	size_t len;
	char *cp;
	struct inodesc idesc;
	static int busy = 0;

	if (curdir == ino && ino == EXT2_ROOTINO) {
		(void)strlcpy(namebuf, "/", buflen);
		return;
	}
	if (busy ||
	    (statemap[curdir] != DSTATE && statemap[curdir] != DFOUND)) {

		(void)strlcpy(namebuf, "?", buflen);
		return;
	}
	busy = 1;
	memset(&idesc, 0, sizeof(struct inodesc));
	idesc.id_type = DATA;
	idesc.id_fix = IGNORE;
	cp = &namebuf[buflen - 1];
	*cp = '\0';
	if (curdir != ino) {
		idesc.id_parent = curdir;
		goto namelookup;
	}
	while (ino != EXT2_ROOTINO) {
		idesc.id_number = ino;
		idesc.id_func = findino;
		idesc.id_name = "..";
		if ((ckinode(ginode(ino), &idesc) & FOUND) == 0)
			break;
	namelookup:
		idesc.id_number = idesc.id_parent;
		idesc.id_parent = ino;
		idesc.id_func = findname;
		idesc.id_name = namebuf;
		if ((ckinode(ginode(idesc.id_number), &idesc)&FOUND) == 0)
			break;
		len = strlen(namebuf);
		cp -= len;
		memcpy(cp, namebuf, len);
		*(--cp) = '/';
		if (cp < &namebuf[EXT2FS_MAXNAMLEN])
			break;
		ino = idesc.id_number;
	}
	busy = 0;
	if (ino != EXT2_ROOTINO)
		*(--cp) = '?';
	memcpy(namebuf, cp, (size_t)(&namebuf[buflen] - cp));
}

/*ARGSUSED*/
void
catch(int signo)
{
	ckfini(0);			/* XXX signal race */
	_exit(12);
}

/*
 * When preening, allow a single quit to signal
 * a special exit after filesystem checks complete
 * so that reboot sequence may be interrupted.
 */
/*ARGSUSED*/
void
catchquit(int signo)
{
	extern volatile sig_atomic_t returntosingle;
	static const char message[] =
	    "returning to single-user after filesystem check\n";

	write(STDOUT_FILENO, message, sizeof(message)-1);
	returntosingle = 1;
	(void)signal(SIGQUIT, SIG_DFL);
}

/*
 * Ignore a single quit signal; wait and flush just in case.
 * Used by child processes in preen.
 */
/*ARGSUSED*/
void
voidquit(int signo)
{
	int save_errno = errno;

	sleep(1);
	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGQUIT, SIG_DFL);
	errno = save_errno;
}

/*
 * determine whether an inode should be fixed.
 */
int
dofix(struct inodesc *idesc, char *msg)
{

	switch (idesc->id_fix) {

	case DONTKNOW:
		if (idesc->id_type == DATA)
			direrror(idesc->id_number, msg);
		else
			pwarn("%s", msg);
		if (preen) {
			printf(" (SALVAGED)\n");
			idesc->id_fix = FIX;
			return (ALTERED);
		}
		if (reply("SALVAGE") == 0) {
			idesc->id_fix = NOFIX;
			return (0);
		}
		idesc->id_fix = FIX;
		return (ALTERED);

	case FIX:
		return (ALTERED);

	case NOFIX:
	case IGNORE:
		return (0);

	default:
		errexit("UNKNOWN INODESC FIX MODE %d\n", idesc->id_fix);
	}
	/* NOTREACHED */
}
@


1.26
log
@snprintf+write --> dprintf

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.25 2015/08/20 22:02:20 deraadt Exp $	*/
d124 1
a124 1
	pbp = pdirbp = (struct bufarea *)0;
d259 1
a259 1
	pbp = pdirbp = (struct bufarea *)0;
@


1.25
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.24 2015/01/16 06:39:57 deraadt Exp $	*/
d450 2
a451 1
	char buf[1024];
d453 1
a453 3
	snprintf(buf, sizeof buf,
	    "returning to single-user after filesystem check\n");
	write(STDOUT_FILENO, buf, strlen(buf));
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.23 2014/07/13 16:08:53 pelikan Exp $	*/
d130 1
a130 1
		bp = (struct bufarea *)malloc(sizeof(struct bufarea));
@


1.23
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.22 2014/05/24 14:54:49 krw Exp $	*/
d34 1
a34 1
#include <sys/param.h>
d36 1
@


1.22
log
@Use consistent format specifiers (%lld) and casts (long long) when
printing out block numbers and sector numbers. Make output verbiage
consistent. -Wall happier.

Original diff and ok chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.21 2014/05/22 14:04:41 krw Exp $	*/
d58 1
a58 1
	switch (fs2h16(dp->e2di_mode) & IFMT) {
d71 1
a71 1
			printf("bad file type 0%o\n", fs2h16(dp->e2di_mode));
@


1.21
log
@Nuke pointless dev_bsize variable which is always set to 512, and just
use DEV_BSIZE.

Write sizes need to be secsize and not DEV_BSIZE, just like reads.

Equivalent to changes made in fsck_ffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.20 2014/05/20 21:11:16 krw Exp $	*/
d298 3
a300 3
				printf(" %ld (%ld),",
				    (blk * DEV_BSIZE + i) / secsize,
				    blk + i / DEV_BSIZE);
d302 2
a303 1
				printf(" %ld,", blk + i / DEV_BSIZE);
d330 7
a336 1
			printf(" %ld,", blk + i / DEV_BSIZE);
@


1.20
log
@As suggested by guenther@@ and millert@@, replace seek+[read|write] with
p[read|write].  Makes the code much clearer by eliminating extra error
checking and verbiage.

No intentional functional change.

Tweaks by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.19 2011/03/12 17:50:47 deraadt Exp $	*/
d203 1
a203 1
		    (bp->b_errs == bp->b_size / dev_bsize) ? "" : "PARTIALLY ",
d240 1
a240 1
	if (havesb && sblk.b_bno != SBOFF / dev_bsize &&
d242 1
a242 1
		sblk.b_bno = SBOFF / dev_bsize;
d288 1
a288 1
	offset *= dev_bsize;
d297 1
a297 1
			if (secsize != dev_bsize && dev_bsize != 1)
d299 2
a300 2
				    (blk * dev_bsize + i) / secsize,
				    blk + i / dev_bsize);
d302 1
a302 1
				printf(" %ld,", blk + i / dev_bsize);
d320 1
a320 1
	offset *= dev_bsize;
d327 3
a329 3
	for (cp = buf, i = 0; i < size; i += dev_bsize, cp += dev_bsize)
		if (pwrite(fd, cp, dev_bsize, offset + i) != dev_bsize) {
			printf(" %ld,", blk + i / dev_bsize);
@


1.19
log
@These utilities can currently only operate with a 32-bit block number range,
so use daddr32_t
ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.18 2009/12/10 16:01:50 deraadt Exp $	*/
d289 1
a289 3
	if (lseek(fd, offset, SEEK_SET) < 0)
		rwerror("SEEK", blk);
	else if (read(fd, buf, (int)size) == size)
a291 2
	if (lseek(fd, offset, SEEK_SET) < 0)
		rwerror("SEEK", blk);
d296 1
a296 2
		if (read(fd, cp, (int)secsize) != secsize) {
			(void)lseek(fd, offset + i + secsize, SEEK_SET);
d321 1
a321 3
	if (lseek(fd, offset, SEEK_SET) < 0)
		rwerror("SEEK", blk);
	else if (write(fd, buf, (int)size) == size) {
a325 2
	if (lseek(fd, offset, SEEK_SET) < 0)
		rwerror("SEEK", blk);
d328 1
a328 2
		if (write(fd, cp, (int)dev_bsize) != dev_bsize) {
			(void)lseek(fd, offset + i + dev_bsize, SEEK_SET);
@


1.18
log
@do not leak memory, found by parfait, ok millert otto
(one case was a false positive, but one is a modified copy of the other)
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.17 2006/04/20 02:24:38 deraadt Exp $	*/
d53 1
a53 1
static void rwerror(char *, daddr_t);
d152 1
a152 1
getdatablk(daddr_t blkno, long size)
d180 1
a180 1
getblk(struct bufarea *bp, daddr_t blk, long size)
d182 1
a182 1
	daddr_t dblk;
d219 1
a219 1
rwerror(char *mesg, daddr_t blk)
d281 1
a281 1
bread(int fd, char *buf, daddr_t blk, long size)
d316 1
a316 1
bwrite(int fd, char *buf, daddr_t blk, long size)
d367 1
a367 1
freeblk(daddr_t blkno)
@


1.17
log
@solve some signal races; from fsck_ffs; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.16 2006/04/02 00:48:35 deraadt Exp $	*/
d132 2
@


1.16
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.15 2006/03/30 01:16:30 deraadt Exp $	*/
d45 1
a54 2
extern int returntosingle;

d95 1
a95 1
		printf("%s? [Fyn] ", question);
d432 1
d434 1
a434 1
catch(int n)
d436 2
a437 3
	/* XXX signal race */
	ckfini(0);
	exit(12);
d445 1
d447 1
a447 1
catchquit(int n)
d449 2
d452 3
a454 2
	/* XXX signal race */
	printf("returning to single-user after filesystem check\n");
d463 1
d465 1
a465 1
voidquit(int n)
d467 1
a468 1
	/* XXX signal race */
d472 1
@


1.15
log
@when asking y or n, accept "F" which forces yes from the on.  i have
wished for this for 10+ year, but always forgotten to make the change
after cleaning up a nasty file system; ok pedro millert
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.14 2003/06/11 06:22:13 deraadt Exp $	*/
d288 1
a288 1
	if (lseek(fd, offset, 0) < 0)
d293 1
a293 1
	if (lseek(fd, offset, 0) < 0)
d300 1
a300 1
			(void)lseek(fd, offset + i + secsize, 0);
d325 1
a325 1
	if (lseek(fd, offset, 0) < 0)
d332 1
a332 1
	if (lseek(fd, offset, 0) < 0)
d337 1
a337 1
			(void)lseek(fd, offset + i + dev_bsize, 0);
@


1.14
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.13 2003/06/02 20:06:15 millert Exp $	*/
d95 2
a96 2
	do	{
		printf("%s? [yn] ", question);
d99 4
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.12 2003/04/17 06:48:47 tedu Exp $	*/
d57 1
a57 2
ftypeok(dp)
	struct ext2fs_dinode *dp;
d78 1
a78 2
reply(question)
	char *question;
d113 1
a113 1
bufinit()
d147 1
a147 3
getdatablk(blkno, size)
	daddr_t blkno;
	long size;
d175 1
a175 4
getblk(bp, blk, size)
	struct bufarea *bp;
	daddr_t blk;
	long size;
d190 1
a190 3
flush(fd, bp)
	int fd;
	struct bufarea *bp;
d214 1
a214 3
rwerror(mesg, blk)
	char *mesg;
	daddr_t blk;
d225 1
a225 2
ckfini(markclean)
	int markclean;
d276 1
a276 5
bread(fd, buf, blk, size)
	int fd;
	char *buf;
	daddr_t blk;
	long size;
d311 1
a311 5
bwrite(fd, buf, blk, size)
	int fd;
	char *buf;
	daddr_t blk;
	long size;
d344 1
a344 1
allocblk()
d362 1
a362 2
freeblk(blkno)
	daddr_t blkno;
d375 1
a375 4
getpathname(namebuf, buflen, curdir, ino)
	char *namebuf;
	size_t buflen;
	ino_t curdir, ino;
d388 1
d430 1
a430 2
catch(n)
	int n;
d443 1
a443 2
catchquit(n)
	int n;
d457 1
a457 2
voidquit(n)
	int n;
d470 1
a470 3
dofix(idesc, msg)
	struct inodesc *idesc;
	char *msg;
@


1.12
log
@strings.  mostly from deraadt@@, some from tdeval@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.11 2002/02/23 21:23:46 deraadt Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@getc() returns an int
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.10 2002/02/16 21:27:34 millert Exp $	*/
d400 1
a400 1
getpathname(namebuf, curdir, ino)
d402 1
d405 1
a405 1
	int len;
d411 1
a411 1
		(void)strcpy(namebuf, "/");
d416 1
a416 1
		(void)strcpy(namebuf, "?");
d423 1
a423 1
	cp = &namebuf[MAXPATHLEN - 1];
d444 2
a445 2
		memcpy(cp, namebuf, (size_t)len);
		*--cp = '/';
d452 2
a453 2
		*--cp = '?';
	memcpy(namebuf, cp, (size_t)(&namebuf[MAXPATHLEN] - cp));
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.9 2001/09/18 17:43:15 art Exp $	*/
d87 1
a87 1
	char c;
@


1.9
log
@cleanups and endianness fixes. Mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.8 2001/01/31 22:31:51 deraadt Exp $	*/
d56 1
a56 1
static void rwerror __P((char *, daddr_t));
@


1.8
log
@KNF; tomo@@ns1.infinitedata.net
@
text
@d1 2
a2 2
/*	$OpenBSD: utilities.c,v 1.7 2001/01/19 17:57:36 deraadt Exp $	*/
/*	$NetBSD: utilities.c,v 1.1 1997/06/11 11:22:02 bouyer Exp $	*/
a37 12
#ifndef lint
#if 0
static char sccsid[] = "@@(#)utilities.c	8.1 (Berkeley) 6/5/93";
#else
#if 0
static char rcsid[] = "$NetBSD: utilities.c,v 1.1 1997/06/11 11:22:02 bouyer Exp $";
#else
static char rcsid[] = "$OpenBSD: utilities.c,v 1.7 2001/01/19 17:57:36 deraadt Exp $";
#endif
#endif
#endif /* not lint */

d58 2
d77 1
a77 1
			printf("bad file type 0%o\n", dp->e2di_mode);
d121 1
a121 1
	register struct bufarea *bp;
d157 1
a157 1
	register struct bufarea *bp;
d184 1
a184 1
	register struct bufarea *bp;
d203 1
a203 1
	register struct bufarea *bp;
d205 1
a205 1
	register int i;
d243 1
a243 1
	register struct bufarea *bp, *nbp;
d370 1
a370 1
	register int i;
d405 1
a405 1
	register char *cp;
a472 1
	extern int returntosingle;
d500 1
a500 1
	register struct inodesc *idesc;
@


1.7
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.6 2000/09/30 16:06:34 aaron Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.6 2000/09/30 16:06:34 aaron Exp $";
d483 1
a483 1
	extern returntosingle;
@


1.6
log
@Some format string problems that were missed during initial audit; deraadt@@ and
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.5 2000/04/26 23:26:07 jasoni Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.5 2000/04/26 23:26:07 jasoni Exp $";
d469 1
d485 1
d500 1
@


1.5
log
@Support for ext2fs rev. 1
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.4 1997/06/25 18:40:43 kstailey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.4 1997/06/25 18:40:43 kstailey Exp $";
d518 1
a518 1
			pwarn(msg);
@


1.4
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.3 1997/06/14 04:17:00 downsj Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.3 1997/06/14 04:17:00 downsj Exp $";
d74 1
a74 1
	switch (dp->e2di_mode & IFMT) {
d135 2
a136 1
	pbp = pdirbp = NULL;
d178 1
d215 1
a215 1
	register int i, j;
d262 1
a262 1
	    !preen && reply("UPDATE STANDARD SUPERBLOCK")) {
d266 3
d279 1
a279 1
	pbp = pdirbp = NULL;
@


1.3
log
@Add tags, fix man page.  Purely cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD$";
d135 1
a135 1
	pbp = pdirbp = (struct bufarea *)0;
d274 1
a274 1
	pbp = pdirbp = (struct bufarea *)0;
@


1.2
log
@Sync with NetBSD.  Purely cosmetic.
@
text
@d1 1
d42 1
d44 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/*	$NetBSD: utilities.c,v 1.18 1996/09/27 22:45:20 christos Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d4 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: utilities.c,v 1.18 1996/09/27 22:45:20 christos Exp $";
@


1.1.1.1
log
@Initial import of Manuel's fsck_ext2fs, unmodified.
@
text
@@
