head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	R19970424:1.1.1.1
	BOUYER:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.04.28.12.17.15;	author krw;	state Exp;
branches;
next	1.29;
commitid	A4fdskp72gjrZWxe;

1.29
date	2015.10.15.15.11.10;	author semarie;	state Exp;
branches;
next	1.28;
commitid	Ku0Mi2yDsPNOS1Oo;

1.28
date	2015.10.14.16.58.55;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	7vEhrQZryjO1AvBa;

1.27
date	2015.09.10.15.21.40;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Ga2b1XrGOVxTApCb;

1.26
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	0qPuuXwccpVXsXcV;

1.25
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Uu5nFG3wCl0LACBb;

1.24
date	2014.11.20.15.22.39;	author tedu;	state Exp;
branches;
next	1.23;
commitid	HIbf8HnT4wFtIrOp;

1.23
date	2014.07.13.16.08.53;	author pelikan;	state Exp;
branches;
next	1.22;
commitid	tQBfngCdLJGooLWH;

1.22
date	2014.07.13.13.50.00;	author pelikan;	state Exp;
branches;
next	1.21;
commitid	UWyIJ21FGOlW4Bcd;

1.21
date	2014.07.11.15.54.52;	author tobias;	state Exp;
branches;
next	1.20;
commitid	wNY0uOVg0D2FyJm1;

1.20
date	2014.05.22.14.04.41;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.22.04.38.02;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.12.17.50.47;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.08.11.19.04;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.02.15.19.23;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.30.13.56.16;	author niallo;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.11.06.22.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.18.17.43.15;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.26.23.26.06;	author jasoni;	state Exp;
branches;
next	1.5;

1.5
date	99.08.17.09.13.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.14.05.04.12;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.06.14.04.16.59;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.06.14.04.06.33;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.05.30.04.33.55;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.30.04.33.55;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Fix fsck'ing. ext2fs_dinode grew extra bits to support ext4
and sizeof(struct ext2fs_dinode) had to be replaced with
EXT2_DINODE_SIZE() and such.

ok beck@@
@
text
@/*	$OpenBSD: setup.c,v 1.29 2015/10/15 15:11:10 semarie Exp $	*/
/*	$NetBSD: setup.c,v 1.1 1997/06/11 11:22:01 bouyer Exp $	*/

/*
 * Copyright (c) 1997 Manuel Bouyer.
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define DKTYPENAMES
#include <sys/param.h>	/* DEV_BSIZE roundup */
#include <sys/time.h>
#include <ufs/ext2fs/ext2fs_dinode.h>
#include <ufs/ext2fs/ext2fs.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/disklabel.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <err.h>

#include "fsck.h"
#include "extern.h"
#include "fsutil.h"

#define POWEROF2(num)	(((num) & ((num) - 1)) == 0)

void badsb(int, char *);
int calcsb(char *, int, struct m_ext2fs *, struct disklabel *);
static struct disklabel *getdisklabel(char *, int);
static int readsb(int);

int
setup(char *dev)
{
	long cg, asked, i;
	long bmapsize;
	struct disklabel *lp;
	off_t sizepb;
	struct stat statb;
	struct m_ext2fs proto;
	int doskipclean;
	u_int64_t maxfilesize;

	havesb = 0;
	fswritefd = -1;
	doskipclean = skipclean;
	if (stat(dev, &statb) < 0) {
		printf("Can't stat %s: %s\n", dev, strerror(errno));
		return (0);
	}
	if (!S_ISCHR(statb.st_mode)) {
		pfatal("%s is not a character device", dev);
		if (reply("CONTINUE") == 0)
			return (0);
	}
	if ((fsreadfd = open(dev, O_RDONLY)) < 0) {
		printf("Can't open %s: %s\n", dev, strerror(errno));
		return (0);
	}
	if (preen == 0)
		printf("** %s", dev);
	if (nflag || (fswritefd = open(dev, O_WRONLY)) < 0) {
		fswritefd = -1;
		if (preen)
			pfatal("NO WRITE ACCESS");
		printf(" (NO WRITE)");
	}
	if (preen == 0)
		printf("\n");
	fsmodified = 0;
	lfdir = 0;
	initbarea(&sblk);
	initbarea(&asblk);
	sblk.b_un.b_buf = malloc(SBSIZE);
	asblk.b_un.b_buf = malloc(SBSIZE);
	if (sblk.b_un.b_buf == NULL || asblk.b_un.b_buf == NULL)
		errexit("cannot allocate space for superblock\n");
	if ((lp = getdisklabel(NULL, fsreadfd)) != NULL)
		secsize = lp->d_secsize;
	else
		secsize = DEV_BSIZE;

	if (!hotroot()) {
#ifndef SMALL
		if (pledge("stdio getpw", NULL) == -1)
			err(1, "pledge");
#else
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
#endif
	}

	/*
	 * Read in the superblock, looking for alternates if necessary
	 */
	if (readsb(1) == 0) {
		if (bflag || preen || calcsb(dev, fsreadfd, &proto, lp) == 0)
			return(0);
		if (reply("LOOK FOR ALTERNATE SUPERBLOCKS") == 0)
			return (0);
		for (cg = 1; cg < proto.e2fs_ncg; cg++) {
			bflag = fsbtodb(&proto,
				cg * proto.e2fs.e2fs_bpg + proto.e2fs.e2fs_first_dblock);
			if (readsb(0) != 0)
				break;
		}
		if (cg >= proto.e2fs_ncg) {
			printf("%s %s\n%s %s\n%s %s\n",
			    "SEARCH FOR ALTERNATE SUPER-BLOCK",
			    "FAILED. YOU MUST USE THE",
			    "-b OPTION TO FSCK_FFS TO SPECIFY THE",
			    "LOCATION OF AN ALTERNATE",
			    "SUPER-BLOCK TO SUPPLY NEEDED",
			    "INFORMATION; SEE fsck_ext2fs(8).");
			return(0);
		}
		doskipclean = 0;
		pwarn("USING ALTERNATE SUPERBLOCK AT %d\n", bflag);
	}
	if (debug)
		printf("state = %d\n", sblock.e2fs.e2fs_state);
	if (sblock.e2fs.e2fs_state == E2FS_ISCLEAN) {
		if (doskipclean) {
			pwarn("%sile system is clean; not checking\n",
			    preen ? "f" : "** F");
			return (-1);
		}
		if (!preen)
			pwarn("** File system is already clean\n");
	}
	maxfsblock = sblock.e2fs.e2fs_bcount;
	maxino = sblock.e2fs_ncg * sblock.e2fs.e2fs_ipg;
	sizepb = sblock.e2fs_bsize;
	maxfilesize = sblock.e2fs_bsize * NDADDR - 1;
	for (i = 0; i < NIADDR; i++) {
		sizepb *= NINDIR(&sblock);
		maxfilesize += sizepb;
	}
	/*
	 * Check and potentially fix certain fields in the super block.
	 */
	if ((sblock.e2fs.e2fs_rbcount < 0) ||
			(sblock.e2fs.e2fs_rbcount > sblock.e2fs.e2fs_bcount)) {
		pfatal("IMPOSSIBLE RESERVED BLOCK COUNT=%d IN SUPERBLOCK",
			sblock.e2fs.e2fs_rbcount);
		if (reply("SET TO DEFAULT") == 1) {
			sblock.e2fs.e2fs_rbcount = sblock.e2fs.e2fs_bcount * 0.1;
			sbdirty();
			dirty(&asblk);
		}
	}
	if (sblock.e2fs.e2fs_bpg != sblock.e2fs.e2fs_fpg) {
		pfatal("WRONG FPG=%d (BPG=%d) IN SUPERBLOCK",
			sblock.e2fs.e2fs_fpg, sblock.e2fs.e2fs_bpg);
		return 0;
	}
	if (asblk.b_dirty && !bflag) {
		copyback_sb(&asblk);
		flush(fswritefd, &asblk);
	}
	/*
	 * read in the summary info.
	 */

	sblock.e2fs_gd = calloc(sblock.e2fs_ngdb, sblock.e2fs_bsize);
	if (sblock.e2fs_gd == NULL)
		errexit("out of memory\n");
	asked = 0;
	for (i=0; i < sblock.e2fs_ngdb; i++) {
		if (bread(fsreadfd,(char *)
			&sblock.e2fs_gd[i* sblock.e2fs_bsize / sizeof(struct ext2_gd)],
			fsbtodb(&sblock, ((sblock.e2fs_bsize>1024)?0:1)+i+1),
			sblock.e2fs_bsize) != 0 && !asked) {
			pfatal("BAD SUMMARY INFORMATION");
			if (reply("CONTINUE") == 0)
				errexit("%s\n", "");
			asked++;
		}
	}
	/*
	 * allocate and initialize the necessary maps
	 */
	bmapsize = roundup(howmany(maxfsblock, NBBY), sizeof(int16_t));
	blockmap = calloc((unsigned)bmapsize, sizeof (char));
	if (blockmap == NULL) {
		printf("cannot alloc %u bytes for blockmap\n",
			(unsigned)bmapsize);
		goto badsblabel;
	}
	statemap = calloc((unsigned)(maxino + 2), sizeof(char));
	if (statemap == NULL) {
		printf("cannot alloc %u bytes for statemap\n",
			(unsigned)(maxino + 1));
		goto badsblabel;
	}
	typemap = calloc((unsigned)(maxino + 1), sizeof(u_char));
	if (typemap == NULL) {
		printf("cannot alloc %u bytes for typemap\n",
		    (unsigned)(maxino + 1));
		goto badsblabel;
	}
	lncntp = calloc((unsigned)(maxino + 1), sizeof(int16_t));
	if (lncntp == NULL) {
		printf("cannot alloc %u bytes for lncntp\n",
			(unsigned)((maxino + 1) * sizeof(int16_t)));
		goto badsblabel;
	}
	for (numdirs = 0, cg = 0; cg < sblock.e2fs_ncg; cg++) {
		numdirs += letoh16(sblock.e2fs_gd[cg].ext2bgd_ndirs);
	}
	inplast = 0;
	listmax = numdirs + 10;
	inpsort = calloc((unsigned)listmax, sizeof(struct inoinfo *));
	inphead = calloc((unsigned)numdirs, sizeof(struct inoinfo *));
	if (inpsort == NULL || inphead == NULL) {
		printf("cannot alloc %u bytes for inphead\n",
			(unsigned)(numdirs * sizeof(struct inoinfo *)));
		goto badsblabel;
	}
	bufinit();
	return (1);

badsblabel:
	ckfini(0);
	return (0);
}

/*
 * Read in the super block and its summary info.
 */
static int
readsb(int listerr)
{
	daddr32_t super = bflag ? bflag : SBOFF / DEV_BSIZE;

	if (bread(fsreadfd, (char *)sblk.b_un.b_fs, super, (long)SBSIZE) != 0)
		return (0);
	sblk.b_bno = super;
	sblk.b_size = SBSIZE;

	/* Copy the superblock in memory */
	e2fs_sbload(sblk.b_un.b_fs, &sblock.e2fs);

	/*
	 * run a few consistency checks of the super block
	 */
	if (sblock.e2fs.e2fs_magic != E2FS_MAGIC) {
		badsb(listerr, "MAGIC NUMBER WRONG"); return (0);
	}
	if (sblock.e2fs.e2fs_log_bsize > 2) {
		badsb(listerr, "BAD LOG_BSIZE"); return (0);
	}
	if (sblock.e2fs.e2fs_bpg == 0) {
		badsb(listerr, "BAD BLOCKS PER GROUP"); return (0);
	}

	/* compute the dynamic fields of the in-memory sb */
	/* compute dynamic sb infos */
	sblock.e2fs_ncg =
		howmany(sblock.e2fs.e2fs_bcount - sblock.e2fs.e2fs_first_dblock,
		sblock.e2fs.e2fs_bpg);
	/* XXX assume hw bsize = 512 */
	sblock.e2fs_fsbtodb = sblock.e2fs.e2fs_log_bsize + 1;
	sblock.e2fs_bsize = 1024 << sblock.e2fs.e2fs_log_bsize;
	sblock.e2fs_bshift = LOG_MINBSIZE + sblock.e2fs.e2fs_log_bsize;
	sblock.e2fs_qbmask = sblock.e2fs_bsize - 1;
	sblock.e2fs_bmask = ~sblock.e2fs_qbmask;
	sblock.e2fs_ngdb = howmany(sblock.e2fs_ncg,
		sblock.e2fs_bsize / sizeof(struct ext2_gd));
	sblock.e2fs_ipb = sblock.e2fs_bsize / EXT2_DINODE_SIZE(&sblock);
	sblock.e2fs_itpg = sblock.e2fs.e2fs_ipg/sblock.e2fs_ipb;

	/*
	 * Compute block size that the filesystem is based on,
	 * according to fsbtodb, and adjust superblock block number
	 * so we can tell if this is an alternate later.
	 */
	sblk.b_bno = super / DEV_BSIZE;

	if (sblock.e2fs_ncg == 1) {
		/* no alternate superblock; assume it's okey */
		havesb = 1;
		return 1;
	}

	getblk(&asblk, 1 * sblock.e2fs.e2fs_bpg + sblock.e2fs.e2fs_first_dblock,
		(long)SBSIZE);
	if (asblk.b_errs)
		return (0);
	if (bflag) {
		havesb = 1;
		return (1);
	}

	/*
	 * Set all possible fields that could differ, then do check
	 * of whole super block against an alternate super block.
	 * When an alternate super-block is specified this check is skipped.
	 */
	asblk.b_un.b_fs->e2fs_rbcount = sblk.b_un.b_fs->e2fs_rbcount;
	asblk.b_un.b_fs->e2fs_fbcount = sblk.b_un.b_fs->e2fs_fbcount;
	asblk.b_un.b_fs->e2fs_ficount = sblk.b_un.b_fs->e2fs_ficount;
	asblk.b_un.b_fs->e2fs_mtime = sblk.b_un.b_fs->e2fs_mtime;
	asblk.b_un.b_fs->e2fs_wtime = sblk.b_un.b_fs->e2fs_wtime;
	asblk.b_un.b_fs->e2fs_mnt_count = sblk.b_un.b_fs->e2fs_mnt_count;
	asblk.b_un.b_fs->e2fs_max_mnt_count = sblk.b_un.b_fs->e2fs_max_mnt_count;
	asblk.b_un.b_fs->e2fs_state = sblk.b_un.b_fs->e2fs_state;
	asblk.b_un.b_fs->e2fs_beh = sblk.b_un.b_fs->e2fs_beh;
	asblk.b_un.b_fs->e2fs_lastfsck = sblk.b_un.b_fs->e2fs_lastfsck;
	asblk.b_un.b_fs->e2fs_fsckintv = sblk.b_un.b_fs->e2fs_fsckintv;
	asblk.b_un.b_fs->e2fs_ruid = sblk.b_un.b_fs->e2fs_ruid;
	asblk.b_un.b_fs->e2fs_rgid = sblk.b_un.b_fs->e2fs_rgid;
	asblk.b_un.b_fs->e2fs_block_group_nr =
	    sblk.b_un.b_fs->e2fs_block_group_nr;
	asblk.b_un.b_fs->e2fs_features_rocompat &= ~EXT2F_ROCOMPAT_LARGEFILE;
	asblk.b_un.b_fs->e2fs_features_rocompat |=
	    sblk.b_un.b_fs->e2fs_features_rocompat & EXT2F_ROCOMPAT_LARGEFILE;
	if (sblock.e2fs.e2fs_rev > E2FS_REV0 &&
	    ((sblock.e2fs.e2fs_features_incompat & ~EXT2F_INCOMPAT_SUPP) ||
	    (sblock.e2fs.e2fs_features_rocompat & ~EXT2F_ROCOMPAT_SUPP))) {
		if (debug) {
			printf("compat 0x%08x, incompat 0x%08x, compat_ro "
			    "0x%08x\n",
			    sblock.e2fs.e2fs_features_compat,
			    sblock.e2fs.e2fs_features_incompat,
			    sblock.e2fs.e2fs_features_rocompat);
		}
		badsb(listerr,"INCOMPATIBLE FEATURE BITS IN SUPER BLOCK");
		return 0;
	}
	if (memcmp(sblk.b_un.b_fs, asblk.b_un.b_fs, SBSIZE)) {
		if (debug) {
			u_int32_t *nlp, *olp, *endlp;

			printf("superblock mismatches\n");
			nlp = (u_int32_t *)asblk.b_un.b_fs;
			olp = (u_int32_t *)sblk.b_un.b_fs;
			endlp = olp + (SBSIZE / sizeof *olp);
			for ( ; olp < endlp; olp++, nlp++) {
				if (*olp == *nlp)
					continue;
				printf("offset %ld, original %ld, alternate %ld\n",
					(long)(olp - (u_int32_t *)sblk.b_un.b_fs),
					(long)letoh32(*olp),
					(long)letoh32(*nlp));
			}
		}
		badsb(listerr,
		"VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE");
		return (0);
	}
	havesb = 1;
	return (1);
}

void
copyback_sb(struct bufarea *bp)
{
	/* Copy the in-memory superblock back to buffer */
	bp->b_un.b_fs->e2fs_icount = letoh32(sblock.e2fs.e2fs_icount);
	bp->b_un.b_fs->e2fs_bcount = letoh32(sblock.e2fs.e2fs_bcount);
	bp->b_un.b_fs->e2fs_rbcount = letoh32(sblock.e2fs.e2fs_rbcount);
	bp->b_un.b_fs->e2fs_fbcount = letoh32(sblock.e2fs.e2fs_fbcount);
	bp->b_un.b_fs->e2fs_ficount = letoh32(sblock.e2fs.e2fs_ficount);
	bp->b_un.b_fs->e2fs_first_dblock =
					letoh32(sblock.e2fs.e2fs_first_dblock);
	bp->b_un.b_fs->e2fs_log_bsize = letoh32(sblock.e2fs.e2fs_log_bsize);
	bp->b_un.b_fs->e2fs_log_fsize = letoh32(sblock.e2fs.e2fs_log_fsize);
	bp->b_un.b_fs->e2fs_bpg = letoh32(sblock.e2fs.e2fs_bpg);
	bp->b_un.b_fs->e2fs_fpg = letoh32(sblock.e2fs.e2fs_fpg);
	bp->b_un.b_fs->e2fs_ipg = letoh32(sblock.e2fs.e2fs_ipg);
	bp->b_un.b_fs->e2fs_mtime = letoh32(sblock.e2fs.e2fs_mtime);
	bp->b_un.b_fs->e2fs_wtime = letoh32(sblock.e2fs.e2fs_wtime);
	bp->b_un.b_fs->e2fs_lastfsck = letoh32(sblock.e2fs.e2fs_lastfsck);
	bp->b_un.b_fs->e2fs_fsckintv = letoh32(sblock.e2fs.e2fs_fsckintv);
	bp->b_un.b_fs->e2fs_creator = letoh32(sblock.e2fs.e2fs_creator);
	bp->b_un.b_fs->e2fs_rev = letoh32(sblock.e2fs.e2fs_rev);
	bp->b_un.b_fs->e2fs_mnt_count = letoh16(sblock.e2fs.e2fs_mnt_count);
	bp->b_un.b_fs->e2fs_max_mnt_count =
					letoh16(sblock.e2fs.e2fs_max_mnt_count);
	bp->b_un.b_fs->e2fs_magic = letoh16(sblock.e2fs.e2fs_magic);
	bp->b_un.b_fs->e2fs_state = letoh16(sblock.e2fs.e2fs_state);
	bp->b_un.b_fs->e2fs_beh = letoh16(sblock.e2fs.e2fs_beh);
	bp->b_un.b_fs->e2fs_ruid = letoh16(sblock.e2fs.e2fs_ruid);
	bp->b_un.b_fs->e2fs_rgid = letoh16(sblock.e2fs.e2fs_rgid);
}

void
badsb(int listerr, char *s)
{

	if (!listerr)
		return;
	if (preen)
		printf("%s: ", cdevname());
	pfatal("BAD SUPER BLOCK: %s\n", s);
}

/*
 * Calculate a prototype superblock based on information in the disk label.
 * When done the cgsblock macro can be calculated and the fs_ncg field
 * can be used. Do NOT attempt to use other macros without verifying that
 * their needed information is available!
 */
int
calcsb(char *dev, int devfd, struct m_ext2fs *fs, struct disklabel *lp)
{
	struct partition *pp;
	char *cp;

	cp = strchr(dev, '\0');
	if ((cp == NULL || (cp[-1] < 'a' || cp[-1] >= 'a' + MAXPARTITIONS)) &&
	    !isdigit((unsigned char)cp[-1])) {
		pfatal("%s: CANNOT FIGURE OUT FILE SYSTEM PARTITION\n", dev);
		return (0);
	}
	cp--;
	if (lp == NULL)
		pfatal("%s: CANNOT READ DISKLABEL\n", dev);
	if (isdigit((unsigned char)*cp))
		pp = &lp->d_partitions[0];
	else
		pp = &lp->d_partitions[*cp - 'a'];
	if (pp->p_fstype != FS_EXT2FS) {
		pfatal("%s: NOT LABELED AS A EXT2 FILE SYSTEM (%s)\n",
			dev, pp->p_fstype < FSMAXTYPES ?
			fstypenames[pp->p_fstype] : "unknown");
		return (0);
	}
	memset(fs, 0, sizeof(struct m_ext2fs));
	fs->e2fs_bsize = DISKLABELV1_FFS_FSIZE(pp->p_fragblock); /* XXX */
	if (fs->e2fs_bsize == 0) {
		pfatal("%s: BLOCK SIZE DETERMINED TO BE ZERO\n", dev);
		return (0);
	}
	fs->e2fs.e2fs_log_bsize = fs->e2fs_bsize / 1024;
	fs->e2fs.e2fs_bcount = (pp->p_size * DEV_BSIZE) / fs->e2fs_bsize;
	fs->e2fs.e2fs_first_dblock = (fs->e2fs.e2fs_log_bsize == 0) ? 1 : 0;
	fs->e2fs.e2fs_bpg = fs->e2fs_bsize * NBBY;
	fs->e2fs_bshift = LOG_MINBSIZE + fs->e2fs.e2fs_log_bsize;
	fs->e2fs_qbmask = fs->e2fs_bsize - 1;
	fs->e2fs_bmask = ~fs->e2fs_qbmask;
	fs->e2fs_ncg =
		howmany(fs->e2fs.e2fs_bcount - fs->e2fs.e2fs_first_dblock,
		fs->e2fs.e2fs_bpg);
	fs->e2fs_fsbtodb = fs->e2fs.e2fs_log_bsize + 1;
	fs->e2fs_ngdb = howmany(fs->e2fs_ncg,
		fs->e2fs_bsize / sizeof(struct ext2_gd));

	return (1);
}

static struct disklabel *
getdisklabel(char *s, int fd)
{
	static struct disklabel lab;

	if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
		if (s == NULL)
			return (NULL);
		pwarn("ioctl (GCINFO): %s\n", strerror(errno));
		errexit("%s: can't read disk label\n", s);
	}
	return (&lab);
}

daddr32_t
cgoverhead(int c)
{
	int overh;
	overh =	1 /* block bitmap */ +
		1 /* inode bitmap */ +
		sblock.e2fs_itpg;
	if (sblock.e2fs.e2fs_rev > E2FS_REV0 &&
	    sblock.e2fs.e2fs_features_rocompat & EXT2F_ROCOMPAT_SPARSESUPER) {
		if (cg_has_sb(c) == 0)
			return overh;
	}
	overh += 1 + sblock.e2fs_ngdb;
	return overh;
}
@


1.29
log
@corrects pledge code for fsck_ffs and fsck_ext2fs

on filesystem error, fsck will try to display username of inode, resulting need
of "getpw" for not SMALL version.

add a missed (?) -DSMALL in distrib/special/ for fsck_ffs and fsck_ext2fs

found by hard way by ajacoutot@@

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.28 2015/10/14 16:58:55 deraadt Exp $	*/
d302 1
a302 1
	sblock.e2fs_ipb = sblock.e2fs_bsize / sizeof(struct ext2fs_dinode);
@


1.28
log
@Since the fsck_* programs now only handle one filesystem, this creates
a point where open() and disklabel reading have completed.  After that
point, pledge "stdio".

As a result, an fsck of a hostile partition (noone ever does that, or
do they? :) is done by a program with SUBSTANTIALLY less system call
exposure.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.27 2015/09/10 15:21:40 deraadt Exp $	*/
d116 4
d122 1
@


1.27
log
@avoid divide by zero; from Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.26 2015/08/20 22:02:20 deraadt Exp $	*/
d13 1
a13 1
 *	notice, this list of conditions and the following disclaimer.
d15 2
a16 2
 *	notice, this list of conditions and the following disclaimer in the
 *	documentation and/or other materials provided with the distribution.
d18 2
a19 2
 *	may be used to endorse or promote products derived from this software
 *	without specific prior written permission.
d48 1
d51 1
d60 1
a60 1
int calcsb(char *, int, struct m_ext2fs *);
d110 1
a110 1
	if ((lp = getdisklabel((char *)NULL, fsreadfd)) != NULL)
d114 6
d124 1
a124 1
		if (bflag || preen || calcsb(dev, fsreadfd, &proto) == 0)
d136 6
a141 6
				"SEARCH FOR ALTERNATE SUPER-BLOCK",
				"FAILED. YOU MUST USE THE",
				"-b OPTION TO FSCK_FFS TO SPECIFY THE",
				"LOCATION OF AN ALTERNATE",
				"SUPER-BLOCK TO SUPPLY NEEDED",
				"INFORMATION; SEE fsck_ext2fs(8).");
d152 1
a152 1
				preen ? "f" : "** F");
a431 1

d433 1
a433 1
calcsb(char *dev, int devfd, struct m_ext2fs *fs)
a434 1
	struct disklabel *lp;
d445 2
a446 1
	lp = getdisklabel(dev, devfd);
d487 1
a487 1
			return ((struct disklabel *)NULL);
@


1.26
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.25 2015/01/16 06:39:57 deraadt Exp $	*/
d215 1
a215 1
	typemap = calloc((unsigned)(maxino + 1), sizeof(char));
d452 4
@


1.25
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.24 2014/11/20 15:22:39 tedu Exp $	*/
d221 1
a221 1
	lncntp = (int16_t *)calloc((unsigned)(maxino + 1), sizeof(int16_t));
d232 2
a233 4
	inpsort = (struct inoinfo **)calloc((unsigned)listmax,
		sizeof(struct inoinfo *));
	inphead = (struct inoinfo **)calloc((unsigned)numdirs,
		sizeof(struct inoinfo *));
@


1.24
log
@remove sys/file.h includes in favor of fcntl.h where needed.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.23 2014/07/13 16:08:53 pelikan Exp $	*/
d35 1
a35 1
#include <sys/param.h>
@


1.23
log
@kill fs2hXX/h2fsXX macros with letohXX/htoleXX

The reason being that ext2 structures are little-endian but JBD2 journal
is big-endian.  Don't confuse readers by talking about "file system endian".

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.22 2014/07/13 13:50:00 pelikan Exp $	*/
a42 1
#include <sys/file.h>
@


1.22
log
@new superblock header needs fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.21 2014/07/11 15:54:52 tobias Exp $	*/
d229 1
a229 1
		numdirs += fs2h16(sblock.e2fs_gd[cg].ext2bgd_ndirs);
d366 2
a367 2
					(long)fs2h32(*olp),
					(long)fs2h32(*nlp));
d382 5
a386 5
	bp->b_un.b_fs->e2fs_icount = fs2h32(sblock.e2fs.e2fs_icount);
	bp->b_un.b_fs->e2fs_bcount = fs2h32(sblock.e2fs.e2fs_bcount);
	bp->b_un.b_fs->e2fs_rbcount = fs2h32(sblock.e2fs.e2fs_rbcount);
	bp->b_un.b_fs->e2fs_fbcount = fs2h32(sblock.e2fs.e2fs_fbcount);
	bp->b_un.b_fs->e2fs_ficount = fs2h32(sblock.e2fs.e2fs_ficount);
d388 13
a400 13
					fs2h32(sblock.e2fs.e2fs_first_dblock);
	bp->b_un.b_fs->e2fs_log_bsize = fs2h32(sblock.e2fs.e2fs_log_bsize);
	bp->b_un.b_fs->e2fs_log_fsize = fs2h32(sblock.e2fs.e2fs_log_fsize);
	bp->b_un.b_fs->e2fs_bpg = fs2h32(sblock.e2fs.e2fs_bpg);
	bp->b_un.b_fs->e2fs_fpg = fs2h32(sblock.e2fs.e2fs_fpg);
	bp->b_un.b_fs->e2fs_ipg = fs2h32(sblock.e2fs.e2fs_ipg);
	bp->b_un.b_fs->e2fs_mtime = fs2h32(sblock.e2fs.e2fs_mtime);
	bp->b_un.b_fs->e2fs_wtime = fs2h32(sblock.e2fs.e2fs_wtime);
	bp->b_un.b_fs->e2fs_lastfsck = fs2h32(sblock.e2fs.e2fs_lastfsck);
	bp->b_un.b_fs->e2fs_fsckintv = fs2h32(sblock.e2fs.e2fs_fsckintv);
	bp->b_un.b_fs->e2fs_creator = fs2h32(sblock.e2fs.e2fs_creator);
	bp->b_un.b_fs->e2fs_rev = fs2h32(sblock.e2fs.e2fs_rev);
	bp->b_un.b_fs->e2fs_mnt_count = fs2h16(sblock.e2fs.e2fs_mnt_count);
d402 6
a407 6
					fs2h16(sblock.e2fs.e2fs_max_mnt_count);
	bp->b_un.b_fs->e2fs_magic = fs2h16(sblock.e2fs.e2fs_magic);
	bp->b_un.b_fs->e2fs_state = fs2h16(sblock.e2fs.e2fs_state);
	bp->b_un.b_fs->e2fs_beh = fs2h16(sblock.e2fs.e2fs_beh);
	bp->b_un.b_fs->e2fs_ruid = fs2h16(sblock.e2fs.e2fs_ruid);
	bp->b_un.b_fs->e2fs_rgid = fs2h16(sblock.e2fs.e2fs_rgid);
@


1.21
log
@Prevent division by zero on erroneous file systems.

ok pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.20 2014/05/22 14:04:41 krw Exp $	*/
d390 1
a390 1
	bp->b_un.b_fs->e2fs_fsize = fs2h32(sblock.e2fs.e2fs_fsize);
@


1.20
log
@Nuke pointless dev_bsize variable which is always set to 512, and just
use DEV_BSIZE.

Write sizes need to be secsize and not DEV_BSIZE, just like reads.

Equivalent to changes made in fsck_ffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.19 2013/11/22 04:38:02 guenther Exp $	*/
d274 3
@


1.19
log
@Kirk was being waaaay too chummy with the compiler when he trusted
it to not optimize away a comparison against NULL-1.
Add (unsigned char) casts for some ctype calls.
Teach fsck_ext2fs about MAXPARTITIONS, letting it operate on
partitions 'i' through 'p'.

ok deraadt@@ millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.18 2011/03/12 17:50:47 deraadt Exp $	*/
d110 1
a110 1
		dev_bsize = secsize = lp->d_secsize;
d112 1
a112 1
		dev_bsize = secsize = DEV_BSIZE;
d256 1
a256 1
	daddr32_t super = bflag ? bflag : SBOFF / dev_bsize;
d297 1
a297 3
	super *= dev_bsize;
	dev_bsize = sblock.e2fs_bsize / fsbtodb(&sblock, 1);
	sblk.b_bno = super / dev_bsize;
@


1.18
log
@These utilities can currently only operate with a 32-bit block number range,
so use daddr32_t
ok jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.17 2010/05/18 04:41:14 dlg Exp $	*/
d434 3
a436 2
	cp = strchr(dev, '\0') - 1;
	if ((cp == (char *)-1 || (*cp < 'a' || *cp > 'h')) && !isdigit(*cp)) {
d440 1
d442 1
a442 1
	if (isdigit(*cp))
@


1.17
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.16 2010/03/08 11:19:04 otto Exp $	*/
d256 1
a256 1
	daddr_t super = bflag ? bflag : SBOFF / dev_bsize;
d483 1
a483 1
daddr_t
@


1.16
log
@if ncg == 1, there's no alternate superblock; from NetBSD; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.15 2007/09/02 15:19:23 deraadt Exp $	*/
d41 1
@


1.15
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.14 2007/05/29 06:28:15 otto Exp $	*/
d299 6
@


1.14
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.13 2005/04/30 13:56:16 niallo Exp $	*/
d184 1
a184 1
	sblock.e2fs_gd = malloc(sblock.e2fs_ngdb * sblock.e2fs_bsize);
@


1.13
log
@Support checking filesystems which have or once had large files (>4 GB)
on them.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.12 2003/07/29 18:38:35 deraadt Exp $	*/
d444 2
a445 2
	fs->e2fs_bsize = pp->p_fsize;
	fs->e2fs.e2fs_log_bsize = pp->p_fsize / 1024;
@


1.12
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.11 2003/06/11 06:22:13 deraadt Exp $	*/
d329 3
@


1.11
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.10 2003/06/02 20:06:15 millert Exp $	*/
d264 1
a264 1
	
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.9 2002/06/09 08:13:05 todd Exp $	*/
d63 1
a63 2
setup(dev)
	char *dev;
d253 1
a253 2
readsb(listerr)
	int listerr;
d368 1
a368 2
copyback_sb(bp)
	struct bufarea *bp;
d400 1
a400 3
badsb(listerr, s)
	int listerr;
	char *s;
d418 1
a418 4
calcsb(dev, devfd, fs)
	char *dev;
	int devfd;
	struct m_ext2fs *fs;
d460 1
a460 3
getdisklabel(s, fd)
	char *s;
	int	fd;
d474 1
a474 2
cgoverhead(c)
	int c;
@


1.9
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.8 2002/02/16 21:27:34 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *	must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.7 2001/09/18 17:43:15 art Exp $	*/
d224 1
a224 1
		goto badsblabel; 
d228 1
a228 1
		printf("cannot alloc %u bytes for lncntp\n", 
d242 1
a242 1
		printf("cannot alloc %u bytes for inphead\n", 
@


1.7
log
@cleanups and endianness fixes. Mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.6 2000/04/26 23:26:06 jasoni Exp $	*/
d61 4
a64 4
void badsb __P((int, char *));
int calcsb __P((char *, int, struct m_ext2fs *));
static struct disklabel *getdisklabel __P((char *, int));
static int readsb __P((int));
@


1.6
log
@Support for ext2fs rev. 1
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.5 1999/08/17 09:13:14 millert Exp $	*/
a37 12
#ifndef lint
#if 0
static char sccsid[] = "@@(#)setup.c	8.5 (Berkeley) 11/23/94";
#else
#if 0
static char rcsid[] = "$NetBSD: setup.c,v 1.1 1997/06/11 11:22:01 bouyer Exp $";
#else
static char rcsid[] = "$OpenBSD: setup.c,v 1.5 1999/08/17 09:13:14 millert Exp $";
#endif
#endif
#endif /* not lint */

d430 1
a430 1
	register struct m_ext2fs *fs;
d432 3
a434 3
	register struct disklabel *lp;
	register struct partition *pp;
	register char *cp;
@


1.5
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.4 1997/06/14 05:04:12 downsj Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.4 1997/06/14 05:04:12 downsj Exp $";
d58 1
a70 2
struct bufarea asblk;
#define altsblock (*asblk.b_un.b_fs)
d74 1
a74 1
/* int calcsb __P((char *, int, struct m_ext2fs *)); */
d82 1
a82 1
	long cg, size, asked, i, j;
d121 2
a122 2
	sblk.b_un.b_buf = malloc(sizeof(struct m_ext2fs));
	asblk.b_un.b_buf = malloc(sizeof(struct m_ext2fs));
d185 1
d194 1
a194 1
		memcpy(&altsblock, &sblock, (size_t)SBSIZE);
d202 2
d232 6
d241 1
a241 1
			(unsigned)(maxino + 1) * sizeof(int16_t));
d245 1
a245 1
		numdirs += sblock.e2fs_gd[cg].ext2bgd_ndirs;
d255 1
a255 1
			(unsigned)numdirs * sizeof(struct inoinfo *));
d275 1
a275 1
	if (bread(fsreadfd, (char *)&sblock.e2fs, super, (long)SBSIZE) != 0)
d279 4
a308 8
	cgoverhead =	1 /* super block */ +
					sblock.e2fs_ngdb +
					1 /* block bitmap */ +
					1 /* inode bitmap */ +
					sblock.e2fs_itpg;

	if (debug) /* DDD */
		printf("cg overhead %d blocks \n", cgoverhead);
d317 5
d332 29
a360 18
	getblk(&asblk, 1 * sblock.e2fs.e2fs_bpg + sblock.e2fs.e2fs_first_dblock,
		(long)SBSIZE);
	if (asblk.b_errs)
		return (0);
	altsblock.e2fs.e2fs_rbcount = sblock.e2fs.e2fs_rbcount;
	altsblock.e2fs.e2fs_fbcount = sblock.e2fs.e2fs_fbcount;
	altsblock.e2fs.e2fs_ficount = sblock.e2fs.e2fs_ficount;
	altsblock.e2fs.e2fs_mtime = sblock.e2fs.e2fs_mtime;
	altsblock.e2fs.e2fs_wtime = sblock.e2fs.e2fs_wtime;
	altsblock.e2fs.e2fs_mnt_count = sblock.e2fs.e2fs_mnt_count;
	altsblock.e2fs.e2fs_max_mnt_count = sblock.e2fs.e2fs_max_mnt_count;
	altsblock.e2fs.e2fs_state = sblock.e2fs.e2fs_state;
	altsblock.e2fs.e2fs_beh = sblock.e2fs.e2fs_beh;
	altsblock.e2fs.e2fs_lastfsck = sblock.e2fs.e2fs_lastfsck;
	altsblock.e2fs.e2fs_fsckintv = sblock.e2fs.e2fs_fsckintv;
	altsblock.e2fs.e2fs_ruid = sblock.e2fs.e2fs_ruid;
	altsblock.e2fs.e2fs_rgid = sblock.e2fs.e2fs_rgid;
	if (memcmp(&(sblock.e2fs), &(altsblock.e2fs), (int)SBSIZE)) {
d362 1
a362 1
			long *nlp, *olp, *endlp;
d365 2
a366 2
			nlp = (long *)&altsblock;
			olp = (long *)&sblock;
d371 4
a374 2
				printf("offset %d, original %ld, alternate %ld\n",
					olp - (long *)&sblock, *olp, *nlp);
d386 33
a446 1
	int i;
d458 2
a459 2
	if (pp->p_fstype != FS_BSDFFS) {
		pfatal("%s: NOT LABELED AS A BSD FILE SYSTEM (%s)\n",
d465 2
a466 2
	fs->e2fs_bsize = 1024; /* XXX to look for altenate SP */
	fs->e2fs.e2fs_log_bsize = 0;
d468 1
a468 1
	fs->e2fs.e2fs_first_dblock = 1;
a479 2


d497 17
@


1.4
log
@s/malloc.h/stdlib.h in pass5.c, and actually malloc() enough memory in
setup() for the superblock!
@
text
@d1 1
a1 1
/*	$OpenBSD: setup.c,v 1.3 1997/06/14 04:16:59 downsj Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: setup.c,v 1.3 1997/06/14 04:16:59 downsj Exp $";
a57 1
#include <sys/file.h>
d60 1
@


1.3
log
@Add tags, fix man page.  Purely cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD$";
d122 2
a123 2
	sblk.b_un.b_buf = malloc(SBSIZE);
	asblk.b_un.b_buf = malloc(SBSIZE);
@


1.2
log
@Sync with NetBSD.  Purely cosmetic.
@
text
@d1 1
d42 1
d44 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/*	$NetBSD: setup.c,v 1.27 1996/09/27 22:45:19 christos Exp $	*/

/* Modified for EXT2FS on NetBSD by Manuel Bouyer, April 1997 */
d4 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: setup.c,v 1.27 1996/09/27 22:45:19 christos Exp $";
@


1.1.1.1
log
@Initial import of Manuel's fsck_ext2fs, unmodified.
@
text
@@
