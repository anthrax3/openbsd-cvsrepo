head	1.77;
access;
symbols
	OPENBSD_6_0:1.75.0.4
	OPENBSD_6_0_BASE:1.75
	OPENBSD_5_9:1.75.0.2
	OPENBSD_5_9_BASE:1.75
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.52.0.4
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.52.0.2
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.12
	OPENBSD_5_0:1.50.0.10
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.8
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.50.0.6
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.50.0.4
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.47.0.4
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.42.0.4
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.40.0.4
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.36.0.4
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.77
date	2017.03.26.00.22.49;	author sobrado;	state Exp;
branches;
next	1.76;
commitid	lpOWwLYQ6gUoQOWs;

1.76
date	2016.12.27.15.01.03;	author krw;	state Exp;
branches;
next	1.75;
commitid	esTMNhggsn9ESVoW;

1.75
date	2015.11.26.08.15.07;	author tim;	state Exp;
branches;
next	1.74;
commitid	K0ReHvH17yLhzwH2;

1.74
date	2015.11.19.16.14.08;	author krw;	state Exp;
branches;
next	1.73;
commitid	07Axfimkfyb7znjO;

1.73
date	2015.10.26.15.08.26;	author krw;	state Exp;
branches;
next	1.72;
commitid	fOI5D0M32zdW7eoe;

1.72
date	2015.03.27.16.06.00;	author krw;	state Exp;
branches;
next	1.71;
commitid	AfQuszZYKfWc5CVd;

1.71
date	2015.03.27.15.56.45;	author krw;	state Exp;
branches;
next	1.70;
commitid	1qcofhP71FYYG1th;

1.70
date	2015.03.26.14.08.12;	author krw;	state Exp;
branches;
next	1.69;
commitid	2pp42lVbpnraZMs8;

1.69
date	2015.03.16.23.51.50;	author krw;	state Exp;
branches;
next	1.68;
commitid	JG85Pc2Xt4lLAJpr;

1.68
date	2015.03.14.18.32.29;	author krw;	state Exp;
branches;
next	1.67;
commitid	VCsOzs6eGW0SpJ6c;

1.67
date	2015.03.14.15.21.53;	author krw;	state Exp;
branches;
next	1.66;
commitid	aPXwn1AfAIMw4FVu;

1.66
date	2014.05.05.17.18.08;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2014.03.31.22.03.29;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.31.19.50.52;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2014.03.25.12.59.03;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2014.03.22.15.40.04;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.20.13.43.32;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2014.03.20.13.18.21;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.17.16.40.00;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2014.03.17.13.15.44;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.14.15.41.33;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2014.03.13.12.02.28;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2014.03.09.22.25.06;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2014.03.07.21.56.13;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.21.18.45.58;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2012.07.25.19.49.11;	author otto;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.11.10.27.34;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2009.04.29.22.58.24;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2009.04.01.15.00.55;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.24.15.10.03;	author todd;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.31.09.45.01;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.18.21.33.05;	author sobrado;	state Exp;
branches;
next	1.45;

1.45
date	2007.07.04.16.34.15;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.10.11.38.27;	author sobrado;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.04.14.36.05;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.09.17.01.47;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.21.01.59.24;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.10.17.29.41;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.03.09.22.03;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.13.06.00.33;	author tom;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.10.08.43.36;	author tom;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.02.21.44.57;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.03.01.13.19;	author weingart;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.19.18.42.14;	author avsm;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.13.22.41.03;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.12.17.56.35;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.18.08.38.26;	author kjell;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.18.08.29.01;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.14.16.42.27;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.07.01.27.33;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.02.13.51.18;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.23.04.27.30;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.23.01.54.38;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.18.20.22.02;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.18.07.15.18;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.16.19.02.14;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.01.21.49.12;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.11.16.11.55;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.10.15.56.42;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.29.01.53.01;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.08.04.51.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.11.23.01.56.39;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.07.22.22.05.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.02.09.19.06.36;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.09.18.02.36.56;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.09.14.03.54.35;	author rahnds;	state Exp;
branches;
next	1.8;

1.8
date	98.02.19.20.48.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.21.22.49.34;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.10.19.23.29.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.16.01.53.08;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.16.01.47.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.02.02.10.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.09.29.23.33.39;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.09.29.22.58.18;	author weingart;	state Exp;
branches;
next	;


desc
@@


1.77
log
@cleanup fdisk(8) partition names used by FAT file systems so they are more
consistent and easier to identify, as outlined here:

    - FAT12: FAT12 (01h)
    - FAT16: FAT16S (04h), FAT16B (06h), FAT16L (0Eh)
    - FAT32: FAT32 (0Bh), FAT32L (0Ch)

nothing in our tree is looking to the strings being replaced for anything
but printing them out, only to the numerical ids taken from disklabel.h

ok krw@@, jmc@@
@
text
@/*	$OpenBSD: part.c,v 1.76 2016/12/27 15:01:03 krw Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/disklabel.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <uuid.h>

#include "disk.h"
#include "misc.h"
#include "part.h"

int	PRT_check_chs(struct prt *partn);

static const struct part_type {
	int	type;
	char	sname[14];
	char	guid[37];
} part_types[] = {
	{ 0x00, "unused      ", "00000000-0000-0000-0000-000000000000" },
	{ 0x01, "FAT12       ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x02, "XENIX /     "},   /* XENIX / filesystem */
	{ 0x03, "XENIX /usr  "},   /* XENIX /usr filesystem */
	{ 0x04, "FAT16S      ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x05, "Extended DOS"},   /* Extended DOS */
	{ 0x06, "FAT16B      ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x07, "NTFS        ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x08, "AIX fs      "},   /* AIX filesystem */
	{ 0x09, "AIX/Coherent"},   /* AIX boot partition or Coherent */
	{ 0x0A, "OS/2 Bootmgr"},   /* OS/2 Boot Manager or OPUS */
	{ 0x0B, "FAT32       ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x0C, "FAT32L      ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x0E, "FAT16L      ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x0F, "Extended LBA"},   /* Extended DOS LBA-mapped */
	{ 0x10, "OPUS        "},   /* OPUS */
	{ 0x11, "OS/2 hidden ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x12, "Compaq Diag."},   /* Compaq Diagnostics */
	{ 0x14, "OS/2 hidden ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x16, "OS/2 hidden ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x17, "OS/2 hidden ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x18, "AST swap    "},   /* AST Windows swapfile */
	{ 0x19, "Willowtech  "},   /* Willowtech Photon coS */
	{ 0x1C, "ThinkPad Rec", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x24, "NEC DOS     "},   /* NEC DOS */
	{ 0x27, "Win Recovery", "de94bba4-06d1-4d40-a16a-bfd50179d6ac" },
	{ 0x20, "Willowsoft  "},   /* Willowsoft OFS1 */
	{ 0x38, "Theos       "},   /* Theos */
	{ 0x39, "Plan 9      "},   /* Plan 9 */
	{ 0x40, "VENIX 286   "},   /* VENIX 286 or LynxOS */
	{ 0x41, "Lin/Minux DR"},   /* Linux/MINIX (sharing disk with DRDOS) or Personal RISC boot */
	{ 0x42, "LinuxSwap DR", "af9b60a0-1431-4f62-bc68-3311714a69ad" },
	{ 0x43, "Linux DR    "},   /* Linux native (sharing disk with DRDOS) */
	{ 0x4D, "QNX 4.2 Pri "},   /* QNX 4.2 Primary */
	{ 0x4E, "QNX 4.2 Sec "},   /* QNX 4.2 Secondary */
	{ 0x4F, "QNX 4.2 Ter "},   /* QNX 4.2 Tertiary */
	{ 0x50, "DM          "},   /* DM (disk manager) */
	{ 0x51, "DM          "},   /* DM6 Aux1 (or Novell) */
	{ 0x52, "CP/M or SysV"},   /* CP/M or Microport SysV/AT */
	{ 0x53, "DM          "},   /* DM6 Aux3 */
	{ 0x54, "Ontrack     "},   /* Ontrack */
	{ 0x55, "EZ-Drive    "},   /* EZ-Drive (disk manager) */
	{ 0x56, "Golden Bow  "},   /* Golden Bow (disk manager) */
	{ 0x5C, "Priam       "},   /* Priam Edisk (disk manager) */
	{ 0x61, "SpeedStor   "},   /* SpeedStor */
	{ 0x63, "ISC, HURD, *"},   /* ISC, System V/386, GNU HURD or Mach */
	{ 0x64, "NetWare 2.xx"},   /* Novell NetWare 2.xx */
	{ 0x65, "NetWare 3.xx"},   /* Novell NetWare 3.xx */
	{ 0x66, "NetWare 386 "},   /* Novell 386 NetWare */
	{ 0x67, "Novell      "},   /* Novell */
	{ 0x68, "Novell      "},   /* Novell */
	{ 0x69, "Novell      "},   /* Novell */
	{ 0x70, "DiskSecure  "},   /* DiskSecure Multi-Boot */
	{ 0x75, "PCIX        "},   /* PCIX */
	{ 0x7f, "ChromeKernel", "fe3a2a5d-4f32-41a7-b725-accc3285a309" },
	{ 0x80, "Minix (old) "},   /* Minix 1.1 ... 1.4a */
	{ 0x81, "Minix (new) "},   /* Minix 1.4b ... 1.5.10 */
	{ 0x82, "Linux swap  ", "0657fd6d-a4ab-43c4-84e5-0933c84b4f4f" },
	{ 0x83, "Linux files*", "0fc63daf-8483-4772-8e79-3d69d8477de4" },
	{ 0x84, "OS/2 hidden "},   /* OS/2 hidden C: drive */
	{ 0x85, "Linux ext.  "},   /* Linux extended */
	{ 0x86, "NT FAT VS   "},   /* NT FAT volume set */
	{ 0x87, "NTFS VS     "},   /* NTFS volume set or HPFS mirrored */
	{ 0x8E, "Linux LVM   ", "e6d6d379-f507-44c2-a23c-238f2a3df928" },
	{ 0x93, "Amoeba FS   "},   /* Amoeba filesystem */
	{ 0x94, "Amoeba BBT  "},   /* Amoeba bad block table */
	{ 0x99, "Mylex       "},   /* Mylex EISA SCSI */
	{ 0x9F, "BSDI        "},   /* BSDI BSD/OS */
	{ 0xA0, "NotebookSave"},   /* Phoenix NoteBIOS save-to-disk */
	{ 0xA5, "FreeBSD     ", "516e7cb4-6ecf-11d6-8ff8-00022d09712b" },
	{ 0xA6, "OpenBSD     ", "824cc7a0-36a8-11e3-890a-952519ad3f61" },
	{ 0xA7, "NEXTSTEP    "},   /* NEXTSTEP */
	{ 0xA8, "MacOS X     ", "55465300-0000-11aa-aa11-00306543ecac" },
	{ 0xA9, "NetBSD      ", "516e7cb4-6ecf-11d6-8ff8-00022d09712b" },
	{ 0xAB, "MacOS X boot", "426f6f74-0000-11aa-aa11-00306543ecac" },
	{ 0xAF, "MacOS X HFS+", "48465300-0000-11aa-aa11-00306543ecac" },
	{ 0xB7, "BSDI filesy*"},   /* BSDI BSD/386 filesystem */
	{ 0xB8, "BSDI swap   "},   /* BSDI BSD/386 swap */
	{ 0xBF, "Solaris     ", "6a85cf4d-1dd2-11b2-99a6-080020736631" },
	{ 0xC0, "CTOS        "},   /* CTOS */
	{ 0xC1, "DRDOSs FAT12"},   /* DRDOS/sec (FAT-12) */
	{ 0xC4, "DRDOSs < 32M"},   /* DRDOS/sec (FAT-16, < 32M) */
	{ 0xC6, "DRDOSs >=32M"},   /* DRDOS/sec (FAT-16, >= 32M) */
	{ 0xC7, "HPFS Disbled"},   /* Syrinx (Cyrnix?) or HPFS disabled */
	{ 0xDB, "CPM/C.DOS/C*"},   /* Concurrent CPM or C.DOS or CTOS */
	{ 0xDE, "Dell Maint  "},   /* Dell maintenance partition */
	{ 0xE1, "SpeedStor   "},   /* DOS access or SpeedStor 12-bit FAT extended partition */
	{ 0xE3, "SpeedStor   "},   /* DOS R/O or SpeedStor or Storage Dimensions */
	{ 0xE4, "SpeedStor   "},   /* SpeedStor 16-bit FAT extended partition < 1024 cyl. */
	{ 0xEB, "BeOS/i386   ", "42465331-3ba3-10f1-802a-4861696b7521" },
	{ 0xEE, "EFI GPT     "},   /* EFI Protective Partition */
	{ 0xEF, "EFI Sys     ", "c12a7328-f81f-11d2-ba4b-00a0c93ec93b" },
	{ 0xF1, "SpeedStor   "},   /* SpeedStor or Storage Dimensions */
	{ 0xF2, "DOS 3.3+ Sec"},   /* DOS 3.3+ Secondary */
	{ 0xF4, "SpeedStor   "},   /* SpeedStor >1024 cyl. or LANstep or IBM PS/2 IML */
	{ 0xFF, "Xenix BBT   "},   /* Xenix Bad Block Table */
};

void
PRT_printall(void)
{
	int i, idrows;

	idrows = ((sizeof(part_types)/sizeof(struct part_type))+3)/4;

	printf("Choose from the following Partition id values:\n");
	for (i = 0; i < idrows; i++) {
		printf("%02X %s   %02X %s   %02X %s",
		    part_types[i].type, part_types[i].sname,
		    part_types[i+idrows].type, part_types[i+idrows].sname,
		    part_types[i+idrows*2].type, part_types[i+idrows*2].sname);
		if ((i+idrows*3) < (sizeof(part_types)/sizeof(struct part_type))) {
			printf("   %02X %s\n",
			    part_types[i+idrows*3].type,
			    part_types[i+idrows*3].sname);
		} else
			printf( "\n" );
	}
}

const char *
PRT_ascii_id(int id)
{
	static char unknown[] = "<Unknown ID>";
	int i;

	for (i = 0; i < sizeof(part_types)/sizeof(struct part_type); i++) {
		if (part_types[i].type == id)
			return (part_types[i].sname);
	}

	return (unknown);
}

void
PRT_parse(struct dos_partition *prt, off_t offset, off_t reloff,
    struct prt *partn)
{
	off_t off;
	u_int32_t t;

	partn->flag = prt->dp_flag;
	partn->shead = prt->dp_shd;

	partn->ssect = (prt->dp_ssect) & 0x3F;
	partn->scyl = ((prt->dp_ssect << 2) & 0xFF00) | prt->dp_scyl;

	partn->id = prt->dp_typ;
	partn->ehead = prt->dp_ehd;
	partn->esect = (prt->dp_esect) & 0x3F;
	partn->ecyl = ((prt->dp_esect << 2) & 0xFF00) | prt->dp_ecyl;

	if ((partn->id == DOSPTYP_EXTEND) || (partn->id == DOSPTYP_EXTENDL))
		off = reloff;
	else
		off = offset;

#if 0 /* XXX */
	partn->bs = letoh32(prt->dp_start) + off;
	partn->ns = letoh32(prt->dp_size);
#else
	memcpy(&t, &prt->dp_start, sizeof(u_int32_t));
	partn->bs = letoh32(t) + off;
	memcpy(&t, &prt->dp_size, sizeof(u_int32_t));
	partn->ns = letoh32(t);
#endif

	PRT_fix_CHS(partn);
}

int
PRT_check_chs(struct prt *partn)
{
	if ( (partn->shead > 255) ||
		(partn->ssect >63) ||
		(partn->scyl > 1023) ||
		(partn->ehead >255) ||
		(partn->esect >63) ||
		(partn->ecyl > 1023) )
	{
		return (0);
	}
	return (1);
}

void
PRT_make(struct prt *partn, off_t offset, off_t reloff,
    struct dos_partition *prt)
{
	off_t off;
	u_int32_t ecsave, scsave;
	u_int64_t t;

	/* Save (and restore below) cylinder info we may fiddle with. */
	scsave = partn->scyl;
	ecsave = partn->ecyl;

	if ((partn->scyl > 1023) || (partn->ecyl > 1023)) {
		partn->scyl = (partn->scyl > 1023)? 1023: partn->scyl;
		partn->ecyl = (partn->ecyl > 1023)? 1023: partn->ecyl;
	}
	if ((partn->id == DOSPTYP_EXTEND) || (partn->id == DOSPTYP_EXTENDL))
		off = reloff;
	else
		off = offset;

	if (PRT_check_chs(partn)) {
		prt->dp_shd = partn->shead & 0xFF;
		prt->dp_ssect = (partn->ssect & 0x3F) |
		    ((partn->scyl & 0x300) >> 2);
		prt->dp_scyl = partn->scyl & 0xFF;
		prt->dp_ehd = partn->ehead & 0xFF;
		prt->dp_esect = (partn->esect & 0x3F) |
		    ((partn->ecyl & 0x300) >> 2);
		prt->dp_ecyl = partn->ecyl & 0xFF;
	} else {
		memset(prt, 0xFF, sizeof(*prt));
	}

	prt->dp_flag = partn->flag & 0xFF;
	prt->dp_typ = partn->id & 0xFF;

	t = htole64(partn->bs - off);
	memcpy(&prt->dp_start, &t, sizeof(u_int32_t));
	t = htole64(partn->ns);
	memcpy(&prt->dp_size, &t, sizeof(u_int32_t));

	partn->scyl = scsave;
	partn->ecyl = ecsave;
}

void
PRT_print(int num, struct prt *partn, char *units)
{
	const int secsize = unit_types[SECTORS].conversion;
	double size;
	int i;

	i = unit_lookup(units);

	if (partn == NULL) {
		printf("            Starting         Ending    "
		    "     LBA Info:\n");
		printf(" #: id      C   H   S -      C   H   S "
		    "[       start:        size ]\n");
		printf("---------------------------------------"
		    "----------------------------------------\n");
	} else {
		size = ((double)partn->ns * secsize) / unit_types[i].conversion;
		printf("%c%1d: %.2X %6u %3u %3u - %6u %3u %3u "
		    "[%12llu:%12.0f%s] %s\n",
		    (partn->flag == DOSACTIVE)?'*':' ',
		    num, partn->id,
		    partn->scyl, partn->shead, partn->ssect,
		    partn->ecyl, partn->ehead, partn->esect,
		    partn->bs, size,
		    unit_types[i].abbr,
		    PRT_ascii_id(partn->id));
	}
}

void
PRT_fix_BN(struct prt *part, int pn)
{
	u_int32_t spt, tpc, spc;
	u_int32_t start = 0;
	u_int32_t end = 0;

	/* Zero out entry if not used */
	if (part->id == DOSPTYP_UNUSED) {
		memset(part, 0, sizeof(*part));
		return;
	}

	/* Disk geometry. */
	spt = disk.sectors;
	tpc = disk.heads;
	spc = spt * tpc;

	start += part->scyl * spc;
	start += part->shead * spt;
	start += part->ssect - 1;

	end += part->ecyl * spc;
	end += part->ehead * spt;
	end += part->esect - 1;

	/* XXX - Should handle this... */
	if (start > end)
		warnx("Start of partition #%d after end!", pn);

	part->bs = start;
	part->ns = (end - start) + 1;
}

void
PRT_fix_CHS(struct prt *part)
{
	u_int32_t spt, tpc, spc;
	u_int32_t start, end, size;
	u_int32_t cyl, head, sect;

	/* Zero out entry if not used */
	if (part->id == DOSPTYP_UNUSED || part->ns == 0) {
		memset(part, 0, sizeof(*part));
		return;
	}

	/* Disk geometry. */
	spt = disk.sectors;
	tpc = disk.heads;
	spc = spt * tpc;

	start = part->bs;
	size = part->ns;
	end = (start + size) - 1;

	/* Figure out starting CHS values */
	cyl = (start / spc); start -= (cyl * spc);
	head = (start / spt); start -= (head * spt);
	sect = (start + 1);

	part->scyl = cyl;
	part->shead = head;
	part->ssect = sect;

	/* Figure out ending CHS values */
	cyl = (end / spc); end -= (cyl * spc);
	head = (end / spt); end -= (head * spt);
	sect = (end + 1);

	part->ecyl = cyl;
	part->ehead = head;
	part->esect = sect;
}

char *
PRT_uuid_to_typename(struct uuid *uuid)
{
	static char partition_type[37];	/* Room for a GUID if needed. */
	char *uuidstr = NULL;
	int i, entries, status;

	memset(partition_type, 0, sizeof(partition_type));

	uuid_to_string(uuid, &uuidstr, &status);
	if (status != uuid_s_ok)
		goto done;

	entries = sizeof(part_types) / sizeof(struct part_type);

	for (i = 0; i < entries; i++) {
		if (memcmp(part_types[i].guid, uuidstr,
		    sizeof(part_types[i].guid)) == 0)
			break;
	}

	if (i < entries)
		strlcpy(partition_type, part_types[i].sname,
		    sizeof(partition_type));
	else
		strlcpy(partition_type, uuidstr, sizeof(partition_type));

done:
	free(uuidstr);

	return (partition_type);
}

int
PRT_uuid_to_type(struct uuid *uuid)
{
	char *uuidstr;
	int entries, i, status, type;

	type = 0;

	uuid_to_string(uuid, &uuidstr, &status);
	if (status != uuid_s_ok)
		goto done;

	entries = sizeof(part_types) / sizeof(struct part_type);
	for (i = 0; i < entries; i++) {
		if (memcmp(part_types[i].guid, uuidstr,
		    sizeof(part_types[i].guid)) == 0) {
			type = part_types[i].type;
			break;
		}
	}

done:
	free(uuidstr);
	return (type);
}

struct uuid *
PRT_type_to_uuid(int type)
{
	static struct uuid guid;
	int i, entries, status = uuid_s_ok;

	memset(&guid, 0, sizeof(guid));

	entries = sizeof(part_types) / sizeof(struct part_type);

	for (i = 0; i < entries; i++) {
		if (part_types[i].type == type)
			break;
	}
	if (i < entries)
		uuid_from_string(part_types[i].guid, &guid, &status);
	if (i == entries || status != uuid_s_ok)
		uuid_from_string(part_types[0].guid, &guid, &status);

	return (&guid);
}
@


1.76
log
@The "disk too large" and "only LBA values saved" messages are more
often confusing than useful these days. Stop emitting them.

Prompted by bugs@@ report of the 8TB disk travails of Jiri.

ok deraadt@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.75 2015/11/26 08:15:07 tim Exp $	*/
d40 1
a40 1
	{ 0x01, "DOS FAT-12  ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
d43 1
a43 1
	{ 0x04, "DOS FAT-16  ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
d45 1
a45 1
	{ 0x06, "DOS > 32MB  ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
d50 3
a52 3
	{ 0x0B, "Win95 FAT-32", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x0C, "Win95 FAT32L", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
	{ 0x0E, "DOS FAT-16  ", "ebd0a0a2-b9e5-4433-87c0-68b6b72699c7" },
@


1.75
log
@When prompting for a GPT partition type, use the partition's current type as
default; OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.74 2015/11/19 16:14:08 krw Exp $	*/
a254 1
		/* should this really keep flag, id and set others to 0xff? */
a255 2
		printf("Warning CHS values out of bounds only saving "
		    "LBA values\n");
@


1.74
log
@Reduce overburden of unnecessary #include's. Note that param.h is
included only for DEV_BSIZE.  Use INT64_MAX instead of LLONG_MAX
so stdint.h is enough.  General tidying up of #include sections.

ok GCC
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.73 2015/10/26 15:08:26 krw Exp $	*/
d379 1
a379 1
PRT_uuid_to_type(struct uuid *uuid)
d409 26
@


1.73
log
@Add GPT editing. Based on GSOC 2014 work by Markus Muller.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.72 2015/03/27 16:06:00 krw Exp $	*/
d21 1
@


1.72
log
@Wrap some annoying long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.71 2015/03/27 15:56:45 krw Exp $	*/
d23 1
d25 1
d36 1
d38 2
a39 2
	{ 0x00, "unused      "},   /* unused */
	{ 0x01, "DOS FAT-12  "},   /* Primary DOS with 12 bit FAT */
d42 1
a42 1
	{ 0x04, "DOS FAT-16  "},   /* Primary DOS with 16 bit FAT */
d44 2
a45 2
	{ 0x06, "DOS > 32MB  "},   /* Primary 'big' DOS (> 32MB) */
	{ 0x07, "NTFS        "},   /* NTFS */
d49 3
a51 3
	{ 0x0B, "Win95 FAT-32"},   /* Primary Win95 w/ 32-bit FAT */
	{ 0x0C, "Win95 FAT32L"},   /* Primary Win95 w/ 32-bit FAT LBA-mapped */
	{ 0x0E, "DOS FAT-16  "},   /* Primary DOS w/ 16-bit FAT, CHS-mapped */
d54 1
a54 1
	{ 0x11, "OS/2 hidden "},   /* OS/2 BM: hidden DOS 12-bit FAT */
d56 3
a58 3
	{ 0x14, "OS/2 hidden "},   /* OS/2 BM: hidden DOS 16-bit FAT <32M or Novell DOS 7.0 bug */
	{ 0x16, "OS/2 hidden "},   /* OS/2 BM: hidden DOS 16-bit FAT >=32M */
	{ 0x17, "OS/2 hidden "},   /* OS/2 BM: hidden IFS */
d61 3
a63 1
	{ 0x1C, "ThinkPad Rec"},   /* IBM ThinkPad recovery partition */
a64 2
	{ 0x24, "NEC DOS     "},   /* NEC DOS */
	{ 0x27, "Win Recovery"},   /* Windows hidden Recovery Partition */
d69 1
a69 1
	{ 0x42, "LinuxSwap DR"},   /* SFS or Linux swap (sharing disk with DRDOS) */
d92 1
d95 2
a96 2
	{ 0x82, "Linux swap  "},   /* Linux swap */
	{ 0x83, "Linux files*"},   /* Linux filesystem */
d101 1
a101 1
	{ 0x8E, "Linux LVM   "},   /* Linux LVM */
d107 2
a108 2
	{ 0xA5, "FreeBSD     "},   /* FreeBSD */
	{ 0xA6, "OpenBSD     "},   /* OpenBSD */
d110 4
a113 4
	{ 0xA8, "MacOS X     "},   /* MacOS X main partition */
	{ 0xA9, "NetBSD      "},   /* NetBSD */
	{ 0xAB, "MacOS X boot"},   /* MacOS X boot partition */
	{ 0xAF, "MacOS X HFS+"},   /* MacOS X HFS+ partition */
d116 1
a116 1
	{ 0xBF, "Solaris     "},   /* Solaris */
d127 1
a127 1
	{ 0xEB, "BeOS/i386   "},   /* BeOS for Intel */
d129 1
a129 1
	{ 0xEF, "EFI Sys     "},   /* EFI System Partition */
d275 1
d289 1
a289 2
		size = ((double)partn->ns * unit_types[SECTORS].conversion) /
		    unit_types[i].conversion;
d375 55
@


1.71
log
@Use DOSACTIVE define instead of magic number 0x80.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.70 2015/03/26 14:08:12 krw Exp $	*/
d252 2
a253 1
		printf("Warning CHS values out of bounds only saving LBA values\n");
d277 6
a282 3
		printf("            Starting         Ending         LBA Info:\n");
		printf(" #: id      C   H   S -      C   H   S [       start:        size ]\n");
		printf("-------------------------------------------------------------------------------\n");
d286 2
a287 1
		printf("%c%1d: %.2X %6u %3u %3u - %6u %3u %3u [%12llu:%12.0f%s] %s\n",
@


1.70
log
@Expand internal representation of partition starting LBA and size
to 64 bits, adjusting printf()'s, etc. as required. Preparing for
GPT partitions. Add 't' size unit. No other intentional functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.69 2015/03/16 23:51:50 krw Exp $	*/
d283 1
a283 1
		    (partn->flag == 0x80)?'*':' ',
@


1.69
log
@Stop passing around a pointer to the stack variable 'disk' in main().
There is only one disk being worked on, so just make it a global.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.68 2015/03/14 18:32:29 krw Exp $	*/
d225 1
a225 1
	u_int32_t t;
d258 1
a258 5
#if 0 /* XXX */
	prt->dp_start = htole32(partn->bs - off);
	prt->dp_size = htole32(partn->ns);
#else
	t = htole32(partn->bs - off);
d260 1
a260 1
	t = htole32(partn->ns);
a261 1
#endif
d282 1
a282 1
		printf("%c%1d: %.2X %6u %3u %3u - %6u %3u %3u [%12u:%12.0f%s] %s\n",
@


1.68
log
@Whitespace & KNF tweaks. Change functions whose return values are
not checked to void. Use continue inside a do loop instead of a
goto to the top. Move a #define/#undef more local to use. Eliminate
some lint.

General cleanup of things noticed preparing the big churn.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.67 2015/03/14 15:21:53 krw Exp $	*/
d169 2
a170 2
PRT_parse(struct disk *disk, struct dos_partition *prt, off_t offset,
    off_t reloff, struct prt *partn)
d201 1
a201 1
	PRT_fix_CHS(disk, partn);
d299 1
a299 1
PRT_fix_BN(struct disk *disk, struct prt *part, int pn)
d312 2
a313 2
	spt = disk->sectors;
	tpc = disk->heads;
d333 1
a333 1
PRT_fix_CHS(struct disk *disk, struct prt *part)
d346 2
a347 2
	spt = disk->sectors;
	tpc = disk->heads;
@


1.67
log
@Switch all the license blocks to the standard OpenBSD/ISC license.

With the permission of Toby.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.66 2014/05/05 17:18:08 miod Exp $	*/
d214 1
a214 1
		return 0;
d216 1
a216 1
	return 1;
d277 1
@


1.66
log
@Ugly workaround for an overoptimistic alignment expectation of dos_partition
fields, found the hard way on landisk, to allow the tree to build until a
proper fix is devised.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.65 2014/03/31 22:03:29 krw Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.65
log
@Whitespace rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.64 2014/03/31 19:50:52 krw Exp $	*/
d182 1
d200 1
d203 6
d234 1
d267 1
d270 6
@


1.64
log
@Nuke [get|put][short|long] and just use letoh[16|32] and
htole[16|32]. This is made possible by a) copying unaligned data
(struct dos_partition's) into properly aligned structs and accessing
the fields of the same; and b) realizing that gcc is smart enough to
access fields in packed struct's *if* it knows it is accessing a
packed struct. Even sparc64 finally gave a thumbs up.

After several attempts and feedback from deraadt@@ and dlg@@, it looks
good to deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.63 2014/03/25 12:59:03 krw Exp $	*/
d219 1
a363 1

@


1.63
log
@Use 'struct dos_partition' variable to access 'struct dos_partition'
data. Since all the fields but 2 that are specially handled are
u_int8_t's there should be no danger from alignment issues.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.62 2014/03/22 15:40:04 krw Exp $	*/
d199 2
a200 2
	partn->bs = getlong(&prt->dp_start) + off;
	partn->ns = getlong(&prt->dp_size);
d257 2
a258 2
	putlong(&prt->dp_start, partn->bs - off);
	putlong(&prt->dp_size, partn->ns);
@


1.62
log
@warn() -> warnx() when errno is irrelevant.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.61 2014/03/20 13:43:32 krw Exp $	*/
d178 2
a179 2
PRT_parse(struct disk *disk, void *prt, off_t offset, off_t reloff,
    struct prt *partn)
a180 1
	unsigned char *p = prt;
d183 2
a184 2
	partn->flag = *p++;
	partn->shead = *p++;
d186 7
a192 9
	partn->ssect = (*p) & 0x3F;
	partn->scyl = ((*p << 2) & 0xFF00) | (*(p+1));
	p += 2;

	partn->id = *p++;
	partn->ehead = *p++;
	partn->esect = (*p) & 0x3F;
	partn->ecyl = ((*p << 2) & 0xFF00) | (*(p+1));
	p += 2;
d199 2
a200 2
	partn->bs = getlong(p) + off;
	partn->ns = getlong(p+4);
d220 2
a221 1
PRT_make(struct prt *partn, off_t offset, off_t reloff, void *prt)
a222 1
	unsigned char *p = prt;
d240 8
a247 11
		*p++ = partn->flag & 0xFF;

		*p++ = partn->shead & 0xFF;
		*p++ = (partn->ssect & 0x3F) | ((partn->scyl & 0x300) >> 2);
		*p++ = partn->scyl & 0xFF;

		*p++ = partn->id & 0xFF;

		*p++ = partn->ehead & 0xFF;
		*p++ = (partn->esect & 0x3F) | ((partn->ecyl & 0x300) >> 2);
		*p++ = partn->ecyl & 0xFF;
d250 1
a250 8
		*p++ = partn->flag & 0xFF;
		*p++ = 0xFF;
		*p++ = 0xFF;
		*p++ = 0xFF;
		*p++ = partn->id & 0xFF;
		*p++ = 0xFF;
		*p++ = 0xFF;
		*p++ = 0xFF;
d254 5
a258 2
	putlong(p, partn->bs - off);
	putlong(p+4, partn->ns);
@


1.61
log
@Simplify a bit of code to make sure even -Wall can see the variables
are not used uninitialized. As a bonus, make variables the same
type as the data they are trying to preserve.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.60 2014/03/20 13:18:21 krw Exp $	*/
d327 1
a327 1
		warn("Start of partition #%d after end!", pn);
@


1.60
log
@Add back various #includes of err.h, unistd.h, ctype.h, ioctl.h to
eliminate multiple 'implicit' declarations introduced by the previous
over-zealous #include cleanup.

Thanks to to tedu@@ for pointing out how -Wall reveals all.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.59 2014/03/17 16:40:00 krw Exp $	*/
a225 2
	int ecsave, scsave;
	int modified = 0;
d227 5
a233 2
		scsave = partn->scyl;
		ecsave = partn->ecyl;
a235 1
		modified = 1;
d269 3
a271 4
	if (modified) {
		partn->scyl = scsave;
		partn->ecyl = ecsave;
	}
@


1.59
log
@Nuke pointless blank lines, defines, comments and casts. Eliminate
#include in *.h files in favour of listing them as required in the *.c
files. Fix error message to correctly state that 64 is the minimum
value for -l. Use errx() where errno is not relevant. Use 'continue'
rather than a label to go back to start of a loop.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.58 2014/03/17 13:15:44 krw Exp $	*/
d30 1
@


1.58
log
@Un-revert, being careful to not break snap building. Add paranoia check
for any missing geometry.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.57 2014/03/14 15:41:33 krw Exp $	*/
d33 1
d35 1
a35 1
#include "mbr.h"
@


1.57
log
@Revert last -- broke building snaps.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.56 2014/03/13 12:02:28 krw Exp $	*/
d311 3
a313 3
	/* Disk metrics */
	spt = disk->real->sectors;
	tpc = disk->real->heads;
d345 3
a347 3
	/* Disk metrics */
	spt = disk->real->sectors;
	tpc = disk->real->heads;
@


1.56
log
@Merge 'struct DISK_metrics' and 'struct disk' into one, since we don't
need to record two sets of metric/geometry data. Use 'geometry'
instead of 'metrics' in names and comments. Eliminate
DISK_getmetrics().

While here, make 64 the minimal valid value for '-l' instead of 1. This
avoids the possibility of having 0 cylinders.

No intentional functional change.

Feedback & tweak from chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.55 2014/03/09 22:25:06 krw Exp $	*/
d311 3
a313 3
	/* Disk geometry. */
	spt = disk->sectors;
	tpc = disk->heads;
d345 3
a347 3
	/* Disk geometry. */
	spt = disk->sectors;
	tpc = disk->heads;
@


1.55
log
@Instead of passing around 'char buf[DEV_BSIZE]' buffers, pass around
'struct dos_mbr' variables, since that is what the buffers were used
for. Removes need to know about DEV_BSIZE and thus include param.h
from all files but one so move the param.h #include to that file
(mbr.c).

Nuke a bunch of local MBR #defines in favour of the disklabel.h ones.

Remove a bunch of unneeded #includes, replace the odd malloc/bzero
with calloc, replace equally odd bcopy's with memcpy, remove a stray
duplicate MBR parsing in MBR_pcopy().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.54 2014/03/07 21:56:13 krw Exp $	*/
d311 3
a313 3
	/* Disk metrics */
	spt = disk->real->sectors;
	tpc = disk->real->heads;
d345 3
a347 3
	/* Disk metrics */
	spt = disk->real->sectors;
	tpc = disk->real->heads;
@


1.54
log
@Relieve the code of an overburden of unnecessary typedef
abstraction. Call a 'struct' a 'struct' and not a pony.

No functional change.

idea ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.53 2013/03/21 18:45:58 deraadt Exp $	*/
a28 2
#include <sys/fcntl.h>
#include <sys/stat.h>
a29 2
#include <err.h>
#include <util.h>
d32 1
a32 2
#include <unistd.h>
#include "disk.h"
@


1.53
log
@more substantial include cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.52 2012/07/25 19:49:11 otto Exp $	*/
d41 1
a41 1
int	PRT_check_chs(prt_t *partn);
d181 2
a182 2
PRT_parse(disk_t *disk, void *prt, off_t offset, off_t reloff,
    prt_t *partn)
d212 1
a212 1
PRT_check_chs(prt_t *partn)
d226 1
a226 1
PRT_make(prt_t *partn, off_t offset, off_t reloff, void *prt)
d279 1
a279 1
PRT_print(int num, prt_t *partn, char *units)
d304 1
a304 1
PRT_fix_BN(disk_t *disk, prt_t *part, int pn)
d338 1
a338 1
PRT_fix_CHS(disk_t *disk, prt_t *part)
@


1.52
log
@do not check ns here, we're supposed to compute it; ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.51 2012/07/11 10:27:34 krw Exp $	*/
d28 4
a36 5
#include <sys/fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <machine/param.h>
@


1.51
log
@Simplify guts and calling of getuint(). Eliminate a useless 'help'
capablity by using help text as regular prompt for 'size' and
'offset'. Try to detect and handle more overflow/underflow conditions
in getuint() and ensure returned value is always within requested
bounds. Handle zero-length partitions by treating them as UNUSED.

tested & ok halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.50 2009/04/29 22:58:24 deraadt Exp $	*/
d312 1
a312 1
	if (part->id == DOSPTYP_UNUSED || part->ns == 0) {
@


1.50
log
@code that stank and made me upset
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.49 2009/04/01 15:00:55 jsg Exp $	*/
d312 1
a312 1
	if (part->id == DOSPTYP_UNUSED ) {
d346 1
a346 1
	if (part->id == DOSPTYP_UNUSED ) {
@


1.49
log
@Remove duplicate entry for partition id 0x07 so NTFS partitions
will show as NTFS in fdisk output.
ok todd@@ otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.48 2009/03/24 15:10:03 todd Exp $	*/
d294 7
a300 7
			(partn->flag == 0x80)?'*':' ',
			num, partn->id,
			partn->scyl, partn->shead, partn->ssect,
			partn->ecyl, partn->ehead, partn->esect,
			partn->bs, size,
			unit_types[i].abbr,
			PRT_ascii_id(partn->id));
@


1.48
log
@two more MBR partition names
ok otto@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.47 2008/05/31 09:45:01 fgsch Exp $	*/
a55 1
	{ 0x07, "HPFS/QNX/AUX"},   /* OS/2 HPFS, QNX-2 or Advanced UNIX */
@


1.47
log
@add hfs+ type. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.46 2008/02/18 21:33:05 sobrado Exp $	*/
d55 1
d75 1
@


1.46
log
@adjust width of S column to improve printing of the MBR partition table
on modern disk geometries; while here, better alignment of column labels

ok jmc@@, jsing@@, krw@@, and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.45 2007/07/04 16:34:15 deraadt Exp $	*/
d121 1
@


1.45
log
@another mbr partition type; fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.44 2007/06/10 11:38:27 sobrado Exp $	*/
d285 3
a287 3
		printf("          Starting         Ending        LBA Info:\n");
		printf(" #: id      C   H  S -      C   H  S [       start:        size ]\n");
		printf("------------------------------------------------------------------------\n");
d291 1
a291 1
		printf("%c%1d: %.2X %6u %3u %2u - %6u %3u %2u [%12u:%12.0f%s] %s\n",
@


1.44
log
@adjust the width of columns to match the geometry of current drives

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.43 2007/04/04 14:36:05 jmc Exp $	*/
d109 1
@


1.43
log
@Thinkpad -> ThinkPad; from Igor Sobrado
ok millert jasper mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.42 2006/06/09 17:01:47 deraadt Exp $	*/
d284 2
a285 2
		printf("         Starting       Ending       LBA Info:\n");
		printf(" #: id    C   H  S -    C   H  S [       start:      size   ]\n");
d290 1
a290 1
		printf("%c%1d: %.2X %4u %3u %2u - %4u %3u %2u [%12u:%12.0f%s] %s\n",
@


1.42
log
@EFI partition types; didickman@@yahoo.com
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.41 2005/11/21 01:59:24 krw Exp $	*/
d71 1
a71 1
	{ 0x1C, "Thinkpad Rec"},   /* IBM Thinkpad recovery partition */
@


1.41
log
@Replace default DEV_BSIZE sector conversion factor with disklabel's
sector size when possible. Fixes the "[ XX Sectors ]" size display.
Pointed out by Robert Szasz while playing with his Sony Hi-MD device.

Apply input conversion fixes similar to those recently applied to
disklabel(8). Use correct sector size in the conversions.

It is still *not* possible to use unusual sector sizes for non-ISO9660
filesystems!

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.40 2004/11/10 17:29:41 deraadt Exp $	*/
d134 2
@


1.40
log
@0xBF is new Solaris ID; lclee@@west.sun.com
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.39 2004/08/03 09:22:03 otto Exp $	*/
d286 1
a286 1
		size = (double)partn->ns * DEV_BSIZE /
@


1.39
log
@Handle geometry parameters as unsigned quantities, getting rid of negative
number of sectors on large disks and other similar problems.

ok toby@@ tom@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.38 2004/07/13 06:00:33 tom Exp $	*/
d122 1
@


1.38
log
@Remove unused argument 'int pn' to PRT_fix_CHS().  The 'int pn'
argument to PRT_parse() then becomes unused, so remove that too.

ok henning@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.37 2004/07/10 08:43:36 tom Exp $	*/
d287 1
a287 1
		printf("%c%1d: %.2X %4d %3d %2d - %4d %3d %2d [%12d:%12.0f%s] %s\n",
d301 3
a303 3
	int spt, tpc, spc;
	int start = 0;
	int end = 0;
d335 3
a337 3
	int spt, tpc, spc;
	int start, end, size;
	int cyl, head, sect;
@


1.37
log
@The long descriptions of partition types are not used by the code, so
have them as comments rather than data.  Reduces the size of the
executable by over 2 KB.

Also s/Netware/NetWare/.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.36 2003/07/29 18:38:35 deraadt Exp $	*/
d177 1
a177 1
    prt_t *partn, int pn)
d203 1
a203 1
	PRT_fix_CHS(disk, partn, pn);
d333 1
a333 1
PRT_fix_CHS(disk_t *disk, prt_t *part, int pn)
@


1.36
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.35 2003/07/02 21:44:57 deraadt Exp $	*/
a46 1
	char	*lname;
d48 89
a136 89
	{ 0x00, "unused      ", "unused"},
	{ 0x01, "DOS FAT-12  ", "Primary DOS with 12 bit FAT"},
	{ 0x02, "XENIX /     ", "XENIX / filesystem"},
	{ 0x03, "XENIX /usr  ", "XENIX /usr filesystem"},
	{ 0x04, "DOS FAT-16  ", "Primary DOS with 16 bit FAT"},
	{ 0x05, "Extended DOS", "Extended DOS"},
	{ 0x06, "DOS > 32MB  ", "Primary 'big' DOS (> 32MB)"},
	{ 0x07, "HPFS/QNX/AUX", "OS/2 HPFS, QNX-2 or Advanced UNIX"},
	{ 0x08, "AIX fs      ", "AIX filesystem"},
	{ 0x09, "AIX/Coherent", "AIX boot partition or Coherent"},
	{ 0x0A, "OS/2 Bootmgr", "OS/2 Boot Manager or OPUS"},
	{ 0x0B, "Win95 FAT-32", "Primary Win95 w/ 32-bit FAT"},
	{ 0x0C, "Win95 FAT32L", "Primary Win95 w/ 32-bit FAT LBA-mapped"},
	{ 0x0E, "DOS FAT-16  ", "Primary DOS w/ 16-bit FAT, CHS-mapped"},
	{ 0x0F, "Extended LBA", "Extended DOS LBA-mapped"},
	{ 0x10, "OPUS        ", "OPUS"},
	{ 0x11, "OS/2 hidden ", "OS/2 BM: hidden DOS 12-bit FAT"},
	{ 0x12, "Compaq Diag.", "Compaq Diagnostics"},
	{ 0x14, "OS/2 hidden ", "OS/2 BM: hidden DOS 16-bit FAT <32M or Novell DOS 7.0 bug"},
	{ 0x16, "OS/2 hidden ", "OS/2 BM: hidden DOS 16-bit FAT >=32M"},
	{ 0x17, "OS/2 hidden ", "OS/2 BM: hidden IFS"},
	{ 0x18, "AST swap    ", "AST Windows swapfile"},
	{ 0x19, "Willowtech  ", "Willowtech Photon coS"},
	{ 0x1C, "Thinkpad Rec", "IBM Thinkpad recovery partition"},
	{ 0x20, "Willowsoft  ", "Willowsoft OFS1"},
	{ 0x24, "NEC DOS     ", "NEC DOS"},
	{ 0x38, "Theos       ", "Theos"},
	{ 0x39, "Plan 9      ",	"Plan 9"},
	{ 0x40, "VENIX 286   ", "VENIX 286 or LynxOS"},
	{ 0x41, "Lin/Minux DR", "Linux/MINIX (sharing disk with DRDOS) or Personal RISC boot"},
	{ 0x42, "LinuxSwap DR", "SFS or Linux swap (sharing disk with DRDOS)"},
	{ 0x43, "Linux DR    ", "Linux native (sharing disk with DRDOS)"},
	{ 0x4D, "QNX 4.2 Pri ", "QNX 4.2 Primary"},
	{ 0x4E, "QNX 4.2 Sec ", "QNX 4.2 Secondary"},
	{ 0x4F, "QNX 4.2 Ter ", "QNX 4.2 Tertiary"},
	{ 0x50, "DM          ", "DM (disk manager)"},
	{ 0x51, "DM          ", "DM6 Aux1 (or Novell)"},
	{ 0x52, "CP/M or SysV", "CP/M or Microport SysV/AT"},
	{ 0x53, "DM          ", "DM6 Aux3"},
	{ 0x54, "Ontrack     ", "Ontrack"},
	{ 0x55, "EZ-Drive    ", "EZ-Drive (disk manager)"},
	{ 0x56, "Golden Bow  ", "Golden Bow (disk manager)"},
	{ 0x5C, "Priam       ", "Priam Edisk (disk manager)"},
	{ 0x61, "SpeedStor   ", "SpeedStor"},
	{ 0x63, "ISC, HURD, *", "ISC, System V/386, GNU HURD or Mach"},
	{ 0x64, "Netware 2.xx", "Novell Netware 2.xx"},
	{ 0x65, "Netware 3.xx", "Novell Netware 3.xx"},
	{ 0x66, "Netware 386 ", "Novell 386 Netware"},
	{ 0x67, "Novell      ", "Novell"},
	{ 0x68, "Novell      ", "Novell"},
	{ 0x69, "Novell      ", "Novell"},
	{ 0x70, "DiskSecure  ", "DiskSecure Multi-Boot"},
	{ 0x75, "PCIX        ", "PCIX"},
	{ 0x80, "Minix (old) ", "Minix 1.1 ... 1.4a"},
	{ 0x81, "Minix (new) ", "Minix 1.4b ... 1.5.10"},
	{ 0x82, "Linux swap  ", "Linux swap"},
	{ 0x83, "Linux files*", "Linux filesystem"},
	{ 0x84, "OS/2 hidden ", "OS/2 hidden C: drive"},
	{ 0x85, "Linux ext.  ", "Linux extended"},
	{ 0x86, "NT FAT VS   ", "NT FAT volume set"},
	{ 0x87, "NTFS VS     ", "NTFS volume set or HPFS mirrored"},
	{ 0x93, "Amoeba FS   ", "Amoeba filesystem"},
	{ 0x94, "Amoeba BBT  ", "Amoeba bad block table"},
	{ 0x99, "Mylex       ", "Mylex EISA SCSI"},
	{ 0x9F, "BSDI        ", "BSDI BSD/OS"},
	{ 0xA0, "NotebookSave", "Phoenix NoteBIOS save-to-disk"},
	{ 0xA5, "FreeBSD     ",	"FreeBSD"},
	{ 0xA6, "OpenBSD     ", "OpenBSD"},
	{ 0xA7, "NEXTSTEP    ", "NEXTSTEP"},
	{ 0xA8, "MacOS X     ",	"MacOS X main partition"},
	{ 0xA9, "NetBSD      ",	"NetBSD"},
	{ 0xAB, "MacOS X boot",	"MacOS X boot partition"},
	{ 0xB7, "BSDI filesy*", "BSDI BSD/386 filesystem"},
	{ 0xB8, "BSDI swap   ", "BSDI BSD/386 swap"},
	{ 0xC0, "CTOS        ", "CTOS"},
	{ 0xC1, "DRDOSs FAT12", "DRDOS/sec (FAT-12)"},
	{ 0xC4, "DRDOSs < 32M", "DRDOS/sec (FAT-16, < 32M)"},
	{ 0xC6, "DRDOSs >=32M", "DRDOS/sec (FAT-16, >= 32M)"},
	{ 0xC7, "HPFS Disbled", "Syrinx (Cyrnix?) or HPFS disabled"},
	{ 0xDB, "CPM/C.DOS/C*", "Concurrent CPM or C.DOS or CTOS"},
	{ 0xDE, "Dell Maint  ", "Dell maintenance partition"},
	{ 0xE1, "SpeedStor   ", "DOS access or SpeedStor 12-bit FAT extended partition"},
	{ 0xE3, "SpeedStor   ", "DOS R/O or SpeedStor or Storage Dimensions"},
	{ 0xE4, "SpeedStor   ", "SpeedStor 16-bit FAT extended partition < 1024 cyl."},
	{ 0xEB, "BeOS/i386   ", "BeOS for Intel"},
	{ 0xF1, "SpeedStor   ", "SpeedStor or Storage Dimensions"},
	{ 0xF2, "DOS 3.3+ Sec", "DOS 3.3+ Secondary"},
	{ 0xF4, "SpeedStor   ", "SpeedStor >1024 cyl. or LANstep or IBM PS/2 IML"},
	{ 0xFF, "Xenix BBT   ", "Xenix Bad Block Table"},
@


1.35
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.34 2003/06/11 06:22:12 deraadt Exp $	*/
d145 1
a145 1
        idrows = ((sizeof(part_types)/sizeof(struct part_type))+3)/4;
d149 10
a158 11
		printf("%02X %s   %02X %s   %02X %s"
                      , part_types[i         ].type, part_types[i         ].sname
                      , part_types[i+idrows  ].type, part_types[i+idrows  ].sname
                      , part_types[i+idrows*2].type, part_types[i+idrows*2].sname
                      );
                if ((i+idrows*3) < (sizeof(part_types)/sizeof(struct part_type))) {
		       printf("   %02X %s\n"
                             , part_types[i+idrows*3].type, part_types[i+idrows*3].sname );
                }
		else
		        printf( "\n" );
d291 1
a291 1
		        partn->scyl, partn->shead, partn->ssect,
d294 1
a294 1
		        unit_types[i].abbr,
@


1.34
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.33 2003/06/03 01:13:19 weingart Exp $	*/
d42 1
@


1.33
log
@Nuke terms 3 & 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.32 2003/04/19 18:42:14 avsm Exp $	*/
d140 1
a140 1
PRT_printall()
d163 1
a163 2
PRT_ascii_id(id)
	int id;
d177 2
a178 7
PRT_parse(disk, prt, offset, reloff, partn, pn)
	disk_t *disk;
	void *prt;
	off_t offset;
	off_t reloff;
	prt_t *partn;
	int pn;
d208 1
a208 2
PRT_check_chs(partn)
	prt_t *partn;
d222 1
a222 5
PRT_make(partn, offset, reloff, prt)
	prt_t *partn;
	off_t offset;
	off_t reloff;
	void *prt;
d275 1
a275 4
PRT_print(num, partn, units)
	int num;
	prt_t *partn;
	char *units;
d300 1
a300 4
PRT_fix_BN(disk, part, pn)
	disk_t *disk;
	prt_t *part;
	int pn;
d334 1
a334 4
PRT_fix_CHS(disk, part, pn)
	disk_t *disk;
	prt_t *part;
	int pn;
@


1.32
log
@change "%12.f" -> "%12.0f" to avoid a -Wformat warning
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.31 2003/03/13 22:41:03 miod Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.31
log
@Remove duplicate Amoeba entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.30 2002/06/09 08:13:05 todd Exp $	*/
d307 1
a307 1
		printf("%c%1d: %.2X %4d %3d %2d - %4d %3d %2d [%12d:%12.f%s] %s\n",
@


1.30
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.29 2002/02/12 17:56:35 kjell Exp $	*/
a109 2
	{ 0x93, "Amoeba file*", "Amoeba filesystem"},
	{ 0x94, "Amoeba BBT  ", "Amoeba bad block table"},
@


1.29
log
@Add Dell, Thinkpad maintenance partition types.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.28 2002/01/18 08:38:26 kjell Exp $	*/
d224 5
a228 5
	if ( (partn->shead > 255) || 
		(partn->ssect >63) || 
		(partn->scyl > 1023) || 
		(partn->ehead >255) || 
		(partn->esect >63) || 
d250 2
a251 2
		partn->scyl = (partn->scyl > 1023)? 1023: partn->scyl; 
		partn->ecyl = (partn->ecyl > 1023)? 1023: partn->ecyl; 
d307 1
a307 1
		size = (double)partn->ns * DEV_BSIZE / 
@


1.28
log
@Allow size values to be displayed in the user's choice of units.
Idea borrowed from disklabel. i.e. Users can now type "print M"
and be rewarded with partition sizes in Megs
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.27 2002/01/18 08:29:01 kjell Exp $	*/
d76 1
d135 1
@


1.27
log
@Do not truncate the cylinder value to 1023 until the MBR
is actually written to disk. Cylinder values for disks >8G
are instead "faked" from the LBA values in the partition table.
These faked values are now displayed correctly after a save.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.26 2001/11/14 16:42:27 mickey Exp $	*/
d291 1
a291 1
PRT_print(num, partn)
d294 1
d296 3
d301 2
a302 2
		printf("         Starting       Ending\n");
		printf(" #: id  cyl  hd sec -  cyl  hd sec [     start -       size]\n");
d305 3
a307 1
		printf("%c%1d: %.2X %4d %3d %3d - %4d %3d %3d [%10d - %10d] %s\n",
d310 1
a310 1
			partn->scyl, partn->shead, partn->ssect,
d312 2
a313 1
			partn->bs, partn->ns,
@


1.26
log
@fix a typo, from Daniel Lucq <daniel@@lucq.org>, tested on:
> (0) a SCSI disk with a working OpenBSD install
> (1) a SCSI disk with cleared first sector (dd if=/dev/zero)
> (2) an IDE disk with a working OpenBSD install
> (3) an IDE disk with cleared first sector
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.25 2001/11/07 01:27:33 miod Exp $	*/
d241 2
a242 1
	prt_t tmp;
d245 6
a250 14
	tmp.shead = partn->shead;
	tmp.ssect = partn->ssect;
	tmp.scyl = (partn->scyl > 1023)? 1023: partn->scyl; 
	tmp.ehead = partn->ehead;
	tmp.esect = partn->esect;
	tmp.ecyl = (partn->ecyl > 1023)? 1023: partn->ecyl; 
	if (!PRT_check_chs(partn) && PRT_check_chs(&tmp)) {
		partn->shead = tmp.shead;
		partn->ssect = tmp.ssect;
		partn->scyl = tmp.scyl;
		partn->ehead = tmp.ehead;
		partn->esect = tmp.esect;
		partn->ecyl = tmp.ecyl;
		printf("Cylinder values are modified to fit in CHS.\n");
d284 4
a377 4
	if (cyl > 1023) {
		cyl = 1023;
		printf("Only LBA values are valid in starting cylinder for partition #%d.\n", pn);
	}
a386 4
	if (cyl > 1023) {
		cyl = 1023;
		printf("Only LBA values are valid in ending cylinder for partition #%d.\n", pn);
	}
@


1.25
log
@Add MacOS X for Intel (or Darwin for Intel, or whatever the correct
name is) partition ID.
ok millert@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.24 2001/07/02 13:51:18 millert Exp $	*/
d248 1
a248 1
	tmp.esect = partn->ssect;
@


1.24
log
@#include <string.h> to get mem* prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.23 2001/06/23 04:27:30 kjell Exp $	*/
d123 1
d125 1
@


1.23
log
@Add more partition types - ref. NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.22 2001/06/23 01:54:38 kjell Exp $	*/
d36 1
@


1.22
log
@Changes from Toby. Make error tests explicit (against -1), remove one big
hurdle to partitions over 8G. Include the default MBR in a header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.21 2001/05/18 20:22:02 mickey Exp $	*/
d68 1
d70 8
d79 9
a87 6
	{ 0x40, "VENIX 286   ", "VENIX 286"},
	{ 0x4d, "QNX 4.2 Pri ", "QNX 4.2 Primary"},
	{ 0x4e, "QNX 4.2 Sec ", "QNX 4.2 Secondary"},
	{ 0x4f, "QNX 4.2 Ter ", "QNX 4.2 Tertiary"},
	{ 0x50, "DM          ", "DM"},
	{ 0x51, "DM          ", "DM"},
d89 1
d91 4
a94 2
	{ 0x56, "GB          ", "GB"},
	{ 0x61, "Speed       ", "Speed"},
d98 5
d110 8
a117 1
	{ 0x9f, "BSDI        ", "BSDI BSD/OS"},
d125 5
d131 3
a133 3
	{ 0xE1, "Speed       ", "Speed"},
	{ 0xE3, "Speed       ", "Speed"},
	{ 0xE4, "Speed       ", "Speed"},
d135 1
a135 1
	{ 0xF1, "Speed       ", "Speed"},
d137 2
a138 2
	{ 0xF4, "Speed       ", "Speed"},
	{ 0xFF, "BBT         ", "BBT (Bad Blocks Table)"},
@


1.21
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.20 2001/05/18 07:15:18 mickey Exp $	*/
d211 1
a211 1
	tmp.scyl = (partn->scyl > 1024)? 1023: partn->scyl; 
d214 1
a214 1
	tmp.ecyl = (partn->ecyl > 1024)? 1023: partn->ecyl; 
d289 6
d325 6
@


1.20
log
@a few harmless cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.19 2001/03/16 19:02:14 markus Exp $	*/
a49 1
	char	osname[8];
@


1.19
log
@0x9f == BSDI, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.18 2000/07/01 21:49:12 mickey Exp $	*/
d47 1
a47 1
static struct part_type {
d49 2
a50 1
	char	*sname;
d133 1
a133 1
char *
d266 3
a268 3
		printf("         Starting        Ending\n");
		printf(" #: id  cyl  hd sec -   cyl  hd sec [     start -       size]\n");
		printf("-------------------------------------------------------------------------\n");
d270 1
a270 1
		printf("%c%1d: %.2X %4d %3d %3d - %5d %3d %3d [%10d - %10d] %s\n",
@


1.18
log
@be more verbose when warning for partition errors,
print partition number in the message.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.17 2000/06/11 16:11:55 markus Exp $	*/
d90 1
@


1.17
log
@0x39 == plan9
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.16 2000/06/10 15:56:42 deraadt Exp $	*/
d147 1
a147 1
PRT_parse(disk, prt, offset, reloff, partn)
d153 1
d179 1
a179 1
	PRT_fix_CHS(disk, partn);
d279 1
a279 1
PRT_fix_BN(disk, part)
d282 1
d303 1
a303 1
		warn("Start of partition after end!");
d310 1
a310 1
PRT_fix_CHS(disk, part)
d313 1
d335 1
a335 1
		printf("Only LBA values are valid in starting cylinder.\n");
d348 1
a348 1
		printf("Only LBA values are valid in ending cylinder.\n");
@


1.16
log
@know QNX; jcplace@@ibm.ne
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.15 2000/03/29 01:53:01 krw Exp $	*/
d69 1
@


1.15
log
@sort partition type list vertically rather than across. ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.14 2000/01/08 04:51:16 deraadt Exp $	*/
d59 1
a59 1
	{ 0x07, "HPFS/QNX/AUX", "OS/2 HPFS, QNX or Advanced UNIX"},
d70 3
@


1.14
log
@support LBA-mapped extended partitions too; sigh@@kuzirabekon.econ.nagasaki-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.13 1999/11/23 01:56:39 ian Exp $	*/
d107 3
a109 1
	int i;
d112 12
a123 3
	for (i = 0; i < sizeof(part_types)/sizeof(struct part_type); i++) {
		printf("%02X %s%s", part_types[i].type,
		    part_types[i].sname, (i+1) % 4 ? "   " : "\n");
a124 2
	if (i % 4)
		printf("\n");
@


1.13
log
@Add Phoenix BIOS notebook save-to-disk partition type (ok theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.12 1999/07/22 22:05:55 deraadt Exp $	*/
d64 1
d66 1
a142 1
	int need_fix_chs = 0;
a143 11
	/* dont check fields 0 and 4, they are flag and id, always preserved */
	if ((p[1] == 0xff) && 
	    (p[2] == 0xff) && 
	    (p[3] == 0xff) && 
	    (p[5] == 0xff) && 
	    (p[6] == 0xff) && 
	    (p[7] == 0xff))
	{
		/* CHS values invalid */
		need_fix_chs =1;
	}
d157 4
a160 1
	off = partn->id != DOSPTYP_EXTEND ? offset : reloff;
d165 1
a165 4
	if (need_fix_chs == 1) {
		printf("warning MBR CHS values invalid, translating LBA values\n");
		PRT_fix_CHS(disk, partn);
	}
d191 22
a212 1
	off_t off = partn->id != DOSPTYP_EXTEND ? offset : reloff; 
d317 4
d330 4
@


1.12
log
@align collumns
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.11 1999/02/09 19:06:36 deraadt Exp $	*/
d84 1
@


1.11
log
@BeOS/i386; ura@@yamato.ibm.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.10 1998/09/18 02:36:56 deraadt Exp $	*/
d239 1
a239 1
		printf(" #: id  cyl  hd sec -  cyl  hd sec [     start -       size]\n");
d242 1
a242 1
		printf("%c%1d: %.2X %4d %3d %3d - %4d %3d %3d [%10d - %10d] %s\n",
@


1.10
log
@fix table
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.9 1998/09/14 03:54:35 rahnds Exp $	*/
d94 1
@


1.9
log
@Since on the powerpc, the system does not supply the user with
bios valid cyl,head,sector information (the information comes from the
sd driver) I have made some changes to fdisk to do the following.

Allow the powerpc to specify values larger than the bios limits.

All platforms now have code that will translate the LBA values
in the mbr into CHS values according to the disk geometry.
This occurs if the start and ending CHS values have been stored as
0xffffff.

If writing to the disk and one of the values of a partition violates
the bios limits, it writes the requested values in the LBA fields ,
and stores 0xffffff for the starting and ending CHS values.

This should not change the default formatting of any existing system
other than the CHS and LBA values should always match given the detected
geometry of the disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.8 1998/02/19 20:48:08 deraadt Exp $	*/
d84 1
a84 1
	{ 0xA5, "FreeBSD",	"FreeBSD"},
d87 1
a87 1
	{ 0xA9, "NetBSD",	"NetBSD"},
@


1.8
log
@new netbsd partition type
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.7 1997/10/21 22:49:34 provos Exp $	*/
d130 2
a131 1
PRT_parse(prt, offset, reloff, partn)
d139 1
d141 11
d169 5
d176 15
d201 24
a224 10
	*p++ = partn->flag & 0xFF;
	*p++ = partn->shead & 0xFF;
	*p++ = (partn->ssect & 0x3F) | ((partn->scyl & 0x300) >> 2);
	*p++ = partn->scyl & 0xFF;

	*p++ = partn->id & 0xFF;

	*p++ = partn->ehead & 0xFF;
	*p++ = (partn->esect & 0x3F) | ((partn->ecyl & 0x300) >> 2);
	*p++ = partn->ecyl & 0xFF;
@


1.7
log
@make fdisk grok extended partitions again. we have to keep track of the
absolute offset of the current mbr and its relative position. because:
the starting sector of the first mbr entry in an extended partition is relative
to the starting offset of the whole mbr itself. the starting offset of a new
extended partition is relative to the offset of the very first extended
partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.6 1997/10/19 23:29:38 deraadt Exp $	*/
d84 1
a84 1
	{ 0xA5, "Free/Net BSD", "386BSD/FreeBSD/NetBSD"},
d87 1
@


1.6
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.5 1997/10/16 01:53:08 deraadt Exp $	*/
d129 1
a129 1
PRT_parse(prt, partn)
d131 2
d136 1
d140 1
d151 3
a153 1
	partn->bs = getlong(p);
d158 1
a158 1
PRT_make(partn, prt)
d160 2
d165 1
d178 1
a178 1
	putlong(p, partn->bs);
@


1.5
log
@better message
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.4 1997/10/16 01:47:12 deraadt Exp $	*/
d105 1
a105 1
	for(i = 0; i < sizeof(part_types)/sizeof(struct part_type); i++) {
d120 3
a122 3
	for(i = 0; i < sizeof(part_types)/sizeof(struct part_type); i++){
		if(part_types[i].type == id)
			return(part_types[i].sname);
d125 1
a125 1
	return(unknown);
d179 1
a179 1
	if(partn == NULL){
d183 1
a183 1
	}else{
d217 1
a217 1
	if(start > end)
@


1.4
log
@a bunch of improvements by weingart & I
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.3 1997/10/02 02:10:07 deraadt Exp $	*/
d104 1
a104 1
	printf("Choose from the following types\n");
@


1.3
log
@shorten two common names
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.2 1997/09/29 23:33:39 mickey Exp $	*/
d49 2
a50 1
	char	*name;
d52 45
a96 45
	{ 0x00, "unused"},
	{ 0x01, "Primary DOS with 12 bit FAT"},
	{ 0x02, "XENIX / filesystem"},
	{ 0x03, "XENIX /usr filesystem"},
	{ 0x04, "Primary DOS with 16 bit FAT"},
	{ 0x05, "Extended DOS"},
	{ 0x06, "Primary 'big' DOS (> 32MB)"},
	{ 0x07, "OS/2 HPFS, QNX or Advanced UNIX"},
	{ 0x08, "AIX filesystem"},
	{ 0x09, "AIX boot partition or Coherent"},
	{ 0x0A, "OS/2 Boot Manager or OPUS"},
	{ 0x0B, "Prim Win95 w/ 32-bit FAT"},
	{ 0x0E, "Prim DOS w/ 16-bit FAT, CHS-mapped"},
	{ 0x10, "OPUS"},
	{ 0x12, "Compaq Diagnostics"},
	{ 0x40, "VENIX 286"},
	{ 0x50, "DM"},
	{ 0x51, "DM"},
	{ 0x52, "CP/M or Microport SysV/AT"},
	{ 0x54, "Ontrack"},
	{ 0x56, "GB"},
	{ 0x61, "Speed"},
	{ 0x63, "ISC, System V/386, GNU HURD or Mach"},
	{ 0x64, "Novell Netware 2.xx"},
	{ 0x65, "Novell Netware 3.xx"},
	{ 0x75, "PCIX"},
	{ 0x80, "Minix 1.1 ... 1.4a"},
	{ 0x81, "Minix 1.4b ... 1.5.10"},
	{ 0x82, "Linux swap"},
	{ 0x83, "Linux filesystem"},
	{ 0x93, "Amoeba filesystem"},
	{ 0x94, "Amoeba bad block table"},
	{ 0xA5, "386BSD/FreeBSD/NetBSD"},
	{ 0xA6, "OpenBSD"},
	{ 0xA7, "NEXTSTEP"},
	{ 0xB7, "BSDI BSD/386 filesystem"},
	{ 0xB8, "BSDI BSD/386 swap"},
	{ 0xDB, "Concurrent CPM or C.DOS or CTOS"},
	{ 0xE1, "Speed"},
	{ 0xE3, "Speed"},
	{ 0xE4, "Speed"},
	{ 0xF1, "Speed"},
	{ 0xF2, "DOS 3.3+ Secondary"},
	{ 0xF4, "Speed"},
	{ 0xFF, "BBT (Bad Blocks Table)"},
d99 13
d122 1
a122 1
			return(part_types[i].name);
d182 1
a182 1
		printf("-------------------------------------------------------------------\n");
d204 2
a205 2
	spt = disk->bios->sectors;
	tpc = disk->bios->heads;
d234 2
a235 2
	spt = disk->bios->sectors;
	tpc = disk->bios->heads;
@


1.2
log
@ID in the first line w/ tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: part.c,v 1.1 1997/09/29 22:58:18 weingart Exp $	*/
d62 2
a63 2
	{ 0x0B, "Primary Windows 95 with 32 bit FAT"},
	{ 0x0E, "Primary DOS with 16-bit FAT, CHS-mapped"},
@


1.1
log
@New fdisk code with interactive (command line type)
editing code.  Rewrite from the ground up, save about
20 lines of code.  Seems to create valid partition
tables on i386 and alphas.
@
text
@d1 1
a1 2

/* $OpenBSD$ */
@
