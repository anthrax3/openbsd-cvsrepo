head	1.61;
access;
symbols
	OPENBSD_6_1:1.61.0.6
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.61.0.4
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.61.0.2
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.32.0.2
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.4
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.18
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.16
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6;
locks; strict;
comment	@ * @;


1.61
date	2015.11.26.08.15.07;	author tim;	state Exp;
branches;
next	1.60;
commitid	K0ReHvH17yLhzwH2;

1.60
date	2015.11.26.08.10.42;	author tim;	state Exp;
branches;
next	1.59;
commitid	oJwCSMrZVYGwJGFh;

1.59
date	2015.11.21.16.45.41;	author krw;	state Exp;
branches;
next	1.58;
commitid	V1q2C6UMPN69xwYN;

1.58
date	2015.11.19.16.14.08;	author krw;	state Exp;
branches;
next	1.57;
commitid	07Axfimkfyb7znjO;

1.57
date	2015.11.12.17.54.50;	author tim;	state Exp;
branches;
next	1.56;
commitid	1FY9qICWMwK3TP1g;

1.56
date	2015.11.12.15.07.41;	author krw;	state Exp;
branches;
next	1.55;
commitid	YcdqZF1BH4pZnMI8;

1.55
date	2015.11.03.14.20.00;	author krw;	state Exp;
branches;
next	1.54;
commitid	75hepZ1HnSBxxZvS;

1.54
date	2015.10.26.15.08.26;	author krw;	state Exp;
branches;
next	1.53;
commitid	fOI5D0M32zdW7eoe;

1.53
date	2015.10.07.00.04.57;	author krw;	state Exp;
branches;
next	1.52;
commitid	JculkXGJRL5nRYvS;

1.52
date	2015.08.27.20.58.27;	author krw;	state Exp;
branches;
next	1.51;
commitid	HPfwzWhA0Lbc6ZGU;

1.51
date	2015.03.30.17.11.49;	author krw;	state Exp;
branches;
next	1.50;
commitid	PQWtQHYSt0QI2mGM;

1.50
date	2015.03.29.21.16.39;	author krw;	state Exp;
branches;
next	1.49;
commitid	wVztKOyPskKRobDK;

1.49
date	2015.03.28.13.29.16;	author krw;	state Exp;
branches;
next	1.48;
commitid	Gw6r0POX7KLBjKik;

1.48
date	2015.03.26.20.32.10;	author krw;	state Exp;
branches;
next	1.47;
commitid	CHIrWMlaDm6Ai6yT;

1.47
date	2015.03.26.16.32.16;	author krw;	state Exp;
branches;
next	1.46;
commitid	fy8RrvF4AQjcuhPZ;

1.46
date	2015.03.26.14.08.12;	author krw;	state Exp;
branches;
next	1.45;
commitid	2pp42lVbpnraZMs8;

1.45
date	2015.03.16.23.51.50;	author krw;	state Exp;
branches;
next	1.44;
commitid	JG85Pc2Xt4lLAJpr;

1.44
date	2015.03.14.18.32.29;	author krw;	state Exp;
branches;
next	1.43;
commitid	VCsOzs6eGW0SpJ6c;

1.43
date	2015.03.14.15.21.53;	author krw;	state Exp;
branches;
next	1.42;
commitid	aPXwn1AfAIMw4FVu;

1.42
date	2014.03.31.19.50.52;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2014.03.20.13.18.21;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2014.03.20.02.08.29;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2014.03.17.16.40.00;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2014.03.17.13.15.44;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2014.03.14.15.41.33;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2014.03.13.12.02.28;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2014.03.10.21.40.58;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.09.22.25.06;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.07.21.56.13;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.21.18.45.58;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2012.08.14.08.48.42;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.11.10.27.34;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.09.17.19.55;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.09.17.07.35;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.09.12.45.30;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.08.18.29.28;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2012.07.08.17.46.44;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.04.22.15.31;	author halex;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.24.23.28.00;	author halex;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.07.16.06.37;	author weingart;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.01.20.15.35;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.01.04.05.43;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.08.23.22.26;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.24.17.30.45;	author moritz;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.21.01.59.24;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.18.23.22.05;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.01.13.19;	author weingart;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.20.00.58.32;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.23.22.04.01;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.18.08.38.26;	author kjell;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.18.08.33.10;	author kjell;	state Exp;
branches;
next	1.6;

1.6
date	97.10.19.23.30.48;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.19.23.29.37;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.16.02.29.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.16.01.47.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.09.29.23.33.37;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.09.29.22.58.17;	author weingart;	state Exp;
branches;
next	;


desc
@@


1.61
log
@When prompting for a GPT partition type, use the partition's current type as
default; OK krw@@
@
text
@/*	$OpenBSD: misc.c,v 1.60 2015/11/26 08:10:42 tim Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/disklabel.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <uuid.h>

#include "disk.h"
#include "misc.h"
#include "part.h"

struct unit_type unit_types[] = {
	{ "b"	, 1LL				, "Bytes"	},
	{ " "	, 0LL				, "Sectors"	},
	{ "K"	, 1024LL			, "Kilobytes"	},
	{ "M"	, 1024LL * 1024			, "Megabytes"	},
	{ "G"	, 1024LL * 1024 *1024		, "Gigabytes"	},
	{ "T"	, 1024LL * 1024 * 1024 * 1024	, "Terabytes"	},
	{ NULL	, 0				, NULL		},
};

int
unit_lookup(char *units)
{
	int i = 0;

	if (units == NULL)
		return (SECTORS);

	while (unit_types[i].abbr != NULL) {
		if (strncasecmp(unit_types[i].abbr, units, 1) == 0)
			break;
		i++;
	}
	/* default */
	if (unit_types[i].abbr == NULL)
		return (SECTORS);

	return (i);
}

int
string_from_line(char *buf, size_t buflen)
{
	char *line;
	size_t sz;

	line = fgetln(stdin, &sz);
	if (line == NULL)
		return (1);

	if (line[sz - 1] == '\n')
		sz--;
	if (sz >= buflen)
		sz = buflen - 1;

	memcpy(buf, line, sz);
	buf[sz] = '\0';

	return (0);
}

void
ask_cmd(char **cmd, char **arg)
{
	static char lbuf[100];
	size_t cmdstart, cmdend, argstart;

	/* Get NUL terminated string from stdin. */
	if (string_from_line(lbuf, sizeof(lbuf)))
		errx(1, "eof");

	cmdstart = strspn(lbuf, " \t");
	cmdend = cmdstart + strcspn(&lbuf[cmdstart], " \t");
	argstart = cmdend + strspn(&lbuf[cmdend], " \t");

	/* *cmd and *arg may be set to point at final NUL! */
	*cmd = &lbuf[cmdstart];
	lbuf[cmdend] = '\0';
	*arg = &lbuf[argstart];
}

int
ask_num(const char *str, int dflt, int low, int high)
{
	char lbuf[100];
	const char *errstr;
	int num;

	if (dflt < low)
		dflt = low;
	else if (dflt > high)
		dflt = high;

	do {
		printf("%s [%d - %d]: [%d] ", str, low, high, dflt);

		if (string_from_line(lbuf, sizeof(lbuf)))
			errx(1, "eof");

		if (lbuf[0] == '\0') {
			num = dflt;
			errstr = NULL;
		} else {
			num = (int)strtonum(lbuf, low, high, &errstr);
			if (errstr)
				printf("%s is %s: %s.\n", str, errstr, lbuf);
		}
	} while (errstr);

	return (num);
}

int
ask_pid(int dflt, struct uuid *guid)
{
	char lbuf[100], *cp;
	int num = -1, status;

	do {
		printf("Partition id ('0' to disable) [01 - FF]: [%X] ", dflt);
		printf("(? for help) ");

		if (string_from_line(lbuf, sizeof(lbuf)))
			errx(1, "eof");

		if (lbuf[0] == '?') {
			PRT_printall();
			continue;
		}

		if (guid && strlen(lbuf) == UUID_STR_LEN) {
			uuid_from_string(lbuf, guid, &status);
			if (status == uuid_s_ok)
				return (0x100);
		}

		/* Convert */
		cp = lbuf;
		num = strtol(lbuf, &cp, 16);

		/* Make sure only number present */
		if (cp == lbuf)
			num = dflt;
		if (*cp != '\0') {
			printf("'%s' is not a valid number.\n", lbuf);
			num = -1;
		} else if (num == 0) {
			break;
		} else if (num < 0 || num > 0xff) {
			printf("'%x' is out of range.\n", num);
		}
	} while (num < 0 || num > 0xff);

	return (num);
}

int
ask_yn(const char *str)
{
	int ch, first;
	extern int y_flag;

	if (y_flag)
		return (1);

	printf("%s [n] ", str);
	fflush(stdout);

	first = ch = getchar();
	while (ch != '\n' && ch != EOF)
		ch = getchar();

	if (ch == EOF || first == EOF)
		errx(1, "eof");

	return (first == 'y' || first == 'Y');
}

/*
 * adapted from sbin/disklabel/editor.c
 */
u_int64_t
getuint64(char *prompt, u_int64_t oval, u_int64_t minval, u_int64_t maxval)
{
	const int secsize = unit_types[SECTORS].conversion;
	char buf[BUFSIZ], *endptr, *p, operator = '\0';
	size_t n;
	int64_t mult = 1;
	double d, d2;
	int secpercyl, saveerr;
	char unit;

	if (oval > maxval)
		oval = maxval;
	if (oval < minval)
		oval = minval;

	secpercyl = disk.sectors * disk.heads;

	do {
		printf("%s [%llu - %llu]: [%llu] ", prompt, minval, maxval,
		    oval);

		if (string_from_line(buf, sizeof(buf)))
			errx(1, "eof");

		if (buf[0] == '\0') {
			return (oval);
		} else if (buf[0] == '*' && buf[1] == '\0') {
			return (maxval);
		}

		/* deal with units */
		n = strlen(buf);
		switch (tolower((unsigned char)buf[n-1])) {
		case 'c':
			unit = 'c';
			mult = secpercyl;
			buf[--n] = '\0';
			break;
		case 'b':
			unit = 'b';
			mult = -(int64_t)secsize;
			buf[--n] = '\0';
			break;
		case 's':
			unit = 's';
			mult = 1;
			buf[--n] = '\0';
			break;
		case 'k':
			unit = 'k';
			if (secsize > 1024)
				mult = -(int64_t)secsize / 1024LL;
			else
				mult = 1024LL / secsize;
			buf[--n] = '\0';
			break;
		case 'm':
			unit = 'm';
			mult = (1024LL * 1024) / secsize;
			buf[--n] = '\0';
			break;
		case 'g':
			unit = 'g';
			mult = (1024LL * 1024 * 1024) / secsize;
			buf[--n] = '\0';
			break;
		case 't':
			unit = 't';
			mult = (1024LL * 1024 * 1024 * 1024) / secsize;
			buf[--n] = '\0';
			break;
		default:
			unit = ' ';
			mult = 1;
			break;
		}

		/* deal with the operator */
		p = &buf[0];
		if (*p == '+' || *p == '-')
			operator = *p++;
		else
			operator = ' ';

		endptr = p;
		errno = 0;
		d = strtod(p, &endptr);
		saveerr = errno;
		d2 = d;
		if (mult > 0)
			d *= mult;
		else {
			d /= (-mult);
			d2 = d;
		}

		/* Apply the operator */
		if (operator == '+')
			d = oval + d;
		else if (operator == '-') {
			d = oval - d;
			d2 = d;
		}

		if (saveerr == ERANGE || d > maxval || d < minval || d < d2) {
			printf("%s is out of range: %c%s%c\n", prompt, operator,
			    p, unit);
		} else if (*endptr != '\0') {
			printf("%s is invalid: %c%s%c\n", prompt, operator,
			    p, unit);
		} else {
			break;
		}
	} while (1);

	return((u_int64_t)d);
}

char *
ask_string(const char *prompt, const char *oval)
{
	static char buf[37];

	buf[0] = '\0';
	printf("%s: [%s] ", prompt, oval ? oval : "");
	if (string_from_line(buf, sizeof(buf)))
		errx(1, "eof");

	if (buf[0] == '\0' && oval)
		strlcpy(buf, oval, sizeof(buf));

	return(buf);
}

/*
 * Adapted from Hacker's Delight crc32b().
 *
 * To quote http://www.hackersdelight.org/permissions.htm :
 *
 * "You are free to use, copy, and distribute any of the code on
 *  this web site, whether modified by you or not. You need not give
 *  attribution. This includes the algorithms (some of which appear
 *  in Hacker's Delight), the Hacker's Assistant, and any code submitted
 *  by readers. Submitters implicitly agree to this."
 */
u_int32_t
crc32(const u_char *buf, const u_int32_t size)
{
	int j;
	u_int32_t i, byte, crc, mask;

	crc = 0xFFFFFFFF;

	for (i = 0; i < size; i++) {
		byte = buf[i];			/* Get next byte. */
		crc = crc ^ byte;
		for (j = 7; j >= 0; j--) {	/* Do eight times. */
			mask = -(crc & 1);
			crc = (crc >> 1) ^ (0xEDB88320 & mask);
		}
	}

	return ~crc;
}

char *
utf16le_to_string(u_int16_t *utf)
{
	static char name[GPTPARTNAMESIZE];
	int i;

	for (i = 0; i < GPTPARTNAMESIZE; i++) {
		name[i] = letoh16(utf[i]) & 0x7F;
		if (name[i] == '\0')
			break;
	}
	if (i == GPTPARTNAMESIZE)
		name[i - 1] = '\0';

	return (name);
}

u_int16_t *
string_to_utf16le(char *ch)
{
	static u_int16_t utf[GPTPARTNAMESIZE];
	int i;

	for (i = 0; i < GPTPARTNAMESIZE; i++) {
		utf[i] = htole16((unsigned int)ch[i]);
		if (utf[i] == 0)
			break;
	}
	if (i == GPTPARTNAMESIZE)
		utf[i - 1] = 0;

	return (utf);
}
@


1.60
log
@When prompting for an LBA, show the min and max values in the prompt; OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.59 2015/11/21 16:45:41 krw Exp $	*/
d154 1
a154 1
		if (guid) {
@


1.59
log
@Bring GPT partition editing into line with MBR partition editing
by presenting the existing offset and size as the defaults. Enhance
getuint64() to take a minimum value as ask_num() does. Use this to
ensure that GPT partitions are constrained to the valid area of the
disk. Leave MBR partition constraints alone for the moment.

Original problem(s) noted by tim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.58 2015/11/19 16:14:08 krw Exp $	*/
d224 2
a225 1
		printf("%s: [%llu] ", prompt, oval);
@


1.58
log
@Reduce overburden of unnecessary #include's. Note that param.h is
included only for DEV_BSIZE.  Use INT64_MAX instead of LLONG_MAX
so stdint.h is enough.  General tidying up of #include sections.

ok GCC
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.57 2015/11/12 17:54:50 tim Exp $	*/
d206 1
a206 1
getuint64(char *prompt, u_int64_t oval, u_int64_t maxval)
d218 2
d309 1
a309 1
		if (saveerr == ERANGE || d > maxval || d < 0 || d < d2) {
@


1.57
log
@Simplify string_from_line(). No functional change.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.56 2015/11/12 15:07:41 krw Exp $	*/
d21 1
d23 2
a27 2
#include <err.h>
#include <errno.h>
@


1.56
log
@Avoid problems with pathological input during edit operations. i.e. never
attempt to use data past the end of the input.

Since the return value of ask_cmd() is never checked, make it void instead
of int.

Problems found, original diff from and ok tim@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.55 2015/11/03 14:20:00 krw Exp $	*/
d74 3
a76 1
		line[--sz] = '\0';
d78 2
a79 7
	if (sz < buflen) {
		memcpy(buf, line, sz);
		buf[sz] = '\0';
	} else {
		memcpy(buf, line, buflen - 1);
		buf[buflen - 1] = '\0';
	}
@


1.55
log
@Don't allow the user to enter GPT partition names too large to fit
in the GPT partition structure. And don't run off the end of the
name buffer by confusing sizeof() with the number of elements in
an array.  Use the new GPTPARTNAMESIZE #define instead. While here,
zap the old partition name before setting the new one, lest a short
new name leave bits of an old long name in place.

Originally spotted by jsg@@ and his friend cppcheck.

ok jsg@@ for slightly different version.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.54 2015/10/26 15:08:26 krw Exp $	*/
d87 2
a88 2
int
ask_cmd(char **cmd, char **args)
d91 1
a91 1
	char *cp, *buf;
d93 1
a93 1
	/* Get input */
d97 8
a104 9
	/* Parse input */
	buf = lbuf;
	buf = &buf[strspn(buf, " \t")];
	cp = &buf[strcspn(buf, " \t")];
	*cp++ = '\0';
	*cmd = buf;
	*args = &cp[strspn(cp, " \t")];

	return (0);
@


1.54
log
@Add GPT editing. Based on GSOC 2014 work by Markus Muller.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.53 2015/10/07 00:04:57 krw Exp $	*/
d374 1
a374 1
	static char name[36];
d377 1
a377 1
	for (i = 0; i < sizeof(name); i++) {
d382 1
a382 1
	if (i == sizeof(name))
d391 1
a391 1
	static u_int16_t utf[36];
d394 1
a394 1
	for (i = 0; i < sizeof(utf); i++) {
d399 1
a399 1
	if (i == sizeof(utf))
@


1.53
log
@Note permissions for the crc32() code adapted from Hacker's Delight.

Prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.52 2015/08/27 20:58:27 krw Exp $	*/
d27 1
d64 24
a91 1
	size_t lbuflen;
d94 1
a94 1
	if (fgets(lbuf, sizeof lbuf, stdin) == NULL)
a95 3
	lbuflen = strlen(lbuf);
	if (lbuflen > 0 && lbuf[lbuflen - 1] == '\n')
		lbuf[lbuflen - 1] = '\0';
a112 1
	size_t lbuflen;
d123 1
a123 1
		if (fgets(lbuf, sizeof lbuf, stdin) == NULL)
a125 4
		lbuflen = strlen(lbuf);
		if (lbuflen > 0 && lbuf[lbuflen - 1] == '\n')
			lbuf[lbuflen - 1] = '\0';

d140 1
a140 1
ask_pid(int dflt, int low, int high)
d143 1
a143 10
	size_t lbuflen;
	int num = -1;

	if (low == 1)
		low = 0;	/* Show continguous range */

	if (dflt < low)
		dflt = low;
	else if (dflt > high)
		dflt = high;
d146 1
a146 2
		printf("Partition id ('0' to disable) [%X - %X]: [%X] ", low,
		    high, dflt);
d149 1
a149 1
		if (fgets(lbuf, sizeof lbuf, stdin) == NULL)
a150 3
		lbuflen = strlen(lbuf);
		if (lbuflen > 0 && lbuf[lbuflen - 1] == '\n')
			lbuf[lbuflen - 1] = '\0';
d157 6
d172 1
a172 1
			num = low - 1;
d175 1
a175 1
		} else if (num < low || num > high) {
d178 1
a178 1
	} while (num < low || num > high);
d227 1
a227 1
		if (fgets(buf, sizeof(buf), stdin) == NULL)
a229 4
		n = strlen(buf);
		if (n > 0 && buf[n-1] == '\n')
			buf[--n] = '\0';

d237 1
d327 1
a327 2
	static char buf[BUFSIZ];
	int n;
d330 6
a335 16
	do {
		printf("%s: [%s] ", prompt, oval ? oval : "");
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			buf[0] = '\0';
			if (feof(stdin)) {
				clearerr(stdin);
				putchar('\n');
				return(NULL);
			}
		}
		n = strlen(buf);
		if (n > 0 && buf[n-1] == '\n')
			buf[--n] = '\0';
		else if (oval != NULL && buf[0] == '\0')
			strlcpy(buf, oval, sizeof(buf));
	} while (buf[0] == '?');
d337 1
a337 1
	return(&buf[0]);
d369 34
@


1.52
log
@Nuke some trailing whitespace that keeps coming back.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.51 2015/03/30 17:11:49 krw Exp $	*/
d347 8
@


1.51
log
@Even better -- readsector() and writesector() become DISK_readsector() and
DISK_writesector() and live in disk.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.50 2015/03/29 21:16:39 krw Exp $	*/
d306 1
a306 1
			    p, unit); 
d309 1
a309 1
			    p, unit); 
@


1.50
log
@Rename MBR_readsector() and MBR_writesector() to just readsector()
and writesector(). Move them to misc.[ch]. Soon to be used for more
than MBR reading/writing.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.49 2015/03/28 13:29:16 krw Exp $	*/
a24 1
#include <unistd.h>
a365 61
}

/*
 * Read the sector at 'where' from the file descriptor 'fd' into newly 
 * calloc'd memory. Return a pointer to the memory if it contains the
 * requested data, or NULL if it does not.
 *
 * The caller must free() the memory it gets.
 */
char *
readsector(int fd, off_t where)
{
	const int secsize = unit_types[SECTORS].conversion;
	char *secbuf;
	ssize_t len;
	off_t off;

	where *= secsize;
	off = lseek(fd, where, SEEK_SET);
	if (off != where)
		return (NULL);

	secbuf = calloc(1, secsize);
	if (secbuf == NULL)
		return (NULL);

	len = read(fd, secbuf, secsize);
	if (len == -1 || len != secsize) {
		free(secbuf);
		return (NULL);
	}

	return (secbuf);
}

/*
 * Write the sector-sized 'secbuf' to the sector 'where' on the file
 * descriptor 'fd'. Return 0 if the write works. Return -1 and set
 * errno if the write fails.
 */
int
writesector(int fd, char *secbuf, off_t where)
{
	const int secsize = unit_types[SECTORS].conversion;
	ssize_t len;
	off_t off;

	len = -1;

	where *= secsize;
	off = lseek(fd, where, SEEK_SET);
	if (off == where)
		len = write(fd, secbuf, secsize);

	if (len == -1 || len != secsize) {
		/* short read or write */
		errno = EIO;
		return (-1);
	}

	return (0);
@


1.49
log
@Add a simple crc32() implmentation to avoid pulling in libz, which
would complicate install media. Will be used by GPT support.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.48 2015/03/26 20:32:10 krw Exp $	*/
d25 1
d367 61
@


1.48
log
@Adapt ask_string() from disklabel's getstring(). It will be used
to obtain GPT partition names. Tweak ask_pid() to take low/high
bounds so it can handle 1-ff (MBR) or 1000-ffff (GPT) partition
pids as required. A pid of '0' is still special and disables the
partition.

No visible or intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.47 2015/03/26 16:32:16 krw Exp $	*/
d343 23
@


1.47
log
@Allow input/printing/conversion of terabyte sizes. Which GPT partitons
will eventually be able to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.46 2015/03/26 14:08:12 krw Exp $	*/
d124 1
a124 1
ask_pid(int dflt)
d129 3
a131 1
	const int low = 0, high = 0xff;
d164 2
d316 27
@


1.46
log
@Expand internal representation of partition starting LBA and size
to 64 bits, adjusting printf()'s, etc. as required. Preparing for
GPT partitions. Add 't' size unit. No other intentional functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.45 2015/03/16 23:51:50 krw Exp $	*/
d33 7
a39 6
	{"b", 1			, "Bytes"},
	{" ", 0			, "Sectors"},	/* Filled in from disklabel. */
	{"K", 1024		, "Kilobytes"},
	{"M", 1024 * 1024	, "Megabytes"},
	{"G", 1024 * 1024 *1024	, "Gigabytes"},
	{NULL, 0		, NULL },
d198 1
d201 1
a201 1
	int mult = 1, secsize = unit_types[SECTORS].conversion;
@


1.45
log
@Stop passing around a pointer to the stack variable 'disk' in main().
There is only one disk being worked on, so just make it a global.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.44 2015/03/14 18:32:29 krw Exp $	*/
d194 2
a195 2
u_int32_t
getuint(char *prompt, u_int32_t oval, u_int32_t maxval)
d210 1
a210 1
		printf("%s: [%u] ", prompt, oval);
d234 1
a234 1
			mult = -secsize;
d245 1
a245 1
				mult = -secsize / 1024;
d247 1
a247 1
				mult = 1024 / secsize;
d252 1
a252 1
			mult = 1048576 / secsize;
d257 6
a262 1
			mult = 1073741824 / secsize;
d309 1
a309 1
	return ((u_int32_t)d);
@


1.44
log
@Whitespace & KNF tweaks. Change functions whose return values are
not checked to void. Use continue inside a do loop instead of a
goto to the top. Move a #define/#undef more local to use. Eliminate
some lint.

General cleanup of things noticed preparing the big churn.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.43 2015/03/14 15:21:53 krw Exp $	*/
d195 1
a195 1
getuint(struct disk *disk, char *prompt, u_int32_t oval, u_int32_t maxval)
d207 1
a207 1
	secpercyl = disk->sectors * disk->heads;
@


1.43
log
@Switch all the license blocks to the standard OpenBSD/ISC license.

With the permission of Toby.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.42 2014/03/31 19:50:52 krw Exp $	*/
d45 1
@


1.42
log
@Nuke [get|put][short|long] and just use letoh[16|32] and
htole[16|32]. This is made possible by a) copying unaligned data
(struct dos_partition's) into properly aligned structs and accessing
the fields of the same; and b) realizing that gcc is smart enough to
access fields in packed struct's *if* it knows it is accessing a
packed struct. Even sparc64 finally gave a thumbs up.

After several attempts and feedback from deraadt@@ and dlg@@, it looks
good to deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.41 2014/03/20 13:18:21 krw Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.41
log
@Add back various #includes of err.h, unistd.h, ctype.h, ioctl.h to
eliminate multiple 'implicit' declarations introduced by the previous
over-zealous #include cleanup.

Thanks to to tedu@@ for pointing out how -Wall reveals all.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.40 2014/03/20 02:08:29 krw Exp $	*/
a196 36
}

u_int16_t
getshort(void *p)
{
	unsigned char *cp = p;

	return (cp[0] | (cp[1] << 8));
}

void
putshort(void *p, u_int16_t l)
{
	unsigned char *cp = p;

	*cp++ = l;
	*cp++ = l >> 8;
}

u_int32_t
getlong(void *p)
{
	unsigned char *cp = p;

	return (cp[0] | (cp[1] << 8) | (cp[2] << 16) | (cp[3] << 24));
}

void
putlong(void *p, u_int32_t l)
{
	unsigned char *cp = p;

	*cp++ = l;
	*cp++ = l >> 8;
	*cp++ = l >> 16;
	*cp++ = l >> 24;
@


1.40
log
@Add back #include <stdlib.h> so strtod() works better. Fixes fdisk on
sparc64 at least.

Found when deraadt@@ complained about loongson miniroot blowing up.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.39 2014/03/17 16:40:00 krw Exp $	*/
d30 1
d34 1
d39 1
@


1.39
log
@Nuke pointless blank lines, defines, comments and casts. Eliminate
#include in *.h files in favour of listing them as required in the *.c
files. Fix error message to correctly state that 64 is the minimum
value for -l. Use errx() where errno is not relevant. Use 'continue'
rather than a label to go back to start of a loop.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.38 2014/03/17 13:15:44 krw Exp $	*/
d31 1
@


1.38
log
@Un-revert, being careful to not break snap building. Add paranoia check
for any missing geometry.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.37 2014/03/14 15:41:33 krw Exp $	*/
d34 1
d51 1
a51 1
		return (UNIT_TYPE_DEFAULT);
d60 1
a60 1
		return (UNIT_TYPE_DEFAULT);
d131 1
a131 1
	int num;
a139 1
again:
d152 1
a152 1
			goto again;
@


1.37
log
@Revert last -- broke building snaps.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.36 2014/03/13 12:02:28 krw Exp $	*/
d247 1
a247 1
	secpercyl = disk->real->sectors * disk->real->heads;
@


1.36
log
@Merge 'struct DISK_metrics' and 'struct disk' into one, since we don't
need to record two sets of metric/geometry data. Use 'geometry'
instead of 'metrics' in names and comments. Eliminate
DISK_getmetrics().

While here, make 64 the minimal valid value for '-l' instead of 1. This
avoids the possibility of having 0 cylinders.

No intentional functional change.

Feedback & tweak from chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.35 2014/03/10 21:40:58 krw Exp $	*/
d247 1
a247 1
	secpercyl = disk->sectors * disk->heads;
@


1.35
log
@No need to pass the name of the command to the function that is
implementing that command, a pointer to the command arguments is the
only thing needed. No need to have a pointer to the command table in
every command, since there is only one table. No need for shiney new
stack space for every command name and arguments parsed, since we
don't recurse we can just use static memory.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.34 2014/03/09 22:25:06 krw Exp $	*/
d247 1
a247 1
	secpercyl = disk->real->sectors * disk->real->heads;
@


1.34
log
@Instead of passing around 'char buf[DEV_BSIZE]' buffers, pass around
'struct dos_mbr' variables, since that is what the buffers were used
for. Removes need to know about DEV_BSIZE and thus include param.h
from all files but one so move the param.h #include to that file
(mbr.c).

Nuke a bunch of local MBR #defines in favour of the disklabel.h ones.

Remove a bunch of unneeded #includes, replace the odd malloc/bzero
with calloc, replace equally odd bcopy's with memcpy, remove a stray
duplicate MBR parsing in MBR_pcopy().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.33 2014/03/07 21:56:13 krw Exp $	*/
d65 1
a65 1
ask_cmd(struct cmd *cmd)
d67 2
a68 1
	char lbuf[100], *cp, *buf;
d83 2
a84 3
	strncpy(cmd->cmd, buf, sizeof(cmd->cmd));
	buf = &cp[strspn(cp, " \t")];
	strncpy(cmd->args, buf, sizeof(cmd->args));
@


1.33
log
@Relieve the code of an overburden of unnecessary typedef
abstraction. Call a 'struct' a 'struct' and not a pony.

No functional change.

idea ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.32 2013/11/22 04:12:47 deraadt Exp $	*/
a29 1
#include <err.h>
a30 2
#include <ctype.h>
#include <stdlib.h>
d33 1
a33 1
#include <limits.h>
d38 1
a38 1
	{" ", DEV_BSIZE		, "Sectors"},
@


1.32
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.31 2013/03/21 18:45:58 deraadt Exp $	*/
d68 1
a68 1
ask_cmd(cmd_t *cmd)
d238 1
a238 1
getuint(disk_t *disk, char *prompt, u_int32_t oval, u_int32_t maxval)
@


1.31
log
@more substantial include cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.30 2012/08/14 08:48:42 chl Exp $	*/
d269 1
a269 1
		switch (tolower(buf[n-1])) {
@


1.30
log
@remove unused variable

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.29 2012/07/11 10:27:34 krw Exp $	*/
d28 2
a35 1
#include <sys/disklabel.h>
@


1.29
log
@Simplify guts and calling of getuint(). Eliminate a useless 'help'
capablity by using help text as regular prompt for 'size' and
'offset'. Try to detect and handle more overflow/underflow conditions
in getuint() and ensure returned value is always within requested
bounds. Handle zero-length partitions by treating them as UNUSED.

tested & ok halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.28 2012/07/09 17:19:55 krw Exp $	*/
d94 1
a94 1
	char lbuf[100], *cp;
@


1.28
log
@We always want to do unit conversions. So flags parameter of getuint()
is now superflous. With rounding gone the offset parameter is
similarly superfluous. Simply getuint() accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.27 2012/07/09 17:07:35 krw Exp $	*/
a234 1
 * Returns UINT_MAX on error
d237 1
a237 2
getuint(disk_t *disk, char *prompt, char *helpstring, u_int32_t oval,
    u_int32_t maxval)
a239 1
	u_int32_t rval = oval;
d242 6
a247 2
	double d;
	int secpercyl;
a250 1
	buf[0] = '\0';
d253 1
d256 1
d260 7
a266 7
		if (buf[0] == '?')
			puts(helpstring);
	} while (buf[0] == '?');

	if (buf[0] == '*' && buf[1] == '\0') {
		rval = maxval;
	} else {
d268 39
a306 2
		if (buf[0] != '\0' && n > 0) {
			switch (tolower(buf[n-1])) {
d308 17
a324 55
			case 'c':
				mult = secpercyl;
				buf[--n] = '\0';
				break;
			case 'b':
				mult = -secsize;
				buf[--n] = '\0';
				break;
			case 's':
				buf[--n] = '\0';
				break;
			case 'k':
				if (secsize > 1024)
					mult = -secsize / 1024;
				else
					mult = 1024 / secsize;
				buf[--n] = '\0';
				break;
			case 'm':
				mult = 1048576 / secsize;
				buf[--n] = '\0';
				break;
			case 'g':
				mult = 1073741824 / secsize;
				buf[--n] = '\0';
				break;
			}

			/* Did they give us an operator? */
			p = &buf[0];
			if (*p == '+' || *p == '-')
				operator = *p++;

			endptr = p;
			errno = 0;
			d = strtod(p, &endptr);
			if (errno == ERANGE)
				rval = UINT_MAX;	/* too big/small */
			else if (*endptr != '\0') {
				errno = EINVAL;		/* non-numbers in str */
				rval = UINT_MAX;
			} else {
				/* XXX - should check for overflow */
				if (mult > 0)
					rval = d * mult;
				else
					/* Negative mult means divide (fancy) */
					rval = d / (-mult);

				/* Apply the operator */
				if (operator == '+')
					rval += oval;
				else if (operator == '-')
					rval = oval - rval;
			}
a325 1
	}
d327 20
a346 1
	return(rval);
@


1.27
log
@I want some of what kjell was smoking 10 years ago when he added
units handling by copying getuint() from disklabel. MBR partition id
and disklabel partition type are different beasts. So deciding to
round off a MBR partition with id FS_BSDFFS meant rounding off
NTFS partitions. And FS_SWAP partitions meant DOS FAT 12. So just
nuke rounding off for now to simplify getuint().

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.26 2012/07/09 12:45:30 krw Exp $	*/
d239 1
a239 1
    u_int32_t maxval, u_int32_t offset,	int flags)
a249 3
	/* We only care about the remainder */
	offset = offset % secpercyl;

d267 1
a267 2
			if ((flags & DO_CONVERSIONS)) {
				switch (tolower(buf[n-1])) {
d269 26
a294 27
				case 'c':
					mult = secpercyl;
					buf[--n] = '\0';
					break;
				case 'b':
					mult = -secsize;
					buf[--n] = '\0';
					break;
				case 's':
					buf[--n] = '\0';
					break;
				case 'k':
					if (secsize > 1024)
						mult = -secsize / 1024;
					else
						mult = 1024 / secsize;
					buf[--n] = '\0';
					break;
				case 'm':
					mult = 1048576 / secsize;
					buf[--n] = '\0';
					break;
				case 'g':
					mult = 1073741824 / secsize;
					buf[--n] = '\0';
					break;
				}
@


1.26
log
@Use strtonum() instead of strtol() inside ask_num(). Many overflows
are thus avoided. Since bounds are now reliable don't check the
returned value for being in-bounds. Since default value is
forced inside bounds, don't bother being tricky and passing a
default that is outside the bounds being specified.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.25 2012/07/08 18:29:28 krw Exp $	*/
a327 23
			}
		}
	}
	if ((flags & DO_ROUNDING) && rval < UINT_MAX) {
#ifndef CYLCHECK
		/* Round to nearest cylinder unless given in sectors */
		if (mult != 1)
#endif
		{
			u_int32_t cyls;

			/* If we round up past the end, round down instead */
			cyls = (u_int32_t)((rval / (double)secpercyl)
			    + 0.5);
			if (cyls != 0 && secpercyl != 0) {
				if ((cyls * secpercyl) - offset > maxval)
					cyls--;

				if (rval != (cyls * secpercyl) - offset) {
					rval = (cyls * secpercyl) - offset;
					printf("Rounding to nearest cylinder: %u\n",
					    rval);
				}
@


1.25
log
@set_pid() does not need prompt string, low or high parameters. These
are all constants. Independantly suggested by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.24 2012/07/08 17:46:44 krw Exp $	*/
d95 1
d109 1
d114 1
a114 6
		/* Convert */
		cp = lbuf;
		num = strtol(lbuf, &cp, 10);

		/* Make sure only number present */
		if (cp == lbuf)
d116 5
a120 5
		if (*cp != '\0') {
			printf("'%s' is not a valid number.\n", lbuf);
			num = low - 1;
		} else if (num < low || num > high) {
			printf("'%d' is out of range.\n", num);
d122 1
a122 1
	} while (num < low || num > high);
@


1.24
log
@Split out an ask_pid() function rather than over-parameterizing the
ask_num() function. Remove now unneeded 'flags' and 'help' parameters
from both. Display out of range values in hex in ask_pid(), since
we are seeking hex input.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.23 2010/07/04 22:15:31 halex Exp $	*/
d131 1
a131 1
ask_pid(const char *str, int dflt, int low, int high)
d136 1
d145 2
a146 1
		printf("%s [%X - %X]: [%X] ", str, low, high, dflt);
@


1.23
log
@make ^D handling consistant in fdisk by just bailing out instead of
returning a magic value that is not even handled as such by the caller

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.22 2009/07/24 23:28:00 halex Exp $	*/
d92 40
a131 2
ask_num(const char *str, int flags, int dflt, int low, int high,
    void (*help)(void))
d144 2
a145 6
		if (flags == ASK_HEX)
			printf("%s [%X - %X]: [%X] ", str, low, high, dflt);
		else
			printf("%s [%d - %d]: [%d] ", str, low, high, dflt);
		if (help)
			printf("(? for help) ");
d153 2
a154 2
		if (help && lbuf[0] == '?') {
			(*help)();
d160 1
a160 1
		num = strtol(lbuf, &cp, ((flags==ASK_HEX)?16:10));
d169 1
a169 1
			printf("'%d' is out of range.\n", num);
@


1.22
log
@properly sanitize the default value in ask_num(...)
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.21 2009/04/07 16:06:37 weingart Exp $	*/
d223 2
a224 8
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			buf[0] = '\0';
			if (feof(stdin)) {
				clearerr(stdin);
				putchar('\n');
				return(UINT_MAX - 1);
			}
		}
@


1.21
log
@Fix the default value to be between low/high range.  Thanks for
frantisek holop pointing out the issue. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.20 2008/12/01 20:15:35 ray Exp $	*/
d99 5
a105 6
		if (dflt < low)
			num = low;
		else if (dflt > high)
			num = high;
		else
			num = dflt;
d107 1
a107 1
			printf("%s [%X - %X]: [%X] ", str, low, high, num);
d109 1
a109 1
			printf("%s [%d - %d]: [%d] ", str, low, high, num);
@


1.20
log
@Back out previous; it broke specifying paritions sizes with decimals,
e.g. "0.5g".
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.18 2006/11/08 23:22:26 deraadt Exp $	*/
d101 6
a106 1
		num = dflt;
@


1.19
log
@Check for invalid integers passed getuint(); instead of getuint()
returning an error, just reprompt. If there is an error reading
from stdin, use the old (default) value.

Shrinks fdisk a few bytes!

OK deraadt.
@
text
@d33 1
d35 1
d198 1
a198 1
 * retries on error
d204 1
a204 2
	char buf[BUFSIZ], *p, operator;
	const char *errstr;
d207 1
a207 1
	int mult, secsize = unit_types[SECTORS].conversion;
d216 1
a216 3
 restart:
	mult = 1;
	operator = '\0';
d224 1
d276 9
a284 4
			d = strtonum(p, 0, maxval, &errstr);
			if (errstr)
				goto restart;
			else {
d300 1
a300 1
	if (flags & DO_ROUNDING) {
@


1.18
log
@add a -y flag, for non-interactive use
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.17 2006/10/24 17:30:45 moritz Exp $	*/
a32 1
#include <errno.h>
a33 1
#include <limits.h>
d196 1
a196 1
 * Returns UINT_MAX on error
d202 2
a203 1
	char buf[BUFSIZ], *endptr, *p, operator = '\0';
d206 1
a206 1
	int mult = 1, secsize = unit_types[SECTORS].conversion;
d215 3
a217 1
	buf[0] = '\0';
a224 1
				return(UINT_MAX - 1);
d276 4
a279 9
			endptr = p;
			errno = 0;
			d = strtod(p, &endptr);
			if (errno == ERANGE)
				rval = UINT_MAX;	/* too big/small */
			else if (*endptr != '\0') {
				errno = EINVAL;		/* non-numbers in str */
				rval = UINT_MAX;
			} else {
d295 1
a295 1
	if ((flags & DO_ROUNDING) && rval < UINT_MAX) {
@


1.17
log
@Check strlen(buf) to be > 0 before accessing buf[strlen(buf)-1].
OK ray@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.16 2005/11/21 01:59:24 krw Exp $	*/
d142 4
@


1.16
log
@Replace default DEV_BSIZE sector conversion factor with disklabel's
sector size when possible. Fixes the "[ XX Sectors ]" size display.
Pointed out by Robert Szasz while playing with his Sony Hi-MD device.

Apply input conversion fixes similar to those recently applied to
disklabel(8). Use correct sector size in the conversions.

It is still *not* possible to use unusual sector sizes for non-ISO9660
filesystems!

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.15 2004/09/18 23:22:05 deraadt Exp $	*/
d70 1
d75 3
a77 1
	lbuf[strlen(lbuf)-1] = '\0';
d96 1
d111 3
a113 1
		lbuf[strlen(lbuf)-1] = '\0';
@


1.15
log
@some delinting; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.14 2003/07/29 18:38:35 deraadt Exp $	*/
d38 1
a38 1
const struct unit_type unit_types[] = {
d197 1
a197 1
	int mult = 1;
d237 1
a237 1
					mult = -DEV_BSIZE;
d244 4
a247 1
					mult = 1024 / DEV_BSIZE;
d251 1
a251 1
					mult = 1048576 / DEV_BSIZE;
d255 1
a255 1
					mult = 1073741824 / DEV_BSIZE;
@


1.14
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.13 2003/06/11 06:22:12 deraadt Exp $	*/
d37 9
@


1.13
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2003/06/03 01:13:19 weingart Exp $	*/
d53 1
a53 1
	
d191 1
a191 1
	
@


1.12
log
@Nuke terms 3 & 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.11 2002/04/20 00:58:32 espie Exp $	*/
d39 1
a39 2
unit_lookup(units)
	char *units;
d58 1
a58 2
ask_cmd(cmd)
	cmd_t *cmd;
d80 2
a81 7
ask_num(str, flags, dflt, low, high, help)
	const char *str;
	int flags;
	int dflt;
	int low;
	int high;
	void (*help)(void);
d124 1
a124 2
ask_yn(str)
	const char *str;
d142 1
a142 2
getshort(p)
	void *p;
d150 1
a150 3
putshort(p, l)
	void *p;
	u_int16_t l;
d159 1
a159 2
getlong(p)
	void *p;
d167 1
a167 3
putlong(p, l)
	void *p;
	u_int32_t l;
d182 2
a183 8
getuint(disk, prompt, helpstring, oval, maxval, offset, flags)
	disk_t *disk;
	char *prompt;
	char *helpstring;
	u_int32_t oval;
	u_int32_t maxval;
	u_int32_t offset;
	int flags;
@


1.11
log
@machine/limits.h is not userland. Use limits.h
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.10 2002/02/16 21:27:34 millert Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.9 2002/01/23 22:04:01 mickey Exp $	*/
d40 1
a40 1
#include <machine/limits.h>
@


1.9
log
@use sizeof instead of magic numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.8 2002/01/18 08:38:26 kjell Exp $	*/
d93 1
a93 1
	void (*help) __P((void));
@


1.8
log
@Allow size values to be displayed in the user's choice of units.
Idea borrowed from disklabel. i.e. Users can now type "print M"
and be rewarded with partition sizes in Megs
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.7 2002/01/18 08:33:10 kjell Exp $	*/
d79 1
a79 1
	strncpy(cmd->cmd, buf, 10);
d81 1
a81 1
	strncpy(cmd->args, buf, 100);
@


1.7
log
@Add disklabel-style editing for size/offset values in
the partition tables. These values may now contain units,
such as "300k" "500M" or "2G".
(sectors, bytes, and cylinders are also supported.)
This should largely eliminate the need for a calculator
when using fdisk on large disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.6 1997/10/19 23:30:48 deraadt Exp $	*/
d43 19
@


1.6
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.5 1997/10/19 23:29:37 deraadt Exp $	*/
d38 1
d40 1
d175 134
@


1.5
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.4 1997/10/16 02:29:54 deraadt Exp $	*/
d101 1
a101 1
		if(cp == lbuf)
d103 1
a103 1
		if(*cp != '\0') {
d106 1
a106 1
		} else if(num < low || num > high) {
d111 1
a111 1
	return(num);
@


1.4
log
@only help if possible
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.3 1997/10/16 01:47:11 deraadt Exp $	*/
d49 1
a49 1
	if(fgets(lbuf, sizeof lbuf, stdin) == NULL)
d62 1
a62 1
	return(0);
d127 1
a127 1
	if(ch == EOF || first == EOF)
d130 1
a130 1
	return(first == 'y' || first == 'Y');
d139 1
a139 1
	return cp[0] | (cp[1] << 8);
d159 1
a159 1
	return cp[0] | (cp[1] << 8) | (cp[2] << 16) | (cp[3] << 24);
a173 1

@


1.3
log
@a bunch of improvements by weingart & I
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.2 1997/09/29 23:33:37 mickey Exp $	*/
d91 1
a91 1
		if (lbuf[0] == '?') {
@


1.2
log
@ID in the first line w/ tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.1 1997/09/29 22:58:17 weingart Exp $	*/
d66 1
a66 1
ask_num(str, flags, dflt, low, high)
d72 1
d78 1
d80 1
a80 1
		if(flags == ASK_HEX)
d84 2
d91 5
d103 1
a103 1
		if(*cp != '\0'){
d106 1
a106 1
		}else if(num < low || num > high){
d109 1
a109 1
	} while(num < low || num > high);
@


1.1
log
@New fdisk code with interactive (command line type)
editing code.  Rewrite from the ground up, save about
20 lines of code.  Seems to create valid partition
tables on i386 and alphas.
@
text
@d1 1
a1 2

/* $OpenBSD$ */
@
