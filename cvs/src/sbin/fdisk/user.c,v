head	1.50;
access;
symbols
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.8
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.10
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.6
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.8
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.10
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.8
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.6
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.8
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11;
locks; strict;
comment	@ * @;


1.50
date	2016.01.09.18.10.57;	author krw;	state Exp;
branches;
next	1.49;
commitid	ptrgnU3nbXhej2kY;

1.49
date	2015.12.11.21.57.31;	author krw;	state Exp;
branches;
next	1.48;
commitid	96L1vk3QTF4FoRGz;

1.48
date	2015.11.19.16.14.08;	author krw;	state Exp;
branches;
next	1.47;
commitid	07Axfimkfyb7znjO;

1.47
date	2015.11.18.02.12.51;	author krw;	state Exp;
branches;
next	1.46;
commitid	HcmflIIHWsz3htQf;

1.46
date	2015.11.13.02.27.17;	author krw;	state Exp;
branches;
next	1.45;
commitid	4K9a6NDKqAi1JXz9;

1.45
date	2015.10.26.15.08.26;	author krw;	state Exp;
branches;
next	1.44;
commitid	fOI5D0M32zdW7eoe;

1.44
date	2015.04.02.18.00.55;	author krw;	state Exp;
branches;
next	1.43;
commitid	IwHCZszuGuX6jauK;

1.43
date	2015.03.26.14.08.12;	author krw;	state Exp;
branches;
next	1.42;
commitid	2pp42lVbpnraZMs8;

1.42
date	2015.03.18.14.46.59;	author krw;	state Exp;
branches;
next	1.41;
commitid	9oRFFmwrkHklH7n4;

1.41
date	2015.03.17.21.42.15;	author krw;	state Exp;
branches;
next	1.40;
commitid	XLe2uvrVSjySe36w;

1.40
date	2015.03.16.23.51.50;	author krw;	state Exp;
branches;
next	1.39;
commitid	JG85Pc2Xt4lLAJpr;

1.39
date	2015.03.16.18.45.51;	author krw;	state Exp;
branches;
next	1.38;
commitid	mp8WjRkElVZwIbfW;

1.38
date	2015.03.14.18.32.29;	author krw;	state Exp;
branches;
next	1.37;
commitid	VCsOzs6eGW0SpJ6c;

1.37
date	2015.03.14.15.21.53;	author krw;	state Exp;
branches;
next	1.36;
commitid	aPXwn1AfAIMw4FVu;

1.36
date	2015.02.09.04.27.15;	author krw;	state Exp;
branches;
next	1.35;
commitid	hdzyTUV8r2DhhgJ1;

1.35
date	2014.03.31.22.03.29;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.20.13.18.21;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.17.16.40.00;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2014.03.17.13.15.44;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2014.03.14.15.41.33;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.13.12.02.28;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2014.03.10.21.40.58;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2014.03.09.22.25.06;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2014.03.07.21.56.13;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.21.18.45.58;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2011.02.21.19.26.13;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.08.18.03.18;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.27.04.06.13;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.19.15.48.20;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.01.13.19;	author weingart;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.22.08.21.02;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.18.08.38.26;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.15.02.12.26;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.01.21.05.34;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.12.00.17.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.09.14.03.54.35;	author rahnds;	state Exp;
branches;
next	1.13;

1.13
date	98.09.08.11.03.16;	author pefo;	state Exp;
branches;
next	1.12;

1.12
date	97.12.23.23.53.02;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.10.21.22.49.35;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.10.19.23.29.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.17.08.07.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.16.10.35.06;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.16.01.47.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.02.14.58.31;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.02.14.55.30;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.09.30.00.02.54;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.09.29.23.33.40;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.09.29.23.28.26;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.09.29.22.58.19;	author weingart;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Revamp the display of GPT information, hiding less important
information under the '-v' flag. This brings the GPT display more
into line with the MBR display and simplifies and hardens the parsing
of the partition info in the install scripts.

Original problem with install scripts parsing hand edited GPT
information reported by Valere Monseur via bugs@@.

Man page fixes and tweaks from jmc@@.
Install script changes tested & ok rpe@@.
@
text
@/*	$OpenBSD: user.c,v 1.49 2015/12/11 21:57:31 krw Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/fcntl.h>
#include <sys/disklabel.h>

#include <err.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "part.h"
#include "mbr.h"
#include "misc.h"
#include "cmd.h"
#include "user.h"
#include "gpt.h"

/* Our command table */
struct cmd cmd_table[] = {
	{"help",   1, Xhelp,   "Command help list"},
	{"manual", 1, Xmanual, "Show entire OpenBSD man page for fdisk"},
	{"reinit", 1, Xreinit, "Re-initialize loaded MBR (to defaults)"},
	{"setpid", 1, Xsetpid, "Set the identifier of a given table entry"},
	{"disk",   0, Xdisk,   "Edit current drive stats"},
	{"edit",   1, Xedit,   "Edit given table entry"},
	{"flag",   1, Xflag,   "Flag given table entry as bootable"},
	{"update", 0, Xupdate, "Update machine code in loaded MBR"},
	{"select", 0, Xselect, "Select extended partition table entry MBR"},
	{"swap",   1, Xswap,   "Swap two partition entries"},
	{"print",  1, Xprint,  "Print loaded MBR partition table"},
	{"write",  1, Xwrite,  "Write loaded MBR to disk"},
	{"exit",   1, Xexit,   "Exit edit of current MBR, without saving changes"},
	{"quit",   1, Xquit,   "Quit edit of current MBR, saving current changes"},
	{"abort",  1, Xabort,  "Abort program without saving current changes"},
	{NULL,     0, NULL,    NULL}
};


int modified;

void
USER_edit(off_t offset, off_t reloff)
{
	static int editlevel;
	struct dos_mbr dos_mbr;
	struct mbr mbr;
	char *cmd, *args;
	int i, st, error;

	/* One level deeper */
	editlevel += 1;

	/* Read MBR & partition */
	error = MBR_read(offset, &dos_mbr);
	if (error == -1)
		goto done;

	/* Parse the sucker */
	MBR_parse(&dos_mbr, offset, reloff, &mbr);

	if (editlevel == 1) {
		memset(&gh, 0, sizeof(gh));
		memset(&gp, 0, sizeof(gp));
		if (MBR_protective_mbr(&mbr) == 0)
			GPT_get_gpt(0);
	}

	printf("Enter 'help' for information\n");

	/* Edit cycle */
again:
	do {
		printf("fdisk:%c%d> ", (modified)?'*':' ', editlevel);
		fflush(stdout);
		ask_cmd(&cmd, &args);

		if (cmd[0] == '\0')
			continue;
		for (i = 0; cmd_table[i].cmd != NULL; i++)
			if (strstr(cmd_table[i].cmd, cmd) == cmd_table[i].cmd)
				break;

		/* Quick hack to put in '?' == 'help' */
		if (!strcmp(cmd, "?"))
			i = 0;

		/* Check for valid command */
		if ((cmd_table[i].cmd == NULL) || (letoh64(gh.gh_sig) ==
		    GPTSIGNATURE && cmd_table[i].gpt == 0)) {
			printf("Invalid command '%s'.  Try 'help'.\n", cmd);
			continue;
		}

		/* Call function */
		st = cmd_table[i].fcn(args, &mbr);

		/* Update status */
		if (st == CMD_EXIT)
			break;
		if (st == CMD_SAVE)
			break;
		if (st == CMD_CLEAN)
			modified = 0;
		if (st == CMD_DIRTY)
			modified = 1;
	} while (1);

	/* Write out MBR */
	if (modified) {
		if (st == CMD_SAVE) {
			if (Xwrite(NULL, &mbr) == CMD_CONT)
				goto again;
		} else
			printf("Aborting changes to current MBR.\n");
	}

done:
	/* One level less */
	editlevel -= 1;
}

void
USER_print_disk(int verbosity)
{
	off_t offset, firstoff;
	int i, error;
	struct dos_mbr dos_mbr;
	struct mbr mbr;

	offset = firstoff = 0;

	do {
		error = MBR_read(offset, &dos_mbr);
		if (error == -1)
			break;
		MBR_parse(&dos_mbr, offset, firstoff, &mbr);
		if (offset == 0) {
		       if (verbosity || MBR_protective_mbr(&mbr) == 0) {
				if (verbosity) {
					printf("Primary GPT:\n");
					GPT_get_gpt(1); /* Get Primary */
				}
				if (letoh64(gh.gh_sig) == GPTSIGNATURE)
					GPT_print("s", verbosity);
				else
					printf("\tNot Found\n");
				if (verbosity) {
					printf("\n");
					printf("Secondary GPT:\n");
					GPT_get_gpt(2); /* Get Secondary */
					if (letoh64(gh.gh_sig) == GPTSIGNATURE)
						GPT_print("s", verbosity);
					else
						printf("\tNot Found\n");
					printf("\nMBR:\n");
				} else
					break;
		       }
		}

		MBR_print(&mbr, NULL);

		/* Print out extended partitions too */
		for (offset = i = 0; i < 4; i++)
			if (mbr.part[i].id == DOSPTYP_EXTEND ||
			    mbr.part[i].id == DOSPTYP_EXTENDL) {
				offset = (off_t)mbr.part[i].bs;
				if (firstoff == 0)
					firstoff = offset;
			}
	} while (offset);
}
@


1.49
log
@Add '-v' flag that forces the display of both GPT's and the MBR.
Useful for seeing exactly what is currently on the disk. Suggested
by a request from kettenis@@.

Man page & usage ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.48 2015/11/19 16:14:08 krw Exp $	*/
d161 1
a161 1
					GPT_print("s");
d169 1
a169 1
						GPT_print("s");
@


1.48
log
@Reduce overburden of unnecessary #include's. Note that param.h is
included only for DEV_BSIZE.  Use INT64_MAX instead of LLONG_MAX
so stdint.h is enough.  General tidying up of #include sections.

ok GCC
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.47 2015/11/18 02:12:51 krw Exp $	*/
d82 1
a82 1
			GPT_get_gpt();
d140 1
a140 1
USER_print_disk(void)
d154 22
a175 5
		if (offset == 0 && MBR_protective_mbr(&mbr) == 0) {
			if (letoh64(gh.gh_sig) == GPTSIGNATURE) {
				GPT_print("s");
				break;
			}
@


1.47
log
@USER_edit() (a.k.a. -e) edits the on-disk information. So zap GPT
and re-read it from disk if appropriate. i.e. when the re-read MBR
is a protective MBR.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.46 2015/11/13 02:27:17 krw Exp $	*/
d22 1
@


1.46
log
@Move from opening/closing disk for every i/o to opening the disk once
and saving the fd in the global 'disk' structure. Stop passing around
fd's and just use the global.

Makes pledge() feasible.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.45 2015/10/26 15:08:26 krw Exp $	*/
d76 7
@


1.45
log
@Add GPT editing. Based on GSOC 2014 work by Markus Muller.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.44 2015/04/02 18:00:55 krw Exp $	*/
a26 1
#include "disk.h"
d64 1
a64 1
	int i, st, fd, error;
d70 1
a70 3
	fd = DISK_open(disk.name, O_RDONLY);
	error = MBR_read(fd, offset, &dos_mbr);
	close(fd);
a121 1
			close(fd);
d135 1
a135 1
	int fd, i, error;
a138 1
	fd = DISK_open(disk.name, O_RDONLY);
d142 1
a142 1
		error = MBR_read(fd, offset, &dos_mbr);
a163 4

	error = close(fd);
	if (error == -1)
		err(1, "Unable to close disk");
@


1.44
log
@Don't printf("offset: ...) before every call to MBR_print(). Do it
once inside MBR_print().
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.43 2015/03/26 14:08:12 krw Exp $	*/
d33 1
d37 16
a52 16
	{"help",   Xhelp,	"Command help list"},
	{"manual", Xmanual,	"Show entire OpenBSD man page for fdisk"},
	{"reinit", Xreinit,	"Re-initialize loaded MBR (to defaults)"},
	{"setpid", Xsetpid,	"Set the identifier of a given table entry"},
	{"disk",   Xdisk,	"Edit current drive stats"},
	{"edit",   Xedit,	"Edit given table entry"},
	{"flag",   Xflag,	"Flag given table entry as bootable"},
	{"update", Xupdate,	"Update machine code in loaded MBR"},
	{"select", Xselect,	"Select extended partition table entry MBR"},
	{"swap",   Xswap,	"Swap two partition entries"},
	{"print",  Xprint,	"Print loaded MBR partition table"},
	{"write",  Xwrite,	"Write loaded MBR to disk"},
	{"exit",   Xexit,	"Exit edit of current MBR, without saving changes"},
	{"quit",   Xquit,	"Quit edit of current MBR, saving current changes"},
	{"abort",  Xabort,	"Abort program without saving current changes"},
	{NULL,     NULL,	NULL}
d100 2
a101 1
		if (cmd_table[i].cmd == NULL) {
a145 2
	DISK_printgeometry(NULL);

d151 6
@


1.43
log
@Expand internal representation of partition starting LBA and size
to 64 bits, adjusting printf()'s, etc. as required. Preparing for
GPT partitions. Add 't' size unit. No other intentional functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.42 2015/03/18 14:46:59 krw Exp $	*/
a151 1
		printf("Offset: %lld\t", (long long)offset);
@


1.42
log
@Stop passing around little used 'struct mbr tt' parameter.  Just
make the initial mbr that tt pointed at a global that can be directly
accessed in the couple of places it is needed.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.41 2015/03/17 21:42:15 krw Exp $	*/
d152 1
a152 1
		printf("Offset: %lld\t", offset);
@


1.41
log
@Stop passing around little used and superfluous 'offset' parameter.
Just use the offset recorded/parsed in the struct mbr being used.

Can still traverse/edit extended MBRs so offset really wasn't needed.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.40 2015/03/16 23:51:50 krw Exp $	*/
d58 1
a58 1
USER_edit(struct mbr *tt, off_t offset, off_t reloff)
d105 1
a105 1
		st = cmd_table[i].fcn(args, &mbr, tt);
d121 1
a121 1
			if (Xwrite(NULL, &mbr, NULL) == CMD_CONT)
@


1.40
log
@Stop passing around a pointer to the stack variable 'disk' in main().
There is only one disk being worked on, so just make it a global.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.39 2015/03/16 18:45:51 krw Exp $	*/
d105 1
a105 1
		st = cmd_table[i].fcn(args, &mbr, tt, offset);
d121 1
a121 1
			if (Xwrite(NULL, &mbr, NULL, offset) == CMD_CONT)
@


1.39
log
@Document that -i/-u are mutually exclusive and clean up the related
code a bit.

ok deraadt@@ igor@@ (with suggested tweak that is coming)
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.38 2015/03/14 18:32:29 krw Exp $	*/
d58 1
a58 1
USER_edit(struct disk *disk, struct mbr *tt, off_t offset, off_t reloff)
d70 1
a70 1
	fd = DISK_open(disk->name, O_RDONLY);
d77 1
a77 1
	MBR_parse(disk, &dos_mbr, offset, reloff, &mbr);
d105 1
a105 1
		st = cmd_table[i].fcn(args, disk, &mbr, tt, offset);
d121 1
a121 1
			if (Xwrite(NULL, disk, &mbr, NULL, offset) == CMD_CONT)
d134 1
a134 1
USER_print_disk(struct disk *disk)
d141 1
a141 1
	fd = DISK_open(disk->name, O_RDONLY);
d144 1
a144 1
	DISK_printgeometry(disk, NULL);
d150 1
a150 1
		MBR_parse(disk, &dos_mbr, offset, firstoff, &mbr);
@


1.38
log
@Whitespace & KNF tweaks. Change functions whose return values are
not checked to void. Use continue inside a do loop instead of a
goto to the top. Move a #define/#undef more local to use. Eliminate
some lint.

General cleanup of things noticed preparing the big churn.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.37 2015/03/14 15:21:53 krw Exp $	*/
a53 16
void
USER_init(struct disk *disk, struct mbr *tt, int preserve)
{
	char *query;

	if (preserve) {
		MBR_pcopy(disk, tt);
		query = "Do you wish to write new MBR?";
	} else {
		MBR_init(disk, tt);
		query = "Do you wish to write new MBR and partition table?";
	}

	if (ask_yn(query))
		Xwrite(NULL, disk, tt, NULL, 0);
}
@


1.37
log
@Switch all the license blocks to the standard OpenBSD/ISC license.

With the permission of Toby.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.36 2015/02/09 04:27:15 krw Exp $	*/
d22 1
d54 1
a54 1
int
d68 1
a68 3
		Xwrite(NULL, disk, tt, NULL, 0); 

	return (0);
d73 1
a73 1
int
d98 1
a99 1
again:
d105 1
a105 1
			goto again;
d137 1
a137 1
			if (Xwrite(NULL, disk, &mbr, NULL, offset) == CMD_CONT) 
a146 2

	return (0);
d149 1
a149 1
int
d181 3
a183 1
	return (close(fd));
@


1.36
log
@Rename 'm_flag' to 'e_flag' since it's '-e' that sets it. Rename
'User_modify' to 'USER_edit' for the same reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.35 2014/03/31 22:03:29 krw Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.35
log
@Whitespace rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.34 2014/03/20 13:18:21 krw Exp $	*/
d84 1
a84 1
USER_modify(struct disk *disk, struct mbr *tt, off_t offset, off_t reloff)
@


1.34
log
@Add back various #includes of err.h, unistd.h, ctype.h, ioctl.h to
eliminate multiple 'implicit' declarations introduced by the previous
over-zealous #include cleanup.

Thanks to to tedu@@ for pointing out how -Wall reveals all.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.33 2014/03/17 16:40:00 krw Exp $	*/
a61 1

a194 1

@


1.33
log
@Nuke pointless blank lines, defines, comments and casts. Eliminate
#include in *.h files in favour of listing them as required in the *.c
files. Fix error message to correctly state that 64 is the minimum
value for -l. Use errx() where errno is not relevant. Use 'continue'
rather than a label to go back to start of a loop.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.32 2014/03/17 13:15:44 krw Exp $	*/
d33 1
@


1.32
log
@Un-revert, being careful to not break snap building. Add paranoia check
for any missing geometry.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.31 2014/03/14 15:41:33 krw Exp $	*/
a33 1
#include "user.h"
d35 2
a37 1
#include "mbr.h"
d39 1
a39 1

@


1.31
log
@Revert last -- broke building snaps.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.30 2014/03/13 12:02:28 krw Exp $	*/
d172 1
a172 1
	DISK_printmetrics(disk, NULL);
@


1.30
log
@Merge 'struct DISK_metrics' and 'struct disk' into one, since we don't
need to record two sets of metric/geometry data. Use 'geometry'
instead of 'metrics' in names and comments. Eliminate
DISK_getmetrics().

While here, make 64 the minimal valid value for '-l' instead of 1. This
avoids the possibility of having 0 cylinders.

No intentional functional change.

Feedback & tweak from chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.29 2014/03/10 21:40:58 krw Exp $	*/
d172 1
a172 1
	DISK_printgeometry(disk, NULL);
@


1.29
log
@No need to pass the name of the command to the function that is
implementing that command, a pointer to the command arguments is the
only thing needed. No need to have a pointer to the command table in
every command, since there is only one table. No need for shiney new
stack space for every command name and arguments parsed, since we
don't recurse we can just use static memory.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.28 2014/03/09 22:25:06 krw Exp $	*/
d172 1
a172 1
	DISK_printmetrics(disk, NULL);
@


1.28
log
@Instead of passing around 'char buf[DEV_BSIZE]' buffers, pass around
'struct dos_mbr' variables, since that is what the buffers were used
for. Removes need to know about DEV_BSIZE and thus include param.h
from all files but one so move the param.h #include to that file
(mbr.c).

Nuke a bunch of local MBR #defines in favour of the disklabel.h ones.

Remove a bunch of unneeded #includes, replace the odd malloc/bzero
with calloc, replace equally odd bcopy's with memcpy, remove a stray
duplicate MBR parsing in MBR_pcopy().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.27 2014/03/07 21:56:13 krw Exp $	*/
d42 1
a42 1
static struct cmd_table cmd_table[] = {
d89 1
a89 1
	struct cmd cmd;
a94 3
	/* Set up command table pointer */
	cmd.table = cmd_table;

d112 1
a112 1
		ask_cmd(&cmd);
d114 1
a114 1
		if (cmd.cmd[0] == '\0')
d117 1
a117 1
			if (strstr(cmd_table[i].cmd, cmd.cmd)==cmd_table[i].cmd)
d121 1
a121 1
		if (!strcmp(cmd.cmd, "?"))
d126 1
a126 1
			printf("Invalid command '%s'.  Try 'help'.\n", cmd.cmd);
d128 1
a128 2
		} else
			strlcpy(cmd.cmd, cmd_table[i].cmd, sizeof cmd.cmd);
d131 1
a131 1
		st = cmd_table[i].fcn(&cmd, disk, &mbr, tt, offset);
@


1.27
log
@Relieve the code of an overburden of unnecessary typedef
abstraction. Call a 'struct' a 'struct' and not a pony.

No functional change.

idea ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.26 2013/03/21 18:45:58 deraadt Exp $	*/
a29 1
#include <sys/stat.h>
a30 3
#include <err.h>
#include <errno.h>
#include <util.h>
a31 1
#include <unistd.h>
d33 1
d87 1
a87 1
	char mbr_buf[DEV_BSIZE];
d100 1
a100 1
	error = MBR_read(fd, offset, mbr_buf);
d106 1
a106 1
	MBR_parse(disk, mbr_buf, offset, reloff, &mbr);
d170 1
a170 1
	char mbr_buf[DEV_BSIZE];
d179 1
a179 1
		error = MBR_read(fd, offset, mbr_buf);
d182 1
a182 1
		MBR_parse(disk, mbr_buf, offset, firstoff, &mbr);
@


1.26
log
@more substantial include cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.25 2011/02/21 19:26:13 krw Exp $	*/
d46 1
a46 1
static cmd_table_t cmd_table[] = {
d67 1
a67 1
USER_init(disk_t *disk, mbr_t *tt, int preserve)
d88 1
a88 1
USER_modify(disk_t *disk, mbr_t *tt, off_t offset, off_t reloff)
d92 2
a93 2
	mbr_t mbr;
	cmd_t cmd;
d170 1
a170 1
USER_print_disk(disk_t *disk)
d175 1
a175 1
	mbr_t mbr;
@


1.25
log
@Honour MBR_read() results and don't pretend we can parse blocks we
did not successfully read. Tweak some casts.

Fixes infinite loop problem noted by jeremy@@ while installing on
boxen with 'random' garbage in MBR. General loop detection may
follow post-4.9.

Tested by jeremy@@ and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.24 2009/02/08 18:03:18 krw Exp $	*/
d28 4
a37 5
#include <sys/fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <machine/param.h>
@


1.24
log
@Eliminate excessive verbiage for 'fdisk -i' and 'fdisk -u'. Especially
the multi-line banner announcing that the MBR is being changed.
Also the listing of the partition table in 'fdisk -u'. Display a
consistant message when the MBR is written.

While here cleanup and shrink code without changing any semantics.
Started with a diff posted on tech@@ by Tobias Ulmer.

"I like it" marco@@ ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.23 2006/07/27 04:06:13 ray Exp $	*/
d95 1
a95 1
	int i, st, fd;
d105 1
a105 1
	MBR_read(fd, offset, mbr_buf);
d107 2
d163 1
d173 2
a174 1
	int fd, offset, firstoff, i;
d184 3
a186 1
		MBR_read(fd, (off_t)offset, mbr_buf);
d189 1
a189 1
		printf("Offset: %d\t", (int)offset);
d196 1
a196 1
				offset = mbr.part[i].bs;
@


1.23
log
@Add checks to each write(2) attempt and try to keep fdisk in a
consistent state upon write failure.

OK krw@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.22 2005/01/19 15:48:20 deraadt Exp $	*/
d70 1
a70 4
	int fd, yn;
	char mbr_buf[DEV_BSIZE];
	char *msgp = "\nDo you wish to write new MBR?";
	char *msgk = "\nDo you wish to write new MBR and partition table?";
d72 1
a72 1
	if (preserve)
d74 2
a75 1
	else
d77 2
d80 2
a81 22
	/* Write sector 0 */
	printf("\a\n"
	   "\t-----------------------------------------------------\n"
	   "\t------ ATTENTION - UPDATING MASTER BOOT RECORD ------\n"
	   "\t-----------------------------------------------------\n");
	if (preserve)
		yn = ask_yn(msgp);
	else
		yn = ask_yn(msgk);

	if (yn) {
		fd = DISK_open(disk->name, O_RDWR);
		MBR_make(tt, mbr_buf);
		if (MBR_write(fd, 0, mbr_buf) == -1) {
			int saved_errno = errno;
			DISK_close(fd);
			errno = saved_errno;
			return (-1);
		}
		DISK_close(fd);
	} else
		printf("MBR is unchanged\n");
d106 1
a106 1
	DISK_close(fd);
d154 1
a154 6
			printf("Writing current MBR to disk.\n");
			fd = DISK_open(disk->name, O_RDWR);
			MBR_make(&mbr, mbr_buf);
			if (MBR_write(fd, offset, mbr_buf) == -1) {
				warn("error writing MBR");
				close(fd);
a155 1
			}
d196 1
a196 1
	return (DISK_close(fd));
@


1.22
log
@add a swap primitive; ok various, will be polished after by tom
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.21 2003/06/11 06:22:12 deraadt Exp $	*/
d29 1
d93 6
a98 1
		MBR_write(fd, (off_t)0, mbr_buf);
d177 5
a181 1
			MBR_write(fd, offset, mbr_buf);
@


1.21
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.20 2003/06/03 01:13:19 weingart Exp $	*/
d56 1
@


1.20
log
@Nuke terms 3 & 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.19 2002/05/22 08:21:02 deraadt Exp $	*/
d66 1
a66 4
USER_init(disk, tt, preserve)
	disk_t *disk;
	mbr_t *tt;
	int preserve;
d102 1
a102 5
USER_modify(disk, tt, offset, reloff)
	disk_t *disk;
	mbr_t *tt;
	off_t offset;
	off_t reloff;
d183 1
a183 2
USER_print_disk(disk)
	disk_t *disk;
@


1.19
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.18 2002/01/18 08:38:26 kjell Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@Allow size values to be displayed in the user's choice of units.
Idea borrowed from disklabel. i.e. Users can now type "print M"
and be rewarded with partition sizes in Megs
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.17 2001/12/15 02:12:26 kjell Exp $	*/
d160 1
a160 1
			strcpy(cmd.cmd, cmd_table[i].cmd);
@


1.17
log
@Get this damn diff out of my tree. ok from weingart@@, deraadt@@ and others.
Add a -u flag to fdisk which updates MBR code, but leaves the partition
table intact. There are still issues with 'update' having different behavior,
but I'll resolve those shortly
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.16 2001/01/01 21:05:34 angelos Exp $	*/
d205 1
a205 1
	DISK_printmetrics(disk);
d212 1
a212 1
		MBR_print(&mbr);
@


1.16
log
@New command "setpid", just changes the ID of a partition (no other
parameters editing) -- vassilip@@dsl.cis.upenn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.15 2000/09/12 00:17:47 deraadt Exp $	*/
d71 1
a71 1
USER_init(disk, tt)
d74 1
d76 1
a76 1
	int fd;
d78 2
d81 4
a84 1
	MBR_init(disk, tt);
d91 6
a96 1
	if (ask_yn("\nDo you wish to write new MBR?")) {
@


1.15
log
@handle LBA extended partitions here too; scott@@nts.umn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.14 1998/09/14 03:54:35 rahnds Exp $	*/
d55 1
@


1.14
log
@Since on the powerpc, the system does not supply the user with
bios valid cyl,head,sector information (the information comes from the
sd driver) I have made some changes to fdisk to do the following.

Allow the powerpc to specify values larger than the bios limits.

All platforms now have code that will translate the LBA values
in the mbr into CHS values according to the disk geometry.
This occurs if the start and ending CHS values have been stored as
0xffffff.

If writing to the disk and one of the values of a partition violates
the bios limits, it writes the requested values in the LBA fields ,
and stores 0xffffff for the starting and ending CHS values.

This should not change the default formatting of any existing system
other than the CHS and LBA values should always match given the detected
geometry of the disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.13 1998/09/08 11:03:16 pefo Exp $	*/
d204 2
a205 1
			if (mbr.part[i].id == DOSPTYP_EXTEND) {
@


1.13
log
@For powerpc's we want to keep the preinstalled msdos partition in the init
MBR when doing a 'fdisk -i'. That is because the msdos partition is used
for booting. The OpenBSD part (part 3) is set up to be the rest of the
disk. Also the msdos partition is set as the 'active' partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.12 1997/12/23 23:53:02 deraadt Exp $	*/
d77 2
a78 30
	/* Fix up given mbr for this disk */
	tt->part[0].flag = 0;
	tt->part[1].flag = 0;
	tt->part[2].flag = 0;
	tt->part[3].flag = DOSACTIVE;
	tt->signature = DOSMBR_SIGNATURE;

	/* Use whole disk, save for first head, on first cyl. */
	tt->part[3].id = DOSPTYP_OPENBSD;
	tt->part[3].scyl = 0;
	tt->part[3].shead = 1;
	tt->part[3].ssect = 1;

	/* Go right to the end */
	tt->part[3].ecyl = disk->real->cylinders;
	tt->part[3].ehead = disk->real->heads;
	tt->part[3].esect = disk->real->sectors;

	/* Fix up start/length fields */
	PRT_fix_BN(disk, &tt->part[3]);

#if defined(__powerpc__)
	/* Now fix up for the MS-DOS boot partition on PowerPC. */
	tt->part[0].flag = DOSACTIVE;  /* Boot from dos part */
	tt->part[3].flag = 0;
	tt->part[3].ns += tt->part[3].bs;
	tt->part[3].bs = tt->part[0].bs + tt->part[0].ns;
	tt->part[3].ns -= tt->part[3].bs;
	PRT_fix_CHS(disk, &tt->part[3]);
#endif
d122 1
a122 1
	MBR_parse(mbr_buf, offset, reloff, &mbr);
d197 1
a197 1
		MBR_parse(mbr_buf, offset, firstoff, &mbr);
@


1.12
log
@swap exit and quit
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.11 1997/10/21 22:49:35 provos Exp $	*/
d98 9
@


1.11
log
@make fdisk grok extended partitions again. we have to keep track of the
absolute offset of the current mbr and its relative position. because:
the starting sector of the first mbr entry in an extended partition is relative
to the starting offset of the whole mbr itself. the starting offset of a new
extended partition is relative to the offset of the very first extended
partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.10 1997/10/19 23:29:38 deraadt Exp $	*/
d62 2
a63 2
	{"exit",   Xexit,	"Exit edit of current MBR, saving current changes"},
	{"quit",   Xquit,	"Quit edit of current MBR, without saving changes"},
@


1.10
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.9 1997/10/17 08:07:15 deraadt Exp $	*/
d117 1
a117 1
USER_modify(disk, tt, offset)
d120 2
a121 1
	int offset;
d141 1
a141 1
	MBR_parse(mbr_buf, &mbr);
d205 1
a205 1
	int fd, offset, i;
d210 1
a210 1
	offset = 0;
d216 1
a216 1
		MBR_parse(mbr_buf, &mbr);
d223 1
a223 1
			if (mbr.part[i].id == DOSPTYP_EXTEND)
d225 3
@


1.9
log
@no input does not do stupid auto help
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.8 1997/10/16 10:35:06 deraadt Exp $	*/
d103 1
a103 1
	if(ask_yn("\nDo you wish to write new MBR?")){
d111 1
a111 1
	return(0);
a127 1

d153 2
a154 2
		for(i = 0; cmd_table[i].cmd != NULL; i++)
			if(strstr(cmd_table[i].cmd, cmd.cmd)==cmd_table[i].cmd)
d158 1
a158 1
		if(!strcmp(cmd.cmd, "?"))
d162 1
a162 1
		if(cmd_table[i].cmd == NULL){
d165 1
a165 1
		}else
d172 9
a180 5
		if(st == CMD_EXIT) break;
		if(st == CMD_SAVE) break;
		if(st == CMD_CLEAN) modified = 0;
		if(st == CMD_DIRTY) modified = 1;
	} while(1);
d183 2
a184 2
	if(modified){
		if(st == CMD_SAVE){
d190 1
a190 1
		}else
d197 1
a197 1
	return(0);
d221 2
a222 2
		for(offset = i = 0; i < 4; i++)
			if(mbr.part[i].id == DOSPTYP_EXTEND)
d224 1
a224 1
	} while(offset);
d226 1
a226 1
	return(DISK_close(fd));
@


1.8
log
@new command: manual
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.7 1997/10/16 01:47:13 deraadt Exp $	*/
d147 1
d152 2
@


1.7
log
@a bunch of improvements by weingart & I
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.6 1997/10/02 14:58:31 deraadt Exp $	*/
d53 1
@


1.6
log
@do not whine if user quits without mods
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.5 1997/10/02 14:55:30 deraadt Exp $	*/
d53 1
a53 1
	{"init",   Xinit,	"Initialize loaded MBR"},
d61 3
a63 2
	{"exit",   Xexit,	"Exit current level of fdisk edit"},
	{"quit",   Xquit,	"Quit program without saving current changes"},
d90 3
a92 3
	tt->part[3].ecyl = disk->bios->cylinders;
	tt->part[3].ehead = disk->bios->heads;
	tt->part[3].esect = disk->bios->sectors;
d121 1
d128 3
d146 1
a146 1
		printf("fdisk:%c%d> ", (modified)?'*':' ', offset);
d170 1
d177 2
a178 5
		printf("\a\n"
		   "\t-----------------------------------------------------\n"
		   "\t--- ATTENTION - PARTITION TABLE HAS BEEN MODIFIED ---\n"
		   "\t-----------------------------------------------------\n");
		if(ask_yn("\nDo you wish to write before exit?")){
d183 2
a184 1
		}
d187 3
a203 1
	printf("Disk: %s\n", disk->name);
d210 1
a210 1
		printf("\nDisk offset: %d\n", (int)offset);
@


1.5
log
@tell user about "help"
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.4 1997/09/30 00:02:54 mickey Exp $	*/
d112 2
d123 1
a123 1
	int i, st, fd, modified = 0;
@


1.4
log
@ask permission to write new MBR
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.3 1997/09/29 23:33:40 mickey Exp $	*/
d135 1
@


1.3
log
@ID in the first line w/ tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: user.c,v 1.2 1997/09/29 23:28:26 mickey Exp $	*/
d97 11
a107 4
	fd = DISK_open(disk->name, O_RDWR);
	MBR_make(tt, mbr_buf);
	MBR_write(fd, (off_t)0, mbr_buf);
	DISK_close(fd);
d166 1
a166 2

	/* XXX - Write out MBR */
@


1.2
log
@don't exseed 80 columns; bell on important warning
@
text
@d1 1
a1 2

/* $OpenBSD: user.c,v 1.1 1997/09/29 22:58:19 weingart Exp $ */
@


1.1
log
@New fdisk code with interactive (command line type)
editing code.  Rewrite from the ground up, save about
20 lines of code.  Seems to create valid partition
tables on i386 and alphas.
@
text
@d2 1
a2 1
/* $OpenBSD$ */
d53 12
a64 12
	{"help",	Xhelp,		"Command help list"},
	{"init",	Xinit,		"Initialize loaded MBR"},
	{"disk",	Xdisk,		"Edit current drive stats"},
	{"edit",	Xedit,		"Edit given table entry"},
	{"flag",	Xflag,		"Flag given table entry as bootable"},
	{"update",	Xupdate,	"Update machine code in loaded MBR"},
	{"select",	Xselect,	"Select extended partition table entry MBR"},
	{"print",	Xprint,		"Print loaded MBR partition table"},
	{"write",	Xwrite,		"Write loaded MBR to disk"},
	{"exit",	Xexit,		"Exit current level of fdisk edit"},
	{"quit",	Xquit,		"Quit program without saving current changes"},
	{NULL,		NULL,		NULL}
d137 1
a137 1
			if(strstr(cmd_table[i].cmd, cmd.cmd) == cmd_table[i].cmd)
d163 4
a166 4
		printf("\n");
		printf("\t-----------------------------------------------------\n");
		printf("\t--- ATTENTION - PARTITION TABLE HAS BEEN MODIFIED ---\n");
		printf("\t-----------------------------------------------------\n");
@
