head	1.55;
access;
symbols
	OPENBSD_6_2_BASE:1.55
	OPENBSD_6_1:1.55.0.6
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.4
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.29.0.4
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.6
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.9.0.10
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9;
locks; strict;
comment	@ * @;


1.55
date	2016.03.09.12.55.18;	author krw;	state Exp;
branches;
next	1.54;
commitid	SWFYnoNef7ocZrss;

1.54
date	2015.12.12.02.49.50;	author krw;	state Exp;
branches;
next	1.53;
commitid	oF2xrlPNdHxVB5pd;

1.53
date	2015.12.01.06.29.13;	author krw;	state Exp;
branches;
next	1.52;
commitid	sQxIFpcCYgKayy6a;

1.52
date	2015.11.19.16.14.08;	author krw;	state Exp;
branches;
next	1.51;
commitid	07Axfimkfyb7znjO;

1.51
date	2015.11.14.21.17.08;	author krw;	state Exp;
branches;
next	1.50;
commitid	AZ3aaJIF3rj1GOvz;

1.50
date	2015.11.13.02.27.17;	author krw;	state Exp;
branches;
next	1.49;
commitid	4K9a6NDKqAi1JXz9;

1.49
date	2015.11.11.15.39.18;	author krw;	state Exp;
branches;
next	1.48;
commitid	NAurcNtvybUXnVMU;

1.48
date	2015.08.27.20.58.27;	author krw;	state Exp;
branches;
next	1.47;
commitid	HPfwzWhA0Lbc6ZGU;

1.47
date	2015.03.30.17.11.49;	author krw;	state Exp;
branches;
next	1.46;
commitid	PQWtQHYSt0QI2mGM;

1.46
date	2015.03.27.16.06.00;	author krw;	state Exp;
branches;
next	1.45;
commitid	AfQuszZYKfWc5CVd;

1.45
date	2015.03.16.23.51.50;	author krw;	state Exp;
branches;
next	1.44;
commitid	JG85Pc2Xt4lLAJpr;

1.44
date	2015.03.14.18.32.29;	author krw;	state Exp;
branches;
next	1.43;
commitid	VCsOzs6eGW0SpJ6c;

1.43
date	2015.03.14.15.21.53;	author krw;	state Exp;
branches;
next	1.42;
commitid	aPXwn1AfAIMw4FVu;

1.42
date	2014.03.31.22.03.29;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2014.03.20.13.18.21;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2014.03.17.16.40.00;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2014.03.17.13.15.44;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2014.03.14.15.41.33;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2014.03.13.12.02.28;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2014.03.09.22.25.06;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2014.03.07.21.56.13;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.21.18.45.58;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.11.13.24.29;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.05.21.39.09;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.30.22.53.41;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.08.18.03.18;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.27.11.42.44;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.26.22.42.11;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.10.19.19.32;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.19.20.17.12;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.18.03.42.23;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.21.01.59.24;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.03.09.23.11;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.11.09.17.36;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.02.21.44.57;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.01.13.19;	author weingart;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.11.21.23.28;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.25.22.13.13;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.18.08.38.26;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.23.01.54.37;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.21.22.47.53;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.18.22.40.15;	author kjell;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.08.04.51.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.28.10.06.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.26.00.47.05;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.22.23.41.15;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.10.19.23.30.46;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.19.23.29.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.16.01.47.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.04.00.15.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.09.29.23.33.34;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.09.29.22.58.15;	author weingart;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Accept only character special devices rather than generating a core
dump on the attempt to get a disklabel from a regular file.

Regular files have not been acceptable as the 'disk' for some time,
and pledging changed the consequences from a somewhat obscure error
message to an abort().

Issue discovered by espie@@.

ok natano@@
@
text
@/*	$OpenBSD: disk.c,v 1.54 2015/12/12 02:49:50 krw Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/stat.h>
#include <sys/disklabel.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <util.h>

#include "disk.h"
#include "misc.h"

struct disk disk;
struct disklabel dl;

void
DISK_open(int rw)
{
	struct stat st;
	u_int64_t sz, spc;

	disk.fd = opendev(disk.name, rw ? O_RDWR : O_RDONLY, OPENDEV_PART,
	    NULL);
	if (disk.fd == -1)
		err(1, "%s", disk.name);
	if (fstat(disk.fd, &st) == -1)
		err(1, "%s", disk.name);
	if (!S_ISCHR(st.st_mode))
		errx(1, "%s is not a character device", disk.name);

	/* Get label geometry. */
	if (ioctl(disk.fd, DIOCGPDINFO, &dl) == -1) {
		warn("DIOCGPDINFO");
	} else {
		unit_types[SECTORS].conversion = dl.d_secsize;
		if (disk.size == 0) {
			/* -l or -c/-h/-s not used. Use disklabel info. */
			disk.cylinders = dl.d_ncylinders;
			disk.heads = dl.d_ntracks;
			disk.sectors = dl.d_nsectors;
			/* MBR handles only first UINT32_MAX sectors. */
			spc = (u_int64_t)disk.heads * disk.sectors;
			sz = DL_GETDSIZE(&dl);
			if (sz > UINT32_MAX) {
				disk.cylinders = UINT32_MAX / spc;
				disk.size = disk.cylinders * spc;
			} else
				disk.size = sz;
		}
	}

	if (disk.size == 0 || disk.cylinders == 0 || disk.heads == 0 ||
	    disk.sectors == 0 || unit_types[SECTORS].conversion == 0)
		errx(1, "Can't get disk geometry, please use [-chs] or [-l]"
		    "to specify.");
}

/*
 * Print the disk geometry information. Take an optional modifier
 * to indicate the units that should be used for display.
 */
int
DISK_printgeometry(char *units)
{
	const int secsize = unit_types[SECTORS].conversion;
	double size;
	int i;

	i = unit_lookup(units);
	size = ((double)disk.size * secsize) / unit_types[i].conversion;
	printf("Disk: %s\t", disk.name);
	if (disk.size) {
		printf("geometry: %d/%d/%d [%.0f ", disk.cylinders,
		    disk.heads, disk.sectors, size);
		if (i == SECTORS && secsize != sizeof(struct dos_mbr))
			printf("%d-byte ", secsize);
		printf("%s]\n", unit_types[i].lname);
	} else
		printf("geometry: <none>\n");

	return (0);
}

/*
 * Read the sector at 'where' from the file descriptor 'fd' into newly
 * calloc'd memory. Return a pointer to the memory if it contains the
 * requested data, or NULL if it does not.
 *
 * The caller must free() the memory it gets.
 */
char *
DISK_readsector(off_t where)
{
	int secsize;
	char *secbuf;
	ssize_t len;
	off_t off;

	secsize = dl.d_secsize;

	where *= secsize;
	off = lseek(disk.fd, where, SEEK_SET);
	if (off != where)
		return (NULL);

	secbuf = calloc(1, secsize);
	if (secbuf == NULL)
		return (NULL);

	len = read(disk.fd, secbuf, secsize);
	if (len == -1 || len != secsize) {
		free(secbuf);
		return (NULL);
	}

	return (secbuf);
}

/*
 * Write the sector-sized 'secbuf' to the sector 'where' on the file
 * descriptor 'fd'. Return 0 if the write works. Return -1 and set
 * errno if the write fails.
 */
int
DISK_writesector(char *secbuf, off_t where)
{
	int secsize;
	ssize_t len;
	off_t off;

	len = -1;
	secsize = dl.d_secsize;

	where *= secsize;
	off = lseek(disk.fd, where, SEEK_SET);
	if (off == where)
		len = write(disk.fd, secbuf, secsize);

	if (len == -1 || len != secsize) {
		/* short read or write */
		errno = EIO;
		return (-1);
	}

	return (0);
}
@


1.54
log
@Open disk READONLY if none of i, e or u are specified.

Suggestion, original diff and ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.53 2015/12/01 06:29:13 krw Exp $	*/
d52 2
a53 3
	if (!S_ISCHR(st.st_mode) && !S_ISREG(st.st_mode))
		errx(1, "%s is not a character device or a regular file",
		    disk.name);
@


1.53
log
@Fix inexplicable use of 'disk' instead of 'disk.name' when trying to
print the disk's name in an error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.52 2015/11/19 16:14:08 krw Exp $	*/
d41 1
a41 1
DISK_open(void)
d46 2
a47 1
	disk.fd = opendev(disk.name, O_RDWR, OPENDEV_PART, NULL);
@


1.52
log
@Reduce overburden of unnecessary #include's. Note that param.h is
included only for DEV_BSIZE.  Use INT64_MAX instead of LLONG_MAX
so stdint.h is enough.  General tidying up of #include sections.

ok GCC
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.51 2015/11/14 21:17:08 krw Exp $	*/
d53 1
a53 1
		    disk);
@


1.51
log
@Since -l is ignored if -c/-h/-s are specified, make that combination
invalid and mention the constraint in usage(). Modify the appropriate
field(s) of the global 'disk' as -l/-c/-h/-s are encountered. As a
result use the disklabel information to populate the global 'disk'
only when it has not already been populated. Move test for 'disk'
validity into DISK_open().
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.50 2015/11/13 02:27:17 krw Exp $	*/
a22 1
#include <sys/stdint.h>
d25 1
a27 1
#include <util.h>
d29 1
d32 1
@


1.50
log
@Move from opening/closing disk for every i/o to opening the disk once
and saving the fd in the global 'disk' structure. Stop passing around
fd's and just use the global.

Makes pledge() feasible.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.49 2015/11/11 15:39:18 krw Exp $	*/
a57 11
		disk.cylinders = dl.d_ncylinders;
		disk.heads = dl.d_ntracks;
		disk.sectors = dl.d_nsectors;
		/* MBR handles only first UINT32_MAX sectors. */
		spc = (u_int64_t)disk.heads * disk.sectors;
		sz = DL_GETDSIZE(&dl);
		if (sz > UINT32_MAX) {
			disk.cylinders = UINT32_MAX / spc;
			disk.size = disk.cylinders * spc;
		} else
			disk.size = sz;
d59 14
d74 5
@


1.49
log
@Display full disk size when editing GPT, not the truncated MBR size. Display
'disk too large' message only when no GPT is found.

Problems found, fix tested and ok naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.48 2015/08/27 20:58:27 krw Exp $	*/
d39 2
a40 2
int
DISK_open(char *disk, int mode)
d43 1
a43 1
	int fd;
d45 5
a49 5
	fd = opendev(disk, mode, OPENDEV_PART, NULL);
	if (fd == -1)
		err(1, "%s", disk);
	if (fstat(fd, &st) == -1)
		err(1, "%s", disk);
a53 9
	return (fd);
}

void
DISK_getlabelgeometry(void)
{
	u_int64_t sz, spc;
	int fd;

d55 15
a69 18
	if ((fd = DISK_open(disk.name, O_RDONLY)) != -1) {
		if (ioctl(fd, DIOCGPDINFO, &dl) == -1) {
			warn("DIOCGPDINFO");
		} else {
			disk.cylinders = dl.d_ncylinders;
			disk.heads = dl.d_ntracks;
			disk.sectors = dl.d_nsectors;
			/* MBR handles only first UINT32_MAX sectors. */
			spc = (u_int64_t)disk.heads * disk.sectors;
			sz = DL_GETDSIZE(&dl);
			if (sz > UINT32_MAX) {
				disk.cylinders = UINT32_MAX / spc;
				disk.size = disk.cylinders * spc;
			} else
				disk.size = sz;
			unit_types[SECTORS].conversion = dl.d_secsize;
		}
		close(fd);
d107 1
a107 1
DISK_readsector(int fd, off_t where)
d117 1
a117 1
	off = lseek(fd, where, SEEK_SET);
d125 1
a125 1
	len = read(fd, secbuf, secsize);
d140 1
a140 1
DISK_writesector(int fd, char *secbuf, off_t where)
d150 1
a150 1
	off = lseek(fd, where, SEEK_SET);
d152 1
a152 1
		len = write(fd, secbuf, secsize);
@


1.48
log
@Nuke some trailing whitespace that keeps coming back.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.47 2015/03/30 17:11:49 krw Exp $	*/
a76 2
				warnx("disk too large (%llu sectors)."
				    " size truncated.", sz);
@


1.47
log
@Even better -- readsector() and writesector() become DISK_readsector() and
DISK_writesector() and live in disk.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.46 2015/03/27 16:06:00 krw Exp $	*/
d114 1
a114 1
 * Read the sector at 'where' from the file descriptor 'fd' into newly 
@


1.46
log
@Wrap some annoying long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.45 2015/03/16 23:51:50 krw Exp $	*/
d27 1
d109 64
@


1.45
log
@Stop passing around a pointer to the stack variable 'disk' in main().
There is only one disk being worked on, so just make it a global.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.44 2015/03/14 18:32:29 krw Exp $	*/
d50 2
a51 1
		errx(1, "%s is not a character device or a regular file", disk);
@


1.44
log
@Whitespace & KNF tweaks. Change functions whose return values are
not checked to void. Use continue inside a do loop instead of a
goto to the top. Move a #define/#undef more local to use. Eliminate
some lint.

General cleanup of things noticed preparing the big churn.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.43 2015/03/14 15:21:53 krw Exp $	*/
d35 1
d56 1
a56 1
DISK_getlabelgeometry(struct disk *disk)
d62 1
a62 1
	if ((fd = DISK_open(disk->name, O_RDONLY)) != -1) {
d66 3
a68 3
			disk->cylinders = dl.d_ncylinders;
			disk->heads = dl.d_ntracks;
			disk->sectors = dl.d_nsectors;
d70 1
a70 1
			spc = (u_int64_t)disk->heads * disk->sectors;
d73 2
a74 2
				disk->cylinders = UINT32_MAX / spc;
				disk->size = disk->cylinders * spc;
d78 1
a78 1
				disk->size = sz;
d90 1
a90 1
DISK_printgeometry(struct disk *disk, char *units)
d97 5
a101 5
	size = ((double)disk->size * secsize) / unit_types[i].conversion;
	printf("Disk: %s\t", disk->name);
	if (disk->size) {
		printf("geometry: %d/%d/%d [%.0f ", disk->cylinders,
		    disk->heads, disk->sectors, size);
@


1.43
log
@Switch all the license blocks to the standard OpenBSD/ISC license.

With the permission of Toby.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.42 2014/03/31 22:03:29 krw Exp $	*/
d40 1
a41 1
	struct stat st;
d50 1
@


1.42
log
@Whitespace rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.41 2014/03/20 13:18:21 krw Exp $	*/
d4 1
a4 2
 * Copyright (c) 1997, 2001 Tobias Weingartner
 * All rights reserved.
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.41
log
@Add back various #includes of err.h, unistd.h, ctype.h, ioctl.h to
eliminate multiple 'implicit' declarations introduced by the previous
over-zealous #include cleanup.

Thanks to to tedu@@ for pointing out how -Wall reveals all.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.40 2014/03/17 16:40:00 krw Exp $	*/
a116 1

@


1.40
log
@Nuke pointless blank lines, defines, comments and casts. Eliminate
#include in *.h files in favour of listing them as required in the *.c
files. Fix error message to correctly state that 64 is the minimum
value for -l. Use errx() where errno is not relevant. Use 'continue'
rather than a label to go back to start of a loop.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.39 2014/03/17 13:15:44 krw Exp $	*/
d30 1
d39 1
@


1.39
log
@Un-revert, being careful to not break snap building. Add paranoia check
for any missing geometry.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.38 2014/03/14 15:41:33 krw Exp $	*/
d56 1
a56 1
		err(1, "%s is not a character device or a regular file", disk);
@


1.38
log
@Revert last -- broke building snaps.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.37 2014/03/13 12:02:28 krw Exp $	*/
a43 2
struct DISK_metrics *DISK_getlabelmetrics(char *name);

d60 2
a61 7
/* Routine to go after the disklabel for geometry
 * information.  This should work everywhere, but
 * in the land of PC, things are not always what
 * they seem.
 */
struct DISK_metrics *
DISK_getlabelmetrics(char *name)
a62 1
	struct DISK_metrics *lm = NULL;
d66 2
a67 6
	/* Get label metrics */
	if ((fd = DISK_open(name, O_RDONLY)) != -1) {
		lm = malloc(sizeof(struct DISK_metrics));
		if (lm == NULL)
			err(1, NULL);

a69 2
			free(lm);
			lm = NULL;
d71 3
a73 3
			lm->cylinders = dl.d_ncylinders;
			lm->heads = dl.d_ntracks;
			lm->sectors = dl.d_nsectors;
d75 1
a75 1
			spc = (u_int64_t)lm->heads * lm->sectors;
d78 2
a79 2
				lm->cylinders = UINT32_MAX / spc;
				lm->size = lm->cylinders * spc;
d83 1
a83 1
				lm->size = sz;
a87 34

	return (lm);
}

/* This is ugly, and convoluted.  All the magic
 * for disk geo/size happens here.  Basically,
 * the real size is the one we will use in the
 * rest of the program, the label size is what we
 * got from the disklabel.  If the disklabel fails,
 * we assume we are working with a normal file,
 * and should request the user to specify the
 * geometry he/she wishes to use.
 */
int
DISK_getmetrics(struct disk *disk, struct DISK_metrics *user)
{

	disk->label = DISK_getlabelmetrics(disk->name);

	/* If user supplied, use that */
	if (user) {
		disk->real = user;
		return (0);
	}

	/* If we have a label, use that */
	if (disk->label) {
		disk->real = disk->label;
		return (0);
	}

	/* Can not get geometry, punt */
	disk->real = NULL;
	return (1);
d95 1
a95 1
DISK_printmetrics(struct disk *disk, char *units)
d102 1
a102 1
	size = ((double)disk->real->size * secsize) / unit_types[i].conversion;
d104 3
a106 4
	if (disk->real) {
		printf("geometry: %d/%d/%d [%.0f ",
		    disk->real->cylinders, disk->real->heads,
		    disk->real->sectors, size);
@


1.37
log
@Merge 'struct DISK_metrics' and 'struct disk' into one, since we don't
need to record two sets of metric/geometry data. Use 'geometry'
instead of 'metrics' in names and comments. Eliminate
DISK_getmetrics().

While here, make 64 the minimal valid value for '-l' instead of 1. This
avoids the possibility of having 0 cylinders.

No intentional functional change.

Feedback & tweak from chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.36 2014/03/09 22:25:06 krw Exp $	*/
d44 2
d62 7
a68 2
void
DISK_getlabelgeometry(struct disk *disk)
d70 1
d74 6
a79 2
	/* Get label geometry. */
	if ((fd = DISK_open(disk->name, O_RDONLY)) != -1) {
d82 2
d85 3
a87 3
			disk->cylinders = dl.d_ncylinders;
			disk->heads = dl.d_ntracks;
			disk->sectors = dl.d_nsectors;
d89 1
a89 1
			spc = (u_int64_t)disk->heads * disk->sectors;
d92 2
a93 2
				disk->cylinders = UINT32_MAX / spc;
				disk->size = disk->cylinders * spc;
d97 1
a97 1
				disk->size = sz;
d102 34
d143 1
a143 1
DISK_printgeometry(struct disk *disk, char *units)
d150 1
a150 1
	size = ((double)disk->size * secsize) / unit_types[i].conversion;
d152 4
a155 3
	if (disk->size) {
		printf("geometry: %d/%d/%d [%.0f ", disk->cylinders,
		    disk->heads, disk->sectors, size);
@


1.36
log
@Instead of passing around 'char buf[DEV_BSIZE]' buffers, pass around
'struct dos_mbr' variables, since that is what the buffers were used
for. Removes need to know about DEV_BSIZE and thus include param.h
from all files but one so move the param.h #include to that file
(mbr.c).

Nuke a bunch of local MBR #defines in favour of the disklabel.h ones.

Remove a bunch of unneeded #includes, replace the odd malloc/bzero
with calloc, replace equally odd bcopy's with memcpy, remove a stray
duplicate MBR parsing in MBR_pcopy().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.35 2014/03/07 21:56:13 krw Exp $	*/
a43 2
struct DISK_metrics *DISK_getlabelmetrics(char *name);

d60 2
a61 7
/* Routine to go after the disklabel for geometry
 * information.  This should work everywhere, but
 * in the land of PC, things are not always what
 * they seem.
 */
struct DISK_metrics *
DISK_getlabelmetrics(char *name)
a62 1
	struct DISK_metrics *lm = NULL;
d66 2
a67 6
	/* Get label metrics */
	if ((fd = DISK_open(name, O_RDONLY)) != -1) {
		lm = malloc(sizeof(struct DISK_metrics));
		if (lm == NULL)
			err(1, NULL);

a69 2
			free(lm);
			lm = NULL;
d71 3
a73 3
			lm->cylinders = dl.d_ncylinders;
			lm->heads = dl.d_ntracks;
			lm->sectors = dl.d_nsectors;
d75 1
a75 1
			spc = (u_int64_t)lm->heads * lm->sectors;
d78 2
a79 2
				lm->cylinders = UINT32_MAX / spc;
				lm->size = lm->cylinders * spc;
d83 1
a83 1
				lm->size = sz;
a87 34

	return (lm);
}

/* This is ugly, and convoluted.  All the magic
 * for disk geo/size happens here.  Basically,
 * the real size is the one we will use in the
 * rest of the program, the label size is what we
 * got from the disklabel.  If the disklabel fails,
 * we assume we are working with a normal file,
 * and should request the user to specify the
 * geometry he/she wishes to use.
 */
int
DISK_getmetrics(struct disk *disk, struct DISK_metrics *user)
{

	disk->label = DISK_getlabelmetrics(disk->name);

	/* If user supplied, use that */
	if (user) {
		disk->real = user;
		return (0);
	}

	/* If we have a label, use that */
	if (disk->label) {
		disk->real = disk->label;
		return (0);
	}

	/* Can not get geometry, punt */
	disk->real = NULL;
	return (1);
d95 1
a95 1
DISK_printmetrics(struct disk *disk, char *units)
d102 1
a102 1
	size = ((double)disk->real->size * secsize) / unit_types[i].conversion;
d104 3
a106 4
	if (disk->real) {
		printf("geometry: %d/%d/%d [%.0f ",
		    disk->real->cylinders, disk->real->heads,
		    disk->real->sectors, size);
@


1.35
log
@Relieve the code of an overburden of unnecessary typedef
abstraction. Call a 'struct' a 'struct' and not a pony.

No functional change.

idea ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.34 2013/03/21 18:45:58 deraadt Exp $	*/
a29 1
#include <sys/ioctl.h>
d38 1
a38 1
#include <unistd.h>
d156 1
a156 1
		if (i == SECTORS && secsize != DEV_BSIZE)
@


1.34
log
@more substantial include cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.33 2012/07/11 13:24:29 krw Exp $	*/
d45 1
a45 1
DISK_metrics *DISK_getlabelmetrics(char *name);
d68 1
a68 1
DISK_metrics *
d71 1
a71 1
	DISK_metrics *lm = NULL;
d77 1
a77 1
		lm = malloc(sizeof(DISK_metrics));
d117 1
a117 1
DISK_getmetrics(disk_t *disk, DISK_metrics *user)
d144 1
a144 1
DISK_printmetrics(disk_t *disk, char *units)
@


1.33
log
@MBR can't handle the truth.

When reading disk size/geometry from disklabel, clamp disk size to
the maximum number of cylinders that fit into UINT32_MAX sectors.
Don't just use the bottom 32 bits of the DL_GETDSIZE(). Warn that
truncation has been done.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.32 2011/07/05 21:39:09 krw Exp $	*/
d28 1
a28 5
#include <err.h>
#include <util.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
a32 1
#include <sys/types.h>
d35 5
a39 1
#include <sys/param.h>
@


1.32
log
@Add DIOCGPDINFO to rxioctl(), as a synonym for DIOCGDINFO, the last
place it was missing. Delete now redundant calls to DIOCGDINFO when
getting physical disk info in disklabel(8) and fdisk(8).

Reminded by a fdisk discussion with Andres Perera on tech@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.31 2010/06/30 22:53:41 krw Exp $	*/
d36 1
d73 1
d90 10
a99 1
			lm->size = dl.d_secperunit;
@


1.31
log
@Make 'fdisk -i' start the OpenBSD partition on a power of 2 512-byte
block boundary. In most modern (i.e. 'faked' geometry) situations
this will start it at (0-based) block[64] rather than block[63] as
now. This should help performance on disks which really have 4K
sectors but report 512-byte sectors.

Power of 2 idea from deraadt@@.

ok toby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.30 2010/05/18 04:41:14 dlg Exp $	*/
d80 2
a81 3
		if (ioctl(fd, DIOCGPDINFO, &dl) == -1 &&
		    ioctl(fd, DIOCGDINFO, &dl) == -1) {
			warn("DIOCGDINFO");
@


1.30
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.29 2009/02/08 18:03:18 krw Exp $	*/
d43 2
a71 1
	struct disklabel dl;
@


1.29
log
@Eliminate excessive verbiage for 'fdisk -i' and 'fdisk -u'. Especially
the multi-line banner announcing that the MBR is being changed.
Also the listing of the partition table in 'fdisk -u'. Display a
consistant message when the MBR is written.

While here cleanup and shrink code without changing any semantics.
Started with a diff posted on tech@@ by Tobias Ulmer.

"I like it" marco@@ ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.28 2007/04/27 11:42:44 krw Exp $	*/
d35 1
@


1.28
log
@Remove unneeded #include's, as already done for disklabel. CPU_BIOS
fallout.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.27 2007/04/26 22:42:11 krw Exp $	*/
a59 7
int
DISK_close(int fd)
{

	return (close(fd));
}

d90 1
a90 1
		DISK_close(fd);
@


1.27
log
@Eliminate CPU_BIOS from userland and wd(4) by always using the BIOS
geometry in the disklabel when there is a BIOS geometry to provide.
This removes the option to set a disklabel to 'BIOS' geometry via the
'g b' command in the editor.

Makes reported geometry more consistant and moves MD code to MD land
where it should be.

Doc help from jmc@@, Feedback from millert@@, marco@@, weingart@@,
kettenis@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.26 2006/12/10 19:19:32 krw Exp $	*/
a36 1
#include <sys/reboot.h>
a38 2
#include <sys/sysctl.h>
#include <machine/cpu.h>
@


1.26
log
@Read/write device sectors rather than assuming sector size ==
DEV_BSIZE. Simply extract/insert the desired MBR from/into the first
DEV_BSIZE bytes of the sector.  Makes fdisk work with devices having a
sector size different from DEV_BSIZE (512 bytes). e.g.  2048 byte
sector MP3 devices. Original diff from weingart@@.

ok pedro@@ deraadt@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.25 2006/11/19 20:17:12 krw Exp $	*/
a41 3
#ifdef CPU_BIOS
#include <machine/biosvar.h>
#endif
a45 1
DISK_metrics *DISK_getbiosmetrics(char *name);
a105 64
#ifdef CPU_BIOS
/*
 * Routine to go after sysctl info for BIOS
 * geometry.  This should only really work on PC
 * type machines.  There is still a problem with
 * correlating the BIOS drive to the BSD drive.
 */
DISK_metrics *
DISK_getbiosmetrics(char *name)
{
	bios_diskinfo_t di;
	DISK_metrics *bm;
	struct stat st;
	int mib[4], fd;
	size_t size;
	dev_t devno;

	if ((fd = DISK_open(name, O_RDONLY)) == -1)
		return (NULL);
	fstat(fd, &st);
	DISK_close(fd);

	/* Get BIOS metrics */
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CHR2BLK;
	mib[2] = st.st_rdev;
	size = sizeof(devno);
	if (sysctl(mib, 3, &devno, &size, NULL, 0) == -1) {
		warn("sysctl(machdep.chr2blk)");
		return (NULL);
	}
	devno = MAKEBOOTDEV(major(devno), 0, 0, DISKUNIT(devno), RAW_PART);

	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_BIOS;
	mib[2] = BIOS_DISKINFO;
	mib[3] = devno;
	size = sizeof(di);
	if (sysctl(mib, 4, &di, &size, NULL, 0) == -1) {
		warn("sysctl(machdep.bios.diskinfo)");
		return (NULL);
	}

	bm = malloc(sizeof(di));
	if (bm == NULL)
		err(1, NULL);
	bm->cylinders = di.bios_cylinders;
	bm->heads = di.bios_heads;
	bm->sectors = di.bios_sectors;
	bm->size = di.bios_cylinders * di.bios_heads * di.bios_sectors;
	return (bm);
}
#else
/*
 * We are not a PC, so we do not have BIOS metrics to contend
 * with.  Return NULL to indicate so.
 */
DISK_metrics *
DISK_getbiosmetrics(char *name)
{
	return (NULL);
}
#endif

a119 1
	disk->bios = DISK_getbiosmetrics(disk->name);
a123 19
		return (0);
	}

	/* Fixup bios metrics to include cylinders past 1023 boundary */
	if(disk->label && disk->bios){
		int cyls, secs;

		cyls = disk->label->size / (disk->bios->heads * disk->bios->sectors);
		secs = cyls * (disk->bios->heads * disk->bios->sectors);
		if (secs > disk->label->size)
			errx(1, "BIOS fixup botch (secs (%d) > size (%d))",
			    secs, disk->label->size);
		disk->bios->cylinders = cyls;
		disk->bios->size = secs;
	}

	/* If we have a (fixed) BIOS geometry, use that */
	if (disk->bios) {
		disk->real = disk->bios;
@


1.25
log
@Try DIOCGPDINFO before DIOCGDINFO when trying to determine the 'label'
geometry for a unit. DIOCGPDINFO avoids using the on-disk label or the
cached copy of it and returns a 'spoofed' label that retains the
geometry info placed in the label by the driver. Unfortunately
DIOCGPDINFO is not universally implemented, though sd and wd do.

This is what disklabel(8) does when it wants geometry so this makes
fdisk a bit more consistant with disklabel.

This fixes 'fdisk -i' and 'reinit' when trying to install from a
miniroot on, e.g., landisk. i.e. no need to zero out the disklabel
before doing 'fdisk -i'.

'get it in snaps' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.24 2005/12/18 03:42:23 krw Exp $	*/
d233 2
d236 1
a236 1
	double size;
d238 1
a238 2
	size = ((double)disk->real->size * unit_types[SECTORS].conversion) /
	    unit_types[i].conversion;
d240 8
a247 5
	if (disk->real)
		printf("geometry: %d/%d/%d [%.0f %s]\n", disk->real->cylinders,
		    disk->real->heads, disk->real->sectors, size,
		    unit_types[i].lname);
	else
@


1.24
log
@Fix condition so "BIOS fixup botch" can, unlikely as it is, be
detected. Found by lint.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.23 2005/11/21 01:59:24 krw Exp $	*/
d92 2
a93 1
		if (ioctl(fd, DIOCGDINFO, &dl) == -1) {
@


1.23
log
@Replace default DEV_BSIZE sector conversion factor with disklabel's
sector size when possible. Fixes the "[ XX Sectors ]" size display.
Pointed out by Robert Szasz while playing with his Sony Hi-MD device.

Apply input conversion fixes similar to those recently applied to
disklabel(8). Use correct sector size in the conversions.

It is still *not* possible to use unusual sector sizes for non-ISO9660
filesystems!

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.22 2004/08/03 09:23:11 deraadt Exp $	*/
d201 3
a203 3
		if ((disk->label->size - secs) < 0)
			errx(1, "BIOS fixup botch (%d sectors)",
			    disk->label->size - secs);
@


1.22
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.21 2004/07/11 09:17:36 tom Exp $	*/
d101 1
d235 2
a236 1
	size = (double)disk->real->size * DEV_BSIZE / unit_types[i].conversion;
@


1.21
log
@Just use err(1, NULL) following malloc() failures, per err(3).

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.20 2003/07/29 18:38:35 deraadt Exp $	*/
d239 1
a239 1
		       unit_types[i].lname);
@


1.20
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.19 2003/07/02 21:44:57 deraadt Exp $	*/
d90 1
a90 1
			err(1, "malloc");
d153 1
a153 1
		err(1, "malloc");
@


1.19
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.18 2003/06/11 06:22:12 deraadt Exp $	*/
d230 1
a230 1
{	
@


1.18
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.17 2003/06/03 01:13:19 weingart Exp $	*/
d47 3
@


1.17
log
@Nuke terms 3 & 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.16 2002/07/11 21:23:28 deraadt Exp $	*/
d49 1
a49 3
DISK_open(disk, mode)
	char *disk;
	int mode;
d65 1
a65 2
DISK_close(fd)
	int fd;
d77 1
a77 2
DISK_getlabelmetrics(name)
	char *name;
d113 1
a113 2
DISK_getbiosmetrics(name)
	char *name;
d163 1
a163 2
DISK_getbiosmetrics(name)
	char *name;
d179 1
a179 3
DISK_getmetrics(disk, user)
	disk_t *disk;
	DISK_metrics *user;
d198 2
a199 1
			errx(1, "BIOS fixup botch (%d sectors)", disk->label->size - secs);
d226 1
a226 3
DISK_printmetrics(disk, units)
	disk_t *disk;
	char *units;
@


1.16
log
@malloc() failure tests; rimshot@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.15 2002/04/25 22:13:13 espie Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.15
log
@sysctl wants size_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.14 2002/01/18 08:38:26 kjell Exp $	*/
d95 2
d159 2
@


1.14
log
@Allow size values to be displayed in the user's choice of units.
Idea borrowed from disklabel. i.e. Users can now type "print M"
and be rewarded with partition sizes in Megs
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.13 2001/06/23 01:54:37 kjell Exp $	*/
d126 2
a127 1
	int mib[4], size, fd;
@


1.13
log
@Changes from Toby. Make error tests explicit (against -1), remove one big
hurdle to partitions over 8G. Include the default MBR in a header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.12 2001/05/21 22:47:53 angelos Exp $	*/
d51 1
d228 4
d233 1
a233 1
DISK_printmetrics(disk)
d235 6
a240 2
{

d243 3
a245 2
		printf("geometry: %d/%d/%d [%d sectors]\n", disk->real->cylinders,
		    disk->real->heads, disk->real->sectors, disk->real->size);
@


1.12
log
@More verbose error message (what's the actual sysctl that failed)
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.11 2000/04/18 22:40:15 kjell Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Tobias Weingartner
d61 1
a61 1
	if (fd < 0)
d63 1
a63 1
	if (fstat(fd, &st) < 0)
d92 1
a92 1
	if ((fd = DISK_open(name, O_RDONLY)) >= 0) {
d95 1
a95 1
		if (ioctl(fd, DIOCGDINFO, &dl) < 0) {
d128 1
a128 1
	if ((fd = DISK_open(name, O_RDONLY)) < 0)
d138 1
a138 1
	if (sysctl(mib, 3, &devno, &size, NULL, 0) < 0) {
d149 2
a150 2
	if (sysctl(mib, 4, &di, &size, NULL, 0) < 0) {
		warn("sysctl(machedep.bios.diskinfo)");
d198 13
a210 1
	/* If we have BIOS geometry, use that */
a215 1

d217 1
a217 1
	if (!disk->real && disk->label)
d219 2
d223 2
a224 4
	if (disk->real == NULL)
		return (1);

	return (0);
@


1.11
log
@Favor BIOS geometry over physical. This should fix MANY problems with
hard drives >8G sharing partitions with other operating systems.
Also, support extended partition type 0x0F, which is quite common now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.10 2000/01/08 04:51:16 deraadt Exp $	*/
d150 1
a150 1
		warn("sysctl");
@


1.10
log
@support LBA-mapped extended partitions too; sigh@@kuzirabekon.econ.nagasaki-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.9 1997/10/28 10:06:32 deraadt Exp $	*/
d198 7
a211 12

	/* If we have a bios, use that (if label looks bogus)
	 *
	 * XXX - This needs to be fixed!!!!
	 * Currently machdep.bios.biosdev is USELESS
	 * It needs to be, at least, a BSD device.
	 * Or we need a mapping from biosdev -> BSD universe.
	 */
	if (disk->bios)
		if (disk->real->cylinders > 262144 || disk->real->heads > 256 ||
		    disk->real->sectors > 63)
			disk->real = disk->bios;
@


1.9
log
@use RAW_PART, not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.8 1997/10/26 00:47:05 deraadt Exp $	*/
d214 1
a214 1
		if (disk->real->cylinders > 1024 || disk->real->heads > 255 ||
@


1.8
log
@do device sysctl operations like installboot does; I hope this is right
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.7 1997/10/22 23:41:15 mickey Exp $	*/
d142 1
a142 1
	devno = MAKEBOOTDEV(major(devno), 0, 0, DISKUNIT(devno), 0);
@


1.7
log
@newer bios stuff; needs work
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.6 1997/10/19 23:30:46 deraadt Exp $	*/
d42 1
d122 1
d124 8
a131 3
	bios_diskinfo_t di;
	int biosdev;
	int mib[4], size;
d135 5
a139 6
	mib[1] = CPU_BIOS;
	mib[2] = BIOS_DEV;
	size = sizeof(biosdev);

	if (sysctl(mib, 3, &biosdev, &size, NULL, 0) < 0) {
		warn("sysctl");
d142 1
d144 2
d147 1
a147 1
	mib[3] = biosdev;
a148 1

@


1.6
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.5 1997/10/19 23:29:36 deraadt Exp $	*/
d111 2
a112 1
/* Routine to go after sysctl info for BIOS
a115 2
 *
 * XXX - Somebody fix this!
d121 2
a122 1
	DISK_metrics *bm = NULL;
a123 1
	u_int biosgeo;
d137 3
a139 2
	mib[2] = BIOS_GEOMETRY;
	size = sizeof(biosgeo);
d141 1
a141 1
	if (sysctl(mib, 3, &biosgeo, &size, NULL, 0) < 0) {
d146 5
a150 6
	bm = malloc(sizeof(DISK_metrics));
	bm->cylinders = BIOSNTRACKS(biosgeo);
	bm->heads = BIOSNHEADS(biosgeo);
	bm->sectors = BIOSNSECTS(biosgeo);
	bm->size = BIOSNTRACKS(biosgeo) * BIOSNHEADS(biosgeo) *
	    BIOSNSECTS(biosgeo);
@


1.5
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.4 1997/10/16 01:47:09 deraadt Exp $	*/
d66 1
a66 1
	return(fd);
d74 1
a74 1
	return(close(fd));
d107 1
a107 1
	return(lm);
d152 1
a152 1
	return(bm);
d163 1
a163 1
	return(NULL);
d226 1
a226 1
	return(0);
@


1.4
log
@a bunch of improvements by weingart & I
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.3 1997/10/04 00:15:48 deraadt Exp $	*/
a50 1

d60 5
a64 4
	if(fd < 0) err(1, "%s", disk);
	if(fstat(fd, &st) < 0) err(1, "%s", disk);

	if(!S_ISCHR(st.st_mode) && !S_ISREG(st.st_mode))
a65 1

d91 1
a91 1
	if((fd = DISK_open(name, O_RDONLY)) >= 0){
d94 1
a94 1
		if(ioctl(fd, DIOCGDINFO, &dl) < 0){
d98 1
a98 1
		}else{
d133 1
a133 1
	if(sysctl(mib, 3, &biosdev, &size, NULL, 0) < 0){
d141 1
a141 1
	if(sysctl(mib, 3, &biosgeo, &size, NULL, 0) < 0){
d186 1
a186 1
	if(user){
d188 1
a188 1
		return(0);
d192 1
a192 1
	if(!disk->real && disk->label)
d196 2
a197 2
	if(disk->real == NULL)
		return(1);
d206 3
a208 3
	if(disk->bios)
		if(disk->real->cylinders > 1024 || disk->real->heads > 255
			|| disk->real->sectors > 63)
d211 1
a211 1
	return(0);
d220 1
a220 1
	if(disk->real)
d222 1
a222 1
			disk->real->heads, disk->real->sectors, disk->real->size);
@


1.3
log
@support CPU_BIOSDEV on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.2 1997/09/29 23:33:34 mickey Exp $	*/
d46 1
a46 1
#ifdef CPU_BIOSDEV
d84 1
a84 1
DISK_getrealmetrics(name)
d91 1
a91 1
	/* Get real metrics */
d111 1
a111 1
#ifdef CPU_BIOSDEV
d155 11
d170 2
a171 2
 * the bios size is the one we will use in the
 * rest of the program, the real size is what we
d178 1
a178 1
DISK_getmetrics(disk)
d180 1
d183 1
a183 2
	disk->real = DISK_getrealmetrics(disk->name);
#ifdef CPU_BIOSDEV
d185 10
a194 3
#else
	disk->bios = disk->real;			/* We aint no stinkin PC */
#endif
d197 1
a197 1
	if(disk->bios == NULL || disk->real == NULL)
d200 12
d220 1
d222 1
a222 1
		printf("Disk GEO: %d/%d/%d [%d sectors]\n", disk->real->cylinders,
d225 1
a225 7
		printf("Disk GEO: <none>\n");

	if(disk->bios)
		printf("Bios GEO: %d/%d/%d [%d sectors]\n", disk->bios->cylinders,
			disk->bios->heads, disk->bios->sectors, disk->bios->size);
	else
		printf("Bios GEO: <none>\n");
@


1.2
log
@ID in the first line w/ tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.c,v 1.1 1997/09/29 22:58:15 weingart Exp $	*/
a110 1

d124 3
a126 2
	int biosdev, biosgeo;
	int mib[3], size;
d130 3
a132 2
	mib[1] = CPU_BIOSDEV;
	size = sizeof(int);
d134 1
a134 1
	if(sysctl(mib, 2, &biosdev, &size, NULL, 0) < 0){
d136 1
a136 1
		return(NULL);
d139 2
a140 2
	mib[1] = CPU_BIOSGEOMETRY;
	size = sizeof(int);
d142 1
a142 1
	if(sysctl(mib, 2, &biosgeo, &size, NULL, 0) < 0){
d144 1
a144 1
		return(NULL);
d151 2
a152 3
	bm->size = BIOSNTRACKS(biosgeo) * BIOSNHEADS(biosgeo)
		* BIOSNSECTS(biosgeo);

d155 1
a155 2
#endif /* CPU_BIOSDEV */

@


1.1
log
@New fdisk code with interactive (command line type)
editing code.  Rewrite from the ground up, save about
20 lines of code.  Seems to create valid partition
tables on i386 and alphas.
@
text
@d1 1
a1 2

/* $OpenBSD$ */
@
