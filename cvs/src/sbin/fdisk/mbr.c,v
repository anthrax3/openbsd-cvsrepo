head	1.67;
access;
symbols
	OPENBSD_6_0:1.65.0.4
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.32.0.2
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.4
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.8
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.6
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.6
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6;
locks; strict;
comment	@ * @;


1.67
date	2016.09.01.16.17.46;	author krw;	state Exp;
branches;
next	1.66;
commitid	1j0OGDKUX3NzKtsu;

1.66
date	2016.09.01.16.14.51;	author krw;	state Exp;
branches;
next	1.65;
commitid	xBp7KCYwSi3jEned;

1.65
date	2015.12.30.17.21.39;	author krw;	state Exp;
branches;
next	1.64;
commitid	yBYwSveSmioQupeG;

1.64
date	2015.12.27.20.39.51;	author krw;	state Exp;
branches;
next	1.63;
commitid	r2v94bEPYyY9yVVI;

1.63
date	2015.11.19.16.14.08;	author krw;	state Exp;
branches;
next	1.62;
commitid	07Axfimkfyb7znjO;

1.62
date	2015.11.18.17.09.26;	author krw;	state Exp;
branches;
next	1.61;
commitid	m8XGGC487CUV05uN;

1.61
date	2015.11.18.15.31.15;	author krw;	state Exp;
branches;
next	1.60;
commitid	BGaJX0YBjBKscKAZ;

1.60
date	2015.11.13.02.27.17;	author krw;	state Exp;
branches;
next	1.59;
commitid	4K9a6NDKqAi1JXz9;

1.59
date	2015.11.12.23.49.37;	author krw;	state Exp;
branches;
next	1.58;
commitid	FVu7UNcLs5uZM2GL;

1.58
date	2015.11.12.21.31.36;	author krw;	state Exp;
branches;
next	1.57;
commitid	uJ7m0sYoyXDL4PcJ;

1.57
date	2015.11.10.18.07.12;	author krw;	state Exp;
branches;
next	1.56;
commitid	9Ww9cQCLin5OTuyI;

1.56
date	2015.10.26.15.08.26;	author krw;	state Exp;
branches;
next	1.55;
commitid	fOI5D0M32zdW7eoe;

1.55
date	2015.10.05.01.39.08;	author krw;	state Exp;
branches;
next	1.54;
commitid	2xnXUR8eGYteWRoe;

1.54
date	2015.09.04.19.02.49;	author kettenis;	state Exp;
branches;
next	1.53;
commitid	7P9obYFrIDpMNPYf;

1.53
date	2015.08.27.20.58.27;	author krw;	state Exp;
branches;
next	1.52;
commitid	HPfwzWhA0Lbc6ZGU;

1.52
date	2015.04.02.18.00.55;	author krw;	state Exp;
branches;
next	1.51;
commitid	IwHCZszuGuX6jauK;

1.51
date	2015.03.30.17.11.49;	author krw;	state Exp;
branches;
next	1.50;
commitid	PQWtQHYSt0QI2mGM;

1.50
date	2015.03.29.21.16.39;	author krw;	state Exp;
branches;
next	1.49;
commitid	wVztKOyPskKRobDK;

1.49
date	2015.03.29.19.11.23;	author krw;	state Exp;
branches;
next	1.48;
commitid	yjs63rvymlEgj9WW;

1.48
date	2015.03.18.14.46.59;	author krw;	state Exp;
branches;
next	1.47;
commitid	9oRFFmwrkHklH7n4;

1.47
date	2015.03.16.23.51.50;	author krw;	state Exp;
branches;
next	1.46;
commitid	JG85Pc2Xt4lLAJpr;

1.46
date	2015.03.14.18.32.29;	author krw;	state Exp;
branches;
next	1.45;
commitid	VCsOzs6eGW0SpJ6c;

1.45
date	2015.03.14.16.58.00;	author krw;	state Exp;
branches;
next	1.44;
commitid	5UuLJqjempXAM8Gc;

1.44
date	2015.03.14.15.21.53;	author krw;	state Exp;
branches;
next	1.43;
commitid	aPXwn1AfAIMw4FVu;

1.43
date	2015.02.10.01.20.10;	author krw;	state Exp;
branches;
next	1.42;
commitid	ULzYHs9wSJgbDBeo;

1.42
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Uu5nFG3wCl0LACBb;

1.41
date	2015.01.03.15.50.50;	author jsing;	state Exp;
branches;
next	1.40;
commitid	Hkl9onJ3wjSN2qH0;

1.40
date	2014.05.21.15.55.19;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2014.03.31.19.50.52;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2014.03.17.16.40.00;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2014.03.17.13.15.44;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2014.03.14.15.41.33;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2014.03.13.12.02.28;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.09.22.25.06;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.07.21.56.13;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2014.02.05.03.51.07;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.08.15.45.43;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.21.18.45.58;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2012.04.04.13.14.44;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.20.19.10.41;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2011.02.21.19.26.13;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.30.22.53.41;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.08.18.03.18;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.10.19.19.32;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.29.05.09.36;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.18.23.22.05;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.13.06.00.33;	author tom;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.01.13.19;	author weingart;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.18.08.38.26;	author kjell;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.04.08.35.06;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.15.02.12.26;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.28.00.51.46;	author weingart;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.07.13.37.00;	author rahnds;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.01.21.49.12;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.08.21.22.49.25;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.08.10.23.10.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.09.14.03.54.35;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	97.10.21.22.49.33;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.10.19.23.30.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.19.23.29.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.16.01.47.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.09.29.23.33.36;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.09.29.22.58.16;	author weingart;	state Exp;
branches;
next	;


desc
@@


1.67
log
@Nuke now unused 'sz' variable.
@
text
@/*	$OpenBSD: mbr.c,v 1.66 2016/09/01 16:14:51 krw Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/ioctl.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "disk.h"
#include "part.h"
#include "misc.h"
#include "mbr.h"
#include "gpt.h"

struct mbr initial_mbr;

static int gpt_chk_mbr(struct dos_partition *, u_int64_t);

int
MBR_protective_mbr(struct mbr *mbr)
{
	struct dos_partition dp[NDOSPART], dos_partition;
	int i;

	for (i = 0; i < NDOSPART; i++) {
		PRT_make(&mbr->part[i], mbr->offset, mbr->reloffset,
		    &dos_partition);
		memcpy(&dp[i], &dos_partition, sizeof(dp[i]));
	}

	return (gpt_chk_mbr(dp, DL_GETDSIZE(&dl)));
}

void
MBR_init_GPT(struct mbr *mbr)
{
	memset(&mbr->part, 0, sizeof(mbr->part));

	/* Use whole disk, starting after MBR.
	 *
	 * Always set the partition size to UINT32_MAX (as MS does). EFI
	 * firmware has been encountered that lies in unpredictable ways
	 * about the size of the disk, thus making it impossible to boot
	 * such devices.
	 */
	mbr->part[0].id = DOSPTYP_EFI;
	mbr->part[0].bs = 1;
	mbr->part[0].ns = UINT32_MAX;

	/* Fix up start/length fields. */
	PRT_fix_CHS(&mbr->part[0]);
}

void
MBR_init(struct mbr *mbr)
{
	extern u_int32_t b_arg;
	u_int64_t adj;
	daddr_t i;

	/*
	 * XXX Do *NOT* zap all MBR parts! Some archs still read initmbr
	 * from disk!! Just mark them inactive until -b goodness spreads
	 * further.
	 */
	mbr->part[0].flag = 0;
	mbr->part[1].flag = 0;
	mbr->part[2].flag = 0;

	memset(&gh, 0, sizeof(gh));
	memset(&gp, 0, sizeof(gp));

	mbr->part[3].flag = DOSACTIVE;
	mbr->signature = DOSMBR_SIGNATURE;

	/* Use whole disk. Reserve first track, or first cyl, if possible. */
	mbr->part[3].id = DOSPTYP_OPENBSD;
	if (disk.heads > 1)
		mbr->part[3].shead = 1;
	else
		mbr->part[3].shead = 0;
	if (disk.heads < 2 && disk.cylinders > 1)
		mbr->part[3].scyl = 1;
	else
		mbr->part[3].scyl = 0;
	mbr->part[3].ssect = 1;

	/* Go right to the end */
	mbr->part[3].ecyl = disk.cylinders - 1;
	mbr->part[3].ehead = disk.heads - 1;
	mbr->part[3].esect = disk.sectors;

	/* Fix up start/length fields */
	PRT_fix_BN(&mbr->part[3], 3);

#if defined(__powerpc__) || defined(__mips__)
	/* Now fix up for the MS-DOS boot partition on PowerPC. */
	mbr->part[0].flag = DOSACTIVE;	/* Boot from dos part */
	mbr->part[3].flag = 0;
	mbr->part[3].ns += mbr->part[3].bs;
	mbr->part[3].bs = mbr->part[0].bs + mbr->part[0].ns;
	mbr->part[3].ns -= mbr->part[3].bs;
	PRT_fix_CHS(&mbr->part[3]);
	if ((mbr->part[3].shead != 1) || (mbr->part[3].ssect != 1)) {
		/* align the partition on a cylinder boundary */
		mbr->part[3].shead = 0;
		mbr->part[3].ssect = 1;
		mbr->part[3].scyl += 1;
	}
	/* Fix up start/length fields */
	PRT_fix_BN(&mbr->part[3], 3);
#endif
#if defined(__i386__) || defined(__amd64__)
	if (b_arg > 0) {
		/* Add an EFI system partition on i386/amd64. */
		mbr->part[0].id = DOSPTYP_EFISYS;
		mbr->part[0].bs = 64;
		mbr->part[0].ns = b_arg;
		PRT_fix_CHS(&mbr->part[0]);
		mbr->part[3].ns += mbr->part[3].bs;
		mbr->part[3].bs = mbr->part[0].bs + mbr->part[0].ns;
		mbr->part[3].ns -= mbr->part[3].bs;
		PRT_fix_CHS(&mbr->part[3]);
	}
#endif

	/* Start OpenBSD MBR partition on a power of 2 block number. */
	i = 1;
	while (i < DL_SECTOBLK(&dl, mbr->part[3].bs))
		i *= 2;
	adj = DL_BLKTOSEC(&dl, i) - mbr->part[3].bs;
	mbr->part[3].bs += adj;
	mbr->part[3].ns -= adj;
	PRT_fix_CHS(&mbr->part[3]);
}

void
MBR_parse(struct dos_mbr *dos_mbr, off_t offset, off_t reloff, struct mbr *mbr)
{
	struct dos_partition dos_parts[NDOSPART];
	int i;

	memcpy(mbr->code, dos_mbr->dmbr_boot, sizeof(mbr->code));
	mbr->offset = offset;
	mbr->reloffset = reloff;
	mbr->signature = letoh16(dos_mbr->dmbr_sign);

	memcpy(dos_parts, dos_mbr->dmbr_parts, sizeof(dos_parts));

	for (i = 0; i < NDOSPART; i++)
		PRT_parse(&dos_parts[i], offset, reloff, &mbr->part[i]);
}

void
MBR_make(struct mbr *mbr, struct dos_mbr *dos_mbr)
{
	struct dos_partition dos_partition;
	int i;

	memcpy(dos_mbr->dmbr_boot, mbr->code, sizeof(dos_mbr->dmbr_boot));
	dos_mbr->dmbr_sign = htole16(DOSMBR_SIGNATURE);

	for (i = 0; i < NDOSPART; i++) {
		PRT_make(&mbr->part[i], mbr->offset, mbr->reloffset,
		    &dos_partition);
		memcpy(&dos_mbr->dmbr_parts[i], &dos_partition,
		    sizeof(dos_mbr->dmbr_parts[i]));
	}
}

void
MBR_print(struct mbr *mbr, char *units)
{
	int i;

	DISK_printgeometry(NULL);

	/* Header */
	printf("Offset: %lld\t", (long long)mbr->offset);
	printf("Signature: 0x%X\n", (int)mbr->signature);
	PRT_print(0, NULL, units);

	/* Entries */
	for (i = 0; i < NDOSPART; i++)
		PRT_print(i, &mbr->part[i], units);
}

int
MBR_read(off_t where, struct dos_mbr *dos_mbr)
{
	char *secbuf;

	secbuf = DISK_readsector(where);
	if (secbuf == NULL)
		return (-1);

	memcpy(dos_mbr, secbuf, sizeof(*dos_mbr));
	free(secbuf);

	return (0);
}

int
MBR_write(off_t where, struct dos_mbr *dos_mbr)
{
	char *secbuf;

	secbuf = DISK_readsector(where);
	if (secbuf == NULL)
		return (-1);

	/*
	 * Place the new MBR at the start of the sector and
	 * write the sector back to "disk".
	 */
	memcpy(secbuf, dos_mbr, sizeof(*dos_mbr));
	DISK_writesector(secbuf, where);

	/* Refresh in-kernel disklabel from the updated disk information. */
	ioctl(disk.fd, DIOCRLDINFO, 0);

	free(secbuf);

	return (0);
}

/*
 * If *dos_mbr has a 0xee or 0xef partition, nothing needs to happen. If no
 * such partition is present but the first or last sector on the disk has a
 * GPT, zero the GPT to ensure the MBR takes priority and fewer BIOSes get
 * confused.
 */
void
MBR_zapgpt(struct dos_mbr *dos_mbr, uint64_t lastsec)
{
	struct dos_partition dos_parts[NDOSPART];
	char *secbuf;
	uint64_t sig;
	int i;

	memcpy(dos_parts, dos_mbr->dmbr_parts, sizeof(dos_parts));

	for (i = 0; i < NDOSPART; i++)
		if ((dos_parts[i].dp_typ == DOSPTYP_EFI) ||
		    (dos_parts[i].dp_typ == DOSPTYP_EFISYS))
			return;

	secbuf = DISK_readsector(GPTSECTOR);
	if (secbuf == NULL)
		return;

	memcpy(&sig, secbuf, sizeof(sig));
	if (letoh64(sig) == GPTSIGNATURE) {
		memset(secbuf, 0, sizeof(sig));
		DISK_writesector(secbuf, GPTSECTOR);
	}
	free(secbuf);

	secbuf = DISK_readsector(lastsec);
	if (secbuf == NULL)
		return;

	memcpy(&sig, secbuf, sizeof(sig));
	if (letoh64(sig) == GPTSIGNATURE) {
		memset(secbuf, 0, sizeof(sig));
		DISK_writesector(secbuf, lastsec);
	}
	free(secbuf);
}

/*
 * Returns 0 if the MBR with the provided partition array is a GPT protective
 * MBR, and returns 1 otherwise. A GPT protective MBR would have one and only
 * one MBR partition, an EFI partition that either covers the whole disk or as
 * much of it as is possible with a 32bit size field.
 *
 * Taken from kern/subr_disk.c.
 *
 * NOTE: MS always uses a size of UINT32_MAX for the EFI partition!**
 */
int
gpt_chk_mbr(struct dos_partition *dp, u_int64_t dsize)
{
	struct dos_partition *dp2;
	int efi, found, i;
	u_int32_t psize;

	found = efi = 0;
	for (dp2=dp, i=0; i < NDOSPART; i++, dp2++) {
		if (dp2->dp_typ == DOSPTYP_UNUSED)
			continue;
		found++;
		if (dp2->dp_typ != DOSPTYP_EFI)
			continue;
		psize = letoh32(dp2->dp_size);
		if (psize == (dsize - 1) ||
		    psize == UINT32_MAX) {
			if (letoh32(dp2->dp_start) == 1)
				efi++;
		}
	}
	if (found == 1 && efi == 1)
		return (0);

	return (1);
}

@


1.66
log
@EFI firmware has been encountered that is (from our point of view) confused
about the disk size. Making the protective MBR created by fdisk invalid as
fdisk used the 'correct' disk size.

So just do what MS does and put UINT32_MAX into the EE partition size field,
no matter what the disk size is. Lets tom@@'s Dell boot.

ok kettenis@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.65 2015/12/30 17:21:39 krw Exp $	*/
a56 4
	u_int64_t sz;

	sz = DL_GETDSIZE(&dl);

@


1.65
log
@Revert r1.59's over-enthusiatic MBR zero'ing in MBR_init(). It was
killing the macppc MSDOS partition created by '-i'.

Should fix the macppc install problems reported by Brian Conway on
bugs@@. Date of breakage found by rpe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.64 2015/12/27 20:39:51 krw Exp $	*/
d63 7
a69 1
	/* Use whole disk, starting after MBR. */
d72 1
a72 4
	if (sz > UINT32_MAX)
		mbr->part[0].ns = UINT32_MAX;
	else
		mbr->part[0].ns = sz - 1;
@


1.64
log
@Use 'standard' gpt_chk_mbr() to check for protective MBR.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.63 2015/11/19 16:14:08 krw Exp $	*/
d82 9
a90 1
	memset(&mbr->part, 0, sizeof(mbr->part));
@


1.63
log
@Reduce overburden of unnecessary #include's. Note that param.h is
included only for DEV_BSIZE.  Use INT64_MAX instead of LLONG_MAX
so stdint.h is enough.  General tidying up of #include sections.

ok GCC
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.62 2015/11/18 17:09:26 krw Exp $	*/
d37 2
d42 2
a43 3
	u_int64_t dsize;
	int efi, found, i;
	u_int32_t psize;
a44 1
	found = efi = 0;
d46 3
a48 11
		if (mbr->part[i].id == DOSPTYP_UNUSED)
			continue;
		found++;
		if (mbr->part[i].id != DOSPTYP_EFI)
			continue;
		dsize = DL_GETDSIZE(&dl);
		psize = mbr->part[i].ns;
		if (psize == (dsize - 1) || psize == UINT32_MAX) {
			if (mbr->part[i].bs == 1)
				efi++;
		}
a49 2
	if (found == 1 && efi == 1)
		return (0);
d51 1
a51 1
	return (1);
d283 38
@


1.62
log
@Change #include <memory.h> to #include <string.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.61 2015/11/18 15:31:15 krw Exp $	*/
a19 1
#include <sys/fcntl.h>
a20 1
#include <sys/stat.h>
d23 2
a24 3
#include <err.h>
#include <errno.h>
#include <util.h>
a25 1
#include <unistd.h>
a26 1
#include <stdint.h>
@


1.61
log
@Parse the original on-disk MBR into a local variable. Use the
partition table in this variable when doing an 'u'pdate of the MBR.
Remove now superfluous MBR_pcopy() and its re-read of the on-disk MBR.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.60 2015/11/13 02:27:17 krw Exp $	*/
d32 1
a32 1
#include <memory.h>
@


1.60
log
@Move from opening/closing disk for every i/o to opening the disk once
and saving the fd in the global 'disk' structure. Stop passing around
fd's and just use the global.

Makes pledge() feasible.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.59 2015/11/12 23:49:37 krw Exp $	*/
a252 22
}

/*
 * Parse the MBR partition table into 'mbr', leaving the rest of 'mbr'
 * untouched.
 */
void
MBR_pcopy(struct mbr *mbr)
{
	struct dos_partition dos_parts[NDOSPART];
	struct dos_mbr dos_mbr;
	int i, error;

	error = MBR_read(0, &dos_mbr);

	if (error == -1)
		return;

	memcpy(dos_parts, dos_mbr.dmbr_parts, sizeof(dos_parts));

	for (i = 0; i < NDOSPART; i++)
		PRT_parse(&dos_parts[i], 0, 0, &mbr->part[i]);
@


1.59
log
@'reinit mbr' must zero existing MBR and GPT partition information
before constructing default MBR.

Change last bzero() to memset().
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.58 2015/11/12 21:31:36 krw Exp $	*/
d217 1
a217 1
MBR_read(int fd, off_t where, struct dos_mbr *dos_mbr)
d221 1
a221 1
	secbuf = DISK_readsector(fd, where);
d232 1
a232 1
MBR_write(int fd, off_t where, struct dos_mbr *dos_mbr)
d236 1
a236 1
	secbuf = DISK_readsector(fd, where);
d245 1
a245 1
	DISK_writesector(fd, secbuf, where);
d248 1
a248 1
	ioctl(fd, DIOCRLDINFO, 0);
d264 1
a264 1
	int i, fd, error;
d266 1
a266 3
	fd = DISK_open(disk.name, O_RDONLY);
	error = MBR_read(fd, 0, &dos_mbr);
	close(fd);
d284 1
a284 1
MBR_zapgpt(int fd, struct dos_mbr *dos_mbr, uint64_t lastsec)
d298 1
a298 1
	secbuf = DISK_readsector(fd, GPTSECTOR);
d305 1
a305 1
		DISK_writesector(fd, secbuf, GPTSECTOR);
d309 1
a309 1
	secbuf = DISK_readsector(fd, lastsec);
d316 1
a316 1
		DISK_writesector(fd, secbuf, lastsec);
@


1.58
log
@Refresh the in-kernel copy of the disklabel from the disk *after* writing
the new GPT.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.57 2015/11/10 18:07:12 krw Exp $	*/
d38 1
d76 1
a76 2
	/* Initialize a protective MBR for GPT. */
	bzero(&mbr->part, sizeof(mbr->part));
d97 3
a99 4
	/* Fix up given mbr for this disk */
	mbr->part[0].flag = 0;
	mbr->part[1].flag = 0;
	mbr->part[2].flag = 0;
@


1.57
log
@Use UINT32_MAX for the size of the EFI System partition on disks larger than
UINT32_MAX sectors. i.e. don't use the truncated value aligned to cylinder
size that we use for 'real' MBR partitions.

Makes GPT on large disks work.

Problem found & fix tested by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.56 2015/10/26 15:08:26 krw Exp $	*/
d247 2
@


1.56
log
@Add GPT editing. Based on GSOC 2014 work by Markus Muller.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.55 2015/10/05 01:39:08 krw Exp $	*/
d71 4
d81 4
a84 1
	mbr->part[0].ns = disk.size - 1;
@


1.55
log
@Enhance '-g' to create a default GPT label in addition to the protective
MBR. If '-b' is specified an EFI System partition of the requested size is
created. All remaining space is put into an OpenBSD partition.

Minimal enhancement necessary for upcoming UEFI install support.
Committed first to flush out any unexpected impacts on 'normal' MBR
operation and install media.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.54 2015/09/04 19:02:49 kettenis Exp $	*/
d31 1
d41 27
d197 2
@


1.54
log
@Add a -b option, to be used together with -i, that tells fdisk to add a
special boot partition on architectures that need it.

For now those architectures are amd64 and i386, where this option will
create an EFI system partition to store our new UEFI bootloader.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.53 2015/08/27 20:58:27 krw Exp $	*/
a58 1
	extern int g_flag;
a60 5

	if (g_flag) {
		MBR_init_GPT(mbr);
		return;
	}
@


1.53
log
@Nuke some trailing whitespace that keeps coming back.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.52 2015/04/02 18:00:55 krw Exp $	*/
d58 1
d112 13
@


1.52
log
@Don't printf("offset: ...) before every call to MBR_print(). Do it
once inside MBR_print().
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.51 2015/03/30 17:11:49 krw Exp $	*/
d119 1
a119 1
	mbr->part[3].ns -= adj; 
@


1.51
log
@Even better -- readsector() and writesector() become DISK_readsector() and
DISK_writesector() and live in disk.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.50 2015/03/29 21:16:39 krw Exp $	*/
d163 1
@


1.50
log
@Rename MBR_readsector() and MBR_writesector() to just readsector()
and writesector(). Move them to misc.[ch]. Soon to be used for more
than MBR reading/writing.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.49 2015/03/29 19:11:23 krw Exp $	*/
d176 1
a176 1
	secbuf = readsector(fd, where);
d191 1
a191 1
	secbuf = readsector(fd, where);
d200 1
a200 1
	writesector(fd, secbuf, where);
d253 1
a253 1
	secbuf = readsector(fd, GPTSECTOR);
d260 1
a260 1
		writesector(fd, secbuf, GPTSECTOR);
d264 1
a264 1
	secbuf = readsector(fd, lastsec);
d271 1
a271 1
		writesector(fd, secbuf, lastsec);
@


1.49
log
@A couple of letoh64() to make GPTSIGNATURE test work better on
non-amd64 boxen.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.48 2015/03/18 14:46:59 krw Exp $	*/
d176 1
a176 1
	secbuf = MBR_readsector(fd, where);
d191 1
a191 1
	secbuf = MBR_readsector(fd, where);
d200 1
a200 1
	MBR_writesector(fd, secbuf, where);
a232 55
 * Read the sector at 'where' into a sector sized buf and return the latter.
 */
char *
MBR_readsector(int fd, off_t where)
{
	const int secsize = unit_types[SECTORS].conversion;
	char *secbuf;
	ssize_t len;
	off_t off;

	where *= secsize;
	off = lseek(fd, where, SEEK_SET);
	if (off != where)
		return (NULL);

	secbuf = calloc(1, secsize);
	if (secbuf == NULL)
		return (NULL);

	len = read(fd, secbuf, secsize);
	if (len == -1 || len != secsize) {
		free(secbuf);
		return (NULL);
	}

	return (secbuf);
}

/*
 * Write the sector sized 'secbuf' to the sector at 'where'.
 */
int
MBR_writesector(int fd, char *secbuf, off_t where)
{
	const int secsize = unit_types[SECTORS].conversion;
	ssize_t len;
	off_t off;

	len = -1;

	where *= secsize;
	off = lseek(fd, where, SEEK_SET);
	if (off == where)
		len = write(fd, secbuf, secsize);

	if (len == -1 || len != secsize) {
		/* short read or write */
		errno = EIO;
		return (-1);
	}

	return (0);
}

/*
d253 1
a253 1
	secbuf = MBR_readsector(fd, GPTSECTOR);
d260 1
a260 1
		MBR_writesector(fd, secbuf, GPTSECTOR);
d264 1
a264 1
	secbuf = MBR_readsector(fd, lastsec);
d271 1
a271 1
		MBR_writesector(fd, secbuf, lastsec);
@


1.48
log
@Stop passing around little used 'struct mbr tt' parameter.  Just
make the initial mbr that tt pointed at a global that can be directly
accessed in the couple of places it is needed.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.47 2015/03/16 23:51:50 krw Exp $	*/
d313 1
a313 1
	if (sig == GPTSIGNATURE) {
d324 1
a324 1
	if (sig == GPTSIGNATURE) {
@


1.47
log
@Stop passing around a pointer to the stack variable 'disk' in main().
There is only one disk being worked on, so just make it a global.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.46 2015/03/14 18:32:29 krw Exp $	*/
d37 2
@


1.46
log
@Whitespace & KNF tweaks. Change functions whose return values are
not checked to void. Use continue inside a do loop instead of a
goto to the top. Move a #define/#undef more local to use. Eliminate
some lint.

General cleanup of things noticed preparing the big churn.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.45 2015/03/14 16:58:00 krw Exp $	*/
d39 1
a39 1
MBR_init_GPT(struct disk *disk, struct mbr *mbr)
d47 1
a47 1
	mbr->part[0].ns = disk->size - 1;
d50 1
a50 1
	PRT_fix_CHS(disk, &mbr->part[0]);
d54 1
a54 1
MBR_init(struct disk *disk, struct mbr *mbr)
d61 1
a61 1
		MBR_init_GPT(disk, mbr);
d75 1
a75 1
	if (disk->heads > 1)
d79 1
a79 1
	if (disk->heads < 2 && disk->cylinders > 1)
d86 3
a88 3
	mbr->part[3].ecyl = disk->cylinders - 1;
	mbr->part[3].ehead = disk->heads - 1;
	mbr->part[3].esect = disk->sectors;
d91 1
a91 1
	PRT_fix_BN(disk, &mbr->part[3], 3);
d100 1
a100 1
	PRT_fix_CHS(disk, &mbr->part[3]);
d108 1
a108 1
	PRT_fix_BN(disk, &mbr->part[3], 3);
d118 1
a118 1
	PRT_fix_CHS(disk, &mbr->part[3]);
d122 1
a122 2
MBR_parse(struct disk *disk, struct dos_mbr *dos_mbr, off_t offset,
    off_t reloff, struct mbr *mbr)
d135 1
a135 1
		PRT_parse(disk, &dos_parts[i], offset, reloff, &mbr->part[i]);
d211 1
a211 1
MBR_pcopy(struct disk *disk, struct mbr *mbr)
d217 1
a217 1
	fd = DISK_open(disk->name, O_RDONLY);
d227 1
a227 1
		PRT_parse(disk, &dos_parts[i], 0, 0, &mbr->part[i]);
@


1.45
log
@Zap unused variable.

Diff from chl@@. Committing now so it doesn't get lost in upcoming
megachurn.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.44 2015/03/14 15:21:53 krw Exp $	*/
d214 2
a216 2
	struct dos_mbr dos_mbr;
	struct dos_partition dos_parts[NDOSPART];
d237 1
a238 1
	const int secsize = unit_types[SECTORS].conversion;
@


1.44
log
@Switch all the license blocks to the standard OpenBSD/ISC license.

With the permission of Toby.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.43 2015/02/10 01:20:10 krw Exp $	*/
a294 1
	const int secsize = unit_types[SECTORS].conversion;
@


1.43
log
@If 'write' is issued after a 'reinit' command, and the MBR to be
written does not contain an EFI partition, zap any GPT signature
found on the 2nd (LBA 1) and last sectors on the disk. The install
script uses this sequence.

This is a temporary workaround until more GPT support is imported
post-5.7.

Should fix at least some machines who insist on using the GPT even
after we have overritten the 'protective' MBR.

ok deraadt@@ tedu@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.42 2015/01/16 06:39:57 deraadt Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.42
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.41 2015/01/03 15:50:50 jsing Exp $	*/
a181 3
	const int secsize = unit_types[SECTORS].conversion;
	ssize_t len;
	off_t off;
d184 1
a184 6
	where *= secsize;
	off = lseek(fd, where, SEEK_SET);
	if (off != where)
		return (-1);

	secbuf = calloc(1, secsize);
a187 1
	len = read(fd, secbuf, secsize);
a190 8
	if (len == -1)
		return (-1);
	if (len < sizeof(*dos_mbr)) {
		/* short read */
		errno = EIO;
		return (-1);
	}

a196 3
	const int secsize = unit_types[SECTORS].conversion;
	ssize_t len;
	off_t off;
d199 1
a199 7
	/* Read the sector we want to store the MBR in. */
	where *= secsize;
	off = lseek(fd, where, SEEK_SET);
	if (off != where)
		return (-1);

	secbuf = calloc(1, secsize);
a202 4
	len = read(fd, secbuf, secsize);
	if (len == -1 || len != secsize)
		goto done;

d208 2
a209 5
	off = lseek(fd, where, SEEK_SET);
	if (off == where)
		len = write(fd, secbuf, secsize);
	else
		len = -1;
a210 1
done:
a211 7
	if (len == -1)
		return (-1);
	if (len != secsize) {
		/* short read or write */
		errno = EIO;
		return (-1);
	}
a212 1
	ioctl(fd, DIOCRLDINFO, 0);
d238 100
@


1.41
log
@Add support for creating a protective MBR for GPT.

Part of a diff by Markus Mueller, which was derived from Bitrig during
Google Summer of Code, with further tweaks by me.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.40 2014/05/21 15:55:19 krw Exp $	*/
d28 1
a28 1
#include <sys/types.h>
a31 1
#include <sys/param.h>
@


1.40
log
@Fix 'fdisk -u', a.k.a. MBR_pcopy(), on sparc64 and possibly others.

gcc's built-in/in-lined memcpy() can't copy elements of a struct
dos_partiton array from inside the __packed struct dos_mbr into an
'unpacked' local variable. But copying the whole array works fine. Be
consistant and use the same idiom in both places the partition table
is parsed.

Leave the landisk workaround/hack in place until it can be confirmed
it is no longer needed.

ok martynas@@ after many alternatives crashed and burned.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.39 2014/03/31 19:50:52 krw Exp $	*/
d49 15
d66 2
d69 5
a73 1
	u_int64_t adj;
@


1.39
log
@Nuke [get|put][short|long] and just use letoh[16|32] and
htole[16|32]. This is made possible by a) copying unaligned data
(struct dos_partition's) into properly aligned structs and accessing
the fields of the same; and b) realizing that gcc is smart enough to
access fields in packed struct's *if* it knows it is accessing a
packed struct. Even sparc64 finally gave a thumbs up.

After several attempts and feedback from deraadt@@ and dlg@@, it looks
good to deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.38 2014/03/17 16:40:00 krw Exp $	*/
d114 1
a114 1
	struct dos_partition dos_partition;
d122 4
a125 6
	for (i = 0; i < NDOSPART; i++) {
		memcpy(&dos_partition, &dos_mbr->dmbr_parts[i],
		    sizeof(dos_partition));
		PRT_parse(disk, &dos_partition, offset, reloff,
		    &mbr->part[i]);
	}
d247 1
d256 2
d259 1
a259 1
		PRT_parse(disk, &dos_mbr.dmbr_parts[i], 0, 0, &mbr->part[i]);
@


1.38
log
@Nuke pointless blank lines, defines, comments and casts. Eliminate
#include in *.h files in favour of listing them as required in the *.c
files. Fix error message to correctly state that 64 is the minimum
value for -l. Use errx() where errno is not relevant. Use 'continue'
rather than a label to go back to start of a loop.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.37 2014/03/17 13:15:44 krw Exp $	*/
d114 1
d120 1
a120 1
	mbr->signature = getshort(&dos_mbr->dmbr_sign);
d122 4
a125 2
	for (i = 0; i < NDOSPART; i++)
		PRT_parse(disk, &dos_mbr->dmbr_parts[i], offset, reloff,
d127 1
d133 1
d137 1
a137 1
	putshort(&dos_mbr->dmbr_sign, DOSMBR_SIGNATURE);
d139 1
a139 1
	for (i = 0; i < NDOSPART; i++)
d141 4
a144 1
		    &dos_mbr->dmbr_parts[i]);
@


1.37
log
@Un-revert, being careful to not break snap building. Add paranoia check
for any missing geometry.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.36 2014/03/14 15:41:33 krw Exp $	*/
d44 1
a46 2
#include "part.h"

d145 1
a145 2
	printf("Signature: 0x%X\n",
	    (int)mbr->signature);
@


1.36
log
@Revert last -- broke building snaps.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.35 2014/03/13 12:02:28 krw Exp $	*/
d65 1
a65 1
	if (disk->real->heads > 1)
d69 1
a69 1
	if (disk->real->heads < 2 && disk->real->cylinders > 1)
d76 3
a78 3
	mbr->part[3].ecyl = disk->real->cylinders - 1;
	mbr->part[3].ehead = disk->real->heads - 1;
	mbr->part[3].esect = disk->real->sectors;
@


1.35
log
@Merge 'struct DISK_metrics' and 'struct disk' into one, since we don't
need to record two sets of metric/geometry data. Use 'geometry'
instead of 'metrics' in names and comments. Eliminate
DISK_getmetrics().

While here, make 64 the minimal valid value for '-l' instead of 1. This
avoids the possibility of having 0 cylinders.

No intentional functional change.

Feedback & tweak from chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.34 2014/03/09 22:25:06 krw Exp $	*/
d65 1
a65 1
	if (disk->heads > 1)
d69 1
a69 1
	if (disk->heads < 2 && disk->cylinders > 1)
d76 3
a78 3
	mbr->part[3].ecyl = disk->cylinders - 1;
	mbr->part[3].ehead = disk->heads - 1;
	mbr->part[3].esect = disk->sectors;
@


1.34
log
@Instead of passing around 'char buf[DEV_BSIZE]' buffers, pass around
'struct dos_mbr' variables, since that is what the buffers were used
for. Removes need to know about DEV_BSIZE and thus include param.h
from all files but one so move the param.h #include to that file
(mbr.c).

Nuke a bunch of local MBR #defines in favour of the disklabel.h ones.

Remove a bunch of unneeded #includes, replace the odd malloc/bzero
with calloc, replace equally odd bcopy's with memcpy, remove a stray
duplicate MBR parsing in MBR_pcopy().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.33 2014/03/07 21:56:13 krw Exp $	*/
d65 1
a65 1
	if (disk->real->heads > 1)
d69 1
a69 1
	if (disk->real->heads < 2 && disk->real->cylinders > 1)
d76 3
a78 3
	mbr->part[3].ecyl = disk->real->cylinders - 1;
	mbr->part[3].ehead = disk->real->heads - 1;
	mbr->part[3].esect = disk->real->sectors;
@


1.33
log
@Relieve the code of an overburden of unnecessary typedef
abstraction. Call a 'struct' a 'struct' and not a pony.

No functional change.

idea ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.32 2014/02/05 03:51:07 krw Exp $	*/
d32 1
d42 1
d112 2
a113 2
MBR_parse(struct disk *disk, char *mbr_buf, off_t offset, off_t reloff,
    struct mbr *mbr)
d117 1
a117 1
	memcpy(mbr->code, mbr_buf, MBR_CODE_SIZE);
d120 1
a120 1
	mbr->signature = getshort(&mbr_buf[MBR_SIG_OFF]);
d123 2
a124 2
		PRT_parse(disk, &mbr_buf[MBR_PART_OFF + MBR_PART_SIZE * i],
		    offset, reloff, &mbr->part[i]);
d128 1
a128 1
MBR_make(struct mbr *mbr, char *mbr_buf)
d132 2
a133 2
	memcpy(mbr_buf, mbr->code, MBR_CODE_SIZE);
	putshort(&mbr_buf[MBR_SIG_OFF], DOSMBR_SIGNATURE);
d137 1
a137 1
		    &mbr_buf[MBR_PART_OFF + MBR_PART_SIZE * i]);
d156 1
a156 1
MBR_read(int fd, off_t where, char *buf)
d168 1
a168 1
	secbuf = malloc(secsize);
a170 1
	bzero(secbuf, secsize);
d173 1
a173 1
	bcopy(secbuf, buf, DEV_BSIZE);
d178 1
a178 1
	if (len < DEV_BSIZE) {
d188 1
a188 1
MBR_write(int fd, off_t where, char *buf)
d201 1
a201 1
	secbuf = malloc(secsize);
a203 1
	bzero(secbuf, secsize);
d210 1
a210 1
	 * Place the new MBR in the first DEV_BSIZE bytes of the sector and
d213 1
a213 1
	bcopy(buf, secbuf, DEV_BSIZE);
d235 2
a236 2
 * Copy partition table from the disk indicated
 * to the supplied mbr structure
d241 2
a242 3
	int i, fd, error, offset = 0, reloff = 0;
	struct mbr mbrd;
	char mbr_disk[DEV_BSIZE];
d245 1
a245 1
	error = MBR_read(fd, offset, mbr_disk);
d247 1
d250 3
a252 6
	MBR_parse(disk, mbr_disk, offset, reloff, &mbrd);
	for (i = 0; i < NDOSPART; i++) {
		PRT_parse(disk, &mbr_disk[MBR_PART_OFF +
		    MBR_PART_SIZE * i],
		    offset, reloff, &mbr->part[i]);
	}
@


1.32
log
@Always set the signature to DOSMBR_SIGNATURE when writing a MBR to
disk. This means skipping the '(U)pdate' command after editing
the MBR will still produce something disklabel(8) will respect in
the morning.

Problem noted by David Vasek.

ok jsing@@ toby@@. Moral support halex@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.31 2013/10/08 15:45:43 krw Exp $	*/
d48 1
a48 1
MBR_init(disk_t *disk, mbr_t *mbr)
d110 2
a111 1
MBR_parse(disk_t *disk, char *mbr_buf, off_t offset, off_t reloff, mbr_t *mbr)
d126 1
a126 1
MBR_make(mbr_t *mbr, char *mbr_buf)
d139 1
a139 1
MBR_print(mbr_t *mbr, char *units)
d239 1
a239 1
MBR_pcopy(disk_t *disk, mbr_t *mbr)
d242 1
a242 1
	mbr_t mbrd;
@


1.31
log
@Keep disk sector calcuations in u_int64_t as long as possible, and
avoid using a daddr_t variable to hold a disk sector value even
temporarily.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.30 2013/06/11 16:42:04 deraadt Exp $	*/
d130 1
a130 1
	putshort(&mbr_buf[MBR_SIG_OFF], mbr->signature);
@


1.30
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.29 2013/03/21 18:45:58 deraadt Exp $	*/
d51 1
a51 1
	int adj;
d103 1
a103 2
	i = DL_BLKTOSEC(&dl, i);
	adj = i - mbr->part[3].bs;
@


1.29
log
@more substantial include cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.28 2012/04/04 13:14:44 krw Exp $	*/
d50 1
a50 1
	daddr64_t i;
@


1.28
log
@Don't 'reserve' a head/track if there is only only 1 head and 1
cylinder.  If there is only one head but multiple cylinders reserve
one cylinder. Prevents nonsense MBR being created on scsi attached
floppies, which have a 'geometry' of 1/1/2888. No change to less
pathological cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.27 2011/06/20 19:10:41 krw Exp $	*/
d28 6
a40 7
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <machine/param.h>
@


1.27
log
@MBR_read() can be reading from a file as well as a raw partition.
And files can be smaller (e.g. 512 bytes like /usr/mdec/mbr) than
a disk sector (e.g. 4096 bytes on pirofti's external disk drive).

So relax the length test on the read() result to < DEV_BSIZE (the
amount of data we actually want) instead of < secsize (the minimum
size that read() will accept).

'fdisk -e' and 'fdisk -i' now work on devices with sector sizes
greater than DEV_BSIZE.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.26 2011/02/21 19:26:13 krw Exp $	*/
d62 1
a62 1
	/* Use whole disk, save for first head, on first cyl. */
d64 8
a71 2
	mbr->part[3].scyl = 0;
	mbr->part[3].shead = 1;
@


1.26
log
@Honour MBR_read() results and don't pretend we can parse blocks we
did not successfully read. Tweak some casts.

Fixes infinite loop problem noted by jeremy@@ while installing on
boxen with 'random' garbage in MBR. General loop detection may
follow post-4.9.

Tested by jeremy@@ and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.25 2010/06/30 22:53:41 krw Exp $	*/
d172 1
a172 1
	if (len != secsize) {
@


1.25
log
@Make 'fdisk -i' start the OpenBSD partition on a power of 2 512-byte
block boundary. In most modern (i.e. 'faked' geometry) situations
this will start it at (0-based) block[64] rather than block[63] as
now. This should help performance on disks which really have 4K
sectors but report 512-byte sectors.

Power of 2 idea from deraadt@@.

ok toby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.24 2009/02/08 18:03:18 krw Exp $	*/
d236 1
a236 1
	int i, fd, offset = 0, reloff = 0;
d241 1
a241 1
	MBR_read(fd, offset, mbr_disk);
d243 2
@


1.24
log
@Eliminate excessive verbiage for 'fdisk -i' and 'fdisk -u'. Especially
the multi-line banner announcing that the MBR is being changed.
Also the listing of the partition table in 'fdisk -u'. Display a
consistant message when the MBR is written.

While here cleanup and shrink code without changing any semantics.
Started with a diff posted on tech@@ by Tobias Ulmer.

"I like it" marco@@ ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.23 2006/12/10 19:19:32 krw Exp $	*/
d51 3
d93 10
@


1.23
log
@Read/write device sectors rather than assuming sector size ==
DEV_BSIZE. Simply extract/insert the desired MBR from/into the first
DEV_BSIZE bytes of the sector.  Makes fdisk work with devices having a
sector size different from DEV_BSIZE (512 bytes). e.g.  2048 byte
sector MP3 devices. Original diff from weingart@@.

ok pedro@@ deraadt@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.22 2006/05/29 05:09:36 ray Exp $	*/
d229 1
a229 1
	DISK_close(fd);
a234 1
		PRT_print(i, &mbr->part[i], NULL);
@


1.22
log
@Change MBR_read() and MBR_write() to return -1 on error and set
errno = EIO for short reads.  This makes it easier to check for
read and write errors.  Much patient tutoring by weingart@@, deraadt@@,
and cloder@@.

Correctly use ssize_t to store read(2) and write(2) return values.

No functional change, since MBR_read() and MBR_write() return values
aren't currently checked.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.21 2004/09/18 23:22:05 deraadt Exp $	*/
d33 1
d138 2
d141 1
a141 1
	ssize_t len;
d143 1
a143 1
	where *= DEV_BSIZE;
d147 10
a156 1
	len = read(fd, buf, DEV_BSIZE);
d159 1
a159 1
	if (len != DEV_BSIZE) {
d164 1
d171 2
d174 1
a174 1
	ssize_t len;
d176 2
a177 1
	where *= DEV_BSIZE;
d181 23
a203 1
	len = write(fd, buf, DEV_BSIZE);
d206 2
a207 2
	if (len != DEV_BSIZE) {
		/* short write */
d211 2
a212 1
	(void) ioctl(fd, DIOCRLDINFO, 0);
@


1.21
log
@some delinting; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.20 2004/07/13 06:00:33 tom Exp $	*/
d29 1
d138 1
a138 1
	int len;
d143 1
a143 1
		return (off);
d145 7
a151 2
	if (len != DEV_BSIZE)
		return (len);
d159 1
a159 1
	int len;
d164 1
a164 1
		return (off);
d166 7
a172 2
	if (len != DEV_BSIZE)
		return (len);
@


1.20
log
@Remove unused argument 'int pn' to PRT_fix_CHS().  The 'int pn'
argument to PRT_parse() then becomes unused, so remove that too.

ok henning@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.19 2003/07/29 18:38:35 deraadt Exp $	*/
d166 4
a172 5
	/*
	 * Copy partition table from the disk indicated
	 * to the supplied mbr structure
	 */

d183 2
a184 2
					 MBR_PART_SIZE * i],
			  offset, reloff, &mbr->part[i]);
@


1.19
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.18 2003/06/11 06:22:12 deraadt Exp $	*/
d78 1
a78 1
	PRT_fix_CHS(disk, &mbr->part[3], 3);
d102 1
a102 1
		    offset, reloff, &mbr->part[i], i);
d185 1
a185 1
			  offset, reloff, &mbr->part[i], i);
@


1.18
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.17 2003/06/03 01:13:19 weingart Exp $	*/
d177 1
a177 1
	
@


1.17
log
@Nuke terms 3 & 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.16 2002/06/09 08:13:05 todd Exp $	*/
d47 1
a47 3
MBR_init(disk, mbr)
	disk_t *disk;
	mbr_t *mbr;
d91 1
a91 6
MBR_parse(disk, mbr_buf, offset, reloff, mbr)
	disk_t *disk;
	char *mbr_buf;
	off_t offset;
	off_t reloff;
	mbr_t *mbr;
d106 1
a106 3
MBR_make(mbr, mbr_buf)
	mbr_t *mbr;
	char *mbr_buf;
d119 1
a119 3
MBR_print(mbr, units)
	mbr_t *mbr;
	char *units;
d134 1
a134 4
MBR_read(fd, where, buf)
	int fd;
	off_t where;
	char *buf;
d150 1
a150 4
MBR_write(fd, where, buf)
	int fd;
	off_t where;
	char *buf;
d167 1
a167 3
MBR_pcopy(disk, mbr)
	disk_t *disk;
	mbr_t *mbr;
@


1.16
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.15 2002/01/18 08:38:26 kjell Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.15
log
@Allow size values to be displayed in the user's choice of units.
Idea borrowed from disklabel. i.e. Users can now type "print M"
and be rewarded with partition sizes in Megs
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.14 2002/01/04 08:35:06 kjell Exp $	*/
d113 1
a113 1
		PRT_parse(disk, &mbr_buf[MBR_PART_OFF + MBR_PART_SIZE * i], 
d128 1
a128 1
		PRT_make(&mbr->part[i], mbr->offset, mbr->reloffset, 
d188 1
a188 1
void 
d193 1
a193 1
	/* 
d195 1
a195 1
	 * to the supplied mbr structure 
d208 1
a208 1
					 MBR_PART_SIZE * i], 
@


1.14
log
@Remove references to the NT serial number. Now the first 0x1be
bytes of the MBR are treated as code for the purposes of the
(u)pdate command. This is consistent with the new -u flag.
This means boot managers like BootEasy can now be written
out correctly. Note that rewriting the MBR now whacks the
NT serial number - a behavior that is consistent with
the DOS FDISK /MBR.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.13 2001/12/15 02:12:26 kjell Exp $	*/
d133 1
a133 1
MBR_print(mbr)
d135 1
d142 1
a142 1
	PRT_print(0, NULL);
d146 1
a146 1
		PRT_print(i, &mbr->part[i]);
d210 1
a210 1
		PRT_print(i, &mbr->part[i]);
@


1.13
log
@Get this damn diff out of my tree. ok from weingart@@, deraadt@@ and others.
Add a -u flag to fdisk which updates MBR code, but leaves the partition
table intact. There are still issues with 'update' having different behavior,
but I'll resolve those shortly
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.12 2001/01/28 00:51:46 weingart Exp $	*/
a109 2
	mbr->nt_serial = getlong(&mbr_buf[MBR_NTSER_OFF]);
	mbr->spare = getshort(&mbr_buf[MBR_SPARE_OFF]);
a124 2
	putlong(&mbr_buf[MBR_NTSER_OFF], mbr->nt_serial);
	putshort(&mbr_buf[MBR_SPARE_OFF], mbr->spare);
d139 2
a140 2
	printf("Signatures: 0x%X,0x%X\n",
	    (int)mbr->signature, (int)mbr->nt_serial);
@


1.12
log
@Quick -Wall fixes, ok niklas@@, aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.11 2000/07/07 13:37:00 rahnds Exp $	*/
d189 26
@


1.11
log
@On the last commit to fdisk when the prototypes to PRT_fix_CHS and PRT_fix_BN
were made, some code in an ifdefed section was missed. Update that
section of code to have the appropriate added parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.10 2000/07/01 21:49:12 mickey Exp $	*/
d39 1
d50 5
a54 1
MBR_init(disk_t *disk, mbr_t *mbr)
@


1.10
log
@be more verbose when warning for partition errors,
print partition number in the message.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.9 1999/08/21 22:49:25 niklas Exp $	*/
d80 1
a80 1
	PRT_fix_CHS(disk, &mbr->part[3]);
d88 1
a88 1
	PRT_fix_BN(disk, &mbr->part[3]);
@


1.9
log
@MIPS boxes that use fdisk need an MS-DOS partition
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.8 1999/08/10 23:10:16 deraadt Exp $	*/
d71 1
a71 1
	PRT_fix_BN(disk, &mbr->part[3]);
d111 1
a111 2
		    offset, reloff,
		    &mbr->part[i]);
@


1.8
log
@call DIOCRLDINFO after writing an MBR
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.7 1998/09/14 03:54:35 rahnds Exp $	*/
d73 1
a73 1
#if defined(__powerpc__)
d82 1
a82 1
		/* align the parition on a cylinder boundary */
@


1.7
log
@Since on the powerpc, the system does not supply the user with
bios valid cyl,head,sector information (the information comes from the
sd driver) I have made some changes to fdisk to do the following.

Allow the powerpc to specify values larger than the bios limits.

All platforms now have code that will translate the LBA values
in the mbr into CHS values according to the disk geometry.
This occurs if the start and ending CHS values have been stored as
0xffffff.

If writing to the disk and one of the values of a partition violates
the bios limits, it writes the requested values in the LBA fields ,
and stores 0xffffff for the starting and ending CHS values.

This should not change the default formatting of any existing system
other than the CHS and LBA values should always match given the detected
geometry of the disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.6 1997/10/21 22:49:33 provos Exp $	*/
d42 1
d183 1
@


1.6
log
@make fdisk grok extended partitions again. we have to keep track of the
absolute offset of the current mbr and its relative position. because:
the starting sector of the first mbr entry in an extended partition is relative
to the starting offset of the whole mbr itself. the starting offset of a new
extended partition is relative to the offset of the very first extended
partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.5 1997/10/19 23:30:47 deraadt Exp $	*/
d48 42
d92 2
a93 1
MBR_parse(mbr_buf, offset, reloff, mbr)
d109 1
a109 1
		PRT_parse(&mbr_buf[MBR_PART_OFF + MBR_PART_SIZE * i], 
@


1.5
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.4 1997/10/19 23:29:37 deraadt Exp $	*/
d50 1
a50 1
MBR_parse(mbr_buf, mbr)
d52 2
d59 2
d66 2
a67 1
		PRT_parse(&mbr_buf[MBR_PART_OFF + MBR_PART_SIZE * i],
d84 2
a85 2
		PRT_make(&mbr->part[i], &mbr_buf[MBR_PART_OFF +
		    MBR_PART_SIZE * i]);
@


1.4
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.3 1997/10/16 01:47:11 deraadt Exp $	*/
d111 1
a111 1
		return(off);
d114 2
a115 2
		return(len);
	return(0);
d130 1
a130 1
		return(off);
d133 2
a134 2
		return(len);
	return(0);
@


1.3
log
@a bunch of improvements by weingart & I
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.2 1997/09/29 23:33:36 mickey Exp $	*/
d61 3
a63 2
	for(i = 0; i < NDOSPART; i++)
		PRT_parse(&mbr_buf[MBR_PART_OFF + MBR_PART_SIZE * i], &mbr->part[i]);
d78 3
a80 2
	for(i = 0; i < NDOSPART; i++)
		PRT_make(&mbr->part[i], &mbr_buf[MBR_PART_OFF + MBR_PART_SIZE * i]);
d91 1
a91 1
		(int)mbr->signature, (int)mbr->nt_serial);
d95 1
a95 1
	for(i = 0; i < NDOSPART; i++){
a96 1
	}
d110 2
a111 2
	if(off != where) return(off);

d113 2
a114 2
	if(len != DEV_BSIZE) return(len);

d129 2
a130 2
	if(off != where) return(off);

d132 2
a133 2
	if(len != DEV_BSIZE) return(len);

a135 1

@


1.2
log
@ID in the first line w/ tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.c,v 1.1 1997/09/29 22:58:16 weingart Exp $	*/
a86 3
	printf("NT Serial #: %d\n", (int)mbr->nt_serial);
	printf("Signature #: 0x%X\n\n", (int)mbr->signature);

d88 2
@


1.1
log
@New fdisk code with interactive (command line type)
editing code.  Rewrite from the ground up, save about
20 lines of code.  Seems to create valid partition
tables on i386 and alphas.
@
text
@d1 1
a1 2

/* $OpenBSD$ */
@
