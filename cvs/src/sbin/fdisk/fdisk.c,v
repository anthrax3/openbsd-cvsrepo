head	1.102;
access;
symbols
	OPENBSD_6_1_BASE:1.102
	OPENBSD_6_0:1.101.0.2
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.99.0.2
	OPENBSD_5_9_BASE:1.99
	OPENBSD_5_8:1.74.0.4
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.53.0.4
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.6
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.52.0.4
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.10
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.6
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.4
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.47.0.2
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.40.0.4
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.39.0.4
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.34.0.6
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.34.0.4
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.34.0.2
	OPENBSD_3_1_BASE:1.34
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9:1.31.0.6
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_8:1.31.0.4
	OPENBSD_2_8_BASE:1.31
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	OPENBSD_2_6:1.30.0.6
	OPENBSD_2_6_BASE:1.30
	OPENBSD_2_5:1.30.0.4
	OPENBSD_2_5_BASE:1.30
	OPENBSD_2_4:1.30.0.2
	OPENBSD_2_4_BASE:1.30
	OPENBSD_2_3:1.29.0.4
	OPENBSD_2_3_BASE:1.29
	OPENBSD_2_2:1.29.0.2
	OPENBSD_2_2_BASE:1.29
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.102
date	2016.12.27.15.01.03;	author krw;	state Exp;
branches;
next	1.101;
commitid	esTMNhggsn9ESVoW;

1.101
date	2016.06.25.17.03.22;	author tb;	state Exp;
branches;
next	1.100;
commitid	HmQm9ojS62FoHcAn;

1.100
date	2016.03.28.16.55.09;	author mestre;	state Exp;
branches;
next	1.99;
commitid	hnF10eTyfJL7bTTO;

1.99
date	2015.12.12.04.14.36;	author krw;	state Exp;
branches;
next	1.98;
commitid	YOcH53Fv4Tf2fZMK;

1.98
date	2015.12.12.02.49.50;	author krw;	state Exp;
branches;
next	1.97;
commitid	oF2xrlPNdHxVB5pd;

1.97
date	2015.12.11.21.57.31;	author krw;	state Exp;
branches;
next	1.96;
commitid	96L1vk3QTF4FoRGz;

1.96
date	2015.12.01.06.25.43;	author krw;	state Exp;
branches;
next	1.95;
commitid	3yqmv4fQXNy47uT4;

1.95
date	2015.11.24.01.01.56;	author deraadt;	state Exp;
branches;
next	1.94;
commitid	Gvv1MUn0PltcAKuH;

1.94
date	2015.11.19.17.52.56;	author krw;	state Exp;
branches;
next	1.93;
commitid	66GDoLrKYN3KMCAX;

1.93
date	2015.11.18.15.31.15;	author krw;	state Exp;
branches;
next	1.92;
commitid	BGaJX0YBjBKscKAZ;

1.92
date	2015.11.18.15.10.43;	author krw;	state Exp;
branches;
next	1.91;
commitid	ljXgiw5JJ8D2SyT8;

1.91
date	2015.11.18.02.32.56;	author krw;	state Exp;
branches;
next	1.90;
commitid	hYzJyy8R5UjhxR2x;

1.90
date	2015.11.18.01.53.12;	author krw;	state Exp;
branches;
next	1.89;
commitid	ZSH627In30yl7Aun;

1.89
date	2015.11.15.01.22.39;	author krw;	state Exp;
branches;
next	1.88;
commitid	pdnGXAhMRWkTnGsH;

1.88
date	2015.11.14.21.17.08;	author krw;	state Exp;
branches;
next	1.87;
commitid	AZ3aaJIF3rj1GOvz;

1.87
date	2015.11.14.17.42.31;	author krw;	state Exp;
branches;
next	1.86;
commitid	iPVdJEmvhpGg5rDA;

1.86
date	2015.11.14.00.20.59;	author krw;	state Exp;
branches;
next	1.85;
commitid	STnnRjhdJh68srZ3;

1.85
date	2015.11.14.00.13.47;	author krw;	state Exp;
branches;
next	1.84;
commitid	XgDtnkrY0KwINbys;

1.84
date	2015.11.13.22.27.35;	author krw;	state Exp;
branches;
next	1.83;
commitid	bMvRLzfRSiH80Zhk;

1.83
date	2015.11.13.21.54.10;	author krw;	state Exp;
branches;
next	1.82;
commitid	llFHfHVKD2hzM0sY;

1.82
date	2015.11.13.15.32.36;	author krw;	state Exp;
branches;
next	1.81;
commitid	1XJY7zSB9uhtdErH;

1.81
date	2015.11.13.02.27.17;	author krw;	state Exp;
branches;
next	1.80;
commitid	4K9a6NDKqAi1JXz9;

1.80
date	2015.11.11.15.39.18;	author krw;	state Exp;
branches;
next	1.79;
commitid	NAurcNtvybUXnVMU;

1.79
date	2015.10.26.15.08.26;	author krw;	state Exp;
branches;
next	1.78;
commitid	fOI5D0M32zdW7eoe;

1.78
date	2015.10.05.01.39.08;	author krw;	state Exp;
branches;
next	1.77;
commitid	2xnXUR8eGYteWRoe;

1.77
date	2015.09.06.09.06.23;	author jmc;	state Exp;
branches;
next	1.76;
commitid	9JRuyiCtIPWrRfYx;

1.76
date	2015.09.04.21.19.45;	author jmc;	state Exp;
branches;
next	1.75;
commitid	zhxePiAqxwY9mF1U;

1.75
date	2015.09.04.19.02.49;	author kettenis;	state Exp;
branches;
next	1.74;
commitid	7P9obYFrIDpMNPYf;

1.74
date	2015.07.09.19.48.36;	author krw;	state Exp;
branches;
next	1.73;
commitid	5cyaBijHu9KyGt8S;

1.73
date	2015.07.08.23.44.56;	author krw;	state Exp;
branches;
next	1.72;
commitid	ACZkjXXKNycHdYdT;

1.72
date	2015.03.19.15.44.12;	author krw;	state Exp;
branches;
next	1.71;
commitid	Wb8MxHeuSDWOUTSU;

1.71
date	2015.03.18.14.46.59;	author krw;	state Exp;
branches;
next	1.70;
commitid	9oRFFmwrkHklH7n4;

1.70
date	2015.03.17.21.42.15;	author krw;	state Exp;
branches;
next	1.69;
commitid	XLe2uvrVSjySe36w;

1.69
date	2015.03.16.23.51.50;	author krw;	state Exp;
branches;
next	1.68;
commitid	JG85Pc2Xt4lLAJpr;

1.68
date	2015.03.16.18.45.51;	author krw;	state Exp;
branches;
next	1.67;
commitid	mp8WjRkElVZwIbfW;

1.67
date	2015.03.14.18.32.29;	author krw;	state Exp;
branches;
next	1.66;
commitid	VCsOzs6eGW0SpJ6c;

1.66
date	2015.03.14.15.21.53;	author krw;	state Exp;
branches;
next	1.65;
commitid	aPXwn1AfAIMw4FVu;

1.65
date	2015.02.09.04.27.15;	author krw;	state Exp;
branches;
next	1.64;
commitid	hdzyTUV8r2DhhgJ1;

1.64
date	2015.01.03.15.50.50;	author jsing;	state Exp;
branches;
next	1.63;
commitid	Hkl9onJ3wjSN2qH0;

1.63
date	2014.03.20.13.18.21;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2014.03.17.16.40.00;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.17.13.15.44;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2014.03.14.15.41.33;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.13.12.02.28;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2014.03.09.22.25.06;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.07.21.56.13;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2014.03.06.17.39.23;	author jmc;	state Exp;
branches;
next	1.55;

1.55
date	2014.03.02.15.41.28;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2013.03.21.18.45.58;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2011.12.25.19.13.51;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2011.02.21.19.26.12;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2010.05.25.18.51.02;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2010.03.22.15.25.47;	author otto;	state Exp;
branches;
next	1.49;

1.49
date	2010.02.17.20.19.05;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2007.12.30.13.20.13;	author sobrado;	state Exp;
branches;
next	1.47;

1.47
date	2007.04.26.23.39.01;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.11.09.00.01.10;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.08.23.57.05;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.08.23.22.26;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.27.04.53.27;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.27.04.06.13;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.09.21.19.41;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.01.20.53.38;	author jmc;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.03.09.22.03;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.07.16.28.52;	author tom;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.02.21.44.57;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.03.01.13.19;	author weingart;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.15.02.12.26;	author kjell;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.02.13.51.17;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.23.01.54.38;	author kjell;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.08.04.51.16;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.09.14.03.54.34;	author rahnds;	state Exp;
branches;
next	1.29;

1.29
date	97.10.28.03.12.14;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	97.10.21.22.49.33;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	97.10.19.23.30.47;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.10.19.23.29.36;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.10.16.01.47.10;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.10.14.21.21.33;	author pefo;	state Exp;
branches;
next	1.23;

1.23
date	97.09.29.23.33.35;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.09.29.23.16.59;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.09.29.22.58.16;	author weingart;	state Exp;
branches;
next	1.20;

1.20
date	97.09.29.22.50.06;	author weingart;	state Exp;
branches;
next	1.19;

1.19
date	97.07.06.18.19.29;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.04.17.12.31.46;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	97.04.15.09.02.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.04.14.22.18.57;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	97.04.11.10.01.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.04.06.23.54.44;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.04.02.05.30.05;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.01.31.11.59.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.01.27.21.57.36;	author rahnds;	state Exp;
branches;
next	1.10;

1.10
date	97.01.10.19.09.58;	author jkatz;	state Exp;
branches;
next	1.9;

1.9
date	96.09.30.12.08.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.27.15.36.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.27.15.34.49;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.27.15.27.03;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.27.14.32.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.25.11.24.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.17.08.27.26;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.03.07.54.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.102
log
@The "disk too large" and "only LBA values saved" messages are more
often confusing than useful these days. Stop emitting them.

Prompted by bugs@@ report of the 8TB disk travails of Jiri.

ok deraadt@@ tom@@
@
text
@/*	$OpenBSD: fdisk.c,v 1.101 2016/06/25 17:03:22 tb Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/fcntl.h>
#include <sys/disklabel.h>

#include <err.h>
#include <paths.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "disk.h"
#include "part.h"
#include "mbr.h"
#include "misc.h"
#include "cmd.h"
#include "user.h"
#include "gpt.h"

#define _PATH_MBR _PATH_BOOTDIR "mbr"
static unsigned char builtin_mbr[] = {
#include "mbrcode.h"
};

u_int32_t b_arg;
int	y_flag;

static void
usage(void)
{
	extern char * __progname;

	fprintf(stderr, "usage: %s "
	    "[-egvy] [-i|-u] [-b #] [-c # -h # -s #] "
	    "[-f mbrfile] [-l # ] disk\n"
	    "\t-b: specify special boot partition block count; requires -i\n"
	    "\t-chs: specify disk geometry; all three must be specified\n"
	    "\t-e: interactively edit MBR or GPT\n"
	    "\t-f: specify non-standard MBR template\n"
	    "\t-g: initialize disk with GPT; requires -i\n"
	    "\t-i: initialize disk with MBR unless -g is also specified\n"
	    "\t-l: specify LBA block count; cannot be used with -chs\n"
	    "\t-u: update MBR code; preserve partition table\n"
	    "\t-v: print the MBR, the Primary GPT and the Secondary GPT\n"
	    "\t-y: do not ask questions\n"
	    "`disk' may be of the forms: sd0 or /dev/rsd0c.\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	ssize_t len;
	int ch, fd, error;
	int e_flag = 0, g_flag = 0, i_flag = 0, u_flag = 0;
	int verbosity = 0;
	int c_arg = 0, h_arg = 0, s_arg = 0;
	u_int32_t l_arg = 0;
	char *query;
#ifdef HAS_MBR
	char *mbrfile = _PATH_MBR;
#else
	char *mbrfile = NULL;
#endif
	struct dos_mbr dos_mbr;
	struct mbr mbr;

	while ((ch = getopt(argc, argv, "iegpuvf:c:h:s:l:b:y")) != -1) {
		const char *errstr;

		switch(ch) {
		case 'i':
			i_flag = 1;
			break;
		case 'u':
			u_flag = 1;
			break;
		case 'e':
			e_flag = 1;
			break;
		case 'f':
			mbrfile = optarg;
			break;
		case 'c':
			c_arg = strtonum(optarg, 1, 262144, &errstr);
			if (errstr)
				errx(1, "Cylinder argument %s [1..262144].",
				    errstr);
			disk.cylinders = c_arg;
			disk.size = c_arg * h_arg * s_arg;
			break;
		case 'h':
			h_arg = strtonum(optarg, 1, 256, &errstr);
			if (errstr)
				errx(1, "Head argument %s [1..256].", errstr);
			disk.heads = h_arg;
			disk.size = c_arg * h_arg * s_arg;
			break;
		case 's':
			s_arg = strtonum(optarg, 1, 63, &errstr);
			if (errstr)
				errx(1, "Sector argument %s [1..63].", errstr);
			disk.sectors = s_arg;
			disk.size = c_arg * h_arg * s_arg;
			break;
		case 'g':
			g_flag = 1;
			break;
		case 'b':
			b_arg = strtonum(optarg, 64, UINT32_MAX, &errstr);
			if (errstr)
				errx(1, "Block argument %s [64..%u].", errstr,
				    UINT32_MAX);
			break;
		case 'l':
			l_arg = strtonum(optarg, 64, UINT32_MAX, &errstr);
			if (errstr)
				errx(1, "Block argument %s [64..%u].", errstr,
				    UINT32_MAX);
			disk.cylinders = l_arg / 64;
			disk.heads = 1;
			disk.sectors = 64;
			disk.size = l_arg;
			break;
		case 'y':
			y_flag = 1;
			break;
		case 'v':
			verbosity++;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	/* Argument checking */
	if (argc != 1 || (i_flag && u_flag) ||
	    (i_flag == 0 && (b_arg || g_flag)) ||
	    ((c_arg | h_arg | s_arg) && !(c_arg && h_arg && s_arg)) ||
	    ((c_arg | h_arg | s_arg) && l_arg))
		usage();

	disk.name = argv[0];
	DISK_open(i_flag || u_flag || e_flag);

	/* "proc exec" for man page display */
	if (pledge("stdio rpath wpath disklabel proc exec", NULL) == -1)
		err(1, "pledge");

	error = MBR_read(0, &dos_mbr);
	if (error)
		errx(1, "Can't read sector 0!");
	MBR_parse(&dos_mbr, 0, 0, &mbr);

	/* Get the GPT if present. Either primary or secondary is ok. */
	if (MBR_protective_mbr(&mbr) == 0)
		GPT_get_gpt(0);

	if (!(i_flag || u_flag || e_flag)) {
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
		USER_print_disk(verbosity);
		goto done;
	}

	/* Create initial/default MBR. */
	if (mbrfile == NULL) {
		memcpy(&dos_mbr, builtin_mbr, sizeof(dos_mbr));
	} else {
		fd = open(mbrfile, O_RDONLY);
		if (fd == -1) {
			warn("%s", mbrfile);
			warnx("using builtin MBR");
			memcpy(&dos_mbr, builtin_mbr, sizeof(dos_mbr));
		} else {
			len = read(fd, &dos_mbr, sizeof(dos_mbr));
			close(fd);
			if (len == -1)
				err(1, "Unable to read MBR from '%s'", mbrfile);
			else if (len != sizeof(dos_mbr))
				errx(1, "Unable to read complete MBR from '%s'",
				    mbrfile);
		}
	}
	MBR_parse(&dos_mbr, 0, 0, &initial_mbr);

	query = NULL;
	if (i_flag) {
		reinited = 1;
		if (g_flag) {
			MBR_init_GPT(&initial_mbr);
			GPT_init();
			query = "Do you wish to write new GPT?";
		} else {
			MBR_init(&initial_mbr);
			query = "Do you wish to write new MBR and "
			    "partition table?";
		}
	} else if (u_flag) {
		memcpy(initial_mbr.part, mbr.part, sizeof(initial_mbr.part));
		query = "Do you wish to write new MBR?";
	}
	if (query && ask_yn(query))
		Xwrite(NULL, &initial_mbr);

	if (e_flag)
		USER_edit(0, 0);

done:
	close(disk.fd);

	return (0);
}
@


1.101
log
@Move pledge after opendev and DIOCGPDINFO. Fixes e.g. fdisk /dev/tty.
This diff by deraadt was overlooked far too many times, mostly by me.
It's the original fix of the pledge disklabel breakage found by espie.

diff by deraadt; ok semarie, tb.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.100 2016/03/28 16:55:09 mestre Exp $	*/
a179 6

	if (letoh64(gh.gh_sig) != GPTSIGNATURE) {
		if (DL_GETDSIZE(&dl) > disk.size)
			warnx("disk too large (%llu sectors). size truncated.",
			    (unsigned long long)DL_GETDSIZE(&dl));
	}
@


1.100
log
@Remove unused variables

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.99 2015/12/12 04:14:36 krw Exp $	*/
a87 4
	/* "proc exec" for man page display */
	if (pledge("stdio rpath wpath disklabel proc exec", NULL) == -1)
		err(1, "pledge");

d167 4
@


1.99
log
@In olden times (i + u + e) was considered a clever way to 'or'
together three boolean values. In today's englightened world we
know about '||'.

Pointed out by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.98 2015/12/12 02:49:50 krw Exp $	*/
d75 1
a75 1
	int e_flag = 0, f_flag = 0, g_flag = 0, i_flag = 0, u_flag = 0;
a105 1
			f_flag = 1;
@


1.98
log
@Open disk READONLY if none of i, e or u are specified.

Suggestion, original diff and ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.97 2015/12/11 21:57:31 krw Exp $	*/
d171 1
a171 1
	DISK_open(i_flag + u_flag + e_flag);
d188 1
a188 1
	if ((i_flag + u_flag + e_flag) == 0) {
@


1.97
log
@Add '-v' flag that forces the display of both GPT's and the MBR.
Useful for seeing exactly what is currently on the disk. Suggested
by a request from kettenis@@.

Man page & usage ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.96 2015/12/01 06:25:43 krw Exp $	*/
d171 1
a171 1
	DISK_open();
@


1.96
log
@Make '-i' set 'reinited' flag so that the initial Xwrite() will zap
any undesirable GPT hanging around. i.e. same as 'reinit' from the
fdisk(8) command line. Noticed now that install media relies on
'-i' rather than issuing 'reinit' in a script.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.95 2015/11/24 01:01:56 deraadt Exp $	*/
d53 1
a53 1
	    "[-egy] [-i|-u] [-b #] [-c # -h # -s #] "
d63 1
d76 1
d92 1
a92 1
	while ((ch = getopt(argc, argv, "ieguf:c:h:s:l:b:y")) != -1) {
d153 3
d178 1
a178 1
	/* Get the GPT if present. */
d180 1
a180 1
		GPT_get_gpt();
d191 1
a191 1
		USER_print_disk();
@


1.95
log
@pledge "stdio rpath wpath disklabel proc exec" throughout, after
krw's refactorings which hoisted disk-opening to the top.
tested by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.94 2015/11/19 17:52:56 krw Exp $	*/
d213 1
@


1.94
log
@Oops. Missed a file.

Reduce overburden of unnecessary #include's. Note that param.h is
included only for DEV_BSIZE.  Use INT64_MAX instead of LLONG_MAX
so stdint.h is enough.  General tidying up of #include sections.

ok GCC
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.93 2015/11/18 15:31:15 krw Exp $	*/
d85 4
@


1.93
log
@Parse the original on-disk MBR into a local variable. Use the
partition table in this variable when doing an 'u'pdate of the MBR.
Remove now superfluous MBR_pcopy() and its re-read of the on-disk MBR.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.92 2015/11/18 15:10:43 krw Exp $	*/
d22 4
a29 3
#include <paths.h>
#include <stdint.h>
#include <err.h>
@


1.92
log
@g_flag does not need to be a global. Move it inside main().
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.91 2015/11/18 02:32:56 krw Exp $	*/
d83 1
d166 1
a166 1
	MBR_parse(&dos_mbr, 0, 0, &initial_mbr);
d169 1
a169 1
	if (MBR_protective_mbr(&initial_mbr) == 0)
d218 1
a218 1
		MBR_pcopy(&initial_mbr);
@


1.91
log
@Rejig the MBR file reading logic so

1) If mbr_file is NULL use built-in mbr for -i, -u and 'reinit'.
2) If mbr_file cannot be opened issue a warning and use built-in mbr for -i,
   -u, and 'reinit'.
3) If mbr_file can't be read, bail out of fdisk.
4) Use the mbr read from mbr_file for -i, -u, and 'reinit'.

Remove inappropriate GPT dancing.

This restores pre-GPT-editing mbr_file handling and makes the logic
clearer at the expense of a tiny bit of duplication.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.90 2015/11/18 01:53:12 krw Exp $	*/
a43 1
int	g_flag;
a67 1

d73 1
a73 1
	int i_flag = 0, e_flag = 0, f_flag = 0, u_flag = 0;
@


1.90
log
@Read MBR immediately, and only read the GPT if the MBR is a
protective MBR.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.89 2015/11/15 01:22:39 krw Exp $	*/
a186 6
	if (mbrfile != NULL && (fd = open(mbrfile, O_RDONLY)) == -1) {
		warn("%s", mbrfile);
		warnx("using builtin MBR");
		memset(&initial_mbr, 0, sizeof(initial_mbr));
		mbrfile = NULL;
	}
d188 6
a193 1
		if (MBR_protective_mbr(&initial_mbr) != 0) {
d195 8
a203 13
	} else {
		len = read(fd, &dos_mbr, sizeof(dos_mbr));
		if (len == -1)
			err(1, "Unable to read MBR from '%s'", mbrfile);
		else if (len != sizeof(dos_mbr))
			errx(1, "Unable to read complete MBR from '%s'",
			    mbrfile);
		close(fd);
	}
	if (f_flag || MBR_protective_mbr(&initial_mbr) != 0)  {
		memset(&gh, 0, sizeof(gh));
		memset(&gp, 0, sizeof(gp));
		MBR_parse(&dos_mbr, 0, 0, &initial_mbr);
d205 1
@


1.89
log
@Move zapping of invalid GPT data into GPT_get_gpt() rather than
returning a value to tell callers to zap it. Use consistant idiom
to check for the presence of a GPT (check gh.gh_sig). When zapping
GPT, always zap both the header and partition table just for
paranoia's sake.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.88 2015/11/14 21:17:08 krw Exp $	*/
d164 5
d170 2
a171 1
	GPT_get_gpt();
a186 7
	if (i_flag == 0) {
		error = MBR_read(0, &dos_mbr);
		if (error)
			errx(1, "Can't read sector 0!");
		MBR_parse(&dos_mbr, 0, 0, &initial_mbr);
	}

@


1.88
log
@Since -l is ignored if -c/-h/-s are specified, make that combination
invalid and mention the constraint in usage(). Modify the appropriate
field(s) of the global 'disk' as -l/-c/-h/-s are encountered. As a
result use the disklabel information to populate the global 'disk'
only when it has not already been populated. Move test for 'disk'
validity into DISK_open().
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.87 2015/11/14 17:42:31 krw Exp $	*/
d165 3
a167 3
	if (GPT_get_gpt()) {
		memset(&gh, 0, sizeof(gh));
		memset(&gp, 0, sizeof(gp));
d208 2
a209 1
		memset(&gh, 0, sizeof(struct gpt_header));
@


1.87
log
@Consolidate usage() checking for -c/-h/-s with other checks. Tweak
usage() verbiage a bit so it's clear all of '-c -h -s' are required
if any are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.86 2015/11/14 00:20:59 krw Exp $	*/
d61 1
a61 1
	    "\t-l: specify LBA block count\n"
d108 2
d115 2
d122 2
d139 4
d157 2
a158 1
	    ((c_arg | h_arg | s_arg) && !(c_arg && h_arg && s_arg)))
d168 1
a168 1
		if (DL_GETDSIZE(&dl) > UINT32_MAX)
a171 18

	if (c_arg | h_arg | s_arg) {
		disk.cylinders = c_arg;
		disk.heads = h_arg;
		disk.sectors = s_arg;
		disk.size = c_arg * h_arg * s_arg;
	} else if (l_arg) {
		/* Use supplied size to calculate a geometry. */
		disk.cylinders = l_arg / 64;
		disk.heads = 1;
		disk.sectors = 64;
		disk.size = l_arg;
	}

	if (disk.size == 0 || disk.cylinders == 0 || disk.heads == 0 ||
	    disk.sectors == 0 || unit_types[SECTORS].conversion == 0)
		errx(1, "Can't get disk geometry, please use [-chs] "
		    "to specify.");
@


1.86
log
@pledge("stdio", NULL) for code path that just prints the MBR or GPT. i.e.
when none of -i, -e or -u are specified.

Prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.85 2015/11/14 00:13:47 krw Exp $	*/
d56 1
a56 1
	    "\t-chs: specify disk geometry\n"
d146 2
a147 1
	    (i_flag == 0 && (b_arg || g_flag)))
d163 4
a166 8
		/* Use supplied geometry if it is completely specified. */
		if (c_arg && h_arg && s_arg) {
			disk.cylinders = c_arg;
			disk.heads = h_arg;
			disk.sectors = s_arg;
			disk.size = c_arg * h_arg * s_arg;
		} else
			errx(1, "Please specify a full geometry with [-chs].");
@


1.85
log
@If none of -i, -u or -e are specified exit immediately after the
MBR or GPT is printed. Do not attempt to read the MBR template file,
construct an initial mbr, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.84 2015/11/13 22:27:35 krw Exp $	*/
d184 2
@


1.84
log
@No need to supplement usage() with extra messages about -b needing -i, or
-g needing -i. The usage() text is quite clear.

usage() doesn't return so eliminate unneeded 'else'.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.83 2015/11/13 21:54:10 krw Exp $	*/
d183 1
a183 2
	/* Print out current MBRs on disk */
	if ((i_flag + u_flag + e_flag) == 0)
d185 2
d241 1
@


1.83
log
@No need to zero a global variable before use.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.82 2015/11/13 15:32:36 krw Exp $	*/
d145 2
a146 1
	if (argc != 1 || (i_flag && u_flag))
a147 2
	else
		disk.name = argv[0];
d149 1
a150 10

	if (b_arg > 0 && i_flag == 0) {
		warnx("-b specified without -i");
		usage();
	}

	if (g_flag != 0 && i_flag == 0) {
		warnx("-g specified without -i");
		usage();
	}
@


1.82
log
@Make usage() output fit on a 'normal' 80-character line. Tweak some
verbiage in the usage() output.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.81 2015/11/13 02:27:17 krw Exp $	*/
a142 2

	memset(&disk, 0, sizeof(disk));
@


1.81
log
@Move from opening/closing disk for every i/o to opening the disk once
and saving the fd in the global 'disk' structure. Stop passing around
fd's and just use the global.

Makes pledge() feasible.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.80 2015/11/11 15:39:18 krw Exp $	*/
d53 3
a55 3
	    "[-egy] [-i|-u] [-b blocks] [-c # -h # -s #] "
	    "[-f mbrfile] [-l blocks] disk\n"
	    "\t-b: add special boot partition; requires -i\n"
d57 1
a57 1
	    "\t-e: edit MBRs on disk interactively\n"
d59 2
a60 2
	    "\t-g: initialize disk with EFI/GPT partition; requires -i\n"
	    "\t-i: initialize disk with virgin MBR\n"
@


1.80
log
@Display full disk size when editing GPT, not the truncated MBR size. Display
'disk too large' message only when no GPT is found.

Problems found, fix tested and ok naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.79 2015/10/26 15:08:26 krw Exp $	*/
d152 1
a152 2
	/* Start with the disklabel geometry and get the sector size. */
	DISK_getlabelgeometry();
d201 1
a201 3
		fd = DISK_open(disk.name, O_RDONLY);
		error = MBR_read(fd, 0, &dos_mbr);
		close(fd);
d251 2
@


1.79
log
@Add GPT editing. Based on GSOC 2014 work by Markus Muller.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.78 2015/10/05 01:39:08 krw Exp $	*/
d169 3
@


1.78
log
@Enhance '-g' to create a default GPT label in addition to the protective
MBR. If '-b' is specified an EFI System partition of the requested size is
created. All remaining space is put into an OpenBSD partition.

Minimal enhancement necessary for upcoming UEFI install support.
Committed first to flush out any unexpected impacts on 'normal' MBR
operation and install media.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.77 2015/09/06 09:06:23 jmc Exp $	*/
d74 2
a75 2
	int ch, fd;
	int i_flag = 0, e_flag = 0, u_flag = 0;
d100 1
d152 8
d165 4
a168 3
	if (b_arg > 0 && i_flag == 0) {
		warnx("-b specified without -i");
		usage();
a170 3
	/* Start with the disklabel geometry and get the sector size. */
	DISK_getlabelgeometry();

d198 9
d210 1
d214 3
a216 1
		memcpy(&dos_mbr, builtin_mbr, sizeof(dos_mbr));
d226 4
a229 1
	MBR_parse(&dos_mbr, 0, 0, &initial_mbr);
d246 1
a246 1
	if (query && ask_yn(query)) {
a247 7
		if (g_flag) {
			fd = DISK_open(disk.name, O_RDWR);
			if (GPT_write(fd) == -1)
				warn("error writing GPT");
			close(fd);
		}
	}
@


1.77
log
@correct a mistake in my previous commit;
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.76 2015/09/04 21:19:45 jmc Exp $	*/
d36 1
d211 9
a219 2
		MBR_init(&initial_mbr);
		query = "Do you wish to write new MBR and partition table?";
d224 1
a224 1
	if (query && ask_yn(query))
d226 7
@


1.76
log
@shuffle -b into place; while there, do some general tidy up
of SYNOPSIS and usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.75 2015/09/04 19:02:49 kettenis Exp $	*/
d52 2
a53 2
	    "[-egy] [-b blocks] [-c # -h # -s #] [-f mbrfile] "
	    "[-i|-u] [-l blocks] disk\n"
@


1.75
log
@Add a -b option, to be used together with -i, that tells fdisk to add a
special boot partition on architectures that need it.

For now those architectures are amd64 and i386, where this option will
create an EFI system partition to store our new UEFI bootloader.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.74 2015/07/09 19:48:36 krw Exp $	*/
d52 4
a55 4
	    "[-i|-u] [-egy] [-c # -h # -s #] [-f mbrfile] "
	    "[-l blocks] [-b blocks] disk\n"
	    "\t-i: initialize disk with virgin MBR\n"
	    "\t-u: update MBR code, preserve partition table\n"
d58 2
a59 1
	    "\t-chs: specify disk geometry\n"
d61 1
a62 2
	    "\t-g: initialize disk with EFI/GPT partition, requires -i\n"
	    "\t-b: add special boot partition, requires -i\n"
@


1.74
log
@Nuke unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.73 2015/07/08 23:44:56 krw Exp $	*/
d42 1
d53 1
a53 1
	    "[-l blocks] disk\n"
d62 1
d85 1
a85 1
	while ((ch = getopt(argc, argv, "ieguf:c:h:s:l:y")) != -1) {
d120 6
d152 5
@


1.73
log
@Do not attempt to read a disk sector worth of data from the file
containing the MBR template. Most especially don't get upset when
the 512-byte file does not contain a full 4096 byte disk sector.

Allows 4096-byte disks to be fdisk'ed once more.

Problem reported and fix tested by Gerald Hanuer via bugs@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.72 2015/03/19 15:44:12 krw Exp $	*/
d71 1
a71 1
	int ch, fd, error;
@


1.72
log
@Nuke now unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.71 2015/03/18 14:46:59 krw Exp $	*/
d70 1
d185 6
a190 3
		error = MBR_read(fd, 0, &dos_mbr);
		if (error == -1)
			err(1, "Unable to read MBR");
@


1.71
log
@Stop passing around little used 'struct mbr tt' parameter.  Just
make the initial mbr that tt pointed at a global that can be directly
accessed in the couple of places it is needed.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.70 2015/03/17 21:42:15 krw Exp $	*/
a79 1
	struct mbr mbr;
@


1.70
log
@Stop passing around little used and superfluous 'offset' parameter.
Just use the offset recorded/parsed in the struct mbr being used.

Can still traverse/edit extended MBRs so offset really wasn't needed.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.69 2015/03/16 23:51:50 krw Exp $	*/
d176 1
a176 1
	/* Parse mbr template, to pass on later */
d190 1
a190 1
	MBR_parse(&dos_mbr, 0, 0, &mbr);
d194 1
a194 1
		MBR_init(&mbr);
d197 1
a197 1
		MBR_pcopy(&mbr);
d201 1
a201 1
		Xwrite(NULL, &mbr, NULL);
d204 1
a204 1
		USER_edit(&mbr, 0, 0);
@


1.69
log
@Stop passing around a pointer to the stack variable 'disk' in main().
There is only one disk being worked on, so just make it a global.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.68 2015/03/16 18:45:51 krw Exp $	*/
d201 1
a201 1
		Xwrite(NULL, &mbr, NULL, 0);
@


1.68
log
@Document that -i/-u are mutually exclusive and clean up the related
code a bit.

ok deraadt@@ igor@@ (with suggested tweak that is coming)
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.67 2015/03/14 18:32:29 krw Exp $	*/
a72 1
	struct disk disk;
d148 1
a148 1
	DISK_getlabelgeometry(&disk);
d174 1
a174 1
		USER_print_disk(&disk);
d190 1
a190 1
	MBR_parse(&disk, &dos_mbr, 0, 0, &mbr);
d194 1
a194 1
		MBR_init(&disk, &mbr);
d197 1
a197 1
		MBR_pcopy(&disk, &mbr);
d201 1
a201 1
		Xwrite(NULL, &disk, &mbr, NULL, 0);
d204 1
a204 1
		USER_edit(&disk, &mbr, 0, 0);
@


1.67
log
@Whitespace & KNF tweaks. Change functions whose return values are
not checked to void. Use continue inside a do loop instead of a
goto to the top. Move a #define/#undef more local to use. Eliminate
some lint.

General cleanup of things noticed preparing the big churn.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.66 2015/03/14 15:21:53 krw Exp $	*/
d34 1
d51 1
a51 1
	    "[-egiuy] [-c cylinders -h heads -s sectors] [-f mbrfile] "
d75 1
d138 1
a138 1
	if (argc != 1)
d193 10
a202 3
	/* Now do what we are supposed to */
	if (i_flag || u_flag)
		USER_init(&disk, &mbr, u_flag);
@


1.66
log
@Switch all the license blocks to the standard OpenBSD/ISC license.

With the permission of Toby.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.65 2015/02/09 04:27:15 krw Exp $	*/
d173 1
a173 1
		exit(USER_print_disk(&disk));
d193 1
a193 2
		if (USER_init(&disk, &mbr, u_flag) == -1)
			err(1, "error initializing MBR");
@


1.65
log
@Rename 'm_flag' to 'e_flag' since it's '-e' that sets it. Rename
'User_modify' to 'USER_edit' for the same reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.64 2015/01/03 15:50:50 jsing Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.64
log
@Add support for creating a protective MBR for GPT.

Part of a diff by Markus Mueller, which was derived from Bitrig during
Google Summer of Code, with further tweaks by me.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.63 2014/03/20 13:18:21 krw Exp $	*/
d79 1
a79 1
	int i_flag = 0, m_flag = 0, u_flag = 0;
d102 1
a102 1
			m_flag = 1;
d181 1
a181 1
	if ((i_flag + u_flag + m_flag) == 0)
d205 2
a206 2
	if (m_flag)
		USER_modify(&disk, &mbr, 0, 0);
@


1.63
log
@Add back various #includes of err.h, unistd.h, ctype.h, ioctl.h to
eliminate multiple 'implicit' declarations introduced by the previous
over-zealous #include cleanup.

Thanks to to tedu@@ for pointing out how -Wall reveals all.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.62 2014/03/17 16:40:00 krw Exp $	*/
d50 1
d59 2
a60 1
	    "[-eiuy] [-c cylinders -h heads -s sectors] [-f mbrfile] [-l blocks] disk\n"
d68 1
d91 1
a91 1
	while ((ch = getopt(argc, argv, "ieuf:c:h:s:l:y")) != -1) {
d123 3
d149 5
@


1.62
log
@Nuke pointless blank lines, defines, comments and casts. Eliminate
#include in *.h files in favour of listing them as required in the *.c
files. Fix error message to correctly state that 64 is the minimum
value for -l. Use errx() where errno is not relevant. Use 'continue'
rather than a label to go back to start of a loop.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.61 2014/03/17 13:15:44 krw Exp $	*/
d37 1
@


1.61
log
@Un-revert, being careful to not break snap building. Add paranoia check
for any missing geometry.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.60 2014/03/14 15:41:33 krw Exp $	*/
d39 2
d122 1
a122 1
				errx(1, "Block argument %s [1..%u].", errstr,
@


1.60
log
@Revert last -- broke building snaps.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.59 2014/03/13 12:02:28 krw Exp $	*/
d39 1
a76 1
	struct DISK_metrics *usermetrics;
d118 1
a118 1
			l_arg = strtonum(optarg, 1, UINT32_MAX, &errstr);
d133 2
d141 3
a143 1
	/* Put in supplied geometry if there */
d145 8
a152 10
		usermetrics = malloc(sizeof(struct DISK_metrics));
		if (usermetrics != NULL) {
			if (c_arg && h_arg && s_arg) {
				usermetrics->cylinders = c_arg;
				usermetrics->heads = h_arg;
				usermetrics->sectors = s_arg;
				usermetrics->size = c_arg * h_arg * s_arg;
			} else
				errx(1, "Please specify a full geometry with [-chs].");
		}
d154 6
a159 15
		/* Force into LBA mode */
		usermetrics = malloc(sizeof(struct DISK_metrics));
		if (usermetrics != NULL) {
			usermetrics->cylinders = l_arg / 64;
			usermetrics->heads = 1;
			usermetrics->sectors = 64;
			usermetrics->size = l_arg;
		}
	} else
		usermetrics = NULL;

	/* Get the geometry */
	disk.real = NULL;
	if (DISK_getmetrics(&disk, usermetrics))
		errx(1, "Can't get disk geometry, please use [-chs] to specify.");
d161 4
@


1.59
log
@Merge 'struct DISK_metrics' and 'struct disk' into one, since we don't
need to record two sets of metric/geometry data. Use 'geometry'
instead of 'metrics' in names and comments. Eliminate
DISK_getmetrics().

While here, make 64 the minimal valid value for '-l' instead of 1. This
avoids the possibility of having 0 cylinders.

No intentional functional change.

Feedback & tweak from chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.58 2014/03/09 22:25:06 krw Exp $	*/
d76 1
d118 1
a118 1
			l_arg = strtonum(optarg, 64, UINT32_MAX, &errstr);
a132 2
	memset(&disk, 0, sizeof(disk));

d139 1
d141 10
a150 8
		/* Use supplied geometry if it is completely specified. */
		if (c_arg && h_arg && s_arg) {
			disk.cylinders = c_arg;
			disk.heads = h_arg;
			disk.sectors = s_arg;
			disk.size = c_arg * h_arg * s_arg;
		} else
			errx(1, "Please specify a full geometry with [-chs].");
d152 10
a161 6
		/* Use supplied size to calculate a geometry. */
		disk.cylinders = l_arg / 64;
		disk.heads = 1;
		disk.sectors = 64;
		disk.size = l_arg;
	}
d163 4
a166 7
	if (disk.size == 0) {
		/* Get the disklabel geometry. */
		DISK_getlabelgeometry(&disk);
		if (disk.size == 0)
			errx(1, "Can't get disk geometry, please use [-chs] "
			    "to specify.");
	}
@


1.58
log
@Instead of passing around 'char buf[DEV_BSIZE]' buffers, pass around
'struct dos_mbr' variables, since that is what the buffers were used
for. Removes need to know about DEV_BSIZE and thus include param.h
from all files but one so move the param.h #include to that file
(mbr.c).

Nuke a bunch of local MBR #defines in favour of the disklabel.h ones.

Remove a bunch of unneeded #includes, replace the odd malloc/bzero
with calloc, replace equally odd bcopy's with memcpy, remove a stray
duplicate MBR parsing in MBR_pcopy().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.57 2014/03/07 21:56:13 krw Exp $	*/
a75 1
	struct DISK_metrics *usermetrics;
d117 1
a117 1
			l_arg = strtonum(optarg, 1, UINT32_MAX, &errstr);
d132 2
a139 1
	/* Put in supplied geometry if there */
d141 8
a148 10
		usermetrics = malloc(sizeof(struct DISK_metrics));
		if (usermetrics != NULL) {
			if (c_arg && h_arg && s_arg) {
				usermetrics->cylinders = c_arg;
				usermetrics->heads = h_arg;
				usermetrics->sectors = s_arg;
				usermetrics->size = c_arg * h_arg * s_arg;
			} else
				errx(1, "Please specify a full geometry with [-chs].");
		}
d150 6
a155 10
		/* Force into LBA mode */
		usermetrics = malloc(sizeof(struct DISK_metrics));
		if (usermetrics != NULL) {
			usermetrics->cylinders = l_arg / 64;
			usermetrics->heads = 1;
			usermetrics->sectors = 64;
			usermetrics->size = l_arg;
		}
	} else
		usermetrics = NULL;
d157 7
a163 4
	/* Get the geometry */
	disk.real = NULL;
	if (DISK_getmetrics(&disk, usermetrics))
		errx(1, "Can't get disk geometry, please use [-chs] to specify.");
@


1.57
log
@Relieve the code of an overburden of unnecessary typedef
abstraction. Call a 'struct' a 'struct' and not a pony.

No functional change.

idea ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.56 2014/03/06 17:39:23 jmc Exp $	*/
a30 1
#include <err.h>
d37 1
d83 1
a83 1
	char mbr_buf[DEV_BSIZE];
d180 1
a180 1
		memcpy(mbr_buf, builtin_mbr, sizeof(mbr_buf));
d182 1
a182 1
		error = MBR_read(fd, 0, mbr_buf);
d187 1
a187 1
	MBR_parse(&disk, mbr_buf, 0, 0, &mbr);
a198 1

@


1.56
log
@tweak previous;
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.55 2014/03/02 15:41:28 deraadt Exp $	*/
d74 1
a74 1
	disk_t disk;
d76 1
a76 1
	DISK_metrics *usermetrics;
d82 1
a82 1
	mbr_t mbr;
d141 1
a141 1
		usermetrics = malloc(sizeof(DISK_metrics));
d153 1
a153 1
		usermetrics = malloc(sizeof(DISK_metrics));
@


1.55
log
@-l disksize code, to force LBA mode.  code by chris, after I suggested
wrapping rows of echo's via fdisk was silly.
ok kettenis krw
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.54 2013/03/21 18:45:58 deraadt Exp $	*/
d54 1
a54 1
	    "[-eiuy] [-l blocks] [-c cylinders -h heads -s sectors] [-f mbrfile] disk\n"
@


1.54
log
@more substantial include cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.53 2011/12/25 19:13:51 krw Exp $	*/
d37 1
d54 1
a54 1
	    "[-eiuy] [-c cylinders -h heads -s sectors] [-f mbrfile] disk\n"
d60 1
d75 1
d85 1
a85 1
	while ((ch = getopt(argc, argv, "ieuf:c:h:s:y")) != -1) {
d117 6
d150 9
@


1.53
log
@printf("msg")/return 1 -> err(1, "msg"), which will also show relevant
errno string. Since we are err()'ing out, don't worry about closing
MBR fd first.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.52 2011/02/21 19:26:12 krw Exp $	*/
d28 3
a36 3
#include <sys/types.h>
#include <sys/fcntl.h>
#include <sys/disklabel.h>
@


1.52
log
@Honour MBR_read() results and don't pretend we can parse blocks we
did not successfully read. Tweak some casts.

Fixes infinite loop problem noted by jeremy@@ while installing on
boxen with 'random' garbage in MBR. General loop detection may
follow post-4.9.

Tested by jeremy@@ and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.51 2010/05/25 18:51:02 deraadt Exp $	*/
d165 2
a167 4
		if (error == -1) {
			printf("Unable to read MBR\n");
			return (1);
		}
@


1.51
log
@match usage to the manual page, and borrow the description of 'disk'
from disklabel(8), since it describes the effect of using opendev()
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.50 2010/03/22 15:25:47 otto Exp $	*/
d69 1
a69 1
	int ch, fd;
d164 1
a164 1
		MBR_read(fd, 0, mbr_buf);
d166 4
@


1.50
log
@introduce HAS_MBR and let make define it for the right machines;
requested by miod@@; ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.49 2010/02/17 20:19:05 otto Exp $	*/
d53 1
a53 1
	    "[-eiuy] [-c cylinders -h heads -s sectors] [-f mbrfile] device\n"
@


1.49
log
@loongson has mbr as well; ok miod@@ (but he made me promise to make
a -DHAVE_MBR diff after release)
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.48 2007/12/30 13:20:13 sobrado Exp $	*/
d74 1
a74 2
#if defined(__amd64__) || defined(__i386__) || defined (__powerpc__) || \
    defined(__sh__) || defined(__MIPSEL__)
@


1.48
log
@sort flags in both synopsis and usage

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.47 2007/04/26 23:39:01 deraadt Exp $	*/
d75 1
a75 1
    defined(__sh__)
@


1.47
log
@lint says: fdisk.c:160: warning: operator '==' found where '=' was expected
yet gcc happily ate it... see, lint is useful
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.46 2006/11/09 00:01:10 deraadt Exp $	*/
d53 1
a53 1
	    "[-ieuy] [-c cylinders -h heads -s sectors] [-f mbrfile] device\n"
@


1.46
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.45 2006/11/08 23:57:05 deraadt Exp $	*/
d160 1
a160 1
		mbrfile == NULL;
@


1.45
log
@sh machines also have a /usr/mdec/mbr
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.44 2006/11/08 23:22:26 deraadt Exp $	*/
d74 1
a74 1
#if defined(__amd64__) || defined(__i386__) || defined (__powerpc__) ||
@


1.44
log
@add a -y flag, for non-interactive use
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.43 2006/07/27 04:53:27 ray Exp $	*/
d74 2
a75 1
#if defined(__amd64__) || defined(__i386__) || defined (__powerpc__)
@


1.43
log
@Change some obvious atoi() to strtonum().

OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.42 2006/07/27 04:06:13 ray Exp $	*/
d45 2
d53 1
a53 1
	    "[-ieu] [-c cylinders -h heads -s sectors] [-f mbrfile] device\n"
d59 1
d82 1
a82 1
	while ((ch = getopt(argc, argv, "ieuf:c:h:s:")) != -1) {
d113 3
@


1.42
log
@Add checks to each write(2) attempt and try to keep fdisk in a
consistent state upon write failure.

OK krw@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.41 2006/07/09 21:19:41 miod Exp $	*/
d80 2
d96 4
a99 4
			c_arg = atoi(optarg);
			if (c_arg < 1 || c_arg > 262144)
				errx(1, "Cylinder argument out of range "
				    "[1..262144].");
d102 3
a104 4
			h_arg = atoi(optarg);
			if (h_arg < 1 || h_arg > 256)
				errx(1, "Head argument out of range "
				    "[1..256].");
d107 3
a109 4
			s_arg = atoi(optarg);
			if (s_arg < 1 || s_arg > 63)
				errx(1, "Sector argument out of range "
				    "[1..63].");
@


1.41
log
@Do not try and read /usr/mdec/mbr in ``fdisk -e'' unless the architecture
really provides it.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.40 2005/05/01 20:53:38 jmc Exp $	*/
d165 2
a166 1
		USER_init(&disk, &mbr, u_flag);
@


1.40
log
@- better synopsis
- sync usage()
- add fstab(5) to SEE ALSO
- NOTES -> CAVEATS and improve

bits ok deraadt@@
improvements and ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.39 2004/08/03 09:22:03 otto Exp $	*/
d71 1
d73 3
d150 1
a150 1
	if ((fd = open(mbrfile, O_RDONLY)) == -1) {
d153 3
@


1.39
log
@Handle geometry parameters as unsigned quantities, getting rid of negative
number of sectors on large disks and other similar problems.

ok toby@@ tom@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.38 2004/01/07 16:28:52 tom Exp $	*/
d51 1
a51 1
	    "[-ieu] [-f mbrboot] [-c cyl -h head -s sect] disk\n"
@


1.38
log
@Better diagnostic message if we can't open the external MBR file

ok weingart@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.37 2003/07/02 21:44:57 deraadt Exp $	*/
d92 2
a93 1
				errx(1, "Cylinder argument out of range.");
d98 2
a99 1
				errx(1, "Head argument out of range.");
d104 2
a105 1
				errx(1, "Sector argument out of range.");
@


1.37
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.36 2003/06/11 06:22:12 deraadt Exp $	*/
d144 1
a144 1
		warn("Can not open MBR file");
@


1.36
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.35 2003/06/03 01:13:19 weingart Exp $	*/
d45 1
a45 2

void
@


1.35
log
@Nuke terms 3 & 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.34 2001/12/15 02:12:26 kjell Exp $	*/
d47 1
a47 1
usage()
d50 1
d65 1
a65 3
main(argc, argv)
	int argc;
	char **argv;
@


1.34
log
@Get this damn diff out of my tree. ok from weingart@@, deraadt@@ and others.
Add a -u flag to fdisk which updates MBR code, but leaves the partition
table intact. There are still issues with 'update' having different behavior,
but I'll resolve those shortly
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.33 2001/07/02 13:51:17 millert Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.33
log
@#include <string.h> to get mem* prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.32 2001/06/23 01:54:38 kjell Exp $	*/
d56 1
a56 1
	    "[-ie] [-f mbrboot] [-c cyl -h head -s sect] disk\n"
d58 1
d74 1
a74 1
	int i_flag = 0, m_flag = 0;
d82 1
a82 1
	while ((ch = getopt(argc, argv, "ief:c:h:s:")) != -1) {
d87 3
d146 1
a146 1
	if ((i_flag + m_flag) == 0)
a159 4
	/* Punt if no i or m */
	if ((i_flag + m_flag) != 1)
		usage();

d161 2
a162 2
	if (i_flag)
		USER_init(&disk, &mbr);
@


1.32
log
@Changes from Toby. Make error tests explicit (against -1), remove one big
hurdle to partitions over 8G. Include the default MBR in a header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.31 2000/01/08 04:51:16 deraadt Exp $	*/
d36 1
@


1.31
log
@support LBA-mapped extended partitions too; sigh@@kuzirabekon.econ.nagasaki-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.30 1998/09/14 03:54:34 rahnds Exp $	*/
d45 3
d145 8
a152 4
	if ((fd = open(mbrfile, O_RDONLY)) < 0)
		err(1, "open mbr file");
	MBR_read(fd, 0, mbr_buf);
	close(fd);
@


1.30
log
@Since on the powerpc, the system does not supply the user with
bios valid cyl,head,sector information (the information comes from the
sd driver) I have made some changes to fdisk to do the following.

Allow the powerpc to specify values larger than the bios limits.

All platforms now have code that will translate the LBA values
in the mbr into CHS values according to the disk geometry.
This occurs if the start and ending CHS values have been stored as
0xffffff.

If writing to the disk and one of the values of a partition violates
the bios limits, it writes the requested values in the LBA fields ,
and stores 0xffffff for the starting and ending CHS values.

This should not change the default formatting of any existing system
other than the CHS and LBA values should always match given the detected
geometry of the disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.29 1997/10/28 03:12:14 deraadt Exp $	*/
d90 1
a90 1
			if (c_arg < 0 || c_arg > 1023)
d95 1
a95 1
			if (h_arg < 0 || h_arg > 255)
d120 1
a120 1
			if (c_arg)
a121 3
			else
				errx(1, "Please specify a full geometry with [-chs].");
			if (h_arg)
a122 3
			else
				errx(1, "Please specify a full geometry with [-chs].");
			if (s_arg)
d124 2
a125 1
			else
a127 1
		usermetrics->size = c_arg * h_arg * s_arg;
d132 1
@


1.29
log
@if printing, we do not need to read the mbr first
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.28 1997/10/21 22:49:33 provos Exp $	*/
d151 1
a151 1
	MBR_parse(mbr_buf, 0, 0, &mbr);
@


1.28
log
@make fdisk grok extended partitions again. we have to keep track of the
absolute offset of the current mbr and its relative position. because:
the starting sector of the first mbr entry in an extended partition is relative
to the starting offset of the whole mbr itself. the starting offset of a new
extended partition is relative to the offset of the very first extended
partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.27 1997/10/19 23:30:47 deraadt Exp $	*/
d141 5
a151 5


	/* Print out current MBRs on disk */
	if ((i_flag + m_flag) == 0)
		exit(USER_print_disk(&disk));
@


1.27
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.26 1997/10/19 23:29:36 deraadt Exp $	*/
d146 1
a146 1
	MBR_parse(mbr_buf, &mbr);
d162 1
a162 1
		USER_modify(&disk, &mbr, 0);
@


1.26
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.25 1997/10/16 01:47:10 deraadt Exp $	*/
d164 1
a164 1
	return(0);
@


1.25
log
@a bunch of improvements by weingart & I
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.24 1997/10/14 21:21:33 pefo Exp $	*/
d52 7
a58 7
		"[-ie] [-f mbrboot] [-c cyl -h head -s sect] disk\n"
		"\t-i: initialize disk with virgin MBR\n"
		"\t-e: edit MBRs on disk interactively\n"
		"\t-f: specify non-standard MBR template\n"
		"\t-chs: specify disk geometry\n"
		"`disk' may be of the forms: sd0 or /dev/rsd0c.\n",
		__progname);
d77 28
a104 34
	while((ch = getopt(argc, argv, "ief:c:h:s:")) != -1){
		switch(ch){
			case 'i':
				i_flag = 1;
				break;

			case 'e':
				m_flag = 1;
				break;

			case 'f':
				mbrfile = optarg;
				break;

			case 'c':
				c_arg = atoi(optarg);
				if(c_arg < 0 || c_arg > 1023)
					errx(1, "Cylinder argument out of range.");
				break;

			case 'h':
				h_arg = atoi(optarg);
				if(h_arg < 0 || h_arg > 255)
					errx(1, "Head argument out of range.");
				break;

			case 's':
				s_arg = atoi(optarg);
				if(s_arg < 1 || s_arg > 63)
					errx(1, "Sector argument out of range.");
				break;

			default:
				usage();
d111 1
a111 1
	if(argc != 1)
d117 1
a117 1
	if(c_arg | h_arg | s_arg){
d119 13
a131 7
		if(usermetrics != NULL){
			if(c_arg) usermetrics->cylinders = c_arg;
			else errx(1, "Please specify a full geometry with [-chs].");
			if(h_arg) usermetrics->heads = h_arg;
			else errx(1, "Please specify a full geometry with [-chs].");
			if(s_arg) usermetrics->sectors = s_arg;
			else errx(1, "Please specify a full geometry with [-chs].");
d134 1
a134 1
	}else
d138 1
a138 1
	if(DISK_getmetrics(&disk, usermetrics))
d142 1
a142 1
	if((fd = open(mbrfile, O_RDONLY)) < 0)
d150 1
a150 1
	if((i_flag + m_flag) == 0)
d154 1
a154 1
	if((i_flag + m_flag) != 1)
a156 1

d158 1
a158 1
	if(i_flag)
d161 1
a161 1
	if(m_flag)
@


1.24
log
@Be a little more informative.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.23 1997/09/29 23:33:35 mickey Exp $	*/
d52 1
a52 1
		"[-ie] [-f mbrboot] [-c cyl] [-h head] [-s sect] disk\n"
d72 1
d93 2
d99 2
d105 2
a121 4
	/* Get the geometry */
	if(DISK_getmetrics(&disk) && !(c_arg | h_arg | s_arg))
		errx(1, "Can't get disk geometry, please use [-c|h|s] to specify.");

d124 8
a131 13
		if(disk.bios != NULL){
			if(c_arg) disk.bios->cylinders = c_arg;
			if(h_arg) disk.bios->heads = h_arg;
			if(s_arg) disk.bios->sectors = s_arg;
		}else{
			disk.bios = malloc(sizeof(DISK_metrics));
			if(!c_arg) warn("Unknown number of cylinders per disk.");
			if(!h_arg) warn("Unknown number of heads per cylinder.");
			if(!s_arg) warn("Unknown number of sectors per track.");

			disk.bios->cylinders = c_arg;
			disk.bios->heads = h_arg;
			disk.bios->sectors = s_arg;
d133 7
a139 1
	}
@


1.23
log
@ID in the first line w/ tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.22 1997/09/29 23:16:59 mickey Exp $	*/
d139 1
a139 1
		err(1, "open");
@


1.22
log
@better usage()
@
text
@d1 1
a1 2

/* $OpenBSD: fdisk.c,v 1.21 1997/09/29 22:58:16 weingart Exp $ */
@


1.21
log
@New fdisk code with interactive (command line type)
editing code.  Rewrite from the ground up, save about
20 lines of code.  Seems to create valid partition
tables on i386 and alphas.
@
text
@d2 1
a2 1
/* $OpenBSD$ */
d51 9
a59 6
	fprintf(stderr, "usage: fdisk [-ie] [-f mbrboot] [-c cyl] [-h head] [-s sect] disk\n");
	fprintf(stderr, "\t-i: initialize disk with virgin MBR\n");
	fprintf(stderr, "\t-e: edit MBRs on disk interactively\n");
	fprintf(stderr, "\t-f: specify non-standard MBR template\n");
	fprintf(stderr, "\t-chs: specify disk geometry\n");
	fprintf(stderr, "`disk' may be of the forms: sd0 or /dev/rsd0c.\n");
@


1.20
log
@Clean up junk before commit of new fdisk
@
text
@d1 2
a2 2
/*	$OpenBSD: fdisk.c,v 1.19 1997/07/06 18:19:29 niklas Exp $	*/
/*	$NetBSD: fdisk.c,v 1.11 1995/10/04 23:11:19 ghudson Exp $	*/
d5 2
a6 15
 * Mach Operating System
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
d8 13
a20 4
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
d22 10
a31 2
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
a33 11
#ifndef lint
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.19 1997/07/06 18:19:29 niklas Exp $";
#endif /* not lint */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/stat.h>

#include <ctype.h>
a34 1
#include <fcntl.h>
a36 1
#include <string.h>
d38 6
a43 159
#include <util.h>

#define _PATH_MBR	"/usr/mdec/mbr"

/*
 * 14-Dec-89  Robert Baron (rvb) at Carnegie-Mellon University
 *	Copyright (c) 1989	Robert. V. Baron
 *	Created.
 */

char *disk;
char *mbrname = _PATH_MBR;

struct	disklabel disklabel;		/* disk parameters */
int	cylinders;
int	sectors;
int	heads;
int	cylindersectors;
int	disksectors;

struct mboot {
	u_int8_t	padding[2];	/* force the int's to be int aligned */
	u_int8_t	bootinst[DOSPARTOFF];
	struct		dos_partition parts[4];
	u_int16_t	signature;
} mboot;

#define ACTIVE		0x80
#define BOOT_MAGIC	(u_int16_t)0xAA55

int	dos_cylinders;
int	dos_heads;
int	dos_sectors;
int	dos_cylindersectors;

#define	DOSSECT(s,c)	(((s) & 0x3f) | (((c) >> 2) & 0xc0))
#define	DOSCYL(c)	((c) & 0xff)
int	partition = -1;

int	a_flag;		/* set active partition */
int	i_flag;		/* replace partition data */
int	u_flag;		/* update partition data */
int	m_flag;		/* give me a brand new mbr */

struct part_type {
	int	type;
	char	*name;
} part_types[] = {
	{ 0x00, "unused"},
	{ 0x01, "Primary DOS with 12 bit FAT"},
	{ 0x02, "XENIX / filesystem"},
	{ 0x03, "XENIX /usr filesystem"},
	{ 0x04, "Primary DOS with 16 bit FAT"},
	{ 0x05, "Extended DOS"},
	{ 0x06, "Primary 'big' DOS (> 32MB)"},
	{ 0x07, "OS/2 HPFS, QNX or Advanced UNIX"},
	{ 0x08, "AIX filesystem"},
	{ 0x09, "AIX boot partition or Coherent"},
	{ 0x0A, "OS/2 Boot Manager or OPUS"},
	{ 0x0B, "Primary Windows 95 with 32 bit FAT"},
	{ 0x0E, "Primary DOS with 16-bit FAT, CHS-mapped"},
	{ 0x10, "OPUS"},
	{ 0x12, "Compaq Diagnostics"},
	{ 0x40, "VENIX 286"},
	{ 0x50, "DM"},
	{ 0x51, "DM"},
	{ 0x52, "CP/M or Microport SysV/AT"},
	{ 0x54, "Ontrack"},
	{ 0x56, "GB"},
	{ 0x61, "Speed"},
	{ 0x63, "ISC, System V/386, GNU HURD or Mach"},
	{ 0x64, "Novell Netware 2.xx"},
	{ 0x65, "Novell Netware 3.xx"},
	{ 0x75, "PCIX"},
	{ 0x80, "Minix 1.1 ... 1.4a"},
	{ 0x81, "Minix 1.4b ... 1.5.10"},
	{ 0x82, "Linux swap"},
	{ 0x83, "Linux filesystem"},
	{ 0x93, "Amoeba filesystem"},
	{ 0x94, "Amoeba bad block table"},
	{ 0xA5, "386BSD/FreeBSD/NetBSD"},
	{ 0xA6, "OpenBSD"},
	{ 0xA7, "NEXTSTEP"},
	{ 0xB7, "BSDI BSD/386 filesystem"},
	{ 0xB8, "BSDI BSD/386 swap"},
	{ 0xDB, "Concurrent CPM or C.DOS or CTOS"},
	{ 0xE1, "Speed"},
	{ 0xE3, "Speed"},
	{ 0xE4, "Speed"},
	{ 0xF1, "Speed"},
	{ 0xF2, "DOS 3.3+ Secondary"},
	{ 0xF4, "Speed"},
	{ 0xFF, "BBT (Bad Blocks Table)"},
};

void	usage __P((void));
void	print_s0 __P((int));
void	print_part __P((int));
void	init_sector0 __P((int));
void	intuit_translated_geometry __P((void));
int	try_heads __P((quad_t, quad_t, quad_t, quad_t, quad_t, quad_t, quad_t,
		       quad_t));
int	try_sectors __P((quad_t, quad_t, quad_t, quad_t, quad_t));
void	change_part __P((int));
void	print_params __P((void));
void	change_active __P((int));
void	get_params_to_use __P((void));
void	dos __P((int, unsigned char *, unsigned char *, unsigned char *));
int	open_disk __P((int));
int	read_disk __P((u_int32_t, void *));
int	write_disk __P((int, void *));
int	get_params __P((void));
int	read_s0 __P((void));
int	write_s0 __P((void));
int	yesno __P((char *));
void	decimal __P((char *, int *));
int	type_match __P((const void *, const void *));
char	*get_type __P((int));
int	get_mapping __P((int, int *, int *, int *, int *));

int
main(argc, argv)
	int argc;
	char *argv[];
{
	int ch, part;

	while ((ch = getopt(argc, argv, "0123aiumf:")) != -1)
		switch (ch) {
		case '0':
			partition = 0;
			break;
		case '1':
			partition = 1;
			break;
		case '2':
			partition = 2;
			break;
		case '3':
			partition = 3;
			break;
		case 'a':
			a_flag = 1;
			break;
		case 'i':
			i_flag = 1;
		case 'u':
			u_flag = 1;
			break;
		case 'm':
			m_flag = 1;
			i_flag = 1;
			u_flag = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;
d45 1
a45 11
	if (argc == 0)
		usage();

	disk = argv[0];

	if (open_disk(a_flag || i_flag || u_flag) < 0)
		exit(1);

	printf("Using device %s:\n", disk);
	if (m_flag || read_s0())
		init_sector0(0);
a46 27
	intuit_translated_geometry();

	if (u_flag)
		get_params_to_use();
	else
		print_params();

	printf("WARNING: BIOS sector numbers start at 1 (not 0)\n");
	if (partition == -1) {
		for (part = 0; part < NDOSPART; part++)
			change_part(part);
	} else
		change_part(partition);

	if (u_flag || a_flag)
		change_active(partition);

	if (u_flag || a_flag) {
		printf("\nWe haven't changed the partition table yet.  ");
		printf("This is your last chance.\n");
		print_s0(-1);
		if (yesno("Should we write new partition table?"))
			write_s0();
	}

	exit(0);
}
d51 5
a55 3
	fprintf(stderr, "usage: fdisk [-aium] [-0123] [-f mbrboot] disk\n");
	fprintf(stderr, "-a: change active, -i: initialize, -u: update\n");
	fprintf(stderr, "-m: replace MBR bootblock, -0123: select partition\n");
a59 5
void
print_s0(which)
	int which;
{
	int part;
d61 4
a64 14
	print_params();
	printf("Information from DOS bootblock is:\n");
	if (which == -1) {
		for (part = 0; part < NDOSPART; part++)
			print_part(part);
	} else
		print_part(which);
}

static struct dos_partition mtpart = { 0 };

static inline u_int16_t
getshort(p)
	void *p;
d66 13
a78 1
	unsigned char *cp = p;
d80 3
a82 2
	return cp[0] | (cp[1] << 8);
}
d84 3
a86 6
static inline void
putshort(p, l)
	void *p;
	u_int16_t l;
{
	unsigned char *cp = p;
d88 3
a90 3
	*cp++ = l;
	*cp++ = l >> 8;
}
d92 3
a94 5
static inline u_int32_t
getlong(p)
	void *p;
{
	unsigned char *cp = p;
d96 3
a98 2
	return cp[0] | (cp[1] << 8) | (cp[2] << 16) | (cp[3] << 24);
}
d100 2
a101 82
static inline void
putlong(p, l)
	void *p;
	u_int32_t l;
{
	unsigned char *cp = p;

	*cp++ = l;
	*cp++ = l >> 8;
	*cp++ = l >> 16;
	*cp++ = l >> 24;
}

void
leader(lead)
	int lead;
{
	while (lead--)
		printf(" ");
}

void
print_partinfo(pp, lead, off)
	struct dos_partition *pp;
	int lead;
	u_int32_t off;
{
	static int extcnt;
	static int extoff;

	printf("sysid %d=0x%02x (%s)\n", pp->dp_typ, pp->dp_typ,
	    get_type(pp->dp_typ));
	if (DPCYL(pp->dp_scyl, pp->dp_esect) > 1023) {
		leader(lead);
		printf("Starts beyond 1023/0/1: BIOS cannot boot from here\n");
	}
	leader(lead);
	printf("    start %d, size %d (%d MB), flag 0x%02x\n",
	    getlong(&pp->dp_start) + 
	    (pp->dp_typ != DOSPTYP_EXTEND ? off : extoff),
	    getlong(&pp->dp_size),
	    getlong(&pp->dp_size) * 512 / (1024 * 1024), pp->dp_flag);
	leader(lead);
	printf("    beg: cylinder %4d, head %3d, sector %2d\n",
	    DPCYL(pp->dp_scyl, pp->dp_ssect),
	    pp->dp_shd, DPSECT(pp->dp_ssect));
	leader(lead);
	printf("    end: cylinder %4d, head %3d, sector %2d\n",
	    DPCYL(pp->dp_ecyl, pp->dp_esect),
	    pp->dp_ehd, DPSECT(pp->dp_esect));

	if (pp->dp_typ == DOSPTYP_EXTEND) {
		struct mboot data;
		u_int32_t off2;
		int i;

		off2 = extoff+getlong(&pp->dp_start);

		if (read_disk(off2, data.bootinst) == -1) {
			leader(lead+4);
			printf("uhm, disk read error...\n");
			return;
		}

		if (!extoff)
		  extoff = off2;

		if (getshort(&data.signature) != BOOT_MAGIC) {
			fprintf(stderr,
			    "warning: invalid fdisk partition table found!\n");
			return;
		}

		for (i = 0; i < 4; i++) {
			pp = &data.parts[i];
			if (memcmp(pp, &mtpart, sizeof(*pp))) {
				leader(lead+2);
				printf("Extended Partition %d: ", extcnt);
				extcnt++;
				print_partinfo(pp, lead+2, off2);
				extcnt--;
			}
d104 2
a105 1
}
d107 3
a109 9
void
print_part(part)
	int part;
{
	struct dos_partition *pp = &mboot.parts[part];

	printf("MBR Partition %d: ", part);
	if (!memcmp(pp, &mtpart, sizeof(*pp)))
		printf("<UNUSED>\n");
d111 1
a111 73
		print_partinfo(pp, 0, 0);
}


void
init_sector0(start)
	int start;
{
	struct dos_partition *partp;
	FILE *f;

	f = fopen(mbrname, "r");
	if (!f)
		err(1, "cannot open %s", mbrname);

	if (fread(mboot.bootinst, sizeof mboot.bootinst, 1, f) != 1)
		err(1, "reading %s", mbrname);
	fclose(f);

	putshort(&mboot.signature, BOOT_MAGIC);

	partp = &mboot.parts[3];
	partp->dp_typ = DOSPTYP_OPENBSD;
	partp->dp_flag = ACTIVE;
	putlong(&partp->dp_start, start);
	putlong(&partp->dp_size,disksectors - start);

	dos(getlong(&partp->dp_start),
	    &partp->dp_scyl, &partp->dp_shd, &partp->dp_ssect);
	dos(getlong(&partp->dp_start) + getlong(&partp->dp_size) - 1,
	    &partp->dp_ecyl, &partp->dp_ehd, &partp->dp_esect);
}

/*
 * Prerequisite: the disklabel parameters and master boot record must
 *		 have been read (i.e. dos_* and mboot are meaningful).
 * Specification: modifies dos_cylinders, dos_heads, dos_sectors, and
 *		  dos_cylindersectors to be consistent with what the
 *		  partition table is using, if we can find a geometry
 *		  which is consistent with all partition table entries.
 *		  We may get the number of cylinders slightly wrong (in
 *		  the conservative direction).  The idea is to be able
 *		  to create a NetBSD partition on a disk we don't know
 *		  the translated geometry of.
 * This whole routine should be replaced with a kernel interface to get
 * the BIOS geometry (which in turn requires modifications to the i386
 * boot loader to pass in the BIOS geometry for each disk).
 */
void
intuit_translated_geometry()
{
	int cylinders = -1, heads = -1, sectors = -1, i, j;
	int c1, h1, s1, c2, h2, s2;
	int a1, a2;
	quad_t num, denom;

	/* Try to deduce the number of heads from two different mappings. */
	for (i = 0; i < NDOSPART * 2; i++) {
		if (get_mapping(i, &c1, &h1, &s1, &a1) < 0)
			continue;
		for (j = 0; j < 8; j++) {
			if (get_mapping(j, &c2, &h2, &s2, &a2) < 0)
				continue;
			num = (quad_t)h1*(a2-s2) - h2*(a1-s1);
			denom = (quad_t)c2*(a1-s1) - c1*(a2-s2);
			if (denom != 0 && num % denom == 0) {
				heads = num / denom;
				break;
			}
		}
		if (heads > 0)	
			break;
	}
d113 19
a131 12
	if (heads <= 0)
		return;

	/* Now figure out the number of sectors from a single mapping. */
	for (i = 0; i < NDOSPART * 2; i++) {
		if (get_mapping(i, &c1, &h1, &s1, &a1) < 0)
			continue;
		num = a1 - s1;
		denom = c1 * heads + h1;
		if (denom != 0 && num % denom == 0) {
			sectors = num / denom;
			break;
d135 11
a145 2
	if (sectors == -1)
		return;
d147 3
a149 22
	/* Estimate the number of cylinders. */
	cylinders = dos_cylinders * dos_cylindersectors / heads / sectors;

	/* Now verify consistency with each of the partition table entries.
	 * Be willing to shove cylinders up a little bit to make things work,
	 * but translation mismatches are fatal. */
	for (i = 0; i < NDOSPART * 2; i++) {
		if (get_mapping(i, &c1, &h1, &s1, &a1) < 0)
			continue;
		if (sectors * (c1 * heads + h1) + s1 != a1)
			return;
		if (c1 >= cylinders)
			cylinders = c1 + 1;
	}

	/* Everything checks out.  Reset the geometry to use for further
	 * calculations. */
	dos_cylinders = cylinders;
	dos_heads = heads;
	dos_sectors = sectors;
	dos_cylindersectors = heads * sectors;
}
a150 120
/*
 * For the purposes of intuit_translated_geometry(), treat the partition
 * table as a list of eight mapping between (cylinder, head, sector)
 * triplets and absolute sectors.  Get the relevant geometry triplet and
 * absolute sectors for a given entry, or return -1 if it isn't present.
 * Note: for simplicity, the returned sector is 0-based.
 */
int
get_mapping(i, cylinder, head, sector, absolute)
	int i, *cylinder, *head, *sector;
	int *absolute;
{
	struct dos_partition *part = &mboot.parts[i / 2];

	if (part->dp_typ == 0)
		return -1;
	if (i % 2 == 0) {
		*cylinder = DPCYL(part->dp_scyl, part->dp_ssect);
		*head = part->dp_shd;
		*sector = DPSECT(part->dp_ssect) - 1;
		*absolute = getlong(&part->dp_start);
	} else {
		*cylinder = DPCYL(part->dp_ecyl, part->dp_esect);
		*head = part->dp_ehd;
		*sector = DPSECT(part->dp_esect) - 1;
		*absolute = getlong(&part->dp_start)
			+ getlong(&part->dp_size) - 1;
	}
	return 0;
}

void
change_part(part)
	int part;
{
	struct dos_partition *partp = &mboot.parts[part];
	int sysid, start, size;

	print_part(part);
	if (!u_flag || !yesno("Do you want to change it?"))
		return;

	if (i_flag) {
		memset(partp, 0, sizeof(*partp));
		if (part == 3) {
			init_sector0(0);
			printf("\nThe static data for the DOS partition 3 has been reinitialized to:\n");
			print_part(part);
		}
	}

	do {
		sysid = partp->dp_typ,
		start = getlong(&partp->dp_start),
		size = getlong(&partp->dp_size);
		decimal("sysid", &sysid);
		decimal("start", &start);
		decimal("size", &size);
		partp->dp_typ = sysid;
		putlong(&partp->dp_start, start);
		putlong(&partp->dp_size, size);

		if (yesno("Explicitly specify beg/end address?")) {
			int tsector, tcylinder, thead;

			tcylinder = DPCYL(partp->dp_scyl, partp->dp_ssect);
			thead = partp->dp_shd;
			tsector = DPSECT(partp->dp_ssect);
			decimal("beginning cylinder", &tcylinder);
			decimal("beginning head", &thead);
			decimal("beginning sector", &tsector);
			partp->dp_scyl = DOSCYL(tcylinder);
			partp->dp_shd = thead;
			partp->dp_ssect = DOSSECT(tsector, tcylinder);

			tcylinder = DPCYL(partp->dp_ecyl, partp->dp_esect);
			thead = partp->dp_ehd;
			tsector = DPSECT(partp->dp_esect);
			decimal("ending cylinder", &tcylinder);
			decimal("ending head", &thead);
			decimal("ending sector", &tsector);
			partp->dp_ecyl = DOSCYL(tcylinder);
			partp->dp_ehd = thead;
			partp->dp_esect = DOSSECT(tsector, tcylinder);
		} else {
			dos(getlong(&partp->dp_start),
			    &partp->dp_scyl, &partp->dp_shd, &partp->dp_ssect);
			dos(getlong(&partp->dp_start)
			    + getlong(&partp->dp_size) - 1,
			    &partp->dp_ecyl, &partp->dp_ehd, &partp->dp_esect);
		}

		print_part(part);
	} while (!yesno("Is this entry okay?"));
}

void
print_params()
{

	printf("Parameters extracted from in-core disklabel are:\n");
	printf("    cylinders=%d heads=%d sectors/track=%d\n",
	    cylinders, heads, sectors);
	printf("    sectors/cylinder=%d total=%d\n",
	    cylindersectors, disksectors);
	if (dos_sectors > 63 || dos_cylinders > 1023 || dos_heads > 255)
		printf("Figures below won't work with BIOS for partitions not in cylinder 1\n");
	printf("Parameters to be used for BIOS calculations are:\n");
	printf("    cylinders=%d heads=%d sectors/track=%d\n",
	    dos_cylinders, dos_heads, dos_sectors);
	printf("    sectors/cylinder=%d\n",
	    dos_cylindersectors);
}

void
change_active(which)
	int which;
{
	struct dos_partition *partp = &mboot.parts[0];
	int part, active = 3;
d152 3
a154 16
	if (a_flag && which != -1)
		active = which;
	else {
		for (part = 0; part < NDOSPART; part++)
			if (partp[part].dp_flag & ACTIVE)
				active = part;
	}
	if (yesno("Do you want to change the active partition?")) {
		do {
			decimal("active partition", &active);
		} while (!yesno("Are you happy with this choice?"));
	}
	for (part = 0; part < NDOSPART; part++)
		partp[part].dp_flag &= ~ACTIVE;
	partp[active].dp_flag |= ACTIVE;
}
d156 2
a157 14
void
get_params_to_use()
{
	print_params();
	if (yesno("Do you want to change our idea of what BIOS thinks?")) {
		do {
			decimal("BIOS's idea of #cylinders", &dos_cylinders);
			decimal("BIOS's idea of #heads", &dos_heads);
			decimal("BIOS's idea of #sectors", &dos_sectors);
			dos_cylindersectors = dos_heads * dos_sectors;
			print_params();
		} while (!yesno("Are you happy with this choice?"));
	}
}
d159 1
a159 25
/*
 * Change real numbers into strange dos numbers
 */
void
dos(sector, cylinderp, headp, sectorp)
	int sector;
	unsigned char *cylinderp, *headp, *sectorp;
{
	int cylinder, head;

	if (dos_cylindersectors)
		cylinder = sector / dos_cylindersectors;
	else
		cylinder = 0;
	sector -= cylinder * dos_cylindersectors;

	if (dos_sectors)
		head = sector / dos_sectors;
	else
		head = 0;
	sector -= head * dos_sectors;

	*cylinderp = DOSCYL(cylinder);
	*headp = head;
	*sectorp = DOSSECT(sector + 1, cylinder);
a161 181
int fd;

int
open_disk(u_flag)
	int u_flag;
{
	struct stat st;

	fd = opendev(disk, (u_flag ? O_RDWR : O_RDONLY), OPENDEV_PART, &disk);
	if (fd == -1) {
		warn("%s", disk);
		return (-1);
	}
	if (fstat(fd, &st) == -1) {
		close(fd);
		warn("%s", disk);
		return (-1);
	}
	if (!S_ISCHR(st.st_mode) && !S_ISREG(st.st_mode)) {
		close(fd);
		warnx("%s is not a character device or regular file", disk);
		return (-1);
	}
	if (get_params() == -1) {
		close(fd);
		return (-1);
	}
	return (0);
}

int
read_disk(sector, buf)
	u_int32_t sector;
	void *buf;
{
	if (lseek(fd, (off_t)(sector * 512), 0) == -1)
		return (-1);
	return (read(fd, buf, 512));
}

int
write_disk(sector, buf)
	int sector;
	void *buf;
{
	if (lseek(fd, (off_t)(sector * 512), 0) == -1)
		return (-1);
	return (write(fd, buf, 512));
}

int
get_params()
{
	if (ioctl(fd, DIOCGDINFO, &disklabel) == -1) {
		warn("DIOCGDINFO");
		return (-1);
	}

	dos_cylinders = cylinders = disklabel.d_ncylinders;
	dos_heads = heads = disklabel.d_ntracks;
	dos_sectors = sectors = disklabel.d_nsectors;
	dos_cylindersectors = cylindersectors = heads * sectors;
	disksectors = cylinders * heads * sectors;
	return (0);
}

int
read_s0()
{

	if (read_disk(0, mboot.bootinst) == -1) {
		warn("can't read fdisk partition table");
		return (-1);
	}
	if (getshort(&mboot.signature) != BOOT_MAGIC) {
		fprintf(stderr,
		    "warning: invalid fdisk partition table found!\n");
		/* So should we initialize things? */
		return (-1);
	}
	return (0);
}

int
write_s0()
{
	int flag;

	/*
	 * write enable label sector before write (if necessary),
	 * disable after writing.
	 * needed if the disklabel protected area also protects
	 * sector 0. (e.g. empty disk)
	 */
	flag = 1;
	if (ioctl(fd, DIOCWLABEL, &flag) < 0)
		warn("DIOCWLABEL");
	if (write_disk(0, mboot.bootinst) == -1) {
		warn("can't write fdisk partition table");
		return -1;
	}
	flag = 0;
	if (ioctl(fd, DIOCWLABEL, &flag) < 0)
		warn("DIOCWLABEL");
	return 0;
}

int
yesno(str)
	char *str;
{
	int ch, first;

	printf("%s [n] ", str);

	first = ch = getchar();
	while (ch != '\n' && ch != EOF)
		ch = getchar();
	return (first == 'y' || first == 'Y');
}

void
decimal(str, num)
	char *str;
	int *num;
{
	char lbuf[100], *cp;
	int acc = 0;

	while (1) {
		printf("Supply a decimal value for \"%s\" [%d] ", str, *num);

		if (fgets(lbuf, sizeof lbuf, stdin) == NULL)
			errx(1, "eof");
		lbuf[strlen(lbuf)-1] = '\0';

		cp = lbuf;
		cp += strspn(cp, " \t");
		if (*cp == '\0')
			return;
		if (!isdigit(*cp))
			goto bad;
		acc = strtol(lbuf, &cp, 10);

		cp += strspn(cp, " \t");
		if (*cp != '\0')
			goto bad;
		*num = acc;
		return;
bad:
		printf("%s is not a valid decimal number.\n", lbuf);
	}
}

int
type_match(key, item)
	const void *key, *item;
{
	const int *typep = key;
	const struct part_type *ptr = item;

	if (*typep < ptr->type)
		return (-1);
	if (*typep > ptr->type)
		return (1);
	return (0);
}

char *
get_type(type)
	int type;
{
	struct part_type *ptr;

	ptr = bsearch(&type, part_types,
	    sizeof(part_types) / sizeof(struct part_type),
	    sizeof(struct part_type), type_match);
	if (ptr == 0)
		return ("unknown");
	return (ptr->name);
}
@


1.19
log
@Explicit typing
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.18 1997/04/17 12:31:46 provos Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.18 1997/04/17 12:31:46 provos Exp $";
d49 1
a49 1
#define _PATH_MBR	"/usr/mdec/sdboot"
@


1.18
log
@fix start address for first extended filesystem
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.17 1997/04/15 09:02:54 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.17 1997/04/15 09:02:54 deraadt Exp $";
d75 1
a75 1
#define BOOT_MAGIC	0xAA55
d274 1
a274 1
static inline unsigned short
d286 1
a286 1
	unsigned short l;
d306 1
a306 1
	unsigned long l;
@


1.17
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.16 1997/04/14 22:18:57 provos Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.16 1997/04/14 22:18:57 provos Exp $";
d341 2
a342 2
	    extoff+getlong(&pp->dp_start) + 
	    (pp->dp_typ != DOSPTYP_EXTEND ? off : 0), 
d359 1
a359 4
		/*
		 * XXX not positive if the extended partition label should
		 * should be found at the dp_start or at dp_s{cyl,hd,sect}
		 */
d361 1
a361 3
		off2 = getlong(&pp->dp_start);

		if (read_disk(extoff+off2, data.bootinst) == -1) {
a374 4

		/* XXX - I dont quite understand why this needs to be like
		 * that.
		 */
@


1.16
log
@works a bit better with extended partitions. hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.15 1997/04/11 10:01:31 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.15 1997/04/11 10:01:31 deraadt Exp $";
d330 1
a330 1
        static int extcnt;
d366 1
a366 2
		if (read_disk(extoff+off2, 
			      data.bootinst) == -1) {
d376 2
a377 2
		        fprintf(stderr,
				"warning: invalid fdisk partition table found!\n");
d388 1
a388 1
			        leader(lead+2);
d391 1
a391 1
			        print_partinfo(pp, lead+2, off2);
@


1.15
log
@add more partition types. add (non-functional) Extended partition support
which can be finished by someone who has Extended partitions (HINT: I
would really like to see this working for 2.1)
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.14 1997/04/06 23:54:44 downsj Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.14 1997/04/06 23:54:44 downsj Exp $";
d325 1
a325 1
print_partinfo(pp, lead)
d328 1
d330 3
a332 1
	leader(lead);
d341 3
a343 1
	    getlong(&pp->dp_start), getlong(&pp->dp_size),
d353 1
d356 1
a356 1
		int off;
d363 5
a367 8
#if 0
		off = getlong(&pp->dp_start) - 1;
#else
		off = DPCYL(pp->dp_scyl, pp->dp_ssect) * dos_cylindersectors +
		    pp->dp_shd * dos_sectors +
		    DPSECT(pp->dp_ssect);
#endif
		if (read_disk(off, &data) == -1) {
d370 24
a393 9
		} else {
			for (i = 0; i < 4; i++) {
				leader(lead+4);
				printf("Extended Partition %d: ", i);
				pp = &data.parts[i];
				if (!memcmp(pp, &mtpart, sizeof(*pp)))
					printf("<UNUSED>\n");
				else
					print_partinfo(pp, lead+4);
d409 1
a409 1
		print_partinfo(pp, 0);
@


1.14
log
@Add partition type 0x12.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.13 1997/04/02 05:30:05 mickey Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.13 1997/04/02 05:30:05 mickey Exp $";
d68 1
a68 1
	u_int8_t	padding[2];	/* force the longs to be long alligned */
d107 1
d114 1
d129 1
d156 1
a156 1
int	read_disk __P((int, void *));
d165 1
d294 1
a294 1
static inline unsigned long
d316 64
d385 1
a385 1
	struct dos_partition *partp;
d388 1
a388 2
	partp = &mboot.parts[part];
	if (!memcmp(partp, &mtpart, sizeof(struct dos_partition))) {
d390 2
a391 13
		return;
	}
	printf("sysid %d=0x%02x (%s)\n", partp->dp_typ, partp->dp_typ,
	    get_type(partp->dp_typ));
	printf("    start %d, size %d (%d MB), flag 0x%02x\n",
	    getlong(&partp->dp_start), getlong(&partp->dp_size),
	    getlong(&partp->dp_size) * 512 / (1024 * 1024), partp->dp_flag);
	printf("    beg: cylinder %4d, head %3d, sector %2d\n",
	    DPCYL(partp->dp_scyl, partp->dp_ssect),
	    partp->dp_shd, DPSECT(partp->dp_ssect));
	printf("    end: cylinder %4d, head %3d, sector %2d\n",
	    DPCYL(partp->dp_ecyl, partp->dp_esect),
	    partp->dp_ehd, DPSECT(partp->dp_esect));
d394 1
d444 1
a444 1
	long a1, a2;
d516 1
a516 1
	long *absolute;
d615 1
a615 1
	    dos_cylinders, dos_heads, dos_sectors, dos_cylindersectors);
d718 1
a718 1
	int sector;
d790 1
@


1.13
log
@fix bios geometry calculation
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.12 1997/01/31 11:59:05 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.12 1997/01/31 11:59:05 deraadt Exp $";
d108 1
@


1.12
log
@avoid some division by zero in hackish ways
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.11 1997/01/27 21:57:36 rahnds Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.11 1997/01/27 21:57:36 rahnds Exp $";
d403 1
a403 1
		if (heads != -1)	
d407 1
a407 1
	if (heads == -1)
@


1.11
log
@Support fdisk on bigendian systems. Does the necessary byte swabbing to
read and write the fdisk label. Added powerpc to systems to build this for.
Currently uses local functions getshort, putshort, getlong, and putlong.
These functions probably should be moved and renamed. Something like
htoles, letohs, htolel, letohl, or htole16, htole32 should be used instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.10 1997/01/10 19:09:58 jkatz Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.10 1997/01/10 19:09:58 jkatz Exp $";
d611 4
a614 1
	cylinder = sector / dos_cylindersectors;
d617 4
a620 1
	head = sector / dos_sectors;
@


1.10
log
@one-line fix so fdisk knows that partitions marked 0x0B are Win95/FAT32
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.9 1996/09/30 12:08:17 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.9 1996/09/30 12:08:17 deraadt Exp $";
d269 43
d327 2
a328 2
	    partp->dp_start, partp->dp_size,
	    partp->dp_size * 512 / (1024 * 1024), partp->dp_flag);
d352 1
a352 1
	mboot.signature = BOOT_MAGIC;
d357 2
a358 2
	partp->dp_start = start;
	partp->dp_size = disksectors - start;
d360 1
a360 1
	dos(partp->dp_start,
d362 1
a362 1
	dos(partp->dp_start + partp->dp_size - 1,
d468 1
a468 1
		*absolute = part->dp_start;
d473 2
a474 1
		*absolute = part->dp_start + part->dp_size - 1;
d501 2
a502 2
		start = partp->dp_start,
		size = partp->dp_size;
d507 2
a508 2
		partp->dp_start = start;
		partp->dp_size = size;
d533 1
a533 1
			dos(partp->dp_start,
d535 2
a536 1
			dos(partp->dp_start + partp->dp_size - 1,
d696 1
a696 1
	if (mboot.signature != BOOT_MAGIC) {
@


1.9
log
@signature is 16 bits
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.8 1996/09/27 15:36:09 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.8 1996/09/27 15:36:09 deraadt Exp $";
d106 1
@


1.8
log
@even better
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.7 1996/09/27 15:34:49 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.7 1996/09/27 15:34:49 deraadt Exp $";
d71 1
a71 1
	u_int32_t	signature;
@


1.7
log
@installing people do not have man pages; better usage
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.6 1996/09/27 15:27:03 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.6 1996/09/27 15:27:03 deraadt Exp $";
d244 4
a247 3
	fprintf(stderr, "usage: fdisk [-aium] [-0123] [-f mbrboot] device\n");
	fprintf(stderr, "    -a: change active, -i: initialize, -u: update\n");
	fprintf(stderr, "    -m: replace MBR bootblock, -0123: select partition\n");
@


1.6
log
@make -m also act like -i/-u
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.5 1996/09/27 14:32:07 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.5 1996/09/27 14:32:07 deraadt Exp $";
d245 2
@


1.5
log
@nicer errors
@
text
@d1 1
a1 1
/*	$OpenBSD: fdisk.c,v 1.4 1996/09/25 11:24:13 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: fdisk.c,v 1.4 1996/09/25 11:24:13 deraadt Exp $";
d123 1
a123 1
	{ 0xA5, "NetBSD/FreeBSD/386BSD"},
d192 2
@


1.4
log
@permit loading of a special MBR bootblock -- do not encode a fake MBR
bootblock inside the program. cleanup printed output. do not assume 'd'
partition.  Solves a whole bunch of other interaction problems with
disklabel.  Has been tested a fair bit, but will endure more testing
(at the hands of the users! Hahahaha!)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD$";
d297 1
a297 1
		errx(1, mbrname);
d300 1
a300 1
		errx(1, "fread");
@


1.3
log
@Switched to generic opendev(3)
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
d31 1
a31 1
static char rcsid[] = "$NetBSD: fdisk.c,v 1.11 1995/10/04 23:11:19 ghudson Exp $";
d34 1
d49 1
a49 2
#define LBUF 100
static char lbuf[LBUF];
d57 2
a58 1
char *disk = "/dev/rwd0d";
d60 6
a65 3
struct disklabel disklabel;		/* disk parameters */

int cylinders, sectors, heads, cylindersectors, disksectors;
d68 22
a89 9
	unsigned char padding[2]; /* force the longs to be long alligned */
	unsigned char bootinst[DOSPARTOFF];
	struct	dos_partition parts[4];
	unsigned short int	signature;
};
struct mboot mboot;

#define ACTIVE 0x80
#define BOOT_MAGIC 0xAA55
a90 47
int dos_cylinders;
int dos_heads;
int dos_sectors;
int dos_cylindersectors;

#define DOSSECT(s,c)	(((s) & 0x3f) | (((c) >> 2) & 0xc0))
#define DOSCYL(c)	((c) & 0xff)
int partition = -1;

int a_flag;		/* set active partition */
int i_flag;		/* replace partition data */
int u_flag;		/* update partition data */

unsigned char bootcode[] = {
0x33, 0xc0, 0xfa, 0x8e, 0xd0, 0xbc, 0x00, 0x7c, 0x8e, 0xc0, 0x8e, 0xd8, 0xfb, 0x8b, 0xf4, 0xbf,
0x00, 0x06, 0xb9, 0x00, 0x02, 0xfc, 0xf3, 0xa4, 0xea, 0x1d, 0x06, 0x00, 0x00, 0xb0, 0x04, 0xbe,
0xbe, 0x07, 0x80, 0x3c, 0x80, 0x74, 0x0c, 0x83, 0xc6, 0x10, 0xfe, 0xc8, 0x75, 0xf4, 0xbe, 0xbd,
0x06, 0xeb, 0x43, 0x8b, 0xfe, 0x8b, 0x14, 0x8b, 0x4c, 0x02, 0x83, 0xc6, 0x10, 0xfe, 0xc8, 0x74,
0x0a, 0x80, 0x3c, 0x80, 0x75, 0xf4, 0xbe, 0xbd, 0x06, 0xeb, 0x2b, 0xbd, 0x05, 0x00, 0xbb, 0x00,
0x7c, 0xb8, 0x01, 0x02, 0xcd, 0x13, 0x73, 0x0c, 0x33, 0xc0, 0xcd, 0x13, 0x4d, 0x75, 0xef, 0xbe,
0x9e, 0x06, 0xeb, 0x12, 0x81, 0x3e, 0xfe, 0x7d, 0x55, 0xaa, 0x75, 0x07, 0x8b, 0xf7, 0xea, 0x00,
0x7c, 0x00, 0x00, 0xbe, 0x85, 0x06, 0x2e, 0xac, 0x0a, 0xc0, 0x74, 0x06, 0xb4, 0x0e, 0xcd, 0x10,
0xeb, 0xf4, 0xfb, 0xeb, 0xfe,
'M', 'i', 's', 's', 'i', 'n', 'g', ' ',
	'o', 'p', 'e', 'r', 'a', 't', 'i', 'n', 'g', ' ', 's', 'y', 's', 't', 'e', 'm', 0,
'E', 'r', 'r', 'o', 'r', ' ', 'l', 'o', 'a', 'd', 'i', 'n', 'g', ' ',
	'o', 'p', 'e', 'r', 'a', 't', 'i', 'n', 'g', ' ', 's', 'y', 's', 't', 'e', 'm', 0,
'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ',
	'p', 'a', 'r', 't', 'i', 't', 'i', 'o', 'n', ' ', 't', 'a', 'b', 'l', 'e', 0,
'A', 'u', 't', 'h', 'o', 'r', ' ', '-', ' ',
	'S', 'i', 'e', 'g', 'm', 'a', 'r', ' ', 'S', 'c', 'h', 'm', 'i', 'd', 't', 0,0,0,

  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
};

d92 2
a93 2
	int type;
	char *name;
d95 40
a134 39
	{0x00, "unused"},
	{0x01, "Primary DOS with 12 bit FAT"},
	{0x02, "XENIX / filesystem"},
	{0x03, "XENIX /usr filesystem"},
	{0x04, "Primary DOS with 16 bit FAT"},
	{0x05, "Extended DOS"},
	{0x06, "Primary 'big' DOS (> 32MB)"},
	{0x07, "OS/2 HPFS, QNX or Advanced UNIX"},
	{0x08, "AIX filesystem"},
	{0x09, "AIX boot partition or Coherent"},
	{0x0A, "OS/2 Boot Manager or OPUS"},
	{0x10, "OPUS"},
	{0x40, "VENIX 286"},
	{0x50, "DM"},
	{0x51, "DM"},
	{0x52, "CP/M or Microport SysV/AT"},
	{0x56, "GB"},
	{0x61, "Speed"},
	{0x63, "ISC UNIX, other System V/386, GNU HURD or Mach"},
	{0x64, "Novell Netware 2.xx"},
	{0x65, "Novell Netware 3.xx"},
	{0x75, "PCIX"},
	{0x80, "Minix 1.1 ... 1.4a"},
	{0x81, "Minix 1.4b ... 1.5.10"},
	{0x82, "Linux swap"},
	{0x83, "Linux filesystem"},
	{0x93, "Amoeba filesystem"},
	{0x94, "Amoeba bad block table"},
	{0xA5, "OpenBSD/NetBSD/FreeBSD/386BSD"},
	{0xB7, "BSDI BSD/386 filesystem"},
	{0xB8, "BSDI BSD/386 swap"},
	{0xDB, "Concurrent CPM or C.DOS or CTOS"},
	{0xE1, "Speed"},
	{0xE3, "Speed"},
	{0xE4, "Speed"},
	{0xF1, "Speed"},
	{0xF2, "DOS 3.3+ Secondary"},
	{0xF4, "Speed"},
	{0xFF, "BBT (Bad Blocks Table)"},
d166 1
a166 2
	int ch;
	int part;
d168 1
a168 2
	a_flag = i_flag = u_flag = 0;
	while ((ch = getopt(argc, argv, "0123aiu")) != -1)
d190 3
d199 4
a202 2
	if (argc > 0)
		disk = argv[0];
d207 3
a209 2
	if (read_s0())
		init_sector0(1);
a212 1
	printf("******* Working on device %s *******\n", disk);
d218 1
a218 2
	printf("Warning: BIOS sector numbering starts with sector 1\n");
	printf("Information from DOS bootblock is:\n");
d242 1
a242 2

	(void)fprintf(stderr, "usage: fdisk [-aiu] [-0|-1|-2|-3] [device]\n");
d256 1
a256 1
			printf("%d: ", part), print_part(part);
d269 1
d275 3
a277 2
	printf("sysid %d (%s)\n", partp->dp_typ, get_type(partp->dp_typ));
	printf("    start %d, size %d (%d MB), flag %x\n",
d280 1
a280 1
	printf("\tbeg: cylinder %4d, head %3d, sector %2d\n",
d283 1
a283 1
	printf("\tend: cylinder %4d, head %3d, sector %2d\n",
d293 9
a302 1
	memcpy(mboot.bootinst, bootcode, sizeof(bootcode));
d306 1
a306 1
	partp->dp_typ = DOSPTYP_386BSD;
d317 2
a318 1
/* Prerequisite: the disklabel parameters and master boot record must
d330 2
a331 1
 * boot loader to pass in the BIOS geometry for each disk). */
d399 2
a400 1
/* For the purposes of intuit_translated_geometry(), treat the partition
d404 2
a405 1
 * Note: for simplicity, the returned sector is 0-based. */
d433 2
a434 1
	struct dos_partition *partp;
a435 3
	partp = &mboot.parts[part];

	printf("The data for partition %d is:\n", part);
a436 1

d443 1
a443 1
			init_sector0(1);
d450 9
a458 13
		{
			int sysid, start, size;

			sysid = partp->dp_typ,
			start = partp->dp_start,
			size = partp->dp_size;
			decimal("sysid", &sysid);
			decimal("start", &start);
			decimal("size", &size);
			partp->dp_typ = sysid;
			partp->dp_start = start;
			partp->dp_size = size;
		}
d497 5
a501 3
	printf("parameters extracted from in-core disklabel are:\n");
	printf("cylinders=%d heads=%d sectors/track=%d (%d sectors/cylinder)\n\n",
	    cylinders, heads, sectors, cylindersectors);
d504 2
a505 2
	printf("parameters to be used for BIOS calculations are:\n");
	printf("cylinders=%d heads=%d sectors/track=%d (%d sectors/cylinder)\n\n",
d507 2
d515 2
a516 5
	struct dos_partition *partp;
	int part;
	int active = 3;

	partp = &mboot.parts[0];
a537 1

d550 3
a552 3
/***********************************************\
* Change real numbers into strange dos numbers	*
\***********************************************/
a605 1

a615 1

a623 1

a633 1

d646 2
a647 1
		warn("invalid fdisk partition table found");
d696 1
a697 1
	char *cp;
d699 1
a699 1
	for (;; printf("%s is not a valid decimal number.\n", lbuf)) {
d702 2
a703 1
		fgets(lbuf, LBUF, stdin);
d705 1
a706 1

a709 1

d711 1
a711 1
			continue;
d716 1
a716 2
			continue;

d719 2
a721 1

d749 1
a749 2
	else
		return (ptr->name);
@


1.2
log
@openbsd, not netbsd
@
text
@d1 1
d46 1
d600 2
a601 1
	if ((fd = open(disk, u_flag ? O_RDWR : O_RDONLY)) == -1) {
@


1.1
log
@Initial revision
@
text
@d151 1
a151 1
	{0xA5, "NetBSD or 386BSD"},
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
