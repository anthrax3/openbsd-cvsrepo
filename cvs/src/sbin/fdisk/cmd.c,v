head	1.97;
access;
symbols
	OPENBSD_6_2_BASE:1.97
	OPENBSD_6_1:1.97.0.4
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.95.0.2
	OPENBSD_6_0_BASE:1.95
	OPENBSD_5_9:1.93.0.2
	OPENBSD_5_9_BASE:1.93
	OPENBSD_5_8:1.82.0.4
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.58.0.2
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.58.0.4
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.2
	OPENBSD_5_0:1.45.0.6
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.4
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.42.0.10
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.8
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.42.0.6
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.4
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.39.0.4
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.38.0.2
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.33.0.4
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.31.0.6
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.4
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.28.0.4
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_8:1.26.0.2
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.20.0.4
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14;
locks; strict;
comment	@ * @;


1.97
date	2016.09.03.17.46.19;	author krw;	state Exp;
branches;
next	1.96;
commitid	z67FhCzyURICxzN4;

1.96
date	2016.08.02.16.00.10;	author jcs;	state Exp;
branches;
next	1.95;
commitid	m7koFlE3ScJ7WxO1;

1.95
date	2016.03.30.23.40.54;	author krw;	state Exp;
branches;
next	1.94;
commitid	EzQ63VvdYN0ky3Op;

1.94
date	2016.03.28.18.14.01;	author krw;	state Exp;
branches;
next	1.93;
commitid	C0ciuZwry68deFwN;

1.93
date	2016.01.09.18.10.56;	author krw;	state Exp;
branches;
next	1.92;
commitid	ptrgnU3nbXhej2kY;

1.92
date	2015.11.26.08.15.07;	author tim;	state Exp;
branches;
next	1.91;
commitid	K0ReHvH17yLhzwH2;

1.91
date	2015.11.25.19.32.35;	author krw;	state Exp;
branches;
next	1.90;
commitid	lfAevvmXolRUQ7Ix;

1.90
date	2015.11.21.16.45.41;	author krw;	state Exp;
branches;
next	1.89;
commitid	V1q2C6UMPN69xwYN;

1.89
date	2015.11.21.02.12.09;	author krw;	state Exp;
branches;
next	1.88;
commitid	WgMWDGOeKcuN0sTu;

1.88
date	2015.11.19.18.03.45;	author tim;	state Exp;
branches;
next	1.87;
commitid	d1hmLZfIpFdwEPEN;

1.87
date	2015.11.19.16.14.08;	author krw;	state Exp;
branches;
next	1.86;
commitid	07Axfimkfyb7znjO;

1.86
date	2015.11.18.17.09.26;	author krw;	state Exp;
branches;
next	1.85;
commitid	m8XGGC487CUV05uN;

1.85
date	2015.11.13.02.27.17;	author krw;	state Exp;
branches;
next	1.84;
commitid	4K9a6NDKqAi1JXz9;

1.84
date	2015.11.03.14.20.00;	author krw;	state Exp;
branches;
next	1.83;
commitid	75hepZ1HnSBxxZvS;

1.83
date	2015.10.26.15.08.26;	author krw;	state Exp;
branches;
next	1.82;
commitid	fOI5D0M32zdW7eoe;

1.82
date	2015.04.02.18.00.55;	author krw;	state Exp;
branches;
next	1.81;
commitid	IwHCZszuGuX6jauK;

1.81
date	2015.03.26.20.32.10;	author krw;	state Exp;
branches;
next	1.80;
commitid	CHIrWMlaDm6Ai6yT;

1.80
date	2015.03.26.14.08.12;	author krw;	state Exp;
branches;
next	1.79;
commitid	2pp42lVbpnraZMs8;

1.79
date	2015.03.19.22.48.57;	author krw;	state Exp;
branches;
next	1.78;
commitid	bTkiZEeUvpTAr7wl;

1.78
date	2015.03.18.14.46.59;	author krw;	state Exp;
branches;
next	1.77;
commitid	9oRFFmwrkHklH7n4;

1.77
date	2015.03.17.21.42.15;	author krw;	state Exp;
branches;
next	1.76;
commitid	XLe2uvrVSjySe36w;

1.76
date	2015.03.16.23.51.50;	author krw;	state Exp;
branches;
next	1.75;
commitid	JG85Pc2Xt4lLAJpr;

1.75
date	2015.03.14.18.32.29;	author krw;	state Exp;
branches;
next	1.74;
commitid	VCsOzs6eGW0SpJ6c;

1.74
date	2015.03.14.15.21.53;	author krw;	state Exp;
branches;
next	1.73;
commitid	aPXwn1AfAIMw4FVu;

1.73
date	2015.02.10.01.20.10;	author krw;	state Exp;
branches;
next	1.72;
commitid	ULzYHs9wSJgbDBeo;

1.72
date	2015.02.09.04.27.15;	author krw;	state Exp;
branches;
next	1.71;
commitid	hdzyTUV8r2DhhgJ1;

1.71
date	2014.03.31.23.04.03;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2014.03.31.22.03.29;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2014.03.20.13.18.21;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2014.03.17.16.40.00;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2014.03.17.13.15.44;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2014.03.14.15.41.33;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2014.03.13.12.12.35;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.13.12.02.28;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2014.03.10.21.40.58;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2014.03.09.22.25.06;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.07.21.56.13;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.21.18.45.58;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.21.18.37.07;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2012.07.11.10.27.34;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2012.07.09.17.19.55;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2012.07.09.17.07.35;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2012.07.09.16.45.34;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2012.07.09.12.45.30;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2012.07.08.18.29.28;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2012.07.08.17.46.44;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.08.12.29.04;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2012.07.08.11.32.58;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.08.10.11.59;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2012.07.07.16.00.19;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.25.04.21.45;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	2011.11.11.18.21.06;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.02.02.54.09;	author halex;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.08.18.03.18;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.27.04.06.13;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.18.19.05.42;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.26.17.10.43;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.29.19.35.25;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.19.15.48.20;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.06.18.57.59;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.18.23.22.05;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.13.06.00.33;	author tom;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.22.23.01.55;	author tom;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.03.01.13.19;	author weingart;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.24.04.40.03;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.18.08.38.26;	author kjell;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.18.08.33.10;	author kjell;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.28.00.56.07;	author weingart;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.01.21.05.33;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.01.21.49.12;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.18.22.40.15;	author kjell;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.04.18.09.36;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.08.04.51.16;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.08.21.22.49.25;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.06.10.22.38.01;	author pjanzen;	state Exp;
branches;
next	1.20;

1.20
date	98.09.14.03.54.34;	author rahnds;	state Exp;
branches;
next	1.19;

1.19
date	98.09.08.11.03.15;	author pefo;	state Exp;
branches;
next	1.18;

1.18
date	98.08.08.05.27.59;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	98.08.07.21.49.18;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.01.04.23.57.29;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.12.23.23.52.58;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.10.21.22.49.32;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.10.19.23.58.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.10.19.23.37.25;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.10.19.23.33.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.19.23.29.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.19.23.13.48;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.18.11.52.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.16.10.35.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.16.01.47.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.04.00.09.51;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.02.14.58.30;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.09.30.00.07.25;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.09.29.23.33.32;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.09.29.22.58.14;	author weingart;	state Exp;
branches;
next	;


desc
@@


1.97
log
@'reinit' should check the MBR on disk, as the man page says.

Makes 'reinit' respect current state of disk when deciding between
MBR and GPT initialization.

Problem noted by halex@@
@
text
@/*	$OpenBSD: cmd.c,v 1.96 2016/08/02 16:00:10 jcs Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/disklabel.h>

#include <err.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <uuid.h>

#include "disk.h"
#include "misc.h"
#include "part.h"
#include "mbr.h"
#include "gpt.h"
#include "user.h"
#include "cmd.h"

int reinited;

/* Some helper functions for GPT handling. */
int Xgedit(char *);
int Xgsetpid(char *);

int
Xreinit(char *args, struct mbr *mbr)
{
	struct dos_mbr dos_mbr;
	int dogpt;

	if (strncasecmp(args, "gpt", 3) == 0)
		dogpt = 1;
	else if (strncasecmp(args, "mbr", 3) == 0)
		dogpt = 0;
	else if (strlen(args) > 0) {
		printf("Unrecognized modifier '%s'\n", args);
		return (CMD_CONT);
	} else if (MBR_protective_mbr(mbr) == 0)
		dogpt = 1;
	else
		dogpt = 0;

	MBR_make(&initial_mbr, &dos_mbr);
	MBR_parse(&dos_mbr, mbr->offset, mbr->reloffset, mbr);

	if (dogpt) {
		MBR_init_GPT(mbr);
		GPT_init();
		GPT_print("s", 0);
	} else {
		MBR_init(mbr);
		MBR_print(mbr, "s");
	}
	reinited = 1;

	printf("Use 'write' to update disk.\n");

	return (CMD_DIRTY);
}

int
Xdisk(char *args, struct mbr *mbr)
{
	int maxcyl  = 1024;
	int maxhead = 256;
	int maxsec  = 63;

	/* Print out disk info */
	DISK_printgeometry(args);

#if defined (__powerpc__) || defined (__mips__)
	maxcyl  = 9999999;
	maxhead = 9999999;
	maxsec  = 9999999;
#endif

	/* Ask for new info */
	if (ask_yn("Change disk geometry?")) {
		disk.cylinders = ask_num("BIOS Cylinders",
		    disk.cylinders, 1, maxcyl);
		disk.heads = ask_num("BIOS Heads",
		    disk.heads, 1, maxhead);
		disk.sectors = ask_num("BIOS Sectors",
		    disk.sectors, 1, maxsec);

		disk.size = disk.cylinders * disk.heads * disk.sectors;
	}

	return (CMD_CONT);
}

int
Xswap(char *args, struct mbr *mbr)
{
	const char *errstr;
	char *from, *to;
	int pf, pt, maxpn;
	struct prt pp;
	struct gpt_partition gg;

	to = args;
	from = strsep(&to, " \t");

	if (to == NULL) {
		printf("partition number is invalid:\n");
		return (CMD_CONT);
	}

	if (letoh64(gh.gh_sig) == GPTSIGNATURE)
		maxpn = NGPTPARTITIONS - 1;
	else
		maxpn = NDOSPART - 1;

	pf = strtonum(from, 0, maxpn, &errstr);
	if (errstr) {
		printf("partition number is %s: %s\n", errstr, from);
		return (CMD_CONT);
	}
	pt = strtonum(to, 0, maxpn, &errstr);
	if (errstr) {
		printf("partition number is %s: %s\n", errstr, to);
		return (CMD_CONT);
	}

	if (pt == pf) {
		printf("%d same partition as %d, doing nothing.\n", pt, pf);
		return (CMD_CONT);
	}

	if (letoh64(gh.gh_sig) == GPTSIGNATURE) {
		gg = gp[pt];
		gp[pt] = gp[pf];
		gp[pf] = gg;
	} else {
		pp = mbr->part[pt];
		mbr->part[pt] = mbr->part[pf];
		mbr->part[pf] = pp;
	}

	return (CMD_DIRTY);
}

int
Xgedit(char *args)
{
	struct gpt_partition oldpart;
	const char *errstr;
	struct gpt_partition *gg;
	char *name;
	u_int16_t *utf;
	u_int64_t bs, ns;
	int i, pn;

	pn = strtonum(args, 0, NGPTPARTITIONS - 1, &errstr);
	if (errstr) {
		printf("partition number is %s: %s\n", errstr, args);
		return (CMD_CONT);
	}
	gg = &gp[pn];
	oldpart = *gg;

	Xgsetpid(args);
	if (uuid_is_nil(&gg->gp_type, NULL)) {
		if (uuid_is_nil(&oldpart.gp_type, NULL) == 0) {
			memset(gg, 0, sizeof(struct gpt_partition));
			printf("Partition %d is disabled.\n", pn);
		}
		goto done;
	}

	bs = getuint64("Partition offset", letoh64(gg->gp_lba_start),
	    letoh64(gh.gh_lba_start), letoh64(gh.gh_lba_end));
	ns = getuint64("Partition size", letoh64(gg->gp_lba_end) - bs + 1,
	    1, letoh64(gh.gh_lba_end) - bs + 1);

	gg->gp_lba_start = htole64(bs);
	gg->gp_lba_end = htole64(bs + ns - 1);

	name = ask_string("Partition name", utf16le_to_string(gg->gp_name));
	if (strlen(name) >= GPTPARTNAMESIZE) {
		printf("partition name must be < %d characters\n",
		    GPTPARTNAMESIZE);
		goto done;
	}
	/*
	 * N.B.: simple memcpy() could copy trash from static buf! This
	 * would create false positives for the partition having changed.
	 */
	utf = string_to_utf16le(name);
	for (i = 0; i < GPTPARTNAMESIZE; i++) {
		gg->gp_name[i] = utf[i];
		if (utf[i] == 0)
			break;
	}

done:
	if (memcmp(gg, &oldpart, sizeof(*gg)))
		return (CMD_DIRTY);
	else
		return (CMD_CONT);
}

int
Xedit(char *args, struct mbr *mbr)
{
	struct prt oldpart;
	const char *errstr;
	struct prt *pp;
	int pn;

	if (letoh64(gh.gh_sig) == GPTSIGNATURE)
		return (Xgedit(args));

	pn = strtonum(args, 0, 3, &errstr);
	if (errstr) {
		printf("partition number is %s: %s\n", errstr, args);
		return (CMD_CONT);
	}
	pp = &mbr->part[pn];
	oldpart = *pp;

	Xsetpid(args, mbr);
	if (pp->id == DOSPTYP_UNUSED) {
		if (oldpart.id != DOSPTYP_UNUSED) {
			memset(pp, 0, sizeof(*pp));
			printf("Partition %d is disabled.\n", pn);
		}
		goto done;
	}

	if (ask_yn("Do you wish to edit in CHS mode?")) {
		pp->scyl = ask_num("BIOS Starting cylinder", pp->scyl,  0,
		    disk.cylinders - 1);
		pp->shead = ask_num("BIOS Starting head",    pp->shead, 0,
		    disk.heads - 1);
		pp->ssect = ask_num("BIOS Starting sector",  pp->ssect, 1,
		    disk.sectors);

		pp->ecyl = ask_num("BIOS Ending cylinder",   pp->ecyl,
		    pp->scyl, disk.cylinders - 1);
		pp->ehead = ask_num("BIOS Ending head",      pp->ehead,
		    (pp->scyl == pp->ecyl) ? pp->shead : 0, disk.heads - 1);
		pp->esect = ask_num("BIOS Ending sector",    pp->esect,
		    (pp->scyl == pp->ecyl && pp->shead == pp->ehead) ? pp->ssect
		    : 1, disk.sectors);

		/* Fix up off/size values */
		PRT_fix_BN(pp, pn);
		/* Fix up CHS values for LBA */
		PRT_fix_CHS(pp);
	} else {
		pp->bs = getuint64("Partition offset", pp->bs, 0, disk.size);
		pp->ns = getuint64("Partition size",   pp->ns, 1,
		    disk.size - pp->bs);

		/* Fix up CHS values */
		PRT_fix_CHS(pp);
	}

done:
	if (memcmp(pp, &oldpart, sizeof(*pp)))
		return (CMD_DIRTY);
	else
		return (CMD_CONT);
}

int
Xgsetpid(char *args)
{
	const char *errstr;
	struct uuid guid;
	struct gpt_partition *gg;
	int pn, num, status;

	pn = strtonum(args, 0, NGPTPARTITIONS - 1, &errstr);
	if (errstr) {
		printf("partition number is %s: %s\n", errstr, args);
		return (CMD_CONT);
	}
	gg = &gp[pn];

	/* Print out current table entry */
	GPT_print_parthdr(0);
	GPT_print_part(pn, "s", 0);

	/* Ask for partition type or GUID. */
	uuid_dec_le(&gg->gp_type, &guid);
	num = ask_pid(PRT_uuid_to_type(&guid), &guid);
	if (num <= 0xff)
		guid = *(PRT_type_to_uuid(num));
	uuid_enc_le(&gg->gp_type, &guid);

	if (uuid_is_nil(&gg->gp_guid, NULL)) {
		uuid_create(&guid, &status);
		if (status != uuid_s_ok) {
			printf("could not create guid for partition\n");
			return (CMD_CONT);
		}
		uuid_enc_le(&gg->gp_guid, &guid);
	}

	return (CMD_DIRTY);
}

int
Xsetpid(char *args, struct mbr *mbr)
{
	const char *errstr;
	int pn, num;
	struct prt *pp;

	if (letoh64(gh.gh_sig) == GPTSIGNATURE)
		return (Xgsetpid(args));

	pn = strtonum(args, 0, 3, &errstr);
	if (errstr) {
		printf("partition number is %s: %s\n", errstr, args);
		return (CMD_CONT);
	}
	pp = &mbr->part[pn];

	/* Print out current table entry */
	PRT_print(0, NULL, NULL);
	PRT_print(pn, pp, NULL);

	/* Ask for MBR partition type */
	num = ask_pid(pp->id, NULL);
	if (num == pp->id)
		return (CMD_CONT);

	pp->id = num;

	return (CMD_DIRTY);
}

int
Xselect(char *args, struct mbr *mbr)
{
	const char *errstr;
	static off_t firstoff = 0;
	off_t off;
	int pn;

	pn = strtonum(args, 0, 3, &errstr);
	if (errstr) {
		printf("partition number is %s: %s\n", errstr, args);
		return (CMD_CONT);
	}

	off = mbr->part[pn].bs;

	/* Sanity checks */
	if ((mbr->part[pn].id != DOSPTYP_EXTEND) &&
	    (mbr->part[pn].id != DOSPTYP_EXTENDL)) {
		printf("Partition %d is not an extended partition.\n", pn);
		return (CMD_CONT);
	}

	if (firstoff == 0)
		firstoff = off;

	if (!off) {
		printf("Loop to offset 0!  Not selected.\n");
		return (CMD_CONT);
	} else {
		printf("Selected extended partition %d\n", pn);
		printf("New MBR at offset %lld.\n", (long long)off);
	}

	/* Recursion is beautiful! */
	USER_edit(off, firstoff);

	return (CMD_CONT);
}

int
Xprint(char *args, struct mbr *mbr)
{

	if (MBR_protective_mbr(mbr) == 0 && letoh64(gh.gh_sig) == GPTSIGNATURE)
		GPT_print(args, 1);
	else
		MBR_print(mbr, args);

	return (CMD_CONT);
}

int
Xwrite(char *args, struct mbr *mbr)
{
	struct dos_mbr dos_mbr;
	int i, n;

	for (i = 0, n = 0; i < NDOSPART; i++)
		if (mbr->part[i].id == 0xA6)
			n++;
	if (n >= 2) {
		warnx("MBR contains more than one OpenBSD partition!");
		if (!ask_yn("Write MBR anyway?"))
			return (CMD_CONT);
	}

	MBR_make(mbr, &dos_mbr);

	printf("Writing MBR at offset %lld.\n", (long long)mbr->offset);
	if (MBR_write(mbr->offset, &dos_mbr) == -1) {
		warn("error writing MBR");
		return (CMD_CONT);
	}

	if (letoh64(gh.gh_sig) == GPTSIGNATURE) {
		printf("Writing GPT.\n");
		if (GPT_write() == -1) {
			warn("error writing GPT");
			return (CMD_CONT);
		}
	} else if (reinited) {
		/* Make sure GPT doesn't get in the way. */
		MBR_zapgpt(&dos_mbr, DL_GETDSIZE(&dl) - 1);
	}

	/* Refresh in memory copy to reflect what was just written. */
	MBR_parse(&dos_mbr, mbr->offset, mbr->reloffset, mbr);

	return (CMD_CLEAN);
}

int
Xquit(char *args, struct mbr *mbr)
{
	return (CMD_SAVE);
}

int
Xabort(char *args, struct mbr *mbr)
{
	exit(0);
}

int
Xexit(char *args, struct mbr *mbr)
{
	return (CMD_EXIT);
}

int
Xhelp(char *args, struct mbr *mbr)
{
	char help[80];
	char *mbrstr;
	int i;

	for (i = 0; cmd_table[i].cmd != NULL; i++) {
		strlcpy(help, cmd_table[i].help, sizeof(help));
		if (letoh64(gh.gh_sig) == GPTSIGNATURE) {
			if (cmd_table[i].gpt == 0)
				continue;
			mbrstr = strstr(help, "MBR");
			if (mbrstr)
				memcpy(mbrstr, "GPT", 3);
		}
		printf("\t%s\t\t%s\n", cmd_table[i].cmd, help);
	}

	return (CMD_CONT);
}

int
Xupdate(char *args, struct mbr *mbr)
{
	/* Update code */
	memcpy(mbr->code, initial_mbr.code, sizeof(mbr->code));
	mbr->signature = DOSMBR_SIGNATURE;
	printf("Machine code updated.\n");
	return (CMD_DIRTY);
}

int
Xflag(char *args, struct mbr *mbr)
{
	const char *errstr;
	int i, maxpn, pn = -1;
	long long val = -1;
	char *part, *flag;

	flag = args;
	part = strsep(&flag, " \t");

	if (letoh64(gh.gh_sig) == GPTSIGNATURE)
		maxpn = NGPTPARTITIONS - 1;
	else
		maxpn = NDOSPART - 1;

	pn = strtonum(part, 0, maxpn, &errstr);
	if (errstr) {
		printf("partition number is %s: %s.\n", errstr, part);
		return (CMD_CONT);
	}

	if (flag != NULL) {
		/* Set flag to value provided. */
		if (letoh64(gh.gh_sig) == GPTSIGNATURE)
			val = strtonum(flag, 0, INT64_MAX, &errstr);
		else
			val = strtonum(flag, 0, 0xff, &errstr);
		if (errstr) {
			printf("flag value is %s: %s.\n", errstr, flag);
			return (CMD_CONT);
		}
		if (letoh64(gh.gh_sig) == GPTSIGNATURE)
			gp[pn].gp_attrs = htole64(val);
		else
			mbr->part[pn].flag = val;
		printf("Partition %d flag value set to 0x%llx.\n", pn, val);
	} else {
		/* Set active flag */
		if (letoh64(gh.gh_sig) == GPTSIGNATURE) {
			for (i = 0; i < NGPTPARTITIONS; i++) {
				if (i == pn)
					gp[i].gp_attrs = htole64(GPTDOSACTIVE);
				else
					gp[i].gp_attrs = htole64(0);
			}
		} else {
			for (i = 0; i < NDOSPART; i++) {
				if (i == pn)
					mbr->part[i].flag = DOSACTIVE;
				else
					mbr->part[i].flag = 0x00;
			}
		}
		printf("Partition %d marked active.\n", pn);
	}

	return (CMD_DIRTY);
}

int
Xmanual(char *args, struct mbr *mbr)
{
	char *pager = "/usr/bin/less";
	char *p;
	sig_t opipe;
	extern const unsigned char manpage[];
	extern const int manpage_sz;
	FILE *f;

	opipe = signal(SIGPIPE, SIG_IGN);
	if ((p = getenv("PAGER")) != NULL && (*p != '\0'))
		pager = p;
	if (asprintf(&p, "gunzip -qc|%s", pager) != -1) {
		f = popen(p, "w");
		if (f) {
			fwrite(manpage, manpage_sz, 1, f);
			pclose(f);
		}
		free(p);
	}

	signal(SIGPIPE, opipe);

	return (CMD_CONT);
}
@


1.96
log
@capitalize a question like all the others

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.95 2016/03/30 23:40:54 krw Exp $	*/
d57 1
a57 1
	} else if (MBR_protective_mbr(&initial_mbr) == 0)
@


1.95
log
@Dump strdup()/free() dance and just use a local buffer to translate help
messages to GPT.

Unchecked strdup() result noted by mestre@@. ok mestre@@ tim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.94 2016/03/28 18:14:01 krw Exp $	*/
d198 1
a198 1
	name = ask_string("partition name", utf16le_to_string(gg->gp_name));
@


1.94
log
@The GPT versions of help strings that don't contain'MBR' were
leaking. Refactor logic a bit to avoid leak and make logic clearer.

Noticed by (and initial diff from) mestre@@ and his friend clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.93 2016/01/09 18:10:56 krw Exp $	*/
d468 2
a469 1
	char *mbrstr, *gpthelp;
d473 1
d477 1
a477 2
			gpthelp = strdup(cmd_table[i].help);
			mbrstr = strstr(gpthelp, "MBR");
d480 2
a481 5
			printf("\t%s\t\t%s\n", cmd_table[i].cmd, gpthelp);
			free(gpthelp);
		} else
			printf("\t%s\t\t%s\n", cmd_table[i].cmd,
			    cmd_table[i].help);
@


1.93
log
@Revamp the display of GPT information, hiding less important
information under the '-v' flag. This brings the GPT display more
into line with the MBR display and simplifies and hardens the parsing
of the partition info in the install scripts.

Original problem with install scripts parsing hand edited GPT
information reported by Valere Monseur via bugs@@.

Man page fixes and tweaks from jmc@@.
Install script changes tested & ok rpe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.92 2015/11/26 08:15:07 tim Exp $	*/
d477 1
a477 1
			if (mbrstr) {
d479 5
a483 7
				printf("\t%s\t\t%s\n", cmd_table[i].cmd,
				    gpthelp);
				free(gpthelp);
				continue;
			}
		}
		printf("\t%s\t\t%s\n", cmd_table[i].cmd, cmd_table[i].help);
@


1.92
log
@When prompting for a GPT partition type, use the partition's current type as
default; OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.91 2015/11/25 19:32:35 krw Exp $	*/
d68 1
a68 1
		GPT_print("s");
d302 2
a303 2
	GPT_print_parthdr();
	GPT_print_part(pn, "s");
d400 1
a400 1
		GPT_print(args);
@


1.91
log
@Try harder to prevent 0-length partitions from being defined.

Suggested by & ok tim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.90 2015/11/21 16:45:41 krw Exp $	*/
d306 2
a307 1
	num = ask_pid(0, &guid);
@


1.90
log
@Bring GPT partition editing into line with MBR partition editing
by presenting the existing offset and size as the defaults. Enhance
getuint64() to take a minimum value as ask_num() does. Use this to
ensure that GPT partitions are constrained to the valid area of the
disk. Leave MBR partition constraints alone for the moment.

Original problem(s) noted by tim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.89 2015/11/21 02:12:09 krw Exp $	*/
d193 1
a193 1
	    0, letoh64(gh.gh_lba_end) - bs + 1);
d258 7
a264 6
		pp->ecyl = ask_num("BIOS Ending cylinder",   pp->ecyl,  0,
		    disk.cylinders - 1);
		pp->ehead = ask_num("BIOS Ending head",      pp->ehead, 0,
		    disk.heads - 1);
		pp->esect = ask_num("BIOS Ending sector",    pp->esect, 1,
		    disk.sectors);
d272 1
a272 1
		pp->ns = getuint64("Partition size",   pp->ns, 0,
@


1.89
log
@Nuke long standing annoyance of EDIT() macros and switch both Xedit()
and Xgedit() to a new mechanism. Keep a copy of the old partition
and compare final edited version to that to decide if it is dirty.

Fixes a number of (but not all!) nits in editing partitions.

Original problem(s) noted by, suggestions from, much testing and
ok tim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.88 2015/11/19 18:03:45 tim Exp $	*/
d190 4
a193 4
	bs = getuint64("Partition offset", letoh64(gh.gh_lba_start),
	    letoh64(gh.gh_lba_end));
	ns = getuint64("Partition size", letoh64(gh.gh_lba_end) - bs + 1,
	    letoh64(gh.gh_lba_end) - bs + 1);
d270 2
a271 3
		pp->bs = getuint64("Partition offset", pp->bs,
		    disk.size);
		pp->ns = getuint64("Partition size",   pp->ns,
@


1.88
log
@When an existing partition is modified in LBA mode, ensure that the partition
table is marked dirty so that it gets written when "quit" is issued.

This commit contains the MBR part of the fix only. The GPT code needs a few
adjustments before the GPT part can be fixed properly.

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.87 2015/11/19 16:14:08 krw Exp $	*/
d165 1
d169 1
d171 1
a171 1
	int pn, ret;
d179 1
d181 1
a181 4
	/* Edit partition type */
	ret = Xgsetpid(args);

	/* Unused, so just zero out */
d183 5
a187 3
		memset(gg, 0, sizeof(struct gpt_partition));
		printf("Partition %d is disabled.\n", pn);
		return (ret);
a189 1
	/* Change table entry */
a197 1
	/* Ask for partition name. */
d202 17
a219 5
	}
	memset(gg->gp_name, 0, sizeof(gg->gp_name));
	memcpy(gg->gp_name, string_to_utf16le(name), sizeof(gg->gp_name));

	return (ret);
d225 1
a226 1
	int pn, ret;
d228 1
d239 1
d241 1
a241 4
	/* Edit partition type */
	ret = Xsetpid(args, mbr);

	/* Unused, so just zero out */
d243 5
a247 3
		memset(pp, 0, sizeof(*pp));
		printf("Partition %d is disabled.\n", pn);
		return (ret);
a249 1
	/* Change table entry */
d251 13
a263 1
		int maxcyl, maxhead, maxsect, num;
a264 17
		/* Shorter */
		maxcyl = disk.cylinders - 1;
		maxhead = disk.heads - 1;
		maxsect = disk.sectors;

		/* Get data */
#define	EDIT(p, v, n, m)			\
	if ((num = ask_num(p, v, n, m)) != v)	\
		ret = CMD_DIRTY;		\
	v = num;
		EDIT("BIOS Starting cylinder", pp->scyl,  0, maxcyl);
		EDIT("BIOS Starting head",     pp->shead, 0, maxhead);
		EDIT("BIOS Starting sector",   pp->ssect, 1, maxsect);
		EDIT("BIOS Ending cylinder",   pp->ecyl,  0, maxcyl);
		EDIT("BIOS Ending head",       pp->ehead, 0, maxhead);
		EDIT("BIOS Ending sector",     pp->esect, 1, maxsect);
#undef EDIT
d270 4
a273 1
		u_int64_t num;
a274 7
#define EDIT(p, v, d)					\
	if ((num = getuint64(p, v, (u_int64_t)d)) != v)	\
		ret = CMD_DIRTY;			\
	v = num;
		EDIT("Partition offset", pp->bs, disk.size);
		EDIT("Partition size",   pp->ns, disk.size - pp->bs);
#undef EDIT
d279 5
a283 1
	return (ret);
@


1.87
log
@Reduce overburden of unnecessary #include's. Note that param.h is
included only for DEV_BSIZE.  Use INT64_MAX instead of LLONG_MAX
so stdint.h is enough.  General tidying up of #include sections.

ok GCC
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.86 2015/11/18 17:09:26 krw Exp $	*/
d214 1
a214 1
	int pn, num, ret;
d239 1
a239 1
		int maxcyl, maxhead, maxsect;
d263 9
a271 4
		pp->bs = getuint64("Partition offset", pp->bs,
		    (u_int64_t)disk.size);
		pp->ns = getuint64("Partition size", pp->ns,
		    (u_int64_t)(disk.size - pp->bs));
@


1.86
log
@Change #include <memory.h> to #include <string.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.85 2015/11/13 02:27:17 krw Exp $	*/
a18 1
#include <sys/param.h>
a19 1
#include <sys/fcntl.h>
d21 1
d23 2
a24 1
#include <errno.h>
a27 2
#include <signal.h>
#include <unistd.h>
d513 1
a513 1
			val = strtonum(flag, 0, LLONG_MAX, &errstr);
@


1.85
log
@Move from opening/closing disk for every i/o to opening the disk once
and saving the fd in the global 'disk' structure. Stop passing around
fd's and just use the global.

Makes pledge() feasible.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.84 2015/11/03 14:20:00 krw Exp $	*/
a25 1
#include <memory.h>
d27 1
@


1.84
log
@Don't allow the user to enter GPT partition names too large to fit
in the GPT partition structure. And don't run off the end of the
name buffer by confusing sizeof() with the number of elements in
an array.  Use the new GPTPARTNAMESIZE #define instead. While here,
zap the old partition name before setting the new one, lest a short
new name leave bits of an old long name in place.

Originally spotted by jsg@@ and his friend cppcheck.

ok jsg@@ for slightly different version.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.83 2015/10/26 15:08:26 krw Exp $	*/
d400 1
a400 1
	int fd, i, n;
a410 1
	fd = DISK_open(disk.name, O_RDWR);
d414 1
a414 2
	if (MBR_write(fd, mbr->offset, &dos_mbr) == -1) {
		int saved_errno = errno;
a415 2
		close(fd);
		errno = saved_errno;
d421 1
a421 2
		if (GPT_write(fd) == -1) {
			int saved_errno = errno;
a422 2
			close(fd);
			errno = saved_errno;
d427 1
a427 1
		MBR_zapgpt(fd, &dos_mbr, DL_GETDSIZE(&dl) - 1);
a431 2

	close(fd);
@


1.83
log
@Add GPT editing. Based on GSOC 2014 work by Markus Muller.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.82 2015/04/02 18:00:55 krw Exp $	*/
d201 6
@


1.82
log
@Don't printf("offset: ...) before every call to MBR_print(). Do it
once inside MBR_print().
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.81 2015/03/26 20:32:10 krw Exp $	*/
d19 1
d30 1
d36 1
d42 4
d50 13
d67 8
a74 1
	MBR_init(mbr);
a76 3
	/* Tell em we did something */
	printf("In memory copy is initialized to:\n");
	MBR_print(mbr, args);
d118 1
a118 1
	int pf, pt;
d120 1
d130 6
a135 1
	pf = strtonum(from, 0, 3, &errstr);
d140 1
a140 1
	pt = strtonum(to, 0, 3, &errstr);
d151 9
a159 3
	pp = mbr->part[pt];
	mbr->part[pt] = mbr->part[pf];
	mbr->part[pf] = pp;
d165 42
d213 3
d271 37
d314 3
d329 1
a329 1
	num = ask_pid(pp->id, 0x01, 0xff);
d382 4
a385 2
	DISK_printgeometry(args);
	MBR_print(mbr, args);
d417 11
a427 2
	/* Make sure GPT doesn't get in the way. */
	if (reinited)
d429 1
d460 1
d463 14
a476 1
	for (i = 0; cmd_table[i].cmd != NULL; i++)
d478 2
d497 2
a498 1
	int i, pn = -1, val = -1;
d504 6
a509 1
	pn = strtonum(part, 0, 3, &errstr);
d516 5
a520 1
		val = (int)strtonum(flag, 0, 0xff, &errstr);
d525 6
a530 3
	}

	if (val == -1) {
d532 14
a545 5
		for (i = 0; i < 4; i++) {
			if (i == pn)
				mbr->part[i].flag = DOSACTIVE;
			else
				mbr->part[i].flag = 0x00;
a547 3
	} else {
		mbr->part[pn].flag = val;
		printf("Partition %d flag value set to 0x%x.\n", pn, val);
@


1.81
log
@Adapt ask_string() from disklabel's getstring(). It will be used
to obtain GPT partition names. Tweak ask_pid() to take low/high
bounds so it can handle 1-ff (MBR) or 1000-ffff (GPT) partition
pids as required. A pid of '0' is still special and disables the
partition.

No visible or intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.80 2015/03/26 14:08:12 krw Exp $	*/
a51 1
	printf("Offset: %lld\t", (long long)mbr->offset);
a261 1
	printf("Offset: %lld\t", (long long)mbr->offset);
@


1.80
log
@Expand internal representation of partition starting LBA and size
to 64 bits, adjusting printf()'s, etc. as required. Preparing for
GPT partitions. Add 't' size unit. No other intentional functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.79 2015/03/19 22:48:57 krw Exp $	*/
d208 2
a209 2
	/* Ask for partition type */
	num = ask_pid(pp->id);
@


1.79
log
@When zapping the GPT at the end of the disk, don't use disk.size
to get the location. disk.size is a 32 bit value for MBR use. Use
DL_GETDSIZE(&dl) to get the real location even on 'big' disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.78 2015/03/18 14:46:59 krw Exp $	*/
d179 4
a182 4
		pp->bs = getuint("Partition offset", pp->bs,
		    disk.size);
		pp->ns = getuint("Partition size", pp->ns,
		    disk.size - pp->bs);
d222 2
a223 2
	static int firstoff = 0;
	int off;
d249 1
a249 1
		printf("New MBR at offset %d.\n", off);
@


1.78
log
@Stop passing around little used 'struct mbr tt' parameter.  Just
make the initial mbr that tt pointed at a global that can be directly
accessed in the couple of places it is needed.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.77 2015/03/17 21:42:15 krw Exp $	*/
d298 1
a298 1
		MBR_zapgpt(fd, &dos_mbr, disk.size - 1);
@


1.77
log
@Stop passing around little used and superfluous 'offset' parameter.
Just use the offset recorded/parsed in the struct mbr being used.

Can still traverse/edit extended MBRs so offset really wasn't needed.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.76 2015/03/16 23:51:50 krw Exp $	*/
d40 1
a40 1
Xreinit(char *args, struct mbr *mbr, struct mbr *tt)
d44 1
a44 2
	/* Copy template MBR */
	MBR_make(tt, &dos_mbr);
d60 1
a60 1
Xdisk(char *args, struct mbr *mbr, struct mbr *tt)
d91 1
a91 1
Xswap(char *args, struct mbr *mbr, struct mbr *tt)
d130 1
a130 1
Xedit(char *args, struct mbr *mbr, struct mbr *tt)
d144 1
a144 1
	ret = Xsetpid(args, mbr, tt);
d191 1
a191 1
Xsetpid(char *args, struct mbr *mbr, struct mbr *tt)
d219 1
a219 1
Xselect(char *args, struct mbr *mbr, struct mbr *tt)
d253 1
a253 1
	USER_edit(tt, off, firstoff);
d259 1
a259 1
Xprint(char *args, struct mbr *mbr, struct mbr *tt)
d270 1
a270 1
Xwrite(char *args, struct mbr *mbr, struct mbr *tt)
d309 1
a309 1
Xquit(char *args, struct mbr *mbr, struct mbr *tt)
d315 1
a315 1
Xabort(char *args, struct mbr *mbr, struct mbr *tt)
d321 1
a321 1
Xexit(char *args, struct mbr *mbr, struct mbr *tt)
d327 1
a327 1
Xhelp(char *args, struct mbr *mbr, struct mbr *tt)
d337 1
a337 1
Xupdate(char *args, struct mbr *mbr, struct mbr *tt)
d340 1
a340 1
	memcpy(mbr->code, tt->code, sizeof(mbr->code));
d347 1
a347 1
Xflag(char *args, struct mbr *mbr, struct mbr *tt)
d388 1
a388 1
Xmanual(char *args, struct mbr *mbr, struct mbr *tt)
@


1.76
log
@Stop passing around a pointer to the stack variable 'disk' in main().
There is only one disk being worked on, so just make it a global.

Fewer parameters, less confusion, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.75 2015/03/14 18:32:29 krw Exp $	*/
d40 1
a40 1
Xreinit(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d53 1
a53 1
	printf("Offset: %d\t", offset);
d61 1
a61 1
Xdisk(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d92 1
a92 1
Xswap(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d131 1
a131 1
Xedit(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d145 1
a145 1
	ret = Xsetpid(args, mbr, tt, offset);
d192 1
a192 1
Xsetpid(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d220 1
a220 1
Xselect(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d260 1
a260 1
Xprint(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d264 1
a264 1
	printf("Offset: %d\t", offset);
d271 1
a271 1
Xwrite(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d288 2
a289 2
	printf("Writing MBR at offset %d.\n", offset);
	if (MBR_write(fd, offset, &dos_mbr) == -1) {
d310 1
a310 1
Xquit(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d316 1
a316 1
Xabort(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d322 1
a322 1
Xexit(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d328 1
a328 1
Xhelp(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d338 1
a338 1
Xupdate(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d348 1
a348 1
Xflag(char *args, struct mbr *mbr, struct mbr *tt, int offset)
d389 1
a389 1
Xmanual(char *args, struct mbr *mbr, struct mbr *tt, int offset)
@


1.75
log
@Whitespace & KNF tweaks. Change functions whose return values are
not checked to void. Use continue inside a do loop instead of a
goto to the top. Move a #define/#undef more local to use. Eliminate
some lint.

General cleanup of things noticed preparing the big churn.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.74 2015/03/14 15:21:53 krw Exp $	*/
d40 1
a40 2
Xreinit(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d46 1
a46 1
	MBR_parse(disk, &dos_mbr, mbr->offset, mbr->reloffset, mbr);
d48 1
a48 1
	MBR_init(disk, mbr);
d61 1
a61 2
Xdisk(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d68 1
a68 1
	DISK_printgeometry(disk, args);
d78 6
a83 6
		disk->cylinders = ask_num("BIOS Cylinders",
		    disk->cylinders, 1, maxcyl);
		disk->heads = ask_num("BIOS Heads",
		    disk->heads, 1, maxhead);
		disk->sectors = ask_num("BIOS Sectors",
		    disk->sectors, 1, maxsec);
d85 1
a85 1
		disk->size = disk->cylinders * disk->heads * disk->sectors;
d92 1
a92 2
Xswap(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d131 1
a131 2
Xedit(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d145 1
a145 1
	ret = Xsetpid(args, disk, mbr, tt, offset);
d159 3
a161 3
		maxcyl = disk->cylinders - 1;
		maxhead = disk->heads - 1;
		maxsect = disk->sectors;
d176 1
a176 1
		PRT_fix_BN(disk, pp, pn);
d178 1
a178 1
		PRT_fix_CHS(disk, pp);
d180 4
a183 4
		pp->bs = getuint(disk, "Partition offset", pp->bs,
		    disk->size);
		pp->ns = getuint(disk, "Partition size", pp->ns,
		    disk->size - pp->bs);
d185 1
a185 1
		PRT_fix_CHS(disk, pp);
d192 1
a192 2
Xsetpid(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d220 1
a220 2
Xselect(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d254 1
a254 1
	USER_edit(disk, tt, off, firstoff);
d260 1
a260 2
Xprint(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d263 1
a263 1
	DISK_printgeometry(disk, args);
d271 1
a271 2
Xwrite(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d285 1
a285 1
	fd = DISK_open(disk->name, O_RDWR);
d299 1
a299 1
		MBR_zapgpt(fd, &dos_mbr, disk->size - 1);
d302 1
a302 1
	MBR_parse(disk, &dos_mbr, mbr->offset, mbr->reloffset, mbr);
d310 1
a310 2
Xquit(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d316 1
a316 2
Xabort(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d322 1
a322 2
Xexit(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d328 1
a328 2
Xhelp(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d338 1
a338 2
Xupdate(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d348 1
a348 2
Xflag(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
d389 1
a389 2
Xmanual(char *args, struct disk *disk, struct mbr *mbr, struct mbr *tt,
    int offset)
@


1.74
log
@Switch all the license blocks to the standard OpenBSD/ISC license.

With the permission of Toby.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.73 2015/02/10 01:20:10 krw Exp $	*/
a150 5
#define	EDIT(p, v, n, m)					\
	if ((num = ask_num(p, v, n, m)) != v)	\
		ret = CMD_DIRTY;				\
	v = num;

d168 4
d178 1
d191 1
a191 1
#undef EDIT
d220 1
d261 1
a320 2

	/* Nothing to do here */
a328 3

	/* NOTREACHED */
	return (CMD_CONT);
a334 2

	/* Nothing to do here */
d398 1
d426 1
@


1.73
log
@If 'write' is issued after a 'reinit' command, and the MBR to be
written does not contain an EFI partition, zap any GPT signature
found on the 2nd (LBA 1) and last sectors on the disk. The install
script uses this sequence.

This is a temporary workaround until more GPT support is imported
post-5.7.

Should fix at least some machines who insist on using the GPT even
after we have overritten the 'protective' MBR.

ok deraadt@@ tedu@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.72 2015/02/09 04:27:15 krw Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.72
log
@Rename 'm_flag' to 'e_flag' since it's '-e' that sets it. Rename
'User_modify' to 'USER_edit' for the same reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.71 2014/03/31 23:04:03 krw Exp $	*/
d46 2
d59 1
d311 4
a314 1
	close(fd);
d318 2
@


1.71
log
@Use return value constants to make effects clearer than the use
of an intermediate variable. No intended functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.70 2014/03/31 22:03:29 krw Exp $	*/
d265 1
a265 1
	USER_modify(disk, tt, off, firstoff);
@


1.70
log
@Whitespace rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.69 2014/03/20 13:18:21 krw Exp $	*/
d105 1
a105 1
	int pf, pt, ret;
a107 2
	ret = CMD_CONT;

d113 1
a113 1
		return (ret);
d119 1
a119 1
		return (ret);
d124 1
a124 1
		return (ret);
d129 1
a129 1
		return (ret);
d136 1
a136 2
	ret = CMD_DIRTY;
	return (ret);
d206 1
a206 1
	int pn, num, ret;
a208 2
	ret = CMD_CONT;

d212 1
a212 1
		return (ret);
d222 2
a223 2
	if (num != pp->id)
		ret = CMD_DIRTY;
d226 1
a226 2

	return (ret);
@


1.69
log
@Add back various #includes of err.h, unistd.h, ctype.h, ioctl.h to
eliminate multiple 'implicit' declarations introduced by the previous
over-zealous #include cleanup.

Thanks to to tedu@@ for pointing out how -Wall reveals all.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.68 2014/03/17 16:40:00 krw Exp $	*/
a141 1

a340 1

a438 1

@


1.68
log
@Nuke pointless blank lines, defines, comments and casts. Eliminate
#include in *.h files in favour of listing them as required in the *.c
files. Fix error message to correctly state that 64 is the minimum
value for -l. Use errx() where errno is not relevant. Use 'continue'
rather than a label to go back to start of a loop.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.67 2014/03/17 13:15:44 krw Exp $	*/
d31 1
d37 1
d40 1
@


1.67
log
@Un-revert, being careful to not break snap building. Add paranoia check
for any missing geometry.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.66 2014/03/14 15:41:33 krw Exp $	*/
d37 3
d115 1
a115 1
	pf = (int)strtonum(from, 0, 3, &errstr);
d120 1
a120 1
	pt = (int)strtonum(to, 0, 3, &errstr);
d148 1
a148 1
	pn = (int)strtonum(args, 0, 3, &errstr);
d212 1
a212 1
	pn = (int)strtonum(args, 0, 3, &errstr);
d242 1
a242 1
	pn = (int)strtonum(args, 0, 3, &errstr);
a363 1

d382 1
a382 1
	pn = (int)strtonum(part, 0, 3, &errstr);
d429 1
a429 1
			(void) fwrite(manpage, manpage_sz, 1, f);
d435 1
a435 1
	(void)signal(SIGPIPE, opipe);
@


1.66
log
@Revert last -- broke building snaps.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.65 2014/03/13 12:12:35 krw Exp $	*/
d70 1
a70 1
	DISK_printmetrics(disk, args);
d80 6
a85 6
		disk->real->cylinders = ask_num("BIOS Cylinders",
		    disk->real->cylinders, 1, maxcyl);
		disk->real->heads = ask_num("BIOS Heads",
		    disk->real->heads, 1, maxhead);
		disk->real->sectors = ask_num("BIOS Sectors",
		    disk->real->sectors, 1, maxsec);
d87 1
a87 2
		disk->real->size = disk->real->cylinders * disk->real->heads
			* disk->real->sectors;
d172 3
a174 3
		maxcyl = disk->real->cylinders - 1;
		maxhead = disk->real->heads - 1;
		maxsect = disk->real->sectors;
d189 1
a189 1
		    disk->real->size);
d191 1
a191 1
		    disk->real->size - pp->bs);
d275 1
a275 1
	DISK_printmetrics(disk, args);
@


1.65
log
@Remove some lint -- ARGSUSED.

Inspired by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.64 2014/03/13 12:02:28 krw Exp $	*/
d70 1
a70 1
	DISK_printgeometry(disk, args);
d80 6
a85 6
		disk->cylinders = ask_num("BIOS Cylinders",
		    disk->cylinders, 1, maxcyl);
		disk->heads = ask_num("BIOS Heads",
		    disk->heads, 1, maxhead);
		disk->sectors = ask_num("BIOS Sectors",
		    disk->sectors, 1, maxsec);
d87 2
a88 1
		disk->size = disk->cylinders * disk->heads * disk->sectors;
d173 3
a175 3
		maxcyl = disk->cylinders - 1;
		maxhead = disk->heads - 1;
		maxsect = disk->sectors;
d190 1
a190 1
		    disk->size);
d192 1
a192 1
		    disk->size - pp->bs);
d276 1
a276 1
	DISK_printgeometry(disk, args);
@


1.64
log
@Merge 'struct DISK_metrics' and 'struct disk' into one, since we don't
need to record two sets of metric/geometry data. Use 'geometry'
instead of 'metrics' in names and comments. Eliminate
DISK_getmetrics().

While here, make 64 the minimal valid value for '-l' instead of 1. This
avoids the possibility of having 0 cylinders.

No intentional functional change.

Feedback & tweak from chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.63 2014/03/10 21:40:58 krw Exp $	*/
a60 1
/* ARGSUSED */
a92 1
/* ARGSUSED */
a136 1
/* ARGSUSED */
a198 1
/* ARGSUSED */
a229 1
/* ARGSUSED */
a269 1
/* ARGSUSED */
a281 1
/* ARGSUSED */
a316 1
/* ARGSUSED */
a325 1
/* ARGSUSED */
a336 1
/* ARGSUSED */
a345 1
/* ARGSUSED */
a356 1
/* ARGSUSED */
a368 1
/* ARGSUSED */
a409 1
/* ARGSUSED */
@


1.63
log
@No need to pass the name of the command to the function that is
implementing that command, a pointer to the command arguments is the
only thing needed. No need to have a pointer to the command table in
every command, since there is only one table. No need for shiney new
stack space for every command name and arguments parsed, since we
don't recurse we can just use static memory.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.62 2014/03/09 22:25:06 krw Exp $	*/
d71 1
a71 1
	DISK_printmetrics(disk, args);
d81 6
a86 6
		disk->real->cylinders = ask_num("BIOS Cylinders",
		    disk->real->cylinders, 1, maxcyl);
		disk->real->heads = ask_num("BIOS Heads",
		    disk->real->heads, 1, maxhead);
		disk->real->sectors = ask_num("BIOS Sectors",
		    disk->real->sectors, 1, maxsec);
d88 1
a88 2
		disk->real->size = disk->real->cylinders * disk->real->heads
			* disk->real->sectors;
d175 3
a177 3
		maxcyl = disk->real->cylinders - 1;
		maxhead = disk->real->heads - 1;
		maxsect = disk->real->sectors;
d192 1
a192 1
		    disk->real->size);
d194 1
a194 1
		    disk->real->size - pp->bs);
d281 1
a281 1
	DISK_printmetrics(disk, args);
@


1.62
log
@Instead of passing around 'char buf[DEV_BSIZE]' buffers, pass around
'struct dos_mbr' variables, since that is what the buffers were used
for. Removes need to know about DEV_BSIZE and thus include param.h
from all files but one so move the param.h #include to that file
(mbr.c).

Nuke a bunch of local MBR #defines in favour of the disklabel.h ones.

Remove a bunch of unneeded #includes, replace the odd malloc/bzero
with calloc, replace equally odd bcopy's with memcpy, remove a stray
duplicate MBR parsing in MBR_pcopy().

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.61 2014/03/07 21:56:13 krw Exp $	*/
d41 1
a41 1
Xreinit(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d55 1
a55 1
	MBR_print(mbr, cmd->args);
d63 1
a63 1
Xdisk(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d71 1
a71 1
	DISK_printmetrics(disk, cmd->args);
d97 1
a97 1
Xswap(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d107 1
a107 1
	to = cmd->args;
d142 1
a142 1
Xedit(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d149 1
a149 1
	pn = (int)strtonum(cmd->args, 0, 3, &errstr);
d151 1
a151 1
		printf("partition number is %s: %s\n", errstr, cmd->args);
d157 1
a157 1
	ret = Xsetpid(cmd, disk, mbr, tt, offset);
d205 1
a205 1
Xsetpid(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d214 1
a214 1
	pn = (int)strtonum(cmd->args, 0, 3, &errstr);
d216 1
a216 1
		printf("partition number is %s: %s\n", errstr, cmd->args);
d237 1
a237 1
Xselect(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d245 1
a245 1
	pn = (int)strtonum(cmd->args, 0, 3, &errstr);
d247 1
a247 1
		printf("partition number is %s: %s\n", errstr, cmd->args);
d278 1
a278 1
Xprint(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d282 1
a282 1
	DISK_printmetrics(disk, cmd->args);
d284 1
a284 1
	MBR_print(mbr, cmd->args);
d291 1
a291 1
Xwrite(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d327 1
a327 1
Xquit(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d337 1
a337 1
Xabort(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d349 1
a349 1
Xexit(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d359 1
a359 1
Xhelp(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
a361 1
	struct cmd_table *cmd_table = cmd->table;
a363 1
	/* Hmm, print out cmd_table here... */
d371 1
a371 1
Xupdate(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d384 1
a384 1
Xflag(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
d391 1
a391 1
	flag = cmd->args;
d426 1
a426 1
Xmanual(struct cmd *cmd, struct disk *disk, struct mbr *mbr, struct mbr *tt,
@


1.61
log
@Relieve the code of an overburden of unnecessary typedef
abstraction. Call a 'struct' a 'struct' and not a pony.

No functional change.

idea ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.60 2013/03/21 18:45:58 deraadt Exp $	*/
a30 1
#include <err.h>
a32 1
#include <ctype.h>
a34 1
#include <unistd.h>
d36 1
a36 3
#include <limits.h>
#include "disk.h"
#include "misc.h"
a37 1
#include "part.h"
d44 1
a44 1
	char buf[DEV_BSIZE];
d47 2
a48 2
	MBR_make(tt, buf);
	MBR_parse(disk, buf, mbr->offset, mbr->reloffset, mbr);
d294 1
a294 1
	char mbr_buf[DEV_BSIZE];
d307 1
a307 1
	MBR_make(mbr, mbr_buf);
d310 1
a310 1
	if (MBR_write(fd, offset, mbr_buf) == -1) {
d320 1
a320 1
	MBR_parse(disk, mbr_buf, mbr->offset, mbr->reloffset, mbr);
d378 1
a378 1
	memcpy(mbr->code, tt->code, MBR_CODE_SIZE);
@


1.60
log
@more substantial include cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.59 2013/03/21 18:37:07 deraadt Exp $	*/
d47 2
a48 1
Xreinit(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d69 2
a70 1
Xdisk(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d103 2
a104 1
Xswap(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d109 1
a109 1
	prt_t pp;
d148 2
a149 1
Xedit(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d153 1
a153 1
	prt_t *pp;
d211 2
a212 1
Xsetpid(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d216 1
a216 1
	prt_t *pp;
d243 2
a244 1
Xselect(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d284 2
a285 1
Xprint(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d297 2
a298 1
Xwrite(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d333 2
a334 6
Xquit(cmd, disk, r, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *r;
	mbr_t *tt;
	int offset;
d343 2
a344 1
Xabort(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d355 2
a356 1
Xexit(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d365 2
a366 1
Xhelp(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d368 1
a368 1
	cmd_table_t *cmd_table = cmd->table;
d379 2
a380 1
Xupdate(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d392 2
a393 1
Xflag(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
d434 2
a435 1
Xmanual(cmd_t *cmd, disk_t *disk, mbr_t *mbr, mbr_t *tt, int offset)
@


1.59
log
@I don't feel great about adding an include for <sys/param.h>, but I feel
great for removing an include of <machine/param.h>
This needs further cleanup if someone has time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.58 2012/07/11 10:27:34 krw Exp $	*/
d28 3
a38 2
#include <sys/fcntl.h>
#include <sys/disklabel.h>
@


1.58
log
@Simplify guts and calling of getuint(). Eliminate a useless 'help'
capablity by using help text as regular prompt for 'size' and
'offset'. Try to detect and handle more overflow/underflow conditions
in getuint() and ensure returned value is always within requested
bounds. Handle zero-length partitions by treating them as UNUSED.

tested & ok halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.57 2012/07/09 17:19:55 krw Exp $	*/
a43 1
#define MAX(a, b) ((a) >= (b) ? (a) : (b))
@


1.57
log
@We always want to do unit conversions. So flags parameter of getuint()
is now superflous. With rounding gone the offset parameter is
similarly superfluous. Simply getuint() accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.56 2012/07/09 17:07:35 krw Exp $	*/
d194 4
a197 26
		u_int m;
		u_int32_t d;

		/* Get data */
		d = pp->bs;
		do {
			pp->bs = getuint(disk, "offset",
			   "Starting sector for this partition.", d,
			   disk->real->size);
			if (pp->bs == UINT_MAX)
				printf("Invalid offset.\n");
		} while (pp->bs == UINT_MAX);

		m = MAX(pp->ns, disk->real->size - pp->bs);
		if ( m > disk->real->size - pp->bs) {
			/* dont have default value extend beyond end of disk */
			m = disk->real->size - pp->bs;
		}
		d = pp->ns;
		do {
			pp->ns = getuint(disk, "size", "Size of the partition.",
			    d, m);
			if (pp->ns == UINT_MAX || pp->ns == 0)
				printf("Invalid size.\n");
		} while (pp->ns == UINT_MAX || pp->ns == 0);

@


1.56
log
@I want some of what kjell was smoking 10 years ago when he added
units handling by copying getuint() from disklabel. MBR partition id
and disklabel partition type are different beasts. So deciding to
round off a MBR partition with id FS_BSDFFS meant rounding off
NTFS partitions. And FS_SWAP partitions meant DOS FAT 12. So just
nuke rounding off for now to simplify getuint().

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.55 2012/07/09 16:45:34 krw Exp $	*/
d202 1
a202 1
			   disk->real->size, 0, DO_CONVERSIONS);
d215 1
a215 1
			    d, m, pp->bs, DO_CONVERSIONS);
@


1.55
log
@Make 'swap' command work like fdisk(8) says -- you must supply two valid
partition numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.54 2012/07/09 12:45:30 krw Exp $	*/
d202 1
a202 2
			   disk->real->size, 0, DO_CONVERSIONS |
			   (pp->id == FS_BSDFFS ? DO_ROUNDING : 0));
d215 1
a215 3
			    d, m, pp->bs , DO_CONVERSIONS |
			    ((pp->id == FS_BSDFFS || pp->id == FS_SWAP) ?
			    DO_ROUNDING : 0));
@


1.54
log
@Use strtonum() instead of strtol() inside ask_num(). Many overflows
are thus avoided. Since bounds are now reliable don't check the
returned value for being in-bounds. Since default value is
forced inside bounds, don't bother being tricky and passing a
default that is outside the bounds being specified.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.53 2012/07/08 18:29:28 krw Exp $	*/
d104 1
d110 9
a118 1
	pf = (int)strtonum(cmd->args, 0, 3, &errstr);
d120 6
a125 1
		printf("partition number is %s: %s\n", errstr, cmd->args);
a127 2

	pt = ask_num("Swap with what partition?", 0, 0, 3);
@


1.53
log
@set_pid() does not need prompt string, low or high parameters. These
are all constants. Independantly suggested by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.52 2012/07/08 17:46:44 krw Exp $	*/
d115 1
a115 5
	pt = ask_num("Swap with what partition?", -1, 0, 3);
	if (pt < 0 || pt > 3) {
		printf("Invalid partition number %d.\n", pt);
		return (ret);
	}
@


1.52
log
@Split out an ask_pid() function rather than over-parameterizing the
ask_num() function. Remove now unneeded 'flags' and 'help' parameters
from both. Display out of range values in hex in ask_pid(), since
we are seeking hex input.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.51 2012/07/08 12:29:04 krw Exp $	*/
d244 1
a244 1
	num = ask_pid("Partition id ('0' to disable) ", pp->id, 0, 0xFF);
@


1.51
log
@Call Xsetpid() to edit the partition type from Xedit() rather than
duplicating the code. Allows simplification of the EDIT() #define
in Xedit() since we always ASK_DEC and use a NULL help parameter when
invoking ask_num().
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.50 2012/07/08 11:32:58 krw Exp $	*/
d85 6
a90 6
		disk->real->cylinders = ask_num("BIOS Cylinders", ASK_DEC,
		    disk->real->cylinders, 1, maxcyl, NULL);
		disk->real->heads = ask_num("BIOS Heads", ASK_DEC,
		    disk->real->heads, 1, maxhead, NULL);
		disk->real->sectors = ask_num("BIOS Sectors", ASK_DEC,
		    disk->real->sectors, 1, maxsec, NULL);
d115 1
a115 2
	pt = ask_num("Swap with what partition?", ASK_DEC,
	    -1, 0, 3, NULL);
d154 1
a154 1
	if ((num = ask_num(p, ASK_DEC, v, n, m, NULL)) != v)	\
d244 1
a244 2
	num = ask_num("Partition id ('0' to disable) ", ASK_HEX, pp->id, 0,
	    0xFF, PRT_printall);
@


1.50
log
@Nuke useless EDIT() #define in Xsetpid.

A #define to simplify a function calling snippet does not simply or
help when it is used only once.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.49 2012/07/08 10:11:59 krw Exp $	*/
a143 2
	ret = CMD_CONT;

d147 1
a147 1
		return (ret);
d149 1
d151 2
a152 4
	/* Print out current table entry */
	pp = &mbr->part[pn];
	PRT_print(0, NULL, NULL);
	PRT_print(pn, pp, NULL);
d154 3
a156 3
#define	EDIT(p, f, v, n, m, h)				\
	if ((num = ask_num(p, f, v, n, m, h)) != v)	\
		ret = CMD_DIRTY;			\
a158 3
	/* Ask for partition type */
	EDIT("Partition id ('0' to disable) ", ASK_HEX, pp->id, 0, 0xFF, PRT_printall);

d176 6
a181 6
		EDIT("BIOS Starting cylinder", ASK_DEC, pp->scyl,  0, maxcyl, NULL);
		EDIT("BIOS Starting head",     ASK_DEC, pp->shead, 0, maxhead, NULL);
		EDIT("BIOS Starting sector",   ASK_DEC, pp->ssect, 1, maxsect, NULL);
		EDIT("BIOS Ending cylinder",   ASK_DEC, pp->ecyl,  0, maxcyl, NULL);
		EDIT("BIOS Ending head",       ASK_DEC, pp->ehead, 0, maxhead, NULL);
		EDIT("BIOS Ending sector",     ASK_DEC, pp->esect, 1, maxsect, NULL);
@


1.49
log
@Replace tricker atoi() and hand rolled parsing with strsep() and
strtonum(). Make related error messages consistant.

ok haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.48 2012/07/07 16:00:19 krw Exp $	*/
d244 1
a246 1
	pp = &mbr->part[pn];
d250 5
a254 4
#define	EDIT(p, f, v, n, m, h)				\
	if ((num = ask_num(p, f, v, n, m, h)) != v)	\
		ret = CMD_DIRTY;			\
	v = num;
d256 1
a256 2
	/* Ask for partition type */
	EDIT("Partition id ('0' to disable) ", ASK_HEX, pp->id, 0, 0xFF, PRT_printall);
a257 1
#undef EDIT
@


1.48
log
@Replace atoi() with strtonum() where it's easy. Make related error
messages consistant. Check for valid partition when 'select'ing a
partition.

ok haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.47 2012/04/25 04:21:45 matthew Exp $	*/
d412 1
d414 4
a417 1
	char *p;
d419 3
a421 4
	/* Parse partition table entry number */
	if (!isdigit(cmd->args[0])) {
		printf("Invalid argument: %s <partition number> [value]\n",
		    cmd->cmd);
a423 4
	pn = atoi(cmd->args);
	p = strchr(cmd->args, ' ');
	if (p != NULL)
		val = strtol(p + 1, NULL, 0) & 0xff;
d425 6
a430 3
	if (pn < 0 || pn > 3) {
		printf("Invalid partition number.\n");
		return (CMD_CONT);
@


1.47
log
@Before writing it to disk, warn the user if their new MBR contains
more than one OpenBSD partition.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.46 2011/11/11 18:21:06 krw Exp $	*/
d103 1
d109 3
a111 9
	if (!isdigit(cmd->args[0])) {
		printf("Invalid argument: %s <from partition number>\n",
		    cmd->cmd);
		return (ret);
	}

	pf = atoi(cmd->args);
	if (pf < 0 || pf > 3) {
		printf("Invalid partition number %d.\n", pf);
d140 1
d146 3
a148 8
	if (!isdigit(cmd->args[0])) {
		printf("Invalid argument: %s <partition number>\n", cmd->cmd);
		return (ret);
	}
	pn = atoi(cmd->args);

	if (pn < 0 || pn > 3) {
		printf("Invalid partition number.\n");
d233 1
d239 3
a241 8
	if (!isdigit(cmd->args[0])) {
		printf("Invalid argument: %s <partition number>\n", cmd->cmd);
		return (ret);
	}
	pn = atoi(cmd->args);

	if (pn < 0 || pn > 3) {
		printf("Invalid partition number.\n");
d266 1
d271 3
a273 2
	if (!isdigit(cmd->args[0])) {
		printf("Invalid argument: %s <partition number>\n", cmd->cmd);
a276 1
	pn = atoi(cmd->args);
@


1.46
log
@A zero-length partition is a non-partition, so reject a partition
length of 0. And anyway PRT_fix_CHS() writes garbage when length
is zero.

Refresh the in-memory copy to reflect any data that was written
out, so you can see that your changes have taken effect.

Surprise behaviours noted by matthew@@ at c2k11.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.45 2010/07/02 02:54:09 halex Exp $	*/
d331 10
a340 1
	int fd;
@


1.45
log
@on error, getuint() will return UINT_MAX. Instead of actually using
that value, print an error message and repost the question

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.44 2009/12/24 10:06:35 sobrado Exp $	*/
d227 1
a227 1
			if (pp->ns == UINT_MAX)
d229 1
a229 1
		} while (pp->ns == UINT_MAX);
d345 3
@


1.44
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.43 2009/02/08 18:03:18 krw Exp $	*/
d38 1
d203 1
d206 9
a214 4
		pp->bs = getuint(disk, "offset",
		   "Starting sector for this partition.", pp->bs,
		   disk->real->size, 0, DO_CONVERSIONS |
		   (pp->id == FS_BSDFFS ? DO_ROUNDING : 0));
d221 9
a229 4
		pp->ns = getuint(disk, "size", "Size of the partition.",
		    pp->ns, m, pp->bs , DO_CONVERSIONS |
		    ((pp->id == FS_BSDFFS || pp->id == FS_SWAP) ?
		    DO_ROUNDING : 0));
@


1.43
log
@Eliminate excessive verbiage for 'fdisk -i' and 'fdisk -u'. Especially
the multi-line banner announcing that the MBR is being changed.
Also the listing of the partition table in 'fdisk -u'. Display a
consistant message when the MBR is written.

While here cleanup and shrink code without changing any semantics.
Started with a diff posted on tech@@ by Tobias Ulmer.

"I like it" marco@@ ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.42 2006/07/27 04:06:13 ray Exp $	*/
d297 1
a297 1
	/* Recursion is beautifull! */
@


1.42
log
@Add checks to each write(2) attempt and try to keep fdisk in a
consistent state upon write failure.

OK krw@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.41 2006/07/18 19:05:42 mbalmer Exp $	*/
d28 2
d319 1
a319 1
	int fd, ret;
d321 2
a322 1
	ret = CMD_CONT;
d325 8
d334 1
a334 6
	fd = DISK_open(disk->name, O_RDWR);
	MBR_make(mbr, mbr_buf);
	if (MBR_write(fd, offset, mbr_buf) != -1)
		ret = CMD_CLEAN;
	close(fd);
	return (ret);
@


1.41
log
@Fix a typo, paritition -> partition.
From Alexey Dobriyan <adobriyan@@gmail.com>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.40 2006/04/26 17:10:43 deraadt Exp $	*/
d317 3
a319 1
	int fd;
d325 2
a326 1
	MBR_write(fd, offset, mbr_buf);
d328 1
a328 1
	return (CMD_CLEAN);
@


1.40
log
@man page is gzip'd, should store as unsigned char array.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.39 2005/03/29 19:35:25 otto Exp $	*/
d117 1
a117 1
	pt = ask_num("Swap with what paritition?", ASK_DEC,
@


1.39
log
@Allow setting of partition flag with an optional explicit value. PR 4143.
ok weingart@@ deraadr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.38 2005/01/19 15:48:20 deraadt Exp $	*/
d433 1
a433 1
	extern const char manpage[];
@


1.38
log
@add a swap primitive; ok various, will be polished after by tom
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.37 2004/11/06 18:57:59 otto Exp $	*/
d391 2
a392 1
	int i, pn = -1;
d396 2
a397 1
		printf("Invalid argument: %s <partition number>\n", cmd->cmd);
d401 3
d410 12
a421 6
	/* Set active flag */
	for (i = 0; i < 4; i++) {
		if (i == pn)
			mbr->part[i].flag = DOSACTIVE;
		else
			mbr->part[i].flag = 0x00;
a422 2

	printf("Partition %d marked active.\n", pn);
@


1.37
log
@gzip embedded man pages, and pipe through gunzip when viewing.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.36 2004/09/18 23:22:05 deraadt Exp $	*/
d95 42
@


1.36
log
@some delinting; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.35 2004/07/13 06:00:33 tom Exp $	*/
d382 2
a383 1
	extern char manpage[];
d389 7
a395 4
	f = popen(pager, "w");
	if (f) {
		(void) fwrite(manpage, strlen(manpage), 1, f);
		pclose(f);
@


1.35
log
@Remove unused argument 'int pn' to PRT_fix_CHS().  The 'int pn'
argument to PRT_parse() then becomes unused, so remove that too.

ok henning@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.34 2004/06/22 23:01:55 tom Exp $	*/
d63 1
d96 1
d182 1
d218 2
d258 1
d270 1
d286 1
d300 1
d311 1
d320 1
d333 1
d345 1
d375 1
@


1.34
log
@Make the interactive "update" command match the command-line "-u"
option by updatng/setting the 0xAA55 signature at the end of the sector.

ok nick@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.33 2003/06/11 06:22:12 deraadt Exp $	*/
d153 1
a153 1
		PRT_fix_CHS(disk, pp, pn);
d174 1
a174 1
		PRT_fix_CHS(disk, pp, pn);
@


1.33
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.32 2003/06/03 01:13:19 weingart Exp $	*/
d328 1
@


1.32
log
@Nuke terms 3 & 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.31 2002/01/24 04:40:03 mickey Exp $	*/
d44 1
a44 6
Xreinit(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d64 1
a64 6
Xdisk(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d96 1
a96 6
Xedit(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d181 1
a181 6
Xsetpid(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d216 1
a216 6
Xselect(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d254 1
a254 6
Xprint(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d265 1
a265 6
Xwrite(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d293 1
a293 6
Xabort(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d303 1
a303 6
Xexit(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d311 1
a311 6
Xhelp(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d323 1
a323 6
Xupdate(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d333 1
a333 6
Xflag(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
d362 1
a362 6
Xmanual(cmd, disk, mbr, tt, offset)
	cmd_t *cmd;
	disk_t *disk;
	mbr_t *mbr;
	mbr_t *tt;
	int offset;
@


1.31
log
@allow reinitializing mbr in the ext parts; from Matt Watson <mwatson@@apple.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.30 2002/01/18 08:38:26 kjell Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.30
log
@Allow size values to be displayed in the user's choice of units.
Idea borrowed from disklabel. i.e. Users can now type "print M"
and be rewarded with partition sizes in Megs
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.29 2002/01/18 08:33:10 kjell Exp $	*/
d60 1
a60 1
	MBR_parse(disk, buf, 0, 0, mbr);
@


1.29
log
@Add disklabel-style editing for size/offset values in
the partition tables. These values may now contain units,
such as "300k" "500M" or "2G".
(sectors, bytes, and cylinders are also supported.)
This should largely eliminate the need for a calculator
when using fdisk on large disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.28 2001/01/28 00:56:07 weingart Exp $	*/
d67 1
a67 1
	MBR_print(mbr);
d86 1
a86 1
	DISK_printmetrics(disk);
d136 2
a137 2
	PRT_print(0, NULL);
	PRT_print(pn, pp);
d226 2
a227 2
	PRT_print(0, NULL);
	PRT_print(pn, pp);
d292 1
a292 1
	DISK_printmetrics(disk);
d294 1
a294 1
	MBR_print(mbr);
@


1.28
log
@More -Wall cleanup.  Ansi style nit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.27 2001/01/01 21:05:33 angelos Exp $	*/
d178 5
a182 2
		EDIT("Partition offset", ASK_DEC, pp->bs, 0,
		    disk->real->size, NULL);
d188 4
a191 2
		EDIT("Partition size", ASK_DEC, pp->ns, 1,
		    m, NULL);
@


1.27
log
@New command "setpid", just changes the ID of a partition (no other
parameters editing) -- vassilip@@dsl.cis.upenn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.26 2000/07/01 21:49:12 mickey Exp $	*/
d243 1
a243 1
	static firstoff = 0;
d431 1
a431 1
	sig_t opipe = signal(SIGPIPE, SIG_IGN);
d435 1
d447 1
@


1.26
log
@be more verbose when warning for partition errors,
print partition number in the message.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.25 2000/04/18 22:40:15 kjell Exp $	*/
d195 40
@


1.25
log
@Favor BIOS geometry over physical. This should fix MANY problems with
hard drives >8G sharing partitions with other operating systems.
Also, support extended partition type 0x0F, which is quite common now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.24 2000/02/04 18:09:36 kjell Exp $	*/
d171 1
a171 1
		PRT_fix_BN(disk, pp);
d173 1
a173 1
		PRT_fix_CHS(disk, pp);
d189 1
a189 1
		PRT_fix_CHS(disk, pp);
@


1.24
log
@Max Sectors is 63. ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.23 2000/01/08 04:51:16 deraadt Exp $	*/
d216 2
a217 1
	if (mbr->part[pn].id != DOSPTYP_EXTEND) {
@


1.23
log
@support LBA-mapped extended partitions too; sigh@@kuzirabekon.econ.nagasaki-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.22 1999/08/21 22:49:25 niklas Exp $	*/
d83 1
a83 1
	int maxsec  = 64;
@


1.22
log
@MIPS boxes that use fdisk need an MS-DOS partition
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.21 1999/06/10 22:38:01 pjanzen Exp $	*/
d172 2
@


1.21
log
@Handle PAGER in a manner consistent with the Single Unix Specification:
that is, use PAGER rather than "more" if it is defined and non-null, not
just if it is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.20 1998/09/14 03:54:34 rahnds Exp $	*/
d88 1
a88 1
#ifdef __powerpc__
@


1.20
log
@Since on the powerpc, the system does not supply the user with
bios valid cyl,head,sector information (the information comes from the
sd driver) I have made some changes to fdisk to do the following.

Allow the powerpc to specify values larger than the bios limits.

All platforms now have code that will translate the LBA values
in the mbr into CHS values according to the disk geometry.
This occurs if the start and ending CHS values have been stored as
0xffffff.

If writing to the disk and one of the values of a partition violates
the bios limits, it writes the requested values in the LBA fields ,
and stores 0xffffff for the starting and ending CHS values.

This should not change the default formatting of any existing system
other than the CHS and LBA values should always match given the detected
geometry of the disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.19 1998/09/08 11:03:15 pefo Exp $	*/
d387 1
d392 2
a393 2
	if (getenv("PAGER"))
		pager = getenv("PAGER");
@


1.19
log
@For powerpc's we want to keep the preinstalled msdos partition in the init
MBR when doing a 'fdisk -i'. That is because the msdos partition is used
for booting. The OpenBSD part (part 3) is set up to be the rest of the
disk. Also the msdos partition is set as the 'active' partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.18 1998/08/08 05:27:59 downsj Exp $	*/
d60 1
a60 1
	MBR_parse(buf, 0, 0, mbr);
d62 1
a62 30
	/* Fix up given mbr for this disk */
	mbr->part[0].flag = 0;
	mbr->part[1].flag = 0;
	mbr->part[2].flag = 0;
	mbr->part[3].flag = DOSACTIVE;
	mbr->signature = DOSMBR_SIGNATURE;

	/* Use whole disk, save for first head, on first cyl. */
	mbr->part[3].id = DOSPTYP_OPENBSD;
	mbr->part[3].scyl = 0;
	mbr->part[3].shead = 1;
	mbr->part[3].ssect = 1;

	/* Go right to the end */
	mbr->part[3].ecyl = disk->real->cylinders - 1;
	mbr->part[3].ehead = disk->real->heads - 1;
	mbr->part[3].esect = disk->real->sectors;

	/* Fix up start/length fields */
	PRT_fix_BN(disk, &mbr->part[3]);

#if defined(__powerpc__)
	/* Now fix up for the MS-DOS boot partition on PowerPC. */
	mbr->part[0].flag = DOSACTIVE;	/* Boot from dos part */
	mbr->part[3].flag = 0;
	mbr->part[3].ns += mbr->part[3].bs;
	mbr->part[3].bs = mbr->part[0].bs + mbr->part[0].ns;
	mbr->part[3].ns -= mbr->part[3].bs;
	PRT_fix_CHS(disk, &mbr->part[3]);
#endif
d81 3
d88 6
d97 1
a97 1
		    disk->real->cylinders, 1, 1024, NULL);
d99 1
a99 1
		    disk->real->heads, 1, 256, NULL);
d101 1
a101 1
		    disk->real->sectors, 1, 64, NULL);
d179 4
@


1.18
log
@Include signal.h so that it compiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.17 1998/08/07 21:49:18 millert Exp $	*/
d82 10
@


1.17
log
@protect against SIGPIPE
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.16 1998/01/04 23:57:29 deraadt Exp $	*/
d38 1
@


1.16
log
@fix maximal cyl/heads; vons@@usa.net
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.15 1997/12/23 23:52:58 deraadt Exp $	*/
d392 1
d404 1
@


1.15
log
@swap exit and quit
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.14 1997/10/21 22:49:32 provos Exp $	*/
d74 4
a77 4
	/* Go right to the end */                                                  
	mbr->part[3].ecyl = disk->real->cylinders;                                  
	mbr->part[3].ehead = disk->real->heads;                                     
	mbr->part[3].esect = disk->real->sectors;                                   
d79 2
a80 2
	/* Fix up start/length fields */                                           
	PRT_fix_BN(disk, &mbr->part[3]);                                            
@


1.14
log
@make fdisk grok extended partitions again. we have to keep track of the
absolute offset of the current mbr and its relative position. because:
the starting sector of the first mbr entry in an extended partition is relative
to the starting offset of the whole mbr itself. the starting offset of a new
extended partition is relative to the offset of the very first extended
partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.13 1997/10/19 23:58:50 deraadt Exp $	*/
d277 1
a277 1
Xexit(cmd, disk, r, tt, offset)
d305 1
a305 1
Xquit(cmd, disk, mbr, tt, offset)
@


1.13
log
@when we reinit, show what we did
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.12 1997/10/19 23:37:25 deraadt Exp $	*/
d59 1
a59 1
	MBR_parse(buf, mbr);
d206 1
d223 4
d236 1
a236 1
	USER_modify(disk, tt, off);
@


1.12
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.11 1997/10/19 23:33:54 deraadt Exp $	*/
d83 3
a85 1
	printf("In memory copy is initialized.\n");
@


1.11
log
@clarify
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.10 1997/10/19 23:29:35 deraadt Exp $	*/
d157 1
a157 1
		printf("Partiton %d cleared.\n", pn);
@


1.10
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.9 1997/10/19 23:13:48 deraadt Exp $	*/
d152 1
a152 1
	EDIT("Partition id", ASK_HEX, pp->id, 0, 0xFF, PRT_printall);
@


1.9
log
@for p, print disk info too
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.8 1997/10/18 11:52:32 deraadt Exp $	*/
d86 1
a86 1
	return(CMD_DIRTY);
d102 1
a102 1
	if(ask_yn("Change disk geometry?")){
d114 1
a114 1
	return(CMD_CONT);
d130 1
a130 1
	if(!isdigit(cmd->args[0])){
d136 1
a136 1
	if(pn < 0 || pn > 3){
d155 1
a155 1
	if(pp->id == DOSPTYP_UNUSED){
d158 1
a158 1
		return(ret);
d162 1
a162 1
	if(ask_yn("Do you wish to edit in CHS mode?")){
d179 1
a179 1
	}else{
d181 1
d193 1
a193 1
	return(ret);
d207 1
a207 1
	if(!isdigit(cmd->args[0])){
d209 1
a209 1
		return(CMD_CONT);
d216 1
a216 1
	if(mbr->part[pn].id != DOSPTYP_EXTEND){
d218 1
a218 1
		return(CMD_CONT);
d220 1
a220 1
	if(!off){
d222 2
a223 2
		return(CMD_CONT);
	}else{
d230 1
a230 2

	return(CMD_CONT);
d246 1
a246 1
	return(CMD_CONT);
d266 1
a266 1
	return(CMD_CLEAN);
d279 1
a279 1
	return(CMD_SAVE);
d293 1
a293 1
	return(CMD_CONT);
d307 1
a307 1
	return(CMD_EXIT);
d322 1
a322 1
	for(i = 0; cmd_table[i].cmd != NULL; i++){
d324 1
a324 3
	}

	return(CMD_CONT);
a337 1

d339 1
a339 2

	return(CMD_DIRTY);
d353 1
a353 1
	if(!isdigit(cmd->args[0])){
d355 1
a355 1
		return(CMD_CONT);
d359 1
a359 1
	if(pn < 0 || pn > 3){
d361 1
a361 1
		return(CMD_CONT);
d365 5
a369 3
	for(i = 0; i < 4; i++){
		if(i == pn) mbr->part[i].flag = DOSACTIVE;
		else mbr->part[i].flag = 0x00;
d373 1
a373 2

	return(CMD_DIRTY);
d384 1
d388 3
a390 1
	f = popen("/usr/bin/less", "w");
@


1.8
log
@constrain edit mode to size of BIOS part of disk; sorry
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.7 1997/10/16 10:35:05 deraadt Exp $	*/
d242 1
@


1.7
log
@new command: manual
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.6 1997/10/16 01:47:08 deraadt Exp $	*/
d45 1
a45 1

d180 1
d184 1
d186 1
a186 1
		     disk->real->size - pp->bs, NULL);
@


1.6
log
@a bunch of improvements by weingart & I
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.5 1997/10/04 00:09:51 deraadt Exp $	*/
d376 19
@


1.5
log
@do not ask for confirmation in write
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.4 1997/10/02 14:58:30 deraadt Exp $	*/
d48 1
a48 1
Xinit(cmd, disk, mbr, tt, offset)
d57 1
a57 1
	/* Copy MBR */
d61 21
d102 7
a108 4
	if(ask_yn("Change geometry?")){
		disk->bios->cylinders = ask_num("Cylinders", ASK_DEC, 1, 1, 1024);
		disk->bios->heads = ask_num("Heads", ASK_DEC, 1, 1, 256);
		disk->bios->sectors = ask_num("Sectors", ASK_DEC, 1, 1, 64);
d110 2
a111 2
		disk->bios->size = disk->bios->cylinders * disk->bios->heads
			* disk->bios->sectors;
d146 2
a147 2
#define	EDIT(p, f, v, n, m)				\
	if ((num = ask_num(p, f, v, n, m)) != v)	\
d152 1
a152 1
	EDIT("Partition id", ASK_HEX, pp->id, 0, 0xFF);
d166 3
a168 3
		maxcyl = disk->bios->cylinders - 1;
		maxhead = disk->bios->heads - 1;
		maxsect = disk->bios->sectors;
d171 6
a176 6
		EDIT("Starting cylinder", ASK_DEC, pp->scyl,  0, maxcyl);
		EDIT("Starting head",     ASK_DEC, pp->shead, 0, maxhead);
		EDIT("Starting sector",   ASK_DEC, pp->ssect, 1, maxsect);
		EDIT("Ending cylinder",   ASK_DEC, pp->ecyl,  0, maxcyl);
		EDIT("Ending head",       ASK_DEC, pp->ehead, 0, maxhead);
		EDIT("Ending sector",     ASK_DEC, pp->esect, 1, maxsect);
d181 4
a184 3
		EDIT("Partition offset", ASK_DEC, pp->bs, 0, disk->bios->size);
		EDIT("Partition size",   ASK_DEC, pp->ns, 1,
		     disk->bios->size - pp->bs);
d240 1
d276 1
a276 1
	return(CMD_EXIT);
d280 1
a280 1
Xquit(cmd, disk, mbr, tt, offset)
d287 5
a291 1
	extern int modified;
a292 2
	if (modified == 0)
		exit(0);
d294 8
a301 2
	if(ask_yn("You really want to quit?"))
		exit(0);
d303 2
a304 1
	return(CMD_CONT);
@


1.4
log
@do not whine if user quits without mods
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.3 1997/09/30 00:07:25 mickey Exp $	*/
d231 1
a231 2
	if(ask_yn("Are you sure?")){
		printf("Writing MBR at offset %d.\n", offset);
d233 5
a237 9
		fd = DISK_open(disk->name, O_RDWR);
		MBR_make(mbr, mbr_buf);
		MBR_write(fd, offset, mbr_buf);
		close(fd);

		return(CMD_CLEAN);
	}

	return(CMD_CONT);
@


1.3
log
@don't say 'dirty' if nothing is changed actually
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.2 1997/09/29 23:33:32 mickey Exp $	*/
d266 4
@


1.2
log
@ID in the first line w/ tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.1 1997/09/29 22:58:14 weingart Exp $	*/
d101 1
a101 1
	int num;
d104 2
d108 1
a108 1
		return(CMD_CONT);
d110 1
a110 1
	num = atoi(cmd->args);
d112 1
a112 1
	if(num < 0 || num > 3){
d114 1
a114 1
		return(CMD_CONT);
d118 1
a118 1
	pp = &mbr->part[num];
d120 6
a125 1
	PRT_print(num, pp);
d128 1
a128 1
	pp->id = ask_num("Partition id", ASK_HEX, pp->id, 0, 0xFF);
d133 2
a134 2
		printf("Partiton %d cleared.\n", num);
		return(CMD_DIRTY);
d147 6
a152 7
		pp->scyl = ask_num("Starting cylinder", ASK_DEC, pp->scyl, 0, maxcyl);
		pp->shead = ask_num("Starting head", ASK_DEC, pp->shead, 0, maxhead);
		pp->ssect = ask_num("Starting sector", ASK_DEC, pp->ssect, 1, maxsect);
		pp->ecyl = ask_num("Ending cylinder", ASK_DEC, pp->ecyl, 0, maxcyl);
		pp->ehead = ask_num("Ending head", ASK_DEC, pp->ehead, 0, maxhead);
		pp->esect = ask_num("Ending sector", ASK_DEC, pp->esect, 1, maxsect);

a155 3
		int start, size;


d157 3
a159 5
		start = disk->bios->size;
		pp->bs = ask_num("Partition offset", ASK_DEC, pp->bs, 0, start);

		size = disk->bios->size - pp->bs;
		pp->ns = ask_num("Partition size", ASK_DEC, pp->ns, 1, size);
d164 2
a165 2

	return(CMD_DIRTY);
d177 1
a177 1
	int num;
d184 2
a185 2
	num = atoi(cmd->args);
	off = mbr->part[num].bs;
d188 2
a189 2
	if(mbr->part[num].id != DOSPTYP_EXTEND){
		printf("Partition %d is not an extended partition.\n", num);
d196 1
a196 1
		printf("Selected extended partition %d\n", num);
d317 1
a317 1
	int i, num = -1;
d324 1
a324 1
	num = atoi(cmd->args);
d326 1
a326 1
	if(num < 0 || num > 3){
d333 1
a333 1
		if(i == num) mbr->part[i].flag = DOSACTIVE;
d337 1
a337 1
	printf("Partition %d marked active.\n", num);
@


1.1
log
@New fdisk code with interactive (command line type)
editing code.  Rewrite from the ground up, save about
20 lines of code.  Seems to create valid partition
tables on i386 and alphas.
@
text
@d1 1
a1 2

/* $OpenBSD$ */
@
