head	1.87;
access;
symbols
	OPENBSD_3_9:1.86.0.4
	OPENBSD_3_9_BASE:1.86
	OPENBSD_3_8:1.86.0.2
	OPENBSD_3_8_BASE:1.86
	OPENBSD_3_7:1.84.0.2
	OPENBSD_3_7_BASE:1.84
	OPENBSD_3_6:1.80.0.2
	OPENBSD_3_6_BASE:1.80
	OPENBSD_3_5:1.74.0.2
	OPENBSD_3_5_BASE:1.74
	OPENBSD_3_4:1.69.0.2
	OPENBSD_3_4_BASE:1.69
	OPENBSD_3_3:1.66.0.2
	OPENBSD_3_3_BASE:1.66
	OPENBSD_3_2:1.64.0.2
	OPENBSD_3_2_BASE:1.64
	OPENBSD_3_1:1.63.0.2
	OPENBSD_3_1_BASE:1.63
	OPENBSD_3_0:1.62.0.2
	OPENBSD_3_0_BASE:1.62
	OPENBSD_2_9:1.53.0.2
	OPENBSD_2_9_BASE:1.53
	OPENBSD_2_8:1.48.0.2
	OPENBSD_2_8_BASE:1.48
	OPENBSD_2_7:1.38.0.2
	OPENBSD_2_7_BASE:1.38
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16;
locks; strict;
comment	@ * @;


1.87
date	2006.05.26.04.02.59;	author deraadt;	state dead;
branches;
next	1.86;

1.86
date	2005.06.07.02.36.41;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2005.05.25.05.51.13;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2004.12.28.15.19.23;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2004.11.25.21.32.52;	author markus;	state Exp;
branches;
next	1.82;

1.82
date	2004.09.27.03.20.21;	author jaredy;	state Exp;
branches;
next	1.81;

1.81
date	2004.09.25.18.29.46;	author jaredy;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.25.02.35.36;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2004.05.23.16.04.18;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2004.05.23.08.48.03;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.14.20.29.52;	author ish;	state Exp;
branches;
next	1.76;

1.76
date	2004.05.10.06.24.42;	author ish;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.09.03.21.35;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.27.22.46.55;	author itojun;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.27.09.26.22;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.15.10.15.55;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2003.12.02.23.16.29;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2003.09.23.18.09.20;	author itojun;	state Exp;
branches;
next	1.69;

1.69
date	2003.07.24.09.59.02;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.24.08.03.19;	author itojun;	state Exp;
branches;
next	1.67;

1.67
date	2003.07.02.21.44.57;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.25.22.29.33;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2003.02.15.22.57.58;	author jason;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2001.12.01.19.05.01;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2001.08.05.11.10.34;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.06.05.01.07;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2001.07.05.08.38.36;	author jjbg;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.26.21.10.28;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.26.20.44.22;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.25.05.16.10;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.08.19.39.02;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.05.00.17.47;	author niklas;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.30.16.44.41;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2001.04.19.20.12.45;	author niklas;	state Exp;
branches;
next	1.52;

1.52
date	2001.03.28.19.15.43;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2001.03.22.03.34.18;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.03.08.21.41.42;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2000.11.17.04.10.21;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2000.10.25.19.08.57;	author jason;	state Exp;
branches;
next	1.47;

1.47
date	2000.10.18.00.42.30;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.16.23.00.40;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	2000.10.09.22.21.41;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.29.19.06.53;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2000.09.21.02.38.20;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2000.09.21.01.34.19;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2000.09.20.21.28.23;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.19.08.38.41;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2000.09.19.03.18.11;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2000.05.02.21.50.30;	author ho;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.22.02.43.15;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.22.02.40.01;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.22.01.53.41;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2000.04.21.17.32.24;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.03.28.14.30.51;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2000.02.08.12.50.25;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.27.08.04.02;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.13.04.46.18;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.09.22.53.40;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	99.12.20.05.38.22;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	99.12.06.21.58.39;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	99.12.04.23.26.27;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	99.11.04.11.29.35;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	99.09.07.12.35.27;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	99.08.25.15.36.57;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	99.08.05.22.02.04;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	99.07.15.14.56.26;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.07.02.23.37.32;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.06.05.19.32.57;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.06.05.17.05.34;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.04.18.15.06.58;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	99.03.29.04.52.53;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	99.03.27.21.04.18;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	99.03.15.15.37.02;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.03.04.19.58.43;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	99.02.27.07.29.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.02.26.10.04.05;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	99.02.26.02.04.52;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	99.02.25.22.32.05;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	99.02.25.10.21.25;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.02.25.00.02.27;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.02.24.23.47.18;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.02.24.23.32.53;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.02.24.22.53.37;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.02.17.20.39.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.02.13.00.19.48;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	98.11.14.23.37.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.87
log
@let us not talk about ipsecadm and vpn anymore; ok reyk
@
text
@/* $OpenBSD: ipsecadm.c,v 1.86 2005/06/07 02:36:41 henning Exp $ */
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
 * Niels Provos (provos@@physnet.uni-hamburg.de).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece,
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 * Copyright (c) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <sys/param.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/sysctl.h>
#include <sys/uio.h>
#include <sys/stat.h>

#include <net/if.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <net/pfkeyv2.h>
#include <netinet/ip_ipsp.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <netdb.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>
#include <err.h>

#define KEYSIZE_LIMIT	1024

#define ESP_OLD		0x0001
#define ESP_NEW		0x0002
#define AH_OLD		0x0004
#define AH_NEW		0x0008

#define XF_ENC		0x0100
#define XF_AUTH		0x0200
#define DEL_SPI		0x0300
#define GRP_SPI		0x0400
#define FLOW		0x0500
#define FLUSH		0x0700
#define XF_COMP		0x0900
#define SHOW		0x0a00
#define MONITOR		0x0b00

/* pseudo commands */
#define IPCOMP		0x1000
#define TCPMD5		0x2000
#define ENC_IP		0x4000

#define CMD_MASK	0xff00
#define XFORM_MASK	0x0f00

#define isencauth(x)	((x)&~CMD_MASK)
#define iscmd(x,y)	(((x) & CMD_MASK) == (y))

typedef struct {
	char	*name;
	int	id, flags;
} transform;

transform xf[] = {
	{ "null", SADB_EALG_NULL, XF_ENC | ESP_NEW },
	{ "des", SADB_EALG_DESCBC, XF_ENC | ESP_OLD | ESP_NEW },
	{ "3des", SADB_EALG_3DESCBC, XF_ENC | ESP_OLD | ESP_NEW },
	{ "aes", SADB_X_EALG_AES, XF_ENC | ESP_NEW },
	{ "aesctr", SADB_X_EALG_AESCTR, XF_ENC | ESP_NEW },
	{ "blf", SADB_X_EALG_BLF, XF_ENC | ESP_NEW },
	{ "cast", SADB_X_EALG_CAST, XF_ENC | ESP_NEW },
	{ "skipjack", SADB_X_EALG_SKIPJACK, XF_ENC | ESP_NEW },
	{ "md5", SADB_AALG_MD5HMAC, XF_AUTH | AH_NEW | ESP_NEW },
	{ "sha1", SADB_AALG_SHA1HMAC, XF_AUTH | AH_NEW | ESP_NEW },
	{ "sha2-256", SADB_X_AALG_SHA2_256, XF_AUTH | AH_NEW | ESP_NEW },
	{ "sha2-384", SADB_X_AALG_SHA2_384, XF_AUTH | AH_NEW | ESP_NEW },
	{ "sha2-512", SADB_X_AALG_SHA2_512, XF_AUTH | AH_NEW | ESP_NEW },
	{ "md5", SADB_X_AALG_MD5, XF_AUTH | AH_OLD },
	{ "sha1", SADB_X_AALG_SHA1, XF_AUTH | AH_OLD },
	{ "rmd160", SADB_X_AALG_RIPEMD160HMAC, XF_AUTH | AH_NEW | ESP_NEW },
	{ "deflate", SADB_X_CALG_DEFLATE, XF_COMP | IPCOMP },
	{ "lzs", SADB_X_CALG_LZS, XF_COMP | IPCOMP },
};

#define ROUNDUP(x) (((x) + sizeof(u_int64_t) - 1) & ~(sizeof(u_int64_t) - 1))

void	ipsecadm_monitor(void);
void	ipsecadm_show(u_int8_t);
int	addrparse(const char *, struct sockaddr *, struct sockaddr *);
void	xf_set(struct iovec *, int, int);
int	x2i(u_char *);
int	isvalid(char *, int, int);
__dead void usage(void);

/*
 * returns 0 if "str" represents an address, returns 1 if address/mask,
 * returns -1 on failure.
 */
int
addrparse(const char *str, struct sockaddr *addr, struct sockaddr *mask)
{
	struct addrinfo hints, *res = NULL;
	char	*p = NULL, *sp, *ep;
	u_long	prefixlen = 0;
	u_char	*ap;
	int	bitlen;

	/* slash */
	if (mask && (p = strchr(str, '/')) != NULL) {
		if (!p[1])
			return -1;
		ep = NULL;
		prefixlen = strtoul(p + 1, &ep, 10);
		if (*ep)
			return -1;

		sp = strdup(str);
		if (!sp)
			return -1;
		sp[p - str] = '\0';
		str = sp;
	} else
		sp = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;	/* dummy */
	hints.ai_flags = AI_NUMERICHOST;
	hints.ai_family = PF_UNSPEC;
	if (getaddrinfo(str, "0", &hints, &res) != 0)
		return -1;
	if (res->ai_next)
		goto fail;

	memcpy(addr, res->ai_addr, res->ai_addrlen);

	if (!p) {
		freeaddrinfo(res);
		if (sp)
			free(sp);
		return 0;
	}
	switch (res->ai_family) {
	case AF_INET:
		ap = (u_char *) & ((struct sockaddr_in *) mask)->sin_addr;
		bitlen = 32;
		break;
	case AF_INET6:
		ap = (u_char *) & ((struct sockaddr_in6 *) mask)->sin6_addr;
		bitlen = 128;
		break;
	default:
		goto fail;
	}

	if (prefixlen > bitlen)
		goto fail;

	memset(mask, 0, addr->sa_len);
	mask->sa_len = addr->sa_len;
	mask->sa_family = addr->sa_family;
	memset(ap, 0xff, prefixlen / 8);
	if (prefixlen % 8)
		ap[prefixlen / 8] = (0xff00 >> (prefixlen % 8)) & 0xff;

	if (res)
		freeaddrinfo(res);
	if (sp)
		free(sp);
	return 1;

fail:
	if (res)
		freeaddrinfo(res);
	if (sp)
		free(sp);
	return -1;
}

void
xf_set(struct iovec *iov, int cnt, int len)
{
	struct sadb_msg sm;
	int sd;

	sd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2);
	if (sd < 0)
		errx(1, "socket: %s%s", strerror(errno),
		    errno == EPROTONOSUPPORT ?
		    "\nMake sure your kernel is compiled with option KEY" : "");
	if (writev(sd, iov, cnt) != len)
		err(1, "write");
	if (read(sd, &sm, sizeof(sm)) != sizeof(sm))
		err(1, "read");
	if (sm.sadb_msg_errno != 0) {
		/* XXX We need better error reporting than this */
		errno = sm.sadb_msg_errno;
		err(1, "pfkey");
	}
	close(sd);
}

int
x2i(u_char *s)
{
	char ss[3];

	ss[0] = s[0];
	ss[1] = s[1];
	ss[2] = 0;

	if (!isxdigit(s[0]) || !isxdigit(s[1]))
		errx(1, "keys should be specified in hex digits");
	return strtoul(ss, NULL, 16);
}

int
isvalid(char *option, int type, int mode)
{
	int i;

	for (i = sizeof(xf) / sizeof(transform) - 1; i >= 0; i--)
		if (!strcmp(option, xf[i].name) &&
		    (xf[i].flags & XFORM_MASK) == type &&
		    (xf[i].flags & mode)) {
			goto gotit;
		}
	return 0;
gotit:
	if (!strcmp(option, "des") || !strcmp(option, "skipjack"))
		warnx("warning: use of %s is strongly discouraged due to"
		    " cryptographic weaknesses", option);
	return xf[i].id;
}

void
usage(void)
{
	fprintf(stderr, "usage: ipsecadm command [modifier ...]\n"
	    "\tCommands: new esp, old esp, new ah, old ah, group, delspi, ip4, ipcomp,\n"
	    "\t\t  tcpmd5, flow, flush, show, monitor\n"
	    "\tPossible modifiers:\n"
	    "\t  -enc <alg>\t\t\tencryption algorithm\n"
	    "\t  -auth <alg>\t\t\tauthentication algorithm\n"
	    "\t  -comp <alg>\t\t\tcompression algorithm\n"
	    "\t  -src <ip>\t\t\tsource address to be used\n"
	    "\t  -halfiv\t\t\tuse 4-byte IV in old ESP\n"
	    "\t  -forcetunnel\t\t\tforce IP-in-IP encapsulation\n"
	    "\t  -udpencap <port>\t\tenable ESP-in-UDP encapsulation\n"
	    "\t  -dst <ip>\t\t\tdestination address to be used\n"
	    "\t  -proto <val>\t\t\tsecurity protocol\n"
	    "\t  -proxy <ip>\t\t\tproxy address to be used\n"
	    "\t  -spi <val>\t\t\tSPI to be used\n"
	    "\t  -cpi <val>\t\t\tCPI to be used\n"
	    "\t  -key <val>\t\t\tkey material to be used\n"
	    "\t  -keyfile <file>\t\tfile to read key material from\n"
	    "\t  -authkey <val>\t\tkey material for auth in new esp\n"
	    "\t  -authkeyfile <file>\t\tfile to read authkey material from\n"
	    "\t  -sport <port>\t\t\tsource port for flow\n"
	    "\t  -dport <port>\t\t\tdestination port for flow\n"
	    "\t  -transport <val>\t\tprotocol number for flow\n"
	    "\t  -addr <srcnet> <mask> <dstnet> <mask>\t\tsubnets for flow\n"
	    "\t  -addr <srcnet/prefix> <dstnet/prefix>\t\tsame as above but in CIDR\n"
	    "\t  -delete\t\t\tdelete specified flow\n"
	    "\t  -bypass\t\t\tpermit a flow through without IPsec\n"
	    "\t  -permit\t\t\tsame as bypass\n"
	    "\t  -deny\t\t\t\tcreate a deny-packets flow\n"
	    "\t  -use\t\t\t\tuse an SA for a flow if it exists\n"
	    "\t  -acquire\t\t\tsend unprotected while acquiring SA\n"
	    "\t  -require\t\t\trequire an SA for a flow, use key mgmt.\n"
	    "\t  -dontacq\t\t\trequire, without using key mgmt.\n"
	    "\t  -in\t\t\t\tspecify incoming-packet policy\n"
	    "\t  -out\t\t\t\tspecify outgoing-packet policy\n"
	    "\t  -[ah|esp|ip4|ipcomp|tcpmd5]\tflush a particular protocol\n"
	    "\t  -srcid <id>\t\t\tsource identity for flows\n"
	    "\t  -dstid <id>\t\t\tdestination identity for flows\n"
	    "\t  -srcid_type <type>\t\tsource identity type\n"
	    "\t  -dstid_type <type>\t\tdestination identity type\n"
	    "\talso: dst2, spi2, proto2\n"
	);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int auth = 0, enc = 0, klen = 0, alen = 0, mode = ESP_NEW, i = 0;
	int proto = IPPROTO_ESP, proto2 = IPPROTO_AH, sproto2 = SADB_SATYPE_AH;
	int dport = -1, sport = -1, tproto = -1;
	int srcset = 0, dstset = 0, dst2set = 0, proxyset = 0;
	int cnt = 0, bypass = 0, deny = 0, ipsec = 0, comp = 0;
	u_int32_t spi = SPI_LOCAL_USE, spi2 = SPI_LOCAL_USE;
	u_int32_t cpi = SPI_LOCAL_USE;
	union sockaddr_union *src, *dst, *dst2, *osrc, *odst, *osmask;
	union sockaddr_union *odmask, *proxy;
	u_char srcbuf[256], dstbuf[256], dst2buf[256], osrcbuf[256];
	u_char odstbuf[256], osmaskbuf[256], odmaskbuf[256], proxybuf[256];
	u_char *keyp = NULL, *authp = NULL;
	u_char *srcid = NULL, *dstid = NULL;
	struct protoent *tp;
	struct servent *svp;
	char *transportproto = NULL;
	struct sadb_msg smsg;
	struct sadb_sa sa, sa2;
	struct sadb_address sad1, sad2, sad3;	/* src, dst, proxy */
	struct sadb_address sad4, sad5;		/* osrc, odst */
	struct sadb_address sad6, sad7, sad8;	/* osmask, odmask, dst2 */
	struct sadb_ident sid1, sid2;
	struct sadb_key skey1, skey2;
	struct sadb_protocol sprotocol, sprotocol2;
	struct sadb_x_udpencap udpencap;	/* Peer UDP Port */
	u_char realkey[8192], realakey[8192];
	struct iovec iov[30];
	struct addrinfo hints, *res;
	const char *errstr;
	u_long ll;
	char *ep;

	if (argc < 2)
		usage();

	/* Zero out */
	memset(&smsg, 0, sizeof(smsg));
	memset(&sa, 0, sizeof(sa));
	memset(&sa2, 0, sizeof(sa2));
	memset(&skey1, 0, sizeof(skey1));
	memset(&skey2, 0, sizeof(skey2));
	memset(&sad1, 0, sizeof(sad1));
	memset(&sad2, 0, sizeof(sad2));
	memset(&sad3, 0, sizeof(sad3));
	memset(&sad4, 0, sizeof(sad4));
	memset(&sad5, 0, sizeof(sad5));
	memset(&sad6, 0, sizeof(sad6));
	memset(&sad7, 0, sizeof(sad7));
	memset(&sad8, 0, sizeof(sad8));
	memset(&sprotocol, 0, sizeof(sprotocol));
	memset(&sprotocol2, 0, sizeof(sprotocol2));
	memset(iov, 0, sizeof(iov));
	memset(realkey, 0, sizeof(realkey));
	memset(realakey, 0, sizeof(realakey));
	memset(&sid1, 0, sizeof(sid1));
	memset(&sid2, 0, sizeof(sid2));
	memset(&udpencap, 0, sizeof(udpencap));

	src = (union sockaddr_union *) srcbuf;
	dst = (union sockaddr_union *) dstbuf;
	dst2 = (union sockaddr_union *) dst2buf;
	osrc = (union sockaddr_union *) osrcbuf;
	odst = (union sockaddr_union *) odstbuf;
	osmask = (union sockaddr_union *) osmaskbuf;
	odmask = (union sockaddr_union *) odmaskbuf;
	proxy = (union sockaddr_union *) proxybuf;

	memset(srcbuf, 0, sizeof(srcbuf));
	memset(dstbuf, 0, sizeof(dstbuf));
	memset(dst2buf, 0, sizeof(dst2buf));
	memset(osrcbuf, 0, sizeof(osrcbuf));
	memset(odstbuf, 0, sizeof(odstbuf));
	memset(osmaskbuf, 0, sizeof(osmaskbuf));
	memset(odmaskbuf, 0, sizeof(odmaskbuf));
	memset(proxybuf, 0, sizeof(proxybuf));

	/* Initialize */
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = 1;
	smsg.sadb_msg_pid = getpid();
	smsg.sadb_msg_len = sizeof(smsg) / 8;

	/* Initialize */
	sa.sadb_sa_exttype = SADB_EXT_SA;
	sa.sadb_sa_len = sizeof(sa) / 8;
	sa.sadb_sa_replay = 0;
	sa.sadb_sa_state = SADB_SASTATE_MATURE;

	sa2.sadb_sa_exttype = SADB_X_EXT_SA2;
	sa2.sadb_sa_len = sizeof(sa) / 8;
	sa2.sadb_sa_replay = 0;
	sa2.sadb_sa_state = SADB_SASTATE_MATURE;

	sid1.sadb_ident_len = sizeof(sid1) / 8;
	sid1.sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;

	sid2.sadb_ident_len = sizeof(sid2) / 8;
	sid2.sadb_ident_exttype = SADB_EXT_IDENTITY_DST;

	sprotocol2.sadb_protocol_len = 1;
	sprotocol2.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
	sprotocol2.sadb_protocol_direction = IPSP_DIRECTION_OUT;
	sprotocol2.sadb_protocol_flags = SADB_X_POLICYFLAGS_POLICY;
	sprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
	sprotocol.sadb_protocol_len = 1;

	if (!strcmp(argv[1], "new") && argc > 3) {
		if (!strcmp(argv[2], "esp")) {
			mode = ESP_NEW;
			smsg.sadb_msg_type = SADB_ADD;
			smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		} else if (!strcmp(argv[2], "ah")) {
			mode = AH_NEW;
			smsg.sadb_msg_type = SADB_ADD;
			smsg.sadb_msg_satype = SADB_SATYPE_AH;
		} else
			errx(1, "unexpected identifier %s", argv[2]);

		i += 2;
	} else if (!strcmp(argv[1], "old") && argc > 3) {
		if (!strcmp(argv[2], "esp")) {
			mode = ESP_OLD;
			smsg.sadb_msg_type = SADB_ADD;
			smsg.sadb_msg_satype = SADB_SATYPE_ESP;
			sa.sadb_sa_flags |= SADB_X_SAFLAGS_RANDOMPADDING;
			sa.sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;
		} else if (!strcmp(argv[2], "ah")) {
			mode = AH_OLD;
			smsg.sadb_msg_type = SADB_ADD;
			smsg.sadb_msg_satype = SADB_SATYPE_AH;
			sa.sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;
		} else
			errx(1, "unexpected identifier %s", argv[2]);

		i += 2;
	} else if (!strcmp(argv[1], "delspi")) {
		smsg.sadb_msg_type = SADB_DELETE;
		smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		mode = DEL_SPI;
		i++;
	} else if (!strcmp(argv[1], "group")) {
		smsg.sadb_msg_type = SADB_X_GRPSPIS;
		smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		mode = GRP_SPI;
		i++;
	} else if (!strcmp(argv[1], "flow")) {
		/* It may not be ADDFLOW, but never mind that for now */
		smsg.sadb_msg_type = SADB_X_ADDFLOW;
		smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		mode = FLOW;
		i++;
	} else if (!strcmp(argv[1], "flush")) {
		mode = FLUSH;
		smsg.sadb_msg_type = SADB_FLUSH;
		smsg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
		i++;
	} else if (!strcmp(argv[1], "ip4")) {
		mode = ENC_IP;
		smsg.sadb_msg_type = SADB_ADD;
		smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
		i++;
	} else if (!strcmp(argv[1], "tcpmd5")) {
		mode = TCPMD5;
		smsg.sadb_msg_type = SADB_ADD;
		smsg.sadb_msg_satype = SADB_X_SATYPE_TCPSIGNATURE;
		i++;
	} else if (!strcmp(argv[1], "ipcomp")) {
		mode = IPCOMP;
		smsg.sadb_msg_type = SADB_ADD;
		smsg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		i++;
	} else if (!strcmp(argv[1], "monitor")) {
		mode = MONITOR;
		i++;
	} else if (!strcmp(argv[1], "show")) {
		mode = SHOW;
		smsg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
		i++;
	} else {
		warnx("unknown command: %s", argv[1]);
		usage();
	}

	for (i++; i < argc; i++) {
		if (argv[i][0] != '-')
			errx(1, "expected option, got %s", argv[i]);
		if (!strcmp(argv[i] + 1, "enc") && enc == 0 && (i + 1 < argc)) {
			if ((enc = isvalid(argv[i + 1], XF_ENC, mode)) == 0)
				errx(1, "invalid encryption algorithm %s",
				    argv[i + 1]);
			skey1.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
			sa.sadb_sa_encrypt = enc;
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "auth") && auth == 0 && (i + 1 < argc)) {
			if ((auth = isvalid(argv[i + 1], XF_AUTH, mode)) == 0)
				errx(1, "invalid auth algorithm %s", argv[i + 1]);
			skey2.sadb_key_exttype = SADB_EXT_KEY_AUTH;
			sa.sadb_sa_auth = auth;
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "comp") && comp == 0 && (i + 1 < argc)) {
			if ((comp = isvalid(argv[i + 1], XF_COMP, mode)) == 0)
				errx(1, "invalid comp algorithm %s", argv[i + 1]);
			/*
			 * Use encryption algo slot to store compression algo
			 * since we cannot modify sadb_sa
			 */
			sa.sadb_sa_encrypt = comp;
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "key") && keyp == NULL &&
		    (i + 1 < argc)) {
			if (mode & (AH_NEW | AH_OLD | TCPMD5)) {
				authp = (u_char *)argv[++i];
				alen = strlen((char *)authp) / 2;
			} else {
				keyp = (u_char *)argv[++i];
				klen = strlen((char *)keyp) / 2;
			}
			continue;
		}
		if (!strcmp(argv[i] + 1, "keyfile") && keyp == NULL &&
		    (i + 1 < argc)) {
			struct stat sb;
			u_char *pptr;
			int fd;

			if (stat(argv[++i], &sb) < 0)
				err(1, "stat");
			if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0))
				errx(1, "file %s is too %s "
				    "(must be between 1 and %d bytes)",
				    argv[i], sb.st_size ? "large" : "small",
				    KEYSIZE_LIMIT);
			if ((pptr = malloc(sb.st_size)) == NULL)
				err(1, "malloc");
			if ((fd = open(argv[i], O_RDONLY)) < 0)
				err(1, "open");
			if (read(fd, pptr, sb.st_size) < sb.st_size)
				err(1, "read");
			close(fd);

			if (mode & (AH_NEW | AH_OLD | TCPMD5)) {
				authp = pptr;
				alen = sb.st_size / 2;
			} else {
				keyp = pptr;
				klen = sb.st_size / 2;
			}
			continue;
		}
		if (!strcmp(argv[i] + 1, "authkeyfile") && authp == NULL &&
		    (i + 1 < argc)) {
			struct stat sb;
			int fd;

			if (!(mode & ESP_NEW))
				errx(1, "invalid option %s for selected mode",
				    argv[i]);
			if (stat(argv[++i], &sb) < 0)
				err(1, "stat");
			if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0))
				errx(1, "file %s is too %s "
				    "(must be between 1 and %d bytes)",
				    argv[i], sb.st_size ? "large" : "small",
				    KEYSIZE_LIMIT);
			if ((authp = malloc(sb.st_size)) == NULL)
				err(1, "malloc");
			if ((fd = open(argv[i], O_RDONLY)) < 0)
				err(1, "open");
			if (read(fd, authp, sb.st_size) < sb.st_size)
				err(1, "read");
			close(fd);

			alen = sb.st_size / 2;
			continue;
		}
		if (!strcmp(argv[i] + 1, "authkey") && authp == NULL &&
		    (i + 1 < argc)) {
			if (!(mode & ESP_NEW))
				errx(1, "invalid option %s for selected mode",
				    argv[i]);
			authp = (u_char *)argv[++i];
			alen = strlen((char *)authp) / 2;
			continue;
		}
		if (!strcmp(argv[i] + 1, "iv") && (i + 1 < argc)) {
			if (mode & (AH_OLD | AH_NEW))
				errx(1, "invalid option %s with auth",
				    argv[i]);
			warnx("warning: option iv has been deprecated");

			/* Horrible hack */
			if (mode & ESP_OLD)
				if (strlen(argv[i + 2]) == 4)
					sa.sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;

			i++;
			continue;
		}
		if ((iscmd(mode, FLUSH) || iscmd(mode, SHOW)) &&
		    smsg.sadb_msg_satype == SADB_SATYPE_UNSPEC) {
			if (!strcmp(argv[i] + 1, "esp"))
				smsg.sadb_msg_satype = SADB_SATYPE_ESP;
			else if (!strcmp(argv[i] + 1, "ah"))
				smsg.sadb_msg_satype = SADB_SATYPE_AH;
			else if (!strcmp(argv[i] + 1, "ip4"))
				smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
			else if (!strcmp(argv[i] + 1, "tcpmd5"))
				smsg.sadb_msg_satype = SADB_X_SATYPE_TCPSIGNATURE;
			else if (!strcmp(argv[i] + 1, "ipcomp"))
				smsg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
			else
				errx(1, "invalid SA type %s", argv[i] + 1);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "spi") && iscmd(mode, FLOW)) {
			warnx("use of flag \"-spi\" is deprecated with "
			    "flow creation or deletion");
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "spi") && spi == SPI_LOCAL_USE &&
		    (i + 1 < argc) && !bypass && !deny) {
			ll = strtoul(argv[i + 1], &ep, 16);
			if ((argv[i + 1] == '\0' || *ep != '\0') ||
			    (errno == ERANGE && ll == ULONG_MAX) ||
			    (ll >= SPI_RESERVED_MIN && ll <= SPI_RESERVED_MAX))
				errx(1, "invalid spi %s", argv[i + 1]);
			spi = ll;
			sa.sadb_sa_spi = htonl(spi);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "spi2") && spi2 == SPI_LOCAL_USE &&
		    iscmd(mode, GRP_SPI) && (i + 1 < argc)) {
			ll = strtoul(argv[i + 1], &ep, 16);
			if ((argv[i + 1] == '\0' || *ep != '\0') ||
			    (errno == ERANGE && ll == ULONG_MAX) ||
			    (ll >= SPI_RESERVED_MIN && ll <= SPI_RESERVED_MAX))
				errx(1, "invalid spi2 %s", argv[i + 1]);
			spi2 = ll;
			sa2.sadb_sa_spi = htonl(spi2);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "cpi") && cpi == SPI_LOCAL_USE &&
		    (i + 1 < argc) && !bypass && !deny) {
			ll = strtoul(argv[i + 1], &ep, 16);
			if ((argv[i + 1] == '\0' || *ep != '\0') ||
			    (errno == ERANGE && ll == ULONG_MAX) ||
			    (ll >= CPI_RESERVED_MIN && ll <= CPI_RESERVED_MAX) ||
			    (ll > USHRT_MAX))
				errx(1, "invalid cpi %s", argv[i + 1]);
			cpi = ll;
			sa.sadb_sa_spi = ntohl(cpi);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "dst2") &&
		    iscmd(mode, GRP_SPI) && (i + 1 < argc)) {
			sad8.sadb_address_exttype = SADB_X_EXT_DST2;
			memset(&hints, 0, sizeof(hints));
			hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
			hints.ai_family = PF_UNSPEC;
			if (getaddrinfo(argv[i + 1], "0", &hints, &res) != 0)
				errx(1, "destination address2 %s is not valid",
				    argv[i + 1]);

			if (res->ai_next)
				errx(1, "destination address2 %s resolves to "
				    "multiple addresses", argv[i + 1]);

			switch (res->ai_family) {
			case AF_INET6:
				if (res->ai_addrlen != sizeof(dst2->sin6))
					errx(1, "destination address2 %s resolves "
					    "to unexpected address", argv[i + 1]);
				memcpy(&dst2->sin6, res->ai_addr,
				    sizeof(dst2->sin6));
				dst2set = 1;
				break;
			case AF_INET:
				if (res->ai_addrlen != sizeof(dst2->sin))
					errx(1, "destination address2 %s resolves "
					    "to unexpected address", argv[i + 1]);
				memcpy(&dst2->sin, res->ai_addr,
				    sizeof(dst2->sin));
				dst2set = 1;
				break;
			default:
				errx(1, "destination address2 %s resolved to "
				    "unsupported address family", argv[i + 1]);
				/* NOTREACHED */
			}

			freeaddrinfo(res);

			if (dst2set == 0)
				errx(1, "destination address2 %s is not valid",
				    argv[i + 1]);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "src") && (i + 1 < argc)) {
			sad1.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
			memset(&hints, 0, sizeof(hints));
			hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
			hints.ai_family = PF_UNSPEC;
			if (getaddrinfo(argv[i + 1], "0", &hints, &res) != 0)
				errx(1, "source address %s is not valid",
				    argv[i + 1]);

			if (res->ai_next)
				errx(1, "source address %s resolves to "
				    "multiple addresses", argv[i + 1]);

			switch (res->ai_family) {
			case AF_INET6:
				if (res->ai_addrlen != sizeof(src->sin6))
					errx(1, "source address %s resolves to "
					    "unexpected address", argv[i + 1]);
				memcpy(&src->sin6, res->ai_addr,
				    sizeof(src->sin6));
				srcset = 1;
				sad1.sadb_address_len = (sizeof(sad1) +
				    ROUNDUP(sizeof(struct sockaddr_in6))) / 8;
				break;
			case AF_INET:
				if (res->ai_addrlen != sizeof(src->sin))
					errx(1, "source address %s resolves to "
					    "unexpected address", argv[i + 1]);
				memcpy(&src->sin, res->ai_addr,
				    sizeof(src->sin));
				srcset = 1;
				sad1.sadb_address_len = (sizeof(sad1) +
				    ROUNDUP(sizeof(struct sockaddr_in))) / 8;
				break;
			default:
				errx(1, "source address %s resolved to "
				    "unsupported address family", argv[i + 1]);
				/* NOTREACHED */
			}

			freeaddrinfo(res);

			if (srcset == 0)
				errx(1, "source address %s is not valid",
				    argv[i + 1]);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "proxy") && (i + 1 < argc) && !deny &&
		    !bypass && !ipsec) {
			sad3.sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;
			memset(&hints, 0, sizeof(hints));
			hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
			hints.ai_family = PF_UNSPEC;
			if (getaddrinfo(argv[i + 1], "0", &hints, &res) != 0)
				errx(1, "proxy address %s is not valid",
				    argv[i + 1]);

			if (res->ai_next)
				errx(1, "proxy address %s resolves to "
				    "multiple addresses", argv[i + 1]);

			switch (res->ai_family) {
			case AF_INET6:
				if (res->ai_addrlen != sizeof(proxy->sin6))
					errx(1, "proxy address %s resolves to "
					    "unexpected address", argv[i + 1]);
				memcpy(&proxy->sin6, res->ai_addr,
				    sizeof(proxy->sin6));
				proxyset = 1;
				sad3.sadb_address_len = (sizeof(sad3) +
				    ROUNDUP(sizeof(struct sockaddr_in6))) / 8;
				break;
			case AF_INET:
				if (res->ai_addrlen != sizeof(proxy->sin))
					errx(1, "proxy address %s resolves to "
					    "unexpected address", argv[i + 1]);
				memcpy(&proxy->sin, res->ai_addr,
				    sizeof(proxy->sin));
				proxyset = 1;
				sad3.sadb_address_len = (sizeof(sad3) +
				    ROUNDUP(sizeof(struct sockaddr_in))) / 8;
				break;
			default:
				errx(1, "proxy address %s resolved to "
				    "unsupported address family", argv[i + 1]);
				/* NOTREACHED */
			}

			freeaddrinfo(res);

			if (proxyset == 0)
				errx(1, "proxy address %s is not valid",
				    argv[i + 1]);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "newpadding")) {
			warnx("warning: option newpadding has been deprecated");
			continue;
		}
		if (!strcmp(argv[i] + 1, "in") && iscmd(mode, FLOW)) {
			sprotocol2.sadb_protocol_direction = IPSP_DIRECTION_IN;
			continue;
		}
		if (!strcmp(argv[i] + 1, "out") && iscmd(mode, FLOW)) {
			sprotocol2.sadb_protocol_direction = IPSP_DIRECTION_OUT;
			continue;
		}
		if (!strcmp(argv[i] + 1, "forcetunnel") && isencauth(mode)) {
			sa.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
			continue;
		}
		if (!strcmp(argv[i] + 1, "udpencap") &&
		    udpencap.sadb_x_udpencap_port == 0 && (i + 1 < argc)) {
			if (!(mode & ESP_NEW))
				errx(1, "option udpencap can "
				    "be used only with new ESP");
			sa.sadb_sa_flags |= SADB_X_SAFLAGS_UDPENCAP;
			udpencap.sadb_x_udpencap_exttype = SADB_X_EXT_UDPENCAP;
			udpencap.sadb_x_udpencap_len = sizeof(udpencap) / 8;
			udpencap.sadb_x_udpencap_port =
			    strtonum(argv[i + 1], 0, USHRT_MAX, &errstr);
			if (errstr)
				errx(1, "invalid port %s", argv[i + 1]);
			udpencap.sadb_x_udpencap_port =
			    htons(udpencap.sadb_x_udpencap_port);
			udpencap.sadb_x_udpencap_reserved = 0;
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "halfiv")) {
			if (!(mode & ESP_OLD))
				errx(1, "option halfiv can be used only "
				    "with old ESP");
			sa.sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;
			continue;
		}
		if (!strcmp(argv[i] + 1, "delete") && iscmd(mode, FLOW)) {
			smsg.sadb_msg_type = SADB_X_DELFLOW;
			continue;
		}
		if (!strcmp(argv[i] + 1, "local") && iscmd(mode, FLOW)) {
			warnx("warning: option local has been deprecated");
			continue;
		}
		if (!strcmp(argv[i] + 1, "tunnel") &&
		    (isencauth(mode) || mode == ENC_IP) && (i + 2 < argc)) {
			i += 2;
			sa.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
			continue;
		}
		if (!strcmp(argv[i] + 1, "srcid") && (iscmd(mode, FLOW) ||
		    isencauth(mode)) && (i + 1 < argc)) {
			int len = ROUNDUP(strlen(argv[i + 1]) + 1);

			if (srcid != NULL)
				errx(1, "srcid specified multiple times");
			if ((srcid = calloc(len, sizeof(char))) == NULL)
				err(1, "calloc");
			strlcpy((char *)srcid, argv[i + 1], len);
			sid1.sadb_ident_len += ROUNDUP(strlen((char *)srcid) + 1) /
			    sizeof(u_int64_t);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "dstid") && (iscmd(mode, FLOW) ||
		    isencauth(mode)) && (i + 1 < argc)) {
			int len = ROUNDUP(strlen(argv[i + 1]) + 1);

			if (dstid != NULL)
				errx(1, "dstid specified multiple times");
			if ((dstid = calloc(len, sizeof(char))) == NULL)
				err(1, "calloc");
			strlcpy((char *)dstid, argv[i + 1], len);
			sid2.sadb_ident_len += ROUNDUP(strlen((char *)dstid) + 1) /
			    sizeof(u_int64_t);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "srcid_type") && (iscmd(mode, FLOW) ||
		    isencauth(mode)) && (i + 1 < argc)) {
			if (sid1.sadb_ident_type != 0)
				errx(1, "srcid_type specified multiple times");
			if (!strcmp(argv[i + 1], "prefix"))
				sid1.sadb_ident_type = SADB_IDENTTYPE_PREFIX;
			else if (!strcmp(argv[i + 1], "fqdn"))
				sid1.sadb_ident_type = SADB_IDENTTYPE_FQDN;
			else if (!strcmp(argv[i + 1], "ufqdn"))
				sid1.sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
			else
				errx(1, "unknown identity type \"%s\"",
				    argv[i + 1]);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "dstid_type") && (iscmd(mode, FLOW) ||
		    isencauth(mode)) && (i + 1 < argc)) {
			if (sid2.sadb_ident_type != 0)
				errx(1, "dstid_type specified multiple times");
			if (!strcmp(argv[i + 1], "prefix"))
				sid2.sadb_ident_type = SADB_IDENTTYPE_PREFIX;
			else if (!strcmp(argv[i + 1], "fqdn"))
				sid2.sadb_ident_type = SADB_IDENTTYPE_FQDN;
			else if (!strcmp(argv[i + 1], "ufqdn"))
				sid2.sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
			else
				errx(1, "unknown identity type \"%s\"",
				    argv[i + 1]);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "addr") && iscmd(mode, FLOW) &&
		    (i + 1 < argc)) {
			int advance;

			sad4.sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
			sad5.sadb_address_exttype = SADB_X_EXT_DST_FLOW;
			sad6.sadb_address_exttype = SADB_X_EXT_SRC_MASK;
			sad7.sadb_address_exttype = SADB_X_EXT_DST_MASK;

			switch (addrparse(argv[i + 1], &osrc->sa, &osmask->sa)) {
			case 0:
				advance = 4;
				if (i + 4 >= argc)
					errx(1, "-addr takes 4 arguments");
				if (addrparse(argv[i + 2], &osmask->sa, NULL) != 0 ||
				    addrparse(argv[i + 3], &odst->sa, NULL) != 0 ||
				    addrparse(argv[i + 4], &odmask->sa, NULL) != 0)
					errx(1, "invalid address on -addr");
				break;
			case 1:
				advance = 2;
				if (i + 2 >= argc)
					errx(1, "-addr takes 2 arguments");
				if (addrparse(argv[i + 2], &odst->sa,
				    &odmask->sa) != 1)
					errx(1, "invalid address on -addr");
				break;
			default:
				errx(1, "invalid address %s on -addr", argv[i + 1]);
				/* NOTREACHED */
			}
			if (osrc->sa.sa_family != odst->sa.sa_family)
				errx(1, "mixed address families specified in addr");
			sad4.sadb_address_len = (sizeof(sad4) +
			    ROUNDUP(osrc->sa.sa_len)) / 8;
			sad5.sadb_address_len = (sizeof(sad5) +
			    ROUNDUP(odst->sa.sa_len)) / 8;
			sad6.sadb_address_len = (sizeof(sad6) +
			    ROUNDUP(osmask->sa.sa_len)) / 8;
			sad7.sadb_address_len = (sizeof(sad7) +
			    ROUNDUP(odmask->sa.sa_len)) / 8;

			i += advance;
			continue;
		}
		if ((!strcmp(argv[i] + 1, "bypass") || !strcmp(argv[i] + 1, "permit"))
		    && iscmd(mode, FLOW) && !deny &&
		    !ipsec && !bypass) {
			/* Setup everything for a bypass flow */
			bypass = 1;
			sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_BYPASS;
			continue;
		}
		if (!strcmp(argv[i] + 1, "deny") && iscmd(mode, FLOW) && !ipsec &&
		    !deny && !bypass) {
			/* Setup everything for a deny flow */
			deny = 1;
			sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_DENY;
			continue;
		}
		if (!strcmp(argv[i] + 1, "use") && iscmd(mode, FLOW) && !deny &&
		    !bypass && !ipsec) {
			ipsec = 1;
			sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_USE;
			continue;
		}
		if (!strcmp(argv[i] + 1, "acquire") && iscmd(mode, FLOW) && !deny &&
		    !bypass && !ipsec) {
			ipsec = 1;
			sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_ACQUIRE;
			continue;
		}
		if (!strcmp(argv[i] + 1, "require") && iscmd(mode, FLOW) && !deny &&
		    !bypass && !ipsec) {
			ipsec = 1;
			sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_REQUIRE;
			continue;
		}
		if (!strcmp(argv[i] + 1, "dontacq") && iscmd(mode, FLOW) && !deny &&
		    !bypass && !ipsec) {
			ipsec = 1;
			sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_DONTACQ;
			continue;
		}
		if (!strcmp(argv[i] + 1, "transport") &&
		    iscmd(mode, FLOW) && (i + 1 < argc)) {
			if (isalpha(argv[i + 1][0])) {
				tp = getprotobyname(argv[i + 1]);
				if (tp == NULL)
					errx(1, "unknown protocol %s",
					    argv[i + 1]);
				tproto = tp->p_proto;
				transportproto = argv[i + 1];
			} else {
				tproto = strtonum(argv[i + 1], 0, INT_MAX,
				    &errstr);
				if (errstr)
					errx(1, "bad protocol %s",
					    argv[i + 1]);
				tp = getprotobynumber(tproto);
				if (tp == NULL)
					transportproto = "UNKNOWN";
				else
					transportproto = tp->p_name;
			}

			sprotocol.sadb_protocol_len = 1;
			sprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
			sprotocol.sadb_protocol_proto = tproto;
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "sport") &&
		    iscmd(mode, FLOW) && (i + 1 < argc)) {
			if (isalpha(argv[i + 1][0])) {
				svp = getservbyname(argv[i + 1], transportproto);
				if (svp == NULL)
					errx(1, "unknown service port %s for "
					    "protocol %s", argv[i + 1],
					    transportproto);
				sport = svp->s_port;
			} else {
				sport = strtonum(argv[i + 1], 0, USHRT_MAX,
				    &errstr);
				if (errstr)
					errx(1, "invalid port %s", argv[i + 1]);
				sport = htons(sport);
			}
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "dport") &&
		    iscmd(mode, FLOW) && (i + 1 < argc)) {
			if (isalpha(argv[i + 1][0])) {
				svp = getservbyname(argv[i + 1], transportproto);
				if (svp == NULL)
					errx(1, "unknown service port %s for "
					    "protocol %s", argv[i + 1],
					    transportproto);
				dport = svp->s_port;
			} else {
				dport = strtonum(argv[i + 1], 0, USHRT_MAX,
				    &errstr);
				if (errstr)
					errx(1, "invalid port %s", argv[i + 1]);
				dport = htons(dport);
			}
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "dst") && (i + 1 < argc) && !bypass && !deny) {
			sad2.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
			memset(&hints, 0, sizeof(hints));
			hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
			hints.ai_family = PF_UNSPEC;
			if (getaddrinfo(argv[i + 1], "0", &hints, &res) != 0)
				errx(1, "destination address %s is not valid",
				    argv[i + 1]);

			if (res->ai_next)
				errx(1, "destination address %s resolves to "
				    "multiple addresses", argv[i + 1]);

			switch (res->ai_family) {
			case AF_INET6:
				if (res->ai_addrlen != sizeof(dst->sin6))
					errx(1, "destination address %s resolves to "
					    "unexpected address", argv[i + 1]);
				memcpy(&dst->sin6, res->ai_addr,
				    sizeof(dst->sin6));
				dstset = 1;
				sad2.sadb_address_len = (sizeof(sad2) +
				    ROUNDUP(sizeof(struct sockaddr_in6))) / 8;
				break;
			case AF_INET:
				if (res->ai_addrlen != sizeof(dst->sin))
					errx(1, "destination address %s resolves to "
					    "unexpected address", argv[i + 1]);
				memcpy(&dst->sin, res->ai_addr,
				    sizeof(dst->sin));
				dstset = 1;
				sad2.sadb_address_len = (sizeof(sad2) +
				    ROUNDUP(sizeof(struct sockaddr_in))) / 8;
				break;
			default:
				errx(1, "destination address %s resolved to "
				    "unsupported address family", argv[i + 1]);
				/* NOTREACHED */
			}

			freeaddrinfo(res);

			if (dstset == 0)
				errx(1, "destination address %s is not valid",
				    argv[i + 1]);
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "proto2") &&
		    iscmd(mode, GRP_SPI) && (i + 1 < argc)) {
			if (isalpha(argv[i + 1][0])) {
				if (!strcasecmp(argv[i + 1], "esp")) {
					sprotocol.sadb_protocol_proto = sproto2 =
					    SADB_SATYPE_ESP;
					proto2 = IPPROTO_ESP;
				} else if (!strcasecmp(argv[i + 1], "ah")) {
					sprotocol.sadb_protocol_proto = sproto2 =
					    SADB_SATYPE_AH;
					proto2 = IPPROTO_AH;
				} else if (!strcasecmp(argv[i + 1], "ip4")) {
					sprotocol.sadb_protocol_proto = sproto2 =
					    SADB_X_SATYPE_IPIP;
					proto2 = IPPROTO_IPIP;
				} else if (!strcasecmp(argv[i + 1], "ipcomp")) {
					sprotocol.sadb_protocol_proto = sproto2 =
					    SADB_X_SATYPE_IPCOMP;
				} else
					errx(1, "unknown security protocol2 "
					    "type %s", argv[i + 1]);
			} else {
				proto2 = strtonum(argv[i + 1], 0, INT_MAX,
				    &errstr);
				if (errstr || (proto2 != IPPROTO_ESP &&
				    proto2 != IPPROTO_AH &&
				    proto2 != IPPROTO_IPIP &&
				    proto2 != IPPROTO_IPCOMP))
					errx(1, "unknown security protocol2 %s",
					    argv[i + 1]);
				if (proto2 == IPPROTO_ESP)
					sprotocol.sadb_protocol_proto = sproto2 =
					    SADB_SATYPE_ESP;
				else if (proto2 == IPPROTO_AH)
					sprotocol.sadb_protocol_proto = sproto2 =
					    SADB_SATYPE_AH;
				else if (proto2 == IPPROTO_IPIP)
					sprotocol.sadb_protocol_proto = sproto2 =
					    SADB_X_SATYPE_IPIP;
				else if (proto2 == IPPROTO_IPCOMP)
					sprotocol.sadb_protocol_proto = sproto2 =
					    SADB_X_SATYPE_IPCOMP;
			}
			i++;
			continue;
		}
		if (!strcmp(argv[i] + 1, "proto") && (i + 1 < argc) &&
		    ((iscmd(mode, FLOW) && !bypass && !deny) || iscmd(mode, DEL_SPI) ||
		    iscmd(mode, GRP_SPI))) {
			if (isalpha(argv[i + 1][0])) {
				if (!strcasecmp(argv[i + 1], "esp")) {
					smsg.sadb_msg_satype = SADB_SATYPE_ESP;
					proto = IPPROTO_ESP;
				} else if (!strcasecmp(argv[i + 1], "ah")) {
					smsg.sadb_msg_satype = SADB_SATYPE_AH;
					proto = IPPROTO_AH;
				} else if (!strcasecmp(argv[i + 1], "ip4")) {
					smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
					proto = IPPROTO_IPIP;
				} else if (!strcasecmp(argv[i + 1], "ipcomp")) {
					smsg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
					proto = IPPROTO_IPCOMP;
				} else if (!strcasecmp(argv[i + 1], "tcpmd5")) {
					smsg.sadb_msg_satype = SADB_X_SATYPE_TCPSIGNATURE;
					proto = IPPROTO_TCP;
				} else
					errx(1, "unknown security protocol type %s",
					    argv[i + 1]);
			} else {
				proto = strtonum(argv[i + 1], 0, INT_MAX,
				    &errstr);
				if (errstr || (proto != IPPROTO_ESP &&
				    proto != IPPROTO_AH &&
				    proto != IPPROTO_IPIP &&
				    proto != IPPROTO_IPCOMP)) {
					errx(1, "unknown security protocol %s",
					    argv[i + 1]);
				}
				if (proto == IPPROTO_ESP)
					smsg.sadb_msg_satype = SADB_SATYPE_ESP;
				else if (proto == IPPROTO_AH)
					smsg.sadb_msg_satype = SADB_SATYPE_AH;
				else if (proto == IPPROTO_IPIP)
					smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
				else if (proto == IPPROTO_IPCOMP)
					smsg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
			}
			i++;
			continue;
		}
		errx(1, "unknown option: %s", argv[i]);
	}

	if (iscmd(mode, SHOW)) {
		ipsecadm_show(smsg.sadb_msg_satype);
		exit(0);
	} else if (iscmd(mode, MONITOR)) {
		ipsecadm_monitor();
		exit(0);
	}

	/* Sanity checks */
	if ((mode & (ESP_NEW | ESP_OLD)) && enc == 0 && auth == 0)
		errx(1, "no encryption or authentication algorithm specified");
	if (iscmd(mode, GRP_SPI) && spi2 == SPI_LOCAL_USE)
		errx(1, "no SPI2 specified");
	if ((mode & (AH_NEW | AH_OLD)) && auth == 0)
		errx(1, "no authentication algorithm specified");
	if (iscmd(mode, IPCOMP) && comp == 0)
		errx(1, "no compression algorithm specified");
	if ((srcid != NULL) && (sid1.sadb_ident_type == 0))
		errx(1, "srcid_type not specified");
	if ((dstid != NULL) && (sid2.sadb_ident_type == 0))
		errx(1, "dstid_type not specified");
	if ((srcid == NULL) && (sid1.sadb_ident_type != 0))
		errx(1, "srcid_type specified, but no srcid given");
	if ((dstid == NULL) && (sid2.sadb_ident_type != 0))
		errx(1, "dstid_type specified, but no dstid given");
	if (((mode & (ESP_NEW | ESP_OLD)) && enc && keyp == NULL) ||
	    ((mode & (AH_NEW | AH_OLD | TCPMD5)) && authp == NULL))
		errx(1, "no key material specified");
	if ((mode & ESP_NEW) && auth && authp == NULL)
		errx(1, "no auth key material specified");
	if (spi == SPI_LOCAL_USE && !iscmd(mode, FLUSH) && !iscmd(mode, FLOW)
	    && !iscmd(mode, IPCOMP))
		errx(1, "no SPI specified");
	if (iscmd(mode, IPCOMP) && cpi == SPI_LOCAL_USE)
		errx(1, "no CPI specified");
	if ((isencauth(mode) || iscmd(mode, ENC_IP)) && !srcset)
		errx(1, "no source address specified");
	if (!dstset && !iscmd(mode, FLUSH) && !iscmd(mode, FLOW))
		errx(1, "no destination address for the SA specified");
	if (iscmd(mode, FLOW) && (sprotocol.sadb_protocol_proto == 0) &&
	    (odst->sin.sin_port || osrc->sin.sin_port))
		errx(1, "no transport protocol supplied with"
		    " source/destination ports");
	if (iscmd(mode, GRP_SPI) && !dst2set)
		errx(1, "no destination address2 specified");
	if ((klen > 2 * 8100) || (alen > 2 * 8100))
		errx(1, "key too long");
	if (iscmd(mode, FLOW) && proto == IPPROTO_IPCOMP)
		sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_USE;
	if (keyp != NULL)
		for (i = 0; i < klen; i++)
			realkey[i] = x2i(keyp + 2 * i);
	if (authp != NULL)
		for (i = 0; i < alen; i++)
			realakey[i] = x2i(authp + 2 * i);
	/* message header */
	iov[cnt].iov_base = &smsg;
	iov[cnt++].iov_len = sizeof(smsg);

	if (isencauth(mode) || iscmd(mode, TCPMD5)) {	/* XXX */
		/* SA header */
		iov[cnt].iov_base = &sa;
		iov[cnt++].iov_len = sizeof(sa);
		smsg.sadb_msg_len += sa.sadb_sa_len;

		/* Destination address header */
		iov[cnt].iov_base = &sad2;
		iov[cnt++].iov_len = sizeof(sad2);
		/* Destination address */
		iov[cnt].iov_base = dst;
		iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
		smsg.sadb_msg_len += sad2.sadb_address_len;

		if (srcid) {
			iov[cnt].iov_base = &sid1;
			iov[cnt++].iov_len = sizeof(sid1);
			/* SRC identity */
			iov[cnt].iov_base = srcid;
			iov[cnt++].iov_len = ROUNDUP(strlen((char *)srcid) + 1);
			smsg.sadb_msg_len += sid1.sadb_ident_len;
		}
		if (dstid) {
			iov[cnt].iov_base = &sid2;
			iov[cnt++].iov_len = sizeof(sid2);
			/* DST identity */
			iov[cnt].iov_base = dstid;
			iov[cnt++].iov_len = ROUNDUP(strlen((char *)dstid) + 1);
			smsg.sadb_msg_len += sid2.sadb_ident_len;
		}
		if (sad1.sadb_address_exttype) {
			/* Source address header */
			iov[cnt].iov_base = &sad1;
			iov[cnt++].iov_len = sizeof(sad1);
			/* Source address */
			iov[cnt].iov_base = src;
			iov[cnt++].iov_len = ROUNDUP(src->sa.sa_len);
			smsg.sadb_msg_len += sad1.sadb_address_len;
		}
		if (proxy->sa.sa_len) {
			/* Proxy address header */
			iov[cnt].iov_base = &sad3;
			iov[cnt++].iov_len = sizeof(sad3);
			/* Proxy address */
			iov[cnt].iov_base = proxy;
			iov[cnt++].iov_len = ROUNDUP(proxy->sa.sa_len);
			smsg.sadb_msg_len += sad3.sadb_address_len;
		}
		if (keyp) {
			/* Key header */
			iov[cnt].iov_base = &skey1;
			iov[cnt++].iov_len = sizeof(skey1);
			/* Key */
			iov[cnt].iov_base = realkey;
			iov[cnt++].iov_len = ((klen + 7) / 8) * 8;
			skey1.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
			skey1.sadb_key_len = (sizeof(skey1) + ((klen + 7) / 8) * 8) / 8;
			skey1.sadb_key_bits = 8 * klen;
			smsg.sadb_msg_len += skey1.sadb_key_len;
		}
		if (authp) {
			/* Auth key header */
			iov[cnt].iov_base = &skey2;
			iov[cnt++].iov_len = sizeof(skey2);
			/* Auth key */
			iov[cnt].iov_base = realakey;
			iov[cnt++].iov_len = ((alen + 7) / 8) * 8;
			skey2.sadb_key_exttype = SADB_EXT_KEY_AUTH;
			skey2.sadb_key_len = (sizeof(skey2) + ((alen + 7) / 8) * 8) / 8;
			skey2.sadb_key_bits = 8 * alen;
			smsg.sadb_msg_len += skey2.sadb_key_len;
		}
		if (sa.sadb_sa_flags & SADB_X_SAFLAGS_UDPENCAP) {
			iov[cnt].iov_base = &udpencap;
			iov[cnt++].iov_len = sizeof(udpencap);
			smsg.sadb_msg_len += udpencap.sadb_x_udpencap_len;
		}
	} else {
		switch (mode & CMD_MASK) {
		case GRP_SPI:
			/* SA header */
			iov[cnt].iov_base = &sa;
			iov[cnt++].iov_len = sizeof(sa);
			smsg.sadb_msg_len += sa.sadb_sa_len;

			/* Destination address header */
			iov[cnt].iov_base = &sad2;
			iov[cnt++].iov_len = sizeof(sad2);
			/* Destination address */
			iov[cnt].iov_base = dst;
			iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
			smsg.sadb_msg_len += sad2.sadb_address_len;

			/* SA header */
			iov[cnt].iov_base = &sa2;
			iov[cnt++].iov_len = sizeof(sa2);
			smsg.sadb_msg_len += sa2.sadb_sa_len;

			/* Destination2 address header */
			iov[cnt].iov_base = &sad8;
			iov[cnt++].iov_len = sizeof(sad8);
			/* Destination2 address */
			iov[cnt].iov_base = dst2;
			iov[cnt++].iov_len = ROUNDUP(dst2->sa.sa_len);
			smsg.sadb_msg_len += sad8.sadb_address_len;

			sprotocol.sadb_protocol_proto = sproto2;

			/* Protocol2 */
			iov[cnt].iov_base = &sprotocol;
			iov[cnt++].iov_len = sizeof(sprotocol);
			smsg.sadb_msg_len += sprotocol.sadb_protocol_len;
			break;

		case DEL_SPI:
			/* SA header */
			iov[cnt].iov_base = &sa;
			iov[cnt++].iov_len = sizeof(sa);
			smsg.sadb_msg_len += sa.sadb_sa_len;

			/* Destination address header */
			iov[cnt].iov_base = &sad2;
			iov[cnt++].iov_len = sizeof(sad2);
			/* Destination address */
			iov[cnt].iov_base = dst;
			iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
			smsg.sadb_msg_len += sad2.sadb_address_len;
			break;

		case ENC_IP:
			/* SA header */
			iov[cnt].iov_base = &sa;
			iov[cnt++].iov_len = sizeof(sa);
			smsg.sadb_msg_len += sa.sadb_sa_len;

			/* Destination address header */
			iov[cnt].iov_base = &sad2;
			iov[cnt++].iov_len = sizeof(sad2);
			/* Destination address */
			iov[cnt].iov_base = dst;
			iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
			smsg.sadb_msg_len += sad2.sadb_address_len;

			if (sad1.sadb_address_exttype) {
				/* Source address header */
				iov[cnt].iov_base = &sad1;
				iov[cnt++].iov_len = sizeof(sad1);
				/* Source address */
				iov[cnt].iov_base = src;
				iov[cnt++].iov_len = ROUNDUP(src->sa.sa_len);
				smsg.sadb_msg_len += sad1.sadb_address_len;
			}
			break;

		case IPCOMP:
			/* SA header */
			iov[cnt].iov_base = &sa;
			iov[cnt++].iov_len = sizeof(sa);
			smsg.sadb_msg_len += sa.sadb_sa_len;

			/* Destination address header */
			iov[cnt].iov_base = &sad2;
			iov[cnt++].iov_len = sizeof(sad2);
			/* Destination address */
			iov[cnt].iov_base = dst;
			iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
			smsg.sadb_msg_len += sad2.sadb_address_len;

			if (sad1.sadb_address_exttype) {
				/* Source address header */
				iov[cnt].iov_base = &sad1;
				iov[cnt++].iov_len = sizeof(sad1);
				/* Source address */
				iov[cnt].iov_base = src;
				iov[cnt++].iov_len = ROUNDUP(src->sa.sa_len);
				smsg.sadb_msg_len += sad1.sadb_address_len;
			}
			break;

		case FLOW:
			if ((smsg.sadb_msg_type != SADB_X_DELFLOW) &&
			    (sad2.sadb_address_exttype)) {
				/* Destination address header */
				iov[cnt].iov_base = &sad2;
				iov[cnt++].iov_len = sizeof(sad2);
				/* Destination address */
				iov[cnt].iov_base = dst;
				iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
				smsg.sadb_msg_len += sad2.sadb_address_len;
			}
			if ((sad1.sadb_address_exttype) &&
			    (smsg.sadb_msg_type != SADB_X_DELFLOW)) {
				/* Source address header */
				iov[cnt].iov_base = &sad1;
				iov[cnt++].iov_len = sizeof(sad1);
				/* Source address */
				iov[cnt].iov_base = src;
				iov[cnt++].iov_len = ROUNDUP(src->sa.sa_len);
				smsg.sadb_msg_len += sad1.sadb_address_len;
			}
			if (sprotocol.sadb_protocol_len) {
				/* Transport protocol */
				iov[cnt].iov_base = &sprotocol;
				iov[cnt++].iov_len = sizeof(sprotocol);
				smsg.sadb_msg_len += sprotocol.sadb_protocol_len;
			}
			/* Flow type */
			iov[cnt].iov_base = &sprotocol2;
			iov[cnt++].iov_len = sizeof(sprotocol2);
			smsg.sadb_msg_len += sprotocol2.sadb_protocol_len;

			/* Flow source address header */
			if ((sport != -1) && (sport != 0)) {
				if (osrc->sa.sa_family == AF_INET) {
					osrc->sin.sin_port = sport;
					osmask->sin.sin_port = 0xffff;
				} else if (osrc->sa.sa_family == AF_INET6) {
					osrc->sin6.sin6_port = sport;
					osmask->sin6.sin6_port = 0xffff;
				}
			}
			iov[cnt].iov_base = &sad4;
			iov[cnt++].iov_len = sizeof(sad4);
			/* Flow source address */
			iov[cnt].iov_base = osrc;
			iov[cnt++].iov_len = ROUNDUP(osrc->sa.sa_len);
			smsg.sadb_msg_len += sad4.sadb_address_len;

			/* Flow destination address header */
			iov[cnt].iov_base = &sad5;
			iov[cnt++].iov_len = sizeof(sad5);
			/* Flow destination address */
			if ((dport != -1) && (dport != 0)) {
				if (odst->sa.sa_family == AF_INET) {
					odst->sin.sin_port = dport;
					odmask->sin.sin_port = 0xffff;
				} else if (odst->sa.sa_family == AF_INET6) {
					odst->sin6.sin6_port = dport;
					odmask->sin6.sin6_port = 0xffff;
				}
			}
			iov[cnt].iov_base = odst;
			iov[cnt++].iov_len = ROUNDUP(odst->sa.sa_len);
			smsg.sadb_msg_len += sad5.sadb_address_len;

			/* Flow source address mask header */
			iov[cnt].iov_base = &sad6;
			iov[cnt++].iov_len = sizeof(sad6);
			/* Flow source address mask */
			iov[cnt].iov_base = osmask;
			iov[cnt++].iov_len = ROUNDUP(osmask->sa.sa_len);
			smsg.sadb_msg_len += sad6.sadb_address_len;

			/* Flow destination address mask header */
			iov[cnt].iov_base = &sad7;
			iov[cnt++].iov_len = sizeof(sad7);
			/* Flow destination address mask */
			iov[cnt].iov_base = odmask;
			iov[cnt++].iov_len = ROUNDUP(odmask->sa.sa_len);
			smsg.sadb_msg_len += sad7.sadb_address_len;

			if (srcid &&
			    (smsg.sadb_msg_type != SADB_X_DELFLOW)) {
				iov[cnt].iov_base = &sid1;
				iov[cnt++].iov_len = sizeof(sid1);
				/* SRC identity */
				iov[cnt].iov_base = srcid;
				iov[cnt++].iov_len = ROUNDUP(strlen((char *)srcid) + 1);
				smsg.sadb_msg_len += sid1.sadb_ident_len;
			}
			if (dstid &&
			    (smsg.sadb_msg_type != SADB_X_DELFLOW)) {
				iov[cnt].iov_base = &sid2;
				iov[cnt++].iov_len = sizeof(sid2);
				/* DST identity */
				iov[cnt].iov_base = dstid;
				iov[cnt++].iov_len = ROUNDUP(strlen((char *)dstid) + 1);
				smsg.sadb_msg_len += sid2.sadb_ident_len;
			}
			break;

		case FLUSH:
			/* No more work needed */
			break;
		}
	}

	xf_set(iov, cnt, smsg.sadb_msg_len * 8);
	exit(0);
}
@


1.86
log
@don't include ccitt headers (were not used anyway)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.85 2005/05/25 05:51:13 markus Exp $ */
@


1.85
log
@aesctr and null support
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.84 2004/12/28 15:19:23 deraadt Exp $ */
a50 1
#include <netccitt/x25.h>
@


1.84
log
@handle strtoul correctly on 64-bit machines; hshoexer ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.83 2004/11/25 21:32:52 markus Exp $ */
d101 1
d105 1
@


1.83
log
@off by one in err()
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.82 2004/09/27 03:20:21 jaredy Exp $ */
d349 1
d649 1
a649 1
			spi = strtoul(argv[i + 1], &ep, 16);
d651 2
a652 2
			    (errno == ERANGE && spi == ULONG_MAX) ||
			    (spi >= SPI_RESERVED_MIN && spi <= SPI_RESERVED_MAX))
d654 1
d661 1
a661 1
			spi2 = strtoul(argv[i + 1], &ep, 16);
d663 2
a664 2
			    (errno == ERANGE && spi == ULONG_MAX) ||
			    (spi2 >= SPI_RESERVED_MIN && spi2 <= SPI_RESERVED_MAX))
d666 1
d673 1
a673 1
			cpi = strtoul(argv[i + 1], &ep, 16);
d675 3
a677 3
			    (errno == ERANGE && spi == ULONG_MAX) ||
			    (cpi >= CPI_RESERVED_MIN && cpi <= CPI_RESERVED_MAX) ||
			    (cpi > USHRT_MAX))
d679 1
@


1.82
log
@make usage() fatal, use err/warn, and minor knf
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.81 2004/09/25 18:29:46 jaredy Exp $ */
d636 1
a636 1
				errx(1, "invalid SA type %s", argv[i + 1]);
@


1.81
log
@tidy usage; ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.80 2004/06/25 02:35:36 henning Exp $ */
d121 2
a122 2
extern void ipsecadm_monitor(void);
extern void ipsecadm_show(u_int8_t);
d127 1
a127 1
void	usage(void);
d220 8
a227 15
	if (sd < 0) {
		perror("socket");
		if (errno == EPROTONOSUPPORT)
			fprintf(stderr,
				"Make sure your kernel is compiled with option KEY\n");
		exit(1);
	}
	if (writev(sd, iov, cnt) != len) {
		perror("write");
		exit(1);
	}
	if (read(sd, &sm, sizeof(sm)) != sizeof(sm)) {
		perror("read");
		exit(1);
	}
d231 1
a231 2
		perror("pfkey");
		exit(1);
d245 2
a246 4
	if (!isxdigit(s[0]) || !isxdigit(s[1])) {
		fprintf(stderr, "Keys should be specified in hex digits.\n");
		exit(1);
	}
d264 2
a265 3
		fprintf(stderr,
		    "Warning: use of %s is strongly discouraged due to"
		    " cryptographic weaknesses\n", option);
d314 1
d351 1
a351 1
	if (argc < 2) {
a352 2
		exit(1);
	}
d434 2
a435 5
		} else {
			fprintf(stderr, "%s: unexpected identifier %s\n", argv[0],
			    argv[2]);
			exit(1);
		}
d450 2
a451 5
		} else {
			fprintf(stderr, "%s: unexpected identifier %s\n", argv[0],
			    argv[2]);
			exit(1);
		}
d498 1
a498 2
		fprintf(stderr, "%s: unknown command: %s\n", argv[0],
		    argv[1]);
a499 1
		exit(1);
d503 2
a504 5
		if (argv[i][0] != '-') {
			fprintf(stderr, "%s: expected option, got %s\n",
			    argv[0], argv[i]);
			exit(1);
		}
d506 3
a508 5
			if ((enc = isvalid(argv[i + 1], XF_ENC, mode)) == 0) {
				fprintf(stderr, "%s: invalid encryption algorithm %s\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d515 2
a516 5
			if ((auth = isvalid(argv[i + 1], XF_AUTH, mode)) == 0) {
				fprintf(stderr, "%s: invalid auth algorithm %s\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d523 2
a524 5
			if ((comp = isvalid(argv[i + 1], XF_COMP, mode)) == 0) {
				fprintf(stderr, "%s: invalid comp algorithm %s\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d550 13
a562 26
			if (stat(argv[++i], &sb) < 0) {
				perror("stat()");
				exit(1);
			}
			if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0)) {
				fprintf(stderr,
				    "%s: file %s is too %s "
				    "(must be between 1 and %d bytes).\nb",
				    argv[0], argv[i],
				    sb.st_size ? "large" : "small", KEYSIZE_LIMIT);
				exit(1);
			}
			pptr = malloc((int)sb.st_size);
			if (pptr == NULL) {
				perror("malloc()");
				exit(1);
			}
			fd = open(argv[i], O_RDONLY);
			if (fd < 0) {
				perror("open()");
				exit(1);
			}
			if (read(fd, pptr, (size_t)sb.st_size) < sb.st_size) {
				perror("read()");
				exit(1);
			}
d579 16
a594 32
			if (!(mode & ESP_NEW)) {
				fprintf(stderr,
				    "%s: invalid option %s for selected mode\n",
				    argv[0], argv[i]);
				exit(1);
			}
			if (stat(argv[++i], &sb) < 0) {
				perror("stat()");
				exit(1);
			}
			if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0)) {
				fprintf(stderr,
				    "%s: file %s is too %s "
				    "(must be between 1 and %d bytes).\n",
				    argv[0], argv[i],
				    sb.st_size ? "large" : "small", KEYSIZE_LIMIT);
				exit(1);
			}
			authp = malloc((int)sb.st_size);
			if (authp == NULL) {
				perror("malloc()");
				exit(1);
			}
			fd = open(argv[i], O_RDONLY);
			if (fd < 0) {
				perror("open()");
				exit(1);
			}
			if (read(fd, authp, (int)sb.st_size) < sb.st_size) {
				perror("read()");
				exit(1);
			}
d602 3
a604 6
			if (!(mode & ESP_NEW)) {
				fprintf(stderr,
				    "%s: invalid option %s for selected mode\n",
				    argv[0], argv[i]);
				exit(1);
			}
d610 4
a613 7
			if (mode & (AH_OLD | AH_NEW)) {
				fprintf(stderr, "%s: invalid option %s with auth\n",
				    argv[0], argv[i]);
				exit(1);
			}
			fprintf(stderr,
			    "%s: Warning: option iv has been deprecated\n", argv[0]);
d635 2
a636 5
			else {
				fprintf(stderr, "%s: invalid SA type %s\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d641 2
a642 2
			fprintf(stderr, "%s: use of flag \"-spi\" is deprecated with "
			    "flow creation or deletion\n", argv[0]);
d686 3
a688 6
			if (getaddrinfo(argv[i + 1], "0", &hints, &res) != 0) {
				fprintf(stderr,
				    "%s: destination address2 %s is not valid\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d690 3
a692 6
			if (res->ai_next) {
				fprintf(stderr,
				    "%s: destination address2 %s resolves to multiple addresses\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d696 3
a698 6
				if (res->ai_addrlen != sizeof(dst2->sin6)) {
					fprintf(stderr,
					    "%s: destination address2 %s resolves to unexpected address\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d704 3
a706 6
				if (res->ai_addrlen != sizeof(dst2->sin)) {
					fprintf(stderr,
					    "%s: destination address2 %s resolves to unexpected address\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d712 3
a714 4
				fprintf(stderr,
				    "%s: destination address2 %s resolved to unsupported address family\n",
				    argv[0], argv[i + 1]);
				exit(1);
d719 3
a721 6
			if (dst2set == 0) {
				fprintf(stderr,
				    "%s: destination address2 %s is not valid\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d730 3
a732 6
			if (getaddrinfo(argv[i + 1], "0", &hints, &res) != 0) {
				fprintf(stderr,
				    "%s: source address %s is not valid\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d734 3
a736 6
			if (res->ai_next) {
				fprintf(stderr,
				    "%s: source address %s resolves to multiple addresses\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d740 3
a742 6
				if (res->ai_addrlen != sizeof(src->sin6)) {
					fprintf(stderr,
					    "%s: source address %s resolves to unexpected address\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d750 3
a752 6
				if (res->ai_addrlen != sizeof(src->sin)) {
					fprintf(stderr,
					    "%s: source address %s resolves to unexpected address\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d760 3
a762 4
				fprintf(stderr,
				    "%s: source address %s resolved to unsupported address family\n",
				    argv[0], argv[i + 1]);
				exit(1);
d767 3
a769 6
			if (srcset == 0) {
				fprintf(stderr,
				    "%s: source address %s is not valid\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d779 3
a781 6
			if (getaddrinfo(argv[i + 1], "0", &hints, &res) != 0) {
				fprintf(stderr,
				    "%s: proxy address %s is not valid\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d783 3
a785 6
			if (res->ai_next) {
				fprintf(stderr,
				    "%s: source address %s resolves to multiple addresses\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d789 3
a791 6
				if (res->ai_addrlen != sizeof(proxy->sin6)) {
					fprintf(stderr,
					    "%s: source address %s resolves to unexpected address\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d799 3
a801 6
				if (res->ai_addrlen != sizeof(proxy->sin)) {
					fprintf(stderr,
					    "%s: source address %s resolves to unexpected address\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d809 3
a811 4
				fprintf(stderr,
				    "%s: proxy address %s resolved to unsupported address family\n",
				    argv[0], argv[i + 1]);
				exit(1);
d816 3
a818 6
			if (proxyset == 0) {
				fprintf(stderr,
				    "%s: proxy address %s is not valid\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d823 1
a823 3
			fprintf(stderr,
			    "%s: Warning: option newpadding has been deprecated\n",
			    argv[0]);
d840 3
a842 5
			if (!(mode & ESP_NEW)) {
				fprintf(stderr, "%s: option udpencap can "
				    "be used only with new ESP\n", argv[0]);
				exit(1);
			}
d857 3
a859 6
			if (!(mode & ESP_OLD)) {
				fprintf(stderr,
				    "%s: option halfiv can be used only with old ESP\n",
				    argv[0]);
				exit(1);
			}
d868 1
a868 3
			fprintf(stderr,
			    "%s: Warning: option local has been deprecated\n",
			    argv[0]);
d881 4
a884 10
			if (srcid != NULL) {
				fprintf(stderr, "%s: srcid specified multiple times\n",
				    argv[0]);
				exit(1);
			}
			srcid = calloc(len, sizeof(char));
			if (srcid == NULL) {
				fprintf(stderr, "%s: malloc failed\n", argv[0]);
				exit(1);
			}
d895 4
a898 10
			if (dstid != NULL) {
				fprintf(stderr, "%s: dstid specified multiple times\n",
				    argv[0]);
				exit(1);
			}
			dstid = calloc(len, sizeof(char));
			if (dstid == NULL) {
				fprintf(stderr, "%s: malloc failed\n", argv[0]);
				exit(1);
			}
d907 2
a908 6
			if (sid1.sadb_ident_type != 0) {
				fprintf(stderr,
				    "%s: srcid_type specified multiple times\n",
				    argv[0]);
				exit(1);
			}
d915 3
a917 5
			else {
				fprintf(stderr, "%s: unknown identity type \"%s\"\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d923 2
a924 6
			if (sid2.sadb_ident_type != 0) {
				fprintf(stderr,
				    "%s: dstid_type specified multiple times\n",
				    argv[0]);
				exit(1);
			}
d931 3
a933 5
			else {
				fprintf(stderr, "%s: unknown identity type \"%s\"\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d950 1
a950 1
					goto argfail;
d953 2
a954 6
				    addrparse(argv[i + 4], &odmask->sa, NULL) != 0) {
					fprintf(stderr,
					    "%s: Invalid address on -addr\n",
					    argv[0]);
					exit(1);
				}
d959 1
a959 1
					goto argfail;
d961 2
a962 5
				    &odmask->sa) != 1) {
					fprintf(stderr,
					    "%s: Invalid address on -addr\n", argv[0]);
					exit(1);
				}
d965 2
a966 10
				fprintf(stderr,
				    "%s: Invalid address %s on -addr\n", argv[0],
				    argv[i + 1]);
				goto argfail;
			}
			if (osrc->sa.sa_family != odst->sa.sa_family) {
				fprintf(stderr,
				    "%s: Mixed address families specified in addr\n",
				    argv[0]);
				exit(1);
d968 2
d1025 3
a1027 6
				if (tp == NULL) {
					fprintf(stderr,
					    "%s: unknown protocol %s\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d1031 1
a1031 1
				tproto = strtonum(argv[i + 1], 0, INT_MAX, 
d1053 4
a1056 6
				if (svp == NULL) {
					fprintf(stderr,
					    "%s: unknown service port %s for protocol %s\n",
					    argv[0], argv[i + 1], transportproto);
					exit(1);
				}
d1072 4
a1075 6
				if (svp == NULL) {
					fprintf(stderr,
					    "%s: unknown service port %s for protocol %s\n",
					    argv[0], argv[i + 1], transportproto);
					exit(1);
				}
d1092 3
a1094 6
			if (getaddrinfo(argv[i + 1], "0", &hints, &res) != 0) {
				fprintf(stderr,
				    "%s: destination address %s is not valid\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d1096 3
a1098 6
			if (res->ai_next) {
				fprintf(stderr,
				    "%s: destination address %s resolves to multiple addresses\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d1102 3
a1104 6
				if (res->ai_addrlen != sizeof(dst->sin6)) {
					fprintf(stderr,
					    "%s: destination address %s resolves to unexpected address\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d1112 3
a1114 6
				if (res->ai_addrlen != sizeof(dst->sin)) {
					fprintf(stderr,
					    "%s: destination address %s resolves to unexpected address\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d1122 3
a1124 4
				fprintf(stderr,
				    "%s: destination address %s resolved to unsupported address family\n",
				    argv[0], argv[i + 1]);
				exit(1);
d1129 3
a1131 6
			if (dstset == 0) {
				fprintf(stderr,
				    "%s: destination address %s is not valid\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d1153 3
a1155 6
				} else {
					fprintf(stderr,
					    "%s: unknown security protocol2 type %s\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d1159 1
a1159 1
				if (errstr || (proto2 != IPPROTO_ESP && 
d1161 2
a1162 2
				    proto2 != IPPROTO_IPIP && 
				    proto2 != IPPROTO_IPCOMP)) {
a1164 1
				}
d1200 3
a1202 6
				} else {
					fprintf(stderr,
					    "%s: unknown security protocol type %s\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d1206 1
a1206 1
				if (errstr || (proto != IPPROTO_ESP && 
d1208 1
a1208 1
				    proto != IPPROTO_IPIP && 
d1225 1
a1225 5
		/* No match */
argfail:
		fprintf(stderr, "%s: Unknown, invalid, or duplicated option: %s\n",
		    argv[0], argv[i]);
		exit(1);
d1237 16
a1252 37
	if ((mode & (ESP_NEW | ESP_OLD)) && enc == 0 && auth == 0) {
		fprintf(stderr, "%s: no encryption or authentication algorithm "
		    "specified\n", argv[0]);
		exit(1);
	}
	if (iscmd(mode, GRP_SPI) && spi2 == SPI_LOCAL_USE) {
		fprintf(stderr, "%s: no SPI2 specified\n", argv[0]);
		exit(1);
	}
	if ((mode & (AH_NEW | AH_OLD)) && auth == 0) {
		fprintf(stderr, "%s: no authentication algorithm specified\n",
		    argv[0]);
		exit(1);
	}
	if (iscmd(mode, IPCOMP) && comp == 0) {
		fprintf(stderr, "%s: no compression algorithm specified\n",
		    argv[0]);
		exit(1);
	}
	if ((srcid != NULL) && (sid1.sadb_ident_type == 0)) {
		fprintf(stderr, "%s: srcid_type not specified\n", argv[0]);
		exit(1);
	}
	if ((dstid != NULL) && (sid2.sadb_ident_type == 0)) {
		fprintf(stderr, "%s: dstid_type not specified\n", argv[0]);
		exit(1);
	}
	if ((srcid == NULL) && (sid1.sadb_ident_type != 0)) {
		fprintf(stderr, "%s: srcid_type specified, but no srcid given\n",
		    argv[0]);
		exit(1);
	}
	if ((dstid == NULL) && (sid2.sadb_ident_type != 0)) {
		fprintf(stderr, "%s: dstid_type specified, but no dstid given\n",
		    argv[0]);
		exit(1);
	}
d1254 4
a1257 8
	    ((mode & (AH_NEW | AH_OLD | TCPMD5)) && authp == NULL)) {
		fprintf(stderr, "%s: no key material specified\n", argv[0]);
		exit(1);
	}
	if ((mode & ESP_NEW) && auth && authp == NULL) {
		fprintf(stderr, "%s: no auth key material specified\n", argv[0]);
		exit(1);
	}
d1259 8
a1266 17
	    && !iscmd(mode, IPCOMP)) {
		fprintf(stderr, "%s: no SPI specified\n", argv[0]);
		exit(1);
	}
	if (iscmd(mode, IPCOMP) && cpi == SPI_LOCAL_USE) {
		fprintf(stderr, "%s: no CPI specified\n", argv[0]);
		exit(1);
	}
	if ((isencauth(mode) || iscmd(mode, ENC_IP)) && !srcset) {
		fprintf(stderr, "%s: no source address specified\n", argv[0]);
		exit(1);
	}
	if (!dstset && !iscmd(mode, FLUSH) && !iscmd(mode, FLOW)) {
		fprintf(stderr, "%s: no destination address for the SA specified\n",
		    argv[0]);
		exit(1);
	}
d1268 8
a1275 15
	    (odst->sin.sin_port || osrc->sin.sin_port)) {
		fprintf(stderr,
		    "%s: no transport protocol supplied with"
		    " source/destination ports\n", argv[0]);
		exit(1);
	}
	if (iscmd(mode, GRP_SPI) && !dst2set) {
		fprintf(stderr, "%s: no destination address2 specified\n", argv[0]);
		exit(1);
	}
	if ((klen > 2 * 8100) || (alen > 2 * 8100)) {
		fprintf(stderr, "%s: key too long\n", argv[0]);
		exit(1);
	}
	if (iscmd(mode, FLOW) && proto == IPPROTO_IPCOMP) {
d1277 1
a1277 2
	}
	if (keyp != NULL) {
d1280 1
a1280 2
	}
	if (authp != NULL) {
a1282 1
	}
d1503 1
a1503 2
				}
				else if (osrc->sa.sa_family == AF_INET6) {
d1523 1
a1523 2
				}
				else if (odst->sa.sa_family == AF_INET6) {
d1548 1
a1548 1
			if ((srcid) &&
d1557 1
a1557 1
			if ((dstid) &&
a1570 1

@


1.80
log
@remove two ununsed includes
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.79 2004/05/23 16:04:18 markus Exp $ */
d283 1
a283 1
	fprintf(stderr, "usage: ipsecadm [command] <modifier...>\n"
d303 2
a304 2
	    "\t  -sport\t\t\tsource port for flow\n"
	    "\t  -dport\t\t\tdestination port for flow\n"
d306 2
a307 1
	    "\t  -addr [<ip> <net> <ip> <net>|<ip/len> <ip/len>] subnets for flow\n"
d318 5
a322 5
	    "\t  -[ah|esp|ip4|ipcomp|tcpmd5]\t\tflush a particular protocol\n"
	    "\t  -srcid\t\t\tsource identity for flows\n"
	    "\t  -dstid\t\t\tdestination identity for flows\n"
	    "\t  -srcid_type\t\t\tsource identity type\n"
	    "\t  -dstid_type\t\t\tdestination identity type\n"
@


1.79
log
@support deletion of tcpmd5 SAs and add regress tests; ok hshoexer, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.78 2004/05/23 08:48:03 markus Exp $ */
a50 2
#include <netns/ns.h>
#include <netiso/iso.h>
@


1.78
log
@unbreak ipcomp; report davidkrause; ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.77 2004/05/14 20:29:52 ish Exp $ */
d1388 3
@


1.77
log
@unbreak, interpret cpi and spi values as hex even if not preceded by 0x.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.76 2004/05/10 06:24:42 ish Exp $ */
d92 1
d269 1
a269 1
		    (xf[i].flags & CMD_MASK) == type &&
@


1.76
log
@strtonum conversion and better input checking of integer values; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.75 2004/05/09 03:21:35 deraadt Exp $ */
d359 1
d717 4
a720 3
			spi = strtonum(argv[i + 1], 0, UINT_MAX, &errstr);
			if (errstr || (spi >= SPI_RESERVED_MIN && 
			    spi <= SPI_RESERVED_MAX))
d728 4
a731 4
			spi2 = strtonum(argv[i + 1], 0, UINT_MAX, &errstr);
			if (errstr || (spi2 == SPI_LOCAL_USE ||
			    (spi2 >= SPI_RESERVED_MIN && 
			     spi2 <= SPI_RESERVED_MAX))) {
a732 1
			}
d739 5
a743 3
			cpi = strtonum(argv[i + 1], 0, USHRT_MAX, &errstr);
			if (errstr || (cpi >= CPI_RESERVED_MIN && 
			    (cpi <= CPI_RESERVED_MAX || cpi >= CPI_PRIVATE_MAX)))
@


1.75
log
@de-lint
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.74 2004/01/27 22:46:55 itojun Exp $ */
d67 1
d358 1
d716 4
a719 6
			spi = strtoul(argv[i + 1], NULL, 16);
			if (spi >= SPI_RESERVED_MIN && spi <= SPI_RESERVED_MAX) {
				fprintf(stderr, "%s: invalid spi %s\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d726 5
a730 6
			spi2 = strtoul(argv[i + 1], NULL, 16);
			if (spi2 == SPI_LOCAL_USE ||
			    (spi2 >= SPI_RESERVED_MIN && spi2 <= SPI_RESERVED_MAX)) {
				fprintf(stderr, "%s: invalid spi2 %s\n",
				    argv[0], argv[i + 1]);
				exit(1);
d738 4
a741 7
			cpi = strtoul(argv[i + 1], NULL, 16);
			if (cpi >= CPI_RESERVED_MIN && (cpi <= CPI_RESERVED_MAX ||
			    cpi >= CPI_PRIVATE_MAX)) {
				fprintf(stderr, "%s: invalid cpi %s\n",
				    argv[0], argv[i + 1]);
				exit(1);
			}
d965 3
a967 1
			    strtoul(argv[i + 1], NULL, 10);
d1194 5
a1198 1
				tproto = atoi(argv[i + 1]);
d1223 7
a1229 2
			} else
				sport = htons(atoi(argv[i + 1]));
d1244 7
a1250 2
			} else
				dport = htons(atoi(argv[i + 1]));
d1343 8
a1350 8
				proto2 = atoi(argv[i + 1]);

				if (proto2 != IPPROTO_ESP && proto2 != IPPROTO_AH &&
				    proto2 != IPPROTO_IPIP && proto2 != IPPROTO_IPCOMP) {
					fprintf(stderr,
					    "%s: unknown security protocol2 %d\n",
					    argv[0], proto2);
					exit(1);
d1391 8
a1398 7
				proto = atoi(argv[i + 1]);
				if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
				    proto != IPPROTO_IPIP && proto != IPPROTO_IPCOMP) {
					fprintf(stderr,
					    "%s: unknown security protocol %d\n",
					    argv[0], proto);
					exit(1);
@


1.74
log
@correct address resolution logic via getaddrinfo(3).  henning and markus ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.73 2004/01/27 09:26:22 markus Exp $ */
d125 1
a125 1
int	x2i(char *);
d245 1
a245 1
x2i(char *s)
d564 2
a565 2
				authp = argv[++i];
				alen = strlen(authp) / 2;
d567 2
a568 2
				keyp = argv[++i];
				klen = strlen(keyp) / 2;
d584 2
a585 1
				    "%s: file %s is too %s (must be between 1 and %d bytes).\nb",
d590 1
a590 1
			pptr = malloc(sb.st_size);
d600 1
a600 1
			if (read(fd, pptr, sb.st_size) < sb.st_size) {
d632 2
a633 1
				    "%s: file %s is too %s (must be between 1 and %d bytes).\n",
d638 1
a638 1
			authp = malloc(sb.st_size);
d648 1
a648 1
			if (read(fd, authp, sb.st_size) < sb.st_size) {
d665 2
a666 2
			authp = argv[++i];
			alen = strlen(authp) / 2;
d1016 2
a1017 2
			strlcpy(srcid, argv[i + 1], len);
			sid1.sadb_ident_len += ROUNDUP(strlen(srcid) + 1) /
d1036 2
a1037 2
			strlcpy(dstid, argv[i + 1], len);
			sid2.sadb_ident_len += ROUNDUP(strlen(dstid) + 1) /
d1528 1
a1528 1
			iov[cnt++].iov_len = ROUNDUP(strlen(srcid) + 1);
d1536 1
a1536 1
			iov[cnt++].iov_len = ROUNDUP(strlen(dstid) + 1);
d1778 1
a1778 1
				iov[cnt++].iov_len = ROUNDUP(strlen(srcid) + 1);
d1787 1
a1787 1
				iov[cnt++].iov_len = ROUNDUP(strlen(dstid) + 1);
@


1.73
log
@pass -spi for tcpmd5, too; ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.72 2004/01/15 10:15:55 markus Exp $ */
d162 1
d753 17
a769 9
#ifdef INET6
			if (hints.ai_family = AF_INET6,
			    getaddrinfo(argv[i + 1], "0", &hints, &res) == 0) {
				if (res->ai_next) {
					fprintf(stderr,
					    "%s: destination address2 %s resolves to multiple addresses\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d779 2
a780 11
				freeaddrinfo(res);
			} else
#endif
			if (hints.ai_family = AF_INET,
			    getaddrinfo(argv[i + 1], "0", &hints, &res) == 0) {
				if (res->ai_next) {
					fprintf(stderr,
					    "%s: destination address2 %s resolves to multiple addresses\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
d790 6
a795 1
				freeaddrinfo(res);
d798 2
d802 1
a802 1
				    "%s: Warning: destination address2 %s is not valid\n",
d813 17
a829 9
#ifdef INET6
			if (hints.ai_family = AF_INET6,
			    getaddrinfo(argv[i + 1], "0", &hints, &res) == 0) {
				if (res->ai_next) {
					fprintf(stderr,
					    "%s: source address %s resolves to multiple addresses\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
a838 1
				freeaddrinfo(res);
d841 2
a842 10
			} else
#endif
			if (hints.ai_family = AF_INET,
			    getaddrinfo(argv[i + 1], "0", &hints, &res) == 0) {
				if (res->ai_next) {
					fprintf(stderr,
					    "%s: source address %s resolves to multiple addresses\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
a851 1
				freeaddrinfo(res);
d854 6
d862 2
d866 1
a866 1
				    "%s: Warning: source address %s is not valid\n",
d878 17
a894 9
#ifdef INET6
			if (hints.ai_family = AF_INET6,
			    getaddrinfo(argv[i + 1], "0", &hints, &res) == 0) {
				if (res->ai_next) {
					fprintf(stderr,
					    "%s: source address %s resolves to multiple addresses\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
a903 1
				freeaddrinfo(res);
d906 2
a907 10
			} else
#endif
			if (hints.ai_family = AF_INET,
			    getaddrinfo(argv[i + 1], "0", &hints, &res) == 0) {
				if (res->ai_next) {
					fprintf(stderr,
					    "%s: source address %s resolves to multiple addresses\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
a916 1
				freeaddrinfo(res);
d919 6
d927 2
d931 1
a931 1
				    "%s: Warning: proxy address %s is not valid\n",
d1244 17
a1260 9
#ifdef INET6
			if (hints.ai_family = AF_INET6,
			    getaddrinfo(argv[i + 1], "0", &hints, &res) == 0) {
				if (res->ai_next) {
					fprintf(stderr,
					    "%s: destination address %s resolves to multiple addresses\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
a1269 1
				freeaddrinfo(res);
d1272 2
a1273 10
			} else
#endif
			if (hints.ai_family = AF_INET,
			    getaddrinfo(argv[i + 1], "0", &hints, &res) == 0) {
				if (res->ai_next) {
					fprintf(stderr,
					    "%s: destination address %s resolves to multiple addresses\n",
					    argv[0], argv[i + 1]);
					exit(1);
				}
a1282 1
				freeaddrinfo(res);
d1285 6
d1293 2
d1297 1
a1297 1
				    "%s: Warning: destination address %s is not valid\n",
a1723 1
#ifdef INET6
a1727 1
#endif				/* INET6 */
a1744 1
#ifdef INET6
a1748 1
#endif				/* INET6 */
@


1.72
log
@support for rfc 2385 tcp md5 'signature' keys
(e.g. ipsecadm tcpmd5 -src ::1 -dst ::1 -key deadbeef)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.71 2003/12/02 23:16:29 markus Exp $ */
a497 1
		sa.sadb_sa_spi = 0;			/* fixed */
d1435 1
a1435 1
	    && !iscmd(mode, IPCOMP) && !iscmd(mode, TCPMD5)) {
@


1.71
log
@UDP encapsulation for ESP in transport mode (draft-ietf-ipsec-udp-encaps-XX.txt)
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.70 2003/09/23 18:09:20 itojun Exp $ */
d70 19
a88 16
#define ESP_OLD		0x01
#define ESP_NEW		0x02
#define AH_OLD		0x04
#define AH_NEW		0x08
#define IPCOMP		0x10

#define XF_ENC		0x10
#define XF_AUTH		0x20
#define DEL_SPI		0x30
#define GRP_SPI		0x40
#define FLOW		0x50
#define FLUSH		0x70
#define ENC_IP		0x80
#define XF_COMP		0x90
#define SHOW		0xa0
#define MONITOR		0xb0
d90 1
a90 1
#define CMD_MASK	0xf0
d284 1
a284 1
	    "\t\t  flow, flush, show, monitor\n"
d316 1
a316 1
	    "\t  -[ah|esp|ip4|ipcomp]\t\tflush a particular protocol\n"
d494 6
d563 1
a563 1
			if (mode & (AH_NEW | AH_OLD)) {
d605 1
a605 1
			if (mode & (AH_NEW | AH_OLD)) {
d692 2
d1427 1
a1427 1
	    ((mode & (AH_NEW | AH_OLD)) && authp == NULL)) {
d1436 1
a1436 1
	    && !iscmd(mode, IPCOMP)) {
d1483 1
a1483 1
	if (isencauth(mode)) {
@


1.70
log
@use getaddrinfo for name-to-address resolution.  mcbride@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.69 2003/07/24 09:59:02 itojun Exp $ */
d289 1
d313 1
a313 1
	    "\t  -[ah|esp|ip4|ipcomp]\t\t\tflush a particular protocol\n"
d349 1
d380 1
d927 18
d1543 5
@


1.69
log
@conform to RFC2367 on SADB_xx naming (local name must be prefixed with
SADB_X_xx)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.68 2003/07/24 08:03:19 itojun Exp $ */
d327 1
a327 1
	int srcset = 0, dstset = 0, dst2set = 0;
d350 1
d737 2
d740 18
a757 7
			if (strchr(argv[i + 1], ':')) {
				sad8.sadb_address_len = (sizeof(sad8) +
				    ROUNDUP(sizeof(struct sockaddr_in6))) / 8;
				dst2->sin6.sin6_family = AF_INET6;
				dst2->sin6.sin6_len = sizeof(struct sockaddr_in6);
				dst2set = inet_pton(AF_INET6, argv[i + 1],
				    &dst2->sin6.sin6_addr) != -1 ? 1 : 0;
d759 19
a777 8
#endif				/* INET6 */
			{
				sad8.sadb_address_len = (sizeof(sad8) +
				    sizeof(struct sockaddr_in)) / 8;
				dst2->sin.sin_family = AF_INET;
				dst2->sin.sin_len = sizeof(struct sockaddr_in);
				dst2set = inet_pton(AF_INET, argv[i + 1],
				    &dst2->sin.sin_addr) != -1 ? 1 : 0;
d791 2
d794 20
a813 7
			if (strchr(argv[i + 1], ':')) {
				src->sin6.sin6_family = AF_INET6;
				src->sin6.sin6_len = sizeof(struct sockaddr_in6);
				srcset = inet_pton(AF_INET6, argv[i + 1],
				    &src->sin6.sin6_addr) != -1 ? 1 : 0;
				sad1.sadb_address_len = 1 +
				    ROUNDUP(sizeof(struct sockaddr_in6)) / 8;
d815 21
a835 7
#endif				/* INET6 */
			{
				src->sin.sin_family = AF_INET;
				src->sin.sin_len = sizeof(struct sockaddr_in);
				srcset = inet_pton(AF_INET, argv[i + 1],
				    &src->sin.sin_addr) != -1 ? 1 : 0;
				sad1.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
d850 2
d853 9
a861 5
			if (strchr(argv[i + 1], ':')) {
				proxy->sin6.sin6_family = AF_INET6;
				proxy->sin6.sin6_len = sizeof(struct sockaddr_in6);
				if (!inet_pton(AF_INET6, argv[i + 1],
				    &proxy->sin6.sin6_addr)) {
d863 1
a863 1
					    "%s: Warning: proxy address %s is not valid\n",
d867 6
a872 2
				sad3.sadb_address_len = 1 +
				    ROUNDUP(sizeof(struct sockaddr_in6)) / 8;
d874 10
a883 6
#endif				/* INET6 */
			{
				proxy->sin.sin_family = AF_INET;
				proxy->sin.sin_len = sizeof(struct sockaddr_in);
				if (!inet_pton(AF_INET, argv[i + 1],
				    &proxy->sin.sin_addr)) {
d885 1
a885 1
					    "%s: Warning: proxy address %s is not valid\n",
d889 6
a894 1
				sad3.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
d897 6
d1192 2
d1195 18
a1212 1
			if (strchr(argv[i + 1], ':')) {
a1214 4
				dst->sin6.sin6_family = AF_INET6;
				dst->sin6.sin6_len = sizeof(struct sockaddr_in6);
				dstset = inet_pton(AF_INET6, argv[i + 1],
					&dst->sin6.sin6_addr) != -1 ? 1 : 0;
d1216 19
a1234 2
#endif				/* INET6 */
			{
d1236 1
a1236 5
				    sizeof(struct sockaddr_in)) / 8;
				dst->sin.sin_family = AF_INET;
				dst->sin.sin_len = sizeof(struct sockaddr_in);
				dstset = inet_pton(AF_INET, argv[i + 1],
				    &dst->sin.sin_addr) != -1 ? 1 : 0;
@


1.68
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.67 2003/07/02 21:44:57 deraadt Exp $ */
d106 3
a108 3
	{ "sha2-256", SADB_AALG_SHA2_256, XF_AUTH | AH_NEW | ESP_NEW },
	{ "sha2-384", SADB_AALG_SHA2_384, XF_AUTH | AH_NEW | ESP_NEW },
	{ "sha2-512", SADB_AALG_SHA2_512, XF_AUTH | AH_NEW | ESP_NEW },
d111 1
a111 1
	{ "rmd160", SADB_AALG_RIPEMD160HMAC, XF_AUTH | AH_NEW | ESP_NEW },
@


1.67
log
@missing protos
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.66 2003/02/25 22:29:33 markus Exp $ */
d106 3
@


1.66
log
@implement 'show' and 'monitor' commands; ok djm@@, deraadt@@, cedric@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.65 2003/02/15 22:57:58 jason Exp $ */
d117 5
@


1.65
log
@skeleton support for LZS compression
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.64 2002/07/03 22:32:33 deraadt Exp $ */
d84 2
d115 3
d273 1
a273 1
	    "\t\t  flow, flush\n"
d484 7
d663 2
a664 1
		if (iscmd(mode, FLUSH) && smsg.sadb_msg_satype == SADB_SATYPE_UNSPEC) {
d1231 8
@


1.64
log
@ansi
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.63 2001/12/01 19:05:01 deraadt Exp $ */
d108 1
@


1.63
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.62 2001/08/05 11:10:34 deraadt Exp $ */
d263 1
a263 1
usage()
d308 1
a308 1
main(int argc, char **argv)
@


1.62
log
@re-order headers as they should be
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.61 2001/07/06 05:01:07 angelos Exp $ */
d4 1
a4 1
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and 
d7 1
a7 1
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
d25 1
a25 1
 * modification of this software. 
d74 1
a74 1
#define IPCOMP          0x10
d79 1
a79 1
#define GRP_SPI         0x40
d83 1
a83 1
#define XF_COMP         0x90
d87 2
a88 2
#define isencauth(x) ((x)&~CMD_MASK)
#define iscmd(x,y)   (((x) & CMD_MASK) == (y))
d91 2
a92 2
    char *name;
    int   id, flags;
d96 12
a107 12
    {"des", SADB_EALG_DESCBC,   XF_ENC |ESP_OLD|ESP_NEW},
    {"3des", SADB_EALG_3DESCBC, XF_ENC |ESP_OLD|ESP_NEW},
    {"aes", SADB_X_EALG_AES, XF_ENC |ESP_NEW},
    {"blf", SADB_X_EALG_BLF,   XF_ENC |        ESP_NEW},
    {"cast", SADB_X_EALG_CAST, XF_ENC |        ESP_NEW},
    {"skipjack", SADB_X_EALG_SKIPJACK, XF_ENC |        ESP_NEW},
    {"md5", SADB_AALG_MD5HMAC,  XF_AUTH|AH_NEW|ESP_NEW},
    {"sha1", SADB_AALG_SHA1HMAC,XF_AUTH|AH_NEW|ESP_NEW},
    {"md5", SADB_X_AALG_MD5,  XF_AUTH|AH_OLD},
    {"sha1", SADB_X_AALG_SHA1,XF_AUTH|AH_OLD},
    {"rmd160", SADB_AALG_RIPEMD160HMAC, XF_AUTH|AH_NEW|ESP_NEW},
    {"deflate", SADB_X_CALG_DEFLATE, XF_COMP|IPCOMP},
d119 54
a172 30
    u_long prefixlen = 0;
    char *p = NULL, *sp, *ep;
    struct addrinfo hints, *res = NULL;
    u_char *ap;
    int bitlen;

    /* slash */
    if (mask && (p = strchr(str, '/')) != NULL) {
	if (!p[1])
	    return -1;
	ep = NULL;
	prefixlen = strtoul(p + 1, &ep, 10);
	if (*ep)
	    return -1;

	sp = strdup(str);
	if (!sp)
	    return -1;
	sp[p - str] = '\0';
	str = sp;
    } else
	sp = NULL;

    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
    hints.ai_flags = AI_NUMERICHOST;
    if (getaddrinfo(str, "0", &hints, &res) != 0)
	return -1;
    if (res->ai_next)
	goto fail;
d174 6
a179 1
    memcpy(addr, res->ai_addr, res->ai_addrlen);
d181 2
a182 2
    if (!p) {
	freeaddrinfo(res);
d184 2
a185 32
	    free(sp);
	return 0;
    }

    switch (res->ai_family) {
    case AF_INET:
	ap = (u_char *)&((struct sockaddr_in *)mask)->sin_addr;
	bitlen = 32;
	break;
    case AF_INET6:
	ap = (u_char *)&((struct sockaddr_in6 *)mask)->sin6_addr;
	bitlen = 128;
	break;
    default:
	goto fail;
    }

    if (prefixlen > bitlen)
	goto fail;

    memset(mask, 0, addr->sa_len);
    mask->sa_len = addr->sa_len;
    mask->sa_family = addr->sa_family;
    memset(ap, 0xff, prefixlen / 8);
    if (prefixlen % 8)
	ap[prefixlen / 8] = (0xff00 >> (prefixlen % 8)) & 0xff;

    if (res)
	freeaddrinfo(res);
    if (sp)
	free(sp);
    return 1;
d188 5
a192 5
    if (res)
	freeaddrinfo(res);
    if (sp)
	free(sp);
    return -1;
d198 2
a199 2
    struct sadb_msg sm;
    int sd;
d201 23
a223 31
    sd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2);
    if (sd < 0) 
    {
	perror("socket");
	if (errno == EPROTONOSUPPORT)
	    fprintf(stderr,
		"Make sure your kernel is compiled with option KEY\n");
	exit(1);
    }

    if (writev(sd, iov, cnt) != len)
    {
	perror("write");
	exit(1);
    }

    if (read(sd, &sm, sizeof(sm)) != sizeof(sm))
    {
	perror("read");
	exit(1);
    }

    if (sm.sadb_msg_errno != 0)
    {
	/* XXX We need better error reporting than this */
	errno = sm.sadb_msg_errno;
	perror("pfkey");
	exit(1);
    }

    close(sd);
d229 1
a229 10
    char    ss[3];
    ss[0] = s[0];
    ss[1] = s[1];
    ss[2] = 0;

    if (!isxdigit(s[0]) || !isxdigit(s[1]))
    {
	fprintf(stderr, "Keys should be specified in hex digits.\n");
	exit(1);
    }
d231 9
a239 1
    return strtoul(ss, NULL, 16);
d245 1
a245 1
    int i;
d247 13
a259 12
    for (i = sizeof(xf) / sizeof(transform) - 1; i >= 0; i--)
      if (!strcmp(option, xf[i].name) &&
	  (xf[i].flags & CMD_MASK) == type && 
	  (xf[i].flags & mode))
      {
	  if (!strcmp(option, "des") || !strcmp(option, "skipjack"))
	    fprintf(stderr, "Warning: use of %s is strongly discouraged due to cryptographic weaknesses\n", option);

          return xf[i].id;
      }

    return 0;
d265 1
a265 1
    fprintf(stderr, "usage: ipsecadm [command] <modifier...>\n"
d296 2
a297 2
            "\t  -in\t\t\t\tspecify incoming-packet policy\n"
            "\t  -out\t\t\t\tspecify outgoing-packet policy\n"
d310 148
a457 185
    int auth = 0, enc = 0, klen = 0, alen = 0, mode = ESP_NEW, i = 0;
    int proto = IPPROTO_ESP, proto2 = IPPROTO_AH, sproto2 = SADB_SATYPE_AH;
    int comp = 0;
    int dport = -1, sport = -1, tproto = -1;
    u_int32_t spi = SPI_LOCAL_USE, spi2 = SPI_LOCAL_USE;
    u_int32_t cpi = SPI_LOCAL_USE;
    union sockaddr_union *src, *dst, *dst2, *osrc, *odst, *osmask;
    union sockaddr_union *odmask, *proxy;
    u_char srcbuf[256], dstbuf[256], dst2buf[256], osrcbuf[256];
    u_char odstbuf[256], osmaskbuf[256], odmaskbuf[256], proxybuf[256];
    int srcset = 0, dstset = 0, dst2set = 0;
    u_char *keyp = NULL, *authp = NULL;
    u_char *srcid = NULL, *dstid = NULL;
    struct protoent *tp;
    struct servent *svp;
    char *transportproto = NULL;
    struct sadb_msg smsg;
    struct sadb_sa sa, sa2;
    struct sadb_address sad1; /* src */
    struct sadb_address sad2; /* dst */
    struct sadb_address sad3; /* proxy */
    struct sadb_address sad4; /* osrc */
    struct sadb_address sad5; /* odst */
    struct sadb_address sad6; /* osmask */
    struct sadb_address sad7; /* odmask */
    struct sadb_address sad8; /* dst2 */
    struct sadb_ident sid1, sid2;
    struct sadb_key skey1;
    struct sadb_key skey2;
    struct sadb_protocol sprotocol;
    struct sadb_protocol sprotocol2;
    struct iovec iov[30];
    int cnt = 0;
    u_char realkey[8192], realakey[8192];
    int bypass = 0;
    int deny = 0;
    int ipsec = 0;

    if (argc < 2)
    {
	usage();
	exit(1);
    }

    /* Zero out */
    bzero(&smsg, sizeof(smsg));
    bzero(&sa, sizeof(sa));
    bzero(&sa2, sizeof(sa2));
    bzero(&skey1, sizeof(skey1));
    bzero(&skey2, sizeof(skey2));
    bzero(&sad1, sizeof(sad1));
    bzero(&sad2, sizeof(sad2));
    bzero(&sad3, sizeof(sad3));
    bzero(&sad4, sizeof(sad4));
    bzero(&sad5, sizeof(sad5));
    bzero(&sad6, sizeof(sad6));
    bzero(&sad7, sizeof(sad7));
    bzero(&sad8, sizeof(sad8));
    bzero(&sprotocol, sizeof(sprotocol));
    bzero(&sprotocol2, sizeof(sprotocol2));
    bzero(iov, sizeof(iov));
    bzero(realkey, sizeof(realkey));
    bzero(realakey, sizeof(realakey));
    bzero(&sid1, sizeof(sid1));
    bzero(&sid2, sizeof(sid2));

    src = (union sockaddr_union *) srcbuf;
    dst = (union sockaddr_union *) dstbuf;
    dst2 = (union sockaddr_union *) dst2buf;
    osrc = (union sockaddr_union *) osrcbuf;
    odst = (union sockaddr_union *) odstbuf;
    osmask = (union sockaddr_union *) osmaskbuf;
    odmask = (union sockaddr_union *) odmaskbuf;
    proxy = (union sockaddr_union *) proxybuf;

    bzero(srcbuf, sizeof(srcbuf));
    bzero(dstbuf, sizeof(dstbuf));
    bzero(dst2buf, sizeof(dst2buf));
    bzero(osrcbuf, sizeof(osrcbuf));
    bzero(odstbuf, sizeof(odstbuf));
    bzero(osmaskbuf, sizeof(osmaskbuf));
    bzero(odmaskbuf, sizeof(odmaskbuf));
    bzero(proxybuf, sizeof(proxybuf));

    /* Initialize */
    smsg.sadb_msg_version = PF_KEY_V2;
    smsg.sadb_msg_seq = 1;
    smsg.sadb_msg_pid = getpid();
    smsg.sadb_msg_len = sizeof(smsg) / 8;
    
    /* Initialize */
    sa.sadb_sa_exttype = SADB_EXT_SA;
    sa.sadb_sa_len = sizeof(sa) / 8;
    sa.sadb_sa_replay = 0;
    sa.sadb_sa_state = SADB_SASTATE_MATURE;

    sa2.sadb_sa_exttype = SADB_X_EXT_SA2;
    sa2.sadb_sa_len = sizeof(sa) / 8;
    sa2.sadb_sa_replay = 0;
    sa2.sadb_sa_state = SADB_SASTATE_MATURE;

    sid1.sadb_ident_len = sizeof(sid1) / 8;
    sid1.sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;

    sid2.sadb_ident_len = sizeof(sid2) / 8;
    sid2.sadb_ident_exttype = SADB_EXT_IDENTITY_DST;
    
    sprotocol2.sadb_protocol_len = 1;
    sprotocol2.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
    sprotocol2.sadb_protocol_direction = IPSP_DIRECTION_OUT;
    sprotocol2.sadb_protocol_flags = SADB_X_POLICYFLAGS_POLICY;
    sprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
    sprotocol.sadb_protocol_len = 1;

    if (!strcmp(argv[1], "new") && argc > 3)
    {
	if (!strcmp(argv[2], "esp"))
	{
	    mode = ESP_NEW;
	    smsg.sadb_msg_type = SADB_ADD;
	    smsg.sadb_msg_satype = SADB_SATYPE_ESP;
	}
	else
	  if (!strcmp(argv[2], "ah"))
	  {
	      mode = AH_NEW;
	      smsg.sadb_msg_type = SADB_ADD;
	      smsg.sadb_msg_satype = SADB_SATYPE_AH;
	  }
	  else
	  {
	      fprintf(stderr, "%s: unexpected identifier %s\n", argv[0],
		      argv[2]);
	      exit(1);
	  }
	
	i += 2;
    }
    else
      if (!strcmp(argv[1], "old") && argc > 3)
      {
	  if (!strcmp(argv[2], "esp"))
	  {
	      mode = ESP_OLD;
	      smsg.sadb_msg_type = SADB_ADD;
	      smsg.sadb_msg_satype = SADB_SATYPE_ESP;
	      sa.sadb_sa_flags |= SADB_X_SAFLAGS_RANDOMPADDING;
	      sa.sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;
	  }
	  else
	    if (!strcmp(argv[2], "ah"))
	    {
		mode = AH_OLD;
		smsg.sadb_msg_type = SADB_ADD;
		smsg.sadb_msg_satype = SADB_SATYPE_AH;
		sa.sadb_sa_flags |= SADB_X_SAFLAGS_NOREPLAY;
	    }
	    else
	    {
		fprintf(stderr, "%s: unexpected identifier %s\n", argv[0],
			argv[2]);
		exit(1);
	    }
	  
	  i += 2;
      }
      else
	if (!strcmp(argv[1], "delspi"))
	{
	    smsg.sadb_msg_type = SADB_DELETE;
	    smsg.sadb_msg_satype = SADB_SATYPE_ESP;
	    mode = DEL_SPI;
	    i++;
	}
	else
	  if (!strcmp(argv[1], "group"))
	  {
	      smsg.sadb_msg_type = SADB_X_GRPSPIS;
	      smsg.sadb_msg_satype = SADB_SATYPE_ESP;
	      mode = GRP_SPI;
	      i++;
	  }
	  else
	    if (!strcmp(argv[1], "flow"))
	    {
d463 20
a482 40
	    }
	    else
	      if (!strcmp(argv[1], "flush"))
	      {
		  mode = FLUSH;
		  smsg.sadb_msg_type = SADB_FLUSH;
		  smsg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
		  i++;
	      }
	      else 
		if (!strcmp(argv[1], "ip4"))
		{
		    mode = ENC_IP;
		    smsg.sadb_msg_type = SADB_ADD;
		    smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
		    i++;
		}
                else
		 if (!strcmp(argv[1], "ipcomp"))
		 {
		     mode = IPCOMP;
		     smsg.sadb_msg_type = SADB_ADD;
		     smsg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		     i++;
		 }
		 else
		 {
		     fprintf(stderr, "%s: unknown command: %s\n", argv[0],
			     argv[1]);
		     usage();
		     exit(1);
		 }
    
    for (i++; i < argc; i++)
    {
	if (argv[i][0] != '-')
	{
	    fprintf(stderr, "%s: expected option, got %s\n", 
		    argv[0], argv[i]);
	    exit(1);
d485 4
a488 222
	if (!strcmp(argv[i] + 1, "enc") && enc == 0 && (i + 1 < argc))
	{
	    if ((enc = isvalid(argv[i + 1], XF_ENC, mode)) == 0)
	    {
		fprintf(stderr, "%s: invalid encryption algorithm %s\n",
			argv[0], argv[i + 1]);
		exit(1);
	    }
	
	    skey1.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
	    sa.sadb_sa_encrypt = enc;
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "auth") && auth == 0 && (i + 1 < argc))
	{
	    if ((auth = isvalid(argv[i + 1], XF_AUTH, mode)) == 0)
	    {
		fprintf(stderr, "%s: invalid auth algorithm %s\n",
			argv[0], argv[i + 1]);
		exit(1);
	    }

	    skey2.sadb_key_exttype = SADB_EXT_KEY_AUTH;
	    sa.sadb_sa_auth = auth;
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "comp") && comp == 0 && (i + 1 < argc))
	{
	    if ((comp = isvalid(argv[i + 1], XF_COMP, mode)) == 0)
	    {
		fprintf(stderr, "%s: invalid comp algorithm %s\n",
			argv[0], argv[i + 1]);
		exit(1);
	    }

	    /*
	     * Use encryption algo slot to store compression algo
	     * since we cannot modify sadb_sa
	     */
	    sa.sadb_sa_encrypt = comp;
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "key") && keyp == NULL &&
	    (i + 1 < argc))
	{
	    if (mode & (AH_NEW | AH_OLD))
	    {
		authp = argv[++i];
		alen = strlen(authp) / 2;
	    }
	    else
	    {
		keyp = argv[++i];
		klen = strlen(keyp) / 2;
	    }
	    continue;
	}

	if (!strcmp(argv[i] + 1, "keyfile") && keyp == NULL &&
	    (i + 1 < argc))
	{
	    struct stat sb;
	    unsigned char *pptr;
	    int fd;

	    if (stat(argv[++i], &sb) < 0)
	    {
		perror("stat()");
		exit(1);
	    }

	    if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0))
	    {
		fprintf(stderr,	"%s: file %s is too %s (must be between 1 and %d bytes).\nb", argv[0], argv[i], sb.st_size ? "large" : "small", KEYSIZE_LIMIT);
		exit(1);
	    }

	    pptr = malloc(sb.st_size);
	    if (pptr == NULL)
	    {
		perror("malloc()");
		exit(1);
	    }

	    fd = open(argv[i], O_RDONLY);
	    if (fd < 0)
	    {
		perror("open()");
		exit(1);
	    }

	    if (read(fd, pptr, sb.st_size) < sb.st_size)
	    {
		perror("read()");
		exit(1);
	    }

	    close(fd);

	    if (mode & (AH_NEW | AH_OLD))
	    {
		authp = pptr;
		alen = sb.st_size / 2;
	    }
	    else
	    {
		keyp = pptr;
		klen = sb.st_size / 2;
	    }
	    continue;
	}

	if (!strcmp(argv[i] + 1, "authkeyfile") && authp == NULL &&
	    (i + 1 < argc))
	{
	    struct stat sb;
	    int fd;

	    if (!(mode & ESP_NEW))
	    {
		fprintf(stderr,	"%s: invalid option %s for selected mode\n",
			argv[0], argv[i]);
		exit(1);
	    }

	    if (stat(argv[++i], &sb) < 0)
	    {
		perror("stat()");
		exit(1);
	    }

	    if ((sb.st_size > KEYSIZE_LIMIT) || (sb.st_size == 0))
	    {
		fprintf(stderr,	"%s: file %s is too %s (must be between 1 and %d bytes).\n", argv[0], argv[i], sb.st_size ? "large" : "small", KEYSIZE_LIMIT);
		exit(1);
	    }

	    authp = malloc(sb.st_size);
	    if (authp == NULL)
	    {
		perror("malloc()");
		exit(1);
	    }

	    fd = open(argv[i], O_RDONLY);
	    if (fd < 0)
	    {
		perror("open()");
		exit(1);
	    }

	    if (read(fd, authp, sb.st_size) < sb.st_size)
	    {
		perror("read()");
		exit(1);
	    }

	    close(fd);

	    alen = sb.st_size / 2;
	    continue;
	}
	
	if (!strcmp(argv[i] + 1, "authkey") && authp == NULL &&
	    (i + 1 < argc))
	{
	    if (!(mode & ESP_NEW))
	    {
		fprintf(stderr,	"%s: invalid option %s for selected mode\n",
			argv[0], argv[i]);
		exit(1);
	    }

	    authp = argv[++i];
	    alen = strlen(authp) / 2;
	    continue;
	}
	
	if (!strcmp(argv[i] + 1, "iv") && (i + 1 < argc))
	{
	    if (mode & (AH_OLD | AH_NEW))
	    {
		fprintf(stderr, "%s: invalid option %s with auth\n",
			argv[0], argv[i]);
		exit(1);
	    }

	    fprintf(stderr,
		    "%s: Warning: option iv has been deprecated\n", argv[0]);

	    /* Horrible hack */
	    if (mode & ESP_OLD)
	      if (strlen(argv[i + 2]) == 4)
		sa.sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;

	    i++;
	    continue;
	}

	if (iscmd(mode, FLUSH) && smsg.sadb_msg_satype == SADB_SATYPE_UNSPEC)
	{
	    if(!strcmp(argv[i] + 1, "esp"))
	        smsg.sadb_msg_satype = SADB_SATYPE_ESP;
	    else 
	      if(!strcmp(argv[i] + 1, "ah"))
	          smsg.sadb_msg_satype = SADB_SATYPE_AH;
	      else 
		if(!strcmp(argv[i] + 1, "ip4"))
		  smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
		else
		    if(!strcmp(argv[i] + 1, "ipcomp"))
			smsg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;  
		    else
		    {
			fprintf(stderr, "%s: invalid SA type %s\n",
				argv[0], argv[i + 1]);
d490 224
a713 64
		    }
	    i++;
	    continue;
	}

        if (!strcmp(argv[i] + 1, "spi") && iscmd(mode, FLOW))
        {
            fprintf(stderr, "%s: use of flag \"-spi\" is deprecated with "
                    "flow creation or deletion\n", argv[0]);
            i++;
            continue;
        }

	if (!strcmp(argv[i] + 1, "spi") && spi == SPI_LOCAL_USE &&
	    (i + 1 < argc) && !bypass && !deny)
	{
	    spi = strtoul(argv[i + 1], NULL, 16);
	    if (spi >= SPI_RESERVED_MIN && spi <= SPI_RESERVED_MAX)
	    {
		fprintf(stderr, "%s: invalid spi %s\n", argv[0], argv[i + 1]);
		exit(1);
	    }

	    sa.sadb_sa_spi = htonl(spi);
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "spi2") && spi2 == SPI_LOCAL_USE && 
	    iscmd(mode, GRP_SPI) && (i + 1 < argc))
	{
	    spi2 = strtoul(argv[i + 1], NULL, 16);
	    if (spi2 == SPI_LOCAL_USE ||
		(spi2 >= SPI_RESERVED_MIN && spi2 <= SPI_RESERVED_MAX))
	    {
		fprintf(stderr, "%s: invalid spi2 %s\n", argv[0], argv[i + 1]);
		exit(1);
	    }

	    sa2.sadb_sa_spi = htonl(spi2);
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "cpi") && cpi == SPI_LOCAL_USE &&
	    (i + 1 < argc) && !bypass && !deny)
	{
	    cpi = strtoul(argv[i + 1], NULL, 16);
	    if (cpi >= CPI_RESERVED_MIN && (cpi <= CPI_RESERVED_MAX ||
					    cpi >= CPI_PRIVATE_MAX))
	    {
		fprintf(stderr, "%s: invalid cpi %s\n", argv[0], argv[i + 1]);
		exit(1);
	    }

	    sa.sadb_sa_spi = ntohl(cpi);
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "dst2") && 
	    iscmd(mode, GRP_SPI) && (i + 1 < argc))
	{
	    sad8.sadb_address_exttype = SADB_X_EXT_DST2;
d715 6
a720 8
	    if (strchr(argv[i + 1], ':'))
	    {
		sad8.sadb_address_len = (sizeof(sad8) +
					 ROUNDUP(sizeof(struct sockaddr_in6)))
					 / 8;
		dst2->sin6.sin6_family = AF_INET6;
		dst2->sin6.sin6_len = sizeof(struct sockaddr_in6);
		dst2set = inet_pton(AF_INET6, argv[i + 1],
d722 8
a729 9
	    }
	    else
#endif /* INET6 */
	    {
		sad8.sadb_address_len = (sizeof(sad8) +
					 sizeof(struct sockaddr_in)) / 8;
		dst2->sin.sin_family = AF_INET;
		dst2->sin.sin_len = sizeof(struct sockaddr_in);
		dst2set = inet_pton(AF_INET, argv[i + 1],
d731 256
a986 1
	    }
d988 228
a1215 5
	    if (dst2set == 0)
	    {
		fprintf(stderr,
			"%s: Warning: destination address2 %s is not valid\n",
			argv[0], argv[i + 1]);
a1216 3
	    }
	    i++;
	    continue;
d1219 31
a1249 28
	if (!strcmp(argv[i] + 1, "src") && (i + 1 < argc))
	{
	    sad1.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
#ifdef INET6
	    if (strchr(argv[i + 1], ':'))
	    {
		src->sin6.sin6_family = AF_INET6;
		src->sin6.sin6_len = sizeof(struct sockaddr_in6);
		srcset = inet_pton(AF_INET6, argv[i + 1],
				   &src->sin6.sin6_addr) != -1 ? 1 : 0;
		sad1.sadb_address_len = 1 +
				       ROUNDUP(sizeof(struct sockaddr_in6)) / 8;
	    }
	    else
#endif /* INET6 */
	    {
		src->sin.sin_family = AF_INET;
		src->sin.sin_len = sizeof(struct sockaddr_in);
		srcset = inet_pton(AF_INET, argv[i + 1],
				   &src->sin.sin_addr) != -1 ? 1 : 0;
		sad1.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
	    }

	    if (srcset == 0)
	    {
		fprintf(stderr,
			"%s: Warning: source address %s is not valid\n",
			argv[0], argv[i + 1]);
a1250 3
	    }
	    i++;
	    continue;
d1252 2
a1253 41

	if (!strcmp(argv[i] + 1, "proxy") && (i + 1 < argc) && !deny &&
	    !bypass && !ipsec)
	{
	    sad3.sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;
#ifdef INET6
	    if (strchr(argv[i + 1], ':'))
	    {
		proxy->sin6.sin6_family = AF_INET6;
		proxy->sin6.sin6_len = sizeof(struct sockaddr_in6);
		if (!inet_pton(AF_INET6, argv[i + 1], &proxy->sin6.sin6_addr)) {
		    fprintf(stderr,
			    "%s: Warning: proxy address %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		sad3.sadb_address_len = 1 +
				       ROUNDUP(sizeof(struct sockaddr_in6)) / 8;
	    }
	    else
#endif /* INET6 */
	    {
		proxy->sin.sin_family = AF_INET;
		proxy->sin.sin_len = sizeof(struct sockaddr_in);
		if (!inet_pton(AF_INET, argv[i + 1], &proxy->sin.sin_addr)) {
		    fprintf(stderr,
			    "%s: Warning: proxy address %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		sad3.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
	    }

	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "newpadding"))
	{
	    fprintf(stderr,
		    "%s: Warning: option newpadding has been deprecated\n",
d1255 10
a1264 1
	    continue;
d1266 7
a1272 26

        if (!strcmp(argv[i] + 1, "in") && iscmd(mode, FLOW))
        {
            sprotocol2.sadb_protocol_direction = IPSP_DIRECTION_IN;
            continue;
        }

        if (!strcmp(argv[i] + 1, "out") && iscmd(mode, FLOW))
        {
            sprotocol2.sadb_protocol_direction = IPSP_DIRECTION_OUT;
            continue;
        }

	if (!strcmp(argv[i] + 1, "forcetunnel") && isencauth(mode))
	{
	    sa.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "halfiv"))
	{
	    if (!(mode & ESP_OLD))
	    {
		fprintf(stderr,
			"%s: option halfiv can be used only with old ESP\n",
			argv[0]);
a1273 4
	    }

	    sa.sadb_sa_flags |= SADB_X_SAFLAGS_HALFIV;
	    continue;
d1275 3
a1277 5

	if (!strcmp(argv[i] + 1, "delete") && iscmd(mode, FLOW))
	{
	    smsg.sadb_msg_type = SADB_X_DELFLOW;
	    continue;
d1279 2
a1280 4

	if (!strcmp(argv[i] + 1, "local") && iscmd(mode, FLOW))
	{
	    fprintf(stderr, "%s: Warning: option local has been deprecated\n",
d1282 1
a1282 1
	    continue;
d1284 2
a1285 152

	if (!strcmp(argv[i] + 1, "tunnel") &&	
	    (isencauth(mode) || mode == ENC_IP) && ( i + 2 < argc))
	{
	    i += 2;
	    sa.sadb_sa_flags |= SADB_X_SAFLAGS_TUNNEL;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "srcid") && (iscmd(mode, FLOW) ||
					      isencauth(mode)) &&
	    (i + 1 < argc))
	{
	    if (srcid != NULL)
	    {
		fprintf(stderr, "%s: srcid specified multiple times\n",
			argv[0]);
		exit(1);
	    }

	    srcid = calloc(ROUNDUP(strlen(argv[i + 1]) + 1), sizeof(char));
            if (srcid == NULL)
            {
                fprintf(stderr, "%s: malloc failed\n", argv[0]);
                exit(1);
            }
            strcpy(srcid, argv[i + 1]);
	    sid1.sadb_ident_len += ROUNDUP(strlen(srcid) + 1) / sizeof(u_int64_t);
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "dstid") && (iscmd(mode, FLOW) ||
					      isencauth(mode)) &&
	    (i + 1 < argc))
	{
	    if (dstid != NULL)
	    {
		fprintf(stderr, "%s: dstid specified multiple times\n",
			argv[0]);
		exit(1);
	    }

	    dstid = calloc(ROUNDUP(strlen(argv[i + 1]) + 1), sizeof(char));
            if (dstid == NULL)
            {
                fprintf(stderr, "%s: malloc failed\n", argv[0]);
                exit(1);
            }
            strcpy(dstid, argv[i + 1]);
	    sid2.sadb_ident_len += ROUNDUP(strlen(dstid) + 1) / sizeof(u_int64_t);
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "srcid_type") && (iscmd(mode, FLOW) ||
						   isencauth(mode)) &&
	    (i + 1 < argc))
	{
	    if (sid1.sadb_ident_type != 0)
	    {
		fprintf(stderr, "%s: srcid_type specified multiple times\n",
			argv[0]);
		exit(1);
	    }

	    if (!strcmp(argv[i + 1], "prefix"))
	      sid1.sadb_ident_type = SADB_IDENTTYPE_PREFIX;
	    else
	      if (!strcmp(argv[i + 1], "fqdn"))
		sid1.sadb_ident_type = SADB_IDENTTYPE_FQDN;
	      else
		if (!strcmp(argv[i + 1], "ufqdn"))
		  sid1.sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
		else
		{
		    fprintf(stderr, "%s: unknown identity type \"%s\"\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}

	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "dstid_type") && (iscmd(mode, FLOW) ||
						   isencauth(mode)) &&
	    (i + 1 < argc))
	{
	    if (sid2.sadb_ident_type != 0)
	    {
		fprintf(stderr, "%s: dstid_type specified multiple times\n",
			argv[0]);
		exit(1);
	    }

	    if (!strcmp(argv[i + 1], "prefix"))
	      sid2.sadb_ident_type = SADB_IDENTTYPE_PREFIX;
	    else
	      if (!strcmp(argv[i + 1], "fqdn"))
		sid2.sadb_ident_type = SADB_IDENTTYPE_FQDN;
	      else
		if (!strcmp(argv[i + 1], "ufqdn"))
		  sid2.sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
		else
		{
		    fprintf(stderr, "%s: unknown identity type \"%s\"\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}

	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "addr") && iscmd(mode, FLOW) &&
	    (i + 1 < argc))
	{
	    int advance;

	    sad4.sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
	    sad5.sadb_address_exttype = SADB_X_EXT_DST_FLOW;
	    sad6.sadb_address_exttype = SADB_X_EXT_SRC_MASK;
	    sad7.sadb_address_exttype = SADB_X_EXT_DST_MASK;

	    switch (addrparse(argv[i + 1], &osrc->sa, &osmask->sa)) {
	    case 0:
		advance = 4;
		if (i + 4 >= argc)
		    goto argfail;
		if (addrparse(argv[i + 2], &osmask->sa, NULL) != 0 ||
		    addrparse(argv[i + 3], &odst->sa, NULL) != 0 ||
		    addrparse(argv[i + 4], &odmask->sa, NULL) != 0) {
		    fprintf(stderr, "%s: Invalid address on -addr\n", argv[0]);
		    exit (1);
		}
		break;
	    case 1:
		advance = 2;
		if (i + 2 >= argc)
		    goto argfail;
		if (addrparse(argv[i + 2], &odst->sa, &odmask->sa) != 1) {
		    fprintf(stderr, "%s: Invalid address on -addr\n", argv[0]);
		    exit(1);
		}
		break;
	    default:
	        fprintf(stderr, "%s: Invalid address %s on -addr\n", argv[0],
		    argv[i + 1]);
		goto argfail;
	    }
	    if (osrc->sa.sa_family != odst->sa.sa_family) {
d1287 2
a1288 2
			"%s: Mixed address families specified in addr\n",
			argv[0]);
d1290 7
a1296 174
	    }

	    sad4.sadb_address_len = (sizeof(sad4) +
				     ROUNDUP(osrc->sa.sa_len)) / 8;
	    sad5.sadb_address_len = (sizeof(sad5) +
				     ROUNDUP(odst->sa.sa_len)) / 8;
	    sad6.sadb_address_len = (sizeof(sad6) +
				     ROUNDUP(osmask->sa.sa_len)) / 8;
	    sad7.sadb_address_len = (sizeof(sad7) +
				     ROUNDUP(odmask->sa.sa_len)) / 8;

	    i += advance;
	    continue;
	}

	if ((!strcmp(argv[i] + 1, "bypass") || !strcmp(argv[i] + 1, "permit"))
            && iscmd(mode, FLOW) && !deny &&
	    !ipsec && !bypass)
	{
	    /* Setup everything for a bypass flow */
	    bypass = 1;
	    sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_BYPASS;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "deny") && iscmd(mode, FLOW) && !ipsec &&
	    !deny && !bypass)
	{
	    /* Setup everything for a deny flow */
	    deny = 1;
	    sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_DENY;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "use") && iscmd(mode, FLOW) && !deny &&
	    !bypass && !ipsec)
	{
	    ipsec = 1;
	    sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_USE;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "acquire") && iscmd(mode, FLOW) && !deny &&
	    !bypass && !ipsec)
	{
	    ipsec = 1;
	    sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_ACQUIRE;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "require") && iscmd(mode, FLOW) && !deny &&
	    !bypass && !ipsec)
	{
	    ipsec = 1;
	    sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_REQUIRE;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "dontacq") && iscmd(mode, FLOW) && !deny &&
	    !bypass && !ipsec)
	{
	    ipsec = 1;
	    sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_DONTACQ;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "transport") &&
	    iscmd(mode, FLOW) && (i + 1 < argc))
	{
	    if (isalpha(argv[i + 1][0]))
	    {
		tp = getprotobyname(argv[i + 1]);
		if (tp == NULL)
		{
		    fprintf(stderr,
			    "%s: unknown protocol %s\n", argv[0], argv[i + 1]);
		    exit(1);
		}

		tproto = tp->p_proto;
		transportproto = argv[i + 1];
	    }
	    else
	    {
		tproto = atoi(argv[i + 1]);
		tp = getprotobynumber(tproto);
		if (tp == NULL)
		  transportproto = "UNKNOWN";
		else
		  transportproto = tp->p_name;
	    }

	    sprotocol.sadb_protocol_len = 1;
	    sprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
	    sprotocol.sadb_protocol_proto = tproto;
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "sport") &&
	    iscmd(mode, FLOW) && (i + 1 < argc))
	{
	    if (isalpha(argv[i + 1][0]))
	    {
		svp = getservbyname(argv[i + 1], transportproto);
		if (svp == NULL)
		{
		    fprintf(stderr,
			    "%s: unknown service port %s for protocol %s\n",
			    argv[0], argv[i + 1], transportproto);
		    exit(1);
		}

		sport = svp->s_port;
	    }
	    else
	      sport = htons(atoi(argv[i+1]));

	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "dport") &&
	    iscmd(mode, FLOW) && (i + 1 < argc))
	{
	    if (isalpha(argv[i + 1][0]))
	    {
		svp = getservbyname(argv[i + 1], transportproto);
		if (svp == NULL)
		{
		    fprintf(stderr,
			    "%s: unknown service port %s for protocol %s\n",
			    argv[0], argv[i + 1], transportproto);
		    exit(1);
		}
		dport = svp->s_port;
	    }
	    else
	      dport = htons(atoi(argv[i + 1]));

	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "dst") && (i + 1 < argc) && !bypass && !deny)
	{
	    sad2.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
#ifdef INET6
	    if (strchr(argv[i + 1], ':'))
	    {
		sad2.sadb_address_len = (sizeof(sad2) +
					 ROUNDUP(sizeof(struct sockaddr_in6)))
					 / 8;
		dst->sin6.sin6_family = AF_INET6;
		dst->sin6.sin6_len = sizeof(struct sockaddr_in6);
		dstset = inet_pton(AF_INET6, argv[i + 1],
				   &dst->sin6.sin6_addr) != -1 ? 1 : 0;
	    }
	    else
#endif /* INET6 */
	    {
		sad2.sadb_address_len = (sizeof(sad2) +
					 sizeof(struct sockaddr_in)) / 8;
		dst->sin.sin_family = AF_INET;
		dst->sin.sin_len = sizeof(struct sockaddr_in);
		dstset = inet_pton(AF_INET, argv[i + 1],
				   &dst->sin.sin_addr) != -1 ? 1 : 0;
	    }

	    if (dstset == 0)
	    {
		fprintf(stderr,
			"%s: Warning: destination address %s is not valid\n",
			argv[0], argv[i + 1]);
a1297 134
	    }
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "proto2") && 
	    iscmd(mode, GRP_SPI) && (i + 1 < argc))
	{
	    if (isalpha(argv[i + 1][0]))
	    {
		if (!strcasecmp(argv[i + 1], "esp"))
		{
		    sprotocol.sadb_protocol_proto = sproto2 = SADB_SATYPE_ESP;
		    proto2 = IPPROTO_ESP;
		}
		else
		  if (!strcasecmp(argv[i + 1], "ah"))
		  {
		      sprotocol.sadb_protocol_proto = sproto2 = SADB_SATYPE_AH;
		      proto2 = IPPROTO_AH;
		  }
		  else
		    if (!strcasecmp(argv[i + 1], "ip4"))
		    {
			sprotocol.sadb_protocol_proto = sproto2 = SADB_X_SATYPE_IPIP;
			proto2 = IPPROTO_IPIP;
		    }
		    else
		      if (!strcasecmp(argv[i + 1], "ipcomp"))
		      {
			  sprotocol.sadb_protocol_proto = sproto2 = SADB_X_SATYPE_IPCOMP;
		      }
		      else
		      {
			  fprintf(stderr,
				  "%s: unknown security protocol2 type %s\n",
				  argv[0], argv[i+1]);
			  exit(1);
		      }
	    }
	    else
	    {
		proto2 = atoi(argv[i + 1]);

		if (proto2 != IPPROTO_ESP && proto2 != IPPROTO_AH &&
		    proto2 != IPPROTO_IPIP && proto2 != IPPROTO_IPCOMP)
		{
		    fprintf(stderr,
			    "%s: unknown security protocol2 %d\n",
			    argv[0], proto2);
		    exit(1);
		}

		if (proto2 == IPPROTO_ESP)
		  sprotocol.sadb_protocol_proto = sproto2 = SADB_SATYPE_ESP;
		else
		  if (proto2 == IPPROTO_AH)
		    sprotocol.sadb_protocol_proto = sproto2 = SADB_SATYPE_AH;
		  else
		    if (proto2 == IPPROTO_IPIP)
		      sprotocol.sadb_protocol_proto = sproto2 = SADB_X_SATYPE_IPIP;
		    else
		      if (proto2 == IPPROTO_IPCOMP)
			sprotocol.sadb_protocol_proto = sproto2 = SADB_X_SATYPE_IPCOMP;
	    }

	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "proto") && (i + 1 < argc) &&
	    ((iscmd(mode, FLOW) && !bypass && !deny) || iscmd(mode, DEL_SPI) ||
	     iscmd(mode, GRP_SPI)))
	{
	    if (isalpha(argv[i + 1][0]))
	    {
		if (!strcasecmp(argv[i + 1], "esp"))
		{
		    smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		    proto = IPPROTO_ESP;
		}
		else
		  if (!strcasecmp(argv[i + 1], "ah"))
		  {
		      smsg.sadb_msg_satype = SADB_SATYPE_AH;
		      proto = IPPROTO_AH;
		  }
		  else
		    if (!strcasecmp(argv[i + 1], "ip4"))
		    {
			smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
			proto = IPPROTO_IPIP;
		    }
		    else
		      if (!strcasecmp(argv[i + 1], "ipcomp"))
		      {
			  smsg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
			  proto = IPPROTO_IPCOMP;
		      }
		      else
		      {
			  fprintf(stderr,
				  "%s: unknown security protocol type %s\n",
				  argv[0], argv[i + 1]);
			  exit(1);
		      }
	    }
	    else
	    {
		proto = atoi(argv[i + 1]);
		if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
		    proto != IPPROTO_IPIP && proto != IPPROTO_IPCOMP)
		{
		    fprintf(stderr,
			    "%s: unknown security protocol %d\n",
			    argv[0], proto);
		    exit(1);
		}

		if (proto == IPPROTO_ESP)
		  smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		else
		  if (proto == IPPROTO_AH)
		    smsg.sadb_msg_satype = SADB_SATYPE_AH;
		  else
		    if (proto == IPPROTO_IPIP)
		      smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
		    else
		      if (proto == IPPROTO_IPCOMP)
			smsg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
	    }
	    
	    i++;
	    continue;
d1299 14
a1312 264
	
	/* No match */
argfail:
	fprintf(stderr, "%s: Unknown, invalid, or duplicated option: %s\n",
		argv[0], argv[i]);
	exit(1);
    }
    
    /* Sanity checks */
    if ((mode & (ESP_NEW | ESP_OLD)) && enc == 0 && auth == 0)
    {
	fprintf(stderr, "%s: no encryption or authentication algorithm "
		"specified\n",  argv[0]);
	exit(1);
    }

    if (iscmd(mode, GRP_SPI) && spi2 == SPI_LOCAL_USE)
    {
	fprintf(stderr, "%s: no SPI2 specified\n", argv[0]);
	exit(1);
    }

    if ((mode & (AH_NEW | AH_OLD)) && auth == 0)
    {
	fprintf(stderr, "%s: no authentication algorithm specified\n", 
		argv[0]);
	exit(1);
    }

    if (iscmd(mode, IPCOMP) && comp == 0)
    {
	fprintf(stderr, "%s: no compression algorithm specified\n",
		argv[0]);
	exit(1);
    }

    if ((srcid != NULL) && (sid1.sadb_ident_type == 0))
    {
	fprintf(stderr, "%s: srcid_type not specified\n", argv[0]);
	exit(1);
    }

    if ((dstid != NULL) && (sid2.sadb_ident_type == 0))
    {
	fprintf(stderr, "%s: dstid_type not specified\n", argv[0]);
	exit(1);
    }

    if ((srcid == NULL) && (sid1.sadb_ident_type != 0))
    {
	fprintf(stderr, "%s: srcid_type specified, but no srcid given\n",
		argv[0]);
	exit(1);
    }

    if ((dstid == NULL) && (sid2.sadb_ident_type != 0))
    {
	fprintf(stderr, "%s: dstid_type specified, but no dstid given\n",
		argv[0]);
	exit(1);
    }

    if (((mode & (ESP_NEW | ESP_OLD)) && enc && keyp == NULL) ||
        ((mode & (AH_NEW | AH_OLD)) && authp == NULL))
    {
	fprintf(stderr, "%s: no key material specified\n", argv[0]);
	exit(1);
    }

    if ((mode & ESP_NEW) && auth && authp == NULL)
    {
	fprintf(stderr, "%s: no auth key material specified\n", argv[0]);
	exit(1);
    }

    if (spi == SPI_LOCAL_USE && !iscmd(mode, FLUSH) && !iscmd(mode, FLOW)
	&& !iscmd(mode, IPCOMP))
    {
	fprintf(stderr, "%s: no SPI specified\n", argv[0]);
	exit(1);
    }

    if (iscmd(mode, IPCOMP) && cpi == SPI_LOCAL_USE)
    {
	fprintf(stderr, "%s: no CPI specified\n", argv[0]);
	exit(1);
    }

    if ((isencauth(mode) || iscmd(mode, ENC_IP)) && !srcset)
    {
	fprintf(stderr, "%s: no source address specified\n", argv[0]);
	exit(1);
    } 

    if (!dstset && !iscmd(mode, FLUSH) && !iscmd(mode, FLOW))
    {
	fprintf(stderr, "%s: no destination address for the SA specified\n", 
		argv[0]);
	exit(1);
    } 

    if (iscmd(mode, FLOW) && (sprotocol.sadb_protocol_proto == 0) &&
	(odst->sin.sin_port || osrc->sin.sin_port))
    {
	fprintf(stderr, "%s: no transport protocol supplied with source/destination ports\n", argv[0]);
	exit(1);
    }

    if (iscmd(mode, GRP_SPI) && !dst2set)
    {
	fprintf(stderr, "%s: no destination address2 specified\n", argv[0]);
	exit(1);
    }
    
    if ((klen > 2 * 8100) || (alen > 2 * 8100))
    {
	fprintf(stderr, "%s: key too long\n", argv[0]);
	exit(1);
    }

    if (iscmd(mode, FLOW) && proto == IPPROTO_IPCOMP)
    {
	sprotocol2.sadb_protocol_proto = SADB_X_FLOW_TYPE_USE;
    }

    if (keyp != NULL)
    {
	for (i = 0; i < klen; i++)
	  realkey[i] = x2i(keyp + 2 * i);
    }
    
    if (authp != NULL)
    {
	for (i = 0; i < alen; i++)
	  realakey[i] = x2i(authp + 2 * i);
    }
    
    /* message header */
    iov[cnt].iov_base = &smsg;
    iov[cnt++].iov_len = sizeof(smsg);

    if (isencauth(mode))
    {
	/* SA header */
	iov[cnt].iov_base = &sa;
	iov[cnt++].iov_len = sizeof(sa);
	smsg.sadb_msg_len += sa.sadb_sa_len;

	/* Destination address header */
	iov[cnt].iov_base = &sad2;
	iov[cnt++].iov_len = sizeof(sad2);
	/* Destination address */
	iov[cnt].iov_base = dst;
	iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
	smsg.sadb_msg_len += sad2.sadb_address_len;

	if (srcid)
	{
	    iov[cnt].iov_base = &sid1;
	    iov[cnt++].iov_len = sizeof(sid1);
	    /* SRC identity */
	    iov[cnt].iov_base = srcid;
	    iov[cnt++].iov_len = ROUNDUP(strlen(srcid) + 1);
	    smsg.sadb_msg_len += sid1.sadb_ident_len;
	}

	if (dstid)
	{
	    iov[cnt].iov_base = &sid2;
	    iov[cnt++].iov_len = sizeof(sid2);
	    /* DST identity */
	    iov[cnt].iov_base = dstid;
	    iov[cnt++].iov_len = ROUNDUP(strlen(dstid) + 1);
	    smsg.sadb_msg_len += sid2.sadb_ident_len;
	}

	if (sad1.sadb_address_exttype)
	{
	    /* Source address header */
	    iov[cnt].iov_base = &sad1;
	    iov[cnt++].iov_len = sizeof(sad1);
	    /* Source address */
	    iov[cnt].iov_base = src;
	    iov[cnt++].iov_len = ROUNDUP(src->sa.sa_len);
	    smsg.sadb_msg_len += sad1.sadb_address_len;
	}

	if (proxy->sa.sa_len)
	{
	    /* Proxy address header */
	    iov[cnt].iov_base = &sad3;
	    iov[cnt++].iov_len = sizeof(sad3);
	    /* Proxy address */
	    iov[cnt].iov_base = proxy;
	    iov[cnt++].iov_len = ROUNDUP(proxy->sa.sa_len);
	    smsg.sadb_msg_len += sad3.sadb_address_len;
	}

	if (keyp)
	{
	    /* Key header */
	    iov[cnt].iov_base = &skey1;
	    iov[cnt++].iov_len = sizeof(skey1);
	    /* Key */
	    iov[cnt].iov_base = realkey;
	    iov[cnt++].iov_len = ((klen + 7) / 8) * 8;
	    skey1.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
	    skey1.sadb_key_len = (sizeof(skey1) + ((klen + 7) / 8) * 8) / 8;
	    skey1.sadb_key_bits = 8 * klen;
	    smsg.sadb_msg_len += skey1.sadb_key_len;
	}

	if (authp)
	{
	    /* Auth key header */
	    iov[cnt].iov_base = &skey2;
	    iov[cnt++].iov_len = sizeof(skey2);
	    /* Auth key */
	    iov[cnt].iov_base = realakey;
	    iov[cnt++].iov_len = ((alen + 7) / 8) * 8;
	    skey2.sadb_key_exttype = SADB_EXT_KEY_AUTH;
	    skey2.sadb_key_len = (sizeof(skey2) + ((alen + 7) / 8) * 8) / 8;
	    skey2.sadb_key_bits = 8 * alen;
	    smsg.sadb_msg_len += skey2.sadb_key_len;
	}
    }
    else
    {
	switch(mode & CMD_MASK)
	{
	    case GRP_SPI:
		/* SA header */
		iov[cnt].iov_base = &sa;
		iov[cnt++].iov_len = sizeof(sa);
		smsg.sadb_msg_len += sa.sadb_sa_len;

		/* Destination address header */
		iov[cnt].iov_base = &sad2;
		iov[cnt++].iov_len = sizeof(sad2);
		/* Destination address */
		iov[cnt].iov_base = dst;
		iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
		smsg.sadb_msg_len += sad2.sadb_address_len;

		/* SA header */
		iov[cnt].iov_base = &sa2;
		iov[cnt++].iov_len = sizeof(sa2);
		smsg.sadb_msg_len += sa2.sadb_sa_len;

		/* Destination2 address header */
		iov[cnt].iov_base = &sad8;
		iov[cnt++].iov_len = sizeof(sad8);
		/* Destination2 address */
		iov[cnt].iov_base = dst2;
		iov[cnt++].iov_len = ROUNDUP(dst2->sa.sa_len);
		smsg.sadb_msg_len += sad8.sadb_address_len;

                sprotocol.sadb_protocol_proto = sproto2;

		/* Protocol2 */
		iov[cnt].iov_base = &sprotocol;
		iov[cnt++].iov_len = sizeof(sprotocol);
		smsg.sadb_msg_len += sprotocol.sadb_protocol_len;
		break;
d1314 1
a1314 1
	    case DEL_SPI:
a1326 1
		break;
d1328 57
a1384 23
	    case ENC_IP:
		/* SA header */
		iov[cnt].iov_base = &sa;
		iov[cnt++].iov_len = sizeof(sa);
		smsg.sadb_msg_len += sa.sadb_sa_len;

		/* Destination address header */
		iov[cnt].iov_base = &sad2;
		iov[cnt++].iov_len = sizeof(sad2);
		/* Destination address */
		iov[cnt].iov_base = dst;
		iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
		smsg.sadb_msg_len += sad2.sadb_address_len;

		if (sad1.sadb_address_exttype)
		{
		    /* Source address header */
		    iov[cnt].iov_base = &sad1;
		    iov[cnt++].iov_len = sizeof(sad1);
		    /* Source address */
		    iov[cnt].iov_base = src;
		    iov[cnt++].iov_len = ROUNDUP(src->sa.sa_len);
		    smsg.sadb_msg_len += sad1.sadb_address_len;
d1386 140
a1525 74
		break;

	     case IPCOMP:
		 /* SA header */
		 iov[cnt].iov_base = &sa;
		 iov[cnt++].iov_len = sizeof(sa);
		 smsg.sadb_msg_len += sa.sadb_sa_len;

		 /* Destination address header */
		 iov[cnt].iov_base = &sad2;
		 iov[cnt++].iov_len = sizeof(sad2);
		 /* Destination address */
		 iov[cnt].iov_base = dst;
		 iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
		 smsg.sadb_msg_len += sad2.sadb_address_len;

		 if (sad1.sadb_address_exttype)
		 {
		     /* Source address header */
		     iov[cnt].iov_base = &sad1;
		     iov[cnt++].iov_len = sizeof(sad1);
		     /* Source address */
		     iov[cnt].iov_base = src;
		     iov[cnt++].iov_len = ROUNDUP(src->sa.sa_len);
		     smsg.sadb_msg_len += sad1.sadb_address_len;
		 }
		 break;

	     case FLOW:
		 if ((smsg.sadb_msg_type != SADB_X_DELFLOW) &&
                     (sad2.sadb_address_exttype))
		 {
		     /* Destination address header */
		     iov[cnt].iov_base = &sad2;
		     iov[cnt++].iov_len = sizeof(sad2);
		     /* Destination address */
		     iov[cnt].iov_base = dst;
		     iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
		     smsg.sadb_msg_len += sad2.sadb_address_len;
		 }

	         if ((sad1.sadb_address_exttype) &&
                     (smsg.sadb_msg_type != SADB_X_DELFLOW))
	         {
	             /* Source address header */
	             iov[cnt].iov_base = &sad1;
	             iov[cnt++].iov_len = sizeof(sad1);
	             /* Source address */
	             iov[cnt].iov_base = src;
	             iov[cnt++].iov_len = ROUNDUP(src->sa.sa_len);
	             smsg.sadb_msg_len += sad1.sadb_address_len;
	         }

		 if (sprotocol.sadb_protocol_len)
		 {
		     /* Transport protocol */
		     iov[cnt].iov_base = &sprotocol;
		     iov[cnt++].iov_len = sizeof(sprotocol);
		     smsg.sadb_msg_len += sprotocol.sadb_protocol_len;
		 }

		 /* Flow type */
		 iov[cnt].iov_base = &sprotocol2;
		 iov[cnt++].iov_len = sizeof(sprotocol2);
		 smsg.sadb_msg_len += sprotocol2.sadb_protocol_len;

		 /* Flow source address header */
                 if ((sport != -1) && (sport != 0))
                 {
                     if (osrc->sa.sa_family == AF_INET)
                     {
                         osrc->sin.sin_port = sport;
                         osmask->sin.sin_port = 0xffff;
                     }
d1527 22
a1548 26
                     else if (osrc->sa.sa_family == AF_INET6)
                     {
                         osrc->sin6.sin6_port = sport;
                         osmask->sin6.sin6_port = 0xffff;
                     }
#endif /* INET6 */
                 }

		 iov[cnt].iov_base = &sad4;
		 iov[cnt++].iov_len = sizeof(sad4);
		 /* Flow source address */
		 iov[cnt].iov_base = osrc;
		 iov[cnt++].iov_len = ROUNDUP(osrc->sa.sa_len);
		 smsg.sadb_msg_len += sad4.sadb_address_len;

		 /* Flow destination address header */
		 iov[cnt].iov_base = &sad5;
		 iov[cnt++].iov_len = sizeof(sad5);
		 /* Flow destination address */
                 if ((dport != -1) && (dport != 0))
                 {
                     if (odst->sa.sa_family == AF_INET)
                     {
                         odst->sin.sin_port = dport;
                         odmask->sin.sin_port = 0xffff;
                     }
d1550 51
a1600 56
                     else if (odst->sa.sa_family == AF_INET6)
                     {
                         odst->sin6.sin6_port = dport;
                         odmask->sin6.sin6_port = 0xffff;
                     }
#endif /* INET6 */
                 }

		 iov[cnt].iov_base = odst;
		 iov[cnt++].iov_len = ROUNDUP(odst->sa.sa_len);
		 smsg.sadb_msg_len += sad5.sadb_address_len;

		 /* Flow source address mask header */
		 iov[cnt].iov_base = &sad6;
		 iov[cnt++].iov_len = sizeof(sad6);
		 /* Flow source address mask */
		 iov[cnt].iov_base = osmask;
		 iov[cnt++].iov_len = ROUNDUP(osmask->sa.sa_len);
		 smsg.sadb_msg_len += sad6.sadb_address_len;

		 /* Flow destination address mask header */
		 iov[cnt].iov_base = &sad7;
		 iov[cnt++].iov_len = sizeof(sad7);
		 /* Flow destination address mask */
		 iov[cnt].iov_base = odmask;
		 iov[cnt++].iov_len = ROUNDUP(odmask->sa.sa_len);
		 smsg.sadb_msg_len += sad7.sadb_address_len;

		 if ((srcid) &&
                     (smsg.sadb_msg_type != SADB_X_DELFLOW))
		 {
		     iov[cnt].iov_base = &sid1;
		     iov[cnt++].iov_len = sizeof(sid1);
		     /* SRC identity */
		     iov[cnt].iov_base = srcid;
		     iov[cnt++].iov_len = ROUNDUP(strlen(srcid) + 1);
		     smsg.sadb_msg_len += sid1.sadb_ident_len;
		 }

		 if ((dstid) &&
                     (smsg.sadb_msg_type != SADB_X_DELFLOW))
		 {
		     iov[cnt].iov_base = &sid2;
		     iov[cnt++].iov_len = sizeof(sid2);
		     /* DST identity */
		     iov[cnt].iov_base = dstid;
		     iov[cnt++].iov_len = ROUNDUP(strlen(dstid) + 1);
		     smsg.sadb_msg_len += sid2.sadb_ident_len;
		 }

		 break;

	    case FLUSH:
		/* No more work needed */
		 break;
	  
a1601 1
    }
d1603 2
a1604 2
    xf_set(iov, cnt, smsg.sadb_msg_len * 8);
    exit (0);
@


1.61
log
@Fix unused/uninitialized variables.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.60 2001/07/05 08:38:36 jjbg Exp $ */
d44 2
d54 3
d58 1
a59 1

a66 5
#include <sys/uio.h>
#include <sys/stat.h>
#include <net/pfkeyv2.h>
#include <netinet/ip_ipsp.h>
#include <netinet/in.h>
@


1.60
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.59 2001/06/26 21:10:28 itojun Exp $ */
d119 2
a120 4
    u_long prefixlen;
    char *p, *sp, *ep;
    char c;
    int ret = 0;
a672 1
	    unsigned char *pptr;
@


1.59
log
@configure sa_family on mask too.  to preserve older practice
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.58 2001/06/26 20:44:22 itojun Exp $ */
d74 1
d83 1
d107 1
d277 1
a277 1
	    "\tCommands: new esp, old esp, new ah, old ah, group, delspi, ip4,\n"
d282 1
d290 1
d309 1
a309 1
	    "\t  -[ah|esp|ip4]\t\t\tflush a particular protocol\n"
d323 1
d326 1
d528 15
a542 7
		else
		{
		    fprintf(stderr, "%s: unknown command: %s\n", argv[0],
			    argv[1]);
		    usage();
		    exit(1);
		}
d583 18
d770 8
a777 5
		{
		    fprintf(stderr, "%s: invalid SA type %s\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
d821 15
d1355 11
a1365 6
		    {
			fprintf(stderr,
				"%s: unknown security protocol2 type %s\n",
				argv[0], argv[i+1]);
			exit(1);
		    }
d1372 1
a1372 1
		    proto2 != IPPROTO_IPIP)
d1388 3
d1421 12
a1432 6
		    {
			fprintf(stderr,
				"%s: unknown security protocol type %s\n",
				argv[0], argv[i + 1]);
				exit(1);
		    }
d1438 1
a1438 1
		    proto != IPPROTO_IPIP)
d1454 3
d1491 7
d1537 2
a1538 1
    if (spi == SPI_LOCAL_USE && !iscmd(mode, FLUSH) && !iscmd(mode, FLOW))
d1544 6
d1582 5
d1767 26
@


1.58
log
@allow -addr src/prefixlen dst/prefixlen.  discussed with angelos.
XXX usage() needs to be made more cute
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.57 2001/06/25 05:16:10 angelos Exp $ */
d176 1
@


1.57
log
@Copyright update.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.56 2001/06/08 19:39:02 angelos Exp $ */
d66 1
d109 85
d292 1
a292 1
	    "\t  -addr <ip> <net> <ip> <net>\tsubnets for flow\n"
d1060 1
a1060 1
	    (i + 4 < argc))
d1062 2
d1069 27
a1095 8
#ifdef INET6
	    if ((strchr(argv[i + 1], ':') &&
		 (!strchr(argv[i + 2], ':') || !strchr(argv[i + 3], ':') ||
		  !strchr(argv[i + 4], ':'))) ||
		(!strchr(argv[i + 1], ':') &&
		 (strchr(argv[i + 2], ':') || strchr(argv[i + 3], ':') ||
		  strchr(argv[i + 4], ':'))))
	    {
d1102 8
a1109 21
	    if (strchr(argv[i + 1], ':'))
	    {
		sad4.sadb_address_len = (sizeof(sad4) +
					 ROUNDUP(sizeof(struct sockaddr_in6)))
					 / 8;
		sad5.sadb_address_len = (sizeof(sad5) +
					 ROUNDUP(sizeof(struct sockaddr_in6)))
					 / 8;
		sad6.sadb_address_len = (sizeof(sad6) +
					 ROUNDUP(sizeof(struct sockaddr_in6)))
					 / 8;
		sad7.sadb_address_len = (sizeof(sad7) +
					 ROUNDUP(sizeof(struct sockaddr_in6)))
					 / 8;

		osrc->sin6.sin6_family = odst->sin6.sin6_family = AF_INET6;
		osmask->sin6.sin6_family = odmask->sin6.sin6_family = AF_INET6;
		osrc->sin6.sin6_len = odst->sin6.sin6_len =
				   sizeof(struct sockaddr_in6);
		osmask->sin6.sin6_len = sizeof(struct sockaddr_in6);
		odmask->sin6.sin6_len = sizeof(struct sockaddr_in6);
d1111 1
a1111 81
		if (!inet_pton(AF_INET6, argv[i + 1], &osrc->sin6.sin6_addr))
		{
		    fprintf(stderr, "%s: source address %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		i++;
		if (!inet_pton(AF_INET6, argv[i + 1], &osmask->sin6.sin6_addr))
		{
		    fprintf(stderr, "%s: source netmask %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		i++;
		if (!inet_pton(AF_INET6, argv[i + 1], &odst->sin6.sin6_addr))
		{
		    fprintf(stderr,
			    "%s: destination address %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		i++;
		if (!inet_pton(AF_INET6, argv[i + 1], &odmask->sin6.sin6_addr))
		{
		    fprintf(stderr,
			    "%s: destination netmask %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		i++;
	    }
	    else
#endif /* INET6 */
	    {
		sad4.sadb_address_len = (sizeof(sad4) +
					 sizeof(struct sockaddr_in)) / 8;
		sad5.sadb_address_len = (sizeof(sad5) +
					 sizeof(struct sockaddr_in)) / 8;
		sad6.sadb_address_len = (sizeof(sad6) +
					 sizeof(struct sockaddr_in)) / 8;
		sad7.sadb_address_len = (sizeof(sad7) +
					 sizeof(struct sockaddr_in)) / 8;

		osrc->sin.sin_family = odst->sin.sin_family = AF_INET;
		osmask->sin.sin_family = odmask->sin.sin_family = AF_INET;
		osrc->sin.sin_len = odst->sin.sin_len =
				   sizeof(struct sockaddr_in);
		osmask->sin.sin_len = sizeof(struct sockaddr_in);
		odmask->sin.sin_len = sizeof(struct sockaddr_in);

		if (!inet_pton(AF_INET, argv[i + 1], &osrc->sin.sin_addr))
		{
		    fprintf(stderr, "%s: source address %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		i++;
		if (!inet_pton(AF_INET, argv[i + 1], &osmask->sin.sin_addr))
		{
		    fprintf(stderr, "%s: source netmask %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		i++;
		if (!inet_pton(AF_INET, argv[i + 1], &odst->sin.sin_addr))
		{
		    fprintf(stderr,
			    "%s: destination address %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		i++;
		if (!inet_pton(AF_INET, argv[i + 1], &odmask->sin.sin_addr))
		{
		    fprintf(stderr,
			    "%s: destination netmask %s is not valid\n",
			    argv[0], argv[i + 1]);
		    exit(1);
		}
		i++;
	    }
d1395 1
@


1.56
log
@Set SADB_X_POLICYFLAGS_POLICY for flows we add/delete.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.55 2001/06/05 00:17:47 niklas Exp $ */
d20 3
a22 2
 *	
 * Permission to use, copy, and modify this software without fee
@


1.55
log
@Make our pfkeyv2.h more RFC2367 compliant.  Also fix some backwards
compatibility problems in isakmpd, at least 2.8 stable can compile current
isakmpd now.  angelos@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.54 2001/05/30 16:44:41 angelos Exp $ */
d336 1
a336 1

@


1.54
log
@MBOX->USERFQDN
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.53 2001/04/19 20:12:45 niklas Exp $ */
d1106 1
a1106 1
	    sprotocol2.sadb_protocol_proto = FLOW_X_TYPE_BYPASS;
d1115 1
a1115 1
	    sprotocol2.sadb_protocol_proto = FLOW_X_TYPE_DENY;
d1123 1
a1123 1
	    sprotocol2.sadb_protocol_proto = FLOW_X_TYPE_USE;
d1131 1
a1131 1
	    sprotocol2.sadb_protocol_proto = FLOW_X_TYPE_ACQUIRE;
d1139 1
a1139 1
	    sprotocol2.sadb_protocol_proto = FLOW_X_TYPE_REQUIRE;
d1147 1
a1147 1
	    sprotocol2.sadb_protocol_proto = FLOW_X_TYPE_DONTACQ;
@


1.53
log
@PF_KEY identity extensions are NUL-terminated.  Do not forget neither to
allocate for the NUL, nor to actually transfer it.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.52 2001/03/28 19:15:43 angelos Exp $ */
d930 1
a930 1
		  sid1.sadb_ident_type = SADB_IDENTTYPE_MBOX;
d960 1
a960 1
		  sid2.sadb_ident_type = SADB_IDENTTYPE_MBOX;
@


1.52
log
@Fix range checking on SPIs (Jean-Jacques.Bernard@@hsc.fr)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.51 2001/03/22 03:34:18 angelos Exp $ */
d105 1
a105 1
#define ROUNDUP(x) (x % 8 ? (x + 8) - (x % 8) : x)
d877 1
a877 1
	    srcid = calloc(ROUNDUP(strlen(argv[i + 1])), sizeof(char));
d884 1
a884 1
	    sid1.sadb_ident_len += ROUNDUP(strlen(srcid)) / sizeof(u_int64_t);
d900 1
a900 1
	    dstid = calloc(ROUNDUP(strlen(argv[i + 1])), sizeof(char));
d907 1
a907 1
	    sid2.sadb_ident_len += ROUNDUP(strlen(dstid)) / sizeof(u_int64_t);
d1520 1
a1520 1
	    iov[cnt++].iov_len = ROUNDUP(strlen(srcid));
d1530 1
a1530 1
	    iov[cnt++].iov_len = ROUNDUP(strlen(dstid));
d1773 1
a1773 1
		     iov[cnt++].iov_len = ROUNDUP(strlen(srcid));
d1784 1
a1784 1
		     iov[cnt++].iov_len = ROUNDUP(strlen(dstid));
@


1.51
log
@Allow srcid/dstid for manually-set SAs as well (mostly for debug
purposes).
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.50 2001/03/08 21:41:42 deraadt Exp $ */
d669 1
a669 1
	    spi = htonl(strtoul(argv[i + 1], NULL, 16));
d676 1
a676 1
	    sa.sadb_sa_spi = spi;
d684 1
a684 1
	    spi2 = htonl(strtoul(argv[i + 1], NULL, 16));
d692 1
a692 1
	    sa2.sadb_sa_spi = spi2;
@


1.50
log
@whack exit(-#)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.49 2000/11/17 04:10:21 angelos Exp $ */
d866 2
a867 1
	if (!strcmp(argv[i] + 1, "srcid") && iscmd(mode, FLOW) &&
d889 2
a890 1
	if (!strcmp(argv[i] + 1, "dstid") && iscmd(mode, FLOW) &&
d912 2
a913 1
	if (!strcmp(argv[i] + 1, "srcid_type") && iscmd(mode, FLOW) &&
d942 2
a943 1
	if (!strcmp(argv[i] + 1, "dstid_type") && iscmd(mode, FLOW) &&
d1513 20
@


1.49
log
@*HMAC96->*HMAC
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.48 2000/10/25 19:08:57 jason Exp $ */
d157 1
a157 1
	exit(-1);
@


1.48
log
@typo; deraadt ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.47 2000/10/18 00:42:30 angelos Exp $ */
d98 2
a99 2
    {"md5", SADB_AALG_MD5HMAC96,  XF_AUTH|AH_NEW|ESP_NEW},
    {"sha1", SADB_AALG_SHA1HMAC96,XF_AUTH|AH_NEW|ESP_NEW},
d102 1
a102 1
    {"rmd160", SADB_X_AALG_RIPEMD160HMAC96, XF_AUTH|AH_NEW|ESP_NEW},
@


1.47
log
@Destination address is not needed for flows.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.46 2000/10/16 23:00:40 niklas Exp $ */
d660 1
a660 1
            fprintf(stderr, "%s: use of flag \"-spi\" is deprecated with"
@


1.46
log
@getserv* already returns ports in network byteorder
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.45 2000/10/09 22:21:41 angelos Exp $ */
d1453 1
a1453 4
    if (!dstset && !iscmd(mode, FLUSH) &&
	(!iscmd(mode, FLOW) || (iscmd(mode, FLOW) &&
			        (smsg.sadb_msg_type != SADB_X_DELFLOW) &&
                                 !deny && !bypass && !ipsec)))
@


1.45
log
@AES.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.44 2000/09/29 19:06:53 angelos Exp $ */
d1194 1
a1194 1
		sport = htons(svp->s_port);
d1216 1
a1216 1
		dport = htons(svp->s_port);
@


1.44
log
@Update for no -spi use with flow
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.43 2000/09/21 02:38:20 angelos Exp $ */
d94 1
@


1.43
log
@Send correct lengths for srcid/dstid.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.42 2000/09/21 01:34:19 angelos Exp $ */
d657 8
a1654 8
                 if (sa.sadb_sa_spi != 0)
                 {
		     /* SA header */
		     iov[cnt].iov_base = &sa;
		     iov[cnt++].iov_len = sizeof(sa);
		     smsg.sadb_msg_len += sa.sadb_sa_len;
                 }

d1744 2
a1745 1
		 if (srcid)
d1755 2
a1756 1
		 if (dstid)
@


1.42
log
@Allocate memory for srcid/dstid.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.41 2000/09/20 21:28:23 angelos Exp $ */
d326 1
a326 1
    sid1.sadb_ident_len = 1;
d329 1
a329 1
    sid2.sadb_ident_len = 1;
a1696 20
		 if (srcid)
		 {
		     iov[cnt].iov_base = &sid1;
		     iov[cnt++].iov_len = sizeof(sid1);
		     /* SRC identity */
		     iov[cnt].iov_base = srcid;
		     iov[cnt++].iov_len = ROUNDUP(strlen(srcid));
		     smsg.sadb_msg_len += sid1.sadb_ident_len;
		 }

		 if (dstid)
		 {
		     iov[cnt].iov_base = &sid2;
		     iov[cnt++].iov_len = sizeof(sid2);
		     /* DST identity */
		     iov[cnt].iov_base = dstid;
		     iov[cnt++].iov_len = ROUNDUP(strlen(dstid));
		     smsg.sadb_msg_len += sid2.sadb_ident_len;
		 }

d1743 21
@


1.41
log
@srcid/dstid/srcid_type/dstid_type flags for flows.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.40 2000/09/19 08:38:41 angelos Exp $ */
d867 7
a873 1
	    srcid = argv[i + 1];
d889 7
a895 1
	    dstid = argv[i + 1];
@


1.40
log
@Re-add support for SA bundles.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.39 2000/09/19 03:18:11 angelos Exp $ */
d216 4
d237 1
d251 1
d256 1
a256 1
    struct iovec iov[20];
d288 2
d326 6
d857 90
d1381 26
d1684 20
@


1.39
log
@Update to use the new framework.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.38 2000/05/02 21:50:30 ho Exp $ */
d76 1
d111 1
a111 1
    
d216 1
d224 1
a224 1
    int proto = IPPROTO_ESP, proto2 = IPPROTO_AH;
d226 1
a226 1
    u_int32_t spi = SPI_LOCAL_USE;
d237 1
a237 1
    struct sadb_sa sa;
d266 1
d313 5
d322 3
d386 1
a386 1
	  if (!strcmp(argv[1], "flow"))
d388 1
a388 2
	      /* It may not be ADDFLOW, but never mind that for now */
	      smsg.sadb_msg_type = SADB_X_ADDFLOW;
d390 1
a390 1
	      mode = FLOW;
d394 1
a394 1
	    if (!strcmp(argv[1], "flush"))
d396 4
a399 3
		mode = FLUSH;
		smsg.sadb_msg_type = SADB_FLUSH;
		smsg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
d402 2
a403 2
	    else 
	      if (!strcmp(argv[1], "ip4"))
d405 3
a407 3
		  mode = ENC_IP;
		  smsg.sadb_msg_type = SADB_ADD;
		  smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
d410 15
a424 7
	      else
	      {
		  fprintf(stderr, "%s: unknown command: %s\n", argv[0],
			  argv[1]);
		  usage();
		  exit(1);
	      }
d658 54
d1136 57
d1194 2
a1195 1
	    ((iscmd(mode, FLOW) && !bypass && !deny) || iscmd(mode, DEL_SPI)))
d1264 6
d1318 6
d1416 35
@


1.38
log
@Keep track of those offsets in argv[].
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.37 2000/04/22 02:43:15 angelos Exp $ */
a75 1
#define GRP_SPI		0x40
a76 1
#define BINDSA		0x60
d185 1
a185 1
	    "\t\t  flow, bind, flush\n"
d193 1
d200 2
a201 2
	    "\t  -proto <val>\t\t\tsecurity protocol\n"
	    "\t  -chain\t\t\tSPI chain delete\n"
d205 10
a214 6
	    "\t  -bypass\t\t\tcreate/delete a bypass flow\n"
	    "\t  -sport\t\t\tsource port for flow\n"
	    "\t  -dport\t\t\tdestination port for flow\n"
	    "\t  -ingress\t\t\tflow is ingress access control entry\n"
	    "\t  -[ah|esp|ip4]\t\t\tto flush a particular protocol\n"
	    "\talso: dst2, spi2, proto2\n"
d222 3
a224 3
    int proto = IPPROTO_ESP, proto2 = IPPROTO_AH, ingress = 0;
    int dport = -1, sport = -1, tproto = -1, setmask = 0;
    u_int32_t spi = SPI_RESERVED_MIN, spi2 = SPI_RESERVED_MIN;
a235 1
    struct sadb_sa sa2;
d247 1
d252 3
a254 1
    
a263 1
    bzero(&sa2, sizeof(sa2));
d275 1
d310 3
a312 5
    /* Initialize */
    sa2.sadb_sa_exttype = SADB_X_EXT_SA2;
    sa2.sadb_sa_len = sizeof(sa2) / 8;
    sa2.sadb_sa_replay = 0;
    sa2.sadb_sa_state = SADB_SASTATE_MATURE;
d375 1
a375 1
	  if (!strcmp(argv[1], "group"))
d377 4
a380 2
	      smsg.sadb_msg_type = SADB_X_GRPSPIS;
	      mode = GRP_SPI;
d384 1
a384 1
	    if (!strcmp(argv[1], "bind"))
d386 3
a388 3
		smsg.sadb_msg_type = SADB_X_BINDSA;
		smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		mode = BINDSA;
d391 2
a392 2
	    else
	      if (!strcmp(argv[1], "flow"))
d394 3
a396 4
		  /* It may not be ADDFLOW, but never mind that for now */
		  smsg.sadb_msg_type = SADB_X_ADDFLOW;
		  smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		  mode = FLOW;
d400 6
a405 22
		if (!strcmp(argv[1], "flush"))
		{
		    mode = FLUSH;
		    smsg.sadb_msg_type = SADB_FLUSH;
		    smsg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
		    i++;
		}
		else 
		  if (!strcmp(argv[1], "ip4"))
		  {
		      mode = ENC_IP;
		      smsg.sadb_msg_type = SADB_ADD;
		      smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
		      i++;
		  }
		  else
		  {
		      fprintf(stderr, "%s: unknown command: %s\n", argv[0], 
			      argv[1]);
		      usage();
		      exit(1);
		  }
d595 1
d612 8
a619 11
		    if(!strcmp(argv[i] + 1, "ip4"))
		        smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
		    else
		      if(!strcmp(argv[i] + 1, "bypass"))
		        smsg.sadb_msg_satype = SADB_X_SATYPE_BYPASS;
		      else
		      {
			fprintf(stderr, "%s: invalid SA type %s\n", argv[0],
				argv[i + 1]);
			exit(1);
		      }
d624 2
a625 2
	if (!strcmp(argv[i] + 1, "spi") && spi == SPI_RESERVED_MIN &&
	    (i + 1 < argc) && !bypass)
a638 16
	if (!strcmp(argv[i] + 1, "spi2") && spi2 == SPI_RESERVED_MIN && 
	    (iscmd(mode, GRP_SPI) || iscmd(mode, BINDSA)) && (i + 1 < argc))
	{
	    spi2 = htonl(strtoul(argv[i + 1], NULL, 16));
	    if (spi2 == SPI_LOCAL_USE ||
		(spi2 >= SPI_RESERVED_MIN && spi2 <= SPI_RESERVED_MAX))
	    {
		fprintf(stderr, "%s: invalid spi2 %s\n", argv[0], argv[i + 1]);
		exit(1);
	    }

	    sa2.sadb_sa_spi = spi2;
	    i++;
	    continue;
	} 

d673 2
a674 1
	if (!strcmp(argv[i] + 1, "proxy") && (i + 1 < argc))
d717 12
d757 1
a757 2
	    fprintf(stderr,
		    "%s: Warning: option local has been deprecated\n",
a812 1
		setmask = 1;
a862 1
		setmask = 1;
d898 3
a900 1
	if (!strcmp(argv[i] + 1, "bypass") && iscmd(mode, FLOW))
d904 42
a945 11
	    sa.sadb_sa_spi = 0;
	    sprotocol.sadb_protocol_len = 1;
	    sprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
	    sprotocol.sadb_protocol_proto = 0;
	    smsg.sadb_msg_satype = SADB_X_SATYPE_BYPASS;
	    sad2.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	    sad2.sadb_address_len = (sizeof(sad2) +
				     sizeof(struct sockaddr_in)) / 8;
	    dst->sin.sin_family = AF_INET;
	    dst->sin.sin_len = sizeof(struct sockaddr_in);
	    dstset = inet_aton("0.0.0.0", &dst->sin.sin_addr) != -1 ? 1 : 0;
a1000 2
	    osrc->sin.sin_port = sport;
	    osmask->sin.sin_port = 0xffff;
a1004 7
	if (!strcmp(argv[i] + 1, "ingress") && iscmd(mode, FLOW))
	{
	    sa.sadb_sa_flags |= SADB_X_SAFLAGS_INGRESS_FLOW;
	    ingress = 1;
	    continue;
	}

a1022 2
	    odst->sin.sin_port = dport;
	    odmask->sin.sin_port = 0xffff;
d1027 1
a1027 1
	if (!strcmp(argv[i] + 1, "dst") && (i + 1 < argc) && !bypass)
a1062 37
	if (!strcmp(argv[i] + 1, "dst2") && 
	    (iscmd(mode, GRP_SPI) || iscmd(mode, BINDSA)) && (i + 1 < argc))
	{
	    sad8.sadb_address_exttype = SADB_X_EXT_DST2;
#ifdef INET6
	    if (strchr(argv[i + 1], ':'))
	    {
		sad8.sadb_address_len = (sizeof(sad8) +
					 ROUNDUP(sizeof(struct sockaddr_in6)))
					 / 8;
		dst2->sin6.sin6_family = AF_INET6;
		dst2->sin6.sin6_len = sizeof(struct sockaddr_in6);
		dst2set = inet_pton(AF_INET6, argv[i + 1],
				    &dst2->sin6.sin6_addr) != -1 ? 1 : 0;
	    }
	    else
#endif /* INET6 */
	    {
		sad8.sadb_address_len = (sizeof(sad8) +
					 sizeof(struct sockaddr_in)) / 8;
		dst2->sin.sin_family = AF_INET;
		dst2->sin.sin_len = sizeof(struct sockaddr_in);
		dst2set = inet_pton(AF_INET, argv[i + 1],
				    &dst2->sin.sin_addr) != -1 ? 1 : 0;
	    }

	    if (dst2set == 0)
	    {
		fprintf(stderr,
			"%s: Warning: destination address2 %s is not valid\n",
			argv[0], argv[i + 1]);
		exit(1);
	    }
	    i++;
	    continue;
	}

d1064 1
a1064 2
	    ((iscmd(mode, FLOW) && !bypass) || iscmd(mode, GRP_SPI) ||
	     iscmd(mode, DEL_SPI) || iscmd(mode, BINDSA)))
a1118 67
	if (!strcmp(argv[i] + 1, "proto2") && 
	    (iscmd(mode, BINDSA) || iscmd(mode, GRP_SPI)) && (i + 1 < argc))
	{
	    if (isalpha(argv[i + 1][0]))
	    {
		if (!strcasecmp(argv[i + 1], "esp"))
		{
		    sprotocol.sadb_protocol_proto = SADB_SATYPE_ESP;
		    proto2 = IPPROTO_ESP;
		}
		else
		  if (!strcasecmp(argv[i + 1], "ah"))
		  {
		      sprotocol.sadb_protocol_proto = SADB_SATYPE_AH;
		      proto2 = IPPROTO_AH;
		  }
		  else
		    if (!strcasecmp(argv[i + 1], "ip4"))
		    {
			sprotocol.sadb_protocol_proto = SADB_X_SATYPE_IPIP;
			proto2 = IPPROTO_IPIP;
		    }
		    else
		    {
			fprintf(stderr,
				"%s: unknown security protocol2 type %s\n",
				argv[0], argv[i+1]);
			exit(1);
		    }
	    }
	    else
	    {
		proto2 = atoi(argv[i + 1]);

		if (proto2 != IPPROTO_ESP && proto2 != IPPROTO_AH &&
		    proto2 != IPPROTO_IPIP)
		{
		    fprintf(stderr,
			    "%s: unknown security protocol2 %d\n",
			    argv[0], proto2);
		    exit(1);
		}

		if (proto2 == IPPROTO_ESP)
		  sprotocol.sadb_protocol_proto = SADB_SATYPE_ESP;
		else
		  if (proto2 == IPPROTO_AH)
		    sprotocol.sadb_protocol_proto = SADB_SATYPE_AH;
		  else
		    if (proto2 == IPPROTO_IPIP)
		      sprotocol.sadb_protocol_proto = SADB_X_SATYPE_IPIP;
	    }

	    sprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
	    sprotocol.sadb_protocol_len = 1;
	    i++;
	    continue;
	}

	if (!strcmp(argv[i] + 1, "chain") &&
	    !(sa.sadb_sa_flags & SADB_X_SAFLAGS_CHAINDEL) &&
	    iscmd(mode, DEL_SPI))
	{
	    sa.sadb_sa_flags |= SADB_X_SAFLAGS_CHAINDEL;
	    continue;
	}

d1120 1
a1120 1
	fprintf(stderr, "%s: Unknown or invalid option: %s\n",
d1153 1
a1153 4
    if (spi == SPI_RESERVED_MIN && !iscmd(mode, FLUSH) && !bypass &&
	(!iscmd(mode, FLOW) || (iscmd(mode, FLOW) &&
			        (smsg.sadb_msg_type != SADB_X_DELFLOW ||
				 ingress))))
a1158 7
    if ((iscmd(mode, GRP_SPI) || iscmd(mode, BINDSA)) &&
	spi2 == SPI_RESERVED_MIN)
    {
	fprintf(stderr, "%s: no SPI2 specified\n", argv[0]);
	exit(1);
    }

a1164 19
    if ((iscmd(mode, DEL_SPI) || iscmd(mode, GRP_SPI) || 
	 (iscmd(mode, FLOW) && !bypass) ||
	 iscmd(mode, BINDSA)) && proto != IPPROTO_ESP &&
	proto != IPPROTO_AH && proto != IPPROTO_IPIP)
    {
	fprintf(stderr, "%s: security protocol is none of AH, ESP or IPIP\n",
		argv[0]);
	exit(1);
    }

    if ((iscmd(mode, GRP_SPI) || iscmd(mode, BINDSA)) &&
	proto2 != IPPROTO_ESP && proto2 != IPPROTO_AH &&
	proto2 != IPPROTO_IPIP)
    {
	fprintf(stderr, "%s: security protocol2 is none of AH, ESP or IPIP\n",
		argv[0]);
	exit(1);
    }

d1167 2
a1168 2
			        (smsg.sadb_msg_type != SADB_X_DELFLOW ||
				 ingress))))
d1175 1
a1175 7
    if (iscmd(mode, FLOW) && !setmask)
    {
	fprintf(stderr,	"%s: no subnets for flow specified\n", argv[0]);
	exit(1);
    }

    if (iscmd(mode, FLOW) && !bypass && (sprotocol.sadb_protocol_proto == 0) &&
a1181 12
    if ((iscmd(mode, GRP_SPI) || iscmd(mode, BINDSA)) && !dst2set)
    {
	fprintf(stderr, "%s: no destination address2 specified\n", argv[0]);
	exit(1);
    }

    if (bypass && ingress)
    {
	fprintf(stderr,	"%s: cannot specify \"-bypass\" and \"-ingress\" simultaneously\n", argv[0]);
	exit(1);
    }

d1219 1
a1219 1
	if (src->sa.sa_len)
a1272 34
	    case GRP_SPI:
	    case BINDSA:
		/* SA header */
		iov[cnt].iov_base = &sa;
		iov[cnt++].iov_len = sizeof(sa);
		smsg.sadb_msg_len += sa.sadb_sa_len;

		/* Destination address header */
		iov[cnt].iov_base = &sad2;
		iov[cnt++].iov_len = sizeof(sad2);
		/* Destination address */
		iov[cnt].iov_base = dst;
		iov[cnt++].iov_len = ROUNDUP(dst->sa.sa_len);
		smsg.sadb_msg_len += sad2.sadb_address_len;

		/* SA header */
		iov[cnt].iov_base = &sa2;
		iov[cnt++].iov_len = sizeof(sa2);
		smsg.sadb_msg_len += sa2.sadb_sa_len;

		/* Destination2 address header */
		iov[cnt].iov_base = &sad8;
		iov[cnt++].iov_len = sizeof(sad8);
		/* Destination2 address */
		iov[cnt].iov_base = dst2;
		iov[cnt++].iov_len = ROUNDUP(dst2->sa.sa_len);
		smsg.sadb_msg_len += sad8.sadb_address_len;

		/* Protocol2 */
		iov[cnt].iov_base = &sprotocol;
		iov[cnt++].iov_len = sizeof(sprotocol);
		smsg.sadb_msg_len += sprotocol.sadb_protocol_len;
		break;

d1302 1
a1302 1
		if (src->sa.sa_len)
d1315 2
a1316 1
		 if ((smsg.sadb_msg_type != SADB_X_DELFLOW) || ingress)
d1326 20
a1345 5
		 
		 /* SA header */
		 iov[cnt].iov_base = &sa;
		 iov[cnt++].iov_len = sizeof(sa);
		 smsg.sadb_msg_len += sa.sadb_sa_len;
d1349 1
a1349 1
		     /* Protocol2 */
d1354 6
a1359 1
		 
d1361 16
d1379 1
a1379 1
		 /* Flow source addressaddress */
d1388 16
d1426 1
a1426 1
		 /* No more work needed. */
@


1.37
log
@Remove extra space from usage.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.36 2000/04/22 02:40:01 angelos Exp $ */
d500 1
a500 1
	    fd = open(argv[i++], O_RDONLY);
d561 1
a561 1
	    fd = open(argv[i++], O_RDONLY);
@


1.36
log
@Slight clarification in usage.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.35 2000/04/22 01:53:41 angelos Exp $ */
d204 1
a204 1
	    "\t  -addr <ip> <net> <ip> <net>\t subnets for flow\n"
@


1.35
log
@-keyfile/-authkeyfile flags, for reading keys from a file.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.34 2000/04/21 17:32:24 deraadt Exp $ */
d200 1
a200 1
	    "\t  -authkeyfile <file>\t\tfile to read key material from\n"
@


1.34
log
@fix some usage glitches
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.33 2000/03/28 14:30:51 jason Exp $ */
d62 1
d66 2
d198 1
d200 1
d474 106
@


1.33
log
@fix sanity checks to allow authentication-only ESP
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.32 2000/02/08 12:50:25 itojun Exp $ */
d183 1
a183 1
	    "\tCommands: new esp, old esp, new ah, old ah, group, delspi, ip4\n"
d186 13
a198 13
	    "\t  -enc <alg>\t\t\t encryption algorithm\n"
	    "\t  -auth <alg>\t\t\t authentication algorithm\n"
	    "\t  -src <ip>\t\t\t source address to be used\n"
	    "\t  -halfiv\t\t\t use 4-byte IV in old ESP\n"
	    "\t  -forcetunnel\t\t\t force IP-in-IP encapsulation\n"
	    "\t  -dst <ip>\t\t\t destination address to be used\n"
	    "\t  -proxy <ip>\t\t\t proxy address to be used\n"
	    "\t  -spi <val>\t\t\t SPI to be used\n"
	    "\t  -key <val>\t\t\t key material to be used\n"
	    "\t  -authkey <val>\t\t key material for auth in new esp\n"
	    "\t  -proto <val>\t\t\t security protocol\n"
	    "\t  -chain\t\t\t SPI chain delete\n"
	    "\t  -transport <val>\t\t protocol number for flow\n"
d200 6
a205 6
	    "\t  -delete\t\t\t delete specified flow\n"
	    "\t  -bypass\t\t\t create/delete a bypass flow\n"
	    "\t  -sport\t\t\t source port for flow\n"
	    "\t  -dport\t\t\t destination port for flow\n"
	    "\t  -ingress\t\t\t flow is ingress access control entry\n"
	    "\t  -[ah|esp|ip4]\t to flush a particular protocol\n"
@


1.32
log
@in6.h is not necessary (in.h will bring it in)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.31 2000/01/27 08:04:02 angelos Exp $ */
d1118 1
a1118 1
    if ((mode & (ESP_NEW | ESP_OLD)) && enc == 0)
d1120 2
a1121 1
	fprintf(stderr, "%s: no encryption algorithm specified\n",  argv[0]);
d1132 1
a1132 1
    if (((mode & (ESP_NEW | ESP_OLD)) && keyp == NULL) ||
@


1.31
log
@Conform with the new changes with regards to new/old ESP/AH
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.30 2000/01/13 04:46:18 angelos Exp $ */
a52 4

#ifdef INET6
#include <netinet6/in6.h>
#endif /* INET6 */
@


1.30
log
@Add -ingress flag
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.29 2000/01/09 22:53:40 angelos Exp $ */
d209 1
a209 1
	    "\t  -[ah|esp|oldah|oldesp|ip4]\t to flush a particular protocol\n"
d341 3
a343 1
	      smsg.sadb_msg_satype = SADB_X_SATYPE_ESP_OLD;
d350 2
a351 1
		smsg.sadb_msg_satype = SADB_X_SATYPE_AH_OLD;
a515 6
		if(!strcmp(argv[i] + 1, "oldesp"))
		    smsg.sadb_msg_satype = SADB_X_SATYPE_ESP_OLD;
		else 
		  if(!strcmp(argv[i] + 1, "oldah"))
		      smsg.sadb_msg_satype = SADB_X_SATYPE_AH_OLD;
		  else 
d1150 2
a1151 1
			        smsg.sadb_msg_type != SADB_X_DELFLOW)))
d1191 2
a1192 1
			        smsg.sadb_msg_type != SADB_X_DELFLOW)))
d1391 1
a1391 1
		 if (smsg.sadb_msg_type != SADB_X_DELFLOW)
@


1.29
log
@Transport protocol ports are in network order.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.28 1999/12/20 05:38:22 angelos Exp $ */
d208 1
d218 1
a218 1
    int proto = IPPROTO_ESP, proto2 = IPPROTO_AH;
d814 1
a814 1
	if (!strcmp(argv[i] + 1, "bypass") && iscmd(mode, FLOW) && !bypass)
d890 7
d1216 6
@


1.28
log
@Accept IPv6 addresses.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.27 1999/12/06 21:58:39 angelos Exp $ */
d878 1
a878 1
		sport = svp->s_port;
d881 1
a881 1
	      sport = atoi(argv[i+1]);
d902 1
a902 1
		dport = svp->s_port;
d905 1
a905 1
	      dport = atoi(argv[i + 1]);
@


1.27
log
@Minor identation.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.26 1999/12/04 23:26:27 angelos Exp $ */
d54 4
d106 2
d220 4
a223 1
    union sockaddr_union src, dst, dst2, osrc, odst, osmask, odmask, proxy;
d272 19
a290 1
    
a308 10
    /* Initialize */
    bzero(&src, sizeof(union sockaddr_union));
    bzero(&dst, sizeof(union sockaddr_union));
    bzero(&dst2, sizeof(union sockaddr_union));
    bzero(&osrc, sizeof(union sockaddr_union));
    bzero(&odst, sizeof(union sockaddr_union));
    bzero(&osmask, sizeof(union sockaddr_union));
    bzero(&odmask, sizeof(union sockaddr_union));
    bzero(&proxy, sizeof(union sockaddr_union));

a565 3
	    src.sin.sin_family = AF_INET;
	    src.sin.sin_len = sizeof(struct sockaddr_in);
	    srcset = inet_aton(argv[i + 1], &src.sin.sin_addr) != -1 ? 1 : 0;
d567 27
a593 1
	    sad1.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
d600 27
a626 7
	    proxy.sin.sin_family = AF_INET;
	    proxy.sin.sin_len = sizeof(struct sockaddr_in);
	    if (!inet_aton(argv[i + 1], &proxy.sin.sin_addr)) {
		fprintf(stderr,
		    "%s: Warning: proxy address %s is not valid\n", argv[0],
		    argv[i + 1]);
		exit(1);
d628 1
a628 2
	    sad3.sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;
	    sad3.sadb_address_len = 1 + sizeof(struct sockaddr_in) / 8;
d691 36
a726 8
	    sad4.sadb_address_len = (sizeof(sad4) +
				     sizeof(struct sockaddr_in)) / 8;
	    sad5.sadb_address_len = (sizeof(sad5) +
				     sizeof(struct sockaddr_in)) / 8;
	    sad6.sadb_address_len = (sizeof(sad6) +
				     sizeof(struct sockaddr_in)) / 8;
	    sad7.sadb_address_len = (sizeof(sad7) +
				     sizeof(struct sockaddr_in)) / 8;
d728 30
a757 11
	    osrc.sin.sin_family = odst.sin.sin_family = AF_INET;
	    osmask.sin.sin_family = odmask.sin.sin_family = AF_INET;
	    osrc.sin.sin_len = odst.sin.sin_len = sizeof(struct sockaddr_in);
	    osmask.sin.sin_len = sizeof(struct sockaddr_in);
	    odmask.sin.sin_len = sizeof(struct sockaddr_in);
	    setmask = 1;

	    if (!inet_aton(argv[i + 1], &osrc.sin.sin_addr)) {
		fprintf(stderr, "%s: source address %s is not valid\n", argv[0],
		    argv[i + 1]);
	        exit(1);
d759 50
a808 11
	    i++;
	    if (!inet_aton(argv[i + 1], &osmask.sin.sin_addr)) {
		fprintf(stderr, "%s: source netmask %s is not valid\n", argv[0],
		    argv[i + 1]);
	        exit(1);
	    }
	    i++;
	    if (!inet_aton(argv[i + 1], &odst.sin.sin_addr)) {
		fprintf(stderr, "%s: destination address %s is not valid\n", argv[0],
		    argv[i + 1]);
	        exit(1);
a809 7
	    i++;
	    if (!inet_aton(argv[i + 1], &odmask.sin.sin_addr)) {
		fprintf(stderr, "%s: destination netmask %s is not valid\n", argv[0],
		    argv[i + 1]);
	        exit(1);
	    }
	    i++;
d825 3
a827 3
	    dst.sin.sin_family = AF_INET;
	    dst.sin.sin_len = sizeof(struct sockaddr_in);
	    dstset = inet_aton("0.0.0.0", &dst.sin.sin_addr) != -1 ? 1 : 0;
d883 2
a884 2
	    osrc.sin.sin_port = sport;
	    osmask.sin.sin_port = 0xffff;
d907 2
a908 2
	    odst.sin.sin_port = dport;
	    odmask.sin.sin_port = 0xffff;
d916 29
a944 5
	    sad2.sadb_address_len = (sizeof(sad2) +
				     sizeof(struct sockaddr_in)) / 8;
	    dst.sin.sin_family = AF_INET;
	    dst.sin.sin_len = sizeof(struct sockaddr_in);
	    dstset = inet_aton(argv[i + 1], &dst.sin.sin_addr) != -1 ? 1 : 0;
a951 2
	    sad8.sadb_address_len = (sizeof(sad8) +
				     sizeof(struct sockaddr_in)) / 8;
d953 29
a981 3
	    dst2.sin.sin_family = AF_INET;
	    dst2.sin.sin_len = sizeof(struct sockaddr_in);
	    dst2set = inet_aton(argv[i + 1], &dst2.sin.sin_addr) != -1 ? 1 : 0;
d1143 3
a1145 1
    if (spi == SPI_RESERVED_MIN && !iscmd(mode, FLUSH) && !bypass)
d1183 3
a1185 1
    if (!dstset && !iscmd(mode, FLUSH))
d1199 1
a1199 1
	(odst.sin.sin_port || osrc.sin.sin_port))
d1244 2
a1245 2
	iov[cnt].iov_base = &dst;
	iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1248 1
a1248 1
	if (src.sin.sin_addr.s_addr)
d1254 2
a1255 2
	    iov[cnt].iov_base = &src;
	    iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1259 1
a1259 1
	if (proxy.sin.sin_addr.s_addr)
d1265 2
a1266 2
	    iov[cnt].iov_base = &proxy;
	    iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1313 2
a1314 2
		iov[cnt].iov_base = &dst;
		iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1326 2
a1327 2
		iov[cnt].iov_base = &dst2;
		iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1346 2
a1347 2
		iov[cnt].iov_base = &dst;
		iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1361 2
a1362 2
		iov[cnt].iov_base = &dst;
		iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1365 1
a1365 1
		if (src.sin.sin_addr.s_addr)
d1371 2
a1372 2
		    iov[cnt].iov_base = &src;
		    iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1384 2
a1385 2
		     iov[cnt].iov_base = &dst;
		     iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1406 2
a1407 2
		 iov[cnt].iov_base = &osrc;
		 iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1414 2
a1415 2
		 iov[cnt].iov_base = &odst;
		 iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1422 2
a1423 2
		 iov[cnt].iov_base = &osmask;
		 iov[cnt++].iov_len = sizeof(struct sockaddr_in);
d1430 2
a1431 2
		 iov[cnt].iov_base = &odmask;
		 iov[cnt++].iov_len = sizeof(struct sockaddr_in);
@


1.26
log
@Deprecate -local flag.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.25 1999/11/04 11:29:35 ho Exp $ */
d611 2
a612 1
		    "%s: Warning: option local has been deprecated\n", argv[0]);
@


1.25
log
@Support IPsec bypass flows. (ok angelos@@, niklas@@)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.24 1999/09/07 12:35:27 ho Exp $ */
a198 1
	    "\t  -local\t\t\t also create a local flow\n"
d610 2
a611 1
	    sa.sadb_sa_flags |= SADB_X_SAFLAGS_LOCALFLOW;
@


1.24
log
@Add {newline, usage()} to 'unknown command' message.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.23 1999/08/25 15:36:57 angelos Exp $ */
d200 1
d238 1
d505 8
a512 5
		    {
		      fprintf(stderr, "%s: invalid SA type %s\n", argv[0],
			      argv[i + 1]);
		      exit(1);
		    }
d518 1
a518 1
	    (i + 1 < argc))
d674 19
a692 1
	if (!strcmp(argv[i] + 1, "transport") && 
d725 1
a725 1
	if (!strcmp(argv[i] + 1, "sport") && 
d750 1
a750 1
	if (!strcmp(argv[i] + 1, "dport") && 
d774 1
a774 1
	if (!strcmp(argv[i] + 1, "dst") && (i + 1 < argc))
d800 1
a800 1
	    (iscmd(mode, FLOW) || iscmd(mode, GRP_SPI) ||
d956 1
a956 1
    if (spi == SPI_RESERVED_MIN && !iscmd(mode, FLUSH))
d975 2
a976 1
    if ((iscmd(mode, DEL_SPI) || iscmd(mode, GRP_SPI) || iscmd(mode, FLOW) ||
d1007 1
a1007 1
    if (iscmd(mode, FLOW) && (sprotocol.sadb_protocol_proto == 0) &&
@


1.23
log
@Fix usage message, fix flow logic.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.22 1999/08/05 22:02:04 ho Exp $ */
d390 1
a390 1
		      fprintf(stderr, "%s: unknown command: %s", argv[0], 
d392 1
@


1.22
log
@Add 'ipsecadm flush' to do what 'route flush -encap' doesn't manage.
Sync manpage and fix a couple of typos.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.21 1999/07/15 14:56:26 niklas Exp $ */
d200 2
d212 1
a212 1
    int dport = -1, sport = -1, tproto = -1;
d639 2
a640 1
	    
d976 1
a976 4
    if (iscmd(mode, FLOW) && (odst.sin.sin_addr.s_addr == 0 &&
			      odmask.sin.sin_addr.s_addr == 0 && 
			      osrc.sin.sin_addr.s_addr == 0 &&
			      osmask.sin.sin_addr.s_addr == 0))
@


1.21
log
@SPI 0 is the one we use for demand keying, IANA reserved SPIs are not
allowed
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.20 1999/07/02 23:37:32 deraadt Exp $ */
d76 1
d182 1
a182 1
	    "\t\t  flow, bind\n"
d200 1
d371 1
a371 1
		if (!strcmp(argv[1], "ip4"))
d373 3
a375 3
		    mode = ENC_IP;
		    smsg.sadb_msg_type = SADB_ADD;
		    smsg.sadb_msg_satype = SADB_X_SATYPE_IPIP;
d378 14
a391 5
		else
		{
		    fprintf(stderr, "%s: unknown command: %s", argv[0], argv[1]);
		    exit(1);
		}
d483 26
d929 1
a929 1
    if (spi == SPI_RESERVED_MIN)
d966 1
a966 1
    if (!dstset)
d1218 5
a1228 1

@


1.20
log
@rename SADB_foo_X_bar to SADB_X_foo_bar
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.19 1999/06/05 19:32:57 deraadt Exp $ */
d209 1
a209 1
    u_int32_t spi = 0, spi2 = 0;
d472 2
a473 1
	if (!strcmp(argv[i] + 1, "spi") && spi == 0 && (i + 1 < argc))
d475 2
a476 1
	    if ((spi = htonl(strtoul(argv[i + 1], NULL, 16))) == 0)
d487 1
a487 1
	if (!strcmp(argv[i] + 1, "spi2") && spi2 == 0 && 
d490 3
a492 1
	    if ((spi2 = htonl(strtoul(argv[i + 1], NULL, 16))) == 0)
d892 1
a892 1
    if (spi == 0)
d898 2
a899 1
    if ((iscmd(mode, GRP_SPI) || iscmd(mode, BINDSA)) && spi2 == 0)
@


1.19
log
@fix another inet_aton()
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.18 1999/06/05 17:05:34 deraadt Exp $ */
d91 3
a93 3
    {"blf", SADB_EALG_X_BLF,   XF_ENC |        ESP_NEW},
    {"cast", SADB_EALG_X_CAST, XF_ENC |        ESP_NEW},
    {"skipjack", SADB_EALG_X_SKIPJACK, XF_ENC |        ESP_NEW},
d96 3
a98 3
    {"md5", SADB_AALG_X_MD5,  XF_AUTH|AH_OLD},
    {"sha1", SADB_AALG_X_SHA1,XF_AUTH|AH_OLD},
    {"rmd160", SADB_AALG_X_RIPEMD160HMAC96, XF_AUTH|AH_NEW|ESP_NEW},
d272 1
a272 1
    sa2.sadb_sa_exttype = SADB_EXT_X_SA2;
d318 1
a318 1
	      smsg.sadb_msg_satype = SADB_SATYPE_X_ESP_OLD;
d325 1
a325 1
		smsg.sadb_msg_satype = SADB_SATYPE_X_AH_OLD;
d373 1
a373 1
		    smsg.sadb_msg_satype = SADB_SATYPE_X_IPIP;
d466 1
a466 1
		sa.sadb_sa_flags |= SADB_SAFLAGS_X_HALFIV;
d536 1
a536 1
	    sa.sadb_sa_flags |= SADB_SAFLAGS_X_TUNNEL;
d550 1
a550 1
	    sa.sadb_sa_flags |= SADB_SAFLAGS_X_HALFIV;
d562 1
a562 1
	    sa.sadb_sa_flags |= SADB_SAFLAGS_X_LOCALFLOW;
d570 1
a570 1
	    sa.sadb_sa_flags |= SADB_SAFLAGS_X_TUNNEL;
d577 4
a580 4
	    sad4.sadb_address_exttype = SADB_EXT_X_SRC_FLOW;
	    sad5.sadb_address_exttype = SADB_EXT_X_DST_FLOW;
	    sad6.sadb_address_exttype = SADB_EXT_X_SRC_MASK;
	    sad7.sadb_address_exttype = SADB_EXT_X_DST_MASK;
d651 1
a651 1
	    sprotocol.sadb_protocol_exttype = SADB_EXT_X_PROTOCOL;
d723 1
a723 1
	    sad8.sadb_address_exttype = SADB_EXT_X_DST2;
d751 1
a751 1
			smsg.sadb_msg_satype = SADB_SATYPE_X_IPIP;
d781 1
a781 1
		      smsg.sadb_msg_satype = SADB_SATYPE_X_IPIP;
d807 1
a807 1
			sprotocol.sadb_protocol_proto = SADB_SATYPE_X_IPIP;
d838 1
a838 1
		      sprotocol.sadb_protocol_proto = SADB_SATYPE_X_IPIP;
d841 1
a841 1
	    sprotocol.sadb_protocol_exttype = SADB_EXT_X_PROTOCOL;
d848 1
a848 1
	    !(sa.sadb_sa_flags & SADB_SAFLAGS_X_CHAINDEL) &&
d851 1
a851 1
	    sa.sadb_sa_flags |= SADB_SAFLAGS_X_CHAINDEL;
@


1.18
log
@use inet_aton()
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.17 1999/04/18 15:06:58 provos Exp $ */
d516 1
a516 1
		    "%s: Warning: proxy address %s is not valid\n",
@


1.17
log
@missing iscmd
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.16 1999/03/29 04:52:53 provos Exp $ */
d514 6
a519 1
	    proxy.sin.sin_addr.s_addr = inet_addr(argv[i + 1]);
d597 24
a620 4
	    osrc.sin.sin_addr.s_addr = inet_addr(argv[i + 1]); i++;
	    osmask.sin.sin_addr.s_addr = inet_addr(argv[i + 1]); i++;
	    odst.sin.sin_addr.s_addr = inet_addr(argv[i + 1]); i++;
	    odmask.sin.sin_addr.s_addr = inet_addr(argv[i + 1]); i++;
@


1.16
log
@make it compile
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.15 1999/03/27 21:04:18 provos Exp $ */
d764 1
a764 1
	    iscmd(mode, GRP_SPI) && (i + 1 < argc))
@


1.15
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.14 1999/03/15 15:37:02 deraadt Exp $ */
d486 1
a486 1
	    (iscmd(mode, GRP_SPI) || iscmd(mode, BINDSA) && (i + 1 < argc))
d694 1
a694 1
	    (iscmd(mode, GRP_SPI) || iscmd(mode, BINDSA) && (i + 1 < argc))
@


1.14
log
@explain EPROTONOSUPPORT; nash@@mcs.net
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.13 1999/03/04 19:58:43 angelos Exp $ */
d75 1
d180 2
a181 1
	    "\tCommands: new esp, old esp, new ah, old ah, group, delspi, ip4, flow\n"
d211 1
d352 1
a352 1
	    if (!strcmp(argv[1], "flow"))
d354 3
a356 4
		/* It may not be ADDFLOW, but never mind that for now */
		smsg.sadb_msg_type = SADB_X_ADDFLOW;
	    	smsg.sadb_msg_satype = SADB_SATYPE_ESP;
		mode = FLOW;
d360 1
a360 1
	      if (!strcmp(argv[1], "ip4"))
d362 4
a365 3
		  mode = ENC_IP;
		  smsg.sadb_msg_type = SADB_ADD;
		  smsg.sadb_msg_satype = SADB_SATYPE_X_IPIP;
d369 13
a381 5
	      {
		  fprintf(stderr, "%s: unknown command: %s", argv[0], argv[1]);
		  exit(1);
	      }

d486 1
a486 1
	    iscmd(mode, GRP_SPI) && (i + 1 < argc))
d503 1
a503 1
	    src.sin.sin_addr.s_addr = inet_addr(argv[i + 1]);
d688 1
a688 1
	    dst.sin.sin_addr.s_addr = inet_addr(argv[i + 1]);
d694 1
a694 1
	    iscmd(mode, GRP_SPI) && (i + 1 < argc))
d701 1
a701 1
	    dst2.sin.sin_addr.s_addr = inet_addr(argv[i + 1]);
d708 1
a708 1
	     iscmd(mode, DEL_SPI)))
d869 1
a869 1
    if (iscmd(mode, GRP_SPI) && spi2 == 0)
d875 1
a875 2
    if ((isencauth(mode) || iscmd(mode, ENC_IP)) && 
	src.sin.sin_addr.s_addr == 0)
d881 3
a883 2
    if ((iscmd(mode, DEL_SPI) || iscmd(mode, GRP_SPI) || iscmd(mode, FLOW)) && 
	proto != IPPROTO_ESP && proto != IPPROTO_AH && proto != IPPROTO_IPIP)
d890 3
a892 2
    if (iscmd(mode, GRP_SPI) && proto2 != IPPROTO_ESP &&
	proto2 != IPPROTO_AH && proto2 != IPPROTO_IPIP)
d899 1
a899 1
    if (dst.sin.sin_addr.s_addr == 0)
d922 1
a922 1
    if (iscmd(mode, GRP_SPI) && dst2.sin.sin_addr.s_addr == 0)
d1020 1
@


1.13
log
@Fix -proto2 numeric protocol handling.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.12 1999/02/27 07:29:17 deraadt Exp $ */
d110 3
@


1.12
log
@authkey not authp; Markus.Friedl@@informatik.uni-erlangen.de
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.11 1999/02/26 10:04:05 angelos Exp $ */
d780 11
a790 1
	      proto2 = atoi(argv[i + 1]);
d792 8
a799 6
	    if (proto2 != IPPROTO_ESP && proto2 != IPPROTO_AH &&
		proto2 != IPPROTO_IPIP)
	    {
		fprintf(stderr,
			"%s: unknown security protocol2 %d\n", argv[0], proto);
		exit(1);
@


1.11
log
@Print warning when using DES or Skipjack for encryption.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.10 1999/02/26 02:04:52 angelos Exp $ */
d824 2
a825 1
    if (isencauth(mode) && keyp == NULL)
@


1.10
log
@Pretty usage message.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.9 1999/02/25 22:32:05 angelos Exp $ */
d162 6
a167 1
        return xf[i].id;
@


1.9
log
@Listen to kernel replies and report errors (much room for improvement
there), fix a typo in a warning message, prettier error messages.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.8 1999/02/25 10:21:25 angelos Exp $ */
d173 16
a188 16
	    "\t\t-enc <alg>\t encryption algorithm\n"
	    "\t\t-auth <alg>\t authentication algorithm\n"
	    "\t\t-src <ip>\t source address to be used\n"
	    "\t\t-halfiv\t use 4-byte IV in old ESP\n"
	    "\t\t-forcetunnel\t force tunneling even when not necessary\n"
	    "\t\t-dst <ip>\t destination address to be used\n"
	    "\t\t-proxy <ip>\t proxy address to be used\n"
	    "\t\t-spi <val>\t SPI to be used\n"
	    "\t\t-key <val>\t key material to be used\n"
	    "\t\t-authkey <val>\t key material for auth in new esp\n"
	    "\t\t-proto <val>\t security protocol\n"
	    "\t\t-chain\t\t SPI chain delete\n"
	    "\t\t-transport <val>\t protocol number for flow\n"
	    "\t\t-addr <ip> <net> <ip> <net>\t subnets for flow\n"
	    "\t\t-delete\t\t delete specified flow\n"
	    "\t\t-local\t\t also create a local flow\n"
@


1.8
log
@Fix missing include file, after the re-positioning of sockaddr_union
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.7 1999/02/25 00:02:27 angelos Exp $ */
a99 1
/* XXX Depending on message type, we should listen for message replies */
d103 1
d119 14
d329 1
d345 1
d359 1
a359 1
		  fprintf(stderr, "%s: Unknown command: %s", argv[0], argv[i]);
d367 1
a367 1
	    fprintf(stderr, "%s: Expected option, got %s\n", 
d376 1
a376 1
		fprintf(stderr, "%s: Invalid encryption algorithm %s\n",
d391 1
a391 1
		fprintf(stderr, "%s: Invalid auth algorithm %s\n",
d423 1
a423 1
		fprintf(stderr,	"%s: Invalid option %s for selected mode\n",
d437 1
a437 1
		fprintf(stderr, "%s: Invalid option %s with auth\n",
d457 1
a457 1
		fprintf(stderr, "%s: Invalid spi %s\n", argv[0], argv[i + 1]);
d469 3
a471 2
	    if ((spi2 = htonl(strtoul(argv[i + 1], NULL, 16))) == 0) {
		fprintf(stderr, "%s: Invalid spi2 %s\n", argv[0], argv[i + 1]);
d800 2
a801 2
	fprintf(stderr,
		"%s: Unknown or invalid option: %s\n", argv[0], argv[i]);
d808 1
a808 1
	fprintf(stderr, "%s: No encryption algorithm specified\n",  argv[0]);
d814 1
a814 1
	fprintf(stderr, "%s: No authentication algorithm specified\n", 
d821 1
a821 1
	fprintf(stderr, "%s: No key material specified\n", argv[0]);
d827 1
a827 1
	fprintf(stderr, "%s: No auth key material specified\n", argv[0]);
d833 1
a833 1
	fprintf(stderr, "%s: No SPI specified\n", argv[0]);
d839 1
a839 1
	fprintf(stderr, "%s: No SPI2 specified\n", argv[0]);
d846 1
a846 1
	fprintf(stderr, "%s: No source address specified\n", argv[0]);
d853 1
a853 1
	fprintf(stderr, "%s: Security protocol is none of AH, ESP or IPIP\n",
d861 1
a861 1
	fprintf(stderr, "%s: Security protocol2 is none of AH, ESP or IPIP\n",
d868 1
a868 1
	fprintf(stderr, "%s: No destination address for the SA specified\n", 
d878 1
a878 1
	fprintf(stderr,	"%s: No subnets for flow specified\n", argv[0]);
d885 1
a885 1
	fprintf(stderr, "%s: No transport protocol supplied with source/destination ports\n", argv[0]);
d891 1
a891 1
	fprintf(stderr, "%s: No destination address2 specified\n", argv[0]);
@


1.7
log
@Fix bug that didn't allow use of sha1/md5.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.6 1999/02/24 23:47:18 angelos Exp $ */
d63 1
@


1.6
log
@Copyright update.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.5 1999/02/24 23:32:53 angelos Exp $ */
d144 4
a147 8
      if (!strcmp(option, xf[i].name))
      {
	  if ((xf[i].flags & CMD_MASK) == type && 
	      (xf[i].flags & mode))
	    return xf[i].id;
	  else
	    return 0;
      }
@


1.5
log
@Remove unnecessary file, move man page to section 8.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.4 1999/02/24 22:53:37 angelos Exp $ */
d16 4
a19 2
 * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
 * and Niels Provos.
@


1.4
log
@Almost rewritten ipsecadm to use pfkey. Error reporting is a bit lacking still.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.3 1999/02/17 20:39:16 deraadt Exp $ */
d60 1
a60 2
#include "net/pfkeyv2.h"
#include "netinet/ip_ipsp.h"
@


1.3
log
@ipsec skipjack, based on free .fi code (some .gov type will test this for me)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.2 1999/02/13 00:19:48 angelos Exp $ */
d59 2
a60 1
#include "net/encap.h"
a61 1
#include "netinet/ip_esp.h"
d81 3
a83 19
	char *name;
	int   id, flags;
}       transform;

int xf_esp_new __P((struct in_addr, struct in_addr, u_int32_t, int, int, 
    u_char *, u_char *, u_char *, struct in_addr, struct in_addr, int));
int xf_esp_old __P((struct in_addr, struct in_addr, u_int32_t, int, u_char *,
    u_char *, struct in_addr, struct in_addr)); 
int xf_ah_new __P((struct in_addr, struct in_addr, u_int32_t, int, u_char *,
    struct in_addr, struct in_addr));
int xf_ah_old __P((struct in_addr, struct in_addr, u_int32_t, int, u_char *,
    struct in_addr, struct in_addr));

int xf_delspi __P((struct in_addr, u_int32_t, int, int));
int xf_grp __P((struct in_addr, u_int32_t, int, struct in_addr, u_int32_t, int));
int xf_flow __P((struct in_addr, u_int32_t, int, struct in_addr, 
    struct in_addr, struct in_addr, struct in_addr, int, int, int, int, int));
int xf_ip4 __P((struct in_addr, struct in_addr, u_int32_t, 
    struct in_addr, struct in_addr));
d86 10
a95 8
	{"des", ALG_ENC_DES,   XF_ENC |ESP_OLD|ESP_NEW},
	{"3des", ALG_ENC_3DES, XF_ENC |ESP_OLD|ESP_NEW},
	{"blf", ALG_ENC_BLF,   XF_ENC |        ESP_NEW},
	{"cast", ALG_ENC_CAST, XF_ENC |        ESP_NEW},
	{"skipjack", ALG_ENC_SKIPJACK, XF_ENC |        ESP_NEW},
	{"md5", ALG_AUTH_MD5,  XF_AUTH|AH_OLD|AH_NEW|ESP_NEW},
	{"sha1", ALG_AUTH_SHA1,XF_AUTH|AH_OLD|AH_NEW|ESP_NEW},
	{"rmd160", ALG_AUTH_RMD160, XF_AUTH|AH_NEW|ESP_NEW},
d98 21
a118 1
char    buf[1024];
d123 10
a132 4
	char    ss[3];
	ss[0] = s[0];
	ss[1] = s[1];
	ss[2] = 0;
d134 1
a134 6
	if (!isxdigit(s[0]) || !isxdigit(s[1])) {
		fprintf(stderr,
			"Keys and IVs should be specified in hex digits.\n");
		exit(-1);
	}
	return strtoul(ss, NULL, 16);
d140 1
a140 1
     int i;
d142 11
a152 9
     for (i = sizeof(xf) / sizeof(transform) - 1; i >= 0; i--)
	  if (!strcmp(option, xf[i].name)) {
	       if ((xf[i].flags & CMD_MASK) == type && 
		   (xf[i].flags & mode))
		    return xf[i].id;
	       else
		    return 0;
	  }
     return 0;
d158 21
a178 21
     fprintf( stderr, "usage: ipsecadm [command] <modifier...>\n"
	      "\tCommands: new esp, old esp, new ah, old ah, group, delspi, ip4, flow\n"
	      "\tPossible modifiers:\n"
	      "\t\t-enc <alg>\t encryption algorithm\n"
	      "\t\t-auth <alg>\t authentication algorithm\n"
	      "\t\t-src <ip>\t source address to be used\n"
              "\t\t-tunnel <ip> <ip> tunneling addresses\n"
	      "\t\t-dst <ip>\t destination address to be used\n"
	      "\t\t-spi <val>\t SPI to be used\n"
	      "\t\t-key <val>\t key material to be used\n"
	      "\t\t-authkey <val>\t key material for auth in new esp\n"
	      "\t\t-iv <val>\t iv to be used\n"
	      "\t\t-proto <val>\t security protocol\n"
	      "\t\t-chain\t\t SPI chain delete\n"
	      "\t\t-newpadding\t new style padding for new ESP\n"
	      "\t\t-transport <val>\t protocol number for flow\n"
	      "\t\t-addr <ip> <net> <ip> <net>\t subnets for flow\n"
	      "\t\t-delete\t\t delete specified flow\n"
	      "\t\t-local\t\t also create a local flow\n"
	      "\talso: dst2, spi2, proto2\n"
	  );
d182 1
a182 3
main(argc, argv)
	int     argc;
	char  **argv;
d184 219
a402 13
	int i;
	int mode = ESP_NEW, new = 1, flag = 0, newpadding = 0;
	int auth = 0, enc = 0, ivlen = 0, klen = 0, alen = 0;
	int proto = IPPROTO_ESP, proto2 = IPPROTO_AH;
	int dport = -1, sport = -1, tproto = -1;
	int delete = 0, local = 0, result;
	int chain = 0; 
	u_int32_t spi = 0, spi2 = 0;
	struct in_addr src, dst, dst2, osrc, odst, osmask, odmask;
	u_char *ivp = NULL, *keyp = NULL, *authp = NULL;
	struct protoent *tp;
	struct servent *svp;
	char *transportproto = NULL;
d404 9
a412 2
	osrc.s_addr = odst.s_addr = src.s_addr = dst.s_addr = dst2.s_addr = 0;
	osmask.s_addr = odmask.s_addr = 0;
d414 11
a424 2
	if (argc < 2) {
		usage();
d426 99
d527 143
a669 31
	for (i=1; i < argc; i++) {
	     if (!strcmp(argv[i], "new") && !flag) {
		  flag = 1;
		  new = 1;
	     } else if (!strcmp(argv[i], "old") && !flag) {
		  flag = 1;
		  new = 0;
	     } else if (!strcmp(argv[i], "esp") && flag < 2) {
		  flag = 2;
		  mode = new ? ESP_NEW : ESP_OLD;
	     } else if (!strcmp(argv[i], "ah") && flag < 2) {
		  flag = 2;
		  mode = new ? AH_NEW : AH_OLD;
	     } else if (!strcmp(argv[i], "delspi") && flag < 2) {
		  flag = 2;
		  mode = DEL_SPI;
	     } else if (!strcmp(argv[i], "group") && flag < 2) {
		  flag = 2;
		  mode = GRP_SPI;
	     } else if (!strcmp(argv[i], "flow") && flag < 2) {
		  flag = 2;
		  mode = FLOW;
	     } else if (!strcmp(argv[i], "ip4") && flag < 2) {
		  flag = 2;
		  mode = ENC_IP;
	     } else if (argv[i][0] == '-') {
		  break;
	     } else {
		  fprintf(stderr, "%s: Unknown command: %s", argv[0], argv[i]);
		  exit(1);
	     }
d672 16
a687 43
	for (; i < argc; i++) {
	     if (argv[i][0] != '-') {
		  fprintf(stderr, "%s: Expected option, got %s\n", 
			  argv[0], argv[i]);
		  exit(1);
	     } else if (!strcmp(argv[i]+1, "enc") && enc == 0 && i+1 < argc) {
		  if ((enc = isvalid(argv[i+1], XF_ENC, mode)) == 0) {
		       fprintf(stderr, "%s: Invalid encryption algorithm %s\n",
			       argv[0], argv[i+1]);
		       exit(1);
		  }
		  i++;
	     } else if (!strcmp(argv[i]+1, "auth") && auth == 0 && i+1 < argc) {
		  if ((auth = isvalid(argv[i+1], XF_AUTH, mode)) == 0) {
		       fprintf(stderr, "%s: Invalid auth algorithm %s\n",
			       argv[0], argv[i+1]);
		       exit(1);
		  }
		  i++;
	     } else if (!strcmp(argv[i]+1, "key") && keyp == NULL && i+1 < argc) {
		  keyp = argv[++i];
		  klen = strlen(keyp);
	     } else if (!strcmp(argv[i]+1, "authkey") && authp == NULL && i+1 < argc) {
		  if (!(mode & ESP_NEW)) {
		       fprintf(stderr, "%s: Invalid option %s for selected mode\n",
			       argv[0], argv[i]);
		       exit(1);
		  }
		  authp = argv[++i];
		  alen = strlen(authp);
	     } else if (!strcmp(argv[i]+1, "iv") && ivp == NULL && i+1 < argc) {
		  if (mode & (AH_OLD|AH_NEW)) {
		       fprintf(stderr, "%s: Invalid option %s with auth\n",
			       argv[0], argv[i]);
		       exit(1);
		  }
		  ivp = argv[++i];
		  ivlen = strlen(ivp);
	     } else if (!strcmp(argv[i]+1, "spi") && spi == 0 && i+1 < argc) {
		  if ((spi = htonl(strtoul(argv[i+1], NULL, 16))) == 0) {
		       fprintf(stderr, "%s: Invalid spi %s\n", 
			       argv[0], argv[i+1]);
		       exit(1);
d689 11
a699 36
		  i++;
	     } else if (!strcmp(argv[i]+1, "spi2") && spi2 == 0 && 
			iscmd(mode, GRP_SPI) && i+1 < argc) {
		  if ((spi2 = htonl(strtoul(argv[i+1], NULL, 16))) == 0) {
		       fprintf(stderr, "%s: Invalid spi2 %s\n", 
			       argv[0], argv[i+1]);
		       exit(1);
		  }
		  i++;
	     } else if (!strcmp(argv[i]+1, "src") && i+1 < argc) {
		  src.s_addr = inet_addr(argv[i+1]);
		  i++;
	     } else if (!strcmp(argv[i]+1, "newpadding") && (mode & ESP_NEW)) {
		  newpadding = 1;
	     } else if (!strcmp(argv[i]+1, "delete") && iscmd(mode, FLOW)) {
		  delete = 1;
	     } else if (!strcmp(argv[i]+1, "local") && iscmd(mode, FLOW)) {
		  local = 1;
	     } else if (!strcmp(argv[i]+1, "tunnel") &&
			(isencauth(mode) || mode == ENC_IP) && i+2 < argc) {
		  osrc.s_addr = inet_addr(argv[i+1]);
		  i++;
		  odst.s_addr = inet_addr(argv[i+1]);
		  i++;
	     } else if (!strcmp(argv[i]+1, "addr") &&
			iscmd(mode, FLOW) && i+4 < argc) {
		  osrc.s_addr = inet_addr(argv[i+1]); i++;
		  osmask.s_addr = inet_addr(argv[i+1]); i++;
		  odst.s_addr = inet_addr(argv[i+1]); i++;
		  odmask.s_addr = inet_addr(argv[i+1]); i++;
	     } else if (!strcmp(argv[i]+1, "transport") && 
			iscmd(mode, FLOW) && i+1 < argc) {
		  if (isalpha(argv[i+1][0])) {
			tp = getprotobyname(argv[i+1]);
			if (tp == NULL) {
				fprintf(stderr, "%s: unknown protocol %s\n", argv[0], argv[i+1]);
d701 43
a743 10
			}
			tproto = tp->p_proto;
			transportproto = argv[i+1];
		  } else {
		  	tproto = atoi(argv[i+1]);
			tp = getprotobynumber(tproto);
			if (tp == NULL)
				transportproto = "UNKNOWN";
			else
				transportproto = tp->p_name; /* This is static, but it doesn't matter for this application */
d745 206
a950 81
		  i++;
	     } else if (!strcmp(argv[i]+1, "sport") && 
			iscmd(mode, FLOW) && i+1 < argc) {
		  if (isalpha(argv[i+1][0])) {
			svp = getservbyname(argv[i+1], transportproto);
			if (svp == NULL) {
				fprintf(stderr, "%s: unknown service port %s for protocol %s\n", argv[0], argv[i+1], transportproto);
				exit(1);
			}
			sport = svp->s_port;
		  } else
		  	sport = atoi(argv[i+1]);
		  i++;
	     } else if (!strcmp(argv[i]+1, "dport") && 
			iscmd(mode, FLOW) && i+1 < argc) {
		  if (isalpha(argv[i+1][0])) {
			svp = getservbyname(argv[i+1], transportproto);
			if (svp == NULL) {
				fprintf(stderr, "%s: unknown service port %s for protocol %s\n", argv[0], argv[i+1], transportproto);
				exit(1);
			}
			dport = svp->s_port;
		  } else
		  	dport = atoi(argv[i+1]);
		  i++;
	     } else if (!strcmp(argv[i]+1, "dst") && i+1 < argc) {
		  dst.s_addr = inet_addr(argv[i+1]);
		  i++;
	     } else if (!strcmp(argv[i]+1, "dst2") && 
			iscmd(mode, GRP_SPI) && i+1 < argc) {
		  dst2.s_addr = inet_addr(argv[i+1]);
		  i++;
	     } else if (!strcmp(argv[i]+1, "proto") && i+1 < argc) {
		  if (isalpha(argv[i+1][0])) {
			if (!strcasecmp(argv[i+1], "esp"))
			 	proto = IPPROTO_ESP;
			else if (!strcasecmp(argv[i+1], "ah"))
				proto = IPPROTO_AH;
			else if (!strcasecmp(argv[i+1], "ip4"))
				proto = IPPROTO_IPIP;
			else {
				fprintf(stderr, "%s: unknown security protocol type %s\n", argv[0], argv[i+1]);
				exit(1);
			}
		  } else {
		  	proto = atoi(argv[i+1]);
			if (proto != IPPROTO_ESP && proto != IPPROTO_AH &&
			    proto != IPPROTO_IPIP) {
				fprintf(stderr, "%s: unknown security protocol %d\n", argv[0], proto);
				exit(1);
			}
		  }
		  i++;
	     } else if (!strcmp(argv[i]+1, "proto2") && 
			iscmd(mode, GRP_SPI) && i+1 < argc) {
		  if (isalpha(argv[i+1][0])) {
			if (!strcasecmp(argv[i+1], "esp"))
			 	proto2 = IPPROTO_ESP;
			else if (!strcasecmp(argv[i+1], "ah"))
				proto2 = IPPROTO_AH;
			else if (!strcasecmp(argv[i+1], "ip4"))
				proto2 = IPPROTO_IPIP;
			else {
				fprintf(stderr, "%s: unknown security protocol2 type %s\n", argv[0], argv[i+1]);
				exit(1);
			}
		  } else
		  	proto2 = atoi(argv[i+1]);
			if (proto2 != IPPROTO_ESP && proto2 != IPPROTO_AH &&
			    proto2 != IPPROTO_IPIP) {
				fprintf(stderr, "%s: unknown security protocol %d\n", argv[0], proto);
				exit(1);
			}
		  i++;
	     } else if (!strcmp(argv[i]+1, "chain") && chain == 0 &&
			iscmd(mode, DEL_SPI)) {
		  chain = 1;
	     } else {
		  fprintf(stderr, "%s: Unkown option: %s\n", argv[0], argv[i]);
		  exit(1);
	     }
d953 91
a1044 84
	/* Sanity checks */
	if ((mode & (ESP_NEW|ESP_OLD)) && enc == 0) {
	     fprintf(stderr, "%s: No encryption algorithm specified\n", 
		     argv[0]);
	     exit(1);
	} else if ((mode & (AH_NEW|AH_OLD)) && auth == 0) {
	     fprintf(stderr, "%s: No authenication algorithm specified\n", 
		     argv[0]);
	     exit(1);
	} else if (isencauth(mode) && keyp == NULL) {
	     fprintf(stderr, "%s: No key material specified\n", argv[0]);
	     exit(1);
	} else if ((mode & ESP_NEW) && auth && authp == NULL) {
	     fprintf(stderr, "%s: No auth key material specified\n", argv[0]);
	     exit(1);
	} else if (spi == 0) {
	     fprintf(stderr, "%s: No SPI specified\n", argv[0]);
	     exit(1);
	} else if (iscmd(mode, GRP_SPI) && spi2 == 0) {
	     fprintf(stderr, "%s: No SPI2 specified\n", argv[0]);
	     exit(1);
	} else if ((isencauth(mode) || iscmd(mode, ENC_IP)) && 
		    src.s_addr == 0) {
	     fprintf(stderr, "%s: No source address specified\n", argv[0]);
	     exit(1);
	} else if ((iscmd(mode, DEL_SPI) || iscmd(mode, GRP_SPI) || 
		   iscmd(mode, FLOW)) && 
		   proto != IPPROTO_ESP && proto != IPPROTO_AH &&
		   proto != IPPROTO_IPIP) {
	     fprintf(stderr, "%s: Security protocol is none of AH, ESP or IPIP\n", argv[0]);
	     exit(1);
	} else if (iscmd(mode, GRP_SPI) && 
		   proto2 != IPPROTO_ESP && proto2 != IPPROTO_AH &&
		   proto2 != IPPROTO_IPIP) {
	     fprintf(stderr, "%s: Security protocol2 is none of AH, ESP or IPIP\n", argv[0]);
	     exit(1);
	} else if (dst.s_addr == 0) {
	     fprintf(stderr, "%s: No destination address specified\n", 
		     argv[0]);
	     exit(1);
	} else if (iscmd(mode, ENC_IP) && 
		   (odst.s_addr == 0 || osrc.s_addr == 0)) {
	     fprintf(stderr, "%s: No tunnel addresses specified\n", 
		     argv[0]);
	     exit(1);
	} else if (iscmd(mode, FLOW) && 
		   (odst.s_addr == 0 && odmask.s_addr == 0 && 
		    osrc.s_addr == 0 && osmask.s_addr == 0)) {
	     fprintf(stderr, "%s: No subnets for flow specified\n", 
		     argv[0]);
	     exit(1);
	} else if (iscmd(mode, GRP_SPI) && dst2.s_addr == 0) {
	     fprintf(stderr, "%s: No destination address2 specified\n", 
		     argv[0]);
	     exit(1);
	}

	if (isencauth(mode)) {
	     switch(mode) {
	     case ESP_NEW:
		  result = xf_esp_new(src, dst, spi, enc, auth, ivp, keyp,
				     authp, osrc, odst, newpadding);
		  break;
	     case ESP_OLD:
		  result = xf_esp_old(src, dst, spi, enc, ivp, keyp, osrc, odst);
		  break;
	     case AH_NEW:
		  result = xf_ah_new(src, dst, spi, auth, keyp, osrc, odst);
		  break;
	     case AH_OLD:
		  result = xf_ah_old(src, dst, spi, auth, keyp, osrc, odst);
		  break;
	     }
	} else {
	     switch(mode & CMD_MASK) {
	     case GRP_SPI:
		  result = xf_grp(dst, spi, proto, dst2, spi2, proto2);
		  break;
	     case DEL_SPI:
		  result = xf_delspi(dst, spi, proto, chain);
		  break;
	     case ENC_IP:
		  result = xf_ip4(src, dst, spi, osrc, odst);
		  break;
d1046 56
a1101 4
		  result = xf_flow(dst, spi, proto, osrc, osmask, odst, odmask,
				  tproto, sport, dport, delete, local);
		  break;
	     }
d1103 1
d1105 2
a1106 1
	exit (result ? 0 : 1);
d1108 1
@


1.2
log
@Verify that keys and IVs are in hex.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.1 1998/11/14 23:37:20 deraadt Exp $ */
d106 1
@


1.1
log
@move ipsec tools into .
@
text
@d1 1
a1 1
/* $OpenBSD: ipsecadm.c,v 1.20 1998/08/01 06:19:27 angelos Exp $ */
d121 5
@

