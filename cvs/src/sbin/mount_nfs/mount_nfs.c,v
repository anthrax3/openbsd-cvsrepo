head	1.53;
access;
symbols
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.2
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.52.0.4
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.52.0.6
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.51.0.4
	OPENBSD_5_6_BASE:1.51
	OPENBSD_5_5:1.50.0.10
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.50.0.6
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.4
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.10
	OPENBSD_5_0:1.49.0.8
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.6
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.47.0.10
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.8
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.6
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.47.0.4
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.45.0.2
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.44.0.4
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	OPENBSD_3_3:1.29.0.4
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.17.0.4
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.15.0.4
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2016.05.27.19.45.04;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	nQEqvpt7rKDi6fz0;

1.52
date	2015.01.16.06.39.59;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	Uu5nFG3wCl0LACBb;

1.51
date	2014.05.21.06.23.01;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2012.05.29.20.04.59;	author jasper;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.12.23.25.08;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.10.17.30.34;	author grunk;	state Exp;
branches;
next	1.46;

1.46
date	2006.11.03.15.38.38;	author grunk;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.28.20.02.49;	author sturm;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.29.20.50.37;	author jaredy;	state Exp;
branches;
next	1.43;

1.43
date	2005.04.08.20.09.37;	author jaredy;	state Exp;
branches;
next	1.42;

1.42
date	2004.09.15.07.10.32;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.20.07.12.00;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.16.00.11.10;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.22.21.12.00;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.18.11.07.53;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.18.10.54.08;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.07.18.35.57;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.06.20.52.40;	author avsm;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.03.22.41.40;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.11.06.22.14;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.29.16.12.17;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.21.21.16.07;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.21.27.36;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.01.19.13.48;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.03.18.50.07;	author hin;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.13.18.19.24;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.07.18.26.15;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.07.00.19.52;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.24.17.03.19;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.11.18.09.08;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.30.16.00.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.06.17.20.53.28;	author millert;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	99.05.31.17.26.12;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.05.16.06.28.00;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.11.11.18.36.38;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.08.20.05.10.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.08.18.03.11.24;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.06.29.11.10.31;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.06.25.18.23.59;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.04.20.15.37.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.12.10.33.23;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.12.10.28.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.28.12.37.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.08.08.53.03;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.23.46.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.21.00.16.03;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.00.23.49;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.40;	author deraadt;	state Exp;
branches;
next	;

1.17.4.1
date	2000.10.06.20.40.27;	author jason;	state Exp;
branches;
next	;


desc
@@


1.53
log
@W^X violations are no longer permitted by default.  A kernel log message
is generated, and mprotect/mmap return ENOTSUP.  If the sysctl(8) flag
kern.wxabort is set then a SIGABRT occurs instead, for gdb use or coredump
creation.

W^X violating programs can be permitted on a ffs/nfs filesystem-basis,
using the "wxallowed" mount option.  One day far in the future
upstream software developers will understand that W^X violations are a
tremendously risky practice and that style of programming will be
banished outright.  Until then, we recommend most users need to use the
wxallowed option on their /usr/local filesystem.  At least your other
filesystems don't permit such programs.

ok jca kettenis mlarkin natano
@
text
@/*	$OpenBSD: mount_nfs.c,v 1.52 2015/01/16 06:39:59 deraadt Exp $	*/
/*	$NetBSD: mount_nfs.c,v 1.12.4.1 1996/05/25 22:48:05 fvdl Exp $	*/

/*
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/stat.h>
#include <syslog.h>

#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#include <rpc/pmap_prot.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>

#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "mntopts.h"

#define	ALTF_BG		0x1
#define ALTF_NOCONN	0x2
#define ALTF_DUMBTIMR	0x4
#define ALTF_INTR	0x8
#define ALTF_NFSV3	0x20
#define ALTF_RDIRPLUS	0x40
#define	ALTF_MNTUDP	0x80
#define ALTF_RESVPORT	0x100
#define ALTF_SEQPACKET	0x200
#define ALTF_SOFT	0x800
#define ALTF_TCP	0x1000
#define ALTF_PORT	0x2000
#define ALTF_NFSV2	0x4000
#define ALTF_NOAC       0x8000
#define ALTF_ACREGMIN	0x10000
#define ALTF_ACREGMAX	0x20000
#define ALTF_ACDIRMIN	0x40000
#define ALTF_ACDIRMAX	0x80000

const struct mntopt mopts[] = {
	MOPT_STDOPTS,
	MOPT_WXALLOWED,
	MOPT_FORCE,
	MOPT_UPDATE,
	MOPT_SYNC,
	{ "bg", ALTF_BG, 0 },
	{ "conn", ALTF_NOCONN, MFLAG_INVERSE },
	{ "dumbtimer", ALTF_DUMBTIMR, 0 },
	{ "intr", ALTF_INTR, 0 },
	{ "nfsv3", ALTF_NFSV3, 0 },
	{ "rdirplus", ALTF_RDIRPLUS, 0 },
	{ "mntudp", ALTF_MNTUDP, 0 },
	{ "resvport", ALTF_RESVPORT, 0 },
	{ "soft", ALTF_SOFT, 0 },
	{ "tcp", ALTF_TCP, 0 },
	{ "port", ALTF_PORT, MFLAG_INTVAL },
	{ "nfsv2", ALTF_NFSV2, 0 },
	{ "ac", ALTF_NOAC, MFLAG_INVERSE },
	{ "acregmin", ALTF_ACREGMIN, MFLAG_INTVAL },
	{ "acregmax", ALTF_ACREGMAX, MFLAG_INTVAL },
	{ "acdirmin", ALTF_ACDIRMIN, MFLAG_INTVAL },
	{ "acdirmax", ALTF_ACDIRMAX, MFLAG_INTVAL },
	{ NULL }
};

struct nfs_args nfsdefargs = {
	NFS_ARGSVERSION,
	NULL,
	sizeof (struct sockaddr_in),
	SOCK_DGRAM,
	0,
	NULL,
	0,
	NFSMNT_NFSV3,
	NFS_WSIZE,
	NFS_RSIZE,
	NFS_READDIRSIZE,
	10,
	NFS_RETRANS,
	NFS_MAXGRPS,
	NFS_DEFRAHEAD,
	0,
	0,
	NULL,
	0,
	0,
	0,
	0
};

struct nfhret {
	u_long		stat;
	long		vers;
	long		auth;
	long		fhsize;
	u_char		nfh[NFSX_V3FHMAX];
};
#define	DEF_RETRY	10000
#define	BGRND	1
#define	ISBGRND	2
int retrycnt;
int opflags = 0;
int nfsproto = IPPROTO_UDP;
int mnttcp_ok = 1;
u_short port_no = 0;
int force2 = 0;
int force3 = 0;

int	getnfsargs(char *, struct nfs_args *);
void	set_rpc_maxgrouplist(int);
__dead	void usage(void);
int	xdr_dir(XDR *, char *);
int	xdr_fh(XDR *, struct nfhret *);

int
main(int argc, char *argv[])
{
	int c;
	struct nfs_args *nfsargsp;
	struct nfs_args nfsargs;
	int mntflags, num;
	char name[PATH_MAX], *options = NULL, *spec;
	const char *p;
	union mntval value;

	retrycnt = DEF_RETRY;

	mntflags = 0;
	nfsargs = nfsdefargs;
	nfsargsp = &nfsargs;
	while ((c = getopt(argc, argv,
	    "23a:bcdD:g:I:iL:lo:PR:r:sTt:w:x:U")) != -1)
		switch (c) {
		case '3':
			if (force2)
				errx(1, "-2 and -3 are mutually exclusive");
			force3 = 1;
			break;
		case '2':
			if (force3)
				errx(1, "-2 and -3 are mutually exclusive");
			force2 = 1;
			nfsargsp->flags &= ~NFSMNT_NFSV3;
			break;
		case 'a':
			num = (int) strtonum(optarg, 0, 4, &p);
			if (p)
				errx(1, "illegal -a value %s: %s", optarg, p);
			nfsargsp->readahead = num;
			nfsargsp->flags |= NFSMNT_READAHEAD;
			break;
		case 'b':
			opflags |= BGRND;
			break;
		case 'c':
			nfsargsp->flags |= NFSMNT_NOCONN;
			break;
		case 'D':
			/* backward compatibility */
			break;
		case 'd':
			nfsargsp->flags |= NFSMNT_DUMBTIMR;
			break;
		case 'g':
			num = (int) strtonum(optarg, 1, NGROUPS_MAX, &p);
			if (p)
				errx(1, "illegal -g value %s: %s", optarg, p);
			set_rpc_maxgrouplist(num);
			nfsargsp->maxgrouplist = num;
			nfsargsp->flags |= NFSMNT_MAXGRPS;
			break;
		case 'I':
			num = (int) strtonum(optarg, 1, INT_MAX, &p);
			if (p)
				errx(1, "illegal -I value %s: %s", optarg, p);
			nfsargsp->readdirsize = num;
			nfsargsp->flags |= NFSMNT_READDIRSIZE;
			break;
		case 'i':
			nfsargsp->flags |= NFSMNT_INT;
			break;
		case 'L':
			/* backward compatibility */
			break;
		case 'l':
			nfsargsp->flags |= NFSMNT_RDIRPLUS;
			break;
		case 'o':
			options = optarg;
			while (options != NULL) {
				switch (getmntopt(&options, &value, mopts,
				    &mntflags)) {
				case ALTF_BG:
					opflags |= BGRND;
					break;
				case ALTF_NOCONN:
					nfsargsp->flags |= NFSMNT_NOCONN;
					break;
				case ALTF_DUMBTIMR:
					nfsargsp->flags |= NFSMNT_DUMBTIMR;
					break;
				case ALTF_INTR:
					nfsargsp->flags |= NFSMNT_INT;
					break;
				case ALTF_NFSV3:
					if (force2)
						errx(1,
						    "conflicting version options");
					force3 = 1;
					break;
				case ALTF_NFSV2:
					if (force3)
						errx(1,
						    "conflicting version options");
					force2 = 1;
					nfsargsp->flags &= ~NFSMNT_NFSV3;
					break;
				case ALTF_RDIRPLUS:
					nfsargsp->flags |= NFSMNT_RDIRPLUS;
					break;
				case ALTF_MNTUDP:
					mnttcp_ok = 0;
					break;
				case ALTF_RESVPORT:
					nfsargsp->flags |= NFSMNT_RESVPORT;
					break;
				case ALTF_SOFT:
					nfsargsp->flags |= NFSMNT_SOFT;
					break;
				case ALTF_TCP:
					nfsargsp->sotype = SOCK_STREAM;
					nfsproto = IPPROTO_TCP;
					break;
				case ALTF_PORT:
					port_no = value.ival;
					break;
				case ALTF_NOAC:
					nfsargsp->flags |= (NFSMNT_ACREGMIN |
					    NFSMNT_ACREGMAX | NFSMNT_ACDIRMIN |
					    NFSMNT_ACDIRMAX);
					nfsargsp->acregmin = 0;
					nfsargsp->acregmax = 0;
					nfsargsp->acdirmin = 0;
					nfsargsp->acdirmax = 0;
					break;
				case ALTF_ACREGMIN:
					nfsargsp->flags |= NFSMNT_ACREGMIN;
					nfsargsp->acregmin = value.ival;
					break;
				case ALTF_ACREGMAX:
					nfsargsp->flags |= NFSMNT_ACREGMAX;
					nfsargsp->acregmax = value.ival;
					break;
				case ALTF_ACDIRMIN:
					nfsargsp->flags |= NFSMNT_ACDIRMIN;
					nfsargsp->acdirmin = value.ival;
					break;
				case ALTF_ACDIRMAX:
					nfsargsp->flags |= NFSMNT_ACDIRMAX;
					nfsargsp->acdirmax = value.ival;
					break;
				}
			}
			break;
		case 'P':
			/* backward compatibility */
			break;
		case 'R':
			num = (int) strtonum(optarg, 1, INT_MAX, &p);
			if (p)
				errx(1, "illegal -R value %s: %s", optarg, p);
			retrycnt = num;
			break;
		case 'r':
			num = (int) strtonum(optarg, 1, INT_MAX, &p);
			if (p)
				errx(1, "illegal -r value %s: %s", optarg, p);
			nfsargsp->rsize = num;
			nfsargsp->flags |= NFSMNT_RSIZE;
			break;
		case 's':
			nfsargsp->flags |= NFSMNT_SOFT;
			break;
		case 'T':
			nfsargsp->sotype = SOCK_STREAM;
			nfsproto = IPPROTO_TCP;
			break;
		case 't':
			num = (int) strtonum(optarg, 1, INT_MAX, &p);
			if (p)
				errx(1, "illegal -t value %s: %s", optarg, p);
			nfsargsp->timeo = num;
			nfsargsp->flags |= NFSMNT_TIMEO;
			break;
		case 'w':
			num = (int) strtonum(optarg, 1, INT_MAX, &p);
			if (p)
				errx(1, "illegal -w value %s: %s", optarg, p);
			nfsargsp->wsize = num;
			nfsargsp->flags |= NFSMNT_WSIZE;
			break;
		case 'x':
			num = (int) strtonum(optarg, 1, INT_MAX, &p);
			if (p)
				errx(1, "illegal -x value %s: %s", optarg, p);
			nfsargsp->retrans = num;
			nfsargsp->flags |= NFSMNT_RETRANS;
			break;
		case 'U':
			mnttcp_ok = 0;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	argc -= optind;
	argv += optind;

	if (argc != 2)
		usage();

	spec = *argv++;
	if (realpath(*argv, name) == NULL)
		err(1, "realpath %s", *argv);

	if (!getnfsargs(spec, nfsargsp))
		exit(1);
	if (mount(MOUNT_NFS, name, mntflags, nfsargsp)) {
		if (errno == EOPNOTSUPP)
			errx(1, "%s: Filesystem not supported by kernel", name);
		else
			err(1, "%s", name);
	}
	exit(0);
}

int
getnfsargs(char *spec, struct nfs_args *nfsargsp)
{
	CLIENT *clp;
	struct hostent *hp;
	static struct sockaddr_in saddr;
	struct timeval pertry, try;
	enum clnt_stat clnt_stat;
	int so = RPC_ANYSOCK, i, nfsvers, mntvers, orgcnt;
	char *hostp, *delimp;
	u_short tport;
	static struct nfhret nfhret;
	static char nam[MNAMELEN + 1];

	if (strlcpy(nam, spec, sizeof(nam)) >= sizeof(nam)) {
		errx(1, "hostname too long");
	}

	if ((delimp = strchr(spec, '@@')) != NULL) {
		hostp = delimp + 1;
	} else if ((delimp = strchr(spec, ':')) != NULL) {
		hostp = spec;
		spec = delimp + 1;
	} else {
		warnx("no <host>:<dirpath> or <dirpath>@@<host> spec");
		return (0);
	}
	*delimp = '\0';

	/*
	 * Handle an internet host address
	 */
	if (inet_aton(hostp, &saddr.sin_addr) == 0) {
		hp = gethostbyname(hostp);
		if (hp == NULL) {
			warnx("can't resolve address for host %s", hostp);
			return (0);
		}
		memcpy(&saddr.sin_addr, hp->h_addr, hp->h_length);
	}

	if (force2) {
		nfsvers = NFS_VER2;
		mntvers = RPCMNT_VER1;
	} else {
		nfsvers = NFS_VER3;
		mntvers = RPCMNT_VER3;
	}
	orgcnt = retrycnt;
tryagain:
	nfhret.stat = EACCES;	/* Mark not yet successful */
	while (retrycnt > 0) {
		saddr.sin_family = AF_INET;
		saddr.sin_port = htons(PMAPPORT);
		if ((tport = port_no ? port_no : pmap_getport(&saddr,
		    RPCPROG_NFS, nfsvers, nfsargsp->sotype == SOCK_STREAM ?
		    IPPROTO_TCP : IPPROTO_UDP)) == 0) {
			if ((opflags & ISBGRND) == 0)
				clnt_pcreateerror("NFS Portmap");
		} else {
			saddr.sin_port = 0;
			pertry.tv_sec = 10;
			pertry.tv_usec = 0;
			if (mnttcp_ok && nfsargsp->sotype == SOCK_STREAM)
			    clp = clnttcp_create(&saddr, RPCPROG_MNT, mntvers,
				&so, 0, 0);
			else
			    clp = clntudp_create(&saddr, RPCPROG_MNT, mntvers,
				pertry, &so);
			if (clp == NULL) {
				if ((opflags & ISBGRND) == 0)
					clnt_pcreateerror("Cannot MNT RPC");
			} else {
				clp->cl_auth = authunix_create_default();
				try.tv_sec = 10;
				try.tv_usec = 0;
				nfhret.auth = RPCAUTH_UNIX;
				nfhret.vers = mntvers;
				clnt_stat = clnt_call(clp, RPCMNT_MOUNT,
				    xdr_dir, spec, xdr_fh, &nfhret, try);
				if (clnt_stat != RPC_SUCCESS) {
					if (clnt_stat == RPC_PROGVERSMISMATCH) {
						if (nfsvers == NFS_VER3 &&
						    !force3) {
							retrycnt = orgcnt;
							nfsvers = NFS_VER2;
							mntvers = RPCMNT_VER1;
							nfsargsp->flags &=
							    ~NFSMNT_NFSV3;
							goto tryagain;
						} else {
							warnx("%s",
							    clnt_sperror(clp,
								"MNT RPC"));
						}
					}
					if ((opflags & ISBGRND) == 0)
						warnx("%s", clnt_sperror(clp,
						    "bad MNT RPC"));
				} else {
					auth_destroy(clp->cl_auth);
					clnt_destroy(clp);
					retrycnt = 0;
				}
			}
		}
		if (--retrycnt > 0) {
			if (opflags & BGRND) {
				opflags &= ~BGRND;
				if ((i = fork())) {
					if (i == -1)
						err(1, "fork");
					exit(0);
				}
				(void) setsid();
				(void) close(STDIN_FILENO);
				(void) close(STDOUT_FILENO);
				(void) close(STDERR_FILENO);
				(void) chdir("/");
				opflags |= ISBGRND;
			}
			sleep(60);
		}
	}
	if (nfhret.stat) {
		if (opflags & ISBGRND)
			exit(1);
		warnc(nfhret.stat, "can't access %s", spec);
		return (0);
	}
	saddr.sin_port = htons(tport);
	nfsargsp->addr = (struct sockaddr *) &saddr;
	nfsargsp->addrlen = sizeof (saddr);
	nfsargsp->fh = nfhret.nfh;
	nfsargsp->fhsize = nfhret.fhsize;
	nfsargsp->hostname = nam;
	return (1);
}

/*
 * xdr routines for mount rpc's
 */
int
xdr_dir(XDR *xdrsp, char *dirp)
{
	return (xdr_string(xdrsp, &dirp, RPCMNT_PATHLEN));
}

int
xdr_fh(XDR *xdrsp, struct nfhret *np)
{
	int i;
	long auth, authcnt, authfnd = 0;

	if (!xdr_u_long(xdrsp, &np->stat))
		return (0);
	if (np->stat)
		return (1);
	switch (np->vers) {
	case 1:
		np->fhsize = NFSX_V2FH;
		return (xdr_opaque(xdrsp, (caddr_t)np->nfh, NFSX_V2FH));
	case 3:
		if (!xdr_long(xdrsp, &np->fhsize))
			return (0);
		if (np->fhsize <= 0 || np->fhsize > NFSX_V3FHMAX)
			return (0);
		if (!xdr_opaque(xdrsp, (caddr_t)np->nfh, np->fhsize))
			return (0);
		if (!xdr_long(xdrsp, &authcnt))
			return (0);
		for (i = 0; i < authcnt; i++) {
			if (!xdr_long(xdrsp, &auth))
				return (0);
			if (auth == np->auth)
				authfnd++;
		}
		/*
		 * Some servers, such as DEC's OSF/1 return a nil authenticator
		 * list to indicate RPCAUTH_UNIX.
		 */
		if (!authfnd && (authcnt > 0 || np->auth != RPCAUTH_UNIX))
			np->stat = EAUTH;
		return (1);
	};
	return (0);
}

__dead void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr,
	    "usage: %s [-23bcdilsTU] [-a maxreadahead] [-g maxgroups]\n"
	    "\t[-I readdirsize] [-o options] [-R retrycnt] [-r readsize]\n"
	    "\t[-t timeout] [-w writesize] [-x retrans] rhost:path node\n",
	    __progname);
	exit(1);
}
@


1.52
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.51 2014/05/21 06:23:01 guenther Exp $	*/
d88 1
@


1.51
log
@Use errc/warnc to simplify code.

ok jca@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.50 2012/05/29 20:04:59 jasper Exp $	*/
d36 1
a36 1
#include <sys/param.h>
d63 1
d167 1
a167 1
	char name[MAXPATHLEN], *options = NULL, *spec;
@


1.50
log
@Fix tyop in error message; this was copied from/to umount(8)'s umount.c which was just fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.49 2009/10/27 23:59:33 deraadt Exp $	*/
d508 1
a508 2
		errno = nfhret.stat;
		warnx("can't access %s: %s", spec, strerror(nfhret.stat));
@


1.49
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.48 2009/05/12 23:25:08 thib Exp $	*/
d452 1
a452 1
					clnt_pcreateerror("Cannot MNT PRC");
@


1.48
log
@don't define _KERNEL. Theres no need and its gross.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.47 2006/11/10 17:30:34 grunk Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1992, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)mount_nfs.c	8.11 (Berkeley) 5/4/95";
#else
static char rcsid[] = "$NetBSD: mount_nfs.c,v 1.12.4.1 1996/05/25 22:48:05 fvdl Exp $";
#endif
#endif /* not lint */
@


1.47
log
@enable -g again

help from millert@@, ok deraadt@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.46 2006/11/03 15:38:38 grunk Exp $	*/
a62 1
#define _KERNEL
a63 1
#undef _KERNEL
@


1.46
log
@storing return value of strtol() in int variable was not safe,
also strtol() result was not checked for under/overflow

thus, rewrite getopt switch/cases with strtonum() and sensible bounds

help from mickey@@ millert@@, ok millert@@, no objections otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.45 2006/07/28 20:02:49 sturm Exp $	*/
a223 1
#if 0 /* XXXX */
a231 1
#endif
@


1.45
log
@permit synchronous mounts

ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.44 2005/06/29 20:50:37 jaredy Exp $	*/
d182 2
a183 1
	char name[MAXPATHLEN], *options = NULL, *p, *spec;
d206 3
a208 3
			num = strtol(optarg, &p, 10);
			if (*p || num < 0)
				errx(1, "illegal -a value -- %s", optarg);
d226 3
a228 3
			num = strtol(optarg, &p, 10);
			if (*p || num <= 0)
				errx(1, "illegal -g value -- %s", optarg);
d235 3
a237 3
			num = strtol(optarg, &p, 10);
			if (*p || num <= 0)
				errx(1, "illegal -I value -- %s", optarg);
d331 3
a333 3
			num = strtol(optarg, &p, 10);
			if (*p || num <= 0)
				errx(1, "illegal -R value -- %s", optarg);
d337 3
a339 3
			num = strtol(optarg, &p, 10);
			if (*p || num <= 0)
				errx(1, "illegal -r value -- %s", optarg);
d351 3
a353 3
			num = strtol(optarg, &p, 10);
			if (*p || num <= 0)
				errx(1, "illegal -t value -- %s", optarg);
d358 3
a360 3
			num = strtol(optarg, &p, 10);
			if (*p || num <= 0)
				errx(1, "illegal -w value -- %s", optarg);
d365 3
a367 3
			num = strtol(optarg, &p, 10);
			if (*p || num <= 0)
				errx(1, "illegal -x value -- %s", optarg);
@


1.44
log
@ignore (but still accept) -D and -L

(and other minor cleaning while here:
sync usage, whitespace, fix error messages)

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.43 2005/04/08 20:09:37 jaredy Exp $	*/
d105 1
@


1.43
log
@Sync with recent realpath(3) changes:  on failure, don't use the second
argument "resolved", since it is undefined.

ok and help millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.42 2004/09/15 07:10:32 miod Exp $	*/
d190 1
a190 1
	    "23a:bcdD:g:I:iL:lo:PpqR:r:sTt:w:x:U")) != -1)
d217 1
a217 5
			num = strtol(optarg, &p, 10);
			if (*p || num <= 0)
				errx(1, "illegal -D value -- %s", optarg);
			nfsargsp->deadthresh = num;
			nfsargsp->flags |= NFSMNT_DEADTHRESH;
d243 1
a243 5
			num = strtol(optarg, &p, 10);
			if (*p || num < 2)
				errx(1, "illegal -L value -- %s", optarg);
			nfsargsp->leaseterm = num;
			nfsargsp->flags |= NFSMNT_LEASETERM;
d326 1
a326 1
			nfsargsp->flags |= NFSMNT_RESVPORT;
d374 1
a374 1
			break;
d485 1
a485 1
								~NFSMNT_NFSV3;
d488 1
a488 1
							fprintf(stderr, "%s",
d508 1
a508 1
						err(1, "nqnfs 2");
d589 7
a595 5
	(void)fprintf(stderr, "usage: mount_nfs %s\n%s\n%s\n%s\n",
	    "[-23PTUbcdilqs] [-a maxreadahead] [-D deadthresh]",
	    "\t[-I readdirsize] [-g maxgroups] [-L leaseterm] [-o options]",
	    "\t[-R retrycnt] [-r readsize] [-t timeout] [-w writesize] [-x retrans]",
	    "\trhost:path node");
@


1.42
log
@Restore correct noac option parsing.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.41 2004/08/20 07:12:00 otto Exp $	*/
d392 1
a392 1
		err(1, "realpath %s", name);
@


1.41
log
@Unbreak processing of options when given a command line with multiple
-o options. All of them are relevant, not only the last one.

ok miod@@ claudio@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.40 2004/07/16 00:11:10 henning Exp $	*/
d117 1
a117 1
	{ "ac", ALTF_NOAC, 0 },
@


1.40
log
@remove netiso traces, millert deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.39 2004/06/22 21:12:00 otto Exp $	*/
d258 74
a388 75

	/* parse -o options */
	while (options != NULL) {
		switch (getmntopt(&options, &value, mopts, &mntflags)) {
		case ALTF_BG:
			opflags |= BGRND;
			break;
		case ALTF_NOCONN:
			nfsargsp->flags |= NFSMNT_NOCONN;
			break;
		case ALTF_DUMBTIMR:
			nfsargsp->flags |= NFSMNT_DUMBTIMR;
			break;
		case ALTF_INTR:
			nfsargsp->flags |= NFSMNT_INT;
			break;
		case ALTF_NFSV3:
			if (force2)
				errx(1,
				    "conflicting version options");
			force3 = 1;
			break;
		case ALTF_NFSV2:
			if (force3)
				errx(1,
				    "conflicting version options");
			force2 = 1;
			nfsargsp->flags &= ~NFSMNT_NFSV3;
			break;
		case ALTF_RDIRPLUS:
			nfsargsp->flags |= NFSMNT_RDIRPLUS;
			break;
		case ALTF_MNTUDP:
			mnttcp_ok = 0;
			break;
		case ALTF_RESVPORT:
			nfsargsp->flags |= NFSMNT_RESVPORT;
			break;
		case ALTF_SOFT:
			nfsargsp->flags |= NFSMNT_SOFT;
			break;
		case ALTF_TCP:
			nfsargsp->sotype = SOCK_STREAM;
			nfsproto = IPPROTO_TCP;
			break;
		case ALTF_PORT:
			port_no = value.ival;
			break;
		case ALTF_NOAC:
			nfsargsp->flags |= (NFSMNT_ACREGMIN |
			    NFSMNT_ACREGMAX | NFSMNT_ACDIRMIN |
			    NFSMNT_ACDIRMAX);
			nfsargsp->acregmin = 0;
			nfsargsp->acregmax = 0;
			nfsargsp->acdirmin = 0;
			nfsargsp->acdirmax = 0;
			break;
		case ALTF_ACREGMIN:
			nfsargsp->flags |= NFSMNT_ACREGMIN;
			nfsargsp->acregmin = value.ival;
			break;
		case ALTF_ACREGMAX:
			nfsargsp->flags |= NFSMNT_ACREGMAX;
			nfsargsp->acregmax = value.ival;
			break;
		case ALTF_ACDIRMIN:
			nfsargsp->flags |= NFSMNT_ACDIRMIN;
			nfsargsp->acdirmin = value.ival;
			break;
		case ALTF_ACDIRMAX:
			nfsargsp->flags |= NFSMNT_ACDIRMAX;
			nfsargsp->acdirmax = value.ival;
			break;
		}
	}
@


1.39
log
@Rewrite of getmntopts(), making it more robust and getting rid of
the mount_nfs alternative implementation of the same function. Joint
work with millert@@. Fixes PR 3642.

ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.38 2004/05/18 11:07:53 otto Exp $	*/
a60 4
#ifdef ISO
#include <netiso/iso.h>
#endif

a112 3
#ifdef ISO
	{ "seqpacket", ALTF_SEQPACKET, 0 },
#endif
a168 3
#ifdef ISO
struct	iso_addr *iso_addr(const char *);
#endif
a261 5
#ifdef ISO
		case 'p':
			nfsargsp->sotype = SOCK_SEQPACKET;
			break;
#endif
a352 5
#ifdef ISO
		case ALTF_SEQPACKET:
			nfsargsp->sotype = SOCK_SEQPACKET;
			break;
#endif
a411 5
#ifdef ISO
	static struct sockaddr_iso isoaddr;
	struct iso_addr *isop;
	int isoflag = 0;
#endif
a433 29
	/*
	 * DUMB!! Until the mount protocol works on iso transport, we must
	 * supply both an iso and an inet address for the host.
	 */
#ifdef ISO
	if (!strncmp(hostp, "iso=", 4)) {
		u_short isoport;

		hostp += 4;
		isoflag++;
		if ((delimp = strchr(hostp, '+')) == NULL) {
			warnx("no iso+inet address");
			return (0);
		}
		*delimp = '\0';
		if ((isop = iso_addr(hostp)) == NULL) {
			warnx("bad ISO address");
			return (0);
		}
		memset(&isoaddr, 0, sizeof (isoaddr));
		memcpy(&isoaddr.siso_addr, isop, sizeof (struct iso_addr));
		isoaddr.siso_len = sizeof (isoaddr);
		isoaddr.siso_family = AF_ISO;
		isoaddr.siso_tlen = 2;
		isoport = htons(NFS_PORT);
		memcpy(TSEL(&isoaddr), &isoport, isoaddr.siso_tlen);
		hostp = delimp + 1;
	}
#endif /* ISO */
d538 2
a539 10
#ifdef ISO
	if (isoflag) {
		nfsargsp->addr = (struct sockaddr *) &isoaddr;
		nfsargsp->addrlen = sizeof (isoaddr);
	} else
#endif /* ISO */
	{
		nfsargsp->addr = (struct sockaddr *) &saddr;
		nfsargsp->addrlen = sizeof (saddr);
	}
@


1.38
log
@Backout changes accidentally committed in prvious commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.36 2003/10/07 18:35:57 henning Exp $	*/
d109 8
a116 8
	{ "bg", 0, ALTF_BG, 1 },
	{ "conn", 1, ALTF_NOCONN, 1 },
	{ "dumbtimer", 0, ALTF_DUMBTIMR, 1 },
	{ "intr", 0, ALTF_INTR, 1 },
	{ "nfsv3", 0, ALTF_NFSV3, 1 },
	{ "rdirplus", 0, ALTF_RDIRPLUS, 1 },
	{ "mntudp", 0, ALTF_MNTUDP, 1 },
	{ "resvport", 0, ALTF_RESVPORT, 1 },
d118 1
a118 1
	{ "seqpacket", 0, ALTF_SEQPACKET, 1 },
d120 9
a128 9
	{ "soft", 0, ALTF_SOFT, 1 },
	{ "tcp", 0, ALTF_TCP, 1 },
	{ "port", 0, ALTF_PORT, 1 },
	{ "nfsv2", 0, ALTF_NFSV2, 1 },
	{ "ac", 1, ALTF_NOAC, 1 },
	{ "acregmin", 0, ALTF_ACREGMIN, 1},
	{ "acregmax", 0, ALTF_ACREGMAX, 1},
	{ "acdirmin", 0, ALTF_ACDIRMIN, 1},
	{ "acdirmax", 0, ALTF_ACDIRMAX, 1},
d190 3
a192 2
	int mntflags, altflags, num;
	char name[MAXPATHLEN], *p, *spec;
a196 1
	altflags = 0;
d267 1
a267 68
			getmntopts(optarg, mopts, &mntflags, &altflags);
			if (altflags & ALTF_BG)
				opflags |= BGRND;
			if (altflags & ALTF_NOCONN)
				nfsargsp->flags |= NFSMNT_NOCONN;
			if (altflags & ALTF_DUMBTIMR)
				nfsargsp->flags |= NFSMNT_DUMBTIMR;
			if (altflags & ALTF_INTR)
				nfsargsp->flags |= NFSMNT_INT;
			if (altflags & ALTF_NFSV3) {
				if (force2)
					errx(1,"conflicting version options");
				force3 = 1;
			}
			if (altflags & ALTF_NFSV2) {
				if (force3)
					errx(1,"conflicting version options");
				force2 = 1;
				nfsargsp->flags &= ~NFSMNT_NFSV3;
			}
			if (altflags & ALTF_RDIRPLUS)
				nfsargsp->flags |= NFSMNT_RDIRPLUS;
			if (altflags & ALTF_MNTUDP)
				mnttcp_ok = 0;
			if (altflags & ALTF_RESVPORT)
				nfsargsp->flags |= NFSMNT_RESVPORT;
#ifdef ISO
			if (altflags & ALTF_SEQPACKET)
				nfsargsp->sotype = SOCK_SEQPACKET;
#endif
			if (altflags & ALTF_SOFT)
				nfsargsp->flags |= NFSMNT_SOFT;
			if (altflags & ALTF_TCP) {
				nfsargsp->sotype = SOCK_STREAM;
				nfsproto = IPPROTO_TCP;
			}
			if (altflags & ALTF_PORT)
				port_no = atoi(strstr(optarg, "port=") + 5);
			if (altflags & ALTF_NOAC) {
				nfsargsp->flags
				    |= (NFSMNT_ACREGMIN | NFSMNT_ACREGMAX |
					NFSMNT_ACDIRMIN | NFSMNT_ACDIRMAX);
				nfsargsp->acregmin = 0;
				nfsargsp->acregmax = 0;
				nfsargsp->acdirmin = 0;
				nfsargsp->acdirmax = 0;
			}
			if (altflags & ALTF_ACREGMIN) {
				nfsargsp->flags |= NFSMNT_ACREGMIN;
				nfsargsp->acregmin =
				    atoi(strstr(optarg, "acregmin=") + 9);
			}
			if (altflags & ALTF_ACREGMAX) {
				nfsargsp->flags |= NFSMNT_ACREGMAX;
				nfsargsp->acregmax =
				    atoi(strstr(optarg, "acregmax=") + 9);
			}
			if (altflags & ALTF_ACDIRMIN) {
				nfsargsp->flags |= NFSMNT_ACDIRMIN;
				nfsargsp->acdirmin =
				    atoi(strstr(optarg, "acdirmin=") + 9);
			}
			if (altflags & ALTF_ACDIRMAX) {
				nfsargsp->flags |= NFSMNT_ACDIRMAX;
				nfsargsp->acdirmax =
				    atoi(strstr(optarg, "acdirmax=") + 9);
			}
			altflags = 0;
d330 80
@


1.37
log
@Trailers are really wonders of the past. Remove them from man page and
usage. ok millert@@
@
text
@d109 8
a116 8
	{ "bg", ALTF_BG, 0 },
	{ "conn", ALTF_NOCONN, MFLAG_INVERSE },
	{ "dumbtimer", ALTF_DUMBTIMR, 0 },
	{ "intr", ALTF_INTR, 0 },
	{ "nfsv3", ALTF_NFSV3, 0 },
	{ "rdirplus", ALTF_RDIRPLUS, 0 },
	{ "mntudp", ALTF_MNTUDP, 0 },
	{ "resvport", ALTF_RESVPORT, 0 },
d118 1
a118 1
	{ "seqpacket", ALTF_SEQPACKET, 0 },
d120 9
a128 9
	{ "soft", ALTF_SOFT, 0 },
	{ "tcp", ALTF_TCP, 0 },
	{ "port", ALTF_PORT, MFLAG_INTVAL },
	{ "nfsv2", ALTF_NFSV2, 0 },
	{ "ac", ALTF_NOAC, 0 },
	{ "acregmin", ALTF_ACREGMIN, MFLAG_INTVAL },
	{ "acregmax", ALTF_ACREGMAX, MFLAG_INTVAL },
	{ "acdirmin", ALTF_ACDIRMIN, MFLAG_INTVAL },
	{ "acdirmax", ALTF_ACDIRMAX, MFLAG_INTVAL },
d190 2
a191 3
	int mntflags, num;
	char name[MAXPATHLEN], *options = NULL, *p, *spec;
	union mntval value;
d196 1
d267 68
a334 1
			options = optarg;
a396 80

	/* parse -o options */
	while (options != NULL) {
		switch (getmntopt(&options, &value, mopts, &mntflags)) {
		case ALTF_BG:
			opflags |= BGRND;
			break;
		case ALTF_NOCONN:
			nfsargsp->flags |= NFSMNT_NOCONN;
			break;
		case ALTF_DUMBTIMR:
			nfsargsp->flags |= NFSMNT_DUMBTIMR;
			break;
		case ALTF_INTR:
			nfsargsp->flags |= NFSMNT_INT;
			break;
		case ALTF_NFSV3:
			if (force2)
				errx(1,
				    "conflicting version options");
			force3 = 1;
			break;
		case ALTF_NFSV2:
			if (force3)
				errx(1,
				    "conflicting version options");
			force2 = 1;
			nfsargsp->flags &= ~NFSMNT_NFSV3;
			break;
		case ALTF_RDIRPLUS:
			nfsargsp->flags |= NFSMNT_RDIRPLUS;
			break;
		case ALTF_MNTUDP:
			mnttcp_ok = 0;
			break;
		case ALTF_RESVPORT:
			nfsargsp->flags |= NFSMNT_RESVPORT;
			break;
#ifdef ISO
		case ALTF_SEQPACKET:
			nfsargsp->sotype = SOCK_SEQPACKET;
			break;
#endif
		case ALTF_SOFT:
			nfsargsp->flags |= NFSMNT_SOFT;
			break;
		case ALTF_TCP:
			nfsargsp->sotype = SOCK_STREAM;
			nfsproto = IPPROTO_TCP;
			break;
		case ALTF_PORT:
			port_no = value.ival;
			break;
		case ALTF_NOAC:
			nfsargsp->flags |= (NFSMNT_ACREGMIN |
			    NFSMNT_ACREGMAX | NFSMNT_ACDIRMIN |
			    NFSMNT_ACDIRMAX);
			nfsargsp->acregmin = 0;
			nfsargsp->acregmax = 0;
			nfsargsp->acdirmin = 0;
			nfsargsp->acdirmax = 0;
			break;
		case ALTF_ACREGMIN:
			nfsargsp->flags |= NFSMNT_ACREGMIN;
			nfsargsp->acregmin = value.ival;
			break;
		case ALTF_ACREGMAX:
			nfsargsp->flags |= NFSMNT_ACREGMAX;
			nfsargsp->acregmax = value.ival;
			break;
		case ALTF_ACDIRMIN:
			nfsargsp->flags |= NFSMNT_ACDIRMIN;
			nfsargsp->acdirmin = value.ival;
			break;
		case ALTF_ACDIRMAX:
			nfsargsp->flags |= NFSMNT_ACDIRMAX;
			nfsargsp->acdirmax = value.ival;
			break;
		}
	}
@


1.36
log
@add support for modifying attribute cache parameters
inspired by PR2567, the included diff was wrong tho and not used here
manpage from millert@@
ok millert@@ on code and jmc@@ on manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.35 2003/07/29 18:38:36 deraadt Exp $	*/
d109 8
a116 8
	{ "bg", 0, ALTF_BG, 1 },
	{ "conn", 1, ALTF_NOCONN, 1 },
	{ "dumbtimer", 0, ALTF_DUMBTIMR, 1 },
	{ "intr", 0, ALTF_INTR, 1 },
	{ "nfsv3", 0, ALTF_NFSV3, 1 },
	{ "rdirplus", 0, ALTF_RDIRPLUS, 1 },
	{ "mntudp", 0, ALTF_MNTUDP, 1 },
	{ "resvport", 0, ALTF_RESVPORT, 1 },
d118 1
a118 1
	{ "seqpacket", 0, ALTF_SEQPACKET, 1 },
d120 9
a128 9
	{ "soft", 0, ALTF_SOFT, 1 },
	{ "tcp", 0, ALTF_TCP, 1 },
	{ "port", 0, ALTF_PORT, 1 },
	{ "nfsv2", 0, ALTF_NFSV2, 1 },
	{ "ac", 1, ALTF_NOAC, 1 },
	{ "acregmin", 0, ALTF_ACREGMIN, 1},
	{ "acregmax", 0, ALTF_ACREGMAX, 1},
	{ "acdirmin", 0, ALTF_ACDIRMIN, 1},
	{ "acdirmax", 0, ALTF_ACDIRMAX, 1},
d190 3
a192 2
	int mntflags, altflags, num;
	char name[MAXPATHLEN], *p, *spec;
a196 1
	altflags = 0;
d267 1
a267 68
			getmntopts(optarg, mopts, &mntflags, &altflags);
			if (altflags & ALTF_BG)
				opflags |= BGRND;
			if (altflags & ALTF_NOCONN)
				nfsargsp->flags |= NFSMNT_NOCONN;
			if (altflags & ALTF_DUMBTIMR)
				nfsargsp->flags |= NFSMNT_DUMBTIMR;
			if (altflags & ALTF_INTR)
				nfsargsp->flags |= NFSMNT_INT;
			if (altflags & ALTF_NFSV3) {
				if (force2)
					errx(1,"conflicting version options");
				force3 = 1;
			}
			if (altflags & ALTF_NFSV2) {
				if (force3)
					errx(1,"conflicting version options");
				force2 = 1;
				nfsargsp->flags &= ~NFSMNT_NFSV3;
			}
			if (altflags & ALTF_RDIRPLUS)
				nfsargsp->flags |= NFSMNT_RDIRPLUS;
			if (altflags & ALTF_MNTUDP)
				mnttcp_ok = 0;
			if (altflags & ALTF_RESVPORT)
				nfsargsp->flags |= NFSMNT_RESVPORT;
#ifdef ISO
			if (altflags & ALTF_SEQPACKET)
				nfsargsp->sotype = SOCK_SEQPACKET;
#endif
			if (altflags & ALTF_SOFT)
				nfsargsp->flags |= NFSMNT_SOFT;
			if (altflags & ALTF_TCP) {
				nfsargsp->sotype = SOCK_STREAM;
				nfsproto = IPPROTO_TCP;
			}
			if (altflags & ALTF_PORT)
				port_no = atoi(strstr(optarg, "port=") + 5);
			if (altflags & ALTF_NOAC) {
				nfsargsp->flags
				    |= (NFSMNT_ACREGMIN | NFSMNT_ACREGMAX |
					NFSMNT_ACDIRMIN | NFSMNT_ACDIRMAX);
				nfsargsp->acregmin = 0;
				nfsargsp->acregmax = 0;
				nfsargsp->acdirmin = 0;
				nfsargsp->acdirmax = 0;
			}
			if (altflags & ALTF_ACREGMIN) {
				nfsargsp->flags |= NFSMNT_ACREGMIN;
				nfsargsp->acregmin =
				    atoi(strstr(optarg, "acregmin=") + 9);
			}
			if (altflags & ALTF_ACREGMAX) {
				nfsargsp->flags |= NFSMNT_ACREGMAX;
				nfsargsp->acregmax =
				    atoi(strstr(optarg, "acregmax=") + 9);
			}
			if (altflags & ALTF_ACDIRMIN) {
				nfsargsp->flags |= NFSMNT_ACDIRMIN;
				nfsargsp->acdirmin =
				    atoi(strstr(optarg, "acdirmin=") + 9);
			}
			if (altflags & ALTF_ACDIRMAX) {
				nfsargsp->flags |= NFSMNT_ACDIRMAX;
				nfsargsp->acdirmax =
				    atoi(strstr(optarg, "acdirmax=") + 9);
			}
			altflags = 0;
d330 80
@


1.35
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.34 2003/07/06 20:52:40 avsm Exp $	*/
d100 4
d125 4
d313 20
@


1.34
log
@error out on hostspec overflow with a "hostname too long" instead of silently
truncating; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.33 2003/07/03 22:41:40 tedu Exp $	*/
d407 1
a407 1
		
@


1.33
log
@use realpath() in helpers instead of doing it ourselves every time.
also fixes pr1662.  from otto moerbeek
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.32 2003/06/11 06:22:14 deraadt Exp $	*/
d404 4
a407 1
	strlcpy(nam, spec, sizeof(nam));
@


1.32
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.31 2003/06/02 20:06:15 millert Exp $	*/
d183 1
a183 1
	char *name, *p, *spec;
d371 2
a372 1
	name = *argv;
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.30 2003/04/29 16:12:17 millert Exp $	*/
d177 1
a177 3
main(argc, argv)
	int argc;
	char *argv[];
d385 1
a385 3
getnfsargs(spec, nfsargsp)
	char *spec;
	struct nfs_args *nfsargsp;
d567 1
a567 3
xdr_dir(xdrsp, dirp)
	XDR *xdrsp;
	char *dirp;
d573 1
a573 3
xdr_fh(xdrsp, np)
	XDR *xdrsp;
	struct nfhret *np;
d613 1
a613 1
usage()
d616 4
a619 4
"[-23PTUbcdilqs] [-a maxreadahead] [-D deadthresh]",
"\t[-I readdirsize] [-g maxgroups] [-L leaseterm] [-o options]",
"\t[-R retrycnt] [-r readsize] [-t timeout] [-w writesize] [-x retrans]",
"\trhost:path node");
@


1.30
log
@Fix parsing of noac option; noticed and OK by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.29 2002/06/09 08:13:08 todd Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.28 2002/03/21 21:16:07 millert Exp $	*/
d124 1
a124 1
	{ "noac", 0, ALTF_NOAC, 1 },
@


1.28
log
@o sync usage() to man page
o -l does not require an argument
o getopt() returns -1 not EOF
From Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.27 2002/02/16 21:27:36 millert Exp $	*/
d304 1
a304 1
				nfsargsp->flags 
@


1.27
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.26 2001/12/01 19:13:48 deraadt Exp $	*/
d198 1
a198 1
	    "23a:bcdD:g:I:iL:l:o:PpqR:r:sTt:w:x:U")) != EOF)
d628 3
a630 3
"[-23bcdiklMPsT] [-a maxreadahead] [-D deadthresh]",
"\t[-g maxgroups] [-L leaseterm] [-o options] [-R retrycnt]",
"\t[-r readsize] [-t timeout] [-w writesize] [-x retrans]",
@


1.26
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.25 2001/11/05 07:39:16 mpech Exp $	*/
d171 1
a171 1
int	getnfsargs __P((char *, struct nfs_args *));
d173 1
a173 1
struct	iso_addr *iso_addr __P((const char *));
d175 4
a178 4
void	set_rpc_maxgrouplist __P((int));
__dead	void usage __P((void));
int	xdr_dir __P((XDR *, char *));
int	xdr_fh __P((XDR *, struct nfhret *));
@


1.25
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.24 2001/10/03 18:50:07 hin Exp $	*/
d188 1
a188 2
	struct nfsd_cargs ncd;
	int mntflags, altflags, i, nfssvc_flag, num;
@


1.24
log
@Remove all traces of Kerberised NFS; it never worked in OpenBSD, but it
has been in the userland tools and the manpages for ages.

Spotted by Lars Hansson <lars@@unet.net.ph>

Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.23 2001/07/13 18:19:24 csapuntz Exp $	*/
d185 2
a186 2
	register int c;
	register struct nfs_args *nfsargsp;
d396 1
a396 1
	register CLIENT *clp;
d586 1
a586 1
	register struct nfhret *np;
d588 1
a588 1
	register int i;
@


1.23
log
@Add noac flag to disable attribute caching
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.22 2001/07/07 18:26:15 deraadt Exp $	*/
a68 5
#ifdef NFSKERB
#include <des.h>
#include <kerberosIV/krb.h>
#endif

a93 1
#define ALTF_KERB	0x10
a112 3
#ifdef NFSKERB
	{ "kerb", 0, ALTF_KERB, 1 },
#endif
a170 15
#ifdef NFSKERB
char inst[INST_SZ];
char realm[REALM_SZ];
struct {
	u_long		kind;
	KTEXT_ST	kt;
} ktick;
struct nfsrpc_nickverf kverf;
struct nfsrpc_fullblock kin, kout;
NFSKERBKEY_T kivec;
CREDENTIALS kcr;
struct timeval ktv;
NFSKERBKEYSCHED_T kerb_keysched;
#endif

a190 13
#ifdef NFSKERB
	uid_t last_ruid;
#endif

#ifdef NFSKERB
	last_ruid = -1;
	if (krb_get_lrealm(realm, 0) != KSUCCESS)
	    (void)strcpy(realm, "[not set]");
	if (sizeof (struct nfsrpc_nickverf) != RPCX_NICKVERF ||
	    sizeof (struct nfsrpc_fullblock) != RPCX_FULLBLOCK ||
	    ((char *)&ktick.kt) - ((char *)&ktick) != NFSX_UNSIGNED ||
	    ((char *)ktick.kt.dat) - ((char *)&ktick) != 2 * NFSX_UNSIGNED)
		fprintf(stderr, "Yikes! NFSKERB structs not packed!!\n");
a191 1
#endif
d199 1
a199 1
	    "23a:bcdD:g:I:iKL:lm:o:PpqR:r:sTt:w:x:U")) != EOF)
a254 5
#ifdef NFSKERB
		case 'K':
			nfsargsp->flags |= NFSMNT_KERB;
			break;
#endif
a264 5
#ifdef NFSKERB
		case 'm':
			strlcpy(realm, optarg, sizeof(realm));
			break;
#endif
a274 4
#ifdef NFSKERB
			if (altflags & ALTF_KERB)
				nfsargsp->flags |= NFSMNT_KERB;
#endif
a387 98
	if (nfsargsp->flags & NFSMNT_KERB) {
		if ((opflags & ISBGRND) == 0) {
			if ((i = fork())) {
				if (i == -1)
					err(1, "Couldn't launch NFS kerberos service process");
				exit(0);
			}
			(void) setsid();
			(void) close(STDIN_FILENO);
			(void) close(STDOUT_FILENO);
			(void) close(STDERR_FILENO);
			(void) chdir("/");
		}
		openlog("mount_nfs:", LOG_PID, LOG_DAEMON);
		nfssvc_flag = NFSSVC_MNTD;
		ncd.ncd_dirp = name;
		while (nfssvc(nfssvc_flag, (caddr_t)&ncd) < 0) {
			if (errno != ENEEDAUTH) {
				syslog(LOG_ERR, "nfssvc err %m");
				continue;
			}
			nfssvc_flag =
			    NFSSVC_MNTD | NFSSVC_GOTAUTH | NFSSVC_AUTHINFAIL;
#ifdef NFSKERB
			/*
			 * Set up as ncd_authuid for the kerberos call.
			 * Must set ruid to ncd_authuid and reset the
			 * ticket name iff ncd_authuid is not the same
			 * as last time, so that the right ticket file
			 * is found.
			 * Get the Kerberos credential structure so that
			 * we have the seesion key and get a ticket for
			 * this uid.
			 * For more info see the IETF Draft "Authentication
			 * in ONC RPC".
			 */
			if (ncd.ncd_authuid != last_ruid) {
				krb_set_tkt_string("");
				last_ruid = ncd.ncd_authuid;
			}
			setreuid(ncd.ncd_authuid, 0);
			kret = krb_get_cred(NFS_KERBSRV, inst, realm, &kcr);
			if (kret == RET_NOTKT) {
		            kret = get_ad_tkt(NFS_KERBSRV, inst, realm,
				DEFAULT_TKT_LIFE);
			    if (kret == KSUCCESS)
				kret = krb_get_cred(NFS_KERBSRV, inst, realm,
				    &kcr);
			}
			if (kret == KSUCCESS)
			    kret = krb_mk_req(&ktick.kt, NFS_KERBSRV, inst,
				realm, 0);

			/*
			 * Fill in the AKN_FULLNAME authenticator and verfier.
			 * Along with the Kerberos ticket, we need to build
			 * the timestamp verifier and encrypt it in CBC mode.
			 */
			if (kret == KSUCCESS &&
			    ktick.kt.length <= (RPCAUTH_MAXSIZ-3*NFSX_UNSIGNED)
			    && gettimeofday(&ktv, NULL) == 0) {
			    ncd.ncd_authtype = RPCAUTH_KERB4;
			    ncd.ncd_authstr = (u_char *)&ktick;
			    ncd.ncd_authlen = nfsm_rndup(ktick.kt.length) +
				3 * NFSX_UNSIGNED;
			    ncd.ncd_verfstr = (u_char *)&kverf;
			    ncd.ncd_verflen = sizeof (kverf);
			    memmove(ncd.ncd_key, kcr.session,
				sizeof (kcr.session));
			    kin.t1 = htonl(ktv.tv_sec);
			    kin.t2 = htonl(ktv.tv_usec);
			    kin.w1 = htonl(NFS_KERBTTL);
			    kin.w2 = htonl(NFS_KERBTTL - 1);
			    bzero((caddr_t)kivec, sizeof (kivec));

			    /*
			     * Encrypt kin in CBC mode using the session
			     * key in kcr.
			     */
			    XXX

			    /*
			     * Finally, fill the timestamp verifier into the
			     * authenticator and verifier.
			     */
			    ktick.kind = htonl(RPCAKN_FULLNAME);
			    kverf.kind = htonl(RPCAKN_FULLNAME);
			    NFS_KERBW1(ktick.kt) = kout.w1;
			    ktick.kt.length = htonl(ktick.kt.length);
			    kverf.verf.t1 = kout.t1;
			    kverf.verf.t2 = kout.t2;
			    kverf.verf.w2 = kout.w2;
			    nfssvc_flag = NFSSVC_MNTD | NFSSVC_GOTAUTH;
			}
			setreuid(0, 0);
#endif /* NFSKERB */
		}
	}
a407 3
#ifdef NFSKERB
	char *cp;
#endif
d454 1
a454 2
	 * Handle an internet host address and reverse resolve it if
	 * doing Kerberos.
d456 1
a456 10
	if (inet_aton(hostp, &saddr.sin_addr) != 0) {
		if ((nfsargsp->flags & NFSMNT_KERB)) {
			if ((hp = gethostbyaddr((char *)&saddr.sin_addr.s_addr,
			    sizeof (u_long), AF_INET)) == NULL) {
				warnx("can't resolve hostname for address %s",
				    hostp);
				return (0);
			}
		}
	} else {
a463 7
#ifdef NFSKERB
	if (nfsargsp->flags & NFSMNT_KERB) {
		strlcpy(inst, hp->h_name, sizeof(inst));
		if (cp = strchr(inst, '.'))
			*cp = '\0';
	}
#endif /* NFSKERB */
d500 1
a500 4
				if (nfsargsp->flags & NFSMNT_KERB)
				    nfhret.auth = RPCAUTH_KERB4;
				else
				    nfhret.auth = RPCAUTH_UNIX;
d629 2
a630 2
"[-23bcdiKklMPqsT] [-a maxreadahead] [-D deadthresh]",
"\t[-g maxgroups] [-L leaseterm] [-m realm] [-o options] [-R retrycnt]",
@


1.22
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.21 2001/07/07 00:19:52 millert Exp $	*/
d109 1
d133 1
d356 9
@


1.21
log
@Initialize missing parts of struct nfs_args nfsdefargs
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.20 2001/06/24 17:03:19 csapuntz Exp $	*/
a212 1
	int error = 0;
d431 1
a431 1
			if (i = fork()) {
d695 1
a695 1
				if (i = fork()) {
@


1.20
log
@

Get rid of NQNFS options
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.19 2001/05/11 18:09:08 mickey Exp $	*/
d137 1
a137 1
	(struct sockaddr *)0,
d141 1
a141 1
	(u_char *)0,
d151 7
a157 1
	(char *)0,
@


1.19
log
@use strlcpy instead of strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.18 2000/06/30 16:00:08 millert Exp $	*/
a78 1
#include <nfs/nqnfs.h>
a104 1
#define ALTF_NQNFS	0x400
a127 1
	{ "nqnfs", 0, ALTF_NQNFS, 1 },
a150 2
	NQ_DEFLEASE,
	NQ_DEADTHRESH,
a340 6
			if (altflags & ALTF_NQNFS) {
				if (force2)
					errx(1,"nqnfs only available with v3");
				force3 = 1;
				nfsargsp->flags |= NFSMNT_NQNFS;
			}
a358 6
		case 'q':
			if (force2)
				errx(1,"nqnfs only available with v3");
			force3 = 1;
			nfsargsp->flags |= NFSMNT_NQNFS;
			break;
d424 1
a424 1
	if (nfsargsp->flags & (NFSMNT_NQNFS | NFSMNT_KERB)) {
d428 1
a428 1
					err(1, "nqnfs 1");
@


1.18
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.17 1999/06/17 20:53:28 millert Exp $	*/
d308 1
a308 2
			(void)strncpy(realm, optarg, REALM_SZ - 1);
			realm[REALM_SZ - 1] = '\0';
d566 1
a566 2
	strncpy(nam, spec, MNAMELEN);
	nam[MNAMELEN] = '\0';
d630 1
a630 2
		strncpy(inst, hp->h_name, INST_SZ);
		inst[INST_SZ - 1] = '\0';
@


1.17
log
@go back to UDP mounts by default until NFS/TCP is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.15 1998/05/16 06:28:00 deraadt Exp $	*/
d440 1
a440 1
			err(1, name);
@


1.17.4.1
log
@Pull in patch from current (more to come...):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.18 2000/06/30 16:00:08 millert Exp $	*/
d440 1
a440 1
			err(1, "%s", name);
@


1.16
log
@Use connection-oriented transport (ie: TCP) when possible.  This makes
the default trasport for NFSV3 be TCP like most other OS's.
@
text
@d171 1
d357 1
a357 1
				mnttcp_ok = 2;
d395 1
a395 1
			mnttcp_ok = 2;
a433 4
	/* Use TCP for NFSV3 by default */
	if (mnttcp_ok == 1 && (nfsargsp->flags & NFSMNT_NFSV3))
		nfsargsp->sotype = SOCK_STREAM;

a654 9
			/*
			 * If user didn't specifically request TCP,
			 * fall back to UDP for NFSV3 mounts.
			 */
			if (nfsvers == NFS_VER3 && mnttcp_ok == 1) {
				nfsargsp->sotype = SOCK_DGRAM;
				mnttcp_ok = 0;
				continue;
			}
@


1.15
log
@call pmap_getport() with correct proto; tron
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.14 1997/11/11 18:36:38 deraadt Exp $	*/
a170 1
int nfsproto = IPPROTO_UDP;
d356 1
a356 1
				nfsproto = IPPROTO_TCP;
d394 1
a394 1
			nfsproto = IPPROTO_TCP;
d433 4
d658 9
@


1.14
log
@use nfsproto variable; tron@@lyssa.owl.de
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.13 1997/08/20 05:10:23 millert Exp $	*/
d653 2
a654 1
		    RPCPROG_NFS, nfsvers, nfsproto)) == 0) {
@


1.13
log
@Print "Filesystem not supported by kernel" not "Operation not supported by
device" (EOPNOTSUPP) so the real problem is obvious.  Idea from Peter Seebach
<seebs@@taniemarie.solon.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.12 1997/08/18 03:11:24 millert Exp $	*/
d653 1
a653 2
		    RPCPROG_NFS, nfsvers, nfsargsp->sotype == SOCK_STREAM ?
		    IPPROTO_TCP : IPPROTO_UDP)) == 0) {
@


1.12
log
@#include <string.h> not <strings.h> -- Yes, I'm a weanie...
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.11 1997/06/29 11:10:31 provos Exp $	*/
d436 6
a441 2
	if (mount(MOUNT_NFS, name, mntflags, nfsargsp))
		err(1, "%s", name);
@


1.11
log
@new location of des.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.10 1997/06/25 18:23:59 kstailey Exp $	*/
d91 1
a91 1
#include <strings.h>
@


1.10
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.9 1997/04/20 15:37:26 deraadt Exp $	*/
d70 1
a70 1
#include <kerberosIV/des.h>
@


1.9
log
@support for -o port=N; provos
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.8 1996/12/12 10:33:23 deraadt Exp $	*/
d498 1
a498 1
			    && gettimeofday(&ktv, (struct timezone *)0) == 0) {
d612 1
a612 1
			    sizeof (u_long), AF_INET)) == (struct hostent *)0) {
@


1.8
log
@i studdderr wheenn i tyttype
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.7 1996/12/12 10:28:28 deraadt Exp $	*/
d109 2
a110 1
#define ALTF_NFSV2	0x2000
d133 1
d173 1
d314 1
a314 1
			if(altflags & ALTF_BG)
d316 1
a316 1
			if(altflags & ALTF_NOCONN)
d318 1
a318 1
			if(altflags & ALTF_DUMBTIMR)
d320 1
a320 1
			if(altflags & ALTF_INTR)
d323 1
a323 1
			if(altflags & ALTF_KERB)
d326 1
a326 1
			if(altflags & ALTF_NFSV3) {
d331 1
a331 1
			if(altflags & ALTF_NFSV2) {
d337 1
a337 1
			if(altflags & ALTF_RDIRPLUS)
d339 1
a339 1
			if(altflags & ALTF_MNTUDP)
d341 1
a341 1
			if(altflags & ALTF_RESVPORT)
d344 1
a344 1
			if(altflags & ALTF_SEQPACKET)
d347 1
a347 1
			if(altflags & ALTF_NQNFS) {
d353 1
a353 1
			if(altflags & ALTF_SOFT)
d355 1
a355 1
			if(altflags & ALTF_TCP) {
d359 2
d648 3
a650 3
		if ((tport = pmap_getport(&saddr, RPCPROG_NFS,
		    nfsvers, nfsargsp->sotype == SOCK_STREAM ? IPPROTO_TCP :
		    IPPROTO_UDP)) == 0) {
@


1.7
log
@cannot use err() here
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.6 1996/05/28 12:37:57 deraadt Exp $	*/
d683 1
a683 1
							fprintf(stdderr, "%s",
@


1.6
log
@Be stricter when checking NQNFS and version combinations
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.4 1996/04/21 23:46:50 deraadt Exp $	*/
d683 1
a683 1
							errx(1, "%s",
@


1.5
log
@Clarified warning messages a bit
@
text
@d2 1
a2 1
/*	$NetBSD: mount_nfs.c,v 1.12 1996/04/13 01:31:43 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$NetBSD: mount_nfs.c,v 1.12 1996/04/13 01:31:43 jtc Exp $";
d109 1
d132 1
d323 11
a333 2
			if(altflags & ALTF_NFSV3)
				nfsargsp->flags |= NFSMNT_NFSV3;
d344 6
a349 2
			if(altflags & ALTF_NQNFS)
				nfsargsp->flags |= (NFSMNT_NQNFS|NFSMNT_NFSV3);
d367 4
a370 1
			nfsargsp->flags |= (NFSMNT_NQNFS | NFSMNT_NFSV3);
d797 1
a797 1
"[-bcdiKklMPqsT] [-a maxreadahead] [-D deadthresh]",
@


1.4
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD: mount_nfs.c,v 1.3 1996/03/21 00:16:03 niklas Exp $	*/
d590 2
a591 1
				warnx("can't reverse resolve net address");
d598 1
a598 1
			warnx("can't get net id for host");
@


1.3
log
@From NetBSD: Merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mount_nfs.c,v 1.11 1996/02/18 11:59:11 fvdl Exp $	*/
d50 1
a50 1
static char rcsid[] = "$NetBSD: mount_nfs.c,v 1.11 1996/02/18 11:59:11 fvdl Exp $";
d110 1
a110 1
struct mntopt mopts[] = {
@


1.2
log
@Do not use hard-coded realm name
@
text
@d1 2
a2 1
/*	$NetBSD: mount_nfs.c,v 1.10 1995/05/21 15:17:13 mycroft Exp $	*/
d48 1
a48 1
static char sccsid[] = "@@(#)mount_nfs.c	8.3 (Berkeley) 3/27/94";
d50 1
a50 1
static char rcsid[] = "$NetBSD: mount_nfs.c,v 1.10 1995/05/21 15:17:13 mycroft Exp $";
d69 1
a69 1
#ifdef KERBEROS
d75 1
a75 1
#include <nfs/nfsv2.h>
d96 14
d114 17
d135 1
d140 1
a140 1
	(nfsv2fh_t *)0,
d142 1
d145 2
a146 1
	NFS_TIMEO,
d156 5
a160 2
	u_long	stat;
	nfsv2fh_t nfh;
d165 1
a165 1
int retrycnt = DEF_RETRY;
d167 4
d172 1
a172 1
#ifdef KERBEROS
d175 10
a184 1
KTEXT_ST kt;
d205 1
a205 1
	int mntflags, i, nfssvc_flag, num;
d208 1
a208 1
#ifdef KERBEROS
d212 1
a212 1
#ifdef KERBEROS
d216 6
d226 1
d230 1
a230 1
	    "a:bcdD:g:iKklL:Mm:o:PpqR:r:sTt:w:x:")) != EOF)
d232 11
d276 7
d286 1
a286 1
#ifdef KERBEROS
a290 3
		case 'k':
			nfsargsp->flags |= NFSMNT_NQLOOKLEASE;
			break;
d299 1
a299 1
			nfsargsp->flags |= NFSMNT_RDIRALOOK;
d301 1
a301 4
		case 'M':
			nfsargsp->flags |= NFSMNT_MYWRITE;
			break;
#ifdef KERBEROS
d308 34
a341 1
			getmntopts(optarg, mopts, &mntflags);
d352 1
a352 1
			nfsargsp->flags |= NFSMNT_NQNFS;
d372 1
d395 3
d438 1
a438 1
#ifdef KERBEROS
d445 5
d456 52
a507 7
			if (krb_mk_req(&kt, "rcmd", inst, realm, 0) ==
			    KSUCCESS &&
			    kt.length <= (RPCAUTH_MAXSIZ - 2 * NFSX_UNSIGNED)) {
				ncd.ncd_authtype = RPCAUTH_NQNFS;
				ncd.ncd_authlen = kt.length;
				ncd.ncd_authstr = (char *)kt.dat;
				nfssvc_flag = NFSSVC_MNTD | NFSSVC_GOTAUTH;
d510 1
a510 1
#endif /* KERBEROS */
d531 1
a531 1
	int so = RPC_ANYSOCK, i;
d533 1
a533 1
#ifdef KERBEROS
d602 1
a602 1
#ifdef KERBEROS
d609 1
a609 1
#endif /* KERBEROS */
d611 9
d625 1
a625 1
		    NFS_VER2, nfsargsp->sotype == SOCK_STREAM ? IPPROTO_TCP :
d633 7
a639 5
			if ((clp = (nfsargsp->sotype == SOCK_STREAM ?
			    clnttcp_create(&saddr, RPCPROG_MNT, RPCMNT_VER1,
					   &so, 0, 0) :
			    clntudp_create(&saddr, RPCPROG_MNT, RPCMNT_VER1,
					   pertry, &so))) == NULL) {
d646 5
d654 15
d701 1
a701 1
		warn("can't access %s", spec);
d715 2
a716 1
	nfsargsp->fh = &nfhret.nfh;
d735 1
a735 1
	struct nfhret *np;
d737 4
a740 1
	if (!xdr_u_long(xdrsp, &(np->stat)))
d744 28
a771 1
	return (xdr_opaque(xdrsp, (caddr_t)&(np->nfh), NFSX_FH));
@


1.1
log
@Initial revision
@
text
@d164 1
a164 1
	    (void)strcpy(realm, KRB_REALM);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
