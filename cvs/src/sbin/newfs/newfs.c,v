head	1.109;
access;
symbols
	OPENBSD_6_2:1.109.0.2
	OPENBSD_6_2_BASE:1.109
	OPENBSD_6_1:1.109.0.4
	OPENBSD_6_1_BASE:1.109
	OPENBSD_6_0:1.108.0.4
	OPENBSD_6_0_BASE:1.108
	OPENBSD_5_9:1.104.0.2
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.99.0.6
	OPENBSD_5_8_BASE:1.99
	OPENBSD_5_7:1.99.0.2
	OPENBSD_5_7_BASE:1.99
	OPENBSD_5_6:1.97.0.4
	OPENBSD_5_6_BASE:1.97
	OPENBSD_5_5:1.95.0.4
	OPENBSD_5_5_BASE:1.95
	OPENBSD_5_4:1.91.0.2
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.90.0.8
	OPENBSD_5_3_BASE:1.90
	OPENBSD_5_2:1.90.0.6
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.4
	OPENBSD_5_0:1.90.0.2
	OPENBSD_5_0_BASE:1.90
	OPENBSD_4_9:1.88.0.2
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.81.0.4
	OPENBSD_4_7_BASE:1.81
	OPENBSD_4_6:1.81.0.6
	OPENBSD_4_6_BASE:1.81
	OPENBSD_4_5:1.81.0.2
	OPENBSD_4_5_BASE:1.81
	OPENBSD_4_4:1.80.0.2
	OPENBSD_4_4_BASE:1.80
	OPENBSD_4_3:1.75.0.2
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.69.0.2
	OPENBSD_4_2_BASE:1.69
	OPENBSD_4_1:1.52.0.4
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.51.0.2
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.50.0.6
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.50.0.4
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	OPENBSD_3_5:1.47.0.2
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.44.0.2
	OPENBSD_3_4_BASE:1.44
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_8:1.22.0.4
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.17.0.6
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.17.0.4
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.109
date	2016.10.11.07.02.46;	author natano;	state Exp;
branches;
next	1.108;
commitid	lYtdMiPD0uqi8DSe;

1.108
date	2016.07.25.15.30.36;	author krw;	state Exp;
branches;
next	1.107;
commitid	8ZXuyFc1Xjz8EU6S;

1.107
date	2016.07.23.09.12.33;	author krw;	state Exp;
branches;
next	1.106;
commitid	mkKfYxv9CZ5ovoXZ;

1.106
date	2016.05.31.16.41.08;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	gVCwDy46Lxg0n4Kr;

1.105
date	2016.03.09.16.28.47;	author deraadt;	state Exp;
branches;
next	1.104;
commitid	OSDG2O3Cgeifnf1W;

1.104
date	2015.12.06.11.56.47;	author tobias;	state Exp;
branches;
next	1.103;
commitid	2CO2sgsumCvf1pCb;

1.103
date	2015.11.25.19.45.21;	author kettenis;	state Exp;
branches;
next	1.102;
commitid	pPq5FloBsZxYEVKG;

1.102
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.101;
commitid	Cz19p5I1S6mVZIjV;

1.101
date	2015.11.10.07.38.19;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	6b1hnomKKL0DcvGS;

1.100
date	2015.09.29.03.19.24;	author guenther;	state Exp;
branches;
next	1.99;
commitid	yKdJafwKaYfM4gkS;

1.99
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.98;
commitid	F55lwc3gS4GN2mLs;

1.98
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.97;
commitid	Uu5nFG3wCl0LACBb;

1.97
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.96;
commitid	0acpjAf5myNxgwB5;

1.96
date	2014.07.20.00.46.26;	author guenther;	state Exp;
branches;
next	1.95;
commitid	RbQqUnIzhxt966vr;

1.95
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2013.11.05.00.51.58;	author krw;	state Exp;
branches;
next	1.93;

1.93
date	2013.10.07.10.05.24;	author krw;	state Exp;
branches;
next	1.92;

1.92
date	2013.10.06.22.13.26;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2013.06.11.16.42.05;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2011.05.23.10.56.17;	author dcoppa;	state Exp;
branches;
next	1.89;

1.89
date	2011.04.26.14.02.14;	author otto;	state Exp;
branches;
next	1.88;

1.88
date	2010.12.13.00.02.58;	author marco;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.24.00.28.41;	author tedu;	state Exp;
branches;
next	1.86;

1.86
date	2010.07.02.22.02.48;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.03.14.28.08;	author jsing;	state Exp;
branches;
next	1.83;

1.83
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.82;

1.82
date	2010.03.20.14.19.38;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2008.08.08.23.49.53;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2008.08.04.18.46.32;	author otto;	state Exp;
branches;
next	1.79;

1.79
date	2008.07.06.15.03.36;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.27.18.50.43;	author sobrado;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.24.15.07.02;	author jmc;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.04.14.21.34;	author tobias;	state Exp;
branches;
next	1.75;

1.75
date	2008.01.29.13.02.31;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.15.14.23.25;	author sthen;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.26.12.19.37;	author tedu;	state Exp;
branches;
next	1.72;

1.72
date	2007.11.25.22.09.35;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.11.25.15.13.57;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2007.11.05.11.37.25;	author otto;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.26.19.03.21;	author otto;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.10.19.11.43;	author otto;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.01.23.42.35;	author pedro;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.01.06.41.35;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.29.06.28.16;	author otto;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.20.11.28.06;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.19.20.12.50;	author otto;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.19.01.28.15;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.18.19.08.16;	author otto;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.15.09.35.47;	author thib;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.13.20.08.30;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.13.20.04.38;	author jmc;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.13.17.33.02;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.03.20.59.34;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.03.18.42.32;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.03.17.08.30;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.02.20.20.39;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.09.13.35.02;	author pedro;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.28.19.10.57;	author otto;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.12.07.53.50;	author otto;	state Exp;
branches;
next	1.49;

1.49
date	2004.07.02.15.48.36;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.26.18.21.36;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.03.05.40.09;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.03.05.36.27;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.07.20.14.54;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.16.18.02.36;	author tedu;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2003.07.02.21.44.58;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.25.21.24.10;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.11.06.22.14;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.03.17.21.04;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.16.10.33.16;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.13.09.09.26;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.26.09.24.35;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.06.19.25.06;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.18.21.57.56;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.16.21.27.36;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.07.18.26.16;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.19.16.22.18;	author gluk;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.14.03.15.54;	author gluk;	state Exp;
branches;
next	1.25;

1.25
date	2001.04.05.00.50.07;	author gluk;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.04.22.06.39;	author gluk;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.03.22.59.35;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.30.05.07.46;	author bjc;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.21.21.58.04;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	99.12.03.19.24.18;	author art;	state Exp;
branches;
next	1.19;

1.19
date	99.08.17.09.13.14;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.04.10.04.09.23;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.09.26.01.49.18;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.07.25.19.13.07;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.06.16.00.03.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.02.23.03.51.25;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.02.22.05.53.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.02.11.07.01.38;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.01.16.05.48.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.01.15.23.41.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.12.23.07.48.28;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.12.04.10.26.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.04.08.52.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.04.08.38.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.11.24.23.46.44;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.27.20.55.05;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.31.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.34.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.43;	author deraadt;	state Exp;
branches;
next	;

1.44.2.1
date	2003.11.03.23.47.26;	author brad;	state Exp;
branches;
next	;


desc
@@


1.109
log
@Enable the noperm option for mount_mfs. mfs is ffs in sheeps clothing,
so we basically get this for free.

requested by espie
ok deraadt
@
text
@/*	$OpenBSD: newfs.c,v 1.108 2016/07/25 15:30:36 krw Exp $	*/
/*	$NetBSD: newfs.c,v 1.20 1996/05/16 07:13:03 thorpej Exp $	*/

/*
 * Copyright (c) 2002 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by Marshall
 * Kirk McKusick and Network Associates Laboratories, the Security
 * Research Division of Network Associates, Inc. under DARPA/SPAWAR
 * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS
 * research program.
 *
 * Copyright (c) 1983, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE MAXBSIZE */
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/disklabel.h>
#include <sys/mount.h>
#include <sys/resource.h>
#include <sys/sysctl.h>
#include <sys/wait.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <signal.h>
#include <util.h>

#include "mntopts.h"
#include "pathnames.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

struct mntopt mopts[] = {
	MOPT_STDOPTS,
	MOPT_WXALLOWED,
	MOPT_NOPERM,
	MOPT_ASYNC,
	MOPT_UPDATE,
	MOPT_FORCE,
	{ NULL },
};

void	fatal(const char *fmt, ...)
	    __attribute__((__format__ (printf, 1, 2)))
	    __attribute__((__nonnull__ (1)));
__dead void	usage(void);
void	mkfs(struct partition *, char *, int, int, mode_t, uid_t, gid_t);
void	getphysmem(void);
void	rewritelabel(char *, int, struct disklabel *);
u_short	dkcksum(struct disklabel *);

/*
 * The following two constants set the default block and fragment sizes.
 * Both constants must be a power of 2 and meet the following constraints:
 *	MINBSIZE <= DESBLKSIZE <= MAXBSIZE
 *	sectorsize <= DESFRAGSIZE <= DESBLKSIZE
 *	DESBLKSIZE / DESFRAGSIZE <= 8
 */
#define	DFL_FRAGSIZE	2048
#define	DFL_BLKSIZE	16384

/*
 * MAXBLKPG determines the maximum number of data blocks which are
 * placed in a single cylinder group. The default is one indirect
 * block worth of data blocks.
 */
#define MAXBLKPG_FFS1(bsize)	((bsize) / sizeof(int32_t))
#define MAXBLKPG_FFS2(bsize)	((bsize) / sizeof(int64_t))

/*
 * Each file system has a number of inodes statically allocated.
 * We allocate one inode slot per NFPI fragments, expecting this
 * to be far more than we will ever need.
 */
#define	NFPI		4

int	mfs;			/* run as the memory based filesystem */
int	Nflag;			/* run without writing file system */
int	Oflag = 1;		/* 0 = 4.3BSD ffs, 1 = 4.4BSD ffs, 2 = ffs2 */
daddr_t	fssize;			/* file system size in 512-byte blocks */
long long	sectorsize;		/* bytes/sector */
int	fsize = 0;		/* fragment size */
int	bsize = 0;		/* block size */
int	maxfrgspercg = INT_MAX;	/* maximum fragments per cylinder group */
int	minfree = MINFREE;	/* free space threshold */
int	opt = DEFAULTOPT;	/* optimization preference (space or time) */
int	reqopt = -1;		/* opt preference has not been specified */
int	density;		/* number of bytes per inode */
int	maxbpg;			/* maximum blocks per file in a cyl group */
int	avgfilesize = AVFILESIZ;/* expected average file size */
int	avgfilesperdir = AFPDIR;/* expected number of files per directory */
int	mntflags = MNT_ASYNC;	/* flags to be passed to mount */
int	quiet = 0;		/* quiet flag */
caddr_t	membase;		/* start address of memory based filesystem */
char	*disktype;
int	unlabeled;

extern	char *__progname;
struct disklabel *getdisklabel(char *, int);

#ifdef MFS
static int do_exec(const char *, const char *, char *const[]);
static int isdir(const char *);
static void copy(char *, char *, struct mfs_args *);
static int gettmpmnt(char *, size_t);
#endif

int64_t physmem;

void
getphysmem(void)
{
	int mib[] = { CTL_HW, HW_PHYSMEM64 };
	size_t len = sizeof(physmem);
	
	if (sysctl(mib, 2, &physmem, &len, NULL, 0) != 0)
		err(1, "can't get physmem");
}

int
main(int argc, char *argv[])
{
	int ch;
	struct partition *pp;
	struct disklabel *lp;
	struct disklabel mfsfakelabel;
	struct partition oldpartition;
	struct stat st;
	struct statfs *mp;
	struct rlimit rl;
	int fsi = -1, oflagset = 0, fso, len, n, maxpartitions;
	char *cp = NULL, *s1, *s2, *special, *opstring, *realdev;
#ifdef MFS
	char mountfromname[BUFSIZ];
	char *pop = NULL, node[PATH_MAX];
	pid_t pid, res;
	struct statfs sf;
	struct stat mountpoint;
	int status;
#endif
	uid_t mfsuid = 0;
	gid_t mfsgid = 0;
	mode_t mfsmode = 0;
	char *fstype = NULL;
	char **saveargv = argv;
	int ffsflag = 1;
	const char *errstr;
	long long fssize_input = 0;
	int fssize_usebytes = 0;
	u_int64_t nsecs;

	if (strstr(__progname, "mfs"))
		mfs = Nflag = quiet = 1;

	getphysmem();
	maxpartitions = getmaxpartitions();
	if (maxpartitions > 26)
		fatal("insane maxpartitions value %d", maxpartitions);

	opstring = mfs ?
	    "P:T:b:c:e:f:i:m:o:s:" :
	    "NO:S:T:b:c:e:f:g:h:i:m:o:qs:t:";
	while ((ch = getopt(argc, argv, opstring)) != -1) {
		switch (ch) {
		case 'N':
			Nflag = 1;
			break;
		case 'O':
			Oflag = strtonum(optarg, 0, 2, &errstr);
			if (errstr)
				fatal("%s: invalid ffs version", optarg);
			oflagset = 1;
			break;
		case 'S':
			if (scan_scaled(optarg, &sectorsize) == -1 ||
			    sectorsize <= 0 || (sectorsize % DEV_BSIZE))
				fatal("sector size invalid: %s", optarg);
			break;
		case 'T':
			disktype = optarg;
			break;
		case 'b':
			bsize = strtonum(optarg, MINBSIZE, MAXBSIZE, &errstr);
			if (errstr)
				fatal("block size is %s: %s", errstr, optarg);
			break;
		case 'c':
			maxfrgspercg = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("fragments per cylinder group is %s: %s",
				    errstr, optarg);
			break;
		case 'e':
			maxbpg = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("blocks per file in a cylinder group is"
				    " %s: %s", errstr, optarg);
			break;
		case 'f':
			fsize = strtonum(optarg, MINBSIZE / MAXFRAG, MAXBSIZE,
			    &errstr);
			if (errstr)
				fatal("fragment size is %s: %s",
				    errstr, optarg);
			break;
		case 'g':
			avgfilesize = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("average file size is %s: %s",
				    errstr, optarg);
			break;
		case 'h':
			avgfilesperdir = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("average files per dir is %s: %s",
				    errstr, optarg);
			break;
		case 'i':
			density = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("bytes per inode is %s: %s",
				    errstr, optarg);
			break;
		case 'm':
			minfree = strtonum(optarg, 0, 99, &errstr);
			if (errstr)
				fatal("free space %% is %s: %s",
				    errstr, optarg);
			break;
		case 'o':
			if (mfs)
				getmntopts(optarg, mopts, &mntflags);
			else {
				if (strcmp(optarg, "space") == 0)
					reqopt = opt = FS_OPTSPACE;
				else if (strcmp(optarg, "time") == 0)
					reqopt = opt = FS_OPTTIME;
				else
					fatal("%s: unknown optimization "
					    "preference: use `space' or `time'.",
					    optarg);
			}
			break;
		case 'q':
			quiet = 1;
			break;
		case 's':
			if (scan_scaled(optarg, &fssize_input) == -1 ||
			    fssize_input <= 0)
				fatal("file system size invalid: %s", optarg);
			fssize_usebytes = 0;    /* in case of multiple -s */
			for (s1 = optarg; *s1 != '\0'; s1++)
				if (isalpha((unsigned char)*s1)) {
					fssize_usebytes = 1;
					break;
				}
			break;
		case 't':
			fstype = optarg;
			if (strcmp(fstype, "ffs"))
				ffsflag = 0;
			break;
#ifdef MFS
		case 'P':
			pop = optarg;
			break;
#endif
		case '?':
		default:
			usage();
		}
		if (!ffsflag)
			break;
	}
	argc -= optind;
	argv += optind;

	if (ffsflag && argc - mfs != 1)
		usage();

	if (mfs) {
		/* Increase our data size to the max */
		if (getrlimit(RLIMIT_DATA, &rl) == 0) {
			rl.rlim_cur = rl.rlim_max;
			(void)setrlimit(RLIMIT_DATA, &rl);
		}
	}

	special = argv[0];

	if (!mfs) {
		char execname[PATH_MAX], name[PATH_MAX];

		if (fstype == NULL)
			fstype = readlabelfs(special, 0);
		if (fstype != NULL && strcmp(fstype, "ffs")) {
			snprintf(name, sizeof name, "newfs_%s", fstype);
			saveargv[0] = name;
			snprintf(execname, sizeof execname, "%s/newfs_%s",
			    _PATH_SBIN, fstype);
			(void)execv(execname, saveargv);
			snprintf(execname, sizeof execname, "%s/newfs_%s",
			    _PATH_USRSBIN, fstype);
			(void)execv(execname, saveargv);
			err(1, "%s not found", name);
		}
	}

	if (mfs && !strcmp(special, "swap")) {
		/*
		 * it's an MFS, mounted on "swap."  fake up a label.
		 * XXX XXX XXX
		 */
		fso = -1;	/* XXX; normally done below. */

		memset(&mfsfakelabel, 0, sizeof(mfsfakelabel));
		mfsfakelabel.d_secsize = 512;
		mfsfakelabel.d_nsectors = 64;
		mfsfakelabel.d_ntracks = 16;
		mfsfakelabel.d_ncylinders = 16;
		mfsfakelabel.d_secpercyl = 1024;
		DL_SETDSIZE(&mfsfakelabel, 16384);
		mfsfakelabel.d_npartitions = 1;
		mfsfakelabel.d_version = 1;
		DL_SETPSIZE(&mfsfakelabel.d_partitions[0], 16384);
		mfsfakelabel.d_partitions[0].p_fragblock =
		    DISKLABELV1_FFS_FRAGBLOCK(1024, 8);
		mfsfakelabel.d_partitions[0].p_cpg = 16;

		lp = &mfsfakelabel;
		pp = &mfsfakelabel.d_partitions[0];

		goto havelabel;
	}
	if (Nflag) {
		fso = -1;
	} else {
		fso = opendev(special, O_WRONLY, 0, &realdev);
		if (fso < 0)
			fatal("%s: %s", special, strerror(errno));
		special = realdev;

		/* Bail if target special is mounted */
		n = getmntinfo(&mp, MNT_NOWAIT);
		if (n == 0)
			fatal("%s: getmntinfo: %s", special, strerror(errno));

		len = sizeof(_PATH_DEV) - 1;
		s1 = special;
		if (strncmp(_PATH_DEV, s1, len) == 0)
			s1 += len;

		while (--n >= 0) {
			s2 = mp->f_mntfromname;
			if (strncmp(_PATH_DEV, s2, len) == 0) {
				s2 += len - 1;
				*s2 = 'r';
			}
			if (strcmp(s1, s2) == 0 || strcmp(s1, &s2[1]) == 0)
				fatal("%s is mounted on %s",
				    special, mp->f_mntonname);
			++mp;
		}
	}
	if (mfs && disktype != NULL) {
		lp = (struct disklabel *)getdiskbyname(disktype);
		if (lp == NULL)
			fatal("%s: unknown disk type", disktype);
		pp = &lp->d_partitions[1];
	} else {
		fsi = opendev(special, O_RDONLY, 0, NULL);
		if (fsi < 0)
			fatal("%s: %s", special, strerror(errno));
		if (fstat(fsi, &st) < 0)
			fatal("%s: %s", special, strerror(errno));
		if (!mfs) {
			if (S_ISBLK(st.st_mode))
				fatal("%s: block device", special);
			if (!S_ISCHR(st.st_mode))
				warnx("%s: not a character-special device",
				    special);
		}
		if (*argv[0] == '\0')
			fatal("empty partition name supplied");
		cp = argv[0] + strlen(argv[0]) - 1;
		if ((*cp < 'a' || *cp > ('a' + maxpartitions - 1))
		    && !isdigit((unsigned char)*cp))
			fatal("%s: can't figure out file system partition",
			    argv[0]);
		lp = getdisklabel(special, fsi);
		if (!mfs) {
			if (pledge("stdio disklabel tty", NULL) == -1)
				err(1, "pledge");
		}
		if (isdigit((unsigned char)*cp))
			pp = &lp->d_partitions[0];
		else
			pp = &lp->d_partitions[*cp - 'a'];
		if (DL_GETPSIZE(pp) == 0)
			fatal("%s: `%c' partition is unavailable",
			    argv[0], *cp);
		if (pp->p_fstype == FS_BOOT)
			fatal("%s: `%c' partition overlaps boot program",
			      argv[0], *cp);
	}
havelabel:
	if (sectorsize == 0) {
		sectorsize = lp->d_secsize;
		if (sectorsize <= 0)
			fatal("%s: no default sector size", argv[0]);
	}

	if (fssize_usebytes) {
		nsecs = fssize_input / sectorsize;
		if (fssize_input % sectorsize != 0)
			nsecs++;
	} else if (fssize_input == 0)
		nsecs = DL_GETPSIZE(pp);
	else
		nsecs = fssize_input;

	if (nsecs > DL_GETPSIZE(pp) && !mfs)
	       fatal("%s: maximum file system size on the `%c' partition is "
		   "%llu sectors", argv[0], *cp, DL_GETPSIZE(pp));

	/* Can't use DL_SECTOBLK() because sectorsize may not be from label! */
	fssize = nsecs * (sectorsize / DEV_BSIZE);
	if (oflagset == 0 && fssize >= INT_MAX)
		Oflag = 2;	/* FFS2 */
	if (fsize == 0) {
		fsize = DISKLABELV1_FFS_FSIZE(pp->p_fragblock);
		if (fsize <= 0)
			fsize = MAXIMUM(DFL_FRAGSIZE, lp->d_secsize);
	}
	if (bsize == 0) {
		bsize = DISKLABELV1_FFS_BSIZE(pp->p_fragblock);
		if (bsize <= 0)
			bsize = MINIMUM(DFL_BLKSIZE, 8 * fsize);
	}
	if (density == 0)
		density = NFPI * fsize;
	if (minfree < MINFREE && opt != FS_OPTSPACE && reqopt == -1) {
		warnx("warning: changing optimization to space "
		    "because minfree is less than %d%%\n", MINFREE);
		opt = FS_OPTSPACE;
	}
	if (maxbpg == 0) {
		if (Oflag <= 1)
			maxbpg = MAXBLKPG_FFS1(bsize);
		else
			maxbpg = MAXBLKPG_FFS2(bsize);
	}
	oldpartition = *pp;
#ifdef MFS
	if (mfs) {
		if (realpath(argv[1], node) == NULL)
			err(1, "realpath %s", argv[1]);
		if (stat(node, &mountpoint) < 0)
			err(ECANCELED, "stat %s", node);
		mfsuid = mountpoint.st_uid;
		mfsgid = mountpoint.st_gid;
		mfsmode = mountpoint.st_mode & ALLPERMS;
	}
#endif

	mkfs(pp, special, fsi, fso, mfsmode, mfsuid, mfsgid);
	if (!Nflag && memcmp(pp, &oldpartition, sizeof(oldpartition)))
		rewritelabel(special, fso, lp);
	if (!Nflag)
		close(fso);
	close(fsi);
#ifdef MFS
	if (mfs) {
		struct mfs_args args;
		memset(&args, 0, sizeof(args));
		args.base = membase;
		args.size = fssize * DEV_BSIZE;
		args.export_info.ex_root = -2;
		if (mntflags & MNT_RDONLY)
			args.export_info.ex_flags = MNT_EXRDONLY;
		if (mntflags & MNT_NOPERM)
			mntflags |= MNT_NODEV | MNT_NOEXEC;

		switch (pid = fork()) {
		case -1:
			err(10, "mfs");
		case 0:
			snprintf(mountfromname, sizeof(mountfromname),
			    "mfs:%d", getpid());
			break;
		default:
			snprintf(mountfromname, sizeof(mountfromname),
			    "mfs:%d", pid);
			for (;;) {
				/*
				 * spin until the mount succeeds
				 * or the child exits
				 */
				usleep(1);

				/*
				 * XXX Here is a race condition: another process
				 * can mount a filesystem which hides our
				 * ramdisk before we see the success.
				 */
				if (statfs(node, &sf) < 0)
					err(ECANCELED, "statfs %s", node);
				if (!strcmp(sf.f_mntfromname, mountfromname) &&
				    !strncmp(sf.f_mntonname, node,
					     MNAMELEN) &&
				    !strcmp(sf.f_fstypename, "mfs")) {
					if (pop != NULL)
						copy(pop, node, &args);
					exit(0);
				}
				res = waitpid(pid, &status, WNOHANG);
				if (res == -1)
					err(EDEADLK, "waitpid");
				if (res != pid)
					continue;
				if (WIFEXITED(status)) {
					if (WEXITSTATUS(status) == 0)
						exit(0);
					errx(1, "%s: mount: %s", node,
					     strerror(WEXITSTATUS(status)));
				} else
					errx(EDEADLK, "abnormal termination");
			}
			/* NOTREACHED */
		}

		(void) setsid();
		(void) close(0);
		(void) close(1);
		(void) close(2);
		(void) chdir("/");

		args.fspec = mountfromname;
		if (mntflags & MNT_RDONLY && pop != NULL)
			mntflags &= ~MNT_RDONLY;
		if (mount(MOUNT_MFS, node, mntflags, &args) < 0)
			exit(errno); /* parent prints message */
	}
#endif
	exit(0);
}

struct disklabel *
getdisklabel(char *s, int fd)
{
	static struct disklabel lab;

	if (ioctl(fd, DIOCGDINFO, (char *)&lab) < 0) {
		if (disktype != NULL) {
			struct disklabel *lp;

			unlabeled++;
			lp = getdiskbyname(disktype);
			if (lp == NULL)
				fatal("%s: unknown disk type", disktype);
			return (lp);
		}
		warn("ioctl (GDINFO)");
		fatal("%s: can't read disk label; disk type must be specified",
		    s);
	}
	return (&lab);
}

void
rewritelabel(char *s, int fd, struct disklabel *lp)
{
	if (unlabeled)
		return;

	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	if (ioctl(fd, DIOCWDINFO, (char *)lp) < 0) {
		warn("ioctl (WDINFO)");
		fatal("%s: can't rewrite disk label", s);
	}
}

void
fatal(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	if (fcntl(STDERR_FILENO, F_GETFL) < 0) {
		openlog(__progname, LOG_CONS, LOG_DAEMON);
		vsyslog(LOG_ERR, fmt, ap);
		closelog();
	} else {
		vwarnx(fmt, ap);
	}
	va_end(ap);
	exit(1);
	/*NOTREACHED*/
}

__dead void
usage(void)
{
	extern char *__progname;

	if (mfs) {
	    fprintf(stderr,
	        "usage: %s [-b block-size] [-c fragments-per-cylinder-group] "
		"[-e maxbpg]\n"
		"\t[-f frag-size] [-i bytes] [-m free-space] [-o options] "
		"[-P file]\n"
		"\t[-s size] special node\n",
		__progname);
	} else {
	    fprintf(stderr,
	        "usage: %s [-Nq] [-b block-size] "
		"[-c fragments-per-cylinder-group] [-e maxbpg]\n"
		"\t[-f frag-size] [-g avgfilesize] [-h avgfpdir] [-i bytes]\n"
		"\t[-m free-space] [-O filesystem-format] [-o optimization]\n"
		"\t[-S sector-size] [-s size] [-T disktype] [-t fstype] "
		"special\n",
		__progname);
	}

	exit(1);
}

#ifdef MFS

static int
do_exec(const char *dir, const char *cmd, char *const argv[])
{
	pid_t pid;
	int ret, status;
	sig_t intsave, quitsave;

	switch (pid = fork()) {
	case -1:
		err(1, "fork");
	case 0:
		if (dir != NULL && chdir(dir) != 0)
			err(1, "chdir");
		if (execv(cmd, argv) != 0)
			err(1, "%s", cmd);
		break;
	default:
		intsave = signal(SIGINT, SIG_IGN);
		quitsave = signal(SIGQUIT, SIG_IGN);
		for (;;) {
			ret = waitpid(pid, &status, 0);
			if (ret == -1)
				err(11, "waitpid");
			if (WIFEXITED(status)) {
				status = WEXITSTATUS(status);
				if (status != 0)
					warnx("%s: exited", cmd);
				break;
			} else if (WIFSIGNALED(status)) {
				warnx("%s: %s", cmd,
				    strsignal(WTERMSIG(status)));
				status = 1;
				break;
			}
		}
		signal(SIGINT, intsave);
		signal(SIGQUIT, quitsave);
		return (status);
	}
	/* NOTREACHED */
	return (-1);
}

static int
isdir(const char *path)
{
	struct stat st;

	if (stat(path, &st) != 0)
		err(1, "cannot stat %s", path);
	if (!S_ISDIR(st.st_mode) && !S_ISBLK(st.st_mode))
		errx(1, "%s: not a dir or a block device", path);
	return (S_ISDIR(st.st_mode));
}

static void
copy(char *src, char *dst, struct mfs_args *args)
{
	int ret, dir, created = 0;
	struct ufs_args mount_args;
	char mountpoint[MNAMELEN];
	char *const argv[] = { "pax", "-rw", "-pe", ".", dst, NULL } ;

	dir = isdir(src);
	if (dir)
		strlcpy(mountpoint, src, sizeof(mountpoint));
	else {
		created = gettmpmnt(mountpoint, sizeof(mountpoint));
		memset(&mount_args, 0, sizeof(mount_args));
		mount_args.fspec = src;
		ret = mount(MOUNT_FFS, mountpoint, MNT_RDONLY, &mount_args);
		if (ret != 0) {
			int saved_errno = errno;
			if (created && rmdir(mountpoint) != 0)
				warn("rmdir %s", mountpoint);
			if (unmount(dst, 0) != 0)
				warn("unmount %s", dst);
			errc(1, saved_errno, "mount %s %s", src, mountpoint);
		}
	}
	ret = do_exec(mountpoint, "/bin/pax", argv);
	if (!dir && unmount(mountpoint, 0) != 0)
		warn("unmount %s", mountpoint);
	if (created && rmdir(mountpoint) != 0)
		warn("rmdir %s", mountpoint);
	if (ret != 0) {
		if (unmount(dst, 0) != 0)
			warn("unmount %s", dst);
		errx(1, "copy %s to %s failed", mountpoint, dst);
	}

	if (mntflags & MNT_RDONLY) {
		mntflags |= MNT_UPDATE;
		if (mount(MOUNT_MFS, dst, mntflags, args) < 0) {
			warn("%s: mount (update, rdonly)", dst);
			if (unmount(dst, 0) != 0)
				warn("unmount %s", dst);
			exit(1);
		}
	}
}

static int
gettmpmnt(char *mountpoint, size_t len)
{
	const char *tmp = _PATH_TMP;
	const char *mnt = _PATH_MNT;
	struct statfs fs;
	size_t n;

	if (statfs(tmp, &fs) != 0)
		err(1, "statfs %s", tmp);
	if (fs.f_flags & MNT_RDONLY) {
		if (statfs(mnt, &fs) != 0)
			err(1, "statfs %s", mnt);
		if (strcmp(fs.f_mntonname, "/") != 0)
			errx(1, "tmp mountpoint %s busy", mnt);
		if (strlcpy(mountpoint, mnt, len) >= len)
			errx(1, "tmp mountpoint %s too long", mnt);
		return (0);
	}
	n = strlcpy(mountpoint, tmp, len);
	if (n >= len)
		errx(1, "tmp mount point too long");
	if (mountpoint[n - 1] != '/')
		strlcat(mountpoint, "/", len);
	n = strlcat(mountpoint, "mntXXXXXXXXXX", len);
	if (n >= len)
		errx(1, "tmp mount point too long");
	if (mkdtemp(mountpoint) == NULL)
		err(1, "mkdtemp %s", mountpoint);
	return (1);
}

#endif /* MFS */
@


1.108
log
@Revert change to density calculation. David Vasek points out this
is a more complicated problem than it appears.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.107 2016/07/23 09:12:33 krw Exp $	*/
d81 1
d526 2
@


1.107
log
@At n2k16 David Vasek pointed out that FFS partitions on 4K disks are
created with far fewer inodes than DEV_BSIZE devices.

Scale the default 'density' value by (sector size)/DEV_BSIZE to
create the same number of inodes. Obviously a NO-OP on DEV_BSIZE
devices.

Thanks David!

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.106 2016/05/31 16:41:08 deraadt Exp $	*/
d485 1
a485 1
		density = (NFPI * fsize) / (sectorsize / DEV_BSIZE);
@


1.106
log
@permit wxallowed on mfs
discussed with naddy a bit, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.105 2016/03/09 16:28:47 deraadt Exp $	*/
d485 1
a485 1
		density = NFPI * fsize;
@


1.105
log
@We are done providing support for the vax.
lots of agreement.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.104 2015/12/06 11:56:47 tobias Exp $	*/
d80 1
@


1.104
log
@Avoid out of boundary access on illegal command line arguments.

ok deraadt, mmcc, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.103 2015/11/25 19:45:21 kettenis Exp $	*/
a622 38
#ifdef __vax__
	if (lp->d_type == DTYPE_SMD && lp->d_flags & D_BADSECT) {
		int i;
		int cfd;
		u_int64_t alt;
		char specname[64];
		char blk[1024];
		char *cp;

		/*
		 * Make name for 'c' partition.
		 */
		if (*s == '\0' ||
		    strlcpy(specname, s, sizeof(specname)) >= sizeof(specname))
			fatal("%s: invalid partition name supplied", s);
		cp = specname + strlen(specname) - 1;
		if (!isdigit((unsigned char)*cp))
			*cp = 'c';
		cfd = open(specname, O_WRONLY);
		if (cfd < 0)
			fatal("%s: %s", specname, strerror(errno));
		memset(blk, 0, sizeof(blk));
		*(struct disklabel *)(blk + LABELOFFSET) = *lp;
		alt = lp->d_ncylinders * lp->d_secpercyl - lp->d_nsectors;
		for (i = 1; i < 11 && i < lp->d_nsectors; i += 2) {
			off_t offset;

			offset = alt + i;
			offset *= lp->d_secsize;
			if (lseek(cfd, offset, SEEK_SET) == -1)
				fatal("lseek to badsector area: %s",
				    strerror(errno));
			if (write(cfd, blk, lp->d_secsize) != lp->d_secsize)
				warn("alternate label %d write", i/2);
		}
		close(cfd);
	}
#endif	/*__vax__*/
@


1.103
log
@We can't make a pledge if we're mount_mfs(8) as we need the ability to call
mount(2).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.102 2015/11/23 19:19:30 deraadt Exp $	*/
d426 5
a430 4
		cp = strchr(argv[0], '\0') - 1;
		if (cp == NULL ||
		    ((*cp < 'a' || *cp > ('a' + maxpartitions - 1))
		    && !isdigit((unsigned char)*cp)))
d635 3
a637 2
		strncpy(specname, s, sizeof(specname) - 1);
		specname[sizeof(specname) - 1] = '\0';
@


1.102
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.101 2015/11/10 07:38:19 deraadt Exp $	*/
d433 4
a436 2
		if (pledge("stdio disklabel tty", NULL) == -1)
			err(1, "pledge");
@


1.101
log
@newfs does not need TMPDIR support
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.100 2015/09/29 03:19:24 guenther Exp $	*/
d91 1
d151 12
d198 1
d433 2
@


1.100
log
@Delete the final, inscrutable NOSTRICT and VARARGS lint comments

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.99 2015/01/20 18:22:21 deraadt Exp $	*/
d795 1
a795 1
	const char *tmp;
a798 4

	tmp = getenv("TMPDIR");
	if (tmp == NULL || *tmp == '\0')
		tmp = _PATH_TMP;
@


1.99
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.98 2015/01/16 06:40:00 deraadt Exp $	*/
a642 1
/*VARARGS*/
@


1.98
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.97 2014/07/20 01:38:40 guenther Exp $	*/
d42 1
a42 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE MAXBSIZE */
@


1.97
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.96 2014/07/20 00:46:26 guenther Exp $	*/
d42 1
a42 1
#include <sys/param.h>
d68 1
d75 3
d165 1
a165 1
	char *pop = NULL, node[MAXPATHLEN];
d321 1
a321 1
		char execname[MAXPATHLEN], name[MAXPATHLEN];
d457 1
a457 1
			fsize = MAX(DFL_FRAGSIZE, lp->d_secsize);
d462 1
a462 1
			bsize = MIN(DFL_BLKSIZE, 8 * fsize);
@


1.96
log
@Mark fatal() as printf-like.
Don't put a format string that's only used once in a variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.95 2013/11/22 04:12:48 deraadt Exp $	*/
d759 1
d764 1
a764 1
			err(1, "mount %s %s", src, mountpoint);
@


1.95
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.94 2013/11/05 00:51:58 krw Exp $	*/
d82 3
a84 1
void	fatal(const char *fmt, ...);
a565 2
char lmsg[] = "%s: can't read disk label; disk type must be specified";

d582 2
a583 1
		fatal(lmsg, s);
@


1.94
log
@Replace direct references to p_size, p_offset and d_secperunit with
DL_[GET|SET]PSIZE(), DL_[GET|SET]POFFSET(), DL_[GET|SET]DSIZE() in
order to get|set correct value that includes the high bits of the
value.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.93 2013/10/07 10:05:24 krw Exp $	*/
d276 1
a276 1
				if (isalpha(*s1)) {
d409 1
a409 1
		    && !isdigit(*cp)))
d413 1
a413 1
		if (isdigit(*cp))
d614 1
a614 1
		if (!isdigit(*cp))
@


1.93
log
@Oops. Too mechanical -- can't use DL_SECTOBLK() to set fssize, since
command line sector size overrides disk label sector size. Add a comment
to make sure I don't do it again.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.92 2013/10/06 22:13:26 krw Exp $	*/
d345 1
a345 1
		mfsfakelabel.d_secperunit = 16384;
@


1.92
log
@daddr_t tweaks. %lld -> %llu, intermediate disk sector calculation
variable, drop pointless casts, vax-only sector variable to u_int64_t.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.91 2013/06/11 16:42:05 deraadt Exp $	*/
d444 2
a445 1
	fssize = DL_SECTOBLK(lp, nsecs);
@


1.91
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.90 2011/05/23 10:56:17 dcoppa Exp $	*/
d116 1
a116 1
daddr_t	fssize;			/* file system size */
d174 1
d432 3
a434 3
		fssize = (daddr_t)fssize_input / (daddr_t)sectorsize;
		if ((daddr_t)fssize_input % (daddr_t)sectorsize != 0)
			fssize++;
d436 1
a436 1
		fssize = DL_GETPSIZE(pp);
d438 1
a438 1
		fssize = (daddr_t)fssize_input;
d440 1
a440 1
	if (fssize > DL_GETPSIZE(pp) && !mfs)
d442 1
a442 1
		   "%lld sectors", argv[0], *cp, DL_GETPSIZE(pp));
d444 1
a444 1
	fssize *= sectorsize / DEV_BSIZE;
d602 1
a602 1
		daddr_t alt;
@


1.90
log
@Allow specifying k/m/g/... suffixes in newfs(8) -S and -s options.

Useful for mount_mfs, now you can just say:

# mount_mfs -s 50m swap /tmp

And it will do what you want, taking into account sector size.

Old behaviour of -s (specifying count of sectors) is, of course,
preserved.

All the work was done by Vadim Zhukov (persgray(at)gmail com).

OK myself, otto@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.89 2011/04/26 14:02:14 otto Exp $	*/
d116 1
a116 1
daddr64_t	fssize;			/* file system size */
d431 2
a432 2
		fssize = (daddr64_t)fssize_input / (daddr64_t)sectorsize;
		if ((daddr64_t)fssize_input % (daddr64_t)sectorsize != 0)
d437 1
a437 1
		fssize = (daddr64_t)fssize_input;
d601 1
a601 1
		daddr64_t alt;
@


1.89
log
@setrlimit only if mfs; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.88 2010/12/13 00:02:58 marco Exp $	*/
d117 1
a117 1
int	sectorsize;		/* bytes/sector */
d172 2
d197 3
a199 3
			sectorsize = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("sector size is %s: %s", errstr, optarg);
d270 9
a278 4
			fssize = strtonum(optarg, 1, LLONG_MAX, &errstr);
			if (errstr)
				fatal("file system size is %s: %s",
				    errstr, optarg);
a423 6
	if (fssize == 0)
		fssize = DL_GETPSIZE(pp);
	if (fssize > DL_GETPSIZE(pp) && !mfs)
	       fatal("%s: maximum file system size on the `%c' partition is %lld",
			argv[0], *cp, DL_GETPSIZE(pp));

d429 14
@


1.88
log
@stray tab
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.87 2010/07/24 00:28:41 tedu Exp $	*/
d296 6
a301 4
	/* Increase our data size to the max */
	if (getrlimit(RLIMIT_DATA, &rl) == 0) {
		rl.rlim_cur = rl.rlim_max;
		(void)setrlimit(RLIMIT_DATA, &rl);
@


1.87
log
@mount -f doesn't help mfs, but it doesn't hurt, so stop warning about it.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.86 2010/07/02 22:02:48 deraadt Exp $	*/
d172 1
a172 1
	
@


1.86
log
@garbage collect an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.85 2010/05/18 04:41:14 dlg Exp $	*/
d78 1
@


1.85
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.84 2010/05/03 14:28:08 jsing Exp $	*/
a128 1
u_long	memleft;		/* virtual memory available */
@


1.84
log
@Switch newfs to opendev(3) - this simplies the code and will allow it to
benefit from planned changes to opendev(3).

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.83 2010/04/23 15:25:21 jsing Exp $	*/
d46 1
@


1.83
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.81 2008/08/08 23:49:53 krw Exp $	*/
a131 1
char	device[MAXPATHLEN];
d155 1
a155 1
	char *cp = NULL, *s1, *s2, *special, *opstring;
a346 12
	cp = strrchr(special, '/');
	if (cp == NULL) {
		/*
		 * No path prefix; try /dev/r%s then /dev/%s.
		 */
		(void)snprintf(device, sizeof(device), "%sr%s",
			       _PATH_DEV, special);
		if (stat(device, &st) == -1)
			(void)snprintf(device, sizeof(device), "%s%s",
				       _PATH_DEV, special);
		special = device;
	}
d350 1
a350 1
		fso = open(special, O_WRONLY);
d353 1
d383 1
a383 1
		fsi = open(special, O_RDONLY);
d396 2
a397 1
		if (cp == NULL || ((*cp < 'a' || *cp > ('a' + maxpartitions - 1))
@


1.82
log
@Make FFS2 the default format for file systems larger than INT_MAX
512-byte blocks. Better than just blowing up. Tweak man page to document
this and clarify various things.

Inspired by problems noted during an install by Harald Dunkel.

Suggestions and man page corrections from otto@@ and jmc@@

ok beck@@
@
text
@a335 2
		mfsfakelabel.d_rpm = 3600;
		mfsfakelabel.d_interleave = 1;
@


1.81
log
@Admit b_blkno means block number; a block is DEV_BSIZE (a.k.a.
512) bytes; ffs is inextricably tied to using b_blkno and disklabel
always uses sectorsize units.

Thus use DEV_BSIZE units for all fields describing ffs filesystems
and convert to/from sectors where required. This enables the creation
and use of ffs filesystems on non-512 byte sectorsize devices.

This diff allows i386 and sgi (the two test platforms) to find
disklabels that are not on a sectorsize boundary. Same change to
further archs coming.

This is a no-op on 512-byte sectorsize devices.

This work triggered by jsing@@'s need to create ffs filesystems on
sgi cdroms so we can create cdrom install media for sgi.

sgi testing by jsing@@

ok jsing@@ pedro@@ "looks sane" beck@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.80 2008/08/04 18:46:32 otto Exp $	*/
d155 1
a155 1
	int fsi = -1, fso, len, n, maxpartitions;
d192 1
d432 1
d439 2
@


1.80
log
@refuse to run on block devices; prompted by marco; ok marco@@ millert@@
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.79 2008/07/06 15:03:36 krw Exp $	*/
d436 1
d484 1
a484 1
		args.size = fssize * sectorsize;
@


1.79
log
@Don't change the size of the partition being newfs'd when sectorsize,
either from the disklabel or via -S, is not 512 bytes. Disklabel
partition sizes are sectors and not 512 byte blocks. One less 'block
is 512 bytes' assumption. 2^32 or so to go.

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.78 2008/06/27 18:50:43 sobrado Exp $	*/
d401 7
a407 3
		if (!S_ISCHR(st.st_mode) && !mfs)
			warnx("%s: not a character-special device\n",
			    special);
@


1.78
log
@documentation tweak.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.77 2008/06/24 15:07:02 jmc Exp $	*/
a115 1
int	realsectorsize;		/* bytes/sector in hardware */
a455 14
	realsectorsize = sectorsize;
	if (sectorsize < DEV_BSIZE) {
		int secperblk = DEV_BSIZE / sectorsize;

		sectorsize = DEV_BSIZE;
		fssize /= secperblk;
		DL_SETPSIZE(pp, DL_GETPSIZE(pp) / secperblk);
	} else if (sectorsize > DEV_BSIZE) {
		int blkpersec = sectorsize / DEV_BSIZE;

		sectorsize = DEV_BSIZE;
		fssize *= blkpersec;
		DL_SETPSIZE(pp, DL_GETPSIZE(pp) * blkpersec);
	}
a468 4
	if (realsectorsize < DEV_BSIZE)
		DL_SETPSIZE(pp, DL_GETPSIZE(pp) * DEV_BSIZE / realsectorsize);
	else if (realsectorsize > DEV_BSIZE)
		DL_SETPSIZE(pp, DL_GETPSIZE(pp) / realsectorsize / DEV_BSIZE);
@


1.77
log
@- move -S and -t into the main option descriptions: they were the only
options left of the old tuning list, and it makes sense to have one list
now
- document -T. this was requested by todd (fries), and comes largely from
the description in netbsd's page of the same name

ok millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.76 2008/06/04 14:21:34 tobias Exp $	*/
d669 1
a669 1
		"\t[-f frag-size] [-i bytes] [-m free space] [-o options] "
@


1.76
log
@warnx already prepends string with a colon, no need to manually add one
here.

ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.75 2008/01/29 13:02:31 krw Exp $	*/
d679 2
a680 1
		"\t[-S sector-size] [-s size] [-t fstype] special\n",
@


1.75
log
@More read/write result checking fixes to avoid unsigned comparisons vs
-1.

ok henning@@ beck@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.74 2008/01/15 14:23:25 sthen Exp $	*/
d403 1
a403 1
			warnx(": %s: not a character-special device\n",
@


1.74
log
@s/fragements/fragments/ in usage().

'please fix' jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.73 2007/11/26 12:19:37 tedu Exp $	*/
d633 1
a633 1
			if (write(cfd, blk, lp->d_secsize) < lp->d_secsize)
@


1.73
log
@revised diff that handles the no mfs parts correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.72 2007/11/25 22:09:35 deraadt Exp $	*/
d667 1
a667 1
	        "usage: %s [-b block-size] [-c fragements-per-cylinder-group] "
@


1.72
log
@when running as newfs, there is no argv[1].. backout previous
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.70 2007/11/05 11:37:25 otto Exp $	*/
d160 1
a160 1
	char *pop = NULL;
d173 1
a173 1

d303 1
d473 4
a476 2
		if (stat(argv[1], &mountpoint) < 0)
			err(88, "stat %s", argv[1]);
d525 2
a526 2
				if (statfs(argv[1], &sf) < 0)
					err(88, "statfs %s", argv[1]);
d528 1
a528 1
				    !strncmp(sf.f_mntonname, argv[1],
d532 1
a532 1
						copy(pop, argv[1], &args);
d537 1
a537 1
					err(11, "waitpid");
d543 1
a543 1
					errx(1, "%s: mount: %s", argv[1],
d546 1
a546 1
					errx(11, "abnormal termination");
d560 1
a560 1
		if (mount(MOUNT_MFS, argv[1], mntflags, &args) < 0)
@


1.71
log
@Iruata Souza sent a diff that fixes weird occurences when mounting with
a relative path:  use realpath to only mount with absolute names.
ok deraadt thib
@
text
@d160 1
a160 1
	char *pop, node[MAXPATHLEN];
a172 2
	
	pop = NULL;
a302 3
	if (realpath(argv[1], node) == NULL)
		err(1, "realpath %s", argv[1]);

d472 2
a473 2
		if (stat(node, &mountpoint) < 0)
			err(ECANCELED, "stat %s", node);
d522 2
a523 2
				if (statfs(node, &sf) < 0)
					err(ECANCELED, "statfs %s", node);
d525 1
a525 1
				    !strncmp(sf.f_mntonname, node,
d529 1
a529 1
						copy(pop, node, &args);
d534 1
a534 1
					err(EDEADLK, "waitpid");
d540 1
a540 1
					errx(1, "%s: mount: %s", node,
d543 1
a543 1
					errx(EDEADLK, "abnormal termination");
d557 1
a557 1
		if (mount(MOUNT_MFS, node, mntflags, &args) < 0)
@


1.70
log
@forgotten arg to printf, Tobias Ulmer
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.69 2007/06/26 19:03:21 otto Exp $	*/
d160 1
a160 1
	char *pop = NULL;
d173 2
d305 3
d477 2
a478 2
		if (stat(argv[1], &mountpoint) < 0)
			err(88, "stat %s", argv[1]);
d527 2
a528 2
				if (statfs(argv[1], &sf) < 0)
					err(88, "statfs %s", argv[1]);
d530 1
a530 1
				    !strncmp(sf.f_mntonname, argv[1],
d534 1
a534 1
						copy(pop, argv[1], &args);
d539 1
a539 1
					err(11, "waitpid");
d545 1
a545 1
					errx(1, "%s: mount: %s", argv[1],
d548 1
a548 1
					errx(11, "abnormal termination");
d562 1
a562 1
		if (mount(MOUNT_MFS, argv[1], mntflags, &args) < 0)
@


1.69
log
@Enable creation of larger than 1TB FFS2 filesystems. Note that this
won't work yet. There remains sys/ufs work.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.68 2007/06/10 19:11:43 otto Exp $	*/
d260 2
a261 1
					    "preference: use `space' or `time'.");
@


1.68
log
@remove last instances of daddr_t; ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.67 2007/06/01 23:42:35 pedro Exp $	*/
d114 1
a114 1
int	fssize;			/* file system size */
d267 1
a267 1
			fssize = strtonum(optarg, 1, INT_MAX, &errstr);
d337 2
a338 1
		mfsfakelabel.d_partitions[0].p_size = 16384;
d413 1
a413 1
		if (pp->p_size == 0)
d422 4
a425 4
		fssize = pp->p_size;
	if (fssize > pp->p_size && !mfs)
	       fatal("%s: maximum file system size on the `%c' partition is %d",
			argv[0], *cp, pp->p_size);
d461 1
a461 1
		pp->p_size /= secperblk;
d467 1
a467 1
		pp->p_size *= blkpersec;
d481 1
a481 1
		pp->p_size *= DEV_BSIZE / realsectorsize;
d483 1
a483 1
		pp->p_size /= realsectorsize / DEV_BSIZE;
@


1.67
log
@ufs1_daddr_t cleanup, okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.66 2007/06/01 06:41:35 deraadt Exp $	*/
d601 1
a601 1
		daddr_t alt;
@


1.66
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.65 2007/05/29 06:28:16 otto Exp $	*/
d101 2
a102 2
#define MAXBLKPG_FFS1(bsize)	((bsize) / sizeof(ufs1_daddr_t))
#define MAXBLKPG_FFS2(bsize)	((bsize) / sizeof(daddr64_t))
@


1.65
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.64 2007/05/20 11:28:06 millert Exp $	*/
d102 1
a102 1
#define MAXBLKPG_FFS2(bsize)	((bsize) / sizeof(ufs2_daddr_t))
@


1.64
log
@Update usage wrt -c option when called as mount_mfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.63 2007/05/19 20:12:50 otto Exp $	*/
d171 1
a171 1
	int ffs = 1;
d275 1
a275 1
				ffs = 0;
d286 1
a286 1
		if (!ffs)
d292 1
a292 1
	if (ffs && argc - mfs != 1)
d338 2
a339 2
		mfsfakelabel.d_partitions[0].p_fsize = 1024;
		mfsfakelabel.d_partitions[0].p_frag = 8;
d431 1
a431 1
		fsize = pp->p_fsize;
d436 1
a436 1
		bsize = pp->p_frag * pp->p_fsize;
@


1.63
log
@Now that the amd64 floppy and cd image -c setting have been fixed,
recommit the -c changes. For now, we warn only if we cannot honour -c.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.62 2007/05/19 01:28:15 deraadt Exp $	*/
d662 1
a662 1
	        "usage: %s [-b block-size] [-c blocks-per-cylinder-group] "
@


1.62
log
@backout -c changes; they were not tested on all the media.  all newfs
changes obviously *MUST* be checked against whatever weird things the
floppies do to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.60 2007/05/15 09:35:47 thib Exp $	*/
d119 1
a119 1
int	maxblkspercg = INT_MAX;	/* maximum blocks per cylinder group */
d208 1
a208 1
			maxblkspercg = strtonum(optarg, 1, INT_MAX, &errstr);
d210 1
a210 1
				fatal("blocks per cylinder group is %s: %s",
d671 1
a671 1
		"[-c blocks-per-cylinder-group] [-e maxbpg]\n"
@


1.61
log
@The unit of the -c options is fragments, so adjust man page and
variable name; correct the loop packing more inodes into the cg:
in some cases it could put more fragments into the cg than requested;
give an error if the -c option cannot be honoured. ok millert@@ pedro@@
@
text
@d119 1
a119 1
int	maxfrgspercg = INT_MAX;	/* maximum fragments per cylinder group */
d208 1
a208 1
			maxfrgspercg = strtonum(optarg, 1, INT_MAX, &errstr);
d210 1
a210 1
				fatal("fragments per cylinder group is %s: %s",
d671 1
a671 1
		"[-c fragments-per-cylinder-group] [-e maxbpg]\n"
@


1.60
log
@Make usage declaration match prototype; Make it __dead also.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.59 2007/04/13 20:08:30 millert Exp $	*/
d119 1
a119 1
int	maxblkspercg = INT_MAX;	/* maximum blocks per cylinder group */
d208 1
a208 1
			maxblkspercg = strtonum(optarg, 1, INT_MAX, &errstr);
d210 1
a210 1
				fatal("blocks per cylinder group is %s: %s",
d671 1
a671 1
		"[-c blocks-per-cylinder-group] [-e maxbpg]\n"
@


1.59
log
@Missing bit in last commit, remove -z for getopt string.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.58 2007/04/13 20:04:38 jmc Exp $	*/
d81 1
a81 1
void	usage(void);
d655 1
a655 1
static void
@


1.58
log
@cut the verbosity from usage() and instead print a synopsis,
as matched by the man page; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.57 2007/04/13 17:33:02 millert Exp $	*/
d183 1
a183 1
	    "NO:S:T:b:c:e:f:g:h:i:m:o:qs:t:z:";
@


1.57
log
@Add support for creating ffs2 filesystems.  Note that the concept
of a constant-sized track is obsolete in today's world of variable
blocks per track disks so the cylinder group packing algorithm has
been updated.  Based on the ufs2 changes in FreeBSD by Kirk McKusick.
From pedro@@ with changes by me as well as a few from NetBSD.
OK pedro@@ beck@@ thib@@ and tested by more...
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.56 2007/04/03 20:59:34 millert Exp $	*/
d655 1
a655 27
struct fsoptions {
	char *str;
	int mfs_too;
} fsopts[] = {
	{ "-N do not create file system, just print out parameters", 0 },
	{ "-O file system format: 0 -> 4.3BSD, 1 -> FFS1, 2 -> FFS2", 0 },
#ifdef MFS
	{ "-P src populate mfs filesystem", 2 },
#endif
	{ "-S sector size", 0 },
	{ "-T disktype", 0 },
	{ "-b block size", 1 },
	{ "-c blocks per cylinders group", 1 },
	{ "-e maximum blocks per file in a cylinder group", 1 },
	{ "-f frag size", 1 },
	{ "-g average file size", 0 },
	{ "-h average files per directory", 0 },
	{ "-i number of bytes per inode", 1 },
	{ "-m minimum free space %%", 1 },
	{ "-n number of distinguished rotational positions", 0 },
	{ "-o optimization preference (`space' or `time')", 1 },
	{ "-s file system size (sectors)", 1 },
	{ "-t file system type", 0 },
	{ NULL, NULL }
};

void
d658 1
a658 1
	struct fsoptions *fsopt;
d661 7
a667 3
		fprintf(stderr,
		    "usage: %s [ -fsoptions ] special-device mount-point\n",
			__progname);
d669 7
a675 7
		fprintf(stderr,
		    "usage: %s [ -fsoptions ] special-device\n", __progname);
	}
	fprintf(stderr, "where fsoptions are:\n");
	for (fsopt = fsopts; fsopt->str; fsopt++) {
		if (!mfs || fsopt->mfs_too == 1 || (mfs && fsopt->mfs_too == 2))
			fprintf(stderr, "\t%s\n", fsopt->str);
d677 1
@


1.56
log
@Use strtonum(), not atoi().  OK deraadt, with help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.55 2007/04/03 18:42:32 millert Exp $	*/
d5 9
d52 1
a96 8
 * Cylinder groups may have up to many cylinders. The actual
 * number used depends upon how much information can be stored
 * on a single cylinder. The default is to use as many as
 * possible.
 */
#define	DESCPG		65536	/* desired fs_cpg */

/*
d101 2
a102 1
#define MAXBLKPG(bsize)	((bsize) / sizeof(daddr_t))
d113 1
a113 1
int	Oflag;			/* format as an 4.3BSD file system */
a114 3
int	ntracks;		/* # tracks/cylinder */
int	nsectors;		/* # sectors/track */
int	secpercyl;		/* sectors per cylinder */
d119 1
a119 2
int	cpg;			/* cylinders/cylinder group */
int	cpgflg;			/* cylinders/cylinder group flag was given */
a123 1
int	maxcontig = 0;		/* max contiguous blocks to allocate */
a126 2
int	bbsize = BBSIZE;	/* boot block size */
int	sbsize = SBSIZE;	/* superblock size */
d156 2
a157 2
	int fsi = -1, fso, len, n, ncyls, maxpartitions;
	char *cp, *s1, *s2, *special, *opstring;
d182 2
a183 2
	    "P:T:a:b:c:e:f:i:m:o:s:" :
	    "NOS:T:a:b:c:e:f:g:h:i:m:o:qs:t:u:z:";
d190 3
a192 1
			Oflag = 1;
a201 6
		case 'a':
			maxcontig = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("maximum contiguous blocks %s: %s",
				    errstr, optarg);
			break;
d208 1
a208 1
			cpg = strtonum(optarg, 1, INT_MAX, &errstr);
d210 1
a210 1
				fatal("cylinders/group is %s: %s",
a211 1
			cpgflg++;
a271 5
		case 'z':
			ntracks = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("total tracks is %s: %s", errstr, optarg);
			break;
a276 6
		case 'u':
			nsectors = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				fatal("sectors/track is %s: %s",
				    errstr, optarg);
			break;
d400 2
a401 2
			printf("%s: %s: not a character-special device\n",
			    __progname, special);
a424 10
	if (ntracks == 0) {
		ntracks = lp->d_ntracks;
		if (ntracks <= 0)
			fatal("%s: no default #tracks", argv[0]);
	}
	if (nsectors == 0) {
		nsectors = lp->d_nsectors;
		if (nsectors <= 0)
			fatal("%s: no default #sectors/track", argv[0]);
	}
a439 8
	/*
	 * Maxcontig sets the default for the maximum number of blocks
	 * that may be allocated sequentially. With filesystem clustering
	 * it is possible to allocate contiguous blocks up to the maximum
	 * transfer size permitted by the controller or buffering.
	 */
	if (maxcontig == 0)
		maxcontig = MAX(1, MIN(MAXPHYS, MAXBSIZE) / bsize - 1);
d443 2
a444 2
		fprintf(stderr, "Warning: changing optimization to space ");
		fprintf(stderr, "because minfree is less than %d%%\n", MINFREE);
d447 6
a452 8
	secpercyl = nsectors * ntracks;
	if (secpercyl != lp->d_secpercyl)
		fprintf(stderr, "%s (%d) %s (%lu)\n",
		    "Warning: calculated sectors per cylinder", secpercyl,
		    "disagrees with disk label",
		    (unsigned long)lp->d_secpercyl);
	if (maxbpg == 0)
		maxbpg = MAXBLKPG(bsize);
a458 2
		nsectors /= secperblk;
		secpercyl /= secperblk;
a464 2
		nsectors *= blkpersec;
		secpercyl *= blkpersec;
a467 10
	ncyls = fssize / secpercyl;
	if (ncyls < 2)
		ncyls = 2;
	if (cpg == 0)
		cpg = DESCPG < ncyls ? DESCPG : ncyls;
	else if (cpg > ncyls) {
		cpg = ncyls;
		printf("Number of cylinders restricts cylinders per group "
		    "to %d.\n", cpg);
	}
d660 1
a660 1
	{ "-O create a 4.3BSD format filesystem", 0 },
a665 1
	{ "-a maximum contiguous blocks", 1 },
d667 1
a667 1
	{ "-c cylinders/group", 1 },
a677 2
	{ "-u sectors/track", 0 },
	{ "-z tracks/cylinder", 0 },
@


1.55
log
@Remove obsolete options for superblock fields that are no longer used.
OK deraadt @@, OK in principle tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.54 2007/04/03 17:08:30 millert Exp $	*/
d176 1
d197 3
a199 2
			if ((sectorsize = atoi(optarg)) <= 0)
				fatal("%s: bad sector size", optarg);
d205 4
a208 3
			if ((maxcontig = atoi(optarg)) <= 0)
				fatal("%s: bad maximum contiguous blocks\n",
				    optarg);
d211 3
a213 2
			if ((bsize = atoi(optarg)) < 0)
				fatal("%s: bad block size", optarg);
d216 4
a219 2
			if ((cpg = atoi(optarg)) <= 0)
				fatal("%s: bad cylinders/group", optarg);
d223 4
a226 3
			if ((maxbpg = atoi(optarg)) <= 0)
		fatal("%s: bad blocks per file in a cylinder group\n",
				    optarg);
d229 5
a233 2
			if ((fsize = atoi(optarg)) <= 0)
				fatal("%s: bad fragment size", optarg);
d236 4
a239 2
			if ((avgfilesize = atoi(optarg)) <= 0)
				fatal("%s: bad average file size", optarg);
d242 4
a245 2
			if ((avgfilesperdir = atoi(optarg)) <= 0)
				fatal("%s: bad average files per dir", optarg);
d248 4
a251 2
			if ((density = atoi(optarg)) <= 0)
				fatal("%s: bad bytes per inode\n", optarg);
d254 4
a257 2
			if ((minfree = atoi(optarg)) < 0 || minfree > 99)
				fatal("%s: bad free space %%\n", optarg);
d276 4
a279 2
			if ((fssize = atoi(optarg)) <= 0)
				fatal("%s: bad file system size", optarg);
d282 3
a284 2
			if ((ntracks = atoi(optarg)) <= 0)
				fatal("%s: bad total tracks", optarg);
d292 4
a295 2
			if ((nsectors = atoi(optarg)) <= 0)
				fatal("%s: bad sectors/track", optarg);
@


1.54
log
@Minor cleanup: remove rcsids, remove #ifdef'd out code, COMPAT is
the default, quiet gcc.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.53 2007/04/02 20:20:39 millert Exp $	*/
a116 3
int	rpm;			/* revolutions/minute of drive */
int	interleave;		/* hardware sector interleave */
int	trackskew = -1;		/* sector 0 skew, per track */
a125 1
int	rotdelay = 0;		/* rotational delay between blocks */
d185 2
a186 2
	    "P:T:a:b:c:d:e:f:i:m:o:s:" :
	    "NOS:T:a:b:c:d:e:f:g:h:i:k:l:m:o:qr:s:t:u:z:";
a215 4
		case 'd':
			if ((rotdelay = atoi(optarg)) < 0)
				fatal("%s: bad rotational delay\n", optarg);
			break;
a236 8
		case 'k':
			if ((trackskew = atoi(optarg)) < 0)
				fatal("%s: bad track skew", optarg);
			break;
		case 'l':
			if ((interleave = atoi(optarg)) <= 0)
				fatal("%s: bad interleave", optarg);
			break;
a256 4
		case 'r':
			if ((rpm = atoi(optarg)) <= 0)
				fatal("%s: bad revolutions/minute\n", optarg);
			break;
a421 5
	if (rpm == 0) {
		rpm = lp->d_rpm;
		if (rpm <= 0)
			rpm = 3600;
	}
a436 10
	if (trackskew == -1) {
		trackskew = lp->d_trackskew;
		if (trackskew < 0)
			trackskew = 0;
	}
	if (interleave == 0) {
		interleave = lp->d_interleave;
		if (interleave <= 0)
			interleave = 1;
	}
a699 1
	{ "-d rotational delay between contiguous blocks", 1 },
a704 2
	{ "-k sector 0 skew, per track", 0 },
	{ "-l hardware sector interleave", 0 },
a707 1
	{ "-r revolutions/minute", 0 },
@


1.53
log
@Modern disks do bad sector replacement themselves.  There is no
need to reserve space for them in the filesystem itself.
OK deraadt@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.52 2006/03/09 13:35:02 pedro Exp $	*/
a32 17
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1983, 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)newfs.c	8.8 (Berkeley) 4/18/94";
#else
static char rcsid[] = "$OpenBSD: newfs.c,v 1.52 2006/03/09 13:35:02 pedro Exp $";
#endif
#endif /* not lint */

/*
 * newfs: friendly front end to mkfs
 */
a75 2
#define	COMPAT			/* allow non-labeled disks */

a94 8
 * ROTDELAY gives the minimum number of milliseconds to initiate
 * another disk transfer on the same cylinder. It is used in
 * determining the rotationally optimal layout for disk blocks
 * within a file; the default of fs_rotdelay is 0ms.
 */
#define ROTDELAY	0

/*
d129 1
a129 1
int	rotdelay = ROTDELAY;	/* rotational delay between blocks */
a138 1
#ifdef COMPAT
a140 2
#endif

d174 3
a176 3
	uid_t mfsuid;
	gid_t mfsgid;
	mode_t mfsmode;
a202 1
#ifdef COMPAT
a205 1
#endif
a404 1
#ifdef COMPAT
d410 1
a410 3
	} else
#endif
	{
a504 4
#ifdef notdef /* label may be 0 if faked up by kernel */
	bbsize = lp->d_bbsize;
	sbsize = lp->d_sbsize;
#endif
a627 1
#ifdef COMPAT
a628 3
#else
char lmsg[] = "%s: can't read disk label";
#endif
d636 1
a636 2
#ifdef COMPAT
		if (disktype) {
a644 1
#endif
a653 1
#ifdef COMPAT
d656 1
a656 1
#endif
a730 1
#ifdef COMPAT
a731 1
#endif
@


1.52
log
@Remove option -n from newfs as well as all references to fs_postbl()
Various testing for a while, okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.51 2005/10/28 19:10:57 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.51 2005/10/28 19:10:57 otto Exp $";
a140 1
int	nphyssectors;		/* # sectors/track including spares */
a141 2
int	trackspares = -1;	/* spare sectors per track */
int	cylspares = -1;		/* spare sectors per cylinder */
d220 1
a220 1
	    "NOS:T:a:b:c:d:e:f:g:h:i:k:l:m:o:p:qr:s:t:u:x:z:";
a301 5
		case 'p':
			if ((trackspares = atoi(optarg)) < 0)
				fatal("%s: bad spare sectors per track",
				    optarg);
			break;
a325 5
		case 'x':
			if ((cylspares = atoi(optarg)) < 0)
				fatal("%s: bad spare sectors per cylinder",
				    optarg);
			break;
d532 1
a532 12
	if (trackspares == -1) {
		trackspares = lp->d_sparespertrack;
		if (trackspares < 0)
			trackspares = 0;
	}
	nphyssectors = nsectors + trackspares;
	if (cylspares == -1) {
		cylspares = lp->d_sparespercyl;
		if (cylspares < 0)
			cylspares = 0;
	}
	secpercyl = nsectors * ntracks - cylspares;
a550 1
		nphyssectors /= secperblk;
a558 1
		nphyssectors *= blkpersec;
a793 1
	{ "-p spare sectors per track", 0 },
a797 1
	{ "-x spare sectors per cylinder", 0 },
@


1.51
log
@Make it possible to use -P on readonly memory filesystems. From
Alexander Hall, with some guidance by me. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.50 2004/08/12 07:53:50 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.50 2004/08/12 07:53:50 otto Exp $";
a134 12
/*
 * For each cylinder we keep track of the availability of blocks at different
 * rotational positions, so that we can lay out the data to be picked
 * up with minimum rotational latency.  NRPOS is the default number of
 * rotational positions that we distinguish.  With NRPOS of 8 the resolution
 * of our summary information is 2ms for a typical 3600 rpm drive.  Caching
 * and zoning pretty much defeats rotational optimization, so we now use a
 * default of 1.
 */
#define	NRPOS		1	/* number distinct rotational positions */


a160 1
int	nrpos = NRPOS;		/* # of distinguished rotational positions */
d223 1
a223 1
	    "NOS:T:a:b:c:d:e:f:g:h:i:k:l:m:n:o:p:qr:s:t:u:x:z:";
a290 5
			break;
		case 'n':
			if ((nrpos = atoi(optarg)) <= 0)
				fatal("%s: bad rotational layout count\n",
				    optarg);
@


1.50
log
@Prevent core dump on large block sizes by checking block size against
MAXBSIZE.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.49 2004/07/02 15:48:36 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.49 2004/07/02 15:48:36 otto Exp $";
d192 1
d195 1
a195 1
static void copy(char *, char *);
d197 1
d640 6
d676 1
a676 1
						copy(pop, argv[1]);
d702 2
a703 7
		args.export_info.ex_root = -2;
		if (mntflags & MNT_RDONLY)
			args.export_info.ex_flags = MNT_EXRDONLY;
		else
			args.export_info.ex_flags = 0;
		args.base = membase;
		args.size = fssize * sectorsize;
d927 1
a927 1
copy(char *src, char *dst)
d959 10
@


1.49
log
@Take TMPDIR into account when creating a temp mountpoint for populating.
ok avsm@@ millert@@; man page ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.48 2004/06/26 18:21:36 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.48 2004/06/26 18:21:36 otto Exp $";
d258 1
a258 1
			if ((bsize = atoi(optarg)) < MINBSIZE)
@


1.48
log
@For all the mfs lovers:

- Make the root of an mfs file system inherit the permission and
  owner/group of the mountpoint. Work by david@@.
- Add the ability to populate an mfs file system with the contents of a
  directory or a file system immediately after creation, controlled
  by the new -P mount option.

Discussed with and tested by many, ok djm@@ david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.47 2003/11/03 05:40:09 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.47 2003/11/03 05:40:09 tedu Exp $";
d962 2
d965 1
d967 6
a972 2
	if (statfs("/tmp", &fs) != 0)
		err(1, "statfs /tmp");
d974 2
a975 2
		if (statfs("/mnt", &fs) != 0)
			err(1, "statfs /mnt");
d977 3
a979 2
			errx(1, "temp mountpoint /mnt busy");
		strlcpy(mountpoint, "/mnt", len);
d982 8
a989 1
	strlcpy(mountpoint, "/tmp/mntXXXXXXXXXXX", len);
@


1.47
log
@NULL for NULL pointers, not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.46 2003/11/03 05:36:27 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.46 2003/11/03 05:36:27 tedu Exp $";
d51 1
d64 1
a75 1
#include <err.h>
d89 1
a89 1
void	mkfs(struct partition *, char *, int, int);
d192 5
d212 1
d215 1
d218 3
d233 1
a233 1
	    "T:a:b:c:d:e:f:i:m:o:s:" :
d281 1
a281 1
			       fatal("%s: bad average file size", optarg);
d355 5
d615 11
a625 1
	mkfs(pp, special, fsi, fso);
d666 3
a668 1
				    !strcmp(sf.f_fstypename, "mfs"))
d670 1
a670 1

d814 3
d860 1
a860 1
		if (!mfs || fsopt->mfs_too)
d865 116
@


1.46
log
@combine ugly printf(), exit() combo statements into err() or errx().
mostly from tom cosgrove.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.45 2003/10/07 20:14:54 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.45 2003/10/07 20:14:54 tedu Exp $";
d468 1
a468 1
		if (cp == 0 || ((*cp < 'a' || *cp > ('a' + maxpartitions - 1))
@


1.45
log
@better guess for ncyls.  allows chuck yerkes to make small file systems again.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.44 2003/07/16 18:02:36 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.44 2003/07/16 18:02:36 tedu Exp $";
d615 1
a615 2
			perror("mfs");
			exit(10);
@


1.44
log
@remove default limit of 16 cylinders per group.  it's now set to
as many as fit with the other parameters given.
change default frag size to 2048, bumping block size to 16k.
from freebsd.

ok deraadt@@ and co.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.43 2003/07/02 21:44:58 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.43 2003/07/02 21:44:58 deraadt Exp $";
d590 2
a591 2
	if (ncyls == 0)
		ncyls = 1;
@


1.44.2.1
log
@MFC:
Fix by tedu@@

better guess for ncyls.  allows chuck yerkes to make small file systems again.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.44 2003/07/16 18:02:36 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.44 2003/07/16 18:02:36 tedu Exp $";
d590 2
a591 2
	if (ncyls < 2)
		ncyls = 2;
@


1.43
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.42 2003/06/25 21:24:10 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.42 2003/06/25 21:24:10 deraadt Exp $";
d101 2
a102 2
#define	DFL_FRAGSIZE	1024
#define	DFL_BLKSIZE	8192
d107 2
a108 2
 * on a single cylinder. The default is to use 16 cylinders
 * per group.
d110 1
a110 1
#define	DESCPG		16	/* desired fs_cpg */
d163 1
a163 1
int	cpg = DESCPG;		/* cylinders/cylinder group */
d202 1
a202 1
	int fsi = -1, fso, len, n, maxpartitions;
d588 10
@


1.42
log
@proto repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.41 2003/06/11 06:22:14 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.41 2003/06/11 06:22:14 deraadt Exp $";
d189 1
a197 1
	struct disklabel *getdisklabel(char *, int);
@


1.41
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.40 2003/06/10 16:41:29 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.40 2003/06/10 16:41:29 deraadt Exp $";
d197 1
a197 1
	struct disklabel *getdisklabel();
d685 1
a685 1
			struct disklabel *lp, *getdiskbyname();
@


1.40
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.39 2003/06/02 20:06:16 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.39 2003/06/02 20:06:16 millert Exp $";
d191 1
a191 3
main(argc, argv)
	int argc;
	char *argv[];
d306 2
a307 1
	fatal("%s: unknown optimization preference: use `space' or `time'.");
d678 1
a678 3
getdisklabel(s, fd)
	char *s;
	int fd;
d701 1
a701 4
rewritelabel(s, fd, lp)
	char *s;
	int fd;
	struct disklabel *lp;
d806 1
a806 1
usage()
@


1.39
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.38 2003/05/03 17:21:04 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.38 2003/05/03 17:21:04 millert Exp $";
d603 7
a609 7
 
 		switch (pid = fork()) {
 		case -1:
 			perror("mfs");
 			exit(10);
 		case 0:
 			snprintf(mountfromname, sizeof(mountfromname),
d611 3
a613 3
 			break;
 		default:
 			snprintf(mountfromname, sizeof(mountfromname),
d615 43
a657 43
 			for (;;) {
 				/*
 				 * spin until the mount succeeds
 				 * or the child exits
 				 */
 				usleep(1);
 
 				/*
 				 * XXX Here is a race condition: another process
 				 * can mount a filesystem which hides our
 				 * ramdisk before we see the success.
 				 */
 				if (statfs(argv[1], &sf) < 0)
 					err(88, "statfs %s", argv[1]);
 				if (!strcmp(sf.f_mntfromname, mountfromname) &&
 				    !strncmp(sf.f_mntonname, argv[1],
 					     MNAMELEN) &&
 				    !strcmp(sf.f_fstypename, "mfs"))
 					exit(0);
 
 				res = waitpid(pid, &status, WNOHANG);
 				if (res == -1)
 					err(11, "waitpid");
 				if (res != pid)
 					continue;
 				if (WIFEXITED(status)) {
 					if (WEXITSTATUS(status) == 0)
 						exit(0);
 					errx(1, "%s: mount: %s", argv[1],
 					     strerror(WEXITSTATUS(status)));
 				} else
 					errx(11, "abnormal termination");
 			}
 			/* NOTREACHED */
 		}
 
 		(void) setsid();
 		(void) close(0);
 		(void) close(1);
 		(void) close(2);
 		(void) chdir("/");
 
 		args.fspec = mountfromname;
@


1.38
log
@The 'memleft' calcuations assume that the data address starts at
0, which is no longer the case.  So instead of the hokey private
malloc() implementation, just use mmap.  From diffs I ran on
anoncvs.usa 4 years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.37 2003/04/16 10:33:16 markus Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.37 2003/04/16 10:33:16 markus Exp $";
@


1.37
log
@fix race between mount(2) and exit(2) for mount_mfs.
from netbsd (drochner, newfs.c 1.30, mkfs.c 1.29, no copyright changes)
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.36 2003/03/13 09:09:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.36 2003/03/13 09:09:26 deraadt Exp $";
d59 1
d207 1
d361 6
@


1.36
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.35 2002/05/26 09:24:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.35 2002/05/26 09:24:35 deraadt Exp $";
d60 1
d75 1
d207 7
a213 1
	char *cp, *s1, *s2, *special, *opstring, buf[BUFSIZ];
d599 55
a653 3

		snprintf(buf, sizeof buf, "mfs:%ld", (long)getpid());
		args.fspec = buf;
d662 1
a662 1
			fatal("%s: %s", argv[1], strerror(errno));
@


1.35
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.34 2002/05/06 19:25:06 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.34 2002/05/06 19:25:06 millert Exp $";
d592 1
a592 1
		sprintf(buf, "mfs:%ld", (long)getpid());
@


1.34
log
@Use the default calculation of maxcontig, based on fs_bsize and MAXPHYS, so
that the cluster summary information is correct for bsize=4k and MAXPHYS=64k.
From NetBSD (mycroft)
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.33 2002/04/23 18:54:12 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.33 2002/04/23 18:54:12 espie Exp $";
d592 1
a592 1
		sprintf(buf, "mfs:%d", getpid());
@


1.33
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.32 2002/02/19 19:39:38 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.32 2002/02/19 19:39:38 millert Exp $";
d170 1
a170 1
int	maxcontig = 8;		/* max contiguous blocks to allocate */
@


1.32
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.31 2002/02/18 21:57:56 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.31 2002/02/18 21:57:56 millert Exp $";
d594 1
a594 1
		args.export.ex_root = -2;
d596 1
a596 1
			args.export.ex_flags = MNT_EXRDONLY;
d598 1
a598 1
			args.export.ex_flags = 0;
@


1.31
log
@Don't accept -N flag for mount_mfs.  This flag is turned on automatically
when invoked as mount_mfs but it has different semantics from what is
described in the man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.30 2002/02/16 21:27:36 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.30 2002/02/16 21:27:36 millert Exp $";
d68 1
a76 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a695 1
#ifdef __STDC__
a696 5
#else
fatal(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a699 1
#ifdef __STDC__
a700 3
#else
	va_start(ap);
#endif
@


1.30
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.29 2001/11/05 07:39:17 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.29 2001/11/05 07:39:17 mpech Exp $";
d223 1
a223 1
	    "NT:a:b:c:d:e:f:i:m:o:s:" :
d732 1
a732 1
	{ "-N do not create file system, just print out parameters", 1 },
@


1.29
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.28 2001/07/07 18:26:16 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.28 2001/07/07 18:26:16 deraadt Exp $";
d92 5
a96 5
void	fatal __P((const char *fmt, ...));
void	usage __P((void));
void	mkfs __P((struct partition *, char *, int, int));
void	rewritelabel __P((char *, int, struct disklabel *));
u_short	dkcksum __P((struct disklabel *));
@


1.28
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.27 2001/04/19 16:22:18 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.27 2001/04/19 16:22:18 gluk Exp $";
d201 3
a203 3
	register int ch;
	register struct partition *pp;
	register struct disklabel *lp;
d648 1
a648 1
	register struct disklabel *lp;
d662 1
a662 1
		register i;
@


1.27
log
@Cleanup dirpref and synhronize superblock with freebsd.
From FreeBSD with little changes.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.26 2001/04/14 03:15:54 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.26 2001/04/14 03:15:54 gluk Exp $";
d74 1
d92 5
a96 5
#ifdef __STDC__
void	fatal(const char *fmt, ...);
#else
void	fatal();
#endif
d209 1
a209 1
	int fsi, fso, len, n, maxpartitions;
d404 1
a404 1
	if (cp == 0) {
d462 2
a463 2
		if (cp == 0 || (*cp < 'a' || *cp > ('a' + maxpartitions - 1))
		    && !isdigit(*cp))
d553 3
a555 2
			"Warning: calculated sectors per cylinder", secpercyl,
			"disagrees with disk label", lp->d_secpercyl);
d644 1
d762 1
@


1.26
log
@Forgot remove 'U' from optstring; millert@@ ok.	 ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.25 2001/04/05 00:50:07 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.25 2001/04/05 00:50:07 gluk Exp $";
d178 2
d223 1
a223 1
	    "NOS:T:a:b:c:d:e:f:i:k:l:m:n:o:p:qr:s:t:u:x:z:";
d268 8
d741 2
@


1.25
log
@Fix:
- two overflow of static buffer by device name.
- one overflow of dynamic buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.24 2001/04/04 22:06:39 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.24 2001/04/04 22:06:39 gluk Exp $";
d221 1
a221 1
	    "NOS:UT:a:b:c:d:e:f:i:k:l:m:n:o:p:qr:s:t:u:x:z:";
@


1.24
log
@bye bye -U (soft updates).
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.23 2001/04/03 22:59:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.23 2001/04/03 22:59:35 millert Exp $";
d397 2
a398 1
		(void)sprintf(device, "%sr%s", _PATH_DEV, special);
d400 2
a401 1
			(void)sprintf(device, "%s%s", _PATH_DEV, special);
d659 2
a660 1
		strcpy(specname, s);
@


1.23
log
@mount_mfs should not take the -U flag sync mfs is async and you cannot
have both aync and soft updates (not that it makes sense to have soft
updates on mfs anyway).  Also sync the usage in mount_mfs mode to
the man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.22 2000/04/30 05:07:46 bjc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.22 2000/04/30 05:07:46 bjc Exp $";
a153 1
int	Uflag;			/* enable soft updates for file system */
a238 3
		case 'U':
			Uflag = 1;
			break;
a721 1
	{ "-U enable soft updates", 0 },
@


1.22
log
@#ifdef vax -> #ifdef __vax__
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.21 2000/03/21 21:58:04 jason Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.21 2000/03/21 21:58:04 jason Exp $";
d221 1
a221 1
	    "NT:Ua:b:c:d:e:f:i:m:o:s:" :
d716 33
d751 2
d762 4
a765 27
	fprintf(stderr,
	    "\t-N do not create file system, just print out parameters\n");
	fprintf(stderr, "\t-O create a 4.3BSD format filesystem\n");
	fprintf(stderr, "\t-S sector size\n");
#ifdef COMPAT
	fprintf(stderr, "\t-T disktype\n");
#endif
	fprintf(stderr, "\t-U enable soft updates\n");
	fprintf(stderr, "\t-a maximum contiguous blocks\n");
	fprintf(stderr, "\t-b block size\n");
	fprintf(stderr, "\t-c cylinders/group\n");
	fprintf(stderr, "\t-d rotational delay between contiguous blocks\n");
	fprintf(stderr, "\t-e maximum blocks per file in a cylinder group\n");
	fprintf(stderr, "\t-f frag size\n");
	fprintf(stderr, "\t-i number of bytes per inode\n");
	fprintf(stderr, "\t-k sector 0 skew, per track\n");
	fprintf(stderr, "\t-l hardware sector interleave\n");
	fprintf(stderr, "\t-m minimum free space %%\n");
	fprintf(stderr, "\t-n number of distinguished rotational positions\n");
	fprintf(stderr, "\t-o optimization preference (`space' or `time')\n");
	fprintf(stderr, "\t-p spare sectors per track\n");
	fprintf(stderr, "\t-r revolutions/minute\n");
	fprintf(stderr, "\t-s file system size (sectors)\n");
	fprintf(stderr, "\t-t file system type\n");
	fprintf(stderr, "\t-u sectors/track\n");
	fprintf(stderr, "\t-x spare sectors per cylinder\n");
	fprintf(stderr, "\t-z tracks/cylinder\n");
@


1.21
log
@add missing break; found by Matt Patton <mep@@netsec.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.20 1999/12/03 19:24:18 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.20 1999/12/03 19:24:18 art Exp $";
d649 1
a649 1
#if vax
d684 1
a684 1
#endif
@


1.20
log
@Allow enabling soft updates (with -U) on a new filesystem.
Allow soft updates on mfs filesystems (even if it's stupid).
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.19 1999/08/17 09:13:14 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.19 1999/08/17 09:13:14 millert Exp $";
a319 1
				
d322 1
@


1.19
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.18 1999/04/10 04:09:23 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.18 1999/04/10 04:09:23 millert Exp $";
d154 1
d221 2
a222 2
	    "NT:a:b:c:d:e:f:i:m:o:s:" :
	    "NOS:T:a:b:c:d:e:f:i:k:l:m:n:o:p:qr:s:t:u:x:z:";
d240 3
d734 1
@


1.18
log
@Add -q flag to newfs and use it in the install
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.17 1997/09/26 01:49:18 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.17 1997/09/26 01:49:18 millert Exp $";
a57 1
#include <sys/file.h>
d66 1
@


1.17
log
@No longer allow the "newfs -flags /dev/rdev disk-type" form.  It's
no longer documented and disk type is settable via the -T flag.
Also fix a problem kept newfs from building w/o COMPAT being defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.16 1997/07/25 19:13:07 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.16 1997/07/25 19:13:07 mickey Exp $";
d181 1
d213 1
a213 1
		mfs = Nflag = 1;
d221 1
a221 1
	    "NOS:T:a:b:c:d:e:f:i:k:l:m:n:o:p:r:s:t:u:x:z:";
d303 3
@


1.16
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.15 1997/06/16 00:03:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.15 1997/06/16 00:03:12 deraadt Exp $";
d339 1
a339 1
	if (ffs && argc != 2 && (mfs || argc != 1))
d427 1
d433 3
a435 1
	} else {
a448 4
#ifdef COMPAT
		if (!mfs && disktype == NULL)
			disktype = argv[1];
#endif
d714 1
a714 1
	} else
d716 2
a717 7
		    "usage: %s [ -fsoptions ] special-device%s\n",
		    __progname,
#ifdef COMPAT
		    " [device-type]");
#else
		    "");
#endif
@


1.15
log
@if -o is used to explicitly specify time or space optimization preference,
do not override based on minfree calculation; problem from jgarzik@@pobox.com,
my fix; PR#226
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.14 1997/02/23 03:51:25 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.14 1997/02/23 03:51:25 millert Exp $";
d75 1
a75 1
#if __STDC__
d91 1
a91 1
#if __STDC__
d682 1
a682 1
#if __STDC__
d692 1
a692 1
#if __STDC__
@


1.14
log
@Inline fsirand(8) (at no noticable cost in speed).
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.13 1997/02/22 05:53:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.13 1997/02/22 05:53:35 millert Exp $";
d172 1
d291 1
a291 1
					opt = FS_OPTSPACE;
d293 1
a293 1
					opt = FS_OPTTIME;
d518 1
a518 1
	if (minfree < MINFREE && opt != FS_OPTSPACE) {
@


1.13
log
@progname -> __progname and exec fsirand after mkfs().
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.12 1997/02/11 07:01:38 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.12 1997/02/11 07:01:38 millert Exp $";
d592 1
a592 6
	if (!Nflag) {
		(void)execl(_PATH_FSIRAND, "fsirand", special, NULL);
		err(1, "Can't exec %s", _PATH_FSIRAND);
	} else {
		exit(0);
	}
@


1.12
log
@Remove occurences of headswitch and trackseek, they no longer
exist in struct fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.11 1997/01/16 05:48:02 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.11 1997/01/16 05:48:02 millert Exp $";
d188 2
a189 1
char	*progname;
a195 2
	extern char *optarg;
	extern int optind;
d210 2
a211 9
	if (progname = strrchr(*argv, '/'))
		++progname;
	else
		progname = *argv;

	if (strstr(progname, "mfs")) {
		mfs = 1;
		Nflag++;
	}
d439 1
a439 1
			    progname, special);
d592 6
a597 1
	exit(0);
d702 1
a702 1
		openlog(progname, LOG_CONS, LOG_DAEMON);
d718 1
a718 1
			progname);
d722 1
a722 1
		    progname,
@


1.11
log
@Correct logic such that newfs w/o -t on a device w/o a label
defaults to ffs like people expect.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.10 1997/01/15 23:41:31 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.10 1997/01/15 23:41:31 millert Exp $";
a165 2
int	headswitch;		/* head switch time, usec */
int	trackseek;		/* track-to-track seek, usec */
a547 2
	headswitch = lp->d_headswitch;
	trackseek = lp->d_trkseek;
@


1.10
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.9 1996/12/23 07:48:28 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.9 1996/12/23 07:48:28 downsj Exp $";
d357 1
a357 1
		if (fstype == NULL || strcmp(fstype, "ffs")) {
@


1.9
log
@readlabelfs()
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.8 1996/12/04 10:26:36 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.8 1996/12/04 10:26:36 deraadt Exp $";
d230 1
a230 1
	while ((ch = getopt(argc, argv, opstring)) != EOF) {
@


1.8
log
@rearrange argv[0] code
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.7 1996/12/04 08:52:18 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.7 1996/12/04 08:52:18 deraadt Exp $";
d356 1
a356 1
			fstype = readlabelfs(special);
@


1.7
log
@fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.6 1996/12/04 08:38:59 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.6 1996/12/04 08:38:59 deraadt Exp $";
d353 1
a353 1
		char name[MAXPATHLEN];
d358 1
a358 2
			snprintf(name, sizeof name, "%s/newfs_%s", _PATH_SBIN,
			    fstype);
d360 6
a365 4
			(void)execv(name, saveargv);
			snprintf(name, sizeof name, "%s/newfs_%s", _PATH_USRSBIN,
			    fstype);
			(void)execv(name, saveargv);
@


1.6
log
@first cut at "newfs -t fstype device". this is very neat
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.5 1996/11/24 23:46:44 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.5 1996/11/24 23:46:44 millert Exp $";
d755 1
d757 1
a757 1
	fprintf(stderr, "\t-r revolutions/minute\n");
@


1.5
log
@Add MOPT_UPDATE to mount options since there is filesystem
support for it.  From NetBSD (cgd).
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.4 1996/10/27 20:55:05 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.4 1996/10/27 20:55:05 downsj Exp $";
d82 1
d209 3
d229 2
a230 2
	    "NOS:T:a:b:c:d:e:f:i:k:l:m:n:o:p:r:s:t:u:x:";
	while ((ch = getopt(argc, argv, opstring)) != EOF)
d320 2
a321 1
		case 't':
d324 4
d342 3
d348 1
a348 1
	if (argc != 2 && (mfs || argc != 1))
d352 17
a756 1
	fprintf(stderr, "\t-t tracks/cylinder\n");
d759 1
@


1.4
log
@newfs for disks other than 512bytes/sector, NetBSD pr#2404,
<yasufu-i@@is.aist-nara.ac.jp>.
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.3 1996/06/23 14:31:47 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.3 1996/06/23 14:31:47 deraadt Exp $";
d86 1
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: newfs.c,v 1.20 1996/05/16 07:13:03 thorpej Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: newfs.c,v 1.20 1996/05/16 07:13:03 thorpej Exp $";
a159 1
#ifdef tahoe
a160 1
#endif
a525 1
#ifdef tahoe
d527 1
a527 1
	if (sectorsize != DEV_BSIZE) {		/* XXX */
d536 9
a545 1
#endif
d547 1
a547 2
#ifdef tahoe
	if (realsectorsize != DEV_BSIZE)
d549 2
a550 1
#endif
@


1.2
log
@libutil
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: newfs.c,v 1.20 1996/05/16 07:13:03 thorpej Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: newfs.c,v 1.19 1995/06/28 02:21:02 thorpej Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: newfs.c,v 1.19 1995/06/28 02:21:02 thorpej Exp $";
d72 1
a93 2
int	getmaxpartitions __P((void));

a680 15
}

int
getmaxpartitions()
{
	int maxpart, mib[2];
	size_t varlen;

	mib[0] = CTL_KERN;
	mib[1] = KERN_MAXPARTITIONS;
	varlen = sizeof(maxpart);
	if (sysctl(mib, 2, &maxpart, &varlen, NULL, 0) < 0)
		fatal("getmaxpartitions: %s", strerror(errno));

	return (maxpart);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
