head	1.97;
access;
symbols
	OPENBSD_6_0:1.96.0.4
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.91.0.4
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.90.0.2
	OPENBSD_5_7_BASE:1.90
	OPENBSD_5_6:1.86.0.4
	OPENBSD_5_6_BASE:1.86
	OPENBSD_5_5:1.85.0.4
	OPENBSD_5_5_BASE:1.85
	OPENBSD_5_4:1.78.0.2
	OPENBSD_5_4_BASE:1.78
	OPENBSD_5_3:1.76.0.8
	OPENBSD_5_3_BASE:1.76
	OPENBSD_5_2:1.76.0.6
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.76
	OPENBSD_5_1:1.76.0.4
	OPENBSD_5_0:1.76.0.2
	OPENBSD_5_0_BASE:1.76
	OPENBSD_4_9:1.74.0.4
	OPENBSD_4_9_BASE:1.74
	OPENBSD_4_8:1.74.0.2
	OPENBSD_4_8_BASE:1.74
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.72.0.6
	OPENBSD_4_6_BASE:1.72
	OPENBSD_4_5:1.72.0.2
	OPENBSD_4_5_BASE:1.72
	OPENBSD_4_4:1.71.0.4
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.71.0.2
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.70.0.2
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.50.0.4
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.50.0.2
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.46.0.2
	OPENBSD_3_7_BASE:1.46
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.97
date	2016.09.01.09.27.06;	author otto;	state Exp;
branches;
next	1.96;
commitid	gUl3fl7GDkw9Z7I6;

1.96
date	2016.03.17.05.27.10;	author bentley;	state Exp;
branches;
next	1.95;
commitid	0afdJPZPXUfvItJV;

1.95
date	2016.01.28.17.26.10;	author gsoares;	state Exp;
branches;
next	1.94;
commitid	asCM1XeyZ4r9sHqx;

1.94
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	Cz19p5I1S6mVZIjV;

1.93
date	2015.10.11.00.20.29;	author guenther;	state Exp;
branches;
next	1.92;
commitid	p83AfJYsoHS8dtNj;

1.92
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.91;
commitid	0qPuuXwccpVXsXcV;

1.91
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.90;
commitid	6b2lLILbgCR1fvia;

1.90
date	2015.02.06.22.29.00;	author millert;	state Exp;
branches;
next	1.89;
commitid	WgDx6wkwMVme8aeW;

1.89
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.88;
commitid	F55lwc3gS4GN2mLs;

1.88
date	2015.01.18.04.48.24;	author deraadt;	state Exp;
branches;
next	1.87;
commitid	eRoBhNqhtj9qy8AW;

1.87
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	Uu5nFG3wCl0LACBb;

1.86
date	2014.06.30.19.19.17;	author otto;	state Exp;
branches;
next	1.85;
commitid	EfGHGphs1upkixaR;

1.85
date	2014.01.24.22.29.21;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2013.11.12.04.59.02;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2013.11.03.02.22.07;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2013.10.07.21.00.45;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.07.11.51.11;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2013.10.06.21.50.23;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2013.06.11.16.42.05;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2013.04.23.21.27.38;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2011.06.05.15.20.37;	author chl;	state Exp;
branches;
next	1.75;

1.75
date	2011.05.23.10.56.17;	author dcoppa;	state Exp;
branches;
next	1.74;

1.74
date	2010.03.21.09.13.30;	author otto;	state Exp;
branches;
next	1.73;

1.73
date	2009.12.23.02.24.39;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2008.08.08.23.49.53;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2008.01.05.19.51.55;	author otto;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.07.08.16.52;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.26.19.03.21;	author otto;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.10.19.11.43;	author otto;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.01.23.42.35;	author pedro;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.01.23.08.23;	author otto;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.01.06.41.35;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.29.06.28.16;	author otto;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.19.20.12.50;	author otto;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.19.01.28.15;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.18.19.08.16;	author otto;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.18.18.57.06;	author otto;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.03.20.11.55;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.23.10.18.30;	author pedro;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.18.14.13.31;	author otto;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.17.14.24.14;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.13.17.33.02;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.03.18.42.32;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.03.17.08.30;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.02.20.20.39;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.09.13.35.02;	author pedro;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.19.15.18.01;	author pedro;	state Exp;
branches;
next	1.48;

1.48
date	2005.08.08.20.27.22;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.14.19.58.32;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.06.08.57.30;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2004.10.14.07.40.29;	author otto;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.10.19.49.15;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.12.07.53.50;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2004.07.06.07.31.59;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.26.18.21.35;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.22.01.58.59;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.13.22.36.39;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.13.01.42.08;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.05.00.40.29;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.06.08.53.58;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.03.05.40.09;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.03.05.36.27;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.25.23.28.15;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.16.18.02.35;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.02.21.44.58;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.25.21.24.10;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.11.06.22.14;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.06.04.32.16;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.06.00.10.40;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.03.17.21.04;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.16.10.33.16;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.19.00.57.14;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.29.09.19.52;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.07.18.26.16;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.19.16.22.17;	author gluk;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.13.02.39.06;	author gluk;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.04.22.06.38;	author gluk;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.16.03.05.44;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.22.19.21.30;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.12.03.19.24.17;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.04.10.04.09.23;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.11.17.09.14.05;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.06.03.22.27.17;	author grr;	state Exp;
branches;
next	1.9;

1.9
date	97.06.03.11.00.09;	author grr;	state Exp;
branches;
next	1.8;

1.8
date	97.05.29.20.22.43;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.03.27.17.15.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.23.03.51.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.02.21.22.55.19;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.11.07.01.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.11.00.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.31.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.97
log
@Start writing the size of the cylinder group into the (unused) cpg
field of the disklabel. To be used by fsck_ffs(8) to find alternate
superblocks. ok deraadt@@ krw@@
@
text
@/*	$OpenBSD: mkfs.c,v 1.96 2016/03/17 05:27:10 bentley Exp $	*/
/*	$NetBSD: mkfs.c,v 1.25 1995/06/18 21:35:38 cgd Exp $	*/

/*
 * Copyright (c) 2002 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by Marshall
 * Kirk McKusick and Network Associates Laboratories, the Security
 * Research Division of Network Associates, Inc. under DARPA/SPAWAR
 * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS
 * research program.
 *
 * Copyright (c) 1980, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE roundup btodb setbit */
#include <sys/signal.h>
#include <sys/time.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/sysctl.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>

#include <err.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <limits.h>

#ifndef STANDALONE
#include <stdio.h>
#include <errno.h>
#endif

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

/*
 * Default directory umask.
 */
#define UMASK		0755

#define POWEROF2(num)	(((num) & ((num) - 1)) == 0)

/*
 * 'Standard' bad FFS magic.
 */
#define FS_BAD_MAGIC	0x19960408

/*
 * The minimum number of cylinder groups that should be created.
 */
#define MINCYLGRPS	4

/*
 * variables set up by front end.
 */
extern int	mfs;		/* run as the memory based filesystem */
extern int	Nflag;		/* run mkfs without writing file system */
extern int	Oflag;		/* format as an 4.3BSD file system */
extern daddr_t fssize;		/* file system size in 512-byte blocks. */
extern long long	sectorsize;	/* bytes/sector */
extern int	fsize;		/* fragment size */
extern int	bsize;		/* block size */
extern int	maxfrgspercg;	/* maximum fragments per cylinder group */
extern int	minfree;	/* free space threshold */
extern int	opt;		/* optimization preference (space or time) */
extern int	density;	/* number of bytes per inode */
extern int	maxbpg;		/* maximum blocks per file in a cyl group */
extern int	avgfilesize;	/* expected average file size */
extern int	avgfilesperdir;	/* expected number of files per directory */
extern int	quiet;		/* quiet flag */
extern caddr_t	membase;	/* start address of memory based filesystem */

union fs_u {
	struct fs fs;
	char pad[SBSIZE];
} *fsun;
#define sblock	fsun->fs

struct	csum *fscs;

union cg_u {
	struct cg cg;
	char pad[MAXBSIZE];
} *cgun;
#define acg	cgun->cg

union dinode {
	struct ufs1_dinode dp1;
	struct ufs2_dinode dp2;
};

int	fsi, fso;

static caddr_t iobuf;
static long iobufsize;

daddr_t	alloc(int, int);
static int	charsperline(void);
static int	ilog2(int);
void		initcg(int, time_t);
void		wtfs(daddr_t, int, void *);
int		fsinit1(time_t, mode_t, uid_t, gid_t);
int		fsinit2(time_t);
int		makedir(struct direct *, int);
void		iput(union dinode *, ino_t);
void		setblock(struct fs *, unsigned char *, int);
void		clrblock(struct fs *, unsigned char *, int);
int		isblock(struct fs *, unsigned char *, int);
void		rdfs(daddr_t, int, void *);
void		mkfs(struct partition *, char *, int, int,
		    mode_t, uid_t, gid_t);
static		void checksz(void);

#ifndef STANDALONE
volatile sig_atomic_t cur_cylno;
volatile const char *cur_fsys;
void	siginfo(int sig);

void
siginfo(int sig)
{
	int save_errno = errno;

	dprintf(STDERR_FILENO, "%s: initializing cg %ld/%d\n",
	    cur_fsys, (long)cur_cylno, sblock.fs_ncg);
	errno = save_errno;
}
#endif

void
mkfs(struct partition *pp, char *fsys, int fi, int fo, mode_t mfsmode,
    uid_t mfsuid, gid_t mfsgid)
{
	time_t utime;
	quad_t sizepb;
	int i, j, width, origdensity, fragsperinode, minfpg, optimalfpg;
	int lastminfpg, mincylgrps;
	uint32_t bpg;
	long cylno, csfrags;
	char tmpbuf[100];	/* XXX this will break in about 2,500 years */

	if ((fsun = calloc(1, sizeof (union fs_u))) == NULL ||
	    (cgun = calloc(1, sizeof (union cg_u))) == NULL)
		err(1, "calloc");

#ifndef STANDALONE
	time(&utime);
#endif
	if (mfs) {
		size_t sz;
		if (fssize > SIZE_MAX / DEV_BSIZE) {
			errno = ENOMEM;
			err(12, "mmap");
		}
		sz = (size_t)fssize * DEV_BSIZE;
		membase = mmap(NULL, sz, PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, (off_t)0);
		if (membase == MAP_FAILED)
			err(12, "mmap");
		madvise(membase, sz, MADV_RANDOM);
	}
	fsi = fi;
	fso = fo;
	/*
	 * Validate the given file system size.
	 * Verify that its last block can actually be accessed.
	 */
	if (Oflag <= 1 && fssize > INT_MAX)
		errx(13, "preposterous size %lld, max is %d", (long long)fssize,
		    INT_MAX);
	if (Oflag == 2 && fssize > MAXDISKSIZE)
		errx(13, "preposterous size %lld, max is %lld",
		    (long long)fssize, MAXDISKSIZE);

	wtfs(fssize - (sectorsize / DEV_BSIZE), sectorsize, (char *)&sblock);

	sblock.fs_postblformat = FS_DYNAMICPOSTBLFMT;
	sblock.fs_avgfilesize = avgfilesize;
	sblock.fs_avgfpdir = avgfilesperdir;

	/*
	 * Collect and verify the block and fragment sizes.
	 */
	if (!POWEROF2(bsize)) {
		errx(16, "block size must be a power of 2, not %d", bsize);
	}
	if (!POWEROF2(fsize)) {
		errx(17, "fragment size must be a power of 2, not %d",
		     fsize);
	}
	if (fsize < sectorsize) {
		errx(18, "fragment size %d is too small, minimum is %lld",
		     fsize, sectorsize);
	}
	if (bsize < MINBSIZE) {
		errx(19, "block size %d is too small, minimum is %d",
		     bsize, MINBSIZE);
	}
	if (bsize > MAXBSIZE) {
		errx(19, "block size %d is too large, maximum is %d",
		     bsize, MAXBSIZE);
	}
	if (bsize < fsize) {
		errx(20, "block size (%d) cannot be smaller than fragment size (%d)",
		     bsize, fsize);
	}
	sblock.fs_bsize = bsize;
	sblock.fs_fsize = fsize;

	/*
	 * Calculate the superblock bitmasks and shifts.
	 */
	sblock.fs_bmask = ~(sblock.fs_bsize - 1);
	sblock.fs_fmask = ~(sblock.fs_fsize - 1);
	sblock.fs_qbmask = ~sblock.fs_bmask;
	sblock.fs_qfmask = ~sblock.fs_fmask;
	sblock.fs_bshift = ilog2(sblock.fs_bsize);
	sblock.fs_fshift = ilog2(sblock.fs_fsize);
	sblock.fs_frag = numfrags(&sblock, sblock.fs_bsize);
	if (sblock.fs_frag > MAXFRAG) {
		errx(21, "fragment size %d is too small, minimum with block "
		    "size %d is %d", sblock.fs_fsize, sblock.fs_bsize,
		    sblock.fs_bsize / MAXFRAG);
	}
	sblock.fs_fragshift = ilog2(sblock.fs_frag);
	sblock.fs_fsbtodb = ilog2(sblock.fs_fsize / DEV_BSIZE);
	sblock.fs_size = dbtofsb(&sblock, fssize);
	sblock.fs_nspf = sblock.fs_fsize / DEV_BSIZE;
	sblock.fs_maxcontig = 1;
	sblock.fs_nrpos = 1;
	sblock.fs_cpg = 1;

	/*
	 * Before the file system is fully initialized, mark it as invalid.
	 */
	sblock.fs_magic = FS_BAD_MAGIC;

	/*
	 * Set the remaining superblock fields.  Note that for FFS1, media
	 * geometry fields are set to fake values.  This is for compatibility
	 * with really ancient kernels that might still inspect these values.
	 */
	if (Oflag <= 1) {
		sblock.fs_sblockloc = SBLOCK_UFS1;
		sblock.fs_nindir = sblock.fs_bsize / sizeof(int32_t);
		sblock.fs_inopb = sblock.fs_bsize / sizeof(struct ufs1_dinode);
		if (Oflag == 0) {
			sblock.fs_maxsymlinklen = 0;
			sblock.fs_inodefmt = FS_42INODEFMT;
		} else {
			sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS1;
			sblock.fs_inodefmt = FS_44INODEFMT;
		}
		sblock.fs_cgoffset = 0;
		sblock.fs_cgmask = 0xffffffff;
		sblock.fs_ffs1_size = sblock.fs_size;
		sblock.fs_rotdelay = 0;
		sblock.fs_rps = 60;
		sblock.fs_interleave = 1;
		sblock.fs_trackskew = 0;
		sblock.fs_cpc = 0;
	} else {
		sblock.fs_inodefmt = FS_44INODEFMT;
		sblock.fs_sblockloc = SBLOCK_UFS2;
		sblock.fs_nindir = sblock.fs_bsize / sizeof(int64_t);
		sblock.fs_inopb = sblock.fs_bsize / sizeof(struct ufs2_dinode);
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS2;
	}
	sblock.fs_sblkno =
	    roundup(howmany(sblock.fs_sblockloc + SBLOCKSIZE, sblock.fs_fsize),
		sblock.fs_frag);
	sblock.fs_cblkno = (int32_t)(sblock.fs_sblkno +
	    roundup(howmany(SBSIZE, sblock.fs_fsize), sblock.fs_frag));
	sblock.fs_iblkno = sblock.fs_cblkno + sblock.fs_frag;
	sblock.fs_maxfilesize = sblock.fs_bsize * NDADDR - 1;
	for (sizepb = sblock.fs_bsize, i = 0; i < NIADDR; i++) {
		sizepb *= NINDIR(&sblock);
		sblock.fs_maxfilesize += sizepb;
	}
#ifdef notyet
	/*
	 * It is impossible to create a snapshot in case fs_maxfilesize is
	 * smaller than fssize.
	 */
	if (sblock.fs_maxfilesize < (u_quad_t)fssize)
		warnx("WARNING: You will be unable to create snapshots on this "
		    "file system. Correct by using a larger blocksize.");
#endif
	/*
	 * Calculate the number of blocks to put into each cylinder group. The
	 * first goal is to have at least enough data blocks in each cylinder
	 * group to meet the density requirement. Once this goal is achieved
	 * we try to expand to have at least mincylgrps cylinder groups. Once
	 * this goal is achieved, we pack as many blocks into each cylinder
	 * group map as will fit.
	 *
	 * We start by calculating the smallest number of blocks that we can
	 * put into each cylinder group. If this is too big, we reduce the
	 * density until it fits.
	 */
	origdensity = density;
	for (;;) {
		fragsperinode = MAXIMUM(numfrags(&sblock, density), 1);

		minfpg = fragsperinode * INOPB(&sblock);
		if (minfpg > sblock.fs_size)
			minfpg = sblock.fs_size;

		sblock.fs_ipg = INOPB(&sblock);
		sblock.fs_fpg = roundup(sblock.fs_iblkno +
		    sblock.fs_ipg / INOPF(&sblock), sblock.fs_frag);
		if (sblock.fs_fpg < minfpg)
			sblock.fs_fpg = minfpg;

		sblock.fs_ipg = roundup(howmany(sblock.fs_fpg, fragsperinode),
		    INOPB(&sblock));
		sblock.fs_fpg = roundup(sblock.fs_iblkno +
		    sblock.fs_ipg / INOPF(&sblock), sblock.fs_frag);
		if (sblock.fs_fpg < minfpg)
			sblock.fs_fpg = minfpg;

		sblock.fs_ipg = roundup(howmany(sblock.fs_fpg, fragsperinode),
		    INOPB(&sblock));

		if (CGSIZE(&sblock) < (unsigned long)sblock.fs_bsize)
			break;

		density -= sblock.fs_fsize;
	}
	if (density != origdensity)
		warnx("density reduced from %d to %d bytes per inode",
		    origdensity, density);

	/*
	 * Use a lower value for mincylgrps if the user specified a large
	 * number of blocks per cylinder group.  This is needed for, e.g. the
	 * install media which needs to pack 2 files very tightly.
	 */
	mincylgrps = MINCYLGRPS;
	if (maxfrgspercg != INT_MAX) {
		i = sblock.fs_size / maxfrgspercg;
		if (i < MINCYLGRPS)
			mincylgrps = i <= 0 ? 1 : i;
	}

	/*
	 * Start packing more blocks into the cylinder group until it cannot
	 * grow any larger, the number of cylinder groups drops below
	 * mincylgrps, or we reach the requested size.
	 */
	for (;;) {
		sblock.fs_fpg += sblock.fs_frag;
		sblock.fs_ipg = roundup(howmany(sblock.fs_fpg, fragsperinode),
		    INOPB(&sblock));

		if (sblock.fs_fpg > maxfrgspercg ||
		    sblock.fs_size / sblock.fs_fpg < mincylgrps ||
		    CGSIZE(&sblock) > (unsigned long)sblock.fs_bsize)
			break;
	}
	sblock.fs_fpg -= sblock.fs_frag;
	sblock.fs_ipg = roundup(howmany(sblock.fs_fpg, fragsperinode),
	    INOPB(&sblock));
	if (sblock.fs_fpg > maxfrgspercg)
		warnx("can't honour -c: minimum is %d", sblock.fs_fpg);

	/*
	 * Check to be sure that the last cylinder group has enough blocks to
	 * be viable. If it is too small, reduce the number of blocks per
	 * cylinder group which will have the effect of moving more blocks into
	 * the last cylinder group.
	 */
	optimalfpg = sblock.fs_fpg;
	for (;;) {
		sblock.fs_ncg = howmany(sblock.fs_size, sblock.fs_fpg);
		lastminfpg = roundup(sblock.fs_iblkno +
		    sblock.fs_ipg / INOPF(&sblock), sblock.fs_frag);
		if (sblock.fs_size < lastminfpg)
			errx(28, "file system size %jd < minimum size of %d "
			    "fragments", (intmax_t)sblock.fs_size, lastminfpg);

		if (sblock.fs_size % sblock.fs_fpg >= lastminfpg ||
		    sblock.fs_size % sblock.fs_fpg == 0)
			break;

		sblock.fs_fpg -= sblock.fs_frag;
		sblock.fs_ipg = roundup(howmany(sblock.fs_fpg, fragsperinode),
		    INOPB(&sblock));
	}

	if (optimalfpg != sblock.fs_fpg)
		warnx("reduced number of fragments per cylinder group from %d"
		    " to %d to enlarge last cylinder group", optimalfpg,
		    sblock.fs_fpg);

	/*
	 * Back to filling superblock fields.
	 */
	if (Oflag <= 1) {
		sblock.fs_spc = sblock.fs_fpg * sblock.fs_nspf;
		sblock.fs_nsect = sblock.fs_spc;
		sblock.fs_npsect = sblock.fs_spc;
		sblock.fs_ncyl = sblock.fs_ncg;
	}
	sblock.fs_cgsize = fragroundup(&sblock, CGSIZE(&sblock));
	sblock.fs_dblkno = sblock.fs_iblkno + sblock.fs_ipg / INOPF(&sblock);
	sblock.fs_csaddr = cgdmin(&sblock, 0);
	sblock.fs_cssize =
	    fragroundup(&sblock, sblock.fs_ncg * sizeof(struct csum));

	fscs = calloc(1, sblock.fs_cssize);
	if (fscs == NULL)
		errx(31, "calloc failed");

	sblock.fs_sbsize = fragroundup(&sblock, sizeof(struct fs));
	if (sblock.fs_sbsize > SBLOCKSIZE)
		sblock.fs_sbsize = SBLOCKSIZE;

	sblock.fs_minfree = minfree;
	sblock.fs_maxbpg = maxbpg;
	sblock.fs_optim = opt;
	sblock.fs_cgrotor = 0;
	sblock.fs_pendingblocks = 0;
	sblock.fs_pendinginodes = 0;
	sblock.fs_fmod = 0;
	sblock.fs_ronly = 0;
	sblock.fs_state = 0;
	sblock.fs_clean = 1;
	sblock.fs_id[0] = (u_int32_t)utime;
	sblock.fs_id[1] = (u_int32_t)arc4random();
	sblock.fs_fsmnt[0] = '\0';

	csfrags = howmany(sblock.fs_cssize, sblock.fs_fsize);
	sblock.fs_dsize = sblock.fs_size - sblock.fs_sblkno -
	    sblock.fs_ncg * (sblock.fs_dblkno - sblock.fs_sblkno);

	sblock.fs_cstotal.cs_nbfree = fragstoblks(&sblock, sblock.fs_dsize) -
	    howmany(csfrags, sblock.fs_frag);
	sblock.fs_cstotal.cs_nffree = fragnum(&sblock, sblock.fs_size) +
	    (fragnum(&sblock, csfrags) > 0 ?
	    sblock.fs_frag - fragnum(&sblock, csfrags) : 0);
	sblock.fs_cstotal.cs_nifree = sblock.fs_ncg * sblock.fs_ipg - ROOTINO;
	sblock.fs_cstotal.cs_ndir = 0;

	sblock.fs_dsize -= csfrags;
	sblock.fs_time = utime;

	if (Oflag <= 1) {
		sblock.fs_ffs1_time = sblock.fs_time;
		sblock.fs_ffs1_dsize = sblock.fs_dsize;
		sblock.fs_ffs1_csaddr = sblock.fs_csaddr;
		sblock.fs_ffs1_cstotal.cs_ndir = sblock.fs_cstotal.cs_ndir;
		sblock.fs_ffs1_cstotal.cs_nbfree = sblock.fs_cstotal.cs_nbfree;
		sblock.fs_ffs1_cstotal.cs_nifree = sblock.fs_cstotal.cs_nifree;
		sblock.fs_ffs1_cstotal.cs_nffree = sblock.fs_cstotal.cs_nffree;
	}

	/*
	 * Dump out summary information about file system.
	 */
	if (!mfs) {
#define B2MBFACTOR (1 / (1024.0 * 1024.0))
		printf("%s: %.1fMB in %jd sectors of %lld bytes\n", fsys,
		    (float)sblock.fs_size * sblock.fs_fsize * B2MBFACTOR,
		    (intmax_t)fsbtodb(&sblock, sblock.fs_size) /
		    (sectorsize / DEV_BSIZE), sectorsize);
		printf("%d cylinder groups of %.2fMB, %d blocks, %d"
		    " inodes each\n", sblock.fs_ncg,
		    (float)sblock.fs_fpg * sblock.fs_fsize * B2MBFACTOR,
		    sblock.fs_fpg / sblock.fs_frag, sblock.fs_ipg);
#undef B2MBFACTOR
		checksz();
	}

	/*
	 * Wipe out old FFS1 superblock if necessary.
	 */
	if (Oflag >= 2) {
		union fs_u *fsun1;
		struct fs *fs1;

		fsun1 = calloc(1, sizeof(union fs_u));
		if (fsun1 == NULL)
			err(39, "calloc");
		fs1 = &fsun1->fs;
		rdfs(SBLOCK_UFS1 / DEV_BSIZE, SBSIZE, (char *)fs1);
		if (fs1->fs_magic == FS_UFS1_MAGIC) {
			fs1->fs_magic = FS_BAD_MAGIC;
			wtfs(SBLOCK_UFS1 / DEV_BSIZE, SBSIZE, (char *)fs1);
		}
		free(fsun1);
	}

	wtfs((int)sblock.fs_sblockloc / DEV_BSIZE, SBSIZE, (char *)&sblock);
	sblock.fs_magic = (Oflag <= 1) ? FS_UFS1_MAGIC : FS_UFS2_MAGIC;

	/*
	 * Now build the cylinders group blocks and
	 * then print out indices of cylinder groups.
	 */
	if (!quiet)
		printf("super-block backups (for fsck -b #) at:\n");
#ifndef STANDALONE
	else if (!mfs && isatty(STDIN_FILENO)) {
		signal(SIGINFO, siginfo);
		cur_fsys = fsys;
	}
#endif
	i = 0;
	width = charsperline();
	/*
	* Allocate space for superblock, cylinder group map, and two sets of
	* inode blocks.
	*/
	if (sblock.fs_bsize < SBLOCKSIZE)
		iobufsize = SBLOCKSIZE + 3 * sblock.fs_bsize;
	else
		iobufsize = 4 * sblock.fs_bsize;
	if ((iobuf = malloc(iobufsize)) == NULL)
		errx(38, "cannot allocate I/O buffer");
	bzero(iobuf, iobufsize);
	/*
	 * Make a copy of the superblock into the buffer that we will be
	 * writing out in each cylinder group.
	 */
	bcopy((char *)&sblock, iobuf, SBLOCKSIZE);
	for (cylno = 0; cylno < sblock.fs_ncg; cylno++) {
		cur_cylno = (sig_atomic_t)cylno;
		initcg(cylno, utime);
		if (quiet)
			continue;
		j = snprintf(tmpbuf, sizeof tmpbuf, " %lld,",
		    (long long)fsbtodb(&sblock, cgsblock(&sblock, cylno)));
		if (j >= sizeof tmpbuf)
			j = sizeof tmpbuf - 1;
		if (j == -1 || i+j >= width) {
			printf("\n");
			i = 0;
		}
		i += j;
		printf("%s", tmpbuf);
		fflush(stdout);
	}
	if (!quiet)
		printf("\n");
	if (Nflag && !mfs)
		exit(0);
	/*
	 * Now construct the initial file system, then write out the superblock.
	 */
	if (Oflag <= 1) {
		if (fsinit1(utime, mfsmode, mfsuid, mfsgid))
			errx(32, "fsinit1 failed");
		sblock.fs_ffs1_cstotal.cs_ndir = sblock.fs_cstotal.cs_ndir;
		sblock.fs_ffs1_cstotal.cs_nbfree = sblock.fs_cstotal.cs_nbfree;
		sblock.fs_ffs1_cstotal.cs_nifree = sblock.fs_cstotal.cs_nifree;
		sblock.fs_ffs1_cstotal.cs_nffree = sblock.fs_cstotal.cs_nffree;
	} else {
		if (fsinit2(utime))
			errx(32, "fsinit2 failed");
	}

	wtfs((int)sblock.fs_sblockloc / DEV_BSIZE, SBSIZE, (char *)&sblock);

	for (i = 0; i < sblock.fs_cssize; i += sblock.fs_bsize)
		wtfs(fsbtodb(&sblock, sblock.fs_csaddr + numfrags(&sblock, i)),
		    sblock.fs_cssize - i < sblock.fs_bsize ?
		    sblock.fs_cssize - i : sblock.fs_bsize,
		    ((char *)fscs) + i);

	/*
	 * Update information about this partition in pack label, to that it may
	 * be updated on disk.
	 */
	pp->p_fstype = FS_BSDFFS;
	pp->p_fragblock =
	    DISKLABELV1_FFS_FRAGBLOCK(sblock.fs_fsize, sblock.fs_frag);
	bpg = sblock.fs_fpg / sblock.fs_frag;
	while (bpg > USHRT_MAX)
		bpg >>= 1;
	pp->p_cpg = bpg;
}

/*
 * Initialize a cylinder group.
 */
void
initcg(int cylno, time_t utime)
{
	int i, j, d, dlower, dupper, blkno, start;
	daddr_t cbase, dmax;
	struct ufs1_dinode *dp1;
	struct ufs2_dinode *dp2;
	struct csum *cs;

	/*
	 * Determine block bounds for cylinder group.  Allow space for
	 * super block summary information in first cylinder group.
	 */
	cbase = cgbase(&sblock, cylno);
	dmax = cbase + sblock.fs_fpg;
	if (dmax > sblock.fs_size)
		dmax = sblock.fs_size;
	if (fsbtodb(&sblock, cgsblock(&sblock, cylno)) + iobufsize / DEV_BSIZE 
	    > fssize)
		errx(40, "inode table does not fit in cylinder group");

	dlower = cgsblock(&sblock, cylno) - cbase;
	dupper = cgdmin(&sblock, cylno) - cbase;
	if (cylno == 0)
		dupper += howmany(sblock.fs_cssize, sblock.fs_fsize);
	cs = &fscs[cylno];
	memset(&acg, 0, sblock.fs_cgsize);
	acg.cg_ffs2_time = utime;
	acg.cg_magic = CG_MAGIC;
	acg.cg_cgx = cylno;
	acg.cg_ffs2_niblk = sblock.fs_ipg;
	acg.cg_initediblk = MINIMUM(sblock.fs_ipg, 2 * INOPB(&sblock));
	acg.cg_ndblk = dmax - cbase;

	start = sizeof(struct cg);
	if (Oflag <= 1) {
		/* Hack to maintain compatibility with old fsck. */
		if (cylno == sblock.fs_ncg - 1)
			acg.cg_ncyl = 0;
		else
			acg.cg_ncyl = sblock.fs_cpg;
		acg.cg_time = acg.cg_ffs2_time;
		acg.cg_ffs2_time = 0;
		acg.cg_niblk = acg.cg_ffs2_niblk;
		acg.cg_ffs2_niblk = 0;
		acg.cg_initediblk = 0;
		acg.cg_btotoff = start;
		acg.cg_boff = acg.cg_btotoff + sblock.fs_cpg * sizeof(int32_t);
		acg.cg_iusedoff = acg.cg_boff +
		    sblock.fs_cpg * sizeof(u_int16_t);
	} else {
		acg.cg_iusedoff = start;
	}

	acg.cg_freeoff = acg.cg_iusedoff + howmany(sblock.fs_ipg, CHAR_BIT);
	acg.cg_nextfreeoff = acg.cg_freeoff + howmany(sblock.fs_fpg, CHAR_BIT);
	if (acg.cg_nextfreeoff > sblock.fs_cgsize)
		errx(37, "panic: cylinder group too big: %d > %d",
		    acg.cg_nextfreeoff, sblock.fs_cgsize);
	acg.cg_cs.cs_nifree += sblock.fs_ipg;
	if (cylno == 0) {
		for (i = 0; i < ROOTINO; i++) {
			setbit(cg_inosused(&acg), i);
			acg.cg_cs.cs_nifree--;
		}
	}
	if (cylno > 0) {
		/*
		 * In cylno 0, space is reserved for boot and super blocks.
		 */
		for (d = 0; d < dlower; d += sblock.fs_frag) {
			blkno = d / sblock.fs_frag;
			setblock(&sblock, cg_blksfree(&acg), blkno);
			acg.cg_cs.cs_nbfree++;
			if (Oflag <= 1) {
				cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
				cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
				    [cbtorpos(&sblock, d)]++;
			}
		}
	}
	if ((i = dupper % sblock.fs_frag)) {
		acg.cg_frsum[sblock.fs_frag - i]++;
		for (d = dupper + sblock.fs_frag - i; dupper < d; dupper++) {
			setbit(cg_blksfree(&acg), dupper);
			acg.cg_cs.cs_nffree++;
		}
	}
	for (d = dupper;
	    d + sblock.fs_frag <= acg.cg_ndblk;
	    d += sblock.fs_frag) {
		blkno = d / sblock.fs_frag;
		setblock(&sblock, cg_blksfree(&acg), blkno);
		acg.cg_cs.cs_nbfree++;
		if (Oflag <= 1) {
			cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
			cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
			    [cbtorpos(&sblock, d)]++;
		}
	}
	if (d < acg.cg_ndblk) {
		acg.cg_frsum[acg.cg_ndblk - d]++;
		for (; d < acg.cg_ndblk; d++) {
			setbit(cg_blksfree(&acg), d);
			acg.cg_cs.cs_nffree++;
		}
	}
	*cs = acg.cg_cs;

	/*
	 * Write out the duplicate superblock, the cylinder group map
	 * and two blocks worth of inodes in a single write.
	 */
	start = sblock.fs_bsize > SBLOCKSIZE ? sblock.fs_bsize : SBLOCKSIZE;
	bcopy((char *)&acg, &iobuf[start], sblock.fs_cgsize);
	start += sblock.fs_bsize;
	dp1 = (struct ufs1_dinode *)(&iobuf[start]);
	dp2 = (struct ufs2_dinode *)(&iobuf[start]);
	for (i = MINIMUM(sblock.fs_ipg, 2 * INOPB(&sblock)); i != 0; i--) {
		if (sblock.fs_magic == FS_UFS1_MAGIC) {
			dp1->di_gen = (u_int32_t)arc4random();
			dp1++;
		} else {
			dp2->di_gen = (u_int32_t)arc4random();
			dp2++;
		}
	}
	wtfs(fsbtodb(&sblock, cgsblock(&sblock, cylno)), iobufsize, iobuf);

	if (Oflag <= 1) {
		/* Initialize inodes for FFS1. */
		for (i = 2 * sblock.fs_frag;
		    i < sblock.fs_ipg / INOPF(&sblock);
		    i += sblock.fs_frag) {
			dp1 = (struct ufs1_dinode *)(&iobuf[start]);
			for (j = 0; j < INOPB(&sblock); j++) {
				dp1->di_gen = (u_int32_t)arc4random();
				dp1++;
			}
			wtfs(fsbtodb(&sblock, cgimin(&sblock, cylno) + i),
			    sblock.fs_bsize, &iobuf[start]);
		}
	}
}

#define PREDEFDIR 2

struct direct root_dir[] = {
	{ ROOTINO, sizeof(struct direct), DT_DIR, 1, "." },
	{ ROOTINO, sizeof(struct direct), DT_DIR, 2, ".." },
};
struct odirect {
	u_int32_t d_ino;
	u_int16_t d_reclen;
	u_int16_t d_namlen;
	u_char	d_name[MAXNAMLEN + 1];
} oroot_dir[] = {
	{ ROOTINO, sizeof(struct direct), 1, "." },
	{ ROOTINO, sizeof(struct direct), 2, ".." },
};

int
fsinit1(time_t utime, mode_t mfsmode, uid_t mfsuid, gid_t mfsgid)
{
	union dinode node;

	/*
	 * Initialize the node
	 */
	memset(&node, 0, sizeof(node));
	node.dp1.di_atime = utime;
	node.dp1.di_mtime = utime;
	node.dp1.di_ctime = utime;

	/*
	 * Create the root directory.
	 */
	if (mfs) {
		node.dp1.di_mode = IFDIR | mfsmode;
		node.dp1.di_uid = mfsuid;
		node.dp1.di_gid = mfsgid;
	} else {
		node.dp1.di_mode = IFDIR | UMASK;
		node.dp1.di_uid = geteuid();
		node.dp1.di_gid = getegid();
	}
	node.dp1.di_nlink = PREDEFDIR;
	if (Oflag == 0)
		node.dp1.di_size = makedir((struct direct *)oroot_dir,
		    PREDEFDIR);
	else
		node.dp1.di_size = makedir(root_dir, PREDEFDIR);
	node.dp1.di_db[0] = alloc(sblock.fs_fsize, node.dp1.di_mode);
	if (node.dp1.di_db[0] == 0)
		return (1);

	node.dp1.di_blocks = btodb(fragroundup(&sblock, node.dp1.di_size));

	wtfs(fsbtodb(&sblock, node.dp1.di_db[0]), sblock.fs_fsize, iobuf);
	iput(&node, ROOTINO);

#ifdef notyet
	/*
	* Create the .snap directory.
	*/
	node.dp1.di_mode |= 020;
	node.dp1.di_gid = gid;
	node.dp1.di_nlink = SNAPLINKCNT;
	node.dp1.di_size = makedir(snap_dir, SNAPLINKCNT);

	node.dp1.di_db[0] = alloc(sblock.fs_fsize, node.dp1.di_mode);
	if (node.dp1.di_db[0] == 0)
		return (1);

	node.dp1.di_blocks = btodb(fragroundup(&sblock, node.dp1.di_size));

	wtfs(fsbtodb(&sblock, node.dp1.di_db[0]), sblock.fs_fsize, iobuf);
	iput(&node, ROOTINO + 1);
#endif
	return (0);
}

int
fsinit2(time_t utime)
{
	union dinode node;

	/*
	 * Initialize the node.
	 */
	memset(&node, 0, sizeof(node));
	node.dp2.di_atime = utime;
	node.dp2.di_mtime = utime;
	node.dp2.di_ctime = utime;

	/*
	 * Create the root directory.
	 */
	node.dp2.di_mode = IFDIR | UMASK;
	node.dp2.di_uid = geteuid();
	node.dp2.di_gid = getegid();
	node.dp2.di_nlink = PREDEFDIR;
	node.dp2.di_size = makedir(root_dir, PREDEFDIR);

	node.dp2.di_db[0] = alloc(sblock.fs_fsize, node.dp2.di_mode);
	if (node.dp2.di_db[0] == 0)
		return (1);

	node.dp2.di_blocks = btodb(fragroundup(&sblock, node.dp2.di_size));

	wtfs(fsbtodb(&sblock, node.dp2.di_db[0]), sblock.fs_fsize, iobuf);
	iput(&node, ROOTINO);

#ifdef notyet
	/*
	 * Create the .snap directory.
	 */
	node.dp2.di_mode |= 020;
	node.dp2.di_gid = gid;
	node.dp2.di_nlink = SNAPLINKCNT;
	node.dp2.di_size = makedir(snap_dir, SNAPLINKCNT);

	node.dp2.di_db[0] = alloc(sblock.fs_fsize, node.dp2.di_mode);
	if (node.dp2.di_db[0] == 0)
		return (1);

	node.dp2.di_blocks = btodb(fragroundup(&sblock, node.dp2.di_size));

	wtfs(fsbtodb(&sblock, node.dp2.di_db[0]), sblock.fs_fsize, iobuf);
	iput(&node, ROOTINO + 1);
#endif
	return (0);
}

/*
 * construct a set of directory entries in "buf".
 * return size of directory.
 */
int
makedir(struct direct *protodir, int entries)
{
	char *cp;
	int i, spcleft;

	spcleft = DIRBLKSIZ;
	for (cp = iobuf, i = 0; i < entries - 1; i++) {
		protodir[i].d_reclen = DIRSIZ(0, &protodir[i]);
		memcpy(cp, &protodir[i], protodir[i].d_reclen);
		cp += protodir[i].d_reclen;
		spcleft -= protodir[i].d_reclen;
	}
	protodir[i].d_reclen = spcleft;
	memcpy(cp, &protodir[i], DIRSIZ(0, &protodir[i]));
	return (DIRBLKSIZ);
}

/*
 * allocate a block or frag
 */
daddr_t
alloc(int size, int mode)
{
	int i, frag;
	daddr_t d, blkno;

	rdfs(fsbtodb(&sblock, cgtod(&sblock, 0)), sblock.fs_cgsize,
	    (char *)&acg);
	if (acg.cg_magic != CG_MAGIC) {
		warnx("cg 0: bad magic number");
		return (0);
	}
	if (acg.cg_cs.cs_nbfree == 0) {
		warnx("first cylinder group ran out of space");
		return (0);
	}
	for (d = 0; d < acg.cg_ndblk; d += sblock.fs_frag)
		if (isblock(&sblock, cg_blksfree(&acg), d / sblock.fs_frag))
			goto goth;
	warnx("internal error: can't find block in cyl 0");
	return (0);
goth:
	blkno = fragstoblks(&sblock, d);
	clrblock(&sblock, cg_blksfree(&acg), blkno);
	acg.cg_cs.cs_nbfree--;
	sblock.fs_cstotal.cs_nbfree--;
	fscs[0].cs_nbfree--;
	if (mode & IFDIR) {
		acg.cg_cs.cs_ndir++;
		sblock.fs_cstotal.cs_ndir++;
		fscs[0].cs_ndir++;
	}
	if (Oflag <= 1) {
		cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
		    [cbtorpos(&sblock, d)]--;
	}
	if (size != sblock.fs_bsize) {
		frag = howmany(size, sblock.fs_fsize);
		fscs[0].cs_nffree += sblock.fs_frag - frag;
		sblock.fs_cstotal.cs_nffree += sblock.fs_frag - frag;
		acg.cg_cs.cs_nffree += sblock.fs_frag - frag;
		acg.cg_frsum[sblock.fs_frag - frag]++;
		for (i = frag; i < sblock.fs_frag; i++)
			setbit(cg_blksfree(&acg), d + i);
	}
	wtfs(fsbtodb(&sblock, cgtod(&sblock, 0)), sblock.fs_cgsize,
	    (char *)&acg);
	return (d);
}

/*
 * Allocate an inode on the disk
 */
void
iput(union dinode *ip, ino_t ino)
{
	daddr_t d;

	if (Oflag <= 1)
		ip->dp1.di_gen = (u_int32_t)arc4random();
	else
		ip->dp2.di_gen = (u_int32_t)arc4random();

	rdfs(fsbtodb(&sblock, cgtod(&sblock, 0)), sblock.fs_cgsize,
	    (char *)&acg);
	if (acg.cg_magic != CG_MAGIC)
		errx(41, "cg 0: bad magic number");

	acg.cg_cs.cs_nifree--;
	setbit(cg_inosused(&acg), ino);

	wtfs(fsbtodb(&sblock, cgtod(&sblock, 0)), sblock.fs_cgsize,
	    (char *)&acg);

	sblock.fs_cstotal.cs_nifree--;
	fscs[0].cs_nifree--;
	if (ino >= sblock.fs_ipg * sblock.fs_ncg)
		errx(32, "fsinit: inode value %llu out of range",
		    (unsigned long long)ino);
	d = fsbtodb(&sblock, ino_to_fsba(&sblock, ino));
	rdfs(d, sblock.fs_bsize, iobuf);

	if (Oflag <= 1)
		((struct ufs1_dinode *)iobuf)[ino_to_fsbo(&sblock, ino)] =
		    ip->dp1;
	else
		((struct ufs2_dinode *)iobuf)[ino_to_fsbo(&sblock, ino)] =
		    ip->dp2;

	wtfs(d, sblock.fs_bsize, iobuf);
}

/*
 * read a block from the file system
 */
void
rdfs(daddr_t bno, int size, void *bf)
{
	int n;

	if (mfs) {
		memcpy(bf, membase + bno * DEV_BSIZE, size);
		return;
	}
	n = pread(fsi, bf, size, (off_t)bno * DEV_BSIZE);
	if (n != size) {
		err(34, "rdfs: read error on block %lld", (long long)bno);
	}
}

/*
 * write a block to the file system
 */
void
wtfs(daddr_t bno, int size, void *bf)
{
	int n;

	if (mfs) {
		memcpy(membase + bno * DEV_BSIZE, bf, size);
		return;
	}
	if (Nflag)
		return;
	n = pwrite(fso, bf, size, (off_t)bno * DEV_BSIZE);
	if (n != size) {
		err(36, "wtfs: write error on block %lld", (long long)bno);
	}
}

/*
 * check if a block is available
 */
int
isblock(struct fs *fs, unsigned char *cp, int h)
{
	unsigned char mask;

	switch (fs->fs_frag) {
	case 8:
		return (cp[h] == 0xff);
	case 4:
		mask = 0x0f << ((h & 0x1) << 2);
		return ((cp[h >> 1] & mask) == mask);
	case 2:
		mask = 0x03 << ((h & 0x3) << 1);
		return ((cp[h >> 2] & mask) == mask);
	case 1:
		mask = 0x01 << (h & 0x7);
		return ((cp[h >> 3] & mask) == mask);
	default:
#ifdef STANDALONE
		printf("isblock bad fs_frag %d\n", fs->fs_frag);
#else
		warnx("isblock bad fs_frag %d", fs->fs_frag);
#endif
		return (0);
	}
}

/*
 * take a block out of the map
 */
void
clrblock(struct fs *fs, unsigned char *cp, int h)
{
	switch ((fs)->fs_frag) {
	case 8:
		cp[h] = 0;
		return;
	case 4:
		cp[h >> 1] &= ~(0x0f << ((h & 0x1) << 2));
		return;
	case 2:
		cp[h >> 2] &= ~(0x03 << ((h & 0x3) << 1));
		return;
	case 1:
		cp[h >> 3] &= ~(0x01 << (h & 0x7));
		return;
	default:
#ifdef STANDALONE
		printf("clrblock bad fs_frag %d\n", fs->fs_frag);
#else
		warnx("clrblock bad fs_frag %d", fs->fs_frag);
#endif
		return;
	}
}

/*
 * put a block into the map
 */
void
setblock(struct fs *fs, unsigned char *cp, int h)
{
	switch (fs->fs_frag) {
	case 8:
		cp[h] = 0xff;
		return;
	case 4:
		cp[h >> 1] |= (0x0f << ((h & 0x1) << 2));
		return;
	case 2:
		cp[h >> 2] |= (0x03 << ((h & 0x3) << 1));
		return;
	case 1:
		cp[h >> 3] |= (0x01 << (h & 0x7));
		return;
	default:
#ifdef STANDALONE
		printf("setblock bad fs_frag %d\n", fs->fs_frag);
#else
		warnx("setblock bad fs_frag %d", fs->fs_frag);
#endif
		return;
	}
}

/*
 * Determine the number of characters in a
 * single line.
 */
static int
charsperline(void)
{
	int columns;
	char *cp;
	struct winsize ws;

	columns = 0;
	if ((cp = getenv("COLUMNS")) != NULL)
		columns = strtonum(cp, 1, INT_MAX, NULL);
	if (columns == 0 && ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 &&
	    ws.ws_col > 0)
		columns = ws.ws_col;
	if (columns == 0)
		columns = 80;

	return columns;
}

static int
ilog2(int val)
{
	int n;

	for (n = 0; n < sizeof(n) * CHAR_BIT; n++)
		if (1 << n == val)
			return (n);

	errx(1, "ilog2: %d is not a power of 2\n", val);
}

struct inoinfo {
        struct  inoinfo *i_nexthash;    /* next entry in hash chain */
        struct  inoinfo *i_child, *i_sibling, *i_parentp;
        size_t  i_isize;                /* size of inode */
        ino_t   i_number;               /* inode number of this entry */  
        ino_t   i_parent;               /* inode number of parent */
  
        ino_t   i_dotdot;               /* inode number of `..' */
        u_int   i_numblks;              /* size of block array in bytes */
        daddr_t i_blks[1];              /* actually longer */
};

static void
checksz(void)
{
	unsigned long long allocate, maxino, maxfsblock, ndir, bound;
	extern int64_t physmem;
	struct rlimit datasz;

	if (getrlimit(RLIMIT_DATA, &datasz) != 0)
		err(1, "can't get rlimit");

	bound = MINIMUM(datasz.rlim_max, physmem);

	allocate = 0;
	maxino = sblock.fs_ncg * (unsigned long long)sblock.fs_ipg;
	maxfsblock = sblock.fs_size;
	ndir = maxino / avgfilesperdir;

	allocate += roundup(howmany(maxfsblock, NBBY), sizeof(int16_t));
	allocate += (maxino + 1) * 3;
	allocate += sblock.fs_ncg * sizeof(long);
	allocate += (MAXIMUM(ndir, 128) + 10) * sizeof(struct inoinfo);
	allocate += MAXIMUM(ndir, 128) * sizeof(struct inoinfo);

	if (allocate > bound)
		warnx("warning: fsck_ffs will need %lluMB; "
		    "min(ulimit -dH,physmem) is %lluMB",
		    allocate / (1024ULL * 1024ULL),
		    bound / (1024ULL * 1024ULL));
}
@


1.96
log
@Switch (non-curses, non-ksh) programs that use COLUMNS to a single idiom.

Previously behaviors were all over the map. This changes them to
use COLUMNS first, and either terminal width or a hardcoded value
(typically 80) as appropriate.

ok deraadt@@; man bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.95 2016/01/28 17:26:10 gsoares Exp $	*/
d172 1
d612 4
a615 1
	pp->p_cpg = sblock.fs_cpg;
@


1.95
log
@malloc(3) returns a pointer, so check against NULL, not 0. (No functional change)

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.94 2015/11/23 19:19:30 deraadt Exp $	*/
d1147 4
a1150 1
	if (ioctl(0, TIOCGWINSZ, &ws) != -1)
a1151 2
	if (columns == 0 && (cp = getenv("COLUMNS")))
		columns = strtonum(cp, 1, INT_MAX, NULL);
d1153 2
a1154 1
		columns = 80;   /* last resort */
@


1.94
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.93 2015/10/11 00:20:29 guenther Exp $	*/
d552 1
a552 1
	if ((iobuf = malloc(iobufsize)) == 0)
@


1.93
log
@Prefer dprintf() over snprintf()+write()

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.92 2015/08/20 22:02:21 deraadt Exp $	*/
d1184 1
a1184 1
	int mib[2];
a1185 1
	size_t len;
a1186 6
	mib[0] = CTL_HW;
	mib[1] = HW_PHYSMEM64;
	len = sizeof(bound);
	
	if (sysctl(mib, 2, &bound, &len, NULL, 0) != 0)
		err(1, "can't get physmem");
d1189 2
a1190 1
	bound = MINIMUM(datasz.rlim_max, bound);
@


1.92
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.91 2015/04/18 18:28:37 deraadt Exp $	*/
a156 1
	char buf[128];
d158 1
a158 1
	snprintf(buf, sizeof(buf), "%s: initializing cg %ld/%d\n",
a159 1
	write(STDERR_FILENO, buf, strlen(buf));
@


1.91
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.90 2015/02/06 22:29:00 millert Exp $	*/
d446 1
a446 1
	fscs = (struct csum *)calloc(1, sblock.fs_cssize);
@


1.90
log
@Better size_t overflow check for mount_mfs.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.89 2015/01/20 18:22:21 deraadt Exp $	*/
d1152 1
a1152 1
		columns = atoi(cp);
@


1.89
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.88 2015/01/18 04:48:24 deraadt Exp $	*/
d185 2
a186 2
		quad_t sz = (quad_t)fssize * DEV_BSIZE;
		if (sz > SIZE_T_MAX) {
d190 1
@


1.88
log
@do not require <a.out.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.87 2015/01/16 06:40:00 deraadt Exp $	*/
d42 1
a42 1
#include <sys/param.h>	/* MAXFRAG MAXBSIZE DEV_BSIZE roundup btodb setbit */
@


1.87
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.86 2014/06/30 19:19:17 otto Exp $	*/
a62 1
#include <a.out.h>
@


1.86
log
@Use getrlimit(2) instead of assuming MAXDSIZ is available in userland.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.85 2014/01/24 22:29:21 miod Exp $	*/
d42 2
a43 1
#include <sys/param.h>
d60 1
d68 3
d338 1
a338 1
		fragsperinode = MAX(numfrags(&sblock, density), 1);
d650 1
a650 1
	acg.cg_initediblk = MIN(sblock.fs_ipg, 2 * INOPB(&sblock));
d737 1
a737 1
	for (i = MIN(sblock.fs_ipg, 2 * INOPB(&sblock)); i != 0; i--) {
d1198 1
a1198 1
	bound = MIN(datasz.rlim_max, bound);
d1208 2
a1209 2
	allocate += (MAX(ndir, 128) + 10) * sizeof(struct inoinfo);
	allocate += MAX(ndir, 128) * sizeof(struct inoinfo);
@


1.85
log
@Don't include <machine/vmparam.h> directly. Instead, get it with its necessary
dependencies via <sys/sysctl.h>. Unbreaks ppc userland build.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.84 2013/11/12 04:59:02 deraadt Exp $	*/
d47 1
d1182 1
d1191 3
a1193 1
	bound = MIN(MAXDSIZ, bound);
d1208 1
a1208 1
		    "min(MAXDSIZ,physmem) is %lluMB",
@


1.84
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.83 2013/11/03 02:22:07 krw Exp $	*/
a42 1
#include <machine/vmparam.h>
@


1.83
log
@Add missing (long long) cast of variable, (long long) casts
for defines fragnum, fsbtodb, cgsblock, and cgdmin.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.82 2013/11/01 17:36:19 krw Exp $	*/
d147 1
@


1.82
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.81 2013/10/07 21:00:45 krw Exp $	*/
d562 1
a562 1
		    fsbtodb(&sblock, cgsblock(&sblock, cylno)));
@


1.81
log
@Say 'fragments' where fragments are meant. Divide by DEV_BSIZE
to convert from bytes to DEV_SIZE.

ok otto@@ zhuk@@ (for his chunk)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.80 2013/10/07 11:51:11 krw Exp $	*/
d198 2
a199 1
		errx(13, "preposterous size %lld, max is %d", fssize, INT_MAX);
d201 2
a202 2
		errx(13, "preposterous size %lld, max is %lld", fssize,
		    MAXDISKSIZE);
d1019 1
a1019 1
		err(34, "rdfs: read error on block %lld", bno);
d1039 1
a1039 1
		err(36, "wtfs: write error on block %lld", bno);
@


1.80
log
@Show number of sectors, not the number of 512-byte blocks, when
saying "n sectors of m bytes".

Issue pointed out by David Vasek on misc@@. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.79 2013/10/06 21:50:23 krw Exp $	*/
d408 1
a408 1
			    "sectors", (intmax_t)sblock.fs_size, lastminfpg);
d629 1
a629 1
	if (fsbtodb(&sblock, cgsblock(&sblock, cylno)) + iobufsize / sectorsize
@


1.79
log
@daddr_t comment tweak and whitespace fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.78 2013/06/11 16:42:05 deraadt Exp $	*/
d493 2
a494 1
		    (intmax_t)fsbtodb(&sblock, sblock.fs_size), sectorsize);
@


1.78
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.77 2013/04/23 21:27:38 deraadt Exp $	*/
d89 1
a89 1
extern daddr_t fssize;	/* file system size */
d1171 1
a1171 1
        daddr_t       i_blks[1];              /* actually longer */
@


1.77
log
@handle large ino_t; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.76 2011/06/05 15:20:37 chl Exp $	*/
d89 1
a89 1
extern daddr64_t fssize;	/* file system size */
d127 1
a127 1
daddr64_t	alloc(int, int);
d131 1
a131 1
void		wtfs(daddr64_t, int, void *);
d139 1
a139 1
void		rdfs(daddr64_t, int, void *);
d615 1
a615 1
	daddr64_t cbase, dmax;
d910 1
a910 1
daddr64_t
d914 1
a914 1
	daddr64_t d, blkno;
d967 1
a967 1
	daddr64_t d;
d1007 1
a1007 1
rdfs(daddr64_t bno, int size, void *bf)
d1025 1
a1025 1
wtfs(daddr64_t bno, int size, void *bf)
d1171 1
a1171 1
        daddr64_t       i_blks[1];              /* actually longer */
@


1.76
log
@fix format string

ok dcoppa@@ otto@@
also reviewed by Vadim Zhukov
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.75 2011/05/23 10:56:17 dcoppa Exp $	*/
d988 2
a989 1
		errx(32, "fsinit: inode value %d out of range", ino);
@


1.75
log
@Allow specifying k/m/g/... suffixes in newfs(8) -S and -s options.

Useful for mount_mfs, now you can just say:

# mount_mfs -s 50m swap /tmp

And it will do what you want, taking into account sector size.

Old behaviour of -s (specifying count of sectors) is, of course,
preserved.

All the work was done by Vadim Zhukov (persgray(at)gmail com).

OK myself, otto@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.74 2010/03/21 09:13:30 otto Exp $	*/
d220 1
a220 1
		errx(18, "fragment size %d is too small, minimum is %d",
d491 1
a491 1
		printf("%s: %.1fMB in %jd sectors of %d bytes\n", fsys,
@


1.74
log
@compute an estimate of how much memory is needed to fsck_ffs the fs
we're about to create and warn the user if this is larger than either
physmem or MAXDSIZ; ok deraadt@@ krw@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.73 2009/12/23 02:24:39 krw Exp $	*/
d90 1
a90 1
extern int	sectorsize;	/* bytes/sector */
d407 2
a408 2
			errx(28, "file system size %jd < minimum size of %d",
			    (intmax_t)sblock.fs_size, lastminfpg);
@


1.73
log
@partion -> partition. First one (mkfs.c) noted by Brad Tilley on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.72 2008/08/08 23:49:53 krw Exp $	*/
d43 1
d48 1
d142 1
d499 1
d1159 45
@


1.72
log
@Admit b_blkno means block number; a block is DEV_BSIZE (a.k.a.
512) bytes; ffs is inextricably tied to using b_blkno and disklabel
always uses sectorsize units.

Thus use DEV_BSIZE units for all fields describing ffs filesystems
and convert to/from sectors where required. This enables the creation
and use of ffs filesystems on non-512 byte sectorsize devices.

This diff allows i386 and sgi (the two test platforms) to find
disklabels that are not on a sectorsize boundary. Same change to
further archs coming.

This is a no-op on 512-byte sectorsize devices.

This work triggered by jsing@@'s need to create ffs filesystems on
sgi cdroms so we can create cdrom install media for sgi.

sgi testing by jsing@@

ok jsing@@ pedro@@ "looks sane" beck@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.71 2008/01/05 19:51:55 otto Exp $	*/
d595 1
a595 1
	 * Update information about this partion in pack label, to that it may
@


1.71
log
@handle 64-bit blkno's in format string
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.70 2007/07/07 08:16:52 millert Exp $	*/
d177 1
a177 1
		quad_t sz = (quad_t)fssize * sectorsize;
d200 1
a200 1
	wtfs(fssize - 1, sectorsize, (char *)&sblock);
d251 1
a251 1
	sblock.fs_fsbtodb = ilog2(sblock.fs_fsize / sectorsize);
d253 1
a253 1
	sblock.fs_nspf = sblock.fs_fsize / sectorsize;
d509 1
a509 1
		rdfs(SBLOCK_UFS1 / sectorsize, SBSIZE, (char *)fs1);
d512 1
a512 1
			wtfs(SBLOCK_UFS1 / sectorsize, SBSIZE, (char *)fs1);
d517 1
a517 1
	wtfs((int)sblock.fs_sblockloc / sectorsize, SBSIZE, (char *)&sblock);
d586 1
a586 1
	wtfs((int)sblock.fs_sblockloc / sectorsize, SBSIZE, (char *)&sblock);
d1007 1
a1007 1
		memcpy(bf, membase + bno * sectorsize, size);
d1010 1
a1010 1
	n = pread(fsi, bf, size, (off_t)bno * sectorsize);
d1025 1
a1025 1
		memcpy(membase + bno * sectorsize, bf, size);
d1030 1
a1030 1
	n = pwrite(fso, bf, size, (off_t)bno * sectorsize);
@


1.70
log
@Initialize the first 2 block's worth of inodes for ffs1 as well as ffs2.
This was not happening since acg.cg_initediblk gets cleared for the
ffs1 case.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.69 2007/06/26 19:03:21 otto Exp $	*/
d555 1
a555 1
		j = snprintf(tmpbuf, sizeof tmpbuf, " %ld,",
@


1.69
log
@Enable creation of larger than 1TB FFS2 filesystems. Note that this
won't work yet. There remains sys/ufs work.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.68 2007/06/10 19:11:43 otto Exp $	*/
d638 1
a638 2
	acg.cg_initediblk = sblock.fs_ipg < 2 * INOPB(&sblock) ?
	    sblock.fs_ipg : 2 * INOPB(&sblock);
d725 1
a725 2

	for (i = 0; i < acg.cg_initediblk; i++) {
a733 1

@


1.68
log
@remove last instances of daddr_t; ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.67 2007/06/01 23:42:35 pedro Exp $	*/
d87 1
a87 1
extern int	fssize;		/* file system size */
d194 5
a198 2
	if (fssize <= 0)
		errx(13, "preposterous size %u, max is %u", fssize, INT_MAX);
@


1.67
log
@ufs1_daddr_t cleanup, okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.66 2007/06/01 23:08:23 otto Exp $	*/
d294 1
a294 1
	sblock.fs_cblkno = (daddr_t)(sblock.fs_sblkno +
@


1.66
log
@daddr64_t changes; not fssize is still an int; ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.65 2007/06/01 06:41:35 deraadt Exp $	*/
d267 1
a267 1
		sblock.fs_nindir = sblock.fs_bsize / sizeof(ufs1_daddr_t);
d287 1
a287 1
		sblock.fs_nindir = sblock.fs_bsize / sizeof(daddr64_t);
@


1.65
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.64 2007/05/29 06:28:16 otto Exp $	*/
d125 1
a125 1
daddr_t		alloc(int, int);
d129 1
a129 1
void		wtfs(daddr_t, int, void *);
d137 1
a137 1
void		rdfs(daddr_t, int, void *);
d906 1
a906 1
daddr_t
d910 1
a910 1
	daddr_t d, blkno;
d1002 1
a1002 1
rdfs(daddr_t bno, int size, void *bf)
d1012 1
a1012 1
		err(34, "rdfs: read error on block %d", bno);
d1020 1
a1020 1
wtfs(daddr_t bno, int size, void *bf)
d1032 1
a1032 1
		err(36, "wtfs: write error on block %d", bno);
@


1.64
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.63 2007/05/19 20:12:50 otto Exp $	*/
d287 1
a287 1
		sblock.fs_nindir = sblock.fs_bsize / sizeof(ufs2_daddr_t);
d608 1
a608 1
	ufs2_daddr_t cbase, dmax;
d963 1
a963 1
	ufs2_daddr_t d;
@


1.63
log
@Now that the amd64 floppy and cd image -c setting have been fixed,
recommit the -c changes. For now, we warn only if we cannot honour -c.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.62 2007/05/19 01:28:15 deraadt Exp $	*/
d596 2
a597 2
	pp->p_fsize = sblock.fs_fsize;
	pp->p_frag = sblock.fs_frag;
@


1.62
log
@backout -c changes; they were not tested on all the media.  all newfs
changes obviously *MUST* be checked against whatever weird things the
floppies do to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.60 2007/05/18 18:57:06 otto Exp $	*/
d91 1
a91 1
extern int	maxblkspercg;	/* maximum blocks per cylinder group */
d362 2
a363 2
	if (maxblkspercg != INT_MAX) {
		i = sblock.fs_size / maxblkspercg;
d373 2
a374 1
	for (; sblock.fs_fpg < maxblkspercg; sblock.fs_fpg += sblock.fs_frag) {
d378 3
a380 7
		if (sblock.fs_size / sblock.fs_fpg < mincylgrps)
			break;

		if (CGSIZE(&sblock) < (unsigned long)sblock.fs_bsize)
			continue;

		if (CGSIZE(&sblock) == (unsigned long)sblock.fs_bsize)
a381 6

		sblock.fs_fpg -= sblock.fs_frag;
		sblock.fs_ipg = roundup(howmany(sblock.fs_fpg, fragsperinode),
		    INOPB(&sblock));

		break;
d383 5
@


1.61
log
@The unit of the -c options is fragments, so adjust man page and
variable name; correct the loop packing more inodes into the cg:
in some cases it could put more fragments into the cg than requested;
give an error if the -c option cannot be honoured. ok millert@@ pedro@@
@
text
@d91 1
a91 1
extern int	maxfrgspercg;	/* maximum fragments per cylinder group */
d362 2
a363 2
	if (maxfrgspercg != INT_MAX) {
		i = sblock.fs_size / maxfrgspercg;
d373 1
a373 2
	for (;;) {
		sblock.fs_fpg += sblock.fs_frag;
d377 7
a383 3
		if (sblock.fs_fpg > maxfrgspercg ||
		    sblock.fs_size / sblock.fs_fpg < mincylgrps ||
		    CGSIZE(&sblock) > (unsigned long)sblock.fs_bsize)
d385 6
a391 5
	sblock.fs_fpg -= sblock.fs_frag;
	sblock.fs_ipg = roundup(howmany(sblock.fs_fpg, fragsperinode),
	    INOPB(&sblock));
	if (sblock.fs_fpg > maxfrgspercg)
		errx(22, "can't honour -c: minimum is %d", sblock.fs_fpg);
@


1.60
log
@Do a bounds check to see if the inode table fits on the disk.
Prevents a core dump found by djm@@ when doing mount_mfs -s 80
(yeah, that's a tiny file system); ok millert@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.59 2007/05/03 20:11:55 millert Exp $	*/
d91 1
a91 1
extern int	maxblkspercg;	/* maximum blocks per cylinder group */
d362 2
a363 2
	if (maxblkspercg != INT_MAX) {
		i = sblock.fs_size / maxblkspercg;
d373 2
a374 1
	for (; sblock.fs_fpg < maxblkspercg; sblock.fs_fpg += sblock.fs_frag) {
d378 3
a380 7
		if (sblock.fs_size / sblock.fs_fpg < mincylgrps)
			break;

		if (CGSIZE(&sblock) < (unsigned long)sblock.fs_bsize)
			continue;

		if (CGSIZE(&sblock) == (unsigned long)sblock.fs_bsize)
a381 6

		sblock.fs_fpg -= sblock.fs_frag;
		sblock.fs_ipg = roundup(howmany(sblock.fs_fpg, fragsperinode),
		    INOPB(&sblock));

		break;
d383 5
@


1.59
log
@Update CGSIZE macro so that it is no longer based on fs_cpg.
This was part of the ffs2 changes but was not committed earlier in
order to make the userland and kernel changes independent.

NOTE: the change to newfs require an updated fs.h; building an
updated newfs with the old fs.h may result in a broken filesystem.
OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.58 2007/04/23 10:18:30 pedro Exp $	*/
d625 4
@


1.58
log
@Remove 'cg_space' from 'struct cg'. Due to the alignment on 64-bit
architectures, CGSIZE() was returning something sligthly over one block.
The 'new' fsck would round this value up to a fragment boundary, and end
up trying to access memory beyond allocated space. From mickey@@, okay
pedro@@, millert@@ and otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.57 2007/04/18 14:13:31 otto Exp $	*/
a343 1
		sblock.fs_spc = sblock.fs_fpg * sblock.fs_nspf;
d373 1
a373 3
	for (; sblock.fs_fpg < maxblkspercg;
	    sblock.fs_fpg += sblock.fs_frag,
	    sblock.fs_spc = sblock.fs_fpg * sblock.fs_nspf) {
a386 1
		sblock.fs_spc = sblock.fs_fpg * sblock.fs_nspf;
a412 1
		sblock.fs_spc = sblock.fs_fpg * sblock.fs_nspf;
d426 1
@


1.57
log
@don't let fpg and spc get out of sync. solves a few cases where newfs
produces a bad cg when -c is used. ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.56 2007/04/17 14:24:14 millert Exp $	*/
d643 1
a643 1
	start = &acg.cg_space[0] - (u_char *)(&acg.cg_firstfield);
@


1.56
log
@Fix merge error; fs_inodefmt was not being set for the ffs2 case
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.55 2007/04/13 17:33:02 millert Exp $	*/
d374 3
a376 2
	for (; sblock.fs_fpg < maxblkspercg; sblock.fs_fpg += sblock.fs_frag) {
		sblock.fs_spc = sblock.fs_fpg * sblock.fs_nspf;
@


1.55
log
@Add support for creating ffs2 filesystems.  Note that the concept
of a constant-sized track is obsolete in today's world of variable
blocks per track disks so the cylinder group packing algorithm has
been updated.  Based on the ufs2 changes in FreeBSD by Kirk McKusick.
From pedro@@ with changes by me as well as a few from NetBSD.
OK pedro@@ beck@@ thib@@ and tested by more...
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.54 2007/04/03 18:42:32 millert Exp $	*/
d285 1
@


1.54
log
@Remove obsolete options for superblock fields that are no longer used.
OK deraadt @@, OK in principle tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.53 2007/04/03 17:08:30 millert Exp $	*/
d5 9
d44 4
a50 3
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
d55 1
d65 1
a65 5
 * We limit the size of the inode map to be no more than a
 * third of the cylinder group space, since we must leave at
 * least an equal amount of space for the block map.
 *
 * N.B.: MAXIPG must be a multiple of INOPB(fs).
d67 1
a67 1
#define MAXIPG(fs)	roundup((fs)->fs_bsize * NBBY / 3, INOPB(fs))
a68 2
#define UMASK		0755
#define MAXINOPB	(MAXBSIZE / sizeof(struct ufs1_dinode))
d72 10
a87 3
extern int	ntracks;	/* # tracks/cylinder */
extern int	nsectors;	/* # sectors/track */
extern int	secpercyl;	/* sectors per cylinder */
d91 1
a91 2
extern int	cpg;		/* cylinders/cylinder group */
extern int	cpgflg;		/* cylinders/cylinder group flag was given */
a94 1
extern int	maxcontig;	/* max contiguous blocks to allocate */
a95 2
extern int	bbsize;		/* boot block size */
extern int	sbsize;		/* superblock size */
d115 4
a118 2
struct ufs1_dinode *zino;
char	*buf;
d122 3
d127 1
d130 2
a131 1
int		fsinit(time_t, mode_t, uid_t, gid_t);
d133 1
a133 1
void		iput(struct ufs1_dinode *, ino_t);
d159 2
a160 2
mkfs(struct partition *pp, char *fsys, int fi, int fo,
    mode_t mfsmode, uid_t mfsuid, gid_t mfsgid)
a161 5
	long i, mincpc, mincpg, inospercg;
	long cylno, j, warn = 0;
	long used, mincpgcnt, bpcg;
	long mapcramped, inodecramped;
	long postblsize, rotblsize, totalsbsize;
d164 3
a166 1
	int width;
d170 1
a170 3
	    (cgun = calloc(1, sizeof (union cg_u))) == NULL ||
	    (zino = calloc(1, MAXBSIZE)) == NULL ||
	    (buf = calloc(1, MAXBSIZE)) == NULL) {
a171 1
	}
a189 7
	if (Oflag) {
		sblock.fs_inodefmt = FS_42INODEFMT;
		sblock.fs_maxsymlinklen = 0;
	} else {
		sblock.fs_inodefmt = FS_44INODEFMT;
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN_UFS1;
	}
d196 1
d198 2
a199 13
recalc:
	/*
	 * collect and verify the sector and track info
	 */
	sblock.fs_nsect = nsectors;
	sblock.fs_ntrak = ntracks;
	if (sblock.fs_ntrak <= 0)
		errx(14, "preposterous ntrak %d", sblock.fs_ntrak);
	if (sblock.fs_nsect <= 0)
		errx(15, "preposterous nsect %d", sblock.fs_nsect);
	/*
	 * collect and verify the filesystem density info
	 */
d202 1
a202 6
	if (sblock.fs_avgfilesize <= 0)
		errx(14, "illegal expected average file size %d",
		    sblock.fs_avgfilesize);
	if (sblock.fs_avgfpdir <= 0)
		errx(15, "illegal expected number of files per directory %d",
		    sblock.fs_avgfpdir);
d204 1
a204 1
	 * collect and verify the block and fragment sizes
d206 2
a207 5
	sblock.fs_bsize = bsize;
	sblock.fs_fsize = fsize;
	if (!POWEROF2(sblock.fs_bsize)) {
		errx(16, "block size must be a power of 2, not %d",
		     sblock.fs_bsize);
d209 1
a209 1
	if (!POWEROF2(sblock.fs_fsize)) {
d211 1
a211 1
		     sblock.fs_fsize);
d213 1
a213 1
	if (sblock.fs_fsize < sectorsize) {
d215 1
a215 1
		     sblock.fs_fsize, sectorsize);
d217 1
a217 1
	if (sblock.fs_bsize < MINBSIZE) {
d219 1
a219 1
		     sblock.fs_bsize, MINBSIZE);
d221 1
a221 1
	if (sblock.fs_bsize > MAXBSIZE) {
d223 1
a223 1
		     sblock.fs_bsize, MAXBSIZE);
d225 1
a225 1
	if (sblock.fs_bsize < sblock.fs_fsize) {
d227 1
a227 1
		     sblock.fs_bsize, sblock.fs_fsize);
d229 6
d239 2
a240 4
	for (sblock.fs_bshift = 0, i = sblock.fs_bsize; i > 1; i >>= 1)
		sblock.fs_bshift++;
	for (sblock.fs_fshift = 0, i = sblock.fs_fsize; i > 1; i >>= 1)
		sblock.fs_fshift++;
a241 2
	for (sblock.fs_fragshift = 0, i = sblock.fs_frag; i > 1; i >>= 1)
		sblock.fs_fragshift++;
d243 2
a244 2
		errx(21, "fragment size %d is too small, minimum with block size %d is %d",
		    sblock.fs_fsize, sblock.fs_bsize,
d247 5
d253 37
a289 5
	sblock.fs_nindir = sblock.fs_bsize / sizeof(daddr_t);
	sblock.fs_inopb = sblock.fs_bsize / sizeof(struct ufs1_dinode);
	sblock.fs_nspf = sblock.fs_fsize / sectorsize;
	for (sblock.fs_fsbtodb = 0, i = NSPF(&sblock); i > 1; i >>= 1)
		sblock.fs_fsbtodb++;
d291 2
a292 1
	    roundup(howmany(bbsize + sbsize, sblock.fs_fsize), sblock.fs_frag);
d294 1
a294 1
	    roundup(howmany(sbsize, sblock.fs_fsize), sblock.fs_frag));
a295 6
	sblock.fs_cgoffset = roundup(
	    howmany(sblock.fs_nsect, NSPF(&sblock)), sblock.fs_frag);
	for (sblock.fs_cgmask = 0xffffffff, i = sblock.fs_ntrak; i > 1; i >>= 1)
		sblock.fs_cgmask <<= 1;
	if (!POWEROF2(sblock.fs_ntrak))
		sblock.fs_cgmask <<= 1;
d301 1
d303 2
a304 2
	 * Validate specified/determined secpercyl
	 * and calculate minimum cylinders per group.
d306 42
a347 66
	sblock.fs_spc = secpercyl;
	for (sblock.fs_cpc = NSPB(&sblock), i = sblock.fs_spc;
	     sblock.fs_cpc > 1 && (i & 1) == 0;
	     sblock.fs_cpc >>= 1, i >>= 1)
		/* void */;
	mincpc = sblock.fs_cpc;
	bpcg = sblock.fs_spc * sectorsize;
	inospercg = roundup(bpcg / sizeof(struct ufs1_dinode), INOPB(&sblock));
	if (inospercg > MAXIPG(&sblock))
		inospercg = MAXIPG(&sblock);
	used = (sblock.fs_iblkno + inospercg / INOPF(&sblock)) * NSPF(&sblock);
	mincpgcnt = howmany(sblock.fs_cgoffset * (~sblock.fs_cgmask) + used,
	    sblock.fs_spc);
	mincpg = roundup(mincpgcnt, mincpc);
	/*
	 * Ensure that cylinder group with mincpg has enough space
	 * for block maps.
	 */
	sblock.fs_cpg = mincpg;
	sblock.fs_ipg = inospercg;
	if (maxcontig > 1)
		sblock.fs_contigsumsize = MIN(maxcontig, FS_MAXCONTIG);
	mapcramped = 0;
	/* A cylinder group *must* fit inside one block so force it if not. */
	if (CGSIZE(&sblock) > sblock.fs_bsize && secpercyl > 1024 && ntracks > 1) {
		secpercyl /= 2;
		ntracks /= 2;
		goto recalc;
	}
	while (CGSIZE(&sblock) > sblock.fs_bsize) {
		mapcramped = 1;
		if (sblock.fs_bsize < MAXBSIZE) {
			sblock.fs_bsize <<= 1;
			if ((i & 1) == 0) {
				i >>= 1;
			} else {
				sblock.fs_cpc <<= 1;
				mincpc <<= 1;
				mincpg = roundup(mincpgcnt, mincpc);
				sblock.fs_cpg = mincpg;
			}
			sblock.fs_frag <<= 1;
			sblock.fs_fragshift += 1;
			if (sblock.fs_frag <= MAXFRAG)
				continue;
		}
		if (sblock.fs_fsize == sblock.fs_bsize) {
			errx(22, "no block size to support this disk");
		}
		sblock.fs_frag >>= 1;
		sblock.fs_fragshift -= 1;
		sblock.fs_fsize <<= 1;
		sblock.fs_nspf <<= 1;
	}
	/*
	 * Ensure that cylinder group with mincpg has enough space for inodes.
	 */
	inodecramped = 0;
	used *= sectorsize;
	inospercg = roundup(((int64_t)mincpg * bpcg - used) / density,
	    INOPB(&sblock));
	sblock.fs_ipg = inospercg;
	while (inospercg > MAXIPG(&sblock)) {
		inodecramped = 1;
		if (mincpc == 1 || sblock.fs_frag == 1 ||
		    sblock.fs_bsize == MINBSIZE)
d349 2
a350 16
		printf("With a block size of %d %s %ld\n",
		    sblock.fs_bsize, "minimum bytes per inode is",
		    (mincpg * bpcg - used) / MAXIPG(&sblock) + 1);
		sblock.fs_bsize >>= 1;
		sblock.fs_frag >>= 1;
		sblock.fs_fragshift -= 1;
		mincpc >>= 1;
		sblock.fs_cpg = roundup(mincpgcnt, mincpc);
		if (CGSIZE(&sblock) > sblock.fs_bsize) {
			sblock.fs_bsize <<= 1;
			break;
		}
		mincpg = sblock.fs_cpg;
		inospercg = roundup(((int64_t)mincpg * bpcg - used) / density,
		    INOPB(&sblock));
		sblock.fs_ipg = inospercg;
d352 14
a365 8
	if (inodecramped) {
		if (inospercg > MAXIPG(&sblock)) {
			printf("Minimum bytes per inode is %ld\n",
			    (mincpg * bpcg - used) / MAXIPG(&sblock) + 1);
		} else if (!mapcramped) {
			printf("With %d bytes per inode, ", density);
			printf("minimum cylinders per group is %ld\n", mincpg);
		}
d367 1
a367 74
	if (mapcramped) {
		printf("With %d sectors per cylinder, ", sblock.fs_spc);
		printf("minimum cylinders per group is %ld\n", mincpg);
	}
	if (inodecramped || mapcramped) {
		if (sblock.fs_bsize != bsize)
			printf("%s to be changed from %d to %d\n",
			    "This requires the block size",
			    bsize, sblock.fs_bsize);
		if (sblock.fs_fsize != fsize)
			printf("\t%s to be changed from %d to %d\n",
			    "and the fragment size",
			    fsize, sblock.fs_fsize);
		exit(23);
	}
	/*
	 * Calculate the number of cylinders per group
	 */
	sblock.fs_cpg = cpg;
	if (sblock.fs_cpg % mincpc != 0) {
		if (!quiet)
			printf("%s groups must have a multiple of %ld "
			    "cylinders\n", cpgflg ? "Cylinder" :
			    "Warning: cylinder", mincpc);
		sblock.fs_cpg = roundup(sblock.fs_cpg, mincpc);
		if (!cpgflg)
			cpg = sblock.fs_cpg;
	}
	/*
	 * Must ensure there is enough space for inodes.
	 */
	sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
	    density, INOPB(&sblock));
	while (sblock.fs_ipg > MAXIPG(&sblock)) {
		inodecramped = 1;
		sblock.fs_cpg -= mincpc;
		sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
		    density, INOPB(&sblock));
	}
	/*
	 * Must ensure there is enough space to hold block map.
	 */
	if (CGSIZE(&sblock) > sblock.fs_bsize && secpercyl > 1024 && ntracks > 1) {
		secpercyl /= 2;
		ntracks /= 2;
		goto recalc;
	}
	while (CGSIZE(&sblock) > sblock.fs_bsize) {
		mapcramped = 1;
		sblock.fs_cpg -= mincpc;
		sblock.fs_ipg = roundup(((int64_t)sblock.fs_cpg * bpcg - used) /
		    density, INOPB(&sblock));
	}
	sblock.fs_fpg = (sblock.fs_cpg * sblock.fs_spc) / NSPF(&sblock);
	if ((sblock.fs_cpg * sblock.fs_spc) % NSPB(&sblock) != 0) {
		errx(24, "panic (fs_cpg * fs_spc) %% NSPF != 0");
	}
	if (sblock.fs_cpg < mincpg) {
		errx(25, "cylinder groups must have at least %ld cylinders",
			mincpg);
	} else if (cpgflg && sblock.fs_cpg != cpg) {
		if (!mapcramped && !inodecramped)
			errx(26, "!mapcramped && !inodecramped");
		if (mapcramped && inodecramped)
			printf("Block size and bytes per inode restrict");
		else if (mapcramped)
			printf("Block size restricts");
		else
			printf("Bytes per inode restrict");
		printf(" cylinders per group to %d.\n", sblock.fs_cpg);
		if (cpgflg)
			exit(27);
	}
	sblock.fs_cgsize = fragroundup(&sblock, CGSIZE(&sblock));
d369 3
a371 2
	 * Now have size for file system and nsect and ntrak.
	 * Determine number of cylinders and blocks in the file system.
d373 20
a392 10
	sblock.fs_ffs1_size = dbtofsb(&sblock, fssize);
	sblock.fs_ncyl = sblock.fs_ffs1_size * NSPF(&sblock) / sblock.fs_spc;
	if (sblock.fs_ffs1_size * NSPF(&sblock) > sblock.fs_ncyl * sblock.fs_spc) {
		sblock.fs_ncyl++;
		warn = 1;
	}
	if (sblock.fs_ncyl < 1) {
		errx(28,
		    "file systems must have at least one cylinder (not %d)",
		     sblock.fs_ncyl);
d394 1
d396 22
a417 20
	 * Determine feasability/values of rotational layout tables.
	 *
	 * The size of the rotational layout tables is limited by the
	 * size of the superblock, SBSIZE. The amount of space available
	 * for tables is calculated as (SBSIZE - sizeof (struct fs)).
	 * The size of these tables is inversely proportional to the block
	 * size of the file system. The size increases if sectors per track
	 * are not powers of two, because more cylinders must be described
	 * by the tables before the rotational pattern repeats (fs_cpc).
	 */
	sblock.fs_interleave = 1;
	sblock.fs_trackskew = 0;
	sblock.fs_npsect = sblock.fs_nsect;
	sblock.fs_postblformat = FS_DYNAMICPOSTBLFMT;
	sblock.fs_sbsize = fragroundup(&sblock, sizeof(struct fs));
	if (sblock.fs_sbsize > SBSIZE)
		sblock.fs_sbsize = SBSIZE;
	if (sblock.fs_ntrak == 1) {
		sblock.fs_cpc = 0;
		goto next;
d419 13
a431 17
	postblsize = sblock.fs_nrpos * sblock.fs_cpc * sizeof(int16_t);
	rotblsize = sblock.fs_cpc * sblock.fs_spc / NSPB(&sblock);
	totalsbsize = sizeof(struct fs) + rotblsize;
	/* use dynamic table space */
	sblock.fs_postbloff = &sblock.fs_space[0] -
	    (u_char *)(&sblock.fs_firstfield);
	sblock.fs_rotbloff = sblock.fs_postbloff + postblsize;
	totalsbsize += postblsize;
	if (totalsbsize > SBSIZE || fragroundup(&sblock, totalsbsize) > SBSIZE
	    || sblock.fs_nsect > (1 << NBBY) * NSPB(&sblock)) {
		printf("%s %s %d %s %d.%s",
		    "Warning: insufficient space in super block for\n",
		    "rotational layout tables with nsect", sblock.fs_nsect,
		    "and ntrak", sblock.fs_ntrak,
		    "\nFile system performance may be impaired.\n");
		sblock.fs_cpc = 0;
		goto next;
d433 1
a433 8
	sblock.fs_sbsize = fragroundup(&sblock, totalsbsize);
next:
	/*
	 * Compute/validate number of cylinder groups.
	 */
	sblock.fs_ncg = sblock.fs_ncyl / sblock.fs_cpg;
	if (sblock.fs_ncyl % sblock.fs_cpg)
		sblock.fs_ncg++;
d435 1
a435 38
	i = MIN(~sblock.fs_cgmask, sblock.fs_ncg - 1);
	if (cgdmin(&sblock, i) - cgbase(&sblock, i) >= sblock.fs_fpg) {
		printf("inode blocks/cyl group (%ld) >= data blocks (%d)\n",
		    cgdmin(&sblock, i) - cgbase(&sblock, i) / sblock.fs_frag,
		    sblock.fs_fpg / sblock.fs_frag);
		printf("number of cylinders per cylinder group (%d) %s.\n",
		    sblock.fs_cpg, "must be increased");
		exit(29);
	}
	j = sblock.fs_ncg - 1;
	if ((i = sblock.fs_ffs1_size - j * sblock.fs_fpg) < sblock.fs_fpg &&
	    cgdmin(&sblock, j) - cgbase(&sblock, j) > i) {
		if (j == 0) {
			errx(30, "filesystem must have at least %d sectors",
			     NSPF(&sblock) *
			    (cgdmin(&sblock, 0) + 3 * sblock.fs_frag));
		}
		printf("Warning: inode blocks/cyl group (%ld) >= data blocks (%ld) in last\n",
		    (cgdmin(&sblock, j) - cgbase(&sblock, j)) / sblock.fs_frag,
		    i / sblock.fs_frag);
		printf("    cylinder group. This implies %ld sector(s) cannot be allocated.\n",
		    i * NSPF(&sblock));
		sblock.fs_ncg--;
		sblock.fs_ncyl -= sblock.fs_ncyl % sblock.fs_cpg;
		sblock.fs_ffs1_size = sblock.fs_ncyl * sblock.fs_spc / NSPF(&sblock);
		fssize = fsbtodb(&sblock, sblock.fs_ffs1_size);
		warn = 0;
	}
	if (!quiet && warn && !mfs) {
		printf("Warning: %d sector(s) in last cylinder unallocated\n",
		    sblock.fs_spc -
		    (dbtofsb(&sblock, fssize) * NSPF(&sblock) -
		    (sblock.fs_ncyl - 1) * sblock.fs_spc));
	}
	/*
	 * fill in remaining fields of the super block
	 */
	sblock.fs_ffs1_csaddr = cgdmin(&sblock, 0);
d439 8
a446 13
	/*
	 * The superblock fields 'fs_csmask' and 'fs_csshift' are no
	 * longer used. However, we still initialise them so that the
	 * filesystem remains compatible with old kernels.
	 */
	i = sblock.fs_bsize / sizeof(struct csum);
	sblock.fs_csmask = ~(i - 1);
	for (sblock.fs_csshift = 0; i > 1; i >>= 1)
		sblock.fs_csshift++;
	if ((fscs = calloc(1, sblock.fs_cssize)) == NULL)
		err(1, "cg summary");
	sblock.fs_magic = FS_MAGIC;
	sblock.fs_rotdelay = 0;
a447 1
	sblock.fs_maxcontig = maxcontig;
a448 1
	sblock.fs_rps = 3600 / 60;
d451 2
a452 4
	sblock.fs_ffs1_cstotal.cs_ndir = 0;
	sblock.fs_ffs1_cstotal.cs_nbfree = 0;
	sblock.fs_ffs1_cstotal.cs_nifree = 0;
	sblock.fs_ffs1_cstotal.cs_nffree = 0;
d455 2
a456 1
	sblock.fs_clean = FS_ISCLEAN;
d459 26
a489 3
		printf("%s:\t%d sectors in %d %s of %d tracks, %d sectors\n",
		    fsys, sblock.fs_ffs1_size * NSPF(&sblock), sblock.fs_ncyl,
		    "cylinders", sblock.fs_ntrak, sblock.fs_nsect);
d491 5
a495 3
		printf("\t%.1fMB in %d cyl groups (%d c/g, %.2fMB/g, %d i/g)\n",
		    (float)sblock.fs_ffs1_size * sblock.fs_fsize * B2MBFACTOR,
		    sblock.fs_ncg, sblock.fs_cpg,
d497 1
a497 1
		    sblock.fs_ipg);
d500 23
d537 16
d575 1
a575 2
	 * Now construct the initial file system,
	 * then write out the super-block.
d577 14
a590 7
	if (fsinit(utime, mfsmode, mfsuid, mfsgid) != 0)
		errx(32, "fsinit failed");
	sblock.fs_ffs1_time = utime;
	/* don't write magic until we are done */
	sblock.fs_magic = 0;
	wtfs((int)SBOFF / sectorsize, sbsize, (char *)&sblock);
	sblock.fs_magic = FS_MAGIC;
d592 5
a596 12
		wtfs(fsbtodb(&sblock, sblock.fs_ffs1_csaddr + numfrags(&sblock, i)),
			sblock.fs_cssize - i < sblock.fs_bsize ?
			    sblock.fs_cssize - i : sblock.fs_bsize,
			((char *)fscs) + i);
	/*
	 * Write out the duplicate super blocks
	 */
	for (cylno = 0; cylno < sblock.fs_ncg; cylno++)
		wtfs(fsbtodb(&sblock, cgsblock(&sblock, cylno)),
		    sbsize, (char *)&sblock);
	/* done, can write with magic now */
	wtfs((int)SBOFF / sectorsize, sbsize, (char *)&sblock);
d598 2
a599 2
	 * Update information about this partion in pack
	 * label, to that it may be updated on disk.
d613 4
a616 2
	daddr_t cbase, d, dlower, dupper, dmax, blkno;
	long i, j;
d620 2
a621 3
	 * Determine block bounds for cylinder group.
	 * Allow space for super block summary information in first
	 * cylinder group.
d625 2
a626 2
	if (dmax > sblock.fs_ffs1_size)
		dmax = sblock.fs_ffs1_size;
d631 1
a631 1
	cs = fscs + cylno;
d633 1
a633 1
	acg.cg_time = utime;
d636 3
a638 5
	if (cylno == sblock.fs_ncg - 1)
		acg.cg_ncyl = sblock.fs_ncyl % sblock.fs_cpg;
	else
		acg.cg_ncyl = sblock.fs_cpg;
	acg.cg_niblk = sblock.fs_ipg;
d640 17
a656 10
	if (sblock.fs_contigsumsize > 0)
		acg.cg_nclusterblks = acg.cg_ndblk / sblock.fs_frag;
	acg.cg_btotoff = &acg.cg_space[0] - (u_char *)(&acg.cg_firstfield);
	acg.cg_boff = acg.cg_btotoff + sblock.fs_cpg * sizeof(int32_t);
	acg.cg_iusedoff = acg.cg_boff +
		sblock.fs_cpg * sblock.fs_nrpos * sizeof(int16_t);
	acg.cg_freeoff = acg.cg_iusedoff + howmany(sblock.fs_ipg, NBBY);
	if (sblock.fs_contigsumsize <= 0) {
		acg.cg_nextfreeoff = acg.cg_freeoff +
		   howmany(sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY);
d658 1
a658 9
		acg.cg_clustersumoff = acg.cg_freeoff + howmany
		    (sblock.fs_cpg * sblock.fs_spc / NSPF(&sblock), NBBY) -
		    sizeof(int32_t);
		acg.cg_clustersumoff =
		    roundup(acg.cg_clustersumoff, sizeof(int32_t));
		acg.cg_clusteroff = acg.cg_clustersumoff +
		    (sblock.fs_contigsumsize + 1) * sizeof(int32_t);
		acg.cg_nextfreeoff = acg.cg_clusteroff + howmany
		    (sblock.fs_cpg * sblock.fs_spc / NSPB(&sblock), NBBY);
d660 3
d664 2
a665 1
		errx(37, "panic: cylinder group too big");
d667 1
a667 1
	if (cylno == 0)
a671 5
	for (i = 0; i < sblock.fs_ipg / INOPF(&sblock); i += sblock.fs_frag) {
		for (j = 0; j < sblock.fs_bsize / sizeof(struct ufs1_dinode); j++)
			zino[j].di_gen = (u_int32_t)arc4random();
		wtfs(fsbtodb(&sblock, cgimin(&sblock, cylno) + i),
		    sblock.fs_bsize, (char *)zino);
d675 1
a675 2
		 * In cylno 0, beginning space is reserved
		 * for boot and super blocks.
a679 2
			if (sblock.fs_contigsumsize > 0)
				setbit(cg_clustersfree(&acg), blkno);
d681 5
a685 3
			cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
			cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
			    [cbtorpos(&sblock, d)]++;
a686 1
		sblock.fs_ffs1_dsize += dlower;
a687 1
	sblock.fs_ffs1_dsize += acg.cg_ndblk - dupper;
d695 3
a697 1
	for (d = dupper; d + sblock.fs_frag <= dmax - cbase; ) {
a699 2
		if (sblock.fs_contigsumsize > 0)
			setbit(cg_clustersfree(&acg), blkno);
d701 5
a705 4
		cg_blktot(&acg)[cbtocylno(&sblock, d)]++;
		cg_blks(&sblock, &acg, cbtocylno(&sblock, d))
		    [cbtorpos(&sblock, d)]++;
		d += sblock.fs_frag;
d707 3
a709 3
	if (d < dmax - cbase) {
		acg.cg_frsum[dmax - cbase - d]++;
		for (; d < dmax - cbase; d++) {
d714 33
a746 15
	if (sblock.fs_contigsumsize > 0) {
		int32_t *sump = cg_clustersum(&acg);
		u_char *mapp = cg_clustersfree(&acg);
		int map = *mapp++;
		int bit = 1;
		int run = 0;

		for (i = 0; i < acg.cg_nclusterblks; i++) {
			if ((map & bit) != 0) {
				run++;
			} else if (run != 0) {
				if (run > sblock.fs_contigsumsize)
					run = sblock.fs_contigsumsize;
				sump[run]++;
				run = 0;
d748 2
a749 11
			if ((i & (NBBY - 1)) != (NBBY - 1)) {
				bit <<= 1;
			} else {
				map = *mapp++;
				bit = 1;
			}
		}
		if (run != 0) {
			if (run > sblock.fs_contigsumsize)
				run = sblock.fs_contigsumsize;
			sump[run]++;
a751 7
	sblock.fs_ffs1_cstotal.cs_ndir += acg.cg_cs.cs_ndir;
	sblock.fs_ffs1_cstotal.cs_nffree += acg.cg_cs.cs_nffree;
	sblock.fs_ffs1_cstotal.cs_nbfree += acg.cg_cs.cs_nbfree;
	sblock.fs_ffs1_cstotal.cs_nifree += acg.cg_cs.cs_nifree;
	*cs = acg.cg_cs;
	wtfs(fsbtodb(&sblock, cgtod(&sblock, cylno)),
	    sblock.fs_bsize, (char *)&acg);
a753 5
/*
 * initialize the file system
 */
struct ufs1_dinode node;

d771 1
a771 1
fsinit(time_t utime, mode_t mfsmode, uid_t mfsuid, gid_t mfsgid)
d773 2
d776 1
a776 1
	 * initialize the node
d778 5
a782 3
	node.di_atime = utime;
	node.di_mtime = utime;
	node.di_ctime = utime;
d784 1
a784 1
	 * create the root directory
d787 3
a789 3
		node.di_mode = IFDIR | mfsmode;
		node.di_uid = mfsuid;
		node.di_gid = mfsgid;
d791 8
a798 7
		node.di_mode = IFDIR | UMASK;
		node.di_uid = geteuid();
		node.di_gid = getegid();
	}
	node.di_nlink = PREDEFDIR;
	if (Oflag)
		node.di_size = makedir((struct direct *)oroot_dir, PREDEFDIR);
d800 55
a854 2
		node.di_size = makedir(root_dir, PREDEFDIR);
	if ((node.di_db[0] = alloc(sblock.fs_fsize, node.di_mode)) == 0)
d856 4
a859 2
	node.di_blocks = btodb(fragroundup(&sblock, node.di_size));
	wtfs(fsbtodb(&sblock, node.di_db[0]), sblock.fs_fsize, buf);
d861 19
d894 1
a894 1
	for (cp = buf, i = 0; i < entries - 1; i++) {
d917 1
a917 1
		printf("cg 0: bad magic number\n");
d921 1
a921 1
		printf("first cylinder group ran out of space\n");
d927 1
a927 1
	printf("internal error: can't find block in cyl 0\n");
a931 2
	if (sblock.fs_contigsumsize > 0)
		clrbit(cg_clustersfree(&acg), blkno);
d933 1
a933 1
	sblock.fs_ffs1_cstotal.cs_nbfree--;
d937 1
a937 1
		sblock.fs_ffs1_cstotal.cs_ndir++;
d940 5
a944 2
	cg_blktot(&acg)[cbtocylno(&sblock, d)]--;
	cg_blks(&sblock, &acg, cbtocylno(&sblock, d))[cbtorpos(&sblock, d)]--;
d948 1
a948 1
		sblock.fs_ffs1_cstotal.cs_nffree += sblock.fs_frag - frag;
d963 1
a963 1
iput(struct ufs1_dinode *ip, ino_t ino)
d965 6
a970 2
	struct ufs1_dinode buf[MAXINOPB];
	daddr_t d;
a971 1
	ip->di_gen = (u_int32_t)arc4random();
d974 3
a976 4
	if (acg.cg_magic != CG_MAGIC) {
		errx(41, "cg 0: bad magic number (0x%06x != 0x%06x)",
		     acg.cg_magic, CG_MAGIC);
	}
d979 1
d982 2
a983 1
	sblock.fs_ffs1_cstotal.cs_nifree--;
d985 1
a985 1
	if (ino >= sblock.fs_ipg * sblock.fs_ncg) {
a986 1
	}
d988 10
a997 3
	rdfs(d, sblock.fs_bsize, buf);
	buf[ino_to_fsbo(&sblock, ino)] = *ip;
	wtfs(d, sblock.fs_bsize, buf);
d1062 1
a1062 1
		fprintf(stderr, "isblock bad fs_frag %d\n", fs->fs_frag);
d1091 1
a1091 1
		fprintf(stderr, "clrblock bad fs_frag %d\n", fs->fs_frag);
d1120 1
a1120 1
		fprintf(stderr, "setblock bad fs_frag %d\n", fs->fs_frag);
d1145 12
@


1.53
log
@Minor cleanup: remove rcsids, remove #ifdef'd out code, COMPAT is
the default, quiet gcc.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.52 2007/04/02 20:20:39 millert Exp $	*/
a76 3
extern int	rpm;		/* revolutions/minute of drive */
extern int	interleave;	/* hardware sector interleave */
extern int	trackskew;	/* sector 0 skew, per track */
a84 1
extern int	rotdelay;	/* rotational delay between blocks */
d480 2
a481 2
	sblock.fs_interleave = interleave;
	sblock.fs_trackskew = trackskew;
d571 1
a571 1
	sblock.fs_rotdelay = rotdelay;
d575 1
a575 1
	sblock.fs_rps = rpm / 60;
@


1.52
log
@Modern disks do bad sector replacement themselves.  There is no
need to reserve space for them in the filesystem itself.
OK deraadt@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.51 2007/03/19 13:27:47 pedro Exp $	*/
a32 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)mkfs.c	8.3 (Berkeley) 2/3/94";
#else
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.51 2007/03/19 13:27:47 pedro Exp $";
#endif
#endif /* not lint */

a53 4
 * make file system for cylinder-group style file systems
 */

/*
a66 11
 * For each cylinder we keep track of the availability of blocks at different
 * rotational positions, so that we can lay out the data to be picked
 * up with minimum rotational latency. NRPOS is the default number of
 * rotational positions that we distinguish. With NRPOS of 8 the resolution
 * of our summary information is 2ms for a typical 3600 rpm drive. Caching
 * and zoning pretty much defeats rotational optimization, so we now use a
 * default of 1.
 */
#define	NRPOS		1	/* number distinct rotational positions */

/*
d265 1
a265 1
	sblock.fs_nrpos = NRPOS;
a830 3
#ifdef LOSTDIR
#define PREDEFDIR 3
#else
a831 1
#endif
a835 3
#ifdef LOSTDIR
	{ LOSTFOUNDINO, sizeof(struct direct), DT_DIR, 10, "lost+found" },
#endif
a844 3
#ifdef LOSTDIR
	{ LOSTFOUNDINO, sizeof(struct direct), 10, "lost+found" },
#endif
a845 12
#ifdef LOSTDIR
struct direct lost_found_dir[] = {
	{ LOSTFOUNDINO, sizeof(struct direct), DT_DIR, 1, "." },
	{ ROOTINO, sizeof(struct direct), DT_DIR, 2, ".." },
	{ 0, DIRBLKSIZ, 0, 0, 0 },
};
struct odirect olost_found_dir[] = {
	{ LOSTFOUNDINO, sizeof(struct direct), 1, "." },
	{ ROOTINO, sizeof(struct direct), 2, ".." },
	{ 0, DIRBLKSIZ, 0, 0 },
};
#endif
a855 28
#ifdef LOSTDIR
	/*
	 * create the lost+found directory
	 */
	if (Oflag) {
		int i;

		(void)makedir((struct direct *)olost_found_dir, 2);
		for (i = DIRBLKSIZ; i < sblock.fs_bsize; i += DIRBLKSIZ)
			memcpy(&buf[i], &olost_found_dir[2],
			    DIRSIZ(0, &olost_found_dir[2]));
	} else {
		int i;

		(void)makedir(lost_found_dir, 2);
		for (i = DIRBLKSIZ; i < sblock.fs_bsize; i += DIRBLKSIZ)
			memcpy(&buf[i], &lost_found_dir[2],
			    DIRSIZ(0, &lost_found_dir[2]));
	}
	node.di_mode = IFDIR | 1700;
	node.di_nlink = 2;
	node.di_size = sblock.fs_bsize;
	if ((node.di_db[0] = alloc(node.di_size, node.di_mode)) == 0)
		return (1);
	node.di_blocks = btodb(fragroundup(&sblock, node.di_size));
	wtfs(fsbtodb(&sblock, node.di_db[0]), node.di_size, buf);
	iput(&node, LOSTFOUNDINO);
#endif
@


1.51
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.50 2006/03/09 13:35:02 pedro Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.50 2006/03/09 13:35:02 pedro Exp $";
a97 1
extern int	nphyssectors;	/* # sectors/track including spares */
d509 1
a509 1
	sblock.fs_npsect = nphyssectors;
@


1.50
log
@Remove option -n from newfs as well as all references to fs_postbl()
Various testing for a while, okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.49 2005/12/19 15:18:01 pedro Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.49 2005/12/19 15:18:01 pedro Exp $";
d486 3
a488 3
	sblock.fs_size = dbtofsb(&sblock, fssize);
	sblock.fs_ncyl = sblock.fs_size * NSPF(&sblock) / sblock.fs_spc;
	if (sblock.fs_size * NSPF(&sblock) > sblock.fs_ncyl * sblock.fs_spc) {
d556 1
a556 1
	if ((i = sblock.fs_size - j * sblock.fs_fpg) < sblock.fs_fpg &&
d570 2
a571 2
		sblock.fs_size = sblock.fs_ncyl * sblock.fs_spc / NSPF(&sblock);
		fssize = fsbtodb(&sblock, sblock.fs_size);
d583 1
a583 1
	sblock.fs_csaddr = cgdmin(&sblock, 0);
d606 4
a609 4
	sblock.fs_cstotal.cs_ndir = 0;
	sblock.fs_cstotal.cs_nbfree = 0;
	sblock.fs_cstotal.cs_nifree = 0;
	sblock.fs_cstotal.cs_nffree = 0;
d621 1
a621 1
		    fsys, sblock.fs_size * NSPF(&sblock), sblock.fs_ncyl,
d625 1
a625 1
		    (float)sblock.fs_size * sblock.fs_fsize * B2MBFACTOR,
d672 1
a672 1
	sblock.fs_time = utime;
d678 1
a678 1
		wtfs(fsbtodb(&sblock, sblock.fs_csaddr + numfrags(&sblock, i)),
d717 2
a718 2
	if (dmax > sblock.fs_size)
		dmax = sblock.fs_size;
d784 1
a784 1
		sblock.fs_dsize += dlower;
d786 1
a786 1
	sblock.fs_dsize += acg.cg_ndblk - dupper;
d841 4
a844 4
	sblock.fs_cstotal.cs_ndir += acg.cg_cs.cs_ndir;
	sblock.fs_cstotal.cs_nffree += acg.cg_cs.cs_nffree;
	sblock.fs_cstotal.cs_nbfree += acg.cg_cs.cs_nbfree;
	sblock.fs_cstotal.cs_nifree += acg.cg_cs.cs_nifree;
d1007 1
a1007 1
	sblock.fs_cstotal.cs_nbfree--;
d1011 1
a1011 1
		sblock.fs_cstotal.cs_ndir++;
d1019 1
a1019 1
		sblock.fs_cstotal.cs_nffree += sblock.fs_frag - frag;
d1050 1
a1050 1
	sblock.fs_cstotal.cs_nifree--;
@


1.49
log
@Add and use a few more constants and macros needed by UFS2
No functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.48 2005/08/08 20:27:22 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.48 2005/08/08 20:27:22 otto Exp $";
d79 11
a113 1
extern int	nrpos;		/* # of distinguished rotational positions */
d176 1
a176 1
	long cylno, rpos, blk, j, warn = 0;
d289 1
a289 1
	sblock.fs_nrpos = nrpos;
d522 5
a526 13
	if (sblock.fs_nrpos == 8 && sblock.fs_cpc <= 16) {
		/* use old static table space */
		sblock.fs_postbloff = (char *)(&sblock.fs_opostbl[0][0]) -
		    (char *)(&sblock.fs_firstfield);
		sblock.fs_rotbloff = &sblock.fs_space[0] -
		    (u_char *)(&sblock.fs_firstfield);
	} else {
		/* use dynamic table space */
		sblock.fs_postbloff = &sblock.fs_space[0] -
		    (u_char *)(&sblock.fs_firstfield);
		sblock.fs_rotbloff = sblock.fs_postbloff + postblsize;
		totalsbsize += postblsize;
	}
a537 18
	/*
	 * calculate the available blocks for each rotational position
	 */
	for (cylno = 0; cylno < sblock.fs_cpc; cylno++)
		for (rpos = 0; rpos < sblock.fs_nrpos; rpos++)
			fs_postbl(&sblock, cylno)[rpos] = -1;
	for (i = (rotblsize - 1) * sblock.fs_frag;
	     i >= 0; i -= sblock.fs_frag) {
		cylno = cbtocylno(&sblock, i);
		rpos = cbtorpos(&sblock, i);
		blk = fragstoblks(&sblock, i);
		if (fs_postbl(&sblock, cylno)[rpos] == -1)
			fs_rotbl(&sblock)[blk] = 0;
		else
			fs_rotbl(&sblock)[blk] =
			    fs_postbl(&sblock, cylno)[rpos] - blk;
		fs_postbl(&sblock, cylno)[rpos] = blk;
	}
@


1.48
log
@More informative error message when trying to create a filesystem
larger than 1TB. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.47 2005/04/14 19:58:32 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.47 2005/04/14 19:58:32 deraadt Exp $";
d204 1
a204 1
		sblock.fs_maxsymlinklen = MAXSYMLINKLEN;
@


1.47
log
@handle snprintf out of range conditions; otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.46 2005/01/06 08:57:30 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.46 2005/01/06 08:57:30 otto Exp $";
d211 1
a211 1
		errx(13, "preposterous size %d", fssize);
@


1.46
log
@validate mfs size to avoid wrapping. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.45 2004/10/14 07:40:29 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.45 2004/10/14 07:40:29 otto Exp $";
d668 3
a670 1
		if (i+j >= width) {
@


1.45
log
@Do not generate either a too large super block or a negative number
of inodes per cylinder group for large block or fragment sizes.
This allows for creation of filesystems with any legal block/fragment
size combination.

ok tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.44 2004/09/10 19:49:15 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.44 2004/09/10 19:49:15 otto Exp $";
d186 6
a191 1
		membase = mmap(NULL, fssize * sectorsize, PROT_READ|PROT_WRITE,
d195 1
a195 1
		madvise(membase, fssize * sectorsize, MADV_RANDOM);
@


1.44
log
@Bail out on errors when making very small filesystems. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.43 2004/08/12 07:53:50 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.43 2004/08/12 07:53:50 otto Exp $";
d359 2
a360 1
	inospercg = roundup((mincpg * bpcg - used) / density, INOPB(&sblock));
d380 2
a381 2
		inospercg =
		    roundup((mincpg * bpcg - used) / density, INOPB(&sblock));
d424 2
a425 2
	sblock.fs_ipg = roundup((sblock.fs_cpg * bpcg - used) / density,
		INOPB(&sblock));
d429 2
a430 2
		sblock.fs_ipg = roundup((sblock.fs_cpg * bpcg - used) / density,
			INOPB(&sblock));
d443 2
a444 2
		sblock.fs_ipg = roundup((sblock.fs_cpg * bpcg - used) / density,
			INOPB(&sblock));
d498 2
d520 2
a521 2
	if (totalsbsize > SBSIZE ||
	    sblock.fs_nsect > (1 << NBBY) * NSPB(&sblock)) {
@


1.43
log
@Prevent core dump on large block sizes by checking block size against
MAXBSIZE.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.42 2004/07/06 07:31:59 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.42 2004/07/06 07:31:59 otto Exp $";
d134 1
a134 1
void		fsinit(time_t, mode_t, uid_t, gid_t);
d676 2
a677 1
	fsinit(utime, mfsmode, mfsuid, mfsgid);
d899 1
a899 1
void
d930 2
a931 1
	node.di_db[0] = alloc(node.di_size, node.di_mode);
d953 2
a954 1
	node.di_db[0] = alloc(sblock.fs_fsize, node.di_mode);
d958 1
@


1.42
log
@delint: offset arg to mmap is off_t and remove dead code

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.41 2004/06/26 18:21:35 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.41 2004/06/26 18:21:35 otto Exp $";
d249 4
@


1.41
log
@For all the mfs lovers:

- Make the root of an mfs file system inherit the permission and
  owner/group of the mountpoint. Work by david@@.
- Add the ability to populate an mfs file system with the contents of a
  directory or a file system immediately after creation, controlled
  by the new -P mount option.

Discussed with and tested by many, ok djm@@ david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.40 2004/06/22 01:58:59 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.40 2004/06/22 01:58:59 millert Exp $";
d187 1
a187 1
		    MAP_ANON|MAP_PRIVATE, -1, 0);
a1035 1
	int c;
a1037 1
	c = ino_to_cg(&sblock, ino);
@


1.40
log
@acg.cg_nextfreeoff is already relative to &acg so don't subtract
&acg.cg_firstfield.  Fixes a bogus "panic: cylinder group too big" I
see sometimes when using mmap malloc.  OK tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.39 2004/05/13 22:36:39 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.39 2004/05/13 22:36:39 mickey Exp $";
d50 1
d134 1
a134 1
void		fsinit(time_t);
d141 2
a142 1
void		mkfs(struct partition *pp, char *fsys, int fi, int fo);
d162 2
a163 1
mkfs(struct partition *pp, char *fsys, int fi, int fo)
d672 1
a672 1
	fsinit(utime);
d895 1
a895 1
fsinit(time_t utime)
d933 5
a937 3
	if (mfs)
		node.di_mode = IFDIR | 01777;
	else
d939 3
@


1.39
log
@provide a siginfo handler for -q run; idea from art's todo; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.38 2004/01/13 01:42:08 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.38 2004/01/13 01:42:08 tedu Exp $";
d753 1
a753 1
	if (acg.cg_nextfreeoff - (long)(&acg.cg_firstfield) > sblock.fs_cgsize) {
a754 1
	}
@


1.38
log
@quiet warnings.  better diff suggested by tom@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.37 2003/12/05 00:40:29 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.37 2003/12/05 00:40:29 mickey Exp $";
d57 1
d142 17
d638 6
d647 1
@


1.37
log
@madvise() the mfs storage area as randomly accessed as mfs does it's own clustering; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.36 2003/11/06 08:53:58 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.36 2003/11/06 08:53:58 tedu Exp $";
d387 4
a390 2
		printf("%s groups must have a multiple of %ld cylinders\n",
			cpgflg ? "Cylinder" : "Warning: cylinder", mincpc);
d557 1
a557 1
	if (warn && !mfs) {
@


1.36
log
@don't write magic until the file system is really done.  prevents
fsck/mount unhappiness.  hint from freebsd-arch ml.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.35 2003/11/03 05:40:09 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.35 2003/11/03 05:40:09 tedu Exp $";
d169 1
@


1.35
log
@NULL for NULL pointers, not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.34 2003/11/03 05:36:27 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.34 2003/11/03 05:36:27 tedu Exp $";
d643 2
d646 1
d658 2
@


1.34
log
@combine ugly printf(), exit() combo statements into err() or errx().
mostly from tom cosgrove.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.33 2003/08/25 23:28:15 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.33 2003/08/25 23:28:15 tedu Exp $";
d154 4
a157 4
	if ((fsun = (union fs_u *)calloc(1, sizeof (union fs_u))) == 0 ||
	    (cgun = (union cg_u *)calloc(1, sizeof (union cg_u))) == 0 ||
	    (zino = (struct ufs1_dinode *)calloc(1, MAXBSIZE)) == 0 ||
	    (buf = (char *)calloc(1, MAXBSIZE)) == 0) {
d576 1
a576 1
	if ((fscs = (struct csum *)calloc(1, sblock.fs_cssize)) == 0) {
a577 1
	}
@


1.33
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.32 2003/07/16 18:02:35 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.32 2003/07/16 18:02:35 tedu Exp $";
d158 1
a158 2
		printf("buffer malloc failed\n");
		exit(1);
d168 1
a168 1
			exit(12);
d184 1
a184 1
		printf("preposterous size %d\n", fssize), exit(13);
d193 1
a193 1
		printf("preposterous ntrak %d\n", sblock.fs_ntrak), exit(14);
d195 1
a195 1
		printf("preposterous nsect %d\n", sblock.fs_nsect), exit(15);
d202 2
a203 2
		printf("illegal expected average file size %d\n",
		    sblock.fs_avgfilesize), exit(14);
d205 2
a206 2
		printf("illegal expected number of files per directory %d\n",
		    sblock.fs_avgfpdir), exit(15);
d213 2
a214 3
		printf("block size must be a power of 2, not %d\n",
		    sblock.fs_bsize);
		exit(16);
d217 2
a218 3
		printf("fragment size must be a power of 2, not %d\n",
		    sblock.fs_fsize);
		exit(17);
d221 2
a222 3
		printf("fragment size %d is too small, minimum is %d\n",
		    sblock.fs_fsize, sectorsize);
		exit(18);
d225 2
a226 3
		printf("block size %d is too small, minimum is %d\n",
		    sblock.fs_bsize, MINBSIZE);
		exit(19);
d229 2
a230 3
		printf("block size (%d) cannot be smaller than fragment size (%d)\n",
		    sblock.fs_bsize, sblock.fs_fsize);
		exit(20);
d244 1
a244 1
		printf("fragment size %d is too small, minimum with block size %d is %d\n",
a246 1
		exit(21);
d321 1
a321 3
			printf("There is no block size that");
			printf(" can support this disk\n");
			exit(22);
d419 1
a419 2
		printf("panic (fs_cpg * fs_spc) %% NSPF != 0");
		exit(24);
d422 1
a422 1
		printf("cylinder groups must have at least %ld cylinders\n",
a423 1
		exit(25);
d426 1
a426 1
			exit(26);
d449 3
a451 2
		printf("file systems must have at least one cylinder\n");
		exit(28);
d539 2
a540 2
			printf("Filesystem must have at least %d sectors\n",
			    NSPF(&sblock) *
a541 1
			exit(30);
d577 1
a577 2
		printf("cg summary malloc failed\n");
		exit(1);
d722 1
a722 2
		printf("Panic: cylinder group too big\n");
		exit(37);
d1004 2
a1005 2
		printf("cg 0: bad magic number\n");
		exit(31);
d1014 1
a1014 2
		printf("fsinit: inode value out of range (%d).\n", ino);
		exit(32);
d1036 1
a1036 3
		printf("read error: %d\n", bno);
		perror("rdfs");
		exit(34);
d1056 1
a1056 3
		printf("write error: %d\n", bno);
		perror("wtfs");
		exit(36);
@


1.32
log
@remove default limit of 16 cylinders per group.  it's now set to
as many as fit with the other parameters given.
change default frag size to 2048, bumping block size to 16k.
from freebsd.

ok deraadt@@ and co.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.31 2003/07/02 21:44:58 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.31 2003/07/02 21:44:58 deraadt Exp $";
d73 1
a73 1
#define MAXINOPB	(MAXBSIZE / sizeof(struct dinode))
d123 1
a123 1
struct dinode *zino;
d134 1
a134 1
void		iput(struct dinode *, ino_t);
d156 1
a156 1
	    (zino = (struct dinode *)calloc(1, MAXBSIZE)) == 0 ||
d257 1
a257 1
	sblock.fs_inopb = sblock.fs_bsize / sizeof(struct dinode);
d288 1
a288 1
	inospercg = roundup(bpcg / sizeof(struct dinode), INOPB(&sblock));
d744 1
a744 1
		for (j = 0; j < sblock.fs_bsize / sizeof(struct dinode); j++)
d833 1
a833 1
struct dinode node;
d1006 1
a1006 1
iput(struct dinode *ip, ino_t ino)
d1008 1
a1008 1
	struct dinode buf[MAXINOPB];
@


1.31
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.30 2003/06/25 21:24:10 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.30 2003/06/25 21:24:10 deraadt Exp $";
d435 2
a436 4
	} else if (sblock.fs_cpg != cpg) {
		if (!cpgflg)
			printf("Warning: ");
		else if (!mapcramped && !inodecramped)
@


1.30
log
@proto repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.29 2003/06/11 06:22:14 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.29 2003/06/11 06:22:14 deraadt Exp $";
d139 1
a148 2
	pid_t ppid = -1;
	int status;
@


1.29
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.28 2003/06/02 20:06:16 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.28 2003/06/02 20:06:16 millert Exp $";
d129 1
a129 1
static int	charsperline();
a1178 1
	extern char *getenv();
@


1.28
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.27 2003/05/06 04:32:16 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.27 2003/05/06 04:32:16 tedu Exp $";
d141 1
a141 4
mkfs(pp, fsys, fi, fo)
	struct partition *pp;
	char *fsys;
	int fi, fo;
d685 1
a685 3
initcg(cylno, utime)
	int cylno;
	time_t utime;
d877 1
a877 2
fsinit(utime)
	time_t utime;
d935 1
a935 3
makedir(protodir, entries)
	struct direct *protodir;
	int entries;
d956 1
a956 3
alloc(size, mode)
	int size;
	int mode;
d1009 1
a1009 3
iput(ip, ino)
	struct dinode *ip;
	ino_t ino;
d1043 1
a1043 4
rdfs(bno, size, bf)
	daddr_t bno;
	int size;
	void *bf;
d1063 1
a1063 4
wtfs(bno, size, bf)
	daddr_t bno;
	int size;
	void *bf;
d1085 1
a1085 4
isblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
d1115 1
a1115 4
clrblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
d1144 1
a1144 4
setblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
d1174 1
a1174 1
charsperline()
@


1.27
log
@remove FSIRAND define and make it non-optional.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.26 2003/05/06 00:10:40 tedu Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.26 2003/05/06 00:10:40 tedu Exp $";
@


1.26
log
@after switch to mmap, we need to zero other malloc'd data.  use calloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.25 2003/05/03 17:21:04 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.25 2003/05/03 17:21:04 millert Exp $";
a615 1
#ifdef FSIRAND
d618 1
a618 1
#endif
a755 1
#ifdef FSIRAND
a757 1
#endif
a1030 1
#ifdef FSIRAND
a1031 1
#endif
@


1.25
log
@The 'memleft' calcuations assume that the data address starts at
0, which is no longer the case.  So instead of the hokey private
malloc() implementation, just use mmap.  From diffs I ran on
anoncvs.usa 4 years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.24 2003/04/16 10:33:16 markus Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.24 2003/04/16 10:33:16 markus Exp $";
d163 3
a165 3
	    (cgun = (union cg_u *)malloc(sizeof (union cg_u))) == 0 ||
	    (zino = (struct dinode *)malloc(MAXBSIZE)) == 0 ||
	    (buf = (char *)malloc(MAXBSIZE)) == 0) {
@


1.24
log
@fix race between mount(2) and exit(2) for mount_mfs.
from netbsd (drochner, newfs.c 1.30, mkfs.c 1.29, no copyright changes)
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.23 2003/02/19 00:57:14 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.23 2003/02/19 00:57:14 millert Exp $";
a46 1
#include <sys/resource.h>
d52 1
a110 1
extern u_long	memleft;	/* virtual memory available */
d174 3
a176 4
		(void)malloc(0);
		if (fssize * sectorsize > memleft)
			fssize = (memleft - 16384) / sectorsize;
		if ((membase = malloc(fssize * sectorsize)) == 0)
d1030 1
a1030 2
	struct dinode *buf =
	   (struct dinode *)malloc(MAXINOPB * sizeof (struct dinode));
a1057 79
	free(buf);
}

/*
 * Replace libc function with one suited to our needs.
 */
static void *
malloc(size)
	size_t size;
{
	void *base, *i;
	static u_long pgsz;
	struct rlimit rlp;

	if (pgsz == 0) {
		base = sbrk(0);
		pgsz = getpagesize() - 1;
		i = (char *)((u_long)(base + pgsz) &~ pgsz);
		base = sbrk(i - base);
		if (getrlimit(RLIMIT_DATA, &rlp) < 0)
			perror("getrlimit");
		rlp.rlim_cur = rlp.rlim_max;
		if (setrlimit(RLIMIT_DATA, &rlp) < 0)
			perror("setrlimit");
		memleft = rlp.rlim_max - (u_long)base;
	}
	size = (size + pgsz) &~ pgsz;
	if (size > memleft)
		size = memleft;
	memleft -= size;
	if (size == 0)
		return (0);
	return (sbrk(size));
}

/*
 * Replace libc function with one suited to our needs.
 */
static void *
realloc(ptr, size)
	void *ptr;
	size_t size;
{
	void *p;

	if ((p = malloc(size)) == NULL)
		return (NULL);
	if (ptr) {
		memcpy(p, ptr, size);
		free(ptr);
	}
	return (p);
}

/*
 * Replace libc function with one suited to our needs.
 */
static void *
calloc(size, numelm)
	size_t size;
	size_t numelm;
{
	void	*base;

	size *= numelm;
	if ((base = malloc(size)) != 0)
		memset(base, 0, size);
	return (base);
}

/*
 * Replace libc function with one suited to our needs.
 */
static void
free(ptr)
	void *ptr;
{
	
	/* do not worry about it for now */
@


1.23
log
@Use pread/pwrite where sensible; also remove some bogus casts in
printf to long and long long for things that are int32_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.22 2002/06/09 08:13:08 todd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.22 2002/06/09 08:13:08 todd Exp $";
a46 1
#include <sys/wait.h>
a55 1
#include <signal.h>
a159 1
	void started();
a174 12
		ppid = getpid();
		(void) signal(SIGUSR1, started);
		if ((i = fork())) {
			if (i == -1) {
				perror("mfs");
				exit(10);
			}
			if (waitpid(i, &status, 0) != -1 && WIFEXITED(status))
				exit(WEXITSTATUS(status));
			exit(11);
			/* NOTREACHED */
		}
a688 12
	/*
	 * Notify parent process of success.
	 * Dissociate from session and tty.
	 */
	if (mfs) {
		kill(ppid, SIGUSR1);
		(void) setsid();
		(void) close(0);
		(void) close(1);
		(void) close(2);
		(void) chdir("/");
	}
a1061 10
}

/*
 * Notify parent process that the filesystem has created itself successfully.
 */
void
started()
{

	_exit(0);
@


1.22
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.21 2002/05/29 09:19:52 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.21 2002/05/29 09:19:52 deraadt Exp $";
d374 2
a375 3
		printf("With a block size of %ld %s %ld\n",
		    (long)sblock.fs_bsize,
		    "minimum bytes per inode is",
a1188 1
	off_t offset;
d1194 1
a1194 8
	offset = bno;
	offset *= sectorsize;
	if (lseek(fsi, offset, SEEK_SET) < 0) {
		printf("seek error: %lld\n", (long long)bno);
		perror("rdfs");
		exit(33);
	}
	n = read(fsi, bf, size);
d1196 1
a1196 1
		printf("read error: %lld\n", (long long)bno);
a1211 1
	off_t offset;
d1219 1
a1219 8
	offset = bno;
	offset *= sectorsize;
	if (lseek(fso, offset, SEEK_SET) < 0) {
		printf("seek error: %lld\n", (long long)bno);
		perror("wtfs");
		exit(35);
	}
	n = write(fso, bf, size);
d1221 1
a1221 1
		printf("write error: %lld\n", (long long)bno);
@


1.21
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.20 2001/11/05 07:39:17 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.20 2001/11/05 07:39:17 mpech Exp $";
d416 1
a416 1
	/* 
d691 1
a691 1
	/* 
d759 1
a759 1
	acg.cg_iusedoff = acg.cg_boff + 
d1164 1
a1164 1
	if ((base = malloc(size)) != 0) 
@


1.20
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.19 2001/07/07 18:26:16 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.19 2001/07/07 18:26:16 deraadt Exp $";
d665 1
a665 1
		j = sprintf(tmpbuf, " %ld,",
@


1.19
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.18 2001/04/19 16:22:17 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.18 2001/04/19 16:22:17 gluk Exp $";
d153 1
a153 1
	register long i, mincpc, mincpg, inospercg;
d729 1
a729 1
	register struct csum *cs;
d1057 2
a1058 2
	register struct dinode *ip;
	register ino_t ino;
@


1.18
log
@Cleanup dirpref and synhronize superblock with freebsd.
From FreeBSD with little changes.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.17 2001/04/13 02:39:06 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.17 2001/04/13 02:39:06 gluk Exp $";
d56 2
a114 2
static caddr_t	malloc(), calloc();
static void	free();
a133 2
daddr_t	alloc();
static int charsperline();
d135 13
d158 2
a159 1
	int ppid, status;
d180 1
a180 1
		if (i = fork()) {
d374 2
a375 1
		printf("With a block size of %d %s %d\n", sblock.fs_bsize,
d394 1
a394 1
			printf("Minimum bytes per inode is %d\n",
d398 1
a398 1
			printf("minimum cylinders per group is %d\n", mincpg);
d403 1
a403 1
		printf("minimum cylinders per group is %d\n", mincpg);
d421 1
a421 1
		printf("%s groups must have a multiple of %d cylinders\n",
d454 1
a454 1
		printf("panic (fs_cpg * fs_spc) % NSPF != 0");
d458 1
a458 1
		printf("cylinder groups must have at least %d cylinders\n",
d566 1
a566 1
		printf("inode blocks/cyl group (%d) >= data blocks (%d)\n",
d582 1
a582 1
		printf("Warning: inode blocks/cyl group (%d) >= data blocks (%d) in last\n",
d585 1
a585 1
		printf("    cylinder group. This implies %d sector(s) cannot be allocated.\n",
d665 2
a666 2
		j = sprintf(tmpbuf, " %d,",
			fsbtodb(&sblock, cgsblock(&sblock, cylno)));
d722 1
d728 1
a728 1
	long i, j, s;
d812 1
a812 1
	if (i = dupper % sblock.fs_frag) {
d872 1
a872 1
		sblock.fs_bsize, (char *)&acg);
d918 1
a921 2
	int i;

d933 2
d940 2
d977 1
d979 1
a979 1
	register struct direct *protodir;
d1055 1
d1105 1
a1105 1
static caddr_t
d1107 1
a1107 1
	register u_long size;
d1109 1
a1109 1
	char *base, *i;
d1131 1
a1131 1
	return ((caddr_t)sbrk(size));
d1137 1
a1137 1
static caddr_t
d1139 2
a1140 2
	char *ptr;
	u_long size;
d1156 1
a1156 1
static char *
d1158 2
a1159 1
	u_long size, numelm;
d1161 1
a1161 1
	caddr_t base;
d1174 1
a1174 1
	char *ptr;
d1183 1
d1187 1
a1187 1
	char *bf;
d1199 1
a1199 1
		printf("seek error: %ld\n", bno);
d1205 1
a1205 1
		printf("read error: %ld\n", bno);
d1214 1
d1218 1
a1218 1
	char *bf;
d1232 1
a1232 1
		printf("seek error: %ld\n", bno);
d1238 1
a1238 1
		printf("write error: %ld\n", bno);
d1247 1
d1280 1
d1312 1
@


1.17
log
@Fix overflow in superblock. From FreeBSD.

FreeBSD's log:
> The ffs superblock includes a 128-byte region for use by temporary
> in-core pointers to summary information. An array in this region
> (fs_csp) could overflow on filesystems with a very large number of
> cylinder groups (~16000 on i386 with 8k blocks). When this happens,
> other fields in the superblock get corrupted, and fsck refuses to
> check the filesystem.
>
> Solve this problem by replacing the fs_csp array in 'struct fs'
> with a single pointer, and add padding to keep the length of the
> 128-byte region fixed. Update the kernel and userland utilities
> to use just this single pointer.
>
> With this change, the kernel no longer makes use of the superblock
> fields 'fs_csshift' and 'fs_csmask'. Add a comment to newfs/mkfs.c
> to indicate that these fields must be calculated for compatibility
> with older kernels.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.16 2001/04/04 22:06:38 gluk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.16 2001/04/04 22:06:38 gluk Exp $";
d108 2
d210 11
@


1.16
log
@bye bye -U (soft updates).
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.15 2001/01/16 03:05:44 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.15 2001/01/16 03:05:44 deraadt Exp $";
d579 6
@


1.15
log
@_exit() in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.14 2000/09/22 19:21:30 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.14 2000/09/22 19:21:30 millert Exp $";
a85 1
extern int	Uflag;		/* enable soft updates for file system */
a189 3
	}
	if (Uflag) {
		sblock.fs_flags |= FS_DOSOFTDEP;
@


1.14
log
@If a cylinder group won't fit inside of one block, adjust secpercyl
and ntracks until it does, if possible.  This allows one to newfs
disks with funky (usually BIOS-generated) geometries without cranking
the block size.  This is really just a hack and a better solution
would be to fake the geometries of zone-recorded disks since secpercyl
is never accurate in that case anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.13 1999/12/03 19:24:17 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.13 1999/12/03 19:24:17 art Exp $";
d1065 1
a1065 1
	exit(0);
@


1.13
log
@Allow enabling soft updates (with -U) on a new filesystem.
Allow soft updates on mfs filesystems (even if it's stupid).
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.12 1999/04/10 04:09:23 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.12 1999/04/10 04:09:23 millert Exp $";
d202 1
d308 6
d419 5
@


1.12
log
@Add -q flag to newfs and use it in the install
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.11 1997/11/17 09:14:05 niklas Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.11 1997/11/17 09:14:05 niklas Exp $";
d86 1
d191 3
@


1.11
log
@Work around a stackframe bug in gcc alpha, who cannot deal with frames > 64k
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.10 1997/06/03 22:27:17 grr Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.10 1997/06/03 22:27:17 grr Exp $";
d108 1
d613 1
a613 1
	if (!mfs)
d619 1
a619 1
		if (mfs)
d631 1
a631 1
	if (!mfs)
@


1.10
log
@Make mkfs.c malloc its large buffers, which saves about 200K of bss size
when newfs is used in instbin and is otherwise harmless.  Also add a little
pro-forma malloc fail parnoia, though it's not really needed when the local
malloc routine is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.8 1997/05/29 20:22:43 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.8 1997/05/29 20:22:43 deraadt Exp $";
d1009 2
a1010 1
	struct dinode buf[MAXINOPB];
d1038 1
@


1.9
log
@number of unallocated sectors message was based on modified fssize, make it deal with reality
@
text
@d113 1
a113 1
union {
d116 3
a118 2
} fsun;
#define	sblock	fsun.fs
d121 1
a121 1
union {
d124 2
a125 2
} cgun;
#define	acg	cgun.cg
d127 2
a128 1
struct dinode zino[MAXBSIZE / sizeof(struct dinode)];
d151 8
d570 4
a573 1
	fscs = (struct csum *)calloc(1, sblock.fs_cssize);
a870 1
char buf[MAXBSIZE];
d1110 2
a1111 2
	base = malloc(size);
	memset(base, 0, size);
@


1.8
log
@mkfs() should not play with fssize; grr, PR#189
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.7 1997/03/27 17:15:27 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.7 1997/03/27 17:15:27 deraadt Exp $";
d547 2
a548 2
		    (fssize * NSPF(&sblock) - (sblock.fs_ncyl - 1)
		    * sblock.fs_spc));
@


1.7
log
@if lost+found generation code is enabled, create it with a nice mode
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.6 1997/02/23 03:51:23 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.6 1997/02/23 03:51:23 millert Exp $";
d432 3
a434 3
	sblock.fs_size = fssize = dbtofsb(&sblock, fssize);
	sblock.fs_ncyl = fssize * NSPF(&sblock) / sblock.fs_spc;
	if (fssize * NSPF(&sblock) > sblock.fs_ncyl * sblock.fs_spc) {
d525 1
a525 1
	if ((i = fssize - j * sblock.fs_fpg) < sblock.fs_fpg &&
d540 2
a541 2
		sblock.fs_size = fssize = sblock.fs_ncyl * sblock.fs_spc /
		    NSPF(&sblock);
@


1.6
log
@Inline fsirand(8) (at no noticable cost in speed).
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.5 1997/02/21 22:55:19 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.5 1997/02/21 22:55:19 millert Exp $";
d886 1
a886 1
	node.di_mode = IFDIR | UMASK;
@


1.5
log
@Don't expose private copies of malloc(), calloc(), free().  Ewwww.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.4 1997/02/11 07:01:37 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.4 1997/02/11 07:01:37 millert Exp $";
d574 1
d576 4
a579 1
	sblock.fs_ronly = 0;
d728 4
d1001 3
@


1.4
log
@Remove occurences of headswitch and trackseek, they no longer
exist in struct fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.3 1996/08/02 11:00:50 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.3 1996/08/02 11:00:50 deraadt Exp $";
d110 2
a111 1
extern caddr_t	malloc(), calloc();
d1029 1
a1029 1
caddr_t
d1061 1
a1061 1
caddr_t
d1070 4
a1073 2
	memcpy(p, ptr, size);
	free(ptr);
d1080 1
a1080 1
char *
d1095 1
@


1.3
log
@proper column management for superblock backups; from freebsd, joerg/satoshi
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.2 1996/06/23 14:31:46 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.2 1996/06/23 14:31:46 deraadt Exp $";
a94 2
extern int	headswitch;	/* head switch time, usec */
extern int	trackseek;	/* track-to-track seek, usec */
a563 2
	sblock.fs_headswitch = headswitch;
	sblock.fs_trkseek = trackseek;
d722 1
a722 1
	for (i = 0; i < sblock.fs_ipg / INOPF(&sblock); i += sblock.fs_frag)
d725 1
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mkfs.c,v 1.25 1995/06/18 21:35:38 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mkfs.c,v 1.25 1995/06/18 21:35:38 cgd Exp $";
d53 1
d131 1
d147 2
d599 3
a601 1
		printf("super-block backups (for fsck -b #) at:");
d606 3
a608 1
		if (cylno % 8 == 0)
d610 4
a613 1
		printf(" %d,", fsbtodb(&sblock, cgsblock(&sblock, cylno)));
d1256 22
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: mkfs.c,v 1.25 1995/06/18 21:35:38 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
