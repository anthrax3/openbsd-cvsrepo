head	1.10;
access;
symbols
	OPENBSD_5_6:1.9.0.10
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.8
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2014.10.09.03.43.34;	author tedu;	state dead;
branches;
next	1.9;
commitid	Qvco95xx2Lj9qjX9;

1.9
date	2012.08.31.23.26.47;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.28.09.05.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.18.18.00.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.21.03.55.35;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.11.18.28.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.08.21.58.36;	author ericj;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.08.21.28.38;	author ericj;	state Exp;
branches;
next	;


desc
@@


1.10
log
@no more modules
@
text
@/*	$OpenBSD: elf.c,v 1.9 2012/08/31 23:26:47 matthew Exp $	*/
/*	$NetBSD: elf.c,v 1.8 2002/01/03 21:45:58 jdolecek Exp $	*/

/*
 * Copyright (c) 1998 Johan Danielsson <joda@@pdc.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>

#if defined(__LP64__)
#define ELFSIZE 64
#else
#define ELFSIZE 32
#endif
#include <sys/exec_elf.h>
#ifndef ELF_HDR_SIZE
#define ELF_HDR_SIZE sizeof(Elf_Ehdr)
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/lkm.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#include "modload.h"

char *strtab;

static void
read_section_header(int fd, Elf_Ehdr *ehdr, int num, Elf_Shdr *shdr)
{

	if (lseek(fd, ehdr->e_shoff + num * ehdr->e_shentsize, SEEK_SET) < 0)
		err(1, "lseek");
	if (read(fd, shdr, sizeof(*shdr)) != sizeof(*shdr))
		err(1, "read");
}

struct elf_section {
	char *name;		/* name of section; points into string table */
	unsigned long type;	/* type of section */
	void *addr;		/* load address of section */
	off_t offset;		/* offset in file */
	size_t size;		/* size of section */
	size_t align;
	struct elf_section *next;
};

/* adds the section `s' at the correct (sorted by address) place in
   the list ponted to by head; *head may be NULL */
static void
add_section(struct elf_section **head, struct elf_section *s)
{
	struct elf_section *p, **q;
	q = head;
	p = *head;

	while (1) {
		if (p == NULL || p->addr > s->addr) {
			s->next = p;
			*q = s;
			return;
		}
		q = &p->next;
		p = p->next;
	}
}

/* make a linked list of all sections containing ALLOCatable data */
static void
read_sections(int fd, Elf_Ehdr *ehdr, char *shstrtab, struct elf_section **head)
{
	int i;
	Elf_Shdr shdr;

	*head = NULL;
	/* scan through section headers */
	for (i = 0; i < ehdr->e_shnum; i++) {
		struct elf_section *s;
		read_section_header(fd, ehdr, i, &shdr);
		if ((shdr.sh_flags & SHF_ALLOC) == 0 &&
		    shdr.sh_type != SHT_STRTAB &&
		    shdr.sh_type != SHT_SYMTAB &&
		    shdr.sh_type != SHT_DYNSYM) {
			/* skip non-ALLOC sections */
			continue;
		}
		s = malloc(sizeof(*s));
		if (s == NULL)
			errx(1, "failed to allocate %lu bytes",
			    (u_long)sizeof(*s));
		s->name = shstrtab + shdr.sh_name;
		s->type = shdr.sh_type;
		s->addr = (void *)shdr.sh_addr;
		s->offset = shdr.sh_offset;
		s->size = shdr.sh_size;
		s->align = shdr.sh_addralign;
		add_section(head, s);
	}
}

/* get the symbol table sections and free the rest of them */
static void
get_symtab(struct elf_section **stab)
{
	struct elf_section *head, *cur, *prev;

	head = NULL;
	prev = NULL;
	cur = *stab;
	while (cur) {
		if ((cur->type == SHT_SYMTAB) || (cur->type == SHT_DYNSYM)) {
			if (head == NULL)
				head = cur;
			if (prev != NULL)
				prev->next = cur;
			prev = cur;
			cur = cur->next;
		} else {
			struct elf_section *p = cur;
			cur = cur->next;
			p->next = NULL;
			free(p);
		}
	}

	if (prev)
		prev->next = NULL;
	*stab = head;
}

/* free a list of section headers */
static void
free_sections(struct elf_section *head)
{

	while (head) {
		struct elf_section *p = head;
		head = head->next;
		free(p);
	}
}

/* read section header's string table */
static char *
read_shstring_table(int fd, Elf_Ehdr *ehdr)
{
	Elf_Shdr shdr;
	char *shstrtab;

	read_section_header(fd, ehdr, ehdr->e_shstrndx, &shdr);

	shstrtab = malloc(shdr.sh_size);
	if (shstrtab == NULL)
		errx(1, "failed to allocate %lu bytes", (u_long)shdr.sh_size);
	if (lseek(fd, shdr.sh_offset, SEEK_SET) < 0)
		err(1, "lseek");
	if (read(fd, shstrtab, shdr.sh_size) != shdr.sh_size)
		err(1, "read");
	return shstrtab;
}

/* read string table */
static char *
read_string_table(int fd, struct elf_section *head, int *strtablen)
{
	char *string_table=NULL;

	while (head) {
		if (strcmp(head->name, ".strtab") == 0 &&
		    head->type == SHT_STRTAB) {
			string_table = malloc(head->size);
			if (string_table == NULL)
				errx(1, "failed to allocate %lu bytes",
				    (u_long)head->size);
			if (lseek(fd, head->offset, SEEK_SET) < 0)
				err(1, "lseek");
			if (read(fd, string_table, head->size) != head->size)
				err(1, "read");
			*strtablen = head->size;
			break;
		} else
			head = head->next;
	}
	return string_table;
}

static int
read_elf_header(int fd, Elf_Ehdr *ehdr)
{
	ssize_t n;

	n = read(fd, ehdr, sizeof(*ehdr));
	if (n < 0)
		err(1, "failed reading %lu bytes", (u_long)sizeof(*ehdr));
	if (n != sizeof(*ehdr)) {
		if (debug)
			warnx("failed to read %lu bytes", (u_long)sizeof(*ehdr));
		return -1;
	}
	if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0 ||
	    ehdr->e_ident[EI_CLASS] != ELFCLASS)
		errx(4, "not in ELF%u format", ELFSIZE);
	if (ehdr->e_ehsize != ELF_HDR_SIZE)
		errx(4, "file has ELF%u identity, but wrong header size",
		    ELFSIZE);
	return 0;
}

/* offset of data segment; this is horrible, but keeps the size of the
   module to a minimum */
static ssize_t data_offset;

/* return size needed by the module */
int
elf_mod_sizes(int fd, size_t *modsize, int *strtablen,
    struct lmc_resrv *resrvp, struct stat *sp)
{
	Elf_Ehdr ehdr;
	ssize_t off = 0;
	size_t data_hole = 0;
	char *shstrtab, *strtab;
	struct elf_section *head, *s, *stab;

	if (read_elf_header(fd, &ehdr) < 0)
		return -1;
	shstrtab = read_shstring_table(fd, &ehdr);
	read_sections(fd, &ehdr, shstrtab, &head);

	for (s = head; s; s = s->next) {
		/* XXX impossible! */
		if (s->type == SHT_STRTAB && s->type == SHT_SYMTAB &&
		    s->type == SHT_DYNSYM)
			continue;
		if (debug)
			fprintf(stderr,
			    "%s: addr = %p size = %#lx align = %#lx\n",
			    s->name, s->addr, (u_long)s->size, (u_long)s->align);
		/*
		 * XXX try to get rid of the hole before the data
		 * section that GNU-ld likes to put there
		 */
		if (strcmp(s->name, ".data") == 0 && s->addr > (void *)off) {
			data_offset = roundup(off, s->align);
			if (debug)
				fprintf(stderr, ".data section forced to "
				    "offset %p (was %p)\n",
				    (void *)data_offset, s->addr);
			/* later remove size of compressed hole from off */
			data_hole = (ssize_t)s->addr - data_offset;
		}
		off = (ssize_t)s->addr + s->size;
	}
	off -= data_hole;

	/* XXX round to pagesize? */
	*modsize = roundup(off, sysconf(_SC_PAGESIZE));

	/* get string table length */
	strtab = read_string_table(fd, head, strtablen);
	free(shstrtab);
	free(strtab);

	/* get symbol table sections */
	get_symtab(&head);
	stab = head;
	resrvp->sym_symsize = 0;
	while (stab) {
		resrvp->sym_symsize += stab->size;
		stab = stab->next;
	}
	resrvp->sym_size = resrvp->sym_symsize + *strtablen;
	free_sections(head);

	return (0);
}

/*
 * Expected linker options:
 *
 * -R		executable to link against
 * -e		entry point
 * -o		output file
 * -Ttext	address to link text segment to in hex (assumes it's
 *		a page boundry)
 * -Tdata	address to link data segment to in hex
 * <target>	object file */

#define	LINKCMD		"ld -nopie -Z -R %s -e %s -o %s -Ttext %p %s"
#define	LINKCMD2	"ld -nopie -Z -R %s -e %s -o %s -Ttext %p -Tdata %p %s"

/* make a link command; XXX if data_offset above is non-zero, force
   data address to be at start of text + offset */
void
elf_linkcmd(char *buf, size_t len, const char *kernel,
    const char *entry, const char *outfile, const void *address,
    const char *object)
{
	ssize_t n;

	if (data_offset == 0)
		n = snprintf(buf, len, LINKCMD, kernel, entry,
		    outfile, address, object);
	else
		n = snprintf(buf, len, LINKCMD2, kernel, entry,
		    outfile, address,
		    (const char*)address + data_offset, object);
	if (n < 0 || n >= len)
		errx(1, "link command longer than %lu bytes", (u_long)len);
}

/* load a prelinked module; returns entry point */
void *
elf_mod_load(int fd)
{
	Elf_Ehdr ehdr;
	size_t zero_size = 0;
	size_t b;
	ssize_t n;
	char *shstrtab;
	struct elf_section *head, *s;
	char buf[10 * BUFSIZ];
	void *addr = NULL;

	if (read_elf_header(fd, &ehdr) < 0)
		return NULL;

	shstrtab = read_shstring_table(fd, &ehdr);
	read_sections(fd, &ehdr, shstrtab, &head);

	for (s = head; s; s = s->next) {
		if (s->type != SHT_STRTAB && s->type != SHT_SYMTAB &&
		    s->type != SHT_DYNSYM) {
			if (debug)
				fprintf(stderr, "loading `%s': addr = %p, "
				    "size = %#lx\n",
				    s->name, s->addr, (u_long)s->size);
			if (s->type == SHT_NOBITS) {
				/* skip some space */
				zero_size += s->size;
			} else {
				if (addr != NULL) {
					/*
					 * if there is a gap in the prelinked
					 * module, transfer some empty space.
					 */
					zero_size += (char*)s->addr -
					    (char*)addr;
				}
				if (zero_size) {
					loadspace(zero_size);
					zero_size = 0;
				}
				b = s->size;
				if (lseek(fd, s->offset, SEEK_SET) == -1)
					err(1, "lseek");
				while (b) {
					n = read(fd, buf, MIN(b, sizeof(buf)));
					if (n == 0)
						errx(1, "unexpected EOF");
					if (n < 0)
						err(1, "read");
					loadbuf(buf, n);
					b -= n;
				}
				addr = (char*)s->addr + s->size;
			}
		}
	}
	if (zero_size)
		loadspace(zero_size);

	free_sections(head);
	free(shstrtab);
	return (void *)ehdr.e_entry;
}

extern int devfd, modfd;

void
elf_mod_symload(int strtablen)
{
	Elf_Ehdr ehdr;
	char *shstrtab;
	struct elf_section *head, *s;
	char *symbuf, *strbuf;

	/*
	 * Seek to the text offset to start loading...
	 */
	if (lseek(modfd, 0, SEEK_SET) == -1)
		err(12, "lseek");
	if (read_elf_header(modfd, &ehdr) < 0)
		return;

	shstrtab = read_shstring_table(modfd, &ehdr);
	read_sections(modfd, &ehdr, shstrtab, &head);

	for (s = head; s; s = s->next) {
		struct elf_section *p = s;

		if ((p->type == SHT_SYMTAB) || (p->type == SHT_DYNSYM)) {
			if (debug)
				fprintf(stderr, "loading `%s': addr = %p, "
				    "size = %#lx\n",
				    s->name, s->addr, (u_long)s->size);
			/*
			 * Seek to the file offset to start loading it...
			 */
			if (lseek(modfd, p->offset, SEEK_SET) == -1)
				err(12, "lseek");
			symbuf = malloc(p->size);
			if (symbuf == 0)
				err(13, "malloc");
			if (read(modfd, symbuf, p->size) != p->size)
				err(14, "read");

			loadsym(symbuf, p->size);
			free(symbuf);
		}
	}

	for (s = head; s; s = s->next) {
		struct elf_section *p = s;

		if ((p->type == SHT_STRTAB) &&
		    (strcmp(p->name, ".strtab") == 0 )) {
			if (debug)
				fprintf(stderr, "loading `%s': addr = %p, "
				    "size = %#lx\n",
				    s->name, s->addr, (u_long)s->size);
			/*
			 * Seek to the file offset to start loading it...
			 */
			if (lseek(modfd, p->offset, SEEK_SET) == -1)
				err(12, "lseek");
			strbuf = malloc(p->size);
			if (strbuf == 0)
				err(13, "malloc");
			if (read(modfd, strbuf, p->size) != p->size)
				err(14, "read");

			loadsym(strbuf, p->size);
			free(strbuf);
		}
	}

	free(shstrtab);
	free_sections(head);
	return;
}
@


1.9
log
@modload needs to invoke ld with -nopie now on ELF platforms

ok pascal
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.8 2011/04/06 11:36:26 miod Exp $	*/
@


1.8
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.7 2004/12/28 09:05:18 deraadt Exp $	*/
d319 2
a320 2
#define	LINKCMD		"ld -Z -R %s -e %s -o %s -Ttext %p %s"
#define	LINKCMD2	"ld -Z -R %s -e %s -o %s -Ttext %p -Tdata %p %s"
@


1.7
log
@use __LP64__; miod
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.6 2003/09/18 18:00:13 deraadt Exp $	*/
d331 1
a331 1
	if (data_offset == NULL)
@


1.6
log
@fix early free (subtle); marius@@monkey.org
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.5 2003/07/21 03:55:35 tedu Exp $	*/
d34 1
a34 1
#if defined(__alpha__) || defined(__arch64__) || defined(__x86_64__)
d124 1
a124 1
		s->addr = (void*)shdr.sh_addr;
d273 1
a273 1
		if (strcmp(s->name, ".data") == 0 && s->addr > (void*)off) {
d278 1
a278 1
				    (void*)data_offset, s->addr);
d405 1
a405 1
	return (void*)ehdr.e_entry;
@


1.5
log
@ld needs -Z flag since W^X.  from marius erikson in pr3360.  ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.4 2002/12/11 18:28:22 deraadt Exp $	*/
a287 1
	free(shstrtab);
d291 1
@


1.4
log
@ansi; modload users please test
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.3 2002/06/09 08:13:07 todd Exp $	*/
d319 2
a320 2
#define	LINKCMD		"ld -R %s -e %s -o %s -Ttext %p %s"
#define	LINKCMD2	"ld -R %s -e %s -o %s -Ttext %p -Tdata %p %s"
@


1.3
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.2 2002/01/08 21:58:36 ericj Exp $	*/
d111 4
a114 4
		if (((shdr.sh_flags & SHF_ALLOC) == 0)
		    && (shdr.sh_type != SHT_STRTAB)
		    && (shdr.sh_type != SHT_SYMTAB)
		    && (shdr.sh_type != SHT_DYNSYM)) {
d121 1
a121 1
			     (u_long)sizeof(*s));
d143 1
a143 1
			if (head == NULL) {
d145 1
a145 2
			}
			if (prev != NULL) {
a146 1
			}
d157 1
a157 1
	if (prev) {
a158 1
	}
d200 2
a201 2
		if ((strcmp(head->name, ".strtab") == 0 )
		    && (head->type == SHT_STRTAB)) {
d212 1
a212 1
		} else {
a213 1
		}
a236 1

d246 2
a247 6
elf_mod_sizes(fd, modsize, strtablen, resrvp, sp)
	int fd;
	size_t *modsize;
	int *strtablen;
	struct lmc_resrv *resrvp;
	struct stat *sp;
d254 1
a254 1
	
d261 3
a263 2
                if ((s->type == SHT_STRTAB) && (s->type == SHT_SYMTAB)
                    && (s->type == SHT_DYNSYM)) {
a264 1
		}
d269 4
a272 2
		/* XXX try to get rid of the hole before the data
                   section that GNU-ld likes to put there */
d278 1
a278 2
				    (void*)data_offset,
				    s->addr);
d285 1
a285 1
	
d325 3
a327 7
elf_linkcmd(char *buf,
	    size_t len,
	    const char *kernel,
	    const char *entry,
	    const char *outfile,
	    const void *address,
	    const char *object)
d333 1
a333 1
			     outfile, address, object);
d336 3
a338 3
			     outfile, address,
			     (const char*)address + data_offset, object);
	if (n >= len)
d354 1
a354 1
		
d360 1
a360 1
	
d362 2
a363 2
		if ((s->type != SHT_STRTAB) && (s->type != SHT_SYMTAB)
		    && (s->type != SHT_DYNSYM)) {
d366 2
a367 2
					"size = %#lx\n",
					s->name, s->addr, (u_long)s->size);
d377 2
a378 2
					zero_size += (char*)s->addr
					 		- (char*)addr;
d402 1
a402 1
	
d411 1
a411 2
elf_mod_symload(strtablen)
	int strtablen;
d414 2
a415 2
        char *shstrtab;
        struct elf_section *head, *s;
d418 7
a424 7
        /*
         * Seek to the text offset to start loading...
         */
        if (lseek(modfd, 0, SEEK_SET) == -1)
                err(12, "lseek");
        if (read_elf_header(modfd, &ehdr) < 0)
                return;
d426 2
a427 2
        shstrtab = read_shstring_table(modfd, &ehdr);
        read_sections(modfd, &ehdr, shstrtab, &head);
d429 1
a429 1
        for (s = head; s; s = s->next) {
d432 5
a436 5
                if ((p->type == SHT_SYMTAB) || (p->type == SHT_DYNSYM)) {
                        if (debug)
                                fprintf(stderr, "loading `%s': addr = %p, "
                                        "size = %#lx\n",
                                        s->name, s->addr, (u_long)s->size);
d438 4
a441 4
         		 * Seek to the file offset to start loading it...
         		 */
        		if (lseek(modfd, p->offset, SEEK_SET) == -1)
                		err(12, "lseek");
d444 1
a444 1
                		err(13, "malloc");
d446 1
a446 1
                		err(14, "read");
d450 2
a451 2
                }
        }
d454 18
a471 1
                struct elf_section *p = s;
d473 8
a480 25
                if ((p->type == SHT_STRTAB)
		    && (strcmp(p->name, ".strtab") == 0 )) {
                        if (debug)
                                fprintf(stderr, "loading `%s': addr = %p, "
                                        "size = %#lx\n",
                                        s->name, s->addr, (u_long)s->size);
                        /*
                         * Seek to the file offset to start loading it...
                         */
                        if (lseek(modfd, p->offset, SEEK_SET) == -1)
                                err(12, "lseek");
                        strbuf = malloc(p->size);
                        if (strbuf == 0)
                                err(13, "malloc");
                        if (read(modfd, strbuf, p->size) != p->size)
                                err(14, "read");

                        loadsym(strbuf, p->size);
                        free(strbuf);
                }
        }

        free(shstrtab);
        free_sections(head);
        return;
@


1.2
log
@
rename symtab to not collide with symtab in modload.c
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.1 2002/01/08 21:28:38 ericj Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Johan Danielsson <joda@@pdc.kth.se> 
d239 1
a239 1
		errx(4, "file has ELF%u identity, but wrong header size", 
d275 2
a276 2
			fprintf(stderr, 
			    "%s: addr = %p size = %#lx align = %#lx\n", 
d322 1
a322 1
 * -Ttext	address to link text segment to in hex (assumes it's 
d335 4
a338 4
	    const char *kernel, 
	    const char *entry, 
	    const char *outfile, 
	    const void *address, 
d344 1
a344 1
		n = snprintf(buf, len, LINKCMD, kernel, entry, 
d347 2
a348 2
		n = snprintf(buf, len, LINKCMD2, kernel, entry, 
			     outfile, address, 
d378 1
a378 1
					"size = %#lx\n", 
d438 1
a438 1
 
d468 1
a468 1
 
d485 1
a485 1
 
@


1.1
log
@
add support in modload for ELF
from NetBSD
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 1
a134 1
get_symtab(struct elf_section **symtab)
d140 1
a140 1
	cur = *symtab;
d162 1
a162 1
	*symtab = head;
d262 1
a262 1
	struct elf_section *head, *s, *symtab;
d304 1
a304 1
	symtab = head;
d306 3
a308 3
	while (symtab) {
		resrvp->sym_symsize += symtab->size;
		symtab = symtab->next;
@

