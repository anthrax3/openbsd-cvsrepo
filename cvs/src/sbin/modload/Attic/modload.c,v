head	1.46;
access;
symbols
	OPENBSD_5_6:1.45.0.6
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.10
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.8
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.6
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.43.0.14
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.12
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.8
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.10
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.6
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.4
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.14
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.41.0.12
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.41.0.10
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.41.0.8
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.41.0.6
	OPENBSD_3_6_BASE:1.41
	OPENBSD_3_5:1.41.0.4
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.41.0.2
	OPENBSD_3_4_BASE:1.41
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_8:1.20.0.6
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.4
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.19.0.8
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.6
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.19.0.4
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2014.10.09.03.43.34;	author tedu;	state dead;
branches;
next	1.45;
commitid	Qvco95xx2Lj9qjX9;

1.45
date	2013.10.15.02.46.31;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2011.06.09.04.57.01;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.25.19.21.37;	author mikeb;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.20.14.01.15;	author jmc;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.06.20.37.25;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.15.08.06.31;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.03.30.20.55.03;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.13.09.09.26;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.18.23.30.20;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.11.18.28.22;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.11.21.23.28;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.16.21.27.35;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.09.00.02.52;	author ericj;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.08.22.07.26;	author ericj;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.08.21.51.50;	author ericj;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.08.21.28.38;	author ericj;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.07.19.38.28;	author ericj;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.17.11.45.20;	author assar;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.09.07.04.46;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.07.18.26.15;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.22.23.17.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.15.18.00.37;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.15.03.07.52;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.10.20.42.09;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.08.17.09.13.14;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.09.17.10.06.32;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.09.17.00.57.45;	author weingart;	state Exp;
branches;
next	1.17;

1.17
date	97.09.17.00.56.42;	author weingart;	state Exp;
branches;
next	1.16;

1.16
date	97.09.11.11.49.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.09.11.11.46.09;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.08.24.08.07.02;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.06.25.18.21.35;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.03.27.19.57.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.01.18.15.12.44;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.01.15.23.41.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.09.16.01.37.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.08.29.15.17.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.13.17.56.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.05.11.01.17;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.07.02.06.37.52;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.31.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.21.11.35.20;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.30.10.44.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.36;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.46
log
@no more modules
@
text
@/* 	$OpenBSD: modload.c,v 1.45 2013/10/15 02:46:31 deraadt Exp $	*/
/*	$NetBSD: modload.c,v 1.30 2001/11/08 15:33:15 christos Exp $	*/

/*
 * Copyright (c) 1993 Terrence R. Lambert.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Terrence R. Lambert.
 * 4. The name Terrence R. Lambert may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TERRENCE R. LAMBERT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE TERRENCE R. LAMBERT BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/mount.h>
#include <sys/lkm.h>
#include <sys/stat.h>
#include <sys/file.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <nlist.h>

#include "modload.h"
#include "pathnames.h"

#define TRUE 1
#define FALSE 0

#ifndef DFLT_ENTRY
#define	DFLT_ENTRY	"xxxinit"
#endif	/* !DFLT_ENTRY */
#ifndef DFLT_ENTRYEXT
#define	DFLT_ENTRYEXT	"_lkmentry"
#endif	/* !DFLT_ENTRYEXT */

int debug = 0;
int verbose = 0;
char *out = NULL;
int symtab = 1;
int Sflag;

extern char *__progname;

static	void	cleanup(void);

/* prelink the module */
static int
prelink(const char *kernel, const char *entry, const char *outfile,
    const void *address, const char *object)
{
	char cmdbuf[1024];
	int fd;

	linkcmd(cmdbuf, sizeof(cmdbuf),
	    kernel, entry, outfile, address, object);

	if (debug)
		fprintf(stderr, "%s\n", cmdbuf);

	if ((fd = open(kernel, O_RDONLY)) == -1)
		errx(1, "can't open %s\n%s: please specify alternative kernel "
		    "executable with -A option", kernel, __progname);
	else
		close(fd);
		
	if (system(cmdbuf) != 0)
		return (1);

	return (0);
}

static void
usage(void)
{

	fprintf(stderr, "usage: %s [-dnSsv] [-A kernel] [-e entry]\n",
	    __progname);
	fprintf(stderr, "\t[-o output_file] [-p postinstall] input_file\n");
	exit(1);
}

int fileopen = 0;
#define	DEV_OPEN	0x01
#define	MOD_OPEN	0x02
#define	PART_RESRV	0x04
#define	OUTFILE_CREAT	0x08

int devfd, modfd;
struct lmc_resrv resrv;

static void
cleanup(void)
{

	if (fileopen & PART_RESRV) {
		/*
		 * Free up kernel memory
		 */
		if (ioctl(devfd, LMUNRESRV, 0) == -1)
			warn("can't release slot 0x%08x memory", resrv.slot);
	}

	if (fileopen & OUTFILE_CREAT)
		unlink(out);
}

static int
verify_entry(const char *entry, char *filename)
{
	struct	nlist	names[2];
	int n;
	char *s;

	memset(names, 0, sizeof(names));
	if (asprintf(&s, "_%s", entry) == -1)
		err(1, "malloc");
	names[0].n_name = s;

	n = nlist(filename, names);
	if (n == -1)
		err(1, "nlist %s", filename);
	free(s);
	return n;
}

/*
 * Transfer data to kernel memory in chunks
 * of MODIOBUF size at a time.
 */
void
loadbuf(void *buf, size_t len)
{
	struct lmc_loadbuf ldbuf;
	size_t n;
	char *p = buf;

	while (len) {
		n = MIN(len, MODIOBUF);
		ldbuf.cnt = n;
		ldbuf.data = p;
		if (ioctl(devfd, LMLOADBUF, &ldbuf) == -1)
			err(11, "error loading buffer");
		len -= n;
		p += n;
	}
}

/* Transfer some empty space. */
void
loadspace(size_t len)
{
	char buf[MODIOBUF];
	size_t n;

	memset(buf, 0, sizeof(buf));
	while (len) {
		n = MIN(len, sizeof(buf));
		loadbuf(buf, n);
		len -= n;
	}
}

/*
 * Transfer symbol table to kernel memory in chunks
 * of MODIOBUF size at a time.
 */
void
loadsym(void *buf, size_t len)
{
	struct lmc_loadbuf ldbuf;
	size_t n;
	char *p = buf;

	while (len) {
		n = MIN(len, MODIOBUF);
		ldbuf.cnt = n;
		ldbuf.data = p;
		if (ioctl(devfd, LMLOADSYMS, &ldbuf) == -1)
			err(11, "error loading buffer");
		len -= n;
		p += n;
	}
}

/* Transfer some empty space. */
int
main(int argc, char *argv[])
{
	int strtablen, c, noready = 0, old = 0;
	const char *kname = _PATH_KSYMS;
	char *entry = DFLT_ENTRY;
	char *post = NULL;
	char *modobj;
	char modout[80], *p;
	struct stat stb;
	size_t modsize;	/* XXX */
	void* modentry;	/* XXX */

	while ((c = getopt(argc, argv, "dnvsA:Se:p:o:")) != -1) {
		switch (c) {
		case 'd':
			debug = 1;
			break;	/* debug */
		case 'v':
			verbose = 1;
			break;	/* verbose */
		case 'A':
			kname = optarg;
			break;	/* kernel */
		case 'e':
			entry = optarg;
			break;	/* entry point */
		case 'p':
			post = optarg;
			break;	/* postinstall */
		case 'o':
			out = optarg;
			break;	/* output file */
		case 'n':
			noready = 1;
			break;
		case 's':
			symtab = 0;
			break;
		case 'S':
			Sflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	modobj = argv[0];

	atexit(cleanup);

	/*
	 * Open the virtual device device driver for exclusive use (needed
	 * to write the new module to it as our means of getting it in the
	 * kernel).
	 */
	if ((devfd = open(_PATH_LKM, O_RDWR, 0)) == -1)
		err(3, "%s", _PATH_LKM);
	fileopen |= DEV_OPEN;

	strncpy(modout, modobj, sizeof(modout) - 1);
	modout[sizeof(modout) - 1] = '\0';

	p = strrchr(modout, '.');
	if (!p || strcmp(p, ".o"))
		errx(2, "module object must end in .o");
	*p = '\0';
	if (out == NULL)
		out = modout;

	/*
	 * Verify that the entry point for the module exists.
	 */
	if (verify_entry(entry, modobj)) {
		/*
		 * Try <modobj>_init if entry is DFLT_ENTRY.
		 */
		if (strcmp(entry, DFLT_ENTRY) == 0) {
			if ((p = strrchr(modout, '/')))
				p++;
			else
				p = modout;
			if (asprintf(&entry, "%s%s", p, DFLT_ENTRYEXT) == -1)
				err(1, "asprintf");
			if (verify_entry(entry, modobj))
				errx(1, "entry point _%s not found in %s",
				    entry, modobj);
		} else
			errx(1, "entry point _%s not found in %s", entry,
			    modobj);
	}

	/*
	 * Prelink to get file size
	 */
	if (prelink(kname, entry, out, 0, modobj))
		errx(1, "can't prelink `%s' creating `%s'", modobj, out);
	if (Sflag == 0)
		fileopen |= OUTFILE_CREAT;

	/*
	 * Pre-open the 0-linked module to get the size information
	 */
	if ((modfd = open(out, O_RDONLY, 0)) == -1)
		err(4, "%s", out);
	fileopen |= MOD_OPEN;

	/*
	 * stat for filesize to figure out string table size
	 */
	if (fstat(modfd, &stb) == -1)
	    err(3, "fstat `%s'", out);

	/*
	 * work out various sizes and fill in resrv bits
	 */
	if (mod_sizes(modfd, &modsize, &strtablen, &resrv, &stb) != 0)
		err(1, "can't get module sizes");

	/*
	 * Close the dummy module -- we have our sizing information.
	 */
	close(modfd);
	fileopen &= ~MOD_OPEN;

	/*
	 * Reserve the required amount of kernel memory -- this may fail
	 * to be successful.
	 */
	resrv.size = modsize;	/* size in bytes */
	resrv.name = modout;	/* objname w/o ".o" */
	resrv.slot = -1;	/* returned */
	resrv.addr = 0;		/* returned */

	if (verbose)
		warnx("reserving %lu bytes of memory", (unsigned long)modsize);

	if (ioctl(devfd, LMRESERV, &resrv) == -1) {
		if (symtab) {
			warn("not loading symbols: kernel does not support "
			    "symbol table loading");
		}
	doold:
		symtab = 0;
		if (ioctl(devfd, LMRESERV_O, &resrv) == -1)
			err(9, "can't reserve memory");
		old = TRUE;
	}
	fileopen |= PART_RESRV;

	/*
	 * Relink at kernel load address
	 */
	if (prelink(kname, entry, out, (void*)resrv.addr, modobj))
		errx(1, "can't link `%s' creating `%s' bound to %p",
		    modobj, out, (void*)resrv.addr);

	/*
	 * Open the relinked module to load it...
	 */
	if ((modfd = open(out, O_RDONLY, 0)) == -1)
		err(4, "%s", out);
	fileopen |= MOD_OPEN;

	modentry = mod_load(modfd);
	if (debug)
		(void)fprintf(stderr, "modentry = %p\n", modentry);

	if (symtab)
		mod_symload(strtablen);

	/*
	 * Save ourselves before disaster (potentitally) strikes...
	 */
	sync();

	if (noready)
		return 0;

	/*
	 * Trigger the module as loaded by calling the entry procedure;
	 * this will do all necessary table fixup to ensure that state
	 * is maintained on success, or blow everything back to ground
	 * zero on failure.
	 */
	if (ioctl(devfd, LMREADY, &modentry) == -1) {
		if (errno == EINVAL && !old) {
			if (fileopen & MOD_OPEN)
				close(modfd);
			/*
			 * PART_RESRV is not true since the kernel cleans
			 * up after a failed LMREADY.
			 */
			fileopen &= ~(MOD_OPEN|PART_RESRV);
			/* try using oldstyle */
			warn("module failed to load using new version; "
			    "trying old version");
			goto doold;
		} else
			err(14, "error initializing module");
	}

	/*
	 * Success!
	 */
	fileopen &= ~PART_RESRV;	/* loaded */
	printf("Module loaded as ID %d\n", resrv.slot);

	/*
	 * Execute the post-install program, if specified.
	 */
	if (post) {
		struct lmc_stat sbuf;
		char name[MAXLKMNAME] = "";
		char id[16], type[32], offset[32];

		sbuf.id = resrv.slot;
		sbuf.name = name;
		if (ioctl(devfd, LMSTAT, &sbuf) == -1)
			err(15, "error fetching module stats for post-install");
		(void)snprintf(id, sizeof(id), "%d", sbuf.id);
		(void)snprintf(type, sizeof(type), "0x%x", sbuf.type);
		(void)snprintf(offset, sizeof(offset), "%ld",
		    (long)sbuf.offset);
		/*
		 * XXX
		 * The modload docs say that drivers can install bdevsw &
		 * cdevsw, but the interface only supports one at a time.
		 */
		execl(post, post, id, type, offset, (char *)NULL);
		err(16, "can't exec `%s'", post);
	}

	exit (0);
}
@


1.45
log
@remove last bits of a.out support
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.44 2011/06/09 04:57:01 deraadt Exp $	*/
@


1.44
log
@there is no need to close files when the titanic is going down.
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.43 2007/11/25 19:21:37 mikeb Exp $	*/
a145 3
#ifdef	_AOUT_INCLUDE_
	names[0].n_un.n_name = s;
#else
a146 1
#endif
@


1.43
log
@Make modload use /dev/ksyms as a kernel file by default.

Idea from form@@, suggestions from miod@@.

ok miod
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.42 2007/02/20 14:01:15 jmc Exp $	*/
a130 6

	if (fileopen & DEV_OPEN)
		close(devfd);

	if (fileopen & MOD_OPEN)
		close(modfd);
@


1.42
log
@sort options and sync usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.41 2003/08/06 20:37:25 millert Exp $	*/
d71 2
d81 1
a81 1
	int error = 0;
d89 10
a98 20
	switch (system(cmdbuf)) {
	case 0:				/* SUCCESS! */
		break;
	case 1:				/* uninformitive error */
		/*
		 * Someone needs to fix the return values from the NetBSD
		 * ld program -- it's totally uninformative.
		 *
		 * No such file		(4 on SunOS)
		 * Can't write output	(2 on SunOS)
		 * Undefined symbol	(1 on SunOS)
		 * etc.
		 */
	case 127:			/* can't load shell */
	case 32512:
	default:
		error = 1;
		break;
	}
	return error;
a103 1
	extern char *__progname;
d229 1
a229 1
	const char *kname = _PATH_UNIX;
@


1.41
log
@Remove an unused variable and plug a memory leak; Patrick Latifi
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.40 2003/04/15 08:06:31 deraadt Exp $	*/
d114 1
a114 1
	fprintf(stderr, "usage: %s [-dnsvS] [-A system] [-e entry]\n",
d116 1
a116 1
	fprintf(stderr, "\t[-p postinstall] [-o outputfile] <input file>\n");
@


1.40
log
@asprintf, and fix buffer sizes; ok tedu
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.39 2003/03/30 20:55:03 henning Exp $	*/
d155 1
a155 1
	int n, len;
d170 1
@


1.39
log
@asprintf

partitially from David Hill <david at phobia.ms>
ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.38 2003/03/13 09:09:26 deraadt Exp $	*/
d159 1
a159 3
	len = strlen(entry) + 2;
	s = malloc(len);
	if (s == NULL)
a160 1
	snprintf(s, len, "_%s", entry);
d452 1
a452 1
		char id[16], type[16], offset[16];
@


1.38
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.37 2003/01/18 23:30:20 deraadt Exp $	*/
d240 1
a240 1
	char *kname = _PATH_UNIX;
a318 2
			int len;

d323 2
a324 5
			len = strlen(p) + strlen(DFLT_ENTRYEXT) + 1;
			entry = malloc(len);
			if (entry == NULL)
				err(1, "malloc");
			snprintf(entry, len, "%s%s", p, DFLT_ENTRYEXT);
@


1.37
log
@minor tweaking; andrushock@@korovino.net
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.36 2002/12/11 18:28:22 deraadt Exp $	*/
d155 1
a155 1
	int n;
d159 2
a160 1
	s = malloc(strlen(entry) + 2);
d163 1
a163 1
	sprintf(s, "_%s", entry);	/* safe */
d319 2
d325 2
a326 1
			entry = malloc(strlen(p) + strlen(DFLT_ENTRYEXT) + 1);
d329 1
a329 1
			sprintf(entry, "%s%s", p, DFLT_ENTRYEXT); /* safe */
@


1.36
log
@ansi; modload users please test
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.35 2002/07/11 21:23:28 deraadt Exp $	*/
d43 1
d51 2
a57 2
#include "modload.h"

d297 1
a297 1
		err(3, _PATH_LKM);
@


1.35
log
@malloc() failure tests; rimshot@@pandora.be
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.34 2002/06/09 08:13:07 todd Exp $	*/
d74 2
a75 5
prelink(const char *kernel,
	const char *entry,
	const char *outfile,
	const void *address,
	const char *object)
d81 1
a81 1
		kernel, entry, outfile, address, object);
a104 1

d114 1
a114 1
		__progname);
d184 1
a184 1
	
d221 1
a221 1
	
d235 1
a235 1
main(int argc, char **argv)
d237 1
a237 1
	int c;
a243 1
	int strtablen;
a245 1
	int noready = 0, old = 0;
d341 3
a343 3
 	/*
 	 * Pre-open the 0-linked module to get the size information
 	 */
d384 4
a387 4
	    symtab = 0;
	    if (ioctl(devfd, LMRESERV_O, &resrv) == -1)
		err(9, "can't reserve memory");
	    old = TRUE;
d396 1
a396 1
		     modobj, out, (void*)resrv.addr);
@


1.34
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.33 2002/02/16 21:27:35 millert Exp $	*/
d163 2
d328 2
@


1.33
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.32 2002/01/09 00:02:52 ericj Exp $	*/
d74 4
a77 4
prelink(const char *kernel, 
	const char *entry, 
	const char *outfile, 
	const void *address, 
d83 1
a83 1
	linkcmd(cmdbuf, sizeof(cmdbuf), 
d176 2
a177 2
/* 
 * Transfer data to kernel memory in chunks 
d213 2
a214 2
/* 
 * Transfer symbol table to kernel memory in chunks 
d342 1
a342 1
  
@


1.32
log
@
symbol addresses should be relative
also, no need to read the aout header twice. actually this made
symbol loading not work.
millert@@ ok
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.31 2002/01/08 22:07:26 ericj Exp $	*/
d70 1
a70 1
static	void	cleanup __P((void));
@


1.31
log
@
oops, put back some earlier changes
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.30 2002/01/08 21:51:50 ericj Exp $	*/
d115 1
d117 3
a119 5
	fprintf(stderr, "usage:\n");
	fprintf(stderr, "modload [-d] [-v] [-n] [-s] [-S] "
	    "[-A <kernel>] [-e <entry>]\n");
	fprintf(stderr,
	    "        [-p <postinstall>] [-o <output file>] <input file>\n");
@


1.30
log
@
change back to old behavior, where we load debugging symbols by default.
@
text
@d1 1
a1 1
/* 	$OpenBSD: modload.c,v 1.29 2002/01/08 21:28:38 ericj Exp $	*/
d281 1
a281 1
		case '?':
a282 4
			/* NOTREACHED */
		default:
			printf("default!\n");
			break;
@


1.29
log
@
add support in modload for ELF
from NetBSD
miod@@ ok.
@
text
@d1 1
a1 1
/* 	$OpenBSD$	*/
d67 1
a67 1
int symtab = 0;
d276 1
a276 1
			symtab = 1;
@


1.28
log
@
u_long for arg for LMREADY
@
text
@d1 2
a2 2
/*	$OpenBSD: modload.c,v 1.27 2001/09/17 11:45:20 assar Exp $	*/
/*	$NetBSD: modload.c,v 1.13 1995/05/28 05:21:58 jtc Exp $	*/
d42 1
a42 2
#include <sys/wait.h>
#include <a.out.h>
a44 2
#include <fcntl.h>
#include <limits.h>
d49 1
d52 2
a53 1
#define	min(a, b)	((a) < (b) ? (a) : (b))
d55 8
a62 9
/*
 * Expected linker options:
 *
 * -A		executable to link against
 * -e		entry point
 * -o		output file
 * -T		address to link to in hex (assumes it's a page boundry)
 * <target>	object file
 */
d66 13
a78 20
int symtab = 1;
int quiet = 0;
int dounlink = 0;

#if defined(__alpha) || defined(__mips)
#define LDSYMTABLE	"-R"
#define LDTEXTSTART	"-Ttext"
#define LDSYMPREFIX	""
#else
#define LDSYMTABLE	"-A"
#define LDTEXTSTART	"-T"
#define LDSYMPREFIX	"_"
#define MAGICCHECK
#endif

void
linkcmd(kernel, entry, outfile, address, object)
	char *kernel, *entry, *outfile;
	u_int address;	/* XXX */
	char *object;
d80 2
a81 3
	char addrbuf[32], entrybuf[_POSIX2_LINE_MAX];
	pid_t pid;
	int status;
d83 2
a84 2
	snprintf(entrybuf, sizeof entrybuf, "%s%s", LDSYMPREFIX, entry);
	snprintf(addrbuf, sizeof addrbuf, "%x", address);
d87 1
a87 6
		printf("%s %s %s -e %s -o %s %s %s %s\n",
		    _PATH_LD, LDSYMTABLE, kernel, entrybuf,
		    outfile, LDTEXTSTART, addrbuf, object);
	
	if ((pid = fork()) < 0)
		err(18, "fork");
d89 18
a106 11
	if (pid == 0) {
		execl(_PATH_LD, "ld", LDSYMTABLE, kernel, "-e", entrybuf, "-o",
		    outfile, LDTEXTSTART, addrbuf, object, (char *)NULL);
		exit(128 + errno);
	}

	waitpid(pid, &status, 0);

	if (WIFSIGNALED(status)) {
		errx(1, "%s got signal: %s", _PATH_LD,
		sys_siglist[WTERMSIG(status)]);
d109 1
a109 7
	if (WEXITSTATUS(status) > 128) {
		errno = WEXITSTATUS(status) - 128;
		err(1, "exec(%s)", _PATH_LD);
	}

	if (WEXITSTATUS(status) != 0)
		errx(1, "%s: return code %d", _PATH_LD, WEXITSTATUS(status));
d113 1
a113 1
usage()
d116 3
a118 1
	fprintf(stderr, "usage: modload [-dvsqu] [-A <kernel>] [-e <entry]\n");
d120 1
a120 1
	    "\t[-p <postinstall>] [-o <output file>] <input file>\n");
d128 2
a131 1
char modout[MAXPATHLEN];
d133 2
a134 6
/*
 * Must be safe for two calls. One in case of the -p option, and one from
 * the atexit() call...
 */
void
cleanup()
d136 1
a142 1
		fileopen &= ~PART_RESRV;
d145 1
a145 1
	if (fileopen & DEV_OPEN) {
d147 49
a195 1
		fileopen &= ~DEV_OPEN;
d197 8
d206 5
a210 3
	if (fileopen & MOD_OPEN) {
		close(modfd);
		fileopen &= ~MOD_OPEN;
d212 1
d214 19
a232 3
	if (dounlink && unlink(modout) != 0) {
		err(17, "unlink(%s)", modout);
		dounlink = 0;
d236 1
d238 1
a238 3
main(argc, argv)
	int argc;
	char *argv[];
d240 1
d242 4
a245 2
	char *entry = NULL, *post = NULL, *out = NULL, *modobj, *p;
	struct exec info_buf;
d247 4
a250 6
	u_int modsize;		/* XXX */
	u_long modentry;	/* XXX */
	int strtablen, c;
	struct lmc_loadbuf ldbuf;
	int sz, bytesleft, old = 0;
	char buf[MODIOBUF];
d252 1
a252 1
	while ((c = getopt(argc, argv, "dvsuqA:e:p:o:")) != -1) {
a259 6
		case 'u':
			dounlink = 1;
			break; /* unlink tmp file */
		case 'q':
			quiet = 1;
			break; /* be quiet */
d272 3
d276 4
a279 1
			symtab = 0;
d281 3
d285 2
a286 1
			usage();
d308 5
a312 2
	p = strrchr(modobj, '.');
	if (!p || p[1] != 'o' || p[2] != '\0')
d314 2
a315 11
	if (out == NULL) {
		p = strrchr(modobj, '/');
		if (p)
			p++;			/* skip over '/' */
		else
			p = modobj;
		snprintf(modout, sizeof modout, "%s%s.XXXXXXXX.o",
		    _PATH_TMP, p);
		if ((modfd = mkstemps(modout, strlen(".o"))) == -1)
			err(1, "creating %s", modout);
		close(modfd);
d317 5
d323 1
a323 2
		 * reverse meaning of -u - if we've generated a /tmp
		 * file, remove it automatically...
d325 13
a337 13
		dounlink = !dounlink;
	}

	if (!entry) {   /* calculate default entry point */
		entry = strrchr(modobj, '/');
		if (entry)
			entry++;		/* skip over '/' */
		else
			entry = modobj;
		entry = strdup(entry);		/* so we can modify it */
		if (!entry)
			errx(1, "Could not allocate memory");
		entry[strlen(entry) - 2] = '\0'; /* chop off .o */
a339 1

d343 9
a351 6
	linkcmd(kname, entry, out, 0, modobj);

	/*
	 * Pre-open the 0-linked module to get the size information
	 */
	if ((modfd = open(out, O_RDONLY)) == -1)
d356 1
a356 2
	 * Get the load module post load size... do this by reading the
	 * header and doing page counts.
d358 2
a359 2
	if (read(modfd, &info_buf, sizeof(struct exec)) == -1)
		err(3, "read `%s'", out);
d362 1
a362 1
	 * stat for filesize to figure out string table size
d364 2
a365 2
	if (fstat(modfd, &stb) == -1)
		err(3, "fstat `%s'", out);
a372 13
#ifdef MAGICCHECK
	/*
	 * Magic number...
	 */
	if (N_BADMAG(info_buf))
		errx(4, "not an a.out format file");
#endif

	/*
	 * Calculate the size of the module
	 */
 	modsize = info_buf.a_text + info_buf.a_data + info_buf.a_bss;

d381 3
a383 11
	strtablen = stb.st_size - N_STROFF(info_buf);
	if (symtab) {
		/*
		 * XXX TODO:  grovel through symbol table looking
		 * for just the symbol table stuff from the new module,
		 * and skip the stuff from the kernel.
		*/
		resrv.sym_size = info_buf.a_syms + strtablen;
		resrv.sym_symsize = info_buf.a_syms;
	} else
		resrv.sym_size = resrv.sym_symsize = 0;
d386 4
a389 3
		if (symtab)
			warn("not loading symbols: "
			    "kernel does not support symbol table loading");
d391 4
a394 4
		symtab = 0;
		if (ioctl(devfd, LMRESERV_O, &resrv) == -1)
			err(9, "can't reserve memory");
		old = 1;
d401 3
a403 1
	linkcmd(kname, entry, out, resrv.addr, modobj);
d408 1
a408 1
	if ((modfd = open(out, O_RDONLY)) == -1)
d412 3
a414 6
	/*
	 * Reread the header to get the actual entry point *after* the
	 * relink.
	 */
	if (read(modfd, &info_buf, sizeof(struct exec)) == -1)
		err(3, "read `%s'", out);
d416 2
a417 61
	/*
	 * Get the entry point (for initialization)
	 */
	modentry = info_buf.a_entry;			/* place to call */

	/*
	 * Seek to the text offset to start loading...
	 */
	if (lseek(modfd, N_TXTOFF(info_buf), 0) == -1)
		err(12, "lseek");

	/*
	 * Transfer the relinked module to kernel memory in chunks of
	 * MODIOBUF size at a time.
	 */
	for (bytesleft = info_buf.a_text + info_buf.a_data; bytesleft > 0;
	    bytesleft -= sz) {
		sz = min(bytesleft, MODIOBUF);
		if (read(modfd, buf, sz) != sz)
			err(14, "read");
		ldbuf.cnt = sz;
		ldbuf.data = buf;
		if (ioctl(devfd, LMLOADBUF, &ldbuf) == -1)
			err(11, "error transferring buffer");
	}

	if (symtab) {
		/*
		 * Seek to the symbol table to start loading it...
		 */
		if (lseek(modfd, N_SYMOFF(info_buf), SEEK_SET) == -1)
			err(12, "lseek");

		/*
		 * Read and load the symbol table entries.
		 */
		for (bytesleft = info_buf.a_syms; bytesleft > 0;
		    bytesleft -= sz) {
			sz = min(bytesleft, MODIOBUF);
			if (read(modfd, buf, sz) != sz)
				err(14, "read");
			ldbuf.cnt = sz;
			ldbuf.data = buf;
			if (ioctl(devfd, LMLOADSYMS, &ldbuf) == -1)
				err(11, "error transferring sym buffer");
		    }

		/*
		 * Read the string table and load it.
		 */
		for (bytesleft = strtablen; bytesleft > 0;
		    bytesleft -= sz) {
			sz = min(bytesleft, MODIOBUF);
			if (read(modfd, buf, sz) != sz)
				err(14, "read");
			ldbuf.cnt = sz;
			ldbuf.data = buf;
			if (ioctl(devfd, LMLOADSYMS, &ldbuf) == -1)
				err(11, "error transferring stringtable buffer");
		}
	}
d424 3
d439 2
a440 2
			 * up after a failed LMREADY
			*/
d454 1
a454 2
	if (!quiet)
		printf("Module loaded as ID %d\n", resrv.slot);
d462 1
a462 1
		char id[16], type[16], offset[32];
d468 4
a471 3
		sprintf(id, "%d", sbuf.id);
		sprintf(type, "0x%x", sbuf.type);
		sprintf(offset, "%lu", sbuf.offset);
a476 3

		cleanup();

d481 1
a481 1
	return 0;
@


1.27
log
@sync actual with flags with usage and man page

art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.26 2001/07/09 07:04:46 deraadt Exp $	*/
d126 1
a126 1
void
d185 2
a186 2
	u_int modsize;	/* XXX */
	u_int modentry;	/* XXX */
d221 1
a221 1
		case '?':
a222 3
		default:
			printf("default!\n");
			break;
@


1.26
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.25 2001/07/07 18:26:15 deraadt Exp $	*/
d130 1
a130 1
	fprintf(stderr, "usage: modload [-dvqu] [-A <kernel>] [-e <entry]\n");
@


1.25
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.24 2001/03/22 23:17:50 deraadt Exp $	*/
d106 1
a106 1
		    outfile, LDTEXTSTART, addrbuf, object, NULL);
d497 1
a497 1
		execl(post, post, id, type, offset, 0);
@


1.24
log
@use mkstemp()
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.23 2001/03/15 18:00:37 deraadt Exp $	*/
d258 1
a258 1
		if (modfd = mkstemps(modout, strlen(".o")) == -1)
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.22 2001/03/15 03:07:52 deraadt Exp $	*/
d256 5
a260 1
		snprintf(modout, sizeof modout, "%s%sut", _PATH_TMP, p);
a280 3
	if ((modfd = open(out, O_RDWR | O_EXCL | O_CREAT, 0600)) < 0)
		err(1, "creating %s", out);
	close(modfd);
@


1.22
log
@override file creation, do not assume umask is enough.  of course, ld may
generate temp files which have umask mode.. so this is not really a sane
change to even bother with.
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.21 2001/02/10 20:42:09 millert Exp $	*/
d104 1
a104 1
	if(pid == 0) {
d112 1
a112 1
	if(WIFSIGNALED(status)) {
d117 1
a117 1
	if(WEXITSTATUS(status) > 128) {
d122 1
a122 1
	if(WEXITSTATUS(status) != 0)
d170 1
a170 1
	if(dounlink && unlink(modout) != 0) {
a180 1
	int c;
d182 1
a182 5
	char *entry = NULL;
	char *post = NULL;
	char *out = NULL;
	char *modobj;
	char *p;
d187 1
a187 3
	struct nlist *nlp;
	int strtablen, numsyms;

d253 1
a253 1
			p++;                    /* skip over '/' */
d268 1
a268 1
			entry++;                /* skip over '/' */
d271 1
a271 1
		entry = strdup(entry);          /* so we can modify it */
d277 1
a277 1
	if((modfd = open(out, O_RDWR | O_EXCL | O_CREAT, 0600)) < 0)
d304 1
a304 1
	    err(3, "fstat `%s'", out);
d335 7
a341 5
	    /* XXX TODO:  grovel through symbol table looking
	       for just the symbol table stuff from the new module,
	       and skip the stuff from the kernel. */
	    resrv.sym_size = info_buf.a_syms + strtablen;
	    resrv.sym_symsize = info_buf.a_syms;
d343 1
a343 1
	    resrv.sym_size = resrv.sym_symsize = 0;
d346 3
a348 2
	    if (symtab)
		warn("not loading symbols: kernel does not support symbol table loading");
d350 4
a353 4
	    symtab = 0;
	    if (ioctl(devfd, LMRESERV_O, &resrv) == -1)
		err(9, "can't reserve memory");
	    old = 1;
d391 1
a391 2
	for (bytesleft = info_buf.a_text + info_buf.a_data;
	    bytesleft > 0;
d403 19
a421 5
	    /*
	     * Seek to the symbol table to start loading it...
	     */
	    if (lseek(modfd, N_SYMOFF(info_buf), SEEK_SET) == -1)
		err(12, "lseek");
d423 13
a435 29
	    /*
	     * Read and load the symbol table entries.
	     */
	    for (bytesleft = info_buf.a_syms;
		 bytesleft > 0;
		 bytesleft -= sz) {
		sz = min(bytesleft, MODIOBUF);
		if (read(modfd, buf, sz) != sz)
			err(14, "read");
		ldbuf.cnt = sz;
		ldbuf.data = buf;
		if (ioctl(devfd, LMLOADSYMS, &ldbuf) == -1)
		    err(11, "error transferring sym buffer");
	    }

	    /*
	     * Read the string table and load it.
	     */
	    for (bytesleft = strtablen;
		 bytesleft > 0;
		 bytesleft -= sz) {
		sz = min(bytesleft, MODIOBUF);
		if (read(modfd, buf, sz) != sz)
			err(14, "read");
		ldbuf.cnt = sz;
		ldbuf.data = buf;
		if (ioctl(devfd, LMLOADSYMS, &ldbuf) == -1)
		    err(11, "error transferring stringtable buffer");
	    }
d450 14
a463 11
	    if (errno == EINVAL && !old) {
		if (fileopen & MOD_OPEN)
		    close(modfd);
		/* PART_RESRV is not true since the kernel cleans up
		   after a failed LMREADY */
		fileopen &= ~(MOD_OPEN|PART_RESRV);
		/* try using oldstyle */
		warn("module failed to load using new version; trying old version");
		goto doold;
	    } else
		err(14, "error initializing module");
@


1.21
log
@Don't make the string table pointers into absolute addresses since
ddb will do that for us on the fly.  Also check some return values
to catch short reads.  OK'd by niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.20 1999/08/17 09:13:14 millert Exp $	*/
d284 1
a284 1
	if((modfd = open(out, O_RDWR | O_EXCL | O_CREAT, 0666)) < 0)
@


1.20
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.19 1997/09/17 10:06:32 deraadt Exp $	*/
a197 1
	char *symbuf;
d399 2
a400 1
		read(modfd, buf, sz);
d415 1
a415 30
	     * Transfer the symbol table entries.  First, read them all in,
	     * then adjust their string table pointers, then
	     * copy in bulk.  Then copy the string table itself.
	     */

	    symbuf = malloc(info_buf.a_syms);
	    if (symbuf == 0)
		err(13, "malloc");

	    if (read(modfd, symbuf, info_buf.a_syms) != info_buf.a_syms)
		err(14, "read");
	    numsyms = info_buf.a_syms / sizeof(struct nlist);
	    for (nlp = (struct nlist *)symbuf; 
		 (char *)nlp < symbuf + info_buf.a_syms;
		 nlp++) {
		register int strx;
		strx = nlp->n_un.n_strx;
		if (strx != 0) {
		    /* If a valid name, set the name ptr to point at the
		     * loaded address for the string in the string table.
		     */
		    if (strx > strtablen)
			nlp->n_un.n_name = 0;
		    else
			nlp->n_un.n_name =
			    (char *)(strx + resrv.sym_addr + info_buf.a_syms);
		}
	    }
	    /*
	     * we've fixed the symbol table entries, now load them
d421 2
d424 1
a424 1
		ldbuf.data = symbuf;
a426 1
		symbuf += sz;
d428 4
a431 2
	    free(symbuf - info_buf.a_syms);
	    /* and now read the string table and load it. */
d436 2
a437 1
		read(modfd, buf, sz);
@


1.19
log
@paranoia on the alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.18 1997/09/17 00:57:45 weingart Exp $	*/
a41 1
#include <sys/file.h>
d43 2
d46 2
a47 1
#include <a.out.h>
a50 1
#include <err.h>
a51 1
#include <limits.h>
d297 1
a297 1
	if ((modfd = open(out, O_RDONLY, 0)) == -1)
d370 1
a370 1
	if ((modfd = open(out, O_RDONLY, 0)) == -1)
@


1.18
log
@Wall cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.17 1997/09/17 00:56:42 weingart Exp $	*/
d508 1
a508 1
		char id[16], type[16], offset[16];
d516 1
a516 1
		sprintf(offset, "%ld", sbuf.offset);
@


1.17
log
@Fix up the non alpha && mips section, back out change to print
offset of lkm in hex, as this number gets passed by apinstall to
mknod.  (mknod does not understand hex too well).
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.16 1997/09/11 11:49:51 deraadt Exp $	*/
d516 1
a516 1
		sprintf(offset, "%d", sbuf.offset);
@


1.16
log
@only check magic in certain cases... sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.15 1997/09/11 11:46:09 deraadt Exp $	*/
d77 3
a79 3
#define LDSYMTABLE	"-R"
#define LDTEXTSTART	"-Ttext"
#define LDSYMPREFIX	""
d516 1
a516 1
		sprintf(offset, "%lx", sbuf.offset);
@


1.15
log
@support the binutils ld
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.14 1997/08/24 08:07:02 downsj Exp $	*/
d80 1
d320 1
d326 1
@


1.14
log
@More err()/warn()/etc. argument fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.13 1997/06/25 18:21:35 kstailey Exp $	*/
d72 10
d92 1
a92 1
	snprintf(entrybuf, sizeof entrybuf, "_%s", entry);
d96 3
a98 4
		printf("%s -A %s -e %s -o %s -T %s %s\n",
			_PATH_LD, kernel, entrybuf, outfile,
			addrbuf, object);

d104 2
a105 2
		execl(_PATH_LD, "ld", "-A", kernel, "-e", entrybuf, "-o",
		outfile, "-T", addrbuf, object, NULL);
d191 1
a191 1
	struct nlist nl, *nlp;
d513 1
a513 1
		sprintf(offset, "%d", sbuf.offset);
@


1.13
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.12 1997/03/27 19:57:55 deraadt Exp $	*/
d288 1
a288 1
		err(4, out);
d359 1
a359 1
		err(4, out);
@


1.12
log
@fix -u/-p problems reported by mks@@msc.edu; but be a bit more careful..
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.11 1997/01/18 15:12:44 mickey Exp $	*/
d96 1
a96 1
		outfile, "-T", addrbuf, object, (char *)0);
@


1.11
log
@unlink /tmp file on failure too.
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.10 1997/01/15 23:41:14 millert Exp $	*/
d132 1
a132 1
char modout[80];
d134 4
d147 1
d150 1
a150 1
	if (fileopen & DEV_OPEN)
d152 2
d155 1
a155 1
	if (fileopen & MOD_OPEN)
d157 2
d160 1
a160 1
	if(dounlink && unlink(modout) != 0)
d162 2
d510 3
@


1.10
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.9 1996/09/16 01:37:00 deraadt Exp $	*/
d132 1
d150 3
d166 1
a166 1
	char modout[80], *p;
a501 3

	if(dounlink && unlink(out) != 0)
		err(17, "unlink(%s)", out);
@


1.9
log
@kill /tmp race
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.8 1996/08/29 15:17:38 deraadt Exp $	*/
d175 1
a175 1
	while ((c = getopt(argc, argv, "dvsuqA:e:p:o:")) != EOF) {
@


1.8
log
@lkm ddb symbol table loading. done during the middle ages by jtkohl, merged
to modern day sources by rees@@umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.7 1996/08/13 17:56:06 deraadt Exp $	*/
d260 1
a260 1
	if((modfd = open(out, O_RDWR | O_CREAT, 0666)) < 0)
@


1.7
log
@buf oflow, from pst@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.6 1996/08/05 11:01:17 mickey Exp $	*/
d41 1
d68 1
d164 1
d167 2
d171 1
a171 1
	int sz, bytesleft;
d173 1
d175 1
a175 1
	while ((c = getopt(argc, argv, "dvuqA:e:p:o:")) != EOF) {
d201 3
d284 6
d314 16
a329 1
	if (ioctl(devfd, LMRESERV, &resrv) == -1)
d331 2
d380 63
d454 11
a464 1
	if (ioctl(devfd, LMREADY, &modentry) == -1)
d466 1
@


1.6
log
@new options, hole fixes, user friendly. (from FreeBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.5 1996/07/02 06:37:52 deraadt Exp $	*/
d230 1
a230 1
		sprintf(modout, "%s%sut", _PATH_TMP, p);
@


1.5
log
@simpler usage line
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.4 1996/06/23 14:31:05 deraadt Exp $	*/
d42 1
d50 1
a52 4
#ifndef DFLT_ENTRY
#define	DFLT_ENTRY	"xxxinit"
#endif	/* !DFLT_ENTRY */

a63 1
#define	LINKCMD		"ld -A %s -e _%s -o %s -T %x %s"
d67 2
d70 1
a70 1
int
d76 3
a78 2
	char cmdbuf[1024];
	int error = 0;
d80 2
a81 1
	sprintf(cmdbuf, LINKCMD, kernel, entry, outfile, address, object);
d84 15
a98 1
		printf("%s\n", cmdbuf);
d100 8
a107 18
	switch (system(cmdbuf)) {
	case 0:				/* SUCCESS! */
		break;
	case 1:				/* uninformitive error */
		/*
		 * Someone needs to fix the return values from the NetBSD
		 * ld program -- it's totally uninformative.
		 *
		 * No such file		(4 on SunOS)
		 * Can't write output	(2 on SunOS)
		 * Undefined symbol	(1 on SunOS)
		 * etc.
		 */
	case 127:			/* can't load shell */
	case 32512:
	default:
		error = 1;
		break;
d110 2
a111 1
	return error;
d118 1
a118 1
	fprintf(stderr, "usage: modload [-d] [-v] [-A <kernel>] [-e <entry]\n");
d156 1
a156 1
	char *entry = DFLT_ENTRY;
d169 1
a169 1
	while ((c = getopt(argc, argv, "dvA:e:p:o:")) != EOF) {
d177 6
d221 2
a222 4
	strcpy(modout, modobj);

	p = strrchr(modout, '.');
	if (!p || strcmp(p, ".o"))
d225 6
d232 17
a248 1
		*p = '\0';
d251 4
d258 1
a258 2
	if (linkcmd(kname, entry, out, 0, modobj))
		errx(1, "can't prelink `%s' creating `%s'", modobj, out);
d306 1
a306 3
	if (linkcmd(kname, entry, out, resrv.addr, modobj))
		errx(1, "can't link `%s' creating `%s' bound to 0x%08x",
		    modobj, out, resrv.addr);
d366 2
a367 1
	printf("Module loaded as ID %d\n", resrv.slot);
d392 3
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: modload.c,v 1.13 1995/05/28 05:21:58 jtc Exp $	*/
d112 1
a112 2
	fprintf(stderr, "usage:\n");
	fprintf(stderr, "modload [-d] [-v] [-A <kernel>] [-e <entry]\n");
d114 1
a114 1
	    "[-p <postinstall>] [-o <output file>] <input file>\n");
@


1.3
log
@updates according to the kernel changes.
@
text
@d1 1
@


1.2
log
@use strrchr() instead of strchr() to find .o extension; from explorer@@flame.org; netbsd pr#1868
@
text
@d340 1
d344 1
@


1.1
log
@Initial revision
@
text
@d211 1
a211 1
	p = strchr(modout, '.');
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
