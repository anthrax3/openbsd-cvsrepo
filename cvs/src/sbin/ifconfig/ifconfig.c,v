head	1.340;
access;
symbols
	OPENBSD_6_1:1.340.0.4
	OPENBSD_6_1_BASE:1.340
	OPENBSD_6_0:1.324.0.2
	OPENBSD_6_0_BASE:1.324
	OPENBSD_5_9:1.315.0.2
	OPENBSD_5_9_BASE:1.315
	OPENBSD_5_8:1.299.0.4
	OPENBSD_5_8_BASE:1.299
	OPENBSD_5_7:1.296.0.2
	OPENBSD_5_7_BASE:1.296
	OPENBSD_5_6:1.287.0.4
	OPENBSD_5_6_BASE:1.287
	OPENBSD_5_5:1.281.0.4
	OPENBSD_5_5_BASE:1.281
	OPENBSD_5_4:1.267.0.2
	OPENBSD_5_4_BASE:1.267
	OPENBSD_5_3:1.260.0.2
	OPENBSD_5_3_BASE:1.260
	OPENBSD_5_2:1.255.0.2
	OPENBSD_5_2_BASE:1.255
	OPENBSD_5_1_BASE:1.254
	OPENBSD_5_1:1.254.0.2
	OPENBSD_5_0:1.248.0.2
	OPENBSD_5_0_BASE:1.248
	OPENBSD_4_9:1.244.0.2
	OPENBSD_4_9_BASE:1.244
	OPENBSD_4_8:1.239.0.2
	OPENBSD_4_8_BASE:1.239
	OPENBSD_4_7:1.228.0.2
	OPENBSD_4_7_BASE:1.228
	OPENBSD_4_6:1.220.0.4
	OPENBSD_4_6_BASE:1.220
	OPENBSD_4_5:1.214.0.2
	OPENBSD_4_5_BASE:1.214
	OPENBSD_4_4:1.202.0.2
	OPENBSD_4_4_BASE:1.202
	OPENBSD_4_3:1.193.0.2
	OPENBSD_4_3_BASE:1.193
	OPENBSD_4_2:1.185.0.2
	OPENBSD_4_2_BASE:1.185
	OPENBSD_4_1:1.177.0.2
	OPENBSD_4_1_BASE:1.177
	OPENBSD_4_0:1.174.0.2
	OPENBSD_4_0_BASE:1.174
	OPENBSD_3_9:1.156.0.2
	OPENBSD_3_9_BASE:1.156
	OPENBSD_3_8:1.148.0.2
	OPENBSD_3_8_BASE:1.148
	OPENBSD_3_7:1.131.0.2
	OPENBSD_3_7_BASE:1.131
	OPENBSD_3_6:1.112.0.2
	OPENBSD_3_6_BASE:1.112
	OPENBSD_3_5:1.93.0.2
	OPENBSD_3_5_BASE:1.93
	OPENBSD_3_4:1.78.0.2
	OPENBSD_3_4_BASE:1.78
	OPENBSD_3_3:1.73.0.2
	OPENBSD_3_3_BASE:1.73
	OPENBSD_3_2:1.69.0.2
	OPENBSD_3_2_BASE:1.69
	OPENBSD_3_1:1.61.0.2
	OPENBSD_3_1_BASE:1.61
	OPENBSD_3_0:1.52.0.2
	OPENBSD_3_0_BASE:1.52
	OPENBSD_2_9:1.46.0.2
	OPENBSD_2_9_BASE:1.46
	OPENBSD_2_8:1.40.0.2
	OPENBSD_2_8_BASE:1.40
	OPENBSD_2_7:1.36.0.2
	OPENBSD_2_7_BASE:1.36
	OPENBSD_2_6:1.22.0.4
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.340
date	2017.03.21.07.24.36;	author stsp;	state Exp;
branches;
next	1.339;
commitid	iijjeoDM14oM7IlD;

1.339
date	2017.03.12.03.18.57;	author stsp;	state Exp;
branches;
next	1.338;
commitid	FZ3aWtaFiuysCstS;

1.338
date	2017.03.11.13.22.36;	author stsp;	state Exp;
branches;
next	1.337;
commitid	Xn9kwljCeGOAIQo7;

1.337
date	2017.01.21.08.31.44;	author krw;	state Exp;
branches;
next	1.336;
commitid	6pABae7LLaEPI7Ds;

1.336
date	2016.12.25.20.30.41;	author krw;	state Exp;
branches;
next	1.335;
commitid	ALHQLQcKN7UxSqzC;

1.335
date	2016.12.20.13.26.24;	author stsp;	state Exp;
branches;
next	1.334;
commitid	5wiWM4wlLaHFV75w;

1.334
date	2016.12.13.01.36.21;	author dlg;	state Exp;
branches;
next	1.333;
commitid	6eTfxf9VwYbGm2FT;

1.333
date	2016.11.10.14.36.03;	author gerhard;	state Exp;
branches;
next	1.332;
commitid	FNFyJ0IczkbzTxVM;

1.332
date	2016.11.08.14.37.20;	author mestre;	state Exp;
branches;
next	1.331;
commitid	MDxYDs8BHYnGeAkm;

1.331
date	2016.10.17.10.49.17;	author rzalamena;	state Exp;
branches;
next	1.330;
commitid	AxVKE9zdebhRz93B;

1.330
date	2016.09.03.13.46.57;	author reyk;	state Exp;
branches;
next	1.329;
commitid	3QjHFZLzmkdTcUlc;

1.329
date	2016.09.02.10.01.36;	author goda;	state Exp;
branches;
next	1.328;
commitid	CnmnHsRybZkqp1q2;

1.328
date	2016.08.31.13.32.27;	author stsp;	state Exp;
branches;
next	1.327;
commitid	1udNucPPlNlQ2K2n;

1.327
date	2016.08.19.09.06.24;	author jsg;	state Exp;
branches;
next	1.326;
commitid	h5N5ecm3dUph4tJW;

1.326
date	2016.08.15.22.16.46;	author stsp;	state Exp;
branches;
next	1.325;
commitid	icL0SJKH7J0qm0nM;

1.325
date	2016.08.03.20.45.36;	author vgross;	state Exp;
branches;
next	1.324;
commitid	EgBxC3FDOK7pS58H;

1.324
date	2016.06.15.19.39.33;	author gerhard;	state Exp;
branches;
next	1.323;
commitid	qJ1QnDnimibODQ30;

1.323
date	2016.06.10.20.33.29;	author vgross;	state Exp;
branches;
next	1.322;
commitid	qJaxh4rw41tBg4CK;

1.322
date	2016.05.03.17.52.33;	author jca;	state Exp;
branches;
next	1.321;
commitid	L3tiTRqCZWCR676H;

1.321
date	2016.04.28.13.51.22;	author stsp;	state Exp;
branches;
next	1.320;
commitid	Kyf8CPNC3XJKVxRJ;

1.320
date	2016.04.18.06.20.23;	author mpi;	state Exp;
branches;
next	1.319;
commitid	cxhQDDB2dari5Ysb;

1.319
date	2016.04.06.11.48.51;	author dlg;	state Exp;
branches;
next	1.318;
commitid	EzJttXw1SXGZd3vR;

1.318
date	2016.04.06.01.39.17;	author dlg;	state Exp;
branches;
next	1.317;
commitid	I7Iih9Zz95k60P8S;

1.317
date	2016.03.02.19.45.10;	author deraadt;	state Exp;
branches;
next	1.316;
commitid	XSmnOVqsJMeuQsNW;

1.316
date	2016.03.02.00.00.16;	author dlg;	state Exp;
branches;
next	1.315;
commitid	7U01XYSlRSFgd0i5;

1.315
date	2016.01.13.09.35.45;	author stsp;	state Exp;
branches;
next	1.314;
commitid	H0dumgG8uq0U5zIf;

1.314
date	2016.01.06.21.37.00;	author tedu;	state Exp;
branches;
next	1.313;
commitid	ADGZ3vQeJdRe3zGt;

1.313
date	2016.01.03.10.33.27;	author mpi;	state Exp;
branches;
next	1.312;
commitid	9ZIeXzCFNX2Y8Mkf;

1.312
date	2016.01.01.12.50.54;	author jung;	state Exp;
branches;
next	1.311;
commitid	8IIMaC0cJOa4CSJm;

1.311
date	2015.12.10.17.26.59;	author mmcc;	state Exp;
branches;
next	1.310;
commitid	82PdNqu2kKAuXPfA;

1.310
date	2015.12.09.16.02.44;	author mpi;	state Exp;
branches;
next	1.309;
commitid	dWN6O6G4C9o1wbRv;

1.309
date	2015.12.06.12.52.18;	author tedu;	state Exp;
branches;
next	1.308;
commitid	4AbX0DAKRlL3ZE2w;

1.308
date	2015.12.06.12.50.05;	author tedu;	state Exp;
branches;
next	1.307;
commitid	elXp5QtailrWrL5N;

1.307
date	2015.11.25.10.52.25;	author mpi;	state Exp;
branches;
next	1.306;
commitid	vqwn4ePv1Eo1YMLk;

1.306
date	2015.11.23.17.53.52;	author mpi;	state Exp;
branches;
next	1.305;
commitid	Sthfhk5YQjGo1AoJ;

1.305
date	2015.11.23.10.33.23;	author mpi;	state Exp;
branches;
next	1.304;
commitid	GNCoxFV4viKHTEo1;

1.304
date	2015.10.24.10.52.05;	author reyk;	state Exp;
branches;
next	1.303;
commitid	PvSfHvj4AhI0uuuE;

1.303
date	2015.10.23.01.19.04;	author dlg;	state Exp;
branches;
next	1.302;
commitid	amrA8l73DaZf9wmS;

1.302
date	2015.10.03.10.44.23;	author florian;	state Exp;
branches;
next	1.301;
commitid	ZIIAgj3OLK4duGNy;

1.301
date	2015.09.11.15.59.40;	author stsp;	state Exp;
branches;
next	1.300;
commitid	nil1urMhQWdYWbnJ;

1.300
date	2015.09.11.13.02.59;	author stsp;	state Exp;
branches;
next	1.299;
commitid	isOwKO8LPCUHPoSF;

1.299
date	2015.07.26.22.37.40;	author chl;	state Exp;
branches;
next	1.298;
commitid	PlEahhB4CHLSTkef;

1.298
date	2015.07.22.06.20.06;	author deraadt;	state Exp;
branches;
next	1.297;
commitid	YxEhAMnTa8ltA808;

1.297
date	2015.07.21.17.50.23;	author rzalamena;	state Exp;
branches;
next	1.296;
commitid	CXiYaPyeDo1B1hx9;

1.296
date	2015.02.05.10.30.25;	author henning;	state Exp;
branches;
next	1.295;
commitid	nTKZrvRbilvDJOOP;

1.295
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.294;
commitid	Uu5nFG3wCl0LACBb;

1.294
date	2015.01.09.20.34.21;	author sthen;	state Exp;
branches;
next	1.293;
commitid	w6lKJJggebn63qFk;

1.293
date	2015.01.06.21.26.46;	author stsp;	state Exp;
branches;
next	1.292;
commitid	jH0HZyR3DaPVl7Rm;

1.292
date	2015.01.04.12.30.39;	author mpi;	state Exp;
branches;
next	1.291;
commitid	uLVzG3ADzuSENelw;

1.291
date	2015.01.03.06.09.36;	author jsg;	state Exp;
branches;
next	1.290;
commitid	jJTFWN5hpm8EqLOy;

1.290
date	2015.01.01.22.53.39;	author krw;	state Exp;
branches;
next	1.289;
commitid	gtpj4sg3JzENq0LL;

1.289
date	2014.11.14.15.09.29;	author tedu;	state Exp;
branches;
next	1.288;
commitid	lXrAiJOHB8wa4nqw;

1.288
date	2014.11.14.15.03.11;	author henning;	state Exp;
branches;
next	1.287;
commitid	pWaUyUJQETUp7UJ4;

1.287
date	2014.07.12.19.58.17;	author henning;	state Exp;
branches;
next	1.286;
commitid	8YALSqjkdVpdmoe8;

1.286
date	2014.07.11.16.41.51;	author henning;	state Exp;
branches;
next	1.285;
commitid	nXkyPJ4jX9VvnbZu;

1.285
date	2014.07.10.14.32.28;	author stsp;	state Exp;
branches;
next	1.284;
commitid	l6yVFVZyUhUAysk2;

1.284
date	2014.06.23.18.44.43;	author henning;	state Exp;
branches;
next	1.283;
commitid	WOHuY3uSvbPH3IuW;

1.283
date	2014.05.12.08.47.37;	author beck;	state Exp;
branches;
next	1.282;

1.282
date	2014.03.05.20.46.50;	author tedu;	state Exp;
branches;
next	1.281;

1.281
date	2014.01.21.21.27.14;	author benno;	state Exp;
branches;
next	1.280;

1.280
date	2013.12.01.10.05.29;	author stsp;	state Exp;
branches;
next	1.279;

1.279
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.278;

1.278
date	2013.11.21.17.24.34;	author millert;	state Exp;
branches;
next	1.277;

1.277
date	2013.11.12.04.59.02;	author deraadt;	state Exp;
branches;
next	1.276;

1.276
date	2013.11.05.21.04.52;	author bluhm;	state Exp;
branches;
next	1.275;

1.275
date	2013.10.28.15.05.35;	author deraadt;	state Exp;
branches;
next	1.274;

1.274
date	2013.10.17.16.27.39;	author bluhm;	state Exp;
branches;
next	1.273;

1.273
date	2013.10.13.12.19.30;	author reyk;	state Exp;
branches;
next	1.272;

1.272
date	2013.10.13.10.10.00;	author reyk;	state Exp;
branches;
next	1.271;

1.271
date	2013.10.09.20.23.46;	author reyk;	state Exp;
branches;
next	1.270;

1.270
date	2013.09.13.14.32.53;	author florian;	state Exp;
branches;
next	1.269;

1.269
date	2013.08.19.11.20.57;	author dcoppa;	state Exp;
branches;
next	1.268;

1.268
date	2013.08.16.12.29.17;	author mpi;	state Exp;
branches;
next	1.267;

1.267
date	2013.07.16.08.21.10;	author mpi;	state Exp;
branches;
next	1.266;

1.266
date	2013.07.10.07.46.10;	author mpi;	state Exp;
branches;
next	1.265;

1.265
date	2013.07.02.14.25.08;	author bluhm;	state Exp;
branches;
next	1.264;

1.264
date	2013.05.31.19.56.06;	author yasuoka;	state Exp;
branches;
next	1.263;

1.263
date	2013.04.25.06.41.46;	author otto;	state Exp;
branches;
next	1.262;

1.262
date	2013.04.19.18.11.13;	author deraadt;	state Exp;
branches;
next	1.261;

1.261
date	2013.04.03.16.28.10;	author deraadt;	state Exp;
branches;
next	1.260;

1.260
date	2012.12.04.14.54.32;	author deraadt;	state Exp;
branches;
next	1.259;

1.259
date	2012.12.04.04.48.10;	author deraadt;	state Exp;
branches;
next	1.258;

1.258
date	2012.11.23.20.12.38;	author sthen;	state Exp;
branches;
next	1.257;

1.257
date	2012.09.06.19.41.59;	author tedu;	state Exp;
branches;
next	1.256;

1.256
date	2012.08.21.19.50.39;	author bluhm;	state Exp;
branches;
next	1.255;

1.255
date	2012.04.15.03.10.43;	author jsg;	state Exp;
branches;
next	1.254;

1.254
date	2012.02.02.12.34.37;	author benno;	state Exp;
branches;
next	1.253;

1.253
date	2011.12.04.06.26.10;	author haesbaert;	state Exp;
branches;
next	1.252;

1.252
date	2011.11.26.23.38.18;	author haesbaert;	state Exp;
branches;
next	1.251;

1.251
date	2011.11.02.02.03.47;	author haesbaert;	state Exp;
branches;
next	1.250;

1.250
date	2011.09.19.20.29.10;	author henning;	state Exp;
branches;
next	1.249;

1.249
date	2011.08.21.06.28.31;	author haesbaert;	state Exp;
branches;
next	1.248;

1.248
date	2011.07.09.00.45.40;	author henning;	state Exp;
branches;
next	1.247;

1.247
date	2011.05.26.13.10.11;	author sthen;	state Exp;
branches;
next	1.246;

1.246
date	2011.03.23.18.36.41;	author jsg;	state Exp;
branches;
next	1.245;

1.245
date	2011.03.13.15.31.41;	author stsp;	state Exp;
branches;
next	1.244;

1.244
date	2011.03.01.09.37.31;	author claudio;	state Exp;
branches;
next	1.243;

1.243
date	2011.02.17.06.46.30;	author camield;	state Exp;
branches;
next	1.242;

1.242
date	2010.11.09.21.14.47;	author jsg;	state Exp;
branches;
next	1.241;

1.241
date	2010.11.01.05.24.58;	author deraadt;	state Exp;
branches;
next	1.240;

1.240
date	2010.10.18.04.10.57;	author deraadt;	state Exp;
branches;
next	1.239;

1.239
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.238;

1.238
date	2010.07.02.22.03.40;	author deraadt;	state Exp;
branches;
next	1.237;

1.237
date	2010.06.26.19.51.12;	author claudio;	state Exp;
branches;
next	1.236;

1.236
date	2010.06.07.14.50.34;	author claudio;	state Exp;
branches;
next	1.235;

1.235
date	2010.06.04.08.53.24;	author claudio;	state Exp;
branches;
next	1.234;

1.234
date	2010.06.03.21.57.12;	author stsp;	state Exp;
branches;
next	1.233;

1.233
date	2010.05.28.12.20.06;	author claudio;	state Exp;
branches;
next	1.232;

1.232
date	2010.05.06.12.58.40;	author claudio;	state Exp;
branches;
next	1.231;

1.231
date	2010.04.06.14.12.10;	author stsp;	state Exp;
branches;
next	1.230;

1.230
date	2010.04.03.03.13.01;	author deraadt;	state Exp;
branches;
next	1.229;

1.229
date	2010.04.02.21.16.24;	author deraadt;	state Exp;
branches;
next	1.228;

1.228
date	2010.01.10.03.58.14;	author guenther;	state Exp;
branches;
next	1.227;

1.227
date	2009.12.22.17.48.49;	author deraadt;	state Exp;
branches;
next	1.226;

1.226
date	2009.12.14.17.22.58;	author deraadt;	state Exp;
branches;
next	1.225;

1.225
date	2009.12.14.17.14.56;	author deraadt;	state Exp;
branches;
next	1.224;

1.224
date	2009.12.09.21.21.57;	author deraadt;	state Exp;
branches;
next	1.223;

1.223
date	2009.11.22.22.00.24;	author claudio;	state Exp;
branches;
next	1.222;

1.222
date	2009.11.22.18.45.19;	author claudio;	state Exp;
branches;
next	1.221;

1.221
date	2009.11.21.14.09.41;	author claudio;	state Exp;
branches;
next	1.220;

1.220
date	2009.06.19.14.05.32;	author henning;	state Exp;
branches;
next	1.219;

1.219
date	2009.06.14.00.16.50;	author dlg;	state Exp;
branches;
next	1.218;

1.218
date	2009.06.11.20.15.28;	author chl;	state Exp;
branches;
next	1.217;

1.217
date	2009.06.05.00.06.52;	author claudio;	state Exp;
branches;
next	1.216;

1.216
date	2009.06.04.19.07.21;	author henning;	state Exp;
branches;
next	1.215;

1.215
date	2009.04.27.22.52.55;	author deraadt;	state Exp;
branches;
next	1.214;

1.214
date	2009.02.16.20.04.12;	author canacar;	state Exp;
branches;
next	1.213;

1.213
date	2009.02.15.08.34.36;	author damien;	state Exp;
branches;
next	1.212;

1.212
date	2009.02.13.17.24.54;	author damien;	state Exp;
branches;
next	1.211;

1.211
date	2009.02.06.22.07.04;	author grange;	state Exp;
branches;
next	1.210;

1.210
date	2008.12.15.15.50.30;	author fgsch;	state Exp;
branches;
next	1.209;

1.209
date	2008.12.12.22.09.26;	author claudio;	state Exp;
branches;
next	1.208;

1.208
date	2008.11.24.04.30.32;	author stevesk;	state Exp;
branches;
next	1.207;

1.207
date	2008.11.17.22.23.14;	author mpf;	state Exp;
branches;
next	1.206;

1.206
date	2008.09.30.13.11.48;	author deraadt;	state Exp;
branches;
next	1.205;

1.205
date	2008.09.09.20.45.23;	author reyk;	state Exp;
branches;
next	1.204;

1.204
date	2008.09.09.13.56.38;	author henning;	state Exp;
branches;
next	1.203;

1.203
date	2008.09.07.02.22.34;	author deraadt;	state Exp;
branches;
next	1.202;

1.202
date	2008.07.17.08.14.24;	author sthen;	state Exp;
branches;
next	1.201;

1.201
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.200;

1.200
date	2008.06.15.06.56.09;	author mpf;	state Exp;
branches;
next	1.199;

1.199
date	2008.06.14.21.46.22;	author reyk;	state Exp;
branches;
next	1.198;

1.198
date	2008.06.13.06.58.20;	author reyk;	state Exp;
branches;
next	1.197;

1.197
date	2008.05.06.13.33.50;	author pyr;	state Exp;
branches;
next	1.196;

1.196
date	2008.05.06.12.13.57;	author markus;	state Exp;
branches;
next	1.195;

1.195
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.194;

1.194
date	2008.03.29.18.56.43;	author damien;	state Exp;
branches;
next	1.193;

1.193
date	2008.02.05.22.57.30;	author mpf;	state Exp;
branches;
next	1.192;

1.192
date	2007.11.27.16.21.02;	author chl;	state Exp;
branches;
next	1.191;

1.191
date	2007.11.27.13.15.42;	author chl;	state Exp;
branches;
next	1.190;

1.190
date	2007.11.22.01.21.40;	author mpf;	state Exp;
branches;
next	1.189;

1.189
date	2007.10.31.21.13.41;	author mikeb;	state Exp;
branches;
next	1.188;

1.188
date	2007.10.09.21.41.54;	author joel;	state Exp;
branches;
next	1.187;

1.187
date	2007.09.02.15.19.23;	author deraadt;	state Exp;
branches;
next	1.186;

1.186
date	2007.08.25.20.05.30;	author henning;	state Exp;
branches;
next	1.185;

1.185
date	2007.07.31.06.37.48;	author pyr;	state Exp;
branches;
next	1.184;

1.184
date	2007.07.30.14.13.29;	author pyr;	state Exp;
branches;
next	1.183;

1.183
date	2007.07.30.12.34.30;	author pyr;	state Exp;
branches;
next	1.182;

1.182
date	2007.06.19.06.24.28;	author pyr;	state Exp;
branches;
next	1.181;

1.181
date	2007.06.14.18.31.50;	author reyk;	state Exp;
branches;
next	1.180;

1.180
date	2007.06.13.06.46.26;	author henning;	state Exp;
branches;
next	1.179;

1.179
date	2007.06.05.21.14.07;	author kurt;	state Exp;
branches;
next	1.178;

1.178
date	2007.05.26.01.02.53;	author krw;	state Exp;
branches;
next	1.177;

1.177
date	2006.11.15.01.53.00;	author itojun;	state Exp;
branches;
next	1.176;

1.176
date	2006.11.10.20.04.24;	author mk;	state Exp;
branches;
next	1.175;

1.175
date	2006.09.30.23.44.17;	author ray;	state Exp;
branches;
next	1.174;

1.174
date	2006.08.29.17.22.00;	author henning;	state Exp;
branches;
next	1.173;

1.173
date	2006.08.18.08.21.08;	author deraadt;	state Exp;
branches;
next	1.172;

1.172
date	2006.08.02.07.38.33;	author grunk;	state Exp;
branches;
next	1.171;

1.171
date	2006.07.25.13.59.17;	author grunk;	state Exp;
branches;
next	1.170;

1.170
date	2006.06.27.21.47.10;	author reyk;	state Exp;
branches;
next	1.169;

1.169
date	2006.06.27.20.55.51;	author reyk;	state Exp;
branches;
next	1.168;

1.168
date	2006.06.23.21.41.30;	author reyk;	state Exp;
branches;
next	1.167;

1.167
date	2006.06.15.16.19.59;	author deraadt;	state Exp;
branches;
next	1.166;

1.166
date	2006.06.14.18.46.21;	author deraadt;	state Exp;
branches;
next	1.165;

1.165
date	2006.06.11.18.47.58;	author jmc;	state Exp;
branches;
next	1.164;

1.164
date	2006.06.03.14.59.44;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2006.06.02.19.53.12;	author mpf;	state Exp;
branches;
next	1.162;

1.162
date	2006.06.01.21.01.10;	author claudio;	state Exp;
branches;
next	1.161;

1.161
date	2006.06.01.18.54.19;	author beck;	state Exp;
branches;
next	1.160;

1.160
date	2006.05.17.03.29.55;	author reyk;	state Exp;
branches;
next	1.159;

1.159
date	2006.03.23.14.20.09;	author mcbride;	state Exp;
branches;
next	1.158;

1.158
date	2006.03.21.14.23.29;	author claudio;	state Exp;
branches;
next	1.157;

1.157
date	2006.03.20.20.12.45;	author dhill;	state Exp;
branches;
next	1.156;

1.156
date	2006.01.05.15.00.10;	author norby;	state Exp;
branches;
next	1.155;

1.155
date	2005.11.28.10.14.34;	author markus;	state Exp;
branches;
next	1.154;

1.154
date	2005.11.15.00.38.34;	author jmc;	state Exp;
branches;
next	1.153;

1.153
date	2005.11.14.15.06.09;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2005.11.01.07.54.26;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2005.10.10.10.28.19;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2005.10.03.01.35.12;	author reyk;	state Exp;
branches;
next	1.149;

1.149
date	2005.09.15.13.52.39;	author pedro;	state Exp;
branches;
next	1.148;

1.148
date	2005.08.10.19.31.55;	author sturm;	state Exp;
branches;
next	1.147;

1.147
date	2005.06.24.15.26.33;	author jolan;	state Exp;
branches;
next	1.146;

1.146
date	2005.06.23.14.26.37;	author mickey;	state Exp;
branches;
next	1.145;

1.145
date	2005.06.12.00.42.55;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2005.06.08.19.03.55;	author henning;	state Exp;
branches;
next	1.143;

1.143
date	2005.05.31.20.54.38;	author jmc;	state Exp;
branches;
next	1.142;

1.142
date	2005.05.26.03.39.57;	author henning;	state Exp;
branches;
next	1.141;

1.141
date	2005.05.26.02.15.42;	author frantzen;	state Exp;
branches;
next	1.140;

1.140
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.139;

1.139
date	2005.05.24.07.51.53;	author reyk;	state Exp;
branches;
next	1.138;

1.138
date	2005.05.24.02.45.18;	author reyk;	state Exp;
branches;
next	1.137;

1.137
date	2005.05.22.00.02.28;	author henning;	state Exp;
branches;
next	1.136;

1.136
date	2005.04.14.10.23.37;	author henning;	state Exp;
branches;
next	1.135;

1.135
date	2005.04.12.12.15.53;	author markus;	state Exp;
branches;
next	1.134;

1.134
date	2005.04.11.21.05.01;	author cloder;	state Exp;
branches;
next	1.133;

1.133
date	2005.04.04.16.03.02;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2005.03.30.02.55.37;	author tedu;	state Exp;
branches;
next	1.131;

1.131
date	2005.02.15.19.45.22;	author reyk;	state Exp;
branches;
next	1.130;

1.130
date	2005.01.20.17.47.38;	author mcbride;	state Exp;
branches;
next	1.129;

1.129
date	2005.01.18.21.51.14;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2005.01.18.21.43.54;	author claudio;	state Exp;
branches;
next	1.127;

1.127
date	2004.12.29.19.32.34;	author claudio;	state Exp;
branches;
next	1.126;

1.126
date	2004.12.25.17.52.45;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2004.12.07.20.40.18;	author mcbride;	state Exp;
branches;
next	1.124;

1.124
date	2004.12.07.20.32.10;	author mcbride;	state Exp;
branches;
next	1.123;

1.123
date	2004.12.07.10.26.49;	author jmc;	state Exp;
branches;
next	1.122;

1.122
date	2004.12.07.00.10.05;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2004.12.01.15.57.44;	author jmc;	state Exp;
branches;
next	1.120;

1.120
date	2004.11.28.23.39.45;	author canacar;	state Exp;
branches;
next	1.119;

1.119
date	2004.11.17.01.47.20;	author itojun;	state Exp;
branches;
next	1.118;

1.118
date	2004.11.06.00.54.19;	author reyk;	state Exp;
branches;
next	1.117;

1.117
date	2004.11.02.11.38.04;	author henning;	state Exp;
branches;
next	1.116;

1.116
date	2004.11.02.02.33.26;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2004.11.02.02.12.16;	author reyk;	state Exp;
branches;
next	1.114;

1.114
date	2004.10.11.10.13.49;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2004.09.15.21.27.01;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2004.08.08.19.04.25;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2004.08.03.05.36.32;	author mcbride;	state Exp;
branches;
next	1.110;

1.110
date	2004.07.03.20.24.48;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2004.07.03.20.24.16;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2004.06.26.17.36.33;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2004.06.26.06.59.17;	author alex;	state Exp;
branches;
next	1.106;

1.106
date	2004.06.26.04.00.05;	author pb;	state Exp;
branches;
next	1.105;

1.105
date	2004.06.26.03.12.08;	author pb;	state Exp;
branches;
next	1.104;

1.104
date	2004.06.26.00.01.36;	author pb;	state Exp;
branches;
next	1.103;

1.103
date	2004.06.25.18.24.23;	author pb;	state Exp;
branches;
next	1.102;

1.102
date	2004.06.24.20.44.06;	author henning;	state Exp;
branches;
next	1.101;

1.101
date	2004.06.21.23.41.53;	author millert;	state Exp;
branches;
next	1.100;

1.100
date	2004.05.29.17.54.46;	author jcs;	state Exp;
branches;
next	1.99;

1.99
date	2004.05.18.10.54.07;	author otto;	state Exp;
branches;
next	1.98;

1.98
date	2004.05.10.18.34.42;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2004.05.05.22.20.17;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2004.04.27.22.14.11;	author pb;	state Exp;
branches;
next	1.95;

1.95
date	2004.04.27.21.13.09;	author jmc;	state Exp;
branches;
next	1.94;

1.94
date	2004.04.27.17.33.52;	author pb;	state Exp;
branches;
next	1.93;

1.93
date	2004.03.18.20.52.13;	author mcbride;	state Exp;
branches;
next	1.92;

1.92
date	2004.03.15.08.52.17;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2004.03.08.17.21.52;	author mcbride;	state Exp;
branches;
next	1.90;

1.90
date	2004.02.26.20.25.09;	author millert;	state Exp;
branches;
next	1.89;

1.89
date	2004.01.13.01.42.45;	author mcbride;	state Exp;
branches;
next	1.88;

1.88
date	2003.12.23.14.52.12;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2003.12.15.07.11.29;	author mcbride;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.08.09.09.03;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.07.15.30.24;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2003.12.03.13.28.36;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.09.06.04.17;	author mcbride;	state Exp;
branches;
next	1.82;

1.82
date	2003.10.19.05.43.35;	author mcbride;	state Exp;
branches;
next	1.81;

1.81
date	2003.10.17.21.04.57;	author mcbride;	state Exp;
branches;
next	1.80;

1.80
date	2003.09.24.21.12.12;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2003.09.23.03.04.16;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2003.07.30.01.42.47;	author pvalchev;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.26.07.27.32;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.11.06.22.13;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.74;

1.74
date	2003.05.14.02.02.56;	author itojun;	state Exp;
branches;
next	1.73;

1.73
date	2003.03.16.05.20.27;	author margarida;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.24.20.39.28;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.24.17.39.04;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2002.11.23.15.08.50;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2002.07.08.00.48.54;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.19.18.53.53;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.14.09.12.43;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.14.01.07.45;	author itojun;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.10.22.18.48;	author markus;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.22.08.21.02;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2002.04.26.04.40.42;	author fgsch;	state Exp;
branches;
next	1.62;

1.62
date	2002.04.25.08.55.16;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2002.04.10.18.52.27;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2002.02.23.22.07.20;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2002.02.21.23.05.13;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.19.01.16.38;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.17.19.42.27;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.16.21.27.35;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.13.18.08.21;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.30.22.00.15;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.19.01.51.34;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.18.20.39.43;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.25.17.41.06;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.07.18.26.13;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.07.13.53.26;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.02.06.44.23;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.01.08.34.37;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.20.13.50.53;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.18.04.46.03;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2000.12.30.21.56.44;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2000.12.18.07.00.17;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.10.18.18.05;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2000.08.03.07.34.41;	author angelos;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2000.06.30.18.17.58;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2000.05.22.03.04.11;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2000.05.15.11.23.51;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.28.04.44.58;	author chris;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.26.19.03.46;	author chris;	state Exp;
branches;
next	1.34;

1.34
date	2000.04.14.02.40.01;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2000.04.14.02.38.21;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2000.04.11.18.08.42;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.18.08.13.31;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.18.05.46.10;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.18.05.23.55;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.15.23.56.24;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.09.05.56.58;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	99.12.27.04.19.42;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	99.12.27.03.14.39;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	99.12.20.09.28.47;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	99.12.08.07.45.30;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	99.02.24.21.26.03;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.02.24.21.24.47;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.09.03.23.08.09;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	98.09.03.06.24.18;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	98.07.09.06.12.09;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.07.07.07.26.15;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.03.20.02.45.28;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	98.03.20.02.22.29;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	98.03.20.02.13.28;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	98.03.17.08.10.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.12.31.11.16.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.09.20.07.51.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.14.10.37.44;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.08.24.20.31.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.01.18.54.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.17.14.43.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.21.18.10.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.19.06.01.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.09.22.41;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.06.17.46.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.35;	author deraadt;	state Exp;
branches;
next	;

1.40.2.1
date	2001.01.02.20.09.42;	author jason;	state Exp;
branches;
next	;


desc
@@


1.340
log
@Replace a magic number with the corresponding macro from ieee80211_ioctl.h.
No functional change.
ok deraadt@@ tb@@
@
text
@/*	$OpenBSD: ifconfig.c,v 1.339 2017/03/12 03:18:57 stsp Exp $	*/
/*	$NetBSD: ifconfig.c,v 1.40 1997/10/01 02:19:43 enami Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1997, 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/param.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>
#include <arpa/inet.h>
#include <netinet/ip_ipsp.h>
#include <netinet/if_ether.h>
#include <net/if_enc.h>
#include <net80211/ieee80211.h>
#include <net80211/ieee80211_ioctl.h>
#include <net/pfvar.h>
#include <net/if_pfsync.h>
#include <net/if_pflow.h>
#include <net/if_pppoe.h>
#include <net/if_trunk.h>
#include <net/if_sppp.h>
#include <net/ppp_defs.h>

#include <netinet/ip_carp.h>

#include <netdb.h>

#include <net/if_vlan_var.h>

#include <netmpls/mpls.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>
#include <ifaddrs.h>

#include "brconfig.h"
#ifndef SMALL
#include <dev/usb/mbim.h>
#include <dev/usb/if_umb.h>
#endif /* SMALL */

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

#define HWFEATURESBITS							\
	"\024\1CSUM_IPv4\2CSUM_TCPv4\3CSUM_UDPv4"			\
	"\5VLAN_MTU\6VLAN_HWTAGGING\10CSUM_TCPv6"			\
	"\11CSUM_UDPv6\20WOL"

struct	ifreq		ifr, ridreq;
struct	in_aliasreq	in_addreq;
struct	in6_ifreq	ifr6;
struct	in6_ifreq	in6_ridreq;
struct	in6_aliasreq	in6_addreq;
struct	sockaddr_in	netmask;

#ifndef SMALL
struct	ifaliasreq	addreq;

int	wconfig = 0;
int	wcwconfig = 0;
struct	ifmpwreq	imrsave;
#endif /* SMALL */

char	name[IFNAMSIZ];
int	flags, xflags, setaddr, setipdst, doalias;
u_long	metric, mtu;
int	rdomainid;
int	llprio;
int	clearaddr, s;
int	newaddr = 0;
int	af = AF_INET;
int	explicit_prefix = 0;
int	Lflag = 1;

int	showmediaflag;
int	showcapsflag;
int	shownet80211chans;
int	shownet80211nodes;
int	showclasses;

void	notealias(const char *, int);
void	setifaddr(const char *, int);
void	setifrtlabel(const char *, int);
void	setiflladdr(const char *, int);
void	setifdstaddr(const char *, int);
void	setifflags(const char *, int);
void	setifxflags(const char *, int);
void	addaf(const char *, int);
void	removeaf(const char *, int);
void	setifbroadaddr(const char *, int);
void	setifmtu(const char *, int);
void	setifllprio(const char *, int);
void	setifnwid(const char *, int);
void	setifbssid(const char *, int);
void	setifnwkey(const char *, int);
void	setifwpa(const char *, int);
void	setifwpaprotos(const char *, int);
void	setifwpaakms(const char *, int);
void	setifwpaciphers(const char *, int);
void	setifwpagroupcipher(const char *, int);
void	setifwpakey(const char *, int);
void	setifchan(const char *, int);
void	setifscan(const char *, int);
void	setifnwflag(const char *, int);
void	unsetifnwflag(const char *, int);
void	setifnetmask(const char *, int);
void	setifprefixlen(const char *, int);
void	settunnel(const char *, const char *);
void	deletetunnel(const char *, int);
void	settunnelinst(const char *, int);
void	settunnelttl(const char *, int);
void	setvnetid(const char *, int);
void	delvnetid(const char *, int);
void	getvnetid(void);
void	setifparent(const char *, int);
void	delifparent(const char *, int);
void	getifparent(void);
void	setia6flags(const char *, int);
void	setia6pltime(const char *, int);
void	setia6vltime(const char *, int);
void	setia6lifetime(const char *, const char *);
void	setia6eui64(const char *, int);
void	setkeepalive(const char *, const char *);
void	unsetkeepalive(const char *, int);
void	setmedia(const char *, int);
void	setmediaopt(const char *, int);
void	setmediamode(const char *, int);
void	unsetmediamode(const char *, int);
void	clone_create(const char *, int);
void	clone_destroy(const char *, int);
void	unsetmediaopt(const char *, int);
void	setmediainst(const char *, int);
void	settimeslot(const char *, int);
void	timeslot_status(void);
void	setmpelabel(const char *, int);
void	process_mpw_commands(void);
void	setmpwencap(const char *, int);
void	setmpwlabel(const char *, const char *);
void	setmpwneighbor(const char *, int);
void	setmpwcontrolword(const char *, int);
void	setvlantag(const char *, int);
void	setvlandev(const char *, int);
void	unsetvlandev(const char *, int);
void	mpe_status(void);
void	mpw_status(void);
void	vlan_status(void);
void	setrdomain(const char *, int);
int	prefix(void *val, int);
void	getifgroups(void);
void	setifgroup(const char *, int);
void	unsetifgroup(const char *, int);
void	setgroupattribs(char *, int, char *[]);
int	printgroup(char *, int);
void	setautoconf(const char *, int);
void	settrunkport(const char *, int);
void	unsettrunkport(const char *, int);
void	settrunkproto(const char *, int);
void	trunk_status(void);
void	list_cloners(void);

#ifndef SMALL
void	carp_status(void);
void	setcarp_advbase(const char *,int);
void	setcarp_advskew(const char *, int);
void	setcarppeer(const char *, int);
void	unsetcarppeer(const char *, int);
void	setcarp_passwd(const char *, int);
void	setcarp_vhid(const char *, int);
void	setcarp_state(const char *, int);
void	setcarpdev(const char *, int);
void	setcarp_nodes(const char *, int);
void	setcarp_balancing(const char *, int);
void	setpfsync_syncdev(const char *, int);
void	setpfsync_maxupd(const char *, int);
void	unsetpfsync_syncdev(const char *, int);
void	setpfsync_syncpeer(const char *, int);
void	unsetpfsync_syncpeer(const char *, int);
void	setpfsync_defer(const char *, int);
void	pfsync_status(void);
void	setpppoe_dev(const char *,int);
void	setpppoe_svc(const char *,int);
void	setpppoe_ac(const char *,int);
void	pppoe_status(void);
void	setspppproto(const char *, int);
void	setspppname(const char *, int);
void	setspppkey(const char *, int);
void	setsppppeerproto(const char *, int);
void	setsppppeername(const char *, int);
void	setsppppeerkey(const char *, int);
void	setsppppeerflag(const char *, int);
void	unsetsppppeerflag(const char *, int);
void	sppp_status(void);
void	sppp_printproto(const char *, struct sauthreq *);
void	setifpriority(const char *, int);
void	setifpowersave(const char *, int);
void	setifmetric(const char *, int);
void	pflow_status(void);
void	pflow_addr(const char*, struct sockaddr_storage *);
void	setpflow_sender(const char *, int);
void	unsetpflow_sender(const char *, int);
void	setpflow_receiver(const char *, int);
void	unsetpflow_receiver(const char *, int);
void	setpflowproto(const char *, int);
void	setifipdst(const char *, int);
void	setifdesc(const char *, int);
void	unsetifdesc(const char *, int);
void	printifhwfeatures(const char *, int);
void	setpair(const char *, int);
void	unsetpair(const char *, int);
void	umb_status(void);
void	umb_printclasses(char *, int);
int	umb_parse_classes(const char *);
void	umb_setpin(const char *, int);
void	umb_chgpin(const char *, const char *);
void	umb_puk(const char *, const char *);
void	umb_pinop(int, int, const char *, const char *);
void	umb_apn(const char *, int);
void	umb_setclass(const char *, int);
void	umb_roaming(const char *, int);
void	utf16_to_char(uint16_t *, int, char *, size_t);
int	char_to_utf16(const char *, uint16_t *, size_t);
#else
void	setignore(const char *, int);
#endif

/*
 * Media stuff.  Whenever a media command is first performed, the
 * currently select media is grabbed for this interface.  If `media'
 * is given, the current media word is modified.  `mediaopt' commands
 * only modify the set and clear words.  They then operate on the
 * current media word later.
 */
uint64_t	media_current;
uint64_t	mediaopt_set;
uint64_t	mediaopt_clear;

int	actions;			/* Actions performed */

#define	A_MEDIA		0x0001		/* media command */
#define	A_MEDIAOPTSET	0x0002		/* mediaopt command */
#define	A_MEDIAOPTCLR	0x0004		/* -mediaopt command */
#define	A_MEDIAOPT	(A_MEDIAOPTSET|A_MEDIAOPTCLR)
#define	A_MEDIAINST	0x0008		/* instance or inst command */
#define	A_MEDIAMODE	0x0010		/* mode command */
#define A_SILENT	0x8000000	/* doing operation, do not print */

#define	NEXTARG0	0xffffff
#define NEXTARG		0xfffffe
#define	NEXTARG2	0xfffffd

const struct	cmd {
	char	*c_name;
	int	c_parameter;		/* NEXTARG means next argv */
	int	c_action;		/* defered action */
	void	(*c_func)(const char *, int);
	void	(*c_func2)(const char *, const char *);
} cmds[] = {
	{ "up",		IFF_UP,		0,		setifflags } ,
	{ "down",	-IFF_UP,	0,		setifflags },
	{ "arp",	-IFF_NOARP,	0,		setifflags },
	{ "-arp",	IFF_NOARP,	0,		setifflags },
	{ "debug",	IFF_DEBUG,	0,		setifflags },
	{ "-debug",	-IFF_DEBUG,	0,		setifflags },
	{ "alias",	IFF_UP,		0,		notealias },
	{ "-alias",	-IFF_UP,	0,		notealias },
	{ "delete",	-IFF_UP,	0,		notealias },
#ifdef notdef
#define	EN_SWABIPS	0x1000
	{ "swabips",	EN_SWABIPS,	0,		setifflags },
	{ "-swabips",	-EN_SWABIPS,	0,		setifflags },
#endif /* notdef */
	{ "netmask",	NEXTARG,	0,		setifnetmask },
	{ "mtu",	NEXTARG,	0,		setifmtu },
	{ "nwid",	NEXTARG,	0,		setifnwid },
	{ "-nwid",	-1,		0,		setifnwid },
	{ "bssid",	NEXTARG,	0,		setifbssid },
	{ "-bssid",	-1,		0,		setifbssid },
	{ "nwkey",	NEXTARG,	0,		setifnwkey },
	{ "-nwkey",	-1,		0,		setifnwkey },
	{ "wpa",	1,		0,		setifwpa },
	{ "-wpa",	0,		0,		setifwpa },
	{ "wpaakms",	NEXTARG,	0,		setifwpaakms },
	{ "wpaciphers",	NEXTARG,	0,		setifwpaciphers },
	{ "wpagroupcipher", NEXTARG,	0,		setifwpagroupcipher },
	{ "wpaprotos",	NEXTARG,	0,		setifwpaprotos },
	{ "wpakey",	NEXTARG,	0,		setifwpakey },
	{ "-wpakey",	-1,		0,		setifwpakey },
	{ "chan",	NEXTARG0,	0,		setifchan },
	{ "-chan",	-1,		0,		setifchan },
	{ "scan",	NEXTARG0,	0,		setifscan },
	{ "broadcast",	NEXTARG,	0,		setifbroadaddr },
	{ "prefixlen",  NEXTARG,	0,		setifprefixlen},
	{ "vlan",	NEXTARG,	0,		setvlantag },
	{ "vlandev",	NEXTARG,	0,		setvlandev },
	{ "-vlandev",	1,		0,		unsetvlandev },
	{ "group",	NEXTARG,	0,		setifgroup },
	{ "-group",	NEXTARG,	0,		unsetifgroup },
	{ "autoconf",	1,		0,		setautoconf },
	{ "-autoconf",	-1,		0,		setautoconf },
	{ "trunkport",	NEXTARG,	0,		settrunkport },
	{ "-trunkport",	NEXTARG,	0,		unsettrunkport },
	{ "trunkproto",	NEXTARG,	0,		settrunkproto },
	{ "anycast",	IN6_IFF_ANYCAST,	0,	setia6flags },
	{ "-anycast",	-IN6_IFF_ANYCAST,	0,	setia6flags },
	{ "tentative",	IN6_IFF_TENTATIVE,	0,	setia6flags },
	{ "-tentative",	-IN6_IFF_TENTATIVE,	0,	setia6flags },
	{ "pltime",	NEXTARG,	0,		setia6pltime },
	{ "vltime",	NEXTARG,	0,		setia6vltime },
	{ "eui64",	0,		0,		setia6eui64 },
	{ "autoconfprivacy",	-IFXF_INET6_NOPRIVACY,	0,	setifxflags },
	{ "-autoconfprivacy",	IFXF_INET6_NOPRIVACY,	0,	setifxflags },
#ifndef SMALL
	{ "hwfeatures", NEXTARG0,	0,		printifhwfeatures },
	{ "metric",	NEXTARG,	0,		setifmetric },
	{ "powersave",	NEXTARG0,	0,		setifpowersave },
	{ "-powersave",	-1,		0,		setifpowersave },
	{ "priority",	NEXTARG,	0,		setifpriority },
	{ "rtlabel",	NEXTARG,	0,		setifrtlabel },
	{ "-rtlabel",	-1,		0,		setifrtlabel },
	{ "rdomain",	NEXTARG,	0,		setrdomain },
	{ "mpls",	IFXF_MPLS,	0,		setifxflags },
	{ "-mpls",	-IFXF_MPLS,	0,		setifxflags },
	{ "mplslabel",	NEXTARG,	0,		setmpelabel },
	{ "mpwlabel",	NEXTARG2,	0,		NULL, setmpwlabel },
	{ "neighbor",	NEXTARG,	0,		setmpwneighbor },
	{ "controlword", 1,		0,		setmpwcontrolword },
	{ "-controlword", 0,		0,		setmpwcontrolword },
	{ "encap",	NEXTARG,	0,		setmpwencap },
	{ "advbase",	NEXTARG,	0,		setcarp_advbase },
	{ "advskew",	NEXTARG,	0,		setcarp_advskew },
	{ "carppeer",	NEXTARG,	0,		setcarppeer },
	{ "-carppeer",	1,		0,		unsetcarppeer },
	{ "pass",	NEXTARG,	0,		setcarp_passwd },
	{ "vhid",	NEXTARG,	0,		setcarp_vhid },
	{ "state",	NEXTARG,	0,		setcarp_state },
	{ "carpdev",	NEXTARG,	0,		setcarpdev },
	{ "carpnodes",	NEXTARG,	0,		setcarp_nodes },
	{ "balancing",	NEXTARG,	0,		setcarp_balancing },
	{ "syncdev",	NEXTARG,	0,		setpfsync_syncdev },
	{ "-syncdev",	1,		0,		unsetpfsync_syncdev },
	{ "syncif",	NEXTARG,	0,		setpfsync_syncdev },
	{ "-syncif",	1,		0,		unsetpfsync_syncdev },
	{ "syncpeer",	NEXTARG,	0,		setpfsync_syncpeer },
	{ "-syncpeer",	1,		0,		unsetpfsync_syncpeer },
	{ "maxupd",	NEXTARG,	0,		setpfsync_maxupd },
	{ "defer",	1,		0,		setpfsync_defer },
	{ "-defer",	0,		0,		setpfsync_defer },
	/* giftunnel is for backward compat */
	{ "giftunnel",  NEXTARG2,	0,		NULL, settunnel } ,
	{ "tunnel",	NEXTARG2,	0,		NULL, settunnel } ,
	{ "deletetunnel",  0,		0,		deletetunnel } ,
	{ "tunneldomain", NEXTARG,	0,		settunnelinst } ,
	{ "tunnelttl",	NEXTARG,	0,		settunnelttl } ,
	{ "vnetid",	NEXTARG,	0,		setvnetid },
	{ "-vnetid",	0,		0,		delvnetid },
	{ "parent",	NEXTARG,	0,		setifparent },
	{ "-parent",	1,		0,		delifparent },
	{ "pppoedev",	NEXTARG,	0,		setpppoe_dev },
	{ "pppoesvc",	NEXTARG,	0,		setpppoe_svc },
	{ "-pppoesvc",	1,		0,		setpppoe_svc },
	{ "pppoeac",	NEXTARG,	0,		setpppoe_ac },
	{ "-pppoeac",	1,		0,		setpppoe_ac },
	{ "timeslot",	NEXTARG,	0,		settimeslot },
	{ "authproto",	NEXTARG,	0,		setspppproto },
	{ "authname",	NEXTARG,	0,		setspppname },
	{ "authkey",	NEXTARG,	0,		setspppkey },
	{ "peerproto",	NEXTARG,	0,		setsppppeerproto },
	{ "peername",	NEXTARG,	0,		setsppppeername },
	{ "peerkey",	NEXTARG,	0,		setsppppeerkey },
	{ "peerflag",	NEXTARG,	0,		setsppppeerflag },
	{ "-peerflag",	NEXTARG,	0,		unsetsppppeerflag },
	{ "nwflag",	NEXTARG,	0,		setifnwflag },
	{ "-nwflag",	NEXTARG,	0,		unsetifnwflag },
	{ "flowsrc",	NEXTARG,	0,		setpflow_sender },
	{ "-flowsrc",	1,		0,		unsetpflow_sender },
	{ "flowdst",	NEXTARG,	0,		setpflow_receiver },
	{ "-flowdst", 1,		0,		unsetpflow_receiver },
	{ "pflowproto", NEXTARG,	0,		setpflowproto },
	{ "-inet",	AF_INET,	0,		removeaf },
	{ "-inet6",	AF_INET6,	0,		removeaf },
	{ "keepalive",	NEXTARG2,	0,		NULL, setkeepalive },
	{ "-keepalive",	1,		0,		unsetkeepalive },
	{ "add",	NEXTARG,	0,		bridge_add },
	{ "del",	NEXTARG,	0,		bridge_delete },
	{ "addspan",	NEXTARG,	0,		bridge_addspan },
	{ "delspan",	NEXTARG,	0,		bridge_delspan },
	{ "discover",	NEXTARG,	0,		setdiscover },
	{ "-discover",	NEXTARG,	0,		unsetdiscover },
	{ "blocknonip", NEXTARG,	0,		setblocknonip },
	{ "-blocknonip",NEXTARG,	0,		unsetblocknonip },
	{ "learn",	NEXTARG,	0,		setlearn },
	{ "-learn",	NEXTARG,	0,		unsetlearn },
	{ "stp",	NEXTARG,	0,		setstp },
	{ "-stp",	NEXTARG,	0,		unsetstp },
	{ "edge",	NEXTARG,	0,		setedge },
	{ "-edge",	NEXTARG,	0,		unsetedge },
	{ "autoedge",	NEXTARG,	0,		setautoedge },
	{ "-autoedge",	NEXTARG,	0,		unsetautoedge },
	{ "ptp",	NEXTARG,	0,		setptp },
	{ "-ptp",	NEXTARG,	0,		unsetptp },
	{ "autoptp",	NEXTARG,	0,		setautoptp },
	{ "-autoptp",	NEXTARG,	0,		unsetautoptp },
	{ "flush",	0,		0,		bridge_flush },
	{ "flushall",	0,		0,		bridge_flushall },
	{ "static",	NEXTARG2,	0,		NULL, bridge_addaddr },
	{ "deladdr",	NEXTARG,	0,		bridge_deladdr },
	{ "maxaddr",	NEXTARG,	0,		bridge_maxaddr },
	{ "addr",	0,		0,		bridge_addrs },
	{ "hellotime",	NEXTARG,	0,		bridge_hellotime },
	{ "fwddelay",	NEXTARG,	0,		bridge_fwddelay },
	{ "maxage",	NEXTARG,	0,		bridge_maxage },
	{ "proto",	NEXTARG,	0,		bridge_proto },
	{ "ifpriority",	NEXTARG2,	0,		NULL, bridge_ifprio },
	{ "ifcost",	NEXTARG2,	0,		NULL, bridge_ifcost },
	{ "-ifcost",	NEXTARG,	0,		bridge_noifcost },
	{ "timeout",	NEXTARG,	0,		bridge_timeout },
	{ "holdcnt",	NEXTARG,	0,		bridge_holdcnt },
	{ "spanpriority", NEXTARG,	0,		bridge_priority },
	{ "ipdst",	NEXTARG,	0,		setifipdst },
#if 0
	/* XXX `rule` special-cased below */
	{ "rule",	0,		0,		bridge_rule },
#endif
	{ "rules",	NEXTARG,	0,		bridge_rules },
	{ "rulefile",	NEXTARG,	0,		bridge_rulefile },
	{ "flushrule",	NEXTARG,	0,		bridge_flushrule },
	{ "description", NEXTARG,	0,		setifdesc },
	{ "descr",	NEXTARG,	0,		setifdesc },
	{ "-description", 1,		0,		unsetifdesc },
	{ "-descr",	1,		0,		unsetifdesc },
	{ "wol",	IFXF_WOL,	0,		setifxflags },
	{ "-wol",	-IFXF_WOL,	0,		setifxflags },
	{ "pin",	NEXTARG,	0,		umb_setpin },
	{ "chgpin",	NEXTARG2,	0,		NULL, umb_chgpin },
	{ "puk",	NEXTARG2,	0,		NULL, umb_puk },
	{ "apn",	NEXTARG,	0,		umb_apn },
	{ "-apn",	-1,		0,		umb_apn },
	{ "class",	NEXTARG0,	0,		umb_setclass },
	{ "-class",	-1,		0,		umb_setclass },
	{ "roaming",	1,		0,		umb_roaming },
	{ "-roaming",	0,		0,		umb_roaming },
	{ "patch",	NEXTARG,	0,		setpair },
	{ "-patch",	1,		0,		unsetpair },
	{ "datapath",	NEXTARG,	0,		switch_datapathid },
	{ "portno",	NEXTARG2,	0,		NULL, switch_portno },
	{ "addlocal",	NEXTARG,	0,		addlocal },
#else /* SMALL */
	{ "powersave",	NEXTARG0,	0,		setignore },
	{ "priority",	NEXTARG,	0,		setignore },
	{ "rtlabel",	NEXTARG,	0,		setignore },
	{ "mpls",	IFXF_MPLS,	0,		setignore },
	{ "nwflag",	NEXTARG,	0,		setignore },
	{ "rdomain",	NEXTARG,	0,		setignore },
	{ "-inet",	AF_INET,	0,		removeaf },
	{ "-inet6",	AF_INET6,	0,		removeaf },
	{ "description", NEXTARG,	0,		setignore },
	{ "descr",	NEXTARG,	0,		setignore },
	{ "wol",	IFXF_WOL,	0,		setignore },
	{ "-wol",	-IFXF_WOL,	0,		setignore },
#endif /* SMALL */
#if 0
	/* XXX `create' special-cased below */
	{ "create",	0,		0,		clone_create } ,
#endif
	{ "destroy",	0,		0,		clone_destroy } ,
	{ "link0",	IFF_LINK0,	0,		setifflags } ,
	{ "-link0",	-IFF_LINK0,	0,		setifflags } ,
	{ "link1",	IFF_LINK1,	0,		setifflags } ,
	{ "-link1",	-IFF_LINK1,	0,		setifflags } ,
	{ "link2",	IFF_LINK2,	0,		setifflags } ,
	{ "-link2",	-IFF_LINK2,	0,		setifflags } ,
	{ "media",	NEXTARG0,	A_MEDIA,	setmedia },
	{ "mediaopt",	NEXTARG,	A_MEDIAOPTSET,	setmediaopt },
	{ "-mediaopt",	NEXTARG,	A_MEDIAOPTCLR,	unsetmediaopt },
	{ "mode",	NEXTARG,	A_MEDIAMODE,	setmediamode },
	{ "-mode",	0,		A_MEDIAMODE,	unsetmediamode },
	{ "instance",	NEXTARG,	A_MEDIAINST,	setmediainst },
	{ "inst",	NEXTARG,	A_MEDIAINST,	setmediainst },
	{ "lladdr",	NEXTARG,	0,		setiflladdr },
	{ "llprio",	NEXTARG,	0,		setifllprio },
	{ NULL, /*src*/	0,		0,		setifaddr },
	{ NULL, /*dst*/	0,		0,		setifdstaddr },
	{ NULL, /*illegal*/0,		0,		NULL },
};

int	getinfo(struct ifreq *, int);
void	getsock(int);
void	printgroupattribs(char *);
void	printif(char *, int);
void	printb_status(unsigned short, unsigned char *);
const char *get_linkstate(int, int);
void	status(int, struct sockaddr_dl *, int);
__dead void	usage(void);
const char *get_string(const char *, const char *, u_int8_t *, int *);
void	print_string(const u_int8_t *, int);
char	*sec2str(time_t);

const char *get_media_type_string(uint64_t);
const char *get_media_subtype_string(uint64_t);
uint64_t	get_media_mode(uint64_t, const char *);
uint64_t	get_media_subtype(uint64_t, const char *);
uint64_t	get_media_options(uint64_t, const char *);
uint64_t	lookup_media_word(const struct ifmedia_description *, uint64_t,
	    const char *);
void	print_media_word(uint64_t, int, int);
void	process_media_commands(void);
void	init_current_media(void);

unsigned long get_ts_map(int, int, int);

void	in_status(int);
void	in_getaddr(const char *, int);
void	in_getprefix(const char *, int);
void	in6_fillscopeid(struct sockaddr_in6 *sin6);
void	in6_alias(struct in6_ifreq *);
void	in6_status(int);
void	in6_getaddr(const char *, int);
void	in6_getprefix(const char *, int);
void	ieee80211_status(void);
void	ieee80211_listchans(void);
void	ieee80211_listnodes(void);
void	ieee80211_printnode(struct ieee80211_nodereq *);
u_int	getwpacipher(const char *name);
void	print_cipherset(u_int32_t cipherset);

void	spppauthinfo(struct sauthreq *spa, int d);

/* Known address families */
const struct afswtch {
	char *af_name;
	short af_af;
	void (*af_status)(int);
	void (*af_getaddr)(const char *, int);
	void (*af_getprefix)(const char *, int);
	u_long af_difaddr;
	u_long af_aifaddr;
	caddr_t af_ridreq;
	caddr_t af_addreq;
} afs[] = {
#define C(x) ((caddr_t) &x)
	{ "inet", AF_INET, in_status, in_getaddr, in_getprefix,
	    SIOCDIFADDR, SIOCAIFADDR, C(ridreq), C(in_addreq) },
	{ "inet6", AF_INET6, in6_status, in6_getaddr, in6_getprefix,
	    SIOCDIFADDR_IN6, SIOCAIFADDR_IN6, C(in6_ridreq), C(in6_addreq) },
	{ 0,	0,	    0,		0 }
};

const struct afswtch *afp;	/*the address family being set or asked about*/

int ifaliases = 0;
int aflag = 0;

int
main(int argc, char *argv[])
{
	const struct afswtch *rafp = NULL;
	int create = 0;
	int Cflag = 0;
	int gflag = 0;
	int i;

	/* If no args at all, print all interfaces.  */
	if (argc < 2) {
		aflag = 1;
		printif(NULL, 0);
		return (0);
	}
	argc--, argv++;
	if (*argv[0] == '-') {
		int nomore = 0;

		for (i = 1; argv[0][i]; i++) {
			switch (argv[0][i]) {
			case 'a':
				aflag = 1;
				nomore = 1;
				break;
			case 'A':
				aflag = 1;
				ifaliases = 1;
				nomore = 1;
				break;
			case 'g':
				gflag = 1;
				break;
			case 'C':
				Cflag = 1;
				nomore = 1;
				break;
			default:
				usage();
				break;
			}
		}
		if (nomore == 0) {
			argc--, argv++;
			if (argc < 1)
				usage();
			if (strlcpy(name, *argv, sizeof(name)) >= IFNAMSIZ)
				errx(1, "interface name '%s' too long", *argv);
		}
	} else if (strlcpy(name, *argv, sizeof(name)) >= IFNAMSIZ)
		errx(1, "interface name '%s' too long", *argv);
	argc--, argv++;
	if (argc > 0) {
		for (afp = rafp = afs; rafp->af_name; rafp++)
			if (strcmp(rafp->af_name, *argv) == 0) {
				afp = rafp;
				argc--;
				argv++;
				break;
			}
		rafp = afp;
		af = ifr.ifr_addr.sa_family = rafp->af_af;
	}
	if (Cflag) {
		if (argc > 0 || aflag)
			usage();
		list_cloners();
		return (0);
	}
	if (gflag) {
		if (argc == 0)
			printgroupattribs(name);
		else
			setgroupattribs(name, argc, argv);
		return (0);
	}
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));

	/* initialization */
	in6_addreq.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;
	in6_addreq.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;

	/*
	 * NOTE:  We must special-case the `create' command right
	 * here as we would otherwise fail in getinfo().
	 */
	if (argc > 0 && strcmp(argv[0], "create") == 0) {
		clone_create(argv[0], 0);
		argc--, argv++;
		if (argc == 0)
			return (0);
	}
	if (aflag == 0) {
		create = (argc > 0) && strcmp(argv[0], "destroy") != 0;
		(void)getinfo(&ifr, create);
	}

	if (argc != 0 && af == AF_INET6)
		addaf(name, AF_INET6);

	while (argc > 0) {
		const struct cmd *p;

		for (p = cmds; p->c_name; p++)
			if (strcmp(*argv, p->c_name) == 0)
				break;
#ifndef SMALL
		if (strcmp(*argv, "rule") == 0) {
			argc--, argv++;
			return bridge_rule(argc, argv, -1);
		}
#endif
		if (p->c_name == 0 && setaddr)
			for (i = setaddr; i > 0; i--) {
				p++;
				if (p->c_func == NULL)
					errx(1, "%s: bad value", *argv);
			}
		if (p->c_func || p->c_func2) {
			if (p->c_parameter == NEXTARG0) {
				const struct cmd *p0;
				int noarg = 1;

				if (argv[1]) {
					for (p0 = cmds; p0->c_name; p0++)
						if (strcmp(argv[1],
						    p0->c_name) == 0) {
							noarg = 0;
							break;
						}
				} else
					noarg = 0;

				if (noarg == 0)
					(*p->c_func)(NULL, 0);
				else
					goto nextarg;
			} else if (p->c_parameter == NEXTARG) {
nextarg:
				if (argv[1] == NULL)
					errx(1, "'%s' requires argument",
					    p->c_name);
				(*p->c_func)(argv[1], 0);
				argc--, argv++;
				actions = actions | A_SILENT | p->c_action;
			} else if (p->c_parameter == NEXTARG2) {
				if ((argv[1] == NULL) ||
				    (argv[2] == NULL))
					errx(1, "'%s' requires 2 arguments",
					    p->c_name);
				(*p->c_func2)(argv[1], argv[2]);
				argc -= 2;
				argv += 2;
				actions = actions | A_SILENT | p->c_action;
			} else {
				(*p->c_func)(*argv, p->c_parameter);
				actions = actions | A_SILENT | p->c_action;
			}
		}
		argc--, argv++;
	}

	if (argc == 0 && actions == 0) {
		printif(ifr.ifr_name, aflag ? ifaliases : 1);
		return (0);
	}

	/* Process any media commands that may have been issued. */
	process_media_commands();

#ifndef SMALL
	/* Process mpw commands */
	process_mpw_commands();
#endif

	if (af == AF_INET6 && explicit_prefix == 0) {
		/*
		 * Aggregatable address architecture defines all prefixes
		 * are 64. So, it is convenient to set prefixlen to 64 if
		 * it is not specified.
		 */
		setifprefixlen("64", 0);
		/* in6_getprefix("64", MASK) if MASK is available here... */
	}

	if (clearaddr) {
		(void) strlcpy(rafp->af_ridreq, name, sizeof(ifr.ifr_name));
		if (ioctl(s, rafp->af_difaddr, rafp->af_ridreq) < 0) {
			if (errno == EADDRNOTAVAIL && (doalias >= 0)) {
				/* means no previous address for interface */
			} else
				err(1, "SIOCDIFADDR");
		}
	}
	if (newaddr) {
		(void) strlcpy(rafp->af_addreq, name, sizeof(ifr.ifr_name));
		if (ioctl(s, rafp->af_aifaddr, rafp->af_addreq) < 0)
			err(1, "SIOCAIFADDR");
	}
	return (0);
}

void
getsock(int naf)
{
	static int oaf = -1;

	if (oaf == naf)
		return;
	if (oaf != -1)
		close(s);
	s = socket(naf, SOCK_DGRAM, 0);
	if (s < 0)
		oaf = -1;
	else
		oaf = naf;
}

int
getinfo(struct ifreq *ifr, int create)
{

	getsock(af);
	if (s < 0)
		err(1, "socket");
	if (!isdigit((unsigned char)name[strlen(name) - 1]))
		return (-1);	/* ignore groups here */
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)ifr) < 0) {
		int oerrno = errno;

		if (!create)
			return (-1);
		if (ioctl(s, SIOCIFCREATE, (caddr_t)ifr) < 0) {
			errno = oerrno;
			return (-1);
		}
		if (ioctl(s, SIOCGIFFLAGS, (caddr_t)ifr) < 0)
			return (-1);
	}
	flags = ifr->ifr_flags & 0xffff;
	if (ioctl(s, SIOCGIFXFLAGS, (caddr_t)ifr) < 0)
		ifr->ifr_flags = 0;
	xflags = ifr->ifr_flags;
	if (ioctl(s, SIOCGIFMETRIC, (caddr_t)ifr) < 0)
		metric = 0;
	else
		metric = ifr->ifr_metric;
#ifdef SMALL
	if (ioctl(s, SIOCGIFMTU, (caddr_t)ifr) < 0)
#else
	if (is_bridge(name) || ioctl(s, SIOCGIFMTU, (caddr_t)ifr) < 0)
#endif
		mtu = 0;
	else
		mtu = ifr->ifr_mtu;
#ifndef SMALL
	if (ioctl(s, SIOCGIFRDOMAIN, (caddr_t)ifr) < 0)
		rdomainid = 0;
	else
		rdomainid = ifr->ifr_rdomainid;
#endif
	if (ioctl(s, SIOCGIFLLPRIO, (caddr_t)ifr) < 0)
		llprio = 0;
	else
		llprio = ifr->ifr_llprio;

	return (0);
}

int
printgroup(char *groupname, int ifaliases)
{
	struct ifgroupreq	 ifgr;
	struct ifg_req		*ifg;
	int			 len, cnt = 0;

	getsock(AF_INET);
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, groupname, sizeof(ifgr.ifgr_name));
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1) {
		if (errno == EINVAL || errno == ENOTTY ||
		    errno == ENOENT)
			return (-1);
		else
			err(1, "SIOCGIFGMEMB");
	}

	len = ifgr.ifgr_len;
	if ((ifgr.ifgr_groups = calloc(1, len)) == NULL)
		err(1, "printgroup");
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
		err(1, "SIOCGIFGMEMB");

	for (ifg = ifgr.ifgr_groups; ifg && len >= sizeof(struct ifg_req);
	    ifg++) {
		len -= sizeof(struct ifg_req);
		printif(ifg->ifgrq_member, ifaliases);
		cnt++;
	}
	free(ifgr.ifgr_groups);

	return (cnt);
}

void
printgroupattribs(char *groupname)
{
	struct ifgroupreq	 ifgr;

	getsock(AF_INET);
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, groupname, sizeof(ifgr.ifgr_name));
	if (ioctl(s, SIOCGIFGATTR, (caddr_t)&ifgr) == -1)
		err(1, "SIOCGIFGATTR");

	printf("%s:", groupname);
	printf(" carp demote count %d", ifgr.ifgr_attrib.ifg_carp_demoted);
	printf("\n");
}

void
setgroupattribs(char *groupname, int argc, char *argv[])
{
	const char *errstr;
	char *p = argv[0];
	int neg = 1;

	struct ifgroupreq	 ifgr;

	getsock(AF_INET);
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, groupname, sizeof(ifgr.ifgr_name));

	if (argc > 1) {
		neg = strtonum(argv[1], 0, 128, &errstr);
		if (errstr)
			errx(1, "invalid carp demotion: %s", errstr);
	}

	if (p[0] == '-') {
		neg = neg * -1;
		p++;
	}
	if (!strcmp(p, "carpdemote"))
		ifgr.ifgr_attrib.ifg_carp_demoted = neg;
	else
		usage();

	if (ioctl(s, SIOCSIFGATTR, (caddr_t)&ifgr) == -1)
		err(1, "SIOCSIFGATTR");
}

void
printif(char *ifname, int ifaliases)
{
	struct ifaddrs *ifap, *ifa;
	struct if_data *ifdata;
	const char *namep;
	char *oname = NULL;
	struct ifreq *ifrp;
	int count = 0, noinet = 1;
	size_t nlen = 0;

	if (aflag)
		ifname = NULL;
	if (ifname) {
		if ((oname = strdup(ifname)) == NULL)
			err(1, "strdup");
		nlen = strlen(oname);
		/* is it a group? */
		if (nlen && !isdigit((unsigned char)oname[nlen - 1]))
			if (printgroup(oname, ifaliases) != -1) {
				free(oname);
				return;
			}
	}

	if (getifaddrs(&ifap) != 0)
		err(1, "getifaddrs");

	namep = NULL;
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (oname) {
			if (nlen && isdigit((unsigned char)oname[nlen - 1])) {
				/* must have exact match */
				if (strcmp(oname, ifa->ifa_name) != 0)
					continue;
			} else {
				/* partial match OK if it ends w/ digit */
				if (strncmp(oname, ifa->ifa_name, nlen) != 0 ||
				    !isdigit((unsigned char)ifa->ifa_name[nlen]))
					continue;
			}
		}
		/* quickhack: sizeof(ifr) < sizeof(ifr6) */
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			memset(&ifr6, 0, sizeof(ifr6));
			memcpy(&ifr6.ifr_addr, ifa->ifa_addr,
			    MINIMUM(sizeof(ifr6.ifr_addr), ifa->ifa_addr->sa_len));
			ifrp = (struct ifreq *)&ifr6;
		} else {
			memset(&ifr, 0, sizeof(ifr));
			memcpy(&ifr.ifr_addr, ifa->ifa_addr,
			    MINIMUM(sizeof(ifr.ifr_addr), ifa->ifa_addr->sa_len));
			ifrp = &ifr;
		}
		strlcpy(name, ifa->ifa_name, sizeof(name));
		strlcpy(ifrp->ifr_name, ifa->ifa_name, sizeof(ifrp->ifr_name));

		if (ifa->ifa_addr->sa_family == AF_LINK) {
			namep = ifa->ifa_name;
			if (getinfo(ifrp, 0) < 0)
				continue;
			ifdata = ifa->ifa_data;
			status(1, (struct sockaddr_dl *)ifa->ifa_addr,
			    ifdata->ifi_link_state);
			count++;
			noinet = 1;
			continue;
		}

		if (!namep || !strcmp(namep, ifa->ifa_name)) {
			const struct afswtch *p;

			if (ifa->ifa_addr->sa_family == AF_INET &&
			    ifaliases == 0 && noinet == 0)
				continue;
			if ((p = afp) != NULL) {
				if (ifa->ifa_addr->sa_family == p->af_af)
					p->af_status(1);
			} else {
				for (p = afs; p->af_name; p++) {
					if (ifa->ifa_addr->sa_family ==
					    p->af_af)
						p->af_status(0);
				}
			}
			count++;
			if (ifa->ifa_addr->sa_family == AF_INET)
				noinet = 0;
			continue;
		}
	}
	freeifaddrs(ifap);
	free(oname);
	if (count == 0) {
		fprintf(stderr, "%s: no such interface\n", name);
		exit(1);
	}
}

/*ARGSUSED*/
void
clone_create(const char *addr, int param)
{

	/* We're called early... */
	getsock(AF_INET);

	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCIFCREATE, &ifr) == -1)
		err(1, "SIOCIFCREATE");
}

/*ARGSUSED*/
void
clone_destroy(const char *addr, int param)
{

	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCIFDESTROY, &ifr) == -1)
		err(1, "SIOCIFDESTROY");
}

void
list_cloners(void)
{
	struct if_clonereq ifcr;
	char *cp, *buf;
	int idx;

	memset(&ifcr, 0, sizeof(ifcr));

	getsock(AF_INET);

	if (ioctl(s, SIOCIFGCLONERS, &ifcr) == -1)
		err(1, "SIOCIFGCLONERS for count");

	buf = calloc(ifcr.ifcr_total, IFNAMSIZ);
	if (buf == NULL)
		err(1, "unable to allocate cloner name buffer");

	ifcr.ifcr_count = ifcr.ifcr_total;
	ifcr.ifcr_buffer = buf;

	if (ioctl(s, SIOCIFGCLONERS, &ifcr) == -1)
		err(1, "SIOCIFGCLONERS for names");

	/*
	 * In case some disappeared in the mean time, clamp it down.
	 */
	if (ifcr.ifcr_count > ifcr.ifcr_total)
		ifcr.ifcr_count = ifcr.ifcr_total;

	qsort(buf, ifcr.ifcr_count, IFNAMSIZ,
	    (int(*)(const void *, const void *))strcmp);

	for (cp = buf, idx = 0; idx < ifcr.ifcr_count; idx++, cp += IFNAMSIZ) {
		if (idx > 0)
			putchar(' ');
		printf("%s", cp);
	}

	putchar('\n');
	free(buf);
}

#define RIDADDR 0
#define ADDR	1
#define MASK	2
#define DSTADDR	3

/*ARGSUSED*/
void
setifaddr(const char *addr, int param)
{
	/*
	 * Delay the ioctl to set the interface addr until flags are all set.
	 * The address interpretation may depend on the flags,
	 * and the flags may change when the address is set.
	 */
	setaddr++;
	if (doalias >= 0)
		newaddr = 1;
	if (doalias == 0)
		clearaddr = 1;
	afp->af_getaddr(addr, (doalias >= 0 ? ADDR : RIDADDR));
}

#ifndef SMALL
void
setifrtlabel(const char *label, int d)
{
	if (d != 0)
		ifr.ifr_data = (caddr_t)(const char *)"";
	else
		ifr.ifr_data = (caddr_t)label;
	if (ioctl(s, SIOCSIFRTLABEL, &ifr) < 0)
		warn("SIOCSIFRTLABEL");
}
#endif

/* ARGSUSED */
void
setifnetmask(const char *addr, int ignored)
{
	afp->af_getaddr(addr, MASK);
}

/* ARGSUSED */
void
setifbroadaddr(const char *addr, int ignored)
{
	afp->af_getaddr(addr, DSTADDR);
}

#ifndef SMALL
/* ARGSUSED */
void
setifdesc(const char *val, int ignored)
{
	ifr.ifr_data = (caddr_t)val;
	if (ioctl(s, SIOCSIFDESCR, &ifr) < 0)
		warn("SIOCSIFDESCR");
}

/* ARGSUSED */
void
unsetifdesc(const char *noval, int ignored)
{
	ifr.ifr_data = (caddr_t)(const char *)"";
	if (ioctl(s, SIOCSIFDESCR, &ifr) < 0)
		warn("SIOCSIFDESCR");
}

/* ARGSUSED */
void
setifipdst(const char *addr, int ignored)
{
	in_getaddr(addr, DSTADDR);
	setipdst++;
	clearaddr = 0;
	newaddr = 0;
}
#endif

#define rqtosa(x) (&(((struct ifreq *)(afp->x))->ifr_addr))
/*ARGSUSED*/
void
notealias(const char *addr, int param)
{
	if (setaddr && doalias == 0 && param < 0)
		memcpy(rqtosa(af_ridreq), rqtosa(af_addreq),
		    rqtosa(af_addreq)->sa_len);
	doalias = param;
	if (param < 0) {
		clearaddr = 1;
		newaddr = 0;
	} else
		clearaddr = 0;
}

/*ARGSUSED*/
void
setifdstaddr(const char *addr, int param)
{
	setaddr++;
	afp->af_getaddr(addr, DSTADDR);
}

/*
 * Note: doing an SIOCGIFFLAGS scribbles on the union portion
 * of the ifreq structure, which may confuse other parts of ifconfig.
 * Make a private copy so we can avoid that.
 */
/* ARGSUSED */
void
setifflags(const char *vname, int value)
{
	struct ifreq my_ifr;

	bcopy((char *)&ifr, (char *)&my_ifr, sizeof(struct ifreq));

	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&my_ifr) < 0)
		err(1, "SIOCGIFFLAGS");
	(void) strlcpy(my_ifr.ifr_name, name, sizeof(my_ifr.ifr_name));
	flags = my_ifr.ifr_flags;

	if (value < 0) {
		value = -value;
		flags &= ~value;
	} else
		flags |= value;
	my_ifr.ifr_flags = flags;
	if (ioctl(s, SIOCSIFFLAGS, (caddr_t)&my_ifr) < 0)
		err(1, "SIOCSIFFLAGS");
}

/* ARGSUSED */
void
setifxflags(const char *vname, int value)
{
	struct ifreq my_ifr;

	bcopy((char *)&ifr, (char *)&my_ifr, sizeof(struct ifreq));

	if (ioctl(s, SIOCGIFXFLAGS, (caddr_t)&my_ifr) < 0)
		warn("SIOCGIFXFLAGS");
	(void) strlcpy(my_ifr.ifr_name, name, sizeof(my_ifr.ifr_name));
	xflags = my_ifr.ifr_flags;

	if (value < 0) {
		value = -value;
		xflags &= ~value;
	} else
		xflags |= value;
	my_ifr.ifr_flags = xflags;
	if (ioctl(s, SIOCSIFXFLAGS, (caddr_t)&my_ifr) < 0)
		warn("SIOCSIFXFLAGS");
}

void
addaf(const char *vname, int value)
{
	struct if_afreq	ifar;

	strlcpy(ifar.ifar_name, name, sizeof(ifar.ifar_name));
	ifar.ifar_af = value;
	if (ioctl(s, SIOCIFAFATTACH, (caddr_t)&ifar) < 0)
		warn("SIOCIFAFATTACH");
}

void
removeaf(const char *vname, int value)
{
	struct if_afreq	ifar;

	strlcpy(ifar.ifar_name, name, sizeof(ifar.ifar_name));
	ifar.ifar_af = value;
	if (ioctl(s, SIOCIFAFDETACH, (caddr_t)&ifar) < 0)
		warn("SIOCIFAFDETACH");
}

void
setia6flags(const char *vname, int value)
{

	if (value < 0) {
		value = -value;
		in6_addreq.ifra_flags &= ~value;
	} else
		in6_addreq.ifra_flags |= value;
}

void
setia6pltime(const char *val, int d)
{

	setia6lifetime("pltime", val);
}

void
setia6vltime(const char *val, int d)
{

	setia6lifetime("vltime", val);
}

void
setia6lifetime(const char *cmd, const char *val)
{
	const char *errmsg = NULL;
	time_t newval, t;

	newval = strtonum(val, 0, 1000000, &errmsg);
	if (errmsg)
		errx(1, "invalid %s %s: %s", cmd, val, errmsg);

	t = time(NULL);

	if (afp->af_af != AF_INET6)
		errx(1, "%s not allowed for the AF", cmd);
	if (strcmp(cmd, "vltime") == 0) {
		in6_addreq.ifra_lifetime.ia6t_expire = t + newval;
		in6_addreq.ifra_lifetime.ia6t_vltime = newval;
	} else if (strcmp(cmd, "pltime") == 0) {
		in6_addreq.ifra_lifetime.ia6t_preferred = t + newval;
		in6_addreq.ifra_lifetime.ia6t_pltime = newval;
	}
}

void
setia6eui64(const char *cmd, int val)
{
	struct ifaddrs *ifap, *ifa;
	const struct sockaddr_in6 *sin6 = NULL;
	const struct in6_addr *lladdr = NULL;
	struct in6_addr *in6;

	if (afp->af_af != AF_INET6)
		errx(1, "%s not allowed for the AF", cmd);

	addaf(name, AF_INET6);

	in6 = (struct in6_addr *)&in6_addreq.ifra_addr.sin6_addr;
	if (memcmp(&in6addr_any.s6_addr[8], &in6->s6_addr[8], 8) != 0)
		errx(1, "interface index is already filled");
	if (getifaddrs(&ifap) != 0)
		err(1, "getifaddrs");
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family == AF_INET6 &&
		    strcmp(ifa->ifa_name, name) == 0) {
			sin6 = (const struct sockaddr_in6 *)ifa->ifa_addr;
			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
				lladdr = &sin6->sin6_addr;
				break;
			}
		}
	}
	if (!lladdr)
		errx(1, "could not determine link local address");

	memcpy(&in6->s6_addr[8], &lladdr->s6_addr[8], 8);

	freeifaddrs(ifap);
}

void
setautoconf(const char *cmd, int val)
{
	switch (afp->af_af) {
	case AF_INET6:
		setifxflags("inet6", val * IFXF_AUTOCONF6);
		break;
	default:
		errx(1, "autoconf not allowed for this AF");
	}
}

#ifndef SMALL
/* ARGSUSED */
void
setifmetric(const char *val, int ignored)
{
	const char *errmsg = NULL;

	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));

	ifr.ifr_metric = strtonum(val, 0, INT_MAX, &errmsg);
	if (errmsg)
		errx(1, "metric %s: %s", val, errmsg);
	if (ioctl(s, SIOCSIFMETRIC, (caddr_t)&ifr) < 0)
		warn("SIOCSIFMETRIC");
}
#endif

/* ARGSUSED */
void
setifmtu(const char *val, int d)
{
	const char *errmsg = NULL;

	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));

	ifr.ifr_mtu = strtonum(val, 0, INT_MAX, &errmsg);
	if (errmsg)
		errx(1, "mtu %s: %s", val, errmsg);
	if (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) < 0)
		warn("SIOCSIFMTU");
}

/* ARGSUSED */
void
setifllprio(const char *val, int d)
{
	const char *errmsg = NULL;

	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));

	ifr.ifr_llprio = strtonum(val, 0, UCHAR_MAX, &errmsg);
	if (errmsg)
		errx(1, "llprio %s: %s", val, errmsg);
	if (ioctl(s, SIOCSIFLLPRIO, (caddr_t)&ifr) < 0)
		warn("SIOCSIFLLPRIO");
}

/* ARGSUSED */
void
setifgroup(const char *group_name, int dummy)
{
	struct ifgroupreq ifgr;

	memset(&ifgr, 0, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, name, IFNAMSIZ);

	if (group_name[0] &&
	    isdigit((unsigned char)group_name[strlen(group_name) - 1]))
		errx(1, "setifgroup: group names may not end in a digit");

	if (strlcpy(ifgr.ifgr_group, group_name, IFNAMSIZ) >= IFNAMSIZ)
		errx(1, "setifgroup: group name too long");
	if (ioctl(s, SIOCAIFGROUP, (caddr_t)&ifgr) == -1) {
		if (errno != EEXIST)
			err(1," SIOCAIFGROUP");
	}
}

/* ARGSUSED */
void
unsetifgroup(const char *group_name, int dummy)
{
	struct ifgroupreq ifgr;

	memset(&ifgr, 0, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, name, IFNAMSIZ);

	if (group_name[0] &&
	    isdigit((unsigned char)group_name[strlen(group_name) - 1]))
		errx(1, "unsetifgroup: group names may not end in a digit");

	if (strlcpy(ifgr.ifgr_group, group_name, IFNAMSIZ) >= IFNAMSIZ)
		errx(1, "unsetifgroup: group name too long");
	if (ioctl(s, SIOCDIFGROUP, (caddr_t)&ifgr) == -1)
		err(1, "SIOCDIFGROUP");
}

const char *
get_string(const char *val, const char *sep, u_int8_t *buf, int *lenp)
{
	int len = *lenp, hexstr;
	u_int8_t *p = buf;

	hexstr = (val[0] == '0' && tolower((u_char)val[1]) == 'x');
	if (hexstr)
		val += 2;
	for (;;) {
		if (*val == '\0')
			break;
		if (sep != NULL && strchr(sep, *val) != NULL) {
			val++;
			break;
		}
		if (hexstr) {
			if (!isxdigit((u_char)val[0]) ||
			    !isxdigit((u_char)val[1])) {
				warnx("bad hexadecimal digits");
				return NULL;
			}
		}
		if (p > buf + len) {
			if (hexstr)
				warnx("hexadecimal digits too long");
			else
				warnx("strings too long");
			return NULL;
		}
		if (hexstr) {
#define	tohex(x)	(isdigit(x) ? (x) - '0' : tolower(x) - 'a' + 10)
			*p++ = (tohex((u_char)val[0]) << 4) |
			    tohex((u_char)val[1]);
#undef tohex
			val += 2;
		} else {
			if (*val == '\\' &&
			    sep != NULL && strchr(sep, *(val + 1)) != NULL)
				val++;
			*p++ = *val++;
		}
	}
	len = p - buf;
	if (len < *lenp)
		memset(p, 0, *lenp - len);
	*lenp = len;
	return val;
}

void
print_string(const u_int8_t *buf, int len)
{
	int i = 0, hasspc = 0;

	if (len < 2 || buf[0] != '0' || tolower(buf[1]) != 'x') {
		for (; i < len; i++) {
			/* Only print 7-bit ASCII keys */
			if (buf[i] & 0x80 || !isprint(buf[i]))
				break;
			if (isspace(buf[i]))
				hasspc++;
		}
	}
	if (i == len) {
		if (hasspc || len == 0)
			printf("\"%.*s\"", len, buf);
		else
			printf("%.*s", len, buf);
	} else {
		printf("0x");
		for (i = 0; i < len; i++)
			printf("%02x", buf[i]);
	}
}

void
setifnwid(const char *val, int d)
{
	struct ieee80211_nwid nwid;
	int len;

	if (d != 0) {
		/* no network id is especially desired */
		memset(&nwid, 0, sizeof(nwid));
		len = 0;
	} else {
		len = sizeof(nwid.i_nwid);
		if (get_string(val, NULL, nwid.i_nwid, &len) == NULL)
			return;
	}
	nwid.i_len = len;
	(void)strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t)&nwid;
	if (ioctl(s, SIOCS80211NWID, (caddr_t)&ifr) < 0)
		warn("SIOCS80211NWID");
}

void
setifbssid(const char *val, int d)
{

	struct ieee80211_bssid bssid;
	struct ether_addr *ea;

	if (d != 0) {
		/* no BSSID is especially desired */
		memset(&bssid.i_bssid, 0, sizeof(bssid.i_bssid));
	} else {
		ea = ether_aton((char*)val);
		if (ea == NULL) {
			warnx("malformed BSSID: %s", val);
			return;
		}
		memcpy(&bssid.i_bssid, ea->ether_addr_octet,
		    sizeof(bssid.i_bssid));
	}
	strlcpy(bssid.i_name, name, sizeof(bssid.i_name));
	if (ioctl(s, SIOCS80211BSSID, &bssid) == -1)
		warn("SIOCS80211BSSID");
}

void
setifnwkey(const char *val, int d)
{
	int i, len;
	struct ieee80211_nwkey nwkey;
	u_int8_t keybuf[IEEE80211_WEP_NKID][16];

	bzero(&nwkey, sizeof(nwkey));
	bzero(&keybuf, sizeof(keybuf));

	nwkey.i_wepon = IEEE80211_NWKEY_WEP;
	nwkey.i_defkid = 1;
	if (d == -1) {
		/* disable WEP encryption */
		nwkey.i_wepon = IEEE80211_NWKEY_OPEN;
		i = 0;
	} else if (strcasecmp("persist", val) == 0) {
		/* use all values from persistent memory */
		nwkey.i_wepon |= IEEE80211_NWKEY_PERSIST;
		nwkey.i_defkid = 0;
		for (i = 0; i < IEEE80211_WEP_NKID; i++)
			nwkey.i_key[i].i_keylen = -1;
	} else if (strncasecmp("persist:", val, 8) == 0) {
		val += 8;
		/* program keys in persistent memory */
		nwkey.i_wepon |= IEEE80211_NWKEY_PERSIST;
		goto set_nwkey;
	} else {
 set_nwkey:
		if (isdigit((unsigned char)val[0]) && val[1] == ':') {
			/* specifying a full set of four keys */
			nwkey.i_defkid = val[0] - '0';
			val += 2;
			for (i = 0; i < IEEE80211_WEP_NKID; i++) {
				len = sizeof(keybuf[i]);
				val = get_string(val, ",", keybuf[i], &len);
				if (val == NULL)
					return;
				nwkey.i_key[i].i_keylen = len;
				nwkey.i_key[i].i_keydat = keybuf[i];
			}
			if (*val != '\0') {
				warnx("SIOCS80211NWKEY: too many keys.");
				return;
			}
		} else {
			/*
			 * length of each key must be either a 5
			 * character ASCII string or 10 hex digits for
			 * 40 bit encryption, or 13 character ASCII
			 * string or 26 hex digits for 128 bit
			 * encryption.
			 */
			int j;
			char *tmp = NULL;
			size_t vlen = strlen(val);
			switch(vlen) {
			case 10:
			case 26:
				/* 0x must be missing for these lengths */
				j = asprintf(&tmp, "0x%s", val);
				if (j == -1) {
					warnx("malloc failed");
					return;
				}
				val = tmp;
				break;
			case 12:
			case 28:
			case 5:
			case 13:
				/* 0xkey or string case - all is ok */
				break;
			default:
				warnx("Invalid WEP key length");
				return;
			}
			len = sizeof(keybuf[0]);
			val = get_string(val, NULL, keybuf[0], &len);
			free(tmp);
			if (val == NULL)
				return;
			nwkey.i_key[0].i_keylen = len;
			nwkey.i_key[0].i_keydat = keybuf[0];
			i = 1;
		}
	}
	(void)strlcpy(nwkey.i_name, name, sizeof(nwkey.i_name));
	if (ioctl(s, SIOCS80211NWKEY, (caddr_t)&nwkey) == -1)
		warn("SIOCS80211NWKEY");
}

/* ARGSUSED */
void
setifwpa(const char *val, int d)
{
	struct ieee80211_wpaparams wpa;

	memset(&wpa, 0, sizeof(wpa));
	(void)strlcpy(wpa.i_name, name, sizeof(wpa.i_name));
	/* Don't read current values. The kernel will set defaults. */
	wpa.i_enabled = d;
	if (ioctl(s, SIOCS80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCS80211WPAPARMS");
}

/* ARGSUSED */
void
setifwpaprotos(const char *val, int d)
{
	struct ieee80211_wpaparams wpa;
	char *optlist, *str;
	u_int rval = 0;

	if ((optlist = strdup(val)) == NULL)
		err(1, "strdup");
	str = strtok(optlist, ",");
	while (str != NULL) {
		if (strcasecmp(str, "wpa1") == 0)
			rval |= IEEE80211_WPA_PROTO_WPA1;
		else if (strcasecmp(str, "wpa2") == 0)
			rval |= IEEE80211_WPA_PROTO_WPA2;
		else
			errx(1, "wpaprotos: unknown protocol: %s", str);
		str = strtok(NULL, ",");
	}
	free(optlist);

	memset(&wpa, 0, sizeof(wpa));
	(void)strlcpy(wpa.i_name, name, sizeof(wpa.i_name));
	if (ioctl(s, SIOCG80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCG80211WPAPARMS");
	wpa.i_protos = rval;
	/* Let the kernel set up the appropriate default ciphers. */
	wpa.i_ciphers = 0;
	wpa.i_groupcipher = 0;
	if (ioctl(s, SIOCS80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCS80211WPAPARMS");
}

/* ARGSUSED */
void
setifwpaakms(const char *val, int d)
{
	struct ieee80211_wpaparams wpa;
	char *optlist, *str;
	u_int rval = 0;

	if ((optlist = strdup(val)) == NULL)
		err(1, "strdup");
	str = strtok(optlist, ",");
	while (str != NULL) {
		if (strcasecmp(str, "psk") == 0)
			rval |= IEEE80211_WPA_AKM_PSK;
		else if (strcasecmp(str, "802.1x") == 0)
			rval |= IEEE80211_WPA_AKM_8021X;
		else
			errx(1, "wpaakms: unknown akm: %s", str);
		str = strtok(NULL, ",");
	}
	free(optlist);

	memset(&wpa, 0, sizeof(wpa));
	(void)strlcpy(wpa.i_name, name, sizeof(wpa.i_name));
	if (ioctl(s, SIOCG80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCG80211WPAPARMS");
	wpa.i_akms = rval;
	if (ioctl(s, SIOCS80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCS80211WPAPARMS");
}

static const struct {
	const char	*name;
	u_int		cipher;
} ciphers[] = {
	{ "usegroup",	IEEE80211_WPA_CIPHER_USEGROUP },
	{ "wep40",	IEEE80211_WPA_CIPHER_WEP40 },
	{ "tkip",	IEEE80211_WPA_CIPHER_TKIP },
	{ "ccmp",	IEEE80211_WPA_CIPHER_CCMP },
	{ "wep104",	IEEE80211_WPA_CIPHER_WEP104 }
};

u_int
getwpacipher(const char *name)
{
	int i;

	for (i = 0; i < sizeof(ciphers) / sizeof(ciphers[0]); i++)
		if (strcasecmp(name, ciphers[i].name) == 0)
			return ciphers[i].cipher;
	return IEEE80211_WPA_CIPHER_NONE;
}

/* ARGSUSED */
void
setifwpaciphers(const char *val, int d)
{
	struct ieee80211_wpaparams wpa;
	char *optlist, *str;
	u_int rval = 0;

	if ((optlist = strdup(val)) == NULL)
		err(1, "strdup");
	str = strtok(optlist, ",");
	while (str != NULL) {
		u_int cipher = getwpacipher(str);
		if (cipher == IEEE80211_WPA_CIPHER_NONE)
			errx(1, "wpaciphers: unknown cipher: %s", str);

		rval |= cipher;
		str = strtok(NULL, ",");
	}
	free(optlist);

	memset(&wpa, 0, sizeof(wpa));
	(void)strlcpy(wpa.i_name, name, sizeof(wpa.i_name));
	if (ioctl(s, SIOCG80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCG80211WPAPARMS");
	wpa.i_ciphers = rval;
	if (ioctl(s, SIOCS80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCS80211WPAPARMS");
}

/* ARGSUSED */
void
setifwpagroupcipher(const char *val, int d)
{
	struct ieee80211_wpaparams wpa;
	u_int cipher;

	cipher = getwpacipher(val);
	if (cipher == IEEE80211_WPA_CIPHER_NONE)
		errx(1, "wpagroupcipher: unknown cipher: %s", val);

	memset(&wpa, 0, sizeof(wpa));
	(void)strlcpy(wpa.i_name, name, sizeof(wpa.i_name));
	if (ioctl(s, SIOCG80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCG80211WPAPARMS");
	wpa.i_groupcipher = cipher;
	if (ioctl(s, SIOCS80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCS80211WPAPARMS");
}

void
setifwpakey(const char *val, int d)
{
	struct ieee80211_wpaparams wpa;
	struct ieee80211_wpapsk psk;
	struct ieee80211_nwid nwid;
	int passlen;

	memset(&psk, 0, sizeof(psk));
	if (d != -1) {
		memset(&ifr, 0, sizeof(ifr));
		ifr.ifr_data = (caddr_t)&nwid;
		strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
		if (ioctl(s, SIOCG80211NWID, (caddr_t)&ifr))
			err(1, "SIOCG80211NWID");

		passlen = strlen(val);
		if (passlen == 2 + 2 * sizeof(psk.i_psk) &&
		    val[0] == '0' && val[1] == 'x') {
			/* Parse a WPA hex key (must be full-length) */
			passlen = sizeof(psk.i_psk);
			val = get_string(val, NULL, psk.i_psk, &passlen);
			if (val == NULL || passlen != sizeof(psk.i_psk))
				errx(1, "wpakey: invalid pre-shared key");
		} else {
			/* Parse a WPA passphrase */
			if (passlen < 8 || passlen > 63)
				errx(1, "wpakey: passphrase must be between "
				    "8 and 63 characters");
			if (nwid.i_len == 0)
				errx(1, "wpakey: nwid not set");
			if (pkcs5_pbkdf2(val, passlen, nwid.i_nwid, nwid.i_len,
			    psk.i_psk, sizeof(psk.i_psk), 4096) != 0)
				errx(1, "wpakey: passphrase hashing failed");
		}
		psk.i_enabled = 1;
	} else
		psk.i_enabled = 0;

	(void)strlcpy(psk.i_name, name, sizeof(psk.i_name));
	if (ioctl(s, SIOCS80211WPAPSK, (caddr_t)&psk) < 0)
		err(1, "SIOCS80211WPAPSK");

	/* And ... automatically enable or disable WPA */
	memset(&wpa, 0, sizeof(wpa));
	(void)strlcpy(wpa.i_name, name, sizeof(wpa.i_name));
	if (ioctl(s, SIOCG80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCG80211WPAPARMS");
	wpa.i_enabled = psk.i_enabled;
	if (ioctl(s, SIOCS80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCS80211WPAPARMS");
}

void
setifchan(const char *val, int d)
{
	struct ieee80211chanreq channel;
	const char *errstr;
	int chan;

	if (val == NULL) {
		if (shownet80211chans || shownet80211nodes)
			usage();
		shownet80211chans = 1;
		return;
	}
	if (d != 0)
		chan = IEEE80211_CHAN_ANY;
	else {
		chan = strtonum(val, 1, 256, &errstr);
		if (errstr) {
			warnx("invalid channel %s: %s", val, errstr);
			return;
		}
	}

	strlcpy(channel.i_name, name, sizeof(channel.i_name));
	channel.i_channel = (u_int16_t)chan;
	if (ioctl(s, SIOCS80211CHANNEL, (caddr_t)&channel) == -1)
		warn("SIOCS80211CHANNEL");
}

/* ARGSUSED */
void
setifscan(const char *val, int d)
{
	if (shownet80211chans || shownet80211nodes)
		usage();
	shownet80211nodes = 1;
}

#ifndef SMALL

void
setifnwflag(const char *val, int d)
{
	static const struct ieee80211_flags nwflags[] = IEEE80211_FLAGS;
	u_int i, flag = 0;

	for (i = 0; i < (sizeof(nwflags) / sizeof(nwflags[0])); i++) {
		if (strcmp(val, nwflags[i].f_name) == 0) {
			flag = nwflags[i].f_flag;
			break;
		}
	}
	if (flag == 0)
		errx(1, "Invalid nwflag: %s", val);

	if (ioctl(s, SIOCG80211FLAGS, (caddr_t)&ifr) != 0)
		err(1, "SIOCG80211FLAGS");

	if (d)
		ifr.ifr_flags &= ~flag;
	else
		ifr.ifr_flags |= flag;

	if (ioctl(s, SIOCS80211FLAGS, (caddr_t)&ifr) != 0)
		err(1, "SIOCS80211FLAGS");
}

void
unsetifnwflag(const char *val, int d)
{
	setifnwflag(val, 1);
}

/* ARGSUSED */
void
setifpowersave(const char *val, int d)
{
	struct ieee80211_power power;
	const char *errmsg = NULL;

	(void)strlcpy(power.i_name, name, sizeof(power.i_name));
	if (ioctl(s, SIOCG80211POWER, (caddr_t)&power) == -1) {
		warn("SIOCG80211POWER");
		return;
	}

	if (d != -1 && val != NULL) {
		power.i_maxsleep = strtonum(val, 0, INT_MAX, &errmsg);
		if (errmsg)
			errx(1, "powersave %s: %s", val, errmsg);
	}

	power.i_enabled = d == -1 ? 0 : 1;
	if (ioctl(s, SIOCS80211POWER, (caddr_t)&power) == -1)
		warn("SIOCS80211POWER");
}
#endif

void
print_cipherset(u_int32_t cipherset)
{
	const char *sep = "";
	int i;

	if (cipherset == IEEE80211_WPA_CIPHER_NONE) {
		printf("none");
		return;
	}
	for (i = 0; i < sizeof(ciphers) / sizeof(ciphers[0]); i++) {
		if (cipherset & ciphers[i].cipher) {
			printf("%s%s", sep, ciphers[i].name);
			sep = ",";
		}
	}
}

void
ieee80211_status(void)
{
	int len, i, nwkey_verbose, inwid, inwkey, ipsk, ichan, ipwr;
	int ibssid, iwpa;
	struct ieee80211_nwid nwid;
	struct ieee80211_nwkey nwkey;
	struct ieee80211_wpapsk psk;
	struct ieee80211_power power;
	struct ieee80211chanreq channel;
	struct ieee80211_bssid bssid;
	struct ieee80211_wpaparams wpa;
	struct ieee80211_nodereq nr;
	u_int8_t zero_bssid[IEEE80211_ADDR_LEN];
	u_int8_t keybuf[IEEE80211_WEP_NKID][16];
	struct ether_addr ea;

	/* get current status via ioctls */
	memset(&ifr, 0, sizeof(ifr));
	ifr.ifr_data = (caddr_t)&nwid;
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	inwid = ioctl(s, SIOCG80211NWID, (caddr_t)&ifr);

	memset(&nwkey, 0, sizeof(nwkey));
	strlcpy(nwkey.i_name, name, sizeof(nwkey.i_name));
	inwkey = ioctl(s, SIOCG80211NWKEY, (caddr_t)&nwkey);

	memset(&psk, 0, sizeof(psk));
	strlcpy(psk.i_name, name, sizeof(psk.i_name));
	ipsk = ioctl(s, SIOCG80211WPAPSK, (caddr_t)&psk);

	memset(&power, 0, sizeof(power));
	strlcpy(power.i_name, name, sizeof(power.i_name));
	ipwr = ioctl(s, SIOCG80211POWER, &power);

	memset(&channel, 0, sizeof(channel));
	strlcpy(channel.i_name, name, sizeof(channel.i_name));
	ichan = ioctl(s, SIOCG80211CHANNEL, (caddr_t)&channel);

	memset(&bssid, 0, sizeof(bssid));
	strlcpy(bssid.i_name, name, sizeof(bssid.i_name));
	ibssid = ioctl(s, SIOCG80211BSSID, &bssid);

	memset(&wpa, 0, sizeof(wpa));
	strlcpy(wpa.i_name, name, sizeof(wpa.i_name));
	iwpa = ioctl(s, SIOCG80211WPAPARMS, &wpa);

	/* check if any ieee80211 option is active */
	if (inwid == 0 || inwkey == 0 || ipsk == 0 || ipwr == 0 ||
	    ichan == 0 || ibssid == 0 || iwpa == 0)
		fputs("\tieee80211:", stdout);
	else
		return;

	if (inwid == 0) {
		/* nwid.i_nwid is not NUL terminated. */
		len = nwid.i_len;
		if (len > IEEE80211_NWID_LEN)
			len = IEEE80211_NWID_LEN;
		fputs(" nwid ", stdout);
		print_string(nwid.i_nwid, len);
	}

	if (ichan == 0 && channel.i_channel != 0 &&
	    channel.i_channel != IEEE80211_CHAN_ANY)
		printf(" chan %u", channel.i_channel);

	memset(&zero_bssid, 0, sizeof(zero_bssid));
	if (ibssid == 0 &&
	    memcmp(bssid.i_bssid, zero_bssid, IEEE80211_ADDR_LEN) != 0) {
		memcpy(&ea.ether_addr_octet, bssid.i_bssid,
		    sizeof(ea.ether_addr_octet));
		printf(" bssid %s", ether_ntoa(&ea));

		bzero(&nr, sizeof(nr));
		bcopy(bssid.i_bssid, &nr.nr_macaddr, sizeof(nr.nr_macaddr));
		strlcpy(nr.nr_ifname, name, sizeof(nr.nr_ifname));
		if (ioctl(s, SIOCG80211NODE, &nr) == 0 && nr.nr_rssi) {
			if (nr.nr_max_rssi)
				printf(" %u%%", IEEE80211_NODEREQ_RSSI(&nr));
			else
				printf(" %ddBm", nr.nr_rssi);
		}
	}

	if (inwkey == 0 && nwkey.i_wepon > IEEE80211_NWKEY_OPEN) {
		fputs(" nwkey ", stdout);
		/* try to retrieve WEP keys */
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			nwkey.i_key[i].i_keydat = keybuf[i];
			nwkey.i_key[i].i_keylen = sizeof(keybuf[i]);
		}
		if (ioctl(s, SIOCG80211NWKEY, (caddr_t)&nwkey) == -1) {
			fputs("<not displayed>", stdout);
		} else {
			nwkey_verbose = 0;
			/*
			 * check to see non default key
			 * or multiple keys defined
			 */
			if (nwkey.i_defkid != 1) {
				nwkey_verbose = 1;
			} else {
				for (i = 1; i < IEEE80211_WEP_NKID; i++) {
					if (nwkey.i_key[i].i_keylen != 0) {
						nwkey_verbose = 1;
						break;
					}
				}
			}
			/* check extra ambiguity with keywords */
			if (!nwkey_verbose) {
				if (nwkey.i_key[0].i_keylen >= 2 &&
				    isdigit((unsigned char)nwkey.i_key[0].i_keydat[0]) &&
				    nwkey.i_key[0].i_keydat[1] == ':')
					nwkey_verbose = 1;
				else if (nwkey.i_key[0].i_keylen >= 7 &&
				    strncasecmp("persist",
				    (char *)nwkey.i_key[0].i_keydat, 7) == 0)
					nwkey_verbose = 1;
			}
			if (nwkey_verbose)
				printf("%d:", nwkey.i_defkid);
			for (i = 0; i < IEEE80211_WEP_NKID; i++) {
				if (i > 0)
					putchar(',');
				if (nwkey.i_key[i].i_keylen < 0) {
					fputs("persist", stdout);
				} else {
					/*
					 * XXX
					 * sanity check nwkey.i_key[i].i_keylen
					 */
					print_string(nwkey.i_key[i].i_keydat,
					    nwkey.i_key[i].i_keylen);
				}
				if (!nwkey_verbose)
					break;
			}
		}
	}

	if (ipsk == 0 && psk.i_enabled) {
		fputs(" wpakey ", stdout);
		if (psk.i_enabled == 2)
			fputs("<not displayed>", stdout);
		else
			print_string(psk.i_psk, sizeof(psk.i_psk));
	}
	if (iwpa == 0 && wpa.i_enabled) {
		const char *sep;

		fputs(" wpaprotos ", stdout); sep = "";
		if (wpa.i_protos & IEEE80211_WPA_PROTO_WPA1) {
			fputs("wpa1", stdout);
			sep = ",";
		}
		if (wpa.i_protos & IEEE80211_WPA_PROTO_WPA2)
			printf("%swpa2", sep);

		fputs(" wpaakms ", stdout); sep = "";
		if (wpa.i_akms & IEEE80211_WPA_AKM_PSK) {
			fputs("psk", stdout);
			sep = ",";
		}
		if (wpa.i_akms & IEEE80211_WPA_AKM_8021X)
			printf("%s802.1x", sep);

		fputs(" wpaciphers ", stdout);
		print_cipherset(wpa.i_ciphers);

		fputs(" wpagroupcipher ", stdout);
		print_cipherset(wpa.i_groupcipher);
	}

	if (ipwr == 0 && power.i_enabled)
		printf(" powersave on (%dms sleep)", power.i_maxsleep);

	if (ioctl(s, SIOCG80211FLAGS, (caddr_t)&ifr) == 0 &&
	    ifr.ifr_flags) {
		putchar(' ');
		printb_status(ifr.ifr_flags, IEEE80211_F_USERBITS);
	}

	putchar('\n');
	if (shownet80211chans)
		ieee80211_listchans();
	else if (shownet80211nodes)
		ieee80211_listnodes();
}

void
ieee80211_listchans(void)
{
	static struct ieee80211_channel chans[256+1];
	struct ieee80211_chanreq_all ca;
	int i;

	bzero(&ca, sizeof(ca));
	bzero(chans, sizeof(chans));
	ca.i_chans = chans;
	strlcpy(ca.i_name, name, sizeof(ca.i_name));

	if (ioctl(s, SIOCG80211ALLCHANS, &ca) != 0) {
		warn("SIOCG80211ALLCHANS");
		return;
	}
	printf("\t\t%4s  %-8s  %s\n", "chan", "freq", "properties");
	for (i = 1; i <= 256; i++) {
		if (chans[i].ic_flags == 0)
			continue;
		printf("\t\t%4d  %4d MHz  ", i, chans[i].ic_freq);
		if (chans[i].ic_flags & IEEE80211_CHAN_PASSIVE)
			printf("passive scan");
		else
			putchar('-');
		putchar('\n');
	}
}

/*
 * Returns an integer less than, equal to, or greater than zero if nr1's
 * RSSI is respectively greater than, equal to, or less than nr2's RSSI.
 */
static int
rssicmp(const void *nr1, const void *nr2)
{
	const struct ieee80211_nodereq *x = nr1, *y = nr2;
	return y->nr_rssi < x->nr_rssi ? -1 : y->nr_rssi > x->nr_rssi;
}

void
ieee80211_listnodes(void)
{
	struct ieee80211_nodereq_all na;
	struct ieee80211_nodereq nr[512];
	struct ifreq ifr;
	int i, down = 0;

	if ((flags & IFF_UP) == 0) {
		down = 1;
		setifflags("up", IFF_UP);
	}

	bzero(&ifr, sizeof(ifr));
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));

	if (ioctl(s, SIOCS80211SCAN, (caddr_t)&ifr) != 0) {
		if (errno == EPERM)
			printf("\t\tno permission to scan\n");
		goto done;
	}

	bzero(&na, sizeof(na));
	bzero(&nr, sizeof(nr));
	na.na_node = nr;
	na.na_size = sizeof(nr);
	strlcpy(na.na_ifname, name, sizeof(na.na_ifname));

	if (ioctl(s, SIOCG80211ALLNODES, &na) != 0) {
		warn("SIOCG80211ALLNODES");
		goto done;
	}

	if (!na.na_nodes)
		printf("\t\tnone\n");
	else
		qsort(nr, na.na_nodes, sizeof(*nr), rssicmp);

	for (i = 0; i < na.na_nodes; i++) {
		printf("\t\t");
		ieee80211_printnode(&nr[i]);
		putchar('\n');
	}

 done:
	if (down)
		setifflags("restore", -IFF_UP);
}

void
ieee80211_printnode(struct ieee80211_nodereq *nr)
{
	int len, i;

	if (nr->nr_flags & IEEE80211_NODEREQ_AP ||
	    nr->nr_capinfo & IEEE80211_CAPINFO_IBSS) {
		len = nr->nr_nwid_len;
		if (len > IEEE80211_NWID_LEN)
			len = IEEE80211_NWID_LEN;
		printf("nwid ");
		print_string(nr->nr_nwid, len);
		putchar(' ');

		printf("chan %u ", nr->nr_channel);

		printf("bssid %s ",
		    ether_ntoa((struct ether_addr*)nr->nr_bssid));
	}

	if ((nr->nr_flags & IEEE80211_NODEREQ_AP) == 0)
		printf("lladdr %s ",
		    ether_ntoa((struct ether_addr*)nr->nr_macaddr));

	if (nr->nr_max_rssi)
		printf("%u%% ", IEEE80211_NODEREQ_RSSI(nr));
	else
		printf("%ddBm ", nr->nr_rssi);

	if (nr->nr_pwrsave)
		printf("powersave ");
	/* 
	 * Print our current Tx rate for associated nodes.
	 * Print the fastest supported rate for APs.
	 */
	if ((nr->nr_flags & (IEEE80211_NODEREQ_AP)) == 0) {
		if (nr->nr_flags & IEEE80211_NODEREQ_HT) {
			printf("HT-MCS%d ", nr->nr_txmcs);
		} else if (nr->nr_nrates) {
			printf("%uM ",
			    (nr->nr_rates[nr->nr_txrate] & IEEE80211_RATE_VAL)
			    / 2);
		}
	} else if (nr->nr_max_rxrate) {
		printf("%uM HT ", nr->nr_max_rxrate);
	} else if (nr->nr_rxmcs[0] != 0) {
		for (i = IEEE80211_HT_NUM_MCS - 1; i >= 0; i--) {
			if (isset(nr->nr_rxmcs, i))
				break;
		}
		printf("HT-MCS%d ", i);
	} else if (nr->nr_nrates) {
		printf("%uM ",
		    (nr->nr_rates[nr->nr_nrates - 1] & IEEE80211_RATE_VAL) / 2);
	}
	/* ESS is the default, skip it */
	nr->nr_capinfo &= ~IEEE80211_CAPINFO_ESS;
	if (nr->nr_capinfo) {
		printb_status(nr->nr_capinfo, IEEE80211_CAPINFO_BITS);
		if (nr->nr_capinfo & IEEE80211_CAPINFO_PRIVACY) {
			if (nr->nr_rsnprotos) {
				if (nr->nr_rsnprotos & IEEE80211_WPA_PROTO_WPA2)
					fputs(",wpa2", stdout);
				if (nr->nr_rsnprotos & IEEE80211_WPA_PROTO_WPA1)
					fputs(",wpa1", stdout);
			} else
				fputs(",wep", stdout);

			if (nr->nr_rsnakms & IEEE80211_WPA_AKM_8021X ||
			    nr->nr_rsnakms & IEEE80211_WPA_AKM_SHA256_8021X)
				fputs(",802.1x", stdout);
		}
		putchar(' ');
	}

	if ((nr->nr_flags & IEEE80211_NODEREQ_AP) == 0)
		printb_status(IEEE80211_NODEREQ_STATE(nr->nr_state),
		    IEEE80211_NODEREQ_STATE_BITS);
}

void
init_current_media(void)
{
	struct ifmediareq ifmr;

	/*
	 * If we have not yet done so, grab the currently-selected
	 * media.
	 */
	if ((actions & (A_MEDIA|A_MEDIAOPT|A_MEDIAMODE)) == 0) {
		(void) memset(&ifmr, 0, sizeof(ifmr));
		(void) strlcpy(ifmr.ifm_name, name, sizeof(ifmr.ifm_name));

		if (ioctl(s, SIOCGIFMEDIA, (caddr_t)&ifmr) < 0) {
			/*
			 * If we get E2BIG, the kernel is telling us
			 * that there are more, so we can ignore it.
			 */
			if (errno != E2BIG)
				err(1, "SIOCGIFMEDIA");
		}

		media_current = ifmr.ifm_current;
	}

	/* Sanity. */
	if (IFM_TYPE(media_current) == 0)
		errx(1, "%s: no link type?", name);
}

void
process_media_commands(void)
{

	if ((actions & (A_MEDIA|A_MEDIAOPT|A_MEDIAMODE)) == 0) {
		/* Nothing to do. */
		return;
	}

	/*
	 * Media already set up, and commands sanity-checked.  Set/clear
	 * any options, and we're ready to go.
	 */
	media_current |= mediaopt_set;
	media_current &= ~mediaopt_clear;

	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_media = media_current;

	if (ioctl(s, SIOCSIFMEDIA, (caddr_t)&ifr) < 0)
		;
}

/* ARGSUSED */
void
setmedia(const char *val, int d)
{
	uint64_t type, subtype, inst;

	if (val == NULL) {
		if (showmediaflag)
			usage();
		showmediaflag = 1;
		return;
	}

	init_current_media();

	/* Only one media command may be given. */
	if (actions & A_MEDIA)
		errx(1, "only one `media' command may be issued");

	/* Must not come after mode commands */
	if (actions & A_MEDIAMODE)
		errx(1, "may not issue `media' after `mode' commands");

	/* Must not come after mediaopt commands */
	if (actions & A_MEDIAOPT)
		errx(1, "may not issue `media' after `mediaopt' commands");

	/*
	 * No need to check if `instance' has been issued; setmediainst()
	 * craps out if `media' has not been specified.
	 */

	type = IFM_TYPE(media_current);
	inst = IFM_INST(media_current);

	/* Look up the subtype. */
	subtype = get_media_subtype(type, val);

	/* Build the new current media word. */
	media_current = IFM_MAKEWORD(type, subtype, 0, inst);

	/* Media will be set after other processing is complete. */
}

/* ARGSUSED */
void
setmediamode(const char *val, int d)
{
	uint64_t type, subtype, options, inst, mode;

	init_current_media();

	/* Can only issue `mode' once. */
	if (actions & A_MEDIAMODE)
		errx(1, "only one `mode' command may be issued");

	type = IFM_TYPE(media_current);
	subtype = IFM_SUBTYPE(media_current);
	options = IFM_OPTIONS(media_current);
	inst = IFM_INST(media_current);

	if ((mode = get_media_mode(type, val)) == -1)
		errx(1, "invalid media mode: %s", val);
	media_current = IFM_MAKEWORD(type, subtype, options, inst) | mode;
	/* Media will be set after other processing is complete. */
}

void
unsetmediamode(const char *val, int d)
{
	uint64_t type, subtype, options, inst;

	init_current_media();

	/* Can only issue `mode' once. */
	if (actions & A_MEDIAMODE)
		errx(1, "only one `mode' command may be issued");

	type = IFM_TYPE(media_current);
	subtype = IFM_SUBTYPE(media_current);
	options = IFM_OPTIONS(media_current);
	inst = IFM_INST(media_current);

	media_current = IFM_MAKEWORD(type, subtype, options, inst) |
	    (IFM_AUTO << IFM_MSHIFT);
	/* Media will be set after other processing is complete. */
}

void
setmediaopt(const char *val, int d)
{

	init_current_media();

	/* Can only issue `mediaopt' once. */
	if (actions & A_MEDIAOPTSET)
		errx(1, "only one `mediaopt' command may be issued");

	/* Can't issue `mediaopt' if `instance' has already been issued. */
	if (actions & A_MEDIAINST)
		errx(1, "may not issue `mediaopt' after `instance'");

	mediaopt_set = get_media_options(IFM_TYPE(media_current), val);

	/* Media will be set after other processing is complete. */
}

/* ARGSUSED */
void
unsetmediaopt(const char *val, int d)
{

	init_current_media();

	/* Can only issue `-mediaopt' once. */
	if (actions & A_MEDIAOPTCLR)
		errx(1, "only one `-mediaopt' command may be issued");

	/* May not issue `media' and `-mediaopt'. */
	if (actions & A_MEDIA)
		errx(1, "may not issue both `media' and `-mediaopt'");

	/*
	 * No need to check for A_MEDIAINST, since the test for A_MEDIA
	 * implicitly checks for A_MEDIAINST.
	 */

	mediaopt_clear = get_media_options(IFM_TYPE(media_current), val);

	/* Media will be set after other processing is complete. */
}

/* ARGSUSED */
void
setmediainst(const char *val, int d)
{
	uint64_t type, subtype, options, inst;
	const char *errmsg = NULL;

	init_current_media();

	/* Can only issue `instance' once. */
	if (actions & A_MEDIAINST)
		errx(1, "only one `instance' command may be issued");

	/* Must have already specified `media' */
	if ((actions & A_MEDIA) == 0)
		errx(1, "must specify `media' before `instance'");

	type = IFM_TYPE(media_current);
	subtype = IFM_SUBTYPE(media_current);
	options = IFM_OPTIONS(media_current);

	inst = strtonum(val, 0, IFM_INST_MAX, &errmsg);
	if (errmsg)
		errx(1, "media instance %s: %s", val, errmsg);

	media_current = IFM_MAKEWORD(type, subtype, options, inst);

	/* Media will be set after other processing is complete. */
}

/*
 * Note: 
 * bits:       0   1   2   3   4   5   ....   24   25   ...   30   31
 * T1 mode:   N/A ch1 ch2 ch3 ch4 ch5        ch24  N/A        N/A  N/A
 * E1 mode:   ts0 ts1 ts2 ts3 ts4 ts5        ts24  ts25       ts30 ts31
 */
#ifndef SMALL
/* ARGSUSED */
void
settimeslot(const char *val, int d)
{
#define SINGLE_CHANNEL	0x1
#define RANGE_CHANNEL	0x2
#define ALL_CHANNELS	0xFFFFFFFF
	unsigned long	ts_map = 0;
	char		*ptr = (char *)val;
	int		ts_flag = 0;
	int		ts = 0, ts_start = 0;

	if (strcmp(val,"all") == 0) {
		ts_map = ALL_CHANNELS;
	} else {
		while (*ptr != '\0') {
			if (isdigit((unsigned char)*ptr)) {
				ts = strtoul(ptr, &ptr, 10);
				ts_flag |= SINGLE_CHANNEL;
			} else {
				if (*ptr == '-') {
					ts_flag |= RANGE_CHANNEL;
					ts_start = ts;
				} else {
					ts_map |= get_ts_map(ts_flag,
					    ts_start, ts);
					ts_flag = 0;
				}
				ptr++;
			}
		}
		if (ts_flag)
			ts_map |= get_ts_map(ts_flag, ts_start, ts);

	}
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t)&ts_map;

	if (ioctl(s, SIOCSIFTIMESLOT, (caddr_t)&ifr) < 0)
		err(1, "SIOCSIFTIMESLOT");
}

unsigned long
get_ts_map(int ts_flag, int ts_start, int ts_stop)
{
	int		i = 0;
	unsigned long	map = 0, mask = 0;

	if ((ts_flag & (SINGLE_CHANNEL | RANGE_CHANNEL)) == 0)
		return 0;
	if (ts_flag & RANGE_CHANNEL) { /* Range of channels */
		for (i = ts_start; i <= ts_stop; i++) {
			mask = 1 << i;
			map |=mask;
		}
	} else { /* Single channel */
		mask = 1 << ts_stop;
		map |= mask;
	}
	return map;
}

void
timeslot_status(void)
{
	char		*sep = " ";
	unsigned long	 ts_map = 0;
	int		 i, start = -1;

	ifr.ifr_data = (caddr_t)&ts_map;

	if (ioctl(s, SIOCGIFTIMESLOT, (caddr_t)&ifr) == -1)
		return;

	printf("\ttimeslot:");
	for (i = 0; i < sizeof(ts_map) * 8; i++) {
		if (start == -1 && ts_map & (1 << i))
			start = i;
		else if (start != -1 && !(ts_map & (1 << i))) {
			if (start == i - 1)
				printf("%s%d", sep, start);
			else
				printf("%s%d-%d", sep, start, i-1);
			sep = ",";
			start = -1;
		}
	}
	if (start != -1) {
		if (start == i - 1)
			printf("%s%d", sep, start);
		else
			printf("%s%d-%d", sep, start, i-1);
	}
	printf("\n");
}
#endif


const struct ifmedia_description ifm_type_descriptions[] =
    IFM_TYPE_DESCRIPTIONS;

const struct ifmedia_description ifm_subtype_descriptions[] =
    IFM_SUBTYPE_DESCRIPTIONS;

struct ifmedia_description ifm_mode_descriptions[] =
    IFM_MODE_DESCRIPTIONS;

const struct ifmedia_description ifm_option_descriptions[] =
    IFM_OPTION_DESCRIPTIONS;

const char *
get_media_type_string(uint64_t mword)
{
	const struct ifmedia_description *desc;

	for (desc = ifm_type_descriptions; desc->ifmt_string != NULL;
	    desc++) {
		if (IFM_TYPE(mword) == desc->ifmt_word)
			return (desc->ifmt_string);
	}
	return ("<unknown type>");
}

const char *
get_media_subtype_string(uint64_t mword)
{
	const struct ifmedia_description *desc;

	for (desc = ifm_subtype_descriptions; desc->ifmt_string != NULL;
	    desc++) {
		if (IFM_TYPE_MATCH(desc->ifmt_word, mword) &&
		    IFM_SUBTYPE(desc->ifmt_word) == IFM_SUBTYPE(mword))
			return (desc->ifmt_string);
	}
	return ("<unknown subtype>");
}

uint64_t
get_media_subtype(uint64_t type, const char *val)
{
	uint64_t rval;

	rval = lookup_media_word(ifm_subtype_descriptions, type, val);
	if (rval == -1)
		errx(1, "unknown %s media subtype: %s",
		    get_media_type_string(type), val);

	return (rval);
}

uint64_t
get_media_mode(uint64_t type, const char *val)
{
	uint64_t rval;

	rval = lookup_media_word(ifm_mode_descriptions, type, val);
	if (rval == -1)
		errx(1, "unknown %s media mode: %s",
		    get_media_type_string(type), val);
	return (rval);
}

uint64_t
get_media_options(uint64_t type, const char *val)
{
	char *optlist, *str;
	uint64_t option, rval = 0;

	/* We muck with the string, so copy it. */
	optlist = strdup(val);
	if (optlist == NULL)
		err(1, "strdup");
	str = optlist;

	/*
	 * Look up the options in the user-provided comma-separated list.
	 */
	for (; (str = strtok(str, ",")) != NULL; str = NULL) {
		option = lookup_media_word(ifm_option_descriptions, type, str);
		if (option == -1)
			errx(1, "unknown %s media option: %s",
			    get_media_type_string(type), str);
		rval |= IFM_OPTIONS(option);
	}

	free(optlist);
	return (rval);
}

uint64_t
lookup_media_word(const struct ifmedia_description *desc, uint64_t type,
    const char *val)
{

	for (; desc->ifmt_string != NULL; desc++) {
		if (IFM_TYPE_MATCH(desc->ifmt_word, type) &&
		    strcasecmp(desc->ifmt_string, val) == 0)
			return (desc->ifmt_word);
	}
	return (-1);
}

void
print_media_word(uint64_t ifmw, int print_type, int as_syntax)
{
	const struct ifmedia_description *desc;
	uint64_t seen_option = 0;

	if (print_type)
		printf("%s ", get_media_type_string(ifmw));
	printf("%s%s", as_syntax ? "media " : "",
	    get_media_subtype_string(ifmw));

	/* Find mode. */
	if (IFM_MODE(ifmw) != 0) {
		for (desc = ifm_mode_descriptions; desc->ifmt_string != NULL;
		    desc++) {
			if (IFM_TYPE_MATCH(desc->ifmt_word, ifmw) &&
			    IFM_MODE(ifmw) == IFM_MODE(desc->ifmt_word)) {
				printf(" mode %s", desc->ifmt_string);
				break;
			}
		}
	}

	/* Find options. */
	for (desc = ifm_option_descriptions; desc->ifmt_string != NULL;
	    desc++) {
		if (IFM_TYPE_MATCH(desc->ifmt_word, ifmw) &&
		    (IFM_OPTIONS(ifmw) & IFM_OPTIONS(desc->ifmt_word)) != 0 &&
		    (seen_option & IFM_OPTIONS(desc->ifmt_word)) == 0) {
			if (seen_option == 0)
				printf(" %s", as_syntax ? "mediaopt " : "");
			printf("%s%s", seen_option ? "," : "",
			    desc->ifmt_string);
			seen_option |= IFM_OPTIONS(desc->ifmt_word);
		}
	}
	if (IFM_INST(ifmw) != 0)
		printf(" instance %lld", IFM_INST(ifmw));
}

/* ARGSUSED */
static void
phys_status(int force)
{
	char psrcaddr[NI_MAXHOST];
	char pdstaddr[NI_MAXHOST];
	const char *ver = "";
	const int niflag = NI_NUMERICHOST;
	struct if_laddrreq req;
	in_port_t dstport = 0;

	psrcaddr[0] = pdstaddr[0] = '\0';

	memset(&req, 0, sizeof(req));
	(void) strlcpy(req.iflr_name, name, sizeof(req.iflr_name));
	if (ioctl(s, SIOCGLIFPHYADDR, (caddr_t)&req) < 0)
		return;
	if (getnameinfo((struct sockaddr *)&req.addr, req.addr.ss_len,
	    psrcaddr, sizeof(psrcaddr), 0, 0, niflag) != 0)
		strlcpy(psrcaddr, "<error>", sizeof(psrcaddr));
	if (req.addr.ss_family == AF_INET6)
		ver = "6";

	if (req.dstaddr.ss_family == AF_INET)
		dstport = ((struct sockaddr_in *)&req.dstaddr)->sin_port;
	else if (req.dstaddr.ss_family == AF_INET6)
		dstport = ((struct sockaddr_in6 *)&req.dstaddr)->sin6_port;
	if (getnameinfo((struct sockaddr *)&req.dstaddr, req.dstaddr.ss_len,
	    pdstaddr, sizeof(pdstaddr), 0, 0, niflag) != 0)
		strlcpy(pdstaddr, "<error>", sizeof(pdstaddr));

	printf("\ttunnel: inet%s %s -> %s", ver,
	    psrcaddr, pdstaddr);

	if (dstport)
		printf(":%u", ntohs(dstport));
	if (ioctl(s, SIOCGLIFPHYTTL, (caddr_t)&ifr) == 0 && ifr.ifr_ttl > 0)
		printf(" ttl %d", ifr.ifr_ttl);
#ifndef SMALL
	if (ioctl(s, SIOCGLIFPHYRTABLE, (caddr_t)&ifr) == 0 &&
	    (rdomainid != 0 || ifr.ifr_rdomainid != 0))
		printf(" rdomain %d", ifr.ifr_rdomainid);
#endif
	printf("\n");
}

#ifndef SMALL
const uint64_t ifm_status_valid_list[] = IFM_STATUS_VALID_LIST;

const struct ifmedia_status_description ifm_status_descriptions[] =
	IFM_STATUS_DESCRIPTIONS;
#endif

const struct if_status_description if_status_descriptions[] =
	LINK_STATE_DESCRIPTIONS;

const char *
get_linkstate(int mt, int link_state)
{
	const struct if_status_description *p;
	static char buf[8];

	for (p = if_status_descriptions; p->ifs_string != NULL; p++) {
		if (LINK_STATE_DESC_MATCH(p, mt, link_state))
			return (p->ifs_string);
	}
	snprintf(buf, sizeof(buf), "[#%d]", link_state);
	return buf;
}

/*
 * Print the status of the interface.  If an address family was
 * specified, show it and it only; otherwise, show them all.
 */
void
status(int link, struct sockaddr_dl *sdl, int ls)
{
	const struct afswtch *p = afp;
	struct ifmediareq ifmr;
#ifndef SMALL
	struct ifreq ifrdesc;
	struct ifkalivereq ikardesc;
	char ifdescr[IFDESCRSIZE];
	char ifname[IF_NAMESIZE];
#endif
	uint64_t *media_list;
	int i;
	char sep;


	printf("%s: ", name);
	printb("flags", flags | (xflags << 16), IFFBITS);
	if (rdomainid)
		printf(" rdomain %d", rdomainid);
	if (metric)
		printf(" metric %lu", metric);
	if (mtu)
		printf(" mtu %lu", mtu);
	putchar('\n');
#ifndef SMALL
	if (showcapsflag)
		printifhwfeatures(NULL, 1);
#endif
	if (sdl != NULL && sdl->sdl_alen &&
	    (sdl->sdl_type == IFT_ETHER || sdl->sdl_type == IFT_CARP))
		(void)printf("\tlladdr %s\n", ether_ntoa(
		    (struct ether_addr *)LLADDR(sdl)));

	sep = '\t';
#ifndef SMALL
	(void) memset(&ifrdesc, 0, sizeof(ifrdesc));
	(void) strlcpy(ifrdesc.ifr_name, name, sizeof(ifrdesc.ifr_name));
	ifrdesc.ifr_data = (caddr_t)&ifdescr;
	if (ioctl(s, SIOCGIFDESCR, &ifrdesc) == 0 &&
	    strlen(ifrdesc.ifr_data))
		printf("\tdescription: %s\n", ifrdesc.ifr_data);

	if (sdl != NULL) {
		printf("%cindex %u", sep, sdl->sdl_index);
		sep = ' ';
	}
	if (!is_bridge(name) && ioctl(s, SIOCGIFPRIORITY, &ifrdesc) == 0) {
		printf("%cpriority %d", sep, ifrdesc.ifr_metric);
		sep = ' ';
	}
#endif
	printf("%cllprio %d\n", sep, llprio);

#ifndef SMALL
	(void) memset(&ikardesc, 0, sizeof(ikardesc));
	(void) strlcpy(ikardesc.ikar_name, name, sizeof(ikardesc.ikar_name));
	if (ioctl(s, SIOCGETKALIVE, &ikardesc) == 0 &&
	    (ikardesc.ikar_timeo != 0 || ikardesc.ikar_cnt != 0))
		printf("\tkeepalive: timeout %d count %d\n",
		    ikardesc.ikar_timeo, ikardesc.ikar_cnt);
	if (ioctl(s, SIOCGIFPAIR, &ifrdesc) == 0 && ifrdesc.ifr_index != 0 &&
	    if_indextoname(ifrdesc.ifr_index, ifname) != NULL)
		printf("\tpatch: %s\n", ifname);
#endif
	vlan_status();
	getvnetid();
	getifparent();
#ifndef SMALL
	carp_status();
	pfsync_status();
	pppoe_status();
	timeslot_status();
	sppp_status();
	mpe_status();
	mpw_status();
	pflow_status();
	umb_status();
#endif
	trunk_status();
	getifgroups();

	(void) memset(&ifmr, 0, sizeof(ifmr));
	(void) strlcpy(ifmr.ifm_name, name, sizeof(ifmr.ifm_name));

	if (ioctl(s, SIOCGIFMEDIA, (caddr_t)&ifmr) < 0) {
		/*
		 * Interface doesn't support SIOC{G,S}IFMEDIA.
		 */
		if (ls != LINK_STATE_UNKNOWN)
			printf("\tstatus: %s\n",
			    get_linkstate(sdl->sdl_type, ls));
		goto proto_status;
	}

	if (ifmr.ifm_count == 0) {
		warnx("%s: no media types?", name);
		goto proto_status;
	}

	media_list = calloc(ifmr.ifm_count, sizeof(*media_list));
	if (media_list == NULL)
		err(1, "calloc");
	ifmr.ifm_ulist = media_list;

	if (ioctl(s, SIOCGIFMEDIA, (caddr_t)&ifmr) < 0)
		err(1, "SIOCGIFMEDIA");

	printf("\tmedia: ");
	print_media_word(ifmr.ifm_current, 1, 0);
	if (ifmr.ifm_active != ifmr.ifm_current) {
		putchar(' ');
		putchar('(');
		print_media_word(ifmr.ifm_active, 0, 0);
		putchar(')');
	}
	putchar('\n');

#ifdef SMALL
	printf("\tstatus: %s\n", get_linkstate(sdl->sdl_type, ls));
#else
	if (ifmr.ifm_status & IFM_AVALID) {
		const struct ifmedia_status_description *ifms;
		int bitno, found = 0;

		printf("\tstatus: ");
		for (bitno = 0; ifm_status_valid_list[bitno] != 0; bitno++) {
			for (ifms = ifm_status_descriptions;
			    ifms->ifms_valid != 0; ifms++) {
				if (ifms->ifms_type !=
				    IFM_TYPE(ifmr.ifm_current) ||
				    ifms->ifms_valid !=
				    ifm_status_valid_list[bitno])
					continue;
				printf("%s%s", found ? ", " : "",
				    IFM_STATUS_DESC(ifms, ifmr.ifm_status));
				found = 1;

				/*
				 * For each valid indicator bit, there's
				 * only one entry for each media type, so
				 * terminate the inner loop now.
				 */
				break;
			}
		}

		if (found == 0)
			printf("unknown");
		putchar('\n');
	}
#endif
	ieee80211_status();

	if (showmediaflag) {
		uint64_t type;
		int printed_type = 0;

		for (type = IFM_NMIN; type <= IFM_NMAX; type += IFM_NMIN) {
			for (i = 0, printed_type = 0; i < ifmr.ifm_count; i++) {
				if (IFM_TYPE(media_list[i]) == type) {

					/*
					 * Don't advertise media with fixed
					 * data rates for wireless interfaces.
					 * Normal people don't need these.
					 */
					if (type == IFM_IEEE80211 &&
					    (media_list[i] & IFM_TMASK) !=
					    IFM_AUTO)
						continue;

					if (printed_type == 0) {
					    printf("\tsupported media:\n");
					    printed_type = 1;
					}
					printf("\t\t");
					print_media_word(media_list[i], 0, 1);
					printf("\n");
				}
			}
		}
	}

	free(media_list);

 proto_status:
	if (link == 0) {
		if ((p = afp) != NULL) {
			p->af_status(1);
		} else for (p = afs; p->af_name; p++) {
			ifr.ifr_addr.sa_family = p->af_af;
			p->af_status(0);
		}
	}

	phys_status(0);
#ifndef SMALL
	bridge_status();
	switch_status();
#endif
}

/* ARGSUSED */
void
in_status(int force)
{
	struct sockaddr_in *sin, sin2;

	getsock(AF_INET);
	if (s < 0) {
		if (errno == EPROTONOSUPPORT)
			return;
		err(1, "socket");
	}
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	sin = (struct sockaddr_in *)&ifr.ifr_addr;

	/*
	 * We keep the interface address and reset it before each
	 * ioctl() so we can get ifaliases information (as opposed
	 * to the primary interface netmask/dstaddr/broadaddr, if
	 * the ifr_addr field is zero).
	 */
	memcpy(&sin2, &ifr.ifr_addr, sizeof(sin2));

	printf("\tinet %s", inet_ntoa(sin->sin_addr));
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFNETMASK, (caddr_t)&ifr) < 0) {
		if (errno != EADDRNOTAVAIL)
			warn("SIOCGIFNETMASK");
		memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
	} else
		netmask.sin_addr =
		    ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
	if (flags & IFF_POINTOPOINT) {
		memcpy(&ifr.ifr_addr, &sin2, sizeof(sin2));
		if (ioctl(s, SIOCGIFDSTADDR, (caddr_t)&ifr) < 0) {
			if (errno == EADDRNOTAVAIL)
			    memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
			else
			    warn("SIOCGIFDSTADDR");
		}
		(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
		sin = (struct sockaddr_in *)&ifr.ifr_dstaddr;
		printf(" --> %s", inet_ntoa(sin->sin_addr));
	}
	printf(" netmask 0x%x", ntohl(netmask.sin_addr.s_addr));
	if (flags & IFF_BROADCAST) {
		memcpy(&ifr.ifr_addr, &sin2, sizeof(sin2));
		if (ioctl(s, SIOCGIFBRDADDR, (caddr_t)&ifr) < 0) {
			if (errno == EADDRNOTAVAIL)
			    memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
			else
			    warn("SIOCGIFBRDADDR");
		}
		(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
		sin = (struct sockaddr_in *)&ifr.ifr_addr;
		if (sin->sin_addr.s_addr != 0)
			printf(" broadcast %s", inet_ntoa(sin->sin_addr));
	}
	putchar('\n');
}

/* ARGSUSED */
void
setifprefixlen(const char *addr, int d)
{
	if (afp->af_getprefix)
		afp->af_getprefix(addr, MASK);
	explicit_prefix = 1;
}

void
in6_fillscopeid(struct sockaddr_in6 *sin6)
{
#ifdef __KAME__
	if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
		sin6->sin6_scope_id =
			ntohs(*(u_int16_t *)&sin6->sin6_addr.s6_addr[2]);
		sin6->sin6_addr.s6_addr[2] = sin6->sin6_addr.s6_addr[3] = 0;
	}
#endif /* __KAME__ */
}

/* XXX not really an alias */
void
in6_alias(struct in6_ifreq *creq)
{
	struct sockaddr_in6 *sin6;
	struct	in6_ifreq ifr6;		/* shadows file static variable */
	u_int32_t scopeid;
	char hbuf[NI_MAXHOST];
	const int niflag = NI_NUMERICHOST;

	/* Get the non-alias address for this interface. */
	getsock(AF_INET6);
	if (s < 0) {
		if (errno == EPROTONOSUPPORT)
			return;
		err(1, "socket");
	}

	sin6 = (struct sockaddr_in6 *)&creq->ifr_addr;

	in6_fillscopeid(sin6);
	scopeid = sin6->sin6_scope_id;
	if (getnameinfo((struct sockaddr *)sin6, sin6->sin6_len,
	    hbuf, sizeof(hbuf), NULL, 0, niflag) != 0)
		strlcpy(hbuf, "", sizeof hbuf);
	printf("\tinet6 %s", hbuf);

	if (flags & IFF_POINTOPOINT) {
		(void) memset(&ifr6, 0, sizeof(ifr6));
		(void) strlcpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
		ifr6.ifr_addr = creq->ifr_addr;
		if (ioctl(s, SIOCGIFDSTADDR_IN6, (caddr_t)&ifr6) < 0) {
			if (errno != EADDRNOTAVAIL)
				warn("SIOCGIFDSTADDR_IN6");
			(void) memset(&ifr6.ifr_addr, 0, sizeof(ifr6.ifr_addr));
			ifr6.ifr_addr.sin6_family = AF_INET6;
			ifr6.ifr_addr.sin6_len = sizeof(struct sockaddr_in6);
		}
		sin6 = (struct sockaddr_in6 *)&ifr6.ifr_addr;
		in6_fillscopeid(sin6);
		if (getnameinfo((struct sockaddr *)sin6, sin6->sin6_len,
		    hbuf, sizeof(hbuf), NULL, 0, niflag) != 0)
			strlcpy(hbuf, "", sizeof hbuf);
		printf(" -> %s", hbuf);
	}

	(void) memset(&ifr6, 0, sizeof(ifr6));
	(void) strlcpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
	ifr6.ifr_addr = creq->ifr_addr;
	if (ioctl(s, SIOCGIFNETMASK_IN6, (caddr_t)&ifr6) < 0) {
		if (errno != EADDRNOTAVAIL)
			warn("SIOCGIFNETMASK_IN6");
	} else {
		sin6 = (struct sockaddr_in6 *)&ifr6.ifr_addr;
		printf(" prefixlen %d", prefix(&sin6->sin6_addr,
		    sizeof(struct in6_addr)));
	}

	(void) memset(&ifr6, 0, sizeof(ifr6));
	(void) strlcpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
	ifr6.ifr_addr = creq->ifr_addr;
	if (ioctl(s, SIOCGIFAFLAG_IN6, (caddr_t)&ifr6) < 0) {
		if (errno != EADDRNOTAVAIL)
			warn("SIOCGIFAFLAG_IN6");
	} else {
		if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_ANYCAST)
			printf(" anycast");
		if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_TENTATIVE)
			printf(" tentative");
		if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_DUPLICATED)
			printf(" duplicated");
		if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_DETACHED)
			printf(" detached");
		if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_DEPRECATED)
			printf(" deprecated");
		if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_AUTOCONF)
			printf(" autoconf");
		if (ifr6.ifr_ifru.ifru_flags6 & IN6_IFF_PRIVACY)
			printf(" autoconfprivacy");
	}

	if (scopeid)
		printf(" scopeid 0x%x", scopeid);

	if (Lflag) {
		struct in6_addrlifetime *lifetime;

		(void) memset(&ifr6, 0, sizeof(ifr6));
		(void) strlcpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
		ifr6.ifr_addr = creq->ifr_addr;
		lifetime = &ifr6.ifr_ifru.ifru_lifetime;
		if (ioctl(s, SIOCGIFALIFETIME_IN6, (caddr_t)&ifr6) < 0) {
			if (errno != EADDRNOTAVAIL)
				warn("SIOCGIFALIFETIME_IN6");
		} else if (lifetime->ia6t_preferred || lifetime->ia6t_expire) {
			time_t t = time(NULL);

			printf(" pltime ");
			if (lifetime->ia6t_preferred) {
				printf("%s", lifetime->ia6t_preferred < t
				    ? "0" :
				    sec2str(lifetime->ia6t_preferred - t));
			} else
				printf("infty");

			printf(" vltime ");
			if (lifetime->ia6t_expire) {
				printf("%s", lifetime->ia6t_expire < t
				    ? "0"
				    : sec2str(lifetime->ia6t_expire - t));
			} else
				printf("infty");
		}
	}

	printf("\n");
}

void
in6_status(int force)
{
	in6_alias((struct in6_ifreq *)&ifr6);
}

#ifndef SMALL
void
settunnel(const char *src, const char *dst)
{
	char buf[HOST_NAME_MAX+1 + sizeof (":65535")], *dstport;
	const char *dstip;
	struct addrinfo *srcres, *dstres;
	int ecode;
	struct if_laddrreq req;

	if (strchr(dst, ':') == NULL || strchr(dst, ':') != strrchr(dst, ':')) {
		/* no port or IPv6 */
		dstip = dst;
		dstport = NULL;
	} else {
		if (strlcpy(buf, dst, sizeof(buf)) >= sizeof(buf))
			errx(1, "%s bad value", dst);
		dstport = strchr(buf, ':');
		*dstport++ = '\0';
		dstip = buf;
	}

	if ((ecode = getaddrinfo(src, NULL, NULL, &srcres)) != 0)
		errx(1, "error in parsing address string: %s",
		    gai_strerror(ecode));

	if ((ecode = getaddrinfo(dstip, dstport, NULL, &dstres)) != 0)
		errx(1, "error in parsing address string: %s",
		    gai_strerror(ecode));

	if (srcres->ai_addr->sa_family != dstres->ai_addr->sa_family)
		errx(1,
		    "source and destination address families do not match");

	if (srcres->ai_addrlen > sizeof(req.addr) ||
	    dstres->ai_addrlen > sizeof(req.dstaddr))
		errx(1, "invalid sockaddr");

	memset(&req, 0, sizeof(req));
	(void) strlcpy(req.iflr_name, name, sizeof(req.iflr_name));
	memcpy(&req.addr, srcres->ai_addr, srcres->ai_addrlen);
	memcpy(&req.dstaddr, dstres->ai_addr, dstres->ai_addrlen);
	if (ioctl(s, SIOCSLIFPHYADDR, &req) < 0)
		warn("SIOCSLIFPHYADDR");

	freeaddrinfo(srcres);
	freeaddrinfo(dstres);
}

/* ARGSUSED */
void
deletetunnel(const char *ignored, int alsoignored)
{
	if (ioctl(s, SIOCDIFPHYADDR, &ifr) < 0)
		warn("SIOCDIFPHYADDR");
}

void
settunnelinst(const char *id, int param)
{
	const char *errmsg = NULL;
	int rdomainid;

	rdomainid = strtonum(id, 0, RT_TABLEID_MAX, &errmsg);
	if (errmsg)
		errx(1, "rdomain %s: %s", id, errmsg);

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_rdomainid = rdomainid;
	if (ioctl(s, SIOCSLIFPHYRTABLE, (caddr_t)&ifr) < 0)
		warn("SIOCSLIFPHYRTABLE");
}

void
settunnelttl(const char *id, int param)
{
	const char *errmsg = NULL;
	int ttl;

	ttl = strtonum(id, 0, 0xff, &errmsg);
	if (errmsg)
		errx(1, "tunnelttl %s: %s", id, errmsg);

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_ttl = ttl;
	if (ioctl(s, SIOCSLIFPHYTTL, (caddr_t)&ifr) < 0)
		warn("SIOCSLIFPHYTTL");
}

void
mpe_status(void)
{
	struct shim_hdr	shim;

	bzero(&shim, sizeof(shim));
	ifr.ifr_data = (caddr_t)&shim;

	if (ioctl(s, SIOCGETLABEL , (caddr_t)&ifr) == -1)
		return;
	printf("\tmpls label: %d\n", shim.shim_label);
}

void
mpw_status(void)
{
	struct sockaddr_in *sin;
	struct ifmpwreq imr;

	bzero(&imr, sizeof(imr));
	ifr.ifr_data = (caddr_t) &imr;
	if (ioctl(s, SIOCGETMPWCFG, (caddr_t) &ifr) == -1)
		return;

	printf("\tencapsulation-type ");
	switch (imr.imr_type) {
	case IMR_TYPE_NONE:
		printf("none");
		break;
	case IMR_TYPE_ETHERNET:
		printf("ethernet");
		break;
	case IMR_TYPE_ETHERNET_TAGGED:
		printf("ethernet-tagged");
		break;
	default:
		printf("unknown");
		break;
	}

	if (imr.imr_flags & IMR_FLAG_CONTROLWORD)
		printf(", control-word");

	printf("\n");

	printf("\tmpls label: ");
	if (imr.imr_lshim.shim_label == 0)
		printf("local none ");
	else
		printf("local %u ", imr.imr_lshim.shim_label);

	if (imr.imr_rshim.shim_label == 0)
		printf("remote none\n");
	else
		printf("remote %u\n", imr.imr_rshim.shim_label);

	sin = (struct sockaddr_in *) &imr.imr_nexthop;
	if (sin->sin_addr.s_addr == 0)
		printf("\tneighbor: none\n");
	else
		printf("\tneighbor: %s\n", inet_ntoa(sin->sin_addr));
}

/* ARGSUSED */
void
setmpelabel(const char *val, int d)
{
	struct shim_hdr	 shim;
	const char	*estr;

	bzero(&shim, sizeof(shim));
	ifr.ifr_data = (caddr_t)&shim;
	shim.shim_label = strtonum(val, 0, MPLS_LABEL_MAX, &estr);

	if (estr)
		errx(1, "mpls label %s is %s", val, estr);
	if (ioctl(s, SIOCSETLABEL, (caddr_t)&ifr) == -1)
		warn("SIOCSETLABEL");
}

void
process_mpw_commands(void)
{
	struct	sockaddr_in *sin, *sinn;
	struct	ifmpwreq imr;

	if (wconfig == 0)
		return;

	bzero(&imr, sizeof(imr));
	ifr.ifr_data = (caddr_t) &imr;
	if (ioctl(s, SIOCGETMPWCFG, (caddr_t) &ifr) == -1)
		err(1, "SIOCGETMPWCFG");

	if (imrsave.imr_type == 0) {
		if (imr.imr_type == 0)
			imrsave.imr_type = IMR_TYPE_ETHERNET;

		imrsave.imr_type = imr.imr_type;
	}
	if (wcwconfig == 0)
		imrsave.imr_flags |= imr.imr_flags;

	if (imrsave.imr_lshim.shim_label == 0 ||
	    imrsave.imr_rshim.shim_label == 0) {
		if (imr.imr_lshim.shim_label == 0 ||
		    imr.imr_rshim.shim_label == 0)
			errx(1, "mpw local / remote label not specified");

		imrsave.imr_lshim.shim_label = imr.imr_lshim.shim_label;
		imrsave.imr_rshim.shim_label = imr.imr_rshim.shim_label;
	}

	sin = (struct sockaddr_in *) &imrsave.imr_nexthop;
	sinn = (struct sockaddr_in *) &imr.imr_nexthop;
	if (sin->sin_addr.s_addr == 0) {
		if (sinn->sin_addr.s_addr == 0)
			errx(1, "mpw neighbor address not specified");

		sin->sin_family = sinn->sin_family;
		sin->sin_addr.s_addr = sinn->sin_addr.s_addr;
	}

	ifr.ifr_data = (caddr_t) &imrsave;
	if (ioctl(s, SIOCSETMPWCFG, (caddr_t) &ifr) == -1)
		err(1, "SIOCSETMPWCFG");
}

void
setmpwencap(const char *value, int d)
{
	wconfig = 1;

	if (strcmp(value, "ethernet") == 0)
		imrsave.imr_type = IMR_TYPE_ETHERNET;
	else if (strcmp(value, "ethernet-tagged") == 0)
		imrsave.imr_type = IMR_TYPE_ETHERNET_TAGGED;
	else
		errx(1, "invalid mpw encapsulation type");
}

void
setmpwlabel(const char *local, const char *remote)
{
	const	char *errstr;

	wconfig = 1;

	imrsave.imr_lshim.shim_label = strtonum(local,
	    (MPLS_LABEL_RESERVED_MAX + 1), MPLS_LABEL_MAX, &errstr);
	if (errstr != NULL)
		errx(1, "invalid local label: %s", errstr);

	imrsave.imr_rshim.shim_label = strtonum(remote,
	    (MPLS_LABEL_RESERVED_MAX + 1), MPLS_LABEL_MAX, &errstr);
	if (errstr != NULL)
		errx(1, "invalid remote label: %s", errstr);
}

void
setmpwneighbor(const char *value, int d)
{
	struct sockaddr_in *sin;

	wconfig = 1;

	sin = (struct sockaddr_in *) &imrsave.imr_nexthop;
	if (inet_aton(value, &sin->sin_addr) == 0)
		errx(1, "invalid neighbor addresses");

	sin->sin_family = AF_INET;
}

void
setmpwcontrolword(const char *value, int d)
{
	wconfig = 1;
	wcwconfig = 1;

	if (d == 1)
		imrsave.imr_flags |= IMR_FLAG_CONTROLWORD;
	else
		imrsave.imr_flags &= ~IMR_FLAG_CONTROLWORD;
}
#endif /* SMALL */

void
setvnetid(const char *id, int param)
{
	const char *errmsg = NULL;
	int64_t vnetid;

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));

	if (strcasecmp("any", id) == 0)
		vnetid = -1;
	else {
		vnetid = strtonum(id, 0, INT64_MAX, &errmsg);
		if (errmsg)
			errx(1, "vnetid %s: %s", id, errmsg);
	}

	ifr.ifr_vnetid = vnetid;
	if (ioctl(s, SIOCSVNETID, (caddr_t)&ifr) < 0)
		warn("SIOCSVNETID");
}

/* ARGSUSED */
void
delvnetid(const char *ignored, int alsoignored)
{
	if (ioctl(s, SIOCDVNETID, &ifr) < 0)
		warn("SIOCDVNETID");
}

void
getvnetid(void)
{
	if (strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name)) >=
	    sizeof(ifr.ifr_name))
		errx(1, "vnetid: name is too long");

	if (ioctl(s, SIOCGVNETID, &ifr) == -1) {
		if (errno != EADDRNOTAVAIL)
			return;

		printf("\tvnetid: none\n");

		return;
	}

	if (ifr.ifr_vnetid < 0) {
		printf("\tvnetid: any\n");
		return;
	}

	printf("\tvnetid: %lld\n", ifr.ifr_vnetid);
}

void
setifparent(const char *id, int param)
{
	struct if_parent ifp;

	if (strlcpy(ifp.ifp_name, name, sizeof(ifp.ifp_name)) >=
	    sizeof(ifp.ifp_name))
		errx(1, "parent: name too long");

	if (strlcpy(ifp.ifp_parent, id, sizeof(ifp.ifp_parent)) >=
	    sizeof(ifp.ifp_parent))
		errx(1, "parent: parent too long");

	if (ioctl(s, SIOCSIFPARENT, (caddr_t)&ifp) < 0)
		warn("SIOCSIFPARENT");
}

/* ARGSUSED */
void
delifparent(const char *ignored, int alsoignored)
{
	if (ioctl(s, SIOCDIFPARENT, &ifr) < 0)
		warn("SIOCDIFPARENT");
}

void
getifparent(void)
{
	struct if_parent ifp;
	const char *parent = "none";

	memset(&ifp, 0, sizeof(ifp));
	if (strlcpy(ifp.ifp_name, name, sizeof(ifp.ifp_name)) >=
	    sizeof(ifp.ifp_name))
		errx(1, "parent: name too long");

	if (ioctl(s, SIOCGIFPARENT, (caddr_t)&ifp) == -1) {
		if (errno != EADDRNOTAVAIL)
			return;
	} else
		parent = ifp.ifp_parent;

	printf("\tparent: %s\n", parent);
}

static int __tag = 0;
static int __have_tag = 0;

void
vlan_status(void)
{
	struct vlanreq vreq;

	bzero((char *)&vreq, sizeof(struct vlanreq));
	ifr.ifr_data = (caddr_t)&vreq;

	if (ioctl(s, SIOCGETVLAN, (caddr_t)&ifr) == -1)
		return;

	if (vreq.vlr_tag || (vreq.vlr_parent[0] != '\0'))
		printf("\tvlan: %d parent interface: %s\n",
		    vreq.vlr_tag, vreq.vlr_parent[0] == '\0' ?
		    "<none>" : vreq.vlr_parent);
}

/* ARGSUSED */
void
setvlantag(const char *val, int d)
{
	u_int16_t tag;
	struct vlanreq vreq;
	const char *errmsg = NULL;

	__tag = tag = strtonum(val, 0, 4095, &errmsg);
	if (errmsg)
		errx(1, "vlan tag %s: %s", val, errmsg);
	__have_tag = 1;

	bzero((char *)&vreq, sizeof(struct vlanreq));
	ifr.ifr_data = (caddr_t)&vreq;

	if (ioctl(s, SIOCGETVLAN, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETVLAN");

	vreq.vlr_tag = tag;

	if (ioctl(s, SIOCSETVLAN, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETVLAN");
}

/* ARGSUSED */
void
setvlandev(const char *val, int d)
{
	struct vlanreq	 vreq;
	int		 tag;
	size_t		 skip;
	const char	*estr;

	bzero((char *)&vreq, sizeof(struct vlanreq));
	ifr.ifr_data = (caddr_t)&vreq;

	if (ioctl(s, SIOCGETVLAN, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETVLAN");

	(void) strlcpy(vreq.vlr_parent, val, sizeof(vreq.vlr_parent));

	if (!__have_tag && vreq.vlr_tag == 0) {
		skip = strcspn(ifr.ifr_name, "0123456789");
		tag = strtonum(ifr.ifr_name + skip, 0, 4095, &estr);
		if (estr != NULL)
			errx(1, "invalid vlan tag and device specification");
		vreq.vlr_tag = tag;
	} else if (__have_tag)
		vreq.vlr_tag = __tag;

	if (ioctl(s, SIOCSETVLAN, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETVLAN");
}

/* ARGSUSED */
void
unsetvlandev(const char *val, int d)
{
	struct vlanreq vreq;

	bzero((char *)&vreq, sizeof(struct vlanreq));
	ifr.ifr_data = (caddr_t)&vreq;

	if (ioctl(s, SIOCGETVLAN, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETVLAN");

	bzero((char *)&vreq.vlr_parent, sizeof(vreq.vlr_parent));
	vreq.vlr_tag = 0;

	if (ioctl(s, SIOCSETVLAN, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETVLAN");
}

void
settrunkport(const char *val, int d)
{
	struct trunk_reqport rp;

	bzero(&rp, sizeof(rp));
	strlcpy(rp.rp_ifname, name, sizeof(rp.rp_ifname));
	strlcpy(rp.rp_portname, val, sizeof(rp.rp_portname));

	if (ioctl(s, SIOCSTRUNKPORT, &rp))
		err(1, "SIOCSTRUNKPORT");
}

void
unsettrunkport(const char *val, int d)
{
	struct trunk_reqport rp;

	bzero(&rp, sizeof(rp));
	strlcpy(rp.rp_ifname, name, sizeof(rp.rp_ifname));
	strlcpy(rp.rp_portname, val, sizeof(rp.rp_portname));

	if (ioctl(s, SIOCSTRUNKDELPORT, &rp))
		err(1, "SIOCSTRUNKDELPORT");
}

void
settrunkproto(const char *val, int d)
{
	struct trunk_protos tpr[] = TRUNK_PROTOS;
	struct trunk_reqall ra;
	int i;

	bzero(&ra, sizeof(ra));
	ra.ra_proto = TRUNK_PROTO_MAX;

	for (i = 0; i < (sizeof(tpr) / sizeof(tpr[0])); i++) {
		if (strcmp(val, tpr[i].tpr_name) == 0) {
			ra.ra_proto = tpr[i].tpr_proto;
			break;
		}
	}
	if (ra.ra_proto == TRUNK_PROTO_MAX)
		errx(1, "Invalid trunk protocol: %s", val);

	strlcpy(ra.ra_ifname, name, sizeof(ra.ra_ifname));
	if (ioctl(s, SIOCSTRUNK, &ra) != 0)
		err(1, "SIOCSTRUNK");
}

void
trunk_status(void)
{
	struct trunk_protos tpr[] = TRUNK_PROTOS;
	struct trunk_reqport rp, rpbuf[TRUNK_MAX_PORTS];
	struct trunk_reqall ra;
	struct lacp_opreq *lp;
	const char *proto = "<unknown>";
	int i, isport = 0;

	bzero(&rp, sizeof(rp));
	bzero(&ra, sizeof(ra));

	strlcpy(rp.rp_ifname, name, sizeof(rp.rp_ifname));
	strlcpy(rp.rp_portname, name, sizeof(rp.rp_portname));

	if (ioctl(s, SIOCGTRUNKPORT, &rp) == 0)
		isport = 1;

	strlcpy(ra.ra_ifname, name, sizeof(ra.ra_ifname));
	ra.ra_size = sizeof(rpbuf);
	ra.ra_port = rpbuf;

	if (ioctl(s, SIOCGTRUNK, &ra) == 0) {
		lp = (struct lacp_opreq *)&ra.ra_lacpreq;

		for (i = 0; i < (sizeof(tpr) / sizeof(tpr[0])); i++) {
			if (ra.ra_proto == tpr[i].tpr_proto) {
				proto = tpr[i].tpr_name;
				break;
			}
		}

		printf("\ttrunk: trunkproto %s", proto);
		if (isport)
			printf(" trunkdev %s", rp.rp_ifname);
		putchar('\n');
		if (ra.ra_proto == TRUNK_PROTO_LACP) {
			char *act_mac = strdup(
			    ether_ntoa((struct ether_addr*)lp->actor_mac));
			if (act_mac == NULL)
				err(1, "strdup");
			printf("\ttrunk id: [(%04X,%s,%04X,%04X,%04X),\n"
			    "\t\t (%04X,%s,%04X,%04X,%04X)]\n",
			    lp->actor_prio, act_mac,
			    lp->actor_key, lp->actor_portprio, lp->actor_portno,
			    lp->partner_prio,
			    ether_ntoa((struct ether_addr*)lp->partner_mac),
			    lp->partner_key, lp->partner_portprio,
			    lp->partner_portno);
			free(act_mac);
		}

		for (i = 0; i < ra.ra_ports; i++) {
			printf("\t\ttrunkport %s ", rpbuf[i].rp_portname);
			printb_status(rpbuf[i].rp_flags, TRUNK_PORT_BITS);
			putchar('\n');
		}

		if (showmediaflag) {
			printf("\tsupported trunk protocols:\n");
			for (i = 0; i < (sizeof(tpr) / sizeof(tpr[0])); i++)
				printf("\t\ttrunkproto %s\n", tpr[i].tpr_name);
		}
	} else if (isport)
		printf("\ttrunk: trunkdev %s\n", rp.rp_ifname);
}

#ifndef SMALL
static const char *carp_states[] = { CARP_STATES };
static const char *carp_bal_modes[] = { CARP_BAL_MODES };

void
carp_status(void)
{
	const char *state, *balmode;
	struct carpreq carpr;
	char peer[32];
	int i;

	memset((char *)&carpr, 0, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		return;

	if (carpr.carpr_vhids[0] == 0)
		return;

	if (carpr.carpr_balancing > CARP_BAL_MAXID)
		balmode = "<UNKNOWN>";
	else
		balmode = carp_bal_modes[carpr.carpr_balancing];

	if (carpr.carpr_peer.s_addr != htonl(INADDR_CARP_GROUP))
		snprintf(peer, sizeof(peer),
		    " carppeer %s", inet_ntoa(carpr.carpr_peer));
	else
		peer[0] = '\0';

	for (i = 0; carpr.carpr_vhids[i]; i++) {
		if (carpr.carpr_states[i] > CARP_MAXSTATE)
			state = "<UNKNOWN>";
		else
			state = carp_states[carpr.carpr_states[i]];
		if (carpr.carpr_vhids[1] == 0) {
			printf("\tcarp: %s carpdev %s vhid %u advbase %d "
			    "advskew %u%s\n", state,
			    carpr.carpr_carpdev[0] != '\0' ?
			    carpr.carpr_carpdev : "none", carpr.carpr_vhids[0],
			    carpr.carpr_advbase, carpr.carpr_advskews[0],
			    peer);
		} else {
			if (i == 0) {
				printf("\tcarp: carpdev %s advbase %d"
				    " balancing %s%s\n",
				    carpr.carpr_carpdev[0] != '\0' ?
				    carpr.carpr_carpdev : "none",
				    carpr.carpr_advbase, balmode, peer);
			}
			printf("\t\tstate %s vhid %u advskew %u\n", state,
			    carpr.carpr_vhids[i], carpr.carpr_advskews[i]);
		}
	}
}

/* ARGSUSED */
void
setcarp_passwd(const char *val, int d)
{
	struct carpreq carpr;

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	bzero(carpr.carpr_key, CARP_KEY_LEN);
	strlcpy((char *)carpr.carpr_key, val, CARP_KEY_LEN);

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

/* ARGSUSED */
void
setcarp_vhid(const char *val, int d)
{
	const char *errmsg = NULL;
	struct carpreq carpr;
	int vhid;

	vhid = strtonum(val, 1, 255, &errmsg);
	if (errmsg)
		errx(1, "vhid %s: %s", val, errmsg);

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	carpr.carpr_vhids[0] = vhid;
	carpr.carpr_vhids[1] = 0;

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

/* ARGSUSED */
void
setcarp_advskew(const char *val, int d)
{
	const char *errmsg = NULL;
	struct carpreq carpr;
	int advskew;

	advskew = strtonum(val, 0, 254, &errmsg);
	if (errmsg)
		errx(1, "advskew %s: %s", val, errmsg);

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	carpr.carpr_advskews[0] = advskew;

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

/* ARGSUSED */
void
setcarp_advbase(const char *val, int d)
{
	const char *errmsg = NULL;
	struct carpreq carpr;
	int advbase;

	advbase = strtonum(val, 0, 254, &errmsg);
	if (errmsg)
		errx(1, "advbase %s: %s", val, errmsg);

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	carpr.carpr_advbase = advbase;

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

/* ARGSUSED */
void
setcarppeer(const char *val, int d)
{
	struct carpreq carpr;
	struct addrinfo hints, *peerres;
	int ecode;

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_DGRAM;

	if ((ecode = getaddrinfo(val, NULL, &hints, &peerres)) != 0)
		errx(1, "error in parsing address string: %s",
		    gai_strerror(ecode));

	if (peerres->ai_addr->sa_family != AF_INET)
		errx(1, "only IPv4 addresses supported for the carppeer");

	carpr.carpr_peer.s_addr = ((struct sockaddr_in *)
	    peerres->ai_addr)->sin_addr.s_addr;

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");

	freeaddrinfo(peerres);
}

void
unsetcarppeer(const char *val, int d)
{
	struct carpreq carpr;

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	bzero(&carpr.carpr_peer, sizeof(carpr.carpr_peer));

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

/* ARGSUSED */
void
setcarp_state(const char *val, int d)
{
	struct carpreq carpr;
	int i;

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	for (i = 0; i <= CARP_MAXSTATE; i++) {
		if (!strcasecmp(val, carp_states[i])) {
			carpr.carpr_state = i;
			break;
		}
	}

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

/* ARGSUSED */
void
setcarpdev(const char *val, int d)
{
	struct carpreq carpr;

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	strlcpy(carpr.carpr_carpdev, val, sizeof(carpr.carpr_carpdev));

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

void
setcarp_nodes(const char *val, int d)
{
	char *optlist, *str;
	int i;
	struct carpreq carpr;

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	bzero(carpr.carpr_vhids, sizeof(carpr.carpr_vhids));
	bzero(carpr.carpr_advskews, sizeof(carpr.carpr_advskews));

	optlist = strdup(val);
	if (optlist == NULL)
		err(1, "strdup");

	str = strtok(optlist, ",");
	for (i = 0; str != NULL; i++) {
		u_int vhid, advskew;

		if (i >= CARP_MAXNODES)
			errx(1, "too many carp nodes");
		if (sscanf(str, "%u:%u", &vhid, &advskew) != 2) {
			errx(1, "non parsable arg: %s", str);
		}
		if (vhid > 255)
			errx(1, "vhid %u: value too large", vhid);
		if (advskew >= 255)
			errx(1, "advskew %u: value too large", advskew);

		carpr.carpr_vhids[i] = vhid;
		carpr.carpr_advskews[i] = advskew;
		str = strtok(NULL, ",");
	}
	free(optlist);

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

void
setcarp_balancing(const char *val, int d)
{
	int i;
	struct carpreq carpr;

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	for (i = 0; i <= CARP_BAL_MAXID; i++)
		if (!strcasecmp(val, carp_bal_modes[i]))
			break;

	if (i > CARP_BAL_MAXID)
		errx(1, "balancing %s: unknown mode", val);

	carpr.carpr_balancing = i;

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

void
setpfsync_syncdev(const char *val, int d)
{
	struct pfsyncreq preq;

	bzero(&preq, sizeof(struct pfsyncreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETPFSYNC");

	strlcpy(preq.pfsyncr_syncdev, val, sizeof(preq.pfsyncr_syncdev));

	if (ioctl(s, SIOCSETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFSYNC");
}

/* ARGSUSED */
void
unsetpfsync_syncdev(const char *val, int d)
{
	struct pfsyncreq preq;

	bzero(&preq, sizeof(struct pfsyncreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETPFSYNC");

	bzero(&preq.pfsyncr_syncdev, sizeof(preq.pfsyncr_syncdev));

	if (ioctl(s, SIOCSETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFSYNC");
}

/* ARGSUSED */
void
setpfsync_syncpeer(const char *val, int d)
{
	struct pfsyncreq preq;
	struct addrinfo hints, *peerres;
	int ecode;

	bzero(&preq, sizeof(struct pfsyncreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETPFSYNC");

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/

	if ((ecode = getaddrinfo(val, NULL, &hints, &peerres)) != 0)
		errx(1, "error in parsing address string: %s",
		    gai_strerror(ecode));

	if (peerres->ai_addr->sa_family != AF_INET)
		errx(1, "only IPv4 addresses supported for the syncpeer");

	preq.pfsyncr_syncpeer.s_addr = ((struct sockaddr_in *)
	    peerres->ai_addr)->sin_addr.s_addr;

	if (ioctl(s, SIOCSETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFSYNC");

	freeaddrinfo(peerres);
}

/* ARGSUSED */
void
unsetpfsync_syncpeer(const char *val, int d)
{
	struct pfsyncreq preq;

	bzero(&preq, sizeof(struct pfsyncreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETPFSYNC");

	preq.pfsyncr_syncpeer.s_addr = 0;

	if (ioctl(s, SIOCSETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFSYNC");
}

/* ARGSUSED */
void
setpfsync_maxupd(const char *val, int d)
{
	const char *errmsg = NULL;
	struct pfsyncreq preq;
	int maxupdates;

	maxupdates = strtonum(val, 0, 255, &errmsg);
	if (errmsg)
		errx(1, "maxupd %s: %s", val, errmsg);

	bzero(&preq, sizeof(struct pfsyncreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETPFSYNC");

	preq.pfsyncr_maxupdates = maxupdates;

	if (ioctl(s, SIOCSETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFSYNC");
}

void
setpfsync_defer(const char *val, int d)
{
	struct pfsyncreq preq;

	bzero(&preq, sizeof(struct pfsyncreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETPFSYNC");

	preq.pfsyncr_defer = d;
	if (ioctl(s, SIOCSETPFSYNC, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFSYNC");
}

void
pfsync_status(void)
{
	struct pfsyncreq preq;

	bzero(&preq, sizeof(struct pfsyncreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETPFSYNC, (caddr_t)&ifr) == -1)
		return;

	if (preq.pfsyncr_syncdev[0] != '\0') {
		printf("\tpfsync: syncdev: %s ", preq.pfsyncr_syncdev);
		if (preq.pfsyncr_syncpeer.s_addr != htonl(INADDR_PFSYNC_GROUP))
			printf("syncpeer: %s ",
			    inet_ntoa(preq.pfsyncr_syncpeer));
		printf("maxupd: %d ", preq.pfsyncr_maxupdates);
		printf("defer: %s\n", preq.pfsyncr_defer ? "on" : "off");
	}
}

void
pflow_status(void)
{
	struct pflowreq		 preq;
	struct sockaddr_in	*sin;
	struct sockaddr_in6	*sin6;
	int			 error;
	char			 buf[INET6_ADDRSTRLEN];

	bzero(&preq, sizeof(struct pflowreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETPFLOW, (caddr_t)&ifr) == -1)
		 return;

	if (preq.flowsrc.ss_family == AF_INET || preq.flowsrc.ss_family ==
	    AF_INET6) {
		error = getnameinfo((struct sockaddr*)&preq.flowsrc,
		    preq.flowsrc.ss_len, buf, sizeof(buf), NULL, 0,
		    NI_NUMERICHOST);
		if (error)
			err(1, "sender: %s", gai_strerror(error));
	}

	printf("\tpflow: ");
	switch (preq.flowsrc.ss_family) {
	case AF_INET:
		sin = (struct sockaddr_in*) &preq.flowsrc;
		if (sin->sin_addr.s_addr != INADDR_ANY) {
			printf("sender: %s", buf);
			if (sin->sin_port != 0)
				printf(":%u", ntohs(sin->sin_port));
			printf(" ");
		}
		break;
	case AF_INET6:
		sin6 = (struct sockaddr_in6*) &preq.flowsrc;
		if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
			printf("sender: [%s]", buf);
			if (sin6->sin6_port != 0)
				printf(":%u", ntohs(sin6->sin6_port));
			printf(" ");
		}
	default:
		break;
	}
	if (preq.flowdst.ss_family == AF_INET || preq.flowdst.ss_family ==
	    AF_INET6) {
		error = getnameinfo((struct sockaddr*)&preq.flowdst,
		    preq.flowdst.ss_len, buf, sizeof(buf), NULL, 0,
		    NI_NUMERICHOST);
		if (error)
			err(1, "receiver: %s", gai_strerror(error));
	}
	switch (preq.flowdst.ss_family) {
	case AF_INET:
		sin = (struct sockaddr_in*)&preq.flowdst;
		printf("receiver: %s:", sin->sin_addr.s_addr != INADDR_ANY ?
		    buf : "INVALID");
		if (sin->sin_port == 0)
			printf("%s ", "INVALID");
		else
			printf("%u ", ntohs(sin->sin_port));
		break;
	case AF_INET6:
		sin6 = (struct sockaddr_in6*) &preq.flowdst;
		printf("receiver: [%s]:",
		    !IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) ? buf :
		    "INVALID");
		if (sin6->sin6_port == 0)
			printf("%s ", "INVALID");
		else
			printf("%u ", ntohs(sin6->sin6_port));
		break;
	default:
		printf("receiver: INVALID:INVALID ");
		break;
	}
	printf("version: %d\n", preq.version);
}

void
pflow_addr(const char *val, struct sockaddr_storage *ss) {
	struct addrinfo hints, *res0;
	int error, flag;
	char *cp, *ip, *port, buf[HOST_NAME_MAX+1 + sizeof (":65535")];

	if (strlcpy(buf, val, sizeof(buf)) >= sizeof(buf))
		errx(1, "%s bad value", val);

	port = NULL;
	cp = buf;
	if (*cp == '[')
		flag = 1;
	else
		flag = 0;

	for(; *cp; ++cp) {
		if (*cp == ']' && *(cp + 1) == ':' && flag) {
			*cp = '\0';
			*(cp + 1) = '\0';
			port = cp + 2;
			break;
		}
		if (*cp == ']' && *(cp + 1) == '\0' && flag) {
			*cp = '\0';
			port = NULL;
			break;
		}
		if (*cp == ':' && !flag) {
			*cp = '\0';
			port = cp + 1;
			break;
		}
	}

	ip = buf;
	if (flag)
		ip++;

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/

	if ((error = getaddrinfo(ip, port, &hints, &res0)) != 0)
		errx(1, "error in parsing address string: %s",
		    gai_strerror(error));

	memcpy(ss, res0->ai_addr, res0->ai_addr->sa_len);
	freeaddrinfo(res0);
}

void
setpflow_sender(const char *val, int d)
{
	struct pflowreq preq;

	bzero(&preq, sizeof(struct pflowreq));
	ifr.ifr_data = (caddr_t)&preq;
	preq.addrmask |= PFLOW_MASK_SRCIP;
	pflow_addr(val, &preq.flowsrc);

	if (ioctl(s, SIOCSETPFLOW, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFLOW");
}

void
unsetpflow_sender(const char *val, int d)
{
	struct pflowreq preq;

	bzero(&preq, sizeof(struct pflowreq));
	preq.addrmask |= PFLOW_MASK_SRCIP;
	ifr.ifr_data = (caddr_t)&preq;
	if (ioctl(s, SIOCSETPFLOW, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFLOW");
}

void
setpflow_receiver(const char *val, int d)
{
	struct pflowreq preq;

	bzero(&preq, sizeof(struct pflowreq));
	ifr.ifr_data = (caddr_t)&preq;
	preq.addrmask |= PFLOW_MASK_DSTIP;
	pflow_addr(val, &preq.flowdst);

	if (ioctl(s, SIOCSETPFLOW, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFLOW");
}

void
unsetpflow_receiver(const char *val, int d)
{
	struct pflowreq preq;

	bzero(&preq, sizeof(struct pflowreq));
	ifr.ifr_data = (caddr_t)&preq;
	preq.addrmask |= PFLOW_MASK_DSTIP;
	if (ioctl(s, SIOCSETPFLOW, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFLOW");
}

/* PFLOWPROTO XXX */
void
setpflowproto(const char *val, int d)
{
	struct pflow_protos ppr[] = PFLOW_PROTOS;
	struct pflowreq preq;
	int i;

	bzero(&preq, sizeof(preq));
	preq.version = PFLOW_PROTO_MAX;

	for (i = 0; i < (sizeof(ppr) / sizeof(ppr[0])); i++) {
		if (strcmp(val, ppr[i].ppr_name) == 0) {
			preq.version = ppr[i].ppr_proto;
			break;
		}
	}
	if (preq.version == PFLOW_PROTO_MAX)
		errx(1, "Invalid pflow protocol: %s", val);

	preq.addrmask |= PFLOW_MASK_VERSION;

	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCSETPFLOW, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETPFLOW");
}

void
pppoe_status(void)
{
	struct pppoediscparms parms;
	struct pppoeconnectionstate state;

	memset(&state, 0, sizeof(state));

	strlcpy(parms.ifname, name, sizeof(parms.ifname));
	if (ioctl(s, PPPOEGETPARMS, &parms))
		return;

	printf("\tdev: %s ", parms.eth_ifname);

	if (*parms.ac_name)
		printf("ac: %s ", parms.ac_name);
	if (*parms.service_name)
		printf("svc: %s ", parms.service_name);

	strlcpy(state.ifname, name, sizeof(state.ifname));
	if (ioctl(s, PPPOEGETSESSION, &state))
		err(1, "PPPOEGETSESSION");

	printf("state: ");
	switch (state.state) {
	case PPPOE_STATE_INITIAL:
		printf("initial"); break;
	case PPPOE_STATE_PADI_SENT:
		printf("PADI sent"); break;
	case PPPOE_STATE_PADR_SENT:
		printf("PADR sent"); break;
	case PPPOE_STATE_SESSION:
		printf("session"); break;
	case PPPOE_STATE_CLOSING:
		printf("closing"); break;
	}
	printf("\n\tsid: 0x%x", state.session_id);
	printf(" PADI retries: %d", state.padi_retry_no);
	printf(" PADR retries: %d", state.padr_retry_no);

	if (state.state == PPPOE_STATE_SESSION) {
		struct timeval temp_time;
		time_t diff_time, day = 0;
		unsigned int hour = 0, min = 0, sec = 0;

		if (state.session_time.tv_sec != 0) {
			gettimeofday(&temp_time, NULL);
			diff_time = temp_time.tv_sec -
			    state.session_time.tv_sec;

			day = diff_time / (60 * 60 * 24);
			diff_time %= (60 * 60 * 24);

			hour = diff_time / (60 * 60);
			diff_time %= (60 * 60);

			min = diff_time / 60;
			diff_time %= 60;

			sec = diff_time;
		}
		printf(" time: ");
		if (day != 0)
			printf("%lldd ", (long long)day);
		printf("%02u:%02u:%02u", hour, min, sec);
	}
	putchar('\n');
}

/* ARGSUSED */
void
setpppoe_dev(const char *val, int d)
{
	struct pppoediscparms parms;

	strlcpy(parms.ifname, name, sizeof(parms.ifname));
	if (ioctl(s, PPPOEGETPARMS, &parms))
		return;

	strlcpy(parms.eth_ifname, val, sizeof(parms.eth_ifname));

	if (ioctl(s, PPPOESETPARMS, &parms))
		err(1, "PPPOESETPARMS");
}

/* ARGSUSED */
void
setpppoe_svc(const char *val, int d)
{
	struct pppoediscparms parms;

	strlcpy(parms.ifname, name, sizeof(parms.ifname));
	if (ioctl(s, PPPOEGETPARMS, &parms))
		return;

	if (d == 0)
		strlcpy(parms.service_name, val, sizeof(parms.service_name));
	else
		memset(parms.service_name, 0, sizeof(parms.service_name));

	if (ioctl(s, PPPOESETPARMS, &parms))
		err(1, "PPPOESETPARMS");
}

/* ARGSUSED */
void
setpppoe_ac(const char *val, int d)
{
	struct pppoediscparms parms;

	strlcpy(parms.ifname, name, sizeof(parms.ifname));
	if (ioctl(s, PPPOEGETPARMS, &parms))
		return;

	if (d == 0)
		strlcpy(parms.ac_name, val, sizeof(parms.ac_name));
	else
		memset(parms.ac_name, 0, sizeof(parms.ac_name));

	if (ioctl(s, PPPOESETPARMS, &parms))
		err(1, "PPPOESETPARMS");
}

void
spppauthinfo(struct sauthreq *spa, int d)
{
	bzero(spa, sizeof(struct sauthreq));

	ifr.ifr_data = (caddr_t)spa;
	spa->cmd = d == 0 ? SPPPIOGMAUTH : SPPPIOGHAUTH;
	if (ioctl(s, SIOCGSPPPPARAMS, &ifr) == -1)
		err(1, "SIOCGSPPPPARAMS(SPPPIOGXAUTH)");
}

void
setspppproto(const char *val, int d)
{
	struct sauthreq spa;

	spppauthinfo(&spa, d);

	if (strcmp(val, "pap") == 0)
		spa.proto = PPP_PAP;
	else if (strcmp(val, "chap") == 0)
		spa.proto = PPP_CHAP;
	else if (strcmp(val, "none") == 0)
		spa.proto = 0;
	else
		errx(1, "setpppproto");

	spa.cmd = d == 0 ? SPPPIOSMAUTH : SPPPIOSHAUTH;
	if (ioctl(s, SIOCSSPPPPARAMS, &ifr) == -1)
		err(1, "SIOCSSPPPPARAMS(SPPPIOSXAUTH)");
}

void
setsppppeerproto(const char *val, int d)
{
	setspppproto(val, 1);
}

void
setspppname(const char *val, int d)
{
	struct sauthreq spa;

	spppauthinfo(&spa, d);

	if (spa.proto == 0)
		errx(1, "unspecified protocol");
	if (strlcpy(spa.name, val, sizeof(spa.name)) >= sizeof(spa.name))
		errx(1, "setspppname");

	spa.cmd = d == 0 ? SPPPIOSMAUTH : SPPPIOSHAUTH;
	if (ioctl(s, SIOCSSPPPPARAMS, &ifr) == -1)
		err(1, "SIOCSSPPPPARAMS(SPPPIOSXAUTH)");
}

void
setsppppeername(const char *val, int d)
{
	setspppname(val, 1);
}

void
setspppkey(const char *val, int d)
{
	struct sauthreq spa;

	spppauthinfo(&spa, d);

	if (spa.proto == 0)
		errx(1, "unspecified protocol");
	if (strlcpy(spa.secret, val, sizeof(spa.secret)) >= sizeof(spa.secret))
		errx(1, "setspppkey");

	spa.cmd = d == 0 ? SPPPIOSMAUTH : SPPPIOSHAUTH;
	if (ioctl(s, SIOCSSPPPPARAMS, &ifr) == -1)
		err(1, "SIOCSSPPPPARAMS(SPPPIOSXAUTH)");
}

void
setsppppeerkey(const char *val, int d)
{
	setspppkey(val, 1);
}

void
setsppppeerflag(const char *val, int d)
{
	struct sauthreq spa;
	int flag;

	spppauthinfo(&spa, 1);

	if (spa.proto == 0)
		errx(1, "unspecified protocol");
	if (strcmp(val, "callin") == 0)
		flag = AUTHFLAG_NOCALLOUT;
	else if (strcmp(val, "norechallenge") == 0)
		flag = AUTHFLAG_NORECHALLENGE;
	else
		errx(1, "setppppeerflags");

	if (d)
		spa.flags &= ~flag;
	else
		spa.flags |= flag;

	spa.cmd = SPPPIOSHAUTH;
	if (ioctl(s, SIOCSSPPPPARAMS, &ifr) == -1)
		err(1, "SIOCSSPPPPARAMS(SPPPIOSXAUTH)");
}

void
unsetsppppeerflag(const char *val, int d)
{
	setsppppeerflag(val, 1);
}

void
sppp_printproto(const char *name, struct sauthreq *auth)
{
	if (auth->proto == 0)
		return;
	printf("%sproto ", name);
	switch (auth->proto) {
	case PPP_PAP:
		printf("pap ");
		break;
	case PPP_CHAP:
		printf("chap ");
		break;
	default:
		printf("0x%04x ", auth->proto);
		break;
	}
	if (auth->name[0])
		printf("%sname \"%s\" ", name, auth->name);
	if (auth->secret[0])
		printf("%skey \"%s\" ", name, auth->secret);
}

void
sppp_status(void)
{
	struct spppreq spr;
	struct sauthreq spa;

	bzero(&spr, sizeof(spr));

	ifr.ifr_data = (caddr_t)&spr;
	spr.cmd = SPPPIOGDEFS;
	if (ioctl(s, SIOCGSPPPPARAMS, &ifr) == -1) {
		return;
	}

	if (spr.phase == PHASE_DEAD)
		return;
	printf("\tsppp: phase ");
	switch (spr.phase) {
	case PHASE_ESTABLISH:
		printf("establish ");
		break;
	case PHASE_TERMINATE:
		printf("terminate ");
		break;
	case PHASE_AUTHENTICATE:
		printf("authenticate ");
		break;
	case PHASE_NETWORK:
		printf("network ");
		break;
	default:
		printf("illegal ");
		break;
	}

	spppauthinfo(&spa, 0);
	sppp_printproto("auth", &spa);
	spppauthinfo(&spa, 1);
	sppp_printproto("peer", &spa);
	if (spa.flags & AUTHFLAG_NOCALLOUT)
		printf("callin ");
	if (spa.flags & AUTHFLAG_NORECHALLENGE)
		printf("norechallenge ");
	putchar('\n');
}

void
setkeepalive(const char *timeout, const char *count)
{
	const char *errmsg = NULL;
	struct ifkalivereq ikar;
	int t, c;

	t = strtonum(timeout, 1, 3600, &errmsg);
	if (errmsg)
		errx(1, "keepalive period %s: %s", timeout, errmsg);
	c = strtonum(count, 2, 600, &errmsg);
	if (errmsg)
		errx(1, "keepalive count %s: %s", count, errmsg);

	strlcpy(ikar.ikar_name, name, sizeof(ikar.ikar_name));
	ikar.ikar_timeo = t;
	ikar.ikar_cnt = c;
	if (ioctl(s, SIOCSETKALIVE, (caddr_t)&ikar) < 0)
		warn("SIOCSETKALIVE");
}

void
unsetkeepalive(const char *val, int d)
{
	struct ifkalivereq ikar;

	bzero(&ikar, sizeof(ikar));
	strlcpy(ikar.ikar_name, name, sizeof(ikar.ikar_name));
	if (ioctl(s, SIOCSETKALIVE, (caddr_t)&ikar) < 0)
		warn("SIOCSETKALIVE");
}

void
setifpriority(const char *id, int param)
{
	const char *errmsg = NULL;
	int prio;

	prio = strtonum(id, 0, 15, &errmsg);
	if (errmsg)
		errx(1, "priority %s: %s", id, errmsg);

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_metric = prio;
	if (ioctl(s, SIOCSIFPRIORITY, (caddr_t)&ifr) < 0)
		warn("SIOCSIFPRIORITY");
}


const struct umb_valdescr umb_regstate[] = MBIM_REGSTATE_DESCRIPTIONS;
const struct umb_valdescr umb_dataclass[] = MBIM_DATACLASS_DESCRIPTIONS;
const struct umb_valdescr umb_simstate[] = MBIM_SIMSTATE_DESCRIPTIONS;
const struct umb_valdescr umb_istate[] = UMB_INTERNAL_STATE_DESCRIPTIONS;
const struct umb_valdescr umb_pktstate[] = MBIM_PKTSRV_STATE_DESCRIPTIONS;
const struct umb_valdescr umb_actstate[] = MBIM_ACTIVATION_STATE_DESCRIPTIONS;

const struct umb_valdescr umb_classalias[] = {
	{ MBIM_DATACLASS_GPRS | MBIM_DATACLASS_EDGE, "2g" },
	{ MBIM_DATACLASS_UMTS | MBIM_DATACLASS_HSDPA | MBIM_DATACLASS_HSUPA,
	    "3g" },
	{ MBIM_DATACLASS_LTE, "4g" },
	{ 0, NULL }
};

int
umb_descr2val(const struct umb_valdescr *vdp, char *str)
{
	while (vdp->descr != NULL) {
		if (!strcasecmp(vdp->descr, str))
			return vdp->val;
		vdp++;
	}
	return 0;
}

void
umb_status(void)
{
	struct umb_info mi;
	char	 provider[UMB_PROVIDERNAME_MAXLEN+1];
	char	 roamingtxt[UMB_ROAMINGTEXT_MAXLEN+1];
	char	 devid[UMB_DEVID_MAXLEN+1];
	char	 fwinfo[UMB_FWINFO_MAXLEN+1];
	char	 hwinfo[UMB_HWINFO_MAXLEN+1];
	char	 sid[UMB_SUBSCRIBERID_MAXLEN+1];
	char	 iccid[UMB_ICCID_MAXLEN+1];
	char	 apn[UMB_APN_MAXLEN+1];
	char	 pn[UMB_PHONENR_MAXLEN+1];
	int	 i, n;

	memset((char *)&mi, 0, sizeof(mi));
	ifr.ifr_data = (caddr_t)&mi;
	if (ioctl(s, SIOCGUMBINFO, (caddr_t)&ifr) == -1)
		return;

	if (mi.nwerror) {
		/* 3GPP 24.008 Cause Code */
		printf("\terror: ");
		switch (mi.nwerror) {
		case 2:
			printf("SIM not activated");
			break;
		case 4:
			printf("Roaming not supported");
			break;
		case 6:
			printf("SIM reported stolen");
			break;
		case 7:
			printf("No GPRS subscription");
			break;
		case 8:
			printf("GPRS and non-GPRS services not allowed");
			break;
		case 11:
			printf("Subscription expired");
			break;
		case 12:
			printf("Subscription does not cover current location");
			break;
		case 13:
			printf("No roaming in this location");
			break;
		case 14:
			printf("GPRS not supported");
			break;
		case 15:
			printf("No subscription for the service");
			break;
		case 17:
			printf("Registration failed");
			break;
		case 22:
			printf("Network congestion");
			break;
		default:
			printf("Error code %d", mi.nwerror);
			break;
		}
		printf("\n");
	}

	printf("\troaming %s registration %s",
	    mi.enable_roaming ? "enabled" : "disabled",
	    umb_val2descr(umb_regstate, mi.regstate));
	utf16_to_char(mi.roamingtxt, UMB_ROAMINGTEXT_MAXLEN,
	    roamingtxt, sizeof (roamingtxt));
	if (roamingtxt[0])
		printf(" [%s]", roamingtxt);
	printf("\n");

	if (showclasses)
		umb_printclasses("available classes", mi.supportedclasses);
	printf("\tstate %s cell-class %s",
	    umb_val2descr(umb_istate, mi.state),
	    umb_val2descr(umb_dataclass, mi.highestclass));
	if (mi.rssi != UMB_VALUE_UNKNOWN && mi.rssi != 0)
		printf(" rssi %ddBm", mi.rssi);
	if (mi.uplink_speed != 0 || mi.downlink_speed != 0) {
		char s[2][FMT_SCALED_STRSIZE];
		if (fmt_scaled(mi.uplink_speed, s[0]) != 0)
			snprintf(s[0], sizeof (s[0]), "%llu", mi.uplink_speed);
		if (fmt_scaled(mi.downlink_speed, s[1]) != 0)
			snprintf(s[1], sizeof (s[1]), "%llu", mi.downlink_speed);
		printf(" speed %sps up %sps down", s[0], s[1]);
	}
	printf("\n");

	printf("\tSIM %s PIN ", umb_val2descr(umb_simstate, mi.sim_state));
	switch (mi.pin_state) {
	case UMB_PIN_REQUIRED:
		printf("required");
		break;
	case UMB_PIN_UNLOCKED:
		printf("valid");
		break;
	case UMB_PUK_REQUIRED:
		printf("locked (PUK required)");
		break;
	default:
		printf("unknown state (%d)", mi.pin_state);
		break;
	}
	if (mi.pin_attempts_left != UMB_VALUE_UNKNOWN)
		printf(" (%d attempts left)", mi.pin_attempts_left);
	printf("\n");

	utf16_to_char(mi.sid, UMB_SUBSCRIBERID_MAXLEN, sid, sizeof (sid));
	utf16_to_char(mi.iccid, UMB_ICCID_MAXLEN, iccid, sizeof (iccid));
	utf16_to_char(mi.provider, UMB_PROVIDERNAME_MAXLEN,
	    provider, sizeof (provider));
	if (sid[0] || iccid[0] || provider[0]) {
		printf("\t");
		n = 0;
		if (sid[0])
			printf("%ssubscriber-id %s", n++ ? " " : "", sid);
		if (iccid[0])
			printf("%sICC-id %s", n++ ? " " : "", iccid);
		if (provider[0])
			printf("%sprovider %s", n ? " " : "", provider);
		printf("\n");
	}

	utf16_to_char(mi.hwinfo, UMB_HWINFO_MAXLEN, hwinfo, sizeof (hwinfo));
	utf16_to_char(mi.devid, UMB_DEVID_MAXLEN, devid, sizeof (devid));
	utf16_to_char(mi.fwinfo, UMB_FWINFO_MAXLEN, fwinfo, sizeof (fwinfo));
	if (hwinfo[0] || devid[0] || fwinfo[0]) {
		printf("\t");
		n = 0;
		if (hwinfo[0])
			printf("%sdevice %s", n++ ? " " : "", hwinfo);
		if (devid[0]) {
			printf("%s", n++ ? " " : "");
			switch (mi.cellclass) {
			case MBIM_CELLCLASS_GSM:
				printf("IMEI");
				break;
			case MBIM_CELLCLASS_CDMA:
				n = strlen(devid);
				if (n == 8 || n == 11) {
					printf("ESN");
					break;
				} else if (n == 14 || n == 18) {
					printf("MEID");
					break;
				}
				/*FALLTHROUGH*/
			default:
				printf("ID");
				break;
			}
			printf(" %s", devid);
		}
		if (fwinfo[0])
			printf("%sfirmware %s", n++ ? " " : "", fwinfo);
		printf("\n");
	}

	utf16_to_char(mi.pn, UMB_PHONENR_MAXLEN, pn, sizeof (pn));
	utf16_to_char(mi.apn, UMB_APN_MAXLEN, apn, sizeof (apn));
	if (pn[0] || apn[0]) {
		printf("\t");
		n = 0;
		if (pn[0])
			printf("%sphone# %s", n++ ? " " : "", pn);
		if (apn[0])
			printf("%sAPN %s", n++ ? " " : "", apn);
		printf("\n");
	}

	for (i = 0, n = 0; i < UMB_MAX_DNSSRV; i++) {
		if (mi.ipv4dns[i] == INADDR_ANY)
			break;
		printf("%s %s", n++ ? "" : "\tdns",
		    inet_ntoa(*(struct in_addr *)&mi.ipv4dns[i]));
	}
	if (n)
		printf("\n");
}

void
umb_printclasses(char *tag, int c)
{
	int	 i;
	char	*sep = "";

	printf("\t%s: ", tag);
	i = 0;
	while (umb_dataclass[i].descr) {
		if (umb_dataclass[i].val & c) {
			printf("%s%s", sep, umb_dataclass[i].descr);
			sep = ",";
		}
		i++;
	}
	printf("\n");
}

int
umb_parse_classes(const char *spec)
{
	char	*optlist, *str;
	int	 c = 0, v;

	if ((optlist = strdup(spec)) == NULL)
		err(1, "strdup");
	str = strtok(optlist, ",");
	while (str != NULL) {
		if ((v = umb_descr2val(umb_dataclass, str)) != 0 ||
		    (v = umb_descr2val(umb_classalias, str)) != 0)
			c |= v;
		str = strtok(NULL, ",");
	}
	free(optlist);
	return c;
}

void
umb_setpin(const char *pin, int d)
{
	umb_pinop(MBIM_PIN_OP_ENTER, 0, pin, NULL);
}

void
umb_chgpin(const char *pin, const char *newpin)
{
	umb_pinop(MBIM_PIN_OP_CHANGE, 0, pin, newpin);
}

void
umb_puk(const char *pin, const char *newpin)
{
	umb_pinop(MBIM_PIN_OP_ENTER, 1, pin, newpin);
}

void
umb_pinop(int op, int is_puk, const char *pin, const char *newpin)
{
	struct umb_parameter mp;

	memset(&mp, 0, sizeof (mp));
	ifr.ifr_data = (caddr_t)&mp;
	if (ioctl(s, SIOCGUMBPARAM, (caddr_t)&ifr) == -1)
		err(1, "SIOCGUMBPARAM");

	mp.op = op;
	mp.is_puk = is_puk;
	if ((mp.pinlen = char_to_utf16(pin, (uint16_t *)mp.pin,
	    sizeof (mp.pin))) == -1)
		errx(1, "PIN too long");

	if (newpin) {
		if ((mp.newpinlen = char_to_utf16(newpin, (uint16_t *)mp.newpin,
		    sizeof (mp.newpin))) == -1)
		errx(1, "new PIN too long");
	}

	if (ioctl(s, SIOCSUMBPARAM, (caddr_t)&ifr) == -1)
		err(1, "SIOCSUMBPARAM");
}

void
umb_apn(const char *apn, int d)
{
	struct umb_parameter mp;

	memset(&mp, 0, sizeof (mp));
	ifr.ifr_data = (caddr_t)&mp;
	if (ioctl(s, SIOCGUMBPARAM, (caddr_t)&ifr) == -1)
		err(1, "SIOCGUMBPARAM");

	if (d != 0)
		memset(mp.apn, 0, sizeof (mp.apn));
	else if ((mp.apnlen = char_to_utf16(apn, mp.apn,
	    sizeof (mp.apn))) == -1)
		errx(1, "APN too long");

	if (ioctl(s, SIOCSUMBPARAM, (caddr_t)&ifr) == -1)
		err(1, "SIOCSUMBPARAM");
}

void
umb_setclass(const char *val, int d)
{
	struct umb_parameter mp;

	if (val == NULL) {
		if (showclasses)
			usage();
		showclasses = 1;
		return;
	}

	memset(&mp, 0, sizeof (mp));
	ifr.ifr_data = (caddr_t)&mp;
	if (ioctl(s, SIOCGUMBPARAM, (caddr_t)&ifr) == -1)
		err(1, "SIOCGUMBPARAM");
	if (d != -1)
		mp.preferredclasses = umb_parse_classes(val);
	else
		mp.preferredclasses = MBIM_DATACLASS_NONE;
	if (ioctl(s, SIOCSUMBPARAM, (caddr_t)&ifr) == -1)
		err(1, "SIOCSUMBPARAM");
}

void
umb_roaming(const char *val, int d)
{
	struct umb_parameter mp;

	memset(&mp, 0, sizeof (mp));
	ifr.ifr_data = (caddr_t)&mp;
	if (ioctl(s, SIOCGUMBPARAM, (caddr_t)&ifr) == -1)
		err(1, "SIOCGUMBPARAM");
	mp.roaming = d;
	if (ioctl(s, SIOCSUMBPARAM, (caddr_t)&ifr) == -1)
		err(1, "SIOCSUMBPARAM");
}

void
utf16_to_char(uint16_t *in, int inlen, char *out, size_t outlen)
{
	uint16_t c;

	while (outlen > 0) {
		c = inlen > 0 ? letoh16(*in) : 0;
		if (c == 0 || --outlen == 0) {
			/* always NUL terminate result */
			*out = '\0';
			break;
		}
		*out++ = isascii(c) ? (char)c : '?';
		in++;
		inlen--;
	}
}

int
char_to_utf16(const char *in, uint16_t *out, size_t outlen)
{
	int	 n = 0;
	uint16_t c;

	for (;;) {
		c = *in++;

		if (c == '\0') {
			/*
			 * NUL termination is not required, but zero out the
			 * residual buffer
			 */
			memset(out, 0, outlen);
			return n;
		}
		if (outlen < sizeof (*out))
			return -1;

		*out++ = htole16(c);
		n += sizeof (*out);
		outlen -= sizeof (*out);
	}
}

#endif

#define SIN(x) ((struct sockaddr_in *) &(x))
struct sockaddr_in *sintab[] = {
SIN(ridreq.ifr_addr), SIN(in_addreq.ifra_addr),
SIN(in_addreq.ifra_mask), SIN(in_addreq.ifra_broadaddr)};

void
in_getaddr(const char *s, int which)
{
	struct sockaddr_in *sin = sintab[which], tsin;
	struct hostent *hp;
	struct netent *np;
	int bits, l;
	char p[3];

	bzero(&tsin, sizeof(tsin));
	sin->sin_len = sizeof(*sin);
	if (which != MASK)
		sin->sin_family = AF_INET;

	if (which == ADDR && strrchr(s, '/') != NULL &&
	    (bits = inet_net_pton(AF_INET, s, &tsin.sin_addr,
	    sizeof(tsin.sin_addr))) != -1) {
		l = snprintf(p, sizeof(p), "%d", bits);
		if (l >= sizeof(p) || l == -1)
			errx(1, "%d: bad prefixlen", bits);
		in_getprefix(p, MASK);
		memcpy(&sin->sin_addr, &tsin.sin_addr, sizeof(sin->sin_addr));
	} else if (inet_aton(s, &sin->sin_addr) == 0) {
		if ((hp = gethostbyname(s)))
			memcpy(&sin->sin_addr, hp->h_addr, hp->h_length);
		else if ((np = getnetbyname(s)))
			sin->sin_addr = inet_makeaddr(np->n_net, INADDR_ANY);
		else
			errx(1, "%s: bad value", s);
	}
}

/* ARGSUSED */
void
in_getprefix(const char *plen, int which)
{
	struct sockaddr_in *sin = sintab[which];
	const char *errmsg = NULL;
	u_char *cp;
	int len;

	len = strtonum(plen, 0, 32, &errmsg);
	if (errmsg)
		errx(1, "prefix %s: %s", plen, errmsg);

	sin->sin_len = sizeof(*sin);
	if (which != MASK)
		sin->sin_family = AF_INET;
	if ((len == 0) || (len == 32)) {
		memset(&sin->sin_addr, 0xff, sizeof(struct in_addr));
		return;
	}
	memset((void *)&sin->sin_addr, 0x00, sizeof(sin->sin_addr));
	for (cp = (u_char *)&sin->sin_addr; len > 7; len -= 8)
		*cp++ = 0xff;
	if (len)
		*cp = 0xff << (8 - len);
}

/*
 * Print a value a la the %b format of the kernel's printf
 */
void
printb(char *s, unsigned int v, unsigned char *bits)
{
	int i, any = 0;
	unsigned char c;

	if (bits && *bits == 8)
		printf("%s=%o", s, v);
	else
		printf("%s=%x", s, v);

	if (bits) {
		bits++;
		putchar('<');
		while ((i = *bits++)) {
			if (v & (1 << (i-1))) {
				if (any)
					putchar(',');
				any = 1;
				for (; (c = *bits) > 32; bits++)
					putchar(c);
			} else
				for (; *bits > 32; bits++)
					;
		}
		putchar('>');
	}
}

/*
 * A simple version of printb for status output
 */
void
printb_status(unsigned short v, unsigned char *bits)
{
	int i, any = 0;
	unsigned char c;

	if (bits) {
		bits++;
		while ((i = *bits++)) {
			if (v & (1 << (i-1))) {
				if (any)
					putchar(',');
				any = 1;
				for (; (c = *bits) > 32; bits++)
					putchar(tolower(c));
			} else
				for (; *bits > 32; bits++)
					;
		}
	}
}

#define SIN6(x) ((struct sockaddr_in6 *) &(x))
struct sockaddr_in6 *sin6tab[] = {
SIN6(in6_ridreq.ifr_addr), SIN6(in6_addreq.ifra_addr),
SIN6(in6_addreq.ifra_prefixmask), SIN6(in6_addreq.ifra_dstaddr)};

void
in6_getaddr(const char *s, int which)
{
	struct sockaddr_in6 *sin6 = sin6tab[which];
	struct addrinfo hints, *res;
	char buf[HOST_NAME_MAX+1 + sizeof("/128")], *pfxlen;
	int error;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/

	if (which == ADDR && strchr(s, '/') != NULL) {
		if (strlcpy(buf, s, sizeof(buf)) >= sizeof(buf))
			errx(1, "%s: bad value", s);
		pfxlen = strchr(buf, '/');
		*pfxlen++ = '\0';
		s = buf;
		in6_getprefix(pfxlen, MASK);
		explicit_prefix = 1;
	}

	error = getaddrinfo(s, "0", &hints, &res);
	if (error)
		errx(1, "%s: %s", s, gai_strerror(error));
	if (res->ai_addrlen != sizeof(struct sockaddr_in6))
		errx(1, "%s: bad value", s);
	memcpy(sin6, res->ai_addr, res->ai_addrlen);
#ifdef __KAME__
	if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) &&
	    *(u_int16_t *)&sin6->sin6_addr.s6_addr[2] == 0 &&
	    sin6->sin6_scope_id) {
		*(u_int16_t *)&sin6->sin6_addr.s6_addr[2] =
		    htons(sin6->sin6_scope_id & 0xffff);
		sin6->sin6_scope_id = 0;
	}
#endif /* __KAME__ */
	freeaddrinfo(res);
}

void
in6_getprefix(const char *plen, int which)
{
	struct sockaddr_in6 *sin6 = sin6tab[which];
	const char *errmsg = NULL;
	u_char *cp;
	int len;

	len = strtonum(plen, 0, 128, &errmsg);
	if (errmsg)
		errx(1, "prefix %s: %s", plen, errmsg);

	sin6->sin6_len = sizeof(*sin6);
	if (which != MASK)
		sin6->sin6_family = AF_INET6;
	if ((len == 0) || (len == 128)) {
		memset(&sin6->sin6_addr, 0xff, sizeof(struct in6_addr));
		return;
	}
	memset((void *)&sin6->sin6_addr, 0x00, sizeof(sin6->sin6_addr));
	for (cp = (u_char *)&sin6->sin6_addr; len > 7; len -= 8)
		*cp++ = 0xff;
	if (len)
		*cp = 0xff << (8 - len);
}

int
prefix(void *val, int size)
{
	u_char *nam = (u_char *)val;
	int byte, bit, plen = 0;

	for (byte = 0; byte < size; byte++, plen += 8)
		if (nam[byte] != 0xff)
			break;
	if (byte == size)
		return (plen);
	for (bit = 7; bit != 0; bit--, plen++)
		if (!(nam[byte] & (1 << bit)))
			break;
	for (; bit != 0; bit--)
		if (nam[byte] & (1 << bit))
			return (0);
	byte++;
	for (; byte < size; byte++)
		if (nam[byte])
			return (0);
	return (plen);
}

/* Print usage and exit  */
__dead void
usage(void)
{
	fprintf(stderr,
	    "usage: ifconfig [-AaC] [interface] [address_family] "
	    "[address [dest_address]]\n"
	    "\t\t[parameters]\n");
	exit(1);
}

void
getifgroups(void)
{
	int			 len, cnt;
	struct ifgroupreq	 ifgr;
	struct ifg_req		*ifg;

	memset(&ifgr, 0, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, name, IFNAMSIZ);

	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1) {
		if (errno == EINVAL || errno == ENOTTY)
			return;
		else
			err(1, "SIOCGIFGROUP");
	}

	len = ifgr.ifgr_len;
	ifgr.ifgr_groups = calloc(len / sizeof(struct ifg_req),
	    sizeof(struct ifg_req));
	if (ifgr.ifgr_groups == NULL)
		err(1, "getifgroups");
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
		err(1, "SIOCGIFGROUP");

	cnt = 0;
	ifg = ifgr.ifgr_groups;
	for (; ifg && len >= sizeof(struct ifg_req); ifg++) {
		len -= sizeof(struct ifg_req);
		if (strcmp(ifg->ifgrq_group, "all")) {
			if (cnt == 0)
				printf("\tgroups:");
			cnt++;
			printf(" %s", ifg->ifgrq_group);
		}
	}
	if (cnt)
		printf("\n");

	free(ifgr.ifgr_groups);
}

#ifndef SMALL
void
printifhwfeatures(const char *unused, int show)
{
	struct if_data ifrdat;

	if (!show) {
		if (showcapsflag)
			usage();
		showcapsflag = 1;
		return;
	}
	bzero(&ifrdat, sizeof(ifrdat));
	ifr.ifr_data = (caddr_t)&ifrdat;
	if (ioctl(s, SIOCGIFDATA, (caddr_t)&ifr) == -1)
		err(1, "SIOCGIFDATA");
	printb("\thwfeatures", (u_int)ifrdat.ifi_capabilities, HWFEATURESBITS);

	if (ioctl(s, SIOCGIFHARDMTU, (caddr_t)&ifr) != -1) {
		if (ifr.ifr_hardmtu)
			printf(" hardmtu %u", ifr.ifr_hardmtu);
	}
	putchar('\n');
}
#endif

char *
sec2str(time_t total)
{
	static char result[256];
	char *p = result;
	char *end = &result[sizeof(result)];

	snprintf(p, end - p, "%lld", (long long)total);
	return (result);
}

/*ARGSUSED*/
void
setiflladdr(const char *addr, int param)
{
	struct ether_addr *eap, eabuf;

	if (!strcmp(addr, "random")) {
		arc4random_buf(&eabuf, sizeof eabuf);
		/* Non-multicast and claim it is a hardware address */
		eabuf.ether_addr_octet[0] &= 0xfc;
		eap = &eabuf;
	} else {
		eap = ether_aton(addr);
		if (eap == NULL) {
			warnx("malformed link-level address");
			return;
		}
	}
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_addr.sa_len = ETHER_ADDR_LEN;
	ifr.ifr_addr.sa_family = AF_LINK;
	bcopy(eap, ifr.ifr_addr.sa_data, ETHER_ADDR_LEN);
	if (ioctl(s, SIOCSIFLLADDR, (caddr_t)&ifr) < 0)
		warn("SIOCSIFLLADDR");
}

#ifndef SMALL
void
setrdomain(const char *id, int param)
{
	const char *errmsg = NULL;
	int rdomainid;

	rdomainid = strtonum(id, 0, RT_TABLEID_MAX, &errmsg);
	if (errmsg)
		errx(1, "rdomain %s: %s", id, errmsg);

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_rdomainid = rdomainid;
	if (ioctl(s, SIOCSIFRDOMAIN, (caddr_t)&ifr) < 0)
		warn("SIOCSIFRDOMAIN");
}
#endif

#ifndef SMALL
void
setpair(const char *val, int d)
{
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if ((ifr.ifr_index = if_nametoindex(val)) == 0) {
		errno = ENOENT;
		err(1, "patch %s", val);
	}
	if (ioctl(s, SIOCSIFPAIR, (caddr_t)&ifr) < 0)
		warn("SIOCSIFPAIR");
}

void
unsetpair(const char *val, int d)
{
	ifr.ifr_index = 0;
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCSIFPAIR, (caddr_t)&ifr) < 0)
		warn("SIOCSIFPAIR");
}
#endif

#ifdef SMALL
void
setignore(const char *id, int param)
{
	/* just digest the command */
}
#endif
@


1.339
log
@Make ifconfig scan display both wpa1 and wpa2 if both are supported.
ok henning@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.338 2017/03/11 13:22:36 stsp Exp $	*/
d1640 1
a1640 1
		nwkey.i_wepon = 0;
d2123 1
a2123 1
	if (inwkey == 0 && nwkey.i_wepon > 0) {
@


1.338
log
@Make 'ifconfig scan' display AP encryption correctly if WEP is configured
on the local wifi interface. ifconfig was mistakenly showing the common
supported subset of client and AP, rather than showing the AP's capabilities.
Exposes WPA protocol capabilities in struct ieee80211_nodereq, which means
ifconfig must be recompiled to run on a new kernel.
ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.337 2017/01/21 08:31:44 krw Exp $	*/
d2378 6
a2383 5
			if (nr->nr_rsnprotos & IEEE80211_WPA_PROTO_WPA2)
				fputs(",wpa2", stdout);
			else if (nr->nr_rsnprotos & IEEE80211_WPA_PROTO_WPA1)
				fputs(",wpa1", stdout);
			else
@


1.337
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.336 2016/12/25 20:30:41 krw Exp $	*/
d2378 1
a2378 1
			if (nr->nr_rsnciphers & IEEE80211_WPA_CIPHER_CCMP)
d2380 1
a2380 1
			else if (nr->nr_rsnciphers & IEEE80211_WPA_CIPHER_TKIP)
@


1.336
log
@gcc says "if you define labels and don't use them, I will whine."

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.335 2016/12/20 13:26:24 stsp Exp $	*/
d1894 1
a1894 1
			/* Parse a WPA passphrase */ 
d3097 1
a3097 1
					/* 
d4447 1
a4447 1
		    buf : "INVALID");	
d4457 1
a4457 1
		    "INVALID");	
@


1.335
log
@Make 'ifconfig if0 wpa' and 'ifconfig if0 -wpa' reset WPA params (does not
include the wpakey) to their defaults.
And make 'ifconfig if0 wpaprotos' reset WPA crypto parameters to settings
which are appropriate for the specified WPA protocol version.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.334 2016/12/13 01:36:21 dlg Exp $	*/
a5317 1
done:
@


1.334
log
@make setting and getting tunnel addresses wrt to ipv6 scope handling.

setting a tunnel addresses uses a sockaddr_in6 from getaddrinfo, which
sets sin6_scope_id for scoped addresses. this is nice and portable.

reading a tunnel address assumed the scope was embedded in link local
addresses in sin6_addr, and unpacked the scope back into sin6_scope_id.
this is inconsistent with the code that sets tunnel addresses.

this fixes the read path so it assumes the kernel sets sin6_scope_id
like it it assumes the kernel will read on the set side. noone likes
the kame hack of embedding the scope id in the addreses.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.333 2016/11/10 14:36:03 gerhard Exp $	*/
d1726 1
a1726 2
	if (ioctl(s, SIOCG80211WPAPARMS, (caddr_t)&wpa) < 0)
		err(1, "SIOCG80211WPAPARMS");
d1759 3
@


1.333
log
@The simple UTF-16 decode routine stopped too early due to wrong calculation
of the output buffer size. Thus elements like subscriber-id, ICC-id, IMEI
were shown truncated.

Some modules report a phone number that already has the '+' prefix.
Don't add another one when printing it.

Patch from Bryan Vyhmeister
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.332 2016/11/08 14:37:20 mestre Exp $	*/
a2875 2
	if (req.addr.ss_family == AF_INET6)
		in6_fillscopeid((struct sockaddr_in6 *)&req.addr);
d2884 1
a2884 2
	else if (req.dstaddr.ss_family == AF_INET6) {
		in6_fillscopeid((struct sockaddr_in6 *)&req.dstaddr);
a2885 1
	}
@


1.332
log
@- Declare usage() as __dead void (remaining prototypes are not declared as
static, so keep it that way for consistency)
- s/usage(1)/usage() and inside call exit(1) explicitly since all usage() calls
always use that value (also update comment to reflect this change)
- Remove main() prototype
- s/exit/return in main() to enable SSP

Feedback from jca@@ and tb@@ and OK from both (with their remarks in)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.331 2016/10/17 10:49:17 rzalamena Exp $	*/
d5156 1
a5156 1
			printf("%sphone# +%s", n++ ? " " : "", pn);
d5326 1
a5326 1
		inlen -= sizeof (*in);
@


1.331
log
@Use strtoull() to read the datapath id and expect "datapath" instead of
"datapathid" as stated by the man page.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.330 2016/09/03 13:46:57 reyk Exp $	*/
a222 1
int	main(int, char *[]);
d568 1
a568 1
void	usage(int);
d641 1
a641 1
		exit(0);
d666 1
a666 1
				usage(1);
d673 1
a673 1
				usage(1);
d693 1
a693 1
			usage(1);
d695 1
a695 1
		exit(0);
d702 1
a702 1
		exit(0);
d718 1
a718 1
			exit(0);
d792 1
a792 1
		exit(0);
d827 1
a827 1
	exit(0);
d974 1
a974 1
		usage(1);
d1929 1
a1929 1
			usage(1);
d1954 1
a1954 1
		usage(1);
d2456 1
a2456 1
			usage(1);
d5280 1
a5280 1
			usage(1);
d5574 3
a5576 3
/* Print usage, exit(value) if value is non-zero. */
void
usage(int value)
d5582 1
a5582 1
	exit(value);
d5635 1
a5635 1
			usage(1);
@


1.330
log
@Add support for a multipoint-to-multipoint mode in vxlan(4).  In this
mode, vxlan(4) must be configured to accept any virtual network
identifier with "vnetid any" and added to a bridge(4) or switch(4).
This way the driver will dynamically learn the tunnel endpoints and
their vnetids for the responses and can be used to dynamically bridge
between VXLANs.  It is also being used in combination with switch(4)
and the OpenFlow tunnel classifiers.

With input from yasuoka@@ goda@@
OK deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.329 2016/09/02 10:01:36 goda Exp $	*/
d520 1
a520 1
	{ "datapathid",	NEXTARG,	0,		switch_datapathid },
@


1.329
log
@Add switch(4) support to ifconfig

ok deraadt@@ yasuoka@@ reyk@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.328 2016/08/31 13:32:27 stsp Exp $	*/
d102 1
d3626 1
a3626 1
	uint32_t vnetid;
d3628 9
a3636 3
	vnetid = strtonum(id, 0, UINT_MAX, &errmsg);
	if (errmsg)
		errx(1, "vnetid %s: %s", id, errmsg);
a3637 1
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d3667 6
a3672 1
	printf("\tvnetid: %u\n", ifr.ifr_vnetid);
@


1.328
log
@Rename ifconfig's setinstance() function to setrdomain(). Less confusing.
ok claudio@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.327 2016/08/19 09:06:24 jsg Exp $	*/
d519 3
d3136 1
@


1.327
log
@correct a rate test introduced in rev 1.326
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.326 2016/08/15 22:16:46 stsp Exp $	*/
d221 1
a221 1
void	setinstance(const char *, int);
d395 1
a395 1
	{ "rdomain",	NEXTARG,	0,		setinstance },
d5678 1
a5678 1
setinstance(const char *id, int param)
@


1.326
log
@When running 'ifconfig scan' in hostap mode display the current Tx rate our
AP is using to send frames to an associated node. This used to always display
the node's highest supported Rx rate, which isn't all that interesting.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.325 2016/08/03 20:45:36 vgross Exp $	*/
d2351 1
a2351 1
		} else if (nr->nr_rates) {
@


1.325
log
@Fix typo, spotted by Holger Mikolon <holger@@mikolon.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.324 2016/06/15 19:39:33 gerhard Exp $	*/
d2344 13
a2356 2
	/* Only print the fastest rate */
	if (nr->nr_max_rxrate) {
d2365 1
a2365 1
		printf("%uM",
a2366 1
		putchar(' ');
@


1.324
log
@Add umb(4) - a driver for the Mobile Broadband Interface Model (MBIM)

The umb(4) driver provides support for USB MBIM devices.
Those devices establish connections via celluar networks such as
GPRS, UMTS, and LTE.

ok mpi@@ sthen@@
additional feedback from deraadt@@ jmc@@ stsp@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.323 2016/06/10 20:33:29 vgross Exp $	*/
d1454 1
a1454 1
	ifr.ifr_mtu = strtonum(val, 0, UCHAR_MAX, &errmsg);
d1456 1
a1456 1
		errx(1, "mtu %s: %s", val, errmsg);
@


1.323
log
@Add the "llprio" field to struct ifnet, and the corresponding keyword
to ifconfig.

"llprio" allows one to set the priority of packets that do not go through
pf(4), as the case is for arp(4) or bpf(4).

ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.322 2016/05/03 17:52:33 jca Exp $	*/
d110 4
d153 1
d285 12
d508 9
d3001 1
d4935 397
@


1.322
log
@Remove INET6 #ifdefs

ifconfig.c doesn't build without -DINET6, and those #ifdefs clutter the
code.  ok bluhm@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.321 2016/04/28 13:51:22 stsp Exp $	*/
d138 1
d161 1
d526 1
d860 5
d1422 15
d2911 2
d2932 1
d2941 4
a2944 2
	if (sdl != NULL)
		printf("\tindex %u", sdl->sdl_index);
d2946 2
a2947 4
		printf("%cpriority %d\n", (sdl != NULL) ? ' ' : '\t',
		    ifrdesc.ifr_metric);
	} else if (sdl != NULL) {
		putchar('\n');
d2949 4
@


1.321
log
@Show 11n HT rate in ifconfig scan output. Needs a new kernel.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.320 2016/04/18 06:20:23 mpi Exp $	*/
a120 1
#ifdef INET6
a123 1
#endif /* INET6 */
a141 1
#ifdef INET6
a142 1
#endif /* INET6 */
a184 1
#ifdef INET6
a191 1
#endif /* INET6 */
a358 1
#ifdef INET6
a367 1
#endif /*INET6*/
a556 1
#ifdef INET6
a561 1
#endif /* INET6 */
a585 1
#ifdef INET6
a587 1
#endif /* INET6 */
a673 1
#ifdef INET6
d677 1
a677 1
#endif /* INET6 */
d692 1
a692 1
#ifdef INET6
d695 1
a695 1
#endif
a984 1
#ifdef INET6
d991 1
a991 3
		} else
#endif
		{
a1283 1
#ifdef INET6
d1342 1
a1342 1
#ifdef INET6
d1344 1
a1344 1
#endif
a1366 1
#endif /* INET6 */
a1371 1
#ifdef INET6
a1374 1
#endif
a2813 1
#ifdef INET6
a2815 1
#endif /* INET6 */
a2818 1
#ifdef INET6
a2820 1
#endif /* INET6 */
a2823 1
#ifdef INET6
a2827 1
#endif /* INET6 */
a3138 1
#ifdef INET6
a3273 1
#endif /*INET6*/
a5000 1
#ifdef INET6
a5094 1
#endif /*INET6*/
a5174 1
#ifdef INET6
a5184 1
#endif /* INET6 */
@


1.320
log
@Print interface index after priority.

Suggestion from claudio@@, ok benno@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.319 2016/04/06 11:48:51 dlg Exp $	*/
d66 1
d2287 1
a2287 1
	int len;
d2315 10
a2324 2
	if (nr->nr_nrates) {
		/* Only print the fastest rate */
@


1.319
log
@move the parent and vnetid stuff around so it builds on ramdisks too.

ramdisk breakage found by jsg@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.318 2016/04/06 01:39:17 dlg Exp $	*/
d2932 8
a2939 2
	if (!is_bridge(name) && ioctl(s, SIOCGIFPRIORITY, &ifrdesc) == 0)
		printf("\tpriority: %d\n", ifrdesc.ifr_metric);
@


1.318
log
@move getting the vnetid out next to getting the ifparent

its now separate to getting the tunnel address.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.317 2016/03/02 19:45:10 deraadt Exp $	*/
a3377 91
setvnetid(const char *id, int param)
{
	const char *errmsg = NULL;
	uint32_t vnetid;

	vnetid = strtonum(id, 0, UINT_MAX, &errmsg);
	if (errmsg)
		errx(1, "vnetid %s: %s", id, errmsg);

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	ifr.ifr_vnetid = vnetid;
	if (ioctl(s, SIOCSVNETID, (caddr_t)&ifr) < 0)
		warn("SIOCSVNETID");
}

/* ARGSUSED */
void
delvnetid(const char *ignored, int alsoignored)
{
	if (ioctl(s, SIOCDVNETID, &ifr) < 0)
		warn("SIOCDVNETID");
}

void
getvnetid(void)
{
	if (strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name)) >=
	    sizeof(ifr.ifr_name))
		errx(1, "vnetid: name is too long");

	if (ioctl(s, SIOCGVNETID, &ifr) == -1) {
		if (errno != EADDRNOTAVAIL)
			return;

		printf("\tvnetid: none\n");

		return;
	}

	printf("\tvnetid: %u\n", ifr.ifr_vnetid);
}

void
setifparent(const char *id, int param)
{
	struct if_parent ifp;

	if (strlcpy(ifp.ifp_name, name, sizeof(ifp.ifp_name)) >=
	    sizeof(ifp.ifp_name))
		errx(1, "parent: name too long");

	if (strlcpy(ifp.ifp_parent, id, sizeof(ifp.ifp_parent)) >=
	    sizeof(ifp.ifp_parent))
		errx(1, "parent: parent too long");

	if (ioctl(s, SIOCSIFPARENT, (caddr_t)&ifp) < 0)
		warn("SIOCSIFPARENT");
}

/* ARGSUSED */
void
delifparent(const char *ignored, int alsoignored)
{
	if (ioctl(s, SIOCDIFPARENT, &ifr) < 0)
		warn("SIOCDIFPARENT");
}
#endif /* !SMALL */

void
getifparent(void)
{
	struct if_parent ifp;
	const char *parent = "none";

	memset(&ifp, 0, sizeof(ifp));
	if (strlcpy(ifp.ifp_name, name, sizeof(ifp.ifp_name)) >=
	    sizeof(ifp.ifp_name))
		errx(1, "parent: name too long");

	if (ioctl(s, SIOCGIFPARENT, (caddr_t)&ifp) == -1) {
		if (errno != EADDRNOTAVAIL)
			return;
	} else
		parent = ifp.ifp_parent;

	printf("\tparent: %s\n", parent);
}

#ifndef SMALL

void
d3562 88
@


1.317
log
@repair for ramdisk builds
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.316 2016/03/02 00:00:16 dlg Exp $	*/
d184 1
a2853 2
	if (ioctl(s, SIOCGVNETID, (caddr_t)&ifr) == 0)
		printf(" vnetid %d", ifr.ifr_vnetid);
d2945 1
d3399 19
@


1.316
log
@provide generic ioctls for managing an interfaces parent

in the future this will subsume the individual vlandev, carpdev,
pppoedev, foodev options for things like vlan, carp, pppoe, etc.

inspired by vnetid

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.315 2016/01/13 09:35:45 stsp Exp $	*/
d3425 1
d3446 2
@


1.315
log
@Make 'ifconfig $if mode' a valid subcommand that works independently of
the 'media' subcommand. Allow clearing the mode with 'ifconfig $if -mode'.

This makes commands such as 'ifconfig iwn0 mode 11a' work without having
to type all of 'ifconfig iwn0 media autoselect mode 11a'.

ok sthen@@ deraadt@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.314 2016/01/06 21:37:00 tedu Exp $	*/
d184 3
d418 2
d2946 1
d3399 45
@


1.314
log
@correct format string. ok deraadt stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.313 2016/01/03 10:33:27 mpi Exp $	*/
d196 1
d521 1
d2372 1
a2372 1
	if ((actions & (A_MEDIA|A_MEDIAOPT)) == 0) {
d2455 21
@


1.313
log
@Remove obsolete and undocumented "-carpdev" option, from Fabian Raetz.

ok benno@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.312 2016/01/01 12:50:54 jung Exp $	*/
d2776 1
a2776 1
		printf(" instance %d", IFM_INST(ifmw));
@


1.312
log
@rmeove unused noprint variable

from Fabian Raetz via tech@@

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.311 2015/12/10 17:26:59 mmcc Exp $	*/
a238 1
void	unsetcarpdev(const char *, int);
a396 1
	{ "-carpdev",	1,		0,		unsetcarpdev },
a4007 17

	if (ioctl(s, SIOCSVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCSVH");
}

void
unsetcarpdev(const char *val, int d)
{
	struct carpreq carpr;

	bzero(&carpr, sizeof(struct carpreq));
	ifr.ifr_data = (caddr_t)&carpr;

	if (ioctl(s, SIOCGVH, (caddr_t)&ifr) == -1)
		err(1, "SIOCGVH");

	bzero(&carpr.carpr_carpdev, sizeof(carpr.carpr_carpdev));
@


1.311
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.310 2015/12/09 16:02:44 mpi Exp $	*/
a608 1
	int noprint = 0;
d764 1
a764 1
	if (argc == 0 && actions == 0 && !noprint) {
@


1.310
log
@Revert SIOCDIFADDR_IN6 fix.

It's not possible to fix this issue in ifconfig(8) because in_control()
and in6_control() have a subtle semantic difference which result in
breaking alias for IPv4.

in_control() always select the first address on the list of an interface
whereas in6_control() doesn't.  That's why ifconfig(8) passes an empty
"struct in_aliasreq" and that fails in netinet6.

Breakage reported by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.309 2015/12/06 12:52:18 tedu Exp $	*/
d1045 1
a1045 2
	if (oname != NULL)
		free(oname);
@


1.309
log
@remove trailers option that was already obsolete when this code was imported.
ok benno krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.308 2015/12/06 12:50:05 tedu Exp $	*/
d785 1
d1134 1
a1134 1
	if (doalias >= 0) {
d1136 1
a1136 3
		afp->af_getaddr(addr, ADDR);
	}
	if (doalias == 0) {
d1138 1
a1138 2
		afp->af_getaddr(addr, RIDADDR);
	}
d4840 1
a4840 1
	if (which != MASK && strrchr(s, '/') != NULL &&
d4960 1
a4960 1
	if (which != MASK && strchr(s, '/') != NULL) {
@


1.308
log
@remove txpower option. only relevant to the now irrelevant wi driver.
(several other drivers misleadingly claim generic 802.11 txpower, but
do not in fact do anything. the knob is not connected to the radio.)
ok benno jsg krw reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.307 2015/11/25 10:52:25 mpi Exp $	*/
a265 1
void	notrailers(const char *, int);
a372 2
	{ "trailers",	-1,		0,		notrailers },
	{ "-trailers",	1,		0,		notrailers },
a1214 9

#ifndef SMALL
/*ARGSUSED*/
void
notrailers(const char *vname, int value)
{
	printf("Note: trailers are no longer sent, but always received\n");
}
#endif
@


1.307
log
@Put back 1.305 without breaking the hand rolled inet_net_pton(3) case
for IPv4.

Tested by sebastia@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.306 2015/11/23 17:53:52 mpi Exp $	*/
a173 1
void	setiftxpower(const char *, int);
a424 2
	{ "txpower",	NEXTARG,	0,		setiftxpower },
	{ "-txpower",	1,		0,		setiftxpower },
a500 1
	{ "txpower",	NEXTARG,	0,		setignore },
a1935 22
void
setiftxpower(const char *val, int d)
{
	const char *errmsg = NULL;
	struct ieee80211_txpower txpower;
	int dbm;

	strlcpy(txpower.i_name, name, sizeof(txpower.i_name));

	if (d == 1) {
		txpower.i_mode = IEEE80211_TXPOWER_MODE_AUTO;
	} else {
		dbm = strtonum(val, SHRT_MIN, SHRT_MAX, &errmsg);
		if (errmsg)
			errx(1, "txpower %sdBm: %s", val, errmsg);
		txpower.i_val = (int16_t)dbm;
		txpower.i_mode = IEEE80211_TXPOWER_MODE_FIXED;
	}

	if (ioctl(s, SIOCS80211TXPOWER, (caddr_t)&txpower) == -1)
		warn("SIOCS80211TXPOWER");
}
d2017 1
a2017 1
	int ibssid, itxpower, iwpa;
a2023 1
	struct ieee80211_txpower txpower;
a2055 4
	memset(&txpower, 0, sizeof(txpower));
	strlcpy(txpower.i_name, name, sizeof(txpower.i_name));
	itxpower = ioctl(s, SIOCG80211TXPOWER, &txpower);

d2062 1
a2062 1
	    ichan == 0 || ibssid == 0 || iwpa == 0 || itxpower == 0)
a2189 5

	if (itxpower == 0)
		printf(" %ddBm%s", txpower.i_val,
		    txpower.i_mode == IEEE80211_TXPOWER_MODE_AUTO ?
		    " (auto)" : "");
@


1.306
log
@Revert previous it introduces a regression found by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.305 2015/11/23 10:33:23 mpi Exp $	*/
a791 1
		/* in6_getprefix("64", MASK) if MASK is available here... */
d1140 1
a1140 1
	if (doalias >= 0)
d1142 3
a1144 1
	if (doalias == 0)
d1146 2
a1147 1
	afp->af_getaddr(addr, (doalias >= 0 ? ADDR : RIDADDR));
d4890 1
a4890 1
	if (which == ADDR && strrchr(s, '/') != NULL &&
d5010 1
a5010 1
	if (which == ADDR && strchr(s, '/') != NULL) {
@


1.305
log
@Initialize SIOCDIFADDR{_IN6,} argument as intended.

How this could have been unotified for so long?  Thanks to sebastia@@
for reporting a breakage when re-configuring an IPv6 static address.

ok sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.304 2015/10/24 10:52:05 reyk Exp $	*/
d792 1
d1141 1
a1141 1
	if (doalias >= 0) {
d1143 1
a1143 3
		afp->af_getaddr(addr, ADDR);
	}
	if (doalias == 0) {
d1145 1
a1145 2
		afp->af_getaddr(addr, RIDADDR);
	}
@


1.304
log
@Add pair(4), a vether-based virtual Ethernet driver to interconnect
rdomains and bridges on the local system.  This can be used to route
through local rdomains, to create L2 devices (like trunks) between
them, and many other things.

Discussed with many, with input from mpi@@
OK sthen@@ phessler@@ yasuoka@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.303 2015/10/23 01:19:04 dlg Exp $	*/
a791 1
		/* in6_getprefix("64", MASK) if MASK is available here... */
d1140 1
a1140 1
	if (doalias >= 0)
d1142 3
a1144 1
	if (doalias == 0)
d1146 2
a1147 1
	afp->af_getaddr(addr, (doalias >= 0 ? ADDR : RIDADDR));
@


1.303
log
@tweak the vnetid so it can be optional and therefore cleared/deleted.

the abstract vnetid is promoted to a uin32_t, and adds a SIOCDVNETID
ioctl so it can be cleared.

this is all because i set an assignment on implementing a virtual
network interface and the students got confused when vnetid 0 didnt
show up in ifconfig output.

the vnetid in the vxlan(4) protocol is optional, but the current
code confuses 0 with no vnetid being set. this makes it clear.

ok reyk@@ who also simplified my diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.302 2015/10/03 10:44:23 florian Exp $	*/
d279 2
d497 2
d2926 1
d2965 3
d5220 23
@


1.302
log
@IPv6 transport for pflow data.
Input deraadt@@
Bug fix & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.301 2015/09/11 15:59:40 stsp Exp $	*/
d184 1
d417 1
d2873 1
a2873 1
	if (ioctl(s, SIOCGVNETID, (caddr_t)&ifr) == 0 && ifr.ifr_vnetid > 0)
d3396 1
a3396 1
	int vnetid;
d3406 8
@


1.301
log
@In `ifconfig media` output, stop advertising media with fixed data
rates on wireless interfaces. They are not needed by mere mortals.
ok phessler miod kettenis deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.300 2015/09/11 13:02:59 stsp Exp $	*/
d268 1
d4284 5
a4288 1
	struct pflowreq preq;
d4296 9
d4306 53
a4358 8
	if (preq.sender_ip.s_addr != INADDR_ANY)
		printf("sender: %s ", inet_ntoa(preq.sender_ip));
	printf("receiver: %s:", preq.receiver_ip.s_addr != INADDR_ANY ?
	    inet_ntoa(preq.receiver_ip) : "INVALID");
	if (preq.receiver_port == 0)
		printf("%s ", "INVALID");
	else
		printf("%u ", ntohs(preq.receiver_port));
a4361 1
/* ARGSUSED */
d4363 37
a4399 5
setpflow_sender(const char *val, int d)
{
	struct pflowreq preq;
	struct addrinfo hints, *sender;
	int ecode;
d4402 1
a4402 1
	hints.ai_family = AF_INET;
d4405 1
a4405 1
	if ((ecode = getaddrinfo(val, NULL, &hints, &sender)) != 0)
d4407 5
a4411 1
		    gai_strerror(ecode));
d4413 4
a4416 2
	if (sender->ai_addr->sa_family != AF_INET)
		errx(1, "only IPv4 addresses supported for the sender");
d4421 1
a4421 2
	preq.sender_ip.s_addr = ((struct sockaddr_in *)
	    sender->ai_addr)->sin_addr.s_addr;
a4424 2

	freeaddrinfo(sender);
a4438 1
/* ARGSUSED */
a4442 23
	struct addrinfo hints, *receiver;
	int ecode;
	char *ip, *port, buf[HOST_NAME_MAX+1 + sizeof (":65535")];

	if (strchr (val, ':') == NULL)
		errx(1, "%s bad value", val);

	if (strlcpy(buf, val, sizeof(buf)) >= sizeof(buf))
		errx(1, "%s bad value", val);
	port = strchr(buf, ':');
	*port++ = '\0';
	ip = buf;

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/

	if ((ecode = getaddrinfo(ip, port, &hints, &receiver)) != 0)
		errx(1, "error in parsing address string: %s",
		    gai_strerror(ecode));

	if (receiver->ai_addr->sa_family != AF_INET)
		errx(1, "only IPv4 addresses supported for the receiver");
d4446 2
a4447 5
	preq.addrmask |= PFLOW_MASK_DSTIP | PFLOW_MASK_DSTPRT;
	preq.receiver_ip.s_addr = ((struct sockaddr_in *)
	    receiver->ai_addr)->sin_addr.s_addr;
	preq.receiver_port = (u_int16_t) ((struct sockaddr_in *)
	    receiver->ai_addr)->sin_port;
a4450 2

	freeaddrinfo(receiver);
d4460 1
a4460 1
	preq.addrmask |= PFLOW_MASK_DSTIP | PFLOW_MASK_DSTPRT;
@


1.300
log
@Fix ifconfig for ifmedia64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.299 2015/07/26 22:37:40 chl Exp $	*/
d3051 11
@


1.299
log
@remove unused variable

ok mpi@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.298 2015/07/22 06:20:06 deraadt Exp $	*/
d288 3
a290 3
int	media_current;
int	mediaopt_set;
int	mediaopt_clear;
d542 6
a547 6
const char *get_media_type_string(int);
const char *get_media_subtype_string(int);
int	get_media_mode(int, const char *);
int	get_media_subtype(int, const char *);
int	get_media_options(int, const char *);
int	lookup_media_word(const struct ifmedia_description *, int,
d549 1
a549 1
void	print_media_word(int, int, int);
d2438 1
a2438 1
	int type, subtype, inst;
d2482 1
a2482 1
	int type, subtype, options, inst, mode;
d2549 1
a2549 1
	int type, subtype, options, inst;
d2693 1
a2693 1
get_media_type_string(int mword)
d2706 1
a2706 1
get_media_subtype_string(int mword)
d2719 2
a2720 2
int
get_media_subtype(int type, const char *val)
d2722 1
a2722 1
	int rval;
d2732 2
a2733 2
int
get_media_mode(int type, const char *val)
d2735 1
a2735 1
	int rval;
d2744 2
a2745 2
int
get_media_options(int type, const char *val)
d2748 1
a2748 1
	int option, rval = 0;
d2771 2
a2772 2
int
lookup_media_word(const struct ifmedia_description *desc, int type,
d2785 1
a2785 1
print_media_word(int ifmw, int print_type, int as_syntax)
d2788 1
a2788 1
	int seen_option = 0;
d2883 1
a2883 1
const int ifm_status_valid_list[] = IFM_STATUS_VALID_LIST;
d2920 2
a2921 1
	int *media_list, i;
d2990 1
a2990 1
	media_list = calloc(ifmr.ifm_count, sizeof(int));
d3045 2
a3046 1
		int type, printed_type = 0;
@


1.298
log
@process_mpw_commands should not go to install-media ifconfig
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.297 2015/07/21 17:50:23 rzalamena Exp $	*/
a3535 1
	struct	shim_hdr shim;
@


1.297
log
@Teach ifconfig(8) about mpw(4) commands.

ok claudio@@, renato@@, mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.296 2015/02/05 10:30:25 henning Exp $	*/
d773 1
d776 1
@


1.296
log
@implement "ifconfig <if> -inet", removing all inet addresses
for symmetry with -inet6 mostly. ok phessler theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.294 2015/01/09 20:34:21 sthen Exp $	*/
d129 4
d203 5
d212 1
d383 5
d773 3
d2963 1
d3403 50
d3468 106
@


1.295
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d423 1
d485 1
@


1.294
log
@Change rssi passed to ifconfig(8) to a signed value to fix printing signal
strengths on 802.11 interfaces.  ok stsp@@

Power on wireless interfaces is usually scaled in dBm. rssi (received signal
strength) is expected to be a -ve dBm values (i.e. [much] <1mW). Some (though
not all!) drivers store this as negative values, so it needs to be passed to
ifconfig that way for printing, not cast to an unsigned value. Valid range is
something like -40 to -90dBm, so the range available with a signed char is
reasonable whether it's stored as a +ve or -ve number.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.293 2015/01/06 21:26:46 stsp Exp $	*/
d104 1
d110 3
d975 1
a975 1
			    MIN(sizeof(ifr6.ifr_addr), ifa->ifa_addr->sa_len));
d982 1
a982 1
			    MIN(sizeof(ifr.ifr_addr), ifa->ifa_addr->sa_len));
d3268 1
a3268 1
	char buf[MAXHOSTNAMELEN+sizeof (":65535")], *dstport;
d4162 1
a4162 1
	char *ip, *port, buf[MAXHOSTNAMELEN+sizeof (":65535")];
d4728 1
a4728 1
	char buf[MAXHOSTNAMELEN+sizeof("/128")], *pfxlen;
@


1.293
log
@Remove the NOINET6 interface flag, a left-over from the times when IPv6
was enabled by default. Add AFATTACH/AFDETACH ioctls which enable/disable
an address family for an interface (currently used for IPv6 only).

New kernel needs new ifconfig for IPv6 configuration (address assignment
still works with old ifconfig making this easy to cross over).

Committing on behalf of henning@@ who is currently lebensmittelvergiftet.
ok stsp, benno, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.292 2015/01/04 12:30:39 mpi Exp $	*/
d2090 1
a2090 1
				printf(" %udB", nr.nr_rssi);
d2321 1
a2321 1
		printf("%udB ", nr->nr_rssi);
@


1.292
log
@Sort wireless nodes by signal strength, from Simon Nicolussi.

ok stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.291 2015/01/03 06:09:36 jsg Exp $	*/
d151 1
d680 1
a680 1
		setifxflags("inet6", -IFXF_NOINET6);
d1257 11
d1270 6
a1275 10
	switch (value) {
#ifdef INET6
	case AF_INET6:
		setifxflags(vname, IFXF_NOINET6);
		setifxflags(vname, -IFXF_AUTOCONF6);
		break;
#endif
	default:
		errx(1, "removeaf not implemented for this AF");
	}
d1337 3
a1339 1
	setifxflags("inet6", -IFXF_NOINET6);
@


1.291
log
@move the list_cloners() prototype out of #ifndef SMALL
missed in rev 1.290
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.290 2015/01/01 22:53:39 krw Exp $	*/
d2224 11
d2270 2
@


1.290
log
@Enable 'ifconfig -C' (list dynamic interface types) on install
media. Use this feature in install scripts to eliminate manually
maintained list of dynamic interface types.

'-C' brought to my attention by reyk@@, tweaks to install script to
use -C in get_ifdevs() from rpe@@.

ok rpe@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.289 2014/11/14 15:09:29 tedu Exp $	*/
d212 1
a257 1
void	list_cloners(void);
@


1.289
log
@sort names for -C. ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.288 2014/11/14 15:03:11 henning Exp $	*/
a583 1
#ifndef SMALL
a584 1
#endif
a612 1
#ifndef SMALL
a616 1
#endif
a642 1
#ifndef SMALL
a648 1
#endif
a1048 1
#ifndef SMALL
a1090 1
#endif
@


1.288
log
@move the trunk related functions out of ifdef SMALL, to allow trunk on
RAMDISKs. grows ifconfig on SMALL media slightly, verified to still fit on
amd64 i386 sparc64 alpha hppa macppc by me. ok krw reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.287 2014/07/12 19:58:17 henning Exp $	*/
d1085 3
@


1.287
log
@ewps, that giant table has -inet6 twice, for SMALL and !SMALL
no breakage involved, but wasn't correct in the SMALL case either
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.284 2014/06/23 18:44:43 henning Exp $	*/
d208 4
a246 4
void	settrunkport(const char *, int);
void	unsettrunkport(const char *, int);
void	settrunkproto(const char *, int);
void	trunk_status(void);
d340 3
a402 3
	{ "trunkport",	NEXTARG,	0,		settrunkport },
	{ "-trunkport",	NEXTARG,	0,		unsettrunkport },
	{ "trunkproto",	NEXTARG,	0,		settrunkproto },
a2919 1
	trunk_status();
d2923 1
d3472 118
a4522 118
}

void
settrunkport(const char *val, int d)
{
	struct trunk_reqport rp;

	bzero(&rp, sizeof(rp));
	strlcpy(rp.rp_ifname, name, sizeof(rp.rp_ifname));
	strlcpy(rp.rp_portname, val, sizeof(rp.rp_portname));

	if (ioctl(s, SIOCSTRUNKPORT, &rp))
		err(1, "SIOCSTRUNKPORT");
}

void
unsettrunkport(const char *val, int d)
{
	struct trunk_reqport rp;

	bzero(&rp, sizeof(rp));
	strlcpy(rp.rp_ifname, name, sizeof(rp.rp_ifname));
	strlcpy(rp.rp_portname, val, sizeof(rp.rp_portname));

	if (ioctl(s, SIOCSTRUNKDELPORT, &rp))
		err(1, "SIOCSTRUNKDELPORT");
}

void
settrunkproto(const char *val, int d)
{
	struct trunk_protos tpr[] = TRUNK_PROTOS;
	struct trunk_reqall ra;
	int i;

	bzero(&ra, sizeof(ra));
	ra.ra_proto = TRUNK_PROTO_MAX;

	for (i = 0; i < (sizeof(tpr) / sizeof(tpr[0])); i++) {
		if (strcmp(val, tpr[i].tpr_name) == 0) {
			ra.ra_proto = tpr[i].tpr_proto;
			break;
		}
	}
	if (ra.ra_proto == TRUNK_PROTO_MAX)
		errx(1, "Invalid trunk protocol: %s", val);

	strlcpy(ra.ra_ifname, name, sizeof(ra.ra_ifname));
	if (ioctl(s, SIOCSTRUNK, &ra) != 0)
		err(1, "SIOCSTRUNK");
}

void
trunk_status(void)
{
	struct trunk_protos tpr[] = TRUNK_PROTOS;
	struct trunk_reqport rp, rpbuf[TRUNK_MAX_PORTS];
	struct trunk_reqall ra;
	struct lacp_opreq *lp;
	const char *proto = "<unknown>";
	int i, isport = 0;

	bzero(&rp, sizeof(rp));
	bzero(&ra, sizeof(ra));

	strlcpy(rp.rp_ifname, name, sizeof(rp.rp_ifname));
	strlcpy(rp.rp_portname, name, sizeof(rp.rp_portname));

	if (ioctl(s, SIOCGTRUNKPORT, &rp) == 0)
		isport = 1;

	strlcpy(ra.ra_ifname, name, sizeof(ra.ra_ifname));
	ra.ra_size = sizeof(rpbuf);
	ra.ra_port = rpbuf;

	if (ioctl(s, SIOCGTRUNK, &ra) == 0) {
		lp = (struct lacp_opreq *)&ra.ra_lacpreq;

		for (i = 0; i < (sizeof(tpr) / sizeof(tpr[0])); i++) {
			if (ra.ra_proto == tpr[i].tpr_proto) {
				proto = tpr[i].tpr_name;
				break;
			}
		}

		printf("\ttrunk: trunkproto %s", proto);
		if (isport)
			printf(" trunkdev %s", rp.rp_ifname);
		putchar('\n');
		if (ra.ra_proto == TRUNK_PROTO_LACP) {
			char *act_mac = strdup(
			    ether_ntoa((struct ether_addr*)lp->actor_mac));
			if (act_mac == NULL)
				err(1, "strdup");
			printf("\ttrunk id: [(%04X,%s,%04X,%04X,%04X),\n"
			    "\t\t (%04X,%s,%04X,%04X,%04X)]\n",
			    lp->actor_prio, act_mac,
			    lp->actor_key, lp->actor_portprio, lp->actor_portno,
			    lp->partner_prio,
			    ether_ntoa((struct ether_addr*)lp->partner_mac),
			    lp->partner_key, lp->partner_portprio,
			    lp->partner_portno);
			free(act_mac);
		}

		for (i = 0; i < ra.ra_ports; i++) {
			printf("\t\ttrunkport %s ", rpbuf[i].rp_portname);
			printb_status(rpbuf[i].rp_flags, TRUNK_PORT_BITS);
			putchar('\n');
		}

		if (showmediaflag) {
			printf("\tsupported trunk protocols:\n");
			for (i = 0; i < (sizeof(tpr) / sizeof(tpr[0])); i++)
				printf("\t\ttrunkproto %s\n", tpr[i].tpr_name);
		}
	} else if (isport)
		printf("\ttrunk: trunkdev %s\n", rp.rp_ifname);
@


1.286
log
@allow IFXF_AUTOCONF6 to be set and cleared.
"ifconfig <if> inet6 autoconf" to turn it on, -autoconf to turn it off.
show AUTOCONF6 in the flags line.
-inet6 turns IFXF_AUTOCONF6 off as well.
ok stsp benno florian bluhm
@
text
@d479 1
a479 1
	{ "-inet6",	IFXF_NOINET6,	0,		setignore } ,
@


1.285
log
@Return RSN (WPA) information to userland during wireless scan, and
make ifconfig show whether a wireless network uses WEP or WPA.
Since struct ieee80211_nodereq grows in size old ifconfig won't be
able to scan when running on a new kernel.
While here, add missing ioctl constant IEEE80211_WPA_CIPHER_BIP.
ok jsg@@
@
text
@d151 1
d207 1
d338 2
d418 1
a418 1
	{ "-inet6",	IFXF_NOINET6,	0,		setifxflags },
d1260 15
d1358 14
@


1.284
log
@make "ifconfig <if> inet6 eui64" reset the NOINET6 flag
(unconditionally), so a link-local will be assigned if there isn't one
yet. ok krw benno todd sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.282 2014/03/05 20:46:50 tedu Exp $	*/
d2284 12
@


1.283
log
@Make ifconfig do something intelligent based on the required length of
WEP keys rather then being silently dumb, so when using WEP:
1) If the key is a plausible size try to use it.
2) If they key would be a plausible size with '0x' in front of it, add that.
3) If the key is not a plausible size, emit a warning and do not try to use it.
ok sthen@@
@
text
@d414 1
a414 1
	{ "-inet6",	IFXF_NOINET6,	0,		setifxflags } ,
d1315 1
@


1.282
log
@fix a null test, from remco.
and then modernize some other function pointer calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.281 2014/01/21 21:27:14 benno Exp $	*/
d1579 31
d1612 1
@


1.281
log
@allow pflow(4) to determine the src IP address based on the route
table if flowsrc is not set. Now works with new udp checksum code.
From Nathanael Rensen (nathanael.openbsd AT list DOT polymorpheus DOT
com), tweak and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.280 2013/12/01 10:05:29 stsp Exp $	*/
d1005 1
a1005 1
					(*p->af_status)(1);
d1010 1
a1010 1
						(*p->af_status)(0);
d1112 1
a1112 1
	(*afp->af_getaddr)(addr, (doalias >= 0 ? ADDR : RIDADDR));
d1132 1
a1132 1
	(*afp->af_getaddr)(addr, MASK);
d1139 1
a1139 1
	(*afp->af_getaddr)(addr, DSTADDR);
d1202 1
a1202 1
	(*afp->af_getaddr)(addr, DSTADDR);
d2943 1
a2943 1
			(*p->af_status)(1);
d2946 1
a2946 1
			(*p->af_status)(0);
d3021 2
a3022 2
	if (*afp->af_getprefix)
		(*afp->af_getprefix)(addr, MASK);
@


1.280
log
@Make ifconfig scan show the nwid, channel, and bssid for IBSS networks.
These were only shown for access points, so getting useful information
about IBSS networks in the area was somewhat difficult.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.279 2013/11/22 04:12:47 deraadt Exp $	*/
d3882 3
a3884 2
	printf("\tpflow: sender: %s ", preq.sender_ip.s_addr != INADDR_ANY ?
	    inet_ntoa(preq.sender_ip) : "INVALID");
@


1.279
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.278 2013/11/21 17:24:34 millert Exp $	*/
d2215 2
a2216 1
	if (nr->nr_flags & IEEE80211_NODEREQ_AP) {
a2224 1
	}
a2225 1
	if (nr->nr_flags & IEEE80211_NODEREQ_AP)
d2228 3
a2230 1
	else
@


1.278
log
@Make the bit string unsigned char * in printb() and printb_status().
In practice we shouldn't have chars > 127 in these but it is better
not to assume this.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.277 2013/11/12 04:59:02 deraadt Exp $	*/
d803 1
a803 1
	if (!isdigit(name[strlen(name) - 1]))
d942 2
a943 1
		if (nlen && !isdigit(oname[nlen - 1]))	/* is it a group? */
d956 1
a956 1
			if (nlen && isdigit(oname[nlen - 1])) {
d963 1
a963 1
				    !isdigit(ifa->ifa_name[nlen]))
d1380 2
a1381 1
	if (group_name[0] && isdigit(group_name[strlen(group_name) - 1]))
d1401 2
a1402 1
	if (group_name[0] && isdigit(group_name[strlen(group_name) - 1]))
d1562 1
a1562 1
		if (isdigit(val[0]) && val[1] == ':') {
d2051 1
a2051 1
				    isdigit(nwkey.i_key[0].i_keydat[0]) &&
d2467 1
a2467 1
	char	*ptr = (char*)val;
d2475 1
a2475 1
			if (isdigit(*ptr)) {
@


1.277
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.276 2013/11/05 21:04:52 bluhm Exp $	*/
d508 1
a508 1
void	printb_status(unsigned short, char *);
d4559 1
a4559 1
printb(char *s, unsigned int v, char *bits)
d4562 1
a4562 1
	char c;
d4591 1
a4591 1
printb_status(unsigned short v, char *bits)
d4594 1
a4594 1
	char c;
@


1.276
log
@Fix ifconfig with IPv6 tunnel addresses which was broken by the
vxlan(4) commit.
found by todd@@; OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.275 2013/10/28 15:05:35 deraadt Exp $	*/
d543 4
@


1.275
log
@use %d instead of %i in a few fprintf for clarity
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.274 2013/10/17 16:27:39 bluhm Exp $	*/
d3166 2
a3167 1
	if (strchr (dst, ':') == NULL) {
@


1.274
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.273 2013/10/13 12:19:30 reyk Exp $	*/
d2795 1
a2795 1
		printf(" rdomain %i", rdomainid);
d4508 1
a4508 1
		l = snprintf(p, sizeof(p), "%i", bits);
d4510 1
a4510 1
			errx(1, "%i: bad prefixlen", bits);
@


1.273
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.272 2013/10/13 10:10:00 reyk Exp $	*/
d73 1
@


1.272
log
@Import vxlan(4), the virtual extensible local area network tunnel
interface.  VXLAN is a UDP-based tunnelling protocol for overlaying
virtualized layer 2 networks over layer 3 networks. The implementation
is based on draft-mahalingam-dutt-dcops-vxlan-04 and has been tested
with other implementations in the wild.

put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.271 2013/10/09 20:23:46 reyk Exp $	*/
d410 1
a410 1
	{ "flowdst", 	NEXTARG,	0,		setpflow_receiver },
d419 1
a419 1
	{ "delspan",	NEXTARG, 	0,		bridge_delspan },
d703 2
a704 1
						if (strcmp(argv[1], p0->c_name) == 0) {
d2702 1
a2702 1
	in_port_t dstport = 0;	
a2738 1

a2740 1

a2742 1

d3425 2
a3426 2
		    	    carpr.carpr_carpdev : "none", carpr.carpr_vhids[0],
		    	    carpr.carpr_advbase, carpr.carpr_advskews[0],
d3907 1
a3907 1
	
d4761 1
a4761 1
	
@


1.271
log
@Change "physical address" to "tunnel:" in ifconfig's tunnel address
output.  This is more consistent with the current ifconfig style and
matches the "tunnel" configuration command.

ok claudio@@ jmc@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.270 2013/09/13 14:32:53 florian Exp $	*/
d171 2
d385 2
d2701 1
d2721 2
d2724 1
a2724 1
	if (req.dstaddr.ss_family == AF_INET6)
d2726 2
d2736 9
d3161 2
d3167 11
d3182 1
a3182 1
	if ((ecode = getaddrinfo(dst, NULL, NULL, &dstres)) != 0)
d3227 32
@


1.270
log
@pflow(4) does not work without flowsrc set.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.269 2013/08/19 11:20:57 dcoppa Exp $	*/
d2724 1
a2724 1
	printf("\tphysical address inet%s %s --> %s", ver,
@


1.269
log
@Add missing util.h

ok otto@@ mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.268 2013/08/16 12:29:17 mpi Exp $	*/
d3811 8
a3818 3
	printf("\tpflow: sender: %s ", inet_ntoa(preq.sender_ip));
	printf("receiver: %s:%u ", inet_ntoa(preq.receiver_ip),
	    ntohs(preq.receiver_port));
@


1.268
log
@Replace the misleading SIOC{G,S}IFGENERIC ioctls by SIOCG{G,S}PPPPARAMS.

This is another ABI break but no port rely on them as verified by naddy@@.

ok claudio@@, mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.267 2013/07/16 08:21:10 mpi Exp $	*/
d103 1
@


1.267
log
@Make sure the ioctl(2) has been processed by sppp(4) before printing
any phase error.

This prevents ifconfig(8) from priting 'sppp: phase...' messages for
vlan(4) interfaces attached to interfaces with a long name.  A better
fix should be cooked because various pseudo-interfaces still use the
same set of ioctl(2)s for different purposes.

Issue reported by jca@@, ok claudio@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.266 2013/07/10 07:46:10 mpi Exp $	*/
d4072 2
a4073 2
	if (ioctl(s, SIOCGIFGENERIC, &ifr) == -1)
		err(1, "SIOCGIFGENERIC(SPPPIOGXAUTH)");
d4093 2
a4094 2
	if (ioctl(s, SIOCSIFGENERIC, &ifr) == -1)
		err(1, "SIOCSIFGENERIC(SPPPIOSXAUTH)");
d4116 2
a4117 2
	if (ioctl(s, SIOCSIFGENERIC, &ifr) == -1)
		err(1, "SIOCSIFGENERIC(SPPPIOSXAUTH)");
d4139 2
a4140 2
	if (ioctl(s, SIOCSIFGENERIC, &ifr) == -1)
		err(1, "SIOCSIFGENERIC(SPPPIOSXAUTH)");
d4172 2
a4173 2
	if (ioctl(s, SIOCSIFGENERIC, &ifr) == -1)
		err(1, "SIOCSIFGENERIC(SPPPIOSXAUTH)");
d4215 1
a4215 1
	if (ioctl(s, SIOCGIFGENERIC, &ifr) == -1) {
d4219 1
a4219 1
	if (spr.cmd != SPPPIOGDEFS || spr.phase == PHASE_DEAD)
@


1.266
log
@Change the structure used in the SPPPIOSDEFS and SPPPIOGDEFS ioctls
to only include what is really needed.  In particular stop including
a "struct ifnet" and move kernel-only definition into the proper #if
dance.

While here remove the unused spppinfo() from ifconfig.

ok guenther@@, sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.265 2013/07/02 14:25:08 bluhm Exp $	*/
d4219 1
a4219 1
	if (spr.phase == PHASE_DEAD)
@


1.265
log
@Long passwords could not be replaced completely with shorter
passwords.  ioctl(SIOCGVH) fills the carpr_key with the old value.
strlcpy() overwrites only the beginning of the key.  Add a bzero()
to clear the rest.
Testing Jan Klemkow; OK florian@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.264 2013/05/31 19:56:06 yasuoka Exp $	*/
a234 1
void	spppinfo(struct spppreq *);
a4065 11
spppinfo(struct spppreq *spr)
{
	bzero(spr, sizeof(struct spppreq));

	ifr.ifr_data = (caddr_t)spr;
	spr->cmd = SPPPIOGDEFS;
	if (ioctl(s, SIOCGIFGENERIC, &ifr) == -1)
		err(1, "SIOCGIFGENERIC(SPPPIOGDEFS)");
}

void
d4219 1
a4219 1
	if (spr.defs.pp_phase == PHASE_DEAD)
d4222 1
a4222 1
	switch (spr.defs.pp_phase) {
@


1.264
log
@Correct the range checks in ifconfig properly for vhid, advbase and advskew.
Clarify about the ranges in the man page.

ok mpf mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.263 2013/04/25 06:41:46 otto Exp $	*/
d3393 1
a3393 1
	/* XXX Should hash the password into the key here, perhaps? */
@


1.263
log
@fix format string; found while scaning the tree for time_t/ino_t problems;
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.262 2013/04/19 18:11:13 deraadt Exp $	*/
d3433 1
a3433 1
	advskew = strtonum(val, 0, 255, &errmsg);
d3457 1
a3457 1
	advbase = strtonum(val, 0, 255, &errmsg);
d3612 1
a3612 1
		if (vhid >= 255)
@


1.262
log
@remove comment about "make gcc happy" for variables which WERE being
used uninitialized... clean up time related variables too for 2038++
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.261 2013/04/03 16:28:10 deraadt Exp $	*/
d4721 1
a4721 1
			printf(" hardmtu %lu", ifr.ifr_hardmtu);
@


1.261
log
@handle larger time_t types; toss some unused code
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.260 2012/12/04 14:54:32 deraadt Exp $	*/
a3947 5
	struct timeval temp_time;
	long diff_time;
	unsigned long day, hour, min, sec;

	day = hour = min = sec = 0; /* XXX make gcc happy */
a3949 1
	timerclear(&temp_time);
d3984 4
d4006 2
a4007 2
			printf("%ldd ", day);
		printf("%02ld:%02ld:%02ld", hour, min, sec);
@


1.260
log
@add group support back (for the ramdisk version)
spotted by rpe and sthen; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.259 2012/12/04 04:48:10 deraadt Exp $	*/
d3100 1
d3110 1
d3115 1
a3115 1
				    sec2str( lifetime->ia6t_preferred - t));
a4733 2
	int days, hours, mins, secs;
	int first = 1;
a4735 32
	int n;

	if (0) {	/*XXX*/
		days = total / 3600 / 24;
		hours = (total / 3600) % 24;
		mins = (total / 60) % 60;
		secs = total % 60;

		if (days) {
			first = 0;
			n = snprintf(p, end - p, "%dd", days);
			if (n < 0 || n >= end - p)
				return (result);
			p += n;
		}
		if (!first || hours) {
			first = 0;
			n = snprintf(p, end - p, "%dh", hours);
			if (n < 0 || n >= end - p)
				return (result);
			p += n;
		}
		if (!first || mins) {
			first = 0;
			n = snprintf(p, end - p, "%dm", mins);
			if (n < 0 || n >= end - p)
				return (result);
			p += n;
		}
		snprintf(p, end - p, "%ds", secs);
	} else
		snprintf(p, end - p, "%lu", (u_long)total);
d4737 1
@


1.259
log
@only needs sys/types.h not sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.258 2012/11/23 20:12:38 sthen Exp $	*/
d197 5
a203 1
void	getifgroups(void);
a241 2
void	setifgroup(const char *, int);
void	unsetifgroup(const char *, int);
a245 1
void	setgroupattribs(char *, int, char *[]);
a255 1
int	printgroup(char *, int);
d331 2
a345 2
	{ "group",	NEXTARG,	0,		setifgroup },
	{ "-group",	NEXTARG,	0,		unsetifgroup },
a462 1
	{ "group",	NEXTARG,	0,		setignore },
d573 1
a574 1
#endif
a598 1
#ifndef SMALL
d602 1
d641 1
a648 1
#endif
a831 1
#ifndef SMALL
a913 1
#endif /* SMALL */
a931 1
#ifndef SMALL
a936 1
#endif
a1359 1
#ifndef SMALL
a1396 1
#endif
d2820 1
a2821 1
#endif
a4658 1
#ifndef SMALL
d4701 1
@


1.258
log
@Display hardmtu value when "ifconfig hwfeatures" is used.
Looks fine reyk@@ ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.257 2012/09/06 19:41:59 tedu Exp $	*/
d63 1
a63 1
#include <sys/param.h>
@


1.257
log
@move pkcs5_pbkdf5 function to libutil so everybody can play with it
ok deraadt jsing matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.256 2012/08/21 19:50:39 bluhm Exp $	*/
d4725 5
@


1.256
log
@Reverse the name and meaning of the IFXF_INET6_PRIVACY interface
flag.  It is now called IFXF_INET6_NOPRIVACY.  So IPv6 privacy
addresses are on by default without resetting the flag during
ifconfig down/up.
OK stsp@@, sperreault@@ (who wrote the same diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.255 2012/04/15 03:10:43 jsg Exp $	*/
a105 1
#include "pbkdf2.h"
@


1.255
log
@fix a leak
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.254 2012/02/02 12:34:37 benno Exp $	*/
d340 2
a341 2
	{ "autoconfprivacy",	IFXF_INET6_PRIVACY,	0,	setifxflags },
	{ "-autoconfprivacy",	-IFXF_INET6_PRIVACY,	0,	setifxflags },
@


1.254
log
@add netflow v9/ipfix support to pflow(4).
large parts written by Florian Obser (florian -at- narrans -dot- de).
feedback from sperreault@@ gollo@@ sthen@@
ok from gollo@@ dlg@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.253 2011/12/04 06:26:10 haesbaert Exp $	*/
d938 2
a939 1
			if (printgroup(oname, ifaliases) != -1)
d941 1
@


1.253
log
@Cleanup recently removed flags from ifconfig.c and its manpage.

ok jmc@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.252 2011/11/26 23:38:18 haesbaert Exp $	*/
d251 1
d409 1
d3816 1
a3816 1
	printf("receiver: %s:%u\n", inet_ntoa(preq.receiver_ip),
d3818 1
d3915 28
@


1.252
log
@Tie the 802.1p (CoS) value in vlan(4) with the new prio scheme in pf.

When transmitting through vlan(4), it will now use the prio value in
pf packet header. When receiving, we save the incoming Cos in the same
place, this gives us the hability to preserve the CoS value across two
different vlan interfaces.

This kills the SIOC[GS]VLANPRIO ioctls and removes the corresponding
buttons from ifconfig(8).

ok henning@@ claudio@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.251 2011/11/02 02:03:47 haesbaert Exp $	*/
d109 3
a111 3
	"\024\1CSUM_IPv4\2CSUM_TCPv4\3CSUM_UDPv4\4IPSEC"		\
	"\5VLAN_MTU\6VLAN_HWTAGGING\7IPCOMP\10CSUM_TCPv6"		\
	"\11CSUM_UDPv6\12TCPv4_Rx\13UDPv4_Rx\20WOL"
@


1.251
log
@Expose if_capabilities to userland so that ifconfig can display the
device hardware features.
Tune ifconfig to show them with 'hwfeatures' argument.
While here, kill some old unused capabilities and respect 80 columns
in brconfig.h.

ok mcbride@@, henning@@, mpf@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.250 2011/09/19 20:29:10 henning Exp $	*/
a190 1
void	setvlanprio(const char *, int);
a363 1
	{ "vlanprio",	NEXTARG,	0,		setvlanprio },
a466 1
	{ "vlanprio",	NEXTARG,	0,		setignore },
a3237 1
	struct vlanreq preq;
a3244 6
	bzero(&preq, sizeof(struct vlanreq));
	ifr.ifr_data = (caddr_t)&preq;

	if (ioctl(s, SIOCGETVLANPRIO, (caddr_t)&ifr) == -1)
		return;

d3246 2
a3247 2
		printf("\tvlan: %d priority: %d parent interface: %s\n",
		    vreq.vlr_tag, preq.vlr_tag, vreq.vlr_parent[0] == '\0' ?
a3274 26

#ifndef SMALL
/* ARGSUSED */
void
setvlanprio(const char *val, int d)
{
	u_int16_t prio;
	struct vlanreq vreq;
	const char *errmsg = NULL;

	prio = strtonum(val, 0, 7, &errmsg);
	if (errmsg)
		errx(1, "vlan priority %s: %s", val, errmsg);

	bzero(&vreq, sizeof(struct vlanreq));
	ifr.ifr_data = (caddr_t)&vreq;

	if (ioctl(s, SIOCGETVLANPRIO, (caddr_t)&ifr) == -1)
		err(1, "SIOCGETVLANPRIO");

	vreq.vlr_tag = prio;

	if (ioctl(s, SIOCSETVLANPRIO, (caddr_t)&ifr) == -1)
		err(1, "SIOCSETVLANPRIO");
}
#endif
@


1.250
log
@kill prototypes for long removed functions, Rafael Sadowski <rafael at
sizeofvoid.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.248 2011/07/09 00:45:40 henning Exp $	*/
d108 5
d139 1
d257 1
d344 1
d2791 4
d4711 19
@


1.249
log
@Remove old wpapsk entries. Cleanup casts and use timerclear.
ok mcbride
@
text
@a528 2
void    at_status(int);
void    at_getaddr(const char *, int);
@


1.248
log
@rmove rotten netatalk bits
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.247 2011/05/26 13:10:11 sthen Exp $	*/
a316 3
/*XXX delete these two after the 4.9 release */
/*XXX*/	{ "wpapsk",     NEXTARG,        0,              setifwpakey },
/*XXX*/	{ "-wpapsk",    -1,             0,              setifwpakey },
d2838 1
a2838 1
	media_list = (int *)calloc(ifmr.ifm_count, sizeof(int));
d2840 1
a2840 1
		err(1, "malloc");
d3415 1
a3415 1
	memset((char *)&carpr, 0, sizeof(struct carpreq));
d3440 1
a3440 1
	memset((char *)&carpr, 0, sizeof(struct carpreq));
d3465 1
a3465 1
	memset((char *)&carpr, 0, sizeof(struct carpreq));
d3489 1
a3489 1
	memset((char *)&carpr, 0, sizeof(struct carpreq));
d3509 1
a3509 1
	memset((char *)&carpr, 0, sizeof(struct carpreq));
d3540 1
a3540 1
	bzero((char *)&carpr, sizeof(struct carpreq));
d3546 1
a3546 1
	bzero((char *)&carpr.carpr_peer, sizeof(carpr.carpr_peer));
d3559 1
a3559 1
	bzero((char *)&carpr, sizeof(struct carpreq));
d3582 1
a3582 1
	bzero((char *)&carpr, sizeof(struct carpreq));
d3599 1
a3599 1
	bzero((char *)&carpr, sizeof(struct carpreq));
d3605 1
a3605 1
	bzero((char *)&carpr.carpr_carpdev, sizeof(carpr.carpr_carpdev));
d3618 1
a3618 1
	bzero((char *)&carpr, sizeof(struct carpreq));
d3661 1
a3661 1
	bzero((char *)&carpr, sizeof(struct carpreq));
d3685 1
a3685 1
	bzero((char *)&preq, sizeof(struct pfsyncreq));
d3703 1
a3703 1
	bzero((char *)&preq, sizeof(struct pfsyncreq));
d3709 1
a3709 1
	bzero((char *)&preq.pfsyncr_syncdev, sizeof(preq.pfsyncr_syncdev));
d3723 1
a3723 1
	bzero((char *)&preq, sizeof(struct pfsyncreq));
d3755 1
a3755 1
	bzero((char *)&preq, sizeof(struct pfsyncreq));
d3779 1
a3779 1
	memset((char *)&preq, 0, sizeof(struct pfsyncreq));
d3796 1
a3796 1
	memset((char *)&preq, 0, sizeof(struct pfsyncreq));
d3812 1
a3812 1
	bzero((char *)&preq, sizeof(struct pfsyncreq));
d3833 1
a3833 1
	bzero((char *)&preq, sizeof(struct pflowreq));
d3852 1
a3852 1
	memset(&hints, 0, sizeof(hints));
d3863 1
a3863 1
	bzero((char *)&preq, sizeof(struct pflowreq));
a3868 1

d3880 1
a3880 1
	bzero((char *)&preq, sizeof(struct pflowreq));
d3905 1
a3905 1
	memset(&hints, 0, sizeof(hints));
d3916 1
a3916 1
	bzero((char *)&preq, sizeof(struct pflowreq));
d3935 1
a3935 1
	bzero((char *)&preq, sizeof(struct pflowreq));
d3954 1
a3954 1
	memset(&temp_time, 0, sizeof(temp_time));
d4006 2
a4007 1
		if (day != 0) printf("%ldd ", day);
d4679 1
a4679 2
	ifgr.ifgr_groups =
	    (struct ifg_req *)calloc(len / sizeof(struct ifg_req),
@


1.247
log
@Don't provide an af hint to getaddrinfo in settunnel(), this function
already checks that families of source and destination addresses match
and that's all we need.

This allows "ifconfig foo tunnel 1::1 2::2" syntax rather than requiring
"ifconfig foo inet6 tunnel 1::1 2::2", which in turn allows hostname.if
files to create an IPv4-in-IPv6 tunnel without games with shell escapes.

ok dcoppa@@, seems ok todd@@, "Yes, yes and yes" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.246 2011/03/23 18:36:41 jsg Exp $	*/
a87 2
#include <netatalk/at.h>

a118 1
struct  netrange	at_nr;		/* AppleTalk net range */
a161 2
void	setatrange(const char *, int);
void	setatphase(const char *, int);
a173 1
void	checkatrange(struct sockaddr_at *);
a350 2
	{ "range",	NEXTARG,	0,		setatrange },
	{ "phase",	NEXTARG,	0,		setatphase },
a557 4
#ifndef SMALL
	{ "atalk", AF_APPLETALK, at_status, at_getaddr, NULL,
	    SIOCDIFADDR, SIOCAIFADDR, C(addreq), C(addreq) },
#endif
a752 5
#ifndef SMALL
	if (af == AF_APPLETALK)
		checkatrange((struct sockaddr_at *) &addreq.ifra_addr);
#endif /* SMALL */

a3193 117
}

void
at_status(int force)
{
	struct sockaddr_at *sat, null_sat;
	struct netrange *nr;

	getsock(AF_APPLETALK);
	if (s < 0) {
		if (errno == EPROTONOSUPPORT)
			return;
		err(1, "socket");
	}
	(void) memset(&ifr, 0, sizeof(ifr));
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFADDR, (caddr_t)&ifr) < 0) {
		if (errno == EADDRNOTAVAIL || errno == EAFNOSUPPORT) {
			if (!force)
				return;
			(void) memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
		} else
			warn("SIOCGIFADDR");
	}
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	sat = (struct sockaddr_at *)&ifr.ifr_addr;

	(void) memset(&null_sat, 0, sizeof(null_sat));

	nr = (struct netrange *) &sat->sat_zero;
	printf("\tAppleTalk %d.%d range %d-%d phase %d",
	    ntohs(sat->sat_addr.s_net), sat->sat_addr.s_node,
	    ntohs(nr->nr_firstnet), ntohs(nr->nr_lastnet), nr->nr_phase);
	if (flags & IFF_POINTOPOINT) {
		if (ioctl(s, SIOCGIFDSTADDR, (caddr_t)&ifr) < 0) {
			if (errno == EADDRNOTAVAIL)
			    (void) memset(&ifr.ifr_addr, 0,
				sizeof(ifr.ifr_addr));
			else
			    warn("SIOCGIFDSTADDR");
		}
		(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
		sat = (struct sockaddr_at *)&ifr.ifr_dstaddr;
		if (!sat)
			sat = &null_sat;
		printf("--> %d.%d",
		    ntohs(sat->sat_addr.s_net), sat->sat_addr.s_node);
	}
	if (flags & IFF_BROADCAST) {
		/* note RTAX_BRD overlap with IFF_POINTOPOINT */
		sat = (struct sockaddr_at *)&ifr.ifr_broadaddr;
		if (sat)
			printf(" broadcast %d.%d", ntohs(sat->sat_addr.s_net),
			    sat->sat_addr.s_node);
	}
	putchar('\n');
}

void
at_getaddr(const char *addr, int which)
{
	struct sockaddr_at *sat = (struct sockaddr_at *) &addreq.ifra_addr;
	u_int net, node;

	sat->sat_family = AF_APPLETALK;
	sat->sat_len = sizeof(*sat);
	if (which == MASK)
		errx(1, "AppleTalk does not use netmasks");
	if (sscanf(addr, "%u.%u", &net, &node) != 2 ||
	    net == 0 || net > 0xffff || node == 0 || node > 0xfe)
		errx(1, "%s: illegal address", addr);
	sat->sat_addr.s_net = htons(net);
	sat->sat_addr.s_node = node;
}

/* ARGSUSED */
void
setatrange(const char *range, int d)
{
	u_int first = 123, last = 123;

	if (sscanf(range, "%u-%u", &first, &last) != 2 ||
	    first == 0 || first > 0xffff ||
	    last == 0 || last > 0xffff || first > last)
		errx(1, "%s: illegal net range: %u-%u", range, first, last);
	at_nr.nr_firstnet = htons(first);
	at_nr.nr_lastnet = htons(last);
}

/* ARGSUSED */
void
setatphase(const char *phase, int d)
{
	if (!strcmp(phase, "1"))
		at_nr.nr_phase = 1;
	else if (!strcmp(phase, "2"))
		at_nr.nr_phase = 2;
	else
		errx(1, "%s: illegal phase", phase);
}

void
checkatrange(struct sockaddr_at *sat)
{
	if (at_nr.nr_phase == 0)
		at_nr.nr_phase = 2;	/* Default phase 2 */
	if (at_nr.nr_firstnet == 0)	/* Default range of one */
		at_nr.nr_firstnet = at_nr.nr_lastnet = sat->sat_addr.s_net;
	printf("\tatalk %d.%d range %d-%d phase %d\n",
	ntohs(sat->sat_addr.s_net), sat->sat_addr.s_node,
	ntohs(at_nr.nr_firstnet), ntohs(at_nr.nr_lastnet), at_nr.nr_phase);
	if ((u_short) ntohs(at_nr.nr_firstnet) >
	    (u_short) ntohs(sat->sat_addr.s_net) ||
	    (u_short) ntohs(at_nr.nr_lastnet) <
	    (u_short) ntohs(sat->sat_addr.s_net))
		errx(1, "AppleTalk address is not in range");
	*((struct netrange *) &sat->sat_zero) = at_nr;
@


1.246
log
@use the define for max rdomain with tunneldomain as well
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.245 2011/03/13 15:31:41 stsp Exp $	*/
d3158 1
a3158 1
	struct addrinfo hints, *srcres, *dstres;
d3162 1
a3162 5
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = afp->af_af;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/

	if ((ecode = getaddrinfo(src, NULL, &hints, &srcres)) != 0)
d3166 1
a3166 1
	if ((ecode = getaddrinfo(dst, NULL, &hints, &dstres)) != 0)
@


1.245
log
@Add a way to enable/disable Wake On LAN with ifconfig.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.244 2011/03/01 09:37:31 claudio Exp $	*/
d3207 1
a3207 1
	rdomainid = strtonum(id, 0, 128, &errmsg);
@


1.244
log
@Introduce a dummy function in the SMALL case to digest arguments like
"rdomain", "description", etc. so that the ifconfig on ramdisk is able
to parse hostname.if files on updates.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.243 2011/02/17 06:46:30 camield Exp $	*/
d464 2
d479 2
@


1.243
log
@0-4095 inclusive is the correct (12 bit) vlan range

ok henning claudio miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.242 2010/11/09 21:14:47 jsg Exp $	*/
a140 3
void	notrailers(const char *, int);
void	setifgroup(const char *, int);
void	unsetifgroup(const char *, int);
a147 4
void	setifdesc(const char *, int);
void	unsetifdesc(const char *, int);
void	setifipdst(const char *, int);
void	setifmetric(const char *, int);
a160 1
void	setifpowersave(const char *, int);
d196 5
d240 2
d243 4
a246 5
void	setinstance(const char *, int);
int	main(int, char *[]);
int	prefix(void *val, int);

#ifndef SMALL
d252 7
a294 2
	{ "trailers",	-1,		0,		notrailers },
	{ "-trailers",	1,		0,		notrailers },
a306 2
	{ "group",	NEXTARG,	0,		setifgroup },
	{ "-group",	NEXTARG,	0,		unsetifgroup },
a307 1
	{ "metric",	NEXTARG,	0,		setifmetric },
a328 2
	{ "powersave",	NEXTARG0,	0,		setifpowersave },
	{ "-powersave",	-1,		0,		setifpowersave },
a329 1
	{ "ipdst",	NEXTARG,	0,		setifipdst },
a330 1
	{ "priority",	NEXTARG,	0,		setifpriority },
a331 1
	{ "vlanprio",	NEXTARG,	0,		setvlanprio },
d346 8
d356 1
d368 1
a408 1
	{ "rdomain",	NEXTARG,	0,		setinstance },
d452 1
d460 17
a495 4
	{ "description", NEXTARG,	0,		setifdesc },
	{ "descr",	NEXTARG,	0,		setifdesc },
	{ "-description", 1,		0,		unsetifdesc },
	{ "-descr",	1,		0,		unsetifdesc },
a502 1
int	printgroup(char *, int);
a503 1
void	setgroupattribs(char *, int, char *[]);
a511 1
void	list_cloners(void);
d579 1
d582 1
d607 1
d615 1
d642 1
d656 1
d836 1
d841 1
d845 1
d928 1
d947 1
d951 1
d1055 1
d1095 1
d1146 1
d1174 1
d1192 1
d1199 1
d1343 1
d1358 1
d1375 1
d1413 1
a1892 1
#endif
d1917 1
a2523 1
#endif /* SMALL */
a2524 1
#ifndef SMALL
d2744 1
d2748 1
d2752 1
d2757 1
d2785 1
a2786 1
#ifndef SMALL
d2788 1
a2790 1
	char ifdescr[IFDESCRSIZE];
d2806 1
a2813 1
#ifndef SMALL
d2833 1
a2834 1
	getifgroups();
d2872 3
d2905 1
a2905 1

d3413 1
d3437 1
a3964 1
#ifndef SMALL
a4078 1
#endif /* SMALL */
a4549 1
#endif /* SMALL */
a4553 1
#ifndef SMALL
d4565 1
a4566 1
}
d4797 1
d4840 1
d4929 8
@


1.242
log
@when setting the rdomain, use the same define as the kernel
for the maximum route-id instead of a currently incorrect number
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.241 2010/11/01 05:24:58 deraadt Exp $	*/
d3354 1
a3354 1
	__tag = tag = strtonum(val, 0, 65535, &errmsg);
d3414 1
a3414 1
		tag = strtonum(ifr.ifr_name + skip, 1, 4095, &estr);
@


1.241
log
@add support for (full length only) hex keys to the wpakey code.  for the
remainder of the 4.8->4.9 transition, alias wpapsk to wpakey (since
it swings both ways)
ok damien halex tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.240 2010/10/18 04:10:57 deraadt Exp $	*/
d4879 1
a4879 1
	rdomainid = strtonum(id, 0, 128, &errmsg);
@


1.240
log
@Add wpakey/-wpakey options.  This was originally written by halex and
has gone many times around now (it is smaller now).  man page diff
coming soon.  Fits onto the media that need it.
ok halex
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.239 2010/07/03 04:44:51 guenther Exp $	*/
a164 1
void	setifwpapsk(const char *, int);
d323 3
a325 2
	{ "wpapsk",	NEXTARG,	0,		setifwpapsk },
	{ "-wpapsk",	-1,		0,		setifwpapsk },
d1381 2
a1382 2
	int len, hexstr;
	u_int8_t *p;
a1383 2
	len = *lenp;
	p = buf;
d1431 1
a1431 2
	int i;
	int hasspc;
a1432 2
	i = 0;
	hasspc = 0;
d1715 1
a1715 1
	int passlen, nwid_len;
d1726 18
a1743 9
		if (passlen < 8 || passlen > 63)
			errx(1, "wpakey: passphrase must be between 8 and 63 "
			    "characters");
		nwid_len = nwid.i_len;
		if (nwid_len == 0)
			errx(1, "wpakey: nwid not set");
		if (pkcs5_pbkdf2(val, passlen, nwid.i_nwid, nwid_len, psk.i_psk,
		    sizeof(psk.i_psk), 4096) != 0)
			errx(1, "wpakey: passphrase hashing failed");
a1762 22
setifwpapsk(const char *val, int d)
{
	struct ieee80211_wpapsk psk;
	int len;

	if (d != -1) {
		len = sizeof(psk.i_psk);
		val = get_string(val, NULL, psk.i_psk, &len);
		if (val == NULL)
			errx(1, "wpapsk: invalid pre-shared key");
		if (len != sizeof(psk.i_psk))
			errx(1, "wpapsk: bad pre-shared key length");
		psk.i_enabled = 1;
	} else
		psk.i_enabled = 0;

	(void)strlcpy(psk.i_name, name, sizeof(psk.i_name));
	if (ioctl(s, SIOCS80211WPAPSK, (caddr_t)&psk) < 0)
		err(1, "SIOCS80211WPAPSK");
}

void
d2048 1
a2048 1
		fputs(" wpapsk ", stdout);
@


1.239
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.238 2010/07/02 22:03:40 deraadt Exp $	*/
d108 1
d164 1
d322 2
d1571 1
d1602 1
d1633 1
d1685 1
d1705 1
d1710 44
@


1.238
log
@make lint a bit happier
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.237 2010/06/26 19:51:12 claudio Exp $	*/
d811 1
a811 1
	if (ioctl(s, SIOCGIFRTABLEID, (caddr_t)ifr) < 0)
d2674 1
a2674 1
	if (ioctl(s, SIOCGLIFPHYRTABLEID, (caddr_t)&ifr) == 0 &&
d3132 2
a3133 2
	if (ioctl(s, SIOCSLIFPHYRTABLEID, (caddr_t)&ifr) < 0)
		warn("SIOCSLIFPHYRTABLEID");
d4850 2
a4851 2
	if (ioctl(s, SIOCSIFRTABLEID, (caddr_t)&ifr) < 0)
		warn("SIOCSIFRTABLEID");
@


1.237
log
@Add a way to enable and set the keepalive parameters for gre(4).
OK deraadt, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.236 2010/06/07 14:50:34 claudio Exp $	*/
d4689 1
a4689 1
	u_char *name = (u_char *)val;
d4693 1
a4693 1
		if (name[byte] != 0xff)
d4698 1
a4698 1
		if (!(name[byte] & (1 << bit)))
d4701 1
a4701 1
		if (name[byte] & (1 << bit))
d4705 1
a4705 1
		if (name[byte])
d4811 1
@


1.236
log
@Oups, an unused prototype sneaked into ifconfig. Found by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.235 2010/06/04 08:53:24 claudio Exp $	*/
d183 2
d406 2
d2712 3
d2742 6
d4440 32
@


1.235
log
@Merge interface flags and xflags before printing them. So it is possible to
see if a interface is using the INET6_PRIVACY or is MPLS enabled.
If xflags uses more then 16 flags something else must be figured out.
OK stsp@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.234 2010/06/03 21:57:12 stsp Exp $	*/
a193 1
void	setifmpls(const char *, int);
@


1.234
log
@Stop requiring the 'inet6' keyword when the 'autoconfprivacy' option is used.
Simplifies enabling autoconf privacy from hostname.if files. A line such as
'rtsol autoconfprivacy' will now work, as documented in ifconfig(8).
Pointed out by steven@@.
ok deraadt@@ steven@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.233 2010/05/28 12:20:06 claudio Exp $	*/
d124 1
a124 1
int	flags, setaddr, setipdst, doalias;
a481 1
void	printb(char *, unsigned short, char *);
d792 4
a795 1
	flags = ifr->ifr_flags;
d1208 1
a1208 1
	flags = my_ifr.ifr_flags;
d1212 1
a1212 1
		flags &= ~value;
d1214 2
a1215 2
		flags |= value;
	my_ifr.ifr_flags = flags;
d2713 1
a2713 1
	printb("flags", flags, IFFBITS);
d4517 1
a4517 1
printb(char *s, unsigned short v, char *bits)
@


1.233
log
@Add mpls/-mpls commands to enable MPLS label switching on an interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.232 2010/05/06 12:58:40 claudio Exp $	*/
a1199 6

	if ((value == IFXF_INET6_PRIVACY || value == -IFXF_INET6_PRIVACY)
	    && afp->af_af != AF_INET6) {
		errx(1, "autoconfprivacy needs AF inet6, current AF is `%s'",
		    afp->af_name);
	}
@


1.232
log
@Print the link state for devices not having if_media support by looking at
ifdata->ifi_link_state. Don't print in case of a unknown linkstate since
some devices (lo0) just have none.
OK sthen, dlg, blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.231 2010/04/06 14:12:10 stsp Exp $	*/
d194 1
d350 2
d3258 1
@


1.231
log
@Simple implementation of RFC4941, "Privacy Extensions for Stateless
Address Autoconfiguration in IPv6". For those among us who are paranoid
about broadcasting their MAC address to the IPv6 internet.

Man page help from jmc, testing by weerd, arc4random API hints from djm.

ok deraadt, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.230 2010/04/03 03:13:01 deraadt Exp $	*/
d481 2
a482 1
void	status(int, struct sockaddr_dl *);
d897 1
d954 3
a956 1
			status(1, (struct sockaddr_dl *)ifa->ifa_addr);
d2683 17
d2705 1
a2705 1
status(int link, struct sockaddr_dl *sdl)
d2758 3
@


1.230
log
@On the random MAC address also turn off the 'local administered' bit,
since it is our intent to deceive.  Prompted by weerd.
ok ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.229 2010/04/02 21:16:24 deraadt Exp $	*/
d341 2
d1194 6
d2992 2
@


1.229
log
@randomized mac addresses, avaliable via 'ifconfig $if lladdr random'.
Note that not all device drivers do the work of the SIOCSIFLLADDR ioctl
correctly, but this is just more reason to get them fixed.
ok beck kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.228 2010/01/10 03:58:14 guenther Exp $	*/
d4740 2
a4741 1
		eabuf.ether_addr_octet[0] &= 0xfe;	/* Not multicast! */
@


1.228
log
@s/setpriority/setifpriority/ to eliminate a conflict with setpriority()
To quote henning, 'ok gcc'
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.227 2009/12/22 17:48:49 deraadt Exp $	*/
d4736 1
a4736 1
	struct ether_addr *eap;
d4738 10
a4747 4
	eap = ether_aton(addr);
	if (eap == NULL) {
		warnx("malformed link-level address");
		return;
@


1.227
log
@re-adding a group that exists is not an error
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.226 2009/12/14 17:22:58 deraadt Exp $	*/
d240 1
a240 1
void	setpriority(const char *, int);
d328 1
a328 1
	{ "priority",	NEXTARG,	0,		setpriority },
d4398 1
a4398 1
setpriority(const char *id, int param)
@


1.226
log
@make ifconfig return with failure of bridge_rule; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.225 2009/12/14 17:14:56 deraadt Exp $	*/
d1336 4
a1339 2
	if (ioctl(s, SIOCAIFGROUP, (caddr_t)&ifgr) == -1)
		err(1," SIOCAIFGROUP");
@


1.225
log
@use strtonum() instead of atoi().  idea from Vladimir Kirillov, but had
to rewrite it because it was another mangled diff in mail.  When will
people learn that the tabs and spaces are important?
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.224 2009/12/09 21:21:57 deraadt Exp $	*/
d658 1
a658 2
			bridge_rule(argc, argv, -1);
			return;
@


1.224
log
@off by one in carp configuration; found by parfait, ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.223 2009/11/22 22:00:24 claudio Exp $	*/
d1716 1
d1728 3
a1730 3
		chan = atoi(val);
		if (chan < 1 || chan > 256) {
			warnx("invalid channel: %s", val);
@


1.223
log
@Merge brconfig into ifconfig. It is annoying that it is impossible to do
ifconfig bridge0 add em0 add gif0 add vether0 up
instead you need to
ifconfig bridge0 create
brconfig bridge0 add em0 add gif0 add vether0 up
This is working for everything now but we may do some changes when needed.
Manpages and startup scripts are following soon.
OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.222 2009/11/22 18:45:19 claudio Exp $	*/
d3644 2
a3645 1
		if (i > CARP_MAXNODES)
@


1.222
log
@Fix ifconfig -a vs. ifconfig -A and make ifconfig without any arg behave
like ifconfig -a by setting the aflag to 1. Found with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.221 2009/11/21 14:09:41 claudio Exp $	*/
d107 2
d329 4
a347 6
#endif /* SMALL */
	{ "vlan",	NEXTARG,	0,		setvlantag },
	{ "vlanprio",	NEXTARG,	0,		setvlanprio },
	{ "vlandev",	NEXTARG,	0,		setvlandev },
	{ "-vlandev",	1,		0,		unsetvlandev },
#ifndef SMALL
d395 48
a465 7
#ifndef SMALL
	{ "flowsrc",	NEXTARG,	0,		setpflow_sender },
	{ "-flowsrc",	1,		0,		unsetpflow_sender },
	{ "flowdst", 	NEXTARG,	0,		setpflow_receiver },
	{ "-flowdst", 1,		0,		unsetpflow_receiver },
	{ "-inet6",	IFXF_NOINET6,	0,		setifxflags } ,
#endif
d655 7
d793 1
d795 3
a2618 4
#define	IFFBITS \
"\020\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5POINTOPOINT\6NOTRAILERS\7RUNNING\10NOARP\
\11PROMISC\12ALLMULTI\13OACTIVE\14SIMPLEX\15LINK0\16LINK1\17LINK2\20MULTICAST"

d2704 1
a2704 1
	if (ioctl(s, SIOCGIFPRIORITY, &ifrdesc) == 0)
a2705 1

d2817 3
@


1.221
log
@Add new option tunneldomain to ifconfig to specify the routing table
to be used for sending out gre/gif encoded packets. OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.220 2009/06/19 14:05:32 henning Exp $	*/
d518 2
a519 1
		printif(NULL, ifaliases);
d664 1
a664 1
		printif(ifr.ifr_name, 1);
@


1.220
log
@after long discussion with many...
ifconfig <if> inet6 used to print all inet6 addresses, and last not least
the installer relies on that behaviour. so don't. to turn inet6 on again
you have to assign any inet6 address or run rtsol.
nobody happy about this asymmetry, but that is the best we could come up
with for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.219 2009/06/14 00:16:50 dlg Exp $	*/
d174 1
d372 1
d2606 1
a2606 1
	printf("\tphysical address inet%s %s --> %s\n", ver,
d2608 5
d3020 16
@


1.219
log
@enable support for deferring the packet that creates a state so that your
sync peers are able to get the states before the replies. previously there
was a race where the reply could hit a partner firewall before it had the
state for it, which caused the reply to get processed by the ruleset which
probably would drop it.

this behaviour is off by default because it does delay packets, which is
only wanted in active-active firewalls or when an upstream router is slow
to learn that you're moved the active member of the pfsync cluster. it also
uses memory keeping the packets in the kernel.

use "ifconfig pfsync0 defer" to enable it, "ifconfig pfsync0 -defer" to
disable.

tested by sthen@@ who loves it. he's got manpage changes coming up for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.218 2009/06/11 20:15:28 chl Exp $	*/
d602 1
a602 3
	if (argc == 0 && af == AF_INET6)
		noprint = 1;	/* handles "ifconfig <if> inet6" */
	if (af == AF_INET6)
@


1.218
log
@remove unused variable

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.217 2009/06/05 00:06:52 claudio Exp $	*/
d216 1
d365 2
d3729 16
d3760 2
a3761 1
		printf("maxupd: %d\n", preq.pfsyncr_maxupdates);
@


1.217
log
@Make it possible to bind an interface to a rdomain. Manpage will follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.216 2009/06/04 19:07:21 henning Exp $	*/
a4660 1
	u_char *cp;
@


1.216
log
@allow IPvShit to be turned off completely per-interface.
ifconfig em0 -inet6
deletes all v6 addresses including link-local and prevents new ones from
being added.
ifconfig em0 inet6 <addr>
re-enables v6, brings the link local back and adds optional <addr>
ok theo reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.215 2009/04/27 22:52:55 deraadt Exp $	*/
d124 1
d237 1
d389 1
d745 4
a748 1

d2627 2
d4656 18
@


1.215
log
@let vlan functionality make it into the -DSMALL ifconfig binary
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.214 2009/02/16 20:04:12 canacar Exp $	*/
d145 1
d415 1
d506 1
d595 6
d656 1
a656 1
	if (argc == 0 && actions == 0) {
d1123 23
@


1.214
log
@Allow username and password to be up to 255 characters in length.
Tested by many, thanks.
Put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.213 2009/02/15 08:34:36 damien Exp $	*/
d337 1
d342 1
d2610 1
d2612 1
d3119 1
d3246 1
@


1.213
log
@make "ifconfig if0 chan" list the channels supported by the device.
add "ifconfig if0 scan" to scan for access points or to list known
stations in Host AP mode.
remove the [-]wmm command while i'm here.  QoS is mandatory with
802.11n so there's not much point into making it an option.
fix parsing of the "powersave" command too.

discussed with deraadt@@
man page hints from jmc@@
display hints from sobrado@@
"i like it" cnst@@, grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.212 2009/02/13 17:24:54 damien Exp $	*/
d229 1
a229 1
void	sppp_printproto(const char *, struct sauth *);
d3952 11
d3965 3
a3967 2
	struct spppreq spr;
	struct sauth *auth;
a3968 2
	spppinfo(&spr);
	auth = d == 0 ? &spr.defs.myauth : &spr.defs.hisauth;
d3970 1
a3970 1
		auth->proto = PPP_PAP;
d3972 1
a3972 1
		auth->proto = PPP_CHAP;
d3974 1
a3974 1
		auth->proto = 0;
d3978 1
a3978 1
	spr.cmd = SPPPIOSDEFS;
d3980 1
a3980 1
		err(1, "SIOCSIFGENERIC(SPPPIOSDEFS)");
d3992 3
a3994 2
	struct spppreq spr;
	struct sauth *auth;
d3996 1
a3996 3
	spppinfo(&spr);
	auth = d == 0 ? &spr.defs.myauth : &spr.defs.hisauth;
	if (auth->proto == 0)
d3998 1
a3998 1
	if (strlcpy((char *)auth->name, val, AUTHNAMELEN) >= AUTHNAMELEN)
d4001 1
a4001 1
	spr.cmd = SPPPIOSDEFS;
d4003 1
a4003 1
		err(1, "SIOCSIFGENERIC(SPPPIOSDEFS)");
d4015 3
a4017 2
	struct spppreq spr;
	struct sauth *auth;
d4019 1
a4019 3
	spppinfo(&spr);
	auth = d == 0 ? &spr.defs.myauth : &spr.defs.hisauth;
	if (auth->proto == 0)
d4021 1
a4021 1
	if (strlcpy((char *)auth->secret, val, AUTHKEYLEN) >= AUTHKEYLEN)
d4024 1
a4024 1
	spr.cmd = SPPPIOSDEFS;
d4026 1
a4026 1
		err(1, "SIOCSIFGENERIC(SPPPIOSDEFS)");
d4038 1
a4038 2
	struct spppreq spr;
	struct sauth *auth;
d4041 3
a4043 3
	spppinfo(&spr);
	auth = &spr.defs.hisauth;
	if (auth->proto == 0)
d4053 1
a4053 1
		auth->flags &= ~flag;
d4055 1
a4055 1
		auth->flags |= flag;
d4057 1
a4057 1
	spr.cmd = SPPPIOSDEFS;
d4059 1
a4059 1
		err(1, "SIOCSIFGENERIC(SPPPIOSDEFS)");
d4069 1
a4069 1
sppp_printproto(const char *name, struct sauth *auth)
d4086 3
a4088 1
		printf("%sname \"%.*s\" ", name, AUTHNAMELEN, auth->name);
d4095 1
d4101 1
a4101 1
	if (ioctl(s, SIOCGIFGENERIC, &ifr) == -1)
d4103 2
d4126 5
a4130 3
	sppp_printproto("auth", &spr.defs.myauth);
	sppp_printproto("peer", &spr.defs.hisauth);
	if (spr.defs.hisauth.flags & AUTHFLAG_NOCALLOUT)
d4132 1
a4132 1
	if (spr.defs.hisauth.flags & AUTHFLAG_NORECHALLENGE)
@


1.212
log
@Change ifconfig wpaakms default setting to `psk' instead of `psk,802.1x'.
Some supplicants will autoselect 802.1X without giving users the
possibility to choose between PSK or 802.1X.

Similarly, no longer announce `PSK with SHA-256 based KDF' AKMP (defined
in Draft 802.11w) by default in the RSN IE of beacons and probe responses
as it confuses some broken supplicants.  This kind of sacrifies security
for interoperability with shitty (but unfortunately widespread) clients
that do not follow the 802.11 standard properly.
This fixes associations from Intel PROSet on XP and also reportedly fixes
some Mac OS clients.  I will likely make `psk-sha256' configurable through
ifconfig wpaakms after the 4.5 release.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.211 2009/02/06 22:07:04 grange Exp $	*/
d133 2
a134 1
int	shownet80211flag;
a153 1
void	setifwmm(const char *, int);
d161 1
a304 2
	{ "wmm",	1,		0,		setifwmm },
	{ "-wmm",	0,		0,		setifwmm },
d315 1
d317 1
a317 1
	{ "-powersave",	0,		0,		setifpowersave },
d459 1
a1451 12
setifwmm(const char *val, int d)
{
	struct ieee80211_wmmparams wmm;

	(void)strlcpy(wmm.i_name, name, sizeof(wmm.i_name));
	wmm.i_enabled = d;
	if (ioctl(s, SIOCS80211WMMPARMS, (caddr_t)&wmm) < 0)
		err(1, "SIOCS80211WMMPARMS");
}

/* ARGSUSED */
void
d1623 1
a1623 1
		if (shownet80211flag)
d1625 1
a1625 1
		shownet80211flag = 1;
d1632 1
a1632 1
		if (chan < 0 || chan > 0xffff) {
d1644 9
d1724 1
a1724 1
	if (val) {
d1730 1
a1730 1
	power.i_enabled = d;
d1757 1
a1757 1
	int ibssid, itxpower, iwmm, iwpa;
a1764 1
	struct ieee80211_wmmparams wmm;
a1800 4
	memset(&wmm, 0, sizeof(wmm));
	strlcpy(wmm.i_name, name, sizeof(wmm.i_name));
	iwmm = ioctl(s, SIOCG80211WMMPARMS, &wmm);

d1807 1
a1807 2
	    ichan == 0 || ibssid == 0 || iwmm == 0 || iwpa == 0 ||
	    itxpower == 0)
d1822 1
a1822 1
	    channel.i_channel != (u_int16_t)-1)
a1931 2
	if (iwmm == 0 && wmm.i_enabled)
		fputs(" wmm", stdout);
d1948 3
a1950 1
	if (shownet80211flag)
d1952 29
@


1.211
log
@Remove bogus casts of integer constants SPPPIO[GS]DEFS to caddr_t
and fix typo while here.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.210 2008/12/15 15:50:30 fgsch Exp $	*/
d1520 1
a1520 1
			rval |= IEEE80211_WPA_AKM_IEEE8021X;
d1931 1
a1931 1
		if (wpa.i_akms & IEEE80211_WPA_AKM_IEEE8021X)
@


1.210
log
@remove unused vars; damien@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.209 2008/12/12 22:09:26 claudio Exp $	*/
d3925 1
a3925 1
	spr->cmd = (int)SPPPIOGDEFS;
d3947 1
a3947 1
	spr.cmd = (int)SPPPIOSDEFS;
d3971 1
a3971 1
	spr.cmd = (int)SPPPIOSDEFS;
d3995 1
a3995 1
	spr.cmd = (int)SPPPIOSDEFS;
d4029 1
a4029 1
	spr.cmd = (int)SPPPIOSDEFS;
d4069 1
a4069 1
	spr.cmd = (int)SPPPIOGDEFS;
@


1.209
log
@ifconfig(8) part to make it possible to set an interface priority.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.208 2008/11/24 04:30:32 stevesk Exp $	*/
a3742 1
	const char *errmsg = NULL;
a4225 1
	u_char *cp;
@


1.208
log
@remove trailing "\n" from errx()
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.207 2008/11/17 22:23:14 mpf Exp $	*/
d233 1
d321 1
d730 1
d2584 3
d4221 19
@


1.207
log
@Fix printing of partner link aggregation group ID.
OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.206 2008/09/30 13:11:48 deraadt Exp $	*/
d1612 1
a1612 1
			errx(1, "wpapsk: invalid pre-shared key\n");
@


1.206
log
@compress powersleep commands into one; ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.205 2008/09/09 20:45:23 reyk Exp $	*/
d4185 4
d4191 1
a4191 2
			    lp->actor_prio,
			    ether_ntoa((struct ether_addr*)lp->actor_mac),
d4197 1
@


1.205
log
@fix printing by group name (eg. ifconfig em), do not abort in the
initial getinfo(), and remove a few superfluous warnings there.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.204 2008/09/09 13:56:38 henning Exp $	*/
a162 1
void	setifpowersavesleep(const char *, int);
d315 1
a315 1
	{ "powersave",	1,		0,		setifpowersave },
a316 1
	{ "powersavesleep", NEXTARG,	0,		setifpowersavesleep },
d1715 1
d1723 4
a1726 16
	power.i_enabled = d;
	if (ioctl(s, SIOCS80211POWER, (caddr_t)&power) == -1)
		warn("SIOCS80211POWER");
}

/* ARGSUSED */
void
setifpowersavesleep(const char *val, int d)
{
	struct ieee80211_power power;
	const char *errmsg = NULL;

	(void)strlcpy(power.i_name, name, sizeof(power.i_name));
	if (ioctl(s, SIOCG80211POWER, (caddr_t)&power) == -1) {
		warn("SIOCG80211POWER");
		return;
d1729 1
a1729 4
	power.i_maxsleep = strtonum(val, 0, INT_MAX, &errmsg);
	if (errmsg)
		errx(1, "powersavesleep %s: %s", val, errmsg);

@


1.204
log
@welcome pflow(4), a netflow v5 compatible flow export interface.
flows export data gathered from pf states.
initial implementation by Joerg Goltermann <jg@@osn.de>, guidance and many
changes by me. 'put it in' theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.203 2008/09/07 02:22:34 deraadt Exp $	*/
d587 1
a587 2
		if (getinfo(&ifr, create) < 0)
			exit(1);
d707 2
d712 1
a712 2
		if (!create) {
			warn("SIOCGIFFLAGS");
a713 1
		}
a715 1
			warn("SIOCGIFFLAGS");
d718 1
a718 2
		if (ioctl(s, SIOCGIFFLAGS, (caddr_t)ifr) < 0) {
			warn("SIOCGIFFLAGS");
a719 1
		}
d722 1
a722 2
	if (ioctl(s, SIOCGIFMETRIC, (caddr_t)ifr) < 0) {
		warn("SIOCGIFMETRIC");
d724 1
a724 1
	} else
@


1.203
log
@Allow some set-style commands to have zero arguments.  If there is an
argument after that command, check if it is a keyword, and if it is,
that means the original command really has no argument. Get it?
Now.. replace -m with media (no options), and -M with chan (no options).
Try 'ifconfig -a media chan' on a wireless & ethernet machine after this.
ok henning, reyk, thanks for the comments from others
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.202 2008/07/17 08:14:24 sthen Exp $	*/
d82 1
d237 8
d407 6
d2610 1
d3692 118
@


1.202
log
@Pasto in error message for setspppkey()
ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.201 2008/06/26 05:42:06 ray Exp $	*/
a125 2
int	mflag;
int	net80211flag;
d131 3
d255 1
d257 3
a259 2
#define	NEXTARG		0xffffff
#define NEXTARG2	0xfffffe
d305 1
a305 1
	{ "chan",	NEXTARG,	0,		setifchan },
d387 1
a387 1
	{ "media",	NEXTARG,	A_MEDIA,	setmedia },
d475 3
a482 2
	int aflag = 0;
	int ifaliases = 0;
a509 6
			case 'm':
				mflag = 1;
				break;
			case 'M':
				net80211flag = 1;
				break;
d541 1
a541 1
		if (argc > 0 || mflag || aflag)
a552 6
	if (aflag) {
		if (argc > 0)
			usage(0);
		printif(NULL, ifaliases);
		exit(0);
	}
a553 4
	if (argc == 0) {
		printif(ifr.ifr_name, 1);
		exit(0);
	}
d570 5
a574 3
	create = (argc > 0) && strcmp(argv[0], "destroy") != 0;
	if (getinfo(&ifr, create) < 0)
		exit(1);
d588 19
a606 1
			if (p->c_parameter == NEXTARG) {
d612 1
d621 2
a622 1
			} else
d624 2
a625 1
			actions |= p->c_action;
d630 5
d816 2
d1622 6
d1961 1
a1961 1
	if (net80211flag)
d2110 1
a2110 1
		err(1, "SIOCSIFMEDIA");
d2119 7
d2664 1
a2664 1
	if (mflag) {
d4089 1
a4089 1
		if (mflag) {
d4322 1
a4322 1
	    "usage: ifconfig [-AaCm] [interface] [address_family] "
@


1.201
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.200 2008/06/15 06:56:09 mpf Exp $	*/
d3844 1
a3844 1
		errx(1, "setspppname");
@


1.200
log
@Add 802.3ad LACP support for trunk(4).
Implementation from NetBSD. Ported via FreeBSD's version in trunk^Wlagg(4).
This is still work in progress.  Tested with a HP ProCurve 3500.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.199 2008/06/14 21:46:22 reyk Exp $	*/
a48 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.199
log
@add carppeer; an option to specify a different multicast address or
even the unicast address of the remote carp peer. this especially
helps when the multicast carp advertisements are causing problems in
the network (some crappy switches don't do well with multicast), there
are conflicts with VRRP, or the policy of the network does not allow
multicast (most Internet eXchange points didn't allow carped OpenBGP
routers because of the multicast advertisements).

discussed with many
ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.198 2008/06/13 06:58:20 reyk Exp $	*/
d4016 1
d4034 2
d4047 11
@


1.198
log
@INADDR_PFSYNC_GROUP is defined as network byte order in the kernel but
as host byte order in userland. ifconfig didn't get this and always printed
the pfsync syncpeer on little endian machines because the check to prevent
printing the default address assumed the wrong byte order.

ok claudio@@ rainer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.197 2008/05/06 13:33:50 pyr Exp $	*/
d205 2
d338 2
d3203 1
d3220 6
d3233 1
a3233 1
			    "advskew %u\n", state,
d3236 2
a3237 1
		    	    carpr.carpr_advbase, carpr.carpr_advskews[0]);
d3241 1
a3241 1
				    " balancing %s\n",
d3244 1
a3244 1
				    carpr.carpr_advbase, balmode);
d3339 51
@


1.197
log
@bring in the mpe interface - for ``MPLS Provider Edge'' - this is a work
in progress and some bits need to be cleaned up but will be in-tree for
convenience.

ok claudio@@, norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.196 2008/05/06 12:13:57 markus Exp $	*/
d3583 1
a3583 1
		if (preq.pfsyncr_syncpeer.s_addr != INADDR_PFSYNC_GROUP)
@


1.196
log
@print IN6_IFF_AUTOCONF flag, too; ok henning some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.195 2008/04/16 18:32:15 damien Exp $	*/
d102 2
d194 1
d199 1
d329 1
d2566 1
d3035 29
@


1.195
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.194 2008/03/29 18:56:43 damien Exp $	*/
d2821 2
@


1.194
log
@fix a free(NULL) in setcarp_nodes().

ok mpf@@, chl@@
"i agree with the diagnosis" oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.193 2008/02/05 22:57:30 mpf Exp $	*/
d156 7
d293 10
a1311 1
/* ARGSUSED */
d1418 178
d1715 18
d1735 2
a1736 1
	int len, i, nwkey_verbose, inwid, inwkey, ichan, ipwr, ibssid, itxpower;
d1739 1
d1744 2
d1761 4
d1781 8
d1790 3
a1792 2
	if (inwid == 0 || inwkey == 0 || ipwr == 0 ||
	    ichan == 0 || ibssid == 0 || itxpower == 0)
d1885 35
d2028 1
@


1.193
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.192 2007/11/27 16:21:02 chl Exp $	*/
d3092 1
a3092 1
	char *str;
d3105 2
a3106 2
	str = strdup(val);
	if (str == NULL)
d3109 2
a3110 1
	for (i = 0; (str = strtok(str, ",")) != NULL; str = NULL) {
d3124 1
a3124 1
		i++;
d3126 1
a3126 1
	free(str);
@


1.192
log
@fix format strings

ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.191 2007/11/27 13:15:42 chl Exp $	*/
d199 2
a200 1
void	setcarpnodes(const char *, int);
d318 2
a319 1
	{ "carpnodes",	NEXTARG,	0,		setcarpnodes },
d2890 1
d2895 1
a2895 1
	const char *state;
d2908 5
d2926 2
a2927 1
				printf("\tcarp: carpdev %s advbase %d\n",
d2930 1
a2930 1
				    carpr.carpr_advbase);
d3090 1
a3090 1
setcarpnodes(const char *val, int d)
d3126 25
@


1.191
log
@fix format strings

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.190 2007/11/22 01:21:40 mpf Exp $	*/
d2911 2
a2912 2
			printf("\tcarp: %s carpdev %s vhid %d advbase %d "
			    "advskew %d\n", state,
d2923 1
a2923 1
			printf("\t\tstate %s vhid %d advskew %d\n", state,
@


1.190
log
@Factor out the virtual host portion of carp into a separate struct
that is kept in a list per carp interface.  This is the huge first
step necessary to make carp load balancing nice and easy. One carp
interface can now contain up to 32 virtual host instances.
This doesn't do anything useful yet, but here is how an ifconfig
for multiple entries now looks like:

# ifconfig carp2 carpnodes 5:0,6:100 192.168.5.88

carp2: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        lladdr 00:00:5e:00:01:05
        carp: carpdev sis0 advbase 1
                state MASTER vhid 5 advskew 0
                state BACKUP vhid 6 advskew 100
        groups: carp
        inet 192.168.5.88 netmask 0xffffff00 broadcast 192.168.5.255

OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.189 2007/10/31 21:13:41 mikeb Exp $	*/
d3108 1
a3108 1
			errx(1, "vhid %s: value too large", vhid);
d3110 1
a3110 1
			errx(1, "advskew %s: value too large", advskew);
@


1.189
log
@Don't leak potentially secret authname through ioctl interface.

Suggestions from mpf@@ and canacar@@

ok deraadt mpf canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.188 2007/10/09 21:41:54 joel Exp $	*/
d199 1
d317 1
d2894 1
d2902 5
a2906 2
	if (carpr.carpr_vhid > 0) {
		if (carpr.carpr_state > CARP_MAXSTATE)
d2909 17
a2925 6
			state = carp_states[carpr.carpr_state];

		printf("\tcarp: %s carpdev %s vhid %d advbase %d advskew %d\n",
		    state, carpr.carpr_carpdev[0] != '\0' ?
		    carpr.carpr_carpdev : "none", carpr.carpr_vhid,
		    carpr.carpr_advbase, carpr.carpr_advskew);
d2966 2
a2967 1
	carpr.carpr_vhid = vhid;
d2991 1
a2991 1
	carpr.carpr_advskew = advskew;
d3075 42
@


1.188
log
@Fix range check for carp vhid: vhid 0 isn't valid
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.187 2007/09/02 15:19:23 deraadt Exp $	*/
d3455 2
a3456 1
	printf("%sname \"%.*s\" ", name, AUTHNAMELEN, auth->name);
@


1.187
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.186 2007/08/25 20:05:30 henning Exp $	*/
d2939 1
a2939 1
	vhid = strtonum(val, 0, 255, &errmsg);
@


1.186
log
@missing free, Igor Zinovik <zinovik@@cs.karelia.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.185 2007/07/31 06:37:48 pyr Exp $	*/
d899 1
a899 1
	buf = malloc(ifcr.ifcr_total * IFNAMSIZ);
d2310 1
a2310 1
	media_list = (int *)malloc(ifmr.ifm_count * sizeof(int));
@


1.185
log
@When setting the vlandevice without specifying a tag, infer the tag
from the interface name, this allows constructs like:
	ifconfig vlan15 vlandev smth0

ok reyk@@, ``makes sense'' henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.184 2007/07/30 14:13:29 pyr Exp $	*/
d3868 2
@


1.184
log
@strlen returns size_t.
ok henning, mbalmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.183 2007/07/30 12:34:30 pyr Exp $	*/
d2840 4
a2843 4
	struct vlanreq vreq;

	if (!__have_tag)
		errx(1, "must specify both vlan tag and device");
d2852 9
a2860 1
	vreq.vlr_tag = __tag;
@


1.183
log
@avoid segfault when empty string is passed as interface name.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.182 2007/06/19 06:24:28 pyr Exp $	*/
d774 2
a775 1
	int nlen = 0, count = 0, noinet = 1;
@


1.182
log
@Allow IPv6 addresses to use the CIDR notation too, no need for separate
prefixlen specification when using this form.
man page bits by jmc.

ok henning@@, ``looks sane'' djm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.181 2007/06/14 18:31:50 reyk Exp $	*/
d780 1
a780 1
		if (!isdigit(oname[nlen - 1]))	/* is it a group? */
d791 1
a791 1
			if (isdigit(oname[nlen - 1])) {
@


1.181
log
@Add a new "rtlabel" option to ifconfig. It allows to specify a route label
which will be used for new interface routes. For example,
	ifconfig em0 10.1.1.0 255.255.255.0 rtlabel RING_1
will set the new interface address and attach the route label RING_1 to
the corresponding route.

manpage bits from jmc@@
ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.180 2007/06/13 06:46:26 henning Exp $	*/
d3723 1
d3729 11
@


1.180
log
@allow IPv4 addresses to be specified in CIDR notation, no need for seperate
mask in that case. initially from rivo nurges <rix@@estpak.ee>, but changed
quite a bit. this has annoyed me so long that I wonder why I hadn't fixed
that earlier... input & ok markus deraadt, manpage also jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.179 2007/06/05 21:14:07 kurt Exp $	*/
d143 1
d302 2
d945 13
@


1.179
log
@remove support for ipx. okay claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.178 2007/05/26 01:02:53 krw Exp $	*/
d3583 1
a3583 1
	struct sockaddr_in *sin = sintab[which];
d3586 2
d3589 1
d3594 9
a3602 1
	if (inet_aton(s, &sin->sin_addr) == 0) {
@


1.178
log
@When the SIOCGIFMEDIA ioctl fails, don't report a problem with
'SGIOCGIFMEDIA'.

Noticed by Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.177 2006/11/15 01:53:00 itojun Exp $	*/
a97 4
#define	IPXIP
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>

a122 1
int	ipx_type = IPX_ETHERTYPE_II;
a162 1
void	setipxframetype(const char *, int);
a302 5
	{ "802.2",	IPX_ETHERTYPE_8022,	0,	setipxframetype },
	{ "802.2tr",	IPX_ETHERTYPE_8022TR, 0,	setipxframetype },
	{ "802.3",	IPX_ETHERTYPE_8023,	0,	setipxframetype },
	{ "snap",	IPX_ETHERTYPE_SNAP,	0,	setipxframetype },
	{ "EtherII",	IPX_ETHERTYPE_II,	0,	setipxframetype },
a413 2
void	ipx_status(int);
void	ipx_getaddr(const char *, int);
a439 2
	{ "ipx", AF_IPX, ipx_status, ipx_getaddr, NULL,
	    SIOCDIFADDR, SIOCAIFADDR, C(ridreq), C(addreq) },
d607 1
a607 14
	switch (af) {
	case AF_IPX:
		if (setipdst) {
			struct ipxip_req rq;
			int size = sizeof(rq);

			rq.rq_ipx = addreq.ifra_addr;
			rq.rq_ip = addreq.ifra_dstaddr;

			if (setsockopt(s, 0, SO_IPXIP_ROUTE, &rq, size) < 0)
				warn("encapsulation routing");
		}
		break;
	case AF_APPLETALK:
a608 2
		break;
	}
a2681 73
/* ARGSUSED */
void
setipxframetype(const char *vname, int type)
{
	struct  sockaddr_ipx	*sipx;

	ipx_type = type;
	getsock(AF_IPX);
	if (s < 0) {
		if (errno == EPROTONOSUPPORT)
			return;
		err(1, "socket");
	}
	memset(&ifr, 0, sizeof(ifr));
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	sipx = (struct sockaddr_ipx *)&addreq.ifra_addr;
	sipx->sipx_type = ipx_type;
}

void
ipx_status(int force)
{
	struct sockaddr_ipx *sipx;
	struct frame_types {
		int	type;
		char	*name;
	} *p, frames[] = {
		{ IPX_ETHERTYPE_8022, "802.2" },
		{ IPX_ETHERTYPE_8022TR, "802.2tr" },
		{ IPX_ETHERTYPE_8023, "802.3" },
		{ IPX_ETHERTYPE_SNAP, "SNAP" },
		{ IPX_ETHERTYPE_II,  "EtherII" },
		{ 0, NULL }
	};

	getsock(AF_IPX);
	if (s < 0) {
		if (errno == EPROTONOSUPPORT)
			return;
		err(1, "socket");
	}
	memset(&ifr, 0, sizeof(ifr));
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFADDR, (caddr_t)&ifr) < 0) {
		if (errno == EADDRNOTAVAIL || errno == EAFNOSUPPORT) {
			if (!force)
				return;
			memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
		} else
			warn("SIOCGIFADDR");
	}
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	sipx = (struct sockaddr_ipx *)&ifr.ifr_addr;
	printf("\tipx %s ", ipx_ntoa(sipx->sipx_addr));
	if (flags & IFF_POINTOPOINT) { /* by W. Nesheim@@Cornell */
		if (ioctl(s, SIOCGIFDSTADDR, (caddr_t)&ifr) < 0) {
			if (errno == EADDRNOTAVAIL)
			    memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
			else
			    warn("SIOCGIFDSTADDR");
		}
		(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
		sipx = (struct sockaddr_ipx *)&ifr.ifr_dstaddr;
		printf("--> %s ", ipx_ntoa(sipx->sipx_addr));
	}

	for (p = frames; p->name && p->type != sipx->sipx_type; p++)
		;
	if (p->name != NULL)
		printf("frame %s ", p->name);
	putchar('\n');
}

a2740 18
}

#define SIPX(x) ((struct sockaddr_ipx *) &(x))
struct sockaddr_ipx *sipxtab[] = {
SIPX(ridreq.ifr_addr), SIPX(addreq.ifra_addr),
SIPX(addreq.ifra_mask), SIPX(addreq.ifra_broadaddr)};

void
ipx_getaddr(const char *addr, int which)
{
	struct sockaddr_ipx *sipx = sipxtab[which];

	sipx->sipx_family = AF_IPX;
	sipx->sipx_len  = sizeof(*sipx);
	sipx->sipx_addr = ipx_addr(addr);
	sipx->sipx_type = ipx_type;
	if (which == MASK)
		printf("Attempt to set IPX netmask will be ineffectual\n");
@


1.177
log
@remove KAME_SCOPEID #ifdef.
__KAME__ should suffice (__KAME__ should be nuked too?)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.175 2006/09/30 23:44:17 ray Exp $	*/
d1797 1
a1797 1
				err(1, "SGIOCGIFMEDIA");
@


1.176
log
@Add -nwid command to allow wireless interfaces to not prefer a specific
access point.  Does the same as nwid "" but since we have -nwkey for nwkey
etc. this is nice for consistency.

ok mbalmer reyk
man stuff also ok jmc
@
text
@d2481 1
a2481 1
#if defined(__KAME__) && defined(KAME_SCOPEID)
d2487 1
a2487 1
#endif /* __KAME__ && KAME_SCOPEID */
a3814 10
#ifndef KAME_SCOPEID
	struct sockaddr_in6 *sin6 = sin6tab[which];

	sin6->sin6_len = sizeof(*sin6);
	if (which != MASK)
		sin6->sin6_family = AF_INET6;

	if (inet_pton(AF_INET6, s, &sin6->sin6_addr) != 1)
		errx(1, "%s: bad value", s);
#else /* KAME_SCOPEID */
a3837 1
#endif /* KAME_SCOPEID */
@


1.175
log
@Don't use uninitialized variable.

From Peter Philipp <peter underscore philipp at freenet dot de>.

OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.174 2006/08/29 17:22:00 henning Exp $	*/
d284 1
d1311 9
a1319 3
	len = sizeof(nwid.i_nwid);
	if (get_string(val, NULL, nwid.i_nwid, &len) == NULL)
		return;
@


1.174
log
@allow a numeric argument to "carpdemote" to in-/decrease the demotion
counter by more than one. manpage help by jmc, ok mcbride mpf deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.173 2006/08/18 08:21:08 deraadt Exp $	*/
d1390 1
a1390 1
			len = sizeof(keybuf[i]);
@


1.173
log
@make non-root -M use not cut ifconfig output; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.172 2006/08/02 07:38:33 grunk Exp $	*/
d764 1
d773 7
d781 1
a781 1
		neg = -1;
@


1.172
log
@remove trailing blanks in output of ieee80211_status() as well.

help from claudio@@, and ok claudio@@ mickey@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.171 2006/07/25 13:59:17 grunk Exp $	*/
d1675 1
a1675 1
	int i, ret, down = 0;
a1683 1
	ret = 1;
d1685 3
a1687 1
	if (ioctl(s, SIOCS80211SCAN, (caddr_t)&ifr) != 0)
d1689 1
a1710 2
	ret = 0;

a1713 3

	if (ret != 0)
		exit(1);
@


1.171
log
@ifconfig output contained trailing whites in inet and groups: lines
fix that by rearranging spaces in printf format strings

ok claudio@@ mpf@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.170 2006/06/27 21:47:10 reyk Exp $	*/
d1558 1
a1558 1
		fputs("\tieee80211: ", stdout);
d1567 1
a1567 1
		fputs("nwid ", stdout);
a1568 1
		putchar(' ');
d1573 1
a1573 1
		printf("chan %u ", channel.i_channel);
d1580 1
a1580 1
		printf("bssid %s ", ether_ntoa(&ea));
d1587 1
a1587 1
				printf("%u%% ", IEEE80211_NODEREQ_RSSI(&nr));
d1589 1
a1589 1
				printf("%udB ", nr.nr_rssi);
d1594 1
a1594 1
		fputs("nwkey ", stdout);
d1601 1
a1601 1
			fputs("<not displayed> ", stdout);
a1646 1
			putchar(' ');
d1651 1
a1651 1
		printf("powersave on (%dms sleep) ", power.i_maxsleep);
d1654 1
a1654 1
		printf("%ddBm %s", txpower.i_val,
d1656 1
a1656 1
		    "(auto) " : "");
d1659 2
a1660 1
	    ifr.ifr_flags)
d1662 1
@


1.170
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.169 2006/06/27 20:55:51 reyk Exp $	*/
d2418 1
a2418 1
	printf("\tinet %s ", inet_ntoa(sin->sin_addr));
d2437 1
a2437 1
		printf("--> %s ", inet_ntoa(sin->sin_addr));
d2439 1
a2439 1
	printf("netmask 0x%x ", ntohl(netmask.sin_addr.s_addr));
d2451 1
a2451 1
			printf("broadcast %s", inet_ntoa(sin->sin_addr));
d3933 1
a3933 1
				printf("\tgroups: ");
d3935 1
a3935 1
			printf("%s ", ifg->ifgrq_group);
@


1.169
log
@add the net80211 hostap options "nwflag hidenwid" for hidden SSID mode
and "nwflag nobridge" to prevent inter-station communications.
"hidenwid" will also work with wi(4) to replace the old -E 3 option of
wicontrol.

ok damien@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.168 2006/06/23 21:41:30 reyk Exp $	*/
d1585 1
a1585 1
		strlcpy(nr.nr_ifname, name, sizeof(nr.nr_ifname));		
@


1.168
log
@allow ifconfig to print the signal quality of the current ap. if the
driver reports a RSSI Max value, print the signal quality as a
percentage instead of the arbitrary "dB" value, this also applies to
the output of ifconfig -M (scan/node list).

ok damien@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.167 2006/06/15 16:19:59 deraadt Exp $	*/
d164 2
d354 2
d1441 33
d1659 4
@


1.167
log
@unused variable, spotted by pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.166 2006/06/14 18:46:21 deraadt Exp $	*/
d1487 1
d1545 10
d1701 4
a1704 1
	printf("%udB ", nr->nr_rssi);
@


1.166
log
@unused var, wrong check for too many keys; mrd@@alkemio.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.165 2006/06/11 18:47:58 jmc Exp $	*/
a763 1
	struct ifg_attrib	*ifga;
@


1.165
log
@simplify usage(); ok krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.164 2006/06/03 14:59:44 claudio Exp $	*/
a1336 1
	char *cp = NULL;
d1374 1
a1374 1
			if (cp != NULL) {
@


1.164
log
@Do not set newaddr to 1 if "delete" was specified beforhands. In this case
doalias is < 0. This fixes the problem where ifconfig em0 delete 10.0.0.1
created a 0.0.0.0/0 route entry and created a total mess because of that.
Diff from markus@@ OK beck@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.163 2006/06/02 19:53:12 mpf Exp $	*/
d3842 3
a3844 30
	    "usage: ifconfig "
	    "[interface] [address_family] [address [dest_address]]\n"
	    "\t[[-]alias] [[-]arp] [broadcast addr]\n"
	    "\t[[-]debug] [delete] [up] [down] [ipdst addr]\n"
	    "\t[tunnel src_address dest_address] [deletetunnel]\n"
	    "\t[description value] [-description] [[-]group group-name]\n"
	    "\t[[-]link0] [[-]link1] [[-]link2] [lladdr etheraddr]\n"
	    "\t[media type] [[-]mediaopt opts] [mode mode] [instance minst]\n"
	    "\t[mtu value] [metric nhops] [netmask mask] [prefixlen n]\n"
	    "\t[nwid id] [nwkey key] [nwkey persist[:key]] [-nwkey]\n"
	    "\t[bssid bssid] [-bssid] [chan n] [-chan] [txpower dBm]\n"
	    "\t[-txpower] [[-]powersave] [powersavesleep duration]\n"
#ifdef INET6
	    "\t[[-]anycast] [eui64] [pltime n] [vltime n] [[-]tentative]\n"
#endif
	    "\t[vlan vlan_tag vlandev parent_iface] [-vlandev] [vhid n]\n"
	    "\t[trunkproto proto] [[-]trunkport child-iface]\n"
	    "\t[advbase n] [advskew n] [maxupd n] [pass passphrase]\n"
	    "\t[state init | backup | master]\n"
	    "\t[syncdev iface] [-syncdev] [syncpeer peer_address] [-syncpeer]\n"
	    "\t[phase n] [range netrange] [timeslot timeslot_range]\n"
	    "\t[802.2] [802.2tr] [802.3] [snap] [EtherII]\n"
	    "\t[pppoeac access-concentrator] [-pppoeac]\n"
	    "\t[pppoesvc service] [-pppoesvc] [authproto proto]\n"
	    "\t[authname name] [authkey key] [peerproto proto]\n"
	    "\t[peername name] [peerkey key] [[-]peerflag flag]\n"
	    "       ifconfig [-AaCMm] [interface] [address_family]\n"
	    "       ifconfig -g group-name [[-]carpdemote]\n"
	    "       ifconfig interface create\n"
	    "       ifconfig interface destroy\n");
@


1.163
log
@Introduce attributes to interface groups.
As a first user, move the global carp(4) demotion counter
into the interface group. Thus we have the possibility
to define which carp interfaces are demoted together.

Put the demotion counter into the reserved field of the carp header.
With this, we can have carp act smarter if multiple errors occur.
It now always takes over other carp peers, that are advertising
with a higher demote count.  As a side effect, we can also have
group failovers without the need of running in preempt mode.
The protocol change does not break compability with older
implementations.

Collaborative work with mcbride@@

OK mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.162 2006/06/01 21:01:10 claudio Exp $	*/
d954 2
a955 1
	newaddr = 1;
@


1.162
log
@Revert last commit. Modifing a interface does a remove and then an add.
We need to figure out a better way to fix this.
Brought up by markus@@ OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.161 2006/06/01 18:54:19 beck Exp $	*/
d383 2
d464 1
d487 3
d532 7
d742 41
d3868 1
@


1.161
log
@ifconfig should be either deleting an interface address, or adding one in one
invocation, not both.

This change ensures that a delete does not also do an add.

Fixes stupid problem where deleting the last address with
ifconfig delete addr
worked differently than
ifconfig addr delete

where the first way would re-add an address of 0.0.0.0/0 after deleting
the address.

ok claudio@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.160 2006/05/17 03:29:55 reyk Exp $	*/
d632 1
a632 1
	else if (newaddr) {
@


1.160
log
@implement support for sppp(4) in ifconfig. have a look at the updated
manual pages pppoe(4) and sppp(4) for examples.

the spppcontrol(8) utility is not required anymore and will probably
be removed in the near future.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.159 2006/03/23 14:20:09 mcbride Exp $	*/
d632 1
a632 1
	if (newaddr) {
@


1.159
log
@Print the lladdr on carp interfaces.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.158 2006/03/21 14:23:29 claudio Exp $	*/
d91 2
d212 11
d344 8
d2183 1
d3294 182
d3539 1
a3539 1
	
d3787 2
a3788 1
	    "usage: ifconfig [interface] [address_family] [address [dest_address]]\n"
d3810 3
a3812 1
	    "\t[pppoesvc service] [-pppoesvc]\n"
@


1.158
log
@Correctly check for the end of the cmds table. There is no need to check for
c_func2. Until now ifconfig accepted something like ifconfig tun0 1.2.3.4
1.2.3.5 foobar without error. Additionally change the error message to
a more comprehensible message. OK markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.157 2006/03/20 20:12:45 dhill Exp $	*/
d2144 2
a2145 1
	if (sdl != NULL && sdl->sdl_type == IFT_ETHER && sdl->sdl_alen)
@


1.157
log
@Don't increment a pointer *before* testing it for NULL

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.156 2006/01/05 15:00:10 norby Exp $	*/
d544 2
a545 2
				if (p->c_func == NULL && p->c_func2)
					errx(1, "extra address not accepted");
@


1.156
log
@Make it possible to set a default vlan priority to a vlan interface.

ok claudio@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.155 2005/11/28 10:14:34 markus Exp $	*/
d3437 1
a3437 1
	bits++;
d3439 1
a3464 1
	bits++;
d3466 1
@


1.155
log
@do not overflow ifr.ifr_addr; ok mpf, henning, hshoexer, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.154 2005/11/15 00:38:34 jmc Exp $	*/
d187 1
d299 1
d2728 1
d2736 6
d2743 2
a2744 2
		printf("\tvlan: %d parent interface: %s\n",
		    vreq.vlr_tag, vreq.vlr_parent[0] == '\0' ?
d2771 24
@


1.154
log
@add "-description" to usage();
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.153 2005/11/14 15:06:09 henning Exp $	*/
a739 2
		(void) strlcpy(name, ifa->ifa_name, sizeof(name));

d743 3
d747 6
a752 2
			memset(&ifr6, 0, sizeof(ifr6));
		} else {
a753 1
			memset(&ifr, 0, sizeof(ifr));
d755 1
a755 5
#else /* INET6 */
		ifrp = &ifr;
		memset(&ifr, 0, sizeof(ifr));
#endif /* INET6 */

a756 2
		/* XXX boundary check? */
		memcpy(&ifrp->ifr_addr, ifa->ifa_addr, ifa->ifa_addr->sa_len);
@


1.153
log
@add -descr / -description to clear the interface description, noticed todd
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.152 2005/11/01 07:54:26 deraadt Exp $	*/
d3554 1
a3554 1
	    "\t[description value] [[-]group group-name]\n"
@


1.152
log
@missing freeaddrinfo(); maticd@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.151 2005/10/10 10:28:19 henning Exp $	*/
d151 1
d350 2
d904 9
@


1.151
log
@getifaddrs() slightly later in printif(), prevents possible memleak
Andrey Matveev <evol@@online.ptt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.150 2005/10/03 01:35:12 reyk Exp $	*/
d3037 2
@


1.150
log
@print all trunk flags

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.149 2005/09/15 13:52:39 pedro Exp $	*/
a710 3
	if (getifaddrs(&ifap) != 0)
		err(1, "getifaddrs");

d719 3
@


1.149
log
@Clean up compilation with -Wall, okay deraadt@@
From: Leonardo Chiquitto Filho <leonardo@@iken.com.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.148 2005/08/10 19:31:55 sturm Exp $	*/
d3311 2
a3312 3
			printf("\t\ttrunkport %s", rpbuf[i].rp_portname);
			if (rpbuf[i].rp_flags & TRUNK_PORT_MASTER)
				printf(" master");
@


1.148
log
@print session time in fixed width

ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.147 2005/06/24 15:26:33 jolan Exp $	*/
d677 1
a677 1
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
d683 1
d709 1
a709 1
	int nlen, count = 0, noinet = 1;
d1546 1
a1555 1
	ret = 1;
a1578 1

d1584 1
a1584 1
	int len, i, isap;
a3108 1
	int e;
d3569 1
a3569 1
	int			 len, cnt, n;
d3576 1
a3576 1
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
d3581 1
@


1.147
log
@err -> errx
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.146 2005/06/23 14:26:37 mickey Exp $	*/
d3167 1
a3167 1
		printf("%ld:%ld:%ld", hour, min, sec);
@


1.146
log
@iface description is not an array of ptr but rather just a string; jcs@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.145 2005/06/12 00:42:55 henning Exp $	*/
d1099 1
a1099 1
		err(1, "setifgroup: group name too long");
d1117 1
a1117 1
		err(1, "unsetifgroup: group name too long");
@


1.145
log
@let 'ifconfig <group>' work, displaying all the interfaces which are member
of the given group, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.144 2005/06/08 19:03:55 henning Exp $	*/
d2123 1
a2123 1
	char *ifdescr[IFDESCRSIZE];
@


1.144
log
@netns crap i missed earlier... damn unreliable tools
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.143 2005/05/31 20:54:38 jmc Exp $	*/
d356 2
a357 1
void	printif(struct ifreq *, int);
d508 1
a508 1
		printif(&ifr, 1);
d667 34
d702 1
a702 1
printif(struct ifreq *ifrm, int ifaliases)
d713 2
a714 3
	if (ifrm) {
		oname = strdup(ifrm->ifr_name);
		if (oname == NULL)
d717 3
@


1.143
log
@tidy up the trunk stuff;
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.142 2005/05/26 03:39:57 henning Exp $	*/
a95 4
#define	NSIP
#include <netns/ns.h>
#include <netns/ns_if.h>

d378 1
a378 4
/*
 * XNS support liberally adapted from code written at the University of
 * Maryland principally by James O'Toole and Chris Torek.
 */
a390 2
void	xns_status(int);
void	xns_getaddr(const char *, int);
a418 2
	{ "ns", AF_NS, xns_status, xns_getaddr, NULL,
	    SIOCDIFADDR, SIOCAIFADDR, C(ridreq), C(addreq) },
a577 12
	case AF_NS:
		if (setipdst) {
			struct nsip_req rq;
			int size = sizeof(rq);

			rq.rq_ns = addreq.ifra_addr;
			rq.rq_ip = addreq.ifra_dstaddr;

			if (setsockopt(s, 0, SO_NSIP_ROUTE, &rq, size) < 0)
				warn("encapsulation routing");
		}
		break;
a2519 38
void
xns_status(int force)
{
	struct sockaddr_ns *sns;

	getsock(AF_NS);
	if (s < 0) {
		if (errno == EPROTONOSUPPORT)
			return;
		err(1, "socket");
	}
	memset(&ifr, 0, sizeof(ifr));
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFADDR, (caddr_t)&ifr) < 0) {
		if (errno == EADDRNOTAVAIL || errno == EAFNOSUPPORT) {
			if (!force)
				return;
			memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
		} else
			warn("SIOCGIFADDR");
	}
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	sns = (struct sockaddr_ns *)&ifr.ifr_addr;
	printf("\tns %s ", ns_ntoa(sns->sns_addr));
	if (flags & IFF_POINTOPOINT) { /* by W. Nesheim@@Cornell */
		if (ioctl(s, SIOCGIFDSTADDR, (caddr_t)&ifr) < 0) {
			if (errno == EADDRNOTAVAIL)
			    memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
			else
			    warn("SIOCGIFDSTADDR");
		}
		(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
		sns = (struct sockaddr_ns *)&ifr.ifr_dstaddr;
		printf("--> %s ", ns_ntoa(sns->sns_addr));
	}
	putchar('\n');
}

a2651 17
}

#define SNS(x) ((struct sockaddr_ns *) &(x))
struct sockaddr_ns *snstab[] = {
SNS(ridreq.ifr_addr), SNS(addreq.ifra_addr),
SNS(addreq.ifra_mask), SNS(addreq.ifra_broadaddr)};

void
xns_getaddr(const char *addr, int which)
{
	struct sockaddr_ns *sns = snstab[which];

	sns->sns_family = AF_NS;
	sns->sns_len = sizeof(*sns);
	sns->sns_addr = ns_addr(addr);
	if (which == MASK)
		printf("Attempt to set XNS netmask will be ineffectual\n");
@


1.142
log
@remove hiding of interface family groups
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.141 2005/05/26 02:15:42 frantzen Exp $	*/
d3602 1
a3602 1
	    "       ifconfig [-aAmMC] [interface] [address_family]\n"
@


1.141
log
@disallow interface group names that end in a digit to differentiate them from
true interfaces
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.140 2005/05/25 07:40:49 reyk Exp $	*/
a3611 1
	char			 ifgroup[IFNAMSIZ];
a3634 4
	for (n = 0; name[n] < '0' || name[n] > '9'; n++)
		continue;
	strlcpy(ifgroup, name, n + 1);

d3637 1
a3637 2
		if (strcmp(ifg->ifgrq_group, "all") &&
		    strcmp(ifg->ifgrq_group, ifgroup)) {
@


1.140
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.139 2005/05/24 07:51:53 reyk Exp $	*/
d1081 3
d1098 3
@


1.139
log
@support trunk stacking (trunks as trunk ports) and some fixes

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.138 2005/05/24 02:45:18 reyk Exp $	*/
d139 1
d362 1
d403 2
d454 36
a489 23
	if (!strcmp(*argv, "-a"))
		aflag = 1;
	else if (!strcmp(*argv, "-A")) {
		aflag = 1;
		ifaliases = 1;
	} else if (!strcmp(*argv, "-ma") || !strcmp(*argv, "-am")) {
		aflag = 1;
		mflag = 1;
	} else if (!strcmp(*argv, "-mA") || !strcmp(*argv, "-Am")) {
		aflag = 1;
		ifaliases = 1;
		mflag = 1;
	} else if (!strcmp(*argv, "-m")) {
		mflag = 1;
		argc--, argv++;
		if (argc < 1)
			usage(1);
		if (strlcpy(name, *argv, sizeof(name)) >= IFNAMSIZ)
			errx(1, "interface name '%s' too long", *argv);
	} else if (!strcmp(*argv, "-C")) {
		Cflag = 1;
	} else if (*argv[0] == '-') {
		usage(0);
d1232 3
a1279 5
	/* zero out any unset keys */
	for (; i < IEEE80211_WEP_NKID; i++) {
		nwkey.i_key[i].i_keylen = 0;
		nwkey.i_key[i].i_keydat = NULL;
	}
d1423 1
a1423 1
		print_string(nwid.i_nwid, nwid.i_len);
d1501 2
a1502 2
		printf("%ddBm %s", txpower.i_val, 
		    txpower.i_mode == IEEE80211_TXPOWER_MODE_AUTO ? 
d1506 97
a2130 1
	ieee80211_status();
d2197 2
d3447 25
d3596 1
a3596 3
	    "       ifconfig -A | -Am | -a | -am [address_family]\n"
	    "       ifconfig -C\n"
	    "       ifconfig -m interface [address_family]\n"
d3711 1
@


1.138
log
@initial import of a trunking (link aggregation and link failover)
implementation. it currently supports round robin mode with link state
checking, additional modes will be added later.

ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.137 2005/05/22 00:02:28 henning Exp $	*/
d3205 1
a3205 1
	int i;
d3207 1
d3209 7
d3228 5
a3232 1
		printf("\ttrunk: trunkproto %s\n", proto);
d3245 1
a3245 7
	} else {
		strlcpy(rp.rp_ifname, name, sizeof(rp.rp_ifname));
		strlcpy(rp.rp_portname, name, sizeof(rp.rp_portname));

		if (ioctl(s, SIOCGTRUNKPORT, &rp) != 0)
			return;

a3246 1
	}
@


1.137
log
@rewrite the interface groups printing code:
don't rely on the interface's driver-name based group to be the first in
the list
don't rely on one group == only default one
do not print the "all" group
don't segfault on interfaces with no group at all
ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.136 2005/04/14 10:23:37 henning Exp $	*/
d90 1
d211 4
d328 3
d2017 1
d3147 96
d3445 1
@


1.136
log
@shave off a few bytes, alpha floppies fit again now
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.135 2005/04/12 12:15:53 markus Exp $	*/
d3358 2
a3359 1
	int			 len;
a3377 1

d3381 13
a3393 10
	if (len -= sizeof(struct ifg_req)) {
		len += sizeof(struct ifg_req);
		printf("\tgroups: ");
		ifg = ifgr.ifgr_groups;
		if (ifg) {
			len -= sizeof(struct ifg_req);
			ifg++;
		}
		for (; ifg && len >= sizeof(struct ifg_req); ifg++) {
			len -= sizeof(struct ifg_req);
d3396 2
a3398 1
	}
@


1.135
log
@lladdr w/o colon; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.134 2005/04/11 21:05:01 cloder Exp $	*/
a68 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)ifconfig.c	8.2 (Berkeley) 2/16/94";
#else
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.134 2005/04/11 21:05:01 cloder Exp $";
#endif
#endif /* not lint */
@


1.134
log
@Handle getnameinfo failure. OK niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.133 2005/04/04 16:03:02 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.133 2005/04/04 16:03:02 deraadt Exp $";
d2007 1
a2007 1
		(void)printf("\tlladdr: %s\n", ether_ntoa(
@


1.133
log
@print lladdr instead of address; pointed out by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.132 2005/03/30 02:55:37 tedu Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.132 2005/03/30 02:55:37 tedu Exp $";
d1961 3
a1963 2
	getnameinfo((struct sockaddr *)&req.addr, req.addr.ss_len,
	    psrcaddr, sizeof(psrcaddr), 0, 0, niflag);
d1973 3
a1975 2
	getnameinfo((struct sockaddr *)&req.dstaddr, req.dstaddr.ss_len,
	    pdstaddr, sizeof(pdstaddr), 0, 0, niflag);
@


1.132
log
@add lladdr command to ifconfig to set MAC address.  diffs from freebsd via
Kyunghwan KIM (prs 2117 and 2118) and Fredrik Widlund.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.131 2005/02/15 19:45:22 reyk Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.131 2005/02/15 19:45:22 reyk Exp $";
d2005 1
a2005 1
		(void)printf("\taddress: %s\n", ether_ntoa(
@


1.131
log
@add txpower support to ifconfig

ok bob@@ robert@@ danh@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.130 2005/01/20 17:47:38 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.130 2005/01/20 17:47:38 mcbride Exp $";
d162 1
d355 1
d3342 1
a3342 1
	    "\t[[-]link0] [[-]link1] [[-]link2]\n"
d3454 18
@


1.130
log
@Use syncdev instead of syncif in ifconfig, and modify ioctl struct pfsyncreq
in kernel code to match.  Brings pfsync in line with carp, vlan and pppoe
devices. Old syncif and -syncif options still work, will be removed later.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.129 2005/01/18 21:51:14 claudio Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.129 2005/01/18 21:51:14 claudio Exp $";
d173 1
d334 2
d1296 25
d1362 1
a1362 1
	int len, i, nwkey_verbose, inwid, inwkey, ichan, ipwr, ibssid;
d1368 1
d1395 4
d1401 1
a1401 1
	    ichan == 0 || ibssid == 0)
d1489 5
d3344 2
a3345 2
	    "\t[bssid bssid] [-bssid] [chan n] [-chan]\n"
	    "\t[[-]powersave] [powersavesleep duration]\n"
@


1.129
log
@Print configured timeslot mask for PDH/TDM interfaces.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.128 2005/01/18 21:43:54 claudio Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.128 2005/01/18 21:43:54 claudio Exp $";
d212 1
a212 1
void	setpfsync_syncif(const char *, int);
d214 1
a214 1
void	unsetpfsync_syncif(const char *, int);
d316 4
a319 2
	{ "syncif",	NEXTARG,	0,		setpfsync_syncif },
	{ "-syncif",	1,		0,		unsetpfsync_syncif },
d2858 1
a2858 1
setpfsync_syncif(const char *val, int d)
d2868 1
a2868 1
	strlcpy(preq.pfsyncr_syncif, val, sizeof(preq.pfsyncr_syncif));
d2876 1
a2876 1
unsetpfsync_syncif(const char *val, int d)
d2886 1
a2886 1
	bzero((char *)&preq.pfsyncr_syncif, sizeof(preq.pfsyncr_syncif));
d2977 2
a2978 2
	if (preq.pfsyncr_syncif[0] != '\0') {
		printf("\tpfsync: syncif: %s ", preq.pfsyncr_syncif);
d3314 1
a3314 1
	    "\t[syncif iface] [-syncif] [syncpeer peer_address] [-syncpeer]\n"
@


1.128
log
@Don't shift the timeslot map so that timeslot 1 ends in bit 0. E1 may need
to specify timeslot 0 and it is more intuitive.
From alex@@ Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.127 2004/12/29 19:32:34 claudio Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.127 2004/12/29 19:32:34 claudio Exp $";
d198 1
d378 1
a378 1
unsigned long get_ts_map(int ts_flag, int ts_start, int ts_stop);
d1714 37
d1978 1
@


1.127
log
@Put settimeslot() into #ifndef SMALL as it is not needed on ramdisks.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.126 2004/12/25 17:52:45 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.126 2004/12/25 17:52:45 deraadt Exp $";
d1643 6
d1683 1
d1702 1
a1702 1
			mask = 1 << (i - 1);
d1706 1
a1706 1
		mask = 1 << (ts_stop - 1);
@


1.126
log
@#ifndef SMALL throughout this, for install media; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.125 2004/12/07 20:40:18 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.125 2004/12/07 20:40:18 mcbride Exp $";
d329 1
a349 1
	{ "timeslot",	NEXTARG,	0,		settimeslot },
d1643 1
d1704 1
@


1.125
log
@Add the 'carpdev' option, to set the carp devices physical interface.
If not specified, the kernel will attempt to select the correct interface
by the subnet (this is the current behaviour).

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.124 2004/12/07 20:32:10 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.124 2004/12/07 20:32:10 mcbride Exp $";
a130 1
struct	ifaliasreq	addreq;
d138 3
d142 2
a144 1
int	ipx_type = IPX_ETHERTYPE_II;
d297 1
d324 6
a346 1
	{ "timeslot",	NEXTARG,	0,		settimeslot },
d349 1
a349 5
	{ "pppoedev",	NEXTARG,	0,		setpppoe_dev },
	{ "pppoesvc",	NEXTARG,	0,		setpppoe_svc },
	{ "-pppoesvc",	1,		0,		setpppoe_svc },
	{ "pppoeac",	NEXTARG,	0,		setpppoe_ac },
	{ "-pppoeac",	1,		0,		setpppoe_ac },
d419 1
d426 1
d568 1
d598 1
a600 1
		int ret;
d602 1
a602 1
		if ((ret = ioctl(s, rafp->af_difaddr, rafp->af_ridreq)) < 0) {
a847 46
void
settunnel(const char *src, const char *dst)
{
	struct addrinfo hints, *srcres, *dstres;
	int ecode;
	struct if_laddrreq req;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = afp->af_af;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/

	if ((ecode = getaddrinfo(src, NULL, &hints, &srcres)) != 0)
		errx(1, "error in parsing address string: %s",
		    gai_strerror(ecode));

	if ((ecode = getaddrinfo(dst, NULL, &hints, &dstres)) != 0)
		errx(1, "error in parsing address string: %s",
		    gai_strerror(ecode));

	if (srcres->ai_addr->sa_family != dstres->ai_addr->sa_family)
		errx(1,
		    "source and destination address families do not match");

	if (srcres->ai_addrlen > sizeof(req.addr) ||
	    dstres->ai_addrlen > sizeof(req.dstaddr))
		errx(1, "invalid sockaddr");

	memset(&req, 0, sizeof(req));
	(void) strlcpy(req.iflr_name, name, sizeof(req.iflr_name));
	memcpy(&req.addr, srcres->ai_addr, srcres->ai_addrlen);
	memcpy(&req.dstaddr, dstres->ai_addr, dstres->ai_addrlen);
	if (ioctl(s, SIOCSLIFPHYADDR, &req) < 0)
		warn("SIOCSLIFPHYADDR");

	freeaddrinfo(srcres);
	freeaddrinfo(dstres);
}

/* ARGSUSED */
void
deletetunnel(const char *ignored, int alsoignored)
{
	if (ioctl(s, SIOCDIFPHYADDR, &ifr) < 0)
		warn("SIOCDIFPHYADDR");
}

d1684 2
a1685 1
unsigned long get_ts_map(int ts_flag, int ts_start, int ts_stop)
d1926 1
d1930 2
a1932 1
	pppoe_status();
d2234 47
d2448 16
a2463 4
#define SIN(x) ((struct sockaddr_in *) &(x))
struct sockaddr_in *sintab[] = {
SIN(ridreq.ifr_addr), SIN(in_addreq.ifra_addr),
SIN(in_addreq.ifra_mask), SIN(in_addreq.ifra_broadaddr)};
d2465 1
d2467 1
a2467 1
in_getaddr(const char *s, int which)
d2469 1
a2469 3
	struct sockaddr_in *sin = sintab[which];
	struct hostent *hp;
	struct netent *np;
d2471 6
a2476 12
	sin->sin_len = sizeof(*sin);
	if (which != MASK)
		sin->sin_family = AF_INET;

	if (inet_aton(s, &sin->sin_addr) == 0) {
		if ((hp = gethostbyname(s)))
			memcpy(&sin->sin_addr, hp->h_addr, hp->h_length);
		else if ((np = getnetbyname(s)))
			sin->sin_addr = inet_makeaddr(np->n_net, INADDR_ANY);
		else
			errx(1, "%s: bad value", s);
	}
d2481 1
a2481 1
in_getprefix(const char *plen, int which)
d2483 7
a2489 4
	struct sockaddr_in *sin = sintab[which];
	const char *errmsg = NULL;
	u_char *cp;
	int len;
d2491 17
a2507 3
	len = strtonum(plen, 0, 32, &errmsg);
	if (errmsg)
		errx(1, "prefix %s: %s", plen, errmsg);
d2509 4
a2512 13
	sin->sin_len = sizeof(*sin);
	if (which != MASK)
		sin->sin_family = AF_INET;
	if ((len == 0) || (len == 32)) {
		memset(&sin->sin_addr, 0xff, sizeof(struct in_addr));
		return;
	}
	memset((void *)&sin->sin_addr, 0x00, sizeof(sin->sin_addr));
	for (cp = (u_char *)&sin->sin_addr; len > 7; len -= 8)
		*cp++ = 0xff;
	if (len)
		*cp = 0xff << (8 - len);
}
a2513 3
/*
 * Print a value a la the %b format of the kernel's printf
 */
d2515 1
a2515 1
printb(char *s, unsigned short v, char *bits)
d2517 1
a2517 2
	int i, any = 0;
	char c;
d2519 5
a2523 20
	if (bits && *bits == 8)
		printf("%s=%o", s, v);
	else
		printf("%s=%x", s, v);
	bits++;
	if (bits) {
		putchar('<');
		while ((i = *bits++)) {
			if (v & (1 << (i-1))) {
				if (any)
					putchar(',');
				any = 1;
				for (; (c = *bits) > 32; bits++)
					putchar(c);
			} else
				for (; *bits > 32; bits++)
					;
		}
		putchar('>');
	}
d2526 4
a2529 5
#ifdef INET6
#define SIN6(x) ((struct sockaddr_in6 *) &(x))
struct sockaddr_in6 *sin6tab[] = {
SIN6(in6_ridreq.ifr_addr), SIN6(in6_addreq.ifra_addr),
SIN6(in6_addreq.ifra_prefixmask), SIN6(in6_addreq.ifra_dstaddr)};
d2532 1
a2532 1
in6_getaddr(const char *s, int which)
d2534 1
a2534 2
#ifndef KAME_SCOPEID
	struct sockaddr_in6 *sin6 = sin6tab[which];
d2536 1
a2536 173
	sin6->sin6_len = sizeof(*sin6);
	if (which != MASK)
		sin6->sin6_family = AF_INET6;

	if (inet_pton(AF_INET6, s, &sin6->sin6_addr) != 1)
		errx(1, "%s: bad value", s);
#else /* KAME_SCOPEID */
	struct sockaddr_in6 *sin6 = sin6tab[which];
	struct addrinfo hints, *res;
	int error;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	error = getaddrinfo(s, "0", &hints, &res);
	if (error)
		errx(1, "%s: %s", s, gai_strerror(error));
	if (res->ai_addrlen != sizeof(struct sockaddr_in6))
		errx(1, "%s: bad value", s);
	memcpy(sin6, res->ai_addr, res->ai_addrlen);
#ifdef __KAME__
	if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) &&
	    *(u_int16_t *)&sin6->sin6_addr.s6_addr[2] == 0 &&
	    sin6->sin6_scope_id) {
		*(u_int16_t *)&sin6->sin6_addr.s6_addr[2] =
		    htons(sin6->sin6_scope_id & 0xffff);
		sin6->sin6_scope_id = 0;
	}
#endif /* __KAME__ */
	freeaddrinfo(res);
#endif /* KAME_SCOPEID */
}

void
in6_getprefix(const char *plen, int which)
{
	struct sockaddr_in6 *sin6 = sin6tab[which];
	const char *errmsg = NULL;
	u_char *cp;
	int len;

	len = strtonum(plen, 0, 128, &errmsg);
	if (errmsg)
		errx(1, "prefix %s: %s", plen, errmsg);

	sin6->sin6_len = sizeof(*sin6);
	if (which != MASK)
		sin6->sin6_family = AF_INET6;
	if ((len == 0) || (len == 128)) {
		memset(&sin6->sin6_addr, 0xff, sizeof(struct in6_addr));
		return;
	}
	memset((void *)&sin6->sin6_addr, 0x00, sizeof(sin6->sin6_addr));
	for (cp = (u_char *)&sin6->sin6_addr; len > 7; len -= 8)
		*cp++ = 0xff;
	if (len)
		*cp = 0xff << (8 - len);
}

int
prefix(void *val, int size)
{
	u_char *name = (u_char *)val;
	int byte, bit, plen = 0;

	for (byte = 0; byte < size; byte++, plen += 8)
		if (name[byte] != 0xff)
			break;
	if (byte == size)
		return (plen);
	for (bit = 7; bit != 0; bit--, plen++)
		if (!(name[byte] & (1 << bit)))
			break;
	for (; bit != 0; bit--)
		if (name[byte] & (1 << bit))
			return (0);
	byte++;
	for (; byte < size; byte++)
		if (name[byte])
			return (0);
	return (plen);
}
#endif /*INET6*/

void
at_getaddr(const char *addr, int which)
{
	struct sockaddr_at *sat = (struct sockaddr_at *) &addreq.ifra_addr;
	u_int net, node;

	sat->sat_family = AF_APPLETALK;
	sat->sat_len = sizeof(*sat);
	if (which == MASK)
		errx(1, "AppleTalk does not use netmasks");
	if (sscanf(addr, "%u.%u", &net, &node) != 2 ||
	    net == 0 || net > 0xffff || node == 0 || node > 0xfe)
		errx(1, "%s: illegal address", addr);
	sat->sat_addr.s_net = htons(net);
	sat->sat_addr.s_node = node;
}

/* ARGSUSED */
void
setatrange(const char *range, int d)
{
	u_int first = 123, last = 123;

	if (sscanf(range, "%u-%u", &first, &last) != 2 ||
	    first == 0 || first > 0xffff ||
	    last == 0 || last > 0xffff || first > last)
		errx(1, "%s: illegal net range: %u-%u", range, first, last);
	at_nr.nr_firstnet = htons(first);
	at_nr.nr_lastnet = htons(last);
}

/* ARGSUSED */
void
setatphase(const char *phase, int d)
{
	if (!strcmp(phase, "1"))
		at_nr.nr_phase = 1;
	else if (!strcmp(phase, "2"))
		at_nr.nr_phase = 2;
	else
		errx(1, "%s: illegal phase", phase);
}

void
checkatrange(struct sockaddr_at *sat)
{
	if (at_nr.nr_phase == 0)
		at_nr.nr_phase = 2;	/* Default phase 2 */
	if (at_nr.nr_firstnet == 0)	/* Default range of one */
		at_nr.nr_firstnet = at_nr.nr_lastnet = sat->sat_addr.s_net;
	printf("\tatalk %d.%d range %d-%d phase %d\n",
	ntohs(sat->sat_addr.s_net), sat->sat_addr.s_node,
	ntohs(at_nr.nr_firstnet), ntohs(at_nr.nr_lastnet), at_nr.nr_phase);
	if ((u_short) ntohs(at_nr.nr_firstnet) >
	    (u_short) ntohs(sat->sat_addr.s_net) ||
	    (u_short) ntohs(at_nr.nr_lastnet) <
	    (u_short) ntohs(sat->sat_addr.s_net))
		errx(1, "AppleTalk address is not in range");
	*((struct netrange *) &sat->sat_zero) = at_nr;
}

#define SNS(x) ((struct sockaddr_ns *) &(x))
struct sockaddr_ns *snstab[] = {
SNS(ridreq.ifr_addr), SNS(addreq.ifra_addr),
SNS(addreq.ifra_mask), SNS(addreq.ifra_broadaddr)};

void
xns_getaddr(const char *addr, int which)
{
	struct sockaddr_ns *sns = snstab[which];

	sns->sns_family = AF_NS;
	sns->sns_len = sizeof(*sns);
	sns->sns_addr = ns_addr(addr);
	if (which == MASK)
		printf("Attempt to set XNS netmask will be ineffectual\n");
}

#define SIPX(x) ((struct sockaddr_ipx *) &(x))
struct sockaddr_ipx *sipxtab[] = {
SIPX(ridreq.ifr_addr), SIPX(addreq.ifra_addr),
SIPX(addreq.ifra_mask), SIPX(addreq.ifra_broadaddr)};

void
ipx_getaddr(const char *addr, int which)
{
	struct sockaddr_ipx *sipx = sipxtab[which];

	sipx->sipx_family = AF_IPX;
a2543 35
/* Print usage, exit(value) if value is non-zero. */
void
usage(int value)
{
	fprintf(stderr,
	    "usage: ifconfig [interface] [address_family] [address [dest_address]]\n"
	    "\t[[-]alias] [[-]arp] [broadcast addr]\n"
	    "\t[[-]debug] [delete] [up] [down] [ipdst addr]\n"
	    "\t[tunnel src_address dest_address] [deletetunnel]\n"
	    "\t[description value] [[-]group group-name]\n"
	    "\t[[-]link0] [[-]link1] [[-]link2]\n"
	    "\t[media type] [[-]mediaopt opts] [mode mode] [instance minst]\n"
	    "\t[mtu value] [metric nhops] [netmask mask] [prefixlen n]\n"
	    "\t[nwid id] [nwkey key] [nwkey persist[:key]] [-nwkey]\n"
	    "\t[bssid bssid] [-bssid] [chan n] [-chan]\n"
	    "\t[[-]powersave] [powersavesleep duration]\n"
#ifdef INET6
	    "\t[[-]anycast] [eui64] [pltime n] [vltime n] [[-]tentative]\n"
#endif
	    "\t[vlan vlan_tag vlandev parent_iface] [-vlandev] [vhid n]\n"
	    "\t[advbase n] [advskew n] [maxupd n] [pass passphrase]\n"
	    "\t[state init | backup | master]\n"
	    "\t[syncif iface] [-syncif] [syncpeer peer_address] [-syncpeer]\n"
	    "\t[phase n] [range netrange] [timeslot timeslot_range]\n"
	    "\t[802.2] [802.2tr] [802.3] [snap] [EtherII]\n"
	    "\t[pppoeac access-concentrator] [-pppoeac]\n"
	    "\t[pppoesvc service] [-pppoesvc]\n"
	    "       ifconfig -A | -Am | -a | -am [address_family]\n"
	    "       ifconfig -C\n"
	    "       ifconfig -m interface [address_family]\n"
	    "       ifconfig interface create\n"
	    "       ifconfig interface destroy\n");
	exit(value);
}

a2563 1

a2632 42
getifgroups(void)
{
	int			 len;
	struct ifgroupreq	 ifgr;
	struct ifg_req		*ifg;

	memset(&ifgr, 0, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, name, IFNAMSIZ);

	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
		if (errno == EINVAL || errno == ENOTTY)
			return;
		else
			err(1, "SIOCGIFGROUP");

	len = ifgr.ifgr_len;
	ifgr.ifgr_groups =
	    (struct ifg_req *)calloc(len / sizeof(struct ifg_req),
	    sizeof(struct ifg_req));
	if (ifgr.ifgr_groups == NULL)
		err(1, "getifgroups");

	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
		err(1, "SIOCGIFGROUP");

	if (len -= sizeof(struct ifg_req)) {
		len += sizeof(struct ifg_req);
		printf("\tgroups: ");
		ifg = ifgr.ifgr_groups;
		if (ifg) {
			len -= sizeof(struct ifg_req);
			ifg++;
		}
		for (; ifg && len >= sizeof(struct ifg_req); ifg++) {
			len -= sizeof(struct ifg_req);
			printf("%s ", ifg->ifgrq_group);
		}
		printf("\n");
	}
}

void
a2935 1

a3006 1

a3022 1

d3060 130
d3191 127
@


1.124
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.123 2004/12/07 10:26:49 jmc Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.123 2004/12/07 10:26:49 jmc Exp $";
d206 2
d309 2
d2896 4
a2899 3
		printf("\tcarp: %s vhid %d advbase %d advskew %d\n",
		    state, carpr.carpr_vhid, carpr.carpr_advbase,
		    carpr.carpr_advskew);
d3019 34
@


1.123
log
@note that -a is the default if no params given;
`interface' is now optional;
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.122 2004/12/07 00:10:05 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.122 2004/12/07 00:10:05 deraadt Exp $";
d732 2
a733 1
					if (ifa->ifa_addr->sa_family == p->af_af)
d1218 1
a1218 1
	
a1229 1
			
d1265 1
a1265 1
  set_nwkey:
d1437 4
a1440 1
			/* check to see non default key or multiple keys defined */
d1470 4
a1473 1
					/* XXX - sanity check nwkey.i_key[i].i_keylen */
d1701 2
a1702 1
					ts_map |= get_ts_map(ts_flag, ts_start, ts);
d1726 1
a1726 1
		for(i = ts_start; i <= ts_stop; i++) {
d2240 2
a2241 2
					? "0"
					: sec2str(lifetime->ia6t_preferred - t));
d2248 2
a2249 2
					? "0"
					: sec2str(lifetime->ia6t_expire - t));
d2603 1
a2603 1
			return(0);
d2607 1
a2607 1
			return(0);
d2849 2
a2850 1
	ifgr.ifgr_groups = (struct ifg_req *)calloc(len / sizeof(struct ifg_req),
d3153 1
a3153 1
		
d3155 1
a3155 1
		
d3175 1
a3175 1
	switch(state.state) {
d3207 1
a3207 1
		}     
d3225 1
a3225 1
	
d3293 1
a3293 1
				return(result);
d3300 1
a3300 1
				return(result);
d3307 1
a3307 1
				return(result);
d3314 1
a3314 1
	return(result);
@


1.122
log
@default to interface printing, instead of help message.  any illegal -
option goes to usage.  initial work by ian, changed by me, ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.121 2004/12/01 15:57:44 jmc Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.121 2004/12/01 15:57:44 jmc Exp $";
d2706 1
a2706 1
	    "usage: ifconfig interface [address_family] [address [dest_address]]\n"
@


1.121
log
@add pppoe stuff to usage();
ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.120 2004/11/28 23:39:45 canacar Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.120 2004/11/28 23:39:45 canacar Exp $";
d351 1
a351 1
void	usage(void);
d431 5
a435 2
	if (argc < 2)
		usage();
d453 1
a453 1
			usage();
d458 2
d476 1
a476 1
			usage();
d482 1
a482 1
			usage();
d2701 1
d2703 1
a2703 1
usage(void)
d2733 1
a2733 1
	exit(1);
@


1.120
log
@In kernel pppoe client, a simple IPv4 only implementation.
Initial porting from NetBSD by David Berghoff.
Modified/simplified to match our sppp implementation.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.119 2004/11/17 01:47:20 itojun Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.119 2004/11/17 01:47:20 itojun Exp $";
d2720 2
@


1.119
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.118 2004/11/06 00:54:19 reyk Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.118 2004/11/06 00:54:19 reyk Exp $";
d103 1
d212 4
d336 5
d1951 1
d2748 1
d3126 129
@


1.118
log
@added the "bssid" command to ifconfig, an extended ieee80211
status output and the missing man page entries for ifconfig.8
(from jared).

ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.117 2004/11/02 11:38:04 henning Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.117 2004/11/02 11:38:04 henning Exp $";
a1869 3
#ifdef NI_WITHSCOPEID
	const int niflag = NI_NUMERICHOST | NI_WITHSCOPEID;
#else /* NI_WITHSCOPEID */
a1870 1
#endif /* NI_WITHSCOPEID */
a2130 3
#ifdef NI_WITHSCOPEID
	const int niflag = NI_NUMERICHOST | NI_WITHSCOPEID;
#else /* NI_WITHSCOPEID */
a2131 1
#endif /* NI_WITHSCOPEID */
@


1.117
log
@KNF - reyk, look at this diff
not that ifconfig is our prime example for nicely KNF'd and readable code tho
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.116 2004/11/02 02:33:26 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.116 2004/11/02 02:33:26 deraadt Exp $";
d166 1
d266 2
d1200 25
d1350 1
a1350 1
	int len, i, nwkey_verbose;
d1354 3
d1358 1
d1360 1
d1363 27
a1389 2
	(void)strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCG80211NWID, (caddr_t)&ifr) == 0) {
d1394 1
a1394 1
		fputs("\tnwid: ", stdout);
d1396 13
a1408 1
		putchar('\n');
d1411 2
a1412 5
	memset(&nwkey, 0, sizeof(nwkey));
	(void)strlcpy(nwkey.i_name, name, sizeof(nwkey.i_name));
	if (ioctl(s, SIOCG80211NWKEY, (caddr_t)&nwkey) == 0 &&
	    nwkey.i_wepon > 0) {
		fputs("\tnwkey: ", stdout);
d1419 1
a1419 1
			puts("<not displayed>");
d1459 1
a1459 1
			putchar('\n');
d1463 4
a1466 9
	memset(&power, 0, sizeof(power));
	(void)strlcpy(power.i_name, name, sizeof(power.i_name));
	if (ioctl(s, SIOCG80211POWER, &power) == 0) {
		fputs("\tpowersave: ", stdout);
		if (power.i_enabled)
			printf("on (%dms sleep)\n", power.i_maxsleep);
		else
			puts("off");
	}
d2706 2
a2707 1
	    "\t[chan n] [-chan] [[-]powersave] [powersavesleep duration]\n"
@


1.116
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.115 2004/11/02 02:12:16 reyk Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.115 2004/11/02 02:12:16 reyk Exp $";
d167 1
a167 1
void    setifchan(const char *, int);
d187 1
a187 1
void    setmediamode(const char *, int);
d231 1
a231 1
#define A_MEDIAMODE	0x0010		/* mode command */
d1275 2
a1276 2
	(void)strlcpy(channel.i_name, name, sizeof(channel.i_name));
	channel.i_channel = (u_int16_t) chan;
@


1.115
log
@added new commands to ifconfig used by net80211 interfaces:
mode (set mode for multi-mode interfaces) and chan (set the radio channel).
some additional output will be printed by "ifconfig -m".

ok deraadt@@ millert@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.114 2004/10/11 10:13:49 henning Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.114 2004/10/11 10:13:49 henning Exp $";
d231 1
a231 1
#define A_MEDIAMODE     0x0010          /* mode command */
d267 2
a268 2
	{ "chan",       NEXTARG,        0,              setifchan },
	{ "-chan",      -1,             0,              setifchan },
d322 1
a322 1
	{ "mode",       NEXTARG,        A_MEDIAMODE,    setmediamode },
d346 1
a346 1
int     get_media_mode(int, const char *);
a862 1

d1502 1
a1502 1
	 
d1504 1
a1504 1
	 
d1508 1
a1508 1
	 
d1513 1
a1513 1
	 
a1515 1
	 
a1516 1
	 
a1631 2


d1709 1
a1709 1
	 
a1713 1
	 
d1771 1
a1771 1
		     desc++) {
a1981 1

a2747 1

a2964 1

@


1.114
log
@ifgroups reqrite
there is now a TAILQ with all interface groups as members, and
in struct ofnet there is only a pointer to the group structure stored
and not its name.
mostly hacked at c2k4 and somewhere over the atlantic ocean
ok markus mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.113 2004/09/15 21:27:01 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.113 2004/09/15 21:27:01 deraadt Exp $";
d99 2
a100 1
#include <net/if_ieee80211.h>
d167 1
d187 1
d231 1
d267 2
d322 1
d346 1
d1260 22
d1417 1
a1417 1
	if ((actions & (A_MEDIA|A_MEDIAOPT)) == 0) {
d1473 4
d1500 24
d1664 3
d1711 13
d1774 12
d2648 1
a2648 1
	    "\t[media type] [[-]mediaopt opts] [instance minst]\n"
d2651 1
a2651 1
	    "\t[[-]powersave] [powersavesleep duration]\n"
@


1.113
log
@ARGSUSED, remove unused, ...
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.112 2004/08/08 19:04:25 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.112 2004/08/08 19:04:25 deraadt Exp $";
d2675 3
a2677 3
	int len;
	struct ifgroupreq ifgr;
	struct ifgroup *ifg;
d2689 2
a2690 2
	ifgr.ifgr_groups = (struct ifgroup *)calloc(len / sizeof(struct ifgroup),
	    sizeof(struct ifgroup));
d2697 2
a2698 2
	if (len -= sizeof(struct ifgroup)) {
		len += sizeof(struct ifgroup);
d2702 1
a2702 1
			len -= sizeof(struct ifgroup);
d2705 3
a2707 3
		for (; ifg && len >= sizeof(struct ifgroup); ifg++) {
			len -= sizeof(struct ifgroup);
			printf("%s ", ifg->ifg_group);
@


1.112
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.111 2004/08/03 05:36:32 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.111 2004/08/03 05:36:32 mcbride Exp $";
d146 1
a146 1
int	dflag, mflag, lflag, uflag;
d847 1
d856 1
d863 1
d870 1
d879 1
d925 1
d1031 1
d1046 1
a1050 1
	char *ep = NULL;
d1061 1
d1076 1
d1172 1
d1252 1
d1269 1
a1274 1
	int len;
d1345 1
a1345 1
				    nwkey.i_key[0].i_keydat, 7) == 0)
d1431 1
d1464 1
d1484 1
d1509 1
d1539 1
d1549 1
a1549 1
	int		ts = 0, ts_start = 0, i;
d1551 1
a1551 1
	if (strcmp(val,"all") == 0){
d1553 2
a1554 2
	}else{
		while(*ptr != '\0') {
d1569 1
a1569 1
		if (ts_flag){
a1570 1
		}
d1721 1
d1903 1
d1964 1
d2203 1
d2302 1
d2473 1
d2487 1
d2603 1
d2628 1
d2650 1
d2737 1
d2750 1
a2750 1
	strlcpy(carpr.carpr_key, val, CARP_KEY_LEN);
d2756 1
d2780 1
d2804 1
d2828 1
d2852 1
d2870 1
d2889 1
a2895 1
	struct if_laddrreq req;
d2921 1
d2939 1
@


1.111
log
@Allow a unicast ip address to be specified for pfsync with the 'syncpeer'
keyword. This address is used instead of the multicast address to send state
updates; this allows pairs of pfsync firewalls to protect the traffic
with IPSec.

ifconfig must be updated to match the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.110 2004/07/03 20:24:48 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.110 2004/07/03 20:24:48 deraadt Exp $";
d1264 1
a1264 1
	
d1578 1
a1578 1
	} else { /* Single channel */ 
d1580 1
a1580 1
		map |= mask; 
d2290 1
a2290 1
	
d2396 1
a2396 1
	
d2656 1
a2656 1
	
d2668 1
a2668 1
	
d2671 1
a2671 1
	
d2884 1
a2884 1
		
d2912 1
a2912 1
	
@


1.110
log
@zap INET_ONLY, compress usage(); jared
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.109 2004/07/03 20:24:16 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.109 2004/07/03 20:24:16 deraadt Exp $";
d204 2
d294 3
a297 1
	{ "-syncif",	1,		0,		unsetpfsync_syncif },
d2549 2
a2550 1
	    "\t[state init | backup | master] [syncif iface] [-syncif]\n"
d2856 50
d2940 7
a2946 3
	if (preq.pfsyncr_syncif[0] != '\0')
		printf("\tpfsync: syncif: %s maxupd: %d\n",
		    preq.pfsyncr_syncif, preq.pfsyncr_maxupdates);
@


1.109
log
@ansi; jared
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.108 2004/06/26 17:36:33 markus Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.108 2004/06/26 17:36:33 markus Exp $";
a2542 1
#ifndef INET_ONLY
d2546 1
a2546 1
	    "\t[phase n] [range netrange]\n"
a2547 2
	    "\t[timeslot timeslot_range]\n"
#endif
@


1.108
log
@cleanup ioctl for ifgroups; ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.107 2004/06/26 06:59:17 alex Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.107 2004/06/26 06:59:17 alex Exp $";
d2687 1
a2687 1
carp_status()
@


1.107
log
@Add option that allows to change timeslot range forn network card.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.106 2004/06/26 04:00:05 pb Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.106 2004/06/26 04:00:05 pb Exp $";
d1053 1
a1053 1
	struct ifgroupreq ifg;
d1055 2
a1056 1
	memset(&ifg, 0, sizeof(ifg));
d1058 1
a1058 3
	strlcpy(ifg.if_name, name, IFNAMSIZ);

	if (strlcpy(ifg.ifg_group, group_name, IFNAMSIZ) >= IFNAMSIZ)
d1060 1
a1060 2

	if (ioctl(s, SIOCAIFGROUP, (caddr_t)&ifg) == -1)
d1067 1
a1067 1
	struct ifgroupreq ifg;
d1069 2
a1070 1
	memset(&ifg, 0, sizeof(ifg));
d1072 1
a1072 3
	strlcpy(ifg.if_name, name, IFNAMSIZ);

	if (strlcpy(ifg.ifg_group, group_name, IFNAMSIZ) >= IFNAMSIZ)
d1074 1
a1074 2

	if (ioctl(s, SIOCDIFGROUP, (caddr_t)&ifg) == -1)
d2649 2
a2650 2
	struct ifgroupreq ifg;
	struct ifgroup *ifgp;
d2652 2
a2653 2
	memset(&ifg, 0, sizeof(ifg));
	strlcpy(ifg.if_name, name, IFNAMSIZ);
d2655 1
a2655 1
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifg) == -1)
d2661 2
a2662 2
	len = ifg.ifg_len;
	ifg.ifg_groups = (struct ifgroup *)calloc(len / sizeof(struct ifgroup),
d2664 1
a2664 1
	if (ifg.ifg_groups == NULL)
d2667 1
a2667 1
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifg) == -1)
d2673 2
a2674 2
		ifgp = ifg.ifg_groups;
		if (ifgp) {
d2676 1
a2676 1
			ifgp++;
d2678 1
a2678 1
		for (; ifgp && len >= sizeof(struct ifgroup); ifgp++) {
d2680 1
a2680 1
			printf("%s ", ifgp->if_group);
@


1.106
log
@ignore IFGROUP errs in ifconfig -a for "too old" kernels right now
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.105 2004/06/26 03:12:08 pb Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.105 2004/06/26 03:12:08 pb Exp $";
d189 1
d314 1
d343 1
d1524 61
d2553 1
@


1.105
log
@more netiso leftovers

by pointer from yared janovich

henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.104 2004/06/26 00:01:36 pb Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.104 2004/06/26 00:01:36 pb Exp $";
d2595 4
a2598 1
		err(1, "SIOCGIFGROUP");
@


1.104
log
@groups in usage() - from jared yanovich
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.103 2004/06/25 18:24:23 pb Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.103 2004/06/25 18:24:23 pb Exp $";
a144 1
int	nsellength = 1;
a319 1
void	adjust_nsellength(void);
d2487 1
a2487 1
	    "\t[phase n] [range netrange] [snpaoffset n] [nsellength n]\n"
@


1.103
log
@introduce "interface groups"

by "ifconfig fxp0 group foobar" "ifconfig xl0 group foobar"
these two interfaces are in one group.
Every interface has its if-family as default group.

idea/design from henning@@, based on some work/disucssion from Joris Vink.

henning@@, mcbride@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.102 2004/06/24 20:44:06 henning Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.102 2004/06/24 20:44:06 henning Exp $";
d2476 1
a2476 1
	    "\t[description value]\n"
@


1.102
log
@remove netiso stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.101 2004/06/21 23:41:53 millert Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.101 2004/06/21 23:41:53 millert Exp $";
d155 2
d194 1
d253 2
d1049 32
d1725 1
d2585 38
@


1.101
log
@Make printing of 802.11 fields consistent with the rest by printing
a colon (':') after the field name.  Noticed by markus@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.100 2004/05/29 17:54:46 jcs Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.100 2004/05/29 17:54:46 jcs Exp $";
a116 5
#define EON
#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <sys/protosw.h>

a135 2
struct	iso_ifreq	iso_ridreq;
struct	iso_aliasreq	iso_addreq;
a168 2
void	setnsellength(const char *, int);
void	setsnpaoffset(const char *, int);
a201 1
void	fixnsel(struct sockaddr_iso *);
a272 2
	{ "snpaoffset",	NEXTARG,	0,		setsnpaoffset },
	{ "nsellength",	NEXTARG,	0,		setnsellength },
a357 2
void	iso_status(int);
void	iso_getaddr(const char *, int);
a384 2
	{ "iso", AF_ISO, iso_status, iso_getaddr, NULL,
	    SIOCDIFADDR_ISO, SIOCAIFADDR_ISO, C(iso_ridreq), C(iso_addreq) },
a521 3
	case AF_ISO:
		adjust_nsellength();
		break;
a2156 47
void
iso_status(int force)
{
	struct sockaddr_iso *siso;
	struct iso_ifreq ifr;

	getsock(AF_ISO);
	if (s < 0) {
		if (errno == EPROTONOSUPPORT)
			return;
		err(1, "socket");
	}
	memset(&ifr, 0, sizeof(ifr));
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFADDR_ISO, (caddr_t)&ifr) < 0) {
		if (errno == EADDRNOTAVAIL || errno == EAFNOSUPPORT) {
			if (!force)
				return;
			memset(&ifr.ifr_Addr, 0, sizeof(ifr.ifr_Addr));
		} else
			warn("SIOCGIFADDR_ISO");
	}
	(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	siso = &ifr.ifr_Addr;
	printf("\tiso %s ", iso_ntoa(&siso->siso_addr));
	if (ioctl(s, SIOCGIFNETMASK_ISO, (caddr_t)&ifr) < 0) {
		if (errno == EADDRNOTAVAIL)
			memset(&ifr.ifr_Addr, 0, sizeof(ifr.ifr_Addr));
		else
			warn("SIOCGIFNETMASK_ISO");
	} else {
		printf(" netmask %s ", iso_ntoa(&siso->siso_addr));
	}
	if (flags & IFF_POINTOPOINT) {
		if (ioctl(s, SIOCGIFDSTADDR_ISO, (caddr_t)&ifr) < 0) {
			if (errno == EADDRNOTAVAIL)
			    memset(&ifr.ifr_Addr, 0, sizeof(ifr.ifr_Addr));
			else
			    warn("SIOCGIFDSTADDR_ISO");
		}
		(void) strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
		siso = &ifr.ifr_Addr;
		printf("--> %s ", iso_ntoa(&siso->siso_addr));
	}
	putchar('\n');
}

a2427 59
}

#define SISO(x) ((struct sockaddr_iso *) &(x))
struct sockaddr_iso *sisotab[] = {
SISO(iso_ridreq.ifr_Addr), SISO(iso_addreq.ifra_addr),
SISO(iso_addreq.ifra_mask), SISO(iso_addreq.ifra_dstaddr)};

void
iso_getaddr(const char *addr, int which)
{
	struct sockaddr_iso *siso = sisotab[which];
	siso->siso_addr = *iso_addr(addr);

	if (which == MASK) {
		siso->siso_len = TSEL(siso) - (caddr_t)(siso);
		siso->siso_nlen = 0;
	} else {
		siso->siso_len = sizeof(*siso);
		siso->siso_family = AF_ISO;
	}
}

void
setsnpaoffset(const char *val, int ignored)
{
	const char *errmsg = NULL;

	iso_addreq.ifra_snpaoffset = strtonum(val, 0, INT_MAX, &errmsg);
	if (errmsg)
		errx(1, "snpaoffset %s: %s", val, errmsg);
}

void
setnsellength(const char *val, int ignored)
{
	const char *errmsg = NULL;

	errno = 0;
	nsellength = strtonum(val, 0, INT_MAX, &errmsg);
	if (errmsg)
		errx(1, "NSEL length %s: %s", val, errmsg);
	if (afp == 0 || afp->af_af != AF_ISO)
		errx(1, "setting NSEL length valid only for iso");
}

void
fixnsel(struct sockaddr_iso *s)
{
	if (s->siso_family == 0)
		return;
	s->siso_tlen = nsellength;
}

void
adjust_nsellength(void)
{
	fixnsel(sisotab[RIDADDR]);
	fixnsel(sisotab[ADDR]);
	fixnsel(sisotab[DSTADDR]);
@


1.100
log
@introduce SIOCSIFDESCR and SIOCGIFDESCR to maintain interface
descriptions, configurable with ifconfig

help from various, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.99 2004/05/18 10:54:07 otto Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.99 2004/05/18 10:54:07 otto Exp $";
d1277 1
a1277 1
		fputs("\tnwid ", stdout);
d1286 1
a1286 1
		fputs("\tnwkey ", stdout);
d1340 1
a1340 1
		fputs("\tpowersave ", stdout);
@


1.99
log
@Trailers are really wonders of the past. Remove them from man page and
usage. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.98 2004/05/10 18:34:42 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.98 2004/05/10 18:34:42 deraadt Exp $";
d166 1
d321 2
d877 8
d1681 1
d1683 1
d1696 7
d2563 1
@


1.98
log
@missing casts spotted by 64 bit cc
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.97 2004/05/05 22:20:17 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.97 2004/05/05 22:20:17 deraadt Exp $";
d2543 1
a2543 1
	    "\t[[-]link0] [[-]link1] [[-]link2] [[-]trailers]\n"
@


1.97
log
@use strtonum all over the place; ok pb millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.96 2004/04/27 22:14:11 pb Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.96 2004/04/27 22:14:11 pb Exp $";
d2402 1
a2402 1
	u_short first = 123, last = 123;
d2404 1
a2404 1
	if (sscanf(range, "%hu-%hu", &first, &last) != 2 ||
@


1.96
log
@clean up ifdef hell
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.94 2004/04/27 17:33:52 pb Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.94 2004/04/27 17:33:52 pb Exp $";
a154 1
int	reset_if_flags;
d393 1
a393 1
	     SIOCDIFADDR, SIOCAIFADDR, C(ridreq), C(addreq) },
d395 1
a395 1
	     SIOCDIFADDR, SIOCAIFADDR, C(ridreq), C(addreq) },
d397 1
a397 1
	     SIOCDIFADDR_ISO, SIOCAIFADDR_ISO, C(iso_ridreq), C(iso_addreq) },
d443 3
a445 1
				afp = rafp; argc--; argv++;
d969 1
d971 4
a974 1
	char *ep;
d977 1
a977 3
	newval = (time_t)strtoul(val, &ep, 0);
	if (val == ep)
		errx(1, "invalid %s", cmd);
d1026 1
a1026 1
	char *ep = NULL;
d1029 4
a1032 3
	ifr.ifr_metric = strtoul(val, &ep, 10);
	if (!ep || *ep)
		errx(1, "%s: invalid metric", val);
d1040 1
d1044 4
a1047 3
	ifr.ifr_mtu = strtoul(val, &ep, 10);
	if (!ep || *ep)
		errx(1, "%s: invalid mtu", val);
d1055 1
a1055 2
	int len;
	int hexstr;
d1232 3
a1234 1

d1241 4
a1244 1
	power.i_maxsleep = atoi(val);
d1469 1
d1485 3
a1487 3
	inst = atoi(val);
	if (inst < 0 || inst > IFM_INST_MAX)
		errx(1, "invalid media instance: %s", val);
d2106 11
d2148 5
a2152 16
	{
		struct frame_types {
			int	type;
			char	*name;
		} *p, frames[] = {
			{ IPX_ETHERTYPE_8022, "802.2" },
			{ IPX_ETHERTYPE_8022TR, "802.2tr" },
			{ IPX_ETHERTYPE_8023, "802.3" },
			{ IPX_ETHERTYPE_SNAP, "SNAP" },
			{ IPX_ETHERTYPE_II,  "EtherII" },
			{ 0, NULL }
		};
		for (p = frames; p->name && p->type != sipx->sipx_type; p++);
		if (p->name != NULL)
			printf("frame %s ", p->name);
	}
d2233 1
d2235 5
a2239 1
	int len = strtol(plen, (char **)NULL, 10);
a2240 2
	if ((len < 0) || (len > 32))
		errx(1, "%s: bad value", plen);
d2335 1
d2337 1
a2337 1
	int len = strtol(plen, (char **)NULL, 10);
d2339 4
a2342 2
	if ((len < 0) || (len > 128))
		errx(1, "%s: bad value", plen);
d2499 5
a2503 1
	iso_addreq.ifra_snpaoffset = atoi(val);
d2509 6
a2514 3
	nsellength = atoi(val);
	if (nsellength < 0)
		errx(1, "negative NSEL length is absurd");
d2538 10
a2547 9
	fprintf(stderr, "usage: ifconfig interface [address_family] [address [dest_address]]\n"
			"\t[[-]alias] [[-]arp] [broadcast addr]\n"
			"\t[[-]debug] [delete] [up] [down] [ipdst addr]\n"
			"\t[tunnel src_address dest_address] [deletetunnel]\n"
			"\t[[-]link0] [[-]link1] [[-]link2] [[-]trailers]\n"
			"\t[media type] [[-]mediaopt opts] [instance minst]\n"
			"\t[mtu value] [metric nhops] [netmask mask] [prefixlen n]\n"
			"\t[nwid id] [nwkey key] [nwkey persist[:key]] [-nwkey]\n"
			"\t[[-]powersave] [powersavesleep duration]\n"
d2549 1
a2549 1
			"\t[[-]anycast] [eui64] [pltime n] [vltime n] [[-]tentative]\n"
d2552 5
a2556 5
			"\t[vlan vlan_tag vlandev parent_iface] [-vlandev] [vhid n]\n"
			"\t[advbase n] [advskew n] [maxupd n] [pass passphrase]\n"
			"\t[state init | backup | master] [syncif iface] [-syncif]\n"
			"\t[phase n] [range netrange] [snpaoffset n] [nsellength n]\n"
			"\t[802.2] [802.2tr] [802.3] [snap] [EtherII]\n"
d2558 5
a2562 6
			"       ifconfig -A | -Am | -a | -am [address_family]\n"
			"       ifconfig -C\n"
			"       ifconfig -m interface [address_family]\n"
			"       ifconfig interface create\n"
			"       ifconfig interface destroy\n"
		);
d2591 1
d2593 3
a2595 1
	__tag = tag = atoi(val);
d2697 2
a2699 1
	struct carpreq carpr;
d2701 3
a2703 4
	vhid = atoi(val);

	if (vhid <= 0)
		errx(1, "vhid must be greater than 0");
d2720 2
a2722 1
	struct carpreq carpr;
d2724 3
a2726 1
	advskew = atoi(val);
d2743 2
a2745 1
	struct carpreq carpr;
d2747 3
a2749 1
	advbase = atoi(val);
d2823 2
d2826 4
a2829 3
	struct pfsyncreq preq;

	maxupdates = atoi(val);
d2854 1
a2854 1
	if (preq.pfsyncr_syncif[0] != '\0') {
a2856 1
	}
@


1.95
log
@reworking of man page and sync/update usage();

this stuff is based mostly on diffs from jared yanovich, with some stuff
from myself and otto;

ok naddy@@ otto@@ markus@@ deraadt@@
@
text
@a121 1
#ifndef INET_ONLY
a122 1
#endif
a130 1
#ifdef HAVE_IFADDRS_H
a131 1
#endif
d140 1
a140 1
#endif
d159 1
a159 1
#endif
d189 1
a189 1
#endif
d259 1
a259 1
#endif
a280 1
#ifndef INET_ONLY
a300 1
#endif	/* INET_ONLY */
d361 1
a361 1
#endif
d390 1
a390 2
#endif
#ifndef INET_ONLY	/* small version, for boot media */
a398 1
#endif	/* INET_ONLY */
d472 1
a472 1
#endif
a532 2
#ifndef INET_ONLY

a564 1
#endif	/* INET_ONLY */
a639 1
#ifdef HAVE_IFADDRS_H
d681 1
a681 1
#else
d684 1
a684 1
#endif
a727 89
#else
	char *inbuf = NULL, *inb;
	struct ifconf ifc;
	struct ifreq ifreq, *ifrp;
	int i, siz, len = 8192;
	int count = 0, noinet = 1;
	char ifrbuf[8192];

	getsock(af);
	if (s < 0)
		err(1, "socket");
	while (1) {
		ifc.ifc_len = len;
		inb = realloc(inbuf, len);
		if (inb == NULL) {
			if (inbuf)
				free(inbuf);
			err(1, "malloc");
		}
		ifc.ifc_buf = inbuf = inb;
		if (ioctl(s, SIOCGIFCONF, &ifc) < 0)
			err(1, "SIOCGIFCONF");
		if (ifc.ifc_len + sizeof(ifreq) < len)
			break;
		len *= 2;
	}
	ifrp = ifc.ifc_req;
	ifreq.ifr_name[0] = '\0';
	for (i = 0; i < ifc.ifc_len; ) {
		ifrp = (struct ifreq *)((caddr_t)ifc.ifc_req + i);
		memcpy(ifrbuf, ifrp, sizeof(*ifrp));
		siz = ((struct ifreq *)ifrbuf)->ifr_addr.sa_len;
		if (siz < sizeof(ifrp->ifr_addr))
			siz = sizeof(ifrp->ifr_addr);
		siz += sizeof(ifrp->ifr_name);
		i += siz;
		/* avoid alignment issue */
		if (sizeof(ifrbuf) < siz)
			errx(1, "ifr too big");
		memcpy(ifrbuf, ifrp, siz);
		ifrp = (struct ifreq *)ifrbuf;

		if (ifrm && strncmp(ifrm->ifr_name, ifrp->ifr_name,
		    sizeof(ifrp->ifr_name)))
			continue;
		(void) strlcpy(name, ifrp->ifr_name, sizeof(name));
		if (ifrp->ifr_addr.sa_family == AF_LINK) {
			ifreq = ifr = *ifrp;
			if (getinfo(&ifreq, 0) < 0)
				continue;
			status(1, NULL);
			count++;
			noinet = 1;
			continue;
		}
		if (!strncmp(ifreq.ifr_name, ifrp->ifr_name,
		    sizeof(ifrp->ifr_name))) {
			const struct afswtch *p;

			if (ifrp->ifr_addr.sa_family == AF_INET &&
			    ifaliases == 0 && noinet == 0)
				continue;
			ifr = *ifrp;
#ifdef INET6
			/* quickhack: sizeof(ifr) < sizeof(ifr6) */
			if (ifrp->ifr_addr.sa_family == AF_INET6)
				bcopy(ifrp, &ifr6, sizeof(ifr6));
#endif
			if ((p = afp) != NULL) {
				if (ifr.ifr_addr.sa_family == p->af_af)
					(*p->af_status)(1);
			} else {
				for (p = afs; p->af_name; p++) {
					if (ifr.ifr_addr.sa_family == p->af_af)
						(*p->af_status)(0);
				}
			}
			count++;
			if (ifrp->ifr_addr.sa_family == AF_INET)
				noinet = 0;
			continue;
		}
	}
	free(inbuf);
	if (count == 0) {
		fprintf(stderr, "%s: no such interface\n", name);
		exit(1);
	}
#endif
d1018 1
a1018 1
#endif
d1612 1
a1612 1
#else
d1614 1
a1614 1
#endif
d1626 1
a1626 1
#endif
d1632 1
a1632 1
#endif
d1637 1
a1637 1
#endif
a1671 1
#ifndef	INET_ONLY
a1674 1
#endif
d1853 1
a1853 1
#endif
d1866 1
a1866 1
#else
d1868 1
a1868 1
#endif
a1978 2
#ifndef INET_ONLY

a2191 2
#endif	/* INET_ONLY */

d2290 1
a2290 1
#else
d2312 1
a2312 1
#endif
d2314 1
a2314 1
#endif
a2364 1
#ifndef INET_ONLY
a2510 2
#endif	/* INET_ONLY */

a2541 2
#ifndef INET_ONLY

a2822 1
#endif /* INET_ONLY */
d2868 1
a2868 1
#endif
@


1.94
log
@missing ';' in actually unreached code (pointed out by logix(at)franken.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.93 2004/03/18 20:52:13 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.93 2004/03/18 20:52:13 mcbride Exp $";
d1014 1
a1014 1
 * Note: doing an SIOCIGIFFLAGS scribbles on the union portion
d2624 25
a2648 20
	fprintf(stderr, "usage: ifconfig [ -m ] [ -a ] [ -A ] [ interface ]\n"
		"\t[ [af] [ address [ dest_addr ] ] [ up ] [ down ] "
		"[ netmask mask ] ]\n"
		"\t[ media media_type ] [ mediaopt media_option ]\n"
		"\t[ metric n ]\n"
		"\t[ mtu n ]\n"
		"\t[ nwid network_id ] [ nwkey network_key | -nwkey ]\n"
		"\t[ powersave | -powersave ] [ powersavesleep duration ]\n"
		"\t[ [af] tunnel srcaddress dstaddress ] [ deletetunnel ]\n"
		"\t[ vlan n vlandev interface ]\n"
		"\t[ arp | -arp ]\n"
		"\t[ anycast | -anycast ] [ deprecated | -deprecated ]\n"
		"\t[ tentative | -tentative ] [ pltime n ] [ vltime n ] [ eui64 ]\n"
		"\t[ -802.2 | -802.3 | -802.2tr | -snap | -EtherII ]\n"
		"\t[ link0 | -link0 ] [ link1 | -link1 ] [ link2 | -link2 ]\n"
		"       ifconfig [-a | -A | -am | -Am] [ af ]\n"
		"       ifconfig -m interface [af]\n"
		"       ifconfig -C\n"
		"       ifconfig interface create\n"
		"       ifconfig interface destroy\n");
@


1.93
log
@Allow the state of a carp interface to be changed explicitly.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.92 2004/03/15 08:52:17 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.92 2004/03/15 08:52:17 deraadt Exp $";
d756 1
a756 1
				free(inbuf)
@


1.92
log
@some small knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.91 2004/03/08 17:21:52 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.91 2004/03/08 17:21:52 mcbride Exp $";
d210 1
d302 1
d2832 23
@


1.91
log
@Prevent user from specifying an interface name longer than IFNAMSIZ.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.90 2004/02/26 20:25:09 millert Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.90 2004/02/26 20:25:09 millert Exp $";
d308 1
a308 1
	{ "deletetunnel",  0,   	0,		deletetunnel } ,
d390 1
a390 1
	     SIOCDIFADDR, SIOCAIFADDR, C(ridreq), C(in_addreq) },
d393 1
a393 1
	     SIOCDIFADDR_IN6, SIOCAIFADDR_IN6, C(in6_ridreq), C(in6_addreq) },
a889 1
	return;
d1095 1
a1095 1
 	in6 = (struct in6_addr *)&in6_addreq.ifra_addr.sin6_addr;
d1113 1
a1113 1
 	memcpy(&in6->s6_addr[8], &lladdr->s6_addr[8], 8);
d1597 1
a1597 1
	     desc++) {
d1610 1
a1610 1
	     desc++) {
d1684 1
a1684 1
	     desc++) {
d1818 1
a1818 1
			     ifms->ifms_valid != 0; ifms++) {
d1820 1
a1820 1
				      IFM_TYPE(ifmr.ifm_current) ||
d1822 1
a1822 1
				      ifm_status_valid_list[bitno])
a2664 2

	return;
a2685 2

	return;
a2706 2

	return;
a2724 2

	return;
a2751 3

        return;

a2769 2

	return;
a2792 2

	return;
a2812 2

	return;
a2832 2

	return;
a2849 2

	return;
a2866 2

	return;
a2886 2

	return;
a2903 2

	return;
@


1.90
log
@Deal correctly with printing interfaces with multiple trailing digits.
E.g. "ifconfig vlan1" should only match vlan1, not vlan1, vlan10, vlan11,
etc.  OK tdeval@@, hshoexer@@, otto@@.  Closes PR 3693.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.89 2004/01/13 01:42:45 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.89 2004/01/13 01:42:45 mcbride Exp $";
d440 2
a441 1
		(void) strlcpy(name, *argv, sizeof(name));
d444 2
a445 2
	} else
		(void) strlcpy(name, *argv, sizeof(name));
@


1.89
log
@Allow ifconfig to print out all interfaces of a given type.
ie. 'ifconfig carp' prints out all carp interfaces.

ok hshoexer@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.88 2003/12/23 14:52:12 markus Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.88 2003/12/23 14:52:12 markus Exp $";
d651 1
a651 1
	char ch, *oname = NULL;
a666 2
		if (oname && strncmp(oname, ifa->ifa_name, nlen))
			continue;
d668 10
a677 4
			/* Check for end or a digit ! */
			ch = ifa->ifa_name[nlen];
			if (ch && (ch < '0' || ch > '9'))
				continue;
@


1.88
log
@automagically create pseudo-network interfaces; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.87 2003/12/15 07:11:29 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.87 2003/12/15 07:11:29 mcbride Exp $";
d651 1
d653 1
a653 1
	int count = 0, noinet = 1;
d658 7
d667 1
a667 2
		if (ifrm && strncmp(ifrm->ifr_name, ifa->ifa_name,
		    sizeof(ifrm->ifr_name)))
d669 6
d727 2
@


1.87
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.86 2003/12/08 09:09:03 markus Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.86 2003/12/08 09:09:03 markus Exp $";
d331 1
a331 1
int	getinfo(struct ifreq *);
d414 1
d488 2
a489 2

	if (getinfo(&ifr) < 0)
d609 1
a609 1
getinfo(struct ifreq *ifr)
d616 15
a630 2
		warn("SIOCGIFFLAGS");
		return (-1);
d684 1
a684 1
			if (getinfo(ifrp) < 0)
d766 1
a766 1
			if (getinfo(&ifreq) < 0)
@


1.86
log
@add IOCIFGCLONERS; ifconfig -C; from netbsd; ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.85 2003/12/07 15:30:24 markus Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.85 2003/12/07 15:30:24 markus Exp $";
d100 2
d210 4
d301 3
d1741 1
d2817 79
@


1.85
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.84 2003/12/03 13:28:36 markus Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.84 2003/12/03 13:28:36 markus Exp $";
d331 1
d407 1
d431 2
d445 6
d809 41
d2596 1
@


1.84
log
@add support for ifconfig clone; from netbsd; ok deraadt, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.83 2003/11/09 06:04:17 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.83 2003/11/09 06:04:17 mcbride Exp $";
d778 1
a778 3
clone_create(addr, param)
	const char *addr;
	int param;
d791 1
a791 3
clone_destroy(addr, param)
	const char *addr;
	int param;
@


1.83
log
@Unbreak printing of vlan interface information, commented out accidentally
in CARP import.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.82 2003/10/19 05:43:35 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.82 2003/10/19 05:43:35 mcbride Exp $";
d195 2
d300 5
d458 10
d776 27
d2548 3
a2550 1
		"       ifconfig -m interface [af]\n");
@


1.82
log
@Remove commented out debug line committed by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.81 2003/10/17 21:04:57 mcbride Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.81 2003/10/17 21:04:57 mcbride Exp $";
d1639 1
a1639 1
	/* vlan_status(); */
@


1.81
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.80 2003/09/24 21:12:12 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.80 2003/09/24 21:12:12 deraadt Exp $";
a608 2
//printf("printif: %s\n", ifa->ifa_name);

@


1.80
log
@realloc fix
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.79 2003/09/23 03:04:16 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.79 2003/09/23 03:04:16 deraadt Exp $";
d103 2
d201 5
d289 4
d609 2
d1641 2
a1642 1
	vlan_status();
d2600 118
@


1.79
log
@fix a few strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.78 2003/07/30 01:42:47 pvalchev Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.78 2003/07/30 01:42:47 pvalchev Exp $";
d658 1
a658 1
	char *inbuf = NULL;
d670 4
a673 2
		ifc.ifc_buf = inbuf = realloc(inbuf, len);
		if (inbuf == NULL)
d675 2
@


1.78
log
@change SIOCDIFADDR/SIOCAIFADDR warnings into errors (now this has correct
return code in certain cases); ok henning itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.77 2003/06/26 07:27:32 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.77 2003/06/26 07:27:32 deraadt Exp $";
a601 1
		name[sizeof(name) - 1] = '\0';
d698 1
a698 1
		(void) strlcpy(name, ifrp->ifr_name, sizeof(ifrp->ifr_name));
@


1.77
log
@bring protypes into scope.  this requires some quirky handling, but in
the end everything is much clearer; ok tedu (itojun might like to see
how ifconfig looks after this)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.76 2003/06/11 06:22:13 deraadt Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.76 2003/06/11 06:22:13 deraadt Exp $";
d533 1
a533 1
				warn("SIOCDIFADDR");
d539 1
a539 1
			warn("SIOCAIFADDR");
@


1.76
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.75 2003/06/02 20:06:15 millert Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.75 2003/06/02 20:06:15 millert Exp $";
d161 9
a169 9
void	notealias(char *, int);
void	notrailers(char *, int);
void	setifaddr(char *, int);
void	setifdstaddr(char *, int);
void	setifflags(char *, int);
void	setifbroadaddr(char *);
void	setifipdst(char *);
void	setifmetric(char *);
void	setifmtu(char *, int);
d174 9
a182 9
void	setifnetmask(char *);
void	setifprefixlen(char *, int);
void	setnsellength(char *);
void	setsnpaoffset(char *);
void	setipxframetype(char *, int);
void	setatrange(char *, int);
void	setatphase(char *, int);
void	settunnel(char *, char *);
void	deletetunnel(void);
d184 4
a187 4
void	setia6flags(char *, int);
void	setia6pltime(char *, int);
void	setia6vltime(char *, int);
void	setia6lifetime(char *, char *);
d191 8
a198 8
void	setmedia(char *, int);
void	setmediaopt(char *, int);
void	unsetmediaopt(char *, int);
void	setmediainst(char *, int);
void	setvlantag(char *, int);
void	setvlandev(char *, int);
void	unsetvlandev(char *, int);
void	vlan_status ();
d229 2
a230 1
	void	(*c_func)();
d284 2
a285 2
	{ "giftunnel",  NEXTARG2,	0,		settunnel } ,
	{ "tunnel",	NEXTARG2,	0,		settunnel } ,
d303 1
a303 1
void	adjust_nsellength();
d309 1
a309 1
void	usage();
d329 2
a330 2
void	in_getaddr(char *, int);
void	in_getprefix(char *, int);
d335 2
a336 2
void	in6_getaddr(char *, int);
void	in6_getprefix(char *, int);
d339 1
a339 1
void    at_getaddr(char *, int);
d341 1
a341 1
void	xns_getaddr(char *, int);
d343 1
a343 1
void	ipx_getaddr(char *, int);
d345 1
a345 1
void	iso_getaddr(char *, int);
d352 3
a354 3
	void (*af_status)();
	void (*af_getaddr)();
	void (*af_getprefix)();
d452 1
a452 1
				if (p->c_func == NULL)
d455 1
a455 1
		if (p->c_func) {
d460 1
a460 1
				(*p->c_func)(argv[1]);
d467 1
a467 1
				(*p->c_func)(argv[1], argv[2]);
d752 1
a752 1
setifaddr(char *addr, int param)
d767 1
a767 1
settunnel(char *src, char *dst)
d805 1
a805 1
deletetunnel(void)
d813 1
a813 1
setifnetmask(char *addr)
d819 1
a819 1
setifbroadaddr(char *addr)
d825 1
a825 1
setifipdst(char *addr)
d836 1
a836 1
notealias(char *addr, int param)
d851 1
a851 1
notrailers(char *vname, int value)
d858 1
a858 1
setifdstaddr(char *addr, int param)
d870 1
a870 1
setifflags(char *vname, int value)
d893 1
a893 1
setia6flags(char *vname, int value)
d904 1
a904 1
setia6pltime(char *val, int d)
d911 1
a911 1
setia6vltime(char *val, int d)
d918 1
a918 1
setia6lifetime(char *cmd, char *val)
d973 1
a973 1
setifmetric(char *val)
d986 1
a986 1
setifmtu(char *val, int d)
d1333 1
a1333 1
setmedia(char *val, int d)
d1365 1
a1365 1
setmediaopt(char *val, int d)
d1384 1
a1384 1
unsetmediaopt(char *val, int d)
d1408 1
a1408 1
setmediainst(char *val, int d)
a1730 1
	char *inet_ntoa();
d1788 1
a1788 1
setifprefixlen(char *addr, int d)
d2028 1
a2028 1
setipxframetype(char *vname, int type)
a2147 2
struct	in_addr inet_makeaddr();

d2154 1
a2154 1
in_getaddr(char *s, int which)
d2175 1
a2175 1
in_getprefix(char *plen, int which)
d2235 1
a2235 1
in6_getaddr(char *s, int which)
d2274 1
a2274 1
in6_getprefix(char *plen, int which)
d2323 1
a2323 1
at_getaddr(char *addr, int which)
d2340 1
a2340 1
setatrange(char *range, int d)
d2353 1
a2353 1
setatphase(char *phase, int d)
d2387 1
a2387 1
xns_getaddr(char *addr, int which)
a2389 1
	struct ns_addr ns_addr();
d2404 1
a2404 1
ipx_getaddr(char *addr, int which)
a2406 1
	struct ipx_addr ipx_addr();
d2422 1
a2422 1
iso_getaddr(char *addr, int which)
a2424 1
	struct iso_addr *iso_addr();
d2437 1
a2437 1
setsnpaoffset(char *val)
d2443 1
a2443 1
setnsellength(char *val)
d2518 1
a2518 1
setvlantag(char *val, int d)
d2541 1
a2541 1
setvlandev(char *val, int d)
d2564 1
a2564 1
unsetvlandev(char *val, int d)
@


1.75
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.74 2003/05/14 02:02:56 itojun Exp $	*/
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.74 2003/05/14 02:02:56 itojun Exp $";
d179 4
a182 4
void    setatrange(char *, int);
void    setatphase(char *, int);
void    settunnel(char *, char *);
void    deletetunnel(void);
d190 1
a190 1
void    checkatrange(struct sockaddr_at *);
d382 1
a382 3
main(argc, argv)
	int argc;
	char *argv[];
d397 1
a397 2
	}
	else if (!strcmp(*argv, "-ma") || !strcmp(*argv, "-am")) {
d400 1
a400 2
	}
	else if (!strcmp(*argv, "-mA") || !strcmp(*argv, "-Am")) {
d404 1
a404 2
	}
	else if (!strcmp(*argv, "-m")) {
d544 1
a544 2
getsock(naf)
	int naf;
d560 1
a560 2
getinfo(ifr)
	struct ifreq *ifr;
d584 1
a584 2
printif(ifrm, ifaliases)
	struct ifreq *ifrm;
d751 1
a751 3
setifaddr(addr, param)
	char *addr;
	int param;
d766 1
a766 3
settunnel(src, dst)
	char *src;
	char *dst;
d804 1
a804 1
deletetunnel()
d812 1
a812 2
setifnetmask(addr)
	char *addr;
d818 1
a818 2
setifbroadaddr(addr)
	char *addr;
d824 1
a824 2
setifipdst(addr)
	char *addr;
d835 1
a835 3
notealias(addr, param)
	char *addr;
	int param;
d850 1
a850 3
notrailers(vname, value)
	char *vname;
	int value;
d857 1
a857 3
setifdstaddr(addr, param)
	char *addr;
	int param;
d869 1
a869 3
setifflags(vname, value)
	char *vname;
	int value;
d892 1
a892 3
setia6flags(vname, value)
	char *vname;
	int value;
d903 1
a903 3
setia6pltime(val, d)
	char *val;
	int d;
d910 1
a910 3
setia6vltime(val, d)
	char *val;
	int d;
d917 1
a917 3
setia6lifetime(cmd, val)
	char *cmd;
	char *val;
d938 1
a938 3
setia6eui64(cmd, val)
	const char *cmd;
	int val;
d972 1
a972 2
setifmetric(val)
	char *val;
d985 1
a985 3
setifmtu(val, d)
	char *val;
	int d;
d998 1
a998 4
get_string(val, sep, buf, lenp)
	const char *val, *sep;
	u_int8_t *buf;
	int *lenp;
d1051 1
a1051 3
print_string(buf, len)
	const u_int8_t *buf;
	int len;
d1080 1
a1080 3
setifnwid(val, d)
	const char *val;
	int d;
d1096 1
a1096 3
setifnwkey(val, d)
	const char *val;
	int d;
d1159 1
a1159 3
setifpowersave(val, d)
	const char *val;
	int d;
d1175 1
a1175 3
setifpowersavesleep(val, d)
	const char *val;
	int d;
d1191 1
a1191 1
ieee80211_status()
d1279 1
a1279 1
init_current_media()
d1309 1
a1309 1
process_media_commands()
d1332 1
a1332 3
setmedia(val, d)
	char *val;
	int d;
d1364 1
a1364 3
setmediaopt(val, d)
	char *val;
	int d;
d1383 1
a1383 3
unsetmediaopt(val, d)
	char *val;
	int d;
d1407 1
a1407 3
setmediainst(val, d)
	char *val;
	int d;
d1444 1
a1444 2
get_media_type_string(mword)
	int mword;
d1457 1
a1457 2
get_media_subtype_string(mword)
	int mword;
d1471 1
a1471 3
get_media_subtype(type, val)
	int type;
	const char *val;
d1484 1
a1484 3
get_media_options(type, val)
	int type;
	const char *val;
d1511 2
a1512 4
lookup_media_word(desc, type, val)
	const struct ifmedia_description *desc;
	int type;
	const char *val;
d1524 1
a1524 2
print_media_word(ifmw, print_type, as_syntax)
	int ifmw, print_type, as_syntax;
d1556 1
a1556 2
phys_status(force)
	int force;
d1606 1
a1606 3
status(link, sdl)
	int link;
	struct sockaddr_dl *sdl;
d1727 1
a1727 2
in_status(force)
	int force;
d1788 1
a1788 3
setifprefixlen(addr, d)
	char *addr;
	int d;
d1797 1
a1797 2
in6_fillscopeid(sin6)
	struct sockaddr_in6 *sin6;
d1810 1
a1810 2
in6_alias(creq)
	struct in6_ifreq *creq;
d1925 1
a1925 2
in6_status(force)
	int force;
d1934 1
a1934 2
at_status(force)
	int force;
d1990 1
a1990 2
xns_status(force)
	int force;
d2028 1
a2028 3
setipxframetype(vname, type)
	char	*vname;
	int	type;
d2046 1
a2046 2
ipx_status(force)
	int force;
d2100 1
a2100 2
iso_status(force)
	int force;
d2156 1
a2156 3
in_getaddr(s, which)
	char *s;
	int which;
d2177 1
a2177 3
in_getprefix(plen, which)
	char *plen;
	int which;
d2203 1
a2203 4
printb(s, v, bits)
	char *s;
	char *bits;
	unsigned short v;
d2237 1
a2237 3
in6_getaddr(s, which)
	char *s;
	int which;
d2276 1
a2276 3
in6_getprefix(plen, which)
	char *plen;
	int which;
d2299 1
a2299 3
prefix(val, size)
	void *val;
	int size;
d2325 1
a2325 3
at_getaddr(addr, which)
	char *addr;
	int which;
d2342 1
a2342 3
setatrange(range, d)
	char *range;
	int d;
d2355 1
a2355 3
setatphase(phase, d)
	char *phase;
	int d;
d2366 1
a2366 2
checkatrange(sat)
	struct sockaddr_at *sat;
d2389 1
a2389 3
xns_getaddr(addr, which)
	char *addr;
	int which;
d2407 1
a2407 3
ipx_getaddr(addr, which)
	char *addr;
	int which;
d2426 1
a2426 3
iso_getaddr(addr, which)
	char *addr;
	int which;
d2442 1
a2442 2
setsnpaoffset(val)
	char *val;
d2448 1
a2448 2
setnsellength(val)
	char *val;
d2458 1
a2458 2
fixnsel(s)
	struct sockaddr_iso *s;
d2466 1
a2466 1
adjust_nsellength()
d2476 1
a2476 1
usage()
d2503 2
a2504 1
void vlan_status()
d2522 2
a2523 3
void setvlantag(val, d)
	char *val;
	int d;
d2545 2
a2546 3
void setvlandev(val, d)
	char *val;
	int d;
d2568 2
a2569 3
void unsetvlandev(val, d)
	char *val;
	int d;
d2592 1
a2592 2
sec2str(total)
	time_t total;
@


1.74
log
@move ETHERTYPE_xx declarations to <net/ethertypes.h>.  meets netbsd practice.
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.73 2003/03/16 05:20:27 margarida Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d80 1
a80 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.73 2003/03/16 05:20:27 margarida Exp $";
@


1.73
log
@modifed -> modified
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.72 2002/11/24 20:39:28 henning Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.72 2002/11/24 20:39:28 henning Exp $";
d150 1
a150 1
int	ipx_type = ETHERTYPE_II;
d277 5
a281 5
	{ "802.2",	ETHERTYPE_8022,	0,		setipxframetype },
	{ "802.2tr",	ETHERTYPE_8022TR, 0,		setipxframetype },
	{ "802.3",	ETHERTYPE_8023,	0,		setipxframetype },
	{ "snap",	ETHERTYPE_SNAP,	0,		setipxframetype },
	{ "EtherII",	ETHERTYPE_II,	0,		setipxframetype },
d2169 5
a2173 5
			{ ETHERTYPE_8022, "802.2" },
			{ ETHERTYPE_8022TR, "802.2tr" },
			{ ETHERTYPE_8023, "802.3" },
			{ ETHERTYPE_SNAP, "SNAP" },
			{ ETHERTYPE_II,  "EtherII" },
@


1.72
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.71 2002/11/24 17:39:04 henning Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.71 2002/11/24 17:39:04 henning Exp $";
d210 1
a210 1
 * is given, the current media word is modifed.  `mediaopt' commands
@


1.71
log
@consistency: use sin6 as variable name for sockaddr_in6, not sin
no functional changes

ok millert@@ pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.70 2002/11/23 15:08:50 henning Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.70 2002/11/23 15:08:50 henning Exp $";
d1000 1
a1000 1
		errx(1, "could not determine link local address"); 
@


1.70
log
@typo (in #ifdef'd out code, but well...); Michal Ludvig <michal at logix.cz>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.69 2002/07/08 00:48:54 deraadt Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.69 2002/07/08 00:48:54 deraadt Exp $";
d2374 1
a2374 1
	struct sockaddr_in6 *sin = sin6tab[which];
d2380 1
a2380 1
	sin->sin6_len = sizeof(*sin);
d2382 1
a2382 1
		sin->sin6_family = AF_INET6;
d2384 1
a2384 1
		memset(&sin->sin6_addr, 0xff, sizeof(struct in6_addr));
d2387 2
a2388 2
	memset((void *)&sin->sin6_addr, 0x00, sizeof(sin->sin6_addr));
	for (cp = (u_char *)&sin->sin6_addr; len > 7; len -= 8)
@


1.69
log
@make failed SIOCG80211NWKEY print alert more clearly; jolan@@norm.encryptedemail.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.68 2002/06/19 18:53:53 millert Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.68 2002/06/19 18:53:53 millert Exp $";
d2336 1
a2336 1
	sin->sin6_len = sizeof(*sin6);
@


1.68
log
@Since we can no longer count on isprint() to tell us whether or not
a character is 7-bit ASCII, check the high bit by hand when deciding
whether to print a WEP key as ASCII or hex.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.67 2002/06/14 09:12:43 itojun Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.67 2002/06/14 09:12:43 itojun Exp $";
d1276 1
a1276 1
			puts("*****");
@


1.67
log
@add "eui64" option.  from ww@@styx.org.  sync usage with reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.66 2002/06/14 01:07:45 itojun Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.66 2002/06/14 01:07:45 itojun Exp $";
d1105 2
a1106 1
			if (!isprint(buf[i]))
@


1.66
log
@metric and mtu are u_long, not int.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.65 2002/06/10 22:18:48 markus Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.65 2002/06/10 22:18:48 markus Exp $";
d192 1
d270 1
d971 35
d2594 1
a2594 1
		"\t[media media_type] [mediaopt media_option]\n"
d2597 3
a2599 3
		"\t[ nwid netword_id ]\n"
		"\t[ tunnel srcaddress dstaddress ]\n"
		"\t[ deletetunnel ]\n"
d2602 2
@


1.65
log
@print ethernet address; ok provos@@, itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.64 2002/05/22 08:21:02 deraadt Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.64 2002/05/22 08:21:02 deraadt Exp $";
d152 2
a153 1
int	flags, metric, mtu, setaddr, setipdst, doalias;
d921 1
d934 1
d943 1
d975 2
d978 3
a980 1
	ifr.ifr_metric = atoi(val);
d990 2
d993 3
a995 1
	ifr.ifr_mtu = atoi(val);
d1650 1
a1650 1
		printf(" metric %d", metric);
d1652 1
a1652 1
		printf(" mtu %d", mtu);
@


1.64
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.63 2002/04/26 04:40:42 fgsch Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.63 2002/04/26 04:40:42 fgsch Exp $";
d95 1
d308 1
a308 1
void	status(int);
d634 1
a634 1
			status(1);
d712 1
a712 1
			status(1);
d1627 1
a1627 1
status(link)
d1629 1
d1642 3
@


1.63
log
@use struct in_aliasreq instead of ifaliasreq when setting new inet
address. solves a sigbus error seen on sparc64 with new binutils.
from itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.62 2002/04/25 08:55:16 itojun Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.62 2002/04/25 08:55:16 itojun Exp $";
d1858 2
a1859 2
			hbuf, sizeof(hbuf), NULL, 0, niflag) != 0)
		strcpy(hbuf, "");
d1876 2
a1877 2
				hbuf, sizeof(hbuf), NULL, 0, niflag) != 0)
			strcpy(hbuf, "");
@


1.62
log
@no need for __alignment__, it was paste error.  from fgs/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.61 2002/04/10 18:52:27 millert Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.61 2002/04/10 18:52:27 millert Exp $";
d138 1
d361 1
a361 1
	     SIOCDIFADDR, SIOCAIFADDR, C(ridreq), C(addreq) },
d2182 2
a2183 2
SIN(ridreq.ifr_addr), SIN(addreq.ifra_addr),
SIN(addreq.ifra_mask), SIN(addreq.ifra_broadaddr)};
@


1.61
log
@Add missing IFM_OPTIONS macro.  Previously 'ifconfig -mediaopt' could
clear bits other than media options.  Fix from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.60 2002/02/23 22:07:20 millert Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.60 2002/02/23 22:07:20 millert Exp $";
d141 1
a141 1
struct	in6_aliasreq	in6_addreq __attribute__((aligned(4)));
@


1.60
log
@Add support for nwkey and powersave; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.59 2002/02/21 23:05:13 millert Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.59 2002/02/21 23:05:13 millert Exp $";
d1518 1
a1518 1
		rval |= option;
@


1.59
log
@i_nwid is not a NUL-terminated string.  Use the length parameter for the
length and sanity check against IEEE80211_NWID_LEN.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.58 2002/02/19 01:16:38 mickey Exp $	*/
d38 1
a38 1
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.58 2002/02/19 01:16:38 mickey Exp $";
d171 4
a174 1
void	setifnwid(char *, int);
d251 5
d308 2
d986 86
d1074 1
a1074 1
	char *val;
d1078 1
d1080 4
a1083 5
	memset(&nwid, 0, sizeof(nwid));
	nwid.i_len = strlen(val);
	if (nwid.i_len > IEEE80211_NWID_LEN)
		nwid.i_len = IEEE80211_NWID_LEN;
	memcpy(nwid.i_nwid, val, nwid.i_len);
d1091 101
d1194 1
a1194 1
	int len;
d1196 3
a1198 1
	char buf[IEEE80211_NWID_LEN + 1];
d1208 68
a1275 3
		memcpy(buf, nwid.i_nwid, len);
		buf[len] = '\0';
		printf("\tnwid %s\n", buf);
@


1.58
log
@when printing out the option list compare the option part only; fixes 802.11 mediaopt printing
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.57 2002/02/17 19:42:27 millert Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.57 2002/02/17 19:42:27 millert Exp $";
d984 4
a987 2
	(void)strlcpy(nwid.i_nwid, val, sizeof(nwid.i_nwid));
	nwid.i_len = sizeof(nwid.i_nwid);
d997 1
d1005 7
a1011 2
		(void) strlcpy(buf, nwid.i_nwid, sizeof(buf));
		printf("\tnwid %s\n", nwid.i_nwid);
@


1.57
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.56 2002/02/16 21:27:35 millert Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.56 2002/02/16 21:27:35 millert Exp $";
d1284 1
a1284 1
		    (ifmw & desc->ifmt_word) != 0 &&
@


1.56
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.55 2001/11/13 18:08:21 mickey Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.55 2001/11/13 18:08:21 mickey Exp $";
d306 2
a307 2
int	lookup_media_word __P((const struct ifmedia_description *, int,
	    const char *));
@


1.55
log
@make setting ipx frame type work; from Ian McWilliam <ianm@@cit.uws.edu.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.54 2001/11/05 07:39:16 mpech Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.54 2001/11/05 07:39:16 mpech Exp $";
d162 19
a180 19
void	notealias __P((char *, int));
void	notrailers __P((char *, int));
void	setifaddr __P((char *, int));
void	setifdstaddr __P((char *, int));
void	setifflags __P((char *, int));
void	setifbroadaddr __P((char *));
void	setifipdst __P((char *));
void	setifmetric __P((char *));
void	setifmtu __P((char *, int));
void	setifnwid __P((char *, int));
void	setifnetmask __P((char *));
void	setifprefixlen __P((char *, int));
void	setnsellength __P((char *));
void	setsnpaoffset __P((char *));
void	setipxframetype __P((char *, int));
void    setatrange __P((char *, int));
void    setatphase __P((char *, int));
void    settunnel __P((char *, char *));
void    deletetunnel __P((void));
d182 4
a185 4
void	setia6flags __P((char *, int));
void	setia6pltime __P((char *, int));
void	setia6vltime __P((char *, int));
void	setia6lifetime __P((char *, char *));
d187 8
a194 8
void    checkatrange __P ((struct sockaddr_at *));
void	setmedia __P((char *, int));
void	setmediaopt __P((char *, int));
void	unsetmediaopt __P((char *, int));
void	setmediainst __P((char *, int));
void	setvlantag __P((char *, int));
void	setvlandev __P((char *, int));
void	unsetvlandev __P((char *, int));
d196 3
a198 3
void	fixnsel __P((struct sockaddr_iso *));
int	main __P((int, char *[]));
int	prefix __P((void *val, int));
d294 5
a298 5
int	getinfo __P((struct ifreq *));
void	getsock __P((int));
void	printif __P((struct ifreq *, int));
void	printb __P((char *, unsigned short, char *));
void	status __P((int));
d300 1
a300 1
char	*sec2str __P((time_t));
d302 4
a305 4
const char *get_media_type_string __P((int));
const char *get_media_subtype_string __P((int));
int	get_media_subtype __P((int, const char *));
int	get_media_options __P((int, const char *));
d308 3
a310 3
void	print_media_word __P((int, int, int));
void	process_media_commands __P((void));
void	init_current_media __P((void));
d316 3
a318 3
void	in_status __P((int));
void	in_getaddr __P((char *, int));
void	in_getprefix __P((char *, int));
d320 5
a324 5
void	in6_fillscopeid __P((struct sockaddr_in6 *sin6));
void	in6_alias __P((struct in6_ifreq *));
void	in6_status __P((int));
void	in6_getaddr __P((char *, int));
void	in6_getprefix __P((char *, int));
d326 9
a334 9
void    at_status __P((int));
void    at_getaddr __P((char *, int));
void	xns_status __P((int));
void	xns_getaddr __P((char *, int));
void	ipx_status __P((int));
void	ipx_getaddr __P((char *, int));
void	iso_status __P((int));
void	iso_getaddr __P((char *, int));
void	ieee80211_status __P((void));
@


1.54
log
@kill more registers;

millert@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: ifconfig.c,v 1.53 2001/10/30 22:00:15 millert Exp $	*/
/*      $NetBSD: ifconfig.c,v 1.40 1997/10/01 02:19:43 enami Exp $      */
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.53 2001/10/30 22:00:15 millert Exp $";
d155 2
a156 2
int     dflag, mflag, lflag, uflag;
int     reset_if_flags;
d162 8
a169 8
void 	notealias __P((char *, int));
void 	notrailers __P((char *, int));
void 	setifaddr __P((char *, int));
void 	setifdstaddr __P((char *, int));
void 	setifflags __P((char *, int));
void 	setifbroadaddr __P((char *));
void 	setifipdst __P((char *));
void 	setifmetric __P((char *));
d172 1
a172 1
void 	setifnetmask __P((char *));
d174 2
a175 2
void 	setnsellength __P((char *));
void 	setsnpaoffset __P((char *));
d178 1
a178 1
void    setatphase __P((char *, int));  
d182 1
a182 1
void 	setia6flags __P((char *, int));
d204 1
a204 1
 * only modify the set and clear words.  They then operate on the   
d220 1
a220 1
#define NEXTARG2        0xfffffe
d274 3
a276 3
	{ "giftunnel",  NEXTARG2,       0,              settunnel } ,
	{ "tunnel",  	NEXTARG2,       0,              settunnel } ,
	{ "deletetunnel",  0,       	0,              deletetunnel } ,
d290 1
a290 1
	{ NULL, /*illegal*/0,		0,		NULL },	
d293 1
a293 1
void 	adjust_nsellength();
d297 3
a299 3
void 	printb __P((char *, unsigned short, char *));
void 	status __P((int));
void 	usage();
d317 2
a318 2
void 	in_getaddr __P((char *, int));
void 	in_getprefix __P((char *, int));
d323 2
a324 2
void 	in6_getaddr __P((char *, int));
void 	in6_getprefix __P((char *, int));
d328 6
a333 6
void 	xns_status __P((int));
void 	xns_getaddr __P((char *, int));
void 	ipx_status __P((int));
void 	ipx_getaddr __P((char *, int));
void 	iso_status __P((int));
void 	iso_getaddr __P((char *, int));
d380 1
a380 1
	if (argc < 2) 
d456 1
a456 1
			        if ((argv[1] == NULL) ||
d482 1
a482 1
  
d807 2
a808 2
        if (ioctl(s, SIOCDIFPHYADDR, &ifr) < 0)
                warn("SIOCDIFPHYADDR");
d890 1
a890 1
 	flags = my_ifr.ifr_flags;
d1490 1
a1490 1
 	 * to the primary interface netmask/dstaddr/broadaddr, if
d1617 1
a1617 1
					       sizeof(struct in6_addr)));
d1690 1
a1690 1
 
d1716 1
a1716 1
	if (flags & IFF_POINTOPOINT) {  
d1785 2
d1788 10
d2103 1
a2103 1
	sat->sat_len = sizeof(*sat);    
d2112 1
a2112 1
	
d2119 1
a2119 1
	
d2127 1
a2127 1
 
d2135 1
a2135 1
	else if (!strcmp(phase, "2"))  
d2140 1
a2140 1
	
d2146 1
a2146 1
		at_nr.nr_phase = 2;     /* Default phase 2 */
d2299 2
a2300 2
		       vreq.vlr_tag, vreq.vlr_parent[0] == '\0' ?
	               "<none>" : vreq.vlr_parent);
@


1.53
log
@strncpy() -> strlcpy(); from Jean-Francois Brousseau
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.52 2001/08/19 01:51:34 itojun Exp $	*/
d84 1
a84 1
static const char rcsid[] = "$OpenBSD: ifconfig.c,v 1.52 2001/08/19 01:51:34 itojun Exp $";
d375 1
a375 1
	register const struct afswtch *rafp = NULL;
d437 1
a437 1
		register const struct cmd *p;
d629 1
a629 1
			register const struct afswtch *p;
d707 1
a707 1
			register const struct afswtch *p;
d1356 1
a1356 1
	register const struct afswtch *p = afp;
d1905 1
a1905 1
	register struct sockaddr_in *sin = sintab[which];
d1928 2
a1929 2
	register struct sockaddr_in *sin = sintab[which];
	register u_char *cp;
d1954 2
a1955 2
	register char *bits;
	register unsigned short v;
d1957 2
a1958 2
	register int i, any = 0;
	register char c;
d2034 2
a2035 2
	register struct sockaddr_in6 *sin = sin6tab[which];
	register u_char *cp;
d2059 2
a2060 2
	register u_char *name = (u_char *)val;
	register int byte, bit, plen = 0;
d2199 1
a2199 1
	register struct sockaddr_iso *siso = sisotab[which];
d2232 1
a2232 1
	register struct sockaddr_iso *s;
@


1.52
log
@fix buffer underrun on 1.51
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.51 2001/08/18 20:39:43 deraadt Exp $	*/
d75 1
a75 1
static char copyright[] =
d82 1
a82 1
static char sccsid[] = "@@(#)ifconfig.c	8.2 (Berkeley) 2/16/94";
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.51 2001/08/18 20:39:43 deraadt Exp $";
d149 1
a149 1
char	name[30];
d403 1
a403 1
		strncpy(name, *argv, sizeof(name) - 1);
d405 1
a405 1
		strncpy(name, *argv, sizeof(name) - 1);
d422 1
a422 1
	strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
d521 1
a521 1
		strncpy(rafp->af_ridreq, name, sizeof ifr.ifr_name);
d530 1
a530 1
		strncpy(rafp->af_addreq, name, sizeof ifr.ifr_name);
d597 1
a597 1
		strncpy(name, ifa->ifa_name, sizeof(name));
d614 1
a614 1
		strncpy(ifrp->ifr_name, ifa->ifa_name, sizeof(ifrp->ifr_name));
d695 1
a695 1
		strncpy(name, ifrp->ifr_name, sizeof(ifrp->ifr_name));
d794 1
a794 1
	strncpy(req.iflr_name, name, sizeof(req.iflr_name));
d889 1
a889 1
	strncpy(my_ifr.ifr_name, name, sizeof (my_ifr.ifr_name));
d959 1
a959 1
	strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d970 1
a970 1
	(void) strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d984 1
a984 1
	(void)strncpy(nwid.i_nwid, val, sizeof(nwid.i_nwid));
d986 1
a986 1
	(void)strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d1000 1
a1000 1
	(void)strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d1002 1
a1002 2
		strncpy(buf, nwid.i_nwid, sizeof(buf) - 1);
		buf[IEEE80211_NWID_LEN] = '\0';
d1018 1
a1018 1
		(void) strncpy(ifmr.ifm_name, name, sizeof(ifmr.ifm_name));
d1053 1
a1053 1
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d1318 1
a1318 1
	strncpy(req.iflr_name, name, IFNAMSIZ);
d1374 1
a1374 1
	(void) strncpy(ifmr.ifm_name, name, sizeof(ifmr.ifm_name));
d1484 1
a1484 1
	strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d1496 1
a1496 1
	strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d1512 1
a1512 1
		strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d1525 1
a1525 1
		strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d1591 1
a1591 1
		(void) strncpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
d1609 1
a1609 1
	(void) strncpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
d1621 1
a1621 1
	(void) strncpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
d1645 1
a1645 1
		(void) strncpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
d1698 1
a1698 1
	(void) strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d1707 1
a1707 1
	(void) strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
d1724 1
a1724 1
		(void) strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d1754 1
a1754 1
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d1763 1
a1763 1
	strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
d1773 1
a1773 1
		strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d1801 1
a1801 1
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d1810 1
a1810 1
	strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
d1820 1
a1820 1
		strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d1857 1
a1857 1
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d1866 1
a1866 1
	strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
d1884 1
a1884 1
		strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
d2332 1
a2332 1
	strncpy(vreq.vlr_parent, val, sizeof(vreq.vlr_parent));
@


1.51
log
@more careful with snprintf result code
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.50 2001/07/25 17:41:06 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.50 2001/07/25 17:41:06 itojun Exp $";
d2388 1
a2388 1
			p -= n;
d2395 1
a2395 1
			p -= n;
d2402 1
a2402 1
			p -= n;
@


1.50
log
@do not write into s6_addr[16] (out of bounds).
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.49 2001/07/07 18:26:13 deraadt Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.49 2001/07/07 18:26:13 deraadt Exp $";
d2375 1
d2385 4
a2388 1
			p += snprintf(p, end - p, "%dd", days);
d2392 4
a2395 1
			p += snprintf(p, end - p, "%dh", hours);
d2399 4
a2402 1
			p += snprintf(p, end - p, "%dm", mins);
@


1.49
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.48 2001/05/07 13:53:26 markus Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.48 2001/05/07 13:53:26 markus Exp $";
d1945 2
a1946 1
	*cp = 0xff << (8 - len);
d2051 2
a2052 1
	*cp = 0xff << (8 - len);
@


1.48
log
@tunneldelete -> deletetunnel
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.47 2001/05/02 06:44:23 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.47 2001/05/02 06:44:23 itojun Exp $";
d198 1
d375 1
a375 1
	register const struct afswtch *rafp;
@


1.47
log
@implement "deletetunnel" (removes tunnel outer IP address pair)
rename "giftunnel" intto "tunnel", to reduce diffs with netbsd.
(giftunnel is still usable for backward compat)

markus and niels ok'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.46 2001/03/01 08:34:37 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.46 2001/03/01 08:34:37 itojun Exp $";
d275 1
a275 1
	{ "tunneldelete",  0,       	0,              deletetunnel } ,
@


1.46
log
@on "giftunnel" configuration, use specified address family
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.45 2001/02/20 13:50:53 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.45 2001/02/20 13:50:53 itojun Exp $";
d179 2
a180 1
void    gifsettunnel __P((char *, char *));
d272 4
a275 1
	{ "giftunnel",  NEXTARG2,       0,              gifsettunnel } ,
d764 1
a764 1
gifsettunnel(src, dst)
d804 8
d2257 2
a2258 1
		"\t[ giftunnel srcaddress dstaddress ]\n"
@


1.45
log
@provide SIOC[SG]LIFPHYADDR, which greatly simplify userland manipulation.
sync with kame.  old ioctls are kept but not really recommended.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.44 2001/01/18 04:46:03 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.44 2001/01/18 04:46:03 itojun Exp $";
d770 1
d772 1
a772 1
	if ((ecode = getaddrinfo(src, NULL, NULL, &srcres)) != 0)
d776 1
a776 1
	if ((ecode = getaddrinfo(dst, NULL, NULL, &dstres)) != 0)  
d2007 1
a2007 1
		*(u_int16_t *)&sin6->sin6_addr.s6_addr[2] = 
@


1.44
log
@permit prefixlen against inet address, like:
# ifconfig fxp0 10.0.0.1 prefixlen 23
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.43 2000/12/30 21:56:44 angelos Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.43 2000/12/30 21:56:44 angelos Exp $";
a764 1
	struct ifaliasreq addreq;
d766 1
a766 3
#ifdef INET6
	struct in6_aliasreq in6_addreq;
#endif /* INET6 */
d771 1
a771 1
	if ((ecode = getaddrinfo(src, NULL, &hints, &srcres)) != 0)
d773 1
a773 1
		     gai_strerror(ecode));
d775 1
a775 1
	if ((ecode = getaddrinfo(dst, NULL, &hints, &dstres)) != 0)
d777 1
a777 1
		     gai_strerror(ecode));
d781 1
a781 11
		     "source and destination address families do not match");

	switch (srcres->ai_addr->sa_family)
	{
	    case AF_INET:
		bzero(&addreq, sizeof(addreq));
		strncpy(addreq.ifra_name, name, IFNAMSIZ);
		bcopy(srcres->ai_addr, &addreq.ifra_addr,
		      srcres->ai_addr->sa_len);
		bcopy(dstres->ai_addr, &addreq.ifra_dstaddr,
		      dstres->ai_addr->sa_len);
d783 10
a792 22
		if (ioctl(s, SIOCSIFPHYADDR, (struct ifreq *) &addreq) < 0)
		  warn("SIOCSIFPHYADDR");
		break;

#ifdef INET6
	    case AF_INET6:
		bzero(&in6_addreq, sizeof(in6_addreq));
		strncpy(in6_addreq.ifra_name, name, IFNAMSIZ);
		bcopy(srcres->ai_addr, &in6_addreq.ifra_addr,
		      srcres->ai_addr->sa_len);
		bcopy(dstres->ai_addr, &in6_addreq.ifra_dstaddr,
		      dstres->ai_addr->sa_len);

		if (ioctl(s, SIOCSIFPHYADDR_IN6,
			  (struct ifreq *) &in6_addreq) < 0)
		  warn("SIOCSIFPHYADDR");
		break;
#endif /* INET6 */

	    default:
		warn("address family not supported");
	}
d1294 1
a1294 3
	u_long srccmd, dstcmd;
	struct ifreq *ifrp;
	char *ver = "";
d1300 1
a1300 4
#ifdef INET6
	struct in6_ifreq in6_ifr;
	int s6;
#endif /* INET6 */
a1301 1
	force = 0;	/*fool gcc*/
d1304 4
d1309 5
a1313 20
	bzero(&in6_ifr, sizeof(in6_ifr));
	strncpy(in6_ifr.ifr_name, name, IFNAMSIZ);
	s6 = socket(AF_INET6, SOCK_DGRAM, 0);
	if (s6 < 0) {
		ifrp = &ifr;
		srccmd = SIOCGIFPSRCADDR;
		dstcmd = SIOCGIFPDSTADDR;
	} else {
		close(s6);
		srccmd = SIOCGIFPSRCADDR_IN6;
		dstcmd = SIOCGIFPDSTADDR_IN6;
		ifrp = (struct ifreq *) &in6_ifr;
	}
#else /* INET6 */
	ifrp = &ifr;
	srccmd = SIOCGIFPSRCADDR;
	dstcmd = SIOCGIFPDSTADDR;
#endif /* INET6 */

	if (0 <= ioctl(s, srccmd, (caddr_t)ifrp)) {
d1315 2
a1316 2
		if (ifrp->ifr_addr.sa_family == AF_INET6)
			in6_fillscopeid((struct sockaddr_in6 *)&ifrp->ifr_addr);
a1317 6
		getnameinfo(&ifrp->ifr_addr, ifrp->ifr_addr.sa_len,
			    psrcaddr, NI_MAXHOST, 0, 0, niflag);
#ifdef INET6
		if (ifrp->ifr_addr.sa_family == AF_INET6)
			ver = "6";
#endif /* INET6 */
a1318 1
		if (0 <= ioctl(s, dstcmd, (caddr_t)ifrp)) {
d1320 2
a1321 4
			if (ifrp->ifr_addr.sa_family == AF_INET6) {
				in6_fillscopeid((struct sockaddr_in6 *)
				    &ifrp->ifr_addr);
			}
d1323 2
a1324 3
		        getnameinfo(&ifrp->ifr_addr, ifrp->ifr_addr.sa_len,
				    pdstaddr, NI_MAXHOST, 0, 0, niflag);
		}
d1326 2
a1327 3
		printf("\tphysical address inet%s %s --> %s\n", ver,
		       psrcaddr, pdstaddr);
	}
@


1.43
log
@Remove the dstsa/srcsa/clearsa directives, the bridge will be using
the gif interface instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.42 2000/12/18 07:00:17 mickey Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.42 2000/12/18 07:00:17 mickey Exp $";
d313 1
d344 1
a344 1
	{ "inet", AF_INET, in_status, in_getaddr, NULL,
d1961 24
@


1.42
log
@fix nwid get/set
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.41 2000/11/10 18:18:05 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.41 2000/11/10 18:18:05 itojun Exp $";
a179 3
void	dstsa __P((char *));
void	srcsa __P((char *));
void	clearsa __P((char *));
a271 3
	{ "dstsa",	NEXTARG,	0,		dstsa } ,
	{ "srcsa",	NEXTARG,	0,		srcsa } ,
	{ "clearsa",	NEXTARG,	0,		clearsa } ,
a821 91
static void
handlesa(cmd, sa)
        int cmd;
	char *sa;
{
	char *p1, *p2, *p;
	struct ifsa ifsa;
	struct addrinfo *res;
	struct protoent *prnt;
	int ecode;

	bzero(&ifsa, sizeof(ifsa));

	strlcpy(ifsa.sa_ifname, name, sizeof ifsa.sa_ifname);

	p1 = strchr(sa, '/');
	if (p1 == NULL)
		errx(1, "invalid SA");
	else
		*(p1++) = '\0';

	if (*p1 == '/')
		errx(1, "missing SPI");

	p2 = strchr(p1, '/');
	if (p2 == NULL)
		errx(1, "invalid SA");
	else
		*(p2++) = '\0';

	if (*p2 == '\0')
		errx(1, "invalid security protocol");

	if ((ecode = getaddrinfo(sa, NULL, NULL, &res)) != 0)
		errx(1, "error in parsing address string: %s",
		     gai_strerror(ecode));

	bcopy(res->ai_addr, &ifsa.sa_dst, res->ai_addr->sa_len);

	freeaddrinfo(res);

	ifsa.sa_spi = htonl(strtoul(p1, &p, 16));
	if ((p == NULL) || ((*p != '\0') && (*p != '/')))
		errx(1, "bad SPI");

	ifsa.sa_proto = strtoul(p2, &p, 10);
	if ((p == NULL) || (*p != '\0')) {
		prnt = getprotobyname(p2);
		if (prnt == NULL)
			errx(1, "bad security protocol");
		ifsa.sa_proto = prnt->p_proto;
	}

	if (ioctl(s, cmd, (caddr_t)&ifsa) < 0) {
		switch (cmd) {
	      	case SIOCSENCDSTSA:
			warn("SIOCSENCDSTSA");
		  	break;

	      	case SIOCSENCSRCSA:
		  	warn("SIOCSENCSRCSA");
		  	break;

	      	case SIOCSENCCLEARSA:
		  	warn("SIOCSENCCLEARSA");
		  	break;
	  	}
	}
}

void
dstsa(sa)
        char *sa;
{
        handlesa(SIOCSENCDSTSA, sa);
}

void
srcsa(sa)
        char *sa;
{
        handlesa(SIOCSENCSRCSA, sa);
}

void
clearsa(sa)
        char *sa;
{
        handlesa(SIOCSENCCLEARSA, sa);
}

a2271 3
		"\t[ dstsa address/spi/protocol ]\n"
		"\t[ srcsa address/spi/protocol ]\n"
		"\t[ clearsa address/spi/protocol ]\n"
@


1.41
log
@show pltime=0 address as "deprecated".  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.40 2000/08/03 07:34:41 angelos Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.40 2000/08/03 07:34:41 angelos Exp $";
d1088 1
a1088 1
	u_int8_t nwid[IEEE80211_NWID_LEN];
d1091 2
a1092 1
	(void)strncpy(nwid, val, sizeof(nwid));
d1094 1
a1094 1
	ifr.ifr_data = (caddr_t)nwid;
d1102 2
a1103 1
	u_int8_t nwid[IEEE80211_NWID_LEN + 1];
d1106 1
a1106 1
	ifr.ifr_data = (caddr_t)nwid;
d1108 5
a1112 3
	nwid[IEEE80211_NWID_LEN] = 0;
	if (ioctl(s, SIOCG80211NWID, (caddr_t)&ifr) == 0)
		printf("\tnwid %s\n", nwid);
@


1.40
log
@Fix compilation in non-INET6 case (rfunk@@funknet.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.39 2000/06/30 18:17:58 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.39 2000/06/30 18:17:58 itojun Exp $";
d628 1
a628 1
		if (!strcmp(namep, ifa->ifa_name)) {
a647 1

d1767 2
d2100 2
a2101 1
	struct sockaddr_in6 *sin = sin6tab[which];
d2103 1
a2103 1
	sin->sin6_len = sizeof(*sin);
d2105 1
a2105 1
		sin->sin6_family = AF_INET6;
d2107 14
a2120 1
	if (inet_pton(AF_INET6, s, &sin->sin6_addr) != 1)
d2122 12
@


1.40.2.1
log
@Pull in patch from current:
Fix (mickey):
fix nwid get/set
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.40 2000/08/03 07:34:41 angelos Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.40 2000/08/03 07:34:41 angelos Exp $";
d1089 1
a1089 1
	struct ieee80211_nwid nwid;
d1092 1
a1092 2
	(void)strncpy(nwid.i_nwid, val, sizeof(nwid.i_nwid));
	nwid.i_len = sizeof(nwid.i_nwid);
d1094 1
a1094 1
	ifr.ifr_data = (caddr_t)&nwid;
d1102 1
a1102 2
	struct ieee80211_nwid nwid;
	char buf[IEEE80211_NWID_LEN + 1];
d1105 1
a1105 1
	ifr.ifr_data = (caddr_t)&nwid;
d1107 3
a1109 5
	if (ioctl(s, SIOCG80211NWID, (caddr_t)&ifr) == 0) {
		strncpy(buf, nwid.i_nwid, sizeof(buf) - 1);
		buf[IEEE80211_NWID_LEN] = '\0';
		printf("\tnwid %s\n", nwid.i_nwid);
	}
@


1.39
log
@correct address family handling in "giftunnel".
test with the following:
# ifconfig gif0 inet giftunnel localhost localhost
# ifconfig gif0 inet6 giftunnel localhost localhost
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.38 2000/05/22 03:04:11 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.38 2000/05/22 03:04:11 itojun Exp $";
d1443 1
a1443 1
	ifrp = ifr;
@


1.38
log
@correct gif physical address printing on non-IPv6 kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.37 2000/05/15 11:23:51 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.37 2000/05/15 11:23:51 itojun Exp $";
d770 1
a770 1
        struct addrinfo *srcres, *dstres;
a772 1

d777 4
a780 1
	if ((ecode = getaddrinfo(src, NULL, NULL, &srcres)) != 0)
d784 1
a784 1
	if ((ecode = getaddrinfo(dst, NULL, NULL, &dstres)) != 0)
d789 1
a789 1
	        errx(1,
@


1.37
log
@better scoped address handling on gif physical address printing.
(hide kame ifidx hack)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.36 2000/04/28 04:44:58 chris Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.36 2000/04/28 04:44:58 chris Exp $";
d1420 1
d1429 11
a1439 3
	srccmd = SIOCGIFPSRCADDR_IN6;
	dstcmd = SIOCGIFPDSTADDR_IN6;
	ifrp = (struct ifreq *) &in6_ifr;
@


1.36
log
@Add vlan stuff to usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.35 2000/04/26 19:03:46 chris Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.35 2000/04/26 19:03:46 chris Exp $";
d1413 5
a1417 1

d1438 4
d1443 1
a1443 1
			    psrcaddr, NI_MAXHOST, 0, 0, NI_NUMERICHOST);
d1449 7
a1455 1
		if (0 <= ioctl(s, dstcmd, (caddr_t)ifrp))
d1457 2
a1458 2
				    pdstaddr, NI_MAXHOST, 0, 0,
				    NI_NUMERICHOST);
@


1.35
log
@if_vlan support
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.34 2000/04/14 02:40:01 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.34 2000/04/14 02:40:01 itojun Exp $";
d2317 1
@


1.34
log
@use getifaddrs, instead of SIOCGIFCONF.
XXX ifr/ifr6 manipulation is kind of ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.33 2000/04/14 02:38:21 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.33 2000/04/14 02:38:21 itojun Exp $";
d121 4
d194 4
d270 3
d979 5
d989 5
a993 1
 	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0)
d995 2
a996 2
	strncpy(ifr.ifr_name, name, sizeof (ifr.ifr_name));
 	flags = ifr.ifr_flags;
d1003 2
a1004 2
	ifr.ifr_flags = flags;
	if (ioctl(s, SIOCSIFFLAGS, (caddr_t)&ifr) < 0)
d1476 3
d2324 94
@


1.33
log
@recover "ifconfig -a" and "ifconfig -A" behavior for inet (least surprise).
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.32 2000/04/11 18:08:42 mickey Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.32 2000/04/11 18:08:42 mickey Exp $";
d128 3
d572 73
d728 1
@


1.32
log
@add 802.11's nwid command; add mtu command
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.31 2000/02/18 08:13:31 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.31 2000/02/18 08:13:31 itojun Exp $";
d623 2
a624 2
#if 0
			if (ifaliases == 0 && noinet == 0)
a625 1
#endif
d642 2
a643 1
			noinet = 0;
@


1.31
log
@more alignment fix for SIOCGIFCONF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.30 2000/02/18 05:46:10 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.30 2000/02/18 05:46:10 itojun Exp $";
d100 1
d102 1
d163 2
d212 1
a212 1
struct	cmd {
d236 2
d275 3
a277 3
	{ 0, /*src*/	0,		0,		setifaddr },
	{ 0, /*dst*/	0,		0,		setifdstaddr },
	{ 0, /*illegal*/0,		0,		NULL },	
d293 1
a293 1
int	lookup_media_word __P((struct ifmedia_description *, int,
d320 1
d323 1
a323 1
struct afswtch {
d354 1
a354 1
struct afswtch *afp;	/*the address family being set or asked about*/
d361 1
a361 1
	register struct afswtch *rafp;
d423 1
a423 1
		register struct cmd *p;
d558 4
d621 1
a621 1
			register struct afswtch *p;
d975 39
d1177 1
a1177 1
struct ifmedia_description ifm_type_descriptions[] =
d1180 1
a1180 1
struct ifmedia_description ifm_subtype_descriptions[] =
d1183 1
a1183 1
struct ifmedia_description ifm_option_descriptions[] =
d1190 1
a1190 1
	struct ifmedia_description *desc;
d1204 1
a1204 1
	struct ifmedia_description *desc;
d1261 1
a1261 1
	struct ifmedia_description *desc;
d1278 1
a1278 1
	struct ifmedia_description *desc;
d1354 5
d1367 1
a1367 1
	register struct afswtch *p = afp;
d1375 2
d1379 2
d1391 5
d1403 1
d1415 3
d1419 20
a1438 7
		switch (IFM_TYPE(ifmr.ifm_active)) {
		case IFM_ETHER:
			if (ifmr.ifm_status & IFM_ACTIVE)
				printf("active");
			else
				printf("no carrier");
			break;
d1440 1
a1440 8
		case IFM_FDDI:
		case IFM_TOKEN:
			if (ifmr.ifm_status & IFM_ACTIVE)
				printf("inserted");
			else
				printf("no ring");
			break;
		default:
a1441 1
		}
d2206 1
a2206 1
	fprintf(stderr, "usage: ifconfig interface\n%s",
d2211 2
@


1.30
log
@avoid alignment problem in 64bit arch.
netbsd 1.57 -> 1.58
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.29 2000/02/18 05:23:55 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.29 2000/02/18 05:23:55 itojun Exp $";
d583 5
a587 3
		siz = sizeof(ifrp->ifr_name) +
		    (ifrp->ifr_addr.sa_len > sizeof(struct sockaddr) ?
		    ifrp->ifr_addr.sa_len : sizeof(struct sockaddr));
d600 1
a600 2
			memcpy(&ifr, ifrp, sizeof(ifr));
			ifreq = ifr;
d616 1
a616 1
			memcpy(&ifr, ifrp, sizeof(ifr));
@


1.29
log
@fix unaligned struct access on alpha.
From: =?iso-8859-1?Q?G=F6ran_Bengtson?= <goeran@@cdg.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.28 2000/01/15 23:56:24 angelos Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.28 2000/01/15 23:56:24 angelos Exp $";
d561 1
a561 1
	int i, len = 8192;
d563 1
d583 1
a583 1
		i += sizeof(ifrp->ifr_name) +
d586 6
@


1.28
log
@Add "giftunnel" keyword, obsoleting gifconfig(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.27 2000/01/09 05:56:58 angelos Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.27 2000/01/09 05:56:58 angelos Exp $";
d591 2
a592 1
			ifreq = ifr = *ifrp;
d608 1
a608 1
			ifr = *ifrp;
@


1.27
log
@Use getaddrinfo() in srcsa/dstsa/clearsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.26 1999/12/27 04:19:42 angelos Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.26 1999/12/27 04:19:42 angelos Exp $";
d168 1
d206 1
d254 1
d434 8
d657 62
d1248 47
d1392 2
d1396 1
d2132 1
@


1.26
log
@Handle srcsa/clearsa, and rename setsa to dstsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.25 1999/12/27 03:14:39 angelos Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.25 1999/12/27 03:14:39 angelos Exp $";
d653 3
d679 7
a685 17
#ifdef INET6
	if (strchr(sa, ':'))
	{
		inet_pton(AF_INET6, sa, &ifsa.sa_dst.sin6.sin6_addr);
		ifsa.sa_dst.sin6.sin6_family = AF_INET6;
		ifsa.sa_dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
	}
	else
#endif /* INET6 */
	if (strchr(sa, '.'))
	{
	  	inet_pton(AF_INET, sa, &ifsa.sa_dst.sin.sin_addr);
		ifsa.sa_dst.sin.sin_family = AF_INET;
		ifsa.sa_dst.sin.sin_len = sizeof(struct sockaddr_in);
	}
	else
	  	errx(1, "unknown address family");
d692 22
a713 18
	if ((p == NULL) || (*p != '\0'))
		errx(1, "bad security protocol");

	if (ioctl(s, cmd, (caddr_t)&ifsa) < 0)
	  switch (cmd)
	  {
	      case SIOCSENCDSTSA:
		  warn("SIOCSENCDSTSA");
		  break;

	      case SIOCSENCSRCSA:
		  warn("SIOCSENCSRCSA");
		  break;

	      case SIOCSENCCLEARSA:
		  warn("SIOCSENCCLEARSA");
		  break;
	  }
@


1.25
log
@Implement setsa keyword for enc interface TDB binding.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.24 1999/12/20 09:28:47 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.24 1999/12/20 09:28:47 itojun Exp $";
d168 3
a170 1
void	setsa __P((char *));
d252 3
a254 1
	{ "setsa",	NEXTARG,	0,		setsa } ,
d646 3
a648 2
void
setsa(sa)
d702 36
a737 2
	if (ioctl(s, SIOCSENCSA, (caddr_t)&ifsa) < 0)
		warn("SIOCSENCSA");
d2009 3
a2011 1
		"\t[ setsa address/spi/protocol ]\n"
@


1.24
log
@remove temporary workaround for library dependency problem.
(this was just for kame repository)
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.23 1999/12/08 07:45:30 itojun Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.23 1999/12/08 07:45:30 itojun Exp $";
d99 2
d168 1
d250 1
d643 59
d1970 1
@


1.23
log
@IPv6-enabled ifconfig from KAME.
it now loops through all the aliases on interfaces.
KAME_SCOPEID will be enabled when get{addr,name}info(3) are replaced with
KAME code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.22 1999/02/24 21:26:03 deraadt Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.22 1999/02/24 21:26:03 deraadt Exp $";
a1606 1
#ifndef KAME_SCOPEID
a1622 35
#else
	/*
	 * XXX
	 * we can't use gethostbyname() nor getnetbyname() here due to
	 * library conflicts between libinet6 and libc.
	 * #if 0 should be modified when we do
	 * the complete merger of libinet6 into libc.
	 */
	register struct sockaddr_in *sin = sintab[which];
	struct addrinfo hints, *res;
	int error;
	struct netent *np;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_RAW;
	error = getaddrinfo(s, "NULL", &hints, &res);
	if (error) {
#if 0	/* incompatible behavior! */
		if ((np = getnetbyname(s)) != NULL) {
			memset(sin, 0, sizeof(*sin));
			sin->sin_family = AF_INET;
			sin->sin_len = sizeof(struct sockaddr_in);
			sin->sin_addr = inet_makeaddr(np->n_net, INADDR_ANY);
			return;
		}
#endif

		errx(1, "%s: %s", s, gai_strerror(error));
	}
	if (res->ai_addrlen != sizeof(struct sockaddr_in))
		errx(1, "%s: bad value", s);
	memcpy(sin, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
#endif
@


1.22
log
@only allow src, dst address, not things like "ifconfig xx0 1 2 3 4 5 6"
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.21 1999/02/24 21:24:47 deraadt Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.21 1999/02/24 21:24:47 deraadt Exp $";
d96 2
d127 5
d146 4
d160 1
d166 6
d227 9
d270 1
d288 7
d310 1
d317 1
a317 1
	{ "inet", AF_INET, in_status, in_getaddr,
d319 4
d324 1
a324 1
	{ "atalk", AF_APPLETALK, at_status, at_getaddr,
d326 1
a326 1
	{ "ns", AF_NS, xns_status, xns_getaddr,
d328 1
a328 1
	{ "ipx", AF_IPX, ipx_status, ipx_getaddr,
d330 1
a330 1
	{ "iso", AF_ISO, iso_status, iso_getaddr,
d396 6
d433 10
d582 1
a582 1
			register struct afswtch *p = afp;
d584 1
d587 1
d589 5
d595 7
a601 4
				(*p->af_status)(1);
			} else for (p = afs; p->af_name; p++) {
				ifr.ifr_addr.sa_family = p->af_af;
				(*p->af_status)(0);
d719 53
d1237 147
d1607 1
d1624 35
d1695 72
a1767 1

d1950 37
@


1.21
log
@for things like "ifconfig xx0 up", do not automatically set an address.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.20 1998/09/03 23:08:09 jason Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.20 1998/09/03 23:08:09 jason Exp $";
d231 3
a233 2
	{ 0,		0,		0,		setifaddr },
	{ 0,		0,		0,		setifdstaddr },
d306 1
d365 5
a369 1
			p++;	/* got src, do dst */
d629 1
@


1.20
log
@Documentation for ifmedia & updated ifconfig usage
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.19 1998/09/03 06:24:18 jason Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.19 1998/09/03 06:24:18 jason Exp $";
d134 1
a134 1
int	newaddr = 1;
d560 1
@


1.19
log
@o OpenBSD gets if_media support (from NetBSD)
o rework/simplify if_xl to use it
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.18 1998/07/09 06:12:09 deraadt Exp $	*/
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.18 1998/07/09 06:12:09 deraadt Exp $";
d1560 1
d1565 2
a1566 1
		"       ifconfig [-a | -A] [ af ]\n");
@


1.18
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.17 1998/07/07 07:26:15 deraadt Exp $	*/
d37 37
d84 1
a84 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.17 1998/07/07 07:26:15 deraadt Exp $";
d93 2
d155 25
d186 1
d189 11
a199 11
	{ "up",		IFF_UP,		setifflags } ,
	{ "down",	-IFF_UP,	setifflags },
	{ "trailers",	-1,		notrailers },
	{ "-trailers",	1,		notrailers },
	{ "arp",	-IFF_NOARP,	setifflags },
	{ "-arp",	IFF_NOARP,	setifflags },
	{ "debug",	IFF_DEBUG,	setifflags },
	{ "-debug",	-IFF_DEBUG,	setifflags },
	{ "alias",	IFF_UP,		notealias },
	{ "-alias",	-IFF_UP,	notealias },
	{ "delete",	-IFF_UP,	notealias },
d202 2
a203 2
	{ "swabips",	EN_SWABIPS,	setifflags },
	{ "-swabips",	-EN_SWABIPS,	setifflags },
d205 4
a208 4
	{ "netmask",	NEXTARG,	setifnetmask },
	{ "metric",	NEXTARG,	setifmetric },
	{ "broadcast",	NEXTARG,	setifbroadaddr },
	{ "ipdst",	NEXTARG,	setifipdst },
d210 9
a218 9
	{ "range",	NEXTARG,	setatrange },
	{ "phase",	NEXTARG,	setatphase },
	{ "snpaoffset",	NEXTARG,	setsnpaoffset },
	{ "nsellength",	NEXTARG,	setnsellength },
	{ "802.2",	ETHERTYPE_8022,	setipxframetype },
	{ "802.2tr",	ETHERTYPE_8022TR, setipxframetype },
	{ "802.3",	ETHERTYPE_8023,	setipxframetype },
	{ "snap",	ETHERTYPE_SNAP,	setipxframetype },
	{ "EtherII",	ETHERTYPE_II,	setipxframetype },
d220 13
a232 8
	{ "link0",	IFF_LINK0,	setifflags } ,
	{ "-link0",	-IFF_LINK0,	setifflags } ,
	{ "link1",	IFF_LINK1,	setifflags } ,
	{ "-link1",	-IFF_LINK1,	setifflags } ,
	{ "link2",	IFF_LINK2,	setifflags } ,
	{ "-link2",	-IFF_LINK2,	setifflags } ,
	{ 0,		0,		setifaddr },
	{ 0,		0,		setifdstaddr },
d243 10
d314 16
d331 1
a331 1
		strncpy(name, *argv, sizeof(name));
d348 1
a348 1
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d373 1
d378 3
d655 290
d958 2
d966 72
@


1.17
log
@tiny freebsd cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.16 1998/03/20 02:45:28 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.16 1998/03/20 02:45:28 angelos Exp $";
d402 2
a403 3
			(ifrp->ifr_addr.sa_len > sizeof(struct sockaddr)
				? ifrp->ifr_addr.sa_len
				: sizeof(struct sockaddr));
@


1.16
log
@Add an explanatory comment, why we keep the interface address and keep
reseting it before each ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.15 1998/03/20 02:22:29 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.15 1998/03/20 02:22:29 angelos Exp $";
d935 1
a935 1
		errx(1, "AppleTalk does not use netmasks\n");
d1067 1
a1067 1
		errx(1, "Negative NSEL length is absurd");
d1069 1
a1069 1
		errx(1, "Setting NSEL length valid only for iso");
@


1.15
log
@Pay attention.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.14 1998/03/20 02:13:28 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.14 1998/03/20 02:13:28 angelos Exp $";
d600 7
d608 1
@


1.14
log
@Should work better for aliases now, with Theo's patch (soon to come).
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.13 1998/03/17 08:10:21 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.13 1998/03/17 08:10:21 deraadt Exp $";
d600 1
a600 1
        bcopy(&ifr.ifr_addr, &sin2, sizeof(sin2));
d611 1
d624 1
a624 1
		bcopy(&sin2, &ifr.ifr_addr, sizeof(sin2));
@


1.13
log
@finish atalk support; merged by I.McWilliam@@st.nepean.uws.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.12 1997/12/31 11:16:22 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.12 1997/12/31 11:16:22 deraadt Exp $";
d589 1
a589 1
	struct sockaddr_in *sin;
d600 1
d623 1
@


1.12
log
@address family; forget about this protocol family stuff for now
@
text
@d1 2
a2 2
/*	$OpenBSD: ifconfig.c,v 1.11 1997/09/20 07:51:39 deraadt Exp $	*/
/*	$NetBSD: ifconfig.c,v 1.22 1996/01/04 20:11:20 pk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.11 1997/09/20 07:51:39 deraadt Exp $";
d59 2
d89 2
d93 1
a93 1
int	flags, metric, setaddr, setipdst, doalias;
d98 2
d113 3
d145 2
d179 2
d203 2
d311 3
d498 2
a499 3
		memcpy(rqtosa(af_ridreq),
		       rqtosa(af_addreq),
		       rqtosa(af_addreq)->sa_len);
d639 57
d912 66
@


1.11
log
@fix extra "no such interface" messages
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.10 1997/09/14 10:37:44 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.10 1997/09/14 10:37:44 deraadt Exp $";
d944 1
a944 1
		"\t[ af [ address [ dest_addr ] ] [ up ] [ down ] "
@


1.10
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.9 1997/08/24 20:31:50 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.9 1997/08/24 20:31:50 deraadt Exp $";
d397 1
@


1.9
log
@if interface not found by SIOCGIFCONF when printing, complain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.8 1997/07/01 18:54:50 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.8 1997/07/01 18:54:50 deraadt Exp $";
d793 1
a793 1
		if (hp = gethostbyname(s))
d795 1
a795 1
		else if (np = getnetbyname(s))
d821 1
a821 1
		while (i = *bits++) {
@


1.8
log
@split -a into -a/-A
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.7 1997/06/17 14:43:33 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.7 1997/06/17 14:43:33 deraadt Exp $";
d363 1
a363 1
	int noinet = 1;
d413 1
d419 4
@


1.7
log
@make 'ifconfig -a' and 'ifconfig de0' print full ifaliases output. this
was not fun, but the result sure is pretty. what is my reward?
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.6 1997/01/21 18:10:39 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.6 1997/01/21 18:10:39 deraadt Exp $";
d157 1
a157 1
void	printif __P((struct ifreq *));
d209 1
d216 4
a219 1
	else
d234 1
a234 1
		printif(NULL);
d239 1
a239 1
		printif(&ifr);
d356 1
a356 1
printif(ifrm)
d363 1
d397 1
d404 2
d413 1
d944 1
a944 1
		"       ifconfig -a [ af ]\n");
@


1.6
log
@spacing glitch
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.5 1996/09/19 06:01:44 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.5 1996/09/19 06:01:44 deraadt Exp $";
d157 1
a157 1
void	printall __P((void));
d159 1
a159 1
void 	status();
d230 1
a230 1
		printall();
a233 2
	if (getinfo(&ifr) < 0)
		exit(1);
d235 1
a235 1
		status();
d238 3
d352 2
a353 1
printall()
d357 1
a357 1
	struct ifreq ifreq, *ifr;
d374 1
a374 1
	ifr = ifc.ifc_req;
d377 4
a380 4
		ifr = (struct ifreq *)((caddr_t)ifc.ifc_req + i);
		i += sizeof(ifr->ifr_name) +
			(ifr->ifr_addr.sa_len > sizeof(struct sockaddr)
				? ifr->ifr_addr.sa_len
d382 3
a384 2
		if (!strncmp(ifreq.ifr_name, ifr->ifr_name,
			     sizeof(ifr->ifr_name)))
d386 6
a391 3
		strncpy(name, ifr->ifr_name, sizeof(ifr->ifr_name));
		ifreq = *ifr;
		if (getinfo(&ifreq) < 0)
d393 14
a406 1
		status();
d533 2
a534 1
status()
d543 7
a549 5
	if ((p = afp) != NULL) {
		(*p->af_status)(1);
	} else for (p = afs; p->af_name; p++) {
		ifr.ifr_addr.sa_family = p->af_af;
		(*p->af_status)(0);
a564 10
	}
	memset(&ifr, 0, sizeof(ifr));
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFADDR, (caddr_t)&ifr) < 0) {
		if (errno == EADDRNOTAVAIL || errno == EAFNOSUPPORT) {
			if (!force)
				return;
			memset(&ifr.ifr_addr, 0, sizeof(ifr.ifr_addr));
		} else
			warn("SIOCGIFADDR");
@


1.5
log
@handle more interfaces in -a mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.4 1996/08/16 09:22:41 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.4 1996/08/16 09:22:41 mickey Exp $";
d365 1
a365 1
			err(1, "malloc");		
@


1.4
log
@ipx.
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.3 1996/06/23 14:30:47 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.3 1996/06/23 14:30:47 deraadt Exp $";
d353 1
a353 1
	char inbuf[8192];
d356 1
a356 1
	int i;
a357 2
	ifc.ifc_len = sizeof(inbuf);
	ifc.ifc_buf = inbuf;
d361 11
a371 2
	if (ioctl(s, SIOCGIFCONF, &ifc) < 0)
		err(1, "SIOCGIFCONF");
d389 1
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ifconfig.c,v 1.22 1996/01/04 20:11:20 pk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ifconfig.c,v 1.22 1996/01/04 20:11:20 pk Exp $";
d62 5
d87 1
d106 1
d138 5
d170 2
d192 2
d263 2
a264 1
	if (af == AF_ISO)
d266 5
a270 3
	if (setipdst && af==AF_NS) {
		struct nsip_req rq;
		int size = sizeof(rq);
d272 2
a273 2
		rq.rq_ns = addreq.ifra_addr;
		rq.rq_ip = addreq.ifra_dstaddr;
d275 16
a290 2
		if (setsockopt(s, 0, SO_NSIP_ROUTE, &rq, size) < 0)
			warn("encapsulation routing");
a291 1

d626 63
d824 21
d908 7
a914 6
	fprintf(stderr, "usage: ifconfig interface\n%s%s%s%s%s%s",
		"\t[ af [ address [ dest_addr ] ] [ up ] [ down ] ",
		"[ netmask mask ] ]\n",
		"\t[ metric n ]\n",
		"\t[ arp | -arp ]\n",
		"\t[ link0 | -link0 ] [ link1 | -link1 ] [ link2 | -link2 ]\n",
@


1.2
log
@from 4.4lite2; additional data from SIOCGIFCONF is at least sockaddr sized
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: ifconfig.c,v 1.22 1996/01/04 20:11:20 pk Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ifconfig.c,v 1.21 1995/10/08 23:03:54 gwr Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: ifconfig.c,v 1.21 1995/10/08 23:03:54 gwr Exp $";
d336 4
a339 1
		i += sizeof(ifr->ifr_name) + ifr->ifr_addr.sa_len;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

