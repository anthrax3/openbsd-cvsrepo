head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.8
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.10.0.10
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.18
	OPENBSD_5_0:1.9.0.16
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.14
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.12
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.8
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.20
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.18
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.16
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.14
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.14
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.12
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2015.09.27.16.56.06;	author guenther;	state Exp;
branches;
next	1.12;
commitid	kZKltxcWbyZaEgB3;

1.12
date	2014.07.09.18.32.34;	author tobias;	state Exp;
branches;
next	1.11;
commitid	OiJs6kBJGusNE7dk;

1.11
date	2014.06.16.18.33.33;	author tobias;	state Exp;
branches;
next	1.10;
commitid	PhPZAfTlrgjKIup9;

1.10
date	2012.03.31.17.53.34;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.07.01.34.12;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.11.04.42.25;	author david;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	98.01.11.20.40.33;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.03.02.05.25.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.04.38.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.23.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Mark ask() as printf-like; split up a pwarn() with variable number of specifiers

ok beck@@ millert@@
@
text
@/*	$OpenBSD: ext.h,v 1.12 2014/07/09 18:32:34 tobias Exp $	*/
/*	$NetBSD: ext.h,v 1.5 1997/10/17 11:19:48 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997 Wolfgang Solfrank
 * Copyright (c) 1995 Martin Husemann
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef EXT_H
#define EXT_H

#include <sys/types.h>

#include "dosfs.h"
#include "fsutil.h"

#define	LOSTDIR	"LOST.DIR"

/*
 * Options:
 */
extern int alwaysno;	/* assume "no" for all questions */
extern int alwaysyes;	/* assume "yes" for all questions */
extern int preen;	/* we are preening */
extern int rdonly;	/* device is opened read only (supersedes above) */

extern struct disklabel lab;

/*
 * function declarations
 */
int ask(int, const char *, ...) __attribute__((__format__ (printf, 2, 3)));

/*
 * Check filesystem given as arg
 */
int checkfilesys(const char *);

/*
 * Return values of various functions
 */
#define	FSOK		0		/* Check was OK */
#define	FSBOOTMOD	1		/* Boot block was modified */
#define	FSDIRMOD	2		/* Some directory was modified */
#define	FSFATMOD	4		/* The FAT was modified */
#define	FSERROR		8		/* Some unrecovered error remains */
#define	FSFATAL		16		/* Some unrecoverable error occurred */

/*
 * read a boot block in a machine independent fashion and translate
 * it into our struct bootblock.
 */
int readboot(int, struct bootblock *);

/*
 * Correct the FSInfo block.
 */
int writefsinfo(int, struct bootblock *);

/*
 * Read one of the FAT copies and return a pointer to the new
 * allocated array holding our description of it.
 */
int readfat(int, struct bootblock *, int, struct fatEntry **);

/*
 * Check two FAT copies for consistency and merge changes into the
 * first if necessary.
 */
int comparefat(struct bootblock *, struct fatEntry *, struct fatEntry *, int);

/*
 * Check a FAT
 */
int checkfat(struct bootblock *, struct fatEntry *);

/*
 * Write back FAT entries
 */
int writefat(int, struct bootblock *, struct fatEntry *);

/*
 * Read a directory
 */
int resetDosDirSection(struct bootblock *, struct fatEntry *);
void finishDosDirSection(void);
int handleDirTree(int, struct bootblock *, struct fatEntry *);

/*
 * Cross-check routines run after everything is completely in memory
 */
/*
 * Check for lost cluster chains
 */
int checklost(int, struct bootblock *, struct fatEntry *);
/*
 * Try to reconnect a lost cluster chain
 */
int reconnect(int, struct bootblock *, struct fatEntry *, cl_t);
void finishlf(void);

/*
 * Small helper functions
 */
/*
 * Return the type of a reserved cluster as text
 */
char *rsrvdcltype(cl_t);

/*
 * Clear a cluster chain in a FAT
 */
void clearchain(struct bootblock *, struct fatEntry *, cl_t);

#endif
@


1.12
log
@Merge memory leak fix from NetBSD's dir.c revision 1.20, but actually
release all reserved memory chunks in all error cases.

with input by and ok tedu@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext.h,v 1.11 2014/06/16 18:33:33 tobias Exp $	*/
d52 1
a52 1
int ask(int, const char *, ...);
@


1.11
log
@Merge NetBSD commit:
Move to 2 clause license, approved by Wolfgang Solfrank.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext.h,v 1.10 2012/03/31 17:53:34 krw Exp $	*/
a47 2

extern struct dosDirEntry *rootDir;
@


1.10
log
@Make fsck_msdos work with non-512-byte sector devices. Problem noted
by and fixes tested by Alexey Vatchenko.

Add a bunch of tests and error messages so whatever media/devices
this breaks will be more easily fixed.

Ignore invalid signatures since we have other checks and many media
have missing signatures.

Use character device to read disk even when called directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext.h,v 1.9 2008/02/07 01:34:12 ian Exp $	*/
a15 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Martin Husemann
 *	and Wolfgang Solfrank.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.9
log
@Check reads and lseek correctly for unsigned return; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext.h,v 1.8 2003/03/11 04:42:25 david Exp $	*/
d54 1
a54 1
extern char *fname;	/* filesystem currently checked */
@


1.8
log
@spelling
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ext.h,v 1.7 2002/02/16 21:27:34 millert Exp $	*/
d79 1
a79 1
 * read a boot block in a machine independend fashion and translate
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext.h,v 1.6 2001/09/19 10:58:07 mpech Exp $	*/
d97 1
a97 1
 * first if neccessary.
@


1.6
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: ext.h,v 1.5 1998/01/11 20:40:33 provos Exp $	*/
d61 1
a61 1
int ask __P((int, const char *, ...));
d66 1
a66 1
int checkfilesys __P((const char *));
d82 1
a82 1
int readboot __P((int, struct bootblock *));
d87 1
a87 1
int writefsinfo __P((int, struct bootblock *));
d93 1
a93 1
int readfat __P((int, struct bootblock *, int, struct fatEntry **));
d99 1
a99 1
int comparefat __P((struct bootblock *, struct fatEntry *, struct fatEntry *, int));
d104 1
a104 1
int checkfat __P((struct bootblock *, struct fatEntry *));
d109 1
a109 1
int writefat __P((int, struct bootblock *, struct fatEntry *));
d114 3
a116 3
int resetDosDirSection __P((struct bootblock *, struct fatEntry *));
void finishDosDirSection __P((void));
int handleDirTree __P((int, struct bootblock *, struct fatEntry *));
d124 1
a124 1
int checklost __P((int, struct bootblock *, struct fatEntry *));
d128 2
a129 2
int reconnect __P((int, struct bootblock *, struct fatEntry *, cl_t));
void finishlf __P((void));
d137 1
a137 1
char *rsrvdcltype __P((cl_t));
d142 1
a142 1
void clearchain __P((struct bootblock *, struct fatEntry *, cl_t));
@


1.5
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: ext.h,v 1.4 1997/03/02 05:25:54 millert Exp $	*/
d76 1
a76 1
#define	FSFATAL		16		/* Some unrecoverable error occured */
@


1.4
log
@Update based on latest NetBSD version.
Now uses functions from util.[ch] instead of local ones.
Also some anal KNF from me...
@
text
@d1 2
a2 2
/*	$OpenBSD: ext.h,v 1.3 1996/06/23 14:30:43 deraadt Exp $	*/
/*	$NetBSD: ext.h,v 1.4 1996/09/23 16:27:59 christos Exp $	*/
d5 1
a5 1
 * Copyright (C) 1995, 1996 Wolfgang Solfrank
d58 1
a58 1
/* 
d72 5
a76 4
#define	FSDIRMOD	1		/* Some directory was modified */
#define	FSFATMOD	2		/* The FAT was modified */
#define	FSERROR		4		/* Some unrecovered error remains */
#define	FSFATAL		8		/* Some unrecoverable error occured */
d84 4
d91 1
a91 1
 * allocated array holding our description of it. 
d114 1
a114 1
int resetDosDirSection __P((struct bootblock *));
d130 1
a130 1
	
@


1.3
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: ext.h,v 1.1.4.1 1996/05/31 18:41:45 jtc Exp $	*/
/*	$NetBSD: ext.h,v 1.1.4.1 1996/05/31 18:41:45 jtc Exp $	*/
d42 1
a60 3
void errexit __P((const char *, ...));
void pfatal __P((const char *, ...));
void pwarn __P((const char *, ...));
a61 1
void perror __P((const char *));
@


1.2
log
@from ws;
Check return values of malloc
Generate full pathnames only on request
Minor cleanup, RCS Ids in .h files
Don't allocate data structures for non-directories
Free any data structures when finishing a check (at the latest)
@
text
@d1 1
@


1.1
log
@add fsck_msdos
@
text
@d1 2
a39 11
#if sun
#define	__P(a)	a

typedef char		int8_t;
typedef unsigned char	u_int8_t;
typedef short		int16_t;
typedef unsigned short	u_int16_t;
typedef long		int32_t;
typedef unsigned long	u_int32_t;
#endif

d54 2
d113 1
a113 6
int readDosDirSection __P((int, struct bootblock *, struct fatEntry *, struct dosDirEntry *));

/*
 * A stack of directories which should be examined later
 */
extern struct dirTodoNode *pendingDirectories;
d121 1
a121 1
int checklost __P((int, struct bootblock *, struct fatEntry *, struct dosDirEntry *));
d125 1
a125 1
int reconnect __P((int, struct bootblock *, struct fatEntry *, cl_t, struct dosDirEntry *));
@
