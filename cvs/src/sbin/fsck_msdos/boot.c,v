head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.8
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.4
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.24
date	2016.10.10.00.34.50;	author bluhm;	state Exp;
branches;
next	1.23;
commitid	acCovoubhhVmbWtj;

1.23
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	Uu5nFG3wCl0LACBb;

1.22
date	2014.07.10.17.12.05;	author tobias;	state Exp;
branches;
next	1.21;
commitid	JBHyBI8CzVyjd4yw;

1.21
date	2014.07.10.17.08.33;	author tobias;	state Exp;
branches;
next	1.20;
commitid	5xhOAAAFNY8wJLdn;

1.20
date	2014.06.16.18.33.33;	author tobias;	state Exp;
branches;
next	1.19;
commitid	PhPZAfTlrgjKIup9;

1.19
date	2014.06.14.15.23.45;	author tobias;	state Exp;
branches;
next	1.18;
commitid	x0hKpFMkhS574Hin;

1.18
date	2014.06.14.15.21.27;	author tobias;	state Exp;
branches;
next	1.17;
commitid	pRirqN3rzzaLKkk0;

1.17
date	2013.08.12.13.44.13;	author rapha;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.31.17.53.34;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.18.04.57.34;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.07.01.34.12;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.19.10.44.23;	author tom;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.27.22.30.09;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.11.04.42.25;	author david;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.14.02.53.36;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.03.13.03.44;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.08.30.20.27.45;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	98.01.11.20.40.28;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.03.02.05.25.51;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.23.53;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Rename BIOS parameter block field from bsPBP to bsBPB.  This typo
has been fixed in FreeBSD in 2002.  No binary change.
From Alexander von Gernler; OK krw@@
@
text
@/*	$OpenBSD: boot.c,v 1.23 2015/01/16 06:39:58 deraadt Exp $	*/
/*	$NetBSD: boot.c,v 1.5 1997/10/17 11:19:23 ws Exp $	*/

/*
 * Copyright (C) 1995, 1997 Wolfgang Solfrank
 * Copyright (c) 1995 Martin Husemann
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE powerof2 */
#include <sys/disklabel.h>

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <unistd.h>

#include "ext.h"

int
readboot(int dosfs, struct bootblock *boot)
{
	u_char *block = NULL;
	u_char *fsinfo = NULL;
	u_char *backup = NULL;
	int ret = FSOK, secsize = lab.d_secsize, fsinfosz;
	off_t o;
	ssize_t n;

	if (secsize < DOSBOOTBLOCKSIZE) {
		xperror("sector size < DOSBOOTBLOCKSIZE");
		goto fail;
	}
	if (DOSBOOTBLOCKSIZE != DEV_BSIZE) {
		xperror("DOSBOOTBLOCKSIZE != DEV_BSIZE");
		goto fail;
	}

	block = malloc(secsize);
	if (block == NULL) {
		xperror("could not malloc boot block");
		goto fail;
	}

	if ((o = lseek(dosfs, 0, SEEK_SET)) == -1) {
		xperror("could not seek boot block");
		goto fail;
	}

	n = read(dosfs, block, secsize);
	if (n == -1 || n != secsize) {
		xperror("could not read boot block");
		goto fail;
	}

	if (block[510] != 0x55 || block[511] != 0xaa) {
		pfatal("Invalid signature in boot block: %02x%02x\n",
		    block[511], block[510]);
	}

	memset(boot, 0, sizeof *boot);
	boot->ValidFat = -1;

	/* decode bios parameter block */
	boot->BytesPerSec = block[11] + (block[12] << 8);
	if (boot->BytesPerSec == 0 || boot->BytesPerSec != secsize) {
		pfatal("Invalid sector size: %u\n", boot->BytesPerSec);
		goto fail;
	}
	boot->SecPerClust = block[13];
	if (boot->SecPerClust == 0 || !powerof2(boot->SecPerClust)) {
		pfatal("Invalid cluster size: %u\n", boot->SecPerClust);
		goto fail;
	}
	boot->ResSectors = block[14] + (block[15] << 8);
	boot->FATs = block[16];
	if (boot->FATs == 0) {
		pfatal("Invalid number of FATs: %u\n", boot->FATs);
		goto fail;
	}
	boot->RootDirEnts = block[17] + (block[18] << 8);
	boot->Sectors = block[19] + (block[20] << 8);
	boot->Media = block[21];
	boot->FATsmall = block[22] + (block[23] << 8);
	boot->SecPerTrack = block[24] + (block[25] << 8);
	boot->Heads = block[26] + (block[27] << 8);
	boot->HiddenSecs = block[28] + (block[29] << 8) + (block[30] << 16) + (block[31] << 24);
	boot->HugeSectors = block[32] + (block[33] << 8) + (block[34] << 16) + (block[35] << 24);

	boot->FATsecs = boot->FATsmall;

	if (!boot->RootDirEnts) {
		boot->flags |= FAT32;
		boot->FATsecs = block[36] + (block[37] << 8)
				+ (block[38] << 16) + (block[39] << 24);
		if (block[40] & 0x80)
			boot->ValidFat = block[40] & 0x0f;

		/* check version number: */
		if (block[42] || block[43]) {
			/* Correct?				XXX */
			pfatal("Unknown filesystem version: %x.%x\n",
			       block[43], block[42]);
			goto fail;
		}
		boot->RootCl = block[44] + (block[45] << 8)
			       + (block[46] << 16) + (block[47] << 24);
		boot->FSInfo = block[48] + (block[49] << 8);
		boot->Backup = block[50] + (block[51] << 8);

		o = lseek(dosfs, boot->FSInfo * secsize, SEEK_SET);
		if (o == -1 || o != boot->FSInfo * secsize) {
			xperror("could not seek fsinfo block");
			goto fail;
		}

		if ((2 * DOSBOOTBLOCKSIZE) < secsize)
			fsinfosz = secsize;
		else
			fsinfosz = 2 * secsize;
		fsinfo = malloc(fsinfosz);
		if (fsinfo == NULL) {
			xperror("could not malloc fsinfo");
			goto fail;
		}
		n = read(dosfs, fsinfo, fsinfosz);
		if (n == -1 || n != fsinfosz) {
			xperror("could not read fsinfo block");
			goto fail;
		}

		if (memcmp(fsinfo, "RRaA", 4)
		    || memcmp(fsinfo + 0x1e4, "rrAa", 4)
		    || fsinfo[0x1fc]
		    || fsinfo[0x1fd]
		    || fsinfo[0x1fe] != 0x55
		    || fsinfo[0x1ff] != 0xaa
		    || fsinfo[0x3fc]
		    || fsinfo[0x3fd]
		    || fsinfo[0x3fe] != 0x55
		    || fsinfo[0x3ff] != 0xaa) {
			pwarn("Invalid signature in fsinfo block\n");
			if (ask(0, "fix")) {
				memcpy(fsinfo, "RRaA", 4);
				memcpy(fsinfo + 0x1e4, "rrAa", 4);
				fsinfo[0x1fc] = fsinfo[0x1fd] = 0;
				fsinfo[0x1fe] = 0x55;
				fsinfo[0x1ff] = 0xaa;
				fsinfo[0x3fc] = fsinfo[0x3fd] = 0;
				fsinfo[0x3fe] = 0x55;
				fsinfo[0x3ff] = 0xaa;

				o = lseek(dosfs, boot->FSInfo * secsize,
				    SEEK_SET);
				if (o == -1 || o != boot->FSInfo * secsize) {
					xperror("Unable to seek FSInfo");
					goto fail;
				}
				n = write(dosfs, fsinfo, fsinfosz);
				if (n == -1 || n != fsinfosz) {
					xperror("Unable to write FSInfo");
					goto fail;
				}
				ret = FSBOOTMOD;
			} else
				boot->FSInfo = 0;
		}
		if (boot->FSInfo) {
			boot->FSFree = fsinfo[0x1e8] + (fsinfo[0x1e9] << 8)
				       + (fsinfo[0x1ea] << 16)
				       + (fsinfo[0x1eb] << 24);
			boot->FSNext = fsinfo[0x1ec] + (fsinfo[0x1ed] << 8)
				       + (fsinfo[0x1ee] << 16)
				       + (fsinfo[0x1ef] << 24);
		}

		o = lseek(dosfs, boot->Backup * secsize, SEEK_SET);
		if (o == -1 || o != boot->Backup * secsize) {
			xperror("could not seek backup bootblock");
			goto fail;
		}
		backup = malloc(2 * secsize); /* In case we check fsinfo. */
		if (backup == NULL) {
			xperror("could not malloc backup boot block");
			goto fail;
		}
		n = read(dosfs, backup, secsize);
		if (n == -1 || n != secsize) {
			xperror("could not read backup bootblock");
			goto fail;
		}

		/*
		 * Check that the backup boot block matches the primary one.
		 * We don't check every byte, since some vendor utilities
		 * seem to overwrite the boot code when they feel like it,
		 * without changing the backup block.  Specifically, we check
		 * the two-byte signature at the end, the BIOS parameter
		 * block (which starts after the 3-byte JMP and the 8-byte
		 * OEM name/version) and the filesystem information that
		 * follows the BPB (bsBPB[53] and bsExt[26] for FAT32, so we
		 * check 79 bytes).
		 */
		if (backup[510] != 0x55 || backup[511] != 0xaa) {
			pfatal("Invalid signature in backup boot block: %02x%02x\n", backup[511], backup[510]);
		}
		if (memcmp(block + 11, backup + 11, 79)) {
			pfatal("backup doesn't compare to primary bootblock\n");
			goto fail;
		}
		/* Check backup FSInfo?					XXX */
	}

	if (boot->FATsecs == 0) {
		pfatal("Invalid number of FAT sectors: %u\n", boot->FATsecs);
		goto fail;
	}

	boot->ClusterOffset = (boot->RootDirEnts * 32 + secsize - 1)
	    / secsize
	    + boot->ResSectors
	    + boot->FATs * boot->FATsecs
	    - CLUST_FIRST * boot->SecPerClust;

	if (boot->Sectors) {
		boot->HugeSectors = 0;
		boot->NumSectors = boot->Sectors;
	} else
		boot->NumSectors = boot->HugeSectors;

	if (boot->ClusterOffset > boot->NumSectors) {
		pfatal("Cluster offset too large (%u clusters)\n",
		    boot->ClusterOffset);
		goto fail;
	}
	boot->NumClusters = (boot->NumSectors - boot->ClusterOffset) / boot->SecPerClust;

	if (boot->flags&FAT32)
		boot->ClustMask = CLUST32_MASK;
	else if (boot->NumClusters < (CLUST_RSRVD&CLUST12_MASK))
		boot->ClustMask = CLUST12_MASK;
	else if (boot->NumClusters < (CLUST_RSRVD&CLUST16_MASK))
		boot->ClustMask = CLUST16_MASK;
	else {
		pfatal("Filesystem too big (%u clusters) for non-FAT32 partition\n",
		       boot->NumClusters);
		goto fail;
	}

	switch (boot->ClustMask) {
	case CLUST32_MASK:
		boot->NumFatEntries = (boot->FATsecs * secsize) / 4;
		break;
	case CLUST16_MASK:
		boot->NumFatEntries = (boot->FATsecs * secsize) / 2;
		break;
	default:
		boot->NumFatEntries = (boot->FATsecs * secsize * 2) / 3;
		break;
	}

	if (boot->NumFatEntries < boot->NumClusters) {
		pfatal("FAT size too small, %u entries won't fit into %u sectors\n",
		       boot->NumClusters, boot->FATsecs);
		goto fail;
	}
	boot->ClusterSize = boot->SecPerClust * secsize;

	boot->NumFiles = 1;
	boot->NumFree = 0;

	free(backup);
	free(block);
	free(fsinfo);
	return ret;
fail:
	free(backup);
	free(block);
	free(fsinfo);
	return FSFATAL;
}

int
writefsinfo(int dosfs, struct bootblock *boot)
{
	u_char *fsinfo = NULL;
	int secsize = lab.d_secsize, fsinfosz;
	off_t o;
	ssize_t n;

	if ((2 * DOSBOOTBLOCKSIZE) < secsize)
		fsinfosz = secsize;
	else
		fsinfosz = 2 * secsize;

	fsinfo = malloc(fsinfosz);
	if (fsinfo == NULL) {
		xperror("could not malloc fsinfo block");
		goto fail;
	}

	o = lseek(dosfs, boot->FSInfo * secsize, SEEK_SET);
	if (o == -1 || o != boot->FSInfo * secsize) {
		xperror("could not seek fsinfo block");
		goto fail;
	}

	n = read(dosfs, fsinfo, fsinfosz);
	if (n == -1 || n != fsinfosz) {
		xperror("could not read fsinfo block");
		goto fail;
	}

	fsinfo[0x1e8] = (u_char)boot->FSFree;
	fsinfo[0x1e9] = (u_char)(boot->FSFree >> 8);
	fsinfo[0x1ea] = (u_char)(boot->FSFree >> 16);
	fsinfo[0x1eb] = (u_char)(boot->FSFree >> 24);
	fsinfo[0x1ec] = (u_char)boot->FSNext;
	fsinfo[0x1ed] = (u_char)(boot->FSNext >> 8);
	fsinfo[0x1ee] = (u_char)(boot->FSNext >> 16);
	fsinfo[0x1ef] = (u_char)(boot->FSNext >> 24);

	o = lseek(dosfs, o, SEEK_SET);
	if (o == -1 || o != boot->FSInfo * boot->BytesPerSec) {
		xperror("Unable to seek FSInfo");
		goto fail;
	}
	n = write(dosfs, fsinfo, fsinfosz);
	if (n == -1 || n != fsinfosz) {
		xperror("Unable to write FSInfo");
		goto fail;
	}

	free(fsinfo);

	/*
	 * Technically, we should return FSBOOTMOD here.
	 *
	 * However, since Win95 OSR2 (the first M$ OS that has
	 * support for FAT32) doesn't maintain the FSINFO block
	 * correctly, it has to be fixed pretty often.
	 *
	 * Therefore, we handle the FSINFO block only informally,
	 * fixing it if necessary, but otherwise ignoring the
	 * fact that it was incorrect.
	 */
	return 0;
fail:
	free(fsinfo);
	return FSFATAL;
}
@


1.23
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.22 2014/07/10 17:12:05 tobias Exp $	*/
d221 1
a221 1
		 * follows the BPB (bsPBP[53] and bsExt[26] for FAT32, so we
@


1.22
log
@Validate file system information which are critical for fsck_msdos operation.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.21 2014/07/10 17:08:33 tobias Exp $	*/
d29 1
a29 1
#include <sys/param.h>
@


1.21
log
@Validate number of FATs.
Merged from Android (commitid 6c29bbe8d58e6fe8755935a04166ecf82ff31f47)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.20 2014/06/16 18:33:33 tobias Exp $	*/
d91 1
a91 1
	if (boot->SecPerClust == 0) {
d234 5
d250 6
@


1.20
log
@Merge NetBSD commit:
Move to 2 clause license, approved by Wolfgang Solfrank.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.19 2014/06/14 15:23:45 tobias Exp $	*/
d97 4
@


1.19
log
@Fix memory leaks in bootblock handling.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.18 2014/06/14 15:21:27 tobias Exp $	*/
a15 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Martin Husemann
 *	and Wolfgang Solfrank.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.18
log
@Fix regression of 1.16: write fsinfo, not block into FSInfo region.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.17 2013/08/12 13:44:13 rapha Exp $	*/
d50 3
a52 3
	u_char *block;
	u_char *fsinfo;
	u_char *backup;
d59 1
a59 1
		return (FSFATAL);
d63 1
a63 1
		return (FSFATAL);
d69 1
a69 1
		return FSFATAL;
d74 1
a74 1
		return FSFATAL;
d80 1
a80 1
		return (FSFATAL);
d95 1
a95 1
		return (FSFATAL);
d100 1
a100 1
		return (FSFATAL);
d127 1
a127 1
			return FSFATAL;
d137 1
a137 1
			return FSFATAL;
d147 1
a147 1
			return FSFATAL;
d152 1
a152 1
			return FSFATAL;
d180 1
a180 1
					return FSFATAL;
d185 1
a185 1
					return FSFATAL;
d203 1
a203 1
			return (FSFATAL);
d208 1
a208 1
			return FSFATAL;
d213 1
a213 1
			return FSFATAL;
d232 1
a232 1
			return FSFATAL;
d259 1
a259 1
		return FSFATAL;
d277 1
a277 1
		return (FSFATAL);
d284 3
d288 5
d298 1
a298 1
	u_char *fsinfo;
d311 1
a311 1
		return FSFATAL;
d317 1
a317 1
		return FSFATAL;
d323 1
a323 1
		return FSFATAL;
d338 1
a338 1
		return FSFATAL;
d343 1
a343 1
		return FSFATAL;
d346 2
d360 3
@


1.17
log
@Add missing \n after a warning.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.16 2012/03/31 17:53:34 krw Exp $	*/
d182 1
a182 1
				n = write(dosfs, block, fsinfosz);
@


1.16
log
@Make fsck_msdos work with non-512-byte sector devices. Problem noted
by and fixes tested by Alexey Vatchenko.

Add a bunch of tests and error messages so whatever media/devices
this breaks will be more easily fixed.

Ignore invalid signatures since we have other checks and many media
have missing signatures.

Use character device to read disk even when called directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.15 2010/12/18 04:57:34 deraadt Exp $	*/
d165 1
a165 1
			pwarn("Invalid signature in fsinfo block");
@


1.15
log
@add some off_t and ssize_t love; ok stsp millert
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.14 2009/10/27 23:59:33 deraadt Exp $	*/
d36 3
d50 4
a53 4
	u_char block[DOSBOOTBLOCKSIZE];
	u_char fsinfo[2 * DOSBOOTBLOCKSIZE];
	u_char backup[DOSBOOTBLOCKSIZE];
	int ret = FSOK;
d57 22
a78 1
	if ((n = read(dosfs, block, sizeof block)) == -1 || n != sizeof block) {
d84 2
a85 2
		pfatal("Invalid signature in boot block: %02x%02x\n", block[511], block[510]);
		return FSFATAL;
d93 4
d98 4
d115 1
a115 1
	if (!boot->RootDirEnts)
a116 1
	if (boot->flags & FAT32) {
d134 17
a150 5
		o = boot->FSInfo * boot->BytesPerSec;
		if ((o = lseek(dosfs, o, SEEK_SET)) == -1
		    || o != boot->FSInfo * boot->BytesPerSec
		    || (n = read(dosfs, fsinfo, sizeof fsinfo)) == -1
		    || n != sizeof fsinfo) {
d154 1
d176 8
a183 5
				o = boot->FSInfo * boot->BytesPerSec;
				if ((o = lseek(dosfs, o, SEEK_SET)) == -1
				    || o != boot->FSInfo * boot->BytesPerSec
				    || (n = write(dosfs, fsinfo, sizeof fsinfo)) == -1
				    || n != sizeof fsinfo) {
d200 12
a211 5
		o = boot->Backup * boot->BytesPerSec;
		if ((o = lseek(dosfs, o, SEEK_SET)) == -1
		    || o != boot->Backup * boot->BytesPerSec
		    || (n = read(dosfs, backup, sizeof backup)) == -1
		    || n != sizeof backup) {
a228 1
			return FSFATAL;
d237 2
a238 12
	if (boot->BytesPerSec == 0 || boot->BytesPerSec % DOSBOOTBLOCKSIZE
	    != 0) {
		pfatal("Invalid sector size: %u\n", boot->BytesPerSec);
		return (FSFATAL);
	}
	if (boot->SecPerClust == 0) {
		pfatal("Invalid cluster size: %u\n", boot->SecPerClust);
		return (FSFATAL);
	}

	boot->ClusterOffset = (boot->RootDirEnts * 32 + boot->BytesPerSec - 1)
	    / boot->BytesPerSec
d264 1
a264 1
		boot->NumFatEntries = (boot->FATsecs * boot->BytesPerSec) / 4;
d267 1
a267 1
		boot->NumFatEntries = (boot->FATsecs * boot->BytesPerSec) / 2;
d270 1
a270 1
		boot->NumFatEntries = (boot->FATsecs * boot->BytesPerSec * 2) / 3;
d279 1
a279 1
	boot->ClusterSize = boot->BytesPerSec * boot->SecPerClust;
d290 2
a291 1
	u_char fsinfo[2 * DOSBOOTBLOCKSIZE];
d295 19
a313 5
	o = boot->FSInfo * boot->BytesPerSec;
	if ((o = lseek(dosfs, o, SEEK_SET)) == -1
	   || o != boot->FSInfo * boot->BytesPerSec
	   || (n = read(dosfs, fsinfo, sizeof fsinfo)) == -1
	   || n != sizeof fsinfo) {
d317 1
d327 7
a333 5
	o = boot->FSInfo * boot->BytesPerSec;
	if ((o = lseek(dosfs, o, SEEK_SET)) == -1
	    || o != boot->FSInfo * boot->BytesPerSec
	    || (n = write(dosfs, fsinfo, sizeof fsinfo)) == -1
	    || n != sizeof fsinfo) {
d337 1
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 2008/02/07 01:34:12 ian Exp $	*/
d51 2
a52 1
	int n;
d103 3
a105 2
		if ((n = lseek(dosfs, boot->FSInfo * boot->BytesPerSec, SEEK_SET)) == -1
		    || n != boot->FSInfo * boot->BytesPerSec
d131 4
a134 2
				if ((n = lseek(dosfs, boot->FSInfo * boot->BytesPerSec, SEEK_SET)) == -1
				    || n != boot->FSInfo * boot->BytesPerSec
d153 3
a155 2
		if ((n = lseek(dosfs, boot->Backup * boot->BytesPerSec, SEEK_SET)) == -1
		    || n != boot->Backup * boot->BytesPerSec
d248 2
a249 1
	int n;
d251 5
a255 4
	if ((n = lseek(dosfs, boot->FSInfo * boot->BytesPerSec, SEEK_SET)) == -1
	    || n != boot->FSInfo * boot->BytesPerSec
	    || (n = read(dosfs, fsinfo, sizeof fsinfo)) == -1
	    || n != sizeof fsinfo) {
d267 4
a270 2
	if ((n = lseek(dosfs, boot->FSInfo * boot->BytesPerSec, SEEK_SET)) == -1
	    || n != boot->FSInfo * boot->BytesPerSec
d283 1
a283 1
	 * Therefor, we handle the FSINFO block only informally,
@


1.13
log
@Check reads and lseek correctly for unsigned return; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2006/07/19 10:44:23 tom Exp $	*/
a34 5


#ifndef lint
static char rcsid[] = "$OpenBSD: boot.c,v 1.12 2006/07/19 10:44:23 tom Exp $";
#endif /* not lint */
@


1.12
log
@Only compare important parts of the boot block with the backup copy,
since some vendor utilities will change one without changing the
other.  Raised most recently by Nick Guenther; fix is similar to
what is in NetBSD, but includes an idea from Steven E. Kalbach
<kalbachs (at) kalbachsoft (dot) com>, posted to bugs@@ over 5 years
ago.

ok tedu@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 2006/05/27 22:30:09 thib Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.11 2006/05/27 22:30:09 thib Exp $";
d56 1
d58 1
a58 1
	if (read(dosfs, block, sizeof block) < sizeof block) {
d107 4
a110 4
		if (lseek(dosfs, boot->FSInfo * boot->BytesPerSec, SEEK_SET)
		    != boot->FSInfo * boot->BytesPerSec
		    || read(dosfs, fsinfo, sizeof fsinfo)
		    != sizeof fsinfo) {
d134 4
a137 4
				if (lseek(dosfs, boot->FSInfo * boot->BytesPerSec, SEEK_SET)
				    != boot->FSInfo * boot->BytesPerSec
				    || write(dosfs, fsinfo, sizeof fsinfo)
				    != sizeof fsinfo) {
d154 4
a157 3
		if (lseek(dosfs, boot->Backup * boot->BytesPerSec, SEEK_SET)
		    != boot->Backup * boot->BytesPerSec
		    || read(dosfs, backup, sizeof backup) != sizeof  backup) {
d248 1
d250 4
a253 3
	if (lseek(dosfs, boot->FSInfo * boot->BytesPerSec, SEEK_SET)
	    != boot->FSInfo * boot->BytesPerSec
	    || read(dosfs, fsinfo, sizeof fsinfo) != sizeof fsinfo) {
d265 4
a268 4
	if (lseek(dosfs, boot->FSInfo * boot->BytesPerSec, SEEK_SET)
	    != boot->FSInfo * boot->BytesPerSec
	    || write(dosfs, fsinfo, sizeof fsinfo)
	    != sizeof fsinfo) {
@


1.11
log
@newline fix + s/perror/xperror since we are
using a home rolled version.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 2004/07/17 02:14:33 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.10 2004/07/17 02:14:33 deraadt Exp $";
d159 17
a175 2
		if (memcmp(block, backup, DOSBOOTBLOCKSIZE)) {
			/* Correct?					XXX */
@


1.10
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 2003/07/29 18:38:35 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.9 2003/07/29 18:38:35 deraadt Exp $";
d58 1
a58 1
		perror("could not read boot block");
d110 1
a110 1
			perror("could not read fsinfo block");
d137 1
a137 1
					perror("Unable to write FSInfo");
d156 1
a156 1
			perror("could not read backup bootblock");
d235 1
a235 1
		perror("could not read fsinfo block");
d250 1
a250 1
		perror("Unable to write FSInfo");
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 2003/03/11 04:42:25 david Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.8 2003/03/11 04:42:25 david Exp $";
d50 1
a50 3
readboot(dosfs, boot)
	int dosfs;
	struct bootblock *boot;
d228 1
a228 3
writefsinfo(dosfs, boot)
	int dosfs;
	struct bootblock *boot;
@


1.8
log
@spelling
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.7 2002/02/14 02:53:36 aaron Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.7 2002/02/14 02:53:36 aaron Exp $";
d60 1
a60 1
		perror("could not read boot block"); 		
@


1.7
log
@Don't divide by zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 2001/07/03 13:03:44 ian Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.6 2001/07/03 13:03:44 ian Exp $";
d265 1
a265 1
	 * fixing it if neccessary, but otherwise ignoring the
@


1.6
log
@Put missing \n's in som error messages; consolidate redundant "if" (OK theo@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 1999/08/30 20:27:45 espie Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.5 1999/08/30 20:27:45 espie Exp $";
d169 2
a170 7
	boot->ClusterOffset = (boot->RootDirEnts * 32 + boot->BytesPerSec - 1)
	    / boot->BytesPerSec
	    + boot->ResSectors
	    + boot->FATs * boot->FATsecs
	    - CLUST_FIRST * boot->SecPerClust;

	if (boot->BytesPerSec % DOSBOOTBLOCKSIZE != 0) {
d178 7
@


1.5
log
@Cater to Win95 brokenness (from netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 1998/01/11 20:40:28 provos Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.4 1998/01/11 20:40:28 provos Exp $";
d65 1
a65 1
		pfatal("Invalid signature in boot block: %02x%02x", block[511], block[510]);
d99 1
a99 1
			pfatal("Unknown filesystem version: %x.%x",
d163 1
a163 1
			pfatal("backup doesn't compare to primary bootblock");
d176 1
a176 1
		pfatal("Invalid sector size: %u", boot->BytesPerSec);
d180 1
a180 1
		pfatal("Invalid cluster size: %u", boot->SecPerClust);
d197 1
a197 1
		pfatal("Filesystem too big (%u clusters) for non-FAT32 partition",
@


1.4
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.3 1997/03/02 05:25:51 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.3 1997/03/02 05:25:51 millert Exp $";
d255 12
a266 1
	return FSBOOTMOD;
@


1.3
log
@Update based on latest NetBSD version.
Now uses functions from util.[ch] instead of local ones.
Also some anal KNF from me...
@
text
@d1 2
a2 2
/*	$OpenBSD: boot.c,v 1.2 1996/06/23 14:30:41 deraadt Exp $	*/
/*	$NetBSD: boot.c,v 1.3 1996/09/27 23:22:51 christos Exp $	*/
d5 1
a5 1
 * Copyright (C) 1995 Wolfgang Solfrank
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.2 1996/06/23 14:30:41 deraadt Exp $";
d55 6
a60 7
	int n;
	
	if ((n = read(dosfs, block, sizeof block)) < (int)sizeof block) {
		if (n < 0)
			perror("could not read boot block");
		else
			pfatal("Short bootblock?");
d64 8
d80 1
a80 1
	boot->FATsecs = block[22] + (block[23] << 8);
d85 84
d176 1
a176 1
		pfatal("Invalid sector size: %u\n", boot->BytesPerSec);
d180 1
a180 1
		pfatal("Invalid cluster size: %u\n", boot->SecPerClust);
a188 4
	if (boot->NumClusters >= MAX12BITCLUSTERS)
		boot->Is16BitFat = 1;
	else
		boot->Is16BitFat = 0;
d190 17
a206 1
	if (boot->Is16BitFat)
d208 2
a209 1
	else
d211 3
d215 1
a215 1
		pfatal("FAT size too small, %d entries won't fit into %u sectors\n", 
d223 33
a255 2
	
	return (FSOK);
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: boot.c,v 1.1 1996/05/14 17:39:28 ws Exp $	*/
/*	$NetBSD: boot.c,v 1.1 1996/05/14 17:39:28 ws Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: boot.c,v 1.1 1996/05/14 17:39:28 ws Exp $";
d62 1
a62 1
		return FSFATAL;
d86 1
a86 1
		return FSFATAL;
d90 1
a90 1
		return FSFATAL;
d110 1
a110 1
		return FSFATAL;
d117 1
a117 1
	return FSOK;
@


1.1
log
@add fsck_msdos
@
text
@d1 1
d38 1
a38 1
static char rcsid[] = "$NetBSD: boot.c,v 1.1 1996/05/14 17:39:28 ws Exp $";
@
