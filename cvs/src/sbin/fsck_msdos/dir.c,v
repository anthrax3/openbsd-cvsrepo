head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.6
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.21.0.20
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.16
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.14
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.12
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.16
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.12
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.10
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.8
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.30
date	2015.12.10.17.26.59;	author mmcc;	state Exp;
branches;
next	1.29;
commitid	82PdNqu2kKAuXPfA;

1.29
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	0qPuuXwccpVXsXcV;

1.28
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2014.11.18.20.51.00;	author krw;	state Exp;
branches;
next	1.26;
commitid	G35ycnLxaVis5TX9;

1.26
date	2014.07.11.14.35.19;	author tobias;	state Exp;
branches;
next	1.25;
commitid	fiDzeWWuNMVo8C3K;

1.25
date	2014.07.10.18.59.49;	author tobias;	state Exp;
branches;
next	1.24;
commitid	XLhZISC2K7XJ12yF;

1.24
date	2014.07.09.18.32.34;	author tobias;	state Exp;
branches;
next	1.23;
commitid	OiJs6kBJGusNE7dk;

1.23
date	2014.06.18.17.29.07;	author tobias;	state Exp;
branches;
next	1.22;
commitid	tNIHI7fdHdn0PBfG;

1.22
date	2014.06.16.18.33.33;	author tobias;	state Exp;
branches;
next	1.21;
commitid	PhPZAfTlrgjKIup9;

1.21
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.27.22.30.09;	author thib;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.30.08.31.53;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.13.09.09.25;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.17.19.42.27;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.07.18.26.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.03.13.03.45;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.09.06.12.40.52;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.08.30.20.29.35;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	98.01.11.20.40.31;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.09.11.08.15.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.03.02.05.25.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.02.28.08.36.11;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.18.06.59.03;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.17.19.31.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.04.38.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.23.54;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: dir.c,v 1.29 2015/08/20 22:02:21 deraadt Exp $	*/
/*	$NetBSD: dir.c,v 1.11 1997/10/17 11:19:35 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997 Wolfgang Solfrank
 * Copyright (c) 1995 Martin Husemann
 * Some structure declaration borrowed from Paul Popelka
 * (paulp@@uts.amdahl.com), see /sys/msdosfs/ for reference.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <limits.h>
#include <time.h>

#include "ext.h"

#define	SLOT_EMPTY	0x00		/* slot has never been used */
#define	SLOT_E5		0x05		/* the real value is 0xe5 */
#define	SLOT_DELETED	0xe5		/* file in this slot deleted */

#define	ATTR_NORMAL	0x00		/* normal file */
#define	ATTR_READONLY	0x01		/* file is readonly */
#define	ATTR_HIDDEN	0x02		/* file is hidden */
#define	ATTR_SYSTEM	0x04		/* file is a system file */
#define	ATTR_VOLUME	0x08		/* entry is a volume label */
#define	ATTR_DIRECTORY	0x10		/* entry is a directory name */
#define	ATTR_ARCHIVE	0x20		/* file is new or modified */

#define	ATTR_WIN95	0x0f		/* long name record */

/*
 * This is the format of the contents of the deTime field in the direntry
 * structure.
 * We don't use bitfields because we don't know how compilers for
 * arbitrary machines will lay them out.
 */
#define DT_2SECONDS_MASK	0x1F	/* seconds divided by 2 */
#define DT_2SECONDS_SHIFT	0
#define DT_MINUTES_MASK		0x7E0	/* minutes */
#define DT_MINUTES_SHIFT	5
#define DT_HOURS_MASK		0xF800	/* hours */
#define DT_HOURS_SHIFT		11

/*
 * This is the format of the contents of the deDate field in the direntry
 * structure.
 */
#define DD_DAY_MASK		0x1F	/* day of month */
#define DD_DAY_SHIFT		0
#define DD_MONTH_MASK		0x1E0	/* month */
#define DD_MONTH_SHIFT		5
#define DD_YEAR_MASK		0xFE00	/* year - 1980 */
#define DD_YEAR_SHIFT		9

/* dir.c */
static struct dosDirEntry *newDosDirEntry(void);
static void freeDosDirEntry(struct dosDirEntry *);
static struct dirTodoNode *newDirTodo(void);
static void freeDirTodo(struct dirTodoNode *);
static char *fullpath(struct dosDirEntry *);
static u_char calcShortSum(u_char *);
static int delete(int, struct bootblock *, struct fatEntry *, cl_t, int,
    cl_t, int, int);
static int removede(int, struct bootblock *, struct fatEntry *, u_char *,
    u_char *, cl_t, cl_t, cl_t, char *, int);
static int checksize(struct bootblock *, struct fatEntry *, u_char *,
    struct dosDirEntry *);
static int readDosDirSection(int, struct bootblock *, struct fatEntry *,
    struct dosDirEntry *);

/*
 * Manage free dosDirEntry structures.
 */
static struct dosDirEntry *freede;

static struct dosDirEntry *
newDosDirEntry(void)
{
	struct dosDirEntry *de;

	if (!(de = freede)) {
		if (!(de = malloc(sizeof *de)))
			return (0);
	} else
		freede = de->next;
	return (de);
}

static void
freeDosDirEntry(struct dosDirEntry *de)
{
	de->next = freede;
	freede = de;
}

/*
 * The same for dirTodoNode structures.
 */
static struct dirTodoNode *freedt;

static struct dirTodoNode *
newDirTodo(void)
{
	struct dirTodoNode *dt;

	if (!(dt = freedt)) {
		if (!(dt = malloc(sizeof *dt)))
			return (0);
	} else
		freedt = dt->next;
	return (dt);
}

static void
freeDirTodo(struct dirTodoNode *dt)
{
	dt->next = freedt;
	freedt = dt;
}

/*
 * The stack of unread directories
 */
static struct dirTodoNode *pendingDirectories = NULL;

/*
 * Return the full pathname for a directory entry.
 */
static char *
fullpath(struct dosDirEntry *dir)
{
	static char namebuf[PATH_MAX + 1];
	char *cp, *np;
	int nl;

	cp = namebuf + sizeof namebuf;
	*--cp = '\0';
	for(;;) {
		np = dir->lname[0] ? dir->lname : dir->name;
		nl = strlen(np);
			/* cf dosDirEntry, sizeof(lname) < MAXPATHLEN, so test is safe */
		if (cp <= namebuf + 1 + nl) {
			*--cp = '?';
			break;
		}
		cp -= nl;
		(void)memcpy(cp, np, nl);
		dir = dir->parent;
		if (!dir)
			break;
		*--cp = '/';
	}
	return (cp);
}

/*
 * Calculate a checksum over an 8.3 alias name
 */
static u_char
calcShortSum(u_char *p)
{
	u_char sum = 0;
	int i;

	for (i = 0; i < 11; i++) {
		sum = (sum << 7)|(sum >> 1);	/* rotate right */
		sum += p[i];
	}

	return (sum);
}

/*
 * Global variables temporarily used during a directory scan
 */
static char longName[DOSLONGNAMELEN] = "";
static u_char *buffer = NULL;
static u_char *delbuf = NULL;

static struct dosDirEntry *rootDir;
static struct dosDirEntry *lostDir;

/*
 * Init internal state for a new directory scan.
 */
int
resetDosDirSection(struct bootblock *boot, struct fatEntry *fat)
{
	int b1, b2;
	int ret = FSOK;

	b1 = boot->RootDirEnts * 32;
	b2 = boot->SecPerClust * boot->BytesPerSec;

	if (!(buffer = malloc(b1 > b2 ? b1 : b2))
	    || !(delbuf = malloc(b2))
	    || !(rootDir = newDosDirEntry())) {
		xperror("No space for directory");
		goto fail;
	}
	(void)memset(rootDir, 0, sizeof *rootDir);
	if (boot->flags & FAT32) {
		if (boot->RootCl < CLUST_FIRST || boot->RootCl >= boot->NumClusters) {
			pfatal("Root directory starts with cluster out of range(%u)\n",
			       boot->RootCl);
			goto fail;
		}
		if (fat[boot->RootCl].head != boot->RootCl) {
			pfatal("Root directory doesn't start a cluster chain\n");
			goto fail;
		}

		fat[boot->RootCl].flags |= FAT_USED;
		rootDir->head = boot->RootCl;
	}

	return (ret);
fail:
	finishDosDirSection();
	return (FSFATAL);
}

/*
 * Cleanup after a directory scan
 */
void
finishDosDirSection(void)
{
	struct dirTodoNode *p, *np;
	struct dosDirEntry *d, *nd;

	for (p = pendingDirectories; p; p = np) {
		np = p->next;
		freeDirTodo(p);
	}
	pendingDirectories = 0;
	for (d = rootDir; d; d = nd) {
		if ((nd = d->child) != NULL) {
			d->child = 0;
			continue;
		}
		if (!(nd = d->next))
			nd = d->parent;
		freeDosDirEntry(d);
	}
	rootDir = lostDir = NULL;
	free(buffer);
	free(delbuf);
	buffer = NULL;
	delbuf = NULL;
}

/*
 * Delete directory entries between startcl, startoff and endcl, endoff.
 */
static int
delete(int f, struct bootblock *boot, struct fatEntry *fat, cl_t startcl,
       int startoff, cl_t endcl, int endoff, int notlast)
{
	u_char *s, *e;
	off_t off;
	int clsz = boot->SecPerClust * boot->BytesPerSec;

	s = delbuf + startoff;
	e = delbuf + clsz;
	while (startcl >= CLUST_FIRST && startcl < boot->NumClusters) {
		if (startcl == endcl) {
			if (notlast)
				break;
			e = delbuf + endoff;
		}
		off = startcl * boot->SecPerClust + boot->ClusterOffset;
		off *= boot->BytesPerSec;
		if (lseek(f, off, SEEK_SET) != off
		    || read(f, delbuf, clsz) != clsz) {
			xperror("Unable to read directory");
			return (FSFATAL);
		}
		while (s < e) {
			*s = SLOT_DELETED;
			s += 32;
		}
		if (lseek(f, off, SEEK_SET) != off
		    || write(f, delbuf, clsz) != clsz) {
			xperror("Unable to write directory");
			return (FSFATAL);
		}
		if (startcl == endcl)
			break;
		startcl = fat[startcl].next;
		s = delbuf;
	}
	return (FSOK);
}

static int
removede(int f, struct bootblock *boot, struct fatEntry *fat, u_char *start,
	 u_char *end, cl_t startcl, cl_t endcl, cl_t curcl, char *path, int type)
{
	switch (type) {
	case 0:
		pwarn("Invalid long filename entry for %s\n", path);
		break;
	case 1:
		pwarn("Invalid long filename entry at end of directory %s\n", path);
		break;
	case 2:
		pwarn("Invalid long filename entry for volume label\n");
		break;
	}
	if (ask(0, "Remove")) {
		if (startcl != curcl) {
			if (delete(f, boot, fat,
				   startcl, start - buffer,
				   endcl, end - buffer,
				   endcl == curcl) == FSFATAL)
				return (FSFATAL);
			start = buffer;
		}
		if (endcl == curcl)
			for (; start < end; start += 32)
				*start = SLOT_DELETED;
		return (FSDIRMOD);
	}
	return (FSERROR);
}

/*
 * Check an in-memory file entry
 */
static int
checksize(struct bootblock *boot, struct fatEntry *fat, u_char *p,
	  struct dosDirEntry *dir)
{
	/*
	 * Check size on ordinary files
	 */
	u_int32_t physicalSize;

	if (dir->head == CLUST_FREE)
		physicalSize = 0;
	else {
		if (dir->head < CLUST_FIRST || dir->head >= boot->NumClusters)
			return (FSERROR);
		physicalSize = fat[dir->head].length * boot->ClusterSize;
	}
	if (physicalSize < dir->size) {
		pwarn("size of %s is %u, should at most be %u\n",
		      fullpath(dir), dir->size, physicalSize);
		if (ask(1, "Truncate")) {
			dir->size = physicalSize;
			p[28] = (u_char)physicalSize;
			p[29] = (u_char)(physicalSize >> 8);
			p[30] = (u_char)(physicalSize >> 16);
			p[31] = (u_char)(physicalSize >> 24);
			return (FSDIRMOD);
		} else
			return (FSERROR);
	} else if (physicalSize - dir->size >= boot->ClusterSize) {
		pwarn("%s has too many clusters allocated\n",
		      fullpath(dir));
		if (ask(1, "Drop superfluous clusters")) {
			cl_t cl;
			u_int32_t len, sz;

			len = sz = 0;
			for (cl = dir->head; (sz += boot->ClusterSize) < dir->size;) {
				cl = fat[cl].next;
				len++;
			}
			clearchain(boot, fat, fat[cl].next);
			fat[cl].next = CLUST_EOF;
			fat[dir->head].length = len;
			return (FSFATMOD);
		} else
			return (FSERROR);
	}
	return (FSOK);
}

/*
 * Read a directory and
 *   - resolve long name records
 *   - enter file and directory records into the parent's list
 *   - push directories onto the todo-stack
 */
static int
readDosDirSection(int f, struct bootblock *boot, struct fatEntry *fat,
		  struct dosDirEntry *dir)
{
	struct dosDirEntry dirent, *d;
	u_char *p, *vallfn, *invlfn, *empty;
	off_t off;
	int i, j, k, last;
	cl_t cl, valcl = ~0, invcl = ~0, empcl = ~0;
	char *t;
	u_int lidx = 0;
	int shortSum;
	int mod = FSOK;
#define	THISMOD	0x8000			/* Only used within this routine */

	cl = dir->head;
	if (dir->parent && (cl < CLUST_FIRST || cl >= boot->NumClusters)) {
		/*
		 * Already handled somewhere else.
		 */
		return (FSOK);
	}
	shortSum = -1;
	vallfn = invlfn = empty = NULL;
	do {
		if (!(boot->flags & FAT32) && !dir->parent) {
			last = boot->RootDirEnts * 32;
			off = boot->ResSectors + boot->FATs * boot->FATsecs;
		} else {
			last = boot->SecPerClust * boot->BytesPerSec;
			off = cl * boot->SecPerClust + boot->ClusterOffset;
		}

		off *= boot->BytesPerSec;
		if (lseek(f, off, SEEK_SET) != off
		    || read(f, buffer, last) != last) {
			xperror("Unable to read directory");
			return (FSFATAL);
		}
		last /= 32;
		/*
		 * Check `.' and `..' entries here?			XXX
		 */
		for (p = buffer, i = 0; i < last; i++, p += 32) {
			if (dir->fsckflags & DIREMPWARN) {
				*p = SLOT_EMPTY;
				continue;
			}

			if (*p == SLOT_EMPTY || *p == SLOT_DELETED) {
				if (*p == SLOT_EMPTY) {
					dir->fsckflags |= DIREMPTY;
					empty = p;
					empcl = cl;
				}
				continue;
			}

			if (dir->fsckflags & DIREMPTY) {
				if (!(dir->fsckflags & DIREMPWARN)) {
					pwarn("%s has entries after end of directory\n",
					      fullpath(dir));
					if (ask(1, "Extend")) {
						u_char *q;

						dir->fsckflags &= ~DIREMPTY;
						if (delete(f, boot, fat,
							   empcl, empty - buffer,
							   cl, p - buffer, 1) == FSFATAL)
							return (FSFATAL);
						q = empcl == cl ? empty : buffer;
						for (; q < p; q += 32)
							*q = SLOT_DELETED;
						mod |= THISMOD|FSDIRMOD;
					} else if (ask(0, "Truncate"))
						dir->fsckflags |= DIREMPWARN;
				}
				if (dir->fsckflags & DIREMPWARN) {
					*p = SLOT_DELETED;
					mod |= THISMOD|FSDIRMOD;
					continue;
				} else if (dir->fsckflags & DIREMPTY)
					mod |= FSERROR;
				empty = NULL;
			}

			if (p[11] == ATTR_WIN95) {
				if (*p & LRFIRST) {
					if (shortSum != -1) {
						if (!invlfn) {
							invlfn = vallfn;
							invcl = valcl;
						}
					}
					(void)memset(longName, 0, sizeof longName);
					shortSum = p[13];
					vallfn = p;
					valcl = cl;
				} else if (shortSum != p[13]
					   || lidx != (*p & LRNOMASK)) {
					if (!invlfn) {
						invlfn = vallfn;
						invcl = valcl;
					}
					if (!invlfn) {
						invlfn = p;
						invcl = cl;
					}
					vallfn = NULL;
				}
				lidx = *p & LRNOMASK;
				if (lidx == 0) {
					if (!invlfn) {
						invlfn = vallfn;
						invcl = valcl;
					}
					vallfn = NULL;
					continue;
				}
				t = longName + --lidx * 13;
				for (k = 1; k < 11 && t < longName + sizeof(longName); k += 2) {
					if (!p[k] && !p[k + 1])
						break;
					*t++ = p[k];
					/*
					 * Warn about those unusable chars in msdosfs here?	XXX
					 */
					if (p[k + 1])
						t[-1] = '?';
				}
				if (k >= 11)
					for (k = 14; k < 26 && t < longName + sizeof(longName); k += 2) {
						if (!p[k] && !p[k + 1])
							break;
						*t++ = p[k];
						if (p[k + 1])
							t[-1] = '?';
					}
				if (k >= 26)
					for (k = 28; k < 32 && t < longName + sizeof(longName); k += 2) {
						if (!p[k] && !p[k + 1])
							break;
						*t++ = p[k];
						if (p[k + 1])
							t[-1] = '?';
					}
				if (t >= longName + sizeof(longName)) {
					pwarn("long filename too long\n");
					if (!invlfn) {
						invlfn = vallfn;
						invcl = valcl;
					}
					vallfn = NULL;
				}
				if (p[26] | (p[27] << 8)) {
					pwarn("long filename record cluster start != 0\n");
					if (!invlfn) {
						invlfn = vallfn;
						invcl = cl;
					}
					vallfn = NULL;
				}
				continue;	/* long records don't carry further
						 * information */
			}

			/*
			 * This is a standard msdosfs directory entry.
			 */
			(void)memset(&dirent, 0, sizeof dirent);

			/*
			 * it's a short name record, but we need to know
			 * more, so get the flags first.
			 */
			dirent.flags = p[11];

			/*
			 * Translate from 850 to ISO here		XXX
			 */
			for (j = 0; j < 8; j++)
				dirent.name[j] = p[j];
			dirent.name[8] = '\0';
			for (k = 7; k >= 0 && dirent.name[k] == ' '; k--)
				dirent.name[k] = '\0';
			if (dirent.name[k] != '\0')
				k++;
			if (dirent.name[0] == SLOT_E5)
				dirent.name[0] = 0xe5;

			if (dirent.flags & ATTR_VOLUME) {
				if (vallfn || invlfn) {
					mod |= removede(f, boot, fat,
							invlfn ? invlfn : vallfn, p,
							invlfn ? invcl : valcl, -1, 0,
							fullpath(dir), 2);
					vallfn = NULL;
					invlfn = NULL;
				}
				continue;
			}

			if (p[8] != ' ')
				dirent.name[k++] = '.';
			for (j = 0; j < 3; j++)
				dirent.name[k++] = p[j+8];
			dirent.name[k] = '\0';
			for (k--; k >= 0 && dirent.name[k] == ' '; k--)
				dirent.name[k] = '\0';

			if (vallfn && shortSum != calcShortSum(p)) {
				if (!invlfn) {
					invlfn = vallfn;
					invcl = valcl;
				}
				vallfn = NULL;
			}
			dirent.head = p[26] | (p[27] << 8);
			if (boot->ClustMask == CLUST32_MASK)
				dirent.head |= (p[20] << 16) | (p[21] << 24);
			dirent.size = p[28] | (p[29] << 8) | (p[30] << 16) | (p[31] << 24);
			if (vallfn) {
				strlcpy(dirent.lname, longName, sizeof dirent.lname);
				longName[0] = '\0';
				shortSum = -1;
			}

			dirent.parent = dir;
			dirent.next = dir->child;

			if (invlfn) {
				mod |= k = removede(f, boot, fat,
						    invlfn, vallfn ? vallfn : p,
						    invcl, vallfn ? valcl : cl, cl,
						    fullpath(&dirent), 0);
				if (mod & FSFATAL)
					return (FSFATAL);
				if (vallfn
				    ? (valcl == cl && vallfn != buffer)
				    : p != buffer)
					if (k & FSDIRMOD)
						mod |= THISMOD;
			}

			vallfn = NULL; /* not used any longer */
			invlfn = NULL;

			if (dirent.size == 0 && !(dirent.flags & ATTR_DIRECTORY)) {
				if (dirent.head != 0) {
					pwarn("%s has clusters, but size 0\n",
					      fullpath(&dirent));
					if (ask(1, "Drop allocated clusters")) {
						p[26] = p[27] = 0;
						if (boot->ClustMask == CLUST32_MASK)
							p[20] = p[21] = 0;
						clearchain(boot, fat, dirent.head);
						dirent.head = 0;
						mod |= THISMOD|FSDIRMOD|FSFATMOD;
					} else
						mod |= FSERROR;
				}
			} else if (dirent.head == 0
				   && !strcmp(dirent.name, "..")
				   && dir->parent			/* XXX */
				   && !dir->parent->parent) {
				/*
				 *  Do nothing, the parent is the root
				 */
			} else if (dirent.head < CLUST_FIRST
				   || dirent.head >= boot->NumClusters
				   || fat[dirent.head].next == CLUST_FREE
				   || (fat[dirent.head].next >= CLUST_RSRVD
				       && fat[dirent.head].next < CLUST_EOFS)
				   || fat[dirent.head].head != dirent.head) {
				if (dirent.head == 0)
					pwarn("%s has no clusters\n",
					      fullpath(&dirent));
				else if (dirent.head < CLUST_FIRST
					 || dirent.head >= boot->NumClusters)
					pwarn("%s starts with cluster out of range(%u)\n",
					      fullpath(&dirent),
					      dirent.head);
				else if (fat[dirent.head].next == CLUST_FREE)
					pwarn("%s starts with free cluster\n",
					      fullpath(&dirent));
				else if (fat[dirent.head].next >= CLUST_RSRVD)
					pwarn("%s starts with cluster marked %s\n",
					      fullpath(&dirent),
					      rsrvdcltype(fat[dirent.head].next));
				else
					pwarn("%s doesn't start a cluster chain\n",
					      fullpath(&dirent));
				if (dirent.flags & ATTR_DIRECTORY) {
					if (ask(0, "Remove")) {
						*p = SLOT_DELETED;
						mod |= THISMOD|FSDIRMOD;
					} else
						mod |= FSERROR;
					continue;
				} else {
					if (ask(1, "Truncate")) {
						p[28] = p[29] = p[30] = p[31] = 0;
						p[26] = p[27] = 0;
						if (boot->ClustMask == CLUST32_MASK)
							p[20] = p[21] = 0;
						dirent.size = 0;
						mod |= THISMOD|FSDIRMOD;
					} else
						mod |= FSERROR;
				}
			}

			if (dirent.head >= CLUST_FIRST && dirent.head < boot->NumClusters)
				fat[dirent.head].flags |= FAT_USED;

			if (dirent.flags & ATTR_DIRECTORY) {
				/*
				 * gather more info for directories
				 */
				struct dirTodoNode *n;

				if (dirent.size) {
					pwarn("Directory %s has size != 0\n",
					      fullpath(&dirent));
					if (ask(1, "Correct")) {
						p[28] = p[29] = p[30] = p[31] = 0;
						dirent.size = 0;
						mod |= THISMOD|FSDIRMOD;
					} else
						mod |= FSERROR;
				}
				/*
				 * handle `.' and `..' specially
				 */
				if (strcmp(dirent.name, ".") == 0) {
					if (dirent.head != dir->head) {
						pwarn("`.' entry in %s has incorrect start cluster\n",
						      fullpath(dir));
						if (ask(1, "Correct")) {
							dirent.head = dir->head;
							p[26] = (u_char)dirent.head;
							p[27] = (u_char)(dirent.head >> 8);
							if (boot->ClustMask == CLUST32_MASK) {
								p[20] = (u_char)(dirent.head >> 16);
								p[21] = (u_char)(dirent.head >> 24);
							}
							mod |= THISMOD|FSDIRMOD;
						} else
							mod |= FSERROR;
					}
					continue;
				}
				if (strcmp(dirent.name, "..") == 0) {
					if (dir->parent) {		/* XXX */
						if (!dir->parent->parent) {
							if (dirent.head) {
								pwarn("`..' entry in %s has non-zero start cluster\n",
								      fullpath(dir));
								if (ask(1, "Correct")) {
									dirent.head = 0;
									p[26] = p[27] = 0;
									if (boot->ClustMask == CLUST32_MASK)
										p[20] = p[21] = 0;
									mod |= THISMOD|FSDIRMOD;
								} else
									mod |= FSERROR;
							}
						} else if (dirent.head != dir->parent->head) {
							pwarn("`..' entry in %s has incorrect start cluster\n",
							      fullpath(dir));
							if (ask(1, "Correct")) {
								dirent.head = dir->parent->head;
								p[26] = (u_char)dirent.head;
								p[27] = (u_char)(dirent.head >> 8);
								if (boot->ClustMask == CLUST32_MASK) {
									p[20] = (u_char)(dirent.head >> 16);
									p[21] = (u_char)(dirent.head >> 24);
								}
								mod |= THISMOD|FSDIRMOD;
							} else
								mod |= FSERROR;
						}
					}
					continue;
				}

				/* create directory tree node */
				if (!(d = newDosDirEntry())) {
					xperror("No space for directory");
					return (FSFATAL);
				}
				(void)memcpy(d, &dirent, sizeof(struct dosDirEntry));
				/* link it into the tree */
				dir->child = d;

				/* Enter this directory into the todo list */
				if (!(n = newDirTodo())) {
					xperror("No space for todo list");
					return (FSFATAL);
				}
				n->next = pendingDirectories;
				n->dir = d;
				pendingDirectories = n;
			} else {
				mod |= k = checksize(boot, fat, p, &dirent);
				if (k & FSDIRMOD)
					mod |= THISMOD;
			}
			boot->NumFiles++;
		}
		if (mod & THISMOD) {
			last *= 32;
			if (lseek(f, off, SEEK_SET) != off
			    || write(f, buffer, last) != last) {
				xperror("Unable to write directory");
				return (FSFATAL);
			}
			mod &= ~THISMOD;
		}
	} while ((cl = fat[cl].next) >= CLUST_FIRST && cl < boot->NumClusters);
	if (invlfn || vallfn)
		mod |= removede(f, boot, fat,
				invlfn ? invlfn : vallfn, p,
				invlfn ? invcl : valcl, -1, 0,
				fullpath(dir), 1);
	return (mod & ~THISMOD);
}

int
handleDirTree(int dosfs, struct bootblock *boot, struct fatEntry *fat)
{
	int mod;

	mod = readDosDirSection(dosfs, boot, fat, rootDir);
	if (mod & FSFATAL)
		return (FSFATAL);

	if (mod & FSFATMOD) {
		mod &= ~FSFATMOD;
		mod |= writefat(dosfs, boot, fat); /* delay writing fats?	XXX */
	}

	if (mod & FSFATAL)
		return (FSFATAL);

	/*
	 * process the directory todo list
	 */
	while (pendingDirectories) {
		struct dosDirEntry *dir = pendingDirectories->dir;
		struct dirTodoNode *n = pendingDirectories->next;

		/*
		 * remove TODO entry now, the list might change during
		 * directory reads
		 */
		freeDirTodo(pendingDirectories);
		pendingDirectories = n;

		/*
		 * handle subdirectory
		 */
		mod |= readDosDirSection(dosfs, boot, fat, dir);
		if (mod & FSFATAL)
			return (FSFATAL);
		if (mod & FSFATMOD) {
			mod &= ~FSFATMOD;
			mod |= writefat(dosfs, boot, fat); /* delay writing fats? XXX */
		}
		if (mod & FSFATAL)
			return (FSFATAL);
	}
	return (mod);
}

/*
 * Try to reconnect a FAT chain into dir
 */
static u_char *lfbuf;
static cl_t lfcl;
static off_t lfoff;

int
reconnect(int dosfs, struct bootblock *boot, struct fatEntry *fat, cl_t head)
{
	struct dosDirEntry d;
	u_char *p;

	if (!ask(1, "Reconnect"))
		return FSERROR;

	if (!lostDir) {
		for (lostDir = rootDir->child; lostDir; lostDir = lostDir->next) {
			if (!strcmp(lostDir->name, LOSTDIR))
				break;
		}
		if (!lostDir) {		/* Create LOSTDIR?		XXX */
			pwarn("No %s directory\n", LOSTDIR);
			return (FSERROR);
		}
	}
	if (!lfbuf) {
		lfbuf = malloc(boot->ClusterSize);
		if (!lfbuf) {
			xperror("No space for buffer");
			return (FSFATAL);
		}
		p = NULL;
	} else
		p = lfbuf;
	while (1) {
		if (p)
			for (; p < lfbuf + boot->ClusterSize; p += 32)
				if (*p == SLOT_EMPTY
				    || *p == SLOT_DELETED)
					break;
		if (p && p < lfbuf + boot->ClusterSize)
			break;
		lfcl = p ? fat[lfcl].next : lostDir->head;
		if (lfcl < CLUST_FIRST || lfcl >= boot->NumClusters) {
			/* Extend LOSTDIR?				XXX */
			pwarn("No space in %s\n", LOSTDIR);
			return (FSERROR);
		}
		lfoff = lfcl * boot->ClusterSize
		    + boot->ClusterOffset * boot->BytesPerSec;
		if (lseek(dosfs, lfoff, SEEK_SET) != lfoff
		    || read(dosfs, lfbuf, boot->ClusterSize) != boot->ClusterSize) {
			xperror("could not read LOST.DIR");
			return (FSFATAL);
		}
		p = lfbuf;
	}

	boot->NumFiles++;
	/* Ensure uniqueness of entry here!				XXX */
	(void)memset(&d, 0, sizeof d);
	snprintf(d.name, sizeof d.name, "%u", head);
	d.flags = 0;
	d.head = head;
	d.size = fat[head].length * boot->ClusterSize;

	(void)memset(p, 0, 32);
	(void)memset(p, ' ', 11);
	(void)memcpy(p, d.name, strlen(d.name));
	p[26] = (u_char)d.head;
	p[27] = (u_char)(d.head >> 8);
	if (boot->ClustMask == CLUST32_MASK) {
		p[20] = (u_char)(d.head >> 16);
		p[21] = (u_char)(d.head >> 24);
	}
	p[28] = (u_char)d.size;
	p[29] = (u_char)(d.size >> 8);
	p[30] = (u_char)(d.size >> 16);
	p[31] = (u_char)(d.size >> 24);
	fat[head].flags |= FAT_USED;
	if (lseek(dosfs, lfoff, SEEK_SET) != lfoff
	    || write(dosfs, lfbuf, boot->ClusterSize) != boot->ClusterSize) {
		xperror("could not write LOST.DIR");
		return (FSFATAL);
	}
	return (FSDIRMOD);
}

void
finishlf(void)
{
	free(lfbuf);
	lfbuf = NULL;
}
@


1.29
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.28 2015/01/16 06:39:58 deraadt Exp $	*/
d978 1
a978 2
	if (lfbuf)
		free(lfbuf);
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.27 2014/11/18 20:51:00 krw Exp $	*/
d106 1
a106 1
		if (!(de = (struct dosDirEntry *)malloc(sizeof *de)))
d131 1
a131 1
		if (!(dt = (struct dirTodoNode *)malloc(sizeof *dt)))
@


1.27
log
@Nuke some obvious #include duplications.

ok espie@@ deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.26 2014/07/11 14:35:19 tobias Exp $	*/
d36 1
a38 2
#include <sys/param.h>

d156 1
a156 1
	static char namebuf[MAXPATHLEN + 1];
@


1.26
log
@Remove redundant check and wrong fix: fat.c checks already take care
about cluster chains.  If the user didn't want to fix them at that time,
he asks for trouble -- and these checks didn't help in all cases either.

discussed with and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.25 2014/07/10 18:59:49 tobias Exp $	*/
a34 1
#include <stdio.h>
@


1.25
log
@Avoid out of boundary access when checking invalid long filenames.

Addressed by NetBSD in revision 1.24, but instead of ignoring the filename,
consider it invalid -- because it is.

ok krw@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.24 2014/07/09 18:32:34 tobias Exp $	*/
a215 1
	cl_t cl;
d234 3
a236 18
		cl = fat[boot->RootCl].next;
		if (cl < CLUST_FIRST
		    || (cl >= CLUST_RSRVD && cl< CLUST_EOFS)
		    || fat[boot->RootCl].head != boot->RootCl) {
			if (cl == CLUST_FREE)
				pwarn("Root directory starts with free cluster\n");
			else if (cl >= CLUST_RSRVD)
				pwarn("Root directory starts with cluster marked %s\n",
				      rsrvdcltype(cl));
			else {
				pfatal("Root directory doesn't start a cluster chain\n");
				goto fail;
			}
			if (ask(1, "Fix")) {
				fat[boot->RootCl].next = CLUST_FREE;
				ret = FSFATMOD;
			} else
				 ret = FSFATAL;
@


1.24
log
@Merge memory leak fix from NetBSD's dir.c revision 1.20, but actually
release all reserved memory chunks in all error cases.

with input by and ok tedu@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.23 2014/06/18 17:29:07 tobias Exp $	*/
d540 8
@


1.23
log
@Always keep length of cluster chain up to date, otherwise the drop of
superfluous clusters can lead to out of boundary access.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.22 2014/06/16 18:33:33 tobias Exp $	*/
d150 1
a150 1
struct dirTodoNode *pendingDirectories = NULL;
d206 1
a206 1
struct dosDirEntry *rootDir;
d226 1
a226 1
		return (FSFATAL);
d233 1
a233 1
			return (FSFATAL);
d246 1
a246 1
				return (FSFATAL);
d260 3
@


1.22
log
@Merge NetBSD commit:
Move to 2 clause license, approved by Wolfgang Solfrank.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.21 2009/10/27 23:59:33 deraadt Exp $	*/
d377 1
a377 1
	int32_t physicalSize;
d403 1
a403 1
			u_int32_t sz = 0;
d405 2
a406 1
			for (cl = dir->head; (sz += boot->ClusterSize) < dir->size;)
d408 2
d412 1
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.20 2006/05/27 22:30:09 thib Exp $	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Martin Husemann
 *	and Wolfgang Solfrank.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.20
log
@newline fix + s/perror/xperror since we are
using a home rolled version.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.19 2004/07/17 02:14:33 deraadt Exp $	*/
a36 5


#ifndef lint
static char rcsid[] = "$OpenBSD: dir.c,v 1.19 2004/07/17 02:14:33 deraadt Exp $";
#endif /* not lint */
@


1.19
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.18 2003/07/29 18:38:35 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.18 2003/07/29 18:38:35 deraadt Exp $";
d237 1
a237 1
		perror("No space for directory");
d327 1
a327 1
			perror("Unable to read directory");
d336 1
a336 1
			perror("Unable to write directory");
d470 1
a470 1
			perror("Unable to read directory");
d814 1
a814 1
					perror("No space for directory");
d823 1
a823 1
					perror("No space for todo list");
d840 1
a840 1
				perror("Unable to write directory");
d930 1
a930 1
			perror("No space for buffer");
d954 1
a954 1
			perror("could not read LOST.DIR");
d984 1
a984 1
		perror("could not write LOST.DIR");
@


1.18
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.17 2003/03/30 08:31:53 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.17 2003/03/30 08:31:53 deraadt Exp $";
d115 1
a115 1
newDosDirEntry()
d128 1
a128 2
freeDosDirEntry(de)
	struct dosDirEntry *de;
d140 1
a140 1
newDirTodo()
d153 1
a153 2
freeDirTodo(dt)
	struct dirTodoNode *dt;
d168 1
a168 2
fullpath(dir)
	struct dosDirEntry *dir;
d198 1
a198 2
calcShortSum(p)
	u_char *p;
d225 1
a225 3
resetDosDirSection(boot, fat)
	struct bootblock *boot;
	struct fatEntry *fat;
d278 1
a278 1
finishDosDirSection()
d308 2
a309 9
delete(f, boot, fat, startcl, startoff, endcl, endoff, notlast)
	int f;
	struct bootblock *boot;
	struct fatEntry *fat;
	cl_t startcl;
	int startoff;
	cl_t endcl;
	int endoff;
	int notlast;
d348 2
a349 11
removede(f, boot, fat, start, end, startcl, endcl, curcl, path, type)
	int f;
	struct bootblock *boot;
	struct fatEntry *fat;
	u_char *start;
	u_char *end;
	cl_t startcl;
	cl_t endcl;
	cl_t curcl;
	char *path;
	int type;
d383 2
a384 5
checksize(boot, fat, p, dir)
	struct bootblock *boot;
	struct fatEntry *fat;
	u_char *p;
	struct dosDirEntry *dir;
d435 2
a436 5
readDosDirSection(f, boot, fat, dir)
	int f;
	struct bootblock *boot;
	struct fatEntry *fat;
	struct dosDirEntry *dir;
d855 1
a855 4
handleDirTree(dosfs, boot, fat)
	int dosfs;
	struct bootblock *boot;
	struct fatEntry *fat;
d909 1
a909 5
reconnect(dosfs, boot, fat, head)
	int dosfs;
	struct bootblock *boot;
	struct fatEntry *fat;
	cl_t head;
d991 1
a991 1
finishlf()
@


1.17
log
@snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.16 2003/03/13 09:09:25 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.16 2003/03/13 09:09:25 deraadt Exp $";
d889 1
a889 1
	
@


1.16
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.15 2002/02/17 19:42:27 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.15 2002/02/17 19:42:27 millert Exp $";
d998 1
a998 1
	sprintf(d.name, "%u", head);
@


1.15
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.14 2002/02/16 21:27:34 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.14 2002/02/16 21:27:34 millert Exp $";
d676 1
a676 1
				strcpy(dirent.lname, longName);
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.13 2001/07/07 18:26:12 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.13 2001/07/07 18:26:12 deraadt Exp $";
d100 8
a107 8
static int delete __P((int, struct bootblock *, struct fatEntry *, cl_t, int,
    cl_t, int, int));
static int removede __P((int, struct bootblock *, struct fatEntry *, u_char *,
    u_char *, cl_t, cl_t, cl_t, char *, int));
static int checksize __P((struct bootblock *, struct fatEntry *, u_char *,
    struct dosDirEntry *));
static int readDosDirSection __P((int, struct bootblock *, struct fatEntry *,
    struct dosDirEntry *));
@


1.13
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.12 2001/07/03 13:03:45 ian Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.12 2001/07/03 13:03:45 ian Exp $";
d94 6
a99 6
static struct dosDirEntry *newDosDirEntry __P((void));
static void freeDosDirEntry __P((struct dosDirEntry *));
static struct dirTodoNode *newDirTodo __P((void));
static void freeDirTodo __P((struct dirTodoNode *));
static char *fullpath __P((struct dosDirEntry *));
static u_char calcShortSum __P((u_char *));
@


1.12
log
@Put missing \n's in som error messages; consolidate redundant "if" (OK theo@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.11 1999/09/06 12:40:52 espie Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.11 1999/09/06 12:40:52 espie Exp $";
d807 1
a807 1
					if (dir->parent)		/* XXX */
d836 1
@


1.11
log
@Corrected overflow logic in fullpath.

<subliminal FreeBSD/NetBSD>Oh yeah, baby, you want that one</subliminal :->
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.9 1998/01/11 20:40:31 provos Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.9 1998/01/11 20:40:31 provos Exp $";
d249 1
a249 1
			pfatal("Root directory starts with cluster out of range(%u)",
d263 1
a263 1
				pfatal("Root directory doesn't start a cluster chain");
@


1.10
log
@Fix obvious logic error (from netbsd)
@
text
@d177 3
a179 3
	cp = namebuf + sizeof namebuf - 1;
	*cp = '\0';
	do {
d182 3
a184 1
		if ((cp -= nl) <= namebuf + 1)
d186 2
d189 3
d193 1
a193 5
	} while ((dir = dir->parent) != NULL);
	if (dir != NULL && dir->parent != NULL)
		*--cp = '?';
	else
		cp++;
@


1.9
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.8 1997/09/11 08:15:24 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.8 1997/09/11 08:15:24 deraadt Exp $";
d945 1
a945 1
	if (ask(1, "Reconnect"))
@


1.8
log
@from ws@@netbsd; Fix a few bugs, especially when repairing disks:
Print correct pathname in error messages
Fix unterminating loop when trying to correct a bad fat
Require fat media byte to be the same as the one in the bpb
Fix unterminating loop when looking for free directory slot in LOST.DIR
(bad disk image provided by Christoph Badura)
@
text
@d1 2
a2 2
/*	$OpenBSD: dir.c,v 1.7 1997/03/02 05:25:53 millert Exp $	*/
/*	NetBSD: dir.c,v 1.9 1997/09/08 14:05:30 ws Exp $	*/
d5 1
a5 1
 * Copyright (C) 1995, 1996 Wolfgang Solfrank
d7 1
a7 1
 * Some structure declaration borrowed from Paul Popelka 
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.7 1997/03/02 05:25:53 millert Exp $";
d118 1
a118 1
	
d144 1
a144 1
	
d176 1
a176 1
	
d226 1
a226 1
resetDosDirSection(boot)
d228 1
d231 3
a233 1
	
d236 1
a236 1
	
d244 31
a274 1
	return (FSOK);
d285 1
a285 1
	
d324 1
a324 1
	
d397 1
a397 1
	
d438 1
a438 1
			
d484 1
a484 1
		if (!dir->parent) {
d491 1
a491 1
	
d507 1
a507 1
			
d516 1
a516 1
			
d544 1
a544 1
			
d621 1
a621 1
			
d627 1
a627 1
			
d660 1
a660 1
			
d669 2
d678 3
d694 1
a696 2
			dirent.parent = dir;
			dirent.next = dir->child;
d704 2
d730 1
a730 1
					pwarn("%s starts with cluster out of range(%d)\n",
d737 1
a737 1
					pwarn("%s starts with %s cluster\n",
d753 3
d762 1
a762 1
			
d765 1
a765 1
			
d770 2
a771 2
				struct dirTodoNode * n;
				
d793 4
d804 29
a832 12
					if (dir->parent			/* XXX */
					    && dirent.head != dir->parent->head) {
						pwarn("`..' entry in %s has incorrect start cluster\n",
						      fullpath(dir));
						if (ask(1, "Correct")) {
							dirent.head = dir->parent->head;
							p[26] = (u_char)dirent.head;
							p[27] = (u_char)(dirent.head >> 8);
							mod |= THISMOD|FSDIRMOD;
						} else
							mod |= FSERROR;
					}
d835 1
a835 1
				
d844 1
a844 1
				
d889 1
a889 1
	
d897 1
a897 1
	
d944 4
a947 1
	
a990 3
	if (!ask(0, "Reconnect"))
		return (FSERROR);

d994 1
a994 1
	sprintf(d.name, "%d", head);
d998 1
a998 1
	
d1004 4
@


1.7
log
@Update based on latest NetBSD version.
Now uses functions from util.[ch] instead of local ones.
Also some anal KNF from me...
@
text
@d1 2
a2 2
/*	$OpenBSD: dir.c,v 1.6 1997/02/28 08:36:11 millert Exp $	*/
/*	$NetBSD: dir.c,v 1.8 1996/09/27 23:22:52 christos Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.6 1997/02/28 08:36:11 millert Exp $";
d189 2
d658 3
a660 1
			
a720 2
			dirent.parent = dir;
			dirent.next = dir->child;
a772 2
				boot->NumFiles++;

a777 1
				
a793 1
				boot->NumFiles++;
d795 1
d903 1
a903 1
			while (p < lfbuf + boot->ClusterSize)
d918 1
a918 1
		    || read(dosfs, buffer, boot->ClusterSize) != boot->ClusterSize) {
d947 1
a947 1
	    || write(dosfs, buffer, boot->ClusterSize) != boot->ClusterSize) {
@


1.6
log
@From NetBSD (ws)
Fix handling of clusters marked bad; Noted by Rafal Boni
@
text
@d1 2
a2 2
/*	$OpenBSD: dir.c,v 1.5 1996/09/18 06:59:03 mickey Exp $	*/
/*	$NetBSD: dir.c,v 1.1.4.1 1996/05/31 18:41:38 jtc Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.5 1996/09/18 06:59:03 mickey Exp $";
d93 16
d121 1
a121 1
			return 0;
d124 1
a124 1
	return de;
d147 1
a147 1
			return 0;
d150 1
a150 1
	return dt;
d184 1
a184 1
		memcpy(cp, np, nl);
d186 1
a186 1
	} while ((dir = dir->parent));
d189 1
a189 1
	return cp;
d207 1
a207 1
	return sum;
d236 1
a236 1
		return FSFATAL;
d238 2
a239 2
	memset(rootDir, 0, sizeof *rootDir);
	return FSOK;
d257 1
a257 1
		if ((nd = d->child)) {
d303 1
a303 1
			return FSFATAL;
d312 1
a312 1
			return FSFATAL;
d319 1
a319 1
	return FSOK;
d352 1
a352 1
				return FSFATAL;
d358 1
a358 1
		return FSDIRMOD;
d360 1
a360 1
	return FSERROR;
d382 1
a382 1
			return FSERROR;
d386 1
a386 1
		pwarn("size of %s is %lu, should at most be %lu\n",
d394 1
a394 1
			return FSDIRMOD;
d396 1
a396 1
			return FSERROR;
d408 1
a408 1
			return FSFATMOD;
d410 1
a410 1
			return FSERROR;
d412 1
a412 1
	return FSOK;
d432 1
a432 1
	cl_t cl, valcl, invcl, empcl;
d444 1
a444 1
		return FSOK;
d461 1
a461 1
			return FSFATAL;
d487 2
d492 6
a497 2
							   cl, p - buffer) == FSFATAL)
							return FSFATAL;
d518 1
a518 1
					memset(longName, 0, sizeof longName);
d585 1
a585 1
			memset(&dirent, 0, sizeof dirent);
d647 1
a647 1
					return FSFATAL;
d776 1
a776 1
					return FSFATAL;
d779 1
a779 1
				memcpy(d, &dirent, sizeof(struct dosDirEntry));
d786 1
a786 1
					return FSFATAL;
d803 1
a803 1
				return FSFATAL;
d813 1
a813 1
	return mod & ~THISMOD;
d826 1
a826 1
		return FSFATAL;
d834 1
a834 1
		return FSFATAL;
d855 1
a855 1
			return FSFATAL;
d861 1
a861 1
			return FSFATAL;
d863 1
a863 1
	return mod;
d890 1
a890 1
			return FSERROR;
d897 1
a897 1
			return FSFATAL;
d914 1
a914 1
			return FSERROR;
d921 1
a921 1
			return FSFATAL;
d927 1
a927 1
		return FSERROR;
d931 1
a931 1
	memset(&d, 0, sizeof d);
d937 3
a939 3
	memset(p, 0, 32);
	memset(p, ' ', 11);
	memcpy(p, d.name, strlen(d.name));
d950 1
a950 1
		return FSFATAL;
d952 1
a952 1
	return FSDIRMOD;
@


1.5
log
@"prs are sometimes wrong" (theo)
fix wrong fix. "kak v zadnitsu kol, russkiy rock-n-roll" (4epHeuKuu)
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.4 1996/09/17 19:31:18 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.4 1996/09/17 19:31:18 deraadt Exp $";
d170 1
a170 1
	} while (dir = dir->parent);
d241 1
a241 1
		if (nd = d->child) {
d501 1
a501 1
					   || lidx != *p & LRNOMASK) {
@


1.4
log
@realpath fix, do not dump; pr#2765, david@@mono.org
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.3 1996/06/23 14:30:42 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.3 1996/06/23 14:30:42 deraadt Exp $";
d171 1
a171 1
	if (dir)
@


1.3
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: dir.c,v 1.1.4.1 1996/05/31 18:41:38 jtc Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: dir.c,v 1.1.4.1 1996/05/31 18:41:38 jtc Exp $";
d171 1
a171 1
	if (dir->parent)
@


1.2
log
@from ws;
Check return values of malloc
Generate full pathnames only on request
Minor cleanup, RCS Ids in .h files
Don't allocate data structures for non-directories
Free any data structures when finishing a check (at the latest)
@
text
@d1 1
d40 1
a40 1
static char rcsid[] = "$NetBSD: dir.c,v 1.1.4.1 1996/05/31 18:41:38 jtc Exp $";
@


1.1
log
@add fsck_msdos
@
text
@d1 1
a1 1
/*	$NetBSD: dir.c,v 1.1 1996/05/14 17:39:30 ws Exp $	*/
d39 1
a39 1
static char rcsid[] = "$NetBSD: dir.c,v 1.1 1996/05/14 17:39:30 ws Exp $";
d50 2
d93 83
d200 3
d216 2
a217 1
	    || !(delbuf = malloc(b2))) {
d221 1
d231 18
d306 1
a306 1
removede(f, boot, fat, start, end, startcl, endcl, curcl, path, eof)
d316 1
a316 1
	int eof;
d318 2
a319 1
	if (!eof)
d321 2
a322 1
	else
d324 5
d359 1
a359 1
	u_int32_t physicalSize;
d361 7
a367 3
	if (dir->head < CLUST_FIRST || dir->head >= boot->NumClusters)
		return FSERROR;
	physicalSize = fat[dir->head].length * boot->ClusterSize;
d370 1
a370 1
		      dir->fullpath, dir->size, physicalSize);
d382 1
a382 1
		      dir->fullpath);
a398 5
 * The stack of unread directories
 */
struct dirTodoNode *pendingDirectories = NULL;

/*
d404 1
a404 1
int
d423 1
a423 1
	if (dir->fullpath[1] && (cl < CLUST_FIRST || cl >= boot->NumClusters)) {
d432 1
a432 1
		if (!dir->fullpath[1]) {
d468 1
a468 1
					      dir->fullpath);
d582 14
a595 4
			/*
			 * What about volume names with extensions?	XXX
			 */
			if ((dirent.flags & ATTR_VOLUME) == 0 && p[8] != ' ')
d617 1
a617 9
			
			k = strlen(dirent.lname[0] ? dirent.lname : dirent.name);
			k += strlen(dir->fullpath) + 2;
			dirent.fullpath = malloc(k);
			strcpy(dirent.fullpath, dir->fullpath);
			if (dir->fullpath[1])
				strcat(dirent.fullpath, "/");
			strcat(dirent.fullpath,
			       dirent.lname[0] ? dirent.lname : dirent.name);
d622 1
a622 1
						    dirent.fullpath, 0);
d637 1
a637 1
					      dirent.fullpath);
d648 2
a649 1
				   && !strcmp(dir->parent->fullpath, "/")) {
d661 1
a661 1
					      dirent.fullpath);
d665 1
a665 1
					      dirent.fullpath,
d669 1
a669 1
					      dirent.fullpath);
d672 1
a672 1
					      dirent.fullpath,
d676 1
a676 1
					      dirent.fullpath);
d694 4
a697 9
			/* create directory tree node */
			d = malloc(sizeof(struct dosDirEntry));
			memcpy(d, &dirent, sizeof(struct dosDirEntry));
			/* link it into the directory tree */
			d->parent = dir;
			d->next = dir->child;
			dir->child = d;
			if (d->head >= CLUST_FIRST && d->head < boot->NumClusters)
				fat[d->head].dirp = d;
d699 1
a699 1
			if (d->flags & ATTR_DIRECTORY) {
d705 1
a705 1
				if (d->size) {
d707 1
a707 1
					      d->fullpath);
d710 1
a710 1
						d->size = 0;
d718 2
a719 2
				if (strcmp(d->name, ".") == 0) {
					if (d->head != dir->head) {
d721 1
a721 1
						      dir->fullpath);
d723 3
a725 3
							d->head = dir->head;
							p[26] = (u_char)d->head;
							p[27] = (u_char)(d->head >> 8);
d732 3
a734 2
				if (strcmp(d->name, "..") == 0) {
					if (d->head != dir->parent->head) {
d736 1
a736 1
						      dir->fullpath);
d738 3
a740 3
							d->head = dir->parent->head;
							p[26] = (u_char)d->head;
							p[27] = (u_char)(d->head >> 8);
d749 11
d761 4
a764 1
				n = malloc(sizeof(struct dirTodoNode));
d769 1
a769 1
				mod |= k = checksize(boot, fat, p, d);
d789 1
a789 1
				dir->fullpath, 1);
d793 50
d851 1
a851 1
reconnect(dosfs, boot, fat, head, dir)
a855 1
	struct dosDirEntry *dir;
d860 10
a869 2
	if (!dir)		/* Create lfdir?			XXX */
		return FSERROR;
d887 1
a887 1
		lfcl = p ? fat[lfcl].next : dir->head;
d889 1
a889 1
			/* Extend lfdir?				XXX */
a909 2
	d.fullpath = malloc(strlen(dir->fullpath) + strlen(d.name) + 2);
	sprintf(d.fullpath, "%s/%s", dir->fullpath, d.name);
a912 4
	d.parent = dir;
	d.next = dir->child;
	dir->child = malloc(sizeof(struct dosDirEntry));
	memcpy(dir->child, &d, sizeof(struct dosDirEntry));
d916 8
a923 8
	memcpy(p, dir->name, strlen(dir->name));
	p[26] = (u_char)dir->head;
	p[27] = (u_char)(dir->head >> 8);
	p[28] = (u_char)dir->size;
	p[29] = (u_char)(dir->size >> 8);
	p[30] = (u_char)(dir->size >> 16);
	p[31] = (u_char)(dir->size >> 24);
	fat[head].dirp = dir;
@
