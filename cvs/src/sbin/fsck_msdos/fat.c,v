head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.6
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.8
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.18.0.20
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.6
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.27
date	2015.12.10.17.26.59;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	82PdNqu2kKAuXPfA;

1.26
date	2015.09.27.16.56.06;	author guenther;	state Exp;
branches;
next	1.25;
commitid	kZKltxcWbyZaEgB3;

1.25
date	2014.07.10.20.11.12;	author tobias;	state Exp;
branches;
next	1.24;
commitid	rSRtzxcxw1PgWzbH;

1.24
date	2014.06.18.17.29.07;	author tobias;	state Exp;
branches;
next	1.23;
commitid	tNIHI7fdHdn0PBfG;

1.23
date	2014.06.16.18.33.33;	author tobias;	state Exp;
branches;
next	1.22;
commitid	PhPZAfTlrgjKIup9;

1.22
date	2014.06.14.19.32.25;	author tobias;	state Exp;
branches;
next	1.21;
commitid	x2YHMM7YTuzR1TCr;

1.21
date	2014.06.14.12.33.07;	author tobias;	state Exp;
branches;
next	1.20;
commitid	IOkpkiqK4KqQwikc;

1.20
date	2014.06.10.23.03.48;	author tobias;	state Exp;
branches;
next	1.19;
commitid	p2v7jqgu19i2BXB3;

1.19
date	2014.06.09.09.13.33;	author tobias;	state Exp;
branches;
next	1.18;
commitid	uTE5u3WD89HLC0fH;

1.18
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.02.15.19.23;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.11.11.34.32;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.27.22.30.09;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.02.21.38.56;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.20.20.11.02;	author dhill;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.28.17.42.06;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.09.06.12.39.58;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	98.01.11.20.40.33;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.09.11.08.15.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.03.02.05.25.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.28.08.36.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.14.30.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.04.38.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.23.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: fat.c,v 1.26 2015/09/27 16:56:06 guenther Exp $	*/
/*	$NetBSD: fat.c,v 1.8 1997/10/17 11:19:53 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997 Wolfgang Solfrank
 * Copyright (c) 1995 Martin Husemann
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <unistd.h>

#include "ext.h"

static int checkclnum(struct bootblock *, int, cl_t, cl_t *);
static int clustdiffer(cl_t, cl_t *, cl_t *, int);
static int tryclear(struct bootblock *, struct fatEntry *, cl_t, cl_t *);

/*
 * Check a cluster number for valid value
 */
static int
checkclnum(struct bootblock *boot, int fat, cl_t cl, cl_t *next)
{
	if (*next >= (CLUST_RSRVD&boot->ClustMask))
		*next |= ~boot->ClustMask;
	if (*next == CLUST_FREE) {
		boot->NumFree++;
		return (FSOK);
	}
	if (*next == CLUST_BAD) {
		boot->NumBad++;
		return (FSOK);
	}
	if (*next < CLUST_FIRST
	    || (*next >= boot->NumClusters && *next < CLUST_EOFS)) {
		pwarn("Cluster %u in FAT %d continues with %s cluster number %u\n",
		      cl, fat,
		      *next < CLUST_RSRVD ? "out of range" : "reserved",
		      *next&boot->ClustMask);
		if (ask(0, "Truncate")) {
			*next = CLUST_EOF;
			return (FSFATMOD);
		}
		return (FSERROR);
	}
	return (FSOK);
}

/*
 * Read a FAT and decode it into internal format
 */
int
readfat(int fs, struct bootblock *boot, int no, struct fatEntry **fp)
{
	struct fatEntry *fat;
	u_char *buffer, *p;
	cl_t cl;
	off_t off;
	int ret = FSOK;

	boot->NumFree = boot->NumBad = 0;
	fat = calloc(boot->NumClusters, sizeof(struct fatEntry));
	buffer = calloc(boot->FATsecs, boot->BytesPerSec);
	if (fat == NULL || buffer == NULL) {
		xperror("No space for FAT");
		free(fat);
		free(buffer);
		return (FSFATAL);
	}

	off = boot->ResSectors + no * boot->FATsecs;
	off *= boot->BytesPerSec;

	if (lseek(fs, off, SEEK_SET) != off) {
		xperror("Unable to read FAT");
		free(buffer);
		free(fat);
		return (FSFATAL);
	}

	if (read(fs, buffer, boot->FATsecs * boot->BytesPerSec)
	    != boot->FATsecs * boot->BytesPerSec) {
		xperror("Unable to read FAT");
		free(buffer);
		free(fat);
		return (FSFATAL);
	}

	if (buffer[0] != boot->Media
	    || buffer[1] != 0xff || buffer[2] != 0xff
	    || (boot->ClustMask == CLUST16_MASK && buffer[3] != 0xff)
	    || (boot->ClustMask == CLUST32_MASK
		&& ((buffer[3]&0x0f) != 0x0f
		    || buffer[4] != 0xff || buffer[5] != 0xff
		    || buffer[6] != 0xff || (buffer[7]&0x0f) != 0x0f))) {
		static const char msg[] = "FAT starts with odd byte sequence ";

		switch (boot->ClustMask) {
		case CLUST32_MASK:
			pwarn("%s(%02x%02x%02x%02x%02x%02x%02x%02x)\n", msg,
			    buffer[0], buffer[1], buffer[2], buffer[3],
			    buffer[4], buffer[5], buffer[6], buffer[7]);
			break;
		case CLUST16_MASK:
			pwarn("%s(%02x%02x%02x%02x)\n", msg,
			    buffer[0], buffer[1], buffer[2], buffer[3]);
			break;
		default:
			pwarn("%s(%02x%02x%02x)\n", msg,
			    buffer[0], buffer[1], buffer[2]);
			break;
		}
		if (ask(1, "Correct"))
			ret |= FSFATMOD;
	}
	switch (boot->ClustMask) {
	case CLUST32_MASK:
		p = buffer + 8;
		break;
	case CLUST16_MASK:
		p = buffer + 4;
		break;
	default:
		p = buffer + 3;
		break;
	}
	for (cl = CLUST_FIRST; cl < boot->NumClusters;) {
		switch (boot->ClustMask) {
		case CLUST32_MASK:
			fat[cl].next = p[0] + (p[1] << 8)
				       + (p[2] << 16) + (p[3] << 24);
			fat[cl].next &= boot->ClustMask;
			ret |= checkclnum(boot, no, cl, &fat[cl].next);
			cl++;
			p += 4;
			break;
		case CLUST16_MASK:
			fat[cl].next = p[0] + (p[1] << 8);
			ret |= checkclnum(boot, no, cl, &fat[cl].next);
			cl++;
			p += 2;
			break;
		default:
			fat[cl].next = (p[0] + (p[1] << 8)) & 0x0fff;
			ret |= checkclnum(boot, no, cl, &fat[cl].next);
			cl++;
			if (cl >= boot->NumClusters)
				break;
			fat[cl].next = ((p[1] >> 4) + (p[2] << 4)) & 0x0fff;
			ret |= checkclnum(boot, no, cl, &fat[cl].next);
			cl++;
			p += 3;
			break;
		}
	}

	free(buffer);
	if (ret & FSFATAL) {
		free(fat);
		*fp = NULL;
	} else
		*fp = fat;	
	return (ret);
}

/*
 * Get type of reserved cluster
 */
char *
rsrvdcltype(cl_t cl)
{
	if (cl == CLUST_FREE)
		return ("free");
	if (cl < CLUST_BAD)
		return ("reserved");
	if (cl > CLUST_BAD)
		return ("as EOF");
	return ("bad");
}

static int
clustdiffer(cl_t cl, cl_t *cp1, cl_t *cp2, int fatnum)
{
	if (*cp1 == CLUST_FREE || *cp1 >= CLUST_RSRVD) {
		if (*cp2 == CLUST_FREE || *cp2 >= CLUST_RSRVD) {
			if ((*cp1 != CLUST_FREE && *cp1 < CLUST_BAD
			     && *cp2 != CLUST_FREE && *cp2 < CLUST_BAD)
			    || (*cp1 > CLUST_BAD && *cp2 > CLUST_BAD)) {
				pwarn("Cluster %u is marked %s with different indicators, ",
				      cl, rsrvdcltype(*cp1));
				if (ask(1, "fix")) {
					*cp2 = *cp1;
					return (FSFATMOD);
				}
				return (FSFATAL);
			}
			pwarn("Cluster %u is marked %s in FAT 0, %s in FAT %d\n",
			      cl, rsrvdcltype(*cp1), rsrvdcltype(*cp2), fatnum);
			if (ask(0, "use FAT 0's entry")) {
				*cp2 = *cp1;
				return (FSFATMOD);
			}
			if (ask(0, "use FAT %d's entry", fatnum)) {
				*cp1 = *cp2;
				return (FSFATMOD);
			}
			return (FSFATAL);
		}
		pwarn("Cluster %u is marked %s in FAT 0, but continues with cluster %u in FAT %d\n",
		      cl, rsrvdcltype(*cp1), *cp2, fatnum);
		if (ask(0, "Use continuation from FAT %d", fatnum)) {
			*cp1 = *cp2;
			return (FSFATMOD);
		}
		if (ask(0, "Use mark from FAT 0")) {
			*cp2 = *cp1;
			return (FSFATMOD);
		}
		return (FSFATAL);
	}
	if (*cp2 == CLUST_FREE || *cp2 >= CLUST_RSRVD) {
		pwarn("Cluster %u continues with cluster %u in FAT 0, but is marked %s in FAT %d\n",
		      cl, *cp1, rsrvdcltype(*cp2), fatnum);
		if (ask(0, "Use continuation from FAT 0")) {
			*cp2 = *cp1;
			return (FSFATMOD);
		}
		if (ask(0, "Use mark from FAT %d", fatnum)) {
			*cp1 = *cp2;
			return (FSFATMOD);
		}
		return (FSERROR);
	}
	pwarn("Cluster %u continues with cluster %u in FAT 0, but with cluster %u in FAT %d\n",
	      cl, *cp1, *cp2, fatnum);
	if (ask(0, "Use continuation from FAT 0")) {
		*cp2 = *cp1;
		return (FSFATMOD);
	}
	if (ask(0, "Use continuation from FAT %d", fatnum)) {
		*cp1 = *cp2;
		return (FSFATMOD);
	}
	return (FSERROR);
}

/*
 * Compare two FAT copies in memory. Resolve any conflicts and merge them
 * into the first one.
 */
int
comparefat(struct bootblock *boot, struct fatEntry *first,
	   struct fatEntry *second, int fatnum)
{
	cl_t cl;
	int ret = FSOK;

	for (cl = CLUST_FIRST; cl < boot->NumClusters; cl++)
		if (first[cl].next != second[cl].next)
			ret |= clustdiffer(cl, &first[cl].next, &second[cl].next, fatnum);
	return (ret);
}

void
clearchain(struct bootblock *boot, struct fatEntry *fat, cl_t head)
{
	cl_t p, q;

	for (p = head; p >= CLUST_FIRST && p < boot->NumClusters; p = q) {
		if (fat[p].head != head)
			break;
		q = fat[p].next;
		fat[p].next = fat[p].head = CLUST_FREE;
		fat[p].length = 0;
	}
}

int
tryclear(struct bootblock *boot, struct fatEntry *fat, cl_t head, cl_t *trunc)
{
	u_int len;
	cl_t p;

	if (ask(0, "Clear chain starting at %u", head)) {
		clearchain(boot, fat, head);
		return FSFATMOD;
	} else if (ask(0, "Truncate")) {
		*trunc = CLUST_EOF;
		len = 0;
		for (p = head; p >= CLUST_FIRST && p < boot->NumClusters;
		    p = fat[p].next) {
			len++;
		}
		fat[head].length = len;
		return FSFATMOD;
	} else
		return FSERROR;
}

/*
 * Check a complete FAT in-memory for crosslinks
 */
int
checkfat(struct bootblock *boot, struct fatEntry *fat)
{
	cl_t head, p, h, n;
	u_int len;
	int ret = 0;
	int conf;

	/*
	 * pass 1: figure out the cluster chains.
	 */
	for (head = CLUST_FIRST; head < boot->NumClusters; head++) {
		/* find next untravelled chain */
		if (fat[head].head != 0		/* cluster already belongs to some chain */
		    || fat[head].next == CLUST_FREE
		    || fat[head].next == CLUST_BAD)
			continue;		/* skip it. */

		/* follow the chain and mark all clusters on the way */
		for (len = 0, p = head;
		     p >= CLUST_FIRST && p < boot->NumClusters &&
		     fat[p].head != head;
		     p = fat[p].next) {
			fat[p].head = head;
			len++;
		}

		/* the head record gets the length */
		fat[head].length = fat[head].next == CLUST_FREE ? 0 : len;
	}

	/*
	 * pass 2: check for crosslinked chains (we couldn't do this in pass 1 because
	 * we didn't know the real start of the chain then - would have treated partial
	 * chains as interlinked with their main chain)
	 */
	for (head = CLUST_FIRST; head < boot->NumClusters; head++) {
		/* find next untravelled chain */
		if (fat[head].head != head)
			continue;

		/* follow the chain to its end (hopefully) */
		for (len = fat[head].length, p = head;
		     (n = fat[p].next) >= CLUST_FIRST && n < boot->NumClusters;
		     p = n) {
			/* len is always off by one due to n assignment */
			if (fat[n].head != head || len-- < 2)
				break;
		}
		if (n >= CLUST_EOFS)
			continue;

		if (n == CLUST_FREE || n >= CLUST_RSRVD) {
			pwarn("Cluster chain starting at %u ends with cluster marked %s\n",
			      head, rsrvdcltype(n));
			ret |= tryclear(boot, fat, head, &fat[p].next);
			continue;
		}
		if (n < CLUST_FIRST || n >= boot->NumClusters) {
			pwarn("Cluster chain starting at %u ends with cluster out of range (%u)\n",
			      head, n);
			ret |= tryclear(boot, fat, head, &fat[p].next);
			continue;
		}
		if (head == fat[n].head) {
			pwarn("Cluster chain starting at %u loops at cluster %u\n",
			      head, p);
			ret |= tryclear(boot, fat, head, &fat[p].next);
			continue;
		}
		pwarn("Cluster chains starting at %u and %u are linked at cluster %u\n",
		      head, fat[n].head, n);
		conf = tryclear(boot, fat, head, &fat[p].next);
		if (ask(0, "Clear chain starting at %u", h = fat[n].head)) {
			if (conf == FSERROR) {
				/*
				 * Transfer the common chain to the one not cleared above.
				 */
				for (p = n;
				     p >= CLUST_FIRST && p < boot->NumClusters;
				     p = fat[p].next) {
					if (h != fat[p].head) {
						/*
						 * Have to reexamine this chain.
						 */
						head--;
						break;
					}
					fat[p].head = head;
				}
			}
			clearchain(boot, fat, h);
			conf |= FSFATMOD;
		}
		ret |= conf;
	}

	return (ret);
}

/*
 * Write out FATs encoding them from the internal format
 */
int
writefat(int fs, struct bootblock *boot, struct fatEntry *fat)
{
	u_char *buffer, *p;
	cl_t cl;
	int i;
	u_int32_t fatsz;
	off_t off;
	int ret = FSOK;

	fatsz = boot->FATsecs * boot->BytesPerSec;
	buffer = calloc(boot->FATsecs, boot->BytesPerSec);
	if (buffer == NULL) {
		xperror("No space for FAT");
		return (FSFATAL);
	}
	(void)memset(buffer, 0, fatsz);
	boot->NumFree = 0;
	p = buffer;
	*p++ = (u_char)boot->Media;
	*p++ = 0xff;
	*p++ = 0xff;
	switch (boot->ClustMask) {
	case CLUST16_MASK:
		*p++ = 0xff;
		break;
	case CLUST32_MASK:
		*p++ = 0x0f;
		*p++ = 0xff;
		*p++ = 0xff;
		*p++ = 0xff;
		*p++ = 0x0f;
		break;
	}
	for (cl = CLUST_FIRST; cl < boot->NumClusters; cl++) {
		switch (boot->ClustMask) {
		case CLUST32_MASK:
			if (fat[cl].next == CLUST_FREE)
				boot->NumFree++;
			*p++ = (u_char)fat[cl].next;
			*p++ = (u_char)(fat[cl].next >> 8);
			*p++ = (u_char)(fat[cl].next >> 16);
			*p &= 0xf0;
			*p++ |= (fat[cl].next >> 24)&0x0f;
			break;
		case CLUST16_MASK:
			if (fat[cl].next == CLUST_FREE)
				boot->NumFree++;
			*p++ = (u_char)fat[cl].next;
			*p++ = (u_char)(fat[cl].next >> 8);
			break;
		default:
			if (fat[cl].next == CLUST_FREE)
				boot->NumFree++;
			*p++ = (u_char)fat[cl].next;
			*p = (u_char)((fat[cl].next >> 8) & 0xf);
			cl++;
			if (cl >= boot->NumClusters)
				break;
			if (fat[cl].next == CLUST_FREE)
				boot->NumFree++;
			*p++ |= (u_char)(fat[cl].next << 4);
			*p++ = (u_char)(fat[cl].next >> 4);
			break;
		}
	}
	for (i = 0; i < boot->FATs; i++) {
		off = boot->ResSectors + i * boot->FATsecs;
		off *= boot->BytesPerSec;
		if (lseek(fs, off, SEEK_SET) != off
		    || write(fs, buffer, fatsz) != fatsz) {
			xperror("Unable to write FAT");
			ret = FSFATAL; /* Return immediately?		XXX */
		}
	}
	free(buffer);
	return (ret);
}

/*
 * Check a complete in-memory FAT for lost cluster chains
 */
int
checklost(int dosfs, struct bootblock *boot, struct fatEntry *fat)
{
	cl_t head;
	int mod = FSOK;
	int ret;

	for (head = CLUST_FIRST; head < boot->NumClusters; head++) {
		/* find next untravelled chain */
		if (fat[head].head != head
		    || fat[head].next == CLUST_FREE
		    || (fat[head].next >= CLUST_RSRVD
			&& fat[head].next < CLUST_EOFS)
		    || (fat[head].flags & FAT_USED))
			continue;

		pwarn("Lost cluster chain at cluster %u\n%d Cluster(s) lost\n",
		      head, fat[head].length);
		mod |= ret = reconnect(dosfs, boot, fat, head);
		if (mod & FSFATAL)
			break;
		if (ret == FSERROR && ask(0, "Clear")) {
			clearchain(boot, fat, head);
			mod |= FSFATMOD;
		}
	}
	finishlf();

	if (boot->FSInfo) {
		ret = 0;
		if (boot->FSFree != 0xffffffff &&
		    boot->FSFree != boot->NumFree) {
			pwarn("Free space in FSInfo block (%u) not correct (%u)\n",
			      boot->FSFree, boot->NumFree);
			if (ask(1, "fix")) {
				boot->FSFree = boot->NumFree;
				ret = 1;
			}
		}
		if (boot->FSNext != 0xffffffff &&
		    boot->NumFree && (boot->FSNext >= boot->NumClusters ||
		    fat[boot->FSNext].next != CLUST_FREE)) {
			pwarn("Next free cluster in FSInfo block (%u) not free\n",
			      boot->FSNext);
			if (ask(1, "fix"))
				for (head = CLUST_FIRST; head < boot->NumClusters; head++)
					if (fat[head].next == CLUST_FREE) {
						boot->FSNext = head;
						ret = 1;
						break;
					}
		}
		if (ret)
			mod |= writefsinfo(dosfs, boot);
	}

	return (mod);
}
@


1.26
log
@Mark ask() as printf-like; split up a pwarn() with variable number of specifiers

ok beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.25 2014/07/10 20:11:12 tobias Exp $	*/
d89 2
a90 4
		if (fat != NULL)
			free(fat);
		if (buffer != NULL)
			free(buffer);
@


1.25
log
@Uninitialized values (-1) in FSInfo are perfectly valid.

Merged from NetBSD revision 1.24.

ok krw@@ (who came up with the same diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.24 2014/06/18 17:29:07 tobias Exp $	*/
d121 1
a121 1
		char *msg;
d125 3
a127 1
			msg = "FAT starts with odd byte sequence (%02x%02x%02x%02x%02x%02x%02x%02x)\n";
d130 2
a131 1
			msg = "FAT starts with odd byte sequence (%02x%02x%02x%02x)\n";
d134 2
a135 1
			msg = "FAT starts with odd byte sequence (%02x%02x%02x)\n";
a137 3
		pwarn(msg,
		      buffer[0], buffer[1], buffer[2], buffer[3],
		      buffer[4], buffer[5], buffer[6], buffer[7]);
@


1.24
log
@Always keep length of cluster chain up to date, otherwise the drop of
superfluous clusters can lead to out of boundary access.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.23 2014/06/16 18:33:33 tobias Exp $	*/
d542 3
a544 2
		if (boot->FSFree != boot->NumFree) {
			pwarn("Free space in FSInfo block (%d) not correct (%d)\n",
d551 2
a552 1
		if (boot->NumFree && (boot->FSNext >= boot->NumClusters ||
@


1.23
log
@Merge NetBSD commit:
Move to 2 clause license, approved by Wolfgang Solfrank.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.22 2014/06/14 19:32:25 tobias Exp $	*/
d305 3
d313 6
@


1.22
log
@Avoid infinite loop if cluster chain is a cyclic list.

Inspired by Android's commit b6ee08aadb580341a4d80943741b80de16a88b5d,
but fixing the actually offending cluster, not a random one.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.21 2014/06/14 12:33:07 tobias Exp $	*/
a15 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Martin Husemann
 *	and Wolfgang Solfrank.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.21
log
@Fix regression of 1.20 by properly incrementing pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.20 2014/06/10 23:03:48 tobias Exp $	*/
d367 1
a367 1
		for (p = head;
d369 3
a371 2
		     p = n)
			if (fat[n].head != head)
d373 1
d386 6
@


1.20
log
@Fix off by one when writing FAT for FAT12 filesystems.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.19 2014/06/09 09:13:33 tobias Exp $	*/
d475 1
a475 1
			*p++ = (u_char)((fat[cl].next >> 8) & 0xf);
d481 1
a481 1
			*p |= (u_char)(fat[cl].next << 4);
@


1.19
log
@Fix possible out of boundary access if filesystem is full or corrupt.

Merged from Android (commit id 59ae828834dc177c74775cf36cafda4da9927bd9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.18 2009/10/27 23:59:33 deraadt Exp $	*/
d474 6
a479 2
			if (cl + 1 < boot->NumClusters
			    && fat[cl + 1].next == CLUST_FREE)
d481 2
a482 4
			*p++ = (u_char)fat[cl].next;
			*p++ = (u_char)((fat[cl].next >> 8) & 0xf)
			       |(u_char)(fat[cl+1].next << 4);
			*p++ = (u_char)(fat[++cl].next >> 4);
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.17 2007/09/02 15:19:23 deraadt Exp $	*/
d538 2
a539 1
		if (boot->NumFree && fat[boot->FSNext].next != CLUST_FREE) {
@


1.17
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.16 2006/11/11 11:34:32 pedro Exp $	*/
a34 5


#ifndef lint
static char rcsid[] = "$OpenBSD: fat.c,v 1.16 2006/11/11 11:34:32 pedro Exp $";
#endif /* not lint */
@


1.16
log
@Fix memory leak, from Charles Longeau, many okays
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.15 2006/05/27 22:30:09 thib Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.15 2006/05/27 22:30:09 thib Exp $";
d98 1
a98 1
	buffer = malloc(boot->FATsecs * boot->BytesPerSec);
d435 2
a436 1
	buffer = malloc(fatsz = boot->FATsecs * boot->BytesPerSec);
@


1.15
log
@newline fix + s/perror/xperror since we are
using a home rolled version.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.14 2006/04/02 21:38:56 djm Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.14 2006/04/02 21:38:56 djm Exp $";
d101 1
a101 1
		if (fat)
d103 2
@


1.14
log
@malloc(x * y) -> calloc(x, y) from adobriyan AT gmail.com, with tweaks
suggested by kjell@@; ok otto@@ pat@@ millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.13 2006/03/20 20:11:02 dhill Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.13 2006/03/20 20:11:02 dhill Exp $";
d100 1
a100 1
		perror("No space for FAT");
d110 1
a110 1
		perror("Unable to read FAT");
d118 1
a118 1
		perror("Unable to read FAT");
d435 1
a435 1
		perror("No space for FAT");
d491 1
a491 1
			perror("Unable to write FAT");
@


1.13
log
@NetBSD Coverity CID 2302: Free fat if fatal error to avoid leak.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.12 2004/07/17 02:14:33 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.12 2004/07/17 02:14:33 deraadt Exp $";
d97 1
a97 1
	fat = malloc(sizeof(struct fatEntry) * boot->NumClusters);
a104 2

	(void)memset(fat, 0, sizeof(struct fatEntry) * boot->NumClusters);
@


1.12
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.11 2003/07/29 18:38:35 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.11 2003/07/29 18:38:35 deraadt Exp $";
d194 5
a198 1
	*fp = fat;
@


1.11
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.10 2002/02/16 21:27:34 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.10 2002/02/16 21:27:34 millert Exp $";
d57 1
a57 5
checkclnum(boot, fat, cl, next)
	struct bootblock *boot;
	int fat;
	cl_t cl;
	cl_t *next;
d88 1
a88 5
readfat(fs, boot, no, fp)
	int fs;
	struct bootblock *boot;
	int no;
	struct fatEntry **fp;
d202 1
a202 2
rsrvdcltype(cl)
	cl_t cl;
d214 1
a214 5
clustdiffer(cl, cp1, cp2, fatnum)
	cl_t cl;
	cl_t *cp1;
	cl_t *cp2;
	int fatnum;
d284 2
a285 5
comparefat(boot, first, second, fatnum)
	struct bootblock *boot;
	struct fatEntry *first;
	struct fatEntry *second;
	int fatnum;
d297 1
a297 4
clearchain(boot, fat, head)
	struct bootblock *boot;
	struct fatEntry *fat;
	cl_t head;
d311 1
a311 5
tryclear(boot, fat, head, trunc)
	struct bootblock *boot;
	struct fatEntry *fat;
	cl_t head;
	cl_t *trunc;
d327 1
a327 3
checkfat(boot, fat)
	struct bootblock *boot;
	struct fatEntry *fat;
d422 1
a422 4
writefat(fs, boot, fat)
	int fs;
	struct bootblock *boot;
	struct fatEntry *fat;
d501 1
a501 4
checklost(dosfs, boot, fat)
	int dosfs;
	struct bootblock *boot;
	struct fatEntry *fat;
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.9 2000/06/28 17:42:06 mickey Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.9 2000/06/28 17:42:06 mickey Exp $";
d113 1
a113 1
	
d537 1
a537 1
	
@


1.9
log
@prevent endless looping on looping fat chains
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.8 1999/09/06 12:39:58 espie Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.8 1999/09/06 12:39:58 espie Exp $";
d49 3
a51 3
static int checkclnum __P((struct bootblock *, int, cl_t, cl_t *));
static int clustdiffer __P((cl_t, cl_t *, cl_t *, int));
static int tryclear __P((struct bootblock *, struct fatEntry *, cl_t, cl_t *));
@


1.8
log
@Leech newer fat checking code from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.7 1998/01/11 20:40:33 provos Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.7 1998/01/11 20:40:33 provos Exp $";
d371 2
a372 1
		     p >= CLUST_FIRST && p < boot->NumClusters;
@


1.7
log
@FAT32 support from NetBSD by Wolfgang Solfrank.
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.6 1997/09/11 08:15:26 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.6 1997/09/11 08:15:26 deraadt Exp $";
d51 1
d213 2
d229 4
a232 3
	if (*cp1 >= CLUST_RSRVD) {
		if (*cp2 >= CLUST_RSRVD) {
			if ((*cp1 < CLUST_BAD && *cp2 < CLUST_BAD)
d266 2
a267 2
	if (*cp2 >= CLUST_RSRVD) {
		pwarn("Cluster %u continues with cluster %u in FAT 1, but is marked %s in FAT %d\n",
d329 17
d354 1
a354 1
	cl_t head, p, h;
d393 3
a395 3
		     fat[p].next >= CLUST_FIRST && fat[p].next < boot->NumClusters;
		     p = fat[p].next)
			if (fat[fat[p].next].head != head)
d397 1
a397 1
		if (fat[p].next >= CLUST_EOFS)
d400 1
a400 10
		if (fat[p].next == 0) {
			pwarn("Cluster chain starting at %u ends with free cluster\n", head);
			if (ask(0, "Clear chain starting at %u", head)) {
				clearchain(boot, fat, head);
				ret |= FSFATMOD;
			} else
				ret |= FSERROR;
			continue;
		}
		if (fat[p].next >= CLUST_RSRVD) {
d402 2
a403 6
			      head, rsrvdcltype(fat[p].next));
			if (ask(0, "Clear chain starting at %u", head)) {
				clearchain(boot, fat, head);
				ret |= FSFATMOD;
			} else
				ret |= FSERROR;
d406 1
a406 1
		if (fat[p].next < CLUST_FIRST || fat[p].next >= boot->NumClusters) {
d408 3
a410 6
			      head, fat[p].next);
			if (ask(0, "Clear chain starting at %u", head)) {
				clearchain(boot, fat, head);
				ret |= FSFATMOD;
			} else
				ret |= FSERROR;
d413 3
a415 7
		      head, fat[p].head, p);
		conf = FSERROR;
		if (ask(0, "Clear chain starting at %u", head)) {
			clearchain(boot, fat, head);
			conf = FSFATMOD;
		}
		if (ask(0, "Clear chain starting at %u", h = fat[p].head)) {
d420 2
a421 1
				for (; p >= CLUST_FIRST && p < boot->NumClusters;
@


1.6
log
@from ws@@netbsd; Fix a few bugs, especially when repairing disks:
Print correct pathname in error messages
Fix unterminating loop when trying to correct a bad fat
Require fat media byte to be the same as the one in the bpb
Fix unterminating loop when looking for free directory slot in LOST.DIR
(bad disk image provided by Christoph Badura)
@
text
@d1 2
a2 2
/*	$OpenBSD: fat.c,v 1.5 1997/03/02 05:25:55 millert Exp $	*/
/*	$NetBSD: fat.c,v 1.6 1997/09/08 14:05:31 ws Exp $	*/
d5 1
a5 1
 * Copyright (C) 1995, 1996 Wolfgang Solfrank
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.5 1997/03/02 05:25:55 millert Exp $";
d62 2
a63 2
	if (!boot->Is16BitFat && *next >= (CLUST_RSRVD&0xfff))
		*next |= 0xf000;
d74 1
a74 1
		pwarn("Cluster %d in FAT %d continues with %s cluster number %d\n",
d77 1
a77 1
		      *next);
a100 1
	int size;
d124 2
a125 2
	
	if ((size = read(fs, buffer, boot->FATsecs * boot->BytesPerSec))
d127 1
a127 4
		if (size < 0)
			perror("Unable to read FAT");
		else
			pfatal("Short FAT?");
a132 6
	/*
	 * Remember start of FAT to allow keeping it in write_fat.
	 */
	fat[0].length = buffer[0]|(buffer[1] << 8)|(buffer[2] << 16);
	if (boot->Is16BitFat)
		fat[0].length |= buffer[3] << 24;
d135 22
a156 7
	    || (boot->Is16BitFat && buffer[3] != 0xff)) {
		char *msg = boot->Is16BitFat
			? "FAT starts with odd byte sequence (%02x%02x%02x%02x)\n"
			: "FAT starts with odd byte sequence (%02x%02x%02x)\n";
		pwarn(msg, buffer[0], buffer[1], buffer[2], buffer[3]);
		if (ask(1, "Correct")) {
			fat[0].length = boot->Media|0xffffff;
a157 1
		}
d159 11
a169 1
	p = buffer + (boot->Is16BitFat ? 4 : 3);
d171 10
a180 1
		if (boot->Is16BitFat) {
d185 2
a186 1
		} else {
d196 1
d199 1
a199 1
	
d230 1
a230 1
				pwarn("Cluster %d is marked %s with different indicators, ",
d238 1
a238 1
			pwarn("Cluster %d is marked %s in FAT 1, %s in FAT %d\n",
d240 1
a240 1
			if (ask(0, "use FAT #1's entry")) {
d244 1
a244 1
			if (ask(0, "use FAT #%d's entry", fatnum)) {
d250 1
a250 1
		pwarn("Cluster %d is marked %s in FAT 1, but continues with cluster %d in FAT %d\n",
d256 1
a256 1
		if (ask(0, "Use mark from FAT 1")) {
d263 1
a263 1
		pwarn("Cluster %d continues with cluster %d in FAT 1, but is marked %s in FAT %d\n",
d265 1
a265 1
		if (ask(0, "Use continuation from FAT 1")) {
d275 1
a275 1
	pwarn("Cluster %d continues with cluster %d in FAT 1, but with cluster %d in FAT %d\n",
d277 1
a277 1
	if (ask(0, "Use continuation from FAT 1")) {
d337 1
a337 1
	
d342 1
a342 1
		/* find next untraveled chain */
d357 1
a357 1
		fat[head].length = len;
d359 1
a359 1
	
d366 1
a366 1
		/* find next untraveled chain */		
d378 1
a378 1
		
d380 2
a381 2
			pwarn("Cluster chain starting at %d ends with free cluster\n", head);
			if (ask(0, "Clear chain starting at %d", head)) {
d389 1
a389 1
			pwarn("Cluster chain starting at %d ends with cluster marked %s\n",
d391 1
a391 1
			if (ask(0, "Clear chain starting at %d", head)) {
d399 1
a399 1
			pwarn("Cluster chain starting at %d ends with cluster out of range (%d)\n",
d401 1
a401 1
			if (ask(0, "Clear chain starting at %d", head)) {
d407 1
a407 1
		pwarn("Cluster chains starting at %d and %d are linked at cluster %d\n",
d410 1
a410 1
		if (ask(0, "Clear chain starting at %d", head)) {
d414 1
a414 1
		if (ask(0, "Clear chain starting at %d", h = fat[p].head)) {
d455 1
a455 1
	
d464 15
a478 5
	*p++ = (u_char)fat[0].length;
	*p++ = (u_char)(fat[0].length >> 8);
	*p++ = (u_char)(fat[0].length >> 16);
	if (boot->Is16BitFat)
		*p++ = (u_char)(fat[0].length >> 24);
d480 2
a481 2
		if (boot->Is16BitFat) {
			p[0] = (u_char)fat[cl].next;
d484 13
a496 3
			p[1] = (u_char)(fat[cl].next >> 8);
			p += 2;
		} else {
d502 5
a506 5
			p[0] = (u_char)fat[cl].next;
			p[1] = (u_char)((fat[cl].next >> 8) & 0xf)
				|(u_char)(fat[cl+1].next << 4);
			p[2] = (u_char)(fat[++cl].next >> 4);
			p += 3;
d533 1
d536 1
a536 1
		/* find next untraveled chain */		
d544 1
a544 1
		pwarn("Lost cluster chain at cluster 0x%04x\n%d Cluster(s) lost\n", 
d546 1
a546 1
		mod |= reconnect(dosfs, boot, fat, head);
d549 4
d555 26
a580 1
	
@


1.5
log
@Update based on latest NetBSD version.
Now uses functions from util.[ch] instead of local ones.
Also some anal KNF from me...
@
text
@d1 2
a2 2
/*	$OpenBSD: fat.c,v 1.4 1997/02/28 08:36:12 millert Exp $	*/
/*	$NetBSD: fat.c,v 1.5 1997/01/03 14:32:49 ws Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.4 1997/02/28 08:36:12 millert Exp $";
d143 2
a144 1
	if (buffer[1] != 0xff || buffer[2] != 0xff
a276 12
	if (first[0].next != second[0].next) {
		pwarn("Media bytes in cluster 1(%02x) and %d(%02x) differ\n",
		      first[0].next, fatnum, second[0].next);
		if (ask(1, "Use media byte from FAT 1")) {
			second[0].next = first[0].next;
			ret |= FSFATMOD;
		} else if (ask(0, "Use media byte from FAT %d", fatnum)) {
			first[0].next = second[0].next;
			ret |= FSFATMOD;
		} else
			ret |= FSERROR;
	}
d318 1
a318 1
		if (fat[head].head != 0		/* cluster already belongs to some chain*/
d438 4
a441 2
	buffer[0] = (u_char)fat[0].length;
	buffer[1] = (u_char)(fat[0].length >> 8);
d443 2
a444 2
		buffer[3] = (u_char)(fat[0].length >> 24);
	for (cl = CLUST_FIRST, p = buffer; cl < boot->NumClusters;) {
d449 1
a449 1
			p[1] = (u_char)(fat[cl++].next >> 8);
d460 1
a460 1
			p[2] = (u_char)(fat[cl++].next >> 8);
@


1.4
log
@From NetBSD (ws)
Fix handling of clusters marked bad; Noted by Rafal Boni
@
text
@d1 1
a1 1
/*	$OpenBSD: fat.c,v 1.3 1996/06/23 14:30:43 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD$";
d66 1
a66 1
		return FSOK;
d70 1
a70 1
		return FSOK;
d80 1
a80 1
			return FSFATMOD;
d82 1
a82 1
		return FSERROR;
d84 1
a84 1
	return FSOK;
d111 1
a111 1
		return FSFATAL;
d114 1
a114 1
	memset(fat, 0, sizeof(struct fatEntry) * boot->NumClusters);
d123 1
a123 1
		return FSFATAL;
d134 1
a134 1
		return FSFATAL;
d176 1
a176 1
	return ret;
d187 1
a187 1
		return "reserved";
d189 2
a190 2
		return "as EOF";
	return "bad";
d208 1
a208 1
					return FSFATMOD;
d210 1
a210 1
				return FSFATAL;
d216 1
a216 1
				return FSFATMOD;
d220 1
a220 1
				return FSFATMOD;
d222 1
a222 1
			return FSFATAL;
d228 1
a228 1
			return FSFATMOD;
d232 1
a232 1
			return FSFATMOD;
d234 1
a234 1
		return FSFATAL;
d241 1
a241 1
			return FSFATMOD;
d245 1
a245 1
			return FSFATMOD;
d247 1
a247 1
		return FSERROR;
d253 1
a253 1
		return FSFATMOD;
d257 1
a257 1
		return FSFATMOD;
d259 1
a259 1
	return FSERROR;
d291 1
a291 1
	return ret;
d423 1
a423 1
	return ret;
d445 1
a445 1
		return FSFATAL;
d447 1
a447 1
	memset(buffer, 0, fatsz);
d483 1
a483 1
	return ret;
d515 1
a515 1
	return mod;
@


1.3
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: fat.c,v 1.1.4.1 1996/05/31 18:41:50 jtc Exp $	*/
/*	$NetBSD: fat.c,v 1.1.4.1 1996/05/31 18:41:50 jtc Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: fat.c,v 1.1.4.1 1996/05/31 18:41:50 jtc Exp $";
d49 3
d68 4
d104 1
a104 1
	boot->NumFree = 0;
d328 1
a328 1
		/* find next untraveled chain */		
d330 2
a331 1
		    || fat[head].next == CLUST_FREE)
@


1.2
log
@from ws;
Check return values of malloc
Generate full pathnames only on request
Minor cleanup, RCS Ids in .h files
Don't allocate data structures for non-directories
Free any data structures when finishing a check (at the latest)
@
text
@d1 1
d38 1
a38 1
static char rcsid[] = "$NetBSD: fat.c,v 1.1.4.1 1996/05/31 18:41:50 jtc Exp $";
@


1.1
log
@add fsck_msdos
@
text
@d1 1
a1 1
/*	$NetBSD: fat.c,v 1.1 1996/05/14 17:39:34 ws Exp $	*/
d37 1
a37 1
static char rcsid[] = "$NetBSD: fat.c,v 1.1 1996/05/14 17:39:34 ws Exp $";
d481 1
a481 1
checklost(dosfs, boot, fat, rootDir)
a484 1
	struct dosDirEntry *rootDir;
a486 1
	struct dosDirEntry *lfdir;
a488 4
	for (lfdir = rootDir->child; lfdir; lfdir = lfdir->next) {
		if (!strcmp(lfdir->name, LOSTDIR))
			break;
	}
d494 2
a495 1
			&& fat[head].next < CLUST_EOFS))
d498 5
a502 7
		if (fat[head].dirp == NULL) {
			pwarn("Lost cluster chain at cluster 0x%04x\n%d Cluster(s) lost\n", 
			      head, fat[head].length);
			mod |= reconnect(dosfs, boot, fat, head, lfdir);
			if (mod&FSFATAL)
				break;
		}
@
