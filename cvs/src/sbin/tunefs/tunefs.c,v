head	1.41;
access;
symbols
	OPENBSD_6_2:1.41.0.8
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.41.0.6
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.32.0.6
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.31.0.8
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.28.0.8
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.23.0.16
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.14
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.12
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.10
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.8
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.8.0.12
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.10
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.8
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2016.05.28.23.44.27;	author tb;	state Exp;
branches;
next	1.40;
commitid	uWfJN4l8cT8JnpOp;

1.40
date	2015.12.09.01.08.31;	author jsg;	state Exp;
branches;
next	1.39;
commitid	1Op92GveRos4bnDT;

1.39
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	Cz19p5I1S6mVZIjV;

1.38
date	2015.10.12.02.01.15;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	9MO63rOw1mWl5bCu;

1.37
date	2015.02.07.02.09.14;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	pzd3OPiuZ6mCFBtc;

1.36
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	F55lwc3gS4GN2mLs;

1.35
date	2015.01.16.06.40.01;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2014.05.20.21.11.16;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.12.12.16.53;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2013.06.11.16.42.05;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2011.05.05.16.29.33;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.21.00.38.22;	author martynas;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.10.19.15.07;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.02.20.16.13;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.02.15.10.30;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.02.14.43.14;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.02.14.39.12;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.10.00.00.58;	author david;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.03.22.32.34;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.09.08.13.09;	author todd;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.27.38;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.12.22.28.02;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.12.22.22.32;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.04.07.23.58;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.05.14.35.42;	author jakob;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.18.08.27.57;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.13.21.35.56;	author gluk;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.08.00.00.42;	author gluk;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.06.20.43.31;	author gluk;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.22.21.30.00;	author gluk;	state Exp;
branches;
next	1.8;

1.8
date	97.11.07.23.27.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.20.27.16;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.22.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.33.59;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.09.04.00.51.56;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.11.23.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Don't pledge before opendev. Just leave pledge "stdio" right
afterwards.

deraadt agrees
@
text
@/*	$OpenBSD: tunefs.c,v 1.40 2015/12/09 01:08:31 jsg Exp $	*/
/*	$NetBSD: tunefs.c,v 1.33 2005/01/19 20:46:16 xtraeme Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * tunefs: change layout parameters to an existing file system.
 */
#include <sys/param.h>	/* DEV_BSIZE MAXBSIZE */

#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>
#include <ufs/ffs/ffs_extern.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fstab.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

/* the optimization warning string template */
#define	OPTWARN	"should optimize for %s with minfree %s %d%%"

union {
	struct	fs sb;
	char pad[MAXBSIZE];
} sbun;
#define	sblock sbun.sb
char buf[MAXBSIZE];

int	fi;
int	is_ufs2 = 0;
off_t	sblockloc;

static off_t sblock_try[] = SBLOCKSEARCH;

static	void	bwrite(daddr_t, char *, int, const char *);
static	void	bread(daddr_t, char *, int, const char *);
static	int	getnum(const char *, const char *, int, int);
static	void	getsb(struct fs *, const char *);
static	int	openpartition(char *, int, char **);
static	void	usage(void);

int
main(int argc, char *argv[])
{
#define	OPTSTRING	"AFNe:g:h:m:o:"
	int		i, ch, Aflag, Fflag, Nflag, openflags;
	char		*special;
	const char	*chg[2];
	int		maxbpg, minfree, optim;
	int		avgfilesize, avgfpdir;

	Aflag = Fflag = Nflag = 0;
	maxbpg = minfree = optim = -1;
	avgfilesize = avgfpdir = -1;
	chg[FS_OPTSPACE] = "space";
	chg[FS_OPTTIME] = "time";

	while ((ch = getopt(argc, argv, OPTSTRING)) != -1) {
		switch (ch) {

		case 'A':
			Aflag = 1;
			break;

		case 'F':
			Fflag = 1;
			break;

		case 'N':
			Nflag = 1;
			break;

		case 'e':
			maxbpg = getnum(optarg,
			    "maximum blocks per file in a cylinder group",
			    1, INT_MAX);
			break;

		case 'g':
			avgfilesize = getnum(optarg,
			    "average file size", 1, INT_MAX);
			break;

		case 'h':
			avgfpdir = getnum(optarg,
			    "expected number of files per directory",
			    1, INT_MAX);
			break;

		case 'm':
			minfree = getnum(optarg,
			    "minimum percentage of free space", 0, 99);
			break;

		case 'o':
			if (strcmp(optarg, chg[FS_OPTSPACE]) == 0)
				optim = FS_OPTSPACE;
			else if (strcmp(optarg, chg[FS_OPTTIME]) == 0)
				optim = FS_OPTTIME;
			else
				errx(10,
				    "bad %s (options are `space' or `time')",
				    "optimization preference");
			break;

		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind; 
	if (argc != 1)
		usage();

	special = argv[0];
	openflags = Nflag ? O_RDONLY : O_RDWR;
	if (Fflag)
		fi = open(special, openflags);
	else
		fi = openpartition(special, openflags, &special);
	if (fi == -1)
		err(1, "%s", special);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	getsb(&sblock, special);

#define CHANGEVAL(old, new, type, suffix) do				\
	if ((new) != -1) {						\
		if ((new) == (old))					\
			warnx("%s remains unchanged at %d%s",		\
			    (type), (old), (suffix));			\
		else {							\
			warnx("%s changes from %d%s to %d%s",		\
			    (type), (old), (suffix), (new), (suffix));	\
			(old) = (new);					\
		}							\
	} while (/* CONSTCOND */0)

	warnx("tuning %s", special);
	CHANGEVAL(sblock.fs_maxbpg, maxbpg,
	    "maximum blocks per file in a cylinder group", "");
	CHANGEVAL(sblock.fs_minfree, minfree,
	    "minimum percentage of free space", "%");
	if (minfree != -1) {
		if (minfree >= MINFREE &&
		    sblock.fs_optim == FS_OPTSPACE)
			warnx(OPTWARN, "time", ">=", MINFREE);
		if (minfree < MINFREE &&
		    sblock.fs_optim == FS_OPTTIME)
			warnx(OPTWARN, "space", "<", MINFREE);
	}
	if (optim != -1) {
		if (sblock.fs_optim == optim) {
			warnx("%s remains unchanged as %s",
			    "optimization preference",
			    chg[optim]);
		} else {
			warnx("%s changes from %s to %s",
			    "optimization preference",
			    chg[sblock.fs_optim], chg[optim]);
			sblock.fs_optim = optim;
			if (sblock.fs_minfree >= MINFREE &&
			    optim == FS_OPTSPACE)
				warnx(OPTWARN, "time", ">=", MINFREE);
			if (sblock.fs_minfree < MINFREE &&
			    optim == FS_OPTTIME)
				warnx(OPTWARN, "space", "<", MINFREE);
		}
	}
	CHANGEVAL(sblock.fs_avgfilesize, avgfilesize,
	    "average file size", "");
	CHANGEVAL(sblock.fs_avgfpdir, avgfpdir,
	    "expected number of files per directory", "");

	if (Nflag) {
		fprintf(stdout, "tunefs: current settings of %s\n", special);
		fprintf(stdout, "\tmaximum contiguous block count %d\n",
		    sblock.fs_maxcontig);
		fprintf(stdout,
		    "\tmaximum blocks per file in a cylinder group %d\n",
		    sblock.fs_maxbpg);
		fprintf(stdout, "\tminimum percentage of free space %d%%\n",
		    sblock.fs_minfree);
		fprintf(stdout, "\toptimization preference: %s\n",
		    chg[sblock.fs_optim]);
		fprintf(stdout, "\taverage file size: %d\n",
		    sblock.fs_avgfilesize);
		fprintf(stdout,
		    "\texpected number of files per directory: %d\n",
		    sblock.fs_avgfpdir);
		fprintf(stdout, "tunefs: no changes made\n");
		exit(0);
	}

	memcpy(buf, (char *)&sblock, SBLOCKSIZE);
	bwrite(sblockloc, buf, SBLOCKSIZE, special);
	if (Aflag)
		for (i = 0; i < sblock.fs_ncg; i++)
			bwrite(fsbtodb(&sblock, cgsblock(&sblock, i)),
			    buf, SBLOCKSIZE, special);
	close(fi);
	exit(0);
}

static int
getnum(const char *num, const char *desc, int min, int max)
{
	int		n;
	const char	*errstr;

	n = strtonum(num, min, max, &errstr);
	if (errstr != NULL)
		errx(1, "Invalid number `%s' for %s: %s", num, desc, errstr);
	return (n);
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-AFN] [-e maxbpg] [-g avgfilesize] "
	    "[-h avgfpdir] [-m minfree]\n"
	    "\t[-o optimize_preference] special | filesys\n",
	    __progname);

	exit(2);
}

static void
getsb(struct fs *fs, const char *file)
{
	int i;

	for (i = 0; ; i++) {
		if (sblock_try[i] == -1)
			errx(5, "cannot find filesystem superblock");
		bread(sblock_try[i] / DEV_BSIZE, (char *)fs, SBLOCKSIZE, file);
		switch(fs->fs_magic) {
		case FS_UFS2_MAGIC:
			is_ufs2 = 1;
			/*FALLTHROUGH*/
		case FS_UFS1_MAGIC:
			break;
		default:
			continue;
		}
		if (!is_ufs2 && sblock_try[i] == SBLOCK_UFS2)
			continue;
		if ((is_ufs2 || fs->fs_flags & FS_FLAGS_UPDATED)
		    && fs->fs_sblockloc != sblock_try[i])
			continue;
		break;
	}

	sblockloc = sblock_try[i] / DEV_BSIZE;
}

static void
bwrite(daddr_t blk, char *buffer, int size, const char *file)
{
	if (pwrite(fi, buffer, size, blk * DEV_BSIZE) != size)
		err(7, "%s: writing %d bytes @@ %lld", file, size,
		    (long long)(blk * DEV_BSIZE));
}

static void
bread(daddr_t blk, char *buffer, int cnt, const char *file)
{
	if ((pread(fi, buffer, cnt, (off_t)blk * DEV_BSIZE)) != cnt)
		errx(5, "%s: reading %d bytes @@ %lld", file, cnt,
		    (long long)(blk * DEV_BSIZE));
}

static int
openpartition(char *name, int flags, char **devicep)
{
	char		rawspec[PATH_MAX], *p;
	struct fstab	*fs;
	int		fd;

	fs = getfsfile(name);
	if (fs) {
		if ((p = strrchr(fs->fs_spec, '/')) != NULL) {
			snprintf(rawspec, sizeof(rawspec), "%.*s/r%s",
			    (int)(p - fs->fs_spec), fs->fs_spec, p + 1);
			name = rawspec;
		} else
			name = fs->fs_spec;
	}
	fd = opendev(name, flags, 0, devicep);
	if (fd == -1 && errno == ENOENT)
		devicep = &name;
	return (fd);
}
@


1.40
log
@add braces to correct pledge logic
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.39 2015/11/23 19:19:30 deraadt Exp $	*/
a148 8

	if (Nflag) {
		if (pledge("stdio rpath disklabel", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio rpath wpath disklabel", NULL) == -1)
			err(1, "pledge");
	}
@


1.39
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.38 2015/10/12 02:01:15 deraadt Exp $	*/
d150 1
a150 1
	if (Nflag)
d153 1
a153 1
	else {
@


1.38
log
@tunefs can pledge to only use "stdio", after it has opened the device.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.37 2015/02/07 02:09:14 deraadt Exp $	*/
d149 8
@


1.37
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.36 2015/01/20 18:22:21 deraadt Exp $	*/
d158 4
@


1.36
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.35 2015/01/16 06:40:01 deraadt Exp $	*/
d97 1
a97 1
			Aflag++;
d101 1
a101 1
			Fflag++;
d105 1
a105 1
			Nflag++;
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.34 2014/05/20 21:11:16 krw Exp $	*/
d36 1
a36 1
#include <sys/param.h>	/* DEV_BSIZE MAXBSIZE MAXFRAG */
@


1.34
log
@As suggested by guenther@@ and millert@@, replace seek+[read|write] with
p[read|write].  Makes the code much clearer by eliminating extra error
checking and verbiage.

No intentional functional change.

Tweaks by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.33 2014/05/12 12:16:53 krw Exp $	*/
d36 1
a36 1
#include <sys/param.h>
d51 1
d312 1
a312 1
	char		rawspec[MAXPATHLEN], *p;
@


1.33
log
@No need for a dev_bsize variable that is always set to 512,
a.k.a. DEV_BSIZE. So just use DEV_BSIZE.

Confirmed to still work on 4k-byte sector disks by David Vasek.
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.32 2013/06/11 16:42:05 deraadt Exp $	*/
d295 3
a297 7
	off_t	offset;

	offset = (off_t)blk * DEV_BSIZE;
	if (lseek(fi, offset, SEEK_SET) == -1)
		err(6, "%s: seeking to %lld", file, (long long)offset);
	if (write(fi, buffer, size) != size)
		err(7, "%s: writing %d bytes", file, size);
d303 3
a305 8
	off_t	offset;
	int	i;

	offset = (off_t)blk * DEV_BSIZE;
	if (lseek(fi, offset, SEEK_SET) == -1)
		err(4, "%s: seeking to %lld", file, (long long)offset);
	if ((i = read(fi, buffer, cnt)) != cnt)
		errx(5, "%s: short read", file);
@


1.32
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.31 2011/05/05 16:29:33 millert Exp $	*/
a63 1
long	dev_bsize = 512;
d271 1
a271 1
		bread(sblock_try[i] / dev_bsize, (char *)fs, SBLOCKSIZE, file);
d289 1
a289 2
	dev_bsize = fs->fs_fsize / fsbtodb(fs, 1);
	sblockloc = sblock_try[i] / dev_bsize;
d297 1
a297 1
	offset = (off_t)blk * dev_bsize;
d310 1
a310 1
	offset = (off_t)blk * dev_bsize;
@


1.31
log
@Use opendev() not opendisk() so we get duid support.  OK oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.30 2009/10/27 23:59:34 deraadt Exp $	*/
d70 2
a71 2
static	void	bwrite(daddr64_t, char *, int, const char *);
static	void	bread(daddr64_t, char *, int, const char *);
d295 1
a295 1
bwrite(daddr64_t blk, char *buffer, int size, const char *file)
d307 1
a307 1
bread(daddr64_t blk, char *buffer, int cnt, const char *file)
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.29 2009/06/21 00:38:22 martynas Exp $	*/
d74 1
a74 1
static	int	openpartition(const char *, int, char *, size_t);
d82 2
a83 2
	const char	*special, *chg[2];
	char		device[MAXPATHLEN];
d154 2
a155 4
	else {
		fi = openpartition(special, openflags, device, sizeof(device));
		special = device;
	}
d320 1
a320 1
openpartition(const char *name, int flags, char *device, size_t devicelen)
d324 1
a324 1
	int		fd, oerrno;
d335 3
a337 6
	fd = opendisk(name, flags, device, devicelen, 0);
	if (fd == -1 && errno == ENOENT) {
		oerrno = errno;
		strlcpy(device, name, devicelen);
		errno = oerrno;
	}
@


1.29
log
@fix rcs ids.  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)tunefs.c	8.3 (Berkeley) 5/3/95";
#else
static const char rcsid[] = "$OpenBSD$";
#endif
#endif /* not lint */
@


1.28
log
@daddr_t -> daddr64_t
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD";
@


1.27
log
@convert to standard usage(); ok millert otto
@
text
@d84 2
a85 2
static	void	bwrite(daddr_t, char *, int, const char *);
static	void	bread(daddr_t, char *, int, const char *);
d311 1
a311 1
bwrite(daddr_t blk, char *buffer, int size, const char *file)
d323 1
a323 1
bread(daddr_t blk, char *buffer, int cnt, const char *file)
@


1.26
log
@use strtonum(3) and usage nit; ok millert@@
@
text
@d269 7
a276 7
	fprintf(stderr, "usage: tunefs [-AFN] tuneup-options special-device\n"
		"where tuneup-options are:\n"
		"\t-e maximum blocks per file in a cylinder group\n"
		"\t-g average file size\n"
		"\t-h expected number of files per directory\n"
		"\t-m minimum percentage of free space\n"
		"\t-o optimization preference (`space' or `time')\n");
@


1.25
log
@remove #ifdef TUNEFS_SOFTDEP code, requested by millert@@
@
text
@d257 2
a258 2
	long	n;
	char	*ep;
d260 4
a263 8
	n = strtol(num, &ep, 10);
	if (ep[0] != '\0')
		errx(1, "Invalid number `%s' for %s", num, desc);
	if ((int) n < min)
		errx(1, "%s `%s' too small (minimum is %d)", desc, num, min);
	if ((int) n > max)
		errx(1, "%s `%s' too large (maximum is %d)", desc, num, max);
	return ((int)n);
d270 7
a276 7
	fprintf(stderr, "usage: tunefs [-AFN] tuneup-options special-device\n");
	fprintf(stderr, "where tuneup-options are:\n");
	fprintf(stderr, "\t-e maximum blocks per file in a cylinder group\n");
	fprintf(stderr, "\t-g average file size\n");
	fprintf(stderr, "\t-h expected number of files per directory\n");
	fprintf(stderr, "\t-m minimum percentage of free space\n");
	fprintf(stderr, "\t-o optimization preference (`space' or `time')\n");
@


1.24
log
@FFS2 savvy tunefs from NetBSD. Some cleanup will be done after this.
ok millert@@ and jmc@@ for the man page.
@
text
@d94 1
a94 7
#define	OPTSTRINGBASE	"AFNe:g:h:m:o:"
#ifdef TUNEFS_SOFTDEP
	int		softdep;
#define	OPTSTRING	OPTSTRINGBASE ## "n:"
#else
#define	OPTSTRING	OPTSTRINGBASE
#endif
a103 3
#ifdef TUNEFS_SOFTDEP
	softdep = -1;
#endif
a143 13
#ifdef TUNEFS_SOFTDEP
		case 'n':
			if (strcmp(optarg, "enable") == 0)
				softdep = 1;
			else if (strcmp(optarg, "disable") == 0)
				softdep = 0;
			else {
				errx(10, "bad soft dependencies "
					"(options are `enable' or `disable')");
			}
			break;
#endif

a200 9
#ifdef TUNEFS_SOFTDEP
	if (softdep == 1) {
		sblock.fs_flags |= FS_DOSOFTDEP;
		warnx("soft dependencies set");
	} else if (softdep == 0) {
		sblock.fs_flags &= ~FS_DOSOFTDEP;
		warnx("soft dependencies cleared");
	}
#endif
a232 4
#ifdef TUNEFS_SOFTDEP
		fprintf(stdout, "\tsoft dependencies: %s\n",
		    (sblock.fs_flags & FS_DOSOFTDEP) ? "on" : "off");
#endif
a279 3
#ifdef TUNEFS_SOFTDEP
	fprintf(stderr, "\t-n soft dependencies (`enable' or `disable')\n");
#endif
@


1.23
log
@add missing includes
ok deraadt@@ millert@@ tedu@@
@
text
@d1 2
a2 2
/*	$OpenBSD: tunefs.c,v 1.22 2003/06/02 20:06:17 millert Exp $	*/
/*	$NetBSD: tunefs.c,v 1.10 1995/03/18 15:01:31 cgd Exp $	*/
d41 1
a41 1
static char sccsid[] = "@@(#)tunefs.c	8.2 (Berkeley) 4/19/94";
d43 1
a43 2
static const char rcsid[] =
	"$OpenBSD: tunefs.c,v 1.22 2003/06/02 20:06:17 millert Exp $";
a50 1
#include <sys/stat.h>
d52 1
d54 1
d56 1
a57 1
#include <err.h>
d60 1
a61 1
#include <paths.h>
d65 1
d75 1
d77 13
a89 10
int fi = -1;
long dev_bsize = 1;

void bwrite(daddr_t, char *, int);
int bread(daddr_t, char *, int);
void getsb(struct fs *, char *, int);
void usage(void);
void printfs(void);

extern char *__progname;
d94 21
a114 6
	char *cp, *special, *name;
	struct stat st;
	int i;
	int Aflag = 0;
	struct fstab *fs;
	char *chg[2], device[MAXPATHLEN];
d116 2
a117 162
	argc--, argv++;
	if (argc < 2)
		usage();
	special = argv[argc - 1];
	fs = getfsfile(special);
	if (fs)
		special = fs->fs_spec;
again:
	if (stat(special, &st) < 0) {
		if (*special != '/') {
			if (*special == 'r')
				special++;
			(void)snprintf(device, sizeof(device), "%s%s",
				       _PATH_DEV, special);
			special = device;
			goto again;
		}
		err(1, "%s", special);
	}
	if (!S_ISBLK(st.st_mode) && !S_ISCHR(st.st_mode))
		errx(10, "%s: not a block or character device", special);
	for (; argc > 0 && argv[0][0] == '-'; argc--, argv++) {
		for (cp = &argv[0][1]; *cp; cp++)
			switch (*cp) {

			case 'A':
				Aflag++;
				continue;

			case 'p':
				getsb(&sblock, special, O_RDONLY);
				printfs();
				return (0);

			case 'a':
				getsb(&sblock, special, O_RDWR);
				name = "maximum contiguous block count";
				if (argc < 1)
					errx(10, "-a: missing %s", name);
				argc--, argv++;
				i = atoi(*argv);
				if (i < 1)
					errx(10, "%s must be >= 1 (was %s)",
					    name, *argv);
				warnx("%s changes from %d to %d",
				    name, sblock.fs_maxcontig, i);
				sblock.fs_maxcontig = i;
				continue;

			case 'd':
				getsb(&sblock, special, O_RDWR);
				name =
				   "rotational delay between contiguous blocks";
				if (argc < 1)
					errx(10, "-d: missing %s", name);
				argc--, argv++;
				i = atoi(*argv);
				warnx("%s changes from %dms to %dms",
				    name, sblock.fs_rotdelay, i);
				sblock.fs_rotdelay = i;
				continue;

			case 'e':
				getsb(&sblock, special, O_RDWR);
				name =
				  "maximum blocks per file in a cylinder group";
				if (argc < 1)
					errx(10, "-e: missing %s", name);
				argc--, argv++;
				i = atoi(*argv);
				if (i < 1)
					errx(10, "%s must be >= 1 (was %s)",
					    name, *argv);
				warnx("%s changes from %d to %d",
				    name, sblock.fs_maxbpg, i);
				sblock.fs_maxbpg = i;
				continue;

			case 'f':
				getsb(&sblock, special, O_RDWR);
				name = "average file size";
				if (argc < 1)
					errx(10, "-f: missing %s", name);
				argc--, argv++;
				i = atoi(*argv);
				if (i < 0)
					errx(10, "%s must be >= 0 (was %s)",
					    name, *argv);
				warnx("%s changes from %d to %d",
				    name, sblock.fs_avgfilesize, i);
				sblock.fs_avgfilesize = i;
				continue;

			case 'm':
				getsb(&sblock, special, O_RDWR);
				name = "minimum percentage of free space";
				if (argc < 1)
					errx(10, "-m: missing %s", name);
				argc--, argv++;
				i = atoi(*argv);
				if (i < 0 || i > 99)
					errx(10, "bad %s (%s)", name, *argv);
				warnx("%s changes from %d%% to %d%%",
				    name, sblock.fs_minfree, i);
				sblock.fs_minfree = i;
				if (i >= MINFREE &&
				    sblock.fs_optim == FS_OPTSPACE)
					warnx(OPTWARN, "time", ">=", MINFREE);
				if (i < MINFREE &&
				    sblock.fs_optim == FS_OPTTIME)
					warnx(OPTWARN, "space", "<", MINFREE);
				continue;

			case 'n':
				getsb(&sblock, special, O_RDWR);
				name = "expected number of files per directory";
				if (argc < 1)
					errx(10, "-n: missing %s", name);
				argc--, argv++;
				i = atoi(*argv);
				if (i < 0)
					errx(10, "%s must be >= 0 (was %s)",
					    name, *argv);
				warnx("%s changes from %d to %d",
				    name, sblock.fs_avgfpdir, i);
				sblock.fs_avgfpdir = i;
				continue;

			case 's':
				errx(1, "See mount(8) for details about"
				      " how to enable soft updates.");

			case 'o':
				getsb(&sblock, special, O_RDWR);
				name = "optimization preference";
				if (argc < 1)
					errx(10, "-o: missing %s", name);
				argc--, argv++;
				chg[FS_OPTSPACE] = "space";
				chg[FS_OPTTIME] = "time";
				if (strcmp(*argv, chg[FS_OPTSPACE]) == 0)
					i = FS_OPTSPACE;
				else if (strcmp(*argv, chg[FS_OPTTIME]) == 0)
					i = FS_OPTTIME;
				else
					errx(10, "bad %s (options are `space' or `time')",
					    name);
				if (sblock.fs_optim == i) {
					warnx("%s remains unchanged as %s",
					    name, chg[i]);
					continue;
				}
				warnx("%s changes from %s to %s",
				    name, chg[sblock.fs_optim], chg[i]);
				sblock.fs_optim = i;
				if (sblock.fs_minfree >= MINFREE &&
				    i == FS_OPTSPACE)
					warnx(OPTWARN, "time", ">=", MINFREE);
				if (sblock.fs_minfree < MINFREE &&
				    i == FS_OPTTIME)
					warnx(OPTWARN, "space", "<", MINFREE);
				continue;
d119 43
a161 2
			default:
				usage();
d163 17
d181 2
d185 96
a280 1
	bwrite((daddr_t)SBOFF / dev_bsize, (char *)&sblock, SBSIZE);
d284 10
a293 3
			    (char *)&sblock, SBSIZE);
	if (close(fi))
		err(1, "close: %s", special);
d295 8
a302 1
	return (0);
d305 1
a305 1
void
d308 11
a318 13
	fprintf(stderr,
		"Usage: %s tuneup-options special-device\n"
		"where tuneup-options are:\n"
		"\t-A modify all backups of the super-block\n"
		"\t-a maximum contiguous blocks\n"
		"\t-d rotational delay between contiguous blocks\n"
		"\t-e maximum blocks per file in a cylinder group\n"
		"\t-f expected average file size\n"
		"\t-m minimum percentage of free space\n"
		"\t-n expected number of files per directory\n"
		"\t-o optimization preference (`space' or `time')\n"
		"\t-p no change - just prints current tuneable settings\n",
		__progname);
d322 2
a323 2
void
getsb(struct fs *fs, char *file, int flags)
d325 22
a347 9
	if (fi >= 0)
		return;
	fi = open(file, flags);
	if (fi < 0)
		err(3, "cannot open %s", file);
	if (bread((daddr_t)SBOFF, (char *)fs, SBSIZE))
		err(4, "%s: bad super block", file);
	if (fs->fs_magic != FS_MAGIC)
		errx(5, "%s: bad magic number", file);
d349 1
d352 2
a353 2
void
printfs(void)
d355 7
a361 20
	warnx("maximum contiguous block count: (-a)               %d",
	      sblock.fs_maxcontig);
	warnx("rotational delay between contiguous blocks: (-d)   %d ms",
	      sblock.fs_rotdelay);
	warnx("maximum blocks per file in a cylinder group: (-e)  %d",
	      sblock.fs_maxbpg);
	warnx("expected average file size: (-f)                   %d",
	      sblock.fs_avgfilesize);
	warnx("minimum percentage of free space: (-m)             %d%%",
	      sblock.fs_minfree);
	warnx("expected number of files per directory: (-n)       %d",
	      sblock.fs_avgfpdir);
	warnx("optimization preference: (-o)                      %s",
	      sblock.fs_optim == FS_OPTSPACE ? "space" : "time");
	if (sblock.fs_minfree >= MINFREE &&
	    sblock.fs_optim == FS_OPTSPACE)
		warnx(OPTWARN, "time", ">=", MINFREE);
	if (sblock.fs_minfree < MINFREE &&
	    sblock.fs_optim == FS_OPTTIME)
		warnx(OPTWARN, "space", "<", MINFREE);
d364 2
a365 2
void
bwrite(daddr_t blk, char *buf, int size)
d367 2
d370 5
a374 4
	if (lseek(fi, (off_t)blk * dev_bsize, SEEK_SET) < 0)
		err(6, "FS SEEK");
	if (write(fi, buf, size) != size)
		err(7, "FS WRITE");
d377 2
a378 2
int
bread(daddr_t bno, char *buf, int cnt)
d380 18
a397 8
	int i;

	if (lseek(fi, (off_t)bno * dev_bsize, SEEK_SET) < 0)
		return(1);
	if ((i = read(fi, buf, cnt)) != cnt) {
		for(i=0; i<sblock.fs_bsize; i++)
			buf[i] = 0;
		return (1);
d399 1
a399 1
	return (0);
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.21 2002/07/03 22:32:34 deraadt Exp $	*/
d44 1
a44 1
	"$OpenBSD: tunefs.c,v 1.21 2002/07/03 22:32:34 deraadt Exp $";
d63 1
@


1.21
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.20 2002/06/09 08:13:09 todd Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
	"$OpenBSD: tunefs.c,v 1.20 2002/06/09 08:13:09 todd Exp $";
@


1.20
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.19 2002/02/16 21:27:38 millert Exp $	*/
d48 1
a48 1
	"$OpenBSD: tunefs.c,v 1.19 2002/02/16 21:27:38 millert Exp $";
d90 1
a90 3
main(argc, argv)
	int argc;
	char *argv[];
d280 1
a280 1
usage()
d299 1
a299 4
getsb(fs, file, flags)
	struct fs *fs;
	char *file;
	int flags;
d315 1
a315 1
printfs()
d340 1
a340 4
bwrite(blk, buf, size)
	daddr_t blk;
	char *buf;
	int size;
d350 1
a350 4
bread(bno, buf, cnt)
	daddr_t bno;
	char *buf;
	int cnt;
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.18 2002/02/12 22:28:02 fgsch Exp $	*/
d48 1
a48 1
	"$OpenBSD: tunefs.c,v 1.18 2002/02/12 22:28:02 fgsch Exp $";
d101 1
a101 1
	argc--, argv++; 
@


1.18
log
@while im here; clean -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.17 2002/02/12 22:22:32 fgsch Exp $	*/
d48 1
a48 1
	"$OpenBSD: tunefs.c,v 1.17 2002/02/12 22:22:32 fgsch Exp $";
d84 2
a85 2
void usage __P((void));
void printfs __P((void));
@


1.17
log
@_PATH_DEV already includes the trailing '/'; no need for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.16 2001/12/04 07:23:58 mickey Exp $	*/
d38 1
a38 1
static char copyright[] =
d47 2
a48 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.16 2001/12/04 07:23:58 mickey Exp $";
@


1.16
log
@do not open the device for writing if not needed to; millert@@ ok & help
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.15 2001/11/05 07:39:17 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.15 2001/11/05 07:39:17 mpech Exp $";
d112 1
a112 1
			(void)snprintf(device, sizeof(device), "%s/%s",
@


1.15
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.14 2001/10/05 14:35:42 jakob Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.14 2001/10/05 14:35:42 jakob Exp $";
d77 1
a77 1
int fi;
d82 1
a82 1
void getsb(struct fs *, char *);
a120 1
	getsb(&sblock, special);
d130 1
d135 1
d150 1
d163 1
d179 1
d194 1
d214 1
d233 1
d274 3
a276 1
	close(fi);
d300 1
a300 1
getsb(fs, file)
d303 1
d306 3
a308 1
	fi = open(file, 2);
d314 1
a314 1
		err(5, "%s: bad magic number", file);
@


1.14
log
@document missing options. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.13 2001/05/18 08:27:57 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.13 2001/05/18 08:27:57 mickey Exp $";
d292 1
a292 1
	register struct fs *fs;
@


1.13
log
@treat two exits for a return
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.12 2001/04/13 21:35:56 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.12 2001/04/13 21:35:56 gluk Exp $";
d277 1
@


1.12
log
@Remove softdep and add avgfilesize/avgfpdir in printfs().
Pointed out by fgs@@.

deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.11 2001/04/08 00:00:42 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.11 2001/04/08 00:00:42 gluk Exp $";
d132 1
a132 1
				exit(0);
d268 1
a268 1
	exit(0);
@


1.11
log
@Remove soft updates. Warn users about how to enable softdep.

art, deraadt ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.10 2001/04/06 20:43:31 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.10 2001/04/06 20:43:31 gluk Exp $";
a307 2
	warnx("soft updates: (-s)                                 %s",
	      (sblock.fs_flags & FS_DOSOFTDEP) ? "yes" : "no");
d314 2
d318 2
@


1.10
log
@Replace FFS directory preference algorithm(dirpref) by new one.
It allocates directory inode in the same cylinder group as a parent
directory in. This speedup file/directory intensive operations on
a big file systems in times.

Don't forget to recompile fsck_ffs with updated fs.h or you will get
"VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE" at
the next boot. In any case you can ignore this error safely.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.9 2001/03/22 21:30:00 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.8 1997/11/07 23:27:04 deraadt Exp $";
d93 1
a93 1
	char *cp, *special, *name, *action;
d223 2
a224 16
				name = "soft updates";
				if (argc < 1)
					errx(10, "-s: missing %s", name);
				argc--, argv++;
				if (strcmp(*argv, "enable") == 0) {
					sblock.fs_flags |= FS_DOSOFTDEP;
					action = "set";
				} else if (strcmp(*argv, "disable") == 0) {
					sblock.fs_flags &= ~FS_DOSOFTDEP;
					action = "cleared";
				} else {
					errx(10, "bad %s (options are %s)",
					    name, "`enable' or `disable'");
				}
				warnx("%s %s", name, action);
				continue;
d284 1
a284 2
		"\t-p no change - just prints current tuneable settings\n"
		"\t-s soft updates ('enable' or 'disable')\n",
@


1.9
log
@sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.8 1997/11/07 23:27:04 deraadt Exp $	*/
d175 14
d208 14
d294 1
d296 1
@


1.8
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.7 1997/11/06 20:27:16 csapuntz Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.7 1997/11/06 20:27:16 csapuntz Exp $";
d112 2
a113 1
			(void)sprintf(device, "%s/%s", _PATH_DEV, special);
@


1.7
log
@Added support for enabling soft updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.5 1997/10/06 15:33:59 csapuntz Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.5 1997/10/06 15:33:59 csapuntz Exp $";
d193 17
a209 18
 			case 's':
 				name = "soft updates";
 				if (argc < 1)
 					errx(10, "-s: missing %s", name);
 				argc--, argv++;
 				if (strcmp(*argv, "enable") == 0) {
 					sblock.fs_flags |= FS_DOSOFTDEP;
 					action = "set";
 				} else if (strcmp(*argv, "disable") == 0) {
 					sblock.fs_flags &= ~FS_DOSOFTDEP;
 					action = "cleared";
 				} else {
 					errx(10, "bad %s (options are %s)",
 					    name, "`enable' or `disable'");
 				}
 				warnx("%s %s", name, action);
 				continue;
 
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.4 1997/09/04 00:51:56 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.4 1997/09/04 00:51:56 mickey Exp $";
d93 1
a93 1
	char *cp, *special, *name;
d193 19
d268 2
a269 1
		"\t-p no change - just prints current tuneable settings\n",
d293 2
@


1.5
log
@VFS Lite2 Changes
@
text
@d93 1
a93 1
	char *cp, *special, *name, *action;
a192 19
 			case 'n':
 				name = "soft updates";
 				if (argc < 1)
 					errx(10, "-s: missing %s", name);
 				argc--, argv++;
 				if (strcmp(*argv, "enable") == 0) {
 					sblock.fs_flags |= FS_DOSOFTDEP;
 					action = "set";
 				} else if (strcmp(*argv, "disable") == 0) {
 					sblock.fs_flags &= ~FS_DOSOFTDEP;
 					action = "cleared";
 				} else {
 					errx(10, "bad %s (options are %s)",
 					    name, "`enable' or `disable'");
 				}
 				warnx("%s %s", name, action);
 				continue;
 

a247 1
		"\t-n soft updates ('enable' or 'disable')\n"
a272 2
	warnx("soft updates: (-n)                                 %s",
	      (sblock.fs_flags & FS_DOSOFTDEP) ? "yes" : "no");
@


1.4
log
@use err()/warn()/__progname where appropriate, consolidate string, some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.3 1996/08/02 11:23:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.3 1996/08/02 11:23:35 deraadt Exp $";
d93 1
a93 1
	char *cp, *special, *name;
d193 19
d267 1
d293 2
@


1.3
log
@add -p option to show current values; this information is available from
dumpfs but not readily obvious. from freebsd by peter@@haywire.dialix.com
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.2 1996/06/23 14:32:50 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.2 1996/06/23 14:32:50 deraadt Exp $";
d86 2
d241 10
a250 9

	fprintf(stderr, "Usage: tunefs tuneup-options special-device\n");
	fprintf(stderr, "where tuneup-options are:\n");
	fprintf(stderr, "\t-a maximum contiguous blocks\n");
	fprintf(stderr, "\t-d rotational delay between contiguous blocks\n");
	fprintf(stderr, "\t-e maximum blocks per file in a cylinder group\n");
	fprintf(stderr, "\t-m minimum percentage of free space\n");
	fprintf(stderr, "\t-o optimization preference (`space' or `time')\n");
	fprintf(stderr, "\t-p no change - just prints current tuneable settings\n");
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: tunefs.c,v 1.10 1995/03/18 15:01:31 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tunefs.c,v 1.10 1995/03/18 15:01:31 cgd Exp $";
d84 1
d127 4
d247 1
d265 21
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: tunefs.c,v 1.10 1995/03/18 15:01:31 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
