head	1.308;
access;
symbols
	OPENBSD_6_2:1.308.0.2
	OPENBSD_6_2_BASE:1.308
	OPENBSD_6_1:1.305.0.4
	OPENBSD_6_1_BASE:1.305
	OPENBSD_6_0:1.300.0.4
	OPENBSD_6_0_BASE:1.300
	OPENBSD_5_9:1.300.0.2
	OPENBSD_5_9_BASE:1.300
	OPENBSD_5_8:1.295.0.4
	OPENBSD_5_8_BASE:1.295
	OPENBSD_5_7:1.291.0.2
	OPENBSD_5_7_BASE:1.291
	OPENBSD_5_6:1.287.0.4
	OPENBSD_5_6_BASE:1.287
	OPENBSD_5_5:1.282.0.4
	OPENBSD_5_5_BASE:1.282
	OPENBSD_5_4:1.271.0.2
	OPENBSD_5_4_BASE:1.271
	OPENBSD_5_3:1.269.0.4
	OPENBSD_5_3_BASE:1.269
	OPENBSD_5_2:1.269.0.2
	OPENBSD_5_2_BASE:1.269
	OPENBSD_5_1_BASE:1.266
	OPENBSD_5_1:1.266.0.2
	OPENBSD_5_0:1.258.0.2
	OPENBSD_5_0_BASE:1.258
	OPENBSD_4_9:1.248.0.2
	OPENBSD_4_9_BASE:1.248
	OPENBSD_4_8:1.242.0.2
	OPENBSD_4_8_BASE:1.242
	OPENBSD_4_7:1.225.0.2
	OPENBSD_4_7_BASE:1.225
	OPENBSD_4_6:1.219.0.4
	OPENBSD_4_6_BASE:1.219
	OPENBSD_4_5:1.174.0.2
	OPENBSD_4_5_BASE:1.174
	OPENBSD_4_4:1.168.0.2
	OPENBSD_4_4_BASE:1.168
	OPENBSD_4_3:1.166.0.2
	OPENBSD_4_3_BASE:1.166
	OPENBSD_4_2:1.124.0.2
	OPENBSD_4_2_BASE:1.124
	OPENBSD_4_1:1.107.0.2
	OPENBSD_4_1_BASE:1.107
	OPENBSD_4_0:1.104.0.2
	OPENBSD_4_0_BASE:1.104
	OPENBSD_3_9:1.101.0.2
	OPENBSD_3_9_BASE:1.101
	OPENBSD_3_8:1.99.0.4
	OPENBSD_3_8_BASE:1.99
	OPENBSD_3_7:1.99.0.2
	OPENBSD_3_7_BASE:1.99
	OPENBSD_3_6:1.94.0.2
	OPENBSD_3_6_BASE:1.94
	OPENBSD_3_5:1.93.0.2
	OPENBSD_3_5_BASE:1.93
	OPENBSD_3_4:1.90.0.2
	OPENBSD_3_4_BASE:1.90
	OPENBSD_3_3:1.82.0.2
	OPENBSD_3_3_BASE:1.82
	OPENBSD_3_2:1.81.0.2
	OPENBSD_3_2_BASE:1.81
	OPENBSD_3_1:1.79.0.2
	OPENBSD_3_1_BASE:1.79
	OPENBSD_3_0:1.77.0.2
	OPENBSD_3_0_BASE:1.77
	OPENBSD_2_9:1.75.0.2
	OPENBSD_2_9_BASE:1.75
	OPENBSD_2_8:1.74.0.2
	OPENBSD_2_8_BASE:1.74
	OPENBSD_2_7:1.70.0.2
	OPENBSD_2_7_BASE:1.70
	OPENBSD_2_6:1.66.0.2
	OPENBSD_2_6_BASE:1.66
	OPENBSD_2_5:1.63.0.2
	OPENBSD_2_5_BASE:1.63
	OPENBSD_2_4:1.45.0.2
	OPENBSD_2_4_BASE:1.45
	OPENBSD_2_3:1.34.0.2
	OPENBSD_2_3_BASE:1.34
	OPENBSD_2_2:1.24.0.2
	OPENBSD_2_2_BASE:1.24;
locks; strict;
comment	@ * @;


1.308
date	2017.09.29.18.32.09;	author otto;	state Exp;
branches;
next	1.307;
commitid	1hWxE0e5a4eVxvXZ;

1.307
date	2017.05.19.12.54.30;	author otto;	state Exp;
branches;
next	1.306;
commitid	3ELqsVKz9uLbEqt6;

1.306
date	2017.04.19.05.27.00;	author otto;	state Exp;
branches;
next	1.305;
commitid	qBZFDTDSmKfjfZbB;

1.305
date	2017.03.04.07.26.42;	author otto;	state Exp;
branches;
next	1.304;
commitid	JwCAC267qNydLo8J;

1.304
date	2016.10.06.13.02.31;	author otto;	state Exp;
branches;
next	1.303;
commitid	UrUD4gBCthZrjhvz;

1.303
date	2016.09.02.10.47.17;	author otto;	state Exp;
branches;
next	1.302;
commitid	eaKocvXC2WL7VoW0;

1.302
date	2016.09.01.09.46.42;	author tedu;	state Exp;
branches;
next	1.301;
commitid	2IuVNKwpZd3jQtHH;

1.301
date	2016.08.19.08.06.25;	author otto;	state Exp;
branches;
next	1.300;
commitid	P1AEDuAjSYJf0r8B;

1.300
date	2015.12.10.17.26.59;	author mmcc;	state Exp;
branches;
next	1.299;
commitid	82PdNqu2kKAuXPfA;

1.299
date	2015.11.23.19.19.29;	author deraadt;	state Exp;
branches;
next	1.298;
commitid	Cz19p5I1S6mVZIjV;

1.298
date	2015.10.17.13.27.08;	author krw;	state Exp;
branches;
next	1.297;
commitid	V77mDKjRGnu2BBag;

1.297
date	2015.10.15.19.31.15;	author miod;	state Exp;
branches;
next	1.296;
commitid	cIMgSVEQ53BJoP4V;

1.296
date	2015.09.08.13.54.09;	author millert;	state Exp;
branches;
next	1.295;
commitid	LpUmMvywEkeCpU6f;

1.295
date	2015.05.08.12.15.50;	author sthen;	state Exp;
branches;
next	1.294;
commitid	cdikkMuE0r2NN8Cv;

1.294
date	2015.04.29.16.46.39;	author henning;	state Exp;
branches;
next	1.293;
commitid	n6DBg2FVns7PdepI;

1.293
date	2015.04.29.09.58.16;	author henning;	state Exp;
branches;
next	1.292;
commitid	4ecfLcgizo5sIt85;

1.292
date	2015.03.17.19.11.55;	author otto;	state Exp;
branches;
next	1.291;
commitid	oNqR1RmDFreo04UI;

1.291
date	2015.01.20.18.22.20;	author deraadt;	state Exp;
branches;
next	1.290;
commitid	F55lwc3gS4GN2mLs;

1.290
date	2015.01.16.20.21.40;	author miod;	state Exp;
branches;
next	1.289;
commitid	el44sqtAdSNIpJ76;

1.289
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.288;
commitid	Uu5nFG3wCl0LACBb;

1.288
date	2014.10.11.03.08.26;	author doug;	state Exp;
branches;
next	1.287;
commitid	qDKhzVecWPnxxxjZ;

1.287
date	2014.07.10.13.31.23;	author florian;	state Exp;
branches;
next	1.286;
commitid	R66OgMHvjjOX2vbZ;

1.286
date	2014.05.02.23.17.29;	author chl;	state Exp;
branches;
next	1.285;

1.285
date	2014.05.02.12.43.10;	author krw;	state Exp;
branches;
next	1.284;

1.284
date	2014.04.21.08.19.38;	author krw;	state Exp;
branches;
next	1.283;

1.283
date	2014.04.03.16.15.38;	author otto;	state Exp;
branches;
next	1.282;

1.282
date	2014.02.22.13.27.46;	author krw;	state Exp;
branches;
next	1.281;

1.281
date	2014.02.16.00.04.32;	author krw;	state Exp;
branches;
next	1.280;

1.280
date	2014.02.15.02.39.38;	author krw;	state Exp;
branches;
next	1.279;

1.279
date	2014.02.15.00.10.17;	author krw;	state Exp;
branches;
next	1.278;

1.278
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.277;

1.277
date	2013.11.12.04.59.02;	author deraadt;	state Exp;
branches;
next	1.276;

1.276
date	2013.10.21.07.59.34;	author otto;	state Exp;
branches;
next	1.275;

1.275
date	2013.10.18.13.36.04;	author otto;	state Exp;
branches;
next	1.274;

1.274
date	2013.10.15.20.13.02;	author bluhm;	state Exp;
branches;
next	1.273;

1.273
date	2013.10.03.18.50.30;	author krw;	state Exp;
branches;
next	1.272;

1.272
date	2013.09.10.15.17.46;	author krw;	state Exp;
branches;
next	1.271;

1.271
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.270;

1.270
date	2013.04.19.14.10.20;	author otto;	state Exp;
branches;
next	1.269;

1.269
date	2012.07.13.16.06.42;	author krw;	state Exp;
branches;
next	1.268;

1.268
date	2012.03.18.03.24.01;	author krw;	state Exp;
branches;
next	1.267;

1.267
date	2012.03.18.03.07.05;	author krw;	state Exp;
branches;
next	1.266;

1.266
date	2012.01.30.10.05.31;	author chl;	state Exp;
branches;
next	1.265;

1.265
date	2012.01.19.15.51.11;	author krw;	state Exp;
branches;
next	1.264;

1.264
date	2012.01.17.15.20.40;	author krw;	state Exp;
branches;
next	1.263;

1.263
date	2012.01.17.01.28.06;	author krw;	state Exp;
branches;
next	1.262;

1.262
date	2012.01.02.03.46.39;	author krw;	state Exp;
branches;
next	1.261;

1.261
date	2011.12.25.20.00.40;	author krw;	state Exp;
branches;
next	1.260;

1.260
date	2011.12.01.16.44.29;	author krw;	state Exp;
branches;
next	1.259;

1.259
date	2011.10.06.21.16.01;	author deraadt;	state Exp;
branches;
next	1.258;

1.258
date	2011.07.05.21.39.08;	author krw;	state Exp;
branches;
next	1.257;

1.257
date	2011.07.05.17.38.54;	author krw;	state Exp;
branches;
next	1.256;

1.256
date	2011.05.24.15.27.56;	author otto;	state Exp;
branches;
next	1.255;

1.255
date	2011.05.23.08.22.29;	author otto;	state Exp;
branches;
next	1.254;

1.254
date	2011.05.22.17.49.26;	author otto;	state Exp;
branches;
next	1.253;

1.253
date	2011.05.22.13.04.40;	author otto;	state Exp;
branches;
next	1.252;

1.252
date	2011.04.16.23.01.17;	author krw;	state Exp;
branches;
next	1.251;

1.251
date	2011.04.16.11.44.41;	author krw;	state Exp;
branches;
next	1.250;

1.250
date	2011.03.05.06.50.41;	author krw;	state Exp;
branches;
next	1.249;

1.249
date	2011.03.02.04.48.24;	author krw;	state Exp;
branches;
next	1.248;

1.248
date	2011.02.19.21.18.59;	author krw;	state Exp;
branches;
next	1.247;

1.247
date	2010.12.13.01.01.41;	author marco;	state Exp;
branches;
next	1.246;

1.246
date	2010.11.24.14.15.31;	author jsing;	state Exp;
branches;
next	1.245;

1.245
date	2010.09.23.13.54.21;	author jsing;	state Exp;
branches;
next	1.244;

1.244
date	2010.08.12.23.32.07;	author tedu;	state Exp;
branches;
next	1.243;

1.243
date	2010.08.10.23.35.08;	author krw;	state Exp;
branches;
next	1.242;

1.242
date	2010.08.09.17.31.45;	author deraadt;	state Exp;
branches;
next	1.241;

1.241
date	2010.07.27.00.49.42;	author krw;	state Exp;
branches;
next	1.240;

1.240
date	2010.06.30.21.11.20;	author halex;	state Exp;
branches;
next	1.239;

1.239
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.238;

1.238
date	2010.05.15.10.54.29;	author otto;	state Exp;
branches;
next	1.237;

1.237
date	2010.05.11.11.12.22;	author otto;	state Exp;
branches;
next	1.236;

1.236
date	2010.04.28.17.26.46;	author jsing;	state Exp;
branches;
next	1.235;

1.235
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.234;

1.234
date	2010.04.21.03.35.41;	author lum;	state Exp;
branches;
next	1.233;

1.233
date	2010.04.13.22.38.20;	author lum;	state Exp;
branches;
next	1.232;

1.232
date	2010.04.13.12.36.31;	author lum;	state Exp;
branches;
next	1.231;

1.231
date	2010.04.04.14.12.12;	author otto;	state Exp;
branches;
next	1.230;

1.230
date	2010.03.29.13.24.59;	author otto;	state Exp;
branches;
next	1.229;

1.229
date	2010.03.25.14.35.58;	author sthen;	state Exp;
branches;
next	1.228;

1.228
date	2010.03.23.14.59.30;	author otto;	state Exp;
branches;
next	1.227;

1.227
date	2010.03.23.14.32.34;	author otto;	state Exp;
branches;
next	1.226;

1.226
date	2010.03.20.16.53.20;	author otto;	state Exp;
branches;
next	1.225;

1.225
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.224;

1.224
date	2009.11.12.16.21.03;	author deraadt;	state Exp;
branches;
next	1.223;

1.223
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.222;

1.222
date	2009.10.01.16.28.33;	author deraadt;	state Exp;
branches;
next	1.221;

1.221
date	2009.08.12.20.01.54;	author deraadt;	state Exp;
branches;
next	1.220;

1.220
date	2009.08.07.00.26.34;	author martynas;	state Exp;
branches;
next	1.219;

1.219
date	2009.06.26.14.25.36;	author deraadt;	state Exp;
branches;
next	1.218;

1.218
date	2009.06.11.02.59.08;	author krw;	state Exp;
branches;
next	1.217;

1.217
date	2009.06.04.21.13.03;	author deraadt;	state Exp;
branches;
next	1.216;

1.216
date	2009.06.02.21.38.36;	author chl;	state Exp;
branches;
next	1.215;

1.215
date	2009.06.02.16.23.45;	author krw;	state Exp;
branches;
next	1.214;

1.214
date	2009.05.31.19.39.45;	author krw;	state Exp;
branches;
next	1.213;

1.213
date	2009.05.29.01.49.56;	author krw;	state Exp;
branches;
next	1.212;

1.212
date	2009.05.17.02.49.45;	author krw;	state Exp;
branches;
next	1.211;

1.211
date	2009.05.17.01.17.12;	author krw;	state Exp;
branches;
next	1.210;

1.210
date	2009.05.17.01.06.56;	author krw;	state Exp;
branches;
next	1.209;

1.209
date	2009.05.13.17.02.46;	author deraadt;	state Exp;
branches;
next	1.208;

1.208
date	2009.05.13.01.31.58;	author krw;	state Exp;
branches;
next	1.207;

1.207
date	2009.05.12.00.54.48;	author krw;	state Exp;
branches;
next	1.206;

1.206
date	2009.05.11.23.15.42;	author krw;	state Exp;
branches;
next	1.205;

1.205
date	2009.05.11.23.09.44;	author deraadt;	state Exp;
branches;
next	1.204;

1.204
date	2009.05.11.23.09.28;	author deraadt;	state Exp;
branches;
next	1.203;

1.203
date	2009.05.03.22.01.46;	author krw;	state Exp;
branches;
next	1.202;

1.202
date	2009.05.03.16.49.16;	author deraadt;	state Exp;
branches;
next	1.201;

1.201
date	2009.04.30.06.56.34;	author deraadt;	state Exp;
branches;
next	1.200;

1.200
date	2009.04.29.22.57.05;	author deraadt;	state Exp;
branches;
next	1.199;

1.199
date	2009.04.29.15.11.20;	author otto;	state Exp;
branches;
next	1.198;

1.198
date	2009.04.26.20.25.09;	author deraadt;	state Exp;
branches;
next	1.197;

1.197
date	2009.04.26.20.05.30;	author deraadt;	state Exp;
branches;
next	1.196;

1.196
date	2009.04.26.19.49.50;	author otto;	state Exp;
branches;
next	1.195;

1.195
date	2009.04.26.01.23.40;	author krw;	state Exp;
branches;
next	1.194;

1.194
date	2009.04.23.00.00.06;	author krw;	state Exp;
branches;
next	1.193;

1.193
date	2009.04.20.17.40.43;	author deraadt;	state Exp;
branches;
next	1.192;

1.192
date	2009.04.18.00.15.46;	author sthen;	state Exp;
branches;
next	1.191;

1.191
date	2009.04.12.01.01.24;	author krw;	state Exp;
branches;
next	1.190;

1.190
date	2009.04.11.23.57.56;	author krw;	state Exp;
branches;
next	1.189;

1.189
date	2009.04.11.15.17.11;	author krw;	state Exp;
branches;
next	1.188;

1.188
date	2009.04.10.21.16.51;	author deraadt;	state Exp;
branches;
next	1.187;

1.187
date	2009.04.10.20.54.08;	author krw;	state Exp;
branches;
next	1.186;

1.186
date	2009.04.04.16.04.44;	author krw;	state Exp;
branches;
next	1.185;

1.185
date	2009.04.03.23.18.11;	author krw;	state Exp;
branches;
next	1.184;

1.184
date	2009.03.30.10.51.37;	author krw;	state Exp;
branches;
next	1.183;

1.183
date	2009.03.30.00.39.26;	author deraadt;	state Exp;
branches;
next	1.182;

1.182
date	2009.03.29.05.37.13;	author deraadt;	state Exp;
branches;
next	1.181;

1.181
date	2009.03.28.17.50.05;	author deraadt;	state Exp;
branches;
next	1.180;

1.180
date	2009.03.28.16.27.24;	author krw;	state Exp;
branches;
next	1.179;

1.179
date	2009.03.28.16.18.50;	author krw;	state Exp;
branches;
next	1.178;

1.178
date	2009.03.28.07.08.32;	author otto;	state Exp;
branches;
next	1.177;

1.177
date	2009.03.22.19.58.43;	author deraadt;	state Exp;
branches;
next	1.176;

1.176
date	2009.03.22.19.01.32;	author krw;	state Exp;
branches;
next	1.175;

1.175
date	2009.03.07.02.12.00;	author krw;	state Exp;
branches;
next	1.174;

1.174
date	2009.01.11.19.44.57;	author miod;	state Exp;
branches;
next	1.173;

1.173
date	2008.12.07.18.31.29;	author cnst;	state Exp;
branches;
next	1.172;

1.172
date	2008.12.07.01.11.50;	author cnst;	state Exp;
branches;
next	1.171;

1.171
date	2008.09.03.11.13.54;	author jsg;	state Exp;
branches;
next	1.170;

1.170
date	2008.08.10.11.22.40;	author sobrado;	state Exp;
branches;
next	1.169;

1.169
date	2008.08.10.02.03.06;	author krw;	state Exp;
branches;
next	1.168;

1.168
date	2008.06.25.18.31.07;	author otto;	state Exp;
branches;
next	1.167;

1.167
date	2008.04.13.15.54.59;	author krw;	state Exp;
branches;
next	1.166;

1.166
date	2008.01.26.15.37.59;	author krw;	state Exp;
branches;
next	1.165;

1.165
date	2008.01.25.16.52.34;	author krw;	state Exp;
branches;
next	1.164;

1.164
date	2008.01.22.01.47.33;	author krw;	state Exp;
branches;
next	1.163;

1.163
date	2008.01.22.01.31.27;	author krw;	state Exp;
branches;
next	1.162;

1.162
date	2008.01.22.01.12.50;	author krw;	state Exp;
branches;
next	1.161;

1.161
date	2008.01.22.00.19.18;	author krw;	state Exp;
branches;
next	1.160;

1.160
date	2008.01.22.00.06.25;	author krw;	state Exp;
branches;
next	1.159;

1.159
date	2008.01.16.23.00.21;	author chl;	state Exp;
branches;
next	1.158;

1.158
date	2008.01.12.20.06.57;	author krw;	state Exp;
branches;
next	1.157;

1.157
date	2008.01.12.19.39.40;	author krw;	state Exp;
branches;
next	1.156;

1.156
date	2008.01.12.19.20.29;	author krw;	state Exp;
branches;
next	1.155;

1.155
date	2008.01.12.18.57.06;	author krw;	state Exp;
branches;
next	1.154;

1.154
date	2008.01.12.18.23.32;	author krw;	state Exp;
branches;
next	1.153;

1.153
date	2008.01.12.18.15.22;	author krw;	state Exp;
branches;
next	1.152;

1.152
date	2008.01.11.22.46.06;	author krw;	state Exp;
branches;
next	1.151;

1.151
date	2008.01.11.20.14.34;	author krw;	state Exp;
branches;
next	1.150;

1.150
date	2008.01.10.04.00.09;	author krw;	state Exp;
branches;
next	1.149;

1.149
date	2008.01.08.23.46.54;	author krw;	state Exp;
branches;
next	1.148;

1.148
date	2008.01.08.13.12.26;	author krw;	state Exp;
branches;
next	1.147;

1.147
date	2008.01.08.13.07.10;	author krw;	state Exp;
branches;
next	1.146;

1.146
date	2008.01.07.23.10.18;	author krw;	state Exp;
branches;
next	1.145;

1.145
date	2008.01.07.19.24.33;	author krw;	state Exp;
branches;
next	1.144;

1.144
date	2008.01.07.16.51.35;	author krw;	state Exp;
branches;
next	1.143;

1.143
date	2008.01.06.22.28.13;	author krw;	state Exp;
branches;
next	1.142;

1.142
date	2008.01.06.21.25.38;	author krw;	state Exp;
branches;
next	1.141;

1.141
date	2008.01.06.17.27.11;	author krw;	state Exp;
branches;
next	1.140;

1.140
date	2008.01.06.16.44.54;	author krw;	state Exp;
branches;
next	1.139;

1.139
date	2008.01.03.02.10.05;	author sthen;	state Exp;
branches;
next	1.138;

1.138
date	2008.01.01.18.20.02;	author krw;	state Exp;
branches;
next	1.137;

1.137
date	2008.01.01.17.15.03;	author krw;	state Exp;
branches;
next	1.136;

1.136
date	2008.01.01.16.22.27;	author krw;	state Exp;
branches;
next	1.135;

1.135
date	2008.01.01.14.58.42;	author krw;	state Exp;
branches;
next	1.134;

1.134
date	2007.12.31.17.51.57;	author krw;	state Exp;
branches;
next	1.133;

1.133
date	2007.12.30.22.42.19;	author krw;	state Exp;
branches;
next	1.132;

1.132
date	2007.12.30.21.30.53;	author krw;	state Exp;
branches;
next	1.131;

1.131
date	2007.12.30.17.31.20;	author krw;	state Exp;
branches;
next	1.130;

1.130
date	2007.12.30.16.51.55;	author krw;	state Exp;
branches;
next	1.129;

1.129
date	2007.12.30.01.52.07;	author krw;	state Exp;
branches;
next	1.128;

1.128
date	2007.12.25.17.26.49;	author krw;	state Exp;
branches;
next	1.127;

1.127
date	2007.12.24.14.46.54;	author krw;	state Exp;
branches;
next	1.126;

1.126
date	2007.12.23.16.15.21;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2007.09.02.15.19.23;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2007.07.24.15.11.53;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2007.06.20.19.16.53;	author otto;	state Exp;
branches;
next	1.122;

1.122
date	2007.06.17.00.32.21;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2007.06.08.20.21.13;	author millert;	state Exp;
branches;
next	1.120;

1.120
date	2007.06.08.19.08.35;	author otto;	state Exp;
branches;
next	1.119;

1.119
date	2007.06.08.18.42.17;	author otto;	state Exp;
branches;
next	1.118;

1.118
date	2007.06.08.13.52.51;	author millert;	state Exp;
branches;
next	1.117;

1.117
date	2007.06.07.21.47.16;	author millert;	state Exp;
branches;
next	1.116;

1.116
date	2007.06.06.21.08.55;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2007.06.04.20.23.32;	author otto;	state Exp;
branches;
next	1.114;

1.114
date	2007.06.01.21.51.15;	author todd;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.112;

1.112
date	2007.04.29.18.31.35;	author otto;	state Exp;
branches;
next	1.111;

1.111
date	2007.04.26.23.20.41;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2007.04.26.22.42.11;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2007.03.18.20.00.02;	author otto;	state Exp;
branches;
next	1.108;

1.108
date	2007.03.13.19.25.31;	author otto;	state Exp;
branches;
next	1.107;

1.107
date	2007.03.02.02.29.13;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2007.02.22.02.26.35;	author krw;	state Exp;
branches;
next	1.105;

1.105
date	2006.10.14.18.26.55;	author krw;	state Exp;
branches;
next	1.104;

1.104
date	2006.07.01.16.50.33;	author krw;	state Exp;
branches;
next	1.103;

1.103
date	2006.04.26.17.09.34;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2006.04.14.16.38.42;	author pedro;	state Exp;
branches;
next	1.101;

1.101
date	2005.12.05.21.30.40;	author miod;	state Exp;
branches;
next	1.100;

1.100
date	2005.11.16.03.12.12;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2005.01.07.21.58.14;	author otto;	state Exp;
branches;
next	1.98;

1.98
date	2004.12.11.07.28.05;	author otto;	state Exp;
branches;
next	1.97;

1.97
date	2004.11.06.18.57.59;	author otto;	state Exp;
branches;
next	1.96;

1.96
date	2004.10.04.15.09.41;	author otto;	state Exp;
branches;
next	1.95;

1.95
date	2004.09.28.17.57.46;	author otto;	state Exp;
branches;
next	1.94;

1.94
date	2004.08.03.09.30.12;	author otto;	state Exp;
branches;
next	1.93;

1.93
date	2003.12.29.19.51.34;	author millert;	state Exp;
branches;
next	1.92;

1.92
date	2003.12.20.09.29.27;	author jmc;	state Exp;
branches;
next	1.91;

1.91
date	2003.09.24.20.40.19;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2003.08.29.00.17.09;	author tedu;	state Exp;
branches;
next	1.89;

1.89
date	2003.08.28.20.19.54;	author tedu;	state Exp;
branches;
next	1.88;

1.88
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2003.07.16.18.03.44;	author tedu;	state Exp;
branches;
next	1.86;

1.86
date	2003.06.17.21.56.24;	author millert;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2003.06.03.01.52.40;	author millert;	state Exp;
branches;
next	1.83;

1.83
date	2003.04.05.23.19.44;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2003.02.13.00.10.39;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.80;

1.80
date	2002.05.22.08.21.01;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.78;

1.78
date	2002.01.24.23.01.19;	author millert;	state Exp;
branches;
next	1.77;

1.77
date	2001.07.07.18.26.10;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2001.05.19.05.10.46;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2001.03.12.23.03.59;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2000.10.22.23.59.40;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2000.08.13.22.07.14;	author millert;	state Exp;
branches;
next	1.72;

1.72
date	2000.06.04.18.34.41;	author millert;	state Exp;
branches;
next	1.71;

1.71
date	2000.06.04.18.19.45;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2000.05.05.19.10.35;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2000.04.04.16.29.27;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2000.03.23.01.24.28;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2000.02.21.14.28.02;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	99.07.14.23.16.26;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	99.06.10.22.37.54;	author pjanzen;	state Exp;
branches;
next	1.64;

1.64
date	99.06.06.18.42.29;	author aaron;	state Exp;
branches;
next	1.63;

1.63
date	99.04.07.22.57.26;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	99.04.07.08.17.21;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	99.04.07.07.50.59;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	99.04.01.21.43.48;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	99.04.01.21.10.13;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	99.04.01.04.14.21;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	99.03.23.05.18.50;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	99.03.21.22.11.42;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	99.03.21.19.31.10;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	99.03.21.17.22.33;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	99.03.18.04.36.22;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	99.03.18.01.59.20;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	99.03.16.21.26.04;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	99.03.16.04.47.16;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	99.03.16.04.27.20;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	99.03.13.19.42.40;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	99.03.13.19.07.37;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	99.03.01.01.50.45;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	98.10.11.20.49.17;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	98.08.07.00.06.00;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	98.08.06.18.07.40;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	98.07.29.18.47.12;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	98.07.26.17.40.38;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	98.07.26.17.36.09;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	98.07.26.17.01.45;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	98.07.23.05.21.23;	author csapuntz;	state Exp;
branches;
next	1.37;

1.37
date	98.06.21.22.13.52;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	98.05.07.06.27.34;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	98.05.07.06.22.20;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	98.04.14.20.02.48;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	98.04.11.10.14.19;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	98.04.08.02.42.37;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	98.02.28.02.52.08;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	98.02.19.20.43.37;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.01.11.18.21.17;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	98.01.05.06.45.50;	author art;	state Exp;
branches;
next	1.27;

1.27
date	98.01.05.06.20.48;	author art;	state Exp;
branches;
next	1.26;

1.26
date	97.11.05.02.48.43;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.11.04.19.46.39;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	97.10.24.02.49.55;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.10.24.02.44.07;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	97.10.24.00.08.24;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.10.20.07.09.43;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.10.20.06.26.53;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.10.18.12.07.57;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.10.17.20.03.46;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.10.17.19.50.43;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.10.17.04.37.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.10.16.10.40.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.10.16.10.40.10;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.10.16.02.41.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.10.15.22.49.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.10.15.19.39.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.10.07.04.26.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.03.49.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.10.03.23.01.52;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.10.02.16.38.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.10.02.06.56.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.10.02.05.58.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.10.02.01.16.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.10.02.00.51.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.10.02.00.02.55;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.09.30.17.54.17;	author millert;	state Exp;
branches;
next	;


desc
@@


1.308
log
@don't be silent on auto-allocation failure in write mode. ok millert@@ krw@@
@
text
@/*	$OpenBSD: editor.c,v 1.307 2017/05/19 12:54:30 otto Exp $	*/

/*
 * Copyright (c) 1997-2000 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE */
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/sysctl.h>
#define	DKTYPENAMES
#include <sys/disklabel.h>

#include <ufs/ffs/fs.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <string.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>

#include "extern.h"
#include "pathnames.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

/* flags for getuint64() */
#define	DO_CONVERSIONS	0x00000001
#define	DO_ROUNDING	0x00000002

/* structure to describe a portion of a disk */
struct diskchunk {
	u_int64_t start;
	u_int64_t stop;
};

/* used when sorting mountpoints in mpsave() */
struct mountinfo {
	char *mountpoint;
	int partno;
};

/* used when allocating all space according to recommendations */

struct space_allocation {
	u_int64_t	minsz;	/* starts as blocks, xlated to sectors. */
	u_int64_t	maxsz;	/* starts as blocks, xlated to sectors. */
	int		rate;	/* % of extra space to use */
	char	       *mp;
};

/* entries for swap and var are changed by editor_allocspace() */
struct space_allocation alloc_big[] = {
	{  MEG(150),         GIG(1),   5, "/"		},
	{   MEG(80),       MEG(256),  10, "swap"	},
	{  MEG(120),         GIG(4),   8, "/tmp"	},
	{   MEG(80),         GIG(4),  13, "/var"	},
	{  MEG(900),         GIG(2),   5, "/usr"	},
	{  MEG(512),         GIG(1),   3, "/usr/X11R6"	},
	{ MEG(1200),        GIG(10),  15, "/usr/local"	},
	{    GIG(1),         GIG(2),   2, "/usr/src"	},
	{    GIG(3),         GIG(6),   4, "/usr/obj"	},
	{    GIG(1),       GIG(300),  35, "/home"	}
	/* Anything beyond this leave for the user to decide */
};

struct space_allocation alloc_medium[] = {
	{  MEG(800),         GIG(2),   5, "/"		},
	{   MEG(80),       MEG(256),  10, "swap"	},
	{  MEG(900),         GIG(3),  78, "/usr"	},
	{  MEG(256),         GIG(2),   7, "/home"	}
};

struct space_allocation alloc_small[] = {
	{  MEG(700),         GIG(4),  95, "/"		},
	{    MEG(1),       MEG(256),   5, "swap"	}
};

struct space_allocation alloc_stupid[] = {
	{    MEG(1),      MEG(2048), 100, "/"		}
};

#ifndef nitems
#define nitems(_a)	(sizeof((_a)) / sizeof((_a)[0]))
#endif

struct alloc_table {
	struct space_allocation *table;
	int sz;
};

struct alloc_table alloc_table_default[] = {
	{ alloc_big,	nitems(alloc_big) },
	{ alloc_medium,	nitems(alloc_medium) },
	{ alloc_small,	nitems(alloc_small) },
	{ alloc_stupid,	nitems(alloc_stupid) }
};
struct alloc_table *alloc_table = alloc_table_default;
int alloc_table_nitems = 4;

void	edit_parms(struct disklabel *);
void	editor_resize(struct disklabel *, char *);
void	editor_add(struct disklabel *, char *);
void	editor_change(struct disklabel *, char *);
u_int64_t editor_countfree(struct disklabel *);
void	editor_delete(struct disklabel *, char *);
void	editor_help(void);
void	editor_modify(struct disklabel *, char *);
void	editor_name(struct disklabel *, char *);
char	*getstring(const char *, const char *, const char *);
u_int64_t getuint64(struct disklabel *, char *, char *, u_int64_t, u_int64_t,
	    u_int64_t, int);
int	has_overlap(struct disklabel *);
int	partition_cmp(const void *, const void *);
struct partition **sort_partitions(struct disklabel *);
void	getdisktype(struct disklabel *, char *, char *);
void	find_bounds(struct disklabel *);
void	set_bounds(struct disklabel *);
void	set_duid(struct disklabel *);
struct diskchunk *free_chunks(struct disklabel *);
int	micmp(const void *, const void *);
int	mpequal(char **, char **);
int	get_bsize(struct disklabel *, int);
int	get_fsize(struct disklabel *, int);
int	get_cpg(struct disklabel *, int);
int	get_fstype(struct disklabel *, int);
int	get_mp(struct disklabel *, int);
int	get_offset(struct disklabel *, int);
int	get_size(struct disklabel *, int);
void	get_geometry(int, struct disklabel **);
void	set_geometry(struct disklabel *, struct disklabel *, struct disklabel *,
	    char *);
void	zero_partitions(struct disklabel *);
u_int64_t max_partition_size(struct disklabel *, int);
void	display_edit(struct disklabel *, char, u_int64_t);
void	psize(u_int64_t sz, char unit, struct disklabel *lp);
char	*get_token(char **, size_t *);
int	apply_unit(double, u_char, u_int64_t *);
int	parse_sizespec(const char *, double *, char **);
int	parse_sizerange(char *, u_int64_t *, u_int64_t *);
int	parse_pct(char *, int *);

static u_int64_t starting_sector;
static u_int64_t ending_sector;
static int expert;
static int overlap;

/*
 * Simple partition editor.
 */
int
editor(int f)
{
	struct disklabel origlabel, lastlabel, tmplabel, newlab = lab;
	struct disklabel *disk_geop = NULL;
	struct partition *pp;
	FILE *fp;
	char buf[BUFSIZ], *cmd, *arg;
	char **omountpoints = NULL;
	char **origmountpoints = NULL, **tmpmountpoints = NULL;
	int i, error = 0;

	/* Alloc and init mount point info */
	if (!(omountpoints = calloc(MAXPARTITIONS, sizeof(char *))) ||
	    !(origmountpoints = calloc(MAXPARTITIONS, sizeof(char *))) ||
	    !(tmpmountpoints = calloc(MAXPARTITIONS, sizeof(char *))))
		errx(4, "out of memory");

	/* Don't allow disk type of "unknown" */
	getdisktype(&newlab, "You need to specify a type for this disk.",
	    specname);

	/* Get the on-disk geometries if possible */
	get_geometry(f, &disk_geop);

	/* How big is the OpenBSD portion of the disk?  */
	find_bounds(&newlab);

	/* Make sure there is no partition overlap. */
	if (has_overlap(&newlab))
		errx(1, "can't run when there is partition overlap.");

	/* If we don't have a 'c' partition, create one. */
	pp = &newlab.d_partitions[RAW_PART];
	if (newlab.d_npartitions < 3 || DL_GETPSIZE(pp) == 0) {
		puts("No 'c' partition found, adding one that spans the disk.");
		if (newlab.d_npartitions < 3)
			newlab.d_npartitions = 3;
		DL_SETPOFFSET(pp, 0);
		DL_SETPSIZE(pp, DL_GETDSIZE(&newlab));
		pp->p_fstype = FS_UNUSED;
		pp->p_fragblock = pp->p_cpg = 0;
	}

#ifdef SUN_CYLCHECK
	if ((newlab.d_flags & D_VENDOR) && !quiet) {
		puts("This platform requires that partition offsets/sizes "
		    "be on cylinder boundaries.\n"
		    "Partition offsets/sizes will be rounded to the "
		    "nearest cylinder automatically.");
	}
#endif

	/* Set d_bbsize and d_sbsize as necessary */
	if (newlab.d_bbsize == 0)
		newlab.d_bbsize = BBSIZE;
	if (newlab.d_sbsize == 0)
		newlab.d_sbsize = SBSIZE;

	/* Save the (U|u)ndo labels and mountpoints. */
	mpcopy(origmountpoints, mountpoints);
	origlabel = newlab;
	lastlabel = newlab;

	puts("Label editor (enter '?' for help at any prompt)");
	for (;;) {
		fputs("> ", stdout);
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			putchar('\n');
			buf[0] = 'q';
			buf[1] = '\0';
		}
		if ((cmd = strtok(buf, " \t\r\n")) == NULL)
			continue;
		arg = strtok(NULL, " \t\r\n");

		if ((*cmd != 'u') && (*cmd != 'U')) {
			/*
			 * Save undo info in case the command tries to make
			 * changes but decides not to.
			 */
			tmplabel = lastlabel;
			lastlabel = newlab;
			mpcopy(tmpmountpoints, omountpoints);
			mpcopy(omountpoints, mountpoints);
		}

		switch (*cmd) {
		case '?':
		case 'h':
			editor_help();
			break;

		case 'A':
			if (ioctl(f, DIOCGPDINFO, &newlab) == 0) {
				aflag = 1;
				++quiet;
				editor_allocspace(&newlab);
				--quiet;
			} else
				newlab = lastlabel;
			break;
		case 'a':
			editor_add(&newlab, arg);
			break;

		case 'b':
			set_bounds(&newlab);
			break;

		case 'c':
			editor_change(&newlab, arg);
			break;

		case 'D':
			if (ioctl(f, DIOCGPDINFO, &newlab) == 0) {
				dflag = 1;
				for (i=0; i<MAXPARTITIONS; i++) {
					free(mountpoints[i]);
					mountpoints[i] = NULL;
				}
			} else
				warn("unable to get default partition table");
			break;

		case 'd':
			editor_delete(&newlab, arg);
			break;

		case 'e':
			edit_parms(&newlab);
			break;

		case 'g':
			set_geometry(&newlab, disk_geop, &lab, arg);
			break;

		case 'i':
			set_duid(&newlab);
			break;

		case 'm':
			editor_modify(&newlab, arg);
			break;

		case 'n':
			if (!fstabfile) {
				fputs("This option is not valid when run "
				    "without the -f flag.\n", stderr);
				break;
			}
			editor_name(&newlab, arg);
			break;

		case 'p':
			display_edit(&newlab, arg ? *arg : 0,
			    editor_countfree(&newlab));
			break;

		case 'l':
			display(stdout, &newlab, arg ? *arg : 0, 0);
			break;

		case 'M': {
			sig_t opipe = signal(SIGPIPE, SIG_IGN);
			char *pager, *comm = NULL;
			extern const u_char manpage[];
			extern const int manpage_sz;

			if ((pager = getenv("PAGER")) == NULL || *pager == '\0')
				pager = _PATH_LESS;

			if (asprintf(&comm, "gunzip -qc|%s", pager) != -1 &&
			    (fp = popen(comm, "w")) != NULL) {
				(void) fwrite(manpage, manpage_sz, 1, fp);
				pclose(fp);
			} else
				warn("unable to execute %s", pager);

			free(comm);
			(void)signal(SIGPIPE, opipe);
			break;
		}

		case 'q':
			if (donothing) {
				puts("In no change mode, not writing label.");
				goto done;
			}

                        /*
			 * If we haven't changed the original label, and it
			 * wasn't a default label or an auto-allocated label,
			 * there is no need to do anything before exiting. Note
			 * that 'w' will reset dflag and aflag to allow 'q' to
			 * exit without further questions.
			 */
			if (!dflag && !aflag &&
			    memcmp(&lab, &newlab, sizeof(newlab)) == 0) {
				puts("No label changes.");
				/* Save mountpoint info. */
				mpsave(&newlab);
				goto done;
			}
			do {
				arg = getstring("Write new label?",
				    "Write the modified label to disk?",
				    "y");
			} while (arg && tolower((unsigned char)*arg) != 'y' &&
			    tolower((unsigned char)*arg) != 'n');
			if (arg && tolower((unsigned char)*arg) == 'y') {
				if (writelabel(f, &newlab) == 0) {
					newlab = lab; /* lab now has UID info */
					goto done;
				}
				warnx("unable to write label");
			}
			error = 1;
			goto done;
			/* NOTREACHED */
			break;

		case 'R':
			if (aflag && !overlap)
				editor_resize(&newlab, arg);
			else
				fputs("Resize only implemented for auto "
				    "allocated labels\n", stderr);
			break;

		case 'r': {
			struct diskchunk *chunks;
			int i;
			/* Display free space. */
			chunks = free_chunks(&newlab);
			for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0;
			    i++)
				fprintf(stderr, "Free sectors: %16llu - %16llu "
				    "(%16llu)\n",
				    chunks[i].start, chunks[i].stop - 1,
				    chunks[i].stop - chunks[i].start);
			fprintf(stderr, "Total free sectors: %llu.\n",
			    editor_countfree(&newlab));
			break;
		}

		case 's':
			if (arg == NULL) {
				arg = getstring("Filename",
				    "Name of the file to save label into.",
				    NULL);
				if (arg == NULL || *arg == '\0')
					break;
			}
			if ((fp = fopen(arg, "w")) == NULL) {
				warn("cannot open %s", arg);
			} else {
				display(fp, &newlab, 0, 1);
				(void)fclose(fp);
			}
			break;

		case 'U':
			/*
			 * If we allow 'U' repeatedly, information would be
			 * lost. This way multiple 'U's followed by 'u' will
			 * undo the 'U's.
			 */
			if (memcmp(&newlab, &origlabel, sizeof(newlab)) ||
			    !mpequal(mountpoints, origmountpoints)) {
				tmplabel = newlab;
				newlab = origlabel;
				lastlabel = tmplabel;
				mpcopy(tmpmountpoints, mountpoints);
				mpcopy(mountpoints, origmountpoints);
				mpcopy(omountpoints, tmpmountpoints);
			}
			puts("Original label and mount points restored.");
			break;

		case 'u':
			tmplabel = newlab;
			newlab = lastlabel;
			lastlabel = tmplabel;
			mpcopy(tmpmountpoints, mountpoints);
			mpcopy(mountpoints, omountpoints);
			mpcopy(omountpoints, tmpmountpoints);
			puts("Last change undone.");
			break;

		case 'w':
			if (donothing)  {
				puts("In no change mode, not writing label.");
				break;
			}

			/* Write label to disk. */
			if (writelabel(f, &newlab) != 0)
				warnx("unable to write label");
			else {
				dflag = aflag = 0;
				newlab = lab; /* lab now has UID info */
			}
			break;

		case 'X':
			expert = !expert;
			printf("%s expert mode\n", expert ? "Entering" :
			    "Exiting");
			break;

		case 'x':
			goto done;
			break;

		case 'z':
			zero_partitions(&newlab);
			break;

		case '\n':
			break;

		default:
			printf("Unknown option: %c ('?' for help)\n", *cmd);
			break;
		}

		/*
		 * If no changes were made to label or mountpoints, then
		 * restore undo info.
		 */
		if (memcmp(&newlab, &lastlabel, sizeof(newlab)) == 0 &&
		    (mpequal(mountpoints, omountpoints))) {
			lastlabel = tmplabel;
			mpcopy(omountpoints, tmpmountpoints);
		}
	}
done:
	mpfree(omountpoints);
	mpfree(origmountpoints);
	mpfree(tmpmountpoints);
	free(disk_geop);
	return(error);
}

/*
 * Allocate all disk space according to standard recommendations for a
 * root disk.
 */
int
editor_allocspace(struct disklabel *lp_org)
{
	struct disklabel *lp, label;
	struct space_allocation *alloc;
	struct space_allocation *ap;
	struct partition *pp;
	struct diskchunk *chunks;
	u_int64_t chunkstart, chunksize, cylsecs, secs, totsecs, xtrasecs;
	char **partmp;
	int i, j, lastalloc, index = 0, fragsize, partno;
	extern int64_t physmem;

	/* How big is the OpenBSD portion of the disk?  */
	find_bounds(lp_org);

	overlap = 0;
	for (i = 0;  i < MAXPARTITIONS; i++) {
		u_int64_t psz, pstart, pend;

		pp = &lp_org->d_partitions[i];
		psz = DL_GETPSIZE(pp);
		pstart = DL_GETPOFFSET(pp);
		pend = pstart + psz;
		if (i != RAW_PART && psz != 0 &&
		    ((pstart >= starting_sector && pstart <= ending_sector) ||
		    (pend > starting_sector && pend < ending_sector))) {
			overlap = 1;
			break;
		}
	}

	cylsecs = lp_org->d_secpercyl;
again:
	lp = &label;
	for (i=0; i<MAXPARTITIONS; i++) {
		free(mountpoints[i]);
		mountpoints[i] = NULL;
	}
	memcpy(lp, lp_org, sizeof(struct disklabel));
	lp->d_npartitions = MAXPARTITIONS;
	lastalloc = alloc_table[index].sz;
	alloc = reallocarray(NULL, lastalloc, sizeof(struct space_allocation));
	if (alloc == NULL)
		errx(4, "out of memory");
	memcpy(alloc, alloc_table[index].table,
	    lastalloc * sizeof(struct space_allocation));

	/* bump max swap based on phys mem, little physmem gets 2x swap */
	if (index == 0 && alloc_table == alloc_table_default) {
		if (physmem / DEV_BSIZE < MEG(256))
			alloc[1].minsz = alloc[1].maxsz = 2 * (physmem / DEV_BSIZE);
		else
			alloc[1].maxsz += (physmem / DEV_BSIZE);
		/* bump max /var to make room for 2 crash dumps */
		alloc[3].maxsz += 2 * (physmem / DEV_BSIZE);
	}

	xtrasecs = totsecs = editor_countfree(lp);

	for (i = 0; i < lastalloc; i++) {
		alloc[i].minsz = DL_BLKTOSEC(lp, alloc[i].minsz);
		alloc[i].maxsz = DL_BLKTOSEC(lp, alloc[i].maxsz);
		if (xtrasecs > alloc[i].minsz)
			xtrasecs -= alloc[i].minsz;
		else
			xtrasecs = 0;
	}

	for (i = 0; i < lastalloc; i++) {
		/* Find next available partition. */
		for (j = 0;  j < MAXPARTITIONS; j++)
			if (DL_GETPSIZE(&lp->d_partitions[j]) == 0)
				break;
		if (j == MAXPARTITIONS) {
			/* It did not work out, try next strategy */
			free(alloc);
			if (++index < alloc_table_nitems)
				goto again;
			else
				return 1;
		}
		partno = j;
		pp = &lp->d_partitions[j];
		partmp = &mountpoints[j];
		ap = &alloc[i];

		/* Figure out the size of the partition. */
		if (i == lastalloc - 1) {
			if (totsecs > ap->maxsz)
				secs = ap->maxsz;
			else
				secs = totsecs;
#ifdef SUN_CYLCHECK
			goto cylinderalign;
#endif
		} else {
			secs = ap->minsz;
			if (xtrasecs > 0)
				secs += (xtrasecs / 100) * ap->rate;
			if (secs > ap->maxsz)
				secs = ap->maxsz;
#ifdef SUN_CYLCHECK
cylinderalign:
			secs = ((secs + cylsecs - 1) / cylsecs) * cylsecs;
#endif
			totsecs -= secs;
#ifdef SUN_CYLCHECK
			while (totsecs < 0) {
				secs -= cylsecs;
				totsecs += cylsecs;
			}
#endif
		}

		/* Find largest chunk of free space. */
		chunks = free_chunks(lp);
		chunkstart = 0;
		chunksize = 0;
		for (j = 0; chunks[j].start != 0 || chunks[j].stop != 0; j++)
			if ((chunks[j].stop - chunks[j].start) > chunksize) {
				chunkstart = chunks[j].start;
				chunksize = chunks[j].stop - chunks[j].start;
			}
#ifdef SUN_CYLCHECK
		if (lp->d_flags & D_VENDOR) {
			/* Align chunk to cylinder boundaries. */
			chunksize -= chunksize % cylsecs;
			chunkstart = ((chunkstart + cylsecs - 1) / cylsecs) *
			    cylsecs;
		}
#endif
		/* See if partition can fit into chunk. */
		if (secs > chunksize) {
			totsecs += secs - chunksize;
			secs = chunksize;
		}
		if (secs < ap->minsz) {
			/* It did not work out, try next strategy */
			free(alloc);
			if (++index < alloc_table_nitems)
				goto again;
			else
				return 1;
		}

		/* Everything seems ok so configure the partition. */
		DL_SETPSIZE(pp, secs);
		DL_SETPOFFSET(pp, chunkstart);
		fragsize = 2048;
		if (secs * lp->d_secsize > 128ULL * 1024 * 1024 * 1024)
			fragsize *= 2;
		if (secs * lp->d_secsize > 512ULL * 1024 * 1024 * 1024)
			fragsize *= 2;
		if (fragsize < lp->d_secsize)
			fragsize = lp->d_secsize;
		if (fragsize > MAXBSIZE / 8)
			fragsize = MAXBSIZE / 8;
		pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(fragsize, 8);
		pp->p_cpg = 1;
		if (ap->mp[0] != '/')
			pp->p_fstype = FS_SWAP;
		else {
			pp->p_fstype = FS_BSDFFS;
			get_bsize(lp, partno);
			free(*partmp);
			if ((*partmp = strdup(ap->mp)) == NULL)
				errx(4, "out of memory");
		}
	}

	free(alloc);
	memcpy(lp_org, lp, sizeof(struct disklabel));
	return 0;
}

/*
 * Resize a partition, moving all subsequent partitions
 */
void
editor_resize(struct disklabel *lp, char *p)
{
	struct disklabel label;
	struct partition *pp, *prev;
	u_int64_t secs, sz, off;
#ifdef SUN_CYLCHECK
	u_int64_t cylsecs;
#endif
	int partno, i;

	label = *lp;

	/* Change which partition? */
	if (p == NULL) {
		p = getstring("partition to resize",
		    "The letter of the partition to name, a - p.", NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	partno = p[0] - 'a';
        if (partno < 0 || partno == RAW_PART || partno >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c' "
		    "(excluding 'c').\n", 'a' + lp->d_npartitions - 1);
		return;
	}

	pp = &label.d_partitions[partno];
	sz = DL_GETPSIZE(pp);
	if (sz == 0) {
		fputs("No such partition\n", stderr);
		return;
	}
	if (pp->p_fstype != FS_BSDFFS && pp->p_fstype != FS_SWAP) {
		fputs("Cannot resize spoofed partition\n", stderr);
		return;
	}
	secs = getuint64(lp, "[+|-]new size (with unit)",
	    "new size or amount to grow (+) or shrink (-) partition including unit",
	    sz, editor_countfree(lp), 0, DO_CONVERSIONS);

	if (secs <= 0) {
		fputs("Command aborted\n", stderr);
		return;
	}

#ifdef SUN_CYLCHECK
	cylsecs = lp->d_secpercyl;
	if (secs > 0)
		secs = ((secs + cylsecs - 1) / cylsecs) * cylsecs;
	else
		secs = ((secs - cylsecs + 1) / cylsecs) * cylsecs;
#endif
	if (DL_GETPOFFSET(pp) + secs > ending_sector) {
		fputs("Amount too big\n", stderr);
		return;
	}

	DL_SETPSIZE(pp, secs);
	get_bsize(&label, partno);

	/*
	 * Pack partitions above the resized partition, leaving unused
	 * partions alone.
	 */
	prev = pp;
	for (i = partno + 1; i < MAXPARTITIONS; i++) {
		if (i == RAW_PART)
			continue;
		pp = &label.d_partitions[i];
		if (pp->p_fstype != FS_BSDFFS && pp->p_fstype != FS_SWAP)
			continue;
		sz = DL_GETPSIZE(pp);
		if (sz == 0)
			continue;

		off = DL_GETPOFFSET(prev) + DL_GETPSIZE(prev);

		if (off < ending_sector) {
			DL_SETPOFFSET(pp, off);
			if (off + DL_GETPSIZE(pp) > ending_sector) {
				DL_SETPSIZE(pp, ending_sector - off);
				fprintf(stderr,
				    "Partition %c shrunk to make room\n",
				    i + 'a');
			}
		} else {
			fputs("No room left for all partitions\n", stderr);
			return;
		}
		get_bsize(&label, i);
		prev = pp;
	}
	*lp = label;
}

/*
 * Add a new partition.
 */
void
editor_add(struct disklabel *lp, char *p)
{
	struct partition *pp;
	struct diskchunk *chunks;
	char buf[2];
	int i, partno, fragsize;
	u_int64_t freesectors, new_offset, new_size;

	freesectors = editor_countfree(lp);

	/* XXX - prompt user to steal space from another partition instead */
#ifdef SUN_CYLCHECK
	if ((lp->d_flags & D_VENDOR) && freesectors < lp->d_secpercyl) {
		fputs("No space left, you need to shrink a partition "
		    "(need at least one full cylinder)\n",
		    stderr);
		return;
	}
#endif
	if (freesectors == 0) {
		fputs("No space left, you need to shrink a partition\n",
		    stderr);
		return;
	}

	if (p == NULL) {
		/*
		 * Use the first unused partition that is not 'c' as the
		 * default partition in the prompt string.
		 */
		pp = &lp->d_partitions[0];
		buf[0] = buf[1] = '\0';
		for (partno = 0; partno < MAXPARTITIONS; partno++, pp++) {
			if (DL_GETPSIZE(pp) == 0 && partno != RAW_PART) {
				buf[0] = partno + 'a';
				p = &buf[0];
				break;
			}
		}
		p = getstring("partition",
		    "The letter of the new partition, a - p.", p);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	partno = p[0] - 'a';
	if (partno < 0 || partno == RAW_PART || partno >= MAXPARTITIONS) {
		fprintf(stderr, "Partition must be between 'a' and '%c' "
		    "(excluding 'c').\n", 'a' + MAXPARTITIONS - 1);
		return;
	}
	pp = &lp->d_partitions[partno];

	if (pp->p_fstype != FS_UNUSED && DL_GETPSIZE(pp) != 0) {
		fprintf(stderr, "Partition '%c' exists.  Delete it first.\n",
		    p[0]);
		return;
	}

	/*
	 * Increase d_npartitions if necessary. Ensure all new partitions are
	 * zero'ed to avoid inadvertent overlaps.
	 */
	for(; lp->d_npartitions <= partno; lp->d_npartitions++)
		memset(&lp->d_partitions[lp->d_npartitions], 0, sizeof(*pp));

	/* Make sure selected partition is zero'd too. */
	memset(pp, 0, sizeof(*pp));
	chunks = free_chunks(lp);

	/*
	 * Since we know there's free space, there must be at least one
	 * chunk. So find the largest chunk and assume we want to add the
	 * partition in that free space.
	 */
	new_size = new_offset = 0;
	for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0; i++) {
		if (chunks[i].stop - chunks[i].start > new_size) {
		    new_size = chunks[i].stop - chunks[i].start;
		    new_offset = chunks[i].start;
		}
	}
	DL_SETPSIZE(pp, new_size);
	DL_SETPOFFSET(pp, new_offset);
	pp->p_fstype = partno == 1 ? FS_SWAP : FS_BSDFFS;
	pp->p_cpg = 1;

	if (get_offset(lp, partno) == 0 &&
	    get_size(lp, partno) == 0) {
		fragsize = 2048;
		new_size = DL_GETPSIZE(pp) * lp->d_secsize;
		if (new_size > 128ULL * 1024 * 1024 * 1024)
			fragsize *= 2;
		if (new_size > 512ULL * 1024 * 1024 * 1024)
			fragsize *= 2;
		if (fragsize < lp->d_secsize)
			fragsize = lp->d_secsize;
		if (fragsize > MAXBSIZE / 8)
			fragsize = MAXBSIZE / 8;
		pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(fragsize, 8);
		if (get_fstype(lp, partno) == 0 &&
		    get_mp(lp, partno) == 0 &&
		    get_fsize(lp, partno) == 0  &&
		    get_bsize(lp, partno) == 0)
			return;
	}
	/* Bailed out at some point, so effectively delete the partition. */
	memset(pp, 0, sizeof(*pp));
}

/*
 * Set the mountpoint of an existing partition ('name').
 */
void
editor_name(struct disklabel *lp, char *p)
{
	struct partition *pp;
	int partno;

	/* Change which partition? */
	if (p == NULL) {
		p = getstring("partition to name",
		    "The letter of the partition to name, a - p.", NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	partno = p[0] - 'a';
	if (partno < 0 || partno == RAW_PART || partno >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c' "
		    "(excluding 'c').\n", 'a' + lp->d_npartitions - 1);
		return;
	}
	pp = &lp->d_partitions[partno];

	if (pp->p_fstype == FS_UNUSED && DL_GETPSIZE(pp) == 0) {
		fprintf(stderr, "Partition '%c' is not in use.\n", p[0]);
		return;
	}

	/* Not all fstypes can be named */
	if (pp->p_fstype == FS_UNUSED || pp->p_fstype == FS_SWAP ||
	    pp->p_fstype == FS_BOOT || pp->p_fstype == FS_OTHER ||
	    pp->p_fstype == FS_RAID) {
		fprintf(stderr, "You cannot name a filesystem of type %s.\n",
		    fstypenames[lp->d_partitions[partno].p_fstype]);
		return;
	}

	get_mp(lp, partno);
}

/*
 * Change an existing partition.
 */
void
editor_modify(struct disklabel *lp, char *p)
{
	struct partition origpart, *pp;
	int partno;

	/* Change which partition? */
	if (p == NULL) {
		p = getstring("partition to modify",
		    "The letter of the partition to modify, a - p.", NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	partno = p[0] - 'a';
	if (partno < 0 || partno == RAW_PART || partno >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c' "
		    "(excluding 'c').\n", 'a' + lp->d_npartitions - 1);
		return;
	}
	pp = &lp->d_partitions[partno];

	if (pp->p_fstype == FS_UNUSED && DL_GETPSIZE(pp) == 0) {
		fprintf(stderr, "Partition '%c' is not in use.\n", p[0]);
		return;
	}

	origpart = *pp;

	if (get_offset(lp, partno) == 0 &&
	    get_size(lp, partno) == 0   &&
	    get_fstype(lp, partno) == 0 &&
	    get_mp(lp, partno) == 0 &&
	    get_fsize(lp, partno) == 0  &&
	    get_bsize(lp, partno) == 0 &&
	    get_cpg(lp, partno) == 0)
		return;

	/* Bailed out at some point, so undo any changes. */
	*pp = origpart;
}

/*
 * Delete an existing partition.
 */
void
editor_delete(struct disklabel *lp, char *p)
{
	struct partition *pp;
	int partno;

	if (p == NULL) {
		p = getstring("partition to delete",
		    "The letter of the partition to delete, a - p, or '*'.",
		    NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	if (p[0] == '*') {
		zero_partitions(lp);
		return;
	}
	partno = p[0] - 'a';
	if (partno < 0 || partno == RAW_PART || partno >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c' "
		    "(excluding 'c').\n", 'a' + lp->d_npartitions - 1);
		return;
	}
	pp = &lp->d_partitions[partno];

	if (pp->p_fstype == FS_UNUSED && DL_GETPSIZE(pp) == 0) {
		fprintf(stderr, "Partition '%c' is not in use.\n", p[0]);
		return;
	}

	/* Really delete it (as opposed to just setting to "unused") */
	memset(pp, 0, sizeof(*pp));
	free(mountpoints[partno]);
	mountpoints[partno] = NULL;
}

/*
 * Change the size of an existing partition.
 */
void
editor_change(struct disklabel *lp, char *p)
{
	struct partition *pp;
	int partno;

	if (p == NULL) {
		p = getstring("partition to change size",
		    "The letter of the partition to change size, a - p.", NULL);
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	partno = p[0] - 'a';
	if (partno < 0 || partno == RAW_PART || partno >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c' "
		    "(excluding 'c').\n", 'a' + lp->d_npartitions - 1);
		return;
	}
	pp = &lp->d_partitions[partno];

	if (DL_GETPSIZE(pp) == 0) {
		fprintf(stderr, "Partition '%c' is not in use.\n", p[0]);
		return;
	}

	printf("Partition %c is currently %llu sectors in size, and can have "
	    "a maximum\nsize of %llu sectors.\n",
	    p[0], DL_GETPSIZE(pp), max_partition_size(lp, partno));

	/* Get new size */
	get_size(lp, partno);
}

/*
 * Sort the partitions based on starting offset.
 * This assumes there can be no overlap.
 */
int
partition_cmp(const void *e1, const void *e2)
{
	struct partition *p1 = *(struct partition **)e1;
	struct partition *p2 = *(struct partition **)e2;
	u_int64_t o1 = DL_GETPOFFSET(p1);
	u_int64_t o2 = DL_GETPOFFSET(p2);

	if (o1 < o2)
		return -1;
	else if (o1 > o2)
		return 1;
	else
		return 0;
}

char *
getstring(const char *prompt, const char *helpstring, const char *oval)
{
	static char buf[BUFSIZ];
	int n;

	buf[0] = '\0';
	do {
		printf("%s: [%s] ", prompt, oval ? oval : "");
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			buf[0] = '\0';
			if (feof(stdin)) {
				clearerr(stdin);
				putchar('\n');
				return(NULL);
			}
		}
		n = strlen(buf);
		if (n > 0 && buf[n-1] == '\n')
			buf[--n] = '\0';
		if (buf[0] == '?')
			puts(helpstring);
		else if (oval != NULL && buf[0] == '\0')
			strlcpy(buf, oval, sizeof(buf));
	} while (buf[0] == '?');

	return(&buf[0]);
}

/*
 * Returns ULLONG_MAX on error
 * Usually only called by helper functions.
 */
u_int64_t
getuint64(struct disklabel *lp, char *prompt, char *helpstring,
    u_int64_t oval, u_int64_t maxval, u_int64_t offset, int flags)
{
	char buf[BUFSIZ], *endptr, *p, operator = '\0';
	u_int64_t rval = oval;
	int64_t mult = 1;
	size_t n;
	double d, percent = 1.0;

	/* We only care about the remainder */
	offset = offset % lp->d_secpercyl;

	buf[0] = '\0';
	do {
		printf("%s: [%llu] ", prompt, oval);
		if (fgets(buf, sizeof(buf), stdin) == NULL) {
			buf[0] = '\0';
			if (feof(stdin)) {
				clearerr(stdin);
				putchar('\n');
				return(ULLONG_MAX - 1);
			}
		}
		n = strlen(buf);
		if (n > 0 && buf[n-1] == '\n')
			buf[--n] = '\0';
		if (buf[0] == '?')
			puts(helpstring);
	} while (buf[0] == '?');

	if (buf[0] == '*' && buf[1] == '\0') {
		rval = maxval;
	} else {
		/* deal with units */
		if (buf[0] != '\0' && n > 0) {
			if ((flags & DO_CONVERSIONS)) {
				switch (tolower((unsigned char)buf[n-1])) {

				case 'c':
					mult = lp->d_secpercyl;
					buf[--n] = '\0';
					break;
				case 'b':
					mult = -(int64_t)lp->d_secsize;
					buf[--n] = '\0';
					break;
				case 'k':
					if (lp->d_secsize > 1024)
						mult = -(int64_t)lp->d_secsize /
						    1024LL;
					else
						mult = 1024LL / lp->d_secsize;
					buf[--n] = '\0';
					break;
				case 'm':
					mult = (1024LL * 1024) / lp->d_secsize;
					buf[--n] = '\0';
					break;
				case 'g':
					mult = (1024LL * 1024 * 1024) /
					    lp->d_secsize;
					buf[--n] = '\0';
					break;
				case 't':
					mult = (1024LL * 1024 * 1024 * 1024) /
					    lp->d_secsize;
					buf[--n] = '\0';
					break;
				case '%':
					buf[--n] = '\0';
					p = &buf[0];
					if (*p == '+' || *p == '-')
						operator = *p++;
					percent = strtod(p, NULL) / 100.0;
					snprintf(buf, sizeof(buf), "%llu",
					    DL_GETDSIZE(lp));
					break;
				case '&':
					buf[--n] = '\0';
					p = &buf[0];
					if (*p == '+' || *p == '-')
						operator = *p++;
					percent = strtod(p, NULL) / 100.0;
					snprintf(buf, sizeof(buf), "%lld",
					    maxval);
					break;
				}
			}

			/* Did they give us an operator? */
			p = &buf[0];
			if (*p == '+' || *p == '-')
				operator = *p++;

			endptr = p;
			errno = 0;
			d = strtod(p, &endptr);
			if (errno == ERANGE)
				rval = ULLONG_MAX;	/* too big/small */
			else if (*endptr != '\0') {
				errno = EINVAL;		/* non-numbers in str */
				rval = ULLONG_MAX;
			} else {
				/* XXX - should check for overflow */
				if (mult > 0)
					rval = d * mult * percent;
				else
					/* Negative mult means divide (fancy) */
					rval = d / (-mult) * percent;

				/* Apply the operator */
				if (operator == '+')
					rval += oval;
				else if (operator == '-')
					rval = oval - rval;
			}
		}
	}
	if ((flags & DO_ROUNDING) && rval != ULLONG_MAX) {
		/* Round to nearest cylinder unless given in sectors */
		if (
#ifdef SUN_CYLCHECK
		    ((lp->d_flags & D_VENDOR) || mult != 1) &&
#else
		    mult != 1 &&
#endif
		    (rval + offset) % lp->d_secpercyl != 0) {
			u_int64_t cyls;

			/* Round to higher cylinder but no more than maxval */
			cyls = (rval / lp->d_secpercyl) + 1;
			if ((cyls * lp->d_secpercyl) - offset > maxval)
				cyls--;
			rval = (cyls * lp->d_secpercyl) - offset;
			if (!quiet)
				printf("Rounding size to cylinder (%d sectors)"
				    ": %llu\n", lp->d_secpercyl, rval);
		}
	}

	return(rval);
}

/*
 * Check for partition overlap in lp and prompt the user to resolve the overlap
 * if any is found.  Returns 1 if unable to resolve, else 0.
 */
int
has_overlap(struct disklabel *lp)
{
	struct partition **spp;
	int c, i, j;
	char buf[BUFSIZ];

	/* Get a sorted list of the in-use partitions. */
	spp = sort_partitions(lp);

	/* If there are less than two partitions in use, there is no overlap. */
	if (spp[1] == NULL)
		return(0);

	/* Now that we have things sorted by starting sector check overlap */
	for (i = 0; spp[i] != NULL; i++) {
		for (j = i + 1; spp[j] != NULL; j++) {
			/* `if last_sec_in_part + 1 > first_sec_in_next_part' */
			if (DL_GETPOFFSET(spp[i]) + DL_GETPSIZE(spp[i]) >
			    DL_GETPOFFSET(spp[j])) {
				/* Overlap!  Convert to real part numbers. */
				i = ((char *)spp[i] - (char *)lp->d_partitions)
				    / sizeof(**spp);
				j = ((char *)spp[j] - (char *)lp->d_partitions)
				    / sizeof(**spp);
				printf("\nError, partitions %c and %c overlap:"
				    "\n", 'a' + i, 'a' + j);
				printf("#    %16.16s %16.16s  fstype "
				    "[fsize bsize    cpg]\n", "size", "offset");
				display_partition(stdout, lp, i, 0);
				display_partition(stdout, lp, j, 0);

				/* Get partition to disable or ^D */
				do {
					printf("Disable which one? "
					    "(^D to abort) [%c %c] ",
					    'a' + i, 'a' + j);
					buf[0] = '\0';
					if (!fgets(buf, sizeof(buf), stdin)) {
						putchar('\n');
						return(1);	/* ^D */
					}
					c = buf[0] - 'a';
				} while (buf[1] != '\n' && buf[1] != '\0' &&
				    c != i && c != j);

				/* Mark the selected one as unused */
				lp->d_partitions[c].p_fstype = FS_UNUSED;
				return (has_overlap(lp));
			}
		}
	}

	return(0);
}

void
edit_parms(struct disklabel *lp)
{
	char *p;
	u_int64_t freesectors, ui;
	struct disklabel oldlabel = *lp;

	printf("Changing device parameters for %s:\n", specname);

	/* disk type */
	for (;;) {
		p = getstring("disk type",
		    "What kind of disk is this?  Usually SCSI, ESDI, ST506, or "
		    "floppy (use ESDI for IDE).", dktypenames[lp->d_type]);
		if (p == NULL) {
			fputs("Command aborted\n", stderr);
			return;
		}
		if (strcasecmp(p, "IDE") == 0)
			ui = DTYPE_ESDI;
		else
			for (ui = 1; ui < DKMAXTYPES &&
			    strcasecmp(p, dktypenames[ui]); ui++)
				;
		if (ui < DKMAXTYPES) {
			break;
		} else {
			printf("\"%s\" is not a valid disk type.\n", p);
			fputs("Valid types are: ", stdout);
			for (ui = 1; ui < DKMAXTYPES; ui++) {
				printf("\"%s\"", dktypenames[ui]);
				if (ui < DKMAXTYPES - 1)
					fputs(", ", stdout);
			}
			putchar('\n');
		}
	}
	lp->d_type = ui;

	/* pack/label id */
	p = getstring("label name",
	    "15 char string that describes this label, usually the disk name.",
	    lp->d_packname);
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		*lp = oldlabel;		/* undo damage */
		return;
	}
	strncpy(lp->d_packname, p, sizeof(lp->d_packname));	/* checked */

	/* sectors/track */
	for (;;) {
		ui = getuint64(lp, "sectors/track",
		    "The Number of sectors per track.", lp->d_nsectors,
		    lp->d_nsectors, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_nsectors = ui;

	/* tracks/cylinder */
	for (;;) {
		ui = getuint64(lp, "tracks/cylinder",
		    "The number of tracks per cylinder.", lp->d_ntracks,
		    lp->d_ntracks, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_ntracks = ui;

	/* sectors/cylinder */
	for (;;) {
		ui = getuint64(lp, "sectors/cylinder",
		    "The number of sectors per cylinder (Usually sectors/track "
		    "* tracks/cylinder).", lp->d_secpercyl, lp->d_secpercyl,
		    0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_secpercyl = ui;

	/* number of cylinders */
	for (;;) {
		ui = getuint64(lp, "number of cylinders",
		    "The total number of cylinders on the disk.",
		    lp->d_ncylinders, lp->d_ncylinders, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_ncylinders = ui;

	/* total sectors */
	for (;;) {
		u_int64_t nsec = MAXIMUM(DL_GETDSIZE(lp),
		    (u_int64_t)lp->d_ncylinders * lp->d_secpercyl);
		ui = getuint64(lp, "total sectors",
		    "The total number of sectors on the disk.",
		    nsec, nsec, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui > DL_GETDSIZE(lp) &&
		    ending_sector == DL_GETDSIZE(lp)) {
			puts("You may want to increase the size of the 'c' "
			    "partition.");
			break;
		} else if (ui < DL_GETDSIZE(lp) &&
		    ending_sector == DL_GETDSIZE(lp)) {
			/* shrink free count */
			freesectors = editor_countfree(lp);
			if (DL_GETDSIZE(lp) - ui > freesectors)
				fprintf(stderr,
				    "Not enough free space to shrink by %llu "
				    "sectors (only %llu sectors left)\n",
				    DL_GETDSIZE(lp) - ui, freesectors);
			else
				break;
		} else
			break;
	}
	/* Adjust ending_sector if necessary. */
	if (ending_sector > ui) {
		ending_sector = ui;
		DL_SETBEND(lp, ending_sector);
	}
	DL_SETDSIZE(lp, ui);
}

struct partition **
sort_partitions(struct disklabel *lp)
{
	static struct partition *spp[MAXPARTITIONS+2];
	int i, npartitions;

	memset(spp, 0, sizeof(spp));

	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    DL_GETPSIZE(&lp->d_partitions[i]) != 0)
			spp[npartitions++] = &lp->d_partitions[i];
	}

	/*
	 * Sort the partitions based on starting offset.
	 * This is safe because we guarantee no overlap.
	 */
	if (npartitions > 1)
		if (heapsort((void *)spp, npartitions, sizeof(spp[0]),
		    partition_cmp))
			err(4, "failed to sort partition table");

	return(spp);
}

/*
 * Get a valid disk type if necessary.
 */
void
getdisktype(struct disklabel *lp, char *banner, char *dev)
{
	int i;
	char *s;
	const char *def = "SCSI";
	const struct dtypes {
		const char *dev;
		const char *type;
	} dtypes[] = {
		{ "sd",   "SCSI" },
		{ "wd",   "IDE" },
		{ "fd",   "FLOPPY" },
		{ "xd",   "SMD" },
		{ "xy",   "SMD" },
		{ "hd",   "HP-IB" },
		{ "vnd",  "VND" },
		{ "svnd", "VND" },
		{ NULL,   NULL }
	};

	if ((s = basename(dev)) != NULL) {
		if (*s == 'r')
			s++;
		i = strcspn(s, "0123456789");
		s[i] = '\0';
		dev = s;
		for (i = 0; dtypes[i].dev != NULL; i++) {
			if (strcmp(dev, dtypes[i].dev) == 0) {
				def = dtypes[i].type;
				break;
			}
		}
	}

	if (lp->d_type > DKMAXTYPES || lp->d_type == 0) {
		puts(banner);
		puts("Possible values are:");
		printf("\"IDE\", ");
		for (i = 1; i < DKMAXTYPES; i++) {
			printf("\"%s\"", dktypenames[i]);
			if (i < DKMAXTYPES - 1)
				fputs(", ", stdout);
		}
		putchar('\n');

		for (;;) {
			s = getstring("Disk type",
			    "What kind of disk is this?  Usually SCSI, IDE, "
			    "ESDI, ST506, or floppy.", def);
			if (s == NULL)
				continue;
			if (strcasecmp(s, "IDE") == 0) {
				lp->d_type = DTYPE_ESDI;
				return;
			}
			for (i = 1; i < DKMAXTYPES; i++)
				if (strcasecmp(s, dktypenames[i]) == 0) {
					lp->d_type = i;
					return;
				}
			printf("\"%s\" is not a valid disk type.\n", s);
			fputs("Valid types are: ", stdout);
			for (i = 1; i < DKMAXTYPES; i++) {
				printf("\"%s\"", dktypenames[i]);
				if (i < DKMAXTYPES - 1)
					fputs(", ", stdout);
			}
			putchar('\n');
		}
	}
}

/*
 * Get beginning and ending sectors of the OpenBSD portion of the disk
 * from the user.
 */
void
set_bounds(struct disklabel *lp)
{
	u_int64_t ui, start_temp;

	/* Starting sector */
	do {
		ui = getuint64(lp, "Starting sector",
		  "The start of the OpenBSD portion of the disk.",
		  starting_sector, DL_GETDSIZE(lp), 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return;
		}
	} while (ui >= DL_GETDSIZE(lp));
	start_temp = ui;

	/* Size */
	do {
		ui = getuint64(lp, "Size ('*' for entire disk)",
		  "The size of the OpenBSD portion of the disk ('*' for the "
		  "entire disk).", ending_sector - starting_sector,
		  DL_GETDSIZE(lp) - start_temp, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return;
		}
	} while (ui > DL_GETDSIZE(lp) - start_temp);
	ending_sector = start_temp + ui;
	DL_SETBEND(lp, ending_sector);
	starting_sector = start_temp;
	DL_SETBSTART(lp, starting_sector);
}

/*
 * Allow user to interactively change disklabel UID.
 */
void
set_duid(struct disklabel *lp)
{
	char *s;
	int i;

	printf("The disklabel UID is currently: "
	    "%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\n",
            lp->d_uid[0], lp->d_uid[1], lp->d_uid[2], lp->d_uid[3],
            lp->d_uid[4], lp->d_uid[5], lp->d_uid[6], lp->d_uid[7]);

	do {
		s = getstring("duid", "The disklabel UID, given as a 16 "
		    "character hexadecimal string.", NULL);
		if (s == NULL || strlen(s) == 0) {
			fputs("Command aborted\n", stderr);
			return;
		}
		i = duid_parse(lp, s);
		if (i != 0)
			fputs("Invalid UID entered.\n", stderr);
	} while (i != 0);
}

/*
 * Return a list of the "chunks" of free space available
 */
struct diskchunk *
free_chunks(struct disklabel *lp)
{
	struct partition **spp;
	static struct diskchunk chunks[MAXPARTITIONS + 2];
	u_int64_t start, stop;
	int i, numchunks;

	/* Sort the in-use partitions based on offset */
	spp = sort_partitions(lp);

	/* If there are no partitions, it's all free. */
	if (spp[0] == NULL) {
		chunks[0].start = starting_sector;
		chunks[0].stop = ending_sector;
		chunks[1].start = chunks[1].stop = 0;
		return(chunks);
	}

	/* Find chunks of free space */
	numchunks = 0;
	if (DL_GETPOFFSET(spp[0]) > starting_sector) {
		chunks[0].start = starting_sector;
		chunks[0].stop = DL_GETPOFFSET(spp[0]);
		numchunks++;
	}
	for (i = 0; spp[i] != NULL; i++) {
		start = DL_GETPOFFSET(spp[i]) + DL_GETPSIZE(spp[i]);
		if (start < starting_sector)
			start = starting_sector;
		else if (start > ending_sector)
			start = ending_sector;
		if (spp[i + 1] != NULL)
			stop = DL_GETPOFFSET(spp[i+1]);
		else
			stop = ending_sector;
		if (stop < starting_sector)
			stop = starting_sector;
		else if (stop > ending_sector)
			stop = ending_sector;
		if (start < stop) {
			chunks[numchunks].start = start;
			chunks[numchunks].stop = stop;
			numchunks++;
		}
	}

	/* Terminate and return */
	chunks[numchunks].start = chunks[numchunks].stop = 0;
	return(chunks);
}

void
find_bounds(struct disklabel *lp)
{
	starting_sector = DL_GETBSTART(lp);
	ending_sector = DL_GETBEND(lp);

	if (ending_sector) {
		if (verbose)
			printf("Treating sectors %llu-%llu as the OpenBSD"
			    " portion of the disk.\nYou can use the 'b'"
			    " command to change this.\n\n", starting_sector,
			    ending_sector);
	}
}

/*
 * Calculate free space.
 */
u_int64_t
editor_countfree(struct disklabel *lp)
{
	struct diskchunk *chunks;
	u_int64_t freesectors = 0;
	int i;

	chunks = free_chunks(lp);

	for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0; i++)
		freesectors += chunks[i].stop - chunks[i].start;

	return (freesectors);
}

void
editor_help(void)
{
	puts("Available commands:");
	puts(
" ? | h    - show help                 n [part] - set mount point\n"
" A        - auto partition all space  p [unit] - print partitions\n"
" a [part] - add partition             q        - quit & save changes\n"
" b        - set OpenBSD boundaries    R [part] - resize auto allocated partition\n"
" c [part] - change partition size     r        - display free space\n"
" D        - reset label to default    s [path] - save label to file\n"
" d [part] - delete partition          U        - undo all changes\n"
" e        - edit drive parameters     u        - undo last change\n"
" g [d|u]  - [d]isk or [u]ser geometry w        - write label to disk\n"
" i        - modify disklabel UID      X        - toggle expert mode\n"
" l [unit] - print disk label header   x        - exit & lose changes\n"
" M        - disklabel(8) man page     z        - delete all partitions\n"
" m [part] - modify partition\n"
"\n"
"Suffixes can be used to indicate units other than sectors:\n"
" 'b' (bytes), 'k' (kilobytes), 'm' (megabytes), 'g' (gigabytes) 't' (terabytes)\n"
" 'c' (cylinders), '%' (% of total disk), '&' (% of free space).\n"
"Values in non-sector units are truncated to the nearest cylinder boundary.");

}

void
mpcopy(char **to, char **from)
{
	int i;

	for (i = 0; i < MAXPARTITIONS; i++) {
		free(to[i]);
		to[i] = NULL;
		if (from[i] != NULL) {
			to[i] = strdup(from[i]);
			if (to[i] == NULL)
				errx(4, "out of memory");
		}
	}
}

int
mpequal(char **mp1, char **mp2)
{
	int i;

	for (i = 0; i < MAXPARTITIONS; i++) {
		if (mp1[i] == NULL && mp2[i] == NULL)
			continue;

		if ((mp1[i] != NULL && mp2[i] == NULL) ||
		    (mp1[i] == NULL && mp2[i] != NULL) ||
		    (strcmp(mp1[i], mp2[i]) != 0))
			return(0);
	}
	return(1);
}

void
mpsave(struct disklabel *lp)
{
	int i, j;
	char bdev[PATH_MAX], *p;
	struct mountinfo mi[MAXPARTITIONS];
	FILE *fp;
	u_int8_t fstype;

	if (!fstabfile)
		return;

	memset(&mi, 0, sizeof(mi));

	for (i = 0; i < MAXPARTITIONS; i++) {
		fstype = lp->d_partitions[i].p_fstype;
		if (mountpoints[i] != NULL || fstype == FS_SWAP) {
			mi[i].mountpoint = mountpoints[i];
			mi[i].partno = i;
		}
	}

	/* Convert specname to bdev */
	if (uidflag) {
		snprintf(bdev, sizeof(bdev),
		    "%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx.%c",
		    lab.d_uid[0], lab.d_uid[1], lab.d_uid[2], lab.d_uid[3],
		    lab.d_uid[4], lab.d_uid[5], lab.d_uid[6], lab.d_uid[7],
		    specname[strlen(specname)-1]);
	} else if (strncmp(_PATH_DEV, specname, sizeof(_PATH_DEV) - 1) == 0 &&
	    specname[sizeof(_PATH_DEV) - 1] == 'r') {
		snprintf(bdev, sizeof(bdev), "%s%s", _PATH_DEV,
		    &specname[sizeof(_PATH_DEV)]);
	} else {
		if ((p = strrchr(specname, '/')) == NULL || *(++p) != 'r')
			return;
		*p = '\0';
		snprintf(bdev, sizeof(bdev), "%s%s", specname, p + 1);
		*p = 'r';
	}
	bdev[strlen(bdev) - 1] = '\0';

	/* Sort mountpoints so we don't try to mount /usr/local before /usr */
	qsort((void *)mi, MAXPARTITIONS, sizeof(struct mountinfo), micmp);

	if ((fp = fopen(fstabfile, "w"))) {
		for (i = 0; i < MAXPARTITIONS; i++) {
			j =  mi[i].partno;
			fstype = lp->d_partitions[j].p_fstype;
			if (fstype == FS_SWAP) {
				fprintf(fp, "%s%c none swap sw\n", bdev, 'a'+j);
			} else if (mi[i].mountpoint) {
				fprintf(fp, "%s%c %s %s rw 1 %d\n", bdev,
				    'a' + j, mi[i].mountpoint,
				    fstypesnames[fstype], j == 0 ? 1 : 2);
			}
		}
		fclose(fp);
	}
}

void
mpfree(char **mp)
{
	int part;
	
	if (mp == NULL)
		return;
	
	for (part = 0; part < MAXPARTITIONS; part++)
		free(mp[part]);
	
	free(mp);
}

int
get_offset(struct disklabel *lp, int partno)
{
	struct diskchunk *chunks;
	struct partition *pp = &lp->d_partitions[partno];
	u_int64_t ui, maxsize;
	int i, fstype;

	ui = getuint64(lp, "offset",
	   "Starting sector for this partition.",
	   DL_GETPOFFSET(pp),
	   DL_GETPOFFSET(pp), 0, DO_CONVERSIONS |
	   (pp->p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));

	if (ui == ULLONG_MAX - 1)
		fputs("Command aborted\n", stderr);
	else if (ui == ULLONG_MAX)
		fputs("Invalid entry\n", stderr);
	else if (ui < starting_sector || ui >= ending_sector)
		fprintf(stderr, "The offset must be >= %llu and < %llu, "
		    "the limits of the OpenBSD portion\n"
		    "of the disk. The 'b' command can change these limits.\n",
		    starting_sector, ending_sector);
#ifdef SUN_AAT0
	else if (partno == 0 && ui != 0)
		fprintf(stderr, "This architecture requires that "
		    "partition 'a' start at sector 0.\n");
#endif
	else {
		fstype = pp->p_fstype;
		pp->p_fstype = FS_UNUSED;
		chunks = free_chunks(lp);
		pp->p_fstype = fstype;
		for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0; i++) {
			if (ui < chunks[i].start || ui >= chunks[i].stop)
				continue;
			DL_SETPOFFSET(pp, ui);
			maxsize = chunks[i].stop - DL_GETPOFFSET(pp);
			if (DL_GETPSIZE(pp) > maxsize)
				DL_SETPSIZE(pp, maxsize);
			return (0);
		}
		fputs("The offset must be in a free area.\n", stderr);
	}

	/* Partition offset was not set. */
	return (1);
}

int
get_size(struct disklabel *lp, int partno)
{
	struct partition *pp = &lp->d_partitions[partno];
	u_int64_t maxsize, ui;

	maxsize = max_partition_size(lp, partno);

	ui = getuint64(lp, "size", "Size of the partition. "
	    "You may also say +/- amount for a relative change.",
	    DL_GETPSIZE(pp), maxsize, DL_GETPOFFSET(pp),
	    DO_CONVERSIONS | ((pp->p_fstype == FS_BSDFFS ||
	    pp->p_fstype == FS_SWAP) ?  DO_ROUNDING : 0));

	if (ui == ULLONG_MAX - 1)
		fputs("Command aborted\n", stderr);
	else if (ui == ULLONG_MAX)
		fputs("Invalid entry\n", stderr);
	else if (ui == 0)
		fputs("The size must be > 0 sectors\n", stderr);
	else if (ui + DL_GETPOFFSET(pp) > ending_sector)
		fprintf(stderr, "The size can't be more than "
		    "%llu sectors, or the partition would\n"
		    "extend beyond the last sector (%llu) of the "
		    "OpenBSD portion of\nthe disk. "
		    "The 'b' command can change this limit.\n",
		    ending_sector - DL_GETPOFFSET(pp), ending_sector);
	else if (ui > maxsize)
		fprintf(stderr,"Sorry, there are only %llu sectors left\n",
		    maxsize);
	else {
		DL_SETPSIZE(pp, ui);
		return (0);
	}

	/* Partition size was not set. */
	return (1);
}

int
get_cpg(struct disklabel *lp, int partno)
{
	u_int64_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	if (!expert || pp->p_fstype != FS_BSDFFS)
		return (0);

	for (;;) {
		ui = getuint64(lp, "cpg",
		    "Size of partition in fs blocks.",
		    pp->p_cpg, pp->p_cpg, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return (1);
		} else if (ui == ULLONG_MAX) {
			fputs("Invalid entry\n", stderr);
		} else if (ui > USHRT_MAX) {
			fprintf(stderr, "Error: cpg should be smaller than "
			    "65536\n");
		} else
			break;
	}
	pp->p_cpg = ui;
	return (0);
}

int
get_fsize(struct disklabel *lp, int partno)
{
	u_int64_t ui, fsize, frag;
	struct partition *pp = &lp->d_partitions[partno];

	if (!expert || pp->p_fstype != FS_BSDFFS)
		return (0);

	fsize = DISKLABELV1_FFS_FSIZE(pp->p_fragblock);
	frag = DISKLABELV1_FFS_FRAG(pp->p_fragblock);
	if (fsize == 0)
		frag = 8;

	for (;;) {
		ui = getuint64(lp, "fragment size",
		    "Size of ffs block fragments. A multiple of the disk "
		    "sector-size.", fsize, ULLONG_MAX-2, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return (1);
		} else if (ui == ULLONG_MAX) {
			fputs("Invalid entry\n", stderr);
		} else if (ui < lp->d_secsize || (ui % lp->d_secsize) != 0) {
			fprintf(stderr, "Error: fragment size must be a "
			    "multiple of the disk sector size (%d)\n",
			    lp->d_secsize);
		} else
			break;
	}
	if (ui == 0)
		puts("Zero fragment size implies zero block size");
	pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(ui, frag);
	return(0);
}

int
get_bsize(struct disklabel *lp, int partno)
{
	u_int64_t adj, ui, bsize, frag, fsize, orig_offset, orig_size;
	struct partition *pp = &lp->d_partitions[partno];
	char *p;

	if (pp->p_fstype != FS_BSDFFS)
		return (0);

	/* Avoid dividing by zero... */
	if (pp->p_fragblock == 0)
		return(1);

	if (!expert)
		goto align;

	fsize = DISKLABELV1_FFS_FSIZE(pp->p_fragblock);
	frag = DISKLABELV1_FFS_FRAG(pp->p_fragblock);

	for (;;) {
		ui = getuint64(lp, "block size",
		    "Size of ffs blocks. 1, 2, 4 or 8 times ffs fragment size.",
		    fsize * frag, ULLONG_MAX - 2, 0, 0);

		/* sanity checks */
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui < getpagesize())
			fprintf(stderr,
			    "Error: block size must be at least as big "
			    "as page size (%d).\n", getpagesize());
		else if (ui < fsize || (fsize != ui && fsize * 2 != ui &&
		    fsize * 4 != ui && fsize * 8 != ui))
			fprintf(stderr, "Error: block size must be 1, 2, 4 or "
			    "8 times fragment size (%llu).\n",
			    (unsigned long long) fsize);
		else
			break;
	}
	frag = ui / fsize;
	pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(fsize, frag);

#ifndef SUN_CYLCHECK
	p = getstring("Align partition to block size",
	    "Round the partition offset and size to multiples of bsize?", "y");

	if (*p == 'n' || *p == 'N')
		return (0);
#endif

align:

#ifndef SUN_CYLCHECK
	orig_size = DL_GETPSIZE(pp);
	orig_offset = DL_GETPOFFSET(pp);

	bsize = (DISKLABELV1_FFS_FRAG(pp->p_fragblock) *
	    DISKLABELV1_FFS_FSIZE(pp->p_fragblock)) / lp->d_secsize;
	if (DL_GETPOFFSET(pp) != starting_sector) {
		/* Can't change offset of first partition. */
		adj = bsize - (DL_GETPOFFSET(pp) % bsize);
		if (adj != 0 && adj != bsize) {
			DL_SETPOFFSET(pp, DL_GETPOFFSET(pp) + adj);
			DL_SETPSIZE(pp, DL_GETPSIZE(pp) - adj);
		}
	}
	/* Always align end. */
	adj = (DL_GETPOFFSET(pp) + DL_GETPSIZE(pp)) % bsize;
	if (adj > 0)
		DL_SETPSIZE(pp, DL_GETPSIZE(pp) - adj);

	if (orig_offset != DL_GETPOFFSET(pp) && !quiet)
		printf("Rounding offset to bsize (%llu sectors): %llu\n",
		    bsize, DL_GETPOFFSET(pp));
	if (orig_size != DL_GETPSIZE(pp) && !quiet)
		printf("Rounding size to bsize (%llu sectors): %llu\n",
		    bsize, DL_GETPSIZE(pp));
#endif
	return(0);
}

int
get_fstype(struct disklabel *lp, int partno)
{
	char *p;
	u_int64_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	if (pp->p_fstype < FSMAXTYPES) {
		p = getstring("FS type",
		    "Filesystem type (usually 4.2BSD or swap)",
		    fstypenames[pp->p_fstype]);
		if (p == NULL) {
			fputs("Command aborted\n", stderr);
			return(1);
		}
		for (ui = 0; ui < FSMAXTYPES; ui++) {
			if (!strcasecmp(p, fstypenames[ui])) {
				pp->p_fstype = ui;
				break;
			}
		}
		if (ui >= FSMAXTYPES) {
			printf("Unrecognized filesystem type '%s', treating "
			    "as 'unknown'\n", p);
			pp->p_fstype = FS_OTHER;
		}
	} else {
		for (;;) {
			ui = getuint64(lp, "FS type (decimal)",
			    "Filesystem type as a decimal number; usually 7 "
			    "(4.2BSD) or 1 (swap).",
			    pp->p_fstype, pp->p_fstype, 0, 0);
			if (ui == ULLONG_MAX - 1) {
				fputs("Command aborted\n", stderr);
				return(1);
			} if (ui == ULLONG_MAX)
				fputs("Invalid entry\n", stderr);
			else
				break;
		}
		pp->p_fstype = ui;
	}
	return(0);
}

int
get_mp(struct disklabel *lp, int partno)
{
	struct partition *pp = &lp->d_partitions[partno];
	char *p;
	int i;

	if (fstabfile && pp->p_fstype != FS_UNUSED &&
	    pp->p_fstype != FS_SWAP && pp->p_fstype != FS_BOOT &&
	    pp->p_fstype != FS_OTHER) {
		for (;;) {
			p = getstring("mount point",
			    "Where to mount this filesystem (ie: / /var /usr)",
			    mountpoints[partno] ? mountpoints[partno] : "none");
			if (p == NULL) {
				fputs("Command aborted\n", stderr);
				return(1);
			}
			if (strcasecmp(p, "none") == 0) {
				free(mountpoints[partno]);
				mountpoints[partno] = NULL;
				break;
			}
			for (i = 0; i < MAXPARTITIONS; i++)
				if (mountpoints[i] != NULL && i != partno &&
				    strcmp(p, mountpoints[i]) == 0)
					break;
			if (i < MAXPARTITIONS) {
				fprintf(stderr, "'%c' already being mounted at "
				    "'%s'\n", 'a'+i, p);
				break;
			}
			if (*p == '/') {
				/* XXX - might as well realloc */
				free(mountpoints[partno]);
				if ((mountpoints[partno] = strdup(p)) == NULL)
					errx(4, "out of memory");
				break;
			}
			fputs("Mount points must start with '/'\n", stderr);
		}
	}
	return(0);
}

int
micmp(const void *a1, const void *a2)
{
	struct mountinfo *mi1 = (struct mountinfo *)a1;
	struct mountinfo *mi2 = (struct mountinfo *)a2;

	/* We want all the NULLs at the end... */
	if (mi1->mountpoint == NULL && mi2->mountpoint == NULL)
		return(0);
	else if (mi1->mountpoint == NULL)
		return(1);
	else if (mi2->mountpoint == NULL)
		return(-1);
	else
		return(strcmp(mi1->mountpoint, mi2->mountpoint));
}

void
get_geometry(int f, struct disklabel **dgpp)
{
	struct stat st;
	struct disklabel *disk_geop;

	if (fstat(f, &st) == -1)
		err(4, "Can't stat device");

	/* Get disk geometry */
	if ((disk_geop = calloc(1, sizeof(struct disklabel))) == NULL)
		errx(4, "out of memory");
	if (ioctl(f, DIOCGPDINFO, disk_geop) < 0)
		err(4, "ioctl DIOCGPDINFO");
	*dgpp = disk_geop;
}

void
set_geometry(struct disklabel *lp, struct disklabel *dgp,
    struct disklabel *ugp, char *p)
{
	if (p == NULL) {
		p = getstring("[d]isk or [u]ser geometry",
		    "Enter 'd' to use the geometry based on what the disk "
		    "itself thinks it is, or 'u' to use the geometry that "
		    "was found in the label.",
		    "d");
	}
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		return;
	}
	switch (*p) {
	case 'd':
	case 'D':
		if (dgp == NULL)
			fputs("BIOS geometry not defined.\n", stderr);
		else {
			lp->d_secsize = dgp->d_secsize;
			lp->d_nsectors = dgp->d_nsectors;
			lp->d_ntracks = dgp->d_ntracks;
			lp->d_ncylinders = dgp->d_ncylinders;
			lp->d_secpercyl = dgp->d_secpercyl;
			DL_SETDSIZE(lp, DL_GETDSIZE(dgp));
		}
		break;
	case 'u':
	case 'U':
		if (ugp == NULL)
			fputs("BIOS geometry not defined.\n", stderr);
		else {
			lp->d_secsize = ugp->d_secsize;
			lp->d_nsectors = ugp->d_nsectors;
			lp->d_ntracks = ugp->d_ntracks;
			lp->d_ncylinders = ugp->d_ncylinders;
			lp->d_secpercyl = ugp->d_secpercyl;
			DL_SETDSIZE(lp, DL_GETDSIZE(ugp));
			if (dgp != NULL && ugp->d_secsize == dgp->d_secsize &&
			    ugp->d_nsectors == dgp->d_nsectors &&
			    ugp->d_ntracks == dgp->d_ntracks &&
			    ugp->d_ncylinders == dgp->d_ncylinders &&
			    ugp->d_secpercyl == dgp->d_secpercyl &&
			    DL_GETDSIZE(ugp) == DL_GETDSIZE(dgp))
				fputs("Note: user geometry is the same as disk "
				    "geometry.\n", stderr);
		}
		break;
	default:
		fputs("You must enter either 'd' or 'u'.\n", stderr);
		break;
	}
}

void
zero_partitions(struct disklabel *lp)
{
	int i;

	for (i = 0; i < MAXPARTITIONS; i++) {
		memset(&lp->d_partitions[i], 0, sizeof(struct partition));
		free(mountpoints[i]);
		mountpoints[i] = NULL;
	}

	DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
}

u_int64_t
max_partition_size(struct disklabel *lp, int partno)
{
	struct partition *pp = &lp->d_partitions[partno];
	struct diskchunk *chunks;
	u_int64_t maxsize = 0, offset;
	int fstype, i;

	fstype = pp->p_fstype;
	pp->p_fstype = FS_UNUSED;
	chunks = free_chunks(lp);
	pp->p_fstype = fstype;

	offset = DL_GETPOFFSET(pp);
	for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0; i++) {
		if (offset < chunks[i].start || offset >= chunks[i].stop)
			continue;
		maxsize = chunks[i].stop - offset;
		break;
	}
	return (maxsize);
}

void
psize(u_int64_t sz, char unit, struct disklabel *lp)
{
	double d = scale(sz, unit, lp);
	if (d < 0)
		printf("%llu", sz);
	else
		printf("%.*f%c", unit == 'B' ? 0 : 1, d, unit);
}

void
display_edit(struct disklabel *lp, char unit, u_int64_t fr)
{
	int i;

	unit = canonical_unit(lp, unit);

	printf("OpenBSD area: ");
	psize(starting_sector, 0, lp);
	printf("-");
	psize(ending_sector, 0, lp);
	printf("; size: ");
	psize(ending_sector - starting_sector, unit, lp);
	printf("; free: ");
	psize(fr, unit, lp);

	printf("\n#    %16.16s %16.16s  fstype [fsize bsize   cpg]\n",
	    "size", "offset");
	for (i = 0; i < lp->d_npartitions; i++)
		display_partition(stdout, lp, i, unit);
}

void
parse_autotable(char *filename)
{
	FILE	*cfile;
	size_t	 len;
	char	*buf, *t;
	uint	 idx = 0, pctsum = 0;
	struct space_allocation *sa;

	if ((cfile = fopen(filename, "r")) == NULL)
		err(1, "%s", filename);
	if ((alloc_table = calloc(1, sizeof(struct alloc_table))) == NULL)
		err(1, NULL);
	alloc_table_nitems = 1;

	while ((buf = fgetln(cfile, &len)) != NULL) {
		if ((alloc_table[0].table = reallocarray(alloc_table[0].table,
		    idx + 1, sizeof(*sa))) == NULL)
			err(1, NULL);
		sa = &(alloc_table[0].table[idx]);
		memset(sa, 0, sizeof(*sa));
		idx++;

		if ((sa->mp = get_token(&buf, &len)) == NULL ||
		    (sa->mp[0] != '/' && strcmp(sa->mp, "swap")))
			errx(1, "%s: parse error on line %u", filename, idx);
		if ((t = get_token(&buf, &len)) == NULL ||
		    parse_sizerange(t, &sa->minsz, &sa->maxsz) == -1)
			errx(1, "%s: parse error on line %u", filename, idx);
		if ((t = get_token(&buf, &len)) != NULL &&
		    parse_pct(t, &sa->rate) == -1)
			errx(1, "%s: parse error on line %u", filename, idx);
		if (sa->minsz > sa->maxsz)
			errx(1, "%s: min size > max size on line %u", filename,
			    idx);
		pctsum += sa->rate;
	}
	if (pctsum > 100)
		errx(1, "%s: sum of extra space allocation > 100%%", filename);
	alloc_table[0].sz = idx;
	fclose(cfile);
}

char *
get_token(char **s, size_t *len)
{
	char	*p, *r;
	size_t	 tlen = 0;

	p = *s;
	while (*len > 0 && !isspace((u_char)*s[0])) {
		(*s)++;
		(*len)--;
		tlen++;
	}
	if (tlen == 0)
		return (NULL);

	/* eat whitespace */
	while (*len > 0 && isspace((u_char)*s[0])) {
		(*s)++;
		(*len)--;
	}

	if ((r = strndup(p, tlen)) == NULL)
		err(1, NULL);
	return (r);
}

int
apply_unit(double val, u_char unit, u_int64_t *n)
{
	u_int64_t factor = 1;

	switch (tolower(unit)) {
	case 't':
		 factor *= 1024;
		/* FALLTHROUGH */
	case 'g':
		 factor *= 1024;
		/* FALLTHROUGH */
	case 'm':
		 factor *= 1024;
		/* FALLTHROUGH */
	case 'k':
		factor *= 1024;
		break;
	default:
		return (-1);
	}

	val *= factor / DEV_BSIZE;
	if (val > ULLONG_MAX)
		return (-1);
	*n = val;
	return (0);
}

int
parse_sizespec(const char *buf, double *val, char **unit)
{
	*val = strtod(buf, unit);
	if ((*val == 0 && *unit == buf) || *val <= 0)
		return (-1);
	if (*unit != NULL && *unit[0] == '\0')
		*unit = NULL;
	return (0);
}

int
parse_sizerange(char *buf, u_int64_t *min, u_int64_t *max)
{
	char	*p, *unit1 = NULL, *unit2 = NULL;
	double	 val1 = 0, val2 = 0;

	if ((p = strchr(buf, '-')) != NULL) {
		p[0] = '\0';
		p++;
	}
	*max = 0;
	if (parse_sizespec(buf, &val1, &unit1) == -1)
		return (-1);
	if (p != NULL && p[0] != '\0') {
		if (p[0] == '*')
			*max = -1;
		else
			if (parse_sizespec(p, &val2, &unit2) == -1)
				return (-1);
	}
	if (unit1 == NULL && (unit1 = unit2) == NULL)
		return (-1);
	if (apply_unit(val1, unit1[0], min) == -1)
		return (-1);
	if (val2 > 0) {
		if (apply_unit(val2, unit2[0], max) == -1)
			return (-1);
	} else
		if (*max == 0)
			*max = *min;
	free(buf);
	return (0);	
}

int
parse_pct(char *buf, int *n)
{
	const char	*errstr;

	if (buf[strlen(buf) - 1] == '%')
		buf[strlen(buf) - 1] = '\0';
	*n = strtonum(buf, 0, 100, &errstr);
	if (errstr) {
		warnx("parse percent %s: %s", buf, errstr);
		return (-1);
	}
	free(buf);
	return (0);
}
@


1.307
log
@tweak partition sizes for auto-alloction to better suit 8G disks
ok kr@@ aja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.306 2017/04/19 05:27:00 otto Exp $	*/
d519 1
a519 1
void
d599 1
a599 1
				return;
d662 1
a662 1
				return;
d692 1
@


1.306
log
@enlarge obj to satisfy new world order that has *big* compilers and
remove condition for static linking; ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.305 2017/03/04 07:26:42 otto Exp $	*/
d73 1
a73 1
	{   MEG(80),         GIG(1),   5, "/"		},
d79 1
a79 1
	{    GIG(2),        GIG(10),  10, "/usr/local"	},
d82 1
a82 1
	{    GIG(1),       GIG(300),  40, "/home"	}
@


1.305
log
@Allow R (resize auto-partition) after A as well as when started with -A.
This ability was lost in editor.c 1.264; noted by ajacoutot@@; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.304 2016/10/06 13:02:31 otto Exp $	*/
d81 1
a81 5
#ifdef STATICLINKING
	{ MEG(2600),         GIG(3),   4, "/usr/obj"	},
#else
	{ MEG(1300),         GIG(2),   4, "/usr/obj"	},
#endif
@


1.304
log
@init auto-partition table to zeroes; ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.303 2016/09/02 10:47:17 otto Exp $	*/
d219 1
a219 1
	if ((newlab.d_flags & D_VENDOR) && !aflag) {
d269 2
a270 1
				++aflag;
d272 1
a272 1
				--aflag;
d1270 1
a1270 1
			if (!aflag)
d2111 1
a2111 1
	if (orig_offset != DL_GETPOFFSET(pp) && !aflag)
d2114 1
a2114 1
	if (orig_size != DL_GETPSIZE(pp) && !aflag)
@


1.303
log
@Allow editing cpg in expert mode and align the cpg field properly
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.302 2016/09/01 09:46:42 tedu Exp $	*/
d2389 1
@


1.302
log
@remove references to sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.301 2016/08/19 08:06:25 otto Exp $	*/
d148 1
d994 2
a995 1
	    get_bsize(lp, partno) == 0)
d1310 1
a1310 1
				    "[fsize bsize  cpg]\n", "size", "offset");
d1972 28
d2363 1
a2363 1
	printf("\n#    %16.16s %16.16s  fstype [fsize bsize  cpg]\n",
@


1.301
log
@Start with a default fragsize of 2048, double it for large disks and then cap
based on sector size. This avoid too large fragments on 4k disks. Problem
noted by David Vasek; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.300 2015/12/10 17:26:59 mmcc Exp $	*/
a678 5
#if defined (__sparc__) && !defined(__sparc64__)
		/* can't boot from > 8k boot blocks */
		pp->p_fragblock =
		    DISKLABELV1_FFS_FRAGBLOCK(i == 0 ? 1024 : fragsize, 8);
#else
a679 1
#endif
a900 5
#if defined (__sparc__) && !defined(__sparc64__)
		/* can't boot from > 8k boot blocks */
		pp->p_fragblock =
		    DISKLABELV1_FFS_FRAGBLOCK(partno == 0 ? 1024 : fragsize, 8);
#else
a901 1
#endif
@


1.300
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.299 2015/11/23 19:19:29 deraadt Exp $	*/
d670 1
a670 2
		fragsize = (lp->d_secsize == DEV_BSIZE) ? 2048 :
		    lp->d_secsize;
d675 4
d897 1
a897 2
		fragsize = (lp->d_secsize == DEV_BSIZE) ? 2048 :
		    lp->d_secsize;
d903 2
@


1.299
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.298 2015/10/17 13:27:08 krw Exp $	*/
d513 1
a513 2
	if (disk_geop)
		free(disk_geop);
@


1.298
log
@NUMBOOT is dead! Nuke the variables and abstractions that were used
to build boot blocks.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.297 2015/10/15 19:31:15 miod Exp $	*/
a157 1
int64_t	getphysmem(void);
a517 12
int64_t
getphysmem(void)
{
	int64_t physmem;
	size_t sz = sizeof(physmem);
	int mib[] = { CTL_HW, HW_PHYSMEM64 };

	if (sysctl(mib, 2, &physmem, &sz, NULL, (size_t)0) == -1)
		errx(4, "can't get mem size");
	return physmem;
}

d533 1
a533 1
	int64_t physmem;
a553 2
	physmem = getphysmem() / DEV_BSIZE;	/* Blocks not sectors here! */

d572 2
a573 2
		if (physmem < MEG(256))
			alloc[1].minsz = alloc[1].maxsz = 2 * physmem;
d575 1
a575 1
			alloc[1].maxsz += physmem;
d577 1
a577 1
		alloc[3].maxsz += 2 * physmem;
@


1.297
log
@Remove disklabel -B (NUMBOOT) support. All the platforms which used to need
it are now using MI installboot for that purpose.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.296 2015/09/08 13:54:09 millert Exp $	*/
d384 1
a384 1
				if (writelabel(f, bootarea, &newlab) == 0) {
d470 1
a470 1
			if (writelabel(f, bootarea, &newlab) != 0)
@


1.296
log
@Avoid a SIGSEGV with FGJ malloc.conf flags when a template is used.
Found by jsg@@.  OK jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.295 2015/05/08 12:15:50 sthen Exp $	*/
a49 4
#ifndef NUMBOOT
#define NUMBOOT 0
#endif

a1749 9
	} else {
#if NUMBOOT > 0 
		/* Boot blocks take up the first cylinder */
		starting_sector = lp->d_secpercyl;
		if (verbose)
			printf("Reserving the first data cylinder for boot"
			    " blocks.\nYou can use the 'b' command to change"
			    " this.\n\n");
#endif
@


1.295
log
@Separately track the number of items in alloc_table in a variable. With
the changes for handling template files in r1.293, alloc_table became
a pointer to an array of structs (rather than the array itself), so
nitems(alloc_table) no longer returns the number of elements. As found
by sebastia@@, autosize would only try the first allocation scheme,
so installation would fail on small disks.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.294 2015/04/29 16:46:39 henning Exp $	*/
d2439 1
a2439 2
	tlen++;	/* null termination */
	if ((r = malloc(tlen)) == NULL)
a2440 1
	strlcpy(r, p, tlen);
@


1.294
log
@g/c unneeded second char * var, ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.293 2015/04/29 09:58:16 henning Exp $	*/
d126 1
d618 1
a618 1
			if (++index < nitems(alloc_table))
d681 1
a681 1
			if (++index < nitems(alloc_table))
d2389 1
@


1.293
log
@support passing a template file for the auto-allocation to disklabel.
template gives mountpoints, min-max size ranges and percentage of disk
foremost intended for autoinstalls, installer bits to follow soon.
with input from many, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.292 2015/03/17 19:11:55 otto Exp $	*/
d2380 1
a2380 1
	char	*buf, *p, *t;
d2396 1
a2396 2
		p = buf;
		if ((sa->mp = get_token(&p, &len)) == NULL ||
d2399 1
a2399 1
		if ((t = get_token(&p, &len)) == NULL ||
d2402 1
a2402 1
		if ((t = get_token(&p, &len)) != NULL &&
@


1.292
log
@for small mem machines, make sure max does not get smaller than
min, otherwise the constraint cannot be satisfied; ok deraadt@@ okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.291 2015/01/20 18:22:20 deraadt Exp $	*/
d76 1
a76 1
const struct space_allocation alloc_big[] = {
d94 1
a94 1
const struct space_allocation alloc_medium[] = {
d101 1
a101 1
const struct space_allocation alloc_small[] = {
d106 1
a106 1
const struct space_allocation alloc_stupid[] = {
d114 2
a115 2
const struct {
	const struct space_allocation *table;
d117 3
a119 1
} alloc_table[] = {
d125 1
d163 5
d589 1
a589 1
	if (index == 0) {
d2373 160
@


1.291
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.290 2015/01/16 20:21:40 miod Exp $	*/
d583 1
a583 1
			alloc[1].maxsz = 2 * physmem;
@


1.290
log
@Constify the driver name to disk type table, and remove rz and ccd from that
list.
ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.289 2015/01/16 06:39:57 deraadt Exp $	*/
d19 1
a19 1
#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE MAXFRAG */
@


1.289
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.288 2014/10/11 03:08:26 doug Exp $	*/
d133 1
a133 1
char	*getstring(char *, char *, char *);
d1119 1
a1119 1
getstring(char *prompt, char *helpstring, char *oval)
d1544 5
a1548 4
	char *s, *def = "SCSI";
	struct dtypes {
		char *dev;
		char *type;
a1550 1
		{ "rz",   "SCSI" },
a1555 1
		{ "ccd",  "CCD" },		/* deprecated */
@


1.288
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.287 2014/07/10 13:31:23 florian Exp $	*/
d19 1
d21 1
a21 1
#include <sys/param.h>
d39 1
d44 2
d1472 1
a1472 1
		u_int64_t nsec = MAX(DL_GETDSIZE(lp),
d1839 1
a1839 1
	char bdev[MAXPATHLEN], *p;
@


1.287
log
@Forward declarations for mpcopy & mpfree.
OK miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.286 2014/05/02 23:17:29 chl Exp $	*/
d570 1
a570 1
	alloc = malloc(lastalloc * sizeof(struct space_allocation));
@


1.286
log
@remove unused variable

ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.285 2014/05/02 12:43:10 krw Exp $	*/
a139 2
void	mpcopy(char **, char **);
void	mpfree(char **);
@


1.285
log
@'for (part == 0; ...)' is not the same as 'for(part = 0; ...)'.

Should fix mysterious crashes when twiddling mount points. Too
much Marrakesh sun.

Pointed out by Owain G. Ainsworth. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.284 2014/04/21 08:19:38 krw Exp $	*/
a1803 1
	char *top;
@


1.284
log
@Don't leak mountpoint info. Now with replacement for silly realloc() dance
that appears to fix mysterious crashes seen with previous version that
tried to sneak in to 5.5.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.283 2014/04/03 16:15:38 otto Exp $	*/
d1903 1
a1903 1
	for (part == 0; part < MAXPARTITIONS; part++)
@


1.283
log
@Proper validation and computation of bsize in expert mode; ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.282 2014/02/22 13:27:46 krw Exp $	*/
d141 1
d504 3
a506 3
	free(omountpoints);
	free(origmountpoints);
	free(tmpmountpoints);
d1807 2
d1810 2
a1811 4
			int len = strlen(from[i]) + 1;

			top = realloc(to[i], len);
			if (top == NULL)
a1812 5
			to[i] = top;
			(void)strlcpy(to[i], from[i], len);
		} else if (to[i] != NULL) {
			free(to[i]);
			to[i] = NULL;
d1893 14
@


1.282
log
@Revert mountpoints tweaking. Needs much more serious surgery than time
permits before release, and is pointless without other following diffs
to justify it that will not make release.

Should fix segfault's during install reported by Rod Whitworth on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.281 2014/02/16 00:04:32 krw Exp $	*/
d2045 1
a2045 1
		    "Size of ffs blocks. A multiple of the ffs fragment size.",
d2058 4
a2061 3
		else if (ui < fsize || (ui % fsize) != 0)
			fprintf(stderr, "Error: block size must be a multiple "
			    "of the fragment size (%llu).\n",
d2066 2
a2067 1
	pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(ui / frag, frag);
@


1.281
log
@Further tweak to mpfree(). Don't bother setting about-to-be-freed
memory to NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.280 2014/02/15 02:39:38 krw Exp $	*/
a140 1
void	mpfree(char **);
d503 3
a505 3
	mpfree(omountpoints);
	mpfree(origmountpoints);
	mpfree(tmpmountpoints);
a1898 14
void
mpfree(char **mp)
{
	int part;

	if (mp == NULL)
		return;

	for (part == 0; part < MAXPARTITIONS; part++)
		free(mp[part]);

	free(mp);
}
	
@


1.280
log
@Don't risk dereferencing NULL pointer to mountpoints array
when calling mpfree() with the array.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.279 2014/02/15 00:10:17 krw Exp $	*/
d1908 1
a1908 1
	for (part == 0; part < MAXPARTITIONS; part++) {
a1909 2
		mp[part] = NULL;
	}
@


1.279
log
@Stop leaking mount point strings in temporary copies of the
mountpoints array.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.278 2013/11/22 04:12:47 deraadt Exp $	*/
d1904 3
@


1.278
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.277 2013/11/12 04:59:02 deraadt Exp $	*/
d141 1
d504 3
a506 3
	free(omountpoints);
	free(origmountpoints);
	free(tmpmountpoints);
d1900 13
@


1.277
log
@add a variety of missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.276 2013/10/21 07:59:34 otto Exp $	*/
d373 3
a375 3
			} while (arg && tolower(*arg) != 'y' &&
			    tolower(*arg) != 'n');
			if (arg && tolower(*arg) == 'y') {
d1185 1
a1185 1
				switch (tolower(buf[n-1])) {
@


1.276
log
@improve on last commit: take 10% for swap, with a max of physmem plus a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.275 2013/10/18 13:36:04 otto Exp $	*/
d155 2
d517 1
@


1.275
log
@allow more space for swap with big disks, useful for hibernation;
requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.274 2013/10/15 20:13:02 bluhm Exp $	*/
d74 1
a74 1
	{   MEG(80),        GIG(16),   5, "swap"	},
d86 1
a86 1
	{    GIG(1),       GIG(300),  45, "/home"	}
@


1.274
log
@The disklabel variables aflag and dflag are boolean, use logical
instead of binary operators for comparison.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.273 2013/10/03 18:50:30 krw Exp $	*/
d74 1
a74 1
	{   MEG(80),       MEG(256),   5, "swap"	},
@


1.273
log
@Print u_int64_t variables with %llu.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.272 2013/09/10 15:17:46 krw Exp $	*/
d209 1
a209 1
	if ((newlab.d_flags & D_VENDOR) & !aflag) {
@


1.272
log
@The rule is: daddr_t variables hold counts of 512-byte blocks, a.k.a.
DEV_BSIZE blocks. Counts of possibly other-sized blocks (e.g. disk
sector addresses) are u_int64_t. The values stored in disklabels are
counts of possibly other-sized blocks and hence should be handled with
u_int64_t variables.

Start enforcing this rule. No intended functional change.

Rule strongly suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.271 2013/06/11 16:42:04 deraadt Exp $	*/
d1220 1
a1220 1
					snprintf(buf, sizeof(buf), "%lld",
@


1.271
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.270 2013/04/19 14:10:20 otto Exp $	*/
d65 2
a66 2
	daddr_t		minsz;	/* starts as blocks, xlated to sectors. */
	daddr_t		maxsz;	/* starts as blocks, xlated to sectors. */
d532 1
a532 1
	daddr_t secs, chunkstart, chunksize, cylsecs, totsecs, xtrasecs;
d542 1
a542 1
		daddr_t psz, pstart, pend;
d712 1
a712 1
	daddr_t secs, sz, off;
d714 1
a714 1
	daddr_t cylsecs;
d2321 1
a2321 1
psize(daddr_t sz, char unit, struct disklabel *lp)
@


1.270
log
@make sure the fs blocksize doesn't get too big; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.269 2012/07/13 16:06:42 krw Exp $	*/
d65 2
a66 2
	daddr64_t	minsz;	/* starts as blocks, xlated to sectors. */
	daddr64_t	maxsz;	/* starts as blocks, xlated to sectors. */
d532 1
a532 1
	daddr64_t secs, chunkstart, chunksize, cylsecs, totsecs, xtrasecs;
d542 1
a542 1
		daddr64_t psz, pstart, pend;
d712 1
a712 1
	daddr64_t secs, sz, off;
d714 1
a714 1
	daddr64_t cylsecs;
d2321 1
a2321 1
psize(daddr64_t sz, char unit, struct disklabel *lp)
@


1.269
log
@Replace a '512' with DEV_BSIZE. Calculate physmem size in blocks and
not sectors, since the values being tested/manipulated in the auto_alloc
tables are blocks at that point. Use MEG(256) instead of hand
expanding it when testing physmem.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.268 2012/03/18 03:24:01 krw Exp $	*/
d906 2
@


1.268
log
@getuint() -> getuint64() to make it crystal clear. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.267 2012/03/18 03:07:05 krw Exp $	*/
d556 1
a556 1
	physmem = getphysmem() / lp_org->d_secsize;
d576 1
a576 1
		if (physmem < 256LL * 1024 * 1024 / lp->d_secsize)
@


1.267
log
@Wrap some long lines I keep fixing, shrinking various diffs. No
change to executable.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.266 2012/01/30 10:05:31 chl Exp $	*/
d42 1
a42 1
/* flags for getuint() */
d130 1
a130 1
u_int64_t getuint(struct disklabel *, char *, char *, u_int64_t, u_int64_t,
d746 1
a746 1
	secs = getuint(lp, "[+|-]new size (with unit)",
d1144 1
a1144 1
getuint(struct disklabel *lp, char *prompt, char *helpstring,
d1399 1
a1399 1
		ui = getuint(lp, "sectors/track",
d1415 1
a1415 1
		ui = getuint(lp, "tracks/cylinder",
d1431 1
a1431 1
		ui = getuint(lp, "sectors/cylinder",
d1448 1
a1448 1
		ui = getuint(lp, "number of cylinders",
d1466 1
a1466 1
		ui = getuint(lp, "total sectors",
d1617 1
a1617 1
		ui = getuint(lp, "Starting sector",
d1629 1
a1629 1
		ui = getuint(lp, "Size ('*' for entire disk)",
d1902 1
a1902 1
	ui = getuint(lp, "offset",
d1951 1
a1951 1
	ui = getuint(lp, "size", "Size of the partition. "
d1997 1
a1997 1
		ui = getuint(lp, "fragment size",
d2039 1
a2039 1
		ui = getuint(lp, "block size",
d2129 1
a2129 1
			ui = getuint(lp, "FS type (decimal)",
@


1.266
log
@fix format string

ok krw@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.265 2012/01/19 15:51:11 krw Exp $	*/
d130 2
a131 1
u_int64_t getuint(struct disklabel *, char *, char *, u_int64_t, u_int64_t, u_int64_t, int);
d183 2
a184 1
	getdisktype(&newlab, "You need to specify a type for this disk.", specname);
d371 2
a372 1
			} while (arg && tolower(*arg) != 'y' && tolower(*arg) != 'n');
d427 3
a429 2
			 * If we allow 'U' repeatedly, information would be lost. This way
			 * multiple 'U's followed by 'u' would undo the 'U's.
d1309 2
a1310 1
			if (DL_GETPOFFSET(spp[i]) + DL_GETPSIZE(spp[i]) > DL_GETPOFFSET(spp[j])) {
d1316 2
a1317 2
				printf("\nError, partitions %c and %c overlap:\n",
				    'a' + i, 'a' + j);
d1325 2
a1326 1
					printf("Disable which one? (^D to abort) [%c %c] ",
d2123 2
a2124 1
			printf("Unrecognized filesystem type '%s', treating as 'unknown'\n", p);
d2130 2
a2131 1
			    "Filesystem type as a decimal number; usually 7 (4.2BSD) or 1 (swap).",
a2348 1

@


1.265
log
@Even 'X'perts should not be able to use the built in editor to
create ffs partitions with invalid fsize and bsize values newfs
will croak on. However, they should be able to set them to whatever
consistent values they want, not just make them smaller.

Also tweak some verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.264 2012/01/17 15:20:40 krw Exp $	*/
d2049 2
a2050 1
			    "of the fragment size (%d).\n", fsize);
@


1.264
log
@No need for saying out loud what we're thinking during auto-allocation.
i.e. when rounding off various values.

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.263 2012/01/17 01:28:06 krw Exp $	*/
d1992 2
a1993 2
		    "Size of fs block fragments.  Usually 2048 or 512.",
		    fsize, fsize, 0, 0);
d1996 2
a1997 2
			return(1);
		} else if (ui == ULLONG_MAX)
d1999 5
a2003 1
		else
d2034 2
a2035 3
		    "Size of filesystem blocks.  Usually 16384 or 4096.",
		    fsize * frag, fsize * frag,
		    0, 0);
d2047 3
a2049 6
		else if (ui % fsize != 0)
			fputs("Error: block size must be a multiple of the "
			    "fragment size.\n", stderr);
		else if (ui / fsize < 1)
			fputs("Error: block size must be at least as big as "
			    "fragment size.\n", stderr);
@


1.263
log
@Avoid ffs fragsize < sector-size when 'a'dding a partition via the
editor.  Use logic from calculating fragsize for an auto-allocated
partition. Noted when trying to add a small ffs partition to a 4K
sector device.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.262 2012/01/02 03:46:39 krw Exp $	*/
d207 1
a207 1
	if (newlab.d_flags & D_VENDOR) {
d257 1
a257 1
				aflag = 1;
d259 1
d1274 3
a1276 2
			printf("Rounding size to cylinder (%d sectors): %llu\n",
			    lp->d_secpercyl, rval);
d2084 1
a2084 1
	if (orig_offset != DL_GETPOFFSET(pp))
d2087 1
a2087 1
	if (orig_size != DL_GETPSIZE(pp))
@


1.262
log
@Change last "#if (NUMBOOT == 1)" to "#if NUMBOOT > 0".
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.261 2011/12/25 20:00:40 krw Exp $	*/
d894 2
a895 1
		fragsize = 2048;
@


1.261
log
@miod@@ reported problems reproducing a 'pre-4K fix' disklabel. So in the
interest of rope sales allow the 'X'pert to suppress the rounding of
partition locations to bsize boundaries. Also mention that such rounding
is being done, so as to not surprise the user.

ok otto@@ a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.260 2011/12/01 16:44:29 krw Exp $	*/
d1730 1
a1730 1
#if (NUMBOOT == 1)
@


1.260
log
@Fix negating of unsigned d_secsize. FIRST, cast to signed type,
THEN negate. Fixes issues with 'b' and 'k' size suffixes. Make error
message more clear while here.

Found, and fix provided, by David Imhoff via bugs@@. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.259 2011/10/06 21:16:01 deraadt Exp $	*/
d1272 2
a1273 1
			printf("Rounding to cylinder: %llu\n", rval);
d2008 1
a2008 1
	u_int64_t adj, ui, bsize, frag, fsize;
d2010 1
d2052 8
d2061 1
d2063 3
d2080 7
@


1.259
log
@mark ccd(4) deprecated in a few more places
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.258 2011/07/05 21:39:08 krw Exp $	*/
d1181 1
a1181 1
					mult = -lp->d_secsize;
d1186 2
a1187 1
						mult = -lp->d_secsize / 1024LL;
d1952 1
a1952 1
		fputs("The size must be > 0\n", stderr);
@


1.258
log
@Add DIOCGPDINFO to rxioctl(), as a synonym for DIOCGDINFO, the last
place it was missing. Delete now redundant calls to DIOCGDINFO when
getting physical disk info in disklabel(8) and fdisk(8).

Reminded by a fdisk discussion with Andres Perera on tech@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.257 2011/07/05 17:38:54 krw Exp $	*/
d1537 1
a1537 1
		{ "ccd",  "CCD" },
d1571 1
a1571 1
			    "ESDI, CCD, ST506, or floppy.", def);
@


1.257
log
@More non-512-byte sector groundwork. Don't let disklabel hint that
a ffs frag size can be less than the d_secsize of the disk.  Make
sure amd64 writedisklabel() puts the disklabel where readdoslabel()
will read it. Tweak i386/amd64 installboot/biosboot so sectors are
indeed used where sectors are claimed.

Lets me fdisk, newfs, mount and installboot onto 2048 and 4096
byte sector devices. Other filesystem utilites will still hold
surprises.

Note that actually booting from such devices will await BIOSen that
acknowledge such devices as bootable.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.256 2011/05/24 15:27:56 otto Exp $	*/
d2186 2
a2187 3
	if (ioctl(f, DIOCGPDINFO, disk_geop) < 0 &&
	    ioctl(f, DIOCGDINFO, disk_geop) < 0)
		err(4, "ioctl DIOCGDINFO");
@


1.256
log
@Allow for more room for /usr/obj on static linking only archs; ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.255 2011/05/23 08:22:29 otto Exp $	*/
d670 2
a671 1
		fragsize = 2048;
@


1.255
log
@Make /usr/obj a bit bigger, on small disks it ends up just a little
bit too small. ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.254 2011/05/22 17:49:26 otto Exp $	*/
d81 3
d85 1
@


1.254
log
@Apply proper rounding for the R command (changing of auto-allocated
partitions); ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.253 2011/05/22 13:04:40 otto Exp $	*/
d80 2
a81 2
	{    GIG(1),         GIG(2),   3, "/usr/src"	},
	{    GIG(1),         GIG(2),   3, "/usr/obj"	},
@


1.253
log
@In addition to relative resizing, allow absolute resizing of partitions
in auto-allocated labels. ok krw@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.252 2011/04/16 23:01:17 krw Exp $	*/
d758 1
d789 1
d1772 2
a1773 2
"\t'b' (bytes), 'k' (kilobytes), 'm' (megabytes), 'g' (gigabytes)\n"
"\t'c' (cylinders), '%' (% of total disk), '&' (% of free space).\n"
@


1.252
log
@Add swap partition entries to -F and -f output. man page
updates to follow. This will simplify install script fstab
creation.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.251 2011/04/16 11:44:41 krw Exp $	*/
d736 3
a738 3
	secs = getuint(lp, "grow (+) or shrink (-) (with unit)",
	    "amount to grow (+) or shrink (-) partition including unit",
	    0, editor_countfree(lp), 0, DO_CONVERSIONS);
d740 1
a740 1
	if (secs == 0 || secs == -1) {
d752 1
a752 1
	if (DL_GETPOFFSET(pp) + sz + secs > ending_sector) {
a755 4
	if (sz + secs < 0) {
		fputs("Amount too small\n", stderr);
		return;
	}
d757 1
a757 1
	DL_SETPSIZE(pp, sz + secs);
d1200 4
a1203 1
					percent = strtod(buf, NULL) / 100.0;
d1209 4
a1212 1
					percent = strtod(buf, NULL) / 100.0;
d1755 13
a1767 13
"  ? | h    - show help                  n [part] - set mount point\n"
"  A        - auto partition all space   p [unit] - print partitions\n"
"  a [part] - add partition              q        - quit & save changes\n"
"  b        - set OpenBSD boundaries     R [part] - resize a partition\n"
"  c [part] - change partition size      r        - display free space\n"
"  D        - reset label to default     s [path] - save label to file\n"
"  d [part] - delete partition           U        - undo all changes\n"
"  e        - edit drive parameters      u        - undo last change\n"
"  g [d|u]  - [d]isk or [u]ser geometry  w        - write label to disk\n"
"  i        - modify disklabel UID       X        - toggle expert mode\n"
"  l [unit] - print disk label header    x        - exit & lose changes\n"
"  M        - disklabel(8) man page      z        - delete all partitions\n"
"  m [part] - modify partition\n"
@


1.251
log
@Add '-F'. Same as '-f' but uses DUIDs when writing the mount point
information to the specified file. After every label write, read the
label to get current UID info.

Some internal code cleanup with no intended functional change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.250 2011/03/05 06:50:41 krw Exp $	*/
d1820 1
d1828 2
a1829 1
		if (mountpoints[i] != NULL) {
d1859 1
a1859 1
		for (i = 0; i < MAXPARTITIONS && mi[i].mountpoint; i++) {
d1861 8
a1868 4
			fprintf(fp, "%s%c %s %s rw 1 %d\n", bdev, 'a' + j,
			    mi[i].mountpoint,
			    fstypesnames[lp->d_partitions[j].p_fstype],
			    j == 0 ? 1 : 2);
@


1.250
log
@If an auto-allocation scheme fails because there are not enough
available partitions (e.g. many spoofed logical partitions) try
the next scheme rather than giving up.

"sane" deraadt@@ ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.249 2011/03/02 04:48:24 krw Exp $	*/
d160 1
a160 1
editor(struct disklabel *lp, int f)
d162 1
a162 1
	struct disklabel origlabel, lastlabel, tmplabel, label = *lp;
d178 1
a178 1
	getdisktype(&label, "You need to specify a type for this disk.", specname);
d184 1
a184 1
	find_bounds(&label);
d187 1
a187 1
	if (has_overlap(&label))
d191 2
a192 2
	pp = &label.d_partitions[RAW_PART];
	if (label.d_npartitions < 3 || DL_GETPSIZE(pp) == 0) {
d194 2
a195 2
		if (label.d_npartitions < 3)
			label.d_npartitions = 3;
d197 1
a197 1
		DL_SETPSIZE(pp, DL_GETDSIZE(&label));
d203 1
a203 1
	if (label.d_flags & D_VENDOR) {
d212 4
a215 4
	if (label.d_bbsize == 0)
		label.d_bbsize = BBSIZE;
	if (label.d_sbsize == 0)
		label.d_sbsize = SBSIZE;
d219 2
a220 2
	origlabel = label;
	lastlabel = label;
d240 1
a240 1
			lastlabel = label;
d252 1
a252 1
			if (ioctl(f, DIOCGPDINFO, &label) == 0) {
d254 1
a254 1
				editor_allocspace(&label);
d256 1
a256 1
				label = lastlabel;
d259 1
a259 1
			editor_add(&label, arg);
d263 1
a263 1
			set_bounds(&label);
d267 1
a267 1
			editor_change(&label, arg);
d271 1
a271 1
			if (ioctl(f, DIOCGPDINFO, &label) == 0) {
d282 1
a282 1
			editor_delete(&label, arg);
d286 1
a286 1
			edit_parms(&label);
d290 1
a290 1
			set_geometry(&label, disk_geop, lp, arg);
d294 1
a294 1
			set_duid(&label);
d298 1
a298 1
			editor_modify(&label, arg);
d307 1
a307 1
			editor_name(&label, arg);
d311 2
a312 1
			display_edit(&label, arg ? *arg : 0, editor_countfree(&label));
d316 1
a316 1
			display(stdout, &label, arg ? *arg : 0, 0);
a344 2
			/* Save mountpoint info if there is any. */
			mpsave(&label);
d354 1
a354 1
			    memcmp(lp, &label, sizeof(label)) == 0) {
d356 2
d366 2
a367 2
				if (writelabel(f, bootarea, &label) == 0) {
					*lp = label;
d379 1
a379 1
				editor_resize(&label, arg);
d389 1
a389 1
			chunks = free_chunks(&label);
d397 1
a397 1
			    editor_countfree(&label));
d412 1
a412 1
				display(fp, &label, 0, 1);
d422 1
a422 1
			if (memcmp(&label, &origlabel, sizeof(label)) ||
d424 2
a425 2
				tmplabel = label;
				label = origlabel;
d435 2
a436 2
			tmplabel = label;
			label = lastlabel;
d451 1
a451 1
			if (writelabel(f, bootarea, &label) != 0)
d455 1
a455 1
				*lp = label;
d470 1
a470 1
			zero_partitions(&label);
d485 1
a485 1
		if (memcmp(&label, &lastlabel, sizeof(label)) == 0 &&
d1834 7
a1840 1
	if (strncmp(_PATH_DEV, specname, sizeof(_PATH_DEV) - 1) == 0 &&
@


1.249
log
@Every time the user updates the bounds of the OpenBSD area of the disk, either explicitly
or implicitly, update the start and end sector of the OpenBSD area in the
disklabel with DL_SEBEND/DL_SETBSTART. Otherwise the new bounds would not be
saved to disk.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.248 2011/02/19 21:18:59 krw Exp $	*/
d590 8
a597 2
		if (j == MAXPARTITIONS)
			return;
@


1.248
log
@If the user screws up adding a partition, don't keep partial bits
of the partition info around to confuse disklabel, newfs, fsck, etc.

From Pedro Martelletto.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.247 2010/12/13 01:01:41 marco Exp $	*/
d1468 1
a1468 1
	if (ending_sector > ui)
d1470 2
d1612 1
d1614 1
@


1.247
log
@stray tabs and spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.246 2010/11/24 14:15:31 jsing Exp $	*/
d904 1
a904 1
	DL_SETPSIZE(pp, 0);
@


1.246
log
@When dealing with disklabel UIDs (DUIDs) be specific and consistent with
naming.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.243 2010/08/10 23:35:08 krw Exp $	*/
d68 1
a68 1
	char 	       *mp;
d353 1
a353 1
 			 */
d393 2
a394 2
			    	    chunks[i].start, chunks[i].stop - 1,
			   	    chunks[i].stop - chunks[i].start);
d397 1
a397 1
		    	break;
d845 1
a845 1
	}	
d862 1
a862 1
	memset(pp, 0, sizeof(*pp)); 
d1734 1
a1734 1
	return (freesectors);	
d1944 1
a1944 1
	
d2249 1
a2249 1
	}	
@


1.245
log
@Print disklabel UIDs using printf/fprintf instead of using the hand rolled
uid_print() function.

ok krw@@
@
text
@d133 1
a133 1
void	set_uid(struct disklabel *);
d294 1
a294 1
			set_uid(&label);
d1617 1
a1617 1
set_uid(struct disklabel *lp)
d1628 1
a1628 1
		s = getstring("uid", "The disklabel UID, given as a 16 "
d1634 1
a1634 1
		i = uid_parse(lp, s);
@


1.244
log
@fix a few warnings.  ok jsing
@
text
@d1622 4
a1625 3
	printf("The disklabel UID is currently: ");
	uid_print(stdout, lp);
	printf("\n");
@


1.243
log
@Add support for t/T == terabyte units to -E. Prodded by deraadt@@.

Semantically equivalent version ok beck@@ millert@@ and tested ckeuthe@@.

"just commit" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.242 2010/08/09 17:31:45 deraadt Exp $	*/
a1618 1
	u_int uid[8];
d1838 1
a1838 1
	if (fp = fopen(fstabfile, "w")) {
@


1.242
log
@Improve the editor prompt for the 'R' (resize) command
from otto
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.241 2010/07/27 00:49:42 krw Exp $	*/
d1133 1
a1134 1
	int mult = 1;
d1176 1
a1176 1
						mult = -lp->d_secsize / 1024;
d1178 1
a1178 1
						mult = 1024 / lp->d_secsize;
d1182 1
a1182 1
					mult = 1048576 / lp->d_secsize;
d1186 7
a1192 1
					mult = 1073741824 / lp->d_secsize;
@


1.241
log
@Align FFS filesystem start and end sectors so the start is on a
bsize boundary and the end fills up the last bsize chunk.

Don't change the start sector if it is the first sector of the
OpenBSD portion of the disk.

Don't attempt to align on SUN_CYLCHECK architectures. They are
attempting a different alignment.

This is an attempt to ensure that FFS i/o's are aligned for optimal
performance on newer disks that lie about their sector size.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.240 2010/06/30 21:11:20 halex Exp $	*/
d729 2
a730 1
	secs = getuint(lp, "resize", "amount to grow (+) or shrink (-)",
@


1.240
log
@make the disklabel editor not crash when pressing ^D in the uid prompt

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.239 2010/05/18 04:41:14 dlg Exp $	*/
d524 1
a524 1
	int i, j, lastalloc, index = 0, fragsize;
d592 1
d676 1
d1967 1
a1967 1
	u_int64_t ui, bsize, frag, fsize;
d1970 1
a1970 1
	if (!expert || pp->p_fstype != FS_BSDFFS)
d1977 3
a1979 1
	bsize = DISKLABELV1_FFS_BSIZE(pp->p_fragblock);
d2009 18
@


1.239
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.238 2010/05/15 10:54:29 otto Exp $	*/
d1621 1
a1621 1
		if (strlen(s) == 0) {
@


1.238
log
@grow /usr/local more at the cost of /home; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.237 2010/05/11 11:12:22 otto Exp $	*/
d23 1
@


1.237
log
@set max size of auto allocated /usr/local to 10G; ok espie@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.236 2010/04/28 17:26:46 jsing Exp $	*/
d78 1
a78 1
	{    GIG(2),        GIG(10),   5, "/usr/local"	},
d81 1
a81 1
	{    GIG(1),       GIG(300),  50, "/home"	}
@


1.236
log
@Add a new 'i' command to the disklabel interactive editor, allowing the
disklabel UID to be changed.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.233 2010/04/13 22:38:20 lum Exp $	*/
d78 1
a78 1
	{    GIG(2),         GIG(6),   5, "/usr/local"	},
@


1.235
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d132 1
d292 4
d1604 27
d1741 4
a1744 3
"  l [unit] - print disk label header    X        - toggle expert mode\n"
"  M        - disklabel(8) man page      x        - exit & lose changes\n"
"  m [part] - modify partition           z        - delete all partitions\n"
@


1.234
log
@Remove interactive help for individual disklabel editor commands.
These were in effect a duplication of the man page contents. The man page
has been updated to include any small ommissions that were in the
interactive help. Man page tweaks/suggestions from jmc@@ and deraadt@@.
ok jmc@@ deraadt@@ krw@@ otto@@
@
text
@a214 4
	/* Interleave must be >= 1 */
	if (label.d_interleave == 0)
		label.d_interleave = 1;

a1455 32

	/* rpm */
	for (;;) {
		ui = getuint(lp, "rpm",
		  "The rotational speed of the disk in revolutions per minute.",
		  lp->d_rpm, lp->d_rpm, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_rpm = ui;

	/* interleave */
	for (;;) {
		ui = getuint(lp, "interleave",
		  "The physical sector interleave, set when formatting.  Almost always 1.",
		  lp->d_interleave, lp->d_interleave, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*lp = oldlabel;		/* undo damage */
			return;
		} else if (ui == ULLONG_MAX || ui == 0)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	lp->d_interleave = ui;
@


1.233
log
@Some more help text cleanup, from suggestions by krw@@
ok krw@@ jmc@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.232 2010/04/13 12:36:31 lum Exp $	*/
d121 1
a121 1
void	editor_help(char *);
d250 1
a250 1
			editor_help(arg ? arg : "");
d1732 1
a1732 1
editor_help(char *arg)
d1734 1
a1734 11

	/* XXX - put these strings in a table instead? */
	switch (*arg) {
	case 'p':
		puts(
"'p' prints the current partitions.  By default, it prints size and offset in\n"
"sectors (a sector is usually 512 bytes). 'p' takes an optional units argument.\n"
"Possible values are 'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm'\n"
"for megabytes, and 'g' for gigabytes\n");
		break;
	case 'l':
d1736 1
a1736 140
"'l' prints the header of the disk label.  By default, it prints size and offset\n"
"in sectors (a sector is usually 512 bytes). 'l' takes an optional units\n"
"argument.  Possible values are 'b' for bytes, 'c' for cylinders, 'k' for\n"
"kilobytes, 'm' for megabytes, and 'g' for gigabytes\n");
		break;
	case 'M':
		puts(
"'M' pipes the entire OpenBSD man page for disklabel through the pager specified\n"
"by the PAGER environment variable or 'less' if PAGER is not set. It is\n"
"especially useful during install when the normal system manual is not available\n");
		break;
	case 'e':
		puts(
"'e' edits the disk drive parameters.  These include the number of sectors/track,\n"
"tracks/cylinder, sectors/cylinder, number of cylinders on the disk, total\n"
"sectors on the disk, rpm, interleave, disk type and a descriptive label string.\n"
"You should not change these unless you know what you are doing\n");
		break;
	case 'a':
		puts(
"'a' adds new partitions to the disk label.  It takes as an optional argument the\n"
"partition letter to add.  If you do not specify a partition letter, you will be\n"
"prompted for it; the next available letter will be the default answer\n");
		break;
	case 'A':
		puts(
"'A' removes all the existing partitions and creates a new set based on the size\n"
"of the disk\n");
		break;
	case 'b':
		puts(
"'b' changes the boundaries of the OpenBSD portion of the disk. This is on a disk\n"
"with an fdisk partition, the boundaries are set to be the first and last sectors\n"
"of the OpenBSD fdisk partition.  You should only change these if your fdisk\n"
"partition table is incorrect or you have a disk larger than the maximum size\n"
"allowed by fdisk.  You may enter '*' at the 'Size' prompt to indicate the entire\n"
"size of the disk (minus the starting sector).  Use this option with care; if you\n"
"extend the boundaries such that they overlap with another operating system you\n"
"will corrupt the other operating system's data\n");
		break;
	case 'c':
		puts(
"'c' changes the size of an existing partition.  It takes as an optional\n"
"argument the partition letter to change.  If you do not specify a partition\n"
"letter, you will be prompted for one.  You may add a '+' or '-' prefix to the\n"
"new size to increase or decrease the existing value instead of entering an\n"
"absolute value.  You may also use a suffix to indicate the units the values\n"
"is in terms of.  Possible suffixes are 'b' for bytes, 'c' for cylinders, 'k'\n"
"for kilobytes, 'm' for megabytes, 'g' for gigabytes or no suffix for sectors\n"
"(usually 512 bytes).  You may also enter '*' to change the size to be the \n"
"total number of free sectors remaining\n");
		break;
	case 'D':
		puts(
"'D' sets the disk label to the default values as reported by the disk itself.\n"
"This simulates the case where there is no disk label.\n");
		break;
	case 'd':
		puts(
"'d' deletes an existing partition.  It takes as an optional argument the\n"
"partition letter to change.  If you do not specify a partition letter, you will\n"
"be prompted for one.  You may not delete the ``c'' partition as 'c' must always\n"
"exist and by default is marked as 'unused' (so it does not take up any space).\n");
		break;
	case 'g':
		puts(
"'g' selects which disk geometry to use, the disk or a user geometry. It takes\n"
"as an optional argument ``d'' or ``u''.  If you do not specify the type as an\n"
"argument, you will be prompted for it.\n");
		break;
	case 'm':
		puts(
"'m' modifys an existing partition.  It takes as an optional argument the\n"
"partition letter to change.  If you do not specify a partition letter, you will\n"
"be prompted for one.  This option allows the user to change the filesystem \n"
"type, starting offset, partition size, block fragment size, block size, and \n"
"cylinders per group for the specified partition (not all parameters are \n"
"configurable for non-BSD partitions).\n");
		break;
	case 'n':
		puts(
"'n' names the mount point for a partition.  It takes as an optional argument\n"
"the partition letter to name.  If you do not specify a partition letter, you\n"
"will be prompted for one.  This command is only valid if disklabel was invoked\n"
"with the -f flag.\n");
		break;
	case 'R':
		puts(
"'R' resizes a partition. If the partition is reduced in size, subsequent\n"
"partitions are reallocated to eliminate unnecessary space. If the chosen\n"
"partition increases in size the last partition will be shrunk if needed.  Works\n"
"only for auto allocated labels.\n");
		break;
	case 'r':
		puts(
"'r' recalculates and display details about the available free space.\n");
		break;
	case 'U':
		puts(
"'U' undoes all changes made since entering the editor.\n");
		break;
	case 'u':
		puts(
"'u' undoes (or redoes) the last change.  Entering 'u' once will undo your\n"
"last change.  Entering it again will restore the change.\n");
		break;
	case 's':
		puts(
"'s' saves a copy of the label to a file in ascii format (suitable for loading\n"
"via disklabel's [-R] option).  It takes as an optional argument the filename\n"
"to save the label to.  If you do not specify a filename, you will be prompted\n"
"for one.\n");
		break;
	case 'w':
		puts(
"'w' writes the current label to disk.  This command will commit any changes\n"
"to the on-disk label.\n");
		break;
	case 'q':
		puts(
"'q' quits the label editor.  If any changes have been made you will be asked\n"
"whether or not to save the changes to the on-disk label.\n");
		break;
	case 'X':
		puts(
"'X' toggles disklabel 'expert mode'.  By default, some settings are reserved\n"
"for experts only (such as the block and fragment size on ffs partitions).\n");
		break;
	case 'x':
		puts(
"'x' exits the label editor without saving any changes to the on-disk label.\n");
		break;
	case 'z':
		puts(
"'z' zeroes out the existing partition table, leaving only the 'c' partition.\n");
		break;
	default:
		puts("Available commands:");
		puts(
"  ? [cmd]  - show help                  n [part] - set mount point\n"
d1753 1
a1753 2
		break;
	}
@


1.232
log
@Clean up and make consistent the first sentence of each help entry in
interactive disklabel. Plus realign all lines because of textual changes.
ok krw@@ jmc@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.231 2010/04/04 14:12:12 otto Exp $	*/
d1753 3
a1755 4
"'M' pipes the entire OpenBSD manual page for disk label through the pager\n"
"specified by the PAGER environment variable or 'less' if PAGER is not set. It\n"
"is especially useful during install when the normal system manual is not\n"
"available\n");
d1766 1
a1766 1
"'a' adds new partitions to the disk.  It takes as an optional argument the\n"
d1772 2
a1773 2
"'A' clears the existing partitions and creates a new label based on the size of\n"
"the disk\n");
d1780 5
a1784 5
"partition table is incorrect or you have a disk larger than 8gig, since 8gig is\n"
"the maximum size an fdisk partition can be.  You may enter '*' at the 'Size'\n"
"prompt to indicate the entire size of the disk (minus the starting sector).  Use\n"
"this option with care; if you extend the boundaries such that they overlap\n"
"with another operating system you will corrupt the other operating system's data\n");
d1800 2
a1801 2
"'D' sets the disk label to the default values as reported by the disk \n"
"itself.  This similates the case where there is no disk label.\n");
d1827 4
a1830 4
"'n' sets the mount point for a partition (ie: name it).  It takes as an\n"
"optional argument the partition letter to name.  If you do not specify a \n"
"partition letter, you will be prompted for one.  This option is only valid \n"
"if disklabel was invoked with the -f flag.\n");
d1834 4
a1837 3
"'R' resizes a partition, compacting unused space between partitions with a\n"
"higher offset. The last partition will be shrunk if needed.  Works only for auto\n"
"allocated labels.\n");
d1843 4
d1861 1
a1861 1
"'w' writes the current label to disk.  This option will commit any changes\n"
d1880 1
a1880 2
"'z' zeroes out the existing partition table, leaving only the 'c' partition.\n"
"The drive parameters are not changed.\n");
@


1.231
log
@In editor_add(), determine block & frag size base on the the actual fs
size chosen by the user, and not the suggested size; move to bigger
blocksize in two steps; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.230 2010/03/29 13:24:59 otto Exp $	*/
d1739 4
a1742 4
"The 'p' command prints the current partitions.  By default, it prints size\n"
"and offset in sectors (a sector is usually 512 bytes).  The 'p' command\n"
"takes an optional units argument.  Possible values are 'b' for bytes, 'c'\n"
"for cylinders, 'k' for kilobytes, 'm' for megabytes, and 'g' for gigabytes.\n");
d1746 4
a1749 4
"The 'l' command prints the header of the disk label.  By default, it prints\n"
"size and offset in sectors (a sector is usually 512 bytes).  The 'p' command\n"
"takes an optional units argument.  Possible values are 'b' for bytes, 'c'\n"
"for cylinders, 'k' for kilobytes, 'm' for megabytes, and 'g' for gigabytes.\n");
d1753 4
a1756 4
"The 'M' command pipes the entire OpenBSD manual page for disk label through\n"
"the pager specified by the PAGER environment variable or 'less' if PAGER is\n"
"not set.  It is especially useful during install when the normal system\n"
"manual is not available.\n");
d1760 4
a1763 5
"The 'e' command is used to edit the disk drive parameters.  These include\n"
"the number of sectors/track, tracks/cylinder, sectors/cylinder, number of\n"
"cylinders on the disk , total sectors on the disk, rpm, interleave, disk\n"
"type, and a descriptive label string.  You should not change these unless\n"
"you know what you are doing\n");
d1767 3
a1769 4
"The 'a' command adds new partitions to the disk.  It takes as an optional\n"
"argument the partition letter to add.  If you do not specify a partition\n"
"letter, you will be prompted for it; the next available letter will be the\n"
"default answer\n");
d1773 2
a1774 2
"The 'A' command clears the existing partitions and creates a new label\n"
"based on the size of the disk\n");
d1778 8
a1785 10
"The 'b' command is used to change the boundaries of the OpenBSD portion of\n"
"the disk.  This is only useful on disks with an fdisk partition.  By default,\n"
"on a disk with an fdisk partition, the boundaries are set to be the first\n"
"and last sectors of the OpenBSD fdisk partition.  You should only change\n"
"these if your fdisk partition table is incorrect or you have a disk larger\n"
"than 8gig, since 8gig is the maximum size an fdisk partition can be.  You\n"
"may enter '*' at the 'Size' prompt to indicate the entire size of the disk\n"
"(minus the starting sector).  Use this option with care; if you extend the\n"
"boundaries such that they overlap with another operating system you will\n"
"corrupt the other operating system's data.\n");
d1789 9
a1797 9
"The 'c' command is used to change the size of an existing partition.  It\n"
"takes as an optional argument the partition letter to change.  If you do not\n"
"specify a partition letter, you will be prompted for one.  You may add a '+'\n"
"or '-' prefix to the new size to increase or decrease the existing value\n"
"instead of entering an absolute value.  You may also use a suffix to indicate\n"
"the units the values is in terms of.  Possible suffixes are 'b' for bytes,\n"
"'c' for cylinders, 'k' for kilobytes, 'm' for megabytes, 'g' for gigabytes or\n"
"no suffix for sectors (usually 512 bytes).  You may also enter '*' to change\n"
"the size to be the total number of free sectors remaining.\n");
d1801 2
a1802 2
"The 'D' command will set the disk label to the default values as reported\n"
"by the disk itself.  This similates the case where there is no disk label.\n");
d1806 4
a1809 5
"The 'd' command is used to delete an existing partition.  It takes as an\n"
"optional argument the partition letter to change.  If you do not specify a\n"
"partition letter, you will be prompted for one.  You may not delete the ``c''\n"
"partition as 'c' must always exist and by default is marked as 'unused' (so\n"
"it does not take up any space).\n");
d1813 3
a1815 3
"The 'g' command is used select which disk geometry to use, the disk or a\n"
"user geometry.  It takes as an optional argument ``d'' or ``u''.  If \n"
"you do not specify the type as an argument, you will be prompted for it.\n");
d1819 6
a1824 6
"The 'm' command is used to modify an existing partition.  It takes as an\n"
"optional argument the partition letter to change.  If you do not specify a\n"
"partition letter, you will be prompted for one.  This option allows the user\n"
"to change the filesystem type, starting offset, partition size, block fragment\n"
"size, block size, and cylinders per group for the specified partition (not all\n"
"parameters are configurable for non-BSD partitions).\n");
d1828 4
a1831 4
"The 'n' command is used to set the mount point for a partition (ie: name it).\n"
"It takes as an optional argument the partition letter to name.  If you do\n"
"not specify a partition letter, you will be prompted for one.  This option\n"
"is only valid if disklabel was invoked with the -f flag.\n");
d1835 3
a1837 3
"Resize a a partition, compacting unused space between partitions\n"
"with a higher offset. The last partition will be shrunk if needed.\n"
"Works only for auto allocated labels.\n");
d1841 1
a1841 2
"The 'r' command is used to recalculate and display details about\n"
"the available free space.\n");
d1845 2
a1846 2
"The 'u' command will undo (or redo) the last change.  Entering 'u' once will\n"
"undo your last change.  Entering it again will restore the change.\n");
d1850 4
a1853 4
"The 's' command is used to save a copy of the label to a file in ascii format\n"
"(suitable for loading via disklabel's [-R] option).  It takes as an optional\n"
"argument the filename to save the label to.  If you do not specify a filename,\n"
"you will be prompted for one.\n");
d1857 2
a1858 2
"The 'w' command will write the current label to disk.  This option will\n"
"commit any changes to the on-disk label.\n");
d1862 2
a1863 2
"The 'q' command quits the label editor.  If any changes have been made you\n"
"will be asked whether or not to save the changes to the on-disk label.\n");
d1867 2
a1868 3
"The 'X' command toggles disklabel in to/out of 'expert mode'.  By default,\n"
"some settings are reserved for experts only (such as the block and fragment\n"
"size on ffs partitions).\n");
d1872 1
a1872 2
"The 'x' command exits the label editor without saving any changes to the\n"
"on-disk label.\n");
d1876 2
a1877 2
"The 'z' command zeroes out the existing partition table, leaving only the 'c'\n"
"partition.  The drive parameters are not changed.\n");
@


1.230
log
@Improve the way we handle spoofed paritions for Resize. Now any auto
allocated can be treated. We still check if no non-native partition
overlaps the openbsd area, to avoid surprised. ok krw@@ lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.229 2010/03/25 14:35:58 sthen Exp $	*/
d657 4
a660 2
		if (secs > 512ULL * 1024 * 1024 * 1024 / lp->d_secsize)
			fragsize *= 4;
d875 10
a884 3
	fragsize = 2048;
	if (new_size > 512ULL * 1024 * 1024 * 1024 / lp->d_secsize)
		fragsize *= 4;
d886 3
a888 3
	/* can't boot from > 8k boot blocks */
	pp->p_fragblock =
	    DISKLABELV1_FFS_FRAGBLOCK(partno == 0 ? 1024 : fragsize, 8);
d890 1
a890 1
	pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(fragsize, 8);
d892 6
a897 10
	pp->p_cpg = 1;

	if (get_offset(lp, partno) == 0 &&
	    get_size(lp, partno) == 0   &&
	    get_fstype(lp, partno) == 0 &&
	    get_mp(lp, partno) == 0 &&
	    get_fsize(lp, partno) == 0  &&
	    get_bsize(lp, partno) == 0)
		return;

@


1.229
log
@s/parititon/partition/ in error message
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.228 2010/03/23 14:59:30 otto Exp $	*/
d152 1
a152 1
static int spoofed;
d375 1
a375 1
			if (aflag && !spoofed)
d379 1
a379 2
				    "allocated labels without spoofed "
				    "partitions\n", stderr);
d525 18
a542 4
	spoofed = 0;
	for (i = 0;  i < MAXPARTITIONS; i++)
		if (i != RAW_PART && DL_GETPSIZE(&lp_org->d_partitions[i]) != 0)
			spoofed = 1;
a545 3
	/* How big is the OpenBSD portion of the disk?  */
	find_bounds(lp_org);

d714 9
a722 1
	sz = editor_countfree(lp);
d724 1
a724 1
	    0, sz, 0, DO_CONVERSIONS);
d726 1
a726 1
	if (secs == 0) {
a737 6

	sz = DL_GETPSIZE(pp);
	if (sz == 0) {
		fputs("No such partition\n", stderr);
		return;
	}
d757 4
a760 1
		sz = DL_GETPSIZE(&label.d_partitions[i]);
a763 1
		pp = &label.d_partitions[i];
d1837 1
a1837 1
"Works only for auto allocated labels with no spoofed partitions\n");
@


1.228
log
@avoid use of uninited var in max_partition_size(); ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.227 2010/03/23 14:32:34 otto Exp $	*/
d723 1
a723 1
		fputs("No such parititon\n", stderr);
@


1.227
log
@introducing 'R': interactive command to customize auto allocated labels,
by growing or shrinking them as desired. can use some tweaks, but
committing now to be able to work in-tree; ok krw@@ lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.226 2010/03/20 16:53:20 otto Exp $	*/
d2344 1
a2344 1
	u_int64_t maxsize, offset;
@


1.226
log
@for big (>500G) partitions, move to bigger bocks and fragments in the
label. newfs wil pick that up, and create a filesystems for which you
actually have a chanche to run fsck successfuly and before your hair
falls out; ok krw@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.225 2009/12/24 10:06:35 sobrado Exp $	*/
d116 1
d152 1
d374 9
d526 5
d672 98
d1754 5
d1819 6
d1874 1
a1874 1
"  b        - set OpenBSD boundaries     s [path] - save label to file\n"
d1876 7
a1882 7
"  D        - reset label to default     U        - undo all changes\n"
"  d [part] - delete partition           u        - undo last change\n"
"  e        - edit drive parameters      w        - write label to disk\n"
"  g [d|u]  - [d]isk or [u]ser geometry  X        - toggle expert mode\n"
"  l [unit] - print disk label header    x        - exit & lose changes\n"
"  M        - disklabel(8) man page      z        - delete all partitions\n"
"  m [part] - modify partition\n"
@


1.225
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.224 2009/11/12 16:21:03 deraadt Exp $	*/
d512 1
a512 1
	int i, j, lastalloc, index = 0;
d630 3
d636 1
a636 1
		    DISKLABELV1_FFS_FRAGBLOCK(i == 0 ? 1024 : 2048, 8);
d638 1
a638 1
		pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
d664 1
a664 1
	int i, partno;
d745 3
d751 1
a751 1
	    DISKLABELV1_FFS_FRAGBLOCK(partno == 0 ? 1024 : 2048, 8);
d753 1
a753 1
	pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
@


1.224
log
@4 memory leaks found by parfait; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.223 2009/10/27 23:59:32 deraadt Exp $	*/
d718 1
a718 1
	 * zero'ed to avoid inadvertant overlaps.
@


1.223
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.222 2009/10/01 16:28:33 deraadt Exp $	*/
d159 1
a159 1
	struct disklabel *disk_geop;
d165 1
a165 1
	int i;
d338 1
a338 1
				return(0);
d353 1
a353 1
				return(0);
d363 1
a363 1
					return(0);
d367 2
a368 1
			return(1);
d453 1
a453 1
			return(0);
d478 7
@


1.222
log
@There is no -F flag, it is -f; spotted by tasm.devil@@googlemail
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.221 2009/08/12 20:01:54 deraadt Exp $	*/
a17 4

#ifndef lint
static char rcsid[] = "$OpenBSD: editor.c,v 1.221 2009/08/12 20:01:54 deraadt Exp $";
#endif /* not lint */
@


1.221
log
@Crank the /usr sizes in the large configuration
ok krw otto
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.220 2009/08/07 00:26:34 martynas Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.220 2009/08/07 00:26:34 martynas Exp $";
d1688 1
a1688 1
"is only valid if disklabel was invoked with the -F flag.\n");
@


1.220
log
@move editor_allocspace & mpsave out to extern.h so that disklabel.c
gets the declarations it uses.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.219 2009/06/26 14:25:36 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.219 2009/06/26 14:25:36 deraadt Exp $";
d80 1
a80 1
	{  MEG(600),         GIG(2),   2, "/usr"	},
d85 1
a85 1
	{    GIG(1),       GIG(300),  53, "/home"	}
@


1.219
log
@since nitems() is not yet fit for userland consumption, provide it
ourselves
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.218 2009/06/11 02:59:08 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.218 2009/06/11 02:59:08 krw Exp $";
a119 1
void	editor_allocspace(struct disklabel *);
a138 1
void	mpsave(struct disklabel *);
@


1.218
log
@'d *' == 'z' == zero_partitions(). Mount point info needs to be
cleared in both cases. So just do it inside zero_partitions() since
we are looping over all the partitions there anyway.

Should fix an install corner case discovered by todd@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.217 2009/06/04 21:13:03 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.217 2009/06/04 21:13:03 deraadt Exp $";
d104 4
@


1.217
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.216 2009/06/02 21:38:36 chl Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.216 2009/06/02 21:38:36 chl Exp $";
a458 4
			for (i=0; i<MAXPARTITIONS; i++) {
				free(mountpoints[i]);
				mountpoints[i] = NULL;
			}
d2193 1
a2193 1
	for (i = 0; i < MAXPARTITIONS; i++)
d2195 4
@


1.216
log
@remove unused variable

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.215 2009/06/02 16:23:45 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.215 2009/06/02 16:23:45 krw Exp $";
a1459 1
 * XXX - should mention MBR values if DOSLABEL
a1547 3
/*
 * What is the OpenBSD portion of the disk?  Uses the MBR if applicable.
 */
d1551 2
a1552 53
	int has_bounds = 0;

	/* Defaults */
	/* XXX - reserve a cylinder for hp300? */
	starting_sector = 0;
	ending_sector = DL_GETDSIZE(lp);

#ifdef DOSLABEL
	/*
	 * If we have an MBR, use values from the OpenBSD partition.
	 */
	if (dosdp) {
		if (dosdp->dp_typ == DOSPTYP_OPENBSD) {
			struct partition *pp;
			u_int64_t new_end;
			int i;

			/* Set start and end based on fdisk partition bounds */
			starting_sector = letoh32(dosdp->dp_start);
			ending_sector = starting_sector + letoh32(dosdp->dp_size);

			/*
			 * If there are any BSD or SWAP partitions beyond
			 * ending_sector we extend ending_sector to include
			 * them.  This is done because the BIOS geometry is
			 * generally different from the disk geometry.
			 */
			for (i = new_end = 0; i < lp->d_npartitions; i++) {
				pp = &lp->d_partitions[i];
				if ((pp->p_fstype == FS_BSDFFS ||
				    pp->p_fstype == FS_SWAP) &&
				    DL_GETPSIZE(pp) + DL_GETPOFFSET(pp) >
					new_end)
					new_end = DL_GETPSIZE(pp) +
					    DL_GETPOFFSET(pp);
			}
			if (new_end > ending_sector)
				ending_sector = new_end;
		} else {
			/* Don't trounce the MBR */
			starting_sector = 63;
		}

		has_bounds = 1;
	}
#endif
#ifdef DPMELABEL
	if (dpme_label) {
		starting_sector = dpme_obsd_start;
		ending_sector = dpme_obsd_start + dpme_obsd_size;
		has_bounds = 1;
	}
#endif
d1554 1
a1554 1
	if (has_bounds) {
@


1.215
log
@Add '-h' flag, and '*' as a unit specifier for 'p' Editor command.
Both cause partition sizes to be displayed using a human readable
format with the units automatically chosen by looking at the smallest
partition in the disk label. Remove forceable humanization in 'A'
code and use '-h' in install scripts.

Prodded & ok deraadt@@, verbiage tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.214 2009/05/31 19:39:45 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.214 2009/05/31 19:39:45 krw Exp $";
a2292 1
	struct partition *pp;
@


1.214
log
@Always show the start and end of the OpenBSD area in units of
sectors, not any 'human' unit in force.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.213 2009/05/29 01:49:56 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.213 2009/05/29 01:49:56 krw Exp $";
a73 3
#define MEG(x)	((x) * 1024LL * (1024 / 512))
#define GIG(x)  (MEG(x) * 1024LL)

a516 7
	if (print_unit == '\0') {
		if (DL_BLKTOSEC(lp_org, MEG(10 * 1024)) > (ending_sector -
		    starting_sector))
			print_unit = 'm';
		else
			print_unit = 'g';
	}
d2293 1
d2296 1
a2296 1
	unit = toupper(unit);
@


1.213
log
@Clean up logic around exit values. Make getasciilabel() return 0
for success. Fix a couple of bugs where errors in checklabel() got
lost.

Make Editor 'q' and 'x' commands exit with 0 (ok) rather than 1.
i.e. non-zero exit value now reserved for failure, not a decision
to leave the disklabel unchanged. This allows the install script
to use the exit value to catch failures to write a disklabel.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.212 2009/05/17 02:49:45 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.212 2009/05/17 02:49:45 krw Exp $";
d2308 1
a2308 1
	psize(starting_sector, unit, lp);
d2310 1
a2310 1
	psize(ending_sector, unit, lp);
@


1.212
log
@No need to write mount point info twice in 'w' command in Editor.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.211 2009/05/17 01:17:12 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.211 2009/05/17 01:17:12 krw Exp $";
d343 1
a343 1
				return(1);
d358 1
a358 1
				return(1);
d457 1
a457 1
			return(1);
@


1.211
log
@Write out mountpoint info in writelabel() after label successfully
written, rather than every time editor_alloc() is called. Respect
'-n' for mountpoint info. Reduces surprise appearance of files when
you 'x' out of Editor.

"my sunglasses did not go dark" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.210 2009/05/17 01:06:56 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.210 2009/05/17 01:06:56 krw Exp $";
a439 2
			/* Save mountpoint info if there is any. */
			mpsave(&label);
@


1.210
log
@Initialize mountpoints[] when going past again:, since a
smaller alloc table will have fewer mountpoints and the
extras cause confusion. And any info from '/etc/fstab'
that was loaded into mountpoints needs to be zapped too.

Noticed by jim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.209 2009/05/13 17:02:46 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.209 2009/05/13 17:02:46 deraadt Exp $";
a659 2
	/* Save mountpoint info if there is any. */
	mpsave(lp);
@


1.209
log
@The auto-allocator does not remember to increase the d_npartitions field
as it adds partitions.  What the heck.  Set it to MAXPARTITIONS.  That is
the new way we are treating d_npartitions everywhere in any case.  It is the
max a label can support.  partitions which are not there mark themselves off.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.208 2009/05/13 01:31:58 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.208 2009/05/13 01:31:58 krw Exp $";
d533 4
@


1.208
log
@Set D_VENDOR when spoofing a label on archs that use D_VENDOR when
reading the native disklabel. This ensures cylinder alignment.

Fix disklabel to do cylinder alignment arithmetic correctly in -A
mode. Worked by accident before, since the code was protected by
D_VENDOR, which wasn't being set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.207 2009/05/12 00:54:48 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.207 2009/05/12 00:54:48 krw Exp $";
d534 1
@


1.207
log
@Various mount point handling fixes, most originally from halex@@.

Don't do fstabfile check everywhere. Always allocate and handle
mount point arrays. Use fstabfile to control 'n' command and writing
mount point info.

Since mount points are primed from /etc/fstab now, prime origmountpoints
so 'U' works.

'D' and 'z' now free current mount point info. 'U' will not lose
undo info when repeatedly invoked. 'n' accepts existing mount point
name as valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.206 2009/05/11 23:15:42 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.206 2009/05/11 23:15:42 krw Exp $";
a612 1
			chunksize -= cylsecs - chunkstart % cylsecs;
d614 2
a615 1
			chunkstart += cylsecs - chunkstart % cylsecs;
@


1.206
log
@Make sure last, catch-all, auto-allocated partition ends on a
cylinder boundary if SUN_CYLCHECK is defined. Don't bother rounding
any partition size to cylinder boundary if SUN_CYLCHECK is not
defined.

Should fix warning message on sparc64 noticed by dlg@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.205 2009/05/11 23:09:44 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.205 2009/05/11 23:09:44 deraadt Exp $";
d139 1
a139 1
int	mpsave(struct disklabel *);
d170 1
d173 4
a176 6
	if (fstabfile) {
		if (!(omountpoints = calloc(MAXPARTITIONS, sizeof(char *))) ||
		    !(origmountpoints = calloc(MAXPARTITIONS, sizeof(char *))) ||
		    !(tmpmountpoints = calloc(MAXPARTITIONS, sizeof(char *))))
			errx(4, "out of memory");
	}
d222 2
a223 1
	/* Save the (U|u)ndo labels, origmountpoints is already NULLs. */
d246 2
a247 4
			if (fstabfile) {
				mpcopy(tmpmountpoints, omountpoints);
				mpcopy(omountpoints, mountpoints);
			}
d276 1
a276 1
			if (ioctl(f, DIOCGPDINFO, &label) == 0)
d278 5
a282 1
			else
d346 9
a354 9
			if (fstabfile)
				mpsave(&label);
			/*
			 * If we haven't changed the label we started with, and
			 * it was not a default label or an auto-allocated
			 * label, there is no need to do anything before
			 * exiting. Note that 'w' will reset dflag and aflag to
			 * allow 'q' to exit with further questions.
			 */
d409 6
a414 4
			if (memcmp(&label, &origlabel, sizeof(label)) == 0 &&
			    (!fstabfile || mpequal(mountpoints, origmountpoints))) {
				puts("Nothing to undo!");
			} else {
d418 3
a420 7
				/* Restore mountpoints */
				if (fstabfile) {
					mpcopy(tmpmountpoints, mountpoints);
					mpcopy(mountpoints, origmountpoints);
					mpcopy(omountpoints, tmpmountpoints);
				}
				puts("All changes undone.");
d422 1
d426 7
a432 15
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0 &&
			    (!fstabfile || mpequal(mountpoints, omountpoints))) {
				puts("Nothing to undo!");
			} else {
				tmplabel = label;
				label = lastlabel;
				lastlabel = tmplabel;
				/* Restore mountpoints */
				if (fstabfile) {
					mpcopy(tmpmountpoints, mountpoints);
					mpcopy(mountpoints, omountpoints);
					mpcopy(omountpoints, tmpmountpoints);
				}
				puts("Last change undone.");
			}
d441 2
a442 2
			if (fstabfile)
				mpsave(&label);
d464 4
a467 2
			if (fstabfile)
				mpcopy(mountpoints, origmountpoints);
d483 1
a483 1
		    (!fstabfile || mpequal(mountpoints, omountpoints))) {
d485 1
a485 2
			if (fstabfile)
				mpcopy(omountpoints, tmpmountpoints);
d656 1
a656 2
	if (fstabfile)
		mpsave(lp);
d1862 1
a1862 1
int
d1870 3
d1889 1
a1889 1
			return(1);
d1899 9
a1907 9
	if ((fp = fopen(fstabfile, "w")) == NULL)
		return(1);

	for (i = 0; i < MAXPARTITIONS && mi[i].mountpoint != NULL; i++) {
		j =  mi[i].partno;
		fprintf(fp, "%s%c %s %s rw 1 %d\n", bdev, 'a' + j,
		    mi[i].mountpoint,
		    fstypesnames[lp->d_partitions[j].p_fstype],
		    j == 0 ? 1 : 2);
a1908 2
	fclose(fp);
	return(0);
d2144 1
a2144 1
				if (mountpoints[i] != NULL &&
d2148 2
a2149 1
				fprintf(stderr, "'%c' already being mounted at '%s'\n", 'a'+i, p);
@


1.205
log
@very long lines in comments are ugly
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.204 2009/05/11 23:09:28 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.204 2009/05/11 23:09:28 deraadt Exp $";
d585 3
d594 2
d597 1
d599 1
d604 1
@


1.204
log
@Always save an fstab file, even if it is empty; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.203 2009/05/03 22:01:46 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.203 2009/05/03 22:01:46 krw Exp $";
d347 5
a351 4
			 * If we haven't changed the label we started with, and it was not
			 * a default label or an auto-allocated label, there is no
			 * need to do anything before exiting. Note that 'w' will reset
			 * dflag and aflag to allow 'q' to exit with further questions.
@


1.203
log
@Prevent the entry of duplicate mount points while in Editor mode.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.202 2009/05/03 16:49:16 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.202 2009/05/03 16:49:16 deraadt Exp $";
d1863 1
a1863 1
	int i, j, mpset;
d1870 1
a1870 1
	for (i = 0, mpset = 0; i < MAXPARTITIONS; i++) {
a1873 1
			mpset = 1;
a1875 3
	/* Exit if there is nothing to do... */
	if (!mpset)
		return(0);
@


1.202
log
@Tune the medium profile to provide more /usr space as 'requested' by beck
also make the %'s add up to 100 again, which was part of the problem
ok krw otto
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.201 2009/04/30 06:56:34 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.201 2009/04/30 06:56:34 deraadt Exp $";
d2124 1
d2126 1
a2126 1
	struct partition *pp = &lp->d_partitions[partno];
d2142 8
@


1.201
log
@in the big configuration, tune /tmp so that it scales up a bit slower,
and benefit /home in exchange
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.200 2009/04/29 22:57:05 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.200 2009/04/29 22:57:05 deraadt Exp $";
d93 1
a93 1
	{  MEG(800),         GIG(2),  15, "/"		},
d95 2
a96 2
	{  MEG(900),         GIG(2),  10, "/usr"	},
	{  MEG(512),         GIG(4),  65, "/home"	}
@


1.200
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.199 2009/04/29 15:11:20 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.199 2009/04/29 15:11:20 otto Exp $";
d81 1
a81 1
	{   MEG(80),         GIG(4),  12, "/tmp"	},
d88 2
a89 1
	{    GIG(1),       GIG(300),  49, "/home"	}
@


1.199
log
@increase the max for medium a bit, so e.g. a 6GB disk gets fully used
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.198 2009/04/26 20:25:09 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.198 2009/04/26 20:25:09 deraadt Exp $";
d107 4
a110 1
const struct { const struct space_allocation *table; int sz; } alloc_table[] = {
@


1.198
log
@adjust the numbers for the "big" auto-allocation scheme with otto
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.197 2009/04/26 20:05:30 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.197 2009/04/26 20:05:30 deraadt Exp $";
d94 2
a95 2
	{  MEG(900),         GIG(1),  10, "/usr"	},
	{  MEG(512),         GIG(1),  65, "/home"	}
@


1.197
log
@Adjust the medium auto scale after looking at how it performs between the
low and high ends of the disk sizes it applies to; with otto
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.196 2009/04/26 19:49:50 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.196 2009/04/26 19:49:50 otto Exp $";
d75 1
d79 1
a79 1
	{   MEG(80),      MEG(1024),   5, "/"		},
d81 8
a88 8
	{   MEG(80),      MEG(4096),  10, "/tmp"	},
	{   MEG(80),      MEG(4096),  10, "/var"	},
	{ MEG(1024),      MEG(4096),  20, "/usr"	},
	{  MEG(512),      MEG(1024),   5, "/usr/X11R6"	},
	{ MEG(2048),    MEG(6*1024),   5, "/usr/local"	},
	{ MEG(1024),      MEG(2048),   5, "/usr/src"	},
	{ MEG(1200),      MEG(2048),   5, "/usr/obj"	},
	{  MEG(512), MEG(1024*1024),  30, "/home"	}
d92 1
a92 1
	{  MEG(800),      MEG(2048),  15, "/"		},
d94 2
a95 2
	{  MEG(900), MEG(1024*1024),  10, "/usr"	},
	{  MEG(512), MEG(1024*1024),  65, "/home"	}
d99 1
a99 1
	{  MEG(700),      MEG(4096),  95, "/"		},
@


1.196
log
@smarter auto-allocation; numbers needs tweaking, but we are getting
closer, ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.195 2009/04/26 01:23:40 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.195 2009/04/26 01:23:40 krw Exp $";
d91 1
a91 1
	{ MEG(1024),      MEG(2048),  25, "/"		},
d93 2
a94 2
	{ MEG(1024), MEG(1024*1024),  25, "/usr"	},
	{  MEG(512), MEG(1024*1024),  40, "/home"	}
d98 2
a99 2
	{  MEG(700),      MEG(4096),   95, "/"		},
	{    MEG(1),       MEG(256),    5, "swap"	}
d103 1
a103 1
	{  MEG(1),      MEG(2048),   100, "/"		}
@


1.195
log
@Fix 'n' (name mountpoint) Editor command. The check for the presence
of the -f flag was reversed.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.194 2009/04/23 00:00:06 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.194 2009/04/23 00:00:06 krw Exp $";
d27 1
d76 2
a77 1
struct space_allocation alloc[] = {
d79 1
a79 1
	{   MEG(80),      MEG(4096),   5, "swap"	},
d82 1
a82 1
	{ MEG(2048),     MEG(10240),  20, "/usr"	},
d84 1
a84 1
	{ MEG(2048),      MEG(5120),   5, "/usr/local"	},
d86 25
a110 2
	{ MEG(2048),      MEG(2048),   0, "/usr/obj"	},
	{  MEG(512), MEG(1024*1024),  35, "/home"	}
d490 11
d506 1
a506 1
editor_allocspace(struct disklabel *lp)
d508 2
d515 4
a518 1
	int i, j, lastalloc;
d521 1
a521 1
	find_bounds(lp);
d523 1
a523 1
		if (DL_BLKTOSEC(lp, MEG(10 * 1024)) > (ending_sector -
d530 21
a550 1
	cylsecs = lp->d_secpercyl;
a552 5
	if (totsecs < DL_BLKTOSEC(lp, alloc[0].minsz + alloc[1].minsz))
		/* Must have space for root and swap at least. */
		return;

	lastalloc = sizeof(alloc) / sizeof(alloc[0]);
d616 6
a621 3
			/* If this one doesn't fit, ignore subsequent ones. */
			totsecs += secs;
			break;
d645 2
@


1.194
log
@Unrevert reversion of r1.192. This time make sure 'aflag' is treated
the same way 'dflag' is treated. i.e. reset it when the label is
written out so a 'w' followed by a 'q' exits the editor without
further questions. Also set it whenever the 'A' command is executed.

Suggestions by Alexander Hall.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.193 2009/04/20 17:40:43 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.193 2009/04/20 17:40:43 deraadt Exp $";
d271 1
a271 1
			if (fstabfile) {
@


1.193
log
@No this change is wrong, because now 'w' followed by 'q' asks if you
are sure.  This will require another solution, based perhaps on comparing
against an earlier form of the label
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.191 2009/04/12 01:01:24 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.191 2009/04/12 01:01:24 krw Exp $";
d229 2
a230 1
			if (ioctl(f, DIOCGPDINFO, &label) == 0)
d232 1
a232 1
			else
d317 4
a320 3
			 * If we didn't manufacture a new default label and
			 * didn't change the label read from disk, there is no
			 * need to do anything before exiting.
d322 2
a323 1
			if (!dflag && memcmp(lp, &label, sizeof(label)) == 0) {
d423 1
a423 1
				dflag = 0;
@


1.192
log
@Alexander Hall points out that disklabel -AE <disk> followed by quitting
without making manual changes does not ask whether you'd like to save the
new automatic disklabel. Change to follow the behaviour of -d and ask
every time.  ok krw@@.
@
text
@d320 1
a320 2
			if (!aflag && !dflag &&
			    memcmp(lp, &label, sizeof(label)) == 0) {
@


1.191
log
@When auto-allocating, check the size of the disk and display
offset/size information in MB if the disk is <10G, and in GB
otherwise. '-p' will override this default.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.190 2009/04/11 23:57:56 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.190 2009/04/11 23:57:56 krw Exp $";
d320 2
a321 1
			if (!dflag && memcmp(lp, &label, sizeof(label)) == 0) {
@


1.190
log
@Always display any mountpoint info available. Thus a simple -A will
now show the planned mountpoint layout.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.189 2009/04/11 15:17:11 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.189 2009/04/11 15:17:11 krw Exp $";
d478 7
@


1.189
log
@Treat the list of auto-allocation partitions as a priority list and
stop auto-allocation as soon as a partition can't fit. Eliminate
the 'no space to allocate ...' messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.188 2009/04/10 21:16:51 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.188 2009/04/10 21:16:51 deraadt Exp $";
d504 1
a504 2
		if (fstabfile)
			partmp = &mountpoints[j];
d570 3
a572 5
			if (fstabfile) {
				free(*partmp);
				if ((*partmp = strdup(ap->mp)) == NULL)
					errx(4, "out of memory");
			}
@


1.188
log
@allow /usr/local to be up to 5MB in auto mode; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.187 2009/04/10 20:54:08 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.187 2009/04/10 20:54:08 krw Exp $";
d551 1
d553 1
a553 6
			fprintf(stderr, "no space to auto allocate %s\n", 
			    ap->mp);
			if (i == 0)
				break;
			else
				continue;
@


1.187
log
@Re-work '-A' so that it sets a flag that -E and -w use, and which will
just display the auto-allocation plan otherwise. Don't overwrite any
spoofed partitions, insert auto allocated partitions where we can.

This is much more install script and weird architecture friendly. I'm
talking about you, macppc.

Many suggestions and code from otto@@, feedback from many, cattle
prod applied by deraadt@@.

ok deraadt@@
"if it works for >8GB ... put it in" miod@@
"to be clear, ok" todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.186 2009/04/04 16:04:44 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.186 2009/04/04 16:04:44 krw Exp $";
d82 1
a82 1
	{ MEG(2048),      MEG(3072),   5, "/usr/local"	},
@


1.186
log
@Translate the size values in the auto-allocate table from blocks to
sectors at runtime instead of constantly converting the sector values
in the label to blocks. Adjust names accordingly. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.185 2009/04/03 23:18:11 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.185 2009/04/03 23:18:11 krw Exp $";
d75 11
a85 17
struct space_allocation alloc[MAXPARTITIONS] = {
	{   MEG(80),      MEG(1024),   5, "/"		},	/* a */
	{ MEG(1024),      MEG(4096),   5, "swap"	},	/* b */
	{         0,              0,   0, ""		},	/* c */
	{   MEG(80),      MEG(4096),  10, "/tmp"	},	/* d */
	{   MEG(80),      MEG(4096),  10, "/var"	},	/* e */
	{         0,              0,   0, ""		},	/* f */
	{ MEG(2048),     MEG(10240),  20, "/usr"	},	/* g */
	{  MEG(512),      MEG(1024),   5, "/usr/X11R6"	},	/* h */
	{         0,              0,   0, ""		},	/* i */
	{ MEG(2048),      MEG(3072),   5, "/usr/local"	},	/* j */
	{ MEG(1024),      MEG(2048),   5, "/usr/src"	},	/* k */
	{ MEG(2048),      MEG(2048),   0, "/usr/obj"	},	/* l */
	{  MEG(512), MEG(1024*1024),  35, "/home"	},	/* m */
	{         0,              0,   0, ""		},	/* n */
	{         0,              0,   0, ""		},	/* o */
	{         0,              0,   0, ""		}	/* p */
d89 2
a90 2
void	editor_allocspace(struct disklabel *, char **, int);
void	editor_add(struct disklabel *, char **, char *);
d93 1
a93 1
void	editor_delete(struct disklabel *, char **, char *);
d95 2
a96 2
void	editor_modify(struct disklabel *, char **, char *);
void	editor_name(struct disklabel *, char **, char *);
d109 1
a109 1
int	mpsave(struct disklabel *, char **, char *, char *);
d113 1
a113 1
int	get_mp(struct disklabel *, char **, int);
d121 1
a121 1
void	display_edit(struct disklabel *, char **, char, u_int64_t);
d131 1
a131 1
editor(struct disklabel *lp, int f, char *dev, char *fstabfile, int aflag)
d138 1
a138 1
	char **mountpoints = NULL, **omountpoints = NULL;
d143 1
a143 2
		if (!(mountpoints = calloc(MAXPARTITIONS, sizeof(char *))) ||
		    !(omountpoints = calloc(MAXPARTITIONS, sizeof(char *))) ||
d150 1
a150 1
	getdisktype(&label, "You need to specify a type for this disk.", dev);
d193 1
a193 1
	/* Save the (U)ndo label, origmountpoints is already NULLs. */
d195 1
d197 1
a197 5
	if (aflag)
		editor_allocspace(&label, mountpoints, 0);

	puts("Initial label editor (enter '?' for help at any prompt)");
	lastlabel = label;
d216 1
a216 1
			if (mountpoints != NULL) {
d229 4
a232 1
			editor_allocspace(&label, mountpoints, 1);
d235 1
a235 1
			editor_add(&label, mountpoints, arg);
d254 1
a254 1
			editor_delete(&label, mountpoints, arg);
d266 1
a266 1
			editor_modify(&label, mountpoints, arg);
d270 1
a270 1
			if (mountpoints == NULL) {
d275 1
a275 1
			editor_name(&label, mountpoints, arg);
d279 1
a279 2
			display_edit(&label, mountpoints, arg ? *arg : 0,
			    editor_countfree(&label));
d283 1
a283 1
			display(stdout, &label, mountpoints, arg ? *arg : 0, 0);
d313 2
a314 2
			if (mountpoints != NULL)
				mpsave(&label, mountpoints, dev, fstabfile);
d367 1
a367 1
				display(fp, &label, NULL, 0, 1);
d374 1
a374 2
			    (mountpoints == NULL || 
			    mpequal(mountpoints, origmountpoints))) {
d381 1
a381 1
				if (mountpoints != NULL) {
d392 1
a392 2
			    (mountpoints == NULL ||
			    mpequal(mountpoints, omountpoints))) {
d399 1
a399 1
				if (mountpoints != NULL) {
d414 2
a415 2
			if (mountpoints != NULL)
				mpsave(&label, mountpoints, dev, fstabfile);
d437 1
a437 1
			if (mountpoints != NULL)
d454 1
a454 2
		    (mountpoints == NULL || 
		    mpequal(mountpoints, omountpoints))) {
d456 1
a456 1
			if (mountpoints != NULL)
d467 1
a467 1
editor_allocspace(struct disklabel *lp, char **mp, int forcealloc)
d469 1
d471 7
a477 2
	daddr64_t secs, cylsecs, totsecs, xtrasecs;
	int i, lastpart;
d480 1
a480 1
	xtrasecs = totsecs = ending_sector - starting_sector;
d482 6
a487 6
	pp = &lp->d_partitions[0];
	for (i = 0; i < MAXPARTITIONS; i++, pp++) {
		if (i == RAW_PART)
			continue;
		if (DL_GETPSIZE(pp) != 0 && !forcealloc)
			return; 
d490 4
a493 5
		secs = alloc[i].minsz;
		if (secs == 0)
			continue;
		xtrasecs -= secs;
		lastpart = i;
d496 16
a511 23
	lp->d_npartitions = MAXPARTITIONS;

	pp = &lp->d_partitions[0];
	for (i = 0; i <= lastpart; i++, pp++) {
		switch (i) {
		case 0:
			DL_SETPSIZE(pp, 0);
			DL_SETPOFFSET(pp, starting_sector);
			break;
		case RAW_PART:
			continue;
		case RAW_PART+1:
			DL_SETPSIZE(pp, 0);
			DL_SETPOFFSET(pp,DL_GETPOFFSET(pp-2)+DL_GETPSIZE(pp-2));
			break;
		default:
			DL_SETPSIZE(pp, 0);
			DL_SETPOFFSET(pp,DL_GETPOFFSET(pp-1)+DL_GETPSIZE(pp-1));
			break;
		}
		if (i == lastpart) {
			if (totsecs > alloc[i].maxsz)
				secs = alloc[i].maxsz;
d515 1
a515 1
			secs = alloc[i].minsz;
d517 3
a519 3
				secs += (xtrasecs / 100) * alloc[i].rate;
			if (secs > alloc[i].maxsz)
				secs = alloc[i].maxsz;
d526 10
a535 3
			if (i == 0 && secs > starting_sector) {
				secs -= starting_sector;
				totsecs += starting_sector;
d537 6
d544 7
a550 1
		if (secs < alloc[i].minsz) {
d552 2
a553 2
			fprintf(stderr, "no space to auto allocate '%c'"
			    " (%s)\n", 'a'+i, alloc[i].mp);
d559 2
d562 1
a562 1
		pp->p_fstype = (i == 1) ? FS_SWAP : FS_BSDFFS;
d571 9
a579 4
		if (mp && alloc[i].mp[0] == '/') {
			free(mp[i]);
			if ((mp[i] = strdup(alloc[i].mp)) == NULL)
				errx(4, "out of memory");
d583 3
a585 4
	/* Zap remaining, unallocated partitions. */
	for (; i < MAXPARTITIONS; i++, pp++)
		if (i != RAW_PART)
			memset(pp, 0, sizeof(*pp));
d592 1
a592 1
editor_add(struct disklabel *lp, char **mp, char *p)
d690 1
a690 1
	    get_mp(lp, mp, partno) == 0 &&
d703 1
a703 1
editor_name(struct disklabel *lp, char **mp, char *p)
d739 1
a739 1
	get_mp(lp, mp, partno);
d746 1
a746 1
editor_modify(struct disklabel *lp, char **mp, char *p)
d778 1
a778 1
	    get_mp(lp, mp, partno) == 0 &&
d791 1
a791 1
editor_delete(struct disklabel *lp, char **mp, char *p)
d824 2
a825 5

	if (mp != NULL && mp[partno] != NULL) {
		free(mp[partno]);
		mp[partno] = NULL;
	}
d1080 2
a1081 2
				display_partition(stdout, lp, NULL, i, 0);
				display_partition(stdout, lp, NULL, j, 0);
d1548 5
a1552 3
		printf("Treating sectors %llu-%llu as the OpenBSD portion of the "
		    "disk.\nYou can use the 'b' command to change this.\n\n",
		    starting_sector, ending_sector);
d1557 4
a1560 2
		printf("Reserving the first data cylinder for boot blocks.\n"
		    "You can use the 'b' command to change this.\n\n");
d1792 1
a1792 1
mpsave(struct disklabel *lp, char **mp, char *cdev, char *fstabfile)
d1802 2
a1803 2
		if (mp[i] != NULL) {
			mi[i].mountpoint = mp[i];
d1812 3
a1814 3
	/* Convert cdev to bdev */
	if (strncmp(_PATH_DEV, cdev, sizeof(_PATH_DEV) - 1) == 0 &&
	    cdev[sizeof(_PATH_DEV) - 1] == 'r') {
d1816 1
a1816 1
		    &cdev[sizeof(_PATH_DEV)]);
d1818 1
a1818 1
		if ((p = strrchr(cdev, '/')) == NULL || *(++p) != 'r')
d1821 1
a1821 1
		snprintf(bdev, sizeof(bdev), "%s%s", cdev, p + 1);
d2053 1
a2053 1
get_mp(struct disklabel *lp, char **mp, int partno)
d2058 1
a2058 1
	if (mp != NULL && pp->p_fstype != FS_UNUSED &&
d2064 1
a2064 1
			    mp[partno] ? mp[partno] : "none");
d2070 2
a2071 2
				free(mp[partno]);
				mp[partno] = NULL;
d2076 2
a2077 2
				free(mp[partno]);
				if ((mp[partno] = strdup(p)) == NULL)
d2222 1
a2222 1
display_edit(struct disklabel *lp, char **mp, char unit, u_int64_t fr)
d2240 1
a2240 1
		display_partition(stdout, lp, mp, i, unit);
@


1.185
log
@Bring comment into line with other docs. -E(dit) is not just for
new labels.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.184 2009/03/30 10:51:37 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.184 2009/03/30 10:51:37 krw Exp $";
d67 3
a69 3
	daddr64_t	minblks;
	daddr64_t	maxblks;
	int		rate;		/* % of extra space to use */
d481 1
a481 1
	daddr64_t blks, cylblks, totblks, xtrablks;
d484 2
a485 2
	cylblks = DL_SECTOBLK(lp, lp->d_secpercyl);
	xtrablks = totblks = DL_SECTOBLK(lp, ending_sector - starting_sector);
a488 1
		blks = alloc[i].minblks;
d493 4
a496 1
		if (blks == 0)
d498 1
a498 1
		xtrablks -= blks;
d523 2
a524 2
			if (totblks > alloc[i].maxblks)
				blks = alloc[i].maxblks;
d526 1
a526 1
				blks = totblks;
d528 14
a541 14
			blks = alloc[i].minblks;
			if (xtrablks > 0)
				blks += (xtrablks / 100) * alloc[i].rate;
			if (blks > alloc[i].maxblks)
				blks = alloc[i].maxblks;
			blks = ((blks + cylblks - 1) / cylblks) * cylblks;
			totblks -= blks;
			while (totblks < 0) {
				blks -= cylblks;
				totblks += cylblks;
			}
			if (i == 0 && blks > DL_SECTOBLK(lp, starting_sector)) {
				blks -= DL_SECTOBLK(lp, starting_sector);
				totblks += DL_SECTOBLK(lp, starting_sector);
d544 2
a545 2
		if (blks < alloc[i].minblks) {
			totblks += blks;
d553 1
a553 1
		DL_SETPSIZE(pp, DL_BLKTOSEC(lp, blks));
@


1.184
log
@Oops. Document new 'U' editor command in '?' output too.

Prodded by & ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.183 2009/03/30 00:39:26 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.183 2009/03/30 00:39:26 deraadt Exp $";
d134 1
a134 1
 * Simple partition editor.  Primarily intended for new labels.
@


1.183
log
@lint; mostly unused variables, carefully checked against all platforms
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.182 2009/03/29 05:37:13 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.182 2009/03/29 05:37:13 deraadt Exp $";
d1716 6
a1721 6
"  ? [cmd]  - show help                  m [part] - modify partition\n"
"  A        - auto partition all space   n [part] - set mount point\n"
"  a [part] - add partition              p [unit] - print partitions\n"
"  b        - set OpenBSD boundaries     q        - quit & save changes\n"
"  c [part] - change partition size      s [path] - save label to file\n"
"  D        - reset label to default     r        - display free space\n"
d1727 1
@


1.182
log
@otto points out that the -v printing changes are incompatible with the
expectation that -R will read the output of disklabel.  I suspect we
will find another way to do this; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.180 2009/03/28 16:27:24 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.181 2009/03/28 17:50:05 deraadt Exp $";
d296 1
a296 1
			char *pager, *cmd = NULL;
d303 2
a304 2
			if (asprintf(&cmd, "gunzip -qc|%s", pager) != -1 &&
			    (fp = popen(cmd, "w")) != NULL) {
d310 1
a310 1
			free(cmd);
@


1.181
log
@do not crash when no mountpoints, spotted by otto; ok krw
@
text
@d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.180 2009/03/28 16:27:24 krw Exp $";
d291 1
a291 2
			display(stdout, &label, mountpoints, arg ? *arg : 0,
			   SHOW_PHYSINFO);
d375 1
a375 2
				display(fp, &label, NULL, 0, SHOW_PHYSINFO |
				    SHOW_PARTINFO);
@


1.180
log
@Move some output under the control of the '-v' flag. In particular only
display the partition info by default as is done in the E(ditor). The
physical info is now only displayed if '-v' is specified.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.179 2009/03/28 16:18:50 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.179 2009/03/28 16:18:50 krw Exp $";
d469 2
a470 1
			mpcopy(omountpoints, tmpmountpoints);
@


1.179
log
@Add 'U' command to E(ditor). It reverts label to state it was in
when entering E(ditor) mode. Clean up 'u' code and make more effort
to keep label and mountpoint info in sync. Makes 'u' undo-able so
those with vi fingers can apply and revert changes (with perhaps a
'p' or two in between) to validate changes.

'U' suggested by deraadt@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.178 2009/03/28 07:08:32 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.178 2009/03/28 07:08:32 otto Exp $";
d291 2
a292 1
			display(stdout, &label, mountpoints, arg ? *arg : 0, 0);
d376 2
a377 1
				display(fp, &label, NULL, 0, 1) ;
@


1.178
log
@for A, use real megs and gigs (power of 2 based); adapt the table to
include /usr/src and /usr/obj plus some tweaks; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.177 2009/03/22 19:58:43 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.177 2009/03/22 19:58:43 deraadt Exp $";
d112 1
a112 1
char **	mpcopy(char **, char **);
d139 1
a139 1
	struct disklabel lastlabel, tmplabel, label = *lp;
d144 2
a145 1
	char **mountpoints = NULL, **omountpoints = NULL, **tmpmountpoints = NULL;
d151 1
d200 3
d219 13
a232 1

a238 2
			tmplabel = lastlabel;
			lastlabel = label;
a241 6
			tmplabel = lastlabel;
			lastlabel = label;
			if (mountpoints != NULL) {
				mpcopy(tmpmountpoints, omountpoints);
				mpcopy(omountpoints, mountpoints);
			}
a242 4
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			if (mountpoints != NULL && mpequal(omountpoints, tmpmountpoints))
				mpcopy(omountpoints, tmpmountpoints);
a245 2
			tmplabel = lastlabel;
			lastlabel = label;
a246 2
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
a249 2
			tmplabel = lastlabel;
			lastlabel = label;
a250 2
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
d254 1
a254 3
			tmplabel = lastlabel;
			lastlabel = label;
			if (ioctl(f, DIOCGPDINFO, &label) == 0) {
d256 1
a256 1
			} else {
a257 2
				lastlabel = tmplabel;
			}
a260 6
			tmplabel = lastlabel;
			lastlabel = label;
			if (mountpoints != NULL) {
				mpcopy(tmpmountpoints, omountpoints);
				mpcopy(omountpoints, mountpoints);
			}
a261 4
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			if (mountpoints != NULL && mpequal(omountpoints, tmpmountpoints))
				mpcopy(omountpoints, tmpmountpoints);
a264 2
			tmplabel = lastlabel;
			lastlabel = label;
a265 2
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
a268 2
			tmplabel = lastlabel;
			lastlabel = label;
a269 2
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
a272 6
			tmplabel = lastlabel;
			lastlabel = label;
			if (mountpoints != NULL) {
				mpcopy(tmpmountpoints, omountpoints);
				mpcopy(omountpoints, mountpoints);
			}
a273 4
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
			if (mountpoints != NULL && mpequal(omountpoints, tmpmountpoints))
				mpcopy(omountpoints, tmpmountpoints);
a281 2
			mpcopy(tmpmountpoints, omountpoints);
			mpcopy(omountpoints, mountpoints);
a282 2
			if (mpequal(omountpoints, tmpmountpoints))
				mpcopy(omountpoints, tmpmountpoints);
d380 19
d401 2
a402 2
			    mountpoints != NULL &&
			    mpequal(mountpoints, omountpoints)) {
d409 2
a410 1
				if (mountpoints != NULL)
d412 2
a445 2
			tmplabel = lastlabel;
			lastlabel = label;
d447 2
d458 11
d1735 1
a1735 1
char **
a1754 1
	return(to);
@


1.177
log
@let u (undo) work for the A command; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.176 2009/03/22 19:01:32 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.176 2009/03/22 19:01:32 krw Exp $";
d73 2
d76 16
a91 16
	{   156250,    1953125,   5, "/"	  }, /* a  80MB ->   1GB */
	{  1953125,    7812500,   5, "swap"	  }, /* b   1GB ->   4GB */
	{        0,          0,   0, ""		  }, /* c                */
	{   156250,    1953125,   5, "/tmp"	  }, /* d  80MB ->   1GB */
	{   156250,    1953125,   5, "/var"	  }, /* e  80MB ->   1GB */
	{        0,          0,   0, ""		  }, /* f                */
	{  3906250,   19531250,  20, "/usr"	  }, /* g   2GB ->  10GB */
	{  1000000,    1953125,   5, "/usr/X11R6" }, /* h 512MB ->   1GB */
	{        0,          0,   0, ""		  }, /* i                */
	{  3906250,    5859375,   5, "/usr/local" }, /* j   2GB ->   3GB */
	{     1953, 1953125000,  50, "/home"	  }, /* k 512MB ->   1TB */
	{        0,          0,   0, ""		  }, /* l */
	{        0,          0,   0, ""		  }, /* m */
	{        0,          0,   0, ""		  }, /* n */
	{        0,          0,   0, ""		  }, /* o */
	{        0,          0,   0, ""		  }  /* p */
@


1.176
log
@Add 'A' command to Editor mode, and -A flag to automatically execute it
on disks without an existing label. The 'A' command allocates all space
on the disk into a reasonable partition scheme for a root disk.

Feedback from several, time to work on it in-tree.

Prodded (repeatedly) by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.175 2009/03/07 02:12:00 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.175 2009/03/07 02:12:00 krw Exp $";
d220 2
@


1.175
log
@"Numer of " -> "Number of ". Typo from r1.1.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.174 2009/01/11 19:44:57 miod Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.174 2009/01/11 19:44:57 miod Exp $";
d64 28
d93 1
d135 1
a135 1
editor(struct disklabel *lp, int f, char *dev, char *fstabfile)
d196 3
d219 3
d475 101
d1717 11
a1727 11
"  ? [command] - show help                  n [part] - set mount point\n"
"  a [part]    - add partition              p [unit] - print partitions\n"
"  b           - set OpenBSD boundaries     q        - quit & save changes\n"
"  c [part]    - change partition size      r        - display free space\n"
"  D           - reset label to default     s [path] - save label to file\n"
"  d [part]    - delete partition           u        - undo last change\n"
"  e           - edit drive parameters      w        - write label to disk\n"
"  g [d | u]   - [d]isk or [u]ser geometry  X        - toggle expert mode\n"
"  l [unit]    - print disk label header    x        - exit & lose changes\n"
"  M           - disklabel(8) man page      z        - delete all partitions\n"
"  m [part]    - modify partition\n"
d2056 2
a2057 4
				if (mp[partno] != NULL) {
					free(mp[partno]);
					mp[partno] = NULL;
				}
d2062 1
a2062 2
				if (mp[partno] != NULL)
					free(mp[partno]);
@


1.174
log
@On *ppc disks shared with MacOS, walk the Apple partition map to find out
the bounds of the OpenBSD area. Should prevent users from shooting themselves
in the feet.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.173 2008/12/07 18:31:29 cnst Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.173 2008/12/07 18:31:29 cnst Exp $";
d1013 1
a1013 1
		    "The Numer of sectors per track.", lp->d_nsectors,
@


1.173
log
@clean up find_bounds(), no binary change;  'dead initialisation' llvm/clang;  ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.172 2008/12/07 01:11:50 cnst Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.172 2008/12/07 01:11:50 cnst Exp $";
d1347 2
d1390 12
d1405 7
a1412 6
#elif (NUMBOOT == 1)
	/* Boot blocks take up the first cylinder */
	starting_sector = lp->d_secpercyl;
	printf("Reserving the first data cylinder for boot blocks.\n"
	    "You can use the 'b' command to change this.\n\n");
#endif
@


1.172
log
@fix an 11-year-old typo in an if statement;  'null dereference' llvm/clang;  ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.171 2008/09/03 11:13:54 jsg Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.171 2008/09/03 11:13:54 jsg Exp $";
a1346 5
#ifdef DOSLABEL
	struct partition *pp = &lp->d_partitions[RAW_PART];
	u_int64_t new_end;
	int i;
#endif
d1357 5
a1361 1
	    if (dosdp->dp_typ == DOSPTYP_OPENBSD) {
@


1.171
log
@Missing break in case statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.170 2008/08/10 11:22:40 sobrado Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.170 2008/08/10 11:22:40 sobrado Exp $";
d369 1
a369 1
				if (arg == NULL && *arg == '\0')
@


1.170
log
@add missing space.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.169 2008/08/10 02:03:06 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.169 2008/08/10 02:03:06 krw Exp $";
d1431 1
@


1.169
log
@Shorten the lines of '?' output in edit mode. A couple were too
long (>76 chars) for the install script space on the CD jackets.

Requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.168 2008/06/25 18:31:07 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.168 2008/06/25 18:31:07 otto Exp $";
d1573 1
a1573 1
"  g [d|u]     - [d]isk or [u]ser geometry  X        - toggle expert mode\n"
@


1.168
log
@In interactive mode, always suggest offsets and sizes inside the
OpenBSD area and change the 'p' command to only print the boundaries
and size of the OpenBSD area and the free space within that area.
Introduce a 'l' command to print the header only. With krw@@; ok krw@@
deraadt@@; jmc@@ for the man page bits
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.167 2008/04/13 15:54:59 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.167 2008/04/13 15:54:59 krw Exp $";
d1566 10
a1575 10
"  ? [command] - show help                   n [part] - set mount point\n"
"  a [part]    - add partition               p [unit] - print partitions\n"
"  b           - set OpenBSD boundaries      q        - quit & save changes\n"
"  c [part]    - change partition size       r        - display free space\n"
"  D           - reset label to default      s [path] - save label to file\n"
"  d [part]    - delete partition            u        - undo last change\n"
"  e           - edit drive parameters       w        - write label to disk\n"
"  g [d|u]     - [d]isk or [u]ser geometry   X        - toggle expert mode\n"
"  l [unit]    - print disk label header     x        - exit w/o saving changes\n"
"  M           - disklabel(8) man page       z        - delete all partitions\n"
@


1.167
log
@Redo the '?' output in (E)ditor mode so it uses two columns and once
again fits on one page. Suggested by, tweaked and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.166 2008/01/26 15:37:59 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.166 2008/01/26 15:37:59 krw Exp $";
d96 1
d286 1
a286 1
			display(stdout, &label, mountpoints, arg ? *arg : 0, 1,
d290 4
d375 1
a375 1
				display(fp, &label, NULL, 0, 0, 0);
d1317 4
d1325 4
d1427 7
a1433 1
"The 'p' command prints the current disk label.  By default, it prints the\n"
d1567 1
a1567 1
"  a [part]    - add partition               p [unit] - print label\n"
d1574 3
a1576 2
"  M           - disklabel(8) man page       x        - exit w/o saving changes\n"
"  m [part]    - modify partition            z        - delete all partitions\n"
d2048 33
@


1.166
log
@getuint() doesn't use its partno argument. So eliminate it. No
functional change. Noticed by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.165 2008/01/25 16:52:34 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.165 2008/01/25 16:52:34 krw Exp $";
a1545 20
		puts("\t? [cmnd]  - this message or command specific help.");
		puts("\ta [part]  - add new partition.");
		puts("\tb         - set OpenBSD disk boundaries.");
		puts("\tc [part]  - change partition size.");
		puts("\tD         - set label to default.");
		puts("\td [part]  - delete partition.");
		puts("\te         - edit drive parameters.");
		puts("\tg [d|u]   - use [d]isk or [u]ser geometry.");
		puts("\tM         - show entire OpenBSD man page for disklabel.");
		puts("\tm [part]  - modify existing partition.");
		puts("\tn [part]  - set the mount point for a partition.");
		puts("\tp [unit]  - print label.");
		puts("\tq         - quit and save changes.");
		puts("\tr         - recalculate & display free space details.");
		puts("\ts [path]  - save label to file.");
		puts("\tu         - undo last change.");
		puts("\tw         - write label to disk.");
		puts("\tX         - toggle expert mode.");
		puts("\tx         - exit without saving changes.");
		puts("\tz         - zero out partition table.");
d1547 15
a1561 6
"Numeric parameters may use suffixes to indicate units:\n\t"
"'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm' for megabytes,\n\t"
"'g' for gigabytes or no suffix for sectors (usually 512 bytes).\n\t"
"'%' for percent of total disk size, '&' for percent of free space.\n\t"
"Non-sector units will be rounded to the nearest cylinder.\n"
"Entering '?' at most prompts will give you (simple) context sensitive help.");
@


1.165
log
@Fix my screwup and don't return NULL from sort_paritions.

Problem found by ckuethe@@, slightly different fix than the one
proposed by otto@@ applied.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.164 2008/01/22 01:47:33 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.164 2008/01/22 01:47:33 krw Exp $";
d73 1
a73 1
u_int64_t getuint(struct disklabel *, int, char *, char *, u_int64_t, u_int64_t, u_int64_t, int);
d769 1
a769 1
getuint(struct disklabel *lp, int partno, char *prompt, char *helpstring,
d1007 1
a1007 1
		ui = getuint(lp, 0, "sectors/track",
d1023 1
a1023 1
		ui = getuint(lp, 0, "tracks/cylinder",
d1039 1
a1039 1
		ui = getuint(lp, 0, "sectors/cylinder",
d1056 1
a1056 1
		ui = getuint(lp, 0, "number of cylinders",
d1074 1
a1074 1
		ui = getuint(lp, 0, "total sectors",
d1109 1
a1109 1
		ui = getuint(lp, 0, "rpm",
d1125 1
a1125 1
		ui = getuint(lp, 0, "interleave",
d1256 1
a1256 1
		ui = getuint(lp, 0, "Starting sector",
d1268 1
a1268 1
		ui = getuint(lp, 0, "Size ('*' for entire disk)",
d1677 1
a1677 1
	ui = getuint(lp, partno, "offset",
d1726 1
a1726 1
	ui = getuint(lp, partno, "size", "Size of the partition. "
d1772 1
a1772 1
		ui = getuint(lp, partno, "fragment size",
d1807 1
a1807 1
		ui = getuint(lp, partno, "block size",
d1862 1
a1862 1
			ui = getuint(lp, partno, "FS type (decimal)",
@


1.164
log
@Another sneaky 32 bit variable trying to hold 64 bit values. This time
in find_bounds() when processing a DOS MBR.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.163 2008/01/22 01:31:27 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.163 2008/01/22 01:31:27 krw Exp $";
a1153 3

	if (npartitions == 0)
		return(NULL);
@


1.163
log
@Use u_int64_t variables to hold partition offsets when calculating
offsets and sizes of free chunks. 32 bits just won't hack new big
partitions. Simplify and clarify code while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.162 2008/01/22 01:12:50 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.162 2008/01/22 01:12:50 krw Exp $";
d1339 2
a1352 2
			u_int32_t i, new_end;

@


1.162
log
@Make sort_partitions() even more consistant with free_chunks() by not
returning the number of elements. Check for terminating empty entry
(i.e. NULL) instead. Code a bit clearer and shorter with fewer
variables. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.161 2008/01/22 00:19:18 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.161 2008/01/22 00:19:18 krw Exp $";
d1292 1
d1314 9
a1322 17
		if (spp[i + 1] != NULL) {
			u_int o1 = DL_GETPOFFSET(spp[i]) + DL_GETPSIZE(spp[i]);
			u_int o2 = DL_GETPOFFSET(spp[i+1]);
			if (o1 < o2) {
				chunks[numchunks].start = o1;
				chunks[numchunks].stop = o2;
				numchunks++;
			}
		} else {
			u_int o1 = DL_GETPOFFSET(spp[i]) + DL_GETPSIZE(spp[i]);
			/* Last partition */
			if (o1 < ending_sector) {

				chunks[numchunks].start = o1;
				chunks[numchunks].stop = ending_sector;
				numchunks++;
			}
@


1.161
log
@Kill redundant loop to find number of partitions to sort. We no longer
calloc() the memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.160 2008/01/22 00:06:25 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.160 2008/01/22 00:06:25 krw Exp $";
d76 1
a76 1
struct partition **sort_partitions(struct disklabel *, u_int16_t *);
a904 1
	u_int16_t npartitions;
d908 2
a909 2
	/* Get a sorted list of the partitions */
	spp = sort_partitions(lp, &npartitions);
d911 3
a913 2
	if (npartitions < RAW_PART)
		return(0);			/* nothing to do */
d916 2
a917 2
	for (i = 0; i < npartitions; i++) {
		for (j = i + 1; j < npartitions; j++) {
d1141 1
a1141 1
sort_partitions(struct disklabel *lp, u_int16_t *npart)
d1144 1
a1144 2
	u_int16_t npartitions;
	int i;
a1154 1
	*npart = npartitions;
a1289 1
	u_int16_t npartitions;
d1294 2
a1295 2
	/* Sort the partitions based on offset */
	spp = sort_partitions(lp, &npartitions);
d1298 1
a1298 1
	if (spp == NULL) {
d1307 1
a1307 1
	if (spp && DL_GETPOFFSET(spp[0]) > starting_sector) {
d1312 2
a1313 2
	for (i = 0; i < npartitions; i++) {
		if (i + 1 < npartitions) {
@


1.160
log
@Replace a frequent calloc/free dance for sorted partitions with a
static array that we zero before each use. heapsort(3) shouldn't
care.

"should be fine" beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.159 2008/01/16 23:00:21 chl Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.159 2008/01/16 23:00:21 chl Exp $";
a1148 1
	/* How many "real" partitions do we have? */
d1153 1
a1153 1
			npartitions++;
d1155 3
a1157 2
	if (npartitions == 0) {
		*npart = 0;
a1158 8
	}

	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    DL_GETPSIZE(&lp->d_partitions[i]) != 0)
			spp[npartitions++] = &lp->d_partitions[i];
	}
a1168 1
	*npart = npartitions;
@


1.159
log
@remove "unused variable" warning

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.158 2008/01/12 20:06:57 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.158 2008/01/12 20:06:57 krw Exp $";
d912 1
a912 2
	if (npartitions < RAW_PART) {
		(void)free(spp);
a913 1
	}
a946 1
				(void)free(spp);
a951 1
	(void)free(spp);
d1143 1
a1144 1
	struct partition **spp;
d1147 2
a1160 3
	/* Create an array of pointers to the partition data */
	if ((spp = calloc(npartitions, sizeof(struct partition *))) == NULL)
		errx(4, "out of memory");
a1346 1
	(void)free(spp);
@


1.158
log
@Check for expert mode/FFS inside get_fsize() and get_bsize() and
reduce meat of editor_add() && editor_modify() to single if statements
checking for != 0 from all get_* functions. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.157 2008/01/12 19:39:40 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.157 2008/01/12 19:39:40 krw Exp $";
d444 1
a444 1
	u_int64_t freesectors, ui, new_offset, new_size;
d595 1
a595 2
	struct diskchunk *chunks;
	int partno, i;
a1422 1
	struct partition *pp;
@


1.157
log
@has_overlap() now always tries to resolve overlaps because it is only
called during -E initialization.  Thus it no longer needs the
'resolve' parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.156 2008/01/12 19:20:29 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.156 2008/01/12 19:20:29 krw Exp $";
d533 6
a538 3
	/* Get offset */
	if (get_offset(lp, partno) != 0) {
		DL_SETPSIZE(pp, 0);		/* effective delete */
a539 13
	}

	/* Get size */
	if (get_size(lp, partno) != 0) {
		DL_SETPSIZE(pp, 0);		/* effective delete */
		return;
	}

	/* Get filesystem type and mountpoint */
	if (get_fstype(lp, partno) != 0 || get_mp(lp, mp, partno) != 0) {
		DL_SETPSIZE(pp, 0);		/* effective delete */
		return;
	}
d541 2
a542 7
	if (expert && pp->p_fstype == FS_BSDFFS) {
		/* Get fsize and bsize */
		if (get_fsize(lp, partno) != 0 || get_bsize(lp, partno) != 0) {
			DL_SETPSIZE(pp, 0);		/* effective delete */
			return;
		}
	}
d622 6
a627 3
	/* Get offset */
	if (get_offset(lp, partno) != 0) {
		*pp = origpart;			/* undo changes */
a628 7
	}

	/* Get size */
	if (get_size(lp, partno) != 0) {
		DL_SETPSIZE(pp, 0);		/* effective delete */
		return;
	}
d630 2
a631 19
	/* Get filesystem type */
	if (get_fstype(lp, partno) != 0) {
		*pp = origpart;			/* undo changes */
		return;
	}

	/* get mount point */
	if (get_mp(lp, mp, partno) != 0) {
		*pp = origpart;			/* undo changes */
		return;
	}

	if (expert && pp->p_fstype == FS_BSDFFS) {
		/* Get fsize and bsize */
		if (get_fsize(lp, partno) != 0 || get_bsize(lp, partno) != 0) {
			*pp = origpart;		/* undo changes */
			return;
		}
	}
d1793 3
d1824 3
@


1.156
log
@Tweak get_offset() so it does it's own free chunks to check the
new offset being in a free area.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.155 2008/01/12 18:57:06 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.155 2008/01/12 18:57:06 krw Exp $";
d74 1
a74 1
int	has_overlap(struct disklabel *, int);
d132 1
a132 1
	if (has_overlap(&label, 1))
d935 2
a936 3
 * Check for partition overlap in lp and prompt the user
 * to resolve the overlap if any is found.  Returns 1
 * if unable to resolve, else 0.
d939 1
a939 1
has_overlap(struct disklabel *lp, int resolve)
a970 6
				/* Did they ask us to resolve it ourselves? */
				if (resolve != 1) {
					(void)free(spp);
					return(1);
				}

d987 1
a987 1
				return(has_overlap(lp, resolve));
@


1.155
log
@Change editor_countfree() to return the count rather than recording it
in a semi-global. Call it whenever the count is needed rather than
trying to make sure it is called anytime the value might change.
Eliminates a bunch of now unnecessary *freep parameters and calls to
editor_countfree().
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.154 2008/01/12 18:23:32 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.154 2008/01/12 18:23:32 krw Exp $";
d89 1
a89 1
int	get_offset(struct disklabel *, int, struct diskchunk *);
d534 1
a534 1
	if (get_offset(lp, partno, chunks) != 0) {
a636 4
	pp->p_fstype = FS_UNUSED;
	chunks = free_chunks(lp);
	pp->p_fstype = origpart.p_fstype;

d638 1
a638 1
	if (get_offset(lp, partno, chunks) != 0) {
d1743 1
a1743 1
get_offset(struct disklabel *lp, int partno, struct diskchunk *chunks)
d1745 1
d1748 1
a1748 1
	int i;
d1771 4
@


1.154
log
@Parameter 'new' to get_size() no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.153 2008/01/12 18:15:22 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.153 2008/01/12 18:15:22 krw Exp $";
d64 5
a68 5
void	edit_parms(struct disklabel *, u_int64_t *);
void	editor_add(struct disklabel *, char **, u_int64_t *, char *);
void	editor_change(struct disklabel *, u_int64_t *, char *);
void	editor_countfree(struct disklabel *, u_int64_t *);
void	editor_delete(struct disklabel *, char **, u_int64_t *, char *);
d70 1
a70 1
void	editor_modify(struct disklabel *, char **, u_int64_t *, char *);
d79 1
a79 1
void	set_bounds(struct disklabel *, u_int64_t *);
d90 1
a90 1
int	get_size(struct disklabel *, int, u_int64_t *);
d94 1
a94 1
void	zero_partitions(struct disklabel *, u_int64_t *);
a109 1
	u_int64_t freesectors;
a134 3
	/* Get initial value for freesectors. */
	editor_countfree(&label, &freesectors);

d193 1
a193 1
			editor_add(&label, mountpoints, &freesectors, arg);
d203 1
a203 1
			set_bounds(&label, &freesectors);
d211 1
a211 1
			editor_change(&label, &freesectors, arg);
a220 1
				editor_countfree(&label, &freesectors);
d234 1
a234 1
			editor_delete(&label, mountpoints, &freesectors, arg);
d244 1
a244 1
			edit_parms(&label, &freesectors);
d264 1
a264 1
			editor_modify(&label, mountpoints, &freesectors, arg);
d286 1
a286 1
			    freesectors);
d346 1
a346 2
			/* Recalculate & display free space. */
			editor_countfree(&label, &freesectors);
d355 1
a355 1
			    freesectors);
a383 2
				/* Recalculate free space */
				editor_countfree(&label, &freesectors);
d421 1
a421 1
			zero_partitions(&label, &freesectors);
d438 1
a438 1
editor_add(struct disklabel *lp, char **mp, u_int64_t *freep, char *p)
d444 3
a446 1
	u_int64_t ui, new_offset, new_size;
d450 1
a450 1
	if ((lp->d_flags & D_VENDOR) && *freep < lp->d_secpercyl) {
d457 1
a457 1
	if (*freep == 0) {
d540 1
a540 1
	if (get_size(lp, partno, freep) != 0) {
d607 1
a607 1
editor_modify(struct disklabel *lp, char **mp, u_int64_t *freep, char *p)
a638 1
	editor_countfree(lp, freep);
d648 1
a648 1
	if (get_size(lp, partno, freep) != 0) {
d678 1
a678 1
editor_delete(struct disklabel *lp, char **mp, u_int64_t *freep, char *p)
d693 1
a693 1
		zero_partitions(lp, freep);
a715 1
	editor_countfree(lp, freep);
d722 1
a722 1
editor_change(struct disklabel *lp, u_int64_t *freep, char *p)
d753 1
a753 1
	get_size(lp, partno, freep);
d1008 1
a1008 1
edit_parms(struct disklabel *lp, u_int64_t *freep)
d1011 1
a1011 1
	u_int64_t ui;
d1143 2
a1144 1
			if (DL_GETDSIZE(lp) - ui > *freep)
d1148 1
a1148 1
				    DL_GETDSIZE(lp) - ui, *freep);
a1157 1
	editor_countfree(lp, freep);
d1317 1
a1317 1
set_bounds(struct disklabel *lp, u_int64_t *freep)
a1345 3

	/* Recalculate the free sectors */
	editor_countfree(lp, freep);
d1467 2
a1468 2
void
editor_countfree(struct disklabel *lp, u_int64_t *freep)
d1472 1
a1474 1
	*freep = 0;
d1478 3
a1480 1
		*freep += chunks[i].stop - chunks[i].start;
d1791 1
a1791 1
get_size(struct disklabel *lp, int partno, u_int64_t *freep)
a1821 1
		editor_countfree(lp, freep);
d2074 1
a2074 1
zero_partitions(struct disklabel *lp, u_int64_t *freep)
a2080 1
	editor_countfree(lp, freep);
@


1.153
log
@Introduce the function max_partition_size() to calculate the max size
a partition can be without causing overlap. Use it to eliminate the
need to check overlap in get_size() and to make the (c)hange command
message more meaningful, i.e. mention max size allowed not the amount
of total free space.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.152 2008/01/11 22:46:06 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.152 2008/01/11 22:46:06 krw Exp $";
d90 1
a90 1
int	get_size(struct disklabel *, int, u_int64_t *, int);
d546 1
a546 1
	if (get_size(lp, partno, freep, 1) != 0) {
d655 1
a655 1
	if (get_size(lp, partno, freep, 0) != 0) {
d761 1
a761 1
	get_size(lp, partno, freep, 0);
d1800 1
a1800 1
get_size(struct disklabel *lp, int partno, u_int64_t *freep, int new)
@


1.152
log
@Remove one level of epicycles by not looping in get_size() or
get_offset() when the user enters an invalid value. Just abort the
partition operation and return to the main prompt. Prevents users
getting trapped because they don't know about ^D. Requested by
deraadt@@.

Tweak an error message to remove ambiguity about what 'between x and
y' means.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.151 2008/01/11 20:14:34 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.151 2008/01/11 20:14:34 krw Exp $";
d95 1
d756 3
a758 2
	printf("Partition %c is currently %llu sectors in size (%llu free).\n",
	    p[0], DL_GETPSIZE(pp), *freep);
d1803 3
a1805 1
	u_int64_t ui, old_psize;
d1809 1
a1809 2
	    DL_GETPSIZE(pp), *freep + (new ? 0 : DL_GETPSIZE(pp)),
	    DL_GETPOFFSET(pp),
d1826 3
a1828 3
	else if (ui > *freep + (new ? 0 : DL_GETPSIZE(pp)))
		fprintf(stderr,"Sorry, there are only %llu "
		    "sectors left\n", *freep);
a1829 1
		old_psize = DL_GETPSIZE(pp);
d1831 2
a1832 8
		if (has_overlap(lp, 0)) {
			fprintf(stderr, "\nPartition '%c' not added\n",
			    'a' + partno);
			DL_SETPSIZE(pp, old_psize);
		} else {
			editor_countfree(lp, freep);
			return (0);
		}	
d2092 23
@


1.151
log
@Don't allow (a)dd or (m)odify to create 0 length partitions. Don't
allow editing the fsize/bsize FFS values for FS_UNUSED partitions.

ok (for at least the first bit) miod@@ weingart@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.150 2008/01/10 04:00:09 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.150 2008/01/10 04:00:09 krw Exp $";
d1760 15
a1774 17
	for (;;) {
		ui = getuint(lp, partno, "offset",
		   "Starting sector for this partition.",
		   DL_GETPOFFSET(pp),
		   DL_GETPOFFSET(pp), 0, DO_CONVERSIONS |
		   (pp->p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui < starting_sector || ui >= ending_sector)
			fprintf(stderr, "The offset must be between "
			    "sector %llu and sector %llu, the limits of\n"
			    "the OpenBSD portion of the disk. "
			    "The 'b' command can change these limits.\n",
			    starting_sector, ending_sector);
d1776 3
a1778 3
		else if (partno == 0 && ui != 0)
			fprintf(stderr, "This architecture requires that "
			    "partition 'a' start at sector 0.\n");
d1780 9
a1788 13
		else {
			for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0;
			     i++) {
				if (ui < chunks[i].start ||
				    ui >= chunks[i].stop)
					continue;
				DL_SETPOFFSET(pp, ui);
				maxsize = chunks[i].stop - DL_GETPOFFSET(pp);
				if (DL_GETPSIZE(pp) > maxsize)
					DL_SETPSIZE(pp, maxsize);
				return (0);
			}
			fputs("The offset must be in a free area.\n", stderr);
d1790 1
d1792 3
d1803 34
a1836 32
	for (;;) {
		ui = getuint(lp, partno, "size", "Size of the partition. "
		    "You may also say +/- amount for a relative change.",
		    DL_GETPSIZE(pp), *freep + (new ? 0 : DL_GETPSIZE(pp)),
		    DL_GETPOFFSET(pp),
		    DO_CONVERSIONS | ((pp->p_fstype == FS_BSDFFS ||
		    pp->p_fstype == FS_SWAP) ?  DO_ROUNDING : 0));
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui == 0)
			fputs("The size must be > 0\n", stderr);
		else if (ui + DL_GETPOFFSET(pp) > ending_sector)
			fprintf(stderr, "The size can't be more than "
			    "%llu sectors, or the partition would\n"
			    "extend beyond the last sector (%llu) of the "
			    "OpenBSD portion of\nthe disk. "
			    "The 'b' command can change this limit.\n",
			    ending_sector - DL_GETPOFFSET(pp), ending_sector);
		else if (ui > *freep + (new ? 0 : DL_GETPSIZE(pp)))
			fprintf(stderr,"Sorry, there are only %llu "
			    "sectors left\n", *freep);
		else {
			old_psize = DL_GETPSIZE(pp);
			DL_SETPSIZE(pp, ui);
			if (has_overlap(lp, 0))
				DL_SETPSIZE(pp, old_psize);
			else
				break;
		}
d1838 3
a1840 2
	editor_countfree(lp, freep);
	return(0);
@


1.150
log
@Minor aligning of code and comments between editor_add() and
editor_modify(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.149 2008/01/08 23:46:54 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.149 2008/01/08 23:46:54 krw Exp $";
d545 1
a545 1
	if (get_size(lp, partno, freep, 1) != 0 || DL_GETPSIZE(pp) == 0) {
d654 1
a654 1
	if (get_size(lp, partno, freep, 0) != 0 || DL_GETPSIZE(pp) == 0) {
d671 1
a671 1
	if (expert && (pp->p_fstype == FS_BSDFFS || pp->p_fstype == FS_UNUSED)){
d1817 2
@


1.149
log
@Beef up the (r)ecalculate command in -E mode by having it display the
details of the free space it calculates. Gives an easy way to see all
the chunks of free sectors on the disk.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.148 2008/01/08 13:12:26 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.148 2008/01/08 13:12:26 krw Exp $";
d557 1
a557 1
		/* Get fsize, bsize, and cpg */
d672 2
a673 8
		/* get fsize */
		if (get_fsize(lp, partno) != 0) {
			*pp = origpart;		/* undo changes */
			return;
		}

		/* get bsize */
		if (get_bsize(lp, partno) != 0) {
@


1.148
log
@Ensure that the initial free space chunk can't have a length <= 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.147 2008/01/08 13:07:10 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.147 2008/01/08 13:07:10 krw Exp $";
d347 16
a362 5
		case 'r':
		    /* Recalculate free space */
		    editor_countfree(&label, &freesectors);
		    puts("Recalculated free space.");
		    break;
d1593 2
a1594 3
"The 'r' command is used to recalculate the free space available.  This option\n"
"should really not be necessary under normal circumstances but can be useful if\n"
"disklabel gets confused.\n");
d1649 1
a1649 1
		puts("\tr         - recalculate free space.");
@


1.147
log
@Do initial free space count *after* resolving overlapping partitions.
This removes the last need for has_overlap() to touch the free space
counter. So eliminate that parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.146 2008/01/07 23:10:18 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.146 2008/01/07 23:10:18 krw Exp $";
d1376 1
a1376 1
	if (spp && DL_GETPOFFSET(spp[0]) > 0) {
@


1.146
log
@Oops. Need to ensure we zero selected partition too.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.145 2008/01/07 19:24:33 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.145 2008/01/07 19:24:33 krw Exp $";
d74 1
a74 1
int	has_overlap(struct disklabel *, u_int64_t *, int);
a130 3
	/* Set freesectors based on bounds and initial label */
	editor_countfree(&label, &freesectors);

d132 1
a132 1
	if (has_overlap(&label, &freesectors, 1))
d135 3
d945 1
a945 1
has_overlap(struct disklabel *lp, u_int64_t *freep, int resolve)
a997 1
				editor_countfree(lp, freep);
d999 1
a999 1
				return(has_overlap(lp, freep, resolve));
d1826 1
a1826 1
			if (has_overlap(lp, freep, 0))
@


1.145
log
@When increasing d_npartitions as a result of (a)dd'ing a partition in
-E, zero intervening partitions as well as the specified partition so
no partitions are inadvertantly activated.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.144 2008/01/07 16:51:35 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.144 2008/01/07 16:51:35 krw Exp $";
d499 2
@


1.144
log
@Shrink & simplify some more -E code. Remove some chances for user
error.

1) Don't accept a partition offset in used space.
2) Make the default size the space available from the offset
   to the end of the free chunk the offset is in.
3) Make (m)odify ask the questions in the same order as
   the (a)dd command. i.e. filesystem type after offset/size.
4) Make it more obvious new partitions default into the largest
   chunk of free space.
5) Nuke another now pointless function - next_offset().

"Looks reasonable" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.143 2008/01/06 22:28:13 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.143 2008/01/06 22:28:13 krw Exp $";
d492 6
a497 3
	/* Increase d_npartitions if necessary */
	if (partno >= lp->d_npartitions)
		lp->d_npartitions = partno + 1;
a498 2
	/* Set defaults */
	memset(pp, 0, sizeof(*pp));
@


1.143
log
@Kill some now-dead code/variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.142 2008/01/06 21:25:38 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.142 2008/01/06 21:25:38 krw Exp $";
a74 1
u_int64_t next_offset(struct disklabel *, u_int64_t *);
d89 1
a89 1
int	get_offset(struct disklabel *, int);
d498 14
a511 2
	new_size = *freep;
	new_offset = next_offset(lp, &new_size);
d525 1
a525 1
	if (get_offset(lp, partno) != 0) {
a529 13
	/* Recompute recommended size based on new offset */
	ui = pp->p_fstype;
	pp->p_fstype = FS_UNUSED;
	chunks = free_chunks(lp);
	for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0; i++) {
		if (DL_GETPOFFSET(pp) >= chunks[i].start &&
		    DL_GETPOFFSET(pp) < chunks[i].stop) {
			DL_SETPSIZE(pp, chunks[i].stop - DL_GETPOFFSET(pp));
			break;
		}
	}
	pp->p_fstype = ui;

d601 2
a602 1
	int partno;
d628 2
a629 17
	/* Get filesystem type */
	if (get_fstype(lp, partno) != 0) {
		*pp = origpart;			/* undo changes */
		return;
	}

	/* Ensure a newly enabled partition fits. */
	if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
	    (origpart.p_fstype == FS_UNUSED || origpart.p_fstype == FS_BOOT)) {
		if (DL_GETPSIZE(pp) > *freep) {
			fprintf(stderr,
			    "Warning, need %llu sectors but there are only %llu "
			    "free.  Setting size to %llu.\n", DL_GETPSIZE(pp), *freep,
			    *freep);
			DL_SETPSIZE(pp, *freep);
		}
	}
d631 1
d634 1
a634 1
	if (get_offset(lp, partno) != 0) {
d645 6
a717 64
 * Find the next reasonable starting offset and returns it.
 * Assumes there is a least one free sector left (returns 0 if not).
 */
u_int64_t
next_offset(struct disklabel *lp, u_int64_t *sizep)
{
	struct partition **spp;
	struct diskchunk *chunks;
	u_int16_t npartitions;
	u_int64_t new_offset, new_size;
	int i, good_offset;

	/* Get a sorted list of the partitions */
	if ((spp = sort_partitions(lp, &npartitions)) == NULL)
		return(starting_sector);

	new_offset = starting_sector;
	for (i = 0; i < npartitions; i++ ) {
		u_int64_t pstart = DL_GETPOFFSET(spp[i]);
		u_int64_t pend = pstart + DL_GETPSIZE(spp[i]);
		u_int64_t newend = new_offset + *sizep;
		
		/*
		 * Is new_offset inside this partition?  If so,
		 * make it the next sector after the partition ends.
		 */
		if (pend < ending_sector &&
		    ((new_offset >= pstart && new_offset < pend) ||
		    (newend > pstart && newend <= pend)))
			new_offset = pend;
	}

	/* Did we find a suitable offset? */
	for (good_offset = 1, i = 0; i < npartitions; i++ ) {
		u_int64_t pstart = DL_GETPOFFSET(spp[i]);
		u_int64_t pend = pstart + DL_GETPSIZE(spp[i]);
		u_int64_t newend = new_offset + *sizep;

		if (newend > pstart && newend <= pend) {
			/* Nope */
			good_offset = 0;
			break;
		}
	}

	/* Specified size is too big, find something that fits */
	if (!good_offset) {
		chunks = free_chunks(lp);
		new_size = 0;
		for (i = 0; chunks[i].start != 0 || chunks[i].stop != 0; i++) {
			if (chunks[i].stop - chunks[i].start > new_size) {
			    new_size = chunks[i].stop - chunks[i].start;
			    new_offset = chunks[i].start;
			}
		}
		/* XXX - should do something intelligent if new_size == 0 */
		*sizep = new_size;
	}

	(void)free(spp);
	return(new_offset);
}

/*
d1748 1
a1748 1
get_offset(struct disklabel *lp, int partno)
d1751 2
a1752 1
	u_int64_t ui;
d1776 14
a1789 2
		else
			break;
a1790 2
	DL_SETPOFFSET(pp, ui);
	return(0);
@


1.142
log
@Move check for overlap inside get_size() as it was always called after
get_size() anyway. Allows elimination of make_contiguous() since we
no longer allow overlaps to develop.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.141 2008/01/06 17:27:11 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.141 2008/01/06 17:27:11 krw Exp $";
d441 1
a441 1
	u_int64_t ui, old_offset, old_size, new_offset, new_size;
a511 2
	old_offset = DL_GETPOFFSET(pp);
	old_size = DL_GETPSIZE(pp);
a1034 6
				/* Don't print, just return */
				if (resolve == -1) {
					(void)free(spp);
					return(1);
				}

@


1.141
log
@Calculate amount of free space by adding up space in free chunks, rather
than hand rolling another partition walking loop. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.140 2008/01/06 16:44:54 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.140 2008/01/06 16:44:54 krw Exp $";
a74 1
void	make_contiguous(struct disklabel *);
a514 1
getoff1:
a539 9
	/* Check for overlap */
	if (has_overlap(lp, freep, 0)) {
		printf("\nPlease re-enter an offset and size for partition "
		    "%c.\n", 'a' + partno);
		DL_SETPOFFSET(pp, old_offset);
		DL_SETPSIZE(pp, old_size);
		goto getoff1;		/* Yeah, I know... */
	}

a552 4

	/* Make sure things stay contiguous. */
	if (has_overlap(lp, freep, -1))
		make_contiguous(lp);
a649 1
getoff2:
a661 8
	/* Check for overlap and restore if not resolved */
	if (has_overlap(lp, freep, 0)) {
		puts("\nPlease re-enter an offset and size");
		DL_SETPSIZE(pp, DL_GETPSIZE(&origpart));
		DL_SETPOFFSET(pp, DL_GETPOFFSET(&origpart));
		goto getoff2;		/* Yeah, I know... */
	}

a680 4

	/* Make sure things stay contiguous. */
	if (has_overlap(lp, freep, -1))
		make_contiguous(lp);
d825 2
a826 32
	/* Get size */
	if (get_size(lp, partno, freep, 0) != 0)
		return;

	/* Make sure things stay contiguous. */
	if (has_overlap(lp, freep, -1))
		make_contiguous(lp);
}

void
make_contiguous(struct disklabel *lp)
{
	struct partition **spp;
	u_int16_t npartitions;
	int i;

	/* Get a sorted list of the partitions */
	if ((spp = sort_partitions(lp, &npartitions)) == NULL)
		return;

	/*
	 * Make everything contiguous but don't muck with start of the first one
	 * or partitions not in the BSD part of the label.
	 */
	for (i = 1; i < npartitions; i++) {
		if (DL_GETPOFFSET(spp[i]) >= starting_sector ||
		    DL_GETPOFFSET(spp[i]) < ending_sector)
			DL_SETPOFFSET(spp[i], DL_GETPOFFSET(spp[i - 1]) +
			    DL_GETPSIZE(spp[i - 1]));
	}

	(void)free(spp);
d1867 1
a1867 1
	u_int64_t ui;
d1891 8
a1898 2
		else
			break;
a1899 1
	DL_SETPSIZE(pp, ui);
@


1.140
log
@There is no point in having cpg manipulated in -E. newfs does all the
work anyway and ignores this value. So just set it to 1 and nuke
get_cpg(), shrinking and simplifying.

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.139 2008/01/03 02:10:05 sthen Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.139 2008/01/03 02:10:05 sthen Exp $";
d1611 1
d1615 2
a1616 1
	*freep = ending_sector - starting_sector;
d1618 2
a1619 19
	for (i = 0; i < lp->d_npartitions; i++) {
		pp = &lp->d_partitions[i];
		if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
		    DL_GETPSIZE(pp) > 0) {
			u_int64_t s = DL_GETPOFFSET(pp);
			u_int64_t sz = DL_GETPSIZE(pp);
			u_int64_t e = s + sz;

			/* do not count if completely out of 'b' area */
			if (e < starting_sector || s >= ending_sector)
				continue;

			if (s < starting_sector)
				sz -= starting_sector - s;
			if (e > ending_sector)
				sz -= e - ending_sector;
			*freep -= sz;
		}
	}
@


1.139
log
@Remove text which is incorrect now that 'get bios geometry'
has been removed.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.138 2008/01/01 18:20:02 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.138 2008/01/01 18:20:02 krw Exp $";
a87 1
int	get_cpg(struct disklabel *, int);
d512 1
a512 1
	pp->p_cpg = 16;
d559 1
a559 2
		if (get_fsize(lp, partno) != 0 || get_bsize(lp, partno) != 0 ||
		    get_cpg(lp, partno) != 0) {
a703 8

		if (pp->p_fstype == FS_BSDFFS) {
			/* get cpg */
			if (get_cpg(lp, partno) != 0) {
				*pp = origpart;	/* undo changes */
				return;
			}
		}
a2040 23
	return(0);
}

int
get_cpg(struct disklabel *lp, int partno)
{
	u_int64_t ui;
	struct partition *pp = &lp->d_partitions[partno];

	for (;;) {
		ui = getuint(lp, partno, "cpg",
		    "Number of filesystem cylinders per group."
		    "  Usually 16 or 8.",
		    pp->p_cpg ? pp->p_cpg : 16, 16, 0, 0);
		if (ui == ULLONG_MAX - 1) {
			fputs("Command aborted\n", stderr);
			return(1);
		} else if (ui == ULLONG_MAX)
			fputs("Invalid entry\n", stderr);
		else
			break;
	}
	pp->p_cpg = ui;
@


1.138
log
@Oops. Missed a couple of unnecessary 'DL_GETPOFFSET()+DL_GETPSIZE() >
ending_sector' tests and one superfluous editor_countfree(). Rectify a
few comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.137 2008/01/01 17:15:03 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.137 2008/01/01 17:15:03 krw Exp $";
d2198 1
a2198 1
		p = getstring("[d]isk, [b]ios, or [u]ser geometry",
d2200 2
a2201 2
		    "itself thinks it is, 'b' to use what the BIOS says,"
		    "or 'u' to use the geometry that was found on in the label.",
d2244 1
a2244 1
		fputs("You must enter either 'd', 'b', or 'u'.\n", stderr);
@


1.137
log
@Fix display of overlapping partitions to account for larger size and offset
fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.136 2008/01/01 16:22:27 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.136 2008/01/01 16:22:27 krw Exp $";
d567 2
a568 4
	/* Update free sector count and make sure things stay contiguous. */
	editor_countfree(lp, freep);
	if (DL_GETPSIZE(pp) + DL_GETPOFFSET(pp) > ending_sector ||
	    has_overlap(lp, freep, -1))
d717 1
a717 2
	if (DL_GETPSIZE(pp) + DL_GETPOFFSET(pp) > ending_sector ||
	    has_overlap(lp, freep, -1))
d867 1
@


1.136
log
@get_size() no longer allows DL_GETPSIZE()+DL_GETPOFFSET >
ending_sector, so no need to check for this condition after calling
get_size().
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.135 2008/01/01 14:58:42 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.135 2008/01/01 14:58:42 krw Exp $";
d1120 1
a1120 1
				printf("#    %13.13s %13.13s  fstype "
@


1.135
log
@Shorten and simplify code, eliminate ability to assign arbitrary sizes
to existing FS_BOOT and FS_UNUSED partitions via -E, tighten up error
verbiage.

Feedback from jsing@@.

ok millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.134 2007/12/31 17:51:57 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.134 2007/12/31 17:51:57 krw Exp $";
d870 1
a870 2
	if (DL_GETPSIZE(pp) + DL_GETPOFFSET(pp) > ending_sector ||
	    has_overlap(lp, freep, -1))
@


1.134
log
@Reset partition size as well as partition offset before asking for
another, valid, set while adding a partition. Lost in r1.119 when we
switched to DL_SETP* defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.133 2007/12/30 22:42:19 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.133 2007/12/30 22:42:19 krw Exp $";
d1917 1
a1918 1
	struct partition *pp = &lp->d_partitions[partno];
d1931 6
a1936 10
		else if (ui < starting_sector)
			fprintf(stderr, "The OpenBSD portion of the disk starts"
			    " at sector %llu, you tried to add a partition at %llu."
			    "  You can use the 'b' command to change the size "
			    "of the OpenBSD portion.\n" , starting_sector, ui);
		else if (ui >= ending_sector)
			fprintf(stderr, "The OpenBSD portion of the disk ends "
			    "at sector %llu, you tried to add a partition at %llu."
			    "  You can use the 'b' command to change the size "
			    "of the OpenBSD portion.\n", ending_sector, ui);
d1952 1
a1953 1
	struct partition *pp = &lp->d_partitions[partno];
d1965 1
a1965 1
		} else if (ui == ULLONG_MAX) {
d1967 12
a1978 32
			continue;
		}
		if (new) {
			if (ui > *freep)
				/* XXX - steal space from another partition */
				fprintf(stderr,"Sorry, there are only %llu "
				    "sectors left\n", *freep);
			else if (DL_GETPOFFSET(pp) + ui > ending_sector)
				fprintf(stderr, "The OpenBSD portion of the "
				    "disk ends at sector %llu, you tried to add "
				    "a partition ending at sector %llu.  You can "
				    "use the 'b' command to change the size of "
				    "the OpenBSD portion.\n",
				    ending_sector, DL_GETPOFFSET(pp) + ui);
			else
				break;			/* ok */
		} else {
			if (ui == DL_GETPSIZE(pp))
				break;			/* no change */
			if (pp->p_fstype == FS_UNUSED ||
			    pp->p_fstype == FS_BOOT) {
				break;
			} else {
				if (ui > DL_GETPSIZE(pp) + *freep)
					/* XXX - steal from another partition */
					fprintf(stderr,
					    "Size may not be larger than %llu "
					    "sectors\n", DL_GETPSIZE(pp) + *freep);
				else
					break;			/* ok */
			}
		}
@


1.133
log
@Use get_size() in editor_change() instead of hand-rolling identical
code. Makes the size prompt/helpstring/looping the same for
(a)dd/(m)odify/(c)hange.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.132 2007/12/30 21:30:53 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.132 2007/12/30 21:30:53 krw Exp $";
d548 1
@


1.132
log
@Kill some now unneeded checks for 'c' partition manipulation. Change
the variable 'c' to 'partno' in editor_delete() so all editor_*
functions are even more consistant. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.131 2007/12/30 17:31:20 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.131 2007/12/30 17:31:20 krw Exp $";
a838 1
	u_int64_t newsize;
d864 3
a866 12
	/* XXX - make maxsize lp->d_secperunit if FS_UNUSED/FS_BOOT? */
	newsize = getuint(lp, partno, "new size", "Size of the partition.  "
	    "You may also say +/- amount for a relative change.",
	    DL_GETPSIZE(pp), DL_GETPSIZE(pp) + *freep, DL_GETPOFFSET(pp), DO_CONVERSIONS |
	    (pp->p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));
	if (newsize == ULLONG_MAX - 1) {
		fputs("Command aborted\n", stderr);
		return;
	} else if (newsize == ULLONG_MAX) {
		fputs("Invalid entry\n", stderr);
		return;
	} else if (newsize == DL_GETPSIZE(pp))
d869 1
a869 13
	if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT) {
		if (newsize > DL_GETPSIZE(pp)) {
			if (newsize - DL_GETPSIZE(pp) > *freep) {
				fprintf(stderr,
				    "Only %llu sectors free, you asked for %llu\n",
				    *freep, newsize - DL_GETPSIZE(pp));
				return;
			}
		}
	}
	DL_SETPSIZE(pp, newsize);
	editor_countfree(lp, freep);
	if (newsize + DL_GETPOFFSET(pp) > ending_sector ||
d1959 2
a1960 1
		ui = getuint(lp, partno, "size", "Size of the partition.",
@


1.131
log
@Simplify code by avoiding manual manipulations of the free space
counter.  Call edit_countfree() instead.

Feedback from otto@@.

ok millert@@ "Go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.130 2007/12/30 16:51:55 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.130 2007/12/30 16:51:55 krw Exp $";
d730 1
a730 1
	int c;
d745 2
a746 2
	c = p[0] - 'a';
	if (c < 0 || c == RAW_PART || c >= lp->d_npartitions) {
d751 1
a751 1
	pp = &lp->d_partitions[c];
d758 6
a763 13
	if (c == RAW_PART) {
		fputs(
"You may not delete the 'c' partition.  The 'c' partition must exist and\n"
"should span the entire disk.  By default it is of type 'unused' and so\n"
"does not take up any space.\n", stderr);
		return;
	} else {
		/* Really delete it (as opposed to just setting to "unused") */
		memset(&lp->d_partitions[c], 0, sizeof(lp->d_partitions[c]));
	}
	if (mp != NULL && mp[c] != NULL) {
		free(mp[c]);
		mp[c] = NULL;
a887 7
	} else {
		if (partno == RAW_PART && newsize +
		    DL_GETPOFFSET(pp) > DL_GETDSIZE(lp)) {
			fputs("'c' partition may not be larger than the disk\n",
			    stderr);
			return;
		}
d2010 1
a2010 5
			if (partno == RAW_PART &&
			    ui + DL_GETPOFFSET(pp) > DL_GETDSIZE(lp)) {
				fputs("'c' partition may not be larger than the disk\n",
				    stderr);
			} else if (pp->p_fstype == FS_UNUSED ||
@


1.130
log
@Since 'c' now always covers the entire disk and is always FS_UNUSED,
there is no point in allowing the edit mode commands
(a)add/(n)ame/(m)odify/(d)elete/(c)hange to pretend to fiddle with it.
Some already checked for and avoided 'c', but do it in a consistant
manner in all cases.

ok millert@@ otto@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.129 2007/12/30 01:52:07 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.129 2007/12/30 01:52:07 krw Exp $";
d567 1
a567 1
	*freep -= DL_GETPSIZE(pp);
d655 2
a656 5
	/* Did they disable/enable the partition? */
	if ((pp->p_fstype == FS_UNUSED || pp->p_fstype == FS_BOOT) &&
	    origpart.p_fstype != FS_UNUSED && origpart.p_fstype != FS_BOOT)
		*freep += DL_GETPSIZE(&origpart);
	else if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
d664 1
a664 3
			*freep = 0;
		} else
			*freep -= DL_GETPSIZE(pp);		/* have enough space */
d666 1
a764 8
		/* Update free sector count. */
		if (DL_GETPOFFSET(&lp->d_partitions[c]) < ending_sector &&
		    DL_GETPOFFSET(&lp->d_partitions[c]) >= starting_sector &&
		    lp->d_partitions[c].p_fstype != FS_UNUSED &&
		    lp->d_partitions[c].p_fstype != FS_BOOT &&
		    DL_GETPSIZE(&lp->d_partitions[c]) != 0)
			*freep += DL_GETPSIZE(&lp->d_partitions[c]);

d766 1
a766 2
		(void)memset(&lp->d_partitions[c], 0,
		    sizeof(lp->d_partitions[c]));
d772 1
a893 3
			*freep -= newsize - DL_GETPSIZE(pp);
		} else if (newsize < DL_GETPSIZE(pp)) {
			*freep += DL_GETPSIZE(pp) - newsize;
d904 1
d1182 1
a1182 1
				*freep += DL_GETPSIZE(&lp->d_partitions[c]);
a1322 2
			/* grow free count */
			*freep += ui - DL_GETDSIZE(lp);
d1334 1
a1334 2
			else {
				*freep -= DL_GETDSIZE(lp) - ui;
a1335 1
			}
d1343 1
a2029 2
				/* don't care what's free */
				DL_SETPSIZE(pp, ui);
d2037 1
a2037 3
				else {
					*freep += DL_GETPSIZE(pp) - ui;
					DL_SETPSIZE(pp, ui);
a2038 1
				}
d2043 1
@


1.129
log
@Bring editor_add() code into line with the other editor_* functions.
The only visible change is allowing only one chance to specify a valid
partition letter before returning to the main edit prompt.

"This looks OK to me" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.128 2007/12/25 17:26:49 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.128 2007/12/25 17:26:49 krw Exp $";
d592 3
a594 3
	if (partno < 0 || partno >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c'.\n",
		    'a' + lp->d_npartitions - 1);
d635 3
a637 3
	if (partno < 0 || partno >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c'.\n",
		    'a' + lp->d_npartitions - 1);
d750 3
a752 3
	if (c < 0 || c >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c'.\n",
		    'a' + lp->d_npartitions - 1);
d870 3
a872 3
	if (partno < 0 || partno >= lp->d_npartitions) {
		fprintf(stderr, "Partition must be between 'a' and '%c'.\n",
		    'a' + lp->d_npartitions - 1);
@


1.128
log
@Some cosmetic code reorg to make things a bit more textually
consistant.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.127 2007/12/24 14:46:54 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.127 2007/12/24 14:46:54 krw Exp $";
d441 1
a441 1
	char buf[BUFSIZ];
d460 11
a470 21
	/* XXX - make more like other editor_* */
	if (p != NULL) {
		partno = p[0] - 'a';
		if (partno < 0 || partno == RAW_PART ||
		    partno >= MAXPARTITIONS) {
			fprintf(stderr,
			    "Partition must be between 'a' and '%c' "
			    "(excluding 'c').\n", 'a' + MAXPARTITIONS - 1);
			return;
		} else if (lp->d_partitions[partno].p_fstype != FS_UNUSED &&
		    DL_GETPSIZE(&lp->d_partitions[partno]) != 0) {
			fprintf(stderr,
			    "Partition '%c' exists.  Delete it first.\n",
			    p[0]);
			return;
		}
	} else {
		/* Find first unused partition that is not 'c' */
		for (partno = 0; partno < MAXPARTITIONS; partno++, p++) {
			if (DL_GETPSIZE(&lp->d_partitions[partno]) == 0 &&
			    partno != RAW_PART)
d472 1
d474 19
a492 22
		if (partno < MAXPARTITIONS) {
			buf[0] = partno + 'a';
			buf[1] = '\0';
			p = &buf[0];
		} else
			p = NULL;
		for (;;) {
			p = getstring("partition",
			    "The letter of the new partition, a - p.", p);
			if (p == NULL)
				return;
			partno = p[0] - 'a';
			if (lp->d_partitions[partno].p_fstype != FS_UNUSED &&
			    DL_GETPSIZE(&lp->d_partitions[partno]) != 0) {
				fprintf(stderr,
				    "Partition '%c' already exists.\n", p[0]);
			} else if (partno >= 0 && partno < MAXPARTITIONS)
				break;
			fprintf(stderr,
			    "Partition must be between 'a' and '%c'.\n",
			    'a' + MAXPARTITIONS - 1);
		}
a499 1
	pp = &lp->d_partitions[partno];
@


1.127
log
@Use zero_partitions() to implement the '-E' command 'd *', as it
already is used to implement 'z'. Vocal support for both commands so
keep both for now.

'sounds good' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.126 2007/12/23 16:15:21 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.126 2007/12/23 16:15:21 krw Exp $";
a604 1
	pp = &lp->d_partitions[partno];
d609 5
a613 3
	} else if (partno >= lp->d_npartitions ||
	    (pp->p_fstype == FS_UNUSED && DL_GETPSIZE(pp) == 0)) {
		fprintf(stderr, "Partition '%c' is not in use.\n", 'a' + partno);
a647 2
	pp = &lp->d_partitions[partno];
	origpart = lp->d_partitions[partno];
d652 5
a656 3
	} else if (partno >= lp->d_npartitions ||
	    (pp->p_fstype == FS_UNUSED && DL_GETPSIZE(pp) == 0)) {
		fprintf(stderr, "Partition '%c' is not in use.\n", 'a' + partno);
d660 2
d746 1
d767 5
a771 3
	} else if (lp->d_partitions[c].p_fstype == FS_UNUSED &&
	    DL_GETPSIZE(&lp->d_partitions[c]) == 0) {
		fprintf(stderr, "Partition '%c' is not in use.\n", 'a' + c);
d773 3
a775 1
	} else if (c == RAW_PART) {
d870 2
a872 2
	u_int64_t newsize;
	struct partition *pp;
d887 5
a891 3
	} else if (partno >= lp->d_npartitions ||
	    DL_GETPSIZE(&lp->d_partitions[partno]) == 0) {
		fprintf(stderr, "Partition '%c' is not in use.\n", 'a' + partno);
a893 1
	pp = &lp->d_partitions[partno];
d896 1
a896 1
	    partno + 'a', DL_GETPSIZE(pp), *freep);
@


1.126
log
@Setting p_fstype to the number of free sectors can't be right. Instead, set
the partition size with DL_SETPSIZE(pp, *freep).
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.125 2007/09/02 15:19:23 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.125 2007/09/02 15:19:23 deraadt Exp $";
d755 1
a755 13
		for (c = 0; c < lp->d_npartitions; c++) {
			if (c == RAW_PART)
				continue;

			/* Update free sector count. */
			if (lp->d_partitions[c].p_fstype != FS_UNUSED &&
			    lp->d_partitions[c].p_fstype != FS_BOOT &&
			    DL_GETPSIZE(&lp->d_partitions[c]) != 0)
				*freep += DL_GETPSIZE(&lp->d_partitions[c]);

			(void)memset(&lp->d_partitions[c], 0,
			    sizeof(lp->d_partitions[c]));
		}
@


1.125
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.124 2007/07/24 15:11:53 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.124 2007/07/24 15:11:53 deraadt Exp $";
d676 1
a676 1
			pp->p_fstype = *freep;
@


1.124
log
@rearrange newline printing code during editor startup; ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.123 2007/06/20 19:16:53 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.123 2007/06/20 19:16:53 otto Exp $";
d1431 1
a1431 1
	if ((spp = malloc(sizeof(struct partition *) * npartitions)) == NULL)
@


1.123
log
@if a 4.2BSD partition falls partly within the area defined by the
'b' command, subtract the overlapping space from the free space.
fixes weird free space calculation on hppa, where converted lif
labels start at sector 1, but the 'b' area skips the first cylinder.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.122 2007/06/17 00:32:21 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.122 2007/06/17 00:32:21 deraadt Exp $";
d172 1
a172 1
	puts("\nInitial label editor (enter '?' for help at any prompt)");
d1674 2
a1675 2
		printf("\nTreating sectors %llu-%llu as the OpenBSD portion of the "
		    "disk.\nYou can use the 'b' command to change this.\n",
d1681 2
a1682 2
	printf("\nReserving the first data cylinder for boot blocks.\n"
	    "You can use the 'b' command to change this.\n");
@


1.122
log
@On Sun machines, disklabels coming from the kernel will now have a d_flags
bit D_VENDOR if they face the Sun cylinder / start-at-zero semantics.  Other
disklabels found on these architectures do not have these issues, and do
not need to be constrained.  checked by otto
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.121 2007/06/08 20:21:13 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.121 2007/06/08 20:21:13 millert Exp $";
d1696 1
d1698 17
a1714 6
		    pp = &lp->d_partitions[i];
		    if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
			DL_GETPSIZE(pp) > 0 &&
			DL_GETPOFFSET(pp) + DL_GETPSIZE(pp) <= ending_sector &&
			DL_GETPOFFSET(pp) >= starting_sector)
			*freep -= DL_GETPSIZE(pp);
@


1.121
log
@Simplify rounding to cylinders.
Also, on systems with sun labels, don't allow the user to create a
partition with fewer than a cylinder's worth of sectors.
OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.120 2007/06/08 19:08:35 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.120 2007/06/08 19:08:35 otto Exp $";
d153 7
a159 2
#ifdef CYLCHECK
	puts("This platform requires that partition offsets/sizes be on cylinder boundaries.\nPartition offsets/sizes will be rounded to the nearest cylinder automatically.");
d446 7
a452 4
#ifdef CYLCHECK
	if (*freep < lp->d_secpercyl)
#else
	if (*freep == 0)
d454 1
a454 1
	{
d1127 3
a1129 1
#ifndef CYLCHECK
d1997 1
a1997 1
#ifdef AAT0
@


1.120
log
@second pass, some fields slipped through the first time around
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.119 2007/06/08 18:42:17 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.119 2007/06/08 18:42:17 otto Exp $";
d441 6
a446 1
	if (*freep == 0) {
d1116 3
a1118 2
	if ((flags & DO_ROUNDING) && rval < ULLONG_MAX - lp->d_secpercyl / 2 &&
	    lp->d_secpercyl != 0) {
d1120 1
a1120 2
		/* Round to nearest cylinder unless given in sectors */
		if (mult != 1)
d1122 1
a1122 1
		{
d1125 6
a1130 13
			/* If we round up past the end, round down instead */
			cyls = (rval + lp->d_secpercyl / 2) / lp->d_secpercyl;
			if (cyls != 0 && lp->d_secpercyl != 0) {
				if (maxval && cyls > 1 &&
				    (cyls * lp->d_secpercyl) - offset > maxval)
					cyls--;

				if (rval != (cyls * lp->d_secpercyl) - offset) {
					rval = (cyls * lp->d_secpercyl) - offset;
					printf("Rounding to nearest cylinder: %llu\n",
					    rval);
				}
			}
@


1.119
log
@Make disklabel(8) aware of the new fields, allowing for larger than
2T disks, partitions and offsets. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.118 2007/06/08 13:52:51 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.118 2007/06/08 13:52:51 millert Exp $";
d147 2
a148 4
		pp->p_offset = 0;
		pp->p_offseth = 0;
		pp->p_size = label.d_secperunit;
		pp->p_sizeh = label.d_secperunith;
d655 1
a655 1
		*freep += origpart.p_size;
d685 2
a686 4
		pp->p_offset = origpart.p_offset;
		pp->p_offseth = origpart.p_offseth;
		pp->p_size = origpart.p_size;
		pp->p_sizeh = origpart.p_sizeh;
d749 1
a749 1
			    lp->d_partitions[c].p_size != 0)
d763 1
a763 1
	    lp->d_partitions[c].p_size == 0) {
d879 1
a879 1
	    lp->d_partitions[partno].p_size == 0) {
d943 4
a946 4
		if (spp[i]->p_offset >= starting_sector ||
		    spp[i]->p_offset < ending_sector)
			spp[i]->p_offset =
			    spp[i - 1]->p_offset + spp[i - 1]->p_size;
d1204 1
a1204 1
				*freep += lp->d_partitions[c].p_size;
d1332 2
a1333 2
		u_int32_t nsec = MAX(lp->d_secperunit,
		    lp->d_ncylinders * lp->d_secpercyl);
d1586 1
a1586 1
	if (spp && spp[0]->p_offset > 0) {
d1654 4
a1657 2
				    DL_GETPSIZE(pp) + pp->p_offset > new_end)
					new_end = DL_GETPSIZE(pp) + pp->p_offset;
d2301 1
a2301 1
			lp->d_secperunit = dgp->d_secperunit;
d2314 1
a2314 1
			lp->d_secperunit = ugp->d_secperunit;
d2320 1
a2320 1
			    ugp->d_secperunit == dgp->d_secperunit)
d2338 1
a2338 2
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_sizeh = lp->d_secperunith;
@


1.118
log
@Fix setting total # sectors in the 'e' command.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.117 2007/06/07 21:47:16 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.117 2007/06/07 21:47:16 millert Exp $";
d54 2
a55 2
	u_int32_t start;
	u_int32_t stop;
d64 5
a68 5
void	edit_parms(struct disklabel *, u_int32_t *);
void	editor_add(struct disklabel *, char **, u_int32_t *, char *);
void	editor_change(struct disklabel *, u_int32_t *, char *);
void	editor_countfree(struct disklabel *, u_int32_t *);
void	editor_delete(struct disklabel *, char **, u_int32_t *, char *);
d70 1
a70 1
void	editor_modify(struct disklabel *, char **, u_int32_t *, char *);
d73 2
a74 2
u_int32_t getuint(struct disklabel *, int, char *, char *, u_int32_t, u_int32_t, u_int32_t, int);
int	has_overlap(struct disklabel *, u_int32_t *, int);
d76 1
a76 1
u_int32_t next_offset(struct disklabel *, u_int32_t *);
d81 1
a81 1
void	set_bounds(struct disklabel *, u_int32_t *);
d93 1
a93 1
int	get_size(struct disklabel *, int, u_int32_t *, int);
d97 1
a97 1
void	zero_partitions(struct disklabel *, u_int32_t *);
d99 2
a100 2
static u_int32_t starting_sector;
static u_int32_t ending_sector;
d112 1
a112 1
	u_int32_t freesectors;
d143 1
a143 1
	if (label.d_npartitions < 3 || pp->p_size == 0) {
d148 1
d150 1
d434 1
a434 1
editor_add(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
d440 1
a440 1
	u_int32_t ui, old_offset, old_size;
d459 1
a459 1
		    lp->d_partitions[partno].p_size != 0) {
d468 1
a468 1
			if (lp->d_partitions[partno].p_size == 0 &&
d485 1
a485 1
			    lp->d_partitions[partno].p_size != 0) {
d503 4
a506 2
	pp->p_size = *freep;
	pp->p_offset = next_offset(lp, &pp->p_size);
d516 2
a517 2
	old_offset = pp->p_offset;
	old_size = pp->p_size;
d522 1
a522 1
		pp->p_size = 0;			/* effective delete */
d531 3
a533 3
		if (pp->p_offset >= chunks[i].start &&
		    pp->p_offset < chunks[i].stop) {
			pp->p_size = chunks[i].stop - pp->p_offset;
d540 2
a541 2
	if (get_size(lp, partno, freep, 1) != 0 || pp->p_size == 0) {
		pp->p_size = 0;			/* effective delete */
d549 1
a549 2
		pp->p_offset = old_offset;
		pp->p_size = old_size;
d555 1
a555 1
		pp->p_size = 0;			/* effective delete */
d563 1
a563 1
			pp->p_size = 0;			/* effective delete */
d569 2
a570 2
	*freep -= pp->p_size;
	if (pp->p_size + pp->p_offset > ending_sector ||
d600 1
a600 1
	    (pp->p_fstype == FS_UNUSED && pp->p_size == 0)) {
d621 1
a621 1
editor_modify(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
d643 1
a643 1
	    (pp->p_fstype == FS_UNUSED && pp->p_size == 0)) {
d660 1
a660 1
		if (pp->p_size > *freep) {
d662 2
a663 2
			    "Warning, need %u sectors but there are only %u "
			    "free.  Setting size to %u.\n", pp->p_size, *freep,
d668 1
a668 1
			*freep -= pp->p_size;		/* have enough space */
d679 2
a680 2
	if (get_size(lp, partno, freep, 0) != 0 || pp->p_size == 0) {
		pp->p_size = 0;			/* effective delete */
d688 1
d690 1
d723 1
a723 1
	if (pp->p_size + pp->p_offset > ending_sector ||
d732 1
a732 1
editor_delete(struct disklabel *lp, char **mp, u_int32_t *freep, char *p)
d754 1
a754 1
				*freep += lp->d_partitions[c].p_size;
d778 2
a779 2
		if (lp->d_partitions[c].p_offset < ending_sector &&
		    lp->d_partitions[c].p_offset >= starting_sector &&
d782 2
a783 2
		    lp->d_partitions[c].p_size != 0)
			*freep += lp->d_partitions[c].p_size;
d799 2
a800 2
u_int32_t
next_offset(struct disklabel *lp, u_int32_t *sizep)
d805 1
a805 1
	u_int32_t new_offset, new_size;
d814 3
a816 3
		u_int32_t pstart = spp[i]->p_offset;
		u_int32_t pend = pstart + spp[i]->p_size;
		u_int32_t newend = new_offset + *sizep;
d830 3
a832 3
		u_int32_t pstart = spp[i]->p_offset;
		u_int32_t pend = pstart + spp[i]->p_size;
		u_int32_t newend = new_offset + *sizep;
d863 1
a863 1
editor_change(struct disklabel *lp, u_int32_t *freep, char *p)
d866 1
a866 1
	u_int32_t newsize;
d889 2
a890 2
	printf("Partition %c is currently %u sectors in size (%u free).\n",
	    partno + 'a', pp->p_size, *freep);
d894 1
a894 1
	    pp->p_size, pp->p_size + *freep, pp->p_offset, DO_CONVERSIONS |
d896 1
a896 1
	if (newsize == UINT_MAX - 1) {
d899 1
a899 1
	} else if (newsize == UINT_MAX) {
d902 1
a902 1
	} else if (newsize == pp->p_size)
d906 2
a907 2
		if (newsize > pp->p_size) {
			if (newsize - pp->p_size > *freep) {
d909 2
a910 2
				    "Only %u sectors free, you asked for %u\n",
				    *freep, newsize - pp->p_size);
d913 3
a915 3
			*freep -= newsize - pp->p_size;
		} else if (newsize < pp->p_size) {
			*freep += pp->p_size - newsize;
d919 1
a919 1
		    pp->p_offset > lp->d_secperunit) {
d925 2
a926 2
	pp->p_size = newsize;
	if (newsize + pp->p_offset > ending_sector ||
d965 2
d968 1
a968 1
	if (p1->p_offset < p2->p_offset)
d970 1
a970 1
	else if (p1->p_offset > p2->p_offset)
d1006 1
a1006 1
 * Returns UINT_MAX on error
d1009 1
a1009 1
u_int32_t
d1011 1
a1011 1
    u_int32_t oval, u_int32_t maxval, u_int32_t offset, int flags)
d1014 1
a1014 1
	u_int32_t rval = oval;
d1024 1
a1024 1
		printf("%s: [%u] ", prompt, oval);
d1030 1
a1030 1
				return(UINT_MAX - 1);
d1074 2
a1075 2
					snprintf(buf, sizeof(buf), "%d",
					    lp->d_secperunit);
d1080 1
a1080 1
					snprintf(buf, sizeof(buf), "%d",
d1095 1
a1095 1
				rval = UINT_MAX;	/* too big/small */
d1098 1
a1098 1
				rval = UINT_MAX;
d1115 1
a1115 1
	if ((flags & DO_ROUNDING) && rval < UINT_MAX - lp->d_secpercyl / 2 &&
d1122 1
a1122 1
			u_int32_t cyls;
d1133 1
a1133 1
					printf("Rounding to nearest cylinder: %u\n",
d1149 1
a1149 1
has_overlap(struct disklabel *lp, u_int32_t *freep, int resolve)
d1168 1
a1168 1
			if (spp[i]->p_offset + spp[i]->p_size > spp[j]->p_offset) {
d1220 1
a1220 1
edit_parms(struct disklabel *lp, u_int32_t *freep)
d1223 1
a1223 1
	u_int32_t ui;
d1274 1
a1274 1
		if (ui == UINT_MAX - 1) {
d1278 1
a1278 1
		} if (ui == UINT_MAX)
d1290 1
a1290 1
		if (ui == UINT_MAX - 1) {
d1294 1
a1294 1
		} else if (ui == UINT_MAX)
d1307 1
a1307 1
		if (ui == UINT_MAX - 1) {
d1311 1
a1311 1
		} else if (ui == UINT_MAX)
d1323 1
a1323 1
		if (ui == UINT_MAX - 1) {
d1327 1
a1327 1
		} else if (ui == UINT_MAX)
d1341 1
a1341 1
		if (ui == UINT_MAX - 1) {
d1345 1
a1345 1
		} else if (ui == UINT_MAX)
d1347 2
a1348 2
		else if (ui > lp->d_secperunit &&
		    ending_sector == lp->d_secperunit) {
d1350 1
a1350 1
			*freep += ui - lp->d_secperunit;
d1354 2
a1355 2
		} else if (ui < lp->d_secperunit &&
		    ending_sector == lp->d_secperunit) {
d1357 1
a1357 1
			if (lp->d_secperunit - ui > *freep)
d1359 3
a1361 3
				    "Not enough free space to shrink by %u "
				    "sectors (only %u sectors left)\n",
				    lp->d_secperunit - ui, *freep);
d1363 1
a1363 1
				*freep -= lp->d_secperunit - ui;
d1372 1
a1372 1
	lp->d_secperunit = ui;
d1379 1
a1379 1
		if (ui == UINT_MAX - 1) {
d1383 1
a1383 1
		} else if (ui == UINT_MAX)
d1395 1
a1395 1
		if (ui == UINT_MAX - 1) {
d1399 1
a1399 1
		} else if (ui == UINT_MAX || ui == 0)
d1418 1
a1418 1
		    lp->d_partitions[i].p_size != 0)
d1432 1
a1432 1
		    lp->d_partitions[i].p_size != 0)
d1532 1
a1532 1
set_bounds(struct disklabel *lp, u_int32_t *freep)
d1534 1
a1534 1
	u_int32_t ui, start_temp;
d1540 2
a1541 2
		  starting_sector, lp->d_secperunit, 0, 0);
		if (ui == UINT_MAX - 1) {
d1545 1
a1545 1
	} while (ui >= lp->d_secperunit);
d1553 2
a1554 2
		  lp->d_secperunit - start_temp, 0, 0);
		if (ui == UINT_MAX - 1) {
d1558 1
a1558 1
	} while (ui > lp->d_secperunit - start_temp);
d1592 1
a1592 1
		chunks[0].stop = spp[0]->p_offset;
d1597 5
a1601 4
			if (spp[i]->p_offset + spp[i]->p_size < spp[i+1]->p_offset) {
				chunks[numchunks].start =
				    spp[i]->p_offset + spp[i]->p_size;
				chunks[numchunks].stop = spp[i+1]->p_offset;
d1605 1
d1607 1
a1607 1
			if (spp[i]->p_offset + spp[i]->p_size < ending_sector) {
d1609 1
a1609 2
				chunks[numchunks].start =
				    spp[i]->p_offset + spp[i]->p_size;
d1634 1
a1634 1
	ending_sector = lp->d_secperunit;
d1658 2
a1659 2
				    pp->p_size + pp->p_offset > new_end)
					new_end = pp->p_size + pp->p_offset;
d1668 1
a1668 1
		printf("\nTreating sectors %u-%u as the OpenBSD portion of the "
d1684 1
a1684 1
editor_countfree(struct disklabel *lp, u_int32_t *freep)
d1693 4
a1696 4
			pp->p_size > 0 &&
			pp->p_offset + pp->p_size <= ending_sector &&
			pp->p_offset >= starting_sector)
			*freep -= pp->p_size;
d1967 1
a1967 1
	u_int32_t ui;
d1972 3
a1974 2
		   "Starting sector for this partition.", pp->p_offset,
		   pp->p_offset, 0, DO_CONVERSIONS |
d1976 1
a1976 1
		if (ui == UINT_MAX - 1) {
d1979 1
a1979 1
		} else if (ui == UINT_MAX)
d1983 1
a1983 1
			    " at sector %u, you tried to add a partition at %u."
d1988 1
a1988 1
			    "at sector %u, you tried to add a partition at %u."
d1999 1
a1999 1
	pp->p_offset = ui;
d2004 1
a2004 1
get_size(struct disklabel *lp, int partno, u_int32_t *freep, int new)
d2006 1
a2006 1
	u_int32_t ui;
d2011 2
a2012 1
		    pp->p_size, *freep + (new ? 0 : pp->p_size), pp->p_offset,
d2015 1
a2015 1
		if (ui == UINT_MAX - 1) {
d2018 1
a2018 1
		} else if (ui == UINT_MAX) {
d2025 1
a2025 1
				fprintf(stderr,"Sorry, there are only %u "
d2027 1
a2027 1
			else if (pp->p_offset + ui > ending_sector)
d2029 2
a2030 2
				    "disk ends at sector %u, you tried to add "
				    "a partition ending at sector %u.  You can "
d2033 1
a2033 1
				    ending_sector, pp->p_offset + ui);
d2037 1
a2037 1
			if (ui == pp->p_size)
d2040 1
a2040 1
			    ui + pp->p_offset > lp->d_secperunit) {
d2046 1
a2046 1
				pp->p_size = ui;
d2049 1
a2049 1
				if (ui > pp->p_size + *freep)
d2052 2
a2053 2
					    "Size may not be larger than %u "
					    "sectors\n", pp->p_size + *freep);
d2055 2
a2056 2
					*freep += pp->p_size - ui;
					pp->p_size = ui;
d2062 1
a2062 1
	pp->p_size = ui;
d2069 1
a2069 1
	u_int32_t ui, fsize, frag;
d2081 1
a2081 1
		if (ui == UINT_MAX - 1) {
d2084 1
a2084 1
		} else if (ui == UINT_MAX)
d2098 1
a2098 1
	u_int32_t ui, bsize, frag, fsize;
d2116 1
a2116 1
		if (ui == UINT_MAX - 1) {
d2119 1
a2119 1
		} else if (ui == UINT_MAX)
d2141 1
a2141 1
	u_int32_t ui;
d2149 1
a2149 1
		if (ui == UINT_MAX - 1) {
d2152 1
a2152 1
		} else if (ui == UINT_MAX)
d2165 1
a2165 1
	u_int32_t ui;
d2191 1
a2191 1
			if (ui == UINT_MAX - 1) {
d2194 1
a2194 1
			} if (ui == UINT_MAX)
d2334 1
a2334 1
zero_partitions(struct disklabel *lp, u_int32_t *freep)
d2341 1
@


1.117
log
@Add missing parens, fixes a bug aded in rev 1.112 where maxval would
be set to 0 most of the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.116 2007/06/06 21:08:55 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.116 2007/06/06 21:08:55 deraadt Exp $";
d1329 2
d1333 1
a1333 3
		    lp->d_secperunit ? lp->d_secperunit :
		    lp->d_ncylinders * lp->d_ncylinders,
		    lp->d_ncylinders * lp->d_ncylinders, 0, 0);
@


1.116
log
@fix the cylinder rounding calculation for "totally using the space" type
calculations; ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.115 2007/06/04 20:23:32 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.115 2007/06/04 20:23:32 otto Exp $";
d2002 1
a2002 1
		    pp->p_size, *freep + new ? 0 : pp->p_size, pp->p_offset,
@


1.115
log
@avoid rounding down to zero cylinders. ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.114 2007/06/01 21:51:15 todd Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.114 2007/06/01 21:51:15 todd Exp $";
d1120 2
a1121 1
				if (cyls > 1 && (cyls * lp->d_secpercyl) - offset > maxval)
@


1.114
log
@add RAID to the list of partition types for which we do not prompt for a
filesystem
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.113 2007/05/29 06:28:15 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.113 2007/05/29 06:28:15 otto Exp $";
d1120 1
a1120 1
				if ((cyls * lp->d_secpercyl) - offset > maxval)
@


1.113
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.112 2007/04/29 18:31:35 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.112 2007/04/29 18:31:35 otto Exp $";
d604 2
a605 1
	    pp->p_fstype == FS_BOOT || pp->p_fstype == FS_OTHER) {
@


1.112
log
@fix rounding in the modify case; ok millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.111 2007/04/26 23:20:41 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.111 2007/04/26 23:20:41 deraadt Exp $";
d150 1
a150 1
		pp->p_fsize = pp->p_frag = pp->p_cpg = 0;
d506 2
a507 1
	pp->p_fsize = partno == 0 ? 1024 : 2048;
d509 1
a509 1
	pp->p_fsize = 2048;
a510 1
	pp->p_frag = 8;
d2057 1
a2057 1
	u_int32_t ui;
d2059 5
d2068 1
a2068 1
		    pp->p_fsize, pp->p_fsize, 0, 0);
d2079 1
a2079 1
	pp->p_fsize = ui;
d2086 1
a2086 1
	u_int32_t ui;
d2090 1
a2090 2
	if (pp->p_fsize == 0) {
		pp->p_frag = 0;
d2092 4
a2095 1
	}
d2100 1
a2100 1
		    pp->p_fsize * pp->p_frag, pp->p_fsize * pp->p_frag,
d2113 1
a2113 1
		else if (ui % pp->p_fsize != 0)
d2116 1
a2116 1
		else if (ui / pp->p_fsize < 1)
d2122 1
a2122 1
	pp->p_frag = ui / pp->p_fsize;
@


1.111
log
@includes that are not needed anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.110 2007/04/26 22:42:11 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.110 2007/04/26 22:42:11 krw Exp $";
d2000 3
a2002 3
		    pp->p_size, *freep, pp->p_offset, DO_CONVERSIONS |
		    ((pp->p_fstype == FS_BSDFFS || pp->p_fstype == FS_SWAP) ?
		    DO_ROUNDING : 0));
@


1.110
log
@Eliminate CPU_BIOS from userland and wd(4) by always using the BIOS
geometry in the disklabel when there is a BIOS geometry to provide.
This removes the option to set a disklabel to 'BIOS' geometry via the
'g b' command in the editor.

Makes reported geometry more consistant and moves MD code to MD land
where it should be.

Doc help from jmc@@, Feedback from millert@@, marco@@, weingart@@,
kettenis@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.109 2007/03/18 20:00:02 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.109 2007/03/18 20:00:02 otto Exp $";
a28 3
#include <sys/reboot.h>
#include <sys/sysctl.h>
#include <machine/cpu.h>
@


1.109
log
@Check for zero divisor _before_ dividing; do not use floating
point arithmetic to round to a cylinder boundary when a simple
integer expression can do the job as well. ok millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.108 2007/03/13 19:25:31 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.108 2007/03/13 19:25:31 otto Exp $";
a31 3
#ifdef CPU_BIOS
#include <machine/biosvar.h>
#endif
d83 1
a83 1
void	find_bounds(struct disklabel *, struct disklabel *);
d97 3
a99 2
void	get_geometry(int, struct disklabel **, struct disklabel **);
void	set_geometry(struct disklabel *, struct disklabel *, struct disklabel *, struct disklabel *, char *);
d113 1
a113 1
	struct disklabel *disk_geop, *bios_geop;
d131 2
a132 2
	/* Get the on-disk and BIOS geometries if possible */
	get_geometry(f, &disk_geop, &bios_geop);
d135 1
a135 1
	find_bounds(&label, bios_geop);
d257 1
a257 1
			set_geometry(&label, disk_geop, bios_geop, lp, arg);
d1619 1
a1619 1
find_bounds(struct disklabel *lp, struct disklabel *bios_lp)
a1641 11
			 * If the ending sector of the BSD fdisk partition
			 * is equal to the ending sector of the BIOS geometry
			 * but the real sector count > BIOS sector count,
			 * adjust the bounds accordingly.  We do this because
			 * the BIOS geometry is limited to disks of ~4gig.
			 */
			if (bios_lp && ending_sector == bios_lp->d_secperunit &&
			    lp->d_secperunit > bios_lp->d_secperunit)
				ending_sector = lp->d_secperunit;

			/*
d1768 2
a1769 2
"The 'g' command is used select which disk geometry to use, the disk, BIOS, or\n"
"user geometry.  It takes as an optional argument ``d'', ``b'', or ``u''.  If \n"
d1774 2
a1775 1
"The 'm' command is used to modify an existing partition.  It takes as an\n"    "optional argument the partition letter to change.  If you do not specify a\n"
d1841 1
a1841 1
		puts("\tg [b|d|u] - use [b]ios, [d]isk or [u]ser geometry.");
d2244 1
a2244 1
get_geometry(int f, struct disklabel **dgpp, struct disklabel **bgpp)
a2245 6
#ifdef CPU_BIOS
	int mib[4];
	size_t size;
	dev_t devno;
	bios_diskinfo_t di;
#endif
d2248 1
a2248 3
#ifdef CPU_BIOS
	struct disklabel *bios_geop;
#endif
a2258 35

	/* Get BIOS geometry */
	*bgpp = NULL;
#ifdef CPU_BIOS
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CHR2BLK;
	mib[2] = st.st_rdev;
	size = sizeof(devno);
	if (sysctl(mib, 3, &devno, &size, NULL, 0) == -1) {
		warn("sysctl(machdep.chr2blk)");
		return;
	}
	devno = MAKEBOOTDEV(major(devno), 0, 0, DISKUNIT(devno), RAW_PART);

	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_BIOS;
	mib[2] = BIOS_DISKINFO;
	mib[3] = devno;
	size = sizeof(di);
	if (sysctl(mib, 4, &di, &size, NULL, 0) == -1) {
		warn("Can't get bios geometry");
		return;
	}
	if ((bios_geop = calloc(1, sizeof(struct disklabel))) == NULL)
		errx(4, "out of memory");

	bios_geop->d_secsize = DEV_BSIZE;
	bios_geop->d_nsectors = di.bios_sectors;
	bios_geop->d_ntracks = di.bios_heads;
	bios_geop->d_ncylinders = di.bios_cylinders;
	bios_geop->d_secpercyl = di.bios_sectors * di.bios_heads;
	bios_geop->d_secperunit = di.bios_cylinders *
	    di.bios_heads * di.bios_sectors;
	*bgpp = bios_geop;
#endif
d2263 1
a2263 1
    struct disklabel *bgp, struct disklabel *ugp, char *p)
a2276 13
	case 'b':
	case 'B':
		if (bgp == NULL)
			fputs("BIOS geometry not defined.\n", stderr);
		else {
			lp->d_secsize = bgp->d_secsize;
			lp->d_nsectors = bgp->d_nsectors;
			lp->d_ntracks = bgp->d_ntracks;
			lp->d_ncylinders = bgp->d_ncylinders;
			lp->d_secpercyl = bgp->d_secpercyl;
			lp->d_secperunit = bgp->d_secperunit;
		}
		break;
@


1.108
log
@Refactor & fix computation of offset for next partition. Now the
code is almost readable. Keep in mind that the starting offset is
inclusive, but the ending offset is exclusive.  I heard rumors that
disklabel was misbehaving in some cases before, but espie@@ was the
only one to provide me with enough details to actually find the
problem.
ok millert@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.107 2007/03/02 02:29:13 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.107 2007/03/02 02:29:13 krw Exp $";
d1112 2
a1113 1
	if ((flags & DO_ROUNDING) && rval < UINT_MAX) {
d1122 1
a1122 2
			cyls = (u_int32_t)((rval / (double)lp->d_secpercyl)
			    + 0.5);
@


1.107
log
@If a default label has been created with the -d command line option or
the  'D' editor command and has not been written to disk when the user
issues the 'q' editor command, ask if the label should be written to
disk before exiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.106 2007/02/22 02:26:35 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.106 2007/02/22 02:26:35 krw Exp $";
d813 4
d821 4
a824 6
		if (spp[i]->p_offset + spp[i]->p_size < ending_sector &&
		    ((new_offset >= spp[i]->p_offset &&
		    new_offset < spp[i]->p_offset + spp[i]->p_size) ||
		    (new_offset + *sizep >= spp[i]->p_offset && new_offset
		    + *sizep <= spp[i]->p_offset + spp[i]->p_size)))
			new_offset = spp[i]->p_offset + spp[i]->p_size;
d829 5
a833 2
		if (new_offset + *sizep >= spp[i]->p_offset &&
		    new_offset + *sizep <= spp[i]->p_offset + spp[i]->p_size) {
@


1.106
log
@Always write the disklabel to disk when asked, even if it appears to
be unchanged. Fixes PR#5209. Proper behaviour of 'q'uit still under
discussion.

ok ray@@ millert@@ ckuethe@@ nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.105 2006/10/14 18:26:55 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.105 2006/10/14 18:26:55 krw Exp $";
d225 2
a226 1
			if (ioctl(f, DIOCGPDINFO, &label) == 0)
d228 1
a228 1
			else {
d325 6
a330 1
			if (memcmp(lp, &label, sizeof(label)) == 0) {
d401 2
a402 1
			else
d404 1
@


1.105
log
@Friends don't let friends look for disklabels in Free/NetBSD MBR
partitions since the kernel doesn't put them or look for them there
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.104 2006/07/01 16:50:33 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.104 2006/07/01 16:50:33 krw Exp $";
d392 2
a393 4
			/* Save label if it has changed. */
			if (memcmp(lp, &label, sizeof(label)) == 0)
				puts("No label changes.");
			else if (writelabel(f, bootarea, &label) != 0)
@


1.104
log
@Eliminate redundant get_le() in favour of letoh32(). Add letoh32()
calls in alpha, hppa, hppa64 and mips63 when accessing the two DOS MBR
u_int32_t fields dp_size and dp_start.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.103 2006/04/26 17:09:34 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.103 2006/04/26 17:09:34 deraadt Exp $";
d1622 1
a1622 1
	 * If we have an MBR, use values from the {Open,Free,Net}BSD partition
d1625 1
a1625 3
	    if (dosdp->dp_typ == DOSPTYP_OPENBSD ||
		    dosdp->dp_typ == DOSPTYP_FREEBSD ||
		    dosdp->dp_typ == DOSPTYP_NETBSD) {
@


1.103
log
@man page is gzip'd, should store as unsigned char array.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.102 2006/04/14 16:38:42 pedro Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.102 2006/04/14 16:38:42 pedro Exp $";
d1631 2
a1632 2
			starting_sector = get_le(&dosdp->dp_start);
			ending_sector = starting_sector + get_le(&dosdp->dp_size);
@


1.102
log
@Remove duplicate code, okay ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.101 2005/12/05 21:30:40 miod Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.101 2005/12/05 21:30:40 miod Exp $";
d298 1
a298 1
			extern const char manpage[];
@


1.101
log
@Avoid an out-of-bounds array access in editor_delete() for invalid partition
name; spotted by Laurent Coustet (ed, debian-fr net)

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.100 2005/11/16 03:12:12 krw Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.100 2005/11/16 03:12:12 krw Exp $";
a498 2
	if (partno >= lp->d_npartitions)
		lp->d_npartitions = partno + 1;
@


1.100
log
@Fix conversion of K units to handle case where sector size > 1024. e.g.
Sony Hi-MD usb drive.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.99 2005/01/07 21:58:14 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.99 2005/01/07 21:58:14 otto Exp $";
d757 1
a757 1
	if (c < 0 || c >= lp->d_npartitions)
d760 3
a762 2
	else if (c >= lp->d_npartitions || (lp->d_partitions[c].p_fstype ==
	    FS_UNUSED && lp->d_partitions[c].p_size == 0))
d764 2
a765 1
	else if (c == RAW_PART)
d770 2
a771 1
	else {
@


1.99
log
@Print disk size and free space in requested unit. Some refactoring to
avoid code duplication as well. ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.98 2004/12/11 07:28:05 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.98 2004/12/11 07:28:05 otto Exp $";
d1042 4
a1045 1
					mult = 1024 / lp->d_secsize;
@


1.98
log
@A compare function for heapsort(3) should not just subtract two
offsets, it does not work if the difference is large. Problem found
by Jean-Gerard Pailloncyi who had false warnings of overlapping
partitions. ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.97 2004/11/06 18:57:59 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.97 2004/11/06 18:57:59 otto Exp $";
a74 1
void	editor_display(struct disklabel *, char **, u_int32_t *, char);
d291 2
a292 2
			editor_display(&label, mountpoints, &freesectors,
			    arg ? *arg : 0);
d361 1
a361 1
				display(fp, &label, 0);
a784 27
}

/*
 * Simplified display() for use with the builtin editor.
 */
void
editor_display(struct disklabel *lp, char **mp, u_int32_t *freep, char unit)
{
	int i;

	printf("device: %s\n", specname);
	printf("type: %s\n", dktypenames[lp->d_type]);
	printf("disk: %.*s\n", (int)sizeof(lp->d_typename), lp->d_typename);
	printf("label: %.*s\n", (int)sizeof(lp->d_packname), lp->d_packname);
	printf("bytes/sector: %u\n", lp->d_secsize);
	printf("sectors/track: %u\n", lp->d_nsectors);
	printf("tracks/cylinder: %u\n", lp->d_ntracks);
	printf("sectors/cylinder: %u\n", lp->d_secpercyl);
	printf("cylinders: %u\n", lp->d_ncylinders);
	printf("total sectors: %u\n", lp->d_secperunit);
	printf("free sectors: %u\n", *freep);
	printf("rpm: %hu\n", lp->d_rpm);
	printf("\n%hu partitions:\n", lp->d_npartitions);
	printf("#    %13.13s %13.13s  fstype [fsize bsize  cpg]\n",
	    "size", "offset");
	for (i = 0; i < lp->d_npartitions; i++)
		display_partition(stdout, lp, mp, i, unit);
@


1.97
log
@gzip embedded man pages, and pipe through gunzip when viewing.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.96 2004/10/04 15:09:41 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.96 2004/10/04 15:09:41 otto Exp $";
d981 6
a986 1
	return((int)(p1->p_offset - p2->p_offset));
d1191 2
a1192 1
				puts("         size   offset    fstype   [fsize bsize   cpg]");
@


1.96
log
@Allow one more char for fstype, to avoid truncation of ISO9660 fstype.
spotted by and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.95 2004/09/28 17:57:46 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.95 2004/09/28 17:57:46 otto Exp $";
d298 3
a300 2
			char *pager;
			extern char manpage[];
d304 4
a307 2
			if ((fp = popen(pager, "w")) != NULL) {
				(void) fwrite(manpage, strlen(manpage), 1, fp);
d312 1
@


1.95
log
@Tidy disklabel output for todays big disks. Based on a diff from f
at obiit dot org in PR 3847. ok tedu@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.94 2004/08/03 09:30:12 otto Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.94 2004/08/03 09:30:12 otto Exp $";
d805 1
a805 1
	printf("#    %13.13s %13.13s fstype [fsize bsize   cpg]\n",
@


1.94
log
@Handle geometry parameters as unsigned quantities, getting rid of
negative number of sectors on large disks and other similar problems.
Also make reading of ASCII disk labels more robust by using strtonum(3)
instead of atoi(3).

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.93 2003/12/29 19:51:34 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.93 2003/12/29 19:51:34 millert Exp $";
d47 1
a70 1
int	editor(struct disklabel *, int, char *, char *);
a108 15
/* from disklabel.c */
int	checklabel(struct disklabel *);
void	display(FILE *, struct disklabel *, char);
void	display_partition(FILE *, struct disklabel *, char **, int, char, int);
int	width_partition(struct disklabel *, int);

struct disklabel *readlabel(int);
struct disklabel *makebootarea(char *, struct disklabel *, int);
int	writelabel(int, char *, struct disklabel *);
extern	char *bootarea, *specname;
extern	int donothing;
#ifdef DOSLABEL
extern	struct dos_partition *dosdp;	/* DOS partition, if found */
#endif

a790 1
	int width;
d805 2
a806 3
	width = width_partition(lp, unit);
	printf("#    %*.*s %*.*s    fstype   [fsize bsize   cpg]\n",
		width, width, "size", width, width, "offset");
d808 1
a808 1
		display_partition(stdout, lp, mp, i, unit, width);
d1183 2
a1184 2
				display_partition(stdout, lp, NULL, i, 0, 0);
				display_partition(stdout, lp, NULL, j, 0, 0);
@


1.93
log
@Add support for % and & units to indicate percent of total space and
percent of available space respectively.  From Sebastian Horzela.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.92 2003/12/20 09:29:27 jmc Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.92 2003/12/20 09:29:27 jmc Exp $";
d812 6
a817 6
	printf("bytes/sector: %ld\n", (long)lp->d_secsize);
	printf("sectors/track: %ld\n", (long)lp->d_nsectors);
	printf("tracks/cylinder: %ld\n", (long)lp->d_ntracks);
	printf("sectors/cylinder: %ld\n", (long)lp->d_secpercyl);
	printf("cylinders: %ld\n", (long)lp->d_ncylinders);
	printf("total sectors: %ld\n", (long)lp->d_secperunit);
d819 2
a820 2
	printf("rpm: %ld\n", (long)lp->d_rpm);
	printf("\n%d partitions:\n", lp->d_npartitions);
@


1.92
log
@make disklabel docs more readable: more logical SYNOPSIS; sort options;
make internal editor help and usage() match the docs; make sure all the
forms described in SYNOPSIS are explained; various other tweaks.

input from millert@@; ok deraadt;
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.91 2003/09/24 20:40:19 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.91 2003/09/24 20:40:19 deraadt Exp $";
d1038 1
a1038 1
	double d;
d1089 12
d1120 1
a1120 1
					rval = d * mult;
d1123 1
a1123 1
					rval = d / (-mult);
d1892 1
@


1.91
log
@realloc fixes; ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.90 2003/08/29 00:17:09 tedu Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.90 2003/08/29 00:17:09 tedu Exp $";
d1856 1
a1856 3
		puts("\tp [unit]  - print label.");
		puts("\tM         - show entire OpenBSD man page for disklabel.");
		puts("\te         - edit drive parameters.");
d1860 1
d1862 3
a1864 2
		puts("\tD         - set label to default.");
		puts("\tg [d|b]   - Use [d]isk or [b]ios geometry.");
d1867 2
d1870 1
a1871 1
		puts("\ts [path]  - save label to file.");
d1873 1
a1873 1
		puts("\tq         - quit and save changes.");
a1874 1
		puts("\tX         - toggle expert mode.");
a1875 1
		puts("\t? [cmnd]  - this message or command specific help.");
@


1.90
log
@exclude __sparc64__ since it can handle 16k blocks.  from jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.89 2003/08/28 20:19:54 tedu Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.89 2003/08/28 20:19:54 tedu Exp $";
d1890 1
d1896 2
a1897 2
			to[i] = realloc(to[i], len);
			if (to[i] == NULL)
d1899 1
@


1.89
log
@sparcs cannot handle booting from > 8k block partitions, so set the root
partition block size back down.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.88 2003/07/29 18:38:35 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.88 2003/07/29 18:38:35 deraadt Exp $";
d517 1
a517 1
#ifdef __sparc__
@


1.88
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.87 2003/07/16 18:03:44 tedu Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.87 2003/07/16 18:03:44 tedu Exp $";
d517 4
d522 1
@


1.87
log
@new default frag/block sizes.
reminded by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.86 2003/06/17 21:56:24 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.86 2003/06/17 21:56:24 millert Exp $";
d542 1
a542 1
	
d609 1
a609 1
	
d651 1
a651 1
	
d839 1
a839 1
	
d1174 1
a1174 1
					
d1560 1
a1560 1
	
d1605 1
a1605 1
				
@


1.86
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.85 2003/06/11 06:22:12 deraadt Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.85 2003/06/11 06:22:12 deraadt Exp $";
d517 1
a517 1
	pp->p_fsize = 1024;
d2079 1
a2079 1
		    "Size of fs block fragments.  Usually 1024 or 512.",
d2109 1
a2109 1
		    "Size of filesystem blocks.  Usually 8192 or 4096.",
@


1.85
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.84 2003/06/03 01:52:40 millert Exp $	*/
d10 7
a16 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.84 2003/06/03 01:52:40 millert Exp $";
@


1.84
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.83 2003/04/05 23:19:44 millert Exp $	*/
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.83 2003/04/05 23:19:44 millert Exp $";
d128 1
a128 5
editor(lp, f, dev, fstabfile)
	struct disklabel *lp;
	int f;
	char *dev;
	char *fstabfile;
d443 1
a443 5
editor_add(lp, mp, freep, p)
	struct disklabel *lp;
	char **mp;
	u_int32_t *freep;
	char *p;
d584 1
a584 4
editor_name(lp, mp, p)
	struct disklabel *lp;
	char **mp;
	char *p;
d625 1
a625 5
editor_modify(lp, mp, freep, p)
	struct disklabel *lp;
	char **mp;
	u_int32_t *freep;
	char *p;
d734 1
a734 5
editor_delete(lp, mp, freep, p)
	struct disklabel *lp;
	char **mp;
	u_int32_t *freep;
	char *p;
d798 1
a798 5
editor_display(lp, mp, freep, unit)
	struct disklabel *lp;
	char **mp;
	u_int32_t *freep;
	char unit;
d828 1
a828 3
next_offset(lp, sizep)
	struct disklabel *lp;
	u_int32_t *sizep;
d886 1
a886 4
editor_change(lp, freep, p)
	struct disklabel *lp;
	u_int32_t *freep;
	char *p;
d955 1
a955 2
make_contiguous(lp)
	struct disklabel *lp;
d984 1
a984 2
partition_cmp(e1, e2)
	const void *e1, *e2;
d993 1
a993 4
getstring(prompt, helpstring, oval)
	char *prompt;
	char *helpstring;
	char *oval;
d1026 2
a1027 9
getuint(lp, partno, prompt, helpstring, oval, maxval, offset, flags)
	struct disklabel *lp;
	int partno;
	char *prompt;
	char *helpstring;
	u_int32_t oval;
	u_int32_t maxval;		/* XXX - used inconsistently */
	u_int32_t offset;
	int flags;
d1149 1
a1149 4
has_overlap(lp, freep, resolve)
	struct disklabel *lp;
	u_int32_t *freep;
	int resolve;
d1219 1
a1219 3
edit_parms(lp, freep)
	struct disklabel *lp;
	u_int32_t *freep;
d1407 1
a1407 3
sort_partitions(lp, npart)
	struct disklabel *lp;
	u_int16_t *npart;
d1452 1
a1452 4
getdisktype(lp, banner, dev)
	struct disklabel *lp;
	char *banner;
	char *dev;
d1531 1
a1531 3
set_bounds(lp, freep)
	struct disklabel *lp;
	u_int32_t *freep;
d1569 1
a1569 2
free_chunks(lp)
	struct disklabel *lp;
d1624 1
a1624 3
find_bounds(lp, bios_lp)
	struct disklabel *lp;
	struct disklabel *bios_lp;
d1695 1
a1695 3
editor_countfree(lp, freep)
	struct disklabel *lp;
	u_int32_t *freep;
d1712 1
a1712 2
editor_help(arg)
	char *arg;
d1882 1
a1882 3
mpcopy(to, from)
	char **to;
	char **from;
d1903 1
a1903 3
mpequal(mp1, mp2)
	char **mp1;
	char **mp2;
d1920 1
a1920 5
mpsave(lp, mp, cdev, fstabfile)
	struct disklabel *lp;
	char **mp;
	char *cdev;
	char *fstabfile;
d1972 1
a1972 3
get_offset(lp, partno)
	struct disklabel *lp;
	int partno;
d2010 1
a2010 5
get_size(lp, partno, freep, new)
	struct disklabel *lp;
	int partno;
	u_int32_t *freep;
	int new;
d2072 1
a2072 3
get_fsize(lp, partno)
	struct disklabel *lp;
	int partno;
d2096 1
a2096 3
get_bsize(lp, partno)
	struct disklabel *lp;
	int partno;
d2137 1
a2137 3
get_cpg(lp, partno)
	struct disklabel *lp;
	int partno;
d2160 1
a2160 3
get_fstype(lp, partno)
	struct disklabel *lp;
	int partno;
d2203 1
a2203 4
get_mp(lp, mp, partno)
	struct disklabel *lp;
	char **mp;
	int partno;
d2241 1
a2241 3
micmp(a1, a2)
	const void *a1;
	const void *a2;
d2258 1
a2258 4
get_geometry(f, dgpp, bgpp)
	int f;
	struct disklabel **dgpp;
	struct disklabel **bgpp;
d2319 2
a2320 6
set_geometry(lp, dgp, bgp, ugp, p)
	struct disklabel *lp;
	struct disklabel *dgp;
	struct disklabel *bgp;
	struct disklabel *ugp;
	char *p;
d2388 1
a2388 3
zero_partitions(lp, freep)
	struct disklabel *lp;
	u_int32_t *freep;
@


1.83
log
@o replace a strncpy + manual NUL terminate w/ strlcpy
o remove NUL termination of d_packname since it is not needed.
krw@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.82 2003/02/13 00:10:39 tedu Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.82 2003/02/13 00:10:39 tedu Exp $";
@


1.82
log
@add support for printing disklabels in units other than sectors from
the cmdline
based on a patch by mho at mho.nu
ok and input by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.81 2002/06/09 08:13:05 todd Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.81 2002/06/09 08:13:05 todd Exp $";
d1058 2
a1059 4
		else if (oval != NULL && buf[0] == '\0') {
			(void)strncpy(buf, oval, sizeof(buf) - 1);
			buf[sizeof(buf) - 1] = '\0';
		}
d1322 1
a1322 2
	strncpy(lp->d_packname, p, sizeof(lp->d_packname) - 1);
	lp->d_packname[sizeof(lp->d_packname) - 1] = '\0';
@


1.81
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.80 2002/05/22 08:21:01 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.80 2002/05/22 08:21:01 deraadt Exp $";
d122 1
a122 1
void	display(FILE *, struct disklabel *);
d388 1
a388 1
				display(fp, &label);
@


1.80
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.79 2002/02/16 21:27:33 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.79 2002/02/16 21:27:33 millert Exp $";
d1775 1
a1775 1
			pp->p_size > 0 && 
d2034 1
a2034 1
	/* Sort mountpoints so we don't try to mount /usr/local before /usr */ 
d2363 1
a2363 1
	int mib[4]; 
@


1.79
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.78 2002/01/24 23:01:19 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.78 2002/01/24 23:01:19 millert Exp $";
d1962 3
a1964 1
			to[i] = realloc(to[i], strlen(from[i]) + 1);
d1967 1
a1967 1
			(void)strcpy(to[i], from[i]);
@


1.78
log
@Fix `necesary' typos; Alexander Yurchenko

Alas many of these were introduced by yours truly as necessary
just doesn't look right to me for some reason ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.77 2001/07/07 18:26:10 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.77 2001/07/07 18:26:10 deraadt Exp $";
d80 35
a114 35
void	edit_parms __P((struct disklabel *, u_int32_t *));
int	editor __P((struct disklabel *, int, char *, char *));
void	editor_add __P((struct disklabel *, char **, u_int32_t *, char *));
void	editor_change __P((struct disklabel *, u_int32_t *, char *));
void	editor_countfree __P((struct disklabel *, u_int32_t *));
void	editor_delete __P((struct disklabel *, char **, u_int32_t *, char *));
void	editor_display __P((struct disklabel *, char **, u_int32_t *, char));
void	editor_help __P((char *));
void	editor_modify __P((struct disklabel *, char **, u_int32_t *, char *));
void	editor_name __P((struct disklabel *, char **, char *));
char	*getstring __P((char *, char *, char *));
u_int32_t getuint __P((struct disklabel *, int, char *, char *, u_int32_t, u_int32_t, u_int32_t, int));
int	has_overlap __P((struct disklabel *, u_int32_t *, int));
void	make_contiguous __P((struct disklabel *));
u_int32_t next_offset __P((struct disklabel *, u_int32_t *));
int	partition_cmp __P((const void *, const void *));
struct partition **sort_partitions __P((struct disklabel *, u_int16_t *));
void	getdisktype __P((struct disklabel *, char *, char *));
void	find_bounds __P((struct disklabel *, struct disklabel *));
void	set_bounds __P((struct disklabel *, u_int32_t *));
struct diskchunk *free_chunks __P((struct disklabel *));
char **	mpcopy __P((char **, char **));
int	micmp __P((const void *, const void *));
int	mpequal __P((char **, char **));
int	mpsave __P((struct disklabel *, char **, char *, char *));
int	get_bsize __P((struct disklabel *, int));
int	get_cpg __P((struct disklabel *, int));
int	get_fsize __P((struct disklabel *, int));
int	get_fstype __P((struct disklabel *, int));
int	get_mp __P((struct disklabel *, char **, int));
int	get_offset __P((struct disklabel *, int));
int	get_size __P((struct disklabel *, int, u_int32_t *, int));
void	get_geometry __P((int, struct disklabel **, struct disklabel **));
void	set_geometry __P((struct disklabel *, struct disklabel *, struct disklabel *, struct disklabel *, char *));
void	zero_partitions __P((struct disklabel *, u_int32_t *));
d121 8
a128 8
int	checklabel __P((struct disklabel *));
void	display __P((FILE *, struct disklabel *));
void	display_partition __P((FILE *, struct disklabel *, char **, int, char, int));
int	width_partition __P((struct disklabel *, int));

struct disklabel *readlabel __P((int));
struct disklabel *makebootarea __P((char *, struct disklabel *, int));
int	writelabel __P((int, char *, struct disklabel *));
@


1.77
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.76 2001/05/19 05:10:46 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.76 2001/05/19 05:10:46 millert Exp $";
d524 1
a524 1
	/* Increase d_npartitions if necesary */
d1427 1
a1427 1
	/* Adjust ending_sector if necesary. */
@


1.76
log
@When zeroing out the parition table, make 'c' the entire disk, not just
the OpenBSD portion of the disk.  This is conistent with the idea of
'c' throughout the program.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.75 2001/03/12 23:03:59 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.75 2001/03/12 23:03:59 deraadt Exp $";
d151 1
a151 1
	char **mountpoints = NULL, **omountpoints, **tmpmountpoints;
d1695 1
d1697 1
a1697 1

d2368 1
d2370 1
a2370 1

@


1.75
log
@correct warning; maurice@@maurice.wan.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.74 2000/10/22 23:59:40 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.74 2000/10/22 23:59:40 millert Exp $";
d2498 1
a2498 2
	lp->d_partitions[RAW_PART].p_offset = starting_sector;
	lp->d_partitions[RAW_PART].p_size = ending_sector - starting_sector;
@


1.74
log
@Use clearerr(3) to clear EOF on stdin when aborting a command due to ^D.
Fixes a bug exposed by the last revision (we got away with before it due
to the rewind(3) calls).
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.73 2000/08/13 22:07:14 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.73 2000/08/13 22:07:14 millert Exp $";
d311 1
a311 1
				    "without the -F flag.\n", stderr);
@


1.73
log
@Get rid of fflush(stdout); rewind(stdin); pairs since we should not
have to worry about stdout == stdin (and since this is done inconsistently
it is useless anyway).  Pointed out by map@@infinitum.ch.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.72 2000/06/04 18:34:41 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.72 2000/06/04 18:34:41 millert Exp $";
d1048 1
d1097 1
@


1.72
log
@Don't exit just because we couldn't get the default label...
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.71 2000/06/04 18:19:45 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.71 2000/06/04 18:19:45 millert Exp $";
a206 2
		fflush(stdout);
		rewind(stdin);
a1044 2
		fflush(stdout);
		rewind(stdin);
a1092 2
		fflush(stdout);
		rewind(stdin);
@


1.71
log
@Add 'D' and 'z' commands to editor to use the default partition and
to zero out the partition table respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.70 2000/05/05 19:10:35 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.70 2000/05/05 19:10:35 millert Exp $";
d256 8
a263 6
			tmplabel = label;
			label = lastlabel;
			lastlabel = tmplabel;
			if (ioctl(f, DIOCGPDINFO, &label) < 0)
				err(4, "ioctl DIOCGDINFO");
			editor_countfree(&label, &freesectors);
d441 2
a442 3
			tmplabel = label;
			label = lastlabel;
			lastlabel = tmplabel;
@


1.70
log
@Reserve the first cylinder for bootblock if NUMBOOT=1.  Basically treat
it the same as the space we reserver on i386 to avoid fdisk trouncing.
The user can change this via the 'b' command and a message is printed
at startup to this effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.69 2000/04/04 16:29:27 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.69 2000/04/04 16:29:27 millert Exp $";
d114 1
d255 9
d278 8
d438 5
a442 1
		case '\n':
d445 1
a445 6
		case 'e':
			tmplabel = lastlabel;
			lastlabel = label;
			edit_parms(&label, &freesectors);
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0)
				lastlabel = tmplabel;
d481 2
a482 1
		if (partno < 0 || partno == 2 || partno >= MAXPARTITIONS) {
d497 2
a498 1
			if (lp->d_partitions[partno].p_size == 0 && partno != 2)
d780 1
a780 1
			if (c == 2)
d801 1
a801 1
	else if (c == 2)
d981 1
a981 1
		if (partno == 2 && newsize +
d1218 1
a1218 1
	if (npartitions < 2) {
d1800 1
a1800 1
"The 'M' command pipes the entire OpenBSD manual page for disklabel though\n"
d1845 5
d1907 6
d1918 5
d1932 1
d1943 1
d2130 2
a2131 1
			if (partno == 2 && ui + pp->p_offset > lp->d_secperunit) {
d2490 14
@


1.69
log
@Add "expert mode" and don't prompt for fsize/bsize/cpg unless an expert

next_offset() now takes a pointer to the partition size as its second
argument instead of a pointer to the partition.  This allows us to
get the offset earlier on and sort_partitions() will not try and
include the partition we are trying to create in its list.

In free_chunks() start looking for things at starting_sector, not 0,
to avoid getting starting offsets that precede the start of the OpenBSD
part of the disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.68 2000/03/23 01:24:28 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.68 2000/03/23 01:24:28 millert Exp $";
a520 7
#if NUMBOOT == 1
	/* Don't clobber boot blocks */
	if (pp->p_offset == 0) {
		pp->p_offset = lp->d_secpercyl;
		pp->p_size -= lp->d_secpercyl;
	}
#endif
d1735 5
@


1.68
log
@Don't use the BIOS geometry by default, it causes too many problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.67 2000/02/21 14:28:02 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997-1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.67 2000/02/21 14:28:02 deraadt Exp $";
d94 1
a94 1
u_int32_t next_offset __P((struct disklabel *, struct partition *));
d117 1
d410 6
d515 2
a520 2
	pp->p_size = *freep;
	pp->p_offset = next_offset(lp, pp);	/* must be computed last */
d572 1
a572 1
	if (pp->p_fstype == FS_BSDFFS) {
d717 1
a717 1
	if (pp->p_fstype == FS_BSDFFS || pp->p_fstype == FS_UNUSED) {
d851 1
a851 1
next_offset(lp, pp)
d853 1
a853 1
	struct partition *pp;
d863 1
a863 1
		return(0);
a866 4
		/* Skip the partition for which we are finding an offset */
		if (pp == spp[i])
			continue;

d874 2
a875 2
		    (new_offset + pp->p_size >= spp[i]->p_offset && new_offset
		    + pp->p_size <= spp[i]->p_offset + spp[i]->p_size)))
d881 2
a882 2
		if (new_offset + pp->p_size >= spp[i]->p_offset &&
		    new_offset + pp->p_size <= spp[i]->p_offset + spp[i]->p_size) {
d900 1
a900 1
		pp->p_size = new_size;
d1639 1
a1639 1
		chunks[0].start = 0;
d1648 1
a1648 1
		chunks[0].start = 0;
d1908 1
@


1.67
log
@missing newline
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.66 1999/07/14 23:16:26 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.66 1999/07/14 23:16:26 deraadt Exp $";
a1729 17

			/*
			 * If we are honoring the fdisk partitions, we should
			 * use the BIOS geometry unless ending_sector is beyond
			 * the end of the BIOS geometry, in which case we know
			 * the BIOS geometry is bogus.
			 */
			if (bios_lp != NULL && ending_sector <= bios_lp->d_secperunit) {
				lp->d_secsize = bios_lp->d_secsize;
				lp->d_nsectors = bios_lp->d_nsectors;
				lp->d_ntracks = bios_lp->d_ntracks;
				lp->d_ncylinders = bios_lp->d_ncylinders;
				lp->d_secpercyl = bios_lp->d_secpercyl;
				lp->d_secperunit = bios_lp->d_secperunit;
				puts("Using BIOS geometry...\nYou can use the "
				    "'g' command to change this.");
			}
@


1.66
log
@put in a check for architectures that demand that partition A start at sector 0
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.65 1999/06/10 22:37:54 pjanzen Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.65 1999/06/10 22:37:54 pjanzen Exp $";
d2060 1
a2060 1
			    "partition 'a' start at sector 0.");
@


1.65
log
@Handle PAGER in a manner consistent with the Single Unix Specification:
that is, use PAGER rather than "more" if it is defined and non-null, not
just if it is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.64 1999/06/06 18:42:29 aaron Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.64 1999/06/06 18:42:29 aaron Exp $";
d2057 5
@


1.64
log
@typo; mcsmart@@engin.umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.63 1999/04/07 22:57:26 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.63 1999/04/07 22:57:26 millert Exp $";
d312 1
a312 1
			if ((pager = getenv("PAGER")) == NULL)
@


1.63
log
@Kill -F option, it is not needed and just plain wrong anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.61 1999/04/07 07:50:59 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.61 1999/04/07 07:50:59 millert Exp $";
d1866 1
a1866 1
"The 'm' command is used to set the mount point for a partition (ie: name it).\n"
@


1.62
log
@XXX temp fix for whole_mode; todd will fix better in tomorrow
@
text
@d81 1
a81 1
int	editor __P((struct disklabel *, int, char *, char *, int));
d98 1
a98 1
void	find_bounds __P((struct disklabel *, struct disklabel *, int));
d137 1
a137 1
editor(lp, f, dev, fstabfile, whole_mode)
d166 1
a166 1
	find_bounds(&label, bios_geop, whole_mode);
d1679 1
a1679 1
find_bounds(lp, bios_lp, whole_mode)
a1681 1
	int whole_mode;
a1692 1
	 * unless we are in whole disk mode (in which case we ignore the MBR).
d1696 2
a1697 2
		dosdp->dp_typ == DOSPTYP_FREEBSD ||
		dosdp->dp_typ == DOSPTYP_NETBSD) {
d1749 1
a1749 1
			starting_sector = 32;
@


1.61
log
@o Be silent on fstab writing
o Change "Save changes" prompt to "Write new label"
o call writelabel() with &label and then update *lp instead of
  updating *lp and then calling writelabel() with lp.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.60 1999/04/01 21:43:48 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.60 1999/04/01 21:43:48 millert Exp $";
d1697 3
a1699 3
	    if (!whole_mode && (dosdp->dp_typ == DOSPTYP_OPENBSD ||
		    dosdp->dp_typ == DOSPTYP_FREEBSD ||
		    dosdp->dp_typ == DOSPTYP_NETBSD)) {
@


1.60
log
@get mountpoint before fsize/bsize/cpg and crunch things a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.59 1999/04/01 21:10:13 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.59 1999/04/01 21:10:13 millert Exp $";
d337 3
a339 3
				arg = getstring("Save changes?",
				    "Save changes you have made to the label?",
				    "n");
d342 2
a343 2
				*lp = label;
				if (writelabel(f, bootarea, lp) == 0)
d345 2
a2027 1
	printf("Wrote fstab entries to %s\n", fstabfile);
@


1.59
log
@Fix filesystem type when writing fstab in -f mode
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.59 1999/04/01 21:07:57 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.59 1999/04/01 21:07:57 millert Exp $";
d557 2
a558 2
	/* Get filesystem type */
	if (get_fstype(lp, partno) != 0) {
d563 4
a566 3
	if (pp->p_fstype == FS_BSDFFS || pp->p_fstype == FS_UNUSED) {
		/* Get fsize */
		if (get_fsize(lp, partno) != 0) {
d570 1
a571 20
		/* Get bsize */
		if (get_bsize(lp, partno) != 0) {
			pp->p_size = 0;			/* effective delete */
			return;
		}

		if (pp->p_fstype == FS_BSDFFS) {
			/* get cpg */
			if (get_cpg(lp, partno) != 0) {
				pp->p_size = 0;		/* effective delete */
				return;
			}
		}

		/* get mount point */
		if (get_mp(lp, mp, partno) != 0) {
			pp->p_size = 0;			/* effective delete */
			return;
		}
	}
d702 6
a727 6
	}

	/* get mount point */
	if (get_mp(lp, mp, partno) != 0) {
		*pp = origpart;			/* undo changes */
		return;
@


1.58
log
@Use fstypenames, not fstypesnames since fstypesnames does not list strings for all types
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.57 1999/03/23 05:18:50 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.57 1999/03/23 05:18:50 millert Exp $";
d1998 1
a1998 1
	int i, mpset;
d2037 2
a2038 1
		fprintf(fp, "%s%c %s %s rw 1 %d\n", bdev, 'a' + mi[i].partno,
d2040 2
a2041 2
		    fstypesnames[lp->d_partitions[i].p_fstype],
		    i == 0 ? 1 : 2);
@


1.57
log
@Rename -F option to -f and add a new -F (full disk) option to use in -E mode.
When checking for an MBR, only say we have an mbr if there is a signature *or*
there is an fdisk partition with an {Open,Free,Net}BSD ID.
When setting the bounds in -E mode add hueristics to deal with disks
bigger than the BIOS geometry would indicate.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.56 1999/03/21 22:11:42 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.56 1999/03/21 22:11:42 millert Exp $";
d634 1
a634 1
		    fstypesnames[lp->d_partitions[partno].p_fstype]);
@


1.56
log
@dosdp should be extern
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.55 1999/03/21 19:31:10 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.55 1999/03/21 19:31:10 millert Exp $";
d81 1
a81 1
int	editor __P((struct disklabel *, int, char *, char *));
d98 1
a98 1
void	find_bounds __P((struct disklabel *));
d137 1
a137 1
editor(lp, f, dev, fstabfile)
a161 3
	/* How big is the OpenBSD portion of the disk?  */
	find_bounds(&label);

d165 3
d176 1
a176 1
	pp = &label.d_partitions[2];
d1695 1
a1695 1
find_bounds(lp)
d1697 2
d1700 1
a1700 1
	struct partition *pp = &lp->d_partitions[2];
d1709 2
a1710 1
	 * If we have an MBR, use values from the {Open,Free,Net}BSD partition.
d1712 56
a1767 22
	if (dosdp && pp->p_size &&
	    (dosdp->dp_typ == DOSPTYP_OPENBSD ||
	    dosdp->dp_typ == DOSPTYP_FREEBSD ||
	    dosdp->dp_typ == DOSPTYP_NETBSD)) {
		u_int32_t i, new_end;

		/* Set start and end based on the fdisk partition bounds */
		starting_sector = get_le(&dosdp->dp_start);
		ending_sector = starting_sector + get_le(&dosdp->dp_size);

		/*
		 * If there are any BSD or SWAP partitions beyond ending_sector
		 * we extend ending_sector to include them.  This is done
		 * because the BIOS geometry is generally different from the
		 * disk geometry.
		 */
		for (i = new_end = 0; i < lp->d_npartitions; i++) {
			pp = &lp->d_partitions[i];
			if ((pp->p_fstype == FS_BSDFFS ||
			    pp->p_fstype == FS_SWAP) &&
			    pp->p_size + pp->p_offset > new_end)
				new_end = pp->p_size + pp->p_offset;
a1768 2
		if (new_end > ending_sector)
			ending_sector = new_end;
@


1.55
log
@Add support for switching disk geometry between disk, bios, and user
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.54 1999/03/21 17:22:33 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.54 1999/03/21 17:22:33 millert Exp $";
d130 1
a130 1
struct dos_partition *dosdp;	/* DOS partition, if found */
@


1.54
log
@If there are any BSD or SWAP partitions beyond ending_sector we extend
ending_sector to include them.  This is done because the BIOS geometry
is generally different from the disk geometry.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.53 1999/03/18 04:36:22 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.53 1999/03/18 04:36:22 millert Exp $";
d36 2
d40 6
d90 1
a90 1
char	*getstring __P((struct disklabel *, char *, char *, char *));
d112 2
d144 1
d165 3
d192 4
a195 6
	if (strcmp(label.d_packname, "fictitious") == 0) {
		if (label.d_bbsize == 0)
			label.d_bbsize = BBSIZE;
		if (label.d_sbsize == 0)
			label.d_sbsize = SBSIZE;
	}
d267 8
d337 1
a337 1
				arg = getstring(&label, "Save changes?",
d358 1
a358 1
				arg = getstring(lp, "Filename",
d480 1
a480 1
			p = getstring(lp, "partition",
d611 1
a611 1
		p = getstring(lp, "partition to name",
a651 1
	u_int32_t ui;
d656 1
a656 1
		p = getstring(lp, "partition to modify",
d767 1
a767 1
		p = getstring(lp, "partition to delete",
d934 1
a934 1
		p = getstring(lp, "partition to change size",
d1036 1
a1036 2
getstring(lp, prompt, helpstring, oval)
	struct disklabel *lp;
d1291 1
a1291 1
		p = getstring(lp, "disk type",
d1320 1
a1320 1
	p = getstring(lp, "label name",
d1528 11
a1538 11
		"sd",	"SCSI",
		"rz",	"SCSI",
		"wd",	"IDE",
		"fd",	"FLOPPY",
		"xd",	"SMD",
		"xy",	"SMD",
		"hd",	"HP-IB",
		"ccd",	"CCD",
		"vnd",	"VND",
		"svnd",	"VND",
		NULL,	NULL
d1567 1
a1567 1
			s = getstring(lp, "Disk type",
d1833 6
d1896 1
d2216 1
a2216 1
		p = getstring(lp, "FS type",
d2264 1
a2264 1
			p = getstring(lp, "mount point",
d2309 136
@


1.53
log
@make sure mountpoint starts with '/' and call get_mp() from editor_name() instead of rolling our own
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.52 1999/03/18 01:59:20 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.52 1999/03/18 01:59:20 millert Exp $";
d1680 1
a1680 1
	struct  partition *pp = &lp->d_partitions[2];
d1688 3
a1690 1
	/* If we have an MBR, use values from the OpenBSD/FreeBSD parition. */
d1695 3
d1700 17
a1719 4
		/*
		 * XXX - check to see if any BSD/SWAP partitions go beyond
		 *	 ending_sector and prompt to extend ending_sector if so.
		 */
@


1.52
log
@Sort entries by mountpoint, not partition number when writing fstab via
the -F option.  We do this to make sure /var occurs before /var/mail,
/usr before /usr/local, etc...
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.51 1999/03/16 21:26:04 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.51 1999/03/16 21:26:04 millert Exp $";
d618 1
a618 17
	p = getstring(lp, "mount point",
	    "Where to mount this filesystem (ie: / /var /usr)",
	    mp[partno] ? mp[partno] : "none");
	if (p == NULL) {
		fputs("Command aborted\n", stderr);
		pp->p_size = 0;		/* effective delete */
		return;
	}
	if (mp[partno] != NULL) {
		free(mp[partno]);
		mp[partno] = NULL;
	}
	if (strcasecmp(p, "none") != 0) {
		/* XXX - check that it starts with '/' */
		if ((mp[partno] = strdup(p)) == NULL)
			errx(4, "out of memory");
	}
d2220 24
a2243 15
		p = getstring(lp, "mount point",
		    "Where to mount this filesystem (ie: / /var /usr)",
		    mp[partno] ? mp[partno] : "none");
		if (p == NULL) {
			fputs("Command aborted\n", stderr);
			return(1);
		}
		if (mp[partno] != NULL) {
			free(mp[partno]);
			mp[partno] = NULL;
		}
		if (strcasecmp(p, "none") != 0) {
			/* XXX - check that it starts with '/' */
			if ((mp[partno] = strdup(p)) == NULL)
				errx(4, "out of memory");
@


1.51
log
@put duplicate code into its own functions and fix some minor problems this brought to light
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.50 1999/03/16 04:47:16 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.50 1999/03/16 04:47:16 millert Exp $";
d66 6
d94 1
d1938 1
d1941 2
d1945 2
a1947 1
			break;
d1950 1
d1952 1
a1952 1
		return(1);
d1968 3
d1974 3
a1976 4
	for (i = 0; i < MAXPARTITIONS; i++) {
		if (mp[i] == NULL)
			continue;
		fprintf(fp, "%s%c %s %s rw 1 %d\n", bdev, 'a' + i, mp[i],
d2254 19
@


1.50
log
@Add -F flag to cause editor to prompt for mount points and save the resulting info in fstab format.  To be used by the install script.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.48 1999/03/13 19:42:40 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.48 1999/03/13 19:42:40 millert Exp $";
d90 7
d497 3
a499 23
	for (;;) {
		ui = getuint(lp, partno, "offset",
		   "Starting sector for this partition.", pp->p_offset,
		   pp->p_offset, 0, DO_CONVERSIONS |
		   (pp->p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			pp->p_size = 0;		/* effective delete */
			return;
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui < starting_sector)
			fprintf(stderr, "The OpenBSD portion of the disk starts"
			    " at sector %u, you tried to add a partition at %u."
			    "  You can use the 'b' command to change the size "
			    "of the OpenBSD portion.\n" , starting_sector, ui);
		else if (ui >= ending_sector)
			fprintf(stderr, "The OpenBSD portion of the disk ends "
			    "at sector %u, you tried to add a partition at %u."
			    "  You can use the 'b' command to change the size "
			    "of the OpenBSD portion.\n", ending_sector, ui);
		else
			break;
a500 1
	pp->p_offset = ui;
d516 3
a518 23
	for (;;) {
		ui = getuint(lp, partno, "size", "Size of the partition.",
		    pp->p_size, *freep, pp->p_offset, DO_CONVERSIONS |
		    ((pp->p_fstype == FS_BSDFFS || pp->p_fstype == FS_SWAP) ?
		    DO_ROUNDING : 0));
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			pp->p_size = 0;		/* effective delete */
			return;
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else if (ui > *freep)
			/* XXX - prompt user to steal space from another partition */
			fprintf(stderr,"Sorry, there are only %u sectors left\n",
			    *freep);
		else if (pp->p_offset + ui > ending_sector)
			fprintf(stderr, "The OpenBSD portion of the disk ends "
			    "at sector %u, you tried to add a partition ending "
			    "at sector %u.  You can use the 'b' command to "
			    "change the size of the OpenBSD portion.\n",
			    ending_sector, pp->p_offset + ui);
		else
			break;
a519 3
	pp->p_size = ui;
	if (pp->p_size == 0)
		return;
d530 4
a533 35
	/* Get fstype */
	if (pp->p_fstype < FSMAXTYPES) {
		p = getstring(lp, "FS type",
		    "Filesystem type (usually 4.2BSD or swap)",
		    fstypenames[pp->p_fstype]);
		if (p == NULL) {
			fputs("Command aborted\n", stderr);
			pp->p_size = 0;		/* effective delete */
			return;
		}
		for (i = 0; i < FSMAXTYPES; i++) {
			if (!strcasecmp(p, fstypenames[i])) {
				pp->p_fstype = i;
				break;
			}
		}
		if (i >= FSMAXTYPES) {
			printf("Unrecognized filesystem type '%s', treating as 'unknown'\n", p);
			pp->p_fstype = FS_OTHER;
		}
	} else {
		for (;;) {
			ui = getuint(lp, partno, "FS type (decimal)",
			    "Filesystem type as a decimal number; usually 7 (4.2BSD) or 1 (swap).",
			    pp->p_fstype, pp->p_fstype, 0, 0);
			if (ui == UINT_MAX - 1) {
				fputs("Command aborted\n", stderr);
				pp->p_size = 0;		/* effective delete */
				return;
			} if (ui == UINT_MAX)
				fputs("Invalid entry\n", stderr);
			else
				break;
		}
		pp->p_fstype = ui;
d537 4
a540 13
		/* get fsize */
		for (;;) {
			ui = getuint(lp, partno, "fragment size",
			    "Size of fs block fragments.  Usually 1024 or 512.",
			    pp->p_fsize, pp->p_fsize, 0, 0);
			if (ui == UINT_MAX - 1) {
				fputs("Command aborted\n", stderr);
				pp->p_size = 0;		/* effective delete */
				return;
			} else if (ui == UINT_MAX)
				fputs("Invalid entry\n", stderr);
			else
				break;
a541 3
		pp->p_fsize = ui;
		if (pp->p_fsize == 0)
			puts("Zero fragment size implies zero block size");
d543 4
a546 25
		/* get bsize */
		/* XXX - do before frag size? */
		for (; pp->p_fsize > 0;) {
			ui = getuint(lp, partno, "block size",
			    "Size of filesystem blocks.  Usually 8192 or 4096.",
			    pp->p_fsize * pp->p_frag, pp->p_fsize * pp->p_frag,
			    0, 0);

			/* sanity checks */
			if (ui == UINT_MAX - 1) {
				fputs("Command aborted\n", stderr);
				pp->p_size = 0;		/* effective delete */
				return;
			} else if (ui == UINT_MAX)
				fputs("Invalid entry\n", stderr);
			else if (ui < getpagesize())
				fprintf(stderr,
				    "Error: block size must be at least as big "
				    "as page size (%d).\n", getpagesize());
			else if (ui % pp->p_fsize != 0)
				fputs("Error: block size must be a multiple of the fragment size.\n", stderr);
			else if (ui / pp->p_fsize < 1)
				fputs("Error: block size must be at least as big as fragment size.\n", stderr);
			else
				break;
a547 1
		pp->p_frag = ui / pp->p_fsize;
d551 1
a551 24
			for (;;) {
				ui = getuint(lp, partno, "cpg",
				    "Number of filesystem cylinders per group.  Usually 16 or 8.",
				    pp->p_cpg, pp->p_cpg, 0, 0);
				if (ui == UINT_MAX - 1) {
					fputs("Command aborted\n", stderr);
					pp->p_size = 0;	/* effective delete */
					return;
				} else if (ui == UINT_MAX)
					fputs("Invalid entry\n", stderr);
				else
					break;
			}
			pp->p_cpg = ui;
		}
		if (mp != NULL && pp->p_fstype != FS_UNUSED &&
		    pp->p_fstype != FS_SWAP && pp->p_fstype != FS_BOOT &&
		    pp->p_fstype != FS_OTHER) {
			/* get mount point */
			p = getstring(lp, "mount point",
			    "Where to mount this filesystem (ie: / /var /usr)",
			    "none");
			if (p == NULL) {
				fputs("Command aborted\n", stderr);
d555 6
a560 7
			if (strcasecmp(p, "none") != 0) {
				/* XXX - check that it starts with '/' */
				if (mp[partno] != NULL)
					free(mp[partno]);
				if ((mp[partno] = strdup(p)) == NULL)
					errx(4, "out of memory");
			}
d667 3
a669 34
	if (pp->p_fstype < FSMAXTYPES) {
		p = getstring(lp, "FS type",
		    "Filesystem type (usually 4.2BSD or swap)",
		    fstypenames[pp->p_fstype]);
		if (p == NULL) {
			fputs("Command aborted\n", stderr);
			pp->p_size = 0;		/* effective delete */
			return;
		}
		for (ui = 0; ui < FSMAXTYPES; ui++) {
			if (!strcasecmp(p, fstypenames[ui])) {
				pp->p_fstype = ui;
				break;
			}
		}
		if (ui >= FSMAXTYPES) {
			printf("Unrecognized filesystem type '%s', treating as 'unknown'\n", p);
			pp->p_fstype = FS_OTHER;
		}
	} else {
		for (;;) {
			ui = getuint(lp, partno, "FS type (decimal)",
			    "Filesystem type as a decimal number; usually 7 (4.2BSD) or 1 (swap).",
			    pp->p_fstype, pp->p_fstype, 0, 0);
			if (ui == UINT_MAX - 1) {
				fputs("Command aborted\n", stderr);
				pp->p_size = 0;		/* effective delete */
				return;
			} else if (ui == UINT_MAX)
				fputs("Invalid entry\n", stderr);
			else
				break;
		}
		pp->p_fstype = ui;
d691 3
a693 18
	for (;;) {
		ui = getuint(lp, partno, "offset",
		    "Starting sector for this partition.", pp->p_offset,
		    pp->p_offset, 0, DO_CONVERSIONS |
		    (pp->p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));
		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*pp = origpart;		/* undo changes */
			return;
		} else if (ui == UINT_MAX)
			fputs("Invalid entry\n", stderr);
		else if (partno != 2 && ui + ui < starting_sector) {
			fprintf(stderr, "The OpenBSD portion of the disk starts"
			    " at sector %u, you tried to start at %u."
			    "  You can use the 'b' command to change the size "
			    "of the OpenBSD portion.\n", starting_sector, ui);
		} else
			break;
a694 1
	pp->p_offset = ui;
d697 3
a699 38
	/* XXX - this loop sucks */
	for (;;) {
		ui = getuint(lp, partno, "size", "Size of the partition.",
		    pp->p_size, *freep, pp->p_offset, DO_CONVERSIONS |
		    ((pp->p_fstype == FS_BSDFFS || pp->p_fstype == FS_SWAP)
		    ? DO_ROUNDING : 0));

		if (ui == pp->p_size)
			break;			/* no change */

		if (ui == UINT_MAX - 1) {
			fputs("Command aborted\n", stderr);
			*pp = origpart;		/* undo changes */
			return;
		} else if (ui == UINT_MAX) {
			fputs("Invalid entry\n", stderr);
			continue;
		} else if (partno == 2 && ui + pp->p_offset > lp->d_secperunit) {
			fputs("'c' partition may not be larger than the disk\n",
			    stderr);
			continue;
		}

		if (pp->p_fstype == FS_UNUSED || pp->p_fstype == FS_BOOT) {
			pp->p_size = ui;	/* don't care what's free */
			break;
		} else {
			if (ui > pp->p_size + *freep)
				/* XXX - prompt user to steal space from another partition */
				fprintf(stderr,
				    "Size may not be larger than %u sectors\n",
				    pp->p_size + *freep);
			else {
				*freep += pp->p_size - ui;
				pp->p_size = ui;
				break;
			}
		}
a700 4
	/* XXX - if (ui % lp->d_secpercyl == 0) make ui + offset on cyl bound */
	pp->p_size = ui;
	if (pp->p_size == 0)
		return;
d712 3
a714 12
		for (;;) {
			ui = getuint(lp, partno, "fragment size",
			    "Size of fs block fragments.  Usually 1024 or 512.",
			    pp->p_fsize ? pp->p_fsize : 1024, 1024, 0, 0);
			if (ui == UINT_MAX - 1) {
				fputs("Command aborted\n", stderr);
				*pp = origpart;		/* undo changes */
				return;
			} else if (ui == UINT_MAX)
				fputs("Invalid entry\n", stderr);
			else
				break;
a715 3
		pp->p_fsize = ui;
		if (pp->p_fsize == 0)
			puts("Zero fragment size implies zero block size");
d718 3
a720 21
		for (; pp->p_fsize > 0;) {
			ui = getuint(lp, partno, "block size",
			    "Size of filesystem blocks.  Usually 8192 or 4096.",
			    pp->p_frag ? pp->p_fsize * pp->p_frag : 8192,
			    8192, 0, 0);

			/* sanity check */
			if (ui == UINT_MAX - 1) {
				fputs("Command aborted\n", stderr);
				*pp = origpart;		/* undo changes */
				return;
			} else if (ui == UINT_MAX)
				fputs("Invalid entry\n", stderr);
			else if (ui % pp->p_fsize != 0)
				puts("Error: block size must be a multiple of the fragment size.");
			else if (ui / pp->p_fsize < 1)
				puts("Error: block size must be at least as big as fragment size.");
			else {
				pp->p_frag = ui / pp->p_fsize;
				break;
			}
d725 3
a727 13
			for (;;) {
				ui = getuint(lp, partno, "cpg",
				    "Number of filesystem cylinders per group."
				    "  Usually 16 or 8.",
				    pp->p_cpg ? pp->p_cpg : 16, 16, 0, 0);
				if (ui == UINT_MAX - 1) {
					fputs("Command aborted\n", stderr);
					*pp = origpart;	/* undo changes */
					return;
				} else if (ui == UINT_MAX)
					fputs("Invalid entry\n", stderr);
				else
					break;
a728 1
			pp->p_cpg = ui;
d732 4
a735 21
	if (mp != NULL && pp->p_fstype != FS_UNUSED &&
	    pp->p_fstype != FS_SWAP && pp->p_fstype != FS_BOOT &&
	    pp->p_fstype != FS_OTHER) {
		/* get mount point */
		p = getstring(lp, "mount point",
		    "Where to mount this filesystem (ie: / /var /usr)",
		    mp[partno] ? mp[partno] : "none");
		if (p == NULL) {
			fputs("Command aborted\n", stderr);
			pp->p_size = 0;		/* effective delete */
			return;
		}
		if (mp[partno] != NULL) {
			free(mp[partno]);
			mp[partno] = NULL;
		}
		if (strcasecmp(p, "none") != 0) {
			/* XXX - check that it starts with '/' */
			if ((mp[partno] = strdup(p)) == NULL)
				errx(4, "out of memory");
		}
d1063 1
a1063 1
 * XXX - there are way too many parameters here.  There should be macros...
d1968 271
@


1.49
log
@Fix longstanding problem when rounding values to neared cylinder.
We used to just round the size to make size % secpercyl == 0.  Now
it makes (size + offset) % secpercyl == 0 so partitions end on a
cylinder bondary (which was the original intent).  The problem with
the old method is that if you have an fdisk table on the disk, 'a'
will start somewhere between 32 and 63, throwing off the calculations.
@
text
@d67 2
a68 2
int	editor __P((struct disklabel *, int, char *));
void	editor_add __P((struct disklabel *, u_int32_t *, char *));
d71 2
a72 2
void	editor_delete __P((struct disklabel *, u_int32_t *, char *));
void	editor_display __P((struct disklabel *, u_int32_t *, char));
d74 2
a75 1
void	editor_modify __P((struct disklabel *, u_int32_t *, char *));
d87 3
d97 1
a97 1
void	display_partition __P((FILE *, struct disklabel *, int, char, int));
d113 1
a113 1
editor(lp, f, dev)
d117 1
d124 9
d163 1
a163 1
	/* Set d_bbsize and d_sbsize as neccesary */
d200 5
a204 1
			editor_add(&label, &freesectors, arg);
d207 2
d230 5
a234 1
			editor_delete(&label, &freesectors, arg);
d237 2
d244 5
a248 1
			editor_modify(&label, &freesectors, arg);
d251 15
d269 2
a270 1
			editor_display(&label, &freesectors, arg ? *arg : 0);
d295 3
d299 1
a299 1
				puts("No changes.");
d303 1
a303 1
				arg = getstring(lp, "Save changes?",
d339 3
a341 1
			if (memcmp(&label, &lastlabel, sizeof(label)) == 0) {
d349 3
d357 1
a357 1
			if (donothing)
d359 8
a366 2
			else if (memcmp(lp, &label, sizeof(label)) == 0)
				puts("No changes.");
d399 1
a399 1
editor_add(lp, freep, p)
d401 1
d668 20
d697 60
d760 1
a760 1
editor_modify(lp, freep, p)
d762 1
d985 23
d1018 1
a1018 1
editor_delete(lp, freep, p)
d1020 1
d1076 4
d1086 1
a1086 1
editor_display(lp, freep, unit)
d1088 1
d1112 1
a1112 1
		display_partition(stdout, lp, i, unit, width);
d1333 1
a1333 1
 * XXX - there are way too many parameters here.  Use inline helper functions
d1504 2
a1505 2
				display_partition(stdout, lp, i, 0, 0);
				display_partition(stdout, lp, j, 0, 0);
d2084 7
d2134 1
d2150 89
@


1.48
log
@Allow user to delete partitions outside the openbsd part of the disk
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.47 1999/03/13 19:07:37 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.47 1999/03/13 19:07:37 millert Exp $";
d76 1
a76 1
u_int32_t getuint __P((struct disklabel *, int, char *, char *, u_int32_t, u_int32_t, int));
d432 1
a432 1
		   pp->p_offset, DO_CONVERSIONS |
d471 1
a471 1
		    pp->p_size, *freep, DO_CONVERSIONS |
d530 1
a530 1
			    pp->p_fstype, pp->p_fstype, 0);
d548 1
a548 1
			    pp->p_fsize, pp->p_fsize, 0);
d568 1
a568 1
			    0);
d595 1
a595 1
				    pp->p_cpg, pp->p_cpg, 0);
d674 1
a674 1
			    pp->p_fstype, pp->p_fstype, 0);
d709 1
a709 1
		    pp->p_offset, DO_CONVERSIONS |
d731 3
a733 1
		    pp->p_size, *freep, 1);
d785 1
a785 1
			    pp->p_fsize ? pp->p_fsize : 1024, 1024, 0);
d804 1
a804 1
			    8192, 0);
d829 1
a829 1
				    pp->p_cpg ? pp->p_cpg : 16, 16, 0);
d1020 1
d1040 1
d1043 1
a1043 1
	    partno + 'a', lp->d_partitions[partno].p_size, *freep);
d1047 2
a1048 3
	    lp->d_partitions[partno].p_size,
	    lp->d_partitions[partno].p_size + *freep, DO_CONVERSIONS |
	    (lp->d_partitions[partno].p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));
d1055 1
a1055 1
	} else if (newsize == lp->d_partitions[partno].p_size)
d1058 3
a1060 4
	if (lp->d_partitions[partno].p_fstype != FS_UNUSED &&
	    lp->d_partitions[partno].p_fstype != FS_BOOT) {
		if (newsize > lp->d_partitions[partno].p_size) {
			if (newsize - lp->d_partitions[partno].p_size > *freep) {
d1063 1
a1063 2
				    *freep,
				    newsize - lp->d_partitions[partno].p_size);
d1066 3
a1068 3
			*freep -= newsize - lp->d_partitions[partno].p_size;
		} else if (newsize < lp->d_partitions[partno].p_size) {
			*freep += lp->d_partitions[partno].p_size - newsize;
d1072 1
a1072 1
		    lp->d_partitions[partno].p_offset > lp->d_secperunit) {
d1078 2
a1079 2
	lp->d_partitions[partno].p_size = newsize;
	if (newsize + lp->d_partitions[partno].p_offset > ending_sector ||
d1165 1
a1165 1
getuint(lp, partno, prompt, helpstring, oval, maxval, flags)
d1172 1
d1181 3
d1274 9
a1282 7
			if (cyls * lp->d_secpercyl > maxval)
				cyls--;

			if (rval != cyls * lp->d_secpercyl) {
				rval = cyls * lp->d_secpercyl;
				printf("Rounding to nearest cylinder: %u\n",
				    rval);
d1425 1
a1425 1
		    lp->d_nsectors, 0);
d1441 1
a1441 1
		    lp->d_ntracks, 0);
d1457 2
a1458 1
		    "* tracks/cylinder).", lp->d_secpercyl, lp->d_secpercyl, 0);
d1474 1
a1474 1
		    lp->d_ncylinders, lp->d_ncylinders, 0);
d1492 1
a1492 1
		    lp->d_ncylinders * lp->d_ncylinders, 0);
d1530 1
a1530 1
		  lp->d_rpm, lp->d_rpm, 0);
d1546 1
a1546 1
		  lp->d_interleave, lp->d_interleave, 0);
d1699 1
a1699 1
		  starting_sector, lp->d_secperunit, 0);
d1712 1
a1712 1
		  lp->d_secperunit - start_temp, 0);
@


1.47
log
@Add support for delete "*"
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.46 1999/03/01 01:50:45 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.46 1999/03/01 01:50:45 millert Exp $";
a894 6
	else if (lp->d_partitions[c].p_offset >= ending_sector ||
	    lp->d_partitions[c].p_offset < starting_sector)
		fprintf(stderr, "The OpenBSD portion of the disk ends at sector"
		    " %u.\nYou can't remove a partition outside the OpenBSD "
		    "part of the disk.  You can use the 'b' command to change "
		    "the size of the OpenBSD portion.\n", ending_sector);
d897 3
a899 1
		if (lp->d_partitions[c].p_fstype != FS_UNUSED &&
@


1.46
log
@Change undocumented '-p' flag to '-d' and document.  Also document '-v'.
Make 'disklabel -ed' not overwrite your label if you make no changes
in the editor (added a cmplabel function to compare two labels).
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.45 1998/10/11 20:49:17 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.45 1998/10/11 20:49:17 millert Exp $";
d860 2
a861 1
		    "The letter of the partition to delete, a - p.", NULL);
d865 16
@


1.45
log
@When rounding to cylinder boundaries check to make sure we don't round up past the end of the disk.  Noticed by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.44 1998/08/07 00:06:00 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997-1998 Todd C. Miller <Todd.Miller@@courtesan.com>
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.44 1998/08/07 00:06:00 millert Exp $";
@


1.44
log
@Support PAGER environment vairable in conjuction with the 'M' command.
Ignore SIGPIPE when spawing the pager since disklabel could get killed.
Add smarts in disk type guesser to know that rz is SCSI.
Kill annoying extra blank line.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.43 1998/08/06 18:07:40 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.43 1998/08/06 18:07:40 millert Exp $";
d1246 1
a1246 10
		u_int32_t cyls;
		/* XXX - should use maxsize and round down if too big */
#ifdef CYLCHECK
		/* Always round to nearest cylinder, regardless of units */
		cyls = (u_int32_t)((rval / (double)lp->d_secpercyl) + 0.5);
		if (rval != cyls * lp->d_secpercyl) {
			rval = cyls * lp->d_secpercyl;
			printf("Rounding to nearest cylinder: %u\n", rval);
		}
#else
d1248 6
a1253 1
		if (mult != 1) {
d1256 3
a1264 1
#endif
@


1.43
log
@add more detailed help accessible via '? [abcdmpMqrsuwxe]'
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.42 1998/07/29 18:47:12 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.42 1998/07/29 18:47:12 millert Exp $";
d227 8
a234 5
		case 'M':
			fp = popen(_PATH_LESS, "w");
			if (fp) {
				extern char manpage[];

d237 4
a240 1
			}
d242 1
d1600 1
a1644 1
				putchar('\n');
a1649 1
					putchar('\n');
d1784 1
a1784 1
		printf("Treating sectors %u-%u as the OpenBSD portion of the "
d1834 3
a1836 2
"The 'less' pager.  It is especially useful during install when the normal\n"
"system manual is not available.\n");
@


1.42
log
@when changing a partition from unknown to 4.2BSD, provide sane defaults for fsize, bsize, cpg
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.41 1998/07/26 17:40:38 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Todd C. Miller <Todd.Miller@@courtesan.com>
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.41 1998/07/26 17:40:38 millert Exp $";
d69 2
a70 1
void	editor_modify __P((struct disklabel *, u_int32_t *, char *));
d73 2
a74 2
void	editor_change __P((struct disklabel *, u_int32_t *, char *));
void	editor_countfree __P((struct disklabel *, u_int32_t *));
d180 1
a180 17
			puts("Available commands:");
			puts("\tp [unit]   - print label.");
			puts("\tM          - show entire OpenBSD man page for disklabel.");
			puts("\te          - edit drive parameters.");
			puts("\ta [part]   - add new partition.");
			puts("\tb          - set OpenBSD disk boundaries.");
			puts("\tc [part]   - change partition size.");
			puts("\td [part]   - delete partition.");
			puts("\tm [part]   - modify existing partition.");
			puts("\tr          - recalculate free space.");
			puts("\tu          - undo last change.");
			puts("\ts [path]   - save label to file.");
			puts("\tw          - write label to disk.");
			puts("\tq          - quit and save changes.");
			puts("\tx          - exit without saving changes.");
			puts("\t?          - this message.");
			puts("Numeric parameters may use suffixes to indicate units:\n\t'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm' for megabytes,\n\t'g' for gigabytes or no suffix for sectors (usually 512 bytes).\n\tNon-sector units will be rounded to the nearest cylinder.");
d867 4
a870 1
		fputs("You may not delete the 'c' partition.\n", stderr);
d1794 2
a1795 2
    struct disklabel *lp;
    u_int32_t *freep;
d1797 13
a1809 2
    struct partition *pp;
    int i;
d1811 134
a1944 9
    *freep = ending_sector - starting_sector;
    for (i = 0; i < lp->d_npartitions; i++) {
	pp = &lp->d_partitions[i];
	if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
	    pp->p_size > 0 && 
	    pp->p_offset + pp->p_size <= ending_sector &&
	    pp->p_offset >= starting_sector)
	    *freep -= pp->p_size;
    }
@


1.41
log
@Don't skip 'b' when suggesting the next partition to add.  I thought it would be confusing to suggest 'b' but what happens is that people build a disk without swap.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.40 1998/07/26 17:36:09 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.40 1998/07/26 17:36:09 millert Exp $";
d791 1
a791 1
			    pp->p_fsize, 1024, 0);
d809 2
a810 2
			    pp->p_fsize * pp->p_frag, pp->p_fsize * pp->p_frag,
			    0);
d834 2
a835 2
				    "  Usually 16 or 8.", pp->p_cpg, pp->p_cpg,
				    0);
@


1.40
log
@When asking the user for the disk type, base the default on the device name.  Ie: wd -> IDE, sd -> SCSI, hd -> HP-IB, etc.  Should help eliminate some confusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.39 1998/07/26 17:01:45 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.39 1998/07/26 17:01:45 millert Exp $";
d381 1
a381 1
		/* Find first unused partition that is not 'b' or 'c' */
d383 1
a383 2
			if (lp->d_partitions[partno].p_size == 0 &&
			    partno != 1 && partno != 2)
@


1.39
log
@Don't allow user to do 'a c' since c always exists.  They can still do 'c c'.  Noted by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.38 1998/07/23 05:21:23 csapuntz Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.38 1998/07/23 05:21:23 csapuntz Exp $";
d45 1
d67 1
a67 1
int	editor __P((struct disklabel *, int));
d81 1
a81 1
void	getdisktype __P((struct disklabel *, char *));
d108 1
a108 1
editor(lp, f)
d111 1
d120 1
a120 1
	getdisktype(&label, "You need to specify a disk type for this disk.");
d1594 1
a1594 1
getdisktype(lp, banner)
d1597 1
d1600 30
a1629 1
	char *s;
d1644 2
a1645 3
			    "What kind of disk is this?  Usually SCSI, ESDI, "
			    "ST506, or floppy (use ESDI for IDE).",
			    "SCSI");
@


1.38
log
@

Fix annoying bug where disklabel would give you wrong default size for last
partition on disk and then complain when you chose it.

The fix makes sure you get the "correct size".
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.37 1998/06/21 22:13:52 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.37 1998/06/21 22:13:52 millert Exp $";
d366 1
a366 1
		if (partno < 0 || partno >= MAXPARTITIONS) {
d368 2
a369 2
			    "Partition must be between 'a' and '%c'.\n",
			    'a' + MAXPARTITIONS - 1);
@


1.37
log
@Remove the advertising clause in my old license, it impedes free use
of the code as a large number of similar clauses makes it impossible
to write an ad for a product using the code...
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.36 1998/05/07 06:27:34 millert Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.36 1998/05/07 06:27:34 millert Exp $";
d1722 2
a1723 2
			if (spp[i]->p_offset + spp[i]->p_size < lp->d_secperunit) {

d1726 1
a1726 1
				chunks[numchunks].stop = lp->d_secperunit;
@


1.36
log
@get rid of #ifdef OLD_SCSI stuff.  It is not useful
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.35 1998/05/07 06:22:20 millert Exp $	*/
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Todd C. Miller.
 * 4. The name of the author may not be used to endorse or promote products
d31 1
a31 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.35 1998/05/07 06:22:20 millert Exp $";
@


1.35
log
@let user set d_interleave, and force it to be >= 1
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.34 1998/04/14 20:02:48 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.34 1998/04/14 20:02:48 millert Exp $";
a148 6
#if defined(OLD_SCSI)
	/* Some ports use the old scsi system that doesn't get the geom right */
	if (strcmp(label.d_packname, "fictitious") == 0)
		puts("Warning, driver-generated label.  Disk parameters may be "
		    "incorrect.");
#endif
@


1.34
log
@Set label.d_bbsize and label.d_sbsize if we have a fictious label
and they are zero.  Fixes "disklabel -B" on hp300 and the warning
about zero size bootblock and superblock fields on all ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.33 1998/04/11 10:14:19 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.33 1998/04/11 10:14:19 deraadt Exp $";
d163 4
d1535 16
@


1.33
log
@mention IDE, or people will get all confused
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.32 1998/04/08 02:42:37 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.32 1998/04/08 02:42:37 millert Exp $";
d151 1
a151 1
	if (strcmp(label.d_typename, "fictitious") == 0)
d155 7
@


1.32
log
@Make undo recalculate free space.  Also adds 'r' command to recalculate
free space manually.  From Magnus Holmberg <mho@@stacken.kth.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.31 1998/02/28 02:52:08 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.31 1998/02/28 02:52:08 millert Exp $";
d1584 1
@


1.31
log
@Be consistent wrt suggesting ESDI for IDE and using ESDI even if
they enter IDE.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.30 1998/02/19 20:43:37 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.30 1998/02/19 20:43:37 deraadt Exp $";
d75 1
a118 1
	int i;
d127 1
a127 9
	freesectors = ending_sector - starting_sector;
	for (i = 0; i < label.d_npartitions; i++) {
		pp = &label.d_partitions[i];
		if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
		    pp->p_size > 0 && 
		    pp->p_offset + pp->p_size <= ending_sector &&
		    pp->p_offset >= starting_sector)
			freesectors -= pp->p_size;
	}
d184 1
d271 6
d300 2
a1631 2
	int i;
	struct partition *pp;
d1660 1
a1660 9
	*freep = ending_sector - starting_sector;
	for (i = 0; i < lp->d_npartitions; i++) {
		pp = &lp->d_partitions[i];
		if (pp->p_fstype != FS_UNUSED && pp->p_fstype != FS_BOOT &&
		    pp->p_size > 0 && 
		    pp->p_offset + pp->p_size <= ending_sector &&
		    pp->p_offset >= starting_sector)
			*freep -= pp->p_size;
	}
d1750 22
@


1.30
log
@deal with partition type renamed
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.29 1998/01/11 18:21:17 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.29 1998/01/11 18:21:17 millert Exp $";
d1592 2
a1593 1
			    "What kind of disk is this?  Usually SCSI, ST506, or floppy (use ST506 for IDE).",
d1597 5
@


1.29
log
@Tell the user to enter ESDI for IDE, not ST506.  Also treat IDE as ESDI
if the user enters that anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.28 1998/01/05 06:45:50 art Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.28 1998/01/05 06:45:50 art Exp $";
d1737 5
a1741 3
	/* If we have an MBR, use values from the OpenBSD/386BSD parition. */
	if (dosdp && pp->p_size && (dosdp->dp_typ == DOSPTYP_OPENBSD ||
	    dosdp->dp_typ == DOSPTYP_386BSD)) {
@


1.28
log
@recalculate the free sectors after changing boundaries.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.27 1998/01/05 06:20:48 art Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.27 1998/01/05 06:20:48 art Exp $";
d1365 2
a1366 2
		    "What kind of disk is this?  Usually SCSI, ST506, or "
		    "floppy (use ST506 for IDE).", dktypenames[lp->d_type]);
d1371 6
a1376 3
		for (ui = 1; ui < DKMAXTYPES && strcasecmp(p, dktypenames[ui]);
		    ui++)
			;
@


1.27
log
@check if the partitions are below the boundaries and not only above when
counting the free sectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.26 1997/11/05 02:48:43 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.26 1997/11/05 02:48:43 millert Exp $";
d84 1
a84 1
void	set_bounds __P((struct disklabel *));
d212 1
a212 1
			set_bounds(&label);
d1617 1
a1617 1
set_bounds(lp)
d1619 1
d1622 2
d1650 11
@


1.26
log
@Document ^D to get out of overlap prompt and remove duplicate exit condition
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.25 1997/11/04 19:46:39 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.25 1997/11/04 19:46:39 millert Exp $";
d131 3
a133 1
		    pp->p_size > 0 && pp->p_offset + pp->p_size <= ending_sector)
@


1.25
log
@Deal correctly with partitions that have multiple overlaps.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.24 1997/10/24 02:49:55 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.24 1997/10/24 02:49:55 millert Exp $";
d1325 1
a1325 1
					printf("Disable which one? [%c %c] ",
d1328 2
a1329 1
					if (!fgets(buf, sizeof(buf), stdin))
d1331 1
a1332 3
					if ((buf[1] == '\n' || buf[1] == '\0')
					    && (c == i || c == j))
						break;
@


1.24
log
@Typo
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.23 1997/10/24 02:44:07 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.23 1997/10/24 02:44:07 millert Exp $";
d1284 2
a1285 1
	int c, i, j, rval = 0;
d1323 10
a1332 6
				printf("Disable which one? [%c %c] ",
				    'a' + i, 'a' + j);
				/* XXX - make less gross */
				while ((c = getchar()) != EOF && c != '\n') {
					c -= 'a';
					if (c == i || c == j)
d1334 9
a1342 9
				}
				putchar('\n');
				/* Mark the selected one as unused or... */
				if (c == i || c == j) {
					lp->d_partitions[c].p_fstype = FS_UNUSED;
					*freep += lp->d_partitions[c].p_size;
				} else
					rval = 1;	/* still has overlap */
			    }
d1347 1
a1347 1
	return(rval);
@


1.23
log
@Warn that geom may be wrong for ports with old scsi.
For ports where boot blocks sit in the first cylinder, don't suggest an
    offset that would clobber them.
Mention the 'b' command when the user tries to go past end of the OpenBSD part.
In 'b' command, don't suggest size that extends beyond the disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.22 1997/10/24 00:08:24 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.22 1997/10/24 00:08:24 millert Exp $";
d422 2
a423 2
		pp->p_offset = pp->d_secpercyl;
		pp->p_size -= pp->d_secpercyl;
@


1.22
log
@Make and use _PATH_LESS.
Use the MBR for begin/end of the OpenBSD portion of the disk.
Don't suggest an offset that would cause a partition to go past the end.
Remove old bounds inference code.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.21 1997/10/20 07:09:43 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.21 1997/10/20 07:09:43 deraadt Exp $";
d58 4
d155 7
d419 7
d444 3
a446 2
			    " at sector %u, you tried to add a partition at %u\n"
			    , starting_sector, ui);
d449 3
a451 2
			    "at sector %u, you tried to add a partition at %u\n",
			    ending_sector, ui);
d489 2
a490 1
			    "at sector %u\n",
d721 3
a723 2
			    " at sector %u, you tried to start at %u\n",
			    starting_sector, ui);
d767 2
d881 2
a882 1
		    "part of the disk.\n", ending_sector);
a988 6
#if 0
	/* If we ran out of space, use an offset of zero */
	if (new_offset >= ending_sector)
		new_offset = 0;
#endif

d1476 2
a1477 1
			puts("You may want to increase the 'c' partition.");
d1630 4
a1633 3
		ui = getuint(lp, 0, "Size",
		  "The size of the OpenBSD portion of the disk.",
		  ending_sector - starting_sector, lp->d_secperunit, 0);
d1638 1
a1638 1
	} while (ui > lp->d_secperunit);
d1706 1
d1715 2
a1716 2
	if (dosdp && lp->d_partitions[2].p_size &&
	    (dosdp->dp_typ == DOSPTYP_OPENBSD || dosdp->dp_typ == DOSPTYP_386BSD)) {
d1722 4
@


1.21
log
@format the "print" units better, in all cases
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.20 1997/10/20 06:26:53 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.20 1997/10/20 06:26:53 millert Exp $";
d52 2
d97 3
d233 1
a233 1
			fp = popen("/usr/bin/less", "w");
a407 7
#ifdef DOSLABEL
	/* Don't clobber the MBR */
	if (pp->p_offset == 0) {
		pp->p_offset = 32;
		pp->p_size -= 32;
	}
#endif
a473 6
#ifdef DOSLABEL
	if (pp->p_offset == 32 && ui % lp->d_secpercyl == 0) {
		ui -= 32;
		puts("Adjusting size by 32 to maintain cylinder boundaries");
	}
#endif
d480 2
a481 1
		puts("\nPlease re-enter an offset and size");
d932 2
a933 1
		if ((new_offset >= spp[i]->p_offset &&
d936 1
a936 1
		    + pp->p_size <= spp[i]->p_offset + spp[i]->p_size))
d960 1
a960 1
		/* XXX - if new_size is 0 here then there was no space at all */
d964 6
d1588 1
d1608 1
a1608 1
	/* Ending sector */
d1610 3
a1612 3
		ui = getuint(lp, 0, "Ending sector",
		  "The end of the OpenBSD portion of the disk.",
		  ending_sector, lp->d_secperunit, 0);
d1618 1
a1618 1
	ending_sector = ui;
a1622 136
 * Find the possible/likely start/stop of the OpenBSD portion of the disk.
 * Sets starting_sector and ending_sector globals.
 * XXX - assumes first OpenBSD partition is 4.2/swap or unused space.
 */
void
find_bounds(lp)
	struct disklabel *lp;
{
	u_int16_t npartitions;
	struct partition **spp;
	struct diskchunk chunks[2 * MAXPARTITIONS + 1];
	int i, j, numchunks, ourchunk = -1;

	/* Sort the partitions based on offset */
	spp = sort_partitions(lp, &npartitions);

	/* If there are no partitions, we get it all. */
	if (spp == NULL) {
		starting_sector = 0;
		ending_sector = lp->d_secperunit;
		puts("OpenBSD will use the entire disk.");
		return;
	}

	/* Find chunks of free space */
	numchunks = 0;
	if (spp && spp[0]->p_offset > 0) {
		chunks[0].start = 0;
		chunks[0].stop = spp[0]->p_offset;
		numchunks++;
	}
	for (i = 0; i < npartitions; i++) {
		if (i + 1 < npartitions) {
			if (spp[i]->p_offset + spp[i]->p_size < spp[i+1]->p_offset) {
				chunks[numchunks].start =
				    spp[i]->p_offset + spp[i]->p_size;
				chunks[numchunks].stop = spp[i+1]->p_offset;
				numchunks++;
			}
		} else {
			/* Last partition */
			if (spp[i]->p_offset + spp[i]->p_size < lp->d_secperunit) {

				chunks[numchunks].start =
				    spp[i]->p_offset + spp[i]->p_size;
				chunks[numchunks].stop = lp->d_secperunit;
				numchunks++;
			}
		}
	}

	/* Now find the OpenBSD partitions and add them in to "chunks" */
	for (i = 0; i < npartitions; i++) {
		if (spp[i]->p_fstype == FS_BSDFFS || spp[i]->p_fstype == FS_SWAP) {
			/* Look for a consecutive chunk to add to */
			for (j = 0; j < numchunks; j++) {
				if (chunks[j].stop == spp[i]->p_offset) {
					chunks[j].stop += spp[i]->p_size;
					if (ourchunk == -1)
						ourchunk = j + 1;
					break;
				} else if (chunks[j].start ==
				    spp[i]->p_offset + spp[i]->p_size) {
					chunks[j].start -= spp[i]->p_size;
					if (ourchunk == -1)
						ourchunk = j + 1;
					break;
				}
			}

			/* Else add a new one */
			if (j >= numchunks) {
				chunks[numchunks].start = spp[i]->p_offset;
				chunks[numchunks].stop =
				    spp[i]->p_offset + spp[i]->p_size;
				numchunks++;
				if (ourchunk == -1)
					ourchunk = numchunks;
			}
		}
	}

	/* If we ended up with consecutive chunks, collapse them. */
	check_chunks:
	for (i = 0; i < numchunks; i++) {
		for (j = 0; j < numchunks; j++) {
			if (j == i)
				continue;
			if (chunks[i].stop == chunks[j].start) {
				/* Collapse i and j */
				chunks[i].stop +=
				    chunks[j].stop - chunks[j].start;
				for (i = j; i < numchunks - 1; i++)
					chunks[i] = chunks[i+1];
				numchunks--;
				goto check_chunks;
			}
		}
	}

	/*
	 * Prompt user to choose which one for OpenBSD (if more than one)
	 * Note: we assume that the first chunk with BSD partitions is ours.
	 */
	if (numchunks > 1) {
		printf("#        size   offset    fstype   [fsize bsize   cpg]\n");
		for (i = 0; i < lp->d_npartitions; i++)
			display_partition(stdout, lp, i, 0, 0);
		puts("Several chunks of unused or BSD space exist, which one is for OpenBSD?");
		if (ourchunk != -1)
			printf("It looks like the OpenBSD portion is chunk "
			    "number %d\n", ourchunk);
		else
			ourchunk = 1;

		for (i = 0; i < numchunks; i++) {
			printf("%6d: start = %d, stop = %d\n", i + 1,
			    chunks[i].start, chunks[i].stop);
		}
		do {
			ourchunk = getuint(lp, 0, "Choose one",
			  "The portion of the disk you will use for OpenBSD.",
			  ourchunk, numchunks, 0);
		} while (ourchunk < 1 || ourchunk > numchunks);
	}
	ourchunk--;

	starting_sector = chunks[ourchunk].start;
	ending_sector = chunks[ourchunk].stop;
	printf("Treating sectors %u-%u as the OpenBSD portion of the disk.\n",
	    starting_sector, ending_sector);

	(void)free(spp);
}

/*
d1676 26
@


1.20
log
@Suport the idea of an OpenBSD portion of the disk.
Allow user to abort commands via ^D at a prompt.
Normalize usage of sectors vs. blocks
Allow real numbers when specifying in b/k/m/g
Be smarter when suggesting offsets and sizes
Always add a 'c' partition
BUGS: not all functions make sure they are operating within the OpenBSD part
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.19 1997/10/18 12:07:57 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.19 1997/10/18 12:07:57 deraadt Exp $";
d87 3
a89 1
void	display_partition __P((FILE *, struct disklabel *, int, char));
d888 1
d903 3
a905 1
	printf("#        size   offset    fstype   [fsize bsize   cpg]\n");
d907 1
a907 1
		display_partition(stdout, lp, i, unit);
d1294 2
a1295 2
				display_partition(stdout, lp, i, 0);
				display_partition(stdout, lp, j, 0);
d1729 1
a1729 1
			display_partition(stdout, lp, i, 0);
@


1.19
log
@do not allow add of existing partition
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.18 1997/10/17 20:03:46 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.18 1997/10/17 20:03:46 millert Exp $";
d56 6
d73 1
a73 1
u_int32_t next_offset __P((struct disklabel *));
d77 6
d103 2
a104 1
	u_int32_t freeblocks;
d109 5
a113 7
	/* Set freeblocks based on initial label */
	freeblocks = label.d_secperunit;
	for (i = 0; i < label.d_npartitions; i++)
		if (label.d_partitions[i].p_fstype != FS_UNUSED &&
		    label.d_partitions[i].p_fstype != FS_BOOT &&
		    label.d_partitions[i].p_size > 0)
			freeblocks -= label.d_partitions[i].p_size;
d115 11
a125 2
	puts("Initial label editor (enter '?' for help at any prompt)");
	if (has_overlap(&label, &freeblocks, 1))
d128 11
a138 1
	getdisktype(&label, "You need to specify a disk type for this disk.");
d144 1
d168 1
d178 1
a178 1
			puts("Numeric parameters may use suffixes to indicate units:\n\t'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm' for megabytes,\n\t'g' for gigabytes or no suffix for blocks (usually 512 bytes).\n\tNon-block units will be rounded to the nearest cylinder.");
d184 9
a192 1
			editor_add(&label, &freeblocks, arg);
d200 1
a200 1
			editor_change(&label, &freeblocks, arg);
d208 1
a208 1
			editor_delete(&label, &freeblocks, arg);
d216 1
a216 1
			editor_modify(&label, &freeblocks, arg);
d222 1
a222 1
			editor_display(&label, &freeblocks, arg ? *arg : 0);
d248 2
a249 2
			} while (tolower(*arg) != 'y' && tolower(*arg) != 'n');
			if (tolower(*arg) == 'y') {
d263 1
a263 1
				if (*arg == '\0')
d306 1
a306 1
			edit_parms(&label, &freeblocks);
d327 2
a328 1
	struct partition origpart, *pp;
d331 1
a331 1
	u_int32_t ui;
d348 1
a348 1
		} else if (lp->d_partitions[partno].p_fstype != FS_UNUSED ||
d371 2
d374 5
a378 1
			if (partno >= 0 && partno < MAXPARTITIONS)
d385 6
a390 1
	/* Increase d_npartitions and set defaults if necesary */
d392 14
a405 42
	if (partno >= lp->d_npartitions || pp->p_fstype == FS_UNUSED) {
		if (partno >= lp->d_npartitions)
			lp->d_npartitions = partno + 1;
		memset(pp, 0, sizeof(*pp));
		pp->p_offset = next_offset(lp);
		pp->p_size = *freep;
		if (partno == 1)
			pp->p_fstype = FS_SWAP;
		else
			pp->p_fstype = FS_BSDFFS;
		pp->p_fsize = 1024;
		pp->p_frag = 8;
		pp->p_cpg = 16;
	}
	origpart = *pp;

	/* Get fstype */
	if (pp->p_fstype < FSMAXTYPES) {
		p = getstring(lp, "FS type",
		    "Filesystem type (usually 4.2BSD or swap)",
		    fstypenames[pp->p_fstype]);
		for (i = 0; i < FSMAXTYPES; i++) {
			if (!strcasecmp(p, fstypenames[i])) {
				pp->p_fstype = i;
				break;
			}
		}
		if (i >= FSMAXTYPES) {
			printf("Unrecognized filesystem type '%s', treating as 'unknown'\n", p);
			pp->p_fstype = FS_OTHER;
		}
	} else {
		for (;;) {
			ui = getuint(lp, partno, "FS type (decimal)",
			    "Filesystem type as a decimal number; usually 7 (4.2BSD) or 1 (swap).",
			    pp->p_fstype, pp->p_fstype, 0);
			if (ui == UINT_MAX)
				fputs("Invalid entry\n", stderr);
			else
				break;
		}
		pp->p_fstype = ui;
d407 3
d418 5
a422 1
		if (ui == UINT_MAX)
d424 8
d437 13
d454 8
a461 4
		    (pp->p_fstype == FS_BSDFFS ? DO_ROUNDING : 0));
		if (ui + pp->p_offset > lp->d_partitions[2].p_size +
		    lp->d_partitions[2].p_offset)
			fputs("Partition must not extend past 'c'\n", stderr);
d464 1
a464 1
			fprintf(stderr,"Sorry, there are only %u blocks left\n",
d466 5
d474 6
d484 1
a484 1
	/* Check for overlap and restore if not resolved */
d487 2
a488 2
		pp->p_offset = origpart.p_offset;
		pp->p_size = origpart.p_size;
d492 37
d535 5
a539 1
			if (ui == UINT_MAX)
d557 5
a561 1
			if (ui == UINT_MAX)
d582 5
a586 1
				if (ui == UINT_MAX)
d594 1
a594 1
	/* Update free block count and make sure things stay contiguous. */
d596 3
a598 1
	make_contiguous(lp);
d619 4
d641 5
d661 5
a665 1
			if (ui == UINT_MAX)
d681 1
a681 1
			    "Warning, need %u blocks but there are only %u "
d697 5
a701 1
		if (ui == UINT_MAX)
d703 5
a707 1
		else
d721 5
a725 1
		if (ui == UINT_MAX) {
a727 4
		} else if (partno != 2 && ui + pp->p_offset >
		    lp->d_partitions[2].p_size + lp->d_partitions[2].p_offset) {
			fputs("Partition must not extend past 'c'\n", stderr);
			continue;
d741 1
a741 1
				    "Size may not be larger than %u blocks\n",
d767 5
a771 1
			if (ui == UINT_MAX)
d788 5
a792 1
			if (ui == UINT_MAX)
d811 5
a815 1
				if (ui == UINT_MAX)
d825 3
a827 1
	make_contiguous(lp);
d845 4
d858 5
d864 1
a864 1
		/* Update free block count. */
a872 3

		/* Fill in the gap we just made */
		make_contiguous(lp);
d907 1
a907 1
 * Assumes there is a least one free block left (returns 0 if not).
d910 1
a910 1
next_offset(lp)
d912 1
d915 1
d917 2
a918 2
	u_int32_t new_offset = 0;
	int i;
d921 8
a928 1
	spp = sort_partitions(lp, &npartitions);
a929 1
	for (i = 0; i < npartitions; i++ ) {
d932 1
a932 1
		 * make it the next block after the partition ends.
d934 4
a937 2
		if (new_offset >= spp[i]->p_offset &&
		    new_offset < spp[i]->p_offset + spp[i]->p_size)
d941 24
d985 4
d1008 4
a1011 1
	if (newsize == UINT_MAX) {
d1032 1
a1032 5
		if (partno != 2 && newsize + lp->d_partitions[partno].p_offset >
		    lp->d_partitions[2].p_size) {
			fputs("Partition must not extend past 'c'\n", stderr);
			return;
		} else if (partno == 2 && newsize +
d1040 3
a1042 1
	make_contiguous(lp);
d1054 2
a1055 1
	spp = sort_partitions(lp, &npartitions);
d1059 1
d1061 6
a1066 2
	for (i = 1; i < npartitions; i++)
		spp[i]->p_offset = spp[i - 1]->p_offset + spp[i - 1]->p_size;
a1100 1
			putchar('\n');
d1102 4
d1139 1
a1139 1
	u_long ul;
a1146 1
			putchar('\n');
d1148 4
d1166 1
a1166 1
				switch (buf[n-1]) {
d1189 1
a1189 2
			} else
				mult = 1;
d1197 5
a1201 11
			if (mult > 0)
				ul = strtoul(p, &endptr, 10) * mult;
			else
				/* Negative mult means divide (ooh, fancy) */
				ul = strtoul(p, &endptr, 10) / (-mult);

			/* Sanity check the return val */
			if (ul == ULONG_MAX || ul >= UINT_MAX) {
				errno = ERANGE;		/* too big */
				rval = UINT_MAX;
			} else if (*endptr != '\0') {
d1205 6
a1210 1
				rval = ul;
d1212 1
a1212 1
				/* Apply the operator (XXX - check for oflow) */
d1231 2
a1232 2
		/* Round to nearest cylinder unless given in blocks */
		if (mult > 1) {
d1275 6
d1293 1
a1293 1
				if (!resolve) {
d1328 1
d1337 4
d1363 5
d1376 5
a1380 1
		if (ui == UINT_MAX)
d1392 5
a1396 1
		if (ui == UINT_MAX)
d1408 5
a1412 1
		if (ui == UINT_MAX)
d1424 5
a1428 1
		if (ui == UINT_MAX)
d1442 5
a1446 1
		if (ui == UINT_MAX)
d1448 2
a1449 1
		else if (ui > lp->d_secperunit) {
d1454 2
a1455 1
		} else if (ui < lp->d_secperunit) {
d1469 3
d1479 5
a1483 1
		if (ui == UINT_MAX)
d1507 4
d1560 2
d1578 228
@


1.18
log
@Allow user to adjust sec/cyl instead of hard coding to sec/track * tracks/cyl.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.17 1997/10/17 19:50:43 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.17 1997/10/17 19:50:43 millert Exp $";
d306 6
@


1.17
log
@Fix pasto.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.16 1997/10/17 04:37:52 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.16 1997/10/17 04:37:52 deraadt Exp $";
d1166 10
a1175 1
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
@


1.16
log
@remove some blank lines
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.15 1997/10/16 10:40:50 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.15 1997/10/16 10:40:50 deraadt Exp $";
d1166 1
a1166 1
	lp->d_ncylinders = lp->d_ntracks * lp->d_nsectors;
@


1.15
log
@make M more visible
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.14 1997/10/16 10:40:10 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.14 1997/10/16 10:40:10 deraadt Exp $";
d104 1
a104 1
	puts("Initial label editor (enter '?' for help at any prompt)\n");
d131 3
a133 2
			puts("Available commands:\n");
			puts("\tp [suffix] - print label.");
d145 2
a146 2
			puts("\t?          - this message.\n");
			puts("Numeric parameters may use suffixes to indicate units:\n\t'b' for bytes, 'c' for cylinders, 'k' for kilobytes, 'm' for megabytes,\n\t'g' for gigabytes or no suffix for blocks (usually 512 bytes).\n\tNon-block units will be rounded to the nearest cylinder.\nThe (optional) argument to p[rint] may be one of the aforementioned units.\n");
d1109 1
a1109 1
	printf("Changing device parameters for %s\n\n", specname);
@


1.14
log
@new command: M (shows linked-in manpage)
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.13 1997/10/16 02:41:34 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.13 1997/10/16 02:41:34 deraadt Exp $";
d133 1
a143 1
			puts("\tM          - show entire OpenBSD man page for disklabel.");
@


1.13
log
@p takes a suffix, not a unit
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.12 1997/10/15 22:49:04 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.12 1997/10/15 22:49:04 millert Exp $";
d143 1
d182 10
@


1.12
log
@Require a disk type other than "unknon", print disk type when displaying
info, and allow user to change disk type via 'e'.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.11 1997/10/15 19:39:48 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.11 1997/10/15 19:39:48 millert Exp $";
d132 12
a143 12
			puts("\tp [unit]  - print label.");
			puts("\te         - edit drive parameters.");
			puts("\ta [part]  - add new partition.");
			puts("\tc [part]  - change partition size.");
			puts("\td [part]  - delete partition.");
			puts("\tm [part]  - modify existing partition.");
			puts("\tu         - undo last change.");
			puts("\ts [path]  - save label to file.");
			puts("\tw         - write label to disk.");
			puts("\tq         - quit and save changes.");
			puts("\tx         - exit without saving changes.");
			puts("\t?         - this message.\n");
@


1.11
log
@Move sorting stuff into new function: sort_partitions()
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.10 1997/10/07 04:26:08 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.10 1997/10/07 04:26:08 millert Exp $";
d70 1
d108 2
d711 1
d1099 23
d1249 43
@


1.10
log
@Support 'g' (gigabyte) suffix.  Requested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.9 1997/10/06 03:49:08 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.9 1997/10/06 03:49:08 millert Exp $";
d69 1
d737 2
a738 27
	/* How many "real" partitions do we have? */
	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    lp->d_partitions[i].p_size != 0)
			npartitions++;
	}

	/* Create an array of pointers to the partition data */
	if ((spp = malloc(sizeof(struct partition *) * npartitions)) == NULL)
		errx(4, "out of memory");
	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    lp->d_partitions[i].p_size != 0)
			spp[npartitions++] = &lp->d_partitions[i];
	}

	/*
	 * Sort the partitions based on starting offset.
	 * This is safe because we guarantee no overlap.
	 */
	if (npartitions > 1)
		if (heapsort((void *)spp, npartitions, sizeof(spp[0]),
		    partition_cmp))
			err(4, "failed to sort partition table");

d833 2
a834 20
	/* How many "real" partitions do we have? */
	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    lp->d_partitions[i].p_size != 0)
			npartitions++;
	}

	if (npartitions < 2)
		return;			/* nothing to do */

	/* Create an array of pointers to the partition data */
	if ((spp = malloc(sizeof(struct partition *) * npartitions)) == NULL)
		errx(4, "out of memory");
	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    lp->d_partitions[i].p_size != 0)
			spp[npartitions++] = &lp->d_partitions[i];
	}
d837 1
a837 2
	 * Sort the partitions based on starting offset.
	 * This is safe because we guarantee no overlap.
a838 4
	if (heapsort((void *)spp, npartitions, sizeof(spp[0]), partition_cmp))
		err(4, "failed to sort partition table");

	/* Now make everything contiguous but don't muck with start of 'a' */
d1032 2
a1033 7
	/* How many "real" partitions do we have? (skip 'c') */
	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (i != 2 && lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    lp->d_partitions[i].p_size != 0)
			npartitions++;
	}
d1035 2
a1036 1
	if (npartitions < 2)
a1037 10

	/* Create an array of pointers to the partition data */
	if ((spp = malloc(sizeof(struct partition *) * npartitions)) == NULL)
		errx(4, "out of memory");

	for (npartitions = 0, i = 0; i < lp->d_npartitions; i++) {
		if (i != 2 && lp->d_partitions[i].p_fstype != FS_UNUSED &&
		    lp->d_partitions[i].p_fstype != FS_BOOT &&
		    lp->d_partitions[i].p_size != 0)
			spp[npartitions++] = &lp->d_partitions[i];
a1039 6
	/*
	 * Sort the partitions based on starting offset.
	 */
	if (heapsort((void *)spp, npartitions, sizeof(spp[0]), partition_cmp))
		err(4, "failed to sort partition table");

d1174 1
a1174 1
		  "The rotational speed of the disk in revoltuions per minute.",
d1182 40
@


1.9
log
@Ignore 'c' when computing overlap; some ports use "unknown" instead of
"unused" as the fstype.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.8 1997/10/03 23:01:52 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.8 1997/10/03 23:01:52 millert Exp $";
d140 1
a140 1
			puts("Numeric parameters may use suffixes to indicate units:\n\t'b' for bytes, 'c' for cylinders, 'k' for kilobytes,\n\t'm' for megabytes or no suffix for blocks (usually 512 bytes).\n\tNon-block units will be rounded to the nearest cylinder.\nThe (optional) argument to p[rint] may be one of the aforementioned units.\n");
d997 4
@


1.8
log
@Update the "real" copy of the label when you do a "write".  Noted by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.7 1997/10/02 16:38:20 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.7 1997/10/02 16:38:20 millert Exp $";
d1075 1
a1075 1
	/* How many "real" partitions do we have? */
d1077 1
a1077 1
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
d1091 1
a1091 1
		if (lp->d_partitions[i].p_fstype != FS_UNUSED &&
@


1.7
log
@Treat FS_BOOT similar to FS_UNUSED.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.6 1997/10/02 06:56:19 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.6 1997/10/02 06:56:19 millert Exp $";
d236 2
@


1.6
log
@ o When adding 'b' make default fstype be swap.
 o Add some missing free()'s.
 o When computing new offset, sort the partitions by offset, don't assume
   that ascending partions are in real order.  Noted by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.5 1997/10/02 05:58:51 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.5 1997/10/02 05:58:51 millert Exp $";
d98 1
d519 2
a520 1
	if (pp->p_fstype == FS_UNUSED && origpart.p_fstype != FS_UNUSED)
d522 2
a523 1
	else if (pp->p_fstype != FS_UNUSED && origpart.p_fstype == FS_UNUSED) {
d571 1
a571 1
		if (pp->p_fstype == FS_UNUSED) {
d680 1
d737 1
d747 1
d798 1
a798 2
	    (lp->d_partitions[partno].p_fstype ==
	    FS_UNUSED && lp->d_partitions[partno].p_size == 0)) {
d805 1
a805 1
	/* XXX - make maxsize lp->d_secperunit if FS_UNUSED? */
d817 2
a818 1
	if (lp->d_partitions[partno].p_fstype != FS_UNUSED) {
d858 1
d871 1
d1076 1
d1090 1
@


1.5
log
@Fix a typo and treat newlines as whitespace (so args work correctly).
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.4 1997/10/02 01:16:01 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.4 1997/10/02 01:16:01 millert Exp $";
d321 4
a324 1
		pp->p_fstype = FS_BSDFFS;
d725 2
a726 1
	struct partition *pp = lp->d_partitions;
d730 25
a754 3
	for (i = 0; i < lp->d_npartitions; i++ ) {
		if (pp[i].p_fstype == FS_UNUSED || pp[i].p_size == 0)
			continue;
d756 1
d761 3
a763 3
		if (new_offset >= pp[i].p_offset &&
		    new_offset < pp[i].p_offset + pp[i].p_size)
			new_offset = pp[i].p_offset + pp[i].p_size;
d766 1
d878 2
d1108 2
a1109 1
				if (!resolve)
d1111 1
d1131 2
@


1.4
log
@Deal with ^D sanely and kill unused get_yn().
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.3 1997/10/02 00:51:58 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.3 1997/10/02 00:51:58 millert Exp $";
d119 3
a121 2
		cmd = strtok(buf, " \t");
		arg = strtok(NULL, " \t");
d203 1
a203 1
				arg = getstring(lp, "Filename:",
d883 1
a883 1
			buf[0] == '\0';
d995 1
a1004 1
		/* XXX - only round BSD partitions! */
@


1.3
log
@Add 'w' (write label) command.
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.2 1997/10/02 00:02:55 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.2 1997/10/02 00:02:55 millert Exp $";
a64 1
char	get_yn __P((char *));
d114 5
a118 1
		fgets(buf, sizeof(buf), stdin);
d880 4
a883 1
		fgets(buf, sizeof(buf), stdin);
d923 4
a926 1
		fgets(buf, sizeof(buf), stdin);
a1197 14
}

char
get_yn(prompt)
	char *prompt;
{
	int c;

	do {
		printf("%s [y/n] ", prompt);
		c = tolower(getchar());
	} while (c != EOF && c != 'y' && c != 'n');

	return((char)c);
@


1.2
log
@respect -n
@
text
@d1 1
a1 1
/*	$OpenBSD: editor.c,v 1.1 1997/09/30 17:54:17 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: editor.c,v 1.1 1997/09/30 17:54:17 millert Exp $";
d131 1
d222 9
@


1.1
log
@Implement "disklabel -E" -- a simple interactive label editor for
installs and new labels.  Documentation to follow :-) Also, give
the user the option of writing the fictitious label if no on-disk
label exists with the -e, -E, and -w options.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD$";
d79 1
a79 1
extern	int rflag;
d174 4
@

