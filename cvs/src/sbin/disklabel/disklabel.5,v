head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.10
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.16
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.14
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.10
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.14
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.12
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.10
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.8
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.22
date	2015.09.10.17.55.21;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	PeV7Ql0T6htfMjhP;

1.21
date	2013.08.14.08.39.30;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.05.11.57.17;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.31.19.19.43;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.20.09.29.27;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.01.07.18.47;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.21.23.14.23;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.18.21.33.58;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.21.11.41.50;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.13.20.16.48;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.12.12.03.01;	author heko;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.06.17.36.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.14.21.31.42;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	99.06.04.02.45.14;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	98.11.11.22.19.56;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	98.09.19.14.40.09;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	98.09.17.04.14.51;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	98.07.14.22.19.33;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	98.07.11.22.42.56;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.30.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@use .In rather than .Fd #include
@
text
@.\"	$OpenBSD: disklabel.5,v 1.21 2013/08/14 08:39:30 jmc Exp $
.\"	$NetBSD: disklabel.5,v 1.3 1995/03/18 14:54:36 cgd Exp $
.\"
.\" Copyright (c) 1987, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Symmetric Computer Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @@(#)disklabel.5.5	8.1 (Berkeley) 6/5/93
.\"
.Dd $Mdocdate: August 14 2013 $
.Dt DISKLABEL 5
.Os
.Sh NAME
.Nm disklabel
.Nd disk pack label
.Sh SYNOPSIS
.In sys/disklabel.h
.Sh DESCRIPTION
Each disk or disk pack on a system may contain a disk label
which provides detailed information
about the geometry of the disk and the partitions into which the disk
is divided.
It should be initialized when the disk is formatted,
and may be changed later with the
.Xr disklabel 8
program.
This information is used by the system disk driver and by the bootstrap
program to determine how to program the drive
and where to find the filesystems on the disk partitions.
Additional information is used by the filesystem in order
to use the disk most efficiently and to locate important filesystem information.
The description of each partition contains an identifier for the partition
type (standard filesystem, swap area, etc.).
The filesystem updates the in-core copy of the label if it contains
incomplete information about the filesystem.
.Pp
The label is located in sector number
.Dv LABELSECTOR
of the drive, usually sector 0 where it may be found
without any information about the disk geometry.
It is at an offset
.Dv LABELOFFSET
from the beginning of the sector, to allow room for the initial bootstrap.
.Pp
A copy of the in-core label for a disk can be obtained with the
.Dv DIOCGDINFO
.Em ioctl ;
this works with a file descriptor for a block or character
.Pq Dq raw
device for any partition of the disk.
The in-core copy of the label is set by the
.Dv DIOCSDINFO
.Em ioctl .
The offset of a partition cannot generally be changed while it is open,
nor can it be made smaller while it is open.
One exception is that any change is allowed if no label was found
on the disk, and the driver was able to construct only a skeletal label
without partition information.
The
.Dv DIOCWDINFO
.Em ioctl
operation sets the in-core label and then updates the on-disk label;
there must be an existing label on the disk for this operation to succeed.
Thus, the initial label for a disk or disk pack must be installed
by writing to the raw disk.
The
.Dv DIOCGPDINFO
.Em ioctl
operation gets the default label for a disk.
This simulates the case
where there is no physical label on the disk itself and can be used to
see the label the kernel would construct in that case.
The
.Dv DIOCRLDINFO
.Em ioctl
operation causes the kernel to update its copy of the label based on the
physical label on the disk.
It can be used when the on-disk version
of the label was changed directly or, if there is no physical label,
to update the kernel's skeletal label if some variable affecting label
generation has changed (e.g. the fdisk partition table).
All of these operations are normally done using
.Xr disklabel 8 .
.Pp
Note that when a disk has no real
.Bx
disklabel the kernel creates a
default label so that the disk can be used.
This default label will include other partitions found on the disk if
they are supported on your architecture.
For example, on systems that support
.Xr fdisk 8
partitions the default label will also include DOS and Linux partitions.
However, these entries are not dynamic, they are fixed at the time
.Xr disklabel 8
is run.
That means that subsequent changes that affect
.Pf non- Ox
partitions will not be present in the default label, though you
may update them by hand.
To see the default label, run
.Xr disklabel 8
with the
.Fl d
flag.
You can then run
.Xr disklabel 8
with the
.Fl e
flag and paste any entries you want from the default label into the real
one.
.Sh SEE ALSO
.Xr disktab 5 ,
.Xr disklabel 8
.Sh CAVEATS
.Nm
only supports up to a maximum of 15 partitions,
.Sq a
through
.Sq p ,
excluding
.Sq c .
The
.Sq c
partition is reserved for the entire physical disk.
By convention, the
.Sq a
partition of the boot disk is the root partition, and the
.Sq b
partition of the boot disk is the swap partition,
but all other letters can be used in any order for any other
partitions as desired.
@


1.21
log
@some Bx/Ox conversion;
From: Jan Stary
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.20 2011/06/05 11:57:17 krw Exp $
d36 1
a36 1
.Dd $Mdocdate: June 5 2011 $
d43 1
a43 1
.Fd #include <sys/disklabel.h>
@


1.20
log
@Nuke uses of and references to DIOCWLABEL, and the related 'W' and
'N' command line options.

ok matthew@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.19 2007/05/31 19:19:43 jmc Exp $
d36 1
a36 1
.Dd $Mdocdate: May 31 2007 $
d111 3
a113 1
Note that when a disk has no real BSD disklabel the kernel creates a
d123 2
a124 1
That means that subsequent changes that affect non-OpenBSD
@


1.19
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.18 2003/12/20 09:29:27 jmc Exp $
d36 1
a36 1
.Dd $Mdocdate$
a69 9
The disk sector containing the label is normally made read-only
so that it is not accidentally overwritten by pack-to-pack copies
or swap operations;
the
.Dv DIOCWLABEL
.Xr ioctl 2 ,
which is done as needed by the
.Xr disklabel 8
program, allows modification of the label sector.
@


1.18
log
@make disklabel docs more readable: more logical SYNOPSIS; sort options;
make internal editor help and usage() match the docs; make sure all the
forms described in SYNOPSIS are explained; various other tweaks.

input from millert@@; ok deraadt;
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.17 2003/07/01 07:18:47 jmc Exp $
d36 1
a36 1
.Dd August 6, 2001
@


1.17
log
@- add info from disklabel(8) documenting default label; suggested by millert@@
- .Xr disklabel 8 instead of .Em
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.16 2003/06/21 23:14:23 jmc Exp $
d111 1
a111 1
operation causes the kernel to update its copy of label based on the
@


1.16
log
@add CAVEATS: disklabel only supports 15 partitions, excluding `c';
from a thread on misc@@;

wording, help, and ok nick@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.15 2003/06/02 20:06:14 millert Exp $
d77 1
a77 1
.Em disklabel
d118 26
a143 1
.Em disklabel .
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.14 2002/04/18 21:33:58 miod Exp $
d122 18
@


1.14
log
@There is no point in embedding an out-of-date copy of <sys/disklabel.h>,
especially since this manual page refers to said file.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.13 2001/12/21 11:41:50 mpech Exp $
d18 1
a18 5
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@Initial patch for a new mdoc issue.
Powered by @@mantoya:
o) kill extra line in the end of file;
o) kill extra space in the end of line;
o) replace blank lines with .Pp;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.12 2001/12/13 20:16:48 mpech Exp $
a122 297
.Pp
The format of the disk label, as specified in
.Pa sys/disklabel.h ,
is
.Bd -literal
/*
 * Disk description table, see disktab(5)
 */
#define	DISKTAB		"/etc/disktab"

/*
 * Each disk has a label which includes information about the hardware
 * disk geometry, filesystem partitions, and drive specific information.
 * The label is in block 0 or 1, possibly offset from the beginning
 * to leave room for a bootstrap, etc.
 */

#ifndef	LABELSECTOR
#define LABELSECTOR	0		/* sector containing label */
#endif

#ifndef	LABELOFFSET
#define LABELOFFSET	64		/* offset of label in sector */
#endif

#define DISKMAGIC	((u_int32_t)0x82564557)	/* disk magic number */

#ifndef LOCORE
struct disklabel {
	u_int32_t	d_magic;	/* the magic number */
	u_int16_t	d_type;		/* drive type */
	u_int16_t	d_subtype;	/* controller/d_type specific */
	char	d_typename[16];	/* type name, e.g., "eagle" */
	/*
	 * d_packname contains the pack identifier and is returned when
	 * the disklabel is read off the disk or in-core copy.
	 * d_boot0 and d_boot1 are the (optional) names of the
	 * primary (block 0) and secondary (block 1-15) bootstraps
	 * as found in /usr/mdec.  These are returned when using
	 * getdiskbyname(3) to retrieve the values from /etc/disktab.
	 */
	union {
		char	un_d_packname[16];    /* pack identifier */
		struct {
			char *un_d_boot0;     /* primary bootstrap name */
			char *un_d_boot1;     /* secondary bootstrap name */
		} un_b;
	} d_un;
#define d_packname	d_un.un_d_packname
#define d_boot0		d_un.un_b.un_d_boot0
#define d_boot1		d_un.un_b.un_d_boot1

	/* disk geometry: */
	u_int32_t	d_secsize;	/* # of bytes per sector */
	u_int32_t	d_nsectors;	/* # of data sectors per track */
	u_int32_t	d_ntracks;	/* # of tracks per cylinder */
	u_int32_t	d_ncylinders;	/* # of data cylinders per unit */
	u_int32_t	d_secpercyl;	/* # of data sectors per cylinder */
	u_int32_t	d_secperunit;	/* # of data sectors per unit */
	/*
	 * Spares (bad sector replacements) below
	 * are not counted in d_nsectors or d_secpercyl.
	 * Spare sectors are assumed to be physical sectors
	 * which occupy space at the end of each track and/or cylinder.
	 */
	u_int16_t	d_sparespertrack;  /* # of spare sects per track */
	u_int16_t	d_sparespercyl; /* # of spare sects per cylinder */
	/*
	 * Alternate cylinders include maintenance, replacement,
	 * configuration description areas, etc.
	 */
	u_int32_t	d_acylinders;	/* # of alt. cylinders per unit */

	/* hardware characteristics: */
	/*
	 * d_interleave, d_trackskew and d_cylskew describe perturbations
	 * in the media format used to compensate for a slow controller.
	 * Interleave is physical sector interleave, set up by the
	 * formatter or controller when formatting.  When interleaving is
	 * in use, logically adjacent sectors are not physically
	 * contiguous, but instead are separated by some number of sectors.
	 * It is specified as the ratio of physical sectors traversed
	 * per logical sector.  Thus an interleave of 1:1 implies
	 * contiguous layout, while 2:1 implies that logical sector 0 is
	 * separated by one sector from logical sector 1.
	 * d_trackskew is the offset of sector 0 on track N
	 * relative to sector 0 on track N-1 on the same cylinder.
	 * Finally, d_cylskew is the offset of sector 0 on cylinder N
	 * relative to sector 0 on cylinder N-1.
	 */
	u_int16_t	d_rpm;	/* rotational speed */
	u_int16_t	d_interleave;	/* hardware sector interleave */
	u_int16_t	d_trackskew;	/* sector 0 skew, per track */
	u_int16_t	d_cylskew;	/* sector 0 skew, per cylinder */
	u_int32_t	d_headswitch;	/* head switch time, usec */
	u_int32_t	d_trkseek;	/* track-to-track seek, usec */
	u_int32_t	d_flags;	/* generic flags */
#define NDDATA 5
	u_int32_t	d_drivedata[NDDATA]; /* drive-type specific info */
#define NSPARE 5
	u_int32_t	d_spare[NSPARE];/* reserved for future use */
	u_int32_t	d_magic2;	/* the magic number (again) */
	u_int16_t	d_checksum;	/* xor of data incl. partitions */

	/* filesystem and partition information: */
	u_int16_t	d_npartitions;	/* # of partitions in following */
	u_int32_t	d_bbsize;	/* size of boot area at sn0, bytes */
	u_int32_t	d_sbsize;	/* max size of fs superblock, bytes */
	struct	partition {	/* the partition table */
		u_int32_t	p_size;	/* number of sectors in partition */
		u_int32_t	p_offset;	/* starting sector */
		u_int32_t	p_fsize;	/* filesystem basic frag size */
		u_int8_t	p_fstype;	/* filesystem type, see below */
		u_int8_t	p_frag;		/* filesystem frags per block */
		union {
			u_int16_t	cpg;	/* UFS: FS cyls per group */
			u_int16_t	sgs;	/* LFS: FS segment shift */
		} __partition_u1;
#define	p_cpg	__partition_u1.cpg
#define	p_sgs	__partition_u1.sgs
	} d_partitions[MAXPARTITIONS];	/* actually may be more,
					 * MAXPARTITIONS depends on the
					 * architecture, and typically
					 * varies between 8 and 16.
					 */
};

/* d_type values: */
#define	DTYPE_SMD	1	/* SMD, XSMD; VAX hp/up */
#define	DTYPE_MSCP	2	/* MSCP */
#define	DTYPE_DEC	3	/* other DEC (rk, rl) */
#define	DTYPE_SCSI	4	/* SCSI */
#define	DTYPE_ESDI	5	/* ESDI interface */
#define	DTYPE_ST506	6	/* ST506 etc. */
#define	DTYPE_HPIB	7	/* CS/80 on HP-IB */
#define	DTYPE_HPFL	8	/* HP Fiber-link */
#define	DTYPE_FLOPPY	10	/* floppy */
#define	DTYPE_CCD	11	/* concatenated disk device */
#define	DTYPE_VND	12	/* vnode pseudo-disk */
#define	DTYPE_ATAPI	13	/* ATAPI */
#define	DTYPE_RAID	14	/* RAIDframe */

#ifdef DKTYPENAMES
static char *dktypenames[] = {
	"unknown",
	"SMD",
	"MSCP",
	"old DEC",
	"SCSI",
	"ESDI",
	"ST506",
	"HP-IB",
	"HP-FL",
	"type 9",
	"floppy",
	"ccd",
	"vnd",
	"ATAPI",
	"RAID",
	NULL
};
#define DKMAXTYPES	(sizeof(dktypenames) / sizeof(dktypenames[0]) - 1)
#endif

/*
 * Filesystem type and version.
 * Used to interpret other filesystem-specific
 * per-partition information.
 */
#define	FS_UNUSED	0	/* unused */
#define	FS_SWAP		1	/* swap */
#define	FS_V6		2	/* Sixth Edition */
#define	FS_V7		3	/* Seventh Edition */
#define	FS_SYSV		4	/* System V */
#define	FS_V71K		5	/* V7 with 1K blocks (4.1, 2.9) */
#define	FS_V8		6	/* Eighth Edition, 4K blocks */
#define	FS_BSDFFS	7	/* 4.2BSD fast file system */
#define	FS_MSDOS	8	/* MSDOS file system */
#define	FS_BSDLFS	9	/* 4.4BSD log-structured file system */
#define	FS_OTHER	10	/* in use, but unknown/unsupported */
#define	FS_HPFS		11	/* OS/2 high-performance file system */
#define	FS_ISO9660	12	/* ISO 9660, normally CD-ROM */
#define	FS_BOOT		13	/* partition contains bootstrap */
#define FS_ADOS		14	/* AmigaDOS fast file system */
#define FS_HFS		15	/* Macintosh HFS */
#define FS_ADFS		16	/* Acorn Disk Filing System */
#define FS_EXT2FS	17	/* ext2fs */
#define FS_CCD		18	/* ccd component */
#define FS_RAID		19	/* RAIDframe */

#ifdef	DKTYPENAMES
static char *fstypenames[] = {
	"unused",
	"swap",
	"Version6",
	"Version7",
	"SystemV",
	"4.1BSD",
	"Eighth-Edition",
	"4.2BSD",
	"MSDOS",
	"4.4LFS",
	"unknown",
	"HPFS",
	"ISO9660",
	"boot",
	"ADOS",
	"HFS",
	"ADFS",
	"ext2fs",
	"ccd",
	"RAID",
	NULL
};
#define FSMAXTYPES	(sizeof(fstypenames) / sizeof(fstypenames[0]) - 1)
#endif

/*
 * flags shared by various drives:
 */
#define	D_REMOVABLE	0x01	/* removable media */
#define	D_ECC		0x02	/* supports ECC */
#define	D_BADSECT	0x04	/* supports bad sector forw. */
#define	D_RAMDISK	0x08	/* disk emulator */
#define	D_CHAIN		0x10	/* can do back-back transfers */

/*
 * Drive data for SMD.
 */

#define	d_smdflags	d_drivedata[0]
#define	D_SSE		0x1	/* supports skip sectoring */
#define	d_mindist	d_drivedata[1]
#define	d_maxdist	d_drivedata[2]
#define	d_sdist		d_drivedata[3]

/*
 * Drive data for ST506.
 */
#define d_precompcyl	d_drivedata[0]
#define d_gap3		d_drivedata[1]	/* used only when formatting */

/*
 * Drive data for SCSI.
 */
#define	d_blind		d_drivedata[0]

#ifndef LOCORE
/*
 * Structure used to perform a format
 * or other raw operation, returning data
 * and/or register values.
 * Register identification and format
 * are device- and driver-dependent.
 */
struct format_op {
	char	*df_buf;
	int	df_count;	/* value-result */
	daddr_t	df_startblk;
	int	df_reg[8];	/* result */
};

/*
 * Structure used internally to retrieve
 * information about a partition on a disk.
 */
struct partinfo {
	struct	disklabel *disklab;
	struct	partition *part;
};

/*
 * Disk-specific ioctls.
 */
/* get and set disklabel; DIOCGPART used internally */
#define DIOCGDINFO   _IOR('d', 101, struct disklabel) /* get */
#define DIOCSDINFO   _IOW('d', 102, struct disklabel) /* set */
#define DIOCWDINFO   _IOW('d', 103, struct disklabel) /* set, update disk */
#define DIOCGPART    _IOW('d', 104, struct partinfo)  /* get partition */

/* do format operation, read or write */
#define DIOCRFORMAT	_IOWR('d', 105, struct format_op)
#define DIOCWFORMAT	_IOWR('d', 106, struct format_op)

#define DIOCSSTEP	_IOW('d', 107, int) /* set step rate */
#define DIOCSRETRIES	_IOW('d', 108, int) /* set # of retries */
#define DIOCWLABEL	_IOW('d', 109, int) /* write en/disable label */

#define DIOCSBAD	_IOW('d', 110, struct dkbad) /* set kernel dkbad */
#define DIOCEJECT	_IO('d', 112)                /* eject disk */
#define DIOCLOCK	_IOW('d', 113, int)          /* lock/unlock pack */

#define DIOCGPDINFO	_IOR('d', 114, struct disklabel)/* get physical */
#define DIOCRLDINFO	_IO('d', 115)                   /* reload disklabel */

#endif /* LOCORE */
.Ed
@


1.12
log
@o) start new sentence on a new line;
o) wrap long lines;
o) fix bogus .Xr usage;
o) we don't like blank lines;
o) always close .Bl tags;
o) OpenBSD -> .Ox;
o) don't like .Pp before .Ss;

millert@@ ok;
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.11 2001/08/12 12:03:01 heko Exp $
d107 1
a107 1
.Em ioctl     
@


1.11
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.10 2001/08/06 17:36:44 millert Exp $
d81 1
a81 1
.Xr disklabel
d86 1
a86 1
.Xr ioctl ;
d92 1
a92 1
.Xr ioctl .
d100 1
a100 1
.Xr ioctl
d107 3
a109 2
.Xr ioctl     
operation gets the default label for a disk.  This simulates the case
d114 1
a114 1
.Xr ioctl
d116 2
a117 1
physical label on the disk.  It can be used when the on-disk version
d122 1
a122 1
.Xr disklabel .
@


1.10
log
@Update to reality based on sys/disklabel.h
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.9 2000/03/14 21:31:42 aaron Exp $
d416 1
a416 1
#endif LOCORE
@


1.9
log
@Suffix "i.e." and "e.g." with a comma. Just another really picky man page
commit, as we want our documentation to be as consistently formatted as
possible (it's getting there :-)).
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.8 1999/06/04 02:45:14 aaron Exp $
d40 1
a40 1
.Dd June 5, 1993
d98 1
a98 1
Finally, the
d105 14
d127 2
a128 2
* Disk description table, see disktab(5)
*/
d132 5
a136 5
* Each disk has a label which includes information about the hardware
* disk geometry, filesystem partitions, and drive specific information.
* The label is in block 0 or 1, possibly offset from the beginning
* to leave room for a bootstrap, etc.
*/
d139 1
a139 1
#define LABELSECTOR	0			/* sector containing label */
d143 1
a143 1
#define LABELOFFSET	64			/* offset of label in sector */
d146 1
a146 1
#define DISKMAGIC	((u_long) 0x82564557)	/* The disk magic number */
d150 3
a152 3
	u_long	d_magic;	/* the magic number */
	short	d_type;		/* drive type */
	short	d_subtype;	/* controller/d_type specific */
d155 7
a161 8
	* d_packname contains the pack identifier and is returned when
	* the disklabel is read off the disk or in-core copy.
	* d_boot0 and d_boot1 are the (optional) names of the
	* primary (block 0) and secondary (block 1-15) bootstraps
	* as found in /usr/mdec.  These are returned when using
	* getdiskbyname(3)
	to retrieve the values from /etc/disktab.
	*/
d163 1
a163 1
		char	un_d_packname[16];	/* pack identifier */
d165 2
a166 2
			char *un_d_boot0;	/* primary bootstrap name */
			char *un_d_boot1;	/* secondary bootstrap name */
d174 6
a179 6
	u_long	d_secsize;	/* # of bytes per sector */
	u_long	d_nsectors;	/* # of data sectors per track */
	u_long	d_ntracks;	/* # of tracks per cylinder */
	u_long	d_ncylinders;	/* # of data cylinders per unit */
	u_long	d_secpercyl;	/* # of data sectors per cylinder */
	u_long	d_secperunit;	/* # of data sectors per unit */
d181 7
a187 7
	* Spares (bad sector replacements) below
	* are not counted in d_nsectors or d_secpercyl.
	* Spare sectors are assumed to be physical sectors
	* which occupy space at the end of each track and/or cylinder.
	*/
	u_short	d_sparespertrack;	/* # of spare sectors per track */
	u_short	d_sparespercyl;	/* # of spare sectors per cylinder */
d189 4
a192 4
	* Alternate cylinders include maintenance, replacement,
	* configuration description areas, etc.
	*/
	u_long	d_acylinders;	/* # of alt. cylinders per unit */
d194 1
a194 1
		/* hardware characteristics: */
d196 22
a217 22
	* d_interleave, d_trackskew and d_cylskew describe perturbations
	* in the media format used to compensate for a slow controller.
	* Interleave is physical sector interleave, set up by the formatter
	* or controller when formatting.  When interleaving is in use,
	* logically adjacent sectors are not physically contiguous,
	* but instead are separated by some number of sectors.
	* It is specified as the ratio of physical sectors traversed
	* per logical sector.  Thus an interleave of 1:1 implies contiguous
	* layout, while 2:1 implies that logical sector 0 is separated
	* by one sector from logical sector 1.
	* d_trackskew is the offset of sector 0 on track N
	* relative to sector 0 on track N-1 on the same cylinder.
	* Finally, d_cylskew is the offset of sector 0 on cylinder N
	* relative to sector 0 on cylinder N-1.
	*/
	u_short	d_rpm;	/* rotational speed */
	u_short	d_interleave;	/* hardware sector interleave */
	u_short	d_trackskew;	/* sector 0 skew, per track */
	u_short	d_cylskew;	/* sector 0 skew, per cylinder */
	u_long	d_headswitch;	/* head switch time, usec */
	u_long	d_trkseek;	/* track-to-track seek, usec */
	u_long	d_flags;	/* generic flags */
d219 1
a219 1
	u_long	d_drivedata[NDDATA];	/* drive-type specific information */
d221 3
a223 3
	u_long	d_spare[NSPARE];	/* reserved for future use */
	u_long	d_magic2;	/* the magic number (again) */
	u_short	d_checksum;	/* xor of data incl. partitions */
d226 3
a228 3
	u_short	d_npartitions;	/* number of partitions in following */
	u_long	d_bbsize;	/* size of boot area at sn0, bytes */
	u_long	d_sbsize;	/* max size of fs superblock, bytes */
d230 5
a234 5
		u_long	p_size;	/* number of sectors in partition */
		u_long	p_offset;	/* starting sector */
		u_long	p_fsize;	/* filesystem basic fragment size */
		u_char	p_fstype;	/* filesystem type, see below */
		u_char	p_frag;	/* filesystem fragments per block */
d236 2
a237 2
			u_short	cpg;	/* UFS: FS cylinders per group */
			u_short	sgs;	/* LFS: FS segment shift */
d241 4
a244 4
		u_short	p_cpg;	/* filesystem cylinders per group */
	} d_partitions[MAXPARTITIONS];	/* actually may be more, MAXPARTITIONS
					 * depends on the architecture, and
					 * typically varies between 8 and 16.
d258 4
d276 5
a280 1
	0
d286 4
a289 4
* Filesystem type and version.
* Used to interpret other filesystem-specific
* per-partition information.
*/
d304 6
d315 3
a317 3
	"Version 6",
	"Version 7",
	"System V",
d319 1
a319 1
	"Eighth Edition",
d327 7
a333 1
	0
d339 2
a340 2
* flags shared by various drives:
*/
d348 2
a349 2
* Drive data for SMD.
*/
d358 2
a359 2
* Drive data for ST506.
*/
d370 6
a375 6
* Structure used to perform a format
* or other raw operation, returning data
* and/or register values.
* Register identification and format
* are device- and driver-dependent.
*/
d384 3
a386 3
* Structure used internally to retrieve
* information about a partition on a disk.
*/
d393 3
a395 3
* Disk-specific ioctls.
*/
	/* get and set disklabel; DIOCGPART used internally */
d410 5
@


1.8
log
@start to remove non-escaped trailing whitespace, it can confuse troff; pjanzen@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.7 1998/11/11 22:19:56 aaron Exp $
d139 1
a139 1
	char	d_typename[16];	/* type name, e.g. "eagle" */
@


1.7
log
@more `` '' -> .Dq sillyness; remove redundant .Pp macros; other misc fixes
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.6 1998/09/19 14:40:09 espie Exp $
d90 1
a90 1
The in-core copy of the label is set by the 
d98 1
a98 1
Finally, the 
d140 1
a140 1
	/* 
d150 1
a150 1
		char	un_d_packname[16];	/* pack identifier */ 
d154 2
a155 2
		} un_b; 
	} d_un; 
@


1.6
log
@
Repair
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.5 1998/09/17 04:14:51 aaron Exp $
d87 3
a89 2
this works with a file descriptor for a block or character (``raw'') device
for any partition of the disk.
@


1.5
log
@sbin/ man page fixes
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.4 1998/07/14 22:19:33 angelos Exp $
d82 1
a82 1
program.
@


1.4
log
@Correct MAXPARTITIONS text.
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.3 1998/07/11 22:42:56 angelos Exp $
d108 1
a108 1
.Aw Pa sys/disklabel.h ,
a381 1
.Sh HISTORY
@


1.3
log
@MAXPARTITIONS are only 8 for amiga; all others have 16.
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.2 1996/06/23 14:30:04 deraadt Exp $
a131 7
#ifndef MAXPARTITIONS
#if amiga
#define MAXPARTITIONS	8
#else
#define	MAXPARTITIONS	16
#endif
#endif
d228 4
a231 1
	} d_partitions[MAXPARTITIONS];	/* actually may be more */
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
.\"	$OpenBSD: disklabel.5,v 1.3 1995/03/18 14:54:36 cgd Exp $
d133 5
a137 1
#define	MAXPARTITIONS	8
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
