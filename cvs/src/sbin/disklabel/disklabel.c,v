head	1.226;
access;
symbols
	OPENBSD_6_2_BASE:1.226
	OPENBSD_6_1:1.225.0.4
	OPENBSD_6_1_BASE:1.225
	OPENBSD_6_0:1.222.0.2
	OPENBSD_6_0_BASE:1.222
	OPENBSD_5_9:1.214.0.2
	OPENBSD_5_9_BASE:1.214
	OPENBSD_5_8:1.202.0.4
	OPENBSD_5_8_BASE:1.202
	OPENBSD_5_7:1.199.0.2
	OPENBSD_5_7_BASE:1.199
	OPENBSD_5_6:1.196.0.4
	OPENBSD_5_6_BASE:1.196
	OPENBSD_5_5:1.192.0.4
	OPENBSD_5_5_BASE:1.192
	OPENBSD_5_4:1.187.0.2
	OPENBSD_5_4_BASE:1.187
	OPENBSD_5_3:1.185.0.4
	OPENBSD_5_3_BASE:1.185
	OPENBSD_5_2:1.185.0.2
	OPENBSD_5_2_BASE:1.185
	OPENBSD_5_1_BASE:1.184
	OPENBSD_5_1:1.184.0.2
	OPENBSD_5_0:1.181.0.2
	OPENBSD_5_0_BASE:1.181
	OPENBSD_4_9:1.175.0.2
	OPENBSD_4_9_BASE:1.175
	OPENBSD_4_8:1.170.0.2
	OPENBSD_4_8_BASE:1.170
	OPENBSD_4_7:1.160.0.2
	OPENBSD_4_7_BASE:1.160
	OPENBSD_4_6:1.158.0.4
	OPENBSD_4_6_BASE:1.158
	OPENBSD_4_5:1.138.0.2
	OPENBSD_4_5_BASE:1.138
	OPENBSD_4_4:1.136.0.2
	OPENBSD_4_4_BASE:1.136
	OPENBSD_4_3:1.122.0.2
	OPENBSD_4_3_BASE:1.122
	OPENBSD_4_2:1.118.0.2
	OPENBSD_4_2_BASE:1.118
	OPENBSD_4_1:1.105.0.2
	OPENBSD_4_1_BASE:1.105
	OPENBSD_4_0:1.98.0.2
	OPENBSD_4_0_BASE:1.98
	OPENBSD_3_9:1.97.0.2
	OPENBSD_3_9_BASE:1.97
	OPENBSD_3_8:1.95.0.2
	OPENBSD_3_8_BASE:1.95
	OPENBSD_3_7:1.94.0.2
	OPENBSD_3_7_BASE:1.94
	OPENBSD_3_6:1.90.0.2
	OPENBSD_3_6_BASE:1.90
	OPENBSD_3_5:1.86.0.2
	OPENBSD_3_5_BASE:1.86
	OPENBSD_3_4:1.85.0.2
	OPENBSD_3_4_BASE:1.85
	OPENBSD_3_3:1.78.0.2
	OPENBSD_3_3_BASE:1.78
	OPENBSD_3_2:1.75.0.2
	OPENBSD_3_2_BASE:1.75
	OPENBSD_3_1:1.73.0.2
	OPENBSD_3_1_BASE:1.73
	OPENBSD_3_0:1.71.0.2
	OPENBSD_3_0_BASE:1.71
	OPENBSD_2_9:1.69.0.4
	OPENBSD_2_9_BASE:1.69
	OPENBSD_2_8:1.69.0.2
	OPENBSD_2_8_BASE:1.69
	OPENBSD_2_7:1.68.0.4
	OPENBSD_2_7_BASE:1.68
	OPENBSD_2_6:1.68.0.2
	OPENBSD_2_6_BASE:1.68
	OPENBSD_2_5:1.63.0.2
	OPENBSD_2_5_BASE:1.63
	OPENBSD_2_4:1.56.0.2
	OPENBSD_2_4_BASE:1.56
	OPENBSD_2_3:1.50.0.2
	OPENBSD_2_3_BASE:1.50
	OPENBSD_2_2:1.46.0.2
	OPENBSD_2_2_BASE:1.46
	OPENBSD_2_1:1.31.0.2
	OPENBSD_2_1_BASE:1.31
	OPENBSD_2_0:1.23.0.2
	OPENBSD_2_0_BASE:1.23
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.226
date	2017.09.29.18.32.09;	author otto;	state Exp;
branches;
next	1.225;
commitid	1hWxE0e5a4eVxvXZ;

1.225
date	2017.03.04.07.26.42;	author otto;	state Exp;
branches;
next	1.224;
commitid	JwCAC267qNydLo8J;

1.224
date	2016.09.04.11.35.30;	author bluhm;	state Exp;
branches;
next	1.223;
commitid	onUaYiNHqY3EIIdF;

1.223
date	2016.09.02.10.47.17;	author otto;	state Exp;
branches;
next	1.222;
commitid	eaKocvXC2WL7VoW0;

1.222
date	2016.06.19.13.42.56;	author tb;	state Exp;
branches;
next	1.221;
commitid	dHsaVhRe1CKEcdzo;

1.221
date	2016.06.13.09.54.01;	author jsg;	state Exp;
branches;
next	1.220;
commitid	HmQQAokPcEEpGpNa;

1.220
date	2016.06.01.16.51.54;	author tb;	state Exp;
branches;
next	1.219;
commitid	RNGE7tk2XuS7i5Op;

1.219
date	2016.05.29.17.02.21;	author tb;	state Exp;
branches;
next	1.218;
commitid	HOVP1EULAEGTRH0Z;

1.218
date	2016.05.28.23.38.30;	author deraadt;	state Exp;
branches;
next	1.217;
commitid	3x1TxbccxuVe2owE;

1.217
date	2016.05.28.16.46.44;	author beck;	state Exp;
branches;
next	1.216;
commitid	KHLlLi9Cf2UDcZmV;

1.216
date	2016.05.28.16.00.19;	author beck;	state Exp;
branches;
next	1.215;
commitid	48kbzWbk2Av3WORh;

1.215
date	2016.05.28.15.46.43;	author beck;	state Exp;
branches;
next	1.214;
commitid	I9lXp5VvURb2tE63;

1.214
date	2015.11.25.17.17.38;	author krw;	state Exp;
branches;
next	1.213;
commitid	Yz8XFcTgHulsHv0j;

1.213
date	2015.11.24.01.17.03;	author krw;	state Exp;
branches;
next	1.212;
commitid	5kq2TBQSOJxLHrdS;

1.212
date	2015.11.23.19.19.29;	author deraadt;	state Exp;
branches;
next	1.211;
commitid	Cz19p5I1S6mVZIjV;

1.211
date	2015.10.17.13.27.08;	author krw;	state Exp;
branches;
next	1.210;
commitid	V77mDKjRGnu2BBag;

1.210
date	2015.10.15.19.31.15;	author miod;	state Exp;
branches;
next	1.209;
commitid	cIMgSVEQ53BJoP4V;

1.209
date	2015.10.11.04.36.22;	author deraadt;	state Exp;
branches;
next	1.208;
commitid	ZnMR5tr69G7FF5uH;

1.208
date	2015.10.05.12.49.58;	author krw;	state Exp;
branches;
next	1.207;
commitid	UBpU7aagl3YEedHg;

1.207
date	2015.09.24.22.03.53;	author krw;	state Exp;
branches;
next	1.206;
commitid	MTIKfcP1VqHWbjsJ;

1.206
date	2015.09.24.19.49.38;	author krw;	state Exp;
branches;
next	1.205;
commitid	vO4z15IO1nCO89wn;

1.205
date	2015.09.09.13.51.55;	author krw;	state Exp;
branches;
next	1.204;
commitid	MhJBFHx9pq2Fexle;

1.204
date	2015.08.20.22.02.20;	author deraadt;	state Exp;
branches;
next	1.203;
commitid	0qPuuXwccpVXsXcV;

1.203
date	2015.08.15.17.16.10;	author krw;	state Exp;
branches;
next	1.202;
commitid	GIToSA4iSGnWrUfq;

1.202
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.201;
commitid	GouatFiJVxwlAVIQ;

1.201
date	2015.04.29.16.56.31;	author henning;	state Exp;
branches;
next	1.200;
commitid	UAIjeVKl6GkJq4ts;

1.200
date	2015.04.29.09.58.16;	author henning;	state Exp;
branches;
next	1.199;
commitid	4ecfLcgizo5sIt85;

1.199
date	2015.02.07.02.09.13;	author deraadt;	state Exp;
branches;
next	1.198;
commitid	pzd3OPiuZ6mCFBtc;

1.198
date	2015.01.20.18.22.20;	author deraadt;	state Exp;
branches;
next	1.197;
commitid	F55lwc3gS4GN2mLs;

1.197
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.196;
commitid	Uu5nFG3wCl0LACBb;

1.196
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.195;
commitid	0acpjAf5myNxgwB5;

1.195
date	2014.05.05.16.33.34;	author krw;	state Exp;
branches;
next	1.194;

1.194
date	2014.04.23.11.49.25;	author otto;	state Exp;
branches;
next	1.193;

1.193
date	2014.03.18.22.36.30;	author miod;	state Exp;
branches;
next	1.192;

1.192
date	2014.02.14.15.03.43;	author krw;	state Exp;
branches;
next	1.191;

1.191
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.190;

1.190
date	2013.10.15.20.13.02;	author bluhm;	state Exp;
branches;
next	1.189;

1.189
date	2013.10.03.18.50.30;	author krw;	state Exp;
branches;
next	1.188;

1.188
date	2013.09.10.15.17.46;	author krw;	state Exp;
branches;
next	1.187;

1.187
date	2013.06.18.18.24.15;	author krw;	state Exp;
branches;
next	1.186;

1.186
date	2013.06.11.16.42.04;	author deraadt;	state Exp;
branches;
next	1.185;

1.185
date	2012.04.06.18.20.35;	author deraadt;	state Exp;
branches;
next	1.184;

1.184
date	2012.01.16.17.32.07;	author krw;	state Exp;
branches;
next	1.183;

1.183
date	2012.01.02.03.40.31;	author krw;	state Exp;
branches;
next	1.182;

1.182
date	2012.01.02.00.59.33;	author krw;	state Exp;
branches;
next	1.181;

1.181
date	2011.06.05.11.57.17;	author krw;	state Exp;
branches;
next	1.180;

1.180
date	2011.06.02.17.00.24;	author krw;	state Exp;
branches;
next	1.179;

1.179
date	2011.05.22.13.05.47;	author otto;	state Exp;
branches;
next	1.178;

1.178
date	2011.04.19.19.16.18;	author halex;	state Exp;
branches;
next	1.177;

1.177
date	2011.04.16.14.51.00;	author krw;	state Exp;
branches;
next	1.176;

1.176
date	2011.04.16.11.44.41;	author krw;	state Exp;
branches;
next	1.175;

1.175
date	2010.12.13.01.01.41;	author marco;	state Exp;
branches;
next	1.174;

1.174
date	2010.11.24.14.15.31;	author jsing;	state Exp;
branches;
next	1.173;

1.173
date	2010.09.23.13.59.10;	author jsing;	state Exp;
branches;
next	1.172;

1.172
date	2010.09.23.13.54.21;	author jsing;	state Exp;
branches;
next	1.171;

1.171
date	2010.08.12.23.32.07;	author tedu;	state Exp;
branches;
next	1.170;

1.170
date	2010.08.08.05.24.46;	author tedu;	state Exp;
branches;
next	1.169;

1.169
date	2010.08.03.00.19.42;	author krw;	state Exp;
branches;
next	1.168;

1.168
date	2010.08.03.00.08.30;	author krw;	state Exp;
branches;
next	1.167;

1.167
date	2010.07.27.00.07.26;	author krw;	state Exp;
branches;
next	1.166;

1.166
date	2010.06.30.23.44.06;	author halex;	state Exp;
branches;
next	1.165;

1.165
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.164;

1.164
date	2010.04.28.17.12.52;	author jsing;	state Exp;
branches;
next	1.163;

1.163
date	2010.04.28.16.56.01;	author jsing;	state Exp;
branches;
next	1.162;

1.162
date	2010.04.28.12.55.55;	author jsing;	state Exp;
branches;
next	1.161;

1.161
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.160;

1.160
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.159;

1.159
date	2009.09.15.21.51.51;	author fgsch;	state Exp;
branches;
next	1.158;

1.158
date	2009.06.04.21.13.03;	author deraadt;	state Exp;
branches;
next	1.157;

1.157
date	2009.06.02.16.23.45;	author krw;	state Exp;
branches;
next	1.156;

1.156
date	2009.05.31.00.05.03;	author krw;	state Exp;
branches;
next	1.155;

1.155
date	2009.05.29.01.49.56;	author krw;	state Exp;
branches;
next	1.154;

1.154
date	2009.05.17.01.17.12;	author krw;	state Exp;
branches;
next	1.153;

1.153
date	2009.05.05.12.24.19;	author otto;	state Exp;
branches;
next	1.152;

1.152
date	2009.04.30.00.45.00;	author krw;	state Exp;
branches;
next	1.151;

1.151
date	2009.04.12.01.01.24;	author krw;	state Exp;
branches;
next	1.150;

1.150
date	2009.04.11.23.57.56;	author krw;	state Exp;
branches;
next	1.149;

1.149
date	2009.04.11.16.54.28;	author krw;	state Exp;
branches;
next	1.148;

1.148
date	2009.04.10.20.54.08;	author krw;	state Exp;
branches;
next	1.147;

1.147
date	2009.03.31.23.58.36;	author krw;	state Exp;
branches;
next	1.146;

1.146
date	2009.03.31.01.22.41;	author krw;	state Exp;
branches;
next	1.145;

1.145
date	2009.03.30.00.39.26;	author deraadt;	state Exp;
branches;
next	1.144;

1.144
date	2009.03.29.19.58.27;	author weingart;	state Exp;
branches;
next	1.143;

1.143
date	2009.03.29.05.37.13;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2009.03.28.16.27.24;	author krw;	state Exp;
branches;
next	1.141;

1.141
date	2009.03.28.14.03.42;	author deraadt;	state Exp;
branches;
next	1.140;

1.140
date	2009.03.22.20.51.58;	author jmc;	state Exp;
branches;
next	1.139;

1.139
date	2009.03.22.19.01.32;	author krw;	state Exp;
branches;
next	1.138;

1.138
date	2009.02.15.21.07.00;	author krw;	state Exp;
branches;
next	1.137;

1.137
date	2009.01.11.19.44.57;	author miod;	state Exp;
branches;
next	1.136;

1.136
date	2008.08.11.19.03.05;	author reyk;	state Exp;
branches;
next	1.135;

1.135
date	2008.08.10.13.00.25;	author sobrado;	state Exp;
branches;
next	1.134;

1.134
date	2008.08.04.15.58.13;	author reyk;	state Exp;
branches;
next	1.133;

1.133
date	2008.07.10.00.21.39;	author krw;	state Exp;
branches;
next	1.132;

1.132
date	2008.07.09.23.59.44;	author krw;	state Exp;
branches;
next	1.131;

1.131
date	2008.07.01.04.08.53;	author ray;	state Exp;
branches;
next	1.130;

1.130
date	2008.06.25.18.31.07;	author otto;	state Exp;
branches;
next	1.129;

1.129
date	2008.06.25.15.26.43;	author reyk;	state Exp;
branches;
next	1.128;

1.128
date	2008.06.04.01.27.54;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2008.04.07.23.37.14;	author krw;	state Exp;
branches;
next	1.126;

1.126
date	2008.04.07.23.27.21;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2008.04.06.21.36.24;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2008.04.06.13.10.43;	author krw;	state Exp;
branches;
next	1.123;

1.123
date	2008.03.23.19.42.17;	author krw;	state Exp;
branches;
next	1.122;

1.122
date	2008.01.24.12.23.35;	author krw;	state Exp;
branches;
next	1.121;

1.121
date	2008.01.21.20.07.11;	author sobrado;	state Exp;
branches;
next	1.120;

1.120
date	2007.10.17.20.02.30;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2007.06.25.22.53.45;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2007.06.23.19.14.20;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2007.06.18.22.07.43;	author krw;	state Exp;
branches;
next	1.115;

1.115
date	2007.06.18.21.06.51;	author krw;	state Exp;
branches;
next	1.114;

1.114
date	2007.06.17.00.32.21;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2007.06.08.19.08.35;	author otto;	state Exp;
branches;
next	1.112;

1.112
date	2007.06.08.18.42.17;	author otto;	state Exp;
branches;
next	1.111;

1.111
date	2007.06.07.19.51.08;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.24.13.01.23;	author krw;	state Exp;
branches;
next	1.108;

1.108
date	2007.05.13.14.19.18;	author ray;	state Exp;
branches;
next	1.107;

1.107
date	2007.04.26.22.42.11;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2007.04.26.02.43.29;	author ray;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.24.03.33.27;	author ray;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.20.01.50.01;	author ray;	state Exp;
branches;
next	1.103;

1.103
date	2006.10.14.19.16.39;	author krw;	state Exp;
branches;
next	1.102;

1.102
date	2006.10.14.18.26.55;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2006.09.27.00.40.43;	author krw;	state Exp;
branches;
next	1.100;

1.100
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2006.09.24.20.29.52;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2006.07.01.16.50.33;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2005.11.13.20.27.10;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2005.11.12.13.27.59;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2005.04.30.07.09.37;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2005.01.07.21.58.14;	author otto;	state Exp;
branches;
next	1.93;

1.93
date	2004.10.04.15.09.41;	author otto;	state Exp;
branches;
next	1.92;

1.92
date	2004.09.28.17.57.46;	author otto;	state Exp;
branches;
next	1.91;

1.91
date	2004.09.18.23.23.17;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2004.08.08.19.04.25;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2004.08.03.09.30.11;	author otto;	state Exp;
branches;
next	1.88;

1.88
date	2004.05.20.23.23.46;	author marco;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.07.14.09.35;	author aaron;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.20.09.29.27;	author jmc;	state Exp;
branches;
next	1.85;

1.85
date	2003.07.29.18.38.35;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2003.07.16.18.03.44;	author tedu;	state Exp;
branches;
next	1.83;

1.83
date	2003.07.02.21.22.10;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.25.21.11.48;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.11.06.22.12;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.79;

1.79
date	2003.04.06.00.45.12;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2003.02.13.00.10.39;	author tedu;	state Exp;
branches;
next	1.77;

1.77
date	2003.02.05.19.13.58;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2002.12.31.16.22.25;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.74;

1.74
date	2002.05.22.08.21.01;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2002.03.24.22.51.54;	author millert;	state Exp;
branches;
next	1.72;

1.72
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.71;

1.71
date	2001.09.03.16.14.27;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2001.07.07.18.26.10;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2000.06.30.16.00.08;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	99.08.17.09.13.14;	author millert;	state Exp;
branches
	1.68.4.1;
next	1.67;

1.67
date	99.08.14.15.11.11;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	99.08.13.02.06.58;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	99.07.14.23.16.26;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	99.06.16.10.12.38;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	99.04.07.22.57.25;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	99.03.23.05.18.49;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	99.03.16.04.47.16;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	99.03.14.19.31.19;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	99.03.07.03.05.31;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	99.03.01.01.50.45;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	99.01.12.04.48.25;	author aaron;	state Exp;
branches;
next	1.56;

1.56
date	98.10.03.22.01.47;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	98.09.11.04.02.27;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	98.09.10.06.56.47;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	98.06.07.05.00.23;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	98.05.07.16.39.35;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	98.04.25.07.17.12;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	98.03.12.19.35.55;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	98.02.20.01.55.29;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	98.02.19.20.43.36;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	97.11.25.00.36.22;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	97.10.24.00.18.55;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	97.10.20.07.09.41;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	97.10.17.07.30.03;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	97.10.17.04.33.05;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	97.10.13.15.02.15;	author pefo;	state Exp;
branches;
next	1.41;

1.41
date	97.10.02.01.16.02;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	97.10.02.00.49.11;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	97.09.30.17.54.15;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	97.09.26.04.10.28;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	97.09.14.10.37.40;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	97.09.03.22.39.12;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	97.08.29.18.05.40;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	97.07.28.08.26.58;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	97.07.19.20.35.37;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	97.06.25.18.06.42;	author kstailey;	state Exp;
branches;
next	1.31;

1.31
date	97.05.21.16.02.33;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	97.04.20.08.59.40;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.04.10.22.26.13;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	97.02.17.16.30.25;	author imp;	state Exp;
branches;
next	1.27;

1.27
date	97.02.16.07.42.52;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	96.12.13.16.58.25;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	96.12.07.10.09.24;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	96.11.12.07.04.49;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	96.10.04.07.24.58;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.10.01.09.23.38;	author maja;	state Exp;
branches;
next	1.21;

1.21
date	96.09.30.11.28.35;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	96.09.24.11.36.55;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.09.24.04.35.18;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.09.22.10.17.10;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.09.21.13.19.03;	author pefo;	state Exp;
branches;
next	1.16;

1.16
date	96.09.16.02.21.59;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	96.08.10.12.14.19;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.06.25.01.21.57;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.06.19.13.24.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.06.19.13.22.57;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.06.17.07.55.59;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.06.17.06.57.06;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.06.12.08.02.44;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.06.08.03.54.56;	author dm;	state Exp;
branches;
next	1.7;

1.7
date	96.06.06.12.10.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.18.19.06.38;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	96.05.17.15.32.58;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.05.16.11.08.54;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.03.21.00.15.31;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.10.27.15.25.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.27;	author deraadt;	state Exp;
branches;
next	;

1.68.4.1
date	2000.10.06.20.40.26;	author jason;	state Exp;
branches;
next	;


desc
@@


1.226
log
@don't be silent on auto-allocation failure in write mode. ok millert@@ krw@@
@
text
@/*	$OpenBSD: disklabel.c,v 1.225 2017/03/04 07:26:42 otto Exp $	*/

/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Symmetric Computer Systems.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/sysctl.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/stat.h>
#include <sys/wait.h>
#define DKTYPENAMES
#include <sys/disklabel.h>

#include <ufs/ffs/fs.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <util.h>
#include <fstab.h>
#include "pathnames.h"
#include "extern.h"

/*
 * Disklabel: read and write disklabels.
 * The label is usually placed on one of the first sectors of the disk.
 * Many machines also place a bootstrap in the same area,
 * in which case the label is embedded in the bootstrap.
 * The bootstrap source must leave space at the proper offset
 * for the label on such machines.
 */

#ifndef BBSIZE
#define	BBSIZE	8192			/* size of boot area, with label */
#endif

char	*dkname, *specname, *fstabfile;
char	tmpfil[] = _PATH_TMPFILE;
char	*mountpoints[MAXPARTITIONS];
struct	disklabel lab;
enum {
	UNSPEC, EDIT, EDITOR, READ, RESTORE, WRITE
} op = UNSPEC;

int	aflag;
int	cflag;
int	dflag;
int	tflag;
int	uidflag;
int	verbose;
int	quiet;
int	donothing;
char	print_unit;

void	makedisktab(FILE *, struct disklabel *);
void	makelabel(char *, char *, struct disklabel *);
int	writelabel(int, struct disklabel *);
void	l_perror(char *);
int	edit(struct disklabel *, int);
int	editit(const char *);
char	*skip(char *);
char	*word(char *);
int	getasciilabel(FILE *, struct disklabel *);
int	cmplabel(struct disklabel *, struct disklabel *);
void	usage(void);
u_int64_t getnum(char *, u_int64_t, u_int64_t, const char **);

int64_t physmem;

void
getphysmem(void)
{
	size_t sz = sizeof(physmem);
	int mib[] = { CTL_HW, HW_PHYSMEM64 };

	if (sysctl(mib, 2, &physmem, &sz, NULL, (size_t)0) == -1)
		errx(4, "can't get mem size");
}

int
main(int argc, char *argv[])
{
	int ch, f, error = 0;
	FILE *t;
	char *autotable = NULL;

	getphysmem();

	while ((ch = getopt(argc, argv, "AEf:F:hRcdenp:tT:vw")) != -1)
		switch (ch) {
		case 'A':
			aflag = 1;
			break;
		case 'R':
			if (op != UNSPEC)
				usage();
			op = RESTORE;
			break;
		case 'c':
			cflag = 1;
			break;
		case 'd':
			dflag = 1;
			break;
		case 'e':
			if (op != UNSPEC)
				usage();
			op = EDIT;
			break;
		case 'E':
			if (op != UNSPEC)
				usage();
			op = EDITOR;
			break;
		case 'f':
			fstabfile = optarg;
			uidflag = 0;
			break;
		case 'F':
			fstabfile = optarg;
			uidflag = 1;
			break;
		case 'h':
			print_unit = '*';
			break;
		case 't':
			tflag = 1;
			break;
		case 'T':
			autotable = optarg;
			break;
		case 'w':
			if (op != UNSPEC)
				usage();
			op = WRITE;
			break;
		case 'p':
			if (strchr("bckmgtBCKMGT", optarg[0]) == NULL ||
			    optarg[1] != '\0') {
				fprintf(stderr, "Valid units are bckmgt\n");
				return 1;
			}
			print_unit = tolower((unsigned char)optarg[0]);
			break;
		case 'n':
			donothing = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		case '?':
		default:
			usage();
	}
	argc -= optind;
	argv += optind;

	if (op == UNSPEC)
		op = READ;

	if (argc < 1 || (fstabfile && !(op == EDITOR || op == RESTORE ||
		    aflag)))
		usage();

	if (argv[0] == NULL)
		usage();
	dkname = argv[0];
	f = opendev(dkname, (op == READ ? O_RDONLY : O_RDWR), OPENDEV_PART,
	    &specname);
	if (f < 0)
		err(4, "%s", specname);

	if (op != WRITE || aflag || dflag) {
		readlabel(f);

		if (op == EDIT || op == EDITOR || aflag) {
			if (pledge("stdio rpath wpath cpath disklabel proc "
			    "exec", NULL) == -1)
				err(1, "pledge");
		} else if (fstabfile) {
			if (pledge("stdio rpath wpath cpath disklabel", NULL)
			    == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio rpath wpath disklabel", NULL) == -1)
				err(1, "pledge");
		}

		if (autotable != NULL)
			parse_autotable(autotable);
		error = parselabel();
		if (op == WRITE && aflag && error)
			errx(1, "autoalloc failed");
	} else if (argc == 2 || argc == 3) {
		/* Ensure f is a disk device before pledging. */
		if (ioctl(f, DIOCGDINFO, &lab) < 0)
			err(4, "ioctl DIOCGDINFO");

		if (pledge("stdio rpath wpath disklabel", NULL) == -1)
			err(1, "pledge");

		makelabel(argv[1], argc == 3 ? argv[2] : NULL, &lab);
	} else
		usage();

	switch (op) {
	case EDIT:
		if (argc != 1)
			usage();
		error = edit(&lab, f);
		break;
	case EDITOR:
		if (argc != 1)
			usage();
		error = editor(f);
		break;
	case READ:
		if (argc != 1)
			usage();

		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");

		if (tflag)
			makedisktab(stdout, &lab);
		else
			display(stdout, &lab, print_unit, 1);
		error = checklabel(&lab);
		break;
	case RESTORE:
		if (argc < 2 || argc > 3)
			usage();
		if (!(t = fopen(argv[1], "r")))
			err(4, "%s", argv[1]);
		error = getasciilabel(t, &lab);
		memset(&lab.d_uid, 0, sizeof(lab.d_uid));
		if (error == 0) {
			error = writelabel(f, &lab);
			if (error == 0) {
				if (ioctl(f, DIOCGDINFO, &lab) < 0)
					err(4, "ioctl DIOCGDINFO");
				mpsave(&lab);
			}
		}
		fclose(t);
		break;
	case WRITE:
		error = checklabel(&lab);
		if (error == 0)
			error = writelabel(f, &lab);
		break;
	default:
		break;
	}
	return error;
}

/*
 * Construct a prototype disklabel from /etc/disktab.  As a side
 * effect, set the names of the primary and secondary boot files
 * if specified.
 */
void
makelabel(char *type, char *name, struct disklabel *lp)
{
	struct disklabel *dp;

	dp = getdiskbyname(type);
	if (dp == NULL)
		errx(1, "unknown disk type: %s", type);
	*lp = *dp;
	/* d_packname is union d_boot[01], so zero */
	memset(lp->d_packname, 0, sizeof(lp->d_packname));
	if (name)
		(void)strncpy(lp->d_packname, name, sizeof(lp->d_packname));
}


int
writelabel(int f, struct disklabel *lp)
{
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	if (!donothing) {
		if (ioctl(f, DIOCWDINFO, lp) < 0) {
			l_perror("ioctl DIOCWDINFO");
			return (1);
		}
	}

	/* Finally, write out any mount point information. */
	if (!donothing) {
		/* First refresh our copy of the current label to get UID. */
		if (ioctl(f, DIOCGDINFO, &lab) < 0)
			err(4, "ioctl DIOCGDINFO");
		mpsave(lp);
	}

	return (0);
}

void
l_perror(char *s)
{

	switch (errno) {
	case ESRCH:
		warnx("%s: No disk label on disk", s);
		break;
	case EINVAL:
		warnx("%s: Label magic number or checksum is wrong!\n"
		    "(disklabel or kernel is out of date?)", s);
		break;
	case EBUSY:
		warnx("%s: Open partition would move or shrink", s);
		break;
	case EXDEV:
		warnx("%s: Labeled partition or 'a' partition must start "
		    "at beginning of disk", s);
		break;
	default:
		warn("%s", s);
		break;
	}
}

/*
 * Fetch requested disklabel into 'lab' using ioctl.
 */
void
readlabel(int f)
{

	if (cflag && ioctl(f, DIOCRLDINFO) < 0)
		err(4, "ioctl DIOCRLDINFO");

	if ((op == RESTORE) || dflag || aflag) {
		if (ioctl(f, DIOCGPDINFO, &lab) < 0)
			err(4, "ioctl DIOCGPDINFO");
	} else {
		if (ioctl(f, DIOCGDINFO, &lab) < 0)
			err(4, "ioctl DIOCGDINFO");
	}
}

int
parselabel(void)
{
	char *partname, *partduid;
	struct fstab *fsent;
	int i;

	i = asprintf(&partname, "/dev/%s%c", dkname, 'a');
	if (i == -1)
		err(4, NULL);
	i = asprintf(&partduid,
	    "%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx.a",
            lab.d_uid[0], lab.d_uid[1], lab.d_uid[2], lab.d_uid[3],
            lab.d_uid[4], lab.d_uid[5], lab.d_uid[6], lab.d_uid[7]);
	if (i == -1)
		err(4, NULL);
	setfsent();
	for (i = 0; i < MAXPARTITIONS; i++) {
		partname[strlen(dkname) + 5] = 'a' + i;
		partduid[strlen(partduid) - 1] = 'a' + i;
		fsent = getfsspec(partname);
		if (fsent == NULL)
			fsent = getfsspec(partduid);
		if (fsent)
			mountpoints[i] = strdup(fsent->fs_file);
	}
	endfsent();
	free(partduid);
	free(partname);

	if (aflag)
		return editor_allocspace(&lab);
	return 0;
}

void
makedisktab(FILE *f, struct disklabel *lp)
{
	int i;
	struct partition *pp;

	if (lp->d_packname[0])
		(void)fprintf(f, "%.*s|", (int)sizeof(lp->d_packname),
		    lp->d_packname);
	if (lp->d_typename[0])
		(void)fprintf(f, "%.*s|", (int)sizeof(lp->d_typename),
		    lp->d_typename);
	(void)fputs("Automatically generated label:\\\n\t:dt=", f);
	if (lp->d_type < DKMAXTYPES)
		(void)fprintf(f, "%s:", dktypenames[lp->d_type]);
	else
		(void)fprintf(f, "unknown%d:", lp->d_type);

	(void)fprintf(f, "se#%u:", lp->d_secsize);
	(void)fprintf(f, "ns#%u:", lp->d_nsectors);
	(void)fprintf(f, "nt#%u:", lp->d_ntracks);
	(void)fprintf(f, "nc#%u:", lp->d_ncylinders);
	(void)fprintf(f, "sc#%u:", lp->d_secpercyl);
	(void)fprintf(f, "su#%llu:", DL_GETDSIZE(lp));

	/*
	 * XXX We do not print have disktab information yet for
	 * XXX DL_GETBSTART DL_GETBEND
	 */
	for (i = 0; i < NDDATA; i++)
		if (lp->d_drivedata[i])
			(void)fprintf(f, "d%d#%u", i, lp->d_drivedata[i]);
	pp = lp->d_partitions;
	for (i = 0; i < lp->d_npartitions; i++, pp++) {
		if (DL_GETPSIZE(pp)) {
			char c = 'a' + i;

			(void)fprintf(f, "\\\n\t:");
			(void)fprintf(f, "p%c#%llu:", c, DL_GETPSIZE(pp));
			(void)fprintf(f, "o%c#%llu:", c, DL_GETPOFFSET(pp));
			if (pp->p_fstype != FS_UNUSED) {
				if (pp->p_fstype < FSMAXTYPES)
					(void)fprintf(f, "t%c=%s:", c,
					    fstypenames[pp->p_fstype]);
				else
					(void)fprintf(f, "t%c=unknown%d:",
					    c, pp->p_fstype);
			}
			switch (pp->p_fstype) {

			case FS_UNUSED:
				break;

			case FS_BSDFFS:
				(void)fprintf(f, "b%c#%u:", c,
				    DISKLABELV1_FFS_BSIZE(pp->p_fragblock));
				(void)fprintf(f, "f%c#%u:", c,
				    DISKLABELV1_FFS_FSIZE(pp->p_fragblock));
				break;

			default:
				break;
			}
		}
	}
	(void)fputc('\n', f);
	(void)fflush(f);
}

double
scale(u_int64_t sz, char unit, struct disklabel *lp)
{
	double fsz;

	fsz = (double)sz * lp->d_secsize;

	switch (unit) {
	case 'B':
		return fsz;
	case 'C':
		return fsz / lp->d_secsize / lp->d_secpercyl;
	case 'K':
		return fsz / 1024;
	case 'M':
		return fsz / (1024 * 1024);
	case 'G':
		return fsz / (1024 * 1024 * 1024);
	case 'T':
		return fsz / (1024ULL * 1024 * 1024 * 1024);
	default:
		return -1.0;
	}
}

/*
 * Display a particular partition.
 */
void
display_partition(FILE *f, struct disklabel *lp, int i, char unit)
{
	volatile struct partition *pp = &lp->d_partitions[i];
	double p_size;

	p_size = scale(DL_GETPSIZE(pp), unit, lp);
	if (DL_GETPSIZE(pp)) {
		u_int32_t frag = DISKLABELV1_FFS_FRAG(pp->p_fragblock);
		u_int32_t fsize = DISKLABELV1_FFS_FSIZE(pp->p_fragblock);

		if (p_size < 0)
			fprintf(f, "  %c: %16llu %16llu ", 'a' + i,
			    DL_GETPSIZE(pp), DL_GETPOFFSET(pp));
		else
			fprintf(f, "  %c: %15.*f%c %16llu ", 'a' + i,
			    unit == 'B' ? 0 : 1, p_size, unit,
			    DL_GETPOFFSET(pp));
		if (pp->p_fstype < FSMAXTYPES)
			fprintf(f, "%7.7s", fstypenames[pp->p_fstype]);
		else
			fprintf(f, "%7d", pp->p_fstype);

		switch (pp->p_fstype) {
		case FS_BSDFFS:
			fprintf(f, "  %5u %5u %5hu ",
			    fsize, fsize * frag,
			    pp->p_cpg);
			break;
		default:
			fprintf(f, "%20.20s", "");
			break;
		}

		if (mountpoints[i] != NULL)
			fprintf(f, "# %s", mountpoints[i]);
		putc('\n', f);
	}
}

char
canonical_unit(struct disklabel *lp, char unit)
{
	struct partition *pp;
	u_int64_t small;
	int i;

	if (unit == '*') {
		small = DL_GETDSIZE(lp);
		pp = &lp->d_partitions[0];
		for (i = 0; i < lp->d_npartitions; i++, pp++)
			if (DL_GETPSIZE(pp) > 0 && DL_GETPSIZE(pp) < small)
				small = DL_GETPSIZE(pp);
		if (small < DL_BLKTOSEC(lp, MEG(1)))
			unit = 'K';
		else if (small < DL_BLKTOSEC(lp, MEG(1024)))
			unit = 'M';
		else if (small < DL_BLKTOSEC(lp, GIG(1024)))
			unit = 'G';
		else
			unit = 'T';
	}
	unit = toupper((unsigned char)unit);

	return (unit);
}

void
display(FILE *f, struct disklabel *lp, char unit, int all)
{
	int i, j;
	double d;

	unit = canonical_unit(lp, unit);

	fprintf(f, "# %s:\n", specname);

	if (lp->d_type < DKMAXTYPES)
		fprintf(f, "type: %s\n", dktypenames[lp->d_type]);
	else
		fprintf(f, "type: %d\n", lp->d_type);
	fprintf(f, "disk: %.*s\n", (int)sizeof(lp->d_typename),
	    lp->d_typename);
	fprintf(f, "label: %.*s\n", (int)sizeof(lp->d_packname),
	    lp->d_packname);
	fprintf(f, "duid: %02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\n",
            lp->d_uid[0], lp->d_uid[1], lp->d_uid[2], lp->d_uid[3],
            lp->d_uid[4], lp->d_uid[5], lp->d_uid[6], lp->d_uid[7]);
	fprintf(f, "flags:");
	if (lp->d_flags & D_BADSECT)
		fprintf(f, " badsect");
	if (lp->d_flags & D_VENDOR)
		fprintf(f, " vendor");
	putc('\n', f);

	fprintf(f, "bytes/sector: %u\n", lp->d_secsize);
	fprintf(f, "sectors/track: %u\n", lp->d_nsectors);
	fprintf(f, "tracks/cylinder: %u\n", lp->d_ntracks);
	fprintf(f, "sectors/cylinder: %u\n", lp->d_secpercyl);
	fprintf(f, "cylinders: %u\n", lp->d_ncylinders);
	fprintf(f, "total sectors: %llu", DL_GETDSIZE(lp));
	d = scale(DL_GETDSIZE(lp), unit, lp);
	if (d > 0)
		fprintf(f, " # total bytes: %.*f%c", unit == 'B' ? 0 : 1,
		    d, unit);
	fprintf(f, "\n");

	fprintf(f, "boundstart: %llu\n", DL_GETBSTART(lp));
	fprintf(f, "boundend: %llu\n", DL_GETBEND(lp));
	fprintf(f, "drivedata: ");
	for (i = NDDATA - 1; i >= 0; i--)
		if (lp->d_drivedata[i])
			break;
	if (i < 0)
		i = 0;
	for (j = 0; j <= i; j++)
		fprintf(f, "%d ", lp->d_drivedata[j]);
	fprintf(f, "\n");
	if (all) {
		fprintf(f, "\n%hu partitions:\n", lp->d_npartitions);
		fprintf(f, "#    %16.16s %16.16s  fstype [fsize bsize   cpg]\n",
		    "size", "offset");
		for (i = 0; i < lp->d_npartitions; i++)
			display_partition(f, lp, i, unit);
	}
	fflush(f);
}

int
edit(struct disklabel *lp, int f)
{
	int first, ch, fd, error = 0;
	struct disklabel label;
	FILE *fp;
	u_int64_t total_sectors, starting_sector, ending_sector;

	if ((fd = mkstemp(tmpfil)) == -1 || (fp = fdopen(fd, "w")) == NULL) {
		warn("%s", tmpfil);
		if (fd != -1)
			close(fd);
		return (1);
	}
	display(fp, lp, 0, 1);
	fprintf(fp, "\n# Notes:\n");
	fprintf(fp,
"# Up to 16 partitions are valid, named from 'a' to 'p'.  Partition 'a' is\n"
"# your root filesystem, 'b' is your swap, and 'c' should cover your whole\n"
"# disk. Any other partition is free for any use.  'size' and 'offset' are\n"
"# in 512-byte blocks. fstype should be '4.2BSD', 'swap', or 'none' or some\n"
"# other values.  fsize/bsize/cpg should typically be '2048 16384 16' for a\n"
"# 4.2BSD filesystem (or '512 4096 16' except on alpha, sun4, ...)\n");
	fclose(fp);
	for (;;) {
		if (editit(tmpfil) == -1)
			break;
		fp = fopen(tmpfil, "r");
		if (fp == NULL) {
			warn("%s", tmpfil);
			break;
		}
		/* Get values set by OS and not the label. */
		if (ioctl(f, DIOCGPDINFO, &label) < 0)
			err(4, "ioctl DIOCGPDINFO");
		ending_sector = DL_GETBEND(&label);
		starting_sector = DL_GETBSTART(&label);
		total_sectors = DL_GETDSIZE(&label);
		error = getasciilabel(fp, &label);
		DL_SETBEND(&label, ending_sector);
		DL_SETBSTART(&label, starting_sector);
		DL_SETDSIZE(&label, total_sectors);

		if (error == 0) {
			if (cmplabel(lp, &label) == 0) {
				puts("No changes.");
				fclose(fp);
				(void) unlink(tmpfil);
				return (0);
			}
			*lp = label;
			if (writelabel(f, lp) == 0) {
				fclose(fp);
				(void) unlink(tmpfil);
				return (0);
			}
		}
		fclose(fp);
		printf("re-edit the label? [y]: ");
		fflush(stdout);
		first = ch = getchar();
		while (ch != '\n' && ch != EOF)
			ch = getchar();
		if (first == 'n' || first == 'N')
			break;
	}
	(void)unlink(tmpfil);
	return (1);
}

/*
 * Execute an editor on the specified pathname, which is interpreted
 * from the shell.  This means flags may be included.
 *
 * Returns -1 on error, or the exit value on success.
 */
int
editit(const char *pathname)
{
	char *argp[] = {"sh", "-c", NULL, NULL}, *ed, *p;
	sig_t sighup, sigint, sigquit, sigchld;
	pid_t pid;
	int saved_errno, st, ret = -1;

	ed = getenv("VISUAL");
	if (ed == NULL || ed[0] == '\0')
		ed = getenv("EDITOR");
	if (ed == NULL || ed[0] == '\0')
		ed = _PATH_VI;
	if (asprintf(&p, "%s %s", ed, pathname) == -1)
		return (-1);
	argp[2] = p;

	sighup = signal(SIGHUP, SIG_IGN);
	sigint = signal(SIGINT, SIG_IGN);
	sigquit = signal(SIGQUIT, SIG_IGN);
	sigchld = signal(SIGCHLD, SIG_DFL);
	if ((pid = fork()) == -1)
		goto fail;
	if (pid == 0) {
		execv(_PATH_BSHELL, argp);
		_exit(127);
	}
	while (waitpid(pid, &st, 0) == -1)
		if (errno != EINTR)
			goto fail;
	if (!WIFEXITED(st))
		errno = EINTR;
	else
		ret = WEXITSTATUS(st);

 fail:
	saved_errno = errno;
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	(void)signal(SIGCHLD, sigchld);
	free(p);
	errno = saved_errno;
	return (ret);
}

char *
skip(char *cp)
{

	cp += strspn(cp, " \t");
	if (*cp == '\0')
		return (NULL);
	return (cp);
}

char *
word(char *cp)
{

	cp += strcspn(cp, " \t");
	if (*cp == '\0')
		return (NULL);
	*cp++ = '\0';
	cp += strspn(cp, " \t");
	if (*cp == '\0')
		return (NULL);
	return (cp);
}

/* Base the max value on the sizeof of the value we are reading */
#define GETNUM(field, nptr, min, errstr)				\
	    getnum((nptr), (min),					\
		sizeof(field) == 8 ? LLONG_MAX :			\
		(sizeof(field) == 4 ? UINT_MAX :			\
		(sizeof(field) == 2 ? USHRT_MAX : UCHAR_MAX)),  (errstr))

u_int64_t
getnum(char *nptr, u_int64_t min, u_int64_t max, const char **errstr)
{
	char *p, c;
	u_int64_t ret;

	for (p = nptr; *p != '\0' && !isspace((unsigned char)*p); p++)
		;
	c = *p;
	*p = '\0';
	ret = strtonum(nptr, min, max, errstr);
	*p = c;
	return (ret);
}

int
duid_parse(struct disklabel *lp, char *s)
{
	u_char duid[8];
	char c;
	int i;

	if (strlen(s) != 16)
		return -1;

	memset(duid, 0, sizeof(duid));
	for (i = 0; i < 16; i++) {
		c = s[i];
		if (c >= '0' && c <= '9')
			c -= '0';
		else if (c >= 'a' && c <= 'f')
			c -= ('a' - 10);
		else if (c >= 'A' && c <= 'F')
			c -= ('A' - 10);
		else
			return -1;
		duid[i / 2] <<= 4;
		duid[i / 2] |= c & 0xf;
	}

	memcpy(lp->d_uid, &duid, sizeof(lp->d_uid));
	return 0;
}

/*
 * Read an ascii label in from FILE f,
 * in the same format as that put out by display(),
 * and fill in lp.
 */
int
getasciilabel(FILE *f, struct disklabel *lp)
{
	char **cpp, *cp;
	const char *errstr;
	struct partition *pp;
	char *mp, *tp, *s, line[BUFSIZ];
	char **omountpoints = NULL;
	int lineno = 0, errors = 0;
	u_int32_t v, fsize;
	u_int64_t lv;
	unsigned int part;

	lp->d_version = 1;
	lp->d_bbsize = BBSIZE;				/* XXX */
	lp->d_sbsize = SBSIZE;				/* XXX */

	if (!(omountpoints = calloc(MAXPARTITIONS, sizeof(char *))))
		errx(4, "out of memory");

	mpcopy(omountpoints, mountpoints);
	for (part = 0; part < MAXPARTITIONS; part++) {
		free(mountpoints[part]);
		mountpoints[part] = NULL;
	}

	while (fgets(line, sizeof(line), f)) {
		lineno++;
		mp = NULL;
		if ((cp = strpbrk(line, "\r\n")))
			*cp = '\0';
		if ((cp = strpbrk(line, "#"))) {
			*cp = '\0';
			mp = skip(cp+1);
			if (mp && *mp != '/')
				mp = NULL;
		}
		cp = skip(line);
		if (cp == NULL)
			continue;
		tp = strchr(cp, ':');
		if (tp == NULL) {
			warnx("line %d: syntax error", lineno);
			errors++;
			continue;
		}
		*tp++ = '\0', tp = skip(tp);
		if (!strcmp(cp, "type")) {
			if (tp == NULL)
				tp = "unknown";
			else if (strcasecmp(tp, "IDE") == 0)
				tp = "ESDI";
			cpp = dktypenames;
			for (; cpp < &dktypenames[DKMAXTYPES]; cpp++)
				if ((s = *cpp) && !strcasecmp(s, tp)) {
					lp->d_type = cpp - dktypenames;
					goto next;
				}
			v = GETNUM(lp->d_type, tp, 0, &errstr);
			if (errstr || v >= DKMAXTYPES)
				warnx("line %d: warning, unknown disk type: %s",
				    lineno, tp);
			lp->d_type = v;
			continue;
		}
		if (!strcmp(cp, "flags")) {
			for (v = 0; (cp = tp) && *cp != '\0';) {
				tp = word(cp);
				if (!strcmp(cp, "badsect"))
					v |= D_BADSECT;
				else if (!strcmp(cp, "vendor"))
					v |= D_VENDOR;
				else {
					warnx("line %d: bad flag: %s",
					    lineno, cp);
					errors++;
				}
			}
			lp->d_flags = v;
			continue;
		}
		if (!strcmp(cp, "drivedata")) {
			int i;

			for (i = 0; (cp = tp) && *cp != '\0' && i < NDDATA;) {
				v = GETNUM(lp->d_drivedata[i], cp, 0, &errstr);
				if (errstr)
					warnx("line %d: bad drivedata %s",
					   lineno, cp);
				lp->d_drivedata[i++] = v;
				tp = word(cp);
			}
			continue;
		}
		if (sscanf(cp, "%d partitions", &v) == 1) {
			if (v == 0 || v > MAXPARTITIONS) {
				warnx("line %d: bad # of partitions", lineno);
				lp->d_npartitions = MAXPARTITIONS;
				errors++;
			} else
				lp->d_npartitions = v;
			continue;
		}
		if (tp == NULL)
			tp = "";
		if (!strcmp(cp, "disk")) {
			strncpy(lp->d_typename, tp, sizeof (lp->d_typename));
			continue;
		}
		if (!strcmp(cp, "label")) {
			strncpy(lp->d_packname, tp, sizeof (lp->d_packname));
			continue;
		}
		if (!strcmp(cp, "duid")) {
			if (duid_parse(lp, tp) != 0) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			}
			continue;
		}
		if (!strcmp(cp, "bytes/sector")) {
			v = GETNUM(lp->d_secsize, tp, 1, &errstr);
			if (errstr || (v % 512) != 0) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_secsize = v;
			continue;
		}
		if (!strcmp(cp, "sectors/track")) {
			v = GETNUM(lp->d_nsectors, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_nsectors = v;
			continue;
		}
		if (!strcmp(cp, "sectors/cylinder")) {
			v = GETNUM(lp->d_secpercyl, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_secpercyl = v;
			continue;
		}
		if (!strcmp(cp, "tracks/cylinder")) {
			v = GETNUM(lp->d_ntracks, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_ntracks = v;
			continue;
		}
		if (!strcmp(cp, "cylinders")) {
			v = GETNUM(lp->d_ncylinders, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_ncylinders = v;
			continue;
		}

		/* Ignore fields that are no longer in the disklabel. */
		if (!strcmp(cp, "rpm") ||
		    !strcmp(cp, "interleave") ||
		    !strcmp(cp, "trackskew") ||
		    !strcmp(cp, "cylinderskew") ||
		    !strcmp(cp, "headswitch") ||
		    !strcmp(cp, "track-to-track seek"))
			continue;

		/* Ignore fields that are forcibly set when label is read. */
		if (!strcmp(cp, "total sectors") ||
		    !strcmp(cp, "boundstart") ||
		    !strcmp(cp, "boundend"))
			continue;

		if ('a' <= *cp && *cp <= 'z' && cp[1] == '\0') {
			unsigned int part = *cp - 'a';

			if (part >= lp->d_npartitions) {
				if (part >= MAXPARTITIONS) {
					warnx("line %d: bad partition name: %s",
					    lineno, cp);
					errors++;
					continue;
				} else {
					lp->d_npartitions = part + 1;
				}
			}
			pp = &lp->d_partitions[part];
#define NXTNUM(n, field, errstr) { \
	if (tp == NULL) {					\
		warnx("line %d: too few fields", lineno);	\
		errors++;					\
		break;						\
	} else							\
		cp = tp, tp = word(cp), (n) = GETNUM(field, cp, 0, errstr); \
}
			NXTNUM(lv, lv, &errstr);
			if (errstr) {
				warnx("line %d: bad partition size: %s",
				    lineno, cp);
				errors++;
			} else {
				DL_SETPSIZE(pp, lv);
			}
			NXTNUM(lv, lv, &errstr);
			if (errstr) {
				warnx("line %d: bad partition offset: %s",
				    lineno, cp);
				errors++;
			} else {
				DL_SETPOFFSET(pp, lv);
			}
			if (tp == NULL) {
				pp->p_fstype = FS_UNUSED;
				goto gottype;
			}
			cp = tp, tp = word(cp);
			cpp = fstypenames;
			for (; cpp < &fstypenames[FSMAXTYPES]; cpp++)
				if ((s = *cpp) && !strcasecmp(s, cp)) {
					pp->p_fstype = cpp - fstypenames;
					goto gottype;
				}
			if (isdigit((unsigned char)*cp))
				v = GETNUM(pp->p_fstype, cp, 0, &errstr);
			else
				v = FSMAXTYPES;
			if (errstr || v >= FSMAXTYPES) {
				warnx("line %d: warning, unknown filesystem type: %s",
				    lineno, cp);
				v = FS_UNUSED;
			}
			pp->p_fstype = v;
	gottype:
			switch (pp->p_fstype) {

			case FS_UNUSED:				/* XXX */
				if (tp == NULL)	/* ok to skip fsize/bsize */
					break;
				NXTNUM(fsize, fsize, &errstr);
				if (fsize == 0)
					break;
				NXTNUM(v, v, &errstr);
				pp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(fsize, v / fsize);
				break;

			case FS_BSDFFS:
				NXTNUM(fsize, fsize, &errstr);
				if (fsize == 0)
					break;
				NXTNUM(v, v, &errstr);
				pp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(fsize, v / fsize);
				NXTNUM(pp->p_cpg, pp->p_cpg, &errstr);
				break;

			default:
				break;
			}
			if (mp)
				mountpoints[part] = strdup(mp);
			continue;
		}
		warnx("line %d: unknown field: %s", lineno, cp);
		errors++;
	next:
		;
	}
	errors += checklabel(lp);

	if (errors > 0)
		mpcopy(mountpoints, omountpoints);
	mpfree(omountpoints);

	return (errors > 0);
}

/*
 * Check disklabel for errors and fill in
 * derived fields according to supplied values.
 */
int
checklabel(struct disklabel *lp)
{
	struct partition *pp;
	int i, errors = 0;
	char part;

	if (lp->d_secsize == 0) {
		warnx("sector size %d", lp->d_secsize);
		return (1);
	}
	if (lp->d_nsectors == 0) {
		warnx("sectors/track %d", lp->d_nsectors);
		return (1);
	}
	if (lp->d_ntracks == 0) {
		warnx("tracks/cylinder %d", lp->d_ntracks);
		return (1);
	}
	if  (lp->d_ncylinders == 0) {
		warnx("cylinders/unit %d", lp->d_ncylinders);
		errors++;
	}
	if (lp->d_secpercyl == 0)
		lp->d_secpercyl = lp->d_nsectors * lp->d_ntracks;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, (u_int64_t)lp->d_secpercyl * lp->d_ncylinders);
	if (lp->d_bbsize == 0) {
		warnx("boot block size %d", lp->d_bbsize);
		errors++;
	} else if (lp->d_bbsize % lp->d_secsize)
		warnx("warning, boot block size %% sector-size != 0");
	if (lp->d_sbsize == 0) {
		warnx("super block size %d", lp->d_sbsize);
		errors++;
	} else if (lp->d_sbsize % lp->d_secsize)
		warnx("warning, super block size %% sector-size != 0");
	if (lp->d_npartitions > MAXPARTITIONS)
		warnx("warning, number of partitions (%d) > MAXPARTITIONS (%d)",
		    lp->d_npartitions, MAXPARTITIONS);
	for (i = 0; i < lp->d_npartitions; i++) {
		part = 'a' + i;
		pp = &lp->d_partitions[i];
		if (DL_GETPSIZE(pp) == 0 && DL_GETPOFFSET(pp) != 0)
			warnx("warning, partition %c: size 0, but offset %llu",
			    part, DL_GETPOFFSET(pp));
#ifdef SUN_CYLCHECK
		if (lp->d_flags & D_VENDOR) {
			if (i != RAW_PART && DL_GETPSIZE(pp) % lp->d_secpercyl)
				warnx("warning, partition %c: size %% "
				    "cylinder-size != 0", part);
			if (i != RAW_PART && DL_GETPOFFSET(pp) % lp->d_secpercyl)
				warnx("warning, partition %c: offset %% "
				    "cylinder-size != 0", part);
		}
#endif
#ifdef SUN_AAT0
		if ((lp->d_flags & D_VENDOR) &&
		    i == 0 && DL_GETPSIZE(pp) != 0 && DL_GETPOFFSET(pp) != 0) {
			warnx("this architecture requires partition 'a' to "
			    "start at sector 0");
			errors++;
		}
#endif
		if (DL_GETPOFFSET(pp) > DL_GETDSIZE(lp)) {
			warnx("partition %c: offset past end of unit", part);
			errors++;
		}
		if (DL_GETPOFFSET(pp) + DL_GETPSIZE(pp) > DL_GETDSIZE(lp)) {
			warnx("partition %c: partition extends past end of unit",
			    part);
			errors++;
		}
#if 0
		if (pp->p_frag == 0 && pp->p_fsize != 0) {
			warnx("partition %c: block size < fragment size", part);
			errors++;
		}
#endif
	}
	for (; i < MAXPARTITIONS; i++) {
		part = 'a' + i;
		pp = &lp->d_partitions[i];
		if (DL_GETPSIZE(pp) || DL_GETPOFFSET(pp))
			warnx("warning, unused partition %c: size %llu "
			    "offset %llu", part, DL_GETPSIZE(pp),
			    DL_GETPOFFSET(pp));
	}
	return (errors > 0);
}

int
cmplabel(struct disklabel *lp1, struct disklabel *lp2)
{
	struct disklabel lab1 = *lp1;
	struct disklabel lab2 = *lp2;

	/* We don't compare these fields */
	lab1.d_magic = lab2.d_magic;
	lab1.d_magic2 = lab2.d_magic2;
	lab1.d_checksum = lab2.d_checksum;
	lab1.d_bbsize = lab2.d_bbsize;
	lab1.d_sbsize = lab2.d_sbsize;
	lab1.d_bstart = lab2.d_bstart;
	lab1.d_bstarth = lab2.d_bstarth;
	lab1.d_bend = lab2.d_bend;
	lab1.d_bendh = lab2.d_bendh;

	return (memcmp(&lab1, &lab2, sizeof(struct disklabel)));
}

void
usage(void)
{
	fprintf(stderr,
	    "usage: disklabel    [-Acdtv] [-h | -p unit] [-T file] disk\t(read)\n");
	fprintf(stderr,
	    "       disklabel -w [-Acdnv] [-T file] disk disktype [packid]\t(write)\n");
	fprintf(stderr,
	    "       disklabel -e [-Acdnv] [-T file] disk\t\t\t(edit)\n");
	fprintf(stderr,
	    "       disklabel -E [-Acdnv] [-F|-f file] [-T file] disk\t(simple editor)"
	    "\n");
	fprintf(stderr,
	    "       disklabel -R [-nv] [-F|-f file] disk protofile\t\t(restore)\n\n");
	fprintf(stderr,
	    "`disk' may be of the form: sd0 or /dev/rsd0%c.\n", 'a'+RAW_PART);
	fprintf(stderr,
	    "`disktype' is an entry from %s, see disktab(5) for more info.\n",
	    DISKTAB);
	fprintf(stderr,
	    "`packid' is an identification string for the device.\n");
	fprintf(stderr,
	    "`protofile' is the output from the read cmd form; -R is powerful.\n");
#ifdef SEEALSO
	fprintf(stderr,
	    "For procedures specific to this architecture see: %s\n", SEEALSO);
#endif
	exit(1);
}
@


1.225
log
@Allow R (resize auto-partition) after A as well as when started with -A.
This ability was lost in editor.c 1.264; noted by ajacoutot@@; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.224 2016/09/04 11:35:30 bluhm Exp $	*/
d228 3
a230 1
		parselabel();
d385 1
a385 1
void
d416 2
a417 1
		editor_allocspace(&lab);
@


1.224
log
@After aligning the cpg field, non ffs partitions were not displayed
aligned anymore.  Put one more space in front of the "# none" mount
point output.
OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.223 2016/09/02 10:47:17 otto Exp $	*/
d88 1
@


1.223
log
@Allow editing cpg in expert mode and align the cpg field properly
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.222 2016/06/19 13:42:56 tb Exp $	*/
d543 1
a543 1
			fprintf(f, "%19.19s", "");
@


1.222
log
@Split readlabel() into two functions, readlabel() and parselabel(), and
pledge in-between the two funtion calls.  The new readlabel() only does
a DIOC*DINFO ioctl, making sure the fd points to a disk, while
parselabel() does the scary string manipulations.  In the makelabel()
code path do an early DIOCGDINFO before pledge.  This fixes yet another
pledge problem (disklabel -w /dev/tty floppy576).

Some of this was discussed with beck.

ok semarie, earlier version ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.221 2016/06/13 09:54:01 jsg Exp $	*/
d538 1
a538 1
			fprintf(f, "  %5u %5u %4hu ",
d633 1
a633 1
		fprintf(f, "#    %16.16s %16.16s  fstype [fsize bsize  cpg]\n",
@


1.221
log
@correct pledge for disklabel -R -[fF]
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.220 2016/06/01 16:51:54 tb Exp $	*/
d209 15
a223 2
	if (autotable != NULL)
		parse_autotable(autotable);
d225 7
a231 6
	if (op != WRITE || aflag || dflag)
		readlabel(f);
	else if (argc == 2 || argc == 3)
		makelabel(argv[1], argc == 3 ? argv[2] : NULL, &lab);
	else
		usage();
a232 7
	if (op == EDIT || op == EDITOR || aflag) {
		if (pledge("stdio rpath wpath cpath disklabel proc exec", NULL) == -1)
			err(1, "pledge");
	} else if (fstabfile) {
		if (pledge("stdio rpath wpath cpath disklabel", NULL) == -1)
			err(1, "pledge");
	} else {
d235 4
a238 1
	}
a368 3
	char *partname, *partduid;
	struct fstab *fsent;
	int i;
d380 8
@


1.220
log
@Fix automatic disk allocation based on a template which I broke in the
previous commit.  readlabel() calls editor_allocspace() which will use
the default label unless a template was provided beforehand.  Thus,
call parse_autolabel() before redlabel().

Problem found and fix provided by Mark Patruck, thanks!

Fix asap, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.219 2016/05/29 17:02:21 tb Exp $	*/
d221 3
@


1.219
log
@Refactor and clean up the logic before pledge a bit and fix pledge
fallout related to pledge disklabel (e.g. 'disklabel /dev/tty').

- Allow 'disklabel sdN' again for non-root users.
- Make sure at least one DIO* ioctl comes before pledge "disklabel"
- Fix the op == WRITE logic that broke 'make release' in -r2.217

Based on -r2.17 from beck.

ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.218 2016/05/28 23:38:30 deraadt Exp $	*/
d209 3
a225 3

	if (autotable != NULL)
		parse_autotable(autotable);
@


1.218
log
@back out previous; -wAT template vnd0 fails
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.216 2016/05/28 16:00:19 beck Exp $	*/
d177 1
a177 1
				exit(1);
d194 7
d209 7
a223 7
	if (op == UNSPEC)
		op = READ;

	if (argc < 1 || (fstabfile && !(op == EDITOR || op == RESTORE ||
		    aflag)))
		usage();

a230 1
		readlabel(f);
a235 1
		readlabel(f);
a240 1
		readlabel(f);
a253 1
		readlabel(f);
a268 6
		if (dflag || aflag) {
			readlabel(f);
		} else if (argc < 2 || argc > 3)
			usage();
		else
			makelabel(argv[1], argc == 3 ? argv[2] : NULL, &lab);
d276 1
a276 1
	exit(error);
@


1.217
log
@host readlabel() above the pledge so we can avoid pledge violations
when the provided device is not a disk
ok tb@@
@
text
@a200 1
	readlabel(f);
d224 1
d230 1
d236 1
d250 1
d266 3
a268 1
		if (!(dflag || aflag) && (argc < 2 || argc > 3))
@


1.216
log
@fix crash if filename not provided
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.215 2016/05/28 15:46:43 beck Exp $	*/
d201 1
a224 1
		readlabel(f);
a229 1
		readlabel(f);
a234 1
		readlabel(f);
a247 1
		readlabel(f);
d263 1
a263 3
		if (dflag || aflag) {
			readlabel(f);
		} else if (argc < 2 || argc > 3)
@


1.215
log
@Hoist the opendev() call before the pledge because it can ioctl() when
the provided path is bogus or not a device.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.214 2015/11/25 17:17:38 krw Exp $	*/
d194 2
@


1.214
log
@-A needs cflag too. Noted by sthen@@ during install.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.213 2015/11/24 01:17:03 krw Exp $	*/
d194 6
a213 6

	dkname = argv[0];
	f = opendev(dkname, (op == READ ? O_RDONLY : O_RDWR), OPENDEV_PART,
	    &specname);
	if (f < 0)
		err(4, "%s", specname);
@


1.213
log
@Need 'cpath' for op == EDITOR, as '-F' to write out the ascii label in
an arbitrary location is a possibility.

Suggested by & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.212 2015/11/23 19:19:29 deraadt Exp $	*/
d194 1
a194 1
	if (op == EDIT || op == EDITOR) {
@


1.212
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.211 2015/10/17 13:27:08 krw Exp $	*/
d194 1
a194 1
	if (op == EDIT) {
a196 4
	} else if (op == EDITOR) {
		/* "proc exec" for man page in editor */
		if (pledge("stdio rpath wpath disklabel proc exec", NULL) == -1)
			err(1, "pledge");
d200 1
a200 1
	}	
@


1.211
log
@NUMBOOT is dead! Nuke the variables and abstractions that were used
to build boot blocks.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.210 2015/10/15 19:31:15 miod Exp $	*/
d36 1
d104 12
d123 2
d193 12
@


1.210
log
@Remove disklabel -B (NUMBOOT) support. All the platforms which used to need
it are now using MI installboot for that purpose.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.209 2015/10/11 04:36:22 deraadt Exp $	*/
a76 2
char	bootarea[BBSIZE];

d92 1
a92 1
int	writelabel(int, char *, struct disklabel *);
a106 1
	struct disklabel *lp;
a225 2
		lp = makebootarea(bootarea, &lab);
		*lp = lab;
d228 2
a229 2
		error = getasciilabel(t, lp);
		bzero(lp->d_uid, sizeof(lp->d_uid));
d231 1
a231 1
			error = writelabel(f, bootarea, lp);
a246 2
		lp = makebootarea(bootarea, &lab);
		*lp = lab;
d249 1
a249 1
			error = writelabel(f, bootarea, lp);
d279 1
a279 1
writelabel(int f, char *boot, struct disklabel *lp)
a375 28
/*
 * Construct a bootarea (d_bbsize bytes) in the specified buffer ``boot''
 * Returns a pointer to the disklabel portion of the bootarea.
 */
struct disklabel *
makebootarea(char *boot, struct disklabel *dp)
{
	struct disklabel *lp;
	char *p;

	/* XXX */
	if (dp->d_secsize == 0) {
		dp->d_secsize = DEV_BSIZE;
		dp->d_bbsize = BBSIZE;
	}
	lp = (struct disklabel *)
	    (boot + (LABELSECTOR * dp->d_secsize) + LABELOFFSET);
	memset(lp, 0, sizeof *lp);
	/*
	 * Make sure no part of the bootstrap is written in the area
	 * reserved for the label.
	 */
	for (p = (char *)lp; p < (char *)lp + sizeof(struct disklabel); p++)
		if (*p)
			errx(2, "Bootstrap doesn't leave room for disk label");
	return (lp);
}

d652 1
a652 1
			if (writelabel(f, bootarea, lp) == 0) {
@


1.209
log
@If only displaying the disklabel (the normal thing to do against potentially
unknown disks...), after opening & reading the disklabel, pledge "stdio"
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.208 2015/10/05 12:49:58 krw Exp $	*/
a72 4
#ifndef NUMBOOT
#define NUMBOOT 0
#endif

a78 10
#if NUMBOOT > 0
char	namebuf[BBSIZE], *np = namebuf;
int	installboot;	/* non-zero if we should install a boot program */
char	*bootbuf;	/* pointer to buffer with remainder of boot prog */
int	bootsize;	/* size of remaining boot program */
char	*xxboot;	/* primary boot */
char	boot0[MAXPATHLEN];
void	setbootflag(struct disklabel *);
#endif

d80 1
a80 1
	UNSPEC, EDIT, EDITOR, READ, RESTORE, WRITE, WRITEBOOT
d113 1
a113 1
	while ((ch = getopt(argc, argv, "ABEf:F:hRb:cdenp:tT:vw")) != -1)
a117 8
#if NUMBOOT > 0
		case 'B':
			installboot = 1;
			break;
		case 'b':
			xxboot = optarg;
			break;
#endif
a181 9
#if NUMBOOT > 0
	if (installboot) {
		if (op == UNSPEC)
			op = WRITEBOOT;
	} else {
		if (op == UNSPEC)
			op = READ;
	}
#else
a183 1
#endif
a228 4
#if NUMBOOT > 0
		if (installboot && argc == 3)
			makelabel(argv[2], NULL, &lab);
#endif
a257 17
#if NUMBOOT > 0
	case WRITEBOOT:
	{
		struct disklabel tlab;

		readlabel(f);
		tlab = lab;
		if (argc == 2)
			makelabel(argv[1], NULL, &lab);
		lp = makebootarea(bootarea, &lab);
		*lp = tlab;
		error = checklabel(&lab);
		if (error == 0)
			error = writelabel(f, bootarea, lp);
		break;
	}
#endif
a277 17
#if NUMBOOT > 0
	/*
	 * Set bootstrap name(s).
	 * 1. If set from command line, use those,
	 * 2. otherwise, check if disktab specifies them (b0 or b1),
	 * 3. otherwise, makebootarea() will choose ones based on the name
	 *    of the disk special file. E.g. /dev/ra0 -> raboot, bootra
	 */
	if (!xxboot && lp->d_boot0) {
		if (*lp->d_boot0 != '/')
			(void)snprintf(boot0, sizeof boot0, "%s%s",
			    _PATH_BOOTDIR, lp->d_boot0);
		else
			(void)strlcpy(boot0, lp->d_boot0, sizeof boot0);
		xxboot = boot0;
	}
#endif
a287 3
#if NUMBOOT > 0
	setbootflag(lp);
#endif
a291 36
#if NUMBOOT > 0
	if (installboot) {
		/*
		 * First set the kernel disk label,
		 * then write a label to the raw disk.
		 * If the SDINFO ioctl fails because it is unimplemented,
		 * keep going; otherwise, the kernel consistency checks
		 * may prevent us from changing the current (in-core)
		 * label.
		 */
		if (!donothing) {
			if (ioctl(f, DIOCSDINFO, lp) < 0 &&
			    errno != ENODEV && errno != ENOTTY) {
				l_perror("ioctl DIOCSDINFO");
				return (1);
			}
		}
		if (!donothing) {
			if (lseek(f, 0, SEEK_SET) < 0) {
				perror("lseek");
				return (1);
			}
			if (write(f, boot, lp->d_bbsize) != lp->d_bbsize) {
				perror("write");
				return (1);
			}
		}
		/*
		 * Output the remainder of the disklabel
		 */
		if (!donothing && bootbuf && write(f, bootbuf, bootsize) != bootsize) {
			perror("write");
			return(1);
		}
	} else
#endif /* NUMBOOT > 0 */
a391 5
#if NUMBOOT > 0
	char *dkbasename;
	int b;
	struct stat sb;
#endif
a400 60
#if NUMBOOT > 0
	/*
	 * If we are not installing a boot program but we are installing a
	 * label on disk then we must read the current bootarea so we don't
	 * clobber the existing boot.
	 */
	if (!installboot)
		return (lp);
	/*
	 * We are installing a boot program.  Determine the name(s) and
	 * read them into the appropriate places in the boot area.
	 */
	if (!xxboot) {
		dkbasename = np;
		if ((p = strrchr(dkname, '/')) == NULL)
			p = dkname;
		else
			p++;
		while (*p && !isdigit((unsigned char)*p))
			*np++ = *p++;
		*np++ = '\0';

		(void)snprintf(np, namebuf + sizeof namebuf - np,
		    "%s%sboot", _PATH_BOOTDIR, dkbasename);
		if (access(np, F_OK) < 0 && dkbasename[0] == 'r')
			dkbasename++;
		xxboot = np;
		(void)snprintf(xxboot,
		    namebuf + sizeof namebuf - np,
		    "%s%sboot", _PATH_BOOTDIR, dkbasename);
		np += strlen(xxboot) + 1;
	}
	if (verbose)
		warnx("bootstrap: xxboot = %s", xxboot);

	/*
	 * For NUMBOOT > 0 architectures (vax)
	 * up to d_bbsize bytes of ``xxboot'' go in bootarea, the rest
	 * is remembered and written later following the bootarea.
	 */
	b = open(xxboot, O_RDONLY);
	if (b < 0)
		err(4, "%s", xxboot);
	if (read(b, boot, (int)dp->d_bbsize) < 0)
		err(4, "%s", xxboot);
	(void)fstat(b, &sb);
	bootsize = (int)sb.st_size - dp->d_bbsize;
	if (bootsize > 0) {
		/* XXX assume d_secsize is a power of two */
		bootsize = (bootsize + dp->d_secsize-1) & ~(dp->d_secsize-1);
		bootbuf = malloc((size_t)bootsize);
		if (bootbuf == NULL)
			err(4, "%s", xxboot);
		if (read(b, bootbuf, bootsize) < 0) {
			free(bootbuf);
			err(4, "%s", xxboot);
		}
	}
	(void)close(b);
#endif
a1217 54
#if NUMBOOT > 0
/*
 * If we are installing a boot program that doesn't fit in d_bbsize
 * we need to mark those partitions that the boot overflows into.
 * This allows newfs to prevent creation of a filesystem where it might
 * clobber bootstrap code.
 */
void
setbootflag(struct disklabel *lp)
{
	struct partition *pp;
	int i, errors = 0;
	u_int64_t bend;
	char part;

	if (bootbuf == NULL)
		return;

	bend = (u_int64_t)bootsize / lp->d_secsize;
	for (i = 0; i < lp->d_npartitions; i++) {
		if (i == RAW_PART)
			/* It will *ALWAYS* overlap 'c'. */
			continue;
		pp = &lp->d_partitions[i];
		if (DL_GETPSIZE(pp) == 0)
			/* Partition is unused. */
			continue;
		if (bend <= DL_GETPOFFSET(pp)) {
			/* Boot blocks end before this partition starts. */
			if (pp->p_fstype == FS_BOOT)
				pp->p_fstype = FS_UNUSED;
			continue;
		}

		part = 'a' + i;
		switch (pp->p_fstype) {
		case FS_BOOT:	/* Already marked. */
			break;
		case FS_UNUSED:	/* Mark. */
			pp->p_fstype = FS_BOOT;
			warnx("warning, boot overlaps partition %c, %s",
			    part, "marked as FS_BOOT");
			break;
		default:
			warnx("boot overlaps used partition %c", part);
			errors++;
			break;
		}
	}
	if (errors)
		errx(4, "cannot install boot program");
}
#endif

a1251 10
#if NUMBOOT > 0
	fprintf(stderr,
	    "       disklabel -B  [-nv] [-b boot1] disk [disktype]\t\t(boot)\n");
 	fprintf(stderr,
	    "       disklabel -Bw [-nv] [-b boot1] disk disktype [packid]\t"
	    "(boot+write)\n");
	fprintf(stderr,
	    "       disklabel -BR [-nv] [-F|-f file ] [-b boot1] disk protofile\t\t"
	    "(boot+restore)\n\n");
#endif
@


1.208
log
@Remove 'landisk' from the comment about NUMBOOT archs. Only one
NUMBOOT arch is left: Vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.207 2015/09/24 22:03:53 krw Exp $	*/
d247 4
@


1.207
log
@Remove hppa/hppa64 from comment about NUMBOOT > 0 architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.206 2015/09/24 19:49:38 krw Exp $	*/
d547 1
a547 1
	 * For NUMBOOT > 0 architectures (landisk/vax)
@


1.206
log
@Expunge VAX SMD special handling that tried to fill up the last
cylinder of the disk with extra copies of the boot blocks and
disklabel. There are no plans to ever support the native SMD
controllers that would find this useful.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.205 2015/09/09 13:51:55 krw Exp $	*/
d547 1
a547 1
	 * For NUMBOOT > 0 architectures (hppa/hppa64/landisk/vax)
@


1.205
log
@No need to check !xxboot inside a 'if (!xxboot) ...' block.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.204 2015/08/20 22:02:20 deraadt Exp $	*/
d403 1
a403 14
#ifdef __vax__
	if (lp->d_type == DTYPE_SMD && lp->d_flags & D_BADSECT) {
		off_t alt;
		int i;

		alt = lp->d_ncylinders * lp->d_secpercyl - lp->d_nsectors;
		for (i = 1; i < 11 && i < lp->d_nsectors; i += 2) {
			(void)lseek(f, (alt + i) * lp->d_secsize, SEEK_SET);
			if (!donothing)
				if (write(f, boot, lp->d_secsize) != lp->d_secsize)
					warn("alternate label %d write", i/2);
		}
	}
#endif
@


1.204
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.203 2015/08/15 17:16:10 krw Exp $	*/
d546 9
a554 11
		if (!xxboot) {
			(void)snprintf(np, namebuf + sizeof namebuf - np,
			    "%s%sboot", _PATH_BOOTDIR, dkbasename);
			if (access(np, F_OK) < 0 && dkbasename[0] == 'r')
				dkbasename++;
			xxboot = np;
			(void)snprintf(xxboot,
			    namebuf + sizeof namebuf - np,
			    "%s%sboot", _PATH_BOOTDIR, dkbasename);
			np += strlen(xxboot) + 1;
		}
@


1.203
log
@Less damned spurious whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.202 2015/06/03 02:24:36 millert Exp $	*/
d576 1
a576 1
		bootbuf = (char *)malloc((size_t)bootsize);
@


1.202
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.201 2015/04/29 16:56:31 henning Exp $	*/
d1048 1
a1048 1
	
d1304 1
a1304 1
	
@


1.201
log
@some fine-tuning in SYNOPSIS, usage, and order of options, with jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.200 2015/04/29 09:58:16 henning Exp $	*/
d474 4
a477 2
	asprintf(&partname, "/dev/%s%c", dkname, 'a');
	asprintf(&partduid,
d481 2
@


1.200
log
@support passing a template file for the auto-allocation to disklabel.
template gives mountpoints, min-max size ranges and percentage of disk
foremost intended for autoinstalls, installer bits to follow soon.
with input from many, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.199 2015/02/07 02:09:13 deraadt Exp $	*/
d1477 1
a1477 1
	    "usage: disklabel    [-Acdtv] [-h | -p unit] disk\t\t(read)\n");
d1483 1
a1483 1
	    "       disklabel -E [-Acdnv] [-T file] [-F|-f file] disk\t(simple editor)"
@


1.199
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.198 2015/01/20 18:22:20 deraadt Exp $	*/
d125 1
d127 1
a127 1
	while ((ch = getopt(argc, argv, "ABEf:F:hRb:cdenp:tvw")) != -1)
d175 3
d227 3
d1477 1
a1477 1
	    "usage: disklabel    [-Acdtv] [-h | -p unit] disk\t(read)\n");
d1479 1
a1479 1
	    "       disklabel -w [-Acdnv] disk disktype [packid]\t(write)\n");
d1481 1
a1481 1
	    "       disklabel -e [-Acdnv] disk\t\t\t(edit)\n");
d1483 1
a1483 1
	    "       disklabel -E [-Acdnv] [-F|-f file] disk\t\t(simple editor)"
@


1.198
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.197 2015/01/16 06:39:57 deraadt Exp $	*/
d129 1
a129 1
			++aflag;
d133 1
a133 1
			++installboot;
d145 1
a145 1
			++cflag;
d148 1
a148 1
			++dflag;
d166 1
a166 1
			++uidflag;
d172 1
a172 1
			++tflag;
d188 1
a188 1
			donothing++;
d191 1
a191 1
			verbose++;
@


1.197
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.196 2014/07/20 01:38:40 guenther Exp $	*/
d35 1
a35 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE */
@


1.196
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.195 2014/05/05 16:33:34 krw Exp $	*/
d35 1
a35 1
#include <sys/param.h>
@


1.195
log
@Enhance reading of saved ascii labels (-R) to process mountpoint
information if present. Can be used with -F/-f options to create
an fstab from the saved label.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.194 2014/04/23 11:49:25 otto Exp $	*/
d819 1
a821 1
		warn("%s", tmpfil);
@


1.194
log
@don't clear label before readasciilabel(), it will not fill in some
required fields like disk size, causing consistency check failures.
with and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.193 2014/03/18 22:36:30 miod Exp $	*/
d213 2
a214 1
	if (argc < 1 || (fstabfile && !(op == EDITOR || aflag)))
d260 1
a260 1
		if (error == 0)
d262 6
d1018 2
a1019 1
	char *tp, *s, line[BUFSIZ];
d1023 1
d1028 10
d1040 4
a1043 1
		if ((cp = strpbrk(line, "#\r\n")))
d1045 4
d1279 2
d1289 5
d1479 1
a1479 1
	    "       disklabel -R [-nv] disk protofile\t\t(restore)\n\n");
d1487 1
a1487 1
	    "       disklabel -BR [-nv] [-b boot1] disk protofile\t\t"
@


1.193
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.192 2014/02/14 15:03:43 krw Exp $	*/
a840 1
		memset(&label, 0, sizeof(label));
@


1.192
log
@Ooops. r1.169 was supposed to add 'total sectors' to the list of
fields that are ignored when reading an ascii disklabel. Actually
remove the parsing of 'total sectors', which was just above the line
trying to skip said parsing.

Spotted when halex@@ forced me to read this code again.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.191 2013/11/22 04:12:47 deraadt Exp $	*/
d544 1
a544 1
	 * For NUMBOOT > 0 architectures (hp300/hppa/hppa64/landisk/vax)
@


1.191
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.190 2013/10/15 20:13:02 bluhm Exp $	*/
a1149 10
			continue;
		}
		if (!strcmp(cp, "total sectors")) {
			lv = GETNUM(lv, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else {
				DL_SETDSIZE(lp, lv);
			}
@


1.190
log
@The disklabel variables aflag and dflag are boolean, use logical
instead of binary operators for comparison.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.189 2013/10/03 18:50:30 krw Exp $	*/
d185 1
a185 1
			print_unit = tolower(optarg[0]);
d524 1
a524 1
		while (*p && !isdigit(*p))
d737 1
a737 1
	unit = toupper(unit);
d963 1
a963 1
	for (p = nptr; *p != '\0' && !isspace(*p); p++)
d1227 1
a1227 1
			if (isdigit(*cp))
@


1.189
log
@Print u_int64_t variables with %llu.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.188 2013/09/10 15:17:46 krw Exp $	*/
d264 1
a264 1
		if (dflag | aflag) {
@


1.188
log
@The rule is: daddr_t variables hold counts of 512-byte blocks, a.k.a.
DEV_BSIZE blocks. Counts of possibly other-sized blocks (e.g. disk
sector addresses) are u_int64_t. The values stored in disklabels are
counts of possibly other-sized blocks and hence should be handled with
u_int64_t variables.

Start enforcing this rule. No intended functional change.

Rule strongly suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.187 2013/06/18 18:24:15 krw Exp $	*/
d1323 1
a1323 1
			warnx("warning, partition %c: size 0, but offset %lld",
d1363 2
a1364 2
			warnx("warning, unused partition %c: size %lld "
			    "offset %lld", part, DL_GETPSIZE(pp),
@


1.187
log
@Initialize duid memory before shifting stuff into elements of it.
No doubt quiets one or more of the fringe compilers out there. Use
variable 'part' rather than recalculating same value in the subsequent
printf().

From dhill. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.186 2013/06/11 16:42:04 deraadt Exp $	*/
d719 1
a719 1
	daddr_t small;
d1382 1
a1382 1
	daddr_t bend;
d1388 1
a1388 1
	bend = bootsize / lp->d_secsize;
@


1.186
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.185 2012/04/06 18:20:35 deraadt Exp $	*/
d982 1
d1363 3
a1365 2
			warnx("warning, unused partition %c: size %lld offset %lld",
			    'a' + i, DL_GETPSIZE(pp), DL_GETPOFFSET(pp));
@


1.185
log
@there is no need to cast an unsigned type with (unsigned).
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.184 2012/01/16 17:32:07 krw Exp $	*/
d719 1
a719 1
	daddr64_t small;
d1380 1
a1380 1
	daddr64_t bend;
@


1.184
log
@Nuke unused parameter (f) to makebootarea(). Unused since r1.123
(2008), when '-r' support was removed. Spotted by jsg@@ with the
assistance of clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.183 2012/01/02 03:40:31 krw Exp $	*/
d591 1
a591 1
	if ((unsigned) lp->d_type < DKMAXTYPES)
d619 1
a619 1
				if ((unsigned) pp->p_fstype < FSMAXTYPES)
d693 1
a693 1
		if ((unsigned) pp->p_fstype < FSMAXTYPES)
d752 1
a752 1
	if ((unsigned) lp->d_type < DKMAXTYPES)
@


1.183
log
@Tweak usage and man page into agreement.

There's nothing special about -c and -d requiring them to be
separated from other flags or specified as mutually exclusive. So
just show a single block of flags. Some flag combos are silly
but harmless.

Move all -B options inside NUMBOOT #if, eliminating confusing
duplication of -w and -R usage lines. And some string
declaration dancing.

Since we only have NUMBOOT = 1, no need to try and finesse
output for different values of NUMBOOT.

Line shit up.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.182 2012/01/02 00:59:33 krw Exp $	*/
d253 1
a253 1
		lp = makebootarea(bootarea, &lab, f);
d270 1
a270 1
		lp = makebootarea(bootarea, &lab, f);
d285 1
a285 1
		lp = makebootarea(bootarea, &lab, f);
d488 1
a488 1
makebootarea(char *boot, struct disklabel *dp, int f)
@


1.182
log
@'-s' hasn't done anything for a couple of years. Garbage collect
it and the associated 'bootxx' variable. Update man page accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.181 2011/06/05 11:57:17 krw Exp $	*/
a1444 9
	char *boot = "";
	char *blank = "       ";
	char *Bflag = "";

#if NUMBOOT == 1
	Bflag = "B";
	boot = " [-b boot1]";
#endif

d1446 1
a1446 1
	    "usage: disklabel [-c | -d | -t] [-Av] [-h | -p unit] disk\t(read)\n");
d1448 1
a1448 1
	    "       disklabel -w [-c | -d] [-Anv] disk disktype [packid]\t(write)\n");
d1450 1
a1450 1
	    "       disklabel -e [-c | -d] [-Anv] disk\t\t\t(edit)\n");
d1452 2
a1453 1
	    "       disklabel -E [-c | -d] [-Anv] [-F|-f file] disk\t(simple editor)\n");
d1455 1
a1455 1
	    "       disklabel -R [-nv] disk protofile\t\t\t(restore)\n");
d1458 7
a1464 2
	    "%sdisklabel -B  [-nv]%s disk [disktype]           (boot)\n",
	    blank, boot);
a1465 6
	fprintf(stderr,
	    "%sdisklabel -%sw [-nv]%s disk disktype [packid]    (write)\n",
	    blank, Bflag, boot);
	fprintf(stderr,
	    "%sdisklabel -%sR [-nv]%s disk protofile [disktype] (restore)\n\n",
	    blank, Bflag, boot);
@


1.181
log
@Nuke uses of and references to DIOCWLABEL, and the related 'W' and
'N' command line options.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.180 2011/06/02 17:00:24 krw Exp $	*/
a88 1
char	*bootxx;	/* secondary boot */
d126 1
a126 1
	while ((ch = getopt(argc, argv, "ABEf:F:hRb:cdenp:s:tvw")) != -1)
d518 1
a518 1
	if (!xxboot || !bootxx) {
d541 1
a541 2
		warnx("bootstraps: xxboot = %s, bootxx = %s", xxboot,
		    bootxx ? bootxx : "NONE");
@


1.180
log
@Hack to ensure that the in-core labels contain the current bounds
info from the physical disk after 'disklabel -e' writes the label
to disk.  Saves having to reboot or do other contortions to initialize
these fields. Toss in same treatment for total sectors so all fields
forcibly set by kernel have current values.

0'ing of the bounds noted by matthew@@.

'lovely' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.179 2011/05/22 13:05:47 otto Exp $	*/
d95 1
a95 1
	UNSPEC, EDIT, EDITOR, READ, RESTORE, SETWRITEABLE, WRITE, WRITEBOOT
d123 1
a123 1
	int ch, f, writeable, error = 0;
d127 1
a127 1
	while ((ch = getopt(argc, argv, "ABEf:F:hNRWb:cdenp:s:tvw")) != -1)
a139 6
		case 'N':
			if (op != UNSPEC)
				usage();
			writeable = 0;
			op = SETWRITEABLE;
			break;
a144 6
		case 'W':
			if (op != UNSPEC)
				usage();
			writeable = 1;
			op = SETWRITEABLE;
			break;
a263 6
	case SETWRITEABLE:
		if (!donothing) {
			if (ioctl(f, DIOCWLABEL, (char *)&writeable) < 0)
				err(4, "ioctl DIOCWLABEL");
		}
		break;
a341 4
	int writeable;
#endif

#if NUMBOOT > 0
a369 8
			/*
			 * write enable label sector before write (if necessary),
			 * disable after writing.
			 */
			writeable = 1;

			if (ioctl(f, DIOCWLABEL, &writeable) < 0)
				perror("ioctl DIOCWLABEL");
a381 4
		writeable = 0;
		if (!donothing)
			if (ioctl(f, DIOCWLABEL, &writeable) < 0)
				perror("ioctl DIOCWLABEL");
a1465 2
	fprintf(stderr,
	    "       disklabel -N | -W [-nv] disk\t\t\t\t(protect)\n\n");
@


1.179
log
@zap unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.178 2011/04/19 19:16:18 halex Exp $	*/
d845 1
d871 6
d879 4
@


1.178
log
@make same changes regarding -f/-F argument (tempfile -> file) as was done
in disklabel(8)

pointed out by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.177 2011/04/16 14:51:00 krw Exp $	*/
d123 1
a123 1
	int ch, f, i, writeable, error = 0;
@


1.177
log
@Tweak man page and usage string with jmc@@ suggestions.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.176 2011/04/16 11:44:41 krw Exp $	*/
d1486 1
a1486 1
	    "       disklabel -E [-c | -d] [-Anv] [-F|-f tempfile] disk\t(simple editor)\n");
@


1.176
log
@Add '-F'. Same as '-f' but uses DUIDs when writing the mount point
information to the specified file. After every label write, read the
label to get current UID info.

Some internal code cleanup with no intended functional change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.175 2010/12/13 01:01:41 marco Exp $	*/
d1486 1
a1486 1
	    "       disklabel -E [-c | -d] [-Anv] [-f | -F tempfile] disk\t(simple editor)\n");
@


1.175
log
@stray tabs and spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.174 2010/11/24 14:15:31 jsing Exp $	*/
d102 1
d127 1
a127 1
	while ((ch = getopt(argc, argv, "ABEf:hNRWb:cdenp:s:tvw")) != -1)
d175 5
d246 1
a246 1
		error = editor(&lab, f);
d439 4
a442 1
	if (!donothing)
d444 1
d1486 1
a1486 1
	    "       disklabel -E [-c | -d] [-Anv] [-f tempfile] disk\t\t(simple editor)\n");
@


1.174
log
@When dealing with disklabel UIDs (DUIDs) be specific and consistent with
naming.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.172 2010/09/23 13:54:21 jsing Exp $	*/
d411 1
a411 1
#endif /* NUMBOOT > 0 */	
d1416 1
a1416 1
		
@


1.173
log
@Correctly identify mount points when they are specified in /etc/fstab using
a disklabel UID. Based on a diff from josh@@elsasser.org. Resolves PR6471.

ok krw@@
@
text
@d470 1
a470 1
	char *partname, *partuid;
d486 2
a487 1
	asprintf(&partuid, "%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx.a",
d493 1
a493 1
		partuid[strlen(partuid) - 1] = 'a' + i;
d496 1
a496 1
			fsent = getfsspec(partuid);
d501 1
a501 1
	free(partuid);
d786 1
a786 1
	fprintf(f, "uid: %02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\n",
d988 1
a988 1
uid_parse(struct disklabel *lp, char *s)
d990 1
a990 1
	u_char uid[8];
d1007 2
a1008 2
		uid[i / 2] <<= 4;
		uid[i / 2] |= c & 0xf;
d1011 1
a1011 1
	memcpy(lp->d_uid, &uid, sizeof(lp->d_uid));
d1114 2
a1115 2
		if (!strcmp(cp, "uid")) {
			if (uid_parse(lp, tp) != 0) {
@


1.172
log
@Print disklabel UIDs using printf/fprintf instead of using the hand rolled
uid_print() function.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.170 2010/08/08 05:24:46 tedu Exp $	*/
a123 1
	struct fstab *fsent;
a124 1
	char *partname;
a228 11
	asprintf(&partname, "/dev/%s%c", dkname, 'a');
	setfsent();
	for (i = 0; i < MAXPARTITIONS; i++) {
		partname[strlen(dkname)+5] = 'a'+i;
		fsent = getfsspec(partname);
		if (fsent)
			mountpoints[i] = strdup(fsent->fs_file);
	}
	endfsent();
	free(partname);

d470 4
d484 18
@


1.171
log
@fix a few warnings.  ok jsing
@
text
@d776 3
a778 3
	fprintf(f, "uid: ");
	uid_print(f, lp);
	fprintf(f, "\n");
a974 11
}

void
uid_print(FILE *f, struct disklabel *lp)
{
	char hex[] = "0123456789abcdef";
	int i;

	for (i = 0; i < sizeof(lp->d_uid); i++)
		fprintf(f, "%c%c", hex[(lp->d_uid[i] >> 4) & 0xf],
		    hex[lp->d_uid[i] & 0xf]);
@


1.170
log
@make disklabel -p slightly nicer by accepting capital letters and printing
a more useful error message for invalid ones.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.169 2010/08/03 00:19:42 krw Exp $	*/
a117 2
void	uid_print(FILE *, struct disklabel *);
int	uid_parse(struct disklabel *, char *);
a597 1
	char *did = "\\\n\t:";
@


1.169
log
@Group string comparisons and supply more helpful comments. Add
"total sectors" to "boundstart" and "boundend" in the list of fields
that are left alone during a RESTORE operation.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.168 2010/08/03 00:08:30 krw Exp $	*/
d191 6
a196 4
			if (strchr("bckmgt", optarg[0]) == NULL ||
			    optarg[1] != '\0')
				usage();
			print_unit = optarg[0];
@


1.168
log
@Start with the default label when RESTORE'ing a saved ascii label.
This ensures that all physical fields are filled in with current
values. Lack of values (boundstart, boundend in particular) noted
by ray@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.167 2010/07/27 00:07:26 krw Exp $	*/
d1178 8
a1185 2
		if (!strcmp(cp, "rpm")) {
			/* ignore */
d1187 5
a1191 3
		}
		if (!strcmp(cp, "interleave")) {
			/* ignore */
d1193 1
a1193 25
		}
		if (!strcmp(cp, "trackskew")) {
			/* ignore */
			continue;
		}
		if (!strcmp(cp, "cylinderskew")) {
			/* ignore */
			continue;
		}
		if (!strcmp(cp, "headswitch")) {
			/* ignore */
			continue;
		}
		if (!strcmp(cp, "track-to-track seek")) {
			/* ignore */
			continue;
		}
		if (!strcmp(cp, "boundstart")) {
			/* ignore */
			continue;
		}
		if (!strcmp(cp, "boundend")) {
			/* ignore */
			continue;
		}
@


1.167
log
@Nuke 'sectoffset'. A stub variable no longer used except to supply
the value 0 to one function call. Use 0 there, eliminate the
variable and the pointless verbose verbiage that always displayed
the same value.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.166 2010/06/30 23:44:06 halex Exp $	*/
d268 1
d274 1
d486 1
a486 1
	if (dflag | aflag) {
@


1.166
log
@allow uppercase A-F in the uid input

ok krw@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.165 2010/05/18 04:41:14 dlg Exp $	*/
a365 1
	off_t sectoffset = 0;
a391 4
		if (verbose)
			printf("writing label to block %lld (0x%qx)\n",
			    (long long)sectoffset/DEV_BSIZE,
			    (long long)sectoffset/DEV_BSIZE);
d393 1
a393 1
			if (lseek(f, sectoffset, SEEK_SET) < 0) {
@


1.165
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.164 2010/04/28 17:12:52 jsing Exp $	*/
d1008 2
@


1.164
log
@Move the UID printing/parsing code into separate functions and avoid using
sscanf().

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.163 2010/04/28 16:56:01 jsing Exp $	*/
d37 1
@


1.163
log
@When restoring a disklabel do not restore the uid. Let the kernel allocate
a new uid instead.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.162 2010/04/28 12:55:55 jsing Exp $	*/
d117 2
d779 3
a781 3
	fprintf(f, "uid: %02x%02x%02x%02x%02x%02x%02x%02x\n",
	    lp->d_uid[0], lp->d_uid[1], lp->d_uid[2], lp->d_uid[3],
	    lp->d_uid[4], lp->d_uid[5], lp->d_uid[6], lp->d_uid[7]);
d980 37
a1031 1
	u_char uid[8];
d1117 1
a1117 3
			if (sscanf(tp, "%02x%02x%02x%02x%02x%02x%02x%02x",
			    &uid[0], &uid[1], &uid[2], &uid[3],
			    &uid[4], &uid[5], &uid[6], &uid[7]) != 8) {
d1120 1
a1120 2
			} else
				memcpy(lp->d_uid, &uid, sizeof(lp->d_uid));
@


1.162
log
@Teach disklabel how to print and parse UIDs.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.161 2010/04/23 15:25:21 jsing Exp $	*/
d273 1
@


1.161
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.159 2009/09/15 21:51:51 fgsch Exp $	*/
d772 7
a778 2
	fprintf(f, "disk: %.*s\n", (int)sizeof(lp->d_typename), lp->d_typename);
	fprintf(f, "label: %.*s\n", (int)sizeof(lp->d_packname), lp->d_packname);
d992 1
d1075 10
@


1.160
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@a618 8
	if (lp->d_rpm != 3600) {
		(void)fprintf(f, "%srm#%hu:", did, lp->d_rpm);
		did = "";
	}
	if (lp->d_interleave != 1) {
		(void)fprintf(f, "%sil#%hu:", did, lp->d_interleave);
		did = "";
	}
a792 2
	fprintf(f, "rpm: %hu\n", lp->d_rpm);
	fprintf(f, "interleave: %hu\n", lp->d_interleave);
d1127 1
a1127 6
			v = GETNUM(lp->d_rpm, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_rpm = v;
d1131 1
a1131 6
			v = GETNUM(lp->d_interleave, tp, 1, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_interleave = v;
a1281 2
	if (lp->d_rpm == 0)
		warnx("warning, revolutions/minute %d", lp->d_rpm);
@


1.159
log
@also ignore boundaries when checking if the disklabel was modified when -e
is used. discussed and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.158 2009/06/04 21:13:03 deraadt Exp $	*/
a33 10

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.158 2009/06/04 21:13:03 deraadt Exp $";
#endif /* not lint */
@


1.158
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.157 2009/06/02 16:23:45 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.157 2009/06/02 16:23:45 krw Exp $";
d1447 4
@


1.157
log
@Add '-h' flag, and '*' as a unit specifier for 'p' Editor command.
Both cause partition sizes to be displayed using a human readable
format with the units automatically chosen by looking at the smallest
partition in the disk label. Remove forceable humanization in 'A'
code and use '-h' in install scripts.

Prodded & ok deraadt@@, verbiage tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.156 2009/05/31 00:05:03 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.156 2009/05/31 00:05:03 krw Exp $";
a114 12
#ifdef DOSLABEL
struct dos_partition *dosdp;	/* DOS partition, if found */
struct dos_partition *findopenbsd(int, off_t, struct dos_partition **, int *);
struct dos_partition *readmbr(int);
#endif

#ifdef DPMELABEL
int	dpme_label = 0;
uint32_t dpme_obsd_start, dpme_obsd_size;
int	check_dpme(int, uint32_t *, uint32_t *);
#endif

a248 20
#ifdef DOSLABEL
	/*
	 * Check for presence of DOS partition table in
	 * master boot record. Return pointer to OpenBSD
	 * partition, if present. If no valid partition table,
	 * return NULL. If valid partition table present, but no
	 * partition to use, return a pointer to a non-386bsd
	 * partition.
	 */
	dosdp = readmbr(f);
#endif

#ifdef DPMELABEL
	/*
	 * Check for a MacOS DPME partition table, and find out the
	 * area of the OpenBSD DPME partition, if any.
	 */
	dpme_label = check_dpme(f, &dpme_obsd_start, &dpme_obsd_size);
#endif

a383 29
#ifdef DOSLABEL
		struct partition *pp = &lp->d_partitions[2];

		/*
		 * If OpenBSD DOS partition is missing, or if
		 * the label to be written is not within partition,
		 * prompt first. Need to allow this in case operator
		 * wants to convert the drive for dedicated use.
		 * In this case, partition 'a' had better start at 0,
		 * otherwise we reject the request as meaningless. -wfj
		 */
		if (dosdp && DL_GETPSIZE(pp) && (dosdp->dp_typ == DOSPTYP_OPENBSD)) {
			sectoffset = (off_t)letoh32(dosdp->dp_start) *
			    lp->d_secsize;
		} else {
			if (dosdp) {
				int first, ch;

				printf("Erase the previous contents of the disk? [n]: ");
				fflush(stdout);
				first = ch = getchar();
				while (ch != '\n' && ch != EOF)
					ch = getchar();
				if (first != 'y' && first != 'Y')
					exit(0);
			}
			sectoffset = 0;
		}
#endif
a485 157
#ifdef DOSLABEL
struct dos_partition *
findopenbsd(int f, off_t mbroff, struct dos_partition **first, int *n)
{
	static struct dos_partition res;
	int mbr[DEV_BSIZE / sizeof(int)];
	struct dos_partition *dp, *p;
	u_int16_t signature;
	u_int32_t start = 0;
	int part;

	/* Limit the number of recursions */
	if (!(*n)--)
		return (NULL);

	/*
	 * This must be done this way due to alignment restrictions
	 * in for example mips processors.
	 */
	dp = (struct dos_partition *)mbr;
	if (lseek(f, (off_t)mbroff * DEV_BSIZE, SEEK_SET) < 0 ||
	    read(f, mbr, sizeof(mbr)) != sizeof(mbr))
		return (NULL);
	signature = *((u_char *)mbr + DOSMBR_SIGNATURE_OFF) |
	    (*((u_char *)mbr + DOSMBR_SIGNATURE_OFF + 1) << 8);
	bcopy((char *)mbr+DOSPARTOFF, (char *)mbr, sizeof(*dp) * NDOSPART);

	/*
	 * If there is no signature and no OpenBSD partition this is probably
	 * not an MBR.
	 */
	if (signature != DOSMBR_SIGNATURE)
		return (NULL);

	/*
	 * Don't (yet) know disk geometry, use partition table to find OpenBSD
	 * partition, and obtain disklabel from there.
	 */
	/* Check if table is valid. */
	for (part = 0; part < NDOSPART; part++) {
		if ((dp[part].dp_flag & ~0x80) != 0)
			return (NULL);
	}
	/* Find OpenBSD partition. */
	for (part = 0; part < NDOSPART; part++) {
		if (!letoh32(dp[part].dp_size))
			continue;
		if (first && *first == NULL) {
			bcopy(&dp[part], &res, sizeof(struct dos_partition));
			*first = &res;
		}
		switch (dp[part].dp_typ) {
		case DOSPTYP_OPENBSD:
			if (verbose)
				fprintf(stderr, "# Inside MBR partition %d: "
				    "type %02X start %u size %u\n", part,
				    dp[part].dp_typ, letoh32(dp[part].dp_start),
				    letoh32(dp[part].dp_size));
			bcopy(&dp[part], &res, sizeof(struct dos_partition));
			res.dp_start =
			    htole32((off_t)letoh32(res.dp_start) + mbroff);
			return (&res);
		case DOSPTYP_EXTEND:
		case DOSPTYP_EXTENDL:
			fprintf(stderr, "# Extended partition %d: "
			    "type %02X start %u size %u\n",
			    part, dp[part].dp_typ,
			    letoh32(dp[part].dp_start), letoh32(dp[part].dp_size));
			start = letoh32(dp[part].dp_start) + mbroff;
			p = findopenbsd(f, start, NULL, n);
			if (p != NULL)
				return (p);
			break;
		}
	}

	return (NULL);
}

/*
 * Fetch DOS partition table from disk.
 */
struct dos_partition *
readmbr(int f)
{
	struct dos_partition *dp, *first = NULL;
	int n = 8;

	dp = findopenbsd(f, DOSBBSECTOR, &first, &n);
	if (dp != NULL)
		return (dp);

	/* If no OpenBSD partition, find first used partition. */
	if (first != NULL) {
		warnx("warning, DOS partition table with no valid OpenBSD partition");
		return (first);
	}

	/* Table appears to be empty. */
	return (NULL);
}
#endif

#ifdef DPMELABEL
int
check_dpme(int f, uint32_t *start, uint32_t *size)
{
	char sector[DEV_BSIZE];
	unsigned int partno, partcnt;
	struct part_map_entry part;

	/*
	 * Read what would be the first DPME partition, and
	 * check for a valid signature.
	 */

	if (lseek(f, (off_t)DEV_BSIZE, SEEK_SET) < 0 ||
	    read(f, sector, sizeof(sector)) != sizeof(sector))
		return (0);
	/* no direct derefence due to strict alignment */
	memcpy(&part, sector, sizeof part);

	if (part.pmSig != PART_ENTRY_MAGIC)
		return (0);

	/*
	 * If the signature matches, perform a few more sanity checks,
	 * and then loop over the remaining partitions.  We can safely
	 * rely on the first entry being of the partition map type,
	 * so it's ok to skip it.
	 */

	partcnt = part.pmMapBlkCnt;
	if (partcnt <= 1 || partcnt > 32)
		return (0);

	for (partno = 2; partno <= partcnt; partno++) {
		if (lseek(f, (off_t)partno * DEV_BSIZE, SEEK_SET) < 0 ||
		    read(f, sector, sizeof(sector)) != sizeof(sector))
			return (0);
		/* no direct derefence due to strict alignment */
		memcpy(&part, sector, sizeof part);

		if (part.pmSig != PART_ENTRY_MAGIC)
			return (0);

		if (strcasecmp(part.pmPartType, PART_TYPE_OPENBSD) == 0) {
			*start = part.pmPyPartStart;
			*size = part.pmPartBlkCnt;
			return (1);
		}
	}

	return (0);
}
#endif

d637 4
a640 16
	if (lp->d_trackskew != 0) {
		(void)fprintf(f, "%ssk#%hu:", did, lp->d_trackskew);
		did = "";
	}
	if (lp->d_cylskew != 0) {
		(void)fprintf(f, "%scs#%hu:", did, lp->d_cylskew);
		did = "";
	}
	if (lp->d_headswitch != 0) {
		(void)fprintf(f, "%shs#%u:", did, lp->d_headswitch);
		did = "";
	}
	if (lp->d_trkseek != 0) {
		(void)fprintf(f, "%sts#%u:", did, lp->d_trkseek);
		did = "";
	}
d813 2
a814 6
	fprintf(f, "trackskew: %hu\n", lp->d_trackskew);
	fprintf(f, "cylinderskew: %hu\n", lp->d_cylskew);
	fprintf(f, "headswitch: %u\t\t# microseconds\n",
	    lp->d_headswitch);
	fprintf(f, "track-to-track seek: %u\t# microseconds\n",
	    lp->d_trkseek);
d1165 1
a1165 6
			v = GETNUM(lp->d_trackskew, tp, 0, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_trackskew = v;
d1169 1
a1169 6
			v = GETNUM(lp->d_cylskew, tp, 0, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_cylskew = v;
d1173 1
a1173 6
			v = GETNUM(lp->d_headswitch, tp, 0, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_headswitch = v;
d1177 9
a1185 6
			v = GETNUM(lp->d_trkseek, tp, 0, &errstr);
			if (errstr) {
				warnx("line %d: bad %s: %s", lineno, cp, tp);
				errors++;
			} else
				lp->d_trkseek = v;
a1317 9
#ifdef i386__notyet
	if (dosdp && dosdp->dp_size &&
	    (dosdp->dp_typ == DOSPTYP_OPENBSD)) {
		&& DL_GETDSIZE(lp) > dosdp->dp_start + dosdp->dp_size) {
		warnx("exceeds DOS partition size");
		errors++;
		DL_SETDSIZE(lp, dosdp->dp_start + dosdp->dp_size);
	}
#endif
@


1.156
log
@Never 'humanize' the sector offsets of partitions or 'total sectors'.
If we are humanizing then add a comment to 'total sectors' line
rather than replacing 'total sectors' with a new header.

Suggestion and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.155 2009/05/29 01:49:56 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.155 2009/05/29 01:49:56 krw Exp $";
d149 1
a149 1
	while ((ch = getopt(argc, argv, "ABEf:NRWb:cdenp:s:tvw")) != -1)
d198 3
d979 27
d1012 2
a1013 1
	unit = toupper(unit);
d1719 1
a1719 1
	    "usage: disklabel [-c | -d | -t] [-Av] [-p unit] disk\t\t(read)\n");
@


1.155
log
@Clean up logic around exit values. Make getasciilabel() return 0
for success. Fix a couple of bugs where errors in checklabel() got
lost.

Make Editor 'q' and 'x' commands exit with 0 (ok) rather than 1.
i.e. non-zero exit value now reserved for failure, not a decision
to leave the disklabel unchanged. This allows the install script
to use the exit value to catch failures to write a disklabel.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.154 2009/05/17 01:17:12 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.154 2009/05/17 01:17:12 krw Exp $";
d940 1
a940 1
	double p_size, p_offset;
a942 1
	p_offset = scale(DL_GETPOFFSET(pp), unit, lp);
d951 1
a951 1
			fprintf(f, "  %c: %15.*f%c %15.*f%c ", 'a' + i,
d953 1
a953 1
			    unit == 'B' ? 0 : 1, p_offset, unit);
d1003 1
d1005 2
a1006 4
	if (d < 0)
		fprintf(f, "total sectors: %llu\n", DL_GETDSIZE(lp));
	else
		fprintf(f, "total bytes: %.*f%c\n", unit == 'B' ? 0 : 1,
d1008 1
@


1.154
log
@Write out mountpoint info in writelabel() after label successfully
written, rather than every time editor_alloc() is called. Respect
'-n' for mountpoint info. Reduces surprise appearance of files when
you 'x' out of Editor.

"my sunglasses did not go dark" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.153 2009/05/05 12:24:19 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.153 2009/05/05 12:24:19 otto Exp $";
d311 2
a312 1
		if (getasciilabel(t, lp))
a313 2
		else
			error = 1;
d331 2
a332 1
		if (checklabel(lp) == 0)
d346 2
a347 1
		if (checklabel(lp) == 0)
d1041 1
a1041 1
	int first, ch, fd;
d1070 2
a1071 1
		if (getasciilabel(fp, &label)) {
d1498 1
a1498 1
	return (errors == 0);
d1603 1
a1603 1
	return (errors);
@


1.153
log
@use logical or when it's intended to be a logical or; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.152 2009/04/30 00:45:00 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.152 2009/04/30 00:45:00 krw Exp $";
d511 4
@


1.152
log
@Prime mountpoint info with any fstab info that is available, with
or without the '-f' option being present. Now you can see in Editor
mode or 'disklabel <dev>' where the partitions that exist will be
mounted in the current configuration.

Tweaks (and libc fixes) from, and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.151 2009/04/12 01:01:24 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.151 2009/04/12 01:01:24 krw Exp $";
d238 1
a238 1
	if (argc < 1 || (fstabfile && !(op == EDITOR | aflag)))
@


1.151
log
@When auto-allocating, check the size of the disk and display
offset/size information in MB if the disk is <10G, and in GB
otherwise. '-p' will override this default.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.150 2009/04/11 23:57:56 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.150 2009/04/11 23:57:56 krw Exp $";
d65 1
d143 1
a143 1
	int ch, f, writeable, error = 0;
d145 1
d147 1
d246 11
@


1.150
log
@Always display any mountpoint info available. Thus a simple -A will
now show the planned mountpoint layout.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.149 2009/04/11 16:54:28 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.149 2009/04/11 16:54:28 krw Exp $";
d112 1
a143 1
	char print_unit = 0;
@


1.149
log
@readlabel() either errored out or returned a pointer to the global
'lab'. So there is no need for the return value. Just use &lab
wherever it was used. No functional change.

Slightly different version read ok to blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.148 2009/04/10 20:54:08 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.148 2009/04/10 20:54:08 krw Exp $";
d952 2
a953 4
		if (fstabfile) {
			if (mountpoints[i] != NULL)
				fprintf(f, "# %s", mountpoints[i]);
		}
@


1.148
log
@Re-work '-A' so that it sets a flag that -E and -w use, and which will
just display the auto-allocation plan otherwise. Don't overwrite any
spoofed partitions, insert auto allocated partitions where we can.

This is much more install script and weird architecture friendly. I'm
talking about you, macppc.

Many suggestions and code from otto@@, feedback from many, cattle
prod applied by deraadt@@.

ok deraadt@@
"if it works for >8GB ... put it in" miod@@
"to be clear, ok" todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.147 2009/03/31 23:58:36 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.147 2009/03/31 23:58:36 krw Exp $";
d268 2
a269 3
		if ((lp = readlabel(f)) == NULL)
			exit(1);
		error = edit(lp, f);
d274 2
a275 3
		if ((lp = readlabel(f)) == NULL)
			exit(1);
		error = editor(lp, f);
d280 1
a280 2
		if ((lp = readlabel(f)) == NULL)
			exit(1);
d282 1
a282 1
			makedisktab(stdout, lp);
d284 2
a285 2
			display(stdout, lp, print_unit, 1);
		error = checklabel(lp);
d311 1
a311 2
			if (readlabel(f) == NULL)
				exit(1);
d326 2
a327 3
		if ((lp = readlabel(f)) == NULL)
			exit(1);
		tlab = *lp;
d683 1
a683 1
 * Fetch disklabel for disk using ioctl.
d685 1
a685 1
struct disklabel *
a687 2
	struct disklabel *lp = NULL;

d692 1
a692 2
		lp = &lab;
		if (ioctl(f, DIOCGPDINFO, lp) < 0)
d695 1
a695 2
		lp = &lab;
		if (ioctl(f, DIOCGDINFO, lp) < 0)
d700 1
a700 3
		editor_allocspace(lp);

	return (lp);
@


1.147
log
@When warning about a non-zero partition offset, show DL_GETPOFFSET()
and not DL_GETPSIZE().
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.146 2009/03/31 01:22:41 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.146 2009/03/31 01:22:41 krw Exp $";
d85 1
a85 1
char	*dkname, *specname;
d87 1
a141 1
	char *fstabfile = NULL;
d235 1
a235 1
	if (argc < 1 || (fstabfile && op != EDITOR))
d277 1
a277 1
		error = editor(lp, f, specname, fstabfile, aflag);
d287 1
a287 1
			display(stdout, lp, NULL, print_unit, 1);
d313 1
a313 1
		if (dflag) {
d583 5
a587 4
			fprintf(stderr, "# Inside MBR partition %d: "
			    "type %02X start %u size %u\n",
			    part, dp[part].dp_typ,
			    letoh32(dp[part].dp_start), letoh32(dp[part].dp_size));
d697 2
a698 1
	if (dflag) {
d708 3
d929 1
a929 2
display_partition(FILE *f, struct disklabel *lp, char **mp, int i,
    char unit)
d963 3
a965 3
		if (mp != NULL) {
			if (mp[i] != NULL)
				fprintf(f, "# %s", mp[i]);
d972 1
a972 1
display(FILE *f, struct disklabel *lp, char **mp, char unit, int all)
d1027 1
a1027 1
			display_partition(f, lp, mp, i, unit);
d1045 1
a1045 1
	display(fp, lp, NULL, 0, 1);
d1682 1
a1682 1
	    "usage: disklabel [-c | -d | -t] [-v] [-p unit] disk\t\t(read)\n");
d1684 1
a1684 1
	    "       disklabel -w [-c | -d] [-nv] disk disktype [packid]\t(write)\n");
d1686 1
a1686 1
	    "       disklabel -e [-c | -d] [-nv] disk\t\t\t(edit)\n");
@


1.146
log
@Tweak comment to remove discussion of now non-existant 2 stage
boot loaders and update list of NUMBOOT>0 archs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.145 2009/03/30 00:39:26 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.145 2009/03/30 00:39:26 deraadt Exp $";
d1550 1
a1550 1
			    part, DL_GETPSIZE(pp));
@


1.145
log
@lint; mostly unused variables, carefully checked against all platforms
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.144 2009/03/29 19:58:27 weingart Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.144 2009/03/29 19:58:27 weingart Exp $";
d771 3
a773 8
	 * Strange rules:
	 * 1. One-piece bootstrap (hp300/hp800)
	 *	up to d_bbsize bytes of ``xxboot'' go in bootarea, the rest
	 *	is remembered and written later following the bootarea.
	 * 2. Two-piece bootstraps (vax/i386?/mips?)
	 *	up to d_secsize bytes of ``xxboot'' go in first d_secsize
	 *	bytes of bootarea, remaining d_bbsize-d_secsize filled
	 *	from ``bootxx''.
@


1.144
log
@No more NUMBOOT==2 stuff around, nuke it for sake of clarity.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.143 2009/03/29 05:37:13 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.143 2009/03/29 05:37:13 deraadt Exp $";
a86 1
char	namebuf[BBSIZE], *np = namebuf;
d91 1
d389 1
d392 1
d615 1
a615 1
	int part, n = 8;
@


1.143
log
@otto points out that the -v printing changes are incompatible with the
expectation that -R will read the output of disklabel.  I suspect we
will find another way to do this; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.141 2009/03/28 14:03:42 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.141 2009/03/28 14:03:42 deraadt Exp $";
a98 3
#if NUMBOOT > 1
char	boot1[MAXPATHLEN];
#endif
a157 5
#if NUMBOOT > 1
		case 's':
			bootxx = optarg;
			break;
#endif
a377 10
#if NUMBOOT > 1
	if (!bootxx && lp->d_boot1) {
		if (*lp->d_boot1 != '/')
			(void)snprintf(boot1, sizeof boot1, "%s%s",
			    _PATH_BOOTDIR, lp->d_boot1);
		else
			(void)strlcpy(boot1, lp->d_boot1, sizeof boot1);
		bootxx = boot1;
	}
#endif
a718 1
#if NUMBOOT == 1
a720 1
#endif
a762 12
#if NUMBOOT > 1
		if (!bootxx) {
			(void)snprintf(np, namebuf + sizeof namebuf - np,
			    "%sboot%s", _PATH_BOOTDIR, dkbasename);
			if (access(np, F_OK) < 0 && dkbasename[0] == 'r')
				dkbasename++;
			bootxx = np;
			(void)snprintf(bootxx, namebuf + sizeof namebuf - bootxx,
			    "%sboot%s", _PATH_BOOTDIR, dkbasename);
			np += strlen(bootxx) + 1;
		}
#endif
a780 10
#if NUMBOOT > 1
	if (read(b, boot, (int)dp->d_secsize) < 0)
		err(4, "%s", xxboot);
	(void)close(b);
	b = open(bootxx, O_RDONLY);
	if (b < 0)
		err(4, "%s", bootxx);
	if (read(b, &boot[dp->d_secsize], (int)(dp->d_bbsize-dp->d_secsize)) < 0)
		err(4, "%s", bootxx);
#else
a795 1
#endif
a1677 4
#elif NUMBOOT == 2
	Bflag = "B";
	boot = " [-b boot1] [-s boot2]";
	blank = "  ";
@


1.142
log
@Move some output under the control of the '-v' flag. In particular only
display the partition info by default as is done in the E(ditor). The
physical info is now only displayed if '-v' is specified.

ok deraadt@@
@
text
@d295 1
a295 2
			display(stdout, lp, NULL, print_unit,
			    (verbose ? SHOW_PHYSINFO : 0) | SHOW_PARTINFO);
d599 4
a602 6
			if (verbose)
				fprintf(stderr, "# Inside MBR partition %d: "
				    "type %02X start %u size %u\n",
				    part, dp[part].dp_typ,
				    letoh32(dp[part].dp_start),
				    letoh32(dp[part].dp_size));
d609 4
a612 6
			if (verbose)
				fprintf(stderr, "# Extended partition %d: "
				    "type %02X start %u size %u\n",
				    part, dp[part].dp_typ,
				    letoh32(dp[part].dp_start),
				    letoh32(dp[part].dp_size));
d1014 1
a1014 1
display(FILE *f, struct disklabel *lp, char **mp, char unit, int opts)
d1020 1
d1022 24
a1045 16
	if (opts & SHOW_PHYSINFO) {
		fprintf(f, "# %s:\n", specname);
		if ((unsigned) lp->d_type < DKMAXTYPES)
			fprintf(f, "type: %s\n", dktypenames[lp->d_type]);
		else
			fprintf(f, "type: %d\n", lp->d_type);
		fprintf(f, "disk: %.*s\n", (int)sizeof(lp->d_typename),
		    lp->d_typename);
		fprintf(f, "label: %.*s\n", (int)sizeof(lp->d_packname),
		    lp->d_packname);
		fprintf(f, "flags:");
		if (lp->d_flags & D_BADSECT)
			fprintf(f, " badsect");
		if (lp->d_flags & D_VENDOR)
			fprintf(f, " vendor");
		putc('\n', f);
d1047 18
a1064 32
		fprintf(f, "bytes/sector: %u\n", lp->d_secsize);
		fprintf(f, "sectors/track: %u\n", lp->d_nsectors);
		fprintf(f, "tracks/cylinder: %u\n", lp->d_ntracks);
		fprintf(f, "sectors/cylinder: %u\n", lp->d_secpercyl);
		fprintf(f, "cylinders: %u\n", lp->d_ncylinders);
		d = scale(DL_GETDSIZE(lp), unit, lp);
		if (d < 0)
			fprintf(f, "total sectors: %llu\n", DL_GETDSIZE(lp));
		else
			fprintf(f, "total bytes: %.*f%c\n", unit == 'B' ? 0 : 1,
			    d, unit);

		fprintf(f, "rpm: %hu\n", lp->d_rpm);
		fprintf(f, "interleave: %hu\n", lp->d_interleave);
		fprintf(f, "trackskew: %hu\n", lp->d_trackskew);
		fprintf(f, "cylinderskew: %hu\n", lp->d_cylskew);
		fprintf(f, "headswitch: %u\t\t# microseconds\n",
		    lp->d_headswitch);
		fprintf(f, "track-to-track seek: %u\t# microseconds\n",
		    lp->d_trkseek);
		fprintf(f, "drivedata: ");
		for (i = NDDATA - 1; i >= 0; i--)
			if (lp->d_drivedata[i])
				break;
		if (i < 0)
			i = 0;
		for (j = 0; j <= i; j++)
			fprintf(f, "%d ", lp->d_drivedata[j]);
		fprintf(f, "\n");
	}

	if (opts & SHOW_PARTINFO) {
a1070 1

@


1.141
log
@make -B not even show up in usage on non-NUMBOOT systems; ok jmc krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.140 2009/03/22 20:51:58 jmc Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.140 2009/03/22 20:51:58 jmc Exp $";
d295 2
a296 1
			display(stdout, lp, NULL, print_unit, 1);
d600 6
a605 4
			fprintf(stderr, "# Inside MBR partition %d: "
			    "type %02X start %u size %u\n",
			    part, dp[part].dp_typ,
			    letoh32(dp[part].dp_start), letoh32(dp[part].dp_size));
d612 6
a617 4
			fprintf(stderr, "# Extended partition %d: "
			    "type %02X start %u size %u\n",
			    part, dp[part].dp_typ,
			    letoh32(dp[part].dp_start), letoh32(dp[part].dp_size));
d1019 1
a1019 1
display(FILE *f, struct disklabel *lp, char **mp, char unit, int all)
a1024 1
	fprintf(f, "# %s:\n", specname);
d1026 47
a1072 24
	if ((unsigned) lp->d_type < DKMAXTYPES)
		fprintf(f, "type: %s\n", dktypenames[lp->d_type]);
	else
		fprintf(f, "type: %d\n", lp->d_type);
	fprintf(f, "disk: %.*s\n", (int)sizeof(lp->d_typename), lp->d_typename);
	fprintf(f, "label: %.*s\n", (int)sizeof(lp->d_packname), lp->d_packname);
	fprintf(f, "flags:");
	if (lp->d_flags & D_BADSECT)
		fprintf(f, " badsect");
	if (lp->d_flags & D_VENDOR)
		fprintf(f, " vendor");
	putc('\n', f);

	fprintf(f, "bytes/sector: %u\n", lp->d_secsize);
	fprintf(f, "sectors/track: %u\n", lp->d_nsectors);
	fprintf(f, "tracks/cylinder: %u\n", lp->d_ntracks);
	fprintf(f, "sectors/cylinder: %u\n", lp->d_secpercyl);
	fprintf(f, "cylinders: %u\n", lp->d_ncylinders);
	d = scale(DL_GETDSIZE(lp), unit, lp);
	if (d < 0)
		fprintf(f, "total sectors: %llu\n", DL_GETDSIZE(lp));
	else
		fprintf(f, "total bytes: %.*f%c\n", unit == 'B' ? 0 : 1,
		    d, unit);
d1074 1
a1074 18
	fprintf(f, "rpm: %hu\n", lp->d_rpm);
	fprintf(f, "interleave: %hu\n", lp->d_interleave);
	fprintf(f, "trackskew: %hu\n", lp->d_trackskew);
	fprintf(f, "cylinderskew: %hu\n", lp->d_cylskew);
	fprintf(f, "headswitch: %u\t\t# microseconds\n",
	    lp->d_headswitch);
	fprintf(f, "track-to-track seek: %u\t# microseconds\n",
	    lp->d_trkseek);
	fprintf(f, "drivedata: ");
	for (i = NDDATA - 1; i >= 0; i--)
		if (lp->d_drivedata[i])
			break;
	if (i < 0)
		i = 0;
	for (j = 0; j <= i; j++)
		fprintf(f, "%d ", lp->d_drivedata[j]);
	fprintf(f, "\n");
	if (all) {
d1081 1
@


1.140
log
@tweak previous;
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.139 2009/03/22 19:01:32 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.139 2009/03/22 19:01:32 krw Exp $";
d1716 1
d1719 1
d1722 1
d1739 1
d1743 1
d1745 2
a1746 2
	    "%sdisklabel -Bw [-nv]%s disk disktype [packid]    (write)\n",
	    blank, boot);
d1748 2
a1749 2
	    "%sdisklabel -BR [-nv]%s disk protofile [disktype] (restore)\n\n",
	    blank, boot);
@


1.139
log
@Add 'A' command to Editor mode, and -A flag to automatically execute it
on disks without an existing label. The 'A' command allocates all space
on the disk into a reasonable partition scheme for a root disk.

Feedback from several, time to work on it in-tree.

Prodded (repeatedly) by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.138 2009/02/15 21:07:00 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.138 2009/02/15 21:07:00 krw Exp $";
d1731 1
a1731 1
	    "       disklabel -E [-A] [-c | -d] [-nv] [-f tempfile] disk\t\t(simple editor)\n");
@


1.138
log
@Don't display, or save via the editor 's' command, the fsize and
bsize fields for UNUSED partitions. '-R' already skipped processing
these fields for such partitions. Eliminates an XXX.

ok deraadt, "makes sense" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.137 2009/01/11 19:44:57 miod Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.137 2009/01/11 19:44:57 miod Exp $";
d108 1
d149 1
a149 1
	while ((ch = getopt(argc, argv, "BEf:NRWb:cdenp:s:tvw")) != -1)
d151 3
d285 1
a285 1
		error = editor(lp, f, specname, fstabfile);
d1731 1
a1731 1
	    "       disklabel -E [-c | -d] [-nv] [-f tempfile] disk\t\t(simple editor)\n");
@


1.137
log
@On *ppc disks shared with MacOS, walk the Apple partition map to find out
the bounds of the OpenBSD area. Should prevent users from shooting themselves
in the feet.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.136 2008/08/11 19:03:05 reyk Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.136 2008/08/11 19:03:05 reyk Exp $";
d989 1
a990 6

		case FS_UNUSED:				/* XXX */
			fprintf(f, "  %5u %5u %4.4s ",
			   fsize, fsize * frag, "");
			break;

a995 1

d1000 1
@


1.136
log
@fix a6 partition lookup where a static variable was incorrectly used in
the recursive findopenbsd() function.  reported by PR 5905.

tested by many
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.135 2008/08/10 13:00:25 sobrado Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.135 2008/08/10 13:00:25 sobrado Exp $";
d120 6
d260 8
d641 54
@


1.135
log
@spacing; remove non-existent flag from synopsis.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.134 2008/08/04 15:58:13 reyk Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.134 2008/08/04 15:58:13 reyk Exp $";
d532 2
a533 1
	static int mbr[DEV_BSIZE / sizeof(int)];
d575 4
a578 2
		if (first && *first == NULL)
			*first = &dp[part];
d585 4
a588 3
			dp[part].dp_start =
			    htole32((off_t)letoh32(dp[part].dp_start) + mbroff);
			return (&dp[part]);
@


1.134
log
@fix extended partition support by handling chained EBRs correctly
(using a recursion limit).  now OpenBSD can be installed in a
subsequent DOS/Linux-compatible extended partition.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.133 2008/07/10 00:21:39 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.133 2008/07/10 00:21:39 krw Exp $";
d1654 1
a1654 1
	    "usage: disklabel [-c | -d | -t] [-v] [-p unit] disk\t(read)\n");
d1660 1
a1660 1
	    "       disklabel -E [-c | -d] [-nv] [-f tempfile] disk\t(simple editor)\n");
@


1.133
log
@Die -r, die! Eliminate stray -r in usage text. Spotted by James Hartley.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.132 2008/07/09 23:59:44 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.132 2008/07/09 23:59:44 krw Exp $";
d582 2
d585 1
d591 1
a591 1
			start = letoh32(dp[part].dp_start);
d593 1
a593 3
			if (p != NULL) {
				p->dp_start =
				    htole32(letoh32(p->dp_start) + start);
a594 1
			}
@


1.132
log
@Read 'vendor' flag from ASCII disklabel since we print it. Fixes
PR #5872.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.131 2008/07/01 04:08:53 ray Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.131 2008/07/01 04:08:53 ray Exp $";
d1662 1
a1662 1
	    "       disklabel -R [-nrv] disk protofile\t\t\t(restore)\n");
@


1.131
log
@Initialize variable before checking against NULL.

OK deraadt, otto, krw.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.130 2008/06/25 18:31:07 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.130 2008/06/25 18:31:07 otto Exp $";
d1216 2
@


1.130
log
@In interactive mode, always suggest offsets and sizes inside the
OpenBSD area and change the 'p' command to only print the boundaries
and size of the OpenBSD area and the free space within that area.
Introduce a 'l' command to print the header only. With krw@@; ok krw@@
deraadt@@; jmc@@ for the man page bits
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.129 2008/06/25 15:26:43 reyk Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.129 2008/06/25 15:26:43 reyk Exp $";
d608 1
a608 1
	struct dos_partition *dp, *first;
@


1.129
log
@allow to install and boot the OpenBSD A6 partition and disklabel in an
extended DOS partition.  the concept of extended partitions is very
simple, it is just another mbr at the partition offset (well, the
standard "EBR" is a linked list with a few limitations, but this diff
works with both variants).

this diff has been in the snapshots for a while.

with input from weingart@@ and krw@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.128 2008/06/04 01:27:54 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.128 2008/06/04 01:27:54 deraadt Exp $";
d277 1
a277 1
			display(stdout, lp, NULL, print_unit, 0, 0);
d755 1
a755 1
		if (bootbuf == 0)
d943 1
a943 2
display(FILE *f, struct disklabel *lp, char **mp, char unit, int edit,
    u_int64_t fr)
d949 1
a949 4
	if (edit)
		fprintf(f, "device: %s\n", specname);
	else
		fprintf(f, "# %s:\n", specname);
d957 7
a963 8
	if (!edit) {
		fprintf(f, "flags:");
		if (lp->d_flags & D_BADSECT)
			fprintf(f, " badsect");
		if (lp->d_flags & D_VENDOR)
			fprintf(f, " vendor");
		putc('\n', f);
	}
d976 23
a998 7
	if (edit) {
		d = scale(fr, unit, lp);
		if (d < 0)
			fprintf(f, "free sectors: %llu\n", fr);
		else
			fprintf(f, "free bytes: %.*f%c\n", unit == 'B' ? 0 : 1,
			    d, unit);
a999 24
	fprintf(f, "rpm: %hu\n", lp->d_rpm);
	if (!edit) {
		fprintf(f, "interleave: %hu\n", lp->d_interleave);
		fprintf(f, "trackskew: %hu\n", lp->d_trackskew);
		fprintf(f, "cylinderskew: %hu\n", lp->d_cylskew);
		fprintf(f, "headswitch: %u\t\t# microseconds\n",
		    lp->d_headswitch);
		fprintf(f, "track-to-track seek: %u\t# microseconds\n",
		    lp->d_trkseek);
		fprintf(f, "drivedata: ");
		for (i = NDDATA - 1; i >= 0; i--)
			if (lp->d_drivedata[i])
				break;
		if (i < 0)
			i = 0;
		for (j = 0; j <= i; j++)
			fprintf(f, "%d ", lp->d_drivedata[j]);
		fprintf(f, "\n");
	}
	fprintf(f, "\n%hu partitions:\n", lp->d_npartitions);
	fprintf(f, "#    %16.16s %16.16s  fstype [fsize bsize  cpg]\n",
	    "size", "offset");
	for (i = 0; i < lp->d_npartitions; i++)
		display_partition(f, lp, mp, i, unit);
d1016 1
a1016 1
	display(fp, lp, NULL, 0, 0, 0);
d1580 1
a1580 1
	u_long boffset;
d1583 1
a1583 1
	if (bootbuf == 0)
d1585 2
a1586 1
	boffset = bootsize / lp->d_secsize;
d1588 3
a1590 1
		part = 'a' + i;
d1593 1
d1595 2
a1596 1
		if (boffset <= DL_GETPOFFSET(pp)) {
d1599 16
a1614 9
		} else if (pp->p_fstype != FS_BOOT) {
			if (pp->p_fstype != FS_UNUSED) {
				warnx("boot overlaps used partition %c", part);
				errors++;
			} else {
				pp->p_fstype = FS_BOOT;
				warnx("warning, boot overlaps partition %c, %s",
				    part, "marked as FS_BOOT");
			}
@


1.128
log
@setbootflag() must be done before checksum'ing the label.  Bug introduced
in 1.126, found by nick during a test install;  ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.127 2008/04/07 23:37:14 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.127 2008/04/07 23:37:14 krw Exp $";
d116 1
a528 3
/*
 * Fetch DOS partition table from disk.
 */
d530 1
a530 1
readmbr(int f)
d533 1
a533 1
	struct dos_partition *dp;
d535 1
d538 4
d547 1
a547 1
	if (lseek(f, (off_t)DOSBBSECTOR * DEV_BSIZE, SEEK_SET) < 0 ||
d555 7
d568 1
a568 1
			return (0);
d572 6
a577 1
		if (letoh32(dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_OPENBSD) {
d583 13
d599 15
a613 6
	/*
	 * If there is no signature and no OpenBSD partition this is probably
	 * not an MBR.
	 */
	if (signature != DOSMBR_SIGNATURE)
		return (NULL);
d616 3
a618 5
	for (part = 0; part < NDOSPART; part++) {
		if (letoh32(dp[part].dp_size)) {
			warnx("warning, DOS partition table with no valid OpenBSD partition");
			return (&dp[part]);
		}
d620 1
@


1.127
log
@Since Alpha is NUMBOOT=0, no need for #ifdef __alpha__ code inside a
#if NUMBOOT > 0 section.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.126 2008/04/07 23:27:21 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.126 2008/04/07 23:27:21 krw Exp $";
d391 3
a398 1
	setbootflag(lp);
@


1.126
log
@Restore boot block (-B) support that was incorrectly deleted during
the -r removal. Found by drahn@@ when attempting a landisk install.

ok deraadt@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.125 2008/04/06 21:36:24 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.125 2008/04/06 21:36:24 krw Exp $";
a458 16
#ifdef __alpha__
			/*
			 * The Alpha requires that the boot block be checksummed.
			 * The first 63 8-byte quantites are summed into the 64th.
			 */
			{
				int i;
				u_int64_t *dp, sum;

				dp = (u_int64_t *)boot;
				sum = 0;
				for (i = 0; i < 63; i++)
					sum += dp[i];
				dp[63] = sum;
			}
#endif
@


1.125
log
@nwflag is never set now that '-r' is no more, so remove it and the warning
that was contingent on it being set.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.124 2008/04/06 13:10:43 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.124 2008/04/06 13:10:43 krw Exp $";
a390 3
#if NUMBOOT > 0
	setbootflag(lp);
#endif
d395 98
@


1.124
log
@Fix logic botch I introduced with r1.123 which effectively disabled
the '-c' and '-d` commands.

With the removal of 'rflag' (logically making it always false), (a ||
(rflag && cflag + dflag) || b) should be (a || b), not (a || (cflag +
dflag) || b).

This fixes 'disklabel -w -d <disk>' as used in the install scripts.

Reported by Peter Kun on misc@@. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.123 2008/03/23 19:42:17 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.123 2008/03/23 19:42:17 krw Exp $";
a110 1
int	nwflag;
a390 9
	if (nwflag) {
		warnx("DANGER! The disklabel was not found at the correct location!");
		warnx("To repair this situation, use `disklabel %s > file' to",
		    dkname);
		warnx("save it, then use `disklabel -R %s file' to replace it.",
		    dkname);
		warnx("A new disklabel is not being installed now.");
		return(0); /* Actually 1 but we want to exit */
	}
@


1.123
log
@Nuke disklabel -r. All labels come from the kernel via ioctl.

"make sense" miod@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.122 2008/01/24 12:23:35 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.122 2008/01/24 12:23:35 krw Exp $";
d233 1
a233 2
	if (argc < 1 || (cflag + dflag > 0) ||
	    (fstabfile && op != EDITOR))
@


1.122
log
@"read(..., ..., sizeof Y) < sizeof Y" is a dangerous idiom because it
does an unsigned comparison and read() can return -1. Use '!=' instead
of '<' since read() can't return more than 'sizeof Y'. Not perfect
(that would require a separate test for -1) but a very common usage.
Do the same for a write(), and a couple of read() calls which are
probably ok but why be inconsistant?

This, as the last couple of commits, found by ian@@ as a result of
poking around in fsck_msdos() when his new iPod had problems vs
OpenBSD.

Concept reviewed by miod@@, beck@@, otto@@ and ian@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.121 2008/01/21 20:07:11 sobrado Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.121 2008/01/21 20:07:11 sobrado Exp $";
a109 1
int	rflag;
d142 1
a142 1
	while ((ch = getopt(argc, argv, "BEf:NRWb:cdenp:rs:tvw")) != -1)
a192 3
		case 'r':
			++rflag;
			break;
a221 1
		rflag++;
d233 1
a233 1
	if (argc < 1 || (rflag && cflag + dflag > 0) ||
a385 24
/*
 * Convert an old disklabel to a v1 disklabel
 */
void
cvtdisklabelv1(struct disklabel *lp)
{
	int i;

	if (lp->d_version == 1)
		return;

	lp->d_version = 1;
	lp->d_secperunith = 0;
	for (i = 0; i < MAXPARTITIONS; i++) {
		struct partition *pp = &lp->d_partitions[i];
		struct __partitionv0 *v0pp = (struct __partitionv0 *)
		    &lp->d_partitions[i];

		pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(v0pp->p_fsize,
		    v0pp->p_frag);
		pp->p_offseth = 0;
		pp->p_sizeh = 0;
	}
}
a407 1
	cvtdisklabelv1(lp);
d409 4
a412 125
	if (rflag) {
#ifdef DOSLABEL
		struct partition *pp = &lp->d_partitions[2];

		/*
		 * If OpenBSD DOS partition is missing, or if
		 * the label to be written is not within partition,
		 * prompt first. Need to allow this in case operator
		 * wants to convert the drive for dedicated use.
		 * In this case, partition 'a' had better start at 0,
		 * otherwise we reject the request as meaningless. -wfj
		 */
		if (dosdp && DL_GETPSIZE(pp) && (dosdp->dp_typ == DOSPTYP_OPENBSD)) {
			sectoffset = (off_t)letoh32(dosdp->dp_start) *
			    lp->d_secsize;
		} else {
			if (dosdp) {
				int first, ch;

				printf("Erase the previous contents of the disk? [n]: ");
				fflush(stdout);
				first = ch = getchar();
				while (ch != '\n' && ch != EOF)
					ch = getchar();
				if (first != 'y' && first != 'Y')
					exit(0);
			}
			sectoffset = 0;
		}

#if NUMBOOT > 0
		/*
		 * If we are not installing a boot program
		 * we must read the current bootarea so we don't
		 * clobber the existing boot.
		 */
		if (!installboot) {
			struct disklabel tlab;

			if (lseek(f, sectoffset, SEEK_SET) < 0) {
				perror("lseek");
				return (1);
			}
			tlab = *lp;
			if (read(f, boot, tlab.d_bbsize) != tlab.d_bbsize) {
				perror("read");
				return (1);
			}
			*lp =tlab;
		}
#endif
#endif

		/*
		 * First set the kernel disk label,
		 * then write a label to the raw disk.
		 * If the SDINFO ioctl fails because it is unimplemented,
		 * keep going; otherwise, the kernel consistency checks
		 * may prevent us from changing the current (in-core)
		 * label.
		 */
		if (!donothing) {
			if (ioctl(f, DIOCSDINFO, lp) < 0 &&
			    errno != ENODEV && errno != ENOTTY) {
				l_perror("ioctl DIOCSDINFO");
				return (1);
			}
		}
		if (verbose)
			printf("writing label to block %lld (0x%qx)\n",
			    (long long)sectoffset/DEV_BSIZE,
			    (long long)sectoffset/DEV_BSIZE);
		if (!donothing) {
			if (lseek(f, sectoffset, SEEK_SET) < 0) {
				perror("lseek");
				return (1);
			}
			/*
			 * write enable label sector before write (if necessary),
			 * disable after writing.
			 */
			writeable = 1;

			if (ioctl(f, DIOCWLABEL, &writeable) < 0)
				perror("ioctl DIOCWLABEL");
#ifdef __alpha__
			/*
			 * The Alpha requires that the boot block be checksummed.
			 * The first 63 8-byte quantites are summed into the 64th.
			 */
			{
				int i;
				u_int64_t *dp, sum;

				dp = (u_int64_t *)boot;
				sum = 0;
				for (i = 0; i < 63; i++)
					sum += dp[i];
				dp[63] = sum;
			}
#endif
			if (write(f, boot, lp->d_bbsize) != lp->d_bbsize) {
				perror("write");
				return (1);
			}
		}
#if NUMBOOT > 0
		/*
		 * Output the remainder of the disklabel
		 */
		if (!donothing && bootbuf && write(f, bootbuf, bootsize) != bootsize) {
			perror("write");
			return(1);
		}
#endif
		writeable = 0;
		if (!donothing)
			if (ioctl(f, DIOCWLABEL, &writeable) < 0)
				perror("ioctl DIOCWLABEL");
	} else {
		if (!donothing) {
			if (ioctl(f, DIOCWDINFO, lp) < 0) {
				l_perror("ioctl DIOCWDINFO");
				return (1);
			}
d438 1
a438 2
		warnx("%s: No disk label on disk;\n"
		    "use \"disklabel -r\" to install initial label", s);
d521 1
a521 2
 * Fetch disklabel for disk.
 * Use ioctl to get label unless -r flag is given.
d528 6
a533 54
	if (rflag) {
		char *msg;
		off_t sectoffset = 0;

#ifdef DOSLABEL
		if (dosdp && letoh32(dosdp->dp_size) &&
		    (dosdp->dp_typ == DOSPTYP_OPENBSD))
			sectoffset = (off_t)letoh32(dosdp->dp_start) *
			    DEV_BSIZE;
#endif
		if (verbose)
			printf("reading label from block %lld, offset %lld\n",
			    (long long)sectoffset/DEV_BSIZE,
			    sectoffset/DEV_BSIZE +
			    (LABELSECTOR * DEV_BSIZE) + LABELOFFSET);
		if (lseek(f, sectoffset, SEEK_SET) < 0 ||
		    read(f, bootarea, BBSIZE) != BBSIZE)
			err(4, "%s", specname);

		lp = (struct disklabel *)(bootarea +
			(LABELSECTOR * DEV_BSIZE) + LABELOFFSET);
		if (lp->d_magic == DISKMAGIC &&
		    lp->d_magic2 == DISKMAGIC) {
			if (lp->d_npartitions <= MAXPARTITIONS &&
			    dkcksum(lp) == 0) {
				cvtdisklabelv1(lp);
				return (lp);
			}

			msg = "disk label corrupted";
		}
		else {
			warnx("no disklabel found. scanning.");
		}
		nwflag++;

		msg = "no disk label";
		for (lp = (struct disklabel *)bootarea;
		    lp <= (struct disklabel *)(bootarea + BBSIZE - sizeof(*lp));
		    lp = (struct disklabel *)((char *)lp + sizeof(long))) {
			if (lp->d_magic == DISKMAGIC &&
			    lp->d_magic2 == DISKMAGIC) {
				if (lp->d_npartitions <= MAXPARTITIONS &&
				    dkcksum(lp) == 0) {
					warnx("found at 0x%lx",
					    (long)((char *)lp - bootarea));
					cvtdisklabelv1(lp);
					return (lp);
				}
				msg = "disk label corrupted";
			}
		}
		warnx("%s", msg);
		return(NULL);
d535 3
a537 11
		if (cflag && ioctl(f, DIOCRLDINFO) < 0)
			err(4, "ioctl DIOCRLDINFO");
		if (dflag) {
			lp = &lab;
			if (ioctl(f, DIOCGPDINFO, lp) < 0)
				err(4, "ioctl DIOCGPDINFO");
		} else {
			lp = &lab;
			if (ioctl(f, DIOCGDINFO, lp) < 0)
				err(4, "ioctl DIOCGDINFO");
		}
d539 1
d574 1
a574 8
	if (!installboot) {
#ifndef __i386__
		if (rflag) {
			if (read(f, boot, BBSIZE) != BBSIZE)
				err(4, "%s", specname);
			memset(lp, 0, sizeof *lp);
		}
#endif
a575 1
	}
d1547 1
a1547 1
	    "usage: disklabel [-c | -d | -r | -t] [-v] [-p unit] disk\t(read)\n");
d1549 1
a1549 1
	    "       disklabel -w [-c | -d | -r] [-nv] disk disktype [packid]\t(write)\n");
d1551 1
a1551 1
	    "       disklabel -e [-c | -d | -r] [-nv] disk\t\t\t(edit)\n");
d1553 1
a1553 1
	    "       disklabel -E [-c | -d | -r] [-nv] [-f tempfile] disk\t(simple editor)\n");
@


1.121
log
@changes to disklabel's usage:

  - align usages and their descriptions (text enclosed in brackets);
  - blank[], used for padding prior to r1.86, can improve readability
    of usage on 80-column displays if NUMBOOT == 2

ok jsing@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.120 2007/10/17 20:02:30 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.120 2007/10/17 20:02:30 deraadt Exp $";
d575 1
a575 1
				if (write(f, boot, lp->d_secsize) < lp->d_secsize)
d627 1
a627 1
	    read(f, mbr, sizeof(mbr)) < sizeof(mbr))
d697 1
a697 1
		    read(f, bootarea, BBSIZE) < BBSIZE)
d785 1
a785 1
			if (read(f, boot, BBSIZE) < BBSIZE)
@


1.120
log
@- Be more careful about pre-existing SIGCHLD handlers (or SIG_IGN) by
  temporarily restoring default behaviour.  This is not 100% ideal.
  But this fixes editor handling in mail... bah, it is really unfortunate
  that got broken
- refactor the restoration code as well, to make it simpler
ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.119 2007/10/15 02:16:35 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.119 2007/10/15 02:16:35 deraadt Exp $";
d1753 1
a1753 1
	char blank[] = "                             ";
d1759 1
a1760 1
	blank[strlen(boot)] = '\0';
a1761 1
	fprintf(stderr, "usage:\n");
d1763 1
a1763 1
	    "  disklabel [-c | -d | -r | -t] [-v] [-p unit] disk\t\t(read)\n");
d1765 1
a1765 1
	    "  disklabel -w [-c | -d | -r] [-nv] disk disktype [packid]\t(write)\n");
d1767 1
a1767 1
	    "  disklabel -e [-c | -d | -r] [-nv] disk\t\t\t(edit)\n");
d1769 1
a1769 1
	    "  disklabel -E [-c | -d | -r] [-nv] [-f tempfile] disk\t\t(simple editor)\n");
d1771 1
a1771 1
	    "  disklabel -R [-nrv] disk protofile\t\t\t\t(restore)\n");
d1773 1
a1773 1
	    "  disklabel -N | -W [-nv] disk\t\t\t\t\t(protect)\n\n");
d1775 2
a1776 2
	    "  disklabel -B  [-nv]%s disk [disktype]\t       (boot)\n",
	    boot);
d1778 2
a1779 2
	    "  disklabel -Bw [-nv]%s disk disktype [packid]     (write)\n",
	    boot);
d1781 2
a1782 2
	    "  disklabel -BR [-nv]%s disk protofile [disktype]  (restore)\n\n",
	    boot);
@


1.119
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.118 2007/06/25 22:53:45 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.118 2007/06/25 22:53:45 deraadt Exp $";
d1195 1
a1195 1
	sig_t sighup, sigint, sigquit;
d1197 1
a1197 1
	int saved_errno, st;
d1211 1
d1221 1
a1221 5
	free(p);
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	if (!WIFEXITED(st)) {
d1223 2
a1224 3
		return (-1);
	}
	return (WEXITSTATUS(st));
d1231 1
d1234 1
a1234 1
	return (-1);
@


1.118
log
@some trivial delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.117 2007/06/23 19:14:20 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.117 2007/06/23 19:14:20 deraadt Exp $";
d1493 1
a1493 1
			unsigned part = *cp - 'a';
@


1.117
log
@expand size/offset to 16 characters, and drop the Cyl comments which
noone cares to see anymore (for those architectures where this is
important, disklabel(8) continues to enfoce the cyl-locked policy)
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.116 2007/06/18 22:07:43 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.116 2007/06/18 22:07:43 krw Exp $";
d98 1
a130 1
void	setbootflag(struct disklabel *);
d314 1
a314 1
		else	
d412 1
a412 1
		pp->p_sizeh = 0;	
d452 1
a452 1
		        sectoffset = (off_t)letoh32(dosdp->dp_start) *
d624 1
a624 1
         */
d1015 1
d1054 1
a1054 1
     u_int64_t fr)
d1265 1
a1265 1
#define GETNUM(field, nptr, min, errstr) 				\
d1267 2
a1268 2
		sizeof(field) == 8 ? LLONG_MAX : 			\
		(sizeof(field) == 4 ? UINT_MAX : 			\
@


1.116
log
@If disklabel(8) is run against unreadable media (e.g. a blank cd)
don't say "can't read master boot record". Just display an empty
disklabel. Really yucky code that needs a lot of tough love, but
marginally less confusing until then.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.115 2007/06/18 21:06:51 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.115 2007/06/18 21:06:51 krw Exp $";
d1016 1
a1016 1
			fprintf(f, "  %c: %13llu %13llu ", 'a' + i,
d1019 1
a1019 1
			fprintf(f, "  %c: %12.*f%c %12.*f%c ", 'a' + i,
a1045 15
		} else if (lp->d_secpercyl) {
			fprintf(f, "# Cyl %5llu",
			    DL_GETPOFFSET(pp) / lp->d_secpercyl);
			if (DL_GETPOFFSET(pp) % lp->d_secpercyl)
				putc('*', f);
			else
				putc(' ', f);
			fprintf(f, "-%6llu",
			    (DL_GETPOFFSET(pp) +
			    DL_GETPSIZE(pp) + lp->d_secpercyl - 1) /
			    lp->d_secpercyl - 1);
			if ((DL_GETPOFFSET(pp) + DL_GETPSIZE(pp)) % lp->d_secpercyl)
				putc('*', f);
			else
				putc(' ', f);
d1118 1
a1118 1
	fprintf(f, "#    %13.13s %13.13s  fstype [fsize bsize  cpg]\n",
@


1.115
log
@-r will die. Until then, make sure any labels it dredges up are
converted to v1 format before being used.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.114 2007/06/17 00:32:21 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.114 2007/06/17 00:32:21 deraadt Exp $";
d253 1
a253 1
	 * return 0. If valid partition table present, but no
d628 1
a628 1
		err(4, "can't read master boot record");
@


1.114
log
@On Sun machines, disklabels coming from the kernel will now have a d_flags
bit D_VENDOR if they face the Sun cylinder / start-at-zero semantics.  Other
disklabels found on these architectures do not have these issues, and do
not need to be constrained.  checked by otto
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.113 2007/06/08 19:08:35 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.113 2007/06/08 19:08:35 otto Exp $";
d705 2
a706 1
			    dkcksum(lp) == 0)
d708 1
d727 1
@


1.113
log
@second pass, some fields slipped through the first time around
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.112 2007/06/08 18:42:17 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.112 2007/06/08 18:42:17 otto Exp $";
d1086 2
d1661 9
a1669 7
#ifdef CYLCHECK
		if (i != RAW_PART && DL_GETPSIZE(pp) % lp->d_secpercyl)
			warnx("warning, partition %c: size %% cylinder-size != 0",
			    part);
		if (i != RAW_PART && DL_GETPOFFSET(pp) % lp->d_secpercyl)
			warnx("warning, partition %c: offset %% cylinder-size != 0",
			    part);
d1671 3
a1673 2
#ifdef AAT0
		if (i == 0 && DL_GETPSIZE(pp) != 0 && DL_GETPOFFSET(pp) != 0) {
@


1.112
log
@Make disklabel(8) aware of the new fields, allowing for larger than
2T disks, partitions and offsets. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.111 2007/06/07 19:51:08 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.111 2007/06/07 19:51:08 deraadt Exp $";
d906 1
a906 1
	(void)fprintf(f, "su#%u:", lp->d_secperunit);
d1629 2
a1630 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = lp->d_secpercyl * lp->d_ncylinders;
d1634 1
a1634 1
		&& lp->d_secperunit > dosdp->dp_start + dosdp->dp_size) {
d1637 1
a1637 1
		lp->d_secperunit = dosdp->dp_start + dosdp->dp_size;
@


1.111
log
@do not complain about c not being a multiple of lp->d_secpercyl; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.110 2007/05/29 06:28:15 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.110 2007/05/29 06:28:15 otto Exp $";
d132 1
a132 1
u_int32_t getnum(char *, u_int32_t, u_int32_t, const char **);
d206 1
a206 1
			if (strchr("bckmg", optarg[0]) == NULL ||
d451 1
a451 1
		if (dosdp && pp->p_size && (dosdp->dp_typ == DOSPTYP_OPENBSD)) {
d568 1
a568 1
		daddr_t alt;
d573 1
a573 2
			(void)lseek(f, (off_t)((alt + i) * lp->d_secsize),
			    SEEK_SET);
d937 1
a937 1
		if (pp->p_size) {
d941 2
a942 2
			(void)fprintf(f, "p%c#%u:", c, pp->p_size);
			(void)fprintf(f, "o%c#%u:", c, pp->p_offset);
d973 1
a973 1
scale(u_int32_t sz, char unit, struct disklabel *lp)
d990 2
d1007 3
a1009 3
	p_size = scale(pp->p_size, unit, lp);
	p_offset = scale(pp->p_offset, unit, lp);
	if (pp->p_size) {
d1013 2
a1014 2
			fprintf(f, "  %c: %13u %13u ", 'a' + i,
			    pp->p_size, pp->p_offset);
d1044 3
a1046 3
			fprintf(f, "# Cyl %5u",
			    pp->p_offset / lp->d_secpercyl);
			if (pp->p_offset % lp->d_secpercyl)
d1050 3
a1052 3
			fprintf(f, "-%6u",
			    (pp->p_offset +
			    pp->p_size + lp->d_secpercyl - 1) /
d1054 1
a1054 1
			if ((pp->p_offset + pp->p_size) % lp->d_secpercyl)
d1065 1
a1065 1
     u_int32_t fr)
d1093 1
a1093 1
	d = scale(lp->d_secperunit, unit, lp);
d1095 1
a1095 1
		fprintf(f, "total sectors: %u\n", lp->d_secperunit);
d1103 1
a1103 1
			fprintf(f, "free sectors: %u\n", fr);
d1276 3
a1278 2
		sizeof(field) == 4 ? UINT_MAX : 			\
		(sizeof(field) == 2 ? USHRT_MAX : UCHAR_MAX),  (errstr))
d1280 2
a1281 2
u_int32_t
getnum(char *nptr, u_int32_t min, u_int32_t max, const char **errstr)
d1284 1
a1284 1
	u_int32_t ret;
d1309 1
d1311 1
d1438 1
a1438 1
			v = GETNUM(lp->d_secperunit, tp, 1, &errstr);
d1442 3
a1444 2
			} else
				lp->d_secperunit = v;
d1523 1
a1523 1
			NXTNUM(v, pp->p_size, &errstr);
d1528 4
a1531 3
			} else
				pp->p_size = v;
			NXTNUM(v, pp->p_offset, &errstr);
d1536 3
a1538 2
			} else
				pp->p_offset = v;
d1656 3
a1658 3
		if (pp->p_size == 0 && pp->p_offset != 0)
			warnx("warning, partition %c: size 0, but offset %d",
			    part, pp->p_offset);
d1660 1
a1660 1
		if (i != RAW_PART && pp->p_size % lp->d_secpercyl)
d1663 1
a1663 1
		if (i != RAW_PART && pp->p_offset % lp->d_secpercyl)
d1668 1
a1668 1
		if (i == 0 && pp->p_size != 0 && pp->p_offset != 0) {
d1674 1
a1674 1
		if (pp->p_offset > lp->d_secperunit) {
d1678 1
a1678 1
		if (pp->p_offset + pp->p_size > lp->d_secperunit) {
d1693 3
a1695 3
		if (pp->p_size || pp->p_offset)
			warnx("warning, unused partition %c: size %d offset %d",
			    'a' + i, pp->p_size, pp->p_offset);
d1721 1
a1721 1
		if (pp->p_size == 0)
d1723 1
a1723 1
		if (boffset <= pp->p_offset) {
@


1.110
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.109 2007/05/24 13:01:23 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.109 2007/05/24 13:01:23 krw Exp $";
d1653 1
a1653 1
		if (pp->p_size % lp->d_secpercyl)
d1656 1
a1656 1
		if (pp->p_offset % lp->d_secpercyl)
@


1.109
log
@Make 'disklabel -w -d <disk>' work. i.e. write the default disklabel
onto disk.  More elegant than "dd if=/dev/zero of= ..." to clear out
an old disklabel.  Think of it as treating the spoofed disklabel
created by readdisklabel() like an automatically generated disktab
entry. Makes some install scripts (macppc to start) easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.108 2007/05/13 14:19:18 ray Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.108 2007/05/13 14:19:18 ray Exp $";
d391 25
d437 1
d959 3
a961 2
				    pp->p_fsize * pp->p_frag);
				(void)fprintf(f, "f%c#%u:", c, pp->p_fsize);
d1009 2
d1026 1
a1026 1
			    pp->p_fsize, pp->p_fsize * pp->p_frag, "");
d1031 1
a1031 1
			    pp->p_fsize, pp->p_fsize * pp->p_frag,
d1306 1
a1306 1
	u_int32_t v;
d1559 2
a1560 2
				NXTNUM(pp->p_fsize, pp->p_fsize, &errstr);
				if (pp->p_fsize == 0)
d1563 2
a1564 1
				pp->p_frag = v / pp->p_fsize;
d1568 2
a1569 2
				NXTNUM(pp->p_fsize, pp->p_fsize, &errstr);
				if (pp->p_fsize == 0)
d1572 2
a1573 1
				pp->p_frag = v / pp->p_fsize;
d1676 1
d1681 1
@


1.108
log
@Sync editit() with sendbug.

OK krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.107 2007/04/26 22:42:11 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.107 2007/04/26 22:42:11 krw Exp $";
d309 4
a312 1
		if (argc < 2 || argc > 3)
d314 2
a315 1
		makelabel(argv[1], argc == 3 ? argv[2] : NULL, &lab);
@


1.107
log
@Eliminate CPU_BIOS from userland and wd(4) by always using the BIOS
geometry in the disklabel when there is a BIOS geometry to provide.
This removes the option to set a disklabel to 'BIOS' geometry via the
'g b' command in the editor.

Makes reported geometry more consistant and moves MD code to MD land
where it should be.

Doc help from jmc@@, Feedback from millert@@, marco@@, weingart@@,
kettenis@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.106 2007/04/26 02:43:29 ray Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.106 2007/04/26 02:43:29 ray Exp $";
d1160 6
d1172 1
a1172 1
	int st;
a1182 1
 top:
d1186 2
a1187 14
	if ((pid = fork()) == -1) {
		int saved_errno = errno;

		(void)signal(SIGHUP, sighup);
		(void)signal(SIGINT, sigint);
		(void)signal(SIGQUIT, sigquit);
		if (saved_errno == EAGAIN) {
			sleep(1);
			goto top;
		}
		free(p);
		errno = saved_errno;
		return (-1);
	}
d1192 3
a1195 7
	for (;;) {
		if (waitpid(pid, &st, 0) == -1) {
			if (errno != EINTR)
				return (-1);
		} else
			break;
	}
d1199 2
a1200 2
	if (!WIFEXITED(st) || WEXITSTATUS(st) != 0) {
		errno = ECHILD;
d1203 10
a1212 1
	return (0);
@


1.106
log
@Copy sendbug's editit() to disklabel.

OK krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.105 2007/02/24 03:33:27 ray Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.105 2007/02/24 03:33:27 ray Exp $";
d605 2
a606 3
	 * Don't (yet) know disk geometry (BIOS), use
	 * partition table to find OpenBSD partition, and obtain
	 * disklabel from there.
a1598 1
	/* XXX should also check geometry against BIOS's idea */
@


1.105
log
@Correct comment calling FILE *f a file descriptor.

OK krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.103 2006/10/14 19:16:39 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.103 2006/10/14 19:16:39 krw Exp $";
d125 1
a125 1
int	editit(void);
d1126 1
a1126 1
		if (!editit())
d1162 1
a1162 1
editit(void)
d1164 2
d1167 1
a1167 3
	int stat = 0;
	char *argp[] = {"sh", "-c", NULL, NULL};
	char *ed, *p;
d1169 4
a1172 1
	if ((ed = getenv("EDITOR")) == NULL)
d1174 2
a1175 4
	if (asprintf(&p, "%s %s", ed, tmpfil) == -1) {
		warn("failed to start editor");
		return (0);
	}
d1178 17
a1194 12
	/* Turn off signals. */
	(void)signal(SIGHUP, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGQUIT, SIG_IGN);
	while ((pid = fork()) < 0) {
		if (errno != EAGAIN) {
			warn("fork");
			free(p);
			stat = 1;
			goto bail;
		}
		sleep(1);
d1202 14
a1215 17
		if (waitpid(pid, (int *)&stat, WUNTRACED) == -1) {
			if (errno == EINTR)
				continue;
			if (errno == ECHILD)
				stat = 1;
			break;
		}
		if (WIFSTOPPED(stat))
			raise(WSTOPSIG(stat));
		else if (WIFEXITED(stat))
			break;
	}
bail:
	(void)signal(SIGHUP, SIG_DFL);
	(void)signal(SIGINT, SIG_DFL);
	(void)signal(SIGQUIT, SIG_DFL);
	return (!stat);
@


1.104
log
@Change hard coded numbers to sizeof(buf).  Also change some
sizeof(buf) - 1 to sizeof(buf), since fgets takes the whole buffer size.

Based on diff from Charles Longeau <chl at tuxfamily dot org> long ago.

OK millert@@.
@
text
@d1261 1
a1261 1
 * Read an ascii label in from fd f,
@


1.103
log
@Friends don't let friends look for disklabels in Free/NetBSD MBR
partitions since the kernel doesn't put them or look for them there
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.102 2006/10/14 18:26:55 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.102 2006/10/14 18:26:55 krw Exp $";
d1277 1
a1277 1
	while (fgets(line, sizeof(line) - 1, f)) {
@


1.102
log
@Friends don't let friends look for disklabels in Free/NetBSD MBR
partitions since the kernel doesn't put them or look for them there
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.101 2006/09/27 00:40:43 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.101 2006/09/27 00:40:43 krw Exp $";
d659 1
a659 3
		    (dosdp->dp_typ == DOSPTYP_OPENBSD ||
		    dosdp->dp_typ == DOSPTYP_FREEBSD ||
		    dosdp->dp_typ == DOSPTYP_NETBSD))
d1591 1
a1591 3
	    (dosdp->dp_typ == DOSPTYP_OPENBSD ||
	    dosdp->dp_typ == DOSPTYP_FREEBSD ||
	    dosdp->dp_typ == DOSPTYP_NETBSD)) {
@


1.101
log
@Oops. Missed a line. Fix so disklabel(8) compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.100 2006/09/26 23:33:04 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.100 2006/09/26 23:33:04 krw Exp $";
d421 1
a421 4
		if (dosdp && pp->p_size &&
		    (dosdp->dp_typ == DOSPTYP_OPENBSD ||
		    dosdp->dp_typ == DOSPTYP_FREEBSD ||
		    dosdp->dp_typ == DOSPTYP_NETBSD)) {
a616 18
			fprintf(stderr, "# Inside MBR partition %d: "
			    "type %02X start %u size %u\n",
			    part, dp[part].dp_typ,
			    letoh32(dp[part].dp_start), letoh32(dp[part].dp_size));
			return (&dp[part]);
		}
	}
	for (part = 0; part < NDOSPART; part++) {
		if (letoh32(dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_FREEBSD) {
			fprintf(stderr, "# Inside MBR partition %d: "
			    "type %02X start %u size %u\n",
			    part, dp[part].dp_typ,
			    letoh32(dp[part].dp_start), letoh32(dp[part].dp_size));
			return (&dp[part]);
		}
	}
	for (part = 0; part < NDOSPART; part++) {
		if (letoh32(dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_NETBSD) {
@


1.100
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.99 2006/09/24 20:29:52 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.99 2006/09/24 20:29:52 krw Exp $";
d1335 1
a1335 1
				else if (!strcmp(cp, "badsect"))
@


1.99
log
@Eliminate D_CHAIN, D_ECC and D_RAMDISK flags from disklabel. They were
not being used in the tree for anything obviously useful. Get it done
early so we can find if there are non-obvious uses out there.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.98 2006/07/01 16:50:33 krw Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.98 2006/07/01 16:50:33 krw Exp $";
a1073 2
		if (lp->d_flags & D_REMOVABLE)
			fprintf(f, " removable");
a1334 2
				if (!strcmp(cp, "removable"))
					v |= D_REMOVABLE;
@


1.98
log
@Eliminate redundant get_le() in favour of letoh32(). Add letoh32()
calls in alpha, hppa, hppa64 and mips63 when accessing the two DOS MBR
u_int32_t fields dp_size and dp_start.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.97 2005/11/13 20:27:10 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.97 2005/11/13 20:27:10 deraadt Exp $";
a1075 2
		if (lp->d_flags & D_ECC)
			fprintf(f, " ecc");
a1338 2
				else if (!strcmp(cp, "ecc"))
					v |= D_ECC;
@


1.97
log
@missing fclose(); from dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.96 2005/11/12 13:27:59 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.96 2005/11/12 13:27:59 deraadt Exp $";
d425 1
a425 1
		        sectoffset = (off_t)get_le(&dosdp->dp_start) *
d619 1
a619 1
		if (get_le(&dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_OPENBSD) {
d623 1
a623 1
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_size));
d628 1
a628 1
		if (get_le(&dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_FREEBSD) {
d632 1
a632 1
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_size));
d637 1
a637 1
		if (get_le(&dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_NETBSD) {
d641 1
a641 1
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_size));
d655 1
a655 1
		if (get_le(&dp[part].dp_size)) {
d679 1
a679 1
		if (dosdp && get_le(&dosdp->dp_size) &&
d683 1
a683 1
			sectoffset = (off_t)get_le(&dosdp->dp_start) *
@


1.96
log
@use snprintf; ok cloder dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.95 2005/04/30 07:09:37 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.95 2005/04/30 07:09:37 deraadt Exp $";
d300 1
@


1.95
log
@Better header at the top:
 # Inside MBR partition 3: type A6 start 2570463 size 75569697
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.94 2005/01/07 21:58:14 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.94 2005/01/07 21:58:14 otto Exp $";
d1191 1
a1191 1
	int stat = 0, len;
d1197 1
a1197 3
	len = strlen(ed) + 1 + strlen(tmpfil) + 1;
	p = (char *)malloc(len);
	if (!p) {
a1200 1
	snprintf(p, len, "%s %s", ed, tmpfil);
@


1.94
log
@Print disk size and free space in requested unit. Some refactoring to
avoid code duplication as well. ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.93 2004/10/04 15:09:41 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.93 2004/10/04 15:09:41 otto Exp $";
d619 4
a622 5
			fprintf(stderr, "# using MBR partition %d: "
			    "type %02X off %u (0x%x) size %u (0x%x)\n", part,
			    dp[part].dp_typ,
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
			    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size));
d628 4
a631 5
			fprintf(stderr, "# using MBR partition %d: "
			    "type %02X off %u (0x%x) size %u (0x%x)\n", part,
			    dp[part].dp_typ,
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
			    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size));
d637 4
a640 5
			fprintf(stderr, "# using MBR partition %d: "
			    "type %02X off %u (0x%x) size %u (0x%x)\n", part,
			    dp[part].dp_typ,
			    get_le(&dp[part].dp_start), get_le(&dp[part].dp_start),
			    get_le(&dp[part].dp_size), get_le(&dp[part].dp_size));
@


1.93
log
@Allow one more char for fstype, to avoid truncation of ISO9660 fstype.
spotted by and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.92 2004/09/28 17:57:46 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.92 2004/09/28 17:57:46 otto Exp $";
d283 1
a283 1
			display(stdout, lp, print_unit);
d968 23
d1001 2
a1002 30
	unit = toupper(unit);
	p_size = -1.0;			/* no conversion by default */
	p_offset = 0.0;
	switch (unit) {
	case 'B':
		p_size = (double)pp->p_size * lp->d_secsize;
		p_offset = (double)pp->p_offset * lp->d_secsize;
		break;

	case 'C':
		p_size = (double)pp->p_size / lp->d_secpercyl;
		p_offset = (double)pp->p_offset / lp->d_secpercyl;
		break;

	case 'K':
		p_size = (double)pp->p_size / (1024 / lp->d_secsize);
		p_offset = (double)pp->p_offset / (1024 / lp->d_secsize);
		break;

	case 'M':
		p_size = (double)pp->p_size / ((1024*1024) / lp->d_secsize);
		p_offset = (double)pp->p_offset / ((1024*1024) / lp->d_secsize);
		break;

	case 'G':
		p_size = (double)pp->p_size / ((1024*1024*1024) / lp->d_secsize);
		p_offset = (double)pp->p_offset / ((1024*1024*1024) / lp->d_secsize);
		break;
	}

d1056 2
a1057 1
display(FILE *f, struct disklabel *lp, char unit)
d1060 7
a1067 1
	fprintf(f, "# %s:\n", specname);
d1074 10
a1083 8
	fprintf(f, "flags:");
	if (lp->d_flags & D_REMOVABLE)
		fprintf(f, " removable");
	if (lp->d_flags & D_ECC)
		fprintf(f, " ecc");
	if (lp->d_flags & D_BADSECT)
		fprintf(f, " badsect");
	putc('\n', f);
d1089 15
a1103 1
	fprintf(f, "total sectors: %u\n", lp->d_secperunit);
d1105 19
a1123 15
	fprintf(f, "interleave: %hu\n", lp->d_interleave);
	fprintf(f, "trackskew: %hu\n", lp->d_trackskew);
	fprintf(f, "cylinderskew: %hu\n", lp->d_cylskew);
	fprintf(f, "headswitch: %u\t\t# microseconds\n", lp->d_headswitch);
	fprintf(f, "track-to-track seek: %u\t# microseconds\n",
	    lp->d_trkseek);
	fprintf(f, "drivedata: ");
	for (i = NDDATA - 1; i >= 0; i--)
		if (lp->d_drivedata[i])
			break;
	if (i < 0)
		i = 0;
	for (j = 0; j <= i; j++)
		fprintf(f, "%d ", lp->d_drivedata[j]);
	fprintf(f, "\n\n%hu partitions:\n", lp->d_npartitions);
d1127 1
a1127 1
		display_partition(f, lp, NULL, i, unit);
d1144 1
a1144 1
	display(fp, lp, 0);
@


1.92
log
@Tidy disklabel output for todays big disks. Based on a diff from f
at obiit dot org in PR 3847. ok tedu@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.91 2004/09/18 23:23:17 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.91 2004/09/18 23:23:17 deraadt Exp $";
d1017 1
a1017 1
			fprintf(f, "%6.6s", fstypenames[pp->p_fstype]);
d1019 1
a1019 1
			fprintf(f, "%6d", pp->p_fstype);
d1023 1
a1023 1
			fprintf(f, "  %5u %5u %5.5s ",
d1028 1
a1028 1
			fprintf(f, "  %5u %5u %5hu ",
d1034 1
a1034 1
			fprintf(f, "%20.20s", "");
d1102 1
a1102 1
	fprintf(f, "#    %13.13s %13.13s fstype [fsize bsize   cpg]\n",
@


1.91
log
@remove unused var, and then fix the code to watch for waitpid() errors
ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.90 2004/08/08 19:04:25 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.90 2004/08/08 19:04:25 deraadt Exp $";
a123 6
struct disklabel *readlabel(int);
struct disklabel *makebootarea(char *, struct disklabel *, int);
void	display(FILE *, struct disklabel *, char);
void	display_partition(FILE *, struct disklabel *, char **, int, char, int);
int	width_partition(struct disklabel *, int);
int	editor(struct disklabel *, int, char *, char *);
a128 1
int	checklabel(struct disklabel *);
d132 1
a132 1
u_short	dkcksum(struct disklabel *);
a967 11
int
width_partition(struct disklabel *lp, int unit)
{
	unit = toupper(unit);
	switch (unit) {
	case 'K':
		return 10;
	}
	return 8;
}

d973 1
a973 1
    char unit, int width)
a977 2
	if (width == 0)
		width = 8;
d1010 2
a1011 2
			fprintf(f, "  %c: %*u %*u  ", 'a' + i,
			    width, pp->p_size, width, pp->p_offset);
d1013 3
a1015 2
			fprintf(f, "  %c: %*.1f%c %*.1f%c  ", 'a' + i,
			    width-1, p_size, unit, width-1, p_offset, unit);
d1017 1
a1017 1
			fprintf(f, "%8.8s", fstypenames[pp->p_fstype]);
d1019 1
a1019 1
			fprintf(f, "%8d", pp->p_fstype);
d1023 1
a1023 1
			fprintf(f, "    %5u %5u %5.5s ",
d1028 1
a1028 1
			fprintf(f, "    %5u %5u %5hu ",
d1034 1
a1034 1
			fprintf(f, "%22.22s", "");
d1039 1
a1039 1
				fprintf(f, " # %s", mp[i]);
d1041 1
a1041 1
			fprintf(f, "\t# (Cyl. %4u",
d1047 1
a1047 1
			fprintf(f, "- %u",
d1053 2
a1054 1
			putc(')', f);
a1063 1
	int width;
d1102 2
a1103 4
	width = width_partition(lp, 0);
	fprintf(f,
	    "#    %*.*s %*.*s    fstype   [fsize bsize   cpg]\n",
	    width, width, "size", width, width, "offset");
d1105 1
a1105 1
		display_partition(f, lp, NULL, i, unit, width);
@


1.90
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.89 2004/08/03 09:30:11 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.89 2004/08/03 09:30:11 otto Exp $";
d1192 2
a1193 2
	pid_t pid, xpid;
	int stat, len;
d1227 7
a1233 1
		xpid = waitpid(pid, (int *)&stat, WUNTRACED);
@


1.89
log
@Handle geometry parameters as unsigned quantities, getting rid of
negative number of sectors on large disks and other similar problems.
Also make reading of ASCII disk labels more robust by using strtonum(3)
instead of atoi(3).

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.88 2004/05/20 23:23:46 marco Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.88 2004/05/20 23:23:46 marco Exp $";
d1357 1
a1357 1
				if (errstr) 
@


1.88
log
@Typo from Jared Yanovich phirerunner@@comcast.net
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.87 2004/04/07 14:09:35 aaron Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.87 2004/04/07 14:09:35 aaron Exp $";
d58 1
d305 2
d627 1
a627 1
			    "type %02X off %d (0x%x) size %d (0x%x)\n", part,
d637 1
a637 1
			    "type %02X off %d (0x%x) size %d (0x%x)\n", part,
d647 1
a647 1
			    "type %02X off %d (0x%x) size %d (0x%x)\n", part,
d913 1
a913 1
		(void)fprintf(f, "%srm#%d:", did, lp->d_rpm);
d917 1
a917 1
		(void)fprintf(f, "%sil#%d:", did, lp->d_interleave);
d921 1
a921 1
		(void)fprintf(f, "%ssk#%d:", did, lp->d_trackskew);
d925 1
a925 1
		(void)fprintf(f, "%scs#%d:", did, lp->d_cylskew);
d1042 1
a1042 1
			fprintf(f, "    %5d %5d %5.5s ",
d1047 1
a1047 1
			fprintf(f, "    %5d %5d %5d ",
d1060 1
a1060 1
			fprintf(f, "\t# (Cyl. %4d",
d1099 13
a1111 14
	fprintf(f, "bytes/sector: %ld\n", (long)lp->d_secsize);
	fprintf(f, "sectors/track: %ld\n", (long)lp->d_nsectors);
	fprintf(f, "tracks/cylinder: %ld\n", (long)lp->d_ntracks);
	fprintf(f, "sectors/cylinder: %ld\n", (long)lp->d_secpercyl);
	fprintf(f, "cylinders: %ld\n", (long)lp->d_ncylinders);
	fprintf(f, "total sectors: %ld\n", (long)lp->d_secperunit);
	fprintf(f, "rpm: %ld\n", (long)lp->d_rpm);
	fprintf(f, "interleave: %ld\n", (long)lp->d_interleave);
	fprintf(f, "trackskew: %ld\n", (long)lp->d_trackskew);
	fprintf(f, "cylinderskew: %ld\n", (long)lp->d_cylskew);
	fprintf(f, "headswitch: %ld\t\t# microseconds\n",
	    (long)lp->d_headswitch);
	fprintf(f, "track-to-track seek: %ld\t# microseconds\n",
	    (long)lp->d_trkseek);
d1120 1
a1120 1
	fprintf(f, "\n\n%d partitions:\n", lp->d_npartitions);
d1264 21
d1294 1
d1297 2
a1298 1
	int v, lineno = 0, errors = 0;
d1327 2
a1328 2
			v = atoi(tp);
			if ((unsigned)v >= DKMAXTYPES)
d1356 5
a1360 1
				lp->d_drivedata[i++] = atoi(cp);
d1366 1
a1366 1
			if (v == 0 || (unsigned)v > MAXPARTITIONS) {
d1385 2
a1386 2
			v = atoi(tp);
			if (v <= 0 || (v % 512) != 0) {
d1394 2
a1395 2
			v = atoi(tp);
			if (v <= 0) {
d1403 2
a1404 2
			v = atoi(tp);
			if (v <= 0) {
d1412 2
a1413 2
			v = atoi(tp);
			if (v <= 0) {
d1421 2
a1422 2
			v = atoi(tp);
			if (v <= 0) {
d1430 2
a1431 2
			v = atoi(tp);
			if (v <= 0) {
d1439 2
a1440 2
			v = atoi(tp);
			if (v <= 0) {
d1448 2
a1449 2
			v = atoi(tp);
			if (v <= 0) {
d1457 2
a1458 2
			v = atoi(tp);
			if (v < 0) {
d1466 2
a1467 2
			v = atoi(tp);
			if (v < 0) {
d1475 2
a1476 2
			v = atoi(tp);
			if (v < 0) {
d1484 2
a1485 2
			v = atoi(tp);
			if (v < 0) {
d1506 1
a1506 1
#define NXTNUM(n) { \
d1512 1
a1512 1
		cp = tp, tp = word(cp), (n) = atoi(cp);		\
d1514 2
a1515 2
			NXTNUM(v);
			if (v < 0) {
d1521 2
a1522 2
			NXTNUM(v);
			if (v < 0) {
d1540 1
a1540 1
				v = atoi(cp);
d1543 1
a1543 1
			if ((unsigned)v >= FSMAXTYPES) {
d1555 1
a1555 1
				NXTNUM(pp->p_fsize);
d1558 1
a1558 1
				NXTNUM(v);
d1563 1
a1563 1
				NXTNUM(pp->p_fsize);
d1566 1
a1566 1
				NXTNUM(v);
d1568 1
a1568 1
				NXTNUM(pp->p_cpg);
@


1.87
log
@Remove those option letters from the getopt string which do not have a case
handler below. millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.86 2003/12/20 09:29:27 jmc Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.86 2003/12/20 09:29:27 jmc Exp $";
d984 1
a984 1
 * Display a particular partion.
@


1.86
log
@make disklabel docs more readable: more logical SYNOPSIS; sort options;
make internal editor help and usage() match the docs; make sure all the
forms described in SYNOPSIS are explained; various other tweaks.

input from millert@@; ok deraadt;
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.85 2003/07/29 18:38:35 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.85 2003/07/29 18:38:35 deraadt Exp $";
d149 1
a149 1
	while ((ch = getopt(argc, argv, "BEFf:NRWb:cdenp:rs:tvw")) != -1)
@


1.85
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.84 2003/07/16 18:03:44 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.84 2003/07/16 18:03:44 tedu Exp $";
d1724 1
a1724 1
	boot = " [-B [-b xxboot]]";
d1726 1
a1726 1
	boot = " [-B [-b xxboot [-s bootxx]]]";
d1732 1
a1732 2
	    "  disklabel [-nv] [-r|-cd] [-p unit] [-t] disk%s (read)\n",
	    blank);
d1734 1
a1734 2
	    "  disklabel [-nv] [-r|-cd] -e disk%s       (edit)\n",
	    blank);
d1736 1
a1736 2
	    "  disklabel [-nv] [-r|-cd] [-f temp] -E disk%.*s  (simple editor)\n",
	    (int)strlen(blank) - 5, blank);
d1738 7
a1744 1
	    "  disklabel [-nv] [-r]%s -R disk proto     (restore)\n",
d1747 1
a1747 1
	    "  disklabel [-nv] [-r]%s -w disk dtab [id] (write)\n",
d1750 2
a1751 1
	    "  disklabel [-nv] [-N|-W] disk%s           (protect)\n", blank);
d1753 1
a1753 1
	    "`disk' may be of the forms: sd0 or /dev/rsd0%c.\n", 'a'+RAW_PART);
d1755 1
a1755 1
	    "`dtab' is an entry from %s, see disktab(5) for more info.\n",
d1758 3
a1760 1
	    "`proto' is the output from the read cmd form; -R is powerful.\n");
@


1.84
log
@new default frag/block sizes.
reminded by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.83 2003/07/02 21:22:10 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.83 2003/07/02 21:22:10 deraadt Exp $";
d497 1
a497 1
			
d609 1
a609 1
		
@


1.83
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.82 2003/06/25 21:11:48 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.82 2003/06/25 21:11:48 deraadt Exp $";
d1148 1
a1148 1
"# other values.  fsize/bsize/cpg should typically be '1024 8192 16' for a\n"
@


1.82
log
@remove junk protos
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.81 2003/06/11 06:22:12 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.81 2003/06/11 06:22:12 deraadt Exp $";
d65 1
@


1.81
log
@ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.80 2003/06/02 20:06:14 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.80 2003/06/02 20:06:14 millert Exp $";
a1190 1
	extern char *getenv();
@


1.80
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.79 2003/04/06 00:45:12 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.79 2003/04/06 00:45:12 deraadt Exp $";
d140 1
a140 3
main(argc, argv)
	int argc;
	char *argv[];
d348 1
a348 3
makelabel(type, name, lp)
	char *type, *name;
	struct disklabel *lp;
d390 1
a390 4
writelabel(f, boot, lp)
	int f;
	char *boot;
	struct disklabel *lp;
d560 1
a560 2
l_perror(s)
	char *s;
d590 1
a590 2
readmbr(f)
	int f;
d675 1
a675 2
readlabel(f)
	int f;
d753 1
a753 4
makebootarea(boot, dp, f)
	char *boot;
	struct disklabel *dp;
	int f;
d883 1
a883 3
makedisktab(f, lp)
	FILE *f;
	struct disklabel *lp;
d972 1
a972 2
width_partition(lp, unit)
	struct disklabel *lp;
d986 2
a987 7
display_partition(f, lp, mp, i, unit, width)
	FILE *f;
	struct disklabel *lp;
	char **mp;
	int i;
	char unit;
	int width;
d1075 1
a1075 4
display(f, lp, unit)
	FILE *f;
	struct disklabel *lp;
	char unit;
d1128 1
a1128 3
edit(lp, f)
	struct disklabel *lp;
	int f;
d1187 1
a1187 1
editit()
d1239 1
a1239 2
skip(cp)
	char *cp;
d1249 1
a1249 2
word(cp)
	char *cp;
d1268 1
a1268 3
getasciilabel(f, lp)
	FILE *f;
	struct disklabel *lp;
d1561 1
a1561 2
checklabel(lp)
	struct disklabel *lp;
d1667 1
a1667 2
setbootflag(lp)
	struct disklabel *lp;
d1702 1
a1702 3
cmplabel(lp1, lp2)
	struct disklabel *lp1;
	struct disklabel *lp2;
d1718 1
a1718 1
usage()
@


1.79
log
@string handling; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.78 2003/02/13 00:10:39 tedu Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.78 2003/02/13 00:10:39 tedu Exp $";
@


1.78
log
@add support for printing disklabels in units other than sectors from
the cmdline
based on a patch by mho at mho.nu
ok and input by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.77 2003/02/05 19:13:58 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.77 2003/02/05 19:13:58 deraadt Exp $";
d821 2
a822 2
			(void)sprintf(np, "%s%sboot",
			    _PATH_BOOTDIR, dkbasename);
d826 3
a828 2
			(void)sprintf(xxboot, "%s%sboot",
			    _PATH_BOOTDIR, dkbasename);
d833 2
a834 2
			(void)sprintf(np, "%sboot%s",
			    _PATH_BOOTDIR, dkbasename);
d838 2
a839 2
			(void)sprintf(bootxx, "%sboot%s",
			    _PATH_BOOTDIR, dkbasename);
@


1.77
log
@WORKAROUND: use a volatile to get around a compiler or fp emulation bug
(jason says he will look into this later)
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.76 2002/12/31 16:22:25 miod Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.76 2002/12/31 16:22:25 miod Exp $";
d128 1
a128 1
void	display(FILE *, struct disklabel *);
d151 1
d154 1
a154 1
	while ((ch = getopt(argc, argv, "BEFf:NRWb:cdenrs:tvw")) != -1)
d216 6
d294 1
a294 1
			display(stdout, lp);
d1099 1
a1099 1
display(f, lp)
d1102 1
d1150 1
a1150 1
		display_partition(f, lp, NULL, i, 0, width);
d1169 1
a1169 1
	display(fp, lp);
d1769 1
a1769 1
	    "  disklabel [-nv] [-r|-cd] [-t] disk%s     (read)\n",
@


1.76
log
@Prepare for the removal of amiga and sun3 platforms from the tree.
There has not been enough activity and interest towards these platform
to keep them lying in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.75 2002/06/09 08:13:05 todd Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.75 2002/06/09 08:13:05 todd Exp $";
d1006 1
a1006 1
	struct partition *pp = &lp->d_partitions[i];
@


1.75
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.74 2002/05/22 08:21:01 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.74 2002/05/22 08:21:01 deraadt Exp $";
d1169 1
a1169 1
"# 4.2BSD filesystem (or '512 4096 16' except on alpha, sun4, amiga, sun3...)\n");
@


1.74
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.73 2002/03/24 22:51:54 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.73 2002/03/24 22:51:54 millert Exp $";
d420 1
a420 1
		 * If OpenBSD DOS partition is missing, or if 
d956 1
a956 1
					(void)fprintf(f, "t%c=%s:", c, 
d1080 1
a1080 1
			    (pp->p_offset + 
@


1.73
log
@Work around a compiler bug on sparc64; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.72 2002/02/16 21:27:33 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.72 2002/02/16 21:27:33 millert Exp $";
d367 2
a368 2
			(void)sprintf(boot0, "%s%s",
				      _PATH_BOOTDIR, lp->d_boot0);
d370 1
a370 1
			(void)strcpy(boot0, lp->d_boot0);
d376 2
a377 2
			(void)sprintf(boot1, "%s%s",
				      _PATH_BOOTDIR, lp->d_boot1);
d379 1
a379 1
			(void)strcpy(boot1, lp->d_boot1);
d815 1
a815 1
				      _PATH_BOOTDIR, dkbasename);
d820 1
a820 1
				      _PATH_BOOTDIR, dkbasename);
d826 1
a826 1
				      _PATH_BOOTDIR, dkbasename);
d831 1
a831 1
				      _PATH_BOOTDIR, dkbasename);
d1211 1
a1211 1
	int stat;
d1218 2
a1219 1
	p = (char *)malloc(strlen(ed) + 1 + strlen(tmpfil) + 1);
d1224 1
a1224 1
	sprintf(p, "%s %s", ed, tmpfil);
@


1.72
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.71 2001/09/03 16:14:27 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.71 2001/09/03 16:14:27 millert Exp $";
d1012 2
a1037 5
		break;

	default:
		p_size = -1;			/* no conversion */
		p_offset = 0;
@


1.71
log
@Include su# in generated disktab.  Because modern disks have a variable
number of sectors/track we need to specify the total number of sectors
per unit explicitly.  Closes PR #2042.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.70 2001/07/07 18:26:10 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: disklabel.c,v 1.70 2001/07/07 18:26:10 deraadt Exp $";
d119 1
a119 1
struct dos_partition *readmbr __P((int));
d122 20
a141 20
void	makedisktab __P((FILE *, struct disklabel *));
void	makelabel __P((char *, char *, struct disklabel *));
int	writelabel __P((int, char *, struct disklabel *));
void	l_perror __P((char *));
struct disklabel *readlabel __P((int));
struct disklabel *makebootarea __P((char *, struct disklabel *, int));
void	display __P((FILE *, struct disklabel *));
void	display_partition __P((FILE *, struct disklabel *, char **, int, char, int));
int	width_partition __P((struct disklabel *, int));
int	editor __P((struct disklabel *, int, char *, char *));
int	edit __P((struct disklabel *, int));
int	editit __P((void));
char	*skip __P((char *));
char	*word __P((char *));
int	getasciilabel __P((FILE *, struct disklabel *));
int	checklabel __P((struct disklabel *));
int	cmplabel __P((struct disklabel *, struct disklabel *));
void	setbootflag __P((struct disklabel *));
void	usage __P((void));
u_short	dkcksum __P((struct disklabel *));
@


1.70
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.69 2000/06/30 16:00:08 millert Exp $	*/
d40 1
a40 1
static char copyright[] =
d46 1
a46 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.69 2000/06/30 16:00:08 millert Exp $";
d912 6
a917 5
	(void)fprintf(f, "se#%d:", lp->d_secsize);
	(void)fprintf(f, "ns#%d:", lp->d_nsectors);
	(void)fprintf(f, "nt#%d:", lp->d_ntracks);
	(void)fprintf(f, "sc#%d:", lp->d_secpercyl);
	(void)fprintf(f, "nc#%d:", lp->d_ncylinders);
d936 1
a936 1
		(void)fprintf(f, "%shs#%d:", did, lp->d_headswitch);
d940 1
a940 1
		(void)fprintf(f, "%sts#%d:", did, lp->d_trkseek);
d945 1
a945 1
			(void)fprintf(f, "d%d#%d", i, lp->d_drivedata[i]);
d952 2
a953 2
			(void)fprintf(f, "p%c#%d:", c, pp->p_size);
			(void)fprintf(f, "o%c#%d:", c, pp->p_offset);
d968 1
a968 1
				(void)fprintf(f, "b%c#%d:", c,
d970 1
a970 1
				(void)fprintf(f, "f%c#%d:", c, pp->p_fsize);
d1082 1
a1082 1
			fprintf(f, "- %d",
@


1.69
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.68 1999/08/17 09:13:14 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.68 1999/08/17 09:13:14 millert Exp $";
d335 2
d487 3
a489 3
			printf("writing label to block %qd (0x%qx)\n",
			    sectoffset/DEV_BSIZE,
			    sectoffset/DEV_BSIZE);
d699 2
a700 2
			printf("reading label from block %qd, offset %qd\n",
			    sectoffset/DEV_BSIZE,
d730 2
a731 2
					warnx("found at 0x%x", (char *)lp
					    - bootarea);
a766 1
	int b;
d769 1
d901 1
a901 1
		(void)fprintf(f, "%.*s|", sizeof(lp->d_packname),
d904 1
a904 1
		(void)fprintf(f, "%.*s|", sizeof(lp->d_typename),
d944 1
a944 1
			(void)fprintf(f, "d%d#%d", lp->d_drivedata[i]);
d1039 1
d1769 1
a1769 1
	    strlen(blank) - 5, blank);
@


1.68
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.67 1999/08/14 15:11:11 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.67 1999/08/14 15:11:11 millert Exp $";
d735 1
a735 1
		warnx(msg);
@


1.68.4.1
log
@Pull in patch from current (more to come...):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.68 1999/08/17 09:13:14 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.68 1999/08/17 09:13:14 millert Exp $";
d735 1
a735 1
		warnx("%s", msg);
@


1.67
log
@Add -c flag that uses DIOCRLDINFO to clear (and update) the in-core label.
@
text
@d1 1
a1 2
/*	$OpenBSD: disklabel.c,v 1.66 1999/08/13 02:06:58 deraadt Exp $	*/
/*	$NetBSD: disklabel.c,v 1.30 1996/03/14 19:49:24 ghudson Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.66 1999/08/13 02:06:58 deraadt Exp $";
a49 1
#include <sys/file.h>
d61 1
@


1.66
log
@microseconds; vax@@linkdead.paranoia.com
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.65 1999/07/14 23:16:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.65 1999/07/14 23:16:26 deraadt Exp $";
d110 1
d154 1
a154 1
	while ((ch = getopt(argc, argv, "BEFf:NRWb:denrs:tvw")) != -1)
d186 3
d243 2
a244 1
	if (argc < 1 || (rflag && dflag) || (fstabfile && op != EDITOR))
a737 4
	} else if (dflag) {
		lp = &lab;
		if (ioctl(f, DIOCGPDINFO, lp) < 0)
			err(4, "ioctl DIOCGPDINFO");
d739 11
a749 3
		lp = &lab;
		if (ioctl(f, DIOCGDINFO, lp) < 0)
			err(4, "ioctl DIOCGDINFO");
d1760 1
a1760 1
	    "  disklabel [-nv] [-r|-d] [-t] disk%s      (read)\n",
d1763 1
a1763 1
	    "  disklabel [-nv] [-r|-d] -e disk%s        (edit)\n",
d1766 2
a1767 2
	    "  disklabel [-nv] [-r|-d] [-f temp] -E disk%.*s  (simple editor)\n",
	    strlen(blank) - 4, blank);
@


1.65
log
@put in a check for architectures that demand that partition A start at sector 0
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.64 1999/06/16 10:12:38 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.64 1999/06/16 10:12:38 espie Exp $";
d1115 1
a1115 1
	fprintf(f, "headswitch: %ld\t\t# milliseconds\n",
d1117 1
a1117 1
	fprintf(f, "track-to-track seek: %ld\t# milliseconds\n",
@


1.64
log
@missed i386 -> __i386__
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.63 1999/04/07 22:57:25 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.63 1999/04/07 22:57:25 millert Exp $";
d1643 7
@


1.63
log
@Kill -F option, it is not needed and just plain wrong anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.62 1999/03/23 05:18:49 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.62 1999/03/23 05:18:49 millert Exp $";
d539 1
a539 1
#ifdef vax
d780 1
a780 1
#ifndef i386
@


1.62
log
@Rename -F option to -f and add a new -F (full disk) option to use in -E mode.
When checking for an MBR, only say we have an mbr if there is a signature *or*
there is an fdisk partition with an {Open,Free,Net}BSD ID.
When setting the bounds in -E mode add hueristics to deal with disks
bigger than the BIOS geometry would indicate.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.61 1999/03/16 04:47:16 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.61 1999/03/16 04:47:16 millert Exp $";
d131 1
a131 1
int	editor __P((struct disklabel *, int, char *, char *, int));
a148 1
	int whole_mode = 0;
a197 3
		case 'F':
			whole_mode = 1;
			break;
d273 1
a273 1
		error = editor(lp, f, specname, fstabfile, whole_mode);
d1750 2
a1751 2
	    "  disklabel [-nv] [-r|-d] [-F] [-f temp] -E disk%.*s  (simple editor)\n",
	    strlen(blank) - 9, blank);
@


1.61
log
@Add -F flag to cause editor to prompt for mount points and save the resulting info in fstab format.  To be used by the install script.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.60 1999/03/14 19:31:19 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.60 1999/03/14 19:31:19 millert Exp $";
d131 1
a131 1
int	editor __P((struct disklabel *, int, char *, char *));
d149 1
d154 1
a154 1
	while ((ch = getopt(argc, argv, "BEF:NRWb:denrs:tvw")) != -1)
d200 3
d277 1
a277 1
		error = editor(lp, f, specname, fstabfile);
d598 1
d609 2
a610 1

d655 7
d670 1
a670 1
	return (0);
d890 1
a890 1
	int i, j;
d1754 2
a1755 2
	    "  disklabel [-nv] [-r|-d] [-F temp] -E disk%s(simple editor)\n",
	    blank);
@


1.60
log
@Fix check for partition ending on a cylinder boundary.  Previously it
checked for size being a mulitple of sectors/cylinder when you really
want size+offset to be a mulitple of sectors/cylinder.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.59 1999/03/07 03:05:31 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.59 1999/03/07 03:05:31 deraadt Exp $";
d129 1
a129 1
void	display_partition __P((FILE *, struct disklabel *, int, char, int));
d131 1
a131 1
int	editor __P((struct disklabel *, int, char *));
d149 1
d153 1
a153 1
	while ((ch = getopt(argc, argv, "BENRWb:denrs:tvw")) != -1)
d198 3
d239 1
a239 1
	if (argc < 1 || (rflag && dflag))
d273 1
a273 1
		error = editor(lp, f, specname);
d978 1
a978 1
display_partition(f, lp, i, unit, width)
d981 1
d1048 1
a1048 1
			fprintf(f, "%20.20s", "");
d1051 4
a1054 1
		if (lp->d_secpercyl) {
d1124 1
a1124 1
		display_partition(f, lp, i, 0, width);
d1735 1
a1735 1
	    "  disklabel [-nv] [-r|-d] [-t] disk%s         (read)\n",
d1738 1
a1738 1
	    "  disklabel [-nv] [-r|-d] -e disk%s           (edit)\n",
d1741 1
a1741 1
	    "  disklabel [-nv] [-r|-d] -E disk%s           (simple editor)\n",
d1750 1
a1750 1
	    "  disklabel [-nv] -[NW] disk%s             (protect)\n", blank);
@


1.59
log
@dkcksum() requires d_checksum cleared
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.58 1999/03/01 01:50:45 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.58 1999/03/01 01:50:45 millert Exp $";
d1057 1
a1057 1
			if (pp->p_size % lp->d_secpercyl)
@


1.58
log
@Change undocumented '-p' flag to '-d' and document.  Also document '-v'.
Make 'disklabel -ed' not overwrite your label if you make no changes
in the editor (added a cmplabel function to compare two labels).
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.57 1999/01/12 04:48:25 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.57 1999/01/12 04:48:25 aaron Exp $";
d403 1
@


1.57
log
@use pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.56 1998/10/03 22:01:47 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.56 1998/10/03 22:01:47 millert Exp $";
d110 1
a110 1
int	pflag;
d138 1
d152 1
a152 1
	while ((ch = getopt(argc, argv, "BENRWb:enprs:tvw")) != -1)
a166 5
		case 'E':
			if (op != UNSPEC)
				usage();
			op = EDITOR;
			break;
d184 3
d192 4
a195 2
		case 'p':
			++pflag;
d235 1
a235 1
	if (argc < 1)
a402 1
	lp->d_checksum = 0;
d719 1
a719 1
	} else if (pflag) {
d1154 6
d1693 18
d1726 1
a1726 1
	    "  disklabel [-nv] [-r] [-t] disk%s         (read)\n",
d1729 1
a1729 1
	    "  disklabel [-nv] [-r] -e disk%s           (edit)\n",
d1732 1
a1732 1
	    "  disklabel [-nv] [-r] -E disk%s           (simple editor)\n",
@


1.56
log
@Add DIOCGPDINFO ioctl and use it in disklabel's new -p mode
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.55 1998/09/11 04:02:27 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.55 1998/09/11 04:02:27 millert Exp $";
d1177 1
a1177 1
	int pid, xpid;
@


1.55
log
@Pass specname in to editor(), missing part of a commit a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.54 1998/09/10 06:56:47 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.54 1998/09/10 06:56:47 deraadt Exp $";
d110 1
d151 1
a151 1
	while ((ch = getopt(argc, argv, "BENRWb:enrs:tvw")) != -1)
d193 3
d719 4
@


1.54
log
@pass correct args to editor()
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.53 1998/06/07 05:00:23 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.53 1998/06/07 05:00:23 deraadt Exp $";
d264 1
a264 1
		error = editor(lp, f, dkname);
@


1.53
log
@off_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.52 1998/05/07 16:39:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.52 1998/05/07 16:39:35 millert Exp $";
d130 1
a130 1
int	editor __P((struct disklabel *, int));
d264 1
a264 1
		error = editor(lp, f);
@


1.52
log
@In -v mode print label offset in addition to the block number.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.51 1998/04/25 07:17:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.51 1998/04/25 07:17:12 deraadt Exp $";
d416 2
a417 1
		        sectoffset = get_le(&dosdp->dp_start) * lp->d_secsize;
d472 3
a474 3
			printf("writing label to block %d (0x%x)\n",
			    (int)sectoffset/DEV_BSIZE,
			    (int)sectoffset/DEV_BSIZE);
d671 2
a672 1
			sectoffset = get_le(&dosdp->dp_start) * DEV_BSIZE;
d675 3
a677 3
			printf("reading label from block %d, offset %d\n",
			    (int)sectoffset/DEV_BSIZE,
			    (int)sectoffset/DEV_BSIZE +
@


1.51
log
@DOSBBSECTOR is in sectors
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.50 1998/03/12 19:35:55 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.50 1998/03/12 19:35:55 millert Exp $";
d673 1
a673 1
			printf("reading label from block %d (0x%x)\n",
d675 2
a676 1
			    (int)sectoffset/DEV_BSIZE);
@


1.50
log
@Treat IDE as ESDI in -e mode just like we do in -E mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.49 1998/02/20 01:55:29 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.49 1998/02/20 01:55:29 deraadt Exp $";
d591 1
a591 1
	if (lseek(f, (off_t)DOSBBSECTOR, SEEK_SET) < 0 ||
@


1.49
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.48 1998/02/19 20:43:36 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.48 1998/02/19 20:43:36 deraadt Exp $";
d1274 2
d1278 1
a1278 1
				if ((s = *cpp) && !strcmp(s, tp)) {
@


1.48
log
@deal with partition type renamed
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.47 1997/11/25 00:36:22 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.47 1997/11/25 00:36:22 millert Exp $";
d668 1
a668 1
		    (dosdp->dp_typ == DOSPTYP_FREEBSD ||
@


1.47
log
@Add -t flag to output in disktab format.  From Christos Zoulas
<christos@@deshaw.com> plus correct code for outputing d_drivedata.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.46 1997/10/24 00:18:55 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.46 1997/10/24 00:18:55 millert Exp $";
d414 2
a415 1
		    dosdp->dp_typ == DOSPTYP_386BSD)) {
d619 11
a629 1
		if (get_le(&dp[part].dp_size) && dp[part].dp_typ == DOSPTYP_386BSD) {
d667 3
a669 2
		    (dosdp->dp_typ == DOSPTYP_386BSD ||
		    dosdp->dp_typ == DOSPTYP_OPENBSD))
d1569 4
a1572 2
	if (dosdp && dosdp->dp_size && (dosdp->dp_typ == DOSPTYP_386BSD ||
	    dosdp->dp_typ == DOSPTYP_OPENBSD)) {
@


1.46
log
@%f not %lf [%f is already a double]
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.45 1997/10/20 07:09:41 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.45 1997/10/20 07:09:41 deraadt Exp $";
d111 1
d121 1
d150 1
a150 1
	while ((ch = getopt(argc, argv, "BENRWb:ers:wnv")) != -1)
d195 3
d271 4
a274 1
		display(stdout, lp);
d844 90
d1675 1
a1675 1
	    "  disklabel [-nv] [-r] disk%s              (read)\n",
@


1.45
log
@format the "print" units better, in all cases
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.44 1997/10/17 07:30:03 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.44 1997/10/17 07:30:03 deraadt Exp $";
d901 1
a901 1
			fprintf(f, "  %c: %*.1lf%c %*.1lf%c  ", 'a' + i,
@


1.44
log
@oops; spotted by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.43 1997/10/17 04:33:05 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.43 1997/10/17 04:33:05 deraadt Exp $";
d126 2
a127 1
void	display_partition __P((FILE *, struct disklabel *, int, char));
d836 12
d852 1
a852 1
display_partition(f, lp, i, unit)
d857 1
d860 1
a860 1
	double p_size;
d862 3
a864 1
	unit = tolower(unit);
d866 1
a866 1
	case 'b':
d868 1
d871 1
a871 1
	case 'c':
d873 1
d876 1
a876 1
	case 'k':
d878 6
d886 3
a888 2
	case 'm':
		p_size = (double)pp->p_size / (1048576 / lp->d_secsize);
d898 2
a899 2
			fprintf(f, "  %c: %8u %8u  ", 'a' + i,
			    pp->p_size, pp->p_offset);
d901 2
a902 2
			fprintf(f, "  %c: %8.2f%c %8u  ", 'a' + i,
			    p_size, unit, pp->p_offset);
d949 1
d989 1
d991 2
a992 1
	    "#        size   offset    fstype   [fsize bsize   cpg]\n");
d994 1
a994 1
		display_partition(f, lp, i, 0);
@


1.43
log
@shrink an output line
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.42 1997/10/13 15:02:15 pefo Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.42 1997/10/13 15:02:15 pefo Exp $";
d602 1
a602 1
			    dp[part].dp_typ, dp[part].dp_typ,
d612 1
a612 1
			    dp[part].dp_typ, dp[part].dp_typ, 
@


1.42
log
@Well, ppc has to work....
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.41 1997/10/02 01:16:02 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.41 1997/10/02 01:16:02 millert Exp $";
d601 1
a601 2
			    "type %d (0x%02x) "
			    "offset %d (0x%x) size %d (0x%x)\n", part,
d611 1
a611 2
			    "type %d (0x%02x) "
			    "offset %d (0x%x) size %d (0x%x)\n", part,
@


1.41
log
@Deal with ^D sanely and kill unused get_yn().
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.40 1997/10/02 00:49:11 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.40 1997/10/02 00:49:11 millert Exp $";
d406 1
a406 1
		        sectoffset = dosdp->dp_start * lp->d_secsize;
d599 1
a599 1
		if (dp[part].dp_size && dp[part].dp_typ == DOSPTYP_OPENBSD) {
d604 2
a605 2
			    dp[part].dp_start, dp[part].dp_start,
			    dp[part].dp_size, dp[part].dp_size);
d610 1
a610 1
		if (dp[part].dp_size && dp[part].dp_typ == DOSPTYP_386BSD) {
d615 2
a616 2
			    dp[part].dp_start, dp[part].dp_start,
			    dp[part].dp_size, dp[part].dp_size);
d623 1
a623 1
		if (dp[part].dp_size) {
d648 1
a648 1
		if (dosdp && dosdp->dp_size &&
d651 1
a651 1
			sectoffset = dosdp->dp_start * DEV_BSIZE;
@


1.40
log
@Kill newlabel() stuff.  The kernel should never fail to write a
label just because none exists on the disk.  i386 has been fixed
in the respect and others may need fixing as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.39 1997/09/30 17:54:15 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.39 1997/09/30 17:54:15 millert Exp $";
a136 1
char	get_yn __P((char *));
@


1.39
log
@Implement "disklabel -E" -- a simple interactive label editor for
installs and new labels.  Documentation to follow :-) Also, give
the user the option of writing the fictitious label if no on-disk
label exists with the -e, -E, and -w options.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.38 1997/09/26 04:10:28 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.38 1997/09/26 04:10:28 millert Exp $";
a122 1
struct disklabel *newlabel __P((int));
d250 1
a250 1
		if ((lp = newlabel(f)) == NULL)
d257 1
a257 1
		if ((lp = newlabel(f)) == NULL)
d302 1
a302 1
		if ((lp = newlabel(f)) == NULL)
a1535 37

/*
 * Get existing label or create a new one if none exists.
 */
struct disklabel *
newlabel(f)
	int f;
{
	int orflag = rflag;
	struct disklabel fictlabel, *lp = NULL;

	rflag = 1;
	if ((lp = readlabel(f)) == NULL) {
		if (get_yn("No label found on disk, write a new one?") != 'y')
			return(NULL);

		/* Read fake label */
		rflag = 0;
		lp = readlabel(f);
		fictlabel = *lp;
		rflag = 1;
		nwflag = 0;		/* set by readlabel() */

		/* Make boot area and fill in values from fictious label */
		lp = makebootarea(bootarea, &lab, f);
		*lp = fictlabel;

		/* Write fake label to disk */
		if (checklabel(lp))
			warnx("you must correct these errors in the editor.");
		if (writelabel(f, bootarea, lp))
			err(4, "unable to write new label");
	}

	rflag = orflag;
	return(lp);
}
@


1.38
log
@Some -Wall.  Add display_partition() for use with upcoming editor mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.37 1997/09/14 10:37:40 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.37 1997/09/14 10:37:40 deraadt Exp $";
d107 1
a107 1
	UNSPEC, EDIT, READ, RESTORE, SETWRITEABLE, WRITE, WRITEBOOT
d123 1
d127 2
a128 1
void	display_partition __P((FILE *, struct disklabel *, int));
d138 1
d149 1
a149 1
	while ((ch = getopt(argc, argv, "BNRWb:ers:wnv")) != -1)
d164 5
d251 2
a252 1
		lp = readlabel(f);
d255 7
d265 2
a266 1
		lp = readlabel(f);
d303 2
a304 1
		lp = readlabel(f);
d693 2
a694 1
		errx(1, msg);
d843 1
a843 1
display_partition(f, lp, i)
d847 1
d850 24
d876 6
a881 2
		fprintf(f, "  %c: %8d %8d  ", 'a' + i,
		    pp->p_size, pp->p_offset);
d970 1
a970 1
		display_partition(f, lp, i);
d1538 37
d1594 3
@


1.37
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.36 1997/09/03 22:39:12 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.36 1997/09/03 22:39:12 mickey Exp $";
a62 1
#include <unistd.h>
d126 1
d699 1
d702 1
d820 54
a879 1
	struct partition *pp;
d886 2
a887 2
	fprintf(f, "disk: %.*s\n", sizeof(lp->d_typename), lp->d_typename);
	fprintf(f, "label: %.*s\n", sizeof(lp->d_packname), lp->d_packname);
d895 1
a895 1
	fprintf(f, "\n");
d921 2
a922 44
	pp = lp->d_partitions;
	for (i = 0; i < lp->d_npartitions; i++, pp++) {
		if (pp->p_size) {
			fprintf(f, "  %c: %8d %8d  ", 'a' + i,
			    pp->p_size, pp->p_offset);
			if ((unsigned) pp->p_fstype < FSMAXTYPES)
				fprintf(f, "%8.8s", fstypenames[pp->p_fstype]);
			else
				fprintf(f, "%8d", pp->p_fstype);
			switch (pp->p_fstype) {

			case FS_UNUSED:				/* XXX */
				fprintf(f, "    %5d %5d %5.5s ",
				    pp->p_fsize, pp->p_fsize * pp->p_frag, "");
				break;

			case FS_BSDFFS:
				fprintf(f, "    %5d %5d %5d ",
				    pp->p_fsize, pp->p_fsize * pp->p_frag,
				    pp->p_cpg);
				break;

			default:
				fprintf(f, "%20.20s", "");
				break;
			}
			if (lp->d_secpercyl) {
				fprintf(f, "\t# (Cyl. %4d",
				    pp->p_offset / lp->d_secpercyl);
				if (pp->p_offset % lp->d_secpercyl)
					putc('*', f);
				else
					putc(' ', f);
				fprintf(f, "- %d",
				    (pp->p_offset + 
				    pp->p_size + lp->d_secpercyl - 1) /
				    lp->d_secpercyl - 1);
				if (pp->p_size % lp->d_secpercyl)
					putc('*', f);
				fprintf(f, ")");
			}
			fprintf(f, "\n");
		}
	}
@


1.36
log
@add xr installboot for i386
change msg to accomodate multiple man pages in SEEALSO
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.35 1997/08/29 18:05:40 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.35 1997/08/29 18:05:40 mickey Exp $";
d1064 1
a1064 1
		if (cp = strpbrk(line, "#\r\n"))
@


1.35
log
@move _PATH_BOOTDIR w/ trailing slash into paths.h for other progs...
disklabel changed to use it that way
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.34 1997/07/28 08:26:58 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.34 1997/07/28 08:26:58 deraadt Exp $";
d1514 1
a1514 2
	    "The manpage %s describes procedures specific to "
	    "this architecture.\n", SEEALSO);
@


1.34
log
@boot1[] only needed if NUMBOOT > 1; frueauf@@ira.uka.de
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.33 1997/07/19 20:35:37 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.33 1997/07/19 20:35:37 niklas Exp $";
d327 1
a327 1
			(void)sprintf(boot0, "%s/%s",
d336 1
a336 1
			(void)sprintf(boot1, "%s/%s",
d741 1
a741 1
			(void)sprintf(np, "%s/%sboot",
d746 1
a746 1
			(void)sprintf(xxboot, "%s/%sboot",
d752 1
a752 1
			(void)sprintf(np, "%s/boot%s",
d757 1
a757 1
			(void)sprintf(bootxx, "%s/boot%s",
@


1.33
log
@some KNF I had lying around
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.32 1997/06/25 18:06:42 kstailey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.32 1997/06/25 18:06:42 kstailey Exp $";
d102 1
d104 1
@


1.32
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.31 1997/05/21 16:02:33 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.31 1997/05/21 16:02:33 deraadt Exp $";
d839 10
a848 10
	fprintf(f, "bytes/sector: %ld\n", (long) lp->d_secsize);
	fprintf(f, "sectors/track: %ld\n", (long) lp->d_nsectors);
	fprintf(f, "tracks/cylinder: %ld\n", (long) lp->d_ntracks);
	fprintf(f, "sectors/cylinder: %ld\n", (long) lp->d_secpercyl);
	fprintf(f, "cylinders: %ld\n", (long) lp->d_ncylinders);
	fprintf(f, "total sectors: %ld\n", (long) lp->d_secperunit);
	fprintf(f, "rpm: %ld\n", (long) lp->d_rpm);
	fprintf(f, "interleave: %ld\n", (long) lp->d_interleave);
	fprintf(f, "trackskew: %ld\n", (long) lp->d_trackskew);
	fprintf(f, "cylinderskew: %ld\n", (long) lp->d_cylskew);
d850 1
a850 1
		(long) lp->d_headswitch);
d852 1
a852 1
		(long) lp->d_trkseek);
d868 1
a868 1
			   pp->p_size, pp->p_offset);
@


1.31
log
@better disklabel -e messaging
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.30 1997/04/20 08:59:40 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.30 1997/04/20 08:59:40 deraadt Exp $";
d256 1
a256 1
			makelabel(argv[2], (char *)0, &lab);
d273 1
a273 1
		makelabel(argv[1], argc == 3 ? argv[2] : (char *)0, &lab);
d287 1
a287 1
			makelabel(argv[1], (char *)0, &lab);
d975 1
a975 1
	if ((ed = getenv("EDITOR")) == (char *)0)
@


1.30
log
@sparc/sun3 labels want cyl-alignment; grr
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.29 1997/04/10 22:26:13 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.29 1997/04/10 22:26:13 millert Exp $";
d921 2
d927 8
@


1.29
log
@Error if bsize < fsize.  Problem noted by Dieter Dworkin Muller
<dworkin@@village.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.28 1997/02/17 16:30:25 imp Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.28 1997/02/17 16:30:25 imp Exp $";
d1390 1
a1390 1
#ifdef notdef
@


1.28
log
@Trivial change.  Restored from backup
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.27 1997/02/16 07:42:52 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.27 1997/02/16 07:42:52 deraadt Exp $";
d1405 4
@


1.27
log
@when spawning editor child, use signal() instead of sigprocmask(SIG_BLOCK...
this appears to prevent the intermediate shell from playing with the signals
such that it gets a tty signal inside an editor such as emacs.
this was very annoying
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.26 1996/12/13 16:58:25 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.26 1996/12/13 16:58:25 millert Exp $";
a90 1

@


1.26
log
@If max number of partitions in the label is < highest partition defined,
increase d_npartitions as long as we don't go above MAXPARTITIONS.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.25 1996/12/07 10:09:24 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.25 1996/12/07 10:09:24 deraadt Exp $";
a962 1
	sigset_t sigset, osigset;
d976 4
a979 5
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGINT);
	sigaddset(&sigset, SIGQUIT);
	sigaddset(&sigset, SIGHUP);
	sigprocmask(SIG_BLOCK, &sigset, &osigset);
a981 1
			sigprocmask(SIG_SETMASK, &osigset, (sigset_t *)0);
d984 2
a985 1
			return (0);
a989 3
		sigprocmask(SIG_SETMASK, &osigset, (sigset_t *)0);
		setgid(getgid());
		setuid(getuid());
d1001 4
a1004 1
	sigprocmask(SIG_SETMASK, &osigset, (sigset_t *)0);
@


1.25
log
@correct a sigsegv during parsing of garbled input; netbsd pr#2659, dgilbert@@jaywon.pci.on.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.24 1996/11/12 07:04:49 downsj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.24 1996/11/12 07:04:49 downsj Exp $";
d1240 9
a1248 5
			if (part > lp->d_npartitions) {
				warnx("line %d: bad partition name: %s",
				    lineno, cp);
				errors++;
				continue;
@


1.24
log
@Match fs type case-insensetively.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.23 1996/10/04 07:24:58 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.23 1996/10/04 07:24:58 deraadt Exp $";
d1269 4
d1294 2
@


1.23
log
@-n fix, one more DOSPTYP_OPENBSD change
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.22 1996/10/01 09:23:38 maja Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.22 1996/10/01 09:23:38 maja Exp $";
d1272 1
a1272 1
				if ((s = *cpp) && !strcmp(s, cp)) {
@


1.22
log
@Make it compilable even if NUMBOOT=1 (vax). -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.21 1996/09/30 11:28:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.21 1996/09/30 11:28:35 deraadt Exp $";
d387 1
a387 1
		    (dosdp->dp_typ == DOSPTYP_386BSD ||
d485 1
a485 1
		if (bootbuf && write(f, bootbuf, bootsize) != bootsize) {
@


1.21
log
@# using message; more donothing stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.20 1996/09/24 11:36:55 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.20 1996/09/24 11:36:55 deraadt Exp $";
d1461 1
a1461 1
	boot = " [-B [-b xxboot]]"
@


1.20
log
@use DOSPTYP_386BSD only if no DOSPTYP_OPENBSD part on disk
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.19 1996/09/24 04:35:18 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.19 1996/09/24 04:35:18 deraadt Exp $";
d266 4
a269 2
		if (ioctl(f, DIOCWLABEL, (char *)&writeable) < 0)
			err(4, "ioctl DIOCWLABEL");
d436 6
a441 4
		if (ioctl(f, DIOCSDINFO, lp) < 0 &&
		    errno != ENODEV && errno != ENOTTY) {
			l_perror("ioctl DIOCSDINFO");
			return (1);
d495 5
a499 3
		if (ioctl(f, DIOCWDINFO, lp) < 0) {
			l_perror("ioctl DIOCWDINFO");
			return (1);
d583 1
a583 1
			fprintf(stderr, "using MBR partition %d: "
d594 1
a594 1
			fprintf(stderr, "using MBR partition %d: "
@


1.19
log
@flags: add -n: do nothing, -v: verbose; delete -d flag.  on DOSLABEL systems,
ensure the OpenBSD disklabel/bootblocks are written inside 165 partition
(RAW_PART must start at block 0 of unit) -- this makes the kernel algorithm
and userland algorithms the same. unify & pretty the usage message
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.18 1996/09/22 10:17:10 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.18 1996/09/22 10:17:10 deraadt Exp $";
d384 3
a386 1
		if (dosdp && dosdp->dp_typ == DOSPTYP_386BSD && pp->p_size) {
d576 11
d588 4
a591 2
			warnx("using dos partition %d: offset %d (0x%x) "
			    "size %d (0x%x)", part,
d597 1
d625 3
a627 1
		if (dosdp && dosdp->dp_size && dosdp->dp_typ == DOSPTYP_386BSD)
d1349 2
a1350 1
	if (dosdp && dosdp->dp_size && dosdp->dp_typ == DOSPTYP_386BSD
@


1.18
log
@warnx does not take a \\n
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.17 1996/09/21 13:19:03 pefo Exp $	*/
d47 1
a47 6
#if 0
/* from static char sccsid[] = "@@(#)disklabel.c	1.2 (Symmetric) 11/28/85"; */
static char sccsid[] = "@@(#)disklabel.c	8.2 (Berkeley) 1/7/94";
#else
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.17 1996/09/21 13:19:03 pefo Exp $";
#endif
d89 1
a89 4
#define	DEFEDITOR	_PATH_VI

char	*dkname;
char	*specname;
a93 1
struct	disklabel *readlabel(), *makebootarea();
d106 1
a106 1
enum	{
d112 2
a113 7

#ifdef DEBUG
int	debug;
#define OPTIONS	"BNRWb:ders:w"
#else
#define OPTIONS	"BNRWb:ers:w"
#endif
d120 3
a122 3
void makelabel __P((char *, char *, struct disklabel *));
int writelabel __P((int, char *, struct disklabel *));
void l_perror __P((char *));
d125 10
a134 11
void display __P((FILE *, struct disklabel *));
int edit __P((struct disklabel *, int));
int editit __P((void));
char *skip __P((char *));
char *word __P((char *));
int getasciilabel __P((FILE *, struct disklabel *));
int checklabel __P((struct disklabel *));
void setbootflag __P((struct disklabel *));
void usage __P((void));
u_short dkcksum __P((struct disklabel *));

d141 1
a143 1
	int ch, f, writeable, error = 0;
d145 1
a145 1
	while ((ch = getopt(argc, argv, OPTIONS)) != -1)
d190 5
a194 3
#ifdef DEBUG
		case 'd':
			debug++;
a195 1
#endif
d222 1
a222 1
		&specname);
d229 1
a229 1
	 * master boot record. Return pointer to OpenBSD/i386
a238 1

a244 1

a251 1

a264 1

a268 1

a277 1

d356 7
a362 4
	if(nwflag) {
		warnx("DANGER! The disklabel was not found at the correct location.");
		warnx("Use 'disklabel -R' to replace it from a file made by using disklabel.");
		warnx("New disklabel will not be installed.");
d377 1
a377 1
		 * If OpenBSD/i386 DOS partition is missing, or if 
d384 2
a385 3
		if (dosdp && dosdp->dp_typ == DOSPTYP_386BSD && pp->p_size &&
			dosdp->dp_start == pp->p_offset) {
		        sectoffset = pp->p_offset * lp->d_secsize;
d437 17
a453 11
		if (lseek(f, sectoffset, SEEK_SET) < 0) {
			perror("lseek");
			return (1);
		}
		/*
		 * write enable label sector before write (if necessary),
		 * disable after writing.
		 */
		writeable = 1;
		if (ioctl(f, DIOCWLABEL, &writeable) < 0)
			perror("ioctl DIOCWLABEL");
d455 14
a468 14
		/*
		 * The Alpha requires that the boot block be checksummed.
		 * The first 63 8-byte quantites are summed into the 64th.
		 */
		{
			int i;
			u_int64_t *dp, sum;

			dp = (u_int64_t *)boot;
			sum = 0;
			for (i = 0; i < 63; i++)
				sum += dp[i];
			dp[63] = sum;
		}
d470 4
a473 3
		if (write(f, boot, lp->d_bbsize) != lp->d_bbsize) {
			perror("write");
			return (1);
d485 3
a487 2
		if (ioctl(f, DIOCWLABEL, &writeable) < 0)
			perror("ioctl DIOCWLABEL");
d503 3
a505 2
			if (write(f, boot, lp->d_secsize) < lp->d_secsize)
				warn("alternate label %d write", i/2);
a517 1

a521 1

a525 1

a528 1

d530 2
a531 1
		warnx("%s: Labeled partition or 'a' partition must start at beginning of disk", s);
a532 1

d564 1
a564 1
	 * partition table to find OpenBSD/i386 partition, and obtain
d575 4
a578 1
			warnx("using dos partition %d.", part);
d602 1
a602 1
	struct disklabel *lp;
d612 4
d642 3
a644 1
				    dkcksum(lp) == 0)
d646 1
d683 1
a683 1
		(boot + (LABELSECTOR * dp->d_secsize) + LABELOFFSET);
d738 1
a738 2
#ifdef DEBUG
	if (debug)
a740 1
#endif
d897 1
a897 2
	if ((fd = mkstemp(tmpfil)) == -1 ||
	    (fp = fdopen(fd, "w")) == NULL) {
d944 1
a944 1
		ed = DEFEDITOR;
d1399 1
a1400 1
	u_long boffset;
d1415 1
a1415 2
				warnx("boot overlaps used partition %c",
				    part);
d1432 2
d1435 30
a1464 1
#if NUMBOOT > 0
d1466 2
a1467 33
"%s\n\t%s\n%s\n\t%s\n%s\n\t%s\n%s\n\t%s\n%s\n\t%s\n%s\n\t%s\n%s\n\t%s\n%s\n\t%s\n",
"usage: disklabel [-r] disk",
		"(to read label)",
"or disklabel -w [-r] disk type [ packid ]",
		"(to write label with existing boot program)",
"or disklabel -e [-r] disk",
		"(to edit label)",
"or disklabel -R [-r] disk protofile",
		"(to restore label with existing boot program)",
#if NUMBOOT > 1
"or disklabel -B [ -b xxboot [ -s bootxx ] ] disk [ type ]",
		"(to install boot program with existing label)",
"or disklabel -w -B [ -b xxboot [ -s bootxx ] ] disk type [ packid ]",
		"(to write label and boot program)",
"or disklabel -R -B [ -b xxboot [ -s bootxx ] ] disk protofile [ type ]",
		"(to restore label and boot program)",
#else
"or disklabel -B [ -b bootprog ] disk [ type ]",
		"(to install boot program with existing on-disk label)",
"or disklabel -w -B [ -b bootprog ] disk type [ packid ]",
		"(to write label and install boot program)",
"or disklabel -R -B [ -b bootprog ] disk protofile [ type ]",
		"(to restore label and install boot program)",
#endif
"or disklabel [-NW] disk",
		"(to write disable/enable label)");
#else
	fprintf(stderr, "%-43s%s\n%-43s%s\n%-43s%s\n%-43s%s\n%-43s%s\n",
"usage: disklabel [-r] disk", "(to read label)",
"or disklabel -w [-r] disk type [ packid ]", "(to write label)",
"or disklabel -e [-r] disk", "(to edit label)",
"or disklabel -R [-r] disk protofile", "(to restore label)",
"or disklabel [-NW] disk", "(to write disable/enable label)");
@


1.17
log
@When reading label -r first try the correct label location.
Don't allow updates when original disklabel is found by scanning.
NetBSD -> OpenBSD in printouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.16 1996/09/16 02:21:59 millert Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.16 1996/09/16 02:21:59 millert Exp $";
d588 1
a588 1
			warnx("using dos partition %d.\n", part);
d637 1
a637 1
			warnx("no disklabel found. scanning.\n");
@


1.16
log
@_PATH_TMP -> _PATH_TMPFILE
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.15 1996/08/10 12:14:19 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.15 1996/08/10 12:14:19 deraadt Exp $";
d120 1
d243 1
a243 1
	 * master boot record. Return pointer to NetBSD/i386
d376 6
d394 1
a394 1
		 * If NetBSD/i386 DOS partition is missing, or if 
d577 1
a577 1
	 * partition table to find NetBSD/i386 partition, and obtain
d585 1
a585 1
	/* Find NetBSD partition. */
d587 2
a588 1
		if (dp[part].dp_size && dp[part].dp_typ == DOSPTYP_386BSD)
d590 1
d592 1
a592 1
	/* If no NetBSD partition, find first used partition. */
d595 1
a595 1
			warnx("warning, DOS partition table with no valid NetBSD partition");
d625 16
a652 1
		/* lp = (struct disklabel *)(bootarea + LABELOFFSET); */
@


1.15
log
@avoid division by zero (avoid printing the incalculateable); netbsd pr#2683; nathanw@@MIT.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.14 1996/06/25 01:21:57 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.14 1996/06/25 01:21:57 deraadt Exp $";
d98 1
a98 1
char	tmpfil[] = _PATH_TMP;
@


1.14
log
@mkstemp & fdopen; fix FILE * leak
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.13 1996/06/19 13:24:27 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.13 1996/06/19 13:24:27 deraadt Exp $";
d848 16
a863 13
			fprintf(f, "\t# (Cyl. %4d",
			    pp->p_offset / lp->d_secpercyl);
			if (pp->p_offset % lp->d_secpercyl)
			    putc('*', f);
			else
			    putc(' ', f);
			fprintf(f, "- %d",
			    (pp->p_offset + 
			    pp->p_size + lp->d_secpercyl - 1) /
			    lp->d_secpercyl - 1);
			if (pp->p_size % lp->d_secpercyl)
			    putc('*', f);
			fprintf(f, ")\n");
@


1.13
log
@pstat == stat
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.12 1996/06/19 13:22:57 deraadt Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.12 1996/06/19 13:22:57 deraadt Exp $";
d871 1
a871 1
	int first, ch;
d873 1
a873 2
	FILE *fd;
	char *mktemp();
d875 2
a876 3
	(void) mktemp(tmpfil);
	fd = fopen(tmpfil, "w");
	if (fd == NULL) {
d880 2
a881 3
	(void)fchmod(fileno(fd), 0600);
	display(fd, lp);
	fclose(fd);
d885 2
a886 2
		fd = fopen(tmpfil, "r");
		if (fd == NULL) {
d891 1
a891 1
		if (getasciilabel(fd, &label)) {
d894 1
d899 1
@


1.12
log
@do not use system() to start $EDITOR, but fake system() ourselves
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.11 1996/06/17 07:55:59 downsj Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.11 1996/06/17 07:55:59 downsj Exp $";
a915 1
	int pstat;
d956 4
a959 4
		xpid = waitpid(pid, (int *)&pstat, WUNTRACED);
		if (WIFSTOPPED(pstat))
			raise(WSTOPSIG(pstat));
		else if (WIFEXITED(pstat))
@


1.11
log
@opendev.h -> util.h
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.10 1996/06/17 06:57:06 downsj Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.10 1996/06/17 06:57:06 downsj Exp $";
d916 1
d921 1
d932 1
a939 1
		free(p);
d943 1
d952 2
a953 3
		if (system(p) == -1)
			perror(ed);
		exit(1);
d956 5
a960 2
	while ((xpid = wait(&stat)) >= 0)
		if (xpid == pid)
d962 1
d964 1
a964 1
	return(!stat);
@


1.10
log
@Switch over to generic opendev(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.9 1996/06/12 08:02:44 downsj Exp $	*/
d51 1
a51 1
static char rcsid[] = "$OpenBSD$";
a72 1
#include <opendev.h>
d74 1
d235 1
a235 1
		0600, &specname);
@


1.9
log
@kill RAWPARTITION, use RAW_PART
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.8 1996/06/08 03:54:56 dm Exp $	*/
d51 1
a51 1
static char rcsid[] = "$NetBSD: disklabel.c,v 1.30 1996/03/14 19:49:24 ghudson Exp $";
d73 1
d234 2
a235 18
	f = open(dkname, op == READ ? O_RDONLY : O_RDWR);
	if (f != -1) {
		specname = dkname;
		goto ok;
	}
	if (dkname[0] != '/') {
		(void)sprintf(np, "%sr%s%c", _PATH_DEV, dkname, 'a' + RAW_PART);
		specname = np;
		np += strlen(specname) + 1;
	} else
		specname = dkname;
	f = open(specname, op == READ ? O_RDONLY : O_RDWR);
ok:
	if (f < 0 && errno == ENOENT && dkname[0] != '/') {
		(void)sprintf(specname, "%sr%s", _PATH_DEV, dkname);
		np = namebuf + strlen(specname) + 1;
		f = open(specname, op == READ ? O_RDONLY : O_RDWR);
	}
@


1.8
log
@missing brace
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.7 1996/06/06 12:10:01 deraadt Exp $	*/
a84 4
#ifndef RAWPARTITION
#define RAWPARTITION	'c'
#endif

d239 1
a239 1
		(void)sprintf(np, "%sr%s%c", _PATH_DEV, dkname, RAWPARTITION);
@


1.7
log
@system() $EDITOR safely
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.6 1996/05/18 19:06:38 pefo Exp $	*/
d944 1
a944 1
	if (!p)
@


1.6
log
@Minor glitch when no boot is used fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.c,v 1.3 1996/03/21 00:15:31 niklas Exp $	*/
d939 10
d956 1
a964 2
		char *ed;

d968 2
a969 4
		if ((ed = getenv("EDITOR")) == (char *)0)
			ed = DEFEDITOR;
		execlp(ed, ed, tmpfil, 0);
		perror(ed);
d972 1
@


1.5
log
@from Hiroyuki Ito:
there is a race condition exists when disklabel
trashes boot blocks (writing label w/o -B).
fix this.
@
text
@d430 2
d451 1
@


1.4
log
@Introduced DOSLABEL to control Dos label handling instead of associate with i386.
@
text
@d430 19
d687 1
d693 1
@


1.3
log
@From NetBSD: Merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d131 2
a132 2
#ifdef i386
struct dos_partition *dosdp;	/* i386 DOS partition, if found */
d258 1
a258 1
#ifdef i386
d402 1
a402 1
#ifdef i386
d542 1
a542 1
#ifdef i386
d550 2
a551 2
	static char mbr[DEV_BSIZE];
	struct dos_partition *dp = (struct dos_partition *)&mbr[DOSPARTOFF];
d554 5
d562 2
d606 1
a606 1
#ifdef i386
@


1.2
log
@attempt to open name as given incase it is a relative pathname
@
text
@d1 2
a2 1
/*	$NetBSD: disklabel.c,v 1.29 1995/06/26 23:17:26 jtc Exp $	*/
d51 1
a51 1
static char rcsid[] = "$NetBSD: disklabel.c,v 1.29 1995/06/26 23:17:26 jtc Exp $";
d785 14
a798 11
	fprintf(f, "bytes/sector: %d\n", lp->d_secsize);
	fprintf(f, "sectors/track: %d\n", lp->d_nsectors);
	fprintf(f, "tracks/cylinder: %d\n", lp->d_ntracks);
	fprintf(f, "sectors/cylinder: %d\n", lp->d_secpercyl);
	fprintf(f, "cylinders: %d\n", lp->d_ncylinders);
	fprintf(f, "rpm: %d\n", lp->d_rpm);
	fprintf(f, "interleave: %d\n", lp->d_interleave);
	fprintf(f, "trackskew: %d\n", lp->d_trackskew);
	fprintf(f, "cylinderskew: %d\n", lp->d_cylskew);
	fprintf(f, "headswitch: %d\t\t# milliseconds\n", lp->d_headswitch);
	fprintf(f, "track-to-track seek: %d\t# milliseconds\n", lp->d_trkseek);
d1103 9
@


1.1
log
@Initial revision
@
text
@d236 5
d248 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

