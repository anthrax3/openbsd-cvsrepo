head	1.49;
access;
symbols
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.45.0.6
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.6
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.40.0.4
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.2
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.6
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.4
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.31.0.8
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.6
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.6
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2017.01.21.08.31.44;	author krw;	state Exp;
branches;
next	1.48;
commitid	6pABae7LLaEPI7Ds;

1.48
date	2016.12.26.23.43.52;	author krw;	state Exp;
branches;
next	1.47;
commitid	vrrtXSUiwujWxgBE;

1.47
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.46;
commitid	82PdNqu2kKAuXPfA;

1.46
date	2015.08.25.04.18.43;	author guenther;	state Exp;
branches;
next	1.45;
commitid	tmwLojyIfsVatsQk;

1.45
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	Uu5nFG3wCl0LACBb;

1.44
date	2014.09.07.19.43.35;	author guenther;	state Exp;
branches;
next	1.43;
commitid	GSOkQ3sPLnOep58t;

1.43
date	2014.09.03.02.37.24;	author guenther;	state Exp;
branches;
next	1.42;
commitid	v6FMrndDh24XIoWk;

1.42
date	2014.07.21.01.51.11;	author guenther;	state Exp;
branches;
next	1.41;
commitid	ro8JUTvBpvQMiFY9;

1.41
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2012.07.14.08.58.18;	author halex;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.27.23.40.57;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.09.03.23.11.59;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.25.09.55.33;	author chl;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.13.09.19.56;	author chl;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.07.16.30.25;	author chl;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.02.15.19.25;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.03.20.16.08;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.14.19.46.05;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.30.01.51.32;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.13.21.51.18;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.19.03.49.44;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.06.13.29.41;	author avsm;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.13.05.00.44;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.07.18.26.20;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.09.03.26.06;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.14.22.38.19;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.16.16.43.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.08.17.09.13.15;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.02.17.00.07.52;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.02.10.20.20.03;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.24.08.07.23;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.07.25.19.13.13;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.07.05.20.51.26;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.04.16.04.07.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.01.27.09.33.08;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.12.27.09.48.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.11.19.23.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.04.01.41.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.01.15.27.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.21.00.16.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: tape.c,v 1.48 2016/12/26 23:43:52 krw Exp $	*/
/*	$NetBSD: tape.c,v 1.26 1997/04/15 07:12:25 lukem Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/ioctl.h>
#include <sys/mtio.h>
#include <sys/stat.h>

#include <ufs/ufs/dinode.h>
#include <protocols/dumprestore.h>

#include <err.h>
#include <fcntl.h>
#include <paths.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "restore.h"
#include "extern.h"

static long	fssize = MAXBSIZE;
static int	mt = -1;
static int	pipein = 0;
static char	magtape[BUFSIZ];
static int	blkcnt;
static int	numtrec;
static char	*tapebuf;
static union	u_spcl endoftapemark;
static long	blksread;		/* blocks read since last header */
static long	tpblksread = 0;		/* TP_BSIZE blocks read */
static long	tapesread;
static jmp_buf	restart;
static int	gettingfile = 0;	/* restart has a valid frame */
#ifdef RRESTORE
static char	*host = NULL;
#endif

static int	ofile;
static char	*map;
static char	lnkbuf[PATH_MAX + 1];
static size_t	pathlen;

int		oldinofmt;	/* old inode format conversion required */
int		Bcvt;		/* Swap Bytes (for CCI or sun) */

#define	FLUSHTAPEBUF()	blkcnt = ntrec + 1

union u_ospcl {
	char dummy[TP_BSIZE];
	struct	s_ospcl {
		int32_t   c_type;
		int32_t   c_date;
		int32_t   c_ddate;
		int32_t   c_volume;
		int32_t   c_tapea;
		u_int16_t c_inumber;
		int32_t   c_magic;
		int32_t   c_checksum;
		struct odinode {
			unsigned short odi_mode;
			u_int16_t odi_nlink;
			u_int16_t odi_uid;
			u_int16_t odi_gid;
			int32_t   odi_size;
			int32_t   odi_rdev;
			char      odi_addr[36];
			int32_t   odi_atime;
			int32_t   odi_mtime;
			int32_t   odi_ctime;
		} c_odinode;
		int32_t c_count;
		char    c_addr[256];
	} s_ospcl;
};

static void	 accthdr(struct s_spcl *);
static int	 checksum(int *);
static void	 findinode(struct s_spcl *);
static void	 findtapeblksize(void);
static int	 gethead(struct s_spcl *);
static void	 readtape(char *);
static void	 setdumpnum(void);
static void	 swap_header(struct s_spcl *);
static void	 swap_old_header(struct s_ospcl *);
static void	 terminateinput(void);
static void	 xtrlnkfile(char *, size_t);
static void	 xtrlnkskip(char *, size_t);
static void	 xtrmap(char *, size_t);
static void	 xtrmapskip(char *, size_t);
static void	 xtrskip(char *, size_t);

/*
 * Set up an input source
 */
void
setinput(char *source)
{
	FLUSHTAPEBUF();
	if (bflag)
		newtapebuf(ntrec);
	else
		/* Max out buffer size, let findtapeblksize() set ntrec. */
		newtapebuf(MAXBSIZE / TP_BSIZE);
	terminal = stdin;

#ifdef RRESTORE
	if (strchr(source, ':')) {
		host = source;
		source = strchr(host, ':');
		*source++ = '\0';
		if (rmthost(host) == 0)
			exit(1);
	} else
#endif
	if (strcmp(source, "-") == 0) {
		/*
		 * Since input is coming from a pipe we must establish
		 * our own connection to the terminal.
		 */
		terminal = fopen(_PATH_TTY, "r");
		if (terminal == NULL) {
			warn("cannot open %s", _PATH_TTY);
			terminal = fopen(_PATH_DEVNULL, "r");
			if (terminal == NULL)
				err(1, "cannot open %s", _PATH_DEVNULL);
		}
		pipein++;
	}
	(void)strlcpy(magtape, source, sizeof magtape);
}

void
newtapebuf(long size)
{
	static long tapebufsize = -1;

	ntrec = size;
	if (size <= tapebufsize)
		return;
	free(tapebuf);
	tapebuf = calloc(size, TP_BSIZE);
	if (tapebuf == NULL)
		errx(1, "Cannot allocate space for tape buffer");
	tapebufsize = size;
}

/*
 * Verify that the tape drive can be accessed and
 * that it actually is a dump tape.
 */
void
setup(void)
{
	int i, j, *ip;
	struct stat stbuf;

	Vprintf(stdout, "Verify tape and initialize maps\n");
#ifdef RRESTORE
	if (host)
		mt = rmtopen(magtape, O_RDONLY);
	else
#endif
	if (pipein)
		mt = 0;
	else
		mt = open(magtape, O_RDONLY);
	if (mt < 0)
		err(1, "%s", magtape);
	volno = 1;
	setdumpnum();
	FLUSHTAPEBUF();
	if (!pipein && !bflag)
		findtapeblksize();
	if (gethead(&spcl) == FAIL) {
		blkcnt--; /* push back this block */
		blksread--;
		tpblksread--;
		cvtflag++;
		if (gethead(&spcl) == FAIL)
			errx(1, "Tape is not a dump tape");
		(void)fputs("Converting to new file system format.\n", stderr);
	}
	if (pipein) {
		endoftapemark.s_spcl.c_magic = cvtflag ? OFS_MAGIC :
		    FS_UFS2_MAGIC;
		endoftapemark.s_spcl.c_type = TS_END;
		ip = (int *)&endoftapemark;
		j = sizeof(union u_spcl) / sizeof(int);
		i = 0;
		do
			i += *ip++;
		while (--j);
		endoftapemark.s_spcl.c_checksum = CHECKSUM - i;
	}
	if (vflag || command == 't')
		printdumpinfo();
	dumptime = (time_t)spcl.c_ddate;
	dumpdate = (time_t)spcl.c_date;
	if (stat(".", &stbuf) < 0)
		err(1, "cannot stat .");
	if (stbuf.st_blksize > 0 && stbuf.st_blksize < TP_BSIZE )
		fssize = TP_BSIZE;
	if (stbuf.st_blksize >= TP_BSIZE && stbuf.st_blksize <= MAXBSIZE)
		fssize = stbuf.st_blksize;
	if (((fssize - 1) & fssize) != 0)
		errx(1, "bad block size %ld", fssize);
	if (spcl.c_volume != 1)
		errx(1, "Tape is not volume 1 of the dump");
	if (gethead(&spcl) == FAIL) {
		Dprintf(stdout, "header read failed at %ld blocks\n", blksread);
		panic("no header after volume mark!\n");
	}
	findinode(&spcl);
	if (spcl.c_type != TS_CLRI)
		errx(1, "Cannot find file removal list");
	maxino = (spcl.c_count * TP_BSIZE * NBBY) + 1;
	Dprintf(stdout, "maxino = %llu\n", (unsigned long long)maxino);
	map = calloc(1, howmany(maxino, NBBY));
	if (map == NULL)
		panic("no memory for active inode map\n");
	usedinomap = map;
	curfile.action = USING;
	getfile(xtrmap, xtrmapskip);
	if (spcl.c_type != TS_BITS)
		errx(1, "Cannot find file dump list");
	map = calloc(1, howmany(maxino, NBBY));
	if (map == NULL)
		panic("no memory for file dump list\n");
	dumpmap = map;
	curfile.action = USING;
	getfile(xtrmap, xtrmapskip);
}

/*
 * Prompt user to load a new dump volume.
 * "Nextvol" is the next suggested volume to use.
 * This suggested volume is enforced when doing full
 * or incremental restores, but can be overrridden by
 * the user when only extracting a subset of the files.
 */
void
getvol(long nextvol)
{
	long newvol = 0, savecnt = 0, wantnext = 0, i;
	union u_spcl tmpspcl;
#	define tmpbuf tmpspcl.s_spcl
	char buf[TP_BSIZE];
	const char *errstr;

	if (nextvol == 1) {
		tapesread = 0;
		gettingfile = 0;
	}
	if (pipein) {
		if (nextvol != 1)
			panic("Changing volumes on pipe input?\n");
		if (volno == 1)
			return;
		goto gethdr;
	}
	savecnt = blksread;
again:
	if (pipein)
		exit(1); /* pipes do not get a second chance */
	if (command == 'R' || command == 'r' || curfile.action != SKIP) {
		newvol = nextvol;
		wantnext = 1;
	} else {
		newvol = 0;
		wantnext = 0;
	}
	while (newvol <= 0) {
		if (tapesread == 0) {
			fprintf(stderr, "%s%s%s%s%s",
			    "You have not read any tapes yet.\n",
			    "Unless you know which volume your",
			    " file(s) are on you should start\n",
			    "with the last volume and work",
			    " towards the first.\n");
		} else {
			fprintf(stderr, "You have read volumes");
			strlcpy(buf, ": ", sizeof buf);
			for (i = 1; i < 32; i++)
				if (tapesread & (1 << i)) {
					fprintf(stderr, "%s%ld", buf, i);
					strlcpy(buf, ", ", sizeof buf);
				}
			fprintf(stderr, "\n");
		}
		do	{
			fprintf(stderr, "Specify next volume #: ");
			(void)fflush(stderr);
			if (fgets(buf, sizeof buf, terminal) == NULL)
				exit(1);
			buf[strcspn(buf, "\n")] = '\0';

			newvol = strtonum(buf, 1, INT_MAX, &errstr);
			if (errstr)
				fprintf(stderr, "Volume number %s: %s\n", errstr, buf);
		} while (errstr);
	}
	if (newvol == volno) {
		tapesread |= 1 << volno;
		return;
	}
	closemt();
	fprintf(stderr, "Mount tape volume %ld\n", newvol);
	fprintf(stderr, "Enter ``none'' if there are no more tapes\n");
	fprintf(stderr, "otherwise enter tape name (default: %s) ", magtape);
	(void)fflush(stderr);
	if (fgets(buf, sizeof buf, terminal) == NULL || feof(terminal))
		exit(1);
	buf[strcspn(buf, "\n")] = '\0';
	if (strcmp(buf, "none") == 0) {
		terminateinput();
		return;
	}
	if (buf[0] != '\0')
		(void)strlcpy(magtape, buf, sizeof magtape);

#ifdef RRESTORE
	if (host)
		mt = rmtopen(magtape, O_RDONLY);
	else
#endif
		mt = open(magtape, O_RDONLY);

	if (mt == -1) {
		fprintf(stderr, "Cannot open %s\n", magtape);
		volno = -1;
		goto again;
	}
gethdr:
	volno = newvol;
	setdumpnum();
	FLUSHTAPEBUF();
	if (gethead(&tmpbuf) == FAIL) {
		Dprintf(stdout, "header read failed at %ld blocks\n", blksread);
		fprintf(stderr, "tape is not dump tape\n");
		volno = 0;
		goto again;
	}
	if (tmpbuf.c_volume != volno) {
		fprintf(stderr, "Wrong volume (%d)\n", tmpbuf.c_volume);
		volno = 0;
		goto again;
	}
	if (tmpbuf.c_date != dumpdate || tmpbuf.c_ddate != dumptime) {
		time_t t = (time_t)tmpbuf.c_date;
		fprintf(stderr, "Wrong dump date\n\tgot: %s", ctime(&t));
		fprintf(stderr, "\twanted: %s", ctime(&dumpdate));
		volno = 0;
		goto again;
	}
	tapesread |= 1 << volno;
	blksread = savecnt;
	/*
	 * If continuing from the previous volume, skip over any
	 * blocks read already at the end of the previous volume.
	 *
	 * If coming to this volume at random, skip to the beginning
	 * of the next record.
	 */
	Dprintf(stdout, "read %ld recs, tape starts with %lld\n",
		tpblksread, tmpbuf.c_firstrec);
	if (tmpbuf.c_type == TS_TAPE && (tmpbuf.c_flags & DR_NEWHEADER)) {
		if (!wantnext) {
			tpblksread = tmpbuf.c_firstrec;
			for (i = tmpbuf.c_count; i > 0; i--)
				readtape(buf);
		} else if (tmpbuf.c_firstrec > 0 &&
			   tmpbuf.c_firstrec < tpblksread - 1) {
			/*
			 * -1 since we've read the volume header
			 */
			i = tpblksread - tmpbuf.c_firstrec - 1;
			Dprintf(stderr, "Skipping %ld duplicate record%s.\n",
				i, (i == 1) ? "" : "s");
			while (--i >= 0)
				readtape(buf);
		}
	}
	if (curfile.action == USING) {
		if (volno == 1)
			panic("active file into volume 1\n");
		return;
	}
	/*
	 * Skip up to the beginning of the next record
	 */
	if (tmpbuf.c_type == TS_TAPE && (tmpbuf.c_flags & DR_NEWHEADER))
		for (i = tmpbuf.c_count; i > 0; i--)
			readtape(buf);
	(void)gethead(&spcl);
	findinode(&spcl);
	if (gettingfile) {
		gettingfile = 0;
		longjmp(restart, 1);
	}
}

/*
 * Handle unexpected EOF.
 */
static void
terminateinput(void)
{

	if (gettingfile && curfile.action == USING) {
		printf("Warning: %s %s\n",
		    "End-of-input encountered while extracting", curfile.name);
	}
	curfile.name = "<name unknown>";
	curfile.action = UNKNOWN;
	curfile.mode = 0;
	curfile.ino = maxino;
	if (gettingfile) {
		gettingfile = 0;
		longjmp(restart, 1);
	}
}

/*
 * handle multiple dumps per tape by skipping forward to the
 * appropriate one.
 */
static void
setdumpnum(void)
{
	struct mtop tcom;

	if (dumpnum == 1 || volno != 1)
		return;
	if (pipein)
		errx(1, "Cannot have multiple dumps on pipe input");
	tcom.mt_op = MTFSF;
	tcom.mt_count = dumpnum - 1;
#ifdef RRESTORE
	if (host)
		rmtioctl(MTFSF, dumpnum - 1);
	else
#endif
		if (ioctl(mt, MTIOCTOP, (char *)&tcom) < 0)
			warn("ioctl MTFSF");
}

void
printdumpinfo(void)
{
	time_t t;

	t = (time_t)spcl.c_date;
	fprintf(stdout, "Dump   date: %s", ctime(&t));
	t = (time_t)spcl.c_ddate;
	fprintf(stdout, "Dumped from: %s",
	    (spcl.c_ddate == 0) ? "the epoch\n" : ctime(&t));
	if (spcl.c_host[0] == '\0')
		return;
	fprintf(stderr, "Level %d dump of %s on %s:%s\n",
		spcl.c_level, spcl.c_filesys, spcl.c_host, spcl.c_dev);
	fprintf(stderr, "Label: %s\n", spcl.c_label);
}

int
extractfile(char *name)
{
	u_int flags;
	uid_t uid;
	gid_t gid;
	mode_t mode;
	struct timespec mtimep[2], ctimep[2];
	struct entry *ep;
	int setbirth;

	curfile.name = name;
	curfile.action = USING;
	mtimep[0].tv_sec = curfile.atime_sec;
	mtimep[0].tv_nsec = curfile.atime_nsec;
	mtimep[1].tv_sec = curfile.mtime_sec;
	mtimep[1].tv_nsec = curfile.mtime_nsec;

	setbirth = curfile.birthtime_sec != 0;
	if (setbirth) {
		ctimep[0].tv_sec = curfile.atime_sec;
		ctimep[0].tv_nsec = curfile.atime_nsec;
		ctimep[1].tv_sec = curfile.birthtime_sec;
		ctimep[1].tv_nsec = curfile.birthtime_nsec;
	}
	uid = curfile.uid;
	gid = curfile.gid;
	mode = curfile.mode;
	flags = curfile.file_flags;
	switch (mode & IFMT) {

	default:
		fprintf(stderr, "%s: unknown file mode 0%o\n", name, mode);
		skipfile();
		return (FAIL);

	case IFSOCK:
		Vprintf(stdout, "skipped socket %s\n", name);
		skipfile();
		return (GOOD);

	case IFDIR:
		if (mflag) {
			ep = lookupname(name);
			if (ep == NULL || ep->e_flags & EXTRACT)
				panic("unextracted directory %s\n", name);
			skipfile();
			return (GOOD);
		}
		Vprintf(stdout, "extract file %s\n", name);
		return (genliteraldir(name, curfile.ino));

	case IFLNK: {
			lnkbuf[0] = '\0';
			pathlen = 0;
			getfile(xtrlnkfile, xtrlnkskip);
			if (pathlen == 0) {
				Vprintf(stdout,
				    "%s: zero length symbolic link (ignored)\n",
				     name);
				return (GOOD);
			}
			if (linkit(lnkbuf, name, SYMLINK) == FAIL)
				return (FAIL);
			(void)lchown(name, uid, gid);
			return (GOOD);
		}

	case IFCHR:
	case IFBLK:
		Vprintf(stdout, "extract special file %s\n", name);
		if (Nflag) {
			skipfile();
			return (GOOD);
		}
		if (mknod(name, mode, (int)curfile.rdev) < 0) {
			warn("%s: cannot create special file", name);
			skipfile();
			return (FAIL);
		}
		(void)chown(name, uid, gid);
		(void)chmod(name, mode);
		(void)chflags(name, flags);
		skipfile();
		if (setbirth)
			(void)utimensat(AT_FDCWD, name, ctimep, 0);
		(void)utimensat(AT_FDCWD, name, mtimep, 0);
		return (GOOD);

	case IFIFO:
		Vprintf(stdout, "extract fifo %s\n", name);
		if (Nflag) {
			skipfile();
			return (GOOD);
		}
		if (mkfifo(name, mode) < 0) {
			warn("%s: cannot create fifo", name);
			skipfile();
			return (FAIL);
		}
		(void)chown(name, uid, gid);
		(void)chmod(name, mode);
		(void)chflags(name, flags);
		skipfile();
		if (setbirth)
			(void)utimensat(AT_FDCWD, name, ctimep, 0);
		(void)utimensat(AT_FDCWD, name, mtimep, 0);
		return (GOOD);

	case IFREG:
		Vprintf(stdout, "extract file %s\n", name);
		if (Nflag) {
			skipfile();
			return (GOOD);
		}
		if ((ofile = open(name, O_WRONLY | O_CREAT | O_TRUNC,
		    0666)) < 0) {
			warn("%s: cannot create file", name);
			skipfile();
			return (FAIL);
		}
		(void)fchown(ofile, curfile.uid, curfile.gid);
		(void)fchmod(ofile, mode);
		(void)fchflags(ofile, flags);
		getfile(xtrfile, xtrskip);
		(void)close(ofile);
		if (setbirth)
			(void)utimensat(AT_FDCWD, name, ctimep, 0);
		(void)utimensat(AT_FDCWD, name, mtimep, 0);
		return (GOOD);
	}
	/* NOTREACHED */
}

/*
 * skip over bit maps on the tape
 */
void
skipmaps(void)
{

	while (spcl.c_type == TS_BITS || spcl.c_type == TS_CLRI)
		skipfile();
}

/*
 * skip over a file on the tape
 */
void
skipfile(void)
{

	curfile.action = SKIP;
	getfile(xtrnull, xtrnull);
}

/*
 * Extract a file from the tape.
 * When an allocated block is found it is passed to the fill function;
 * when an unallocated block (hole) is found, a zeroed buffer is passed
 * to the skip function.
 *
 * For some block types (TS_BITS, TS_CLRI), the c_addr map is not meaningful
 * and no blocks should be skipped.
 */
void
getfile(void (*fill)(char *, size_t), void (*skip)(char *, size_t))
{
	int i;
	volatile int curblk = 0;
	volatile off_t size = spcl.c_size;
	static char clearedbuf[MAXBSIZE];
	char buf[MAXBSIZE / TP_BSIZE][TP_BSIZE];
	char junk[TP_BSIZE];
	volatile int noskip = (spcl.c_type == TS_BITS || spcl.c_type == TS_CLRI);

	if (spcl.c_type == TS_END)
		panic("ran off end of tape\n");
	if (spcl.c_magic != FS_UFS2_MAGIC)
		panic("not at beginning of a file\n");
	if (!gettingfile && setjmp(restart) != 0)
		return;
	gettingfile++;
loop:
	for (i = 0; i < spcl.c_count; i++) {
		if (noskip || spcl.c_addr[i]) {
			readtape(&buf[curblk++][0]);
			if (curblk == fssize / TP_BSIZE) {
				(*fill)((char *)buf, size > TP_BSIZE ?
				     fssize :
				     ((off_t)curblk - 1) * TP_BSIZE + size);
				curblk = 0;
			}
		} else {
			if (curblk > 0) {
				(*fill)((char *)buf, size > TP_BSIZE ?
				     (curblk * TP_BSIZE) :
				     ((off_t)curblk - 1) * TP_BSIZE + size);
				curblk = 0;
			}
			(*skip)(clearedbuf, size > TP_BSIZE ?
				TP_BSIZE : size);
		}
		if ((size -= TP_BSIZE) <= 0) {
			for (i++; i < spcl.c_count; i++)
				if (noskip || spcl.c_addr[i])
					readtape(junk);
			break;
		}
	}
	if (gethead(&spcl) == GOOD && size > 0) {
		if (spcl.c_type == TS_ADDR)
			goto loop;
		Dprintf(stdout,
			"Missing address (header) block for %s at %ld blocks\n",
			curfile.name, blksread);
	}
	if (curblk > 0)
		(*fill)((char *)buf, ((off_t)curblk * TP_BSIZE) + size);
	findinode(&spcl);
	gettingfile = 0;
}

/*
 * Write out the next block of a file.
 */
void
xtrfile(char *buf, size_t size)
{

	if (Nflag)
		return;
	if (write(ofile, buf, size) == -1)
		err(1, "write error extracting inode %llu, name %s\nwrite",
		    (unsigned long long)curfile.ino, curfile.name);
}

/*
 * Skip over a hole in a file.
 */
/* ARGSUSED */
static void
xtrskip(char *buf, size_t size)
{

	if (lseek(ofile, (off_t)size, SEEK_CUR) == -1)
		err(1, "seek error extracting inode %llu, name %s\nlseek",
		    (unsigned long long)curfile.ino, curfile.name);
}

/*
 * Collect the next block of a symbolic link.
 */
static void
xtrlnkfile(char *buf, size_t size)
{

	pathlen += size;
	if (pathlen > PATH_MAX)
		errx(1, "symbolic link name: %s->%s%s; too long %lu",
		    curfile.name, lnkbuf, buf, (u_long)pathlen);
	(void)strlcat(lnkbuf, buf, sizeof(lnkbuf));
}

/*
 * Skip over a hole in a symbolic link (should never happen).
 */
/* ARGSUSED */
static void
xtrlnkskip(char *buf, size_t size)
{

	errx(1, "unallocated block in symbolic link %s", curfile.name);
}

/*
 * Collect the next block of a bit map.
 */
static void
xtrmap(char *buf, size_t size)
{

	memcpy(map, buf, size);
	map += size;
}

/*
 * Skip over a hole in a bit map (should never happen).
 */
/* ARGSUSED */
static void
xtrmapskip(char *buf, size_t size)
{

	panic("hole in map\n");
	map += size;
}

/*
 * Noop, when an extraction function is not needed.
 */
/* ARGSUSED */
void
xtrnull(char *buf, size_t size)
{

	return;
}

/*
 * Read TP_BSIZE blocks from the input.
 * Handle read errors, and end of media.
 */
static void
readtape(char *buf)
{
	long rd, newvol, i;
	int cnt, seek_failed;

	if (blkcnt < numtrec) {
		memcpy(buf, &tapebuf[(blkcnt++ * TP_BSIZE)], TP_BSIZE);
		blksread++;
		tpblksread++;
		return;
	}
	for (i = 0; i < ntrec; i++)
		((struct s_spcl *)&tapebuf[i * TP_BSIZE])->c_magic = 0;
	if (numtrec == 0)
		numtrec = ntrec;
	cnt = ntrec * TP_BSIZE;
	rd = 0;
getmore:
#ifdef RRESTORE
	if (host)
		i = rmtread(&tapebuf[rd], cnt);
	else
#endif
		i = read(mt, &tapebuf[rd], cnt);
	/*
	 * Check for mid-tape short read error.
	 * If found, skip rest of buffer and start with the next.
	 */
	if (!pipein && numtrec < ntrec && i > 0) {
		Dprintf(stdout, "mid-media short read error.\n");
		numtrec = ntrec;
	}
	/*
	 * Handle partial block read.
	 */
	if (pipein && i == 0 && rd > 0)
		i = rd;
	else if (i > 0 && i != ntrec * TP_BSIZE) {
		if (pipein) {
			rd += i;
			cnt -= i;
			if (cnt > 0)
				goto getmore;
			i = rd;
		} else {
			/*
			 * Short read. Process the blocks read.
			 */
			if (i % TP_BSIZE != 0)
				Vprintf(stdout,
				    "partial block read: %ld should be %ld\n",
				    i, ntrec * TP_BSIZE);
			numtrec = i / TP_BSIZE;
		}
	}
	/*
	 * Handle read error.
	 */
	if (i < 0) {
		fprintf(stderr, "Tape read error while ");
		switch (curfile.action) {
		default:
			fprintf(stderr, "trying to set up tape\n");
			break;
		case UNKNOWN:
			fprintf(stderr, "trying to resynchronize\n");
			break;
		case USING:
			fprintf(stderr, "restoring %s\n", curfile.name);
			break;
		case SKIP:
			fprintf(stderr, "skipping over inode %llu\n",
			    (unsigned long long)curfile.ino);
			break;
		}
		if (!yflag && !reply("continue"))
			exit(1);
		i = ntrec * TP_BSIZE;
		memset(tapebuf, 0, i);
#ifdef RRESTORE
		if (host)
			seek_failed = (rmtseek(i, 1) < 0);
		else
#endif
			seek_failed = (lseek(mt, i, SEEK_CUR) == (off_t)-1);

		if (seek_failed)
			err(1, "continuation failed");
	}
	/*
	 * Handle end of tape.
	 */
	if (i == 0) {
		Vprintf(stdout, "End-of-tape encountered\n");
		if (!pipein) {
			newvol = volno + 1;
			volno = 0;
			numtrec = 0;
			getvol(newvol);
			readtape(buf);
			return;
		}
		if (rd % TP_BSIZE != 0)
			panic("partial block read: %ld should be %ld\n",
				rd, ntrec * TP_BSIZE);
		terminateinput();
		memcpy(&tapebuf[rd], &endoftapemark, TP_BSIZE);
	}
	blkcnt = 0;
	memcpy(buf, &tapebuf[(blkcnt++ * TP_BSIZE)], TP_BSIZE);
	blksread++;
	tpblksread++;
}

static void
findtapeblksize(void)
{
	long i;

	for (i = 0; i < ntrec; i++)
		((struct s_spcl *)&tapebuf[i * TP_BSIZE])->c_magic = 0;
	blkcnt = 0;
#ifdef RRESTORE
	if (host)
		i = rmtread(tapebuf, ntrec * TP_BSIZE);
	else
#endif
		i = read(mt, tapebuf, ntrec * TP_BSIZE);

	if (i <= 0)
		err(1, "tape read error");
	if (i % TP_BSIZE != 0) {
		errx(1,
		    "Tape block size (%ld) is not a multiple of dump block size (%d)",
		    i, TP_BSIZE);
	}
	ntrec = i / TP_BSIZE;
	numtrec = ntrec;
	Vprintf(stdout, "Tape block size is %ld\n", ntrec);
}

void
closemt(void)
{

	if (mt < 0)
		return;
#ifdef RRESTORE
	if (host)
		rmtclose();
	else
#endif
		(void)close(mt);
}

/*
 * Read the next block from the tape.
 * Check to see if it is one of several vintage headers.
 * If it is an old style header, convert it to a new style header.
 * If it is not any valid header, return an error.
 */
static int
gethead(struct s_spcl *buf)
{
	union u_ospcl u_ospcl;

	if (!cvtflag) {
		readtape((char *)buf);
		if (buf->c_magic != NFS_MAGIC &&
		    buf->c_magic != FS_UFS2_MAGIC) {
			if (swap32(buf->c_magic) != NFS_MAGIC &&
			    swap32(buf->c_magic) != FS_UFS2_MAGIC)
				return (FAIL);
			if (!Bcvt) {
				Vprintf(stdout, "Note: Doing Byte swapping\n");
				Bcvt = 1;
			}
		}
		if (checksum((int *)buf) == FAIL)
			return (FAIL);
		if (Bcvt)
			swap_header(buf);
		goto good;
	}

	readtape((char *)(&u_ospcl.s_ospcl));
	if (checksum((int *)(&u_ospcl.s_ospcl)) == FAIL)
		return (FAIL);
	if (u_ospcl.s_ospcl.c_magic != OFS_MAGIC) {
		if (swap32(u_ospcl.s_ospcl.c_magic) != OFS_MAGIC)
			return (FAIL);
		if (!Bcvt) {
			fprintf(stdout, "Note: Doing Byte swapping\n");
			Bcvt = 1;
		}
		swap_old_header(&u_ospcl.s_ospcl);
	}

	memset(buf, 0, TP_BSIZE);
	buf->c_type = u_ospcl.s_ospcl.c_type;
	buf->c_date = u_ospcl.s_ospcl.c_date;
	buf->c_ddate = u_ospcl.s_ospcl.c_ddate;
	buf->c_volume = u_ospcl.s_ospcl.c_volume;
	buf->c_tapea = u_ospcl.s_ospcl.c_tapea;
	buf->c_inumber = u_ospcl.s_ospcl.c_inumber;
	buf->c_checksum = u_ospcl.s_ospcl.c_checksum;
	buf->c_mode = u_ospcl.s_ospcl.c_odinode.odi_mode;
	buf->c_uid = u_ospcl.s_ospcl.c_odinode.odi_uid;
	buf->c_gid = u_ospcl.s_ospcl.c_odinode.odi_gid;
	buf->c_size = u_ospcl.s_ospcl.c_odinode.odi_size;
	buf->c_rdev = u_ospcl.s_ospcl.c_odinode.odi_rdev;
	buf->c_atime = u_ospcl.s_ospcl.c_odinode.odi_atime;
	buf->c_mtime = u_ospcl.s_ospcl.c_odinode.odi_mtime;
	buf->c_count = u_ospcl.s_ospcl.c_count;
	memcpy(buf->c_addr, u_ospcl.s_ospcl.c_addr, 256);
	buf->c_magic = FS_UFS2_MAGIC;
good:
	switch (buf->c_type) {

	case TS_CLRI:
	case TS_BITS:
		/*
		 * Have to patch up missing information in bit map headers
		 */
		buf->c_inumber = 0;
		buf->c_size = buf->c_count * TP_BSIZE;
		break;

	case TS_TAPE:
		if ((buf->c_flags & DR_NEWINODEFMT) == 0)
			oldinofmt = 1;
		/* fall through */
	case TS_END:
		buf->c_inumber = 0;
		break;

	case TS_INODE:
		if (buf->c_magic == NFS_MAGIC) {
			buf->c_tapea = buf->c_old_tapea;
			buf->c_firstrec = buf->c_old_firstrec;
			buf->c_date = buf->c_old_date;
			buf->c_ddate = buf->c_old_ddate;
			buf->c_atime = buf->c_old_atime;
			buf->c_mtime = buf->c_old_mtime;
			buf->c_birthtime = 0;
			buf->c_birthtimensec = 0;
			buf->c_atimensec = buf->c_mtimensec = 0;
		}

	case TS_ADDR:
		break;

	default:
		panic("gethead: unknown inode type %d\n", buf->c_type);
		break;
	}

	buf->c_magic = FS_UFS2_MAGIC;

	/*
	 * If we are restoring a filesystem with old format inodes,
	 * copy the uid/gid to the new location.
	 */
	if (oldinofmt) {
		buf->c_uid = buf->c_spare1[1];
		buf->c_gid = buf->c_spare1[2];
	}
	if (dflag)
		accthdr(buf);
	return(GOOD);
}

/*
 * Check that a header is where it belongs and predict the next header
 */
static void
accthdr(struct s_spcl *header)
{
	static ino_t previno = (ino_t)-1;
	static int prevtype;
	static long predict;
	long blks, i;

	if (header->c_type == TS_TAPE) {
		fprintf(stderr, "Volume header (%s inode format) ",
		    oldinofmt ? "old" : "new");
		if (header->c_firstrec)
			fprintf(stderr, "begins with record %lld",
				(long long)header->c_firstrec);
		fprintf(stderr, "\n");
		previno = (ino_t)-1;
		return;
	}
	if (previno == (ino_t)-1)
		goto newcalc;
	switch (prevtype) {
	case TS_BITS:
		fprintf(stderr, "Dumped inodes map header");
		break;
	case TS_CLRI:
		fprintf(stderr, "Used inodes map header");
		break;
	case TS_INODE:
		fprintf(stderr, "File header, ino %llu",
		    (unsigned long long)previno);
		break;
	case TS_ADDR:
		fprintf(stderr, "File continuation header, ino %llu",
		    (unsigned long long)previno);
		break;
	case TS_END:
		fprintf(stderr, "End of tape header");
		break;
	}
	if (predict != blksread - 1)
		fprintf(stderr, "; predicted %ld blocks, got %ld blocks",
			predict, blksread - 1);
	fprintf(stderr, "\n");
newcalc:
	blks = 0;
	switch (header->c_type) {

	case TS_BITS:
	case TS_CLRI:
		blks = header->c_count;
		break;

	case TS_END:
		break;

	default:
		for (i = 0; i < header->c_count; i++)
			if (header->c_addr[i] != 0)
				blks++;
	}
	predict = blks;
	blksread = 0;
	prevtype = header->c_type;
	previno = header->c_inumber;
}

/*
 * Find an inode header.
 * Complain if had to skip, and complain is set.
 */
static void
findinode(struct s_spcl *header)
{
	static long skipcnt = 0;
	long i;
	char buf[TP_BSIZE];

	curfile.name = "<name unknown>";
	curfile.action = UNKNOWN;
	curfile.mode = 0;
	curfile.ino = 0;
	do {
		if (header->c_magic != FS_UFS2_MAGIC) {
			skipcnt++;
			while (gethead(header) == FAIL ||
			    header->c_date != dumpdate)
				skipcnt++;
		}
		switch (header->c_type) {

		case TS_ADDR:
			/*
			 * Skip up to the beginning of the next record
			 */
			for (i = 0; i < header->c_count; i++)
				if (header->c_addr[i])
					readtape(buf);
			while (gethead(header) == FAIL ||
			    header->c_date != dumpdate)
				skipcnt++;
			break;

		case TS_INODE:
			curfile.mode = header->c_mode;
			curfile.uid = header->c_uid;
			curfile.gid = header->c_gid;
			curfile.file_flags = header->c_file_flags;
			curfile.rdev = header->c_rdev;
			curfile.atime_sec = header->c_atime;
			curfile.atime_nsec = header->c_atimensec;
			curfile.mtime_sec = header->c_mtime;
			curfile.mtime_nsec = header->c_mtimensec;
			curfile.birthtime_sec = header->c_birthtime;
			curfile.birthtime_nsec = header->c_birthtimensec;
			curfile.size = header->c_size;
			curfile.ino = header->c_inumber;
			break;

		case TS_END:
			curfile.ino = maxino;
			break;

		case TS_CLRI:
			curfile.name = "<file removal list>";
			break;

		case TS_BITS:
			curfile.name = "<file dump list>";
			break;

		case TS_TAPE:
			panic("unexpected tape header\n");
			/* NOTREACHED */

		default:
			panic("unknown tape header type %d\n", spcl.c_type);
			/* NOTREACHED */

		}
	} while (header->c_type == TS_ADDR);
	if (skipcnt > 0)
		fprintf(stderr, "resync restore, skipped %ld blocks\n", skipcnt);
	skipcnt = 0;
}

static int
checksum(int *buf)
{
	int i, j;

	j = sizeof(union u_spcl) / sizeof(int);
	i = 0;
	if (!Bcvt) {
		do
			i += *buf++;
		while (--j);
	} else {
		do
			i += swap32(*buf++);
		while (--j);
	}

	if (i != CHECKSUM) {
		fprintf(stderr, "Checksum error %o, inode %llu file %s\n", i,
		    (unsigned long long)curfile.ino, curfile.name);
		return(FAIL);
	}
	return(GOOD);
}

#ifdef RRESTORE
#include <stdarg.h>

void
msg(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
}
#endif /* RRESTORE */

static void
swap_header(struct s_spcl *s)
{
	s->c_type = swap32(s->c_type);
	s->c_old_date = swap32(s->c_old_date);
	s->c_old_ddate = swap32(s->c_old_ddate);
	s->c_volume = swap32(s->c_volume);
	s->c_old_tapea = swap32(s->c_old_tapea);
	s->c_inumber = swap32(s->c_inumber);
	s->c_magic = swap32(s->c_magic);
	s->c_checksum = swap32(s->c_checksum);

	s->c_mode = swap16(s->c_mode);
	s->c_size = swap64(s->c_size);
	s->c_old_atime = swap32(s->c_old_atime);
	s->c_atimensec = swap32(s->c_atimensec);
	s->c_old_mtime = swap32(s->c_old_mtime);
	s->c_mtimensec = swap32(s->c_mtimensec);
	s->c_rdev = swap32(s->c_rdev);
	s->c_birthtimensec = swap32(s->c_birthtimensec);
	s->c_birthtime = swap64(s->c_birthtime);
	s->c_atime = swap64(s->c_atime);
	s->c_mtime = swap64(s->c_mtime);
	s->c_file_flags = swap32(s->c_file_flags);
	s->c_uid = swap32(s->c_uid);
	s->c_gid = swap32(s->c_gid);

	s->c_count = swap32(s->c_count);
	s->c_level = swap32(s->c_level);
	s->c_flags = swap32(s->c_flags);
	s->c_old_firstrec = swap32(s->c_old_firstrec);

	s->c_date = swap64(s->c_date);
	s->c_ddate = swap64(s->c_ddate);
	s->c_tapea = swap64(s->c_tapea);
	s->c_firstrec = swap64(s->c_firstrec);

	/*
	 * These are ouid and ogid.
	 */
	s->c_spare1[1] = swap16(s->c_spare1[1]);
	s->c_spare1[2] = swap16(s->c_spare1[2]);
}

static void
swap_old_header(struct s_ospcl *os)
{
	os->c_type = swap32(os->c_type);
	os->c_date = swap32(os->c_date);
	os->c_ddate = swap32(os->c_ddate);
	os->c_volume = swap32(os->c_volume);
	os->c_tapea = swap32(os->c_tapea);
	os->c_inumber = swap16(os->c_inumber);
	os->c_magic = swap32(os->c_magic);
	os->c_checksum = swap32(os->c_checksum);

	os->c_odinode.odi_mode = swap16(os->c_odinode.odi_mode);
	os->c_odinode.odi_nlink = swap16(os->c_odinode.odi_nlink);
	os->c_odinode.odi_uid = swap16(os->c_odinode.odi_uid);
	os->c_odinode.odi_gid = swap16(os->c_odinode.odi_gid);

	os->c_odinode.odi_size = swap32(os->c_odinode.odi_size);
	os->c_odinode.odi_rdev = swap32(os->c_odinode.odi_rdev);
	os->c_odinode.odi_atime = swap32(os->c_odinode.odi_atime);
	os->c_odinode.odi_mtime = swap32(os->c_odinode.odi_mtime);
	os->c_odinode.odi_ctime = swap32(os->c_odinode.odi_ctime);

	os->c_count = swap32(os->c_count);
}
@


1.48
log
@Put some variable declarations under appropriate #if/#endif protection
so gcc doesn't complain about defining but not using them.

typo correction & ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.47 2015/12/10 17:27:00 mmcc Exp $	*/
d395 7
a401 7
 	/*
 	 * If continuing from the previous volume, skip over any
 	 * blocks read already at the end of the previous volume.
 	 *
 	 * If coming to this volume at random, skip to the beginning
 	 * of the next record.
 	 */
d404 6
a409 6
 	if (tmpbuf.c_type == TS_TAPE && (tmpbuf.c_flags & DR_NEWHEADER)) {
 		if (!wantnext) {
 			tpblksread = tmpbuf.c_firstrec;
 			for (i = tmpbuf.c_count; i > 0; i--)
 				readtape(buf);
 		} else if (tmpbuf.c_firstrec > 0 &&
d414 1
a414 1
 			i = tpblksread - tmpbuf.c_firstrec - 1;
d417 4
a420 4
 			while (--i >= 0)
 				readtape(buf);
 		}
 	}
d1064 1
a1064 1
			
d1076 1
a1076 1
	 * If we are restoring a filesystem with old format inodes, 
d1102 4
a1105 4
 		if (header->c_firstrec)
 			fprintf(stderr, "begins with record %lld",
 				(long long)header->c_firstrec);
 		fprintf(stderr, "\n");
@


1.47
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.46 2015/08/25 04:18:43 guenther Exp $	*/
d72 1
d74 1
@


1.46
log
@Switch from utimes() to utimensat() to $estore full nanosecond granularity

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.45 2015/01/16 06:40:00 deraadt Exp $	*/
d176 1
a176 2
	if (tapebuf != NULL)
		free(tapebuf);
@


1.45
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.44 2014/09/07 19:43:35 guenther Exp $	*/
d508 1
a508 1
	struct timeval mtimep[2], ctimep[2];
d515 1
a515 1
	mtimep[0].tv_usec = curfile.atime_nsec / 1000;
d517 1
a517 1
	mtimep[1].tv_usec = curfile.mtime_nsec / 1000;
d522 1
a522 1
		ctimep[0].tv_usec = curfile.atime_nsec / 1000;
d524 1
a524 1
		ctimep[1].tv_usec = curfile.birthtime_nsec / 1000;
d586 2
a587 2
			(void)utimes(name, ctimep);
		(void)utimes(name, mtimep);
d606 2
a607 2
			(void)utimes(name, ctimep);
		(void)utimes(name, mtimep);
d628 2
a629 2
			(void)utimes(name, ctimep);
		(void)utimes(name, mtimep);
@


1.44
log
@Reuse xtrfile() to avoid duplication.
Casting from long to int for a size_t argument is dumb.
Calling warnx() right before err() is silly.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.43 2014/09/03 02:37:24 guenther Exp $	*/
d38 1
a38 1
#include <sys/param.h>
d54 1
d76 1
a76 1
static char	lnkbuf[MAXPATHLEN + 1];
d759 1
a759 1
	if (pathlen > MAXPATHLEN)
@


1.43
log
@Mark msg() and panic() as printf-like and fix the format error it turns up

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.42 2014/07/21 01:51:11 guenther Exp $	*/
a120 1
static void	 xtrfile(char *, size_t);
d726 1
a726 1
static void
@


1.42
log
@Switch from <sys/endian.h> or <machine/endian.h> to the new,
being-standardized <endian.h>

ok deraadt@@ millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.41 2013/04/24 13:46:29 deraadt Exp $	*/
d918 1
a918 1
			panic("partial block read: %d should be %d\n",
@


1.41
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.40 2012/07/14 08:58:18 halex Exp $	*/
a41 1
#include <sys/endian.h>
@


1.40
log
@replace (somewhat) magic numbers with constants

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.39 2011/06/27 23:40:57 tedu Exp $	*/
d255 1
a255 1
	Dprintf(stdout, "maxino = %d\n", maxino);
d735 2
a736 2
		err(1, "write error extracting inode %d, name %s\nwrite",
		    curfile.ino, curfile.name);
d748 2
a749 2
		err(1, "seek error extracting inode %d, name %s\nlseek",
		    curfile.ino, curfile.name);
d887 2
a888 2
			fprintf(stderr, "skipping over inode %d\n",
				curfile.ino);
d1094 1
a1094 1
	static ino_t previno = 0x7fffffff;
d1106 1
a1106 1
		previno = 0x7fffffff;
d1109 1
a1109 1
	if (previno == 0x7fffffff)
d1119 2
a1120 1
		fprintf(stderr, "File header, ino %d", previno);
d1123 2
a1124 1
		fprintf(stderr, "File continuation header, ino %d", previno);
d1254 2
a1255 2
		fprintf(stderr, "Checksum error %o, inode %d file %s\n", i,
			curfile.ino, curfile.name);
@


1.39
log
@remove some useless casts. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.38 2009/10/27 23:59:34 deraadt Exp $	*/
d198 1
a198 1
		mt = rmtopen(magtape, 0);
d361 1
a361 1
		mt = rmtopen(magtape, 0);
@


1.38
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.37 2008/09/03 23:11:59 krw Exp $	*/
d256 1
a256 1
	map = calloc((unsigned)1, (unsigned)howmany(maxino, NBBY));
d264 1
a264 1
	map = calloc((size_t)1, (size_t)howmany(maxino, NBBY));
d822 1
a822 1
		memcpy(buf, &tapebuf[(blkcnt++ * TP_BSIZE)], (long)TP_BSIZE);
d922 1
a922 1
		memcpy(&tapebuf[rd], &endoftapemark, (long)TP_BSIZE);
d925 1
a925 1
	memcpy(buf, &tapebuf[(blkcnt++ * TP_BSIZE)], (long)TP_BSIZE);
d1014 1
a1014 1
	memset(buf, 0, (long)TP_BSIZE);
d1030 1
a1030 1
	memcpy(buf->c_addr, u_ospcl.s_ospcl.c_addr, (long)256);
@


1.37
log
@Start with a max size tape buffer rather than one 1/2 the max (i.e.
32K). This allows the automatic recognition of dumps written with
64K buffers. It also prevents alert scsi devices from complaining
about read requests that provide only 1/2 the room needed for an
actual tape record.

Problem noted, fix tested & ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.36 2007/09/25 09:55:33 chl Exp $	*/
a36 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)tape.c	8.6 (Berkeley) 9/13/94";
#else
static const char rcsid[] = "$OpenBSD: tape.c,v 1.36 2007/09/25 09:55:33 chl Exp $";
#endif
#endif /* not lint */
@


1.36
log
@remove unneeded feof

with help and ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.35 2007/09/13 09:19:56 chl Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.35 2007/09/13 09:19:56 chl Exp $";
d147 2
a148 1
		newtapebuf(NTREC > HIGHDENSITYTREC ? NTREC : HIGHDENSITYTREC);
@


1.35
log
@use strcspn to properly overwrite '\n' in fgets returned buffer
use strtonum instead of atoi

prompted by ray@@
ok moritz@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.34 2007/09/07 16:30:25 chl Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.34 2007/09/07 16:30:25 chl Exp $";
d338 1
a338 2
			if (fgets(buf, sizeof buf, terminal) == NULL ||
			    feof(terminal))
@


1.34
log
@check fgets return value
use sizeof buf instead of TP_BSIZE
use strcspn to properly overwrite '\n' in fgets returned buffer

ok moritz@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.33 2007/09/02 15:19:25 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.33 2007/09/02 15:19:25 deraadt Exp $";
d293 1
d341 6
a346 6
		} while (buf[0] == '\n');
		newvol = atoi(buf);
		if (newvol <= 0) {
			fprintf(stderr,
			    "Volume numbers are positive numerics\n");
		}
@


1.33
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.32 2007/06/03 20:16:08 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.32 2007/06/03 20:16:08 millert Exp $";
d337 4
a340 4
			(void)fgets(buf, TP_BSIZE, terminal);
		} while (!feof(terminal) && buf[0] == '\n');
		if (feof(terminal))
			exit(1);
d356 1
a356 1
	if (fgets(buf, TP_BSIZE, terminal) == NULL || feof(terminal))
d358 1
a358 3
	i = strlen(buf);
	if (i > 0 && buf[--i] == '\n')
		buf[i] = '\0';
@


1.32
log
@Add ffs2 support to dump/restore.  From FreeBSD with some NetBSD changes.
With help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.31 2005/06/14 19:46:05 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.31 2005/06/14 19:46:05 millert Exp $";
d186 1
a186 1
	tapebuf = malloc(size * TP_BSIZE);
@


1.31
log
@Kill whiteout support.  OK deraadt@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.30 2004/12/30 01:51:32 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.30 2004/12/30 01:51:32 millert Exp $";
a88 1
static int	Qcvt;		/* Swap quads (for sun) */
d92 28
d128 1
d229 2
a230 1
		endoftapemark.s_spcl.c_magic = cvtflag ? OFS_MAGIC : NFS_MAGIC;
d242 2
a243 2
	dumptime = spcl.c_ddate;
	dumpdate = spcl.c_date;
d289 1
a289 1
	long newvol = 0, savecnt, wantnext, i;
d396 2
a397 2
		fprintf(stderr, "Wrong dump date\n\tgot: %s",
			ctime(&tmpbuf.c_date));
d411 1
a411 1
	Dprintf(stdout, "read %ld recs, tape starts with %d\n",
d462 1
a462 1
	curfile.dip = NULL;
d497 5
a501 1
	fprintf(stdout, "Dump   date: %s", ctime(&spcl.c_date));
d503 1
a503 1
	    (spcl.c_ddate == 0) ? "the epoch\n" : ctime(&spcl.c_ddate));
d515 2
d518 1
a518 1
	struct timeval timep[2];
d520 1
d524 16
a539 6
	timep[0].tv_sec = curfile.dip->di_atime;
	timep[0].tv_usec = curfile.dip->di_atimensec / 1000;
	timep[1].tv_sec = curfile.dip->di_mtime;
	timep[1].tv_usec = curfile.dip->di_mtimensec / 1000;
	mode = curfile.dip->di_mode;
	flags = curfile.dip->di_flags;
a563 4
			/* Gotta save these, linkit() changes curfile. */
			uid_t luid = curfile.dip->di_uid;
			gid_t lgid = curfile.dip->di_gid;

d575 1
a575 1
			(void)lchown(name, luid, lgid);
d586 1
a586 1
		if (mknod(name, mode, (int)curfile.dip->di_rdev) < 0) {
d591 1
a591 1
		(void)chown(name, curfile.dip->di_uid, curfile.dip->di_gid);
d595 3
a597 1
		utimes(name, timep);
d611 1
a611 1
		(void)chown(name, curfile.dip->di_uid, curfile.dip->di_gid);
d615 3
a617 1
		utimes(name, timep);
d632 1
a632 1
		(void)fchown(ofile, curfile.dip->di_uid, curfile.dip->di_gid);
d637 3
a639 1
		utimes(name, timep);
d681 1
a681 1
	volatile off_t size = spcl.c_dinode.di_size;
d689 1
a689 1
	if (spcl.c_magic != NFS_MAGIC)
d989 1
a989 32
	long i;
	union {
		quad_t	qval;
		int32_t	val[2];
	} qcvt;
	union u_ospcl {
		char dummy[TP_BSIZE];
		struct	s_ospcl {
			int32_t   c_type;
			int32_t   c_date;
			int32_t   c_ddate;
			int32_t   c_volume;
			int32_t   c_tapea;
			u_int16_t c_inumber;
			int32_t   c_magic;
			int32_t   c_checksum;
			struct odinode {
				unsigned short odi_mode;
				u_int16_t odi_nlink;
				u_int16_t odi_uid;
				u_int16_t odi_gid;
				int32_t   odi_size;
				int32_t   odi_rdev;
				char	  odi_addr[36];
				int32_t   odi_atime;
				int32_t   odi_mtime;
				int32_t   odi_ctime;
			} c_dinode;
			int32_t c_count;
			char	c_addr[256];
		} s_ospcl;
	} u_ospcl;
d993 4
a996 2
		if (buf->c_magic != NFS_MAGIC) {
			if (swap32(buf->c_magic) != NFS_MAGIC)
d1009 1
d1011 12
d1031 7
a1037 10
	buf->c_magic = u_ospcl.s_ospcl.c_magic;
	buf->c_dinode.di_mode = u_ospcl.s_ospcl.c_dinode.odi_mode;
	buf->c_dinode.di_nlink = u_ospcl.s_ospcl.c_dinode.odi_nlink;
	buf->c_dinode.di_uid = u_ospcl.s_ospcl.c_dinode.odi_uid;
	buf->c_dinode.di_gid = u_ospcl.s_ospcl.c_dinode.odi_gid;
	buf->c_dinode.di_size = u_ospcl.s_ospcl.c_dinode.odi_size;
	buf->c_dinode.di_rdev = u_ospcl.s_ospcl.c_dinode.odi_rdev;
	buf->c_dinode.di_atime = u_ospcl.s_ospcl.c_dinode.odi_atime;
	buf->c_dinode.di_mtime = u_ospcl.s_ospcl.c_dinode.odi_mtime;
	buf->c_dinode.di_ctime = u_ospcl.s_ospcl.c_dinode.odi_ctime;
d1040 1
a1040 5
	if (u_ospcl.s_ospcl.c_magic != OFS_MAGIC ||
	    checksum((int *)(&u_ospcl.s_ospcl)) == FAIL)
		return(FAIL);
	buf->c_magic = NFS_MAGIC;

a1041 16
	if ((buf->c_dinode.di_size == 0 || buf->c_dinode.di_size > 0xfffffff) &&
	    (buf->c_dinode.di_mode & IFMT) == IFDIR && Qcvt == 0) {
		qcvt.qval = buf->c_dinode.di_size;
		if (qcvt.val[0] || qcvt.val[1]) {
			printf("Note: Doing Quad swapping\n");
			Qcvt = 1;
		}
	}
	if (Qcvt) {
		qcvt.qval = buf->c_dinode.di_size;
		i = qcvt.val[1];
		qcvt.val[1] = qcvt.val[0];
		qcvt.val[0] = i;
		buf->c_dinode.di_size = qcvt.qval;
	}

d1050 1
a1050 1
		buf->c_dinode.di_size = buf->c_count * TP_BSIZE;
d1062 12
d1081 3
d1085 1
a1085 1
	 * If we are restoring a filesystem with old format inodes,
d1089 2
a1090 2
		buf->c_dinode.di_uid = buf->c_dinode.di_ouid;
		buf->c_dinode.di_gid = buf->c_dinode.di_ogid;
d1112 2
a1113 2
 			fprintf(stderr, "begins with record %d",
 				header->c_firstrec);
d1177 1
a1177 1
	curfile.dip = NULL;
d1180 1
a1180 1
		if (header->c_magic != NFS_MAGIC) {
d1201 12
a1212 1
			curfile.dip = &header->c_dinode;
a1254 2
		/* What happens if we want to read restore tapes
			for a 16bit int machine??? */
d1286 2
a1287 2
	s->c_date = swap32(s->c_date);
	s->c_ddate = swap32(s->c_ddate);
d1289 1
a1289 1
	s->c_tapea = swap32(s->c_tapea);
d1294 14
a1307 19
	s->c_dinode.di_mode = swap16(s->c_dinode.di_mode);
	s->c_dinode.di_nlink = swap16(s->c_dinode.di_nlink);
	s->c_dinode.di_ouid = swap16(s->c_dinode.di_ouid);
	s->c_dinode.di_ogid = swap16(s->c_dinode.di_ogid);

	s->c_dinode.di_size = swap64(s->c_dinode.di_size);

	s->c_dinode.di_atime = swap32(s->c_dinode.di_atime);
	s->c_dinode.di_atimensec = swap32(s->c_dinode.di_atimensec);
	s->c_dinode.di_mtime = swap32(s->c_dinode.di_mtime);
	s->c_dinode.di_mtimensec = swap32(s->c_dinode.di_mtimensec);
	s->c_dinode.di_ctime = swap32(s->c_dinode.di_ctime);
	s->c_dinode.di_ctimensec = swap32(s->c_dinode.di_ctimensec);

	s->c_dinode.di_flags = swap32(s->c_dinode.di_flags);
	s->c_dinode.di_blocks = swap32(s->c_dinode.di_blocks);
	s->c_dinode.di_gen = swap32(s->c_dinode.di_gen);
	s->c_dinode.di_uid = swap32(s->c_dinode.di_uid);
	s->c_dinode.di_gid = swap32(s->c_dinode.di_gid);
d1312 38
a1349 1
	s->c_firstrec = swap32(s->c_firstrec);
@


1.30
log
@Replace home-grown byte swapping routine with calls to swap* macros
from endian.h.  Header swapping is moved into its own function.
Fixes problems reading non-native endian dump images on sparc64.
Adapted from changes in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.29 2004/07/17 02:14:33 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.29 2004/07/17 02:14:33 deraadt Exp $";
a247 7
	/*
	 * If there may be whiteout entries on the tape, pretend that the
	 * whiteout inode exists, so that the whiteout entries can be
	 * extracted.
	 */
	if (oldinofmt == 0)
		SETINO(WINO, dumpmap);
@


1.29
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.28 2004/04/13 21:51:18 henning Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.28 2004/04/13 21:51:18 henning Exp $";
d50 1
d100 1
a100 3
static u_long	 swabl(u_long);
static u_char	*swablong(u_char *, int);
static u_char	*swabshort(u_char *, int);
d984 1
a984 1
			if (swabl(buf->c_magic) != NFS_MAGIC)
d994 1
a994 1
			swabst((u_char *)"8l4s31l528b1l192b2l", (u_char *)buf);
d1222 1
a1222 1
	if(!Bcvt) {
d1230 1
a1230 1
			i += swabl(*buf++);
d1256 2
a1257 62
static u_char *
swabshort(u_char *sp, int n)
{
	char c;

	while (--n >= 0) {
		c = sp[0]; sp[0] = sp[1]; sp[1] = c;
		sp += 2;
	}
	return (sp);
}

static u_char *
swablong(u_char *sp, int n)
{
	char c;

	while (--n >= 0) {
		c = sp[0]; sp[0] = sp[3]; sp[3] = c;
		c = sp[2]; sp[2] = sp[1]; sp[1] = c;
		sp += 4;
	}
	return (sp);
}

void
swabst(u_char *cp, u_char *sp)
{
	int n = 0;

	while (*cp) {
		switch (*cp) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = (n * 10) + (*cp++ - '0');
			continue;

		case 's': case 'w': case 'h':
			if (n == 0)
				n = 1;
			sp = swabshort(sp, n);
			break;

		case 'l':
			if (n == 0)
				n = 1;
			sp = swablong(sp, n);
			break;

		default: /* Any other character, like 'b' counts as byte. */
			if (n == 0)
				n = 1;
			sp += n;
			break;
		}
		cp++;
		n = 0;
	}
}

static u_long
swabl(u_long x)
d1259 33
a1291 2
	swabst((u_char *)"l", (u_char *)&x);
	return (x);
@


1.28
log
@fix restore so that it can actually restore files larger than 4GB by
changing the type of "size" to off_t in getfiles() plus little dependent
type cleanup, from Daniel Lucq <daniel@@lucq.org>
ok tdeval@@ millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.27 2003/07/29 18:38:36 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.27 2003/07/29 18:38:36 deraadt Exp $";
d114 1
a114 2
setinput(source)
	char *source;
d150 1
a150 2
newtapebuf(size)
	long size;
d170 1
a170 1
setup()
d266 1
a266 2
getvol(nextvol)
	long nextvol;
d432 1
a432 1
terminateinput()
d454 1
a454 1
setdumpnum()
d474 1
a474 1
printdumpinfo()
d487 1
a487 2
extractfile(name)
	char *name;
d609 1
a609 1
skipmaps()
d620 1
a620 1
skipfile()
d637 1
a637 3
getfile(fill, skip)
	void	(*fill)(char *, size_t);
	void	(*skip)(char *, size_t);
d698 1
a698 3
xtrfile(buf, size)
	char	*buf;
	size_t	size;
d713 1
a713 3
xtrskip(buf, size)
	char *buf;
	size_t size;
d725 1
a725 3
xtrlnkfile(buf, size)
	char	*buf;
	size_t	size;
d740 1
a740 3
xtrlnkskip(buf, size)
	char *buf;
	size_t size;
d750 1
a750 3
xtrmap(buf, size)
	char	*buf;
	size_t	size;
d762 1
a762 3
xtrmapskip(buf, size)
	char *buf;
	size_t size;
d774 1
a774 3
xtrnull(buf, size)
	char *buf;
	size_t size;
d785 1
a785 2
readtape(buf)
	char *buf;
d900 1
a900 1
findtapeblksize()
d927 1
a927 1
closemt()
d947 1
a947 2
gethead(buf)
	struct s_spcl *buf;
d1085 1
a1085 2
accthdr(header)
	struct s_spcl *header;
d1153 1
a1153 2
findinode(header)
	struct s_spcl *header;
d1217 1
a1217 2
checksum(buf)
	int *buf;
d1258 1
a1258 3
swabshort(sp, n)
	u_char *sp;
	int n;
d1270 1
a1270 3
swablong(sp, n)
	u_char *sp;
	int n;
d1283 1
a1283 2
swabst(cp, sp)
	u_char *cp, *sp;
d1318 1
a1318 2
swabl(x)
	u_long x;
@


1.27
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.26 2003/07/28 06:13:26 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: tape.c,v 1.26 2003/07/28 06:13:26 tedu Exp $";
d84 1
a84 1
static int	pathlen;
d103 6
a108 6
static void	 xtrfile(char *, long);
static void	 xtrlnkfile(char *, long);
static void	 xtrlnkskip(char *, long);
static void	 xtrmap(char *, long);
static void	 xtrmapskip(char *, long);
static void	 xtrskip(char *, long);
d642 2
a643 2
	void	(*fill)(char *, long);
	void	(*skip)(char *, long);
d647 1
a647 1
	volatile long size = spcl.c_dinode.di_size;
d666 2
a667 2
				     (long) (fssize) :
				     (curblk - 1) * TP_BSIZE + size);
d673 2
a674 2
				     (long) (curblk * TP_BSIZE) :
				     (curblk - 1) * TP_BSIZE + size);
d678 1
a678 1
				(long) TP_BSIZE : size);
d695 1
a695 1
		(*fill)((char *)buf, (curblk * TP_BSIZE) + size);
d706 1
a706 1
	long	size;
d711 1
a711 1
	if (write(ofile, buf, (int) size) == -1)
d723 1
a723 1
	long size;
d726 1
a726 1
	if (lseek(ofile, size, SEEK_CUR) == -1)
d737 1
a737 1
	long	size;
d742 2
a743 2
		errx(1, "symbolic link name: %s->%s%s; too long %d",
		    curfile.name, lnkbuf, buf, pathlen);
d754 1
a754 1
	long size;
d766 1
a766 1
	long	size;
d780 1
a780 1
	long size;
d794 1
a794 1
	long size;
@


1.26
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.25 2003/06/19 03:49:44 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD$";
d1259 1
a1259 1
			
d1323 1
a1323 1
		
@


1.25
log
@Strip the newline from the buffer when reading the tape name during
tape change.  Closes PR 3324; OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.24 2003/06/02 20:06:16 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$NetBSD: tape.c,v 1.22 1996/11/30 18:31:29 cgd Exp $";
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.23 2003/04/06 13:29:41 avsm Exp $	*/
d338 1
a338 2
	(void)fgets(buf, TP_BSIZE, terminal);
	if (feof(terminal))
d340 4
a343 1
	if (!strcmp(buf, "none\n")) {
d347 1
a347 1
	if (buf[0] != '\n')
@


1.23
log
@strcat->strlcat, ho@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.22 2003/03/13 05:00:44 deraadt Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.22
log
@more strlcpy; most from Hans-Joerg.Hoexer@@yerbouti.franken.de, a bit from me
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.21 2002/02/19 19:39:38 millert Exp $	*/
d746 1
a746 1
	(void)strcat(lnkbuf, buf);
@


1.21
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.20 2002/02/16 21:27:37 millert Exp $	*/
d151 1
a151 1
	(void)strcpy(magtape, source);
d312 1
a312 1
			strcpy(buf, ": ");
d316 1
a316 1
					strcpy(buf, ", ");
d349 3
a351 4
	if (buf[0] != '\n') {
		(void)strcpy(magtape, buf);
		magtape[strlen(magtape) - 1] = '\0';
	}
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.19 2001/11/05 07:39:17 mpech Exp $	*/
a1271 1
#ifdef __STDC__
a1272 3
#else
#include <varargs.h>
#endif
a1274 1
#ifdef __STDC__
a1275 5
#else
msg(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
d1278 1
a1278 1
#ifdef __STDC__
a1279 3
#else
	va_start(ap);
#endif
@


1.19
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.18 2001/07/07 18:26:20 deraadt Exp $	*/
d96 17
a112 17
static void	 accthdr __P((struct s_spcl *));
static int	 checksum __P((int *));
static void	 findinode __P((struct s_spcl *));
static void	 findtapeblksize __P((void));
static int	 gethead __P((struct s_spcl *));
static void	 readtape __P((char *));
static void	 setdumpnum __P((void));
static u_long	 swabl __P((u_long));
static u_char	*swablong __P((u_char *, int));
static u_char	*swabshort __P((u_char *, int));
static void	 terminateinput __P((void));
static void	 xtrfile __P((char *, long));
static void	 xtrlnkfile __P((char *, long));
static void	 xtrlnkskip __P((char *, long));
static void	 xtrmap __P((char *, long));
static void	 xtrmapskip __P((char *, long));
static void	 xtrskip __P((char *, long));
d645 2
a646 2
	void	(*fill) __P((char *, long));
	void	(*skip) __P((char *, long));
@


1.18
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.17 2001/01/09 03:26:06 angelos Exp $	*/
d648 1
a648 1
	register int i;
d926 1
a926 1
	register long i;
d1245 1
a1245 1
	register int *buf;
d1247 1
a1247 1
	register int i, j;
d1300 2
a1301 2
	register u_char *sp;
	register int n;
d1314 2
a1315 2
	register u_char *sp;
	register int n;
d1329 1
a1329 1
	register u_char *cp, *sp;
@


1.17
log
@Don't skip if TS_BITS or TS_CLRI, closed PR 1576. Fix supplied by
sysadmin@@astro.su.se
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.16 2000/09/14 22:38:19 deraadt Exp $	*/
d158 1
a158 1
	static tapebufsize = -1;
d275 1
a275 1
	long newvol, savecnt, wantnext, i;
d654 1
a654 1
	int noskip = (spcl.c_type == TS_BITS || spcl.c_type == TS_CLRI);
@


1.16
log
@wrong type to ioctl; naddy@@mips.inka.de
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.15 2000/06/16 16:43:18 deraadt Exp $	*/
d639 3
d654 1
d665 1
a665 1
		if (spcl.c_addr[i]) {
d685 1
a685 1
				if (spcl.c_addr[i])
a1074 2
		for (i = 0; i < buf->c_count; i++)
			buf->c_addr[i]++;
d1153 11
a1163 1
	if (header->c_type != TS_END)
d1167 1
@


1.15
log
@use TP_BSIZE (== BUFSIZ so no problem)
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.14 1999/08/17 09:13:15 millert Exp $	*/
d475 1
a475 1
		if (ioctl(mt, (int)MTIOCTOP, (char *)&tcom) < 0)
@


1.14
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.13 1998/02/17 00:07:52 millert Exp $	*/
d323 1
a323 1
			(void)fgets(buf, BUFSIZ, terminal);
d342 1
a342 1
	(void)fgets(buf, BUFSIZ, terminal);
@


1.13
log
@chflags(2) take a u_int
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.12 1998/02/10 20:20:03 deraadt Exp $	*/
a50 1
#include <sys/file.h>
d59 1
d190 1
a190 1
		mt = open(magtape, O_RDONLY, 0);
d358 1
a358 1
		mt = open(magtape, O_RDONLY, 0);
@


1.12
log
@allow tape blocksize > disk blocksize to work; dwmalone@@maths.tcd.ie
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.11 1997/08/24 08:07:23 downsj Exp $	*/
d496 1
a496 1
	int flags;
@


1.11
log
@More err()/warn()/etc. argument fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.10 1997/07/25 19:13:13 mickey Exp $	*/
d224 2
@


1.10
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.9 1997/07/05 20:51:26 millert Exp $	*/
d192 1
a192 1
		err(1, magtape);
@


1.9
log
@vprintf -> Vprintf and dprintf -> Dprintf to avoid confusion
Use err/errx and warn/warnx where it makes sense.
Some sprintf -> snprintf, strcpy -> strncpy, and strcat -> strncat.
Honor $TMPDIR (based on changes from NetBSD)
Use __progname not "restore" (we could be called as rrestore).
Some -Wall happiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.8 1997/04/16 04:07:40 millert Exp $	*/
d1257 1
a1257 1
#if __STDC__
d1264 1
a1264 1
#if __STDC__
d1273 1
a1273 1
#if __STDC__
@


1.8
log
@No need for "pathnames.h" now that _PATH_DEFTAPE is in <paths.h>
Fix rmt -> rst in man page and change ".Nm restore" -> ".Nm"
@
text
@d1 2
a2 2
/*	$OpenBSD: tape.c,v 1.7 1997/01/27 09:33:08 downsj Exp $	*/
/*	$NetBSD: tape.c,v 1.22 1996/11/30 18:31:29 cgd Exp $	*/
d59 1
a59 1
#include <errno.h>
d144 1
a144 2
			(void)fprintf(stderr, "cannot open %s: %s\n",
			    _PATH_TTY, strerror(errno));
d146 2
a147 5
			if (terminal == NULL) {
				(void)fprintf(stderr, "cannot open %s: %s\n",
				    _PATH_DEVNULL, strerror(errno));
				exit(1);
			}
d151 1
a151 1
	(void) strcpy(magtape, source);
d166 2
a167 4
	if (tapebuf == NULL) {
		fprintf(stderr, "Cannot allocate space for tape buffer\n");
		exit(1);
	}
d181 1
a181 1
	vprintf(stdout, "Verify tape and initialize maps\n");
d191 2
a192 4
	if (mt < 0) {
		fprintf(stderr, "%s: %s\n", magtape, strerror(errno));
		exit(1);
	}
d203 3
a205 5
		if (gethead(&spcl) == FAIL) {
			fprintf(stderr, "Tape is not a dump tape\n");
			exit(1);
		}
		fprintf(stderr, "Converting to new file system format.\n");
d222 2
a223 4
	if (stat(".", &stbuf) < 0) {
		fprintf(stderr, "cannot stat .: %s\n", strerror(errno));
		exit(1);
	}
d226 4
a229 8
	if (((fssize - 1) & fssize) != 0) {
		fprintf(stderr, "bad block size %d\n", fssize);
		exit(1);
	}
	if (spcl.c_volume != 1) {
		fprintf(stderr, "Tape is not volume 1 of the dump\n");
		exit(1);
	}
d231 1
a231 1
		dprintf(stdout, "header read failed at %d blocks\n", blksread);
d235 2
a236 4
	if (spcl.c_type != TS_CLRI) {
		fprintf(stderr, "Cannot find file removal list\n");
		exit(1);
	}
d238 1
a238 1
	dprintf(stdout, "maxino = %d\n", maxino);
d245 4
a248 6
	if (spcl.c_type != TS_BITS) {
		fprintf(stderr, "Cannot find file dump list\n");
		exit(1);
	}
	map = calloc((unsigned)1, (unsigned)howmany(maxino, NBBY));
	if (map == (char *)NULL)
d296 1
a296 1
	} else { 
d313 1
a313 1
					fprintf(stderr, "%s%d", buf, i);
d320 2
a321 2
			(void) fflush(stderr);
			(void) fgets(buf, BUFSIZ, terminal);
d336 1
a336 1
	fprintf(stderr, "Mount tape volume %d\n", newvol);
d339 2
a340 2
	(void) fflush(stderr);
	(void) fgets(buf, BUFSIZ, terminal);
d348 1
a348 1
		(void) strcpy(magtape, buf);
d368 1
a368 1
		dprintf(stdout, "header read failed at %d blocks\n", blksread);
d394 1
a394 1
	dprintf(stdout, "read %ld recs, tape starts with %ld\n", 
d407 2
a408 2
			dprintf(stderr, "Skipping %d duplicate record%s.\n",
				i, i > 1 ? "s" : "");
d424 1
a424 1
	(void) gethead(&spcl);
d464 2
a465 4
	if (pipein) {
		fprintf(stderr, "Cannot have multiple dumps on pipe input\n");
		exit(1);
	}
d471 1
a471 1
	else 
d474 1
a474 1
			fprintf(stderr, "ioctl MTFSF: %s\n", strerror(errno));
d515 1
a515 1
		vprintf(stdout, "skipped socket %s\n", name);
d527 1
a527 1
		vprintf(stdout, "extract file %s\n", name);
d539 1
a539 1
				vprintf(stdout,
d546 1
a546 1
			(void) lchown(name, luid, lgid);
d552 1
a552 1
		vprintf(stdout, "extract special file %s\n", name);
d558 1
a558 2
			fprintf(stderr, "%s: cannot create special file: %s\n",
			    name, strerror(errno));
d562 3
a564 3
		(void) chown(name, curfile.dip->di_uid, curfile.dip->di_gid);
		(void) chmod(name, mode);
		(void) chflags(name, flags);
d570 1
a570 1
		vprintf(stdout, "extract fifo %s\n", name);
d576 1
a576 2
			fprintf(stderr, "%s: cannot create fifo: %s\n",
			    name, strerror(errno));
d580 3
a582 3
		(void) chown(name, curfile.dip->di_uid, curfile.dip->di_gid);
		(void) chmod(name, mode);
		(void) chflags(name, flags);
d588 1
a588 1
		vprintf(stdout, "extract file %s\n", name);
d595 1
a595 2
			fprintf(stderr, "%s: cannot create file: %s\n",
			    name, strerror(errno));
d599 3
a601 3
		(void) fchown(ofile, curfile.dip->di_uid, curfile.dip->di_gid);
		(void) fchmod(ofile, mode);
		(void) fchflags(ofile, flags);
d603 1
a603 1
		(void) close(ofile);
d644 2
a645 2
	int curblk = 0;
	long size = spcl.c_dinode.di_size;
d687 2
a688 2
		dprintf(stdout,
			"Missing address (header) block for %s at %d blocks\n",
d708 3
a710 6
	if (write(ofile, buf, (int) size) == -1) {
		fprintf(stderr,
		    "write error extracting inode %d, name %s\nwrite: %s\n",
			curfile.ino, curfile.name, strerror(errno));
		exit(1);
	}
d723 3
a725 6
	if (lseek(ofile, size, SEEK_CUR) == -1) {
		fprintf(stderr,
		    "seek error extracting inode %d, name %s\nlseek: %s\n",
			curfile.ino, curfile.name, strerror(errno));
		exit(1);
	}
d738 2
a739 2
	if (pathlen > MAXPATHLEN) {
		fprintf(stderr, "symbolic link name: %s->%s%s; too long %d\n",
d741 1
a741 3
		exit(1);
	}
	(void) strcat(lnkbuf, buf);
d754 1
a754 3
	fprintf(stderr, "unallocated block in symbolic link %s\n",
		curfile.name);
	exit(1);
d832 1
a832 1
		dprintf(stdout, "mid-media short read error.\n");
d852 2
a853 2
				vprintf(stdout,
				    "partial block read: %d should be %d\n",
d889 2
a890 5
		if (seek_failed) {
			fprintf(stderr,
			    "continuation failed: %s\n", strerror(errno));
			exit(1);
		}
d896 1
a896 1
		vprintf(stdout, "End-of-tape encountered\n");
d932 2
a933 4
	if (i <= 0) {
		fprintf(stderr, "tape read error: %s\n", strerror(errno));
		exit(1);
	}
d935 3
a937 3
		fprintf(stderr, "Tape block size (%d) %s (%d)\n",
			i, "is not a multiple of dump block size", TP_BSIZE);
		exit(1);
d941 1
a941 1
	vprintf(stdout, "Tape block size is %d\n", ntrec);
d955 1
a955 1
		(void) close(mt);
d991 1
a991 1
				char	odi_addr[36];
d1007 1
a1007 1
				vprintf(stdout, "Note: Doing Byte swapping\n");
d1090 1
a1090 1
	 * If we are restoring a filesystem with old format inodes, 
d1144 1
a1144 1
		fprintf(stderr, "; predicted %d blocks, got %d blocks",
d1224 1
a1224 1
		fprintf(stderr, "resync restore, skipped %d blocks\n", skipcnt);
d1243 1
a1243 1
		do 
@


1.7
log
@Support lchown(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.6 1996/12/27 09:48:07 deraadt Exp $	*/
d60 1
a68 1
#include "pathnames.h"
@


1.6
log
@epilepsy in csrg?
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.5 1996/12/11 19:23:40 deraadt Exp $	*/
d552 17
a568 7
	case IFLNK:
		lnkbuf[0] = '\0';
		pathlen = 0;
		getfile(xtrlnkfile, xtrlnkskip);
		if (pathlen == 0) {
			vprintf(stdout,
			    "%s: zero length symbolic link (ignored)\n", name);
a570 1
		return (linkit(lnkbuf, name, SYMLINK));
@


1.5
log
@from netbsd; repair byte swapping of fields
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.4 1996/12/04 01:41:54 deraadt Exp $	*/
d327 1
a327 1
			    " towards towards the first.\n");
@


1.4
log
@64 bit patches, tih@@nhh.no
@
text
@d1 1
a1 1
/*	$OpenBSD: tape.c,v 1.3 1996/09/01 15:27:29 deraadt Exp $	*/
d1045 1
a1045 1
			swabst((u_char *)"8l4s31l", (u_char *)buf);
@


1.3
log
@lose setuid
@
text
@d1 2
a2 2
/*	$OpenBSD: tape.c,v 1.2 1996/03/21 00:16:32 niklas Exp $	*/
/*	$NetBSD: tape.c,v 1.20 1996/03/15 22:39:41 scottr Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: tape.c,v 1.20 1996/03/15 22:39:41 scottr Exp $";
d236 1
a236 1
	if (stbuf.st_blksize > 0 && stbuf.st_blksize <= MAXBSIZE)
d1002 1
a1002 1
		long	val[2];
d1007 8
a1014 8
			long	c_type;
			long	c_date;
			long	c_ddate;
			long	c_volume;
			long	c_tapea;
			u_short	c_inumber;
			long	c_magic;
			long	c_checksum;
d1017 5
a1021 5
				u_short	odi_nlink;
				u_short	odi_uid;
				u_short	odi_gid;
				long	odi_size;
				long	odi_rdev;
d1023 3
a1025 3
				long	odi_atime;
				long	odi_mtime;
				long	odi_ctime;
d1027 1
a1027 1
			long	c_count;
@


1.2
log
@From NetBSD: Merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a93 3
extern	uid_t uid;		/* real uid */
extern	uid_t euid;		/* effective uid */

a154 1
	(void) setuid(uid); /* rmthost() is the only reason to be setuid */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tape.c,v 1.19 1995/06/19 00:20:32 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: tape.c,v 1.19 1995/06/19 00:20:32 cgd Exp $";
d94 3
d158 1
a158 1
	setuid(getuid());	/* no longer need or want root privileges */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
