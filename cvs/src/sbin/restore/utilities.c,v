head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.10
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.8
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.20
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.16
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.14
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.12
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.11.07.21.52.55;	author guenther;	state Exp;
branches;
next	1.18;
commitid	hOR3NbUo3KcZnEBD;

1.18
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.14.19.46.05;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.13.05.00.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.29.19.23.34;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.23.21.18.11;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.05.22.32.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.24.08.07.25;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.19.13.12;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.05.20.51.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Use linkat() instead of link() so that hardlinks of symlinks work

ok millert@@
@
text
@/*	$OpenBSD: utilities.c,v 1.18 2015/01/16 06:40:00 deraadt Exp $	*/
/*	$NetBSD: utilities.c,v 1.11 1997/03/19 08:42:56 lukem Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>

#include <err.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "restore.h"
#include "extern.h"

/*
 * Insure that all the components of a pathname exist.
 */
void
pathcheck(char *name)
{
	char *cp;
	struct entry *ep;
	char *start;

	start = strchr(name, '/');
	if (start == 0)
		return;
	for (cp = start; *cp != '\0'; cp++) {
		if (*cp != '/')
			continue;
		*cp = '\0';
		ep = lookupname(name);
		if (ep == NULL) {
			/* Safe; we know the pathname exists in the dump. */
			ep = addentry(name, pathsearch(name)->d_ino, NODE);
			newnode(ep);
		}
		ep->e_flags |= NEW|KEEP;
		*cp = '/';
	}
}

/*
 * Change a name to a unique temporary name.
 */
void
mktempname(struct entry *ep)
{
	char oldname[PATH_MAX];

	if (ep->e_flags & TMPNAME)
		badentry(ep, "mktempname: called with TMPNAME");
	ep->e_flags |= TMPNAME;
	(void)strlcpy(oldname, myname(ep), sizeof oldname);
	freename(ep->e_name);
	ep->e_name = savename(gentempname(ep));
	ep->e_namlen = strlen(ep->e_name);
	renameit(oldname, myname(ep));
}

/*
 * Generate a temporary name for an entry.
 */
char *
gentempname(struct entry *ep)
{
	static char name[PATH_MAX];
	struct entry *np;
	long i = 0;

	for (np = lookupino(ep->e_ino);
	    np != NULL && np != ep; np = np->e_links)
		i++;
	if (np == NULL)
		badentry(ep, "not on ino list");
	(void)snprintf(name, sizeof(name), "%s%ld%llu", TMPHDR, i,
	    (unsigned long long)ep->e_ino);
	return (name);
}

/*
 * Rename a file or directory.
 */
void
renameit(char *from, char *to)
{
	if (!Nflag && rename(from, to) < 0) {
		warn("cannot rename %s to %s", from, to);
		return;
	}
	Vprintf(stdout, "rename %s to %s\n", from, to);
}

/*
 * Create a new node (directory).
 */
void
newnode(struct entry *np)
{
	char *cp;

	if (np->e_type != NODE)
		badentry(np, "newnode: not a node");
	cp = myname(np);
	if (!Nflag && mkdir(cp, 0777) < 0) {
		np->e_flags |= EXISTED;
		warn("%s", cp);
		return;
	}
	Vprintf(stdout, "Make node %s\n", cp);
}

/*
 * Remove an old node (directory).
 */
void
removenode(struct entry *ep)
{
	char *cp;

	if (ep->e_type != NODE)
		badentry(ep, "removenode: not a node");
	if (ep->e_entries != NULL)
		badentry(ep, "removenode: non-empty directory");
	ep->e_flags |= REMOVED;
	ep->e_flags &= ~TMPNAME;
	cp = myname(ep);
	if (!Nflag && rmdir(cp) < 0) {
		warn("%s", cp);
		return;
	}
	Vprintf(stdout, "Remove node %s\n", cp);
}

/*
 * Remove a leaf.
 */
void
removeleaf(struct entry *ep)
{
	char *cp;

	if (ep->e_type != LEAF)
		badentry(ep, "removeleaf: not a leaf");
	ep->e_flags |= REMOVED;
	ep->e_flags &= ~TMPNAME;
	cp = myname(ep);
	if (!Nflag && unlink(cp) < 0) {
		warn("%s", cp);
		return;
	}
	Vprintf(stdout, "Remove leaf %s\n", cp);
}

/*
 * Create a link.
 */
int
linkit(char *existing, char *new, int type)
{

	if (type == SYMLINK) {
		if (!Nflag && symlink(existing, new) < 0) {
			warn("cannot create symbolic link %s->%s",
			    new, existing);
			return (FAIL);
		}
	} else if (type == HARDLINK) {
		if (!Nflag && linkat(AT_FDCWD, existing, AT_FDCWD, new, 0)
		    < 0) {
			warn("cannot create hard link %s->%s",
			    new, existing);
			return (FAIL);
		}
	} else {
		panic("linkit: unknown type %d\n", type);
		return (FAIL);
	}
	Vprintf(stdout, "Create %s link %s->%s\n",
		type == SYMLINK ? "symbolic" : "hard", new, existing);
	return (GOOD);
}

/*
 * find lowest number file (above "start") that needs to be extracted
 */
ino_t
lowerbnd(ino_t start)
{
	struct entry *ep;

	for ( ; start < maxino; start++) {
		ep = lookupino(start);
		if (ep == NULL || ep->e_type == NODE)
			continue;
		if (ep->e_flags & (NEW|EXTRACT))
			return (start);
	}
	return (start);
}

/*
 * find highest number file (below "start") that needs to be extracted
 */
ino_t
upperbnd(ino_t start)
{
	struct entry *ep;

	for ( ; start > ROOTINO; start--) {
		ep = lookupino(start);
		if (ep == NULL || ep->e_type == NODE)
			continue;
		if (ep->e_flags & (NEW|EXTRACT))
			return (start);
	}
	return (start);
}

/*
 * report on a badly formed entry
 */
void
badentry(struct entry *ep, char *msg)
{

	fprintf(stderr, "bad entry: %s\n", msg);
	fprintf(stderr, "name: %s\n", myname(ep));
	fprintf(stderr, "parent name %s\n", myname(ep->e_parent));
	if (ep->e_sibling != NULL)
		fprintf(stderr, "sibling name: %s\n", myname(ep->e_sibling));
	if (ep->e_entries != NULL)
		fprintf(stderr, "next entry name: %s\n", myname(ep->e_entries));
	if (ep->e_links != NULL)
		fprintf(stderr, "next link name: %s\n", myname(ep->e_links));
	if (ep->e_next != NULL)
		fprintf(stderr,
		    "next hashchain name: %s\n", myname(ep->e_next));
	fprintf(stderr, "entry type: %s\n",
		ep->e_type == NODE ? "NODE" : "LEAF");
	fprintf(stderr, "inode number: %llu\n",
	    (unsigned long long)ep->e_ino);
	panic("flags: %s\n", flagvalues(ep));
}

/*
 * Construct a string indicating the active flag bits of an entry.
 */
char *
flagvalues(struct entry *ep)
{
	static char flagbuf[BUFSIZ];

	(void)strlcpy(flagbuf, "|NIL", sizeof flagbuf);
	flagbuf[0] = '\0';
	if (ep->e_flags & REMOVED)
		(void)strlcat(flagbuf, "|REMOVED", sizeof flagbuf);
	if (ep->e_flags & TMPNAME)
		(void)strlcat(flagbuf, "|TMPNAME", sizeof flagbuf);
	if (ep->e_flags & EXTRACT)
		(void)strlcat(flagbuf, "|EXTRACT", sizeof flagbuf);
	if (ep->e_flags & NEW)
		(void)strlcat(flagbuf, "|NEW", sizeof flagbuf);
	if (ep->e_flags & KEEP)
		(void)strlcat(flagbuf, "|KEEP", sizeof flagbuf);
	if (ep->e_flags & EXISTED)
		(void)strlcat(flagbuf, "|EXISTED", sizeof flagbuf);
	return (&flagbuf[1]);
}

/*
 * Check to see if a name is on a dump tape.
 */
ino_t
dirlookup(const char *name)
{
	struct direct *dp;
	ino_t ino;

	ino = ((dp = pathsearch(name)) == NULL) ? 0 : dp->d_ino;

	if (ino == 0 || TSTINO(ino, dumpmap) == 0)
		fprintf(stderr, "%s is not on the tape\n", name);
	return (ino);
}

/*
 * Elicit a reply.
 */
int
reply(char *question)
{
	int c;

	do	{
		fprintf(stderr, "%s? [yn] ", question);
		(void)fflush(stderr);
		c = getc(terminal);
		while (c != '\n' && getc(terminal) != '\n')
			if (feof(terminal))
				return (FAIL);
	} while (c != 'y' && c != 'n');
	if (c == 'y')
		return (GOOD);
	return (FAIL);
}

/*
 * handle unexpected inconsistencies
 */
void
panic(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);

	vfprintf(stderr, fmt, ap);
	va_end(ap);
	if (yflag)
		return;
	if (reply("abort") == GOOD) {
		if (reply("dump core") == GOOD)
			abort();
		exit(1);
	}
}
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.17 2013/04/24 13:46:29 deraadt Exp $	*/
d39 1
d204 2
a205 1
		if (!Nflag && link(existing, new) < 0) {
@


1.17
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.16 2009/10/27 23:59:34 deraadt Exp $	*/
a32 1
#include <sys/param.h>
d44 1
d83 1
a83 1
	char oldname[MAXPATHLEN];
d101 1
a101 1
	static char name[MAXPATHLEN];
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.15 2005/06/14 19:46:05 millert Exp $	*/
d110 2
a111 1
	(void)snprintf(name, sizeof(name), "%s%ld%d", TMPHDR, i, ep->e_ino);
d274 2
a275 1
	fprintf(stderr, "inode number: %d\n", ep->e_ino);
@


1.15
log
@Kill whiteout support.  OK deraadt@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.14 2004/07/17 02:14:33 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)utilities.c	8.4 (Berkeley) 10/18/94";
#else
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.14 2004/07/17 02:14:33 deraadt Exp $";
#endif
#endif /* not lint */
@


1.14
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.13 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.13 2003/07/28 06:13:26 tedu Exp $";
a221 35
}

/*
 * Create a whiteout.
 */
int
addwhiteout(char *name)
{

	if (!Nflag && mknod(name, S_IFWHT, 0) < 0) {
		warn("cannot create whiteout %s", name);
		return (FAIL);
	}
	Vprintf(stdout, "Create whiteout %s\n", name);
	return (GOOD);
}

/*
 * Delete a whiteout.
 */
void
delwhiteout(struct entry *ep)
{
	char *name;

	if (ep->e_type != LEAF)
		badentry(ep, "delwhiteout: not a leaf");
	ep->e_flags |= REMOVED;
	ep->e_flags &= ~TMPNAME;
	name = myname(ep);
	if (!Nflag && undelete(name) < 0) {
		warn("cannot delete whiteout %s", name);
		return;
	}
	Vprintf(stdout, "Delete whiteout %s\n", name);
@


1.13
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.12 2003/06/02 20:06:16 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: utilities.c,v 1.12 2003/06/02 20:06:16 millert Exp $";
d61 1
a61 2
pathcheck(name)
	char *name;
d89 1
a89 2
mktempname(ep)
	struct entry *ep;
d107 1
a107 2
gentempname(ep)
	struct entry *ep;
d126 1
a126 2
renameit(from, to)
	char *from, *to;
d139 1
a139 2
newnode(np)
	struct entry *np;
d158 1
a158 2
removenode(ep)
	struct entry *ep;
d180 1
a180 2
removeleaf(ep)
	struct entry *ep;
d200 1
a200 3
linkit(existing, new, type)
	char *existing, *new;
	int type;
d228 1
a228 2
addwhiteout(name)
	char *name;
d243 1
a243 2
delwhiteout(ep)
	struct entry *ep;
d263 1
a263 2
lowerbnd(start)
	ino_t start;
d281 1
a281 2
upperbnd(start)
	ino_t start;
d299 1
a299 3
badentry(ep, msg)
	struct entry *ep;
	char *msg;
d324 1
a324 2
flagvalues(ep)
	struct entry *ep;
d349 1
a349 2
dirlookup(name)
	const char *name;
d365 1
a365 2
reply(question)
	char *question;
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.11 2003/03/13 05:00:44 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.11 2003/03/13 05:00:44 deraadt Exp $";
@


1.11
log
@more strlcpy; most from Hans-Joerg.Hoexer@@yerbouti.franken.de, a bit from me
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.10 2002/05/29 19:23:34 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.10 2002/05/29 19:23:34 deraadt Exp $";
@


1.10
log
@more strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.9 2002/02/23 21:18:11 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.9 2002/02/23 21:18:11 deraadt Exp $";
d102 1
a102 1
	(void)strcpy(oldname, myname(ep));
d348 1
a348 1
	(void)strcpy(flagbuf, "|NIL");
@


1.9
log
@getc() returns an int
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.8 2002/02/19 19:39:38 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.8 2002/02/19 19:39:38 millert Exp $";
d351 1
a351 1
		(void)strcat(flagbuf, "|REMOVED");
d353 1
a353 1
		(void)strcat(flagbuf, "|TMPNAME");
d355 1
a355 1
		(void)strcat(flagbuf, "|EXTRACT");
d357 1
a357 1
		(void)strcat(flagbuf, "|NEW");
d359 1
a359 1
		(void)strcat(flagbuf, "|KEEP");
d361 1
a361 1
		(void)strcat(flagbuf, "|EXISTED");
@


1.8
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.7 2001/11/05 07:39:17 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.7 2001/11/05 07:39:17 mpech Exp $";
d389 1
a389 1
	char c;
@


1.7
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.6 2001/09/05 22:32:37 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.6 2001/09/05 22:32:37 deraadt Exp $";
d52 1
a406 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a407 1
#ifdef __STDC__
a408 5
#else
panic(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a410 1
#ifdef __STDC__
a411 3
#else
	va_start(ap);
#endif
@


1.6
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.5 1997/08/24 08:07:25 downsj Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.5 1997/08/24 08:07:25 downsj Exp $";
d67 1
a67 1
	register char *cp;
d94 1
a94 1
	register struct entry *ep;
d167 1
a167 1
	register struct entry *ep;
d190 1
a190 1
	register struct entry *ep;
d257 1
a257 1
	register struct entry *ep;
d280 1
a280 1
	register struct entry *ep;
d299 1
a299 1
	register struct entry *ep;
d316 1
a316 1
	register struct entry *ep;
d343 1
a343 1
	register struct entry *ep;
@


1.5
log
@More err()/warn()/etc. argument fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.4 1997/07/25 19:13:12 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.4 1997/07/25 19:13:12 mickey Exp $";
d429 1
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.3 1997/07/05 20:51:27 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.3 1997/07/05 20:51:27 millert Exp $";
d156 1
a156 1
		warn(cp);
d179 1
a179 1
		warn(cp);
d200 1
a200 1
		warn(cp);
@


1.3
log
@vprintf -> Vprintf and dprintf -> Dprintf to avoid confusion
Use err/errx and warn/warnx where it makes sense.
Some sprintf -> snprintf, strcpy -> strncpy, and strcat -> strncat.
Honor $TMPDIR (based on changes from NetBSD)
Use __progname not "restore" (we could be called as rrestore).
Some -Wall happiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: utilities.c,v 1.2 1996/06/23 14:32:19 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.2 1996/06/23 14:32:19 deraadt Exp $";
d406 1
a406 1
#if __STDC__
d413 1
a413 1
#if __STDC__
d422 1
a422 1
#if __STDC__
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: utilities.c,v 1.9 1995/03/18 14:59:59 cgd Exp $	*/
/*	$NetBSD: utilities.c,v 1.9 1995/03/18 14:59:59 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: utilities.c,v 1.9 1995/03/18 14:59:59 cgd Exp $";
d51 1
a51 1
#include <errno.h>
d101 1
a101 1
	(void) strcpy(oldname, myname(ep));
d124 1
a124 1
	(void) sprintf(name, "%s%d%d", TMPHDR, i, ep->e_ino);
d136 1
a136 2
		fprintf(stderr, "warning: cannot rename %s to %s: %s\n",
		    from, to, strerror(errno));
d139 1
a139 1
	vprintf(stdout, "rename %s to %s\n", from, to);
d156 1
a156 1
		fprintf(stderr, "warning: %s: %s\n", cp, strerror(errno));
d159 1
a159 1
	vprintf(stdout, "Make node %s\n", cp);
d179 1
a179 1
		fprintf(stderr, "warning: %s: %s\n", cp, strerror(errno));
d182 1
a182 1
	vprintf(stdout, "Remove node %s\n", cp);
d200 1
a200 1
		fprintf(stderr, "warning: %s: %s\n", cp, strerror(errno));
d203 1
a203 1
	vprintf(stdout, "Remove leaf %s\n", cp);
d217 2
a218 3
			fprintf(stderr,
			    "warning: cannot create symbolic link %s->%s: %s\n",
			    new, existing, strerror(errno));
d223 2
a224 3
			fprintf(stderr,
			    "warning: cannot create hard link %s->%s: %s\n",
			    new, existing, strerror(errno));
d231 1
a231 1
	vprintf(stdout, "Create %s link %s->%s\n",
d245 1
a245 2
		fprintf(stderr, "warning: cannot create whiteout %s: %s\n",
		    name, strerror(errno));
d248 1
a248 1
	vprintf(stdout, "Create whiteout %s\n", name);
d267 1
a267 2
		fprintf(stderr, "warning: cannot delete whiteout %s: %s\n",
		    name, strerror(errno));
d270 1
a270 1
	vprintf(stdout, "Delete whiteout %s\n", name);
d334 1
a334 1
	fprintf(stderr, "inode number: %ld\n", ep->e_ino);
d347 1
a347 1
	(void) strcpy(flagbuf, "|NIL");
d350 1
a350 1
		(void) strcat(flagbuf, "|REMOVED");
d352 1
a352 1
		(void) strcat(flagbuf, "|TMPNAME");
d354 1
a354 1
		(void) strcat(flagbuf, "|EXTRACT");
d356 1
a356 1
		(void) strcat(flagbuf, "|NEW");
d358 1
a358 1
		(void) strcat(flagbuf, "|KEEP");
d360 1
a360 1
		(void) strcat(flagbuf, "|EXISTED");
d373 1
a373 1
 
d392 1
a392 1
		(void) fflush(stderr);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: utilities.c,v 1.9 1995/03/18 14:59:59 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
