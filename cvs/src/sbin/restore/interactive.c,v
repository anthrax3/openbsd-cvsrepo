head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.14
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.12
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.8
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.8
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.23.0.10
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.8
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.6
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	F55lwc3gS4GN2mLs;

1.29
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2013.04.25.06.43.20;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.27.23.40.57;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.25.09.51.48;	author chl;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.02.15.19.25;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.16.14.51.21;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.14.19.46.05;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.28.16.15.46;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.10.00.00.58;	author david;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.26.02.57.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.04.22.12.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.07.18.26.19;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.19.17.57.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.10.03.08.05;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.02.17.00.17.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.09.18.18.48.11;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.06.23.22.40.31;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.01.31.23.08.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.06.01.45.26;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.05.20.51.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.16.17.11.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@/*	$OpenBSD: interactive.c,v 1.29 2015/01/16 06:40:00 deraadt Exp $	*/
/*	$NetBSD: interactive.c,v 1.10 1997/03/19 08:42:52 lukem Exp $	*/

/*
 * Copyright (c) 1985, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/stat.h>

#include <ufs/ffs/fs.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <protocols/dumprestore.h>

#include <setjmp.h>
#include <glob.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "restore.h"
#include "extern.h"

#define round(a, b) (((a) + (b) - 1) / (b) * (b))

/*
 * Things to handle interruptions.
 */
static int runshell;
static jmp_buf reset;
static char *nextarg = NULL;

/*
 * Structure and routines associated with listing directories.
 */
struct afile {
	ino_t	fnum;		/* inode number of file */
	char	*fname;		/* file name */
	short	len;		/* name length */
	char	prefix;		/* prefix character */
	char	postfix;	/* postfix character */
};
struct arglist {
	int	freeglob;	/* glob structure needs to be freed */
	int	argcnt;		/* next globbed argument to return */
	glob_t	glob;		/* globbing information */
	char	*cmd;		/* the current command */
};

static char	*copynext(char *, char *);
static int	 fcmp(const void *, const void *);
static void	 formatf(struct afile *, int);
static void	 getcmd(char *, char *, size_t, char *, size_t, struct arglist *);
struct dirent	*glob_readdir(RST_DIR *dirp);
static int	 glob_stat(const char *, struct stat *);
static void	 mkentry(char *, struct direct *, struct afile *);
static void	 printlist(char *, char *);

/*
 * Read and execute commands from the terminal.
 */
void
runcmdshell(void)
{
	struct entry *np;
	ino_t ino;
	struct arglist arglist;
	char curdir[PATH_MAX];
	char name[PATH_MAX];
	char cmd[BUFSIZ];

	arglist.freeglob = 0;
	arglist.argcnt = 0;
	arglist.glob.gl_flags = GLOB_ALTDIRFUNC;
	arglist.glob.gl_opendir = (void *)rst_opendir;
	arglist.glob.gl_readdir = (void *)glob_readdir;
	arglist.glob.gl_closedir = (void *)rst_closedir;
	arglist.glob.gl_lstat = glob_stat;
	arglist.glob.gl_stat = glob_stat;
	canon("/", curdir, sizeof curdir);
loop:
	if (setjmp(reset) != 0) {
		if (arglist.freeglob != 0) {
			arglist.freeglob = 0;
			arglist.argcnt = 0;
			globfree(&arglist.glob);
		}
		nextarg = NULL;
		volno = 0;
	}
	runshell = 1;
	getcmd(curdir, cmd, sizeof cmd, name, sizeof name, &arglist);
	switch (cmd[0]) {
	/*
	 * Add elements to the extraction list.
	 */
	case 'a':
		if (strncmp(cmd, "add", strlen(cmd)) != 0)
			goto bad;
		ino = dirlookup(name);
		if (ino == 0)
			break;
		if (mflag)
			pathcheck(name);
		treescan(name, ino, addfile);
		break;
	/*
	 * Change working directory.
	 */
	case 'c':
		if (strncmp(cmd, "cd", strlen(cmd)) != 0)
			goto bad;
		ino = dirlookup(name);
		if (ino == 0)
			break;
		if (inodetype(ino) == LEAF) {
			fprintf(stderr, "%s: not a directory\n", name);
			break;
		}
		(void)strlcpy(curdir, name, sizeof curdir);
		break;
	/*
	 * Delete elements from the extraction list.
	 */
	case 'd':
		if (strncmp(cmd, "delete", strlen(cmd)) != 0)
			goto bad;
		np = lookupname(name);
		if (np == NULL || (np->e_flags & NEW) == 0) {
			fprintf(stderr, "%s: not on extraction list\n", name);
			break;
		}
		treescan(name, np->e_ino, deletefile);
		break;
	/*
	 * Extract the requested list.
	 */
	case 'e':
		if (strncmp(cmd, "extract", strlen(cmd)) != 0)
			goto bad;
		createfiles();
		createlinks();
		setdirmodes(0);
		if (dflag)
			checkrestore();
		volno = 0;
		break;
	/*
	 * List available commands.
	 */
	case 'h':
		if (strncmp(cmd, "help", strlen(cmd)) != 0)
			goto bad;
	case '?':
		fprintf(stderr, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
			"Available commands are:\n",
			"\tls [arg] - list directory\n",
			"\tcd arg - change directory\n",
			"\tpwd - print current directory\n",
			"\tadd [arg] - add `arg' to list of",
			" files to be extracted\n",
			"\tdelete [arg] - delete `arg' from",
			" list of files to be extracted\n",
			"\textract - extract requested files\n",
			"\tsetmodes - set modes of requested directories\n",
			"\tquit - immediately exit program\n",
			"\twhat - list dump header information\n",
			"\tverbose - toggle verbose flag",
			" (useful with ``ls'')\n",
			"\thelp or `?' - print this list\n",
			"If no `arg' is supplied, the current",
			" directory is used\n");
		break;
	/*
	 * List a directory.
	 */
	case 'l':
		if (strncmp(cmd, "ls", strlen(cmd)) != 0)
			goto bad;
		printlist(name, curdir);
		break;
	/*
	 * Print current directory.
	 */
	case 'p':
		if (strncmp(cmd, "pwd", strlen(cmd)) != 0)
			goto bad;
		if (curdir[1] == '\0')
			fprintf(stderr, "/\n");
		else
			fprintf(stderr, "%s\n", &curdir[1]);
		break;
	/*
	 * Quit.
	 */
	case 'q':
		if (strncmp(cmd, "quit", strlen(cmd)) != 0)
			goto bad;
		return;
	case 'x':
		if (strncmp(cmd, "xit", strlen(cmd)) != 0)
			goto bad;
		return;
	/*
	 * Toggle verbose mode.
	 */
	case 'v':
		if (strncmp(cmd, "verbose", strlen(cmd)) != 0)
			goto bad;
		if (vflag) {
			fprintf(stderr, "verbose mode off\n");
			vflag = 0;
			break;
		}
		fprintf(stderr, "verbose mode on\n");
		vflag++;
		break;
	/*
	 * Just restore requested directory modes.
	 */
	case 's':
		if (strncmp(cmd, "setmodes", strlen(cmd)) != 0)
			goto bad;
		setdirmodes(FORCE);
		break;
	/*
	 * Print out dump header information.
	 */
	case 'w':
		if (strncmp(cmd, "what", strlen(cmd)) != 0)
			goto bad;
		printdumpinfo();
		break;
	/*
	 * Turn on debugging.
	 */
	case 'D':
		if (strncmp(cmd, "Debug", strlen(cmd)) != 0)
			goto bad;
		if (dflag) {
			fprintf(stderr, "debugging mode off\n");
			dflag = 0;
			break;
		}
		fprintf(stderr, "debugging mode on\n");
		dflag++;
		break;
	/*
	 * Unknown command.
	 */
	default:
	bad:
		fprintf(stderr, "%s: unknown command; type ? for help\n", cmd);
		break;
	}
	goto loop;
}

/*
 * Read and parse an interactive command.
 * The first word on the line is assigned to "cmd". If
 * there are no arguments on the command line, then "curdir"
 * is returned as the argument. If there are arguments
 * on the line they are returned one at a time on each
 * successive call to getcmd. Each argument is first assigned
 * to "name". If it does not start with "/" the pathname in
 * "curdir" is prepended to it. Finally "canon" is called to
 * eliminate any embedded ".." components.
 */
static void
getcmd(char *curdir, char *cmd, size_t cmdlen, char *name, size_t namelen,
       struct arglist *ap)
{
	char *cp;
	static char input[BUFSIZ];
	char output[BUFSIZ];
#	define rawname input	/* save space by reusing input buffer */
	int globretval;

	/*
	 * Check to see if still processing arguments.
	 */
	if (ap->argcnt > 0)
		goto retnext;
	if (nextarg != NULL)
		goto getnext;
	/*
	 * Read a command line and trim off trailing white space.
	 */
	do {
		(void)fprintf(stderr, "%s > ", __progname);
		(void)fflush(stderr);
		if (fgets(input, sizeof input, terminal) == NULL) {
			(void)strlcpy(cmd, "quit", cmdlen);
			return;
		}
	} while (input[0] == '\n' || input[0] == '\0');
	for (cp = &input[strlen(input) - 1];
	     cp >= input && (*cp == ' ' || *cp == '\t' || *cp == '\n'); cp--)
		/* trim off trailing white space and newline */;
	*++cp = '\0';
	/*
	 * Copy the command into "cmd".
	 */
	cp = copynext(input, cmd);
	ap->cmd = cmd;
	/*
	 * If no argument, use curdir as the default.
	 */
	if (*cp == '\0') {
		(void)strlcpy(name, curdir, PATH_MAX);
		return;
	}
	nextarg = cp;
	/*
	 * Find the next argument.
	 */
getnext:
	cp = copynext(nextarg, rawname);
	if (*cp == '\0')
		nextarg = NULL;
	else
		nextarg = cp;
	/*
	 * If it is an absolute pathname, canonicalize it and return it.
	 */
	if (rawname[0] == '/') {
		canon(rawname, name, namelen);
	} else {
		/*
		 * For relative pathnames, prepend the current directory to
		 * it then canonicalize and return it.
		 */
		snprintf(output, sizeof(output), "%s/%s", curdir, rawname);
		canon(output, name, namelen);
	}
	if ((globretval = glob(name, GLOB_ALTDIRFUNC | GLOB_NOESCAPE,
	    NULL, &ap->glob)) < 0) {
		fprintf(stderr, "%s: %s: ", ap->cmd, name);
		switch (globretval) {
		case GLOB_NOSPACE:
			fprintf(stderr, "out of memory\n");
			break;
		case GLOB_NOMATCH:
			fprintf(stderr, "no filename match.\n");
			break;
		case GLOB_ABORTED:
			fprintf(stderr, "glob() aborted.\n");
			break;
		default:
			fprintf(stderr, "unknown error!\n");
			break;
		}
	}

	if (ap->glob.gl_pathc == 0)
		return;
	ap->freeglob = 1;
	ap->argcnt = ap->glob.gl_pathc;

retnext:
	strlcpy(name, ap->glob.gl_pathv[ap->glob.gl_pathc - ap->argcnt],
	    PATH_MAX);
	if (--ap->argcnt == 0) {
		ap->freeglob = 0;
		globfree(&ap->glob);
	}
#	undef rawname
}

/*
 * Strip off the next token of the input.
 */
static char *
copynext(char *input, char *output)
{
	char *cp, *bp;
	char quote;

	for (cp = input; *cp == ' ' || *cp == '\t'; cp++)
		/* skip to argument */;
	bp = output;
	while (*cp != ' ' && *cp != '\t' && *cp != '\0') {
		/*
		 * Handle back slashes.
		 */
		if (*cp == '\\') {
			if (*++cp == '\0') {
				fprintf(stderr,
					"command lines cannot be continued\n");
				continue;
			}
			*bp++ = *cp++;
			continue;
		}
		/*
		 * The usual unquoted case.
		 */
		if (*cp != '\'' && *cp != '"') {
			*bp++ = *cp++;
			continue;
		}
		/*
		 * Handle single and double quotes.
		 */
		quote = *cp++;
		while (*cp != quote && *cp != '\0')
			*bp++ = *cp++;
		if (*cp++ == '\0') {
			fprintf(stderr, "missing %c\n", quote);
			cp--;
			continue;
		}
	}
	*bp = '\0';
	return (cp);
}

/*
 * Canonicalize file names to always start with ``./'' and
 * remove any imbedded "." and ".." components.
 */
void
canon(char *rawname, char *canonname, size_t canonnamelen)
{
	char *cp, *np;

	if (strcmp(rawname, ".") == 0 || strncmp(rawname, "./", 2) == 0)
		(void)strlcpy(canonname, "", canonnamelen);
	else if (rawname[0] == '/')
		(void)strlcpy(canonname, ".", canonnamelen);
	else
		(void)strlcpy(canonname, "./", canonnamelen);
	(void)strlcat(canonname, rawname, canonnamelen);
	/*
	 * Eliminate multiple and trailing '/'s
	 */
	for (cp = np = canonname; *np != '\0'; cp++) {
		*cp = *np++;
		while (*cp == '/' && *np == '/')
			np++;
	}
	*cp = '\0';
	if (*--cp == '/')
		*cp = '\0';
	/*
	 * Eliminate extraneous "." and ".." from pathnames.
	 */
	for (np = canonname; *np != '\0'; ) {
		np++;
		cp = np;
		while (*np != '/' && *np != '\0')
			np++;
		if (np - cp == 1 && *cp == '.') {
			cp--;
			(void)strlcpy(cp, np, canonname + canonnamelen - cp);
			np = cp;
		}
		if (np - cp == 2 && strncmp(cp, "..", 2) == 0) {
			cp--;
			while (cp > &canonname[1] && *--cp != '/')
				/* find beginning of name */;
			(void)strlcpy(cp, np, canonname + canonnamelen - cp);
			np = cp;
		}
	}
}

/*
 * Do an "ls" style listing of a directory
 */
static void
printlist(char *name, char *basename)
{
	struct afile *fp, *list, *listp = NULL;
	struct direct *dp;
	struct afile single;
	RST_DIR *dirp;
	size_t namelen;
	int entries, len;
	char locname[PATH_MAX];

	dp = pathsearch(name);
	if (dp == NULL || (!dflag && TSTINO(dp->d_ino, dumpmap) == 0))
		return;
	if ((dirp = rst_opendir(name)) == NULL) {
		entries = 1;
		list = &single;
		mkentry(name, dp, list);
		len = strlen(basename) + 1;
		if (strlen(name) - len > single.len) {
			freename(single.fname);
			single.fname = savename(&name[len]);
			single.len = strlen(single.fname);
		}
	} else {
		entries = 0;
		while ((dp = rst_readdir(dirp)))
			entries++;
		rst_closedir(dirp);
		list = calloc(entries, sizeof(struct afile));
		if (list == NULL) {
			fprintf(stderr, "ls: out of memory\n");
			return;
		}
		if ((dirp = rst_opendir(name)) == NULL)
			panic("directory reopen failed\n");
		fprintf(stderr, "%s:\n", name);
		entries = 0;
		listp = list;
		namelen = strlcpy(locname, name, sizeof(locname));
		if (namelen >= sizeof(locname) - 1)
			namelen = sizeof(locname) - 2;
		locname[namelen++] = '/';
		locname[namelen] = '\0';
		while ((dp = rst_readdir(dirp))) {
			if (dp == NULL)
				break;
			if (!dflag && TSTINO(dp->d_ino, dumpmap) == 0)
				continue;
			if (!vflag && (strcmp(dp->d_name, ".") == 0 ||
			     strcmp(dp->d_name, "..") == 0))
				continue;
			locname[namelen] = '\0';
			if (namelen + dp->d_namlen >= PATH_MAX) {
				fprintf(stderr, "%s%s: name exceeds %d char\n",
					locname, dp->d_name, PATH_MAX);
			} else {
				(void)strncat(locname, dp->d_name,
				    (int)dp->d_namlen);
				mkentry(locname, dp, listp++);
				entries++;
			}
		}
		rst_closedir(dirp);
		if (entries == 0) {
			fprintf(stderr, "\n");
			free(list);
			return;
		}
		qsort((char *)list, entries, sizeof(struct afile), fcmp);
	}
	formatf(list, entries);
	if (dirp != NULL) {
		for (fp = listp - 1; fp >= list; fp--)
			freename(fp->fname);
		fprintf(stderr, "\n");
		free(list);
	}
}

/*
 * Read the contents of a directory.
 */
static void
mkentry(char *name, struct direct *dp, struct afile *fp)
{
	char *cp;
	struct entry *np;

	fp->fnum = dp->d_ino;
	fp->fname = savename(dp->d_name);
	for (cp = fp->fname; *cp; cp++)
		if (!vflag && (*cp < ' ' || *cp >= 0177))
			*cp = '?';
	fp->len = cp - fp->fname;
	if (dflag && TSTINO(fp->fnum, dumpmap) == 0)
		fp->prefix = '^';
	else if ((np = lookupname(name)) != NULL && (np->e_flags & NEW))
		fp->prefix = '*';
	else
		fp->prefix = ' ';
	switch(dp->d_type) {

	default:
		fprintf(stderr, "Warning: undefined file type %d\n",
		    dp->d_type);
		/* fall through */
	case DT_REG:
		fp->postfix = ' ';
		break;

	case DT_LNK:
		fp->postfix = '@@';
		break;

	case DT_FIFO:
	case DT_SOCK:
		fp->postfix = '=';
		break;

	case DT_CHR:
	case DT_BLK:
		fp->postfix = '#';
		break;

	case DT_UNKNOWN:
	case DT_DIR:
		if (inodetype(dp->d_ino) == NODE)
			fp->postfix = '/';
		else
			fp->postfix = ' ';
		break;
	}
	return;
}

/*
 * Print out a pretty listing of a directory
 */
static void
formatf(struct afile *list, int nentry)
{
	struct afile *fp, *endlist;
	int width, bigino, haveprefix, havepostfix;
	int i, j, w, precision = 0, columns, lines;

	width = 0;
	haveprefix = 0;
	havepostfix = 0;
	bigino = ROOTINO;
	endlist = &list[nentry];
	for (fp = &list[0]; fp < endlist; fp++) {
		if (bigino < fp->fnum)
			bigino = fp->fnum;
		if (width < fp->len)
			width = fp->len;
		if (fp->prefix != ' ')
			haveprefix = 1;
		if (fp->postfix != ' ')
			havepostfix = 1;
	}
	if (haveprefix)
		width++;
	if (havepostfix)
		width++;
	if (vflag) {
		for (precision = 0, i = bigino; i > 0; i /= 10)
			precision++;
		width += precision + 1;
	}
	width++;
	columns = 81 / width;
	if (columns == 0)
		columns = 1;
	lines = (nentry + columns - 1) / columns;
	for (i = 0; i < lines; i++) {
		for (j = 0; j < columns; j++) {
			fp = &list[j * lines + i];
			if (vflag) {
				fprintf(stderr, "%*llu ", precision,
				(unsigned long long)fp->fnum);
				fp->len += precision + 1;
			}
			if (haveprefix) {
				putc(fp->prefix, stderr);
				fp->len++;
			}
			fprintf(stderr, "%s", fp->fname);
			if (havepostfix) {
				putc(fp->postfix, stderr);
				fp->len++;
			}
			if (fp + lines >= endlist) {
				fprintf(stderr, "\n");
				break;
			}
			for (w = fp->len; w < width; w++)
				putc(' ', stderr);
		}
	}
}

/*
 * Skip over directory entries that are not on the tape
 *
 * First have to get definition of a dirent.
 */
#undef DIRBLKSIZ
#include <dirent.h>
#undef d_ino

struct dirent *
glob_readdir(RST_DIR *dirp)
{
	struct direct *dp;
	static struct dirent adirent;

	while ((dp = rst_readdir(dirp)) != NULL) {
		if (dflag || TSTINO(dp->d_ino, dumpmap))
			break;
	}
	if (dp == NULL)
		return (NULL);
	adirent.d_fileno = dp->d_ino;
	adirent.d_namlen = dp->d_namlen;
	memcpy(adirent.d_name, dp->d_name, dp->d_namlen + 1);
	return (&adirent);
}

/*
 * Return st_mode information in response to stat or lstat calls
 */
static int
glob_stat(const char *name, struct stat *stp)
{
	struct direct *dp;

	dp = pathsearch(name);
	if (dp == NULL || (!dflag && TSTINO(dp->d_ino, dumpmap) == 0))
		return (-1);
	if (inodetype(dp->d_ino) == NODE)
		stp->st_mode = S_IFDIR;
	else
		stp->st_mode = S_IFREG;
	return (0);
}

/*
 * Comparison routine for qsort.
 */
static int
fcmp(const void *f1, const void *f2)
{
	return (strcmp(((struct afile *)f1)->fname,
	    ((struct afile *)f2)->fname));
}

/*
 * respond to interrupts
 */
void
onintr(int signo)
{
	int save_errno = errno;

	if (command == 'i' && runshell)
		longjmp(reset, 1);	/* XXX signal/longjmp reentrancy */
	if (reply("restore interrupted, continue") == FAIL)	/* XXX signal race */
		_exit(1);
	errno = save_errno;
}
@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.28 2013/04/25 06:43:20 otto Exp $	*/
a32 1
#include <sys/param.h>	/* MAXFRAG */
@


1.28
log
@big int_t/time_t fixes; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.27 2011/06/27 23:40:57 tedu Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d49 1
d98 2
a99 2
	char curdir[MAXPATHLEN];
	char name[MAXPATHLEN];
d341 1
a341 1
		(void)strlcpy(name, curdir, MAXPATHLEN);
d393 1
a393 1
	    MAXPATHLEN);
d511 1
a511 1
	char locname[MAXPATHLEN];
d555 1
a555 1
			if (namelen + dp->d_namlen >= MAXPATHLEN) {
d557 1
a557 1
					locname, dp->d_name, MAXPATHLEN);
@


1.27
log
@remove some useless casts. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.26 2009/10/27 23:59:34 deraadt Exp $	*/
d680 2
a681 1
				fprintf(stderr, "%*d ", precision, fp->fnum);
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.25 2007/09/25 09:51:48 chl Exp $	*/
d530 1
a530 1
		list = (struct afile *)calloc(entries, sizeof(struct afile));
@


1.25
log
@check fgets return value
use sizeof input intead of BUFSIZ
remove unneeded feof
handle empty strings returned by fgets
properly remove newline and white space at the end of buffer

with help and ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.24 2007/09/02 15:19:25 deraadt Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)interactive.c	8.3 (Berkeley) 9/13/94";
#else
static const char rcsid[] = "$OpenBSD: interactive.c,v 1.24 2007/09/02 15:19:25 deraadt Exp $";
#endif
#endif /* not lint */
@


1.24
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.23 2005/06/16 14:51:21 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: interactive.c,v 1.23 2005/06/16 14:51:21 millert Exp $";
d330 7
a336 7
		(void)fgets(input, BUFSIZ, terminal);
	} while (!feof(terminal) && input[0] == '\n');
	if (feof(terminal)) {
		(void)strlcpy(cmd, "quit", cmdlen);
		return;
	}
	for (cp = &input[strlen(input) - 2]; *cp == ' ' || *cp == '\t'; cp--)
@


1.23
log
@whiteout bit I missed earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.22 2005/06/14 19:46:05 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: interactive.c,v 1.22 2005/06/14 19:46:05 millert Exp $";
d538 1
a538 1
		list = (struct afile *)malloc(entries * sizeof(struct afile));
@


1.22
log
@Kill whiteout support.  OK deraadt@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.21 2005/04/28 16:15:46 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: interactive.c,v 1.21 2005/04/28 16:15:46 millert Exp $";
a631 4
		break;

	case DT_WHT:
		fp->postfix = '%';
@


1.21
log
@Use strlcpy() not snprintf().  OK otto@@ and moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.20 2004/07/17 02:14:33 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: interactive.c,v 1.20 2004/07/17 02:14:33 deraadt Exp $";
d521 1
a521 2
	if (dp == NULL || (!dflag && TSTINO(dp->d_ino, dumpmap) == 0) ||
	    (!vflag && dp->d_ino == WINO))
d558 1
a558 2
			if (!vflag && (dp->d_ino == WINO ||
			     strcmp(dp->d_name, ".") == 0 ||
a729 2
		if (!vflag && dp->d_ino == WINO)
			continue;
d750 1
a750 2
	if (dp == NULL || (!dflag && TSTINO(dp->d_ino, dumpmap) == 0) ||
	    (!vflag && dp->d_ino == WINO))
@


1.20
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.19 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: interactive.c,v 1.19 2003/07/28 06:13:26 tedu Exp $";
d516 2
a517 1
	int entries, len, namelen;
d549 5
a553 3
		namelen = snprintf(locname, sizeof(locname), "%s/", name);
		if (namelen >= sizeof(locname))
			namelen = sizeof(locname) - 1;
@


1.19
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.18 2003/07/10 00:00:58 david Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: interactive.c,v 1.17 2003/06/02 20:06:16 millert Exp $";
d100 1
a100 1
runcmdshell()
d308 2
a309 6
getcmd(curdir, cmd, cmdlen, name, namelen, ap)
	char *curdir, *cmd;
	size_t cmdlen;
	char *name;
	size_t namelen;
	struct arglist *ap;
d412 1
a412 2
copynext(input, output)
	char *input, *output;
d461 1
a461 3
canon(rawname, canonname, canonnamelen)
	char *rawname, *canonname;
	size_t canonnamelen;
d510 1
a510 3
printlist(name, basename)
	char *name;
	char *basename;
d592 1
a592 4
mkentry(name, dp, fp)
	char *name;
	struct direct *dp;
	struct afile *fp;
d652 1
a652 3
formatf(list, nentry)
	struct afile *list;
	int nentry;
d723 1
a723 2
glob_readdir(dirp)
	RST_DIR *dirp;
d746 1
a746 3
glob_stat(name, stp)
	const char *name;
	struct stat *stp;
d765 1
a765 2
fcmp(f1, f2)
	const void *f1, *f2;
d775 1
a775 2
onintr(signo)
	int signo;
@


1.18
log
@add missing includes
ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.17 2003/06/02 20:06:16 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.17 2003/06/02 20:06:16 millert Exp $";
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.16 2003/04/26 02:57:35 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.16 2003/04/26 02:57:35 deraadt Exp $";
d56 1
@


1.16
log
@string cleanup; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.15 2003/04/04 22:12:35 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.15 2003/04/04 22:12:35 deraadt Exp $";
@


1.15
log
@simple string fixes; ok matthieu tedu tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.14 2002/02/16 21:27:37 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.14 2002/02/16 21:27:37 millert Exp $";
d503 1
a503 1
			(void)strcpy(cp, np);
d510 1
a510 1
			(void)strcpy(cp, np);
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.13 2001/11/05 07:39:17 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.13 2001/11/05 07:39:17 mpech Exp $";
d93 1
a93 1
static void	 getcmd(char *, char *, char *, struct arglist *);
d120 1
a120 1
	canon("/", curdir);
d132 1
a132 1
	getcmd(curdir, cmd, name, &arglist);
d311 5
a315 2
getcmd(curdir, cmd, name, ap)
	char *curdir, *cmd, *name;
d340 1
a340 1
		(void)strcpy(cmd, "quit");
d372 1
a372 1
		canon(rawname, name);
d379 1
a379 1
		canon(output, name);
d469 1
a469 1
canon(rawname, canonname)
d471 1
d476 1
a476 1
		(void)strcpy(canonname, "");
d478 1
a478 1
		(void)strcpy(canonname, ".");
d480 2
a481 2
		(void)strcpy(canonname, "./");
	(void)strlcat(canonname, rawname, MAXPATHLEN);
@


1.13
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.12 2001/07/07 18:26:19 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.12 2001/07/07 18:26:19 deraadt Exp $";
d90 8
a97 8
static char	*copynext __P((char *, char *));
static int	 fcmp __P((const void *, const void *));
static void	 formatf __P((struct afile *, int));
static void	 getcmd __P((char *, char *, char *, struct arglist *));
struct dirent	*glob_readdir __P((RST_DIR *dirp));
static int	 glob_stat __P((const char *, struct stat *));
static void	 mkentry __P((char *, struct direct *, struct afile *));
static void	 printlist __P((char *, char *));
@


1.12
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.11 2001/01/19 17:57:41 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.11 2001/01/19 17:57:41 deraadt Exp $";
d105 1
a105 1
	register struct entry *np;
d315 1
a315 1
	register char *cp;
d419 1
a419 1
	register char *cp, *bp;
d469 1
a469 1
	register char *cp, *np;
d520 2
a521 2
	register struct afile *fp, *list, *listp = NULL;
	register struct direct *dp;
d603 1
a603 1
	register struct afile *fp;
d664 1
a664 1
	register struct afile *list;
d667 1
a667 1
	register struct afile *fp, *endlist;
d764 1
a764 1
	register struct direct *dp;
d782 1
a782 1
	register const void *f1, *f2;
@


1.11
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.10 2000/01/10 03:08:05 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.10 2000/01/10 03:08:05 deraadt Exp $";
d520 1
a520 1
	register struct afile *fp, *list, *listp;
d669 1
a669 1
	int i, j, w, precision, columns, lines;
@


1.10
log
@handle glob() return values better; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.9 1999/02/17 00:17:33 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.9 1999/02/17 00:17:33 deraadt Exp $";
d798 3
a800 3
		longjmp(reset, 1);
	if (reply("restore interrupted, continue") == FAIL)
		exit(1);
@


1.9
log
@make quoted strings work; erh@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.8 1998/09/18 18:48:11 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.8 1998/09/18 18:48:11 deraadt Exp $";
d319 1
d378 19
a396 2
	if (glob(name, GLOB_ALTDIRFUNC | GLOB_NOESCAPE, NULL, &ap->glob) < 0)
		fprintf(stderr, "%s: out of memory\n", ap->cmd);
@


1.8
log
@buf oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.7 1998/06/23 22:40:31 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.7 1998/06/23 22:40:31 millert Exp $";
d432 1
a432 1
			*bp++ = *cp++ | 0200;
@


1.7
log
@Fix snprintf return value usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.6 1998/01/31 23:08:49 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.6 1998/01/31 23:08:49 millert Exp $";
d160 1
a160 1
		(void)strcpy(curdir, name);
d351 1
a351 1
		(void)strcpy(name, curdir);
d374 1
a374 3
		(void)strcpy(output, curdir);
		(void)strcat(output, "/");
		(void)strcat(output, rawname);
d385 2
a386 1
	strcpy(name, ap->glob.gl_pathv[ap->glob.gl_pathc - ap->argcnt]);
d459 1
a459 1
	(void)strcat(canonname, rawname);
@


1.6
log
@Use GLOB_NOESCAPE flag with glob(3) to preserve old behavior now that
glob(3) accepts backslash quoting by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.5 1997/08/06 01:45:26 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.5 1997/08/06 01:45:26 deraadt Exp $";
d540 2
@


1.5
log
@do not clobber errno in signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.4 1997/07/05 20:51:22 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.4 1997/07/05 20:51:22 millert Exp $";
d379 1
a379 1
	if (glob(name, GLOB_ALTDIRFUNC, NULL, &ap->glob) < 0)
@


1.4
log
@vprintf -> Vprintf and dprintf -> Dprintf to avoid confusion
Use err/errx and warn/warnx where it makes sense.
Some sprintf -> snprintf, strcpy -> strncpy, and strcat -> strncat.
Honor $TMPDIR (based on changes from NetBSD)
Use __progname not "restore" (we could be called as rrestore).
Some -Wall happiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.3 1996/12/16 17:11:43 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.3 1996/12/16 17:11:43 deraadt Exp $";
d57 1
d776 2
d782 1
@


1.3
log
@does noone know how to use strncat correctly?
@
text
@d1 2
a2 2
/*	$OpenBSD: interactive.c,v 1.2 1996/06/23 14:32:15 deraadt Exp $	*/
/*	$NetBSD: interactive.c,v 1.9 1995/03/18 14:59:44 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.2 1996/06/23 14:32:15 deraadt Exp $";
d159 1
a159 1
		(void) strcpy(curdir, name);
d329 4
a332 4
	do	{
		fprintf(stderr, "restore > ");
		(void) fflush(stderr);
		(void) fgets(input, BUFSIZ, terminal);
d335 1
a335 1
		(void) strcpy(cmd, "quit");
d350 1
a350 1
		(void) strcpy(name, curdir);
d373 3
a375 3
		(void) strcpy(output, curdir);
		(void) strcat(output, "/");
		(void) strcat(output, rawname);
d454 1
a454 1
		(void) strcpy(canonname, "");
d456 1
a456 1
		(void) strcpy(canonname, ".");
d458 2
a459 2
		(void) strcpy(canonname, "./");
	(void) strcat(canonname, rawname);
d481 1
a481 1
			(void) strcpy(cp, np);
d488 1
a488 1
			(void) strcpy(cp, np);
d507 1
a507 1
	char locname[MAXPATHLEN + 1];
d525 1
a525 1
		while (dp = rst_readdir(dirp))
d538 2
a539 5
		(void) strncpy(locname, name, MAXPATHLEN);
		locname[sizeof locname - 1] = '\0';
		(void) strncat(locname, "/", MAXPATHLEN - strlen(locname));
		namelen = strlen(locname);
		while (dp = rst_readdir(dirp)) {
d553 1
a553 1
				(void) strncat(locname, dp->d_name,
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: interactive.c,v 1.9 1995/03/18 14:59:44 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: interactive.c,v 1.9 1995/03/18 14:59:44 cgd Exp $";
d539 2
a540 1
		(void) strncat(locname, "/", MAXPATHLEN);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: interactive.c,v 1.9 1995/03/18 14:59:44 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
