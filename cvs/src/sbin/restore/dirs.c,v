head	1.41;
access;
symbols
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.4
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.35.0.6
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.8
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.12
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.8
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.6
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.4
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.30.0.8
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.6
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.4
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.17.0.10
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.17.0.8
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.17.0.6
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.4
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2015.08.25.04.18.43;	author guenther;	state Exp;
branches;
next	1.40;
commitid	tmwLojyIfsVatsQk;

1.40
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	F55lwc3gS4GN2mLs;

1.39
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	Uu5nFG3wCl0LACBb;

1.38
date	2014.09.07.19.43.35;	author guenther;	state Exp;
branches;
next	1.37;
commitid	GSOkQ3sPLnOep58t;

1.37
date	2014.07.21.01.51.11;	author guenther;	state Exp;
branches;
next	1.36;
commitid	ro8JUTvBpvQMiFY9;

1.36
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.35;
commitid	0acpjAf5myNxgwB5;

1.35
date	2013.04.25.06.43.20;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2011.06.27.23.40.57;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.03.20.16.08;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.28.16.15.45;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.30.01.51.32;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.13.21.51.18;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.25.23.28.16;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.07.00.51.52;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.06.15.42.07;	author avsm;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.13.05.00.44;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.17;

1.17
date	99.08.17.09.13.15;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.06.23.22.40.30;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.02.17.00.07.51;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.05.20.51.21;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.04.16.04.07.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.12.24.08.37.50;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.12.16.17.11.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.12.15.18.49.24;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.12.04.01.41.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.16.16.35.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.08.02.11.26.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.09.02.11.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.25.01.12.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.32.14;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.17.09.06.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.16.13.26.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Switch from utimes() to utimensat() to $estore full nanosecond granularity

ok millert@@ deraadt@@
@
text
@/*	$OpenBSD: dirs.c,v 1.40 2015/01/20 18:22:21 deraadt Exp $	*/
/*	$NetBSD: dirs.c,v 1.26 1997/07/01 05:37:49 lukem Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>

#include <ufs/ffs/fs.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <protocols/dumprestore.h>

#include <endian.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "restore.h"
#include "extern.h"

/*
 * Symbol table of directories read from tape.
 */
#define HASHSIZE	1000
#define INOHASH(val) (val % HASHSIZE)
struct inotab {
	struct	inotab *t_next;
	ino_t	t_ino;
	int32_t	t_seekpt;
	int32_t	t_size;
};
static struct inotab *inotab[HASHSIZE];

/*
 * Information retained about directories.
 */
struct modeinfo {
	ino_t ino;
	struct timespec ctimep[2];
	struct timespec mtimep[2];
	mode_t mode;
	uid_t uid;
	gid_t gid;
	u_int flags;
};

/*
 * Definitions for library routines operating on directories.
 */
#undef DIRBLKSIZ
#define DIRBLKSIZ 1024
struct rstdirdesc {
	int	dd_fd;
	int32_t	dd_loc;
	int32_t	dd_size;
	char	dd_buf[DIRBLKSIZ];
};

/*
 * Global variables for this file.
 */
static long	seekpt;
static FILE	*df, *mf;
static RST_DIR	*dirp;
static char	dirfile[PATH_MAX] = "#";	/* No file */
static char	modefile[PATH_MAX] = "#";	/* No file */
static char	dot[2] = ".";			/* So it can be modified */

/*
 * Format of old style directories.
 */
#define ODIRSIZ 14
struct odirect {
	u_short	d_ino;
	char	d_name[ODIRSIZ];
};

static struct inotab	*allocinotab(FILE *, struct context *, long);
static void		 dcvt(struct odirect *, struct direct *);
static void		 flushent(void);
static struct inotab	*inotablookup(ino_t);
static RST_DIR		*opendirfile(const char *);
static void		 putdir(char *, size_t);
static void		 putent(struct direct *);
static void		 rst_seekdir(RST_DIR *, long, long);
static long		 rst_telldir(RST_DIR *);
static struct direct	*searchdir(ino_t, char *);

/*
 *	Extract directory contents, building up a directory structure
 *	on disk for extraction by name.
 *	If genmode is requested, save mode, owner, and times for all
 *	directories on the tape.
 */
void
extractdirs(int genmode)
{
	int i;
	struct inotab *itp;
	struct direct nulldir;
	int fd;

	Vprintf(stdout, "Extract directories from tape\n");
	(void)snprintf(dirfile, sizeof(dirfile), "%s/rstdir%lld", tmpdir,
	    (long long)dumpdate);
	if (command != 'r' && command != 'R') {
		strlcat(dirfile, "-XXXXXXXXXX", sizeof(dirfile));
		fd = mkstemp(dirfile);
	} else
		fd = open(dirfile, O_RDWR|O_CREAT|O_EXCL, 0666);
	if (fd == -1 || (df = fdopen(fd, "w")) == NULL) {
		int saved_errno = errno;
		if (fd != -1)
			close(fd);
		errc(1, saved_errno,
		    "cannot create directory temporary %s", dirfile);
	}
	if (genmode != 0) {
		(void)snprintf(modefile, sizeof(modefile), "%s/rstmode%lld",
		    tmpdir, (long long)dumpdate);
		if (command != 'r' && command != 'R') {
			strlcat(modefile, "-XXXXXXXXXX", sizeof(modefile));
			fd = mkstemp(modefile);
		} else
			fd = open(modefile, O_RDWR|O_CREAT|O_EXCL, 0666);
		if (fd == -1 || (mf = fdopen(fd, "w")) == NULL) {
			int saved_errno = errno;
			if (fd != -1)
				close(fd);
			errc(1, saved_errno,
			    "cannot create modefile %s", modefile);
		}
	}
	nulldir.d_ino = 0;
	nulldir.d_type = DT_DIR;
	nulldir.d_namlen = 1;
	nulldir.d_name[0] = '/';
	nulldir.d_name[1] = '\0';
	nulldir.d_reclen = DIRSIZ(0, &nulldir);
	for (;;) {
		curfile.name = "<directory file - name unknown>";
		curfile.action = USING;
		if (curfile.mode == 0 || (curfile.mode & IFMT) != IFDIR) {
			(void)fclose(df);
			dirp = opendirfile(dirfile);
			if (dirp == NULL)
				warn("opendirfile");
			if (mf != NULL)
				(void)fclose(mf);
			i = dirlookup(dot);
			if (i == 0)
				panic("Root directory is not on tape\n");
			return;
		}
		itp = allocinotab(mf, &curfile, seekpt);
		getfile(putdir, xtrnull);
		putent(&nulldir);
		flushent();
		itp->t_size = seekpt - itp->t_seekpt;
	}
}

/*
 * skip over all the directories on the tape
 */
void
skipdirs(void)
{

	while (curfile.ino && (curfile.mode & IFMT) == IFDIR) {
		skipfile();
	}
}

/*
 *	Recursively find names and inumbers of all files in subtree
 *	pname and pass them off to be processed.
 */
void
treescan(char *pname, ino_t ino, long (*todo)(char *, ino_t, int))
{
	struct inotab *itp;
	struct direct *dp;
	size_t namelen;
	long bpt;
	char locname[PATH_MAX + 1];

	itp = inotablookup(ino);
	if (itp == NULL) {
		/*
		 * Pname is name of a simple file or an unchanged directory.
		 */
		(void)(*todo)(pname, ino, LEAF);
		return;
	}
	/*
	 * Pname is a dumped directory name.
	 */
	if ((*todo)(pname, ino, NODE) == FAIL)
		return;
	/*
	 * begin search through the directory
	 * skipping over "." and ".."
	 */
	namelen = strlcpy(locname, pname, sizeof(locname));
	if (namelen >= sizeof(locname) - 1)
		namelen = sizeof(locname) - 2;
	locname[namelen++] = '/';
	locname[namelen] = '\0';
	rst_seekdir(dirp, itp->t_seekpt, itp->t_seekpt);
	dp = rst_readdir(dirp); /* "." */
	if (dp != NULL && strcmp(dp->d_name, ".") == 0)
		dp = rst_readdir(dirp); /* ".." */
	else
		fprintf(stderr, "Warning: `.' missing from directory %s\n",
			pname);
	if (dp != NULL && strcmp(dp->d_name, "..") == 0)
		dp = rst_readdir(dirp); /* first real entry */
	else
		fprintf(stderr, "Warning: `..' missing from directory %s\n",
			pname);
	bpt = rst_telldir(dirp);
	/*
	 * a zero inode signals end of directory
	 */
	while (dp != NULL) {
		locname[namelen] = '\0';
		if (namelen + dp->d_namlen >= sizeof(locname)) {
			fprintf(stderr, "%s%s: name exceeds %zd char\n",
				locname, dp->d_name, sizeof(locname) - 1);
		} else {
			(void)strlcat(locname, dp->d_name, sizeof(locname));
			treescan(locname, dp->d_ino, todo);
			rst_seekdir(dirp, bpt, itp->t_seekpt);
		}
		dp = rst_readdir(dirp);
		bpt = rst_telldir(dirp);
	}
}

/*
 * Lookup a pathname which is always assumed to start from the ROOTINO.
 */
struct direct *
pathsearch(const char *pathname)
{
	ino_t ino;
	struct direct *dp;
	char *path, *name, buffer[PATH_MAX];

	strlcpy(buffer, pathname, sizeof buffer);
	path = buffer;
	ino = ROOTINO;
	while (*path == '/')
		path++;
	dp = NULL;
	while ((name = strsep(&path, "/")) != NULL && *name != '\0') {
		if ((dp = searchdir(ino, name)) == NULL)
			return (NULL);
		ino = dp->d_ino;
	}
	return (dp);
}

/*
 * Lookup the requested name in directory inum.
 * Return its inode number if found, zero if it does not exist.
 */
static struct direct *
searchdir(ino_t inum, char *name)
{
	struct direct *dp;
	struct inotab *itp;
	int len;

	itp = inotablookup(inum);
	if (itp == NULL)
		return (NULL);
	rst_seekdir(dirp, itp->t_seekpt, itp->t_seekpt);
	len = strlen(name);
	do {
		dp = rst_readdir(dirp);
		if (dp == NULL)
			return (NULL);
	} while (dp->d_namlen != len || strncmp(dp->d_name, name, len) != 0);
	return (dp);
}

/*
 * Put the directory entries in the directory file
 */
static void
putdir(char *buf, size_t size)
{
	struct direct cvtbuf;
	struct odirect *odp;
	struct odirect *eodp;
	struct direct *dp;
	size_t loc, i;

	if (cvtflag) {
		eodp = (struct odirect *)&buf[size];
		for (odp = (struct odirect *)buf; odp < eodp; odp++)
			if (odp->d_ino != 0) {
				dcvt(odp, &cvtbuf);
				putent(&cvtbuf);
			}
	} else {
		for (loc = 0; loc < size; ) {
			dp = (struct direct *)(buf + loc);
			if (Bcvt) {
				dp->d_ino = swap32(dp->d_ino);
				dp->d_reclen = swap16(dp->d_reclen);
			}
			if (oldinofmt && dp->d_ino != 0) {
#				if BYTE_ORDER == BIG_ENDIAN
					if (Bcvt)
						dp->d_namlen = dp->d_type;
#				else
					if (!Bcvt)
						dp->d_namlen = dp->d_type;
#				endif
				dp->d_type = DT_UNKNOWN;
			}
			i = DIRBLKSIZ - (loc & (DIRBLKSIZ - 1));
			if ((dp->d_reclen & 0x3) != 0 ||
			    dp->d_reclen > i ||
			    dp->d_reclen < DIRSIZ(0, dp) ||
			    dp->d_namlen > NAME_MAX) {
				Vprintf(stdout, "Mangled directory: ");
				if ((dp->d_reclen & 0x3) != 0)
					Vprintf(stdout,
					   "reclen not multiple of 4 ");
				if (dp->d_reclen < DIRSIZ(0, dp))
					Vprintf(stdout,
					   "reclen less than DIRSIZ (%u < %u) ",
					   (unsigned)dp->d_reclen,
					   (unsigned)DIRSIZ(0, dp));
				if (dp->d_namlen > NAME_MAX)
					Vprintf(stdout,
					   "reclen name too big (%u > %u) ",
					   (unsigned)dp->d_namlen, NAME_MAX);
				Vprintf(stdout, "\n");
				loc += i;
				continue;
			}
			loc += dp->d_reclen;
			if (dp->d_ino != 0) {
				putent(dp);
			}
		}
	}
}

/*
 * These variables are "local" to the following two functions.
 */
char dirbuf[DIRBLKSIZ];
long dirloc = 0;
long prev = 0;

/*
 * add a new directory entry to a file.
 */
static void
putent(struct direct *dp)
{
	dp->d_reclen = DIRSIZ(0, dp);
	if (dirloc + dp->d_reclen > DIRBLKSIZ) {
		((struct direct *)(dirbuf + prev))->d_reclen =
		    DIRBLKSIZ - prev;
		(void)fwrite(dirbuf, 1, DIRBLKSIZ, df);
		dirloc = 0;
	}
	memcpy(dirbuf + dirloc, dp, dp->d_reclen);
	prev = dirloc;
	dirloc += dp->d_reclen;
}

/*
 * flush out a directory that is finished.
 */
static void
flushent(void)
{
	((struct direct *)(dirbuf + prev))->d_reclen = DIRBLKSIZ - prev;
	(void)fwrite(dirbuf, dirloc, 1, df);
	seekpt = ftell(df);
	dirloc = 0;
}

static void
dcvt(struct odirect *odp, struct direct *ndp)
{

	memset(ndp, 0, sizeof *ndp);
	if (Bcvt)
	    ndp->d_ino = swap16(odp->d_ino);
	else
	    ndp->d_ino = odp->d_ino;
	ndp->d_type = DT_UNKNOWN;
	(void)strncpy(ndp->d_name, odp->d_name, ODIRSIZ);
	ndp->d_namlen = strlen(ndp->d_name);
	ndp->d_reclen = DIRSIZ(0, ndp);
}

/*
 * Seek to an entry in a directory.
 * Only values returned by rst_telldir should be passed to rst_seekdir.
 * This routine handles many directories in a single file.
 * It takes the base of the directory in the file, plus
 * the desired seek offset into it.
 */
static void
rst_seekdir(RST_DIR *dirp, long loc, long base)
{

	if (loc == rst_telldir(dirp))
		return;
	loc -= base;
	if (loc < 0)
		fprintf(stderr, "bad seek pointer to rst_seekdir %ld\n", loc);
	(void)lseek(dirp->dd_fd, base + (loc & ~(DIRBLKSIZ - 1)), SEEK_SET);
	dirp->dd_loc = loc & (DIRBLKSIZ - 1);
	if (dirp->dd_loc != 0)
		dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf, DIRBLKSIZ);
}

/*
 * get next entry in a directory.
 */
struct direct *
rst_readdir(RST_DIR *dirp)
{
	struct direct *dp;

	for (;;) {
		if (dirp->dd_loc == 0) {
			dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf,
			    DIRBLKSIZ);
			if (dirp->dd_size <= 0) {
				Dprintf(stderr, "error reading directory\n");
				return (NULL);
			}
		}
		if (dirp->dd_loc >= dirp->dd_size) {
			dirp->dd_loc = 0;
			continue;
		}
		dp = (struct direct *)(dirp->dd_buf + dirp->dd_loc);
		if (dp->d_reclen == 0 ||
		    dp->d_reclen > DIRBLKSIZ + 1 - dirp->dd_loc) {
			Dprintf(stderr, "corrupted directory: bad reclen %d\n",
				dp->d_reclen);
			return (NULL);
		}
		dirp->dd_loc += dp->d_reclen;
		if (dp->d_ino == 0 && strcmp(dp->d_name, "/") == 0)
			return (NULL);
		if (dp->d_ino >= maxino) {
			Dprintf(stderr, "corrupted directory: bad inum %llu\n",
			    (unsigned long long)dp->d_ino);
			continue;
		}
		return (dp);
	}
}

/*
 * Simulate the opening of a directory
 */
RST_DIR *
rst_opendir(const char *name)
{
	struct inotab *itp;
	RST_DIR *dirp;
	ino_t ino;

	if ((ino = dirlookup(name)) > 0 &&
	    (itp = inotablookup(ino)) != NULL) {
		dirp = opendirfile(dirfile);
		rst_seekdir(dirp, itp->t_seekpt, itp->t_seekpt);
		return (dirp);
	}
	return (NULL);
}

/*
 * In our case, there is nothing to do when closing a directory.
 */
void
rst_closedir(RST_DIR *dirp)
{
	(void)close(dirp->dd_fd);
	free(dirp);
	return;
}

/*
 * Simulate finding the current offset in the directory.
 */
static long
rst_telldir(RST_DIR *dirp)
{
	return ((long)lseek(dirp->dd_fd,
	    (off_t)0, SEEK_CUR) - dirp->dd_size + dirp->dd_loc);
}

/*
 * Open a directory file.
 */
static RST_DIR *
opendirfile(const char *name)
{
	RST_DIR *dirp;
	int fd;

	if ((fd = open(name, O_RDONLY)) == -1)
		return (NULL);
	if ((dirp = malloc(sizeof(RST_DIR))) == NULL) {
		(void)close(fd);
		return (NULL);
	}
	dirp->dd_fd = fd;
	dirp->dd_loc = 0;
	return (dirp);
}

/*
 * Set the mode, owner, and times for all new or changed directories
 */
void
setdirmodes(int flags)
{
	FILE *mf;
	struct modeinfo node;
	struct entry *ep;
	char *cp;

	Vprintf(stdout, "Set directory mode, owner, and times.\n");
	if (command == 'r' || command == 'R')
		(void)snprintf(modefile, sizeof(modefile), "%s/rstmode%lld",
		    tmpdir, (long long)dumpdate);
	if (modefile[0] == '#') {
		panic("modefile not defined\n");
		fputs("directory mode, owner, and times not set\n", stderr);
		return;
	}
	mf = fopen(modefile, "r");
	if (mf == NULL) {
		warn("fopen");
		fprintf(stderr, "cannot open mode file %s\n", modefile);
		fprintf(stderr, "directory mode, owner, and times not set\n");
		return;
	}
	clearerr(mf);
	for (;;) {
		(void)fread((char *)&node, 1, sizeof(struct modeinfo), mf);
		if (feof(mf))
			break;
		ep = lookupino(node.ino);
		if (command == 'i' || command == 'x') {
			if (ep == NULL)
				continue;
			if ((flags & FORCE) == 0 && ep->e_flags & EXISTED) {
				ep->e_flags &= ~NEW;
				continue;
			}
			if (node.ino == ROOTINO &&
		   	    reply("set owner/mode for '.'") == FAIL)
				continue;
		}
		if (ep == NULL) {
			panic("cannot find directory inode %llu\n",
			    (unsigned long long)node.ino);
		} else {
			if (!Nflag) {
				cp = myname(ep);
				(void)chown(cp, node.uid, node.gid);
				(void)chmod(cp, node.mode);
				(void)chflags(cp, node.flags);
				(void)utimensat(AT_FDCWD, cp, node.ctimep, 0);
				(void)utimensat(AT_FDCWD, cp, node.mtimep, 0);
			}
			ep->e_flags &= ~NEW;
		}
	}
	if (ferror(mf))
		panic("error setting directory modes\n");
	(void)fclose(mf);
}

/*
 * Generate a literal copy of a directory.
 */
int
genliteraldir(char *name, ino_t ino)
{
	struct inotab *itp;
	int ofile, dp, i, size;
	char buf[BUFSIZ];

	itp = inotablookup(ino);
	if (itp == NULL)
		panic("Cannot find directory inode %llu named %s\n",
		    (unsigned long long)ino, name);
	if ((ofile = open(name, O_WRONLY | O_CREAT | O_TRUNC, 0666)) < 0) {
		warn("%s: cannot create file", name);
		return (FAIL);
	}
	rst_seekdir(dirp, itp->t_seekpt, itp->t_seekpt);
	dp = dup(dirp->dd_fd);
	for (i = itp->t_size; i > 0; i -= BUFSIZ) {
		size = i < BUFSIZ ? i : BUFSIZ;
		if (read(dp, buf, size) == -1)
			err(1, "read error extracting inode %llu, name %s",
			    (unsigned long long)curfile.ino, curfile.name);
		xtrfile(buf, size);
	}
	(void)close(dp);
	(void)close(ofile);
	return (GOOD);
}

/*
 * Determine the type of an inode
 */
int
inodetype(ino_t ino)
{
	struct inotab *itp;

	itp = inotablookup(ino);
	if (itp == NULL)
		return (LEAF);
	return (NODE);
}

/*
 * Allocate and initialize a directory inode entry.
 * If requested, save its pertinent mode, owner, and time info.
 */
static struct inotab *
allocinotab(FILE *mf, struct context *ctxp, long seekpt)
{
	struct inotab	*itp;
	struct modeinfo node;

	itp = calloc(1, sizeof(struct inotab));
	if (itp == NULL)
		panic("no memory directory table\n");
	itp->t_next = inotab[INOHASH(ctxp->ino)];
	inotab[INOHASH(ctxp->ino)] = itp;
	itp->t_ino = ctxp->ino;
	itp->t_seekpt = seekpt;
	if (mf == NULL)
		return (itp);
	node.ino = ctxp->ino;
	node.mtimep[0].tv_sec = ctxp->atime_sec;
	node.mtimep[0].tv_nsec = ctxp->atime_nsec;
	node.mtimep[1].tv_sec = ctxp->mtime_sec;
	node.mtimep[1].tv_nsec = ctxp->mtime_nsec;
	node.ctimep[0].tv_sec = ctxp->atime_sec;
	node.ctimep[0].tv_nsec = ctxp->atime_nsec;
	node.ctimep[1].tv_sec = ctxp->birthtime_sec;
	node.ctimep[1].tv_nsec = ctxp->birthtime_nsec;
	node.mode = ctxp->mode;
	node.flags = ctxp->file_flags;
	node.uid = ctxp->uid;
	node.gid = ctxp->gid;
	(void)fwrite((char *)&node, 1, sizeof(struct modeinfo), mf);
	return (itp);
}

/*
 * Look up an inode in the table of directories
 */
static struct inotab *
inotablookup(ino_t ino)
{
	struct inotab *itp;

	for (itp = inotab[INOHASH(ino)]; itp != NULL; itp = itp->t_next)
		if (itp->t_ino == ino)
			return (itp);
	return (NULL);
}

/*
 * Clean up and exit
 */
void
cleanup(void)
{

	closemt();
	if (modefile[0] != '#')
		(void)unlink(modefile);
	if (dirfile[0] != '#')
		(void)unlink(dirfile);
}
@


1.40
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.39 2015/01/16 06:40:00 deraadt Exp $	*/
d78 2
a79 2
	struct timeval ctimep[2];
	struct timeval mtimep[2];
d621 2
a622 2
				(void)utimes(cp, node.ctimep);
				(void)utimes(cp, node.mtimep);
d699 1
a699 1
	node.mtimep[0].tv_usec = ctxp->atime_nsec / 1000;
d701 1
a701 1
	node.mtimep[1].tv_usec = ctxp->mtime_nsec / 1000;
d703 1
a703 1
	node.ctimep[0].tv_usec = ctxp->atime_nsec / 1000;
d705 1
a705 1
	node.ctimep[1].tv_usec = ctxp->birthtime_nsec / 1000;
@


1.39
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.38 2014/09/07 19:43:35 guenther Exp $	*/
a37 1
#include <sys/param.h>	/* MAXFRAG */
@


1.38
log
@Reuse xtrfile() to avoid duplication.
Casting from long to int for a size_t argument is dumb.
Calling warnx() right before err() is silly.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.37 2014/07/21 01:51:11 guenther Exp $	*/
d38 1
a38 1
#include <sys/param.h>
d56 1
d105 2
a106 2
static char	dirfile[MAXPATHLEN] = "#";	/* No file */
static char	modefile[MAXPATHLEN] = "#";	/* No file */
d226 1
a226 1
	char locname[MAXPATHLEN + 1];
d289 1
a289 1
	char *path, *name, buffer[MAXPATHLEN];
@


1.37
log
@Switch from <sys/endian.h> or <machine/endian.h> to the new,
being-standardized <endian.h>

ok deraadt@@ millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.36 2014/07/20 01:38:40 guenther Exp $	*/
d426 1
a426 1
	(void)fwrite(dirbuf, (int)dirloc, 1, df);
d654 2
a655 2
		if (read(dp, buf, (int) size) == -1) {
			warnx("write error extracting inode %llu, name %s",
d657 1
a657 8
			err(1, "read");
		}
		if (!Nflag && write(ofile, buf, (int) size) == -1) {
			fprintf(stderr,
			    "write error extracting inode %llu, name %s\n",
			    (unsigned long long)curfile.ino, curfile.name);
			err(1, "write");
		}
@


1.36
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.35 2013/04/25 06:43:20 otto Exp $	*/
d47 1
a55 2

#include <machine/endian.h>
@


1.35
log
@big int_t/time_t fixes; ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.34 2013/04/24 13:46:29 deraadt Exp $	*/
d48 1
d152 1
d155 2
a156 1
		err(1, "cannot create directory temporary %s", dirfile);
d167 1
d170 2
a171 1
			err(1, "cannot create modefile %s", modefile);
@


1.34
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.33 2011/06/27 23:40:57 tedu Exp $	*/
d143 2
a144 2
	(void)snprintf(dirfile, sizeof(dirfile), "%s/rstdir%d", tmpdir,
	    dumpdate);
d156 2
a157 2
		(void)snprintf(modefile, sizeof(modefile), "%s/rstmode%d",
		    tmpdir, dumpdate);
d577 2
a578 2
		(void)snprintf(modefile, sizeof(modefile), "%s/rstmode%d",
		    tmpdir, dumpdate);
@


1.33
log
@remove some useless casts. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.32 2009/10/27 23:59:34 deraadt Exp $	*/
d496 2
a497 2
			Dprintf(stderr, "corrupted directory: bad inum %d\n",
				dp->d_ino);
d609 2
a610 1
			panic("cannot find directory inode %d\n", node.ino);
d640 2
a641 1
		panic("Cannot find directory inode %d named %s\n", ino, name);
d651 2
a652 2
			warnx("write error extracting inode %d, name %s",
			    curfile.ino, curfile.name);
d657 2
a658 2
				"write error extracting inode %d, name %s\n",
				curfile.ino, curfile.name);
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.31 2007/06/03 20:16:08 millert Exp $	*/
d410 1
a410 1
	memcpy(dirbuf + dirloc, dp, (long)dp->d_reclen);
d431 1
a431 1
	memset(ndp, 0, (size_t)(sizeof *ndp));
@


1.31
log
@Add ffs2 support to dump/restore.  From FreeBSD with some NetBSD changes.
With help from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.30 2005/04/28 16:15:45 millert Exp $	*/
a36 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)dirs.c	8.5 (Berkeley) 8/31/94";
#else
static const char rcsid[] = "$OpenBSD: dirs.c,v 1.30 2005/04/28 16:15:45 millert Exp $";
#endif
#endif /* not lint */
@


1.30
log
@Use strlcpy() not snprintf().  OK otto@@ and moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.29 2004/12/30 01:51:32 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: dirs.c,v 1.29 2004/12/30 01:51:32 millert Exp $";
d86 2
a87 1
	struct timeval timep[2];
d125 1
a125 1
static struct inotab	*allocinotab(ino_t, struct ufs1_dinode *, long);
a145 1
	struct ufs1_dinode *ip;
d186 1
a186 2
		ip = curfile.dip;
		if (ip == NULL || (ip->di_mode & IFMT) != IFDIR) {
d198 1
a198 1
		itp = allocinotab(curfile.ino, ip, seekpt);
d213 1
a213 1
	while (curfile.dip && (curfile.dip->di_mode & IFMT) == IFDIR) {
d272 1
a272 1
			fprintf(stderr, "%s%s: name exceeds %d char\n",
d619 8
a626 5
			cp = myname(ep);
			(void)chown(cp, node.uid, node.gid);
			(void)chmod(cp, node.mode);
			(void)chflags(cp, node.flags);
			utimes(cp, node.timep);
d692 1
a692 1
allocinotab(ino_t ino, struct ufs1_dinode *dip, long seekpt)
d700 3
a702 3
	itp->t_next = inotab[INOHASH(ino)];
	inotab[INOHASH(ino)] = itp;
	itp->t_ino = ino;
d706 13
a718 9
	node.ino = ino;
	node.timep[0].tv_sec = dip->di_atime;
	node.timep[0].tv_usec = dip->di_atimensec / 1000;
	node.timep[1].tv_sec = dip->di_mtime;
	node.timep[1].tv_usec = dip->di_mtimensec / 1000;
	node.mode = dip->di_mode;
	node.flags = dip->di_flags;
	node.uid = dip->di_uid;
	node.gid = dip->di_gid;
@


1.29
log
@Replace home-grown byte swapping routine with calls to swap* macros
from endian.h.  Header swapping is moved into its own function.
Fixes problems reading non-native endian dump images on sparc64.
Adapted from changes in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.28 2004/07/17 02:14:33 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: dirs.c,v 1.28 2004/07/17 02:14:33 deraadt Exp $";
d228 1
a228 1
	int namelen;
d249 5
a253 3
	namelen = snprintf(locname, sizeof(locname), "%s/", pname);
	if (namelen >= sizeof(locname))
		namelen = sizeof(locname) - 1;
@


1.28
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.27 2004/04/13 21:51:18 henning Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: dirs.c,v 1.27 2004/04/13 21:51:18 henning Exp $";
d353 4
a356 2
			if (Bcvt)
				swabst((u_char *)"ls", (u_char *) dp);
d439 4
a442 1
	ndp->d_ino =  odp->d_ino;
@


1.27
log
@fix restore so that it can actually restore files larger than 4GB by
changing the type of "size" to off_t in getfiles() plus little dependent
type cleanup, from Daniel Lucq <daniel@@lucq.org>
ok tdeval@@ millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.26 2003/08/25 23:28:16 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: dirs.c,v 1.26 2003/08/25 23:28:16 tedu Exp $";
d142 1
a142 2
extractdirs(genmode)
	int genmode;
d211 1
a211 1
skipdirs()
d224 1
a224 4
treescan(pname, ino, todo)
	char *pname;
	ino_t ino;
	long (*todo)(char *, ino_t, int);
d287 1
a287 2
pathsearch(pathname)
	const char *pathname;
d312 1
a312 3
searchdir(inum, name)
	ino_t	inum;
	char	*name;
d335 1
a335 3
putdir(buf, size)
	char *buf;
	size_t size;
d406 1
a406 2
putent(dp)
	struct direct *dp;
d424 1
a424 1
flushent()
d433 1
a433 3
dcvt(odp, ndp)
	struct odirect *odp;
	struct direct *ndp;
d452 1
a452 3
rst_seekdir(dirp, loc, base)
	RST_DIR *dirp;
	long loc, base;
d470 1
a470 2
rst_readdir(dirp)
	RST_DIR *dirp;
d510 1
a510 2
rst_opendir(name)
	const char *name;
d529 1
a529 2
rst_closedir(dirp)
	RST_DIR *dirp;
a530 1

d540 1
a540 2
rst_telldir(dirp)
	RST_DIR *dirp;
d550 1
a550 2
opendirfile(name)
	const char *name;
d570 1
a570 2
setdirmodes(flags)
	int flags;
d630 1
a630 3
genliteraldir(name, ino)
	char *name;
	ino_t ino;
d668 1
a668 2
inodetype(ino)
	ino_t ino;
d683 1
a683 4
allocinotab(ino, dip, seekpt)
	ino_t ino;
	struct ufs1_dinode *dip;
	long seekpt;
d714 1
a714 2
inotablookup(ino)
	ino_t	ino;
d728 1
a728 1
cleanup()
@


1.26
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.25 2003/07/29 18:38:36 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: dirs.c,v 1.25 2003/07/29 18:38:36 deraadt Exp $";
d129 1
a129 1
static void		 putdir(char *, long);
d344 1
a344 1
	long size;
d350 1
a350 1
	long loc, i;
d385 3
a387 2
					   "reclen less than DIRSIZ (%d < %d) ",
					   dp->d_reclen, DIRSIZ(0, dp));
d390 2
a391 2
					   "reclen name too big (%d > %d) ",
					   dp->d_namlen, NAME_MAX);
@


1.25
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.24 2003/07/28 06:13:26 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: dirs.c,v 1.24 2003/07/28 06:13:26 tedu Exp $";
d124 1
a124 1
static struct inotab	*allocinotab(ino_t, struct dinode *, long);
d146 1
a146 1
	struct dinode *ip;
d708 1
a708 1
	struct dinode *dip;
@


1.24
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.23 2003/07/07 00:51:52 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: dirs.c,v 1.21 2003/06/02 20:06:16 millert Exp $";
d596 1
a596 1
	
@


1.23
log
@Repair last commit, the NUL termination of locname is required
for the strlcat() to work since the buffer gets used for each
entry in a directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.22 2003/07/06 15:42:07 avsm Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.22 2003/07/06 15:42:07 avsm Exp $";
@


1.22
log
@convert strn{cpy,cat}->strl{cpy,cat} in directory processing
comments and from krw@@, tdeval@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.21 2003/06/02 20:06:16 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.21 2003/06/02 20:06:16 millert Exp $";
d232 1
d253 3
a255 1
	(void)snprintf(locname, sizeof(locname), "%s/", pname);
d273 2
a274 1
		if (strlen(locname) + dp->d_namlen >= sizeof(locname)) {
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.20 2003/03/13 05:00:44 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.20 2003/03/13 05:00:44 deraadt Exp $";
d155 1
a155 2
		strncat(dirfile, "-XXXXXXXXXX",
		    sizeof(dirfile) - strlen(dirfile));
d168 1
a168 2
			strncat(modefile, "-XXXXXXXXXX",
			    sizeof(modefile) - strlen(modefile));
a231 1
	int namelen;
d252 1
a252 3
	namelen = snprintf(locname, sizeof(locname), "%s/", pname);
	if (namelen >= sizeof(locname))
		namelen = sizeof(locname) - 1;
d270 1
a270 2
		locname[namelen] = '\0';
		if (namelen + dp->d_namlen >= sizeof(locname)) {
d274 1
a274 1
			(void)strncat(locname, dp->d_name, (int)dp->d_namlen);
@


1.20
log
@more strlcpy; most from Hans-Joerg.Hoexer@@yerbouti.franken.de, a bit from me
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.19 2002/02/16 21:27:37 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.19 2002/02/16 21:27:37 millert Exp $";
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.18 2001/11/05 07:39:17 mpech Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.18 2001/11/05 07:39:17 mpech Exp $";
d304 1
a304 1
	strcpy(buffer, pathname);
@


1.18
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.17 1999/08/17 09:13:15 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.17 1999/08/17 09:13:15 millert Exp $";
d128 10
a137 10
static struct inotab	*allocinotab __P((ino_t, struct dinode *, long));
static void		 dcvt __P((struct odirect *, struct direct *));
static void		 flushent __P((void));
static struct inotab	*inotablookup __P((ino_t));
static RST_DIR		*opendirfile __P((const char *));
static void		 putdir __P((char *, long));
static void		 putent __P((struct direct *));
static void		 rst_seekdir __P((RST_DIR *, long, long));
static long		 rst_telldir __P((RST_DIR *));
static struct direct	*searchdir __P((ino_t, char *));
d234 1
a234 1
	long (*todo) __P((char *, ino_t, int));
@


1.17
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.16 1998/06/23 22:40:30 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.16 1998/06/23 22:40:30 millert Exp $";
d149 2
a150 2
	register int i;
	register struct dinode *ip;
d236 2
a237 2
	register struct inotab *itp;
	register struct direct *dp;
d327 2
a328 2
	register struct direct *dp;
	register struct inotab *itp;
d353 1
a353 1
	register struct odirect *odp;
d355 1
a355 1
	register struct direct *dp;
d449 2
a450 2
	register struct odirect *odp;
	register struct direct *ndp;
d470 1
a470 1
	register RST_DIR *dirp;
d490 1
a490 1
	register RST_DIR *dirp;
d492 1
a492 1
	register struct direct *dp;
d577 2
a578 2
	register RST_DIR *dirp;
	register int fd;
d660 1
a660 1
	register struct inotab *itp;
d717 1
a717 1
	register struct inotab	*itp;
d749 1
a749 1
	register struct inotab *itp;
@


1.16
log
@Fix snprintf return value usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.15 1998/02/17 00:07:51 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.15 1998/02/17 00:07:51 millert Exp $";
a50 1
#include <sys/file.h>
d60 1
@


1.15
log
@chflags(2) take a u_int
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.14 1997/07/05 20:51:21 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.14 1997/07/05 20:51:21 millert Exp $";
d260 2
@


1.14
log
@vprintf -> Vprintf and dprintf -> Dprintf to avoid confusion
Use err/errx and warn/warnx where it makes sense.
Some sprintf -> snprintf, strcpy -> strncpy, and strcat -> strncat.
Honor $TMPDIR (based on changes from NetBSD)
Use __progname not "restore" (we could be called as rrestore).
Some -Wall happiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.13 1997/04/16 04:07:35 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.13 1997/04/16 04:07:35 millert Exp $";
d94 1
a94 1
	int flags;
@


1.13
log
@No need for "pathnames.h" now that _PATH_DEFTAPE is in <paths.h>
Fix rmt -> rst in man page and change ".Nm restore" -> ".Nm"
@
text
@d1 2
a2 2
/*	$OpenBSD: dirs.c,v 1.12 1996/12/24 08:37:50 deraadt Exp $	*/
/*	$NetBSD: dirs.c,v 1.16 1995/06/19 00:20:11 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.12 1996/12/24 08:37:50 deraadt Exp $";
d60 1
a60 1
#include <errno.h>
d155 3
a157 2
	vprintf(stdout, "Extract directories from tape\n");
	(void) sprintf(dirfile, "%srstdir%d", _PATH_TMP, dumpdate);
d159 2
a160 1
		(void *) strcat(dirfile, "-XXXXXX");
d167 1
a167 5
		fprintf(stderr,
		    "restore: %s - cannot create directory temporary\n",
		    dirfile);
		fprintf(stderr, "fopen: %s\n", strerror(errno));
		exit(1);
d170 2
a171 1
		(void) sprintf(modefile, "%srstmode%d", _PATH_TMP, dumpdate);
d173 2
a174 1
			(void *) strcat(modefile, "-XXXXXX");
d181 1
a181 5
			fprintf(stderr,
			    "restore: %s - cannot create modefile \n",
			    modefile);
			fprintf(stderr, "fopen: %s\n", strerror(errno));
			exit(1);
d187 2
a188 1
	(void) strcpy(nulldir.d_name, "/");
d195 1
a195 1
			(void) fclose(df);
d198 1
a198 2
				fprintf(stderr, "opendirfile: %s\n",
				    strerror(errno));
d200 1
a200 1
				(void) fclose(mf);
d227 1
a227 1
 *	Recursively find names and inumbers of all files in subtree 
d247 1
a247 1
		(void) (*todo)(pname, ino, LEAF);
d259 1
a259 4
	(void) strncpy(locname, pname, sizeof(locname) - 1);
	locname[sizeof(locname) - 1] = '\0';
	(void) strncat(locname, "/", sizeof(locname) - strlen(locname));
	namelen = strlen(locname);
d282 1
a282 1
			(void) strncat(locname, dp->d_name, (int)dp->d_namlen);
d308 1
a308 1
	while ((name = strsep(&path, "/")) != NULL && *name != NULL) {
d383 1
a383 1
				vprintf(stdout, "Mangled directory: ");
d385 1
a385 1
					vprintf(stdout,
d388 1
a388 1
					vprintf(stdout,
d392 1
a392 1
					vprintf(stdout,
d395 1
a395 1
				vprintf(stdout, "\n");
d425 1
a425 1
		(void) fwrite(dirbuf, 1, DIRBLKSIZ, df);
d440 1
a440 1
	(void) fwrite(dirbuf, (int)dirloc, 1, df);
d454 1
a454 1
	(void) strncpy(ndp->d_name, odp->d_name, ODIRSIZ);
d476 2
a477 2
		fprintf(stderr, "bad seek pointer to rst_seekdir %d\n", loc);
	(void) lseek(dirp->dd_fd, base + (loc & ~(DIRBLKSIZ - 1)), SEEK_SET);
d494 1
a494 1
			dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf, 
d497 1
a497 1
				dprintf(stderr, "error reading directory\n");
d508 1
a508 1
			dprintf(stderr, "corrupted directory: bad reclen %d\n",
d516 1
a516 1
			dprintf(stderr, "corrupted directory: bad inum %d\n",
d601 1
a601 1
	vprintf(stdout, "Set directory mode, owner, and times.\n");
d603 2
a604 1
		(void) sprintf(modefile, "%srstmode%d", _PATH_TMP, dumpdate);
d607 1
a607 1
		fprintf(stderr, "directory mode, owner, and times not set\n");
d612 1
a612 1
		fprintf(stderr, "fopen: %s\n", strerror(errno));
d619 1
a619 1
		(void) fread((char *)&node, 1, sizeof(struct modeinfo), mf);
d638 3
a640 3
			(void) chown(cp, node.uid, node.gid);
			(void) chmod(cp, node.mode);
			(void) chflags(cp, node.flags);
d647 1
a647 1
	(void) fclose(mf);
d666 1
a666 3
		fprintf(stderr, "%s: ", name);
		(void) fflush(stderr);
		fprintf(stderr, "cannot create file: %s\n", strerror(errno));
d674 3
a676 5
			fprintf(stderr,
				"write error extracting inode %d, name %s\n",
				curfile.ino, curfile.name);
			fprintf(stderr, "read: %s\n", strerror(errno));
			exit(1);
d682 1
a682 2
			fprintf(stderr, "write: %s\n", strerror(errno));
			exit(1);
d685 2
a686 2
	(void) close(dp);
	(void) close(ofile);
d736 1
a736 1
	(void) fwrite((char *)&node, 1, sizeof(struct modeinfo), mf);
d764 1
a764 1
		(void) unlink(modefile);
d766 1
a766 1
		(void) unlink(dirfile);
@


1.12
log
@use mkstemp()
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.11 1996/12/16 17:11:41 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.11 1996/12/16 17:11:41 deraadt Exp $";
d61 1
a68 1
#include "pathnames.h"
@


1.11
log
@does noone know how to use strncat correctly?
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.10 1996/12/15 18:49:24 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.10 1996/12/15 18:49:24 millert Exp $";
d159 4
a162 9
		if (mktemp(dirfile) == NULL) {
			fprintf(stderr,
			    "restore: %s - cannot mktemp directory temporary\n",
			    dirfile);
			exit(1);
		}
	}
	if ((fd = open(dirfile, O_RDWR|O_CREAT|O_EXCL, 0666)) == -1 ||
	    (df = fdopen(fd, "w")) == NULL) {
d175 4
a178 9
			if (mktemp(modefile) == NULL) {
				fprintf(stderr,
				    "restore: %s - cannot mktemp modefile\n",
				    modefile);
				exit(1);
			}
		}
		if ((fd = open(modefile, O_RDWR|O_CREAT|O_EXCL,
		    0666)) == -1 || (mf = fdopen(fd, "w")) == NULL) {
@


1.10
log
@Fix strncpy usage and correct strncat length field, from Theo.
Also change some occurrence of MAXPATHLEN with sizeof(foo).
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.9 1996/12/04 01:41:53 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.9 1996/12/04 01:41:53 deraadt Exp $";
d275 1
a275 1
	(void) strncat(locname, "/", sizeof(locname) - strlen(locname) - 1);
@


1.9
log
@64 bit patches, tih@@nhh.no
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.8 1996/09/16 16:35:09 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.8 1996/09/16 16:35:09 millert Exp $";
d273 3
a275 2
	(void) strncpy(locname, pname, MAXPATHLEN);
	(void) strncat(locname, "/", MAXPATHLEN);
d295 1
a295 1
		if (namelen + dp->d_namlen >= MAXPATHLEN) {
d297 1
a297 1
				locname, dp->d_name, MAXPATHLEN);
d468 1
a468 1
	memset(ndp, 0, (long)(sizeof *ndp));
@


1.8
log
@/tmp// -> /tmp/
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.7 1996/08/02 11:26:23 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.7 1996/08/02 11:26:23 deraadt Exp $";
d80 2
a81 2
	long	t_seekpt;
	long	t_size;
d104 2
a105 2
	long	dd_loc;
	long	dd_size;
@


1.7
log
@ptr check in skipdirs(), by joerg from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.6 1996/07/09 02:11:13 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.6 1996/07/09 02:11:13 deraadt Exp $";
d156 1
a156 1
	(void) sprintf(dirfile, "%s/rstdir%d", _PATH_TMP, dumpdate);
d177 1
a177 1
		(void) sprintf(modefile, "%s/rstmode%d", _PATH_TMP, dumpdate);
d619 1
a619 1
		(void) sprintf(modefile, "%s/rstmode%d", _PATH_TMP, dumpdate);
@


1.6
log
@mktemp whoops
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.5 1996/06/25 01:12:10 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.5 1996/06/25 01:12:10 deraadt Exp $";
d235 1
a235 1
	while ((curfile.dip->di_mode & IFMT) == IFDIR) {
@


1.5
log
@mktemp open & fdopen
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.4 1996/06/23 14:32:14 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.4 1996/06/23 14:32:14 deraadt Exp $";
d166 1
a166 2
	fd = -1;
	if (fd = open(dirfile, O_RDWR|O_CREAT|O_EXCL, 0666) == -1 ||
d187 2
a188 3
		fd = -1;
		if (fd = open(modefile, O_RDWR|O_CREAT|O_EXCL,
		    0666) == -1 || (mf = fdopen(fd, "w")) == NULL) {
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: dirs.c,v 1.16 1995/06/19 00:20:11 cgd Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: dirs.c,v 1.16 1995/06/19 00:20:11 cgd Exp $";
d153 1
d166 5
a170 2
	df = fopen(dirfile, "w");
	if (df == NULL) {
d188 5
a192 2
		mf = fopen(modefile, "w");
		if (mf == NULL) {
@


1.3
log
@updated patch from lukem@@supp.cpr.itg.telecom.com.au to also make -r and -R work again
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: dirs.c,v 1.16 1995/06/19 00:20:11 cgd Exp $";
@


1.2
log
@use unique temporary files; netbsd pr#2544; lukem@@supp.cpr.itg.telecom.com.au
@
text
@d154 9
a162 6
	(void) sprintf(dirfile, "%s/rstdir%d-XXXXXX", _PATH_TMP, dumpdate);
	if (mktemp(dirfile) == NULL) {
		fprintf(stderr,
		    "restore: %s - cannot generate directory temporary\n",
		    dirfile);
		exit(1);
d173 9
a181 7
		(void) sprintf(modefile, "%s/rstmode%d-XXXXXX", _PATH_TMP,
		    dumpdate);
		if (mktemp(modefile) == NULL) {
			fprintf(stderr,
			    "restore: %s - cannot generate modefile\n",
			    modefile);
			exit(1);
d612 7
a618 1
	(void) sprintf(modefile, "%s/rstmode%d", _PATH_TMP, dumpdate);
@


1.1
log
@Initial revision
@
text
@d114 3
a116 3
static char	dirfile[32] = "#";	/* No file */
static char	modefile[32] = "#";	/* No file */
static char	dot[2] = ".";		/* So it can be modified */
d154 7
a160 1
	(void) sprintf(dirfile, "%s/rstdir%d", _PATH_TMP, dumpdate);
d170 8
a177 1
		(void) sprintf(modefile, "%s/rstmode%d", _PATH_TMP, dumpdate);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
