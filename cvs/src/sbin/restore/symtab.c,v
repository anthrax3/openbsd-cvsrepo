head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.10
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.8
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.4
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.14
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.10
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.8
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.18
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2013.12.30.22.01.23;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.27.23.40.57;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.18.21.18.59;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.15.07.02.35;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.14.19.46.05;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.26.02.57.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.12.00.42.56;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	97.07.05.20.51.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.09.18.55.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.04.01.41.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: symtab.c,v 1.21 2013/12/30 22:01:23 deraadt Exp $	*/
/*	$NetBSD: symtab.c,v 1.10 1997/03/19 08:42:54 lukem Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * These routines maintain the symbol table which tracks the state
 * of the file system being restored. They provide lookup by either
 * name or inode number. They also provide for creation, deletion,
 * and renaming of entries. Because of the dynamic nature of pathnames,
 * names should not be saved, but always constructed just before they
 * are needed, by calling "myname".
 */

#include <sys/stat.h>

#include <ufs/ufs/dinode.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "restore.h"
#include "extern.h"

/*
 * The following variables define the inode symbol table.
 * The primary hash table is dynamically allocated based on
 * the number of inodes in the file system (maxino), scaled by
 * HASHFACTOR. The variable "entry" points to the hash table;
 * the variable "entrytblsize" indicates its size (in entries).
 */
#define HASHFACTOR 5
static struct entry **entry;
static long entrytblsize;

static void		 addino(ino_t, struct entry *);
static struct entry	*lookupparent(char *);
static void		 removeentry(struct entry *);

/*
 * Look up an entry by inode number
 */
struct entry *
lookupino(ino_t inum)
{
	struct entry *ep;

	if (inum < ROOTINO || inum >= maxino)
		return (NULL);
	for (ep = entry[inum % entrytblsize]; ep != NULL; ep = ep->e_next)
		if (ep->e_ino == inum)
			return (ep);
	return (NULL);
}

/*
 * Add an entry into the entry table
 */
static void
addino(ino_t inum, struct entry *np)
{
	struct entry **epp;

	if (inum < ROOTINO || inum >= maxino)
		panic("addino: out of range %llu\n",
		    (unsigned long long)inum);
	epp = &entry[inum % entrytblsize];
	np->e_ino = inum;
	np->e_next = *epp;
	*epp = np;
	if (dflag)
		for (np = np->e_next; np != NULL; np = np->e_next)
			if (np->e_ino == inum)
				badentry(np, "duplicate inum");
}

/*
 * Delete an entry from the entry table
 */
void
deleteino(ino_t inum)
{
	struct entry *next;
	struct entry **prev;

	if (inum < ROOTINO || inum >= maxino)
		panic("deleteino: out of range %llu\n",
		    (unsigned long long)inum);
	prev = &entry[inum % entrytblsize];
	for (next = *prev; next != NULL; next = next->e_next) {
		if (next->e_ino == inum) {
			next->e_ino = 0;
			*prev = next->e_next;
			return;
		}
		prev = &next->e_next;
	}
	panic("deleteino: %llu not found\n", (unsigned long long)inum);
}

/*
 * Look up an entry by name
 */
struct entry *
lookupname(char *name)
{
	struct entry *ep;
	char *np, *cp;
	char buf[PATH_MAX];

	cp = name;
	for (ep = lookupino(ROOTINO); ep != NULL; ep = ep->e_entries) {
		for (np = buf;
		    *cp != '/' && *cp != '\0' && np < &buf[sizeof(buf)]; )
			*np++ = *cp++;
		if (np == &buf[sizeof(buf)])
			break;
		*np = '\0';
		for ( ; ep != NULL; ep = ep->e_sibling)
			if (strcmp(ep->e_name, buf) == 0)
				break;
		if (ep == NULL)
			break;
		if (*cp++ == '\0')
			return (ep);
	}
	return (NULL);
}

/*
 * Look up the parent of a pathname
 */
static struct entry *
lookupparent(char *name)
{
	struct entry *ep;
	char *tailindex;

	tailindex = strrchr(name, '/');
	if (tailindex == NULL)
		return (NULL);
	*tailindex = '\0';
	ep = lookupname(name);
	*tailindex = '/';
	if (ep == NULL)
		return (NULL);
	if (ep->e_type != NODE)
		panic("%s is not a directory\n", name);
	return (ep);
}

/*
 * Determine the current pathname of a node or leaf
 */
char *
myname(struct entry *ep)
{
	char *cp;
	static char namebuf[PATH_MAX];

	for (cp = &namebuf[PATH_MAX - 2]; cp > &namebuf[ep->e_namlen]; ) {
		cp -= ep->e_namlen;
		memcpy(cp, ep->e_name, ep->e_namlen);
		if (ep == lookupino(ROOTINO))
			return (cp);
		*(--cp) = '/';
		ep = ep->e_parent;
	}
	panic("%s: pathname too long\n", cp);
	return(cp);
}

/*
 * Unused symbol table entries are linked together on a freelist
 * headed by the following pointer.
 */
static struct entry *freelist = NULL;

/*
 * add an entry to the symbol table
 */
struct entry *
addentry(char *name, ino_t inum, int type)
{
	struct entry *np, *ep;

	if (freelist != NULL) {
		np = freelist;
		freelist = np->e_next;
		memset(np, 0, sizeof(struct entry));
	} else {
		np = calloc(1, sizeof(struct entry));
		if (np == NULL)
			panic("no memory to extend symbol table\n");
	}
	np->e_type = type & ~LINK;
	ep = lookupparent(name);
	if (ep == NULL) {
		if (inum != ROOTINO || lookupino(ROOTINO) != NULL)
			panic("bad name to addentry %s\n", name);
		np->e_name = savename(name);
		np->e_namlen = strlen(name);
		np->e_parent = np;
		addino(ROOTINO, np);
		return (np);
	}
	np->e_name = savename(strrchr(name, '/') + 1);
	np->e_namlen = strlen(np->e_name);
	np->e_parent = ep;
	np->e_sibling = ep->e_entries;
	ep->e_entries = np;
	if (type & LINK) {
		ep = lookupino(inum);
		if (ep == NULL)
			panic("link to non-existent name\n");
		np->e_ino = inum;
		np->e_links = ep->e_links;
		ep->e_links = np;
	} else if (inum != 0) {
		if (lookupino(inum) != NULL)
			panic("duplicate entry\n");
		addino(inum, np);
	}
	return (np);
}

/*
 * delete an entry from the symbol table
 */
void
freeentry(struct entry *ep)
{
	struct entry *np;
	ino_t inum;

	if (ep->e_flags != REMOVED)
		badentry(ep, "not marked REMOVED");
	if (ep->e_type == NODE) {
		if (ep->e_links != NULL)
			badentry(ep, "freeing referenced directory");
		if (ep->e_entries != NULL)
			badentry(ep, "freeing non-empty directory");
	}
	if (ep->e_ino != 0) {
		np = lookupino(ep->e_ino);
		if (np == NULL)
			badentry(ep, "lookupino failed");
		if (np == ep) {
			inum = ep->e_ino;
			deleteino(inum);
			if (ep->e_links != NULL)
				addino(inum, ep->e_links);
		} else {
			for (; np != NULL; np = np->e_links) {
				if (np->e_links == ep) {
					np->e_links = ep->e_links;
					break;
				}
			}
			if (np == NULL)
				badentry(ep, "link not found");
		}
	}
	removeentry(ep);
	freename(ep->e_name);
	ep->e_next = freelist;
	freelist = ep;
}

/*
 * Relocate an entry in the tree structure
 */
void
moveentry(struct entry *ep, char *newname)
{
	struct entry *np;
	char *cp;

	np = lookupparent(newname);
	if (np == NULL)
		badentry(ep, "cannot move ROOT");
	if (np != ep->e_parent) {
		removeentry(ep);
		ep->e_parent = np;
		ep->e_sibling = np->e_entries;
		np->e_entries = ep;
	}
	cp = strrchr(newname, '/') + 1;
	freename(ep->e_name);
	ep->e_name = savename(cp);
	ep->e_namlen = strlen(cp);
	if (strcmp(gentempname(ep), ep->e_name) == 0)
		ep->e_flags |= TMPNAME;
	else
		ep->e_flags &= ~TMPNAME;
}

/*
 * Remove an entry in the tree structure
 */
static void
removeentry(struct entry *ep)
{
	struct entry *np;

	np = ep->e_parent;
	if (np->e_entries == ep) {
		np->e_entries = ep->e_sibling;
	} else {
		for (np = np->e_entries; np != NULL; np = np->e_sibling) {
			if (np->e_sibling == ep) {
				np->e_sibling = ep->e_sibling;
				break;
			}
		}
		if (np == NULL)
			badentry(ep, "cannot find entry in parent list");
	}
}

/*
 * Table of unused string entries, sorted by length.
 *
 * Entries are allocated in STRTBLINCR sized pieces so that names
 * of similar lengths can use the same entry. The value of STRTBLINCR
 * is chosen so that every entry has at least enough space to hold
 * a "struct strtbl" header. Thus every entry can be linked onto an
 * apprpriate free list.
 *
 * NB. The macro "allocsize" below assumes that "struct strhdr"
 *     has a size that is a power of two.
 */
struct strhdr {
	struct strhdr *next;
};

#define STRTBLINCR	(sizeof(struct strhdr))
#define allocsize(size)	(((size) + 1 + STRTBLINCR - 1) & ~(STRTBLINCR - 1))

static struct strhdr strtblhdr[allocsize(NAME_MAX) / STRTBLINCR];

/*
 * Allocate space for a name. It first looks to see if it already
 * has an appropriate sized entry, and if not allocates a new one.
 */
char *
savename(char *name)
{
	struct strhdr *np;
	long len;
	char *cp;

	if (name == NULL)
		panic("bad name\n");
	len = strlen(name);
	np = strtblhdr[len / STRTBLINCR].next;
	if (np != NULL) {
		strtblhdr[len / STRTBLINCR].next = np->next;
		cp = (char *)np;
	} else {
		cp = malloc(allocsize(len));
		if (cp == NULL)
			panic("no space for string table\n");
	}
	(void)strlcpy(cp, name, len + 1);
	return (cp);
}

/*
 * Free space for a name. The resulting entry is linked onto the
 * appropriate free list.
 */
void
freename(char *name)
{
	struct strhdr *tp, *np;

	tp = &strtblhdr[strlen(name) / STRTBLINCR];
	np = (struct strhdr *)name;
	np->next = tp->next;
	tp->next = np;
}

/*
 * Useful quantities placed at the end of a dumped symbol table.
 */
struct symtableheader {
	int32_t	volno;
	int32_t	stringsize;
	int32_t	entrytblsize;
	time_t	dumptime;
	time_t	dumpdate;
	ino_t	maxino;
	int32_t	ntrec;
};

/*
 * dump a snapshot of the symbol table
 */
void
dumpsymtable(char *filename, long checkpt)
{
	struct entry *ep, *tep;
	ino_t i;
	struct entry temp, *tentry;
	long mynum = 1, stroff = 0;
	FILE *fp;
	struct symtableheader hdr;

	Vprintf(stdout, "Check pointing the restore\n");
	if (Nflag)
		return;
	if ((fp = fopen(filename, "w")) == NULL) {
		warn("fopen");
		panic("cannot create save file %s for symbol table\n",
		    filename);
	}
	clearerr(fp);
	/*
	 * Assign indices to each entry
	 * Write out the string entries
	 */
	for (i = ROOTINO; i <= maxino; i++) {
		for (ep = lookupino(i); ep != NULL; ep = ep->e_links) {
			ep->e_index = mynum++;
			(void)fwrite(ep->e_name, sizeof(char),
			       (int)allocsize(ep->e_namlen), fp);
		}
	}
	/*
	 * Convert pointers to indexes, and output
	 */
	tep = &temp;
	stroff = 0;
	for (i = ROOTINO; i <= maxino; i++) {
		for (ep = lookupino(i); ep != NULL; ep = ep->e_links) {
			memcpy(tep, ep, sizeof(struct entry));
			tep->e_name = (char *)stroff;
			stroff += allocsize(ep->e_namlen);
			tep->e_parent = (struct entry *)ep->e_parent->e_index;
			if (ep->e_links != NULL)
				tep->e_links =
					(struct entry *)ep->e_links->e_index;
			if (ep->e_sibling != NULL)
				tep->e_sibling =
					(struct entry *)ep->e_sibling->e_index;
			if (ep->e_entries != NULL)
				tep->e_entries =
					(struct entry *)ep->e_entries->e_index;
			if (ep->e_next != NULL)
				tep->e_next =
					(struct entry *)ep->e_next->e_index;
			(void)fwrite((char *)tep, sizeof(struct entry), 1, fp);
		}
	}
	/*
	 * Convert entry pointers to indexes, and output
	 */
	for (i = 0; i < entrytblsize; i++) {
		if (entry[i] == NULL)
			tentry = NULL;
		else
			tentry = (struct entry *)entry[i]->e_index;
		(void)fwrite((char *)&tentry, sizeof(struct entry *), 1, fp);
	}
	hdr.volno = checkpt;
	hdr.maxino = maxino;
	hdr.entrytblsize = entrytblsize;
	hdr.stringsize = stroff;
	hdr.dumptime = dumptime;
	hdr.dumpdate = dumpdate;
	hdr.ntrec = ntrec;
	(void)fwrite((char *)&hdr, sizeof(struct symtableheader), 1, fp);
	if (ferror(fp)) {
		warn("fwrite");
		panic("output error to file %s writing symbol table\n",
		    filename);
	}
	(void)fclose(fp);
}

/*
 * Initialize a symbol table from a file
 */
void
initsymtable(char *filename)
{
	char *base;
	long tblsize;
	struct entry *ep;
	struct entry *baseep, *lep;
	struct symtableheader hdr;
	struct stat stbuf;
	long i;
	int fd;

	Vprintf(stdout, "Initialize symbol table.\n");
	if (filename == NULL) {
		entrytblsize = maxino / HASHFACTOR;
		entry = calloc(entrytblsize, sizeof(struct entry *));
		if (entry == NULL)
			panic("no memory for entry table\n");
		ep = addentry(".", ROOTINO, NODE);
		ep->e_flags |= NEW;
		return;
	}
	if ((fd = open(filename, O_RDONLY, 0)) < 0) {
		warn("open");
		panic("cannot open symbol table file %s\n", filename);
	}
	if (fstat(fd, &stbuf) < 0) {
		warn("stat");
		panic("cannot stat symbol table file %s\n", filename);
	}
	tblsize = stbuf.st_size - sizeof(struct symtableheader);
	base = calloc(tblsize, sizeof(char));
	if (base == NULL)
		panic("cannot allocate space for symbol table\n");
	if (read(fd, base, tblsize) < 0 ||
	    read(fd, &hdr, sizeof(struct symtableheader)) < 0) {
		warn("read");
		panic("cannot read symbol table file %s\n", filename);
	}
	close(fd);
	switch (command) {
	case 'r':
		/*
		 * For normal continuation, insure that we are using
		 * the next incremental tape
		 */
		if (hdr.dumpdate != dumptime)
			errx(1, "Incremental tape too %s",
			    (hdr.dumpdate < dumptime) ? "low" : "high");
		break;
	case 'R':
		/*
		 * For restart, insure that we are using the same tape
		 */
		curfile.action = SKIP;
		dumptime = hdr.dumptime;
		dumpdate = hdr.dumpdate;
		if (!bflag)
			newtapebuf(hdr.ntrec);
		getvol(hdr.volno);
		break;
	default:
		panic("initsymtable called from command %c\n", command);
		break;
	}
	maxino = hdr.maxino;
	entrytblsize = hdr.entrytblsize;
	entry = (struct entry **)
		(base + tblsize - (entrytblsize * sizeof(struct entry *)));
	baseep = (struct entry *)(base + hdr.stringsize - sizeof(struct entry));
	lep = (struct entry *)entry;
	for (i = 0; i < entrytblsize; i++) {
		if (entry[i] == NULL)
			continue;
		entry[i] = &baseep[(long)entry[i]];
	}
	for (ep = &baseep[1]; ep < lep; ep++) {
		ep->e_name = base + (long)ep->e_name;
		ep->e_parent = &baseep[(long)ep->e_parent];
		if (ep->e_sibling != NULL)
			ep->e_sibling = &baseep[(long)ep->e_sibling];
		if (ep->e_links != NULL)
			ep->e_links = &baseep[(long)ep->e_links];
		if (ep->e_entries != NULL)
			ep->e_entries = &baseep[(long)ep->e_entries];
		if (ep->e_next != NULL)
			ep->e_next = &baseep[(long)ep->e_next];
	}
}
@


1.21
log
@Do not leak symtab fd (if at fd limit might even prevent correct operation)
from Loganaden Velvindron
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.20 2013/04/24 13:46:29 deraadt Exp $	*/
a41 1
#include <sys/param.h>
d52 1
d141 1
a141 1
	char buf[MAXPATHLEN];
d191 1
a191 1
	static char namebuf[MAXPATHLEN];
d193 1
a193 1
	for (cp = &namebuf[MAXPATHLEN - 2]; cp > &namebuf[ep->e_namlen]; ) {
@


1.20
log
@pretty print bigger off_t
ok tedu otto
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.19 2011/06/27 23:40:57 tedu Exp $	*/
d556 1
@


1.19
log
@remove some useless casts. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.18 2009/10/27 23:59:34 deraadt Exp $	*/
d97 2
a98 1
		panic("addino: out of range %d\n", inum);
d119 2
a120 1
		panic("deleteino: out of range %d\n", inum);
d130 1
a130 1
	panic("deleteino: %d not found\n", inum);
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.17 2006/10/18 21:18:59 deraadt Exp $	*/
d193 1
a193 1
		memcpy(cp, ep->e_name, (long)ep->e_namlen);
d220 1
a220 1
		memset(np, 0, (long)sizeof(struct entry));
d222 1
a222 1
		np = (struct entry *)calloc(1, sizeof(struct entry));
d391 1
a391 1
		cp = malloc((unsigned)allocsize(len));
d467 1
a467 1
			memcpy(tep, ep, (long)sizeof(struct entry));
d530 2
a531 3
		entry = (struct entry **)
			calloc((unsigned)entrytblsize, sizeof(struct entry *));
		if (entry == (struct entry **)NULL)
d546 1
a546 1
	base = calloc((unsigned)tblsize, sizeof(char));
d549 2
a550 2
	if (read(fd, base, (int)tblsize) < 0 ||
	    read(fd, (char *)&hdr, sizeof(struct symtableheader)) < 0) {
@


1.17
log
@do not name FILE * variables "fd" since it is confusing
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.16 2005/11/15 07:02:35 miod Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)symtab.c	8.2 (Berkeley) 9/13/94";
#else
static const char rcsid[] = "$OpenBSD: symtab.c,v 1.16 2005/11/15 07:02:35 miod Exp $";
#endif
#endif /* not lint */
@


1.16
log
@More typos (especially indicies -> indices), checked with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.15 2005/06/14 19:46:05 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: symtab.c,v 1.15 2005/06/14 19:46:05 millert Exp $";
d445 1
a445 1
	FILE *fd;
d451 1
a451 1
	if ((fd = fopen(filename, "w")) == NULL) {
d456 1
a456 1
	clearerr(fd);
d465 1
a465 1
			       (int)allocsize(ep->e_namlen), fd);
d491 1
a491 1
			(void)fwrite((char *)tep, sizeof(struct entry), 1, fd);
d502 1
a502 1
		(void)fwrite((char *)&tentry, sizeof(struct entry *), 1, fd);
d511 2
a512 2
	(void)fwrite((char *)&hdr, sizeof(struct symtableheader), 1, fd);
	if (ferror(fd)) {
d517 1
a517 1
	(void)fclose(fd);
@


1.15
log
@Kill whiteout support.  OK deraadt@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.14 2004/07/17 02:14:33 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: symtab.c,v 1.14 2004/07/17 02:14:33 deraadt Exp $";
d458 1
a458 1
	 * Assign indicies to each entry
@


1.14
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.13 2003/11/08 19:17:28 jmc Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: symtab.c,v 1.13 2003/11/08 19:17:28 jmc Exp $";
d88 1
a88 1
	if (inum < WINO || inum >= maxino)
d104 1
a104 1
	if (inum < WINO || inum >= maxino)
d125 1
a125 1
	if (inum < WINO || inum >= maxino)
d461 1
a461 1
	for (i = WINO; i <= maxino; i++) {
d473 1
a473 1
	for (i = WINO; i <= maxino; i++) {
@


1.13
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.12 2003/07/29 18:38:36 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: symtab.c,v 1.12 2003/07/29 18:38:36 deraadt Exp $";
d84 1
a84 2
lookupino(inum)
	ino_t inum;
d100 1
a100 3
addino(inum, np)
	ino_t inum;
	struct entry *np;
d120 1
a120 2
deleteino(inum)
	ino_t inum;
d143 1
a143 2
lookupname(name)
	char *name;
d172 1
a172 2
lookupparent(name)
	char *name;
d194 1
a194 2
myname(ep)
	struct entry *ep;
d221 1
a221 4
addentry(name, inum, type)
	char *name;
	ino_t inum;
	int type;
d269 1
a269 2
freeentry(ep)
	struct entry *ep;
d312 1
a312 3
moveentry(ep, newname)
	struct entry *ep;
	char *newname;
d340 1
a340 2
removeentry(ep)
	struct entry *ep;
d385 1
a385 2
savename(name)
	char *name;
d412 1
a412 2
freename(name)
	char *name;
d439 1
a439 3
dumpsymtable(filename, checkpt)
	char *filename;
	long checkpt;
d524 1
a524 2
initsymtable(filename)
	char *filename;
@


1.12
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.11 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: symtab.c,v 1.11 2003/07/28 06:13:26 tedu Exp $";
d263 1
a263 1
			panic("link to non-existant name\n");
@


1.11
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.10 2003/06/02 20:06:16 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: symtab.c,v 1.10 2003/06/02 20:06:16 millert Exp $";
d431 1
a431 1
	
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.9 2003/04/26 02:57:35 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.9 2003/04/26 02:57:35 deraadt Exp $";
@


1.9
log
@string cleanup; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.8 2002/08/12 00:42:56 aaron Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.8 2002/08/12 00:42:56 aaron Exp $";
@


1.8
log
@Swap args to calloc(3) so they are in the correct order; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.7 2002/02/16 21:27:37 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.7 2002/02/16 21:27:37 millert Exp $";
d422 1
a422 1
	(void)strcpy(cp, name);
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.6 2001/11/05 07:39:17 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.6 2001/11/05 07:39:17 mpech Exp $";
d578 1
a578 1
	base = calloc(sizeof(char), (unsigned)tblsize);
@


1.6
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.5 1997/07/05 20:51:25 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.5 1997/07/05 20:51:25 millert Exp $";
d80 3
a82 3
static void		 addino __P((ino_t, struct entry *));
static struct entry	*lookupparent __P((char *));
static void		 removeentry __P((struct entry *));
@


1.5
log
@vprintf -> Vprintf and dprintf -> Dprintf to avoid confusion
Use err/errx and warn/warnx where it makes sense.
Some sprintf -> snprintf, strcpy -> strncpy, and strcat -> strncat.
Honor $TMPDIR (based on changes from NetBSD)
Use __progname not "restore" (we could be called as rrestore).
Some -Wall happiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.4 1997/02/09 18:55:16 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.4 1997/02/09 18:55:16 deraadt Exp $";
d91 1
a91 1
	register struct entry *ep;
d130 1
a130 1
	register struct entry *next;
d154 2
a155 2
	register struct entry *ep;
	register char *np, *cp;
d205 1
a205 1
	register struct entry *ep;
d207 1
a207 1
	register char *cp;
d237 1
a237 1
	register struct entry *np, *ep;
d284 1
a284 1
	register struct entry *ep;
d286 1
a286 1
	register struct entry *np;
d328 1
a328 1
	register struct entry *ep;
d358 1
a358 1
	register struct entry *ep;
d360 1
a360 1
	register struct entry *np;
d463 2
a464 2
	register struct entry *ep, *tep;
	register ino_t i;
d551 1
a551 1
	register struct entry *ep;
d555 1
a555 1
	register long i;
@


1.4
log
@unexploitable buf oflow, eivind@@freebsd
@
text
@d1 2
a2 2
/*	$OpenBSD: symtab.c,v 1.3 1996/12/04 01:41:53 deraadt Exp $	*/
/*	$NetBSD: symtab.c,v 1.9 1996/11/30 18:04:47 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.3 1996/12/04 01:41:53 deraadt Exp $";
d59 1
a59 1
#include <errno.h>
d379 1
a379 1
 * 
d422 1
a422 1
	(void) strcpy(cp, name);
d470 1
a470 1
	vprintf(stdout, "Check pointing the restore\n");
d474 1
a474 1
		fprintf(stderr, "fopen: %s\n", strerror(errno));
d476 1
a476 1
			filename);
d486 1
a486 1
			(void) fwrite(ep->e_name, sizeof(char),
d513 1
a513 1
			(void) fwrite((char *)tep, sizeof(struct entry), 1, fd);
d524 1
a524 1
		(void) fwrite((char *)&tentry, sizeof(struct entry *), 1, fd);
d533 1
a533 1
	(void) fwrite((char *)&hdr, sizeof(struct symtableheader), 1, fd);
d535 1
a535 1
		fprintf(stderr, "fwrite: %s\n", strerror(errno));
d537 1
a537 1
			filename);
d539 1
a539 1
	(void) fclose(fd);
d558 1
a558 1
	vprintf(stdout, "Initialize symbol table.\n");
d570 1
a570 1
		fprintf(stderr, "open: %s\n", strerror(errno));
d574 1
a574 1
		fprintf(stderr, "stat: %s\n", strerror(errno));
d583 1
a583 1
		fprintf(stderr, "read: %s\n", strerror(errno));
d592 3
a594 7
		if (hdr.dumpdate != dumptime) {
			if (hdr.dumpdate < dumptime)
				fprintf(stderr, "Incremental tape too low\n");
			else
				fprintf(stderr, "Incremental tape too high\n");
			exit(1);
		}
@


1.3
log
@64 bit patches, tih@@nhh.no
@
text
@d1 1
a1 1
/*	$OpenBSD: symtab.c,v 1.2 1996/06/23 14:32:19 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.2 1996/06/23 14:32:19 deraadt Exp $";
d160 2
a161 1
		for (np = buf; *cp != '/' && *cp != '\0'; )
d163 2
@


1.2
log
@update rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: symtab.c,v 1.8 1995/03/18 14:59:54 cgd Exp $	*/
/*	$NetBSD: symtab.c,v 1.8 1995/03/18 14:59:54 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: symtab.c,v 1.8 1995/03/18 14:59:54 cgd Exp $";
d443 3
a445 3
	long	volno;
	long	stringsize;
	long	entrytblsize;
d449 1
a449 1
	long	ntrec;
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: symtab.c,v 1.8 1995/03/18 14:59:54 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
