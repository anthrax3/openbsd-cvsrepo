head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.14
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.10
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.12
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.8
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.12
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.8
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.6
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.18
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2013.04.24.13.46.29;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.13.19.07.32;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.14.19.46.05;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.28.06.13.26;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.13.05.00.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.29.19.23.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	97.07.05.23.10.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.05.20.51.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.06.18.01.46.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.32.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@pretty print bigger off_t
ok tedu otto
@
text
@/*	$OpenBSD: restore.c,v 1.16 2009/10/27 23:59:34 deraadt Exp $	*/
/*	$NetBSD: restore.c,v 1.9 1997/06/18 07:10:16 lukem Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <ufs/ufs/dinode.h>

#include <stdio.h>
#include <string.h>

#include "restore.h"
#include "extern.h"

static char *keyval(int);

/*
 * This implements the 't' option.
 * List entries on the tape.
 */
long
listfile(char *name, ino_t ino, int type)
{
	long descend = hflag ? GOOD : FAIL;

	if (TSTINO(ino, dumpmap) == 0)
		return (descend);
	Vprintf(stdout, "%s", type == LEAF ? "leaf" : "dir ");
	fprintf(stdout, "%10llu\t%s\n", (unsigned long long)ino, name);
	return (descend);
}

/*
 * This implements the 'x' option.
 * Request that new entries be extracted.
 */
long
addfile(char *name, ino_t ino, int type)
{
	struct entry *ep;
	long descend = hflag ? GOOD : FAIL;
	char buf[100];

	if (TSTINO(ino, dumpmap) == 0) {
		Dprintf(stdout, "%s: not on the tape\n", name);
		return (descend);
	}
	if (!mflag) {
		(void)snprintf(buf, sizeof(buf), "./%llu",
		    (unsigned long long)ino);
		name = buf;
		if (type == NODE) {
			(void)genliteraldir(name, ino);
			return (descend);
		}
	}
	ep = lookupino(ino);
	if (ep != NULL) {
		if (strcmp(name, myname(ep)) == 0) {
			ep->e_flags |= NEW;
			return (descend);
		}
		type |= LINK;
	}
	ep = addentry(name, ino, type);
	if (type == NODE)
		newnode(ep);
	ep->e_flags |= NEW;
	return (descend);
}

/*
 * This is used by the 'i' option to undo previous requests made by addfile.
 * Delete entries from the request queue.
 */
/* ARGSUSED */
long
deletefile(char *name, ino_t ino, int type)
{
	long descend = hflag ? GOOD : FAIL;
	struct entry *ep;

	if (TSTINO(ino, dumpmap) == 0)
		return (descend);
	ep = lookupname(name);
	if (ep != NULL) {
		ep->e_flags &= ~NEW;
		ep->e_flags |= REMOVED;
		if (ep->e_type != NODE)
			freeentry(ep);
	}
	return (descend);
}

/*
 * The following four routines implement the incremental
 * restore algorithm. The first removes old entries, the second
 * does renames and calculates the extraction list, the third
 * cleans up link names missed by the first two, and the final
 * one deletes old directories.
 *
 * Directories cannot be immediately deleted, as they may have
 * other files in them which need to be moved out first. As
 * directories to be deleted are found, they are put on the
 * following deletion list. After all deletions and renames
 * are done, this list is actually deleted.
 */
static struct entry *removelist;

/*
 *	Remove unneeded leaves from the old tree.
 *	Remove directories from the lookup chains.
 */
void
removeoldleaves(void)
{
	struct entry *ep;
	ino_t i;

	Vprintf(stdout, "Mark entries to be removed.\n");
	for (i = ROOTINO + 1; i < maxino; i++) {
		ep = lookupino(i);
		if (ep == NULL)
			continue;
		if (TSTINO(i, usedinomap))
			continue;
		for ( ; ep != NULL; ep = ep->e_links) {
			Dprintf(stdout, "%s: REMOVE\n", myname(ep));
			if (ep->e_type == LEAF) {
				removeleaf(ep);
				freeentry(ep);
			} else {
				mktempname(ep);
				deleteino(ep->e_ino);
				ep->e_next = removelist;
				removelist = ep;
			}
		}
	}
}

/*
 *	For each directory entry on the incremental tape, determine which
 *	category it falls into as follows:
 *	KEEP - entries that are to be left alone.
 *	NEW - new entries to be added.
 *	EXTRACT - files that must be updated with new contents.
 *	LINK - new links to be added.
 *	Renames are done at the same time.
 */
long
nodeupdates(char *name, ino_t ino, int type)
{
	struct entry *ep, *np, *ip;
	long descend = GOOD;
	int lookuptype = 0;
	int key = 0;
		/* key values */
#		define ONTAPE	0x1	/* inode is on the tape */
#		define INOFND	0x2	/* inode already exists */
#		define NAMEFND	0x4	/* name already exists */
#		define MODECHG	0x8	/* mode of inode changed */

	/*
	 * This routine is called once for each element in the
	 * directory hierarchy, with a full path name.
	 * The "type" value is incorrectly specified as LEAF for
	 * directories that are not on the dump tape.
	 *
	 * Check to see if the file is on the tape.
	 */
	if (TSTINO(ino, dumpmap))
		key |= ONTAPE;
	/*
	 * Check to see if the name exists, and if the name is a link.
	 */
	np = lookupname(name);
	if (np != NULL) {
		key |= NAMEFND;
		ip = lookupino(np->e_ino);
		if (ip == NULL)
			panic("corrupted symbol table\n");
		if (ip != np)
			lookuptype = LINK;
	}
	/*
	 * Check to see if the inode exists, and if one of its links
	 * corresponds to the name (if one was found).
	 */
	ip = lookupino(ino);
	if (ip != NULL) {
		key |= INOFND;
		for (ep = ip->e_links; ep != NULL; ep = ep->e_links) {
			if (ep == np) {
				ip = ep;
				break;
			}
		}
	}
	/*
	 * If both a name and an inode are found, but they do not
	 * correspond to the same file, then both the inode that has
	 * been found and the inode corresponding to the name that
	 * has been found need to be renamed. The current pathname
	 * is the new name for the inode that has been found. Since
	 * all files to be deleted have already been removed, the
	 * named file is either a now unneeded link, or it must live
	 * under a new name in this dump level. If it is a link, it
	 * can be removed. If it is not a link, it is given a
	 * temporary name in anticipation that it will be renamed
	 * when it is later found by inode number.
	 */
	if (((key & (INOFND|NAMEFND)) == (INOFND|NAMEFND)) && ip != np) {
		if (lookuptype == LINK) {
			removeleaf(np);
			freeentry(np);
		} else {
			Dprintf(stdout, "name/inode conflict, mktempname %s\n",
				myname(np));
			mktempname(np);
		}
		np = NULL;
		key &= ~NAMEFND;
	}
	if ((key & ONTAPE) &&
	  (((key & INOFND) && ip->e_type != type) ||
	   ((key & NAMEFND) && np->e_type != type)))
		key |= MODECHG;

	/*
	 * Decide on the disposition of the file based on its flags.
	 * Note that we have already handled the case in which
	 * a name and inode are found that correspond to different files.
	 * Thus if both NAMEFND and INOFND are set then ip == np.
	 */
	switch (key) {

	/*
	 * A previously existing file has been found.
	 * Mark it as KEEP so that other links to the inode can be
	 * detected, and so that it will not be reclaimed by the search
	 * for unreferenced names.
	 */
	case INOFND|NAMEFND:
		ip->e_flags |= KEEP;
		Dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
			flagvalues(ip));
		break;

	/*
	 * A file on the tape has a name which is the same as a name
	 * corresponding to a different file in the previous dump.
	 * Since all files to be deleted have already been removed,
	 * this file is either a now unneeded link, or it must live
	 * under a new name in this dump level. If it is a link, it
	 * can simply be removed. If it is not a link, it is given a
	 * temporary name in anticipation that it will be renamed
	 * when it is later found by inode number (see INOFND case
	 * below). The entry is then treated as a new file.
	 */
	case ONTAPE|NAMEFND:
	case ONTAPE|NAMEFND|MODECHG:
		if (lookuptype == LINK) {
			removeleaf(np);
			freeentry(np);
		} else {
			mktempname(np);
		}
		/* fall through */

	/*
	 * A previously non-existent file.
	 * Add it to the file system, and request its extraction.
	 * If it is a directory, create it immediately.
	 * (Since the name is unused there can be no conflict)
	 */
	case ONTAPE:
		ep = addentry(name, ino, type);
		if (type == NODE)
			newnode(ep);
		ep->e_flags |= NEW|KEEP;
		Dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
			flagvalues(ep));
		break;

	/*
	 * A file with the same inode number, but a different
	 * name has been found. If the other name has not already
	 * been found (indicated by the KEEP flag, see above) then
	 * this must be a new name for the file, and it is renamed.
	 * If the other name has been found then this must be a
	 * link to the file. Hard links to directories are not
	 * permitted, and are either deleted or converted to
	 * symbolic links. Finally, if the file is on the tape,
	 * a request is made to extract it.
	 */
	case ONTAPE|INOFND:
		if (type == LEAF && (ip->e_flags & KEEP) == 0)
			ip->e_flags |= EXTRACT;
		/* fall through */
	case INOFND:
		if ((ip->e_flags & KEEP) == 0) {
			renameit(myname(ip), name);
			moveentry(ip, name);
			ip->e_flags |= KEEP;
			Dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
				flagvalues(ip));
			break;
		}
		if (ip->e_type == NODE) {
			descend = FAIL;
			fprintf(stderr,
				"deleted hard link %s to directory %s\n",
				name, myname(ip));
			break;
		}
		ep = addentry(name, ino, type|LINK);
		ep->e_flags |= NEW;
		Dprintf(stdout, "[%s] %s: %s|LINK\n", keyval(key), name,
			flagvalues(ep));
		break;

	/*
	 * A previously known file which is to be updated. If it is a link,
	 * then all names referring to the previous file must be removed
	 * so that the subset of them that remain can be recreated.
	 */
	case ONTAPE|INOFND|NAMEFND:
		if (lookuptype == LINK) {
			removeleaf(np);
			freeentry(np);
			ep = addentry(name, ino, type|LINK);
			if (type == NODE)
			        newnode(ep);
			ep->e_flags |= NEW|KEEP;
			Dprintf(stdout, "[%s] %s: %s|LINK\n", keyval(key), name,
				flagvalues(ep));
			break;
		}
		if (type == LEAF && lookuptype != LINK)
			np->e_flags |= EXTRACT;
		np->e_flags |= KEEP;
		Dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
			flagvalues(np));
		break;

	/*
	 * An inode is being reused in a completely different way.
	 * Normally an extract can simply do an "unlink" followed
	 * by a "creat". Here we must do effectively the same
	 * thing. The complications arise because we cannot really
	 * delete a directory since it may still contain files
	 * that we need to rename, so we delete it from the symbol
	 * table, and put it on the list to be deleted eventually.
	 * Conversely if a directory is to be created, it must be
	 * done immediately, rather than waiting until the
	 * extraction phase.
	 */
	case ONTAPE|INOFND|MODECHG:
	case ONTAPE|INOFND|NAMEFND|MODECHG:
		if (ip->e_flags & KEEP) {
			badentry(ip, "cannot KEEP and change modes");
			break;
		}
		if (ip->e_type == LEAF) {
			/* changing from leaf to node */
			for ( ; ip != NULL; ip = ip->e_links) {
				if (ip->e_type != LEAF)
					badentry(ip,
					   "NODE and LEAF links to same inode");
				removeleaf(ip);
				freeentry(ip);
			}
			ip = addentry(name, ino, type);
			newnode(ip);
		} else {
			/* changing from node to leaf */
			if ((ip->e_flags & TMPNAME) == 0)
				mktempname(ip);
			deleteino(ip->e_ino);
			ip->e_next = removelist;
			removelist = ip;
			ip = addentry(name, ino, type);
		}
		ip->e_flags |= NEW|KEEP;
		Dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
			flagvalues(ip));
		break;

	/*
	 * A hard link to a diirectory that has been removed.
	 * Ignore it.
	 */
	case NAMEFND:
		Dprintf(stdout, "[%s] %s: Extraneous name\n", keyval(key),
			name);
		descend = FAIL;
		break;

	/*
	 * If we find a directory entry for a file that is not on
	 * the tape, then we must have found a file that was created
	 * while the dump was in progress. Since we have no contents
	 * for it, we discard the name knowing that it will be on the
	 * next incremental tape.
	 */
	case 0:
		fprintf(stderr, "%s: (inode %llu) not found on tape\n",
			name, (unsigned long long)ino);
		break;

	/*
	 * If any of these arise, something is grievously wrong with
	 * the current state of the symbol table.
	 */
	case INOFND|NAMEFND|MODECHG:
	case NAMEFND|MODECHG:
	case INOFND|MODECHG:
		fprintf(stderr, "[%s] %s: inconsistent state\n", keyval(key),
			name);
		break;

	/*
	 * These states "cannot" arise for any state of the symbol table.
	 */
	case ONTAPE|MODECHG:
	case MODECHG:
	default:
		panic("[%s] %s: impossible state\n", keyval(key), name);
		break;
	}
	return (descend);
}

/*
 * Calculate the active flags in a key.
 */
static char *
keyval(int key)
{
	static char keybuf[32];

	(void)strlcpy(keybuf, "|NIL", sizeof keybuf);
	keybuf[0] = '\0';
	if (key & ONTAPE)
		(void)strlcat(keybuf, "|ONTAPE", sizeof keybuf);
	if (key & INOFND)
		(void)strlcat(keybuf, "|INOFND", sizeof keybuf);
	if (key & NAMEFND)
		(void)strlcat(keybuf, "|NAMEFND", sizeof keybuf);
	if (key & MODECHG)
		(void)strlcat(keybuf, "|MODECHG", sizeof keybuf);
	return (&keybuf[1]);
}

/*
 * Find unreferenced link names.
 */
void
findunreflinks(void)
{
	struct entry *ep, *np;
	ino_t i;

	Vprintf(stdout, "Find unreferenced names.\n");
	for (i = ROOTINO; i < maxino; i++) {
		ep = lookupino(i);
		if (ep == NULL || ep->e_type == LEAF || TSTINO(i, dumpmap) == 0)
			continue;
		for (np = ep->e_entries; np != NULL; np = np->e_sibling) {
			if (np->e_flags == 0) {
				Dprintf(stdout,
				    "%s: remove unreferenced name\n",
				    myname(np));
				removeleaf(np);
				freeentry(np);
			}
		}
	}
	/*
	 * Any leaves remaining in removed directories is unreferenced.
	 */
	for (ep = removelist; ep != NULL; ep = ep->e_next) {
		for (np = ep->e_entries; np != NULL; np = np->e_sibling) {
			if (np->e_type == LEAF) {
				if (np->e_flags != 0)
					badentry(np, "unreferenced with flags");
				Dprintf(stdout,
				    "%s: remove unreferenced name\n",
				    myname(np));
				removeleaf(np);
				freeentry(np);
			}
		}
	}
}

/*
 * Remove old nodes (directories).
 * Note that this routine runs in O(N*D) where:
 *	N is the number of directory entries to be removed.
 *	D is the maximum depth of the tree.
 * If N == D this can be quite slow. If the list were
 * topologically sorted, the deletion could be done in
 * time O(N).
 */
void
removeoldnodes(void)
{
	struct entry *ep, **prev;
	long change;

	Vprintf(stdout, "Remove old nodes (directories).\n");
	do	{
		change = 0;
		prev = &removelist;
		for (ep = removelist; ep != NULL; ep = *prev) {
			if (ep->e_entries != NULL) {
				prev = &ep->e_next;
				continue;
			}
			*prev = ep->e_next;
			removenode(ep);
			freeentry(ep);
			change++;
		}
	} while (change);
	for (ep = removelist; ep != NULL; ep = ep->e_next)
		badentry(ep, "cannot remove, non-empty");
}

/*
 * This is the routine used to extract files for the 'r' command.
 * Extract new leaves.
 */
void
createleaves(char *symtabfile)
{
	struct entry *ep;
	ino_t first;
	long curvol;

	if (command == 'R') {
		Vprintf(stdout, "Continue extraction of new leaves\n");
	} else {
		Vprintf(stdout, "Extract new leaves.\n");
		dumpsymtable(symtabfile, volno);
	}
	first = lowerbnd(ROOTINO);
	curvol = volno;
	while (curfile.ino < maxino) {
		first = lowerbnd(first);
		/*
		 * If the next available file is not the one which we
		 * expect then we have missed one or more files. Since
		 * we do not request files that were not on the tape,
		 * the lost files must have been due to a tape read error,
		 * or a file that was removed while the dump was in progress.
		 */
		while (first < curfile.ino) {
			ep = lookupino(first);
			if (ep == NULL)
				panic("%llu: bad first\n",
			    (unsigned long long)first);
			fprintf(stderr, "%s: not found on tape\n", myname(ep));
			ep->e_flags &= ~(NEW|EXTRACT);
			first = lowerbnd(first);
		}
		/*
		 * If we find files on the tape that have no corresponding
		 * directory entries, then we must have found a file that
		 * was created while the dump was in progress. Since we have
		 * no name for it, we discard it knowing that it will be
		 * on the next incremental tape.
		 */
		if (first != curfile.ino) {
			fprintf(stderr, "expected next file %llu, got %llu\n",
			    (unsigned long long)first,
			    (unsigned long long)curfile.ino);
			skipfile();
			goto next;
		}
		ep = lookupino(curfile.ino);
		if (ep == NULL)
			panic("unknown file on tape\n");
		if ((ep->e_flags & (NEW|EXTRACT)) == 0)
			badentry(ep, "unexpected file on tape");
		/*
		 * If the file is to be extracted, then the old file must
		 * be removed since its type may change from one leaf type
		 * to another (eg "file" to "character special").
		 */
		if ((ep->e_flags & EXTRACT) != 0) {
			removeleaf(ep);
			ep->e_flags &= ~REMOVED;
		}
		(void)extractfile(myname(ep));
		ep->e_flags &= ~(NEW|EXTRACT);
		/*
		 * We checkpoint the restore after every tape reel, so
		 * as to simplify the amount of work re quired by the
		 * 'R' command.
		 */
	next:
		if (curvol != volno) {
			dumpsymtable(symtabfile, volno);
			skipmaps();
			curvol = volno;
		}
	}
}

/*
 * This is the routine used to extract files for the 'x' and 'i' commands.
 * Efficiently extract a subset of the files on a tape.
 */
void
createfiles(void)
{
	ino_t first, next, last;
	struct entry *ep;
	long curvol;

	Vprintf(stdout, "Extract requested files\n");
	curfile.action = SKIP;
	getvol((long)1);
	skipmaps();
	skipdirs();
	first = lowerbnd(ROOTINO);
	last = upperbnd(maxino - 1);
	for (;;) {
		first = lowerbnd(first);
		last = upperbnd(last);
		/*
		 * Check to see if any files remain to be extracted
		 */
		if (first > last)
			return;
		/*
		 * Reject any volumes with inodes greater
		 * than the last one needed
		 */
		while (curfile.ino > last) {
			curfile.action = SKIP;
			getvol((long)0);
			skipmaps();
			skipdirs();
		}
		/*
		 * Decide on the next inode needed.
		 * Skip across the inodes until it is found
		 * or an out of order volume change is encountered
		 */
		next = lowerbnd(curfile.ino);
		do	{
			curvol = volno;
			while (next > curfile.ino && volno == curvol)
				skipfile();
			skipmaps();
			skipdirs();
		} while (volno == curvol + 1);
		/*
		 * If volume change out of order occurred the
		 * current state must be recalculated
		 */
		if (volno != curvol)
			continue;
		/*
		 * If the current inode is greater than the one we were
		 * looking for then we missed the one we were looking for.
		 * Since we only attempt to extract files listed in the
		 * dump map, the lost files must have been due to a tape
		 * read error, or a file that was removed while the dump
		 * was in progress. Thus we report all requested files
		 * between the one we were looking for, and the one we
		 * found as missing, and delete their request flags.
		 */
		while (next < curfile.ino) {
			ep = lookupino(next);
			if (ep == NULL)
				panic("corrupted symbol table\n");
			fprintf(stderr, "%s: not found on tape\n", myname(ep));
			ep->e_flags &= ~NEW;
			next = lowerbnd(next);
		}
		/*
		 * The current inode is the one that we are looking for,
		 * so extract it per its requested name.
		 */
		if (next == curfile.ino && next <= last) {
			ep = lookupino(next);
			if (ep == NULL)
				panic("corrupted symbol table\n");
			(void)extractfile(myname(ep));
			ep->e_flags &= ~NEW;
			if (volno != curvol)
				skipmaps();
		}
	}
}

/*
 * Add links.
 */
void
createlinks(void)
{
	struct entry *np, *ep;
	ino_t i;
	char name[BUFSIZ];

	Vprintf(stdout, "Add links\n");
	for (i = ROOTINO; i < maxino; i++) {
		ep = lookupino(i);
		if (ep == NULL)
			continue;
		for (np = ep->e_links; np != NULL; np = np->e_links) {
			if ((np->e_flags & NEW) == 0)
				continue;
			(void)strlcpy(name, myname(ep), sizeof name);
			if (ep->e_type == NODE) {
				(void)linkit(name, myname(np), SYMLINK);
			} else {
				(void)linkit(name, myname(np), HARDLINK);
			}
			np->e_flags &= ~NEW;
		}
	}
}

/*
 * Check the symbol table.
 * We do this to insure that all the requested work was done, and
 * that no temporary names remain.
 */
void
checkrestore(void)
{
	struct entry *ep;
	ino_t i;

	Vprintf(stdout, "Check the symbol table.\n");
	for (i = ROOTINO; i < maxino; i++) {
		for (ep = lookupino(i); ep != NULL; ep = ep->e_links) {
			ep->e_flags &= ~KEEP;
			if (ep->e_type == NODE)
				ep->e_flags &= ~(NEW|EXISTED);
			if (ep->e_flags != 0)
				badentry(ep, "incomplete operations");
		}
	}
}

/*
 * Compare with the directory structure on the tape
 * A paranoid check that things are as they should be.
 */
long
verifyfile(char *name, ino_t ino, int type)
{
	struct entry *np, *ep;
	long descend = GOOD;

	ep = lookupname(name);
	if (ep == NULL) {
		fprintf(stderr, "Warning: missing name %s\n", name);
		return (FAIL);
	}
	np = lookupino(ino);
	if (np != ep)
		descend = FAIL;
	for ( ; np != NULL; np = np->e_links)
		if (np == ep)
			break;
	if (np == NULL)
		panic("missing inumber %llu\n", (unsigned long long)ino);
	if (ep->e_type == LEAF && type != LEAF)
		badentry(ep, "type should be LEAF");
	return (descend);
}
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.15 2007/05/13 19:07:32 millert Exp $	*/
d58 1
a58 1
	fprintf(stdout, "%10d\t%s\n", ino, name);
d78 2
a79 1
		(void)snprintf(buf, sizeof(buf), "./%u", ino);
d437 2
a438 2
		fprintf(stderr, "%s: (inode %d) not found on tape\n",
			name, ino);
d592 2
a593 1
				panic("%d: bad first\n", first);
d606 3
a608 2
			fprintf(stderr, "expected next file %d, got %d\n",
				first, curfile.ino);
d805 1
a805 1
		panic("missing inumber %d\n", ino);
@


1.15
log
@g/c unused vars
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.14 2005/06/14 19:46:05 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)restore.c	8.3 (Berkeley) 9/13/94";
#else
static const char rcsid[] = "$OpenBSD: restore.c,v 1.14 2005/06/14 19:46:05 millert Exp $";
#endif
#endif /* not lint */
@


1.14
log
@Kill whiteout support.  OK deraadt@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.13 2004/07/17 02:14:33 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: restore.c,v 1.13 2004/07/17 02:14:33 deraadt Exp $";
d153 2
a154 2
	struct entry *ep, *nextep;
	ino_t i, mydirino;
@


1.13
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.12 2003/07/29 18:38:36 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: restore.c,v 1.12 2003/07/29 18:38:36 deraadt Exp $";
a84 2
	if (ino == WINO && command == 'i' && !vflag)
		return (descend);
a146 1
 *	Remove invalid whiteouts from the old tree.
a156 16
	if ((ep = lookupino(WINO))) {
		Vprintf(stdout, "Delete whiteouts\n");
		for ( ; ep != NULL; ep = nextep) {
			nextep = ep->e_links;
			mydirino = ep->e_parent->e_ino;
			/*
			 * We remove all whiteouts that are in directories
			 * that have been removed or that have been dumped.
			 */
			if (TSTINO(mydirino, usedinomap) &&
			    !TSTINO(mydirino, dumpmap))
				continue;
			delwhiteout(ep);
			freeentry(ep);
		}
	}
a745 9
	if ((ep = lookupino(WINO))) {
		Vprintf(stdout, "Add whiteouts\n");
		for ( ; ep != NULL; ep = ep->e_links) {
			if ((ep->e_flags & NEW) == 0)
				continue;
			(void)addwhiteout(myname(ep));
			ep->e_flags &= ~NEW;
		}
	}
d777 1
a777 1
	for (i = WINO; i < maxino; i++) {
@


1.12
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.11 2003/07/28 06:13:26 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: restore.c,v 1.11 2003/07/28 06:13:26 tedu Exp $";
d59 1
a59 4
listfile(name, ino, type)
	char *name;
	ino_t ino;
	int type;
d75 1
a75 4
addfile(name, ino, type)
	char *name;
	ino_t ino;
	int type;
d116 1
a116 4
deletefile(name, ino, type)
	char *name;
	ino_t ino;
	int type;
d154 1
a154 1
removeoldleaves()
d207 1
a207 4
nodeupdates(name, ino, type)
	char *name;
	ino_t ino;
	int type;
d494 1
a494 2
keyval(key)
	int key;
d515 1
a515 1
findunreflinks()
d563 1
a563 1
removeoldnodes()
d592 1
a592 2
createleaves(symtabfile)
	char *symtabfile;
d671 1
a671 1
createfiles()
d759 1
a759 1
createlinks()
d799 1
a799 1
checkrestore()
d821 1
a821 4
verifyfile(name, ino, type)
	char *name;
	ino_t ino;
	int type;
@


1.11
log
@rcsid should say openbsd.  make 'em const while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.10 2003/06/02 20:06:16 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: restore.c,v 1.10 2003/06/02 20:06:16 millert Exp $";
d498 1
a498 1
	}	
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.9 2003/03/13 05:00:44 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.9 2003/03/13 05:00:44 deraadt Exp $";
@


1.9
log
@more strlcpy; most from Hans-Joerg.Hoexer@@yerbouti.franken.de, a bit from me
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.8 2002/05/29 19:23:34 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.8 2002/05/29 19:23:34 deraadt Exp $";
@


1.8
log
@more strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.7 2002/02/16 21:27:37 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.7 2002/02/16 21:27:37 millert Exp $";
d515 1
a515 1
	(void)strcpy(keybuf, "|NIL");
d800 1
a800 1
			(void)strcpy(name, myname(ep));
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.6 2001/11/05 07:39:17 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.6 2001/11/05 07:39:17 mpech Exp $";
d518 1
a518 1
		(void)strcat(keybuf, "|ONTAPE");
d520 1
a520 1
		(void)strcat(keybuf, "|INOFND");
d522 1
a522 1
		(void)strcat(keybuf, "|NAMEFND");
d524 1
a524 1
		(void)strcat(keybuf, "|MODECHG");
@


1.6
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.5 1997/07/05 23:10:21 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.5 1997/07/05 23:10:21 deraadt Exp $";
d56 1
a56 1
static char *keyval __P((int));
@


1.5
log
@NULL vs 0 confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.4 1997/07/05 20:51:24 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.4 1997/07/05 20:51:24 millert Exp $";
d87 1
a87 1
	register struct entry *ep;
d169 2
a170 2
	register struct entry *ep, *nextep;
	register ino_t i, mydirino;
d225 1
a225 1
	register struct entry *ep, *np, *ip;
d534 2
a535 2
	register struct entry *ep, *np;
	register ino_t i;
d582 1
a582 1
	register struct entry *ep, **prev;
d612 1
a612 1
	register struct entry *ep;
d691 2
a692 2
	register ino_t first, next, last;
	register struct entry *ep;
d779 2
a780 2
	register struct entry *np, *ep;
	register ino_t i;
d819 2
a820 2
	register struct entry *ep;
	register ino_t i;
@


1.4
log
@vprintf -> Vprintf and dprintf -> Dprintf to avoid confusion
Use err/errx and warn/warnx where it makes sense.
Some sprintf -> snprintf, strcpy -> strncpy, and strcat -> strncat.
Honor $TMPDIR (based on changes from NetBSD)
Use __progname not "restore" (we could be called as rrestore).
Some -Wall happiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.3 1997/06/18 01:46:40 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.3 1997/06/18 01:46:40 millert Exp $";
d478 1
a478 1
	case NULL:
d828 1
a828 1
			if (ep->e_flags != NULL)
@


1.3
log
@Remove all links for an inode when "changing from leaf to node".
From Guy Harris <guy@@netapp.com> via Kirk McKusick <mckusick@@McKusick.COM>.
@
text
@d1 2
a2 2
/*	$OpenBSD: restore.c,v 1.2 1996/06/23 14:32:17 deraadt Exp $	*/
/*	$NetBSD: restore.c,v 1.6 1995/03/18 14:59:51 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.2 1996/06/23 14:32:17 deraadt Exp $";
d72 1
a72 1
	vprintf(stdout, "%s", type == LEAF ? "leaf" : "dir ");
d92 1
a92 1
		dprintf(stdout, "%s: not on the tape\n", name);
d98 1
a98 1
		(void) sprintf(buf, "./%u", ino);
d101 1
a101 1
			(void) genliteraldir(name, ino);
d146 1
a146 1
/* 
d155 1
a155 1
 * directories to be deleted are found, they are put on the 
d172 3
a174 3
	vprintf(stdout, "Mark entries to be removed.\n");
	if (ep = lookupino(WINO)) {
		vprintf(stdout, "Delete whiteouts\n");
d196 1
a196 1
			dprintf(stdout, "%s: REMOVE\n", myname(ep));
d236 1
a236 1
	 * This routine is called once for each element in the 
d289 1
a289 1
			dprintf(stdout, "name/inode conflict, mktempname %s\n",
d317 1
a317 1
		dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
d353 1
a353 1
		dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
d377 1
a377 1
			dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
d390 1
a390 1
		dprintf(stdout, "[%s] %s: %s|LINK\n", keyval(key), name,
d407 1
a407 1
			dprintf(stdout, "[%s] %s: %s|LINK\n", keyval(key), name,
d414 1
a414 1
		dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
d427 1
a427 1
	 * done immediately, rather than waiting until the 
d440 2
a441 1
					badentry(ip, "NODE and LEAF links to same inode");
d457 1
a457 1
		dprintf(stdout, "[%s] %s: %s\n", keyval(key), name,
d466 1
a466 1
		dprintf(stdout, "[%s] %s: Extraneous name\n", keyval(key),
d515 1
a515 1
	(void) strcpy(keybuf, "|NIL");
d518 1
a518 1
		(void) strcat(keybuf, "|ONTAPE");
d520 1
a520 1
		(void) strcat(keybuf, "|INOFND");
d522 1
a522 1
		(void) strcat(keybuf, "|NAMEFND");
d524 1
a524 1
		(void) strcat(keybuf, "|MODECHG");
d537 1
a537 1
	vprintf(stdout, "Find unreferenced names.\n");
d544 1
a544 1
				dprintf(stdout,
d560 1
a560 1
				dprintf(stdout,
d585 1
a585 1
	vprintf(stdout, "Remove old nodes (directories).\n");
d617 1
a617 1
		vprintf(stdout, "Continue extraction of new leaves\n");
d619 1
a619 1
		vprintf(stdout, "Extract new leaves.\n");
d644 1
a644 1
		 * was created while the dump was in progress. Since we have 
d668 1
a668 1
		(void) extractfile(myname(ep));
d695 1
a695 1
	vprintf(stdout, "Extract requested files\n");
d765 1
a765 1
			(void) extractfile(myname(ep));
d783 2
a784 2
	if (ep = lookupino(WINO)) {
		vprintf(stdout, "Add whiteouts\n");
d788 1
a788 1
			(void) addwhiteout(myname(ep));
d792 1
a792 1
	vprintf(stdout, "Add links\n");
d800 1
a800 1
			(void) strcpy(name, myname(ep));
d802 1
a802 1
				(void) linkit(name, myname(np), SYMLINK);
d804 1
a804 1
				(void) linkit(name, myname(np), HARDLINK);
d822 1
a822 1
	vprintf(stdout, "Check the symbol table.\n");
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: restore.c,v 1.6 1995/03/18 14:59:51 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: restore.c,v 1.6 1995/03/18 14:59:51 cgd Exp $";
d438 6
a443 2
			removeleaf(ip);
			freeentry(ip);
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: restore.c,v 1.6 1995/03/18 14:59:51 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
