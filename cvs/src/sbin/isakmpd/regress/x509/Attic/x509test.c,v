head	1.23;
access;
symbols
	OPENBSD_3_7:1.22.0.8
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2005.04.08.17.21.42;	author cloder;	state dead;
branches;
next	1.22;

1.22
date	2003.06.03.14.39.51;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.02.17.09.29;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.10.18.08.59;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.03.16.27.41;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.05.12.37.05;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.11.15.53.23;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.27.12.03.39;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.27.11.24.44;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.26.12.35.47;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.26.11.08.25;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.19.18.54.59;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.10.01.14.10.45;	author niklas;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	99.08.26.22.30.46;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.07.17.21.54.38;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.07.07.22.14.31;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.04.19.21.22.49;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.03.02.15.27.36;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.04.08.29;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.15.01.04.38;	author niklas;	state dead;
branches;
next	1.2;

1.2
date	98.11.15.00.44.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.50;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.50;	author niklas;	state Exp;
branches;
next	;

1.10.6.1
date	2001.05.08.12.45.28;	author ho;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Moved regression tests to src/regress/sbin/isakmpd where they belong.
@
text
@/*	$OpenBSD: x509test.c,v 1.22 2003/06/03 14:39:51 ho Exp $	*/
/*	$EOM: x509test.c,v 1.9 2000/12/21 15:24:25 ho Exp $	*/

/*
 * Copyright (c) 1998, 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 1999, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

/*
 * This program takes a certificate generated by ssleay and a key pair
 * from rsakeygen. It reads the IP address from certificate.txt and
 * includes this as subject alt name extension into the certifcate.
 * The result gets written as new certificate that can be used by
 * isakmpd.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "conf.h"
#include "ipsec_num.h"
#include "isakmp_fld.h"
#include "libcrypto.h"
#include "log.h"
#include "math_mp.h"
#include "x509.h"

static int x509_check_subjectaltname (u_char *, u_int, X509 *);

u_int32_t file_sz;

#if 0
/* XXX Currently unused.  */
static u_int8_t *
open_file (char *name)
{
  int fd;
  struct stat st;
  u_int8_t *addr;

  if (stat (name, &st) == -1)
    log_fatal ("stat (\"%s\", &st)", name);
  file_sz = st.st_size;
  fd = open (name, O_RDONLY);
  if (fd == -1)
    log_fatal ("open (\"%s\", O_RDONLY)", name);
  addr = mmap (0, file_sz, PROT_READ | PROT_WRITE, MAP_FILE | MAP_PRIVATE,
	       fd, 0);
  if (addr == MAP_FAILED)
    log_fatal ("mmap (0, %d, PROT_READ | PROT_WRITE, MAP_FILE | MAP_PRIVATE,"
	       "%d, 0)", file_sz, fd);
  close (fd);

  return addr;
}
#endif

/*
 * Check that a certificate has a subjectAltName and that it matches our ID.
 */
static int
x509_check_subjectaltname (u_char *id, u_int id_len, X509 *scert)
{
  u_int8_t *altname;
  u_int32_t altlen;
  int type, idtype, ret;

  type = x509_cert_subjectaltname (scert, &altname, &altlen);
  if (!type)
    {
      log_print ("x509_check_subjectaltname: can't access subjectAltName");
      return 0;
    }

  /*
   * Now that we have the X509 certicate in native form, get the
   * subjectAltName extension and verify that it matches our ID.
   */

  /* XXX Get type of ID.  */
  idtype = id[0];
  id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
  id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

  ret = 0;
  switch (idtype)
    {
    case IPSEC_ID_IPV4_ADDR:
      if (type == X509v3_IP_ADDR)
	ret = 1;
      break;
    case IPSEC_ID_FQDN:
      if (type == X509v3_DNS_NAME)
	ret = 1;
      break;
    case IPSEC_ID_USER_FQDN:
      if (type == X509v3_RFC_NAME)
	ret = 1;
      break;
    default:
      ret = 0;
      break;
    }

  if (!ret)
    {
      LOG_DBG ((LOG_CRYPTO, 50,
		"x509_check_subjectaltname: "
		"our ID type (%d) does not match X509 cert ID type (%d)",
		idtype, type));
      return 0;
    }

  if (altlen != id_len || memcmp (altname, id, id_len) != 0)
    {
      LOG_DBG ((LOG_CRYPTO, 50,
		"x509_check_subjectaltname: "
		"our ID does not match X509 cert ID"));
      return 0;
    }

  return 1;
}

int
main (int argc, char *argv[])
{
  RSA *pub_key, *priv_key;
  X509 *cert;
  BIO *certfile, *keyfile;
  EVP_PKEY *pkey_pub;
  u_char ipaddr[6];
  struct in_addr saddr;
  char enc[256], dec[256];
  u_int8_t idpayload[8];
  int err, len;

  if (argc < 3 || argc > 4)
    {
      fprintf (stderr, "usage: x509test private-key certificate ip-address\n");
      exit (1);
    }

  /*
   * X509_verify will fail, as will all other functions that call
   * EVP_get_digest_byname.
   */

  libcrypto_init ();

  printf ("Reading private key %s\n", argv[1]);
  keyfile = BIO_new (BIO_s_file ());
  if (BIO_read_filename (keyfile, argv[1]) == -1)
    {
      perror ("read");
      exit (1);
    }
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
  priv_key = PEM_read_bio_RSAPrivateKey (keyfile, NULL, NULL, NULL);
#else
  priv_key = PEM_read_bio_RSAPrivateKey (keyfile, NULL, NULL);
#endif
  BIO_free (keyfile);
  if (priv_key == NULL)
    {
      printf("PEM_read_bio_RSAPrivateKey () failed\n");
      exit (1);
    }

  /* Use a certificate created by ssleay.  */
  printf ("Reading ssleay created certificate %s\n", argv[2]);
  certfile = BIO_new (BIO_s_file ());
  if (BIO_read_filename (certfile, argv[2]) == -1)
    {
      perror ("read");
      exit (1);
    }
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
  cert = PEM_read_bio_X509 (certfile, NULL, NULL, NULL);
#else
  cert = PEM_read_bio_X509 (certfile, NULL, NULL);
#endif
  BIO_free (certfile);
  if (cert == NULL)
    {
      printf("PEM_read_bio_X509 () failed\n");
      exit (1);
    }

  pkey_pub = X509_get_pubkey (cert);
  /* XXX Violation of the interface?  */
  pub_key = pkey_pub->pkey.rsa;
  if (pub_key == NULL)
    {
      exit (1);
    }

  printf ("Testing RSA keys: ");

  err = 0;
  strlcpy (dec, "Eine kleine Testmeldung", 256);
  if ((len = RSA_private_encrypt (strlen (dec), dec, enc, priv_key,
				  RSA_PKCS1_PADDING)) == -1)

    printf ("SIGN FAILED ");
  else
    err = RSA_public_decrypt (len, enc, dec, pub_key, RSA_PKCS1_PADDING);

  if (err == -1 || strcmp (dec, "Eine kleine Testmeldung"))
    printf ("SIGN/VERIFY FAILED");
  else
    printf ("OKAY");
  printf ("\n");


  printf ("Validate SIGNED: ");
  err = X509_verify (cert, pkey_pub);
  printf ("X509 verify: %d ", err);
  if (err == -1)
    printf ("FAILED ");
  else
    printf ("OKAY ");
  printf ("\n");

  if (argc == 4)
    {
      printf ("Verifying extension: ");
      if (inet_aton (argv[3], &saddr) == 0)
	{
	  printf ("inet_aton () failed\n");
	  exit (1);
	}

      saddr.s_addr = htonl (saddr.s_addr);
      ipaddr[0] = 0x87;
      ipaddr[1] = 0x04;
      ipaddr[2] = saddr.s_addr >> 24;
      ipaddr[3] = (saddr.s_addr >> 16) & 0xff;
      ipaddr[4] = (saddr.s_addr >> 8) & 0xff;
      ipaddr[5] = saddr.s_addr & 0xff;
      bzero (idpayload, sizeof idpayload);
      idpayload[0] = IPSEC_ID_IPV4_ADDR;
      bcopy (ipaddr + 2, idpayload + 4, 4);

      if (!x509_check_subjectaltname (idpayload, sizeof idpayload, cert))
	printf("FAILED ");
      else
	printf("OKAY ");
      printf ("\n");
    }

  return 1;
}
@


1.22
log
@Remove clauses 3 and 4. Approved by Niklas Hallqvist and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.21 2002/08/02 17:09:29 aaron Exp $	*/
@


1.21
log
@Check inet_aton() failure with == 0, not == -1; millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.20 2002/06/10 18:08:59 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.20
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.19 2002/06/09 08:13:07 todd Exp $	*/
d271 1
a271 1
      if (inet_aton (argv[3], &saddr) == -1)
@


1.19
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.18 2002/01/03 16:27:41 ho Exp $	*/
a193 8
#ifndef USE_LIBCRYPTO
  if (!libcrypto)
    {
      fprintf (stderr, "I did not find the X.509 support, giving up...");
      exit (1);
    }
#endif

d195 2
a196 2
  keyfile = LC (BIO_new, (LC (BIO_s_file, ())));
  if (LC (BIO_read_filename, (keyfile, argv[1])) == -1)
d202 1
a202 1
  priv_key = LC (PEM_read_bio_RSAPrivateKey, (keyfile, NULL, NULL, NULL));
d204 1
a204 1
  priv_key = LC (PEM_read_bio_RSAPrivateKey, (keyfile, NULL, NULL));
d206 1
a206 1
  LC (BIO_free, (keyfile));
d215 2
a216 2
  certfile = LC (BIO_new, (LC (BIO_s_file, ())));
  if (LC (BIO_read_filename, (certfile, argv[2])) == -1)
d222 1
a222 1
  cert = LC (PEM_read_bio_X509, (certfile, NULL, NULL, NULL));
d224 1
a224 1
  cert = LC (PEM_read_bio_X509, (certfile, NULL, NULL));
d226 1
a226 1
  LC (BIO_free, (certfile));
d233 1
a233 1
  pkey_pub = LC (X509_get_pubkey, (cert));
d245 2
a246 2
  if ((len = LC (RSA_private_encrypt, (strlen (dec), dec, enc, priv_key,
				       RSA_PKCS1_PADDING))) == -1)
d250 1
a250 1
    err = LC (RSA_public_decrypt, (len, enc, dec, pub_key, RSA_PKCS1_PADDING));
d260 1
a260 1
  err = LC (X509_verify, (cert, pkey_pub));
@


1.18
log
@str[n]{cpy,cat} -> strl{cpy,cat}, sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.17 2001/07/05 12:37:05 ho Exp $	*/
d118 1
a118 1
  /* 
d132 1
a132 1
      if (type == X509v3_IP_ADDR) 
d136 1
a136 1
      if (type == X509v3_DNS_NAME) 
d140 1
a140 1
      if (type == X509v3_RFC_NAME) 
d204 1
a204 1
  if (LC (BIO_read_filename, (keyfile, argv[1])) == -1) 
d224 1
a224 1
  if (LC (BIO_read_filename, (certfile, argv[2])) == -1) 
d235 1
a235 1
  if (cert == NULL) 
d255 1
a255 1
  
d265 1
a265 1
  
@


1.17
log
@Add prototypes and some other various cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.16 2001/05/11 15:53:23 art Exp $	*/
d252 1
a252 1
  strcpy (dec, "Eine kleine Testmeldung");
@


1.16
log
@MAP_FAILED, not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.15 2001/01/27 12:03:39 niklas Exp $	*/
d71 2
d75 3
a77 1
u_int8_t *
d99 1
d104 1
a104 1
int
@


1.15
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.14 2001/01/27 11:24:44 niklas Exp $	*/
d88 1
a88 1
  if (!addr)
@


1.14
log
@Cleanup the MP_FLAVOUR situation.  Still needs work.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.13 2001/01/26 12:35:47 niklas Exp $	*/
d6 2
a7 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
@


1.13
log
@There is no need to check the subjectAltName anymore, since we are in fact
looking up the certificate via the name.  The lookup method already
guarantees a match.  It is also a problem to look at the subjectAltName
should we have got the certificate with no such name in it.  Prodded by
mickey@@ although I solved the problem in a different way.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.12 2001/01/26 11:08:25 niklas Exp $	*/
a61 4
#if MP_FLAVOUR == MP_FLAVOUR_GMP
#  include <gmp.h>
#endif

d63 2
d67 1
a67 2
#include "ipsec_num.h"
#include "isakmp_fld.h"
@


1.12
log
@apps/certpatch/certpatch.c: Merge with EOM 1.11
regress/rsakeygen/rsakeygen.c: Merge with EOM 1.10
regress/x509/x509test.c: Merge with EOM 1.9

author: ho
Only include <gmp.h> with MP_FLAVOUR_GMP.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.11 2000/12/19 18:54:59 mickey Exp $	*/
d70 1
d96 67
@


1.11
log
@gmp is gone, make it build again
@
text
@d1 2
a2 2
/*	$OpenBSD: x509test.c,v 1.10 1999/10/01 14:10:45 niklas Exp $	*/
/*	$EOM: x509test.c,v 1.8 1999/09/30 13:40:39 niklas Exp $	*/
d61 4
@


1.10
log
@regress/x509/x509test.c: Merge with EOM 1.8
README.PKI: Merge with EOM 1.7

author: niklas
OpenSSL 0.9.4 support
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.9 1999/08/26 22:30:46 niklas Exp $	*/
a52 1
#include <gmp.h>
@


1.10.6.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509test.c,v 1.15 2001/01/27 12:03:39 niklas Exp $	*/
/*	$EOM: x509test.c,v 1.9 2000/12/21 15:24:25 ho Exp $	*/
d6 1
a6 2
 * Copyright (c) 1999, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
d53 1
a63 2
#include "ipsec_num.h"
#include "isakmp_fld.h"
d66 1
a66 1
#include "math_mp.h"
a91 67
}

/*
 * Check that a certificate has a subjectAltName and that it matches our ID.
 */
int
x509_check_subjectaltname (u_char *id, u_int id_len, X509 *scert)
{
  u_int8_t *altname;
  u_int32_t altlen;
  int type, idtype, ret;

  type = x509_cert_subjectaltname (scert, &altname, &altlen);
  if (!type)
    {
      log_print ("x509_check_subjectaltname: can't access subjectAltName");
      return 0;
    }

  /* 
   * Now that we have the X509 certicate in native form, get the
   * subjectAltName extension and verify that it matches our ID.
   */

  /* XXX Get type of ID.  */
  idtype = id[0];
  id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
  id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

  ret = 0;
  switch (idtype)
    {
    case IPSEC_ID_IPV4_ADDR:
      if (type == X509v3_IP_ADDR) 
	ret = 1;
      break;
    case IPSEC_ID_FQDN:
      if (type == X509v3_DNS_NAME) 
	ret = 1;
      break;
    case IPSEC_ID_USER_FQDN:
      if (type == X509v3_RFC_NAME) 
	ret = 1;
      break;
    default:
      ret = 0;
      break;
    }

  if (!ret)
    {
      LOG_DBG ((LOG_CRYPTO, 50,
		"x509_check_subjectaltname: "
		"our ID type (%d) does not match X509 cert ID type (%d)",
		idtype, type));
      return 0;
    }

  if (altlen != id_len || memcmp (altname, id, id_len) != 0)
    {
      LOG_DBG ((LOG_CRYPTO, 50,
		"x509_check_subjectaltname: "
		"our ID does not match X509 cert ID"));
      return 0;
    }

  return 1;
@


1.9
log
@regress/rsakeygen/rsakeygen.c: Merge with EOM 1.9
regress/x509/x509test.c: Merge with EOM 1.7
DESIGN-NOTES: Merge with EOM 1.48
README.PKI: Merge with EOM 1.6
TO-DO: Merge with EOM 1.44
cert.c: Merge with EOM 1.12

author: niklas
Add support for dynamic loading of optional facilities, libcrypto first.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509test.c,v 1.8 1999/07/17 21:54:38 niklas Exp $	*/
/*	$EOM: x509test.c,v 1.7 1999/08/12 22:34:31 niklas Exp $	*/
d135 3
d139 1
d155 3
d159 1
@


1.8
log
@regress/rsakeygen/Makefile: Merge with EOM 1.4
regress/rsakeygen/rsakeygen.c: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.6
regress/x509/x509test.c: Merge with EOM 1.6
regress/Makefile: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.6
samples/VPN-west.conf: Merge with EOM 1.6
samples/singlehost-east.conf: Merge with EOM 1.3
samples/singlehost-west.conf: Merge with EOM 1.3
sysdep/openbsd/Makefile.sysdep: Merge with EOM 1.5
x509.h: Merge with EOM 1.6
x509.c: Merge with EOM 1.17
DESIGN-NOTES: Merge with EOM 1.46
Makefile: Merge with EOM 1.55
cert.c: Merge with EOM 1.11
cert.h: Merge with EOM 1.6
exchange.c: Merge with EOM 1.109
exchange.h: Merge with EOM 1.26
ike_auth.c: Merge with EOM 1.32
ike_phase_1.c: Merge with EOM 1.7
init.c: Merge with EOM 1.16
isakmpd.conf.5: Merge with EOM 1.27
README.PKI: Merge with EOM 1.1

author: niklas
From Niels Provos, edited by me: certificate support using SSLeay
@
text
@d1 2
a2 2
/*	$OpenBSD: x509test.c,v 1.7 1999/07/07 22:14:31 niklas Exp $	*/
/*	$EOM: x509test.c,v 1.6 1999/07/17 20:44:14 niklas Exp $	*/
a62 4
#include <ssl/rsa.h>
#include <ssl/x509.h>
#include <ssl/pem.h>

d64 1
d118 9
a126 1
  SSLeay_add_all_algorithms ();
d129 2
a130 2
  keyfile = BIO_new (BIO_s_file ());
  if (BIO_read_filename (keyfile, argv[1]) == -1) 
d135 2
a136 2
  priv_key = PEM_read_bio_RSAPrivateKey (keyfile, NULL, NULL);
  BIO_free (keyfile);
d145 2
a146 2
  certfile = BIO_new (BIO_s_file ());
  if (BIO_read_filename (certfile, argv[2]) == -1) 
d151 2
a152 2
  cert = PEM_read_bio_X509 (certfile, NULL, NULL);
  BIO_free (certfile);
d159 1
a159 1
  pkey_pub = X509_get_pubkey (cert);
d171 2
a172 2
  if ((len = RSA_private_encrypt (strlen (dec), dec, enc, priv_key,
				  RSA_PKCS1_PADDING)) == -1)
d176 1
a176 1
    err = RSA_public_decrypt (len, enc, dec, pub_key, RSA_PKCS1_PADDING);
d186 1
a186 1
  err = X509_verify (cert, pkey_pub);
@


1.7
log
@Merge with EOM 1.5

author: niklas
typo
@
text
@d1 2
a2 2
/*	$OpenBSD: x509test.c,v 1.6 1999/04/19 21:22:49 niklas Exp $	*/
/*	$EOM: x509test.c,v 1.5 1999/06/10 13:39:20 niklas Exp $	*/
d5 2
a6 1
 * Copyright (c) 1998 Niels Provos.  All rights reserved.
d38 8
d55 1
d59 8
d68 2
a69 3
#include "asn.h"
#include "asn_useful.h"
#include "pkcs.h"
a70 1
#include "log.h"
a73 5
#define LINECOL(x,y)   (x) = strsep (&(y), "\n\r"); \
  (x) = strchr ((x), ':') + 1; \
  while (isspace((x)[0])) (x)++; \


d98 1
a98 1
main (void)
d100 9
a108 6
  struct rsa_private_key priv;
  struct x509_certificate cert;
  FILE *fd;
  char *p, *p2;
  u_int8_t *addr, *asn;
  u_int32_t asnlen, len;
d110 1
a110 2
  addr = open_file ("isakmpd_key");
  if (!pkcs_private_key_from_asn (&priv, addr, asn_get_len (addr)))
d112 1
a112 1
      munmap (addr, file_sz);
a114 1
  munmap (addr, file_sz);
d116 17
a132 2
  addr = open_file ("isakmpd_key.pub");
  if (!pkcs_public_key_from_asn (&cert.key, addr, asn_get_len (addr)))
d134 1
a134 1
      munmap (addr, file_sz);
a136 1
  munmap (addr, file_sz);
d138 15
a152 5
  cert.signaturetype = strdup (ASN_ID_MD5WITHRSAENC);
  cert.issuer1.type = strdup (ASN_ID_COUNTRY_NAME);
  cert.issuer2.type = strdup (ASN_ID_ORGANIZATION_NAME);
  cert.subject1.type = strdup (ASN_ID_COUNTRY_NAME);
  cert.subject2.type = strdup (ASN_ID_ORGANIZATION_NAME);
d154 7
a160 2
  addr = open_file ("certificate.txt");
  p = addr;
d162 1
a162 9
  LINECOL (p2, p); cert.version = atoi (p2);
  LINECOL (p2, p); cert.serialnumber = atoi (p2);
  LINECOL (p2, p); cert.issuer1.val = strdup (p2);
  LINECOL (p2, p); cert.issuer2.val = strdup (p2);
  LINECOL (p2, p); cert.subject1.val = strdup (p2);
  LINECOL (p2, p); cert.subject2.val = strdup (p2);
  LINECOL (p2, p); cert.start = strdup (p2);
  LINECOL (p2, p); cert.end = strdup (p2);
  munmap (addr, file_sz);
d164 6
a169 10
  /* XXX Just put any IP number in there.  */
  cert.extension.type = strdup (ASN_ID_SUBJECT_ALT_NAME);
  cert.extension.val = p = malloc (8);
  /* XXX This could also be encoded as norm_type, but time is lacking.  */
  p[0] = 0x30; p[1] = 0x06; p[2] = 0x87; p[3] = 0x04;
  memset (p + 4, 0, 4);

  printf ("Encoding Certificate: ");
  if (!x509_encode_certificate(&cert, &asn, &asnlen))
    printf ("FAILED ");
d171 1
a171 2
    printf ("OKAY ");
  printf ("\n");
d173 2
a174 3
  printf ("Creating Signature: ");
  if (!x509_create_signed (asn, asnlen, &priv, &addr, &len))
    printf ("FAILED ");
d176 1
a176 1
    printf ("OKAY ");
d178 1
d181 3
a183 1
  if (!x509_validate_signed (addr, len, &cert.key, &asn, &asnlen))
d189 26
a214 5
  fd = fopen ("cert.asn", "w");
  fwrite (addr, len, 1, fd);
  fclose (fd);

  free (addr);
@


1.6
log
@./regress/x509/x509test.c: Merge with EOM 1.4
./dh.h: Merge with EOM 1.4
./math_ec2n.c: Merge with EOM 1.8
./crypto.c: Merge with EOM 1.25
./ike_quick_mode.c: Merge with EOM 1.82
./math_group.c: Merge with EOM 1.16
./math_ec2n.h: Merge with EOM 1.4

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509test.c,v 1.5 1999/03/02 15:27:36 niklas Exp $	*/
/*	$EOM: x509test.c,v 1.4 1999/04/17 23:20:45 niklas Exp $	*/
d138 1
a138 1
  printf ("Encoding Certificiate: ");
@


1.5
log
@RCS tags
@
text
@d1 2
a2 2
/*	$OpenBSD: x509test.c,v 1.4 1999/02/26 04:08:29 niklas Exp $	*/
/*	$EOM: x509test.c,v 1.3 1998/08/21 14:33:12 provos Exp $	*/
d77 1
a77 1
		    fd, 0);
d131 1
a131 1
  /* XXX - just put any IP number in there - XXX */
d134 1
a134 1
  /* XXX - this could also be encoded as norm_type, but time is lacking */
@


1.4
log
@Merge from the Ericsson repository
| revision 1.3
| date: 1998/08/21 14:33:12;  author: provos;  state: Exp;  lines: +8 -1
| encode IP into cert. many XXX.
| ----------------------------
| revision 1.2
| date: 1998/08/20 14:09:05;  author: provos;  state: Exp;  lines: +3 -3
| rename pkcs_{set,get}_{public,private}_key to something more understandable,
| it confused me, so i suppose it will also confuse others.
| ----------------------------
| revision 1.1
| date: 1998/08/11 20:29:16;  author: provos;  state: Exp;
| add a tool for generating x509 certificates
| =============================================================================
@
text
@d1 2
a2 1
/*	$Id: x509test.c,v 1.3 1998/08/21 14:33:12 provos Exp $	*/
@


1.3
log
@Not clear if we want this
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.2 1998/11/15 00:44:12 niklas Exp $	*/
@


1.2
log
@openBSD RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: x509test.c,v 1.1.1.1 1998/11/15 00:03:50 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: x509test.c,v 1.3 1998/08/21 14:33:12 provos Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
