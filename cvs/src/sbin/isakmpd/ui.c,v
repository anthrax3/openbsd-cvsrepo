head	1.56;
access;
symbols
	OPENBSD_6_1:1.56.0.10
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.56.0.8
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.56.0.4
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.56.0.6
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.54.0.28
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.54.0.26
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.54.0.22
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.20
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.18
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.16
	OPENBSD_5_0:1.54.0.14
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.54.0.12
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.54.0.10
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.54.0.6
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.54.0.8
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.54.0.4
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.54.0.2
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.53.0.4
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.53.0.2
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.52.0.2
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.45.0.2
	OPENBSD_3_8_BASE:1.45
	OPENBSD_3_7:1.42.0.4
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.42.0.2
	OPENBSD_3_6_BASE:1.42
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2014.12.01.23.05.18;	author tedu;	state Exp;
branches;
next	1.55;
commitid	wn8W9QPb4QyEeIkN;

1.55
date	2014.10.09.02.38.56;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	lHB12E9VkXKsWY0B;

1.54
date	2008.06.10.22.14.02;	author bluhm;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.30.11.24.49;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.28.09.27.09;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2006.10.18.21.18.59;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.19.10.48.41;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2006.09.01.00.24.06;	author mpf;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.14.23.25.11;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2005.09.23.14.44.03;	author hshoexer;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.08.19.40.03;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.25.00.58.39;	author hshoexer;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.13.06.56.34;	author ho;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.06.16.12.08;	author ho;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.13.13.57.51;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.27.11.16.24;	author ho;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.01.07.44.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.19.04.00.59;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.17.21.48.06;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.11.01.43.54;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.10.03.34.51;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.03.16.17.17;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.22.11.10.45;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.05.08.18.37;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.24.13.53.02;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.06.14.37.12;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.30.12.16.44;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.09.21.21.57;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.07.06.57.25;	author niklas;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.05.02.14.37.00;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.07.22.10.30;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.07.22.06.44;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.08.08.42.38;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.25.17.23.42;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.08.26.22.29.57;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.08.05.22.41.08;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.06.02.06.29.55;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.05.01.20.43.46;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.04.19.21.10.21;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.03.24.15.00.17;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.02.26.03.52.22;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.12.21.01.02.27;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2001.05.08.12.45.26;	author ho;	state Exp;
branches;
next	;


desc
@@


1.56
log
@memcpy abort found an overlap. from dsp at 2f30. ok deraadt
@
text
@/* $OpenBSD: ui.c,v 1.55 2014/10/09 02:38:56 deraadt Exp $	 */
/* $EOM: ui.c,v 1.43 2000/10/05 09:25:12 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001, 2002 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include "conf.h"
#include "connection.h"
#include "doi.h"
#include "exchange.h"
#include "init.h"
#include "isakmp.h"
#include "log.h"
#include "monitor.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "ui.h"
#include "util.h"

#define BUF_SZ 256

/* from isakmpd.c */
void		 daemon_shutdown_now(int);

/* Report all SA configuration information. */
void		 ui_report_sa(char *);

static FILE	*ui_open_result(void);

char		*ui_fifo = FIFO;
int		 ui_socket;
struct event	*ui_cr_event = NULL;
int		 ui_daemon_passive = 0;

/* Create and open the FIFO used for user control.  */
void
ui_init(void)
{
	struct stat     st;

	/* -f- means control messages comes in via stdin.  */
	if (strcmp(ui_fifo, "-") == 0) {
		ui_socket = 0;
		return;
	}

	/* Don't overwrite a file, i.e '-f /etc/isakmpd/isakmpd.conf'.  */
	if (lstat(ui_fifo, &st) == 0) {
		if (S_ISREG(st.st_mode)) {
			errno = EEXIST;
			log_fatal("ui_init: could not create FIFO \"%s\"",
			    ui_fifo);
		}
	}

	/* No need to know about errors.  */
	unlink(ui_fifo);
	if (mkfifo(ui_fifo, 0600) == -1)
		log_fatal("ui_init: mkfifo (\"%s\", 0600) failed", ui_fifo);

	ui_socket = open(ui_fifo, O_RDWR | O_NONBLOCK, 0);
	if (ui_socket == -1)
		log_fatal("ui_init: open (\"%s\", O_RDWR | O_NONBLOCK, 0) "
		    "failed", ui_fifo);
}

/*
 * Setup a phase 2 connection.
 * XXX Maybe phase 1 works too, but teardown won't work then, fix?
 */
static void
ui_connect(char *cmd)
{
	char	name[201];

	if (sscanf(cmd, "c %200s", name) != 1) {
		log_print("ui_connect: command \"%s\" malformed", cmd);
		return;
	}
	LOG_DBG((LOG_UI, 10, "ui_connect: setup connection \"%s\"", name));
	connection_setup(name);
}

/* Tear down a connection, can be phase 1 or 2.  */
static void
ui_teardown(char *cmd)
{
	struct sockaddr_in	 addr;
	struct sockaddr_in6	 addr6;
	struct sa		*sa;
	int			 phase;
	char			 name[201];

	/* If no phase is given, we default to phase 2. */
	phase = 2;
	if (sscanf(cmd, "t main %200s", name) == 1)
		phase = 1;
	else if (sscanf(cmd, "t quick %200s", name) == 1)
		phase = 2;
	else if (sscanf(cmd, "t %200s", name) != 1) {
		log_print("ui_teardown: command \"%s\" malformed", cmd);
		return;
	}
	LOG_DBG((LOG_UI, 10, "ui_teardown: teardown connection \"%s\", "
	    "phase %d", name, phase));

	bzero(&addr, sizeof(addr));
	bzero(&addr6, sizeof(addr6));

	if (inet_pton(AF_INET, name, &addr.sin_addr) == 1) {
		addr.sin_len = sizeof(addr);
		addr.sin_family = AF_INET;

		while ((sa = sa_lookup_by_peer((struct sockaddr *)&addr,
		    SA_LEN((struct sockaddr *)&addr), phase)) != 0) {
			if (sa->name)
				connection_teardown(sa->name);
			sa_delete(sa, 1);
		}
	} else if (inet_pton(AF_INET6, name, &addr6.sin6_addr) == 1) {
		addr6.sin6_len = sizeof(addr6);
		addr6.sin6_family = AF_INET6;

		while ((sa = sa_lookup_by_peer((struct sockaddr *)&addr6,
		    SA_LEN((struct sockaddr *)&addr6), phase)) != 0) {
			if (sa->name)
				connection_teardown(sa->name);
			sa_delete(sa, 1);
		}
	} else {
		if (phase == 2)
			connection_teardown(name);
		while ((sa = sa_lookup_by_name(name, phase)) != 0)
			sa_delete(sa, 1);
	}
}

/* Tear down all phase 2 connections.  */
static void
ui_teardown_all(char *cmd)
{
	/* Skip 'cmd' as arg. */
	sa_teardown_all();
}

static void
ui_conn_reinit_event(void *v)
{
	/*
	 * This event is required for isakmpd to reinitialize the connection
	 * and passive-connection lists. Otherwise a change to the
	 * "[Phase 2]:Connections" tag will not have any effect.
	 */
	connection_reinit();

	ui_cr_event = NULL;
}

static void
ui_conn_reinit(void)
{
	struct timeval tv;

	if (ui_cr_event)
		timer_remove_event(ui_cr_event);

	gettimeofday(&tv, 0);
	tv.tv_sec += 5;

	ui_cr_event = timer_add_event("ui_conn_reinit", ui_conn_reinit_event,
	    0, &tv);
	if (!ui_cr_event)
		log_print("ui_conn_reinit: timer_add_event() failed. "
		    "Connections will not be updated.");
}

/*
 * Call the configuration API.
 * XXX Error handling!  How to do multi-line transactions?
 */
static void
ui_config(char *cmd)
{
	struct conf_list *vlist;
	struct conf_list_node *vnode;
	char	 subcmd[201], section[201], tag[201], value[201], tmp[201];
	char	*v, *nv;
	int	 trans = 0, items, skip = 0, ret;
	FILE	*fp;

	if (sscanf(cmd, "C %200s", subcmd) != 1)
		goto fail;

	if (strcasecmp(subcmd, "get") == 0) {
		if (sscanf(cmd, "C %*s [%200[^]]]:%200s", section, tag) != 2)
			goto fail;
		v = conf_get_str(section, tag);
		fp = ui_open_result();
		if (fp) {
			if (v)
				fprintf(fp, "%s\n", v);
			fclose(fp);
		}
		LOG_DBG((LOG_UI, 30, "ui_config: \"%s\"", cmd));
		return;
	}

	trans = conf_begin();
	if (strcasecmp(subcmd, "set") == 0) {
		items = sscanf(cmd, "C %*s [%200[^]]]:%200[^=]=%200s %200s",
		    section, tag, value, tmp);
		if (!(items == 3 || items == 4))
			goto fail;
		conf_set(trans, section, tag, value, items == 4 ? 1 : 0, 0);
		if (strcasecmp(section, "Phase 2") == 0 &&
		    (strcasecmp(tag, "Connections") == 0 ||
			strcasecmp(tag, "Passive-connections") == 0))
			ui_conn_reinit();
	} else if (strcasecmp(subcmd, "add") == 0) {
		items = sscanf(cmd, "C %*s [%200[^]]]:%200[^=]=%200s %200s",
		    section, tag, value, tmp);
		if (!(items == 3 || items == 4))
			goto fail;
		v = conf_get_str(section, tag);
		if (!v)
			conf_set(trans, section, tag, value, 1, 0);
		else {
			vlist = conf_get_list(section, tag);
			if (vlist) {
				for (vnode = TAILQ_FIRST(&vlist->fields);
				    vnode;
				    vnode = TAILQ_NEXT(vnode, link)) {
					if (strcmp(vnode->field, value) == 0) {
						skip = 1;
						break;
					}
				}
				conf_free_list(vlist);
			}
			/* Add the new value to the end of the 'v' list.  */
			if (skip == 0) {
				if (asprintf(&nv,
				    v[strlen(v) - 1] == ',' ? "%s%s" : "%s,%s",
				    v, value) == -1) {
					log_error("ui_config: malloc() failed");
					if (trans)
						conf_end(trans, 0);
					return;
				}
				conf_set(trans, section, tag, nv, 1, 0);
				free(nv);
			}
		}
		if (strcasecmp(section, "Phase 2") == 0 &&
		    (strcasecmp(tag, "Connections") == 0 ||
			strcasecmp(tag, "Passive-connections") == 0))
			ui_conn_reinit();
	} else if (strcasecmp(subcmd, "rmv") == 0) {
		items = sscanf(cmd, "C %*s [%200[^]]]:%200[^=]=%200s %200s",
		    section, tag, value, tmp);
		if (!(items == 3 || items == 4))
			goto fail;
		vlist = conf_get_list(section, tag);
		if (vlist) {
			nv = v = NULL;
			for (vnode = TAILQ_FIRST(&vlist->fields);
			    vnode;
			    vnode = TAILQ_NEXT(vnode, link)) {
				if (strcmp(vnode->field, value) == 0)
					continue;
				ret = v ?
				    asprintf(&nv, "%s,%s", v, vnode->field) :
				    asprintf(&nv, "%s", vnode->field);
				free(v);
				if (ret == -1) {
					log_error("ui_config: malloc() failed");
					if (trans)
						conf_end(trans, 0);
					return;
				}
				v = nv;
			}
			conf_free_list(vlist);
			if (nv) {
				conf_set(trans, section, tag, nv, 1, 0);
				free(nv);
			} else {
				conf_remove(trans, section, tag);
			}
		}
		if (strcasecmp(section, "Phase 2") == 0 &&
		    (strcasecmp(tag, "Connections") == 0 ||
			strcasecmp(tag, "Passive-connections") == 0))
			ui_conn_reinit();
	} else if (strcasecmp(subcmd, "rm") == 0) {
		if (sscanf(cmd, "C %*s [%200[^]]]:%200s", section, tag) != 2)
			goto fail;
		conf_remove(trans, section, tag);
	} else if (strcasecmp(subcmd, "rms") == 0) {
		if (sscanf(cmd, "C %*s [%200[^]]]", section) != 1)
			goto fail;
		conf_remove_section(trans, section);
	} else
		goto fail;

	LOG_DBG((LOG_UI, 30, "ui_config: \"%s\"", cmd));
	conf_end(trans, 1);
	return;

fail:
	if (trans)
		conf_end(trans, 0);
	log_print("ui_config: command \"%s\" malformed", cmd);
}

static void
ui_delete(char *cmd)
{
	char            cookies_str[ISAKMP_HDR_COOKIES_LEN * 2 + 1];
	char            message_id_str[ISAKMP_HDR_MESSAGE_ID_LEN * 2 + 1];
	u_int8_t        cookies[ISAKMP_HDR_COOKIES_LEN];
	u_int8_t        message_id_buf[ISAKMP_HDR_MESSAGE_ID_LEN];
	u_int8_t       *message_id = message_id_buf;
	struct sa      *sa;

	if (sscanf(cmd, "d %32s %8s", cookies_str, message_id_str) != 2) {
		log_print("ui_delete: command \"%s\" malformed", cmd);
		return;
	}
	if (strcmp(message_id_str, "-") == 0)
		message_id = 0;

	if (hex2raw(cookies_str, cookies, ISAKMP_HDR_COOKIES_LEN) == -1 ||
	    (message_id && hex2raw(message_id_str, message_id_buf,
	    ISAKMP_HDR_MESSAGE_ID_LEN) == -1)) {
		log_print("ui_delete: command \"%s\" has bad arguments", cmd);
		return;
	}
	sa = sa_lookup(cookies, message_id);
	if (!sa) {
		log_print("ui_delete: command \"%s\" found no SA", cmd);
		return;
	}
	LOG_DBG((LOG_UI, 20,
	    "ui_delete: deleting SA for cookie \"%s\" msgid \"%s\"",
	    cookies_str, message_id_str));
	sa_delete(sa, 1);
}

/* Parse the debug command found in CMD.  */
static void
ui_debug(char *cmd)
{
	int             cls, level;
	char            subcmd[3];

	if (sscanf(cmd, "D %d %d", &cls, &level) == 2) {
		log_debug_cmd(cls, level);
		return;
	} else if (sscanf(cmd, "D %2s %d", subcmd, &level) == 2) {
		switch (subcmd[0]) {
		case 'A':
			for (cls = 0; cls < LOG_ENDCLASS; cls++)
				log_debug_cmd(cls, level);
			return;
		}
	} else if (sscanf(cmd, "D %2s", subcmd) == 1) {
		switch (subcmd[0]) {
		case 'T':
			log_debug_toggle();
			return;
		}
	}
	log_print("ui_debug: command \"%s\" malformed", cmd);
}

static void
ui_packetlog(char *cmd)
{
	char	subcmd[201];

	if (sscanf(cmd, "p %200s", subcmd) != 1)
		goto fail;

	if (strncasecmp(subcmd, "on=", 3) == 0) {
		/* Start capture to a new file.  */
		if (subcmd[strlen(subcmd) - 1] == '\n')
			subcmd[strlen(subcmd) - 1] = 0;
		log_packet_restart(subcmd + 3);
	} else if (strcasecmp(subcmd, "on") == 0)
		log_packet_restart(NULL);
	else if (strcasecmp(subcmd, "off") == 0)
		log_packet_stop();
	return;

fail:
	log_print("ui_packetlog: command \"%s\" malformed", cmd);
}

static void
ui_shutdown_daemon(char *cmd)
{
	if (strlen(cmd) == 1) {
		log_print("ui_shutdown_daemon: received shutdown command");
		daemon_shutdown_now(0);
	} else
		log_print("ui_shutdown_daemon: command \"%s\" malformed", cmd);
}

/* Report SAs and ongoing exchanges.  */
void
ui_report(char *cmd)
{
	/* XXX Skip 'cmd' as arg? */
	sa_report();
	exchange_report();
	transport_report();
	connection_report();
	timer_report();
	conf_report();
}

/* Report all SA configuration information.  */
void
ui_report_sa(char *cmd)
{
	FILE *fp = ui_open_result();

	/* Skip 'cmd' as arg? */
	if (!fp)
		return;

	sa_report_all(fp);

	fclose(fp);
}

static void
ui_setmode(char *cmd)
{
	char	arg[11];

	if (sscanf(cmd, "M %10s", arg) != 1)
		goto fail;
	if (strncmp(arg, "active", 6) == 0) {
		if (ui_daemon_passive) 
			LOG_DBG((LOG_UI, 20,
			    "ui_setmode: switching to active mode"));
		ui_daemon_passive = 0;
	} else if (strncmp(arg, "passive", 7) == 0) {
		if (!ui_daemon_passive) 
			LOG_DBG((LOG_UI, 20,
			    "ui_setmode: switching to passive mode"));
		ui_daemon_passive = 1;
	} else
		goto fail;
	return;
	
  fail:
	log_print("ui_setmode: command \"%s\" malformed", cmd);
}


/*
 * Call the relevant command handler based on the first character of the
 * line (the command).
 */
static void
ui_handle_command(char *line)
{
	/* Find out what one-letter command was sent.  */
	switch (line[0]) {
	case 'c':
		ui_connect(line);
		break;

	case 'C':
		ui_config(line);
		break;

	case 'd':
		ui_delete(line);
		break;

	case 'D':
		ui_debug(line);
		break;

	case 'M':
		ui_setmode(line);
		break;

	case 'p':
		ui_packetlog(line);
		break;

	case 'Q':
		ui_shutdown_daemon(line);
		break;

	case 'R':
		reinit();
		break;

	case 'S':
		ui_report_sa(line);
		break;

	case 'r':
		ui_report(line);
		break;

	case 't':
		ui_teardown(line);
		break;

	case 'T':
		ui_teardown_all(line);
		break;

	default:
		log_print("ui_handle_messages: unrecognized command: '%c'",
		    line[0]);
	}
}

/*
 * A half-complex implementation of reading from a file descriptor
 * line by line without resorting to stdio which apparently have
 * troubles with non-blocking fifos.
 */
void
ui_handler(void)
{
	static char    *buf = 0;
	static char    *p;
	static size_t   sz;
	static size_t   resid;
	ssize_t         n;
	char           *new_buf;

	/* If no buffer, set it up.  */
	if (!buf) {
		sz = BUF_SZ;
		buf = malloc(sz);
		if (!buf) {
			log_print("ui_handler: malloc (%lu) failed",
			    (unsigned long)sz);
			return;
		}
		p = buf;
		resid = sz;
	}
	/* If no place left in the buffer reallocate twice as large.  */
	if (!resid) {
		new_buf = reallocarray(buf, sz, 2);
		if (!new_buf) {
			log_print("ui_handler: realloc (%p, %lu) failed", buf,
			    (unsigned long)sz * 2);
			free(buf);
			buf = 0;
			return;
		}
		buf = new_buf;
		p = buf + sz;
		resid = sz;
		sz *= 2;
	}
	n = read(ui_socket, p, resid);
	if (n == -1) {
		log_error("ui_handler: read (%d, %p, %lu)", ui_socket, p,
		    (unsigned long)resid);
		return;
	}
	if (!n)
		return;
	resid -= n;
	while (n--) {
		/*
		 * When we find a newline, cut off the line and feed it to the
		 * command processor.  Then move the rest up-front.
		 */
		if (*p == '\n') {
			*p = '\0';
			ui_handle_command(buf);
			memmove(buf, p + 1, n);
			p = buf;
			resid = sz - n;
			continue;
		}
		p++;
	}
}

static FILE *
ui_open_result(void)
{
	FILE *fp = monitor_fopen(RESULT_FILE, "w");

	if (!fp)
		log_error("ui_open_result: fopen() failed");
	return fp;
}
@


1.55
log
@obvious reallocarray() conversions
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.54 2008/06/10 22:14:02 bluhm Exp $	 */
d624 1
a624 1
			memcpy(buf, p + 1, n);
@


1.54
log
@Arguments to fifo commands were limited to 80 bytes.  That is too
short for IPv6.  Increase the buffer size from 80 to 200 where
appropriate.  For the M command a buffer for 10 bytes is sufficient.
ok hshoexer@@ mpf@@ grunk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.53 2007/04/16 13:01:39 moritz Exp $	 */
d594 1
a594 1
		new_buf = realloc(buf, sz * 2);
@


1.53
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.52 2006/11/30 11:24:49 markus Exp $	 */
d112 1
a112 1
	char	name[81];
d114 1
a114 1
	if (sscanf(cmd, "c %80s", name) != 1) {
d130 1
a130 1
	char            	 name[81];
d134 1
a134 1
	if (sscanf(cmd, "t main %80s", name) == 1)
d136 1
a136 1
	else if (sscanf(cmd, "t quick %80s", name) == 1)
d138 1
a138 1
	else if (sscanf(cmd, "t %80s", name) != 1) {
d217 1
a217 2
 * XXX Error handling!  How to do multi-line transactions?  Too short arbitrary
 * limit on the parameters?
d224 1
a224 1
	char	 subcmd[81], section[81], tag[81], value[81], tmp[81];
d229 1
a229 1
	if (sscanf(cmd, "C %80s", subcmd) != 1)
d233 1
a233 1
		if (sscanf(cmd, "C %*s [%80[^]]]:%80s", section, tag) != 2)
d248 1
a248 1
		items = sscanf(cmd, "C %*s [%80[^]]]:%80[^=]=%80s %80s",
d258 1
a258 1
		items = sscanf(cmd, "C %*s [%80[^]]]:%80[^=]=%80s %80s",
d297 1
a297 1
		items = sscanf(cmd, "C %*s [%80[^]]]:%80[^=]=%80s %80s",
d334 1
a334 1
		if (sscanf(cmd, "C %*s [%80[^]]]:%80s", section, tag) != 2)
d338 1
a338 1
		if (sscanf(cmd, "C %*s [%80[^]]]", section) != 1)
d418 1
a418 1
	char            subcmd[81];
d420 1
a420 1
	if (sscanf(cmd, "p %80s", subcmd) != 1)
d479 1
a479 1
	char	arg[81];
d481 1
a481 1
	if (sscanf(cmd, "M %80s", arg) != 1)
@


1.52
log
@new ui command 'rmv': removes an entry from a list, thus reversing an
'add' operation; ok ho, hshoexer, jmc
eVS: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.51 2006/11/28 09:27:09 markus Exp $	 */
d313 1
a313 2
				if (v)
					free(v);
@


1.51
log
@do not re-add existing entries; ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.50 2006/10/18 21:18:59 deraadt Exp $	 */
d227 1
a227 1
	int	 trans = 0, items, skip = 0;
d291 38
@


1.50
log
@do not name FILE * variables "fd" since it is confusing
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.49 2006/09/19 10:48:41 otto Exp $	 */
d223 2
d227 1
a227 1
	int	 trans = 0, items;
d267 12
d280 11
a290 7
			if (asprintf(&nv,
			    v[strlen(v) - 1] == ',' ? "%s%s" : "%s,%s", v,
			    value) == -1) {
				log_error("ui_config: malloc() failed");
				if (trans)
					conf_end(trans, 0);
				return;
a291 2
			conf_set(trans, section, tag, nv, 1, 0);
			free(nv);
@


1.49
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by/partly
from Paul Stoeber, more to come. ok ho@@ miod@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.48 2006/09/01 00:24:06 mpf Exp $	 */
d226 1
a226 1
	FILE	*fd;
d235 2
a236 2
		fd = ui_open_result();
		if (fd) {
d238 2
a239 2
				fprintf(fd, "%s\n", v);
			fclose(fd);
d413 2
d416 1
a416 3

	FILE *fd = ui_open_result();
	if (!fd)
d419 1
a419 1
	sa_report_all(fd);
d421 1
a421 1
	fclose(fd);
d584 3
a586 2
	FILE *fd = monitor_fopen(RESULT_FILE, "w");
	if (!fd)
d588 1
a588 1
	return fd;
@


1.48
log
@Add a new UI command to force isakmpd into passive only mode.
Will be used by sasyncd to prevent two talking isakmpd's in an HA setup.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.47 2005/11/14 23:25:11 deraadt Exp $	 */
d87 1
a87 1
		if ((st.st_mode & S_IFMT) == S_IFREG) {
@


1.47
log
@use snprintf; ok cloder.  also looked at by a few other people
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.46 2005/09/23 14:44:03 hshoexer Exp $	 */
d71 1
d424 26
d473 4
@


1.46
log
@Provide UI commands to delete phase 1 SAs.

Looks good mortiz@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.45 2005/04/08 22:32:10 cloder Exp $	 */
d224 1
a224 1
	int	 trans = 0, items, nvlen;
d265 4
a268 5
			nvlen = strlen(v) + strlen(value) + 2;
			nv = (char *)malloc(nvlen);
			if (!nv) {
				log_error("ui_config: malloc(%d) failed",
				    nvlen);
a272 3
			snprintf(nv, nvlen,
			    v[strlen(v) - 1] == ',' ? "%s%s" : "%s,%s", v,
			    value);
@


1.45
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.44 2005/04/08 19:40:03 deraadt Exp $	 */
d34 1
d36 2
d121 1
a121 1
/* Tear down a phase 2 connection.  */
d125 13
a137 4
	char            name[81];
	struct sa      *sa;

	if (sscanf(cmd, "t %80s", name) != 1) {
d141 32
a172 4
	LOG_DBG((LOG_UI, 10, "ui_teardown: teardown connection \"%s\"", name));
	connection_teardown(name);
	while ((sa = sa_lookup_by_name(name, 2)) != 0)
		sa_delete(sa, 1);
@


1.44
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.43 2005/04/04 19:31:11 deraadt Exp $	 */
a39 2

#include "sysdep.h"
@


1.43
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.42 2004/08/08 19:11:06 deraadt Exp $	 */
a300 1
#ifdef USE_DEBUG
a349 1
#endif				/* USE_DEBUG */
a409 1
#ifdef USE_DEBUG
a416 1
#endif
@


1.42
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.41 2004/06/25 00:58:39 hshoexer Exp $	 */
a326 1
	return;
d507 1
a507 1
	         */
@


1.41
log
@Narrow down privsep interface.  Remove ui_init to monitor. So we can get rid of
monitor_mkfifo.

Work in progress.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.40 2004/05/23 18:17:56 hshoexer Exp $	 */
d162 1
a162 1
	
d168 1
a168 1
	
d386 1
a386 1
	
@


1.40
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.39 2004/05/13 06:56:34 ho Exp $	 */
d82 2
a83 8
	/*
	 * Don't overwrite a file, i.e '-f
	 * /etc/isakmpd/isakmpd.conf'.
	 */
#if defined (USE_PRIVSEP)
	/* XXX This is a fstat! */
	if (monitor_stat(ui_fifo, &st) == 0) {
#else
a84 1
#endif
d94 1
a94 1
	if (monitor_mkfifo(ui_fifo, 0600) == -1)
d97 1
a97 1
	ui_socket = monitor_open(ui_fifo, O_RDWR | O_NONBLOCK, 0);
@


1.39
log
@Extensions to the FIFO interface:
"C get [section]:tag" fetches a configuration value.
"C add [section]:tag=value" adds 'value' to a list, typically for the
[Phase 2]:Connections tag. FIFO "S" command destination file changed.
Various KNF cleanups. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.38 2004/04/15 18:39:26 deraadt Exp $	 */
d117 1
a117 1
	char            name[81];
d481 1
a481 1
			    (unsigned long) sz);
d492 1
a492 1
			    (unsigned long) sz * 2);
d505 1
a505 1
		    (unsigned long) resid);
@


1.38
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ui.c,v 1.37 2004/04/07 22:45:49 ho Exp $	 */
d60 1
a60 1
void            daemon_shutdown_now(int);
d63 1
a63 1
void            ui_report_sa(char *cmd);
d65 5
a69 2
char           *ui_fifo = FIFO;
int             ui_socket;
d94 2
a95 1
			log_fatal("ui_init: could not create FIFO \"%s\"", ui_fifo);
d106 2
a107 2
		log_fatal("ui_init: open (\"%s\", O_RDWR | O_NONBLOCK, 0) failed",
		    ui_fifo);
d152 31
d191 4
a194 2
	char	subcmd[81], section[81], tag[81], value[81], tmp[81];
	int	trans = 0, items;
d199 14
d220 33
d389 8
a396 1
	sa_report_all();
d408 1
a408 1
		case 'c':
d455 2
a456 1
		log_print("ui_handle_messages: unrecognized command: '%c'", line[0]);
d526 9
@


1.37
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.36 2004/03/19 14:04:43 hshoexer Exp $	*/
/*	$EOM: ui.c,v 1.43 2000/10/05 09:25:12 niklas Exp $	*/
d60 1
a60 1
void daemon_shutdown_now (int);
d63 1
a63 1
void ui_report_sa (char *cmd);
d65 2
a66 2
char *ui_fifo = FIFO;
int ui_socket;
d70 1
a70 1
ui_init (void)
d72 1
a72 1
  struct stat st;
d74 9
a82 6
  /* -f- means control messages comes in via stdin.  */
  if (strcmp (ui_fifo, "-") == 0)
    ui_socket = 0;
  else
    {
      /* Don't overwrite a file, i.e '-f /etc/isakmpd/isakmpd.conf'.  */
d84 2
a85 2
      /* XXX This is a fstat! */
      if (monitor_stat (ui_fifo, &st) == 0)
d87 1
a87 1
      if (lstat (ui_fifo, &st) == 0)
d89 15
a103 16
	if ((st.st_mode & S_IFMT) == S_IFREG)
	  {
	    errno = EEXIST;
	    log_fatal ("ui_init: could not create FIFO \"%s\"", ui_fifo);
	  }

      /* No need to know about errors.  */
      unlink (ui_fifo);
      if (monitor_mkfifo (ui_fifo, 0600) == -1)
	log_fatal ("ui_init: mkfifo (\"%s\", 0600) failed", ui_fifo);

      ui_socket = monitor_open (ui_fifo, O_RDWR | O_NONBLOCK, 0);
      if (ui_socket == -1)
	log_fatal ("ui_init: open (\"%s\", O_RDWR | O_NONBLOCK, 0) failed",
		   ui_fifo);
    }
d111 1
a111 1
ui_connect (char *cmd)
d113 1
a113 1
  char name[81];
d115 6
a120 7
  if (sscanf (cmd, "c %80s", name) != 1)
    {
      log_print ("ui_connect: command \"%s\" malformed", cmd);
      return;
    }
  LOG_DBG ((LOG_UI, 10, "ui_connect: setup connection \"%s\"", name));
  connection_setup (name);
d125 1
a125 1
ui_teardown (char *cmd)
d127 2
a128 2
  char name[81];
  struct sa *sa;
d130 8
a137 9
  if (sscanf (cmd, "t %80s", name) != 1)
    {
      log_print ("ui_teardown: command \"%s\" malformed", cmd);
      return;
    }
  LOG_DBG ((LOG_UI, 10, "ui_teardown: teardown connection \"%s\"", name));
  connection_teardown (name);
  while ((sa = sa_lookup_by_name (name, 2)) != 0)
    sa_delete (sa, 1);
d142 1
a142 1
ui_teardown_all (char *cmd)
d144 2
a145 2
  /* Skip 'cmd' as arg. */
  sa_teardown_all ();
d154 1
a154 1
ui_config (char *cmd)
d156 2
a157 2
  char subcmd[81], section[81], tag[81], value[81], tmp[81];
  int trans = 0, items;
d159 2
a160 2
  if (sscanf (cmd, "C %80s", subcmd) != 1)
    goto fail;
d162 26
a187 32
  trans = conf_begin ();
  if (strcasecmp (subcmd, "set") == 0)
    {
      items = sscanf (cmd, "C %*s [%80[^]]]:%80[^=]=%80s %80s", section, tag,
		      value, tmp);
      if (!(items == 3 || items == 4))
	goto fail;
      conf_set (trans, section, tag, value, items == 4 ? 1 : 0, 0);
    }
  else if (strcasecmp (subcmd, "rm") == 0)
    {
      if (sscanf (cmd, "C %*s [%80[^]]]:%80s", section, tag) != 2)
	goto fail;
      conf_remove (trans, section, tag);
    }
  else if (strcasecmp (subcmd, "rms") == 0)
    {
      if (sscanf (cmd, "C %*s [%80[^]]]", section) != 1)
	goto fail;
      conf_remove_section (trans, section);
    }
  else
    goto fail;

  LOG_DBG ((LOG_UI, 30, "ui_config: \"%s\"", cmd));
  conf_end (trans, 1);
  return;

    fail:
  if (trans)
    conf_end (trans, 0);
  log_print ("ui_config: command \"%s\" malformed", cmd);
d191 1
a191 1
ui_delete (char *cmd)
d193 26
a218 31
  char cookies_str[ISAKMP_HDR_COOKIES_LEN * 2 + 1];
  char message_id_str[ISAKMP_HDR_MESSAGE_ID_LEN * 2 + 1];
  u_int8_t cookies[ISAKMP_HDR_COOKIES_LEN];
  u_int8_t message_id_buf[ISAKMP_HDR_MESSAGE_ID_LEN];
  u_int8_t *message_id = message_id_buf;
  struct sa *sa;

  if (sscanf (cmd, "d %32s %8s", cookies_str, message_id_str) != 2)
    {
      log_print ("ui_delete: command \"%s\" malformed", cmd);
      return;
    }

  if (strcmp (message_id_str, "-") == 0)
    message_id = 0;

  if (hex2raw (cookies_str, cookies, ISAKMP_HDR_COOKIES_LEN) == -1
      || (message_id && hex2raw (message_id_str, message_id_buf,
				 ISAKMP_HDR_MESSAGE_ID_LEN) == -1))
    {
      log_print ("ui_delete: command \"%s\" has bad arguments", cmd);
      return;
    }

  sa = sa_lookup (cookies, message_id);
  if (!sa)
    {
      log_print ("ui_delete: command \"%s\" found no SA", cmd);
      return;
    }
  LOG_DBG ((LOG_UI, 20, 
d221 1
a221 1
  sa_delete (sa, 1);
d227 1
a227 1
ui_debug (char *cmd)
d229 2
a230 2
  int cls, level;
  char subcmd[3];
d232 16
a247 22
  if (sscanf (cmd, "D %d %d", &cls, &level) == 2)
    {
      log_debug_cmd (cls, level);
      return;
    }
  else if (sscanf (cmd, "D %2s %d", subcmd, &level) == 2)
    {
      switch (subcmd[0])
	{
	case 'A':
	  for (cls = 0; cls < LOG_ENDCLASS; cls++)
	    log_debug_cmd (cls, level);
	  return;
	}
    }
  else if (sscanf (cmd, "D %2s", subcmd) == 1)
    {
      switch (subcmd[0])
	{
	case 'T':
	  log_debug_toggle ();
	  return;
d249 2
a250 4
    }

  log_print ("ui_debug: command \"%s\" malformed", cmd);
  return;
d254 1
a254 1
ui_packetlog (char *cmd)
d256 1
a256 4
  char subcmd[81];

  if (sscanf (cmd, "p %80s", subcmd) != 1)
    goto fail;
d258 2
a259 11
  if (strncasecmp (subcmd, "on=", 3) == 0)
    {
      /* Start capture to a new file.  */
      if (subcmd[strlen (subcmd) - 1] == '\n')
	subcmd[strlen (subcmd) - 1] = 0;
      log_packet_restart (subcmd + 3);
    }
  else if (strcasecmp (subcmd, "on") == 0)
    log_packet_restart (NULL);
  else if (strcasecmp (subcmd, "off") == 0)
    log_packet_stop ();
d261 10
a270 1
  return;
d272 2
a273 2
 fail:
  log_print ("ui_packetlog: command \"%s\" malformed", cmd);
d275 1
a275 1
#endif /* USE_DEBUG */
d278 1
a278 1
ui_shutdown_daemon (char *cmd)
d280 5
a284 7
  if (strlen (cmd) == 1)
    {
      log_print ("ui_shutdown_daemon: received shutdown command");
      daemon_shutdown_now (0);
    }
  else
    log_print ("ui_shutdown_daemon: command \"%s\" malformed", cmd);
d289 1
a289 1
ui_report (char *cmd)
d291 7
a297 7
  /* XXX Skip 'cmd' as arg? */
  sa_report ();
  exchange_report ();
  transport_report ();
  connection_report ();
  timer_report ();
  conf_report ();
d302 1
a302 1
ui_report_sa (char *cmd)
d304 2
a305 2
  /* Skip 'cmd' as arg? */
  sa_report_all ();
d313 1
a313 1
ui_handle_command (char *line)
d315 13
a327 14
  /* Find out what one-letter command was sent.  */
  switch (line[0])
    {
    case 'c':
      ui_connect (line);
      break;

    case 'C':
      ui_config (line);
      break;

    case 'd':
      ui_delete (line);
      break;
d330 7
a336 7
    case 'D':
      ui_debug (line);
      break;

    case 'p':
      ui_packetlog (line);
      break;
d339 27
a365 27
    case 'Q':
      ui_shutdown_daemon (line);
      break;

    case 'R':
      reinit ();
      break;

    case 'S':
      ui_report_sa (line);
      break;

    case 'r':
      ui_report (line);
      break;

    case 't':
      ui_teardown (line);
      break;

    case 'T':
      ui_teardown_all (line);
      break;

    default:
      log_print ("ui_handle_messages: unrecognized command: '%c'", line[0]);
    }
d374 1
a374 1
ui_handler (void)
d376 57
a432 64
  static char *buf = 0;
  static char *p;
  static size_t sz;
  static size_t resid;
  ssize_t n;
  char *new_buf;

  /* If no buffer, set it up.  */
  if (!buf)
    {
      sz = BUF_SZ;
      buf = malloc (sz);
      if (!buf)
	{
	  log_print ("ui_handler: malloc (%lu) failed", (unsigned long)sz);
	  return;
	}
      p = buf;
      resid = sz;
    }

  /* If no place left in the buffer reallocate twice as large.  */
  if (!resid)
    {
      new_buf = realloc (buf, sz * 2);
      if (!new_buf)
	{
	  log_print ("ui_handler: realloc (%p, %lu) failed", buf,
		(unsigned long)sz * 2);
	  free (buf);
	  buf = 0;
	  return;
	}
      buf = new_buf;
      p = buf + sz;
      resid = sz;
      sz *= 2;
    }

  n = read (ui_socket, p, resid);
  if (n == -1)
    {
      log_error ("ui_handler: read (%d, %p, %lu)", ui_socket, p,
	(unsigned long)resid);
      return;
    }

  if (!n)
    return;
  resid -= n;
  while (n--)
    {
      /*
       * When we find a newline, cut off the line and feed it to the
       * command processor.  Then move the rest up-front.
       */
      if (*p == '\n')
	{
	  *p = '\0';
	  ui_handle_command (buf);
	  memcpy (buf, p + 1, n);
	  p = buf;
	  resid = sz - n;
	  continue;
a433 2
      p++;
    }
@


1.36
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.35 2003/11/06 16:12:08 ho Exp $	*/
d405 1
a405 1
  size_t n;
@


1.35
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.34 2003/10/13 13:57:51 ho Exp $	*/
d80 4
d85 1
@


1.34
log
@Add a UI FIFO debug class. ok markus@@ plus I think henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.33 2003/06/03 14:28:16 ho Exp $	*/
d140 1
a140 1
  sa_teardown_all();
@


1.33
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.32 2003/05/15 00:28:53 ho Exp $	*/
d113 1
a113 1
  log_print ("ui_connect: setup connection \"%s\"", name);
d129 1
a129 1
  log_print ("ui_teardown: teardown connection \"%s\"", name);
d181 1
a181 1
  log_print ("ui_config: \"%s\"", cmd);
d224 3
a226 2
  log_print ("ui_delete: deleting SA for cookie \"%s\" msgid \"%s\"",
	     cookies_str, message_id_str);
@


1.32
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.31 2003/04/27 11:16:24 ho Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999, 2000, 2001 Håkan Olsson.  All rights reserved.
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.31
log
@Make the 'C set' FIFO command work as expected. PR#3148.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.30 2002/06/09 08:13:07 todd Exp $	*/
d55 1
d94 1
a94 1
      if (mkfifo (ui_fifo, 0600) == -1)
d97 1
a97 1
      ui_socket = open (ui_fifo, O_RDWR | O_NONBLOCK, 0);
@


1.30
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.29 2002/06/01 07:44:22 deraadt Exp $	*/
d155 2
a156 2
  char subcmd[81], section[81], tag[81], value[81];
  int override, trans = 0;
d164 3
a166 2
      if (sscanf (cmd, "C %*s [%80[^]]]:%80[^=]=%80s %d", section, tag, value,
		  &override) != 4)
d168 1
a168 1
      conf_set (trans, section, tag, value, override, 0);
@


1.29
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.28 2002/03/19 04:00:59 angelos Exp $	*/
d209 1
a209 1
  
@


1.28
log
@Remove unnecessary prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.27 2002/03/17 21:48:06 angelos Exp $	*/
d412 1
a412 1
	  log_print ("ui_handler: malloc (%d) failed", sz);
d425 2
a426 1
	  log_print ("ui_handler: realloc (%p, %d) failed", buf, sz * 2);
d440 2
a441 1
      log_error ("ui_handler: read (%d, %p, %d)", ui_socket, p, resid);
@


1.27
log
@Add 'T' and 'S' commands (for tearing-down and reporting all Phase 2
SAs), from bdallen@@nps.navy.mil
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.26 2001/12/11 01:43:54 ho Exp $	*/
a67 2
/* Issue SIGHUP. */
void ui_sighup (char *cmd);
@


1.26
log
@Proper error msg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.25 2001/12/10 03:34:51 ho Exp $	*/
d66 5
d141 8
d323 8
d371 4
d381 4
@


1.25
log
@Add UI option 'R' to trigger isakmpd reinit (same as SIGHUP).
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.24 2001/12/03 16:17:17 ho Exp $	*/
d95 1
a95 1
	log_fatal ("ui_init: open (\"%s\", O_RDONLY | O_NONBLOCK, 0) failed",
@


1.24
log
@Change UI fifo open to O_RDWR to avoid problems on some OSes (such as
FreeBSD). Reported by Tariq Rashid <tariq@@inty.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.23 2001/11/22 11:10:45 ho Exp $	*/
d52 1
d344 4
@


1.23
log
@Nit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.22 2001/10/05 08:18:37 ho Exp $	*/
d92 1
a92 2
      /* XXX Is O_RDWR needed on some OSes?  Photurisd seems to imply that.  */
      ui_socket = open (ui_fifo, O_RDONLY | O_NONBLOCK, 0);
@


1.22
log
@Extend the FIFO ui with the 'D A <level>' (to set all debug levels) and
'D T' (to toggle all logging on and off) commands. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.21 2001/08/24 13:53:02 ho Exp $	*/
a335 1
#endif
a336 1
#ifdef USE_DEBUG
@


1.21
log
@Send DELETE notifications for all active SAs when we shut down the daemon.
This "clean" shutdown happens on SIGTERM ('kill <pid>') or if a 'Q' command
is input to the fifo UI. Suggested by <Ghislaine.Labouret@@hsc.fr>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.20 2001/07/06 14:37:12 ho Exp $	*/
d227 1
d229 1
a229 1
  if (sscanf (cmd, "D %d %d", &cls, &level) != 2)
d231 1
a231 1
      log_print ("ui_debug: command \"%s\" malformed", cmd);
d234 22
a255 1
  log_debug_cmd (cls, level);
@


1.20
log
@Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.19 2001/04/30 12:16:44 ho Exp $	*/
d62 3
d263 12
d316 10
a332 6

#ifdef USE_DEBUG
    case 'p':
      ui_packetlog (line);
      break;
#endif
@


1.19
log
@Be more verbose about fifo ui operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.18 2001/04/09 21:21:57 ho Exp $	*/
d67 1
a67 1
ui_init ()
d326 1
a326 1
ui_handler ()
@


1.18
log
@isakmpd can now capture un-encrypted IKE negotiation packets to a
file. In pcap(3) format, so tcpdump(8) can read it.
Idea by Tim Newsham <newsham@@lava.net>, work by him and me.
Ok angelos@@, niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.17 2000/10/07 06:57:25 niklas Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999, 2000 Håkan Olsson.  All rights reserved.
d111 1
d127 1
d170 1
d213 2
@


1.17
log
@Merge with EOM 1.43

author: niklas
missing arg

author: ho
(c)-2000
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.16 2000/05/02 14:37:00 niklas Exp $	*/
d227 26
d303 6
@


1.17.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.c,v 1.19 2001/04/30 12:16:44 ho Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999, 2000, 2001 Håkan Olsson.  All rights reserved.
a110 1
  log_print ("ui_connect: setup connection \"%s\"", name);
a125 1
  log_print ("ui_teardown: teardown connection \"%s\"", name);
a167 1
  log_print ("ui_config: \"%s\"", cmd);
a209 2
  log_print ("ui_delete: deleting SA for cookie \"%s\" msgid \"%s\"",
	     cookies_str, message_id_str);
a226 26

static void
ui_packetlog (char *cmd)
{
  char subcmd[81];

  if (sscanf (cmd, "p %80s", subcmd) != 1)
    goto fail;

  if (strncasecmp (subcmd, "on=", 3) == 0)
    {
      /* Start capture to a new file.  */
      if (subcmd[strlen (subcmd) - 1] == '\n')
	subcmd[strlen (subcmd) - 1] = 0;
      log_packet_restart (subcmd + 3);
    }
  else if (strcasecmp (subcmd, "on") == 0)
    log_packet_restart (NULL);
  else if (strcasecmp (subcmd, "off") == 0)
    log_packet_stop ();

  return;

 fail:
  log_print ("ui_packetlog: command \"%s\" malformed", cmd);
}
a276 6

#ifdef USE_DEBUG
    case 'p':
      ui_packetlog (line);
      break;
#endif
@


1.16
log
@conf.h: Merge with EOM 1.11
ui.c: Merge with EOM 1.41

author: niklas
From ho: provide defaults for requested transforms, shortens config files
vastly.
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.15 2000/04/07 22:10:30 niklas Exp $	*/
/*	$EOM: ui.c,v 1.41 2000/05/01 20:57:33 niklas Exp $	*/
d6 1
d87 1
a87 1
	log_fatal ("ui_init: mkfifo (\"%s\", 0600) failed");
@


1.15
log
@conf.c: Merge with EOM 1.22
gmp_util.c: Merge with EOM 1.5
gmp_util.h: Merge with EOM 1.3
math_mp.h: Merge with EOM 1.2
sa.c: Merge with EOM 1.101
ui.c: Merge with EOM 1.40

author: niklas
(c) 2000
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.14 2000/04/07 22:06:44 niklas Exp $	*/
/*	$EOM: ui.c,v 1.40 2000/04/07 22:05:57 niklas Exp $	*/
d150 1
a150 1
      conf_set (trans, section, tag, value, override);
d238 1
@


1.14
log
@conf.c: Merge with EOM 1.21
isakmpd.c: Merge with EOM 1.46
sa.c: Merge with EOM 1.100
ui.c: Merge with EOM 1.39

author: niklas
error message style
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.13 2000/03/08 08:42:38 niklas Exp $	*/
/*	$EOM: ui.c,v 1.39 2000/04/07 19:05:01 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.13
log
@Merge with EOM 1.38

author: niklas
Comparison to wrong var, fix by rayl@@mail.com
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.12 2000/02/25 17:23:42 niklas Exp $	*/
/*	$EOM: ui.c,v 1.38 2000/03/07 20:22:14 niklas Exp $	*/
d80 1
a80 1
	    log_fatal ("could not create FIFO \"%s\"", ui_fifo);
d86 1
a86 1
	log_fatal ("mkfifo");
d91 2
a92 1
	log_fatal (ui_fifo);
d303 1
a303 1
	  log_print ("malloc (%d) failed", sz);
d316 1
a316 1
	  log_print ("realloc (%p, %d) failed", buf, sz * 2);
d330 1
a330 1
      log_error ("read (%d, %p, %d)", ui_socket, p, resid);
@


1.12
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.11 1999/08/26 22:29:57 niklas Exp $	*/
/*	$EOM: ui.c,v 1.37 2000/02/20 19:58:42 niklas Exp $	*/
d151 1
a151 1
  else if (strcasecmp (cmd, "rm") == 0)
d157 1
a157 1
  else if (strcasecmp (cmd, "rms") == 0)
@


1.11
log
@Merge with EOM 1.36

author: ho
style

author: ho
Don't accidentally overwrite files with the FIFO.
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.10 1999/08/05 22:41:08 niklas Exp $	*/
/*	$EOM: ui.c,v 1.36 1999/08/20 12:54:51 ho Exp $	*/
d211 1
d225 1
d261 1
d265 1
@


1.10
log
@DESIGN-NOTES: Merge with EOM 1.47
conf.c: Merge with EOM 1.19
conf.h: Merge with EOM 1.10
ui.c: Merge with EOM 1.34

author: niklas
Dynamic updates of the configuration database is now possible, either through
ui, or through the new conf_* API described in DESIGN-NOTES
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.9 1999/06/02 06:29:55 niklas Exp $	*/
/*	$EOM: ui.c,v 1.34 1999/08/05 14:58:00 niklas Exp $	*/
d43 1
d68 2
d75 8
@


1.9
log
@Merge with EOM 1.33

author: ho
Add connection_report
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.8 1999/05/01 20:43:46 niklas Exp $	*/
/*	$EOM: ui.c,v 1.33 1999/05/19 22:40:13 ho Exp $	*/
d118 46
d238 4
@


1.8
log
@sysdep/openbsd/sysdep.c: Merge with EOM 1.7
DESIGN-NOTES: Merge with EOM 1.42
Makefile: Merge with EOM 1.51
app.c: Merge with EOM 1.6
conf.c: Merge with EOM 1.18
init.c: Merge with EOM 1.14
isakmpd.conf.5: Merge with EOM 1.19
pf_encap.c: Merge with EOM 1.64
pf_encap.h: Merge with EOM 1.12
pf_key_v2.h: Merge with EOM 1.3
sysdep.h: Merge with EOM 1.16
transport.c: Merge with EOM 1.40
ui.c: Merge with EOM 1.32

author: niklas
A new connection abstraction
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.7 1999/04/19 21:10:21 niklas Exp $	*/
/*	$EOM: ui.c,v 1.32 1999/05/01 20:21:19 niklas Exp $	*/
d172 1
d176 1
@


1.7
log
@./ui.c: Merge with EOM 1.31

Added timer_report

Add call to transport_report

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.6 1999/03/24 15:00:17 niklas Exp $	*/
/*	$EOM: ui.c,v 1.31 1999/04/11 22:35:53 ho Exp $	*/
d47 1
d84 4
a87 1
/* New style connect.  */
d98 18
a115 1
  exchange_establish (name, 0, 0);
d202 4
@


1.6
log
@Merge with EOM 1.28
old connect has disappeared
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.5 1999/02/26 03:52:22 niklas Exp $	*/
/*	$EOM: ui.c,v 1.28 1999/03/08 00:39:28 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d52 1
d153 2
@


1.5
log
@Merge from the Ericsson repository
| revision 1.27
| date: 1999/02/25 11:39:26;  author: niklas;  state: Exp;  lines: +4 -1
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.4 1998/12/21 01:02:27 niklas Exp $	*/
/*	$EOM: ui.c,v 1.27 1999/02/25 11:39:26 niklas Exp $	*/
d88 1
a88 1
  if (sscanf (cmd, "C %80s", name) != 1)
@


1.4
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.3 1998/11/17 11:10:21 niklas Exp $	*/
/*	$EOM: ui.c,v 1.26 1998/12/19 09:18:17 niklas Exp $	*/
d43 3
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: ui.c,v 1.2 1998/11/15 00:44:04 niklas Exp $	*/
/*	$EOM: ui.c,v 1.20 1998/11/12 13:01:19 niklas Exp $	*/
d43 1
a43 3

#define BUF_SZ 256

d53 2
d79 1
a79 1
/* Parse the connect command found in CMD.  */
d83 1
a83 6
  char trpt[11];
  char addr[81];
  struct transport *transport = 0;
  int exchange, doi;
  struct sa *isakmp_sa = 0;
  u_int8_t cookies[ISAKMP_HDR_COOKIES_LEN];
d85 1
a85 1
  if (sscanf (cmd, "c %10s %80s %d %d", trpt, addr, &exchange, &doi) != 4)
d90 1
a90 49

  if (strcasecmp (trpt, "isakmp") == 0)
    {
      if (hex2raw (addr, cookies, ISAKMP_HDR_COOKIES_LEN) == -1)
	{
	  log_print ("ui_connect: cookiepair \"%s\" malformed", addr);
	  return;
	}
      isakmp_sa = sa_lookup (cookies, 0);
      if (!isakmp_sa)
	{
	  log_print ("ui_connect: transport \"%s %s\" could not be found",
		     trpt, addr);
	  return;
	}

      /* XXX Fill in the args argument.  */
      exchange_establish_p2 (isakmp_sa, exchange, 0);
    }
  else
    {
      transport = transport_create (trpt, addr);
      if (!transport)
	{
	  log_print ("ui_connect: transport \"%s %s\" could not be created",
		     trpt, addr);
	  return;
	}

      /* XXX This validity check seems to be a bit dumb.  */
#if 0
      /* Only ISAKMP exchange types can be given.  */
      if (exchange < ISAKMP_EXCH_BASE || exchange >= ISAKMP_EXCH_FUTURE_MIN)
	{
	  log_print ("exchange %d is not valid", exchange);
	  return;
	}
#endif

      /* Only valid DOIs can be given.  XXX Uninteresting for phase 2.  */
      if (!doi_lookup (doi))
	{
	  log_print ("DOI %d is not valid", doi);
	  return;
	}

      /* XXX Fill in the args argument.  */
      exchange_establish_p1 (transport, exchange, doi, 0);
    }
d135 1
a135 1
  if (sscanf (cmd, "d %d %d", &cls, &level) != 2)
d144 1
a144 1
static void
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: ui.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: ui.c,v 1.20 1998/11/12 13:01:19 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
