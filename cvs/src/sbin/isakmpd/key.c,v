head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.6
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.40
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.36
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.38
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.30
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.34
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.32
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.28
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.26
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.24
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.22
	OPENBSD_5_0:1.25.0.20
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.18
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.16
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.12
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.14
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.10
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.8
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.6
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.4
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.6
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.26
date	2017.02.03.08.23.46;	author guenther;	state Exp;
branches;
next	1.25;
commitid	RkgZAc0srXet0WqL;

1.25
date	2007.03.05.20.11.40;	author moritz;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.15.22.10.49;	author cloder;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.15.21.49.04;	author cloder;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.05.20.46.20;	author cloder;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.28.11.19.47;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.17.13.53.08;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.23.16.13.39;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.07.22.45.04;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.06.16.12.07;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.11.09.50.44;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.10.18.08.58;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.06.13.55.12;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.06.10.02.32;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.05.00.10.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.23.18.44.47;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.26.16.02.20;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.02.02.28.35;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.01.19.48.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.25.05.15.11;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.31.20.20.07;	author angelos;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Stop assuming that in_{addr,port}_t are typedefed in <sys/types.h> and
instead pull in <netinet/in.h> or <arpa/inet.h> when those are needed.

ok florian@@ beck@@ millert@@
@
text
@/* $OpenBSD: key.c,v 1.25 2007/03/05 20:11:40 moritz Exp $	 */
/*
 * The author of this code is Angelos D. Keromytis (angelos@@cis.upenn.edu)
 *
 * Copyright (c) 2000-2001 Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>

#include "key.h"
#include "libcrypto.h"
#include "log.h"
#include "util.h"
#include "x509.h"

void
key_free(int type, int private, void *key)
{
	switch (type) {
	case ISAKMP_KEY_PASSPHRASE:
		free(key);
		break;
	case ISAKMP_KEY_RSA:
		RSA_free(key);
		break;
	case ISAKMP_KEY_NONE:
	default:
		log_error("key_free: unknown/unsupportedkey type %d", type);
		break;
	}
}

/* Convert from internal form to serialized */
void
key_serialize(int type, int private, void *key, u_int8_t **data,
    size_t *datalenp)
{
	u_int8_t       *p;
	size_t		datalen;

	switch (type) {
	case ISAKMP_KEY_PASSPHRASE:
		*datalenp = strlen((char *)key);
		*data = (u_int8_t *)strdup((char *)key);
		break;
	case ISAKMP_KEY_RSA:
		switch (private) {
		case ISAKMP_KEYTYPE_PUBLIC:
			datalen = i2d_RSAPublicKey((RSA *)key, NULL);
			*data = p = malloc(datalen);
			if (!p) {
				log_error("key_serialize: malloc (%lu) failed",
				    (unsigned long)datalen);
				return;
			}
			*datalenp = i2d_RSAPublicKey((RSA *) key, &p);
			break;

		case ISAKMP_KEYTYPE_PRIVATE:
			datalen = i2d_RSAPrivateKey((RSA *)key, NULL);
			*data = p = malloc(datalen);
			if (!p) {
				log_error("key_serialize: malloc (%lu) failed",
				    (unsigned long)datalen);
				return;
			}
			*datalenp = i2d_RSAPrivateKey((RSA *)key, &p);
			break;
		}
		break;
	default:
		log_error("key_serialize: unknown/unsupported key type %d",
		    type);
		break;
	}
}

/* Convert from serialized to printable */
char *
key_printable(int type, int private, u_int8_t *data, size_t datalen)
{
	switch (type) {
	case ISAKMP_KEY_PASSPHRASE:
		return strdup((char *)data);

	case ISAKMP_KEY_RSA:
		return raw2hex(data, datalen);

	default:
		log_error("key_printable: unknown/unsupported key type %d",
		    type);
		return 0;
	}
}

/* Convert from serialized to internal.  */
void *
key_internalize(int type, int private, u_int8_t *data, size_t datalen)
{
	switch (type) {
	case ISAKMP_KEY_PASSPHRASE:
		return strdup((char *)data);
	case ISAKMP_KEY_RSA:
		switch (private) {
#if OPENSSL_VERSION_NUMBER >= 0x00907000L
		case ISAKMP_KEYTYPE_PUBLIC:
			return d2i_RSAPublicKey(NULL,
			    (const u_int8_t **)&data, datalen);
		case ISAKMP_KEYTYPE_PRIVATE:
			return d2i_RSAPrivateKey(NULL,
			    (const u_int8_t **)&data, datalen);
#else
		case ISAKMP_KEYTYPE_PUBLIC:
			return d2i_RSAPublicKey(NULL, &data, datalen);
		case ISAKMP_KEYTYPE_PRIVATE:
			return d2i_RSAPrivateKey(NULL, &data, datalen);
#endif
		default:
			log_error("key_internalize: not public or private "
			    "RSA key passed");
			return 0;
		}
		break;
	default:
		log_error("key_internalize: unknown/unsupported key type %d",
		    type);
		break;
	}

	return 0;
}

/* Convert from printable to serialized */
void
key_from_printable(int type, int private, char *key, u_int8_t **data,
    u_int32_t *datalenp)
{
	u_int32_t datalen;

	switch (type) {
	case ISAKMP_KEY_PASSPHRASE:
		*datalenp = strlen(key);
		*data = (u_int8_t *) strdup(key);
		break;

	case ISAKMP_KEY_RSA:
		datalen = (strlen(key) + 1) / 2; /* Round up, just in case */
		*data = malloc(datalen);
		if (!*data) {
			log_error("key_from_printable: malloc (%d) failed",
			    datalen);
			*datalenp = 0;
			return;
		}
		if (hex2raw(key, *data, datalen)) {
			log_error("key_from_printable: invalid hex key");
			free(*data);
			*data = NULL;
			*datalenp = 0;
			return;
		}
		*datalenp = datalen;
		break;

	default:
		log_error("key_from_printable: "
		    "unknown/unsupported key type %d", type);
		*data = NULL;
		*datalenp = 0;
		break;
	}
}
@


1.25
log
@Set pointer to NULL after freeing it, so callers of
key_from_printable() are not fooled into using it
afterwards.

OK hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.24 2005/11/15 22:10:49 cloder Exp $	 */
d23 1
@


1.24
log
@Be cleaner about signed vs. unsigned when it's easy to do so.  OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.23 2005/11/15 21:49:04 cloder Exp $	 */
d174 1
@


1.23
log
@Add a new raw2hex function and yank out several pieces of code in other
places that were doing this.  Prodding deraadt.  OK hshoexer.
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.22 2005/04/08 22:32:10 cloder Exp $	 */
d96 1
a96 1
key_printable(int type, int private, u_int8_t *data, int datalen)
d114 1
a114 1
key_internalize(int type, int private, u_int8_t *data, int datalen)
@


1.22
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.21 2005/04/05 20:46:20 cloder Exp $	 */
a97 3
	char	*s;
	int	 i;

d103 1
a103 10
		s = malloc(datalen * 2 + 1);
		if (!s) {
			log_error("key_printable: malloc (%d) failed",
			    datalen * 2 + 1);
			return 0;
		}
		for (i = 0; i < datalen; i++)
			snprintf(s + (2 * i), 2 * (datalen - i) + 1, "%02x",
			    data[i]);
		return s;
@


1.21
log
@Always compile X509 support. Almost everyone uses it.  Makes the code
much easier to read and to maintain.
OK and testing by hshoexer@@, more testing by me
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.20 2004/12/28 11:19:47 hshoexer Exp $	 */
a24 2

#include "sysdep.h"
@


1.20
log
@Correctly determine length of rsa key passed by the kernel to userland.  Found
and fix provided by Stefan Miltchev.  Again, many thanks!

Slightly different fix.
ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.19 2004/09/17 13:53:08 ho Exp $	 */
a31 1
#ifdef USE_X509
a32 1
#endif
a41 1
#ifdef USE_X509
a43 1
#endif
a55 1
#ifdef USE_X509
a57 1
#endif
a64 1
#ifdef USE_X509
a87 1
#endif
a99 1
#ifdef USE_X509
a101 1
#endif
a107 1
#ifdef USE_X509
a117 1
#endif
a133 1
#ifdef USE_X509
a153 1
#endif /* USE_X509 */
a167 1
#ifdef USE_X509
a168 1
#endif
a176 1
#ifdef USE_X509
a192 1
#endif
@


1.19
log
@Missing #ifdefs.
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.18 2004/06/14 09:55:41 ho Exp $	 */
d202 7
a208 1
		*datalenp = hex2raw(key, *data, datalen);
@


1.18
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.17 2004/05/23 18:17:56 hshoexer Exp $	 */
d24 1
d32 1
d34 1
d44 1
d47 1
d60 1
d63 1
d71 1
d95 1
d108 1
d111 1
d118 1
d129 1
d146 1
d167 1
d182 1
d184 1
d193 1
d204 1
@


1.17
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.16 2004/05/23 16:13:39 deraadt Exp $	 */
d188 2
a189 2
		log_error("key_from_printable: unknown/unsupported key type %d",
		    type);
@


1.16
log
@greater care with arguments
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.15 2004/04/15 18:39:26 deraadt Exp $	 */
d52 2
a53 1
key_serialize(int type, int private, void *key, u_int8_t **data, size_t *datalenp)
d60 2
a61 2
		*datalenp = strlen((char *) key);
		*data = (u_int8_t *) strdup((char *) key);
d66 1
a66 1
			datalen = i2d_RSAPublicKey((RSA *) key, NULL);
d70 1
a70 1
				    (unsigned long) datalen);
d77 1
a77 1
			datalen = i2d_RSAPrivateKey((RSA *) key, NULL);
d81 1
a81 1
				    (unsigned long) datalen);
d84 1
a84 1
			*datalenp = i2d_RSAPrivateKey((RSA *) key, &p);
d89 2
a90 1
		log_error("key_serialize: unknown/unsupported key type %d", type);
d99 2
a100 2
	char           *s;
	int             i;
d104 1
a104 1
		return strdup((char *) data);
d119 2
a120 1
		log_error("key_printable: unknown/unsupported key type %d", type);
d131 1
a131 1
		return strdup((char *) data);
d176 1
a176 1
		datalen = (strlen(key) + 1) / 2;	/* Round up, just in case */
d179 2
a180 1
			log_error("key_from_printable: malloc (%d) failed", datalen);
d188 2
a189 1
		log_error("key_from_printable: unknown/unsupported key type %d", type);
@


1.15
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: key.c,v 1.14 2004/04/07 22:45:04 ho Exp $	 */
d37 1
a37 1
		case ISAKMP_KEY_PASSPHRASE:
d52 1
a52 1
key_serialize(int type, int private, void *key, u_int8_t **data, size_t *datalen)
d55 1
d59 1
a59 1
		*datalen = strlen((char *) key);
d65 2
a66 2
			*datalen = i2d_RSAPublicKey((RSA *) key, NULL);
			*data = p = malloc(*datalen);
d69 1
a69 1
				    (unsigned long) *datalen);
d72 1
a72 1
			*datalen = i2d_RSAPublicKey((RSA *) key, &p);
d76 2
a77 2
			*datalen = i2d_RSAPrivateKey((RSA *) key, NULL);
			*data = p = malloc(*datalen);
d80 1
a80 1
				    (unsigned long) *datalen);
d83 1
a83 1
			*datalen = i2d_RSAPrivateKey((RSA *) key, &p);
d162 1
a162 1
    u_int32_t *datalen)
d164 2
d168 1
a168 1
		*datalen = strlen(key);
d173 2
a174 2
		*datalen = (strlen(key) + 1) / 2;	/* Round up, just in case */
		*data = malloc(*datalen);
d176 2
a177 1
			log_error("key_from_printable: malloc (%d) failed", *datalen);
d180 1
a180 1
		*datalen = hex2raw(key, *data, *datalen);
d185 2
a186 1
		*data = 0;
@


1.14
log
@Reset *data in case of unknown key types
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.13 2003/11/06 16:12:07 ho Exp $	*/
d34 1
a34 1
key_free (int type, int private, void *key)
d36 12
a47 13
  switch (type)
    {
    case ISAKMP_KEY_PASSPHRASE:
      free (key);
      break;
    case ISAKMP_KEY_RSA:
      RSA_free (key);
      break;
    case ISAKMP_KEY_NONE:
    default:
      log_error ("key_free: unknown/unsupportedkey type %d", type);
      break;
    }
d52 1
a52 1
key_serialize (int type, int private, void *key, u_int8_t **data, size_t *datalen)
d54 1
a54 1
  u_int8_t *p;
d56 33
a88 32
  switch (type)
    {
    case ISAKMP_KEY_PASSPHRASE:
      *datalen = strlen ((char *)key);
      *data = (u_int8_t *)strdup ((char *)key);
      break;
    case ISAKMP_KEY_RSA:
      switch (private)
	{
	case ISAKMP_KEYTYPE_PUBLIC:
	  *datalen = i2d_RSAPublicKey ((RSA *)key, NULL);
	  *data = p = malloc (*datalen);
	  if (!p)
	    {
	      log_error ("key_serialize: malloc (%lu) failed",
			 (unsigned long)*datalen);
	      return;
	    }
	  *datalen = i2d_RSAPublicKey ((RSA *)key, &p);
	  break;

	case ISAKMP_KEYTYPE_PRIVATE:
	  *datalen = i2d_RSAPrivateKey ((RSA *)key, NULL);
	  *data = p = malloc (*datalen);
	  if (!p)
	    {
	      log_error ("key_serialize: malloc (%lu) failed",
			 (unsigned long)*datalen);
	      return;
	    }
	  *datalen = i2d_RSAPrivateKey ((RSA *)key, &p);
	  break;
a89 5
      break;
    default:
      log_error ("key_serialize: unknown/unsupported key type %d", type);
      break;
    }
d94 1
a94 1
key_printable (int type, int private, u_int8_t *data, int datalen)
d96 18
a113 2
  char *s;
  int i;
d115 3
a117 11
  switch (type)
    {
    case ISAKMP_KEY_PASSPHRASE:
      return strdup ((char *)data);

    case ISAKMP_KEY_RSA:
      s = malloc (datalen * 2 + 1);
      if (!s)
	{
	  log_error ("key_printable: malloc (%d) failed", datalen * 2 + 1);
	  return 0;
a118 8
      for (i = 0; i < datalen; i++)
	snprintf (s + (2 * i), 2 * (datalen - i) + 1, "%02x", data[i]);
      return s;

    default:
      log_error ("key_printable: unknown/unsupported key type %d", type);
      return 0;
    }
d123 1
a123 1
key_internalize (int type, int private, u_int8_t *data, int datalen)
d125 5
a129 7
  switch (type)
    {
    case ISAKMP_KEY_PASSPHRASE:
      return strdup ((char *)data);
    case ISAKMP_KEY_RSA:
      switch (private)
	{
d131 6
a136 4
	case ISAKMP_KEYTYPE_PUBLIC:
	  return d2i_RSAPublicKey (NULL, (const u_int8_t **)&data, datalen);
	case ISAKMP_KEYTYPE_PRIVATE:
	  return d2i_RSAPrivateKey (NULL, (const u_int8_t **)&data, datalen);
d138 4
a141 4
	case ISAKMP_KEYTYPE_PUBLIC:
	  return d2i_RSAPublicKey (NULL, &data, datalen);
	case ISAKMP_KEYTYPE_PRIVATE:
	  return d2i_RSAPrivateKey (NULL, &data, datalen);
d143 6
d150 3
a152 2
	  log_error ("key_internalize: not public or private RSA key passed");
	  return 0;
a153 5
      break;
    default:
      log_error ("key_internalize: unknown/unsupported key type %d", type);
      break;
    }
d155 1
a155 1
  return 0;
d160 2
a161 2
key_from_printable (int type, int private, char *key, u_int8_t **data,
		    u_int32_t *datalen)
d163 20
a182 14
  switch (type)
    {
    case ISAKMP_KEY_PASSPHRASE:
      *datalen = strlen (key);
      *data = (u_int8_t *)strdup (key);
      break;

    case ISAKMP_KEY_RSA:
      *datalen = (strlen (key) + 1) / 2; /* Round up, just in case */
      *data = malloc (*datalen);
      if (!*data)
	{
	  log_error ("key_from_printable: malloc (%d) failed", *datalen);
	  return;
a183 8
      *datalen = hex2raw (key, *data, *datalen);
      break;

    default:
      log_error ("key_from_printable: unknown/unsupported key type %d", type);
      *data = 0;
      break;
    }
@


1.13
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.12 2002/09/11 09:50:44 ho Exp $	*/
d186 1
@


1.12
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.11 2002/06/10 18:08:58 ho Exp $	*/
d71 2
a72 2
	      log_error("key_serialize: malloc (%lu) failed",
		(unsigned long)*datalen);
d83 2
a84 2
	      log_error("key_serialize: malloc (%lu) failed",
		(unsigned long)*datalen);
@


1.11
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.10 2002/06/01 07:44:21 deraadt Exp $	*/
d61 1
a61 1
      *data = strdup ((char *)key);
d133 1
a133 1
      return strdup (data);
d164 1
a164 1
		    int *datalen)
d170 1
a170 1
      *data = strdup (key);
@


1.10
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.9 2002/03/06 13:55:12 ho Exp $	*/
a26 1
#include "dyn.h"
d42 1
a42 1
      LC (RSA_free, (key));
d67 1
a67 1
	  *datalen = LC (i2d_RSAPublicKey, ((RSA *)key, NULL));
d75 1
a75 1
	  *datalen = LC (i2d_RSAPublicKey, ((RSA *)key, &p));
d79 1
a79 1
	  *datalen = LC (i2d_RSAPrivateKey, ((RSA *)key, NULL));
d87 1
a87 1
	  *datalen = LC (i2d_RSAPrivateKey, ((RSA *)key, &p));
d139 1
a139 2
	  return LC (d2i_RSAPublicKey, (NULL, (const u_int8_t **)&data,
					datalen));
d141 1
a141 2
	  return LC (d2i_RSAPrivateKey, (NULL, (const u_int8_t **)&data,
					 datalen));
d144 1
a144 1
	  return LC (d2i_RSAPublicKey, (NULL, &data, datalen));
d146 1
a146 1
	  return LC (d2i_RSAPrivateKey, (NULL, &data, datalen));
@


1.9
log
@Compile without warnings for older/newer OpenSSL.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.8 2002/03/06 10:02:32 ho Exp $	*/
d72 2
a73 1
	      log_error("key_serialize: malloc (%d) failed", *datalen);
d84 2
a85 1
	      log_error("key_serialize: malloc (%d) failed", *datalen);
@


1.8
log
@Fix a couple of snprintf length bugs. Same problem <chris@@stallion.oz.au>
found for policy passphrases.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.7 2002/03/05 00:10:43 deraadt Exp $	*/
d127 1
a127 1
key_internalize (int type, int private, const u_int8_t *data, int datalen)
d136 8
d148 1
@


1.7
log
@handle constification from new openssl
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.6 2002/01/23 18:44:47 ho Exp $	*/
d109 1
a109 1
      s = malloc (datalen * 2);
d112 1
a112 1
	  log_error ("key_printable: malloc (%d) failed", datalen * 2);
d116 1
a116 1
	snprintf (s + (2 * i), 2 * (datalen - i), "%02x", data[i]);
@


1.6
log
@the last few sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.5 2001/10/26 16:02:20 ho Exp $	*/
d127 1
a127 1
key_internalize (int type, int private, u_int8_t *data, int datalen)
@


1.5
log
@libcrypto.h should be included. Sort includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.4 2001/07/02 02:28:35 deraadt Exp $	*/
d116 1
a116 1
	sprintf (s + (2 * i), "%02x", data[i]);
@


1.4
log
@make the alpha happy
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.3 2001/07/01 19:48:43 niklas Exp $	*/
d28 3
a31 2
#include "log.h"
#include "key.h"
@


1.3
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.2 2001/06/25 05:15:11 angelos Exp $	*/
d53 1
a53 1
key_serialize (int type, int private, void *key, u_int8_t **data, int *datalen)
@


1.2
log
@Copyright update.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.1 2001/05/31 20:20:07 angelos Exp $	*/
d69 1
a69 1
	  if (*data == NULL)
d76 1
d80 1
a80 1
	  if (*data == NULL)
d106 1
d109 1
a109 1
      if (s == NULL)
d112 1
a112 1
	  return NULL;
d117 1
d120 1
a120 1
      return NULL;
d124 1
a124 1
/* Convert from serialized to internal */
d141 1
a141 1
	  return NULL;
d149 1
a149 1
  return NULL;
d163 1
d167 1
a167 1
      if (*data == NULL)
d174 1
@


1.1
log
@Key handling routines.
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/

d5 1
a5 1
 * Copyright (c) 2000 Angelos D. Keromytis.
d7 1
a7 1
 * Permission to use, copy, and modify this software without fee
@

