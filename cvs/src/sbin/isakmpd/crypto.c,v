head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.12
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.4
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.8
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.6
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.31.0.10
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.8
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.6
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.29.0.14
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.10
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.12
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.8
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.6
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.8
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.6
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.4
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.32;
commitid	CLwtYUTkBZ3FXV1w;

1.32
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.10.19.07.47.34;	author mikeb;	state Exp;
branches;
next	1.30;

1.30
date	2010.10.15.10.18.42;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.07.18.25.30;	author cloder;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.08.22.32.09;	author cloder;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.08.18.44.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.08.16.20.30;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.08.16.06.25;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.08.16.04.17;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.05.18.13.20;	author cloder;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.14.08.42.56;	author hshoexer;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.31.10.54.46;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.24.11.12.31;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.24.10.13.43;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.28.14.43.35;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.24.04.42.48;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.08.08.41.41;	author niklas;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2000.02.25.17.23.39;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.19.19.31.32;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.26.15.23.04;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.04.19.21.22.49;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.04.05.21.00.27;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.03.35.54;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2001.05.08.12.45.22;	author ho;	state Exp;
branches;
next	;

1.16.2.1
date	2004.01.13.22.50.07;	author brad;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@/* $OpenBSD: crypto.c,v 1.32 2013/03/21 04:30:14 deraadt Exp $	 */
/* $EOM: crypto.c,v 1.32 2000/03/07 20:08:51 niklas Exp $	 */

/*
 * Copyright (c) 1998 Niels Provos.  All rights reserved.
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <stdlib.h>
#include <string.h>

#include "crypto.h"
#include "log.h"

enum cryptoerr  des3_init(struct keystate *, u_int8_t *, u_int16_t);
enum cryptoerr  blf_init(struct keystate *, u_int8_t *, u_int16_t);
enum cryptoerr  cast_init(struct keystate *, u_int8_t *, u_int16_t);
enum cryptoerr  aes_init(struct keystate *, u_int8_t *, u_int16_t);
void            des3_encrypt(struct keystate *, u_int8_t *, u_int16_t);
void            des3_decrypt(struct keystate *, u_int8_t *, u_int16_t);
void            blf_encrypt(struct keystate *, u_int8_t *, u_int16_t);
void            blf_decrypt(struct keystate *, u_int8_t *, u_int16_t);
void            cast1_encrypt(struct keystate *, u_int8_t *, u_int16_t);
void            cast1_decrypt(struct keystate *, u_int8_t *, u_int16_t);
void            aes_encrypt(struct keystate *, u_int8_t *, u_int16_t);
void            aes_decrypt(struct keystate *, u_int8_t *, u_int16_t);

struct crypto_xf transforms[] = {
	{
		TRIPLEDES_CBC, "Triple-DES (CBC-Mode)", 24, 24,
		BLOCKSIZE, 0,
		des3_init,
		des3_encrypt, des3_decrypt
	},
	{
		BLOWFISH_CBC, "Blowfish (CBC-Mode)", 12, 56,
		BLOCKSIZE, 0,
		blf_init,
		blf_encrypt, blf_decrypt
	},
	{
		CAST_CBC, "CAST (CBC-Mode)", 12, 16,
		BLOCKSIZE, 0,
		cast_init,
		cast1_encrypt, cast1_decrypt
	},
	{
		AES_CBC, "AES (CBC-Mode)", 16, 32,
		AES_BLOCK_SIZE, 0,
		aes_init,
		aes_encrypt, aes_decrypt
	},
};

enum cryptoerr
des3_init(struct keystate *ks, u_int8_t *key, u_int16_t len)
{
	DES_set_odd_parity((void *)key);
	DES_set_odd_parity((void *)(key + 8));
	DES_set_odd_parity((void *)(key + 16));

	/* As of the draft Tripe-DES does not check for weak keys */
	DES_set_key((void *)key, &ks->ks_des[0]);
	DES_set_key((void *)(key + 8), &ks->ks_des[1]);
	DES_set_key((void *)(key + 16), &ks->ks_des[2]);

	return EOKAY;
}

void
des3_encrypt(struct keystate *ks, u_int8_t *data, u_int16_t len)
{
	u_int8_t        iv[MAXBLK];

	memcpy(iv, ks->riv, ks->xf->blocksize);
	DES_ede3_cbc_encrypt((void *)data, (void *)data, len, &ks->ks_des[0],
	    &ks->ks_des[1], &ks->ks_des[2], (void *)iv, DES_ENCRYPT);
}

void
des3_decrypt(struct keystate *ks, u_int8_t *data, u_int16_t len)
{
	u_int8_t        iv[MAXBLK];

	memcpy(iv, ks->riv, ks->xf->blocksize);
	DES_ede3_cbc_encrypt((void *)data, (void *)data, len, &ks->ks_des[0],
	    &ks->ks_des[1], &ks->ks_des[2], (void *)iv, DES_DECRYPT);
}

enum cryptoerr
blf_init(struct keystate *ks, u_int8_t *key, u_int16_t len)
{
	blf_key(&ks->ks_blf, key, len);

	return EOKAY;
}

void
blf_encrypt(struct keystate *ks, u_int8_t *data, u_int16_t len)
{
	u_int16_t       i, blocksize = ks->xf->blocksize;
	u_int8_t       *iv = ks->liv;
	u_int32_t       xl, xr;

	memcpy(iv, ks->riv, blocksize);

	for (i = 0; i < len; data += blocksize, i += blocksize) {
		XOR64(data, iv);
		xl = GET_32BIT_BIG(data);
		xr = GET_32BIT_BIG(data + 4);
		Blowfish_encipher(&ks->ks_blf, &xl, &xr);
		SET_32BIT_BIG(data, xl);
		SET_32BIT_BIG(data + 4, xr);
		SET64(iv, data);
	}
}

void
blf_decrypt(struct keystate *ks, u_int8_t *data, u_int16_t len)
{
	u_int16_t       i, blocksize = ks->xf->blocksize;
	u_int32_t       xl, xr;

	data += len - blocksize;
	for (i = len - blocksize; i >= blocksize; data -= blocksize,
	    i -= blocksize) {
		xl = GET_32BIT_BIG(data);
		xr = GET_32BIT_BIG(data + 4);
		Blowfish_decipher(&ks->ks_blf, &xl, &xr);
		SET_32BIT_BIG(data, xl);
		SET_32BIT_BIG(data + 4, xr);
		XOR64(data, data - blocksize);

	}
	xl = GET_32BIT_BIG(data);
	xr = GET_32BIT_BIG(data + 4);
	Blowfish_decipher(&ks->ks_blf, &xl, &xr);
	SET_32BIT_BIG(data, xl);
	SET_32BIT_BIG(data + 4, xr);
	XOR64(data, ks->riv);
}

enum cryptoerr
cast_init(struct keystate *ks, u_int8_t *key, u_int16_t len)
{
	CAST_set_key(&ks->ks_cast, len, key);
	return EOKAY;
}

void
cast1_encrypt(struct keystate *ks, u_int8_t *data, u_int16_t len)
{
	memcpy(ks->liv, ks->riv, ks->xf->blocksize);
	CAST_cbc_encrypt(data, data, len, &ks->ks_cast, ks->liv, 1);
}

void
cast1_decrypt(struct keystate *ks, u_int8_t *data, u_int16_t len)
{
	CAST_cbc_encrypt(data, data, len, &ks->ks_cast, ks->riv, 0);
}

enum cryptoerr
aes_init(struct keystate *ks, u_int8_t *key, u_int16_t len)
{
	AES_set_encrypt_key(key, len << 3, &ks->ks_aes[0]);
	AES_set_decrypt_key(key, len << 3, &ks->ks_aes[1]);
	return EOKAY;
}

void
aes_encrypt(struct keystate *ks, u_int8_t *data, u_int16_t len)
{
	u_int8_t        iv[MAXBLK];

	memcpy(iv, ks->riv, ks->xf->blocksize);
	AES_cbc_encrypt(data, data, len, &ks->ks_aes[0], iv, AES_ENCRYPT);
}

void
aes_decrypt(struct keystate *ks, u_int8_t *data, u_int16_t len)
{
	u_int8_t        iv[MAXBLK];

	memcpy(iv, ks->riv, ks->xf->blocksize);
	AES_cbc_encrypt(data, data, len, &ks->ks_aes[1], iv, AES_DECRYPT);
}

struct crypto_xf *
crypto_get(enum transform id)
{
	size_t          i;

	for (i = 0; i < sizeof transforms / sizeof transforms[0]; i++)
		if (id == transforms[i].id)
			return &transforms[i];

	return 0;
}

struct keystate *
crypto_init(struct crypto_xf *xf, u_int8_t *key, u_int16_t len,
    enum cryptoerr *err)
{
	struct keystate *ks;

	if (len < xf->keymin || len > xf->keymax) {
		LOG_DBG((LOG_CRYPTO, 10, "crypto_init: invalid key length %d",
		    len));
		*err = EKEYLEN;
		return 0;
	}
	ks = calloc(1, sizeof *ks);
	if (!ks) {
		log_error("crypto_init: calloc (1, %lu) failed",
		    (unsigned long)sizeof *ks);
		*err = ENOCRYPTO;
		return 0;
	}
	ks->xf = xf;

	/* Setup the IV.  */
	ks->riv = ks->iv;
	ks->liv = ks->iv2;

	LOG_DBG_BUF((LOG_CRYPTO, 40, "crypto_init: key", key, len));

	*err = xf->init(ks, key, len);
	if (*err != EOKAY) {
		LOG_DBG((LOG_CRYPTO, 30, "crypto_init: weak key found for %s",
		    xf->name));
		free(ks);
		return 0;
	}
	return ks;
}

void
crypto_update_iv(struct keystate *ks)
{
	u_int8_t       *tmp;

	tmp = ks->riv;
	ks->riv = ks->liv;
	ks->liv = tmp;

	LOG_DBG_BUF((LOG_CRYPTO, 50, "crypto_update_iv: updated IV", ks->riv,
	    ks->xf->blocksize));
}

void
crypto_init_iv(struct keystate *ks, u_int8_t *buf, size_t len)
{
	memcpy(ks->riv, buf, len);

	LOG_DBG_BUF((LOG_CRYPTO, 50, "crypto_init_iv: initialized IV", ks->riv,
	    len));
}

void
crypto_encrypt(struct keystate *ks, u_int8_t *buf, u_int16_t len)
{
	LOG_DBG_BUF((LOG_CRYPTO, 70, "crypto_encrypt: before encryption", buf,
	    len));
	ks->xf->encrypt(ks, buf, len);
	memcpy(ks->liv, buf + len - ks->xf->blocksize, ks->xf->blocksize);
	LOG_DBG_BUF((LOG_CRYPTO, 70, "crypto_encrypt: after encryption", buf,
	    len));
}

void
crypto_decrypt(struct keystate *ks, u_int8_t *buf, u_int16_t len)
{
	LOG_DBG_BUF((LOG_CRYPTO, 70, "crypto_decrypt: before decryption", buf,
	    len));
	/*
	 * XXX There is controversy about the correctness of updating the IV
	 * like this.
         */
	memcpy(ks->liv, buf + len - ks->xf->blocksize, ks->xf->blocksize);
	ks->xf->decrypt(ks, buf, len);
	LOG_DBG_BUF((LOG_CRYPTO, 70, "crypto_decrypt: after decryption", buf,
	    len));
}

/* Make a copy of the keystate pointed to by OKS.  */
struct keystate *
crypto_clone_keystate(struct keystate *oks)
{
	struct keystate *ks;

	ks = malloc(sizeof *ks);
	if (!ks) {
		log_error("crypto_clone_keystate: malloc (%lu) failed",
		    (unsigned long)sizeof *ks);
		return 0;
	}
	memcpy(ks, oks, sizeof *ks);
	if (oks->riv == oks->iv) {
		ks->riv = ks->iv;
		ks->liv = ks->iv2;
	} else {
		ks->riv = ks->iv2;
		ks->liv = ks->iv;
	}
	return ks;
}
@


1.32
log
@remove excessive includes
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.31 2010/10/19 07:47:34 mikeb Exp $	 */
a39 1
enum cryptoerr  des1_init(struct keystate *, u_int8_t *, u_int16_t);
a43 2
void            des1_encrypt(struct keystate *, u_int8_t *, u_int16_t);
void            des1_decrypt(struct keystate *, u_int8_t *, u_int16_t);
a54 6
		DES_CBC, "Data Encryption Standard (CBC-Mode)", 8, 8,
		BLOCKSIZE, 0,
		des1_init,
		des1_encrypt, des1_decrypt
	},
	{
a78 27

enum cryptoerr
des1_init(struct keystate *ks, u_int8_t *key, u_int16_t len)
{
	/* DES_set_key returns -1 for parity problems, and -2 for weak keys */
	DES_set_odd_parity((void *)key);
	switch (DES_set_key((void *)key, &ks->ks_des[0])) {
	case -2:
		return EWEAKKEY;
	default:
		return EOKAY;
	}
}

void
des1_encrypt(struct keystate *ks, u_int8_t *d, u_int16_t len)
{
	DES_cbc_encrypt((void *)d, (void *)d, len, &ks->ks_des[0], (void *)ks->riv,
	    DES_ENCRYPT);
}

void
des1_decrypt(struct keystate *ks, u_int8_t *d, u_int16_t len)
{
	DES_cbc_encrypt((void *)d, (void *)d, len, &ks->ks_des[0], (void *)ks->riv,
	    DES_DECRYPT);
}
@


1.31
log
@convert to fuse cast from the libcrypto.  with a simplification nit from
blambert, ok jsg, "seems ok" todd
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.30 2010/10/15 10:18:42 jsg Exp $	 */
d33 1
a33 1
#include <sys/param.h>
@


1.30
log
@Switch the remaining users of libdes in src to libcrypto,
telnet portion partially from the latest heimdal.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.29 2007/05/07 18:25:30 cloder Exp $	 */
d207 1
a207 1
	cast_setkey(&ks->ks_cast, key, len);
d214 2
a215 10
	u_int16_t       i, blocksize = ks->xf->blocksize;
	u_int8_t       *iv = ks->liv;

	memcpy(iv, ks->riv, blocksize);

	for (i = 0; i < len; data += blocksize, i += blocksize) {
		XOR64(data, iv);
		cast_encrypt(&ks->ks_cast, data, data);
		SET64(iv, data);
	}
d221 1
a221 10
	u_int16_t       i, blocksize = ks->xf->blocksize;

	data += len - blocksize;
	for (i = len - blocksize; i >= blocksize; data -= blocksize,
	    i -= blocksize) {
		cast_decrypt(&ks->ks_cast, data, data);
		XOR64(data, data - blocksize);
	}
	cast_decrypt(&ks->ks_cast, data, data);
	XOR64(data, ks->riv);
@


1.29
log
@Bump crypto buffer logging (before crypto/after crypto) to level 70 from
level 30. This was a huge cause of log spam at level 30 and below, and is
really not that useful.
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.28 2005/04/08 22:32:09 cloder Exp $	 */
d92 3
a94 3
	/* des_set_key returns -1 for parity problems, and -2 for weak keys */
	des_set_odd_parity((void *)key);
	switch (des_set_key((void *)key, ks->ks_des[0])) {
d105 1
a105 1
	des_cbc_encrypt((void *)d, (void *)d, len, ks->ks_des[0], (void *)ks->riv,
d112 1
a112 1
	des_cbc_encrypt((void *)d, (void *)d, len, ks->ks_des[0], (void *)ks->riv,
d119 3
a121 3
	des_set_odd_parity((void *)key);
	des_set_odd_parity((void *)(key + 8));
	des_set_odd_parity((void *)(key + 16));
d124 3
a126 3
	des_set_key((void *)key, ks->ks_des[0]);
	des_set_key((void *)(key + 8), ks->ks_des[1]);
	des_set_key((void *)(key + 16), ks->ks_des[2]);
d137 2
a138 2
	des_ede3_cbc_encrypt((void *)data, (void *)data, len, ks->ks_des[0],
	    ks->ks_des[1], ks->ks_des[2], (void *)iv, DES_ENCRYPT);
d147 2
a148 2
	des_ede3_cbc_encrypt((void *)data, (void *)data, len, ks->ks_des[0],
	    ks->ks_des[1], ks->ks_des[2], (void *)iv, DES_DECRYPT);
@


1.28
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.27 2005/04/08 18:44:04 deraadt Exp $	 */
d341 1
a341 1
	LOG_DBG_BUF((LOG_CRYPTO, 30, "crypto_encrypt: before encryption", buf,
d345 1
a345 1
	LOG_DBG_BUF((LOG_CRYPTO, 30, "crypto_encrypt: after encryption", buf,
d352 1
a352 1
	LOG_DBG_BUF((LOG_CRYPTO, 30, "crypto_decrypt: before decryption", buf,
d360 1
a360 1
	LOG_DBG_BUF((LOG_CRYPTO, 30, "crypto_decrypt: after decryption", buf,
@


1.27
log
@simplify
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.26 2005/04/08 16:20:30 deraadt Exp $	 */
a35 2

#include "sysdep.h"
@


1.26
log
@kill USE_DES and USE_TRIPLEDES, why was it ever a choice even?
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.25 2005/04/08 16:06:25 deraadt Exp $	 */
a90 7
/* Hmm, the function prototypes for des are really dumb */
#ifdef __OpenBSD__
#define DC	(des_cblock *)
#else
#define DC	(void *)
#endif

d95 2
a96 2
	des_set_odd_parity(DC key);
	switch (des_set_key(DC key, ks->ks_des[0])) {
d107 1
a107 1
	des_cbc_encrypt(DC d, DC d, len, ks->ks_des[0], DC ks->riv,
d114 1
a114 1
	des_cbc_encrypt(DC d, DC d, len, ks->ks_des[0], DC ks->riv,
d121 3
a123 3
	des_set_odd_parity(DC key);
	des_set_odd_parity(DC(key + 8));
	des_set_odd_parity(DC(key + 16));
d126 3
a128 3
	des_set_key(DC key, ks->ks_des[0]);
	des_set_key(DC(key + 8), ks->ks_des[1]);
	des_set_key(DC(key + 16), ks->ks_des[2]);
d139 2
a140 2
	des_ede3_cbc_encrypt(DC data, DC data, len, ks->ks_des[0],
	    ks->ks_des[1], ks->ks_des[2], DC iv, DES_ENCRYPT);
d149 2
a150 2
	des_ede3_cbc_encrypt(DC data, DC data, len, ks->ks_des[0],
	    ks->ks_des[1], ks->ks_des[2], DC iv, DES_DECRYPT);
a151 1
#undef DC
@


1.25
log
@app.c
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.24 2005/04/08 16:04:17 deraadt Exp $	 */
a58 1
#ifdef USE_DES
a64 2
#endif
#ifdef USE_TRIPLEDES
a70 1
#endif
a124 1
#ifdef USE_TRIPLEDES
a159 1
#endif				/* USE_TRIPLEDES */
@


1.24
log
@un-ifdef USE_BLOWFISH
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.23 2005/04/05 18:13:20 cloder Exp $	 */
a80 1
#ifdef USE_CAST
a86 2
#endif
#ifdef USE_AES
a92 1
#endif
a219 1
#ifdef USE_CAST
a255 1
#endif				/* USE_CAST */
a256 1
#ifdef USE_AES
a281 1
#endif				/* USE_AES */
@


1.23
log
@Do not log before/after crypto blobs at log level 10.  Makes -DA=10
useable without enduring pages of hex. OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.22 2004/06/14 09:55:41 ho Exp $	 */
a74 1
#ifdef USE_BLOWFISH
a80 1
#endif
a170 1
#ifdef USE_BLOWFISH
a222 1
#endif				/* USE_BLOWFISH */
@


1.22
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.21 2004/05/14 08:42:56 hshoexer Exp $	 */
d369 1
a369 1
	LOG_DBG_BUF((LOG_CRYPTO, 10, "crypto_encrypt: before encryption", buf,
d380 1
a380 1
	LOG_DBG_BUF((LOG_CRYPTO, 10, "crypto_decrypt: before decryption", buf,
@


1.21
log
@Some more KNF, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.20 2004/04/15 18:39:25 deraadt Exp $	 */
d61 2
a62 1
		DES_CBC, "Data Encryption Standard (CBC-Mode)", 8, 8, BLOCKSIZE, 0,
d69 2
a70 1
		TRIPLEDES_CBC, "Triple-DES (CBC-Mode)", 24, 24, BLOCKSIZE, 0,
d77 2
a78 1
		BLOWFISH_CBC, "Blowfish (CBC-Mode)", 12, 56, BLOCKSIZE, 0,
d85 2
a86 1
		CAST_CBC, "CAST (CBC-Mode)", 12, 16, BLOCKSIZE, 0,
d93 2
a94 1
		AES_CBC, "AES (CBC-Mode)", 16, 32, AES_BLOCK_SIZE, 0,
d124 2
a125 1
	des_cbc_encrypt(DC d, DC d, len, ks->ks_des[0], DC ks->riv, DES_ENCRYPT);
d131 2
a132 1
	des_cbc_encrypt(DC d, DC d, len, ks->ks_des[0], DC ks->riv, DES_DECRYPT);
@


1.20
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.c,v 1.19 2004/03/31 10:54:46 ho Exp $	 */
d104 1
a104 1
des1_init(struct keystate * ks, u_int8_t * key, u_int16_t len)
d117 1
a117 1
des1_encrypt(struct keystate * ks, u_int8_t * d, u_int16_t len)
d123 1
a123 1
des1_decrypt(struct keystate * ks, u_int8_t * d, u_int16_t len)
d130 1
a130 1
des3_init(struct keystate * ks, u_int8_t * key, u_int16_t len)
d145 1
a145 1
des3_encrypt(struct keystate * ks, u_int8_t * data, u_int16_t len)
d150 2
a151 2
	des_ede3_cbc_encrypt(DC data, DC data, len, ks->ks_des[0], ks->ks_des[1],
			     ks->ks_des[2], DC iv, DES_ENCRYPT);
d155 1
a155 1
des3_decrypt(struct keystate * ks, u_int8_t * data, u_int16_t len)
d160 2
a161 2
	des_ede3_cbc_encrypt(DC data, DC data, len, ks->ks_des[0], ks->ks_des[1],
			     ks->ks_des[2], DC iv, DES_DECRYPT);
d168 1
a168 1
blf_init(struct keystate * ks, u_int8_t * key, u_int16_t len)
d176 1
a176 1
blf_encrypt(struct keystate * ks, u_int8_t * data, u_int16_t len)
d196 1
a196 1
blf_decrypt(struct keystate * ks, u_int8_t * data, u_int16_t len)
d202 2
a203 1
	for (i = len - blocksize; i >= blocksize; data -= blocksize, i -= blocksize) {
d223 1
a223 1
cast_init(struct keystate * ks, u_int8_t * key, u_int16_t len)
d230 1
a230 1
cast1_encrypt(struct keystate * ks, u_int8_t * data, u_int16_t len)
d245 1
a245 1
cast1_decrypt(struct keystate * ks, u_int8_t * data, u_int16_t len)
d250 2
a251 1
	for (i = len - blocksize; i >= blocksize; data -= blocksize, i -= blocksize) {
d262 1
a262 1
aes_init(struct keystate * ks, u_int8_t * key, u_int16_t len)
d270 1
a270 1
aes_encrypt(struct keystate * ks, u_int8_t * data, u_int16_t len)
d279 1
a279 1
aes_decrypt(struct keystate * ks, u_int8_t * data, u_int16_t len)
d301 2
a302 2
crypto_init(struct crypto_xf * xf, u_int8_t * key, u_int16_t len,
	    enum cryptoerr * err)
d307 2
a308 1
		LOG_DBG((LOG_CRYPTO, 10, "crypto_init: invalid key length %d", len));
d315 1
a315 1
			  (unsigned long) sizeof *ks);
d330 1
a330 1
			 xf->name));
d338 1
a338 1
crypto_update_iv(struct keystate * ks)
d347 1
a347 1
		     ks->xf->blocksize));
d351 1
a351 1
crypto_init_iv(struct keystate * ks, u_int8_t * buf, size_t len)
d356 1
a356 1
		     len));
d360 1
a360 1
crypto_encrypt(struct keystate * ks, u_int8_t * buf, u_int16_t len)
d363 1
a363 1
		     len));
d367 1
a367 1
		     len));
d371 1
a371 1
crypto_decrypt(struct keystate * ks, u_int8_t * buf, u_int16_t len)
d374 1
a374 1
		     len));
d382 1
a382 1
		     len));
d387 1
a387 1
crypto_clone_keystate(struct keystate * oks)
d394 1
a394 1
			  (unsigned long) sizeof *ks);
@


1.19
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: crypto.c,v 1.18 2003/09/24 11:12:31 markus Exp $	*/
/*	$EOM: crypto.c,v 1.32 2000/03/07 20:08:51 niklas Exp $	*/
d42 15
a56 15
enum cryptoerr des1_init (struct keystate *, u_int8_t *, u_int16_t);
enum cryptoerr des3_init (struct keystate *, u_int8_t *, u_int16_t);
enum cryptoerr blf_init (struct keystate *, u_int8_t *, u_int16_t);
enum cryptoerr cast_init (struct keystate *, u_int8_t *, u_int16_t);
enum cryptoerr aes_init (struct keystate *, u_int8_t *, u_int16_t);
void des1_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void des1_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void des3_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void des3_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void blf_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void blf_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void cast1_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void cast1_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void aes_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void aes_decrypt (struct keystate *, u_int8_t *, u_int16_t);
d60 5
a64 5
  {
    DES_CBC, "Data Encryption Standard (CBC-Mode)", 8, 8, BLOCKSIZE, 0,
    des1_init,
    des1_encrypt, des1_decrypt
  },
d67 5
a71 5
  {
    TRIPLEDES_CBC, "Triple-DES (CBC-Mode)", 24, 24, BLOCKSIZE, 0,
    des3_init,
    des3_encrypt, des3_decrypt
  },
d74 5
a78 5
  {
    BLOWFISH_CBC, "Blowfish (CBC-Mode)", 12, 56, BLOCKSIZE, 0,
    blf_init,
    blf_encrypt, blf_decrypt
  },
d81 5
a85 5
  {
    CAST_CBC, "CAST (CBC-Mode)", 12, 16, BLOCKSIZE, 0,
    cast_init,
    cast1_encrypt, cast1_decrypt
  },
d88 5
a92 5
  {
    AES_CBC, "AES (CBC-Mode)", 16, 32, AES_BLOCK_SIZE, 0, 
    aes_init,
    aes_encrypt, aes_decrypt
  },
d104 1
a104 1
des1_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d106 8
a113 9
  /* des_set_key returns -1 for parity problems, and -2 for weak keys */
  des_set_odd_parity (DC key);
  switch (des_set_key (DC key, ks->ks_des[0]))
    {
    case -2:
      return EWEAKKEY;
    default:
      return EOKAY;
    }
d117 1
a117 1
des1_encrypt (struct keystate *ks, u_int8_t *d, u_int16_t len)
d119 1
a119 1
  des_cbc_encrypt (DC d, DC d, len, ks->ks_des[0], DC ks->riv, DES_ENCRYPT);
d123 1
a123 1
des1_decrypt (struct keystate *ks, u_int8_t *d, u_int16_t len)
d125 1
a125 1
  des_cbc_encrypt (DC d, DC d, len, ks->ks_des[0], DC ks->riv, DES_DECRYPT);
d130 1
a130 1
des3_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d132 3
a134 3
  des_set_odd_parity (DC key);
  des_set_odd_parity (DC (key + 8));
  des_set_odd_parity (DC (key + 16));
d136 4
a139 4
  /* As of the draft Tripe-DES does not check for weak keys */
  des_set_key (DC key, ks->ks_des[0]);
  des_set_key (DC (key + 8), ks->ks_des[1]);
  des_set_key (DC (key + 16), ks->ks_des[2]);
d141 1
a141 1
  return EOKAY;
d145 1
a145 1
des3_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d147 1
a147 1
  u_int8_t iv[MAXBLK];
d149 3
a151 3
  memcpy (iv, ks->riv, ks->xf->blocksize);
  des_ede3_cbc_encrypt (DC data, DC data, len, ks->ks_des[0], ks->ks_des[1],
			ks->ks_des[2], DC iv, DES_ENCRYPT);
d155 1
a155 1
des3_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d157 1
a157 1
  u_int8_t iv[MAXBLK];
d159 3
a161 3
  memcpy (iv, ks->riv, ks->xf->blocksize);
  des_ede3_cbc_encrypt (DC data, DC data, len, ks->ks_des[0], ks->ks_des[1],
			ks->ks_des[2], DC iv, DES_DECRYPT);
d164 1
a164 1
#endif /* USE_TRIPLEDES */
d168 1
a168 1
blf_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d170 1
a170 1
  blf_key (&ks->ks_blf, key, len);
d172 1
a172 1
  return EOKAY;
d176 1
a176 1
blf_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d178 3
a180 3
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int8_t *iv = ks->liv;
  u_int32_t xl, xr;
d182 1
a182 1
  memcpy (iv, ks->riv, blocksize);
d184 9
a192 10
  for (i = 0; i < len; data += blocksize, i += blocksize)
    {
      XOR64 (data, iv);
      xl = GET_32BIT_BIG (data);
      xr = GET_32BIT_BIG (data + 4);
      Blowfish_encipher (&ks->ks_blf, &xl, &xr);
      SET_32BIT_BIG (data, xl);
      SET_32BIT_BIG (data + 4, xr);
      SET64 (iv, data);
    }
d196 1
a196 1
blf_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d198 2
a199 2
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int32_t xl, xr;
d201 8
a208 9
  data += len - blocksize;
  for (i = len - blocksize; i >= blocksize; data -= blocksize, i -= blocksize)
    {
      xl = GET_32BIT_BIG (data);
      xr = GET_32BIT_BIG (data + 4);
      Blowfish_decipher (&ks->ks_blf, &xl, &xr);
      SET_32BIT_BIG (data, xl);
      SET_32BIT_BIG (data + 4, xr);
      XOR64 (data, data - blocksize);
d210 7
a216 7
    }
  xl = GET_32BIT_BIG (data);
  xr = GET_32BIT_BIG (data + 4);
  Blowfish_decipher (&ks->ks_blf, &xl, &xr);
  SET_32BIT_BIG (data, xl);
  SET_32BIT_BIG (data + 4, xr);
  XOR64 (data, ks->riv);
d218 1
a218 1
#endif /* USE_BLOWFISH */
d222 1
a222 1
cast_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d224 2
a225 2
  cast_setkey (&ks->ks_cast, key, len);
  return EOKAY;
d229 1
a229 1
cast1_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d231 2
a232 2
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int8_t *iv = ks->liv;
d234 1
a234 1
  memcpy (iv, ks->riv, blocksize);
d236 5
a240 6
  for (i = 0; i < len; data += blocksize, i += blocksize)
    {
      XOR64 (data, iv);
      cast_encrypt (&ks->ks_cast, data, data);
      SET64 (iv, data);
    }
d244 1
a244 1
cast1_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d246 1
a246 1
  u_int16_t i, blocksize = ks->xf->blocksize;
d248 7
a254 8
  data += len - blocksize;
  for (i = len - blocksize; i >= blocksize; data -= blocksize, i -= blocksize)
    {
      cast_decrypt (&ks->ks_cast, data, data);
      XOR64 (data, data - blocksize);
    }
  cast_decrypt (&ks->ks_cast, data, data);
  XOR64 (data, ks->riv);
d256 1
a256 1
#endif /* USE_CAST */
d260 1
a260 1
aes_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d262 3
a264 3
  AES_set_encrypt_key (key, len << 3, &ks->ks_aes[0]);
  AES_set_decrypt_key (key, len << 3, &ks->ks_aes[1]);
  return EOKAY;
d268 1
a268 1
aes_encrypt (struct keystate *ks,  u_int8_t *data, u_int16_t len)
d270 1
a270 1
  u_int8_t iv[MAXBLK];
d272 2
a273 2
  memcpy (iv, ks->riv, ks->xf->blocksize);
  AES_cbc_encrypt (data, data, len, &ks->ks_aes[0], iv, AES_ENCRYPT);
d277 1
a277 1
aes_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d279 1
a279 1
  u_int8_t iv[MAXBLK];
d281 2
a282 2
  memcpy (iv, ks->riv, ks->xf->blocksize);
  AES_cbc_encrypt (data, data, len, &ks->ks_aes[1], iv, AES_DECRYPT);
d284 1
a284 1
#endif /* USE_AES */
d287 1
a287 1
crypto_get (enum transform id)
d289 1
a289 1
  size_t i;
d291 3
a293 3
  for (i = 0; i < sizeof transforms / sizeof transforms[0]; i++)
    if (id == transforms[i].id)
      return &transforms[i];
d295 1
a295 1
  return 0;
d299 2
a300 2
crypto_init (struct crypto_xf *xf, u_int8_t *key, u_int16_t len,
	     enum cryptoerr *err)
d302 1
a302 1
  struct keystate *ks;
d304 13
a316 6
  if (len < xf->keymin || len > xf->keymax)
    {
      LOG_DBG ((LOG_CRYPTO, 10, "crypto_init: invalid key length %d", len));
      *err = EKEYLEN;
      return 0;
    }
d318 3
a320 8
  ks = calloc (1, sizeof *ks);
  if (!ks)
    {
      log_error ("crypto_init: calloc (1, %lu) failed",
	(unsigned long)sizeof *ks);
      *err = ENOCRYPTO;
      return 0;
    }
d322 1
a322 1
  ks->xf = xf;
d324 8
a331 16
  /* Setup the IV.  */
  ks->riv = ks->iv;
  ks->liv = ks->iv2;

  LOG_DBG_BUF ((LOG_CRYPTO, 40, "crypto_init: key", key, len));

  *err = xf->init (ks, key, len);
  if (*err != EOKAY)
    {
      LOG_DBG ((LOG_CRYPTO, 30, "crypto_init: weak key found for %s",
		xf->name));
      free (ks);
      return 0;
    }

  return ks;
d335 1
a335 1
crypto_update_iv (struct keystate *ks)
d337 1
a337 1
  u_int8_t *tmp;
d339 3
a341 3
  tmp = ks->riv;
  ks->riv = ks->liv;
  ks->liv = tmp;
d343 2
a344 2
  LOG_DBG_BUF ((LOG_CRYPTO, 50, "crypto_update_iv: updated IV", ks->riv,
		ks->xf->blocksize));
d348 1
a348 1
crypto_init_iv (struct keystate *ks, u_int8_t *buf, size_t len)
d350 1
a350 1
  memcpy (ks->riv, buf, len);
d352 2
a353 2
  LOG_DBG_BUF ((LOG_CRYPTO, 50, "crypto_init_iv: initialized IV", ks->riv,
		len));
d357 1
a357 1
crypto_encrypt (struct keystate *ks, u_int8_t *buf, u_int16_t len)
d359 6
a364 6
  LOG_DBG_BUF ((LOG_CRYPTO, 10, "crypto_encrypt: before encryption", buf,
		len));
  ks->xf->encrypt (ks, buf, len);
  memcpy (ks->liv, buf + len - ks->xf->blocksize, ks->xf->blocksize);
  LOG_DBG_BUF ((LOG_CRYPTO, 30, "crypto_encrypt: after encryption", buf,
		len));
d368 1
a368 1
crypto_decrypt (struct keystate *ks, u_int8_t *buf, u_int16_t len)
d370 10
a379 10
  LOG_DBG_BUF ((LOG_CRYPTO, 10, "crypto_decrypt: before decryption", buf,
		len));
  /*
   * XXX There is controversy about the correctness of updating the IV
   * like this.
   */
  memcpy (ks->liv, buf + len - ks->xf->blocksize, ks->xf->blocksize);
  ks->xf->decrypt (ks, buf, len);
  LOG_DBG_BUF ((LOG_CRYPTO, 30, "crypto_decrypt: after decryption", buf,
		len));
d384 1
a384 1
crypto_clone_keystate (struct keystate *oks)
d386 1
a386 1
  struct keystate *ks;
d388 15
a402 19
  ks = malloc (sizeof *ks);
  if (!ks)
    {
      log_error ("crypto_clone_keystate: malloc (%lu) failed",
	(unsigned long)sizeof *ks);
      return 0;
    }
  memcpy (ks, oks, sizeof *ks);
  if (oks->riv == oks->iv)
    {
      ks->riv = ks->iv;
      ks->liv = ks->iv2;
    }
  else
    {
      ks->riv = ks->iv2;
      ks->liv = ks->iv;
    }
  return ks;
@


1.18
log
@re-add AES, but without using EVP;
patch from Hans-Joerg.Hoexer at yerbouti.franken.de; ok ho@@
(interops with isakmpd+AES in OpenBSD 3.4)
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.17 2003/09/24 10:13:43 markus Exp $	*/
d294 1
a294 1
  int i;
@


1.17
log
@back out EVP change; causes fd leaks; ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.15 2003/08/06 21:08:06 millert Exp $	*/
d46 1
d55 2
d87 7
d263 28
d363 1
a363 1
  LOG_DBG_BUF ((LOG_CRYPTO, 50, "crypto_update_iv: initialized IV", ks->riv,
@


1.16
log
@support AES in phase 1, too. switch to OpenSSL EVP interface;
with Hans-Joerg.Hoexer at yerbouti.franken.de; ok ho@@
@
text
@a41 2
enum cryptoerr evp_init (struct keystate *, u_int8_t *, u_int16_t,
    const EVP_CIPHER *);
d46 8
a53 3
enum cryptoerr aes_init (struct keystate *, u_int8_t *, u_int16_t);
void evp_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void evp_decrypt (struct keystate *, u_int8_t *, u_int16_t);
d60 1
a60 1
    evp_encrypt, evp_decrypt
d67 1
a67 1
    evp_encrypt, evp_decrypt
d74 1
a74 1
    evp_encrypt, evp_decrypt
d81 1
a81 1
    evp_encrypt, evp_decrypt
d84 7
a90 6
#ifdef USE_AES
  {
    AES_CBC, "AES (CBC-Mode)", 16, 32, 2*BLOCKSIZE, 0,
    aes_init,
    evp_encrypt, evp_decrypt
  },
a91 1
};
a92 1
#ifdef USE_DES
d96 10
a105 1
  const EVP_CIPHER *evp;
d107 10
a116 2
  evp = EVP_des_cbc();
  return evp_init (ks, key, len, evp);
a117 1
#endif
d123 26
a148 1
  const EVP_CIPHER *evp;
d150 3
a152 2
  evp = EVP_des_ede3_cbc();
  return evp_init (ks, key, len, evp);
d154 2
a155 1
#endif
d161 1
a161 1
  const EVP_CIPHER *evp;
d163 1
a163 2
  evp = EVP_bf_cbc();
  return evp_init (ks, key, len, evp);
a164 1
#endif
d166 2
a167 3
#ifdef USE_CAST
enum cryptoerr
cast_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d169 5
a173 1
  const EVP_CIPHER *evp;
d175 10
a184 2
  evp = EVP_cast5_cbc();
  return evp_init (ks, key, len, evp);
a185 1
#endif
d187 2
a188 3
#ifdef USE_AES
enum cryptoerr
aes_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d190 2
a191 1
  const EVP_CIPHER *evp;
d193 2
a194 1
  switch (8 * len)
d196 7
a202 11
    case 128:
      evp = EVP_aes_128_cbc();
      break;
    case 192:
      evp = EVP_aes_192_cbc();
      break;
    case 256:
      evp = EVP_aes_256_cbc();
      break;
    default:
      return EKEYLEN;
d204 6
a209 1
  return evp_init (ks, key, len, evp);
d211 1
a211 1
#endif
d213 1
d215 1
a215 1
evp_init (struct keystate *ks, u_int8_t *key, u_int16_t len, const EVP_CIPHER *evp)
d217 1
a217 10
  EVP_CIPHER_CTX_init(&ks->ks_evpenc);
  EVP_CIPHER_CTX_init(&ks->ks_evpdec);

  if (EVP_CIPHER_key_length(evp) != len
      && !(EVP_CIPHER_flags(evp) & EVP_CIPH_VARIABLE_LENGTH))
    return EKEYLEN;
  if (EVP_CipherInit(&ks->ks_evpenc, evp, key, NULL, 1) <= 0)
    return EKEYLEN;
  if (EVP_CipherInit(&ks->ks_evpdec, evp, key, NULL, 0) <= 0)
    return EKEYLEN;
d222 1
a222 1
evp_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d224 11
a234 2
  (void) EVP_CipherInit(&ks->ks_evpenc, NULL, NULL, ks->riv, -1);
  EVP_Cipher(&ks->ks_evpenc, data, data, len);
d238 1
a238 1
evp_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d240 10
a249 2
  (void) EVP_CipherInit(&ks->ks_evpdec, NULL, NULL, ks->riv, -1);
  EVP_Cipher(&ks->ks_evpdec, data, data, len);
d251 1
@


1.16.2.1
log
@Fixes a few message handling flaws in isakmpd as reported by
Thomas Walpuski.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.18 2003/09/24 11:12:31 markus Exp $	*/
d42 2
d49 2
a50 10
void des1_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void des1_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void des3_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void des3_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void blf_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void blf_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void cast1_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void cast1_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void aes_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void aes_decrypt (struct keystate *, u_int8_t *, u_int16_t);
d57 1
a57 1
    des1_encrypt, des1_decrypt
d64 1
a64 1
    des3_encrypt, des3_decrypt
d71 1
a71 1
    blf_encrypt, blf_decrypt
d78 1
a78 1
    cast1_encrypt, cast1_decrypt
d83 1
a83 1
    AES_CBC, "AES (CBC-Mode)", 16, 32, AES_BLOCK_SIZE, 0, 
d85 1
a85 1
    aes_encrypt, aes_decrypt
d90 1
a90 7
/* Hmm, the function prototypes for des are really dumb */
#ifdef __OpenBSD__
#define DC	(des_cblock *)
#else
#define DC	(void *)
#endif

d94 1
a94 16
  /* des_set_key returns -1 for parity problems, and -2 for weak keys */
  des_set_odd_parity (DC key);
  switch (des_set_key (DC key, ks->ks_des[0]))
    {
    case -2:
      return EWEAKKEY;
    default:
      return EOKAY;
    }
}

void
des1_encrypt (struct keystate *ks, u_int8_t *d, u_int16_t len)
{
  des_cbc_encrypt (DC d, DC d, len, ks->ks_des[0], DC ks->riv, DES_ENCRYPT);
}
d96 2
a97 4
void
des1_decrypt (struct keystate *ks, u_int8_t *d, u_int16_t len)
{
  des_cbc_encrypt (DC d, DC d, len, ks->ks_des[0], DC ks->riv, DES_DECRYPT);
d99 1
d105 1
a105 8
  des_set_odd_parity (DC key);
  des_set_odd_parity (DC (key + 8));
  des_set_odd_parity (DC (key + 16));

  /* As of the draft Tripe-DES does not check for weak keys */
  des_set_key (DC key, ks->ks_des[0]);
  des_set_key (DC (key + 8), ks->ks_des[1]);
  des_set_key (DC (key + 16), ks->ks_des[2]);
d107 2
a108 1
  return EOKAY;
d110 1
a110 22

void
des3_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
{
  u_int8_t iv[MAXBLK];

  memcpy (iv, ks->riv, ks->xf->blocksize);
  des_ede3_cbc_encrypt (DC data, DC data, len, ks->ks_des[0], ks->ks_des[1],
			ks->ks_des[2], DC iv, DES_ENCRYPT);
}

void
des3_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
{
  u_int8_t iv[MAXBLK];

  memcpy (iv, ks->riv, ks->xf->blocksize);
  des_ede3_cbc_encrypt (DC data, DC data, len, ks->ks_des[0], ks->ks_des[1],
			ks->ks_des[2], DC iv, DES_DECRYPT);
}
#undef DC
#endif /* USE_TRIPLEDES */
d116 1
a116 1
  blf_key (&ks->ks_blf, key, len);
d118 2
a119 1
  return EOKAY;
d121 1
a121 47

void
blf_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
{
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int8_t *iv = ks->liv;
  u_int32_t xl, xr;

  memcpy (iv, ks->riv, blocksize);

  for (i = 0; i < len; data += blocksize, i += blocksize)
    {
      XOR64 (data, iv);
      xl = GET_32BIT_BIG (data);
      xr = GET_32BIT_BIG (data + 4);
      Blowfish_encipher (&ks->ks_blf, &xl, &xr);
      SET_32BIT_BIG (data, xl);
      SET_32BIT_BIG (data + 4, xr);
      SET64 (iv, data);
    }
}

void
blf_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
{
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int32_t xl, xr;

  data += len - blocksize;
  for (i = len - blocksize; i >= blocksize; data -= blocksize, i -= blocksize)
    {
      xl = GET_32BIT_BIG (data);
      xr = GET_32BIT_BIG (data + 4);
      Blowfish_decipher (&ks->ks_blf, &xl, &xr);
      SET_32BIT_BIG (data, xl);
      SET_32BIT_BIG (data + 4, xr);
      XOR64 (data, data - blocksize);

    }
  xl = GET_32BIT_BIG (data);
  xr = GET_32BIT_BIG (data + 4);
  Blowfish_decipher (&ks->ks_blf, &xl, &xr);
  SET_32BIT_BIG (data, xl);
  SET_32BIT_BIG (data + 4, xr);
  XOR64 (data, ks->riv);
}
#endif /* USE_BLOWFISH */
d127 1
a127 11
  cast_setkey (&ks->ks_cast, key, len);
  return EOKAY;
}

void
cast1_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
{
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int8_t *iv = ks->liv;

  memcpy (iv, ks->riv, blocksize);
d129 2
a130 6
  for (i = 0; i < len; data += blocksize, i += blocksize)
    {
      XOR64 (data, iv);
      cast_encrypt (&ks->ks_cast, data, data);
      SET64 (iv, data);
    }
d132 1
d134 3
a136 2
void
cast1_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d138 1
a138 1
  u_int16_t i, blocksize = ks->xf->blocksize;
d140 1
a140 2
  data += len - blocksize;
  for (i = len - blocksize; i >= blocksize; data -= blocksize, i -= blocksize)
d142 11
a152 2
      cast_decrypt (&ks->ks_cast, data, data);
      XOR64 (data, data - blocksize);
d154 1
a154 2
  cast_decrypt (&ks->ks_cast, data, data);
  XOR64 (data, ks->riv);
d156 1
a156 1
#endif /* USE_CAST */
a157 1
#ifdef USE_AES
d159 1
a159 1
aes_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d161 10
a170 2
  AES_set_encrypt_key (key, len << 3, &ks->ks_aes[0]);
  AES_set_decrypt_key (key, len << 3, &ks->ks_aes[1]);
d175 1
a175 1
aes_encrypt (struct keystate *ks,  u_int8_t *data, u_int16_t len)
d177 2
a178 4
  u_int8_t iv[MAXBLK];

  memcpy (iv, ks->riv, ks->xf->blocksize);
  AES_cbc_encrypt (data, data, len, &ks->ks_aes[0], iv, AES_ENCRYPT);
d182 1
a182 1
aes_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d184 2
a185 4
  u_int8_t iv[MAXBLK];

  memcpy (iv, ks->riv, ks->xf->blocksize);
  AES_cbc_encrypt (data, data, len, &ks->ks_aes[1], iv, AES_DECRYPT);
a186 1
#endif /* USE_AES */
d260 1
a260 1
  LOG_DBG_BUF ((LOG_CRYPTO, 50, "crypto_init_iv: initialized IV", ks->riv,
@


1.15
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.14 2003/06/03 14:28:16 ho Exp $	*/
d42 2
d48 3
a50 8
void des1_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void des1_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void des3_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void des3_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void blf_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void blf_decrypt (struct keystate *, u_int8_t *, u_int16_t);
void cast1_encrypt (struct keystate *, u_int8_t *, u_int16_t);
void cast1_decrypt (struct keystate *, u_int8_t *, u_int16_t);
d57 1
a57 1
    des1_encrypt, des1_decrypt
d64 1
a64 1
    des3_encrypt, des3_decrypt
d71 1
a71 1
    blf_encrypt, blf_decrypt
d78 8
a85 1
    cast1_encrypt, cast1_decrypt
d90 1
a90 7
/* Hmm, the function prototypes for des are really dumb */
#ifdef __OpenBSD__
#define DC	(des_cblock *)
#else
#define DC	(void *)
#endif

d94 1
a94 10
  /* des_set_key returns -1 for parity problems, and -2 for weak keys */
  des_set_odd_parity (DC key);
  switch (des_set_key (DC key, ks->ks_des[0]))
    {
    case -2:
      return EWEAKKEY;
    default:
      return EOKAY;
    }
}
d96 2
a97 10
void
des1_encrypt (struct keystate *ks, u_int8_t *d, u_int16_t len)
{
  des_cbc_encrypt (DC d, DC d, len, ks->ks_des[0], DC ks->riv, DES_ENCRYPT);
}

void
des1_decrypt (struct keystate *ks, u_int8_t *d, u_int16_t len)
{
  des_cbc_encrypt (DC d, DC d, len, ks->ks_des[0], DC ks->riv, DES_DECRYPT);
d99 1
d105 1
a105 8
  des_set_odd_parity (DC key);
  des_set_odd_parity (DC (key + 8));
  des_set_odd_parity (DC (key + 16));

  /* As of the draft Tripe-DES does not check for weak keys */
  des_set_key (DC key, ks->ks_des[0]);
  des_set_key (DC (key + 8), ks->ks_des[1]);
  des_set_key (DC (key + 16), ks->ks_des[2]);
d107 2
a108 1
  return EOKAY;
d110 1
a110 22

void
des3_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
{
  u_int8_t iv[MAXBLK];

  memcpy (iv, ks->riv, ks->xf->blocksize);
  des_ede3_cbc_encrypt (DC data, DC data, len, ks->ks_des[0], ks->ks_des[1],
			ks->ks_des[2], DC iv, DES_ENCRYPT);
}

void
des3_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
{
  u_int8_t iv[MAXBLK];

  memcpy (iv, ks->riv, ks->xf->blocksize);
  des_ede3_cbc_encrypt (DC data, DC data, len, ks->ks_des[0], ks->ks_des[1],
			ks->ks_des[2], DC iv, DES_DECRYPT);
}
#undef DC
#endif /* USE_TRIPLEDES */
d116 1
a116 1
  blf_key (&ks->ks_blf, key, len);
d118 2
a119 1
  return EOKAY;
d121 1
d123 3
a125 2
void
blf_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d127 1
a127 5
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int8_t *iv = ks->liv;
  u_int32_t xl, xr;

  memcpy (iv, ks->riv, blocksize);
d129 2
a130 10
  for (i = 0; i < len; data += blocksize, i += blocksize)
    {
      XOR64 (data, iv);
      xl = GET_32BIT_BIG (data);
      xr = GET_32BIT_BIG (data + 4);
      Blowfish_encipher (&ks->ks_blf, &xl, &xr);
      SET_32BIT_BIG (data, xl);
      SET_32BIT_BIG (data + 4, xr);
      SET64 (iv, data);
    }
d132 1
d134 3
a136 2
void
blf_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d138 1
a138 2
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int32_t xl, xr;
d140 1
a140 2
  data += len - blocksize;
  for (i = len - blocksize; i >= blocksize; data -= blocksize, i -= blocksize)
d142 11
a152 7
      xl = GET_32BIT_BIG (data);
      xr = GET_32BIT_BIG (data + 4);
      Blowfish_decipher (&ks->ks_blf, &xl, &xr);
      SET_32BIT_BIG (data, xl);
      SET_32BIT_BIG (data + 4, xr);
      XOR64 (data, data - blocksize);

d154 1
a154 6
  xl = GET_32BIT_BIG (data);
  xr = GET_32BIT_BIG (data + 4);
  Blowfish_decipher (&ks->ks_blf, &xl, &xr);
  SET_32BIT_BIG (data, xl);
  SET_32BIT_BIG (data + 4, xr);
  XOR64 (data, ks->riv);
d156 1
a156 1
#endif /* USE_BLOWFISH */
a157 1
#ifdef USE_CAST
d159 1
a159 1
cast_init (struct keystate *ks, u_int8_t *key, u_int16_t len)
d161 10
a170 1
  cast_setkey (&ks->ks_cast, key, len);
d175 1
a175 1
cast1_encrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d177 2
a178 11
  u_int16_t i, blocksize = ks->xf->blocksize;
  u_int8_t *iv = ks->liv;

  memcpy (iv, ks->riv, blocksize);

  for (i = 0; i < len; data += blocksize, i += blocksize)
    {
      XOR64 (data, iv);
      cast_encrypt (&ks->ks_cast, data, data);
      SET64 (iv, data);
    }
d182 1
a182 1
cast1_decrypt (struct keystate *ks, u_int8_t *data, u_int16_t len)
d184 2
a185 10
  u_int16_t i, blocksize = ks->xf->blocksize;

  data += len - blocksize;
  for (i = len - blocksize; i >= blocksize; data -= blocksize, i -= blocksize)
    {
      cast_decrypt (&ks->ks_cast, data, data);
      XOR64 (data, data - blocksize);
    }
  cast_decrypt (&ks->ks_cast, data, data);
  XOR64 (data, ks->riv);
a186 1
#endif /* USE_CAST */
@


1.14
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.13 2002/06/09 08:13:06 todd Exp $	*/
d350 1
a350 1
  ks->xf->decrypt (ks, buf, len);;
@


1.13
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.12 2002/06/01 07:44:21 deraadt Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.12
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.11 2001/02/24 04:42:48 angelos Exp $	*/
d146 1
a146 1
  des_ede3_cbc_encrypt (DC data, DC data, len, ks->ks_des[0], ks->ks_des[1], 
d156 1
a156 1
  des_ede3_cbc_encrypt (DC data, DC data, len, ks->ks_des[0], ks->ks_des[1], 
d161 1
a161 1
 
d197 1
a197 1
  
@


1.11
log
@Make DES a feature, so isakmpd can compile on Linux (most of the fixed
by newsham@@lava.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.10 2000/03/08 08:41:41 niklas Exp $	*/
d286 2
a287 1
      log_error ("crypto_init: calloc (1, %d) failed", sizeof *ks);
d369 2
a370 1
      log_error ("crypto_clone_keystate: malloc (%d) failed", sizeof *ks);
@


1.10
log
@Merge with EOM 1.32

author: niklas
Use a clearer pointer arithmetic

author: niklas
Multiple DES API support

author: niklas
argh

author: niklas
More braindamage with USE_ macros
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.9 2000/02/25 17:23:39 niklas Exp $	*/
d61 1
d67 1
@


1.10.4.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.c,v 1.11 2001/02/24 04:42:48 angelos Exp $	*/
a60 1
#ifdef USE_DES
a65 1
#endif
@


1.9
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: crypto.c,v 1.8 2000/02/19 19:31:32 niklas Exp $	*/
/*	$EOM: crypto.c,v 1.28 2000/02/20 19:58:36 niklas Exp $	*/
d127 2
a128 2
  des_set_odd_parity (DC key + 1);
  des_set_odd_parity (DC key + 2);
d132 2
a133 2
  des_set_key (DC key + 1, ks->ks_des[1]);
  des_set_key (DC key + 2, ks->ks_des[2]);
@


1.8
log
@Makefile: Merge with EOM 1.61
crypto.c: Merge with EOM 1.27
exchange.c: Merge with EOM 1.115
ike_quick_mode.c: Merge with EOM 1.115
x509.c: Merge with EOM 1.35
features/ec: Merge with EOM 1.1
features/aggressive: Merge with EOM 1.1
features/policy: Merge with EOM 1.1
features/x509: Merge with EOM 1.1

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: crypto.c,v 1.7 2000/01/26 15:23:04 niklas Exp $	*/
/*	$EOM: crypto.c,v 1.27 2000/02/19 07:46:30 niklas Exp $	*/
d276 1
a276 1
      log_debug (LOG_CRYPTO, 10, "crypto_init: invalid key length %d", len);
d295 1
a295 1
  log_debug_buf (LOG_CRYPTO, 40, "crypto_init: key", key, len);
d300 2
a301 2
      log_debug (LOG_CRYPTO, 30, "crypto_init: weak key found for %s",
		 xf->name);
d318 2
a319 2
  log_debug_buf (LOG_CRYPTO, 50, "crypto_update_iv: updated IV", ks->riv,
		 ks->xf->blocksize);
d327 2
a328 2
  log_debug_buf (LOG_CRYPTO, 50, "crypto_update_iv: initialized IV", ks->riv,
		 len);
d334 2
a335 2
  log_debug_buf (LOG_CRYPTO, 10, "crypto_encrypt: before encryption", buf,
		 len);
d338 2
a339 2
  log_debug_buf (LOG_CRYPTO, 30, "crypto_encrypt: after encryption", buf,
		 len);
d345 2
a346 2
  log_debug_buf (LOG_CRYPTO, 10, "crypto_decrypt: before decryption", buf,
		 len);
d353 2
a354 2
  log_debug_buf (LOG_CRYPTO, 30, "crypto_decrypt: after decryption", buf,
		 len);
@


1.7
log
@Merge with EOM 1.26

author: niklas
Be kind to libcrypto DES
@
text
@d1 2
a2 2
/*	$OpenBSD: crypto.c,v 1.6 1999/04/19 21:22:49 niklas Exp $	*/
/*	$EOM: crypto.c,v 1.26 1999/12/08 20:31:02 niklas Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
d66 1
d72 2
d79 2
d86 1
d122 1
d158 3
a160 1

d214 1
d216 1
d254 1
@


1.6
log
@./regress/x509/x509test.c: Merge with EOM 1.4
./dh.h: Merge with EOM 1.4
./math_ec2n.c: Merge with EOM 1.8
./crypto.c: Merge with EOM 1.25
./ike_quick_mode.c: Merge with EOM 1.82
./math_group.c: Merge with EOM 1.16
./math_ec2n.h: Merge with EOM 1.4

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.
@
text
@d1 2
a2 2
/*	$OpenBSD: crypto.c,v 1.5 1999/04/05 21:00:27 niklas Exp $	*/
/*	$EOM: crypto.c,v 1.25 1999/04/17 23:20:21 niklas Exp $	*/
d84 1
d86 3
@


1.5
log
@Merge with EOM 1.24
Better error messages, style

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: crypto.c,v 1.4 1999/02/26 03:35:54 niklas Exp $	*/
/*	$EOM: crypto.c,v 1.24 1999/04/05 07:57:03 niklas Exp $	*/
d62 1
a62 1
    DES_CBC, "Data Encryption Standard (CBC-Mode)", 8, 8, BLOCKSIZE, NULL, 
d67 1
a67 1
    TRIPLEDES_CBC, "Triple-DES (CBC-Mode)", 24, 24, BLOCKSIZE, NULL,
d72 1
a72 1
    BLOWFISH_CBC, "Blowfish (CBC-Mode)", 12, 56, BLOCKSIZE, NULL,
d77 1
a77 1
    CAST_CBC, "CAST (CBC-Mode)", 12, 16, BLOCKSIZE, NULL,
@


1.4
log
@Merge from the Ericsson repository
| revision 1.22
| date: 1999/02/25 11:38:50;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: crypto.c,v 1.3 1998/11/17 11:10:09 niklas Exp $	*/
/*	$EOM: crypto.c,v 1.22 1999/02/25 11:38:50 niklas Exp $	*/
d6 1
d256 1
a256 1
  struct keystate *ks = NULL;
d262 1
a262 1
      return NULL;
d265 2
a266 1
  if ((ks = calloc (1, sizeof (struct keystate))) == NULL)
d268 1
d270 1
a270 1
      return NULL;
d275 1
a275 1
  /* Set up the iv */
d287 1
a287 1
      return NULL;
d341 1
d349 4
a352 1
    return 0;
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: crypto.c,v 1.2 1998/11/15 00:43:51 niklas Exp $	*/
/*	$EOM: crypto.c,v 1.21 1998/11/12 15:31:04 niklas Exp $	*/
d40 2
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: crypto.c,v 1.1.1.1 1998/11/15 00:03:48 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: crypto.c,v 1.21 1998/11/12 15:31:04 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
