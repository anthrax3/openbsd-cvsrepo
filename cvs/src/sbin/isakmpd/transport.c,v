head	1.37;
access;
symbols
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.6
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.36.0.10
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.12
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.8
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.6
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.30
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.28
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.26
	OPENBSD_5_0:1.35.0.24
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.22
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.20
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.16
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.18
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.14
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.12
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.10
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.8
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.6
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.03.10.07.32.16;	author yasuoka;	state Exp;
branches;
next	1.36;
commitid	aGOfvj3wuWdmV0zv;

1.36
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.28.10.57.35;	author hshoexer;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.27.08.19.59;	author hshoexer;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.08.16.32.11;	author hshoexer;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.03.10.54.09;	author ho;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.21.13.09.00;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.14.09.55.42;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.18.02.03.28;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.20.09.14.14;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.14.14.49.08;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.07.21.59.22;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.26.11.37.16;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.05.05.54.50;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.23.23.11.02;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.09.22.09.53;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.10.13.35.12;	author niklas;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.10.07.06.57.34;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.25.17.23.42;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.05.01.20.43.45;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.04.30.22.33.09;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.04.30.11.46.48;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.04.27.21.12.31;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.04.19.21.04.00;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.03.51.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2001.05.08.12.45.25;	author ho;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Don't retransmit responses for unauthenticated messages.
Base on diff from Yuuichi Someya

ok markus reyk mikeb
@
text
@/* $OpenBSD: transport.c,v 1.36 2013/03/21 04:30:14 deraadt Exp $	 */
/* $EOM: transport.c,v 1.43 2000/10/10 12:36:39 provos Exp $	 */

/*
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001, 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/queue.h>
#include <netdb.h>
#include <string.h>

#include "conf.h"
#include "exchange.h"
#include "log.h"
#include "message.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "virtual.h"

/* If no retransmit limit is given, use this as a default.  */
#define RETRANSMIT_DEFAULT 10

LIST_HEAD(transport_method_list, transport_vtbl) transport_method_list;

/* Call the reinit function of the various transports.  */
void
transport_reinit(void)
{
	struct transport_vtbl *method;

	for (method = LIST_FIRST(&transport_method_list); method;
	    method = LIST_NEXT(method, link))
		if (method->reinit)
			method->reinit();
}

/* Initialize the transport maintenance module.  */
void
transport_init(void)
{
	LIST_INIT(&transport_list);
	LIST_INIT(&transport_method_list);
}

/* Register another transport T.  */
void
transport_setup(struct transport *t, int toplevel)
{
	if (toplevel) {
		/* Only the toplevel (virtual) transport has sendqueues.  */
		LOG_DBG((LOG_TRANSPORT, 70,
		    "transport_setup: virtual transport %p", t));
		TAILQ_INIT(&t->sendq);
		TAILQ_INIT(&t->prio_sendq);
		t->refcnt = 0;
	} else {
		/* udp and udp_encap trp goes into the transport list.  */
		LOG_DBG((LOG_TRANSPORT, 70,
		    "transport_setup: added %p to transport list", t));
		LIST_INSERT_HEAD(&transport_list, t, link);
		t->refcnt = 1;
	}
	t->flags = 0;
}

/* Add a referer to transport T.  */
void
transport_reference(struct transport *t)
{
	t->refcnt++;
	LOG_DBG((LOG_TRANSPORT, 95,
	    "transport_reference: transport %p now has %d references", t,
	    t->refcnt));
}

/*
 * Remove a referer from transport T, removing all of T when no referers left.
 */
void
transport_release(struct transport *t)
{
	LOG_DBG((LOG_TRANSPORT, 95,
	    "transport_release: transport %p had %d references", t,
	    t->refcnt));
	if (--t->refcnt)
		return;

	LOG_DBG((LOG_TRANSPORT, 70, "transport_release: freeing %p", t));
	t->vtbl->remove(t);
}

void
transport_report(void)
{
	struct virtual_transport *v;
	struct transport *t;
	struct message *msg;

	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link)) {
		LOG_DBG((LOG_REPORT, 0,
		    "transport_report: transport %p flags %x refcnt %d", t,
		    t->flags, t->refcnt));

		/* XXX Report sth on the virtual transport?  */
		t->vtbl->report(t);

		/*
		 * This is the reason message_dump_raw lives outside
		 * message.c.
		 */
		v = (struct virtual_transport *)t->virtual;
		if ((v->encap_is_active && v->encap == t) ||
		    (!v->encap_is_active && v->main == t)) {
			for (msg = TAILQ_FIRST(&t->virtual->prio_sendq); msg;
			    msg = TAILQ_NEXT(msg, link))
				message_dump_raw("udp_report(prio)", msg,
				    LOG_REPORT);

			for (msg = TAILQ_FIRST(&t->virtual->sendq); msg;
			    msg = TAILQ_NEXT(msg, link))
				message_dump_raw("udp_report", msg,
				    LOG_REPORT);
		}
	}
}

int
transport_prio_sendqs_empty(void)
{
	struct transport *t;

	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link))
		if (TAILQ_FIRST(&t->virtual->prio_sendq))
			return 0;
	return 1;
}

/* Register another transport method T.  */
void
transport_method_add(struct transport_vtbl *t)
{
	LIST_INSERT_HEAD(&transport_method_list, t, link);
}

/*
 * Build up a file descriptor set FDS with all transport descriptors we want
 * to read from.  Return the number of file descriptors select(2) needs to
 * check in order to cover the ones we setup in here.
 */
int
transport_fd_set(fd_set * fds)
{
	struct transport *t;
	int	n;
	int	max = -1;

	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link))
		if (t->virtual->flags & TRANSPORT_LISTEN) {
			n = t->vtbl->fd_set(t, fds, 1);
			if (n > max)
				max = n;

			LOG_DBG((LOG_TRANSPORT, 95, "transport_fd_set: "
			    "transport %p (virtual %p) fd %d", t,
			    t->virtual, n));
		}
	return max + 1;
}

/*
 * Build up a file descriptor set FDS with all the descriptors belonging to
 * transport where messages are queued for transmittal.  Return the number
 * of file descriptors select(2) needs to check in order to cover the ones
 * we setup in here.
 */
int
transport_pending_wfd_set(fd_set * fds)
{
	struct transport *t;
	int	n;
	int	max = -1;

	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link)) {
		if (TAILQ_FIRST(&t->virtual->sendq) ||
		    TAILQ_FIRST(&t->virtual->prio_sendq)) {
			n = t->vtbl->fd_set(t, fds, 1);
			LOG_DBG((LOG_TRANSPORT, 95,
			    "transport_pending_wfd_set: "
			    "transport %p (virtual %p) fd %d pending", t,
			    t->virtual, n));
			if (n > max)
				max = n;
		}
	}
	return max + 1;
}

/*
 * For each transport with a file descriptor in FDS, try to get an
 * incoming message and start processing it.
 */
void
transport_handle_messages(fd_set *fds)
{
	struct transport *t;

	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link)) {
		if ((t->flags & TRANSPORT_LISTEN) &&
		    (*t->vtbl->fd_isset)(t, fds)) {
			(*t->virtual->vtbl->handle_message)(t);
			(*t->vtbl->fd_set)(t, fds, 0);
		}
	}
}

/*
 * Send the first queued message on the transports found whose file
 * descriptor is in FDS and has messages queued.  Remove the fd bit from
 * FDS as soon as one message has been sent on it so other transports
 * sharing the socket won't get service without an intervening select
 * call.  Perhaps a fairness strategy should be implemented between
 * such transports.  Now early transports in the list will potentially
 * be favoured to later ones sharing the file descriptor.
 */
void
transport_send_messages(fd_set * fds)
{
	struct transport *t, *next;
	struct message *msg;
	struct exchange *exchange;
	struct sockaddr *dst;
	struct timeval  expiration;
	int             expiry, ok_to_drop_message;
	char peer[NI_MAXHOST], peersv[NI_MAXSERV];

	/*
	 * Reference all transports first so noone will disappear while in
	 * use.
	 */
	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link))
		transport_reference(t->virtual);

	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link)) {
		if ((TAILQ_FIRST(&t->virtual->sendq) ||
		    TAILQ_FIRST(&t->virtual->prio_sendq)) &&
		    t->vtbl->fd_isset(t, fds)) {
			/* Remove fd bit.  */
			t->vtbl->fd_set(t, fds, 0);

			/* Prefer a message from the prioritized sendq.  */
			if (TAILQ_FIRST(&t->virtual->prio_sendq)) {
				msg = TAILQ_FIRST(&t->virtual->prio_sendq);
				TAILQ_REMOVE(&t->virtual->prio_sendq, msg,
				    link);
			} else {
				msg = TAILQ_FIRST(&t->virtual->sendq);
				TAILQ_REMOVE(&t->virtual->sendq, msg, link);
			}

			msg->flags &= ~MSG_IN_TRANSIT;
			exchange = msg->exchange;
			exchange->in_transit = 0;

			/*
			 * We disregard the potential error message here,
			 * hoping that the retransmit will go better.
			 * XXX Consider a retry/fatal error discriminator.
			 */
			t->virtual->vtbl->send_message(msg, 0);
			msg->xmits++;

			/*
			 * This piece of code has been proven to be quite
			 * delicate. Think twice for before altering.
			 * Here's an outline:
			 *
			 * If this message is not the one which finishes an
			 * exchange, check if we have reached the number of
			 * retransmit before queuing it up for another.
			 *
			 * If it is a finishing message we still may have to
			 * keep it around for an on-demand retransmit when
			 * seeing a duplicate of our peer's previous message.
			 */
			if ((msg->flags & MSG_LAST) == 0) {
				if (msg->flags & MSG_DONTRETRANSMIT)
					exchange->last_sent = 0;
				else if (msg->xmits > conf_get_num("General",
				    "retransmits", RETRANSMIT_DEFAULT)) {
					t->virtual->vtbl->get_dst(t->virtual, &dst);
					if (getnameinfo(dst, SA_LEN(dst), peer,
					    sizeof peer, peersv, sizeof peersv,
					    NI_NUMERICHOST | NI_NUMERICSERV)) {
						strlcpy(peer, "<unknown>", sizeof peer);
						strlcpy(peersv, "<?>", sizeof peersv);
					}
					log_print("transport_send_messages: "
					    "giving up on exchange %s, no "
					    "response from peer %s:%s",
					    exchange->name ? exchange->name :
					    "<unnamed>", peer, peersv);

					exchange->last_sent = 0;
#ifdef notyet
					exchange_free(exchange);
					exchange = 0;
#endif
				} else {
					gettimeofday(&expiration, 0);

					/*
					 * XXX Calculate from round trip
					 * timings and a backoff func.
					 */
					expiry = msg->xmits * 2 + 5;
					expiration.tv_sec += expiry;
					LOG_DBG((LOG_TRANSPORT, 30,
					    "transport_send_messages: "
					    "message %p scheduled for "
					    "retransmission %d in %d secs",
					    msg, msg->xmits, expiry));
					if (msg->retrans)
						timer_remove_event(msg->retrans);
					msg->retrans
					    = timer_add_event("message_send_expire",
						(void (*) (void *)) message_send_expire,
						msg, &expiration);
					/*
					 * If we cannot retransmit, we
					 * cannot...
					 */
					exchange->last_sent =
					    msg->retrans ? msg : 0;
				}
			} else
				exchange->last_sent =
				    exchange->last_received ? msg : 0;

			/*
			 * If this message is not referred to for later
			 * retransmission it will be ok for us to drop it
			 * after the post-send function. But as the post-send
			 * function may remove the exchange, we need to
			 * remember this fact here.
			 */
			ok_to_drop_message = exchange->last_sent == 0;

			/*
			 * If this is not a retransmit call post-send
			 * functions that allows parallel work to be done
			 * while the network and peer does their share of
			 * the job.  Note that a post-send function may take
			 * away the exchange we belong to, but only if no
			 * retransmits are possible.
			 */
			if (msg->xmits == 1)
				message_post_send(msg);

			if (ok_to_drop_message)
				message_free(msg);
		}
	}

	for (t = LIST_FIRST(&transport_list); t; t = next) {
		next = LIST_NEXT(t, link);
		transport_release(t->virtual);
	}
}

/*
 * Textual search after the transport method denoted by NAME, then create
 * a transport connected to the peer with address ADDR, given in a transport-
 * specific string format.
 */
struct transport *
transport_create(char *name, char *addr)
{
	struct transport_vtbl *method;

	for (method = LIST_FIRST(&transport_method_list); method;
	    method = LIST_NEXT(method, link))
		if (strcmp(method->name, name) == 0)
			return (*method->create) (addr);
	return 0;
}
@


1.36
log
@remove excessive includes
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.35 2005/12/28 10:57:35 hshoexer Exp $	 */
d312 3
a314 1
				if (msg->xmits > conf_get_num("General",
@


1.35
log
@remove some unused functions and an unused variable found by lint.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.34 2005/10/27 08:19:59 hshoexer Exp $	 */
a32 1
#include <sys/param.h>
@


1.34
log
@Do not touch LIST_* macro internals.

with otto@@, ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.33 2005/04/08 23:15:26 hshoexer Exp $	 */
a169 10
}

/* Apply a function FUNC on all registered (non-toplevel) transports.  */
void
transport_map(void (*func) (struct transport *))
{
	struct transport *t;

	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link))
		(*func) (t);
@


1.33
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.32 2005/04/08 16:32:11 hshoexer Exp $	 */
a49 1
LIST_HEAD(transport_list, transport) transport_list;
@


1.32
log
@improve logging, original diff and ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.31 2005/04/04 19:31:11 deraadt Exp $	 */
a37 2
#include "sysdep.h"

d327 2
a328 2
					if (getnameinfo(dst, sysdep_sa_len(dst),
					    peer, sizeof peer, peersv, sizeof peersv,
@


1.31
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.30 2004/08/08 19:11:06 deraadt Exp $	 */
d35 1
d271 1
d274 1
d328 7
d336 2
a337 2
					    "giving up on message %p, "
					    "exchange %s", msg,
d339 2
a340 19
					    "<unnamed>");
					/* Be more verbose here.  */
					if (exchange->phase == 1) {
						log_print(
						    "transport_send_messages: "
						    "either this message did "
						    "not reach the other "
						    "peer");
						if (exchange->initiator)
							log_print("transport_send_messages: "
							    "or the response"
							    "message did not "
							    "reach us back");
						else
							log_print("transport_send_messages: "
							    "or this is an "
							    "attempted IKE "
							    "scan");
					}
@


1.30
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.29 2004/08/03 10:54:09 ho Exp $	 */
d61 1
a61 1
	     method = LIST_NEXT(method, link))
d130 2
a131 2
		     "transport_report: transport %p flags %x refcnt %d", t,
			 t->flags, t->refcnt));
d144 1
a144 1
			     msg = TAILQ_NEXT(msg, link))
d149 1
a149 1
			     msg = TAILQ_NEXT(msg, link))
d305 1
a305 1
		         */
d313 1
a313 1
		         *
d317 1
a317 1
		         *
d321 1
a321 2
		         *
		         */
d359 1
a359 1
				         */
d390 1
a390 1
		         */
d400 1
a400 1
		         */
d426 1
a426 1
	     method = LIST_NEXT(method, link))
@


1.29
log
@Rewrite the transport reference count code to avoid leaks.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.28 2004/06/21 13:09:00 ho Exp $	 */
d226 1
a226 1
			LOG_DBG((LOG_TRANSPORT, 95, 
d279 1
a279 1
	
@


1.28
log
@Port floating (500->4500) for p1 and p2 exchanges.
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.27 2004/06/20 15:24:05 ho Exp $	 */
d78 4
a81 6
	LOG_DBG((LOG_TRANSPORT, 70, "transport_setup: adding %p%s", t,
	    toplevel ? " (virtual)" : ""));
	if (toplevel == 0)
		LIST_INSERT_HEAD(&transport_list, t, link);
	else {
		/* Only the toplevel (virtual) transport has the sendqueues. */
d84 7
a92 1
	t->refcnt = 0;
a117 9
	if (t->virtual) {
		struct virtual_transport *v =
		    (struct virtual_transport *)t->virtual;
		if (v->main == t)
			v->main = 0;
		else
			v->encap = 0;
		LIST_REMOVE(t, link);
	}
d202 1
a202 1
			LOG_DBG((LOG_TRANSPORT,95,"transport_fd_set: "
d226 2
a227 1
			LOG_DBG((LOG_TRANSPORT,95,"transport_pending_wfd_set: "
d277 1
a277 1
	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link)) {
a278 2
		transport_reference(t);
	}
d350 4
a412 1
		transport_release(t);
@


1.27
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.26 2004/06/14 09:55:42 ho Exp $	 */
d78 2
a79 1
	LOG_DBG((LOG_TRANSPORT, 70, "transport_setup: adding %p", t));
d203 1
a203 1
			n = t->virtual->vtbl->fd_set(t->virtual, fds, 1);
d230 1
a230 1
			n = t->virtual->vtbl->fd_set(t->virtual, fds, 1);
d252 3
a254 3
		    (*t->virtual->vtbl->fd_isset)(t->virtual, fds)) {
			(*t->virtual->vtbl->handle_message)(t->virtual);
			(*t->virtual->vtbl->fd_set)(t->virtual, fds, 0);
d289 1
a289 1
		    t->virtual->vtbl->fd_isset(t->virtual, fds)) {
d291 1
a291 1
			t->virtual->vtbl->fd_set(t->virtual, fds, 0);
@


1.26
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.25 2004/06/09 14:02:44 ho Exp $	 */
d6 1
a6 1
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
d46 1
d55 2
a56 2
	void
	                transport_reinit(void)
d62 2
a63 1
		method->reinit();
d76 1
a76 1
transport_add(struct transport *t)
d78 8
a85 4
	LOG_DBG((LOG_TRANSPORT, 70, "transport_add: adding %p", t));
	TAILQ_INIT(&t->sendq);
	TAILQ_INIT(&t->prio_sendq);
	LIST_INSERT_HEAD(&transport_list, t, link);
d96 2
a97 2
	       "transport_reference: transport %p now has %d references", t,
		 t->refcnt));
d107 2
a108 2
		 "transport_release: transport %p had %d references", t,
		 t->refcnt));
d113 9
a121 1
	LIST_REMOVE(t, link);
d128 1
d137 1
d144 13
a156 6
		for (msg = TAILQ_FIRST(&t->prio_sendq); msg;
		     msg = TAILQ_NEXT(msg, link))
			message_dump_raw("udp_report", msg, LOG_REPORT);

		for (msg = TAILQ_FIRST(&t->sendq); msg; msg = TAILQ_NEXT(msg, link))
			message_dump_raw("udp_report", msg, LOG_REPORT);
d166 1
a166 1
		if (TAILQ_FIRST(&t->prio_sendq))
d178 1
a178 1
/* Apply a function FUNC on all registered transports.  */
a195 2
	int             n;
	int             max = -1;
d197 2
d201 2
a202 2
		if (t->flags & TRANSPORT_LISTEN) {
			n = t->vtbl->fd_set(t, fds, 1);
d205 4
a221 2
	int             n;
	int             max = -1;
d223 2
d227 6
a232 2
		if (TAILQ_FIRST(&t->sendq) || TAILQ_FIRST(&t->prio_sendq)) {
			n = t->vtbl->fd_set(t, fds, 1);
d245 1
a245 1
transport_handle_messages(fd_set * fds)
d249 1
a249 1
	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link))
d251 5
a255 2
		    (*t->vtbl->fd_isset) (t, fds))
			(*t->vtbl->handle_message) (t);
d280 2
a281 1
	for (t = LIST_FIRST(&transport_list); t; t = LIST_NEXT(t, link))
d283 2
a284 1

d286 5
a290 3
		if ((TAILQ_FIRST(&t->sendq) || TAILQ_FIRST(&t->prio_sendq))
		    && t->vtbl->fd_isset(t, fds)) {
			t->vtbl->fd_set(t, fds, 0);
d293 4
a296 3
			if (TAILQ_FIRST(&t->prio_sendq)) {
				msg = TAILQ_FIRST(&t->prio_sendq);
				TAILQ_REMOVE(&t->prio_sendq, msg, link);
d298 2
a299 2
				msg = TAILQ_FIRST(&t->sendq);
				TAILQ_REMOVE(&t->sendq, msg, link);
d311 1
a311 1
			t->vtbl->send_message(msg);
d316 6
a321 5
			 * delicate. Think twice for before altering.  Here's
			 * an outline: If this message is not the one which
			 * finishes an exchange, check if we have reached the
			 * number of retransmit before queuing it up for
			 * another.
a326 2
			 * If we have no previous message from our peer, we
			 * need not to keep the message around.
d398 3
a400 3
			 * while the network and peer does their share of the
			 * job.  Note that a post-send function may take away
			 * the exchange we belong to, but only if no
d413 1
@


1.25
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.24 2004/04/15 18:39:26 deraadt Exp $	 */
d219 2
a220 1
		if ((t->flags & TRANSPORT_LISTEN) && (*t->vtbl->fd_isset) (t, fds))
d268 2
a269 2
			 * We disregard the potential error message here, hoping that the
			 * retransmit will go better.
d276 6
a281 2
			 * This piece of code has been proven to be quite delicate.
			 * Think twice for before altering.  Here's an outline:
d283 3
a285 3
			 * If this message is not the one which finishes an exchange,
			 * check if we have reached the number of retransmit before
			 * queuing it up for another.
d287 2
a288 6
			 * If it is a finishing message we still may have to keep it
			 * around for an on-demand retransmit when seeing a duplicate
			 * of our peer's previous message.
		         *
			 * If we have no previous message from our peer, we need not
			 * to keep the message around.
d291 7
a297 5
				if (msg->xmits > conf_get_num("General", "retransmits",
						      RETRANSMIT_DEFAULT)) {
					log_print("transport_send_messages: giving up on "
					     "message %p, exchange %s", msg,
						  exchange->name ? exchange->name : "<unnamed>");
d300 5
a304 2
						log_print("transport_send_messages: either this "
							  "message did not reach the other peer");
d306 4
a309 2
							log_print("transport_send_messages: or the response"
								  "message did not reach us back");
d311 4
a314 2
							log_print("transport_send_messages: or this is "
								  "an attempted IKE scan");
d321 2
a322 1
					 * XXX Calculate from round trip timings and a backoff func.
d327 4
a330 3
						 "transport_send_messages: message %p "
						 "scheduled for retransmission %d in %d secs",
						 msg, msg->xmits, expiry));
d334 3
a336 3
						= timer_add_event("message_send_expire",
								  (void (*) (void *)) message_send_expire,
							  msg, &expiration);
d341 2
a342 1
					exchange->last_sent = msg->retrans ? msg : 0;
d345 2
a346 1
				exchange->last_sent = exchange->last_received ? msg : 0;
d349 5
a353 4
			 * If this message is not referred to for later retransmission
			 * it will be ok for us to drop it after the post-send function.
			 * But as the post-send function may remove the exchange, we need
			 * to remember this fact here.
d358 6
a363 5
			 * If this is not a retransmit call post-send functions that allows
			 * parallel work to be done while the network and peer does their
			 * share of the job.  Note that a post-send function may take
			 * away the exchange we belong to, but only if no retransmits
			 * are possible.
@


1.24
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: transport.c,v 1.23 2003/12/18 02:03:28 ho Exp $	 */
d74 1
a74 1
transport_add(struct transport * t)
d86 1
a86 1
transport_reference(struct transport * t)
d98 1
a98 1
transport_release(struct transport * t)
d150 1
a150 1
transport_method_add(struct transport_vtbl * t)
@


1.23
log
@Mention the exchange name when giving up on a message. Suggested by
Michael Coulter.
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.22 2003/06/20 09:14:14 ho Exp $	*/
/*	$EOM: transport.c,v 1.43 2000/10/10 12:36:39 provos Exp $	*/
d50 2
a51 2
LIST_HEAD (transport_list, transport) transport_list;
LIST_HEAD (transport_method_list, transport_vtbl) transport_method_list;
d54 2
a55 2
void
transport_reinit (void)
d57 1
a57 1
  struct transport_vtbl *method;
d59 3
a61 3
  for (method = LIST_FIRST (&transport_method_list); method;
       method = LIST_NEXT (method, link))
    method->reinit ();
d66 1
a66 1
transport_init (void)
d68 2
a69 2
  LIST_INIT (&transport_list);
  LIST_INIT (&transport_method_list);
d74 1
a74 1
transport_add (struct transport *t)
d76 6
a81 6
  LOG_DBG ((LOG_TRANSPORT, 70, "transport_add: adding %p", t));
  TAILQ_INIT (&t->sendq);
  TAILQ_INIT (&t->prio_sendq);
  LIST_INSERT_HEAD (&transport_list, t, link);
  t->flags = 0;
  t->refcnt = 0;
d86 1
a86 1
transport_reference (struct transport *t)
d88 4
a91 4
  t->refcnt++;
  LOG_DBG ((LOG_TRANSPORT, 95,
	    "transport_reference: transport %p now has %d references", t,
	    t->refcnt));
d98 1
a98 1
transport_release (struct transport *t)
d100 9
a108 9
  LOG_DBG ((LOG_TRANSPORT, 95,
	    "transport_release: transport %p had %d references", t,
	    t->refcnt));
  if (--t->refcnt)
    return;

  LOG_DBG ((LOG_TRANSPORT, 70, "transport_release: freeing %p", t));
  LIST_REMOVE (t, link);
  t->vtbl->remove (t);
d112 1
a112 1
transport_report (void)
d114 17
a130 2
  struct transport *t;
  struct message *msg;
d132 3
a134 16
  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    {
      LOG_DBG ((LOG_REPORT, 0,
		"transport_report: transport %p flags %x refcnt %d", t,
		t->flags, t->refcnt));

      t->vtbl->report (t);

      /* This is the reason message_dump_raw lives outside message.c.  */
      for (msg = TAILQ_FIRST (&t->prio_sendq); msg;
	   msg = TAILQ_NEXT (msg, link))
        message_dump_raw ("udp_report", msg, LOG_REPORT);

      for (msg = TAILQ_FIRST (&t->sendq); msg; msg = TAILQ_NEXT (msg, link))
        message_dump_raw ("udp_report", msg, LOG_REPORT);
    }
d138 1
a138 1
transport_prio_sendqs_empty (void)
d140 1
a140 1
  struct transport *t;
d142 4
a145 4
  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    if (TAILQ_FIRST (&t->prio_sendq))
      return 0;
  return 1;
d150 1
a150 1
transport_method_add (struct transport_vtbl *t)
d152 1
a152 1
  LIST_INSERT_HEAD (&transport_method_list, t, link);
d157 1
a157 1
transport_map (void (*func) (struct transport *))
d159 1
a159 1
  struct transport *t;
d161 2
a162 2
  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    (*func) (t);
d171 1
a171 1
transport_fd_set (fd_set *fds)
d173 11
a183 12
  int n;
  int max = -1;
  struct transport *t;

  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    if (t->flags & TRANSPORT_LISTEN)
      {
	n = t->vtbl->fd_set (t, fds, 1);
	if (n > max)
	  max = n;
      }
  return max + 1;
d193 1
a193 1
transport_pending_wfd_set (fd_set *fds)
d195 10
a204 11
  int n;
  int max = -1;
  struct transport *t;

  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    {
      if (TAILQ_FIRST (&t->sendq) || TAILQ_FIRST (&t->prio_sendq))
	{
	  n = t->vtbl->fd_set (t, fds, 1);
	  if (n > max)
	    max = n;
d206 1
a206 2
    }
  return max + 1;
d214 1
a214 1
transport_handle_messages (fd_set *fds)
d216 1
a216 1
  struct transport *t;
d218 3
a220 3
  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    if ((t->flags & TRANSPORT_LISTEN) && (*t->vtbl->fd_isset) (t, fds))
      (*t->vtbl->handle_message) (t);
d233 1
a233 1
transport_send_messages (fd_set *fds)
d235 119
a353 77
  struct transport *t, *next;
  struct message *msg;
  struct exchange *exchange;
  struct timeval expiration;
  int expiry, ok_to_drop_message;

  /* Reference all transports first so noone will disappear while in use.  */
  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    transport_reference (t);

  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    {
      if ((TAILQ_FIRST (&t->sendq) || TAILQ_FIRST (&t->prio_sendq))
	  && t->vtbl->fd_isset (t, fds))
	{
	  t->vtbl->fd_set (t, fds, 0);

	  /* Prefer a message from the prioritized sendq.  */
	  if (TAILQ_FIRST (&t->prio_sendq))
	    {
	      msg = TAILQ_FIRST (&t->prio_sendq);
	      TAILQ_REMOVE (&t->prio_sendq, msg, link);
	    }
	  else
	    {
	      msg = TAILQ_FIRST (&t->sendq);
	      TAILQ_REMOVE (&t->sendq, msg, link);
	    }

	  msg->flags &= ~MSG_IN_TRANSIT;
	  exchange = msg->exchange;
	  exchange->in_transit = 0;

	  /*
	   * We disregard the potential error message here, hoping that the
	   * retransmit will go better.
	   * XXX Consider a retry/fatal error discriminator.
	   */
	  t->vtbl->send_message (msg);
	  msg->xmits++;

	  /*
	   * This piece of code has been proven to be quite delicate.
	   * Think twice for before altering.  Here's an outline:
	   *
	   * If this message is not the one which finishes an exchange,
	   * check if we have reached the number of retransmit before
	   * queuing it up for another.
	   *
	   * If it is a finishing message we still may have to keep it
	   * around for an on-demand retransmit when seeing a duplicate
	   * of our peer's previous message.
	   *
	   * If we have no previous message from our peer, we need not
	   * to keep the message around.
	   */
	  if ((msg->flags & MSG_LAST) == 0)
	    {
	      if (msg->xmits > conf_get_num ("General", "retransmits",
					     RETRANSMIT_DEFAULT))
		{
		  log_print ("transport_send_messages: giving up on "
			     "message %p, exchange %s", msg,
			     exchange->name ? exchange->name : "<unnamed>");
		  /* Be more verbose here.  */
		  if (exchange->phase == 1)
		    {
		      log_print ("transport_send_messages: either this "
				 "message did not reach the other peer");
		      if (exchange->initiator)
			log_print ("transport_send_messages: or the response"
				   "message did not reach us back");
		      else
			log_print ("transport_send_messages: or this is "
				   "an attempted IKE scan");
		    }
		  exchange->last_sent = 0;
d355 1
a355 43
	      else
		{
		  gettimeofday (&expiration, 0);

		  /*
		   * XXX Calculate from round trip timings and a backoff func.
		   */
		  expiry = msg->xmits * 2 + 5;
		  expiration.tv_sec += expiry;
		  LOG_DBG ((LOG_TRANSPORT, 30,
			    "transport_send_messages: message %p "
			    "scheduled for retransmission %d in %d secs",
			    msg, msg->xmits, expiry));
		  if (msg->retrans)
		    timer_remove_event (msg->retrans);
		  msg->retrans
		    = timer_add_event ("message_send_expire",
				       (void (*) (void *))message_send_expire,
				       msg, &expiration);
		  /* If we cannot retransmit, we cannot...  */
		  exchange->last_sent = msg->retrans ? msg : 0;
		}
	    }
	  else
	    exchange->last_sent = exchange->last_received ? msg : 0;

	  /*
	   * If this message is not referred to for later retransmission
	   * it will be ok for us to drop it after the post-send function.
	   * But as the post-send function may remove the exchange, we need
	   * to remember this fact here.
	   */
	  ok_to_drop_message = exchange->last_sent == 0;

	  /*
	   * If this is not a retransmit call post-send functions that allows
	   * parallel work to be done while the network and peer does their
	   * share of the job.  Note that a post-send function may take
	   * away the exchange we belong to, but only if no retransmits
	   * are possible.
	   */
	  if (msg->xmits == 1)
	    message_post_send (msg);
d357 3
a359 2
	  if (ok_to_drop_message)
	    message_free (msg);
a360 7
    }

  for (t = LIST_FIRST (&transport_list); t; t = next)
    {
      next = LIST_NEXT (t, link);
      transport_release (t);
    }
d369 1
a369 1
transport_create (char *name, char *addr)
d371 1
a371 1
  struct transport_vtbl *method;
d373 5
a377 5
  for (method = LIST_FIRST (&transport_method_list); method;
       method = LIST_NEXT (method, link))
    if (strcmp (method->name, name) == 0)
      return (*method->create) (addr);
  return 0;
@


1.22
log
@Be a bit more verbose when we give up on ever seeing a response to the
last message we sent out. In case we initiated the exchange, one possible
and common reason is a network level problem (pf, routing, whatnot), if
we're the responder, there is also the possibility we were scanned by
something like ike-scan.  markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.21 2003/06/10 16:41:29 deraadt Exp $	*/
d298 2
a299 1
			     "message %p", msg);
@


1.21
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.20 2003/06/03 14:28:16 ho Exp $	*/
d297 14
a310 3
		  log_print ("transport_send_messages: "
			     "giving up on message %p",
			     msg);
@


1.20
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.19 2003/03/14 14:49:08 ho Exp $	*/
d255 1
a255 1
 	    {
@


1.19
log
@Spelling fixes from david@@. jmc@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.18 2002/06/09 08:13:07 todd Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.17 2002/06/07 21:59:22 ho Exp $	*/
d169 1
a169 1
 * Build up a file desciptor set FDS with all transport descriptors we want
d191 1
a191 1
 * Build up a file desciptor set FDS with all the descriptors belonging to
@


1.17
log
@Avoid some gcc3 warnings. From David Krause <openbsd@@davidkrause.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.16 2001/10/26 11:37:16 ho Exp $	*/
d123 2
a124 2
    { 
      LOG_DBG ((LOG_REPORT, 0, 
d127 1
a127 1
      
d129 1
a129 1
      
@


1.16
log
@Sometimes the daemon will not die promptly on SIGTERM, even though
all DELETE notifications is sent out.  Create a prioritized send-queue
for the DELETE messages to solve this. Some (C)-2001.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.15 2001/10/05 05:54:50 ho Exp $	*/
d40 1
@


1.15
log
@Tweak a couple of debug levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.14 2001/08/23 23:11:02 angelos Exp $	*/
d6 1
d82 1
d130 4
d139 11
d204 1
a204 1
      if (TAILQ_FIRST (&t->sendq))
d252 2
a253 1
      if (TAILQ_FIRST (&t->sendq) && t->vtbl->fd_isset (t, fds))
d256 13
a268 1
	  msg = TAILQ_FIRST (&t->sendq);
a271 1
	  TAILQ_REMOVE (&t->sendq, msg, link);
@


1.14
log
@Reinitialize transports on SIGUP.
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.13 2001/04/09 22:09:53 ho Exp $	*/
d91 1
a91 1
  LOG_DBG ((LOG_TRANSPORT, 90,
d102 1
a102 1
  LOG_DBG ((LOG_TRANSPORT, 90,
@


1.13
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.12 2000/10/10 13:35:12 niklas Exp $	*/
d55 11
@


1.12
log
@message.c: Merge with EOM 1.156
message.h: Merge with EOM 1.51
transport.c: Merge with EOM 1.43

author: provos
use message_send_expire for timeouts. okay niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.11 2000/10/07 06:57:34 niklas Exp $	*/
d118 1
a118 1
        message_dump_raw("udp_report", msg, LOG_REPORT);
@


1.12.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: transport.c,v 1.13 2001/04/09 22:09:53 ho Exp $	*/
d118 1
a118 1
        message_dump_raw ("udp_report", msg, LOG_REPORT);
@


1.11
log
@Merge with EOM 1.42

author: provos
remove previous timeout if adding a new one
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.10 2000/02/25 17:23:42 niklas Exp $	*/
/*	$EOM: transport.c,v 1.42 2000/09/14 18:12:55 provos Exp $	*/
d282 2
a283 2
		    = timer_add_event ("message_send",
				       (void (*) (void *))message_send,
@


1.10
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.9 1999/05/01 20:43:45 niklas Exp $	*/
/*	$EOM: transport.c,v 1.41 2000/02/20 19:58:42 niklas Exp $	*/
d279 2
@


1.9
log
@sysdep/openbsd/sysdep.c: Merge with EOM 1.7
DESIGN-NOTES: Merge with EOM 1.42
Makefile: Merge with EOM 1.51
app.c: Merge with EOM 1.6
conf.c: Merge with EOM 1.18
init.c: Merge with EOM 1.14
isakmpd.conf.5: Merge with EOM 1.19
pf_encap.c: Merge with EOM 1.64
pf_encap.h: Merge with EOM 1.12
pf_key_v2.h: Merge with EOM 1.3
sysdep.h: Merge with EOM 1.16
transport.c: Merge with EOM 1.40
ui.c: Merge with EOM 1.32

author: niklas
A new connection abstraction
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.8 1999/04/30 22:33:09 niklas Exp $	*/
/*	$EOM: transport.c,v 1.40 1999/05/01 20:21:17 niklas Exp $	*/
d68 1
a68 1
  log_debug (LOG_TRANSPORT, 70, "transport_add: adding %p", t);
d80 3
a82 3
  log_debug (LOG_TRANSPORT, 90,
	     "transport_reference: transport %p now has %d references", t,
	     t->refcnt);
d91 3
a93 3
  log_debug (LOG_TRANSPORT, 90,
	     "transport_release: transport %p had %d references", t,
	     t->refcnt);
d97 1
a97 1
  log_debug (LOG_TRANSPORT, 70, "transport_release: freeing %p", t);
d110 3
a112 3
      log_debug (LOG_REPORT, 0, 
		 "transport_report: transport %p flags %x refcnt %d", t,
		 t->flags, t->refcnt);
d275 4
a278 4
		  log_debug (LOG_TRANSPORT, 30,
			     "transport_send_messages: message %p "
			     "scheduled for retransmission %d in %d secs",
			     msg, msg->xmits, expiry);
@


1.8
log
@Merge with EOM 1.39

author: niklas
Unused var removed
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.7 1999/04/30 11:46:48 niklas Exp $	*/
/*	$EOM: transport.c,v 1.39 1999/04/30 11:59:39 niklas Exp $	*/
d259 1
a259 1
					       RETRANSMIT_DEFAULT))
@


1.7
log
@Merge with EOM 1.38

author: niklas
Careful rewrite of the message sending to cope with exchanges disappearing
in post-send functions.

author: niklas
Try to fix the retransmit business, so info exchanges does not retransmit

author: niklas
Keep track of messages in the send queue from the exchange point of view.
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.6 1999/04/27 21:12:31 niklas Exp $	*/
/*	$EOM: transport.c,v 1.38 1999/04/30 11:05:41 niklas Exp $	*/
a215 1
  struct sa *sa;
@


1.6
log
@Merge with EOM 1.35

author: niklas
Do not lose the transport we are handling

author: niklas
Remove obsolete XXX comment.

author: niklas
Collapse MSG_NO_RETRANS & MSG_KEEP into MSG_LAST.
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.5 1999/04/19 21:04:00 niklas Exp $	*/
/*	$EOM: transport.c,v 1.35 1999/04/25 22:15:00 niklas Exp $	*/
d201 7
a207 4
 * Send the first queued message on the first transport found whose file
 * descriptor is in FDS and has messages queued.  For fairness always try
 * the transport right after the last one which got a message sent on it.
 * XXX Would this perhaps be nicer done with CIRCLEQ chaining?
d212 1
a212 1
  struct transport *t = 0, *next;
d214 1
d216 2
a217 2
  struct sa *sa, *next_sa;
  int expiry;
d219 5
a223 1
  for (t = LIST_FIRST (&transport_list); t; t = next)
a224 2
      next = LIST_NEXT (t, link);
      transport_reference (t);
d230 2
d240 1
d243 13
a255 3
	   * If this is not a retransmit call post-send functions that allows
	   * parallel work to be done while the network and peer does their
	   * share of the job.
a256 5
	  if (msg->xmits == 0)
	    message_post_send (msg);

	  msg->xmits++;

d260 1
a260 1
					     RETRANSMIT_DEFAULT))
d265 5
a269 1
		  msg->exchange->last_sent = 0;
d272 1
a272 2
		   * As this exchange never went to a normal end, remove the
		   * SA's being negotiated too.
d274 12
a285 28
		  for (sa = TAILQ_FIRST (&msg->exchange->sa_list); sa;
		       sa = next_sa)
		    {
		      next_sa = TAILQ_NEXT (sa, next);
		      sa_free (sa);
		    }

		  exchange_free (msg->exchange);
		  message_free (msg);
		  goto next;
	      };

	      gettimeofday (&expiration, 0);
	      /* XXX Calculate from round trip timings and a backoff func.  */
	      expiry = msg->xmits * 2 + 5;
	      expiration.tv_sec += expiry;
	      log_debug (LOG_TRANSPORT, 30,
			 "transport_send_messages: message %p "
			 "scheduled for retransmission %d in %d secs",
			 msg, msg->xmits, expiry);
	      msg->retrans = timer_add_event ("message_send",
					      (void (*) (void *))message_send,
					      msg, &expiration);
	      if (!msg->retrans)
		{
		  /* If we can make no retransmission, we can't.... */
		  message_free (msg);
		  goto next;
d287 11
d299 12
a310 2
	      msg->exchange->last_sent = msg;
	    }
d312 1
d314 3
a316 1
    next:
@


1.5
log
@./transport.c: Merge with EOM 1.32

Add LOG_REPORT to always go to logchannel regardless of level; misc small fixes

Nitpick: better english

Move transport-independent reporting to transport_report instead.  Also
report the socket fd for UDP transports.  A derived transport class is always
aligned with the transport superclass, so there is no need to search for
the udp_transport that matches a given transport.

Add transport_report

transport refcnt should start with 0

Garbage collect transports via refcounting.  Fix commentary.

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.4 1999/02/26 03:51:07 niklas Exp $	*/
/*	$EOM: transport.c,v 1.32 1999/04/13 20:00:42 ho Exp $	*/
d209 1
a209 1
  struct transport *t = 0;
d215 52
a266 49
  for (t = LIST_FIRST (&transport_list); t; t = LIST_NEXT (t, link))
    if (TAILQ_FIRST (&t->sendq) && t->vtbl->fd_isset (t, fds))
      {
	t->vtbl->fd_set (t, fds, 0);
	msg = TAILQ_FIRST (&t->sendq);
	msg->flags &= ~MSG_IN_TRANSIT;
	TAILQ_REMOVE (&t->sendq, msg, link);

	/*
	 * We disregard the potential error message here, hoping that the
	 * retransmit will go better.
	 * XXX Consider a retry/fatal error discriminator.
	 */
	t->vtbl->send_message (msg);

	/*
	 * If this is not a retransmit call post-send functions that allows
	 * parallel work to be done while the network and peer does their
	 * share of the job.
	 */
	if (msg->xmits == 0)
	  message_post_send (msg);

	msg->xmits++;

	if ((msg->flags & MSG_NO_RETRANS) == 0)
	  {
	    /* XXX make this a configurable parameter.  */
	    if (msg->xmits
		> conf_get_num ("General", "retransmits", RETRANSMIT_DEFAULT))
	      {
		log_print ("transport_send_messages: giving up on message %p",
			   msg);
		msg->exchange->last_sent = 0;

		/*
		 * As this exchange never went to a normal end, remove the
		 * SA's being negotiated too.
		 */
		for (sa = TAILQ_FIRST (&msg->exchange->sa_list); sa;
		     sa = next_sa)
		  {
		    next_sa = TAILQ_NEXT (sa, next);
		    sa_free (sa);
		  }

		exchange_free (msg->exchange);
		message_free (msg);
		continue;
d269 25
a293 23
	    gettimeofday (&expiration, 0);
	    /* XXX Calculate from round trip timings and a backoff func.  */
	    expiry = msg->xmits * 2 + 5;
	    expiration.tv_sec += expiry;
	    log_debug (LOG_TRANSPORT, 30,
		       "transport_send_messages: "
		       "message %p scheduled for retransmission %d in %d secs",
		       msg, msg->xmits, expiry);
	    msg->retrans = timer_add_event ("message_send",
					    (void (*) (void *))message_send,
					    msg, &expiration);
	    if (!msg->retrans)
	      {
		/* If we can make no retransmission, we can't.... */
		message_free (msg);
		return;
	      }

	    msg->exchange->last_sent = msg;
	  }
	else if ((msg->flags & MSG_KEEP) == 0)
	  message_free (msg);
      }
@


1.4
log
@Merge from the Ericsson repository
| revision 1.25
| date: 1999/02/25 11:39:24;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
| revision 1.24
| date: 1999/02/25 11:09:40;  author: niklas;  state: Exp;  lines: +6 -2
| Make conf_get_num take a default value to give back when tag does not exist
| ----------------------------
| revision 1.23
| date: 1999/02/24 12:14:10;  author: niklas;  state: Exp;  lines: +2 -1
| initialize flags, noted by Ilya Tsindlekht
| ----------------------------
| revision 1.22
| date: 1999/02/14 00:15:15;  author: niklas;  state: Exp;  lines: +11 -8
| New fd_set API which may clear a bit.  Use it for doing proper message
| send queue runs, as reported by Ilya Tsindlekht.  Better style.
| ----------------------------
| revision 1.21
| date: 1999/02/06 15:03:41;  author: niklas;  state: Exp;  lines: +2 -1
| Do not forget to remove message from sendq when freed
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.3 1998/11/17 11:10:21 niklas Exp $	*/
/*	$EOM: transport.c,v 1.25 1999/02/25 11:39:24 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d68 1
d72 48
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: transport.c,v 1.2 1998/11/15 00:44:03 niklas Exp $	*/
/*	$EOM: transport.c,v 1.20 1998/10/11 20:25:09 niklas Exp $	*/
d40 2
d50 3
d70 1
d105 1
a105 1
	n = (*t->vtbl->fd_set) (t, fds);
d129 1
a129 1
	  n = (*t->vtbl->fd_set) (t, fds);
d152 4
a155 2
 * Send the first queued message on the transports whose file descriptor
 * is in FDS.
d160 1
a160 1
  struct transport *t;
d167 1
a167 1
    if (TAILQ_FIRST (&t->sendq) && (*t->vtbl->fd_isset) (t, fds))
d169 1
d171 1
d194 2
a195 1
	    if (msg->xmits > conf_get_num ("General", "retransmits"))
d214 1
a214 1
		return;
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: transport.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: transport.c,v 1.20 1998/10/11 20:25:09 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
