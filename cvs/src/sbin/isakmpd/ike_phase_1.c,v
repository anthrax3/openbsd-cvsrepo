head	1.76;
access;
symbols
	OPENBSD_6_1:1.76.0.6
	OPENBSD_6_1_BASE:1.76
	OPENBSD_6_0:1.76.0.4
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.74.0.6
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.74.0.2
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.72.0.20
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.72.0.18
	OPENBSD_5_5_BASE:1.72
	OPENBSD_5_4:1.72.0.14
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.72.0.12
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.72.0.10
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.8
	OPENBSD_5_0:1.72.0.6
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.72.0.4
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.72.0.2
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.71.0.8
	OPENBSD_4_7_BASE:1.71
	OPENBSD_4_6:1.71.0.10
	OPENBSD_4_6_BASE:1.71
	OPENBSD_4_5:1.71.0.6
	OPENBSD_4_5_BASE:1.71
	OPENBSD_4_4:1.71.0.4
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.71.0.2
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.70.0.2
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.66.0.4
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.66.0.2
	OPENBSD_4_0_BASE:1.66
	OPENBSD_3_9:1.65.0.4
	OPENBSD_3_9_BASE:1.65
	OPENBSD_3_8:1.65.0.2
	OPENBSD_3_8_BASE:1.65
	OPENBSD_3_7:1.58.0.2
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	OPENBSD_3_3:1.35.0.4
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.76
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.75;
commitid	82PdNqu2kKAuXPfA;

1.75
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.74;
commitid	0qPuuXwccpVXsXcV;

1.74
date	2015.02.15.01.56.42;	author tedu;	state Exp;
branches;
next	1.73;
commitid	MizPuKMrwD760Res;

1.73
date	2014.08.22.07.59.52;	author doug;	state Exp;
branches;
next	1.72;
commitid	Rx3yBknaEXVQhzte;

1.72
date	2010.06.29.19.50.16;	author reyk;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.06.11.37.53;	author moritz;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.05.09.43.09;	author tom;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.07.18.19.56;	author cloder;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.22.11.32.30;	author moritz;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.02.13.19.00;	author hshoexer;	state Exp;
branches;
next	1.65;

1.65
date	2005.07.05.11.59.51;	author hshoexer;	state Exp;
branches;
next	1.64;

1.64
date	2005.06.25.11.40.52;	author hshoexer;	state Exp;
branches;
next	1.63;

1.63
date	2005.05.26.06.11.09;	author hshoexer;	state Exp;
branches;
next	1.62;

1.62
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.61;

1.61
date	2005.04.08.16.52.41;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.08.16.37.14;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2005.01.29.17.07.55;	author hshoexer;	state Exp;
branches;
next	1.57;

1.57
date	2004.12.14.10.17.28;	author mcbride;	state Exp;
branches;
next	1.56;

1.56
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2004.07.29.08.54.08;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	2004.07.05.17.33.35;	author pvalchev;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.23.00.56.45;	author ho;	state Exp;
branches;
next	1.52;

1.52
date	2004.06.20.17.17.35;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.10.12.54.53;	author hshoexer;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.06.13.05.40;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.27.10.16.26;	author ho;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2004.02.27.09.01.18;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.04.21.13.35;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.14.14.29.15;	author ho;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.04.17.29.58;	author cloder;	state Exp;
branches;
next	1.39;

1.39
date	2003.08.08.08.46.59;	author ho;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.04.07.31.16;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.11.09.50.43;	author ho;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.04.17.00.35;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.06.02.15.27;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.26.12.03.07;	author ho;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.01.20.11.53;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.01.18.46.33;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.29.18.52.16;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.29.04.12.00;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.05.10.50.55;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.05.10.09.01;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.05.08.01.07;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.13.14.05.18;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.07.07.33.53;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.12.01.45.45;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.16.23.27.13;	author niklas;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.10.07.06.58.07;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.07.22.05.48;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.08.08.43.04;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.28.22.48.34;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.25.17.23.40;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.19.19.32.53;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.11.10.22.25;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.01.02.46.18;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.30.09.20.57;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.27.18.07.16;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.26.15.21.36;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.10.01.14.07.42;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.08.26.22.27.51;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.07.17.21.54.39;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.07.16.02.01.59;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.07.07.22.15.42;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.05.02.19.16.41;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.11.46.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.04.19.21.05.22;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2001.05.08.12.45.23;	author ho;	state Exp;
branches;
next	;

1.39.2.1
date	2004.06.11.03.08.02;	author brad;	state Exp;
branches;
next	;

1.44.2.1
date	2004.06.11.02.34.56;	author brad;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/* $OpenBSD: ike_phase_1.c,v 1.75 2015/08/20 22:02:21 deraadt Exp $	 */
/* $EOM: ike_phase_1.c,v 1.31 2000/12/11 23:47:56 niklas Exp $	 */

/*
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2001, 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>

#include "attribute.h"
#include "conf.h"
#include "constants.h"
#include "crypto.h"
#include "dh.h"
#include "doi.h"
#include "dpd.h"
#include "exchange.h"
#include "hash.h"
#include "ike_auth.h"
#include "ike_phase_1.h"
#include "ipsec.h"
#include "ipsec_doi.h"
#include "isakmp.h"
#include "log.h"
#include "message.h"
#include "nat_traversal.h"
#include "prf.h"
#include "sa.h"
#include "transport.h"
#include "util.h"
#include "vendor.h"

static int      attribute_unacceptable(u_int16_t, u_int8_t *, u_int16_t,
		    void *);
static int	ike_phase_1_validate_prop(struct exchange *, struct sa *,
		    struct sa *);

/* Offer a set of transforms to the responder in the MSG message.  */
int
ike_phase_1_initiator_send_SA(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t       *proposal = 0, *sa_buf = 0, *saved_nextp, *attr;
	u_int8_t      **transform = 0;
	size_t          transforms_len = 0, proposal_len, sa_len;
	size_t         *transform_len = 0;
	struct conf_list *conf, *life_conf;
	struct conf_list_node *xf, *life;
	int             value, update_nextp;
	size_t          i;
	struct payload *p;
	struct proto   *proto;
	struct proto_attr *pa;
	int             group_desc = -1, new_group_desc;

	/* Get the list of transforms.  */
	conf = conf_get_list(exchange->policy, "Transforms");
	if (!conf)
		return -1;

	transform = calloc(conf->cnt, sizeof *transform);
	if (!transform) {
		log_error("ike_phase_1_initiator_send_SA: calloc (%lu, %lu) "
		    "failed", (u_long)conf->cnt, (u_long)sizeof *transform);
		goto bail_out;
	}
	transform_len = calloc(conf->cnt, sizeof *transform_len);
	if (!transform_len) {
		log_error("ike_phase_1_initiator_send_SA: calloc (%lu, %lu) "
		    "failed", (u_long)conf->cnt,
		    (u_long)sizeof *transform_len);
		goto bail_out;
	}
	for (xf = TAILQ_FIRST(&conf->fields), i = 0; i < conf->cnt;
	    i++, xf = TAILQ_NEXT(xf, link)) {
		/* XXX The sizing needs to be dynamic.  */
		transform[i] = malloc(ISAKMP_TRANSFORM_SA_ATTRS_OFF +
		    16 * ISAKMP_ATTR_VALUE_OFF);
		if (!transform[i]) {
			log_error("ike_phase_1_initiator_send_SA: malloc (%d) "
			    "failed", ISAKMP_TRANSFORM_SA_ATTRS_OFF +
			    16 * ISAKMP_ATTR_VALUE_OFF);
			goto bail_out;
		}
		SET_ISAKMP_TRANSFORM_NO(transform[i], i);
		SET_ISAKMP_TRANSFORM_ID(transform[i], IPSEC_TRANSFORM_KEY_IKE);
		SET_ISAKMP_TRANSFORM_RESERVED(transform[i], 0);

		attr = transform[i] + ISAKMP_TRANSFORM_SA_ATTRS_OFF;

		if (attribute_set_constant(xf->field, "ENCRYPTION_ALGORITHM",
		    ike_encrypt_cst, IKE_ATTR_ENCRYPTION_ALGORITHM, &attr))
			goto bail_out;

		if (attribute_set_constant(xf->field, "HASH_ALGORITHM",
		    ike_hash_cst, IKE_ATTR_HASH_ALGORITHM, &attr))
			goto bail_out;

		if (attribute_set_constant(xf->field, "AUTHENTICATION_METHOD",
		    ike_auth_cst, IKE_ATTR_AUTHENTICATION_METHOD, &attr))
			goto bail_out;

		if (attribute_set_constant(xf->field, "GROUP_DESCRIPTION",
		    ike_group_desc_cst, IKE_ATTR_GROUP_DESCRIPTION, &attr)) {
			/*
			 * If no group description exists, try looking for
			 * a user-defined one.
			 */
			if (attribute_set_constant(xf->field, "GROUP_TYPE",
			    ike_group_cst, IKE_ATTR_GROUP_TYPE, &attr))
				goto bail_out;

#if 0
			if (attribute_set_bignum(xf->field, "GROUP_PRIME",
			    IKE_ATTR_GROUP_PRIME, &attr))
				goto bail_out;

			if (attribute_set_bignum(xf->field,
			    "GROUP_GENERATOR_2", IKE_ATTR_GROUP_GENERATOR_2,
			    &attr))
				goto bail_out;

			if (attribute_set_bignum(xf->field,
			    "GROUP_GENERATOR_2", IKE_ATTR_GROUP_GENERATOR_2,
			    &attr))
				goto bail_out;

			if (attribute_set_bignum(xf->field, "GROUP_CURVE_A",
			    IKE_ATTR_GROUP_CURVE_A, &attr))
				goto bail_out;

			if (attribute_set_bignum(xf->field, "GROUP_CURVE_B",
			    IKE_ATTR_GROUP_CURVE_B, &attr))
				goto bail_out;
#endif
		}
		/*
		 * Life durations are special, we should be able to specify
		 * several, one per type.
		 */
		life_conf = conf_get_list(xf->field, "Life");
		if (life_conf) {
			for (life = TAILQ_FIRST(&life_conf->fields); life;
			    life = TAILQ_NEXT(life, link)) {
				attribute_set_constant(life->field,
				    "LIFE_TYPE", ike_duration_cst,
				    IKE_ATTR_LIFE_TYPE, &attr);

				/*
				 * XXX Deals with 16 and 32 bit lifetimes
				 * only
				 */
				value = conf_get_num(life->field,
				    "LIFE_DURATION", 0);
				if (value) {
					if (value <= 0xffff)
						attr = attribute_set_basic(
						    attr,
						    IKE_ATTR_LIFE_DURATION,
						    value);
					else {
						value = htonl(value);
						attr = attribute_set_var(attr,
						    IKE_ATTR_LIFE_DURATION,
						    (u_int8_t *)&value,
						    sizeof value);
					}
				}
			}
			conf_free_list(life_conf);
		}
		attribute_set_constant(xf->field, "PRF", ike_prf_cst,
		    IKE_ATTR_PRF, &attr);

		value = conf_get_num(xf->field, "KEY_LENGTH", 0);
		if (value)
			attr = attribute_set_basic(attr, IKE_ATTR_KEY_LENGTH,
			    value);

		value = conf_get_num(xf->field, "FIELD_SIZE", 0);
		if (value)
			attr = attribute_set_basic(attr, IKE_ATTR_FIELD_SIZE,
			    value);

		value = conf_get_num(xf->field, "GROUP_ORDER", 0);
		if (value)
			attr = attribute_set_basic(attr, IKE_ATTR_GROUP_ORDER,
			    value);

		/* Record the real transform size.  */
		transforms_len += transform_len[i] = attr - transform[i];

		/* XXX I don't like exchange-specific stuff in here.  */
		if (exchange->type == ISAKMP_EXCH_AGGRESSIVE) {
			/*
			 * Make sure that if a group description is specified,
			 * it is specified for all transforms equally.
			 */
			attr = (u_int8_t *)conf_get_str(xf->field,
			    "GROUP_DESCRIPTION");
			new_group_desc =
			    attr ? constant_value(ike_group_desc_cst,
				(char *)attr) : 0;
			if (group_desc == -1)
				group_desc = new_group_desc;
			else if (group_desc != new_group_desc) {
				log_print("ike_phase_1_initiator_send_SA: "
				    "differing group descriptions in a "
				    "proposal");
				goto bail_out;
			}
		}
		/*
		 * We need to check that we actually support our
		 * configuration.
		 */
		if (attribute_map(transform[i] + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		    transform_len[i] - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		    exchange->doi->is_attribute_incompatible, msg)) {
			log_print("ike_phase_1_initiator_send_SA: "
			    "section [%s] has unsupported attribute(s)",
			    xf->field);
			goto bail_out;
		}
	}

	/* XXX I don't like exchange-specific stuff in here.  */
	if (exchange->type == ISAKMP_EXCH_AGGRESSIVE)
		ie->group = group_get(group_desc);

	proposal_len = ISAKMP_PROP_SPI_OFF;
	proposal = malloc(proposal_len);
	if (!proposal) {
		log_error("ike_phase_1_initiator_send_SA: malloc (%lu) failed",
		    (unsigned long)proposal_len);
		goto bail_out;
	}
	SET_ISAKMP_PROP_NO(proposal, 1);
	SET_ISAKMP_PROP_PROTO(proposal, ISAKMP_PROTO_ISAKMP);
	SET_ISAKMP_PROP_SPI_SZ(proposal, 0);
	SET_ISAKMP_PROP_NTRANSFORMS(proposal, conf->cnt);

	/* XXX I would like to see this factored out.  */
	proto = calloc(1, sizeof *proto);
	if (!proto) {
		log_error("ike_phase_1_initiator_send_SA: "
		    "calloc (1, %lu) failed", (unsigned long)sizeof *proto);
		goto bail_out;
	}
	proto->no = 1;
	proto->proto = ISAKMP_PROTO_ISAKMP;
	proto->sa = TAILQ_FIRST(&exchange->sa_list);
	proto->xf_cnt = conf->cnt;
	TAILQ_INIT(&proto->xfs);
	for (i = 0; i < proto->xf_cnt; i++) {
		pa = calloc(1, sizeof *pa);
		if (!pa)
			goto bail_out;
		pa->len = transform_len[i];
		pa->attrs = malloc(pa->len);
		if (!pa->attrs) {
			free(pa);
			goto bail_out;
		}
		memcpy(pa->attrs, transform[i], pa->len);
		TAILQ_INSERT_TAIL(&proto->xfs, pa, next);
	}
	TAILQ_INSERT_TAIL(&TAILQ_FIRST(&exchange->sa_list)->protos, proto,
	    link);

	sa_len = ISAKMP_SA_SIT_OFF + IPSEC_SIT_SIT_LEN;
	sa_buf = malloc(sa_len);
	if (!sa_buf) {
		log_error("ike_phase_1_initiator_send_SA: malloc (%lu) failed",
		    (unsigned long)sa_len);
		goto bail_out;
	}
	SET_ISAKMP_SA_DOI(sa_buf, IPSEC_DOI_IPSEC);
	SET_IPSEC_SIT_SIT(sa_buf + ISAKMP_SA_SIT_OFF, IPSEC_SIT_IDENTITY_ONLY);

	/*
	 * Add the payloads.  As this is a SA, we need to recompute the
	 * lengths of the payloads containing others.
	 */
	if (message_add_payload(msg, ISAKMP_PAYLOAD_SA, sa_buf, sa_len, 1))
		goto bail_out;
	SET_ISAKMP_GEN_LENGTH(sa_buf,
	    sa_len + proposal_len + transforms_len);
	sa_buf = 0;

	saved_nextp = msg->nextp;
	if (message_add_payload(msg, ISAKMP_PAYLOAD_PROPOSAL, proposal,
	    proposal_len, 0))
		goto bail_out;
	SET_ISAKMP_GEN_LENGTH(proposal, proposal_len + transforms_len);
	proposal = 0;

	update_nextp = 0;
	for (i = 0; i < conf->cnt; i++) {
		if (message_add_payload(msg, ISAKMP_PAYLOAD_TRANSFORM,
		    transform[i], transform_len[i], update_nextp))
			goto bail_out;
		update_nextp = 1;
		transform[i] = 0;
	}
	msg->nextp = saved_nextp;

	/* Save SA payload body in ie->sa_i_b, length ie->sa_i_b_len.  */
	ie->sa_i_b_len = sa_len + proposal_len + transforms_len -
	    ISAKMP_GEN_SZ;
	ie->sa_i_b = malloc(ie->sa_i_b_len);
	if (!ie->sa_i_b) {
		log_error("ike_phase_1_initiator_send_SA: malloc (%lu) failed",
		    (unsigned long)ie->sa_i_b_len);
		goto bail_out;
	}
	memcpy(ie->sa_i_b,
	    payload_first(msg, ISAKMP_PAYLOAD_SA)->p + ISAKMP_GEN_SZ,
	    sa_len - ISAKMP_GEN_SZ);
	memcpy(ie->sa_i_b + sa_len - ISAKMP_GEN_SZ,
	    payload_first(msg, ISAKMP_PAYLOAD_PROPOSAL)->p, proposal_len);
	transforms_len = 0;
	for (i = 0, p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]);
	    i < conf->cnt; i++, p = TAILQ_NEXT(p, link)) {
		memcpy(ie->sa_i_b + sa_len + proposal_len + transforms_len -
		    ISAKMP_GEN_SZ, p->p, transform_len[i]);
		transforms_len += transform_len[i];
	}

	/* Advertise OpenBSD isakmpd. */
	if (add_vendor_openbsd(msg))
		goto bail_out;

	/* Advertise NAT-T capability.  */
	if (nat_t_add_vendor_payloads(msg))
		goto bail_out;

	/* Advertise DPD capability.  */
	if (dpd_add_vendor_payload(msg))
		goto bail_out;

	conf_free_list(conf);
	free(transform);
	free(transform_len);
	return 0;

bail_out:
	free(sa_buf);
	free(proposal);
	if (transform) {
		for (i = 0; i < conf->cnt; i++)
			free(transform[i]);
		free(transform);
	}
	free(transform_len);
	conf_free_list(conf);
	return -1;
}

/* Figure out what transform the responder chose.  */
int
ike_phase_1_initiator_recv_SA(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct sa      *sa = TAILQ_FIRST(&exchange->sa_list);
	struct ipsec_exch *ie = exchange->data;
	struct ipsec_sa *isa = sa->data;
	struct payload *sa_p = payload_first(msg, ISAKMP_PAYLOAD_SA);
	struct payload *prop = payload_first(msg, ISAKMP_PAYLOAD_PROPOSAL);
	struct payload *xf = payload_first(msg, ISAKMP_PAYLOAD_TRANSFORM);

	/*
	 * IKE requires that only one SA with only one proposal exists and
	 * since we are getting an answer on our transform offer, only one
	 * transform.
	 */
	if (TAILQ_NEXT(sa_p, link) || TAILQ_NEXT(prop, link) ||
	    TAILQ_NEXT(xf, link)) {
		log_print("ike_phase_1_initiator_recv_SA: "
		    "multiple SA, proposal or transform payloads in phase 1");
		/* XXX Is there a better notification type?  */
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		return -1;
	}
	/* Check that the chosen transform matches an offer.  */
	if (message_negotiate_sa(msg, ike_phase_1_validate_prop) ||
	    !TAILQ_FIRST(&sa->protos))
		return -1;

	ipsec_decode_transform(msg, sa, TAILQ_FIRST(&sa->protos), xf->p);

	/* XXX I don't like exchange-specific stuff in here.  */
	if (exchange->type != ISAKMP_EXCH_AGGRESSIVE)
		ie->group = group_get(isa->group_desc);

	/* Mark the SA as handled.  */
	sa_p->flags |= PL_MARK;

	return 0;
}

/* Send our public DH value and a nonce to the responder.  */
int
ike_phase_1_initiator_send_KE_NONCE(struct message *msg)
{
	struct ipsec_exch *ie = msg->exchange->data;

	ie->g_x_len = dh_getlen(ie->group);

	/* XXX I want a better way to specify the nonce's size.  */
	return ike_phase_1_send_KE_NONCE(msg, 16);
}

/* Accept responder's public DH value and nonce.  */
int
ike_phase_1_initiator_recv_KE_NONCE(struct message *msg)
{
	if (ike_phase_1_recv_KE_NONCE(msg))
		return -1;

	return ike_phase_1_post_exchange_KE_NONCE(msg);
}

/*
 * Accept a set of transforms offered by the initiator and chose one we can
 * handle.
 */
int
ike_phase_1_responder_recv_SA(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct sa      *sa = TAILQ_FIRST(&exchange->sa_list);
	struct ipsec_sa *isa = sa->data;
	struct payload *sa_p = payload_first(msg, ISAKMP_PAYLOAD_SA);
	struct payload *prop = payload_first(msg, ISAKMP_PAYLOAD_PROPOSAL);
	struct ipsec_exch *ie = exchange->data;

	/* Mark the SA as handled.  */
	sa_p->flags |= PL_MARK;

	/* IKE requires that only one SA with only one proposal exists.  */
	if (TAILQ_NEXT(sa_p, link) || TAILQ_NEXT(prop, link)) {
		log_print("ike_phase_1_responder_recv_SA: "
		    "multiple SA or proposal payloads in phase 1");
		/* XXX Is there a better notification type?  */
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		return -1;
	}
	/* Chose a transform from the SA.  */
	if (message_negotiate_sa(msg, ike_phase_1_validate_prop) ||
	    !TAILQ_FIRST(&sa->protos))
		return -1;

	/* XXX Move into message_negotiate_sa?  */
	ipsec_decode_transform(msg, sa, TAILQ_FIRST(&sa->protos),
	    TAILQ_FIRST(&sa->protos)->chosen->p);

	ie->group = group_get(isa->group_desc);

	/*
	 * Check that the mandatory attributes: encryption, hash,
	 * authentication method and Diffie-Hellman group description, has
	 * been supplied.
	 */
	if (!exchange->crypto || !ie->hash || !ie->ike_auth || !ie->group) {
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		return -1;
	}
	/* Save the body for later hash computation.  */
	ie->sa_i_b_len = GET_ISAKMP_GEN_LENGTH(sa_p->p) - ISAKMP_GEN_SZ;
	ie->sa_i_b = malloc(ie->sa_i_b_len);
	if (!ie->sa_i_b) {
		/* XXX How to notify peer?  */
		log_error("ike_phase_1_responder_recv_SA: malloc (%lu) failed",
		    (unsigned long)ie->sa_i_b_len);
		return -1;
	}
	memcpy(ie->sa_i_b, sa_p->p + ISAKMP_GEN_SZ, ie->sa_i_b_len);
	return 0;
}

/* Reply with the transform we chose.  */
int
ike_phase_1_responder_send_SA(struct message *msg)
{
	/* Add the SA payload with the transform that was chosen.  */
	if (message_add_sa_payload(msg))
		return -1;

	/* Advertise OpenBSD isakmpd. */
	if (add_vendor_openbsd(msg))
		return -1;

	/* Advertise NAT-T capability.  */
	if (nat_t_add_vendor_payloads(msg))
		return -1;

	/* Advertise DPD capability.  */
	if (dpd_add_vendor_payload(msg))
		return -1;
	return 0;
}

/* Send our public DH value and a nonce to the peer.  */
int
ike_phase_1_send_KE_NONCE(struct message *msg, size_t nonce_sz)
{
	/* Public DH key.  */
	if (ipsec_gen_g_x(msg)) {
		/* XXX How to log and notify peer?  */
		return -1;
	}
	/* Generate a nonce, and add it to the message.  */
	if (exchange_gen_nonce(msg, nonce_sz)) {
		/* XXX Log?  */
		return -1;
	}
	/* Are there any CERTREQs to send? */
	if (exchange_add_certreqs(msg)) {
		/* XXX Log? */
		return -1;
	}
	/* Try to add certificates which are acceptable for the CERTREQs */
	if (exchange_add_certs(msg)) {
		/* XXX Log? */
		return -1;
	}
	/* If this exchange uses NAT-Traversal, add NAT-D payloads now.  */
	if (msg->exchange->flags & EXCHANGE_FLAG_NAT_T_CAP_PEER)
		if (nat_t_exchange_add_nat_d(msg)) {
			/* XXX Log? */
			return -1;
		}
	return 0;
}

/* Receive our peer's public DH value and nonce.  */
int
ike_phase_1_recv_KE_NONCE(struct message *msg)
{
	/* Copy out the initiator's DH public value.  */
	if (ipsec_save_g_x(msg)) {
		/* XXX How to log and notify peer?  */
		return -1;
	}
	/* Copy out the initiator's nonce.  */
	if (exchange_save_nonce(msg)) {
		/* XXX How to log and notify peer?  */
		return -1;
	}
	/* Copy out the initiator's cert requests.  */
	if (exchange_save_certreq(msg)) {
		/* XXX How to log and notify peer?  */
		return -1;
	}
	/* MainMode: Check for NAT-D payloads and contents.  */
	if (msg->exchange->type == ISAKMP_EXCH_ID_PROT &&
	    msg->exchange->flags & EXCHANGE_FLAG_NAT_T_CAP_PEER)
		(void)nat_t_exchange_check_nat_d(msg);
	return 0;
}

/*
 * Compute DH values and key material.  This is done in a post-send function
 * as that means we can do parallel work in both the initiator and responder
 * thus speeding up exchanges.
 */
int
ike_phase_1_post_exchange_KE_NONCE(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct prf     *prf;
	struct hash    *hash = ie->hash;
	enum cryptoerr  err;

	/* Compute Diffie-Hellman shared value.  */
	ie->g_xy = malloc(ie->g_x_len);
	if (!ie->g_xy) {
		/* XXX How to notify peer?  */
		log_error("ike_phase_1_post_exchange_KE_NONCE: "
		    "malloc (%lu) failed", (unsigned long)ie->g_x_len);
		return -1;
	}
	if (dh_create_shared(ie->group, ie->g_xy,
	    exchange->initiator ? ie->g_xr : ie->g_xi)) {
		log_print("ike_phase_1_post_exchange_KE_NONCE: "
		    "dh_create_shared failed");
		return -1;
	}
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "ike_phase_1_post_exchange_KE_NONCE: g^xy", ie->g_xy,
	    ie->g_x_len));

	/* Compute the SKEYID depending on the authentication method.  */
	ie->skeyid = ie->ike_auth->gen_skeyid(exchange, &ie->skeyid_len);
	if (!ie->skeyid) {
		/* XXX Log and teardown?  */
		return -1;
	}
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "ike_phase_1_post_exchange_KE_NONCE: SKEYID", ie->skeyid,
	    ie->skeyid_len));

	/* SKEYID_d.  */
	ie->skeyid_d = malloc(ie->skeyid_len);
	if (!ie->skeyid_d) {
		/* XXX How to notify peer?  */
		log_error("ike_phase_1_post_exchange_KE_NONCE: "
		    "malloc (%lu) failed", (unsigned long)ie->skeyid_len);
		return -1;
	}
	prf = prf_alloc(ie->prf_type, hash->type, ie->skeyid, ie->skeyid_len);
	if (!prf) {
		/* XXX Log and teardown?  */
		return -1;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, ie->g_xy, ie->g_x_len);
	prf->Update(prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
	prf->Update(prf->prfctx, (unsigned char *)"\0", 1);
	prf->Final(ie->skeyid_d, prf->prfctx);
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "ike_phase_1_post_exchange_KE_NONCE: SKEYID_d", ie->skeyid_d,
	    ie->skeyid_len));

	/* SKEYID_a.  */
	ie->skeyid_a = malloc(ie->skeyid_len);
	if (!ie->skeyid_a) {
		log_error("ike_phase_1_post_exchange_KE_NONCE: "
		    "malloc (%lu) failed", (unsigned long)ie->skeyid_len);
		prf_free(prf);
		return -1;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, ie->skeyid_d, ie->skeyid_len);
	prf->Update(prf->prfctx, ie->g_xy, ie->g_x_len);
	prf->Update(prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
	prf->Update(prf->prfctx, (unsigned char *)"\1", 1);
	prf->Final(ie->skeyid_a, prf->prfctx);
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "ike_phase_1_post_exchange_KE_NONCE: SKEYID_a", ie->skeyid_a,
	    ie->skeyid_len));

	/* SKEYID_e.  */
	ie->skeyid_e = malloc(ie->skeyid_len);
	if (!ie->skeyid_e) {
		/* XXX How to notify peer?  */
		log_error("ike_phase_1_post_exchange_KE_NONCE: "
		    "malloc (%lu) failed", (unsigned long)ie->skeyid_len);
		prf_free(prf);
		return -1;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, ie->skeyid_a, ie->skeyid_len);
	prf->Update(prf->prfctx, ie->g_xy, ie->g_x_len);
	prf->Update(prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
	prf->Update(prf->prfctx, (unsigned char *)"\2", 1);
	prf->Final(ie->skeyid_e, prf->prfctx);
	prf_free(prf);
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "ike_phase_1_post_exchange_KE_NONCE: SKEYID_e", ie->skeyid_e,
	    ie->skeyid_len));

	/* Key length determination.  */
	if (!exchange->key_length)
		exchange->key_length = exchange->crypto->keymax;

	/* Derive a longer key from skeyid_e */
	if (ie->skeyid_len < exchange->key_length) {
		u_int16_t       len, keylen;
		u_int8_t       *key, *p;

		prf = prf_alloc(ie->prf_type, hash->type, ie->skeyid_e,
		    ie->skeyid_len);
		if (!prf) {
			/* XXX - notify peer */
			return -1;
		}
		/* Make keylen a multiple of prf->blocksize */
		keylen = exchange->key_length;
		if (keylen % prf->blocksize)
			keylen += prf->blocksize - (keylen % prf->blocksize);

		key = malloc(keylen);
		if (!key) {
			/* XXX - Notify peer.  */
			prf_free(prf);
			log_error("ike_phase_1_post_exchange_KE_NONCE: "
			    "malloc (%d) failed", keylen);
			return -1;
		}
		prf->Init(prf->prfctx);
		prf->Update(prf->prfctx, (unsigned char *)"\0", 1);
		prf->Final(key, prf->prfctx);

		for (len = prf->blocksize, p = key; len < exchange->key_length;
		    len += prf->blocksize, p += prf->blocksize) {
			prf->Init(prf->prfctx);
			prf->Update(prf->prfctx, p, prf->blocksize);
			prf->Final(p + prf->blocksize, prf->prfctx);
		}
		prf_free(prf);

		/* Setup our keystate using the derived encryption key.  */
		exchange->keystate = crypto_init(exchange->crypto, key,
		    exchange->key_length, &err);

		free(key);
	} else
		/* Setup our keystate using the raw skeyid_e.  */
		exchange->keystate = crypto_init(exchange->crypto,
		    ie->skeyid_e, exchange->key_length, &err);

	/* Special handling for DES weak keys.  */
	if (!exchange->keystate && err == EWEAKKEY &&
	    (exchange->key_length << 1) <= ie->skeyid_len) {
		log_print("ike_phase_1_post_exchange_KE_NONCE: "
		    "weak key, trying subseq. skeyid_e");
		exchange->keystate = crypto_init(exchange->crypto,
		    ie->skeyid_e + exchange->key_length,
		    exchange->key_length, &err);
	}
	if (!exchange->keystate) {
		log_print("ike_phase_1_post_exchange_KE_NONCE: "
		    "exchange->crypto->init () failed: %d", err);

		/*
		 * XXX We really need to know if problems are of transient
		 * nature or fatal (like failed assertions etc.)
		 */
		return -1;
	}
	/* Setup IV.  XXX Only for CBC transforms, no?  */
	hash->Init(hash->ctx);
	hash->Update(hash->ctx, ie->g_xi, ie->g_x_len);
	hash->Update(hash->ctx, ie->g_xr, ie->g_x_len);
	hash->Final(hash->digest, hash->ctx);
	crypto_init_iv(exchange->keystate, hash->digest,
	    exchange->crypto->blocksize);
	return 0;
}

int
ike_phase_1_responder_send_ID_AUTH(struct message *msg)
{
	if (ike_phase_1_send_ID(msg))
		return -1;

	return ike_phase_1_send_AUTH(msg);
}

int
ike_phase_1_send_ID(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	u_int8_t       *buf;
	char            header[80];
	ssize_t         sz;
	struct sockaddr *src;
	int             initiator = exchange->initiator;
	u_int8_t      **id;
	size_t         *id_len;
	char           *my_id = 0, *data;
	u_int8_t        id_type;
	sa_family_t	af = 0;

	/* Choose the right fields to fill-in.  */
	id = initiator ? &exchange->id_i : &exchange->id_r;
	id_len = initiator ? &exchange->id_i_len : &exchange->id_r_len;

	if (exchange->name)
		my_id = conf_get_str(exchange->name, "ID");

	if (!my_id)
		my_id = conf_get_str("General", "Default-phase-1-ID");

	msg->transport->vtbl->get_src(msg->transport, &src);
	sz = my_id ? ipsec_id_size(my_id, &id_type) : sockaddr_addrlen(src);
	if (sz == -1)
		return -1;

	sz += ISAKMP_ID_DATA_OFF;
	buf = malloc(sz);
	if (!buf) {
		log_error("ike_phase_1_send_ID: malloc (%lu) failed",
			  (unsigned long)sz);
		return -1;
	}
	SET_IPSEC_ID_PROTO(buf + ISAKMP_ID_DOI_DATA_OFF, 0);
	SET_IPSEC_ID_PORT(buf + ISAKMP_ID_DOI_DATA_OFF, 0);
	if (my_id) {
		SET_ISAKMP_ID_TYPE(buf, id_type);
		switch (id_type) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV4_ADDR_SUBNET:
			af = AF_INET;
			break;
		case IPSEC_ID_IPV6_ADDR:
		case IPSEC_ID_IPV6_ADDR_SUBNET:
			af = AF_INET6;
			break;
		}
		switch (id_type) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV6_ADDR:
			data = conf_get_str(my_id, "Address");
			if (!data) {
				log_print("ike_phase_1_send_ID: section %s "
				    "has no \"Address\" tag", my_id);
				free(buf);
				return -1;
			}
			if (text2sockaddr(data, NULL, &src, af, 0)) {
				log_error("ike_phase_1_send_ID: "
				    "text2sockaddr() failed");
				free(buf);
				return -1;
			}
			memcpy(buf + ISAKMP_ID_DATA_OFF,
			    sockaddr_addrdata(src), sockaddr_addrlen(src));
			free(src);
			break;

		case IPSEC_ID_IPV4_ADDR_SUBNET:
		case IPSEC_ID_IPV6_ADDR_SUBNET:
			/* Network */
			data = conf_get_str(my_id, "Network");
			if (!data) {
				log_print("ike_phase_1_send_ID: section %s "
				    "has no \"Network\" tag", my_id);
				free(buf);
				return -1;
			}
			if (text2sockaddr(data, NULL, &src, af, 0)) {
				log_error("ike_phase_1_send_ID: "
				    "text2sockaddr() failed");
				free(buf);
				return -1;
			}
			memcpy(buf + ISAKMP_ID_DATA_OFF,
			    sockaddr_addrdata(src), sockaddr_addrlen(src));
			free(src);
			/* Netmask */
			data = conf_get_str(my_id, "Netmask");
			if (!data) {
				log_print("ike_phase_1_send_ID: section %s "
				    "has no \"Netmask\" tag", my_id);
				free(buf);
				return -1;
			}
			if (text2sockaddr(data, NULL, &src, af, 1)) {
				log_error("ike_phase_1_send_ID: "
				    "text2sockaddr() failed");
				free(buf);
				return -1;
			}
			memcpy(buf + ISAKMP_ID_DATA_OFF +
			    sockaddr_addrlen(src), sockaddr_addrdata(src),
			    sockaddr_addrlen(src));
			free(src);
			break;

		case IPSEC_ID_FQDN:
		case IPSEC_ID_USER_FQDN:
		case IPSEC_ID_KEY_ID:
			data = conf_get_str(my_id, "Name");
			if (!data) {
				log_print("ike_phase_1_send_ID: section %s "
				    "has no \"Name\" tag", my_id);
				free(buf);
				return -1;
			}
			memcpy(buf + ISAKMP_ID_DATA_OFF, data,
			    sz - ISAKMP_ID_DATA_OFF);
			break;

		default:
			log_print("ike_phase_1_send_ID: "
			    "unsupported ID type %d", id_type);
			free(buf);
			return -1;
		}
	} else {
		switch (src->sa_family) {
		case AF_INET:
			SET_ISAKMP_ID_TYPE(buf, IPSEC_ID_IPV4_ADDR);
			break;
		case AF_INET6:
			SET_ISAKMP_ID_TYPE(buf, IPSEC_ID_IPV6_ADDR);
			break;
		}
		/* Already in network byteorder.  */
		memcpy(buf + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(src),
		    sockaddr_addrlen(src));
	}

	if (message_add_payload(msg, ISAKMP_PAYLOAD_ID, buf, sz, 1)) {
		free(buf);
		return -1;
	}
	*id_len = sz - ISAKMP_GEN_SZ;
	*id = malloc(*id_len);
	if (!*id) {
		log_error("ike_phase_1_send_ID: malloc (%lu) failed",
		    (unsigned long)*id_len);
		return -1;
	}
	memcpy(*id, buf + ISAKMP_GEN_SZ, *id_len);
	snprintf(header, sizeof header, "ike_phase_1_send_ID: %s",
	    constant_name(ipsec_id_cst, GET_ISAKMP_ID_TYPE(buf)));
	LOG_DBG_BUF((LOG_NEGOTIATION, 40, header, buf + ISAKMP_ID_DATA_OFF,
	    sz - ISAKMP_ID_DATA_OFF));
	return 0;
}

int
ike_phase_1_send_AUTH(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;

	if (ie->ike_auth->encode_hash(msg)) {
		/* XXX Log? */
		return -1;
	}
	/*
	 * XXX Many people say the COMMIT flag is just junk, especially in
	 * Phase 1.
	 */
#ifdef notyet
	if ((exchange->flags & EXCHANGE_FLAG_COMMITTED) == 0)
		exchange->flags |= EXCHANGE_FLAG_I_COMMITTED;
#endif

	return 0;
}

/* Receive ID and HASH and check that the exchange has been consistent.  */
int
ike_phase_1_recv_ID_AUTH(struct message *msg)
{
	if (ike_phase_1_recv_ID(msg))
		return -1;

	return ike_phase_1_recv_AUTH(msg);
}

/* Receive ID.  */
int
ike_phase_1_recv_ID(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct payload *payload;
	char            header[80], *rs = 0, *rid = 0, *p;
	int             initiator = exchange->initiator;
	u_int8_t      **id, id_type;
	size_t         *id_len;
	ssize_t         sz;
	struct sockaddr *sa;
	sa_family_t	af = 0;

	payload = payload_first(msg, ISAKMP_PAYLOAD_ID);

	if (exchange->name)
		rs = conf_get_str(exchange->name, "Remote-ID");

	if (rs) {
		sz = ipsec_id_size(rs, &id_type);
		if (sz == -1) {
			log_print("ike_phase_1_recv_ID: could not handle "
			    "specified Remote-ID [%s]", rs);
			return -1;
		}
		rid = malloc(sz);
		if (!rid) {
			log_error("ike_phase_1_recv_ID: malloc (%lu) failed",
			    (unsigned long)sz);
			return -1;
		}
		switch (id_type) {
		case IPSEC_ID_IPV4_ADDR:
			af = AF_INET;
			break;
		case IPSEC_ID_IPV6_ADDR:
			af = AF_INET6;
			break;
		}
		switch (id_type) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV6_ADDR:
			p = conf_get_str(rs, "Address");
			if (!p) {
				log_print("ike_phase_1_recv_ID: failed to get "
				    "Address in Remote-ID section [%s]", rs);
				free(rid);
				return -1;
			}
			if (text2sockaddr(p, 0, &sa, af, 0) == -1) {
				log_print("ike_phase_1_recv_ID: "
				    "failed to parse address %s", p);
				free(rid);
				return -1;
			}
			if ((id_type == IPSEC_ID_IPV4_ADDR &&
			    sa->sa_family != AF_INET) ||
			    (id_type == IPSEC_ID_IPV6_ADDR &&
			    sa->sa_family != AF_INET6)) {
				log_print("ike_phase_1_recv_ID: "
				    "address %s not of expected family", p);
				free(rid);
				free(sa);
				return -1;
			}
			memcpy(rid, sockaddr_addrdata(sa),
			    sockaddr_addrlen(sa));
			free(sa);
			break;

		case IPSEC_ID_FQDN:
		case IPSEC_ID_USER_FQDN:
		case IPSEC_ID_KEY_ID:
			p = conf_get_str(rs, "Name");
			if (!p) {
				log_print("ike_phase_1_recv_ID: failed to "
				    "get Name in Remote-ID section [%s]", rs);
				free(rid);
				return -1;
			}
			memcpy(rid, p, sz);
			break;

		default:
			log_print("ike_phase_1_recv_ID: "
			    "unsupported ID type %d", id_type);
			free(rid);
			return -1;
		}

		/* Compare expected/desired and received remote ID */
		if (memcmp(rid, payload->p + ISAKMP_ID_DATA_OFF, sz) != 0) {
			free(rid);
			log_print("ike_phase_1_recv_ID: "
			    "received remote ID other than expected %s", p);
			return -1;
		}
		free(rid);
	}
	/* Choose the right fields to fill in */
	id = initiator ? &exchange->id_r : &exchange->id_i;
	id_len = initiator ? &exchange->id_r_len : &exchange->id_i_len;

	*id_len = GET_ISAKMP_GEN_LENGTH(payload->p) - ISAKMP_GEN_SZ;
	*id = malloc(*id_len);
	if (!*id) {
		log_error("ike_phase_1_recv_ID: malloc (%lu) failed",
		    (unsigned long)*id_len);
		return -1;
	}
	memcpy(*id, payload->p + ISAKMP_GEN_SZ, *id_len);
	snprintf(header, sizeof header, "ike_phase_1_recv_ID: %s",
	    constant_name(ipsec_id_cst, GET_ISAKMP_ID_TYPE(payload->p)));
	LOG_DBG_BUF((LOG_NEGOTIATION, 40, header,
	    payload->p + ISAKMP_ID_DATA_OFF,
	    *id_len + ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF));
	payload->flags |= PL_MARK;
	return 0;
}

/* Receive HASH and check that the exchange has been consistent.  */
int
ike_phase_1_recv_AUTH(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct prf     *prf;
	struct hash    *hash = ie->hash;
	char            header[80];
	size_t          hashsize = hash->hashsize;
	int             initiator = exchange->initiator;
	u_int8_t      **hash_p, *id;
	size_t          id_len;

	/* Choose the right fields to fill in */
	hash_p = initiator ? &ie->hash_r : &ie->hash_i;
	id = initiator ? exchange->id_r : exchange->id_i;
	id_len = initiator ? exchange->id_r_len : exchange->id_i_len;

	/* The decoded hash will be in ie->hash_r or ie->hash_i */
	if (ie->ike_auth->decode_hash(msg)) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION, 0, 1,
		    0);
		return -1;
	}
	/* Allocate the prf and start calculating his HASH.  */
	prf = prf_alloc(ie->prf_type, hash->type, ie->skeyid, ie->skeyid_len);
	if (!prf) {
		/* XXX Log?  */
		return -1;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, initiator ? ie->g_xr : ie->g_xi, ie->g_x_len);
	prf->Update(prf->prfctx, initiator ? ie->g_xi : ie->g_xr, ie->g_x_len);
	prf->Update(prf->prfctx, exchange->cookies +
	    (initiator ? ISAKMP_HDR_RCOOKIE_OFF : ISAKMP_HDR_ICOOKIE_OFF),
	    ISAKMP_HDR_ICOOKIE_LEN);
	prf->Update(prf->prfctx, exchange->cookies +
	    (initiator ? ISAKMP_HDR_ICOOKIE_OFF : ISAKMP_HDR_RCOOKIE_OFF),
	    ISAKMP_HDR_ICOOKIE_LEN);
	prf->Update(prf->prfctx, ie->sa_i_b, ie->sa_i_b_len);
	prf->Update(prf->prfctx, id, id_len);
	prf->Final(hash->digest, prf->prfctx);
	prf_free(prf);
	snprintf(header, sizeof header, "ike_phase_1_recv_AUTH: "
	    "computed HASH_%c", initiator ? 'R' : 'I');
	LOG_DBG_BUF((LOG_NEGOTIATION, 80, header, hash->digest, hashsize));

	/* Check that the hash we got matches the one we computed.  */
	if (memcmp(*hash_p, hash->digest, hashsize) != 0) {
		/* XXX Log?  */
		return -1;
	}

	/* Mark message as authenticated. */
	msg->flags |= MSG_AUTHENTICATED;

	return 0;
}

struct attr_node {
	LIST_ENTRY(attr_node) link;
	u_int16_t       type;
};

struct validation_state {
	struct conf_list_node *xf;
	LIST_HEAD(attr_head, attr_node) attrs;
	char           *life;
};

/* Validate a proposal inside SA according to EXCHANGE's policy.  */
static int
ike_phase_1_validate_prop(struct exchange *exchange, struct sa *sa,
    struct sa *isakmp_sa)
{
	struct conf_list *conf, *tags;
	struct conf_list_node *xf, *tag;
	struct proto   *proto;
	struct validation_state vs;
	struct attr_node *node, *next_node;

	/* Get the list of transforms.  */
	conf = conf_get_list(exchange->policy, "Transforms");
	if (!conf)
		return 0;

	for (xf = TAILQ_FIRST(&conf->fields); xf; xf = TAILQ_NEXT(xf, link)) {
		for (proto = TAILQ_FIRST(&sa->protos); proto;
		    proto = TAILQ_NEXT(proto, link)) {
			/* Mark all attributes in our policy as unseen.  */
			LIST_INIT(&vs.attrs);
			vs.xf = xf;
			vs.life = 0;
			if (attribute_map(proto->chosen->p +
			    ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			    GET_ISAKMP_GEN_LENGTH(proto->chosen->p) -
			    ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			    attribute_unacceptable, &vs))
				goto try_next;

			/* Sweep over unseen tags in this section.  */
			tags = conf_get_tag_list(xf->field);
			if (tags) {
				for (tag = TAILQ_FIRST(&tags->fields); tag;
				    tag = TAILQ_NEXT(tag, link))
					/*
					 * XXX Should we care about attributes
					 * we have, they do not provide?
					 */
					for (node = LIST_FIRST(&vs.attrs);
					    node; node = next_node) {
						next_node =
						    LIST_NEXT(node, link);
						if (node->type ==
						    constant_value(ike_attr_cst,
						    tag->field)) {
							LIST_REMOVE(node, link);
							free(node);
						}
					}
				conf_free_list(tags);
			}
			/* Are there leftover tags in this section?  */
			node = LIST_FIRST(&vs.attrs);
			if (node)
				goto try_next;
		}

		/* All protocols were OK, we succeeded.  */
		LOG_DBG((LOG_NEGOTIATION, 20, "ike_phase_1_validate_prop: "
		    "success"));
		conf_free_list(conf);
		free(vs.life);
		return 1;

try_next:
		/* Are there leftover tags in this section?  */
		node = LIST_FIRST(&vs.attrs);
		while (node) {
			LIST_REMOVE(node, link);
			free(node);
			node = LIST_FIRST(&vs.attrs);
		}
		free(vs.life);
	}

	LOG_DBG((LOG_NEGOTIATION, 20, "ike_phase_1_validate_prop: failure"));
	conf_free_list(conf);
	return 0;
}

/*
 * Look at the attribute of type TYPE, located at VALUE for LEN bytes forward.
 * The VVS argument holds a validation state kept across invocations.
 * If the attribute is unacceptable to use, return non-zero, otherwise zero.
 */
static int
attribute_unacceptable(u_int16_t type, u_int8_t *value, u_int16_t len,
    void *vvs)
{
	struct validation_state *vs = vvs;
	struct conf_list *life_conf;
	struct conf_list_node *xf = vs->xf, *life;
	char           *tag = constant_lookup(ike_attr_cst, type);
	char           *str;
	struct constant_map *map;
	struct attr_node *node;
	int             rv, dur = 0;

	if (!tag) {
		log_print("attribute_unacceptable: "
		    "attribute type %d not known", type);
		return 1;
	}
	switch (type) {
	case IKE_ATTR_ENCRYPTION_ALGORITHM:
	case IKE_ATTR_HASH_ALGORITHM:
	case IKE_ATTR_AUTHENTICATION_METHOD:
	case IKE_ATTR_GROUP_DESCRIPTION:
	case IKE_ATTR_GROUP_TYPE:
	case IKE_ATTR_PRF:
		str = conf_get_str(xf->field, tag);
		if (!str) {
			/* This attribute does not exist in this policy.  */
			log_print("attribute_unacceptable: "
			    "attr %s does not exist in %s", tag, xf->field);
			return 1;
		}
		map = constant_link_lookup(ike_attr_cst, type);
		if (!map)
			return 1;

		if ((constant_value(map, str) == decode_16(value)) ||
		    (!strcmp(str, "ANY"))) {
			/* Mark this attribute as seen.  */
			node = malloc(sizeof *node);
			if (!node) {
				log_error("attribute_unacceptable: "
				    "malloc (%lu) failed",
				    (unsigned long)sizeof *node);
				return 1;
			}
			node->type = type;
			LIST_INSERT_HEAD(&vs->attrs, node, link);
			return 0;
		}
		log_print("attribute_unacceptable: %s: got %s, expected %s",
		    tag, constant_name(map, decode_16(value)), str);
		return 1;

	case IKE_ATTR_GROUP_PRIME:
	case IKE_ATTR_GROUP_GENERATOR_1:
	case IKE_ATTR_GROUP_GENERATOR_2:
	case IKE_ATTR_GROUP_CURVE_A:
	case IKE_ATTR_GROUP_CURVE_B:
		/* XXX Bignums not handled yet.  */
		log_print("attribute_unacceptable: "
		    "bignum type %d not supported", type);
		return 1;

	case IKE_ATTR_LIFE_TYPE:
	case IKE_ATTR_LIFE_DURATION:
		life_conf = conf_get_list(xf->field, "Life");
		if (life_conf &&
		    !strcmp(conf_get_str(xf->field, "Life"), "ANY")) {
			conf_free_list(life_conf);
			return 0;
		}

		rv = 1;
		if (!life_conf) {
			/* Life attributes given, but not in our policy.  */
			log_print("attribute_unacceptable: "
			    "life attribute received, none in policy");
			return 1;
		}
		/*
		 * Each lifetime type must match, otherwise we turn the
		 * proposal down. In order to do this we need to find the
		 * specific section of our policy's "Life" list and match
		 * its duration.
		 */
		switch (type) {
		case IKE_ATTR_LIFE_TYPE:
			for (life = TAILQ_FIRST(&life_conf->fields); life;
			    life = TAILQ_NEXT(life, link)) {
				str = conf_get_str(life->field, "LIFE_TYPE");
				if (!str) {
					log_print("attribute_unacceptable: "
					    "section [%s] has no LIFE_TYPE",
					    life->field);
					continue;
				}

				/*
				 * If this is the type we are looking at,
				 * save a pointer to this section in vs->life.
				 */
				if (constant_value(ike_duration_cst, str) ==
				    decode_16(value)) {
					vs->life = strdup(life->field);
					rv = 0;
					goto bail_out;
				}
			}
			log_print("attribute_unacceptable: "
			    "unrecognized LIFE_TYPE %d", decode_16(value));
			vs->life = 0;
			break;

		case IKE_ATTR_LIFE_DURATION:
			if (!vs->life) {
				log_print("attribute_unacceptable: "
				    "LIFE_DURATION without LIFE_TYPE");
				rv = 1;
				goto bail_out;
			}
			str = conf_get_str(vs->life, "LIFE_DURATION");
			if (str) {
				if (!strcmp(str, "ANY"))
					rv = 0;
				else
					dur = (len == 4) ? decode_32(value) :
					    decode_16(value);
					if ((rv = !conf_match_num(vs->life,
					    "LIFE_DURATION", dur))) {
						log_print(
						    "attribute_unacceptable: "
						    "LIFE_DURATION: got %d, "
						    " expected %s", dur, str);
					}
			} else {
				log_print("attribute_unacceptable: "
				    "section [%s] has no LIFE_DURATION",
				    vs->life);
				rv = 1;
			}

			free(vs->life);
			vs->life = 0;
			break;
		}

bail_out:
		conf_free_list(life_conf);
		return rv;

	case IKE_ATTR_KEY_LENGTH:
	case IKE_ATTR_FIELD_SIZE:
	case IKE_ATTR_GROUP_ORDER:
		if (conf_match_num(xf->field, tag, decode_16(value))) {
			/* Mark this attribute as seen.  */
			node = malloc(sizeof *node);
			if (!node) {
				log_error("attribute_unacceptable: "
				    "malloc (%lu) failed",
				    (unsigned long)sizeof *node);
				return 1;
			}
			node->type = type;
			LIST_INSERT_HEAD(&vs->attrs, node, link);
			return 0;
		}
		return 1;
	default:
		log_print("attribute_unacceptable: unexpected type %d",
		    type);
	}
	return 1;
}
@


1.75
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.74 2015/02/15 01:56:42 tedu Exp $	 */
d383 1
a383 2
			if (transform[i])
				free(transform[i]);
@


1.74
log
@convert bcmp to memcmp
ok doug millert miod
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.73 2014/08/22 07:59:52 doug Exp $	 */
d287 1
a287 1
		pa = (struct proto_attr *)calloc(1, sizeof *pa);
d291 1
a291 1
		pa->attrs = (u_int8_t *)malloc(pa->len);
@


1.73
log
@fix memory leak in isakmpd

ok gerhard@@ (also corrected first version)
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.72 2010/06/29 19:50:16 reyk Exp $	 */
d1073 1
a1073 1
		if (bcmp(rid, payload->p + ISAKMP_ID_DATA_OFF, sz)) {
@


1.72
log
@Replace the hand-crafted Diffie-Hellman implementation in isakmpd with
the smaller implementation from iked that is using libcrypto instead.
This allows to remove a lot of code (which is always good), get rid of
some custom crypto code by using libcrypto, theoretically adds
support for many new MODP and EC2N/ECP modes (but it is not configurable
yet), and allows to share the dh.c/dh.h code in different codebases
(it is identical in isakmpd and iked, but could also be used elsewhere).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.71 2008/02/06 11:37:53 moritz Exp $	 */
d720 1
@


1.71
log
@Fix possible memory leaks when sending phase 1 IDs.
From Igor Zinovik <zinovik@@cs.karelia.ru>

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.70 2007/08/05 09:43:09 tom Exp $	 */
a54 1
#include "math_group.h"
@


1.70
log
@Allow key exchange with RSA signature authentication to work with
Cisco IOS and other initiators that only send their certs in response
to CERT_REQUEST.

With input and help from cloder@@, Stuart Henderson, mpf@@, and several
others who did lots of testing - thanks to all.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.69 2007/05/07 18:19:56 cloder Exp $	 */
d843 1
d849 1
d864 1
d870 1
d881 1
d887 1
d903 1
@


1.69
log
@It was possible for phase 1 negotiation to fail due to lifetime duration
mismatch without any log message stating so. This diff makes sure that
all phase 1 negotiation failures due to proposal attribute mismatch are
logged. Also change these messages from LOG_NEGOTIATION debug level 70 to
always be logged (not just with debug).

General idea OK hshoexer, tested here in production.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.68 2007/04/22 11:32:30 moritz Exp $	 */
d549 5
@


1.68
log
@Use conf_free_list() after calling conf_get_list().
Otherwise we leak memory.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.67 2007/04/16 13:01:39 moritz Exp $	 */
d1258 1
a1258 1
	int             rv;
d1261 2
a1262 2
		LOG_DBG((LOG_NEGOTIATION, 60, "attribute_unacceptable: "
		    "attribute type %d not known", type));
d1275 2
a1276 3
			LOG_DBG((LOG_NEGOTIATION, 70,
			    "attribute_unacceptable: attr %s does not exist "
			    "in %s", tag, xf->field));
d1297 2
a1298 3
		LOG_DBG((LOG_NEGOTIATION, 70,
		    "attribute_unacceptable: %s: got %s, expected %s", tag,
		    constant_name(map, decode_16(value)), str));
d1307 2
d1323 2
a1324 3
			LOG_DBG((LOG_NEGOTIATION, 70,
			    "attribute_unacceptable: received unexpected life "
			    "attribute"));
d1339 1
a1339 2
					LOG_DBG((LOG_NEGOTIATION, 70,
					    "attribute_unacceptable: "
d1341 1
a1341 1
					    life->field));
d1356 2
a1357 2
			LOG_DBG((LOG_NEGOTIATION, 70, "attribute_unacceptable:"
			    " unrecognized LIFE_TYPE %d", decode_16(value)));
d1363 2
a1364 3
				LOG_DBG((LOG_NEGOTIATION, 70,
				    "attribute_unacceptable: "
				    "LIFE_DURATION without LIFE_TYPE"));
d1373 9
a1381 4
					rv = !conf_match_num(vs->life,
					    "LIFE_DURATION",
					    len == 4 ? decode_32(value) :
					    decode_16(value));
d1383 3
a1385 3
				LOG_DBG((LOG_NEGOTIATION, 70,
				    "attribute_unacceptable: section [%s] has "
				    "no LIFE_DURATION", vs->life));
d1415 3
@


1.67
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.66 2006/07/02 13:19:00 hshoexer Exp $	 */
d1315 2
a1316 1
		    !strcmp(conf_get_str(xf->field, "Life"), "ANY"))
d1318 1
@


1.66
log
@Let isakmpd send out a vendor ID announcing isamkpds release version.
Will be handy for release specific bug fixes, etc.  Suggested by
markus@@ quite some time ago.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.65 2005/07/05 11:59:51 hshoexer Exp $	 */
d380 2
a381 4
	if (sa_buf)
		free(sa_buf);
	if (proposal)
		free(proposal);
d388 1
a388 2
	if (transform_len)
		free(transform_len);
d1223 1
a1223 2
		if (vs.life)
			free(vs.life);
d1234 1
a1234 2
		if (vs.life)
			free(vs.life);
@


1.65
log
@fix comment
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.64 2005/06/25 11:40:52 hshoexer Exp $	 */
d62 1
d65 1
a65 1
    void *);
d67 1
a67 1
    struct sa *);
d362 4
d524 4
@


1.64
log
@Use correct local ID in phase 1 when using IPV[46]_ADDR.
Diff from st.sch at gmx.net
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.63 2005/05/26 06:11:09 hshoexer Exp $	 */
d1343 1
a1343 1
				 * to save a pointer this section in vs->life.
@


1.63
log
@Use TAILQ_FOREACH where possible, remove payload_last()

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.62 2005/04/08 22:32:10 cloder Exp $	 */
d828 11
a838 1
			/* Already in network byteorder.  */
d841 1
@


1.62
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.61 2005/04/08 16:52:41 deraadt Exp $	 */
d354 1
a354 1
	for (i = 0, p = payload_first(msg, ISAKMP_PAYLOAD_TRANSFORM);
@


1.61
log
@always enable aggressive, dpd, and isakmp_cfg
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.60 2005/04/08 16:37:14 deraadt Exp $	 */
a38 2

#include "sysdep.h"
@


1.60
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.59 2005/04/04 19:31:11 deraadt Exp $	 */
a47 1
#ifdef USE_DPD
a48 1
#endif
a366 1
#if defined (USE_DPD)
a369 1
#endif
a526 1
#if defined (USE_DPD)
a529 1
#endif
@


1.59
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.58 2005/01/29 17:07:55 hshoexer Exp $	 */
a60 1
#if defined (USE_NAT_TRAVERSAL)
a61 1
#endif
a364 1
#if defined (USE_NAT_TRAVERSAL)
a367 1
#endif
a526 1
#if defined (USE_NAT_TRAVERSAL)
a529 1
#endif
a557 1
#if defined (USE_NAT_TRAVERSAL)
a563 1
#endif
a585 1
#if defined (USE_NAT_TRAVERSAL)
a589 1
#endif
@


1.58
log
@some knf and space killing, no binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.57 2004/12/14 10:17:28 mcbride Exp $	 */
d737 1
a737 1
		     len += prf->blocksize, p += prf->blocksize) {
d1202 1
a1202 1
					     node; node = next_node) {
@


1.57
log
@Allow the Address, Network, or Netmask values of the <IPsec-ID> to be
specified with an interface name (in which case the first address is used)
or the keyword 'default' (in which case the address is selected based on the
default route). eg:

[roadwarrior-ip]
ID-type=                IPV4_ADDR
Address=                default

ok ho@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.56 2004/08/08 19:11:06 deraadt Exp $	 */
d101 1
a101 1
		    "failed", (u_long)conf->cnt, (u_long) sizeof *transform);
d108 1
a108 1
		    (u_long) sizeof *transform_len);
d236 1
a236 1
			attr = (u_int8_t *) conf_get_str(xf->field,
d240 1
a240 1
				(char *) attr) : 0;
d272 1
a272 1
		    (unsigned long) proposal_len);
d284 1
a284 1
		    "calloc (1, %lu) failed", (unsigned long) sizeof *proto);
d293 1
a293 1
		pa = (struct proto_attr *) calloc(1, sizeof *pa);
d297 1
a297 1
		pa->attrs = (u_int8_t *) malloc(pa->len);
d312 1
a312 1
		    (unsigned long) sa_len);
d351 1
a351 1
		    (unsigned long) ie->sa_i_b_len);
d516 1
a516 1
		    (unsigned long) ie->sa_i_b_len);
d622 1
a622 1
		    "malloc (%lu) failed", (unsigned long) ie->g_x_len);
d650 1
a650 1
		    "malloc (%lu) failed", (unsigned long) ie->skeyid_len);
d661 1
a661 1
	prf->Update(prf->prfctx, (unsigned char *) "\0", 1);
d671 1
a671 1
		    "malloc (%lu) failed", (unsigned long) ie->skeyid_len);
d679 1
a679 1
	prf->Update(prf->prfctx, (unsigned char *) "\1", 1);
d690 1
a690 1
		    "malloc (%lu) failed", (unsigned long) ie->skeyid_len);
d698 1
a698 1
	prf->Update(prf->prfctx, (unsigned char *) "\2", 1);
d733 1
a733 1
		prf->Update(prf->prfctx, (unsigned char *) "\0", 1);
d826 1
a826 1
			  (unsigned long) sz);
d927 1
a927 1
		    (unsigned long) *id_len);
d999 1
a999 1
			    (unsigned long) sz);
d1078 1
a1078 1
		    (unsigned long) *id_len);
d1294 1
a1294 1
				    (unsigned long) sizeof *node);
d1406 1
a1406 1
				    (unsigned long) sizeof *node);
@


1.56
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.55 2004/07/29 08:54:08 ho Exp $	 */
d805 1
d835 10
d860 1
a860 1
			if (text2sockaddr(data, NULL, &src)) {
d875 1
a875 1
			if (text2sockaddr(data, NULL, &src)) {
d982 1
d1004 8
d1020 1
a1020 1
			if (text2sockaddr(p, 0, &sa) == -1) {
@


1.55
log
@Repair NAT-T using Aggressive mode, NAT-D checks were in the wrong place.
Noted by Yvan VANHULLEBUS.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.54 2004/07/05 17:33:35 pvalchev Exp $	 */
d571 1
a571 1
#endif			
d1183 1
a1183 1
						next_node = 
@


1.54
log
@%lu and cast to unsigned long to print a size_t; ok ho
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.53 2004/06/23 00:56:45 ho Exp $	 */
d595 3
a597 2
	/* Check NAT-D payloads and contents.  */
	if (msg->exchange->flags & EXCHANGE_FLAG_NAT_T_CAP_PEER)
@


1.53
log
@Support IPV{4,6}_ADDR_SUBNET IDs in Phase 1, just like the man page
says we do. Noted and tested by alex at vbone.net. Also avoid a
potential SEGV here. hshoexer@@ok
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.52 2004/06/20 17:17:35 ho Exp $	 */
d100 2
a101 2
		log_error("ike_phase_1_initiator_send_SA: calloc (%d, %lu) "
		    "failed", conf->cnt, (unsigned long) sizeof *transform);
d106 3
a108 3
		log_error("ike_phase_1_initiator_send_SA: calloc (%d, %lu) "
		    "failed", conf->cnt,
		    (unsigned long) sizeof *transform_len);
@


1.52
log
@Make the payload array in struct message dynamic, since we need to handle
payloads in the private range, such as the pre-RFC NAT-D/NAT-OA.
Replace TAILQ_FIRST(&msg->payload[i]) instances with function calls.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.51 2004/06/20 15:24:05 ho Exp $	 */
d802 1
a802 1
	char           *my_id = 0;
d839 35
d877 8
a884 2
			memcpy(buf + ISAKMP_ID_DATA_OFF, conf_get_str(my_id,
			    "Name"), sz - ISAKMP_ID_DATA_OFF);
@


1.51
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.50 2004/06/14 09:55:41 ho Exp $	 */
d355 1
a355 1
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SA])->p + ISAKMP_GEN_SZ,
d358 1
a358 2
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_PROPOSAL])->p,
	    proposal_len);
d360 1
a360 1
	for (i = 0, p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]);
d409 3
a411 5
	struct payload *sa_p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SA]);
	struct payload *prop =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_PROPOSAL]);
	struct payload *xf =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]);
d475 2
a476 3
	struct payload *sa_p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SA]);
	struct payload *prop = 
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_PROPOSAL]);
d930 1
a930 1
	payload = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_ID]);
@


1.50
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.49 2004/06/10 12:54:53 hshoexer Exp $	 */
d48 3
d61 3
d368 12
d532 15
a546 1
	return message_add_sa_payload(msg);
d568 8
d598 5
@


1.49
log
@Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!

ok ho@@ niklas@@, testing and spellcheck by todd@@ msf@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.48 2004/06/09 14:02:44 ho Exp $	 */
d981 2
a982 1
	LOG_DBG_BUF((LOG_NEGOTIATION, 40, header, payload->p + ISAKMP_ID_DATA_OFF,
@


1.48
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.47 2004/06/06 13:05:40 ho Exp $	 */
d1040 4
@


1.47
log
@Style (KNF, 80c). No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.46 2004/04/15 18:39:25 deraadt Exp $	 */
d386 1
a386 1
ike_phase_1_initiator_recv_SA(struct message * msg)
d430 1
a430 1
ike_phase_1_initiator_send_KE_NONCE(struct message * msg)
d442 1
a442 1
ike_phase_1_initiator_recv_KE_NONCE(struct message * msg)
d455 1
a455 1
ike_phase_1_responder_recv_SA(struct message * msg)
d511 1
a511 1
ike_phase_1_responder_send_SA(struct message * msg)
d519 1
a519 1
ike_phase_1_send_KE_NONCE(struct message * msg, size_t nonce_sz)
d541 1
a541 1
ike_phase_1_recv_KE_NONCE(struct message * msg)
d567 1
a567 1
ike_phase_1_post_exchange_KE_NONCE(struct message * msg)
d742 1
a742 1
ike_phase_1_responder_send_ID_AUTH(struct message * msg)
d751 1
a751 1
ike_phase_1_send_ID(struct message * msg)
d845 1
a845 1
ike_phase_1_send_AUTH(struct message * msg)
d868 1
a868 1
ike_phase_1_recv_ID_AUTH(struct message * msg)
d878 1
a878 1
ike_phase_1_recv_ID(struct message * msg)
d989 1
a989 1
ike_phase_1_recv_AUTH(struct message * msg)
@


1.46
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_phase_1.c,v 1.45 2004/04/07 22:45:49 ho Exp $	 */
d63 2
a64 1
static int      attribute_unacceptable(u_int16_t, u_int8_t *, u_int16_t, void *);
d66 1
a66 1
		    struct sa *);
d94 2
a95 2
		log_error("ike_phase_1_initiator_send_SA: calloc (%d, %lu) failed",
		    conf->cnt, (unsigned long) sizeof *transform);
d100 3
a102 2
		log_error("ike_phase_1_initiator_send_SA: calloc (%d, %lu) failed",
		    conf->cnt, (unsigned long) sizeof *transform_len);
d111 2
a112 2
			log_error("ike_phase_1_initiator_send_SA: malloc (%d) failed",
			    ISAKMP_TRANSFORM_SA_ATTRS_OFF +
d149 3
a151 2
			if (attribute_set_bignum(xf->field, "GROUP_GENERATOR_2",
			    IKE_ATTR_GROUP_GENERATOR_2, &attr))
d154 3
a156 2
			if (attribute_set_bignum(xf->field, "GROUP_GENERATOR_2",
			    IKE_ATTR_GROUP_GENERATOR_2, &attr))
d176 3
a178 2
				attribute_set_constant(life->field, "LIFE_TYPE",
				    ike_duration_cst, IKE_ATTR_LIFE_TYPE, &attr);
d184 2
a185 1
				value = conf_get_num(life->field, "LIFE_DURATION", 0);
d188 4
a191 2
						attr = attribute_set_basic(attr,
						    IKE_ATTR_LIFE_DURATION, value);
d208 2
a209 1
			attr = attribute_set_basic(attr, IKE_ATTR_KEY_LENGTH, value);
d213 2
a214 1
			attr = attribute_set_basic(attr, IKE_ATTR_FIELD_SIZE, value);
d218 2
a219 1
			attr = attribute_set_basic(attr, IKE_ATTR_GROUP_ORDER, value);
d227 2
a228 2
			 * Make sure that if a group description is specified, it is
			 * specified for all transforms equally.
d230 5
a234 3
			attr = (u_int8_t *) conf_get_str(xf->field, "GROUP_DESCRIPTION");
			new_group_desc = attr ? constant_value(ike_group_desc_cst,
			    (char *) attr) : 0;
d239 2
a240 1
				    "differing group descriptions in a proposal");
d277 2
a278 2
		log_error("ike_phase_1_initiator_send_SA: calloc (1, %lu) failed",
		    (unsigned long) sizeof *proto);
d299 2
a300 1
	TAILQ_INSERT_TAIL(&TAILQ_FIRST(&exchange->sa_list)->protos, proto, link);
d331 2
a332 2
		if (message_add_payload(msg, ISAKMP_PAYLOAD_TRANSFORM, transform[i],
		    transform_len[i], update_nextp))
d340 2
a341 1
	ie->sa_i_b_len = sa_len + proposal_len + transforms_len - ISAKMP_GEN_SZ;
d393 4
a396 2
	struct payload *prop = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_PROPOSAL]);
	struct payload *xf = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]);
d399 3
a401 2
	 * IKE requires that only one SA with only one proposal exists and since
	 * we are getting an answer on our transform offer, only one transform.
d461 2
a462 1
	struct payload *prop = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_PROPOSAL]);
d488 3
a490 2
	 * Check that the mandatory attributes: encryption, hash, authentication
	 * method and Diffie-Hellman group description, has been supplied.
d579 2
a580 2
		log_error("ike_phase_1_post_exchange_KE_NONCE: malloc (%lu) failed",
		    (unsigned long) ie->g_x_len);
d607 2
a608 2
		log_error("ike_phase_1_post_exchange_KE_NONCE: malloc (%lu) failed",
		    (unsigned long) ie->skeyid_len);
d628 2
a629 2
		log_error("ike_phase_1_post_exchange_KE_NONCE: malloc (%lu) failed",
		    (unsigned long) ie->skeyid_len);
d647 2
a648 2
		log_error("ike_phase_1_post_exchange_KE_NONCE: malloc (%lu) failed",
		    (unsigned long) ie->skeyid_len);
d672 2
a673 1
		prf = prf_alloc(ie->prf_type, hash->type, ie->skeyid_e, ie->skeyid_len);
d686 2
a687 2
			log_error("ike_phase_1_post_exchange_KE_NONCE: malloc (%d) failed",
			    keylen);
d709 2
a710 2
		exchange->keystate = crypto_init(exchange->crypto, ie->skeyid_e,
		    exchange->key_length, &err);
d726 2
a727 2
		 * XXX We really need to know if problems are of transient nature
		 * or fatal (like failed assertions etc.)
d794 2
a795 2
			memcpy(buf + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(src),
			    sockaddr_addrlen(src));
d801 2
a802 2
			memcpy(buf + ISAKMP_ID_DATA_OFF, conf_get_str(my_id, "Name"),
			    sz - ISAKMP_ID_DATA_OFF);
d806 2
a807 2
			log_print("ike_phase_1_send_ID: unsupported ID type %d",
			    id_type);
d855 2
a856 1
	 * XXX Many people say the COMMIT flag is just junk, especially in Phase 1.
d897 2
a898 2
			log_print("ike_phase_1_recv_ID: could not handle specified "
			    "Remote-ID [%s]", rs);
d912 2
a913 3
				log_print("ike_phase_1_recv_ID: "
				    "failed to get Address in Remote-ID section [%s]",
				    rs);
d918 2
a919 1
				log_print("ike_phase_1_recv_ID: failed to parse address %s", p);
d933 2
a934 1
			memcpy(rid, sockaddr_addrdata(sa), sockaddr_addrlen(sa));
d943 2
a944 2
				log_print("ike_phase_1_recv_ID: "
				    "failed to get Name in Remote-ID section [%s]", rs);
d952 2
a953 2
			log_print("ike_phase_1_recv_ID: unsupported ID type %d",
			    id_type);
d1008 2
a1009 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION, 0, 1, 0);
d1031 2
a1032 2
	snprintf(header, sizeof header, "ike_phase_1_recv_AUTH: computed HASH_%c",
	    initiator ? 'R' : 'I');
d1050 1
a1050 1
	                LIST_HEAD(attr_head, attr_node) attrs;
d1093 4
a1096 3
					for (node = LIST_FIRST(&vs.attrs); node;
					    node = next_node) {
						next_node = LIST_NEXT(node, link);
d1113 2
a1114 1
		LOG_DBG((LOG_NEGOTIATION, 20, "ike_phase_1_validate_prop: success"));
d1156 2
a1157 2
		LOG_DBG((LOG_NEGOTIATION, 60,
		    "attribute_unacceptable: attribute type %d not known", type));
d1171 2
a1172 2
			    "attribute_unacceptable: attr %s does not exist in %s",
			    tag, xf->field));
d1184 2
a1185 1
				log_error("attribute_unacceptable: malloc (%lu) failed",
d1209 2
a1210 1
		if (life_conf && !strcmp(conf_get_str(xf->field, "Life"), "ANY"))
d1216 3
a1218 2
			LOG_DBG((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
			    "received unexpected life attribute"));
d1222 4
a1225 3
		 * Each lifetime type must match, otherwise we turn the proposal down.
		 * In order to do this we need to find the specific section of our
		 * policy's "Life" list and match its duration
d1251 2
a1252 3
			LOG_DBG((LOG_NEGOTIATION, 70,
			    "attribute_unacceptable: unrecognized LIFE_TYPE %d",
			    decode_16(value)));
d1258 2
a1259 1
				LOG_DBG((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
d1269 2
a1270 1
					rv = !conf_match_num(vs->life, "LIFE_DURATION",
d1274 3
a1276 2
				LOG_DBG((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
				    "section [%s] has no LIFE_DURATION", vs->life));
d1296 2
a1297 1
				log_error("attribute_unacceptable: malloc (%lu) failed",
@


1.45
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.44 2004/02/27 10:16:26 ho Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.31 2000/12/11 23:47:56 niklas Exp $	*/
d63 3
a65 3
static int attribute_unacceptable (u_int16_t, u_int8_t *, u_int16_t, void *);
static int ike_phase_1_validate_prop (struct exchange *, struct sa *,
				      struct sa *);
d69 1
a69 1
ike_phase_1_initiator_send_SA (struct message *msg)
d71 70
a140 81
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t *proposal = 0, *sa_buf = 0, *saved_nextp, *attr;
  u_int8_t **transform = 0;
  size_t transforms_len = 0, proposal_len, sa_len;
  size_t *transform_len = 0;
  struct conf_list *conf, *life_conf;
  struct conf_list_node *xf, *life;
  int value, update_nextp;
  size_t i;
  struct payload *p;
  struct proto *proto;
  struct proto_attr *pa;
  int group_desc = -1, new_group_desc;

  /* Get the list of transforms.  */
  conf = conf_get_list (exchange->policy, "Transforms");
  if (!conf)
    return -1;

  transform = calloc (conf->cnt, sizeof *transform);
  if (!transform)
    {
      log_error ("ike_phase_1_initiator_send_SA: calloc (%d, %lu) failed",
		 conf->cnt, (unsigned long)sizeof *transform);
      goto bail_out;
    }

  transform_len = calloc (conf->cnt, sizeof *transform_len);
  if (!transform_len)
    {
      log_error ("ike_phase_1_initiator_send_SA: calloc (%d, %lu) failed",
		 conf->cnt, (unsigned long)sizeof *transform_len);
      goto bail_out;
    }

  for (xf = TAILQ_FIRST (&conf->fields), i = 0; i < conf->cnt;
       i++, xf = TAILQ_NEXT (xf, link))
    {
      /* XXX The sizing needs to be dynamic.  */
      transform[i]
	= malloc (ISAKMP_TRANSFORM_SA_ATTRS_OFF + 16 * ISAKMP_ATTR_VALUE_OFF);
      if (!transform[i])
	{
	  log_error ("ike_phase_1_initiator_send_SA: malloc (%d) failed",
		     ISAKMP_TRANSFORM_SA_ATTRS_OFF
		     + 16 * ISAKMP_ATTR_VALUE_OFF);
	  goto bail_out;
	}

      SET_ISAKMP_TRANSFORM_NO (transform[i], i);
      SET_ISAKMP_TRANSFORM_ID (transform[i], IPSEC_TRANSFORM_KEY_IKE);
      SET_ISAKMP_TRANSFORM_RESERVED (transform[i], 0);

      attr = transform[i] + ISAKMP_TRANSFORM_SA_ATTRS_OFF;

      if (attribute_set_constant (xf->field, "ENCRYPTION_ALGORITHM",
				  ike_encrypt_cst,
				  IKE_ATTR_ENCRYPTION_ALGORITHM, &attr))
	goto bail_out;

      if (attribute_set_constant (xf->field, "HASH_ALGORITHM", ike_hash_cst,
				  IKE_ATTR_HASH_ALGORITHM, &attr))
	goto bail_out;

      if (attribute_set_constant (xf->field, "AUTHENTICATION_METHOD",
				  ike_auth_cst, IKE_ATTR_AUTHENTICATION_METHOD,
				  &attr))
	goto bail_out;

      if (attribute_set_constant (xf->field, "GROUP_DESCRIPTION",
				  ike_group_desc_cst,
				  IKE_ATTR_GROUP_DESCRIPTION, &attr))
	{
	  /*
	   * If no group description exists, try looking for a user-defined
	   * one.
	   */
	  if (attribute_set_constant (xf->field, "GROUP_TYPE", ike_group_cst,
				      IKE_ATTR_GROUP_TYPE, &attr))
	    goto bail_out;
d143 19
a161 19
	  if (attribute_set_bignum (xf->field, "GROUP_PRIME",
				    IKE_ATTR_GROUP_PRIME, &attr))
	    goto bail_out;

	  if (attribute_set_bignum (xf->field, "GROUP_GENERATOR_2",
				    IKE_ATTR_GROUP_GENERATOR_2, &attr))
	    goto bail_out;

	  if (attribute_set_bignum (xf->field, "GROUP_GENERATOR_2",
				    IKE_ATTR_GROUP_GENERATOR_2, &attr))
	    goto bail_out;

	  if (attribute_set_bignum (xf->field, "GROUP_CURVE_A",
				    IKE_ATTR_GROUP_CURVE_A, &attr))
	    goto bail_out;

	  if (attribute_set_bignum (xf->field, "GROUP_CURVE_B",
				    IKE_ATTR_GROUP_CURVE_B, &attr))
	    goto bail_out;
d163 79
d244 122
a365 218
      /*
       * Life durations are special, we should be able to specify
       * several, one per type.
       */
      life_conf = conf_get_list (xf->field, "Life");
      if (life_conf)
	{
	  for (life = TAILQ_FIRST (&life_conf->fields); life;
	       life = TAILQ_NEXT (life, link))
	    {
	      attribute_set_constant (life->field, "LIFE_TYPE",
				      ike_duration_cst, IKE_ATTR_LIFE_TYPE,
				      &attr);

              /* XXX Deals with 16 and 32 bit lifetimes only */
	      value = conf_get_num (life->field, "LIFE_DURATION", 0);
              if (value)
                {
	          if (value <= 0xffff)
		    attr = attribute_set_basic (attr, IKE_ATTR_LIFE_DURATION,
						value);
                  else
                    {
                      value = htonl (value);
		      attr = attribute_set_var (attr, IKE_ATTR_LIFE_DURATION,
                                                (u_int8_t *)&value,
						sizeof value);
                    }
                }
	    }
	  conf_free_list (life_conf);
	}

      attribute_set_constant (xf->field, "PRF", ike_prf_cst, IKE_ATTR_PRF,
			      &attr);

      value = conf_get_num (xf->field, "KEY_LENGTH", 0);
      if (value)
	attr = attribute_set_basic (attr, IKE_ATTR_KEY_LENGTH, value);

      value = conf_get_num (xf->field, "FIELD_SIZE", 0);
      if (value)
	attr = attribute_set_basic (attr, IKE_ATTR_FIELD_SIZE, value);

      value = conf_get_num (xf->field, "GROUP_ORDER", 0);
      if (value)
	attr = attribute_set_basic (attr, IKE_ATTR_GROUP_ORDER, value);

      /* Record the real transform size.  */
      transforms_len += transform_len[i] = attr - transform[i];

      /* XXX I don't like exchange-specific stuff in here.  */
      if (exchange->type == ISAKMP_EXCH_AGGRESSIVE)
	{
	  /*
	   * Make sure that if a group description is specified, it is
	   * specified for all transforms equally.
	   */
	  attr = (u_int8_t *)conf_get_str (xf->field, "GROUP_DESCRIPTION");
	  new_group_desc
	    = attr ? constant_value (ike_group_desc_cst, (char *)attr) : 0;
	  if (group_desc == -1)
	    group_desc = new_group_desc;
	  else if (group_desc != new_group_desc)
	    {
	      log_print ("ike_phase_1_initiator_send_SA: "
			 "differing group descriptions in a proposal");
	      goto bail_out;
	    }
	}

      /* We need to check that we actually support our configuration.  */
      if (attribute_map (transform[i] + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			 transform_len[i] - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			 exchange->doi->is_attribute_incompatible, msg))
	{
	  log_print ("ike_phase_1_initiator_send_SA: "
		     "section [%s] has unsupported attribute(s)",
		     xf->field);
	  goto bail_out;
	}
    }

  /* XXX I don't like exchange-specific stuff in here.  */
  if (exchange->type == ISAKMP_EXCH_AGGRESSIVE)
    ie->group = group_get (group_desc);

  proposal_len = ISAKMP_PROP_SPI_OFF;
  proposal = malloc (proposal_len);
  if (!proposal)
    {
      log_error ("ike_phase_1_initiator_send_SA: malloc (%lu) failed",
		 (unsigned long)proposal_len);
      goto bail_out;
    }

  SET_ISAKMP_PROP_NO (proposal, 1);
  SET_ISAKMP_PROP_PROTO (proposal, ISAKMP_PROTO_ISAKMP);
  SET_ISAKMP_PROP_SPI_SZ (proposal, 0);
  SET_ISAKMP_PROP_NTRANSFORMS (proposal, conf->cnt);

  /* XXX I would like to see this factored out.  */
  proto = calloc (1, sizeof *proto);
  if (!proto)
    {
      log_error ("ike_phase_1_initiator_send_SA: calloc (1, %lu) failed",
		 (unsigned long)sizeof *proto);
      goto bail_out;
    }

  proto->no = 1;
  proto->proto = ISAKMP_PROTO_ISAKMP;
  proto->sa = TAILQ_FIRST (&exchange->sa_list);
  proto->xf_cnt = conf->cnt;
  TAILQ_INIT (&proto->xfs);
  for (i = 0; i < proto->xf_cnt; i++)
    {
      pa = (struct proto_attr *)calloc (1, sizeof *pa);
      if (!pa)
	goto bail_out;
      pa->len = transform_len[i];
      pa->attrs = (u_int8_t *)malloc (pa->len);
      if (!pa->attrs)
	{
	  free (pa);
	  goto bail_out;
	}
      memcpy (pa->attrs, transform[i], pa->len);
      TAILQ_INSERT_TAIL (&proto->xfs, pa, next);
    }
  TAILQ_INSERT_TAIL (&TAILQ_FIRST (&exchange->sa_list)->protos, proto, link);

  sa_len = ISAKMP_SA_SIT_OFF + IPSEC_SIT_SIT_LEN;
  sa_buf = malloc (sa_len);
  if (!sa_buf)
    {
      log_error ("ike_phase_1_initiator_send_SA: malloc (%lu) failed",
	(unsigned long)sa_len);
      goto bail_out;
    }

  SET_ISAKMP_SA_DOI (sa_buf, IPSEC_DOI_IPSEC);
  SET_IPSEC_SIT_SIT (sa_buf + ISAKMP_SA_SIT_OFF, IPSEC_SIT_IDENTITY_ONLY);

  /*
   * Add the payloads.  As this is a SA, we need to recompute the
   * lengths of the payloads containing others.
   */
  if (message_add_payload (msg, ISAKMP_PAYLOAD_SA, sa_buf, sa_len, 1))
    goto bail_out;
  SET_ISAKMP_GEN_LENGTH (sa_buf,
			 sa_len + proposal_len + transforms_len);
  sa_buf = 0;

  saved_nextp = msg->nextp;
  if (message_add_payload (msg, ISAKMP_PAYLOAD_PROPOSAL, proposal,
			   proposal_len, 0))
    goto bail_out;
  SET_ISAKMP_GEN_LENGTH (proposal, proposal_len + transforms_len);
  proposal = 0;

  update_nextp = 0;
  for (i = 0; i < conf->cnt; i++)
    {
      if (message_add_payload (msg, ISAKMP_PAYLOAD_TRANSFORM, transform[i],
			       transform_len[i], update_nextp))
	goto bail_out;
      update_nextp = 1;
      transform[i] = 0;
    }
  msg->nextp = saved_nextp;

  /* Save SA payload body in ie->sa_i_b, length ie->sa_i_b_len.  */
  ie->sa_i_b_len = sa_len + proposal_len + transforms_len - ISAKMP_GEN_SZ;
  ie->sa_i_b = malloc (ie->sa_i_b_len);
  if (!ie->sa_i_b)
    {
      log_error ("ike_phase_1_initiator_send_SA: malloc (%lu) failed",
		 (unsigned long)ie->sa_i_b_len);
      goto bail_out;
    }
  memcpy (ie->sa_i_b,
	  TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SA])->p + ISAKMP_GEN_SZ,
	  sa_len - ISAKMP_GEN_SZ);
  memcpy (ie->sa_i_b + sa_len - ISAKMP_GEN_SZ,
	  TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_PROPOSAL])->p,
	  proposal_len);
  transforms_len = 0;
  for (i = 0, p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]);
       i < conf->cnt; i++, p = TAILQ_NEXT (p, link))
    {
      memcpy (ie->sa_i_b + sa_len + proposal_len + transforms_len
	      - ISAKMP_GEN_SZ,
	      p->p, transform_len[i]);
      transforms_len += transform_len[i];
    }

  conf_free_list (conf);
  free (transform);
  free (transform_len);
  return 0;

 bail_out:
  if (sa_buf)
    free (sa_buf);
  if (proposal)
    free (proposal);
  if (transform)
    {
      for (i = 0; i < conf->cnt; i++)
	if (transform[i])
	  free (transform[i]);
      free (transform);
    }
  if (transform_len)
    free (transform_len);
  conf_free_list (conf);
  return -1;
d370 1
a370 1
ike_phase_1_initiator_recv_SA (struct message *msg)
d372 30
a401 32
  struct exchange *exchange = msg->exchange;
  struct sa *sa = TAILQ_FIRST (&exchange->sa_list);
  struct ipsec_exch *ie = exchange->data;
  struct ipsec_sa *isa = sa->data;
  struct payload *sa_p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SA]);
  struct payload *prop = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_PROPOSAL]);
  struct payload *xf = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]);

  /*
   * IKE requires that only one SA with only one proposal exists and since
   * we are getting an answer on our transform offer, only one transform.
   */
  if (TAILQ_NEXT (sa_p, link) || TAILQ_NEXT (prop, link)
      || TAILQ_NEXT (xf, link))
    {
      log_print ("ike_phase_1_initiator_recv_SA: "
		 "multiple SA, proposal or transform payloads in phase 1");
      /* XXX Is there a better notification type?  */
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      return -1;
    }

  /* Check that the chosen transform matches an offer.  */
  if (message_negotiate_sa (msg, ike_phase_1_validate_prop)
      || !TAILQ_FIRST (&sa->protos))
    return -1;

  ipsec_decode_transform (msg, sa, TAILQ_FIRST (&sa->protos), xf->p);

  /* XXX I don't like exchange-specific stuff in here.  */
  if (exchange->type != ISAKMP_EXCH_AGGRESSIVE)
    ie->group = group_get (isa->group_desc);
d403 2
a404 2
  /* Mark the SA as handled.  */
  sa_p->flags |= PL_MARK;
d406 1
a406 1
  return 0;
d411 1
a411 1
ike_phase_1_initiator_send_KE_NONCE (struct message *msg)
d413 1
a413 1
  struct ipsec_exch *ie = msg->exchange->data;
d415 1
a415 1
  ie->g_x_len = dh_getlen (ie->group);
d417 2
a418 2
  /* XXX I want a better way to specify the nonce's size.  */
  return ike_phase_1_send_KE_NONCE (msg, 16);
d423 1
a423 1
ike_phase_1_initiator_recv_KE_NONCE (struct message *msg)
d425 2
a426 2
  if (ike_phase_1_recv_KE_NONCE (msg))
    return -1;
d428 1
a428 1
  return ike_phase_1_post_exchange_KE_NONCE (msg);
d436 1
a436 1
ike_phase_1_responder_recv_SA (struct message *msg)
d438 48
a485 54
  struct exchange *exchange = msg->exchange;
  struct sa *sa = TAILQ_FIRST (&exchange->sa_list);
  struct ipsec_sa *isa = sa->data;
  struct payload *sa_p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SA]);
  struct payload *prop = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_PROPOSAL]);
  struct ipsec_exch *ie = exchange->data;

  /* Mark the SA as handled.  */
  sa_p->flags |= PL_MARK;

  /* IKE requires that only one SA with only one proposal exists.  */
  if (TAILQ_NEXT (sa_p, link) || TAILQ_NEXT (prop, link))
    {
      log_print ("ike_phase_1_responder_recv_SA: "
		 "multiple SA or proposal payloads in phase 1");
      /* XXX Is there a better notification type?  */
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      return -1;
    }

  /* Chose a transform from the SA.  */
  if (message_negotiate_sa (msg, ike_phase_1_validate_prop)
      || !TAILQ_FIRST (&sa->protos))
    return -1;

  /* XXX Move into message_negotiate_sa?  */
  ipsec_decode_transform (msg, sa, TAILQ_FIRST (&sa->protos),
			  TAILQ_FIRST (&sa->protos)->chosen->p);

  ie->group = group_get (isa->group_desc);

  /*
   * Check that the mandatory attributes: encryption, hash, authentication
   * method and Diffie-Hellman group description, has been supplied.
   */
  if (!exchange->crypto || !ie->hash || !ie->ike_auth || !ie->group)
    {
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      return -1;
    }

  /* Save the body for later hash computation.  */
  ie->sa_i_b_len = GET_ISAKMP_GEN_LENGTH (sa_p->p) - ISAKMP_GEN_SZ;
  ie->sa_i_b = malloc (ie->sa_i_b_len);
  if (!ie->sa_i_b)
    {
      /* XXX How to notify peer?  */
      log_error ("ike_phase_1_responder_recv_SA: malloc (%lu) failed",
		 (unsigned long)ie->sa_i_b_len);
      return -1;
    }
  memcpy (ie->sa_i_b, sa_p->p + ISAKMP_GEN_SZ, ie->sa_i_b_len);

  return 0;
d490 1
a490 1
ike_phase_1_responder_send_SA (struct message *msg)
d492 2
a493 2
  /* Add the SA payload with the transform that was chosen.  */
  return message_add_sa_payload (msg);
d498 1
a498 1
ike_phase_1_send_KE_NONCE (struct message *msg, size_t nonce_sz)
d500 16
a515 22
  /* Public DH key.  */
  if (ipsec_gen_g_x (msg))
    {
      /* XXX How to log and notify peer?  */
      return -1;
    }

  /* Generate a nonce, and add it to the message.  */
  if (exchange_gen_nonce (msg, nonce_sz))
    {
      /* XXX Log?  */
      return -1;
    }

  /* Try to add certificates which are acceptable for the CERTREQs */
  if (exchange_add_certs (msg))
    {
      /* XXX Log? */
      return -1;
    }

  return 0;
d520 1
a520 1
ike_phase_1_recv_KE_NONCE (struct message *msg)
d522 16
a537 22
  /* Copy out the initiator's DH public value.  */
  if (ipsec_save_g_x (msg))
    {
      /* XXX How to log and notify peer?  */
      return -1;
    }

  /* Copy out the initiator's nonce.  */
  if (exchange_save_nonce (msg))
    {
      /* XXX How to log and notify peer?  */
      return -1;
    }

  /* Copy out the initiator's cert requests.  */
  if (exchange_save_certreq (msg))
    {
      /* XXX How to log and notify peer?  */
      return -1;
    }

  return 0;
d546 1
a546 1
ike_phase_1_post_exchange_KE_NONCE (struct message *msg)
d548 154
a701 186
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct prf *prf;
  struct hash *hash = ie->hash;
  enum cryptoerr err;

  /* Compute Diffie-Hellman shared value.  */
  ie->g_xy = malloc (ie->g_x_len);
  if (!ie->g_xy)
    {
      /* XXX How to notify peer?  */
      log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%lu) failed",
		 (unsigned long)ie->g_x_len);
      return -1;
    }
  if (dh_create_shared (ie->group, ie->g_xy,
			exchange->initiator ? ie->g_xr : ie->g_xi))
    {
      log_print ("ike_phase_1_post_exchange_KE_NONCE: "
		 "dh_create_shared failed");
      return -1;
    }
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80,
		"ike_phase_1_post_exchange_KE_NONCE: g^xy", ie->g_xy,
		ie->g_x_len));

  /* Compute the SKEYID depending on the authentication method.  */
  ie->skeyid = ie->ike_auth->gen_skeyid (exchange, &ie->skeyid_len);
  if (!ie->skeyid)
    {
      /* XXX Log and teardown?  */
      return -1;
    }
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80,
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID", ie->skeyid,
		ie->skeyid_len));

  /* SKEYID_d.  */
  ie->skeyid_d = malloc (ie->skeyid_len);
  if (!ie->skeyid_d)
    {
      /* XXX How to notify peer?  */
      log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%lu) failed",
		 (unsigned long)ie->skeyid_len);
      return -1;
    }
  prf = prf_alloc (ie->prf_type, hash->type, ie->skeyid, ie->skeyid_len);
  if (!prf)
    {
      /* XXX Log and teardown?  */
      return -1;
    }
  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, ie->g_xy, ie->g_x_len);
  prf->Update (prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
  prf->Update (prf->prfctx, (unsigned char *)"\0", 1);
  prf->Final (ie->skeyid_d, prf->prfctx);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80,
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID_d",	ie->skeyid_d,
		ie->skeyid_len));

  /* SKEYID_a.  */
  ie->skeyid_a = malloc (ie->skeyid_len);
  if (!ie->skeyid_a)
    {
      log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%lu) failed",
		 (unsigned long)ie->skeyid_len);
      prf_free (prf);
      return -1;
    }
  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, ie->skeyid_d, ie->skeyid_len);
  prf->Update (prf->prfctx, ie->g_xy, ie->g_x_len);
  prf->Update (prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
  prf->Update (prf->prfctx, (unsigned char *)"\1", 1);
  prf->Final (ie->skeyid_a, prf->prfctx);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80,
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID_a",	ie->skeyid_a,
		ie->skeyid_len));

  /* SKEYID_e.  */
  ie->skeyid_e = malloc (ie->skeyid_len);
  if (!ie->skeyid_e)
    {
      /* XXX How to notify peer?  */
      log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%lu) failed",
		 (unsigned long)ie->skeyid_len);
      prf_free (prf);
      return -1;
    }
  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, ie->skeyid_a, ie->skeyid_len);
  prf->Update (prf->prfctx, ie->g_xy, ie->g_x_len);
  prf->Update (prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
  prf->Update (prf->prfctx, (unsigned char *)"\2", 1);
  prf->Final (ie->skeyid_e, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80,
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID_e",	ie->skeyid_e,
		ie->skeyid_len));

  /* Key length determination.  */
  if (!exchange->key_length)
    exchange->key_length = exchange->crypto->keymax;

  /* Derive a longer key from skeyid_e */
  if (ie->skeyid_len < exchange->key_length)
    {
      u_int16_t len, keylen;
      u_int8_t *key, *p;

      prf = prf_alloc (ie->prf_type, hash->type, ie->skeyid_e, ie->skeyid_len);
      if (!prf)
	{
	  /* XXX - notify peer */
	  return -1;
	}

      /* Make keylen a multiple of prf->blocksize */
      keylen = exchange->key_length;
      if (keylen % prf->blocksize)
	keylen += prf->blocksize - (keylen % prf->blocksize);

      key = malloc (keylen);
      if (!key)
	{
	  /* XXX - Notify peer.  */
	  log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%d) failed",
		     keylen);
	  return -1;
	}

      prf->Init (prf->prfctx);
      prf->Update (prf->prfctx, (unsigned char *)"\0", 1);
      prf->Final (key, prf->prfctx);

      for (len = prf->blocksize, p = key; len < exchange->key_length;
	   len += prf->blocksize, p += prf->blocksize)
	{
	  prf->Init (prf->prfctx);
	  prf->Update (prf->prfctx, p, prf->blocksize);
	  prf->Final (p + prf->blocksize, prf->prfctx);
	}
      prf_free (prf);

      /* Setup our keystate using the derived encryption key.  */
      exchange->keystate
	= crypto_init (exchange->crypto, key, exchange->key_length, &err);

      free (key);
    }
  else
    /* Setup our keystate using the raw skeyid_e.  */
    exchange->keystate = crypto_init (exchange->crypto, ie->skeyid_e,
				      exchange->key_length, &err);

  /* Special handling for DES weak keys.  */
  if (!exchange->keystate && err == EWEAKKEY
      && (exchange->key_length << 1) <= ie->skeyid_len)
    {
      log_print ("ike_phase_1_post_exchange_KE_NONCE: "
		 "weak key, trying subseq. skeyid_e");
      exchange->keystate
	= crypto_init (exchange->crypto, ie->skeyid_e + exchange->key_length,
		       exchange->key_length, &err);
    }

  if (!exchange->keystate)
    {
      log_print ("ike_phase_1_post_exchange_KE_NONCE: "
		 "exchange->crypto->init () failed: %d", err);

      /*
       * XXX We really need to know if problems are of transient nature
       * or fatal (like failed assertions etc.)
       */
      return -1;
    }

  /* Setup IV.  XXX Only for CBC transforms, no?  */
  hash->Init (hash->ctx);
  hash->Update (hash->ctx, ie->g_xi, ie->g_x_len);
  hash->Update (hash->ctx, ie->g_xr, ie->g_x_len);
  hash->Final (hash->digest, hash->ctx);
  crypto_init_iv (exchange->keystate, hash->digest,
		  exchange->crypto->blocksize);
d703 14
a716 1
  return 0;
d720 1
a720 1
ike_phase_1_responder_send_ID_AUTH (struct message *msg)
d722 2
a723 2
  if (ike_phase_1_send_ID (msg))
    return -1;
d725 1
a725 1
  return ike_phase_1_send_AUTH (msg);
d729 1
a729 1
ike_phase_1_send_ID (struct message *msg)
d731 89
a819 98
  struct exchange *exchange = msg->exchange;
  u_int8_t *buf;
  char header[80];
  ssize_t sz;
  struct sockaddr *src;
  int initiator = exchange->initiator;
  u_int8_t **id;
  size_t *id_len;
  char *my_id = 0;
  u_int8_t id_type;

  /* Choose the right fields to fill-in.  */
  id = initiator ? &exchange->id_i : &exchange->id_r;
  id_len = initiator ? &exchange->id_i_len : &exchange->id_r_len;

  if (exchange->name)
    my_id = conf_get_str (exchange->name, "ID");

  if (!my_id)
    my_id = conf_get_str ("General", "Default-phase-1-ID");

  msg->transport->vtbl->get_src (msg->transport, &src);
  sz = my_id ? ipsec_id_size (my_id, &id_type) : sockaddr_addrlen (src);
  if (sz == -1)
    return -1;

  sz += ISAKMP_ID_DATA_OFF;
  buf = malloc (sz);
  if (!buf)
    {
      log_error ("ike_phase_1_send_ID: malloc (%lu) failed",
		 (unsigned long)sz);
      return -1;
    }

  SET_IPSEC_ID_PROTO (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
  SET_IPSEC_ID_PORT (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
  if (my_id)
    {
      SET_ISAKMP_ID_TYPE (buf, id_type);
      switch (id_type)
	{
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
	  /* Already in network byteorder.  */
	  memcpy (buf + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (src),
		  sockaddr_addrlen (src));
	  break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	case IPSEC_ID_KEY_ID:
	  memcpy (buf + ISAKMP_ID_DATA_OFF, conf_get_str (my_id, "Name"),
		  sz - ISAKMP_ID_DATA_OFF);
	  break;

	default:
	  log_print ("ike_phase_1_send_ID: unsupported ID type %d", id_type);
	  free (buf);
	  return -1;
	}
    }
  else
    {
      switch (src->sa_family)
	{
	case AF_INET:
	  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV4_ADDR);
	  break;
	case AF_INET6:
	  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV6_ADDR);
	  break;
	}
      /* Already in network byteorder.  */
      memcpy (buf + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (src),
	      sockaddr_addrlen (src));
    }

  if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, buf, sz, 1))
    {
      free (buf);
      return -1;
    }
  *id_len = sz - ISAKMP_GEN_SZ;
  *id = malloc (*id_len);
  if (!*id)
    {
      log_error ("ike_phase_1_send_ID: malloc (%lu) failed",
		 (unsigned long)*id_len);
      return -1;
    }
  memcpy (*id, buf + ISAKMP_GEN_SZ, *id_len);
  snprintf (header, sizeof header, "ike_phase_1_send_ID: %s",
	    constant_name (ipsec_id_cst, GET_ISAKMP_ID_TYPE (buf)));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 40, header, buf + ISAKMP_ID_DATA_OFF,
		sz - ISAKMP_ID_DATA_OFF));

  return 0;
d823 1
a823 1
ike_phase_1_send_AUTH (struct message *msg)
d825 2
a826 2
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
d828 7
a834 9
  if (ie->ike_auth->encode_hash (msg))
    {
      /* XXX Log? */
      return -1;
    }

  /*
   * XXX Many people say the COMMIT flag is just junk, especially in Phase 1.
   */
d836 2
a837 2
  if ((exchange->flags & EXCHANGE_FLAG_COMMITTED) == 0)
    exchange->flags |= EXCHANGE_FLAG_I_COMMITTED;
d840 1
a840 1
  return 0;
d845 1
a845 1
ike_phase_1_recv_ID_AUTH (struct message *msg)
d847 2
a848 2
  if (ike_phase_1_recv_ID (msg))
    return -1;
d850 1
a850 1
  return ike_phase_1_recv_AUTH (msg);
d855 1
a855 1
ike_phase_1_recv_ID (struct message *msg)
d857 76
a932 118
  struct exchange *exchange = msg->exchange;
  struct payload *payload;
  char header[80], *rs = 0, *rid = 0, *p;
  int initiator = exchange->initiator;
  u_int8_t **id, id_type;
  size_t *id_len;
  ssize_t sz;
  struct sockaddr *sa;

  payload = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_ID]);

  if (exchange->name)
    rs = conf_get_str (exchange->name, "Remote-ID");

  if (rs)
    {
      sz = ipsec_id_size (rs, &id_type);
      if (sz == -1)
	{
	  log_print ("ike_phase_1_recv_ID: could not handle specified "
		     "Remote-ID [%s]", rs);
	  return -1;
	}

      rid = malloc (sz);
      if (!rid)
	{
	  log_error ("ike_phase_1_recv_ID: malloc (%lu) failed",
		     (unsigned long)sz);
	  return -1;
	}

      switch (id_type)
	{
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
	  p = conf_get_str (rs, "Address");
	  if (!p)
	    {
	      log_print ("ike_phase_1_recv_ID: "
			 "failed to get Address in Remote-ID section [%s]",
			 rs);
	      free (rid);
	      return -1;
	    }

	  if (text2sockaddr (p, 0, &sa) == -1)
	    {
	      log_print ("ike_phase_1_recv_ID: failed to parse address %s", p);
	      free (rid);
	      return -1;
	    }

	  if ((id_type == IPSEC_ID_IPV4_ADDR && sa->sa_family != AF_INET)
	      || (id_type == IPSEC_ID_IPV6_ADDR && sa->sa_family != AF_INET6))
	    {
	      log_print ("ike_phase_1_recv_ID: "
			 "address %s not of expected family", p);
	      free (rid);
	      free (sa);
	      return -1;
	    }

	  memcpy (rid, sockaddr_addrdata (sa), sockaddr_addrlen (sa));
	  free (sa);
	  break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	case IPSEC_ID_KEY_ID:
	  p = conf_get_str (rs, "Name");
	  if (!p)
	    {
	      log_print ("ike_phase_1_recv_ID: "
			 "failed to get Name in Remote-ID section [%s]", rs);
	      free (rid);
	      return -1;
	    }

	  memcpy (rid, p, sz);
	  break;

	default:
	  log_print ("ike_phase_1_recv_ID: unsupported ID type %d", id_type);
	  free (rid);
	  return -1;
	}

      /* Compare expected/desired and received remote ID */
      if (bcmp (rid, payload->p + ISAKMP_ID_DATA_OFF, sz))
	{
	  free (rid);
	  log_print ("ike_phase_1_recv_ID: "
		     "received remote ID other than expected %s", p);
	  return -1;
	}

      free (rid);
    }

  /* Choose the right fields to fill in */
  id = initiator ? &exchange->id_r : &exchange->id_i;
  id_len = initiator ? &exchange->id_r_len : &exchange->id_i_len;

  *id_len = GET_ISAKMP_GEN_LENGTH (payload->p) - ISAKMP_GEN_SZ;
  *id = malloc (*id_len);
  if (!*id)
    {
      log_error ("ike_phase_1_recv_ID: malloc (%lu) failed",
		 (unsigned long)*id_len);
      return -1;
    }
  memcpy (*id, payload->p + ISAKMP_GEN_SZ, *id_len);
  snprintf (header, sizeof header, "ike_phase_1_recv_ID: %s",
	    constant_name (ipsec_id_cst, GET_ISAKMP_ID_TYPE (payload->p)));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 40, header, payload->p + ISAKMP_ID_DATA_OFF,
		*id_len + ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF));
  payload->flags |= PL_MARK;
d934 27
a960 1
  return 0;
d965 1
a965 1
ike_phase_1_recv_AUTH (struct message *msg)
d967 40
a1006 45
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct prf *prf;
  struct hash *hash = ie->hash;
  char header[80];
  size_t hashsize = hash->hashsize;
  int initiator = exchange->initiator;
  u_int8_t **hash_p, *id;
  size_t id_len;

  /* Choose the right fields to fill in */
  hash_p = initiator ? &ie->hash_r : &ie->hash_i;
  id = initiator ? exchange->id_r : exchange->id_i;
  id_len = initiator ? exchange->id_r_len : exchange->id_i_len;

  /* The decoded hash will be in ie->hash_r or ie->hash_i */
  if (ie->ike_auth->decode_hash (msg))
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION, 0, 1, 0);
      return -1;
    }

  /* Allocate the prf and start calculating his HASH.  */
  prf = prf_alloc (ie->prf_type, hash->type, ie->skeyid, ie->skeyid_len);
  if (!prf)
    {
      /* XXX Log?  */
      return -1;
    }
  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, initiator ? ie->g_xr : ie->g_xi, ie->g_x_len);
  prf->Update (prf->prfctx, initiator ? ie->g_xi : ie->g_xr, ie->g_x_len);
  prf->Update (prf->prfctx,
	       exchange->cookies
	       + (initiator ? ISAKMP_HDR_RCOOKIE_OFF : ISAKMP_HDR_ICOOKIE_OFF),
	       ISAKMP_HDR_ICOOKIE_LEN);
  prf->Update (prf->prfctx,
	       exchange->cookies
	       + (initiator ? ISAKMP_HDR_ICOOKIE_OFF : ISAKMP_HDR_RCOOKIE_OFF),
	       ISAKMP_HDR_ICOOKIE_LEN);
  prf->Update (prf->prfctx, ie->sa_i_b, ie->sa_i_b_len);
  prf->Update (prf->prfctx, id, id_len);
  prf->Final (hash->digest, prf->prfctx);
  prf_free (prf);
  snprintf (header, sizeof header, "ike_phase_1_recv_AUTH: computed HASH_%c",
d1008 1
a1008 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, header, hash->digest, hashsize));
d1010 6
a1015 8
  /* Check that the hash we got matches the one we computed.  */
  if (memcmp (*hash_p, hash->digest, hashsize) != 0)
    {
      /* XXX Log?  */
      return -1;
    }

  return 0;
d1019 2
a1020 2
  LIST_ENTRY (attr_node) link;
  u_int16_t type;
d1024 3
a1026 3
  struct conf_list_node *xf;
  LIST_HEAD (attr_head, attr_node) attrs;
  char *life;
d1031 2
a1032 2
ike_phase_1_validate_prop (struct exchange *exchange, struct sa *sa,
			   struct sa *isakmp_sa)
d1034 74
a1107 79
  struct conf_list *conf, *tags;
  struct conf_list_node *xf, *tag;
  struct proto *proto;
  struct validation_state vs;
  struct attr_node *node, *next_node;

  /* Get the list of transforms.  */
  conf = conf_get_list (exchange->policy, "Transforms");
  if (!conf)
    return 0;

  for (xf = TAILQ_FIRST (&conf->fields); xf; xf = TAILQ_NEXT (xf, link))
    {
      for (proto = TAILQ_FIRST (&sa->protos); proto;
	   proto = TAILQ_NEXT (proto, link))
	{
	  /* Mark all attributes in our policy as unseen.  */
	  LIST_INIT (&vs.attrs);
	  vs.xf = xf;
	  vs.life = 0;
	  if (attribute_map (proto->chosen->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			     GET_ISAKMP_GEN_LENGTH (proto->chosen->p)
			     - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			     attribute_unacceptable, &vs))
	    goto try_next;

	  /* Sweep over unseen tags in this section.  */
	  tags = conf_get_tag_list (xf->field);
	  if (tags)
	    {
	      for (tag = TAILQ_FIRST (&tags->fields); tag;
		   tag = TAILQ_NEXT (tag, link))
		/*
		 * XXX Should we care about attributes we have, they do not
		 * provide?
		 */
		for (node = LIST_FIRST (&vs.attrs); node;
		     node = next_node)
		  {
		    next_node = LIST_NEXT (node, link);
		    if (node->type
			== constant_value (ike_attr_cst, tag->field))
		      {
			LIST_REMOVE (node, link);
			free (node);
		      }
		  }
	      conf_free_list (tags);
	    }

	  /* Are there leftover tags in this section?  */
	  node = LIST_FIRST (&vs.attrs);
	  if (node)
	    goto try_next;
	}

      /* All protocols were OK, we succeeded.  */
      LOG_DBG ((LOG_NEGOTIATION, 20, "ike_phase_1_validate_prop: success"));
      conf_free_list (conf);
      if (vs.life)
	free (vs.life);
      return 1;

    try_next:
      /* Are there leftover tags in this section?  */
      node = LIST_FIRST (&vs.attrs);
      while (node)
	{
	  LIST_REMOVE (node, link);
	  free (node);
	  node = LIST_FIRST (&vs.attrs);
	}
      if (vs.life)
	free (vs.life);
    }

  LOG_DBG ((LOG_NEGOTIATION, 20, "ike_phase_1_validate_prop: failure"));
  conf_free_list (conf);
  return 0;
d1116 2
a1117 2
attribute_unacceptable (u_int16_t type, u_int8_t *value, u_int16_t len,
			void *vvs)
d1119 58
a1176 33
  struct validation_state *vs = vvs;
  struct conf_list *life_conf;
  struct conf_list_node *xf = vs->xf, *life;
  char *tag = constant_lookup (ike_attr_cst, type);
  char *str;
  struct constant_map *map;
  struct attr_node *node;
  int rv;

  if (!tag)
    {
      LOG_DBG ((LOG_NEGOTIATION, 60,
		"attribute_unacceptable: attribute type %d not known", type));
      return 1;
    }

  switch (type)
    {
    case IKE_ATTR_ENCRYPTION_ALGORITHM:
    case IKE_ATTR_HASH_ALGORITHM:
    case IKE_ATTR_AUTHENTICATION_METHOD:
    case IKE_ATTR_GROUP_DESCRIPTION:
    case IKE_ATTR_GROUP_TYPE:
    case IKE_ATTR_PRF:
      str = conf_get_str (xf->field, tag);
      if (!str)
	{
	  /* This attribute does not exist in this policy.  */
	  LOG_DBG ((LOG_NEGOTIATION, 70,
		    "attribute_unacceptable: attr %s does not exist in %s",
		    tag, xf->field));
	  return 1;
	}
a1177 54
      map = constant_link_lookup (ike_attr_cst, type);
      if (!map)
	return 1;

      if ((constant_value (map, str) == decode_16 (value)) ||
	  (!strcmp (str, "ANY")))
	{
	  /* Mark this attribute as seen.  */
	  node = malloc (sizeof *node);
	  if (!node)
	    {
	      log_error ("attribute_unacceptable: malloc (%lu) failed",
			 (unsigned long)sizeof *node);
	      return 1;
	    }
	  node->type = type;
	  LIST_INSERT_HEAD (&vs->attrs, node, link);
	  return 0;
	}
      LOG_DBG ((LOG_NEGOTIATION, 70,
		"attribute_unacceptable: %s: got %s, expected %s", tag,
		constant_name (map, decode_16 (value)), str));
      return 1;

    case IKE_ATTR_GROUP_PRIME:
    case IKE_ATTR_GROUP_GENERATOR_1:
    case IKE_ATTR_GROUP_GENERATOR_2:
    case IKE_ATTR_GROUP_CURVE_A:
    case IKE_ATTR_GROUP_CURVE_B:
      /* XXX Bignums not handled yet.  */
      return 1;

    case IKE_ATTR_LIFE_TYPE:
    case IKE_ATTR_LIFE_DURATION:
      life_conf = conf_get_list (xf->field, "Life");
      if (life_conf && !strcmp (conf_get_str (xf->field, "Life"), "ANY"))
	return 0;

      rv = 1;
      if (!life_conf)
	{
	  /* Life attributes given, but not in our policy.  */
	  LOG_DBG ((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
		    "received unexpected life attribute"));
	  return 1;
	}

      /*
       * Each lifetime type must match, otherwise we turn the proposal down.
       * In order to do this we need to find the specific section of our
       * policy's "Life" list and match its duration
       */
      switch (type)
	{
d1179 72
a1250 27
	  for (life = TAILQ_FIRST (&life_conf->fields); life;
	       life = TAILQ_NEXT (life, link))
	    {
	      str = conf_get_str (life->field, "LIFE_TYPE");
	      if (!str)
		{
		  LOG_DBG ((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
			    "section [%s] has no LIFE_TYPE", life->field));
		  continue;
		}

	      /*
	       * If this is the type we are looking at, save a pointer
	       * to this section in vs->life.
	       */
	      if (constant_value (ike_duration_cst, str) == decode_16 (value))
		{
		  vs->life = strdup (life->field);
		  rv = 0;
		  goto bail_out;
		}
	    }
	  LOG_DBG ((LOG_NEGOTIATION, 70,
		    "attribute_unacceptable: unrecognized LIFE_TYPE %d",
		    decode_16 (value)));
	  vs->life = 0;
	  break;
d1252 22
a1273 55
	case IKE_ATTR_LIFE_DURATION:
	  if (!vs->life)
	    {
	      LOG_DBG ((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
			"LIFE_DURATION without LIFE_TYPE"));
	      rv = 1;
	      goto bail_out;
	    }

	  str = conf_get_str (vs->life, "LIFE_DURATION");
	  if (str)
	    {
	      if (!strcmp (str, "ANY"))
		rv = 0;
	      else
		rv = !conf_match_num (vs->life, "LIFE_DURATION",
				      len == 4 ? decode_32 (value) :
				      decode_16 (value));
	    }
	  else
	    {
	      LOG_DBG ((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
			"section [%s] has no LIFE_DURATION", vs->life));
	      rv = 1;
	    }

	  free (vs->life);
	  vs->life = 0;
	  break;
	}

    bail_out:
      conf_free_list (life_conf);
      return rv;

    case IKE_ATTR_KEY_LENGTH:
    case IKE_ATTR_FIELD_SIZE:
    case IKE_ATTR_GROUP_ORDER:
      if (conf_match_num (xf->field, tag, decode_16 (value)))
	{
	  /* Mark this attribute as seen.  */
	  node = malloc (sizeof *node);
	  if (!node)
	    {
	      log_error ("attribute_unacceptable: malloc (%lu) failed",
			 (unsigned long)sizeof *node);
	      return 1;
	    }
	  node->type = type;
	  LIST_INSERT_HEAD (&vs->attrs, node, link);
	  return 0;
	}
      return 1;
    }
  return 1;
@


1.44
log
@(C)-2004
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.43 2004/02/27 09:01:18 ho Exp $	*/
d79 2
a80 1
  int i, value, update_nextp;
d940 2
a941 1
  size_t *id_len, sz;
@


1.44.2.1
log
@MFC:
Fix by hshoexer@@

Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.44 2004/02/27 10:16:26 ho Exp $	*/
a1112 3

  /* Mark message as authenticated. */
  msg->flags |= MSG_AUTHENTICATED;
@


1.43
log
@Follow RFC 2408 more closely regarding how to better check the proposal
returned by the other peer (the responder). Some implementations (notably
the Cisco PIX) does not follow a SHOULD in section 4.2 of the RFC. With
certain proposal combinations this caused us to setup the wrong SA
resulting in us being unable to process incoming IPsec traffic (over this
tunnel).

Tested against a number of different IKE implementations.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.42 2003/12/04 21:13:35 miod Exp $	*/
d7 1
a7 1
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
@


1.42
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.41 2003/10/14 14:29:15 ho Exp $	*/
d82 1
d288 18
a305 2
  TAILQ_INSERT_TAIL (&TAILQ_FIRST (&exchange->sa_list)->protos, proto,
		     link);
@


1.41
log
@constant_lookup() to constant_name() cleanup. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.40 2003/10/04 17:29:58 cloder Exp $	*/
d239 1
a239 1
	      log_print ("ike_phase_1_inititor_send_SA: "
@


1.40
log
@Avoid crash on invalid config file (missing value for LIFE_DURATION).
OK ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.39 2003/08/08 08:46:59 ho Exp $	*/
d1210 1
a1210 1
  char *tag2, *str;
a1258 1
      tag2 = constant_lookup (map, decode_16 (value));
d1261 1
a1261 1
		tag2 ? tag2 : "<unknown>", str));
@


1.39
log
@Be more careful when using constant_lookup() in messages. Pointed out by
Jean-Francois Dive, although I opted for a slightly different patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.38 2003/06/10 16:41:29 deraadt Exp $	*/
d1333 10
a1342 2
	  if (!strcmp (conf_get_str (vs->life, "LIFE_DURATION"), "ANY"))
	    rv = 0;
d1344 6
a1349 3
	    rv = !conf_match_num (vs->life, "LIFE_DURATION",
				  len == 4 ? decode_32 (value) :
				  decode_16 (value));
@


1.39.2.1
log
@MFC:
Fix by hshoexer@@

Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.39 2003/08/08 08:46:59 ho Exp $	*/
a1095 3

  /* Mark message as authenticated. */
  msg->flags |= MSG_AUTHENTICATED;
@


1.38
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.37 2003/06/04 07:31:16 ho Exp $	*/
d1210 1
a1210 1
  char *str;
d1259 1
d1262 1
a1262 1
		constant_lookup (map, decode_16 (value)), str));
@


1.37
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.36 2003/06/03 12:51:39 ho Exp $	*/
d824 2
a825 2
      	  /* Already in network byteorder.  */
      	  memcpy (buf + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (src),
@


1.36
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.35 2002/09/11 09:50:43 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.35
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.34 2002/07/04 17:00:35 ho Exp $	*/
d877 1
a877 1
  snprintf (header, 80, "ike_phase_1_send_ID: %s",
d1034 1
a1034 1
  snprintf (header, 80, "ike_phase_1_recv_ID: %s",
d1091 1
a1091 1
  snprintf (header, 80, "ike_phase_1_recv_AUTH: computed HASH_%c",
@


1.34
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.33 2002/06/06 02:15:27 ho Exp $	*/
d204 2
a205 1
                                                (char *)&value, sizeof value);
d237 1
a237 1
	  attr = conf_get_str (xf->field, "GROUP_DESCRIPTION");
d239 1
a239 1
	    = attr ? constant_value (ike_group_desc_cst, attr) : 0;
d638 1
a638 1
  prf->Update (prf->prfctx, "\0", 1);
d657 1
a657 1
  prf->Update (prf->prfctx, "\1", 1);
d677 1
a677 1
  prf->Update (prf->prfctx, "\2", 1);
d716 1
a716 1
      prf->Update (prf->prfctx, "\0", 1);
@


1.33
log
@Style, and a few additional format/type mods.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.32 2002/06/01 07:44:21 deraadt Exp $	*/
d814 2
a815 1
      log_error ("ike_phase_1_send_ID: malloc (%lu) failed", (unsigned long)sz);
d871 2
a872 1
      log_error ("ike_phase_1_send_ID: malloc (%lu) failed", (unsigned long)*id_len);
d947 2
a948 1
	  log_error ("ike_phase_1_recv_ID: malloc (%lu) failed", (unsigned long)sz);
d1009 1
a1009 1
      if (bcmp(rid, payload->p + ISAKMP_ID_DATA_OFF, sz))
@


1.32
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.31 2001/10/26 12:03:07 ho Exp $	*/
d1025 2
a1026 1
      log_error ("ike_phase_1_recv_ID: malloc (%lu) failed", *id_len);
d1253 1
a1253 1
			 sizeof *node);
d1358 1
a1358 1
			 sizeof *node);
@


1.31
log
@Just rename sockaddr_data/len functions to sockaddr_addrdata/addrlen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.30 2001/07/01 20:11:53 niklas Exp $	*/
d97 2
a98 2
      log_error ("ike_phase_1_initiator_send_SA: calloc (%d, %d) failed",
		 conf->cnt, sizeof *transform);
d105 2
a106 2
      log_error ("ike_phase_1_initiator_send_SA: calloc (%d, %d) failed",
		 conf->cnt, sizeof *transform_len);
d269 2
a270 2
      log_error ("ike_phase_1_initiator_send_SA: malloc (%d) failed",
		 proposal_len);
d283 2
a284 2
      log_error ("ike_phase_1_initiator_send_SA: calloc (1, %d) failed",
		 sizeof *proto);
d298 2
a299 1
      log_error ("ike_phase_1_initiator_send_SA: malloc (%d) failed", sa_len);
d339 2
a340 2
      log_error ("ike_phase_1_initiator_send_SA: malloc (%d) failed",
		 ie->sa_i_b_len);
d501 2
a502 2
      log_error ("ike_phase_1_responder_recv_SA: malloc (%d) failed",
		 ie->sa_i_b_len);
d593 2
a594 2
      log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%d) failed",
		 ie->g_x_len);
d624 2
a625 2
      log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%d) failed",
		 ie->skeyid_len);
d647 2
a648 2
      log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%d) failed",
		 ie->skeyid_len);
d667 2
a668 2
      log_error ("ike_phase_1_post_exchange_KE_NONCE: malloc (%d) failed",
		 ie->skeyid_len);
d814 1
a814 1
      log_error ("ike_phase_1_send_ID: malloc (%d) failed", sz);
d870 1
a870 1
      log_error ("ike_phase_1_send_ID: malloc (%d) failed", *id_len);
d945 1
a945 1
	  log_error ("ike_phase_1_recv_ID: malloc (%d) failed", sz);
d1025 1
a1025 1
      log_error ("ike_phase_1_recv_ID: malloc (%d) failed", *id_len);
d1251 1
a1251 1
	      log_error ("attribute_unacceptable: malloc (%d) failed",
d1356 1
a1356 1
	      log_error ("attribute_unacceptable: malloc (%d) failed",
@


1.30
log
@More Style police, but also sane checking of address
family vs stated ID-type.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.29 2001/07/01 18:46:33 angelos Exp $	*/
d805 1
a805 1
  sz = my_id ? ipsec_id_size (my_id, &id_type) : sockaddr_len (src);
d827 2
a828 2
      	  memcpy (buf + ISAKMP_ID_DATA_OFF, sockaddr_data (src),
		  sockaddr_len (src));
d856 2
a857 2
      memcpy (buf + ISAKMP_ID_DATA_OFF, sockaddr_data (src),
	      sockaddr_len (src));
d979 1
a979 1
	  memcpy (rid, sockaddr_data (sa), sockaddr_len (sa));
@


1.29
log
@Set size correctly for IPv6 Phase 1 IDs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.28 2001/06/29 18:52:16 ho Exp $	*/
d603 2
a604 2
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
		"ike_phase_1_post_exchange_KE_NONCE: g^xy", ie->g_xy, 
d614 1
a614 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
d638 1
a638 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
d657 1
a657 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
d678 2
a679 2
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID_e",	ie->skeyid_e, 
a825 2
      	  msg->transport->vtbl->get_src (msg->transport, &src);

d827 1
a827 1
      	  memcpy (buf + ISAKMP_ID_DATA_OFF, sockaddr_data (src), 
d830 1
d837 1
a845 1
      msg->transport->vtbl->get_src (msg->transport, &src);
d856 1
a856 1
      memcpy (buf + ISAKMP_ID_DATA_OFF, sockaddr_data (src), 
d924 1
d951 1
d955 3
a957 2
	      log_print ("ike_phase_1_recv_ID: failed to get Address in "
			 "Remote-ID section [%s]", rs);
d962 9
a970 5
	  inet_pton (AF_INET, p, rid);
	  break;
	case IPSEC_ID_IPV6_ADDR:
	  p = conf_get_str (rs, "Address");
	  if (!p)
d972 2
a973 2
	      log_print ("ike_phase_1_recv_ID: failed to get Address in "
			 "Remote-ID section [%s]", rs);
d975 1
d979 2
a980 1
	  inet_pton (AF_INET6, p, rid);
d982 1
d987 8
d997 1
d1008 2
a1009 2
	  log_print ("ike_phase_1_recv_ID: received remote ID other than "
		     "expected %s", p);
d1216 1
a1216 1
      LOG_DBG ((LOG_NEGOTIATION, 60, 
d1258 2
a1259 2
      LOG_DBG ((LOG_NEGOTIATION, 70, 
		"attribute_unacceptable: %s: got %s, expected %s", tag, 
d1316 1
a1316 1
	  LOG_DBG ((LOG_NEGOTIATION, 70, 
@


1.28
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.27 2001/06/29 04:12:00 ho Exp $	*/
d804 2
a805 1
  sz = my_id ? ipsec_id_size (my_id, &id_type) : sizeof (in_addr_t);
@


1.27
log
@Initial IPv6 support. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.26 2001/06/05 10:50:55 angelos Exp $	*/
a787 1
  int src_len;
d825 1
a825 1
      	  msg->transport->vtbl->get_src (msg->transport, &src, &src_len);
d845 1
a845 1
      msg->transport->vtbl->get_src (msg->transport, &src, &src_len);
@


1.26
log
@Print the correct expected Remote ID value
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.25 2001/06/05 10:09:01 angelos Exp $	*/
d7 1
d825 1
d829 2
a830 3
      	  memcpy (buf + ISAKMP_ID_DATA_OFF,
	      	  &((struct sockaddr_in *)src)->sin_addr.s_addr,
	      	  sizeof (in_addr_t));
d847 9
a855 2
      /* XXX Assumes IPv4.  */
      SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV4_ADDR);
d857 2
a858 3
      memcpy (buf + ISAKMP_ID_DATA_OFF,
	      &((struct sockaddr_in *)src)->sin_addr.s_addr,
	      sizeof (in_addr_t));
a959 1
	  /* XXX IPv4 specific */
d961 12
@


1.25
log
@Don't use log_error() in vain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.24 2001/06/05 08:01:07 angelos Exp $	*/
d973 1
a973 1
		     "expected %s", rs);
@


1.24
log
@Enforce Remote-ID specified in Phase 1 peer section (whether manually
or dynamically specified).
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.23 2001/03/13 14:05:18 ho Exp $	*/
d929 1
a929 1
	  log_error ("ike_phase_1_recv_ID: could not handle specified "
d947 1
a947 1
	      log_error ("ike_phase_1_recv_ID: failed to get Address in "
d972 1
a972 1
	  log_error ("ike_phase_1_recv_ID: received remote ID other than "
@


1.23
log
@Add logging classes for Negotiation and Policy, and change a number of
debug messages to use these instead. Change a number of 'log_print'
to debug messages to keep the noise down. Use 'log_error' instead of
'log_print' in some cases when we have errno. Some indentation fixes.
(niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.22 2001/03/07 07:33:53 angelos Exp $	*/
d40 1
d914 1
a914 1
  char header[80];
d916 60
a975 2
  u_int8_t **id;
  size_t *id_len;
d977 2
a978 5
  /*
   * XXX Here, we could be checking that the received ID matches what
   * we expect it to be (if anything). That information is contained
   * in the [[exchange->name]:Remote-ID] section.
   */
a983 2
  /* XXX Do I really have to save the ID in the SA?  */
  payload = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_ID]);
@


1.22
log
@Add KEY_ID support (mostly from roland@@digitalvampire.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.21 2000/12/12 01:45:45 niklas Exp $	*/
d601 3
a603 2
  LOG_DBG_BUF ((LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: g^xy",
		ie->g_xy, ie->g_x_len));
d612 3
a614 2
  LOG_DBG_BUF ((LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: SKEYID",
		ie->skeyid, ie->skeyid_len));
d636 3
a638 2
  LOG_DBG_BUF ((LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: SKEYID_d",
		ie->skeyid_d, ie->skeyid_len));
d655 3
a657 2
  LOG_DBG_BUF ((LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: SKEYID_a",
		ie->skeyid_a, ie->skeyid_len));
d676 3
a678 2
  LOG_DBG_BUF ((LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: SKEYID_e",
		ie->skeyid_e, ie->skeyid_len));
d868 1
a868 1
  LOG_DBG_BUF ((LOG_MISC, 40, header, buf + ISAKMP_ID_DATA_OFF,
d940 1
a940 1
  LOG_DBG_BUF ((LOG_MISC, 40, header, payload->p + ISAKMP_ID_DATA_OFF,
d997 1
a997 1
  LOG_DBG_BUF ((LOG_MISC, 80, header, hash->digest, hashsize));
d1082 1
a1082 1
      LOG_DBG ((LOG_MISC, 20, "ike_phase_1_validate_prop: success"));
d1101 1
a1101 1
  LOG_DBG ((LOG_MISC, 20, "ike_phase_1_validate_prop: failure"));
d1126 2
a1127 1
      log_print ("attribute_unacceptable: attribute type %d not known", type);
d1143 3
a1145 2
	  log_print ("attribute_unacceptable: attr %s does not exist in %s",
		     tag, xf->field);
d1168 3
a1170 2
      log_print ("attribute_unacceptable: %s: got %s, expected %s",
		 tag, constant_lookup (map, decode_16 (value)), str);
d1191 2
a1192 2
	  log_print ("attribute_unacceptable: "
		     "received unexpected life attribute");
d1210 2
a1211 2
		  log_print ("attribute_unacceptable: "
			     "section [%s] has no LIFE_TYPE", life->field);
d1226 3
a1228 2
	  log_print ("attribute_unacceptable: unrecognized LIFE_TYPE %d",
		     decode_16 (value));
d1235 2
a1236 2
	      log_print ("attribute_unacceptable: "
			 "LIFE_DURATION without LIFE_TYPE");
@


1.21
log
@Merge with EOM 1.31

author: niklas
style nit, we only use NULL in isakmpd when a manpage mandates it

author: angelos
Also check for default Phase 1 ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_phase_1.c,v 1.20 2000/10/16 23:27:13 niklas Exp $	*/
d827 1
@


1.20
log
@Merge with EOM 1.29

author: angelos
Add comment on where we could be checking the Remote-ID.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.19 2000/10/07 06:58:07 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.29 2000/10/14 18:50:04 angelos Exp $	*/
d794 3
@


1.20.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.23 2001/03/13 14:05:18 ho Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.31 2000/12/11 23:47:56 niklas Exp $	*/
d601 2
a602 3
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
		"ike_phase_1_post_exchange_KE_NONCE: g^xy", ie->g_xy, 
		ie->g_x_len));
d611 2
a612 3
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID", ie->skeyid,
		ie->skeyid_len));
d634 2
a635 3
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID_d",	ie->skeyid_d,
		ie->skeyid_len));
d652 2
a653 3
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID_a",	ie->skeyid_a,
		ie->skeyid_len));
d672 2
a673 3
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, 
		"ike_phase_1_post_exchange_KE_NONCE: SKEYID_e",	ie->skeyid_e, 
		ie->skeyid_len));
a794 3
  if (!my_id)
    my_id = conf_get_str ("General", "Default-phase-1-ID");

a823 1
	case IPSEC_ID_KEY_ID:
d859 1
a859 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 40, header, buf + ISAKMP_ID_DATA_OFF,
d931 1
a931 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 40, header, payload->p + ISAKMP_ID_DATA_OFF,
d988 1
a988 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, header, hash->digest, hashsize));
d1073 1
a1073 1
      LOG_DBG ((LOG_NEGOTIATION, 20, "ike_phase_1_validate_prop: success"));
d1092 1
a1092 1
  LOG_DBG ((LOG_NEGOTIATION, 20, "ike_phase_1_validate_prop: failure"));
d1117 1
a1117 2
      LOG_DBG ((LOG_NEGOTIATION, 60, 
		"attribute_unacceptable: attribute type %d not known", type));
d1133 2
a1134 3
	  LOG_DBG ((LOG_NEGOTIATION, 70,
		    "attribute_unacceptable: attr %s does not exist in %s",
		    tag, xf->field));
d1157 2
a1158 3
      LOG_DBG ((LOG_NEGOTIATION, 70, 
		"attribute_unacceptable: %s: got %s, expected %s", tag, 
		constant_lookup (map, decode_16 (value)), str));
d1179 2
a1180 2
	  LOG_DBG ((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
		    "received unexpected life attribute"));
d1198 2
a1199 2
		  LOG_DBG ((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
			    "section [%s] has no LIFE_TYPE", life->field));
d1214 2
a1215 3
	  LOG_DBG ((LOG_NEGOTIATION, 70, 
		    "attribute_unacceptable: unrecognized LIFE_TYPE %d",
		    decode_16 (value)));
d1222 2
a1223 2
	      LOG_DBG ((LOG_NEGOTIATION, 70, "attribute_unacceptable: "
			"LIFE_DURATION without LIFE_TYPE"));
@


1.19
log
@Merge with EOM 1.28

author: niklas
style and < that should be <=

author: angelos
Handle 32-bit lifetimes (in generating them).

author: ho
Use log_print() instead of log_error here, no errno here.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.18 2000/04/07 22:05:48 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.28 2000/10/06 23:43:27 niklas Exp $	*/
d908 6
@


1.18
log
@Merge with EOM 1.25

author: niklas
wording
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.17 2000/03/08 08:43:04 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.25 2000/04/07 19:01:39 niklas Exp $	*/
d191 1
a191 1
	      /* XXX Does only handle 16-bit entities!  */
d193 12
a204 3
	      if (value)
		attr
		  = attribute_set_basic (attr, IKE_ATTR_LIFE_DURATION, value);
d252 1
a252 1
	  log_error ("ike_phase_1_initiator_send_SA: "
d415 1
a415 1
 
d684 1
a684 1
      
d710 1
a710 1
      for (len = prf->blocksize, p = key; len < exchange->key_length; 
d824 1
a824 1
	  memcpy (buf + ISAKMP_ID_DATA_OFF, conf_get_str (my_id, "Name"), 
d957 1
a957 1
  
d1043 1
a1043 1
		 * XXX Should we care about attributes we have, they do not 
d1127 1
a1127 1
	  log_print ("attribute_unacceptable: attr %s does not exist in %s", 
d1168 1
a1168 1
	
@


1.17
log
@Merge with EOM 1.24

author: niklas
line break
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.16 2000/02/28 22:48:34 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.24 2000/03/07 20:40:24 niklas Exp $	*/
d425 1
a425 1
/* Accept receptor's public DH value and nonce.  */
@


1.16
log
@Merge with EOM 1.23

author: niklas
nm@@wizard.web.am & winquist@@cybernet.com both independently found my
bug, a %s without a string given.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.15 2000/02/25 17:23:40 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.23 2000/02/28 22:52:46 niklas Exp $	*/
d1164 2
a1165 1
	  log_print ("attribute_unacceptable: received unexpected life attribute");
@


1.15
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.14 2000/02/19 19:32:53 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.22 2000/02/20 19:58:38 niklas Exp $	*/
d244 2
a245 1
		     "section [%s] has unsupported attribute(s)");
@


1.14
log
@cert.c: Merge with EOM 1.14
ike_auth.c: Merge with EOM 1.43
ike_phase_1.c: Merge with EOM 1.21
init.c: Merge with EOM 1.24
ipsec.c: Merge with EOM 1.117
isakmpd.c: Merge with EOM 1.44
math_group.c: Merge with EOM 1.22

author: niklas
Copyright 2000

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.13 2000/02/11 10:22:25 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.21 2000/02/19 07:58:55 niklas Exp $	*/
d591 2
a592 2
  log_debug_buf (LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: g^xy",
		 ie->g_xy, ie->g_x_len);
d601 2
a602 2
  log_debug_buf (LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: SKEYID",
		 ie->skeyid, ie->skeyid_len);
d624 2
a625 2
  log_debug_buf (LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: SKEYID_d",
		 ie->skeyid_d, ie->skeyid_len);
d642 2
a643 2
  log_debug_buf (LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: SKEYID_a",
		 ie->skeyid_a, ie->skeyid_len);
d662 2
a663 2
  log_debug_buf (LOG_MISC, 80, "ike_phase_1_post_exchange_KE_NONCE: SKEYID_e",
		 ie->skeyid_e, ie->skeyid_len);
d849 2
a850 2
  log_debug_buf (LOG_MISC, 40, header, buf + ISAKMP_ID_DATA_OFF,
		 sz - ISAKMP_ID_DATA_OFF);
d915 2
a916 2
  log_debug_buf (LOG_MISC, 40, header, payload->p + ISAKMP_ID_DATA_OFF,
		 *id_len + ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF);
d972 1
a972 1
  log_debug_buf (LOG_MISC, 80, header, hash->digest, hashsize);
d1057 1
a1057 1
      log_debug (LOG_MISC, 20, "ike_phase_1_validate_prop: success");
d1076 1
a1076 1
  log_debug (LOG_MISC, 20, "ike_phase_1_validate_prop: failure");
@


1.13
log
@Merge with EOM 1.19

author: ho
style...

author: ho
Think-o. Reword log msg again to match what happens here.

author: ho
(struct constant_map *) is not (char *), plus reword the log msg.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.12 2000/02/01 02:46:18 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.19 2000/02/07 02:08:13 ho Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
d236 10
@


1.12
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.11 2000/01/30 09:20:57 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.16 2000/01/31 22:33:45 niklas Exp $	*/
d1131 2
a1132 1
      log_print ("attribute_unacceptable: got %s, expected %s", map, str);
@


1.11
log
@Merge with EOM 1.15

author: angelos
Better logic.

author: angelos
Don't crash if Life is not present...
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.10 2000/01/27 18:07:16 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.15 2000/01/30 07:09:26 angelos Exp $	*/
d6 1
@


1.10
log
@Merge with EOM 1.13

author: ho
Bugfix. From <Jorgen.Granstam@@abc.se>.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.9 2000/01/26 15:21:36 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.13 2000/01/27 17:14:17 ho Exp $	*/
d1143 2
a1144 1
      if (!strcmp (conf_get_str (xf->field, "Life"), "ANY"))
a1147 1
      life_conf = conf_get_list (xf->field, "Life");
@


1.9
log
@Merge with EOM 1.12

date: 2000/01/25 06:13:15;  author: angelos;  state: Exp;  lines: +7 -4
Handle IPV4_ADDR as a Phase 1 ID
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.8 1999/10/01 14:07:42 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.12 2000/01/25 06:13:15 angelos Exp $	*/
d803 2
a804 1
	  memcpy (buf + ISAKMP_ID_DATA_OFF, conf_get_str (my_id, "Name"), sz);
@


1.8
log
@Merge with EOM 1.11

author: ho
add some more debugging info

author: angelos
Allow "Life" to be ANY

author: angelos
Allow "ANY" in some fields
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.7 1999/08/26 22:27:51 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.11 1999/09/29 22:05:38 ho Exp $	*/
a792 1
#ifdef notyet
d794 6
a799 1
	  /* XXX not implemented yet.  */
a800 1
#endif
@


1.7
log
@ike_phase_1.c: Merge with EOM 1.8
message.c: Merge with EOM 1.135
message.h: Merge with EOM 1.48
sa.c: Merge with EOM 1.97
sa.h: Merge with EOM 1.53

author: angelos
Complete policy work; tested for the shared-key case. Documentation needed.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.6 1999/07/17 21:54:39 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.8 1999/08/18 00:44:55 angelos Exp $	*/
d1100 6
a1105 2
	/* This attribute does not exist in this policy.  */
	return 1;
d1111 2
a1112 1
      if (constant_value (map, str) == decode_16 (value))
d1126 1
d1139 3
d1145 5
a1149 2
	/* Life attributes given, but not in our policy.  */
	return 1;
d1194 7
a1200 2
	  rv = !conf_match_num (vs->life, "LIFE_DURATION",
				len == 4 ? decode_32 (value) : decode_16 (value));
@


1.6
log
@regress/rsakeygen/Makefile: Merge with EOM 1.4
regress/rsakeygen/rsakeygen.c: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.6
regress/x509/x509test.c: Merge with EOM 1.6
regress/Makefile: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.6
samples/VPN-west.conf: Merge with EOM 1.6
samples/singlehost-east.conf: Merge with EOM 1.3
samples/singlehost-west.conf: Merge with EOM 1.3
sysdep/openbsd/Makefile.sysdep: Merge with EOM 1.5
x509.h: Merge with EOM 1.6
x509.c: Merge with EOM 1.17
DESIGN-NOTES: Merge with EOM 1.46
Makefile: Merge with EOM 1.55
cert.c: Merge with EOM 1.11
cert.h: Merge with EOM 1.6
exchange.c: Merge with EOM 1.109
exchange.h: Merge with EOM 1.26
ike_auth.c: Merge with EOM 1.32
ike_phase_1.c: Merge with EOM 1.7
init.c: Merge with EOM 1.16
isakmpd.conf.5: Merge with EOM 1.27
README.PKI: Merge with EOM 1.1

author: niklas
From Niels Provos, edited by me: certificate support using SSLeay
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.5 1999/07/16 02:01:59 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.7 1999/07/17 20:44:10 niklas Exp $	*/
d66 2
a67 1
static int ike_phase_1_validate_prop (struct exchange *, struct sa *);
d982 2
a983 1
ike_phase_1_validate_prop (struct exchange *exchange, struct sa *sa)
@


1.5
log
@Merge with EOM 1.6

author: niklas
Bugs found when interoperating with KAME:
Inbound policy was not checked properly.  Lifetime duration could be in
long format.  Main mode can carry different DH-groups.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.4 1999/07/07 22:15:42 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.6 1999/07/16 02:01:52 niklas Exp $	*/
d928 1
a928 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
@


1.4
log
@ike_phase_1.c: Merge with EOM 1.5
x509.c: Merge with EOM 1.16

author: niklas
Start stab at supporting other IDs than IPV4_ADDR in main mode
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.3 1999/05/02 19:16:41 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.5 1999/06/15 11:21:21 niklas Exp $	*/
d216 2
a217 9
      /*
       * Make sure that if a group description is specified, it is
       * specified for all transforms equally.
       */
      attr = conf_get_str (xf->field, "GROUP_DESCRIPTION");
      new_group_desc = attr ? constant_value (ike_group_desc_cst, attr) : 0;
      if (group_desc == -1)
	group_desc = new_group_desc;
      else if (group_desc != new_group_desc)
d219 15
a233 3
	  log_print ("ike_phase_1_inititor_send_SA: "
		     "differing group descriptions in a proposal");
	  goto bail_out;
d237 4
a333 3
  if (group_desc)
    ie->group = group_get (group_desc);

d362 1
a363 1
  struct sa *sa = TAILQ_FIRST (&exchange->sa_list);
a364 1
  struct proto *proto;
d383 4
a386 6
  /* Build the protection suite in our SA.  */
  if (sa_add_transform (sa, xf, msg->exchange->initiator, &proto))
    {
      /* XXX Log?  */
      return -1;
    }
a387 1
  /* XXX Check that the chosen transform matches an offer.  */
d390 4
a396 7
  if ((isa->group_desc && (!ie->group || ie->group->id != isa->group_desc))
      || (!isa->group_desc && ie->group))
    {
      log_print ("ike_phase_1_initiator_recv_SA: disagreement on DH group");
      return -1;
    }

d1180 2
a1181 1
	  rv = !conf_match_num (vs->life, "LIFE_DURATION", decode_16 (value));
@


1.3
log
@ike_phase_1.c: Merge with EOM 1.4
prf.c: Merge with EOM 1.7

author: niklas
Remove bogus XXXes, add allocation error reporting.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.2 1999/04/30 11:46:23 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.4 1999/05/02 12:50:27 niklas Exp $	*/
d758 1
a758 1
  size_t sz;
d764 2
d771 8
a778 1
  sz = ISAKMP_ID_DATA_OFF + 4;
a785 3
  msg->transport->vtbl->get_src (msg->transport, &src, &src_len);
  /* XXX Assumes IPv4.  */
  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV4_ADDR);
d788 31
a818 3
  /* Already in network byteorder.  */
  memcpy (buf + ISAKMP_ID_DATA_OFF,
	  &((struct sockaddr_in *)src)->sin_addr.s_addr, sizeof (in_addr_t));
@


1.2
log
@ike_phase_1.c: Merge with EOM 1.3
ike_quick_mode.c: Merge with EOM 1.84
message.h: Merge with EOM 1.46

author: niklas
New message_drop API.  Generate real INVALID_COOKIE notification.
Generate informational exchanges in phase 1 too.  Really get these
messages to the wire
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_phase_1.c,v 1.1 1999/04/19 21:05:22 niklas Exp $	*/
/*	$EOM: ike_phase_1.c,v 1.3 1999/04/29 10:51:36 niklas Exp $	*/
a619 1
      /* XXX How to notify peer?  */
@


1.1
log
@./ike_phase_1.c: Merge with EOM 1.2

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.

Let's get aggressive!
@
text
@d1 2
a2 1
/*	$Id: ike_phase_1.c,v 1.2 1999/04/17 23:20:26 niklas Exp $	*/
d374 1
a374 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 0);
d446 1
a446 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 0);
d467 1
a467 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 0);
d896 1
a896 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 0);
@

