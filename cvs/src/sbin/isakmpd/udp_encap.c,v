head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.10
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.26
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.24
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.22
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.20
	OPENBSD_5_0:1.21.0.18
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.16
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.14
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.10
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.12
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.8
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.19.0.6
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7;
locks; strict;
comment	@ * @;


1.23
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	0qPuuXwccpVXsXcV;

1.22
date	2014.01.22.03.09.31;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.15.19.37.46;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.02.14.33.53;	author hshoexer;	state Exp;
branches
	1.19.4.1
	1.19.6.1;
next	1.18;

1.18
date	2005.08.25.09.57.58;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.04.21.54.55;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.01.23.03.56;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.08.16.07.22;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.05.12.21.35;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.04.16.57.34;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.14.10.17.28;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.20.15.00.45;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.24.13.31.04;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.10.15.59.10;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.03.10.54.09;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.07.09.13.01;	author hshoexer;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.21.23.27.10;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.21.13.09.01;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	;

1.19.4.1
date	2007.05.18.21.34.43;	author ckuethe;	state Exp;
branches;
next	;

1.19.6.1
date	2007.05.18.21.34.07;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.23
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@/*	$OpenBSD: udp_encap.c,v 1.22 2014/01/22 03:09:31 deraadt Exp $	*/

/*
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2000 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <limits.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "conf.h"
#include "if.h"
#include "ipsec_doi.h"
#include "isakmp.h"
#include "log.h"
#include "message.h"
#include "monitor.h"
#include "transport.h"
#include "udp.h"
#include "udp_encap.h"
#include "util.h"
#include "virtual.h"

#define UDP_SIZE 65536

/* If a system doesn't have SO_REUSEPORT, SO_REUSEADDR will have to do.  */
#ifndef SO_REUSEPORT
#define SO_REUSEPORT SO_REUSEADDR
#endif

/* Reused, from udp.c */
struct transport *udp_clone(struct transport *, struct sockaddr *);
int		  udp_fd_set(struct transport *, fd_set *, int);
int		  udp_fd_isset(struct transport *, fd_set *);
void		  udp_get_dst(struct transport *, struct sockaddr **);
void		  udp_get_src(struct transport *, struct sockaddr **);
char		 *udp_decode_ids(struct transport *);
void		  udp_remove(struct transport *);

static struct transport *udp_encap_create(char *);
static void		 udp_encap_report(struct transport *);
static void		 udp_encap_handle_message(struct transport *);
static struct transport *udp_encap_make(struct sockaddr *);
static int		 udp_encap_send_message(struct message *,
    struct transport *);

static struct transport_vtbl udp_encap_transport_vtbl = {
	{ 0 }, "udp_encap",
	udp_encap_create,
	0,
	udp_remove,
	udp_encap_report,
	udp_fd_set,
	udp_fd_isset,
	udp_encap_handle_message,
	udp_encap_send_message,
	udp_get_dst,
	udp_get_src,
	udp_decode_ids,
	udp_clone,
	0
};

char	 *udp_encap_default_port = 0;

void
udp_encap_init(void)
{
	transport_method_add(&udp_encap_transport_vtbl);
}

/* Create a UDP transport structure bound to LADDR just for listening.  */
static struct transport *
udp_encap_make(struct sockaddr *laddr)
{
	struct udp_transport *t = 0;
	int	 s, on, wildcardaddress = 0;
	char	*tstr;

	t = calloc(1, sizeof *t);
	if (!t) {
		log_print("udp_encap_make: malloc(%lu) failed",
		    (unsigned long)sizeof *t);
		free(laddr);
		return 0;
	}
	t->src = laddr;

	s = socket(laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
	if (s == -1) {
		log_error("udp_encap_make: socket (%d, %d, %d)",
		    laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
		goto err;
	}

	/* Make sure we don't get our traffic encrypted.  */
	if (sysdep_cleartext(s, laddr->sa_family) == -1)
		goto err;

	/* Wildcard address ?  */
	switch (laddr->sa_family) {
	case AF_INET:
		if (((struct sockaddr_in *)laddr)->sin_addr.s_addr
		    == INADDR_ANY)
			wildcardaddress = 1;
		break;
	case AF_INET6:
		if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)laddr)->sin6_addr))
			wildcardaddress = 1;
		break;
	}

	/*
	 * In order to have several bound specific address-port combinations
	 * with the same port SO_REUSEADDR is needed.
	 * If this is a wildcard socket and we are not listening there, but
	 * only sending from it make sure it is entirely reuseable with
	 * SO_REUSEPORT.
	 */
	on = 1;
	if (setsockopt(s, SOL_SOCKET,
	    wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
	    (void *)&on, sizeof on) == -1) {
		log_error("udp_encap_make: setsockopt (%d, %d, %d, %p, %lu)",
		    s, SOL_SOCKET,
		    wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR, &on,
		    (unsigned long)sizeof on);
		goto err;
	}

	t->transport.vtbl = &udp_encap_transport_vtbl;
	if (monitor_bind(s, t->src, SA_LEN(t->src))) {
		if (sockaddr2text(t->src, &tstr, 0))
			log_error("udp_encap_make: bind (%d, %p, %lu)", s,
			    &t->src, (unsigned long)sizeof t->src);
		else {
			log_error("udp_encap_make: bind (%d, %s, %lu)", s,
			    tstr, (unsigned long)sizeof t->src);
			free(tstr);
		}
		goto err;
	}

	t->s = s;
	if (sockaddr2text(t->src, &tstr, 0))
		LOG_DBG((LOG_MISC, 20, "udp_encap_make: "
		    "transport %p socket %d family %d", t, s,
		    t->src->sa_family == AF_INET ? 4 : 6));
	else {
		LOG_DBG((LOG_MISC, 20, "udp_encap_make: "
		    "transport %p socket %d ip %s port %d", t, s,
		    tstr, ntohs(sockaddr_port(t->src))));
		free(tstr);
	}
	transport_setup(&t->transport, 0);
	t->transport.flags |= TRANSPORT_LISTEN;
	return &t->transport;

err:
	if (s >= 0)
		close (s);
	if (t) {
		/* Already closed.  */
		t->s = -1;
		udp_remove(&t->transport);
	}
	return 0;
}

/*
 * Initialize an object of the UDP transport class.  Fill in the local
 * IP address and port information and create a server socket bound to
 * that specific port.  Add the polymorphic transport structure to the
 * system-wide pools of known ISAKMP transports.
 */
struct transport *
udp_encap_bind(const struct sockaddr *addr)
{
	struct sockaddr	*src;

	src = malloc(SA_LEN(addr));
	if (!src)
		return 0;

	memcpy(src, addr, SA_LEN(addr));
	return udp_encap_make(src);
}

/*
 * NAME is a section name found in the config database.  Setup and return
 * a transport useable to talk to the peer specified by that name.
 */
static struct transport *
udp_encap_create(char *name)
{
	struct virtual_transport *v;
	struct udp_transport	*u;
	struct transport	*rv, *t;
	struct sockaddr		*dst, *addr;
	struct conf_list	*addr_list = 0;
	struct conf_list_node	*addr_node;
	char	*addr_str, *port_str;

	port_str = conf_get_str(name, "Port"); /* XXX "Encap-port" ? */
	if (!port_str)
		port_str = udp_encap_default_port;
	if (!port_str)
		port_str = UDP_ENCAP_DEFAULT_PORT_STR;

	addr_str = conf_get_str(name, "Address");
	if (!addr_str) {
		log_print("udp_encap_create: no address configured "
		    "for \"%s\"", name);
		return 0;
	}
	if (text2sockaddr(addr_str, port_str, &dst, 0, 0)) {
		log_print("udp_encap_create: address \"%s\" not understood",
		    addr_str);
		return 0;
	}

	addr_str = conf_get_str(name, "Local-address");
	if (!addr_str)
		addr_list = conf_get_list("General", "Listen-on");
	if (!addr_str && !addr_list) {
		v = virtual_get_default(dst->sa_family);
		u = (struct udp_transport *)v->encap;

		if (!u) {
			log_print("udp_encap_create: no default transport");
			rv = 0;
			goto ret;
		} else {
			rv = udp_clone((struct transport *)u, dst);
			if (rv)
				rv->vtbl = &udp_encap_transport_vtbl;
			goto ret;
		}
	}

	if (addr_list) {
		for (addr_node = TAILQ_FIRST(&addr_list->fields);
		    addr_node; addr_node = TAILQ_NEXT(addr_node, link))
			if (text2sockaddr(addr_node->field, port_str,
			    &addr, 0, 0) == 0) {
				v = virtual_listen_lookup(addr);
				free(addr);
				if (v) {
					addr_str = addr_node->field;
					break;
				}
			}
		if (!addr_str) {
			log_print("udp_encap_create: "
			    "no matching listener found");
			rv = 0;
			goto ret;
		}
	}
	if (text2sockaddr(addr_str, port_str, &addr, 0, 0)) {
		log_print("udp_encap_create: "
		    "address \"%s\" not understood", addr_str);
		rv = 0;
		goto ret;
	}
	v = virtual_listen_lookup(addr);
	free(addr);
	if (!v) {
		log_print("udp_encap_create: "
		    "%s:%s must exist as a listener too", addr_str, port_str);
		rv = 0;
		goto ret;
	}
	t = (struct transport *)v;
	rv = udp_clone(v->encap, dst);
	if (rv)
		rv->vtbl = &udp_encap_transport_vtbl;

ret:
	if (addr_list)
		conf_free_list(addr_list);
	free(dst);
	return rv;
}

/* Report transport-method specifics of the T transport.  */
void
udp_encap_report(struct transport *t)
{
	struct udp_transport *u = (struct udp_transport *)t;
	char	 *src = NULL, *dst = NULL;
	in_port_t sport, dport;

	if (sockaddr2text(u->src, &src, 0))
		return;
	sport = sockaddr_port(u->src);

	if (!u->dst || sockaddr2text(u->dst, &dst, 0))
		dst = 0;
	dport = dst ? sockaddr_port(u->dst) : 0;

	LOG_DBG ((LOG_REPORT, 0, "udp_encap_report: fd %d src %s:%u dst %s:%u",
	    u->s, src, ntohs(sport), dst ? dst : "*", ntohs(dport)));

	free(dst);
	free(src);
}

/*
 * A message has arrived on transport T's socket.  If T is single-ended,
 * clone it into a double-ended transport which we will use from now on.
 * Package the message as we want it and continue processing in the message
 * module.
 */
static void
udp_encap_handle_message(struct transport *t)
{
	struct udp_transport	*u = (struct udp_transport *)t;
	struct sockaddr_storage	 from;
	struct message		*msg;
	u_int32_t	len = sizeof from;
	ssize_t		n;
	u_int8_t	buf[UDP_SIZE];

	n = recvfrom(u->s, buf, UDP_SIZE, 0, (struct sockaddr *)&from, &len);
	if (n == -1) {
		log_error("recvfrom (%d, %p, %d, %d, %p, %p)", u->s, buf,
		    UDP_SIZE, 0, &from, &len);
		return;
	}

	if (t->virtual == (struct transport *)virtual_get_default(AF_INET) ||
	    t->virtual == (struct transport *)virtual_get_default(AF_INET6)) {
		t->virtual->vtbl->reinit();

		/*
		 * As we don't know the actual destination address of the
		 * packet, we can't really deal with it. So, just ignore it
		 * and hope we catch the retransmission.
		 */
		return;
	}

	/*
	 * Make a specialized UDP transport structure out of the incoming
	 * transport and the address information we got from recvfrom(2).
	 */
	t = t->virtual->vtbl->clone(t->virtual, (struct sockaddr *)&from);
	if (!t)
		return;

	/* Check NULL-ESP marker.  */
	if (n < (ssize_t)sizeof(u_int32_t) || *(u_int32_t *)buf != 0) {
		/* Should never happen.  */
		log_print("udp_encap_handle_message: "
		    "Null-ESP marker not NULL or short message");
		return;
	}

	/* NAT-Keepalive messages should not be processed further.  */
	n -= sizeof(u_int32_t);
	if (n == 1 && buf[sizeof(u_int32_t)] == 0xFF)
		return;

	msg = message_alloc(t, buf + sizeof (u_int32_t), n);
	if (!msg) {
		log_error("failed to allocate message structure, dropping "
		    "packet received on transport %p", u);
		return;
	}

	msg->flags |= MSG_NATT;

	message_recv(msg);
}

/*
 * Physically send the message MSG over its associated transport.
 * Special: if 'msg' is NULL, send a NAT-T keepalive message.
 */
static int
udp_encap_send_message(struct message *msg, struct transport *t)
{
	struct udp_transport *u = (struct udp_transport *)t;
	struct msghdr	 m;
	struct iovec	*new_iov = 0, keepalive;
	ssize_t		 n;
	u_int32_t	 marker = 0;			/* NULL-ESP Marker */

	if (msg) {
		/* Construct new iov array, prefixing NULL-ESP Marker.  */
		new_iov = calloc(msg->iovlen + 1, sizeof *new_iov);
		if (!new_iov) {
			log_error ("udp_encap_send_message: "
			    "calloc(%lu, %lu) failed",
			    (unsigned long)msg->iovlen + 1,
			    (unsigned long)sizeof *new_iov);
			return -1;
		}
		new_iov[0].iov_base = &marker;
		new_iov[0].iov_len = IPSEC_SPI_SIZE;
		memcpy (new_iov + 1, msg->iov, msg->iovlen * sizeof *new_iov);
	} else {
		marker = ~marker;
		keepalive.iov_base = &marker;
		keepalive.iov_len = 1;
	}

	/*
	 * Sending on connected sockets requires that no destination address is
	 * given, or else EISCONN will occur.
	 */
	m.msg_name = (caddr_t)u->dst;
	m.msg_namelen = SA_LEN(u->dst);
	m.msg_iov = msg ? new_iov : &keepalive;
	m.msg_iovlen = msg ? msg->iovlen + 1 : 1;
	m.msg_control = 0;
	m.msg_controllen = 0;
	m.msg_flags = 0;
	n = sendmsg (u->s, &m, 0);
	if (msg)
		free (new_iov);
	if (n == -1) {
		/* XXX We should check whether the address has gone away */
		log_error ("sendmsg (%d, %p, %d)", u->s, &m, 0);
		return -1;
	}
	return 0;
}
@


1.22
log
@improve randomization.  remove some junk debugging features that are
fundamentally broken.
ok jsing mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.21 2007/04/16 13:01:39 moritz Exp $	*/
d114 1
a114 1
		log_print("udp_encap_make: malloc (%lu) failed",
d424 1
a424 2
		new_iov = (struct iovec *)calloc (msg->iovlen + 1,
		    sizeof *new_iov);
d427 1
a427 1
			    "calloc (%lu, %lu) failed",
@


1.21
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.20 2007/04/15 19:37:46 hshoexer Exp $	*/
a41 2

#include "sysdep.h"
@


1.20
log
@Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.19 2006/02/02 14:33:53 hshoexer Exp $	*/
d339 2
a340 4
	if (dst)
		free(dst);
	if (src)
		free(src);
@


1.19
log
@Small cleanup to avoid gotos, from Andrey Matveev.
ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.18 2005/08/25 09:57:58 markus Exp $	*/
d407 3
@


1.19.4.1
log
@Original Commit by hshoexer@@, original commit message:
===========================================================================
Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
===========================================================================
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.19 2006/02/02 14:33:53 hshoexer Exp $	*/
a406 3

	msg->flags |= MSG_NATT;

@


1.19.6.1
log
@Original Commit by hshoexer@@, original commit message:
===========================================================================
Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
===========================================================================
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.19 2006/02/02 14:33:53 hshoexer Exp $	*/
d339 4
a342 2
	free(dst);
	free(src);
@


1.18
log
@read the information from the INADDR_ANY socket and do not loop if
a new IP appears (cf udp.c, rev 1.74), ok ho@@ hshoexer@@ cloder@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.17 2005/06/04 21:54:55 hshoexer Exp $	*/
d329 1
a329 1
		goto ret;
a338 1
  ret:
@


1.17
log
@undo last commit, all memory is already freed by udp_remove()

ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.16 2005/06/01 23:03:56 cloder Exp $	*/
d366 12
@


1.16
log
@Fix memory leaks. OK hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.15 2005/04/08 23:15:26 hshoexer Exp $	*/
a199 1
		free(t);
@


1.15
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.14 2005/04/08 16:07:22 cloder Exp $	*/
d200 1
@


1.14
log
@Remove references to LINUX_IPSEC
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.13 2005/04/04 19:31:11 deraadt Exp $	*/
a51 1
#include "sysdep.h"
d166 1
a166 1
	if (monitor_bind(s, t->src, sysdep_sa_len (t->src))) {
d215 1
a215 1
	src = malloc(sysdep_sa_len((struct sockaddr *)addr));
d219 1
a219 1
	memcpy(src, addr, sysdep_sa_len((struct sockaddr *)addr));
d437 1
a437 1
	m.msg_namelen = sysdep_sa_len (u->dst);
@


1.13
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.12 2005/03/05 12:21:35 ho Exp $	*/
a31 1
#ifndef linux
a32 1
#endif
@


1.12
log
@No need for err.h. hshoexer@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.11 2005/03/04 16:57:34 hshoexer Exp $	*/
d280 1
a280 1
		     addr_node; addr_node = TAILQ_NEXT(addr_node, link))
@


1.11
log
@remove unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.10 2004/12/14 10:17:28 mcbride Exp $	*/
a38 1
#include <err.h>
@


1.10
log
@Allow the Address, Network, or Netmask values of the <IPsec-ID> to be
specified with an interface name (in which case the first address is used)
or the keyword 'default' (in which case the address is selected based on the
default route). eg:

[roadwarrior-ip]
ID-type=                IPV4_ADDR
Address=                default

ok ho@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.9 2004/10/20 15:00:45 hshoexer Exp $	*/
a102 1
char	 *udp_encap_bind_port = 0;
@


1.9
log
@fix potential memleaks & small cleanup.  found by patrick latifi, thanks!

ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.8 2004/09/24 13:31:04 ho Exp $	*/
d255 1
a255 1
	if (text2sockaddr(addr_str, port_str, &dst)) {
d284 1
a284 1
			    &addr) == 0) {
d299 1
a299 1
	if (text2sockaddr(addr_str, port_str, &addr)) {
@


1.8
log
@Don't process NAT-T keepalives. Noted by Kamel Messaoudi. hshoexer@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.7 2004/08/10 15:59:10 ho Exp $	*/
d123 1
d126 1
a170 1
	t->src = laddr;
d218 1
a218 2
	struct sockaddr	*src =
	    malloc(sysdep_sa_len((struct sockaddr *)addr));
d220 1
d330 1
a330 1
	char	 *src, *dst;
@


1.7
log
@Better implementation of the Dead Peer Detection protocol, RFC 3706.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.6 2004/08/08 19:11:06 deraadt Exp $	*/
d389 6
a394 2
	msg = message_alloc(t, buf + sizeof (u_int32_t),
	    n - sizeof (u_int32_t));
@


1.6
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.5 2004/08/03 10:54:09 ho Exp $	*/
d384 1
a384 1
		log_print ("udp_encap_handle_message: "
d392 1
a392 1
		log_error ("failed to allocate message structure, dropping "
d396 1
a396 1
	message_recv (msg);
@


1.5
log
@Rewrite the transport reference count code to avoid leaks.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.4 2004/07/07 09:13:01 hshoexer Exp $	*/
d240 1
a240 1
	char 	*addr_str, *port_str;
@


1.4
log
@compile cleanly with -Wsign-compare; while around, kill a space

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.3 2004/06/21 23:27:10 ho Exp $	*/
d70 1
a70 1
struct transport *udp_clone (struct transport *, struct sockaddr *);
d73 10
a82 10
void		  udp_get_dst (struct transport *, struct sockaddr **);
void		  udp_get_src (struct transport *, struct sockaddr **);
char		 *udp_decode_ids (struct transport *);

static struct transport *udp_encap_create (char *);
static void		 udp_encap_remove (struct transport *);
static void		 udp_encap_report (struct transport *);
static void		 udp_encap_handle_message (struct transport *);
static struct transport *udp_encap_make (struct sockaddr *);
static int		 udp_encap_send_message (struct message *,
d89 1
a89 1
	udp_encap_remove,
a193 1
	transport_reference(&t->transport);
d203 1
a203 1
		udp_encap_remove(&t->transport);
d314 4
a317 6
	if (rv) {
		rv->vtbl = &udp_encap_transport_vtbl; /* XXX Necessary? */
		transport_reference(rv->virtual);
	}
  
  ret:
a321 18
}

void
udp_encap_remove(struct transport *t)
{
	struct udp_transport *u = (struct udp_transport *)t;

	if (u->src)
		free (u->src);
	if (u->dst)
		free (u->dst);
	if (t->flags & TRANSPORT_LISTEN) {
		if (u->s >= 0)
			close (u->s);
		if (u->link.le_prev)
			LIST_REMOVE (u, link);
	}
	free (t);
@


1.3
log
@Implement NAT-T keepalive messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.2 2004/06/21 13:09:01 ho Exp $	*/
d198 1
a198 1
  err:
d403 1
a403 1
	if (n < sizeof (u_int32_t) || *(u_int32_t *)buf != 0) {
@


1.2
log
@Port floating (500->4500) for p1 and p2 exchanges.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp_encap.c,v 1.1 2004/06/20 15:24:05 ho Exp $	*/
d420 4
a423 1
/* Physically send the message MSG over its associated transport.  */
d429 1
a429 1
	struct iovec	*new_iov;
d433 18
a450 7
	/* Construct new iov array, prefixing NULL-ESP Marker.  */
	new_iov = (struct iovec *)calloc (msg->iovlen + 1, sizeof *new_iov);
	if (!new_iov) {
		log_error ("udp_encap_send_message: calloc (%lu, %lu) failed",
		    (unsigned long)msg->iovlen + 1,
		    (unsigned long)sizeof *new_iov);
		return -1;
a451 3
	new_iov[0].iov_base = &marker;
	new_iov[0].iov_len = IPSEC_SPI_SIZE;
	memcpy (new_iov + 1, msg->iov, msg->iovlen * sizeof *new_iov);
d459 2
a460 2
	m.msg_iov = new_iov;
	m.msg_iovlen = msg->iovlen + 1;
d465 2
a469 1
		free (new_iov);
a471 1
	free (new_iov);
@


1.1
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.65 2003/09/26 11:29:11 cedric Exp $	*/
d71 2
d91 2
a92 2
	0,
	0,
d440 1
a440 2
	memcpy (new_iov + sizeof *new_iov, msg->iov,
	    msg->iovlen * sizeof *new_iov);
@
