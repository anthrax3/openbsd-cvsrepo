head	1.118;
access;
symbols
	OPENBSD_6_2_BASE:1.118
	OPENBSD_6_1:1.118.0.12
	OPENBSD_6_1_BASE:1.118
	OPENBSD_6_0:1.118.0.8
	OPENBSD_6_0_BASE:1.118
	OPENBSD_5_9:1.118.0.4
	OPENBSD_5_9_BASE:1.118
	OPENBSD_5_8:1.118.0.6
	OPENBSD_5_8_BASE:1.118
	OPENBSD_5_7:1.118.0.2
	OPENBSD_5_7_BASE:1.118
	OPENBSD_5_6:1.117.0.4
	OPENBSD_5_6_BASE:1.117
	OPENBSD_5_5:1.115.0.4
	OPENBSD_5_5_BASE:1.115
	OPENBSD_5_4:1.113.0.14
	OPENBSD_5_4_BASE:1.113
	OPENBSD_5_3:1.113.0.12
	OPENBSD_5_3_BASE:1.113
	OPENBSD_5_2:1.113.0.10
	OPENBSD_5_2_BASE:1.113
	OPENBSD_5_1_BASE:1.113
	OPENBSD_5_1:1.113.0.8
	OPENBSD_5_0:1.113.0.6
	OPENBSD_5_0_BASE:1.113
	OPENBSD_4_9:1.113.0.4
	OPENBSD_4_9_BASE:1.113
	OPENBSD_4_8:1.113.0.2
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.112.0.4
	OPENBSD_4_7_BASE:1.112
	OPENBSD_4_6:1.112.0.6
	OPENBSD_4_6_BASE:1.112
	OPENBSD_4_5:1.112.0.2
	OPENBSD_4_5_BASE:1.112
	OPENBSD_4_4:1.111.0.4
	OPENBSD_4_4_BASE:1.111
	OPENBSD_4_3:1.111.0.2
	OPENBSD_4_3_BASE:1.111
	OPENBSD_4_2:1.110.0.2
	OPENBSD_4_2_BASE:1.110
	OPENBSD_4_1:1.108.0.2
	OPENBSD_4_1_BASE:1.108
	OPENBSD_4_0:1.106.0.2
	OPENBSD_4_0_BASE:1.106
	OPENBSD_3_9:1.105.0.2
	OPENBSD_3_9_BASE:1.105
	OPENBSD_3_8:1.103.0.2
	OPENBSD_3_8_BASE:1.103
	OPENBSD_3_7:1.97.0.2
	OPENBSD_3_7_BASE:1.97
	OPENBSD_3_6:1.95.0.2
	OPENBSD_3_6_BASE:1.95
	OPENBSD_3_5:1.86.0.2
	OPENBSD_3_5_BASE:1.86
	OPENBSD_3_4:1.82.0.2
	OPENBSD_3_4_BASE:1.82
	OPENBSD_3_3:1.78.0.2
	OPENBSD_3_3_BASE:1.78
	OPENBSD_3_2:1.77.0.2
	OPENBSD_3_2_BASE:1.77
	OPENBSD_3_1:1.69.0.2
	OPENBSD_3_1_BASE:1.69
	OPENBSD_3_0:1.65.0.2
	OPENBSD_3_0_BASE:1.65
	OPENBSD_2_9:1.49.0.2
	OPENBSD_2_9_BASE:1.49
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.27.0.2
	OPENBSD_2_7_BASE:1.27
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.118
date	2015.01.16.06.39.59;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	Uu5nFG3wCl0LACBb;

1.117
date	2014.05.01.07.35.57;	author jsg;	state Exp;
branches;
next	1.116;

1.116
date	2014.03.07.07.19.42;	author gerhard;	state Exp;
branches;
next	1.115;

1.115
date	2013.11.14.15.44.06;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2013.10.27.18.54.03;	author guenther;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.29.19.50.16;	author reyk;	state Exp;
branches;
next	1.112;

1.112
date	2008.09.06.12.22.57;	author djm;	state Exp;
branches;
next	1.111;

1.111
date	2007.09.02.15.19.24;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2007.08.05.09.43.09;	author tom;	state Exp;
branches;
next	1.109;

1.109
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.108;

1.108
date	2007.03.03.20.03.03;	author tom;	state Exp;
branches;
next	1.107;

1.107
date	2006.09.19.10.48.41;	author otto;	state Exp;
branches;
next	1.106;

1.106
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2005.11.15.21.49.04;	author cloder;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2005.11.14.23.25.11;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2005.05.28.17.42.50;	author moritz;	state Exp;
branches;
next	1.102;

1.102
date	2005.05.26.00.58.52;	author cloder;	state Exp;
branches;
next	1.101;

1.101
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.100;

1.100
date	2005.04.08.17.15.01;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2005.04.08.16.24.12;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2005.04.05.20.46.20;	author cloder;	state Exp;
branches;
next	1.97;

1.97
date	2005.03.15.16.49.05;	author mpf;	state Exp;
branches;
next	1.96;

1.96
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.95;

1.95
date	2004.08.10.19.21.01;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2004.06.17.19.32.06;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2004.06.14.13.53.31;	author hshoexer;	state Exp;
branches;
next	1.91;

1.91
date	2004.06.14.09.55.42;	author ho;	state Exp;
branches;
next	1.90;

1.90
date	2004.06.02.16.19.16;	author hshoexer;	state Exp;
branches;
next	1.89;

1.89
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.86;

1.86
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.85;

1.85
date	2004.01.06.00.09.19;	author hshoexer;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.07.10.16.44;	author jmc;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.06.16.12.08;	author ho;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.04.07.31.17;	author ho;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.79;

1.79
date	2003.04.09.15.46.48;	author ho;	state Exp;
branches;
next	1.78;

1.78
date	2002.12.03.16.08.13;	author ho;	state Exp;
branches;
next	1.77;

1.77
date	2002.09.11.09.50.44;	author ho;	state Exp;
branches;
next	1.76;

1.76
date	2002.09.05.15.47.22;	author ho;	state Exp;
branches;
next	1.75;

1.75
date	2002.08.29.12.13.19;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2002.08.07.13.19.20;	author ho;	state Exp;
branches;
next	1.73;

1.73
date	2002.08.02.13.10.41;	author ho;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.10.20.45.35;	author ho;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.10.18.08.59;	author ho;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.01.07.44.22;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2002.03.06.10.02.32;	author ho;	state Exp;
branches;
next	1.68;

1.68
date	2002.01.23.18.44.48;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2002.01.23.17.26.21;	author ho;	state Exp;
branches;
next	1.66;

1.66
date	2002.01.03.09.24.02;	author ho;	state Exp;
branches;
next	1.65;

1.65
date	2001.08.25.22.17.13;	author niklas;	state Exp;
branches;
next	1.64;

1.64
date	2001.08.16.14.23.21;	author ho;	state Exp;
branches;
next	1.63;

1.63
date	2001.07.13.14.16.39;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2001.07.05.12.37.00;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.05.07.28.00;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2001.07.05.07.16.52;	author angelos;	state Exp;
branches;
next	1.59;

1.59
date	2001.07.01.19.48.44;	author niklas;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.22.16.21.43;	author provos;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.07.07.35.15;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.07.04.46.45;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.07.04.23.35;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.05.10.11.42;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.05.06.51.05;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.05.05.59.43;	author niklas;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.31.20.20.59;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.12.06.46.58;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.12.15.50.02;	author ho;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.09.22.09.53;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2001.04.03.13.59.12;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.27.16.50.35;	author ho;	state Exp;
branches;
next	1.45;

1.45
date	2001.03.14.21.13.24;	author tholo;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.14.12.15.46;	author niklas;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.13.14.05.19;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.23.15.29.55;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.18.23.16.14;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.08.22.37.45;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.27.12.03.36;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.26.16.40.52;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.26.11.09.12;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.10.20.31.24;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.19.19.03.06;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2000.12.12.01.46.39;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.02.02.10.58;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.30.06.36.37;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.23.12.57.07;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.07.07.00.34;	author niklas;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2000.06.08.20.51.21;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.07.22.04.16;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.08.08.42.15;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.25.17.23.42;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.19.19.31.33;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.11.10.21.54;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.07.01.32.54;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.01.02.46.19;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.31.08.38.29;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.31.08.18.41;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.27.08.49.24;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.27.08.43.06;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.26.15.24.52;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.10.26.22.32.28;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	99.10.01.14.08.40;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.08.26.22.28.15;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.07.17.21.54.39;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.07.07.22.15.42;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.06.05.19.04.32;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.06.05.18.01.42;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.04.19.19.57.29;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.03.24.15.00.36;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.02.26.03.53.16;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.11.17.11.10.22;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.11.16.21.07.18;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.15.00.52.26;	author niklas;	state dead;
branches;
next	1.2;

1.2
date	98.11.15.00.44.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.29.2.1
date	2000.12.11.05.25.41;	author jason;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2001.05.08.12.45.26;	author ho;	state Exp;
branches;
next	;

1.105.2.1
date	2007.04.06.08.07.05;	author mbalmer;	state Exp;
branches;
next	;

1.106.2.1
date	2007.04.06.08.07.19;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.118
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/* $OpenBSD: x509.c,v 1.117 2014/05/01 07:35:57 jsg Exp $	 */
/* $EOM: x509.c,v 1.54 2001/01/16 18:42:16 ho Exp $	 */

/*
 * Copyright (c) 1998, 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include <regex.h>
#include <keynote.h>

#include "cert.h"
#include "conf.h"
#include "exchange.h"
#include "hash.h"
#include "ike_auth.h"
#include "ipsec.h"
#include "log.h"
#include "dh.h"
#include "monitor.h"
#include "policy.h"
#include "sa.h"
#include "util.h"
#include "x509.h"

static u_int16_t x509_hash(u_int8_t *, size_t);
static void	 x509_hash_init(void);
static X509	*x509_hash_find(u_int8_t *, size_t);
static int	 x509_hash_enter(X509 *);

/*
 * X509_STOREs do not support subjectAltNames, so we have to build
 * our own hash table.
 */

/*
 * XXX Actually this store is not really useful, we never use it as we have
 * our own hash table.  It also gets collisions if we have several certificates
 * only differing in subjectAltName.
 */
static X509_STORE *x509_certs = 0;
static X509_STORE *x509_cas = 0;

static int n_x509_cas = 0;

/* Initial number of bits used as hash.  */
#define INITIAL_BUCKET_BITS 6

struct x509_hash {
	LIST_ENTRY(x509_hash) link;

	X509		*cert;
};

static LIST_HEAD(x509_list, x509_hash) *x509_tab = 0;

/* Works both as a maximum index and a mask.  */
static int	bucket_mask;

/*
 * Given an X509 certificate, create a KeyNote assertion where
 * Issuer/Subject -> Authorizer/Licensees.
 * XXX RSA-specific.
 */
int
x509_generate_kn(int id, X509 *cert)
{
	static const char fmt[] = "Authorizer: \"rsa-hex:%s\"\nLicensees: \"rsa-hex:%s"
		    "\"\nConditions: %s >= \"%s\" && %s <= \"%s\";\n";
	char	*ikey = NULL, *skey = NULL, *buf = NULL;
	char	isname[256], subname[256];
	static const char fmt2[] = "Authorizer: \"DN:%s\"\nLicensees: \"DN:%s\"\n"
		    "Conditions: %s >= \"%s\" && %s <= \"%s\";\n";
	X509_NAME *issuer, *subject;
	struct keynote_deckey dc;
	X509_STORE_CTX csc;
	X509_OBJECT obj;
	X509	*icert;
	RSA	*key = NULL;
	time_t	tt;
	char	before[15], after[15], *timecomp, *timecomp2;
	ASN1_TIME *tm;
	int	i;

	LOG_DBG((LOG_POLICY, 90,
	    "x509_generate_kn: generating KeyNote policy for certificate %p",
	    cert));

	issuer = X509_get_issuer_name(cert);
	subject = X509_get_subject_name(cert);

	/* Missing or self-signed, ignore cert but don't report failure.  */
	if (!issuer || !subject || !X509_name_cmp(issuer, subject))
		return 1;

	if (!x509_cert_get_key(cert, &key)) {
		LOG_DBG((LOG_POLICY, 30,
		    "x509_generate_kn: failed to get public key from cert"));
		return 0;
	}
	dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
	dc.dec_key = key;
	ikey = kn_encode_key(&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
	    KEYNOTE_PUBLIC_KEY);
	if (keynote_errno == ERROR_MEMORY) {
		log_print("x509_generate_kn: failed to get memory for "
		    "public key");
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: cannot get "
		    "subject key"));
		goto fail;
	}
	if (!ikey) {
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: cannot get "
		    "subject key"));
		goto fail;
	}

	RSA_free(key);
	key = NULL;

	/* Now find issuer's certificate so we can get the public key.  */
	X509_STORE_CTX_init(&csc, x509_cas, cert, NULL);
	if (X509_STORE_get_by_subject(&csc, X509_LU_X509, issuer, &obj) !=
	    X509_LU_X509) {
		X509_STORE_CTX_cleanup(&csc);
		X509_STORE_CTX_init(&csc, x509_certs, cert, NULL);
		if (X509_STORE_get_by_subject(&csc, X509_LU_X509, issuer, &obj)
		    != X509_LU_X509) {
			X509_STORE_CTX_cleanup(&csc);
			LOG_DBG((LOG_POLICY, 30,
			    "x509_generate_kn: no certificate found for "
			    "issuer"));
			goto fail;
		}
	}
	X509_STORE_CTX_cleanup(&csc);
	icert = obj.data.x509;

	if (icert == NULL) {
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: "
		    "missing certificates, cannot construct X509 chain"));
		goto fail;
	}
	if (!x509_cert_get_key(icert, &key)) {
		LOG_DBG((LOG_POLICY, 30,
		    "x509_generate_kn: failed to get public key from cert"));
		goto fail;
	}
	X509_OBJECT_free_contents(&obj);

	dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
	dc.dec_key = key;
	skey = kn_encode_key(&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
	    KEYNOTE_PUBLIC_KEY);
	if (keynote_errno == ERROR_MEMORY) {
		log_error("x509_generate_kn: failed to get memory for public "
		    "key");
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: cannot get issuer "
		    "key"));
		goto fail;
	}
	if (!skey) {
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: cannot get issuer "
		    "key"));
		goto fail;
	}

	RSA_free(key);
	key = NULL;

	if (((tm = X509_get_notBefore(cert)) == NULL) ||
	    (tm->type != V_ASN1_UTCTIME &&
		tm->type != V_ASN1_GENERALIZEDTIME)) {
		tt = time(0);
		strftime(before, 14, "%Y%m%d%H%M%S", localtime(&tt));
		timecomp = "LocalTimeOfDay";
	} else {
		if (tm->data[tm->length - 1] == 'Z') {
			timecomp = "GMTTimeOfDay";
			i = tm->length - 2;
		} else {
			timecomp = "LocalTimeOfDay";
			i = tm->length - 1;
		}

		for (; i >= 0; i--) {
			if (tm->data[i] < '0' || tm->data[i] > '9') {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid data in "
				    "NotValidBefore time field"));
				goto fail;
			}
		}

		if (tm->type == V_ASN1_UTCTIME) {
			if ((tm->length < 10) || (tm->length > 13)) {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid length "
				    "of NotValidBefore time field (%d)",
				    tm->length));
				goto fail;
			}
			/* Validity checks.  */
			if ((tm->data[2] != '0' && tm->data[2] != '1') ||
			    (tm->data[2] == '0' && tm->data[3] == '0') ||
			    (tm->data[2] == '1' && tm->data[3] > '2') ||
			    (tm->data[4] > '3') ||
			    (tm->data[4] == '0' && tm->data[5] == '0') ||
			    (tm->data[4] == '3' && tm->data[5] > '1') ||
			    (tm->data[6] > '2') ||
			    (tm->data[6] == '2' && tm->data[7] > '3') ||
			    (tm->data[8] > '5')) {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid value in "
				    "NotValidBefore time field"));
				goto fail;
			}
			/* Stupid UTC tricks.  */
			if (tm->data[0] < '5')
				snprintf(before, sizeof before, "20%s",
				    tm->data);
			else
				snprintf(before, sizeof before, "19%s",
				    tm->data);
		} else {	/* V_ASN1_GENERICTIME */
			if ((tm->length < 12) || (tm->length > 15)) {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid length of "
				    "NotValidBefore time field (%d)",
				    tm->length));
				goto fail;
			}
			/* Validity checks.  */
			if ((tm->data[4] != '0' && tm->data[4] != '1') ||
			    (tm->data[4] == '0' && tm->data[5] == '0') ||
			    (tm->data[4] == '1' && tm->data[5] > '2') ||
			    (tm->data[6] > '3') ||
			    (tm->data[6] == '0' && tm->data[7] == '0') ||
			    (tm->data[6] == '3' && tm->data[7] > '1') ||
			    (tm->data[8] > '2') ||
			    (tm->data[8] == '2' && tm->data[9] > '3') ||
			    (tm->data[10] > '5')) {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid value in "
				    "NotValidBefore time field"));
				goto fail;
			}
			snprintf(before, sizeof before, "%s", tm->data);
		}

		/* Fix missing seconds.  */
		if (tm->length < 12) {
			before[12] = '0';
			before[13] = '0';
		}
		/* This will overwrite trailing 'Z'.  */
		before[14] = '\0';
	}

	tm = X509_get_notAfter(cert);
	if (tm == NULL ||
	    (tm->type != V_ASN1_UTCTIME &&
		tm->type != V_ASN1_GENERALIZEDTIME)) {
		tt = time(0);
		strftime(after, 14, "%Y%m%d%H%M%S", localtime(&tt));
		timecomp2 = "LocalTimeOfDay";
	} else {
		if (tm->data[tm->length - 1] == 'Z') {
			timecomp2 = "GMTTimeOfDay";
			i = tm->length - 2;
		} else {
			timecomp2 = "LocalTimeOfDay";
			i = tm->length - 1;
		}

		for (; i >= 0; i--) {
			if (tm->data[i] < '0' || tm->data[i] > '9') {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid data in "
				    "NotValidAfter time field"));
				goto fail;
			}
		}

		if (tm->type == V_ASN1_UTCTIME) {
			if ((tm->length < 10) || (tm->length > 13)) {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid length of "
				    "NotValidAfter time field (%d)",
				    tm->length));
				goto fail;
			}
			/* Validity checks. */
			if ((tm->data[2] != '0' && tm->data[2] != '1') ||
			    (tm->data[2] == '0' && tm->data[3] == '0') ||
			    (tm->data[2] == '1' && tm->data[3] > '2') ||
			    (tm->data[4] > '3') ||
			    (tm->data[4] == '0' && tm->data[5] == '0') ||
			    (tm->data[4] == '3' && tm->data[5] > '1') ||
			    (tm->data[6] > '2') ||
			    (tm->data[6] == '2' && tm->data[7] > '3') ||
			    (tm->data[8] > '5')) {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid value in "
				    "NotValidAfter time field"));
				goto fail;
			}
			/* Stupid UTC tricks.  */
			if (tm->data[0] < '5')
				snprintf(after, sizeof after, "20%s",
				    tm->data);
			else
				snprintf(after, sizeof after, "19%s",
				    tm->data);
		} else {	/* V_ASN1_GENERICTIME */
			if ((tm->length < 12) || (tm->length > 15)) {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid length of "
				    "NotValidAfter time field (%d)",
				    tm->length));
				goto fail;
			}
			/* Validity checks.  */
			if ((tm->data[4] != '0' && tm->data[4] != '1') ||
			    (tm->data[4] == '0' && tm->data[5] == '0') ||
			    (tm->data[4] == '1' && tm->data[5] > '2') ||
			    (tm->data[6] > '3') ||
			    (tm->data[6] == '0' && tm->data[7] == '0') ||
			    (tm->data[6] == '3' && tm->data[7] > '1') ||
			    (tm->data[8] > '2') ||
			    (tm->data[8] == '2' && tm->data[9] > '3') ||
			    (tm->data[10] > '5')) {
				LOG_DBG((LOG_POLICY, 30,
				    "x509_generate_kn: invalid value in "
				    "NotValidAfter time field"));
				goto fail;
			}
			snprintf(after, sizeof after, "%s", tm->data);
		}

		/* Fix missing seconds.  */
		if (tm->length < 12) {
			after[12] = '0';
			after[13] = '0';
		}
		after[14] = '\0';	/* This will overwrite trailing 'Z' */
	}

	if (asprintf(&buf, fmt, skey, ikey, timecomp, before, timecomp2,
	    after) == -1) {
		log_error("x509_generate_kn: "
		    "failed to allocate memory for KeyNote credential");
		goto fail;
	}
	
	free(ikey);
	ikey = NULL;
	free(skey);
	skey = NULL;

	if (kn_add_assertion(id, buf, strlen(buf), ASSERT_FLAG_LOCAL) == -1) {
		LOG_DBG((LOG_POLICY, 30,
		    "x509_generate_kn: failed to add new KeyNote credential"));
		goto fail;
	}
	/* We could print the assertion here, but log_print() truncates...  */
	LOG_DBG((LOG_POLICY, 60, "x509_generate_kn: added credential"));

	free(buf);
	buf = NULL;

	if (!X509_NAME_oneline(issuer, isname, 256)) {
		LOG_DBG((LOG_POLICY, 50,
		    "x509_generate_kn: "
		    "X509_NAME_oneline (issuer, ...) failed"));
		goto fail;
	}
	if (!X509_NAME_oneline(subject, subname, 256)) {
		LOG_DBG((LOG_POLICY, 50,
		    "x509_generate_kn: "
		    "X509_NAME_oneline (subject, ...) failed"));
		goto fail;
	}
	if (asprintf(&buf, fmt2, isname, subname, timecomp, before,
	    timecomp2, after) == -1) {
		log_error("x509_generate_kn: malloc failed");
		return 0;
	}

	if (kn_add_assertion(id, buf, strlen(buf), ASSERT_FLAG_LOCAL) == -1) {
		LOG_DBG((LOG_POLICY, 30,
		    "x509_generate_kn: failed to add new KeyNote credential"));
		goto fail;
	}
	LOG_DBG((LOG_POLICY, 80, "x509_generate_kn: added credential:\n%s",
	    buf));

	free(buf);
	return 1;

fail:
	free(buf);
	free(skey);
	free(ikey);
	if (key)
		RSA_free(key);

	return 0;
}

static u_int16_t
x509_hash(u_int8_t *id, size_t len)
{
	u_int16_t bucket = 0;
	size_t	i;

	/* XXX We might resize if we are crossing a certain threshold.  */
	for (i = 4; i < (len & ~1); i += 2) {
		/* Doing it this way avoids alignment problems.  */
		bucket ^= (id[i] + 1) * (id[i + 1] + 257);
	}
	/* Hash in the last character of odd length IDs too.  */
	if (i < len)
		bucket ^= (id[i] + 1) * (id[i] + 257);

	bucket &= bucket_mask;
	return bucket;
}

static void
x509_hash_init(void)
{
	struct x509_hash *certh;
	int	i;

	bucket_mask = (1 << INITIAL_BUCKET_BITS) - 1;

	/* If reinitializing, free existing entries.  */
	if (x509_tab) {
		for (i = 0; i <= bucket_mask; i++)
			for (certh = LIST_FIRST(&x509_tab[i]); certh;
			    certh = LIST_FIRST(&x509_tab[i])) {
				LIST_REMOVE(certh, link);
				free(certh);
			}
		free(x509_tab);
	}
	x509_tab = calloc(bucket_mask + 1, sizeof(struct x509_list));
	if (!x509_tab)
		log_fatal("x509_hash_init: malloc (%lu) failed",
		    (bucket_mask + 1) *
		    (unsigned long)sizeof(struct x509_list));
	for (i = 0; i <= bucket_mask; i++) {
		LIST_INIT(&x509_tab[i]);
	}
}

/* Lookup a certificate by an ID blob.  */
static X509 *
x509_hash_find(u_int8_t *id, size_t len)
{
	struct x509_hash *cert;
	u_int8_t	**cid;
	u_int32_t	*clen;
	int	n, i, id_found;

	for (cert = LIST_FIRST(&x509_tab[x509_hash(id, len)]); cert;
	    cert = LIST_NEXT(cert, link)) {
		if (!x509_cert_get_subjects(cert->cert, &n, &cid, &clen))
			continue;

		id_found = 0;
		for (i = 0; i < n; i++) {
			LOG_DBG_BUF((LOG_CRYPTO, 70, "cert_cmp", id, len));
			LOG_DBG_BUF((LOG_CRYPTO, 70, "cert_cmp", cid[i],
			    clen[i]));
			/*
			 * XXX This identity predicate needs to be
			 * understood.
			 */
			if (clen[i] == len && id[0] == cid[i][0] &&
			    memcmp(id + 4, cid[i] + 4, len - 4) == 0) {
				id_found++;
				break;
			}
		}
		cert_free_subjects(n, cid, clen);
		if (!id_found)
			continue;

		LOG_DBG((LOG_CRYPTO, 70, "x509_hash_find: return X509 %p",
		    cert->cert));
		return cert->cert;
	}

	LOG_DBG((LOG_CRYPTO, 70,
	    "x509_hash_find: no certificate matched query"));
	return 0;
}

static int
x509_hash_enter(X509 *cert)
{
	u_int16_t	bucket = 0;
	u_int8_t	**id;
	u_int32_t	*len;
	struct x509_hash *certh;
	int	n, i;

	if (!x509_cert_get_subjects(cert, &n, &id, &len)) {
		log_print("x509_hash_enter: cannot retrieve subjects");
		return 0;
	}
	for (i = 0; i < n; i++) {
		certh = calloc(1, sizeof *certh);
		if (!certh) {
			cert_free_subjects(n, id, len);
			log_error("x509_hash_enter: calloc (1, %lu) failed",
			    (unsigned long)sizeof *certh);
			return 0;
		}
		certh->cert = cert;

		bucket = x509_hash(id[i], len[i]);

		LIST_INSERT_HEAD(&x509_tab[bucket], certh, link);
		LOG_DBG((LOG_CRYPTO, 70,
		    "x509_hash_enter: cert %p added to bucket %d",
		    cert, bucket));
	}
	cert_free_subjects(n, id, len);

	return 1;
}

/* X509 Certificate Handling functions.  */

int
x509_read_from_dir(X509_STORE *ctx, char *name, int hash, int *pcount)
{
	FILE		*certfp;
	X509		*cert;
	struct stat	sb;
	char		fullname[PATH_MAX];
	char		file[PATH_MAX];
	int		fd;

	if (strlen(name) >= sizeof fullname - 1) {
		log_print("x509_read_from_dir: directory name too long");
		return 0;
	}
	LOG_DBG((LOG_CRYPTO, 40, "x509_read_from_dir: reading certs from %s",
	    name));

	if (monitor_req_readdir(name) == -1) {
		LOG_DBG((LOG_CRYPTO, 10,
		    "x509_read_from_dir: opendir (\"%s\") failed: %s",
		    name, strerror(errno)));
		return 0;
	}

	while ((fd = monitor_readdir(file, sizeof file)) != -1) {
		LOG_DBG((LOG_CRYPTO, 60,
		    "x509_read_from_dir: reading certificate %s",
		    file));

		if (fstat(fd, &sb) == -1) {
			log_error("x509_read_from_dir: fstat failed");
			close(fd);
			continue;
		}

		if (!S_ISREG(sb.st_mode)) {
			close(fd);
			continue;
		}

		if ((certfp = fdopen(fd, "r")) == NULL) {
			log_error("x509_read_from_dir: fdopen failed");
			close(fd);
			continue;
		}

#if SSLEAY_VERSION_NUMBER >= 0x00904100L
		cert = PEM_read_X509(certfp, NULL, NULL, NULL);
#else
		cert = PEM_read_X509(certfp, NULL, NULL);
#endif
		fclose(certfp);

		if (cert == NULL) {
			log_print("x509_read_from_dir: PEM_read_X509 "
			    "failed for %s", file);
			continue;
		}

		if (pcount != NULL)
			(*pcount)++;

		if (!X509_STORE_add_cert(ctx, cert)) {
			/*
			 * This is actually expected if we have several
			 * certificates only differing in subjectAltName,
			 * which is not an something that is strange.
			 * Consider multi-homed machines.
			*/
			LOG_DBG((LOG_CRYPTO, 50,
			    "x509_read_from_dir: X509_STORE_add_cert failed "
			    "for %s", file));
		}
		if (hash)
			if (!x509_hash_enter(cert))
				log_print("x509_read_from_dir: "
				    "x509_hash_enter (%s) failed",
				    file);
	}

	return 1;
}

/* XXX share code with x509_read_from_dir() ?  */
int
x509_read_crls_from_dir(X509_STORE *ctx, char *name)
{
#if OPENSSL_VERSION_NUMBER >= 0x00907000L
	FILE		*crlfp;
	X509_CRL	*crl;
	struct stat	sb;
	char		fullname[PATH_MAX];
	char		file[PATH_MAX];
	int		fd, off, size;

	if (strlen(name) >= sizeof fullname - 1) {
		log_print("x509_read_crls_from_dir: directory name too long");
		return 0;
	}
	LOG_DBG((LOG_CRYPTO, 40, "x509_read_crls_from_dir: reading CRLs "
	    "from %s", name));

	if (monitor_req_readdir(name) == -1) {
		LOG_DBG((LOG_CRYPTO, 10, "x509_read_crls_from_dir: opendir "
		    "(\"%s\") failed: %s", name, strerror(errno)));
		return 0;
	}
	strlcpy(fullname, name, sizeof fullname);
	off = strlen(fullname);
	size = sizeof fullname - off;

	while ((fd = monitor_readdir(file, sizeof file)) != -1) {
		LOG_DBG((LOG_CRYPTO, 60, "x509_read_crls_from_dir: reading "
		    "CRL %s", file));

		if (fstat(fd, &sb) == -1) {
			log_error("x509_read_crls_from_dir: fstat failed");
			close(fd);
			continue;
		}

		if (!S_ISREG(sb.st_mode)) {
			close(fd);
			continue;
		}

		if ((crlfp = fdopen(fd, "r")) == NULL) {
			log_error("x509_read_crls_from_dir: fdopen failed");
			close(fd);
			continue;
		}

		crl = PEM_read_X509_CRL(crlfp, NULL, NULL, NULL);

		fclose(crlfp);

		if (crl == NULL) {
			log_print("x509_read_crls_from_dir: "
			    "PEM_read_X509_CRL failed for %s",
			    file);
			continue;
		}
		if (!X509_STORE_add_crl(ctx, crl)) {
			LOG_DBG((LOG_CRYPTO, 50, "x509_read_crls_from_dir: "
			    "X509_STORE_add_crl failed for %s", file));
			continue;
		}
		/*
		 * XXX This is to make x509_cert_validate set this (and
		 * XXX another) flag when validating certificates. Currently,
		 * XXX OpenSSL defaults to reject an otherwise valid
		 * XXX certificate (chain) if these flags are set but there
		 * XXX are no CRLs to check. The current workaround is to only
		 * XXX set the flags if we actually loaded some CRL data.
		 */
		X509_STORE_set_flags(ctx, X509_V_FLAG_CRL_CHECK);
	}

#endif				/* OPENSSL_VERSION_NUMBER >= 0x00907000L */

	return 1;
}

/* Initialize our databases and load our own certificates.  */
int
x509_cert_init(void)
{
	char	*dirname;

	x509_hash_init();

	/* Process CA certificates we will trust.  */
	dirname = conf_get_str("X509-certificates", "CA-directory");
	if (!dirname) {
		log_print("x509_cert_init: no CA-directory");
		return 0;
	}
	/* Free if already initialized.  */
	if (x509_cas)
		X509_STORE_free(x509_cas);

	x509_cas = X509_STORE_new();
	if (!x509_cas) {
		log_print("x509_cert_init: creating new X509_STORE failed");
		return 0;
	}
	if (!x509_read_from_dir(x509_cas, dirname, 0, &n_x509_cas)) {
		log_print("x509_cert_init: x509_read_from_dir failed");
		return 0;
	}
	/* Process client certificates we will accept.  */
	dirname = conf_get_str("X509-certificates", "Cert-directory");
	if (!dirname) {
		log_print("x509_cert_init: no Cert-directory");
		return 0;
	}
	/* Free if already initialized.  */
	if (x509_certs)
		X509_STORE_free(x509_certs);

	x509_certs = X509_STORE_new();
	if (!x509_certs) {
		log_print("x509_cert_init: creating new X509_STORE failed");
		return 0;
	}
	if (!x509_read_from_dir(x509_certs, dirname, 1, NULL)) {
		log_print("x509_cert_init: x509_read_from_dir failed");
		return 0;
	}
	return 1;
}

int
x509_crl_init(void)
{
	/*
	 * XXX I'm not sure if the method to use CRLs in certificate validation
	 * is valid for OpenSSL versions prior to 0.9.7. For now, simply do not
	 * support it.
	 */
#if OPENSSL_VERSION_NUMBER >= 0x00907000L
	char	*dirname;
	dirname = conf_get_str("X509-certificates", "CRL-directory");
	if (!dirname) {
		log_print("x509_crl_init: no CRL-directory");
		return 0;
	}
	if (!x509_read_crls_from_dir(x509_cas, dirname)) {
		LOG_DBG((LOG_MISC, 10,
		    "x509_crl_init: x509_read_crls_from_dir failed"));
		return 0;
	}
#else
	LOG_DBG((LOG_CRYPTO, 10, "x509_crl_init: CRL support only "
	    "with OpenSSL v0.9.7 or later"));
#endif

	return 1;
}

void *
x509_cert_get(u_int8_t *asn, u_int32_t len)
{
	return x509_from_asn(asn, len);
}

int
x509_cert_validate(void *scert)
{
	X509_STORE_CTX	csc;
	X509_NAME	*issuer, *subject;
	X509		*cert = (X509 *) scert;
	EVP_PKEY	*key;
	int		res, err;

	/*
	 * Validate the peer certificate by checking with the CA certificates
	 * we trust.
	 */
	X509_STORE_CTX_init(&csc, x509_cas, cert, NULL);
#if OPENSSL_VERSION_NUMBER >= 0x00908000L
	/* XXX See comment in x509_read_crls_from_dir.  */
	if (x509_cas->param->flags & X509_V_FLAG_CRL_CHECK) {
		X509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK);
		X509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK_ALL);
	}
#elif OPENSSL_VERSION_NUMBER >= 0x00907000L
	/* XXX See comment in x509_read_crls_from_dir.  */
	if (x509_cas->flags & X509_V_FLAG_CRL_CHECK) {
		X509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK);
		X509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK_ALL);
	}
#endif
	res = X509_verify_cert(&csc);
	err = csc.error;
	X509_STORE_CTX_cleanup(&csc);

	/*
	 * Return if validation succeeded or self-signed certs are not
	 * accepted.
	 *
	 * XXX X509_verify_cert seems to return -1 if the validation should be
	 * retried somehow.  We take this as an error and give up.
	 */
	if (res > 0)
		return 1;
	else if (res < 0 ||
	    (res == 0 && err != X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)) {
		if (err)
			log_print("x509_cert_validate: %.100s",
			    X509_verify_cert_error_string(err));
		return 0;
	} else if (!conf_get_str("X509-certificates", "Accept-self-signed")) {
		if (err)
			log_print("x509_cert_validate: %.100s",
			    X509_verify_cert_error_string(err));
		return 0;
	}
	issuer = X509_get_issuer_name(cert);
	subject = X509_get_subject_name(cert);

	if (!issuer || !subject || X509_name_cmp(issuer, subject))
		return 0;

	key = X509_get_pubkey(cert);
	if (!key) {
		log_print("x509_cert_validate: could not get public key from "
		    "self-signed cert");
		return 0;
	}
	if (X509_verify(cert, key) == -1) {
		log_print("x509_cert_validate: self-signed cert is bad");
		return 0;
	}
	return 1;
}

int
x509_cert_insert(int id, void *scert)
{
	X509	*cert;
	int	 res;

	cert = X509_dup((X509 *)scert);
	if (!cert) {
		log_print("x509_cert_insert: X509_dup failed");
		return 0;
	}
	if (x509_generate_kn(id, cert) == 0) {
		LOG_DBG((LOG_POLICY, 50,
		    "x509_cert_insert: x509_generate_kn failed"));
		X509_free(cert);
		return 0;
	}

	res = x509_hash_enter(cert);
	if (!res)
		X509_free(cert);

	return res;
}

static struct x509_hash *
x509_hash_lookup(X509 *cert)
{
	struct x509_hash *certh;
	int	i;

	for (i = 0; i <= bucket_mask; i++)
		for (certh = LIST_FIRST(&x509_tab[i]); certh;
		    certh = LIST_NEXT(certh, link))
			if (certh->cert == cert)
				return certh;
	return 0;
}

void
x509_cert_free(void *cert)
{
	struct x509_hash *certh = x509_hash_lookup((X509 *) cert);

	if (certh)
		LIST_REMOVE(certh, link);
	X509_free((X509 *) cert);
}

/* Validate the BER Encoding of a RDNSequence in the CERT_REQ payload.  */
int
x509_certreq_validate(u_int8_t *asn, u_int32_t len)
{
	int	res = 1;
#if 0
	struct norm_type name = SEQOF("issuer", RDNSequence);

	if (!asn_template_clone(&name, 1) ||
	    (asn = asn_decode_sequence(asn, len, &name)) == 0) {
		log_print("x509_certreq_validate: can not decode 'acceptable "
		    "CA' info");
		res = 0;
	}
	asn_free(&name);
#endif

	/* XXX - not supported directly in SSL - later.  */

	return res;
}

/* Decode the BER Encoding of a RDNSequence in the CERT_REQ payload.  */
int
x509_certreq_decode(void **pdata, u_int8_t *asn, u_int32_t len)
{
#if 0
	/* XXX This needs to be done later.  */
	struct norm_type aca = SEQOF("aca", RDNSequence);
	struct norm_type *tmp;
	struct x509_aca naca, *ret;

	if (!asn_template_clone(&aca, 1) ||
	    (asn = asn_decode_sequence(asn, len, &aca)) == 0) {
		log_print("x509_certreq_decode: can not decode 'acceptable "
		    "CA' info");
		goto fail;
	}
	bzero(&naca, sizeof(naca));

	tmp = asn_decompose("aca.RelativeDistinguishedName."
	    "AttributeValueAssertion", &aca);
	if (!tmp)
		goto fail;
	x509_get_attribval(tmp, &naca.name1);

	tmp = asn_decompose("aca.RelativeDistinguishedName[1]"
	    ".AttributeValueAssertion", &aca);
	if (tmp)
		x509_get_attribval(tmp, &naca.name2);

	asn_free(&aca);

	ret = malloc(sizeof(struct x509_aca));
	if (ret)
		memcpy(ret, &naca, sizeof(struct x509_aca));
	else {
		log_error("x509_certreq_decode: malloc (%lu) failed",
		    (unsigned long) sizeof(struct x509_aca));
		x509_free_aca(&aca);
	}

	return ret;

fail:
	asn_free(&aca);
#endif
	return 1;
}

void
x509_free_aca(void *blob)
{
	struct x509_aca *aca = blob;

	if (aca != NULL) {
		free(aca->name1.type);
		free(aca->name1.val);

		free(aca->name2.type);
		free(aca->name2.val);
	}
}

X509 *
x509_from_asn(u_char *asn, u_int len)
{
	BIO		*certh;
	X509		*scert = 0;

	certh = BIO_new(BIO_s_mem());
	if (!certh) {
		log_error("x509_from_asn: BIO_new (BIO_s_mem ()) failed");
		return 0;
	}
	if (BIO_write(certh, asn, len) == -1) {
		log_error("x509_from_asn: BIO_write failed\n");
		goto end;
	}
	scert = d2i_X509_bio(certh, NULL);
	if (!scert) {
		log_print("x509_from_asn: d2i_X509_bio failed\n");
		goto end;
	}
end:
	BIO_free(certh);
	return scert;
}

/*
 * Obtain a certificate from an acceptable CA.
 * XXX We don't check if the certificate we find is from an accepted CA.
 */
int
x509_cert_obtain(u_int8_t *id, size_t id_len, void *data, u_int8_t **cert,
    u_int32_t *certlen)
{
	struct x509_aca *aca = data;
	X509		*scert;

	if (aca)
		LOG_DBG((LOG_CRYPTO, 60, "x509_cert_obtain: "
		    "acceptable certificate authorities here"));

	/* We need our ID to find a certificate.  */
	if (!id) {
		log_print("x509_cert_obtain: ID is missing");
		return 0;
	}
	scert = x509_hash_find(id, id_len);
	if (!scert)
		return 0;

	x509_serialize(scert, cert, certlen);
	if (!*cert)
		return 0;
	return 1;
}

/* Returns a pointer to the subjectAltName information of X509 certificate.  */
int
x509_cert_subjectaltname(X509 *scert, u_int8_t **altname, u_int32_t *len)
{
	X509_EXTENSION	*subjectaltname;
	u_int8_t	*sandata;
	int		extpos, santype, sanlen;

	extpos = X509_get_ext_by_NID(scert, NID_subject_alt_name, -1);
	if (extpos == -1) {
		log_print("x509_cert_subjectaltname: "
		    "certificate does not contain subjectAltName");
		return 0;
	}
	subjectaltname = X509_get_ext(scert, extpos);

	if (!subjectaltname || !subjectaltname->value ||
	    !subjectaltname->value->data ||
	    subjectaltname->value->length < 4) {
		log_print("x509_cert_subjectaltname: invalid "
		    "subjectaltname extension");
		return 0;
	}
	/* SSL does not handle unknown ASN stuff well, do it by hand.  */
	sandata = subjectaltname->value->data;
	santype = sandata[2] & 0x3f;
	sanlen = sandata[3];
	sandata += 4;

	/*
	 * The test here used to be !=, but some certificates can include
	 * extra stuff in subjectAltName, so we will just take the first
	 * salen bytes, and not worry about what follows.
	 */
	if (sanlen + 4 > subjectaltname->value->length) {
		log_print("x509_cert_subjectaltname: subjectaltname invalid "
		    "length");
		return 0;
	}
	*len = sanlen;
	*altname = sandata;
	return santype;
}

int
x509_cert_get_subjects(void *scert, int *cnt, u_int8_t ***id,
    u_int32_t **id_len)
{
	X509		*cert = scert;
	X509_NAME	*subject;
	int		type;
	u_int8_t	*altname;
	u_int32_t	altlen;
	u_int8_t	*buf = 0;
	unsigned char	*ubuf;
	int		i;

	*id = 0;
	*id_len = 0;

	/*
	 * XXX There can be a collection of subjectAltNames, but for now I
	 * only return the subjectName and a single subjectAltName, if
	 * present.
	 */
	type = x509_cert_subjectaltname(cert, &altname, &altlen);
	if (!type) {
		*cnt = 1;
		altlen = 0;
	} else
		*cnt = 2;

	*id = calloc(*cnt, sizeof **id);
	if (!*id) {
		log_print("x509_cert_get_subject: malloc (%lu) failed",
		    *cnt * (unsigned long)sizeof **id);
		*cnt = 0;
		goto fail;
	}
	*id_len = calloc(*cnt, sizeof **id_len);
	if (!*id_len) {
		log_print("x509_cert_get_subject: malloc (%lu) failed",
		    *cnt * (unsigned long)sizeof **id_len);
		goto fail;
	}
	/* Stash the subjectName into the first slot.  */
	subject = X509_get_subject_name(cert);
	if (!subject)
		goto fail;

	(*id_len)[0] =
		ISAKMP_ID_DATA_OFF + i2d_X509_NAME(subject, NULL) -
		    ISAKMP_GEN_SZ;
	(*id)[0] = malloc((*id_len)[0]);
	if (!(*id)[0]) {
		log_print("x509_cert_get_subject: malloc (%d) failed",
		    (*id_len)[0]);
		goto fail;
	}
	SET_ISAKMP_ID_TYPE((*id)[0] - ISAKMP_GEN_SZ, IPSEC_ID_DER_ASN1_DN);
	ubuf = (*id)[0] + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
	i2d_X509_NAME(subject, &ubuf);

	if (altlen) {
		/* Stash the subjectAltName into the second slot.  */
		buf = malloc(altlen + ISAKMP_ID_DATA_OFF);
		if (!buf) {
			log_print("x509_cert_get_subject: malloc (%d) failed",
			    altlen + ISAKMP_ID_DATA_OFF);
			goto fail;
		}
		switch (type) {
		case X509v3_DNS_NAME:
			SET_ISAKMP_ID_TYPE(buf, IPSEC_ID_FQDN);
			break;

		case X509v3_RFC_NAME:
			SET_ISAKMP_ID_TYPE(buf, IPSEC_ID_USER_FQDN);
			break;

		case X509v3_IP_ADDR:
			/*
			 * XXX I dislike the numeric constants, but I don't
			 * know what we should use otherwise.
			 */
			switch (altlen) {
			case 4:
				SET_ISAKMP_ID_TYPE(buf, IPSEC_ID_IPV4_ADDR);
				break;

			case 16:
				SET_ISAKMP_ID_TYPE(buf, IPSEC_ID_IPV6_ADDR);
				break;

			default:
				log_print("x509_cert_get_subject: invalid "
				    "subjectAltName IPaddress length %d ",
				    altlen);
				goto fail;
			}
			break;
		}

		SET_IPSEC_ID_PROTO(buf + ISAKMP_ID_DOI_DATA_OFF, 0);
		SET_IPSEC_ID_PORT(buf + ISAKMP_ID_DOI_DATA_OFF, 0);
		memcpy(buf + ISAKMP_ID_DATA_OFF, altname, altlen);

		(*id_len)[1] = ISAKMP_ID_DATA_OFF + altlen - ISAKMP_GEN_SZ;
		(*id)[1] = malloc((*id_len)[1]);
		if (!(*id)[1]) {
			log_print("x509_cert_get_subject: malloc (%d) failed",
			    (*id_len)[1]);
			goto fail;
		}
		memcpy((*id)[1], buf + ISAKMP_GEN_SZ, (*id_len)[1]);

		free(buf);
		buf = 0;
	}
	return 1;

fail:
	for (i = 0; i < *cnt; i++)
		free((*id)[i]);
	free(*id);
	free(*id_len);
	free(buf);
	return 0;
}

int
x509_cert_get_key(void *scert, void *keyp)
{
	X509		*cert = scert;
	EVP_PKEY	*key;

	key = X509_get_pubkey(cert);

	/* Check if we got the right key type.  */
	if (key->type != EVP_PKEY_RSA) {
		log_print("x509_cert_get_key: public key is not a RSA key");
		X509_free(cert);
		return 0;
	}
	*(RSA **)keyp = RSAPublicKey_dup(key->pkey.rsa);

	return *(RSA **)keyp == NULL ? 0 : 1;
}

void *
x509_cert_dup(void *scert)
{
	return X509_dup(scert);
}

void
x509_serialize(void *scert, u_int8_t **data, u_int32_t *datalen)
{
	u_int8_t	*p;

	*datalen = i2d_X509((X509 *)scert, NULL);
	*data = p = malloc(*datalen);
	if (!p) {
		log_error("x509_serialize: malloc (%d) failed", *datalen);
		return;
	}
	*datalen = i2d_X509((X509 *)scert, &p);
}

/* From cert to printable */
char *
x509_printable(void *cert)
{
	char		*s;
	u_int8_t	*data;
	u_int32_t	datalen;

	x509_serialize(cert, &data, &datalen);
	if (!data)
		return 0;

	s = raw2hex(data, datalen);
	free(data);
	return s;
}

/* From printable to cert */
void *
x509_from_printable(char *cert)
{
	u_int8_t	*buf;
	int		plen, ret;
	void		*foo;

	plen = (strlen(cert) + 1) / 2;
	buf = malloc(plen);
	if (!buf) {
		log_error("x509_from_printable: malloc (%d) failed", plen);
		return 0;
	}
	ret = hex2raw(cert, buf, plen);
	if (ret == -1) {
		free(buf);
		log_print("x509_from_printable: badly formatted cert");
		return 0;
	}
	foo = x509_cert_get(buf, plen);
	free(buf);
	if (!foo)
		log_print("x509_from_printable: "
		    "could not retrieve certificate");
	return foo;
}

char *
x509_DN_string(u_int8_t *asn1, size_t sz)
{
	X509_NAME	*name;
	const u_int8_t	*p = asn1;
	char		buf[256];	/* XXX Just a guess at a maximum length.  */
	long len = sz;

	name = d2i_X509_NAME(NULL, &p, len);
	if (!name) {
		log_print("x509_DN_string: d2i_X509_NAME failed");
		return 0;
	}
	if (!X509_NAME_oneline(name, buf, sizeof buf - 1)) {
		log_print("x509_DN_string: X509_NAME_oneline failed");
		X509_NAME_free(name);
		return 0;
	}
	X509_NAME_free(name);
	buf[sizeof buf - 1] = '\0';
	return strdup(buf);
}

/* Number of CAs we trust (to decide whether we can send CERT_REQ) */
int
x509_ca_count(void)
{
	return n_x509_cas;
}
@


1.117
log
@Correct a test for X509_get_notAfter() failing or returning
an unsupported time type when passing data to keynote.

Problem introduced by angelos in 1.41 though the code
has been reformatted a few times since then.

ok otto@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.116 2014/03/07 07:19:42 gerhard Exp $	 */
a33 2

#include <sys/param.h>
d43 1
@


1.116
log
@If allocation of 'id' fails, don't try to deref it after 'goto fail'.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.115 2013/11/14 15:44:06 deraadt Exp $	 */
d298 1
a298 1
	if (tm == NULL &&
@


1.115
log
@fix parameter types for x509 routines
ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.114 2013/10/27 18:54:03 guenther Exp $	 */
d1156 1
@


1.114
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.113 2010/06/29 19:50:16 reyk Exp $	 */
d1337 1
a1337 1
	u_int8_t	*p = asn1;
d1339 1
d1341 1
a1341 1
	name = d2i_X509_NAME(NULL, &p, sz);
@


1.113
log
@Replace the hand-crafted Diffie-Hellman implementation in isakmpd with
the smaller implementation from iked that is using libcrypto instead.
This allows to remove a lot of code (which is always good), get rid of
some custom crypto code by using libcrypto, theoretically adds
support for many new MODP and EC2N/ECP modes (but it is not configurable
yet), and allows to share the dh.c/dh.h code in different codebases
(it is identical in isakmpd and iked, but could also be used elsewhere).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.112 2008/09/06 12:22:57 djm Exp $	 */
d105 1
a105 1
	char	*fmt = "Authorizer: \"rsa-hex:%s\"\nLicensees: \"rsa-hex:%s"
d109 1
a109 1
	char	*fmt2 = "Authorizer: \"DN:%s\"\nLicensees: \"DN:%s\"\n"
@


1.112
log
@adapt to API changes in OpenSSL 0.9.8h
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.111 2007/09/02 15:19:24 deraadt Exp $	 */
d56 1
a56 1
#include "math_mp.h"
@


1.111
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.110 2007/08/05 09:43:09 tom Exp $	 */
d835 7
a841 1
#if OPENSSL_VERSION_NUMBER >= 0x00907000L
@


1.110
log
@Allow key exchange with RSA signature authentication to work with
Cisco IOS and other initiators that only send their certs in response
to CERT_REQUEST.

With input and help from cloder@@, Stuart Henderson, mpf@@, and several
others who did lots of testing - thanks to all.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.108 2007/03/03 20:03:03 tom Exp $	 */
d485 1
a485 1
	x509_tab = malloc((bucket_mask + 1) * sizeof(struct x509_list));
d1152 1
a1152 1
	*id_len = malloc(*cnt * sizeof **id_len);
@


1.109
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d81 2
d576 1
a576 1
x509_read_from_dir(X509_STORE *ctx, char *name, int hash)
d633 4
d761 1
a761 1
	if (!x509_read_from_dir(x509_cas, dirname, 0)) {
d780 1
a780 1
	if (!x509_read_from_dir(x509_certs, dirname, 1)) {
d958 2
a959 2
void *
x509_certreq_decode(u_int8_t *asn, u_int32_t len)
d1002 1
a1002 1
	return 0;
d1010 3
a1012 2
	free(aca->name1.type);
	free(aca->name1.val);
d1014 3
a1016 2
	free(aca->name2.type);
	free(aca->name2.val);
d1349 6
@


1.108
log
@There may be more than one item in the subjectAltName (cropping up
with CACert certificates) so don't require the reported length to be
exactly equal to the length of the data, but accept it if it's <=
the length of the data (i.e. we just use the first alt name).  The
purpose of the check is to make sure we don't try to read beyond the
data we actually have.

ok cloder@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.107 2006/09/19 10:48:41 otto Exp $	 */
d437 3
a439 6
	if (buf)
		free(buf);
	if (skey)
		free(skey);
	if (ikey)
		free(ikey);
d1004 5
a1008 9
	if (aca->name1.type)
		free(aca->name1.type);
	if (aca->name1.val)
		free(aca->name1.val);

	if (aca->name2.type)
		free(aca->name2.type);
	if (aca->name2.val)
		free(aca->name2.val);
d1228 4
a1231 8
		if ((*id)[i])
			free((*id)[i]);
	if (*id)
		free(*id);
	if (*id_len)
		free(*id_len);
	if (buf)
		free(buf);
@


1.107
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by/partly
from Paul Stoeber, more to come. ok ho@@ miod@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.106 2006/06/02 19:35:55 hshoexer Exp $	 */
d1102 6
a1107 1
	if (sanlen + 4 != subjectaltname->value->length) {
@


1.106
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.105 2005/11/15 21:49:04 cloder Exp $	 */
d611 1
a611 1
		if (!(sb.st_mode & S_IFREG)) {
d693 1
a693 1
		if (!(sb.st_mode & S_IFREG)) {
@


1.106.2.1
log
@Make isakmpd(8) useable with CaCert signed certificates and add a fix from
-current.

MFC:
revision 1.108
date: 2007/03/03 20:03:03;  author: tom;  state: Exp;  lines: +7 -2
There may be more than one item in the subjectAltName (cropping up
with CACert certificates) so don't require the reported length to be
exactly equal to the length of the data, but accept it if it's <=
the length of the data (i.e. we just use the first alt name).  The
purpose of the check is to make sure we don't try to read beyond the
data we actually have.

ok cloder@@ hshoexer@@
----------------------------
revision 1.107
date: 2006/09/19 10:48:41;  author: otto;  state: Exp;  lines: +3 -3
Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by/partly
from Paul Stoeber, more to come. ok ho@@ miod@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.108 2007/03/03 20:03:03 tom Exp $	 */
d611 1
a611 1
		if (!S_ISREG(sb.st_mode)) {
d693 1
a693 1
		if (!S_ISREG(sb.st_mode)) {
d1102 1
a1102 6
	/*
	 * The test here used to be !=, but some certificates can include
	 * extra stuff in subjectAltName, so we will just take the first
	 * salen bytes, and not worry about what follows.
	 */
	if (sanlen + 4 > subjectaltname->value->length) {
@


1.105
log
@Add a new raw2hex function and yank out several pieces of code in other
places that were doing this.  Prodding deraadt.  OK hshoexer.
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.104 2005/11/14 23:25:11 deraadt Exp $	 */
d75 1
a75 1
 * our own hash table.  It also gets collisons if we have several certificates
@


1.105.2.1
log
@Make isakmpd(8) usable with CaCert signed certificates and add a fix from
-current.

MFC:
revision 1.108
date: 2007/03/03 20:03:03;  author: tom;  state: Exp;  lines: +7 -2
There may be more than one item in the subjectAltName (cropping up
with CACert certificates) so don't require the reported length to be
exactly equal to the length of the data, but accept it if it's <=
the length of the data (i.e. we just use the first alt name).  The
purpose of the check is to make sure we don't try to read beyond the
data we actually have.

ok cloder@@ hshoexer@@
----------------------------
revision 1.107
date: 2006/09/19 10:48:41;  author: otto;  state: Exp;  lines: +3 -3
Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by/partly
from Paul Stoeber, more to come. ok ho@@ miod@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.108 2007/03/03 20:03:03 tom Exp $	 */
d611 1
a611 1
		if (!S_ISREG(sb.st_mode)) {
d693 1
a693 1
		if (!S_ISREG(sb.st_mode)) {
d1102 1
a1102 6
	/*
	 * The test here used to be !=, but some certificates can include
	 * extra stuff in subjectAltName, so we will just take the first
	 * salen bytes, and not worry about what follows.
	 */
	if (sanlen + 4 > subjectaltname->value->length) {
@


1.104
log
@use snprintf; ok cloder.  also looked at by a few other people
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.103 2005/05/28 17:42:50 moritz Exp $	 */
d1286 1
a1286 1
	u_int32_t	datalen, i;
d1292 1
a1292 9
	s = malloc(datalen * 2 + 1);
	if (!s) {
		free(data);
		log_error("x509_printable: malloc (%d) failed",
		    datalen * 2 + 1);
		return 0;
	}
	for (i = 0; i < datalen; i++)
		snprintf(s + (2 * i), 2 * (datalen - i) + 1, "%02x", data[i]);
@


1.103
log
@introduce new readdir implementation for the monitor.
testing and ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.102 2005/05/26 00:58:52 cloder Exp $	 */
d118 1
a118 1
	int	i, buf_len;
a205 8
	buf_len = strlen(fmt) + strlen(ikey) + strlen(skey) + 56;
	buf = calloc(buf_len, sizeof(char));
	buf_len *= sizeof(char);
	if (!buf) {
		log_error("x509_generate_kn: "
		    "failed to allocate memory for KeyNote credential");
		goto fail;
	}
d384 6
a389 2
	snprintf(buf, buf_len, fmt, skey, ikey, timecomp, before, timecomp2,
	    after);
d419 3
a421 4
	buf_len = strlen(fmt2) + strlen(isname) + strlen(subname) + 56;
	buf = malloc(buf_len);
	if (!buf) {
		log_error("x509_generate_kn: malloc (%d) failed", buf_len);
a423 2
	snprintf(buf, buf_len, fmt2, isname, subname, timecomp, before,
	    timecomp2, after);
@


1.102
log
@Clean up some cleanup code. Fixes at least one leak, possibly more.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.101 2005/04/08 22:32:10 cloder Exp $	 */
a585 2
	struct dirent  *file;
	struct monitor_dirents *dir;
d590 2
a591 1
	int		fd, off, size;
d600 1
a600 2
	dir = monitor_opendir(name);
	if (!dir) {
a605 11
	strlcpy(fullname, name, sizeof fullname);
	off = strlen(fullname);
	size = sizeof fullname - off;

	while ((file = monitor_readdir(dir)) != NULL) {
		strlcpy(fullname + off, file->d_name, size);

		if (file->d_type != DT_UNKNOWN) {
			if (file->d_type != DT_REG && file->d_type != DT_LNK)
				continue;
		}
d607 1
d610 1
a610 7
		    file->d_name));

		if ((fd = monitor_open(fullname, O_RDONLY, 0)) == -1) {
			log_error("x509_read_from_dir: monitor_open"
			    "(\"%s\", O_RDONLY, 0) failed", fullname);
			continue;
		}
d638 1
a638 1
			    "failed for %s", file->d_name);
d650 1
a650 1
			    "for %s", file->d_name));
d656 1
a656 1
				    file->d_name);
a658 2
	monitor_closedir(dir);

a666 2
	struct dirent	*file;
	struct monitor_dirents *dir;
d671 1
d681 1
a681 2
	dir = monitor_opendir(name);
	if (!dir) {
d690 1
a690 8
	while ((file = monitor_readdir(dir)) != NULL) {
		strlcpy(fullname + off, file->d_name, size);

		if (file->d_type != DT_UNKNOWN) {
			if (file->d_type != DT_REG && file->d_type != DT_LNK)
				continue;
		}

d692 1
a692 7
		    "CRL %s", file->d_name));

		if ((fd = monitor_open(fullname, O_RDONLY, 0)) == -1) {
			log_error("x509_read_crls_from_dir: monitor_open"
			    "(\"%s\", O_RDONLY, 0) failed", fullname);
			continue;
		}
d718 1
a718 1
			    file->d_name);
d723 1
a723 1
			    "X509_STORE_add_crl failed for %s", file->d_name));
a736 1
	monitor_closedir(dir);
@


1.101
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.100 2005/04/08 17:15:01 deraadt Exp $	 */
d105 2
a106 1
	char	*ikey, *skey, *buf, isname[256], subname[256];
d114 1
a114 1
	RSA	*key;
a142 1
		RSA_free(key);
d145 1
a145 1
		return 0;
a147 1
		RSA_free(key);
d150 1
a150 1
		return 0;
d152 1
d154 1
d168 1
a168 1
			return 0;
d177 1
a177 2
		free(ikey);
		return 0;
d182 1
a182 2
		free(ikey);
		return 0;
a192 2
		free(ikey);
		RSA_free(key);
d195 1
a195 1
		return 0;
a197 2
		free(ikey);
		RSA_free(key);
d200 1
a200 1
		return 0;
d202 1
d204 1
d212 1
a212 3
		free(ikey);
		free(skey);
		return 0;
d234 1
a234 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d244 1
a244 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d259 1
a259 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d274 1
a274 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d289 1
a289 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d324 1
a324 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d334 1
a334 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d349 1
a349 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d364 1
a364 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d379 1
a379 4
				free(ikey);
				free(skey);
				free(buf);
				return 0;
d394 1
d396 1
d398 1
d403 1
a403 2
		free(buf);
		return 0;
d409 1
d415 1
a415 1
		return 0;
d421 1
a421 1
		return 0;
d435 1
a435 2
		free(buf);
		return 0;
d442 12
@


1.100
log
@keynote and policy always compiled in
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.99 2005/04/08 16:24:12 deraadt Exp $	 */
a47 2

#include "sysdep.h"
@


1.99
log
@privsep always
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.98 2005/04/05 20:46:20 cloder Exp $	 */
a45 1
#ifdef USE_POLICY
a47 1
#endif				/* USE_POLICY */
a96 1
#ifdef USE_POLICY
a477 1
#endif				/* USE_POLICY */
a959 1
#ifdef USE_POLICY
a965 1
#endif				/* USE_POLICY */
@


1.98
log
@Always compile X509 support. Almost everyone uses it.  Makes the code
much easier to read and to maintain.
OK and testing by hshoexer@@, more testing by me
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.97 2005/03/15 16:49:05 mpf Exp $	 */
a613 1
#if defined (USE_PRIVSEP)
a614 3
#else
	DIR		*dir;
#endif
a714 1
#if defined (USE_PRIVSEP)
a715 3
#else
	DIR		*dir;
#endif
@


1.97
log
@small log message fix.
ok hshoexer@@, markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.96 2005/02/27 13:12:12 hshoexer Exp $	 */
a33 1
#ifdef USE_X509
d1434 1
a1434 1
#endif				/* USE_X509 */
@


1.96
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.95 2004/08/10 19:21:01 deraadt Exp $	 */
d687 1
a687 1
			log_print("x509_read_from_dir: PEM_read_bio_X509 "
@


1.95
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.94 2004/08/08 19:11:06 deraadt Exp $	 */
d1051 1
a1051 1
	memset(&naca, 0, sizeof(naca));
@


1.94
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.93 2004/06/17 19:32:06 hshoexer Exp $	 */
d69 3
a71 3
static void     x509_hash_init(void);
static X509    *x509_hash_find(u_int8_t *, size_t);
static int      x509_hash_enter(X509 *);
d92 1
a92 1
	X509           *cert;
d95 1
a95 2
static
LIST_HEAD(x509_list, x509_hash) * x509_tab = 0;
d98 1
a98 1
	static int      bucket_mask;
d116 1
a116 1
	X509_STORE_CTX  csc;
d536 2
a537 2
	u_int8_t      **cid;
	u_int32_t      *clen;
d577 3
a579 3
	u_int16_t       bucket = 0;
	u_int8_t      **id;
	u_int32_t      *len;
d581 1
a581 1
	int             n, i;
d618 1
a618 1
	DIR            *dir;
d620 2
a621 2
	FILE           *certfp;
	X509           *cert;
d623 2
a624 2
	char            fullname[PATH_MAX];
	int             fd, off, size;
d631 1
a631 1
	     name));
d697 1
a697 1
		         */
d719 1
a719 1
	struct dirent  *file;
d723 1
a723 1
	DIR            *dir;
d725 2
a726 2
	FILE           *crlfp;
	X509_CRL       *crl;
d728 2
a729 2
	char            fullname[PATH_MAX];
	int             fd, off, size;
d804 1
a804 1
	         */
d870 1
a870 1
         */
d900 5
a904 5
	X509_STORE_CTX  csc;
	X509_NAME      *issuer, *subject;
	X509           *cert = (X509 *) scert;
	EVP_PKEY       *key;
	int             res, err;
d909 1
a909 1
         */
a991 1
	int             i;
d993 1
d1017 1
a1017 1
	int             res = 1;
d1158 3
a1160 4
	X509_EXTENSION *subjectaltname;
	u_int8_t       *sandata;
	int             extpos;
	int             santype, sanlen;
d1197 8
a1204 8
	X509           *cert = scert;
	X509_NAME      *subject;
	int             type;
	u_int8_t       *altname;
	u_int32_t       altlen;
	u_int8_t       *buf = 0;
	unsigned char  *ubuf;
	int             i;
d1213 1
a1213 1
         */
d1272 1
a1272 1
		         */
d1325 2
a1326 2
	X509           *cert = scert;
	EVP_PKEY       *key;
d1350 1
a1350 1
	u_int8_t       *p;
d1365 3
a1367 3
	char           *s;
	u_int8_t       *data;
	u_int32_t       datalen, i;
d1390 3
a1392 3
	u_int8_t       *buf;
	int             plen, ret;
	void           *foo;
d1417 3
a1419 4
	X509_NAME      *name;
	u_int8_t       *p = asn1;
	/* XXX Just a guess at a maximum length.  */
	char            buf[256];
@


1.93
log
@Evaluate result of X509_verify_cert() more carefully.

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.92 2004/06/14 13:53:31 hshoexer Exp $	 */
d111 1
a111 1
	    	     "\"\nConditions: %s >= \"%s\" && %s <= \"%s\";\n";
d114 1
a114 1
		     "Conditions: %s >= \"%s\" && %s <= \"%s\";\n";
d525 1
a525 1
		    (bucket_mask + 1) * 
d570 1
a570 1
	LOG_DBG((LOG_CRYPTO, 70, 
d755 1
a755 1
		} 
@


1.92
log
@avoid stat before open

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.91 2004/06/14 09:55:42 ho Exp $	 */
d926 3
d930 1
a930 1
	if (res)
d932 2
a933 1
	else if (!conf_get_str("X509-certificates", "Accept-self-signed")) {
d937 6
a942 1
		return res;
@


1.91
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.90 2004/06/02 16:19:16 hshoexer Exp $	 */
d623 1
d625 1
a625 1
	int             off, size;
a650 6
		} else {
			struct stat     sb;

			if (monitor_stat(fullname, &sb) == -1 ||
			    !(sb.st_mode & S_IFREG))
				continue;
d657 14
a670 5
		certfp = monitor_fopen(fullname, "r");
		if (!certfp) {
			log_error("x509_read_from_dir: monitor_fopen "
			    "(\"%s\", \"r\") failed",
			    fullname);
d673 7
d728 1
d730 1
a730 1
	int             off, size;
d755 10
a764 2
		} else {
			struct stat     sb;
d766 4
a769 3
			if (monitor_stat(fullname, &sb) == -1 ||
			    !(sb.st_mode & S_IFREG))
				continue;
d772 4
a775 2
		LOG_DBG((LOG_CRYPTO, 60, "x509_read_crls_from_dir: reading "
		    "CRL %s", file->d_name));
d777 3
a779 4
		crlfp = monitor_fopen(fullname, "r");
		if (!crlfp) {
			log_error("x509_read_crls_from_dir: monitor_fopen "
			    "(\"%s\", \"r\") failed", fullname);
d782 1
d789 1
a789 1
			    "PEM_read_bio_X509_CRL failed for %s",
@


1.90
log
@remove unused BIO-functions.

ok markus@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.89 2004/05/23 18:17:56 hshoexer Exp $	 */
d172 2
a173 1
			    "x509_generate_kn: no certificate found for issuer"));
d227 2
a228 1
	    (tm->type != V_ASN1_UTCTIME && tm->type != V_ASN1_GENERALIZEDTIME)) {
d332 2
a333 1
	    (tm->type != V_ASN1_UTCTIME && tm->type != V_ASN1_GENERALIZEDTIME)) {
d362 2
a363 1
				    "NotValidAfter time field (%d)", tm->length));
d389 2
a390 1
				snprintf(after, sizeof after, "20%s", tm->data);
d392 2
a393 1
				snprintf(after, sizeof after, "19%s", tm->data);
d452 2
a453 1
		    "x509_generate_kn: X509_NAME_oneline (issuer, ...) failed"));
d458 2
a459 1
		    "x509_generate_kn: X509_NAME_oneline (subject, ...) failed"));
d525 2
a526 1
		    (bucket_mask + 1) * (unsigned long)sizeof(struct x509_list));
d570 2
a571 1
	LOG_DBG((LOG_CRYPTO, 70, "x509_hash_find: no certificate matched query"));
d694 2
a695 2
				log_print("x509_read_from_dir: x509_hash_enter "
				    "(%s) failed",
d885 2
a886 2
	 * Validate the peer certificate by checking with the CA certificates we
	 * trust.
d1105 2
a1106 2
		LOG_DBG((LOG_CRYPTO, 60,
		    "x509_cert_obtain: acceptable certificate authorities here"));
d1141 2
a1142 1
	    !subjectaltname->value->data || subjectaltname->value->length < 4) {
d1379 2
a1380 1
		log_print("x509_from_printable: could not retrieve certificate");
@


1.89
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.88 2004/04/15 18:39:26 deraadt Exp $	 */
a607 1
	FILE           *certfp;
a609 1
	BIO            *certh;
d611 1
a651 1
#if defined (USE_PRIVSEP)
d665 1
a665 21
#else
		certh = BIO_new(BIO_s_file());
		if (!certh) {
			log_error("x509_read_from_dir: BIO_new (BIO_s_file "
			    "()) failed");
			continue;
		}
		if (BIO_read_filename(certh, fullname) == -1) {
			BIO_free(certh);
			log_error("x509_read_from_dir: "
			    "BIO_read_filename (certh, \"%s\") failed",
			    fullname);
			continue;
		}
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
		cert = PEM_read_bio_X509(certh, NULL, NULL, NULL);
#else
		cert = PEM_read_bio_X509(certh, NULL, NULL);
#endif
		BIO_free(certh);
#endif				/* USE_PRIVSEP */
a701 1
	FILE           *crlfp;
a703 1
	BIO            *crlh;
d705 1
a743 1
#if defined (USE_PRIVSEP)
d751 1
a752 15
#else
		crlh = BIO_new(BIO_s_file());
		if (!crlh) {
			log_error("x509_read_crls_from_dir: "
			    "BIO_new (BIO_s_file ()) failed");
			continue;
		}
		if (BIO_read_filename(crlh, fullname) == -1) {
			BIO_free(crlh);
			log_error("x509_read_crls_from_dir: "
			    "BIO_read_filename (crlh, \"%s\") failed",
			    fullname);
			continue;
		}
		crl = PEM_read_bio_X509_CRL(crlh, NULL, NULL, NULL);
a753 2
		BIO_free(crlh);
#endif				/* USE_PRIVSEP */
@


1.88
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.87 2004/04/07 22:45:49 ho Exp $	 */
d110 2
a111 2
	char	*fmt = "Authorizer: \"rsa-hex:%s\"\nLicensees: \"rsa-hex:%s\"\n"
	    "Conditions: %s >= \"%s\" && %s <= \"%s\";\n";
d114 1
a114 1
	    "Conditions: %s >= \"%s\" && %s <= \"%s\";\n";
d147 2
a148 1
		log_print("x509_generate_kn: failed to get memory for public key");
d150 2
a151 1
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: cannot get subject key"));
d156 2
a157 1
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: cannot get subject key"));
d168 2
a169 2
		if (X509_STORE_get_by_subject(&csc, X509_LU_X509, issuer, &obj) !=
		    X509_LU_X509) {
d198 2
a199 1
		log_error("x509_generate_kn: failed to get memory for public key");
d202 2
a203 1
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: cannot get issuer key"));
d209 2
a210 1
		LOG_DBG((LOG_POLICY, 30, "x509_generate_kn: cannot get issuer key"));
d255 2
a256 1
				    "of NotValidBefore time field (%d)", tm->length));
d282 2
a283 1
				snprintf(before, sizeof before, "20%s", tm->data);
d285 2
a286 1
				snprintf(before, sizeof before, "19%s", tm->data);
d291 2
a292 1
				    "NotValidBefore time field (%d)", tm->length));
d392 2
a393 1
				    "NotValidAfter time field (%d)", tm->length));
d428 2
a429 1
	snprintf(buf, buf_len, fmt, skey, ikey, timecomp, before, timecomp2, after);
d460 2
a461 2
	snprintf(buf, buf_len, fmt2, isname, subname, timecomp, before, timecomp2,
	    after);
d469 2
a470 1
	LOG_DBG((LOG_POLICY, 80, "x509_generate_kn: added credential:\n%s", buf));
d508 1
a508 1
			     certh = LIST_FIRST(&x509_tab[i])) {
d517 1
a517 1
		    (bucket_mask + 1) * (unsigned long) sizeof(struct x509_list));
d540 2
a541 1
			LOG_DBG_BUF((LOG_CRYPTO, 70, "cert_cmp", cid[i], clen[i]));
d583 1
a583 1
			    (unsigned long) sizeof *certh);
d591 2
a592 1
		LOG_DBG((LOG_CRYPTO, 70, "x509_hash_enter: cert %p added to bucket %d",
d627 2
a628 2
		    "x509_read_from_dir: opendir (\"%s\") failed: "
		    "%s", name, strerror(errno)));
d649 2
a650 1
		LOG_DBG((LOG_CRYPTO, 60, "x509_read_from_dir: reading certificate %s",
d670 2
a671 1
			log_error("x509_read_from_dir: BIO_new (BIO_s_file ()) failed");
d689 2
a690 2
			log_print("x509_read_from_dir: PEM_read_bio_X509 failed for %s",
			    file->d_name);
d696 3
a698 3
			 * certificates only differing in subjectAltName, which
			 * is not an something that is strange.  Consider
			 * multi-homed machines.
d701 2
a702 2
			    "x509_read_from_dir: X509_STORE_add_cert failed for %s",
			    file->d_name));
d737 2
a738 2
	LOG_DBG((LOG_CRYPTO, 40, "x509_read_crls_from_dir: reading CRLs from %s",
	    name));
d742 2
a743 2
		LOG_DBG((LOG_CRYPTO, 10, "x509_read_crls_from_dir: opendir (\"%s\") "
		    "failed: %s", name, strerror(errno)));
d759 2
a760 1
			if (monitor_stat(fullname, &sb) == -1 || !(sb.st_mode & S_IFREG))
d764 2
a765 2
		LOG_DBG((LOG_CRYPTO, 60, "x509_read_crls_from_dir: reading CRL %s",
		    file->d_name));
d786 2
a787 1
			    "BIO_read_filename (crlh, \"%s\") failed", fullname);
d796 2
a797 1
			    "PEM_read_bio_X509_CRL failed for %s", file->d_name);
d806 6
a811 5
		 * XXX This is to make x509_cert_validate set this (and another) flag
		 * XXX when validating certificates. Currently, OpenSSL defaults to
		 * XXX reject an otherwise valid certificate (chain) if these flags
		 * XXX are set but there are no CRLs to check. The current workaround
		 * XXX is to only set the flags if we actually loaded some CRL data.
d826 1
a826 1
	char           *dirname;
d880 1
a880 1
	char           *dirname;
d964 2
a965 2
	X509           *cert;
	int             res;
d967 1
a967 1
	cert = X509_dup((X509 *) scert);
d1022 2
a1023 1
		log_print("x509_certreq_validate: can not decode 'acceptable CA' info");
d1046 2
a1047 1
		log_print("x509_certreq_decode: can not decode 'acceptable CA' info");
d1052 2
a1053 2
	tmp = asn_decompose("aca.RelativeDistinguishedName.AttributeValueAssertion",
	    &aca);
d1172 2
a1173 1
		log_print("x509_cert_subjectaltname: invalid subjectaltname extension");
d1183 2
a1184 1
		log_print("x509_cert_subjectaltname: subjectaltname invalid length");
d1209 3
a1211 2
	 * XXX There can be a collection of subjectAltNames, but for now
	 * I only return the subjectName and a single subjectAltName, if present.
d1223 1
a1223 1
		    *cnt * (unsigned long) sizeof **id);
d1229 1
a1229 1
		    *cnt * (unsigned long) sizeof **id_len);
d1238 2
a1239 1
		ISAKMP_ID_DATA_OFF + i2d_X509_NAME(subject, NULL) - ISAKMP_GEN_SZ;
d1242 2
a1243 1
		log_print("x509_cert_get_subject: malloc (%d) failed", (*id_len)[0]);
d1269 2
a1270 2
			 * XXX I dislike the numeric constants, but I don't know what we
			 * should use otherwise.
d1282 2
a1283 2
				log_print("x509_cert_get_subject: "
				    "invalid subjectAltName IPaddress length %d ",
d1335 1
a1335 1
	*(RSA **) keyp = RSAPublicKey_dup(key->pkey.rsa);
d1337 1
a1337 1
	return *(RSA **) keyp == NULL ? 0 : 1;
d1351 1
a1351 1
	*datalen = i2d_X509((X509 *) scert, NULL);
d1357 1
a1357 1
	*datalen = i2d_X509((X509 *) scert, &p);
d1375 2
a1376 1
		log_error("x509_printable: malloc (%d) failed", datalen * 2 + 1);
@


1.87
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.86 2004/03/19 14:04:43 hshoexer Exp $	*/
/*	$EOM: x509.c,v 1.54 2001/01/16 18:42:16 ho Exp $	*/
d50 1
a50 1
#endif /* USE_POLICY */
d68 4
a71 4
static u_int16_t x509_hash (u_int8_t *, size_t);
static void x509_hash_init (void);
static X509 *x509_hash_find (u_int8_t *, size_t);
static int x509_hash_enter (X509 *);
d90 1
a90 1
  LIST_ENTRY (x509_hash) link;
d92 1
a92 1
  X509 *cert;
d95 2
a96 1
static LIST_HEAD (x509_list, x509_hash) *x509_tab = 0;
d99 1
a99 1
static int bucket_mask;
d108 1
a108 1
x509_generate_kn (int id, X509 *cert)
d110 15
a124 16
  char *fmt = "Authorizer: \"rsa-hex:%s\"\nLicensees: \"rsa-hex:%s\"\n"
    "Conditions: %s >= \"%s\" && %s <= \"%s\";\n";
  char *ikey, *skey, *buf, isname[256], subname[256];
  char *fmt2 = "Authorizer: \"DN:%s\"\nLicensees: \"DN:%s\"\n"
    "Conditions: %s >= \"%s\" && %s <= \"%s\";\n";
  X509_NAME *issuer, *subject;
  struct keynote_deckey dc;
  X509_STORE_CTX csc;
  X509_OBJECT obj;
  X509 *icert;
  RSA *key;
  time_t tt;
  char before[15], after[15];
  ASN1_TIME *tm;
  char *timecomp, *timecomp2;
  int i, buf_len;
d126 1
a126 1
  LOG_DBG ((LOG_POLICY, 90,
d130 2
a131 2
  issuer = X509_get_issuer_name (cert);
  subject = X509_get_subject_name (cert);
d133 316
a448 372
  /* Missing or self-signed, ignore cert but don't report failure.  */
  if (!issuer || !subject || !X509_name_cmp (issuer, subject))
    return 1;

  if (!x509_cert_get_key (cert, &key))
    {
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to get public key from cert"));
      return 0;
    }

  dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
  dc.dec_key = key;
  ikey = kn_encode_key (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
			KEYNOTE_PUBLIC_KEY);
  if (keynote_errno == ERROR_MEMORY)
    {
      log_print ("x509_generate_kn: failed to get memory for public key");
      RSA_free (key);
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: cannot get subject key"));
      return 0;
    }
  if (!ikey)
    {
      RSA_free (key);
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: cannot get subject key"));
      return 0;
    }
  RSA_free (key);

  /* Now find issuer's certificate so we can get the public key.  */
  X509_STORE_CTX_init (&csc, x509_cas, cert, NULL);
  if (X509_STORE_get_by_subject (&csc, X509_LU_X509, issuer, &obj) !=
      X509_LU_X509)
    {
      X509_STORE_CTX_cleanup (&csc);
      X509_STORE_CTX_init (&csc, x509_certs, cert, NULL);
      if (X509_STORE_get_by_subject (&csc, X509_LU_X509, issuer, &obj) !=
          X509_LU_X509)
	{
	  X509_STORE_CTX_cleanup (&csc);
	  LOG_DBG ((LOG_POLICY, 30,
		    "x509_generate_kn: no certificate found for issuer"));
	  return 0;
	}
    }

  X509_STORE_CTX_cleanup (&csc);
  icert = obj.data.x509;

  if (icert == NULL)
    {
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: "
		"missing certificates, cannot construct X509 chain"));
      free (ikey);
      return 0;
    }

  if (!x509_cert_get_key (icert, &key))
    {
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to get public key from cert"));
      free (ikey);
      return 0;
    }

  X509_OBJECT_free_contents (&obj);

  dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
  dc.dec_key = key;
  skey = kn_encode_key (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
			KEYNOTE_PUBLIC_KEY);
  if (keynote_errno == ERROR_MEMORY)
    {
      log_error ("x509_generate_kn: failed to get memory for public key");
      free (ikey);
      RSA_free (key);
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: cannot get issuer key"));
      return 0;
    }

  if (!skey)
    {
      free (ikey);
      RSA_free (key);
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: cannot get issuer key"));
      return 0;
    }
  RSA_free (key);

  buf_len = strlen (fmt) + strlen (ikey) + strlen (skey) + 56;
  buf = calloc (buf_len, sizeof (char));
  buf_len *= sizeof (char);
  if (!buf)
    {
      log_error ("x509_generate_kn: "
		 "failed to allocate memory for KeyNote credential");
      free (ikey);
      free (skey);
      return 0;
    }

  if (((tm = X509_get_notBefore (cert)) == NULL) ||
      (tm->type != V_ASN1_UTCTIME && tm->type != V_ASN1_GENERALIZEDTIME))
    {
      tt = time (0);
      strftime (before, 14, "%Y%m%d%H%M%S", localtime (&tt));
      timecomp = "LocalTimeOfDay";
    }
  else
    {
      if (tm->data[tm->length - 1] == 'Z')
	{
	  timecomp = "GMTTimeOfDay";
	  i = tm->length - 2;
	}
      else
        {
	  timecomp = "LocalTimeOfDay";
	  i = tm->length - 1;
	}

      for (; i >= 0; i--)
        {
	  if (tm->data[i] < '0' || tm->data[i] > '9')
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid data in "
			"NotValidBefore time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }
	}

      if (tm->type == V_ASN1_UTCTIME)
	{
	  if ((tm->length < 10) || (tm->length > 13))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid length "
			"of NotValidBefore time field (%d)", tm->length));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Validity checks.  */
	  if ((tm->data[2] != '0' && tm->data[2] != '1')
	      || (tm->data[2] == '0' && tm->data[3] == '0')
	      || (tm->data[2] == '1' && tm->data[3] > '2')
	      || (tm->data[4] > '3')
	      || (tm->data[4] == '0' && tm->data[5] == '0')
	      || (tm->data[4] == '3' && tm->data[5] > '1')
	      || (tm->data[6] > '2')
	      || (tm->data[6] == '2' && tm->data[7] > '3')
	      || (tm->data[8] > '5'))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid value in "
			"NotValidBefore time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Stupid UTC tricks.  */
	  if (tm->data[0] < '5')
	    snprintf (before, sizeof before, "20%s", tm->data);
	  else
	    snprintf (before, sizeof before, "19%s", tm->data);
	}
      else
        { /* V_ASN1_GENERICTIME */
	  if ((tm->length < 12) || (tm->length > 15))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid length of "
			"NotValidBefore time field (%d)", tm->length));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Validity checks.  */
	  if ((tm->data[4] != '0' && tm->data[4] != '1')
	      || (tm->data[4] == '0' && tm->data[5] == '0')
	      || (tm->data[4] == '1' && tm->data[5] > '2')
	      || (tm->data[6] > '3')
	      || (tm->data[6] == '0' && tm->data[7] == '0')
	      || (tm->data[6] == '3' && tm->data[7] > '1')
	      || (tm->data[8] > '2')
	      || (tm->data[8] == '2' && tm->data[9] > '3')
	      || (tm->data[10] > '5'))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid value in "
			"NotValidBefore time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  snprintf (before, sizeof before, "%s", tm->data);
	}

      /* Fix missing seconds.  */
      if (tm->length < 12)
        {
	  before[12] = '0';
	  before[13] = '0';
	}

      /* This will overwrite trailing 'Z'.  */
      before[14] = '\0';
    }

  tm = X509_get_notAfter (cert);
  if (tm == NULL
      && (tm->type != V_ASN1_UTCTIME && tm->type != V_ASN1_GENERALIZEDTIME))
    {
      tt = time (0);
      strftime (after, 14, "%Y%m%d%H%M%S", localtime (&tt));
      timecomp2 = "LocalTimeOfDay";
    }
  else
    {
      if (tm->data[tm->length - 1] == 'Z')
	{
	  timecomp2 = "GMTTimeOfDay";
	  i = tm->length - 2;
	}
      else
        {
	  timecomp2 = "LocalTimeOfDay";
	  i = tm->length - 1;
	}

      for (; i >= 0; i--)
        {
	  if (tm->data[i] < '0' || tm->data[i] > '9')
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid data in "
			"NotValidAfter time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }
	}

      if (tm->type == V_ASN1_UTCTIME)
	{
	  if ((tm->length < 10) || (tm->length > 13))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid length of "
			"NotValidAfter time field (%d)", tm->length));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Validity checks. */
	  if ((tm->data[2] != '0' && tm->data[2] != '1')
	      || (tm->data[2] == '0' && tm->data[3] == '0')
	      || (tm->data[2] == '1' && tm->data[3] > '2')
	      || (tm->data[4] > '3')
	      || (tm->data[4] == '0' && tm->data[5] == '0')
	      || (tm->data[4] == '3' && tm->data[5] > '1')
	      || (tm->data[6] > '2')
	      || (tm->data[6] == '2' && tm->data[7] > '3')
	      || (tm->data[8] > '5'))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid value in "
			"NotValidAfter time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Stupid UTC tricks.  */
	  if (tm->data[0] < '5')
	    snprintf (after, sizeof after, "20%s", tm->data);
	  else
	    snprintf (after, sizeof after, "19%s", tm->data);
	}
      else
        { /* V_ASN1_GENERICTIME */
	  if ((tm->length < 12) || (tm->length > 15))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid length of "
			"NotValidAfter time field (%d)", tm->length));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Validity checks.  */
	  if ((tm->data[4] != '0' && tm->data[4] != '1')
	      || (tm->data[4] == '0' && tm->data[5] == '0')
	      || (tm->data[4] == '1' && tm->data[5] > '2')
	      || (tm->data[6] > '3')
	      || (tm->data[6] == '0' && tm->data[7] == '0')
	      || (tm->data[6] == '3' && tm->data[7] > '1')
	      || (tm->data[8] > '2')
	      || (tm->data[8] == '2' && tm->data[9] > '3')
	      || (tm->data[10] > '5'))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid value in "
			"NotValidAfter time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  snprintf (after, sizeof after, "%s", tm->data);
        }

      /* Fix missing seconds.  */
      if (tm->length < 12)
        {
	  after[12] = '0';
	  after[13] = '0';
	}

      after[14] = '\0'; /* This will overwrite trailing 'Z' */
    }

  snprintf (buf, buf_len, fmt, skey, ikey, timecomp, before, timecomp2, after);
  free (ikey);
  free (skey);

  if (kn_add_assertion (id, buf, strlen (buf), ASSERT_FLAG_LOCAL) == -1)
    {
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to add new KeyNote credential"));
      free (buf);
      return 0;
    }

  /* We could print the assertion here, but log_print() truncates...  */
  LOG_DBG ((LOG_POLICY, 60, "x509_generate_kn: added credential"));

  free (buf);

  if (!X509_NAME_oneline (issuer, isname, 256))
    {
      LOG_DBG ((LOG_POLICY, 50,
		"x509_generate_kn: X509_NAME_oneline (issuer, ...) failed"));
      return 0;
    }

  if (!X509_NAME_oneline (subject, subname, 256))
    {
      LOG_DBG ((LOG_POLICY, 50,
		"x509_generate_kn: X509_NAME_oneline (subject, ...) failed"));
      return 0;
    }

  buf_len = strlen (fmt2) + strlen (isname) + strlen (subname) + 56;
  buf = malloc (buf_len);
  if (!buf)
    {
      log_error ("x509_generate_kn: malloc (%d) failed", buf_len);
      return 0;
    }

  snprintf (buf, buf_len, fmt2, isname, subname, timecomp, before, timecomp2,
d451 7
a457 7
  if (kn_add_assertion (id, buf, strlen (buf), ASSERT_FLAG_LOCAL) == -1)
    {
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to add new KeyNote credential"));
      free (buf);
      return 0;
    }
d459 2
a460 4
  LOG_DBG ((LOG_POLICY, 80, "x509_generate_kn: added credential:\n%s", buf));

  free (buf);
  return 1;
d462 1
a462 1
#endif /* USE_POLICY */
d465 1
a465 1
x509_hash (u_int8_t *id, size_t len)
d467 2
a468 12
  size_t i;
  u_int16_t bucket = 0;

  /* XXX We might resize if we are crossing a certain threshold.  */
  for (i = 4; i < (len & ~1); i += 2)
    {
      /* Doing it this way avoids alignment problems.  */
      bucket ^= (id[i] + 1) * (id[i + 1] + 257);
    }
  /* Hash in the last character of odd length IDs too.  */
  if (i < len)
    bucket ^= (id[i] + 1) * (id[i] + 257);
d470 8
a477 1
  bucket &= bucket_mask;
d479 2
a480 1
  return bucket;
d484 1
a484 1
x509_hash_init (void)
d486 2
a487 2
  struct x509_hash *certh;
  int i;
d489 1
a489 1
  bucket_mask = (1 << INITIAL_BUCKET_BITS) - 1;
d491 17
a507 22
  /* If reinitializing, free existing entries.  */
  if (x509_tab)
    {
      for (i = 0; i <= bucket_mask; i++)
        for (certh = LIST_FIRST (&x509_tab[i]); certh;
             certh = LIST_FIRST (&x509_tab[i]))
	  {
	    LIST_REMOVE (certh, link);
	    free (certh);
	  }

      free (x509_tab);
    }

  x509_tab = malloc ((bucket_mask + 1) * sizeof (struct x509_list));
  if (!x509_tab)
    log_fatal ("x509_hash_init: malloc (%lu) failed",
	       (bucket_mask + 1) * (unsigned long)sizeof (struct x509_list));
  for (i = 0; i <= bucket_mask; i++)
    {
      LIST_INIT (&x509_tab[i]);
    }
d512 1
a512 1
x509_hash_find (u_int8_t *id, size_t len)
d514 32
a545 32
  struct x509_hash *cert;
  u_int8_t **cid;
  u_int32_t *clen;
  int n, i, id_found;

  for (cert = LIST_FIRST (&x509_tab[x509_hash (id, len)]); cert;
       cert = LIST_NEXT (cert, link))
    {
      if (!x509_cert_get_subjects (cert->cert, &n, &cid, &clen))
	continue;

      id_found = 0;
      for (i = 0; i < n; i++)
	{
	  LOG_DBG_BUF ((LOG_CRYPTO, 70, "cert_cmp", id, len));
	  LOG_DBG_BUF ((LOG_CRYPTO, 70, "cert_cmp", cid[i], clen[i]));
	  /* XXX This identity predicate needs to be understood.  */
	  if (clen[i] == len && id[0] == cid[i][0]
	      && memcmp (id + 4, cid[i] + 4, len - 4) == 0)
	    {
	      id_found++;
	      break;
	    }
	}
      cert_free_subjects (n, cid, clen);
      if (!id_found)
	continue;

      LOG_DBG ((LOG_CRYPTO, 70, "x509_hash_find: return X509 %p",
		cert->cert));
      return cert->cert;
    }
d547 2
a548 2
  LOG_DBG ((LOG_CRYPTO, 70, "x509_hash_find: no certificate matched query"));
  return 0;
d552 1
a552 1
x509_hash_enter (X509 *cert)
d554 27
a580 32
  u_int16_t bucket = 0;
  u_int8_t **id;
  u_int32_t *len;
  struct x509_hash *certh;
  int n, i;

  if (!x509_cert_get_subjects (cert, &n, &id, &len))
    {
      log_print ("x509_hash_enter: cannot retrieve subjects");
      return 0;
    }

  for (i = 0; i < n; i++)
    {
      certh = calloc (1, sizeof *certh);
      if (!certh)
        {
          cert_free_subjects (n, id, len);
          log_error ("x509_hash_enter: calloc (1, %lu) failed",
		(unsigned long)sizeof *certh);
          return 0;
        }

      certh->cert = cert;

      bucket = x509_hash (id[i], len[i]);

      LIST_INSERT_HEAD (&x509_tab[bucket], certh, link);
      LOG_DBG ((LOG_CRYPTO, 70, "x509_hash_enter: cert %p added to bucket %d",
		cert, bucket));
    }
  cert_free_subjects (n, id, len);
d582 1
a582 1
  return 1;
d588 1
a588 1
x509_read_from_dir (X509_STORE *ctx, char *name, int hash)
d590 1
a590 1
  struct dirent *file;
d592 2
a593 2
  struct monitor_dirents *dir;
  FILE *certfp;
d595 2
a596 2
  DIR *dir;
  BIO *certh;
d598 35
a632 9
  X509 *cert;
  char fullname[PATH_MAX];
  int off, size;

  if (strlen (name) >= sizeof fullname - 1)
    {
      log_print ("x509_read_from_dir: directory name too long");
      return 0;
    }
d634 2
a635 34
  LOG_DBG ((LOG_CRYPTO, 40, "x509_read_from_dir: reading certs from %s",
	    name));

  dir = monitor_opendir (name);
  if (!dir)
    {
      LOG_DBG ((LOG_CRYPTO, 10, "x509_read_from_dir: opendir (\"%s\") failed: "
		"%s", name, strerror (errno)));
      return 0;
    }

  strlcpy (fullname, name, sizeof fullname);
  off = strlen (fullname);
  size = sizeof fullname - off;

  while ((file = monitor_readdir (dir)) != NULL)
    {
      strlcpy (fullname + off, file->d_name, size);

      if (file->d_type != DT_UNKNOWN)
      {
	 if (file->d_type != DT_REG && file->d_type != DT_LNK)
	   continue;
      }
      else
      {
	struct stat sb;

	if (monitor_stat (fullname, &sb) == -1 || !(sb.st_mode & S_IFREG))
          continue;
      }

      LOG_DBG ((LOG_CRYPTO, 60, "x509_read_from_dir: reading certificate %s",
		file->d_name));
d638 7
a644 8
      certfp = monitor_fopen (fullname, "r");
      if (!certfp)
        { 
          log_error ("x509_read_from_dir: monitor_fopen (\"%s\", \"r\") failed",
                     fullname);
          continue;
        }

d646 1
a646 1
      cert = PEM_read_X509 (certfp, NULL, NULL, NULL);
d648 1
a648 1
      cert = PEM_read_X509 (certfp, NULL, NULL);
d650 1
a650 1
      fclose (certfp);
d652 12
a663 16
      certh = BIO_new (BIO_s_file ());
      if (!certh)
	{
	  log_error ("x509_read_from_dir: BIO_new (BIO_s_file ()) failed");
	  continue;
	}

      if (BIO_read_filename (certh, fullname) == -1)
	{
	  BIO_free (certh);
	  log_error ("x509_read_from_dir: "
		     "BIO_read_filename (certh, \"%s\") failed",
		     fullname);
	  continue;
	}

d665 1
a665 1
      cert = PEM_read_bio_X509 (certh, NULL, NULL, NULL);
d667 1
a667 1
      cert = PEM_read_bio_X509 (certh, NULL, NULL);
d669 23
a691 19
      BIO_free (certh);
#endif	/* USE_PRIVSEP */
      if (cert == NULL)
	{
	  log_print ("x509_read_from_dir: PEM_read_bio_X509 failed for %s",
		     file->d_name);
	  continue;
	}

      if (!X509_STORE_add_cert (ctx, cert))
	{
	  /*
	   * This is actually expected if we have several certificates only
	   * differing in subjectAltName, which is not an something that is
	   * strange.  Consider multi-homed machines.
	   */
	  LOG_DBG ((LOG_CRYPTO, 50,
		    "x509_read_from_dir: X509_STORE_add_cert failed for %s",
		    file->d_name));
d694 1
a694 7
      if (hash)
	if (!x509_hash_enter (cert))
	  log_print ("x509_read_from_dir: x509_hash_enter (%s) failed",
		     file->d_name);
    }

  monitor_closedir (dir);
d696 1
a696 1
  return 1;
d701 1
a701 1
x509_read_crls_from_dir (X509_STORE *ctx, char *name)
d704 1
a704 1
  struct dirent *file;
d706 2
a707 2
  struct monitor_dirents *dir;
  FILE *crlfp;
d709 2
a710 2
  DIR *dir;
  BIO *crlh;
d712 9
a720 11
  X509_CRL *crl;
  char fullname[PATH_MAX];
  int off, size;

  if (strlen (name) >= sizeof fullname - 1)
    {
      log_print ("x509_read_crls_from_dir: directory name too long");
      return 0;
    }

  LOG_DBG ((LOG_CRYPTO, 40, "x509_read_crls_from_dir: reading CRLs from %s",
d723 22
a744 28
  dir = monitor_opendir (name);
  if (!dir)
    {
      LOG_DBG ((LOG_CRYPTO, 10, "x509_read_crls_from_dir: opendir (\"%s\") "
		"failed: %s", name, strerror (errno)));
      return 0;
    }

  strlcpy (fullname, name, sizeof fullname);
  off = strlen (fullname);
  size = sizeof fullname - off;

  while ((file = monitor_readdir (dir)) != NULL)
    {
      strlcpy (fullname + off, file->d_name, size);

      if (file->d_type != DT_UNKNOWN)
      {
	  if (file->d_type != DT_REG && file->d_type != DT_LNK)
	    continue;
      }
      else
      {
	struct stat sb;

	if (monitor_stat (fullname, &sb) == -1 || !(sb.st_mode & S_IFREG))
	  continue;
      }
d746 2
a747 2
      LOG_DBG ((LOG_CRYPTO, 60, "x509_read_crls_from_dir: reading CRL %s",
		file->d_name));
d750 43
a792 6
      crlfp = monitor_fopen (fullname, "r");
      if (!crlfp)
	{
          log_error ("x509_read_crls_from_dir: monitor_fopen (\"%s\", \"r\") "
	             "failed", fullname);
	  continue;
d795 2
a796 46
      crl = PEM_read_X509_CRL (crlfp, NULL, NULL, NULL);
      fclose (crlfp);
#else
      crlh = BIO_new (BIO_s_file ());
      if (!crlh)
	{
	  log_error ("x509_read_crls_from_dir: "
		     "BIO_new (BIO_s_file ()) failed");
	  continue;
	}

      if (BIO_read_filename (crlh, fullname) == -1)
	{
	  BIO_free (crlh);
	  log_error ("x509_read_crls_from_dir: "
		     "BIO_read_filename (crlh, \"%s\") failed", fullname);
	  continue;
	}

      crl = PEM_read_bio_X509_CRL (crlh, NULL, NULL, NULL);

      BIO_free (crlh);
#endif	/* USE_PRIVSEP */
      if (crl == NULL)
	{
	  log_print ("x509_read_crls_from_dir: "
		     "PEM_read_bio_X509_CRL failed for %s", file->d_name);
	  continue;
	}

      if (!X509_STORE_add_crl (ctx, crl))
	{
	  LOG_DBG ((LOG_CRYPTO, 50, "x509_read_crls_from_dir: "
		    "X509_STORE_add_crl failed for %s", file->d_name));
	  continue;
	}

      /*
       * XXX This is to make x509_cert_validate set this (and another) flag
       * XXX when validating certificates. Currently, OpenSSL defaults to
       * XXX reject an otherwise valid certificate (chain) if these flags
       * XXX are set but there are no CRLs to check. The current workaround
       * XXX is to only set the flags if we actually loaded some CRL data.
       */
      X509_STORE_set_flags (ctx, X509_V_FLAG_CRL_CHECK);
    }
d798 1
a798 4
  monitor_closedir (dir);
#endif /* OPENSSL_VERSION_NUMBER >= 0x00907000L */

  return 1;
d803 1
a803 1
x509_cert_init (void)
d805 1
a805 1
  char *dirname;
d807 1
a807 1
  x509_hash_init ();
d809 39
a847 51
  /* Process CA certificates we will trust.  */
  dirname = conf_get_str ("X509-certificates", "CA-directory");
  if (!dirname)
    {
      log_print ("x509_cert_init: no CA-directory");
      return 0;
    }

  /* Free if already initialized.  */
  if (x509_cas)
    X509_STORE_free (x509_cas);

  x509_cas = X509_STORE_new ();
  if (!x509_cas)
    {
      log_print ("x509_cert_init: creating new X509_STORE failed");
      return 0;
    }

  if (!x509_read_from_dir (x509_cas, dirname, 0))
    {
      log_print ("x509_cert_init: x509_read_from_dir failed");
      return 0;
    }

  /* Process client certificates we will accept.  */
  dirname = conf_get_str ("X509-certificates", "Cert-directory");
  if (!dirname)
    {
      log_print ("x509_cert_init: no Cert-directory");
      return 0;
    }

  /* Free if already initialized.  */
  if (x509_certs)
    X509_STORE_free (x509_certs);

  x509_certs = X509_STORE_new ();
  if (!x509_certs)
    {
      log_print ("x509_cert_init: creating new X509_STORE failed");
      return 0;
    }

  if (!x509_read_from_dir (x509_certs, dirname, 1))
    {
      log_print ("x509_cert_init: x509_read_from_dir failed");
      return 0;
    }

  return 1;
d851 1
a851 1
x509_crl_init (void)
d853 5
a857 5
  /*
   * XXX I'm not sure if the method to use CRLs in certificate validation
   * is valid for OpenSSL versions prior to 0.9.7. For now, simply do not
   * support it.
   */
d859 11
a869 13
  char *dirname;
  dirname = conf_get_str ("X509-certificates", "CRL-directory");
  if (!dirname)
    {
      log_print ("x509_crl_init: no CRL-directory");
      return 0;
    }

  if (!x509_read_crls_from_dir (x509_cas, dirname))
    {
      LOG_DBG ((LOG_MISC, 10, "x509_crl_init: x509_read_crls_from_dir failed"));
      return 0;
    }
d871 1
a871 1
  LOG_DBG ((LOG_CRYPTO, 10, "x509_crl_init: CRL support only "
d875 1
a875 1
  return 1;
d879 1
a879 1
x509_cert_get (u_int8_t *asn, u_int32_t len)
d881 1
a881 1
  return x509_from_asn (asn, len);
d885 1
a885 1
x509_cert_validate (void *scert)
d887 11
a897 11
  X509_STORE_CTX csc;
  X509_NAME *issuer, *subject;
  X509 *cert = (X509 *)scert;
  EVP_PKEY *key;
  int res, err;

  /*
   * Validate the peer certificate by checking with the CA certificates we
   * trust.
   */
  X509_STORE_CTX_init (&csc, x509_cas, cert, NULL);
d899 5
a903 6
  /* XXX See comment in x509_read_crls_from_dir.  */
  if (x509_cas->flags & X509_V_FLAG_CRL_CHECK)
    {
      X509_STORE_CTX_set_flags (&csc, X509_V_FLAG_CRL_CHECK);
      X509_STORE_CTX_set_flags (&csc, X509_V_FLAG_CRL_CHECK_ALL);
    }
d905 33
a937 36
  res = X509_verify_cert (&csc);
  err = csc.error;
  X509_STORE_CTX_cleanup (&csc);

  /* Return if validation succeeded or self-signed certs are not accepted.  */
  if (res)
    return 1;
  else if (!conf_get_str ("X509-certificates", "Accept-self-signed"))
    {
      if (err)
	log_print ("x509_cert_validate: %.100s",
		   X509_verify_cert_error_string (err));
      return res;
    }

  issuer = X509_get_issuer_name (cert);
  subject = X509_get_subject_name (cert);

  if (!issuer || !subject || X509_name_cmp (issuer, subject))
    return 0;

  key = X509_get_pubkey (cert);
  if (!key)
    {
      log_print ("x509_cert_validate: could not get public key from "
		 "self-signed cert");
      return 0;
    }

  if (X509_verify (cert, key) == -1)
    {
      log_print ("x509_cert_validate: self-signed cert is bad");
      return 0;
    }

  return 1;
d941 1
a941 1
x509_cert_insert (int id, void *scert)
d943 2
a944 9
  X509 *cert;
  int res;

  cert = X509_dup ((X509 *)scert);
  if (!cert)
    {
      log_print ("x509_cert_insert: X509_dup failed");
      return 0;
    }
d946 5
d952 11
a962 12
  if (x509_generate_kn (id, cert) == 0)
    {
      LOG_DBG ((LOG_POLICY, 50,
		"x509_cert_insert: x509_generate_kn failed"));
      X509_free (cert);
      return 0;
    }
#endif /* USE_POLICY */

  res = x509_hash_enter (cert);
  if (!res)
    X509_free (cert);
d964 1
a964 1
  return res;
d968 1
a968 1
x509_hash_lookup (X509 *cert)
d970 2
a971 2
  int i;
  struct x509_hash *certh;
d973 6
a978 6
  for (i = 0; i <= bucket_mask; i++)
    for (certh = LIST_FIRST (&x509_tab[i]); certh;
	 certh = LIST_NEXT (certh, link))
      if (certh->cert == cert)
	return certh;
  return 0;
d982 1
a982 1
x509_cert_free (void *cert)
d984 1
a984 1
  struct x509_hash *certh = x509_hash_lookup ((X509 *)cert);
d986 3
a988 3
  if (certh)
    LIST_REMOVE (certh, link);
  X509_free ((X509 *)cert);
d993 1
a993 1
x509_certreq_validate (u_int8_t *asn, u_int32_t len)
d995 1
a995 1
  int res = 1;
d997 1
a997 1
  struct norm_type name = SEQOF ("issuer", RDNSequence);
d999 6
a1004 7
  if (!asn_template_clone (&name, 1)
      || (asn = asn_decode_sequence (asn, len, &name)) == 0)
    {
      log_print ("x509_certreq_validate: can not decode 'acceptable CA' info");
      res = 0;
    }
  asn_free (&name);
d1007 1
a1007 1
  /* XXX - not supported directly in SSL - later.  */
d1009 1
a1009 1
  return res;
d1014 1
a1014 1
x509_certreq_decode (u_int8_t *asn, u_int32_t len)
d1017 33
a1049 35
  /* XXX This needs to be done later.  */
  struct norm_type aca = SEQOF ("aca", RDNSequence);
  struct norm_type *tmp;
  struct x509_aca naca, *ret;

  if (!asn_template_clone (&aca, 1)
      || (asn = asn_decode_sequence (asn, len, &aca)) == 0)
    {
      log_print ("x509_certreq_decode: can not decode 'acceptable CA' info");
      goto fail;
    }
  memset (&naca, 0, sizeof (naca));

  tmp = asn_decompose ("aca.RelativeDistinguishedName.AttributeValueAssertion",
		       &aca);
  if (!tmp)
    goto fail;
  x509_get_attribval (tmp, &naca.name1);

  tmp = asn_decompose ("aca.RelativeDistinguishedName[1]"
		       ".AttributeValueAssertion", &aca);
  if (tmp)
    x509_get_attribval (tmp, &naca.name2);

  asn_free (&aca);

  ret = malloc (sizeof (struct x509_aca));
  if (ret)
    memcpy (ret, &naca, sizeof (struct x509_aca));
  else
    {
      log_error ("x509_certreq_decode: malloc (%lu) failed",
		 (unsigned long)sizeof (struct x509_aca));
      x509_free_aca (&aca);
    }
d1051 1
a1051 1
  return ret;
d1053 2
a1054 2
 fail:
  asn_free (&aca);
d1056 1
a1056 1
  return 0;
d1060 1
a1060 1
x509_free_aca (void *blob)
d1062 1
a1062 1
  struct x509_aca *aca = blob;
d1064 9
a1072 9
  if (aca->name1.type)
    free (aca->name1.type);
  if (aca->name1.val)
    free (aca->name1.val);

  if (aca->name2.type)
    free (aca->name2.type);
  if (aca->name2.val)
    free (aca->name2.val);
d1076 1
a1076 1
x509_from_asn (u_char *asn, u_int len)
d1078 2
a1079 2
  BIO *certh;
  X509 *scert = 0;
d1081 17
a1097 23
  certh = BIO_new (BIO_s_mem ());
  if (!certh)
    {
      log_error ("x509_from_asn: BIO_new (BIO_s_mem ()) failed");
      return 0;
    }

  if (BIO_write (certh, asn, len) == -1)
    {
      log_error ("x509_from_asn: BIO_write failed\n");
      goto end;
    }

  scert = d2i_X509_bio (certh, NULL);
  if (!scert)
    {
      log_print ("x509_from_asn: d2i_X509_bio failed\n");
      goto end;
    }

 end:
  BIO_free (certh);
  return scert;
d1105 2
a1106 2
x509_cert_obtain (u_int8_t *id, size_t id_len, void *data, u_int8_t **cert,
		  u_int32_t *certlen)
d1108 2
a1109 2
  struct x509_aca *aca = data;
  X509 *scert;
d1111 17
a1127 19
  if (aca)
    LOG_DBG ((LOG_CRYPTO, 60,
	      "x509_cert_obtain: acceptable certificate authorities here"));

  /* We need our ID to find a certificate.  */
  if (!id)
    {
      log_print ("x509_cert_obtain: ID is missing");
      return 0;
    }

  scert = x509_hash_find (id, id_len);
  if (!scert)
    return 0;

  x509_serialize (scert, cert, certlen);
  if (!*cert)
    return 0;
  return 1;
d1132 1
a1132 1
x509_cert_subjectaltname (X509 *scert, u_int8_t **altname, u_int32_t *len)
d1134 31
a1164 38
  X509_EXTENSION *subjectaltname;
  u_int8_t *sandata;
  int extpos;
  int santype, sanlen;

  extpos = X509_get_ext_by_NID (scert, NID_subject_alt_name, -1);
  if (extpos == -1)
    {
      log_print ("x509_cert_subjectaltname: "
		 "certificate does not contain subjectAltName");
      return 0;
    }

  subjectaltname = X509_get_ext (scert, extpos);

  if (!subjectaltname || !subjectaltname->value
      || !subjectaltname->value->data || subjectaltname->value->length < 4)
    {
      log_print ("x509_cert_subjectaltname: invalid subjectaltname extension");
      return 0;
    }

  /* SSL does not handle unknown ASN stuff well, do it by hand.  */
  sandata = subjectaltname->value->data;
  santype = sandata[2] & 0x3f;
  sanlen = sandata[3];
  sandata += 4;

  if (sanlen + 4 != subjectaltname->value->length)
    {
      log_print ("x509_cert_subjectaltname: subjectaltname invalid length");
      return 0;
    }

  *len = sanlen;
  *altname = sandata;

  return santype;
d1168 2
a1169 2
x509_cert_get_subjects (void *scert, int *cnt, u_int8_t ***id,
			u_int32_t **id_len)
d1171 120
a1290 133
  X509 *cert = scert;
  X509_NAME *subject;
  int type;
  u_int8_t *altname;
  u_int32_t altlen;
  u_int8_t *buf = 0;
  unsigned char *ubuf;
  int i;

  *id = 0;
  *id_len = 0;

  /*
   * XXX There can be a collection of subjectAltNames, but for now
   * I only return the subjectName and a single subjectAltName, if present.
   */
  type = x509_cert_subjectaltname (cert, &altname, &altlen);
  if (!type)
    {
      *cnt = 1;
      altlen = 0;
    }
  else
    *cnt = 2;

  *id = calloc (*cnt, sizeof **id);
  if (!*id)
    {
      log_print ("x509_cert_get_subject: malloc (%lu) failed",
		 *cnt * (unsigned long)sizeof **id);
      goto fail;
    }

  *id_len = malloc (*cnt * sizeof **id_len);
  if (!*id_len)
    {
      log_print ("x509_cert_get_subject: malloc (%lu) failed",
		 *cnt * (unsigned long)sizeof **id_len);
      goto fail;
    }

  /* Stash the subjectName into the first slot.  */
  subject = X509_get_subject_name (cert);
  if (!subject)
    goto fail;

  (*id_len)[0] =
    ISAKMP_ID_DATA_OFF + i2d_X509_NAME (subject, NULL) - ISAKMP_GEN_SZ;
  (*id)[0] = malloc ((*id_len)[0]);
  if (!(*id)[0])
    {
      log_print ("x509_cert_get_subject: malloc (%d) failed", (*id_len)[0]);
      goto fail;
    }
  SET_ISAKMP_ID_TYPE ((*id)[0] - ISAKMP_GEN_SZ, IPSEC_ID_DER_ASN1_DN);
  ubuf = (*id)[0] + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
  i2d_X509_NAME (subject, &ubuf);

  if (altlen)
    {
      /* Stash the subjectAltName into the second slot.  */
      buf = malloc (altlen + ISAKMP_ID_DATA_OFF);
      if (!buf)
	{
	  log_print ("x509_cert_get_subject: malloc (%d) failed",
		     altlen + ISAKMP_ID_DATA_OFF);
	  goto fail;
	}

      switch (type)
	{
	case X509v3_DNS_NAME:
	  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_FQDN);
	  break;

	case X509v3_RFC_NAME:
	  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_USER_FQDN);
	  break;

	case X509v3_IP_ADDR:
	  /*
	   * XXX I dislike the numeric constants, but I don't know what we
	   * should use otherwise.
	   */
	  switch (altlen)
	    {
	    case 4:
	      SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV4_ADDR);
	      break;

	    case 16:
	      SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV6_ADDR);
	      break;

	    default:
	      log_print ("x509_cert_get_subject: "
			 "invalid subjectAltName IPaddress length %d ", altlen);
	      goto fail;
	    }
	  break;
	}

      SET_IPSEC_ID_PROTO (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
      SET_IPSEC_ID_PORT (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
      memcpy (buf + ISAKMP_ID_DATA_OFF, altname, altlen);

      (*id_len)[1] = ISAKMP_ID_DATA_OFF + altlen - ISAKMP_GEN_SZ;
      (*id)[1] = malloc ((*id_len)[1]);
      if (!(*id)[1])
	{
	  log_print ("x509_cert_get_subject: malloc (%d) failed",
		     (*id_len)[1]);
	  goto fail;
	}
      memcpy ((*id)[1], buf + ISAKMP_GEN_SZ, (*id_len)[1]);

      free (buf);
      buf = 0;
    }

  return 1;

 fail:
  for (i = 0; i < *cnt; i++)
    if ((*id)[i])
      free ((*id)[i]);
  if (*id)
    free (*id);
  if (*id_len)
    free (*id_len);
  if (buf)
    free (buf);
  return 0;
d1294 1
a1294 1
x509_cert_get_key (void *scert, void *keyp)
d1296 2
a1297 2
  X509 *cert = scert;
  EVP_PKEY *key;
d1299 1
a1299 1
  key = X509_get_pubkey (cert);
d1301 7
a1307 9
  /* Check if we got the right key type.  */
  if (key->type != EVP_PKEY_RSA)
    {
      log_print ("x509_cert_get_key: public key is not a RSA key");
      X509_free (cert);
      return 0;
    }

  *(RSA **)keyp = RSAPublicKey_dup (key->pkey.rsa);
d1309 1
a1309 1
  return *(RSA **)keyp == NULL ? 0 : 1;
d1313 1
a1313 1
x509_cert_dup (void *scert)
d1315 1
a1315 1
  return X509_dup (scert);
d1319 1
a1319 1
x509_serialize (void *scert, u_int8_t **data, u_int32_t *datalen)
d1321 1
a1321 1
  u_int8_t *p;
d1323 7
a1329 9
  *datalen = i2d_X509 ((X509 *) scert, NULL);
  *data = p = malloc (*datalen);
  if (!p)
    {
      log_error ("x509_serialize: malloc (%d) failed", *datalen);
      return;
    }

  *datalen = i2d_X509 ((X509 *)scert, &p);
d1334 1
a1334 1
x509_printable (void *cert)
d1336 18
a1353 20
  char *s;
  u_int8_t *data;
  u_int32_t datalen, i;

  x509_serialize (cert, &data, &datalen);
  if (!data)
    return 0;

  s = malloc (datalen * 2 + 1);
  if (!s)
    {
      free (data);
      log_error ("x509_printable: malloc (%d) failed", datalen * 2 + 1);
      return 0;
    }

  for (i = 0; i < datalen; i++)
    snprintf (s + (2 * i), 2 * (datalen - i) + 1, "%02x", data[i]);
  free (data);
  return s;
d1358 1
a1358 1
x509_from_printable (char *cert)
d1360 21
a1380 25
  u_int8_t *buf;
  int plen, ret;
  void *foo;

  plen = (strlen (cert) + 1) / 2;
  buf = malloc (plen);
  if (!buf)
    {
      log_error ("x509_from_printable: malloc (%d) failed", plen);
      return 0;
    }

  ret = hex2raw (cert, buf, plen);
  if (ret == -1)
    {
      free (buf);
      log_print ("x509_from_printable: badly formatted cert");
      return 0;
    }

  foo = x509_cert_get (buf, plen);
  free (buf);
  if (!foo)
    log_print ("x509_from_printable: could not retrieve certificate");
  return foo;
d1384 1
a1384 1
x509_DN_string (u_int8_t *asn1, size_t sz)
d1386 18
a1403 20
  X509_NAME *name;
  u_int8_t *p = asn1;
  /* XXX Just a guess at a maximum length.  */
  char buf[256];

  name = d2i_X509_NAME (NULL, &p, sz);
  if (!name)
    {
      log_print ("x509_DN_string: d2i_X509_NAME failed");
      return 0;
    }
  if (!X509_NAME_oneline (name, buf, sizeof buf - 1))
    {
      log_print ("x509_DN_string: X509_NAME_oneline failed");
      X509_NAME_free (name);
      return 0;
    }
  X509_NAME_free (name);
  buf[sizeof buf - 1] = '\0';
  return strdup (buf);
d1405 1
a1405 1
#endif /* USE_X509 */
@


1.86
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.85 2004/01/06 00:09:19 hshoexer Exp $	*/
d525 1
a525 1
  int i;
d1495 1
a1495 2
  u_int32_t datalen;
  int i;
@


1.85
log
@Remove redundant test for file types.  Noted by Stefan Paletta.
While around, fix typos in log messages.

Both ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.84 2003/11/07 10:16:44 jmc Exp $	*/
d62 1
d660 5
a665 1
  struct dirent *file;
d667 1
d681 1
a681 1
  dir = opendir (name);
d693 1
a693 1
  while ((file = readdir (dir)) != NULL)
d706 1
a706 1
	if (stat (fullname, &sb) == -1 || !(sb.st_mode & S_IFREG))
d713 16
d751 1
d777 1
a777 1
  closedir (dir);
d787 5
a792 1
  struct dirent *file;
d794 1
d808 1
a808 1
  dir = opendir (name);
d820 1
a820 1
  while ((file = readdir (dir)) != NULL)
d833 1
a833 1
	if (stat (fullname, &sb) == -1 || !(sb.st_mode & S_IFREG))
d840 12
d871 1
d896 1
a896 1
  closedir (dir);
@


1.84
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.83 2003/11/06 16:12:08 ho Exp $	*/
d678 1
a678 1
      LOG_DBG ((LOG_CRYPTO, 10, "x509_read_from_dir: opendir (\"%s\") failed:"
a703 3
      if (file->d_type != DT_REG && file->d_type != DT_LNK)
	continue;

d773 1
a773 1
      log_print ("x509_read_from_dir: directory name too long");
a808 3
      if (file->d_type != DT_REG && file->d_type != DT_LNK)
	continue;

d941 1
a941 1
      LOG_DBG ((LOG_MISC, 10, "x509_crl_init: x509_read_from_dir failed"));
@


1.83
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.82 2003/06/10 16:41:29 deraadt Exp $	*/
d1372 1
a1372 1
			 "invalid subjectAltName iPAdress length %d ", altlen);
@


1.82
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.81 2003/06/04 07:31:17 ho Exp $	*/
d700 1
a700 1
	if (stat(fullname, &sb) == -1 || !(sb.st_mode & S_IFREG))
d808 1
a808 1
	if (stat(fullname, &sb) == -1 || !(sb.st_mode & S_IFREG))
@


1.81
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.80 2003/06/03 12:51:39 ho Exp $	*/
d172 1
a172 1
  	  X509_STORE_CTX_cleanup (&csc);
d931 1
a931 1
  /* 
d1369 1
a1369 1
	      
@


1.80
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.79 2003/04/09 15:46:48 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.79
log
@Less noise for missing crl dir, demoted to debug message.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.78 2002/12/03 16:08:13 ho Exp $	*/
d305 1
a305 1
	    snprintf (before, 15, "20%s", tm->data);
d307 1
a307 1
	    snprintf (before, 15, "19%s", tm->data);
d340 1
a340 1
	  snprintf (before, 15, "%s", tm->data);
d421 1
a421 1
	    snprintf (after, 15, "20%s", tm->data);
d423 1
a423 1
	    snprintf (after, 15, "19%s", tm->data);
d456 1
a456 1
	  snprintf (after, 15, "%s", tm->data);
@


1.78
log
@LOG_DBG for missing ca/, certs/, crls/ dirs, not
log_error(). Suggested by markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.77 2002/09/11 09:50:44 ho Exp $	*/
d952 1
a952 1
      log_print ("x509_crl_init: x509_read_from_dir failed");
@


1.77
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.76 2002/09/05 15:47:22 ho Exp $	*/
d45 1
d683 2
a684 1
      log_error ("x509_read_from_dir: opendir (\"%s\") failed", name);
d788 1
a788 1
  dir = opendir(name);
d791 2
a792 1
      log_error ("x509_read_crls_from_dir: opendir (\"%s\") failed", name);
@


1.76
log
@Do not require the presence of subjectAltName in certificates used for
IKE auth. Should make interoperating with for example FreeS/WAN easier
(Pluto).
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.75 2002/08/29 12:13:19 ho Exp $	*/
d1283 1
a1283 1
  char *buf = 0;
@


1.75
log
@Work around arguably correct OpenSSL behaviour and only ask for CRL
checks when we actually have CRLs to check against. Problem pointed
out by <sturm@@sec.informatik.tu-darmstadt.de>.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.74 2002/08/07 13:19:20 ho Exp $	*/
d1292 1
a1292 1
   * I only return the subjectName and a single subjectAltName.
d1294 8
a1301 1
  *cnt = 2;
a1323 1

d1336 1
a1336 7
  /* Stash the subjectAltName into the second slot.  */
  type = x509_cert_subjectaltname (cert, &altname, &altlen);
  if (!type)
    goto fail;

  buf = malloc (altlen + ISAKMP_ID_DATA_OFF);
  if (!buf)
d1338 8
a1345 4
      log_print ("x509_cert_get_subject: malloc (%d) failed",
		 altlen + ISAKMP_ID_DATA_OFF);
      goto fail;
    }
d1347 5
a1351 5
  switch (type)
    {
    case X509v3_DNS_NAME:
      SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_FQDN);
      break;
d1353 3
a1355 3
    case X509v3_RFC_NAME:
      SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_USER_FQDN);
      break;
d1357 10
a1366 10
    case X509v3_IP_ADDR:
      /*
       * XXX I dislike the numeric constants, but I don't know what we
       * should use otherwise.
       */
      switch (altlen)
	{
	case 4:
	  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV4_ADDR);
	  break;
d1368 9
a1376 2
	case 16:
	  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV6_ADDR);
d1378 1
d1380 10
a1389 3
	default:
	  log_print ("x509_cert_get_subject: "
		     "invalid subjectAltName iPAdress length %d ", altlen);
d1392 1
a1392 2
      break;
    }
d1394 2
a1395 10
  SET_IPSEC_ID_PROTO (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
  SET_IPSEC_ID_PORT (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
  memcpy (buf + ISAKMP_ID_DATA_OFF, altname, altlen);

  (*id_len)[1] = ISAKMP_ID_DATA_OFF + altlen - ISAKMP_GEN_SZ;
  (*id)[1] = malloc ((*id_len)[1]);
  if (!(*id)[1])
    {
      log_print ("x509_cert_get_subject: malloc (%d) failed", (*id_len)[1]);
      goto fail;
a1396 1
  memcpy ((*id)[1], buf + ISAKMP_GEN_SZ, (*id_len)[1]);
a1397 2
  free (buf);
  buf = 0;
@


1.74
log
@A rewrite of the CRL support code, also from <Thomas.Walpuski@@gmx.net>.
Some style mods, and checks added for OpenSSL version 0.9.7 or later.
Currently CRLs are not supported for earlier versions.
Manual pages updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.73 2002/08/02 13:10:41 ho Exp $	*/
d847 14
a860 2
	LOG_DBG ((LOG_CRYPTO, 50, "x509_read_crls_from_dir: "
		  "X509_STORE_add_crl failed for %s", file->d_name));
d981 6
a986 2
  X509_STORE_CTX_set_flags (&csc, X509_V_FLAG_CRL_CHECK);
  X509_STORE_CTX_set_flags (&csc, X509_V_FLAG_CRL_CHECK_ALL);
@


1.73
log
@CRL support for isakmpd. From <Thomas.Walpuski@@gmx.net> with some minor
modifications by me. ok niklas@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.72 2002/06/10 20:45:35 ho Exp $	*/
d765 92
a917 6
void *
x509_cert_get (u_int8_t *asn, u_int32_t len)
{
  return x509_from_asn (asn, len);
}

d919 1
a919 1
x509_crl_get (X509_STORE_CTX *ctx, X509_CRL **crl, X509 *x)
d921 9
a929 4
  char *crlfile;
  BIO *in;

  if ((crlfile = conf_get_str ("X509-certificates", "CRL-file")) == NULL)
d931 1
a931 1
      LOG_DBG ((LOG_MISC, 10, "x509_crl_get: no CRL-file specified"));
d935 1
a935 1
  if((in = BIO_new (BIO_s_file ())) == NULL)
d937 1
a937 1
      log_print ("x509_crl_get: BIO_new (BIO_s_file ()) failed");
d940 4
d945 2
a946 7
  if (BIO_read_filename (in, crlfile) <= 0)
    {
      log_print ("x509_crl_get: BIO_read_filename (in, \"%s\") failed",
		 crlfile);
      BIO_free (in);
      return 0;
    }
d948 4
a951 10
  *crl = PEM_read_bio_X509_CRL (in, NULL, NULL, NULL);
  BIO_free (in);
  if (*crl == NULL)
    {
      log_print ("x509_crl_get: PEM_read_bio_X509_CRL (in, NULL, NULL, NULL)"
		 " failed");
      return 0;
    }

  return 1;
d968 1
d971 1
a971 1
  csc.get_crl = x509_crl_get;
@


1.72
log
@Zap a few remaining libkeynote refs.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.71 2002/06/10 18:08:59 ho Exp $	*/
d833 38
d884 3
@


1.71
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.70 2002/06/01 07:44:22 deraadt Exp $	*/
a897 1
#ifdef USE_KEYNOTE
d899 6
a904 9
#else
    if (libkeynote && x509_generate_kn (id, cert) == 0)
#endif
      {
	LOG_DBG ((LOG_POLICY, 50,
		  "x509_cert_insert: x509_generate_kn failed"));
	X509_free (cert);
	return 0;
      }
@


1.70
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.69 2002/03/06 10:02:32 ho Exp $	*/
a59 1
#include "dyn.h"
d133 2
a134 2
  issuer = LC (X509_get_issuer_name, (cert));
  subject = LC (X509_get_subject_name, (cert));
d137 1
a137 1
  if (!issuer || !subject || !LC (X509_name_cmp, (issuer, subject)))
d149 3
a151 3
  ikey = LK (kn_encode_key, (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
			     KEYNOTE_PUBLIC_KEY));
  if (LKV (keynote_errno) == ERROR_MEMORY)
d154 1
a154 1
      LC (RSA_free, (key));
d160 1
a160 1
      LC (RSA_free, (key));
d164 1
a164 1
  LC (RSA_free, (key));
d167 2
a168 2
  LC (X509_STORE_CTX_init, (&csc, x509_cas, cert, NULL));
  if (LC (X509_STORE_get_by_subject, (&csc, X509_LU_X509, issuer, &obj)) !=
d171 3
a173 3
      LC (X509_STORE_CTX_cleanup, (&csc));
      LC (X509_STORE_CTX_init, (&csc, x509_certs, cert, NULL));
      if (LC (X509_STORE_get_by_subject, (&csc, X509_LU_X509, issuer, &obj)) !=
d176 1
a176 1
  	  LC (X509_STORE_CTX_cleanup, (&csc));
d183 1
a183 1
  LC (X509_STORE_CTX_cleanup, (&csc));
d202 1
a202 1
  LC (X509_OBJECT_free_contents, (&obj));
d206 3
a208 3
  skey = LK (kn_encode_key, (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
			     KEYNOTE_PUBLIC_KEY));
  if (LKV (keynote_errno) == ERROR_MEMORY)
d212 1
a212 1
      LC (RSA_free, (key));
d220 1
a220 1
      LC (RSA_free, (key));
d224 1
a224 1
  LC (RSA_free, (key));
d472 1
a472 2
  if (LK (kn_add_assertion, (id, buf, strlen (buf),
			     ASSERT_FLAG_LOCAL)) == -1)
d485 1
a485 1
  if (!LC (X509_NAME_oneline, (issuer, isname, 256)))
d492 1
a492 1
  if (!LC (X509_NAME_oneline, (subject, subname, 256)))
d510 1
a510 2
  if (LK (kn_add_assertion, (id, buf, strlen (buf),
			     ASSERT_FLAG_LOCAL)) == -1)
d713 1
a713 1
      certh = LC (BIO_new, (LC (BIO_s_file, ())));
d720 1
a720 1
      if (LC (BIO_read_filename, (certh, fullname)) == -1)
d722 1
a722 1
	  LC (BIO_free, (certh));
d730 1
a730 1
      cert = LC (PEM_read_bio_X509, (certh, NULL, NULL, NULL));
d732 1
a732 1
      cert = LC (PEM_read_bio_X509, (certh, NULL, NULL));
d734 1
a734 1
      LC (BIO_free, (certh));
d742 1
a742 1
      if (!LC (X509_STORE_add_cert, (ctx, cert)))
d783 1
a783 1
    LC (X509_STORE_free, (x509_cas));
d785 1
a785 1
  x509_cas = LC (X509_STORE_new, ());
d808 1
a808 1
    LC (X509_STORE_free, (x509_certs));
d810 1
a810 1
  x509_certs = LC (X509_STORE_new, ());
a828 9
#ifndef USE_LIBCRYPTO
  /*
   * If we don't have a statically linked libcrypto, the dlopen must have
   * succeeded for X.509 to be usable.
   */
  if (!libcrypto)
    return 0;
#endif

d845 2
a846 2
  LC (X509_STORE_CTX_init, (&csc, x509_cas, cert, NULL));
  res = LC (X509_verify_cert, (&csc));
d848 1
a848 1
  LC (X509_STORE_CTX_cleanup, (&csc));
d857 1
a857 1
		   LC (X509_verify_cert_error_string, (err)));
d861 2
a862 2
  issuer = LC (X509_get_issuer_name, (cert));
  subject = LC (X509_get_subject_name, (cert));
d864 1
a864 1
  if (!issuer || !subject || LC (X509_name_cmp, (issuer, subject)))
d867 1
a867 1
  key = LC (X509_get_pubkey, (cert));
d875 1
a875 1
  if (LC (X509_verify, (cert, key)) == -1)
d890 1
a890 1
  cert = LC (X509_dup, ((X509 *)scert));
d906 1
a906 1
	LC (X509_free, (cert));
d913 1
a913 1
    LC (X509_free, (cert));
d939 1
a939 1
  LC (X509_free, ((X509 *)cert));
d1035 1
a1035 1
  certh = LC (BIO_new, (LC (BIO_s_mem, ())));
d1042 1
a1042 1
  if (LC (BIO_write, (certh, asn, len)) == -1)
d1048 1
a1048 1
  scert = LC (d2i_X509_bio, (certh, NULL));
d1056 1
a1056 1
  LC (BIO_free, (certh));
d1101 1
a1101 1
  extpos = LC (X509_get_ext_by_NID, (scert, NID_subject_alt_name, -1));
d1109 1
a1109 1
  subjectaltname = LC (X509_get_ext, (scert, extpos));
d1175 1
a1175 1
  subject = LC (X509_get_subject_name, (cert));
d1181 1
a1181 1
    ISAKMP_ID_DATA_OFF + LC (i2d_X509_NAME, (subject, NULL)) - ISAKMP_GEN_SZ;
d1190 1
a1190 1
  LC (i2d_X509_NAME, (subject, &ubuf));
d1274 1
a1274 1
  key = LC (X509_get_pubkey, (cert));
d1280 1
a1280 1
      LC (X509_free, (cert));
d1284 1
a1284 1
  *(RSA **)keyp = LC (RSAPublicKey_dup, (key->pkey.rsa));
d1292 1
a1292 1
  return LC (X509_dup, (scert));
d1300 1
a1300 1
  *datalen = LC (i2d_X509, ((X509 *) scert, NULL));
d1308 1
a1308 1
  *datalen = LC (i2d_X509, ((X509 *)scert, &p));
d1377 1
a1377 1
  name = LC (d2i_X509_NAME, (NULL, &p, sz));
d1383 1
a1383 1
  if (!LC (X509_NAME_oneline, (name, buf, sizeof buf - 1)))
d1386 1
a1386 1
      LC (X509_NAME_free, (name));
d1389 1
a1389 1
  LC (X509_NAME_free, (name));
@


1.69
log
@Fix a couple of snprintf length bugs. Same problem <chris@@stallion.oz.au>
found for policy passphrases.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.68 2002/01/23 18:44:48 ho Exp $	*/
d573 2
a574 2
    log_fatal ("x509_hash_init: malloc (%d) failed",
	       (bucket_mask + 1) * sizeof (struct x509_list));
d643 2
a644 1
          log_error ("x509_hash_enter: calloc (1, %d) failed", sizeof *certh);
d1012 2
a1013 2
      log_error ("x509_certreq_decode: malloc (%d) failed",
		 sizeof (struct x509_aca));
d1173 2
a1174 2
      log_print ("x509_cert_get_subject: malloc (%d) failed",
		 *cnt * sizeof **id);
d1181 2
a1182 2
      log_print ("x509_cert_get_subject: malloc (%d) failed",
		 *cnt * sizeof **id_len);
@


1.68
log
@the last few sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.67 2002/01/23 17:26:21 ho Exp $	*/
d1335 1
a1335 1
  s = malloc (datalen * 2);
d1339 1
a1339 1
      log_error ("x509_printable: malloc (%d) failed", datalen * 2);
d1344 1
a1344 1
    snprintf (s + (2 * i), 2 * (datalen - i), "%02x", data[i]);
@


1.67
log
@strcpy->strlcpy, sprintf->snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.66 2002/01/03 09:24:02 ho Exp $	*/
d1344 1
a1344 1
    sprintf (s + (2 * i), "%02x", data[i]);
@


1.66
log
@strftime format fixes. From Christo Butcher <christo@@fox-it.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.65 2001/08/25 22:17:13 niklas Exp $	*/
d128 1
a128 1
  int i;
d227 3
a229 2
  buf = calloc (strlen (fmt) + strlen (ikey) + strlen (skey) + 56,
		sizeof (char));
d305 1
a305 1
	    sprintf (before, "20%s", tm->data);
d307 1
a307 1
	    sprintf (before, "19%s", tm->data);
d340 1
a340 1
	  sprintf (before, "%s", tm->data);
d421 1
a421 1
	    sprintf (after, "20%s", tm->data);
d423 1
a423 1
	    sprintf (after, "19%s", tm->data);
d456 1
a456 1
	  sprintf (after, "%s", tm->data);
d469 1
a469 1
  sprintf (buf, fmt, skey, ikey, timecomp, before, timecomp2, after);
d501 2
a502 1
  buf = malloc (strlen (fmt2) + strlen (isname) + strlen (subname) + 56);
d505 1
a505 2
      log_error ("x509_generate_kn: malloc (%d) failed", strlen (fmt2) +
		 strlen (isname) + strlen (subname) + 56);
d509 2
a510 1
  sprintf (buf, fmt2, isname, subname, timecomp, before, timecomp2, after);
d688 1
a688 2
  strncpy (fullname, name, sizeof fullname - 1);
  fullname[sizeof fullname - 1] = 0;
d690 1
a690 1
  size = sizeof fullname - off - 1;
d694 1
a694 2
      strncpy (fullname + off, file->d_name, size);
      fullname[off + size] = 0;
@


1.65
log
@Add x509_DN_string API to get a printable DN component given one
rpresented in ASN.1
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.64 2001/08/16 14:23:21 ho Exp $	*/
d242 1
a242 1
      strftime (before, 14, "%G%m%d%H%M%S", localtime (&tt));
d358 1
a358 1
      strftime (after, 14, "%G%m%d%H%M%S", localtime (&tt));
@


1.64
log
@Don't right-justify this debug message.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.63 2001/07/13 14:16:39 ho Exp $	*/
d1378 25
@


1.63
log
@Be more verbose about why X509_verify_cert() failed. Thanks to
<sakane@@kame.net> for pointing out X509_verify_cert_error_string(). :)
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.62 2001/07/05 12:37:00 ho Exp $	*/
d867 1
a867 1
	log_print ("x509_cert_validate: %100s",
@


1.62
log
@Add prototypes and some other various cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.61 2001/07/05 07:28:00 angelos Exp $	*/
d850 1
a850 1
  int res;
d858 1
d862 9
a870 2
  if (res || !conf_get_str ("X509-certificates", "Accept-self-signed"))
    return res;
d880 5
a884 1
    return 0;
d887 4
a890 1
    return 0;
@


1.61
log
@On closer inspection, freeing the X509 names is bad. I should stop
coding late while half-asleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.59 2001/07/01 19:48:44 niklas Exp $	*/
d72 5
d526 1
a526 1
u_int16_t
d547 2
a548 2
void
x509_hash_init ()
d580 1
a580 1
X509 *
d620 1
a620 1
int
@


1.60
log
@Free X509 names in case of failure and when done.
@
text
@d134 1
a134 7
    {
      if (issuer)
	LC (X509_NAME_free, (issuer));
      if (subject)
	LC (X509_NAME_free, (subject));
      return 1;
    }
a137 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a149 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
d155 1
a155 3
    { 
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a171 2
	  LC (X509_NAME_free, (issuer));
	  LC (X509_NAME_free, (subject));
a183 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a191 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a207 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a215 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a225 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a258 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a271 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a290 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a308 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a327 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a374 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a387 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a406 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a424 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a443 2
	      LC (X509_NAME_free, (issuer));
	      LC (X509_NAME_free, (subject));
a471 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a484 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a491 2
      LC (X509_NAME_free, (issuer));
      LC (X509_NAME_free, (subject));
a493 4

  /* Don't need them anymore */
  LC (X509_NAME_free, (issuer));
  LC (X509_NAME_free, (subject));
@


1.59
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.58 2001/06/22 16:21:43 provos Exp $	*/
d134 7
a140 1
    return 1;
d144 2
d158 2
d165 3
a167 1
    {
d184 2
d198 2
d208 2
d226 2
d236 2
d248 2
d283 2
d298 2
d319 2
d339 2
d360 2
d409 2
d424 2
d445 2
d465 2
d486 2
d516 2
d531 2
d540 2
d544 4
@


1.58
log
@fix for filesystems where readdir does not return d_type, use stat instead.
okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.57 2001/06/07 07:35:15 angelos Exp $	*/
d236 1
a236 1
      tt = time ((time_t) NULL);
@


1.57
log
@log_error -> log_print
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.56 2001/06/07 04:46:45 angelos Exp $	*/
d688 16
a715 3

      strncpy (fullname + off, file->d_name, size);
      fullname[off + size] = 0;
@


1.56
log
@No need to allocate/free X509 policy information -- the certs are
converted as needed, and the CA certs are irrelevant.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.55 2001/06/07 04:23:35 angelos Exp $	*/
d721 1
a721 1
	  log_error ("x509_read_from_dir: PEM_read_bio_X509 failed for %s",
@


1.55
log
@Get rid of the main policy session (unnecessary).
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.54 2001/06/05 10:11:42 angelos Exp $	*/
a118 1
  char **new_asserts;
d467 2
a468 2
  /* If we've been given a session, add it there */
  if (id != -1)
d470 4
a473 11
      if (LK (kn_add_assertion, (id, buf, strlen (buf),
				 ASSERT_FLAG_LOCAL)) == -1)
	{
	  LOG_DBG ((LOG_POLICY, 30,
		    "x509_generate_kn: failed to add new KeyNote credential"));
	  free (buf);
	  return 0;
	}

      /* We could print the assertion here, but log_print() truncates...  */
      LOG_DBG ((LOG_POLICY, 60, "x509_generate_kn: added credential"));
a474 37
  else
    {
      /* We could print the assertion here, but log_print() truncates...  */
      LOG_DBG ((LOG_POLICY, 60, "x509_generate_kn: adding policy"));

      /* Store the X509-derived assertion so we can use it as a policy.  */
      if (x509_policy_asserts_num == 0)
	{
	  x509_policy_asserts = calloc (4, sizeof (char *));
	  if (!x509_policy_asserts)
	    {
	      log_error ("x509_generate_kn: failed to allocate %d bytes",
			 4 * sizeof (char *));
	      free (buf);
	      return 0;
	    }

	  x509_policy_asserts_num_alloc = 4;
	  x509_policy_asserts_num = 1;
	  x509_policy_asserts[0] = buf;
	}
      else
	{
	  if (x509_policy_asserts_num + 1 > x509_policy_asserts_num_alloc)
	    {
	      x509_policy_asserts_num_alloc *= 2;
	      new_asserts = realloc (x509_policy_asserts,
				     x509_policy_asserts_num_alloc
				     * sizeof (char *));
	      if (!new_asserts)
		{
		  x509_policy_asserts_num_alloc /= 2;
		  log_error ("x509_generate_kn: failed to allocate %d bytes",
			     x509_policy_asserts_num_alloc * sizeof (char *));
		  free (buf);
		  return 0;
		}
d476 2
a477 7
	      x509_policy_asserts = new_asserts;
	    }

	  /* Assign to the next available.  */
	  x509_policy_asserts[x509_policy_asserts_num++] = buf;
	}
    }
d505 2
a506 1
  if (id != -1)
d508 4
a511 11
      if (LK (kn_add_assertion, (id, buf, strlen (buf),
				 ASSERT_FLAG_LOCAL)) == -1)
	{
	  LOG_DBG ((LOG_POLICY, 30,
		    "x509_generate_kn: failed to add new KeyNote credential"));
	  free (buf);
	  return 0;
	}

      LOG_DBG ((LOG_POLICY, 80, "x509_generate_kn: added credential:\n%s",
		buf));
a512 3
  else
    {
      LOG_DBG ((LOG_POLICY, 80, "x509_generate_kn: adding policy:\n%s", buf));
d514 1
a514 40
      /* Store the X509-derived assertion so we can use it as a policy.  */
      if (x509_policy_asserts_num == 0)
	{
	  x509_policy_asserts = calloc (4, sizeof (char *));
	  if (!x509_policy_asserts)
	    {
	      log_error ("x509_generate_kn: failed to allocate %d bytes",
			 4 * sizeof (char *));
	      free (buf);
	      return 0;
	    }

	  x509_policy_asserts_num_alloc = 4;
	  x509_policy_asserts_num = 1;
	  x509_policy_asserts[0] = buf;
	}
      else
	{
	  if (x509_policy_asserts_num + 1 > x509_policy_asserts_num_alloc)
	    {
	      x509_policy_asserts_num_alloc *= 2;
	      new_asserts = realloc (x509_policy_asserts,
				     x509_policy_asserts_num_alloc
				     * sizeof (char *));
	      if (!new_asserts)
		{
		  x509_policy_asserts_num_alloc /= 2;
		  log_error ("x509_generate_kn: failed to allocate %d bytes",
			     x509_policy_asserts_num_alloc * sizeof (char *));
		  free (buf);
		  return 0;
		}

	      x509_policy_asserts = new_asserts;
	    }

	  /* Assign to the next available.  */
	  x509_policy_asserts[x509_policy_asserts_num++] = buf;
	}
    }
d516 1
d739 3
a741 17
	{
	  if (!x509_hash_enter (cert))
	    log_print ("x509_read_from_dir: x509_hash_enter (%s) failed",
		       file->d_name);
	}
      else
	{
#ifdef USE_POLICY
#ifdef USE_KEYNOTE
	  if (x509_generate_kn (-1, cert) == 0)
#else
	    if (libkeynote && x509_generate_kn (-1, cert) == 0)
#endif
	      LOG_DBG ((LOG_POLICY, 50,
			"x509_read_from_dir: x509_generate_kn failed"));
#endif /* USE_POLICY */
	}
a753 3
#if defined(USE_KEYNOTE) || defined(USE_POLICY)
  int i;
#endif
a755 15

#if defined(USE_KEYNOTE) || defined(USE_POLICY)
  /* Cleanup */
  if (x509_policy_asserts)
    {
      for (i = 0; i < x509_policy_asserts_num; i++)
        if (x509_policy_asserts[i])
          free (x509_policy_asserts[i]);

      free (x509_policy_asserts);
    }

  x509_policy_asserts = 0;
  x509_policy_asserts_num = x509_policy_asserts_num_alloc = 0;
#endif
@


1.54
log
@log_error() cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.53 2001/06/05 06:51:05 angelos Exp $	*/
d106 1
a106 1
x509_generate_kn (X509 *cert)
d468 2
a469 2
  if (LK (kn_add_assertion, (keynote_sessid, buf, strlen (buf),
			     ASSERT_FLAG_LOCAL)) == -1)
d471 11
a481 4
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to add new KeyNote credential"));
      free (buf);
      return 0;
d483 4
d488 40
a527 1
  /* We could print the assertion here, but log_print() truncates...  */
d555 1
a555 2
  if (LK (kn_add_assertion, (keynote_sessid, buf, strlen (buf),
			     ASSERT_FLAG_LOCAL)) == -1)
d557 2
a558 13
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to add new KeyNote credential"));
      free (buf);
      return 0;
    }
  else
    LOG_DBG ((LOG_POLICY, 80, "x509_generate_kn: added policy:\n%s", buf));

  /* Store the X509-derived assertion so we can use it as a policy.  */
  if (x509_policy_asserts_num == 0)
    {
      x509_policy_asserts = calloc (4, sizeof (char *));
      if (!x509_policy_asserts)
d560 2
a561 2
	  log_error ("x509_generate_kn: failed to allocate %d bytes",
		     4 * sizeof (char *));
d566 2
a567 3
      x509_policy_asserts_num_alloc = 4;
      x509_policy_asserts_num = 1;
      x509_policy_asserts[0] = buf;
d571 4
a574 1
      if (x509_policy_asserts_num + 1 > x509_policy_asserts_num_alloc)
d576 2
a577 5
	  x509_policy_asserts_num_alloc *= 2;
	  new_asserts = realloc (x509_policy_asserts,
				 x509_policy_asserts_num_alloc
				 * sizeof (char *));
	  if (!new_asserts)
a578 1
	      x509_policy_asserts_num_alloc /= 2;
d580 1
a580 1
			 x509_policy_asserts_num_alloc * sizeof (char *));
d585 3
a587 1
	  x509_policy_asserts = new_asserts;
d589 19
d609 3
a611 2
      /* Assign to the next available.  */
      x509_policy_asserts[x509_policy_asserts_num++] = buf;
a613 8
  /*
   * XXX Should add a remove-assertion event set to the expiration of the
   * X509 cert (and remove such events when we reinit and close the keynote
   * session)  -- that's relevant only for really long-lived daemons.
   * Alternatively (and preferably), we can encode the X509 expiration
   * in the KeyNote Conditions.
   */

a836 1

d840 3
d845 1
a845 1
	  if (x509_generate_kn (cert) == 0)
d847 1
a847 1
	    if (libkeynote && x509_generate_kn (cert) == 0)
d871 15
a929 15
#if defined(USE_KEYNOTE) || defined(USE_POLICY)
  /* Cleanup */
  if (x509_policy_asserts)
    {
      for (i = 0; i < x509_policy_asserts_num; i++)
        if (x509_policy_asserts[i])
          free (x509_policy_asserts[i]);

      free (x509_policy_asserts);
    }

  x509_policy_asserts = 0;
  x509_policy_asserts_num = x509_policy_asserts_num_alloc = 0;
#endif

d1006 1
a1006 1
  if (x509_generate_kn (cert) == 0)
d1008 1
a1008 1
    if (libkeynote && x509_generate_kn (cert) == 0)
@


1.53
log
@Bad niklas, re-committed redundant code.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.52 2001/06/05 05:59:43 niklas Exp $	*/
d1413 1
a1413 1
      log_error ("x509_from_printable: badly formatted cert");
d1420 1
a1420 1
    log_error ("x509_from_printable: could not retrieve certificate");
@


1.52
log
@Style issues and commentary
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.51 2001/05/31 20:20:59 angelos Exp $	*/
a1139 9

  *certlen = LC (i2d_X509, (scert, NULL));
  p = *cert = malloc (*certlen);
  if (!p)
    {
      log_error ("x509_cert_obtain: malloc (%d) failed", *certlen);
      return 0;
    }
  *certlen = LC (i2d_X509, (scert, &p));
@


1.51
log
@New routines for handling X509 cert representation.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.50 2001/05/12 06:46:58 angelos Exp $	*/
d1032 1
a1032 1
      log_print ("x509_certreq_validate: can not decode 'acceptable CA' info");
d1141 9
d1151 1
a1151 1
  if (*cert == NULL)
d1385 2
a1386 2
  if (data == NULL)
    return NULL;
d1389 1
a1389 1
  if (s == NULL)
d1393 1
a1393 1
      return NULL;
d1412 1
a1412 1
  if (buf == NULL)
d1415 1
a1415 1
      return NULL;
d1423 1
a1423 1
      return NULL;
d1428 1
a1428 1
  if (foo == NULL)
@


1.50
log
@size_t -> u_int32_t (mcmahill@@mtl.mit.edu)
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.49 2001/04/12 15:50:02 ho Exp $	*/
d69 1
a1124 1
  u_char *p;
d1141 3
a1143 9
  *certlen = LC (i2d_X509, (scert, NULL));
  p = *cert = malloc (*certlen);
  if (!p)
    {
      log_error ("x509_cert_obtain: malloc (%d) failed", *certlen);
      return 0;
    }
  *certlen = LC (i2d_X509, (scert, &p));

d1344 79
@


1.49
log
@Correct various faulty x509 deallocations. By Niklas and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.48 2001/04/09 22:09:53 ho Exp $	*/
d626 1
a626 1
  size_t *clen;
@


1.48
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.47 2001/04/03 13:59:12 ho Exp $	*/
d601 1
a601 1
             certh = LIST_NEXT (certh, link))
a603 1
	    LC (X509_free, (certh->cert));
d972 14
d989 4
@


1.47
log
@Don't free reallocated memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.46 2001/03/27 16:50:35 ho Exp $	*/
d334 1
a334 1
	  sprintf(before, "%s", tm->data);
d450 1
a450 1
	  sprintf(after, "%s", tm->data);
d1202 1
a1202 1
  *id = calloc(*cnt, sizeof **id);
d1210 1
a1210 1
  *id_len = malloc(*cnt * sizeof **id_len);
@


1.46
log
@Allocate a buffer large enough to contain the generated assertion.
Found with ElectricFence.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.45 2001/03/14 21:13:24 tholo Exp $	*/
a547 1
	  free (x509_policy_asserts);
@


1.45
log
@Make these compile again...
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.44 2001/03/14 12:15:46 niklas Exp $	*/
d494 1
a494 2

  buf = malloc (strlen (fmt2) + strlen (isname) + strlen (subname));
d497 2
a498 2
      log_error ("x509_generate_kn: malloc (%d) failed",
		 strlen (fmt2) + strlen (isname) + strlen (subname));
@


1.44
log
@Indentation and style fascism
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.43 2001/03/13 14:05:19 ho Exp $	*/
d349 1
a349 1
  if (tm == NULL)
@


1.43
log
@Add logging classes for Negotiation and Policy, and change a number of
debug messages to use these instead. Change a number of 'log_print'
to debug messages to keep the noise down. Use 'log_error' instead of
'log_print' in some cases when we have errno. Some indentation fixes.
(niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.42 2001/02/23 15:29:55 angelos Exp $	*/
d71 1
a71 1
/* 
d101 2
a102 2
 * Issuer/Subject -> Authorizer/Licensees,
 * XXX RSA-specific
d107 2
a108 1
  char *fmt = "Authorizer: \"rsa-hex:%s\"\nLicensees: \"rsa-hex:%s\"\nConditions: %s >= \"%s\" && %s <= \"%s\";\n";
d110 2
a111 1
  char *fmt2 = "Authorizer: \"DN:%s\"\nLicensees: \"DN:%s\"\nConditions: %s >= \"%s\" && %s <= \"%s\";\n";
d134 1
a134 1
      return 1;
d138 1
a138 1
      LOG_DBG ((LOG_POLICY, 30, 
d162 1
a162 1
  /* Now find issuer's certificate so we can get the public key */
d173 1
a173 1
	  LOG_DBG ((LOG_POLICY, 30, 
d192 1
a192 1
      LOG_DBG ((LOG_POLICY, 30, 
d278 10
a287 10
	  /* Validity checks */
	  if ((tm->data[2] != '0' && tm->data[2] != '1') ||
	      (tm->data[2] == '0' && tm->data[3] == '0') ||
	      (tm->data[2] == '1' && tm->data[3] > '2') ||
	      (tm->data[4] > '3') ||
	      (tm->data[4] == '0' && tm->data[5] == '0') ||
	      (tm->data[4] == '3' && tm->data[5] > '1') ||
	      (tm->data[6] > '2') ||
	      (tm->data[6] == '2' && tm->data[7] > '3') ||
	      (tm->data[8] > '5'))
d297 1
a297 1
	  /* Stupid UTC tricks */
d315 10
a324 10
	  /* Validity checks */
	  if ((tm->data[4] != '0' && tm->data[4] != '1') ||
	      (tm->data[4] == '0' && tm->data[5] == '0') ||
	      (tm->data[4] == '1' && tm->data[5] > '2') ||
	      (tm->data[6] > '3') ||
	      (tm->data[6] == '0' && tm->data[7] == '0') ||
	      (tm->data[6] == '3' && tm->data[7] > '1') ||
	      (tm->data[8] > '2') ||
	      (tm->data[8] == '2' && tm->data[9] > '3') ||
	      (tm->data[10] > '5'))
d337 1
a337 1
      /* Fix missing seconds */
d344 2
a345 1
      before[14] = '\0'; /* This will overwrite trailing 'Z' */
d348 3
a350 2
  if (((tm = X509_get_notAfter (cert)) == NULL) &&
      (tm->type != V_ASN1_UTCTIME && tm->type != V_ASN1_GENERALIZEDTIME))
d352 1
a352 1
      tt = time ((time_t) NULL);
d394 10
a403 10
	  /* Validity checks */
	  if ((tm->data[2] != '0' && tm->data[2] != '1') ||
	      (tm->data[2] == '0' && tm->data[3] == '0') ||
	      (tm->data[2] == '1' && tm->data[3] > '2') ||
	      (tm->data[4] > '3') ||
	      (tm->data[4] == '0' && tm->data[5] == '0') ||
	      (tm->data[4] == '3' && tm->data[5] > '1') ||
	      (tm->data[6] > '2') ||
	      (tm->data[6] == '2' && tm->data[7] > '3') ||
	      (tm->data[8] > '5'))
d413 1
a413 1
	  /* Stupid UTC tricks */
d431 10
a440 10
	  /* Validity checks */
	  if ((tm->data[4] != '0' && tm->data[4] != '1') ||
	      (tm->data[4] == '0' && tm->data[5] == '0') ||
	      (tm->data[4] == '1' && tm->data[5] > '2') ||
	      (tm->data[6] > '3') ||
	      (tm->data[6] == '0' && tm->data[7] == '0') ||
	      (tm->data[6] == '3' && tm->data[7] > '1') ||
	      (tm->data[8] > '2') ||
	      (tm->data[8] == '2' && tm->data[9] > '3') ||
	      (tm->data[10] > '5'))
d453 1
a453 1
      /* Fix missing seconds */
d470 1
a470 1
      LOG_DBG ((LOG_POLICY, 30, 
d482 1
a482 1
      LOG_DBG ((LOG_POLICY, 50, 
d489 1
a489 1
      LOG_DBG ((LOG_POLICY, 50, 
d508 1
a508 1
      LOG_DBG ((LOG_POLICY, 30, 
d516 1
a516 1
  /* Store the X509-derived assertion so we can use it as a policy */
d553 1
a553 1
      /* Assign to the next available */
d557 2
a558 3
  /* 
   * XXX
   * Should add a remove-assertion event set to the expiration of the
a562 1
   * XXX
d584 1
a584 1
 
d598 1
a598 1
  /* If reinitializing, free existing entries */
d604 5
a608 5
	    {
	      LIST_REMOVE (certh, link);
              LC (X509_free, (certh->cert));
              free (certh);
	    }
d681 1
a681 1
      certh = malloc (sizeof *certh);
d685 1
a685 1
          log_error ("x509_hash_enter: malloc (%d) failed", sizeof *certh);
a687 1
      memset (certh, 0, sizeof *certh);
d694 1
a694 1
      LOG_DBG ((LOG_CRYPTO, 70, "x509_hash_enter: cert %p added to bucket %d", 
d722 1
a722 1
  
d799 1
a799 1
	      LOG_DBG ((LOG_POLICY, 50, 
d829 1
a829 1
  /* Free if already initialized */
d854 1
a854 1
  /* Free if already initialized */
d896 1
a896 1
   */ 
d927 1
a927 1
  
d958 1
a958 1
  if (libkeynote && x509_generate_kn (cert) == 0)
d960 6
a965 5
    {
      LOG_DBG ((LOG_POLICY, 50, "x509_cert_insert: x509_generate_kn failed"));
      LC (X509_free, (cert));
      return 0;
    }
d998 1
a998 1
  /* XXX - not supported directly in SSL - later */
d1031 1
a1031 1
  
d1080 1
a1080 1
	  
d1170 1
a1170 1
  if (sanlen + 4 != subjectaltname->value->length) 
d1175 1
a1175 1
  
d1225 1
a1225 1
  
d1229 1
a1229 1
  if (!(*id)[0]) 
d1290 1
a1290 1
  if (!(*id)[1]) 
d1313 1
a1313 1
 
d1322 1
a1322 1
  /* Check if we got the right key type */
@


1.42
log
@Allocate larger buffer for generated policies.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.41 2001/02/18 23:16:14 angelos Exp $	*/
d123 1
a123 1
  LOG_DBG ((LOG_CRYPTO, 90,
d136 2
a137 1
      log_print ("x509_generate_kn: failed to get public key from cert");
d149 1
a149 1
      log_print ("x509_generate_kn: cannot get subject key");
d155 1
a155 1
      log_print ("x509_generate_kn: cannot get subject key");
d171 2
a172 1
	  log_print ("x509_generate_kn: no certificate found for issuer");
d182 2
a183 2
      log_print ("x509_generate_kn: "
		 "missing certificates, cannot construct X509 chain");
d190 2
a191 1
      log_print ("x509_generate_kn: failed to get public key from cert");
d207 1
a207 1
      log_print ("x509_generate_kn: cannot get issuer key");
d215 1
a215 1
      log_print ("x509_generate_kn: cannot get issuer key");
d255 6
a260 6
		log_error ("x509_generate_kn: invalid data in "
			   "NotValidBefore time field");
		free (ikey);
		free (skey);
		free (buf);
		return 0;
d268 2
a269 3
	      log_error ("x509_generate_kn: "
			 "invalid length of NotValidBefore time field (%d)",
			 tm->length);
d287 6
a292 6
		log_error ("x509_generate_kn: invalid value in "
			   "NotValidBefore time field");
		free (ikey);
		free (skey);
		free (buf);
		return 0;
d305 2
a306 3
	      log_error ("x509_generate_kn: "
			 "invalid length of NotValidBefore time field (%d)",
			 tm->length);
d324 6
a329 6
		log_error ("x509_generate_kn: invalid value in "
			   "NotValidBefore time field");
		free (ikey);
		free (skey);
		free (buf);
		return 0;
d369 6
a374 6
		log_error ("x509_generate_kn: invalid data in "
			   "NotValidAfter time field");
		free (ikey);
		free (skey);
		free (buf);
		return 0;
d382 2
a383 3
	      log_error ("x509_generate_kn: "
			 "invalid length of NotValidAfter time field (%d)",
			 tm->length);
d401 6
a406 6
		log_error ("x509_generate_kn: invalid value in "
			   "NotValidAfter time field");
		free (ikey);
		free (skey);
		free (buf);
		return 0;
d419 2
a420 3
	      log_error ("x509_generate_kn: "
			 "invalid length of NotValidAfter time field (%d)",
			 tm->length);
d438 6
a443 6
		log_error ("x509_generate_kn: invalid value in "
			   "NotValidAfter time field");
		free (ikey);
		free (skey);
		free (buf);
		return 0;
d466 2
a467 1
      log_error ("x509_generate_kn: failed to add new KeyNote credential");
d478 2
a479 1
      log_print ("x509_generate_kn: X509_NAME_oneline (issuer, ...) failed");
d485 2
a486 1
      log_print ("x509_generate_kn: X509_NAME_oneline (subject, ...) failed");
d504 2
a505 1
      log_error ("x509_generate_kn: failed to add new KeyNote credential");
d510 1
a510 1
    LOG_DBG ((LOG_CRYPTO, 80, "x509_generate_kn: added policy:\n%s", buf));
d798 2
a799 1
	      log_print ("x509_read_from_dir: x509_generate_kn failed");
d960 1
a960 1
      log_print ("x509_cert_insert: x509_generate_kn failed");
@


1.41
log
@Encode the X509 expiration in the KeyNote credential/policies
generated on the fly.

For the record, this commit done at the beach in Cayman Islands :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.40 2001/02/08 22:37:45 angelos Exp $	*/
d217 2
a218 1
  buf = calloc (strlen (fmt) + strlen (ikey) + strlen (skey), sizeof (char));
@


1.40
log
@Typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.39 2001/01/27 12:03:36 niklas Exp $	*/
d107 1
a107 1
  char *fmt = "Authorizer: \"rsa-hex:%s\"\nLicensees: \"rsa-hex:%s\"\n";
d109 1
a109 1
  char *fmt2 = "Authorizer: \"DN:%s\"\nLicensees: \"DN:%s\"\n";
d117 5
d227 233
a459 1
  sprintf (buf, fmt, skey, ikey);
d496 1
a496 1
  sprintf (buf, fmt2, isname, subname);
@


1.39
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.38 2001/01/26 16:40:52 niklas Exp $	*/
d432 1
a432 1
      log_print ("x509_hash_enter: can not retrieve subjects");
@


1.38
log
@There is no need to check the subjectAltName anymore, since we are in fact
looking up the certificate via the name.  The lookup method already
guarantees a match.  It is also a problem to look at the subjectAltName
should we have got the certificate with no such name in it.  Prodded by
mickey@@ although I solved the problem in a different way.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.37 2001/01/26 12:12:52 niklas Exp $	*/
d6 2
a7 2
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000 Angelos D. Keromytis.  All rights reserved.
a50 4
#if MP_FLAVOUR == MP_FLAVOUR_GMP
#include <gmp.h>
#endif

a63 1
#include "sa.h"
d66 1
d68 1
@


1.37
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.36 2001/01/26 11:09:12 niklas Exp $	*/
a858 67
 * Check that a certificate has a subjectAltName and that it matches our ID.
 */
int
x509_check_subjectaltname (u_char *id, u_int id_len, X509 *scert)
{
  u_int8_t *altname;
  u_int32_t altlen;
  int type, idtype, ret;

  type = x509_cert_subjectaltname (scert, &altname, &altlen);
  if (!type)
    {
      log_print ("x509_check_subjectaltname: can't access subjectAltName");
      return 0;
    }

  /* 
   * Now that we have the X509 certicate in native form, get the
   * subjectAltName extension and verify that it matches our ID.
   */

  /* XXX Get type of ID.  */
  idtype = id[0];
  id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
  id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

  ret = 0;
  switch (idtype)
    {
    case IPSEC_ID_IPV4_ADDR:
      if (type == X509v3_IP_ADDR) 
	ret = 1;
      break;
    case IPSEC_ID_FQDN:
      if (type == X509v3_DNS_NAME) 
	ret = 1;
      break;
    case IPSEC_ID_USER_FQDN:
      if (type == X509v3_RFC_NAME) 
	ret = 1;
      break;
    default:
      ret = 0;
      break;
    }

  if (!ret)
    {
      LOG_DBG ((LOG_CRYPTO, 50,
		"x509_check_subjectaltname: "
		"our ID type (%d) does not match X509 cert ID type (%d)",
		idtype, type));
      return 0;
    }

  if (altlen != id_len || memcmp (altname, id, id_len) != 0)
    {
      LOG_DBG ((LOG_CRYPTO, 50,
		"x509_check_subjectaltname: "
		"our ID does not match X509 cert ID"));
      return 0;
    }

  return 1;
}

/*
a884 7
  if (!x509_check_subjectaltname (id, id_len, scert))
    {
      log_print ("x509_cert_obtain: subjectAltName does not match id");
      free (*cert);
      return 0;
    }

d919 1
a919 2
      log_print ("x509_check_subjectaltname: "
		 "invalid subjectaltname extension");
d931 1
a931 1
      log_print ("x509_check_subjectaltname: subjectaltname invalid length");
d958 1
a958 1
   * XXX I *think* the subjectAltName can be a collection, but for now
@


1.36
log
@Merge with EOM 1.54

author: ho
Only include <gmp.h> with MP_FLAVOUR_GMP. Sync with OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.35 2001/01/10 20:31:24 angelos Exp $	*/
d121 3
a123 1
  LOG_DBG ((LOG_CRYPTO, 90, "x509_generate_kn: generating KeyNote policy for certificate %p", cert));
d128 1
a128 1
  /* Missing or self-signed, ignore cert but don't report failure */
d237 1
a237 1
  /* We could print the assertion here, but log_print() truncates... */
@


1.35
log
@Some more debug logging.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.34 2000/12/19 19:03:06 mickey Exp $	*/
/*	$EOM: x509.c,v 1.51 2000/12/12 01:38:38 niklas Exp $	*/
d50 4
@


1.34
log
@gmp is gone, make it build again; cvs retard
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.33 2000/12/12 01:46:39 niklas Exp $	*/
d117 2
d199 1
d230 3
d265 2
@


1.33
log
@Merge with EOM 1.51

author: niklas
more fascistoid style

author: angelos
Don't insert the *same* entry in two or more buckets! Thanks to
cedric@@wireless-networks.com for reporting/debugging and coming up
with the patch.

author: angelos
Correct format string.

author: angelos
x509_hash() should also skip the cert length (willey@@serasystems.com)

author: angelos
Add some error messages (ingham@@ara.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.32 2000/12/02 02:10:58 angelos Exp $	*/
a45 1
#include <gmp.h>
@


1.32
log
@Error messages.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.31 2000/11/30 06:36:37 angelos Exp $	*/
/*	$EOM: x509.c,v 1.45 2000/11/23 12:51:21 niklas Exp $	*/
d81 2
a82 2
static X509_STORE *x509_certs = NULL;
static X509_STORE *x509_cas = NULL;
d93 1
a93 1
static LIST_HEAD (x509_list, x509_hash) *x509_tab = NULL;
d116 1
d139 1
d195 1
d208 1
a208 1
  if (buf == NULL)
d264 12
a275 12
	x509_policy_asserts = calloc (4, sizeof(char *));
	if (x509_policy_asserts == NULL)
	  {
	    log_error ("x509_generate_kn: failed to allocate %d bytes",
		       4 * sizeof(char *));
	    free (buf);
	    return 0;
	  }

	x509_policy_asserts_num_alloc = 4;
	x509_policy_asserts_num = 1;
	x509_policy_asserts[0] = buf;
d279 14
a292 19
	if (x509_policy_asserts_num + 1 > x509_policy_asserts_num_alloc)
	  {
	    char **foo;

	    x509_policy_asserts_num_alloc *= 2;
	    foo = realloc (x509_policy_asserts,
			   x509_policy_asserts_num_alloc * sizeof(char *));
	    if (foo == NULL)
	      {
		x509_policy_asserts_num_alloc /= 2;
		log_error ("x509_generate_kn: failed to allocate %d bytes",
			   x509_policy_asserts_num_alloc * sizeof(char *));
		free (buf);
		return 0;
	      }

	    free (x509_policy_asserts);
	    x509_policy_asserts = foo;
	  }
d294 6
a299 2
	/* Assign to the next available */
	x509_policy_asserts[x509_policy_asserts_num++] = buf;
d388 2
a389 2
	  LOG_DBG_BUF ((LOG_CRYPTO, 70, "cert_cmp: ", id, len));
	  LOG_DBG_BUF ((LOG_CRYPTO, 70, "cert_cmp: ", cid[i], clen[i]));
d426 1
a426 2
  certh = malloc (sizeof *certh);
  if (!certh)
d428 8
a435 5
      cert_free_subjects (n, id, len);
      log_error ("x509_hash_enter: malloc (%d) failed", sizeof *certh);
      return 0;
    }
  memset (certh, 0, sizeof *certh);
d437 1
a437 1
  certh->cert = cert;
a438 2
  for (i = 0; i < n; i++)
    {
d537 4
d543 1
a543 1
  if (x509_generate_kn (cert) == 0)
d545 1
a545 1
  if (libkeynote && x509_generate_kn (cert) == 0)
d547 1
a547 4
    {
      log_print ("x509_read_from_dir: x509_generate_kn failed");
      continue;
    }
a549 4

      if (hash && !x509_hash_enter (cert))
	log_print ("x509_read_from_dir: x509_hash_enter (%s) failed",
		   file->d_name);
d623 1
a623 1
  x509_policy_asserts = NULL;
d818 1
a818 1
  X509 *scert = NULL;
d824 1
a824 1
      return NULL;
@


1.31
log
@x509_hash() should also ignore the id length (for matching purposes)
-- willey@@serasystems.co
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.30 2000/11/23 12:57:07 niklas Exp $	*/
d143 1
d159 1
d199 1
@


1.30
log
@Merge with EOM 1.45

author: niklas
style

author: angelos
Better ID matching, should solve (some?) of PGPnet interoperability
problems. From mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.29 2000/10/07 07:00:34 niklas Exp $	*/
d318 1
a318 1
  for (i = 0; i < (len & ~1); i += 2)
@


1.29
log
@Merge with EOM 1.43

author: niklas
Multiple subject name matching, makes certificate interop with PGPnet at least
partly working.  Added some error checking.

author: provos
style as pointed out by the code style pedant.

author: ho
Compile without USE_KEYNOTE/USE_POLICY.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.28 2000/06/08 20:51:21 niklas Exp $	*/
/*	$EOM: x509.c,v 1.43 2000/09/28 12:53:27 niklas Exp $	*/
d382 11
a392 5
	if (clen[i] == len && memcmp (id, cid[i], len) == 0)
	  {
	    id_found++;
	    break;
	  }
d894 2
a895 1
		"our ID type does not match X509 cert ID type"));
@


1.29.2.1
log
@Pull in patches from current:
Fixes (niklas,angelos):
-- x509_hash() should also ignore the id length (for matching purposes) -- willey@@serasystems.co
-- Merge with EOM 1.45
author: niklas
style

author: angelos
Better ID matching, should solve (some?) of PGPnet interoperability
problems. From mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.29 2000/10/07 07:00:34 niklas Exp $	*/
d318 1
a318 1
  for (i = 4; i < (len & ~1); i += 2)
d382 5
a386 11
	{
	  LOG_DBG_BUF ((LOG_CRYPTO, 70, "cert_cmp: ", id, len));
	  LOG_DBG_BUF ((LOG_CRYPTO, 70, "cert_cmp: ", cid[i], clen[i]));
	  /* XXX This identity predicate needs to be understood.  */
	  if (clen[i] == len && id[0] == cid[i][0]
	      && memcmp (id + 4, cid[i] + 4, len - 4) == 0)
	    {
	      id_found++;
	      break;
	    }
	}
d888 1
a888 2
		"our ID type (%d) does not match X509 cert ID type (%d)",
		idtype, type));
@


1.29.2.2
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.49 2001/04/12 15:50:02 ho Exp $	*/
/*	$EOM: x509.c,v 1.54 2001/01/16 18:42:16 ho Exp $	*/
d6 2
a7 2
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
d46 1
d65 1
a67 1
#include "math_mp.h"
a68 1
#include "sa.h"
d71 1
a71 1
/*
d81 2
a82 2
static X509_STORE *x509_certs = 0;
static X509_STORE *x509_cas = 0;
d93 1
a93 1
static LIST_HEAD (x509_list, x509_hash) *x509_tab = 0;
d101 2
a102 2
 * Issuer/Subject -> Authorizer/Licensees.
 * XXX RSA-specific.
d107 1
a107 2
  char *fmt = "Authorizer: \"rsa-hex:%s\"\nLicensees: \"rsa-hex:%s\"\n"
    "Conditions: %s >= \"%s\" && %s <= \"%s\";\n";
d109 1
a109 2
  char *fmt2 = "Authorizer: \"DN:%s\"\nLicensees: \"DN:%s\"\n"
    "Conditions: %s >= \"%s\" && %s <= \"%s\";\n";
a115 10
  char **new_asserts;
  time_t tt;
  char before[15], after[15];
  ASN1_TIME *tm;
  char *timecomp, *timecomp2;
  int i;

  LOG_DBG ((LOG_POLICY, 90,
	    "x509_generate_kn: generating KeyNote policy for certificate %p",
	    cert));
d120 1
a120 1
  /* Missing or self-signed, ignore cert but don't report failure.  */
d122 1
a122 1
    return 1;
d126 1
a126 2
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to get public key from cert"));
a137 1
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: cannot get subject key"));
a142 1
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: cannot get subject key"));
d147 1
a147 1
  /* Now find issuer's certificate so we can get the public key.  */
a157 2
	  LOG_DBG ((LOG_POLICY, 30,
		    "x509_generate_kn: no certificate found for issuer"));
d167 2
a168 2
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: "
		"missing certificates, cannot construct X509 chain"));
d175 1
a175 2
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to get public key from cert"));
a190 1
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: cannot get issuer key"));
a192 1

a196 1
      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: cannot get issuer key"));
d201 2
a202 3
  buf = calloc (strlen (fmt) + strlen (ikey) + strlen (skey) + 56,
		sizeof (char));
  if (!buf)
d211 1
a211 231
  if (((tm = X509_get_notBefore (cert)) == NULL) ||
      (tm->type != V_ASN1_UTCTIME && tm->type != V_ASN1_GENERALIZEDTIME))
    {
      tt = time ((time_t) NULL);
      strftime (before, 14, "%G%m%d%H%M%S", localtime (&tt));
      timecomp = "LocalTimeOfDay";
    }
  else
    {
      if (tm->data[tm->length - 1] == 'Z')
	{
	  timecomp = "GMTTimeOfDay";
	  i = tm->length - 2;
	}
      else
        {
	  timecomp = "LocalTimeOfDay";
	  i = tm->length - 1;
	}

      for (; i >= 0; i--)
        {
	  if (tm->data[i] < '0' || tm->data[i] > '9')
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid data in "
			"NotValidBefore time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }
	}

      if (tm->type == V_ASN1_UTCTIME)
	{
	  if ((tm->length < 10) || (tm->length > 13))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid length "
			"of NotValidBefore time field (%d)", tm->length));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Validity checks.  */
	  if ((tm->data[2] != '0' && tm->data[2] != '1')
	      || (tm->data[2] == '0' && tm->data[3] == '0')
	      || (tm->data[2] == '1' && tm->data[3] > '2')
	      || (tm->data[4] > '3')
	      || (tm->data[4] == '0' && tm->data[5] == '0')
	      || (tm->data[4] == '3' && tm->data[5] > '1')
	      || (tm->data[6] > '2')
	      || (tm->data[6] == '2' && tm->data[7] > '3')
	      || (tm->data[8] > '5'))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid value in "
			"NotValidBefore time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Stupid UTC tricks.  */
	  if (tm->data[0] < '5')
	    sprintf (before, "20%s", tm->data);
	  else
	    sprintf (before, "19%s", tm->data);
	}
      else
        { /* V_ASN1_GENERICTIME */
	  if ((tm->length < 12) || (tm->length > 15))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid length of "
			"NotValidBefore time field (%d)", tm->length));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Validity checks.  */
	  if ((tm->data[4] != '0' && tm->data[4] != '1')
	      || (tm->data[4] == '0' && tm->data[5] == '0')
	      || (tm->data[4] == '1' && tm->data[5] > '2')
	      || (tm->data[6] > '3')
	      || (tm->data[6] == '0' && tm->data[7] == '0')
	      || (tm->data[6] == '3' && tm->data[7] > '1')
	      || (tm->data[8] > '2')
	      || (tm->data[8] == '2' && tm->data[9] > '3')
	      || (tm->data[10] > '5'))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid value in "
			"NotValidBefore time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  sprintf (before, "%s", tm->data);
	}

      /* Fix missing seconds.  */
      if (tm->length < 12)
        {
	  before[12] = '0';
	  before[13] = '0';
	}

      /* This will overwrite trailing 'Z'.  */
      before[14] = '\0';
    }

  tm = X509_get_notAfter (cert);
  if (tm == NULL
      && (tm->type != V_ASN1_UTCTIME && tm->type != V_ASN1_GENERALIZEDTIME))
    {
      tt = time (0);
      strftime (after, 14, "%G%m%d%H%M%S", localtime (&tt));
      timecomp2 = "LocalTimeOfDay";
    }
  else
    {
      if (tm->data[tm->length - 1] == 'Z')
	{
	  timecomp2 = "GMTTimeOfDay";
	  i = tm->length - 2;
	}
      else
        {
	  timecomp2 = "LocalTimeOfDay";
	  i = tm->length - 1;
	}

      for (; i >= 0; i--)
        {
	  if (tm->data[i] < '0' || tm->data[i] > '9')
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid data in "
			"NotValidAfter time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }
	}

      if (tm->type == V_ASN1_UTCTIME)
	{
	  if ((tm->length < 10) || (tm->length > 13))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid length of "
			"NotValidAfter time field (%d)", tm->length));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Validity checks. */
	  if ((tm->data[2] != '0' && tm->data[2] != '1')
	      || (tm->data[2] == '0' && tm->data[3] == '0')
	      || (tm->data[2] == '1' && tm->data[3] > '2')
	      || (tm->data[4] > '3')
	      || (tm->data[4] == '0' && tm->data[5] == '0')
	      || (tm->data[4] == '3' && tm->data[5] > '1')
	      || (tm->data[6] > '2')
	      || (tm->data[6] == '2' && tm->data[7] > '3')
	      || (tm->data[8] > '5'))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid value in "
			"NotValidAfter time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Stupid UTC tricks.  */
	  if (tm->data[0] < '5')
	    sprintf (after, "20%s", tm->data);
	  else
	    sprintf (after, "19%s", tm->data);
	}
      else
        { /* V_ASN1_GENERICTIME */
	  if ((tm->length < 12) || (tm->length > 15))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid length of "
			"NotValidAfter time field (%d)", tm->length));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  /* Validity checks.  */
	  if ((tm->data[4] != '0' && tm->data[4] != '1')
	      || (tm->data[4] == '0' && tm->data[5] == '0')
	      || (tm->data[4] == '1' && tm->data[5] > '2')
	      || (tm->data[6] > '3')
	      || (tm->data[6] == '0' && tm->data[7] == '0')
	      || (tm->data[6] == '3' && tm->data[7] > '1')
	      || (tm->data[8] > '2')
	      || (tm->data[8] == '2' && tm->data[9] > '3')
	      || (tm->data[10] > '5'))
	    {
	      LOG_DBG ((LOG_POLICY, 30, "x509_generate_kn: invalid value in "
			"NotValidAfter time field"));
	      free (ikey);
	      free (skey);
	      free (buf);
	      return 0;
	    }

	  sprintf (after, "%s", tm->data);
        }

      /* Fix missing seconds.  */
      if (tm->length < 12)
        {
	  after[12] = '0';
	  after[13] = '0';
	}

      after[14] = '\0'; /* This will overwrite trailing 'Z' */
    }

  sprintf (buf, fmt, skey, ikey, timecomp, before, timecomp2, after);
d218 1
a218 2
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to add new KeyNote credential"));
a221 3

  /* We could print the assertion here, but log_print() truncates...  */

d226 1
a226 2
      LOG_DBG ((LOG_POLICY, 50,
		"x509_generate_kn: X509_NAME_oneline (issuer, ...) failed"));
d232 1
a232 2
      LOG_DBG ((LOG_POLICY, 50,
		"x509_generate_kn: X509_NAME_oneline (subject, ...) failed"));
d236 2
a237 1
  buf = malloc (strlen (fmt2) + strlen (isname) + strlen (subname) + 56);
d240 2
a241 2
      log_error ("x509_generate_kn: malloc (%d) failed", strlen (fmt2) +
		 strlen (isname) + strlen (subname) + 56);
d245 1
a245 1
  sprintf (buf, fmt2, isname, subname, timecomp, before, timecomp2, after);
d250 1
a250 2
      LOG_DBG ((LOG_POLICY, 30,
		"x509_generate_kn: failed to add new KeyNote credential"));
a253 2
  else
    LOG_DBG ((LOG_POLICY, 80, "x509_generate_kn: added policy:\n%s", buf));
d255 1
a255 1
  /* Store the X509-derived assertion so we can use it as a policy.  */
d258 8
a265 8
      x509_policy_asserts = calloc (4, sizeof (char *));
      if (!x509_policy_asserts)
	{
	  log_error ("x509_generate_kn: failed to allocate %d bytes",
		     4 * sizeof (char *));
	  free (buf);
	  return 0;
	}
d267 3
a269 3
      x509_policy_asserts_num_alloc = 4;
      x509_policy_asserts_num = 1;
      x509_policy_asserts[0] = buf;
d273 15
a287 14
      if (x509_policy_asserts_num + 1 > x509_policy_asserts_num_alloc)
	{
	  x509_policy_asserts_num_alloc *= 2;
	  new_asserts = realloc (x509_policy_asserts,
				 x509_policy_asserts_num_alloc
				 * sizeof (char *));
	  if (!new_asserts)
	    {
	      x509_policy_asserts_num_alloc /= 2;
	      log_error ("x509_generate_kn: failed to allocate %d bytes",
			 x509_policy_asserts_num_alloc * sizeof (char *));
	      free (buf);
	      return 0;
	    }
d289 3
a291 2
	  x509_policy_asserts = new_asserts;
	}
d293 2
a294 2
      /* Assign to the next available.  */
      x509_policy_asserts[x509_policy_asserts_num++] = buf;
d297 3
a299 2
  /*
   * XXX Should add a remove-assertion event set to the expiration of the
d304 1
d326 1
a326 1

d340 1
a340 1
  /* If reinitializing, free existing entries.  */
d345 6
a350 5
             certh = LIST_FIRST (&x509_tab[i]))
	  {
	    LIST_REMOVE (certh, link);
	    free (certh);
	  }
d383 2
a384 2
	  LOG_DBG_BUF ((LOG_CRYPTO, 70, "cert_cmp", id, len));
	  LOG_DBG_BUF ((LOG_CRYPTO, 70, "cert_cmp", cid[i], clen[i]));
d417 1
a417 1
      log_print ("x509_hash_enter: cannot retrieve subjects");
d421 2
a422 1
  for (i = 0; i < n; i++)
d424 5
a428 7
      certh = calloc (1, sizeof *certh);
      if (!certh)
        {
          cert_free_subjects (n, id, len);
          log_error ("x509_hash_enter: calloc (1, %d) failed", sizeof *certh);
          return 0;
        }
d430 1
a430 1
      certh->cert = cert;
d432 2
d437 1
a437 1
      LOG_DBG ((LOG_CRYPTO, 70, "x509_hash_enter: cert %p added to bucket %d",
d465 1
a465 1

a531 4

	  if (!x509_hash_enter (cert))
	    log_print ("x509_read_from_dir: x509_hash_enter (%s) failed",
		       file->d_name);
d534 1
a534 1
	  if (x509_generate_kn (cert) == 0)
d536 1
a536 1
	    if (libkeynote && x509_generate_kn (cert) == 0)
d538 4
a541 2
	      LOG_DBG ((LOG_POLICY, 50,
			"x509_read_from_dir: x509_generate_kn failed"));
d544 4
d574 1
a574 1
  /* Free if already initialized.  */
d599 1
a599 1
  /* Free if already initialized.  */
d621 1
a621 1
  x509_policy_asserts = 0;
d641 1
a641 1
   */
d672 1
a672 1

d703 1
a703 1
    if (libkeynote && x509_generate_kn (cert) == 0)
d705 5
a709 6
      {
	LOG_DBG ((LOG_POLICY, 50,
		  "x509_cert_insert: x509_generate_kn failed"));
	LC (X509_free, (cert));
	return 0;
      }
a718 14
static struct x509_hash *
x509_hash_lookup (X509 *cert)
{
  int i;
  struct x509_hash *certh;

  for (i = 0; i <= bucket_mask; i++)
    for (certh = LIST_FIRST (&x509_tab[i]); certh;
	 certh = LIST_NEXT (certh, link))
      if (certh->cert == cert)
	return certh;
  return 0;
}

a721 4
  struct x509_hash *certh = x509_hash_lookup ((X509 *)cert);

  if (certh)
    LIST_REMOVE (certh, link);
d742 1
a742 1
  /* XXX - not supported directly in SSL - later.  */
d775 1
a775 1

d816 1
a816 1
  X509 *scert = 0;
d822 1
a822 1
      return 0;
d824 1
a824 1

d844 67
d937 7
d978 2
a979 1
      log_print ("x509_cert_subjectaltname: invalid subjectaltname extension");
d989 1
a989 1
  if (sanlen + 4 != subjectaltname->value->length)
d991 1
a991 1
      log_print ("x509_cert_subjectaltname: subjectaltname invalid length");
d994 1
a994 1

d1018 1
a1018 1
   * XXX There can be a collection of subjectAltNames, but for now
d1023 1
a1023 1
  *id = calloc (*cnt, sizeof **id);
d1031 1
a1031 1
  *id_len = malloc (*cnt * sizeof **id_len);
d1044 1
a1044 1

d1048 1
a1048 1
  if (!(*id)[0])
d1109 1
a1109 1
  if (!(*id)[1])
d1132 1
a1132 1

d1141 1
a1141 1
  /* Check if we got the right key type.  */
@


1.28
log
@Merge with EOM 1.40

author: angelos
Different policy/Keynote sessions per Phase 1 SA.

author: angelos
Allow exchange of KeyNote credentials over IKE. Multiple credentials
may be passed in a single CERT payload. KeyNote is used if a
directory named as the local ID we use in an exchange exists in the
KeyNote directory (default: /etc/isakmpd/keynote/). Note that
asymmetric credentials are possible (use KeyNote in one direction and
X509 in the other); such authentication is envisioned to be the most
common: the clients will use KeyNote credentials to authenticate and
authorize with a server, whilst the server will just provide an X509
certificate proving its binding to the IP address or ID.

Totally asymmetric authentication (e.g., shared key in one direction,
RSA in the other) is not supported by the IKE protocol.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.27 2000/04/07 22:04:16 niklas Exp $	*/
/*	$EOM: x509.c,v 1.40 2000/05/21 04:24:54 angelos Exp $	*/
d59 1
d169 1
a169 1
      free(ikey);
d224 12
a235 2
  LC (X509_NAME_oneline, (issuer, isname, 256));
  LC (X509_NAME_oneline, (subject, subname, 256));
d352 1
a352 1
      free(x509_tab);
d370 3
a372 2
  u_int8_t *cid;
  size_t clen;
d377 1
a377 1
      if (!x509_cert_get_subject (cert->cert, &cid, &clen))
d380 10
a389 6
      if (clen != len || memcmp (id, cid, len) != 0)
	{
	  free (cid);
	  continue;
	}
      free (cid);
d404 2
a405 2
  u_int8_t *id;
  u_int32_t len;
d407 1
d409 1
a409 1
  if (!x509_cert_get_subject (cert, &id, &len))
d411 1
a411 1
      log_print ("x509_hash_enter: can not retrieve subjectAltName");
d418 1
a418 1
      free (id);
d426 9
a434 2
  bucket = x509_hash (id, len);
  free (id);
a435 3
  LIST_INSERT_HEAD (&x509_tab[bucket], certh, link);
  LOG_DBG ((LOG_CRYPTO, 70, "x509_hash_enter: cert %p added to bucket %d", 
	    cert, bucket));
d554 1
d556 1
d868 1
a868 1
      if (type == X509v3_IPV4_ADDR) 
d995 2
a996 1
x509_cert_get_subject (void *scert, u_int8_t **id, u_int32_t *id_len)
d999 1
d1003 33
d1037 14
d1052 10
d1066 3
d1070 2
a1071 10
      {
	char *buf;
	  
	buf = malloc (altlen + ISAKMP_ID_DATA_OFF);
	if (!buf)
	  {
	    log_print ("x509_cert_get_subject: malloc (%d) failed",
		       altlen + ISAKMP_ID_DATA_OFF);
	    return 0;
	  }
d1073 20
a1092 20
	if (type == X509v3_DNS_NAME)
	  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_FQDN);
	else
	  SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_USER_FQDN);

	SET_IPSEC_ID_PROTO (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
	SET_IPSEC_ID_PORT (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
	memcpy (buf + ISAKMP_ID_DATA_OFF, altname, altlen);

	*id_len = ISAKMP_ID_DATA_OFF + altlen - ISAKMP_GEN_SZ;
	*id = malloc (*id_len);
	if (!*id) 
	  {
	    log_print ("x509_cert_get_subject: malloc (%d) failed", *id_len);
	    free (buf);
	    return 0;
	  }
	memcpy (*id, buf + ISAKMP_GEN_SZ, *id_len);
	free (buf);
      }
d1094 1
a1094 12
	 
    case X509v3_IPV4_ADDR:
      {
	char buf[ISAKMP_ID_DATA_OFF + 4];
	
	/* XXX sizeof IPV4_ADDR, how any better?  */
	if (altlen != 4)
	  {
	    log_print ("x509_cert_get_subject: length != IP4addr: %d",
		       altlen);
	    return 0;
	  }
d1096 10
a1105 19
	SET_ISAKMP_ID_TYPE (buf, IPSEC_ID_IPV4_ADDR);
	SET_IPSEC_ID_PROTO (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
	SET_IPSEC_ID_PORT (buf + ISAKMP_ID_DOI_DATA_OFF, 0);
	memcpy (buf + ISAKMP_ID_DATA_OFF, altname, altlen);

	*id_len = ISAKMP_ID_DATA_OFF + 4 - ISAKMP_GEN_SZ;
	*id = malloc (*id_len);
	if (!*id) 
	  {
	    log_print ("x509_cert_get_subject: malloc (%d) failed", *id_len);
	    return 0;
	  }
	memcpy (*id, buf + ISAKMP_GEN_SZ, *id_len);
      }
      break;
    default:
      log_print ("x509_cert_get_subject: unsupported subjectAltName type: %d",
		 type);
      return 0;
d1107 1
d1109 2
d1112 12
d1125 1
a1125 1

@


1.27
log
@Merge with EOM 1.38

author: niklas
log_fatal is only OK during initialization, also style fixes
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.26 2000/03/08 08:42:15 niklas Exp $	*/
/*	$EOM: x509.c,v 1.38 2000/04/07 19:22:34 niklas Exp $	*/
d243 42
a284 1
  free (buf);
d533 1
d581 15
d658 1
a658 1
x509_cert_insert (void *scert)
@


1.26
log
@Merge with EOM 1.37

author: ho
Add missing #ifdef USE_X509/#endif
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.25 2000/02/25 17:23:42 niklas Exp $	*/
/*	$EOM: x509.c,v 1.37 2000/03/07 16:09:36 ho Exp $	*/
d107 1
a107 1
  char *ikey, *skey, *buf, isname[256], subname[256], *buf2;
d130 1
a130 1
  dc.dec_key = (void *) key;
a133 2
      log_fatal ("x509_generate_kn: failed to get memory for public key");
  if (ikey == NULL)
d135 2
d138 3
d142 1
a165 1
      free(ikey);
d168 1
d174 1
a175 1
      log_print ("x509_generate_kn: failed to get public key from cert");
d182 1
a182 1
  dc.dec_key = (void *) key;
d186 7
a192 2
      log_fatal ("x509_generate_kn: failed to get memory for public key");
  if (skey == NULL)
d202 7
a208 1
    log_fatal ("x509_generate_kn: failed to allocate memory for KeyNote credential");
d221 1
d226 7
a232 4
  buf2 = calloc(strlen (fmt2) + strlen (isname) + strlen (subname),
		sizeof(char));
  if (buf == NULL)
    log_fatal ("x509_generate_kn: failed to allocate memory for KeyNote credential");
d234 1
a234 1
  sprintf (buf2, fmt2, isname, subname);
d236 1
a236 1
  if (LK (kn_add_assertion, (keynote_sessid, buf2, strlen(buf2),
d240 1
a240 1
      free (buf2);
d243 1
a254 1
  free (buf);
@


1.25
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.24 2000/02/19 19:31:33 niklas Exp $	*/
/*	$EOM: x509.c,v 1.36 2000/02/20 19:58:43 niklas Exp $	*/
d39 2
d998 2
@


1.24
log
@Makefile: Merge with EOM 1.61
crypto.c: Merge with EOM 1.27
exchange.c: Merge with EOM 1.115
ike_quick_mode.c: Merge with EOM 1.115
x509.c: Merge with EOM 1.35
features/ec: Merge with EOM 1.1
features/aggressive: Merge with EOM 1.1
features/policy: Merge with EOM 1.1
features/x509: Merge with EOM 1.1

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.23 2000/02/11 10:21:54 niklas Exp $	*/
/*	$EOM: x509.c,v 1.35 2000/02/19 07:46:33 niklas Exp $	*/
d313 2
a314 1
      log_debug (LOG_CRYPTO, 70, "x509_hash_find: return X509 %p", cert->cert);
d318 1
a318 1
  log_debug (LOG_CRYPTO, 70, "x509_hash_find: no certificate matched query");
d351 2
a352 2
  log_debug (LOG_CRYPTO, 70, "x509_hash_enter: cert %p added to bucket %d", 
	     cert, bucket);
d374 2
a375 2
  log_debug (LOG_CRYPTO, 40, "x509_read_from_dir: reading certs from %s",
	     name);
d394 2
a395 2
      log_debug (LOG_CRYPTO, 60, "x509_read_from_dir: reading certificate %s",
		 file->d_name);
d436 3
a438 3
	  log_debug (LOG_CRYPTO, 50,
		     "x509_read_from_dir: X509_STORE_add_cert failed for %s",
		     file->d_name);
d785 3
a787 3
      log_debug (LOG_CRYPTO, 50,
		 "x509_check_subjectaltname: "
		 "our ID type does not match X509 cert ID type");
d793 3
a795 3
      log_debug (LOG_CRYPTO, 50,
		 "x509_check_subjectaltname: "
		 "our ID does not match X509 cert ID");
d815 2
a816 2
    log_debug (LOG_CRYPTO, 60,
	       "x509_cert_obtain: acceptable certificate authorities here");
@


1.23
log
@Merge with EOM 1.34

author: angelos
Rename the "CN:" tag to "DN:", after Jorgen's suggestion.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.22 2000/02/07 01:32:54 niklas Exp $	*/
/*	$EOM: x509.c,v 1.34 2000/02/10 16:25:01 angelos Exp $	*/
d50 1
a50 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
d53 1
a53 1
#endif /* USE_KEYNOTE || HAVE_DLOPEN */
a67 2
extern int keynote_sessid;

a77 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
a79 1
#endif
d95 1
a95 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
d236 1
a236 1
#endif /* USE_KEYNOTE || HAVE_DLOPEN */
a359 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
d442 1
a442 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
d452 1
a452 1
#endif /* USE_KEYNOTE || HAVE_DLOPEN */
a462 3
#else
  return 0;
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
a468 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
a523 3
#else
  return 0;
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
a543 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
a575 3
#else
  return 0;
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
a580 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
d591 1
a591 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
d602 1
a602 1
#endif /* USE_KEYNOTE || HAVE_DLOPEN */
a608 3
#else
  return 0;
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
a613 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
a614 1
#endif
a706 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
a732 3
#else
  return NULL;
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
a808 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
a844 3
#else
  return 0;
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
a850 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
a889 3
#else
  return 0;
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
a977 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
a993 3
#else
  return 0;
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
@


1.22
log
@ike_quick_mode.c: Merge with EOM 1.111
libcrypto.c: Merge with EOM 1.11
libcrypto.h: Merge with EOM 1.11
x509.c: Merge with EOM 1.33

author: angelos
Add Canonical Names as policy targets (so they can be specified in the
Licensees field), with the "CN:..." format.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.21 2000/02/01 02:46:19 niklas Exp $	*/
/*	$EOM: x509.c,v 1.33 2000/02/07 01:30:36 angelos Exp $	*/
d110 1
a110 1
  char *fmt2 = "Authorizer: \"CN:%s\"\nLicensees: \"CN:%s\"\n";
@


1.21
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.20 2000/01/31 08:38:29 niklas Exp $	*/
/*	$EOM: x509.c,v 1.32 2000/01/31 22:33:49 niklas Exp $	*/
d109 2
a112 1
  char *ikey, *skey, *buf;
d195 1
a195 2
    log_fatal ("x509_generate_kn: "
	       "failed to allocate memory for KeyNote credential");
a203 1
      printf("%d\n", keynote_errno);
d206 18
@


1.20
log
@ike_quick_mode.c: Merge with EOM 1.109
isakmpd.conf.5: Merge with EOM 1.38
message.c: Merge with EOM 1.142
pf_key_v2.c: Merge with EOM 1.35
x509.c: Merge with EOM 1.31

author: niklas
(c) 2000
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.19 2000/01/31 08:18:41 niklas Exp $	*/
/*	$EOM: x509.c,v 1.31 2000/01/31 08:39:45 niklas Exp $	*/
d7 1
@


1.19
log
@Merge with EOM 1.30

author: angelos
Make x509_cert_init() able to re-initialize.

author: angelos
Fix delegating to a CA.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.18 2000/01/27 08:49:24 niklas Exp $	*/
/*	$EOM: x509.c,v 1.30 2000/01/31 05:50:59 angelos Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
@


1.18
log
@Merge with EOM 1.28

author: niklas
-Wall friendly
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.17 2000/01/27 08:43:06 niklas Exp $	*/
/*	$EOM: x509.c,v 1.28 2000/01/27 08:53:22 niklas Exp $	*/
d80 2
a81 2
static X509_STORE *x509_certs;
static X509_STORE *x509_cas;
d93 1
a93 1
static LIST_HEAD (x509_list, x509_hash) *x509_tab;
d102 1
d107 1
a107 1
  char *fmt = "Authorizer: \"%s\"\nLicensees: \"%s\"\n";
d112 1
a113 5
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
  STACK_OF (X509) *sk;
#else
  STACK *sk;
#endif
d120 2
a121 2
  if (!issuer || !subject || LC (X509_name_cmp, (issuer, subject)))
    return 1;
d143 14
a156 12
  LC (X509_STORE_CTX_init, (&csc, x509_cas, NULL, NULL));
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
  sk = LC (sk_X509_new_null, ());
#else
  sk = LC (sk_new_null, ());
#endif
  icert = LC (X509_find_by_subject, (sk, issuer));
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
  LC (sk_X509_free, (sk));
#else
  LC (sk_free, (sk));
#endif
d158 1
d175 2
d196 1
a196 1
  sprintf (buf, fmt, ikey, skey);
d203 1
d213 3
a215 1
   * session).
d248 1
d252 16
d427 15
d464 2
a465 2
  /* Process client certificates we will accept.  */
  dirname = conf_get_str ("X509-certificates", "Cert-directory");
d468 1
a468 1
      log_print ("x509_cert_init: no Cert-directory");
d472 6
a477 2
  x509_certs = LC (X509_STORE_new, ());
  if (!x509_certs)
d483 1
a483 1
  if (!x509_read_from_dir (x509_certs, dirname, 1))
d489 2
a490 2
  /* Process CA certificates we will trust.  */
  dirname = conf_get_str ("X509-certificates", "CA-directory");
d493 1
a493 1
      log_print ("x509_cert_init: no CA-directory");
d497 6
a502 2
  x509_cas = LC (X509_STORE_new, ());
  if (!x509_cas)
d508 1
a508 1
  if (!x509_read_from_dir (x509_cas, dirname, 0))
@


1.17
log
@Merge with EOM 1.27

author: niklas
Fix cert ID hashing
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.16 2000/01/26 15:24:52 niklas Exp $	*/
/*	$EOM: x509.c,v 1.27 2000/01/27 08:45:54 niklas Exp $	*/
d226 1
a226 1
  for (i = 0; i < len & ~1; i += 2)
@


1.16
log
@Merge with EOM 1.26

author: angelos
GMTTimeOfDay and LocalTimeOfDay attributes, comment in x509.c.

author: angelos
Include files, in anticipation of the keynote.h changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.15 1999/10/26 22:32:28 angelos Exp $	*/
/*	$EOM: x509.c,v 1.26 1999/10/10 22:48:37 angelos Exp $	*/
d226 1
a226 2
  len &= ~2;
  for (i = 0; i < len; i += 2)
d229 1
a229 1
      bucket ^= (id[i] + 1) * (id[i + 1]  + 257);
d231 4
a234 1

@


1.15
log
@sync with latest libkeynote (include file changes only)
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.14 1999/10/01 14:08:40 niklas Exp $	*/
/*	$EOM: x509.c,v 1.24 1999/09/30 13:40:38 niklas Exp $	*/
d205 8
@


1.14
log
@Merge with EOM 1.24

author: niklas
OpenSSL 0.9.4 support

author: angelos
blah

author: angelos
Add handling of X509v3_RFC_NAME and X509v3_DNS_NAME as subjaltnames
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.13 1999/08/26 22:28:15 niklas Exp $	*/
d50 1
@


1.13
log
@Merge with EOM 1.21

author: niklas
Support dynamic loading of libkeynote too.  Build isakmpd static by default.
Stylistic cleanup of keynote policy code.  Correct some libcrypto calls.

author: angelos
Complete policy work; tested for the shared-key case. Documentation needed.

author: ho
Compile without USE_LIBCRYPTO and HAVE_DLOPEN.

author: niklas
Add support for dynamic loading of optional facilities, libcrypto first.
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.12 1999/07/17 21:54:39 niklas Exp $	*/
/*	$EOM: x509.c,v 1.21 1999/08/26 11:21:49 niklas Exp $	*/
d111 3
d115 1
d146 5
a150 1
  sk = sk_new_null ();
d152 5
a156 1
  sk_free (sk);
d369 3
d373 1
d864 35
@


1.12
log
@regress/rsakeygen/Makefile: Merge with EOM 1.4
regress/rsakeygen/rsakeygen.c: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.6
regress/x509/x509test.c: Merge with EOM 1.6
regress/Makefile: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.6
samples/VPN-west.conf: Merge with EOM 1.6
samples/singlehost-east.conf: Merge with EOM 1.3
samples/singlehost-west.conf: Merge with EOM 1.3
sysdep/openbsd/Makefile.sysdep: Merge with EOM 1.5
x509.h: Merge with EOM 1.6
x509.c: Merge with EOM 1.17
DESIGN-NOTES: Merge with EOM 1.46
Makefile: Merge with EOM 1.55
cert.c: Merge with EOM 1.11
cert.h: Merge with EOM 1.6
exchange.c: Merge with EOM 1.109
exchange.h: Merge with EOM 1.26
ike_auth.c: Merge with EOM 1.32
ike_phase_1.c: Merge with EOM 1.7
init.c: Merge with EOM 1.16
isakmpd.conf.5: Merge with EOM 1.27
README.PKI: Merge with EOM 1.1

author: niklas
From Niels Provos, edited by me: certificate support using SSLeay
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.11 1999/07/07 22:15:42 niklas Exp $	*/
/*	$EOM: x509.c,v 1.17 1999/07/17 20:44:12 niklas Exp $	*/
d49 3
a51 3
#include <ssl/x509.h>
#include <ssl/x509_vfy.h>
#include <ssl/pem.h>
d56 1
d63 1
d66 2
d78 1
d81 1
d97 101
d301 1
d338 1
a338 1
      certh = BIO_new (BIO_s_file ());
d348 1
a348 1
      if (BIO_read_filename (certh, fullname) == -1)
d350 4
a353 2
	  BIO_free (certh);
	  log_error ("x509_read_from_dir: BIO_read_filename () failed");
d357 2
a358 2
      cert = PEM_read_bio_X509 (certh, NULL, NULL);
      BIO_free (certh);
d361 1
a361 1
	  log_error ("x509_read_from_dir: PEM_read_bio_X509 (%s) failed",
d366 1
a366 1
      if (!X509_STORE_add_cert (ctx, cert))
d374 1
a374 1
		     "x509_read_from_dir: X509_STORE_add_cert (%s) failed",
d379 1
a379 1
	log_print ("x509_read_from_dir: X509_hash_enter (%s) failed",
d386 3
d395 1
d408 1
a408 1
  x509_certs = X509_STORE_new ();
d429 1
a429 1
  x509_cas = X509_STORE_new ();
d443 3
d451 9
d466 1
d477 3
a479 3
  X509_STORE_CTX_init (&csc, x509_cas, cert, NULL);
  res = X509_verify_cert (&csc);
  X509_STORE_CTX_cleanup (&csc);
d485 2
a486 2
  issuer = X509_get_issuer_name (cert);
  subject = X509_get_subject_name (cert);
d488 1
a488 1
  if (!issuer || !subject || X509_name_cmp (issuer, subject))
d491 1
a491 1
  key = X509_get_pubkey (cert);
d495 1
a495 1
  if (X509_verify (cert, key) == -1)
d499 3
d507 2
a508 1
  X509 *cert = X509_dup ((X509 *)scert);
d511 1
d518 13
d533 1
a533 1
    X509_free (cert);
d536 3
d544 3
a546 1
  X509_free ((X509 *)cert);
d554 2
a555 1
  /*  struct norm_type name = SEQOF ("issuer", RDNSequence);
d563 2
a564 1
    asn_free (&name); */
d575 2
a576 1
  /* XXX This needs to be done later.
d615 2
a616 1
 asn_free (&aca); */
d639 1
d643 1
a643 1
  certh = BIO_new (BIO_s_mem ());
d646 1
a646 1
      log_error ("X509_from_asn: BIO_new (BIO_s_mem ()) failed");
d650 1
a650 1
  if (BIO_write (certh, asn, len) == -1)
d652 1
a652 1
      log_error ("X509_from_asn: BIO_write failed\n");
d656 1
a656 1
  scert = d2i_X509_bio (certh, NULL);
d659 1
a659 1
      log_print ("X509_from_asn: d2i_X509_bio failed\n");
d664 1
a664 1
  BIO_free (certh);
d666 3
d721 1
a721 1
		 "X509_check_subjectaltname: "
d729 1
a729 1
		 "X509_check_subjectaltname: "
d745 1
d757 1
a757 1
      log_print ("X509_cert_obtain: ID is missing");
d767 1
a767 1
      log_print ("X509_cert_obtain: subjectAltName does not match id");
d772 1
a772 1
  *certlen = i2d_X509 (scert, NULL);
d776 1
a776 1
      log_error ("X509_cert_obtain: malloc (%d) failed", *certlen);
d779 1
a779 1
  *certlen = i2d_X509 (scert, &p);
d782 3
d791 1
d797 1
a797 1
  extpos = X509_get_ext_by_NID (scert, NID_subject_alt_name, -1);
d800 1
a800 1
      log_print ("X509_cert_subjectaltname: "
d805 1
a805 1
  subjectaltname = X509_get_ext (scert, extpos);
d810 1
a810 1
      log_print ("X509_check_subjectaltname: "
d823 1
a823 1
      log_print ("X509_check_subjectaltname: subjectaltname invalid length");
d831 3
d887 1
d891 1
a891 1
  key = X509_get_pubkey (cert);
d897 1
a897 1
      X509_free (cert);
d901 1
a901 1
  *(RSA **)keyp = RSAPublicKey_dup (key->pkey.rsa);
d904 3
@


1.11
log
@ike_phase_1.c: Merge with EOM 1.5
x509.c: Merge with EOM 1.16

author: niklas
Start stab at supporting other IDs than IPV4_ADDR in main mode
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.10 1999/06/05 19:04:32 niklas Exp $	*/
/*	$EOM: x509.c,v 1.16 1999/06/15 11:21:19 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niels Provos.  All rights reserved.
d41 1
d44 1
d49 4
a61 3
#include "asn.h"
#include "asn_useful.h"
#include "pkcs.h"
d64 21
a84 1
/* X509 Certificate Handling functions */
d86 7
a92 3
/* Validate the BER Encoding of a RDNSequence in the CERT_REQ payload.  */
int
x509_certreq_validate (u_int8_t *asn, u_int32_t len)
d94 2
a95 2
  struct norm_type name = SEQOF ("issuer", RDNSequence);
  int res = 1;
d97 3
a99 2
  if (!asn_template_clone (&name, 1)
      || (asn = asn_decode_sequence (asn, len, &name)) == 0)
d101 2
a102 2
      log_print ("x509_certreq_validate: can not decode 'acceptable CA' info");
      res = 0;
a103 1
  asn_free (&name);
d105 3
a107 1
  return res;
d110 2
a111 3
/* Decode the BER Encoding of a RDNSequence in the CERT_REQ payload.  */
void *
x509_certreq_decode (u_int8_t *asn, u_int32_t len)
d113 1
a113 3
  struct norm_type aca = SEQOF ("aca", RDNSequence);
  struct norm_type *tmp;
  struct x509_aca naca, *ret;
d115 6
a120 2
  if (!asn_template_clone (&aca, 1)
      || (asn = asn_decode_sequence (asn, len, &aca)) == 0)
d122 1
a122 2
      log_print ("x509_certreq_validate: can not decode 'acceptable CA' info");
      goto fail;
d124 9
a132 1
  memset (&naca, 0, sizeof (naca));
d134 5
a138 5
  tmp = asn_decompose ("aca.RelativeDistinguishedName.AttributeValueAssertion",
		       &aca);
  if (!tmp)
    goto fail;
  x509_get_attribval (tmp, &naca.name1);
d140 6
a145 6
  tmp = asn_decompose ("aca.RelativeDistinguishedName[1]"
		       ".AttributeValueAssertion", &aca);
  if (tmp)
    x509_get_attribval (tmp, &naca.name2);
  
  asn_free (&aca);
d147 2
a148 8
  ret = malloc (sizeof (struct x509_aca));
  if (ret)
    memcpy (ret, &naca, sizeof (struct x509_aca));
  else
    {
      log_error ("x509_certreq_decode: malloc (%d) failed",
		 sizeof (struct x509_aca));
      x509_free_aca (&aca);
d151 1
a151 4
  return ret;

 fail:
  asn_free (&aca);
a154 21
void
x509_free_aca (void *blob)
{
  struct x509_aca *aca = blob;

  if (aca->name1.type)
    free (aca->name1.type);
  if (aca->name1.val)
    free (aca->name1.val);

  if (aca->name2.type)
    free (aca->name2.type);
  if (aca->name2.val)
    free (aca->name2.val);
}

/* 
 * Obtain a Certificate from an acceptable Certification Authority.
 * XXX This is where all the magic should happen, but yet here
 * you will find nothing.
 */
d156 1
a156 2
x509_cert_obtain (struct exchange *exchange, void *data, u_int8_t **cert,
		  u_int32_t *certlen)
d158 4
a161 8
  struct x509_aca *aca = data;
  struct ipsec_exch *ie = exchange->data;
  char *certfile;
  int fd, res = 0;
  struct stat st;
  u_int8_t *id_cert, *asn, *id;
  size_t id_len;
  u_int32_t id_cert_len;
d163 3
a165 14
  if (aca)
    log_debug (LOG_CRYPTO, 60, "x509_cert_obtain: (%s) %s, (%s) %s",
	       asn_parse_objectid (asn_ids, aca->name1.type), aca->name1.val,
	       asn_parse_objectid (asn_ids, aca->name2.type), aca->name2.val);

  /* XXX This needs to be changed - but how else would I know?  */
  switch (ie->ike_auth->id)
    {
    case IKE_AUTH_RSA_SIG:
      certfile = conf_get_str ("RSA_sig", "cert");
      if (!certfile)
	return 0;
      break;
    default:
d169 2
a170 1
  if (stat (certfile, &st) == -1)
d172 2
a173 1
      log_error ("x509_cert_obtain: failed to state %s", certfile);
d176 3
d180 8
a187 1
  *certlen = st.st_size;
d189 13
a201 1
  if ((fd = open (certfile, O_RDONLY)) == -1)
d203 1
a203 1
      log_error ("x509_cert_obtain: failed to open %s", certfile);
d206 3
d210 2
a211 2
  *cert = malloc (st.st_size);
  if (!*cert)
d213 2
a214 11
      log_error ("x509_cert_obtain: malloc (%d) failed", st.st_size);
      res = 0;
      goto done;
    }

  if (read (fd, *cert, st.st_size) != st.st_size)
    {
      log_print ("x509_cert_obtain: cert file ended early");
      free (*cert);
      res = 0;
      goto done;
d217 4
a220 7
  /* 
   * XXX We assume IPv4 here and a certificate with an extension
   * type of subjectAltName at the end.  This can go once the saved
   * certificate is only used with one host with a fixed IP address.
   */
  id = exchange->initiator ? exchange->id_i : exchange->id_r;
  id_len = exchange->initiator ? exchange->id_i_len : exchange->id_r_len;
d222 1
a222 2
  /* XXX We need our ID to set that in the cert.  */
  if (id) 
d224 2
a225 2
      id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
      id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
d227 2
a228 8
      /* Get offset into data structure where the IP is saved.  */
      asn = *cert;
      id_cert_len = asn_get_data_len (0, &asn, &id_cert);
      asn = id_cert;
      id_cert_len = asn_get_data_len (0, &asn, &id_cert);
      id_cert += id_cert_len - 4;
      memcpy (id_cert, id, 4); 
    }
d230 6
a235 1
  res = 1;
d237 2
a238 2
 done:
  close (fd);
d240 6
a245 2
  return res;
}
d247 8
a254 6
/* Retrieve the public key from a X509 certificate.  */
int
x509_cert_get_key (u_int8_t *asn, u_int32_t asnlen, void *blob)
{
  struct rsa_public_key *key = blob;
  struct x509_certificate cert;
d256 11
a266 2
  if (!x509_decode_certificate (asn, asnlen, &cert))
    return 0;
d268 4
a271 3
  /* XXX Perhaps put into pkcs?  */
  mpz_init_set (key->n, cert.key.n);
  mpz_init_set (key->e, cert.key.e);
d273 1
a273 1
  x509_free_certificate (&cert);
d278 1
a278 1
/* Retrieve the public key from a X509 certificate.  */
d280 1
a280 2
x509_cert_get_subject (u_int8_t *asn, u_int32_t asnlen, 
		       u_int8_t **subject, u_int32_t *subjectlen)
d282 1
a282 1
  struct x509_certificate cert;
d284 9
a292 2
  if (!x509_decode_certificate (asn, asnlen, &cert))
    return 0;
d294 6
a299 2
  if (!cert.extension.type || !cert.extension.val)
    goto fail;
d301 5
a305 3
  log_debug (LOG_CRYPTO, 60, "x509_cert_get_subject: Extension Type %s = %s",
	     cert.extension.type, 
	     asn_parse_objectid (asn_ids, cert.extension.type));
d307 3
a309 1
  if (strcmp (ASN_ID_SUBJECT_ALT_NAME, cert.extension.type))
d311 2
a312 2
      log_print ("x509_cert_get_subject: extension type != subjectAltName");
      goto fail;
d315 2
a316 6
  /* 
   * XXX Evil**3, due to lack of time the IP encoding of subjectAltName
   * is supposed to be: 0x30 0x06 0x087 0x04 aa bb cc dd, where the IPV4
   * IP number is aa.bb.cc.dd.
   */
  if (asn_get_len (cert.extension.val) != 8 || cert.extension.val[3] != 4)
d318 2
a319 3
      log_print ("x509_cert_get_subject: "
		 "subjectAltName uses unhandled encoding");
      goto fail;
d322 1
a322 3
  /* XXX IPV4 address.  */
  *subject = malloc (sizeof (in_addr_t));
  if (!*subject)
d324 2
a325 3
      log_error ("x509_cert_get_subject: malloc (%d) failed",
		 sizeof (in_addr_t));
      goto fail;
a326 2
  *subjectlen = sizeof (in_addr_t);
  memcpy (*subject, cert.extension.val + 4, *subjectlen);
a327 1
  x509_free_certificate (&cert);
d329 1
d331 4
a334 3
 fail:
  x509_free_certificate (&cert);
  return 0;
d337 2
a338 6
/*
 * Initalizes the struct x509_attribval from a AttributeValueAssertion.
 * XXX Error checking.
 */
void
x509_get_attribval (struct norm_type *obj, struct x509_attribval *a)
d340 27
a366 1
  struct norm_type *tmp;
d368 2
a369 3
  tmp = asn_decompose ("AttributeValueAssertion.AttributeType", obj);
  if (tmp && tmp->data)
    a->type = strdup ((char *)tmp->data);
d371 1
a371 3
  tmp = asn_decompose ("AttributeValueAssertion.AttributeValue", obj);
  if (tmp && tmp->data)
    a->val = strdup ((char *)tmp->data);
d374 2
a375 3
/* Set OBJ with values from A.  XXX Error checking.  */
void
x509_set_attribval (struct norm_type *obj, struct x509_attribval *a)
d377 8
a384 1
  struct norm_type *tmp;
d386 3
a388 8
  tmp = asn_decompose ("AttributeValueAssertion.AttributeType", obj);
  tmp->data = strdup (a->type);
  tmp->len = strlen (tmp->data);
  tmp = asn_decompose ("AttributeValueAssertion.AttributeValue", obj);
  tmp->type = TAG_PRINTSTRING;
  tmp->data = strdup (a->val);
  tmp->len = strlen (tmp->data);
}
d390 1
a390 7
void
x509_free_attribval (struct x509_attribval *a)
{
  if (a->type)
    free (a->type);
  if (a->val)
    free (a->val);
d394 1
a394 1
x509_free_certificate (struct x509_certificate *cert)
d396 1
a396 13
  pkcs_free_public_key (&cert->key);
  if (cert->signaturetype)
    free (cert->signaturetype);
  if (cert->start)
    free (cert->start);
  if (cert->end)
    free (cert->end);

  x509_free_attribval (&cert->issuer1);
  x509_free_attribval (&cert->issuer2);
  x509_free_attribval (&cert->subject1);
  x509_free_attribval (&cert->subject2);
  x509_free_attribval (&cert->extension);
d399 1
d401 1
a401 2
x509_decode_certificate (u_int8_t *asn, u_int32_t asnlen, 
			 struct x509_certificate *rcert)
d403 2
a404 4
  struct norm_type cert = SEQ ("cert", Certificate);
  struct norm_type *tmp;
  u_int8_t *data;
  u_int32_t datalen;
d406 7
a412 8
  /*
   * Get access to the inner Certificate.
   * XXX We don't know how to get at the CA's public key yet.
   */
  if (!x509_validate_signed (asn, asnlen, 0, &data, &datalen))
    return 0;
  
  memset (rcert, 0, sizeof *rcert);
d414 1
a414 3
  if (!asn_template_clone (&cert, 1)
      || !asn_decode_sequence (data, datalen, &cert))
    goto fail;
d416 2
a417 10
  tmp = asn_decompose ("cert.subjectPublicKeyInfo.subjectPublicKey", &cert);
  if (!tmp || !tmp->data)
    goto fail;
  if (!pkcs_public_key_from_asn (&rcert->key, tmp->data + 1, tmp->len - 1))
    goto fail;
  
  tmp = asn_decompose ("cert.version", &cert);
  if (!tmp || !tmp->data)
    goto fail;
  rcert->version = mpz_get_ui (tmp->data);
d419 8
a426 4
  tmp = asn_decompose ("cert.serialNumber", &cert);
  if (!tmp || !tmp->data)
    goto fail;
  rcert->serialnumber = mpz_get_ui (tmp->data);
d428 7
a434 4
  tmp = asn_decompose ("cert.signature.algorithm", &cert);
  if (!tmp || !tmp->data)
    goto fail;
  rcert->signaturetype = strdup ((char *)tmp->data);
d436 2
a437 2
  tmp = asn_decompose ("cert.issuer.RelativeDistinguishedName."
		       "AttributeValueAssertion", &cert);
d440 1
a440 1
  x509_get_attribval (tmp, &rcert->issuer1);
d442 2
a443 2
  tmp = asn_decompose ("cert.issuer.RelativeDistinguishedName[1]."
		       "AttributeValueAssertion", &cert);
d445 3
a447 3
    x509_get_attribval (tmp, &rcert->issuer2);
  else
    rcert->issuer2.type = 0;
d449 3
a451 10
  tmp = asn_decompose ("cert.subject.RelativeDistinguishedName."
		       "AttributeValueAssertion", &cert);
  if (!tmp)
    goto fail;
  x509_get_attribval (tmp, &rcert->subject1);

  tmp = asn_decompose ("cert.subject.RelativeDistinguishedName[1]."
		       "AttributeValueAssertion", &cert);
  if (tmp)
    x509_get_attribval (tmp, &rcert->subject2);
a452 7
    rcert->subject2.type = 0;

  tmp = asn_decompose ("cert.validity.notBefore", &cert);
  if (!tmp || !tmp->data)
    goto fail;
  rcert->start = strdup ((char *)tmp->data);
  if (!rcert->start)
d454 3
a456 2
      log_error ("x509_decode_certificate: strdup(\"%s\") failed", tmp->data);
      goto fail;
d459 1
a459 17
  tmp = asn_decompose ("cert.validity.notAfter", &cert);
  if (!tmp || !tmp->data)
    goto fail;
  rcert->end = strdup ((char *)tmp->data);
  if (!rcert->end)
    {
      log_error ("x509_decode_certificate: strdup(\"%s\") failed", tmp->data);
      goto fail;
    }

  /* For x509v3 there might be an extension, try to decode it.  */
  tmp = asn_decompose ("cert.extension", &cert);
  if (tmp && tmp->data && rcert->version == 2)
    x509_decode_cert_extension (tmp->data, tmp->len, rcert);
 
  asn_free (&cert);
  return 1;
d462 1
a462 2
  x509_free_certificate (rcert);
  asn_free (&cert);
d466 2
a467 3
int
x509_encode_certificate (struct x509_certificate *rcert,
			 u_int8_t **asn, u_int32_t *asnlen)
d469 6
a474 6
  struct norm_type cert = SEQ ("cert", Certificate);
  struct norm_type *tmp;
  u_int8_t *data, *new_buf;
  mpz_t num;
  u_int8_t *tmpasn;
  u_int32_t tmpasnlen;
d476 5
d482 5
a486 2
  if (!asn_template_clone (&cert, 1))
    goto fail;
d488 2
a489 1
  if (rcert->extension.type && rcert->extension.val)
d491 2
a492 6
      tmp = asn_decompose ("cert.extension", &cert);
      if (x509_encode_cert_extension (rcert, &tmpasn, &tmpasnlen))
	{
	  tmp->data = tmpasn;
	  tmp->len = tmpasnlen;
	}
d494 2
a495 34

  tmp = asn_decompose ("cert.subjectPublicKeyInfo.algorithm.parameters",
		       &cert);
  tmp->type = TAG_NULL;
  tmp = asn_decompose ("cert.subjectPublicKeyInfo.algorithm.algorithm",
		       &cert);
  tmp->data = strdup (ASN_ID_RSAENCRYPTION);
  tmp->len = strlen (tmp->data);

  tmp = asn_decompose ("cert.subjectPublicKeyInfo.subjectPublicKey", &cert);
  data = pkcs_public_key_to_asn (&rcert->key);
  if (!data)
    goto fail;

  /* This is a BITSTRING, add 0 octet for padding.  */
  tmp->len = asn_get_len (data);
  new_buf = realloc (data, tmp->len + 1);
  if (!new_buf)
    {
      log_error ("x509_encode_certificate: realloc (%p, %d) failed", data,
		 tmp->len + 1);
      free (data);
      goto fail;
    }
  data = new_buf;
  memmove (data + 1, data, tmp->len);
  data[0] = 0;
  tmp->data = data;
  tmp->len++;
  
  mpz_init (num);
  tmp = asn_decompose ("cert.version", &cert);
  mpz_set_ui (num, rcert->version);
  if (!pkcs_mpz_to_norm_type (tmp, num))
d497 2
a498 2
      mpz_clear (num);
      goto fail;
d501 2
a502 3
  tmp = asn_decompose ("cert.serialNumber", &cert);
  mpz_set_ui (num, rcert->serialnumber);
  if (!pkcs_mpz_to_norm_type (tmp, num))
d504 2
a505 2
      mpz_clear (num);
      goto fail;
a506 38
  mpz_clear (num);

  tmp = asn_decompose ("cert.signature.parameters", &cert);
  tmp->type = TAG_NULL;
  tmp = asn_decompose ("cert.signature.algorithm", &cert);
  tmp->data = strdup (rcert->signaturetype);
  tmp->len = strlen ((char *)tmp->data);

  tmp = asn_decompose ("cert.issuer.RelativeDistinguishedName."
		       "AttributeValueAssertion", &cert);
  x509_set_attribval (tmp, &rcert->issuer1);
  tmp = asn_decompose ("cert.issuer.RelativeDistinguishedName[1]."
		       "AttributeValueAssertion", &cert);
  x509_set_attribval (tmp, &rcert->issuer2);

  tmp = asn_decompose ("cert.subject.RelativeDistinguishedName."
		       "AttributeValueAssertion", &cert);
  x509_set_attribval (tmp, &rcert->subject1);
  tmp = asn_decompose ("cert.subject.RelativeDistinguishedName[1]."
		       "AttributeValueAssertion", &cert);
  x509_set_attribval (tmp, &rcert->subject2);

  tmp = asn_decompose ("cert.validity.notBefore", &cert);
  tmp->data = strdup (rcert->start);
  tmp->len = strlen ((char *)tmp->data);

  tmp = asn_decompose ("cert.validity.notAfter", &cert);
  tmp->data = strdup (rcert->end);
  tmp->len = strlen ((char *)tmp->data);

  *asn = asn_encode_sequence (&cert, 0);
  if (!*asn)
    goto fail;

  *asnlen = asn_get_len (*asn);

  asn_free (&cert);
  return 1;
d508 3
a510 3
 fail:
  asn_free (&cert);
  return 0;
d514 1
a514 2
 * Decode an Extension to a X509 certificate.
 * XXX We ignore the critical boolean.
a515 1

d517 1
a517 2
x509_decode_cert_extension (u_int8_t *asn, u_int32_t asnlen,
			    struct x509_certificate *cert)
d519 10
a528 2
  struct norm_type *tmp;
  struct norm_type ex = SEQOF ("ex", Extensions);
d530 4
a533 2
  /* Implicit tagging for extension.  */
  ex.class = ADD_EXP (3, UNIVERSAL);
d535 26
a560 1
  if (!asn_template_clone (&ex, 1) || !asn_decode_sequence (asn, asnlen, &ex))
d562 3
a564 1
      asn_free (&ex);
d568 1
a568 13
  tmp = asn_decompose ("ex.extension.extnValue", &ex);
  if (!tmp || !tmp->data || asn_get_len (tmp->data) != tmp->len)
    goto fail;
  cert->extension.val = malloc (tmp->len);
  if (cert->extension.val == 0)
    goto fail;
  memcpy (cert->extension.val, tmp->data, tmp->len);

  tmp = asn_decompose ("ex.extension.extnId", &ex);
  if (!tmp || !tmp->data)
    goto fail;
  cert->extension.type = strdup (tmp->data);
  if (!cert->extension.type)
d570 4
a573 3
      free (cert->extension.val);
      cert->extension.val = 0;
      goto fail;
a575 1
  asn_free (&ex);
a576 4

 fail:
  asn_free (&ex);
  return 0;
d579 3
a581 4
/* 
 * Encode a Cert Extension.
 * XXX Only one extension per certificate.
 * XXX We tag everything as critical.
d584 2
a585 2
x509_encode_cert_extension (struct x509_certificate *cert,
			    u_int8_t **asn, u_int32_t *asnlen)
d587 3
a589 3
  struct norm_type ex = SEQ ("ex", Extensions);
  struct norm_type *tmp;
  ex.class = ADD_EXP (3, UNIVERSAL);
d591 3
a593 2
  if (!asn_template_clone (&ex ,1))
    goto fail;
d595 2
a596 8
  tmp = asn_decompose ("ex.extension.extnId", &ex);
  tmp->data = strdup (cert->extension.type);
  tmp->len = strlen (tmp->data);

  /* XXX We mark every extension as critical.  */
  tmp = asn_decompose ("ex.extension.critical", &ex);
  tmp->data = malloc (1);
  if (!tmp->data)
d598 2
a599 2
      log_error ("x509_encode_cert_extension: malloc (1) failed");
      goto fail;
a600 2
  *(u_int8_t *)tmp->data = 0xff;
  tmp->len = 1;
d602 5
a606 3
  tmp = asn_decompose ("ex.extension.extnValue", &ex);
  tmp->data = malloc (asn_get_len (cert->extension.val));
  if (!tmp->data)
d608 3
a610 3
      log_error ("x509_encode_cert_extension: malloc (%d) failed",
		 asn_get_len (cert->extension.val));
      goto fail;
a611 2
  tmp->len = asn_get_len (cert->extension.val);
  memcpy (tmp->data, cert->extension.val, tmp->len);
d613 8
a620 3
  *asn = asn_encode_sequence (&ex, 0);
  if (!*asn)
    goto fail;
a621 3
  *asnlen = asn_get_len (*asn);
  
  asn_free (&ex);
a622 3
 fail:
  asn_free (&ex);
  return 0;
d625 1
a625 4
/* 
 * Checks the signature on an ASN.1 Signed Type. If the passed KEY is
 * NULL we just unwrap the inner object and return it.
 */
d627 1
a627 3
x509_validate_signed (u_int8_t *asn, u_int32_t asnlen,
		      struct rsa_public_key *key, u_int8_t **data, 
		      u_int32_t *datalen)
d629 4
a632 12
  struct norm_type sig = SEQ ("signed", Signed);
  struct norm_type digest = SEQ ("digest", DigestInfo);
  struct norm_type *tmp;
  struct hash *hash = 0;
  int res;
  u_int8_t *dec;
  u_int16_t declen;
  char *id;

  if (!asn_template_clone (&sig, 1))
    /* Failed, probably memory allocation, free what we got anyway.  */
    goto fail;
d634 2
a635 1
  if (!asn_decode_sequence (asn, asnlen, &sig))
d637 3
a639 2
      log_print ("x509_validate_signed: input data could not be decoded");
      goto fail;
d642 1
a642 1
  tmp = asn_decompose ("signed.algorithm.algorithm", &sig);
d644 2
a645 3
  if (strcmp ((char *)tmp->data, ASN_ID_MD5WITHRSAENC) == 0)
    hash = hash_get (HASH_MD5);
  else
d647 3
a649 4
      id = asn_parse_objectid (asn_ids, tmp->data);
      log_print ("x509_validate_signed: can not handle SigType %s",
		 id ? id : tmp->data);
      goto fail;
d652 5
a656 9
  if (!hash)
    goto fail;

  tmp = asn_decompose ("signed.data", &sig);

  /* Hash the data.  */
  hash->Init (hash->ctx);
  hash->Update (hash->ctx, tmp->data, tmp->len);
  hash->Final (hash->digest, hash->ctx);
d658 1
a658 5
  *data = tmp->data;
  *datalen = tmp->len;

  /* Used to unwrap the SIGNED object around the Certificate.  */
  if (!key)
d660 2
a661 2
      asn_free (&sig);
      return 1;
d663 3
d667 2
a668 1
  tmp = asn_decompose ("signed.encrypted", &sig);
d670 43
a712 31
  /* 
   * tmp->data is a BITSTRING, the first octet in the BITSTRING gives
   * the padding bits at the end. Per definition there are no padding
   * bits at the end in this case, so just skip it.
   */
  if (!pkcs_rsa_decrypt (PKCS_PRIVATE, key, 0, tmp->data + 1, &dec, &declen))
    goto fail;

  if (!asn_template_clone (&digest, 1)
      || !asn_decode_sequence (dec, declen, &digest))
    {
      asn_free (&digest);
      goto fail;
    }
  tmp = asn_decompose ("digest.digestAlgorithm.algorithm", &digest);
  if (strcmp (ASN_ID_MD5, (char *)tmp->data))
    {
      log_print ("x509_validate_signed: DigestAlgorithm is not MD5");
      res = 0;
    }
  else
    {
      tmp = asn_decompose ("digest.digest", &digest);
      if (tmp->len != hash->hashsize
	  || memcmp (tmp->data, hash->digest, tmp->len))
	{
	  log_print ("x509_validate_signed: Digest does not match Data");
	  res = 0;
	}
      else
	res = 1;
d715 1
a715 7
  asn_free (&digest);
  asn_free (&sig);
  return res;

 fail:
  asn_free (&sig);
  return 0;
a717 6
/*
 * Create an ASN Signed Structure from the data passed in data
 * and return the result in asn.
 * At the moment the used hash is MD5, this is the only common
 * hash between us and X509.
 */
d719 1
a719 3
x509_create_signed (u_int8_t *data, u_int32_t datalen,
		    struct rsa_private_key *key, u_int8_t **asn, 
		    u_int32_t *asnlen)
d721 2
a722 13
  struct norm_type digest = SEQ ("digest", DigestInfo);
  struct norm_type sig = SEQ ("signed", Signed);
  struct norm_type *tmp;
  struct hash *hash;
  u_int8_t *diginfo, *enc;
  u_int32_t enclen;
  int res = 0;
  
  /* Hash the Data.  */
  hash = hash_get (HASH_MD5);
  hash->Init (hash->ctx);
  hash->Update (hash->ctx, data, datalen);
  hash->Final (hash->digest, hash->ctx);
d724 1
a724 2
  if (!asn_template_clone (&digest, 1))
    goto fail;
d726 2
a727 4
  tmp = asn_decompose ("digest.digest", &digest);
  tmp->len = hash->hashsize;
  tmp->data = malloc (hash->hashsize);
  if (!tmp->data)
d729 3
a731 2
      log_error ("x509_create_signed: malloc (%d) failed", hash->hashsize);
      goto fail;
a732 1
  memcpy (tmp->data, hash->digest, hash->hashsize);
d734 1
a734 10
  tmp = asn_decompose ("digest.digestAlgorithm.parameters", &digest);
  tmp->type = TAG_NULL;
  tmp = asn_decompose ("digest.digestAlgorithm.algorithm", &digest);
  tmp->data = strdup (ASN_ID_MD5);
  tmp->len = strlen (tmp->data);

  /* ASN encode Digest Information.  */
  diginfo = asn_encode_sequence (&digest, 0);
  if (!diginfo)
    goto fail;
d736 1
a736 49
  /* Encrypt the Digest Info with Private Key.  */
  res = pkcs_rsa_encrypt (PKCS_PRIVATE, 0, key, diginfo, asn_get_len (diginfo),
			  &enc, &enclen);
  free (diginfo);
  if (!res)
    goto fail;
  res = 0;

  if (!asn_template_clone (&sig, 1))
    goto fail2;

  tmp = asn_decompose ("signed.algorithm.parameters", &sig);
  tmp->type = TAG_NULL;
  tmp = asn_decompose ("signed.algorithm.algorithm", &sig);
  tmp->data = strdup (ASN_ID_MD5WITHRSAENC);
  tmp->len = strlen (tmp->data);

  /* The type is BITSTRING, i.e. first octet need to be zero.  */
  tmp = asn_decompose ("signed.encrypted", &sig);
  tmp->data = malloc (enclen + 1);
  if (!tmp->data)
    {
      log_error ("x509_create_signed: malloc (%d) failed", enclen + 1);
      free (enc);
      goto fail2;
    }
  tmp->len = enclen + 1;
  memcpy (tmp->data + 1, enc, enclen);
  *(char *)tmp->data = 0;
  free (enc);

  tmp = asn_decompose ("signed.data", &sig);
  tmp->data = data;
  tmp->len = datalen;

  *asn = asn_encode_sequence (&sig, 0);
  if (!*asn)
    goto fail2;
  *asnlen = asn_get_len (*asn);

  /* This is the data we have been given, we can not free it in asn_free.  */
  tmp->data = 0;
  res = 1;			/* Successful.  */

 fail2:
  asn_free (&sig);
 fail:
  asn_free (&digest);
  return res;
@


1.10
log
@Merge with EOM 1.15

author: niklas
More error checking of certs
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.9 1999/06/05 18:01:42 niklas Exp $	*/
/*	$EOM: x509.c,v 1.15 1999/06/05 18:59:08 niklas Exp $	*/
d157 3
d208 23
a230 29
  {
    /* 
     * XXX We assume IPv4 here and a certificate with an extension
     * type of subjectAltName at the end.  This can go once the saved
     * certificate is only used with one host with a fixed IP address.
     */
    u_int8_t *id_cert, *asn, *id;
    size_t id_len;
    u_int32_t id_cert_len;

    id = exchange->initiator ? exchange->id_i : exchange->id_r;
    id_len = exchange->initiator ? exchange->id_i_len : exchange->id_r_len;

    /* XXX We need our ID to set that in the cert.  */
    if (id) 
      {
	/* XXX How to get to the address?  */
	id += 4; id_len -= 4;
	
	/* Get offset into data structure where the IP is saved.  */
	asn = *cert;
	id_cert_len = asn_get_data_len (0, &asn, &id_cert);
	asn = id_cert;
	id_cert_len = asn_get_data_len (0, &asn, &id_cert);
	id_cert += id_cert_len - 4;
	memcpy (id_cert, id, 4); 
      }
  }
 
d293 2
a294 2
  /* XXX 4 bytes for IPV4 address.  */
  *subject = malloc (4);
d297 2
a298 1
      log_error ("x509_cert_get_subject: malloc (4) failed");
d301 1
a301 1
  *subjectlen = 4;
d313 1
a313 1
 * Initalizes the struct x509_attribval from a AtributeValueAssertion.
@


1.9
log
@Merge with EOM 1.14

author: niklas
Add some error checking
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.8 1999/04/19 19:57:29 niklas Exp $	*/
/*	$EOM: x509.c,v 1.14 1999/06/05 18:01:37 niklas Exp $	*/
d397 1
a397 1
  if (!tmp)
d403 1
a403 1
  if (!tmp)
d408 1
a408 1
  if (!tmp)
d413 1
a413 1
  if (!tmp)
d444 1
a444 1
  if (!tmp)
d454 1
a454 1
  if (!tmp)
@


1.8
log
@./cert.c: Merge with EOM 1.10
./x509.c: Merge with EOM 1.13

Style

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.7 1999/03/24 15:00:36 niklas Exp $	*/
/*	$EOM: x509.c,v 1.13 1999/04/18 15:17:26 niklas Exp $	*/
d314 4
a317 1
/* Initalizes the struct x509_attribval from a AtributeValueAssertion.  */
d332 1
a332 1
/* Set OBJ with values from A.  */
d397 2
d403 2
d406 1
d408 2
d411 1
d413 2
d419 2
d422 1
d432 2
d435 1
d444 2
d447 6
d454 2
d457 5
@


1.7
log
@Merge with EOM 1.10
RSA fixes and optimiations from Ilya Tsindlekht, via Niels Provos
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.6 1999/02/26 03:53:16 niklas Exp $	*/
/*	$EOM: x509.c,v 1.10 1999/03/13 17:43:20 niklas Exp $	*/
d6 1
d63 1
a63 2
/* Validate the BER Encoding of a RDNSequence in the CERT_REQ payload */

d70 2
a71 2
  if (asn_template_clone (&name, 1) == NULL ||
      (asn = asn_decode_sequence (asn, len, &name)) == NULL)
d81 1
a81 2
/* Decode the BER Encoding of a RDNSequence in the CERT_REQ payload */

d89 2
a90 2
  if (asn_template_clone (&aca, 1) == NULL ||
      (asn = asn_decode_sequence (asn, len, &aca)) == NULL)
d97 3
a99 2
  tmp = asn_decompose ("aca.RelativeDistinguishedName.AttributeValueAssertion", &aca);
  if (tmp == NULL)
d103 3
a105 2
  tmp = asn_decompose ("aca.RelativeDistinguishedName[1].AttributeValueAssertion", &aca);
  if (tmp != NULL)
d110 2
a111 1
  if ((ret = malloc (sizeof (struct x509_aca))) != NULL)
d114 5
a118 1
    x509_free_aca (&aca);
d124 1
a124 1
  return NULL;
d132 1
a132 1
  if (aca->name1.type != NULL)
d134 1
a134 1
  if (aca->name1.val != NULL)
d137 1
a137 1
  if (aca->name2.type != NULL)
d139 1
a139 1
  if (aca->name2.val != NULL)
d145 2
a146 2
 * XXX - this is where all the magic should happen, but yet here
 * you will find nothing :-\
a147 1

d158 1
a158 1
  if (aca != NULL)
d163 1
a163 1
  /* XXX - this needs to be changed - but how else shoud I know */
d167 2
a168 1
      if ((certfile = conf_get_str ("rsa_sig", "cert")) == NULL)
d189 2
a190 1
  if ((*cert = malloc (st.st_size)) == NULL)
d192 1
a192 1
      log_print ("x509_cert_obtain: out of memory");
d207 3
a209 3
     * XXX - assumes IPv4 here, assumes a certificate with an extension
     * type of subjectAltName at the end - this can go once the saved
     * certificate is only used with one host with a fixed IP address
a214 1
    /* XXX - assumes IPv4 */
d218 2
a219 2
    /* XXX - we need our ID to set that in the cert */
    if (id != NULL) 
d221 1
a221 1
	/* XXX - get to address ? */
d224 1
a224 1
	/* Get offset into data structure where the IP is saved */
d226 1
a226 1
	id_cert_len = asn_get_data_len (NULL, &asn, &id_cert);
d228 1
a228 1
	id_cert_len = asn_get_data_len (NULL, &asn, &id_cert);
d242 1
a242 1
/* Retrieve the public key from a X509 Certificate */
d252 1
a252 1
  /* XXX - perhaps put into pkcs ? */
d261 1
a261 5
/*
 * Retrieve the public key from a X509 Certificate
 * XXX - look at XXX below.
 */

d271 1
a271 1
  if (cert.extension.type == NULL || cert.extension.val == NULL)
a288 1

d291 2
a292 2
      log_print ("x509_cert_get_subject: subjectAltName uses "
		 "unhandled encoding");
d296 1
a296 1
  /* XXX - 4 bytes for IPV4 address */
d298 1
a298 1
  if (*subject == NULL)
d300 1
a300 1
      log_print ("x509_cert_get_subject: out of memory");
a306 1

d314 1
a314 2
/* Initalizes the struct x509_attribval from a AtributeValueAssertion */

d321 1
a321 1
  if (tmp != NULL && tmp->data != NULL)
d325 1
a325 1
  if (tmp != NULL && tmp->data != NULL)
d329 1
a329 2
/* Set's norm_type with values from x509_attribval */

d347 1
a347 1
  if (a->type != NULL)
d349 1
a349 1
  if (a->val != NULL)
d357 1
a357 1
  if (cert->signaturetype != NULL)
d359 1
a359 1
  if (cert->start != NULL)
d361 1
a361 1
  if (cert->end != NULL)
d373 1
a373 1
			      struct x509_certificate *rcert)
d380 5
a384 2
  /* Get access to the inner Certificate */
  if (!x509_validate_signed (asn, asnlen, NULL, &data, &datalen))
d387 1
a387 1
  memset (rcert, 0, sizeof (*rcert));
d389 2
a390 2
  if (asn_template_clone (&cert, 1) == NULL || 
      asn_decode_sequence (data, datalen, &cert) == NULL)
d409 1
a409 1
  if (tmp != NULL)
d412 1
a412 1
    rcert->issuer2.type = NULL;
d419 1
a419 1
  if (tmp != NULL)
d422 1
a422 1
    rcert->subject2.type = NULL;
d429 1
a429 1
  /* For x509v3 there might be an extension, try to decode it */
d451 3
d455 1
a455 1
  if (asn_template_clone (&cert, 1) == NULL)
d458 1
a458 1
  if (rcert->extension.type != NULL && rcert->extension.val != NULL)
a459 3
      u_int8_t *asn;
      u_int32_t asnlen;

d461 1
a461 1
      if (x509_encode_cert_extension (rcert, &asn, &asnlen))
d463 2
a464 2
	  tmp->data = asn;
	  tmp->len = asnlen;
d478 1
a478 1
  if (data == NULL)
d481 1
a481 1
  /* This is a BIT STRING add 0 octet for padding */
d484 1
a484 1
  if (new_buf == NULL)
d486 2
d543 2
a544 2
  *asn = asn_encode_sequence (&cert, NULL);
  if (*asn == NULL)
d559 1
a559 1
 * XXX - We ignore the critical boolean
d569 1
a569 1
  /* Implicit tagging for extension */
d572 1
a572 2
  if (asn_template_clone (&ex, 1) == NULL ||
      asn_decode_sequence (asn, asnlen, &ex) == NULL)
d579 1
a579 1
  if (!tmp || tmp->data == NULL || asn_get_len (tmp->data) != tmp->len)
d587 1
a587 1
  if (!tmp || tmp->data == NULL)
d590 1
a590 1
  if (cert->extension.type == NULL)
d593 1
a593 1
      cert->extension.val = NULL;
d606 3
a608 2
 * Encode a Cert Extension - XXX - only one extension per certificate 
 * XXX - We tag everything as critical
a609 1

d618 1
a618 1
  if (asn_template_clone (&ex ,1) == NULL)
d625 1
a625 1
  /* XXX - we mark every extension as critical */
d627 7
a633 3
  if ((tmp->data = malloc (1)) == NULL)
    goto fail;
  *(u_int8_t *)tmp->data = 0xFF;
d637 7
a643 2
  if ((tmp->data = malloc (asn_get_len (cert->extension.val))) == NULL)
    goto fail;
d647 2
a648 2
  *asn = asn_encode_sequence (&ex, NULL);
  if (*asn == NULL)
d661 1
a661 1
 * Checks the signature on an ASN.1 Signed Type. If the passed Key is
a663 1

d669 2
a670 2
  struct norm_type sig = SEQ("signed", Signed);
  struct norm_type digest = SEQ("digest", DigestInfo);
d672 1
a672 1
  struct hash *hash = NULL;
d676 1
d678 2
a679 2
  if (asn_template_clone (&sig, 1) == NULL)
      /* Failed, probably memory allocation, free what we got anyway */
d682 1
a682 1
  if (asn_decode_sequence (asn, asnlen, &sig) == NULL)
d690 2
a691 4
  if (!strcmp ((char *)tmp->data, ASN_ID_MD5WITHRSAENC))
    {
      hash = hash_get (HASH_MD5);
    }
d694 1
a694 1
      char *id = asn_parse_objectid (asn_ids, tmp->data);
d696 1
a696 1
		 id == NULL ? tmp->data : id);
d700 1
a700 1
  if (hash == NULL)
d704 2
a705 1
  /* Hash the data */
d713 2
a714 2
  /* Used to unwrap the SIGNED object around the Certificate */
  if (key == NULL)
d721 1
d723 1
a723 1
   * tmp->data is a BIT STRING, the first octet in the BIT STRING gives
d727 1
a727 2
  if (!pkcs_rsa_decrypt (PKCS_PRIVATE, key, NULL, tmp->data + 1,
			 &dec, &declen))
d730 2
a731 2
  if (asn_template_clone (&digest, 1) == NULL || 
      asn_decode_sequence (dec, declen, &digest) == NULL)
d745 2
a746 2
      if (tmp->len != hash->hashsize ||
	  memcmp (tmp->data, hash->digest, tmp->len))
a769 1

d783 1
a783 1
  /* Hash the Data */
d789 1
a789 1
  if (asn_template_clone (&digest, 1) == NULL)
d795 5
a799 2
  if (tmp->data == NULL)
    goto fail;
d808 3
a810 2
  /* ASN encode Digest Information */
  if ((diginfo = asn_encode_sequence (&digest, NULL)) == NULL)
d813 3
a815 3
  /* Encrypt the Digest Info with Private Key */
  res = pkcs_rsa_encrypt (PKCS_PRIVATE, NULL, key, diginfo, 
			  asn_get_len (diginfo), &enc, &enclen);
d821 1
a821 1
  if (asn_template_clone (&sig, 1) == NULL)
d830 1
a830 1
  /* The type is BITSTING, i.e. first octet need to be zero */
d833 1
a833 1
  if (tmp->data == NULL)
d835 1
d848 2
a849 2
  *asn = asn_encode_sequence (&sig, NULL);
  if (*asn == NULL)
d853 4
a856 3
  /* This is the data we have been given, we can not free it in asn_free */
  tmp->data = NULL;
  res = 1;	/* Successfull */
@


1.6
log
@Merge from the Ericsson repository
| revision 1.9
| date: 1999/02/25 11:39:29;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.5 1998/11/17 11:10:22 niklas Exp $	*/
/*	$EOM: x509.c,v 1.9 1999/02/25 11:39:29 niklas Exp $	*/
d716 1
a716 1
  if (!pkcs_rsa_decrypt (PKCS_PRIVATE, key->n, key->e, tmp->data + 1,
d801 1
a801 1
  res = pkcs_rsa_encrypt (PKCS_PRIVATE, key->n, key->d, diginfo, 
@


1.5
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: x509.c,v 1.4 1998/11/16 21:07:18 niklas Exp $	*/
/*	$EOM: x509.c,v 1.8 1998/08/21 14:33:09 provos Exp $	*/
d45 2
@


1.4
log
@Reinstate X509 signature code except for RSA code
@
text
@d1 2
a2 1
/*	$OpenBSD: x509.c,v 1.2 1998/11/15 00:44:05 niklas Exp $	*/
@


1.3
log
@Not clean enough yet
@
text
@@


1.2
log
@openBSD RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: x509.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: x509.c,v 1.8 1998/08/21 14:33:09 provos Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
