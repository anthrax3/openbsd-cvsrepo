head	1.62;
access;
symbols
	OPENBSD_6_0:1.62.0.8
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.4
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.62.0.6
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.62.0.2
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.61.0.16
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.61.0.14
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.61.0.10
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.61.0.8
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.61.0.6
	OPENBSD_5_2_BASE:1.61
	OPENBSD_5_1_BASE:1.61
	OPENBSD_5_1:1.61.0.4
	OPENBSD_5_0:1.61.0.2
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.60.0.16
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.60.0.14
	OPENBSD_4_8_BASE:1.60
	OPENBSD_4_7:1.60.0.10
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.60.0.12
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.60.0.8
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.60.0.6
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.60.0.4
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.59.0.2
	OPENBSD_4_1_BASE:1.59
	OPENBSD_4_0:1.58.0.6
	OPENBSD_4_0_BASE:1.58
	OPENBSD_3_9:1.58.0.4
	OPENBSD_3_9_BASE:1.58
	OPENBSD_3_8:1.58.0.2
	OPENBSD_3_8_BASE:1.58
	OPENBSD_3_7:1.51.0.2
	OPENBSD_3_7_BASE:1.51
	OPENBSD_3_6:1.49.0.2
	OPENBSD_3_6_BASE:1.49
	OPENBSD_3_5:1.41.0.2
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.62
date	2014.10.25.03.18.13;	author lteo;	state Exp;
branches;
next	1.61;
commitid	RKMpGS78lskgSHj4;

1.61
date	2011.04.16.10.30.29;	author sthen;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.02.01.29.11;	author pvalchev;	state Exp;
branches;
next	1.59;

1.59
date	2006.09.19.10.48.41;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.26.05.35.55;	author moritz;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.03.13.42.54;	author hshoexer;	state Exp;
branches;
next	1.56;

1.56
date	2005.04.08.19.40.03;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.08.16.37.14;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.08.16.24.12;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.08.16.14.04;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.50;

1.50
date	2004.11.08.11.59.37;	author hshoexer;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.25.00.58.39;	author hshoexer;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.21.16.37.30;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.21.16.01.56;	author ho;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.25.16.01.28;	author hshoexer;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.19.09.54.52;	author ho;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.16.10.51.57;	author hshoexer;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.14.14.50.23;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.06.16.12.07;	author ho;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.18.19.37.46;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.08.13.25.28;	author ho;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.10.15.13.12;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.01.23.18.44.47;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.03.16.27.41;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.05.08.18.37;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.02.18.04.35;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.18.20.50.02;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.10.10.47.37;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.10.10.46.29;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.10.07.55.05;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.15.16.09.16;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.09.21.21.57;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.27.12.03.33;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.12.05.12.45;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.07.06.58.29;	author niklas;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.08.03.07.28.56;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.29.00.01.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.07.22.05.38;	author niklas;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.02.25.17.23.40;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.08.26.22.31.36;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.07.07.22.11.14;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.04.19.19.53.41;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.02.26.03.45.48;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.12.21.01.02.26;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.16;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.59;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2000.10.07.04.01.10;	author jason;	state Exp;
branches;
next	;

1.13.2.1
date	2001.05.08.12.45.24;	author ho;	state Exp;
branches;
next	;

1.27.2.1
date	2002.05.11.04.42.14;	author jason;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@/* $OpenBSD: log.c,v 1.61 2011/04/16 10:30:29 sthen Exp $	 */
/* $EOM: log.c,v 1.30 2000/09/29 08:19:23 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001, 2003 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip6.h>
#include <netinet/udp.h>
#include <arpa/inet.h>

#include <pcap.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <stdarg.h>
#include <unistd.h>

#include "conf.h"
#include "isakmp_num.h"
#include "log.h"
#include "monitor.h"
#include "util.h"

static void	_log_print(int, int, const char *, va_list, int, int);

static FILE	*log_output;

int		verbose_logging = 0;
static int	log_level[LOG_ENDCLASS];

#define TCPDUMP_MAGIC	0xa1b2c3d4
#define SNAPLEN		(64 * 1024)

struct packhdr {
	struct pcap_pkthdr pcap;/* pcap file packet header */
	u_int32_t sa_family;	/* address family */
	union {
		struct ip       ip4;	/* IPv4 header (w/o options) */
		struct ip6_hdr  ip6;	/* IPv6 header */
	} ip;
};

struct isakmp_hdr {
	u_int8_t        icookie[8], rcookie[8];
	u_int8_t        next, ver, type, flags;
	u_int32_t       msgid, len;
};

static char    *pcaplog_file = NULL;
static FILE    *packet_log;
static u_int8_t *packet_buf = NULL;

static int      udp_cksum(struct packhdr *, const struct udphdr *,
    u_int16_t *);
static u_int16_t in_cksum(const u_int16_t *, int);

void
log_init(int debug)
{
	if (debug)
		log_output = stderr;
	else
		log_to(0);	/* syslog */
}

void
log_reinit(void)
{
	struct conf_list *logging;
	struct conf_list_node *logclass;
	int		class, level;

	logging = conf_get_list("General", "Logverbose");
	if (logging) {
		verbose_logging = 1;
		conf_free_list(logging);
	}
	logging = conf_get_list("General", "Loglevel");
	if (!logging)
		return;

	for (logclass = TAILQ_FIRST(&logging->fields); logclass;
	    logclass = TAILQ_NEXT(logclass, link)) {
		if (sscanf(logclass->field, "%d=%d", &class, &level) != 2) {
			if (sscanf(logclass->field, "A=%d", &level) == 1)
				for (class = 0; class < LOG_ENDCLASS; class++)
					log_debug_cmd(class, level);
			else {
				log_print("init: invalid logging class or "
				    "level: %s", logclass->field);
				continue;
			}
		} else
			log_debug_cmd(class, level);
	}
	conf_free_list(logging);
}

void
log_to(FILE *f)
{
	if (!log_output && f)
		closelog();
	log_output = f;
	if (!f)
		openlog("isakmpd", LOG_PID | LOG_CONS, LOG_DAEMON);
}

FILE *
log_current(void)
{
	return log_output;
}

static char *
_log_get_class(int error_class)
{
	/* XXX For test purposes. To be removed later on?  */
	static char	*class_text[] = LOG_CLASSES_TEXT;

	if (error_class < 0)
		return "Dflt";
	else if (error_class >= LOG_ENDCLASS)
		return "Unkn";
	else
		return class_text[error_class];
}

static void
_log_print(int error, int syslog_level, const char *fmt, va_list ap,
    int class, int level)
{
	char		buffer[LOG_SIZE], nbuf[LOG_SIZE + 32];
	static const char fallback_msg[] =
	    "write to log file failed (errno %d), redirecting to syslog";
	int		len;
	struct tm      *tm;
	struct timeval  now;
	time_t          t;

	len = vsnprintf(buffer, sizeof buffer, fmt, ap);
	if (len > 0 && len < (int) sizeof buffer - 1 && error)
		snprintf(buffer + len, sizeof buffer - len, ": %s",
		    strerror(errno));
	if (log_output) {
		gettimeofday(&now, 0);
		t = now.tv_sec;
		tm = localtime(&t);
		if (class >= 0)
			snprintf(nbuf, sizeof nbuf,
			    "%02d%02d%02d.%06ld %s %02d ",
			    tm->tm_hour, tm->tm_min, tm->tm_sec, now.tv_usec,
			    _log_get_class(class), level);
		else /* LOG_PRINT (-1) or LOG_REPORT (-2) */
			snprintf(nbuf, sizeof nbuf, "%02d%02d%02d.%06ld %s ",
			    tm->tm_hour, tm->tm_min, tm->tm_sec, now.tv_usec,
			    class == LOG_PRINT ? "Default" : "Report>");
		strlcat(nbuf, buffer, sizeof nbuf);
		strlcat(nbuf, getuid() ? "" : " [priv]", LOG_SIZE + 32);
		strlcat(nbuf, "\n", sizeof nbuf);

		if (fwrite(nbuf, strlen(nbuf), 1, log_output) == 0) {
			/* Report fallback.  */
			syslog(LOG_ALERT, fallback_msg, errno);
			fprintf(log_output, fallback_msg, errno);

			/*
			 * Close log_output to prevent isakmpd from locking
			 * the file.  We may need to explicitly close stdout
			 * to do this properly.
			 * XXX - Figure out how to match two FILE *'s and
			 * rewrite.
			 */
			if (fileno(log_output) != -1 &&
			    fileno(stdout) == fileno(log_output))
				fclose(stdout);
			fclose(log_output);

			/* Fallback to syslog.  */
			log_to(0);

			/* (Re)send current message to syslog().  */
			syslog(class == LOG_REPORT ? LOG_ALERT :
			    syslog_level, "%s", buffer);
		}
	} else
		syslog(class == LOG_REPORT ? LOG_ALERT : syslog_level, "%s",
		    buffer);
}

void
log_debug(int cls, int level, const char *fmt, ...)
{
	va_list         ap;

	/*
	 * If we are not debugging this class, or the level is too low, just
	 * return.
         */
	if (cls >= 0 && (log_level[cls] == 0 || level > log_level[cls]))
		return;
	va_start(ap, fmt);
	_log_print(0, LOG_INFO, fmt, ap, cls, level);
	va_end(ap);
}

void
log_debug_buf(int cls, int level, const char *header, const u_int8_t *buf,
    size_t sz)
{
	size_t	i, j;
	char	s[73];

	/*
	 * If we are not debugging this class, or the level is too low, just
	 * return.
         */
	if (cls >= 0 && (log_level[cls] == 0 || level > log_level[cls]))
		return;

	log_debug(cls, level, "%s:", header);
	for (i = j = 0; i < sz;) {
		snprintf(s + j, sizeof s - j, "%02x", buf[i++]);
		j += strlen(s + j);
		if (i % 4 == 0) {
			if (i % 32 == 0) {
				s[j] = '\0';
				log_debug(cls, level, "%s", s);
				j = 0;
			} else
				s[j++] = ' ';
		}
	}
	if (j) {
		s[j] = '\0';
		log_debug(cls, level, "%s", s);
	}
}

void
log_debug_cmd(int cls, int level)
{
	if (cls < 0 || cls >= LOG_ENDCLASS) {
		log_print("log_debug_cmd: invalid debugging class %d", cls);
		return;
	}
	if (level < 0) {
		log_print("log_debug_cmd: invalid debugging level %d for "
		    "class %d", level, cls);
		return;
	}
	if (level == log_level[cls])
		log_print("log_debug_cmd: log level unchanged for class %d",
		    cls);
	else {
		log_print("log_debug_cmd: log level changed from %d to %d "
		    "for class %d", log_level[cls], level, cls);
		log_level[cls] = level;
	}
}

void
log_debug_toggle(void)
{
	static int	log_level_copy[LOG_ENDCLASS], toggle = 0;

	if (!toggle) {
		LOG_DBG((LOG_MISC, 50, "log_debug_toggle: "
		    "debug levels cleared"));
		memcpy(&log_level_copy, &log_level, sizeof log_level);
		bzero(&log_level, sizeof log_level);
	} else {
		memcpy(&log_level, &log_level_copy, sizeof log_level);
		LOG_DBG((LOG_MISC, 50, "log_debug_toggle: "
		    "debug levels restored"));
	}
	toggle = !toggle;
}

void
log_print(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	_log_print(0, LOG_NOTICE, fmt, ap, LOG_PRINT, 0);
	va_end(ap);
}

void
log_verbose(const char *fmt, ...)
{
	va_list	ap;

	if (verbose_logging == 0)
		return;

	va_start(ap, fmt);
	_log_print(0, LOG_NOTICE, fmt, ap, LOG_PRINT, 0);
	va_end(ap);
}

void
log_error(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	_log_print(1, LOG_ERR, fmt, ap, LOG_PRINT, 0);
	va_end(ap);
}

void
log_errorx(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	_log_print(0, LOG_ERR, fmt, ap, LOG_PRINT, 0);
	va_end(ap);
}

void
log_fatal(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	_log_print(1, LOG_CRIT, fmt, ap, LOG_PRINT, 0);
	va_end(ap);
	monitor_exit(1);
}

void
log_fatalx(const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	_log_print(0, LOG_CRIT, fmt, ap, LOG_PRINT, 0);
	va_end(ap);
	monitor_exit(1);
}

void
log_packet_init(char *newname)
{
	struct pcap_file_header sf_hdr;
	struct stat     st;
	mode_t          old_umask;
	char           *mode;

	/* Allocate packet buffer first time through.  */
	if (!packet_buf)
		packet_buf = malloc(SNAPLEN);

	if (!packet_buf) {
		log_error("log_packet_init: malloc (%d) failed", SNAPLEN);
		return;
	}
	if (pcaplog_file && strcmp(pcaplog_file, PCAP_FILE_DEFAULT) != 0)
		free(pcaplog_file);

	pcaplog_file = strdup(newname);
	if (!pcaplog_file) {
		log_error("log_packet_init: strdup (\"%s\") failed", newname);
		return;
	}
	/* Does the file already exist?  XXX lstat() or stat()?  */
	/* XXX This is a fstat! */
	if (monitor_stat(pcaplog_file, &st) == 0) {
		/* Sanity checks.  */
		if (!S_ISREG(st.st_mode)) {
			log_print("log_packet_init: existing capture file is "
			    "not a regular file");
			return;
		}
		if ((st.st_mode & (S_IRWXG | S_IRWXO)) != 0) {
			log_print("log_packet_init: existing capture "
			    "file has bad modes");
			return;
		}
		/*
		 * XXX It would be nice to check if it actually is a pcap
		 * file...
		 */

		mode = "a";
	} else
		mode = "w";

	old_umask = umask(S_IRWXG | S_IRWXO);
	packet_log = monitor_fopen(pcaplog_file, mode);
	umask(old_umask);

	if (!packet_log) {
		log_error("log_packet_init: fopen (\"%s\", \"%s\") failed",
		    pcaplog_file, mode);
		return;
	}
	log_print("log_packet_init: "
	    "starting IKE packet capture to file \"%s\"", pcaplog_file);

	/* If this is a new file, we need to write a PCAP header to it.  */
	if (*mode == 'w') {
		sf_hdr.magic = TCPDUMP_MAGIC;
		sf_hdr.version_major = PCAP_VERSION_MAJOR;
		sf_hdr.version_minor = PCAP_VERSION_MINOR;
		sf_hdr.thiszone = 0;
		sf_hdr.snaplen = SNAPLEN;
		sf_hdr.sigfigs = 0;
		sf_hdr.linktype = DLT_LOOP;

		fwrite((char *) &sf_hdr, sizeof sf_hdr, 1, packet_log);
		fflush(packet_log);
	}
}

void
log_packet_restart(char *newname)
{
	if (packet_log) {
		log_print("log_packet_restart: capture already active on "
		    "file \"%s\"", pcaplog_file);
		return;
	}
	if (newname)
		log_packet_init(newname);
	else if (!pcaplog_file)
		log_packet_init(PCAP_FILE_DEFAULT);
	else
		log_packet_init(pcaplog_file);
}

void
log_packet_stop(void)
{
	/* Stop capture.  */
	if (packet_log) {
		fclose(packet_log);
		log_print("log_packet_stop: stopped capture");
	}
	packet_log = 0;
}

void
log_packet_iov(struct sockaddr *src, struct sockaddr *dst, struct iovec *iov,
    int iovcnt)
{
	struct isakmp_hdr *isakmphdr;
	struct packhdr  hdr;
	struct udphdr   udp;
	struct timeval  tv;
	int             off, datalen, hdrlen, i, add_espmarker = 0;
	const u_int32_t	espmarker = 0;

	for (i = 0, datalen = 0; i < iovcnt; i++)
		datalen += iov[i].iov_len;

	if (!packet_log || datalen > SNAPLEN)
		return;

	/* copy packet into buffer */
	for (i = 0, off = 0; i < iovcnt; i++) {
		memcpy(packet_buf + off, iov[i].iov_base, iov[i].iov_len);
		off += iov[i].iov_len;
	}

	bzero(&hdr, sizeof hdr);
	bzero(&udp, sizeof udp);

	/* isakmp - turn off the encryption bit in the isakmp hdr */
	isakmphdr = (struct isakmp_hdr *) packet_buf;
	isakmphdr->flags &= ~(ISAKMP_FLAGS_ENC);

	/* udp */
	udp.uh_sport = sockaddr_port(src);
	udp.uh_dport = sockaddr_port(dst);
	datalen += sizeof udp;
	if (ntohs(udp.uh_sport) == 4500 ||
	    ntohs(udp.uh_dport) == 4500) { /* XXX Quick and dirty */
		add_espmarker = 1;
		datalen += sizeof espmarker;
	}
	udp.uh_ulen = htons(datalen);

	/* ip */
	hdr.sa_family = htonl(src->sa_family);
	switch (src->sa_family) {
	default:
		/* Assume IPv4. XXX Can 'default' ever happen here?  */
		hdr.sa_family = htonl(AF_INET);
		hdr.ip.ip4.ip_src.s_addr = 0x02020202;
		hdr.ip.ip4.ip_dst.s_addr = 0x01010101;
		/* The rest of the setup is common to AF_INET.  */
		goto setup_ip4;

	case AF_INET:
		hdr.ip.ip4.ip_src.s_addr =
		    ((struct sockaddr_in *)src)->sin_addr.s_addr;
		hdr.ip.ip4.ip_dst.s_addr =
		    ((struct sockaddr_in *)dst)->sin_addr.s_addr;

setup_ip4:
		hdrlen = sizeof hdr.ip.ip4;
		hdr.ip.ip4.ip_v = 0x4;
		hdr.ip.ip4.ip_hl = 0x5;
		hdr.ip.ip4.ip_p = IPPROTO_UDP;
		hdr.ip.ip4.ip_len = htons(datalen + hdrlen);
		/* Let's use the IP ID as a "packet counter".  */
		i = ntohs(hdr.ip.ip4.ip_id) + 1;
		hdr.ip.ip4.ip_id = htons(i);
		/* Calculate IP header checksum. */
		hdr.ip.ip4.ip_sum = in_cksum((u_int16_t *) & hdr.ip.ip4,
		    hdr.ip.ip4.ip_hl << 2);
		break;

	case AF_INET6:
		hdrlen = sizeof(hdr.ip.ip6);
		hdr.ip.ip6.ip6_vfc = IPV6_VERSION;
		hdr.ip.ip6.ip6_nxt = IPPROTO_UDP;
		hdr.ip.ip6.ip6_plen = udp.uh_ulen;
		memcpy(&hdr.ip.ip6.ip6_src,
		    &((struct sockaddr_in6 *)src)->sin6_addr,
		    sizeof hdr.ip.ip6.ip6_src);
		memcpy(&hdr.ip.ip6.ip6_dst,
		    &((struct sockaddr_in6 *)dst)->sin6_addr,
		    sizeof hdr.ip.ip6.ip6_dst);
		break;
	}

	/* Calculate UDP checksum.  */
	udp.uh_sum = udp_cksum(&hdr, &udp, (u_int16_t *) packet_buf);
	hdrlen += sizeof hdr.sa_family;

	/* pcap file packet header */
	gettimeofday(&tv, 0);
	hdr.pcap.ts.tv_sec = tv.tv_sec;
	hdr.pcap.ts.tv_usec = tv.tv_usec;
	hdr.pcap.caplen = datalen + hdrlen;
	hdr.pcap.len = datalen + hdrlen;

	hdrlen += sizeof(struct pcap_pkthdr);
	datalen -= sizeof(struct udphdr);

	/* Write to pcap file.  */
	fwrite(&hdr, hdrlen, 1, packet_log);	/* pcap + IP */
	fwrite(&udp, sizeof(struct udphdr), 1, packet_log);	/* UDP */
	if (add_espmarker) {
		fwrite(&espmarker, sizeof espmarker, 1, packet_log);
		datalen -= sizeof espmarker;
	}
	fwrite(packet_buf, datalen, 1, packet_log);	/* IKE-data */
	fflush(packet_log);
}

/* Copied from tcpdump/print-udp.c, mostly rewritten.  */
static int
udp_cksum(struct packhdr *hdr, const struct udphdr *u, u_int16_t *d)
{
	struct ip	*ip4;
	struct ip6_hdr	*ip6;
	int	i, hdrlen, tlen = ntohs(u->uh_ulen) - sizeof(struct udphdr);

	union phu {
		struct ip4pseudo {
			struct in_addr  src;
			struct in_addr  dst;
			u_int8_t        z;
			u_int8_t        proto;
			u_int16_t       len;
		} ip4p;
		struct ip6pseudo {
			struct in6_addr src;
			struct in6_addr dst;
			u_int32_t       plen;
			u_int16_t       z0;
			u_int8_t        z1;
			u_int8_t        nxt;
		} ip6p;
		u_int16_t       pa[20];
	} phu;
	const u_int16_t *sp;
	u_int32_t       sum;

	/* Setup pseudoheader.  */
	bzero(phu.pa, sizeof phu);
	switch (ntohl(hdr->sa_family)) {
	case AF_INET:
		ip4 = &hdr->ip.ip4;
		memcpy(&phu.ip4p.src, &ip4->ip_src, sizeof(struct in_addr));
		memcpy(&phu.ip4p.dst, &ip4->ip_dst, sizeof(struct in_addr));
		phu.ip4p.proto = ip4->ip_p;
		phu.ip4p.len = u->uh_ulen;
		hdrlen = sizeof phu.ip4p;
		break;

	case AF_INET6:
		ip6 = &hdr->ip.ip6;
		memcpy(&phu.ip6p.src, &ip6->ip6_src, sizeof(phu.ip6p.src));
		memcpy(&phu.ip6p.dst, &ip6->ip6_dst, sizeof(phu.ip6p.dst));
		phu.ip6p.plen = u->uh_ulen;
		phu.ip6p.nxt = ip6->ip6_nxt;
		hdrlen = sizeof phu.ip6p;
		break;

	default:
		return 0;
	}

	/* IPv6 wants a 0xFFFF checksum "on error", not 0x0.  */
	if (tlen < 0)
		return (ntohl(hdr->sa_family) == AF_INET ? 0 : 0xFFFF);

	sum = 0;
	for (i = 0; i < hdrlen; i += 2)
		sum += phu.pa[i / 2];

	sp = (const u_int16_t *)u;
	for (i = 0; i < (int)sizeof(struct udphdr); i += 2)
		sum += *sp++;

	sp = d;
	for (i = 0; i < (tlen & ~1); i += 2)
		sum += *sp++;

	if (tlen & 1)
		sum += htons((*(const char *)sp) << 8);

	while (sum > 0xffff)
		sum = (sum & 0xffff) + (sum >> 16);
	sum = ~sum & 0xffff;

	return sum;
}

/* Copied from tcpdump/print-ip.c, modified.  */
static u_int16_t
in_cksum(const u_int16_t *w, int len)
{
	int		nleft = len, sum = 0;
	u_int16_t       answer;

	while (nleft > 1) {
		sum += *w++;
		nleft -= 2;
	}
	if (nleft == 1)
		sum += htons(*(const u_char *)w << 8);

	sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
	sum += (sum >> 16);	/* add carry */
	answer = ~sum;		/* truncate to 16 bits */
	return answer;
}
@


1.61
log
@Allow -v (verbose logging) to work if a -D option is supplied.
Previously, a specific check was made for any -D log option being
used and, if so, *no* -v log entries are made, losing potentially
useful log entries.  ok lum@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.60 2007/06/02 01:29:11 pvalchev Exp $	 */
a39 1
#include <netinet/in_systm.h>
@


1.60
log
@safer snprintf construct with more paranoid length calculation
ok millert
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.59 2006/09/19 10:48:41 otto Exp $	 */
a331 1
	int	i;
a334 4

	for (i = 0; i < LOG_ENDCLASS; i++)
		if (log_level[i] > 0)
			return;
@


1.59
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by/partly
from Paul Stoeber, more to come. ok ho@@ miod@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.58 2005/05/26 05:35:55 moritz Exp $	 */
d262 1
a262 1
		j += 2;
@


1.58
log
@add log_errorx() which doesn't print the errno value. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.57 2005/05/03 13:42:54 hshoexer Exp $	 */
d416 1
a416 1
		if ((st.st_mode & S_IFMT) != S_IFREG) {
@


1.57
log
@provide log_fatalx() function, that does not print an error string (like err
vs. errx).  Not used yet.

ok moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.56 2005/04/08 19:40:03 deraadt Exp $	 */
d353 10
@


1.56
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.55 2005/04/08 16:37:14 deraadt Exp $	 */
d363 11
@


1.55
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.54 2005/04/08 16:24:12 deraadt Exp $	 */
a35 1
#ifdef USE_DEBUG
a47 2
#endif				/* USE_DEBUG */

a66 1
#if defined (USE_DEBUG)
a93 1
#endif				/* USE_DEBUG */
a107 1
#ifdef USE_DEBUG
a109 1
#endif				/* USE_DEBUG */
a115 1
#ifdef USE_DEBUG
a134 1
#endif				/* USE_DEBUG */
a228 1
#ifdef USE_DEBUG
a316 1
#endif				/* USE_DEBUG */
a331 1
#ifdef USE_DEBUG
a332 1
#endif				/* USE_DEBUG */
a336 1
#ifdef USE_DEBUG
a339 1
#endif
a366 1
#ifdef USE_DEBUG
a677 2

#endif				/* USE_DEBUG */
@


1.54
log
@privsep always
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.53 2005/04/08 16:14:04 deraadt Exp $	 */
a517 1
#if defined (USE_NAT_TRAVERSAL)
a522 1
#endif
@


1.53
log
@kill HAVE_PCAP
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.52 2005/04/04 19:31:11 deraadt Exp $	 */
a205 1
#if defined (USE_PRIVSEP)
a206 1
#endif
a378 1
#ifdef USE_PRIVSEP
a379 3
#else
	exit(1);
#endif
a407 1
#if defined (USE_PRIVSEP)
a409 3
#else
	if (lstat(pcaplog_file, &st) == 0) {
#endif
@


1.52
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.51 2005/02/27 13:12:12 hshoexer Exp $	 */
a46 1
#ifdef HAVE_PCAP
a47 3
#else
#include "sysdep/common/pcap.h"
#endif
@


1.51
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.50 2004/11/08 11:59:37 hshoexer Exp $	 */
d427 1
a427 1
			     "not a regular file");
@


1.50
log
@make lint happy and honor const.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.49 2004/08/08 19:11:06 deraadt Exp $	 */
d325 1
a325 1
		memset(&log_level, 0, sizeof log_level);
d521 2
a522 2
	memset(&hdr, 0, sizeof hdr);
	memset(&udp, 0, sizeof udp);
d641 1
a641 1
	memset(phu.pa, 0, sizeof phu);
@


1.49
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.48 2004/06/25 00:58:39 hshoexer Exp $	 */
d673 1
a673 1
	sp = (u_int16_t *) u;
d703 1
a703 1
		sum += htons(*(u_char *) w << 8);
@


1.48
log
@Narrow down privsep interface.  Remove ui_init to monitor. So we can get rid of
monitor_mkfifo.

Work in progress.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.47 2004/06/21 16:37:30 ho Exp $	 */
d223 1
a223 1
			 * to do this properly.  
@


1.47
log
@Don't write too much IKE data in packet capture
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.46 2004/06/21 16:01:56 ho Exp $	 */
d385 3
d389 1
@


1.46
log
@Packet capture should add the ESP-marker when NAT-T is active.
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.45 2004/06/14 09:55:41 ho Exp $	 */
d599 1
a599 1
	if (add_espmarker)
d601 2
@


1.45
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.44 2004/05/23 18:17:56 hshoexer Exp $	 */
a500 1
	int             off, datalen, hdrlen, i;
d502 2
d528 7
d599 2
@


1.44
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.43 2004/04/15 18:39:26 deraadt Exp $	 */
d99 2
a100 1
static int      udp_cksum(struct packhdr *, const struct udphdr *, u_int16_t *);
d186 1
a186 1
	    "write to log file failed (errno %d), redirecting output to syslog";
d322 2
a323 1
		LOG_DBG((LOG_MISC, 50, "log_debug_toggle: debug levels cleared"));
d328 2
a329 1
		LOG_DBG((LOG_MISC, 50, "log_debug_toggle: debug levels restored"));
d449 2
a450 2
	log_print("log_packet_init: starting IKE packet capture to file \"%s\"",
	    pcaplog_file);
@


1.43
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: log.c,v 1.42 2004/04/07 22:45:49 ho Exp $	 */
d138 2
a139 2
				log_print("init: invalid logging class or level: %s",
				    logclass->field);
d193 2
a194 1
		snprintf(buffer + len, sizeof buffer - len, ": %s", strerror(errno));
d200 2
a201 1
			snprintf(nbuf, sizeof nbuf, "%02d%02d%02d.%06ld %s %02d ",
d220 5
a224 3
			 * Close log_output to prevent isakmpd from locking the file.
			 * We may need to explicitly close stdout to do this properly.
			 * XXX - Figure out how to match two FILE *'s and rewrite.
d239 2
a240 2
		syslog(class == LOG_REPORT ? LOG_ALERT : syslog_level,
		    "%s", buffer);
d250 2
a251 1
	 * If we are not debugging this class, or the level is too low, just return.
d268 2
a269 1
	 * If we are not debugging this class, or the level is too low, just return.
d301 2
a302 2
		log_print("log_debug_cmd: invalid debugging level %d for class %d",
		    level, cls);
d306 2
a307 1
		log_print("log_debug_cmd: log level unchanged for class %d", cls);
d309 2
a310 2
		log_print("log_debug_cmd: log level changed from %d to %d for class %d",
		    log_level[cls], level, cls);
d335 1
a335 1
	va_list         ap;
d345 1
a345 1
	va_list         ap;
d347 1
a347 1
	int             i;
d367 1
a367 1
	va_list         ap;
d377 1
a377 1
	va_list         ap;
d468 2
a469 2
		log_print("log_packet_restart: capture already active on file \"%s\"",
		    pcaplog_file);
d492 1
a492 1
log_packet_iov(struct sockaddr * src, struct sockaddr * dst, struct iovec * iov,
d538 4
a541 2
		hdr.ip.ip4.ip_src.s_addr = ((struct sockaddr_in *) src)->sin_addr.s_addr;
		hdr.ip.ip4.ip_dst.s_addr = ((struct sockaddr_in *) dst)->sin_addr.s_addr;
d562 2
a563 1
		memcpy(&hdr.ip.ip6.ip6_src, &((struct sockaddr_in6 *) src)->sin6_addr,
d565 2
a566 1
		memcpy(&hdr.ip.ip6.ip6_dst, &((struct sockaddr_in6 *) dst)->sin6_addr,
d655 1
a655 1
	for (i = 0; i < (int) sizeof(struct udphdr); i += 2)
d663 1
a663 1
		sum += htons((*(const char *) sp) << 8);
d676 1
a676 1
	int             nleft = len, sum = 0;
@


1.42
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.41 2004/03/19 14:04:43 hshoexer Exp $	*/
/*	$EOM: log.c,v 1.30 2000/09/29 08:19:23 niklas Exp $	*/
d53 1
a53 1
#endif /* USE_DEBUG */
d69 1
a69 1
static void _log_print (int, int, const char *, va_list, int, int);
d71 1
a71 1
static FILE *log_output;
d73 1
a73 1
int verbose_logging = 0;
d75 1
a75 1
static int log_level[LOG_ENDCLASS];
d81 6
a86 6
  struct pcap_pkthdr pcap;		/* pcap file packet header */
  u_int32_t sa_family;			/* address family */
  union {
    struct ip ip4;			/* IPv4 header (w/o options) */
    struct ip6_hdr ip6;			/* IPv6 header */
  } ip;
d90 3
a92 3
  u_int8_t icookie[8], rcookie[8];
  u_int8_t next, ver, type, flags;
  u_int32_t msgid, len;
d95 2
a96 2
static char *pcaplog_file = NULL;
static FILE *packet_log;
d99 3
a101 3
static int udp_cksum (struct packhdr *, const struct udphdr *, u_int16_t *);
static u_int16_t in_cksum (const u_int16_t *, int);
#endif /* USE_DEBUG */
d104 1
a104 1
log_init (int debug)
d106 4
a109 4
  if (debug)
    log_output = stderr;
  else
    log_to (0); /* syslog */
d113 1
a113 1
log_reinit (void)
d115 1
a115 1
  struct conf_list *logging;
d117 9
a125 12
  struct conf_list_node *logclass;
  int class, level;
#endif  /* USE_DEBUG */

  logging = conf_get_list ("General", "Logverbose");
  if (logging)
    {
      verbose_logging = 1;
      conf_free_list (logging);
    }


d127 17
a143 20
  logging = conf_get_list ("General", "Loglevel");
  if (logging)
    {
      for (logclass = TAILQ_FIRST (&logging->fields); logclass;
	   logclass = TAILQ_NEXT (logclass, link))
	{
	  if (sscanf (logclass->field, "%d=%d", &class, &level) != 2)
	    {
	      if (sscanf (logclass->field, "A=%d", &level) == 1)
		  for (class = 0; class < LOG_ENDCLASS; class++)
		    log_debug_cmd (class, level);
	      else
		{
		  log_print ("init: invalid logging class or level: %s",
			     logclass->field);
		  continue;
		}
	    }
	  else
	    log_debug_cmd (class, level);
d145 2
a146 3
      conf_free_list (logging);
    }
#endif /* USE_DEBUG */
d150 1
a150 1
log_to (FILE *f)
d152 5
a156 5
  if (!log_output && f)
    closelog ();
  log_output = f;
  if (!f)
    openlog ("isakmpd", LOG_PID | LOG_CONS, LOG_DAEMON);
d160 1
a160 1
log_current (void)
d162 1
a162 1
  return log_output;
d166 1
a166 1
_log_get_class (int error_class)
d168 2
a169 2
  /* XXX For test purposes. To be removed later on?  */
  static char *class_text[] = LOG_CLASSES_TEXT;
d171 6
a176 6
  if (error_class < 0)
    return "Dflt";
  else if (error_class >= LOG_ENDCLASS)
    return "Unkn";
  else
    return class_text[error_class];
d180 2
a181 2
_log_print (int error, int syslog_level, const char *fmt, va_list ap,
	    int class, int level)
d183 24
a206 25
  char buffer[LOG_SIZE], nbuf[LOG_SIZE + 32];
  static const char fallback_msg[] =
    "write to log file failed (errno %d), redirecting output to syslog";
  int len;
  struct tm *tm;
  struct timeval now;
  time_t t;

  len = vsnprintf (buffer, sizeof buffer, fmt, ap);
  if (len > 0 && len < (int)sizeof buffer - 1 && error)
    snprintf (buffer + len, sizeof buffer - len, ": %s", strerror (errno));
  if (log_output)
    {
      gettimeofday (&now, 0);
      t = now.tv_sec;
      tm = localtime (&t);
      if (class >= 0)
	snprintf (nbuf, sizeof nbuf, "%02d%02d%02d.%06ld %s %02d ",
		  tm->tm_hour, tm->tm_min, tm->tm_sec, now.tv_usec,
		  _log_get_class (class), level);
      else /* LOG_PRINT (-1) or LOG_REPORT (-2) */
	snprintf (nbuf, sizeof nbuf, "%02d%02d%02d.%06ld %s ", tm->tm_hour,
		  tm->tm_min, tm->tm_sec, now.tv_usec,
		  class == LOG_PRINT ? "Default" : "Report>");
      strlcat (nbuf, buffer, sizeof nbuf);
d208 1
a208 1
      strlcat (nbuf, getuid () ? "" : " [priv]", LOG_SIZE + 32);
d210 1
a210 1
      strlcat (nbuf, "\n", sizeof nbuf);
d212 25
a236 26
      if (fwrite (nbuf, strlen (nbuf), 1, log_output) == 0)
	{
	  /* Report fallback.  */
	  syslog (LOG_ALERT, fallback_msg, errno);
	  fprintf (log_output, fallback_msg, errno);

	  /*
	   * Close log_output to prevent isakmpd from locking the file.
	   * We may need to explicitly close stdout to do this properly.
	   * XXX - Figure out how to match two FILE *'s and rewrite.
	   */
	  if (fileno (log_output) != -1
	      && fileno (stdout) == fileno (log_output))
	    fclose (stdout);
	  fclose (log_output);

	  /* Fallback to syslog.  */
	  log_to (0);

	  /* (Re)send current message to syslog().  */
	  syslog (class == LOG_REPORT ? LOG_ALERT
		  : syslog_level, "%s", buffer);
	}
    }
  else
    syslog (class == LOG_REPORT ? LOG_ALERT : syslog_level, "%s", buffer);
d241 1
a241 1
log_debug (int cls, int level, const char *fmt, ...)
d243 1
a243 1
  va_list ap;
d245 8
a252 8
  /*
   * If we are not debugging this class, or the level is too low, just return.
   */
  if (cls >= 0 && (log_level[cls] == 0 || level > log_level[cls]))
    return;
  va_start (ap, fmt);
  _log_print (0, LOG_INFO, fmt, ap, cls, level);
  va_end (ap);
d256 28
a283 27
log_debug_buf (int cls, int level, const char *header, const u_int8_t *buf,
	       size_t sz)
{
  char s[73];
  size_t i, j;

  /*
   * If we are not debugging this class, or the level is too low, just return.
   */
  if (cls >= 0 && (log_level[cls] == 0 || level > log_level[cls]))
    return;

  log_debug (cls, level, "%s:", header);
  for (i = j = 0; i < sz;)
    {
      snprintf (s + j, sizeof s - j, "%02x", buf[i++]);
      j += 2;
      if (i % 4 == 0)
	{
	  if (i % 32 == 0)
	    {
	      s[j] = '\0';
	      log_debug (cls, level, "%s", s);
	      j = 0;
	    }
	  else
	    s[j++] = ' ';
a284 6
    }
  if (j)
    {
      s[j] = '\0';
      log_debug (cls, level, "%s", s);
    }
d288 1
a288 1
log_debug_cmd (int cls, int level)
d290 16
a305 21
  if (cls < 0 || cls >= LOG_ENDCLASS)
    {
      log_print ("log_debug_cmd: invalid debugging class %d", cls);
      return;
    }

  if (level < 0)
    {
      log_print ("log_debug_cmd: invalid debugging level %d for class %d",
		 level, cls);
      return;
    }

  if (level == log_level[cls])
    log_print ("log_debug_cmd: log level unchanged for class %d", cls);
  else
    {
      log_print ("log_debug_cmd: log level changed from %d to %d for class %d",
		 log_level[cls], level, cls);
      log_level[cls] = level;
    }
d309 1
a309 1
log_debug_toggle (void)
d311 1
a311 1
  static int log_level_copy[LOG_ENDCLASS], toggle = 0;
d313 9
a321 12
  if (!toggle)
    {
      LOG_DBG ((LOG_MISC, 50, "log_debug_toggle: debug levels cleared"));
      memcpy (&log_level_copy, &log_level, sizeof log_level);
      memset (&log_level, 0, sizeof log_level);
    }
  else
    {
      memcpy (&log_level, &log_level_copy, sizeof log_level);
      LOG_DBG ((LOG_MISC, 50, "log_debug_toggle: debug levels restored"));
    }
  toggle = !toggle;
d323 1
a323 1
#endif /* USE_DEBUG */
d326 1
a326 1
log_print (const char *fmt, ...)
d328 1
a328 1
  va_list ap;
d330 3
a332 3
  va_start (ap, fmt);
  _log_print (0, LOG_NOTICE, fmt, ap, LOG_PRINT, 0);
  va_end (ap);
d336 1
a336 1
log_verbose (const char *fmt, ...)
d338 1
a338 1
  va_list ap;
d340 2
a341 2
  int i;
#endif /* USE_DEBUG */
d343 2
a344 2
  if (verbose_logging == 0)
    return;
d347 3
a349 3
  for (i = 0; i < LOG_ENDCLASS; i++)
    if (log_level[i] > 0)
      return;
d352 3
a354 3
  va_start (ap, fmt);
  _log_print (0, LOG_NOTICE, fmt, ap, LOG_PRINT, 0);
  va_end (ap);
d358 1
a358 1
log_error (const char *fmt, ...)
d360 1
a360 1
  va_list ap;
d362 3
a364 3
  va_start (ap, fmt);
  _log_print (1, LOG_ERR, fmt, ap, LOG_PRINT, 0);
  va_end (ap);
d368 1
a368 1
log_fatal (const char *fmt, ...)
d370 1
a370 1
  va_list ap;
d372 4
a375 4
  va_start (ap, fmt);
  _log_print (1, LOG_CRIT, fmt, ap, LOG_PRINT, 0);
  va_end (ap);
  exit (1);
d380 1
a380 1
log_packet_init (char *newname)
d382 15
a396 24
  struct pcap_file_header sf_hdr;
  struct stat st;
  mode_t old_umask;
  char *mode;

  /* Allocate packet buffer first time through.  */
  if (!packet_buf)
    packet_buf = malloc (SNAPLEN);

  if (!packet_buf)
    {
      log_error ("log_packet_init: malloc (%d) failed", SNAPLEN);
      return;
    }

  if (pcaplog_file && strcmp (pcaplog_file, PCAP_FILE_DEFAULT) != 0)
    free (pcaplog_file);

  pcaplog_file = strdup (newname);
  if (!pcaplog_file)
    {
      log_error ("log_packet_init: strdup (\"%s\") failed", newname);
      return;
    }
d398 6
a403 1
  /* Does the file already exist?  XXX lstat() or stat()?  */
d405 2
a406 2
  /* XXX This is a fstat! */
  if (monitor_stat (pcaplog_file, &st) == 0)
d408 1
a408 1
  if (lstat (pcaplog_file, &st) == 0)
d410 169
a578 180
    {
      /* Sanity checks.  */
      if ((st.st_mode & S_IFMT) != S_IFREG)
	{
	  log_print ("log_packet_init: existing capture file is "
		     "not a regular file");
	  return;
	}

      if ((st.st_mode & (S_IRWXG | S_IRWXO)) != 0)
	{
	  log_print ("log_packet_init: existing capture file has bad modes");
	  return;
	}

      /* XXX It would be nice to check if it actually is a pcap file... */

      mode = "a";
    }
  else
    mode = "w";

  old_umask = umask (S_IRWXG | S_IRWXO);
  packet_log = monitor_fopen (pcaplog_file, mode);
  umask (old_umask);

  if (!packet_log)
    {
      log_error ("log_packet_init: fopen (\"%s\", \"%s\") failed",
		 pcaplog_file, mode);
      return;
    }

  log_print ("log_packet_init: starting IKE packet capture to file \"%s\"",
	     pcaplog_file);

  /* If this is a new file, we need to write a PCAP header to it.  */
  if (*mode == 'w')
    {
      sf_hdr.magic = TCPDUMP_MAGIC;
      sf_hdr.version_major = PCAP_VERSION_MAJOR;
      sf_hdr.version_minor = PCAP_VERSION_MINOR;
      sf_hdr.thiszone = 0;
      sf_hdr.snaplen = SNAPLEN;
      sf_hdr.sigfigs = 0;
      sf_hdr.linktype = DLT_LOOP;

      fwrite ((char *)&sf_hdr, sizeof sf_hdr, 1, packet_log);
      fflush (packet_log);
    }
}

void
log_packet_restart (char *newname)
{
  if (packet_log)
    {
      log_print ("log_packet_restart: capture already active on file \"%s\"",
		 pcaplog_file);
      return;
    }

  if (newname)
    log_packet_init (newname);
  else if (!pcaplog_file)
    log_packet_init (PCAP_FILE_DEFAULT);
  else
    log_packet_init (pcaplog_file);
}

void
log_packet_stop (void)
{
  /* Stop capture.  */
  if (packet_log)
    {
      fclose (packet_log);
      log_print ("log_packet_stop: stopped capture");
    }
  packet_log = 0;
}

void
log_packet_iov (struct sockaddr *src, struct sockaddr *dst, struct iovec *iov,
		int iovcnt)
{
  struct isakmp_hdr *isakmphdr;
  struct packhdr hdr;
  struct udphdr udp;
  int off, datalen, hdrlen, i;
  struct timeval tv;

  for (i = 0, datalen = 0; i < iovcnt; i++)
    datalen += iov[i].iov_len;

  if (!packet_log || datalen > SNAPLEN)
    return;

  /* copy packet into buffer */
  for (i = 0, off = 0; i < iovcnt; i++)
    {
      memcpy (packet_buf + off, iov[i].iov_base, iov[i].iov_len);
      off += iov[i].iov_len;
    }

  memset (&hdr, 0, sizeof hdr);
  memset (&udp, 0, sizeof udp);

  /* isakmp - turn off the encryption bit in the isakmp hdr */
  isakmphdr = (struct isakmp_hdr *)packet_buf;
  isakmphdr->flags &= ~(ISAKMP_FLAGS_ENC);

  /* udp */
  udp.uh_sport = sockaddr_port (src);
  udp.uh_dport = sockaddr_port (dst);
  datalen += sizeof udp;
  udp.uh_ulen = htons (datalen);

  /* ip */
  hdr.sa_family = htonl (src->sa_family);
  switch (src->sa_family)
    {
    default:
      /* Assume IPv4. XXX Can 'default' ever happen here?  */
      hdr.sa_family = htonl (AF_INET);
      hdr.ip.ip4.ip_src.s_addr = 0x02020202;
      hdr.ip.ip4.ip_dst.s_addr = 0x01010101;
      /* The rest of the setup is common to AF_INET.  */
      goto setup_ip4;

    case AF_INET:
      hdr.ip.ip4.ip_src.s_addr = ((struct sockaddr_in *)src)->sin_addr.s_addr;
      hdr.ip.ip4.ip_dst.s_addr = ((struct sockaddr_in *)dst)->sin_addr.s_addr;

    setup_ip4:
      hdrlen = sizeof hdr.ip.ip4;
      hdr.ip.ip4.ip_v = 0x4;
      hdr.ip.ip4.ip_hl = 0x5;
      hdr.ip.ip4.ip_p = IPPROTO_UDP;
      hdr.ip.ip4.ip_len = htons (datalen + hdrlen);
      /* Let's use the IP ID as a "packet counter".  */
      i = ntohs (hdr.ip.ip4.ip_id) + 1;
      hdr.ip.ip4.ip_id = htons (i);
      /* Calculate IP header checksum. */
      hdr.ip.ip4.ip_sum = in_cksum ((u_int16_t *)&hdr.ip.ip4,
				    hdr.ip.ip4.ip_hl << 2);
      break;

    case AF_INET6:
      hdrlen = sizeof (hdr.ip.ip6);
      hdr.ip.ip6.ip6_vfc = IPV6_VERSION;
      hdr.ip.ip6.ip6_nxt = IPPROTO_UDP;
      hdr.ip.ip6.ip6_plen = udp.uh_ulen;
      memcpy (&hdr.ip.ip6.ip6_src, &((struct sockaddr_in6 *)src)->sin6_addr,
	      sizeof hdr.ip.ip6.ip6_src);
      memcpy (&hdr.ip.ip6.ip6_dst, &((struct sockaddr_in6 *)dst)->sin6_addr,
	      sizeof hdr.ip.ip6.ip6_dst);
      break;
   }

  /* Calculate UDP checksum.  */
  udp.uh_sum = udp_cksum (&hdr, &udp, (u_int16_t *)packet_buf);
  hdrlen += sizeof hdr.sa_family;

  /* pcap file packet header */
  gettimeofday (&tv, 0);
  hdr.pcap.ts.tv_sec = tv.tv_sec;
  hdr.pcap.ts.tv_usec = tv.tv_usec;
  hdr.pcap.caplen = datalen + hdrlen;
  hdr.pcap.len = datalen + hdrlen;

  hdrlen += sizeof (struct pcap_pkthdr);
  datalen -= sizeof (struct udphdr);

  /* Write to pcap file.  */
  fwrite (&hdr, hdrlen, 1, packet_log);			/* pcap + IP */
  fwrite (&udp, sizeof (struct udphdr), 1, packet_log);	/* UDP */
  fwrite (packet_buf, datalen, 1, packet_log);		/* IKE-data */
  fflush (packet_log);
  return;
d583 1
a583 1
udp_cksum (struct packhdr *hdr, const struct udphdr *u, u_int16_t *d)
d585 72
a656 73
  int i, hdrlen, tlen = ntohs (u->uh_ulen) - sizeof (struct udphdr);
  struct ip *ip4;
  struct ip6_hdr *ip6;

  union phu {
    struct ip4pseudo {
      struct in_addr src;
      struct in_addr dst;
      u_int8_t z;
      u_int8_t proto;
      u_int16_t len;
    } ip4p;
    struct ip6pseudo {
      struct in6_addr src;
      struct in6_addr dst;
      u_int32_t plen;
      u_int16_t z0;
      u_int8_t z1;
      u_int8_t nxt;
    } ip6p;
    u_int16_t pa[20];
  } phu;
  const u_int16_t *sp;
  u_int32_t sum;

  /* Setup pseudoheader.  */
  memset (phu.pa, 0, sizeof phu);
  switch (ntohl (hdr->sa_family))
    {
    case AF_INET:
      ip4 = &hdr->ip.ip4;
      memcpy (&phu.ip4p.src, &ip4->ip_src, sizeof (struct in_addr));
      memcpy (&phu.ip4p.dst, &ip4->ip_dst, sizeof (struct in_addr));
      phu.ip4p.proto = ip4->ip_p;
      phu.ip4p.len = u->uh_ulen;
      hdrlen = sizeof phu.ip4p;
      break;

    case AF_INET6:
      ip6 = &hdr->ip.ip6;
      memcpy (&phu.ip6p.src, &ip6->ip6_src, sizeof (phu.ip6p.src));
      memcpy (&phu.ip6p.dst, &ip6->ip6_dst, sizeof (phu.ip6p.dst));
      phu.ip6p.plen = u->uh_ulen;
      phu.ip6p.nxt = ip6->ip6_nxt;
      hdrlen = sizeof phu.ip6p;
      break;

    default:
      return 0;
    }

  /* IPv6 wants a 0xFFFF checksum "on error", not 0x0.  */
  if (tlen < 0)
    return (ntohl (hdr->sa_family) == AF_INET ? 0 : 0xFFFF);

  sum = 0;
  for (i = 0; i < hdrlen; i += 2)
    sum += phu.pa[i/2];

  sp = (u_int16_t *)u;
  for (i = 0; i < (int)sizeof (struct udphdr); i += 2)
    sum += *sp++;

  sp = d;
  for (i = 0; i < (tlen&~1); i += 2)
    sum += *sp++;

  if (tlen & 1)
    sum += htons ((*(const char *)sp) << 8);

  while (sum > 0xffff)
    sum = (sum & 0xffff) + (sum >> 16);
  sum = ~sum & 0xffff;
d658 1
a658 1
  return sum;
d663 1
a663 1
in_cksum (const u_int16_t *w, int len)
d665 2
a666 2
  int nleft = len, sum = 0;
  u_int16_t answer;
d668 6
a673 6
  while (nleft > 1)  {
    sum += *w++;
    nleft -= 2;
  }
  if (nleft == 1)
    sum += htons (*(u_char *)w << 8);
d675 4
a678 4
  sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
  sum += (sum >> 16);                     /* add carry */
  answer = ~sum;                          /* truncate to 16 bits */
  return answer;
d681 1
a681 1
#endif /* USE_DEBUG */
@


1.41
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.40 2004/02/25 16:01:28 hshoexer Exp $	*/
d199 1
a199 1
  if (len > 0 && len < sizeof buffer - 1 && error)
d269 1
a269 1
  int i, j;
d682 1
a682 1
  for (i = 0; i < sizeof (struct udphdr); i += 2)
@


1.40
log
@Add and document configuration options Logverbose and Loglevel.  As log.c now
depends on conf.c and some regression tests use log.c, add conf.c to
Makefiles where necessary.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.39 2004/02/19 09:54:52 ho Exp $	*/
d430 4
d435 1
@


1.39
log
@With -d, SIGINT should do a clean shutdown.
Without -d, logs should be sent to syslog, level LOG_INFO.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.38 2004/01/16 10:51:57 hshoexer Exp $	*/
d63 1
d110 44
@


1.38
log
@Added -v option.  Enables logging of successful exchange completion.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.37 2003/12/14 14:50:23 ho Exp $	*/
d103 1
a103 1
log_init (void)
d105 4
a108 1
  log_output = stderr;
d215 1
a215 1
  _log_print (0, LOG_DEBUG, fmt, ap, cls, level);
@


1.37
log
@Log the actual port for src and dst, don't assume it's always 500.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.36 2003/11/06 16:12:07 ho Exp $	*/
d72 1
d303 22
@


1.36
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.35 2003/06/10 16:41:29 deraadt Exp $	*/
d66 1
d473 2
a474 1
  udp.uh_sport = udp.uh_dport = htons (500);
@


1.35
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.34 2003/06/03 14:28:16 ho Exp $	*/
d166 1
a166 1
      strlcat (nbuf, getuid() ? "" : " [priv]", LOG_SIZE + 32);
@


1.34
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.33 2003/06/03 12:51:39 ho Exp $	*/
a641 1
  
@


1.33
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.32 2003/05/18 19:37:46 ho Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999, 2000, 2001 Håkan Olsson.  All rights reserved.
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.32
log
@More isakmpd privsep work. X509 private keys are now kept in the privileged
process only. Various cleanup and bugfixes.
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.31 2003/05/15 00:28:53 ho Exp $	*/
d153 3
a155 3
  len = vsnprintf (buffer, LOG_SIZE, fmt, ap);
  if (len > 0 && len < LOG_SIZE - 1 && error)
    snprintf (buffer + len, LOG_SIZE - len, ": %s", strerror (errno));
d162 1
a162 1
	snprintf (nbuf, LOG_SIZE + 32, "%02d%02d%02d.%06ld %s %02d ",
d166 1
a166 1
	snprintf (nbuf, LOG_SIZE + 32, "%02d%02d%02d.%06ld %s ", tm->tm_hour,
d169 1
a169 1
      strlcat (nbuf, buffer, LOG_SIZE + 32);
d173 1
a173 1
      strlcat (nbuf, "\n", LOG_SIZE + 32);
d235 1
a235 1
      snprintf (s + j, 73 - j, "%02x", buf[i++]);
@


1.31
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.30 2002/08/08 13:25:28 ho Exp $	*/
d189 1
a189 1
	  fclose (log_output); /* XXX monitor_fclose ? */
d440 1
a440 1
      monitor_fclose (packet_log);
@


1.30
log
@Append to the packet log file, don't overwrite. Requested by pb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.29 2002/06/09 08:13:06 todd Exp $	*/
d66 1
d70 1
d76 1
a76 1
#ifdef USE_DEBUG
d168 1
a168 1
		  class == LOG_PRINT ? "Default" : "Report>");	
d170 3
d189 1
a189 1
	  fclose (log_output);
d387 1
a387 1
  packet_log = fopen (pcaplog_file, mode);
d440 1
a440 1
      fclose (packet_log);
d647 1
@


1.29
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.28 2002/05/10 15:13:12 ho Exp $	*/
d333 1
d335 1
d357 24
d382 1
a382 1
  packet_log = fopen (pcaplog_file, "w");
d387 2
a388 2
      log_error ("log_packet_init: fopen (\"%s\", \"w\") failed",
		 pcaplog_file);
d395 10
a404 7
  sf_hdr.magic = TCPDUMP_MAGIC;
  sf_hdr.version_major = PCAP_VERSION_MAJOR;
  sf_hdr.version_minor = PCAP_VERSION_MINOR;
  sf_hdr.thiszone = 0;
  sf_hdr.snaplen = SNAPLEN;
  sf_hdr.sigfigs = 0;
  sf_hdr.linktype = DLT_LOOP;
d406 3
a408 2
  fwrite ((char *)&sf_hdr, sizeof sf_hdr, 1, packet_log);
  fflush (packet_log);
a413 2
  struct stat st;

d422 1
a422 7
    {
      if (stat (newname, &st) == 0)
	log_print ("log_packet_restart: won't overwrite existing \"%s\"",
		   newname);
      else
	log_packet_init (newname);
    }
d425 1
a425 1
  else if (stat (pcaplog_file, &st) != 0)
a426 11
  else
    {
      /* Re-activate capture on current file.  */
      packet_log = fopen (pcaplog_file, "a");
      if (!packet_log)
	log_error ("log_packet_restart: fopen (\"%s\", \"a\") failed",
		   pcaplog_file);
      else
	log_print ("log_packet_restart: capture restarted on file \"%s\"",
		   pcaplog_file);
    }
@


1.28
log
@Use DLT_LOOP instead of DLT_NULL for pcap, to keep track of changes in
tcpdump(8). This repairs the '-L' (cleartext packet capture) option.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.27 2002/02/19 19:39:38 millert Exp $	*/
d140 1
a140 1
_log_print (int error, int syslog_level, const char *fmt, va_list ap, 
d144 1
a144 1
  static const char fallback_msg[] = 
d164 1
a164 1
	snprintf (nbuf, LOG_SIZE + 32, "%02d%02d%02d.%06ld %s ", tm->tm_hour, 
d176 1
a176 1
	  /* 
d180 1
a180 1
	   */  
d361 1
a361 1
      log_error ("log_packet_init: fopen (\"%s\", \"w\") failed", 
d366 1
a366 1
  log_print ("log_packet_init: starting IKE packet capture to file \"%s\"", 
d396 1
a396 1
	log_print ("log_packet_restart: won't overwrite existing \"%s\"", 
d410 1
a410 1
	log_error ("log_packet_restart: fopen (\"%s\", \"a\") failed", 
d442 1
a442 1
  
d445 1
a445 1
  
d447 1
a447 1
  for (i = 0, off = 0; i < iovcnt; i++) 
d455 1
a455 1
  
d459 1
a459 1
  
d464 1
a464 1
  
d473 1
a473 1
      hdr.ip.ip4.ip_dst.s_addr = 0x01010101; 
d595 1
a595 1
  
d599 1
a599 1
  
d602 1
a602 1
  
d606 1
a606 1
  
d616 1
a616 1
  
d623 1
a623 1
  
@


1.27
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.26 2002/01/23 18:44:47 ho Exp $	*/
d375 1
a375 1
  sf_hdr.linktype = DLT_NULL;
@


1.27.2.1
log
@Pull in patch from current:
Fix (ho):
Use DLT_LOOP instead of DLT_NULL for pcap, to keep track of changes in
tcpdump(8). This repairs the '-L' (cleartext packet capture) option.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.27 2002/02/19 19:39:38 millert Exp $	*/
d375 1
a375 1
  sf_hdr.linktype = DLT_LOOP;
@


1.26
log
@the last few sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.25 2002/01/03 16:27:41 ho Exp $	*/
a64 2

#ifdef __STDC__
a65 3
#else
#include <varargs.h>
#endif
a199 1
#ifdef __STDC__
a200 7
#else
log_debug (cls, level, fmt, va_alist)
     int cls;
     int level;
     const char *fmt;
     va_dcl
#endif
a208 1
#ifdef __STDC__
a209 4
#else
  va_start (ap);
  fmt = va_arg (ap, const char *);
#endif
a297 1
#ifdef __STDC__
a298 5
#else
log_print (fmt, va_alist)
     const char *fmt;
     va_dcl
#endif
a301 1
#ifdef __STDC__
a302 4
#else
  va_start (ap);
  fmt = va_arg (ap, const char *);
#endif
a307 1
#ifdef __STDC__
a308 5
#else
log_error (fmt, va_alist)
     const char *fmt;
     va_dcl
#endif
a311 1
#ifdef __STDC__
a312 4
#else
  va_start (ap);
  fmt = va_arg (ap, const char *);
#endif
a317 1
#ifdef __STDC__
a318 5
#else
log_fatal (fmt, va_alist)
     const char *fmt;
     va_dcl
#endif
a321 1
#ifdef __STDC__
a322 4
#else
  va_start (ap);
  fmt = va_arg (ap, const char *);
#endif
@


1.25
log
@str[n]{cpy,cat} -> strl{cpy,cat}, sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.24 2001/10/05 08:18:37 ho Exp $	*/
d248 1
a248 1
      sprintf (s + j, "%02x", buf[i++]);
@


1.24
log
@Extend the FIFO ui with the 'D A <level>' (to set all debug levels) and
'D T' (to toggle all logging on and off) commands. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.23 2001/10/02 18:04:35 deraadt Exp $	*/
d165 3
a167 3
	sprintf (nbuf, "%02d%02d%02d.%06ld %s %02d ", tm->tm_hour, 
		 tm->tm_min, tm->tm_sec, now.tv_usec, _log_get_class (class), 
		 level);
d169 5
a173 5
	sprintf (nbuf, "%02d%02d%02d.%06ld %s ", tm->tm_hour, 
		 tm->tm_min, tm->tm_sec, now.tv_usec,
		 class == LOG_PRINT ? "Default" : "Report>");	
      strcat (nbuf, buffer);
      strcat (nbuf, "\n");
@


1.23
log
@change timeval to bpf_timeval; 32 bit in size, permitting much greater portability
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.22 2001/08/18 20:50:02 deraadt Exp $	*/
d293 19
@


1.22
log
@careful with snprintf() == -1; ho, provos
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.21 2001/07/10 10:47:37 ho Exp $	*/
d470 1
d544 3
a546 1
  gettimeofday (&hdr.pcap.ts, 0);
@


1.21
log
@(c)-2001
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.20 2001/07/10 10:46:29 ho Exp $	*/
d157 1
a157 1
  if (len < LOG_SIZE - 1 && error)
@


1.20
log
@Rewrite packet capture to handle IPv6 addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.19 2001/07/10 07:55:05 markus Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999, 2000 Håkan Olsson.  All rights reserved.
@


1.19
log
@htonl() for null.null_family, ok niels@@, ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.18 2001/04/15 16:09:16 ho Exp $	*/
d48 1
d87 5
a91 5
  struct {
    u_int32_t null_family;		/* NULL encapsulation */
  } null;
  struct ip ip;				/* IP header (w/o options) */
  struct udphdr udp;			/* UDP header */
d102 1
a102 2
static u_int8_t pack[SNAPLEN + sizeof (struct packhdr)];
static struct packhdr *hdr;
d104 2
a105 2
static int udp_cksum (const struct ip *, const struct udphdr *, int);
static u_int16_t in_cksum (const struct ip *, int);
d367 10
a410 9
  
  /* prep dummy header prepended to each packet */
  hdr = (struct packhdr *)pack;
  hdr->null.null_family = htonl(AF_INET);
  hdr->ip.ip_v = 0x4;
  hdr->ip.ip_hl = 0x5;
  hdr->ip.ip_p = IPPROTO_UDP;
  hdr->udp.uh_sport = htons (500);
  hdr->udp.uh_dport = htons (500);
d467 6
a472 5
  int off, len, i;
  
  len = 0;
  for (i = 0; i < iovcnt; i++)
    len += iov[i].iov_len;
d474 1
a474 1
  if (!packet_log || len > SNAPLEN)
d478 1
a478 2
  off = sizeof *hdr;
  for (i = 0; i < iovcnt; i++) 
d480 1
a480 1
      memcpy (pack + off, iov[i].iov_base, iov[i].iov_len);
d483 3
d488 1
a488 1
  isakmphdr = (struct isakmp_hdr *)(pack + sizeof *hdr);
d492 3
a494 2
  len += sizeof hdr->udp;
  hdr->udp.uh_ulen = htons (len);
d497 1
a497 3
  len += sizeof hdr->ip;
  hdr->ip.ip_len = htons (len);

d500 8
d509 15
a523 2
      hdr->ip.ip_src.s_addr = ((struct sockaddr_in *)src)->sin_addr.s_addr;
      hdr->ip.ip_dst.s_addr = ((struct sockaddr_in *)dst)->sin_addr.s_addr;
d525 1
d527 10
a536 9
      /* XXX TBD */
    default:
      hdr->ip.ip_src.s_addr = 0x02020202;
      hdr->ip.ip_dst.s_addr = 0x01010101;
    }

  /* Let's use the IP ID as a "packet counter".  */
  i = ntohs (hdr->ip.ip_id) + 1;
  hdr->ip.ip_id = htons (i);
d539 2
a540 6
  hdr->udp.uh_sum = 0; 
  hdr->udp.uh_sum = udp_cksum (&hdr->ip, &hdr->udp, len);

  /* Calculate IP header checksum. */
  hdr->ip.ip_sum = 0;
  hdr->ip.ip_sum = in_cksum (&hdr->ip, hdr->ip.ip_hl << 2);
a541 3
  /* null header */
  len += sizeof hdr->null;
  
d543 11
a553 6
  gettimeofday (&hdr->pcap.ts, 0);
  hdr->pcap.caplen = len;
  hdr->pcap.len = len;
  len += sizeof hdr->pcap;
  
  fwrite (pack, len, 1, packet_log);
d558 1
a558 1
/* Copied from tcpdump/print-udp.c  */
d560 1
a560 1
udp_cksum (const struct ip *ip, const struct udphdr *up, int len)
d562 4
a565 1
  int i, tlen;
d567 5
a571 5
    struct phdr {
      u_int32_t src;
      u_int32_t dst;
      u_char mbz;
      u_char proto;
d573 10
a582 2
    } ph;
    u_int16_t pa[6];
d586 38
a623 13
  tlen = ntohs (ip->ip_len) - ((const char *)up-(const char*)ip);
  
  /* pseudo-header.. */
  phu.ph.len = htons (tlen);
  phu.ph.mbz = 0;
  phu.ph.proto = ip->ip_p;
  memcpy (&phu.ph.src, &ip->ip_src.s_addr, sizeof (u_int32_t));
  memcpy (&phu.ph.dst, &ip->ip_dst.s_addr, sizeof (u_int32_t));
  
  sp = &phu.pa[0];
  sum = sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];
  
  sp = (const u_int16_t *)up;
d625 1
d629 1
a629 1
  if (tlen & 1) {
a630 1
  }
d641 1
a641 1
in_cksum (const struct ip *ip, int len)
d643 2
a644 4
  int nleft = len;
  const u_short *w = (const u_short *)ip;
  u_short answer;
  int sum = 0;
a657 1

@


1.18
log
@Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.17 2001/04/09 21:21:57 ho Exp $	*/
d404 1
a404 1
  hdr->null.null_family = AF_INET;
@


1.17
log
@isakmpd can now capture un-encrypted IKE negotiation packets to a
file. In pcap(3) format, so tcpdump(8) can read it.
Idea by Tim Newsham <newsham@@lava.net>, work by him and me.
Ok angelos@@, niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.16 2001/01/27 12:03:33 niklas Exp $	*/
d593 1
a593 1
    sum += htons (*(u_char *)w<<8);
@


1.16
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.15 2001/01/26 12:12:52 niklas Exp $	*/
d38 1
d40 19
d61 1
d64 1
d71 1
d77 1
d80 27
a106 1
#endif
d359 244
@


1.15
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.14 2000/12/12 05:12:45 todd Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.14
log
@pids are useful in syslog; ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.13 2000/10/07 06:58:29 niklas Exp $	*/
d136 3
a138 3
	  if (fileno (log_output) != -1)
	    if (fileno (stdout) == fileno (log_output))
	      fclose (stdout);
d144 3
a146 2
	  /* (Re)send current message to syslog(). */
	  syslog (class == LOG_REPORT ? LOG_ALERT : syslog_level, "%s", buffer);
@


1.13
log
@Merge with EOM 1.30

author: niklas
no need for sysdep.h in here.  This promotes reuse of the log
module in other environments

author: ho
(c)-2000
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.12 2000/08/03 07:28:56 niklas Exp $	*/
d71 1
a71 1
    openlog ("isakmpd", LOG_CONS, LOG_DAEMON);
@


1.13.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.18 2001/04/15 16:09:16 ho Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
a37 1
#include <sys/types.h>
a38 19

#ifdef USE_DEBUG
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <arpa/inet.h>

#ifdef HAVE_PCAP
#include <pcap.h>
#else
#include "sysdep/common/pcap.h"
#endif

#endif /* USE_DEBUG */

a40 1
#include <stdlib.h>
a42 1

a48 1
#include "isakmp_num.h"
a53 1

d56 1
a56 27

#define TCPDUMP_MAGIC	0xa1b2c3d4
#define SNAPLEN		(64 * 1024)

struct packhdr {
  struct pcap_pkthdr pcap;		/* pcap file packet header */
  struct {
    u_int32_t null_family;		/* NULL encapsulation */
  } null;
  struct ip ip;				/* IP header (w/o options) */
  struct udphdr udp;			/* UDP header */
};

struct isakmp_hdr {
  u_int8_t icookie[8], rcookie[8];
  u_int8_t next, ver, type, flags;
  u_int32_t msgid, len;
};

static char *pcaplog_file = NULL;
static FILE *packet_log;
static u_int8_t pack[SNAPLEN + sizeof (struct packhdr)];
static struct packhdr *hdr;

static int udp_cksum (const struct ip *, const struct udphdr *, int);
static u_int16_t in_cksum (const struct ip *, int);
#endif /* USE_DEBUG */
d71 1
a71 1
    openlog ("isakmpd", LOG_PID | LOG_CONS, LOG_DAEMON);
d136 3
a138 3
	  if (fileno (log_output) != -1
	      && fileno (stdout) == fileno (log_output))
	    fclose (stdout);
d144 2
a145 3
	  /* (Re)send current message to syslog().  */
	  syslog (class == LOG_REPORT ? LOG_ALERT
		  : syslog_level, "%s", buffer);
a307 244

#ifdef USE_DEBUG
void
log_packet_init (char *newname)
{
  struct pcap_file_header sf_hdr;
  mode_t old_umask;

  if (pcaplog_file && strcmp (pcaplog_file, PCAP_FILE_DEFAULT) != 0)
    free (pcaplog_file);

  pcaplog_file = strdup (newname);
  if (!pcaplog_file)
    {
      log_error ("log_packet_init: strdup (\"%s\") failed", newname);
      return;
    }

  old_umask = umask (S_IRWXG | S_IRWXO);
  packet_log = fopen (pcaplog_file, "w");
  umask (old_umask);

  if (!packet_log)
    {
      log_error ("log_packet_init: fopen (\"%s\", \"w\") failed", 
		 pcaplog_file);
      return;
    }

  log_print ("log_packet_init: starting IKE packet capture to file \"%s\"", 
	     pcaplog_file);

  sf_hdr.magic = TCPDUMP_MAGIC;
  sf_hdr.version_major = PCAP_VERSION_MAJOR;
  sf_hdr.version_minor = PCAP_VERSION_MINOR;
  sf_hdr.thiszone = 0;
  sf_hdr.snaplen = SNAPLEN;
  sf_hdr.sigfigs = 0;
  sf_hdr.linktype = DLT_NULL;

  fwrite ((char *)&sf_hdr, sizeof sf_hdr, 1, packet_log);
  fflush (packet_log);
  
  /* prep dummy header prepended to each packet */
  hdr = (struct packhdr *)pack;
  hdr->null.null_family = AF_INET;
  hdr->ip.ip_v = 0x4;
  hdr->ip.ip_hl = 0x5;
  hdr->ip.ip_p = IPPROTO_UDP;
  hdr->udp.uh_sport = htons (500);
  hdr->udp.uh_dport = htons (500);
}

void
log_packet_restart (char *newname)
{
  struct stat st;

  if (packet_log)
    {
      log_print ("log_packet_restart: capture already active on file \"%s\"",
		 pcaplog_file);
      return;
    }

  if (newname)
    {
      if (stat (newname, &st) == 0)
	log_print ("log_packet_restart: won't overwrite existing \"%s\"", 
		   newname);
      else
	log_packet_init (newname);
    }
  else if (!pcaplog_file)
    log_packet_init (PCAP_FILE_DEFAULT);
  else if (stat (pcaplog_file, &st) != 0)
    log_packet_init (pcaplog_file);
  else
    {
      /* Re-activate capture on current file.  */
      packet_log = fopen (pcaplog_file, "a");
      if (!packet_log)
	log_error ("log_packet_restart: fopen (\"%s\", \"a\") failed", 
		   pcaplog_file);
      else
	log_print ("log_packet_restart: capture restarted on file \"%s\"",
		   pcaplog_file);
    }
}

void
log_packet_stop (void)
{
  /* Stop capture.  */
  if (packet_log)
    {
      fclose (packet_log);
      log_print ("log_packet_stop: stopped capture");
    }
  packet_log = 0;
}

void
log_packet_iov (struct sockaddr *src, struct sockaddr *dst, struct iovec *iov,
		int iovcnt)
{
  struct isakmp_hdr *isakmphdr;
  int off, len, i;
  
  len = 0;
  for (i = 0; i < iovcnt; i++)
    len += iov[i].iov_len;
  
  if (!packet_log || len > SNAPLEN)
    return;
  
  /* copy packet into buffer */
  off = sizeof *hdr;
  for (i = 0; i < iovcnt; i++) 
    {
      memcpy (pack + off, iov[i].iov_base, iov[i].iov_len);
      off += iov[i].iov_len;
    }
  
  /* isakmp - turn off the encryption bit in the isakmp hdr */
  isakmphdr = (struct isakmp_hdr *)(pack + sizeof *hdr);
  isakmphdr->flags &= ~(ISAKMP_FLAGS_ENC);
  
  /* udp */
  len += sizeof hdr->udp;
  hdr->udp.uh_ulen = htons (len);
  
  /* ip */
  len += sizeof hdr->ip;
  hdr->ip.ip_len = htons (len);

  switch (src->sa_family)
    {
    case AF_INET:
      hdr->ip.ip_src.s_addr = ((struct sockaddr_in *)src)->sin_addr.s_addr;
      hdr->ip.ip_dst.s_addr = ((struct sockaddr_in *)dst)->sin_addr.s_addr;
      break;
    case AF_INET6:
      /* XXX TBD */
    default:
      hdr->ip.ip_src.s_addr = 0x02020202;
      hdr->ip.ip_dst.s_addr = 0x01010101;
    }

  /* Let's use the IP ID as a "packet counter".  */
  i = ntohs (hdr->ip.ip_id) + 1;
  hdr->ip.ip_id = htons (i);

  /* Calculate UDP checksum.  */
  hdr->udp.uh_sum = 0; 
  hdr->udp.uh_sum = udp_cksum (&hdr->ip, &hdr->udp, len);

  /* Calculate IP header checksum. */
  hdr->ip.ip_sum = 0;
  hdr->ip.ip_sum = in_cksum (&hdr->ip, hdr->ip.ip_hl << 2);

  /* null header */
  len += sizeof hdr->null;
  
  /* pcap file packet header */
  gettimeofday (&hdr->pcap.ts, 0);
  hdr->pcap.caplen = len;
  hdr->pcap.len = len;
  len += sizeof hdr->pcap;
  
  fwrite (pack, len, 1, packet_log);
  fflush (packet_log);
  return;
}

/* Copied from tcpdump/print-udp.c  */
static int
udp_cksum (const struct ip *ip, const struct udphdr *up, int len)
{
  int i, tlen;
  union phu {
    struct phdr {
      u_int32_t src;
      u_int32_t dst;
      u_char mbz;
      u_char proto;
      u_int16_t len;
    } ph;
    u_int16_t pa[6];
  } phu;
  const u_int16_t *sp;
  u_int32_t sum;
  tlen = ntohs (ip->ip_len) - ((const char *)up-(const char*)ip);
  
  /* pseudo-header.. */
  phu.ph.len = htons (tlen);
  phu.ph.mbz = 0;
  phu.ph.proto = ip->ip_p;
  memcpy (&phu.ph.src, &ip->ip_src.s_addr, sizeof (u_int32_t));
  memcpy (&phu.ph.dst, &ip->ip_dst.s_addr, sizeof (u_int32_t));
  
  sp = &phu.pa[0];
  sum = sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];
  
  sp = (const u_int16_t *)up;
  
  for (i = 0; i < (tlen&~1); i += 2)
    sum += *sp++;
  
  if (tlen & 1) {
    sum += htons ((*(const char *)sp) << 8);
  }
  
  while (sum > 0xffff)
    sum = (sum & 0xffff) + (sum >> 16);
  sum = ~sum & 0xffff;
  
  return sum;
}

/* Copied from tcpdump/print-ip.c, modified.  */
static u_int16_t
in_cksum (const struct ip *ip, int len)
{
  int nleft = len;
  const u_short *w = (const u_short *)ip;
  u_short answer;
  int sum = 0;
  
  while (nleft > 1)  {
    sum += *w++;
    nleft -= 2;
  }
  if (nleft == 1)
    sum += htons (*(u_char *)w << 8);
  
  sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
  sum += (sum >> 16);                     /* add carry */
  answer = ~sum;                          /* truncate to 16 bits */
  return answer;
}


#endif /* USE_DEBUG */
@


1.12
log
@Merge with EOM 1.28

author: niklas
From OpenBSD: be paranoid about the syslog format parameter
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.11 2000/06/29 00:01:14 deraadt Exp $	*/
/*	$EOM: log.c,v 1.28 2000/08/03 07:21:15 niklas Exp $	*/
d6 1
a47 2

#include "sysdep.h"
@


1.11
log
@use %s when calling syslog
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.10 2000/04/07 22:05:38 niklas Exp $	*/
/*	$EOM: log.c,v 1.27 2000/03/30 14:27:03 ho Exp $	*/
@


1.10
log
@Merge with EOM 1.27

author: ho
Add log_init() to properly initialize log_output variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2000/02/25 17:23:40 niklas Exp $	*/
d146 1
a146 1
	  syslog (class == LOG_REPORT ? LOG_ALERT : syslog_level, buffer);
d150 1
a150 1
    syslog (class == LOG_REPORT ? LOG_ALERT : syslog_level, buffer);
@


1.10.2.1
log
@Pull in patch from current:
Fix (deraadt):
use %s when calling syslog
Merge with EOM 1.28

author: niklas
From OpenBSD: be paranoid about the syslog format parameter
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.10 2000/04/07 22:05:38 niklas Exp $	*/
d146 1
a146 1
	  syslog (class == LOG_REPORT ? LOG_ALERT : syslog_level, "%s", buffer);
d150 1
a150 1
    syslog (class == LOG_REPORT ? LOG_ALERT : syslog_level, "%s", buffer);
@


1.9
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.8 1999/08/26 22:31:36 niklas Exp $	*/
/*	$EOM: log.c,v 1.26 2000/02/20 19:58:39 niklas Exp $	*/
d54 1
a54 1
static FILE *log_output = stderr;
d58 6
@


1.8
log
@Merge with EOM 1.25

author: niklas
Ouch ho, that was ugly, make code portable
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.7 1999/07/07 22:11:14 niklas Exp $	*/
/*	$EOM: log.c,v 1.25 1999/08/12 23:08:55 niklas Exp $	*/
d55 1
d57 1
d147 1
d214 27
a301 26
}

void
log_debug_cmd (int cls, int level)
{
  if (cls < 0 || cls >= LOG_ENDCLASS)
    {
      log_print ("log_debug_cmd: invalid debugging class %d", cls);
      return;
    }

  if (level < 0)
    {
      log_print ("log_debug_cmd: invalid debugging level %d for class %d",
		 level, cls);
      return;
    }

  if (level == log_level[cls])
    log_print ("log_debug_cmd: log level unchanged for class %d", cls);
  else
    {
      log_print ("log_debug_cmd: log level changed from %d to %d for class %d",
		 log_level[cls], level, cls);
      log_level[cls] = level;
    }
@


1.7
log
@Merge with EOM 1.24

author: ho
Release lock(s) on logfile when write fails.
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.6 1999/04/19 19:53:41 niklas Exp $	*/
/*	$EOM: log.c,v 1.24 1999/06/26 23:26:56 ho Exp $	*/
d129 2
a130 2
	  if (log_output->_file != -1)
	    if (stdout->_file == log_output->_file)
@


1.6
log
@./log.c: Merge with EOM 1.23

Style

Make an attempt to handle failures in logging; disk full, etc.
We fallback to syslog(), which in turn has a fallback to /dev/console.

Move LOG_SIZE to log.h

Add LOG_REPORT to always go to logchannel regardless of level; misc small fixes

I did not need to do this but... style nits

Add class and level to debug messages

log time on -d mode

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.5 1999/02/26 03:45:48 niklas Exp $	*/
/*	$EOM: log.c,v 1.23 1999/04/18 15:17:24 niklas Exp $	*/
d123 10
@


1.5
log
@Merge from the Ericsson repository
| revision 1.15
| date: 1999/02/25 11:39:10;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.4 1998/12/21 01:02:26 niklas Exp $	*/
/*	$EOM: log.c,v 1.15 1999/02/25 11:39:10 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d37 1
d52 1
a52 7
/*
 * We cannot do the log strings dynamically sizeable as out of memory is one
 * of the situations we need to report about.
 */
#define LOG_SIZE	200

static void _log_print (int, int, const char *, va_list);
d64 1
a64 1
    openlog ("isakmpd", 0, LOG_DAEMON);
d73 14
d88 2
a89 1
_log_print (int error, int level, const char *fmt, va_list ap)
d91 3
a93 1
  char buffer[LOG_SIZE];
d95 3
d104 26
a129 2
      fputs (buffer, log_output);
      fputc ('\n', log_output);
d132 1
a132 1
    syslog (level, buffer);
d139 1
a139 1
log_debug (cls, level, clfmt, va_alist)
d151 1
a151 1
  if (log_level[cls] == 0 || level > log_level[cls])
d159 1
a159 1
  _log_print (0, LOG_DEBUG, fmt, ap);
d173 1
a173 1
  if (log_level[cls] == 0 || level > log_level[cls])
d217 1
a217 1
  _log_print (0, LOG_NOTICE, fmt, ap);
d238 1
a238 1
  _log_print (1, LOG_ERR, fmt, ap);
d259 1
a259 1
  _log_print (1, LOG_CRIT, fmt, ap);
@


1.4
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.3 1998/11/17 11:10:16 niklas Exp $	*/
/*	$EOM: log.c,v 1.14 1998/12/01 10:19:44 niklas Exp $	*/
d46 2
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: log.c,v 1.2 1998/11/15 00:43:59 niklas Exp $	*/
/*	$EOM: log.c,v 1.13 1998/07/26 00:48:55 niklas Exp $	*/
d68 6
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: log.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: log.c,v 1.13 1998/07/26 00:48:55 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
