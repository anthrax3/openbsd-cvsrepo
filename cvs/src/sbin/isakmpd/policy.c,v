head	1.97;
access;
symbols
	OPENBSD_6_2_BASE:1.97
	OPENBSD_6_1:1.97.0.16
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.97.0.12
	OPENBSD_6_0_BASE:1.97
	OPENBSD_5_9:1.97.0.8
	OPENBSD_5_9_BASE:1.97
	OPENBSD_5_8:1.97.0.10
	OPENBSD_5_8_BASE:1.97
	OPENBSD_5_7:1.97.0.2
	OPENBSD_5_7_BASE:1.97
	OPENBSD_5_6:1.97.0.6
	OPENBSD_5_6_BASE:1.97
	OPENBSD_5_5:1.97.0.4
	OPENBSD_5_5_BASE:1.97
	OPENBSD_5_4:1.96.0.2
	OPENBSD_5_4_BASE:1.96
	OPENBSD_5_3:1.94.0.4
	OPENBSD_5_3_BASE:1.94
	OPENBSD_5_2:1.94.0.2
	OPENBSD_5_2_BASE:1.94
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.4
	OPENBSD_5_0:1.93.0.2
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.92.0.2
	OPENBSD_4_9_BASE:1.92
	OPENBSD_4_8:1.91.0.14
	OPENBSD_4_8_BASE:1.91
	OPENBSD_4_7:1.91.0.10
	OPENBSD_4_7_BASE:1.91
	OPENBSD_4_6:1.91.0.12
	OPENBSD_4_6_BASE:1.91
	OPENBSD_4_5:1.91.0.8
	OPENBSD_4_5_BASE:1.91
	OPENBSD_4_4:1.91.0.6
	OPENBSD_4_4_BASE:1.91
	OPENBSD_4_3:1.91.0.4
	OPENBSD_4_3_BASE:1.91
	OPENBSD_4_2:1.91.0.2
	OPENBSD_4_2_BASE:1.91
	OPENBSD_4_1:1.89.0.2
	OPENBSD_4_1_BASE:1.89
	OPENBSD_4_0:1.88.0.2
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.87.0.2
	OPENBSD_3_9_BASE:1.87
	OPENBSD_3_8:1.86.0.2
	OPENBSD_3_8_BASE:1.86
	OPENBSD_3_7:1.80.0.2
	OPENBSD_3_7_BASE:1.80
	OPENBSD_3_6:1.78.0.2
	OPENBSD_3_6_BASE:1.78
	OPENBSD_3_5:1.68.0.2
	OPENBSD_3_5_BASE:1.68
	OPENBSD_3_4:1.66.0.2
	OPENBSD_3_4_BASE:1.66
	OPENBSD_3_3:1.57.0.2
	OPENBSD_3_3_BASE:1.57
	OPENBSD_3_2:1.56.0.2
	OPENBSD_3_2_BASE:1.56
	OPENBSD_3_1:1.50.0.2
	OPENBSD_3_1_BASE:1.50
	OPENBSD_3_0:1.46.0.2
	OPENBSD_3_0_BASE:1.46
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.97
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2013.04.16.19.26.00;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.93;

1.93
date	2011.04.06.11.36.25;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.22.13.45.16;	author mikeb;	state Exp;
branches;
next	1.91;

1.91
date	2007.08.05.09.43.09;	author tom;	state Exp;
branches;
next	1.90;

1.90
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.89;

1.89
date	2007.03.03.18.47.37;	author cloder;	state Exp;
branches;
next	1.88;

1.88
date	2006.06.17.10.06.21;	author hshoexer;	state Exp;
branches;
next	1.87;

1.87
date	2005.11.14.23.25.11;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2005.06.14.10.50.47;	author hshoexer;	state Exp;
branches;
next	1.85;

1.85
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.84;

1.84
date	2005.04.08.18.39.04;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2005.04.08.16.37.15;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2005.03.03.15.06.55;	author hshoexer;	state Exp;
branches;
next	1.79;

1.79
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.78;

1.78
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2004.06.25.20.25.34;	author hshoexer;	state Exp;
branches;
next	1.76;

1.76
date	2004.06.24.15.58.58;	author hshoexer;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2004.06.14.09.55.42;	author ho;	state Exp;
branches;
next	1.73;

1.73
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.23.16.14.22;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.28.20.20.31;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.67;

1.67
date	2003.11.06.16.12.08;	author ho;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.25.08.31.16;	author markus;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.04.07.31.17;	author ho;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.18.19.37.47;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.14.18.10.30;	author ho;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.14.17.37.22;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.12.21.43.22;	author ho;	state Exp;
branches;
next	1.57;

1.57
date	2002.11.14.16.38.05;	author ho;	state Exp;
branches;
next	1.56;

1.56
date	2002.09.11.09.50.44;	author ho;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.15.19.27.06;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.10.18.08.58;	author ho;	state Exp;
branches;
next	1.53;

1.53
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.01.07.44.22;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2002.05.28.11.23.20;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.23.22.14.28;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.23.18.09.04;	author ho;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.23.17.25.38;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.03.09.24.02;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.26.01.48.12;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.25.22.22.11;	author niklas;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.24.11.19.01;	author ho;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.11.05.26.59;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.05.07.29.59;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.04.22.16.32;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.03.23.39.01;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.03.11.00.52;	author ho;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.03.08.07.22;	author ho;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.01.19.48.44;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.01.18.57.33;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.01.05.42.05;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.29.18.52.17;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.29.04.12.01;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.07.04.46.45;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.07.04.23.35;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.07.03.15.15;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.31.20.21.08;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.09.12.34.38;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.05.23.18.53;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.14.21.13.24;	author tholo;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.14.12.15.45;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.13.14.05.19;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.07.07.36.34;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.07.07.33.53;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.27.12.03.34;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.10.00.42.00;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.23.12.56.15;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.16.23.28.43;	author niklas;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.10.09.23.27.31;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.07.06.59.56;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.03.07.25.11;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.08.20.51.42;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.02.14.35.27;	author niklas;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.04.07.22.50.02;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.07.22.04.02;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.25.17.23.41;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.19.19.32.04;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.11.10.21.05;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.01.02.46.18;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.27.18.07.28;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.26.15.24.03;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.10.26.22.32.28;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.08.26.22.31.09;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.07.07.22.10.28;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2000.06.10.17.22.57;	author jason;	state Exp;
branches;
next	;

1.17.2.1
date	2001.05.08.12.45.25;	author ho;	state Exp;
branches;
next	;


desc
@@


1.97
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@/* $OpenBSD: policy.c,v 1.96 2013/04/16 19:26:00 deraadt Exp $	 */
/* $EOM: policy.c,v 1.49 2000/10/24 13:33:39 niklas Exp $ */

/*
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <regex.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <keynote.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <openssl/ssl.h>
#include <netdb.h>

#include "conf.h"
#include "exchange.h"
#include "ipsec.h"
#include "isakmp_doi.h"
#include "sa.h"
#include "transport.h"
#include "log.h"
#include "message.h"
#include "monitor.h"
#include "util.h"
#include "policy.h"
#include "x509.h"

char          **policy_asserts = NULL;
int		ignore_policy = 0;
int             policy_asserts_num = 0;
struct exchange *policy_exchange = 0;
struct sa      *policy_sa = 0;
struct sa      *policy_isakmp_sa = 0;

static const char hextab[] = {
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};

/*
 * Adaptation of Vixie's inet_ntop4 ()
 */
static const char *
my_inet_ntop4(const in_addr_t *src, char *dst, size_t size, int normalize)
{
	static const char fmt[] = "%03u.%03u.%03u.%03u";
	char            tmp[sizeof "255.255.255.255"];
	in_addr_t       src2;
	int		len;

	if (normalize)
		src2 = ntohl(*src);
	else
		src2 = *src;

	len = snprintf(tmp, sizeof tmp, fmt, ((u_int8_t *)&src2)[0],
	    ((u_int8_t *)&src2)[1], ((u_int8_t *)&src2)[2],
	    ((u_int8_t *)&src2)[3]);
	if (len == -1 || len > (int)size) {
		errno = ENOSPC;
		return 0;
	}
	strlcpy(dst, tmp, size);
	return dst;
}

static const char *
my_inet_ntop6(const unsigned char *src, char *dst, size_t size)
{
	static const char fmt[] =
	    "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x";
	char	tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];
	int	len;

	len = snprintf(tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3],
	    src[4], src[5], src[6], src[7], src[8], src[9], src[10], src[11],
	    src[12], src[13], src[14], src[15]);
	if (len == -1 || len > (int)size) {
		errno = ENOSPC;
		return 0;
	}
	strlcpy(dst, tmp, size);
	return dst;
}

char *
policy_callback(char *name)
{
	struct proto   *proto;

	u_int8_t       *attr, *value, *id, *idlocal, *idremote;
	size_t          id_sz, idlocalsz, idremotesz;
	struct sockaddr *sin;
	struct ipsec_exch *ie;
	struct ipsec_sa *is;
	size_t          i;
	int             fmt, lifetype = 0;
	in_addr_t       net, subnet;
	u_int16_t       len, type;
	time_t          tt;
	char           *addr;
	static char     mytimeofday[15];

	/* We use all these as a cache.  */
#define PMAX 32
	static char    *esp_present, *ah_present, *comp_present;
	static char    *ah_hash_alg, *ah_auth_alg, *esp_auth_alg, *esp_enc_alg;
	static char    *comp_alg, ah_life_kbytes[PMAX], ah_life_seconds[PMAX];
	static char     esp_life_kbytes[PMAX], esp_life_seconds[PMAX];
	static char     comp_life_kbytes[PMAX];
	static char    *ah_ecn, *esp_ecn, *comp_ecn;
	static char     comp_life_seconds[PMAX], *ah_encapsulation;
	static char    *esp_encapsulation, *comp_encapsulation;
	static char     ah_key_length[PMAX], esp_key_length[PMAX];
	static char     ah_key_rounds[PMAX], esp_key_rounds[PMAX];
	static char	comp_dict_size[PMAX], comp_private_alg[PMAX];
	static char    *remote_filter_type, *local_filter_type;
	static char     remote_filter_addr_upper[NI_MAXHOST];
	static char     remote_filter_addr_lower[NI_MAXHOST];
	static char     local_filter_addr_upper[NI_MAXHOST];
	static char     local_filter_addr_lower[NI_MAXHOST];
	static char     ah_group_desc[PMAX], esp_group_desc[PMAX];
	static char	comp_group_desc[PMAX], remote_ike_address[NI_MAXHOST];
	static char     local_ike_address[NI_MAXHOST];
	static char    *remote_id_type, remote_id_addr_upper[NI_MAXHOST];
	static char    *phase_1, remote_id_addr_lower[NI_MAXHOST];
	static char    *remote_id_proto, remote_id_port[PMAX];
	static char     remote_filter_port[PMAX], local_filter_port[PMAX];
	static char    *remote_filter_proto, *local_filter_proto, *pfs;
	static char    *initiator, remote_filter_proto_num[3];
	static char	local_filter_proto_num[3], remote_id_proto_num[3];
	static char     phase1_group[PMAX];

	/* Allocated.  */
	static char    *remote_filter = 0, *local_filter = 0, *remote_id = 0;

	static int      dirty = 1;

	/* We only need to set dirty at initialization time really.  */
	if (strcmp(name, KEYNOTE_CALLBACK_CLEANUP) == 0 ||
	    strcmp(name, KEYNOTE_CALLBACK_INITIALIZE) == 0) {
		esp_present = ah_present = comp_present = pfs = "no";
		ah_hash_alg = ah_auth_alg = phase_1 = "";
		esp_auth_alg = esp_enc_alg = comp_alg = ah_encapsulation = "";
		ah_ecn = esp_ecn = comp_ecn = "no";
		esp_encapsulation = comp_encapsulation = "";
		remote_filter_type = "";
		local_filter_type = remote_id_type = initiator = "";
		remote_filter_proto = local_filter_proto = "";
		remote_id_proto = "";

		free(remote_filter);
		remote_filter = 0;
		free(local_filter);
		local_filter = 0;
		free(remote_id);
		remote_id = 0;

		bzero(remote_ike_address, sizeof remote_ike_address);
		bzero(local_ike_address, sizeof local_ike_address);
		bzero(ah_life_kbytes, sizeof ah_life_kbytes);
		bzero(ah_life_seconds, sizeof ah_life_seconds);
		bzero(esp_life_kbytes, sizeof esp_life_kbytes);
		bzero(esp_life_seconds, sizeof esp_life_seconds);
		bzero(comp_life_kbytes, sizeof comp_life_kbytes);
		bzero(comp_life_seconds, sizeof comp_life_seconds);
		bzero(ah_key_length, sizeof ah_key_length);
		bzero(ah_key_rounds, sizeof ah_key_rounds);
		bzero(esp_key_length, sizeof esp_key_length);
		bzero(esp_key_rounds, sizeof esp_key_rounds);
		bzero(comp_dict_size, sizeof comp_dict_size);
		bzero(comp_private_alg, sizeof comp_private_alg);
		bzero(remote_filter_addr_upper,
		    sizeof remote_filter_addr_upper);
		bzero(remote_filter_addr_lower,
		    sizeof remote_filter_addr_lower);
		bzero(local_filter_addr_upper,
		    sizeof local_filter_addr_upper);
		bzero(local_filter_addr_lower,
		    sizeof local_filter_addr_lower);
		bzero(remote_id_addr_upper, sizeof remote_id_addr_upper);
		bzero(remote_id_addr_lower, sizeof remote_id_addr_lower);
		bzero(ah_group_desc, sizeof ah_group_desc);
		bzero(esp_group_desc, sizeof esp_group_desc);
		bzero(remote_id_port, sizeof remote_id_port);
		bzero(remote_filter_port, sizeof remote_filter_port);
		bzero(local_filter_port, sizeof local_filter_port);
		bzero(phase1_group, sizeof phase1_group);

		dirty = 1;
		return "";
	}
	/*
	 * If dirty is set, this is the first request for an attribute, so
	 * populate our value cache.
         */
	if (dirty) {
		ie = policy_exchange->data;

		if (ie->pfs)
			pfs = "yes";

		is = policy_isakmp_sa->data;
		snprintf(phase1_group, sizeof phase1_group, "%u",
		    is->group_desc);

		for (proto = TAILQ_FIRST(&policy_sa->protos); proto;
		    proto = TAILQ_NEXT(proto, link)) {
			switch (proto->proto) {
			case IPSEC_PROTO_IPSEC_AH:
				ah_present = "yes";
				switch (proto->id) {
				case IPSEC_AH_MD5:
					ah_hash_alg = "md5";
					break;

				case IPSEC_AH_SHA:
					ah_hash_alg = "sha";
					break;

				case IPSEC_AH_RIPEMD:
					ah_hash_alg = "ripemd";
					break;

				case IPSEC_AH_SHA2_256:
					ah_auth_alg = "sha2-256";
					break;

				case IPSEC_AH_SHA2_384:
					ah_auth_alg = "sha2-384";
					break;

				case IPSEC_AH_SHA2_512:
					ah_auth_alg = "sha2-512";
					break;

				case IPSEC_AH_DES:
					ah_hash_alg = "des";
					break;
				}

				break;

			case IPSEC_PROTO_IPSEC_ESP:
				esp_present = "yes";
				switch (proto->id) {
				case IPSEC_ESP_DES_IV64:
					esp_enc_alg = "des-iv64";
					break;

				case IPSEC_ESP_DES:
					esp_enc_alg = "des";
					break;

				case IPSEC_ESP_3DES:
					esp_enc_alg = "3des";
					break;

				case IPSEC_ESP_AES:
				case IPSEC_ESP_AES_CTR:
				case IPSEC_ESP_AES_GCM_16:
				case IPSEC_ESP_AES_GMAC:
					esp_enc_alg = "aes";
					break;

				case IPSEC_ESP_RC5:
					esp_enc_alg = "rc5";
					break;

				case IPSEC_ESP_IDEA:
					esp_enc_alg = "idea";
					break;

				case IPSEC_ESP_CAST:
					esp_enc_alg = "cast";
					break;

				case IPSEC_ESP_BLOWFISH:
					esp_enc_alg = "blowfish";
					break;

				case IPSEC_ESP_3IDEA:
					esp_enc_alg = "3idea";
					break;

				case IPSEC_ESP_DES_IV32:
					esp_enc_alg = "des-iv32";
					break;

				case IPSEC_ESP_RC4:
					esp_enc_alg = "rc4";
					break;

				case IPSEC_ESP_NULL:
					esp_enc_alg = "null";
					break;
				}

				break;

			case IPSEC_PROTO_IPCOMP:
				comp_present = "yes";
				switch (proto->id) {
				case IPSEC_IPCOMP_OUI:
					comp_alg = "oui";
					break;

				case IPSEC_IPCOMP_DEFLATE:
					comp_alg = "deflate";
					break;

				case IPSEC_IPCOMP_LZS:
					comp_alg = "lzs";
					break;

				case IPSEC_IPCOMP_V42BIS:
					comp_alg = "v42bis";
					break;
				}

				break;
			}

			for (attr = proto->chosen->p +
			    ISAKMP_TRANSFORM_SA_ATTRS_OFF;
			    attr < proto->chosen->p +
			    GET_ISAKMP_GEN_LENGTH(proto->chosen->p);
			    attr = value + len) {
				if (attr + ISAKMP_ATTR_VALUE_OFF >
				    (proto->chosen->p +
				    GET_ISAKMP_GEN_LENGTH(proto->chosen->p)))
					return "";

				type = GET_ISAKMP_ATTR_TYPE(attr);
				fmt = ISAKMP_ATTR_FORMAT(type);
				type = ISAKMP_ATTR_TYPE(type);
				value = attr + (fmt ?
				    ISAKMP_ATTR_LENGTH_VALUE_OFF :
				    ISAKMP_ATTR_VALUE_OFF);
				len = (fmt ? ISAKMP_ATTR_LENGTH_VALUE_LEN :
				    GET_ISAKMP_ATTR_LENGTH_VALUE(attr));

				if (value + len > proto->chosen->p +
				    GET_ISAKMP_GEN_LENGTH(proto->chosen->p))
					return "";

				switch (type) {
				case IPSEC_ATTR_SA_LIFE_TYPE:
					lifetype = decode_16(value);
					break;

				case IPSEC_ATTR_SA_LIFE_DURATION:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(ah_life_seconds, sizeof ah_life_seconds,
								    "%u", decode_16(value));
							else
								snprintf(ah_life_seconds, sizeof ah_life_seconds,
								    "%u", decode_32(value));
						} else {
							if (len == 2)
								snprintf(ah_life_kbytes, sizeof ah_life_kbytes,
								    "%u", decode_16(value));
							else
								snprintf(ah_life_kbytes, sizeof ah_life_kbytes,
								    "%u", decode_32(value));
						}

						break;

					case IPSEC_PROTO_IPSEC_ESP:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(esp_life_seconds,
								    sizeof esp_life_seconds, "%u",
								    decode_16(value));
							else
								snprintf(esp_life_seconds,
								    sizeof esp_life_seconds, "%u",
								    decode_32(value));
						} else {
							if (len == 2)
								snprintf(esp_life_kbytes,
								    sizeof esp_life_kbytes, "%u",
								    decode_16(value));
							else
								snprintf(esp_life_kbytes,
								    sizeof esp_life_kbytes, "%u",
								    decode_32(value));
						}

						break;

					case IPSEC_PROTO_IPCOMP:
						if (lifetype == IPSEC_DURATION_SECONDS) {
							if (len == 2)
								snprintf(comp_life_seconds,
								    sizeof comp_life_seconds, "%u",
								    decode_16(value));
							else
								snprintf(comp_life_seconds,
								    sizeof comp_life_seconds, "%u",
								    decode_32(value));
						} else {
							if (len == 2)
								snprintf(comp_life_kbytes,
								    sizeof comp_life_kbytes, "%u",
								    decode_16(value));
							else
								snprintf(comp_life_kbytes,
								    sizeof comp_life_kbytes, "%u",
								    decode_32(value));
						}
						break;
					}
					break;

				case IPSEC_ATTR_GROUP_DESCRIPTION:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_group_desc,
						    sizeof ah_group_desc, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_group_desc,
						    sizeof esp_group_desc, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPCOMP:
						snprintf(comp_group_desc,
						    sizeof comp_group_desc, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_ECN_TUNNEL:
					if (decode_16(value))
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_ecn = "yes";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_ecn = "yes";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_ecn = "yes";
							break;
						}

				case IPSEC_ATTR_ENCAPSULATION_MODE:
					if (decode_16(value) == IPSEC_ENCAP_TUNNEL)
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "tunnel";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "tunnel";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "tunnel";
							break;
						}
					else if (decode_16(value) ==
					    IPSEC_ENCAP_UDP_ENCAP_TUNNEL ||
					    decode_16(value) ==
					    IPSEC_ENCAP_UDP_ENCAP_TUNNEL_DRAFT)
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "udp-encap-tunnel";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "udp-encap-tunnel";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "udp-encap-tunnel";
							break;
						}
					/* XXX IPSEC_ENCAP_UDP_ENCAP_TRANSPORT */
					else
						switch (proto->proto) {
						case IPSEC_PROTO_IPSEC_AH:
							ah_encapsulation = "transport";
							break;

						case IPSEC_PROTO_IPSEC_ESP:
							esp_encapsulation = "transport";
							break;

						case IPSEC_PROTO_IPCOMP:
							comp_encapsulation = "transport";
							break;
						}
					break;

				case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						switch (decode_16(value)) {
						case IPSEC_AUTH_HMAC_MD5:
							ah_auth_alg = "hmac-md5";
							break;

						case IPSEC_AUTH_HMAC_SHA:
							ah_auth_alg = "hmac-sha";
							break;

						case IPSEC_AUTH_HMAC_RIPEMD:
							ah_auth_alg = "hmac-ripemd";
							break;

						case IPSEC_AUTH_HMAC_SHA2_256:
							ah_auth_alg = "hmac-sha2-256";
							break;

						case IPSEC_AUTH_HMAC_SHA2_384:
							ah_auth_alg = "hmac-sha2-384";
							break;

						case IPSEC_AUTH_HMAC_SHA2_512:
							ah_auth_alg = "hmac-sha2-512";
							break;

						case IPSEC_AUTH_DES_MAC:
							ah_auth_alg = "des-mac";
							break;

						case IPSEC_AUTH_KPDK:
							ah_auth_alg = "kpdk";
							break;
						}
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						switch (decode_16(value)) {
						case IPSEC_AUTH_HMAC_MD5:
							esp_auth_alg = "hmac-md5";
							break;

						case IPSEC_AUTH_HMAC_SHA:
							esp_auth_alg = "hmac-sha";
							break;

						case IPSEC_AUTH_HMAC_RIPEMD:
							esp_auth_alg = "hmac-ripemd";
							break;

						case IPSEC_AUTH_HMAC_SHA2_256:
							esp_auth_alg = "hmac-sha2-256";
							break;

						case IPSEC_AUTH_HMAC_SHA2_384:
							esp_auth_alg = "hmac-sha2-384";
							break;

						case IPSEC_AUTH_HMAC_SHA2_512:
							esp_auth_alg = "hmac-sha2-512";
							break;

						case IPSEC_AUTH_DES_MAC:
							esp_auth_alg = "des-mac";
							break;

						case IPSEC_AUTH_KPDK:
							esp_auth_alg = "kpdk";
							break;
						}
						break;
					}
					break;

				case IPSEC_ATTR_KEY_LENGTH:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_key_length,
						    sizeof ah_key_length, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_key_length,
						    sizeof esp_key_length, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_KEY_ROUNDS:
					switch (proto->proto) {
					case IPSEC_PROTO_IPSEC_AH:
						snprintf(ah_key_rounds,
						    sizeof ah_key_rounds, "%u",
						    decode_16(value));
						break;

					case IPSEC_PROTO_IPSEC_ESP:
						snprintf(esp_key_rounds,
						    sizeof esp_key_rounds, "%u",
						    decode_16(value));
						break;
					}
					break;

				case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
					snprintf(comp_dict_size,
					    sizeof comp_dict_size, "%u",
					    decode_16(value));
					break;

				case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
					snprintf(comp_private_alg,
					    sizeof comp_private_alg, "%u",
					    decode_16(value));
					break;
				}
			}
		}

		policy_sa->transport->vtbl->get_src(policy_sa->transport,
		    &sin);
		if (sockaddr2text(sin, &addr, 1)) {
			log_error("policy_callback: sockaddr2text failed");
			goto bad;
		}
		strlcpy(local_ike_address, addr, sizeof local_ike_address);
		free(addr);

		policy_sa->transport->vtbl->get_dst(policy_sa->transport,
		    &sin);
		if (sockaddr2text(sin, &addr, 1)) {
			log_error("policy_callback: sockaddr2text failed");
			goto bad;
		}
		strlcpy(remote_ike_address, addr, sizeof remote_ike_address);
		free(addr);

		switch (policy_isakmp_sa->exch_type) {
		case ISAKMP_EXCH_AGGRESSIVE:
			phase_1 = "aggressive";
			break;

		case ISAKMP_EXCH_ID_PROT:
			phase_1 = "main";
			break;
		}

		if (policy_isakmp_sa->initiator) {
			id = policy_isakmp_sa->id_r;
			id_sz = policy_isakmp_sa->id_r_len;
		} else {
			id = policy_isakmp_sa->id_i;
			id_sz = policy_isakmp_sa->id_i_len;
		}

		switch (id[0]) {
		case IPSEC_ID_IPV4_ADDR:
			remote_id_type = "IPv4 address";

			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
			my_inet_ntop4(&net, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1, 1);
			my_inet_ntop4(&net, remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1, 1);
			remote_id = strdup(remote_id_addr_upper);
			if (!remote_id) {
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    remote_id_addr_upper);
				goto bad;
			}
			break;

		case IPSEC_ID_IPV4_RANGE:
			remote_id_type = "IPv4 range";

			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
			my_inet_ntop4(&net, remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1, 1);
			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 4);
			my_inet_ntop4(&net, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1, 1);
			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;

		case IPSEC_ID_IPV4_ADDR_SUBNET:
			remote_id_type = "IPv4 subnet";

			net = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
			subnet = decode_32(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 4);
			net &= subnet;
			my_inet_ntop4(&net, remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1, 1);
			net |= ~subnet;
			my_inet_ntop4(&net, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1, 1);
			len = strlen(remote_id_addr_upper) +
				 strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;

		case IPSEC_ID_IPV6_ADDR:
			remote_id_type = "IPv6 address";
			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    remote_id_addr_upper, sizeof remote_id_addr_upper);
			strlcpy(remote_id_addr_lower, remote_id_addr_upper,
			    sizeof remote_id_addr_lower);
			remote_id = strdup(remote_id_addr_upper);
			if (!remote_id) {
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    remote_id_addr_upper);
				goto bad;
			}
			break;

		case IPSEC_ID_IPV6_RANGE:
			remote_id_type = "IPv6 range";

			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1);

			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ + 16, remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1);

			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;

		case IPSEC_ID_IPV6_ADDR_SUBNET:
		    {
			struct in6_addr net, mask;

			remote_id_type = "IPv6 subnet";

			bcopy(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, &net,
			    sizeof(net));
			bcopy(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
			    &mask, sizeof(mask));

			for (i = 0; i < 16; i++)
				net.s6_addr[i] &= mask.s6_addr[i];

			my_inet_ntop6((unsigned char *)&net,
			    remote_id_addr_lower,
			    sizeof remote_id_addr_lower - 1);

			for (i = 0; i < 16; i++)
				net.s6_addr[i] |= ~mask.s6_addr[i];

			my_inet_ntop6((unsigned char *)&net,
			    remote_id_addr_upper,
			    sizeof remote_id_addr_upper - 1);

			len = strlen(remote_id_addr_upper) +
			    strlen(remote_id_addr_lower) + 2;
			remote_id = calloc(len, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%d, %lu) failed", len,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			strlcpy(remote_id, remote_id_addr_lower, len);
			strlcat(remote_id, "-", len);
			strlcat(remote_id, remote_id_addr_upper, len);
			break;
		    }

		case IPSEC_ID_FQDN:
			remote_id_type = "FQDN";
			remote_id = calloc(id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
				    (unsigned long)id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			memcpy(remote_id,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			break;

		case IPSEC_ID_USER_FQDN:
			remote_id_type = "User FQDN";
			remote_id = calloc(id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
				    (unsigned long)id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			memcpy(remote_id,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			break;

		case IPSEC_ID_DER_ASN1_DN:
			remote_id_type = "ASN1 DN";

			remote_id = x509_DN_string(id + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ,
			    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			if (!remote_id) {
				LOG_DBG((LOG_POLICY, 50,
				    "policy_callback: failed to decode name"));
				goto bad;
			}
			break;

		case IPSEC_ID_DER_ASN1_GN:	/* XXX */
			remote_id_type = "ASN1 GN";
			break;

		case IPSEC_ID_KEY_ID:
			remote_id_type = "Key ID";
			remote_id = calloc(2 * (id_sz - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ) + 1, sizeof(char));
			if (!remote_id) {
				log_error("policy_callback: "
				    "calloc (%lu, %lu) failed",
				    2 * ((unsigned long)id_sz -
					ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
				    (unsigned long)sizeof(char));
				goto bad;
			}
			/* Does it contain any non-printable characters ? */
			for (i = 0;
			    i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
			    i++)
				if (!isprint((unsigned char)*(id + ISAKMP_ID_DATA_OFF -
				    ISAKMP_GEN_SZ + i)))
					break;
			if (i >= id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) {
				memcpy(remote_id, id + ISAKMP_ID_DATA_OFF -
				    ISAKMP_GEN_SZ,
				    id_sz - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ);
				break;
			}
			/* Non-printable characters, convert to hex */
			for (i = 0;
			    i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
			    i++) {
				remote_id[2 * i] = hextab[*(id +
				    ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) >> 4];
				remote_id[2 * i + 1] = hextab[*(id +
				    ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) & 0xF];
			}
			break;

		default:
			log_print("policy_callback: "
			    "unknown remote ID type %u", id[0]);
			goto bad;
		}

		switch (id[1]) {
		case IPPROTO_TCP:
			remote_id_proto = "tcp";
			break;

		case IPPROTO_UDP:
			remote_id_proto = "udp";
			break;

		case IPPROTO_ETHERIP:
			remote_id_proto = "etherip";
			break;

		default:
			snprintf(remote_id_proto_num,
			    sizeof remote_id_proto_num, "%d",
			    id[1]);
			remote_id_proto = remote_id_proto_num;
			break;
		}

		snprintf(remote_id_port, sizeof remote_id_port, "%u",
		    decode_16(id + 2));

		if (policy_exchange->initiator) {
			initiator = "yes";
			idlocal = ie->id_ci;
			idremote = ie->id_cr;
			idlocalsz = ie->id_ci_sz;
			idremotesz = ie->id_cr_sz;
		} else {
			initiator = "no";
			idlocal = ie->id_cr;
			idremote = ie->id_ci;
			idlocalsz = ie->id_cr_sz;
			idremotesz = ie->id_ci_sz;
		}

		/* Initialize the ID variables.  */
		if (idremote) {
			switch (GET_ISAKMP_ID_TYPE(idremote)) {
			case IPSEC_ID_IPV4_ADDR:
				remote_filter_type = "IPv4 address";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				remote_filter =
				    strdup(remote_filter_addr_upper);
				if (!remote_filter) {
					log_error("policy_callback: strdup "
					    "(\"%s\") failed",
					    remote_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV4_RANGE:
				remote_filter_type = "IPv4 range";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				net = decode_32(idremote + ISAKMP_ID_DATA_OFF +
				    4);
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV4_ADDR_SUBNET:
				remote_filter_type = "IPv4 subnet";

				net = decode_32(idremote + ISAKMP_ID_DATA_OFF);
				subnet = decode_32(idremote +
				    ISAKMP_ID_DATA_OFF + 4);
				net &= subnet;
				my_inet_ntop4(&net, remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1, 1);
				net |= ~subnet;
				my_inet_ntop4(&net, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1, 1);
				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV6_ADDR:
				remote_filter_type = "IPv6 address";
				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF,
				    remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1);
				strlcpy(remote_filter_addr_lower,
				    remote_filter_addr_upper,
				    sizeof remote_filter_addr_lower);
				remote_filter =
				    strdup(remote_filter_addr_upper);
				if (!remote_filter) {
					log_error("policy_callback: strdup "
					    "(\"%s\") failed",
					    remote_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV6_RANGE:
				remote_filter_type = "IPv6 range";

				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF,
				    remote_filter_addr_lower,
				    sizeof remote_filter_addr_lower - 1);

				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF +
				    16, remote_filter_addr_upper,
				    sizeof remote_filter_addr_upper - 1);

				len = strlen(remote_filter_addr_upper) +
				    strlen(remote_filter_addr_lower) + 2;
				remote_filter = calloc(len, sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: calloc "
					    "(%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(remote_filter,
				    remote_filter_addr_lower, len);
				strlcat(remote_filter, "-", len);
				strlcat(remote_filter,
				    remote_filter_addr_upper, len);
				break;

			case IPSEC_ID_IPV6_ADDR_SUBNET:
				{
					struct in6_addr net, mask;

					remote_filter_type = "IPv6 subnet";

					bcopy(idremote + ISAKMP_ID_DATA_OFF,
					    &net, sizeof(net));
					bcopy(idremote + ISAKMP_ID_DATA_OFF +
					    16, &mask, sizeof(mask));

					for (i = 0; i < 16; i++)
						net.s6_addr[i] &=
						    mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net,
					    remote_filter_addr_lower,
					sizeof remote_filter_addr_lower - 1);

					for (i = 0; i < 16; i++)
						net.s6_addr[i] |=
						    ~mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net,
					    remote_filter_addr_upper,
					sizeof remote_filter_addr_upper - 1);

					len = strlen(remote_filter_addr_upper)
						+ strlen(remote_filter_addr_lower) + 2;
					remote_filter = calloc(len,
					    sizeof(char));
					if (!remote_filter) {
						log_error("policy_callback: "
						    "calloc (%d, %lu) failed",
						    len,
						    (unsigned long)sizeof(char));
						goto bad;
					}
					strlcpy(remote_filter,
					    remote_filter_addr_lower, len);
					strlcat(remote_filter, "-", len);
					strlcat(remote_filter,
					    remote_filter_addr_upper, len);
					break;
				}

			case IPSEC_ID_FQDN:
				remote_filter_type = "FQDN";
				remote_filter = malloc(idremotesz -
				    ISAKMP_ID_DATA_OFF + 1);
				if (!remote_filter) {
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idremotesz -
					    ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(remote_filter,
				    idremote + ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF]
				    = '\0';
				break;

			case IPSEC_ID_USER_FQDN:
				remote_filter_type = "User FQDN";
				remote_filter = malloc(idremotesz -
				    ISAKMP_ID_DATA_OFF + 1);
				if (!remote_filter) {
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idremotesz -
					    ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(remote_filter,
				    idremote + ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF]
				    = '\0';
				break;

			case IPSEC_ID_DER_ASN1_DN:
				remote_filter_type = "ASN1 DN";

				remote_filter = x509_DN_string(idremote +
				    ISAKMP_ID_DATA_OFF,
				    idremotesz - ISAKMP_ID_DATA_OFF);
				if (!remote_filter) {
					LOG_DBG((LOG_POLICY, 50,
					    "policy_callback: "
					    "failed to decode name"));
					goto bad;
				}
				break;

			case IPSEC_ID_DER_ASN1_GN:	/* XXX -- not sure
							 * what's in this.  */
				remote_filter_type = "ASN1 GN";
				break;

			case IPSEC_ID_KEY_ID:
				remote_filter_type = "Key ID";
				remote_filter
					= calloc(2 * (idremotesz -
					    ISAKMP_ID_DATA_OFF) + 1,
					    sizeof(char));
				if (!remote_filter) {
					log_error("policy_callback: "
					    "calloc (%lu, %lu) failed",
					    2 * ((unsigned long)idremotesz -
						ISAKMP_ID_DATA_OFF) + 1,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				/*
				 * Does it contain any non-printable
				 * characters ?
				 */
				for (i = 0;
				    i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint((unsigned char)*(idremote +
					    ISAKMP_ID_DATA_OFF + i)))
						break;
				if (i >= idremotesz - ISAKMP_ID_DATA_OFF) {
					memcpy(remote_filter,
					    idremote + ISAKMP_ID_DATA_OFF,
					    idremotesz - ISAKMP_ID_DATA_OFF);
					break;
				}
				/* Non-printable characters, convert to hex */
				for (i = 0;
				    i < idremotesz - ISAKMP_ID_DATA_OFF;
				    i++) {
					remote_filter[2 * i]
					    = hextab[*(idremote +
						ISAKMP_ID_DATA_OFF) >> 4];
					remote_filter[2 * i + 1]
					    = hextab[*(idremote +
						ISAKMP_ID_DATA_OFF) & 0xF];
				}
				break;

			default:
				log_print("policy_callback: "
				    "unknown Remote ID type %u",
				    GET_ISAKMP_ID_TYPE(idremote));
				goto bad;
			}

			switch (idremote[ISAKMP_GEN_SZ + 1]) {
			case IPPROTO_TCP:
				remote_filter_proto = "tcp";
				break;

			case IPPROTO_UDP:
				remote_filter_proto = "udp";
				break;

			case IPPROTO_ETHERIP:
				remote_filter_proto = "etherip";
				break;

			default:
				snprintf(remote_filter_proto_num,
				    sizeof remote_filter_proto_num, "%d",
				    idremote[ISAKMP_GEN_SZ + 1]);
				remote_filter_proto = remote_filter_proto_num;
				break;
			}

			snprintf(remote_filter_port, sizeof remote_filter_port,
			    "%u", decode_16(idremote + ISAKMP_GEN_SZ + 2));
		} else {
			policy_sa->transport->vtbl->get_dst(policy_sa->transport, &sin);
			switch (sin->sa_family) {
			case AF_INET:
				remote_filter_type = "IPv4 address";
				break;
			case AF_INET6:
				remote_filter_type = "IPv6 address";
				break;
			default:
				log_print("policy_callback: "
				    "unsupported protocol family %d",
				    sin->sa_family);
				goto bad;
			}
			if (sockaddr2text(sin, &addr, 1)) {
				log_error("policy_callback: "
				    "sockaddr2text failed");
				goto bad;
			}
			memcpy(remote_filter_addr_upper, addr,
			    sizeof remote_filter_addr_upper);
			memcpy(remote_filter_addr_lower, addr,
			    sizeof remote_filter_addr_lower);
			free(addr);
			remote_filter = strdup(remote_filter_addr_upper);
			if (!remote_filter) {
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    remote_filter_addr_upper);
				goto bad;
			}
		}

		if (idlocal) {
			switch (GET_ISAKMP_ID_TYPE(idlocal)) {
			case IPSEC_ID_IPV4_ADDR:
				local_filter_type = "IPv4 address";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, local_filter_addr_upper,
				    sizeof local_filter_addr_upper - 1, 1);
				my_inet_ntop4(&net, local_filter_addr_lower,
				    sizeof local_filter_addr_upper - 1, 1);
				local_filter = strdup(local_filter_addr_upper);
				if (!local_filter) {
					log_error("policy_callback: "
					    "strdup (\"%s\") failed",
					    local_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV4_RANGE:
				local_filter_type = "IPv4 range";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				my_inet_ntop4(&net, local_filter_addr_lower,
				    sizeof local_filter_addr_lower - 1, 1);
				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF +
				    4);
				my_inet_ntop4(&net, local_filter_addr_upper,
				    sizeof local_filter_addr_upper - 1, 1);
				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper,
				    len);
				break;

			case IPSEC_ID_IPV4_ADDR_SUBNET:
				local_filter_type = "IPv4 subnet";

				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF);
				subnet = decode_32(idlocal +
				    ISAKMP_ID_DATA_OFF + 4);
				net &= subnet;
				my_inet_ntop4(&net, local_filter_addr_lower,
				    sizeof local_filter_addr_lower - 1, 1);
				net |= ~subnet;
				my_inet_ntop4(&net, local_filter_addr_upper,
				    sizeof local_filter_addr_upper - 1, 1);
				len = strlen(local_filter_addr_upper) +
				    strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper,
				    len);
				break;

			case IPSEC_ID_IPV6_ADDR:
				local_filter_type = "IPv6 address";
				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF,
				    local_filter_addr_upper,
				    sizeof local_filter_addr_upper - 1);
				strlcpy(local_filter_addr_lower,
				    local_filter_addr_upper,
				    sizeof local_filter_addr_lower);
				local_filter = strdup(local_filter_addr_upper);
				if (!local_filter) {
					log_error("policy_callback: "
					    "strdup (\"%s\") failed",
					    local_filter_addr_upper);
					goto bad;
				}
				break;

			case IPSEC_ID_IPV6_RANGE:
				local_filter_type = "IPv6 range";

				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF,
				    local_filter_addr_lower,
				    sizeof local_filter_addr_lower - 1);

				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF +
				    16, local_filter_addr_upper,
				    sizeof local_filter_addr_upper - 1);

				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
				local_filter = calloc(len, sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: "
					    "calloc (%d, %lu) failed", len,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				strlcpy(local_filter, local_filter_addr_lower,
				    len);
				strlcat(local_filter, "-", len);
				strlcat(local_filter, local_filter_addr_upper,
				    len);
				break;

			case IPSEC_ID_IPV6_ADDR_SUBNET:
				{
					struct in6_addr net, mask;

					local_filter_type = "IPv6 subnet";

					bcopy(idlocal + ISAKMP_ID_DATA_OFF,
					    &net, sizeof(net));
					bcopy(idlocal + ISAKMP_ID_DATA_OFF +
					    16, &mask, sizeof(mask));

					for (i = 0; i < 16; i++)
						net.s6_addr[i] &=
						    mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net,
					    local_filter_addr_lower,
					sizeof local_filter_addr_lower - 1);

					for (i = 0; i < 16; i++)
						net.s6_addr[i] |=
						    ~mask.s6_addr[i];

					my_inet_ntop6((unsigned char *)&net,
					    local_filter_addr_upper,
					    sizeof local_filter_addr_upper -
					    1);

					len = strlen(local_filter_addr_upper)
					    + strlen(local_filter_addr_lower)
					    + 2;
					local_filter = calloc(len,
					    sizeof(char));
					if (!local_filter) {
						log_error("policy_callback: "
						    "calloc (%d, %lu) failed",
						    len,
						    (unsigned long)sizeof(char));
						goto bad;
					}
					strlcpy(local_filter,
					    local_filter_addr_lower, len);
					strlcat(local_filter, "-", len);
					strlcat(local_filter,
					    local_filter_addr_upper, len);
					break;
				}

			case IPSEC_ID_FQDN:
				local_filter_type = "FQDN";
				local_filter = malloc(idlocalsz -
				    ISAKMP_ID_DATA_OFF + 1);
				if (!local_filter) {
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idlocalsz -
					    ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(local_filter,
				    idlocal + ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
				break;

			case IPSEC_ID_USER_FQDN:
				local_filter_type = "User FQDN";
				local_filter = malloc(idlocalsz -
				    ISAKMP_ID_DATA_OFF + 1);
				if (!local_filter) {
					log_error("policy_callback: "
					    "malloc (%lu) failed",
					    (unsigned long)idlocalsz -
					    ISAKMP_ID_DATA_OFF + 1);
					goto bad;
				}
				memcpy(local_filter,
				    idlocal + ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
				break;

			case IPSEC_ID_DER_ASN1_DN:
				local_filter_type = "ASN1 DN";

				local_filter = x509_DN_string(idlocal +
				    ISAKMP_ID_DATA_OFF,
				    idlocalsz - ISAKMP_ID_DATA_OFF);
				if (!local_filter) {
					LOG_DBG((LOG_POLICY, 50,
					    "policy_callback: failed to decode"
					    " name"));
					goto bad;
				}
				break;

			case IPSEC_ID_DER_ASN1_GN:
				/* XXX -- not sure what's in this.  */
				local_filter_type = "ASN1 GN";
				break;

			case IPSEC_ID_KEY_ID:
				local_filter_type = "Key ID";
				local_filter = calloc(2 * (idlocalsz -
				    ISAKMP_ID_DATA_OFF) + 1,
				    sizeof(char));
				if (!local_filter) {
					log_error("policy_callback: "
					    "calloc (%lu, %lu) failed",
					    2 * ((unsigned long)idlocalsz -
					    ISAKMP_ID_DATA_OFF) + 1,
					    (unsigned long)sizeof(char));
					goto bad;
				}
				/*
				 * Does it contain any non-printable
				 * characters ?
				 */
				for (i = 0;
				    i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint((unsigned char)*(idlocal +
					    ISAKMP_ID_DATA_OFF + i)))
						break;
				if (i >= idlocalsz - ISAKMP_ID_DATA_OFF) {
					memcpy(local_filter, idlocal +
					    ISAKMP_ID_DATA_OFF,
					    idlocalsz - ISAKMP_ID_DATA_OFF);
					break;
				}
				/* Non-printable characters, convert to hex */
				for (i = 0;
				    i < idlocalsz - ISAKMP_ID_DATA_OFF; i++) {
					local_filter[2 * i] =
					    hextab[*(idlocal +
					    ISAKMP_ID_DATA_OFF) >> 4];
					local_filter[2 * i + 1] =
					    hextab[*(idlocal +
					    ISAKMP_ID_DATA_OFF) & 0xF];
				}
				break;

			default:
				log_print("policy_callback: "
				    "unknown Local ID type %u",
				    GET_ISAKMP_ID_TYPE(idlocal));
				goto bad;
			}

			switch (idlocal[ISAKMP_GEN_SZ + 1]) {
			case IPPROTO_TCP:
				local_filter_proto = "tcp";
				break;

			case IPPROTO_UDP:
				local_filter_proto = "udp";
				break;

			case IPPROTO_ETHERIP:
				local_filter_proto = "etherip";
				break;

			default:
				snprintf(local_filter_proto_num,
				    sizeof local_filter_proto_num,
				    "%d", idlocal[ISAKMP_GEN_SZ + 1]);
				local_filter_proto = local_filter_proto_num;
				break;
			}

			snprintf(local_filter_port, sizeof local_filter_port,
			    "%u", decode_16(idlocal + ISAKMP_GEN_SZ + 2));
		} else {
			policy_sa->transport->vtbl->get_src(policy_sa->transport,
			    (struct sockaddr **)&sin);
			switch (sin->sa_family) {
			case AF_INET:
				local_filter_type = "IPv4 address";
				break;
			case AF_INET6:
				local_filter_type = "IPv6 address";
				break;
			default:
				log_print("policy_callback: "
				    "unsupported protocol family %d",
				    sin->sa_family);
				goto bad;
			}

			if (sockaddr2text(sin, &addr, 1)) {
				log_error("policy_callback: "
				    "sockaddr2text failed");
				goto bad;
			}
			memcpy(local_filter_addr_upper, addr,
			    sizeof local_filter_addr_upper);
			memcpy(local_filter_addr_lower, addr,
			    sizeof local_filter_addr_lower);
			free(addr);
			local_filter = strdup(local_filter_addr_upper);
			if (!local_filter) {
				log_error("policy_callback: "
				    "strdup (\"%s\") failed",
				    local_filter_addr_upper);
				goto bad;
			}
		}

		LOG_DBG((LOG_POLICY, 80,
		    "Policy context (action attributes):"));
		LOG_DBG((LOG_POLICY, 80, "esp_present == %s", esp_present));
		LOG_DBG((LOG_POLICY, 80, "ah_present == %s", ah_present));
		LOG_DBG((LOG_POLICY, 80, "comp_present == %s", comp_present));
		LOG_DBG((LOG_POLICY, 80, "ah_hash_alg == %s", ah_hash_alg));
		LOG_DBG((LOG_POLICY, 80, "esp_enc_alg == %s", esp_enc_alg));
		LOG_DBG((LOG_POLICY, 80, "comp_alg == %s", comp_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_auth_alg == %s", ah_auth_alg));
		LOG_DBG((LOG_POLICY, 80, "esp_auth_alg == %s", esp_auth_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_life_seconds == %s",
		    ah_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "ah_life_kbytes == %s",
		    ah_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "esp_life_seconds == %s",
		    esp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "esp_life_kbytes == %s",
		    esp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "comp_life_seconds == %s",
		    comp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "comp_life_kbytes == %s",
		    comp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "ah_encapsulation == %s",
		    ah_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "esp_encapsulation == %s",
		    esp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_encapsulation == %s",
		    comp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_dict_size == %s",
		    comp_dict_size));
		LOG_DBG((LOG_POLICY, 80, "comp_private_alg == %s",
		    comp_private_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_key_length == %s",
		    ah_key_length));
		LOG_DBG((LOG_POLICY, 80, "ah_key_rounds == %s",
		    ah_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "esp_key_length == %s",
		    esp_key_length));
		LOG_DBG((LOG_POLICY, 80, "esp_key_rounds == %s",
		    esp_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "ah_group_desc == %s",
		    ah_group_desc));
		LOG_DBG((LOG_POLICY, 80, "esp_group_desc == %s",
		    esp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "comp_group_desc == %s",
		    comp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "ah_ecn == %s", ah_ecn));
		LOG_DBG((LOG_POLICY, 80, "esp_ecn == %s", esp_ecn));
		LOG_DBG((LOG_POLICY, 80, "comp_ecn == %s", comp_ecn));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_type == %s",
		    remote_filter_type));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_addr_upper == %s",
		    remote_filter_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_addr_lower == %s",
		    remote_filter_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "remote_filter == %s",
		    (remote_filter ? remote_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_port == %s",
		    remote_filter_port));
		LOG_DBG((LOG_POLICY, 80, "remote_filter_proto == %s",
		    remote_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "local_filter_type == %s",
		    local_filter_type));
		LOG_DBG((LOG_POLICY, 80, "local_filter_addr_upper == %s",
		    local_filter_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "local_filter_addr_lower == %s",
		    local_filter_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "local_filter == %s",
		    (local_filter ? local_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "local_filter_port == %s",
		    local_filter_port));
		LOG_DBG((LOG_POLICY, 80, "local_filter_proto == %s",
		    local_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_id_type == %s",
		    remote_id_type));
		LOG_DBG((LOG_POLICY, 80, "remote_id_addr_upper == %s",
		    remote_id_addr_upper));
		LOG_DBG((LOG_POLICY, 80, "remote_id_addr_lower == %s",
		    remote_id_addr_lower));
		LOG_DBG((LOG_POLICY, 80, "remote_id == %s",
		    (remote_id ? remote_id : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_id_port == %s",
		    remote_id_port));
		LOG_DBG((LOG_POLICY, 80, "remote_id_proto == %s",
		    remote_id_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_negotiation_address == %s",
		    remote_ike_address));
		LOG_DBG((LOG_POLICY, 80, "local_negotiation_address == %s",
		    local_ike_address));
		LOG_DBG((LOG_POLICY, 80, "pfs == %s", pfs));
		LOG_DBG((LOG_POLICY, 80, "initiator == %s", initiator));
		LOG_DBG((LOG_POLICY, 80, "phase1_group_desc == %s",
		    phase1_group));

		/* Unset dirty now.  */
		dirty = 0;
	}
	if (strcmp(name, "phase_1") == 0)
		return phase_1;

	if (strcmp(name, "GMTTimeOfDay") == 0) {
		tt = time(NULL);
		strftime(mytimeofday, 14, "%Y%m%d%H%M%S", gmtime(&tt));
		return mytimeofday;
	}
	if (strcmp(name, "LocalTimeOfDay") == 0) {
		tt = time(NULL);
		strftime(mytimeofday, 14, "%Y%m%d%H%M%S", localtime(&tt));
		return mytimeofday;
	}
	if (strcmp(name, "initiator") == 0)
		return initiator;

	if (strcmp(name, "pfs") == 0)
		return pfs;

	if (strcmp(name, "app_domain") == 0)
		return "IPsec policy";

	if (strcmp(name, "doi") == 0)
		return "ipsec";

	if (strcmp(name, "esp_present") == 0)
		return esp_present;

	if (strcmp(name, "ah_present") == 0)
		return ah_present;

	if (strcmp(name, "comp_present") == 0)
		return comp_present;

	if (strcmp(name, "ah_hash_alg") == 0)
		return ah_hash_alg;

	if (strcmp(name, "ah_auth_alg") == 0)
		return ah_auth_alg;

	if (strcmp(name, "esp_auth_alg") == 0)
		return esp_auth_alg;

	if (strcmp(name, "esp_enc_alg") == 0)
		return esp_enc_alg;

	if (strcmp(name, "comp_alg") == 0)
		return comp_alg;

	if (strcmp(name, "ah_life_kbytes") == 0)
		return ah_life_kbytes;

	if (strcmp(name, "ah_life_seconds") == 0)
		return ah_life_seconds;

	if (strcmp(name, "esp_life_kbytes") == 0)
		return esp_life_kbytes;

	if (strcmp(name, "esp_life_seconds") == 0)
		return esp_life_seconds;

	if (strcmp(name, "comp_life_kbytes") == 0)
		return comp_life_kbytes;

	if (strcmp(name, "comp_life_seconds") == 0)
		return comp_life_seconds;

	if (strcmp(name, "ah_encapsulation") == 0)
		return ah_encapsulation;

	if (strcmp(name, "esp_encapsulation") == 0)
		return esp_encapsulation;

	if (strcmp(name, "comp_encapsulation") == 0)
		return comp_encapsulation;

	if (strcmp(name, "ah_key_length") == 0)
		return ah_key_length;

	if (strcmp(name, "ah_key_rounds") == 0)
		return ah_key_rounds;

	if (strcmp(name, "esp_key_length") == 0)
		return esp_key_length;

	if (strcmp(name, "esp_key_rounds") == 0)
		return esp_key_rounds;

	if (strcmp(name, "comp_dict_size") == 0)
		return comp_dict_size;

	if (strcmp(name, "comp_private_alg") == 0)
		return comp_private_alg;

	if (strcmp(name, "remote_filter_type") == 0)
		return remote_filter_type;

	if (strcmp(name, "remote_filter") == 0)
		return (remote_filter ? remote_filter : "");

	if (strcmp(name, "remote_filter_addr_upper") == 0)
		return remote_filter_addr_upper;

	if (strcmp(name, "remote_filter_addr_lower") == 0)
		return remote_filter_addr_lower;

	if (strcmp(name, "remote_filter_port") == 0)
		return remote_filter_port;

	if (strcmp(name, "remote_filter_proto") == 0)
		return remote_filter_proto;

	if (strcmp(name, "local_filter_type") == 0)
		return local_filter_type;

	if (strcmp(name, "local_filter") == 0)
		return (local_filter ? local_filter : "");

	if (strcmp(name, "local_filter_addr_upper") == 0)
		return local_filter_addr_upper;

	if (strcmp(name, "local_filter_addr_lower") == 0)
		return local_filter_addr_lower;

	if (strcmp(name, "local_filter_port") == 0)
		return local_filter_port;

	if (strcmp(name, "local_filter_proto") == 0)
		return local_filter_proto;

	if (strcmp(name, "remote_ike_address") == 0)
		return remote_ike_address;

	if (strcmp(name, "remote_negotiation_address") == 0)
		return remote_ike_address;

	if (strcmp(name, "local_ike_address") == 0)
		return local_ike_address;

	if (strcmp(name, "local_negotiation_address") == 0)
		return local_ike_address;

	if (strcmp(name, "remote_id_type") == 0)
		return remote_id_type;

	if (strcmp(name, "remote_id") == 0)
		return (remote_id ? remote_id : "");

	if (strcmp(name, "remote_id_addr_upper") == 0)
		return remote_id_addr_upper;

	if (strcmp(name, "remote_id_addr_lower") == 0)
		return remote_id_addr_lower;

	if (strcmp(name, "remote_id_port") == 0)
		return remote_id_port;

	if (strcmp(name, "remote_id_proto") == 0)
		return remote_id_proto;

	if (strcmp(name, "phase1_group_desc") == 0)
		return phase1_group;

	if (strcmp(name, "esp_group_desc") == 0)
		return esp_group_desc;

	if (strcmp(name, "ah_group_desc") == 0)
		return ah_group_desc;

	if (strcmp(name, "comp_group_desc") == 0)
		return comp_group_desc;

	if (strcmp(name, "comp_ecn") == 0)
		return comp_ecn;

	if (strcmp(name, "ah_ecn") == 0)
		return ah_ecn;

	if (strcmp(name, "esp_ecn") == 0)
		return esp_ecn;

	return "";

bad:
	policy_callback(KEYNOTE_CALLBACK_INITIALIZE);
	return "";
}

void
policy_init(void)
{
	char           *ptr, *policy_file;
	char          **asserts;
	size_t          sz, len;
	int             fd, i;

	LOG_DBG((LOG_POLICY, 30, "policy_init: initializing"));

	/* Do we want to use the policy modules?  */
	if (ignore_policy ||
	    strncmp("yes", conf_get_str("General", "Use-Keynote"), 3))
		return;

	/* Get policy file from configuration.  */
	policy_file = conf_get_str("General", "Policy-file");
	if (!policy_file)
		policy_file = CONF_DFLT_POLICY_FILE;

	/* Open policy file.  */
	fd = monitor_open(policy_file, O_RDONLY, 0);
	if (fd == -1)
		log_fatal("policy_init: open (\"%s\", O_RDONLY) failed",
		    policy_file);

	/* Check file modes and collect file size */
	if (check_file_secrecy_fd(fd, policy_file, &sz)) {
		close(fd);
		log_fatal("policy_init: cannot read %s", policy_file);
	}

	/* Allocate memory to keep policies.  */
	ptr = calloc(sz + 1, sizeof(char));
	if (!ptr)
		log_fatal("policy_init: calloc (%lu, %lu) failed",
		    (unsigned long)sz + 1, (unsigned long)sizeof(char));

	/* Just in case there are short reads...  */
	for (len = 0; len < sz; len += i) {
		i = read(fd, ptr + len, sz - len);
		if (i == -1)
			log_fatal("policy_init: read (%d, %p, %lu) failed", fd,
			    ptr + len, (unsigned long)(sz - len));
	}

	/* We're done with this.  */
	close(fd);

	/* Parse buffer, break up into individual policies.  */
	asserts = kn_read_asserts(ptr, sz, &i);

	/* Begone!  */
	free(ptr);

	if (asserts == (char **)NULL)
		log_print("policy_init: all policies flushed");

	/* Cleanup */
	if (policy_asserts) {
		for (fd = 0; fd < policy_asserts_num; fd++)
			if (policy_asserts)
				free(policy_asserts[fd]);

		free(policy_asserts);
	}
	policy_asserts = asserts;
	policy_asserts_num = i;
}

/* Nothing needed for initialization */
int
keynote_cert_init(void)
{
	return 1;
}

/* Just copy and return.  */
void           *
keynote_cert_get(u_int8_t *data, u_int32_t len)
{
	char	*foo = malloc(len + 1);

	if (foo == NULL)
		return NULL;

	memcpy(foo, data, len);
	foo[len] = '\0';
	return foo;
}

/*
 * We just verify the signature on the credentials.
 * On signature failure, just drop the whole payload.
 */
int
keynote_cert_validate(void *scert)
{
	char	**foo;
	int	  num, i;

	if (scert == NULL)
		return 0;

	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL)
		return 0;

	for (i = 0; i < num; i++) {
		if (kn_verify_assertion(scert, strlen((char *)scert))
		    != SIGRESULT_TRUE) {
			for (; i < num; i++)
				free(foo[i]);
			free(foo);
			return 0;
		}
		free(foo[i]);
	}

	free(foo);
	return 1;
}

/* Add received credentials.  */
int
keynote_cert_insert(int sid, void *scert)
{
	char	**foo;
	int	  num;

	if (scert == NULL)
		return 0;

	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL)
		return 0;

	while (num--)
		kn_add_assertion(sid, foo[num], strlen(foo[num]), 0);

	return 1;
}

/* Just regular memory free.  */
void
keynote_cert_free(void *cert)
{
	free(cert);
}

/* Verify that the key given to us is valid.  */
int
keynote_certreq_validate(u_int8_t *data, u_int32_t len)
{
	struct keynote_deckey dc;
	int	 err = 1;
	char	*dat;

	dat = calloc(len + 1, sizeof(char));
	if (!dat) {
		log_error("keynote_certreq_validate: calloc (%d, %lu) failed",
		    len + 1, (unsigned long)sizeof(char));
		return 0;
	}
	memcpy(dat, data, len);

	if (kn_decode_key(&dc, dat, KEYNOTE_PUBLIC_KEY) != 0)
		err = 0;
	else
		kn_free_key(&dc);

	free(dat);

	return err;
}

/* Beats me what we should be doing with this.  */
int
keynote_certreq_decode(void **pdata, u_int8_t *data, u_int32_t len)
{
	/* XXX */
	return 0;
}

void
keynote_free_aca(void *blob)
{
	/* XXX */
}

int
keynote_cert_obtain(u_int8_t *id, size_t id_len, void *data, u_int8_t **cert,
    u_int32_t *certlen)
{
	char           *dirname, *file, *addr_str;
	struct stat     sb;
	size_t          size;
	int             idtype, fd, len;

	if (!id) {
		log_print("keynote_cert_obtain: ID is missing");
		return 0;
	}
	/* Get type of ID.  */
	idtype = id[0];
	id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
	id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

	dirname = conf_get_str("KeyNote", "Credential-directory");
	if (!dirname) {
		LOG_DBG((LOG_POLICY, 30,
			 "keynote_cert_obtain: no Credential-directory"));
		return 0;
	}
	len = strlen(dirname) + strlen(CREDENTIAL_FILE) + 3;

	switch (idtype) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
		util_ntoa(&addr_str, idtype == IPSEC_ID_IPV4_ADDR ?
		    AF_INET : AF_INET6, id);
		if (addr_str == 0)
			return 0;

		if (asprintf(&file, "%s/%s/%s", dirname,
		    addr_str, CREDENTIAL_FILE) == -1) {
			log_error("keynote_cert_obtain: failed to allocate "
			    "%lu bytes", (unsigned long)len +
			    strlen(addr_str));
			free(addr_str);
			return 0;
		}
		free(addr_str);
		break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
		file = calloc(len + id_len, sizeof(char));
		if (file == NULL) {
			log_error("keynote_cert_obtain: "
			    "failed to allocate %lu bytes",
			    (unsigned long)len + id_len);
			return 0;
		}
		snprintf(file, len + id_len, "%s/", dirname);
		memcpy(file + strlen(dirname) + 1, id, id_len);
		snprintf(file + strlen(dirname) + 1 + id_len,
		    len - strlen(dirname) - 1, "/%s", CREDENTIAL_FILE);
		break;

	default:
		return 0;
	}

	fd = monitor_open(file, O_RDONLY, 0);
	if (fd < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to open \"%s\"", file));
		free(file);
		return 0;
	}

	if (fstat(fd, &sb) < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to stat \"%s\"", file));
		free(file);
		close(fd);
		return 0;
	}
	size = (size_t)sb.st_size;

	*cert = calloc(size + 1, sizeof(char));
	if (*cert == NULL) {
		log_error("keynote_cert_obtain: failed to allocate %lu bytes",
		    (unsigned long)size);
		free(file);
		close(fd);
		return 0;
	}

	if (read(fd, *cert, size) != (int)size) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: "
		    "failed to read %lu bytes from \"%s\"",
		    (unsigned long)size, file));
		free(cert);
		cert = NULL;
		free(file);
		close(fd);
		return 0;
	}
	close(fd);
	free(file);
	*certlen = size;
	return 1;
}

/* This should never be called.  */
int
keynote_cert_get_subjects(void *scert, int *n, u_int8_t ***id,
    u_int32_t **id_len)
{
	return 0;
}

/* Get the authorizer key.  */
int
keynote_cert_get_key(void *scert, void *keyp)
{
	struct keynote_keylist *kl;
	int             sid, kid, num;
	char          **foo;

	foo = kn_read_asserts((char *)scert, strlen((char *)scert), &num);
	if (foo == NULL || num == 0) {
		log_print("keynote_cert_get_key: "
		    "failed to decompose credentials");
		return 0;
	}
	kid = kn_init();
	if (kid == -1) {
		log_print("keynote_cert_get_key: "
		    "failed to initialize new policy session");
		while (num--)
			free(foo[num]);
		free(foo);
		return 0;
	}
	sid = kn_add_assertion(kid, foo[num - 1], strlen(foo[num - 1]), 0);
	while (num--)
		free(foo[num]);
	free(foo);

	if (sid == -1) {
		log_print("keynote_cert_get_key: failed to add assertion");
		kn_close(kid);
		return 0;
	}
	*(RSA **)keyp = NULL;

	kl = kn_get_licensees(kid, sid);
	while (kl) {
		if (kl->key_alg == KEYNOTE_ALGORITHM_RSA ||
		    kl->key_alg == KEYNOTE_ALGORITHM_X509) {
			*(RSA **)keyp = RSAPublicKey_dup(kl->key_key);
			break;
		}
		kl = kl->key_next;
	}

	kn_remove_assertion(kid, sid);
	kn_close(kid);
	return *(RSA **)keyp == NULL ? 0 : 1;
}

void *
keynote_cert_dup(void *cert)
{
	return strdup((char *)cert);
}

void
keynote_serialize(void *cert, u_int8_t **data, u_int32_t *datalen)
{
	*datalen = strlen((char *)cert) + 1;
	*data = (u_int8_t *)strdup(cert);	/* i.e an extra character at
						 * the end... */
	if (*data == NULL)
		log_error("keynote_serialize: malloc (%d) failed", *datalen);
}

/* From cert to printable */
char *
keynote_printable(void *cert)
{
	return strdup((char *)cert);
}

/* From printable to cert */
void *
keynote_from_printable(char *cert)
{
	return strdup(cert);
}

/* Number of CAs we trust (currently this is x509 only) */
int
keynote_ca_count(void)
{
	return 0;
}
@


1.96
log
@remove casts to time_t * which are not needed
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.95 2013/03/21 04:30:14 deraadt Exp $	 */
d922 1
a922 1
				if (!isprint(*(id + ISAKMP_ID_DATA_OFF -
d1228 1
a1228 1
					if (!isprint(*(idremote +
d1551 1
a1551 1
					if (!isprint(*(idlocal +
@


1.95
log
@remove excessive includes
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.94 2012/06/30 14:51:31 naddy Exp $	 */
d1739 1
a1739 1
		tt = time((time_t *)NULL);
d1744 1
a1744 1
		tt = time((time_t *)NULL);
@


1.94
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.93 2011/04/06 11:36:25 miod Exp $	 */
a34 1
#include <sys/param.h>
@


1.93
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.92 2010/09/22 13:45:16 mikeb Exp $	 */
d299 1
a299 1
				case IPSEC_ESP_AES_128_CTR:
@


1.92
log
@Support for use of AES-GCM-16 (as AESGCM) and ENCR_NULL_AUTH_AES_GMAC
(as AESGMAC) ciphers in the ISAKMP Phase 2 (aka Quick Mode).

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.91 2007/08/05 09:43:09 tom Exp $	 */
d1740 1
a1740 1
		tt = time((time_t)NULL);
d1745 1
a1745 1
		tt = time((time_t)NULL);
@


1.91
log
@Allow key exchange with RSA signature authentication to work with
Cisco IOS and other initiators that only send their certs in response
to CERT_REQUEST.

With input and help from cloder@@, Stuart Henderson, mpf@@, and several
others who did lots of testing - thanks to all.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.90 2007/04/16 13:01:39 moritz Exp $	 */
d300 2
@


1.90
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.89 2007/03/03 18:47:37 cloder Exp $	 */
d2099 2
a2100 2
void *
keynote_certreq_decode(u_int8_t *data, u_int32_t len)
d2103 1
a2103 1
	return NULL;
d2304 7
@


1.89
log
@keynote_cert_obtain should not leak in case of error. OK moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.88 2006/06/17 10:06:21 hshoexer Exp $	 */
d191 7
a197 12
		if (remote_filter != 0) {
			free(remote_filter);
			remote_filter = 0;
		}
		if (local_filter != 0) {
			free(local_filter);
			local_filter = 0;
		}
		if (remote_id != 0) {
			free(remote_id);
			remote_id = 0;
		}
d1983 1
a1983 1
			if (policy_asserts && policy_asserts[fd])
@


1.88
log
@Do not leak file descriptor in error path.  From Andrey Matveev
<evol at online dot ptt dot ru>, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.87 2005/11/14 23:25:11 deraadt Exp $	 */
d2211 2
@


1.87
log
@use snprintf; ok cloder.  also looked at by a few other people
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.86 2005/06/14 10:50:47 hshoexer Exp $	 */
d2203 1
@


1.86
log
@add ENCAP_UDP_{TUNNEL,TRANSPORT} types according to rfc 3947

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.85 2005/04/08 22:32:10 cloder Exp $	 */
d2151 2
a2152 2
		file = calloc(len + strlen(addr_str), sizeof(char));
		if (file == NULL) {
a2158 2
		snprintf(file, len + strlen(addr_str), "%s/%s/%s", dirname,
		    addr_str, CREDENTIAL_FILE);
d2163 7
a2169 13
	case IPSEC_ID_USER_FQDN: {
			file = calloc(len + id_len, sizeof(char));
			if (file == NULL) {
				log_error("keynote_cert_obtain: "
				    "failed to allocate %lu bytes",
				    (unsigned long)len + id_len);
				return 0;
			}
			snprintf(file, len + id_len, "%s/", dirname);
			memcpy(file + strlen(dirname) + 1, id, id_len);
			snprintf(file + strlen(dirname) + 1 + id_len,
			    len - strlen(dirname) - 1, "/%s", CREDENTIAL_FILE);
			break;
d2171 5
@


1.85
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.84 2005/04/08 18:39:04 deraadt Exp $	 */
d516 3
a518 1
					    IPSEC_ENCAP_UDP_ENCAP_TUNNEL)
@


1.84
log
@we have IPPROTO_ETHERIP
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.83 2005/04/08 16:37:15 deraadt Exp $	 */
a52 2

#include "sysdep.h"
@


1.83
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.82 2005/04/06 16:00:20 deraadt Exp $	 */
a961 1
#ifdef IPPROTO_ETHERIP
a964 1
#endif
a1269 1
#ifdef IPPROTO_ETHERIP
a1272 1
#endif
a1591 1
#ifdef IPPROTO_ETHERIP
a1594 1
#endif
@


1.82
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.81 2005/04/04 19:31:11 deraadt Exp $	 */
d517 2
a518 2
#if defined (USE_NAT_TRAVERSAL)
					else if (decode_16(value) == IPSEC_ENCAP_UDP_ENCAP_TUNNEL)
a532 1
#endif
@


1.81
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.80 2005/03/03 15:06:55 hshoexer Exp $	 */
d181 2
a182 2
	if (strcmp(name, KEYNOTE_CALLBACK_CLEANUP) == 0
	    || strcmp(name, KEYNOTE_CALLBACK_INITIALIZE) == 0) {
@


1.80
log
@handle return value of snprintf more carefully

ok cloder ho
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.79 2005/02/27 13:12:12 hshoexer Exp $	 */
d431 1
a431 1
								     decode_16(value));
d716 1
a716 1
				      sizeof remote_id_addr_upper - 1, 1);
d718 1
a718 1
				      sizeof remote_id_addr_lower - 1, 1);
d925 2
a926 2
			     i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
			     i++)
d940 1
a940 1
			     i++) {
d1234 1
a1234 1
				     i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
d1246 2
a1247 2
				     i < idremotesz - ISAKMP_ID_DATA_OFF;
				     i++) {
d1310 1
a1310 1
			       sizeof remote_filter_addr_upper);
d1312 1
a1312 1
			       sizeof remote_filter_addr_lower);
d1330 1
a1330 1
				     sizeof local_filter_addr_upper - 1, 1);
d1332 1
a1332 1
				     sizeof local_filter_addr_upper - 1, 1);
d1347 1
a1347 1
				     sizeof local_filter_addr_lower - 1, 1);
d1351 1
a1351 1
				     sizeof local_filter_addr_upper - 1, 1);
d1376 1
a1376 1
				     sizeof local_filter_addr_lower - 1, 1);
d1379 3
a1381 3
				     sizeof local_filter_addr_upper - 1, 1);
				len = strlen(local_filter_addr_upper)
					+ strlen(local_filter_addr_lower) + 2;
d1399 2
a1400 2
					      local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);
d1417 2
a1418 2
					      local_filter_addr_lower,
					sizeof local_filter_addr_lower - 1);
d1502 1
a1502 2
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF]
				    = '\0';
d1519 1
a1519 2
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF]
				    = '\0';
d1550 1
a1550 1
						ISAKMP_ID_DATA_OFF) + 1,
d1559 1
a1559 1
				     i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
d1571 7
a1577 7
				     i < idlocalsz - ISAKMP_ID_DATA_OFF; i++) {
					local_filter[2 * i]
					    = hextab[*(idlocal +
						ISAKMP_ID_DATA_OFF) >> 4];
					local_filter[2 * i + 1]
					    = hextab[*(idlocal +
						ISAKMP_ID_DATA_OFF) & 0xF];
@


1.79
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.78 2004/08/08 19:11:06 deraadt Exp $	 */
d90 1
d97 1
a97 1
	if (snprintf(tmp, sizeof tmp, fmt, ((u_int8_t *)&src2)[0],
d99 2
a100 1
	    ((u_int8_t *)&src2)[3]) > (int)size) {
d114 1
d116 1
a116 1
	if (snprintf(tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3],
d118 2
a119 1
	    src[12], src[13], src[14], src[15]) > (int)size) {
@


1.78
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.77 2004/06/25 20:25:34 hshoexer Exp $	 */
d201 15
a215 15
		memset(remote_ike_address, 0, sizeof remote_ike_address);
		memset(local_ike_address, 0, sizeof local_ike_address);
		memset(ah_life_kbytes, 0, sizeof ah_life_kbytes);
		memset(ah_life_seconds, 0, sizeof ah_life_seconds);
		memset(esp_life_kbytes, 0, sizeof esp_life_kbytes);
		memset(esp_life_seconds, 0, sizeof esp_life_seconds);
		memset(comp_life_kbytes, 0, sizeof comp_life_kbytes);
		memset(comp_life_seconds, 0, sizeof comp_life_seconds);
		memset(ah_key_length, 0, sizeof ah_key_length);
		memset(ah_key_rounds, 0, sizeof ah_key_rounds);
		memset(esp_key_length, 0, sizeof esp_key_length);
		memset(esp_key_rounds, 0, sizeof esp_key_rounds);
		memset(comp_dict_size, 0, sizeof comp_dict_size);
		memset(comp_private_alg, 0, sizeof comp_private_alg);
		memset(remote_filter_addr_upper, 0,
d217 1
a217 1
		memset(remote_filter_addr_lower, 0,
d219 1
a219 1
		memset(local_filter_addr_upper, 0,
d221 1
a221 1
		memset(local_filter_addr_lower, 0,
d223 8
a230 8
		memset(remote_id_addr_upper, 0, sizeof remote_id_addr_upper);
		memset(remote_id_addr_lower, 0, sizeof remote_id_addr_lower);
		memset(ah_group_desc, 0, sizeof ah_group_desc);
		memset(esp_group_desc, 0, sizeof esp_group_desc);
		memset(remote_id_port, 0, sizeof remote_id_port);
		memset(remote_filter_port, 0, sizeof remote_filter_port);
		memset(local_filter_port, 0, sizeof local_filter_port);
		memset(phase1_group, 0, sizeof phase1_group);
@


1.77
log
@Keynote policy checking can now be disabled by "-K" switch and config tag
"Use-Keynote".  Default is to use keynote.

ok henning@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.76 2004/06/24 15:58:58 hshoexer Exp $	 */
d1176 1
a1176 1
				remote_filter = malloc(idremotesz - 
d1214 1
a1214 1
					= calloc(2 * (idremotesz - 
d1220 1
a1220 1
					    2 * ((unsigned long)idremotesz - 
d1486 1
a1486 1
				local_filter = malloc(idlocalsz - 
d1556 1
a1556 1
				for (i = 0; 
d1746 1
a1746 1
	
@


1.76
log
@Also handle keys from x509-certificates embedded in keynote credentials.

with msf@@
ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.75 2004/06/20 15:24:05 ho Exp $	 */
d70 1
d1941 5
@


1.75
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.74 2004/06/14 09:55:42 ho Exp $	 */
d2267 2
a2268 1
		if (kl->key_alg == KEYNOTE_ALGORITHM_RSA) {
@


1.74
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.73 2004/05/23 18:17:56 hshoexer Exp $	 */
d512 17
@


1.73
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.72 2004/05/23 16:14:22 deraadt Exp $	 */
d148 6
a153 4
	static char     comp_life_seconds[PMAX], *ah_encapsulation, *esp_encapsulation;
	static char    *comp_encapsulation, ah_key_length[PMAX], esp_key_length[PMAX];
	static char     ah_key_rounds[PMAX], esp_key_rounds[PMAX], comp_dict_size[PMAX];
	static char     comp_private_alg[PMAX], *remote_filter_type, *local_filter_type;
d158 2
a159 2
	static char     ah_group_desc[PMAX], esp_group_desc[PMAX], comp_group_desc[PMAX];
	static char     remote_ike_address[NI_MAXHOST];
d161 2
a162 3
	static char    *remote_id_type, remote_id_addr_upper[NI_MAXHOST],
	               *phase_1;
	static char     remote_id_addr_lower[NI_MAXHOST];
d165 3
a167 4
	static char    *remote_filter_proto, *local_filter_proto, *pfs,
	               *initiator;
	static char     remote_filter_proto_num[3], local_filter_proto_num[3];
	static char     remote_id_proto_num[3];
d182 2
a183 1
		esp_encapsulation = comp_encapsulation = remote_filter_type = "";
d185 2
a186 1
		remote_filter_proto = local_filter_proto = remote_id_proto = "";
d651 2
a652 1
		policy_sa->transport->vtbl->get_src(policy_sa->transport, &sin);
d660 2
a661 1
		policy_sa->transport->vtbl->get_dst(policy_sa->transport, &sin);
d691 2
a692 1
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
d699 2
a700 1
				log_error("policy_callback: strdup (\"%s\") failed",
d709 2
a710 1
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
d713 2
a714 1
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
d721 3
a723 2
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
d734 4
a737 2
			net = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
			subnet = decode_32(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
d748 3
a750 2
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
d766 2
a767 1
				log_error("policy_callback: strdup (\"%s\") failed",
d780 2
a781 2
			my_inet_ntop6(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
			    remote_id_addr_upper,
d788 3
a790 2
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
d806 2
a807 2
			bcopy(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16, &mask,
			    sizeof(mask));
d812 2
a813 1
			my_inet_ntop6((unsigned char *)&net, remote_id_addr_lower,
d819 2
a820 1
			my_inet_ntop6((unsigned char *)&net, remote_id_addr_upper,
d827 3
a829 2
				log_error("policy_callback: calloc (%d, %lu) failed",
				    len, (unsigned long)sizeof(char));
d843 2
a844 1
				log_error("policy_callback: calloc (%lu, %lu) failed",
d850 2
a851 1
			memcpy(remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d860 2
a861 1
				log_error("policy_callback: calloc (%lu, %lu) failed",
d867 2
a868 1
			memcpy(remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d894 2
a895 1
				log_error("policy_callback: calloc (%lu, %lu) failed",
d897 1
a897 1
				    ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
d902 3
a904 1
			for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++)
d911 2
a912 1
				    id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
d917 2
a918 1
			    i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++) {
d927 2
a928 1
			log_print("policy_callback: unknown remote ID type %u", id[0]);
d948 2
a949 1
			snprintf(remote_id_proto_num, sizeof remote_id_proto_num, "%d",
d983 2
a984 1
				remote_filter = strdup(remote_filter_addr_upper);
d999 2
a1000 1
				net = decode_32(idremote + ISAKMP_ID_DATA_OFF + 4);
d1012 2
a1013 1
				strlcpy(remote_filter, remote_filter_addr_lower, len);
d1015 2
a1016 1
				strlcat(remote_filter, remote_filter_addr_upper, len);
d1023 2
a1024 1
				subnet = decode_32(idremote + ISAKMP_ID_DATA_OFF + 4);
d1040 2
a1041 1
				strlcpy(remote_filter, remote_filter_addr_lower, len);
d1043 2
a1044 1
				strlcat(remote_filter, remote_filter_addr_upper, len);
d1055 2
a1056 1
				remote_filter = strdup(remote_filter_addr_upper);
d1072 2
a1073 2
				my_inet_ntop6(idremote + ISAKMP_ID_DATA_OFF + 16,
				    remote_filter_addr_upper,
d1085 2
a1086 1
				strlcpy(remote_filter, remote_filter_addr_lower, len);
d1088 2
a1089 1
				strlcat(remote_filter, remote_filter_addr_upper, len);
d1098 4
a1101 2
					bcopy(idremote + ISAKMP_ID_DATA_OFF, &net, sizeof(net));
					bcopy(idremote + ISAKMP_ID_DATA_OFF + 16, &mask, sizeof(mask));
d1104 2
a1105 1
						net.s6_addr[i] &= mask.s6_addr[i];
d1107 2
a1108 1
					my_inet_ntop6((unsigned char *)&net, remote_filter_addr_lower,
d1112 2
a1113 1
						net.s6_addr[i] |= ~mask.s6_addr[i];
d1115 2
a1116 1
					my_inet_ntop6((unsigned char *)&net, remote_filter_addr_upper,
d1121 2
a1122 1
					remote_filter = calloc(len, sizeof(char));
d1124 4
a1127 2
						log_error("policy_callback: calloc (%d, %lu) failed", len,
							  (unsigned long)sizeof(char));
d1130 2
a1131 1
					strlcpy(remote_filter, remote_filter_addr_lower, len);
d1133 2
a1134 1
					strlcat(remote_filter, remote_filter_addr_upper, len);
d1140 2
a1141 1
				remote_filter = malloc(idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1143 4
a1146 2
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1149 5
a1153 3
				memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
				       idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
d1158 2
a1159 1
				remote_filter = malloc(idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1161 4
a1164 2
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1167 5
a1171 3
				memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
				       idremotesz - ISAKMP_ID_DATA_OFF);
				remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
d1177 3
a1179 2
				remote_filter = x509_DN_string(idremote + ISAKMP_ID_DATA_OFF,
					   idremotesz - ISAKMP_ID_DATA_OFF);
d1182 2
a1183 1
						 "policy_callback: failed to decode name"));
d1196 3
a1198 2
					= calloc(2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1,
						 sizeof(char));
d1200 5
a1204 3
					log_error("policy_callback: calloc (%lu, %lu) failed",
						  2 * ((unsigned long)idremotesz - ISAKMP_ID_DATA_OFF) + 1,
					      (unsigned long)sizeof(char));
d1211 4
a1214 2
				for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idremote + ISAKMP_ID_DATA_OFF + i)))
d1217 3
a1219 2
					memcpy(remote_filter, idremote + ISAKMP_ID_DATA_OFF,
					   idremotesz - ISAKMP_ID_DATA_OFF);
d1223 3
a1225 1
				for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++) {
d1227 2
a1228 1
						= hextab[*(idremote + ISAKMP_ID_DATA_OFF) >> 4];
d1230 2
a1231 1
						= hextab[*(idremote + ISAKMP_ID_DATA_OFF) & 0xF];
d1236 3
a1238 2
				log_print("policy_callback: unknown Remote ID type %u",
					  GET_ISAKMP_ID_TYPE(idremote));
d1259 2
a1260 2
				       sizeof remote_filter_proto_num, "%d",
					 idremote[ISAKMP_GEN_SZ + 1]);
d1265 2
a1266 2
			snprintf(remote_filter_port, sizeof remote_filter_port, "%u",
				 decode_16(idremote + ISAKMP_GEN_SZ + 2));
d1277 3
a1279 2
				log_print("policy_callback: unsupported protocol family %d",
					  sin->sa_family);
d1283 2
a1284 1
				log_error("policy_callback: sockaddr2text failed");
d1294 3
a1296 2
				log_error("policy_callback: strdup (\"%s\") failed",
					  remote_filter_addr_upper);
d1313 3
a1315 2
					log_error("policy_callback: strdup (\"%s\") failed",
						  local_filter_addr_upper);
d1326 2
a1327 1
				net = decode_32(idlocal + ISAKMP_ID_DATA_OFF + 4);
d1334 3
a1336 2
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
d1339 2
a1340 1
				strlcpy(local_filter, local_filter_addr_lower, len);
d1342 2
a1343 1
				strlcat(local_filter, local_filter_addr_upper, len);
d1350 2
a1351 1
				subnet = decode_32(idlocal + ISAKMP_ID_DATA_OFF + 4);
d1362 3
a1364 2
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
d1367 2
a1368 1
				strlcpy(local_filter, local_filter_addr_lower, len);
d1370 2
a1371 1
				strlcat(local_filter, local_filter_addr_upper, len);
d1379 3
a1381 2
				strlcpy(local_filter_addr_lower, local_filter_addr_upper,
					sizeof local_filter_addr_lower);
d1384 3
a1386 2
					log_error("policy_callback: strdup (\"%s\") failed",
						  local_filter_addr_upper);
d1398 3
a1400 3
				my_inet_ntop6(idlocal + ISAKMP_ID_DATA_OFF + 16,
					      local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);
d1406 3
a1408 2
					log_error("policy_callback: calloc (%d, %lu) failed", len,
					      (unsigned long)sizeof(char));
d1411 2
a1412 1
				strlcpy(local_filter, local_filter_addr_lower, len);
d1414 2
a1415 1
				strlcat(local_filter, local_filter_addr_upper, len);
d1424 4
a1427 2
					bcopy(idlocal + ISAKMP_ID_DATA_OFF, &net, sizeof(net));
					bcopy(idlocal + ISAKMP_ID_DATA_OFF + 16, &mask, sizeof(mask));
d1430 2
a1431 1
						net.s6_addr[i] &= mask.s6_addr[i];
d1433 2
a1434 1
					my_inet_ntop6((unsigned char *)&net, local_filter_addr_lower,
d1438 2
a1439 1
						net.s6_addr[i] |= ~mask.s6_addr[i];
d1441 4
a1444 2
					my_inet_ntop6((unsigned char *)&net, local_filter_addr_upper,
					sizeof local_filter_addr_upper - 1);
d1447 4
a1450 2
						+ strlen(local_filter_addr_lower) + 2;
					local_filter = calloc(len, sizeof(char));
d1452 4
a1455 2
						log_error("policy_callback: calloc (%d, %lu) failed", len,
							  (unsigned long)sizeof(char));
d1458 2
a1459 1
					strlcpy(local_filter, local_filter_addr_lower, len);
d1461 2
a1462 1
					strlcat(local_filter, local_filter_addr_upper, len);
d1468 2
a1469 1
				local_filter = malloc(idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1471 4
a1474 2
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1477 5
a1481 3
				memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
				       idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
d1486 2
a1487 1
				local_filter = malloc(idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1489 4
a1492 2
					log_error("policy_callback: malloc (%lu) failed",
						  (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1495 5
a1499 3
				memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
				       idlocalsz - ISAKMP_ID_DATA_OFF);
				local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
d1505 3
a1507 2
				local_filter = x509_DN_string(idlocal + ISAKMP_ID_DATA_OFF,
					    idlocalsz - ISAKMP_ID_DATA_OFF);
d1510 2
a1511 1
						 "policy_callback: failed to decode name"));
d1523 3
a1525 2
				local_filter = calloc(2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
						      sizeof(char));
d1527 5
a1531 3
					log_error("policy_callback: calloc (%lu, %lu) failed",
						  2 * ((unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
					      (unsigned long)sizeof(char));
d1538 4
a1541 2
				for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
					if (!isprint(*(idlocal + ISAKMP_ID_DATA_OFF + i)))
d1544 2
a1545 1
					memcpy(local_filter, idlocal + ISAKMP_ID_DATA_OFF,
d1550 2
a1551 1
				for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++) {
d1553 2
a1554 1
						= hextab[*(idlocal + ISAKMP_ID_DATA_OFF) >> 4];
d1556 2
a1557 1
						= hextab[*(idlocal + ISAKMP_ID_DATA_OFF) & 0xF];
d1562 3
a1564 2
				log_print("policy_callback: unknown Local ID type %u",
					  GET_ISAKMP_ID_TYPE(idlocal));
d1584 3
a1586 2
				snprintf(local_filter_proto_num, sizeof local_filter_proto_num,
					 "%d", idlocal[ISAKMP_GEN_SZ + 1]);
d1591 2
a1592 2
			snprintf(local_filter_port, sizeof local_filter_port, "%u",
				 decode_16(idlocal + ISAKMP_GEN_SZ + 2));
d1595 1
a1595 1
						(struct sockaddr **)&sin);
d1604 3
a1606 2
				log_print("policy_callback: unsupported protocol family %d",
					  sin->sa_family);
d1611 2
a1612 1
				log_error("policy_callback: sockaddr2text failed");
d1616 1
a1616 1
			       sizeof local_filter_addr_upper);
d1618 1
a1618 1
			       sizeof local_filter_addr_lower);
d1622 3
a1624 2
				log_error("policy_callback: strdup (\"%s\") failed",
					  local_filter_addr_upper);
d1629 2
a1630 1
		LOG_DBG((LOG_POLICY, 80, "Policy context (action attributes):"));
d1639 16
a1654 8
		LOG_DBG((LOG_POLICY, 80, "ah_life_seconds == %s", ah_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "ah_life_kbytes == %s", ah_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "esp_life_seconds == %s", esp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "esp_life_kbytes == %s", esp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "comp_life_seconds == %s", comp_life_seconds));
		LOG_DBG((LOG_POLICY, 80, "comp_life_kbytes == %s", comp_life_kbytes));
		LOG_DBG((LOG_POLICY, 80, "ah_encapsulation == %s", ah_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "esp_encapsulation == %s", esp_encapsulation));
d1656 19
a1674 10
			 comp_encapsulation));
		LOG_DBG((LOG_POLICY, 80, "comp_dict_size == %s", comp_dict_size));
		LOG_DBG((LOG_POLICY, 80, "comp_private_alg == %s", comp_private_alg));
		LOG_DBG((LOG_POLICY, 80, "ah_key_length == %s", ah_key_length));
		LOG_DBG((LOG_POLICY, 80, "ah_key_rounds == %s", ah_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "esp_key_length == %s", esp_key_length));
		LOG_DBG((LOG_POLICY, 80, "esp_key_rounds == %s", esp_key_rounds));
		LOG_DBG((LOG_POLICY, 80, "ah_group_desc == %s", ah_group_desc));
		LOG_DBG((LOG_POLICY, 80, "esp_group_desc == %s", esp_group_desc));
		LOG_DBG((LOG_POLICY, 80, "comp_group_desc == %s", comp_group_desc));
d1679 1
a1679 1
			 remote_filter_type));
d1681 1
a1681 1
			 remote_filter_addr_upper));
d1683 1
a1683 1
			 remote_filter_addr_lower));
d1685 1
a1685 1
			 (remote_filter ? remote_filter : "")));
d1687 1
a1687 1
			 remote_filter_port));
d1689 3
a1691 2
			 remote_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "local_filter_type == %s", local_filter_type));
d1693 1
a1693 1
			 local_filter_addr_upper));
d1695 1
a1695 1
			 local_filter_addr_lower));
d1697 3
a1699 2
			 (local_filter ? local_filter : "")));
		LOG_DBG((LOG_POLICY, 80, "local_filter_port == %s", local_filter_port));
d1701 3
a1703 2
			 local_filter_proto));
		LOG_DBG((LOG_POLICY, 80, "remote_id_type == %s", remote_id_type));
d1705 1
a1705 1
			 remote_id_addr_upper));
d1707 1
a1707 1
			 remote_id_addr_lower));
d1709 5
a1713 3
			 (remote_id ? remote_id : "")));
		LOG_DBG((LOG_POLICY, 80, "remote_id_port == %s", remote_id_port));
		LOG_DBG((LOG_POLICY, 80, "remote_id_proto == %s", remote_id_proto));
d1715 1
a1715 1
			 remote_ike_address));
d1717 1
a1717 1
			 local_ike_address));
d1720 2
a1721 1
		LOG_DBG((LOG_POLICY, 80, "phase1_group_desc == %s", phase1_group));
d1728 1
a1728 1

d1932 2
a1933 1
		log_fatal("policy_init: open (\"%s\", O_RDONLY) failed", policy_file);
d2150 2
a2151 1
				log_error("keynote_cert_obtain: failed to allocate %lu bytes",
d2168 2
a2169 2
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to open \"%s\"",
		    file));
d2175 2
a2176 2
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to stat \"%s\"",
		    file));
d2192 3
a2194 2
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to read %lu "
		    "bytes from \"%s\"", (unsigned long)size, file));
d2223 2
a2224 1
		log_print("keynote_cert_get_key: failed to decompose credentials");
d2229 2
a2230 2
		log_print("keynote_cert_get_key: failed to initialize new policy "
		    "session");
@


1.72
log
@stat before open is flawed
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.71 2004/04/28 20:20:31 hshoexer Exp $	 */
d84 1
a84 1
my_inet_ntop4(const in_addr_t * src, char *dst, size_t size, int normalize)
d110 1
a110 1
	char            tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];
d112 2
a113 2
	if (snprintf(tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3], src[4],
	    src[5], src[6], src[7], src[8], src[9], src[10], src[11],
d212 8
a219 4
		memset(remote_filter_addr_upper, 0, sizeof remote_filter_addr_upper);
		memset(remote_filter_addr_lower, 0, sizeof remote_filter_addr_lower);
		memset(local_filter_addr_upper, 0, sizeof local_filter_addr_upper);
		memset(local_filter_addr_lower, 0, sizeof local_filter_addr_lower);
d243 2
a244 1
		snprintf(phase1_group, sizeof phase1_group, "%u", is->group_desc);
d361 2
a362 1
			for (attr = proto->chosen->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF;
d374 2
a375 1
				value = attr + (fmt ? ISAKMP_ATTR_LENGTH_VALUE_OFF :
d1791 2
a1792 2
		log_fatal("policy_init: calloc (%lu, %lu) failed", (unsigned long)sz + 1,
			  (unsigned long)sizeof(char));
d1798 2
a1799 2
			log_fatal("policy_init: read (%d, %p, %lu) failed", fd, ptr + len,
				  (unsigned long)(sz - len));
d1835 1
a1835 1
keynote_cert_get(u_int8_t * data, u_int32_t len)
d1837 1
a1837 1
	char           *foo = malloc(len + 1);
d1854 2
a1855 2
	char          **foo;
	int             num, i;
d1883 2
a1884 2
	char          **foo;
	int             num;
d1908 1
a1908 1
keynote_certreq_validate(u_int8_t * data, u_int32_t len)
d1911 2
a1912 2
	int             err = 1;
	char           *dat;
d1916 2
a1917 2
		log_error("keynote_certreq_validate: calloc (%d, %lu) failed", len + 1,
			  (unsigned long)sizeof(char));
d1933 2
a1934 2
void           *
keynote_certreq_decode(u_int8_t * data, u_int32_t len)
d1947 2
a1948 2
keynote_cert_obtain(u_int8_t * id, size_t id_len, void *data, u_int8_t ** cert,
		    u_int32_t * certlen)
d1975 2
a1976 2
		util_ntoa(&addr_str, idtype == IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
			  id);
d1982 3
a1984 2
			log_error("keynote_cert_obtain: failed to allocate %lu bytes",
				  (unsigned long)len + strlen(addr_str));
d1988 2
a1989 2
		snprintf(file, len + strlen(addr_str), "%s/%s/%s", dirname, addr_str,
		    CREDENTIAL_FILE);
d1994 1
a1994 2
	case IPSEC_ID_USER_FQDN:
		{
@


1.71
log
@remove unused variable and shorten names of two other.  Removed some spaces
while around.

ok ho@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.70 2004/04/15 18:39:26 deraadt Exp $	 */
a1769 4
	/* Check file modes and collect file size */
	if (check_file_secrecy(policy_file, &sz))
		log_fatal("policy_init: cannot read %s", policy_file);

d1775 6
d2005 9
a2013 1
	if (monitor_stat(file, &sb) < 0) {
d2017 1
d2029 1
a2029 7
	fd = monitor_open(file, O_RDONLY, 0);
	if (fd < 0) {
		LOG_DBG((LOG_POLICY, 30, "keynote_cert_obtain: failed to open \"%s\"",
		    file));
		free(file);
		return 0;
	}
@


1.70
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: policy.c,v 1.69 2004/04/07 22:45:49 ho Exp $	 */
d69 2
a70 2
char          **keynote_policy_asserts = NULL;
int             keynote_policy_asserts_num = 0;
d95 3
a97 3
	if (snprintf(tmp, sizeof tmp, fmt, ((u_int8_t *) & src2)[0],
	    ((u_int8_t *) & src2)[1], ((u_int8_t *) & src2)[2],
	    ((u_int8_t *) & src2)[3]) > (int) size) {
d114 1
a114 1
	    src[12], src[13], src[14], src[15]) > (int) size) {
d707 1
a707 1
				    len, (unsigned long) sizeof(char));
d731 1
a731 1
				    len, (unsigned long) sizeof(char));
d769 1
a769 1
				    len, (unsigned long) sizeof(char));
d791 1
a791 1
			my_inet_ntop6((unsigned char *) &net, remote_id_addr_lower,
d797 1
a797 1
			my_inet_ntop6((unsigned char *) &net, remote_id_addr_upper,
d805 1
a805 1
				    len, (unsigned long) sizeof(char));
d820 1
a820 1
				    (unsigned long) id_sz - ISAKMP_ID_DATA_OFF +
d822 1
a822 1
				    (unsigned long) sizeof(char));
d835 1
a835 1
				    (unsigned long) id_sz - ISAKMP_ID_DATA_OFF +
d837 1
a837 1
				    (unsigned long) sizeof(char));
d867 1
a867 1
				    2 * ((unsigned long) id_sz -
d869 1
a869 1
				    (unsigned long) sizeof(char));
d972 1
a972 1
					    (unsigned long) sizeof(char));
d997 1
a997 1
					    (unsigned long) sizeof(char));
d1039 1
a1039 1
					    (unsigned long) sizeof(char));
d1059 1
a1059 1
					my_inet_ntop6((unsigned char *) &net, remote_filter_addr_lower,
d1065 1
a1065 1
					my_inet_ntop6((unsigned char *) &net, remote_filter_addr_upper,
d1073 1
a1073 1
							  (unsigned long) sizeof(char));
d1087 1
a1087 1
						  (unsigned long) idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1100 1
a1100 1
						  (unsigned long) idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1132 2
a1133 2
						  2 * ((unsigned long) idremotesz - ISAKMP_ID_DATA_OFF) + 1,
					      (unsigned long) sizeof(char));
d1251 1
a1251 1
					      (unsigned long) sizeof(char));
d1275 1
a1275 1
					      (unsigned long) sizeof(char));
d1314 1
a1314 1
					      (unsigned long) sizeof(char));
d1334 1
a1334 1
					my_inet_ntop6((unsigned char *) &net, local_filter_addr_lower,
d1340 1
a1340 1
					my_inet_ntop6((unsigned char *) &net, local_filter_addr_upper,
d1348 1
a1348 1
							  (unsigned long) sizeof(char));
d1362 1
a1362 1
						  (unsigned long) idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1375 1
a1375 1
						  (unsigned long) idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1406 2
a1407 2
						  2 * ((unsigned long) idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
					      (unsigned long) sizeof(char));
d1463 1
a1463 1
						(struct sockaddr **) & sin);
d1571 1
a1571 1
		tt = time((time_t) NULL);
d1576 1
a1576 1
		tt = time((time_t) NULL);
d1782 2
a1783 2
		log_fatal("policy_init: calloc (%lu, %lu) failed", (unsigned long) sz + 1,
			  (unsigned long) sizeof(char));
d1790 1
a1790 1
				  (unsigned long) (sz - len));
d1802 1
a1802 1
	if (asserts == (char **) NULL)
d1806 4
a1809 4
	if (keynote_policy_asserts) {
		for (fd = 0; fd < keynote_policy_asserts_num; fd++)
			if (keynote_policy_asserts && keynote_policy_asserts[fd])
				free(keynote_policy_asserts[fd]);
d1811 1
a1811 1
		free(keynote_policy_asserts);
d1813 2
a1814 2
	keynote_policy_asserts = asserts;
	keynote_policy_asserts_num = i;
d1851 1
a1851 1
	foo = kn_read_asserts((char *) scert, strlen((char *) scert), &num);
d1856 1
a1856 1
		if (kn_verify_assertion(scert, strlen((char *) scert))
d1880 1
a1880 1
	foo = kn_read_asserts((char *) scert, strlen((char *) scert), &num);
d1908 1
a1908 1
			  (unsigned long) sizeof(char));
d1974 1
a1974 1
				  (unsigned long) len + strlen(addr_str));
d1989 1
a1989 1
				    (unsigned long) len + id_len);
d2009 1
a2009 1
	size = (size_t) sb.st_size;
d2014 1
a2014 1
		    (unsigned long) size);
d2025 1
a2025 1
	if (read(fd, *cert, size) != (int) size) {
d2027 1
a2027 1
		    "bytes from \"%s\"", (unsigned long) size, file));
d2054 1
a2054 1
	foo = kn_read_asserts((char *) scert, strlen((char *) scert), &num);
d2078 1
a2078 1
	*(RSA **) keyp = NULL;
d2083 1
a2083 1
			*(RSA **) keyp = RSAPublicKey_dup(kl->key_key);
d2091 1
a2091 1
	return *(RSA **) keyp == NULL ? 0 : 1;
d2097 1
a2097 1
	return strdup((char *) cert);
d2103 2
a2104 2
	*datalen = strlen((char *) cert) + 1;
	*data = (u_int8_t *) strdup(cert);	/* i.e an extra character at
d2114 1
a2114 1
	return strdup((char *) cert);
@


1.69
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.68 2004/03/19 14:04:43 hshoexer Exp $	*/
/*	$EOM: policy.c,v 1.49 2000/10/24 13:33:39 niklas Exp $ */
d69 2
a70 2
char **keynote_policy_asserts = NULL;
int keynote_policy_asserts_num = 0;
d72 2
a73 2
struct sa *policy_sa = 0;
struct sa *policy_isakmp_sa = 0;
d76 2
a77 2
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
d84 1
a84 1
my_inet_ntop4 (const in_addr_t *src, char *dst, size_t size, int normalize)
d86 17
a102 18
  static const char fmt[] = "%03u.%03u.%03u.%03u";
  char tmp[sizeof "255.255.255.255"];
  in_addr_t src2;

  if (normalize)
    src2 = ntohl (*src);
  else
    src2 = *src;

  if (snprintf (tmp, sizeof tmp, fmt, ((u_int8_t *) &src2)[0],
		((u_int8_t *) &src2)[1], ((u_int8_t *) &src2)[2],
		((u_int8_t *) &src2)[3]) > (int)size)
    {
      errno = ENOSPC;
      return 0;
    }
  strlcpy (dst, tmp, size);
  return dst;
d106 1
a106 1
my_inet_ntop6 (const unsigned char *src, char *dst, size_t size)
d108 12
a119 12
  static const char fmt[] = "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x";
  char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];

  if (snprintf (tmp, sizeof tmp, fmt, src[0], src[1], src[2], src[3], src[4],
		src[5], src[6], src[7], src[8], src[9], src[10], src[11],
		src[12], src[13], src[14], src[15]) > (int)size)
    {
      errno = ENOSPC;
      return 0;
    }
  strlcpy (dst, tmp, size);
  return dst;
d123 1
a123 1
policy_callback (char *name)
d125 1
a125 1
  struct proto *proto;
d127 12
a138 12
  u_int8_t *attr, *value, *id, *idlocal, *idremote;
  size_t id_sz, idlocalsz, idremotesz;
  struct sockaddr *sin;
  struct ipsec_exch *ie;
  struct ipsec_sa *is;
  size_t i;
  int fmt, lifetype = 0;
  in_addr_t net, subnet;
  u_int16_t len, type;
  time_t tt;
  char *addr;
  static char mytimeofday[15];
d140 1
a140 1
  /* We use all these as a cache.  */
d142 210
a351 143
  static char *esp_present, *ah_present, *comp_present;
  static char *ah_hash_alg, *ah_auth_alg, *esp_auth_alg, *esp_enc_alg;
  static char *comp_alg, ah_life_kbytes[PMAX], ah_life_seconds[PMAX];
  static char esp_life_kbytes[PMAX], esp_life_seconds[PMAX];
  static char comp_life_kbytes[PMAX];
  static char *ah_ecn, *esp_ecn, *comp_ecn;
  static char comp_life_seconds[PMAX], *ah_encapsulation, *esp_encapsulation;
  static char *comp_encapsulation, ah_key_length[PMAX], esp_key_length[PMAX];
  static char ah_key_rounds[PMAX], esp_key_rounds[PMAX], comp_dict_size[PMAX];
  static char comp_private_alg[PMAX], *remote_filter_type, *local_filter_type;
  static char remote_filter_addr_upper[NI_MAXHOST];
  static char remote_filter_addr_lower[NI_MAXHOST];
  static char local_filter_addr_upper[NI_MAXHOST];
  static char local_filter_addr_lower[NI_MAXHOST];
  static char ah_group_desc[PMAX], esp_group_desc[PMAX], comp_group_desc[PMAX];
  static char remote_ike_address[NI_MAXHOST];
  static char local_ike_address[NI_MAXHOST];
  static char *remote_id_type, remote_id_addr_upper[NI_MAXHOST], *phase_1;
  static char remote_id_addr_lower[NI_MAXHOST];
  static char *remote_id_proto, remote_id_port[PMAX];
  static char remote_filter_port[PMAX], local_filter_port[PMAX];
  static char *remote_filter_proto, *local_filter_proto, *pfs, *initiator;
  static char remote_filter_proto_num[3], local_filter_proto_num[3];
  static char remote_id_proto_num[3];
  static char phase1_group[PMAX];

  /* Allocated.  */
  static char *remote_filter = 0, *local_filter = 0, *remote_id = 0;

  static int dirty = 1;

  /* We only need to set dirty at initialization time really.  */
  if (strcmp (name, KEYNOTE_CALLBACK_CLEANUP) == 0
      || strcmp (name, KEYNOTE_CALLBACK_INITIALIZE) == 0)
    {
      esp_present = ah_present = comp_present = pfs = "no";
      ah_hash_alg = ah_auth_alg = phase_1 = "";
      esp_auth_alg = esp_enc_alg = comp_alg = ah_encapsulation = "";
      ah_ecn = esp_ecn = comp_ecn = "no";
      esp_encapsulation = comp_encapsulation = remote_filter_type = "";
      local_filter_type = remote_id_type = initiator = "";
      remote_filter_proto = local_filter_proto = remote_id_proto = "";

      if (remote_filter != 0)
        {
	  free (remote_filter);
	  remote_filter = 0;
	}

      if (local_filter != 0)
        {
	  free (local_filter);
	  local_filter = 0;
	}

      if (remote_id != 0)
        {
	  free (remote_id);
	  remote_id = 0;
	}

      memset (remote_ike_address, 0, sizeof remote_ike_address);
      memset (local_ike_address, 0, sizeof local_ike_address);
      memset (ah_life_kbytes, 0, sizeof ah_life_kbytes);
      memset (ah_life_seconds, 0, sizeof ah_life_seconds);
      memset (esp_life_kbytes, 0, sizeof esp_life_kbytes);
      memset (esp_life_seconds, 0, sizeof esp_life_seconds);
      memset (comp_life_kbytes, 0, sizeof comp_life_kbytes);
      memset (comp_life_seconds, 0, sizeof comp_life_seconds);
      memset (ah_key_length, 0, sizeof ah_key_length);
      memset (ah_key_rounds, 0, sizeof ah_key_rounds);
      memset (esp_key_length, 0, sizeof esp_key_length);
      memset (esp_key_rounds, 0, sizeof esp_key_rounds);
      memset (comp_dict_size, 0, sizeof comp_dict_size);
      memset (comp_private_alg, 0, sizeof comp_private_alg);
      memset (remote_filter_addr_upper, 0, sizeof remote_filter_addr_upper);
      memset (remote_filter_addr_lower, 0, sizeof remote_filter_addr_lower);
      memset (local_filter_addr_upper, 0, sizeof local_filter_addr_upper);
      memset (local_filter_addr_lower, 0, sizeof local_filter_addr_lower);
      memset (remote_id_addr_upper, 0, sizeof remote_id_addr_upper);
      memset (remote_id_addr_lower, 0, sizeof remote_id_addr_lower);
      memset (ah_group_desc, 0, sizeof ah_group_desc);
      memset (esp_group_desc, 0, sizeof esp_group_desc);
      memset (remote_id_port, 0, sizeof remote_id_port);
      memset (remote_filter_port, 0, sizeof remote_filter_port);
      memset (local_filter_port, 0, sizeof local_filter_port);
      memset (phase1_group, 0, sizeof phase1_group);

      dirty = 1;
      return "";
    }

  /*
   * If dirty is set, this is the first request for an attribute, so
   * populate our value cache.
   */
  if (dirty)
    {
      ie = policy_exchange->data;

      if (ie->pfs)
	pfs = "yes";

      is = policy_isakmp_sa->data;
      snprintf (phase1_group, sizeof phase1_group, "%u", is->group_desc);

      for (proto = TAILQ_FIRST (&policy_sa->protos); proto;
	   proto = TAILQ_NEXT (proto, link))
	{
	  switch (proto->proto)
	    {
	    case IPSEC_PROTO_IPSEC_AH:
	      ah_present = "yes";
	      switch (proto->id)
		{
		case IPSEC_AH_MD5:
		  ah_hash_alg = "md5";
		  break;

		case IPSEC_AH_SHA:
		  ah_hash_alg = "sha";
		  break;

		case IPSEC_AH_RIPEMD:
		  ah_hash_alg = "ripemd";
		  break;

		case IPSEC_AH_SHA2_256:
		  ah_auth_alg = "sha2-256";
		  break;

		case IPSEC_AH_SHA2_384:
		  ah_auth_alg = "sha2-384";
		  break;

		case IPSEC_AH_SHA2_512:
		  ah_auth_alg = "sha2-512";
		  break;

		case IPSEC_AH_DES:
		  ah_hash_alg = "des";
		  break;
		}
d353 2
a354 1
	      break;
d356 284
a639 52
	    case IPSEC_PROTO_IPSEC_ESP:
	      esp_present = "yes";
	      switch (proto->id)
		{
		case IPSEC_ESP_DES_IV64:
		  esp_enc_alg = "des-iv64";
		  break;

		case IPSEC_ESP_DES:
		  esp_enc_alg = "des";
		  break;

		case IPSEC_ESP_3DES:
		  esp_enc_alg = "3des";
		  break;

		case IPSEC_ESP_AES:
		case IPSEC_ESP_AES_128_CTR:
		  esp_enc_alg = "aes";
		  break;

		case IPSEC_ESP_RC5:
		  esp_enc_alg = "rc5";
		  break;

		case IPSEC_ESP_IDEA:
		  esp_enc_alg = "idea";
		  break;

		case IPSEC_ESP_CAST:
		  esp_enc_alg = "cast";
		  break;

		case IPSEC_ESP_BLOWFISH:
		  esp_enc_alg = "blowfish";
		  break;

		case IPSEC_ESP_3IDEA:
		  esp_enc_alg = "3idea";
		  break;

		case IPSEC_ESP_DES_IV32:
		  esp_enc_alg = "des-iv32";
		  break;

		case IPSEC_ESP_RC4:
		  esp_enc_alg = "rc4";
		  break;

		case IPSEC_ESP_NULL:
		  esp_enc_alg = "null";
		  break;
d642 20
a661 1
	      break;
d663 3
a665 19
	    case IPSEC_PROTO_IPCOMP:
	      comp_present = "yes";
	      switch (proto->id)
		{
		case IPSEC_IPCOMP_OUI:
		  comp_alg = "oui";
		  break;

		case IPSEC_IPCOMP_DEFLATE:
		  comp_alg = "deflate";
		  break;

		case IPSEC_IPCOMP_LZS:
		  comp_alg = "lzs";
		  break;

		case IPSEC_IPCOMP_V42BIS:
		  comp_alg = "v42bis";
		  break;
d668 24
a691 2
	      break;
	    }
d693 2
a694 9
	  for (attr = proto->chosen->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF;
	       attr
		 < proto->chosen->p + GET_ISAKMP_GEN_LENGTH (proto->chosen->p);
	       attr = value + len)
	    {
	      if (attr + ISAKMP_ATTR_VALUE_OFF
		  > (proto->chosen->p
		     + GET_ISAKMP_GEN_LENGTH (proto->chosen->p)))
		return "";
d696 18
a713 7
	      type = GET_ISAKMP_ATTR_TYPE (attr);
	      fmt = ISAKMP_ATTR_FORMAT (type);
	      type = ISAKMP_ATTR_TYPE (type);
	      value = attr + (fmt ? ISAKMP_ATTR_LENGTH_VALUE_OFF :
			      ISAKMP_ATTR_VALUE_OFF);
	      len = (fmt ? ISAKMP_ATTR_LENGTH_VALUE_LEN :
		     GET_ISAKMP_ATTR_LENGTH_VALUE (attr));
d715 2
a716 3
	      if (value + len > proto->chosen->p +
		  GET_ISAKMP_GEN_LENGTH (proto->chosen->p))
		return "";
d718 20
a737 5
	      switch (type)
		{
		case IPSEC_ATTR_SA_LIFE_TYPE:
		  lifetype = decode_16 (value);
		  break;
d739 11
a749 73
		case IPSEC_ATTR_SA_LIFE_DURATION:
		  switch (proto->proto)
		    {
		    case IPSEC_PROTO_IPSEC_AH:
		      if (lifetype == IPSEC_DURATION_SECONDS)
			{
			  if (len == 2)
			    snprintf (ah_life_seconds, sizeof ah_life_seconds,
				      "%u", decode_16 (value));
			  else
			    snprintf (ah_life_seconds, sizeof ah_life_seconds,
				      "%u", decode_32 (value));
			}
		      else
			{
			  if (len == 2)
			    snprintf (ah_life_kbytes, sizeof ah_life_kbytes,
				      "%u", decode_16 (value));
			  else
			    snprintf (ah_life_kbytes, sizeof ah_life_kbytes,
				      "%u", decode_32 (value));
			}

		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      if (lifetype == IPSEC_DURATION_SECONDS)
			{
			  if (len == 2)
			    snprintf (esp_life_seconds,
				      sizeof esp_life_seconds, "%u",
				      decode_16 (value));
			  else
			    snprintf (esp_life_seconds,
				      sizeof esp_life_seconds, "%u",
				      decode_32 (value));
			}
		      else
			{
			  if (len == 2)
			    snprintf (esp_life_kbytes,
				      sizeof esp_life_kbytes, "%u",
				      decode_16 (value));
			  else
			    snprintf (esp_life_kbytes,
				      sizeof esp_life_kbytes, "%u",
				      decode_32 (value));
			}

		      break;

		    case IPSEC_PROTO_IPCOMP:
		      if (lifetype == IPSEC_DURATION_SECONDS)
			{
			  if (len == 2)
			    snprintf (comp_life_seconds,
				      sizeof comp_life_seconds, "%u",
				      decode_16 (value));
			  else
			    snprintf (comp_life_seconds,
				      sizeof comp_life_seconds, "%u",
				      decode_32 (value));
			}
		      else
			{
			  if (len == 2)
			    snprintf (comp_life_kbytes,
				      sizeof comp_life_kbytes, "%u",
				      decode_16 (value));
			  else
			    snprintf (comp_life_kbytes,
				      sizeof comp_life_kbytes, "%u",
				      decode_32 (value));
d751 1
d753 23
a775 3
		      break;
		    }
		  break;
d777 1
a777 2
		case IPSEC_ATTR_GROUP_DESCRIPTION:
		  switch (proto->proto)
d779 33
a811 14
		    case IPSEC_PROTO_IPSEC_AH:
		      snprintf (ah_group_desc, sizeof ah_group_desc, "%u",
				decode_16 (value));
		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      snprintf (esp_group_desc, sizeof esp_group_desc, "%u",
			       decode_16 (value));
		      break;

		    case IPSEC_PROTO_IPCOMP:
		      snprintf (comp_group_desc, sizeof comp_group_desc, "%u",
			       decode_16 (value));
		      break;
a812 1
		  break;
d814 13
a826 6
		case IPSEC_ATTR_ECN_TUNNEL:
		  if (decode_16 (value))
		    switch (proto->proto)
		      {
		      case IPSEC_PROTO_IPSEC_AH:
			ah_ecn = "yes";
d829 13
a841 2
		      case IPSEC_PROTO_IPSEC_ESP:
			esp_ecn = "yes";
d844 11
a854 2
		      case IPSEC_PROTO_IPCOMP:
			comp_ecn = "yes";
a855 1
		      }
d857 2
a858 6
		case IPSEC_ATTR_ENCAPSULATION_MODE:
		  if (decode_16 (value) == IPSEC_ENCAP_TUNNEL)
		    switch (proto->proto)
		      {
		      case IPSEC_PROTO_IPSEC_AH:
			ah_encapsulation = "tunnel";
d861 30
a890 2
		      case IPSEC_PROTO_IPSEC_ESP:
			esp_encapsulation = "tunnel";
d893 8
a900 2
		      case IPSEC_PROTO_IPCOMP:
			comp_encapsulation = "tunnel";
d902 3
a904 6
		      }
		  else
		    switch (proto->proto)
		      {
		      case IPSEC_PROTO_IPSEC_AH:
			ah_encapsulation = "transport";
d907 3
a909 2
		      case IPSEC_PROTO_IPSEC_ESP:
			esp_encapsulation = "transport";
d911 1
d913 4
a916 2
		      case IPSEC_PROTO_IPCOMP:
			comp_encapsulation = "transport";
d918 1
a918 2
		      }
		  break;
d920 241
a1160 74
		case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
		  switch (proto->proto)
		    {
		    case IPSEC_PROTO_IPSEC_AH:
		      switch (decode_16 (value))
			{
			case IPSEC_AUTH_HMAC_MD5:
			  ah_auth_alg = "hmac-md5";
			  break;

			case IPSEC_AUTH_HMAC_SHA:
			  ah_auth_alg = "hmac-sha";
			  break;

			case IPSEC_AUTH_HMAC_RIPEMD:
			  ah_auth_alg = "hmac-ripemd";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_256:
			  ah_auth_alg = "hmac-sha2-256";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_384:
			  ah_auth_alg = "hmac-sha2-384";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_512:
			  ah_auth_alg = "hmac-sha2-512";
			  break;

			case IPSEC_AUTH_DES_MAC:
			  ah_auth_alg = "des-mac";
			  break;

			case IPSEC_AUTH_KPDK:
			  ah_auth_alg = "kpdk";
			  break;
			}
		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      switch (decode_16 (value))
			{
			case IPSEC_AUTH_HMAC_MD5:
			  esp_auth_alg = "hmac-md5";
			  break;

			case IPSEC_AUTH_HMAC_SHA:
			  esp_auth_alg = "hmac-sha";
			  break;

			case IPSEC_AUTH_HMAC_RIPEMD:
			  esp_auth_alg = "hmac-ripemd";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_256:
			  esp_auth_alg = "hmac-sha2-256";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_384:
			  esp_auth_alg = "hmac-sha2-384";
			  break;

			case IPSEC_AUTH_HMAC_SHA2_512:
			  esp_auth_alg = "hmac-sha2-512";
			  break;

			case IPSEC_AUTH_DES_MAC:
			  esp_auth_alg = "des-mac";
			  break;

			case IPSEC_AUTH_KPDK:
			  esp_auth_alg = "kpdk";
			  break;
a1161 3
		      break;
		    }
		  break;
d1163 14
a1176 14
		case IPSEC_ATTR_KEY_LENGTH:
		  switch (proto->proto)
		    {
		    case IPSEC_PROTO_IPSEC_AH:
		      snprintf (ah_key_length, sizeof ah_key_length, "%u",
				decode_16 (value));
		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      snprintf (esp_key_length, sizeof esp_key_length, "%u",
			       decode_16 (value));
		      break;
		    }
		  break;
d1178 7
a1184 14
		case IPSEC_ATTR_KEY_ROUNDS:
		  switch (proto->proto)
		    {
		    case IPSEC_PROTO_IPSEC_AH:
		      snprintf (ah_key_rounds, sizeof ah_key_rounds, "%u",
				decode_16 (value));
		      break;

		    case IPSEC_PROTO_IPSEC_ESP:
		      snprintf (esp_key_rounds, sizeof esp_key_rounds, "%u",
			       decode_16 (value));
		      break;
		    }
		  break;
d1186 31
a1216 9
		case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
		  snprintf (comp_dict_size, sizeof comp_dict_size, "%u",
			    decode_16 (value));
		  break;

		case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
		  snprintf (comp_private_alg, sizeof comp_private_alg, "%u",
			    decode_16 (value));
		  break;
a1217 2
	    }
	}
d1219 257
a1475 8
      policy_sa->transport->vtbl->get_src (policy_sa->transport, &sin);
      if (sockaddr2text (sin, &addr, 1))
	{
	  log_error ("policy_callback: sockaddr2text failed");
	  goto bad;
	}
      strlcpy (local_ike_address, addr, sizeof local_ike_address);
      free (addr);
d1477 16
a1492 8
      policy_sa->transport->vtbl->get_dst (policy_sa->transport, &sin);
      if (sockaddr2text (sin, &addr, 1))
	{
	  log_error ("policy_callback: sockaddr2text failed");
	  goto bad;
	}
      strlcpy (remote_ike_address, addr, sizeof remote_ike_address);
      free (addr);
d1494 69
a1562 5
      switch (policy_isakmp_sa->exch_type)
	{
	case ISAKMP_EXCH_AGGRESSIVE:
	  phase_1 = "aggressive";
	  break;
d1564 2
a1565 3
	case ISAKMP_EXCH_ID_PROT:
	  phase_1 = "main";
	  break;
d1567 2
d1570 4
a1573 4
      if (policy_isakmp_sa->initiator)
        {
	  id = policy_isakmp_sa->id_r;
	  id_sz = policy_isakmp_sa->id_r_len;
d1575 4
a1578 4
      else
        {
	  id = policy_isakmp_sa->id_i;
	  id_sz = policy_isakmp_sa->id_i_len;
d1580 32
d1613 11
a1623 4
      switch (id[0])
        {
	case IPSEC_ID_IPV4_ADDR:
	  remote_id_type = "IPv4 address";
d1625 2
a1626 63
	  net = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  my_inet_ntop4 (&net, remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1, 1);
	  my_inet_ntop4 (&net, remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1, 1);
	  remote_id = strdup (remote_id_addr_upper);
	  if (!remote_id)
	    {
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 remote_id_addr_upper);
	      goto bad;
	    }
	  break;

	case IPSEC_ID_IPV4_RANGE:
	  remote_id_type = "IPv4 range";

	  net = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  my_inet_ntop4 (&net, remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1, 1);
	  net = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
	  my_inet_ntop4 (&net, remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1, 1);
	  len = strlen (remote_id_addr_upper) + strlen (remote_id_addr_lower)
	    + 2;
	  remote_id = calloc (len, sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %lu) failed", len,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }

	  strlcpy (remote_id, remote_id_addr_lower, len);
	  strlcat (remote_id, "-", len);
	  strlcat (remote_id, remote_id_addr_upper, len);
	  break;

	case IPSEC_ID_IPV4_ADDR_SUBNET:
	  remote_id_type = "IPv4 subnet";

	  net = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  subnet = decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 4);
	  net &= subnet;
	  my_inet_ntop4 (&net, remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1, 1);
	  net |= ~subnet;
	  my_inet_ntop4 (&net, remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1, 1);
	  len = strlen (remote_id_addr_upper) + strlen (remote_id_addr_lower)
	    + 2;
	  remote_id = calloc (len, sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %lu) failed", len,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }

	  strlcpy (remote_id, remote_id_addr_lower, len);
	  strlcat (remote_id, "-", len);
	  strlcat (remote_id, remote_id_addr_upper, len);
	  break;
d1628 2
a1629 78
	case IPSEC_ID_IPV6_ADDR:
	  remote_id_type = "IPv6 address";
	  my_inet_ntop6 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			 remote_id_addr_upper, sizeof remote_id_addr_upper);
	  strlcpy (remote_id_addr_lower, remote_id_addr_upper,
		   sizeof remote_id_addr_lower);
	  remote_id = strdup (remote_id_addr_upper);
	  if (!remote_id)
	    {
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 remote_id_addr_upper);
	      goto bad;
	    }
	  break;

	case IPSEC_ID_IPV6_RANGE:
	  remote_id_type = "IPv6 range";

	  my_inet_ntop6 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			 remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1);

	  my_inet_ntop6 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16,
			 remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1);

	  len = strlen (remote_id_addr_upper) + strlen (remote_id_addr_lower)
	    + 2;
	  remote_id = calloc (len, sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %lu) failed", len,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }

	  strlcpy (remote_id, remote_id_addr_lower, len);
	  strlcat (remote_id, "-", len);
	  strlcat (remote_id, remote_id_addr_upper, len);
	  break;

	case IPSEC_ID_IPV6_ADDR_SUBNET:
	{
	  struct in6_addr net, mask;

	  remote_id_type = "IPv6 subnet";

	  bcopy (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, &net, sizeof (net));
	  bcopy (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 16, &mask,
		 sizeof (mask));

	  for (i = 0; i < 16; i++)
	    net.s6_addr[i] &= mask.s6_addr[i];

	  my_inet_ntop6 ((unsigned char *) &net, remote_id_addr_lower,
			 sizeof remote_id_addr_lower - 1);

	  for (i = 0; i < 16; i++)
	    net.s6_addr[i] |= ~mask.s6_addr[i];

	  my_inet_ntop6 ((unsigned char *) &net, remote_id_addr_upper,
			 sizeof remote_id_addr_upper - 1);

	  len = strlen (remote_id_addr_upper) + strlen (remote_id_addr_lower)
	    + 2;
	  remote_id = calloc (len, sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %lu) failed", len,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }

	  strlcpy (remote_id, remote_id_addr_lower, len);
	  strlcat (remote_id, "-", len);
	  strlcat (remote_id, remote_id_addr_upper, len);
	  break;
	}
d1631 2
a1632 14
	case IPSEC_ID_FQDN:
	  remote_id_type = "FQDN";
	  remote_id = calloc (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			      sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%lu, %lu) failed",
		 (unsigned long)id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
		 (unsigned long)sizeof (char));
	      goto bad;
	    }
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	  break;
d1634 2
a1635 65
	case IPSEC_ID_USER_FQDN:
	  remote_id_type = "User FQDN";
	  remote_id = calloc (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			      sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%lu, %lu) failed",
		 (unsigned long)id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
		 (unsigned long)sizeof (char));
	      goto bad;
	    }
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	  break;

	case IPSEC_ID_DER_ASN1_DN:
	  remote_id_type = "ASN1 DN";

	  remote_id = x509_DN_string (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
				      id_sz - ISAKMP_ID_DATA_OFF
				      + ISAKMP_GEN_SZ);
	  if (!remote_id)
	    {
	      LOG_DBG ((LOG_POLICY, 50,
			"policy_callback: failed to decode name"));
	      goto bad;
	    }
	  break;

	case IPSEC_ID_DER_ASN1_GN: /* XXX */
	  remote_id_type = "ASN1 GN";
	  break;

	case IPSEC_ID_KEY_ID:
	  remote_id_type = "Key ID";
	  remote_id
	    = calloc (2 * (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
		      sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%lu, %lu) failed",
			 2 * ((unsigned long)id_sz - ISAKMP_ID_DATA_OFF
			      + ISAKMP_GEN_SZ) + 1,
			 (unsigned long)sizeof (char));
	      goto bad;
	    }
	  /* Does it contain any non-printable characters ? */
	  for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++)
	    if (!isprint (*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + i)))
	      break;
	  if (i >= id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ)
	    {
	      memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		      id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	      break;
	    }
	  /* Non-printable characters, convert to hex */
          for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++)
	    {
	      remote_id[2 * i]
		= hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) >> 4];
	      remote_id[2 * i + 1]
		= hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) & 0xF];
	    }
	  break;
d1637 2
a1638 4
	default:
	  log_print ("policy_callback: unknown remote ID type %u", id[0]);
	  goto bad;
	}
d1640 2
a1641 9
      switch (id[1])
        {
	case IPPROTO_TCP:
	  remote_id_proto = "tcp";
	  break;

	case IPPROTO_UDP:
	  remote_id_proto = "udp";
	  break;
d1643 2
a1644 5
#ifdef IPPROTO_ETHERIP
	case IPPROTO_ETHERIP:
	  remote_id_proto = "etherip";
	  break;
#endif
d1646 2
a1647 48
	default:
	  snprintf (remote_id_proto_num, sizeof remote_id_proto_num, "%d",
		    id[1]);
	  remote_id_proto = remote_id_proto_num;
	  break;
	}

      snprintf (remote_id_port, sizeof remote_id_port, "%u",
		decode_16 (id + 2));

      if (policy_exchange->initiator)
        {
	  initiator = "yes";
	  idlocal = ie->id_ci;
	  idremote = ie->id_cr;
	  idlocalsz = ie->id_ci_sz;
	  idremotesz = ie->id_cr_sz;
        }
      else
        {
	  initiator = "no";
	  idlocal = ie->id_cr;
	  idremote = ie->id_ci;
	  idlocalsz = ie->id_cr_sz;
	  idremotesz = ie->id_ci_sz;
	}

      /* Initialize the ID variables.  */
      if (idremote)
        {
	  switch (GET_ISAKMP_ID_TYPE (idremote))
	    {
	    case IPSEC_ID_IPV4_ADDR:
	      remote_filter_type = "IPv4 address";

	      net = decode_32 (idremote + ISAKMP_ID_DATA_OFF);
	      my_inet_ntop4 (&net, remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1, 1);
	      my_inet_ntop4 (&net, remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1, 1);
	      remote_filter = strdup (remote_filter_addr_upper);
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     remote_filter_addr_upper);
		  goto bad;
		}
	      break;
d1649 2
a1650 2
	    case IPSEC_ID_IPV4_RANGE:
	      remote_filter_type = "IPv4 range";
d1652 2
a1653 15
	      net = decode_32 (idremote + ISAKMP_ID_DATA_OFF);
	      my_inet_ntop4 (&net, remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1, 1);
	      net = decode_32 (idremote + ISAKMP_ID_DATA_OFF + 4);
	      my_inet_ntop4 (&net, remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1, 1);
	      len = strlen (remote_filter_addr_upper)
		+ strlen (remote_filter_addr_lower) + 2;
	      remote_filter = calloc (len, sizeof (char));
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1655 2
a1656 45
	      strlcpy (remote_filter, remote_filter_addr_lower, len);
	      strlcat (remote_filter, "-", len);
	      strlcat (remote_filter, remote_filter_addr_upper, len);
	      break;

	    case IPSEC_ID_IPV4_ADDR_SUBNET:
	      remote_filter_type = "IPv4 subnet";

	      net = decode_32 (idremote + ISAKMP_ID_DATA_OFF);
	      subnet = decode_32 (idremote + ISAKMP_ID_DATA_OFF + 4);
	      net &= subnet;
	      my_inet_ntop4 (&net, remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1, 1);
	      net |= ~subnet;
	      my_inet_ntop4 (&net, remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1, 1);
	      len = strlen (remote_filter_addr_upper)
		+ strlen (remote_filter_addr_lower) + 2;
	      remote_filter = calloc (len, sizeof (char));
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
	      strlcpy (remote_filter, remote_filter_addr_lower, len);
	      strlcat (remote_filter, "-", len);
	      strlcat (remote_filter, remote_filter_addr_upper, len);
	      break;

	    case IPSEC_ID_IPV6_ADDR:
	      remote_filter_type = "IPv6 address";
	      my_inet_ntop6 (idremote + ISAKMP_ID_DATA_OFF,
			     remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1);
	      strlcpy (remote_filter_addr_lower, remote_filter_addr_upper,
		       sizeof remote_filter_addr_lower);
	      remote_filter = strdup (remote_filter_addr_upper);
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     remote_filter_addr_upper);
		  goto bad;
		}
	      break;
d1658 2
a1659 2
	    case IPSEC_ID_IPV6_RANGE:
	      remote_filter_type = "IPv6 range";
d1661 2
a1662 17
	      my_inet_ntop6 (idremote + ISAKMP_ID_DATA_OFF,
			     remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1);

	      my_inet_ntop6 (idremote + ISAKMP_ID_DATA_OFF + 16,
			     remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1);

	      len = strlen (remote_filter_addr_upper)
		+ strlen (remote_filter_addr_lower) + 2;
	      remote_filter = calloc (len, sizeof (char));
	      if (!remote_filter)
		{
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1664 2
a1665 4
	      strlcpy (remote_filter, remote_filter_addr_lower, len);
	      strlcat (remote_filter, "-", len);
	      strlcat (remote_filter, remote_filter_addr_upper, len);
	      break;
d1667 2
a1668 3
	    case IPSEC_ID_IPV6_ADDR_SUBNET:
	    {
	      struct in6_addr net, mask;
d1670 2
a1671 1
	      remote_filter_type = "IPv6 subnet";
d1673 2
a1674 2
	      bcopy (idremote + ISAKMP_ID_DATA_OFF, &net, sizeof (net));
	      bcopy (idremote + ISAKMP_ID_DATA_OFF + 16, &mask, sizeof (mask));
d1676 2
a1677 2
	      for (i = 0; i < 16; i++)
		net.s6_addr[i] &= mask.s6_addr[i];
d1679 2
a1680 2
	      my_inet_ntop6 ((unsigned char *) &net, remote_filter_addr_lower,
			     sizeof remote_filter_addr_lower - 1);
d1682 2
a1683 2
	      for (i = 0; i < 16; i++)
		net.s6_addr[i] |= ~mask.s6_addr[i];
d1685 2
a1686 2
	      my_inet_ntop6 ((unsigned char *) &net, remote_filter_addr_upper,
			     sizeof remote_filter_addr_upper - 1);
d1688 2
a1689 9
	      len = strlen (remote_filter_addr_upper)
		+ strlen (remote_filter_addr_lower) + 2;
	      remote_filter = calloc (len, sizeof (char));
	      if (!remote_filter)
		{
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1691 2
a1692 46
	      strlcpy (remote_filter, remote_filter_addr_lower, len);
	      strlcat (remote_filter, "-", len);
	      strlcat (remote_filter, remote_filter_addr_upper, len);
	      break;
	    }

	    case IPSEC_ID_FQDN:
	      remote_filter_type = "FQDN";
	      remote_filter = malloc (idremotesz - ISAKMP_ID_DATA_OFF + 1);
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: malloc (%lu) failed",
			     (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
		  goto bad;
		}
	      memcpy (remote_filter, idremote + ISAKMP_ID_DATA_OFF,
		      idremotesz - ISAKMP_ID_DATA_OFF);
	      remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
	      break;

	    case IPSEC_ID_USER_FQDN:
	      remote_filter_type = "User FQDN";
	      remote_filter = malloc (idremotesz - ISAKMP_ID_DATA_OFF + 1);
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: malloc (%lu) failed",
			     (unsigned long)idremotesz - ISAKMP_ID_DATA_OFF + 1);
		  goto bad;
		}
	      memcpy (remote_filter, idremote + ISAKMP_ID_DATA_OFF,
		      idremotesz - ISAKMP_ID_DATA_OFF);
	      remote_filter[idremotesz - ISAKMP_ID_DATA_OFF] = '\0';
	      break;

	    case IPSEC_ID_DER_ASN1_DN:
	      remote_filter_type = "ASN1 DN";

	      remote_filter = x509_DN_string (idremote + ISAKMP_ID_DATA_OFF,
					      idremotesz - ISAKMP_ID_DATA_OFF);
	      if (!remote_filter)
	        {
		  LOG_DBG ((LOG_POLICY, 50,
			    "policy_callback: failed to decode name"));
		  goto bad;
		}
	      break;
d1694 2
a1695 51
	    case IPSEC_ID_DER_ASN1_GN: /* XXX -- not sure what's in this.  */
	      remote_filter_type = "ASN1 GN";
	      break;

	    case IPSEC_ID_KEY_ID:
	      remote_filter_type = "Key ID";
	      remote_filter
		= calloc (2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1,
			  sizeof (char));
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: calloc (%lu, %lu) failed",
		     2 * ((unsigned long)idremotesz - ISAKMP_ID_DATA_OFF) + 1,
		     (unsigned long)sizeof (char));
		  goto bad;
	        }
	      /* Does it contain any non-printable characters ? */
	      for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
		if (!isprint (*(idremote + ISAKMP_ID_DATA_OFF + i)))
		  break;
	      if (i >= idremotesz - ISAKMP_ID_DATA_OFF)
	        {
		  memcpy (remote_filter, idremote + ISAKMP_ID_DATA_OFF,
			  idremotesz - ISAKMP_ID_DATA_OFF);
		  break;
		}
	      /* Non-printable characters, convert to hex */
              for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
	        {
		  remote_filter[2 * i]
		    = hextab[*(idremote + ISAKMP_ID_DATA_OFF) >> 4];
		  remote_filter[2 * i + 1]
		    = hextab[*(idremote + ISAKMP_ID_DATA_OFF) & 0xF];
	        }
	      break;

	    default:
	      log_print ("policy_callback: unknown Remote ID type %u",
			 GET_ISAKMP_ID_TYPE (idremote));
	      goto bad;
	    }

	  switch (idremote[ISAKMP_GEN_SZ + 1])
	    {
	    case IPPROTO_TCP:
	      remote_filter_proto = "tcp";
	      break;

	    case IPPROTO_UDP:
	      remote_filter_proto = "udp";
	      break;
d1697 2
a1698 5
#ifdef IPPROTO_ETHERIP
	    case IPPROTO_ETHERIP:
	      remote_filter_proto = "etherip";
	      break;
#endif
d1700 2
a1701 66
	    default:
	      snprintf (remote_filter_proto_num,
			sizeof remote_filter_proto_num, "%d",
			idremote[ISAKMP_GEN_SZ + 1]);
	      remote_filter_proto = remote_filter_proto_num;
	      break;
	    }

	  snprintf (remote_filter_port, sizeof remote_filter_port, "%u",
		    decode_16 (idremote + ISAKMP_GEN_SZ + 2));
	}
      else
        {
	  policy_sa->transport->vtbl->get_dst (policy_sa->transport, &sin);
	  switch (sin->sa_family)
	    {
	    case AF_INET:
	      remote_filter_type = "IPv4 address";
	      break;
	    case AF_INET6:
	      remote_filter_type = "IPv6 address";
	      break;
	    default:
	      log_print ("policy_callback: unsupported protocol family %d",
			 sin->sa_family);
	      goto bad;
	    }
	  if (sockaddr2text (sin, &addr, 1))
	    {
	      log_error ("policy_callback: sockaddr2text failed");
	      goto bad;
	    }
	  memcpy (remote_filter_addr_upper, addr,
		  sizeof remote_filter_addr_upper);
	  memcpy (remote_filter_addr_lower, addr,
		  sizeof remote_filter_addr_lower);
	  free (addr);
	  remote_filter = strdup (remote_filter_addr_upper);
	  if (!remote_filter)
	    {
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 remote_filter_addr_upper);
	      goto bad;
	    }
	}

      if (idlocal)
        {
	  switch (GET_ISAKMP_ID_TYPE (idlocal))
	    {
	    case IPSEC_ID_IPV4_ADDR:
	      local_filter_type = "IPv4 address";

	      net = decode_32 (idlocal + ISAKMP_ID_DATA_OFF);
	      my_inet_ntop4 (&net, local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1, 1);
	      my_inet_ntop4 (&net, local_filter_addr_lower,
			     sizeof local_filter_addr_upper - 1, 1);
	      local_filter = strdup (local_filter_addr_upper);
	      if (!local_filter)
	        {
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     local_filter_addr_upper);
		  goto bad;
		}
	      break;
d1703 2
a1704 2
	    case IPSEC_ID_IPV4_RANGE:
	      local_filter_type = "IPv4 range";
d1706 2
a1707 60
	      net = decode_32 (idlocal + ISAKMP_ID_DATA_OFF);
	      my_inet_ntop4 (&net, local_filter_addr_lower,
			     sizeof local_filter_addr_lower - 1, 1);
	      net = decode_32 (idlocal + ISAKMP_ID_DATA_OFF + 4);
	      my_inet_ntop4 (&net, local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1, 1);
	      len = strlen (local_filter_addr_upper)
		+ strlen (local_filter_addr_lower) + 2;
	      local_filter = calloc (len, sizeof (char));
	      if (!local_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
	      strlcpy (local_filter, local_filter_addr_lower, len);
	      strlcat (local_filter, "-", len);
	      strlcat (local_filter, local_filter_addr_upper, len);
	      break;

	    case IPSEC_ID_IPV4_ADDR_SUBNET:
	      local_filter_type = "IPv4 subnet";

	      net = decode_32 (idlocal + ISAKMP_ID_DATA_OFF);
	      subnet = decode_32 (idlocal + ISAKMP_ID_DATA_OFF + 4);
	      net &= subnet;
	      my_inet_ntop4 (&net, local_filter_addr_lower,
			     sizeof local_filter_addr_lower - 1, 1);
	      net |= ~subnet;
	      my_inet_ntop4 (&net, local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1, 1);
	      len = strlen (local_filter_addr_upper)
		+ strlen (local_filter_addr_lower) + 2;
	      local_filter = calloc (len, sizeof (char));
	      if (!local_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
	      strlcpy (local_filter, local_filter_addr_lower, len);
	      strlcat (local_filter, "-", len);
	      strlcat (local_filter, local_filter_addr_upper, len);
	      break;

	    case IPSEC_ID_IPV6_ADDR:
	      local_filter_type = "IPv6 address";
	      my_inet_ntop6 (idlocal + ISAKMP_ID_DATA_OFF,
			     local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1);
	      strlcpy (local_filter_addr_lower, local_filter_addr_upper,
		       sizeof local_filter_addr_lower);
	      local_filter = strdup (local_filter_addr_upper);
	      if (!local_filter)
	        {
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     local_filter_addr_upper);
		  goto bad;
		}
	      break;
d1709 2
a1710 2
	    case IPSEC_ID_IPV6_RANGE:
	      local_filter_type = "IPv6 range";
d1712 2
a1713 17
	      my_inet_ntop6 (idlocal + ISAKMP_ID_DATA_OFF,
			     local_filter_addr_lower,
			     sizeof local_filter_addr_lower - 1);

	      my_inet_ntop6 (idlocal + ISAKMP_ID_DATA_OFF + 16,
			     local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1);

	      len = strlen (local_filter_addr_upper)
		+ strlen (local_filter_addr_lower) + 2;
	      local_filter = calloc (len, sizeof (char));
	      if (!local_filter)
		{
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1715 2
a1716 4
	      strlcpy (local_filter, local_filter_addr_lower, len);
	      strlcat (local_filter, "-", len);
	      strlcat (local_filter, local_filter_addr_upper, len);
	      break;
d1718 2
a1719 3
	    case IPSEC_ID_IPV6_ADDR_SUBNET:
	    {
	      struct in6_addr net, mask;
d1721 2
a1722 1
	      local_filter_type = "IPv6 subnet";
d1724 2
a1725 2
	      bcopy (idlocal + ISAKMP_ID_DATA_OFF, &net, sizeof (net));
	      bcopy (idlocal + ISAKMP_ID_DATA_OFF + 16, &mask, sizeof (mask));
d1727 2
a1728 2
	      for (i = 0; i < 16; i++)
		net.s6_addr[i] &= mask.s6_addr[i];
d1730 2
a1731 2
	      my_inet_ntop6 ((unsigned char *) &net, local_filter_addr_lower,
			     sizeof local_filter_addr_lower - 1);
d1733 2
a1734 2
	      for (i = 0; i < 16; i++)
		net.s6_addr[i] |= ~mask.s6_addr[i];
d1736 2
a1737 2
	      my_inet_ntop6 ((unsigned char *) &net, local_filter_addr_upper,
			     sizeof local_filter_addr_upper - 1);
d1739 2
a1740 9
	      len = strlen (local_filter_addr_upper)
		+ strlen (local_filter_addr_lower) + 2;
	      local_filter = calloc (len, sizeof (char));
	      if (!local_filter)
		{
		  log_error ("policy_callback: calloc (%d, %lu) failed", len,
			     (unsigned long)sizeof (char));
		  goto bad;
		}
d1742 2
a1743 46
	      strlcpy (local_filter, local_filter_addr_lower, len);
	      strlcat (local_filter, "-", len);
	      strlcat (local_filter, local_filter_addr_upper, len);
	      break;
	    }

	    case IPSEC_ID_FQDN:
	      local_filter_type = "FQDN";
	      local_filter = malloc (idlocalsz - ISAKMP_ID_DATA_OFF + 1);
	      if (!local_filter)
	        {
		  log_error ("policy_callback: malloc (%lu) failed",
			     (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
		  goto bad;
		}
	      memcpy (local_filter, idlocal + ISAKMP_ID_DATA_OFF,
		      idlocalsz - ISAKMP_ID_DATA_OFF);
	      local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
	      break;

	    case IPSEC_ID_USER_FQDN:
	      local_filter_type = "User FQDN";
	      local_filter = malloc (idlocalsz - ISAKMP_ID_DATA_OFF + 1);
	      if (!local_filter)
	        {
		  log_error ("policy_callback: malloc (%lu) failed",
			     (unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF + 1);
		  goto bad;
		}
	      memcpy (local_filter, idlocal + ISAKMP_ID_DATA_OFF,
		      idlocalsz - ISAKMP_ID_DATA_OFF);
	      local_filter[idlocalsz - ISAKMP_ID_DATA_OFF] = '\0';
	      break;

	    case IPSEC_ID_DER_ASN1_DN:
	      local_filter_type = "ASN1 DN";

	      local_filter = x509_DN_string (idlocal + ISAKMP_ID_DATA_OFF,
					     idlocalsz - ISAKMP_ID_DATA_OFF);
	      if (!local_filter)
	        {
		  LOG_DBG ((LOG_POLICY, 50,
			    "policy_callback: failed to decode name"));
		  goto bad;
		}
	      break;
d1745 2
a1746 51
	    case IPSEC_ID_DER_ASN1_GN:
	      /* XXX -- not sure what's in this.  */
	      local_filter_type = "ASN1 GN";
	      break;

	    case IPSEC_ID_KEY_ID:
	      local_filter_type = "Key ID";
	      local_filter = calloc (2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
				     sizeof (char));
	      if (!local_filter)
	        {
		  log_error ("policy_callback: calloc (%lu, %lu) failed",
		     2 * ((unsigned long)idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
		     (unsigned long)sizeof (char));
		  goto bad;
	        }
	      /* Does it contain any non-printable characters ? */
	      for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
		if (!isprint (*(idlocal + ISAKMP_ID_DATA_OFF + i)))
		  break;
	      if (i >= idlocalsz - ISAKMP_ID_DATA_OFF)
	        {
		  memcpy (local_filter, idlocal + ISAKMP_ID_DATA_OFF,
			  idlocalsz - ISAKMP_ID_DATA_OFF);
		  break;
		}
	      /* Non-printable characters, convert to hex */
              for (i = 0; i < idlocalsz - ISAKMP_ID_DATA_OFF; i++)
	        {
		  local_filter[2 * i]
		    = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) >> 4];
		  local_filter[2 * i + 1]
		    = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) & 0xF];
	        }
	      break;

	    default:
	      log_print ("policy_callback: unknown Local ID type %u",
			 GET_ISAKMP_ID_TYPE (idlocal));
	      goto bad;
	    }

	  switch (idlocal[ISAKMP_GEN_SZ + 1])
	    {
	    case IPPROTO_TCP:
	      local_filter_proto = "tcp";
	      break;

	    case IPPROTO_UDP:
	      local_filter_proto = "udp";
	      break;
d1748 1
a1748 5
#ifdef IPPROTO_ETHERIP
	    case IPPROTO_ETHERIP:
	      local_filter_proto = "etherip";
	      break;
#endif
d1750 3
a1752 311
	    default:
	      snprintf (local_filter_proto_num, sizeof local_filter_proto_num,
			"%d", idlocal[ISAKMP_GEN_SZ + 1]);
	      local_filter_proto = local_filter_proto_num;
	      break;
	    }

	  snprintf (local_filter_port, sizeof local_filter_port, "%u",
		    decode_16 (idlocal + ISAKMP_GEN_SZ + 2));
	}
      else
        {
	  policy_sa->transport->vtbl->get_src (policy_sa->transport,
					       (struct sockaddr **)&sin);
	  switch (sin->sa_family)
	    {
	    case AF_INET:
	      local_filter_type = "IPv4 address";
	      break;
	    case AF_INET6:
	      local_filter_type = "IPv6 address";
	      break;
	    default:
	      log_print ("policy_callback: unsupported protocol family %d",
			 sin->sa_family);
	      goto bad;
	    }

	  if (sockaddr2text (sin, &addr, 1))
	    {
	      log_error ("policy_callback: sockaddr2text failed");
	      goto bad;
	    }
	  memcpy (local_filter_addr_upper, addr,
		  sizeof local_filter_addr_upper);
	  memcpy (local_filter_addr_lower, addr,
		  sizeof local_filter_addr_lower);
	  free (addr);
	  local_filter = strdup (local_filter_addr_upper);
	  if (!local_filter)
	    {
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 local_filter_addr_upper);
	      goto bad;
	    }
        }

      LOG_DBG ((LOG_POLICY, 80, "Policy context (action attributes):"));
      LOG_DBG ((LOG_POLICY, 80, "esp_present == %s", esp_present));
      LOG_DBG ((LOG_POLICY, 80, "ah_present == %s", ah_present));
      LOG_DBG ((LOG_POLICY, 80, "comp_present == %s", comp_present));
      LOG_DBG ((LOG_POLICY, 80, "ah_hash_alg == %s", ah_hash_alg));
      LOG_DBG ((LOG_POLICY, 80, "esp_enc_alg == %s", esp_enc_alg));
      LOG_DBG ((LOG_POLICY, 80, "comp_alg == %s", comp_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_auth_alg == %s", ah_auth_alg));
      LOG_DBG ((LOG_POLICY, 80, "esp_auth_alg == %s", esp_auth_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_life_seconds == %s", ah_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "ah_life_kbytes == %s", ah_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "esp_life_seconds == %s", esp_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "esp_life_kbytes == %s", esp_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "comp_life_seconds == %s", comp_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "comp_life_kbytes == %s", comp_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "ah_encapsulation == %s", ah_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "esp_encapsulation == %s", esp_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "comp_encapsulation == %s",
		comp_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "comp_dict_size == %s", comp_dict_size));
      LOG_DBG ((LOG_POLICY, 80, "comp_private_alg == %s", comp_private_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_key_length == %s", ah_key_length));
      LOG_DBG ((LOG_POLICY, 80, "ah_key_rounds == %s", ah_key_rounds));
      LOG_DBG ((LOG_POLICY, 80, "esp_key_length == %s", esp_key_length));
      LOG_DBG ((LOG_POLICY, 80, "esp_key_rounds == %s", esp_key_rounds));
      LOG_DBG ((LOG_POLICY, 80, "ah_group_desc == %s", ah_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "esp_group_desc == %s", esp_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "comp_group_desc == %s", comp_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "ah_ecn == %s", ah_ecn));
      LOG_DBG ((LOG_POLICY, 80, "esp_ecn == %s", esp_ecn));
      LOG_DBG ((LOG_POLICY, 80, "comp_ecn == %s", comp_ecn));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_type == %s",
		remote_filter_type));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_addr_upper == %s",
		remote_filter_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_addr_lower == %s",
		remote_filter_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter == %s",
		(remote_filter ? remote_filter : "")));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_port == %s",
		remote_filter_port));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_proto == %s",
		remote_filter_proto));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_type == %s", local_filter_type));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_addr_upper == %s",
		local_filter_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_addr_lower == %s",
		local_filter_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "local_filter == %s",
		(local_filter ? local_filter : "")));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_port == %s", local_filter_port));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_proto == %s",
		local_filter_proto));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_type == %s", remote_id_type));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_addr_upper == %s",
		remote_id_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_addr_lower == %s",
		remote_id_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "remote_id == %s",
		(remote_id ? remote_id : "")));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_port == %s", remote_id_port));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_proto == %s", remote_id_proto));
      LOG_DBG ((LOG_POLICY, 80, "remote_negotiation_address == %s",
		remote_ike_address));
      LOG_DBG ((LOG_POLICY, 80, "local_negotiation_address == %s",
		local_ike_address));
      LOG_DBG ((LOG_POLICY, 80, "pfs == %s", pfs));
      LOG_DBG ((LOG_POLICY, 80, "initiator == %s", initiator));
      LOG_DBG ((LOG_POLICY, 80, "phase1_group_desc == %s", phase1_group));

      /* Unset dirty now.  */
      dirty = 0;
    }

  if (strcmp (name, "phase_1") == 0)
    return phase_1;

  if (strcmp (name, "GMTTimeOfDay") == 0)
    {
      tt = time ((time_t) NULL);
      strftime (mytimeofday, 14, "%Y%m%d%H%M%S", gmtime (&tt));
      return mytimeofday;
    }

  if (strcmp (name, "LocalTimeOfDay") == 0)
    {
      tt = time ((time_t) NULL);
      strftime (mytimeofday, 14, "%Y%m%d%H%M%S", localtime (&tt));
      return mytimeofday;
    }

  if (strcmp (name, "initiator") == 0)
    return initiator;

  if (strcmp (name, "pfs") == 0)
    return pfs;

  if (strcmp (name, "app_domain") == 0)
    return "IPsec policy";

  if (strcmp (name, "doi") == 0)
    return "ipsec";

  if (strcmp (name, "esp_present") == 0)
    return esp_present;

  if (strcmp (name, "ah_present") == 0)
    return ah_present;

  if (strcmp (name, "comp_present") == 0)
    return comp_present;

  if (strcmp (name, "ah_hash_alg") == 0)
    return ah_hash_alg;

  if (strcmp (name, "ah_auth_alg") == 0)
    return ah_auth_alg;

  if (strcmp (name, "esp_auth_alg") == 0)
    return esp_auth_alg;

  if (strcmp (name, "esp_enc_alg") == 0)
    return esp_enc_alg;

  if (strcmp (name, "comp_alg") == 0)
    return comp_alg;

  if (strcmp (name, "ah_life_kbytes") == 0)
    return ah_life_kbytes;

  if (strcmp (name, "ah_life_seconds") == 0)
    return ah_life_seconds;

  if (strcmp (name, "esp_life_kbytes") == 0)
    return esp_life_kbytes;

  if (strcmp (name, "esp_life_seconds") == 0)
    return esp_life_seconds;

  if (strcmp (name, "comp_life_kbytes") == 0)
    return comp_life_kbytes;

  if (strcmp (name, "comp_life_seconds") == 0)
    return comp_life_seconds;

  if (strcmp (name, "ah_encapsulation") == 0)
    return ah_encapsulation;

  if (strcmp (name, "esp_encapsulation") == 0)
    return esp_encapsulation;

  if (strcmp (name, "comp_encapsulation") == 0)
    return comp_encapsulation;

  if (strcmp (name, "ah_key_length") == 0)
    return ah_key_length;

  if (strcmp (name, "ah_key_rounds") == 0)
    return ah_key_rounds;

  if (strcmp (name, "esp_key_length") == 0)
    return esp_key_length;

  if (strcmp (name, "esp_key_rounds") == 0)
    return esp_key_rounds;

  if (strcmp (name, "comp_dict_size") == 0)
    return comp_dict_size;

  if (strcmp (name, "comp_private_alg") == 0)
    return comp_private_alg;

  if (strcmp (name, "remote_filter_type") == 0)
    return remote_filter_type;

  if (strcmp (name, "remote_filter") == 0)
    return (remote_filter ? remote_filter : "");

  if (strcmp (name, "remote_filter_addr_upper") == 0)
    return remote_filter_addr_upper;

  if (strcmp (name, "remote_filter_addr_lower") == 0)
    return remote_filter_addr_lower;

  if (strcmp (name, "remote_filter_port") == 0)
    return remote_filter_port;

  if (strcmp (name, "remote_filter_proto") == 0)
    return remote_filter_proto;

  if (strcmp (name, "local_filter_type") == 0)
    return local_filter_type;

  if (strcmp (name, "local_filter") == 0)
    return (local_filter ? local_filter : "");

  if (strcmp (name, "local_filter_addr_upper") == 0)
    return local_filter_addr_upper;

  if (strcmp (name, "local_filter_addr_lower") == 0)
    return local_filter_addr_lower;

  if (strcmp (name, "local_filter_port") == 0)
    return local_filter_port;

  if (strcmp (name, "local_filter_proto") == 0)
    return local_filter_proto;

  if (strcmp (name, "remote_ike_address") == 0)
    return remote_ike_address;

  if (strcmp (name, "remote_negotiation_address") == 0)
    return remote_ike_address;

  if (strcmp (name, "local_ike_address") == 0)
    return local_ike_address;

  if (strcmp (name, "local_negotiation_address") == 0)
    return local_ike_address;

  if (strcmp (name, "remote_id_type") == 0)
    return remote_id_type;

  if (strcmp (name, "remote_id") == 0)
    return (remote_id ? remote_id : "");

  if (strcmp (name, "remote_id_addr_upper") == 0)
    return remote_id_addr_upper;

  if (strcmp (name, "remote_id_addr_lower") == 0)
    return remote_id_addr_lower;

  if (strcmp (name, "remote_id_port") == 0)
    return remote_id_port;

  if (strcmp (name, "remote_id_proto") == 0)
    return remote_id_proto;

  if (strcmp (name, "phase1_group_desc") == 0)
    return phase1_group;

  if (strcmp (name, "esp_group_desc") == 0)
    return esp_group_desc;

  if (strcmp (name, "ah_group_desc") == 0)
    return ah_group_desc;

  if (strcmp (name, "comp_group_desc") == 0)
    return comp_group_desc;

  if (strcmp (name, "comp_ecn") == 0)
    return comp_ecn;

  if (strcmp (name, "ah_ecn") == 0)
    return ah_ecn;

  if (strcmp (name, "esp_ecn") == 0)
    return esp_ecn;

  return "";

 bad:
  policy_callback (KEYNOTE_CALLBACK_INITIALIZE);
  return "";
d1756 1
a1756 1
policy_init (void)
d1758 34
a1791 54
  char *ptr, *policy_file;
  char **asserts;
  size_t sz, len;
  int fd, i;

  LOG_DBG ((LOG_POLICY, 30, "policy_init: initializing"));

  /* Get policy file from configuration.  */
  policy_file = conf_get_str ("General", "Policy-file");
  if (!policy_file)
    policy_file = CONF_DFLT_POLICY_FILE;

  /* Check file modes and collect file size */
  if (check_file_secrecy (policy_file, &sz))
    log_fatal ("policy_init: cannot read %s", policy_file);

  /* Open policy file.  */
  fd = monitor_open (policy_file, O_RDONLY, 0);
  if (fd == -1)
    log_fatal ("policy_init: open (\"%s\", O_RDONLY) failed", policy_file);

  /* Allocate memory to keep policies.  */
  ptr = calloc (sz + 1, sizeof (char));
  if (!ptr)
    log_fatal ("policy_init: calloc (%lu, %lu) failed", (unsigned long)sz + 1,
	       (unsigned long)sizeof (char));

  /* Just in case there are short reads...  */
  for (len = 0; len < sz; len += i)
    {
      i = read (fd, ptr + len, sz - len);
      if (i == -1)
	log_fatal ("policy_init: read (%d, %p, %lu) failed", fd, ptr + len,
		   (unsigned long)(sz - len));
    }

  /* We're done with this.  */
  close (fd);

  /* Parse buffer, break up into individual policies.  */
  asserts = kn_read_asserts (ptr, sz, &i);

  /* Begone!  */
  free (ptr);

  if (asserts == (char **) NULL)
    log_print ("policy_init: all policies flushed");

  /* Cleanup */
  if (keynote_policy_asserts)
    {
      for (fd = 0; fd < keynote_policy_asserts_num; fd++)
        if (keynote_policy_asserts && keynote_policy_asserts[fd])
          free (keynote_policy_asserts[fd]);
d1793 2
a1794 2
      free (keynote_policy_asserts);
    }
d1796 19
a1814 2
  keynote_policy_asserts = asserts;
  keynote_policy_asserts_num = i;
d1819 1
a1819 1
keynote_cert_init (void)
d1821 1
a1821 1
  return 1;
d1825 2
a1826 2
void *
keynote_cert_get (u_int8_t *data, u_int32_t len)
d1828 1
a1828 1
  char *foo = malloc (len + 1);
d1830 2
a1831 2
  if (foo == NULL)
    return NULL;
d1833 3
a1835 3
  memcpy (foo, data, len);
  foo[len] = '\0';
  return foo;
d1843 1
a1843 1
keynote_cert_validate (void *scert)
d1845 2
a1846 2
  char **foo;
  int num, i;
d1848 2
a1849 2
  if (scert == NULL)
    return 0;
d1851 13
a1863 13
  foo = kn_read_asserts ((char *) scert, strlen ((char *) scert), &num);
  if (foo == NULL)
    return 0;

  for (i = 0; i < num; i++)
    {
      if (kn_verify_assertion (scert, strlen ((char *) scert))
	  != SIGRESULT_TRUE)
        {
	  for (; i < num; i++)
	    free (foo[i]);
	  free (foo);
	  return 0;
d1866 2
a1867 5
      free (foo[i]);
    }

  free (foo);
  return 1;
d1872 1
a1872 1
keynote_cert_insert (int sid, void *scert)
d1874 2
a1875 2
  char **foo;
  int num;
d1877 2
a1878 2
  if (scert == NULL)
    return 0;
d1880 3
a1882 3
  foo = kn_read_asserts ((char *) scert, strlen ((char *) scert), &num);
  if (foo == NULL)
    return 0;
d1884 2
a1885 2
  while (num--)
    kn_add_assertion (sid, foo[num], strlen (foo[num]), 0);
d1887 1
a1887 1
  return 1;
d1892 1
a1892 1
keynote_cert_free (void *cert)
d1894 1
a1894 1
  free (cert);
d1899 1
a1899 1
keynote_certreq_validate (u_int8_t *data, u_int32_t len)
d1901 11
a1911 13
  struct keynote_deckey dc;
  int err = 1;
  char *dat;

  dat = calloc (len + 1, sizeof (char));
  if (!dat)
    {
      log_error ("keynote_certreq_validate: calloc (%d, %lu) failed", len + 1,
		 (unsigned long)sizeof (char));
	return 0;
    }

  memcpy (dat, data, len);
d1913 4
a1916 4
  if (kn_decode_key (&dc, dat, KEYNOTE_PUBLIC_KEY) != 0)
    err = 0;
  else
    kn_free_key (&dc);
d1918 1
a1918 1
  free (dat);
d1920 1
a1920 1
  return err;
d1924 2
a1925 2
void *
keynote_certreq_decode (u_int8_t *data, u_int32_t len)
d1927 2
a1928 2
  /* XXX */
  return NULL;
d1932 1
a1932 1
keynote_free_aca (void *blob)
d1934 1
a1934 1
  /* XXX */
d1938 2
a1939 2
keynote_cert_obtain (u_int8_t *id, size_t id_len, void *data, u_int8_t **cert,
		     u_int32_t *certlen)
d1941 69
a2009 34
  char *dirname, *file, *addr_str;
  struct stat sb;
  size_t size;
  int idtype, fd, len;

  if (!id)
    {
      log_print ("keynote_cert_obtain: ID is missing");
      return 0;
    }

  /* Get type of ID.  */
  idtype = id[0];
  id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
  id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

  dirname = conf_get_str ("KeyNote", "Credential-directory");
  if (!dirname)
    {
      LOG_DBG ((LOG_POLICY, 30,
		"keynote_cert_obtain: no Credential-directory"));
      return 0;
    }

  len = strlen (dirname) + strlen (CREDENTIAL_FILE) + 3;

  switch (idtype)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      util_ntoa (&addr_str, idtype == IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
		 id);
      if (addr_str == 0)
	return 0;
d2011 25
a2035 76
      file = calloc (len + strlen (addr_str), sizeof (char));
      if (file == NULL)
	{
	  log_error ("keynote_cert_obtain: failed to allocate %lu bytes",
		     (unsigned long)len + strlen (addr_str));
	  free (addr_str);
	  return 0;
	}

      snprintf (file, len + strlen (addr_str), "%s/%s/%s", dirname, addr_str,
		CREDENTIAL_FILE);
      free (addr_str);
      break;

    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
      {
        file = calloc (len + id_len, sizeof (char));
	if (file == NULL)
	  {
	    log_error ("keynote_cert_obtain: failed to allocate %lu bytes",
		       (unsigned long)len + id_len);
	    return 0;
	  }

	snprintf (file, len + id_len, "%s/", dirname);
	memcpy (file + strlen (dirname) + 1, id, id_len);
	snprintf (file + strlen (dirname) + 1 + id_len,
		  len - strlen (dirname) - 1, "/%s", CREDENTIAL_FILE);
	break;
      }

    default:
      return 0;
    }

  if (monitor_stat (file, &sb) < 0)
    {
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to stat \"%s\"",
		file));
      free (file);
      return 0;
    }
  size = (size_t)sb.st_size;

  *cert = calloc (size + 1, sizeof (char));
  if (*cert == NULL)
    {
      log_error ("keynote_cert_obtain: failed to allocate %lu bytes",
		 (unsigned long)size);
      free (file);
      return 0;
    }

  fd = monitor_open (file, O_RDONLY, 0);
  if (fd < 0)
    {
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to open \"%s\"",
		file));
      free (file);
      return 0;
    }

  if (read (fd, *cert, size) != (int)size)
    {
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to read %lu "
		"bytes from \"%s\"", (unsigned long)size, file));
      free (file);
      close (fd);
      return 0;
    }

  close (fd);
  free (file);
  *certlen = size;
  return 1;
d2040 2
a2041 2
keynote_cert_get_subjects (void *scert, int *n, u_int8_t ***id,
			   u_int32_t **id_len)
d2043 1
a2043 1
  return 0;
d2048 1
a2048 1
keynote_cert_get_key (void *scert, void *keyp)
d2050 42
a2091 51
  struct keynote_keylist *kl;
  int sid, kid, num;
  char **foo;

  foo = kn_read_asserts ((char *)scert, strlen ((char *)scert), &num);
  if (foo == NULL || num == 0)
    {
      log_print ("keynote_cert_get_key: failed to decompose credentials");
      return 0;
    }

  kid = kn_init ();
  if (kid == -1)
    {
      log_print ("keynote_cert_get_key: failed to initialize new policy "
		 "session");
      while (num--)
	free (foo[num]);
      free (foo);
      return 0;
    }

  sid = kn_add_assertion (kid, foo[num - 1], strlen (foo[num - 1]), 0);
  while (num--)
    free (foo[num]);
  free (foo);

  if (sid == -1)
    {
      log_print ("keynote_cert_get_key: failed to add assertion");
      kn_close (kid);
      return 0;
    }

  *(RSA **)keyp = NULL;

  kl = kn_get_licensees (kid, sid);
  while (kl)
    {
      if (kl->key_alg == KEYNOTE_ALGORITHM_RSA)
	{
	  *(RSA **)keyp = RSAPublicKey_dup (kl->key_key);
	  break;
	}

      kl = kl->key_next;
    }

  kn_remove_assertion (kid, sid);
  kn_close (kid);
  return *(RSA **)keyp == NULL ? 0 : 1;
d2095 1
a2095 1
keynote_cert_dup (void *cert)
d2097 1
a2097 1
  return strdup ((char *)cert);
d2101 1
a2101 1
keynote_serialize (void *cert, u_int8_t **data, u_int32_t *datalen)
d2103 5
a2107 4
  *datalen = strlen ((char *)cert) + 1;
  *data = (u_int8_t *)strdup (cert); /* i.e an extra character at the end... */
  if (*data == NULL)
    log_error ("keynote_serialize: malloc (%d) failed", *datalen);
d2112 1
a2112 1
keynote_printable (void *cert)
d2114 1
a2114 1
  return strdup ((char *)cert);
d2119 1
a2119 1
keynote_from_printable (char *cert)
d2121 1
a2121 1
  return strdup (cert);
@


1.68
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.67 2003/11/06 16:12:08 ho Exp $	*/
d97 1
a97 1
		((u_int8_t *) &src2)[3]) > size)
d114 1
a114 1
		src[12], src[13], src[14], src[15]) > size)
d133 2
a134 1
  int fmt, i, lifetype = 0;
d912 3
a914 2
		 2 * ((unsigned long)id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
		 (unsigned long)sizeof (char));
d1845 2
a1846 2
  size_t sz;
  int fd, len, i;
d2132 1
a2132 1
  if (read (fd, *cert, size) != size)
@


1.67
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.66 2003/07/25 08:31:16 markus Exp $	*/
d2103 1
a2103 1
  if (stat (file, &sb) < 0)
d2121 1
a2121 1
  fd = open (file, O_RDONLY, 0);
@


1.66
log
@add sha2 support; ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.65 2003/06/10 16:41:29 deraadt Exp $	*/
d2213 1
a2213 1
  return strdup((char *)cert);
@


1.65
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.64 2003/06/04 07:31:17 ho Exp $	*/
d269 12
d563 12
d598 12
@


1.64
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.63 2003/06/03 12:51:39 ho Exp $	*/
d683 1
a683 1
  	    {
d748 1
a748 1
  	    {
d920 1
a920 1
 	default:
d1196 1
a1196 1
 	    default:
d1489 1
a1489 1
 	    default:
@


1.63
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.62 2003/05/18 19:37:47 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.62
log
@More isakmpd privsep work. X509 private keys are now kept in the privileged
process only. Various cleanup and bugfixes.
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.61 2003/05/15 00:28:53 ho Exp $	*/
d251 1
a251 1
      snprintf (phase1_group, PMAX, "%u", is->group_desc);
d396 2
a397 2
			    snprintf (ah_life_seconds, PMAX, "%u",
				      decode_16 (value));
d399 2
a400 2
			    snprintf (ah_life_seconds, PMAX, "%u",
				      decode_32 (value));
d405 2
a406 2
			    snprintf (ah_life_kbytes, PMAX, "%u",
				      decode_16 (value));
d408 2
a409 2
			    snprintf (ah_life_kbytes, PMAX, "%u",
				      decode_32 (value));
d418 2
a419 1
			    snprintf (esp_life_seconds, PMAX, "%u",
d422 2
a423 1
			    snprintf (esp_life_seconds, PMAX, "%u",
d429 2
a430 1
			    snprintf (esp_life_kbytes, PMAX, "%u",
d433 2
a434 1
			    snprintf (esp_life_kbytes, PMAX, "%u",
d444 2
a445 1
			    snprintf (comp_life_seconds, PMAX, "%u",
d448 2
a449 1
			    snprintf (comp_life_seconds, PMAX, "%u",
d455 2
a456 1
			    snprintf (comp_life_kbytes, PMAX, "%u",
d459 2
a460 1
			    snprintf (comp_life_kbytes, PMAX, "%u",
d472 2
a473 1
		      snprintf (ah_group_desc, PMAX, "%u", decode_16 (value));
d477 1
a477 1
		      snprintf (esp_group_desc, PMAX, "%u",
d482 1
a482 1
		      snprintf (comp_group_desc, PMAX, "%u",
d597 2
a598 1
		      snprintf (ah_key_length, PMAX, "%u", decode_16 (value));
d602 1
a602 1
		      snprintf (esp_key_length, PMAX, "%u",
d612 2
a613 1
		      snprintf (ah_key_rounds, PMAX, "%u", decode_16 (value));
d617 1
a617 1
		      snprintf (esp_key_rounds, PMAX, "%u",
d624 2
a625 1
		  snprintf (comp_dict_size, PMAX, "%u", decode_16 (value));
d629 2
a630 1
		  snprintf (comp_private_alg, PMAX, "%u", decode_16 (value));
d926 2
a927 1
	  snprintf (remote_id_proto_num, 3, "%d", id[1]);
d932 1
a932 1
      snprintf (remote_id_port, sizeof remote_id_port - 1, "%u",
d1202 3
a1204 2
	      snprintf (remote_filter_proto_num, 3, "%d",
		       idremote[ISAKMP_GEN_SZ + 1]);
d1209 2
a1210 2
	  snprintf (remote_filter_port, sizeof remote_filter_port - 1,
		    "%u", decode_16 (idremote + ISAKMP_GEN_SZ + 2));
d1495 2
a1496 2
	      snprintf (local_filter_proto_num, 3, "%d",
		       idlocal[ISAKMP_GEN_SZ + 1]);
d1501 2
a1502 2
	  snprintf (local_filter_port, sizeof local_filter_port - 1,
		    "%u", decode_16 (idlocal + ISAKMP_GEN_SZ + 2));
@


1.61
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.60 2003/05/14 18:10:30 ho Exp $	*/
d1832 1
a1832 1
  monitor_close (fd);
@


1.60
log
@Policy file default defined twice, kill the local copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.59 2003/05/14 17:37:22 ho Exp $	*/
d69 1
d1812 1
a1812 1
  fd = open (policy_file, O_RDONLY);
d1832 1
a1832 1
  close (fd);
@


1.59
log
@I did not test this enough. Unbreak.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.58 2003/05/12 21:43:22 ho Exp $	*/
d1804 1
a1804 1
    policy_file = POLICY_FILE_DEFAULT;
@


1.58
log
@AES -> AES_128_CBC
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.57 2002/11/14 16:38:05 ho Exp $	*/
d296 1
a296 1
		case IPSEC_ESP_AES_128_CBC:
@


1.57
log
@Use %d instead of %2d for better matching. From Mike Neuman. Fixes PR#2848.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.56 2002/09/11 09:50:44 ho Exp $	*/
d296 2
a297 1
		case IPSEC_ESP_AES:
@


1.56
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.55 2002/06/15 19:27:06 angelos Exp $	*/
d911 1
a911 1
	  snprintf (remote_id_proto_num, 3, "%2d", id[1]);
d1186 1
a1186 1
	      snprintf (remote_filter_proto_num, 3, "%2d",
d1478 1
a1478 1
	      snprintf (local_filter_proto_num, 3, "%2d",
@


1.55
log
@ecn_* policy attributes --- ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.54 2002/06/10 18:08:58 ho Exp $	*/
d784 1
a784 1
	  my_inet_ntop6 ((char *) &net, remote_id_addr_lower,
d790 1
a790 1
	  my_inet_ntop6 ((char *) &net, remote_id_addr_upper,
d1061 1
a1061 1
	      my_inet_ntop6 ((char *) &net, remote_filter_addr_lower,
d1067 1
a1067 1
	      my_inet_ntop6 ((char *) &net, remote_filter_addr_upper,
d1353 1
a1353 1
	      my_inet_ntop6 ((char *) &net, local_filter_addr_lower,
d1359 1
a1359 1
	      my_inet_ntop6 ((char *) &net, local_filter_addr_upper,
d2172 1
a2172 1
  *data = strdup (cert); /* So we allocate an extra character at the end... */
@


1.54
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.53 2002/06/09 08:13:06 todd Exp $	*/
d151 1
d184 1
d477 17
d1552 3
d1773 9
@


1.53
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.52 2002/06/01 07:44:22 deraadt Exp $	*/
a61 1
#include "dyn.h"
a72 44
#if defined (HAVE_DLOPEN) && !defined (USE_KEYNOTE) && 0

void *libkeynote = 0;

/*
 * These prototypes matches OpenBSD keynote.h 1.6.  If you use
 * a different version than that, you are on your own.
 */
int *lk_keynote_errno;
int (*lk_kn_add_action) (int, char *, char *, int);
int (*lk_kn_add_assertion) (int, char *, int, int);
int (*lk_kn_add_authorizer) (int, char *);
int (*lk_kn_close) (int);
int (*lk_kn_do_query) (int, char **, int);
char *(*lk_kn_encode_key) (struct keynote_deckey *, int, int, int);
int (*lk_kn_init) (void);
char **(*lk_kn_read_asserts) (char *, int, int *);
int (*lk_kn_remove_authorizer) (int, char *);
int (*lk_kn_get_authorizer) (int, int, int *);
void (*lk_kn_free_key) (struct keynote_deckey *);
struct keynote_keylist *(*lk_kn_get_licensees) (int, int);
#define SYMENTRY(x) { SYM, SYM (x), (void **)&lk_ ## x }

static struct dynload_script libkeynote_script[] = {
  { LOAD, "libc.so", &libkeynote },
  { LOAD, "libcrypto.so", &libkeynote },
  { LOAD, "libm.so", &libkeynote },
  { LOAD, "libkeynote.so", &libkeynote },
  SYMENTRY (keynote_errno),
  SYMENTRY (kn_add_action),
  SYMENTRY (kn_add_assertion),
  SYMENTRY (kn_add_authorizer),
  SYMENTRY (kn_close),
  SYMENTRY (kn_do_query),
  SYMENTRY (kn_encode_key),
  SYMENTRY (kn_init),
  SYMENTRY (kn_read_asserts),
  SYMENTRY (kn_remove_authorizer),
  SYMENTRY (kn_get_licensees),
  SYMENTRY (kn_get_authorizer),
  { EOS }
};
#endif

a1768 5
#if defined (HAVE_DLOPEN) && !defined (USE_KEYNOTE)
  if (!dyn_load (libkeynote_script))
    return;
#endif

d1802 1
a1802 1
  asserts = LK (kn_read_asserts, (ptr, sz, &i));
d1858 1
a1858 2
  foo = LK (kn_read_asserts, ((char *) scert, strlen ((char *) scert),
			      &num));
d1864 1
a1864 1
      if (LK (kn_verify_assertion, (scert, strlen ((char *) scert)))
d1890 1
a1890 2
  foo = LK (kn_read_asserts, ((char *) scert, strlen ((char *) scert),
			      &num));
d1895 1
a1895 1
    LK (kn_add_assertion, (sid, foo[num], strlen (foo[num]), 0));
d1925 1
a1925 1
  if (LK (kn_decode_key, (&dc, dat, KEYNOTE_PUBLIC_KEY)) != 0)
d1928 1
a1928 1
    LK (kn_free_key, (&dc));
d2082 1
a2082 1
  foo = LK (kn_read_asserts, ((char *)scert, strlen ((char *)scert), &num));
d2089 1
a2089 1
  kid = LK (kn_init, ());
d2100 1
a2100 2
  sid = LK (kn_add_assertion, (kid, foo[num - 1],
			       strlen (foo[num - 1]), 0));
d2108 1
a2108 1
      LK (kn_close, (kid));
d2114 1
a2114 1
  kl = LK (kn_get_licensees, (kid, sid));
d2119 1
a2119 1
	  *(RSA **)keyp = LC (RSAPublicKey_dup, (kl->key_key));
d2126 2
a2127 2
  LK (kn_remove_assertion, (kid, sid));
  LK (kn_close, (kid));
@


1.52
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.51 2002/05/28 11:23:20 ho Exp $	*/
d760 1
a760 1
	  strlcpy (remote_id_addr_lower, remote_id_addr_upper, 
d2067 1
a2067 1
	snprintf (file + strlen (dirname) + 1 + id_len, 
@


1.51
log
@off_t to size_t change for printf format and malloc. Pointed out by <greg@@nest.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.50 2002/01/23 22:14:28 angelos Exp $	*/
d720 2
a721 2
	      log_error ("policy_callback: calloc (%d, %d) failed", len,
			 sizeof (char));
d746 2
a747 2
	      log_error ("policy_callback: calloc (%d, %d) failed", len,
			 sizeof (char));
d787 2
a788 2
	      log_error ("policy_callback: calloc (%d, %d) failed", len,
			 sizeof (char));
d824 2
a825 2
	      log_error ("policy_callback: calloc (%d, %d) failed", len,
			 sizeof (char));
d841 3
a843 3
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			 sizeof (char));
d856 3
a858 3
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			 sizeof (char));
d890 3
a892 3
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 2 * (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
			 sizeof (char));
d998 2
a999 2
		  log_error ("policy_callback: calloc (%d, %d) failed", len,
			     sizeof (char));
d1024 2
a1025 2
		  log_error ("policy_callback: calloc (%d, %d) failed", len,
			     sizeof (char));
d1065 2
a1066 2
		  log_error ("policy_callback: calloc (%d, %d) failed", len,
			     sizeof (char));
d1101 2
a1102 2
		  log_error ("policy_callback: calloc (%d, %d) failed", len,
			     sizeof (char));
d1117 2
a1118 2
		  log_error ("policy_callback: malloc (%d) failed",
			     idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1131 2
a1132 2
		  log_error ("policy_callback: malloc (%d) failed",
			     idremotesz - ISAKMP_ID_DATA_OFF + 1);
d1164 3
a1166 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1,
			     sizeof (char));
d1291 2
a1292 2
		  log_error ("policy_callback: calloc (%d, %d) failed", len,
			     sizeof (char));
d1316 2
a1317 2
		  log_error ("policy_callback: calloc (%d, %d) failed", len,
			     sizeof (char));
d1357 2
a1358 2
		  log_error ("policy_callback: calloc (%d, %d) failed", len,
			     sizeof (char));
d1393 2
a1394 2
		  log_error ("policy_callback: calloc (%d, %d) failed", len,
			     sizeof (char));
d1409 2
a1410 2
		  log_error ("policy_callback: malloc (%d) failed",
			     idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1423 2
a1424 2
		  log_error ("policy_callback: malloc (%d) failed",
			     idlocalsz - ISAKMP_ID_DATA_OFF + 1);
d1456 3
a1458 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
			     sizeof (char));
d1836 2
a1837 2
    log_fatal ("policy_init: calloc (%d, %d) failed", sz + 1,
	       sizeof (char));
d1844 2
a1845 2
	log_fatal ("policy_init: read (%d, %p, %d) failed", fd, ptr + len,
		   sz - len);
d1970 2
a1971 2
      log_error ("keynote_certreq_validate: calloc (%d, %d) failed", len + 1,
		 sizeof (char));
d2043 2
a2044 2
	  log_error ("keynote_cert_obtain: failed to allocate %d bytes",
		     len + strlen (addr_str));
d2060 2
a2061 2
	    log_error ("keynote_cert_obtain: failed to allocate %d bytes",
		       len + id_len);
d2088 2
a2089 2
      log_error ("keynote_cert_obtain: failed to allocate %d bytes",
		 size);
d2105 2
a2106 2
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to read %d "
		"bytes from \"%s\"", size, file));
@


1.50
log
@Actually return the ESP/AH/COMP ground descriptions for policy
comparisons -- from cjkim2000@@yahoo.com
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.49 2002/01/23 18:09:04 ho Exp $	*/
d1809 1
a1809 1
  off_t sz;
d2007 1
d2083 1
d2085 1
a2085 1
  *cert = calloc (sb.st_size + 1, sizeof (char));
d2089 1
a2089 1
		 sb.st_size);
d2103 1
a2103 1
  if (read (fd, *cert, sb.st_size) != sb.st_size)
d2106 1
a2106 1
		"bytes from \"%s\"", sb.st_size, file));
d2114 1
a2114 1
  *certlen = sb.st_size;
@


1.49
log
@no more strcpy/sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.48 2002/01/23 17:25:38 ho Exp $	*/
d1787 9
@


1.48
log
@strcpy->strlcpy, sprintf->snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.47 2002/01/03 09:24:02 ho Exp $	*/
d144 3
a146 2
  if (sprintf (tmp, fmt, ((u_int8_t *) &src2)[0], ((u_int8_t *) &src2)[1],
	       ((u_int8_t *) &src2)[2], ((u_int8_t *) &src2)[3]) > size)
d161 3
a163 3
  if (sprintf (tmp, fmt, src[0], src[1], src[2], src[3], src[4], src[5],
               src[6], src[7], src[8], src[9], src[10], src[11], src[12],
               src[13], src[14], src[15]) > size)
d715 3
a717 3
	  remote_id = calloc (strlen (remote_id_addr_upper)
			      + strlen (remote_id_addr_lower) + 2,
			      sizeof (char));
d720 1
a720 3
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 strlen (remote_id_addr_upper)
			 + strlen (remote_id_addr_lower) + 2,
d725 3
a727 4
	  strcpy (remote_id, remote_id_addr_lower);
	  remote_id[strlen (remote_id_addr_lower)] = '-';
	  strcpy (remote_id + strlen (remote_id_addr_lower) + 1,
		  remote_id_addr_upper);
d741 3
a743 3
	  remote_id = calloc (strlen (remote_id_addr_upper)
			      + strlen (remote_id_addr_lower) + 2,
			      sizeof (char));
d746 1
a746 3
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 strlen (remote_id_addr_upper)
			 + strlen (remote_id_addr_lower) + 2,
d751 3
a753 4
	  strcpy (remote_id, remote_id_addr_lower);
	  remote_id[strlen (remote_id_addr_lower)] = '-';
	  strcpy (remote_id + strlen (remote_id_addr_lower) + 1,
		  remote_id_addr_upper);
d760 2
a761 1
	  strcpy (remote_id_addr_lower, remote_id_addr_upper);
d782 3
a784 3
	  remote_id = calloc (strlen (remote_id_addr_upper) +
			      strlen (remote_id_addr_lower) + 2,
			      sizeof (char));
d787 1
a787 3
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 strlen (remote_id_addr_upper)
			 + strlen (remote_id_addr_lower) + 2,
d792 3
a794 4
	  strcpy (remote_id, remote_id_addr_lower);
	  remote_id[strlen (remote_id_addr_lower)] = '-';
	  strcpy (remote_id + strlen (remote_id_addr_lower) + 1,
		  remote_id_addr_upper);
d819 3
a821 3
	  remote_id = calloc (strlen (remote_id_addr_upper) +
			      strlen (remote_id_addr_lower) + 2,
			      sizeof (char));
d824 1
a824 3
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 strlen (remote_id_addr_upper)
			 + strlen (remote_id_addr_lower) + 2,
d829 3
a831 4
	  strcpy (remote_id, remote_id_addr_lower);
	  remote_id[strlen (remote_id_addr_lower)] = '-';
	  strcpy (remote_id + strlen (remote_id_addr_lower) + 1,
		  remote_id_addr_upper);
d993 3
a995 3
	      remote_filter = calloc (strlen (remote_filter_addr_upper)
				      + strlen (remote_filter_addr_lower) + 2,
				      sizeof (char));
d998 1
a998 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (remote_filter_addr_upper)
			     + strlen (remote_filter_addr_lower) + 2,
d1002 4
a1005 4
	      strcpy (remote_filter, remote_filter_addr_lower);
	      remote_filter[strlen (remote_filter_addr_lower)] = '-';
	      strcpy (remote_filter + strlen (remote_filter_addr_lower) + 1,
		      remote_filter_addr_upper);
d1019 3
a1021 3
	      remote_filter = calloc (strlen (remote_filter_addr_upper)
				      + strlen (remote_filter_addr_lower) + 2,
				      sizeof (char));
d1024 1
a1024 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (remote_filter_addr_upper)
			     + strlen (remote_filter_addr_lower) + 2,
d1028 3
a1030 4
	      strcpy (remote_filter, remote_filter_addr_lower);
	      remote_filter[strlen (remote_filter_addr_lower)] = '-';
	      strcpy (remote_filter + strlen (remote_filter_addr_lower) + 1,
		      remote_filter_addr_upper);
d1038 2
a1039 1
	      strcpy (remote_filter_addr_lower, remote_filter_addr_upper);
d1060 3
a1062 3
	      remote_filter = calloc (strlen (remote_filter_addr_upper) +
				      strlen (remote_filter_addr_lower) + 2,
				      sizeof (char));
d1065 1
a1065 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (remote_filter_addr_upper) +
			     strlen (remote_filter_addr_lower) + 2,
d1070 3
a1072 4
	      strcpy (remote_filter, remote_filter_addr_lower);
	      remote_filter[strlen (remote_filter_addr_lower)] = '-';
	      strcpy (remote_filter + strlen (remote_filter_addr_lower) + 1,
		      remote_filter_addr_upper);
d1096 3
a1098 3
	      remote_filter = calloc (strlen (remote_filter_addr_upper) +
				      strlen (remote_filter_addr_lower) + 2,
				      sizeof (char));
d1101 1
a1101 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (remote_filter_addr_upper) +
			     strlen (remote_filter_addr_lower) + 2,
d1106 3
a1108 4
	      strcpy (remote_filter, remote_filter_addr_lower);
	      remote_filter[strlen (remote_filter_addr_lower)] = '-';
	      strcpy (remote_filter + strlen (remote_filter_addr_lower) + 1,
		      remote_filter_addr_upper);
d1286 3
a1288 3
	      local_filter = calloc (strlen (local_filter_addr_upper)
				     + strlen (local_filter_addr_lower) + 2,
				     sizeof (char));
d1291 1
a1291 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (local_filter_addr_upper)
			     + strlen (local_filter_addr_lower) + 2,
d1295 3
a1297 4
	      strcpy (local_filter, local_filter_addr_lower);
	      local_filter[strlen (local_filter_addr_lower)] = '-';
	      strcpy (local_filter + strlen (local_filter_addr_lower) + 1,
		      local_filter_addr_upper);
d1311 3
a1313 3
	      local_filter = calloc (strlen (local_filter_addr_upper)
				     + strlen (local_filter_addr_lower) + 2,
				     sizeof (char));
d1316 1
a1316 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (local_filter_addr_upper)
			     + strlen (local_filter_addr_lower) + 2,
d1320 3
a1322 4
	      strcpy (local_filter, local_filter_addr_lower);
	      local_filter[strlen (local_filter_addr_lower)] = '-';
	      strcpy (local_filter + strlen (local_filter_addr_lower) + 1,
		      local_filter_addr_upper);
d1330 2
a1331 1
	      strcpy (local_filter_addr_lower, local_filter_addr_upper);
d1352 3
a1354 3
	      local_filter = calloc (strlen (local_filter_addr_upper) +
				      strlen (local_filter_addr_lower) + 2,
				      sizeof (char));
d1357 1
a1357 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (local_filter_addr_upper) +
			     strlen (local_filter_addr_lower) + 2,
d1362 3
a1364 4
	      strcpy (local_filter, local_filter_addr_lower);
	      local_filter[strlen (local_filter_addr_lower)] = '-';
	      strcpy (local_filter + strlen (local_filter_addr_lower) + 1,
		      local_filter_addr_upper);
d1388 3
a1390 3
	      local_filter = calloc (strlen (local_filter_addr_upper) +
				      strlen (local_filter_addr_lower) + 2,
				      sizeof (char));
d1393 1
a1393 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (local_filter_addr_upper) +
			     strlen (local_filter_addr_lower) + 2,
d1398 3
a1400 4
	      strcpy (local_filter, local_filter_addr_lower);
	      local_filter[strlen (local_filter_addr_lower)] = '-';
	      strcpy (local_filter + strlen (local_filter_addr_lower) + 1,
		      local_filter_addr_upper);
@


1.47
log
@strftime format fixes. From Christo Butcher <christo@@fox-it.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.46 2001/08/26 01:48:12 niklas Exp $	*/
d150 1
a150 1
  strcpy (dst, tmp);
d167 1
a167 1
  strcpy (dst, tmp);
d189 1
d192 7
a198 6
  static char *comp_alg, ah_life_kbytes[32], ah_life_seconds[32];
  static char esp_life_kbytes[32], esp_life_seconds[32], comp_life_kbytes[32];
  static char comp_life_seconds[32], *ah_encapsulation, *esp_encapsulation;
  static char *comp_encapsulation, ah_key_length[32], esp_key_length[32];
  static char ah_key_rounds[32], esp_key_rounds[32], comp_dict_size[32];
  static char comp_private_alg[32], *remote_filter_type, *local_filter_type;
d203 1
a203 1
  static char ah_group_desc[32], esp_group_desc[32], comp_group_desc[32];
d208 2
a209 2
  static char *remote_id_proto, remote_id_port[32];
  static char remote_filter_port[32], local_filter_port[32];
d213 1
a213 1
  static char phase1_group[32];
d292 1
a292 1
      sprintf (phase1_group, "%u", is->group_desc);
d436 2
a437 2
			    sprintf (ah_life_seconds, "%u",
				     decode_16 (value));
d439 2
a440 2
			    sprintf (ah_life_seconds, "%u",
				     decode_32 (value));
d445 2
a446 2
			    sprintf (ah_life_kbytes, "%u",
				     decode_16 (value));
d448 2
a449 2
			    sprintf (ah_life_kbytes, "%u",
				     decode_32 (value));
d458 2
a459 2
			    sprintf (esp_life_seconds, "%u",
				     decode_16 (value));
d461 2
a462 2
			    sprintf (esp_life_seconds, "%u",
				     decode_32 (value));
d467 2
a468 2
			    sprintf (esp_life_kbytes, "%u",
				     decode_16 (value));
d470 2
a471 2
			    sprintf (esp_life_kbytes, "%u",
				     decode_32 (value));
d480 2
a481 2
			    sprintf (comp_life_seconds, "%u",
				     decode_16 (value));
d483 2
a484 2
			    sprintf (comp_life_seconds, "%u",
				     decode_32 (value));
d489 2
a490 2
			    sprintf (comp_life_kbytes, "%u",
				     decode_16 (value));
d492 2
a493 2
			    sprintf (comp_life_kbytes, "%u",
				     decode_32 (value));
d504 1
a504 1
		      sprintf (ah_group_desc, "%u", decode_16 (value));
d508 1
a508 1
		      sprintf (esp_group_desc, "%u",
d513 1
a513 1
		      sprintf (comp_group_desc, "%u",
d611 1
a611 1
		      sprintf (ah_key_length, "%u", decode_16 (value));
d615 1
a615 1
		      sprintf (esp_key_length, "%u",
d625 1
a625 1
		      sprintf (ah_key_rounds, "%u", decode_16 (value));
d629 1
a629 1
		      sprintf (esp_key_rounds, "%u",
d636 1
a636 1
		  sprintf (comp_dict_size, "%u", decode_16 (value));
d640 1
a640 1
		  sprintf (comp_private_alg, "%u", decode_16 (value));
d652 1
a652 2
      strncpy (local_ike_address, addr, sizeof local_ike_address);
      local_ike_address[sizeof local_ike_address - 1] = '\0';
d661 1
a661 2
      strncpy (remote_ike_address, addr, sizeof remote_ike_address);
      remote_ike_address[sizeof remote_ike_address - 1] = '\0';
d947 1
a947 1
	  sprintf (remote_id_proto_num, "%2d", id[1]);
d1232 1
a1232 1
	      sprintf (remote_filter_proto_num, "%2d",
d1535 1
a1535 1
	      sprintf (local_filter_proto_num, "%2d",
d2070 2
a2071 1
      sprintf (file, "%s/%s/%s", dirname, addr_str, CREDENTIAL_FILE);
d2086 4
a2089 3
	sprintf (file, "%s/", dirname);
	memcpy (file + strlen (file), id, id_len);
	sprintf (file + strlen (dirname) + 1 + id_len, "/%s", CREDENTIAL_FILE);
@


1.46
log
@more style
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.45 2001/08/25 22:22:11 niklas Exp $	*/
d1658 1
a1658 1
      strftime (mytimeofday, 14, "%G%m%d%H%M%S", gmtime (&tt));
d1665 1
a1665 1
      strftime (mytimeofday, 14, "%G%m%d%H%M%S", localtime (&tt));
@


1.45
log
@Use x509_DN_string API.  Style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.44 2001/08/24 11:19:01 ho Exp $	*/
d1476 2
a1477 1
	    case IPSEC_ID_DER_ASN1_GN: /* XXX -- not sure what's in this.  */
@


1.44
log
@I was only going to remove #include "init.h", but found 8 more
#include's we don't need here.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.43 2001/08/11 05:26:59 angelos Exp $	*/
a186 1
  X509_NAME *x509name;
d878 3
a880 1
	  remote_id = calloc (257, sizeof (char));
a882 15
	      log_error ("policy_callback: calloc (%d, %d) failed", 257,
			 sizeof (char));
	      goto bad;
	    }

	  addr = id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
	  x509name = LC (d2i_X509_NAME, (NULL, (unsigned char **) &addr,
			 id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ));
	  if (!x509name)
	    {
	      log_error ("policy_callback: failed to initialize DN");
	      goto bad;
	    }
	  if (!LC (X509_NAME_oneline, (x509name, remote_id, 256)))
	    {
d884 1
a884 2
		        "policy_callback: failed to decode name"));
	      LC (X509_NAME_free, (x509name));
a885 1

a886 1
	  LC (X509_NAME_free, (x509name));
d1134 1
a1134 2
	      remote_filter = calloc (idremotesz - ISAKMP_ID_DATA_OFF + 1,
				      sizeof (char));
d1137 2
a1138 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     idremotesz - ISAKMP_ID_DATA_OFF + 1,
			     sizeof (char));
d1142 2
a1143 1
		      idremotesz);
d1148 1
a1148 2
	      remote_filter = calloc (idremotesz - ISAKMP_ID_DATA_OFF + 1,
				      sizeof (char));
d1151 2
a1152 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     idremotesz - ISAKMP_ID_DATA_OFF + 1,
			     sizeof (char));
d1156 2
a1157 1
		      idremotesz);
d1163 2
a1164 1
	      remote_filter = calloc (257, sizeof (char));
a1166 15
		  log_error ("policy_callback: calloc (%d, %d) failed", 257,
			     sizeof (char));
		  goto bad;
		}

	      addr = idremote + ISAKMP_ID_DATA_OFF;
	      x509name = LC (d2i_X509_NAME, (NULL, (unsigned char **) &addr,
			     idremotesz - ISAKMP_ID_DATA_OFF));
	      if (!x509name)
	        {
		  log_error ("policy_callback: failed to initialize DN");
		  goto bad;
		}
	      if (!LC (X509_NAME_oneline, (x509name, remote_filter, 256)))
	        {
a1168 1
		  LC (X509_NAME_free, (x509name));
a1170 1
	      LC (X509_NAME_free, (x509name));
d1437 1
a1437 2
	      local_filter = calloc (idlocalsz - ISAKMP_ID_DATA_OFF + 1,
				     sizeof (char));
d1440 2
a1441 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     idlocalsz - ISAKMP_ID_DATA_OFF + 1,
			     sizeof (char));
d1445 2
a1446 1
		      idlocalsz);
d1451 1
a1451 2
	      local_filter = calloc (idlocalsz - ISAKMP_ID_DATA_OFF + 1,
				     sizeof (char));
d1454 2
a1455 3
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     idlocalsz - ISAKMP_ID_DATA_OFF + 1,
			     sizeof (char));
d1459 2
a1460 1
		      idlocalsz);
d1466 2
a1467 1
	      local_filter = calloc (257, sizeof (char));
a1469 15
		  log_error ("policy_callback: calloc (%d, %d) failed", 257,
			     sizeof (char));
		  goto bad;
		}

	      addr = idlocal + ISAKMP_ID_DATA_OFF;
	      x509name = LC (d2i_X509_NAME, (NULL, (unsigned char **) &addr,
			     idlocalsz - ISAKMP_ID_DATA_OFF));
	      if (!x509name)
	        {
		  log_error ("policy_callback: failed to initialize DN");
		  goto bad;
		}
	      if (!LC (X509_NAME_oneline, (x509name, local_filter, 256)))
	        {
a1471 1
		  LC (X509_NAME_free, (x509name));
a1473 1
	      LC (X509_NAME_free, (x509name));
@


1.43
log
@Allocate slightly larger buffer for cert.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.42 2001/07/05 07:29:59 angelos Exp $	*/
a60 1
#include "app.h"
a61 3
#include "connection.h"
#include "cookie.h"
#include "doi.h"
a63 1
#include "init.h"
a65 1
#include "math_group.h"
a66 1
#include "timer.h"
a67 1
#include "udp.h"
a69 1
#include "ui.h"
@


1.42
log
@DER_ASN1_DN ID handling --- untested
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.41 2001/07/04 22:16:32 angelos Exp $	*/
d2164 1
a2164 1
  *cert = calloc (sb.st_size, sizeof (char));
@


1.41
log
@Better handling of Key IDs.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.40 2001/07/03 23:39:01 angelos Exp $	*/
d196 1
d885 1
a885 1
	case IPSEC_ID_DER_ASN1_DN: /* XXX -- not sure what's in this.  */
d887 26
d915 1
a915 1
	case IPSEC_ID_DER_ASN1_GN: /* XXX -- not sure what's in this.  */
d1188 1
a1188 1
	    case IPSEC_ID_DER_ASN1_DN: /* XXX -- not sure what's in this.  */
d1190 25
d1509 1
a1509 1
	    case IPSEC_ID_DER_ASN1_DN: /* XXX -- not sure what's in this.  */
d1511 25
@


1.40
log
@Fix policy information for IPv6 subnet/range cases. This is ugly, I'll
have to find another way of dealing with IPv6 addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.39 2001/07/03 11:00:52 ho Exp $	*/
d904 11
d1181 11
d1476 12
a1487 1
              for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
@


1.39
log
@Wait with strlcpy a while, change to strncpy.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.38 2001/07/03 08:07:22 ho Exp $	*/
d57 1
d206 4
a209 2
  static char remote_filter_addr_upper[64], remote_filter_addr_lower[64];
  static char local_filter_addr_upper[64], local_filter_addr_lower[64];
d211 5
a215 3
  static char remote_ike_address[64], local_ike_address[64];
  static char *remote_id_type, remote_id_addr_upper[64], *phase_1;
  static char remote_id_addr_lower[64], *remote_id_proto, remote_id_port[32];
d773 1
a773 1
	                 remote_id_addr_upper, sizeof remote_id_addr_upper);
a784 1
	  /* XXX Not yet implemented.  */
d786 25
d814 37
a850 2
	  /* XXX Not yet implemented.  */
	  remote_id_type = "IPv6 address";
d852 1
a1051 1
	      /* XXX Not yet implemented.  */
d1053 25
d1081 3
a1083 1
	      /* XXX Not yet implemented.  */
d1085 32
d1118 1
a1336 1
	      /* XXX Not yet implemented.  */
d1338 25
d1366 3
a1368 1
	      /* XXX Not yet implemented.  */
d1370 32
d1403 1
@


1.38
log
@use strlcpy instead of memcpy to copy strings
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.37 2001/07/01 19:48:44 niklas Exp $	*/
d654 2
a655 1
      strlcpy (local_ike_address, addr, sizeof local_ike_address);
d664 2
a665 1
      strlcpy (remote_ike_address, addr, sizeof remote_ike_address);
@


1.37
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.36 2001/07/01 18:57:33 angelos Exp $	*/
d654 1
a654 1
      memcpy (local_ike_address, addr, sizeof local_ike_address);
d663 1
a663 1
      memcpy (remote_ike_address, addr, sizeof remote_ike_address);
@


1.36
log
@Start support for IPv6 addresses in policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.35 2001/07/01 05:42:05 angelos Exp $	*/
d1106 1
a1106 1
	  memcpy (remote_filter_addr_upper, addr, 
d1108 1
a1108 1
	  memcpy (remote_filter_addr_lower, addr, 
d1333 1
a1333 1
	  memcpy (local_filter_addr_upper, addr, 
d1335 1
a1335 1
	  memcpy (local_filter_addr_lower, addr, 
@


1.35
log
@Fix remote_negotiation_address attribute; fix sockaddr2text() return
value when zero-filling; log_error()->log_print() consistently.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.34 2001/06/29 18:52:17 ho Exp $	*/
d162 17
a763 1
	  /* XXX Not yet implemented.  */
d765 10
a969 1
	      /* XXX Not yet implemented.  */
d971 11
d991 1
a991 1
	      remote_filter_type = "IPv6 address";
a1195 1
	      /* XXX Not yet implemented.  */
d1197 11
d1217 1
a1217 1
	      local_filter_type = "IPv6 address";
@


1.34
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.33 2001/06/29 04:12:01 ho Exp $	*/
d646 1
a646 1
      memcpy (local_ike_address, addr, sizeof remote_ike_address);
@


1.33
log
@Initial IPv6 support. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.32 2001/06/07 04:46:45 angelos Exp $	*/
d631 1
a631 1
      policy_sa->transport->vtbl->get_src (policy_sa->transport, &sin, &fmt);
d640 1
a640 1
      policy_sa->transport->vtbl->get_dst (policy_sa->transport, &sin, &fmt);
d1051 1
a1051 2
	  policy_sa->transport->vtbl->get_dst (policy_sa->transport, &sin,
					       &fmt);
d1267 1
a1267 2
					       (struct sockaddr **)&sin,
					       &fmt);
@


1.32
log
@No need to allocate/free X509 policy information -- the certs are
converted as needed, and the CA certs are irrelevant.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.31 2001/06/07 04:23:35 angelos Exp $	*/
d7 1
d169 1
a169 1
  struct sockaddr_in *sin;
d176 1
d631 17
a647 10
      /* XXX IPv4-specific.  */
      policy_sa->transport->vtbl->get_src (policy_sa->transport,
					   (struct sockaddr **)&sin, &fmt);
      my_inet_ntop4 (&(sin->sin_addr.s_addr), local_ike_address,
		     sizeof local_ike_address - 1, 0);

      policy_sa->transport->vtbl->get_dst (policy_sa->transport,
					   (struct sockaddr **)&sin, &fmt);
      my_inet_ntop4 (&(sin->sin_addr.s_addr), remote_ike_address,
		     sizeof remote_ike_address - 1, 0);
d1051 1
a1051 2
	  policy_sa->transport->vtbl->get_dst (policy_sa->transport,
					       (struct sockaddr **) &sin,
d1053 23
a1075 6
	  remote_filter_type = "IPv4 address";

	  my_inet_ntop4 (&(sin->sin_addr.s_addr), remote_filter_addr_upper,
			 sizeof remote_filter_addr_upper - 1, 0);
	  my_inet_ntop4 (&(sin->sin_addr.s_addr), remote_filter_addr_lower,
			 sizeof remote_filter_addr_lower - 1, 0);
d1270 13
d1284 10
a1293 6
	  local_filter_type = "IPv4 address";

	  my_inet_ntop4 (&(sin->sin_addr.s_addr), local_filter_addr_upper,
			 sizeof local_filter_addr_upper - 1, 0);
	  my_inet_ntop4 (&(sin->sin_addr.s_addr), local_filter_addr_lower,
			 sizeof local_filter_addr_lower - 1, 0);
d1749 1
a1749 1
  char *dirname, *file;
d1777 14
a1790 2
      {
	struct in_addr in;
d1792 3
a1794 12
	file = calloc (len + 15, sizeof (char));
	if (file == NULL)
	  {
	    log_error ("keynote_cert_obtain: failed to allocate %d bytes",
		       len + 15);
	    return 0;
	  }

	memcpy (&in, id, sizeof in);
	sprintf (file, "%s/%s/%s", dirname, inet_ntoa (in), CREDENTIAL_FILE);
	break;
      }
@


1.31
log
@Get rid of the main policy session (unnecessary).
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.30 2001/06/07 03:15:15 angelos Exp $	*/
a126 3
char **x509_policy_asserts = NULL;
int x509_policy_asserts_num = 0;
int x509_policy_asserts_num_alloc = 0;
@


1.30
log
@Add some log_print()
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.29 2001/05/31 20:21:08 angelos Exp $	*/
a124 1
int keynote_sessid = -1;
a1523 9
  /* If there exists a session already, release all its resources.  */
  if (keynote_sessid != -1)
    LK (kn_close, (keynote_sessid));

  /* Initialize a session.  */
  keynote_sessid = LK (kn_init, ());
  if (keynote_sessid == -1)
    log_fatal ("policy_init: kn_init () failed");

d1562 2
a1563 10
  /* Add each individual policy in the session.  */
  for (fd = 0; fd < i; fd++)
    {
      if (LK (kn_add_assertion, (keynote_sessid, asserts[fd],
				 strlen (asserts[fd]), ASSERT_FLAG_LOCAL))
	  == -1)
        log_print ("policy_init: "
		   "kn_add_assertion (%d, %p, %d, ASSERT_FLAG_LOCAL) failed",
                   keynote_sessid, asserts[fd], strlen (asserts[fd]));
    }
d1829 1
a1829 1
  int sid, num;
d1839 12
a1850 1
  sid = LK (kn_add_assertion, (keynote_sessid, foo[num - 1],
d1859 1
d1865 1
a1865 1
  kl = LK (kn_get_licensees, (keynote_sessid, sid));
d1877 2
a1878 1
  LK (kn_remove_assertion, (keynote_sessid, sid));
@


1.29
log
@Routines for handling KeyNote cert representation.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.28 2001/04/09 12:34:38 ho Exp $	*/
d1852 4
a1855 1
    return 0;
d1858 1
a1858 1
			       strlen (scert), 0));
d1864 4
a1867 1
    return 0;
@


1.28
log
@Style police a'la niklas@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.27 2001/04/05 23:18:53 ho Exp $	*/
d1608 1
a1608 1
  char *foo = calloc (len + 1, sizeof (char));
d1614 1
d1879 29
@


1.27
log
@As the isakmpd.policy file can contain sensitive information, we want
the same mode checks we use for isakmpd.conf. Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.26 2001/03/14 21:13:24 tholo Exp $	*/
d874 1
a874 1
			     sizeof (remote_filter_addr_lower) - 1, 1);
d1608 1
a1608 1
  char *foo = calloc (len + 1, sizeof(char));
d1758 1
a1758 1
	file = calloc (len + 15, sizeof(char));
d1766 1
a1766 1
	memcpy (&in, id, sizeof(in));
d1774 1
a1774 1
        file = calloc (len + id_len, sizeof(char));
@


1.26
log
@Make these compile again...
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.25 2001/03/14 12:15:45 niklas Exp $	*/
d1515 1
a1515 1
  struct stat st;
d1535 1
a1535 1
  policy_file = conf_get_str ("General", "policy-file");
d1539 4
a1547 4
  /* Get size.  */
  if (fstat (fd, &st) == -1)
    log_fatal ("policy_init: fstat (%d, &st) failed", fd);

d1549 1
a1549 1
  ptr = calloc (st.st_size + 1, sizeof (char));
d1551 1
a1551 1
    log_fatal ("policy_init: calloc (%d, %d) failed", st.st_size,
d1555 1
a1555 1
  for (len = 0; len < st.st_size; len += i)
d1557 1
a1557 1
      i = read (fd, ptr + len, st.st_size - len);
d1560 1
a1560 1
		   st.st_size - len);
d1567 1
a1567 1
  asserts = LK (kn_read_asserts, (ptr, st.st_size, &i));
@


1.25
log
@Indentation and style fascism
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.24 2001/03/13 14:05:19 ho Exp $	*/
d1693 1
a1693 1
		 sizeof (char))
@


1.24
log
@Add logging classes for Negotiation and Policy, and change a number of
debug messages to use these instead. Change a number of 'log_print'
to debug messages to keep the noise down. Use 'log_error' instead of
'log_print' in some cases when we have errno. Some indentation fixes.
(niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.23 2001/03/07 07:36:34 angelos Exp $	*/
d136 2
a137 2
     '0', '1', '2', '3', '4', '5', '6', '7',
     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
d397 1
a397 1
		
d635 1
a635 1
					   (struct sockaddr **) &sin, &fmt);
d640 1
a640 1
					   (struct sockaddr **) &sin, &fmt);
d645 4
a648 4
      {
	  case ISAKMP_EXCH_AGGRESSIVE:
	      phase_1 = "aggressive";
	      break;
d650 4
a653 4
 	  case ISAKMP_EXCH_ID_PROT:
	      phase_1 = "main";
	      break;
      }
d705 1
a705 1
		
d767 1
a767 1
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, 
d782 1
a782 1
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, 
d796 3
a798 1
	  remote_id = calloc (2 * (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1, sizeof (char));
d808 4
a811 2
	      remote_id[2 * i] = hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) >> 4];
	      remote_id[2 * i + 1] = hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) & 0xF];
d993 3
a995 1
	      remote_filter = calloc (2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1, sizeof (char));
d998 2
a999 2
		  log_error ("policy_callback: calloc (%d, %d) failed", 
			     2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1, 
d1005 4
a1008 2
		  remote_filter[2 * i] = hextab[*(idremote + ISAKMP_ID_DATA_OFF) >> 4];
		  remote_filter[2 * i + 1] = hextab[*(idremote + ISAKMP_ID_DATA_OFF) & 0xF];
d1027 1
a1027 1
	
d1035 1
a1035 1
	      sprintf (remote_filter_proto_num, "%2d", 
d1194 2
a1195 1
	      local_filter = calloc (2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1, sizeof (char));
d1198 2
a1199 2
		  log_error ("policy_callback: calloc (%d, %d) failed", 
			     2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1, 
d1205 4
a1208 2
		  local_filter[2 * i] = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) >> 4];
		  local_filter[2 * i + 1] = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) & 0xF];
d1235 1
a1235 1
	      sprintf (local_filter_proto_num, "%2d", 
d1247 1
a1247 1
					       (struct sockaddr **) &sin,
d1282 1
a1282 1
      LOG_DBG ((LOG_POLICY, 80, "comp_encapsulation == %s", 
d1293 1
a1293 1
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_type == %s", 
d1301 1
a1301 1
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_port == %s", 
d1303 1
a1303 1
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_proto == %s", 
d1313 1
a1313 1
      LOG_DBG ((LOG_POLICY, 80, "local_filter_proto == %s", 
d1320 1
a1320 1
      LOG_DBG ((LOG_POLICY, 80, "remote_id == %s", 
d1604 1
a1604 1
/* Just copy and return */
d1637 2
a1638 2
      if (LK (kn_verify_assertion, (scert, strlen ((char *) scert))) !=
	  SIGRESULT_TRUE)
d1653 1
a1653 1
/* Add received credentials */
d1674 1
a1674 1
/* Just regular memory free */
d1681 1
a1681 1
/* Verify that the key given to us is valid */
d1685 3
a1687 3
    struct keynote_deckey dc;
    int err = 1;
    char *dat;
d1689 7
a1695 3
    dat = calloc (len + 1, sizeof(char));
    if (dat == NULL)
      return 0;
d1697 1
a1697 1
    memcpy (dat, data, len);
d1699 4
a1702 4
    if (LK (kn_decode_key, (&dc, dat, KEYNOTE_PUBLIC_KEY)) != 0)
      err = 0;
    else
      LK (kn_free_key, (&dc));
d1704 1
a1704 1
    free (dat);
d1706 1
a1706 1
    return err;
d1709 1
a1709 1
/* Beats me what we should be doing with this */
d1737 1
a1737 1
  /* Get type of ID */
d1745 1
a1745 1
      LOG_DBG ((LOG_POLICY, 30, 
d1794 1
a1794 1
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to stat \"%s\"", 
d1800 1
a1800 1
  *cert = calloc (sb.st_size, sizeof(char));
d1833 1
a1833 1
/* This should never be called */
d1841 1
a1841 1
/* Get the Authorizer key */
d1849 2
a1850 2
  foo = LK (kn_read_asserts, ((char *) scert, strlen ((char *) scert), &num));
  if ((foo == NULL) || (num == 0))
d1868 1
a1868 1
      {
d1871 1
a1871 1
      }
@


1.23
log
@Oops, use the right legnth for the key id.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.22 2001/03/07 07:33:53 angelos Exp $	*/
d679 3
a681 3
		log_print ("policy_callback: strdup (\"%s\") failed",
			   remote_id_addr_upper);
		goto bad;
d699 5
a703 5
		log_print ("policy_callback: calloc (%d, %d) failed",
			   strlen (remote_id_addr_upper)
			   + strlen (remote_id_addr_lower) + 2,
			   sizeof (char));
		goto bad;
d728 5
a732 5
		log_print ("policy_callback: calloc (%d, %d) failed",
			   strlen (remote_id_addr_upper)
			   + strlen (remote_id_addr_lower) + 2,
			   sizeof (char));
		goto bad;
d762 4
a765 4
		log_print ("policy_callback: calloc (%d, %d) failed",
			   id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			   sizeof (char));
		goto bad;
d777 4
a780 4
		log_print ("policy_callback: calloc (%d, %d) failed",
			   id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			   sizeof (char));
		goto bad;
d799 4
a802 4
		log_print ("policy_callback: calloc (%d, %d) failed",
			   2 * (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
			   sizeof (char));
		goto bad;
d806 2
a807 2
		remote_id[2 * i] = hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) >> 4];
		remote_id[2 * i + 1] = hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) & 0xF];
d874 3
a876 3
		    log_print ("policy_callback: strdup (\"%s\") failed",
			       remote_filter_addr_upper);
		    goto bad;
d894 5
a898 5
		    log_print ("policy_callback: calloc (%d, %d) failed",
			       strlen (remote_filter_addr_upper)
			       + strlen (remote_filter_addr_lower) + 2,
			       sizeof (char));
		    goto bad;
d922 5
a926 5
		    log_print ("policy_callback: calloc (%d, %d) failed",
			       strlen (remote_filter_addr_upper)
			       + strlen (remote_filter_addr_lower) + 2,
			       sizeof (char));
		    goto bad;
d955 4
a958 4
		    log_print ("policy_callback: calloc (%d, %d) failed",
			       idremotesz - ISAKMP_ID_DATA_OFF + 1,
			       sizeof (char));
		    goto bad;
d970 4
a973 4
		    log_print ("policy_callback: calloc (%d, %d) failed",
			       idremotesz - ISAKMP_ID_DATA_OFF + 1,
			       sizeof (char));
		    goto bad;
d992 4
a995 2
		    log_print ("policy_callback: calloc (%d, %d) failed", 2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1, sizeof (char));
		    goto bad;
d999 2
a1000 2
		    remote_filter[2 * i] = hextab[*(idremote + ISAKMP_ID_DATA_OFF) >> 4];
		    remote_filter[2 * i + 1] = hextab[*(idremote + ISAKMP_ID_DATA_OFF) & 0xF];
d1027 2
a1028 1
	      sprintf (remote_filter_proto_num, "%2d", idremote[ISAKMP_GEN_SZ + 1]);
d1050 3
a1052 3
		log_print ("policy_callback: strdup (\"%s\") failed",
			   remote_filter_addr_upper);
		goto bad;
d1071 3
a1073 3
		    log_print ("policy_callback: strdup (\"%s\") failed",
			       local_filter_addr_upper);
		    goto bad;
d1091 5
a1095 5
		    log_print ("policy_callback: calloc (%d, %d) failed",
			       strlen (local_filter_addr_upper)
			       + strlen (local_filter_addr_lower) + 2,
			       sizeof (char));
		    goto bad;
d1119 5
a1123 5
		    log_print ("policy_callback: calloc (%d, %d) failed",
			       strlen (local_filter_addr_upper)
			       + strlen (local_filter_addr_lower) + 2,
			       sizeof (char));
		    goto bad;
d1152 4
a1155 4
		    log_print ("policy_callback: calloc (%d, %d) failed",
			       idlocalsz - ISAKMP_ID_DATA_OFF + 1,
			       sizeof (char));
		    goto bad;
d1167 4
a1170 4
		    log_print ("policy_callback: calloc (%d, %d) failed",
			       idlocalsz - ISAKMP_ID_DATA_OFF + 1,
			       sizeof (char));
		    goto bad;
d1189 4
a1192 2
		    log_print ("policy_callback: calloc (%d, %d) failed", 2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1, sizeof (char));
		    goto bad;
d1196 2
a1197 2
		    local_filter[2 * i] = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) >> 4];
		    local_filter[2 * i + 1] = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) & 0xF];
d1224 2
a1225 1
	      sprintf (local_filter_proto_num, "%2d", idlocal[ISAKMP_GEN_SZ + 1]);
d1248 3
a1250 3
		log_print ("policy_callback: strdup (\"%s\") failed",
			   local_filter_addr_upper);
		goto bad;
d1254 31
a1284 29
      LOG_DBG ((LOG_SA, 80, "Policy context (action attributes):"));
      LOG_DBG ((LOG_SA, 80, "esp_present == %s", esp_present));
      LOG_DBG ((LOG_SA, 80, "ah_present == %s", ah_present));
      LOG_DBG ((LOG_SA, 80, "comp_present == %s", comp_present));
      LOG_DBG ((LOG_SA, 80, "ah_hash_alg == %s", ah_hash_alg));
      LOG_DBG ((LOG_SA, 80, "esp_enc_alg == %s", esp_enc_alg));
      LOG_DBG ((LOG_SA, 80, "comp_alg == %s", comp_alg));
      LOG_DBG ((LOG_SA, 80, "ah_auth_alg == %s", ah_auth_alg));
      LOG_DBG ((LOG_SA, 80, "esp_auth_alg == %s", esp_auth_alg));
      LOG_DBG ((LOG_SA, 80, "ah_life_seconds == %s", ah_life_seconds));
      LOG_DBG ((LOG_SA, 80, "ah_life_kbytes == %s", ah_life_kbytes));
      LOG_DBG ((LOG_SA, 80, "esp_life_seconds == %s", esp_life_seconds));
      LOG_DBG ((LOG_SA, 80, "esp_life_kbytes == %s", esp_life_kbytes));
      LOG_DBG ((LOG_SA, 80, "comp_life_seconds == %s", comp_life_seconds));
      LOG_DBG ((LOG_SA, 80, "comp_life_kbytes == %s", comp_life_kbytes));
      LOG_DBG ((LOG_SA, 80, "ah_encapsulation == %s", ah_encapsulation));
      LOG_DBG ((LOG_SA, 80, "esp_encapsulation == %s", esp_encapsulation));
      LOG_DBG ((LOG_SA, 80, "comp_encapsulation == %s", comp_encapsulation));
      LOG_DBG ((LOG_SA, 80, "comp_dict_size == %s", comp_dict_size));
      LOG_DBG ((LOG_SA, 80, "comp_private_alg == %s", comp_private_alg));
      LOG_DBG ((LOG_SA, 80, "ah_key_length == %s", ah_key_length));
      LOG_DBG ((LOG_SA, 80, "ah_key_rounds == %s", ah_key_rounds));
      LOG_DBG ((LOG_SA, 80, "esp_key_length == %s", esp_key_length));
      LOG_DBG ((LOG_SA, 80, "esp_key_rounds == %s", esp_key_rounds));
      LOG_DBG ((LOG_SA, 80, "ah_group_desc == %s", ah_group_desc));
      LOG_DBG ((LOG_SA, 80, "esp_group_desc == %s", esp_group_desc));
      LOG_DBG ((LOG_SA, 80, "comp_group_desc == %s", comp_group_desc));
      LOG_DBG ((LOG_SA, 80, "remote_filter_type == %s", remote_filter_type));
      LOG_DBG ((LOG_SA, 80, "remote_filter_addr_upper == %s",
d1286 1
a1286 1
      LOG_DBG ((LOG_SA, 80, "remote_filter_addr_lower == %s",
d1288 1
a1288 1
      LOG_DBG ((LOG_SA, 80, "remote_filter == %s",
d1290 6
a1295 4
      LOG_DBG ((LOG_SA, 80, "remote_filter_port == %s", remote_filter_port));
      LOG_DBG ((LOG_SA, 80, "remote_filter_proto == %s", remote_filter_proto));
      LOG_DBG ((LOG_SA, 80, "local_filter_type == %s", local_filter_type));
      LOG_DBG ((LOG_SA, 80, "local_filter_addr_upper == %s",
d1297 1
a1297 1
      LOG_DBG ((LOG_SA, 80, "local_filter_addr_lower == %s",
d1299 1
a1299 1
      LOG_DBG ((LOG_SA, 80, "local_filter == %s",
d1301 5
a1305 4
      LOG_DBG ((LOG_SA, 80, "local_filter_port == %s", local_filter_port));
      LOG_DBG ((LOG_SA, 80, "local_filter_proto == %s", local_filter_proto));
      LOG_DBG ((LOG_SA, 80, "remote_id_type == %s", remote_id_type));
      LOG_DBG ((LOG_SA, 80, "remote_id_addr_upper == %s",
d1307 1
a1307 1
      LOG_DBG ((LOG_SA, 80, "remote_id_addr_lower == %s",
d1309 5
a1313 4
      LOG_DBG ((LOG_SA, 80, "remote_id == %s", (remote_id ? remote_id : "")));
      LOG_DBG ((LOG_SA, 80, "remote_id_port == %s", remote_id_port));
      LOG_DBG ((LOG_SA, 80, "remote_id_proto == %s", remote_id_proto));
      LOG_DBG ((LOG_SA, 80, "remote_negotiation_address == %s",
d1315 1
a1315 1
      LOG_DBG ((LOG_SA, 80, "local_negotiation_address == %s",
d1317 3
a1319 3
      LOG_DBG ((LOG_SA, 80, "pfs == %s", pfs));
      LOG_DBG ((LOG_SA, 80, "initiator == %s", initiator));
      LOG_DBG ((LOG_SA, 80, "phase1_group_desc == %s", phase1_group));
d1330 3
a1332 3
	tt = time ((time_t) NULL);
	strftime (mytimeofday, 14, "%G%m%d%H%M%S", gmtime (&tt));
	return mytimeofday;
d1337 3
a1339 3
	tt = time ((time_t) NULL);
	strftime (mytimeofday, 14, "%G%m%d%H%M%S", localtime (&tt));
	return mytimeofday;
d1507 1
a1507 1
  LOG_DBG ((LOG_MISC, 50, "policy_init: initializing"));
d1730 2
a1731 1
      log_print ("keynote_cert_obtain: no Credential-directory");
d1746 1
a1746 1
	    log_print ("keynote_cert_obtain: failed to allocate %d bytes",
d1762 1
a1762 1
	    log_print ("keynote_cert_obtain: failed to allocate %d bytes",
d1779 2
a1780 1
      log_print ("keynote_cert_obtain: failed to stat \"%s\"", file);
d1788 1
a1788 1
      log_print ("keynote_cert_obtain: failed to allocate %d bytes",
d1797 2
a1798 1
      log_print ("keynote_cert_obtain: failed to open \"%s\"", file);
d1805 2
a1806 2
      log_print ("keynote_cert_obtain: failed to read %d bytes from \"%s\"",
		 sb.st_size, file);
@


1.22
log
@Add KEY_ID support (mostly from roland@@digitalvampire.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.21 2001/01/27 12:03:34 niklas Exp $	*/
d796 1
a796 2
	  remote_id = calloc (2 * (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) +
			      1, sizeof (char));
d995 1
a995 1
              for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF; i++)
d1189 1
a1189 1
              for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF; i++)
@


1.21
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.20 2001/01/26 12:12:52 niklas Exp $	*/
d135 5
d175 1
a175 1
  int fmt, lifetype = 0;
d794 1
a794 1
	case IPSEC_ID_KEY_ID: /* XXX -- hex-encode this.  */
d796 14
d988 1
a988 1
	    case IPSEC_ID_KEY_ID: /* XXX -- hex-encode this.  */
d990 11
d1182 1
a1182 1
	    case IPSEC_ID_KEY_ID: /* XXX -- hex-encode this.  */
d1184 11
@


1.20
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.19 2001/01/10 00:42:00 angelos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1999, 2000 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
@


1.19
log
@Handle null remote_id/local_filter/remote_filter nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.18 2000/11/23 12:56:15 niklas Exp $	*/
d1236 6
a1241 3
      LOG_DBG ((LOG_SA, 80, "remote_filter_addr_upper == %s", remote_filter_addr_upper));
      LOG_DBG ((LOG_SA, 80, "remote_filter_addr_lower == %s", remote_filter_addr_lower));
      LOG_DBG ((LOG_SA, 80, "remote_filter == %s", (remote_filter ? remote_filter : "")));
d1245 6
a1250 3
      LOG_DBG ((LOG_SA, 80, "local_filter_addr_upper == %s", local_filter_addr_upper));
      LOG_DBG ((LOG_SA, 80, "local_filter_addr_lower == %s", local_filter_addr_lower));
      LOG_DBG ((LOG_SA, 80, "local_filter == %s", (local_filter ? local_filter : "")));
d1254 4
a1257 2
      LOG_DBG ((LOG_SA, 80, "remote_id_addr_upper == %s", remote_id_addr_upper));
      LOG_DBG ((LOG_SA, 80, "remote_id_addr_lower == %s", remote_id_addr_lower));
d1261 4
a1264 2
      LOG_DBG ((LOG_SA, 80, "remote_negotiation_address == %s", remote_ike_address));
      LOG_DBG ((LOG_SA, 80, "local_negotiation_address == %s", local_ike_address));
d1491 1
a1491 1
  /* Just in case there are short reads... */
@


1.18
log
@policy.c: Merge with EOM 1.49
util.h: Merge with EOM 1.10

author: niklas
style and removal of unused, unneeded code
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.17 2000/10/16 23:28:43 niklas Exp $	*/
d1238 1
a1238 1
      LOG_DBG ((LOG_SA, 80, "remote_filter == %s", remote_filter));
d1244 1
a1244 1
      LOG_DBG ((LOG_SA, 80, "local_filter == %s", local_filter));
d1250 1
a1250 1
      LOG_DBG ((LOG_SA, 80, "remote_id == %s", remote_id));
d1365 1
a1365 1
    return remote_filter;
d1383 1
a1383 1
    return local_filter;
d1413 1
a1413 1
    return remote_id;
@


1.17
log
@Merge with EOM 1.48

author: angelos
Fix comment.

author: angelos
Add RIPEMD negotiation/configuration.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.16 2000/10/09 23:27:31 niklas Exp $	*/
/*	$EOM: policy.c,v 1.48 2000/10/14 20:19:51 angelos Exp $ */
d736 2
a737 1
	case IPSEC_ID_IPV6_ADDR: /* XXX we need decode_128 ().  */
d741 2
a742 1
	case IPSEC_ID_IPV6_RANGE: /* XXX we need decode_128 ().  */
d746 2
a747 1
	case IPSEC_ID_IPV6_ADDR_SUBNET: /* XXX we need decode_128 ().  */
d916 2
a917 1
	    case IPSEC_ID_IPV6_ADDR: /* XXX we need decode_128 (). */
d921 2
a922 1
	    case IPSEC_ID_IPV6_RANGE: /* XXX we need decode_128 ().  */
d926 2
a927 1
	    case IPSEC_ID_IPV6_ADDR_SUBNET: /* XXX we need decode_128 ().  */
d1099 2
a1100 1
	    case IPSEC_ID_IPV6_ADDR: /* XXX we need decode_128 ().  */
d1104 2
a1105 1
	    case IPSEC_ID_IPV6_RANGE: /* XXX we need decode_128 ().  */
d1109 2
a1110 1
	    case IPSEC_ID_IPV6_ADDR_SUBNET: /* XXX we need decode_128 ().  */
@


1.17.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.28 2001/04/09 12:34:38 ho Exp $	*/
/*	$EOM: policy.c,v 1.49 2000/10/24 13:33:39 niklas Exp $ */
d5 2
a6 2
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
a134 5
static const char hextab[] = {
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};

d170 1
a170 1
  int fmt, i, lifetype = 0;
d392 1
a392 1

d630 1
a630 1
					   (struct sockaddr **)&sin, &fmt);
d635 1
a635 1
					   (struct sockaddr **)&sin, &fmt);
d640 4
a643 4
	{
	case ISAKMP_EXCH_AGGRESSIVE:
	  phase_1 = "aggressive";
	  break;
d645 4
a648 4
	case ISAKMP_EXCH_ID_PROT:
	  phase_1 = "main";
	  break;
	}
d674 3
a676 3
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 remote_id_addr_upper);
	      goto bad;
d694 5
a698 5
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 strlen (remote_id_addr_upper)
			 + strlen (remote_id_addr_lower) + 2,
			 sizeof (char));
	      goto bad;
d700 1
a700 1

d723 5
a727 5
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 strlen (remote_id_addr_upper)
			 + strlen (remote_id_addr_lower) + 2,
			 sizeof (char));
	      goto bad;
d736 1
a736 2
	case IPSEC_ID_IPV6_ADDR:
	  /* XXX Not yet implemented.  */
d740 1
a740 2
	case IPSEC_ID_IPV6_RANGE:
	  /* XXX Not yet implemented.  */
d744 1
a744 2
	case IPSEC_ID_IPV6_ADDR_SUBNET:
	  /* XXX Not yet implemented.  */
d754 4
a757 4
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			 sizeof (char));
	      goto bad;
d759 1
a759 1
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d769 4
a772 4
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			 sizeof (char));
	      goto bad;
d774 1
a774 1
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d786 1
a786 1
	case IPSEC_ID_KEY_ID:
a787 17
	  remote_id
	    = calloc (2 * (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
		      sizeof (char));
	  if (!remote_id)
	    {
	      log_error ("policy_callback: calloc (%d, %d) failed",
			 2 * (id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) + 1,
			 sizeof (char));
	      goto bad;
	    }
          for (i = 0; i < id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ; i++)
	    {
	      remote_id[2 * i]
		= hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) >> 4];
	      remote_id[2 * i + 1]
		= hextab[*(id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ) & 0xF];
	    }
d849 1
a849 1
			     sizeof remote_filter_addr_lower - 1, 1);
d853 3
a855 3
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     remote_filter_addr_upper);
		  goto bad;
d873 5
a877 5
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (remote_filter_addr_upper)
			     + strlen (remote_filter_addr_lower) + 2,
			     sizeof (char));
		  goto bad;
d901 5
a905 5
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (remote_filter_addr_upper)
			     + strlen (remote_filter_addr_lower) + 2,
			     sizeof (char));
		  goto bad;
d913 1
a913 2
	    case IPSEC_ID_IPV6_ADDR:
	      /* XXX Not yet implemented.  */
d917 1
a917 2
	    case IPSEC_ID_IPV6_RANGE:
	      /* XXX Not yet implemented.  */
d921 1
a921 2
	    case IPSEC_ID_IPV6_ADDR_SUBNET:
	      /* XXX Not yet implemented.  */
d931 4
a934 4
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     idremotesz - ISAKMP_ID_DATA_OFF + 1,
			     sizeof (char));
		  goto bad;
d946 4
a949 4
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     idremotesz - ISAKMP_ID_DATA_OFF + 1,
			     sizeof (char));
		  goto bad;
d963 1
a963 1
	    case IPSEC_ID_KEY_ID:
a964 17
	      remote_filter
		= calloc (2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1,
			  sizeof (char));
	      if (!remote_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     2 * (idremotesz - ISAKMP_ID_DATA_OFF) + 1,
			     sizeof (char));
		  goto bad;
	        }
              for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
	        {
		  remote_filter[2 * i]
		    = hextab[*(idremote + ISAKMP_ID_DATA_OFF) >> 4];
		  remote_filter[2 * i + 1]
		    = hextab[*(idremote + ISAKMP_ID_DATA_OFF) & 0xF];
	        }
d982 1
a982 1

d990 1
a990 2
	      sprintf (remote_filter_proto_num, "%2d",
		       idremote[ISAKMP_GEN_SZ + 1]);
d1012 3
a1014 3
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 remote_filter_addr_upper);
	      goto bad;
d1033 3
a1035 3
		  log_error ("policy_callback: strdup (\"%s\") failed",
			     local_filter_addr_upper);
		  goto bad;
d1053 5
a1057 5
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (local_filter_addr_upper)
			     + strlen (local_filter_addr_lower) + 2,
			     sizeof (char));
		  goto bad;
d1081 5
a1085 5
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     strlen (local_filter_addr_upper)
			     + strlen (local_filter_addr_lower) + 2,
			     sizeof (char));
		  goto bad;
d1093 1
a1093 2
	    case IPSEC_ID_IPV6_ADDR:
	      /* XXX Not yet implemented.  */
d1097 1
a1097 2
	    case IPSEC_ID_IPV6_RANGE:
	      /* XXX Not yet implemented.  */
d1101 1
a1101 2
	    case IPSEC_ID_IPV6_ADDR_SUBNET:
	      /* XXX Not yet implemented.  */
d1111 4
a1114 4
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     idlocalsz - ISAKMP_ID_DATA_OFF + 1,
			     sizeof (char));
		  goto bad;
d1126 4
a1129 4
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     idlocalsz - ISAKMP_ID_DATA_OFF + 1,
			     sizeof (char));
		  goto bad;
d1143 1
a1143 1
	    case IPSEC_ID_KEY_ID:
a1144 16
	      local_filter = calloc (2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
				     sizeof (char));
	      if (!local_filter)
	        {
		  log_error ("policy_callback: calloc (%d, %d) failed",
			     2 * (idlocalsz - ISAKMP_ID_DATA_OFF) + 1,
			     sizeof (char));
		  goto bad;
	        }
              for (i = 0; i < idremotesz - ISAKMP_ID_DATA_OFF; i++)
	        {
		  local_filter[2 * i]
		    = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) >> 4];
		  local_filter[2 * i + 1]
		    = hextab[*(idlocal + ISAKMP_ID_DATA_OFF) & 0xF];
	        }
d1170 1
a1170 2
	      sprintf (local_filter_proto_num, "%2d",
		       idlocal[ISAKMP_GEN_SZ + 1]);
d1181 1
a1181 1
					       (struct sockaddr **)&sin,
d1193 3
a1195 3
	      log_error ("policy_callback: strdup (\"%s\") failed",
			 local_filter_addr_upper);
	      goto bad;
d1199 50
a1248 66
      LOG_DBG ((LOG_POLICY, 80, "Policy context (action attributes):"));
      LOG_DBG ((LOG_POLICY, 80, "esp_present == %s", esp_present));
      LOG_DBG ((LOG_POLICY, 80, "ah_present == %s", ah_present));
      LOG_DBG ((LOG_POLICY, 80, "comp_present == %s", comp_present));
      LOG_DBG ((LOG_POLICY, 80, "ah_hash_alg == %s", ah_hash_alg));
      LOG_DBG ((LOG_POLICY, 80, "esp_enc_alg == %s", esp_enc_alg));
      LOG_DBG ((LOG_POLICY, 80, "comp_alg == %s", comp_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_auth_alg == %s", ah_auth_alg));
      LOG_DBG ((LOG_POLICY, 80, "esp_auth_alg == %s", esp_auth_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_life_seconds == %s", ah_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "ah_life_kbytes == %s", ah_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "esp_life_seconds == %s", esp_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "esp_life_kbytes == %s", esp_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "comp_life_seconds == %s", comp_life_seconds));
      LOG_DBG ((LOG_POLICY, 80, "comp_life_kbytes == %s", comp_life_kbytes));
      LOG_DBG ((LOG_POLICY, 80, "ah_encapsulation == %s", ah_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "esp_encapsulation == %s", esp_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "comp_encapsulation == %s",
		comp_encapsulation));
      LOG_DBG ((LOG_POLICY, 80, "comp_dict_size == %s", comp_dict_size));
      LOG_DBG ((LOG_POLICY, 80, "comp_private_alg == %s", comp_private_alg));
      LOG_DBG ((LOG_POLICY, 80, "ah_key_length == %s", ah_key_length));
      LOG_DBG ((LOG_POLICY, 80, "ah_key_rounds == %s", ah_key_rounds));
      LOG_DBG ((LOG_POLICY, 80, "esp_key_length == %s", esp_key_length));
      LOG_DBG ((LOG_POLICY, 80, "esp_key_rounds == %s", esp_key_rounds));
      LOG_DBG ((LOG_POLICY, 80, "ah_group_desc == %s", ah_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "esp_group_desc == %s", esp_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "comp_group_desc == %s", comp_group_desc));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_type == %s",
		remote_filter_type));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_addr_upper == %s",
		remote_filter_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_addr_lower == %s",
		remote_filter_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter == %s",
		(remote_filter ? remote_filter : "")));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_port == %s",
		remote_filter_port));
      LOG_DBG ((LOG_POLICY, 80, "remote_filter_proto == %s",
		remote_filter_proto));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_type == %s", local_filter_type));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_addr_upper == %s",
		local_filter_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_addr_lower == %s",
		local_filter_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "local_filter == %s",
		(local_filter ? local_filter : "")));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_port == %s", local_filter_port));
      LOG_DBG ((LOG_POLICY, 80, "local_filter_proto == %s",
		local_filter_proto));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_type == %s", remote_id_type));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_addr_upper == %s",
		remote_id_addr_upper));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_addr_lower == %s",
		remote_id_addr_lower));
      LOG_DBG ((LOG_POLICY, 80, "remote_id == %s",
		(remote_id ? remote_id : "")));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_port == %s", remote_id_port));
      LOG_DBG ((LOG_POLICY, 80, "remote_id_proto == %s", remote_id_proto));
      LOG_DBG ((LOG_POLICY, 80, "remote_negotiation_address == %s",
		remote_ike_address));
      LOG_DBG ((LOG_POLICY, 80, "local_negotiation_address == %s",
		local_ike_address));
      LOG_DBG ((LOG_POLICY, 80, "pfs == %s", pfs));
      LOG_DBG ((LOG_POLICY, 80, "initiator == %s", initiator));
      LOG_DBG ((LOG_POLICY, 80, "phase1_group_desc == %s", phase1_group));
d1259 3
a1261 3
      tt = time ((time_t) NULL);
      strftime (mytimeofday, 14, "%G%m%d%H%M%S", gmtime (&tt));
      return mytimeofday;
d1266 3
a1268 3
      tt = time ((time_t) NULL);
      strftime (mytimeofday, 14, "%G%m%d%H%M%S", localtime (&tt));
      return mytimeofday;
d1356 1
a1356 1
    return (remote_filter ? remote_filter : "");
d1374 1
a1374 1
    return (local_filter ? local_filter : "");
d1404 1
a1404 1
    return (remote_id ? remote_id : "");
d1433 1
a1433 1
  off_t sz;
d1436 1
a1436 1
  LOG_DBG ((LOG_POLICY, 30, "policy_init: initializing"));
d1453 1
a1453 1
  policy_file = conf_get_str ("General", "Policy-file");
a1456 4
  /* Check file modes and collect file size */
  if (check_file_secrecy (policy_file, &sz))
    log_fatal ("policy_init: cannot read %s", policy_file);

d1462 4
d1467 1
a1467 1
  ptr = calloc (sz + 1, sizeof (char));
d1469 1
a1469 1
    log_fatal ("policy_init: calloc (%d, %d) failed", sz + 1,
d1472 2
a1473 2
  /* Just in case there are short reads...  */
  for (len = 0; len < sz; len += i)
d1475 1
a1475 1
      i = read (fd, ptr + len, sz - len);
d1478 1
a1478 1
		   sz - len);
d1485 1
a1485 1
  asserts = LK (kn_read_asserts, (ptr, sz, &i));
d1522 1
a1522 1
/* Just copy and return.  */
d1526 1
a1526 1
  char *foo = calloc (len + 1, sizeof (char));
d1555 2
a1556 2
      if (LK (kn_verify_assertion, (scert, strlen ((char *) scert)))
	  != SIGRESULT_TRUE)
d1571 1
a1571 1
/* Add received credentials.  */
d1592 1
a1592 1
/* Just regular memory free.  */
d1599 1
a1599 1
/* Verify that the key given to us is valid.  */
d1603 3
a1605 3
  struct keynote_deckey dc;
  int err = 1;
  char *dat;
d1607 3
a1609 7
  dat = calloc (len + 1, sizeof (char));
  if (!dat)
    {
      log_error ("keynote_certreq_validate: calloc (%d, %d) failed", len + 1,
		 sizeof (char));
	return 0;
    }
d1611 1
a1611 1
  memcpy (dat, data, len);
d1613 4
a1616 4
  if (LK (kn_decode_key, (&dc, dat, KEYNOTE_PUBLIC_KEY)) != 0)
    err = 0;
  else
    LK (kn_free_key, (&dc));
d1618 1
a1618 1
  free (dat);
d1620 1
a1620 1
  return err;
d1623 1
a1623 1
/* Beats me what we should be doing with this.  */
d1651 1
a1651 1
  /* Get type of ID.  */
d1659 1
a1659 2
      LOG_DBG ((LOG_POLICY, 30,
		"keynote_cert_obtain: no Credential-directory"));
d1671 1
a1671 1
	file = calloc (len + 15, sizeof (char));
d1674 1
a1674 1
	    log_error ("keynote_cert_obtain: failed to allocate %d bytes",
d1679 1
a1679 1
	memcpy (&in, id, sizeof in);
d1687 1
a1687 1
        file = calloc (len + id_len, sizeof (char));
d1690 1
a1690 1
	    log_error ("keynote_cert_obtain: failed to allocate %d bytes",
d1707 1
a1707 2
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to stat \"%s\"",
		file));
d1712 1
a1712 1
  *cert = calloc (sb.st_size, sizeof (char));
d1715 1
a1715 1
      log_error ("keynote_cert_obtain: failed to allocate %d bytes",
d1724 1
a1724 2
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to open \"%s\"",
		file));
d1731 2
a1732 2
      LOG_DBG ((LOG_POLICY, 30, "keynote_cert_obtain: failed to read %d "
		"bytes from \"%s\"", sb.st_size, file));
d1744 1
a1744 1
/* This should never be called.  */
d1752 1
a1752 1
/* Get the authorizer key.  */
d1760 2
a1761 2
  foo = LK (kn_read_asserts, ((char *)scert, strlen ((char *)scert), &num));
  if (foo == NULL || num == 0)
d1779 1
a1779 1
	{
d1782 1
a1782 1
	}
@


1.16
log
@samples/VPN-3way-template.conf: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.12
samples/VPN-west.conf: Merge with EOM 1.13
samples/policy: Merge with EOM 1.6
samples/singlehost-west.conf: Merge with EOM 1.9
samples/singlehost-east.conf: Merge with EOM 1.9
conf.c: Merge with EOM 1.37
ipsec.c: Merge with EOM 1.133
ipsec_num.cst: Merge with EOM 1.4
isakmpd.conf.5: Merge with EOM 1.48
isakmpd.policy.5: Merge with EOM 1.21
policy.c: Merge with EOM 1.46

author: angelos
AES support.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.15 2000/10/07 06:59:56 niklas Exp $	*/
/*	$EOM: policy.c,v 1.46 2000/10/09 22:08:29 angelos Exp $ */
d293 4
d548 4
d573 4
d1536 2
a1537 3
 * We just verify the signature on the certificates.
 * XXX Is this the right thing to do -- verify the signature on all
 * XXX credentials ?
@


1.15
log
@Merge with EOM 1.45

author: angelos
Unsigned integers for most attributes.

author: niklas
Multiple subject name matching, makes certificate interop with PGPnet at least
partly working.  Added some error checking.

author: ho
Nowadays we can use #include <openssl/...> instead of <ssl/...>

author: angelos
Typo on checking esp lifetimes.

author: angelos
Use the correct protocol from the IDi/IDr.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.14 2000/08/03 07:25:11 niklas Exp $	*/
/*	$EOM: policy.c,v 1.45 2000/10/02 03:23:25 angelos Exp $ */
d314 4
@


1.14
log
@Merge with EOM 1.40

author: angelos
Get the right value.

author: angelos
Add "phase1_group_desc" attribute, and explain the various values.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.13 2000/06/08 20:51:42 niklas Exp $	*/
/*	$EOM: policy.c,v 1.40 2000/07/26 06:04:27 angelos Exp $ */
d55 1
a55 6

#ifdef KAME
#  include <openssl/ssl.h>
#else
#  include <ssl/ssl.h>
#endif
d274 1
a274 1
      sprintf (phase1_group, "%d", is->group_desc);
d410 1
a410 1
			    sprintf (ah_life_seconds, "%d",
d413 1
a413 1
			    sprintf (ah_life_seconds, "%d",
d419 1
a419 1
			    sprintf (ah_life_kbytes, "%d",
d422 1
a422 1
			    sprintf (ah_life_kbytes, "%d",
d432 1
a432 1
			    sprintf (esp_life_seconds, "%d",
d435 1
a435 1
			    sprintf (esp_life_seconds, "%d",
d441 1
a441 1
			    sprintf (esp_life_kbytes, "%d",
d444 1
a444 1
			    sprintf (esp_life_kbytes, "%d",
d454 1
a454 1
			    sprintf (comp_life_seconds, "%d",
d457 1
a457 1
			    sprintf (comp_life_seconds, "%d",
d463 1
a463 1
			    sprintf (comp_life_kbytes, "%d",
d466 1
a466 1
			    sprintf (comp_life_kbytes, "%d",
d478 1
a478 1
		      sprintf (ah_group_desc, "%d", decode_16 (value));
d482 1
a482 1
		      sprintf (esp_group_desc, "%d",
d487 1
a487 1
		      sprintf (comp_group_desc, "%d",
d577 1
a577 1
		      sprintf (ah_key_length, "%d", decode_16 (value));
d581 1
a581 1
		      sprintf (esp_key_length, "%d",
d591 1
a591 1
		      sprintf (ah_key_rounds, "%d", decode_16 (value));
d595 1
a595 1
		      sprintf (esp_key_rounds, "%d",
d602 1
a602 1
		  sprintf (comp_dict_size, "%d", decode_16 (value));
d606 1
a606 1
		  sprintf (comp_private_alg, "%d", decode_16 (value));
d775 1
a775 1
	  log_print ("policy_callback: unknown remote ID type %d", id[0]);
d801 1
a801 1
      snprintf (remote_id_port, sizeof remote_id_port - 1, "%d",
d952 1
a952 1
	      log_print ("policy_callback: unknown Remote ID type %d",
d974 1
a974 1
	      sprintf (remote_filter_proto_num, "%2d", id[1]);
d980 1
a980 1
		    "%d", decode_16 (idremote + ISAKMP_GEN_SZ + 2));
d1132 1
a1132 1
	      log_print ("policy_callback: unknown Local ID type %d",
d1154 1
a1154 1
	      sprintf (local_filter_proto_num, "%2d", id[1]);
d1160 1
a1160 1
		    "%d", decode_16 (idlocal + ISAKMP_GEN_SZ + 2));
d1298 1
a1298 1
    return ah_life_kbytes;
d1301 1
a1301 1
    return ah_life_seconds;
d1731 2
a1732 1
keynote_cert_get_subject (void *scert, u_int8_t **id, u_int32_t *id_len)
@


1.13
log
@Merge with EOM 1.38

author: angelos
No need for NODEBUG actually...

author: angelos
Use LOG_DBG() instead of log_debug()

author: angelos
NODEBUG compile option, so regress doesn't barf.

author: angelos
No point adding a handling attribute for the generic session.

author: angelos
log_debug() for the action attributes.

author: angelos
Different policy/Keynote sessions per Phase 1 SA.

author: angelos
Allow exchange of KeyNote credentials over IKE. Multiple credentials
may be passed in a single CERT payload. KeyNote is used if a
directory named as the local ID we use in an exchange exists in the
KeyNote directory (default: /etc/isakmpd/keynote/). Note that
asymmetric credentials are possible (use KeyNote in one direction and
X509 in the other); such authentication is envisioned to be the most
common: the clients will use KeyNote credentials to authenticate and
authorize with a server, whilst the server will just provide an X509
certificate proving its binding to the IP address or ID.

Totally asymmetric authentication (e.g., shared key in one direction,
RSA in the other) is not supported by the IKE protocol.

author: angelos
Correct pointer handling.

author: angelos
A few more certificate handling routines for KeyNote.

author: angelos
Some more support for KeyNote credential exchange (not yet done).

author: angelos
Add a couple more KeyNote functions in the sym entries.

author: ho
Some systems do not define IPPROTO_ETHERIP (yet).
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.12 2000/05/02 14:35:27 niklas Exp $	*/
/*	$EOM: policy.c,v 1.38 2000/06/08 04:36:26 angelos Exp $ */
d174 1
d200 1
d261 1
d278 3
d1237 1
d1406 3
@


1.12
log
@Merge with EOM 1.26

author: niklas
style

author: angelos
Move POLICY_FILE_DEFAULT definition to the .h file.

author: angelos
Add etherip and protocol numbers in the transport protocol entries,
document.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.11 2000/04/07 22:50:02 niklas Exp $	*/
/*	$EOM: policy.c,v 1.26 2000/05/01 19:52:50 niklas Exp $ */
d56 6
d84 1
d104 3
d124 2
d131 5
a135 1

d165 1
a165 1
static char *
d788 1
d792 1
d966 1
d970 1
d1146 1
d1150 1
d1182 49
a1230 50
#if 0
      printf ("esp_present == %s\n", esp_present);
      printf ("ah_present == %s\n", ah_present);
      printf ("comp_present == %s\n", comp_present);
      printf ("ah_hash_alg == %s\n", ah_hash_alg);
      printf ("esp_enc_alg == %s\n", esp_enc_alg);
      printf ("comp_alg == %s\n", comp_alg);
      printf ("ah_auth_alg == %s\n", ah_auth_alg);
      printf ("esp_auth_alg == %s\n", esp_auth_alg);
      printf ("ah_life_seconds == %s\n", ah_life_seconds);
      printf ("ah_life_kbytes == %s\n", ah_life_kbytes);
      printf ("esp_life_seconds == %s\n", esp_life_seconds);
      printf ("esp_life_kbytes == %s\n", esp_life_kbytes);
      printf ("comp_life_seconds == %s\n", comp_life_seconds);
      printf ("comp_life_kbytes == %s\n", comp_life_kbytes);
      printf ("ah_encapsulation == %s\n", ah_encapsulation);
      printf ("esp_encapsulation == %s\n", esp_encapsulation);
      printf ("comp_encapsulation == %s\n", comp_encapsulation);
      printf ("comp_dict_size == %s\n", comp_dict_size);
      printf ("comp_private_alg == %s\n", comp_private_alg);
      printf ("ah_key_length == %s\n", ah_key_length);
      printf ("ah_key_rounds == %s\n", ah_key_rounds);
      printf ("esp_key_length == %s\n", esp_key_length);
      printf ("esp_key_rounds == %s\n", esp_key_rounds);
      printf ("ah_group_desc == %s\n", ah_group_desc);
      printf ("esp_group_desc == %s\n", esp_group_desc);
      printf ("comp_group_desc == %s\n", comp_group_desc);
      printf ("remote_filter_type == %s\n", remote_filter_type);
      printf ("remote_filter_addr_upper == %s\n", remote_filter_addr_upper);
      printf ("remote_filter_addr_lower == %s\n", remote_filter_addr_lower);
      printf ("remote_filter == %s\n", remote_filter);
      printf ("remote_filter_port == %s\n", remote_filter_port);
      printf ("remote_filter_proto == %s\n", remote_filter_proto);
      printf ("local_filter_type == %s\n", local_filter_type);
      printf ("local_filter_addr_upper == %s\n", local_filter_addr_upper);
      printf ("local_filter_addr_lower == %s\n", local_filter_addr_lower);
      printf ("local_filter == %s\n", local_filter);
      printf ("local_filter_port == %s\n", local_filter_port);
      printf ("local_filter_proto == %s\n", local_filter_proto);
      printf ("remote_id_type == %s\n", remote_id_type);
      printf ("remote_id_addr_upper == %s\n", remote_id_addr_upper);
      printf ("remote_id_addr_lower == %s\n", remote_id_addr_lower);
      printf ("remote_id == %s\n", remote_id);
      printf ("remote_id_port == %s\n", remote_id_port);
      printf ("remote_id_proto == %s\n", remote_id_proto);
      printf ("remote_negotiation_address == %s\n", remote_ike_address);
      printf ("local_negotiation_address == %s\n", local_ike_address);
      printf ("pfs == %s\n", pfs);
      printf ("initiator == %s\n", initiator);
#endif /* 0 */
d1478 65
d1544 1
a1544 1
      free (asserts[fd]);
d1547 218
a1764 2
  if (asserts)
    free (asserts);
d1766 2
a1767 7
  /* Add the callback that will handle attributes.  */
  if (LK (kn_add_action, (keynote_sessid, ".*", (char *) policy_callback,
			  ENVIRONMENT_FLAG_FUNC | ENVIRONMENT_FLAG_REGEX))
      == -1)
    log_fatal ("policy_init: "
	       "kn_add_action (%d, \".*\", %p, FUNC | REGEX) failed",
	       keynote_sessid, policy_callback);
@


1.12.2.1
log
@Pull in patch:
Errata (009):
A serious bug in isakmpd(8) policy handling wherein policy verification could
be completely bypassed in isakmpd.
Fix (angelos):
Fix bug that resulted in bypass of policy verification of proposed SAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.12 2000/05/02 14:35:27 niklas Exp $	*/
d149 1
a149 1
char *
@


1.11
log
@Merge with EOM 1.23

author: angelos
Typo...

author: angelos
*_ike_address -> *_negotiation_address (so it's not IKE specific)

author: angelos
No need to use log_fatal...
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.10 2000/04/07 22:04:02 niklas Exp $	*/
/*	$EOM: policy.c,v 1.23 2000/04/07 22:44:25 angelos Exp $ */
a78 4
#ifndef POLICY_FILE_DEFAULT
#define POLICY_FILE_DEFAULT "/etc/isakmpd/isakmpd.policy"
#endif /* POLICY_FILE_DEFAULT */

d181 2
d771 9
d947 9
d1125 9
d1220 2
a1221 2
	tt = time((time_t) NULL);
	strftime (mytimeofday, 14, "%G%m%d%H%M%S", gmtime(&tt));
d1227 2
a1228 2
	tt = time((time_t) NULL);
	strftime (mytimeofday, 14, "%G%m%d%H%M%S", localtime(&tt));
d1382 1
a1382 1
  policy_callback(KEYNOTE_CALLBACK_INITIALIZE);
@


1.10
log
@Merge with EOM 1.20

author: niklas
Hmm keynote does not exist in a dynamically linked version

author: angelos
Add phase_1 attribute.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.9 2000/02/25 17:23:41 niklas Exp $	*/
/*	$EOM: policy.c,v 1.20 2000/04/06 19:50:34 niklas Exp $ */
d642 5
a646 2
	    log_fatal ("policy_callback: strdup (\"%s\") failed",
		       remote_id_addr_upper);
d662 8
a669 5
	    log_fatal ("policy_callback: calloc (%d, %d) failed",
		       strlen (remote_id_addr_upper)
		       + strlen (remote_id_addr_lower) + 2,
		       sizeof (char));

d691 7
a697 4
	    log_fatal ("policy_callback: calloc (%d, %d) failed",
		       strlen (remote_id_addr_upper)
		       + strlen (remote_id_addr_lower) + 2,
		       sizeof (char));
d722 6
a727 3
	    log_fatal ("policy_callback: calloc (%d, %d) failed",
		       id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
		       sizeof (char));
d737 6
a742 3
	    log_fatal ("policy_callback: calloc (%d, %d) failed",
		       id_sz - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
		       sizeof (char));
d761 1
a761 1
	  return "";
d810 5
a814 2
		log_fatal ("policy_callback: strdup (\"%s\") failed",
			   remote_filter_addr_upper);
d830 7
a836 4
		log_fatal ("policy_callback: calloc (%d, %d) failed",
			   strlen (remote_filter_addr_upper)
			   + strlen (remote_filter_addr_lower) + 2,
			   sizeof (char));
d858 7
a864 4
		log_fatal ("policy_callback: calloc (%d, %d) failed",
			   strlen (remote_filter_addr_upper)
			   + strlen (remote_filter_addr_lower) + 2,
			   sizeof (char));
d888 6
a893 3
		log_fatal ("policy_callback: calloc (%d, %d) failed",
			   idremotesz - ISAKMP_ID_DATA_OFF + 1,
			   sizeof (char));
d903 6
a908 3
		log_fatal ("policy_callback: calloc (%d, %d) failed",
			   idremotesz - ISAKMP_ID_DATA_OFF + 1,
			   sizeof (char));
d928 1
a928 1
	      return "";
d958 5
a962 2
	    log_fatal ("policy_callback: strdup (\"%s\") failed",
		       remote_filter_addr_upper);
d979 5
a983 2
		log_fatal ("policy_callback: strdup (\"%s\") failed",
			   local_filter_addr_upper);
d999 7
a1005 4
		log_fatal ("policy_callback: calloc (%d, %d) failed",
			   strlen (local_filter_addr_upper)
			   + strlen (local_filter_addr_lower) + 2,
			   sizeof (char));
d1027 7
a1033 4
		log_fatal ("policy_callback: calloc (%d, %d) failed",
			   strlen (local_filter_addr_upper)
			   + strlen (local_filter_addr_lower) + 2,
			   sizeof (char));
d1057 6
a1062 3
		log_fatal ("policy_callback: calloc (%d, %d) failed",
			   idlocalsz - ISAKMP_ID_DATA_OFF + 1,
			   sizeof (char));
d1072 6
a1077 3
		log_fatal ("policy_callback: calloc (%d, %d) failed",
			   idlocalsz - ISAKMP_ID_DATA_OFF + 1,
			   sizeof (char));
d1097 1
a1097 1
	      return "";
d1128 2
a1129 1
		log_fatal ("policy_callback: strdup (\"%s\") failed",
d1131 2
d1180 2
a1181 2
      printf ("remote_ike_address == %s\n", remote_ike_address);
      printf ("local_ike_address == %s\n", local_ike_address);
d1327 3
d1333 3
d1354 4
@


1.9
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.8 2000/02/19 19:32:04 niklas Exp $	*/
/*	$EOM: policy.c,v 1.18 2000/02/20 19:58:41 niklas Exp $ */
d83 1
a83 1
#if defined (HAVE_DLOPEN) && !defined (USE_KEYNOTE)
d181 1
a181 1
  static char *remote_id_type, remote_id_addr_upper[64];
d196 1
a196 1
      ah_hash_alg = ah_auth_alg = "";
d608 11
d1138 3
@


1.8
log
@Merge with EOM 1.17

author: niklas
Copyright 2000
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.7 2000/02/11 10:21:05 niklas Exp $	*/
/*	$EOM: policy.c,v 1.17 2000/02/19 07:58:56 niklas Exp $ */
d1294 1
a1294 1
  log_debug (LOG_MISC, 50, "policy_init: initializing");
@


1.7
log
@Merge with EOM 1.16

author: angelos
Do a policy check on the Initiator, when notified by the Responder on
the SA selection. For efficiency, we should replicate this check on
the first message sent by the Initiator (so we only send proposals we
know we'll eventually accept).

author: angelos
Add an initiator attribute, and make the code amenable to be invoked
by the initiator as well (for policy compliance checking).
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.6 2000/02/01 02:46:18 niklas Exp $	*/
/*	$EOM: policy.c,v 1.16 2000/02/10 11:54:07 angelos Exp $ */
d6 1
a6 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
@


1.6
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.5 2000/01/27 18:07:28 niklas Exp $	*/
/*	$EOM: policy.c,v 1.14 2000/01/31 22:33:48 niklas Exp $ */
d158 2
a159 1
  u_int8_t *attr, *value, *id;
a164 1
  size_t id_sz;
d184 1
a184 1
  static char *remote_filter_proto, *local_filter_proto, *pfs;
d199 1
a199 1
      local_filter_type = remote_id_type = "";
d752 17
d770 1
a770 1
      if (ie->id_ci)
d772 1
a772 1
	  switch (GET_ISAKMP_ID_TYPE (ie->id_ci))
d777 1
a777 1
	      net = decode_32 (ie->id_ci + ISAKMP_ID_DATA_OFF);
d791 1
a791 1
	      net = decode_32 (ie->id_ci + ISAKMP_ID_DATA_OFF);
d794 1
a794 1
	      net = decode_32 (ie->id_ci + ISAKMP_ID_DATA_OFF + 4);
d814 2
a815 2
	      net = decode_32 (ie->id_ci + ISAKMP_ID_DATA_OFF);
	      subnet = decode_32 (ie->id_ci + ISAKMP_ID_DATA_OFF + 4);
d850 1
a850 1
	      remote_filter = calloc (ie->id_ci_sz - ISAKMP_ID_DATA_OFF + 1,
d854 1
a854 1
			   ie->id_ci_sz - ISAKMP_ID_DATA_OFF + 1,
d856 2
a857 2
	      memcpy (remote_filter, ie->id_ci + ISAKMP_ID_DATA_OFF,
		      ie->id_ci_sz);
d862 1
a862 1
	      remote_filter = calloc (ie->id_ci_sz - ISAKMP_ID_DATA_OFF + 1,
d866 1
a866 1
			   ie->id_ci_sz - ISAKMP_ID_DATA_OFF + 1,
d868 2
a869 2
	      memcpy (remote_filter, ie->id_ci + ISAKMP_ID_DATA_OFF,
		      ie->id_ci_sz);
d885 2
a886 2
	      log_print ("policy_callback: unknown initiator ID type %d",
			 GET_ISAKMP_ID_TYPE (ie->id_ci));
d890 1
a890 1
	  switch (ie->id_ci[ISAKMP_GEN_SZ + 1])
d902 1
a902 1
		    "%d", decode_16 (ie->id_ci + ISAKMP_GEN_SZ + 2));
d906 1
a906 1
	  policy_sa->transport->vtbl->get_src (policy_sa->transport,
d914 1
a914 1
			 sizeof remote_filter_addr_lower - 1, 1);
d921 1
a921 1
      if (ie->id_cr)
d923 1
a923 1
	  switch (GET_ISAKMP_ID_TYPE (ie->id_cr))
d928 1
a928 1
	      net = decode_32 (ie->id_cr + ISAKMP_ID_DATA_OFF);
d942 1
a942 1
	      net = decode_32 (ie->id_cr + ISAKMP_ID_DATA_OFF);
d945 1
a945 1
	      net = decode_32 (ie->id_cr + ISAKMP_ID_DATA_OFF + 4);
d965 2
a966 2
	      net = decode_32 (ie->id_cr + ISAKMP_ID_DATA_OFF);
	      subnet = decode_32 (ie->id_cr + ISAKMP_ID_DATA_OFF + 4);
d1001 1
a1001 1
	      local_filter = calloc (ie->id_cr_sz - ISAKMP_ID_DATA_OFF + 1,
d1005 1
a1005 1
			   ie->id_cr_sz - ISAKMP_ID_DATA_OFF + 1,
d1007 2
a1008 2
	      memcpy (local_filter, ie->id_cr + ISAKMP_ID_DATA_OFF,
		      ie->id_cr_sz);
d1013 1
a1013 1
	      local_filter = calloc (ie->id_cr_sz - ISAKMP_ID_DATA_OFF + 1,
d1017 1
a1017 1
			   ie->id_cr_sz - ISAKMP_ID_DATA_OFF + 1,
d1019 2
a1020 2
	      memcpy (local_filter, ie->id_cr + ISAKMP_ID_DATA_OFF,
		      ie->id_cr_sz);
d1036 2
a1037 2
	      log_print ("policy_callback: unknown responder ID type %d",
			 GET_ISAKMP_ID_TYPE (ie->id_cr));
d1041 1
a1041 1
	  switch (ie->id_cr[ISAKMP_GEN_SZ + 1])
d1053 1
a1053 1
		    "%d", decode_16 (ie->id_cr + ISAKMP_GEN_SZ + 2));
d1057 1
a1057 1
	  policy_sa->transport->vtbl->get_dst (policy_sa->transport,
d1060 1
d1066 1
a1066 1
			 sizeof local_filter_addr_lower - 1, 1);
d1121 1
d1141 3
@


1.5
log
@Merge with EOM 1.13

author: ho
Bugfix for IPSEC_ID_USER_FQDN from <<Jorgen.Granstam@@abc.se>.
Apply similar to the IPSEC_ID_FQDN case plus fix the log messages.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.4 2000/01/26 15:24:03 niklas Exp $	*/
/*	$EOM: policy.c,v 1.13 2000/01/27 17:38:43 ho Exp $ */
d5 1
a5 1
 * Copyright (c) 1999 Angelos D. Keromytis.  All rights reserved.
@


1.4
log
@Merge with EOM 1.12

date: 2000/01/25 02:21:10;  author: angelos;  state: Exp;  lines: +2 -2
Move the policy file location

author: angelos
GMTTimeOfDay and LocalTimeOfDay attributes, comment in x509.c.

author: angelos
Oops on previous PFS-policy patch. Small fixes in the manpages.

author: angelos
Add pfs keynote attribute.

author: angelos
Include files, in anticipation of the keynote.h changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.3 1999/10/26 22:32:28 angelos Exp $	*/
/*	$EOM: policy.c,v 1.12 2000/01/25 02:21:10 angelos Exp $ */
d699 1
a699 1
	  remote_id = calloc (id_sz - ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 1,
d703 1
a703 1
		       id_sz - ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 1,
d705 2
a706 1
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, id_sz);
d711 1
a711 1
	  remote_id = calloc (id_sz - ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 1,
d715 1
a715 1
		       id_sz - ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ + 1,
d717 2
a718 1
	  memcpy (remote_id, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, id_sz);
@


1.3
log
@sync with latest libkeynote (include file changes only)
@
text
@d1 2
a2 2
/*	$OpenBSD: policy.c,v 1.2 1999/08/26 22:31:09 niklas Exp $	*/
/*	$EOM: policy.c,v 1.7 1999/08/26 11:21:47 niklas Exp $ */
d80 1
a80 1
#define POLICY_FILE_DEFAULT "/etc/isakmpd.policy"
d165 2
d184 1
a184 1
  static char *remote_filter_proto, *local_filter_proto;
d195 1
a195 1
      esp_present = ah_present = comp_present = "no";
d258 3
d1100 1
d1106 17
@


1.2
log
@Merge with EOM 1.7

author: niklas
Support dynamic loading of libkeynote too.  Build isakmpd static by default.
Stylistic cleanup of keynote policy code.  Correct some libcrypto calls.

author: niklas
more style

author: niklas
isakmpd style

author: angelos
Hopefully better wording of variables.

author: angelos
Complete policy work; tested for the shared-key case. Documentation needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: policy.c,v 1.1 1999/07/07 22:10:28 niklas Exp $	*/
d38 1
d43 1
@


1.1
log
@policy.h: Merge with EOM 1.2
policy.c: Merge with EOM 1.2

author: niklas
Remove $EOM$ from Eom repository version

author: niklas
New file, for keynote policy handling. By angelos@@openbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$EOM: policy.c,v 1.2 1999/06/07 08:46:34 niklas Exp $ */
d6 1
d49 4
d61 1
d81 39
d122 28
a149 2
struct exchange *policy_exchange = NULL;
struct sa *policy_sa = NULL;
d156 5
a160 1
  u_int8_t *attr, *value;
d162 1
a162 1
  int fmt, lifetype = 0;
d164 1
a164 1
  /* We use all these as a cache */
d172 3
a174 4
  static char comp_private_alg[32], *id_initiator_type, *id_responder_type;
  static char id_initiator_addr_upper[32], id_initiator_addr_lower[32];
  static char id_responder_addr_upper[32], id_responder_addr_lower[32];
  static char id_initiator[100], id_responder[100];
d176 9
a184 1
  
d187 3
a189 3
  /* We only need to set dirty at initialization time really */
  if (strcmp (name, KEYNOTE_CALLBACK_CLEANUP) == 0 ||
      strcmp (name, KEYNOTE_CALLBACK_INITIALIZE) == 0)
d192 50
a241 26
      ah_hash_alg = ah_auth_alg = NULL;
      esp_auth_alg = esp_enc_alg = comp_alg = ah_encapsulation = NULL;
      esp_encapsulation = comp_encapsulation = id_initiator_type = NULL;
      id_responder_type = NULL;
      memset (ah_life_kbytes, 0, 32);
      memset (ah_life_seconds, 0, 32);
      memset (esp_life_kbytes, 0, 32);
      memset (esp_life_seconds, 0, 32);
      memset (comp_life_kbytes, 0, 32);
      memset (comp_life_seconds, 0, 32);
      memset (ah_key_length, 0, 32);
      memset (ah_key_rounds, 0, 32);
      memset (esp_key_length, 0, 32);
      memset (esp_key_rounds, 0, 32);
      memset (comp_dict_size, 0, 32);
      memset (comp_private_alg, 0, 32);
      memset (id_initiator_addr_upper, 0, 32);
      memset (id_initiator_addr_lower, 0, 32);
      memset (id_responder_addr_upper, 0, 32);
      memset (id_responder_addr_lower, 0, 32);
      memset (ah_group_desc, 0, 32);
      memset (esp_group_desc, 0, 32);
      memset (comp_group_desc, 0, 32);
      memset (id_initiator, 0, 100); /* XX */
      memset (id_responder, 0, 100); /* XX */
      
d246 1
a246 1
  /* 
d251 3
a253 1
  {
d256 1
a256 1
      {
d258 95
a352 95
	  {
		case IPSEC_PROTO_IPSEC_AH:
		    ah_present = "yes";
		    switch (proto->id)
		    {
			case IPSEC_AH_MD5:
			    ah_hash_alg = "md5";
			    break;
			    
			case IPSEC_AH_SHA:
			    ah_hash_alg = "sha";
			    break;
			    
			case IPSEC_AH_DES:
			    ah_hash_alg = "des";
			    break;
		    }
		    
		    break;
		    
		case IPSEC_PROTO_IPSEC_ESP:
		    esp_present = "yes";
		    switch (proto->id)
		    {
			case IPSEC_ESP_DES_IV64:
			    esp_enc_alg = "des-iv64";
			    break;
			    
			case IPSEC_ESP_DES:
			    esp_enc_alg = "des";
			    break;
			    
			case IPSEC_ESP_3DES:
			    esp_enc_alg = "3des";
			    break;
			    
			case IPSEC_ESP_RC5:
			    esp_enc_alg = "rc5";
			    break;
			    
			case IPSEC_ESP_IDEA:
			    esp_enc_alg = "idea";
			    break;
			    
			case IPSEC_ESP_CAST:
			    esp_enc_alg = "cast";
			    break;
			    
			case IPSEC_ESP_BLOWFISH:
			    esp_enc_alg = "blowfish";
			    break;
			    
			case IPSEC_ESP_3IDEA:
			    esp_enc_alg = "3idea";
			    break;
			    
			case IPSEC_ESP_DES_IV32:
			    esp_enc_alg = "des-iv32";
			    break;
			    
			case IPSEC_ESP_RC4:
			    esp_enc_alg = "rc4";
			    break;
			    
			case IPSEC_ESP_NULL:
			    esp_enc_alg = "null";
			    break;
		    }
		    
		    break;
		    
		case IPSEC_PROTO_IPCOMP:
		    comp_present = "yes";
		    switch (proto->id)
		    {
			case IPSEC_IPCOMP_OUI:
			    comp_alg = "oui";
			    break;
			    
			case IPSEC_IPCOMP_DEFLATE:
			    comp_alg = "deflate";
			    break;
			    
			case IPSEC_IPCOMP_LZS:
			    comp_alg = "lzs";
			    break;
			    
			case IPSEC_IPCOMP_V42BIS:
			    comp_alg = "v42bis";
			    break;
		    }
		    
		    break;
	  }
	    
d354 2
a355 2
	       attr < proto->chosen->p + 
		      GET_ISAKMP_GEN_LENGTH (proto->chosen->p);
d357 4
a360 3
	  {
	      if (attr + ISAKMP_ATTR_VALUE_OFF > proto->chosen->p +
		  GET_ISAKMP_GEN_LENGTH (proto->chosen->p))
d362 1
a362 1

d376 81
a456 3
	      {
		  case IPSEC_ATTR_SA_LIFE_TYPE:
		      lifetype = decode_16 (value);
d459 4
a462 70
		  case IPSEC_ATTR_SA_LIFE_DURATION:
		      switch (proto->proto)
		      {
			  case IPSEC_PROTO_IPSEC_AH:
			      if (lifetype == IPSEC_DURATION_SECONDS)
			      {
				  if (len == 2)
				    sprintf (ah_life_seconds, "%d",
					     decode_16 (value));
				  else
				    sprintf (ah_life_seconds, "%d",
					     decode_32 (value));
			      }
			      else
			      {
				  if (len == 2)
				    sprintf (ah_life_kbytes, "%d",
					     decode_16 (value));
				  else
				    sprintf (ah_life_kbytes, "%d",
					     decode_32 (value));
			      }
			      
			      break;
		    
			  case IPSEC_PROTO_IPSEC_ESP:
			      if (lifetype == IPSEC_DURATION_SECONDS)
			      {
				  if (len == 2)
				    sprintf (esp_life_seconds, "%d",
					     decode_16 (value));
				  else
				    sprintf (esp_life_seconds, "%d",
					     decode_32 (value));
			      }
			      else
			      {
				  if (len == 2)
				    sprintf (esp_life_kbytes, "%d",
					     decode_16 (value));
				  else
				    sprintf (esp_life_kbytes, "%d",
					     decode_32 (value));
			      }
			      
			      break;
		    
			  case IPSEC_PROTO_IPCOMP:
			      if (lifetype == IPSEC_DURATION_SECONDS)
			      {
				  if (len == 2)
				    sprintf (comp_life_seconds, "%d",
					     decode_16 (value));
				  else
				    sprintf (comp_life_seconds, "%d",
					     decode_32 (value));
			      }
			      else
			      {
				  if (len == 2)
				    sprintf (comp_life_kbytes, "%d",
					     decode_16 (value));
				  else
				    sprintf (comp_life_kbytes, "%d",
					     decode_32 (value));
			      }
			      
			      break;
		      }
		      break;		      
d464 3
a466 17
		  case IPSEC_ATTR_GROUP_DESCRIPTION:
		      switch (proto->proto)
		      {
			  case IPSEC_PROTO_IPSEC_AH:
			      sprintf (ah_group_desc, "%d", decode_16 (value));
			      break;
		    
			  case IPSEC_PROTO_IPSEC_ESP:
			      sprintf (esp_group_desc, "%d",
				       decode_16 (value));
			      break;
		    
			  case IPSEC_PROTO_IPCOMP:
			      sprintf (comp_group_desc, "%d",
				       decode_16 (value));
			      break;
		      }
d468 6
a473 4
		      
		  case IPSEC_ATTR_ENCAPSULATION_MODE:
		    if (decode_16(value) == IPSEC_ENCAP_TUNNEL)
		      switch (proto->proto)
d475 11
a485 11
			  case IPSEC_PROTO_IPSEC_AH:
			      ah_encapsulation = "tunnel";
			      break;
		    
			  case IPSEC_PROTO_IPSEC_ESP:
			      esp_encapsulation = "tunnel";
			      break;
		    
			  case IPSEC_PROTO_IPCOMP:
			      comp_encapsulation = "tunnel";
			      break;
d487 2
a488 2
		    else
		      switch (proto->proto)
d490 11
a500 11
			  case IPSEC_PROTO_IPSEC_AH:
			      ah_encapsulation = "transport";
			      break;
		    
			  case IPSEC_PROTO_IPSEC_ESP:
			      esp_encapsulation = "transport";
			      break;
		    
			  case IPSEC_PROTO_IPCOMP:
			      comp_encapsulation = "transport";
			      break;
d502 25
a526 1
		    break;
d528 33
a560 45
		  case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
		      switch (proto->proto)
		      {
			  case IPSEC_PROTO_IPSEC_AH:
			      switch (decode_16 (value))
			      {
				  case IPSEC_AUTH_HMAC_MD5:
				      ah_auth_alg = "hmac-md5";
				      break;
				      
				  case IPSEC_AUTH_HMAC_SHA:
				      ah_auth_alg = "hmac-sha";
				      break;
				      
				  case IPSEC_AUTH_DES_MAC:
				      ah_auth_alg = "des-mac";
				      break;
				      
				  case IPSEC_AUTH_KPDK:
				      ah_auth_alg = "kpdk";
				      break;
			      }
			      break;
		    
			  case IPSEC_PROTO_IPSEC_ESP:
			      switch (decode_16 (value))
			      {
				  case IPSEC_AUTH_HMAC_MD5:
				      esp_auth_alg = "hmac-md5";
				      break;
				      
				  case IPSEC_AUTH_HMAC_SHA:
				      esp_auth_alg = "hmac-sha";
				      break;
				      
				  case IPSEC_AUTH_DES_MAC:
				      esp_auth_alg = "des-mac";
				      break;
				      
				  case IPSEC_AUTH_KPDK:
				      esp_auth_alg = "kpdk";
				      break;
			      }
			      break;
		      }
d562 2
d565 5
a569 12
		  case IPSEC_ATTR_KEY_LENGTH:
		      switch (proto->proto)
		      {
			  case IPSEC_PROTO_IPSEC_AH:
			      sprintf (ah_key_length, "%d", decode_16 (value));
			      break;
		    
			  case IPSEC_PROTO_IPSEC_ESP:
			      sprintf (esp_key_length, "%d",
				       decode_16 (value));
			      break;
		      }
d572 3
a574 12
		  case IPSEC_ATTR_KEY_ROUNDS:
		      switch (proto->proto)
		      {
			  case IPSEC_PROTO_IPSEC_AH:
			      sprintf (ah_key_rounds, "%d", decode_16 (value));
			      break;
		    
			  case IPSEC_PROTO_IPSEC_ESP:
			      sprintf (esp_key_rounds, "%d",
				       decode_16 (value));
			      break;
		      }
d576 2
a577 11
		      
		  case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
		    sprintf (comp_dict_size, "%d", decode_16(value));
		    break;

		  case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
		    sprintf (comp_private_alg, "%d", decode_16 (value));
		    break;
	      }
	  }
      }
d579 517
a1095 1
      /* Unset dirty now */
d1097 1
a1097 3
  }

  /* XXX Need to initialize the ID variables */
d1107 1
a1107 1
    
d1110 1
a1110 1
    
d1113 1
a1113 1
    
d1124 1
a1124 1
      return esp_enc_alg;
d1128 1
a1128 1
      
d1131 1
a1131 1
      
d1134 1
a1134 1
      
d1137 1
a1137 1
      
d1140 1
a1140 1
      
d1143 1
a1143 1
      
d1146 1
a1146 1
      
d1149 1
a1149 1
      
d1152 1
a1152 1
      
d1155 1
a1155 1
      
d1158 1
a1158 1
      
d1164 1
a1164 1
      
d1167 1
a1167 1
      
d1170 1
a1170 1
      
d1174 14
a1187 2
  if (strcmp (name, "id_initiator_type") == 0)
    return id_initiator_type;
d1189 2
a1190 2
  if (strcmp (name, "id_initiator") == 0)
    return id_initiator;
d1192 2
a1193 2
  if (strcmp (name, "id_initiator_addr_upper") == 0)
    return id_initiator_addr_upper;
d1195 2
a1196 2
  if (strcmp (name, "id_initiator_addr_lower") == 0)
    return id_initiator_addr_lower;
d1198 2
a1199 2
  if (strcmp (name, "id_responder_type") == 0)
    return id_responder_type;
d1201 2
a1202 2
  if (strcmp (name, "id_responder") == 0)
    return id_responder;
d1204 2
a1205 2
  if (strcmp (name, "id_responder_addr_upper") == 0)
    return id_responder_addr_upper;
d1207 26
a1232 2
  if (strcmp (name, "id_responder_addr_lower") == 0)
    return id_responder_addr_lower;
d1247 6
a1252 1
  /* If there exists a session already, release all its resources */
d1254 1
a1254 1
    kn_close (keynote_sessid);
d1256 2
a1257 2
  /* Initialize a session */
  keynote_sessid = kn_init ();
d1259 1
a1259 1
    log_fatal ("kn_init()");
d1261 1
a1261 1
  /* Get policy file from configuration */
d1266 1
a1266 1
  /* Open policy file */
d1269 1
a1269 1
    log_fatal ("open (\"%s\", O_RDONLY)", policy_file);
d1271 1
a1271 1
  /* Get size */
d1273 1
a1273 1
    log_fatal ("fstat (%d, &st)", fd);
d1275 1
a1275 1
  /* Allocate memory to keep policies */
d1278 2
a1279 1
    log_fatal ("calloc (%d, %d)", st.st_size, sizeof (char));
d1281 1
a1281 1
  /* Just in case there's short reads... */
d1283 6
a1288 2
    if ((i = read (fd, ptr + len, st.st_size - len)) == -1)
      log_fatal ("read (%d, %p, %d)", fd, ptr + len, st.st_size - len);
d1290 1
a1290 1
  /* We're done with this */
d1293 2
a1294 2
  /* Parse buffer, break up into individual policies */
  asserts = kn_read_asserts (ptr, st.st_size, &i);
d1296 1
a1296 1
  /* Begone */
d1299 1
a1299 1
  /* Add each individual policy in the session */
d1301 6
a1306 4
  {
      if (kn_add_assertion (keynote_sessid, asserts[fd], strlen (asserts[fd]),
                            ASSERT_FLAG_LOCAL) == -1)
        log_fatal ("kn_add_assertion (%d, %p, %d, ASSERT_FLAG_LOCAL)",
d1310 1
a1310 1
  }
d1315 6
a1320 4
  /* Add the callback that will handle attributes */
  if (kn_add_action (keynote_sessid, ".*", (char *) policy_callback,
		     ENVIRONMENT_FLAG_FUNC | ENVIRONMENT_FLAG_REGEX) == -1)
    log_fatal ("kn_add_action (%d, \".*\", %p, FUNC | REGEX)",
@

