head	1.32;
access;
symbols
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.8
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.22
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.14
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.18
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.16
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.12
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.10
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.8
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.6
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.8
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.4
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.32
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	0qPuuXwccpVXsXcV;

1.31
date	2011.02.03.08.49.46;	author phessler;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.28.17.57.15;	author hshoexer;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.21.13.32.56;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.15.19.37.46;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches
	1.26.2.1
	1.26.4.1;
next	1.25;

1.25
date	2005.11.13.18.24.24;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.27.08.19.59;	author hshoexer;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.25.13.35.47;	author hshoexer;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.25.09.57.58;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.08.19.40.03;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.08.16.37.15;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.08.16.07.22;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.07.18.43.17;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.05.18.06.06;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.05.12.21.35;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.04.16.55.15;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.14.10.17.28;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.20.21.36.50;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.10.19.21.01;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.03.10.54.09;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.08.19.53.46;	author hshoexer;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.22.03.44.55;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.21.18.40.01;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.21.13.09.01;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	;

1.26.2.1
date	2007.05.18.21.34.43;	author ckuethe;	state Exp;
branches;
next	;

1.26.4.1
date	2007.05.18.21.34.07;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.32
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@/*	$OpenBSD: virtual.c,v 1.31 2011/02/03 08:49:46 phessler Exp $	*/

/*
 * Copyright (c) 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <limits.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "conf.h"
#include "if.h"
#include "exchange.h"
#include "log.h"
#include "message.h"
#include "nat_traversal.h"
#include "transport.h"
#include "virtual.h"
#include "udp.h"
#include "util.h"

#include "udp_encap.h"

static struct transport	*virtual_bind(const struct sockaddr *);
static struct transport	*virtual_bind_ADDR_ANY(sa_family_t);
static int		 virtual_bind_if(char *, struct sockaddr *, void *);
static struct transport	*virtual_clone(struct transport *, struct sockaddr *);
static struct transport	*virtual_create(char *);
static char		*virtual_decode_ids (struct transport *);
static void		 virtual_get_dst(struct transport *,
			     struct sockaddr **);
static struct msg_head	*virtual_get_queue(struct message *);
static void		 virtual_get_src(struct transport *,
			     struct sockaddr **);
static void		 virtual_handle_message(struct transport *);
static void		 virtual_reinit(void);
static void		 virtual_remove(struct transport *);
static void		 virtual_report(struct transport *);
static int		 virtual_send_message(struct message *,
			     struct transport *);

static struct transport_vtbl virtual_transport_vtbl = {
	{ 0 }, "udp",
	virtual_create,
	virtual_reinit,
	virtual_remove,
	virtual_report,
	0,
	0,
	virtual_handle_message,
	virtual_send_message,
	virtual_get_dst,
	virtual_get_src,
	virtual_decode_ids,
	virtual_clone,
	virtual_get_queue
};

static LIST_HEAD (virtual_listen_list, virtual_transport) virtual_listen_list;
static struct transport *default_transport, *default_transport6;

void
virtual_init(void)
{
	struct conf_list *listen_on;

	LIST_INIT(&virtual_listen_list);

	transport_method_add(&virtual_transport_vtbl);

	/* Bind the ISAKMP port(s) on all network interfaces we have.  */
	if (if_map(virtual_bind_if, 0) == -1)
		log_fatal("virtual_init: "
		    "could not bind the ISAKMP port(s) on all interfaces");

	/* Only listen to the specified address if Listen-on is configured */
	listen_on = conf_get_list("General", "Listen-on");
	if (listen_on) {
		LOG_DBG((LOG_TRANSPORT, 50,
		    "virtual_init: not binding ISAKMP port(s) to ADDR_ANY"));
		conf_free_list(listen_on);
		return;
	}

	/*
	 * Bind to INADDR_ANY in case of new addresses popping up.
	 * Packet reception on this transport is taken as a hint to reprobe the
	 * interface list.
	 */
	if (!bind_family || (bind_family & BIND_FAMILY_INET4)) {
		default_transport = virtual_bind_ADDR_ANY(AF_INET);
		if (!default_transport)
			return;
		LIST_INSERT_HEAD(&virtual_listen_list,
		    (struct virtual_transport *)default_transport, link);
		transport_reference(default_transport);
	}

	if (!bind_family || (bind_family & BIND_FAMILY_INET6)) {
		default_transport6 = virtual_bind_ADDR_ANY(AF_INET6);
		if (!default_transport6)
			return;
		LIST_INSERT_HEAD(&virtual_listen_list,
		    (struct virtual_transport *)default_transport6, link);
		transport_reference(default_transport6);
	}
}

struct virtual_transport *
virtual_get_default(sa_family_t af)
{
	switch (af) {
	case AF_INET:
		return (struct virtual_transport *)default_transport;
	case AF_INET6:
		return (struct virtual_transport *)default_transport6;
	default:
		return 0;
	}
}

/*
 * Probe the interface list and determine what new interfaces have
 * appeared.
 *
 * At the same time, we try to determine whether existing interfaces have
 * been rendered invalid; we do this by marking all virtual transports before
 * we call virtual_bind_if() through if_map(), and then releasing those
 * transports that have not been unmarked.
 */
void
virtual_reinit(void)
{
	struct virtual_transport *v, *v2;

	/* Mark all UDP transports, except the default ones. */
	for (v = LIST_FIRST(&virtual_listen_list); v; v = LIST_NEXT(v, link))
		if (&v->transport != default_transport &&
		    &v->transport != default_transport6)
			v->transport.flags |= TRANSPORT_MARK;

	/* Re-probe interface list.  */
	if (if_map(virtual_bind_if, 0) == -1)
		log_print("virtual_init: "
		    "could not bind the ISAKMP port(s) on all interfaces");

	/*
	 * Release listening transports for local addresses that no
	 * longer exist. virtual_bind_if () will have left those still marked.
	 */
	v = LIST_FIRST(&virtual_listen_list);
	while (v) {
		v2 = LIST_NEXT(v, link);
		if (v->transport.flags & TRANSPORT_MARK) {
			LIST_REMOVE(v, link);
			transport_release(&v->transport);
		}
		v = v2;
	}
}

struct virtual_transport *
virtual_listen_lookup(struct sockaddr *addr)
{
	struct virtual_transport *v;
	struct udp_transport	 *u;

	for (v = LIST_FIRST(&virtual_listen_list); v;
	    v = LIST_NEXT(v, link)) {
		if (!(u = (struct udp_transport *)v->main))
			if (!(u = (struct udp_transport *)v->encap)) {
				log_print("virtual_listen_lookup: "
				    "virtual %p has no low-level transports",
				    v);
				continue;
			}

		if (u->src->sa_family == addr->sa_family &&
		    sockaddr_addrlen(u->src) == sockaddr_addrlen(addr) &&
		    memcmp(sockaddr_addrdata (u->src), sockaddr_addrdata(addr),
		    sockaddr_addrlen(addr)) == 0)
			return v;
	}

	LOG_DBG((LOG_TRANSPORT, 40, "virtual_listen_lookup: no match"));
	return 0;
}

/*
 * Initialize an object of the VIRTUAL transport class.
 */
static struct transport *
virtual_bind(const struct sockaddr *addr)
{
	struct virtual_transport *v;
	struct sockaddr_storage	  tmp_sa;
	char	*stport;
	in_port_t port;

	v = calloc(1, sizeof *v);
	if (!v) {
		log_error("virtual_bind: calloc(1, %lu) failed",
		    (unsigned long)sizeof *v);
		return 0;
	}

	v->transport.vtbl = &virtual_transport_vtbl;

	memcpy(&tmp_sa, addr, SA_LEN(addr));

	/* Get port. */
	stport = udp_default_port ? udp_default_port : UDP_DEFAULT_PORT_STR;
	port = text2port(stport);
	if (port == 0) {
		log_print("virtual_bind: bad port \"%s\"", stport);
		free(v);
		return 0;
	}

	sockaddr_set_port((struct sockaddr *)&tmp_sa, port);
	v->main = udp_bind((struct sockaddr *)&tmp_sa);
	if (!v->main) {
		free(v);
		return 0;
	}
	v->main->virtual = (struct transport *)v;

	if (!disable_nat_t) {
		memcpy(&tmp_sa, addr, SA_LEN(addr));

		/* Get port. */
		stport = udp_encap_default_port
		    ? udp_encap_default_port : UDP_ENCAP_DEFAULT_PORT_STR;
		port = text2port(stport);
		if (port == 0) {
			log_print("virtual_bind: bad encap port \"%s\"",
			    stport);
			v->main->vtbl->remove(v->main);
			free(v);
			return 0;
		}

		sockaddr_set_port((struct sockaddr *)&tmp_sa, port);
		v->encap = udp_encap_bind((struct sockaddr *)&tmp_sa);
		if (!v->encap) {
			v->main->vtbl->remove(v->main);
			free(v);
			return 0;
		}
		v->encap->virtual = (struct transport *)v;
	}
	v->encap_is_active = 0;

	transport_setup(&v->transport, 1);
	v->transport.flags |= TRANSPORT_LISTEN;

	return (struct transport *)v;
}

static struct transport *
virtual_bind_ADDR_ANY(sa_family_t af)
{
	struct sockaddr_storage dflt_stor;
	struct sockaddr_in	*d4 = (struct sockaddr_in *)&dflt_stor;
	struct sockaddr_in6	*d6 = (struct sockaddr_in6 *)&dflt_stor;
	struct transport	*t;
	struct in6_addr		in6addr_any = IN6ADDR_ANY_INIT;

	bzero(&dflt_stor, sizeof dflt_stor);
	switch (af) {
	case AF_INET:
		d4->sin_family = af;
		d4->sin_len = sizeof(struct sockaddr_in);
		d4->sin_addr.s_addr = INADDR_ANY;
		break;

	case AF_INET6:
		d6->sin6_family = af;
		d6->sin6_len = sizeof(struct sockaddr_in6);
		memcpy(&d6->sin6_addr.s6_addr, &in6addr_any,
		    sizeof in6addr_any);
		break;
	}

	t = virtual_bind((struct sockaddr *)&dflt_stor);
	if (!t)
		log_error("virtual_bind_ADDR_ANY: "
		    "could not allocate default IPv%s ISAKMP port(s)",
		    af == AF_INET ? "4" : "6");
	return t;
}

static int
virtual_bind_if(char *ifname, struct sockaddr *if_addr, void *arg)
{
	struct conf_list	*listen_on;
	struct virtual_transport *v;
	struct conf_list_node	*address;
	struct sockaddr		*addr;
	struct transport	*t;
	struct ifreq		flags_ifr;
	struct in6_ifreq	flags_ifr6;
	char	*addr_str;
	int	 s, error;

	if (sockaddr2text(if_addr, &addr_str, 0))
		addr_str = 0;

	LOG_DBG((LOG_TRANSPORT, 90,
	    "virtual_bind_if: interface %s family %s address %s",
	    ifname ? ifname : "<unknown>",
	    if_addr->sa_family == AF_INET ? "v4" :
	    (if_addr->sa_family == AF_INET6 ? "v6" : "<unknown>"),
	    addr_str ? addr_str : "<invalid>"));
	free(addr_str);

	/*
	 * Drop non-Internet stuff.
	 */
	if ((if_addr->sa_family != AF_INET ||
	    SA_LEN(if_addr) != sizeof (struct sockaddr_in)) &&
	    (if_addr->sa_family != AF_INET6 ||
	    SA_LEN(if_addr) != sizeof (struct sockaddr_in6)))
		return 0;

	/*
	 * Only create sockets for families we should listen to.
	 */
	if (bind_family)
		switch (if_addr->sa_family) {
		case AF_INET:
			if ((bind_family & BIND_FAMILY_INET4) == 0)
				return 0;
			break;
		case AF_INET6:
			if ((bind_family & BIND_FAMILY_INET6) == 0)
				return 0;
			break;
		default:
			return 0;
		}

	/*
	 * These special addresses are not useable as they have special meaning
	 * in the IP stack.
	 */
	if (if_addr->sa_family == AF_INET &&
	    (((struct sockaddr_in *)if_addr)->sin_addr.s_addr == INADDR_ANY ||
	    (((struct sockaddr_in *)if_addr)->sin_addr.s_addr == INADDR_NONE)))
		return 0;

	/*
	 * Go through the list of transports and see if we already have this
	 * address bound. If so, unmark the transport and skip it; this allows
	 * us to call this function when we suspect a new address has appeared.
	 */
	if ((v = virtual_listen_lookup(if_addr)) != 0) {
		LOG_DBG ((LOG_TRANSPORT, 90, "virtual_bind_if: "
		    "already bound"));
		v->transport.flags &= ~TRANSPORT_MARK;
		return 0;
	}

	/*
	 * Don't bother with interfaces that are down.
	 * Note: This socket is only used to collect the interface status,
	 * rtables and inet6 addresses.
	 */
	s = socket(if_addr->sa_family, SOCK_DGRAM, 0);
	if (s == -1) {
		log_error("virtual_bind_if: "
		    "socket (%d, SOCK_DGRAM, 0) failed", if_addr->sa_family);
		return -1;
	}
	strlcpy(flags_ifr.ifr_name, ifname, sizeof flags_ifr.ifr_name);
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&flags_ifr) == -1) {
		log_error("virtual_bind_if: "
		    "ioctl (%d, SIOCGIFFLAGS, ...) failed", s);
		close(s);
		return -1;
	}
	if (!(flags_ifr.ifr_flags & IFF_UP)) {
		close(s);
		return 0;
	}
	/* Also skip tentative addresses during DAD since bind(2) would fail. */
	if (if_addr->sa_family == AF_INET6) {
		memset(&flags_ifr6, 0, sizeof(flags_ifr6));
		strlcpy(flags_ifr6.ifr_name, ifname, sizeof flags_ifr6.ifr_name);
		flags_ifr6.ifr_addr = *(struct sockaddr_in6 *)if_addr;
		if (ioctl(s, SIOCGIFAFLAG_IN6, (caddr_t)&flags_ifr6) < 0) {
			log_error("virtual_bind_if: "
			    "ioctl (%d, SIOCGIFAFLAG_IN6, ...) failed", s);
			close(s);
			return 0;
		}
		if (flags_ifr6.ifr_ifru.ifru_flags6 & (IN6_IFF_ANYCAST|
		    IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED|IN6_IFF_DETACHED)) {
			error = sockaddr2text(if_addr, &addr_str, 0);
			log_print("virtual_bind_if: "
			    "IPv6 address %s not ready (flags 0x%x)",
			    error ? "unknown" : addr_str,
			    flags_ifr6.ifr_ifru.ifru_flags6);
			/* XXX schedule an interface rescan */
			if (!error)
				free(addr_str);
			close(s);
			return 0;
		}
	}

	if (ioctl(s, SIOCGIFRDOMAIN, (caddr_t)&flags_ifr) == -1) {
		log_error("virtual_bind_if: "
		    "ioctl (%d, SIOCGIFRDOMAIN, ...) failed", s);
		close(s);
		return -1;
	}

	/*
	 * Ignore interfaces outside of our rtable
	 */
	if (getrtable() != flags_ifr.ifr_rdomainid) {
		close(s);
		return 0;
	}

	close(s);

	/* Set the port number to zero.  */
	switch (if_addr->sa_family) {
	case AF_INET:
		((struct sockaddr_in *)if_addr)->sin_port = htons(0);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)if_addr)->sin6_port = htons(0);
		break;
	default:
		log_print("virtual_bind_if: unsupported protocol family %d",
		    if_addr->sa_family);
		break;
	}

	/*
	 * If we are explicit about what addresses we can listen to, be sure
	 * to respect that option.
	 * This is quite wasteful redoing the list-run for every interface,
	 * but who cares?  This is not an operation that needs to be fast.
	 */
	listen_on = conf_get_list("General", "Listen-on");
	if (listen_on) {
		for (address = TAILQ_FIRST(&listen_on->fields); address;
		    address = TAILQ_NEXT(address, link)) {
			if (text2sockaddr(address->field, 0, &addr, 0, 0)) {
				log_print("virtual_bind_if: "
				    "invalid address %s in \"Listen-on\"",
				    address->field);
				continue;
			}

			/* If found, take the easy way out. */
			if (memcmp(addr, if_addr, SA_LEN(addr)) == 0) {
				free(addr);
				break;
			}
			free(addr);
		}
		conf_free_list(listen_on);

		/*
		 * If address is zero then we did not find the address among
		 * the ones we should listen to.
		 * XXX We do not discover if we do not find our listen
		 * addresses. Maybe this should be the other way round.
		 */
		if (!address)
			return 0;
	}

	t = virtual_bind(if_addr);
	if (!t) {
		error = sockaddr2text(if_addr, &addr_str, 0);
		log_print("virtual_bind_if: failed to create a socket on %s",
		    error ? "unknown" : addr_str);
		if (!error)
			free(addr_str);
		return -1;
	}
	LIST_INSERT_HEAD(&virtual_listen_list, (struct virtual_transport *)t,
	    link);
	transport_reference(t);
	return 0;
}

static struct transport *
virtual_clone(struct transport *vt, struct sockaddr *raddr)
{
	struct virtual_transport *v = (struct virtual_transport *)vt;
	struct virtual_transport *v2;
	struct transport	 *t;
	char			 *stport;
	in_port_t		  port;

	t = malloc(sizeof *v);
	if (!t) {
		log_error("virtual_clone: malloc(%lu) failed",
		    (unsigned long)sizeof *v);
		return 0;
	}
	v2 = (struct virtual_transport *)t;

	memcpy(v2, v, sizeof *v);
	/* Remove the copy's links into virtual_listen_list.  */
	memset(&v2->link, 0, sizeof v2->link);

	if (v->encap_is_active)
		v2->main = 0; /* No need to clone this.  */
	else {
		v2->main = v->main->vtbl->clone(v->main, raddr);
		v2->main->virtual = (struct transport *)v2;
	}
	if (!disable_nat_t) {
		stport = udp_encap_default_port ? udp_encap_default_port :
		    UDP_ENCAP_DEFAULT_PORT_STR;
		port = text2port(stport);
		if (port == 0) {
			log_print("virtual_clone: port string \"%s\" not convertible "
			    "to in_port_t", stport);
			free(t);
			return 0;
		}
		sockaddr_set_port(raddr, port);
		v2->encap = v->encap->vtbl->clone(v->encap, raddr);
		v2->encap->virtual = (struct transport *)v2;
	}
	LOG_DBG((LOG_TRANSPORT, 50, "virtual_clone: old %p new %p (%s is %p)",
	    v, t, v->encap_is_active ? "encap" : "main",
	    v->encap_is_active ? v2->encap : v2->main));

	t->flags &= ~TRANSPORT_LISTEN;
	transport_setup(t, 1);
	return t;
}

static struct transport *
virtual_create(char *name)
{
	struct virtual_transport *v;
	struct transport	 *t, *t2 = 0;

	t = transport_create("udp_physical", name);
	if (!t)
		return 0;

	if (!disable_nat_t) {
		t2 = transport_create("udp_encap", name);
		if (!t2) {
			t->vtbl->remove(t);
			return 0;
		}
	}

	v = calloc(1, sizeof *v);
	if (!v) {
		log_error("virtual_create: calloc(1, %lu) failed",
		    (unsigned long)sizeof *v);
		t->vtbl->remove(t);
		if (t2)
			t2->vtbl->remove(t2);
		return 0;
	}

	memcpy(v, t, sizeof *t);
	v->transport.virtual = 0;
	v->main = t;
	v->encap = t2;
	v->transport.vtbl = &virtual_transport_vtbl;
	t->virtual = (struct transport *)v;
	if (t2)
		t2->virtual = (struct transport *)v;
	transport_setup(&v->transport, 1);
	return (struct transport *)v;
}

static void
virtual_remove(struct transport *t)
{
	struct virtual_transport *p, *v = (struct virtual_transport *)t;

	if (v->encap)
		v->encap->vtbl->remove(v->encap);
	if (v->main)
		v->main->vtbl->remove(v->main);

	for (p = LIST_FIRST(&virtual_listen_list); p && p != v; p =
	    LIST_NEXT(p, link))
		;
	if (p == v)
		LIST_REMOVE(v, link);

	LOG_DBG((LOG_TRANSPORT, 90, "virtual_remove: removed %p", v));
	free(t);
}

static void
virtual_report(struct transport *t)
{
}

static void
virtual_handle_message(struct transport *t)
{
	/*
	 * As per the NAT-T draft, in case we have already switched ports,
	 * any messages received on the old (500) port SHOULD be discarded.
	 * (Actually, while phase 1 messages should be discarded,
	 *  informational exchanges MAY be processed normally. For now, we
	 *  discard them all.)
	 */
	if (((struct virtual_transport *)t->virtual)->encap_is_active &&
	    ((struct virtual_transport *)t->virtual)->main == t) {
		LOG_DBG((LOG_MESSAGE, 10, "virtual_handle_message: "
		    "message on old port discarded"));
		return;
	}

	t->vtbl->handle_message(t);
}

static int
virtual_send_message(struct message *msg, struct transport *t)
{
	struct virtual_transport *v =
	    (struct virtual_transport *)msg->transport;
	struct sockaddr *dst;
	in_port_t port, default_port;

	/*
	 * Activate NAT-T Encapsulation if
	 *   - the exchange says we can, and
	 *   - in ID_PROT, after step 4 (draft-ietf-ipsec-nat-t-ike-03), or
	 *   - in other exchange (Aggressive, ), asap
	 * XXX ISAKMP_EXCH_BASE etc?
	 */

	if (msg->flags & MSG_NATT) {
		msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_ENABLE;
		msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_CAP_PEER;
	}

	if ((v->encap_is_active == 0 &&
	    (msg->exchange->flags & EXCHANGE_FLAG_NAT_T_ENABLE) &&
	    (msg->exchange->type != ISAKMP_EXCH_ID_PROT ||
		msg->exchange->step > 4)) || (msg->flags & MSG_NATT)) {
		LOG_DBG((LOG_MESSAGE, 10, "virtual_send_message: "
		    "enabling NAT-T encapsulation for this exchange"));
		v->encap_is_active++;

		/* Copy destination port if it is translated (NAT).  */
		v->main->vtbl->get_dst(v->main, &dst);
		port = ntohs(sockaddr_port(dst));

		if (udp_default_port)
			default_port = text2port(udp_default_port);
		else
			default_port = UDP_DEFAULT_PORT;
		if (port != default_port) {
			v->main->vtbl->get_dst(v->encap, &dst);
			sockaddr_set_port(dst, port);
		}
	}

	if (v->encap_is_active)
		return v->encap->vtbl->send_message(msg, v->encap);
	else
		return v->main->vtbl->send_message(msg, v->main);
}

static void
virtual_get_src(struct transport *t, struct sockaddr **s)
{
	struct virtual_transport *v = (struct virtual_transport *)t;

	if (v->encap_is_active)
		v->encap->vtbl->get_src(v->encap, s);
	else
		v->main->vtbl->get_src(v->main, s);
}

static void
virtual_get_dst(struct transport *t, struct sockaddr **s)
{
	struct virtual_transport *v = (struct virtual_transport *)t;

	if (v->encap_is_active)
		v->encap->vtbl->get_dst(v->encap, s);
	else
		v->main->vtbl->get_dst(v->main, s);
}

static char *
virtual_decode_ids(struct transport *t)
{
	struct virtual_transport *v = (struct virtual_transport *)t;

	if (v->encap_is_active)
		return v->encap->vtbl->decode_ids(t);
	else
		return v->main->vtbl->decode_ids(t);
}

static struct msg_head *
virtual_get_queue(struct message *msg)
{
	if (msg->flags & MSG_PRIORITIZED)
		return &msg->transport->prio_sendq;
	else
		return &msg->transport->sendq;
}
@


1.31
log
@When binding to addresses, ignore any IP address not in the current
routing domain.

While here, update comment on what the ioctl is used for (from sthen@@).

OK mikeb@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.30 2009/01/28 17:57:15 hshoexer Exp $	*/
d231 1
a231 1
	v = (struct virtual_transport *)calloc(1, sizeof *v);
d593 1
a593 1
	v = (struct virtual_transport *)calloc(1, sizeof *v);
@


1.30
log
@cleaning up my tree:  trivial KNF and a comment fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.29 2008/10/21 13:32:56 markus Exp $	*/
d397 2
a398 1
	 * Note: This socket is only used to collect the interface status.
d442 16
@


1.29
log
@do not listen on tentative (during DAD), duplicated (after DAD) or
detached addresses. bind(2) will not allow this. ok hshoexer, fries
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.28 2007/04/16 13:01:39 moritz Exp $	*/
d159 1
a159 1
 * we call virtual_bind_if () through if_map (), and then releasing those
@


1.28
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.27 2007/04/15 19:37:46 hshoexer Exp $	*/
d33 1
d333 1
d412 29
a441 2
	if (!(flags_ifr.ifr_flags & IFF_UP))
		return 0;
@


1.27
log
@Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.26 2006/06/02 19:35:55 hshoexer Exp $	*/
d344 1
a344 2
	if (addr_str)
		free(addr_str);
@


1.26
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.25 2005/11/13 18:24:24 hshoexer Exp $	*/
d630 7
a636 1
	if (v->encap_is_active == 0 &&
d639 1
a639 1
		msg->exchange->step > 4)) {
@


1.26.2.1
log
@Original Commit by hshoexer@@, original commit message:
===========================================================================
Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
===========================================================================
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.26 2006/06/02 19:35:55 hshoexer Exp $	*/
d630 1
a630 7

	if (msg->flags & MSG_NATT) {
		msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_ENABLE;
		msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_CAP_PEER;
	}

	if ((v->encap_is_active == 0 &&
d633 1
a633 1
		msg->exchange->step > 4)) || (msg->flags & MSG_NATT)) {
@


1.26.4.1
log
@Original Commit by hshoexer@@, original commit message:
===========================================================================
Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
===========================================================================
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.26 2006/06/02 19:35:55 hshoexer Exp $	*/
d630 1
a630 7

	if (msg->flags & MSG_NATT) {
		msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_ENABLE;
		msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_CAP_PEER;
	}

	if ((v->encap_is_active == 0 &&
d633 1
a633 1
		msg->exchange->step > 4)) || (msg->flags & MSG_NATT)) {
@


1.25
log
@zap unused variable and silence gcc.
From Mike Belopuhov <mkb at crypt dot org dot ru>
Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.24 2005/10/27 08:19:59 hshoexer Exp $	*/
d600 1
a600 1
	 * any messages recieved on the old (500) port SHOULD be discarded.
@


1.24
log
@Do not touch LIST_* macro internals.

with otto@@, ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.23 2005/10/25 13:35:47 hshoexer Exp $	*/
d573 1
a573 1
	struct virtual_transport *p, *next, *v = (struct virtual_transport *)t;
@


1.23
log
@some small knf, ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.22 2005/08/25 09:57:58 markus Exp $	*/
d499 1
a499 2
	v2->link.le_next = 0;
	v2->link.le_prev = 0;
d573 1
a573 1
	struct virtual_transport *v = (struct virtual_transport *)t;
d579 5
a583 1
	if (v->link.le_prev)
@


1.22
log
@read the information from the INADDR_ANY socket and do not loop if
a new IP appears (cf udp.c, rev 1.74), ok ho@@ hshoexer@@ cloder@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.21 2005/04/08 23:15:26 hshoexer Exp $	*/
d61 1
a61 1
    struct sockaddr **);
d64 1
a64 1
    struct sockaddr **);
d70 1
a70 1
    struct transport *);
@


1.21
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.20 2005/04/08 19:40:03 deraadt Exp $	*/
a594 14
	if (t->virtual == default_transport ||
	    t->virtual == default_transport6) {
		/* XXX drain pending message. See udp_handle_message().  */

		virtual_reinit();

		/*
		 * As we don't know the actual destination address of the
		 * packet, we can't really deal with it. So, just ignore it
		 * and hope we catch the retransmission.
		 */
		return;
	}

@


1.20
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.19 2005/04/08 16:37:15 deraadt Exp $	*/
d239 1
a239 1
	memcpy(&tmp_sa, addr, sysdep_sa_len((struct sockaddr *)addr));
d259 1
a259 1
		memcpy(&tmp_sa, addr, sysdep_sa_len((struct sockaddr *)addr));
d351 1
a351 1
	    sysdep_sa_len(if_addr) != sizeof (struct sockaddr_in)) &&
d353 1
a353 1
	    sysdep_sa_len(if_addr) != sizeof (struct sockaddr_in6)))
d447 1
a447 2
			if (memcmp(addr, if_addr,
			    sysdep_sa_len(addr)) == 0) {
@


1.19
log
@nat-traversal always
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.18 2005/04/08 16:07:22 cloder Exp $	*/
a334 1
#if defined (USE_DEBUG)
a345 1
#endif
@


1.18
log
@Remove references to LINUX_IPSEC
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.17 2005/04/07 18:43:17 hshoexer Exp $	*/
a51 1
#if defined (USE_NAT_TRAVERSAL)
a52 1
#endif
a257 1
#if defined (USE_NAT_TRAVERSAL)
a281 1
#endif
a510 1
#if defined (USE_NAT_TRAVERSAL)
a524 1
#endif
a543 1
#if defined (USE_NAT_TRAVERSAL)
a550 1
#endif
a633 1
#if defined (USE_NAT_TRAVERSAL)
a664 1
#endif /* USE_NAT_TRAVERSAL */
@


1.17
log
@remove unnecessary typecasts.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.16 2005/04/06 16:00:20 deraadt Exp $	*/
a29 1
#ifndef linux
a30 1
#endif
a306 1
#if !defined (LINUX_IPSEC)
a307 1
#endif
a312 1
#if !defined (LINUX_IPSEC)
a313 1
#endif
@


1.16
log
@knf, ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.15 2005/04/05 18:06:06 cloder Exp $	*/
d260 1
a260 1
	((struct transport *)v->main)->virtual = (struct transport *)v;
d285 1
a285 1
		((struct transport *)v->encap)->virtual = (struct transport *)v;
@


1.15
log
@Add -T flag to isakmpd to disable NAT-T support from the command line.
This lets binat setups work again without having to recompile isakmpd.
OK ho, hshoexer.
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.14 2005/04/04 19:31:11 deraadt Exp $	*/
d172 2
a173 2
		if (&v->transport != default_transport
		    && &v->transport != default_transport6)
d212 4
a215 5
		if (u->src->sa_family == addr->sa_family
		    && sockaddr_addrlen(u->src) == sockaddr_addrlen(addr)
		    && memcmp(sockaddr_addrdata (u->src),
			sockaddr_addrdata(addr),
			sockaddr_addrlen(addr)) == 0)
d362 4
a365 4
	if ((if_addr->sa_family != AF_INET
	    || sysdep_sa_len(if_addr) != sizeof (struct sockaddr_in))
	    && (if_addr->sa_family != AF_INET6
		|| sysdep_sa_len(if_addr) != sizeof (struct sockaddr_in6)))
d389 3
a391 4
	if (if_addr->sa_family == AF_INET
	    && (((struct sockaddr_in *)if_addr)->sin_addr.s_addr == INADDR_ANY
		|| (((struct sockaddr_in *)if_addr)->sin_addr.s_addr
		    == INADDR_NONE)))
@


1.14
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.13 2005/03/05 12:21:35 ho Exp $	*/
d47 2
d264 2
a265 1
	memcpy(&tmp_sa, addr, sysdep_sa_len((struct sockaddr *)addr));
d267 11
a277 10
	/* Get port. */
	stport = udp_encap_default_port
	    ? udp_encap_default_port : UDP_ENCAP_DEFAULT_PORT_STR;
	port = text2port(stport);
	if (port == 0) {
		log_print("virtual_bind: bad encap port \"%s\"", stport);
		v->main->vtbl->remove(v->main);
		free(v);
		return 0;
	}
d279 8
a286 6
	sockaddr_set_port((struct sockaddr *)&tmp_sa, port);
	v->encap = udp_encap_bind((struct sockaddr *)&tmp_sa);
	if (!v->encap) {
		v->main->vtbl->remove(v->main);
		free(v);
		return 0;
a287 1
	((struct transport *)v->encap)->virtual = (struct transport *)v;
d524 13
a536 8
	stport = udp_encap_default_port ? udp_encap_default_port :
	    UDP_ENCAP_DEFAULT_PORT_STR;
	port = text2port(stport);
	if (port == 0) {
		log_print("virtual_clone: port string \"%s\" not convertible "
		    "to in_port_t", stport);
		free(t);
		return 0;
a537 3
	sockaddr_set_port(raddr, port);
	v2->encap = v->encap->vtbl->clone(v->encap, raddr);
	v2->encap->virtual = (struct transport *)v2;
d552 1
a552 1
	struct transport	 *t, *t2;
d559 6
a564 4
	t2 = transport_create("udp_encap", name);
	if (!t2) {
		t->vtbl->remove(t);
		return 0;
a565 2
#else
	t2 = 0;
@


1.13
log
@No need for err.h. hshoexer@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.12 2005/03/04 16:55:15 hshoexer Exp $	*/
a138 2

	return;
a601 1
	return;
@


1.12
log
@cleanup binding and cloning functions, use text2port(), correctly
determin the encap port.  This makes udpencap fully useable on ports
other than the default 4500.

ok ho cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.11 2005/02/27 13:12:12 hshoexer Exp $	*/
a36 1
#include <err.h>
@


1.11
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.10 2004/12/14 10:17:28 mcbride Exp $	*/
d233 2
a234 3
	char	*port;
	char	*ep;
	long	 lport;
d247 5
a251 9
	/*
	 * Get port.
	 * XXX Use getservbyname too.
	 */
	port = udp_default_port ? udp_default_port : UDP_DEFAULT_PORT_STR;
	lport = strtol(port, &ep, 10);
	if (*ep != '\0' || lport < 0 || lport > (long)USHRT_MAX) {
		log_print("virtual_bind: "
		    "port string \"%s\" not convertible to in_port_t", port);
d256 1
a256 1
	sockaddr_set_port((struct sockaddr *)&tmp_sa, (in_port_t)lport);
d267 2
a268 5
	/*
	 * Get port.
	 * XXX Use getservbyname too.
	 */
	port = udp_encap_default_port
d270 3
a272 4
	lport = strtol(port, &ep, 10);
	if (*ep != '\0' || lport < 0 || lport > (long)USHRT_MAX) {
		log_print("virtual_bind: "
		    "port string \"%s\" not convertible to in_port_t", port);
d278 1
a278 1
	sockaddr_set_port((struct sockaddr *)&tmp_sa, (in_port_t)lport);
d499 2
d522 10
a531 3
	/* XXX fix strtol() call */
	sockaddr_set_port(raddr, udp_encap_default_port ?
	    strtol(udp_encap_default_port, NULL, 10) : UDP_ENCAP_DEFAULT_PORT);
d649 1
a649 1
	in_port_t port;
d669 6
a674 1
		if (port != UDP_DEFAULT_PORT) {
@


1.10
log
@Allow the Address, Network, or Netmask values of the <IPsec-ID> to be
specified with an interface name (in which case the first address is used)
or the keyword 'default' (in which case the address is selected based on the
default route). eg:

[roadwarrior-ip]
ID-type=                IPV4_ADDR
Address=                default

ok ho@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.9 2004/09/20 21:36:50 hshoexer Exp $	*/
d313 1
a313 1
	memset(&dflt_stor, 0, sizeof dflt_stor);
@


1.9
log
@compile cleanly with -Wsign-compare
ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.8 2004/08/10 19:21:01 deraadt Exp $	*/
d460 1
a460 1
			if (text2sockaddr(address->field, 0, &addr)) {
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.7 2004/08/08 19:11:06 deraadt Exp $	*/
d254 1
a254 1
	if (*ep != '\0' || lport < 0 || lport > USHRT_MAX) {
d279 1
a279 1
	if (*ep != '\0' || lport < 0 || lport > USHRT_MAX) {
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.6 2004/08/03 10:54:09 ho Exp $	*/
d204 1
a204 1
	     v = LIST_NEXT(v, link)) {
d459 1
a459 1
		     address = TAILQ_NEXT(address, link)) {
@


1.6
log
@Rewrite the transport reference count code to avoid leaks.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.5 2004/07/08 19:53:46 hshoexer Exp $	*/
d357 1
a357 1
	LOG_DBG((LOG_TRANSPORT, 90, 
d360 1
a360 1
	    if_addr->sa_family == AF_INET ? "v4" : 
d526 1
a526 1
		v2->main->virtual = (struct transport *)v2;	
d543 1
a543 1
  
d616 1
a616 1
      
d650 1
a650 1
	
@


1.5
log
@free() and close() in error path.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.4 2004/06/22 03:44:55 ho Exp $	*/
d129 1
d138 1
d140 2
d201 1
a201 1
	struct udp_transport	*u;
d205 8
a212 1
		u = (struct udp_transport *)v->main;
d221 1
d282 1
a282 1
		transport_release(v->main);
d290 1
a290 1
		transport_release(v->main);
a298 1
	transport_reference(&v->transport);
d498 1
d518 3
a540 7

	transport_reference(t);
	if (v2->main)
		transport_reference(v2->main);
	if (v2->encap)
		transport_reference(v2->encap);

a582 2
	LIST_INSERT_HEAD(&virtual_listen_list, v, link);

d598 1
d648 1
a648 1
	struct sockaddr *sa;
d667 2
a668 2
		v->main->vtbl->get_dst(v->main, &sa);
		port = ntohs(sockaddr_port(sa));
d670 2
a671 2
			v->main->vtbl->get_dst(v->encap, &sa);
			sockaddr_set_port(sa, port);
@


1.4
log
@The NAT-T drafts suggest we should drop incoming messages arriving on
the old port (500) after we've switched to the new one.
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.3 2004/06/21 18:40:01 ho Exp $	*/
d245 1
d251 2
a252 1
	if (!v->main)
d254 1
d270 2
d277 3
a279 1
	if (!v->encap)
d281 1
d418 1
@


1.3
log
@When switching from main to encap transport, copy dst port if
translated (NAT).
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.2 2004/06/21 13:09:01 ho Exp $	*/
d606 14
@


1.2
log
@Port floating (500->4500) for p1 and p2 exchanges.
@
text
@d1 1
a1 1
/*	$OpenBSD: virtual.c,v 1.1 2004/06/20 15:24:05 ho Exp $	*/
a616 6

	/* XXX Debug */
	if (t)
		log_print("virtual_send_message: called with "
		    "transport %p != NULL", t);

d618 3
d635 8
d644 1
a644 1
#endif
@


1.1
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.65 2003/09/26 11:29:11 cedric Exp $	*/
a62 2
static int		 virtual_fd_set(struct transport *, fd_set *, int);
static int		 virtual_fd_isset(struct transport *, fd_set *);
d81 2
a82 2
	virtual_fd_set,
	virtual_fd_isset,
d250 2
d272 2
d498 3
a500 5
	if (v->encap_is_active) {
		v2->main = 0;
		v2->encap = v->encap->vtbl->clone(v->encap, raddr);
		v2->encap->virtual = (struct transport *)v2;
	} else {
a502 1
		v2->encap = 0;
d504 9
a512 2
	LOG_DBG((LOG_TRANSPORT, 50, "virtual_clone: old %p new %p (->%s %p)",
	    v, t, v->encap_is_active ? "encap" : "main", 
d519 5
a523 2
	transport_reference(v->encap_is_active ? v2->encap : v2->main);
	
d595 2
a596 3
	struct virtual_transport *v = (struct virtual_transport *)t;

	if (t == default_transport || t == default_transport6) {
d609 1
a609 4
	if (v->encap_is_active)
		v->encap->vtbl->handle_message(v->encap);
	else
		v->main->vtbl->handle_message(v->main);
d624 7
d632 3
a634 1
	    (msg->exchange->flags & EXCHANGE_FLAG_NAT_T_ENABLE)) {
d636 1
a636 1
		    "switching to ENCAP"));
a644 33
}

static int
virtual_fd_set(struct transport *t, fd_set *fds, int bit)
{
	struct virtual_transport	*v = (struct virtual_transport *)t;
	struct udp_transport		*u;

	if (v->encap_is_active)
		u = (struct udp_transport *)v->encap;
	else
		u = (struct udp_transport *)v->main;

	if (bit)
		FD_SET(u->s, fds);
	else
		FD_CLR(u->s, fds);

	return u->s + 1;
}

static int
virtual_fd_isset(struct transport *t, fd_set *fds)
{
	struct virtual_transport	*v = (struct virtual_transport *)t;
	struct udp_transport		*u;

	if (v->encap_is_active)
		u = (struct udp_transport *)v->encap;
	else
		u = (struct udp_transport *)v->main;

	return FD_ISSET(u->s, fds);
@

