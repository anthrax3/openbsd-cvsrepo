head	1.25;
access;
symbols
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2001.07.06.09.35.57;	author ho;	state dead;
branches;
next	1.24;

1.24
date	2001.06.29.19.08.11;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.29.04.12.00;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.27.03.31.42;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.09.22.09.52;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.27.12.03.34;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.12.01.46.29;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.08.20.49.19;	author niklas;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.02.25.17.23.41;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.05.02.19.16.12;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.05.01.22.57.38;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.05.01.20.43.43;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.04.19.21.07.42;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.04.05.21.02.48;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.03.31.14.27.38;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.03.31.00.51.50;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.03.24.14.41.41;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.03.02.15.48.23;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.02.27.09.59.36;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.02.26.03.48.32;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.12.21.01.02.26;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.18;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2001.05.08.12.45.24;	author ho;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove support for PF_ENCAP (deprecated since OpenBSD2.5).
@
text
@/*	$OpenBSD: pf_encap.c,v 1.24 2001/06/29 19:08:11 ho Exp $	*/
/*	$EOM: pf_encap.c,v 1.73 2000/12/04 04:46:34 angelos Exp $	*/

/*
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <net/route.h>
#include <netinet/in.h>
#include <net/encap.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/ip_ip4.h>
#include <netinet/ip_ipsp.h>
#include <arpa/inet.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sysdep.h"

#include "conf.h"
#include "exchange.h"
#include "hash.h"
#include "ipsec.h"
#include "ipsec_num.h"
#include "isakmp.h"
#include "log.h"
#include "pf_encap.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"

#define ROUNDUP(a) \
  ((a) > 0 ? (1 + (((a) - 1) | (sizeof (long) - 1))) : sizeof (long))

static void pf_encap_deregister_on_demand_connection (char *);
static int pf_encap_register_on_demand_connection (in_addr_t, char *);
static void pf_encap_request_sa (struct encap_msghdr *);

struct on_demand_connection {
  /* Connections are linked together.  */
  LIST_ENTRY (on_demand_connection) link;

  /* The security gateway's IP-address.  */
  in_addr_t dst;

  /* The name of a phase 2 connection associated with the security gateway.  */
  char *conn;
};

static LIST_HEAD (on_demand_connection_list_list, on_demand_connection)
  on_demand_connections;

static int pf_encap_socket;

void
pf_encap_init ()
{
  LIST_INIT (&on_demand_connections);
}

int
pf_encap_open ()
{
  int fd;

  fd = socket (PF_ENCAP, SOCK_RAW, PF_UNSPEC);
  if (fd == -1)
    {
      log_error ("pf_encap_open: "
		 "socket (PF_ENCAP, SOCK_RAW, PF_UNSPEC) failed");
      return -1;
    }
  pf_encap_socket = fd;
  return fd;
}

static void
pf_encap_expire (struct encap_msghdr *emsg)
{
  struct sa *sa;

  LOG_DBG ((LOG_SYSDEP, 20,
	    "pf_encap_expire: NOTIFY_%s_EXPIRE dst %s spi %x sproto %d",
	    emsg->em_not_type == NOTIFY_SOFT_EXPIRE ? "SOFT" : "HARD",
	    inet_ntoa (emsg->em_not_dst), htonl (emsg->em_not_spi),
	    emsg->em_not_sproto));

  /*
   * Find the IPsec SA.  The IPsec stack has two SAs for every IKE SA,
   * one outgoing and one incoming, we regard expirations for any of
   * them as an expiration of the full IKE SA.  Likewise, in
   * protection suites consisting of more than one protocol, any
   * expired individual IPsec stack SA will be seen as an expiration
   * of the full suite.
   *
   * XXX When anything else than AH and ESP is supported this needs to change.
   */
  sa = ipsec_sa_lookup (emsg->em_not_dst.s_addr, emsg->em_not_spi,
			emsg->em_not_sproto == IPPROTO_ESP
			? IPSEC_PROTO_IPSEC_ESP : IPSEC_PROTO_IPSEC_AH);

  /* If the SA is already gone, don't do anything.  */
  if (!sa)
    return;

  /*
   * If we want this connection to stay "forever", we should renegotiate
   * already at the soft expire, and certainly at the hard expire if we
   * haven't started a negotiation by then.
   */
  if ((sa->flags & (SA_FLAG_STAYALIVE | SA_FLAG_REPLACED))
      == SA_FLAG_STAYALIVE)
    exchange_establish (sa->name, 0, 0);

  if (emsg->em_not_type == NOTIFY_HARD_EXPIRE)
    {
      /*
       * XXX This should not be necessary anymore due to the 
       *     connection abstraction.
       */
#if 0
      /*
       * If the expired SA is something we know how to renegotiate, and it
       * has not already been replaced.  Establish routes that requests SAs
       * from us on use.
       */
      if (sa->name && (sa->flags & SA_FLAG_REPLACED) == 0)
	/*
	 * We reestablish the on-demand route here even if we have started
	 * a new negotiation, considering it might fail.
	 */
	pf_encap_connection_check (sa->name);
#endif

      /* Remove the old SA, it isn't useful anymore.  */
      sa_free (sa);
    }
}

static void
pf_encap_notify (struct encap_msghdr *emsg)
{
  LOG_DBG_BUF ((LOG_SYSDEP, 90, "pf_encap_notify: emsg", (u_int8_t *)emsg,
		emsg->em_msglen));

  switch (emsg->em_not_type)
    {
    case NOTIFY_SOFT_EXPIRE:
    case NOTIFY_HARD_EXPIRE:
      pf_encap_expire (emsg);
      break;

    case NOTIFY_REQUEST_SA:
      pf_encap_request_sa (emsg);
      break;

    default:
      log_print ("pf_encap_notify: unknown notify message type (%d)",
		 emsg->em_not_type);
      break;
    }
  free (emsg);
}

void
pf_encap_handler (int fd)
{
  u_int8_t *buf;
  struct encap_msghdr *emsg;
  ssize_t len;
  int n;

  /*
   * As synchronous read/writes to the socket can have taken place between
   * the select(2) call of the main loop and this handler, we need to recheck
   * the readability.
   */
  if (ioctl (pf_encap_socket, FIONREAD, &n) == -1)
    {
      log_error ("pf_encap_handler: ioctl (%d, FIONREAD, &n) failed",
		 pf_encap_socket);
      return;
    }
  if (!n)
    return;

  /*
   * PF_ENCAP version 1 has a max length equal to the notify length on
   * upcoming packets.
   */
  buf = malloc (EMT_NOTIFY_FLEN);
  if (!buf)
    {
      log_error ("pf_encap_handler: malloc (%d) failed", EMT_NOTIFY_FLEN);
      return;
    }
  emsg = (struct encap_msghdr *)buf;

  len = read (fd, buf, EMT_NOTIFY_FLEN);
  if (len == -1)
    {
      log_error ("pf_encap_handler: read (%d, ...) failed", fd);
      free (emsg);
      return;
    }

  if (emsg->em_version != PFENCAP_VERSION_1)
    {
      log_print ("pf_encap_handler: "
		 "unexpected message version (%d) from PF_ENCAP socket",
		 emsg->em_version);
      free (emsg);
      return;
    }

  if (emsg->em_type != EMT_NOTIFY)
    {
      log_print ("pf_encap_handler: "
		 "unexpected message type (%d) from PF_ENCAP socket",
		 emsg->em_type);
      free (emsg);
      return;
    }

  pf_encap_notify (emsg);
}

/* Write a PF_ENCAP request down to the kernel.  */
static int
pf_encap_write (struct encap_msghdr *em)
{
  ssize_t n;

  em->em_version = PFENCAP_VERSION_1;

  LOG_DBG_BUF ((LOG_SYSDEP, 30, "pf_encap_write: em", (u_int8_t *)em,
		em->em_msglen));
  n = write (pf_encap_socket, em, em->em_msglen);
  if (n == -1)
    {
      log_error ("pf_encap_write: write (%d, ...) failed", pf_encap_socket);
      return -1;
    }
  if ((size_t)n != em->em_msglen)
    {
      log_error ("pf_encap_write: write (%d, ...) returned prematurely",
		 pf_encap_socket);
      return -1;
    }
  return 0;
}

/*
 * We are asked to setup an SA that can protect packets like the one described
 * in EMSG.  We are supposed to deallocate EMSG too.
 */
static void
pf_encap_request_sa (struct encap_msghdr *emsg)
{
  struct on_demand_connection *node;

  LOG_DBG ((LOG_SYSDEP, 10,
	    "pf_encap_request_sa: SA requested for %s type %d",
	    inet_ntoa (emsg->em_not_dst), emsg->em_not_satype));

  /*
   * In my mind this is rediculous, PF_ENCAP is just broken.  Well, to
   * describe how it is broken it suffices to say that REQUEST_SA messages
   * does not tell which of all connections using a specific security
   * gateway needs to be brought up.  So we have to bring them all up.
   * I won't bother replying to the PF_ENCAP socket because the kernel
   * does not require it when this request is due to a SPI 1 route.
   */  
  for (node = LIST_FIRST (&on_demand_connections); node;
       node = LIST_NEXT (node, link))
    if (emsg->em_not_dst.s_addr == node->dst
	&& !sa_lookup_by_name (node->conn, 2))
      exchange_establish (node->conn, 0, 0);
}

/*
 * Read a PF_ENCAP non-notify packet (e.g. an answer to a request of ours)
 * If we see a notify queue it up as a timeout timing out now for the main
 * loop to see.
 */
static struct encap_msghdr *
pf_encap_read ()
{
  u_int8_t *buf;
  ssize_t n;
  struct encap_msghdr *emsg;
  struct timeval now;

  /*
   * PF_ENCAP version 1 has a max length equal to the notify length on
   * upcoming packets.
   */
  buf = malloc (EMT_NOTIFY_FLEN);
  if (!buf)
    goto cleanup;
  emsg = (struct encap_msghdr *)buf;

  while (1)
    {
      n = read (pf_encap_socket, buf, EMT_NOTIFY_FLEN);
      if (n == -1)
	{
	  log_error ("read (%d, ...) failed", pf_encap_socket);
	  goto cleanup;
	}

      if ((size_t)n < EMT_GENLEN || (size_t)n != emsg->em_msglen)
	{
	  log_print ("read (%d, ...) returned short packet (%d bytes)",
		     pf_encap_socket, n);
	  goto cleanup;
	}

      /* We drop all messages that is not what we expect.  */
      if (emsg->em_version != PFENCAP_VERSION_1)
	continue;

      /*
       * Enqueue notifications so they will be dealt with as soon as we get
       * back to the main server loop.
       */
      if (emsg->em_type == EMT_NOTIFY)
	{
	  gettimeofday (&now, 0);
	  timer_add_event ("pf_encap_notify",
			   (void (*) (void *))pf_encap_notify, emsg, &now);

	  /* We need a new buffer since we gave our former one away.  */
	  buf = malloc (EMT_NOTIFY_FLEN);
	  if (!buf)
	    goto cleanup;
	  emsg = (struct encap_msghdr *)buf;
	  continue;
	}

      return emsg;
    }

 cleanup:
  if (buf)
    free (buf);
  return 0;
}

/*
 * Generate a SPI for protocol PROTO and the source/destination pair given by
 * SRC, SRCLEN, DST & DSTLEN.  Stash the SPI size in SZ.
 */
u_int8_t *
pf_encap_get_spi (size_t *sz, u_int8_t proto, struct sockaddr *src,
		  struct sockaddr *dst)
{
  struct encap_msghdr *emsg = 0;
  u_int8_t *spi = 0;
  struct sockaddr_in *ipv4_dst = (struct sockaddr_in *)dst;

  emsg = calloc (1, EMT_RESERVESPI_FLEN);
  if (!emsg)
    return 0;

  emsg->em_msglen = EMT_RESERVESPI_FLEN;
  emsg->em_type = EMT_RESERVESPI;
  emsg->em_gen_spi = 0;
  memcpy (&emsg->em_gen_dst, &ipv4_dst->sin_addr, sizeof ipv4_dst->sin_addr);
  emsg->em_gen_sproto =
    proto == IPSEC_PROTO_IPSEC_ESP ? IPPROTO_ESP : IPPROTO_AH;

  if (pf_encap_write (emsg))
    goto cleanup;
  free (emsg);
  emsg = pf_encap_read ();
  if (!emsg)
    goto cleanup;

  *sz = sizeof emsg->em_gen_spi;
  spi = malloc (*sz);
  if (!spi)
    goto cleanup;
  memcpy (spi, &emsg->em_gen_spi, *sz);
  free (emsg);

  LOG_DBG_BUF ((LOG_SYSDEP, 50, "pf_encap_get_spi: spi", spi, *sz));

  return spi;

 cleanup:
  if (emsg)
    free (emsg);
  if (spi)
    free (spi);
  return 0;
}

/* Group 2 SPIs in a chain.  */
int
pf_encap_group_spis (struct sa *sa, struct proto *proto1, struct proto *proto2,
		     int incoming)
{
  struct encap_msghdr *emsg = 0;
  struct sockaddr *dst;

  emsg = calloc (1, EMT_GRPSPIS_FLEN);
  if (!emsg)
    return -1;

  emsg->em_msglen = EMT_GRPSPIS_FLEN;
  emsg->em_type = EMT_GRPSPIS;

  memcpy (&emsg->em_rel_spi, proto1->spi[incoming], sizeof emsg->em_rel_spi);
  memcpy (&emsg->em_rel_spi2, proto2->spi[incoming],
	  sizeof emsg->em_rel_spi2);
  if (incoming)
    sa->transport->vtbl->get_src (sa->transport, &dst);
  else
    sa->transport->vtbl->get_dst (sa->transport, &dst);
  emsg->em_rel_dst = emsg->em_rel_dst2 = ((struct sockaddr_in *)dst)->sin_addr;
  /* XXX What if IPCOMP etc. comes along?  */
  emsg->em_rel_sproto
    = proto1->proto == IPSEC_PROTO_IPSEC_ESP ? IPPROTO_ESP : IPPROTO_AH;
  emsg->em_rel_sproto2
    = proto2->proto == IPSEC_PROTO_IPSEC_ESP ? IPPROTO_ESP : IPPROTO_AH;

  if (pf_encap_write (emsg))
    goto cleanup;
  free (emsg);

  LOG_DBG ((LOG_SYSDEP, 50, "pf_encap_group_spis: done"));

  return 0;

 cleanup:
  if (emsg)
    free (emsg);
  return -1;
}

/*
 * Store/update a PF_KEY_V2 security association with full information from the
 * IKE SA and PROTO into the kernel.  INCOMING is set if we are setting the
 * parameters for the incoming SA, and cleared otherwise.
 */
int
pf_encap_set_spi (struct sa *sa, struct proto *proto, int incoming)
{
  struct encap_msghdr *emsg = 0;
  struct ipsec_proto *iproto = proto->data;
  struct sockaddr *dst, *src;
  int keylen, hashlen;
  size_t len;
  struct esp_new_xencap *edx;
  struct ah_new_xencap *amx;

  switch (proto->proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      keylen = ipsec_esp_enckeylength (proto);
      hashlen = ipsec_esp_authkeylength (proto);
      len = EMT_SETSPI_FLEN + ESP_NEW_XENCAP_LEN + keylen + hashlen + 8;
      emsg = calloc (1, len);
      if (!emsg)
	return -1;

      /* Whenever should the "old" transforms be used?  Policy thing?  */
      emsg->em_alg = XF_NEW_ESP;
      emsg->em_sproto = IPPROTO_ESP;

      edx = (struct esp_new_xencap *)emsg->em_dat;

      switch (proto->id)
	{
	case IPSEC_ESP_DES:
	case IPSEC_ESP_DES_IV32:
	case IPSEC_ESP_DES_IV64:
	  edx->edx_enc_algorithm = ALG_ENC_DES;
	  break;

	case IPSEC_ESP_3DES:
	  edx->edx_enc_algorithm = ALG_ENC_3DES;
	  break;

	case IPSEC_ESP_CAST:
	  edx->edx_enc_algorithm = ALG_ENC_CAST;
	  break;

	case IPSEC_ESP_BLOWFISH:
	  edx->edx_enc_algorithm = ALG_ENC_BLF;
	  break;

	default:
	  /* XXX Log?  */
	  return -1;
	}

      switch (iproto->auth)
	{
	case IPSEC_AUTH_HMAC_MD5:
	  edx->edx_hash_algorithm = ALG_AUTH_MD5;
	  break;

	case IPSEC_AUTH_HMAC_SHA:
	  edx->edx_hash_algorithm = ALG_AUTH_SHA1;
	  break;

	case IPSEC_AUTH_DES_MAC:
	case IPSEC_AUTH_KPDK:
	  /* XXX Log?  */
	  return -1;

	default:
	  edx->edx_hash_algorithm = 0;
	}

      /* XXX What if we have a protocol requiring IV?  */
      edx->edx_ivlen = 8;
      edx->edx_confkeylen = keylen;
      edx->edx_authkeylen = hashlen;
      edx->edx_wnd
	= conf_get_str ("General", "Shared-SADB") ? -1 : iproto->replay_window;
      edx->edx_flags = iproto->auth ? ESP_NEW_FLAG_AUTH : 0;
      memcpy (edx->edx_data + 8, iproto->keymat[incoming], keylen);
      if (iproto->auth)
	memcpy (edx->edx_data + keylen + 8, iproto->keymat[incoming] + keylen,
		hashlen);
      break;

    case IPSEC_PROTO_IPSEC_AH:
      hashlen = ipsec_ah_keylength (proto);
      len = EMT_SETSPI_FLEN + AH_NEW_XENCAP_LEN + hashlen;
      emsg = calloc (1, len);
      if (!emsg)
	return -1;

      /* Whenever should the "old" transforms be used?  Policy thing?  */
      emsg->em_alg = XF_NEW_AH;
      emsg->em_sproto = IPPROTO_AH;

      amx = (struct ah_new_xencap *)emsg->em_dat;

      switch (proto->id)
	{
	case IPSEC_AH_MD5:
	  amx->amx_hash_algorithm = ALG_AUTH_MD5;
	  break;

	case IPSEC_AH_SHA:
	  amx->amx_hash_algorithm = ALG_AUTH_SHA1;
	  break;

	default:
	  /* XXX Log?  */
	  goto cleanup;
	}

      amx->amx_keylen = hashlen;
      amx->amx_wnd
	= conf_get_str ("General", "Shared-SADB") ? -1 : iproto->replay_window;
      memcpy (amx->amx_key, iproto->keymat[incoming], hashlen);
      break;

    default:
      /* XXX Log?  */
      goto cleanup;
    }

  emsg->em_msglen = len;
  emsg->em_type = EMT_SETSPI;
  memcpy (&emsg->em_spi, proto->spi[incoming], sizeof emsg->em_spi);
  emsg->em_ttl = IP4_DEFAULT_TTL;
  /* Fill in a well-defined value in this reserved field.  */
  emsg->em_satype = 0;

  sa->transport->vtbl->get_dst (sa->transport, &dst);
  sa->transport->vtbl->get_src (sa->transport, &src);
  emsg->em_dst
    = ((struct sockaddr_in *)(incoming ? src : dst))->sin_addr;
  emsg->em_src
    = ((struct sockaddr_in *)(incoming ? dst : src))->sin_addr;
  if (iproto->encap_mode == IPSEC_ENCAP_TUNNEL)
    {
      emsg->em_odst = emsg->em_dst;
      emsg->em_osrc = emsg->em_src;
    }

  /* XXX I am not sure which one is best in security respect.  */
#if 0
  emsg->em_first_use_hard = (u_int64_t)sa->seconds;
  /* XXX Perhaps we could calculate something out of the last negotiation.  */
  emsg->em_first_use_soft = (u_int64_t)sa->seconds * 9 / 10;
  emsg->em_expire_hard = 0;
  emsg->em_expire_soft = 0;
#else
  emsg->em_expire_hard
    = sa->seconds ? time ((time_t *)0) + (u_int64_t)sa->seconds : 0;
  /* XXX Perhaps we could calculate something out of the last negotiation.  */
  emsg->em_expire_soft
    = sa->seconds ? time ((time_t *)0) + (u_int64_t)sa->seconds * 9 / 10 : 0;
  emsg->em_first_use_hard = 0;
  emsg->em_first_use_soft = 0;
#endif
  emsg->em_bytes_hard = (u_int64_t)sa->kilobytes * 1024;
  /* XXX A configurable ratio would be better.  */
  emsg->em_bytes_soft = (u_int64_t)sa->kilobytes * 1024 * 9 / 10;
  emsg->em_packets_hard = 0;
  emsg->em_packets_soft = 0;

  LOG_DBG ((LOG_SYSDEP, 10, "pf_encap_set_spi: proto %d dst %s SPI 0x%x",
	    emsg->em_sproto, inet_ntoa (emsg->em_dst),
	    htonl (emsg->em_spi)));
  if (pf_encap_write (emsg))
    goto cleanup;
  free (emsg);

  LOG_DBG ((LOG_SYSDEP, 50, "pf_encap_set_spi: done"));

  return 0;

 cleanup:
  if (emsg)
    free (emsg);
  return -1;
}
 
/*
 * Delete the IPsec SA represented by the INCOMING direction in protocol PROTO
 * of the IKE security association SA.
 */
int
pf_encap_delete_spi (struct sa *sa, struct proto *proto, int incoming)
{
  struct encap_msghdr *emsg = 0;
  struct sockaddr *dst;

  emsg = calloc (1, EMT_DELSPI_FLEN);
  if (!emsg)
    return -1;

  emsg->em_msglen = EMT_DELSPI_FLEN;
  emsg->em_type = EMT_DELSPI;

  memcpy (&emsg->em_gen_spi, proto->spi[incoming], sizeof emsg->em_gen_spi);
  if (incoming)
    sa->transport->vtbl->get_src (sa->transport, &dst);
  else
    sa->transport->vtbl->get_dst (sa->transport, &dst);
  emsg->em_gen_dst = ((struct sockaddr_in *)dst)->sin_addr;
  /* XXX What if IPCOMP etc. comes along?  */
  emsg->em_gen_sproto
    = proto->proto == IPSEC_PROTO_IPSEC_ESP ? IPPROTO_ESP : IPPROTO_AH;

  if (pf_encap_write (emsg))
    goto cleanup;
  free (emsg);

  LOG_DBG ((LOG_SYSDEP, 50, "pf_encap_delete_spi: done"));

  return 0;

 cleanup:
  if (emsg)
    free (emsg);
  return -1;
}

/* Enable a flow given an SA.  */
int
pf_encap_enable_sa (struct sa *sa, struct sa *isakmp_sa)
{
  struct ipsec_sa *isa = sa->data;
  struct sockaddr *dst;
  struct proto *proto = TAILQ_FIRST (&sa->protos);

  sa->transport->vtbl->get_dst (sa->transport, &dst);

  return pf_encap_enable_spi (isa->src_net, isa->src_mask, isa->dst_net,
			      isa->dst_mask, proto->spi[0], proto->proto,
			      ((struct sockaddr_in *)dst)->sin_addr.s_addr);
}

/* Enable a flow.  */
int
pf_encap_enable_spi (struct sockaddr *laddr, struct sockaddr *lmask,
		     struct sockaddr *raddr, struct sockaddr *rmask,
		     u_int8_t *spi, u_int8_t proto, in_addr_t dst)
{
  struct encap_msghdr *emsg = 0;
#ifdef USE_DEBUG
  char *la_str, *lm_str, *ra_str, *rm_str;
#endif

  emsg = calloc (1, EMT_ENABLESPI_FLEN);
  if (!emsg)
    /* XXX Log?  */
    return -1;

  emsg->em_msglen = EMT_ENABLESPI_FLEN;
  emsg->em_type = EMT_ENABLESPI;

  memcpy (&emsg->em_ena_spi, spi, sizeof emsg->em_ena_spi);
  emsg->em_ena_dst.s_addr = dst;

#ifdef USE_DEBUG
  if (sockaddr2text (laddr, &la_str))
    la_str = 0;
  if (sockaddr2text (lmask, &lm_str))
    lm_str = 0;
  if (sockaddr2text (raddr, &ra_str))
    ra_str = 0;
  if (sockaddr2text (rmask, &rm_str))
    rm_str = 0;
  
  LOG_DBG ((LOG_SYSDEP, 50, "pf_encap_enable_spi: src %x %x dst %x %x",
	    la_str ? la_str : "<???>", lm_str : lm_str ? "<???>",
	    ra_str ? ra_str : "<???>", rm_str : rm_str ? "<???>"));
  
  if (la_str)
    free (la_str);
  if (lm_str)
    free (lm_str);
  if (ra_str)
    free (ra_str);
  if (rm_str)
    free (rm_str);
#endif /* USE_DEBUG */

  emsg->em_ena_isrc.s_addr = ((struct sockaddr_in *)laddr)->sin_addr.s_addr;
  emsg->em_ena_ismask.s_addr = ((struct sockaddr_in *)lmask)->sin_addr.s_addr;
  emsg->em_ena_idst.s_addr = ((struct sockaddr_in *)raddr)->sin_addr.s_addr;
  emsg->em_ena_idmask.s_addr = ((struct sockaddr_in *)rmask)->sin_addr.s_addr;
  emsg->em_ena_flags = ENABLE_FLAG_REPLACE;

  /* XXX What if IPCOMP etc. comes along?  */
  emsg->em_ena_sproto
    = proto == IPSEC_PROTO_IPSEC_ESP ? IPPROTO_ESP : IPPROTO_AH;

  if (pf_encap_write (emsg))
    goto cleanup;

  /*
   * XXX The condition should be true if this machine is part of the source
   * subnet.
   */
  if (1)
    {
      /*
       * This "route" is used for packets from this host where the source
       * address has not yet been decided.
       */
      emsg->em_ena_flags |= ENABLE_FLAG_LOCAL;
      if (pf_encap_write (emsg))
	goto cleanup;
    }
  free (emsg);
  LOG_DBG ((LOG_SYSDEP, 50, "pf_encap_enable_spi: done"));
  return 0;

 cleanup:
  if (emsg)
    free (emsg);
  return -1;
}

/*
 * Establish an encap route.
 * XXX We should add delete support here a la ipsecadm/xf_flow.c the day
 * we want to clean up after us.
 */
static int
pf_encap_route (in_addr_t laddr, in_addr_t lmask, in_addr_t raddr,
		in_addr_t rmask, in_addr_t dst)
{
  int s = -1;
  int off;
  struct sockaddr_encap *ddst, *msk, *gw;
  struct rt_msghdr *rtmsg = 0;

  rtmsg = calloc (1,
		  sizeof *rtmsg + 2 * ROUNDUP (SENT_IP4_LEN)
		  + ROUNDUP (SENT_IPSP_LEN));
  if (!rtmsg)
    {
      log_error ("pf_encap_route: calloc (1, %d) failed",
		 sizeof *rtmsg + 2 * ROUNDUP (SENT_IP4_LEN)
		 + ROUNDUP (SENT_IPSP_LEN));
      goto fail;
    }

  s = socket (PF_ROUTE, SOCK_RAW, AF_UNSPEC);
  if (s == -1)
    {
      log_error ("pf_encap_route: "
		 "socket(PF_ROUTE, SOCK_RAW, AF_UNSPEC) failed");
      goto fail;
    }

  off = sizeof *rtmsg;
  ddst = (struct sockaddr_encap *)((char *)rtmsg + off);
  off = ROUNDUP (off + SENT_IP4_LEN);
  gw = (struct sockaddr_encap *)((char *)rtmsg + off);
  off = ROUNDUP (off + SENT_IPSP_LEN);
  msk = (struct sockaddr_encap *)((char *)rtmsg + off);
  bzero (rtmsg, off + SENT_IP4_LEN);
	
  rtmsg->rtm_version = RTM_VERSION;
  rtmsg->rtm_type = RTM_ADD;
  rtmsg->rtm_index = 0;
  rtmsg->rtm_pid = getpid ();
  rtmsg->rtm_addrs = RTA_DST | RTA_GATEWAY | RTA_NETMASK;
  rtmsg->rtm_errno = 0;
  rtmsg->rtm_flags = RTF_UP | RTF_GATEWAY | RTF_STATIC;
  rtmsg->rtm_inits = 0;
	
  ddst->sen_len = SENT_IP4_LEN;
  ddst->sen_family = AF_ENCAP;
  ddst->sen_type = SENT_IP4;
  ddst->sen_ip_src.s_addr = laddr & lmask;
  ddst->sen_ip_dst.s_addr = raddr & rmask;
  ddst->sen_proto = ddst->sen_sport = ddst->sen_dport = 0;

  gw->sen_len = SENT_IPSP_LEN;
  gw->sen_family = AF_ENCAP;
  gw->sen_type = SENT_IPSP;
  gw->sen_ipsp_dst.s_addr = dst;
  gw->sen_ipsp_spi = htonl(1);
  gw->sen_ipsp_sproto = 0;	/* XXX Correct?  */

  msk->sen_len = SENT_IP4_LEN;
  msk->sen_family = AF_ENCAP;
  msk->sen_type = SENT_IP4;
  msk->sen_ip_src.s_addr = lmask;
  msk->sen_ip_dst.s_addr = rmask;

  rtmsg->rtm_msglen = off + msk->sen_len;

  LOG_DBG ((LOG_SYSDEP, 70, "pf_encap_route: rtmsg", rtmsg,
	    rtmsg->rtm_msglen));
  if (write (s, (caddr_t)rtmsg, rtmsg->rtm_msglen) == -1)
    {
      if (errno == EEXIST)
	{
	  rtmsg->rtm_type = RTM_CHANGE;

	  LOG_DBG ((LOG_SYSDEP, 70, "pf_encap_route: rtmsg", rtmsg,
		    rtmsg->rtm_msglen));
	  if (write (s, (caddr_t)rtmsg, rtmsg->rtm_msglen) == -1)
	    {
	      log_error ("pf_encap_route: write(%d, %p, %d) failed", s, rtmsg,
			 rtmsg->rtm_msglen);
	      goto fail;
	    }
	}
      else
	{
	  log_error ("pf_encap_route: write(%d, %p, %d) failed", s, rtmsg,
		     rtmsg->rtm_msglen);
	  goto fail;
	}
    }

  /* XXX Local packet route should be setup here.  */

  /*
   * Setup a reverse map, address -> name, we can use when getting SA
   * requests back from the stack.
   */

  close (s);
  free (rtmsg);

  LOG_DBG ((LOG_SYSDEP, 30, "pf_encap_route: done"));
  return 0;

 fail:
  if (s != -1)
    close (s);
  if (rtmsg)
    free (rtmsg);
  return -1;
}

/* Check that the CONN connection has SPI 1 routes in-place.  */
void
pf_encap_connection_check (char *conn)
{
  char *conf, *doi_str, *local_id, *remote_id, *peer, *address;
  struct sockaddr *laddr, *lmask, *raddr, *rmask;
  struct in_addr gwaddr;
  int lid, rid, err;
  u_int8_t tproto;
  u_int16_t sport, dport;

  if (sa_lookup_by_name (conn, 2) || exchange_lookup_by_name (conn, 2))
    {
      LOG_DBG ((LOG_SYSDEP, 70,
		"pf_encap_connection_check: SA or exchange for %s exists", 
		conn));
      return;
    }

  /* Figure out the DOI.  We only handle IPsec so far.  */
  conf = conf_get_str (conn, "Configuration");
  if (!conf)
    {
      log_print ("pf_encap_connection_check: "
		 "no \"Configuration\" specified for %s",
		 conn);
      return;
    }
  doi_str = conf_get_str (conf, "DOI");
  if (doi_str && strcasecmp (doi_str, "IPSEC") != 0)
    {
      log_print ("pf_encap_connection_check: DOI \"%s\" unsupported", doi_str);
      return;
    }

  local_id = conf_get_str (conn, "Local-ID");
  remote_id = conf_get_str (conn, "Remote-ID");

  /* At the moment I only do on-demand keying for modes with client IDs.  */
  if (!local_id || !remote_id)
    {
      log_print ("pf_encap_connection_check: "
		 "both Local-ID and Remote-ID required for %s", conn);
      return;
    }

  if (ipsec_get_id (local_id, &lid, &laddr, &lmask, &tproto, &sport))
    return;
  if (ipsec_get_id (remote_id, &rid, &raddr, &rmask, &tproto, &dport))
    return;

  peer = conf_get_str (conn, "ISAKMP-peer");
  if (!peer)
    {
      log_print ("pf_encap_connection_check: "
		 "section %s has no \"ISAKMP-peer\" tag", conn);
      return;
    }
  address = conf_get_str (peer, "Address");
  if (!address)
    {
      log_print ("pf_encap_connection_check: "
		 "section %s has no \"Address\" tag",
		 peer);
      return;
    }
  if (!inet_aton (address, &gwaddr))
    {
      log_print ("pf_encap_connection_check: invalid adress %s in section %s",
		 address, peer);
      return;
    }

  err = pf_encap_register_on_demand_connection (gwaddr.s_addr, conn);
  if (err)
    return;

  if (pf_encap_route (((struct sockaddr_in *)laddr)->sin_addr.s_addr,
		      ((struct sockaddr_in *)lmask)->sin_addr.s_addr,
		      ((struct sockaddr_in *)raddr)->sin_addr.s_addr,
		      ((struct sockaddr_in *)rmask)->sin_addr.s_addr,
		      gwaddr.s_addr))
    {
      pf_encap_deregister_on_demand_connection (conn);
      return;
    }
}

/* Lookup an on-demand connection from its name: CONN.  */
static struct on_demand_connection *
pf_encap_lookup_on_demand_connection (char *conn)
{
  struct on_demand_connection *node;

  for (node = LIST_FIRST (&on_demand_connections); node;
       node = LIST_NEXT (node, link))
    if (strcasecmp (conn, node->conn) == 0)
      return node;
  return 0;
}

/*
 * Register an IP-address to Phase 2 connection name mapping.
 */
static int
pf_encap_register_on_demand_connection (in_addr_t dst, char *conn)
{
  struct on_demand_connection *node;

  /* Don't add duplicates.  */
  if (pf_encap_lookup_on_demand_connection (conn))
    return 0;

  node = malloc (sizeof *node);
  if (!node)
    {
      log_error ("pf_encap_register_on_demand_connection: malloc (%d) failed",
		 sizeof *node);
      return -1;
    }

  node->dst = dst;
  node->conn = strdup (conn);
  if (!node->conn)
    {
      log_error ("pf_encap_register_on_demand_connection: "
		 "strdup (\"%s\") failed",
		 conn);
      free (node);
      return -1;
    }

  LIST_INSERT_HEAD (&on_demand_connections, node, link);
  return 0;
}

/*
 * Remove an IP-address to Phase 2 connection name mapping.
 */
static void
pf_encap_deregister_on_demand_connection (char *conn)
{
  struct on_demand_connection *node;

  node = pf_encap_lookup_on_demand_connection (conn);
  if (node)
    {
      LIST_REMOVE (node, link);
      free (node->conn);
      free (node);
    }
}
@


1.24
log
@Get rid of redundant lengths in get_spi API.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_encap.c,v 1.23 2001/06/29 04:12:00 ho Exp $	*/
@


1.23
log
@Initial IPv6 support. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_encap.c,v 1.22 2001/06/27 03:31:42 angelos Exp $	*/
d394 2
a395 2
pf_encap_get_spi (size_t *sz, u_int8_t proto, struct sockaddr *src, int srclen,
		  struct sockaddr *dst, int dstlen)
a444 1
  int dstlen;
d457 1
a457 1
    sa->transport->vtbl->get_src (sa->transport, &dst, &dstlen);
d459 1
a459 1
    sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
d492 1
a492 1
  int dstlen, srclen, keylen, hashlen;
d616 2
a617 2
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
  sa->transport->vtbl->get_src (sa->transport, &src, &srclen);
a675 1
  int dstlen;
d686 1
a686 1
    sa->transport->vtbl->get_src (sa->transport, &dst, &dstlen);
d688 1
a688 1
    sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
a713 1
  int dstlen;
d716 1
a716 1
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
@


1.22
log
@Consistently use "IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_encap.c,v 1.21 2001/04/09 22:09:52 ho Exp $	*/
d6 1
d728 3
a730 3
pf_encap_enable_spi (in_addr_t laddr, in_addr_t lmask, in_addr_t raddr,
		     in_addr_t rmask, u_int8_t *spi, u_int8_t proto,
		     in_addr_t dst)
d733 3
d748 10
d759 17
a775 5
	    htonl (laddr), htonl (lmask), htonl (raddr), htonl (rmask)));
  emsg->em_ena_isrc.s_addr = laddr;
  emsg->em_ena_ismask.s_addr = lmask;
  emsg->em_ena_idst.s_addr = raddr;
  emsg->em_ena_idmask.s_addr = rmask;
d932 2
a933 1
  struct in_addr laddr, lmask, raddr, rmask, gwaddr;
d1004 4
a1007 1
  if (pf_encap_route (laddr.s_addr, lmask.s_addr, raddr.s_addr, rmask.s_addr,
@


1.21
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_encap.c,v 1.20 2001/01/27 12:03:34 niklas Exp $	*/
d668 1
a668 1
 * Delete the IPSec SA represented by the INCOMING direction in protocol PROTO
@


1.20
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_encap.c,v 1.19 2001/01/26 12:12:52 niklas Exp $	*/
d745 1
a745 1
	    htonl(laddr), htonl(lmask), htonl(raddr), htonl(rmask)));
d857 1
a857 1
  if (write(s, (caddr_t)rtmsg, rtmsg->rtm_msglen) == -1)
d865 1
a865 1
	  if (write(s, (caddr_t)rtmsg, rtmsg->rtm_msglen) == -1)
d867 2
a868 2
	      log_error("pf_encap_route: write(%d, %p, %d) failed", s, rtmsg,
			rtmsg->rtm_msglen);
d874 2
a875 2
	  log_error("pf_encap_route: write(%d, %p, %d) failed", s, rtmsg,
		    rtmsg->rtm_msglen);
@


1.19
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_encap.c,v 1.18 2000/12/12 01:46:29 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.18
log
@Merge with EOM 1.73

author: angelos
Pass the local/remote Phase 1 ID to the flow, so it can be reused when
an SA is re-negotiated.

author: angelos
isakmpd can now negotiate transport protocol/ports (either through the
configuration file or through kernel ACQUIREs).
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_encap.c,v 1.17 2000/06/08 20:49:19 niklas Exp $	*/
d284 2
a285 1
      log_error ("pf_encap_write: write (%d, ...) returned prematurely", pf_encap_socket);
@


1.17
log
@Merge with EOM 1.71

author: ho
DOI IPSEC is default if not specified.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.16 2000/02/25 17:23:41 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.71 2000/05/12 12:41:23 ho Exp $	*/
d710 1
a710 1
pf_encap_enable_sa (struct sa *sa)
d907 2
d945 1
a945 1
  if (ipsec_get_id (local_id, &lid, &laddr, &lmask))
d947 1
a947 1
  if (ipsec_get_id (remote_id, &rid, &raddr, &rmask))
@


1.17.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.21 2001/04/09 22:09:52 ho Exp $	*/
/*	$EOM: pf_encap.c,v 1.73 2000/12/04 04:46:34 angelos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
d284 1
a284 2
      log_error ("pf_encap_write: write (%d, ...) returned prematurely",
		 pf_encap_socket);
d710 1
a710 1
pf_encap_enable_sa (struct sa *sa, struct sa *isakmp_sa)
d744 1
a744 1
	    htonl (laddr), htonl (lmask), htonl (raddr), htonl (rmask)));
d856 1
a856 1
  if (write (s, (caddr_t)rtmsg, rtmsg->rtm_msglen) == -1)
d864 1
a864 1
	  if (write (s, (caddr_t)rtmsg, rtmsg->rtm_msglen) == -1)
d866 2
a867 2
	      log_error ("pf_encap_route: write(%d, %p, %d) failed", s, rtmsg,
			 rtmsg->rtm_msglen);
d873 2
a874 2
	  log_error ("pf_encap_route: write(%d, %p, %d) failed", s, rtmsg,
		     rtmsg->rtm_msglen);
a906 2
  u_int8_t tproto;
  u_int16_t sport, dport;
d943 1
a943 1
  if (ipsec_get_id (local_id, &lid, &laddr, &lmask, &tproto, &sport))
d945 1
a945 1
  if (ipsec_get_id (remote_id, &rid, &raddr, &rmask, &tproto, &dport))
@


1.16
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.15 1999/05/02 19:16:12 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.70 2000/02/20 19:58:40 niklas Exp $	*/
d926 1
a926 6
  if (!doi_str)
    {
      log_print ("pf_encap_connection_check: No DOI specified for %s", conf);
      return;
    }
  if (strcasecmp (doi_str, "IPSEC") != 0)
@


1.15
log
@Merge with EOM 1.69

author: niklas
Remove bogus XXXes, add allocation error reporting.

author: ho
Typo.

author: ho
Do not automatically check connections at HARD_EXPIRE.
Also check for existing exchanges in pf_encap_connection_check.

author: ho
Cut'n'paste typo fix.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.14 1999/05/01 22:57:38 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.69 1999/05/02 12:50:28 niklas Exp $	*/
d120 5
a124 5
  log_debug (LOG_SYSDEP, 20,
	     "pf_encap_expire: NOTIFY_%s_EXPIRE dst %s spi %x sproto %d",
	     emsg->em_not_type == NOTIFY_SOFT_EXPIRE ? "SOFT" : "HARD",
	     inet_ntoa (emsg->em_not_dst), htonl (emsg->em_not_spi),
	     emsg->em_not_sproto);
d181 2
a182 2
  log_debug_buf (LOG_SYSDEP, 90, "pf_encap_notify: emsg", (u_int8_t *)emsg,
		 emsg->em_msglen);
d274 2
a275 2
  log_debug_buf (LOG_SYSDEP, 30, "pf_encap_write: em", (u_int8_t *)em,
		 em->em_msglen);
d299 3
a301 3
  log_debug (LOG_SYSDEP, 10,
	     "pf_encap_request_sa: SA requested for %s type %d",
	     inet_ntoa (emsg->em_not_dst), emsg->em_not_satype);
d424 1
a424 1
  log_debug_buf (LOG_SYSDEP, 50, "pf_encap_get_spi: spi", spi, *sz);
d470 1
a470 1
  log_debug (LOG_SYSDEP, 50, "pf_encap_group_spis: done");
d649 3
a651 2
  log_debug (LOG_SYSDEP, 10, "pf_encap_set_spi: proto %d dst %s SPI 0x%x",
	     emsg->em_sproto, inet_ntoa (emsg->em_dst), htonl (emsg->em_spi));
d656 1
a656 1
  log_debug (LOG_SYSDEP, 50, "pf_encap_set_spi: done");
d698 1
a698 1
  log_debug (LOG_SYSDEP, 50, "pf_encap_delete_spi: done");
d743 2
a744 2
  log_debug (LOG_SYSDEP, 50, "pf_encap_enable_spi: src %x %x dst %x %x",
	     htonl(laddr), htonl(lmask), htonl(raddr), htonl(rmask));
d773 1
a773 1
  log_debug (LOG_SYSDEP, 50, "pf_encap_enable_spi: done");
d854 2
a855 2
  log_debug (LOG_SYSDEP, 70, "pf_encap_route: rtmsg", rtmsg,
	     rtmsg->rtm_msglen);
d862 2
a863 2
	  log_debug (LOG_SYSDEP, 70, "pf_encap_route: rtmsg", rtmsg,
		     rtmsg->rtm_msglen);
d889 1
a889 1
  log_debug (LOG_SYSDEP, 30, "pf_encap_route: done");
d910 3
a912 3
      log_debug (LOG_SYSDEP, 70,
		 "pf_encap_connection_check: SA or exchange for %s exists", 
		 conn);
@


1.14
log
@Merge with EOM 1.65

author: niklas
Forgot one change in last commit
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.13 1999/05/01 20:43:43 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.65 1999/05/01 21:08:42 niklas Exp $	*/
d156 5
d171 1
d799 6
a804 2
    /* XXX Log?  */
    goto fail;
d907 1
a907 1
  if (sa_lookup_by_name (conn, 2))
d910 2
a911 1
		 "pf_key_v2_connection_check: SA for %s exists", conn);
@


1.13
log
@sysdep/openbsd/sysdep.c: Merge with EOM 1.7
DESIGN-NOTES: Merge with EOM 1.42
Makefile: Merge with EOM 1.51
app.c: Merge with EOM 1.6
conf.c: Merge with EOM 1.18
init.c: Merge with EOM 1.14
isakmpd.conf.5: Merge with EOM 1.19
pf_encap.c: Merge with EOM 1.64
pf_encap.h: Merge with EOM 1.12
pf_key_v2.h: Merge with EOM 1.3
sysdep.h: Merge with EOM 1.16
transport.c: Merge with EOM 1.40
ui.c: Merge with EOM 1.32

author: niklas
A new connection abstraction
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.12 1999/04/19 21:07:42 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.64 1999/05/01 20:21:11 niklas Exp $	*/
d161 5
a165 8
	{
	  /*
	   * We reestablish the on-demand route here even if we have started
	   * a new negotiation, considering it might fail.
	   */
	  pf_encap_deregister_on_demand_connection (sa->name);
	  pf_encap_connection (sa->name);
	}
@


1.12
log
@./pf_encap.c: Merge with EOM 1.63

remove warning

Simplify the checks of existing exchanges by moving it into
exchange_establish.  This means we need to change the finalize API.
Try to make PF_ENCAP support handle multiple connections to a single
security gateway.

Sigh, log the SPIs in network byte order, please
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.11 1999/04/05 21:02:48 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.63 1999/04/15 19:03:04 niklas Exp $	*/
d892 3
a894 2
int
pf_encap_connection (char *conn)
d900 7
d911 2
a912 1
      log_print ("pf_encap_connection: no \"Configuration\" specified for %s",
d914 1
a914 1
      return -1;
d919 2
a920 2
      log_print ("sysdep_conf_init_hook: No DOI specified for %s", conf);
      return -1;
d924 2
a925 2
      log_print ("sysdep_conf_init_hook: DOI \"%s\" unsupported", doi_str);
      return -1;
d934 1
a934 1
      log_print ("sysdep_conf_init_hook: "
d936 1
a936 1
      return -1;
d940 1
a940 1
    return -1;
d942 1
a942 1
    return -1;
d947 1
a947 1
      log_print ("sysdep_conf_init_hook: "
d949 1
a949 1
	  return -1;
d954 2
a955 1
      log_print ("sysdep_conf_init_hook: section %s has no \"Address\" tag",
d957 1
a957 1
      return -1;
d961 1
a961 1
      log_print ("sysdep_conf_init_hook: invalid adress %s in section %s",
d963 1
a963 1
      return -1;
d968 1
a968 1
    return -1;
d974 1
a974 1
      return -1;
d976 12
d999 4
d1005 6
a1010 1
    return -1;
d1015 3
d1021 1
d1034 7
a1040 9
  for (node = LIST_FIRST (&on_demand_connections); node;
       node = LIST_NEXT (node, link))
    if (strcasecmp (conn, node->conn) == 0)
      {
	LIST_REMOVE (node, link);
	free (node->conn);
	free (node);
	break;
      }
@


1.11
log
@Merge with EOM 1.60
Mem leak plugging.  New finalize API.

Do not renegotiate on already replaced SA expirations

Only establish on-demand route if we know how to

If we get an EEXIST from RTM_ADD, try to RTM_CHANGE the route.

Correct buffer size in log printout

make compile

Make "Connections" handling nicer, and even implement it for KLIPS.
A stab at reregestering the on-demand routes for PF_ENCAP.

typo found by ho@@netman.se
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.10 1999/03/31 14:27:38 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.60 1999/04/05 08:07:55 niklas Exp $	*/
a73 1
static char *pf_encap_on_demand_connection (in_addr_t);
d123 1
a123 1
	     inet_ntoa (emsg->em_not_dst), emsg->em_not_spi,
d151 1
a151 5
    {
      /* If we are already renegotiating, don't start over.  */
      if (!exchange_lookup_by_name (sa->name, 2))
	exchange_establish (sa->name, 0, 0);
    }
a185 1
      free (emsg);
a194 1
      free (emsg);
d197 1
a286 9
static void
pf_encap_finalize_request_sa (void *v_emsg, int fail)
{
  struct encap_msghdr *emsg = v_emsg;

  pf_encap_write (emsg);
  free (emsg);
}

d294 1
a294 1
  char *conn;
a299 6
  /* XXX pf_encap_on_demand_connection should return a list of connections.  */
  conn = pf_encap_on_demand_connection (emsg->em_not_dst.s_addr);
  if (!conn)
    /* Not ours.  */
    goto bail_out;

d301 12
a312 12
   * If a connection or an SA for this connections already exists, drop it.
   * XXX Perhaps this test is better to have in exchange_establish.
   * XXX We are leaking emsg here.
   */
  if (exchange_lookup_by_name (conn, 2) || sa_lookup_by_name (conn, 2))
    goto bail_out;

  exchange_establish (conn, pf_encap_finalize_request_sa, emsg);
  return;

 bail_out:
  free (emsg);
d704 1
a704 1
/* Enable a flow given a SA.  */
a1007 16
}

/*
 * Return a phase 2 connection name given a security gateway's IP-address.
 * XXX Does only handle 1-1 mappings so far.
 */
static char *
pf_encap_on_demand_connection (in_addr_t dst)
{
  struct on_demand_connection *node;

  for (node = LIST_FIRST (&on_demand_connections); node;
       node = LIST_NEXT (node, link))
    if (dst == node->dst)
      return node->conn;
  return 0;
@


1.10
log
@ipsec.c: Merge with EOM 1.86
ipsec.h: Merge with EOM 1.33
pf_encap.c: Merge with EOM 1.52
pf_key_v2.c: Merge with EOM 1.3

Fix case of missing client ID payloads, a case the standards allow.  Thanks
to Michael Paddon (mwp@@aba.net.au) for the diffs I based my fix upon.  His
diff also made me realize I stored the address information in host order in
internal structures where I had planned to use network order.  Fix this,
and remove the XXXes I had due to this elsewhere.  Add commentary.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.9 1999/03/31 00:51:50 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.52 1999/03/31 14:19:53 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d51 1
d73 1
a73 1
static void pf_encap_deregister_on_demand_connection (in_addr_t, char *);
d150 2
a151 1
  if (sa->flags & SA_FLAG_STAYALIVE)
d161 3
a163 3
       * XXX We need to reestablish the on-demand route here.  This we need
       * even if we have started a new negotiation, considering it might
       * fail.
d165 9
d184 1
a184 1
		 sizeof *emsg);
d234 4
a237 1
    return;
d282 1
a282 1
      log_error ("write (%d, ...) failed", pf_encap_socket);
d287 1
a287 1
      log_error ("write (%d, ...) returned prematurely", pf_encap_socket);
d294 1
a294 1
pf_encap_finalize_request_sa (void *v_emsg)
d302 4
d319 1
a319 1
    return;
d327 4
a330 1
    return;
d332 2
a333 2
  if (conn)
    exchange_establish (conn, pf_encap_finalize_request_sa, emsg);
d338 1
a338 1
 * If we see a notify queue it up as a timeout timing out NOW for the main
d424 1
a424 1
  memcpy (&emsg->em_gen_dst, &ipv4_src->sin_addr, sizeof ipv4_src->sin_addr);
d804 1
a804 1
int
d806 1
a806 1
		in_addr_t rmask, u_int32_t spi, in_addr_t dst, char *conn)
d809 1
a809 1
  int off, err;
a812 4
  err = pf_encap_register_on_demand_connection (dst, conn);
  if (err)
    return -1;

d824 1
a824 1
		"socket(PF_ROUTE, SOCK_RAW, AF_UNSPEC) failed");
d856 1
a856 1
  gw->sen_ipsp_spi = htonl(spi);
d866 3
a868 1
	
d871 19
a889 2
      log_error("write(%d, ...) failed", s);
      goto fail;
d901 2
a909 1
  pf_encap_deregister_on_demand_connection (dst, conn);
d913 77
d1002 6
a1007 1
  node->conn = conn;
d1016 1
a1016 1
pf_encap_deregister_on_demand_connection (in_addr_t dst, char *conn)
d1022 1
a1022 1
    if (dst == node->dst && conn == node->conn)
d1025 3
@


1.9
log
@Merge with EOM 1.51
Async PF_ENCAP messages might be handled earlier so recheck readability in
the handler.  Remove some XXX comments.  Fix some byte order conversions in
debugging output.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.8 1999/03/24 14:41:41 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.51 1999/03/30 21:43:08 niklas Exp $	*/
d715 2
a716 4
  /* XXX Check why byte ordering is backwards.  */
  return pf_encap_enable_spi (htonl (isa->src_net), htonl (isa->src_mask),
			      htonl (isa->dst_net), htonl (isa->dst_mask),
			      proto->spi[0], proto->proto,
@


1.8
log
@Merge with EOM 1.50
New sysdep API.  Fix an allocation size typo.  Use correct SPIs and
addresses all over.

Simplify flow

Correct log headers

s/LOG_PF_ENCAP/LOG_SYSDEP/
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.7 1999/03/02 15:48:23 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.50 1999/03/24 11:04:12 niklas Exp $	*/
d38 1
d201 15
a393 1
  /* IPv4-specific, but so is PF_ENCAP.  */
a611 3
  /*
   * XXX Addresses has to be thought through.  Assumes IPv4.
   */
d742 1
a742 1
	     laddr, lmask, raddr, rmask);
@


1.7
log
@sa.c: Merge with EOM 1.67
Add SA attributes, specifically stayalive

sa.h: Merge with EOM 1.42
Add SA attributes, specifically stayalive

pf_encap.c: Merge with EOM 1.46
Add SA attributes, specifically stayalive

exchange.c: Merge with EOM 1.65
Add SA attributes, specifically stayalive
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.6 1999/02/27 09:59:36 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.46 1999/03/02 15:43:00 niklas Exp $	*/
d119 2
a120 2
  log_debug (LOG_PF_ENCAP, 20,
	     "pf_encap_handler: NOTIFY_%s_EXPIRE dst %s spi %x sproto %d",
d162 3
a165 4

  /* If this was a hard expire, remove the old SA, it isn't useful anymore.  */
  if (emsg->em_not_type == NOTIFY_HARD_EXPIRE)
    sa_free (sa);
d171 1
a171 1
  log_debug_buf (LOG_PF_ENCAP, 90, "pf_encap_notify: emsg", (u_int8_t *)emsg,
d187 1
a187 1
      log_print ("pf_encap_handler: unknown notify message type (%d)",
d247 1
a247 1
  log_debug_buf (LOG_PF_ENCAP, 30, "pf_encap_write: em", (u_int8_t *)em,
d277 2
a278 1
  log_debug (LOG_PF_ENCAP, 10, "pf_encap_handler: SA requested for %s type %d",
d369 2
a370 2
 * Generate a SPI for protocol PROTO and the destination signified by
 * ID & ID_SZ.  Stash the SPI size in SZ.
d373 2
a374 1
pf_encap_get_spi (size_t *sz, u_int8_t proto, void *id, size_t id_sz)
d378 2
a379 1
  struct sockaddr_in *ipv4_id = id;
d388 1
a388 1
  memcpy (&emsg->em_gen_dst, &ipv4_id->sin_addr, sizeof ipv4_id->sin_addr);
d406 1
a406 1
  log_debug_buf (LOG_PF_ENCAP, 50, "pf_encap_get_spi: spi", spi, *sz);
d418 1
a418 1
/* Group 2 SPIs in a chain.  XXX not implemented yet.  */
d421 1
a421 1
		     int role)
d434 2
a435 2
  memcpy (&emsg->em_rel_spi, proto1->spi[role], sizeof emsg->em_rel_spi);
  memcpy (&emsg->em_rel_spi2, proto2->spi[role],
d437 4
a440 1
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
d452 1
a452 1
  log_debug (LOG_PF_ENCAP, 50, "pf_encap_group_spis: done");
d462 5
a466 1
/* Store/update a SPI with full information into the kernel.  */
d468 1
a468 1
pf_encap_set_spi (struct sa *sa, struct proto *proto, int role, int initiator)
d542 2
a543 1
      edx->edx_wnd = iproto->replay_window;
d545 1
a545 1
      memcpy (edx->edx_data + 8, iproto->keymat[role], keylen);
d547 1
a547 1
	memcpy (edx->edx_data + keylen + 8, iproto->keymat[role] + keylen,
d580 3
a582 2
      amx->amx_wnd = iproto->replay_window;
      memcpy (amx->amx_key, iproto->keymat[role], hashlen);
d592 1
a592 1
  memcpy (&emsg->em_spi, proto->spi[role], sizeof emsg->em_spi);
d603 1
a603 1
    = ((struct sockaddr_in *)((initiator ^ role) ? dst : src))->sin_addr;
d605 1
a605 1
    = ((struct sockaddr_in *)((initiator ^ role) ? src : dst))->sin_addr;
d634 1
a634 1
  log_debug (LOG_PF_ENCAP, 10, "pf_encap_set_spi: proto %d dst %s SPI 0x%x",
d640 1
a640 1
  log_debug (LOG_PF_ENCAP, 50, "pf_encap_set_spi: done");
d650 4
a653 1
/* Delete a specific SPI from the IPSEC kernel subsystem.  */
d655 1
a655 1
pf_encap_delete_spi (struct sa *sa, struct proto *proto, int initiator)
d668 5
a672 2
  memcpy (&emsg->em_gen_spi, proto->spi[initiator], sizeof emsg->em_gen_spi);
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
d682 1
a682 1
  log_debug (LOG_PF_ENCAP, 50, "pf_encap_delete_spi: done");
d694 1
a694 1
pf_encap_enable_sa (struct sa *sa, int initiator)
d706 1
a706 1
			      proto->spi[!initiator], proto->proto,
d729 1
a729 1
  log_debug (LOG_PF_ENCAP, 50, "pf_encap_enable_spi: src %x %x dst %x %x",
d759 1
a759 1
  log_debug (LOG_PF_ENCAP, 50, "pf_encap_enable_spi: done");
d775 1
a775 1
		in_addr_t rmask, u_int8_t spi, in_addr_t dst, char *conn)
d786 3
a788 1
  rtmsg = calloc (1, EMT_ENABLESPI_FLEN);
@


1.6
log
@ipsec.c: Merge with EOM 1.83
Only accept IPsec SAs when searching for such

sa.h: Merge with EOM 1.41
Stayalive connections as a default for now, init pf_encap_socket

pf_encap.c: Merge with EOM 1.45
Stayalive connections as a default for now, init pf_encap_socket
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.5 1999/02/26 03:48:32 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.45 1999/02/26 14:41:31 niklas Exp $	*/
a682 3

  /* XXX Hardwire for the time being.  */
  sa->flags |= SA_FLAG_STAYALIVE;
@


1.5
log
@Merge from the Ericsson repository
| revision 1.44
| date: 1999/02/25 14:03:54;  author: niklas;  state: Exp;  lines: +13 -13
| do not use the app_socket name.  correct some LOG_* syms
| ----------------------------
| revision 1.43
| date: 1999/02/25 11:39:17;  author: niklas;  state: Exp;  lines: +3 -2
| include sysdep.h everywhere
| ----------------------------
| revision 1.42
| date: 1999/02/25 09:30:28;  author: niklas;  state: Exp;  lines: +3 -3
| Replay protection window configurable
| ----------------------------
| revision 1.41
| date: 1999/02/14 00:17:15;  author: niklas;  state: Exp;  lines: +68 -28
| Better PF_ENCAP expiration  and SA request handling
| ----------------------------
| revision 1.40
| date: 1999/02/06 15:08:33;  author: niklas;  state: Exp;  lines: +6 -1
| Drop SA request notifies if an exchange or SA already exist
| ----------------------------
| revision 1.39
| date: 1999/01/31 01:20:37;  author: niklas;  state: Exp;  lines: +217 -51
| on-demand keying
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.4 1998/12/21 01:02:26 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.44 1999/02/25 14:03:54 niklas Exp $	*/
d110 1
d126 1
a126 1
   * Fin the IPsec SA.  The IPsec stack has two SAs for every IKE SA,
d129 1
a129 1
   * protection suites consisitng of more than one protocol, any
d143 11
a153 1
  /* XXX We need to reestablish the on-demand route here. */
d155 10
a164 1
  /* If this was a hard expire, remove the SA.  */
d683 3
@


1.4
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.3 1998/11/17 11:10:18 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.38 1998/12/17 07:56:33 niklas Exp $	*/
d39 2
d42 1
d54 2
a55 1
#include "app.h"
d57 1
a64 1
#include "sysdep.h"
d68 29
a96 1
void pf_encap_request_sa (struct encap_msghdr *);
d116 25
a140 1
  /* XXX not implemented yet.  */
d142 5
a146 1
  /* Identify the IPsec SA and rekey that one.  */
a158 5
      log_debug (LOG_PF_ENCAP, 20,
		 "pf_encap_handler: NOTIFY_%s_EXPIRE dst %s spi %x sproto %d",
		 emsg->em_not_type == NOTIFY_SOFT_EXPIRE ? "SOFT" : "HARD",
		 inet_ntoa (emsg->em_not_dst), emsg->em_not_spi,
		 emsg->em_not_sproto);
d160 1
a163 3
      log_debug (LOG_PF_ENCAP, 10,
		 "pf_encap_handler: SA requested for %s type %d",
		 inet_ntoa (emsg->em_not_dst), emsg->em_not_satype);
d170 1
a172 1
  free (emsg);
a219 35
void
pf_encap_request_sa (struct encap_msghdr *emsg)
{
  struct transport *transport;
  struct sa *isakmp_sa;
  char addr[20];
  in_port_t port;
  struct sockaddr *taddr;
  int taddr_len;

  /*
   * XXX I'd really want some more flexible way to map the IPv4 address in
   * this message to a general transport endpoint.  For now we hardcode
   * the ISAKMP peer to be at the same IP and talking UDP.
   */
  port = conf_get_num (inet_ntoa (emsg->em_not_dst), "port");
  if (!port)
    port = UDP_DEFAULT_PORT;
  snprintf (addr, 20, "%s:%d", inet_ntoa (emsg->em_not_dst), port);
  transport = transport_create ("udp", addr);
  if (!transport)
    {
      log_print ("pf_encap_request_sa: "
		 "transport \"udp %s\" could not be created",
		 transport, addr);
      return;
    }

  /* Check if we already have an ISAKMP SA setup.  */
  transport->vtbl->get_dst (transport, &taddr, &taddr_len);
  isakmp_sa = sa_isakmp_lookup_by_peer (taddr, taddr_len);
  if (!isakmp_sa)
    /* XXX transport_free (transport)  */ ;
}

d230 1
a230 1
  n = write (app_socket, em, em->em_msglen);
d233 1
a233 1
      log_error ("write (%d, ...) failed", app_socket);
d238 1
a238 1
      log_error ("write (%d, ...) returned prematurely", app_socket);
d244 35
d303 1
a303 2
      /* XXX Should we have a static pf_encap_socket instead?  */
      n = read (app_socket, buf, EMT_NOTIFY_FLEN);
d306 1
a306 1
	  log_error ("read (%d, ...) failed", app_socket);
d313 1
a313 1
		     app_socket, n);
d348 4
d384 1
a384 1
  log_debug_buf (LOG_MISC, 50, "pf_encap_get_spi: spi", spi, *sz);
d427 1
a427 1
  log_debug (LOG_MISC, 50, "pf_encap_group_spis: done");
d513 1
a513 1
      edx->edx_wnd = 16;
d550 1
a550 1
      amx->amx_wnd = 16;
d645 1
a645 1
  log_debug (LOG_MISC, 50, "pf_encap_delete_spi: done");
d655 18
d675 3
a677 1
pf_encap_enable_spi (struct sa *sa, int initiator)
a678 1
  struct ipsec_sa *isa = sa->data;
a679 3
  struct sockaddr *dst, *src;
  int dstlen, srclen;
  struct proto *proto = TAILQ_FIRST (&sa->protos);
d683 1
d689 2
a690 5
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
  sa->transport->vtbl->get_src (sa->transport, &src, &srclen);

  memcpy (&emsg->em_ena_spi, proto->spi[!initiator], sizeof emsg->em_ena_spi);
  emsg->em_ena_dst = ((struct sockaddr_in *)dst)->sin_addr;
d693 5
a697 6
	     isa->src_net, isa->src_mask, isa->dst_net, isa->dst_mask);
  /* XXX Check why byte ordering is backwards.  */
  emsg->em_ena_isrc.s_addr = htonl (isa->src_net);
  emsg->em_ena_ismask.s_addr = htonl (isa->src_mask);
  emsg->em_ena_idst.s_addr = htonl (isa->dst_net);
  emsg->em_ena_idmask.s_addr = htonl (isa->dst_mask);
d702 1
a702 1
    = proto->proto == IPSEC_PROTO_IPSEC_ESP ? IPPROTO_ESP : IPPROTO_AH;
d722 1
a722 3

  log_debug (LOG_MISC, 50, "pf_encap_enable_spi: done");

d729 145
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_encap.c,v 1.2 1998/11/15 00:44:01 niklas Exp $	*/
/*	$EOM: pf_encap.c,v 1.35 1998/11/14 23:41:21 niklas Exp $	*/
d85 2
d533 2
a534 1
  emsg->em_expire_hard = time ((time_t *)0) + (u_int64_t)sa->seconds;
d536 2
a537 1
  emsg->em_expire_soft = time ((time_t *)0) + (u_int64_t)sa->seconds * 9 / 10;
d603 1
d622 7
a628 5
  emsg->em_ena_isrc.s_addr = ((struct sockaddr_in *)src)->sin_addr.s_addr;
  emsg->em_ena_ismask.s_addr = 0xffffffff;
  emsg->em_ena_idst.s_addr = emsg->em_ena_dst.s_addr;
  emsg->em_ena_idmask.s_addr = 0xffffffff;
  /* XXX How to deduce if we need ENABLE_FLAG_LOCAL?  */
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: pf_encap.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: pf_encap.c,v 1.35 1998/11/14 23:41:21 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
