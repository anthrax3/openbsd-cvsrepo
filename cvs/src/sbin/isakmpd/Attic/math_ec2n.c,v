head	1.14;
access;
symbols
	OPENBSD_4_7:1.13.0.18
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.20
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.16
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.14
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.12
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.12
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2010.06.29.19.50.16;	author reyk;	state dead;
branches;
next	1.13;

1.13
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	99.04.20.11.32.57;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.04.19.21.22.49;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.04.05.21.01.41;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.03.46.40;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.16;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Replace the hand-crafted Diffie-Hellman implementation in isakmpd with
the smaller implementation from iked that is using libcrypto instead.
This allows to remove a lot of code (which is always good), get rid of
some custom crypto code by using libcrypto, theoretically adds
support for many new MODP and EC2N/ECP modes (but it is not configurable
yet), and allows to share the dh.c/dh.h code in different codebases
(it is identical in isakmpd and iked, but could also be used elsewhere).

ok deraadt@@
@
text
@/* $OpenBSD: math_ec2n.c,v 1.13 2005/04/08 22:32:10 cloder Exp $	 */
/* $EOM: math_ec2n.c,v 1.9 1999/04/20 09:23:31 niklas Exp $	 */

/*
 * Copyright (c) 1998 Niels Provos.  All rights reserved.
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/param.h>
#include <stdio.h>

#include "math_2n.h"
#include "math_ec2n.h"

void
ec2np_init(ec2np_ptr n)
{
	b2n_init(n->x);
	b2n_init(n->y);
	n->inf = 0;
}

void
ec2np_clear(ec2np_ptr n)
{
	b2n_clear(n->x);
	b2n_clear(n->y);
}

int
ec2np_set(ec2np_ptr d, ec2np_ptr n)
{
	if (d == n)
		return 0;

	d->inf = n->inf;
	if (b2n_set(d->x, n->x))
		return -1;
	return b2n_set(d->y, n->y);
}

/* Group */

void
ec2ng_init(ec2ng_ptr n)
{
	b2n_init(n->a);
	b2n_init(n->b);
	b2n_init(n->p);
}

void
ec2ng_clear(ec2ng_ptr n)
{
	b2n_clear(n->a);
	b2n_clear(n->b);
	b2n_clear(n->p);
}

int
ec2ng_set(ec2ng_ptr d, ec2ng_ptr n)
{
	if (b2n_set(d->a, n->a))
		return -1;
	if (b2n_set(d->b, n->b))
		return -1;
	return b2n_set(d->p, n->p);
}

/* Arithmetic functions */

int
ec2np_right(b2n_ptr n, ec2np_ptr p, ec2ng_ptr g)
{
	b2n_t	temp;

	b2n_init(temp);

	/* First calc x**3 + ax**2 + b */
	if (b2n_square(n, p->x))
		goto fail;
	if (b2n_mod(n, n, g->p))
		goto fail;

	if (b2n_mul(temp, g->a, n))	/* a*x**2 */
		goto fail;
	if (b2n_mod(temp, temp, g->p))
		goto fail;

	if (b2n_mul(n, n, p->x))/* x**3 */
		goto fail;
	if (b2n_mod(n, n, g->p))
		goto fail;

	if (b2n_add(n, n, temp))
		goto fail;
	if (b2n_add(n, n, g->b))
		goto fail;

	b2n_clear(temp);
	return 0;

fail:
	b2n_clear(temp);
	return -1;
}

int
ec2np_ison(ec2np_ptr p, ec2ng_ptr g)
{
	int	res;
	b2n_t	x, y, temp;

	if (p->inf)
		return 1;

	b2n_init(x);
	b2n_init(y);
	b2n_init(temp);

	/* First calc x**3 + ax**2 + b */
	if (ec2np_right(x, p, g))
		goto fail;

	/* Now calc y**2 + xy */
	if (b2n_square(y, p->y))
		goto fail;
	if (b2n_mod(y, y, g->p))
		goto fail;

	if (b2n_mul(temp, p->y, p->x))
		goto fail;
	if (b2n_mod(temp, temp, g->p))
		goto fail;

	if (b2n_add(y, y, temp))
		goto fail;

	res = !b2n_cmp(x, y);

	b2n_clear(x);
	b2n_clear(y);
	b2n_clear(temp);
	return res;

fail:
	b2n_clear(x);
	b2n_clear(y);
	b2n_clear(temp);
	return -1;
}

int
ec2np_find_y(ec2np_ptr p, ec2ng_ptr g)
{
	b2n_t	right;

	b2n_init(right);

	if (ec2np_right(right, p, g))	/* Right sight of equation */
		goto fail;
	if (b2n_mul_inv(p->y, p->x, g->p))
		goto fail;

	if (b2n_square(p->y, p->y))
		goto fail;
	if (b2n_mod(p->y, p->y, g->p))
		goto fail;

	if (b2n_mul(right, right, p->y))	/* x^-2 * right */
		goto fail;
	if (b2n_mod(right, right, g->p))
		goto fail;

	if (b2n_sqrt(p->y, right, g->p))	/* Find root */
		goto fail;
	if (b2n_mul(p->y, p->y, p->x))
		goto fail;
	if (b2n_mod(p->y, p->y, g->p))
		goto fail;

	b2n_clear(right);
	return 0;

fail:
	b2n_clear(right);
	return -1;
}

int
ec2np_add(ec2np_ptr d, ec2np_ptr a, ec2np_ptr b, ec2ng_ptr g)
{
	b2n_t	lambda, temp;
	ec2np_t	pn;

	/* Check for Neutral Element */
	if (b->inf)
		return ec2np_set(d, a);
	if (a->inf)
		return ec2np_set(d, b);

	if (!b2n_cmp(a->x, b->x) && (b2n_cmp(a->y, b->y) ||
	    !b2n_cmp_null(a->x))) {
		d->inf = 1;
		if (b2n_set_null(d->x))
			return -1;
		return b2n_set_null(d->y);
	}
	b2n_init(lambda);
	b2n_init(temp);
	ec2np_init(pn);

	if (b2n_cmp(a->x, b->x)) {
		if (b2n_add(temp, a->x, b->x))
			goto fail;
		if (b2n_add(lambda, a->y, b->y))
			goto fail;
		if (b2n_div_mod(lambda, lambda, temp, g->p))
			goto fail;

		if (b2n_square(pn->x, lambda))
			goto fail;
		if (b2n_mod(pn->x, pn->x, g->p))
			goto fail;

		if (b2n_add(pn->x, pn->x, lambda))
			goto fail;
		if (b2n_add(pn->x, pn->x, g->a))
			goto fail;
		if (b2n_add(pn->x, pn->x, a->x))
			goto fail;
		if (b2n_add(pn->x, pn->x, b->x))
			goto fail;
	} else {
		if (b2n_div_mod(lambda, b->y, b->x, g->p))
			goto fail;
		if (b2n_add(lambda, lambda, b->x))
			goto fail;

		if (b2n_square(pn->x, lambda))
			goto fail;
		if (b2n_mod(pn->x, pn->x, g->p))
			goto fail;
		if (b2n_add(pn->x, pn->x, lambda))
			goto fail;
		if (b2n_add(pn->x, pn->x, g->a))
			goto fail;
	}

	if (b2n_add(pn->y, b->x, pn->x))
		goto fail;

	if (b2n_mul(pn->y, pn->y, lambda))
		goto fail;
	if (b2n_mod(pn->y, pn->y, g->p))
		goto fail;

	if (b2n_add(pn->y, pn->y, pn->x))
		goto fail;
	if (b2n_add(pn->y, pn->y, b->y))
		goto fail;

	EC2NP_SWAP(d, pn);

	ec2np_clear(pn);
	b2n_clear(lambda);
	b2n_clear(temp);
	return 0;

fail:
	ec2np_clear(pn);
	b2n_clear(lambda);
	b2n_clear(temp);
	return -1;
}

int
ec2np_mul(ec2np_ptr d, ec2np_ptr a, b2n_ptr e, ec2ng_ptr g)
{
	int	i, j, bits, start;
	b2n_t	h, k;
	ec2np_t	q, mina;

	if (!b2n_cmp_null(e)) {
		d->inf = 1;
		if (b2n_set_null(d->x))
			return -1;
		return b2n_set_null(d->y);
	}
	b2n_init(h);
	b2n_init(k);
	ec2np_init(q);
	ec2np_init(mina);

	if (ec2np_set(q, a))
		goto fail;

	/* Create the point -a.  */
	if (ec2np_set(mina, a))
		goto fail;
	if (b2n_add(mina->y, mina->y, mina->x))
		goto fail;

	if (b2n_set(k, e))
		goto fail;
	if (b2n_3mul(h, k))
		goto fail;
	if (b2n_resize(k, h->chunks))
		goto fail;

	/*
	 * This is low level but can not be avoided, since we have to do single
	 * bit checks on h and k.
         */
	bits = b2n_sigbit(h);
	if ((bits & CHUNK_MASK) == 1) {
		start = ((CHUNK_MASK + bits) >> CHUNK_SHIFTS) - 2;
		bits = CHUNK_BITS;
	} else {
		start = ((CHUNK_MASK + bits) >> CHUNK_SHIFTS) - 1;
		bits = ((bits - 1) & CHUNK_MASK);
	}

	/*
	 * This is the addition, subtraction method which is faster because
	 * we avoid one out of three additions (mean).
         */
	for (i = start; i >= 0; i--)
		for (j = (i == start ? bits : CHUNK_BITS) - 1; j >= 0; j--)
			if (i > 0 || j > 0) {
				if (ec2np_add(q, q, q, g))
					goto fail;
				if ((h->limp[i] & b2n_mask[j]) && !(k->limp[i]
				    & b2n_mask[j])) {
					if (ec2np_add(q, q, a, g))
						goto fail;
				} else if (!(h->limp[i] & b2n_mask[j]) &&
				    (k->limp[i] & b2n_mask[j]))
					if (ec2np_add(q, q, mina, g))
						goto fail;
			}
	EC2NP_SWAP(d, q);

	b2n_clear(k);
	b2n_clear(h);
	ec2np_clear(q);
	ec2np_clear(mina);
	return 0;

fail:
	b2n_clear(k);
	b2n_clear(h);
	ec2np_clear(q);
	ec2np_clear(mina);
	return -1;
}
@


1.13
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: math_ec2n.c,v 1.12 2005/04/06 16:00:20 deraadt Exp $	 */
@


1.12
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: math_ec2n.c,v 1.11 2004/05/23 18:17:56 hshoexer Exp $	 */
a34 2

#include "sysdep.h"
@


1.11
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_ec2n.c,v 1.10 2004/04/15 18:39:26 deraadt Exp $	 */
d363 2
a364 2
				} else if (!(h->limp[i] & b2n_mask[j])
				    && (k->limp[i] & b2n_mask[j]))
@


1.10
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: math_ec2n.c,v 1.9 2003/06/03 14:28:16 ho Exp $	 */
d101 1
a101 1
	b2n_t           temp;
d137 2
a138 3
	int             res;

	b2n_t           x, y, temp;
d182 1
a182 1
	b2n_t           right;
d219 2
a220 2
	b2n_t           lambda, temp;
	ec2np_t         pn;
d228 2
a229 1
	if (!b2n_cmp(a->x, b->x) && (b2n_cmp(a->y, b->y) || !b2n_cmp_null(a->x))) {
d306 3
a308 3
	int             i, j, bits, start;
	b2n_t           h, k;
	ec2np_t         q, mina;
d359 2
a360 1
				if ((h->limp[i] & b2n_mask[j]) && !(k->limp[i] & b2n_mask[j])) {
d363 2
a364 1
				} else if (!(h->limp[i] & b2n_mask[j]) && (k->limp[i] & b2n_mask[j]))
@


1.9
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 2
a2 2
/*	$OpenBSD: math_ec2n.c,v 1.8 2002/06/09 08:13:06 todd Exp $	*/
/*	$EOM: math_ec2n.c,v 1.9 1999/04/20 09:23:31 niklas Exp $	*/
d42 1
a42 1
ec2np_init (ec2np_ptr n)
d44 3
a46 3
  b2n_init (n->x);
  b2n_init (n->y);
  n->inf = 0;
d50 1
a50 1
ec2np_clear (ec2np_ptr n)
d52 2
a53 2
  b2n_clear (n->x);
  b2n_clear (n->y);
d57 1
a57 1
ec2np_set (ec2np_ptr d, ec2np_ptr n)
d59 2
a60 2
  if (d == n)
    return 0;
d62 4
a65 4
  d->inf = n->inf;
  if (b2n_set (d->x, n->x))
    return -1;
  return b2n_set (d->y, n->y);
d71 1
a71 1
ec2ng_init (ec2ng_ptr n)
d73 3
a75 3
  b2n_init (n->a);
  b2n_init (n->b);
  b2n_init (n->p);
d79 1
a79 1
ec2ng_clear (ec2ng_ptr n)
d81 3
a83 3
  b2n_clear (n->a);
  b2n_clear (n->b);
  b2n_clear (n->p);
d87 1
a87 1
ec2ng_set (ec2ng_ptr d, ec2ng_ptr n)
d89 5
a93 5
  if (b2n_set (d->a, n->a))
    return -1;
  if (b2n_set (d->b, n->b))
    return -1;
  return b2n_set (d->p, n->p);
d99 1
a99 1
ec2np_right (b2n_ptr n, ec2np_ptr p, ec2ng_ptr g)
d101 1
a101 1
  b2n_t temp;
d103 1
a103 1
  b2n_init (temp);
d105 27
a131 27
  /* First calc x**3 + ax**2 + b */
  if (b2n_square (n, p->x))
    goto fail;
  if (b2n_mod (n, n, g->p))
    goto fail;

  if (b2n_mul (temp, g->a, n))	/* a*x**2 */
    goto fail;
  if (b2n_mod (temp, temp, g->p))
    goto fail;

  if (b2n_mul (n, n, p->x))	/* x**3 */
    goto fail;
  if (b2n_mod (n, n, g->p))
    goto fail;

  if (b2n_add (n, n, temp))
    goto fail;
  if (b2n_add (n, n, g->b))
    goto fail;

  b2n_clear (temp);
  return 0;

 fail:
  b2n_clear (temp);
  return -1;
d135 1
a135 1
ec2np_ison (ec2np_ptr p, ec2ng_ptr g)
d137 1
a137 1
  int res;
d139 1
a139 1
  b2n_t x, y, temp;
d141 2
a142 2
  if (p->inf)
    return 1;
d144 3
a146 3
  b2n_init (x);
  b2n_init (y);
  b2n_init (temp);
d148 3
a150 3
  /* First calc x**3 + ax**2 + b */
  if (ec2np_right (x, p, g))
    goto fail;
d152 5
a156 5
  /* Now calc y**2 + xy */
  if (b2n_square (y, p->y))
    goto fail;
  if (b2n_mod (y, y, g->p))
    goto fail;
d158 4
a161 4
  if (b2n_mul (temp, p->y, p->x))
    goto fail;
  if (b2n_mod (temp, temp, g->p))
    goto fail;
d163 2
a164 2
  if (b2n_add (y, y, temp))
    goto fail;
d166 1
a166 1
  res = !b2n_cmp (x, y);
d168 10
a177 10
  b2n_clear (x);
  b2n_clear (y);
  b2n_clear (temp);
  return res;

 fail:
  b2n_clear (x);
  b2n_clear (y);
  b2n_clear (temp);
  return -1;
d181 1
a181 1
ec2np_find_y (ec2np_ptr p, ec2ng_ptr g)
d183 13
a195 1
  b2n_t right;
d197 4
a200 1
  b2n_init (right);
d202 13
a214 28
  if (ec2np_right (right, p, g))		/* Right sight of equation */
    goto fail;
  if (b2n_mul_inv (p->y, p->x, g->p))
    goto fail;

  if (b2n_square (p->y, p->y))
    goto fail;
  if (b2n_mod (p->y, p->y, g->p))
    goto fail;

  if (b2n_mul (right, right, p->y))		/* x^-2 * right */
    goto fail;
  if (b2n_mod (right, right, g->p))
    goto fail;

  if (b2n_sqrt (p->y, right, g->p))		/* Find root */
    goto fail;
  if (b2n_mul (p->y, p->y, p->x))
    goto fail;
  if (b2n_mod (p->y, p->y, g->p))
    goto fail;

  b2n_clear (right);
  return 0;

 fail:
  b2n_clear (right);
  return -1;
d218 1
a218 1
ec2np_add (ec2np_ptr d, ec2np_ptr a, ec2np_ptr b, ec2ng_ptr g)
d220 68
a287 2
  b2n_t lambda, temp;
  ec2np_t pn;
d289 11
a299 10
  /* Check for Neutral Element */
  if (b->inf)
    return ec2np_set (d, a);
  if (a->inf)
    return ec2np_set (d, b);

  if (!b2n_cmp (a->x, b->x) && (b2n_cmp (a->y, b->y) || !b2n_cmp_null (a->x)))
    {
      d->inf = 1;
      if (b2n_set_null (d->x))
a300 72
      return b2n_set_null (d->y);
    }

  b2n_init (lambda);
  b2n_init (temp);
  ec2np_init (pn);

  if (b2n_cmp (a->x, b->x))
    {
      if (b2n_add (temp, a->x, b->x))
	goto fail;
      if (b2n_add (lambda, a->y, b->y))
	goto fail;
      if (b2n_div_mod (lambda, lambda, temp, g->p))
	goto fail;

      if (b2n_square (pn->x, lambda))
	goto fail;
      if (b2n_mod (pn->x, pn->x, g->p))
	goto fail;

      if (b2n_add (pn->x, pn->x, lambda))
	goto fail;
      if (b2n_add (pn->x, pn->x, g->a))
	goto fail;
      if (b2n_add (pn->x, pn->x, a->x))
	goto fail;
      if (b2n_add (pn->x, pn->x, b->x))
	goto fail;
    }
  else
    {
      if (b2n_div_mod (lambda, b->y, b->x, g->p))
	goto fail;
      if (b2n_add (lambda, lambda, b->x))
	goto fail;

      if (b2n_square (pn->x, lambda))
	goto fail;
      if (b2n_mod (pn->x, pn->x, g->p))
	goto fail;
      if (b2n_add (pn->x, pn->x, lambda))
	goto fail;
      if (b2n_add (pn->x, pn->x, g->a))
	goto fail;
    }

  if (b2n_add (pn->y, b->x, pn->x))
    goto fail;

  if (b2n_mul (pn->y, pn->y, lambda))
    goto fail;
  if (b2n_mod (pn->y, pn->y, g->p))
    goto fail;

  if (b2n_add (pn->y, pn->y, pn->x))
    goto fail;
  if (b2n_add (pn->y, pn->y, b->y))
    goto fail;

  EC2NP_SWAP (d, pn);

  ec2np_clear (pn);
  b2n_clear (lambda);
  b2n_clear (temp);
  return 0;

 fail:
  ec2np_clear (pn);
  b2n_clear (lambda);
  b2n_clear (temp);
  return -1;
d304 1
a304 1
ec2np_mul (ec2np_ptr d, ec2np_ptr a, b2n_ptr e, ec2ng_ptr g)
d306 30
a335 11
  int i, j, bits, start;
  b2n_t h, k;
  ec2np_t q, mina;

  if (!b2n_cmp_null (e))
    {
      d->inf = 1;
      if (b2n_set_null (d->x))
	return -1;
      return b2n_set_null (d->y);
    }
d337 11
a347 55
  b2n_init (h);
  b2n_init (k);
  ec2np_init (q);
  ec2np_init (mina);

  if (ec2np_set (q, a))
    goto fail;

  /* Create the point -a.  */
  if (ec2np_set (mina, a))
    goto fail;
  if (b2n_add (mina->y, mina->y, mina->x))
    goto fail;

  if (b2n_set (k, e))
    goto fail;
  if (b2n_3mul (h, k))
    goto fail;
  if (b2n_resize (k, h->chunks))
    goto fail;

  /*
   * This is low level but can not be avoided, since we have to do single
   * bit checks on h and k.
   */
  bits = b2n_sigbit (h);
  if ((bits & CHUNK_MASK) == 1)
    {
      start = ((CHUNK_MASK + bits) >> CHUNK_SHIFTS) - 2;
      bits = CHUNK_BITS;
    }
  else
    {
      start = ((CHUNK_MASK + bits) >> CHUNK_SHIFTS) - 1;
      bits = ((bits - 1) & CHUNK_MASK);
    }

  /*
   * This is the addition, subtraction method which is faster because
   * we avoid one out of three additions (mean).
   */
  for (i = start; i >= 0; i--)
    for (j = (i == start ? bits : CHUNK_BITS) - 1; j >= 0; j--)
      if (i > 0 || j > 0)
	{
	  if (ec2np_add (q, q, q, g))
	    goto fail;
	  if ((h->limp[i] & b2n_mask[j]) && !(k->limp[i] & b2n_mask[j]))
	    {
	      if (ec2np_add (q, q, a, g))
		goto fail;
	    }
	  else if (!(h->limp[i] & b2n_mask[j]) && (k->limp[i] & b2n_mask[j]))
	    if (ec2np_add (q, q, mina, g))
	      goto fail;
d350 30
a379 14
  EC2NP_SWAP (d, q);

  b2n_clear (k);
  b2n_clear (h);
  ec2np_clear (q);
  ec2np_clear (mina);
  return 0;

 fail:
  b2n_clear (k);
  b2n_clear (h);
  ec2np_clear (q);
  ec2np_clear (mina);
  return -1;
@


1.8
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: math_ec2n.c,v 1.7 1999/04/20 11:32:57 niklas Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@math_2n.c: Merge with EOM 1.15
math_ec2n.c: Merge with EOM 1.9

author: niklas
Plug potential memory leaks in case of memory allocation errors
@
text
@d1 1
a1 1
/*	$OpenBSD: math_ec2n.c,v 1.6 1999/04/19 21:22:49 niklas Exp $	*/
d145 1
a145 1
  
d349 1
a349 1
  /* 
d365 1
a365 1
  /* 
@


1.6
log
@./regress/x509/x509test.c: Merge with EOM 1.4
./dh.h: Merge with EOM 1.4
./math_ec2n.c: Merge with EOM 1.8
./crypto.c: Merge with EOM 1.25
./ike_quick_mode.c: Merge with EOM 1.82
./math_group.c: Merge with EOM 1.16
./math_ec2n.h: Merge with EOM 1.4

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.
@
text
@d1 2
a2 2
/*	$OpenBSD: math_ec2n.c,v 1.5 1999/04/05 21:01:41 niklas Exp $	*/
/*	$EOM: math_ec2n.c,v 1.8 1999/04/17 23:20:36 niklas Exp $	*/
d155 1
a155 1
    return -1;
d159 1
a159 1
    return -1;
d161 1
a161 1
    return -1;
d164 1
a164 1
    return -1;
d166 1
a166 1
    return -1;
d169 1
a169 1
    return -1;
d176 1
d178 5
a182 1
  return res;
d193 1
a193 1
    return -1;
d195 1
a195 1
    return -1;
d198 1
a198 1
    return -1;
d200 1
a200 1
    return -1;
d203 1
a203 1
    return -1;
d205 1
a205 1
    return -1;
d208 1
a208 1
    return -1;
d210 1
a210 1
    return -1;
d212 1
a212 1
    return -1;
d215 1
d217 3
a219 1
  return 0;
@


1.5
log
@Merge with EOM 1.7
Mem leak fix

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: math_ec2n.c,v 1.4 1999/02/26 03:46:40 niklas Exp $	*/
/*	$EOM: math_ec2n.c,v 1.7 1999/04/05 08:04:58 niklas Exp $	*/
d61 1
a61 1
void
d65 1
a65 1
    return;
d68 3
a70 2
  b2n_set (d->x, n->x);
  b2n_set (d->y, n->y);
d91 1
a91 1
void
d94 5
a98 3
  b2n_set (d->a, n->a);
  b2n_set (d->b, n->b);
  b2n_set (d->p, n->p);
d103 1
a103 1
void
d109 1
d111 19
a129 2
  b2n_square (n, p->x);
  b2n_mod (n, n, g->p);
d131 2
a132 8
  b2n_mul (temp, g->a, n);	/* a*x**2 */
  b2n_mod (temp, temp, g->p);

  b2n_mul (n, n, p->x);		/* x**3 */
  b2n_mod (n, n, g->p);

  b2n_add (n, n, temp);
  b2n_add (n, n, g->b);
d134 1
d136 1
d154 2
a155 1
  ec2np_right (x, p, g);
d158 9
a166 5
  b2n_square (y, p->y);
  b2n_mod (y, y, g->p);

  b2n_mul (temp, p->y, p->x);
  b2n_mod (temp, temp, g->p);
d168 2
a169 1
  b2n_add (y, y, temp);
a185 8
  ec2np_right (right, p, g);		/* Right sight of equation */
  b2n_mul_inv (p->y, p->x, g->p);

  b2n_square (p->y, p->y);
  b2n_mod (p->y, p->y, g->p);

  b2n_mul (right, right, p->y);		/* x^-2 * right */
  b2n_mod (right, right, g->p);
d187 21
a207 3
  b2n_sqrt (p->y, right, g->p);		/* Find root */
  b2n_mul (p->y, p->y, p->x);
  b2n_mod (p->y, p->y, g->p);
d211 1
a211 1
  return 1;
d214 1
a214 1
void
d222 1
a222 4
    {
      ec2np_set (d, a);
      return;
    }
d224 1
a224 4
    {
      ec2np_set (d, b);
      return;
    }
d229 3
a231 3
      b2n_set_null (d->x);
      b2n_set_null (d->y);
      return;
d240 20
a259 11
      b2n_add (temp, a->x, b->x);
      b2n_add (lambda, a->y, b->y);
      b2n_div_mod (lambda, lambda, temp, g->p);

      b2n_square (pn->x, lambda);
      b2n_mod (pn->x, pn->x, g->p);

      b2n_add (pn->x, pn->x, lambda);
      b2n_add (pn->x, pn->x, g->a);
      b2n_add (pn->x, pn->x, a->x);
      b2n_add (pn->x, pn->x, b->x);
d263 13
a275 7
      b2n_div_mod (lambda, b->y, b->x, g->p);
      b2n_add (lambda, lambda, b->x);

      b2n_square (pn->x, lambda);
      b2n_mod (pn->x, pn->x, g->p);
      b2n_add (pn->x, pn->x, lambda);
      b2n_add (pn->x, pn->x, g->a);
d278 2
a279 1
  b2n_add (pn->y, b->x, pn->x);
d281 9
a289 2
  b2n_mul (pn->y, pn->y, lambda);
  b2n_mod (pn->y, pn->y, g->p);
d291 1
a291 2
  b2n_add (pn->y, pn->y, pn->x);
  b2n_add (pn->y, pn->y, b->y);
d293 4
a296 1
  EC2NP_SWAP (d, pn);
d298 1
d302 1
d305 1
a305 1
void
d315 3
a317 3
      b2n_set_null (d->x);
      b2n_set_null (d->y);
      return;
a321 1

a323 1
  ec2np_set (q, a);
d325 15
a339 7
  /* Create the point -a */
  ec2np_set (mina, a);
  b2n_add (mina->y, mina->y, mina->x);

  b2n_set (k, e);
  b2n_3mul (h, k);
  b2n_resize (k, h->chunks);
a360 1

d365 2
a366 1
	  ec2np_add (q, q, q, g);
d368 4
a371 1
	    ec2np_add (q, q, a, g);
d373 2
a374 1
	    ec2np_add (q, q, mina, g);
d381 3
d385 3
d390 1
@


1.4
log
@Merge from the Ericsson repository
| revision 1.5
| date: 1999/02/25 11:39:13;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: math_ec2n.c,v 1.3 1998/11/17 11:10:16 niklas Exp $	*/
/*	$EOM: math_ec2n.c,v 1.5 1999/02/25 11:39:13 niklas Exp $	*/
d6 1
d175 2
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: math_ec2n.c,v 1.2 1998/11/15 00:44:00 niklas Exp $	*/
/*	$EOM: math_ec2n.c,v 1.4 1998/07/18 21:09:41 provos Exp $	*/
d39 2
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: math_ec2n.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: math_ec2n.c,v 1.4 1998/07/18 21:09:41 provos Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
