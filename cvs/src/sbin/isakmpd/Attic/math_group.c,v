head	1.33;
access;
symbols
	OPENBSD_4_7:1.32.0.14
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.16
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.12
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.10
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.8
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.13.0.6
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2010.06.29.19.50.16;	author reyk;	state dead;
branches;
next	1.32;

1.32
date	2006.07.24.11.45.44;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.05.09.29.35;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.05.00.19.21;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.04.14.37.51;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.08.20.04.57;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.08.19.19.39;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.08.16.18.59;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.15.10.06.42;	author hshoexer;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.14.14.49.08;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.12.18.34.42;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.06.02.15.27;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.09.22.09.52;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.07.22.04.44;	author niklas;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2000.02.25.17.23.41;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.19.19.32.54;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.07.13.15.46.43;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.06.02.06.30.13;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.05.06.22.45.00;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.04.19.21.22.49;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.04.05.20.59.37;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.03.46.57;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.17;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2001.05.08.12.45.24;	author ho;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Replace the hand-crafted Diffie-Hellman implementation in isakmpd with
the smaller implementation from iked that is using libcrypto instead.
This allows to remove a lot of code (which is always good), get rid of
some custom crypto code by using libcrypto, theoretically adds
support for many new MODP and EC2N/ECP modes (but it is not configurable
yet), and allows to share the dh.c/dh.h code in different codebases
(it is identical in isakmpd and iked, but could also be used elsewhere).

ok deraadt@@
@
text
@/* $OpenBSD: math_group.c,v 1.32 2006/07/24 11:45:44 ho Exp $	 */
/* $EOM: math_group.c,v 1.25 2000/04/07 19:53:26 niklas Exp $	 */

/*
 * Copyright (c) 1998 Niels Provos.  All rights reserved.
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/param.h>
#include <stdlib.h>
#include <string.h>

#include "log.h"
#include "math_2n.h"
#include "math_ec2n.h"
#include "math_group.h"
#include "math_mp.h"
#include "util.h"

/* We do not want to export these definitions.  */
int	modp_getlen(struct group *);
void	modp_getraw(struct group *, math_mp_t, u_int8_t *);
int	modp_setraw(struct group *, math_mp_t, u_int8_t *, int);
int	modp_setrandom(struct group *, math_mp_t);
int	modp_operation(struct group *, math_mp_t, math_mp_t, math_mp_t);
int	modp_validate_public(struct group *, math_mp_t);

int	ec2n_getlen(struct group *);
void	ec2n_getraw(struct group *, ec2np_ptr, u_int8_t *);
int	ec2n_setraw(struct group *, ec2np_ptr, u_int8_t *, int);
int	ec2n_setrandom(struct group *, ec2np_ptr);
int	ec2n_operation(struct group *, ec2np_ptr, ec2np_ptr, ec2np_ptr);
int	ec2n_validate_public(struct group *, ec2np_ptr);

struct ec2n_group {
	ec2np_t         gen;	/* Generator */
	ec2ng_t         grp;
	ec2np_t         a, b, c, d;
};

struct modp_group {
	math_mp_t       gen;	/* Generator */
	math_mp_t       p;	/* Prime */
	math_mp_t       a, b, c, d;
};

/*
 * This module provides access to the operations on the specified group
 * and is absolutely free of any cryptographic devices. This is math :-).
 */

#define OAKLEY_GRP_1	1
#define OAKLEY_GRP_2	2
#define OAKLEY_GRP_3	3
#define OAKLEY_GRP_4	4
#define OAKLEY_GRP_5	5
#define OAKLEY_GRP_6	6
#define OAKLEY_GRP_7	7
#define OAKLEY_GRP_8	8
#define OAKLEY_GRP_9	9
#define OAKLEY_GRP_10	10
#define OAKLEY_GRP_11	11
#define OAKLEY_GRP_12	12
#define OAKLEY_GRP_13	13
#define OAKLEY_GRP_14	14
#define OAKLEY_GRP_15	15
#define OAKLEY_GRP_16	16
#define OAKLEY_GRP_17	17
#define OAKLEY_GRP_18	18

/* Describe preconfigured MODP groups */

/*
 * The Generalized Number Field Sieve has an asymptotic running time
 * of: O(exp(1.9223 * (ln q)^(1/3) (ln ln q)^(2/3))), where q is the
 * group order, e.g. q = 2**768.
 */

struct modp_dscr oakley_modp[] =
{
	{OAKLEY_GRP_1, 72,	/* This group is insecure, only sufficient
				 * for DES */
		"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
		"29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
		"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
		"E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF",
		"0x02"
	},
	{OAKLEY_GRP_2, 82,	/* This group is a bit better */
		"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
		"29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
		"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
		"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
		"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381"
		"FFFFFFFFFFFFFFFF",
		"0x02"
	},
	{OAKLEY_GRP_5, 102,
		"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
		"29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
		"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
		"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
		"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
		"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
		"83655D23DCA3AD961C62F356208552BB9ED529077096966D"
		"670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF",
		"0x02"
	},
	{OAKLEY_GRP_14, 135,	/* 2048 bit */
		"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
		"29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
		"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
		"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
		"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
		"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
		"83655D23DCA3AD961C62F356208552BB9ED529077096966D"
		"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
		"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
		"DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
		"15728E5A8AACAA68FFFFFFFFFFFFFFFF",
		"0x02"
	},
	{OAKLEY_GRP_15, 170,	/* 3072 bit */
		"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
		"29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
		"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
		"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
		"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
		"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
		"83655D23DCA3AD961C62F356208552BB9ED529077096966D"
		"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
		"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
		"DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
		"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
		"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
		"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
		"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
		"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
		"43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF",
		"0x02"
	},
	{OAKLEY_GRP_16, 195,	/* 4096 bit */
		"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
		"29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
		"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
		"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
		"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
		"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
		"83655D23DCA3AD961C62F356208552BB9ED529077096966D"
		"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
		"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
		"DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
		"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
		"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
		"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
		"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
		"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
		"43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7"
		"88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA"
		"2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6"
		"287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED"
		"1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"
		"93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199"
		"FFFFFFFFFFFFFFFF",
		"0x02"
	},
	{OAKLEY_GRP_17, 220,	/* 6144 bit */
		"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
		"29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
		"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
		"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
		"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
		"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
		"83655D23DCA3AD961C62F356208552BB9ED529077096966D"
		"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
		"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
		"DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
		"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
		"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
		"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
		"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
		"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
		"43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7"
		"88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA"
		"2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6"
		"287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED"
		"1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"
		"93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"
		"36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BD"
		"F8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831"
		"179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1B"
		"DB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF"
		"5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6"
		"D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F3"
		"23A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"
		"CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE328"
		"06A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55C"
		"DA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE"
		"12BF2D5B0B7474D6E694F91E6DCC4024FFFFFFFFFFFFFFFF",
		"0x02"
	},
	{OAKLEY_GRP_18, 250,	/* 8192 bit */
		"0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
		"29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
		"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
		"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
		"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
		"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
		"83655D23DCA3AD961C62F356208552BB9ED529077096966D"
		"670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
		"E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
		"DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
		"15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
		"ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
		"ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
		"F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
		"BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
		"43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7"
		"88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA"
		"2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6"
		"287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED"
		"1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"
		"93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"
		"36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BD"
		"F8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831"
		"179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1B"
		"DB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF"
		"5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6"
		"D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F3"
		"23A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"
		"CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE328"
		"06A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55C"
		"DA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE"
		"12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E4"
		"38777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300"
		"741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F568"
		"3423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD9"
		"22222E04A4037C0713EB57A81A23F0C73473FC646CEA306B"
		"4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A"
		"062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A36"
		"4597E899A0255DC164F31CC50846851DF9AB48195DED7EA1"
		"B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F92"
		"4009438B481C6CD7889A002ED5EE382BC9190DA6FC026E47"
		"9558E4475677E9AA9E3050E2765694DFC81F56E880B96E71"
		"60C980DD98EDD3DFFFFFFFFFFFFFFFFF",
		"0x02"
	},
};

/* Describe preconfigured EC2N groups */

/*
 * Related collision-search methods can compute discrete logarithms
 * in O(sqrt(r)), r being the subgroup order.
 */

struct ec2n_dscr oakley_ec2n[] = {
	{ OAKLEY_GRP_3, 76,	/* This group is also considered insecure
				 * (P1363) */
	"0x0800000000000000000000004000000000000001",
	"0x7b",
	"0x00",
	"0x7338f" },
	{ OAKLEY_GRP_4, 91,
	"0x020000000000000000000000000000200000000000000001",
	"0x18",
	"0x00",
	"0x1ee9" },
};

/* XXX I want to get rid of the casting here.  */
struct group    groups[] = {
	{
		MODP, OAKLEY_GRP_1, 0, &oakley_modp[0], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) modp_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) modp_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) modp_setraw,
		(int (*) (struct group *, void *)) modp_setrandom,
		(int (*) (struct group *, void *, void *, void *)) modp_operation,
		(int (*) (struct group *, void *)) modp_validate_public
	},
	{
		MODP, OAKLEY_GRP_2, 0, &oakley_modp[1], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) modp_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) modp_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) modp_setraw,
		(int (*) (struct group *, void *)) modp_setrandom,
		(int (*) (struct group *, void *, void *, void *)) modp_operation,
		(int (*) (struct group *, void *)) modp_validate_public
	},
	{
		EC2N, OAKLEY_GRP_3, 0, &oakley_ec2n[0], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) ec2n_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) ec2n_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) ec2n_setraw,
		(int (*) (struct group *, void *)) ec2n_setrandom,
		(int (*) (struct group *, void *, void *, void *)) ec2n_operation,
		(int (*) (struct group *, void *)) ec2n_validate_public
	},
	{
		EC2N, OAKLEY_GRP_4, 0, &oakley_ec2n[1], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) ec2n_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) ec2n_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) ec2n_setraw,
		(int (*) (struct group *, void *)) ec2n_setrandom,
		(int (*) (struct group *, void *, void *, void *)) ec2n_operation,
		(int (*) (struct group *, void *)) ec2n_validate_public
	},
	{
		MODP, OAKLEY_GRP_5, 0, &oakley_modp[2], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) modp_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) modp_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) modp_setraw,
		(int (*) (struct group *, void *)) modp_setrandom,
		(int (*) (struct group *, void *, void *, void *)) modp_operation,
		(int (*) (struct group *, void *)) modp_validate_public
	},
	/* XXX Higher EC2N group go here... */
	/* XXX group 6 to 13 are not yet defined (draft-ike-ecc) */
	{
		NOTYET, OAKLEY_GRP_6, 0, NULL, 0, 0, 0, 0, 0,
		NULL, NULL, NULL, NULL, NULL
	},
	{
		NOTYET, OAKLEY_GRP_7, 0, NULL, 0, 0, 0, 0, 0,
		NULL, NULL, NULL, NULL, NULL
	},
	{
		NOTYET, OAKLEY_GRP_8, 0, NULL, 0, 0, 0, 0, 0,
		NULL, NULL, NULL, NULL, NULL
	},
	{
		NOTYET, OAKLEY_GRP_9, 0, NULL, 0, 0, 0, 0, 0,
		NULL, NULL, NULL, NULL, NULL
	},
	{
		NOTYET, OAKLEY_GRP_10, 0, NULL, 0, 0, 0, 0, 0,
		NULL, NULL, NULL, NULL, NULL
	},
	{
		NOTYET, OAKLEY_GRP_11, 0, NULL, 0, 0, 0, 0, 0,
		NULL, NULL, NULL, NULL, NULL
	},
	{
		NOTYET, OAKLEY_GRP_12, 0, NULL, 0, 0, 0, 0, 0,
		NULL, NULL, NULL, NULL, NULL
	},
	{
		NOTYET, OAKLEY_GRP_13, 0, NULL, 0, 0, 0, 0, 0,
		NULL, NULL, NULL, NULL, NULL
	},
	{
		MODP, OAKLEY_GRP_14, 0, &oakley_modp[3], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) modp_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) modp_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) modp_setraw,
		(int (*) (struct group *, void *)) modp_setrandom,
		(int (*) (struct group *, void *, void *, void *)) modp_operation,
		(int (*) (struct group *, void *)) modp_validate_public
	},
	{
		MODP, OAKLEY_GRP_15, 0, &oakley_modp[4], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) modp_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) modp_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) modp_setraw,
		(int (*) (struct group *, void *)) modp_setrandom,
		(int (*) (struct group *, void *, void *, void *)) modp_operation,
		(int (*) (struct group *, void *)) modp_validate_public
	},
	{
		MODP, OAKLEY_GRP_16, 0, &oakley_modp[5], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) modp_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) modp_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) modp_setraw,
		(int (*) (struct group *, void *)) modp_setrandom,
		(int (*) (struct group *, void *, void *, void *)) modp_operation,
		(int (*) (struct group *, void *)) modp_validate_public
	},
	{
		MODP, OAKLEY_GRP_17, 0, &oakley_modp[6], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) modp_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) modp_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) modp_setraw,
		(int (*) (struct group *, void *)) modp_setrandom,
		(int (*) (struct group *, void *, void *, void *)) modp_operation,
		(int (*) (struct group *, void *)) modp_validate_public
	},
	{
		MODP, OAKLEY_GRP_18, 0, &oakley_modp[7], 0, 0, 0, 0, 0,
		(int (*) (struct group *)) modp_getlen,
		(void (*) (struct group *, void *, u_int8_t *)) modp_getraw,
		(int (*) (struct group *, void *, u_int8_t *, int)) modp_setraw,
		(int (*) (struct group *, void *)) modp_setrandom,
		(int (*) (struct group *, void *, void *, void *)) modp_operation,
		(int (*) (struct group *, void *)) modp_validate_public
	},
};

/*
 * Initialize the group structure for later use,
 * this is done by converting the values given in the description
 * and converting them to their native representation.
 */
void
group_init(void)
{
	int	i;

	for (i = sizeof(groups) / sizeof(groups[0]) - 1; i >= 0; i--)
		switch (groups[i].type) {
		case EC2N:  /* Initialize an Elliptic Curve over GF(2**n) */
			ec2n_init(&groups[i]);
			break;

		case MODP:	/* Initialize an over GF(p) */
			modp_init(&groups[i]);
			break;

		case NOTYET:	/* Not yet assigned, drop silently */
			break;

		default:
			log_print("Unknown group type %d at index %d in "
			    "group_init().", groups[i].type, i);
			break;
		}
}

struct group *
group_get(u_int32_t id)
{
	struct group   *new, *clone;

	if (id < 1 || id > (sizeof(groups) / sizeof(groups[0]))) {
		log_print("group_get: group ID (%u) out of range", id);
		return 0;
	}
	clone = &groups[id - 1];

	new = malloc(sizeof *new);
	if (!new) {
		log_error("group_get: malloc (%lu) failed",
		    (unsigned long)sizeof *new);
		return 0;
	}
	switch (clone->type) {
	case EC2N:
		new = ec2n_clone(new, clone);
		break;
	case MODP:
		new = modp_clone(new, clone);
		break;
	default:
		log_print("group_get: unknown group type %d", clone->type);
		free(new);
		return 0;
	}
	LOG_DBG((LOG_MISC, 70, "group_get: returning %p of group %d", new,
		 new->id));
	return new;
}

void
group_free(struct group *grp)
{
	switch (grp->type) {
		case EC2N:
		ec2n_free(grp);
		break;
	case MODP:
		modp_free(grp);
		break;
	default:
		log_print("group_free: unknown group type %d", grp->type);
		break;
	}
	free(grp);
}

struct group *
modp_clone(struct group *new, struct group *clone)
{
	struct modp_group *new_grp, *clone_grp = clone->group;

	new_grp = malloc(sizeof *new_grp);
	if (!new_grp) {
		log_print("modp_clone: malloc (%lu) failed",
		    (unsigned long)sizeof *new_grp);
		free(new);
		return 0;
	}
	memcpy(new, clone, sizeof(struct group));

	new->group = new_grp;
	new_grp->p = BN_dup(clone_grp->p);
	new_grp->gen = BN_dup(clone_grp->gen);

	new_grp->a = BN_new();
	new_grp->b = BN_new();
	new_grp->c = BN_new();

	new->gen = new_grp->gen;
	new->a = new_grp->a;
	new->b = new_grp->b;
	new->c = new_grp->c;

	return new;
}

void
modp_free(struct group *old)
{
	struct modp_group *grp = old->group;

	BN_clear_free(grp->p);
	BN_clear_free(grp->gen);
	BN_clear_free(grp->a);
	BN_clear_free(grp->b);
	BN_clear_free(grp->c);

	free(grp);
}

void
modp_init(struct group *group)
{
	struct modp_dscr *dscr = (struct modp_dscr *)group->group;
	struct modp_group *grp;

	grp = malloc(sizeof *grp);
	if (!grp)
		log_fatal("modp_init: malloc (%lu) failed",
		    (unsigned long)sizeof *grp);

	group->bits = dscr->bits;

	grp->p = BN_new();
	BN_hex2bn(&grp->p, dscr->prime + 2);
	grp->gen = BN_new();
	BN_hex2bn(&grp->gen, dscr->gen + 2);

	grp->a = BN_new();
	grp->b = BN_new();
	grp->c = BN_new();

	group->gen = grp->gen;
	group->a = grp->a;
	group->b = grp->b;
	group->c = grp->c;

	group->group = grp;
}

struct group *
ec2n_clone(struct group *new, struct group *clone)
{
	struct ec2n_group *new_grp, *clone_grp = clone->group;

	new_grp = malloc(sizeof *new_grp);
	if (!new_grp) {
		log_error("ec2n_clone: malloc (%lu) failed",
		    (unsigned long)sizeof *new_grp);
		free(new);
		return 0;
	}
	memcpy(new, clone, sizeof(struct group));

	new->group = new_grp;
	ec2ng_init(new_grp->grp);
	ec2np_init(new_grp->gen);
	ec2np_init(new_grp->a);
	ec2np_init(new_grp->b);
	ec2np_init(new_grp->c);

	if (ec2ng_set(new_grp->grp, clone_grp->grp))
		goto fail;
	if (ec2np_set(new_grp->gen, clone_grp->gen))
		goto fail;

	new->gen = new_grp->gen;
	new->a = new_grp->a;
	new->b = new_grp->b;
	new->c = new_grp->c;
	new->d = ((ec2np_ptr) new->a)->x;

	return new;

fail:
	ec2ng_clear(new_grp->grp);
	ec2np_clear(new_grp->gen);
	ec2np_clear(new_grp->a);
	ec2np_clear(new_grp->b);
	ec2np_clear(new_grp->c);
	free(new_grp);
	free(new);
	return 0;
}

void
ec2n_free(struct group *old)
{
	struct ec2n_group *grp = old->group;

	ec2ng_clear(grp->grp);
	ec2np_clear(grp->gen);
	ec2np_clear(grp->a);
	ec2np_clear(grp->b);
	ec2np_clear(grp->c);

	free(grp);
}

void
ec2n_init(struct group *group)
{
	struct ec2n_dscr *dscr = (struct ec2n_dscr *)group->group;
	struct ec2n_group *grp;

	grp = malloc(sizeof *grp);
	if (!grp)
		log_fatal("ec2n_init: malloc (%lu) failed",
		    (unsigned long)sizeof *grp);

	group->bits = dscr->bits;

	ec2ng_init(grp->grp);
	ec2np_init(grp->gen);
	ec2np_init(grp->a);
	ec2np_init(grp->b);
	ec2np_init(grp->c);

	if (ec2ng_set_p_str(grp->grp, dscr->polynomial))
		goto fail;
	grp->grp->p->bits = b2n_sigbit(grp->grp->p);
	if (ec2ng_set_a_str(grp->grp, dscr->a))
		goto fail;
	if (ec2ng_set_b_str(grp->grp, dscr->b))
		goto fail;

	if (ec2np_set_x_str(grp->gen, dscr->gen_x))
		goto fail;
	if (ec2np_find_y(grp->gen, grp->grp))
		goto fail;

	/* Sanity check */
	if (!ec2np_ison(grp->gen, grp->grp))
		log_fatal("ec2n_init: generator is not on curve");

	group->gen = grp->gen;
	group->a = grp->a;
	group->b = grp->b;
	group->c = grp->c;
	group->d = ((ec2np_ptr) group->a)->x;

	group->group = grp;
	return;

fail:
	log_fatal("ec2n_init: general failure");
}

int
modp_getlen(struct group *group)
{
	struct modp_group *grp = (struct modp_group *)group->group;

	return BN_num_bytes(grp->p);
}

void
modp_getraw(struct group *grp, math_mp_t v, u_int8_t *d)
{
	math_mp_t       a;
	int		len;

	len = grp->getlen(grp);

	/* XXX bn2bin?  */
	a = BN_dup(v);

	while (len-- > 0)
		d[len] = BN_div_word(a, 256);

	BN_clear_free(a);
}

int
modp_setraw(struct group *group, math_mp_t d, u_int8_t *s, int l)
{
	if (BN_bin2bn(s, l, d) == NULL)
		return -1;

	return 0;
}

int
modp_setrandom(struct group *grp, math_mp_t d)
{
	int             i, l = grp->getlen(grp);
	u_int32_t       tmp = 0;

	BN_set_word(d, 0);

	for (i = 0; i < l; i++) {
		if (i % 4)
			tmp = rand_32();

		BN_lshift(d, d, 8);
		BN_add_word(d, tmp & 0xFF);
		tmp >>= 8;
	}
	return 0;
}

int
modp_operation(struct group *group, math_mp_t d, math_mp_t a, math_mp_t e)
{
	struct modp_group *grp = (struct modp_group *)group->group;

	BN_CTX         *ctx = BN_CTX_new();
	BN_mod_exp(d, a, e, grp->p, ctx);
	BN_CTX_free(ctx);
	return 0;
}

int
modp_validate_public(struct group *group, math_mp_t pub_exp)
{
	struct modp_group *grp = (struct modp_group *)group->group;
	int i, len, bits_set;
	math_mp_t tmp;

	/*
	 * Sanity checks from RFC2412 section 2.3.1.1:
	 * Ensure that peer does not send us <0, 0, 1, p-1 or >= p
	 */
	if (BN_cmp(pub_exp, BN_value_one()) != 1)	/* pub_exp <= 1 */
		return -1;
	if ((tmp = BN_new()) == NULL)
		return -1;
	if (!BN_sub(tmp, grp->p, BN_value_one()) ||
	    BN_cmp(pub_exp, tmp) != -1) {		/* pub_exp > p-2 */
		BN_clear_free(tmp);
		return -1;
	}
	BN_clear_free(tmp);

	/*
	 * Another sanity check: when the generator is 2 and the
	 * population count of the public exponent is 1, then 
	 * computing log_g(pub_exp) is trivial.
	 */
	len = BN_num_bits(pub_exp);
	for (bits_set = i = 0; i < len; i++) {
		if (BN_is_bit_set(pub_exp, i))
			bits_set++;
	}
	if (bits_set <= 1)
		return -1;

	return 0;
}

int
ec2n_getlen(struct group *group)
{
	struct ec2n_group *grp = (struct ec2n_group *)group->group;
	int		bits = b2n_sigbit(grp->grp->p) - 1;

	return (7 + bits) >> 3;
}

void
ec2n_getraw(struct group *group, ec2np_ptr xo, u_int8_t *e)
{
	struct ec2n_group *grp = (struct ec2n_group *) group->group;
	int             chunks, bytes, i, j;
	b2n_ptr         x = xo->x;
	CHUNK_TYPE      tmp;

	bytes = b2n_sigbit(grp->grp->p) - 1;
	chunks = (CHUNK_MASK + bytes) >> CHUNK_SHIFTS;
	bytes = ((7 + (bytes & CHUNK_MASK)) >> 3);

	for (i = chunks - 1; i >= 0; i--) {
		tmp = (i >= x->chunks ? 0 : x->limp[i]);
		for (j = (i == chunks - 1 ? bytes : CHUNK_BYTES) - 1; j >= 0;
		    j--) {
			e[j] = tmp & 0xff;
			tmp >>= 8;
		}
		e += (i == chunks - 1 ? bytes : CHUNK_BYTES);
	}
}

int
ec2n_setraw(struct group *grp, ec2np_ptr out, u_int8_t *s, int l)
{
	int             len, bytes, i, j;
	b2n_ptr         outx = out->x;
	CHUNK_TYPE      tmp;

	len = (CHUNK_BYTES - 1 + l) / CHUNK_BYTES;
	if (b2n_resize(outx, len))
		return -1;

	bytes = ((l - 1) % CHUNK_BYTES) + 1;

	for (i = len - 1; i >= 0; i--) {
		tmp = 0;
		for (j = (i == len - 1 ? bytes : CHUNK_BYTES); j > 0; j--) {
			tmp <<= 8;
			tmp |= *s++;
		}
		outx->limp[i] = tmp;
	}
	return 0;
}

int
ec2n_setrandom(struct group *group, ec2np_ptr x)
{
	b2n_ptr         d = x->x;
	struct ec2n_group *grp = (struct ec2n_group *) group->group;

	return b2n_random(d, b2n_sigbit(grp->grp->p) - 1);
}

/*
 * This is an attempt at operation abstraction. It can happen
 * that we need to initialize the y variable for the operation
 * to proceed correctly. When this is the case operation has
 * to supply the variable 'a' with the chunks of the Y coordinate
 * set to zero.
 */
int
ec2n_operation(struct group *grp, ec2np_ptr d, ec2np_ptr a, ec2np_ptr e)
{
	b2n_ptr         ex = e->x;
	struct ec2n_group *group = (struct ec2n_group *)grp->group;

	if (a->y->chunks == 0)
		if (ec2np_find_y(a, group->grp))
			return -1;

	return ec2np_mul(d, a, ex, group->grp);
}

int
ec2n_validate_public(struct group *grp, ec2np_ptr p)
{
	/* XXX: needs similar checks to modp_validate_public() */
	return 0;
}
@


1.32
log
@Style; return is not a function. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.31 2006/06/02 19:35:55 hshoexer Exp $	 */
@


1.31
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.30 2006/05/05 09:29:35 djm Exp $	 */
d715 1
a715 1
		return (-1);
d762 1
a762 1
		return (-1);
d764 1
a764 1
		return (-1);
d768 1
a768 1
		return (-1);
d783 1
a783 1
		return (-1);
d785 1
a785 1
	return (0);
d877 1
a877 1
	return (0);
@


1.30
log
@correct correct rfc reference
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.29 2006/05/05 00:19:21 djm Exp $	 */
d73 1
a73 1
 * and is absolutly free of any cryptographic devices. This is math :-).
d277 1
a277 1
 * Related collision-search methods can compute discrete logarithmns
d425 1
a425 1
 * this is done by converting the values given in the describtion
d857 1
a857 1
 * to supply the variable 'a' with the chunks of the Y cooridnate
@


1.29
log
@correct rfc reference
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.28 2006/05/04 14:37:51 djm Exp $	 */
d758 1
a758 1
	 * Sanity checks from RFC2409 section 2.3.1.1:
@


1.28
log
@check for degenerate Diffie-Hellman public exponents;
ok markus@@ hshoexer@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.27 2005/04/08 22:32:10 cloder Exp $	 */
d758 1
a758 1
	 * Sanity checks from RFC2142 section 2.3.1.1:
@


1.27
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.26 2005/04/08 20:04:57 hshoexer Exp $	 */
d50 1
d57 1
d303 2
a304 1
		(int (*) (struct group *, void *, void *, void *)) modp_operation
d312 2
a313 1
		(int (*) (struct group *, void *, void *, void *)) modp_operation
d321 2
a322 1
		(int (*) (struct group *, void *, void *, void *)) ec2n_operation
d330 2
a331 1
		(int (*) (struct group *, void *, void *, void *)) ec2n_operation
d339 2
a340 1
		(int (*) (struct group *, void *, void *, void *)) modp_operation
d382 2
a383 1
		(int (*) (struct group *, void *, void *, void *)) modp_operation
d391 2
a392 1
		(int (*) (struct group *, void *, void *, void *)) modp_operation
d400 2
a401 1
		(int (*) (struct group *, void *, void *, void *)) modp_operation
d409 2
a410 1
		(int (*) (struct group *, void *, void *, void *)) modp_operation
d418 2
a419 1
		(int (*) (struct group *, void *, void *, void *)) modp_operation
d712 1
a712 1
modp_setraw(struct group *grp, math_mp_t d, u_int8_t *s, int l)
d714 2
a715 1
        u_int32_t       i;
a716 6
	/* XXX bin2bn?  */
	BN_set_word(d, 0);
	for (i = 0; i < l; i++) {
		BN_mul_word(d, 256);
		BN_add_word(d, s[i]);
	}
d751 38
d871 7
@


1.26
log
@kill gmp
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.25 2005/04/08 19:19:39 hshoexer Exp $	 */
a36 2
#include "sysdep.h"

d42 1
d723 1
a723 1
			tmp = sysdep_random();
@


1.25
log
@remove gmp, no binary change
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.24 2005/04/08 16:18:59 deraadt Exp $	 */
a38 1
#include "gmp_util.h"
d680 1
a680 1
	return mpz_sizeinoctets(grp->p);
d686 12
a697 1
	mpz_getraw(d, v, grp->getlen(grp));
d703 8
a710 1
	mpz_setraw(d, s, l);
@


1.24
log
@kill USE_EC
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.23 2004/06/14 09:55:41 ho Exp $	 */
a508 8
#if MP_FLAVOUR == MP_FLAVOUR_GMP
	mpz_init_set(new_grp->p, clone_grp->p);
	mpz_init_set(new_grp->gen, clone_grp->gen);

	mpz_init(new_grp->a);
	mpz_init(new_grp->b);
	mpz_init(new_grp->c);
#elif MP_FLAVOUR == MP_FLAVOUR_OPENSSL
a514 1
#endif
a528 7
#if MP_FLAVOUR == MP_FLAVOUR_GMP
	mpz_clear(grp->p);
	mpz_clear(grp->gen);
	mpz_clear(grp->a);
	mpz_clear(grp->b);
	mpz_clear(grp->c);
#elif MP_FLAVOUR == MP_FLAVOUR_OPENSSL
a533 1
#endif
a550 8
#if MP_FLAVOUR == MP_FLAVOUR_GMP
	mpz_init_set_str(grp->p, dscr->prime, 0);
	mpz_init_set_str(grp->gen, dscr->gen, 0);

	mpz_init(grp->a);
	mpz_init(grp->b);
	mpz_init(grp->c);
#elif MP_FLAVOUR == MP_FLAVOUR_OPENSSL
a558 1
#endif
a702 3
#if MP_FLAVOUR == MP_FLAVOUR_GMP
	mpz_set_ui(d, 0);
#elif MP_FLAVOUR == MP_FLAVOUR_OPENSSL
a703 1
#endif
a708 4
#if MP_FLAVOUR == MP_FLAVOUR_GMP
		mpz_mul_2exp(d, d, 8);
		mpz_add_ui(d, d, tmp & 0xFF);
#elif MP_FLAVOUR == MP_FLAVOUR_OPENSSL
a710 1
#endif
a720 3
#if MP_FLAVOUR == MP_FLAVOUR_GMP
	mpz_powm(d, a, e, grp->p);
#elif MP_FLAVOUR == MP_FLAVOUR_OPENSSL
a723 1
#endif
@


1.23
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.22 2004/05/23 18:17:56 hshoexer Exp $	 */
a273 1
#ifdef USE_EC
a293 1
#endif				/* USE_EC */
a312 1
#ifdef USE_EC
a328 1
#endif				/* USE_EC */
a336 1
#ifdef USE_EC
a337 1
#endif				/* USE_EC */
a424 1
#ifdef USE_EC
a427 1
#endif
a460 1
#ifdef USE_EC
a463 1
#endif
a480 1
#ifdef USE_EC
a483 1
#endif
a593 1
#ifdef USE_EC
a700 1
#endif				/* USE_EC */
a765 1
#ifdef USE_EC
a849 1
#endif				/* USE_EC */
@


1.22
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.21 2004/04/15 18:39:26 deraadt Exp $	 */
d432 1
a432 1
		case EC2N:	/* Initialize an Elliptic Curve over GF(2**n) */
@


1.21
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: math_group.c,v 1.20 2004/04/07 22:45:49 ho Exp $	 */
d47 11
a57 11
int             modp_getlen(struct group *);
void            modp_getraw(struct group *, math_mp_t, u_int8_t *);
int             modp_setraw(struct group *, math_mp_t, u_int8_t *, int);
int             modp_setrandom(struct group *, math_mp_t);
int             modp_operation(struct group *, math_mp_t, math_mp_t, math_mp_t);

int             ec2n_getlen(struct group *);
void            ec2n_getraw(struct group *, ec2np_ptr, u_int8_t *);
int             ec2n_setraw(struct group *, ec2np_ptr, u_int8_t *, int);
int             ec2n_setrandom(struct group *, ec2np_ptr);
int             ec2n_operation(struct group *, ec2np_ptr, ec2np_ptr, ec2np_ptr);
d283 1
a283 1
	{OAKLEY_GRP_3, 76,	/* This group is also considered insecure
d285 9
a293 9
		"0x0800000000000000000000004000000000000001",
		"0x7b",
		"0x00",
	"0x7338f"},
	{OAKLEY_GRP_4, 91,
		"0x020000000000000000000000000000200000000000000001",
		"0x18",
		"0x00",
	"0x1ee9"},
d427 1
a427 1
	int             i;
d445 2
a446 2
			log_print("Unknown group type %d at index %d in group_init().",
				  groups[i].type, i);
d451 1
a451 1
struct group   *
d464 2
a465 1
		log_error("group_get: malloc (%lu) failed", (unsigned long) sizeof *new);
d488 1
a488 1
group_free(struct group * grp)
d506 2
a507 2
struct group   *
modp_clone(struct group * new, struct group * clone)
d514 1
a514 1
			  (unsigned long) sizeof *new_grp);
d546 1
a546 1
modp_free(struct group * old)
d568 1
a568 1
modp_init(struct group * group)
d570 1
a570 1
	struct modp_dscr *dscr = (struct modp_dscr *) group->group;
d575 2
a576 1
		log_fatal("modp_init: malloc (%lu) failed", (unsigned long) sizeof *grp);
d607 2
a608 2
struct group   *
ec2n_clone(struct group * new, struct group * clone)
d615 1
a615 1
			  (unsigned long) sizeof *new_grp);
d653 1
a653 1
ec2n_free(struct group * old)
d667 1
a667 1
ec2n_init(struct group * group)
d669 1
a669 1
	struct ec2n_dscr *dscr = (struct ec2n_dscr *) group->group;
d674 2
a675 1
		log_fatal("ec2n_init: malloc (%lu) failed", (unsigned long) sizeof *grp);
d717 1
a717 1
modp_getlen(struct group * group)
d719 1
a719 1
	struct modp_group *grp = (struct modp_group *) group->group;
d725 1
a725 1
modp_getraw(struct group * grp, math_mp_t v, u_int8_t * d)
d731 1
a731 1
modp_setraw(struct group * grp, math_mp_t d, u_int8_t * s, int l)
d738 1
a738 1
modp_setrandom(struct group * grp, math_mp_t d)
d766 1
a766 1
modp_operation(struct group * group, math_mp_t d, math_mp_t a, math_mp_t e)
d768 1
a768 1
	struct modp_group *grp = (struct modp_group *) group->group;
d782 1
a782 1
ec2n_getlen(struct group * group)
d784 2
a785 2
	struct ec2n_group *grp = (struct ec2n_group *) group->group;
	int             bits = b2n_sigbit(grp->grp->p) - 1;
d791 1
a791 1
ec2n_getraw(struct group * group, ec2np_ptr xo, u_int8_t * e)
d804 2
a805 1
		for (j = (i == chunks - 1 ? bytes : CHUNK_BYTES) - 1; j >= 0; j--) {
d814 1
a814 1
ec2n_setraw(struct group * grp, ec2np_ptr out, u_int8_t * s, int l)
d838 1
a838 1
ec2n_setrandom(struct group * group, ec2np_ptr x)
d854 1
a854 1
ec2n_operation(struct group * grp, ec2np_ptr d, ec2np_ptr a, ec2np_ptr e)
d857 1
a857 1
	struct ec2n_group *group = (struct ec2n_group *) grp->group;
@


1.20
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.19 2003/12/15 10:06:42 hshoexer Exp $	*/
/*	$EOM: math_group.c,v 1.25 2000/04/07 19:53:26 niklas Exp $	*/
d47 11
a57 11
int modp_getlen (struct group *);
void modp_getraw (struct group *, math_mp_t, u_int8_t *);
int modp_setraw (struct group *, math_mp_t, u_int8_t *, int);
int modp_setrandom (struct group *, math_mp_t);
int modp_operation (struct group *, math_mp_t, math_mp_t, math_mp_t);

int ec2n_getlen (struct group *);
void ec2n_getraw (struct group *, ec2np_ptr, u_int8_t *);
int ec2n_setraw (struct group *, ec2np_ptr, u_int8_t *, int);
int ec2n_setrandom (struct group *, ec2np_ptr);
int ec2n_operation (struct group *, ec2np_ptr, ec2np_ptr, ec2np_ptr);
d60 3
a62 3
  ec2np_t gen;				/* Generator */
  ec2ng_t grp;
  ec2np_t a, b, c, d;
d66 3
a68 3
  math_mp_t gen;			/* Generator */
  math_mp_t p;				/* Prime */
  math_mp_t a, b, c, d;
d105 167
a271 166
  { OAKLEY_GRP_1, 72,	/* This group is insecure, only sufficient for DES */
    "0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
    "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
    "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
    "E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF",
    "0x02"
  },
  { OAKLEY_GRP_2, 82,	/* This group is a bit better */
    "0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
    "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
    "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
    "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
    "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381"
    "FFFFFFFFFFFFFFFF",
    "0x02"
  },
  { OAKLEY_GRP_5, 102,
    "0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
    "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
    "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
    "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
    "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
    "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
    "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
    "670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF",
    "0x02"
  },
  { OAKLEY_GRP_14, 135,  /* 2048 bit */
    "0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
    "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
    "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
    "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
    "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
    "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
    "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
    "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
    "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
    "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
    "15728E5A8AACAA68FFFFFFFFFFFFFFFF",
    "0x02"
  },
  { OAKLEY_GRP_15, 170,  /* 3072 bit */
    "0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
    "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
    "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
    "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
    "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
    "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
    "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
    "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
    "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
    "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
    "15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
    "ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
    "ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
    "F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
    "BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
    "43DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF",
    "0x02"
  },
  { OAKLEY_GRP_16, 195,  /* 4096 bit */
    "0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
    "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
    "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
    "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
    "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
    "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
    "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
    "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
    "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
    "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
    "15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
    "ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
    "ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
    "F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
    "BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
    "43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7"
    "88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA"
    "2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6"
    "287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED"
    "1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"
    "93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199"
    "FFFFFFFFFFFFFFFF",
    "0x02"
  },
  { OAKLEY_GRP_17, 220,  /* 6144 bit */
    "0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
    "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
    "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
    "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
    "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
    "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
    "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
    "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
    "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
    "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
    "15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
    "ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
    "ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
    "F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
    "BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
    "43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7"
    "88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA"
    "2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6"
    "287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED"
    "1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"
    "93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"
    "36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BD"
    "F8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831"
    "179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1B"
    "DB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF"
    "5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6"
    "D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F3"
    "23A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"
    "CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE328"
    "06A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55C"
    "DA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE"
    "12BF2D5B0B7474D6E694F91E6DCC4024FFFFFFFFFFFFFFFF",
    "0x02"
  },
  { OAKLEY_GRP_18, 250,  /* 8192 bit */
    "0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
    "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
    "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
    "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
    "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
    "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
    "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
    "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
    "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
    "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
    "15728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64"
    "ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7"
    "ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6B"
    "F12FFA06D98A0864D87602733EC86A64521F2B18177B200C"
    "BBE117577A615D6C770988C0BAD946E208E24FA074E5AB31"
    "43DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D7"
    "88719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA"
    "2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6"
    "287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED"
    "1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA9"
    "93B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492"
    "36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BD"
    "F8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831"
    "179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1B"
    "DB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF"
    "5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6"
    "D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F3"
    "23A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA"
    "CC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE328"
    "06A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55C"
    "DA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE"
    "12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E4"
    "38777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300"
    "741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F568"
    "3423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD9"
    "22222E04A4037C0713EB57A81A23F0C73473FC646CEA306B"
    "4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A"
    "062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A36"
    "4597E899A0255DC164F31CC50846851DF9AB48195DED7EA1"
    "B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F92"
    "4009438B481C6CD7889A002ED5EE382BC9190DA6FC026E47"
    "9558E4475677E9AA9E3050E2765694DFC81F56E880B96E71"
    "60C980DD98EDD3DFFFFFFFFFFFFFFFFF",
    "0x02"
  },
d283 11
a293 10
  { OAKLEY_GRP_3, 76,	/* This group is also considered insecure (P1363) */
    "0x0800000000000000000000004000000000000001",
    "0x7b",
    "0x00",
    "0x7338f" },
  { OAKLEY_GRP_4, 91,
    "0x020000000000000000000000000000200000000000000001",
    "0x18",
    "0x00",
    "0x1ee9" },
d295 1
a295 1
#endif /* USE_EC */
d298 17
a314 17
struct group groups[] = {
  {
    MODP, OAKLEY_GRP_1, 0, &oakley_modp[0], 0, 0, 0, 0, 0,
    (int (*) (struct group *))modp_getlen,
    (void (*) (struct group *, void *, u_int8_t *))modp_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (int (*) (struct group *, void *))modp_setrandom,
    (int (*) (struct group *, void *, void *, void *))modp_operation
  },
  {
    MODP, OAKLEY_GRP_2, 0, &oakley_modp[1], 0, 0, 0, 0, 0,
    (int (*) (struct group *))modp_getlen,
    (void (*) (struct group *, void *, u_int8_t *))modp_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (int (*) (struct group *, void *))modp_setrandom,
    (int (*) (struct group *, void *, void *, void *))modp_operation
  },
d316 25
a340 25
  {
    EC2N, OAKLEY_GRP_3, 0, &oakley_ec2n[0], 0, 0, 0, 0, 0,
    (int (*) (struct group *))ec2n_getlen,
    (void (*) (struct group *, void *, u_int8_t *))ec2n_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))ec2n_setraw,
    (int (*) (struct group *, void *))ec2n_setrandom,
    (int (*) (struct group *, void *, void *, void *))ec2n_operation
  },
  {
    EC2N, OAKLEY_GRP_4, 0, &oakley_ec2n[1], 0, 0, 0, 0, 0,
    (int (*) (struct group *))ec2n_getlen,
    (void (*) (struct group *, void *, u_int8_t *))ec2n_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))ec2n_setraw,
    (int (*) (struct group *, void *))ec2n_setrandom,
    (int (*) (struct group *, void *, void *, void *))ec2n_operation
  },
#endif /* USE_EC */
  {
    MODP, OAKLEY_GRP_5, 0, &oakley_modp[2], 0, 0, 0, 0, 0,
    (int (*) (struct group *))modp_getlen,
    (void (*) (struct group *, void *, u_int8_t *))modp_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (int (*) (struct group *, void *))modp_setrandom,
    (int (*) (struct group *, void *, void *, void *))modp_operation
  },
d342 75
a416 75
  /* XXX Higher EC2N group go here... */
#endif /* USE_EC */
  /* XXX group 6 to 13 are not yet defined (draft-ike-ecc) */
  {
    NOTYET, OAKLEY_GRP_6, 0, NULL, 0, 0, 0, 0, 0,
    NULL, NULL, NULL, NULL, NULL
  },
  {
    NOTYET, OAKLEY_GRP_7, 0, NULL, 0, 0, 0, 0, 0,
    NULL, NULL, NULL, NULL, NULL
  },
  {
    NOTYET, OAKLEY_GRP_8, 0, NULL, 0, 0, 0, 0, 0,
    NULL, NULL, NULL, NULL, NULL
  },
  {
    NOTYET, OAKLEY_GRP_9, 0, NULL, 0, 0, 0, 0, 0,
    NULL, NULL, NULL, NULL, NULL
  },
  {
    NOTYET, OAKLEY_GRP_10, 0, NULL, 0, 0, 0, 0, 0,
    NULL, NULL, NULL, NULL, NULL
  },
  {
    NOTYET, OAKLEY_GRP_11, 0, NULL, 0, 0, 0, 0, 0,
    NULL, NULL, NULL, NULL, NULL
  },
  {
    NOTYET, OAKLEY_GRP_12, 0, NULL, 0, 0, 0, 0, 0,
    NULL, NULL, NULL, NULL, NULL
  },
  {
    NOTYET, OAKLEY_GRP_13, 0, NULL, 0, 0, 0, 0, 0,
    NULL, NULL, NULL, NULL, NULL
  },
  {
    MODP, OAKLEY_GRP_14, 0, &oakley_modp[3], 0, 0, 0, 0, 0,
    (int (*) (struct group *))modp_getlen,
    (void (*) (struct group *, void *, u_int8_t *))modp_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (int (*) (struct group *, void *))modp_setrandom,
    (int (*) (struct group *, void *, void *, void *))modp_operation
  },
  {
    MODP, OAKLEY_GRP_15, 0, &oakley_modp[4], 0, 0, 0, 0, 0,
    (int (*) (struct group *))modp_getlen,
    (void (*) (struct group *, void *, u_int8_t *))modp_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (int (*) (struct group *, void *))modp_setrandom,
    (int (*) (struct group *, void *, void *, void *))modp_operation
  },
  {
    MODP, OAKLEY_GRP_16, 0, &oakley_modp[5], 0, 0, 0, 0, 0,
    (int (*) (struct group *))modp_getlen,
    (void (*) (struct group *, void *, u_int8_t *))modp_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (int (*) (struct group *, void *))modp_setrandom,
    (int (*) (struct group *, void *, void *, void *))modp_operation
  },
  {
    MODP, OAKLEY_GRP_17, 0, &oakley_modp[6], 0, 0, 0, 0, 0,
    (int (*) (struct group *))modp_getlen,
    (void (*) (struct group *, void *, u_int8_t *))modp_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (int (*) (struct group *, void *))modp_setrandom,
    (int (*) (struct group *, void *, void *, void *))modp_operation
  },
  {
    MODP, OAKLEY_GRP_18, 0, &oakley_modp[7], 0, 0, 0, 0, 0,
    (int (*) (struct group *))modp_getlen,
    (void (*) (struct group *, void *, u_int8_t *))modp_getraw,
    (int (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (int (*) (struct group *, void *))modp_setrandom,
    (int (*) (struct group *, void *, void *, void *))modp_operation
  },
d425 1
a425 1
group_init (void)
d427 1
a427 1
  int i;
d429 2
a430 3
  for (i = sizeof (groups) / sizeof (groups[0]) - 1; i >= 0; i--)
    switch (groups[i].type)
      {
d432 3
a434 3
      case EC2N:		/* Initialize an Elliptic Curve over GF(2**n) */
	ec2n_init (&groups[i]);
	break;
d437 24
a460 33
      case MODP:		/* Initialize an over GF(p) */
	modp_init (&groups[i]);
	break;

      case NOTYET:		/* Not yet assigned, drop silently */
	break;
	
      default:
	log_print ("Unknown group type %d at index %d in group_init().",
		   groups[i].type, i);
	break;
      }
}

struct group *
group_get (u_int32_t id)
{
  struct group *new, *clone;

  if (id < 1 || id > (sizeof (groups) / sizeof (groups[0])))
    {
      log_print ("group_get: group ID (%u) out of range", id);
      return 0;
    }

  clone = &groups[id - 1];

  new = malloc (sizeof *new);
  if (!new)
    {
      log_error ("group_get: malloc (%lu) failed", (unsigned long)sizeof *new);
      return 0;
    }
d462 6
a467 2
  switch (clone->type)
    {
d469 3
a471 3
    case EC2N:
      new = ec2n_clone (new, clone);
      break;
d473 11
a483 11
    case MODP:
      new = modp_clone (new, clone);
      break;
    default:
      log_print ("group_get: unknown group type %d", clone->type);
      free (new);
      return 0;
    }
  LOG_DBG ((LOG_MISC, 70, "group_get: returning %p of group %d", new,
	    new->id));
  return new;
d487 1
a487 1
group_free (struct group *grp)
d489 1
a489 2
  switch (grp->type)
    {
d491 3
a493 3
    case EC2N:
      ec2n_free (grp);
      break;
d495 14
a508 23
    case MODP:
      modp_free (grp);
      break;
    default:
      log_print ("group_free: unknown group type %d", grp->type);
      break;
    }
  free (grp);
}

struct group *
modp_clone (struct group *new, struct group *clone)
{
  struct modp_group *new_grp, *clone_grp = clone->group;

  new_grp = malloc (sizeof *new_grp);
  if (!new_grp)
    {
      log_print ("modp_clone: malloc (%lu) failed",
		 (unsigned long)sizeof *new_grp);
      free (new);
      return 0;
    }
d510 8
a517 1
  memcpy (new, clone, sizeof (struct group));
d519 1
a519 1
  new->group = new_grp;
d521 2
a522 2
  mpz_init_set (new_grp->p, clone_grp->p);
  mpz_init_set (new_grp->gen, clone_grp->gen);
d524 3
a526 3
  mpz_init (new_grp->a);
  mpz_init (new_grp->b);
  mpz_init (new_grp->c);
d528 2
a529 2
  new_grp->p = BN_dup (clone_grp->p);
  new_grp->gen = BN_dup (clone_grp->gen);
d531 3
a533 3
  new_grp->a = BN_new ();
  new_grp->b = BN_new ();
  new_grp->c = BN_new ();
d536 4
a539 4
  new->gen = new_grp->gen;
  new->a = new_grp->a;
  new->b = new_grp->b;
  new->c = new_grp->c;
d541 1
a541 1
  return new;
d545 1
a545 1
modp_free (struct group *old)
d547 1
a547 1
  struct modp_group *grp = old->group;
d550 5
a554 5
  mpz_clear (grp->p);
  mpz_clear (grp->gen);
  mpz_clear (grp->a);
  mpz_clear (grp->b);
  mpz_clear (grp->c);
d556 5
a560 5
  BN_clear_free (grp->p);
  BN_clear_free (grp->gen);
  BN_clear_free (grp->a);
  BN_clear_free (grp->b);
  BN_clear_free (grp->c);
d563 1
a563 1
  free (grp);
d567 1
a567 1
modp_init (struct group *group)
d569 2
a570 2
  struct modp_dscr *dscr = (struct modp_dscr *)group->group;
  struct modp_group *grp;
d572 3
a574 3
  grp = malloc (sizeof *grp);
  if (!grp)
    log_fatal ("modp_init: malloc (%lu) failed", (unsigned long)sizeof *grp);
d576 1
a576 1
  group->bits = dscr->bits;
d579 2
a580 2
  mpz_init_set_str (grp->p, dscr->prime, 0);
  mpz_init_set_str (grp->gen, dscr->gen, 0);
d582 3
a584 3
  mpz_init (grp->a);
  mpz_init (grp->b);
  mpz_init (grp->c);
d586 8
a593 8
  grp->p = BN_new ();
  BN_hex2bn (&grp->p, dscr->prime + 2);
  grp->gen = BN_new ();
  BN_hex2bn (&grp->gen, dscr->gen + 2);

  grp->a = BN_new ();
  grp->b = BN_new ();
  grp->c = BN_new ();
d596 4
a599 4
  group->gen = grp->gen;
  group->a = grp->a;
  group->b = grp->b;
  group->c = grp->c;
d601 1
a601 1
  group->group = grp;
d605 2
a606 2
struct group *
ec2n_clone (struct group *new, struct group *clone)
d608 1
a608 1
  struct ec2n_group *new_grp, *clone_grp = clone->group;
d610 38
a647 40
  new_grp = malloc (sizeof *new_grp);
  if (!new_grp)
    {
      log_error ("ec2n_clone: malloc (%lu) failed",
		 (unsigned long)sizeof *new_grp);
      free (new);
      return 0;
    }

  memcpy (new, clone, sizeof (struct group));

  new->group = new_grp;
  ec2ng_init (new_grp->grp);
  ec2np_init (new_grp->gen);
  ec2np_init (new_grp->a);
  ec2np_init (new_grp->b);
  ec2np_init (new_grp->c);

  if (ec2ng_set (new_grp->grp, clone_grp->grp))
    goto fail;
  if (ec2np_set (new_grp->gen, clone_grp->gen))
    goto fail;

  new->gen = new_grp->gen;
  new->a = new_grp->a;
  new->b = new_grp->b;
  new->c = new_grp->c;
  new->d = ((ec2np_ptr)new->a)->x;

  return new;

 fail:
  ec2ng_clear (new_grp->grp);
  ec2np_clear (new_grp->gen);
  ec2np_clear (new_grp->a);
  ec2np_clear (new_grp->b);
  ec2np_clear (new_grp->c);
  free (new_grp);
  free (new);
  return 0;
d651 1
a651 1
ec2n_free (struct group *old)
d653 1
a653 1
  struct ec2n_group *grp = old->group;
d655 5
a659 5
  ec2ng_clear (grp->grp);
  ec2np_clear (grp->gen);
  ec2np_clear (grp->a);
  ec2np_clear (grp->b);
  ec2np_clear (grp->c);
d661 1
a661 1
  free (grp);
d665 1
a665 1
ec2n_init (struct group *group)
d667 2
a668 2
  struct ec2n_dscr *dscr = (struct ec2n_dscr *)group->group;
  struct ec2n_group *grp;
d670 34
a703 34
  grp = malloc (sizeof *grp);
  if (!grp)
    log_fatal ("ec2n_init: malloc (%lu) failed", (unsigned long)sizeof *grp);

  group->bits = dscr->bits;

  ec2ng_init (grp->grp);
  ec2np_init (grp->gen);
  ec2np_init (grp->a);
  ec2np_init (grp->b);
  ec2np_init (grp->c);

  if (ec2ng_set_p_str (grp->grp, dscr->polynomial))
    goto fail;
  grp->grp->p->bits = b2n_sigbit (grp->grp->p);
  if (ec2ng_set_a_str (grp->grp, dscr->a))
    goto fail;
  if (ec2ng_set_b_str (grp->grp, dscr->b))
    goto fail;

  if (ec2np_set_x_str (grp->gen, dscr->gen_x))
    goto fail;
  if (ec2np_find_y (grp->gen, grp->grp))
    goto fail;

  /* Sanity check */
  if (!ec2np_ison (grp->gen, grp->grp))
    log_fatal ("ec2n_init: generator is not on curve");

  group->gen = grp->gen;
  group->a = grp->a;
  group->b = grp->b;
  group->c = grp->c;
  group->d = ((ec2np_ptr)group->a)->x;
d705 2
a706 2
  group->group = grp;
  return;
d708 2
a709 2
 fail:
  log_fatal ("ec2n_init: general failure");
d711 1
a711 1
#endif /* USE_EC */
d714 1
a714 1
modp_getlen (struct group *group)
d716 1
a716 1
  struct modp_group *grp = (struct modp_group *)group->group;
d718 1
a718 1
  return mpz_sizeinoctets (grp->p);
d722 1
a722 1
modp_getraw (struct group *grp, math_mp_t v, u_int8_t *d)
d724 1
a724 1
  mpz_getraw (d, v, grp->getlen (grp));
d728 1
a728 1
modp_setraw (struct group *grp, math_mp_t d, u_int8_t *s, int l)
d730 2
a731 2
  mpz_setraw (d, s, l);
  return 0;
d735 1
a735 1
modp_setrandom (struct group *grp, math_mp_t d)
d737 2
a738 2
  int i, l = grp->getlen (grp);
  u_int32_t tmp = 0;
d741 1
a741 1
  mpz_set_ui (d, 0);
d743 1
a743 1
  BN_set_word (d, 0);
d746 3
a748 4
  for (i = 0; i < l; i++)
    {
      if (i % 4)
	tmp = sysdep_random ();
d751 2
a752 2
      mpz_mul_2exp (d, d, 8);
      mpz_add_ui (d, d, tmp & 0xFF);
d754 2
a755 2
      BN_lshift (d, d, 8);
      BN_add_word (d, tmp & 0xFF);
d757 3
a759 3
      tmp >>= 8;
    }
  return 0;
d763 1
a763 1
modp_operation (struct group *group, math_mp_t d, math_mp_t a, math_mp_t e)
d765 1
a765 1
  struct modp_group *grp = (struct modp_group *)group->group;
d768 1
a768 1
  mpz_powm (d, a, e, grp->p);
d770 3
a772 3
  BN_CTX *ctx = BN_CTX_new ();
  BN_mod_exp (d, a, e, grp->p, ctx);
  BN_CTX_free (ctx);
d774 1
a774 1
  return 0;
d779 1
a779 1
ec2n_getlen (struct group *group)
d781 2
a782 2
  struct ec2n_group *grp = (struct ec2n_group *)group->group;
  int bits = b2n_sigbit (grp->grp->p) - 1;
d784 1
a784 1
  return (7 + bits) >> 3;
d788 1
a788 1
ec2n_getraw (struct group *group, ec2np_ptr xo, u_int8_t *e)
d790 16
a805 16
  struct ec2n_group *grp = (struct ec2n_group *)group->group;
  int chunks, bytes, i, j;
  b2n_ptr x = xo->x;
  CHUNK_TYPE tmp;

  bytes = b2n_sigbit (grp->grp->p) - 1;
  chunks = (CHUNK_MASK + bytes) >> CHUNK_SHIFTS;
  bytes = ((7 + (bytes & CHUNK_MASK)) >> 3);

  for (i = chunks - 1; i >= 0; i--)
    {
      tmp = (i >= x->chunks ? 0 : x->limp[i]);
      for (j = (i == chunks - 1 ? bytes : CHUNK_BYTES) - 1; j >= 0; j--)
	{
	  e[j] = tmp & 0xff;
	  tmp >>= 8;
a806 2
      e += (i == chunks - 1 ? bytes : CHUNK_BYTES);
    }
d810 1
a810 1
ec2n_setraw (struct group *grp, ec2np_ptr out, u_int8_t *s, int l)
d812 17
a828 17
  int len, bytes, i, j;
  b2n_ptr outx = out->x;
  CHUNK_TYPE tmp;

  len = (CHUNK_BYTES - 1 + l) / CHUNK_BYTES;
  if (b2n_resize (outx, len))
    return -1;

  bytes = ((l - 1) % CHUNK_BYTES) + 1;

  for (i = len - 1; i >= 0; i--)
    {
      tmp = 0;
      for (j = (i == len - 1 ? bytes : CHUNK_BYTES); j > 0; j--)
	{
	  tmp <<= 8;
	  tmp |= *s++;
d830 1
a830 3
      outx->limp[i] = tmp;
    }
  return 0;
d834 1
a834 1
ec2n_setrandom (struct group *group, ec2np_ptr x)
d836 2
a837 2
  b2n_ptr d = x->x;
  struct ec2n_group *grp = (struct ec2n_group *)group->group;
d839 1
a839 1
  return b2n_random (d, b2n_sigbit (grp->grp->p) - 1);
d850 1
a850 1
ec2n_operation (struct group *grp, ec2np_ptr d, ec2np_ptr a, ec2np_ptr e)
d852 2
a853 2
  b2n_ptr ex = e->x;
  struct ec2n_group *group = (struct ec2n_group *)grp->group;
d855 3
a857 3
  if (a->y->chunks == 0)
    if (ec2np_find_y (a, group->grp))
      return -1;
d859 1
a859 1
  return ec2np_mul (d, a, ex, group->grp);
d861 1
a861 1
#endif /* USE_EC */
@


1.19
log
@Support for groups modp2048, modp3072, modp4096, modp6144 and modp8192 (IDs 14
to 18).

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.18 2003/06/03 14:28:16 ho Exp $	*/
d451 1
a451 1
group_get (int id)
d457 1
a457 1
      log_print ("group_get: group ID (%d) out of range", id);
@


1.18
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.17 2003/03/14 14:49:08 ho Exp $	*/
a80 2

#ifdef not_until_IANA_assigns_the_groups
a93 1
#endif /* IANA */
d121 1
a121 1
  { OAKLEY_GRP_5, 102,	/* This group is yet a bit better, but non-standard */
d132 1
a132 2
#ifdef not_until_IANA_assigns_the_groups
  { OAKLEY_GRP_14, 135,  /* 2048 bit, non-standard */
d146 1
a146 1
  { OAKLEY_GRP_15, 170,  /* 3072 bit, non-standard */
d165 1
a165 1
  { OAKLEY_GRP_16, 195,  /* 4096 bit, non-standard */
d190 1
a190 1
  { OAKLEY_GRP_17, 220,  /* 6144 bit, non-standard */
d225 1
a225 1
  { OAKLEY_GRP_18, 250,  /* 8192 bit, non-standard */
a270 1
#endif /* IANA */
d342 33
a374 1
#ifdef not_until_IANA_assigns_the_groups
a414 1
#endif /* IANA */
d438 3
@


1.17
log
@Spelling fixes from david@@. jmc@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.16 2002/06/12 18:34:42 ho Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.16
log
@Five higher MODP groups, but commented out for now (until IANA assigns
them proper numbers).
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.15 2002/06/06 02:15:27 ho Exp $	*/
d397 1
a397 1
 * Initalize the group structure for later use,
d410 1
a410 1
      case EC2N:		/* Initalize an Elliptic Curve over GF(2**n) */
d415 1
a415 1
      case MODP:		/* Initalize an over GF(p) */
d834 1
a834 1
 * that we need to initalize the y variable for the operation
@


1.15
log
@Style, and a few additional format/type mods.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.14 2002/06/01 07:44:21 deraadt Exp $	*/
d87 16
d139 142
a280 1
  }
d348 46
a393 1
  }
@


1.14
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.13 2001/04/09 22:09:52 ho Exp $	*/
d292 2
a293 1
      log_print ("modp_clone: malloc (%lu) failed", (unsigned long)sizeof *new_grp);
d394 2
a395 1
      log_error ("ec2n_clone: malloc (%lu) failed", (unsigned long)sizeof *new_grp);
@


1.13
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.12 2000/04/07 22:04:44 niklas Exp $	*/
d240 1
a240 1
      log_error ("group_get: malloc (%d) failed", sizeof *new);
d292 1
a292 1
      log_print ("modp_clone: malloc (%d) failed", sizeof *new_grp);
d354 1
a354 1
    log_fatal ("modp_init: malloc (%d) failed", sizeof *grp);
d393 1
a393 1
      log_error ("ec2n_clone: malloc (%d) failed", sizeof *new_grp);
d453 1
a453 1
    log_fatal ("ec2n_init: malloc (%d) failed", sizeof *grp);
@


1.12
log
@Merge with EOM 1.25

author: niklas
typo

author: niklas
Multi-implementation for MP
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.11 2000/02/25 17:23:41 niklas Exp $	*/
d530 1
a530 1
	tmp = sysdep_random();
@


1.12.4.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_group.c,v 1.13 2001/04/09 22:09:52 ho Exp $	*/
d530 1
a530 1
	tmp = sysdep_random ();
@


1.11
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.10 2000/02/19 19:32:54 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.23 2000/02/20 19:58:40 niklas Exp $	*/
a38 1
#include <gmp.h>
d49 1
d53 4
a56 4
void modp_getraw (struct group *, mpz_ptr, u_int8_t *);
int modp_setraw (struct group *, mpz_ptr, u_int8_t *, int);
int modp_setrandom (struct group *, mpz_ptr);
int modp_operation (struct group *, mpz_ptr, mpz_ptr, mpz_ptr);
d71 3
a73 3
  mpz_t gen;				/* Generator */
  mpz_t p;				/* Prime */
  mpz_t a, b, c, d;
d300 1
a301 1

d307 8
d329 1
d335 7
d358 1
a359 1

d365 10
d503 1
a503 1
modp_getraw (struct group *grp, mpz_ptr v, u_int8_t *d)
d509 1
a509 1
modp_setraw (struct group *grp, mpz_ptr d, u_int8_t *s, int l)
d516 1
a516 1
modp_setrandom (struct group *grp, mpz_ptr d)
d521 1
d523 3
d532 1
d535 4
d545 1
a545 1
modp_operation (struct group *group, mpz_ptr d, mpz_ptr a, mpz_ptr e)
d549 1
d551 5
@


1.10
log
@cert.c: Merge with EOM 1.14
ike_auth.c: Merge with EOM 1.43
ike_phase_1.c: Merge with EOM 1.21
init.c: Merge with EOM 1.24
ipsec.c: Merge with EOM 1.117
isakmpd.c: Merge with EOM 1.44
math_group.c: Merge with EOM 1.22

author: niklas
Copyright 2000

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.9 1999/07/13 15:46:43 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.22 2000/02/19 07:58:56 niklas Exp $	*/
d259 2
a260 2
  log_debug (LOG_MISC, 70, "group_get: returning %p of group %d", new,
	     new->id);
@


1.9
log
@ipsec.c: Merge with EOM 1.114
math_group.c: Merge with EOM 1.20

author: niklas
Really make group 5 work
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.8 1999/06/02 06:30:13 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.20 1999/07/13 15:43:21 niklas Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
d126 1
d146 1
d166 1
d183 1
d207 1
d211 1
d246 1
d250 1
d269 1
d273 1
d358 1
d466 1
d518 1
d606 1
@


1.8
log
@Merge with EOM 1.19

author: niklas
Oakley group 5 is of 102 bit ops strength

author: niklas
Initial stab at Oakley group 5, still an XXX though.
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.7 1999/05/06 22:45:00 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.19 1999/05/28 19:51:45 niklas Exp $	*/
d179 8
@


1.7
log
@Merge with EOM 1.17

author: niklas
diagnostic
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.6 1999/04/19 21:22:49 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.17 1999/05/04 18:45:24 niklas Exp $	*/
d85 1
d111 11
@


1.6
log
@./regress/x509/x509test.c: Merge with EOM 1.4
./dh.h: Merge with EOM 1.4
./math_ec2n.c: Merge with EOM 1.8
./crypto.c: Merge with EOM 1.25
./ike_quick_mode.c: Merge with EOM 1.82
./math_group.c: Merge with EOM 1.16
./math_ec2n.h: Merge with EOM 1.4

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.5 1999/04/05 20:59:37 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.16 1999/04/17 23:20:38 niklas Exp $	*/
d204 4
a207 1
    return 0;
@


1.5
log
@Merge with EOM 1.15
Correct wording of debug printout

Debug output.  Style.  Missing break in case.

Style

Style police.

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.4 1999/02/26 03:46:57 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.15 1999/04/05 20:18:04 niklas Exp $	*/
d51 1
a51 1
/* We do not want to export these definitions */
d54 3
a56 3
void modp_setraw (struct group *, mpz_ptr, u_int8_t *, int);
void modp_setrandom (struct group *, mpz_ptr);
void modp_operation (struct group *, mpz_ptr, mpz_ptr, mpz_ptr);
d60 3
a62 3
void ec2n_setraw (struct group *, ec2np_ptr, u_int8_t *, int);
void ec2n_setrandom (struct group *, ec2np_ptr);
void ec2n_operation (struct group *, ec2np_ptr, ec2np_ptr, ec2np_ptr);
d76 1
a76 1
/* 
d123 1
a123 1
    "0x0800000000000000000000004000000000000001", 
d127 1
a127 1
  { OAKLEY_GRP_4, 91, 
d134 1
d137 1
a137 1
    MODP, OAKLEY_GRP_1, 0, &oakley_modp[0], NULL, NULL, NULL, NULL, NULL,
d140 3
a142 3
    (void (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (void (*) (struct group *, void *))modp_setrandom,
    (void (*) (struct group *, void *, void *, void *))modp_operation
d145 1
a145 1
    MODP, OAKLEY_GRP_2, 0, &oakley_modp[1], NULL, NULL, NULL, NULL, NULL,
d148 3
a150 3
    (void (*) (struct group *, void *, u_int8_t *, int))modp_setraw,
    (void (*) (struct group *, void *))modp_setrandom,
    (void (*) (struct group *, void *, void *, void *))modp_operation
d153 1
a153 1
    EC2N, OAKLEY_GRP_3, 0, &oakley_ec2n[0], NULL, NULL, NULL, NULL, NULL,
d156 3
a158 3
    (void (*) (struct group *, void *, u_int8_t *, int))ec2n_setraw,
    (void (*) (struct group *, void *))ec2n_setrandom,
    (void (*) (struct group *, void *, void *, void *))ec2n_operation
d161 1
a161 1
    EC2N, OAKLEY_GRP_4, 0, &oakley_ec2n[1], NULL, NULL, NULL, NULL, NULL,
d164 3
a166 3
    (void (*) (struct group *, void *, u_int8_t *, int))ec2n_setraw,
    (void (*) (struct group *, void *))ec2n_setrandom,
    (void (*) (struct group *, void *, void *, void *))ec2n_operation
a169 1

d174 1
a174 2
 */ 

d192 1
a192 1
	log_print ("Unknown group type %d at index %d in group_init().", 
d289 1
a289 1
  mpz_clear (grp->gen); 
a300 1

d303 3
a305 2
  if ((grp = malloc (sizeof (struct modp_group))) == NULL)
    log_fatal ("modp_init: out of memory");
d330 2
a331 1
  if ((new_grp = malloc (sizeof (struct ec2n_group))) == NULL)
d333 1
a333 1
      log_print ("ec2n_clone: out of memory");
d342 1
a342 5
  ec2ng_set (new_grp->grp, clone_grp->grp);

  ec2np_init (new_grp->gen); 
  ec2np_set (new_grp->gen, clone_grp->gen);

d347 5
d359 10
d377 1
a377 1
  ec2np_clear (grp->gen); 
a388 1

d391 3
a393 2
  if ((grp = malloc (sizeof (struct ec2n_group))) == NULL)
    log_fatal ("ec2n_init: out of memory");
d398 7
a404 1
  ec2ng_set_p_str (grp->grp, dscr->polynomial);
d406 9
a414 6
  ec2ng_set_a_str (grp->grp, dscr->a);
  ec2ng_set_b_str (grp->grp, dscr->b);

  ec2np_init (grp->gen);
  ec2np_set_x_str (grp->gen, dscr->gen_x);
  ec2np_find_y (grp->gen, grp->grp);
a419 4
  ec2np_init (grp->a);
  ec2np_init (grp->b);
  ec2np_init (grp->c);

d427 4
d433 1
a433 1
int 
d441 1
a441 1
void 
d447 1
a447 1
void 
d451 1
d454 1
a454 1
void 
d471 1
d474 1
a474 1
void 
d478 1
d480 1
d483 1
a483 1
int 
d492 1
a492 1
void 
d504 1
a504 1
  for (i = chunks-1; i >= 0; i--)
d509 1
a509 1
	  e[j] = tmp & 0xFF;
d516 1
a516 1
void 
d524 2
a525 1
  b2n_resize (outx, len);
d539 1
d542 1
a542 1
void 
d547 2
a548 1
  b2n_random (d, b2n_sigbit (grp->grp->p) - 1);
d558 1
a558 1
void 
d565 2
a566 1
    ec2np_find_y (a, group->grp);
d568 1
a568 1
  ec2np_mul (d, a, ex, group->grp);
@


1.4
log
@Merge from the Ericsson repository
| revision 1.10
| date: 1999/02/25 11:39:14;  author: niklas;  state: Exp;  lines: +4 -4
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.3 1998/11/17 11:10:17 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.10 1999/02/25 11:39:14 niklas Exp $	*/
d6 1
d181 1
a181 1
  for (i = sizeof (groups)/sizeof (groups[0]) -1; i >= 0; i--)
a202 2
  if (id < 1 || id > (sizeof (groups)/sizeof (groups[0])))
    return NULL;
d204 2
a205 1
  clone = &groups[id-1];
d207 4
a210 1
  if ((new = malloc (sizeof (struct group))) == NULL)
d212 2
a213 2
      log_print ("group_get: Out of memory");
      return (NULL);
d225 1
a225 1
      log_print ("group_get: Unknown group type %d", clone->type);
d227 1
a227 1
      return (NULL);
d229 3
a231 1
  return (new);
d244 1
d246 1
a246 1
      log_print ("group_free: Unknown group type %d", grp->type);
d257 2
a258 1
  if ((new_grp = malloc (sizeof (struct modp_group))) == NULL)
d260 1
a260 1
      log_print ("modp_clone: Out of memory");
d262 1
a262 1
      return (NULL);
d281 1
a281 1
  return (new);
d306 1
a306 1
      log_fatal ("modp_init: Out of memory");
d333 1
a333 1
      log_print ("ec2n_clone: Out of memory");
d335 1
a335 1
      return (NULL);
d357 1
a357 1
  return (new);
d382 1
a382 1
      log_fatal ("ec2n_init: Out of memory");
d392 2
a393 1
  ec2np_init (grp->gen); ec2np_set_x_str (grp->gen, dscr->gen_x);
d398 1
a398 1
    log_fatal ("ec2n_init: Generator is not on curve");
d499 1
a499 1
  len = (CHUNK_BYTES - 1 + l)/CHUNK_BYTES;
a530 1

@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: math_group.c,v 1.2 1998/11/15 00:44:00 niklas Exp $	*/
/*	$EOM: math_group.c,v 1.9 1998/08/09 19:03:47 niklas Exp $	*/
d42 2
d45 1
a48 3

#include "log.h"
#include "sysdep.h"
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: math_group.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: math_group.c,v 1.9 1998/08/09 19:03:47 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
