head	1.27;
access;
symbols
	OPENBSD_4_7:1.26.0.10
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.12
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.8
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.6
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2010.06.29.19.50.16;	author reyk;	state dead;
branches;
next	1.26;

1.26
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.28.10.57.35;	author hshoexer;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.03.13.50.44;	author moritz;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.21.01.23.06;	author cloder;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.09.00.42.27;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.05.11.08.13;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.23.17.43.24;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.09.22.09.52;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	99.04.20.11.32.57;	author niklas;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	99.04.19.20.54.01;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.04.05.21.01.23;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.03.46.18;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.16;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.7.6.1
date	2001.05.08.12.45.24;	author ho;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Replace the hand-crafted Diffie-Hellman implementation in isakmpd with
the smaller implementation from iked that is using libcrypto instead.
This allows to remove a lot of code (which is always good), get rid of
some custom crypto code by using libcrypto, theoretically adds
support for many new MODP and EC2N/ECP modes (but it is not configurable
yet), and allows to share the dh.c/dh.h code in different codebases
(it is identical in isakmpd and iked, but could also be used elsewhere).

ok deraadt@@
@
text
@/* $OpenBSD: math_2n.c,v 1.26 2007/04/16 13:01:39 moritz Exp $	 */
/* $EOM: math_2n.c,v 1.15 1999/04/20 09:23:30 niklas Exp $	 */

/*
 * Copyright (c) 1998 Niels Provos.  All rights reserved.
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

/*
 * B2N is a module for doing arithmetic on the Field GF(2**n) which is
 * isomorph to ring of polynomials GF(2)[x]/p(x) where p(x) is an
 * irreducible polynomial over GF(2)[x] with grade n.
 *
 * First we need functions which operate on GF(2)[x], operation
 * on GF(2)[x]/p(x) can be done as for Z_p then.
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "math_2n.h"
#include "util.h"

static u_int8_t hex2int(char);

CHUNK_TYPE      b2n_mask[CHUNK_BITS] = {
	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
#if CHUNK_BITS > 8
	0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000,
#if CHUNK_BITS > 16
	0x00010000, 0x00020000, 0x00040000, 0x00080000,
	0x00100000, 0x00200000, 0x00400000, 0x00800000,
	0x01000000, 0x02000000, 0x04000000, 0x08000000,
	0x10000000, 0x20000000, 0x40000000, 0x80000000,
#endif
#endif
};

/* Convert a hex character to its integer value.  */
static u_int8_t
hex2int(char c)
{
	if (c <= '9')
		return c - '0';
	if (c <= 'f')
		return 10 + c - 'a';

	return 0;
}

int
b2n_random(b2n_ptr n, u_int32_t bits)
{
	if (b2n_resize(n, (CHUNK_MASK + bits) >> CHUNK_SHIFTS))
		return -1;

	getrandom((u_int8_t *) n->limp, CHUNK_BYTES * n->chunks);

	/* Get the number of significant bits right */
	if (bits & CHUNK_MASK) {
		CHUNK_TYPE m =
		    (((1 << ((bits & CHUNK_MASK) - 1)) - 1) << 1) | 1;
		n->limp[n->chunks - 1] &= m;
	}
	n->dirty = 1;
	return 0;
}

/* b2n management functions */

void
b2n_init(b2n_ptr n)
{
	n->chunks = 0;
	n->limp = 0;
}

void
b2n_clear(b2n_ptr n)
{
	free(n->limp);
}

int
b2n_resize(b2n_ptr n, unsigned int chunks)
{
	size_t          old = n->chunks;
	size_t          size;
	CHUNK_TYPE     *new;

	if (chunks == 0)
		chunks = 1;

	if (chunks == old)
		return 0;

	size = CHUNK_BYTES * chunks;

	new = realloc(n->limp, size);
	if (!new)
		return -1;

	n->limp = new;
	n->chunks = chunks;
	n->bits = chunks << CHUNK_SHIFTS;
	n->dirty = 1;

	if (chunks > old)
		bzero(n->limp + old, size - CHUNK_BYTES * old);

	return 0;
}

/* Simple assignment functions.  */

int
b2n_set(b2n_ptr d, b2n_ptr s)
{
	if (d == s)
		return 0;

	b2n_sigbit(s);
	if (b2n_resize(d, (CHUNK_MASK + s->bits) >> CHUNK_SHIFTS))
		return -1;
	memcpy(d->limp, s->limp, CHUNK_BYTES * d->chunks);
	d->bits = s->bits;
	d->dirty = s->dirty;
	return 0;
}

int
b2n_set_null(b2n_ptr n)
{
	if (b2n_resize(n, 1))
		return -1;
	n->limp[0] = n->bits = n->dirty = 0;
	return 0;
}

int
b2n_set_ui(b2n_ptr n, unsigned int val)
{
#if CHUNK_BITS < 32
	int	i, chunks;

	chunks = (CHUNK_BYTES - 1 + sizeof(val)) / CHUNK_BYTES;

	if (b2n_resize(n, chunks))
		return -1;

	for (i = 0; i < chunks; i++) {
		n->limp[i] = val & CHUNK_BMASK;
		val >>= CHUNK_BITS;
	}
#else
	if (b2n_resize(n, 1))
		return -1;
	n->limp[0] = val;
#endif
	n->dirty = 1;
	return 0;
}

/* XXX This one only takes hex at the moment.  */
int
b2n_set_str(b2n_ptr n, char *str)
{
	int		i, j, w, len, chunks;
	CHUNK_TYPE      tmp;

	if (strncasecmp(str, "0x", 2))
		return -1;

	/* Make the hex string even lengthed */
	len = strlen(str) - 2;
	if (len & 1) {
		len++;
		str++;
	} else
		str += 2;

	len /= 2;

	chunks = (CHUNK_BYTES - 1 + len) / CHUNK_BYTES;
	if (b2n_resize(n, chunks))
		return -1;
	bzero(n->limp, CHUNK_BYTES * n->chunks);

	for (w = 0, i = 0; i < chunks; i++) {
		tmp = 0;
		for (j = (i == 0 ?
		    ((len - 1) % CHUNK_BYTES) + 1 : CHUNK_BYTES);
		    j > 0; j--) {
			tmp <<= 8;
			tmp |= (hex2int(str[w]) << 4) | hex2int(str[w + 1]);
			w += 2;
		}
		n->limp[chunks - 1 - i] = tmp;
	}

	n->dirty = 1;
	return 0;
}

/* Arithmetic functions.  */

u_int32_t
b2n_sigbit(b2n_ptr n)
{
	int	i, j;

	if (!n->dirty)
		return n->bits;

	for (i = n->chunks - 1; i > 0; i--)
		if (n->limp[i])
			break;

	if (!n->limp[i])
		return 0;

	for (j = CHUNK_MASK; j > 0; j--)
		if (n->limp[i] & b2n_mask[j])
			break;

	n->bits = (i << CHUNK_SHIFTS) + j + 1;
	n->dirty = 0;
	return n->bits;
}

/* Addition on GF(2)[x] is nice, its just an XOR.  */
int
b2n_add(b2n_ptr d, b2n_ptr a, b2n_ptr b)
{
	int             i;
	b2n_ptr         bmin, bmax;

	if (!b2n_cmp_null(a))
		return b2n_set(d, b);

	if (!b2n_cmp_null(b))
		return b2n_set(d, a);

	bmin = B2N_MIN(a, b);
	bmax = B2N_MAX(a, b);

	if (b2n_resize(d, bmax->chunks))
		return -1;

	for (i = 0; i < bmin->chunks; i++)
		d->limp[i] = bmax->limp[i] ^ bmin->limp[i];

	/*
	 * If d is not bmax, we have to copy the rest of the bytes, and also
	 * need to adjust to number of relevant bits.
         */
	if (d != bmax) {
		for (; i < bmax->chunks; i++)
			d->limp[i] = bmax->limp[i];

		d->bits = bmax->bits;
	}
	/*
	 * Help to converse memory. When the result of the addition is zero
	 * truncate the used amount of memory.
         */
	if (d != bmax && !b2n_cmp_null(d))
		return b2n_set_null(d);
	else
		d->dirty = 1;
	return 0;
}

/* Compare two polynomials.  */
int
b2n_cmp(b2n_ptr n, b2n_ptr m)
{
	int	sn, sm;
	int	i;

	sn = b2n_sigbit(n);
	sm = b2n_sigbit(m);

	if (sn > sm)
		return 1;
	if (sn < sm)
		return -1;

	for (i = n->chunks - 1; i >= 0; i--)
		if (n->limp[i] > m->limp[i])
			return 1;
		else if (n->limp[i] < m->limp[i])
			return -1;

	return 0;
}

int
b2n_cmp_null(b2n_ptr a)
{
	int	i = 0;

	do {
		if (a->limp[i])
			return 1;
	} while (++i < a->chunks);

	return 0;
}

/* Left shift, needed for polynomial multiplication.  */
int
b2n_lshift(b2n_ptr d, b2n_ptr n, unsigned int s)
{
	int             i, maj, min, chunks;
	u_int16_t       bits = b2n_sigbit(n), add;
	CHUNK_TYPE     *p, *op;

	if (!s)
		return b2n_set(d, n);

	maj = s >> CHUNK_SHIFTS;
	min = s & CHUNK_MASK;

	add = (!(bits & CHUNK_MASK) ||
	    ((bits & CHUNK_MASK) + min) > CHUNK_MASK) ? 1 : 0;
	chunks = n->chunks;
	if (b2n_resize(d, chunks + maj + add))
		return -1;
	memmove(d->limp + maj, n->limp, CHUNK_BYTES * chunks);

	if (maj)
		bzero(d->limp, CHUNK_BYTES * maj);
	if (add)
		d->limp[d->chunks - 1] = 0;

	/* If !min there are no bit shifts, we are done */
	if (!min)
		return 0;

	op = p = &d->limp[d->chunks - 1];
	for (i = d->chunks - 2; i >= maj; i--) {
		op--;
		*p = (*p << min) | (*op >> (CHUNK_BITS - min));
		p--;
	}
	*p <<= min;

	d->dirty = 0;
	d->bits = bits + (maj << CHUNK_SHIFTS) + min;
	return 0;
}

/* Right shift, needed for polynomial division.  */
int
b2n_rshift(b2n_ptr d, b2n_ptr n, unsigned int s)
{
	int	maj, min, size = n->chunks, newsize;
	b2n_ptr	tmp;

	if (!s)
		return b2n_set(d, n);

	maj = s >> CHUNK_SHIFTS;

	newsize = size - maj;

	if (size < maj)
		return b2n_set_null(d);

	min = (CHUNK_BITS - (s & CHUNK_MASK)) & CHUNK_MASK;
	if (min) {
		if ((b2n_sigbit(n) & CHUNK_MASK) > (u_int32_t) min)
			newsize++;

		if (b2n_lshift(d, n, min))
			return -1;
		tmp = d;
	} else
		tmp = n;

	memmove(d->limp, tmp->limp + maj + (min ? 1 : 0),
	    CHUNK_BYTES * newsize);
	if (b2n_resize(d, newsize))
		return -1;

	d->bits = tmp->bits - ((maj + (min ? 1 : 0)) << CHUNK_SHIFTS);
	return 0;
}

/* Normal polynomial multiplication.  */
int
b2n_mul(b2n_ptr d, b2n_ptr n, b2n_ptr m)
{
	int	i, j;
	b2n_t	tmp, tmp2;

	if (!b2n_cmp_null(m) || !b2n_cmp_null(n))
		return b2n_set_null(d);

	if (b2n_sigbit(m) == 1)
		return b2n_set(d, n);

	if (b2n_sigbit(n) == 1)
		return b2n_set(d, m);

	b2n_init(tmp);
	b2n_init(tmp2);

	if (b2n_set(tmp, B2N_MAX(n, m)))
		goto fail;
	if (b2n_set(tmp2, B2N_MIN(n, m)))
		goto fail;

	if (b2n_set_null(d))
		goto fail;

	for (i = 0; i < tmp2->chunks; i++)
		if (tmp2->limp[i])
			for (j = 0; j < CHUNK_BITS; j++) {
				if (tmp2->limp[i] & b2n_mask[j])
					if (b2n_add(d, d, tmp))
						goto fail;

				if (b2n_lshift(tmp, tmp, 1))
					goto fail;
			}
		else if (b2n_lshift(tmp, tmp, CHUNK_BITS))
			goto fail;

	b2n_clear(tmp);
	b2n_clear(tmp2);
	return 0;

fail:
	b2n_clear(tmp);
	b2n_clear(tmp2);
	return -1;
}

/*
 * Squaring in this polynomial ring is more efficient than normal
 * multiplication.
 */
int
b2n_square(b2n_ptr d, b2n_ptr n)
{
	int	i, j, maj, min, bits, chunk;
	b2n_t	t;

	maj = b2n_sigbit(n);
	min = maj & CHUNK_MASK;
	maj = (maj + CHUNK_MASK) >> CHUNK_SHIFTS;

	b2n_init(t);
	if (b2n_resize(t,
	    2 * maj + ((CHUNK_MASK + 2 * min) >> CHUNK_SHIFTS))) {
		b2n_clear(t);
		return -1;
	}
	chunk = 0;
	bits = 0;

	for (i = 0; i < maj; i++)
		if (n->limp[i])
			for (j = 0; j < CHUNK_BITS; j++) {
				if (n->limp[i] & b2n_mask[j])
					t->limp[chunk] ^= b2n_mask[bits];

				bits += 2;
				if (bits >= CHUNK_BITS) {
					chunk++;
					bits &= CHUNK_MASK;
				}
			}
		else
			chunk += 2;

	t->dirty = 1;
	B2N_SWAP(d, t);
	b2n_clear(t);
	return 0;
}

/*
 * Normal polynomial division.
 * These functions are far from optimal in speed.
 */
int
b2n_div_r(b2n_ptr r, b2n_ptr n, b2n_ptr m)
{
	b2n_t	q;
	int	rv;

	b2n_init(q);
	rv = b2n_div(q, r, n, m);
	b2n_clear(q);
	return rv;
}

int
b2n_div(b2n_ptr q, b2n_ptr r, b2n_ptr n, b2n_ptr m)
{
	int		i, j, len, bits;
	u_int32_t	sm, sn;
	b2n_t		nenn, div, shift, mask;

	/* If Teiler > Zaehler, the result is 0 */
	if ((sm = b2n_sigbit(m)) > (sn = b2n_sigbit(n))) {
		if (b2n_set_null(q))
			return -1;
		return b2n_set(r, n);
	}
	if (sm == 0)
		/* Division by Zero */
		return -1;
	else if (sm == 1) {
		/* Division by the One-Element */
		if (b2n_set(q, n))
			return -1;
		return b2n_set_null(r);
	}
	b2n_init(nenn);
	b2n_init(div);
	b2n_init(shift);
	b2n_init(mask);

	if (b2n_set(nenn, n))
		goto fail;
	if (b2n_set(div, m))
		goto fail;
	if (b2n_set(shift, m))
		goto fail;
	if (b2n_set_ui(mask, 1))
		goto fail;

	if (b2n_resize(q, (sn - sm + CHUNK_MASK) >> CHUNK_SHIFTS))
		goto fail;
	bzero(q->limp, CHUNK_BYTES * q->chunks);

	if (b2n_lshift(shift, shift, sn - sm))
		goto fail;
	if (b2n_lshift(mask, mask, sn - sm))
		goto fail;

	/* Number of significant octets */
	len = (sn - 1) >> CHUNK_SHIFTS;
	/* The first iteration is done over the relevant bits */
	bits = (CHUNK_MASK + sn) & CHUNK_MASK;
	for (i = len; i >= 0 && b2n_sigbit(nenn) >= sm; i--)
		for (j = (i == len ? bits : CHUNK_MASK); j >= 0 &&
		    b2n_sigbit(nenn) >= sm; j--) {
			if (nenn->limp[i] & b2n_mask[j]) {
				if (b2n_sub(nenn, nenn, shift))
					goto fail;
				if (b2n_add(q, q, mask))
					goto fail;
			}
			if (b2n_rshift(shift, shift, 1))
				goto fail;
			if (b2n_rshift(mask, mask, 1))
				goto fail;
		}

	B2N_SWAP(r, nenn);

	b2n_clear(nenn);
	b2n_clear(div);
	b2n_clear(shift);
	b2n_clear(mask);
	return 0;

fail:
	b2n_clear(nenn);
	b2n_clear(div);
	b2n_clear(shift);
	b2n_clear(mask);
	return -1;
}

/* Functions for Operation on GF(2**n) ~= GF(2)[x]/p(x).  */
int
b2n_mod(b2n_ptr m, b2n_ptr n, b2n_ptr p)
{
	int	bits, size;

	if (b2n_div_r(m, n, p))
		return -1;

	bits = b2n_sigbit(m);
	size = ((CHUNK_MASK + bits) >> CHUNK_SHIFTS);
	if (size == 0)
		size = 1;
	if (m->chunks > size)
		if (b2n_resize(m, size))
			return -1;

	m->bits = bits;
	m->dirty = 0;
	return 0;
}

int
b2n_mul_inv(b2n_ptr ga, b2n_ptr be, b2n_ptr p)
{
	b2n_t	a;

	b2n_init(a);
	if (b2n_set_ui(a, 1))
		goto fail;

	if (b2n_div_mod(ga, a, be, p))
		goto fail;

	b2n_clear(a);
	return 0;

fail:
	b2n_clear(a);
	return -1;
}

int
b2n_div_mod(b2n_ptr ga, b2n_ptr a, b2n_ptr be, b2n_ptr p)
{
	b2n_t	s0, s1, s2, q, r0, r1;

	/* There is no multiplicative inverse to Null.  */
	if (!b2n_cmp_null(be))
		return b2n_set_null(ga);

	b2n_init(s0);
	b2n_init(s1);
	b2n_init(s2);
	b2n_init(r0);
	b2n_init(r1);
	b2n_init(q);

	if (b2n_set(r0, p))
		goto fail;
	if (b2n_set(r1, be))
		goto fail;

	if (b2n_set_null(s0))
		goto fail;
	if (b2n_set(s1, a))
		goto fail;

	while (b2n_cmp_null(r1)) {
		if (b2n_div(q, r0, r0, r1))
			goto fail;
		B2N_SWAP(r0, r1);

		if (b2n_mul(s2, q, s1))
			goto fail;
		if (b2n_mod(s2, s2, p))
			goto fail;
		if (b2n_sub(s2, s0, s2))
			goto fail;

		B2N_SWAP(s0, s1);
		B2N_SWAP(s1, s2);
	}
	B2N_SWAP(ga, s0);

	b2n_clear(s0);
	b2n_clear(s1);
	b2n_clear(s2);
	b2n_clear(r0);
	b2n_clear(r1);
	b2n_clear(q);
	return 0;

fail:
	b2n_clear(s0);
	b2n_clear(s1);
	b2n_clear(s2);
	b2n_clear(r0);
	b2n_clear(r1);
	b2n_clear(q);
	return -1;
}

/*
 * The halftrace yields the square root if the degree of the
 * irreducible polynomial is odd.
 */
int
b2n_halftrace(b2n_ptr ho, b2n_ptr a, b2n_ptr p)
{
	int	i, m = b2n_sigbit(p) - 1;
	b2n_t	h;

	b2n_init(h);
	if (b2n_set(h, a))
		goto fail;

	for (i = 0; i < (m - 1) / 2; i++) {
		if (b2n_square(h, h))
			goto fail;
		if (b2n_mod(h, h, p))
			goto fail;
		if (b2n_square(h, h))
			goto fail;
		if (b2n_mod(h, h, p))
			goto fail;

		if (b2n_add(h, h, a))
			goto fail;
	}

	B2N_SWAP(ho, h);

	b2n_clear(h);
	return 0;

fail:
	b2n_clear(h);
	return -1;
}

/*
 * Solving the equation: y**2 + y = b in GF(2**m) where ip is the
 * irreducible polynomial. If m is odd, use the half trace.
 */
int
b2n_sqrt(b2n_ptr zo, b2n_ptr b, b2n_ptr ip)
{
	int	i, m = b2n_sigbit(ip) - 1;
	b2n_t	w, p, temp, z;

	if (!b2n_cmp_null(b))
		return b2n_set_null(z);

	if (m & 1)
		return b2n_halftrace(zo, b, ip);

	b2n_init(z);
	b2n_init(w);
	b2n_init(p);
	b2n_init(temp);

	do {
		if (b2n_random(p, m))
			goto fail;
		if (b2n_set_null(z))
			goto fail;
		if (b2n_set(w, p))
			goto fail;

		for (i = 1; i < m; i++) {
			if (b2n_square(z, z))	/* z**2 */
				goto fail;
			if (b2n_mod(z, z, ip))
				goto fail;

			if (b2n_square(w, w))	/* w**2 */
				goto fail;
			if (b2n_mod(w, w, ip))
				goto fail;

			if (b2n_mul(temp, w, b))	/* w**2 * b */
				goto fail;
			if (b2n_mod(temp, temp, ip))
				goto fail;
			if (b2n_add(z, z, temp))	/* z**2 + w**2 + b */
				goto fail;

			if (b2n_add(w, w, p))	/* w**2 + p */
				goto fail;
		}
	} while (!b2n_cmp_null(w));

	B2N_SWAP(zo, z);

	b2n_clear(w);
	b2n_clear(p);
	b2n_clear(temp);
	b2n_clear(z);
	return 0;

fail:
	b2n_clear(w);
	b2n_clear(p);
	b2n_clear(temp);
	b2n_clear(z);
	return -1;
}

/*
 * Low-level function to speed up scalar multiplication with
 * elliptic curves.
 * Multiplies a normal number by 3.
 */

/* Normal addition behaves as Z_{2**n} and not F_{2**n}.  */
int
b2n_nadd(b2n_ptr d0, b2n_ptr a0, b2n_ptr b0)
{
	int	i, carry;
	b2n_ptr	a, b;
	b2n_t	d;

	if (!b2n_cmp_null(a0))
		return b2n_set(d0, b0);

	if (!b2n_cmp_null(b0))
		return b2n_set(d0, a0);

	b2n_init(d);
	a = B2N_MAX(a0, b0);
	b = B2N_MIN(a0, b0);

	if (b2n_resize(d, a->chunks + 1)) {
		b2n_clear(d);
		return -1;
	}
	for (carry = i = 0; i < b->chunks; i++) {
		d->limp[i] = a->limp[i] + b->limp[i] + carry;
		carry = (d->limp[i] < a->limp[i] ? 1 : 0);
	}

	for (; i < a->chunks && carry; i++) {
		d->limp[i] = a->limp[i] + carry;
		carry = (d->limp[i] < a->limp[i] ? 1 : 0);
	}

	if (i < a->chunks)
		memcpy(d->limp + i, a->limp + i,
		    CHUNK_BYTES * (a->chunks - i));

	d->dirty = 1;
	B2N_SWAP(d0, d);

	b2n_clear(d);
	return 0;
}

int
b2n_3mul(b2n_ptr d0, b2n_ptr e)
{
	b2n_t	d;

	b2n_init(d);
	if (b2n_lshift(d, e, 1))
		goto fail;

	if (b2n_nadd(d0, d, e))
		goto fail;

	b2n_clear(d);
	return 0;

fail:
	b2n_clear(d);
	return -1;
}
@


1.26
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.25 2006/06/02 19:35:55 hshoexer Exp $	 */
@


1.25
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.24 2005/12/28 10:57:35 hshoexer Exp $	 */
d106 1
a106 2
	if (n->limp)
		free(n->limp);
@


1.24
log
@remove some unused functions and an unused variable found by lint.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.23 2005/05/03 13:50:44 moritz Exp $	 */
d36 1
a36 1
 * irreduciable polynomial over GF(2)[x] with grade n.
d712 1
a712 1
 * irreduceable polynomial is odd.
d750 1
a750 1
 * irreduceable polynomial. If m is odd, use the half trace.
@


1.23
log
@remove remaining stuff from b2n_snprintf removal. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.22 2005/04/21 01:23:06 cloder Exp $	 */
a515 12
b2n_div_q(b2n_ptr d, b2n_ptr n, b2n_ptr m)
{
	b2n_t	r;
	int	rv;

	b2n_init(r);
	rv = b2n_div(d, r, n, m);
	b2n_clear(r);
	return rv;
}

int
a629 30
b2n_gcd(b2n_ptr e, b2n_ptr go, b2n_ptr ho)
{
	b2n_t	g, h;

	b2n_init(g);
	b2n_init(h);
	if (b2n_set(g, go))
		goto fail;
	if (b2n_set(h, ho))
		goto fail;

	while (b2n_cmp_null(h)) {
		if (b2n_mod(g, g, h))
			goto fail;
		B2N_SWAP(g, h);
	}

	B2N_SWAP(e, g);

	b2n_clear(g);
	b2n_clear(h);
	return 0;

fail:
	b2n_clear(g);
	b2n_clear(h);
	return -1;
}

int
a710 35
 * The trace tells us if there do exist any square roots
 * for 'a' in GF(2)[x]/p(x). The number of square roots is
 * 2 - 2*Trace.
 * If z is a square root, z + 1 is the other.
 */
int
b2n_trace(b2n_ptr ho, b2n_ptr a, b2n_ptr p)
{
	int	i, m = b2n_sigbit(p) - 1;
	b2n_t	h;

	b2n_init(h);
	if (b2n_set(h, a))
		goto fail;

	for (i = 0; i < m - 1; i++) {
		if (b2n_square(h, h))
			goto fail;
		if (b2n_mod(h, h, p))
			goto fail;

		if (b2n_add(h, h, a))
			goto fail;
	}
	B2N_SWAP(ho, h);

	b2n_clear(h);
	return 0;

fail:
	b2n_clear(h);
	return -1;
}

/*
a815 39
/* Exponentiation modulo a polynomial.  */
int
b2n_exp_mod(b2n_ptr d, b2n_ptr b0, u_int32_t e, b2n_ptr p)
{
	b2n_t	u, b;

	b2n_init(u);
	b2n_init(b);
	if (b2n_set_ui(u, 1))
		goto fail;
	if (b2n_mod(b, b0, p))
		goto fail;

	while (e) {
		if (e & 1) {
			if (b2n_mul(u, u, b))
				goto fail;
			if (b2n_mod(u, u, p))
				goto fail;
		}
		if (b2n_square(b, b))
			goto fail;
		if (b2n_mod(b, b, p))
			goto fail;
		e >>= 1;
	}

	B2N_SWAP(d, u);

	b2n_clear(u);
	b2n_clear(b);
	return 0;

fail:
	b2n_clear(u);
	b2n_clear(b);
	return -1;
}

a858 37
	B2N_SWAP(d0, d);

	b2n_clear(d);
	return 0;
}

/* Very special sub, a > b.  */
int
b2n_nsub(b2n_ptr d0, b2n_ptr a, b2n_ptr b)
{
	int	i, carry;
	b2n_t	d;

	if (b2n_cmp(a, b) <= 0)
		return b2n_set_null(d0);

	b2n_init(d);
	if (b2n_resize(d, a->chunks)) {
		b2n_clear(d);
		return -1;
	}
	for (carry = i = 0; i < b->chunks; i++) {
		d->limp[i] = a->limp[i] - b->limp[i] - carry;
		carry = (d->limp[i] > a->limp[i] ? 1 : 0);
	}

	for (; i < a->chunks && carry; i++) {
		d->limp[i] = a->limp[i] - carry;
		carry = (d->limp[i] > a->limp[i] ? 1 : 0);
	}

	if (i < a->chunks)
		memcpy(d->limp + i, a->limp + i,
		    CHUNK_BYTES * (a->chunks - i));

	d->dirty = 1;

@


1.22
log
@Rather than try to fix b2n_print and b2n_snprint, which are not used, send
them to the attic.  OK beck
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.21 2005/04/09 00:42:27 deraadt Exp $	 */
a50 1
static char     int2hex[] = "0123456789abcdef";
@


1.21
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.20 2005/04/08 22:32:10 cloder Exp $	 */
a229 66
}

/* Output function, mainly for debugging purposes.  */
void
b2n_print(b2n_ptr n)
{
	int             i, j, w, flag = 0;
	int             left;
	char            buffer[2 * CHUNK_BYTES];
	CHUNK_TYPE      tmp;

	left = ((((7 + b2n_sigbit(n)) >> 3) - 1) % CHUNK_BYTES) + 1;
	printf("0x");
	for (i = 0; i < n->chunks; i++) {
		tmp = n->limp[n->chunks - 1 - i];
		memset(buffer, '0', sizeof(buffer));
		for (w = 0, j = (i == 0 ? left : CHUNK_BYTES); j > 0; j--) {
			buffer[w++] = int2hex[(tmp >> 4) & 0xf];
			buffer[w++] = int2hex[tmp & 0xf];
			tmp >>= 8;
		}

		for (j = (i == 0 ? left - 1 : CHUNK_BYTES - 1); j >= 0; j--)
			if (flag || (i == n->chunks - 1 && j == 0) ||
			 buffer[2 * j] != '0' || buffer[2 * j + 1] != '0') {
				putchar(buffer[2 * j]);
				putchar(buffer[2 * j + 1]);
				flag = 1;
			}
	}
	printf("\n");
}

int
b2n_snprint(char *buf, size_t sz, b2n_ptr n)
{
	int             i, j, w, flag = 0;
	size_t          k;
	int             left;
	char            buffer[2 * CHUNK_BYTES];
	CHUNK_TYPE      tmp;

	left = ((((7 + b2n_sigbit(n)) >> 3) - 1) % CHUNK_BYTES) + 1;

	k = strlcpy(buf, "0x", sz);
	for (i = 0; i < n->chunks && k < sz - 1; i++) {
		tmp = n->limp[n->chunks - 1 - i];
		memset(buffer, '0', sizeof(buffer));
		for (w = 0, j = (i == 0 ? left : CHUNK_BYTES); j > 0; j--) {
			buffer[w++] = int2hex[(tmp >> 4) & 0xf];
			buffer[w++] = int2hex[tmp & 0xf];
			tmp >>= 8;
		}

		for (j = (i == 0 ? left - 1 : CHUNK_BYTES - 1); j >= 0 &&
		    k < sz - 3; j--)
			if (flag || (i == n->chunks - 1 && j == 0) ||
			    buffer[2 * j] != '0' || buffer[2 * j + 1] != '0') {
				buf[k++] = buffer[2 * j];
				buf[k++] = buffer[2 * j + 1];
				flag = 1;
			}
	}

	buf[k++] = 0;
	return k;
@


1.20
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.19 2005/04/06 16:00:20 deraadt Exp $	 */
d399 1
a399 2
	}
	while (++i < a->chunks);
d942 1
a942 2
	}
	while (!b2n_cmp_null(w));
@


1.19
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.18 2005/04/04 19:31:11 deraadt Exp $	 */
a44 2

#include "sysdep.h"
@


1.18
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.17 2005/02/27 13:12:12 hshoexer Exp $	 */
d286 2
a287 2
		for (j = (i == 0 ? left - 1 : CHUNK_BYTES - 1); j >= 0
		    && k < sz - 3; j--)
d659 2
a660 2
		for (j = (i == len ? bits : CHUNK_MASK); j >= 0
		    && b2n_sigbit(nenn) >= sm; j--) {
@


1.17
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.16 2004/06/14 09:55:41 ho Exp $	 */
d222 1
a222 1
		     j > 0; j--) {
@


1.16
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.15 2004/05/23 18:17:56 hshoexer Exp $	 */
d138 1
a138 1
		memset(n->limp + old, 0, size - CHUNK_BYTES * old);
d216 1
a216 1
	memset(n->limp, 0, CHUNK_BYTES * n->chunks);
d429 1
a429 1
		memset(d->limp, 0, CHUNK_BYTES * maj);
d647 1
a647 1
	memset(q->limp, 0, CHUNK_BYTES * q->chunks);
@


1.15
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.14 2004/04/15 18:39:26 deraadt Exp $	 */
d89 2
a90 1
		CHUNK_TYPE m = (((1 << ((bits & CHUNK_MASK) - 1)) - 1) << 1) | 1;
d220 3
a222 2
		for (j = (i == 0 ? ((len - 1) % CHUNK_BYTES) + 1 : CHUNK_BYTES);
		    j > 0; j--) {
d421 2
a422 2
	add = (!(bits & CHUNK_MASK) || ((bits & CHUNK_MASK) + min) > CHUNK_MASK)
	    ? 1 : 0;
d478 2
a479 1
	memmove(d->limp, tmp->limp + maj + (min ? 1 : 0), CHUNK_BYTES * newsize);
d552 2
a553 1
	if (b2n_resize(t, 2 * maj + ((CHUNK_MASK + 2 * min) >> CHUNK_SHIFTS))) {
d1042 2
a1043 1
		memcpy(d->limp + i, a->limp + i, CHUNK_BYTES * (a->chunks - i));
d1078 2
a1079 1
		memcpy(d->limp + i, a->limp + i, CHUNK_BYTES * (a->chunks - i));
@


1.14
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: math_2n.c,v 1.13 2004/04/07 22:45:49 ho Exp $	 */
d68 1
a68 1
static          u_int8_t
d89 1
a89 1
		CHUNK_TYPE      m = (((1 << ((bits & CHUNK_MASK) - 1)) - 1) << 1) | 1;
d172 1
a172 1
	int             i, chunks;
d196 1
a196 1
	int             i, j, w, len, chunks;
d219 2
a220 2
		for (j = (i == 0 ? ((len - 1) % CHUNK_BYTES) + 1 : CHUNK_BYTES); j > 0;
		     j--) {
d284 2
a285 1
		for (j = (i == 0 ? left - 1 : CHUNK_BYTES - 1); j >= 0 && k < sz - 3; j--)
d287 1
a287 1
			 buffer[2 * j] != '0' || buffer[2 * j + 1] != '0') {
d303 1
a303 1
	int             i, j;
d371 2
a372 2
	int             sn, sm;
	int             i;
d394 1
a394 1
	int             i = 0;
d420 1
a420 1
		? 1 : 0;
d452 2
a453 2
	int             maj, min, size = n->chunks, newsize;
	b2n_ptr         tmp;
d488 2
a489 2
	int             i, j;
	b2n_t           tmp, tmp2;
d541 2
a542 2
	int             i, j, maj, min, bits, chunk;
	b2n_t           t;
d584 2
a585 2
	b2n_t           r;
	int             rv;
d596 2
a597 2
	b2n_t           q;
	int             rv;
d608 3
a610 3
	int             i, j, len, bits;
	u_int32_t       sm, sn;
	b2n_t           nenn, div, shift, mask;
d655 2
a656 2
		for (j = (i == len ? bits : CHUNK_MASK); j >= 0 && b2n_sigbit(nenn) >= sm;
		     j--) {
d689 1
a689 1
	int             bits, size;
d710 1
a710 1
	b2n_t           g, h;
d740 1
a740 1
	b2n_t           a;
d760 1
a760 1
	b2n_t           s0, s1, s2, q, r0, r1;
d827 2
a828 2
	int             i, m = b2n_sigbit(p) - 1;
	b2n_t           h;
d860 2
a861 2
	int             i, m = b2n_sigbit(p) - 1;
	b2n_t           h;
d898 2
a899 2
	int             i, m = b2n_sigbit(ip) - 1;
	b2n_t           w, p, temp, z;
d964 1
a964 1
	b2n_t           u, b;
d1009 3
a1011 3
	int             i, carry;
	b2n_ptr         a, b;
	b2n_t           d;
d1051 2
a1052 2
	int             i, carry;
	b2n_t           d;
d1086 1
a1086 1
	b2n_t           d;
@


1.13
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: math_2n.c,v 1.12 2003/06/03 14:28:16 ho Exp $	*/
/*	$EOM: math_2n.c,v 1.15 1999/04/20 09:23:30 niklas Exp $	*/
d51 1
a51 1
static u_int8_t hex2int (char);
d53 3
a55 3
static char int2hex[] = "0123456789abcdef";
CHUNK_TYPE b2n_mask[CHUNK_BITS] = {
  0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
d57 1
a57 1
  0x0100,0x0200,0x0400,0x0800,0x1000,0x2000,0x4000,0x8000,
d59 4
a62 4
  0x00010000,0x00020000,0x00040000,0x00080000,
  0x00100000,0x00200000,0x00400000,0x00800000,
  0x01000000,0x02000000,0x04000000,0x08000000,
  0x10000000,0x20000000,0x40000000,0x80000000,
d68 2
a69 2
static u_int8_t
hex2int (char c)
d71 4
a74 4
  if (c <= '9')
    return c - '0';
  if (c <= 'f')
    return 10 + c - 'a';
d76 1
a76 1
  return 0;
d80 1
a80 1
b2n_random (b2n_ptr n, u_int32_t bits)
d82 2
a83 2
  if (b2n_resize (n, (CHUNK_MASK + bits) >> CHUNK_SHIFTS))
    return -1;
d85 1
a85 1
  getrandom ((u_int8_t *)n->limp, CHUNK_BYTES * n->chunks);
d87 7
a93 9
  /* Get the number of significant bits right */
  if (bits & CHUNK_MASK)
    {
      CHUNK_TYPE m = (((1 << ((bits & CHUNK_MASK)-1)) - 1) << 1) | 1;
      n->limp[n->chunks-1] &= m;
    }

  n->dirty = 1;
  return 0;
d99 1
a99 1
b2n_init (b2n_ptr n)
d101 2
a102 2
  n->chunks = 0;
  n->limp = 0;
d106 1
a106 1
b2n_clear (b2n_ptr n)
d108 2
a109 2
  if (n->limp)
    free (n->limp);
d113 1
a113 1
b2n_resize (b2n_ptr n, unsigned int chunks)
d115 3
a117 3
  size_t old = n->chunks;
  size_t size;
  CHUNK_TYPE *new;
d119 2
a120 2
  if (chunks == 0)
    chunks = 1;
d122 2
a123 2
  if (chunks == old)
    return 0;
d125 1
a125 1
  size = CHUNK_BYTES * chunks;
d127 3
a129 3
  new = realloc (n->limp, size);
  if (!new)
    return -1;
d131 4
a134 4
  n->limp = new;
  n->chunks = chunks;
  n->bits = chunks << CHUNK_SHIFTS;
  n->dirty = 1;
d136 2
a137 2
  if (chunks > old)
    memset (n->limp + old, 0, size - CHUNK_BYTES * old);
d139 1
a139 1
  return 0;
d145 1
a145 1
b2n_set (b2n_ptr d, b2n_ptr s)
d147 2
a148 2
  if (d == s)
    return 0;
d150 7
a156 7
  b2n_sigbit (s);
  if (b2n_resize (d, (CHUNK_MASK + s->bits) >> CHUNK_SHIFTS))
    return -1;
  memcpy (d->limp, s->limp, CHUNK_BYTES * d->chunks);
  d->bits = s->bits;
  d->dirty = s->dirty;
  return 0;
d160 1
a160 1
b2n_set_null (b2n_ptr n)
d162 4
a165 4
  if (b2n_resize (n, 1))
    return -1;
  n->limp[0] = n->bits = n->dirty = 0;
  return 0;
d169 1
a169 1
b2n_set_ui (b2n_ptr n, unsigned int val)
d172 1
a172 1
  int i, chunks;
d174 1
a174 1
  chunks = (CHUNK_BYTES - 1 + sizeof (val)) / CHUNK_BYTES;
d176 2
a177 2
  if (b2n_resize (n, chunks))
      return -1;
d179 4
a182 5
  for (i = 0; i < chunks; i++)
    {
      n->limp[i] = val & CHUNK_BMASK;
      val >>= CHUNK_BITS;
    }
d184 3
a186 3
  if (b2n_resize (n, 1))
    return -1;
  n->limp[0] = val;
d188 2
a189 2
  n->dirty = 1;
  return 0;
d194 1
a194 1
b2n_set_str (b2n_ptr n, char *str)
d196 2
a197 2
  int i, j, w, len, chunks;
  CHUNK_TYPE tmp;
d199 2
a200 2
  if (strncasecmp (str, "0x", 2))
    return -1;
d202 24
a225 26
  /* Make the hex string even lengthed */
  len = strlen (str) - 2;
  if (len & 1)
    {
      len ++;
      str ++;
    }
  else
    str += 2;

  len /= 2;

  chunks = (CHUNK_BYTES - 1 + len) / CHUNK_BYTES;
  if (b2n_resize (n, chunks))
    return -1;
  memset (n->limp, 0, CHUNK_BYTES * n->chunks);

  for (w = 0, i = 0; i < chunks; i++)
    {
      tmp = 0;
      for (j = (i == 0 ? ((len - 1) % CHUNK_BYTES) + 1 : CHUNK_BYTES); j > 0;
	   j--)
	{
	  tmp <<= 8;
	  tmp |= (hex2int (str[w]) << 4) | hex2int (str[w + 1]);
	  w += 2;
a226 2
      n->limp[chunks - 1 - i] = tmp;
    }
d228 2
a229 2
  n->dirty = 1;
  return 0;
d234 1
a234 1
b2n_print (b2n_ptr n)
d236 26
a261 62
  int i, j, w, flag = 0;
  int left;
  char buffer[2 * CHUNK_BYTES];
  CHUNK_TYPE tmp;

  left = ((((7 + b2n_sigbit (n)) >> 3) - 1) % CHUNK_BYTES) + 1;
  printf ("0x");
  for (i = 0; i < n->chunks; i++)
    {
      tmp = n->limp[n->chunks - 1 - i];
      memset (buffer, '0', sizeof (buffer));
      for (w = 0, j = (i == 0 ? left : CHUNK_BYTES); j > 0; j--)
	{
	  buffer[w++] = int2hex[(tmp >> 4) & 0xf];
	  buffer[w++] = int2hex[tmp & 0xf];
	  tmp >>= 8;
	}

      for (j = (i == 0 ? left - 1: CHUNK_BYTES - 1); j >= 0; j--)
	if (flag || (i == n->chunks - 1 && j == 0) ||
	    buffer[2 * j] != '0' || buffer[2 * j + 1] != '0')
	  {
	    putchar (buffer[2 * j]);
	    putchar (buffer[2 * j + 1]);
	    flag = 1;
	  }
    }
  printf ("\n");
}

int
b2n_snprint (char *buf, size_t sz, b2n_ptr n)
{
  int i, j, w, flag = 0;
  size_t k;
  int left;
  char buffer[2 * CHUNK_BYTES];
  CHUNK_TYPE tmp;

  left = ((((7 + b2n_sigbit (n)) >> 3) - 1) % CHUNK_BYTES) + 1;

  k = strlcpy (buf, "0x", sz);
  for (i = 0; i < n->chunks && k < sz - 1; i++)
    {
      tmp = n->limp[n->chunks - 1 - i];
      memset (buffer, '0', sizeof (buffer));
      for (w = 0, j = (i == 0 ? left : CHUNK_BYTES); j > 0; j--)
	{
	  buffer[w++] = int2hex[(tmp >> 4) & 0xf];
	  buffer[w++] = int2hex[tmp & 0xf];
	  tmp >>= 8;
	}

      for (j = (i == 0 ? left - 1: CHUNK_BYTES - 1); j >= 0 && k < sz - 3; j--)
	if (flag || (i == n->chunks - 1 && j == 0) ||
	    buffer[2 * j] != '0' || buffer[2 * j + 1] != '0')
	  {
	    buf[k++] = buffer[2 * j];
	    buf[k++] = buffer[2 * j + 1];
	    flag = 1;
	  }
    }
d263 32
a294 2
  buf[k++] = 0;
  return k;
d300 1
a300 1
b2n_sigbit (b2n_ptr n)
d302 1
a302 1
  int i, j;
d304 2
a305 2
  if (!n->dirty)
    return n->bits;
d307 3
a309 3
  for (i = n->chunks - 1; i > 0; i--)
    if (n->limp[i])
      break;
d311 2
a312 2
  if (!n->limp[i])
    return 0;
d314 3
a316 3
  for (j = CHUNK_MASK; j > 0; j--)
    if (n->limp[i] & b2n_mask[j])
      break;
d318 3
a320 3
  n->bits = (i << CHUNK_SHIFTS) + j + 1;
  n->dirty = 0;
  return n->bits;
d325 1
a325 1
b2n_add (b2n_ptr d, b2n_ptr a, b2n_ptr b)
d327 8
a334 2
  int i;
  b2n_ptr bmin, bmax;
d336 2
a337 2
  if (!b2n_cmp_null (a))
    return b2n_set (d, b);
d339 25
a363 33
  if (!b2n_cmp_null (b))
    return b2n_set (d, a);

  bmin = B2N_MIN (a,b);
  bmax = B2N_MAX (a,b);

  if (b2n_resize (d, bmax->chunks))
    return -1;

  for (i = 0; i < bmin->chunks; i++)
      d->limp[i] = bmax->limp[i] ^ bmin->limp[i];

  /*
   * If d is not bmax, we have to copy the rest of the bytes, and also
   * need to adjust to number of relevant bits.
   */
  if (d != bmax)
    {
      for ( ; i < bmax->chunks; i++)
	  d->limp[i] = bmax->limp[i];

      d->bits = bmax->bits;
    }

  /*
   * Help to converse memory. When the result of the addition is zero
   * truncate the used amount of memory.
   */
  if (d != bmax && !b2n_cmp_null (d))
    return b2n_set_null (d);
  else
    d->dirty = 1;
  return 0;
d368 1
a368 1
b2n_cmp (b2n_ptr n, b2n_ptr m)
d370 2
a371 2
  int sn, sm;
  int i;
d373 2
a374 2
  sn = b2n_sigbit (n);
  sm = b2n_sigbit (m);
d376 4
a379 4
  if (sn > sm)
    return 1;
  if (sn < sm)
    return -1;
d381 5
a385 5
  for (i = n->chunks-1; i >= 0; i--)
    if (n->limp[i] > m->limp[i])
      return 1;
    else if (n->limp[i] < m->limp[i])
      return -1;
d387 1
a387 1
  return 0;
d391 1
a391 1
b2n_cmp_null (b2n_ptr a)
d393 1
a393 1
  int i = 0;
d395 5
a399 6
  do
    {
      if (a->limp[i])
	return 1;
    }
  while (++i < a->chunks);
d401 1
a401 1
  return 0;
d406 1
a406 1
b2n_lshift (b2n_ptr d, b2n_ptr n, unsigned int s)
d408 37
a444 38
  int i, maj, min, chunks;
  u_int16_t bits = b2n_sigbit (n), add;
  CHUNK_TYPE *p, *op;

  if (!s)
    return b2n_set (d, n);

  maj = s >> CHUNK_SHIFTS;
  min = s & CHUNK_MASK;

  add = (!(bits & CHUNK_MASK) || ((bits & CHUNK_MASK) + min) > CHUNK_MASK)
    ? 1 : 0;
  chunks = n->chunks;
  if (b2n_resize (d, chunks + maj + add))
    return -1;
  memmove (d->limp + maj, n->limp, CHUNK_BYTES * chunks);

  if (maj)
    memset (d->limp, 0, CHUNK_BYTES * maj);
  if (add)
    d->limp[d->chunks - 1] = 0;

  /* If !min there are no bit shifts, we are done */
  if (!min)
    return 0;

  op = p = &d->limp[d->chunks - 1];
  for (i = d->chunks - 2; i >= maj; i--)
    {
      op--;
      *p = (*p << min) | (*op >> (CHUNK_BITS - min));
      p--;
    }
  *p <<= min;

  d->dirty = 0;
  d->bits = bits + (maj << CHUNK_SHIFTS) + min;
  return 0;
d449 1
a449 1
b2n_rshift (b2n_ptr d, b2n_ptr n, unsigned int s)
d451 5
a455 2
  int maj, min, size = n->chunks, newsize;
  b2n_ptr tmp;
d457 1
a457 2
  if (!s)
    return b2n_set (d, n);
d459 1
a459 1
  maj = s >> CHUNK_SHIFTS;
d461 2
a462 1
  newsize = size - maj;
d464 4
a467 2
  if (size < maj)
    return b2n_set_null (d);
d469 5
a473 5
  min = (CHUNK_BITS - (s & CHUNK_MASK)) & CHUNK_MASK;
  if (min)
    {
      if ((b2n_sigbit (n) & CHUNK_MASK) > (u_int32_t)min)
	newsize++;
d475 3
a477 10
      if (b2n_lshift (d, n, min))
	return -1;
      tmp = d;
    }
  else
    tmp = n;

  memmove (d->limp, tmp->limp + maj + (min ? 1 : 0), CHUNK_BYTES * newsize);
  if (b2n_resize (d, newsize))
    return -1;
d479 2
a480 2
  d->bits = tmp->bits - ((maj + (min ? 1 : 0)) << CHUNK_SHIFTS);
  return 0;
d485 1
a485 1
b2n_mul (b2n_ptr d, b2n_ptr n, b2n_ptr m)
d487 5
a491 2
  int i, j;
  b2n_t tmp, tmp2;
d493 33
a525 2
  if (!b2n_cmp_null (m) || !b2n_cmp_null (n))
    return b2n_set_null (d);
d527 4
a530 40
  if (b2n_sigbit (m) == 1)
    return b2n_set (d, n);

  if (b2n_sigbit (n) == 1)
    return b2n_set (d, m);

  b2n_init (tmp);
  b2n_init (tmp2);

  if (b2n_set (tmp, B2N_MAX (n, m)))
    goto fail;
  if (b2n_set (tmp2, B2N_MIN (n, m)))
    goto fail;

  if (b2n_set_null (d))
    goto fail;

  for (i = 0; i < tmp2->chunks; i++)
    if (tmp2->limp[i])
      for (j = 0; j < CHUNK_BITS; j++)
	{
	  if (tmp2->limp[i] & b2n_mask[j])
	    if (b2n_add (d, d, tmp))
	      goto fail;
	
	  if (b2n_lshift (tmp, tmp, 1))
	    goto fail;
	}
    else
      if (b2n_lshift (tmp, tmp, CHUNK_BITS))
	goto fail;

  b2n_clear (tmp);
  b2n_clear (tmp2);
  return 0;

 fail:
  b2n_clear (tmp);
  b2n_clear (tmp2);
  return -1;
d538 1
a538 1
b2n_square (b2n_ptr d, b2n_ptr n)
d540 2
a541 2
  int i, j, maj, min, bits, chunk;
  b2n_t t;
d543 31
a573 35
  maj = b2n_sigbit (n);
  min = maj & CHUNK_MASK;
  maj = (maj + CHUNK_MASK) >> CHUNK_SHIFTS;

  b2n_init (t);
  if (b2n_resize (t, 2 * maj + ((CHUNK_MASK + 2 * min) >> CHUNK_SHIFTS)))
    {
      b2n_clear (t);
      return -1;
    }

  chunk = 0;
  bits = 0;

  for (i = 0; i < maj; i++)
    if (n->limp[i])
      for (j = 0; j < CHUNK_BITS; j++)
	{
	  if (n->limp[i] & b2n_mask[j])
	    t->limp[chunk] ^= b2n_mask[bits];

	  bits += 2;
	  if (bits >= CHUNK_BITS)
	    {
	      chunk++;
	      bits &= CHUNK_MASK;
	    }
	}
    else
      chunk += 2;

  t->dirty = 1;
  B2N_SWAP (d, t);
  b2n_clear (t);
  return 0;
d581 1
a581 1
b2n_div_q (b2n_ptr d, b2n_ptr n, b2n_ptr m)
d583 2
a584 2
  b2n_t r;
  int rv;
d586 4
a589 4
  b2n_init (r);
  rv = b2n_div (d, r, n, m);
  b2n_clear (r);
  return rv;
d593 1
a593 1
b2n_div_r (b2n_ptr r, b2n_ptr n, b2n_ptr m)
d595 2
a596 2
  b2n_t q;
  int rv;
d598 4
a601 4
  b2n_init (q);
  rv = b2n_div (q, r, n, m);
  b2n_clear (q);
  return rv;
d605 1
a605 1
b2n_div (b2n_ptr q, b2n_ptr r, b2n_ptr n, b2n_ptr m)
d607 3
a609 3
  int i, j, len, bits;
  u_int32_t sm, sn;
  b2n_t nenn, div, shift, mask;
d611 64
a674 7
  /* If Teiler > Zaehler, the result is 0 */
  if ((sm = b2n_sigbit (m)) > (sn = b2n_sigbit (n)))
    {
      if (b2n_set_null (q))
	return -1;
      return b2n_set (r, n);
    }
d676 5
a680 7
  if (sm == 0)
    /* Division by Zero */
    return -1;
  else if (sm == 1)
    {
      /* Division by the One-Element */
      if (b2n_set (q, n))
a681 61
      return b2n_set_null (r);
    }

  b2n_init (nenn);
  b2n_init (div);
  b2n_init (shift);
  b2n_init (mask);

  if (b2n_set (nenn, n))
    goto fail;
  if (b2n_set (div, m))
    goto fail;
  if (b2n_set (shift, m))
    goto fail;
  if (b2n_set_ui (mask, 1))
    goto fail;

  if (b2n_resize (q, (sn - sm + CHUNK_MASK) >> CHUNK_SHIFTS))
    goto fail;
  memset (q->limp, 0, CHUNK_BYTES * q->chunks);

  if (b2n_lshift (shift, shift, sn - sm))
    goto fail;
  if (b2n_lshift (mask, mask, sn - sm))
    goto fail;

  /* Number of significant octets */
  len = (sn - 1) >> CHUNK_SHIFTS;
  /* The first iteration is done over the relevant bits */
  bits = (CHUNK_MASK + sn) & CHUNK_MASK;
  for (i = len; i >= 0 && b2n_sigbit (nenn) >= sm; i--)
    for (j = (i == len ? bits : CHUNK_MASK); j >= 0 && b2n_sigbit (nenn) >= sm;
	 j--)
      {
	if (nenn->limp[i] & b2n_mask[j])
	  {
	    if (b2n_sub (nenn, nenn, shift))
	      goto fail;
	    if (b2n_add (q, q, mask))
	      goto fail;
	  }
	if (b2n_rshift (shift, shift, 1))
	  goto fail;
	if (b2n_rshift (mask, mask, 1))
	  goto fail;
      }

  B2N_SWAP (r, nenn);

  b2n_clear (nenn);
  b2n_clear (div);
  b2n_clear (shift);
  b2n_clear (mask);
  return 0;

fail:
  b2n_clear (nenn);
  b2n_clear (div);
  b2n_clear (shift);
  b2n_clear (mask);
  return -1;
d686 1
a686 1
b2n_mod (b2n_ptr m, b2n_ptr n, b2n_ptr p)
d688 1
a688 1
  int bits, size;
d690 2
a691 2
  if (b2n_div_r (m, n, p))
    return -1;
d693 7
a699 7
  bits = b2n_sigbit (m);
  size = ((CHUNK_MASK + bits) >> CHUNK_SHIFTS);
  if (size == 0)
    size = 1;
  if (m->chunks > size)
    if (b2n_resize (m, size))
      return -1;
d701 3
a703 3
  m->bits = bits;
  m->dirty = 0;
  return 0;
d707 1
a707 1
b2n_gcd (b2n_ptr e, b2n_ptr go, b2n_ptr ho)
d709 1
a709 1
  b2n_t g, h;
d711 6
a716 6
  b2n_init (g);
  b2n_init (h);
  if (b2n_set (g, go))
    goto fail;
  if (b2n_set (h, ho))
    goto fail;
d718 5
a722 6
  while (b2n_cmp_null (h))
    {
      if (b2n_mod (g, g, h))
	goto fail;
      B2N_SWAP (g, h);
    }
d724 1
a724 1
  B2N_SWAP (e, g);
d726 3
a728 3
  b2n_clear (g);
  b2n_clear (h);
  return 0;
d731 3
a733 3
  b2n_clear (g);
  b2n_clear (h);
  return -1;
d737 1
a737 1
b2n_mul_inv (b2n_ptr ga, b2n_ptr be, b2n_ptr p)
d739 1
a739 1
  b2n_t a;
d741 3
a743 3
  b2n_init (a);
  if (b2n_set_ui (a, 1))
    goto fail;
d745 2
a746 2
  if (b2n_div_mod (ga, a, be, p))
    goto fail;
d748 2
a749 2
  b2n_clear (a);
  return 0;
d751 3
a753 3
 fail:
  b2n_clear (a);
  return -1;
d757 1
a757 1
b2n_div_mod (b2n_ptr ga, b2n_ptr a, b2n_ptr be, b2n_ptr p)
d759 1
a759 1
  b2n_t s0, s1, s2, q, r0, r1;
d761 32
a792 3
  /* There is no multiplicative inverse to Null.  */
  if (!b2n_cmp_null (be))
    return b2n_set_null (ga);
d794 4
a797 29
  b2n_init (s0);
  b2n_init (s1);
  b2n_init (s2);
  b2n_init (r0);
  b2n_init (r1);
  b2n_init (q);

  if (b2n_set (r0, p))
    goto fail;
  if (b2n_set (r1, be))
    goto fail;

  if (b2n_set_null (s0))
    goto fail;
  if (b2n_set (s1, a))
    goto fail;

  while (b2n_cmp_null (r1))
    {
      if (b2n_div (q, r0, r0, r1))
	goto fail;
      B2N_SWAP (r0, r1);

      if (b2n_mul (s2, q, s1))
	goto fail;
      if (b2n_mod (s2, s2, p))
	goto fail;
      if (b2n_sub (s2, s0, s2))
	goto fail;
d799 7
a805 12
      B2N_SWAP (s0, s1);
      B2N_SWAP (s1, s2);
    }
  B2N_SWAP (ga, s0);

  b2n_clear (s0);
  b2n_clear (s1);
  b2n_clear (s2);
  b2n_clear (r0);
  b2n_clear (r1);
  b2n_clear (q);
  return 0;
d808 7
a814 7
  b2n_clear (s0);
  b2n_clear (s1);
  b2n_clear (s2);
  b2n_clear (r0);
  b2n_clear (r1);
  b2n_clear (q);
  return -1;
d824 1
a824 1
b2n_trace (b2n_ptr ho, b2n_ptr a, b2n_ptr p)
d826 20
a845 2
  int i, m = b2n_sigbit (p) - 1;
  b2n_t h;
d847 3
a849 22
  b2n_init (h);
  if (b2n_set (h, a))
    goto fail;

  for (i = 0; i < m - 1; i++)
    {
      if (b2n_square (h, h))
	goto fail;
      if (b2n_mod (h, h, p))
	goto fail;

      if (b2n_add (h, h, a))
	goto fail;
    }
  B2N_SWAP (ho, h);

  b2n_clear (h);
  return 0;

 fail:
  b2n_clear (h);
  return -1;
d857 1
a857 1
b2n_halftrace (b2n_ptr ho, b2n_ptr a, b2n_ptr p)
d859 20
a878 2
  int i, m = b2n_sigbit (p) - 1;
  b2n_t h;
d880 8
a887 27
  b2n_init (h);
  if (b2n_set (h, a))
    goto fail;

  for (i = 0; i < (m - 1) / 2; i++)
    {
      if (b2n_square (h, h))
	goto fail;
      if (b2n_mod (h, h, p))
	goto fail;
      if (b2n_square (h, h))
	goto fail;
      if (b2n_mod (h, h, p))
	goto fail;

      if (b2n_add (h, h, a))
	goto fail;
    }

  B2N_SWAP (ho, h);

  b2n_clear (h);
  return 0;

 fail:
  b2n_clear (h);
  return -1;
d895 1
a895 1
b2n_sqrt (b2n_ptr zo, b2n_ptr b, b2n_ptr ip)
d897 5
a901 2
  int i, m = b2n_sigbit (ip) - 1;
  b2n_t w, p, temp, z;
d903 47
a949 2
  if (!b2n_cmp_null (b))
    return b2n_set_null (z);
d951 6
a956 56
  if (m & 1)
    return b2n_halftrace (zo, b, ip);

  b2n_init (z);
  b2n_init (w);
  b2n_init (p);
  b2n_init (temp);

  do
    {
      if (b2n_random (p, m))
	goto fail;
      if (b2n_set_null (z))
	goto fail;
      if (b2n_set (w, p))
	goto fail;

      for (i = 1; i < m; i++)
	{
	  if (b2n_square (z, z))	/* z**2 */
	    goto fail;
	  if (b2n_mod (z, z, ip))
	    goto fail;

	  if (b2n_square (w, w))	/* w**2 */
	    goto fail;
	  if (b2n_mod (w, w, ip))
	    goto fail;

	  if (b2n_mul (temp, w, b))	/* w**2 * b */
	    goto fail;
	  if (b2n_mod (temp, temp, ip))
	    goto fail;
	  if (b2n_add (z, z, temp))	/* z**2 + w**2 + b */
	    goto fail;

	  if (b2n_add (w, w, p))	/* w**2 + p */
	    goto fail;
	}
    }
  while (!b2n_cmp_null (w));

  B2N_SWAP (zo, z);

  b2n_clear (w);
  b2n_clear (p);
  b2n_clear (temp);
  b2n_clear (z);
  return 0;

 fail:
  b2n_clear (w);
  b2n_clear (p);
  b2n_clear (temp);
  b2n_clear (z);
  return -1;
d961 1
a961 1
b2n_exp_mod (b2n_ptr d, b2n_ptr b0, u_int32_t e, b2n_ptr p)
d963 1
a963 1
  b2n_t u, b;
d965 31
a995 33
  b2n_init (u);
  b2n_init (b);
  if (b2n_set_ui (u, 1))
    goto fail;
  if (b2n_mod (b, b0, p))
    goto fail;

  while (e)
    {
      if (e & 1)
	{
	  if (b2n_mul (u, u, b))
	    goto fail;
	  if (b2n_mod (u, u, p))
	    goto fail;
	}
      if (b2n_square (b, b))
	goto fail;
      if (b2n_mod (b, b, p))
	goto fail;
      e >>= 1;
    }

  B2N_SWAP (d, u);

  b2n_clear (u);
  b2n_clear (b);
  return 0;

 fail:
  b2n_clear (u);
  b2n_clear (b);
  return -1;
d1006 1
a1006 1
b2n_nadd (b2n_ptr d0, b2n_ptr a0, b2n_ptr b0)
d1008 22
a1029 31
  int i, carry;
  b2n_ptr a, b;
  b2n_t d;

  if (!b2n_cmp_null (a0))
    return b2n_set (d0, b0);

  if (!b2n_cmp_null (b0))
    return b2n_set (d0, a0);

  b2n_init (d);
  a = B2N_MAX (a0, b0);
  b = B2N_MIN (a0, b0);

  if (b2n_resize (d, a->chunks + 1))
    {
      b2n_clear (d);
      return -1;
    }

  for (carry = i = 0; i < b->chunks; i++)
    {
      d->limp[i] = a->limp[i] + b->limp[i] + carry;
      carry = (d->limp[i] < a->limp[i] ? 1 : 0);
    }

  for (; i < a->chunks && carry; i++)
    {
      d->limp[i] = a->limp[i] + carry;
      carry = (d->limp[i] < a->limp[i] ? 1 : 0);
    }
d1031 4
a1034 2
  if (i < a->chunks)
      memcpy (d->limp + i, a->limp + i, CHUNK_BYTES * (a->chunks - i));
d1036 2
a1037 2
  d->dirty = 1;
  B2N_SWAP (d0, d);
d1039 5
a1043 2
  b2n_clear (d);
  return 0;
d1048 1
a1048 1
b2n_nsub (b2n_ptr d0, b2n_ptr a, b2n_ptr b)
d1050 2
a1051 2
  int i, carry;
  b2n_t d;
d1053 2
a1054 2
  if (b2n_cmp (a, b) <= 0)
    return b2n_set_null (d0);
d1056 9
a1064 6
  b2n_init (d);
  if (b2n_resize (d, a->chunks))
    {
      b2n_clear (d);
      return -1;
    }
d1066 4
a1069 11
  for (carry = i = 0; i < b->chunks; i++)
    {
      d->limp[i] = a->limp[i] - b->limp[i] - carry;
      carry = (d->limp[i] > a->limp[i] ? 1 : 0);
    }

  for (; i < a->chunks && carry; i++)
    {
      d->limp[i] = a->limp[i] - carry;
      carry = (d->limp[i] > a->limp[i] ? 1 : 0);
    }
d1071 2
a1072 2
  if (i < a->chunks)
      memcpy (d->limp + i, a->limp + i, CHUNK_BYTES*(a->chunks - i));
d1074 1
a1074 1
  d->dirty = 1;
d1076 1
a1076 1
  B2N_SWAP (d0, d);
d1078 2
a1079 2
  b2n_clear (d);
  return 0;
d1083 1
a1083 1
b2n_3mul (b2n_ptr d0, b2n_ptr e)
d1085 1
a1085 1
  b2n_t d;
d1087 3
a1089 3
  b2n_init (d);
  if (b2n_lshift (d, e, 1))
    goto fail;
d1091 2
a1092 2
  if (b2n_nadd (d0, d, e))
    goto fail;
d1094 2
a1095 2
  b2n_clear (d);
  return 0;
d1097 3
a1099 3
 fail:
  b2n_clear (d);
  return -1;
@


1.12
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_2n.c,v 1.11 2002/07/05 11:08:13 ho Exp $	*/
d117 2
a118 2
  int old = n->chunks;
  int size;
d276 2
a277 1
  int i, k, j, w, flag = 0;
d484 1
a484 1
      if ((b2n_sigbit (n) & CHUNK_MASK) > min)
d632 2
a633 1
  int sn, sm, i, j, len, bits;
@


1.11
log
@gcc 3.1 nits. Pointed out by David Krause.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_2n.c,v 1.10 2002/06/09 08:13:06 todd Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.10
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: math_2n.c,v 1.9 2002/01/23 17:43:24 ho Exp $	*/
d458 2
a459 1
      *p-- = (*p << min) | (*op >> (CHUNK_BITS - min));
@


1.9
log
@Another strcpy gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_2n.c,v 1.8 2001/04/09 22:09:52 ho Exp $	*/
d42 1
a42 1
 * 
d131 1
a131 1
  
d320 1
a320 1
  
d334 1
a334 1
  
d355 1
a355 1
    
d362 1
a362 1
  /* 
d368 1
a368 1
      for ( ; i < bmax->chunks; i++) 
d370 1
a370 1
      
d378 1
a378 1
  if (d != bmax && !b2n_cmp_null (d)) 
d405 1
a405 1
  
d447 1
a447 1
  if (add) 
d520 1
a520 1
  
d536 1
a536 1
	  if (tmp2->limp[i] & b2n_mask[j]) 
d539 1
a539 1
	  
d597 1
a597 1
 
d679 1
a679 1
  
d750 1
a750 1
  
d853 1
a853 1
 * The trace tells us if there do exist any square roots 
d855 1
a855 1
 * 2 - 2*Trace. 
d867 1
a867 1
  
d901 1
a901 1
  
d928 1
a928 1
 * Solving the equation: y**2 + y = b in GF(2**m) where ip is the 
d1010 1
a1010 1
  
d1043 1
a1043 1
 */ 
d1074 1
a1074 1
  
d1100 1
a1100 1
  
d1113 1
a1113 1
  
@


1.8
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: math_2n.c,v 1.7 1999/04/20 11:32:57 niklas Exp $	*/
d279 1
a279 1
b2n_sprint (char *buf, b2n_ptr n)
d288 2
a289 2
  strcpy (buf, "0x"); k = 2;
  for (i = 0; i < n->chunks; i++)
d300 1
a300 1
      for (j = (i == 0 ? left - 1: CHUNK_BYTES - 1); j >= 0; j--)
@


1.7
log
@math_2n.c: Merge with EOM 1.15
math_ec2n.c: Merge with EOM 1.9

author: niklas
Plug potential memory leaks in case of memory allocation errors
@
text
@d1 1
a1 1
/*	$OpenBSD: math_2n.c,v 1.6 1999/04/19 20:54:01 niklas Exp $	*/
d275 1
a275 1
  printf("\n");
@


1.7.6.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_2n.c,v 1.8 2001/04/09 22:09:52 ho Exp $	*/
d275 1
a275 1
  printf ("\n");
@


1.6
log
@./math_2n.c: Merge with EOM 1.14

reporting.  Math error propagation.  Allocate right
sizes.
@
text
@d1 2
a2 2
/*	$OpenBSD: math_2n.c,v 1.5 1999/04/05 21:01:23 niklas Exp $	*/
/*	$EOM: math_2n.c,v 1.14 1999/04/17 23:20:31 niklas Exp $	*/
d573 4
a576 1
    return -1;
@


1.5
log
@Merge with EOM 1.13
Style police.  No free(0).

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: math_2n.c,v 1.4 1999/02/26 03:46:18 niklas Exp $	*/
/*	$EOM: math_2n.c,v 1.13 1999/04/05 08:04:25 niklas Exp $	*/
d53 1
a54 1
#include "math_2n.h"
d56 1
a56 1
u_int8_t hex2int (char);
d72 2
a73 2
/* Misc */
u_int8_t
d84 1
a84 2

void
d87 2
a88 1
  b2n_resize (n, (CHUNK_MASK + bits) >> CHUNK_SHIFTS);
d100 1
d109 1
a109 1
  n->limp = NULL;
d119 1
a119 1
void
d130 1
a130 1
    return;
a133 1
  /* XXX - is there anything I can do here? */
d135 2
a136 2
  if (new == NULL)
    return;
d144 3
a146 1
      memset (n->limp + old, 0, size - CHUNK_BYTES*old);
d149 1
a149 1
/* Simple assignment functions */
d151 1
a151 1
void
d155 1
a155 1
    return;
d158 3
a160 2
  b2n_resize (d, (CHUNK_MASK + s->bits) >> CHUNK_SHIFTS);
  memcpy (d->limp, s->limp, CHUNK_BYTES*d->chunks);
d163 1
d166 1
a166 1
void
d169 2
a170 1
  b2n_resize (n, 1);
d172 1
d175 1
a175 1
void
d183 2
a184 1
  b2n_resize (n, chunks);
d192 2
a193 1
  b2n_resize (n, 1);
d197 1
d200 2
a201 3
/* Only takes hex at the moment */

void
d208 1
a208 1
    return;
d222 3
a224 2
  chunks = (CHUNK_BYTES - 1 + len)/CHUNK_BYTES;
  b2n_resize (n, chunks);
d230 2
a231 1
      for (j = (i == 0 ? ((len-1) % CHUNK_BYTES)+1 : CHUNK_BYTES); j > 0; j--)
d234 1
a234 1
	  tmp |= (hex2int(str[w]) << 4) | hex2int(str[w+1]);
d237 1
a237 1
      n->limp[chunks-1-i] = tmp;
d241 1
d244 1
a244 2
/* Output function, mainly for debugging perpurses */

d250 1
a250 1
  char buffer[2*CHUNK_BYTES];
d254 1
a254 1
  printf("0x");
d257 1
a257 1
      tmp = n->limp[n->chunks-1-i];
d261 2
a262 2
	  buffer[w++] = int2hex[(tmp >> 4) & 0xF];
	  buffer[w++] = int2hex[tmp & 0xF];
d268 1
a268 1
	    buffer[2*j] != '0' || buffer[2*j+1] != '0')
d270 2
a271 2
	    putchar (buffer[2*j]);
	    putchar (buffer[2*j+1]);
d283 1
a283 1
  char buffer[2*CHUNK_BYTES];
d291 1
a291 1
      tmp = n->limp[n->chunks-1-i];
d295 2
a296 2
	  buffer[w++] = int2hex[(tmp >> 4) & 0xF];
	  buffer[w++] = int2hex[tmp & 0xF];
d302 1
a302 1
	    buffer[2*j] != '0' || buffer[2*j+1] != '0')
d304 2
a305 2
	    buf[k++] = buffer[2*j];
	    buf[k++] = buffer[2*j+1];
d310 1
a310 1
  buf [k++] = 0;
d314 1
a314 1
/* Arithmetic functions */
d324 1
a324 1
  for (i = n->chunks-1; i > 0; i--)
d340 2
a341 6

/*
 * Addition on GF(2)[x] is nice, its just an XOR.
 */

void
d348 1
a348 4
    {
      b2n_set (d, b);
      return;
    }
d351 1
a351 4
    {
      b2n_set (d, a);
      return;
    }
d356 2
a357 1
  b2n_resize (d, bmax->chunks);
d379 1
a379 1
      b2n_set_null (d);
d382 1
d385 1
a385 5

/*
 * Compare two polynomials.
 */

d418 2
a419 1
    } while (++i < a->chunks);
d424 2
a425 5
/*
 * Left shift, needed for polynomial multiplication.
 */

void
d433 1
a433 4
    {
      b2n_set (d, n);
      return;
    }
d438 2
a439 1
  add = (!(bits&CHUNK_MASK) || ((bits&CHUNK_MASK) + min) > CHUNK_MASK) ? 1 : 0;
d441 2
a442 1
  b2n_resize (d, chunks + maj + add);
d448 1
a448 1
    d->limp[d->chunks-1] = 0;
d452 1
a452 1
    return;
d454 2
a455 2
  op = p = &d->limp[d->chunks-1];
  for (i = d->chunks-2; i >= maj; i--)
d464 1
d467 2
a468 5
/*
 * Right shift, needed for polynomial division.
 */

void
d475 1
a475 4
    {
      b2n_set (d, n);
      return;
    }
d482 1
a482 4
    {
      b2n_set_null (d);
      return;
    }
d490 2
a491 1
      b2n_lshift (d, n, min);
d498 2
a499 1
  b2n_resize (d, newsize);
d502 1
d505 2
a506 4
/*
 * Normal polynomial multiplication.
 */
void
d513 1
a513 4
    {
      b2n_set_null (d);
      return;
    }
d516 1
a516 4
    {
      b2n_set (d, n);
      return;
    }
d519 1
a519 4
    {
      b2n_set (d, m);
      return;
    }
d524 4
a527 2
  b2n_set (tmp, B2N_MAX (n, m));
  b2n_set (tmp2, B2N_MIN (n, m));
d529 2
a530 1
  b2n_set_null (d);
d537 2
a538 1
	    b2n_add (d, d, tmp);
d540 2
a541 1
	  b2n_lshift (tmp, tmp, 1);
d544 2
a545 1
      b2n_lshift (tmp, tmp, CHUNK_BITS);
d549 6
d561 1
a561 1
void
d572 2
a573 1
  b2n_resize (t, 2 * maj + ((CHUNK_MASK + 2 * min) >> CHUNK_SHIFTS));
d598 1
d605 1
a605 1
void
d609 1
d612 1
a612 1
  b2n_div (d, r, n, m);
d614 1
d617 1
a617 1
void
d621 1
d624 1
a624 1
  b2n_div (q, r, n, m);
d626 1
d629 1
a629 1
void
d638 3
a640 3
      b2n_set_null (q);
      b2n_set (r, n);
      return;
d645 1
a645 1
    return;
d649 3
a651 3
      b2n_set (q, n);
      b2n_set_null (r);
      return;
d659 8
a666 4
  b2n_set (nenn, n);
  b2n_set (div, m);
  b2n_set (shift, m);
  b2n_set_ui (mask, 1);
d668 2
a669 1
  b2n_resize (q, (sn - sm + CHUNK_MASK) >> CHUNK_SHIFTS);
d672 4
a675 2
  b2n_lshift (shift, shift, sn - sm);
  b2n_lshift (mask, mask, sn - sm);
d687 4
a690 2
	    b2n_sub (nenn, nenn, shift);
	    b2n_add (q, q, mask);
d692 4
a695 2
	b2n_rshift (shift, shift, 1);
	b2n_rshift (mask, mask, 1);
d704 8
d714 2
a715 4
/*
 * Functions for Operation on GF(2**n) ~= GF(2)[x]/p(x).
 */
void
d719 3
a721 1
  b2n_div_r (m, n, p);
d728 2
a729 1
      b2n_resize (m, size);
d733 1
d736 1
a736 1
void
a741 1
  b2n_set (g, go);
d743 4
a746 1
  b2n_set (h, ho);
d750 2
a751 1
      b2n_mod (g, g, h);
d759 6
d767 1
a767 1
void
d773 2
a774 1
  b2n_set_ui (a, 1);
d776 2
a777 1
  b2n_div_mod (ga, a, be, p);
d780 5
d787 1
a787 1
void
d793 2
a794 5
  if (!b2n_cmp_null(be))
    {
      b2n_set_null (ga);
      return;
    }
d803 9
a811 5
  b2n_set (r0, p);
  b2n_set (r1, be);

  b2n_set_null (s0);
  b2n_set (s1, a);
d815 2
a816 1
      b2n_div(q, r0, r0, r1);
d819 6
a824 3
      b2n_mul (s2, q, s1);
      b2n_mod (s2, s2, p);
      b2n_sub (s2, s0, s2);
d837 10
d855 1
a855 1
void
d862 2
a863 1
  b2n_set (h, a);
d867 4
a870 2
      b2n_square (h, h);
      b2n_mod (h, h, p);
d872 2
a873 1
      b2n_add (h, h, a);
d878 5
d889 1
a889 1
void
d896 2
a897 1
  b2n_set (h, a);
d901 8
a908 4
      b2n_square (h, h);
      b2n_mod (h, h, p);
      b2n_square (h, h);
      b2n_mod (h, h, p);
d910 2
a911 1
      b2n_add (h, h, a);
d917 5
d928 1
a928 1
void
d935 1
a935 4
    {
      b2n_set_null (z);
      return;
    }
d938 1
a938 4
    {
      b2n_halftrace (zo, b, ip);
      return;
    }
a943 8
  do {
    b2n_random (p, m);
    b2n_set_null (z);
    b2n_set (w, p);
    for (i = 1; i < m; i++)
      {
	b2n_square (z, z);	/* z**2 */
	b2n_mod (z, z, ip);
d945 8
a952 2
	b2n_square (w, w);	/* w**2 */
	b2n_mod (w, w, ip);
d954 18
a971 3
	b2n_mul (temp, w, b);   /* w**2 * b */
	b2n_mod (temp, temp, ip);
	b2n_add (z, z, temp);   /* z**2 + w**2 + b */
d973 5
a977 3
	b2n_add (w, w, p);	/* w**2 + p */
      }
  } while (!b2n_cmp_null (w));
d985 8
d995 2
a996 4
/*
 * Exponentiation modulo a polynomial.
 */
void
a1001 1
  b2n_set_ui (u, 1);
d1003 4
a1006 1
  b2n_mod (b, b0, p);
d1012 4
a1015 2
	  b2n_mul (u, u, b);
	  b2n_mod (u, u, p);
d1017 4
a1020 2
      b2n_square (b, b);
      b2n_mod (b, b, p);
d1025 1
d1028 6
d1042 2
a1043 4
/*
 * Normal addition behaves as Z_{2**n} and not F_{2**n}.
 */
void
d1051 1
a1051 4
    {
      b2n_set (d0, b0);
      return;
    }
d1054 1
a1054 4
    {
      b2n_set (d0, a0);
      return;
    }
d1060 5
a1064 1
  b2n_resize (d, a->chunks + 1);
d1085 1
d1088 2
a1089 4
/*
 * Very special sub, a > b.
 */
void
d1096 4
d1101 2
a1102 2
      b2n_set_null (d0);
      return;
a1103 3
  
  b2n_init (d);
  b2n_resize (d, a->chunks);
d1125 1
d1128 1
a1128 1
void
d1134 2
a1135 1
  b2n_lshift (d, e, 1);
d1137 5
a1141 1
  b2n_nadd (d0, d, e);
d1143 1
d1145 1
@


1.4
log
@Merge from the Ericsson repository
| revision 1.11
| date: 1999/02/25 11:39:12;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: math_2n.c,v 1.3 1998/11/17 11:10:16 niklas Exp $	*/
/*	$EOM: math_2n.c,v 1.11 1999/02/25 11:39:12 niklas Exp $	*/
d6 1
d114 2
a115 2
  /* XXX Does all systems deal with free (NULL) nicely?  */
  free (n->limp);
d136 1
a136 1
    return ;
d165 1
a165 1
  b2n_resize (n , 1);
d175 1
a175 1
  chunks = (CHUNK_BYTES - 1 + sizeof (val))/CHUNK_BYTES;
d177 1
a177 1
  b2n_resize (n, chunks );
d509 1
a509 1
  memmove (d->limp, tmp->limp+maj+(min ? 1 : 0), CHUNK_BYTES * newsize);
a517 1

a569 1

d581 1
a581 1
  b2n_resize (t, 2*maj + ((CHUNK_MASK + 2*min) >> CHUNK_SHIFTS));
d601 1
a601 1
	chunk += 2;
a611 1

d678 2
a679 1
    for (j = (i == len ? bits : CHUNK_MASK); j >= 0 && b2n_sigbit (nenn) >= sm; j--)
a689 1

d695 1
a697 1

a700 1

d723 4
a726 2
  b2n_init (g); b2n_set (g, go);
  b2n_init (h); b2n_set (h, ho);
d731 1
a731 1
      B2N_SWAP (g,h);
d746 1
a746 1
  b2n_set_ui (a,1);
d758 1
a758 1
  /* There is no multiplicative inverse to Null */
d765 5
a769 2
  b2n_init (s0); b2n_init (s1); b2n_init (s2);
  b2n_init (r0); b2n_init (r1);
d792 5
a796 2
  b2n_clear (s0); b2n_clear (s1); b2n_clear (s2);
  b2n_clear (r0); b2n_clear (r1);
a805 1

a830 1

d840 1
a840 1
  for (i = 0; i < (m - 1)/2; i++)
a858 1

a908 1

a911 1

a947 1

a951 1

d979 1
a979 1
  for ( ; i < a->chunks && carry; i++)
d986 1
a986 1
      memcpy (d->limp + i, a->limp + i, CHUNK_BYTES*(a->chunks - i));
a996 1

d1018 1
a1018 1
  for ( ; i < a->chunks && carry; i++)
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: math_2n.c,v 1.2 1998/11/15 00:44:00 niklas Exp $	*/
/*	$EOM: math_2n.c,v 1.10 1998/08/15 21:58:21 provos Exp $	*/
d49 2
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: math_2n.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: math_2n.c,v 1.10 1998/08/15 21:58:21 provos Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
