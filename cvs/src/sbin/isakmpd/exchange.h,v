head	1.35;
access;
symbols
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.34.0.12
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.8
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.4
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.32
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.30
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.26
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.24
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.22
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.20
	OPENBSD_5_0:1.33.0.18
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.16
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.14
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.10
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.12
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.8
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.6
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.30.0.4
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.20.0.4
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2017.09.18.07.42.52;	author mpi;	state Exp;
branches;
next	1.34;
commitid	Lvnu0EWkJAfJLeU7;

1.34
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Uu5nFG3wCl0LACBb;

1.33
date	2007.08.05.09.43.09;	author tom;	state Exp;
branches;
next	1.32;

1.32
date	2006.07.02.13.19.00;	author hshoexer;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.31.04.54.46;	author hshoexer;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.25.15.03.47;	author hshoexer;	state Exp;
branches;
next	1.29;

1.29
date	2005.01.31.10.07.59;	author hshoexer;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.23.11.13.14;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.03.21.23.51;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.11.09.50.43;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.05.05.59.43;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.31.20.23.52;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.24.03.59.55;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.27.12.03.32;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.26.12.12.51;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.07.06.59.46;	author niklas;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.06.08.20.49.44;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.07.17.21.54.39;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.07.07.22.09.53;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.04.30.11.47.11;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.04.27.21.14.04;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.04.19.21.03.35;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.04.05.20.58.28;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.04.02.01.08.41;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.03.31.01.51.05;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.02.26.03.38.22;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.12.21.01.02.23;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.10;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2001.05.08.12.45.22;	author ho;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Check for failures of exchange_establish_p{1,2}() and call the given
`finalize' function with the `fail' argument when this happen.

Introduce some sanity checks in exchange_free() to be able to call if
even if the data structure isn't completely initialized.

Plug memory leaks when exchange_establish() fails.  While here fix a
double free in one of the error paths.

Based on a diff from hshoexer@@, ok stsp@@, markus@@
@
text
@/* $OpenBSD: exchange.h,v 1.34 2015/01/16 06:39:58 deraadt Exp $	 */
/* $EOM: exchange.h,v 1.28 2000/09/28 12:54:28 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#ifndef _EXCHANGE_H_
#define _EXCHANGE_H_

#include <sys/types.h>
#include <sys/queue.h>

#include "exchange_num.h"
#include "isakmp.h"

/* Remove an exchange if it has not been fully negotiated in this time.  */
#define EXCHANGE_MAX_TIME 120

struct crypto_xf;
struct certreq_aca;
struct doi;
struct event;
struct keystate;
struct message;
struct payload;
struct transport;
struct sa;

struct exchange {
	/* Link to exchanges with the same hash value.  */
	LIST_ENTRY(exchange) link;

	/* This exchange is linked to the global exchange list. */
	int		linked;

	/* A name of the SAs this exchange will result in.  XXX non unique?  */
	char           *name;

	/*
	 * A name of the major policy deciding offers and acceptable
	 * proposals.
	 */
	char           *policy;

	/*
	 * A function with a polymorphic argument called after the exchange
	 * has been run to its end, successfully.  The 2nd argument is true
	 * if the finalization hook is called due to the exchange not running
	 * to its end normally.
         */
	void            (*finalize)(struct exchange *, void *, int);
	void           *finalize_arg;

	/* When several SA's are being negotiated we keep them here.  */
	TAILQ_HEAD(sa_head, sa) sa_list;

	/*
	 * The event that will occur when it has taken too long time to try to
	 * run the exchange and which will trigger auto-destruction.
         */
	struct event   *death;

	/*
	 * Both initiator and responder cookies.
	 * XXX For code clarity we might split this into two fields.
         */
	u_int8_t        cookies[ISAKMP_HDR_COOKIES_LEN];

	/* The message ID signifying phase 2 exchanges.  */
	u_int8_t        message_id[ISAKMP_HDR_MESSAGE_ID_LEN];

	/* The exchange type we are using.  */
	u_int8_t        type;

	/* Phase is 1 for ISAKMP SA exchanges, and 2 for application ones.  */
	u_int8_t        phase;

	/* The "step counter" of the exchange, starting from zero.  */
	u_int8_t        step;

	/* 1 if we are the initiator, 0 if we are the responder.  */
	u_int8_t        initiator;

	/* Various flags, look below for descriptions.  */
	u_int32_t       flags;

	/* The DOI that is to handle DOI-specific issues for this exchange.  */
	struct doi     *doi;

	/*
	 * A "program counter" into the script that validate message contents
	 * for this exchange.
         */
	int16_t        *exch_pc;

	/* The last message received, used for checking for duplicates.  */
	struct message *last_received;

	/* The last message sent, to be acked when something new is received.  */
	struct message *last_sent;

	/*
	 * If some message is queued up for sending, we want to be able to
	 * remove it from the queue, when the exchange is deleted.
         */
	struct message *in_transit;

	/*
	 * Initiator's & responder's nonces respectively, with lengths.
	 * XXX Should this be in the DOI-specific parts instead?
         */
	u_int8_t       *nonce_i;
	size_t          nonce_i_len;
	u_int8_t       *nonce_r;
	size_t          nonce_r_len;

	/*
	 * The ID payload contents for the initiator & responder,
	 * respectively.
	 */
	u_int8_t       *id_i;
	size_t          id_i_len;
	u_int8_t       *id_r;
	size_t          id_r_len;

	/* Policy session identifier, where applicable.  */
	int             policy_id;

	/* Crypto info needed to encrypt/decrypt packets in this exchange.  */
	struct crypto_xf *crypto;
	size_t          key_length;
	struct keystate *keystate;

	/*
	 * Used only by KeyNote, to cache the key used to authenticate Phase
	 * 1
	 */
	char           *keynote_key;	/* printable format */

	/*
	 * Received certificate - used to verify signatures on packet,
	 * stored here for later policy processing.
         *
	 * The rules for the recv_* and sent_* fields are:
	 * - recv_cert stores the credential (if any) received from the peer;
	 *   the kernel may pass us one, but we ignore it. We pass it to the
	 *   kernel so processes can peek at it. When doing passphrase
	 *   authentication in Phase 1, this is empty.
	 * - recv_key stores the key (public or private) used by the peer
	 *   to authenticate. Otherwise, same properties as recv_cert except
	 *   that we don't tell the kernel about passphrases (so we don't
	 *   reveal system-wide passphrases). Processes that used passphrase
	 *   authentication already know the passphrase! We ignore it if/when
	 *   received from the kernel (meaningless).
	 * - sent_cert stores the credential, if any, we used to authenticate
	 *   with the peer. It may be passed to us by the kernel, or we may
	 *   have found it in our certificate storage. In either case, there's
	 *   no point passing it to the kernel, so we don't.
	 * - sent key stores the private key we used for authentication with
	 *   the peer (private key or passphrase). This may have been received
	 *   from the kernel, or may be a system-wide setting. In either case,
	 *   we don't pass it to the kernel, to avoid revealing such information
	 *   to processes (processes either already know it, or have no business
	 *   knowing it).
         */
	int             recv_certtype, recv_keytype;
	void           *recv_cert;	/* Certificate received from peer,
					 * native format */
	void           *recv_key;	/* Key peer used to authenticate,
					 * native format */

	/* Likewise, for certificates we use. */
	int             sent_certtype, sent_keytype;
	void           *sent_cert;	/* Certificate (to be) sent to peer,
					 * native format */

	/* ACQUIRE sequence number.  */
	u_int32_t       seq;

	/* XXX This is no longer necessary, it is covered by policy.  */

	/* Acceptable authorities for cert requests.  */
	TAILQ_HEAD(aca_head, certreq_aca) aca_list;

	/* DOI-specific opaque data.  */
	void           *data;
};

/* The flag bits.  */
#define EXCHANGE_FLAG_I_COMMITTED	0x0001
#define EXCHANGE_FLAG_HE_COMMITTED	0x0002
#define EXCHANGE_FLAG_COMMITTED		(EXCHANGE_FLAG_I_COMMITTED \
					 | EXCHANGE_FLAG_HE_COMMITTED)
#define EXCHANGE_FLAG_ENCRYPT		0x0004
#define EXCHANGE_FLAG_NAT_T_CAP_PEER	0x0008	/* Peer is NAT capable.  */
#define EXCHANGE_FLAG_NAT_T_ENABLE	0x0010	/* We are doing NAT-T.  */
#define EXCHANGE_FLAG_NAT_T_KEEPALIVE	0x0020	/* We are the NAT:ed peer.  */
#define EXCHANGE_FLAG_DPD_CAP_PEER	0x0040	/* Peer is DPD capable.  */
#define EXCHANGE_FLAG_NAT_T_RFC		0x0080	/* Peer does RFC NAT-T. */
#define EXCHANGE_FLAG_NAT_T_DRAFT	0x0100	/* Peer does draft NAT-T.*/
#define EXCHANGE_FLAG_OPENBSD		0x0200	/* Peer is OpenBSD */

extern int      exchange_add_certs(struct message *);
extern int      exchange_add_certreqs(struct message *);
extern void     exchange_finalize(struct message *);
extern void     exchange_free(struct exchange *);
extern void     exchange_free_aca_list(struct exchange *);
extern void     exchange_establish(char *name, void (*)(struct exchange *,
		    void *, int), void *, int);
extern int	exchange_establish_p1(struct transport *, u_int8_t, u_int32_t,
		    char *, void *, void (*)(struct exchange *, void *, int),
		    void *, int);
extern int      exchange_establish_p2(struct sa *, u_int8_t, char *, void *,
		    void (*)(struct exchange *, void *, int), void *);
extern int      exchange_gen_nonce(struct message *, size_t);
extern void     exchange_init(void);
extern struct exchange *exchange_lookup(u_int8_t *, int);
extern struct exchange *exchange_lookup_by_name(char *, int);
extern struct exchange *exchange_lookup_from_icookie(u_int8_t *);
extern void     exchange_report(void);
extern void     exchange_run(struct message *);
extern int      exchange_save_nonce(struct message *);
extern int      exchange_save_certreq(struct message *);
extern int16_t *exchange_script(struct exchange *);
extern struct exchange *exchange_setup_p1(struct message *, u_int32_t);
extern struct exchange *exchange_setup_p2(struct message *, u_int8_t);
extern void     exchange_upgrade_p1(struct message *);

#endif				/* _EXCHANGE_H_ */
@


1.34
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.33 2007/08/05 09:43:09 tom Exp $	 */
d58 3
d235 1
a235 1
extern void	exchange_establish_p1(struct transport *, u_int8_t, u_int32_t,
d238 1
a238 1
extern void     exchange_establish_p2(struct sa *, u_int8_t, char *, void *,
@


1.33
log
@Allow key exchange with RSA signature authentication to work with
Cisco IOS and other initiators that only send their certs in response
to CERT_REQUEST.

With input and help from cloder@@, Stuart Henderson, mpf@@, and several
others who did lots of testing - thanks to all.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.32 2006/07/02 13:19:00 hshoexer Exp $	 */
a34 1
#include <sys/param.h>
@


1.32
log
@Let isakmpd send out a vendor ID announcing isamkpds release version.
Will be handy for release specific bug fixes, etc.  Suggested by
markus@@ quite some time ago.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.31 2006/05/31 04:54:46 hshoexer Exp $	 */
d227 1
@


1.31
log
@Make sure, that phase 1 SAs of active connections stay alive.  Fixes a DPD
breakage noticed and reported by Mitja Muzenic.

ok markus@@ ho@@, testing by Mitja and cloder@@, discussed with Nathanael.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.30 2005/07/25 15:03:47 hshoexer Exp $	 */
d224 1
@


1.30
log
@Use payload NAT-D or NAT-D-DRAFT according to NAT-T vendor ID advertised by the
peer.

looks good ho
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.29 2005/01/31 10:07:59 hshoexer Exp $	 */
d230 1
a230 1
		    void *, int), void *);
d233 1
a233 1
		    void *);
@


1.29
log
@Remove unused stuff.

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.28 2004/08/23 11:13:14 ho Exp $	 */
d213 2
a214 2
#define EXCHANGE_FLAG_I_COMMITTED	0x01
#define EXCHANGE_FLAG_HE_COMMITTED	0x02
d217 7
a223 5
#define EXCHANGE_FLAG_ENCRYPT		0x04
#define EXCHANGE_FLAG_NAT_T_CAP_PEER	0x08	/* Peer is NAT capable.  */
#define EXCHANGE_FLAG_NAT_T_ENABLE	0x10	/* We are doing NAT-T.  */
#define EXCHANGE_FLAG_NAT_T_KEEPALIVE	0x20	/* We are the NAT:ed peer.  */
#define EXCHANGE_FLAG_DPD_CAP_PEER	0x40	/* Peer is DPD capable.  */
@


1.28
log
@Indent nit.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.27 2004/06/20 15:24:05 ho Exp $	 */
d195 1
a195 1
	/* Likewise, for certificates/keys we use. */
a198 2
	void           *sent_key;	/* Key we'll use to authenticate to
					 * peer, native format */
@


1.27
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.26 2004/05/03 21:23:51 hshoexer Exp $	 */
d78 1
a78 1
	                TAILQ_HEAD(sa_head, sa) sa_list;
@


1.26
log
@KNF.  ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.25 2004/04/15 18:39:25 deraadt Exp $	 */
d215 2
a216 2
#define EXCHANGE_FLAG_I_COMMITTED	1
#define EXCHANGE_FLAG_HE_COMMITTED	2
d219 5
a223 1
#define EXCHANGE_FLAG_ENCRYPT		4
@


1.25
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.h,v 1.24 2004/04/07 22:45:49 ho Exp $	 */
d74 1
a74 1
	void            (*finalize) (struct exchange *, void *, int);
d114 2
a115 2
	 * A "program counter" into the script that validate message contents for
	 * this exchange.
d126 2
a127 2
	 * If some message is queued up for sending, we want to be able to remove
	 * it from the queue, when the exchange is deleted.
d208 1
a208 1
	                TAILQ_HEAD(aca_head, certreq_aca) aca_list;
d225 20
a244 24
extern void
exchange_establish(char *name,
		   void (*) (struct exchange *, void *, int),
		   void *);
	extern void     exchange_establish_p1(struct transport *, u_int8_t, u_int32_t,
					                      char *, void *,
		                  void (*) (struct exchange *, void *, int),
					                      void *);
	extern void     exchange_establish_p2(struct sa *, u_int8_t, char *, void *,
		                  void (*) (struct exchange *, void *, int),
					                      void *);
	extern int      exchange_gen_nonce(struct message *, size_t);
	extern void     exchange_init(void);
	extern struct exchange *exchange_lookup(u_int8_t *, int);
	extern struct exchange *exchange_lookup_by_name(char *, int);
	extern struct exchange *exchange_lookup_from_icookie(u_int8_t *);
	extern void     exchange_report(void);
	extern void     exchange_run(struct message *);
	extern int      exchange_save_nonce(struct message *);
	extern int      exchange_save_certreq(struct message *);
	extern int16_t *exchange_script(struct exchange *);
	extern struct exchange *exchange_setup_p1(struct message *, u_int32_t);
	extern struct exchange *exchange_setup_p2(struct message *, u_int8_t);
	extern void     exchange_upgrade_p1(struct message *);
@


1.24
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.23 2003/06/03 14:28:16 ho Exp $	*/
/*	$EOM: exchange.h,v 1.28 2000/09/28 12:54:28 niklas Exp $	*/
d56 2
a57 2
  /* Link to exchanges with the same hash value.  */
  LIST_ENTRY (exchange) link;
d59 2
a60 2
  /* A name of the SAs this exchange will result in.  XXX non unique?  */
  char *name;
d62 142
a203 2
  /* A name of the major policy deciding offers and acceptable proposals.  */
  char *policy;
d205 1
a205 126
  /*
   * A function with a polymorphic argument called after the exchange
   * has been run to its end, successfully.  The 2nd argument is true
   * if the finalization hook is called due to the exchange not running
   * to its end normally.
   */
  void (*finalize) (struct exchange *, void *, int);
  void *finalize_arg;

  /* When several SA's are being negotiated we keep them here.  */
  TAILQ_HEAD (sa_head, sa) sa_list;

  /*
   * The event that will occur when it has taken too long time to try to
   * run the exchange and which will trigger auto-destruction.
   */
  struct event *death;

  /*
   * Both initiator and responder cookies.
   * XXX For code clarity we might split this into two fields.
   */
  u_int8_t cookies[ISAKMP_HDR_COOKIES_LEN];

  /* The message ID signifying phase 2 exchanges.  */
  u_int8_t message_id[ISAKMP_HDR_MESSAGE_ID_LEN];

  /* The exchange type we are using.  */
  u_int8_t type;

  /* Phase is 1 for ISAKMP SA exchanges, and 2 for application ones.  */
  u_int8_t phase;

  /* The "step counter" of the exchange, starting from zero.  */
  u_int8_t step;

  /* 1 if we are the initiator, 0 if we are the responder.  */
  u_int8_t initiator;

  /* Various flags, look below for descriptions.  */
  u_int32_t flags;

  /* The DOI that is to handle DOI-specific issues for this exchange.  */
  struct doi *doi;

  /*
   * A "program counter" into the script that validate message contents for
   * this exchange.
   */
  int16_t *exch_pc;

  /* The last message received, used for checking for duplicates.  */
  struct message *last_received;

  /* The last message sent, to be acked when something new is received.  */
  struct message *last_sent;

  /*
   * If some message is queued up for sending, we want to be able to remove
   * it from the queue, when the exchange is deleted.
   */
  struct message *in_transit;

  /*
   * Initiator's & responder's nonces respectively, with lengths.
   * XXX Should this be in the DOI-specific parts instead?
   */
  u_int8_t *nonce_i;
  size_t nonce_i_len;
  u_int8_t *nonce_r;
  size_t nonce_r_len;

  /* The ID payload contents for the initiator & responder, respectively.  */
  u_int8_t *id_i;
  size_t id_i_len;
  u_int8_t *id_r;
  size_t id_r_len;

  /* Policy session identifier, where applicable.  */
  int policy_id;

  /* Crypto info needed to encrypt/decrypt packets in this exchange.  */
  struct crypto_xf *crypto;
  size_t key_length;
  struct keystate *keystate;

  /* Used only by KeyNote, to cache the key used to authenticate Phase 1 */
  char *keynote_key; /* printable format */

  /*
   * Received certificate - used to verify signatures on packet,
   * stored here for later policy processing.
   *
   * The rules for the recv_* and sent_* fields are:
   * - recv_cert stores the credential (if any) received from the peer;
   *   the kernel may pass us one, but we ignore it. We pass it to the
   *   kernel so processes can peek at it. When doing passphrase
   *   authentication in Phase 1, this is empty.
   * - recv_key stores the key (public or private) used by the peer
   *   to authenticate. Otherwise, same properties as recv_cert except
   *   that we don't tell the kernel about passphrases (so we don't
   *   reveal system-wide passphrases). Processes that used passphrase
   *   authentication already know the passphrase! We ignore it if/when
   *   received from the kernel (meaningless).
   * - sent_cert stores the credential, if any, we used to authenticate
   *   with the peer. It may be passed to us by the kernel, or we may
   *   have found it in our certificate storage. In either case, there's
   *   no point passing it to the kernel, so we don't.
   * - sent key stores the private key we used for authentication with
   *   the peer (private key or passphrase). This may have been received
   *   from the kernel, or may be a system-wide setting. In either case,
   *   we don't pass it to the kernel, to avoid revealing such information
   *   to processes (processes either already know it, or have no business
   *   knowing it).
   */
  int recv_certtype, recv_keytype;
  void *recv_cert; /* Certificate received from peer, native format */
  void *recv_key; /* Key peer used to authenticate, native format */

  /* Likewise, for certificates/keys we use. */
  int sent_certtype, sent_keytype;
  void *sent_cert; /* Certificate (to be) sent to peer, native format */
  void *sent_key; /* Key we'll use to authenticate to peer, native format */

  /* ACQUIRE sequence number.  */
  u_int32_t seq;
d207 2
a208 1
  /* XXX This is no longer necessary, it is covered by policy.  */
d210 2
a211 5
  /* Acceptable authorities for cert requests.  */
  TAILQ_HEAD (aca_head, certreq_aca) aca_list;

  /* DOI-specific opaque data.  */
  void *data;
d221 28
a248 27
extern int exchange_add_certs (struct message *);
extern void exchange_finalize (struct message *);
extern void exchange_free (struct exchange *);
extern void exchange_free_aca_list (struct exchange *);
extern void exchange_establish (char *name,
				void (*) (struct exchange *, void *, int),
				void *);
extern void exchange_establish_p1 (struct transport *, u_int8_t, u_int32_t,
				   char *, void *,
				   void (*) (struct exchange *, void *, int),
				   void *);
extern void exchange_establish_p2 (struct sa *, u_int8_t, char *, void *,
				   void (*) (struct exchange *, void *, int),
				   void *);
extern int exchange_gen_nonce (struct message *, size_t);
extern void exchange_init (void);
extern struct exchange *exchange_lookup (u_int8_t *, int);
extern struct exchange *exchange_lookup_by_name (char *, int);
extern struct exchange *exchange_lookup_from_icookie (u_int8_t *);
extern void exchange_report (void);
extern void exchange_run (struct message *);
extern int exchange_save_nonce (struct message *);
extern int exchange_save_certreq (struct message *);
extern int16_t *exchange_script (struct exchange *);
extern struct exchange *exchange_setup_p1 (struct message *, u_int32_t);
extern struct exchange *exchange_setup_p2 (struct message *, u_int8_t);
extern void exchange_upgrade_p1 (struct message *);
d250 1
a250 1
#endif /* _EXCHANGE_H_ */
@


1.23
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.22 2002/09/11 09:50:43 ho Exp $	*/
d148 1
a148 1
  int key_length;
@


1.22
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.21 2002/06/09 08:13:06 todd Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.21
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.20 2001/06/05 05:59:43 niklas Exp $	*/
d236 1
a236 1
extern u_int16_t *exchange_script (struct exchange *);
@


1.20
log
@Style issues and commentary
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.19 2001/05/31 20:23:52 angelos Exp $	*/
d159 1
a159 1
  /* 
d161 1
a161 1
   * stored here for later policy processing. 
@


1.19
log
@Match the information stored in the sa structure (or the other way
around) in terms of certificates and keys.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.18 2001/02/24 03:59:55 angelos Exp $	*/
d148 1
a148 1
  /* Policy session identifier, where applicable */
d194 1
a194 1
  /* ACQUIRE sequence number */
d199 1
a199 1
  /* Acceptable authorities for cert requests */
@


1.18
log
@For the GETSPI PFKEY message, use the sequence number from the ACQUIRE
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.17 2001/01/27 12:03:32 niklas Exp $	*/
d156 3
d162 31
a192 5
   * a type of ISAKMP_CERTENC_NONE implies pre-shared key.
   */
  int recv_certtype, recv_certlen;
  void *recv_cert;
  void *recv_key;
@


1.17
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.16 2001/01/26 12:12:51 niklas Exp $	*/
d164 3
@


1.16
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.15 2000/10/07 06:59:46 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.15
log
@Merge with EOM 1.28

author: niklas
Obsolete commentary
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.14 2000/06/08 20:49:44 niklas Exp $	*/
d165 1
a165 1
  /* XXX This is no longer necessary, it is covered by policy. */
@


1.15.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.h,v 1.18 2001/02/24 03:59:55 angelos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
d165 1
a165 4
  /* ACQUIRE sequence number */
  u_int32_t seq;

  /* XXX This is no longer necessary, it is covered by policy.  */
@


1.14
log
@cert.h: Merge with EOM 1.7
exchange.h: Merge with EOM 1.27
x509.h: Merge with EOM 1.10

author: angelos
Allow exchange of KeyNote credentials over IKE. Multiple credentials
may be passed in a single CERT payload. KeyNote is used if a
directory named as the local ID we use in an exchange exists in the
KeyNote directory (default: /etc/isakmpd/keynote/). Note that
asymmetric credentials are possible (use KeyNote in one direction and
X509 in the other); such authentication is envisioned to be the most
common: the clients will use KeyNote credentials to authenticate and
authorize with a server, whilst the server will just provide an X509
certificate proving its binding to the IP address or ID.

Totally asymmetric authentication (e.g., shared key in one direction,
RSA in the other) is not supported by the IKE protocol.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.13 1999/07/17 21:54:39 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.27 2000/05/19 05:47:52 angelos Exp $	*/
d142 1
a142 1
  /* XXX Do we want to save these in the exchange at all?  */
@


1.13
log
@regress/rsakeygen/Makefile: Merge with EOM 1.4
regress/rsakeygen/rsakeygen.c: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.6
regress/x509/x509test.c: Merge with EOM 1.6
regress/Makefile: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.6
samples/VPN-west.conf: Merge with EOM 1.6
samples/singlehost-east.conf: Merge with EOM 1.3
samples/singlehost-west.conf: Merge with EOM 1.3
sysdep/openbsd/Makefile.sysdep: Merge with EOM 1.5
x509.h: Merge with EOM 1.6
x509.c: Merge with EOM 1.17
DESIGN-NOTES: Merge with EOM 1.46
Makefile: Merge with EOM 1.55
cert.c: Merge with EOM 1.11
cert.h: Merge with EOM 1.6
exchange.c: Merge with EOM 1.109
exchange.h: Merge with EOM 1.26
ike_auth.c: Merge with EOM 1.32
ike_phase_1.c: Merge with EOM 1.7
init.c: Merge with EOM 1.16
isakmpd.conf.5: Merge with EOM 1.27
README.PKI: Merge with EOM 1.1

author: niklas
From Niels Provos, edited by me: certificate support using SSLeay
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.12 1999/07/07 22:09:53 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.26 1999/07/17 20:44:10 niklas Exp $	*/
d148 3
d163 1
@


1.12
log
@exchange.h: Merge with EOM 1.25
ike_quick_mode.c: Merge with EOM 1.90
init.c: Merge with EOM 1.15

author: ho
Add keynote policy support (with USE_KEYNOTE). angelos@@openbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.11 1999/04/30 11:47:11 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.25 1999/06/07 00:02:11 ho Exp $	*/
d152 8
@


1.11
log
@Merge with EOM 1.24

author: niklas
Keep track of messages in the send queue from the exchange point of view.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.10 1999/04/27 21:14:04 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.24 1999/04/29 20:45:11 niklas Exp $	*/
d152 2
@


1.10
log
@Merge with EOM 1.23

author: niklas
Simplify exchange life logic some.  Some style too.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.9 1999/04/19 21:03:35 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.23 1999/04/25 22:04:35 niklas Exp $	*/
d126 6
@


1.9
log
@./exchange.h: Merge with EOM 1.22

Simplify the checks of existing exchanges by moving it into
exchange_establish.  This means we need to change the finalize API.
Try to make PF_ENCAP support handle multiple connections to a single
security gateway.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.8 1999/04/05 20:58:28 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.22 1999/04/15 18:51:08 niklas Exp $	*/
a108 3
  /* A reference counter for this structure.  */
  u_int32_t refcnt;

a179 2
extern void exchange_reference (struct exchange *);
extern void exchange_release (struct exchange *);
@


1.8
log
@Merge with EOM 1.21
New finalize API so we can call it when failing too, so we do not leak
resources.  Plug memory leaks in general.  More memory allocation error
reporting.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.7 1999/04/02 01:08:41 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.21 1999/04/05 07:59:37 niklas Exp $	*/
d76 1
a76 1
  void (*finalize) (void *, int);
d168 3
a170 1
extern void exchange_establish (char *name, void (*) (void *, int), void *);
d172 2
a173 1
				   char *, void *, void (*) (void *, int),
d176 2
a177 1
				   void (*) (void *, int), void *);
@


1.7
log
@Merge with EOM 1.20
refcounting on exchanges
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.6 1999/03/31 01:51:05 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.20 1999/04/02 00:39:58 niklas Exp $	*/
d72 3
a74 1
   * has been run to its end, successfully.
d76 1
a76 1
  void (*finalize) (void *);
d168 1
a168 1
extern void exchange_establish (char *name, void (*) (void *), void *);
d170 2
a171 1
				   char *, void *, void (*) (void *), void *);
d173 1
a173 1
				   void (*) (void *), void *);
@


1.6
log
@Merge with EOM 1.19
Do not overwrite the last-sent-message of phase 1 with last-sent dittos
of phase2.  Add some debugging.  Make exchange finalization accept added
hooks to run.  Try to protect better against multiple equal exchanges
getting started concurrently.  Set the SA names from the exchange name up
early.  Change "Attributes" to "Flags" to not be mistaken for ISAKMP
attributes.  Let phase 2 exchanges take finalization functions too.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.5 1999/02/26 03:38:22 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.19 1999/03/31 01:29:53 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d107 3
d162 1
d165 1
d176 2
a181 2
extern void exchange_free_aca_list (struct exchange *);
extern int exchange_add_certs (struct message *);
@


1.5
log
@Merge from the Ericsson repository
| revision 1.18
| date: 1999/02/06 14:57:52;  author: niklas;  state: Exp;  lines: +2 -1
| Export exchange_lookup_by_name
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.4 1998/12/21 01:02:23 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.18 1999/02/06 14:57:52 niklas Exp $	*/
d163 3
a165 2
				   void *, void (*) (void *), void *);
extern void exchange_establish_p2 (struct sa *, u_int8_t, void *);
@


1.4
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.3 1998/11/17 11:10:10 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.17 1998/12/15 16:58:40 niklas Exp $	*/
d168 1
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.h,v 1.2 1998/11/15 00:43:52 niklas Exp $	*/
/*	$EOM: exchange.h,v 1.15 1998/08/13 21:43:57 provos Exp $	*/
d64 13
d161 1
d163 1
a163 1
				   void *);
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: exchange.h,v 1.1.1.1 1998/11/15 00:03:48 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: exchange.h,v 1.15 1998/08/13 21:43:57 provos Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
