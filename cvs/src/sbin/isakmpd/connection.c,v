head	1.37;
access;
symbols
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.12
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.8
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.37.0.10
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.37.0.6
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.24
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.22
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.20
	OPENBSD_5_0:1.35.0.18
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.16
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.14
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.10
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.12
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.8
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.6
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.4
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.34.0.4
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.22.0.4
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.37
date	2014.01.22.03.09.31;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2013.04.02.03.06.18;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.34;

1.34
date	2006.09.01.00.24.06;	author mpf;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.22.17.34.31;	author hshoexer;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.04.10.05.01;	author hshoexer;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.08.19.40.02;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.14.08.42.56;	author hshoexer;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.13.06.56.33;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.06.02.15.27;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.06.14.37.11;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.05.12.36.49;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.02.02.28.35;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.01.19.48.43;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.27.03.31.40;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.14.21.13.24;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.14.12.15.45;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.14.10.42.19;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.14.10.33.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.27.12.03.31;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.26.12.12.51;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.23.12.56.59;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.07.06.58.16;	author niklas;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.08.03.07.29.11;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.03.07.25.39;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.07.22.05.29;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.25.17.23.39;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.10.01.14.10.19;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.07.13.15.46.32;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.07.07.22.04.34;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.06.02.06.31.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.05.02.05.52.48;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.08.12.45.22;	author ho;	state Exp;
branches;
next	;


desc
@@


1.37
log
@improve randomization.  remove some junk debugging features that are
fundamentally broken.
ok jsing mikeb
@
text
@/* $OpenBSD: connection.c,v 1.36 2013/04/02 03:06:18 guenther Exp $	 */
/* $EOM: connection.c,v 1.28 2000/11/23 12:21:18 niklas Exp $	 */

/*
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999 Hakan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/queue.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>

#include "conf.h"
#include "connection.h"
#include "doi.h"
#include "ipsec.h"
#include "pf_key_v2.h"

/* XXX isakmp.h only required for compare_ids().  */
#include "isakmp.h"

#include "log.h"
#include "timer.h"
#include "ui.h"
#include "util.h"

/* How often should we check that connections we require to be up, are up?  */
#define CHECK_INTERVAL 60

static void     connection_passive_teardown(char *);

struct connection {
	TAILQ_ENTRY(connection) link;
	char           *name;
	struct event   *ev;
};

struct connection_passive {
	TAILQ_ENTRY(connection_passive) link;
	char           *name;
	u_int8_t       *local_id, *remote_id;
	size_t          local_sz, remote_sz;

#if 0
	/* XXX Potential additions to 'connection_passive'.  */
	char           *isakmp_peer;
	struct sa      *sa;	/* XXX "Soft" ref to active sa?  */
	struct timeval  sa_expiration;	/* XXX *sa may expire.  */
#endif
};

TAILQ_HEAD(connection_head, connection) connections;
TAILQ_HEAD(passive_head, connection_passive) connections_passive;

/*
 * This is where we setup all the connections we want there right from the
 * start.
 */
void
connection_init(void)
{
	struct conf_list *conns, *attrs;
	struct conf_list_node *conn, *attr = NULL;

	/*
	 * Passive connections normally include: all "active" connections that
	 * are not flagged "Active-Only", plus all connections listed in
	 * the 'Passive-Connections' list.
         */
	TAILQ_INIT(&connections);
	TAILQ_INIT(&connections_passive);

	conns = conf_get_list("Phase 2", "Connections");
	if (conns) {
		for (conn = TAILQ_FIRST(&conns->fields); conn;
		    conn = TAILQ_NEXT(conn, link)) {
			if (connection_setup(conn->field))
				log_print("connection_init: could not setup "
				    "\"%s\"", conn->field);

			/* XXX Break/abort here if connection_setup failed?  */

			/*
			 * XXX This code (i.e. the attribute lookup) seems
			 * like a likely candidate for factoring out into a
			 * function of its own.
			 */
			attrs = conf_get_list(conn->field, "Flags");
			if (attrs)
				for (attr = TAILQ_FIRST(&attrs->fields); attr;
				    attr = TAILQ_NEXT(attr, link))
					if (strcasecmp("active-only",
					    attr->field) == 0)
						break;
			if (!attrs || (attrs && !attr))
				if (connection_record_passive(conn->field))
					log_print("connection_init: could not "
					    "record connection \"%s\"",
					    conn->field);
			if (attrs)
				conf_free_list(attrs);

		}
		conf_free_list(conns);
	}
	conns = conf_get_list("Phase 2", "Passive-Connections");
	if (conns) {
		for (conn = TAILQ_FIRST(&conns->fields); conn;
		    conn = TAILQ_NEXT(conn, link))
			if (connection_record_passive(conn->field))
				log_print("connection_init: could not record "
				    "passive connection \"%s\"", conn->field);
		conf_free_list(conns);
	}
}

/* Check the connection in VCONN and schedule another check later.  */
static void
connection_checker(void *vconn)
{
	struct timeval  now;
	struct connection *conn = vconn;

	gettimeofday(&now, 0);
	now.tv_sec += conf_get_num("General", "check-interval",
	    CHECK_INTERVAL);
	conn->ev = timer_add_event("connection_checker",
	    connection_checker, conn, &now);
	if (!conn->ev)
		log_print("connection_checker: could not add timer event");
	if (!ui_daemon_passive)
		pf_key_v2_connection_check(conn->name);
}

/* Find the connection named NAME.  */
static struct connection *
connection_lookup(char *name)
{
	struct connection *conn;

	for (conn = TAILQ_FIRST(&connections); conn;
	    conn = TAILQ_NEXT(conn, link))
		if (strcasecmp(conn->name, name) == 0)
			return conn;
	return 0;
}

/* Does the connection named NAME exist?  */
int
connection_exist(char *name)
{
	return (connection_lookup(name) != 0);
}

/* Find the passive connection named NAME.  */
static struct connection_passive *
connection_passive_lookup_by_name(char *name)
{
	struct connection_passive *conn;

	for (conn = TAILQ_FIRST(&connections_passive); conn;
	    conn = TAILQ_NEXT(conn, link))
		if (strcasecmp(conn->name, name) == 0)
			return conn;
	return 0;
}

/*
 * IDs of different types cannot be the same.
 * XXX Rename to ipsec_compare_id, and move to ipsec.c ?
 */
static int
compare_ids(u_int8_t *id1, u_int8_t *id2, size_t idlen)
{
	int	id1_type, id2_type;

	id1_type = GET_ISAKMP_ID_TYPE(id1);
	id2_type = GET_ISAKMP_ID_TYPE(id2);

	return id1_type == id2_type ? memcmp(id1 + ISAKMP_ID_DATA_OFF,
	    id2 + ISAKMP_ID_DATA_OFF, idlen - ISAKMP_ID_DATA_OFF) : -1;
}

/* Find the connection named with matching IDs.  */
char *
connection_passive_lookup_by_ids(u_int8_t *id1, u_int8_t *id2)
{
	struct connection_passive *conn;

	for (conn = TAILQ_FIRST(&connections_passive); conn;
	    conn = TAILQ_NEXT(conn, link)) {
		if (!conn->remote_id)
			continue;

		/*
		 * If both IDs match what we have saved, return the name.
		 * Don't bother in which order they are.
		 */
		if ((compare_ids(id1, conn->local_id, conn->local_sz) == 0 &&
		    compare_ids(id2, conn->remote_id, conn->remote_sz) == 0) ||
		    (compare_ids(id1, conn->remote_id, conn->remote_sz) == 0 &&
		    compare_ids(id2, conn->local_id, conn->local_sz) == 0)) {
			LOG_DBG((LOG_MISC, 60,
			    "connection_passive_lookup_by_ids: "
			    "returned \"%s\"", conn->name));
			return conn->name;
		}
	}

	/*
	 * In the road warrior case, we do not know the remote ID. In that
	 * case we will just match against the local ID.
	 */
	for (conn = TAILQ_FIRST(&connections_passive); conn;
	    conn = TAILQ_NEXT(conn, link)) {
		if (!conn->remote_id)
			continue;

		if (compare_ids(id1, conn->local_id, conn->local_sz) == 0 ||
		    compare_ids(id2, conn->local_id, conn->local_sz) == 0) {
			LOG_DBG((LOG_MISC, 60,
			    "connection_passive_lookup_by_ids: returned \"%s\""
			    " only matched local id", conn->name));
			return conn->name;
		}
	}
	LOG_DBG((LOG_MISC, 60,
	    "connection_passive_lookup_by_ids: no match"));
	return 0;
}

/*
 * Setup NAME to be a connection that should be up "always", i.e. if it dies,
 * for whatever reason, it should be tried to be brought up, over and over
 * again.
 */
int
connection_setup(char *name)
{
	struct connection *conn = 0;
	struct timeval  now;

	/* Check for trials to add duplicate connections.  */
	if (connection_lookup(name)) {
		LOG_DBG((LOG_MISC, 10,
		    "connection_setup: cannot add \"%s\" twice", name));
		return 0;
	}
	conn = calloc(1, sizeof *conn);
	if (!conn) {
		log_error("connection_setup: calloc (1, %lu) failed",
		    (unsigned long)sizeof *conn);
		goto fail;
	}
	conn->name = strdup(name);
	if (!conn->name) {
		log_error("connection_setup: strdup (\"%s\") failed", name);
		goto fail;
	}
	gettimeofday(&now, 0);
	conn->ev = timer_add_event("connection_checker", connection_checker,
	    conn, &now);
	if (!conn->ev) {
		log_print("connection_setup: could not add timer event");
		goto fail;
	}
	TAILQ_INSERT_TAIL(&connections, conn, link);
	return 0;

fail:
	if (conn) {
		free(conn->name);
		free(conn);
	}
	return -1;
}

int
connection_record_passive(char *name)
{
	struct connection_passive *conn;
	char           *local_id, *remote_id;

	if (connection_passive_lookup_by_name(name)) {
		LOG_DBG((LOG_MISC, 10,
		    "connection_record_passive: cannot add \"%s\" twice",
		    name));
		return 0;
	}
	local_id = conf_get_str(name, "Local-ID");
	if (!local_id) {
		log_print("connection_record_passive: "
		    "\"Local-ID\" is missing from section [%s]", name);
		return -1;
	}
	/* If the remote id lookup fails we defer it to later */
	remote_id = conf_get_str(name, "Remote-ID");

	conn = calloc(1, sizeof *conn);
	if (!conn) {
		log_error("connection_record_passive: calloc (1, %lu) failed",
		    (unsigned long)sizeof *conn);
		return -1;
	}
	conn->name = strdup(name);
	if (!conn->name) {
		log_error("connection_record_passive: strdup (\"%s\") failed",
		    name);
		goto fail;
	}
	/* XXX IPsec DOI-specific.  */
	conn->local_id = ipsec_build_id(local_id, &conn->local_sz);
	if (!conn->local_id)
		goto fail;

	if (remote_id) {
		conn->remote_id = ipsec_build_id(remote_id, &conn->remote_sz);
		if (!conn->remote_id)
			goto fail;
	} else
		conn->remote_id = 0;

	TAILQ_INSERT_TAIL(&connections_passive, conn, link);

	LOG_DBG((LOG_MISC, 60,
	    "connection_record_passive: passive connection \"%s\" added",
	    conn->name));
	return 0;

fail:
	free(conn->local_id);
	free(conn->name);
	free(conn);
	return -1;
}

/* Remove the connection named NAME.  */
void
connection_teardown(char *name)
{
	struct connection *conn;

	conn = connection_lookup(name);
	if (!conn)
		return;

	TAILQ_REMOVE(&connections, conn, link);
	timer_remove_event(conn->ev);
	free(conn->name);
	free(conn);
}

/* Remove the passive connection named NAME.  */
static void
connection_passive_teardown(char *name)
{
	struct connection_passive *conn;

	conn = connection_passive_lookup_by_name(name);
	if (!conn)
		return;

	TAILQ_REMOVE(&connections_passive, conn, link);
	free(conn->name);
	free(conn->local_id);
	free(conn->remote_id);
	free(conn);
}

void
connection_report(void)
{
	struct connection *conn;
	struct timeval  now;
	struct connection_passive *pconn;
	struct doi     *doi = doi_lookup(ISAKMP_DOI_ISAKMP);

	gettimeofday(&now, 0);
	for (conn = TAILQ_FIRST(&connections); conn;
	    conn = TAILQ_NEXT(conn, link))
		LOG_DBG((LOG_REPORT, 0,
		    "connection_report: connection %s next check %lld seconds",
		    (conn->name ? conn->name : "<unnamed>"),
		    (long long)(conn->ev->expiration.tv_sec - now.tv_sec)));
	for (pconn = TAILQ_FIRST(&connections_passive); pconn;
	    pconn = TAILQ_NEXT(pconn, link))
		LOG_DBG((LOG_REPORT, 0,
		    "connection_report: passive connection %s %s", pconn->name,
		    doi->decode_ids("local_id: %s, remote_id: %s",
		    pconn->local_id, pconn->local_sz,
		    pconn->remote_id, pconn->remote_sz, 1)));
}

/* Reinitialize all connections (SIGHUP handling).  */
void
connection_reinit(void)
{
	struct connection *conn, *next;
	struct connection_passive *pconn, *pnext;

	LOG_DBG((LOG_MISC, 30,
	    "connection_reinit: reinitializing connection list"));

	/* Remove all present connections.  */
	for (conn = TAILQ_FIRST(&connections); conn; conn = next) {
		next = TAILQ_NEXT(conn, link);
		connection_teardown(conn->name);
	}

	for (pconn = TAILQ_FIRST(&connections_passive); pconn; pconn = pnext) {
		pnext = TAILQ_NEXT(pconn, link);
		connection_passive_teardown(pconn->name);
	}

	/* Setup new connections, as the (new) config directs.  */
	connection_init();
}
@


1.36
log
@Stop assuming time_t is long

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.35 2007/04/16 13:01:39 moritz Exp $	 */
a37 2

#include "sysdep.h"
@


1.35
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.34 2006/09/01 00:24:06 mpf Exp $	 */
d410 1
a410 1
		    "connection_report: connection %s next check %ld seconds",
d412 1
a412 1
		    conn->ev->expiration.tv_sec - now.tv_sec));
@


1.34
log
@Add a new UI command to force isakmpd into passive only mode.
Will be used by sasyncd to prevent two talking isakmpd's in an HA setup.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.33 2006/08/22 17:34:31 hshoexer Exp $	 */
d300 1
a300 2
		if (conn->name)
			free(conn->name);
d359 2
a360 4
	if (conn->local_id)
		free(conn->local_id);
	if (conn->name)
		free(conn->name);
@


1.33
log
@correct function name in log message.
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.32 2005/05/04 10:05:01 hshoexer Exp $	 */
d52 1
d159 2
a160 1
	pf_key_v2_connection_check(conn->name);
@


1.32
log
@clean up KEY_API() wrapper.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.31 2005/04/08 19:40:02 deraadt Exp $	 */
d248 1
a248 1
			    "connection passive_lookup_by_ids: returned \"%s\""
@


1.31
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.30 2005/04/04 19:31:11 deraadt Exp $	 */
d45 1
d158 1
a158 1
	sysdep_connection_check(conn->name);
@


1.30
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.29 2004/06/14 09:55:41 ho Exp $	 */
a402 1
#ifdef USE_DEBUG
a404 1
#endif
a412 1
#ifdef USE_DEBUG
a419 1
#endif
@


1.29
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.28 2004/05/14 08:42:56 hshoexer Exp $	 */
d113 1
a113 1
		         */
d223 1
a223 1
	         */
@


1.28
log
@Some more KNF, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.27 2004/05/13 06:56:33 ho Exp $	 */
d151 2
a152 1
	now.tv_sec += conf_get_num("General", "check-interval", CHECK_INTERVAL);
d229 2
a230 2
			    "connection_passive_lookup_by_ids: returned \"%s\"",
			    conn->name));
@


1.27
log
@Extensions to the FIFO interface:
"C get [section]:tag" fetches a configuration value.
"C add [section]:tag=value" adds 'value' to a list, typically for the
[Phase 2]:Connections tag. FIFO "S" command destination file changed.
Various KNF cleanups. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.26 2004/04/15 18:39:25 deraadt Exp $	 */
d104 2
a105 2
				log_print("connection_init: could not setup \"%s\"",
				    conn->field);
d110 3
a112 3
			 * XXX This code (i.e. the attribute lookup) seems like a
			 * likely candidate for factoring out into a function of its
			 * own.
d118 2
a119 1
					if (strcasecmp("active-only", attr->field) == 0)
d123 3
a125 2
					log_print("connection_init: could not record "
					    "connection \"%s\"", conn->field);
d137 2
a138 2
				log_print("connection_init: could not record passive "
				    "connection \"%s\"", conn->field);
d165 2
a166 1
	for (conn = TAILQ_FIRST(&connections); conn; conn = TAILQ_NEXT(conn, link))
d220 2
a221 2
		 * If both IDs match what we have saved, return the name.  Don't bother
		 * in which order they are.
d276 1
a276 1
		    (unsigned long) sizeof *conn);
d285 2
a286 2
	conn->ev = timer_add_event("connection_checker",
	    connection_checker, conn, &now);
d327 1
a327 1
		    (unsigned long) sizeof *conn);
d409 1
a409 1
	     conn = TAILQ_NEXT(conn, link))
@


1.26
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: connection.c,v 1.25 2003/06/03 14:28:16 ho Exp $	 */
d266 2
a267 2
		LOG_DBG((LOG_MISC, 10, "connection_setup: cannot add \"%s\" twice",
		    name));
d329 2
a330 1
		log_error("connection_record_passive: strdup (\"%s\") failed", name);
d405 2
a406 1
	for (conn = TAILQ_FIRST(&connections); conn; conn = TAILQ_NEXT(conn, link))
@


1.25
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.24 2002/06/06 02:15:27 ho Exp $	*/
/*	$EOM: connection.c,v 1.28 2000/11/23 12:21:18 niklas Exp $	*/
d56 1
a56 1
static void connection_passive_teardown (char *);
d58 4
a61 5
struct connection
{
  TAILQ_ENTRY (connection) link;
  char *name;
  struct event *ev;
d64 5
a68 6
struct connection_passive
{
  TAILQ_ENTRY (connection_passive) link;
  char *name;
  u_int8_t *local_id, *remote_id;
  size_t local_sz, remote_sz;
d71 4
a74 4
  /* XXX Potential additions to 'connection_passive'.  */
  char *isakmp_peer;
  struct sa *sa;                /* XXX "Soft" ref to active sa?  */
  struct timeval sa_expiration; /* XXX *sa may expire.  */
d78 2
a79 2
TAILQ_HEAD (connection_head, connection) connections;
TAILQ_HEAD (passive_head, connection_passive) connections_passive;
d86 1
a86 1
connection_init (void)
d88 38
a125 2
  struct conf_list *conns, *attrs;
  struct conf_list_node *conn, *attr = NULL;
d127 12
a138 52
  /*
   * Passive connections normally include: all "active" connections that
   * are not flagged "Active-Only", plus all connections listed in
   * the 'Passive-Connections' list.
   */

  TAILQ_INIT (&connections);
  TAILQ_INIT (&connections_passive);

  conns = conf_get_list ("Phase 2", "Connections");
  if (conns)
    {
      for (conn = TAILQ_FIRST (&conns->fields); conn;
	   conn = TAILQ_NEXT (conn, link))
	{
	  if (connection_setup (conn->field))
	    log_print ("connection_init: could not setup \"%s\"", conn->field);

	  /* XXX Break/abort here if connection_setup failed?  */

	  /*
	   * XXX This code (i.e. the attribute lookup) seems like a
	   * likely candidate for factoring out into a function of its
	   * own.
	   */
	  attrs = conf_get_list (conn->field, "Flags");
	  if (attrs)
	    for (attr = TAILQ_FIRST (&attrs->fields); attr;
		 attr = TAILQ_NEXT (attr, link))
	      if (strcasecmp ("active-only", attr->field) == 0)
		break;
	  if (!attrs || (attrs && !attr))
	    if (connection_record_passive (conn->field))
	      log_print ("connection_init: could not record "
			 "connection \"%s\"", conn->field);
	  if (attrs)
	    conf_free_list (attrs);

	}
      conf_free_list (conns);
    }

  conns = conf_get_list ("Phase 2", "Passive-Connections");
  if (conns)
    {
      for (conn = TAILQ_FIRST (&conns->fields); conn;
	   conn = TAILQ_NEXT (conn, link))
	if (connection_record_passive (conn->field))
	  log_print ("connection_init: could not record passive "
		     "connection \"%s\"", conn->field);
      conf_free_list (conns);
    }
d143 1
a143 1
connection_checker (void *vconn)
d145 2
a146 2
  struct timeval now;
  struct connection *conn = vconn;
d148 7
a154 7
  gettimeofday (&now, 0);
  now.tv_sec += conf_get_num ("General", "check-interval", CHECK_INTERVAL);
  conn->ev
    = timer_add_event ("connection_checker", connection_checker, conn, &now);
  if (!conn->ev)
    log_print ("connection_checker: could not add timer event");
  sysdep_connection_check (conn->name);
d159 1
a159 1
connection_lookup (char *name)
d161 1
a161 1
  struct connection *conn;
d163 4
a166 4
  for (conn = TAILQ_FIRST (&connections); conn; conn = TAILQ_NEXT (conn, link))
    if (strcasecmp (conn->name, name) == 0)
      return conn;
  return 0;
d171 1
a171 1
connection_exist (char *name)
d173 1
a173 1
  return (connection_lookup (name) != 0);
d178 1
a178 1
connection_passive_lookup_by_name (char *name)
d180 1
a180 1
  struct connection_passive *conn;
d182 5
a186 5
  for (conn = TAILQ_FIRST (&connections_passive); conn;
       conn = TAILQ_NEXT (conn, link))
    if (strcasecmp (conn->name, name) == 0)
      return conn;
  return 0;
d194 1
a194 1
compare_ids (u_int8_t *id1, u_int8_t *id2, size_t idlen)
d196 1
a196 1
  int id1_type, id2_type;
d198 2
a199 2
  id1_type = GET_ISAKMP_ID_TYPE (id1);
  id2_type = GET_ISAKMP_ID_TYPE (id2);
d201 2
a202 3
  return id1_type == id2_type
    ? memcmp (id1 + ISAKMP_ID_DATA_OFF, id2 + ISAKMP_ID_DATA_OFF,
	      idlen - ISAKMP_ID_DATA_OFF) : -1;
d207 1
a207 1
connection_passive_lookup_by_ids (u_int8_t *id1, u_int8_t *id2)
d209 1
a209 1
  struct connection_passive *conn;
d211 18
a228 38
  for (conn = TAILQ_FIRST (&connections_passive); conn;
       conn = TAILQ_NEXT (conn, link))
    {
      if (!conn->remote_id)
	continue;

      /*
       * If both IDs match what we have saved, return the name.  Don't bother
       * in which order they are.
       */
      if ((compare_ids (id1, conn->local_id, conn->local_sz) == 0
	   && compare_ids (id2, conn->remote_id, conn->remote_sz) == 0)
	  || (compare_ids (id1, conn->remote_id, conn->remote_sz) == 0
	      && compare_ids (id2, conn->local_id, conn->local_sz) == 0))
	{
	  LOG_DBG ((LOG_MISC, 60,
		    "connection_passive_lookup_by_ids: returned \"%s\"",
		    conn->name));
	  return conn->name;
	}
    }

  /* In the road warrior case, we do not know the remote ID. In that
   * case we will just match against the local ID.
   */
  for (conn = TAILQ_FIRST (&connections_passive); conn;
       conn = TAILQ_NEXT (conn, link))
    {
      if (!conn->remote_id)
	continue;

      if (compare_ids (id1, conn->local_id, conn->local_sz) == 0
	  || compare_ids (id2, conn->local_id, conn->local_sz) == 0)
	{
	  LOG_DBG ((LOG_MISC, 60,
		    "connection passive_lookup_by_ids: returned \"%s\""
		    " only matched local id", conn->name));
	  return conn->name;
d230 19
a248 2
    }
  LOG_DBG ((LOG_MISC, 60,
d250 1
a250 1
  return 0;
d259 1
a259 1
connection_setup (char *name)
d261 2
a262 2
  struct connection *conn = 0;
  struct timeval now;
d264 34
a297 43
  /* Check for trials to add duplicate connections.  */
  if (connection_lookup (name))
    {
      LOG_DBG ((LOG_MISC, 10, "connection_setup: cannot add \"%s\" twice",
		name));
      return 0;
    }

  conn = calloc (1, sizeof *conn);
  if (!conn)
    {
      log_error ("connection_setup: calloc (1, %lu) failed",
		 (unsigned long)sizeof *conn);
      goto fail;
    }

  conn->name = strdup (name);
  if (!conn->name)
    {
      log_error ("connection_setup: strdup (\"%s\") failed", name);
      goto fail;
    }

  gettimeofday (&now, 0);
  conn->ev
    = timer_add_event ("connection_checker", connection_checker, conn, &now);
  if (!conn->ev)
    {
      log_print ("connection_setup: could not add timer event");
      goto fail;
    }

  TAILQ_INSERT_TAIL (&connections, conn, link);
  return 0;

 fail:
  if (conn)
    {
      if (conn->name)
	free (conn->name);
      free (conn);
    }
  return -1;
d301 1
a301 1
connection_record_passive (char *name)
d303 17
a319 2
  struct connection_passive *conn;
  char *local_id, *remote_id;
d321 37
a357 63
  if (connection_passive_lookup_by_name (name))
    {
      LOG_DBG ((LOG_MISC, 10,
		"connection_record_passive: cannot add \"%s\" twice",
		name));
      return 0;
    }

  local_id = conf_get_str (name, "Local-ID");
  if (!local_id)
    {
      log_print ("connection_record_passive: "
		 "\"Local-ID\" is missing from section [%s]",
		 name);
      return -1;
    }

  /* If the remote id lookup fails we defer it to later */
  remote_id = conf_get_str (name, "Remote-ID");

  conn = calloc (1, sizeof *conn);
  if (!conn)
    {
      log_error ("connection_record_passive: calloc (1, %lu) failed",
		 (unsigned long)sizeof *conn);
      return -1;
    }

  conn->name = strdup (name);
  if (!conn->name)
    {
      log_error ("connection_record_passive: strdup (\"%s\") failed", name);
      goto fail;
    }

  /* XXX IPsec DOI-specific.  */
  conn->local_id = ipsec_build_id (local_id, &conn->local_sz);
  if (!conn->local_id)
    goto fail;

  if (remote_id)
    {
      conn->remote_id = ipsec_build_id (remote_id, &conn->remote_sz);
      if (!conn->remote_id)
	goto fail;
    }
  else
    conn->remote_id = 0;

  TAILQ_INSERT_TAIL (&connections_passive, conn, link);

  LOG_DBG ((LOG_MISC, 60,
	    "connection_record_passive: passive connection \"%s\" "
	    "added", conn->name));
  return 0;

 fail:
  if (conn->local_id)
    free (conn->local_id);
  if (conn->name)
    free (conn->name);
  free (conn);
  return -1;
d362 1
a362 1
connection_teardown (char *name)
d364 1
a364 1
  struct connection *conn;
d366 8
a373 8
  conn = connection_lookup (name);
  if (!conn)
    return;

  TAILQ_REMOVE (&connections, conn, link);
  timer_remove_event (conn->ev);
  free (conn->name);
  free (conn);
d378 1
a378 1
connection_passive_teardown (char *name)
d380 1
a380 1
  struct connection_passive *conn;
d382 9
a390 9
  conn = connection_passive_lookup_by_name (name);
  if (!conn)
    return;

  TAILQ_REMOVE (&connections_passive, conn, link);
  free (conn->name);
  free (conn->local_id);
  free (conn->remote_id);
  free (conn);
d394 1
a394 1
connection_report (void)
d396 2
a397 2
  struct connection *conn;
  struct timeval now;
d399 2
a400 2
  struct connection_passive *pconn;
  struct doi *doi = doi_lookup (ISAKMP_DOI_ISAKMP);
d403 6
a408 6
  gettimeofday (&now, 0);
  for (conn = TAILQ_FIRST (&connections); conn; conn = TAILQ_NEXT (conn, link))
    LOG_DBG ((LOG_REPORT, 0,
	      "connection_report: connection %s next check %ld seconds",
	      (conn->name ? conn->name : "<unnamed>"),
	      conn->ev->expiration.tv_sec - now.tv_sec));
d410 7
a416 7
  for (pconn = TAILQ_FIRST (&connections_passive); pconn;
       pconn = TAILQ_NEXT (pconn, link))
    LOG_DBG ((LOG_REPORT, 0,
	      "connection_report: passive connection %s %s", pconn->name,
	      doi->decode_ids ("local_id: %s, remote_id: %s",
			       pconn->local_id, pconn->local_sz,
			       pconn->remote_id, pconn->remote_sz, 1)));
d422 1
a422 1
connection_reinit (void)
d424 2
a425 2
  struct connection *conn, *next;
  struct connection_passive *pconn, *pnext;
d427 1
a427 1
  LOG_DBG ((LOG_MISC, 30,
d430 10
a439 12
  /* Remove all present connections.  */
  for (conn = TAILQ_FIRST (&connections); conn; conn = next)
    {
      next = TAILQ_NEXT (conn, link);
      connection_teardown (conn->name);
    }

  for (pconn = TAILQ_FIRST (&connections_passive); pconn; pconn = pnext)
    {
      pnext = TAILQ_NEXT (pconn, link);
      connection_passive_teardown (pconn->name);
    }
d441 2
a442 2
  /* Setup new connections, as the (new) config directs.  */
  connection_init ();
@


1.24
log
@Style, and a few additional format/type mods.
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.23 2002/06/01 07:44:21 deraadt Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.23
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.22 2001/07/06 14:37:11 ho Exp $	*/
d290 2
a291 1
      log_error ("connection_setup: calloc (1, %ld) failed", sizeof *conn);
@


1.22
log
@Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.21 2001/07/05 12:36:49 ho Exp $	*/
d290 1
a290 1
      log_error ("connection_setup: calloc (1, %d) failed", sizeof *conn);
d352 2
a353 2
      log_error ("connection_record_passive: calloc (1, %d) failed",
		 sizeof *conn);
@


1.21
log
@Add prototypes and some other various cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.20 2001/07/02 02:28:35 deraadt Exp $	*/
d93 1
a93 1
connection_init ()
@


1.20
log
@make the alpha happy
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.19 2001/07/01 19:48:43 niklas Exp $	*/
d61 2
d411 1
a411 1
void
@


1.19
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.18 2001/06/27 03:31:40 angelos Exp $	*/
d94 1
a94 1
  struct conf_list_node *conn, *attr;
@


1.18
log
@Consistently use "IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.17 2001/03/14 21:13:24 tholo Exp $	*/
d182 1
a182 1
  return (connection_lookup (name) != NULL);
d224 1
a224 1
      if (conn->remote_id == NULL)
d249 1
a249 1
      if (conn->remote_id != NULL)
d374 1
a374 1
    conn->remote_id = NULL;
@


1.17
log
@Make these compile again...
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.16 2001/03/14 12:15:45 niklas Exp $	*/
d362 1
a362 1
  /* XXX IPSec DOI-specific.  */
@


1.16
log
@Indentation and style fascism
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.15 2001/03/14 10:42:19 deraadt Exp $	*/
d465 1
a465 1
      next = TAILQ_NEXT (conn);
d471 1
a471 1
      pnext = TAILQ_NEXT (pconn);
@


1.15
log
@might as well throw a few crumbs at the anal compiler
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.14 2001/03/14 10:33:16 deraadt Exp $	*/
d78 1
a78 1
  struct sa *sa;                /* XXX "Soft" ref to active sa?  */ 
d123 4
a126 4
	      for (attr = TAILQ_FIRST (&attrs->fields); attr;
		   attr = TAILQ_NEXT (attr, link))
		if (strcasecmp ("active-only", attr->field) == 0)
		  break;
d199 1
a199 1
 * IDs of different types cannot be the same.  
d202 1
a202 1
static int 
d209 1
a209 1
  
d220 1
a220 1
  
d251 1
a251 1
      
d329 1
a329 1
      LOG_DBG ((LOG_MISC, 10, 
d334 1
a334 1
  
d354 1
a354 1
  
d367 1
a367 1
  if (remote_id) 
d377 1
a377 1
  
d415 1
a415 1
  if (!conn) 
d417 1
a417 1
  
d437 1
a437 1
    LOG_DBG ((LOG_REPORT, 0, 
d442 1
a442 1
  for (pconn = TAILQ_FIRST (&connections_passive); pconn; 
d445 1
a445 1
	      "connection_report: passive connection %s %s", pconn->name, 
d447 2
a448 2
				pconn->local_id, pconn->local_sz,
				pconn->remote_id, pconn->remote_sz, 1)));
d452 1
a452 1
/* Reinit all connections (SIGHUP handling).  */
d456 2
a457 2
  struct connection *conn;
  struct connection_passive *pconn;
d459 1
a459 1
  LOG_DBG ((LOG_MISC, 30, 
d463 5
d469 5
a473 5
  while ((conn = TAILQ_FIRST (&connections)))
    connection_teardown (conn->name);

  while ((pconn = TAILQ_FIRST (&connections_passive)))
    connection_passive_teardown (pconn->name);
@


1.14
log
@incorrect TAILQ management; chris@@stallion.oz.au, pr#1723
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.13 2001/01/27 12:03:31 niklas Exp $	*/
d464 1
a464 1
  while (conn = TAILQ_FIRST (&connections))
d467 1
a467 1
  while (pconn = TAILQ_FIRST (&connections_passive))
@


1.13
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.12 2001/01/26 12:12:51 niklas Exp $	*/
d464 1
a464 1
  for (conn = TAILQ_FIRST (&connections); conn; conn = TAILQ_NEXT (conn, link))
d467 1
a467 2
  for (pconn = TAILQ_FIRST (&connections_passive); pconn; 
       pconn = TAILQ_NEXT (pconn, link))
@


1.12
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.11 2000/11/23 12:56:59 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
@


1.11
log
@Merge with EOM 1.28

author: niklas
Fix log message

author: niklas
style
@
text
@d1 1
a1 1
/*	$OpenBSD: connection.c,v 1.10 2000/10/07 06:58:16 niklas Exp $	*/
d462 1
a462 1
  /* Remove all present connections. */
@


1.10
log
@Merge with EOM 1.26

author: ho
pconn variable only used with USE_DEBUG

author: ho
NetBSD wants <sys/socket.h> for AF_INET def.
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.9 2000/08/03 07:29:11 niklas Exp $	*/
/*	$EOM: connection.c,v 1.26 2000/09/12 16:27:08 ho Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
d210 3
a212 4
  return id1_type == id2_type ? 
    memcmp (id1 + ISAKMP_ID_DATA_OFF, 
	    id2 + ISAKMP_ID_DATA_OFF, 
	    idlen - ISAKMP_ID_DATA_OFF) : -1;
d231 4
a234 4
      if ((compare_ids (id1, conn->local_id, conn->local_sz) == 0 &&
	   compare_ids (id2, conn->remote_id, conn->remote_sz) == 0) ||
	  (compare_ids (id1, conn->remote_id, conn->remote_sz) == 0 &&
	   compare_ids (id2, conn->local_id, conn->local_sz) == 0))
d252 2
a253 2
      if (compare_ids (id1, conn->local_id, conn->local_sz) == 0 ||
	  compare_ids (id2, conn->local_id, conn->local_sz) == 0)
d339 1
a339 1
		 "\"Local-ID\" or \"Remote-ID\" is missing from section [%s]",
@


1.10.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.17 2001/03/14 21:13:24 tholo Exp $	*/
/*	$EOM: connection.c,v 1.28 2000/11/23 12:21:18 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
d78 1
a78 1
  struct sa *sa;                /* XXX "Soft" ref to active sa?  */
d123 4
a126 4
	    for (attr = TAILQ_FIRST (&attrs->fields); attr;
		 attr = TAILQ_NEXT (attr, link))
	      if (strcasecmp ("active-only", attr->field) == 0)
		break;
d199 1
a199 1
 * IDs of different types cannot be the same.
d202 1
a202 1
static int
d209 5
a213 4

  return id1_type == id2_type
    ? memcmp (id1 + ISAKMP_ID_DATA_OFF, id2 + ISAKMP_ID_DATA_OFF,
	      idlen - ISAKMP_ID_DATA_OFF) : -1;
d221 1
a221 1

d232 4
a235 4
      if ((compare_ids (id1, conn->local_id, conn->local_sz) == 0
	   && compare_ids (id2, conn->remote_id, conn->remote_sz) == 0)
	  || (compare_ids (id1, conn->remote_id, conn->remote_sz) == 0
	      && compare_ids (id2, conn->local_id, conn->local_sz) == 0))
d252 3
a254 3

      if (compare_ids (id1, conn->local_id, conn->local_sz) == 0
	  || compare_ids (id2, conn->local_id, conn->local_sz) == 0)
d330 1
a330 1
      LOG_DBG ((LOG_MISC, 10,
d335 1
a335 1

d340 1
a340 1
		 "\"Local-ID\" is missing from section [%s]",
d355 1
a355 1

d368 1
a368 1
  if (remote_id)
d378 1
a378 1

d416 1
a416 1
  if (!conn)
d418 1
a418 1

d438 1
a438 1
    LOG_DBG ((LOG_REPORT, 0,
d443 1
a443 1
  for (pconn = TAILQ_FIRST (&connections_passive); pconn;
d446 1
a446 1
	      "connection_report: passive connection %s %s", pconn->name,
d448 2
a449 2
			       pconn->local_id, pconn->local_sz,
			       pconn->remote_id, pconn->remote_sz, 1)));
d453 1
a453 1
/* Reinitialize all connections (SIGHUP handling).  */
d457 2
a458 2
  struct connection *conn, *next;
  struct connection_passive *pconn, *pnext;
d460 1
a460 1
  LOG_DBG ((LOG_MISC, 30,
d463 4
a466 6
  /* Remove all present connections.  */
  for (conn = TAILQ_FIRST (&connections); conn; conn = next)
    {
      next = TAILQ_NEXT (conn, link);
      connection_teardown (conn->name);
    }
d468 3
a470 5
  for (pconn = TAILQ_FIRST (&connections_passive); pconn; pconn = pnext)
    {
      pnext = TAILQ_NEXT (pconn, link);
      connection_passive_teardown (pconn->name);
    }
@


1.9
log
@Merge with EOM 1.24

author: niklas
style
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.8 2000/08/03 07:25:39 niklas Exp $	*/
/*	$EOM: connection.c,v 1.24 2000/08/03 07:20:35 niklas Exp $	*/
d40 1
a429 1
  struct connection_passive *pconn;
d432 1
@


1.8
log
@Merge with EOM 1.23

author: provos
make a DOI specific decode_ids, but have isakmp doi decode point to
ipsec.

author: provos
introduce ipsec_decode_ids, also decodes FQDN and USER_FQDN now.
new ipsec_clone_id to copy IDs to phase 2 SAs for better status
reports. okay angelos@@

author: provos
dont segfault on connection report when id is not set
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.7 2000/04/07 22:05:29 niklas Exp $	*/
/*	$EOM: connection.c,v 1.23 2000/07/02 18:47:15 provos Exp $	*/
d432 1
a432 1
  struct doi *doi = doi_lookup(ISAKMP_DOI_ISAKMP);
@


1.7
log
@Merge with EOM 1.20

author: provos
Do not require Remote-ID in connection_record_passiv, make lookup_by_ids
deal with it.  This helps road warrior support. okay ho@@ angelos@@
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.6 2000/02/25 17:23:39 niklas Exp $	*/
/*	$EOM: connection.c,v 1.20 2000/04/04 13:52:43 provos Exp $	*/
d47 1
d50 1
a50 1
/* XXX isakmp.h only required for compare_ids() and decode_ids().  */
a424 51
#ifdef USE_DEBUG
/* 
 * XXX Perhaps move this outside connection.c (ipsec.c?)
 * Perhaps rewrite without the duplicated code.
 */
static char *
decode_ids (char *fmt, u_int8_t *id1, u_int8_t *id2)
{
  int id_type;
  static char result[1024];
  char s_id1[256], s_id2[256];

  id_type = GET_ISAKMP_ID_TYPE (id1);
  switch (id_type)
    {
    case IPSEC_ID_IPV4_ADDR:
      snprintf (s_id1, 256, "%08x", decode_32 (id1 + ISAKMP_ID_DATA_OFF));
      break;
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      snprintf (s_id1, 256, "%08x", decode_32 (id1 + ISAKMP_ID_DATA_OFF));
      snprintf (s_id1 + strlen(s_id1), 256, "/%08x",
	       decode_32 (id1 + ISAKMP_ID_DATA_OFF + 4));
      break;
    /* XXX - IPV6 et al */
    default:
      strcpy (s_id1, "<notype>");
      break;
    }

  id_type = GET_ISAKMP_ID_TYPE (id2);
  switch (id_type)
    {
    case IPSEC_ID_IPV4_ADDR:
      snprintf (s_id2, 256, "%08x", decode_32 (id2 + ISAKMP_ID_DATA_OFF));
      break;
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      snprintf (s_id2, 256, "%08x", decode_32 (id2 + ISAKMP_ID_DATA_OFF));
      snprintf (s_id2 + strlen(s_id2), 256, "/%08x",
	       decode_32 (id2 + ISAKMP_ID_DATA_OFF + 4));
      break;
    /* XXX - IPV6 et al */
    default:
      strcpy (s_id2, "<notype>");
      break;
    }

  snprintf (result, 1024, fmt, s_id1, s_id2);
  return result;
}
#endif /* USE_DEBUG */

d431 3
d441 1
d446 4
a449 2
	      decode_ids ("local_id %s remote_id %s", pconn->local_id,
			  pconn->remote_id)));
@


1.6
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.5 1999/10/01 14:10:19 niklas Exp $	*/
/*	$EOM: connection.c,v 1.19 2000/02/20 19:58:36 niklas Exp $	*/
d223 3
d241 19
d335 1
a335 2
  remote_id = conf_get_str (name, "Remote-ID");
  if (!local_id || !remote_id)
d343 3
d366 8
a373 3
  conn->remote_id = ipsec_build_id (remote_id, &conn->remote_sz);
  if (!conn->remote_id)
    goto fail;
@


1.5
log
@Merge with EOM 1.18

author: niklas
actually tv_sec is long, so use %ld
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.4 1999/07/13 15:46:32 niklas Exp $	*/
/*	$EOM: connection.c,v 1.18 1999/08/31 11:08:57 niklas Exp $	*/
d232 3
a234 3
	  log_debug (LOG_MISC, 60,
		     "connection_passive_lookup_by_ids: returned \"%s\"",
		     conn->name);
d238 2
a239 2
  log_debug (LOG_MISC, 60,
	     "connection_passive_lookup_by_ids: no match");
d257 2
a258 2
      log_debug (LOG_MISC, 10, "connection_setup: cannot add \"%s\" twice",
		 name);
d306 3
a308 3
      log_debug (LOG_MISC, 10, 
		 "connection_record_passive: cannot add \"%s\" twice",
		 name);
d348 3
a350 3
  log_debug (LOG_MISC, 60,
	     "connection_record_passive: passive connection \"%s\" "
	     "added", conn->name);
d395 1
d444 1
d455 4
a458 4
    log_debug (LOG_REPORT, 0, 
	       "connection_report: connection %s next check %ld seconds",
	       (conn->name ? conn->name : "<unnamed>"),
	       conn->ev->expiration.tv_sec - now.tv_sec);
d461 4
a464 4
    log_debug (LOG_REPORT, 0,
	       "connection_report: passive connection %s %s", pconn->name, 
	       decode_ids ("local_id %s remote_id %s", pconn->local_id,
			   pconn->remote_id));
d474 2
a475 2
  log_debug (LOG_MISC, 30, 
	     "connection_reinit: reinitializing connection list");
@


1.4
log
@Merge with EOM 1.17

author: ho
Oops.
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.3 1999/07/07 22:04:34 niklas Exp $	*/
/*	$EOM: connection.c,v 1.17 1999/07/11 13:09:54 ho Exp $	*/
d454 1
a454 1
	       "connection_report: connection %s next check %d seconds",
@


1.3
log
@Merge with EOM 1.16

author: ho
Add copyright notice.

author: ho
Add connection_exist function
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.2 1999/06/02 06:31:37 niklas Exp $	*/
/*	$EOM: connection.c,v 1.16 1999/06/07 00:10:47 ho Exp $	*/
d454 1
a454 1
	       "connection_report: connection %s next check %ld seconds",
d456 1
a456 1
	       (long)conn->ev - now.tv_sec);
@


1.2
log
@Merge with EOM 1.14

author: ho
We do not require flags on implicit passive connections.

author: ho
Fix bug in matching IDs. Cleanup debugging.

author: ho
bug fix of decode_id function.

author: ho
Temp. add some more debugging around setup of passive connection

author: ho
Add more debugging output and correct connection_report

author: niklas
Some extra error checking, documentation and style wrt connections

author: ho
More passive connection support

author: niklas
Small bugfixes and style nits

author: ho
Expand the passive connection mechanism.

author: niklas
Some more #if 0 stuff for passive connections

author: ho
Commit to embryonic code for passive connections

author: niklas
Some type pedantery. Comment style nits.

author: ho
Add connections_report and connection_reinit
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.1 1999/05/02 05:52:48 niklas Exp $	*/
/*	$EOM: connection.c,v 1.14 1999/06/01 18:28:44 ho Exp $	*/
d6 1
d174 7
@


1.1
log
@New files I forgot to commit when adding the new connection abstraction
@
text
@d1 2
a2 2
/*	$OpenBSD: connection.c,v 1.1 1999/05/01 20:21:09 niklas Exp $	*/
/*	$EOM: connection.c,v 1.1 1999/05/01 20:21:09 niklas Exp $	*/
d46 5
d53 1
d65 15
d81 1
d90 8
a97 2
  struct conf_list *conns;
  struct conf_list_node *conn;
d100 2
d110 21
a130 1
	    continue;
d134 11
d175 60
d290 64
d368 110
@

