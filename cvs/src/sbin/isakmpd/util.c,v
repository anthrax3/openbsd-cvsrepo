head	1.69;
access;
symbols
	OPENBSD_6_0:1.69.0.4
	OPENBSD_6_0_BASE:1.69
	OPENBSD_5_9:1.69.0.2
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.68.0.10
	OPENBSD_5_8_BASE:1.68
	OPENBSD_5_7:1.68.0.2
	OPENBSD_5_7_BASE:1.68
	OPENBSD_5_6:1.68.0.6
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.68.0.4
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.65.0.16
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.14
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.12
	OPENBSD_5_0:1.65.0.10
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.65.0.8
	OPENBSD_4_9_BASE:1.65
	OPENBSD_4_8:1.65.0.6
	OPENBSD_4_8_BASE:1.65
	OPENBSD_4_7:1.65.0.2
	OPENBSD_4_7_BASE:1.65
	OPENBSD_4_6:1.65.0.4
	OPENBSD_4_6_BASE:1.65
	OPENBSD_4_5:1.63.0.10
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.63.0.8
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.63.0.6
	OPENBSD_4_3_BASE:1.63
	OPENBSD_4_2:1.63.0.4
	OPENBSD_4_2_BASE:1.63
	OPENBSD_4_1:1.63.0.2
	OPENBSD_4_1_BASE:1.63
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.60.0.2
	OPENBSD_3_9_BASE:1.60
	OPENBSD_3_8:1.58.0.2
	OPENBSD_3_8_BASE:1.58
	OPENBSD_3_7:1.52.0.2
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.48.0.2
	OPENBSD_3_6_BASE:1.48
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.69
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	0qPuuXwccpVXsXcV;

1.68
date	2014.01.23.01.04.28;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.22.03.09.31;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.24.13.46.09;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2009.06.25.15.40.55;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.05.22.40.23;	author chris;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.24.11.45.44;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches;
next	1.60;

1.60
date	2005.12.28.10.57.35;	author hshoexer;	state Exp;
branches;
next	1.59;

1.59
date	2005.11.15.21.49.04;	author cloder;	state Exp;
branches;
next	1.58;

1.58
date	2005.07.25.14.56.42;	author hshoexer;	state Exp;
branches;
next	1.57;

1.57
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.56;

1.56
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.08.18.52.23;	author hshoexer;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.08.16.09.25;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.10.21.39.21;	author hshoexer;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.04.16.51.52;	author hshoexer;	state Exp;
branches;
next	1.50;

1.50
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.14.10.17.28;	author mcbride;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.30.10.45.27;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.25.19.42.38;	author mcbride;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.23.03.01.53;	author hshoexer;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.23.01.17.29;	author ho;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.16.15.08.20;	author hshoexer;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.14.09.55.42;	author ho;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.24.14.54.50;	author hshoexer;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.23.16.14.22;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.14.14.50.23;	author ho;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.13.10.31.44;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.06.14.22.13;	author cedric;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.06.09.56.25;	author ho;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.09.02.51.59;	author ho;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.28.11.23.20;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.23.18.44.48;	author ho;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.23.17.10.09;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.19.20.12.02;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.26.13.29.26;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.26.12.03.07;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.03.23.39.01;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.01.19.59.13;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.01.14.23.30;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.01.05.42.05;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.29.22.59.41;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.29.04.52.22;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.29.04.12.01;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.05.16.49;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.00.10.35;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.05.23.02.02;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.23.12.57.15;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.27.19.22.36;	author niklas;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.10.16.23.27.03;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.13.13.22.02;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.07.06.59.39;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.08.05.22.40.37;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.04.19.19.54.54;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.03.52.40;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.22;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.08.12.45.26;	author ho;	state Exp;
branches;
next	;


desc
@@


1.69
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@/* $OpenBSD: util.c,v 1.68 2014/01/23 01:04:28 deraadt Exp $	 */
/* $EOM: util.c,v 1.23 2000/11/23 12:22:08 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2000, 2001, 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <limits.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <ifaddrs.h>
#include <net/route.h>
#include <net/if.h>

#include "log.h"
#include "message.h"
#include "monitor.h"
#include "transport.h"
#include "util.h"

/*
 * Set if -N is given, allowing name lookups to be done, possibly stalling
 * the daemon for quite a while.
 */
int	allow_name_lookups = 0;

/*
 * XXX These might be turned into inlines or macros, maybe even
 * machine-dependent ones, for performance reasons.
 */
u_int16_t
decode_16(u_int8_t *cp)
{
	return cp[0] << 8 | cp[1];
}

u_int32_t
decode_32(u_int8_t *cp)
{
	return cp[0] << 24 | cp[1] << 16 | cp[2] << 8 | cp[3];
}

void
encode_16(u_int8_t *cp, u_int16_t x)
{
	*cp++ = x >> 8;
	*cp = x & 0xff;
}

void
encode_32(u_int8_t *cp, u_int32_t x)
{
	*cp++ = x >> 24;
	*cp++ = (x >> 16) & 0xff;
	*cp++ = (x >> 8) & 0xff;
	*cp = x & 0xff;
}

/* Check a buffer for all zeroes.  */
int
zero_test(const u_int8_t *p, size_t sz)
{
	while (sz-- > 0)
		if (*p++ != 0)
			return 0;
	return 1;
}

static __inline int
hex2nibble(char c)
{
	if (c >= '0' && c <= '9')
		return c - '0';
	if (c >= 'a' && c <= 'f')
		return c - 'a' + 10;
	if (c >= 'A' && c <= 'F')
		return c - 'A' + 10;
	return -1;
}

/*
 * Convert hexadecimal string in S to raw binary buffer at BUF sized SZ
 * bytes.  Return 0 if everything is OK, -1 otherwise.
 */
int
hex2raw(char *s, u_int8_t *buf, size_t sz)
{
	u_int8_t *bp;
	char	*p;
	int	tmp;

	if (strlen(s) > sz * 2)
		return -1;
	for (p = s + strlen(s) - 1, bp = &buf[sz - 1]; bp >= buf; bp--) {
		*bp = 0;
		if (p >= s) {
			tmp = hex2nibble(*p--);
			if (tmp == -1)
				return -1;
			*bp = tmp;
		}
		if (p >= s) {
			tmp = hex2nibble(*p--);
			if (tmp == -1)
				return -1;
			*bp |= tmp << 4;
		}
	}
	return 0;
}

/*
 * Convert raw binary buffer to a newly allocated hexadecimal string.  Returns
 * NULL if an error occurred.  It is the caller's responsibility to free the
 * returned string.
 */
char *
raw2hex(u_int8_t *buf, size_t sz)
{
	char *s;
	size_t i;

	if ((s = malloc(sz * 2 + 1)) == NULL) {
		log_error("raw2hex: malloc (%lu) failed", (unsigned long)sz * 2 + 1);
		return NULL;
	}

	for (i = 0; i < sz; i++)
		snprintf(s + (2 * i), 2 * (sz - i) + 1, "%02x", buf[i]);

	s[sz * 2] = '\0';
	return s;
}

in_port_t
text2port(char *port_str)
{
	char           *port_str_end;
	long            port_long;
	struct servent *service;

	port_long = strtol(port_str, &port_str_end, 0);
	if (port_str == port_str_end) {
		service = getservbyname(port_str, "udp");
		if (!service) {
			log_print("text2port: service \"%s\" unknown",
			    port_str);
			return 0;
		}
		return ntohs(service->s_port);
	} else if (port_long < 1 || port_long > (long)USHRT_MAX) {
		log_print("text2port: port %ld out of range", port_long);
		return 0;
	}
	return port_long;
}

int
text2sockaddr(char *address, char *port, struct sockaddr **sa, sa_family_t af,
    int netmask)
{
	struct addrinfo *ai, hints;
	struct sockaddr_storage tmp_sas;
	struct ifaddrs *ifap, *ifa = NULL, *llifa = NULL;
	char *np = address;
	char ifname[IFNAMSIZ];
	u_char buf[BUFSIZ];
	struct rt_msghdr *rtm;
	struct sockaddr *sa2;
	struct sockaddr_in *sin;
	struct sockaddr_in6 *sin6;
	int fd = 0, seq, len, b;
	pid_t pid;

	bzero(&hints, sizeof hints);
	if (!allow_name_lookups)
		hints.ai_flags = AI_NUMERICHOST;
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_protocol = IPPROTO_UDP;

	if (getaddrinfo(address, port, &hints, &ai)) {
		/*
		 * If the 'default' keyword is used, do a route lookup for
		 * the default route, and use the interface associated with
		 * it to select a source address.
		 */
		if (!strcmp(address, "default")) {
			fd = socket(PF_ROUTE, SOCK_RAW, af);

			bzero(buf, sizeof(buf));

			rtm = (struct rt_msghdr *)buf;
			rtm->rtm_version = RTM_VERSION;
			rtm->rtm_type = RTM_GET;
			rtm->rtm_flags = RTF_UP;
			rtm->rtm_addrs = RTA_DST;
			rtm->rtm_seq = seq = arc4random();

			/* default destination */
			sa2 = (struct sockaddr *)((char *)rtm + rtm->rtm_hdrlen);
			switch (af) {
			case AF_INET: {
				sin = (struct sockaddr_in *)sa2;
				sin->sin_len = sizeof(*sin);
				sin->sin_family = af;
				break;
			}
			case AF_INET6: {
				sin6 = (struct sockaddr_in6 *)sa2;
				sin6->sin6_len = sizeof(*sin6);
				sin6->sin6_family = af;
				break;
			}
			default:
				close(fd);
				return -1;
			}
			rtm->rtm_addrs |= RTA_NETMASK|RTA_IFP|RTA_IFA;
			rtm->rtm_msglen = sizeof(*rtm) + sizeof(*sa2);

			if ((b = write(fd, buf, rtm->rtm_msglen)) < 0) {
				close(fd);
				return -1;
			}

			pid = getpid();

			while ((len = read(fd, buf, sizeof(buf))) > 0) {
				if (len < sizeof(*rtm)) {
					close(fd);
					return -1;
				}
				if (rtm->rtm_version != RTM_VERSION)
					continue;

				if (rtm->rtm_type == RTM_GET &&
				    rtm->rtm_pid == pid &&
				    rtm->rtm_seq == seq) {
					if (rtm->rtm_errno) {
						close(fd);
						return -1;
					}
					break;
				}
			}
			close(fd);

			if ((rtm->rtm_addrs & (RTA_DST|RTA_GATEWAY)) ==
			    (RTA_DST|RTA_GATEWAY)) {
				np = if_indextoname(rtm->rtm_index, ifname);
				if (np == NULL)
					return -1;
			}
		}

		if (getifaddrs(&ifap) != 0)
			return -1;

		switch (af) {
		default:
		case AF_INET:
			for (ifa = ifap; ifa; ifa = ifa->ifa_next)
				if (!strcmp(ifa->ifa_name, np) &&
				    ifa->ifa_addr != NULL &&
				    ifa->ifa_addr->sa_family == AF_INET)
					break;
			break;
		case AF_INET6:
			for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
				if (!strcmp(ifa->ifa_name, np) &&
				    ifa->ifa_addr != NULL &&
				    ifa->ifa_addr->sa_family == AF_INET6) {
					if (IN6_IS_ADDR_LINKLOCAL(
					    &((struct sockaddr_in6 *)
					    ifa->ifa_addr)->sin6_addr) &&
					    llifa == NULL)
						llifa = ifa;
					else
						break;
				}
			}
			if (ifa == NULL) {
				ifa = llifa;
			}
			break;
		}

		if (ifa) {
			if (netmask)
				memcpy(&tmp_sas, ifa->ifa_netmask,
				    SA_LEN(ifa->ifa_netmask));
			else
				memcpy(&tmp_sas, ifa->ifa_addr,
				    SA_LEN(ifa->ifa_addr));
			freeifaddrs(ifap);
		} else {
			freeifaddrs(ifap);
			return -1;
		}
	} else {
		memcpy(&tmp_sas, ai->ai_addr, SA_LEN(ai->ai_addr));
		freeaddrinfo(ai);
	}

	*sa = malloc(SA_LEN((struct sockaddr *)&tmp_sas));
	if (!*sa)
		return -1;

	memcpy(*sa, &tmp_sas, SA_LEN((struct sockaddr *)&tmp_sas));
	return 0;
}

/*
 * Convert a sockaddr to text. With zflag non-zero fill out with zeroes,
 * i.e 10.0.0.10 --> "010.000.000.010"
 */
int
sockaddr2text(struct sockaddr *sa, char **address, int zflag)
{
	char	buf[NI_MAXHOST], *token, *bstart, *ep;
	int	addrlen, i, j;
	long	val;

	if (getnameinfo(sa, SA_LEN(sa), buf, sizeof buf, 0, 0,
			allow_name_lookups ? 0 : NI_NUMERICHOST))
		return -1;

	if (zflag == 0) {
		*address = strdup(buf);
		if (!*address)
			return -1;
	} else
		switch (sa->sa_family) {
		case AF_INET:
			addrlen = sizeof "000.000.000.000";
			*address = malloc(addrlen);
			if (!*address)
				return -1;
			buf[addrlen] = '\0';
			bstart = buf;
			**address = '\0';
			while ((token = strsep(&bstart, ".")) != NULL) {
				if (strlen(*address) > 12) {
					free(*address);
					return -1;
				}
				val = strtol(token, &ep, 10);
				if (ep == token || val < (long)0 ||
				    val > (long)UCHAR_MAX) {
					free(*address);
					return -1;
				}
				snprintf(*address + strlen(*address),
				    addrlen - strlen(*address), "%03ld", val);
				if (bstart)
					strlcat(*address, ".", addrlen);
			}
			break;

		case AF_INET6:
			/*
			 * XXX In the algorithm below there are some magic
			 * numbers we probably could give explaining names.
			 */
			addrlen =
			    sizeof "0000:0000:0000:0000:0000:0000:0000:0000";
			*address = malloc(addrlen);
			if (!*address)
				return -1;

			for (i = 0, j = 0; i < 8; i++) {
				snprintf((*address) + j, addrlen - j,
				    "%02x%02x",
				    ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2*i],
				    ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2*i + 1]);
				j += 4;
				(*address)[j] =
				    (j < (addrlen - 1)) ? ':' : '\0';
				j++;
			}
			break;

		default:
			*address = strdup("<error>");
			if (!*address)
				return -1;
		}

	return 0;
}

/*
 * sockaddr_addrlen and sockaddr_addrdata return the relevant sockaddr info
 * depending on address family.  Useful to keep other code shorter(/clearer?).
 */
int
sockaddr_addrlen(struct sockaddr *sa)
{
	switch (sa->sa_family) {
	case AF_INET6:
		return sizeof((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr;
	case AF_INET:
		return sizeof((struct sockaddr_in *)sa)->sin_addr.s_addr;
	default:
		log_print("sockaddr_addrlen: unsupported protocol family %d",
		    sa->sa_family);
		return 0;
	}
}

u_int8_t *
sockaddr_addrdata(struct sockaddr *sa)
{
	switch (sa->sa_family) {
	case AF_INET6:
		return (u_int8_t *)&((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr;
	case AF_INET:
		return (u_int8_t *)&((struct sockaddr_in *)sa)->sin_addr.s_addr;
	default:
		log_print("sockaddr_addrdata: unsupported protocol family %d",
		    sa->sa_family);
		return 0;
	}
}

in_port_t
sockaddr_port(struct sockaddr *sa)
{
	switch (sa->sa_family) {
	case AF_INET6:
		return ((struct sockaddr_in6 *)sa)->sin6_port;
	case AF_INET:
		return ((struct sockaddr_in *)sa)->sin_port;
	default:
		log_print("sockaddr_port: unsupported protocol family %d",
		    sa->sa_family);
		return 0;
	}
}

/* Utility function used to set the port of a sockaddr.  */
void
sockaddr_set_port(struct sockaddr *sa, in_port_t port)
{
	switch (sa->sa_family) {
	case AF_INET:
		((struct sockaddr_in *)sa)->sin_port = htons (port);
		break;

	case AF_INET6:
		((struct sockaddr_in6 *)sa)->sin6_port = htons (port);
		break;
	}
}

/*
 * Convert network address to text. The network address does not need
 * to be properly aligned.
 */
void
util_ntoa(char **buf, int af, u_int8_t *addr)
{
	struct sockaddr_storage from;
	struct sockaddr *sfrom = (struct sockaddr *) & from;
	socklen_t	fromlen = sizeof from;

	bzero(&from, fromlen);
	sfrom->sa_family = af;

	switch (af) {
	case AF_INET:
		sfrom->sa_len = sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		sfrom->sa_len = sizeof(struct sockaddr_in6);
		break;
	}

	memcpy(sockaddr_addrdata(sfrom), addr, sockaddr_addrlen(sfrom));

	if (sockaddr2text(sfrom, buf, 0)) {
		log_print("util_ntoa: could not make printable address out "
		    "of sockaddr %p", sfrom);
		*buf = 0;
	}
}

/*
 * Perform sanity check on files containing secret information.
 * Returns -1 on failure, 0 otherwise.
 * Also, if FILE_SIZE is a not a null pointer, store file size here.
 */

int
check_file_secrecy_fd(int fd, char *name, size_t *file_size)
{
	struct stat st;

	if (fstat(fd, &st) == -1) {
		log_error("check_file_secrecy: stat (\"%s\") failed", name);
		return -1;
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_print("check_file_secrecy_fd: "
		    "not loading %s - file owner is not process user", name);
		errno = EPERM;
		return -1;
	}
	if ((st.st_mode & (S_IRWXG | S_IRWXO)) != 0) {
		log_print("check_file_secrecy_fd: not loading %s - too open "
		    "permissions", name);
		errno = EPERM;
		return -1;
	}
	if (file_size)
		*file_size = (size_t)st.st_size;

	return 0;
}

/* Calculate timeout.  Returns -1 on error. */
long
get_timeout(struct timeval *timeout)
{
	struct timeval	now, result;

	if (gettimeofday(&now, NULL) < 0)
		return -1;

	timersub(timeout, &now, &result);

	return result.tv_sec;
}

int
expand_string(char *label, size_t len, const char *srch, const char *repl)
{
	char *tmp;
	char *p, *q;

	if ((tmp = calloc(1, len)) == NULL) {
		log_error("expand_string: calloc");
		return (-1);
	}
	p = q = label;
	while ((q = strstr(p, srch)) != NULL) {
		*q = '\0';
		if ((strlcat(tmp, p, len) >= len) ||
		    (strlcat(tmp, repl, len) >= len)) {
			log_print("expand_string: string too long");
			return (-1);
		}
		q += strlen(srch);
		p = q;
	}
	if (strlcat(tmp, p, len) >= len) {
		log_print("expand_string: string too long");
		return (-1);
	}
	strlcpy(label, tmp, len);	/* always fits */
	free(tmp);

	return (0);
}
@


1.68
log
@Remove a mid-layer which acts like arc4random isn't fairly standard.
ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.67 2014/01/22 03:09:31 deraadt Exp $	 */
d156 1
a156 1
	if ((s = (char *)malloc(sz * 2 + 1)) == NULL) {
@


1.67
log
@improve randomization.  remove some junk debugging features that are
fundamentally broken.
ok jsing mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.66 2013/04/24 13:46:09 deraadt Exp $	 */
a99 19
}

/*
 * Generate 32 bits of random data.
 */
u_int32_t
rand_32(void)
{
	return arc4random();
}

/*
 * Generate a random data, len bytes long.
 */
u_int8_t *
getrandom(u_int8_t *buf, size_t len)
{
	arc4random_buf(buf, len);
	return buf;
@


1.66
log
@remove old backwards random junk
ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.65 2009/06/25 15:40:55 claudio Exp $	 */
a50 1
#include "sysdep.h"
d117 1
a117 11
	u_int32_t	tmp = 0;
	size_t		i;

	for (i = 0; i < len; i++) {
		if (i % sizeof tmp == 0)
			tmp = rand_32();

		buf[i] = tmp & 0xff;
		tmp >>= 8;
	}

a586 12


/* Special for compiling with Boehms GC. See Makefile and sysdep.h  */
#if defined (USE_BOEHM_GC)
char *
gc_strdup(const char *x)
{
	char *strcpy(char *,const char *);
	char *y = malloc(strlen(x) + 1);
	return strcpy(y,x);
}
#endif
@


1.65
log
@Add missing RTM_VERSION check. This is needed before accessing other data
from routing messages retrieved via routing socket or sysctl.
Tested and OK sthen@@, OK henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.64 2009/06/05 22:40:23 chris Exp $	 */
a60 8
#if defined(INSECURE_RAND)
/*
 * This is set to true in case of regression-test mode, when it will
 * cause predictable random numbers be generated.
 */
int	regrand = 0;
#endif

d104 1
a104 2
 * Generate 32 bits of random data.  If compiled with INSECURE_RAND
 * and -r option is specified, then return deterministic data.
a108 1
#if !defined(INSECURE_RAND)
a109 6
#else
	if (regrand)
		return random();
	else
		return arc4random();
#endif
@


1.64
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.63 2006/11/24 13:52:14 reyk Exp $	 */
d313 2
@


1.63
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.62 2006/07/24 11:45:44 ho Exp $	 */
d280 1
a280 1
			sa2 = (struct sockaddr *)(rtm + 1);
@


1.62
log
@Style; return is not a function. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.61 2006/06/02 19:35:55 hshoexer Exp $	 */
d624 31
@


1.61
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.60 2005/12/28 10:57:35 hshoexer Exp $	 */
d296 1
a296 1
				return (-1);
d303 1
a303 1
				return (-1);
d311 1
a311 1
					return (-1);
d319 1
a319 1
						return (-1);
d330 1
a330 1
					return (-1);
d335 1
a335 1
			return (-1);
@


1.60
log
@remove some unused functions and an unused variable found by lint.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.59 2005/11/15 21:49:04 cloder Exp $	 */
d193 1
a193 1
 * NULL if an error occured.  It is the caller's responsibility to free the
@


1.59
log
@Add a new raw2hex function and yank out several pieces of code in other
places that were doing this.  Prodding deraadt.  OK hshoexer.
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.58 2005/07/25 14:56:42 hshoexer Exp $	 */
a69 5
 * If in regression-test mode, this is the seed used.
 */
u_long	seed;

/*
a84 8
u_int64_t
decode_64(u_int8_t *cp)
{
	return (u_int64_t) cp[0] << 56 | (u_int64_t) cp[1] << 48 |
	    (u_int64_t) cp[2] << 40 | (u_int64_t) cp[3] << 32 |
	    cp[4] << 24 | cp[5] << 16 | cp[6] << 8 | cp[7];
}

a100 13
void
encode_64(u_int8_t *cp, u_int64_t x)
{
	*cp++ = x >> 56;
	*cp++ = (x >> 48) & 0xff;
	*cp++ = (x >> 40) & 0xff;
	*cp++ = (x >> 32) & 0xff;
	*cp++ = (x >> 24) & 0xff;
	*cp++ = (x >> 16) & 0xff;
	*cp++ = (x >> 8) & 0xff;
	*cp = x & 0xff;
}

a106 10
			return 0;
	return 1;
}

/* Check a buffer for all ones.  */
int
ones_test(const u_int8_t *p, size_t sz)
{
	while (sz-- > 0)
		if (*p++ != 0xff)
@


1.58
log
@output some more information on UI command "S"

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.57 2005/04/08 23:15:26 hshoexer Exp $	 */
d225 23
@


1.57
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.56 2005/04/08 22:32:10 cloder Exp $	 */
d611 15
@


1.56
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.55 2005/04/08 18:52:23 hshoexer Exp $	 */
d382 1
a382 1
				    sysdep_sa_len(ifa->ifa_netmask));
d385 1
a385 1
				    sysdep_sa_len(ifa->ifa_addr));
d392 1
a392 1
		memcpy(&tmp_sas, ai->ai_addr, sysdep_sa_len(ai->ai_addr));
d396 1
a396 1
	*sa = malloc(sysdep_sa_len((struct sockaddr *)&tmp_sas));
d400 1
a400 1
	memcpy(*sa, &tmp_sas, sysdep_sa_len((struct sockaddr *)&tmp_sas));
d415 1
a415 1
	if (getnameinfo(sa, sysdep_sa_len(sa), buf, sizeof buf, 0, 0,
@


1.55
log
@zap USE_DEFAULT_ROUTE
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.54 2005/04/08 16:09:25 deraadt Exp $	 */
a47 2
#include "sysdep.h"

d61 1
d67 1
d148 17
d175 1
a175 1
			tmp = sysdep_random();
@


1.54
log
@kill USE_OLD_SOCKADDR
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.53 2005/04/04 19:31:11 deraadt Exp $	 */
a240 1
#ifdef USE_DEFAULT_ROUTE
a248 1
#endif /* USE_DEFAULT_ROUTE */
a257 1
#ifdef USE_DEFAULT_ROUTE
a328 1
#endif /* USE_DEFAULT_ROUTE */
@


1.53
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.52 2005/03/10 21:39:21 hshoexer Exp $	 */
d547 1
a547 1
#ifndef USE_OLD_SOCKADDR
d556 1
a556 1
#endif
@


1.52
log
@remove dead code, noted by ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.51 2005/03/04 16:51:52 hshoexer Exp $	 */
d268 1
a268 1
			
d276 1
a276 1
			rtm->rtm_seq = seq = arc4random(); 
d330 1
a330 1
			}	
d333 1
a333 1
	
d342 1
a342 1
				    ifa->ifa_addr != NULL && 
d349 1
a349 1
				    ifa->ifa_addr != NULL && 
d353 1
a353 1
					    ifa->ifa_addr)->sin6_addr) && 
d365 1
a365 1
  
a369 1
				    
@


1.51
log
@remove unused function udp_decode_port(), add modified version as text2port() to
utilities.

ok cloder ho
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.50 2005/02/27 13:12:12 hshoexer Exp $	 */
a97 22
#if 0
/*
 * XXX I severly doubt that we will need this.  IPv6 does not have the legacy
 * of representation in host byte order, AFAIK.
 */

void
decode_128(u_int8_t *cp, u_int8_t *cpp)
{
#if BYTE_ORDER == LITTLE_ENDIAN
	int	i;

	for (i = 0; i < 16; i++)
		cpp[i] = cp[15 - i];
#elif BYTE_ORDER == BIG_ENDIAN
	bcopy(cp, cpp, 16);
#else
#error "Byte order unknown!"
#endif
}
#endif

a125 13

#if 0
/*
 * XXX I severly doubt that we will need this.  IPv6 does not have the legacy
 * of representation in host byte order, AFAIK.
 */

void
encode_128(u_int8_t *cp, u_int8_t *cpp)
{
	decode_128(cpp, cp);
}
#endif
@


1.50
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.49 2004/12/14 10:17:28 mcbride Exp $	 */
d243 23
@


1.49
log
@Allow the Address, Network, or Netmask values of the <IPsec-ID> to be
specified with an interface name (in which case the first address is used)
or the keyword 'default' (in which case the address is selected based on the
default route). eg:

[roadwarrior-ip]
ID-type=                IPV4_ADDR
Address=                default

ok ho@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.48 2004/08/08 19:11:06 deraadt Exp $	 */
d264 1
a264 1
	memset(&hints, 0, sizeof hints);
d281 1
a281 1
			memset(buf, 0, sizeof(buf));
d558 1
a558 1
	memset(&from, 0, fromlen);
@


1.48
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.47 2004/07/30 10:45:27 ho Exp $	 */
d44 3
d246 2
a247 1
text2sockaddr(char *address, char *port, struct sockaddr **sa)
d250 13
d271 124
a394 2
	if (getaddrinfo(address, port, &hints, &ai))
		return -1;
d396 2
a397 3
	*sa = malloc(sysdep_sa_len(ai->ai_addr));
	if (!*sa) {
		freeaddrinfo(ai);
a398 1
	}
d400 1
a400 2
	memcpy(*sa, ai->ai_addr, sysdep_sa_len(ai->ai_addr));
	freeaddrinfo(ai);
@


1.47
log
@Style.
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.46 2004/06/25 19:42:38 mcbride Exp $	 */
d259 1
a259 1
      		freeaddrinfo(ai);
@


1.46
log
@Remove HAVE_GETNAMEINFO alternate code. Compiled binary is unchanged.

ok msf@@ hshoexer@@ itojun@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.45 2004/06/23 03:01:53 hshoexer Exp $	 */
d479 1
a479 1
my_strdup(const char *x)
@


1.45
log
@Avoid stat before open.  Do open and fstat instead.
Remove check_file_secrecy() as it is obsoleted be check_file_secrecy_fd().

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.44 2004/06/23 01:17:29 ho Exp $	 */
a244 1
#ifdef HAVE_GETNAMEINFO
a265 38
#else
	int	af = strchr(address, ':') != NULL ? AF_INET6 : AF_INET;
	size_t	sz = af == AF_INET ? sizeof(struct sockaddr_in) :
	    sizeof(struct sockaddr_in6);
	long	lport;
	struct servent *sp;
	char	*ep;

	*sa = calloc(1, sz);
	if (!*sa)
		return -1;

#ifndef USE_OLD_SOCKADDR
	(*sa)->sa_len = sz;
#endif
	(*sa)->sa_family = af;
	if (inet_pton(af, address, sockaddr_addrdata(*sa)) != 1) {
		free(*sa);
		return -1;
	}
	if (!port)
		return 0;
	sp = getservbyname(port, "udp");
	if (!sp) {
		lport = strtol(port, &ep, 10);
		if (ep == port || lport < 0 || lport > (long)USHRT_MAX) {
			free(*sa);
			return -1;
		}
		lport = htons(lport);
	} else
		lport = sp->s_port;
	if ((*sa)->sa_family == AF_INET)
		((struct sockaddr_in *)*sa)->sin_port = lport;
	else
		((struct sockaddr_in6 *)*sa)->sin6_port = lport;
	return 0;
#endif
a278 1
#ifdef HAVE_GETNAMEINFO
a281 20
#else
	switch (sa->sa_family) {
	case AF_INET:
	case AF_INET6:
		if (inet_ntop(sa->sa_family, sa->sa_data, buf, NI_MAXHOST - 1)
		    == NULL) {
			log_error("sockaddr2text: inet_ntop (%d, %p, %p, %d) "
			    "failed", sa->sa_family, sa->sa_data, buf,
			    NI_MAXHOST - 1);
			return -1;
		}
		buf[NI_MAXHOST - 1] = '\0';
		break;

	default:
		log_print("sockaddr2text: unsupported protocol family %d\n",
		    sa->sa_family);
		return -1;
	}
#endif
@


1.44
log
@Make compiling with Boehm's gc possible again.
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.43 2004/06/20 15:24:05 ho Exp $	 */
a507 26
int
check_file_secrecy(char *name, size_t *file_size)
{
	struct stat st;

	if (monitor_stat(name, &st) == -1) {
		log_error("check_file_secrecy: stat (\"%s\") failed", name);
		return -1;
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_print("check_file_secrecy: "
		    "not loading %s - file owner is not process user", name);
		errno = EPERM;
		return -1;
	}
	if ((st.st_mode & (S_IRWXG | S_IRWXO)) != 0) {
		log_print("check_file_secrecy: not loading %s - too open "
		    "permissions", name);
		errno = EPERM;
		return -1;
	}
	if (file_size)
		*file_size = (size_t)st.st_size;

	return 0;
}
@


1.43
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.42 2004/06/16 15:08:20 hshoexer Exp $	 */
d561 11
@


1.42
log
@Fix wrong pointer dereference and plug memleak.  Found and patch by
Patrick Latifi.  Thanks!

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.41 2004/06/14 09:55:42 ho Exp $	 */
d6 1
a6 1
 * Copyright (c) 2000, 2001 Håkan Olsson.  All rights reserved.
d453 15
@


1.41
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.40 2004/05/24 14:54:50 hshoexer Exp $	 */
d259 2
a260 1
	if (!sa)
d262 1
@


1.40
log
@Use correct function names in log messages.  Kill some spaces.

ok deraadt@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.39 2004/05/23 18:17:56 hshoexer Exp $	 */
d378 2
a379 1
			addrlen = sizeof "0000:0000:0000:0000:0000:0000:0000:0000";
d390 2
a391 1
				(*address)[j] = (j < (addrlen - 1)) ? ':' : '\0';
@


1.39
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.38 2004/05/23 16:14:22 deraadt Exp $	 */
d505 1
a505 1
		log_print("conf_file_secrecy: not loading %s - too open "
d526 1
a526 1
		log_print("check_file_secrecy: "
d532 2
a533 2
		log_print("conf_file_secrecy: not loading %s - too open permissions",
		    name);
d538 1
a538 1
		*file_size = (size_t) st.st_size;
@


1.38
log
@stat before open is flawed
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.37 2004/04/15 18:39:26 deraadt Exp $	 */
d243 1
a243 1
text2sockaddr(char *address, char *port, struct sockaddr ** sa)
d290 1
a290 1
		if (ep == port || lport < 0 || lport > (long) USHRT_MAX) {
d298 1
a298 1
		((struct sockaddr_in *) *sa)->sin_port = lport;
d300 1
a300 1
		((struct sockaddr_in6 *) *sa)->sin6_port = lport;
d324 5
a328 3
		if (inet_ntop(sa->sa_family, sa->sa_data, buf, NI_MAXHOST - 1) == NULL) {
			log_error("sockaddr2text: inet_ntop (%d, %p, %p, %d) failed",
			    sa->sa_family, sa->sa_data, buf, NI_MAXHOST - 1);
d336 1
a336 1
			  sa->sa_family);
d361 2
a362 2
				if (ep == token || val < (long) 0 ||
				    val > (long) UCHAR_MAX) {
d375 2
a376 2
			 * XXX In the algorithm below there are some magic numbers we
			 * probably could give explaining names.
d384 2
a385 1
				snprintf((*address) + j, addrlen - j, "%02x%02x",
d412 1
a412 1
		return sizeof((struct sockaddr_in6 *) sa)->sin6_addr.s6_addr;
d414 1
a414 1
		return sizeof((struct sockaddr_in *) sa)->sin_addr.s_addr;
d427 1
a427 1
		return (u_int8_t *) & ((struct sockaddr_in6 *) sa)->sin6_addr.s6_addr;
d429 1
a429 1
		return (u_int8_t *) & ((struct sockaddr_in *) sa)->sin_addr.s_addr;
d442 1
a442 1
		return ((struct sockaddr_in6 *) sa)->sin6_port;
d444 1
a444 1
		return ((struct sockaddr_in *) sa)->sin_port;
d478 2
a479 2
		log_print("util_ntoa: "
		    "could not make printable address out of sockaddr %p", sfrom);
d505 2
a506 2
		log_print("conf_file_secrecy: not loading %s - too open permissions",
		    name);
d511 1
a511 1
		*file_size = (size_t) st.st_size;
@


1.37
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: util.c,v 1.36 2004/04/07 22:45:49 ho Exp $	 */
d492 27
@


1.36
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.35 2003/12/14 14:50:23 ho Exp $	*/
/*	$EOM: util.c,v 1.23 2000/11/23 12:22:08 niklas Exp $	*/
d58 1
a58 1
int allow_name_lookups = 0;
d64 1
a64 1
int regrand = 0;
d69 1
a69 1
unsigned long seed;
d76 1
a76 1
decode_16 (u_int8_t *cp)
d78 1
a78 1
  return cp[0] << 8 | cp[1];
d82 1
a82 1
decode_32 (u_int8_t *cp)
d84 1
a84 1
  return cp[0] << 24 | cp[1] << 16 | cp[2] << 8 | cp[3];
d88 1
a88 1
decode_64 (u_int8_t *cp)
d90 3
a92 3
  return (u_int64_t)cp[0] << 56 | (u_int64_t)cp[1] << 48
    | (u_int64_t)cp[2] << 40 | (u_int64_t)cp[3] << 32
    | cp[4] << 24 | cp[5] << 16 | cp[6] << 8 | cp[7];
d102 1
a102 1
decode_128 (u_int8_t *cp, u_int8_t *cpp)
d105 1
a105 1
  int i;
d107 2
a108 2
  for (i = 0; i < 16; i++)
    cpp[i] = cp[15 - i];
d110 1
a110 1
  bcopy (cp, cpp, 16);
d118 1
a118 1
encode_16 (u_int8_t *cp, u_int16_t x)
d120 2
a121 2
  *cp++ = x >> 8;
  *cp = x & 0xff;
d125 1
a125 1
encode_32 (u_int8_t *cp, u_int32_t x)
d127 4
a130 4
  *cp++ = x >> 24;
  *cp++ = (x >> 16) & 0xff;
  *cp++ = (x >> 8) & 0xff;
  *cp = x & 0xff;
d134 1
a134 1
encode_64 (u_int8_t *cp, u_int64_t x)
d136 8
a143 8
  *cp++ = x >> 56;
  *cp++ = (x >> 48) & 0xff;
  *cp++ = (x >> 40) & 0xff;
  *cp++ = (x >> 32) & 0xff;
  *cp++ = (x >> 24) & 0xff;
  *cp++ = (x >> 16) & 0xff;
  *cp++ = (x >> 8) & 0xff;
  *cp = x & 0xff;
d153 1
a153 1
encode_128 (u_int8_t *cp, u_int8_t *cpp)
d155 1
a155 1
  decode_128 (cpp, cp);
d161 1
a161 1
zero_test (const u_int8_t *p, size_t sz)
d163 4
a166 4
  while (sz-- > 0)
    if (*p++ != 0)
      return 0;
  return 1;
d171 1
a171 1
ones_test (const u_int8_t *p, size_t sz)
d173 4
a176 4
  while (sz-- > 0)
    if (*p++ != 0xff)
      return 0;
  return 1;
d183 1
a183 1
getrandom (u_int8_t *buf, size_t len)
d185 2
a186 2
  u_int32_t tmp = 0;
  size_t i;
d188 3
a190 4
  for (i = 0; i < len; i++)
    {
      if (i % sizeof tmp == 0)
	tmp = sysdep_random ();
d192 3
a194 3
      buf[i] = tmp & 0xff;
      tmp >>= 8;
    }
d196 1
a196 1
  return buf;
d200 1
a200 1
hex2nibble (char c)
d202 7
a208 7
  if (c >= '0' && c <= '9')
    return c - '0';
  if (c >= 'a' && c <= 'f')
    return c - 'a' + 10;
  if (c >= 'A' && c <= 'F')
    return c - 'A' + 10;
  return -1;
d216 1
a216 1
hex2raw (char *s, u_int8_t *buf, size_t sz)
d218 20
a237 22
  char *p;
  u_int8_t *bp;
  int tmp;

  if (strlen (s) > sz * 2)
    return -1;
  for (p = s + strlen (s) - 1, bp = &buf[sz - 1]; bp >= buf; bp--)
    {
      *bp = 0;
      if (p >= s)
	{
	  tmp = hex2nibble (*p--);
	  if (tmp == -1)
	    return -1;
	  *bp = tmp;
	}
      if (p >= s)
	{
	  tmp = hex2nibble (*p--);
	  if (tmp == -1)
	    return -1;
	  *bp |= tmp << 4;
d239 1
a239 2
    }
  return 0;
d243 1
a243 1
text2sockaddr (char *address, char *port, struct sockaddr **sa)
d246 15
a260 1
  struct addrinfo *ai, hints;
d262 3
a264 17
  memset (&hints, 0, sizeof hints);
  if (!allow_name_lookups)
    hints.ai_flags = AI_NUMERICHOST;
  hints.ai_family = PF_UNSPEC;
  hints.ai_socktype = SOCK_DGRAM;
  hints.ai_protocol = IPPROTO_UDP;

  if (getaddrinfo (address, port, &hints, &ai))
    return -1;

  *sa = malloc (sysdep_sa_len (ai->ai_addr));
  if (!sa)
    return -1;

  memcpy (*sa, ai->ai_addr, sysdep_sa_len (ai->ai_addr));
  freeaddrinfo (ai);
  return 0;
d266 10
a275 10
  int af = strchr (address, ':') != NULL ? AF_INET6 : AF_INET;
  size_t sz = af == AF_INET
    ? sizeof (struct sockaddr_in) : sizeof (struct sockaddr_in6);
  long lport;
  struct servent *sp;
  char *ep;

  *sa = calloc (1, sz);
  if (!*sa)
    return -1;
d278 1
a278 1
  (*sa)->sa_len = sz;
d280 22
a301 26
  (*sa)->sa_family = af;
  if (inet_pton (af, address, sockaddr_addrdata (*sa)) != 1)
    {
      free (*sa);
      return -1;
    }
  if (!port)
    return 0;
  sp = getservbyname (port, "udp");
  if (!sp)
    {
      lport = strtol (port, &ep, 10);
      if (ep == port || lport < 0 || lport > (long)USHRT_MAX)
	{
	  free (*sa);
	  return -1;
	}
      lport = htons (lport);
    }
  else
    lport = sp->s_port;
  if ((*sa)->sa_family == AF_INET)
    ((struct sockaddr_in *)*sa)->sin_port = lport;
  else
    ((struct sockaddr_in6 *)*sa)->sin6_port = lport;
  return 0;
d310 1
a310 1
sockaddr2text (struct sockaddr *sa, char **address, int zflag)
d312 3
a314 5
  char buf[NI_MAXHOST];
  char *token, *bstart, *ep;
  int addrlen;
  long val;
  int i, j;
d317 3
a319 3
  if (getnameinfo (sa, sysdep_sa_len (sa), buf, sizeof buf, 0, 0,
		   allow_name_lookups ? 0 : NI_NUMERICHOST))
    return -1;
d321 16
a336 18
  switch (sa->sa_family)
    {
    case AF_INET:
    case AF_INET6:
      if (inet_ntop (sa->sa_family, sa->sa_data, buf, NI_MAXHOST - 1) == NULL)
	{
	  log_error ("sockaddr2text: inet_ntop (%d, %p, %p, %d) failed",
		     sa->sa_family, sa->sa_data, buf, NI_MAXHOST - 1);
	  return -1;
	}
      buf[NI_MAXHOST - 1] = '\0';
      break;

    default:
      log_print ("sockaddr2text: unsupported protocol family %d\n",
		  sa->sa_family);
      return -1;
    }
d339 57
a395 63
  if (zflag == 0)
    {
      *address = strdup (buf);
      if (!*address)
	return -1;
    }
  else
    switch (sa->sa_family)
      {
      case AF_INET:
	addrlen = sizeof "000.000.000.000";
	*address = malloc (addrlen);
	if (!*address)
	  return -1;
	buf[addrlen] = '\0';
	bstart = buf;
	**address = '\0';
	while ((token = strsep (&bstart, ".")) != NULL)
	  {
	    if (strlen (*address) > 12)
	      {
		free (*address);
		return -1;
	      }
	    val = strtol (token, &ep, 10);
	    if (ep == token || val < (long)0 || val > (long)UCHAR_MAX)
	      {
		free (*address);
		return -1;
	      }
	    snprintf (*address + strlen (*address),
		      addrlen - strlen (*address), "%03ld", val);
	    if (bstart)
	      strlcat (*address, ".", addrlen);
	  }
	break;

      case AF_INET6:
	/*
	 * XXX In the algorithm below there are some magic numbers we
	 * probably could give explaining names.
	 */
	addrlen = sizeof "0000:0000:0000:0000:0000:0000:0000:0000";
	*address = malloc (addrlen);
	if (!*address)
	  return -1;

	for (i = 0, j = 0; i < 8; i++)
	  {
	    snprintf ((*address) + j, addrlen - j, "%02x%02x",
		      ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2 * i],
		      ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2 * i + 1]);
	    j += 4;
	    (*address)[j] = (j < (addrlen - 1)) ? ':' : '\0';
	    j++;
	  }
	break;

      default:
	*address = strdup ("<error>");
	if (!*address)
	  return -1;
      }
d397 1
a397 1
  return 0;
d405 1
a405 1
sockaddr_addrlen (struct sockaddr *sa)
d407 10
a416 11
  switch (sa->sa_family)
    {
    case AF_INET6:
      return sizeof ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr;
    case AF_INET:
      return sizeof ((struct sockaddr_in *)sa)->sin_addr.s_addr;
    default:
      log_print ("sockaddr_addrlen: unsupported protocol family %d",
		 sa->sa_family);
      return 0;
    }
d420 1
a420 1
sockaddr_addrdata (struct sockaddr *sa)
d422 10
a431 11
  switch (sa->sa_family)
    {
    case AF_INET6:
      return (u_int8_t *)&((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr;
    case AF_INET:
      return (u_int8_t *)&((struct sockaddr_in *)sa)->sin_addr.s_addr;
    default:
      log_print ("sockaddr_addrdata: unsupported protocol family %d",
		 sa->sa_family);
      return 0;
    }
d435 1
a435 1
sockaddr_port (struct sockaddr *sa)
d437 10
a446 11
  switch (sa->sa_family)
    {
    case AF_INET6:
      return ((struct sockaddr_in6 *)sa)->sin6_port;
    case AF_INET:
      return ((struct sockaddr_in *)sa)->sin_port;
    default:
      log_print ("sockaddr_port: unsupported protocol family %d",
		 sa->sa_family);
      return 0;
    }
d454 1
a454 1
util_ntoa (char **buf, int af, u_int8_t *addr)
d456 3
a458 3
  struct sockaddr_storage from;
  struct sockaddr *sfrom = (struct sockaddr *)&from;
  socklen_t fromlen = sizeof from;
d460 2
a461 2
  memset (&from, 0, fromlen);
  sfrom->sa_family = af;
d463 8
a470 9
  switch (af)
    {
    case AF_INET:
      sfrom->sa_len = sizeof (struct sockaddr_in);
      break;
    case AF_INET6:
      sfrom->sa_len = sizeof (struct sockaddr_in6);
      break;
    }
d472 1
a472 1
  memcpy (sockaddr_addrdata (sfrom), addr, sockaddr_addrlen (sfrom));
d474 5
a478 6
  if (sockaddr2text (sfrom, buf, 0))
    {
      log_print ("util_ntoa: "
		 "could not make printable address out of sockaddr %p", sfrom);
      *buf = 0;
    }
d487 1
a487 1
check_file_secrecy (char *name, size_t *file_size)
d489 1
a489 1
  struct stat st;
d491 18
a508 22
  if (monitor_stat (name, &st) == -1)
    {
      log_error ("check_file_secrecy: stat (\"%s\") failed", name);
      return -1;
    }
  if (st.st_uid != 0 && st.st_uid != getuid ())
    {
      log_print ("check_file_secrecy: "
		 "not loading %s - file owner is not process user", name);
      errno = EPERM;
      return -1;
    }
  if ((st.st_mode & (S_IRWXG | S_IRWXO)) != 0)
    {
      log_print ("conf_file_secrecy: not loading %s - too open permissions",
		 name);
      errno = EPERM;
      return -1;
    }

  if (file_size)
    *file_size = (size_t)st.st_size;
d510 1
a510 1
  return 0;
@


1.35
log
@Log the actual port for src and dst, don't assume it's always 500.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.34 2003/06/03 14:28:16 ho Exp $	*/
d186 1
a186 1
  int i;
d296 1
a296 1
      if (ep == port || lport < 0 || lport > USHRT_MAX)
d376 1
a376 1
	    if (ep == token || val < 0 || val > UCHAR_MAX)
@


1.34
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.33 2003/05/15 00:28:53 ho Exp $	*/
d449 16
@


1.33
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2003/03/13 10:31:44 ho Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.32
log
@Avoid "j += snprintf()". niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.31 2003/03/06 14:22:13 cedric Exp $	*/
d54 1
d503 1
a503 1
  if (stat (name, &st) == -1)
d508 1
a508 1
  if (st.st_uid != geteuid () && st.st_uid != getuid ())
@


1.31
log
@fix text2sockaddr() when HAVE_GETNAMEINFO is false and port is NULL.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.30 2003/03/06 09:56:25 ho Exp $	*/
d404 4
a407 3
	    j += snprintf ((*address) + j, addrlen - j, "%02x%02x",
			   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2 * i],
			   ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2 * i + 1]);
@


1.30
log
@Less ambiguous l-value usage. Noted by cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2003/01/09 02:51:59 ho Exp $	*/
d294 2
@


1.29
log
@Don't write past the end of the address buffer. Found by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2002/06/09 08:13:07 todd Exp $	*/
d405 2
a406 1
	    (*address)[j] = (++j < addrlen) ? ':' : '\0';
@


1.28
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2002/05/28 11:23:20 ho Exp $	*/
d401 6
a406 4
	  j += snprintf ((*address) + j, addrlen - j, "%02x%02x:",
			 ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2 * i],
			 ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2 * i + 1]);
	(*address)[j - 1] = '\0';
@


1.27
log
@off_t to size_t change for printf format and malloc. Pointed out by <greg@@nest.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2002/01/23 18:44:48 ho Exp $	*/
d383 1
a383 1
	    snprintf (*address + strlen (*address), 
@


1.26
log
@the last few sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2002/01/23 17:10:09 ho Exp $	*/
d492 1
a492 1
check_file_secrecy (char *name, off_t *file_size)
d517 1
a517 1
    *file_size = st.st_size;
@


1.25
log
@less strcpy/strcat
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2002/01/19 20:12:02 angelos Exp $	*/
d383 2
a384 1
	    sprintf (*address + strlen (*address), "%03ld", val);
d401 3
a403 3
	  j += sprintf ((*address) + j, "%02x%02x:",
			((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2 * i],
			((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[2 * i + 1]);
@


1.24
log
@Fix bogosity with sa_len value assignment...I wonder how this ever
worked (but it did, until very recently).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2001/10/26 13:29:26 ho Exp $	*/
d355 1
a355 1
      *address = malloc (strlen (buf) + 1);
a357 1
      strcpy (*address, buf);
d385 1
a385 1
	      strcat (*address + strlen (*address), ".");
d407 3
a409 1
	strcpy (*address, "<error>");
@


1.23
log
@Change to use sysdep_sa_len() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2001/10/26 12:03:07 ho Exp $	*/
d464 9
a472 1
  sfrom->sa_len = sysdep_sa_len (sfrom);
@


1.22
log
@Just rename sockaddr_data/len functions to sockaddr_addrdata/addrlen.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2001/07/03 23:39:01 angelos Exp $	*/
d266 1
a266 1
  *sa = malloc (ai->ai_addr->sa_len);
d270 1
a270 1
  memcpy (*sa, ai->ai_addr, ai->ai_addr->sa_len);
d285 1
d287 1
d329 1
a329 1
  if (getnameinfo (sa, sa->sa_len, buf, sizeof buf, 0, 0,
a459 1
  u_int32_t ip4_buf;
d463 4
a466 13
  switch (af)
    {
    case AF_INET:
      sfrom->sa_len = sizeof (struct sockaddr_in);
      memcpy (&ip4_buf, addr, sizeof (struct in_addr));
      ((struct sockaddr_in *)sfrom)->sin_addr.s_addr = ip4_buf;
      break;

    case AF_INET6:
      sfrom->sa_len = sizeof (struct sockaddr_in6);
      memcpy (sockaddr_addrdata (sfrom), addr, sizeof (struct in6_addr));
      break;
    }
@


1.21
log
@Fix policy information for IPv6 subnet/range cases. This is ugly, I'll
have to find another way of dealing with IPv6 addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2001/07/01 19:59:13 niklas Exp $	*/
d287 1
a287 1
  if (inet_pton (af, address, sockaddr_data (*sa)) != 1)
d413 2
a414 2
 * sockaddr_len and sockaddr_data return the relevant sockaddr info depending
 * on address family.  Useful to keep other code shorter(/clearer?).
d417 1
a417 1
sockaddr_len (struct sockaddr *sa)
d426 1
a426 1
      log_print ("sockaddr_len: unsupported protocol family %d",
d433 1
a433 1
sockaddr_data (struct sockaddr *sa)
d442 2
d472 1
a472 1
      memcpy (sockaddr_data (sfrom), addr, sizeof (struct in6_addr));
@


1.20
log
@strict strtol checking.  text2sockaddr/sockaddr2text implementations
for systems without get{addr,name}info calls.  Some style police.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2001/07/01 14:23:30 ho Exp $	*/
d321 2
a322 2
  char *token, *bstart, *p, *ep;
  int addrlen, c_pre = 0, c_post = 0;
d324 1
d397 6
a402 45
	bstart = buf;
	**address = '\0';
	buf[addrlen] = '\0';
	while ((token = strsep (&bstart, ":")) != NULL)
	  {
	    if (strlen (token) == 0)
	      {
		/*
		 * Encountered a '::'. Fill out the string.
		 * XXX Isn't there a library function for this somewhere?
		 */
		for (p = buf; p < token - 1; p++)
		  if (*p == 0)
		    c_pre++;
		for (p = token + 1; p < (bstart + strlen (bstart)); p++)
		  if (*p == ':')
		    c_post++;
		/* The number of zero groups to add. */
		c_pre = 7 - c_pre - c_post - 1;
		if (c_pre > 6 || strlen (*address) > (40 - 5 * c_pre))
		  {
		    free (*address);
		    return -1;
		  }
		for (; c_pre; c_pre--)
		  strcat (*address + strlen (*address), "0000:");
	      }
	    else
	      {
		if (strlen (*address) > 35)
		  {
		    free (*address);
		    return -1;
		  }
		val = strtol (token, &ep, 10);
		if (ep == token || val < 0 || val > USHRT_MAX)
		  {
		    free (*address);
		    return -1;
		  }
		sprintf (*address + strlen (*address), "%04lx", val);
		if (bstart)
		  strcat (*address + strlen (*address), ":");
	      }
	  }
@


1.19
log
@Get the 'default:' case right too.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2001/07/01 05:42:05 angelos Exp $	*/
d43 1
d71 5
d274 36
a309 1
  return -1;
d321 1
a321 1
  char *token, *bstart, *p;
d323 1
d330 1
a330 1
  if (sa->sa_family == AF_INET)
d332 8
a339 2
      strncpy (buf, inet_ntoa (((struct sockaddr_in *)sa)->sin_addr), 
	       NI_MAXHOST - 1);
d341 3
a343 3
    }
  else
    {
d346 1
a346 1
      strcpy (buf, "<error>");
d353 1
a353 1
      if (*address == NULL)
d365 3
a367 2
	buf[addrlen] = '\0'; /* Terminate */
	bstart = buf; **address = '\0';
d375 7
a381 2
	    sprintf (*address + strlen (*address), "%03ld",
		     strtol (token, NULL, 10));
d386 1
d388 4
d396 3
a398 2
	bstart = buf; **address = '\0';
	buf[addrlen] = '\0'; /* Terminate */
d403 1
a403 1
		/* 
d430 7
a436 2
		sprintf (*address + strlen (*address), "%04lx", 
			 strtol (token, NULL, 16));
d442 1
d452 1
a452 1
 * on address family. Useful to keep other code shorter(/clearer?).
d463 2
a464 2
    default: 
      log_print ("sockaddr_len: unsupported protocol family %d", 
d480 1
a480 1
      return 0; /* XXX */
a502 1
/*      ((struct sockaddr_in *)sfrom)->sin_addr.s_addr = htonl (ip4_buf);*/
d505 1
d514 2
a515 1
      log_error ("util_ntoa: sockaddr2text () failed");
d523 1
a523 1
 * Also, if *file_size != NULL, store file size here.
d529 1
a529 1
  
d549 1
a549 1
  
@


1.18
log
@Fix remote_negotiation_address attribute; fix sockaddr2text() return
value when zero-filling; log_error()->log_print() consistently.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2001/06/29 22:59:41 angelos Exp $	*/
a307 1
      return 0;
d378 1
a378 1
	strcpy (buf, "<error>");
d380 1
a380 1
	
@


1.17
log
@Fix address byte ordering issue, ho@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2001/06/29 04:52:22 ho Exp $	*/
d307 2
a381 1
  strcpy (*address, buf);
@


1.16
log
@Style fix as per niklas@@'s suggestion.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2001/06/29 04:12:01 ho Exp $	*/
d437 2
a438 1
      ((struct sockaddr_in *)sfrom)->sin_addr.s_addr = htonl (ip4_buf);
@


1.15
log
@Initial IPv6 support. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2001/06/27 05:16:49 ho Exp $	*/
d281 1
a281 1
  int c_pre = 0, c_post = 0;
d312 3
a314 2
	*address = malloc (16);
	if (*address == NULL)
d316 1
d332 3
a334 2
	*address = malloc (40);
	if (!address)
d337 1
a337 1
	buf[40] = '\0'; /* Make sure buf is terminated. */
d342 4
a345 2
		/* Encountered a '::'. Fill out the string. */
		/* XXX Isn't there a library function for this somewhere? */
@


1.14
log
@sockaddr2text w/o HAVE_GETNAMEINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2001/06/27 00:10:35 ho Exp $	*/
d272 4
d277 1
a277 1
sockaddr2text (struct sockaddr *sa, char **address)
d280 2
d302 73
a374 4
  *address = malloc (strlen (buf) + 1);
  if (!address)
    return -1;
  
d412 35
a446 1
     
a481 1

@


1.13
log
@A few more functions to help with IPv6 support. By Niklas and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2001/04/05 23:02:02 ho Exp $	*/
d42 1
a274 1
#ifdef HAVE_GETNAMEINFO
d277 1
d281 14
a301 3
#else
  return -1;
#endif
@


1.12
log
@let check_file_secrecy() set errno
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2000/11/23 12:57:15 niklas Exp $	*/
d5 2
a6 2
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2000 Håkan Olsson.  All rights reserved.
d39 1
d41 2
d57 6
d243 83
@


1.11
log
@Merge with EOM 1.23

author: niklas
style nits

author: angelos
Typecast so compiler shuts up.

author: ho
Use stat(), not lstat().

author: niklas
style and removal of unused, unneeded code
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2000/11/23 12:22:08 niklas Exp $	*/
d43 1
d253 1
d260 1
@


1.10
log
@conf.c: Merge with EOM 1.46
util.c: Merge EOM diff 1.20 - 1.21, i.e. 1.19 is still left to be merged

author: ho
Use stat(), not lstat().
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.9 2000/10/16 23:27:03 niklas Exp $	*/
/*	$Id: util.c,v 1.21 2000/10/26 16:17:19 ho Exp $	*/
d77 3
a79 3
  return ((u_int64_t) cp[0] << 56) | ((u_int64_t) cp[1] << 48) |
         ((u_int64_t) cp[2] << 40) | ((u_int64_t) cp[3] << 32) |
         cp[4] << 24 | cp[5] << 16 | cp[6] << 8 | cp[7];
d82 6
d91 1
a93 1
#if BYTE_ORDER == LITTLE_ENDIAN
d102 1
d133 6
d142 1
a142 1
    decode_128 (cpp, cp);
d144 1
@


1.10.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.12 2001/04/05 23:02:02 ho Exp $	*/
/*	$EOM: util.c,v 1.23 2000/11/23 12:22:08 niklas Exp $	*/
a42 1
#include <errno.h>
d77 3
a79 3
  return (u_int64_t)cp[0] << 56 | (u_int64_t)cp[1] << 48
    | (u_int64_t)cp[2] << 40 | (u_int64_t)cp[3] << 32
    | cp[4] << 24 | cp[5] << 16 | cp[6] << 8 | cp[7];
a81 6
#if 0
/*
 * XXX I severly doubt that we will need this.  IPv6 does not have the legacy
 * of representation in host byte order, AFAIK.
 */

a84 1
#if BYTE_ORDER == LITTLE_ENDIAN
d87 1
a95 1
#endif
a125 6
#if 0
/*
 * XXX I severly doubt that we will need this.  IPv6 does not have the legacy
 * of representation in host byte order, AFAIK.
 */

d129 1
a129 1
  decode_128 (cpp, cp);
a130 1
#endif
a237 1
      errno = EPERM;
a243 1
      errno = EPERM;
@


1.9
log
@Merge with EOM 1.19

author: angelos
Correct byte-order handling in encode/decode_128, add function prototypes.

author: angelos
A few more auxiliary routines.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.8 2000/10/13 13:22:02 niklas Exp $	*/
/*	$EOM: util.c,v 1.19 2000/10/14 23:40:08 angelos Exp $	*/
d229 1
a229 1
  if (lstat (name, &st) == -1)
d231 1
a231 1
      log_error ("check_file_secrecy: lstat (\"%s\") failed", name);
@


1.8
log
@regress/b2n/Makefile: Merge with EOM 1.12
regress/ec2n/Makefile: Merge with EOM 1.9
conf.c: Merge with EOM 1.40
util.c: Merge with EOM 1.17

author: ho
Add file permission check to private key file. Split out check function to util.c.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.7 2000/10/07 06:59:39 niklas Exp $	*/
/*	$EOM: util.c,v 1.17 2000/10/13 13:04:16 ho Exp $	*/
d74 23
d113 19
d138 10
@


1.7
log
@Merge with EOM 1.16

author: itojun
need string.h for netbsd/alpha
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.6 1999/08/05 22:40:37 niklas Exp $	*/
/*	$EOM: util.c,v 1.16 2000/10/04 16:36:56 itojun Exp $	*/
d6 1
d39 1
d42 1
d166 35
@


1.6
log
@regress/rsakeygen/Makefile: Merge with EOM 1.5
sysdep/openbsd/sysdep.c: Merge with EOM 1.8
cookie.c: Merge with EOM 1.21
util.c: Merge with EOM 1.15
util.h: Merge with EOM 1.7

author: niklas
Move regrand var to util.c, and get the decl from util.h, do not update the
cookie secret if in deterministic mode.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.5 1999/04/19 19:54:54 niklas Exp $	*/
/*	$EOM: util.c,v 1.15 1999/08/05 15:00:04 niklas Exp $	*/
d39 1
@


1.5
log
@./app.c: Merge with EOM 1.5
./gmp_util.c: Merge with EOM 1.3
./asn_useful.c: Merge with EOM 1.11
./attribute.c: Merge with EOM 1.9
./constants.c: Merge with EOM 1.7
./doi.h: Merge with EOM 1.25
./doi.c: Merge with EOM 1.4
./field.c: Merge with EOM 1.9
./init.c: Merge with EOM 1.13
./isakmp_doi.c: Merge with EOM 1.35
./prf.c: Merge with EOM 1.6
./util.c: Merge with EOM 1.14
./app.h: Merge with EOM 1.4
./conf.h: Merge with EOM 1.8
./ipsec.h: Merge with EOM 1.34
./ipsec_doi.h: Merge with EOM 1.10
./pkcs.h: Merge with EOM 1.8
./sysdep.h: Merge with EOM 1.15

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.4 1999/02/26 03:52:40 niklas Exp $	*/
/*	$EOM: util.c,v 1.14 1999/04/02 00:58:15 niklas Exp $	*/
d47 6
@


1.4
log
@Merge from the Ericsson repository
| revision 1.13
| date: 1999/02/25 11:39:27;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.3 1998/11/17 11:10:22 niklas Exp $	*/
/*	$EOM: util.c,v 1.13 1999/02/25 11:39:27 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.2 1998/11/15 00:44:04 niklas Exp $	*/
/*	$EOM: util.c,v 1.12 1998/11/12 13:01:46 niklas Exp $	*/
d39 2
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: util.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: util.c,v 1.12 1998/11/12 13:01:46 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
