head	1.23;
access;
symbols
	OPENBSD_3_7:1.21.0.8
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.17.0.4
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.23
date	2005.05.18.20.18.39;	author hshoexer;	state dead;
branches;
next	1.22;

1.22
date	2005.04.08.21.51.08;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.04.07.31.17;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.11.10.13.20;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.02.17.09.29;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.11.00.40.29;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.09.22.09.53;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.16.21.17.31;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.27.12.03.37;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.27.11.24.39;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.26.11.08.22;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.19.18.54.59;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.26.22.28.07;	author niklas;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.10.07.06.58.55;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.08.08.42.27;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.01.02.46.17;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.26.15.22.41;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.10.21.58.19;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.10.01.14.08.54;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.08.26.22.29.29;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.07.18.17.25.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.07.17.21.48.59;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.08.12.45.27;	author ho;	state Exp;
branches;
next	;


desc
@@


1.23
log
@bye bye
@
text
@/*	$OpenBSD: certpatch.c,v 1.22 2005/04/08 21:51:08 deraadt Exp $	*/
/*	$EOM: certpatch.c,v 1.11 2000/12/21 14:50:09 ho Exp $	*/

/*
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 1999, 2000 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

/*
 * This program takes a certificate generated by ssleay and a
 * private key. It encodes a new id as subject alt name
 * extension into the certifcate. The result gets written as
 * new certificate that can be used by isakmpd.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "sysdep.h"

#ifdef KAME
#  ifdef CRYPTO
#    include <openssl/rsa.h>
#  endif
#else
#  include <openssl/rsa.h>
#endif

#include <openssl/x509.h>
#include <openssl/pem.h>

#include "conf.h"
#include "ipsec_num.h"
#include "log.h"
#include "math_mp.h"
#include "x509.h"

#define IDTYPE_IP	"ip"
#define IDTYPE_FQDN     "fqdn"
#define IDTYPE_UFQDN    "ufqdn"

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-t idtype] -i id -k keyfile certin certout\n",
	    __progname);
	exit(1);
}


int
main(int argc, char **argv)
{
	EVP_PKEY *pkey_priv;
	X509 *cert;
	BIO *file;
	const EVP_MD *digest;
	X509_EXTENSION *ex = NULL;
	ASN1_OCTET_STRING *data = NULL;
	struct in_addr saddr;
	unsigned char ipaddr[6], *new_id;
	char *type = IDTYPE_IP, *keyfile = NULL, *id = NULL;
	char *certin, *certout;
	int ch, err;

#if SSLEAY_VERSION_NUMBER >= 0x00904100L
	unsigned char *p;
	ASN1_STRING str;
	int i;
#endif


	/* read command line arguments */
	while ((ch = getopt (argc, argv, "t:k:i:")) != -1)
		switch (ch) {
		case 't':
			type = optarg;
			break;
		case 'k':
			keyfile = optarg;
			break;
		case 'i':
			id = optarg;
			break;
		default:
			usage();
		}

	argc -= optind;

	if (argc != 2)
		usage();

	argv += optind;

	certin = argv[0];
	certout = argv[1];

	/* Check ID */

	if ((strcasecmp(IDTYPE_IP, type) != 0 &&
	    strcasecmp(IDTYPE_FQDN, type) != 0 &&
	    strcasecmp(IDTYPE_UFQDN, type) != 0) || id == NULL) {
		printf("wrong id type or missing id\n");
		return (1);
	}

	/*
	 * X509_verify will fail, as will all other functions that call
	 * EVP_get_digest_byname.
	 */
	SSLeay_add_all_algorithms();

	/* Use a certificate created by ssleay and add the appr. extension */
	printf("Reading ssleay created certificate %s and modify it\n",
	    certin);
	file = BIO_new(BIO_s_file ());
	if (BIO_read_filename(file, certin) == -1) {
		perror("read");
		return (1);
	}
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
	cert = PEM_read_bio_X509(file, NULL, NULL, NULL);
#else
	cert = PEM_read_bio_X509(file, NULL, NULL);
#endif
	BIO_free(file);
	if (cert == NULL) {
		printf("PEM_read_bio_X509() failed\n");
		return (1);
	}

	/* Get the digest for the actual signing */
	digest = EVP_get_digestbyname(OBJ_nid2sn(OBJ_obj2nid(cert->sig_alg->algorithm)));
	if (!X509_set_version(cert, 2)) {
		printf("X509 failed to set version number\n");
		return (1);
	}

	if (!strcasecmp(IDTYPE_IP, type)) {
		if (inet_aton(id, &saddr) == 0) {
			printf("inet_aton() failed\n");
			return (1);
		}

		saddr.s_addr = htonl(saddr.s_addr);
		ipaddr[0] = 0x87;
		ipaddr[1] = 0x04;
		ipaddr[2] = saddr.s_addr >> 24;
		ipaddr[3] = (saddr.s_addr >> 16) & 0xff;
		ipaddr[4] = (saddr.s_addr >> 8) & 0xff;
		ipaddr[5] = saddr.s_addr & 0xff;

#if SSLEAY_VERSION_NUMBER >= 0x00904100L
		str.length = 6;
		str.type = V_ASN1_OCTET_STRING;
		str.data = ipaddr;
		data = ASN1_OCTET_STRING_new();
		if (!data) {
			perror("ASN1_OCTET_STRING_new() failed");
			return (1);
		}

		i = i2d_ASN1_OCTET_STRING((ASN1_OCTET_STRING *)&str, NULL);
		if (!ASN1_STRING_set((ASN1_STRING *)data, NULL, i)) {
			perror("ASN1_STRING_set() failed");
			return (1);
		}
		p = (unsigned char *)data->data;
		i2d_ASN1_OCTET_STRING((ASN1_OCTET_STRING *)&str, &p);
		data->length = i;
#else
		data = X509v3_pack_string(NULL, V_ASN1_OCTET_STRING, ipaddr, 6);
#endif
	} else if (!strcasecmp(IDTYPE_FQDN, type) || !strcasecmp(IDTYPE_UFQDN, type)) {
		new_id = malloc(strlen(id) + 2);
		if (new_id == NULL) {
			printf("malloc() failed\n");
			return (1);
		}

		if (!strcasecmp(IDTYPE_FQDN, type))
			new_id[0] = 0x82;
		else
			new_id[0] = 0x81; /* IDTYPE_UFQDN */

		memcpy(new_id + 2, id, strlen(id));
		new_id[1] = strlen(id);
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
		str.length = strlen(id) + 2;
		str.type = V_ASN1_OCTET_STRING;
		str.data = new_id;
		data = ASN1_OCTET_STRING_new();
		if (!data) {
			perror("ASN1_OCTET_STRING_new() failed");
			return (1);
		}

		i = i2d_ASN1_OCTET_STRING((ASN1_OCTET_STRING *)&str, NULL);
		if (!ASN1_STRING_set((ASN1_STRING *)data,NULL, i)) {
			perror("ASN1_STRING_set() failed");
			return (1);
		}
		p = (unsigned char *)data->data;
		i2d_ASN1_OCTET_STRING((ASN1_OCTET_STRING *)&str, &p);
		data->length = i;
#else
		data = X509v3_pack_string(NULL, V_ASN1_OCTET_STRING, new_id,
		    strlen (id) + 2);
#endif
		free (new_id);
	}

	/* XXX This is a hack, how to do better?	*/
	data->type = 0x30;
	data->data[0] = 0x30;
	ex = X509_EXTENSION_create_by_NID(NULL, NID_subject_alt_name, 1, data);
	if (ex == NULL) {
		printf("X509_EXTENSION_create()\n");
		return (1);
	}

	X509_add_ext(cert, ex, -1);

	file = BIO_new (BIO_s_file());
	if (BIO_read_filename(file, keyfile) == -1) {
		perror("open");
		return (1);
	}
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
	if ((pkey_priv = PEM_read_bio_PrivateKey(file, NULL, NULL, NULL)) == NULL) {
#else
	if ((pkey_priv = PEM_read_bio_PrivateKey(file, NULL, NULL)) == NULL) {
#endif
		printf("Can not read private key %s\n", keyfile);
		return (1);
	}
	BIO_free(file);

	printf("Creating Signature: PKEY_TYPE = %s: ",
	    pkey_priv->type == EVP_PKEY_RSA ? "RSA" : "unknown");
	err = X509_sign(cert, pkey_priv, digest);
	printf("X509_sign: %d ", err);
	if (!err)
		printf("FAILED ");
	else
		printf("OKAY ");
	printf("\n");

	file = BIO_new(BIO_s_file());
	if (BIO_write_filename(file, certout) == -1) {
		perror("open");
		return (1);
	}

	printf("Writing new certificate to %s\n", certout);
	PEM_write_bio_X509(file, cert);
	BIO_free(file);
	return (0);
}
@


1.22
log
@knf; ok cloder hshoexunpunouncable
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.21 2003/06/04 07:31:17 ho Exp $	*/
@


1.21
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.20 2002/09/11 10:13:20 ho Exp $	*/
d80 12
d93 1
a93 1
main (int argc, char **argv)
d95 11
a105 15
  char *usage = "%s [-t idtype] -i id -k keyfile certin certout\n\n"
    "This programs takes a certificate and adds a subjectAltName extension\n"
    "with the identication given as command line argument.  Be sure that \n"
    "the signing key matches the issuer.\n";
  EVP_PKEY *pkey_priv;
  X509 *cert;
  BIO *file;
  const EVP_MD *digest;
  X509_EXTENSION *ex = NULL;
  ASN1_OCTET_STRING *data = NULL;
  struct in_addr saddr;
  unsigned char ipaddr[6], *new_id;
  char *type = IDTYPE_IP, *keyfile = NULL, *id = NULL;
  char *certin, *certout;
  int ch, err;
d108 3
a110 3
  unsigned char *p;
  ASN1_STRING str;
  int i;
d114 49
a162 55
  /* read command line arguments */
  while ((ch = getopt (argc, argv, "t:k:i:")) != -1)
    switch (ch) {
    case 't':
      type = optarg;
      break;
    case 'k':
      keyfile = optarg;
      break;
    case 'i':
      id = optarg;
      break;
    default:
      fprintf (stderr, usage, argv[0]);
      return (1);
    }

  argc -= optind;

  if (argc != 2) {
    fprintf (stderr, usage, argv[0]);
    return (1);
  }

  argv += optind;

  certin = argv[0];
  certout = argv[1];

  /* Check ID */

  if ((strcasecmp (IDTYPE_IP, type) != 0 &&
       strcasecmp (IDTYPE_FQDN, type) != 0 &&
       strcasecmp (IDTYPE_UFQDN, type) != 0) || id == NULL)
    {
      printf ("wrong id type or missing id\n");
      return (1);
    }

  /*
   * X509_verify will fail, as will all other functions that call
   * EVP_get_digest_byname.
   */

  SSLeay_add_all_algorithms ();

  /* Use a certificate created by ssleay and add the appr. extension */
  printf ("Reading ssleay created certificate %s and modify it\n",
	  certin);
  file = BIO_new (BIO_s_file ());
  if (BIO_read_filename (file, certin) == -1)
    {
      perror ("read");
      return (1);
    }
d164 1
a164 1
  cert = PEM_read_bio_X509 (file, NULL, NULL, NULL);
d166 1
a166 1
  cert = PEM_read_bio_X509 (file, NULL, NULL);
d168 4
a171 22
  BIO_free (file);
  if (cert == NULL)
    {
      printf ("PEM_read_bio_X509 () failed\n");
      return (1);
    }

  /* Get the digest for the actual signing */
  digest = EVP_get_digestbyname (OBJ_nid2sn (OBJ_obj2nid (cert->sig_alg->algorithm)));

  if (!X509_set_version (cert, 2))
    {
      printf ("X509 failed to set version number\n");
      return (1);
    }

  if (!strcasecmp (IDTYPE_IP, type))
    {
      if (inet_aton (id, &saddr) == 0)
        {
	  printf ("inet_aton () failed\n");
	  return (1);
d174 20
a193 7
      saddr.s_addr = htonl (saddr.s_addr);
      ipaddr[0] = 0x87;
      ipaddr[1] = 0x04;
      ipaddr[2] = saddr.s_addr >> 24;
      ipaddr[3] = (saddr.s_addr >> 16) & 0xff;
      ipaddr[4] = (saddr.s_addr >> 8) & 0xff;
      ipaddr[5] = saddr.s_addr & 0xff;
d196 17
a212 19
      str.length = 6;
      str.type = V_ASN1_OCTET_STRING;
      str.data = ipaddr;
      data = ASN1_OCTET_STRING_new ();
      if (!data)
	{
	  perror ("ASN1_OCTET_STRING_new() failed");
	  return (1);
	}

      i = i2d_ASN1_OCTET_STRING ((ASN1_OCTET_STRING *)&str, NULL);
      if (!ASN1_STRING_set ((ASN1_STRING *)data,NULL,i))
        {
	  perror ("ASN1_STRING_set() failed");
	  return (1);
	}
      p = (unsigned char *)data->data;
      i2d_ASN1_OCTET_STRING ((ASN1_OCTET_STRING *)&str, &p);
      data->length = i;
d214 1
a214 1
      data = X509v3_pack_string (NULL, V_ASN1_OCTET_STRING, ipaddr, 6);
d216 11
a226 14
    }
  else if (!strcasecmp (IDTYPE_FQDN, type) || !strcasecmp (IDTYPE_UFQDN, type))
    {
      new_id = malloc (strlen (id) + 2);
      if (new_id == NULL)
        {
          printf ("malloc () failed\n");
          return (1);
        }

      if (!strcasecmp (IDTYPE_FQDN, type))
        new_id[0] = 0x82;
      else
        new_id[0] = 0x81; /* IDTYPE_UFQDN */
d228 2
a229 2
      memcpy (new_id + 2, id, strlen(id));
      new_id[1] = strlen (id);
d231 17
a247 19
      str.length = strlen (id) + 2;
      str.type = V_ASN1_OCTET_STRING;
      str.data = new_id;
      data = ASN1_OCTET_STRING_new ();
      if (!data)
        {
          perror ("ASN1_OCTET_STRING_new() failed");
          return (1);
        }

      i = i2d_ASN1_OCTET_STRING ((ASN1_OCTET_STRING *)&str, NULL);
      if (!ASN1_STRING_set ((ASN1_STRING *)data,NULL,i))
        {
          perror ("ASN1_STRING_set() failed");
          return (1);
        }
      p = (unsigned char *)data->data;
      i2d_ASN1_OCTET_STRING ((ASN1_OCTET_STRING *)&str, &p);
      data->length = i;
d249 2
a250 2
      data = X509v3_pack_string (NULL, V_ASN1_OCTET_STRING, new_id,
				 strlen (id) + 2);
d252 11
a262 2
      free (new_id);
    }
d264 7
a270 19
  /* XXX This is a hack, how to do better?  */
  data->type = 0x30;
  data->data[0] = 0x30;
  ex = X509_EXTENSION_create_by_NID (NULL, NID_subject_alt_name, 1, data);

  if (ex == NULL)
    {
      printf ("X509_EXTENSION_create ()\n");
      return (1);
    }

  X509_add_ext (cert, ex, -1);

  file = BIO_new (BIO_s_file ());
  if (BIO_read_filename (file, keyfile) == -1)
    {
      perror ("open");
      return (1);
    }
d272 1
a272 1
  if ((pkey_priv = PEM_read_bio_PrivateKey (file, NULL, NULL, NULL)) == NULL)
d274 1
a274 1
  if ((pkey_priv = PEM_read_bio_PrivateKey (file, NULL, NULL)) == NULL)
d276 20
a295 26
    {
      printf ("Can not read private key %s\n", keyfile);
      return (1);
    }
  BIO_free (file);

  printf ("Creating Signature: PKEY_TYPE = %s: ",
	  pkey_priv->type == EVP_PKEY_RSA ? "RSA" : "unknown");
  err = X509_sign (cert, pkey_priv, digest);
  printf ("X509_sign: %d ", err);
  if (!err)
    printf ("FAILED ");
  else
    printf ("OKAY ");
  printf ("\n");

  file = BIO_new (BIO_s_file ());
  if (BIO_write_filename (file, certout) == -1)
    {
      perror ("open");
      return (1);
    }

  printf ("Writing new certificate to %s\n", certout);
  PEM_write_bio_X509 (file, cert);
  BIO_free (file);
d297 4
a300 1
  return (0);
@


1.20
log
@signed vs unsigned from -pedantic.
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.19 2002/08/02 17:09:29 aaron Exp $	*/
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.19
log
@Check inet_aton() failure with == 0, not == -1; millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.18 2002/06/09 08:13:07 todd Exp $	*/
d99 1
a99 1
  char ipaddr[6], *new_id;
@


1.18
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.17 2001/07/11 00:40:29 angelos Exp $	*/
d189 1
a189 1
      if (inet_aton (id, &saddr) == -1)
@


1.17
log
@Return 0 on success, convert exit to return
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.16 2001/04/09 22:09:53 ho Exp $	*/
d41 1
a41 1
 * This program takes a certificate generated by ssleay and a 
d158 1
a158 1
  printf ("Reading ssleay created certificate %s and modify it\n", 
d161 1
a161 1
  if (BIO_read_filename (file, certin) == -1) 
@


1.16
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.15 2001/02/16 21:17:31 provos Exp $	*/
d125 1
a125 1
      exit (1);
d132 1
a132 1
    exit (1);
d147 1
a147 1
      exit (1);
d164 1
a164 1
      exit (1);
d175 1
a175 1
      exit (1);
d184 1
a184 1
      exit (1);
d192 1
a192 1
	  exit (1);
d211 1
a211 1
	  exit (1);
d218 1
a218 1
	  exit (1);
d233 1
a233 1
          exit (1);
d251 1
a251 1
          exit (1);
d258 1
a258 1
          exit (1);
d278 1
a278 1
      exit (1);
d287 1
a287 1
      exit (1);
d296 1
a296 1
      exit (1);
d314 1
a314 1
      exit (1);
d321 1
a321 1
  return 1;
@


1.15
log
@use the hash algorithm found in original certificate for the signature
after it has been patched. from angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.14 2001/01/27 12:03:37 niklas Exp $	*/
d113 1
a113 1
    switch(ch) {
d164 1
a164 1
      exit(1);
@


1.14
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.13 2001/01/27 11:24:39 niklas Exp $	*/
d95 1
a95 1
  EVP_MD *digest = EVP_md5 ();
d178 3
d269 1
a269 2
  
  
@


1.13
log
@Cleanup the MP_FLAVOUR situation.  Still needs work.
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.12 2001/01/26 11:08:22 niklas Exp $	*/
d7 2
a8 1
 * Copyright (c) 2000 Niklas Hallqvist.  All rights reserved.
@


1.12
log
@apps/certpatch/certpatch.c: Merge with EOM 1.11
regress/rsakeygen/rsakeygen.c: Merge with EOM 1.10
regress/x509/x509test.c: Merge with EOM 1.9

author: ho
Only include <gmp.h> with MP_FLAVOUR_GMP.
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.11 2000/12/19 18:54:59 mickey Exp $	*/
a60 4
#if MP_FLAVOUR == MP_FLAVOUR_GMP
#  include <gmp.h>
#endif

d75 1
d77 1
a77 1
#include "ipsec_num.h"
@


1.11
log
@gmp is gone, make it build again
@
text
@d1 2
a2 2
/*	$OpenBSD: certpatch.c,v 1.10 2000/10/26 22:28:07 niklas Exp $	*/
/*	$EOM: certpatch.c,v 1.10 2000/10/24 13:34:24 niklas Exp $	*/
d60 4
@


1.10
log
@Merge with EOM 1.10

author: niklas
getopt returns int not char; Boris Prochazka <boris@@stargate.ipunplugged.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.9 2000/10/07 06:58:55 niklas Exp $	*/
a52 1
#include <gmp.h>
@


1.10.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: certpatch.c,v 1.16 2001/04/09 22:09:53 ho Exp $	*/
/*	$EOM: certpatch.c,v 1.11 2000/12/21 14:50:09 ho Exp $	*/
d7 1
a7 2
 * Copyright (c) 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
d53 1
d76 1
a77 2
#include "log.h"
#include "math_mp.h"
d94 1
a94 1
  const EVP_MD *digest;
d112 1
a112 1
    switch (ch) {
d163 1
a163 1
      exit (1);
a176 3
  /* Get the digest for the actual signing */
  digest = EVP_get_digestbyname (OBJ_nid2sn (OBJ_obj2nid (cert->sig_alg->algorithm)));

d265 2
a266 1

@


1.9
log
@Merge with EOM 1.9

author: niklas
Style

author: ho
Nowadays we can use #include <openssl/...> instead of <ssl/...>
@
text
@d1 2
a2 2
/*	$OpenBSD: certpatch.c,v 1.8 2000/03/08 08:42:27 niklas Exp $	*/
/*	$EOM: certpatch.c,v 1.9 2000/09/28 12:53:37 niklas Exp $	*/
d101 1
a101 2
  char ch;
  int err;
@


1.8
log
@Merge with EOM 1.7

author: ho
Add sysdep.h and compile with KAME
@
text
@d1 2
a2 2
/*	$OpenBSD: certpatch.c,v 1.7 2000/02/01 02:46:17 niklas Exp $	*/
/*	$EOM: certpatch.c,v 1.7 2000/03/08 02:47:45 ho Exp $	*/
d7 1
a67 2
#  include <openssl/x509.h>
#  include <openssl/pem.h>
d69 1
a69 3
#  include <ssl/rsa.h>
#  include <ssl/x509.h>
#  include <ssl/pem.h>
d72 3
d83 1
@


1.7
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: certpatch.c,v 1.6 2000/01/26 15:22:41 niklas Exp $	*/
/*	$EOM: certpatch.c,v 1.6 2000/01/31 22:33:50 niklas Exp $	*/
d61 13
a73 3
#include <ssl/rsa.h>
#include <ssl/x509.h>
#include <ssl/pem.h>
@


1.6
log
@Merge with EOM 1.5

date: 2000/01/10 22:02:00;  author: angelos;  state: Exp;  lines: +2 -2
Fix wrong memcpy()
@
text
@d1 2
a2 2
/*	$OpenBSD: certpatch.c,v 1.5 2000/01/10 21:58:19 angelos Exp $	*/
/*	$EOM: certpatch.c,v 1.5 2000/01/10 22:02:00 angelos Exp $	*/
d6 1
@


1.5
log
@Big oops for non-IP SubjAltNames -- correct memcpy.
@
text
@d1 2
a2 2
/*	$OpenBSD: certpatch.c,v 1.4 1999/10/01 14:08:54 niklas Exp $	*/
/*	$EOM: certpatch.c,v 1.4 1999/09/28 21:26:47 angelos Exp $	*/
d226 1
a227 1
      memcpy (new_id + 2, id, strlen(id));
@


1.4
log
@Merge with EOM 1.4

author: angelos
blah

author: angelos
fqdn and ufqdn types
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.3 1999/08/26 22:29:29 niklas Exp $	*/
d227 1
a227 1
      memcpy (data + 2, id, strlen(id));
@


1.3
log
@regress/exchange/def-i.1: Merge with EOM
regress/exchange/def-r.1: Merge with EOM
apps/certpatch/certpatch.c: Merge with EOM 1.2
@
text
@d1 2
a2 2
/*	$OpenBSD: certpatch.c,v 1.2 1999/07/18 17:25:51 deraadt Exp $	*/
/*	$EOM: certpatch.c,v 1.2 1999/07/17 20:44:13 niklas Exp $	*/
d70 2
a71 1

d86 2
a87 2
  char ipaddr[6];
  char *type = "ip", *keyfile = NULL, *id = NULL;
d92 6
d130 3
a132 1
  if (strcasecmp (IDTYPE_IP, type) != 0 || id == NULL)
d154 3
d158 1
d172 41
a212 1
  if (inet_aton (id, &saddr) == -1)
d214 39
a252 2
      printf ("inet_aton () failed\n");
      exit (1);
d254 2
a255 10

  saddr.s_addr = htonl (saddr.s_addr);
  ipaddr[0] = 0x87;
  ipaddr[1] = 0x04;
  ipaddr[2] = saddr.s_addr >> 24;
  ipaddr[3] = (saddr.s_addr >> 16) & 0xff;
  ipaddr[4] = (saddr.s_addr >> 8) & 0xff;
  ipaddr[5] = saddr.s_addr & 0xff;

  data = X509v3_pack_string (NULL, V_ASN1_OCTET_STRING, ipaddr, 6);
d275 3
d279 1
@


1.2
log
@verbose usage messages do not suffice for missing man pages! and you know it!
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.1 1999/07/17 21:48:59 niklas Exp $	*/
d74 4
a77 1
  char *usage = "usage: %s [-t idtype] -i id -k keyfile certin certout\n";
@


1.1
log
@apps/certpatch/certpatch.c: Merge with EOM 1.2
apps/certpatch/Makefile: Merge with EOM 1.2
apps/Makefile: Merge with EOM 1.2

author: niklas
From Niels Provos, edited by me: certificate support using SSLeay

author: provos
add a tool that takes a certificate and private key in PEM format,
adds a subjectAltName extension to the certifcate and finally signs
it with the private key, writing back the result.
@
text
@d1 1
a1 1
/*	$OpenBSD: certpatch.c,v 1.2 1999/07/17 20:44:13 niklas Exp $	*/
d74 1
a74 4
  char *usage = "%s [-t idtype] -i id -k keyfile certin certout\n\n"
    "This programs takes a certificate and adds a subjectAltName extension\n"
    "with the identication given as command line argument.  Be sure that \n"
    "the signing key matches the issuer.\n";
@

