head	1.74;
access;
symbols
	OPENBSD_6_1:1.74.0.8
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.4
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.73.0.6
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.72.0.20
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.72.0.18
	OPENBSD_5_5_BASE:1.72
	OPENBSD_5_4:1.72.0.14
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.72.0.12
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.72.0.10
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.8
	OPENBSD_5_0:1.72.0.6
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.72.0.4
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.72.0.2
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.71.0.10
	OPENBSD_4_7_BASE:1.71
	OPENBSD_4_6:1.71.0.12
	OPENBSD_4_6_BASE:1.71
	OPENBSD_4_5:1.71.0.8
	OPENBSD_4_5_BASE:1.71
	OPENBSD_4_4:1.71.0.6
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.71.0.4
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.71.0.2
	OPENBSD_4_2_BASE:1.71
	OPENBSD_4_1:1.66.0.4
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.66.0.2
	OPENBSD_4_0_BASE:1.66
	OPENBSD_3_9:1.63.0.2
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.60.0.2
	OPENBSD_3_8_BASE:1.60
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9;
locks; strict;
comment	@ * @;


1.74
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	0qPuuXwccpVXsXcV;

1.73
date	2015.01.16.06.39.59;	author deraadt;	state Exp;
branches;
next	1.72;
commitid	Uu5nFG3wCl0LACBb;

1.72
date	2010.05.10.02.00.50;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2007.08.11.00.20.30;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.07.20.09.39;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.08.11.15.30;	author moritz;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.02.08.16.32;	author moritz;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.02.08.11.59;	author moritz;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.24.11.45.44;	author ho;	state Exp;
branches;
next	1.65;

1.65
date	2006.06.18.10.25.27;	author hshoexer;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.20.16.43.22;	author hshoexer;	state Exp;
branches;
next	1.63;

1.63
date	2006.01.02.10.42.51;	author hshoexer;	state Exp;
branches;
next	1.62;

1.62
date	2005.12.20.22.03.53;	author moritz;	state Exp;
branches;
next	1.61;

1.61
date	2005.11.26.22.17.20;	author hshoexer;	state Exp;
branches;
next	1.60;

1.60
date	2005.06.13.13.32.59;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2005.05.28.18.48.12;	author hshoexer;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.28.18.38.38;	author moritz;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.28.17.42.49;	author moritz;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.28.17.07.53;	author moritz;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.27.20.55.49;	author cloder;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.27.19.26.25;	author cloder;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.27.07.08.21;	author moritz;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.27.06.33.11;	author moritz;	state Exp;
branches;
next	1.51;

1.51
date	2005.05.27.04.37.25;	author moritz;	state Exp;
branches;
next	1.50;

1.50
date	2005.05.26.22.22.03;	author hshoexer;	state Exp;
branches;
next	1.49;

1.49
date	2005.05.24.03.26.26;	author moritz;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.24.02.57.15;	author moritz;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.23.22.33.32;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.23.22.21.56;	author ho;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.10.11.12.50;	author hshoexer;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.05.09.54.37;	author hshoexer;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.05.09.48.02;	author hshoexer;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.03.14.03.11;	author moritz;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.03.13.09.45;	author moritz;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.19.15.46.49;	author hshoexer;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.08.17.15.01;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.11.12.39.55;	author hshoexer;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.03.22.05.58;	author moritz;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.08.12.40.19;	author hshoexer;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.08.12.34.00;	author hshoexer;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.08.12.23.31;	author hshoexer;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.08.12.11.00;	author hshoexer;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.12.11.21.07;	author hshoexer;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.26.06.07.03;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.25.00.58.39;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.24.17.02.48;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.21.18.34.11;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.20.15.03.35;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.10.18.34.15;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.31.10.53.10;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.29.17.07.59;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.29.16.32.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.23.18.20.03;	author hshoexer;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.15.16.34.28;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.15.16.29.00;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.25.22.28.48;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.05.07.50.04;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.29.02.01.22;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.18.21.26.36;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.18.19.37.46;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.15.02.04.45;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.15.01.51.10;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	;


desc
@@


1.74
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@/* $OpenBSD: monitor.c,v 1.73 2015/01/16 06:39:59 deraadt Exp $	 */

/*
 * Copyright (c) 2003 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <netinet/in.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include <regex.h>
#include <keynote.h>

#include "conf.h"
#include "log.h"
#include "monitor.h"
#include "policy.h"
#include "ui.h"
#include "util.h"
#include "pf_key_v2.h"

struct monitor_state {
	pid_t           pid;
	int             s;
	char            root[PATH_MAX];
} m_state;

extern char *pid_file;

extern void	set_slave_signals(void);

/* Private functions.  */
static void	must_read(void *, size_t);
static void	must_write(const void *, size_t);

static void	m_priv_getfd(void);
static void	m_priv_setsockopt(void);
static void	m_priv_req_readdir(void);
static void	m_priv_bind(void);
static void	m_priv_pfkey_open(void);
static int	m_priv_local_sanitize_path(char *, size_t, int);
static int	m_priv_check_sockopt(int, int);
static int	m_priv_check_bind(const struct sockaddr *, socklen_t);

static void	set_monitor_signals(void);
static void	sig_pass_to_chld(int);

/*
 * Public functions, unprivileged.
 */

/* Setup monitor context, fork, drop child privs.  */
pid_t
monitor_init(int debug)
{
	struct passwd  *pw;
	int             p[2];

	bzero(&m_state, sizeof m_state);

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, p) != 0)
		log_fatal("monitor_init: socketpair() failed");

	pw = getpwnam(ISAKMPD_PRIVSEP_USER);
	if (pw == NULL)
		log_fatalx("monitor_init: getpwnam(\"%s\") failed",
		    ISAKMPD_PRIVSEP_USER);
	strlcpy(m_state.root, pw->pw_dir, sizeof m_state.root);

	set_monitor_signals();
	m_state.pid = fork();

	if (m_state.pid == -1)
		log_fatal("monitor_init: fork of unprivileged child failed");
	if (m_state.pid == 0) {
		/* The child process drops privileges. */
		set_slave_signals();

		if (chroot(pw->pw_dir) != 0 || chdir("/") != 0)
			log_fatal("monitor_init: chroot failed");

		if (setgroups(1, &pw->pw_gid) == -1 ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
			log_fatal("monitor_init: can't drop privileges");

		m_state.s = p[0];
		close(p[1]);

		LOG_DBG((LOG_MISC, 10,
		    "monitor_init: privileges dropped for child process"));
	} else {
		/* Privileged monitor. */
		setproctitle("monitor [priv]");

		m_state.s = p[1];
		close(p[0]);
	}

	/* With "-dd", stop and wait here. For gdb "attach" etc.  */
	if (debug > 1) {
		log_print("monitor_init: stopped %s PID %d fd %d%s",
		    m_state.pid ? "priv" : "child", getpid(), m_state.s,
		    m_state.pid ? ", waiting for SIGCONT" : "");
		kill(getpid(), SIGSTOP);	/* Wait here for SIGCONT.  */
		if (m_state.pid)
			kill(m_state.pid, SIGCONT); /* Continue child.  */
	}

	return m_state.pid;
}

void
monitor_exit(int code)
{
	int status;
	pid_t pid;

	if (m_state.pid != 0) {
		/* When called from the monitor, kill slave and wait for it  */
		kill(m_state.pid, SIGTERM);

		do {
			pid = waitpid(m_state.pid, &status, 0);
		} while (pid == -1 && errno == EINTR);

		/* Remove FIFO and pid files.  */
		unlink(ui_fifo);
		unlink(pid_file);
	}

	close(m_state.s);
	exit(code);
}

int
monitor_pf_key_v2_open(void)
{
	int	err, cmd;

	cmd = MONITOR_PFKEY_OPEN;
	must_write(&cmd, sizeof cmd);

	must_read(&err, sizeof err);
	if (err < 0) {
		log_error("monitor_pf_key_v2_open: parent could not create "
		    "PF_KEY socket");
		return -1;
	}
	pf_key_v2_socket = mm_receive_fd(m_state.s);
	if (pf_key_v2_socket < 0) {
		log_error("monitor_pf_key_v2_open: mm_receive_fd() failed");
		return -1;
	}

	return pf_key_v2_socket;
}

int
monitor_open(const char *path, int flags, mode_t mode)
{
	size_t	len;
	int	fd, err, cmd;
	char	pathreal[PATH_MAX];

	if (path[0] == '/')
		strlcpy(pathreal, path, sizeof pathreal);
	else
		snprintf(pathreal, sizeof pathreal, "%s/%s", m_state.root,
		    path);

	cmd = MONITOR_GET_FD;
	must_write(&cmd, sizeof cmd);

	len = strlen(pathreal);
	must_write(&len, sizeof len);
	must_write(&pathreal, len);

	must_write(&flags, sizeof flags);
	must_write(&mode, sizeof mode);

	must_read(&err, sizeof err);
	if (err != 0) {
		errno = err;
		return -1;
	}

	fd = mm_receive_fd(m_state.s);
	if (fd < 0) {
		log_error("monitor_open: mm_receive_fd () failed");
		return -1;
	}

	return fd;
}

FILE *
monitor_fopen(const char *path, const char *mode)
{
	FILE	*fp;
	int	 fd, flags = 0, saved_errno;
	mode_t	 mask, cur_umask;

	/* Only the child process is supposed to run this.  */
	if (m_state.pid)
		log_fatal("[priv] bad call to monitor_fopen");

	switch (mode[0]) {
	case 'r':
		flags = (mode[1] == '+' ? O_RDWR : O_RDONLY);
		break;
	case 'w':
		flags = (mode[1] == '+' ? O_RDWR : O_WRONLY) | O_CREAT |
		    O_TRUNC;
		break;
	case 'a':
		flags = (mode[1] == '+' ? O_RDWR : O_WRONLY) | O_CREAT |
		    O_APPEND;
		break;
	default:
		log_fatal("monitor_fopen: bad call");
	}

	cur_umask = umask(0);
	(void)umask(cur_umask);
	mask = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
	mask &= ~cur_umask;

	fd = monitor_open(path, flags, mask);
	if (fd < 0)
		return NULL;

	/* Got the fd, attach a FILE * to it.  */
	fp = fdopen(fd, mode);
	if (!fp) {
		log_error("monitor_fopen: fdopen() failed");
		saved_errno = errno;
		close(fd);
		errno = saved_errno;
		return NULL;
	}
	return fp;
}

int
monitor_stat(const char *path, struct stat *sb)
{
	int	fd, r, saved_errno;

	/* O_NONBLOCK is needed for stat'ing fifos. */
	fd = monitor_open(path, O_RDONLY | O_NONBLOCK, 0);
	if (fd < 0)
		return -1;

	r = fstat(fd, sb);
	saved_errno = errno;
	close(fd);
	errno = saved_errno;
	return r;
}

int
monitor_setsockopt(int s, int level, int optname, const void *optval,
    socklen_t optlen)
{
	int	ret, err, cmd;

	cmd = MONITOR_SETSOCKOPT;
	must_write(&cmd, sizeof cmd);
	if (mm_send_fd(m_state.s, s)) {
		log_print("monitor_setsockopt: read/write error");
		return -1;
	}

	must_write(&level, sizeof level);
	must_write(&optname, sizeof optname);
	must_write(&optlen, sizeof optlen);
	must_write(optval, optlen);

	must_read(&err, sizeof err);
	must_read(&ret, sizeof ret);
	if (err != 0)
		errno = err;
	return ret;
}

int
monitor_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
	int	ret, err, cmd;

	cmd = MONITOR_BIND;
	must_write(&cmd, sizeof cmd);
	if (mm_send_fd(m_state.s, s)) {
		log_print("monitor_bind: read/write error");
		return -1;
	}

	must_write(&namelen, sizeof namelen);
	must_write(name, namelen);

	must_read(&err, sizeof err);
	must_read(&ret, sizeof ret);
	if (err != 0)
		errno = err;
	return ret;
}

int
monitor_req_readdir(const char *filename)
{
	int cmd, err;
	size_t len;

	cmd = MONITOR_REQ_READDIR;
	must_write(&cmd, sizeof cmd);

	len = strlen(filename);
	must_write(&len, sizeof len);
	must_write(filename, len);

	must_read(&err, sizeof err);
	if (err == -1)
		must_read(&errno, sizeof errno);

	return err;
}

int
monitor_readdir(char *file, size_t size)
{
	int fd;
	size_t len;

	must_read(&len, sizeof len);
	if (len == 0)
		return -1;
	if (len >= size)
		log_fatal("monitor_readdir: received bad length from monitor");
	must_read(file, len);
	file[len] = '\0';
	fd = mm_receive_fd(m_state.s);
	return fd;
}

void
monitor_init_done(void)
{
	int	cmd;

	cmd = MONITOR_INIT_DONE;
	must_write(&cmd, sizeof cmd);
}

/*
 * Start of code running with privileges (the monitor process).
 */

static void
set_monitor_signals(void)
{
	int n;

	for (n = 1; n < _NSIG; n++)
		signal(n, SIG_DFL);

	/* Forward some signals to the child. */
	signal(SIGTERM, sig_pass_to_chld);
	signal(SIGHUP, sig_pass_to_chld);
	signal(SIGUSR1, sig_pass_to_chld);
}

static void
sig_pass_to_chld(int sig)
{
	int	oerrno = errno;

	if (m_state.pid > 0)
		kill(m_state.pid, sig);
	errno = oerrno;
}

/* This function is where the privileged process waits(loops) indefinitely.  */
void
monitor_loop(int debug)
{
	int	 msgcode;

	if (!debug)
		log_to(0);

	for (;;) {
		must_read(&msgcode, sizeof msgcode);

		switch (msgcode) {
		case MONITOR_GET_FD:
			m_priv_getfd();
			break;

		case MONITOR_PFKEY_OPEN:
			LOG_DBG((LOG_MISC, 80,
			    "monitor_loop: MONITOR_PFKEY_OPEN"));
			m_priv_pfkey_open();
			break;

		case MONITOR_SETSOCKOPT:
			LOG_DBG((LOG_MISC, 80,
			    "monitor_loop: MONITOR_SETSOCKOPT"));
			m_priv_setsockopt();
			break;

		case MONITOR_BIND:
			LOG_DBG((LOG_MISC, 80,
			    "monitor_loop: MONITOR_BIND"));
			m_priv_bind();
			break;

		case MONITOR_REQ_READDIR:
			LOG_DBG((LOG_MISC, 80,
			    "monitor_loop: MONITOR_REQ_READDIR"));
			m_priv_req_readdir();
			break;

		case MONITOR_INIT_DONE:
			LOG_DBG((LOG_MISC, 80,
			    "monitor_loop: MONITOR_INIT_DONE"));
			break;

		case MONITOR_SHUTDOWN:
			LOG_DBG((LOG_MISC, 80,
			    "monitor_loop: MONITOR_SHUTDOWN"));
			break;

		default:
			log_print("monitor_loop: got unknown code %d",
			    msgcode);
		}
	}

	exit(0);
}


/* Privileged: called by monitor_loop.  */
static void
m_priv_pfkey_open(void)
{
	int	fd, err = 0;

	fd = pf_key_v2_open();
	if (fd < 0)
		err = -1;

	must_write(&err, sizeof err);

	if (fd > 0 && mm_send_fd(m_state.s, fd)) {
		log_error("m_priv_pfkey_open: read/write operation failed");
		close(fd);
		return;
	}
	close(fd);
}

/* Privileged: called by monitor_loop.  */
static void
m_priv_getfd(void)
{
	char	path[PATH_MAX];
	size_t	len;
	int	v, flags, ret;
	int	err = 0;
	mode_t	mode;

	must_read(&len, sizeof len);
	if (len == 0 || len >= sizeof path)
		log_fatal("m_priv_getfd: invalid pathname length");

	must_read(path, len);
	path[len] = '\0';
	if (strlen(path) != len)
		log_fatal("m_priv_getfd: invalid pathname");

	must_read(&flags, sizeof flags);
	must_read(&mode, sizeof mode);

	if ((ret = m_priv_local_sanitize_path(path, sizeof path, flags))
	    != 0) {
		if (ret == 1)
			log_print("m_priv_getfd: illegal path \"%s\"", path);
		err = EACCES;
		v = -1;
	} else {
		if ((v = open(path, flags, mode)) == -1)
			err = errno;
	}

	must_write(&err, sizeof err);

	if (v != -1) {
		if (mm_send_fd(m_state.s, v) == -1)
			log_error("m_priv_getfd: sending fd failed");
		close(v);
	}
}

/* Privileged: called by monitor_loop.  */
static void
m_priv_setsockopt(void)
{
	int		 sock, level, optname, v;
	int		 err = 0;
	char		*optval = 0;
	socklen_t	 optlen;

	sock = mm_receive_fd(m_state.s);
	if (sock < 0) {
		log_print("m_priv_setsockopt: read/write error");
		return;
	}

	must_read(&level, sizeof level);
	must_read(&optname, sizeof optname);
	must_read(&optlen, sizeof optlen);

	optval = malloc(optlen);
	if (!optval) {
		log_print("m_priv_setsockopt: malloc failed");
		close(sock);
		return;
	}

	must_read(optval, optlen);

	if (m_priv_check_sockopt(level, optname) != 0) {
		err = EACCES;
		v = -1;
	} else {
		v = setsockopt(sock, level, optname, optval, optlen);
		if (v < 0)
			err = errno;
	}

	close(sock);
	sock = -1;

	must_write(&err, sizeof err);
	must_write(&v, sizeof v);

	free(optval);
	return;
}

/* Privileged: called by monitor_loop.  */
static void
m_priv_bind(void)
{
	int		 sock, v, err = 0;
	struct sockaddr *name = 0;
	socklen_t        namelen;

	sock = mm_receive_fd(m_state.s);
	if (sock < 0) {
		log_print("m_priv_bind: read/write error");
		return;
	}

	must_read(&namelen, sizeof namelen);
	name = malloc(namelen);
	if (!name) {
		log_print("m_priv_bind: malloc failed");
		close(sock);
		return;
	}
	must_read((char *)name, namelen);

	if (m_priv_check_bind(name, namelen) != 0) {
		err = EACCES;
		v = -1;
	} else {
		v = bind(sock, name, namelen);
		if (v < 0) {
			log_error("m_priv_bind: bind(%d,%p,%d) returned %d",
			    sock, name, namelen, v);
			err = errno;
		}
	}

	close(sock);
	sock = -1;

	must_write(&err, sizeof err);
	must_write(&v, sizeof v);

	free(name);
	return;
}

/*
 * Help functions, used by both privileged and unprivileged code
 */

/*
 * Read data with the assertion that it all must come through, or else abort
 * the process.  Based on atomicio() from openssh.
 */
static void
must_read(void *buf, size_t n)
{
        char *s = buf;
	size_t pos = 0;
        ssize_t res;

        while (n > pos) {
                res = read(m_state.s, s + pos, n - pos);
                switch (res) {
                case -1:
                        if (errno == EINTR || errno == EAGAIN)
                                continue;
                case 0:
			monitor_exit(0);
                default:
                        pos += res;
                }
        }
}

/*
 * Write data with the assertion that it all has to be written, or else abort
 * the process.  Based on atomicio() from openssh.
 */
static void
must_write(const void *buf, size_t n)
{
        const char *s = buf;
	size_t pos = 0;
	ssize_t res;

        while (n > pos) {
                res = write(m_state.s, s + pos, n - pos);
                switch (res) {
                case -1:
                        if (errno == EINTR || errno == EAGAIN)
                                continue;
                case 0:
			monitor_exit(0);
                default:
                        pos += res;
                }
        }
}

/* Check that path/mode is permitted.  */
static int
m_priv_local_sanitize_path(char *path, size_t pmax, int flags)
{
	char new_path[PATH_MAX], var_run[PATH_MAX];

	/*
	 * We only permit paths starting with
	 *  /etc/isakmpd/	(read only)
	 *  /var/run/		(rw)
         */

	if (realpath(path, new_path) == NULL ||
	    realpath("/var/run", var_run) == NULL) {
		/*
                 * We could not decide whether the path is ok or not.
                 * Indicate this be returning 2.
		 */
		if (errno == ENOENT)
			return 2;
		goto bad_path;
	}
	strlcat(var_run, "/", sizeof(var_run));

	if (strncmp(var_run, new_path, strlen(var_run)) == 0)
		return 0;

	if (strncmp(ISAKMPD_ROOT, new_path, strlen(ISAKMPD_ROOT)) == 0 &&
	    (flags & O_ACCMODE) == O_RDONLY)
		return 0;

bad_path:
	return 1;
}

/* Check setsockopt */
static int
m_priv_check_sockopt(int level, int name)
{
	switch (level) {
		/* These are allowed */
		case SOL_SOCKET:
		case IPPROTO_IP:
		case IPPROTO_IPV6:
		break;

	default:
		log_print("m_priv_check_sockopt: Illegal level %d", level);
		return 1;
	}

	switch (name) {
		/* These are allowed */
	case SO_REUSEPORT:
	case SO_REUSEADDR:
	case IP_AUTH_LEVEL:
	case IP_ESP_TRANS_LEVEL:
	case IP_ESP_NETWORK_LEVEL:
	case IP_IPCOMP_LEVEL:
	case IPV6_AUTH_LEVEL:
	case IPV6_ESP_TRANS_LEVEL:
	case IPV6_ESP_NETWORK_LEVEL:
	case IPV6_IPCOMP_LEVEL:
		break;

	default:
		log_print("m_priv_check_sockopt: Illegal option name %d",
		    name);
		return 1;
	}

	return 0;
}

/* Check bind */
static int
m_priv_check_bind(const struct sockaddr *sa, socklen_t salen)
{
	in_port_t       port;

	if (sa == NULL) {
		log_print("NULL address");
		return 1;
	}
	if (SA_LEN(sa) != salen) {
		log_print("Length mismatch: %lu %lu", (unsigned long)sa->sa_len,
		    (unsigned long)salen);
		return 1;
	}
	switch (sa->sa_family) {
	case AF_INET:
		if (salen != sizeof(struct sockaddr_in)) {
			log_print("Invalid inet address length");
			return 1;
		}
		port = ((const struct sockaddr_in *)sa)->sin_port;
		break;
	case AF_INET6:
		if (salen != sizeof(struct sockaddr_in6)) {
			log_print("Invalid inet6 address length");
			return 1;
		}
		port = ((const struct sockaddr_in6 *)sa)->sin6_port;
		break;
	default:
		log_print("Unknown address family");
		return 1;
	}

	port = ntohs(port);

	if (port != ISAKMP_PORT_DEFAULT && port < 1024) {
		log_print("Disallowed port %u", port);
		return 1;
	}
	return 0;
}

static void
m_priv_req_readdir()
{
	size_t len;
	char path[PATH_MAX];
	DIR *dp;
	struct dirent *file;
	struct stat sb;
	int off, size, fd, ret, serrno;

	must_read(&len, sizeof len);
	if (len == 0 || len >= sizeof path)
		log_fatal("m_priv_req_readdir: invalid pathname length");
	must_read(path, len);
	path[len] = '\0';
	if (strlen(path) != len)
		log_fatal("m_priv_req_readdir: invalid pathname");

	off = strlen(path);
	size = sizeof path - off;

	if ((dp = opendir(path)) == NULL) {
		serrno = errno;
		ret = -1;
		must_write(&ret, sizeof ret);
		must_write(&serrno, sizeof serrno);
		return;
	}

	/* report opendir() success */
	ret = 0;
	must_write(&ret, sizeof ret);

	while ((file = readdir(dp)) != NULL) {
		strlcpy(path + off, file->d_name, size);

		if (m_priv_local_sanitize_path(path, sizeof path, O_RDONLY)
		    != 0)
			continue;
		fd = open(path, O_RDONLY, 0);
		if (fd == -1) {
			log_error("m_priv_req_readdir: open "
			    "(\"%s\", O_RDONLY, 0) failed", path);
			continue;
		}
		if ((fstat(fd, &sb) == -1) ||
		    !(S_ISREG(sb.st_mode) || S_ISLNK(sb.st_mode))) {
			close(fd);
			continue;
		}

		len = strlen(path);
		must_write(&len, sizeof len);
		must_write(path, len);

		mm_send_fd(m_state.s, fd);
		close(fd);
	}
	closedir(dp);

	len = 0;
	must_write(&len, sizeof len);
}
@


1.73
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.72 2010/05/10 02:00:50 krw Exp $	 */
d558 1
a558 1
	optval = (char *)malloc(optlen);
d601 1
a601 1
	name = (struct sockaddr *)malloc(namelen);
@


1.72
log
@Various comment typos. 'wether' -> 'whether' (most popular), 'possiblity' ->
'possibility', 'optins' -> 'options', 'resposne' -> 'response', 'unecessary' -> 'unnecessary', 'desination' -> 'destination'. Collected from various misc@@
and tech@@ postings, many by Brad Tilley.
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.71 2007/08/11 00:20:30 hshoexer Exp $	 */
a26 1
#include <sys/param.h>
d42 1
d58 1
a58 1
	char            root[MAXPATHLEN];
d197 1
a197 1
	char	pathreal[MAXPATHLEN];
d501 1
a501 1
	char	path[MAXPATHLEN];
d807 1
a807 1
	char path[MAXPATHLEN];
@


1.71
log
@Do not complain about being not able to read non-existing files.  Minor
glitch introduced by previous commit.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.70 2007/08/07 20:09:39 markus Exp $	 */
d700 1
a700 1
                 * We could not decide wether the path is ok or not.
@


1.70
log
@m_priv_req_readdir(): check file type after fstat, since d_type
is not passed over NFS (unless readdir+ is used). fixes pr 5557
with and ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.70 2007/08/07 20:05:17 markus Exp $	 */
d503 1
a503 1
	int	v, flags;
d519 4
a522 2
	if (m_priv_local_sanitize_path(path, sizeof path, flags) != 0) {
		log_print("m_priv_getfd: illegal path \"%s\"", path);
d699 4
d704 1
a704 1
			return 1;
@


1.69
log
@o Kill another strerror() from a call to log_error(),
  which already adds the errno string.
o Avoid closing fd, if it's -1.
o Don't replace illegal pathes with /dev/null in
  m_priv_local_sanitize_path(). All callers skip it
  anyways, in the failure case.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.68 2007/04/02 08:16:32 moritz Exp $	 */
d520 1
a710 1
	log_print("m_priv_local_sanitize_path: illegal path \"%.1023s\"", path);
d804 1
a832 3
		if (file->d_type != DT_REG && file->d_type != DT_LNK)
				continue;

d834 1
a834 2
		    != 0) {
			log_errorx("m_priv_req_readdir: invalid dir entry");
a835 1
		}
d840 5
@


1.68
log
@Don't append the errno string in a log_error() call,
since it will be automatically be appended.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.67 2007/04/02 08:11:59 moritz Exp $	 */
d223 1
a223 2
		log_error("monitor_open: mm_receive_fd () failed: %s",
		    strerror(errno));
d523 1
a523 2
		v = open(path, flags, mode);
		if (v < 0)
d529 3
a531 2
	if (v > 0 && mm_send_fd(m_state.s, v)) {
		log_error("m_priv_getfd: read/write operation failed");
a532 1
		return;
a533 1
	close(v);
d710 1
a710 3
	log_print("m_priv_local_sanitize_path: illegal path \"%.1023s\", "
		  "replaced with \"/dev/null\"", path);
	strlcpy(path, "/dev/null", pmax);
@


1.67
log
@When setting all signals to their default handlers, start
with signal 1, since there's no signal 0.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.66 2006/07/24 11:45:44 ho Exp $	 */
d185 1
a185 2
		log_error("monitor_pf_key_v2_open: mm_receive_fd() failed: %s",
		    strerror(errno));
@


1.66
log
@Style; return is not a function. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.65 2006/06/18 10:25:27 hshoexer Exp $	 */
d399 1
a399 1
	for (n = 0; n < _NSIG; n++)
@


1.65
log
@clean up some gotos.  Originally from Andrey Matveev <evol at online
dot ptt dot ru>.  Ok and help moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.64 2006/03/20 16:43:22 hshoexer Exp $	 */
d361 1
a361 1
	return (err);
@


1.64
log
@make sure the command fifo is ready before isakmpd returns.  This
resolves a startup race when interacting with ipsecctl.  Suggested
by and discussed with moritz@@

ok moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.63 2006/01/02 10:42:51 hshoexer Exp $	 */
d550 4
a553 2
	if (sock < 0)
		goto errout;
d560 5
a564 2
	if (!optval)
		goto errout;
a584 5

errout:
	log_print("m_priv_setsockopt: read/write error");
	if (sock >= 0)
		close(sock);
d596 4
a599 2
	if (sock < 0)
		goto errout;
d603 5
a607 2
	if (!name)
		goto errout;
a629 5

errout:
	log_print("m_priv_bind: read/write error");
	if (sock >= 0)
		close(sock);
@


1.63
log
@clean up error paths using "goto", part 1.  From Andrey Matveev <evol at
online dot ptt dot ru>.  Thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.62 2005/12/20 22:03:53 moritz Exp $	 */
a72 1
static void	m_priv_ui_init(void);
d74 3
a76 3
static int      m_priv_local_sanitize_path(char *, size_t, int);
static int      m_priv_check_sockopt(int, int);
static int      m_priv_check_bind(const struct sockaddr *, socklen_t);
a168 19
void
monitor_ui_init(void)
{
	int	err, cmd;

	cmd = MONITOR_UI_INIT;
	must_write(&cmd, sizeof cmd);

	must_read(&err, sizeof err);
	if (err != 0)
		log_fatal("monitor_ui_init: parent could not create FIFO "
		    "\"%s\"", ui_fifo);

	ui_socket = mm_receive_fd(m_state.s);
	if (ui_socket < 0)
		log_fatal("monitor_ui_init: parent could not create FIFO "
		    "\"%s\"", ui_fifo);
}

a434 6
		case MONITOR_UI_INIT:
			LOG_DBG((LOG_MISC, 80,
			    "monitor_loop: MONITOR_UI_INIT"));
			m_priv_ui_init();
			break;

a477 24

/* Privileged: called by monitor_loop.  */
static void
m_priv_ui_init(void)
{
	int	err = 0;

	ui_init();

	if (ui_socket < 0)
		err = -1;

	must_write(&err, sizeof err);

	if (ui_socket >= 0 && mm_send_fd(m_state.s, ui_socket)) {
		log_error("m_priv_ui_init: read/write operation failed");
		close(ui_socket);
		return;
	}

	/* In case of stdin, we do not close the socket. */
	if (ui_socket > 0)
		close(ui_socket);
}
@


1.62
log
@let isakmpd(8) remove it's pid/fifo file on exit.
rework signal handling in the monitor process to
let this work. testing and ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.61 2005/11/26 22:17:20 hshoexer Exp $	 */
a186 2

	return;
d325 4
a328 2
	if (mm_send_fd(m_state.s, s))
		goto errout;
a339 4

errout:
	log_print("monitor_setsockopt: read/write error");
	return -1;
d349 4
a352 2
	if (mm_send_fd(m_state.s, s))
		goto errout;
a361 4

errout:
	log_print("monitor_bind: read/write error");
	return -1;
d519 1
d521 1
a521 1
		goto errout;
a526 4
	return;

errout:
	log_error("m_priv_ui_init: read/write operation failed");
d542 1
d544 1
a544 1
		goto errout;
a546 5

	return;

errout:
	log_error("m_priv_pfkey_open: read/write operation failed");
d583 1
d585 1
a585 1
		goto errout;
a587 4
	return;

errout:
	log_error("m_priv_getfd: read/write operation failed");
a913 2

	return;
@


1.61
log
@get rid of some leftovers from a cleanup during c2k5.  From Andrey Matveev
<evol at online dot ptt dot ru>, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.60 2005/06/13 13:32:59 millert Exp $	 */
d61 1
a61 2
volatile sig_atomic_t sigchlded = 0;
extern volatile sig_atomic_t sigtermed;
a79 1
static void	monitor_got_sigchld(int);
d150 15
a164 2
	if (m_state.pid != 0)
		kill(m_state.pid, SIGKILL);
a427 3
	/* If the child dies, we should shutdown also.  */
	signal(SIGCHLD, monitor_got_sigchld);

a433 7
/* ARGSUSED */
static void
monitor_got_sigchld(int sig)
{
	sigchlded = 1;
}

d448 1
a448 2
	pid_t	 pid;
	int	 msgcode, status;
a453 20
		/*
		 * Currently, there is no need for us to hang around if the
		 * child is in the process of shutting down.
		 */
		if (sigtermed) {
			kill(m_state.pid, SIGTERM);
			break;
		}

		if (sigchlded) {
			do {
				pid = waitpid(m_state.pid, &status, WNOHANG);
			} while (pid == -1 && errno == EINTR);

			if (pid == m_state.pid && (WIFEXITED(status) ||
			    WIFSIGNALED(status))) {
				break;
			}
		}

d720 1
a720 1
			_exit(0);
d745 1
a745 1
			_exit(0);
@


1.60
log
@Allow isakmpd to write a pid file when /var is a subdir (e.g. /usr/var)
and not a mount point.
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.59 2005/05/28 18:48:12 hshoexer Exp $	 */
a668 2
	if (optval)
		free(optval);
a713 2
	if (name)
		free(name);
@


1.59
log
@Remove current state code, it's bogus.  We'll redo this.

suggested by and ok moritz
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.58 2005/05/28 18:38:38 moritz Exp $	 */
d780 1
a780 1
	char new_path[PATH_MAX];
d788 2
a789 1
	if (realpath(path, new_path) == NULL) {
d794 1
d796 1
a796 1
	if (strncmp("/var/run/", new_path, strlen("/var/run/")) == 0)
@


1.58
log
@do sanity checking on directoy entries. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.57 2005/05/28 17:42:49 moritz Exp $	 */
a62 1
static volatile sig_atomic_t cur_state = STATE_INIT;
a78 2
static void     m_priv_increase_state(int);
static void     m_priv_test_state(int);
d453 1
a453 1
	while (cur_state < STATE_QUIT) {
a458 1
			m_priv_increase_state(STATE_QUIT);
a469 1
				m_priv_increase_state(STATE_QUIT);
a483 1
			m_priv_test_state(STATE_INIT);
a489 1
			m_priv_test_state(STATE_INIT);
a495 1
			m_priv_test_state(STATE_INIT);
a501 1
			m_priv_test_state(STATE_INIT);
a513 2
			m_priv_test_state(STATE_INIT);
			m_priv_increase_state(STATE_RUNNING);
a518 1
			m_priv_increase_state(STATE_QUIT);
a953 21
}

/* Increase state into less permissive mode */
static void
m_priv_increase_state(int state)
{
	if (state <= cur_state)
		log_print("m_priv_increase_state: attempt to decrease state "
		    "or match current state");
	if (state < STATE_INIT || state > STATE_QUIT)
		log_print("m_priv_increase_state: attempt to switch to "
		    "invalid state");
	cur_state = state;
}

static void
m_priv_test_state(int state)
{
	if (cur_state != state)
		log_print("m_priv_test_state: Illegal state: %d != %d",
		    (int)cur_state, state);
@


1.57
log
@introduce new readdir implementation for the monitor.
testing and ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.56 2005/05/28 17:07:53 moritz Exp $	 */
d800 3
a802 1
	if (realpath(path, new_path) == NULL)
d804 1
a922 2
	/* XXX sanitize path */

d938 6
a943 2
		if (file->d_type != DT_UNKNOWN && file->d_type != DT_REG &&
		    file->d_type != DT_LNK)
d945 1
a945 1

@


1.56
log
@make path checking in the monitor a lot easier. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.55 2005/05/27 20:55:49 cloder Exp $	 */
d73 1
d362 2
a363 2
struct monitor_dirents *
monitor_opendir(const char *path)
d365 2
a366 7
	char           *buf, *cp;
	size_t          bufsize;
	int             fd, nbytes, entries;
	long            base;
	struct stat     sb;
	struct dirent  *dp;
	struct monitor_dirents *direntries;
d368 2
a369 33
	fd = monitor_open(path, 0, O_RDONLY);
	if (fd < 0) {
		log_error("monitor_opendir: opendir(\"%s\") failed", path);
		return NULL;
	}
	/* Now build a list with all dirents from fd. */
	if (fstat(fd, &sb) < 0) {
		(void)close(fd);
		return NULL;
	}
	if (!S_ISDIR(sb.st_mode)) {
		(void)close(fd);
		errno = EACCES;
		return NULL;
	}
	bufsize = sb.st_size;
	if (bufsize < sb.st_blksize)
		bufsize = sb.st_blksize;

	buf = calloc(bufsize, sizeof(char));
	if (buf == NULL) {
		(void)close(fd);
		errno = EACCES;
		return NULL;
	}
	nbytes = getdirentries(fd, buf, bufsize, &base);
	if (nbytes <= 0) {
		(void)close(fd);
		free(buf);
		errno = EACCES;
		return NULL;
	}
	(void)close(fd);
d371 3
a373 5
	for (entries = 0, cp = buf; cp < buf + nbytes;) {
		dp = (struct dirent *)cp;
		cp += dp->d_reclen;
		entries++;
	}
d375 3
a377 14
	direntries = calloc(1, sizeof(struct monitor_dirents));
	if (direntries == NULL) {
		free(buf);
		errno = EACCES;
		return NULL;
	}
	direntries->dirents = calloc(entries + 1, sizeof(struct dirent *));
	if (direntries->dirents == NULL) {
		free(buf);
		free(direntries);
		errno = EACCES;
		return NULL;
	}
	direntries->current = 0;
d379 1
a379 8
	for (entries = 0, cp = buf; cp < buf + nbytes;) {
		dp = (struct dirent *)cp;
		direntries->dirents[entries++] = dp;
		cp += dp->d_reclen;
	}
	direntries->dirents[entries] = NULL;

	return direntries;
d382 2
a383 2
struct dirent *
monitor_readdir(struct monitor_dirents *direntries)
d385 2
a386 2
	if (direntries->dirents[direntries->current] != NULL)
		return direntries->dirents[direntries->current++];
d388 9
a396 8
	return NULL;
}

void
monitor_closedir(struct monitor_dirents *direntries)
{
	free(direntries->dirents);
	free(direntries);
d514 6
d898 63
@


1.55
log
@Make monitor.c use unsigned lengths in messages.  Makes this compile
with -Wsign-compare. OK and a little testing by hshoexer, OK moritz
Now it's anil's turn to do some of this somewhere else
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.54 2005/05/27 19:26:25 cloder Exp $	 */
d840 1
a840 1
	char	*p;
d848 1
a848 1
	if (strlen(path) < strlen("/var/run/"))
d851 5
a855 14
	/* Any path containing '..' is invalid.  */
	for (p = path; *p && (p - path) < (int)pmax; p++)
		if (*p == '.' && *(p + 1) == '.')
			goto bad_path;

	/* For any write-mode, only a few paths are permitted.  */
	if ((flags & O_ACCMODE) != O_RDONLY) {
		if (strncmp("/var/run/", path, strlen("/var/run/")) == 0)
			return 0;
		goto bad_path;
	}
	/* Any other path is read-only.  */
	if (strncmp(ISAKMPD_ROOT, path, strlen(ISAKMPD_ROOT)) == 0 ||
	    strncmp("/var/run/", path, strlen("/var/run/")) == 0)
@


1.54
log
@Additional paranoia. OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.53 2005/05/27 07:08:21 moritz Exp $	 */
d209 2
a210 1
	int	fd, err, cmd, len;
d324 1
a324 1
	must_write(optval, (size_t)optlen);
d348 1
a348 1
	must_write(name, (size_t)namelen);
d647 2
a648 1
	int	v, flags, len;
d653 1
a653 1
	if (len <= 0 || len >= sizeof path)
d707 1
a707 1
	must_read(optval, (size_t)optlen);
d747 1
a747 2
	must_read(&v, sizeof v);
	namelen = (socklen_t)v;
d751 1
a751 1
	must_read((char *)name, (size_t)namelen);
d819 2
a820 1
        ssize_t res, pos = 0;
@


1.53
log
@o only pass signals from monitor to slave when pid is valid
o remove some unused monitor command
with and ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.52 2005/05/27 06:33:11 moritz Exp $	 */
d656 3
@


1.52
log
@move m_state.s directly into must_{read,write} instead of passing
it every time as an argument. ok cloder@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.51 2005/05/27 04:37:25 moritz Exp $	 */
d494 1
a494 1
	if (m_state.pid != -1)
@


1.51
log
@guarantee nul-termination in the monitor, we must. ok cloder@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.50 2005/05/26 22:22:03 hshoexer Exp $	 */
d68 2
a69 2
static void	must_read(int, void *, size_t);
static void	must_write(int, const void *, size_t);
d71 5
a75 3
static void     m_priv_getfd(int);
static void     m_priv_setsockopt(int);
static void     m_priv_bind(int);
a81 3
static void	m_priv_ui_init(int);
static void	m_priv_pfkey_open(int);

d167 1
a167 1
	must_write(m_state.s, &cmd, sizeof cmd);
d169 1
a169 1
	must_read(m_state.s, &err, sizeof err);
d188 1
a188 1
	must_write(m_state.s, &cmd, sizeof cmd);
d190 1
a190 1
	must_read(m_state.s, &err, sizeof err);
d219 1
a219 1
	must_write(m_state.s, &cmd, sizeof cmd);
d222 2
a223 2
	must_write(m_state.s, &len, sizeof len);
	must_write(m_state.s, &pathreal, len);
d225 2
a226 2
	must_write(m_state.s, &flags, sizeof flags);
	must_write(m_state.s, &mode, sizeof mode);
d228 1
a228 1
	must_read(m_state.s, &err, sizeof err);
d316 1
a316 1
	must_write(m_state.s, &cmd, sizeof cmd);
d320 4
a323 4
	must_write(m_state.s, &level, sizeof level);
	must_write(m_state.s, &optname, sizeof optname);
	must_write(m_state.s, &optlen, sizeof optlen);
	must_write(m_state.s, optval, (size_t)optlen);
d325 2
a326 2
	must_read(m_state.s, &err, sizeof err);
	must_read(m_state.s, &ret, sizeof ret);
d342 1
a342 1
	must_write(m_state.s, &cmd, sizeof cmd);
d346 2
a347 2
	must_write(m_state.s, &namelen, sizeof namelen);
	must_write(m_state.s, name, (size_t)namelen);
d349 2
a350 2
	must_read(m_state.s, &err, sizeof err);
	must_read(m_state.s, &ret, sizeof ret);
d458 1
a458 1
	must_write(m_state.s, &cmd, sizeof cmd);
d532 1
a532 1
		must_read(m_state.s, &msgcode, sizeof msgcode);
d536 1
a536 1
			m_priv_getfd(m_state.s);
d543 1
a543 1
			m_priv_ui_init(m_state.s);
d550 1
a550 1
			m_priv_pfkey_open(m_state.s);
d557 1
a557 1
			m_priv_setsockopt(m_state.s);
d564 1
a564 1
			m_priv_bind(m_state.s);
d592 1
a592 1
m_priv_ui_init(int s)
d601 1
a601 1
	must_write(s, &err, sizeof err);
d603 1
a603 1
	if (ui_socket >= 0 && mm_send_fd(s, ui_socket)) {
d619 1
a619 1
m_priv_pfkey_open(int s)
d627 1
a627 1
	must_write(s, &err, sizeof err);
d629 1
a629 1
	if (fd > 0 && mm_send_fd(s, fd)) {
d643 1
a643 1
m_priv_getfd(int s)
d650 1
a650 1
	must_read(s, &len, sizeof len);
d654 1
a654 1
	must_read(s, path, len);
d656 2
a657 2
	must_read(s, &flags, sizeof flags);
	must_read(s, &mode, sizeof mode);
d668 1
a668 1
	must_write(s, &err, sizeof err);
d670 1
a670 1
	if (v > 0 && mm_send_fd(s, v)) {
d683 1
a683 1
m_priv_setsockopt(int s)
d690 1
a690 1
	sock = mm_receive_fd(s);
d694 3
a696 3
	must_read(s, &level, sizeof level);
	must_read(s, &optname, sizeof optname);
	must_read(s, &optlen, sizeof optlen);
d702 1
a702 1
	must_read(s, optval, (size_t)optlen);
d716 2
a717 2
	must_write(s, &err, sizeof err);
	must_write(s, &v, sizeof v);
d732 1
a732 1
m_priv_bind(int s)
d738 1
a738 1
	sock = mm_receive_fd(s);
d742 1
a742 1
	must_read(s, &v, sizeof v);
d747 1
a747 1
	must_read(s, (char *)name, (size_t)namelen);
d764 2
a765 2
	must_write(s, &err, sizeof err);
	must_write(s, &v, sizeof v);
d787 1
a787 1
must_read(int fd, void *buf, size_t n)
d794 1
a794 1
                res = read(fd, s + pos, n - pos);
d812 1
a812 1
must_write(int fd, const void *buf, size_t n)
d818 1
a818 1
                res = write(fd, s + pos, n - pos);
@


1.50
log
@simplify read/write between child and monitor

help and ok cloder moritz
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.49 2005/05/24 03:26:26 moritz Exp $	 */
d222 1
a222 1
	len = strlen(pathreal) + 1;
d652 1
a652 1
	if (len <= 0 || sizeof path < len)
d656 1
@


1.49
log
@kill unneeded exit(). log_fatal() already does it. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.48 2005/05/24 02:57:15 moritz Exp $	 */
d68 2
a69 5
int             m_write_int32(int, int32_t);
int             m_write_raw(int, const char *, size_t);
int             m_read_int32(int, int32_t *);
int             m_read_raw(int, char *, size_t);
void            m_flush(int);
a71 1
static void     m_priv_getsocket(int);
d165 1
a165 1
	int32_t	err;
d167 2
a168 5
	if (m_write_int32(m_state.s, MONITOR_UI_INIT))
		goto errout;

	if (m_read_int32(m_state.s, &err))
		goto errout;
d170 1
a180 3

errout:
	log_error("monitor_ui_init: problem talking to privileged process");
d186 1
a186 4
	int32_t err;

	if (m_write_int32(m_state.s, MONITOR_PFKEY_OPEN))
		goto errout;
d188 2
a189 2
	if (m_read_int32(m_state.s, &err))
		goto errout;
d191 1
a196 1

d203 1
a204 5

errout:
	log_error("monitor_pf_key_v2_open: problem talking to privileged "
	    "process");
	return -1;
d210 1
a210 2
	int	fd, mode32 = (int32_t) mode;
	int32_t	err;
d219 2
a220 3
	/* Write data to priv process.  */
	if (m_write_int32(m_state.s, MONITOR_GET_FD))
		goto errout;
d222 3
a224 2
	if (m_write_raw(m_state.s, pathreal, strlen(pathreal) + 1))
		goto errout;
d226 2
a227 8
	if (m_write_int32(m_state.s, flags))
		goto errout;

	if (m_write_int32(m_state.s, mode32))
		goto errout;

	if (m_read_int32(m_state.s, &err))
		goto errout;
d229 1
d231 1
a231 1
		errno = (int) err;
d234 1
a234 1
	/* Wait for response.  */
d241 1
a242 4

errout:
	log_error("monitor_open: problem talking to privileged process");
	return -1;
d314 1
a314 1
	int32_t	ret, err;
d316 2
a317 2
	if (m_write_int32(m_state.s, MONITOR_SETSOCKOPT))
		goto errout;
d321 4
a324 11
	if (m_write_int32(m_state.s, (int32_t)level))
		goto errout;
	if (m_write_int32(m_state.s, (int32_t)optname))
		goto errout;
	if (m_write_int32(m_state.s, (int32_t)optlen))
		goto errout;
	if (m_write_raw(m_state.s, (const char *)optval, (size_t)optlen))
		goto errout;

	if (m_read_int32(m_state.s, &err))
		goto errout;
d326 2
d329 2
a330 6
		errno = (int)err;

	if (m_read_int32(m_state.s, &ret))
		goto errout;

	return (int)ret;
d340 1
a340 1
	int32_t	ret, err;
d342 2
a343 2
	if (m_write_int32(m_state.s, MONITOR_BIND))
		goto errout;
d347 2
a348 7
	if (m_write_int32(m_state.s, (int32_t)namelen))
		goto errout;
	if (m_write_raw(m_state.s, (const char *)name, (size_t)namelen))
		goto errout;

	if (m_read_int32(m_state.s, &err))
		goto errout;
d350 2
d353 2
a354 6
		errno = (int)err;

	if (m_read_int32(m_state.s, &ret))
		goto errout;

	return (int)ret;
d456 4
a459 2
	if (m_write_int32(m_state.s, MONITOR_INIT_DONE))
		log_print("monitor_init_done: read/write error");
d505 1
a505 2
	int32_t	 msgcode;
	int	 status;
d533 1
a533 2
		if (m_read_int32(m_state.s, &msgcode))
			break;
a553 7
		case MONITOR_GET_SOCKET:
			LOG_DBG((LOG_MISC, 80,
			    "monitor_loop: MONITOR_GET_SOCKET"));
			m_priv_test_state(STATE_INIT);
			m_priv_getsocket(m_state.s);
			break;

d595 1
a595 1
	int32_t err;
d599 1
a599 3
	if (ui_socket >= 0)
		err = 0;
	else
d602 1
a602 2
	if (m_write_int32(s, err))
		goto errout;
d622 1
a622 2
	int fd;
	int32_t err;
a624 1

a626 2
	else
		err = 0;
d628 1
a628 2
	if (m_write_int32(s, err))
		goto errout;
d647 2
a648 2
	int32_t	v, err;
	int	flags;
d651 7
a657 18
	/*
	 * We expect the following data on the socket:
	 *  u_int32_t  pathlen
	 *  <variable> path
	 *  u_int32_t  flags
	 *  u_int32_t  mode
         */

	if (m_read_raw(s, path, MAXPATHLEN))
		goto errout;

	if (m_read_int32(s, &v))
		goto errout;
	flags = (int)v;

	if (m_read_int32(s, &v))
		goto errout;
	mode = (mode_t) v;
d663 1
a663 2
		err = 0;
		v = (int32_t)open(path, flags, mode);
d665 1
a665 1
			err = (int32_t)errno;
d668 1
a668 2
	if (m_write_int32(s, err))
		goto errout;
a682 38
m_priv_getsocket(int s)
{
	int	domain, type, protocol;
	int32_t	v, err;

	if (m_read_int32(s, &v))
		goto errout;
	domain = (int)v;

	if (m_read_int32(s, &v))
		goto errout;
	type = (int)v;

	if (m_read_int32(s, &v))
		goto errout;
	protocol = (int)v;

	err = 0;
	v = (int32_t)socket(domain, type, protocol);
	if (v < 0)
		err = (int32_t)errno;

	if (m_write_int32(s, err))
		goto errout;

	if (v > 0 && mm_send_fd(s, v)) {
		close(v);
		goto errout;
	}
	close(v);
	return;

errout:
	log_error("m_priv_getsocket: read/write operation failed");
}

/* Privileged: called by monitor_loop.  */
static void
d685 2
a686 1
	int		 sock, level, optname;
a688 1
	int32_t		 v, err;
d694 3
a696 8
	if (m_read_int32(s, &level))
		goto errout;

	if (m_read_int32(s, &optname))
		goto errout;

	if (m_read_int32(s, (int *)&optlen))
		goto errout;
d702 1
a702 2
	if (m_read_raw(s, optval, optlen))
		goto errout;
d708 1
a708 2
		err = 0;
		v = (int32_t)setsockopt(sock, level, optname, optval, optlen);
d710 1
a710 1
			err = (int32_t)errno;
d716 2
a717 5
	if (m_write_int32(s, err))
		goto errout;

	if (m_write_int32(s, v))
		goto errout;
d734 1
a734 1
	int		 sock;
a736 1
	int32_t          v, err;
d742 2
a743 4
	if (m_read_int32(s, &v))
		goto errout;
	namelen = (socklen_t) v;

d747 1
a747 3

	if (m_read_raw(s, (char *)name, (size_t)namelen))
		goto errout;
d753 1
a753 2
		err = 0;
		v = (int32_t)bind(sock, name, namelen);
d757 1
a757 1
			err = (int32_t)errno;
d764 2
a765 5
	if (m_write_int32(s, err))
		goto errout;

	if (m_write_int32(s, v))
		goto errout;
d782 6
a787 3
/* Write a 32-bit value to a socket.  */
int
m_write_int32(int s, int32_t value)
d789 16
a804 4
	u_int32_t	v;

	memcpy(&v, &value, sizeof v);
	return (write(s, &v, sizeof v) == -1);
d807 6
a812 37
/* Write a number of bytes of data to a socket.  */
int
m_write_raw(int s, const char *data, size_t dlen)
{
	if (m_write_int32(s, (int32_t) dlen))
		return 1;
	return (write(s, data, dlen) == -1);
}

int
m_read_int32(int s, int32_t *value)
{
	u_int32_t	v;

	if (read(s, &v, sizeof v) != sizeof v)
		return 1;
	memcpy(value, &v, sizeof v);
	return 0;
}

int
m_read_raw(int s, char *data, size_t maxlen)
{
	u_int32_t	v;
	int		r;

	if (m_read_int32(s, &v))
		return 1;
	if (v > maxlen)
		return 1;
	r = read(s, data, v);
	return (r == -1);
}

/* Drain all available input on a socket.  */
void
m_flush(int s)
d814 2
a815 2
	u_int8_t	tmp;
	int             one = 1;
d817 12
a828 3
	ioctl(s, FIONBIO, &one);/* Non-blocking */
	while (read(s, &tmp, 1) > 0);
	ioctl(s, FIONBIO, 0);	/* Blocking */
@


1.48
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.47 2005/05/23 22:33:32 ho Exp $	 */
d177 1
a177 1
	if (err != 0) {
a179 2
		exit(1);
	}
@


1.47
log
@endpwent() not needed here, pointed out by theo.
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.46 2005/05/23 22:21:56 ho Exp $	 */
d117 1
a117 1
		log_fatal("monitor_init: for of unprivileged child failed");
@


1.46
log
@endpwent() after last use. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.45 2005/05/10 11:12:50 hshoexer Exp $	 */
a111 1
	endpwent();
@


1.45
log
@no need to use select()

ok moritz cloder
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.44 2005/05/05 09:54:37 hshoexer Exp $	 */
d111 1
a112 1
	strlcpy(m_state.root, pw->pw_dir, sizeof m_state.root);
@


1.44
log
@remove a LOG_DBG, suggested by moritz
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.43 2005/05/05 09:48:02 hshoexer Exp $	 */
d163 1
a524 1
/* Help functions for monitor_loop().  */
a546 2
	fd_set	*fds;
	size_t	 fdsn;
d548 1
a548 1
	int	 status, n, maxfd;
a552 11
	maxfd = m_state.s + 1;

	fdsn = howmany(maxfd, NFDBITS) * sizeof(fd_mask);
	fds = (fd_set *)malloc(fdsn);
	if (!fds) {
		kill(m_state.pid, SIGTERM);
		log_fatal("monitor_loop: malloc (%lu) failed",
		    (unsigned long)fdsn);
		return;
	}

d576 2
a577 2
		bzero(fds, fdsn);
		FD_SET(m_state.s, fds);
d579 4
a582 17
		n = select(maxfd, fds, NULL, NULL, NULL);
		if (n <= 0) {
			if (n && errno != EINTR) {
				log_error("select");
				sleep(1);
			}
			continue;
		}
		if (FD_ISSET(m_state.s, fds)) {
			if (m_read_int32(m_state.s, &msgcode)) {
				m_flush(m_state.s);
				continue;
			}
			switch (msgcode) {
			case MONITOR_GET_FD:
				m_priv_getfd(m_state.s);
				break;
d584 6
a589 6
			case MONITOR_UI_INIT:
				LOG_DBG((LOG_MISC, 80,
				    "monitor_loop: MONITOR_UI_INIT"));
				m_priv_test_state(STATE_INIT);
				m_priv_ui_init(m_state.s);
				break;
d591 6
a596 6
			case MONITOR_PFKEY_OPEN:
				LOG_DBG((LOG_MISC, 80,
				    "monitor_loop: MONITOR_PFKEY_OPEN"));
				m_priv_test_state(STATE_INIT);
				m_priv_pfkey_open(m_state.s);
				break;
d598 6
a603 6
			case MONITOR_GET_SOCKET:
				LOG_DBG((LOG_MISC, 80,
				    "monitor_loop: MONITOR_GET_SOCKET"));
				m_priv_test_state(STATE_INIT);
				m_priv_getsocket(m_state.s);
				break;
d605 6
a610 6
			case MONITOR_SETSOCKOPT:
				LOG_DBG((LOG_MISC, 80,
				    "monitor_loop: MONITOR_SETSOCKOPT"));
				m_priv_test_state(STATE_INIT);
				m_priv_setsockopt(m_state.s);
				break;
d612 6
a617 6
			case MONITOR_BIND:
				LOG_DBG((LOG_MISC, 80,
				    "monitor_loop: MONITOR_BIND"));
				m_priv_test_state(STATE_INIT);
				m_priv_bind(m_state.s);
				break;
d619 6
a624 6
			case MONITOR_INIT_DONE:
				LOG_DBG((LOG_MISC, 80,
				    "monitor_loop: MONITOR_INIT_DONE"));
				m_priv_test_state(STATE_INIT);
				m_priv_increase_state(STATE_RUNNING);
				break;
d626 5
a630 5
			case MONITOR_SHUTDOWN:
				LOG_DBG((LOG_MISC, 80,
				    "monitor_loop: MONITOR_SHUTDOWN"));
				m_priv_increase_state(STATE_QUIT);
				break;
d632 3
a634 4
			default:
				log_print("monitor_loop: got unknown code %d",
				    msgcode);
			}
a637 1
	free(fds);
@


1.43
log
@more cleanup:  use log_fatalx(), nicer handling of the socketpair, use
setre[sg]id.

ok moritz djm
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.42 2005/05/03 14:03:11 moritz Exp $	 */
a115 3

	LOG_DBG((LOG_SYSDEP, 30, "monitor_init: pid %d my fd %d", m_state.pid,
	    m_state.s));
@


1.42
log
@Remove SIGUSR2-related stuff as suggested by ho@@.
SA rehashing won't happen anytime soon. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.41 2005/05/03 13:09:45 moritz Exp $	 */
d109 1
a109 1
		log_fatal("monitor_init: getpwnam(\"%s\") failed",
d112 1
a115 2
	m_state.s = p[m_state.pid ? 1 : 0];
	strlcpy(m_state.root, pw->pw_dir, sizeof m_state.root);
d120 4
a123 2
	/* The child process should drop privileges now.  */
	if (!m_state.pid) {
d125 1
d129 7
a135 15
		if (setgroups(1, &pw->pw_gid) == -1)
			log_fatal("monitor_init: setgroups(%d) failed",
			    pw->pw_gid);
		if (setegid(pw->pw_gid) == -1)
			log_fatal("monitor_init: setegid(%d) failed",
			    pw->pw_gid);
		if (setgid(pw->pw_gid) == -1)
			log_fatal("monitor_init: setgid(%d) failed",
			    pw->pw_gid);
		if (seteuid(pw->pw_uid) == -1)
			log_fatal("monitor_init: seteuid(%d) failed",
			    pw->pw_uid);
		if (setuid(pw->pw_uid) == -1)
			log_fatal("monitor_init: setuid(%d) failed",
			    pw->pw_uid);
d140 1
d142 3
@


1.41
log
@fix signal race, when child dies before the monitor
sets it's signal handlers. ok hshoexer@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.40 2005/04/19 15:46:49 hshoexer Exp $	 */
a526 1
	signal(SIGUSR2, sig_pass_to_chld);
@


1.40
log
@missing endpwent(), change more carefully to _isakmpd privsep user

ok moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.39 2005/04/08 23:15:26 hshoexer Exp $	 */
d65 2
d87 4
d113 1
d123 1
d512 18
a570 7
	/* If the child dies, we should shutdown also.  */
	signal(SIGCHLD, monitor_got_sigchld);

	/* SIGHUP, SIGUSR1 and SIGUSR2 will be forwarded to child. */
	signal(SIGHUP, sig_pass_to_chld);
	signal(SIGUSR1, sig_pass_to_chld);
	signal(SIGUSR2, sig_pass_to_chld);
@


1.39
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.38 2005/04/08 17:15:01 deraadt Exp $	 */
d105 1
d119 7
a125 1
		if (setgid(pw->pw_gid) != 0)
d128 4
a131 2

		if (setuid(pw->pw_uid) != 0)
@


1.38
log
@keynote and policy always compiled in
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.37 2005/04/04 19:31:11 deraadt Exp $	 */
a46 2
#include "sysdep.h"

d1060 3
a1062 3
	if (sysdep_sa_len((struct sockaddr *)sa) != salen) {
		log_print("Length mismatch: %d %d",
		  (int)sysdep_sa_len((struct sockaddr *)sa), (int)salen);
@


1.37
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.36 2005/03/11 12:39:55 hshoexer Exp $	 */
a43 1
#if defined (USE_POLICY)
a45 1
#endif
@


1.36
log
@simplify monitor main loop

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.35 2005/03/03 22:05:58 moritz Exp $	 */
a183 1
	return;
a492 2

	return;
d552 1
a552 1
	         */
a679 1
	return;
a708 1
	return;
a760 1
	return;
a798 1
	return;
a857 1
	return;
a914 1
	return;
a1116 1
	return;
@


1.35
log
@fix typo in log msg.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.34 2005/02/27 13:12:12 hshoexer Exp $	 */
d63 1
a63 1
}               m_state;
a135 1

d527 1
d578 2
a579 2
		if (n == -1) {
			if (errno != EINTR) {
d583 6
a588 73
		} else if (n)
			if (FD_ISSET(m_state.s, fds)) {
				int32_t	msgcode;
				if (m_read_int32(m_state.s, &msgcode))
					m_flush(m_state.s);
				else
					switch (msgcode) {
					case MONITOR_GET_FD:
						m_priv_getfd(m_state.s);
						break;

					case MONITOR_UI_INIT:
						LOG_DBG((LOG_MISC, 80,
						    "monitor_loop: "
						    "MONITOR_UI_INIT"));
						m_priv_test_state(STATE_INIT);
						m_priv_ui_init(m_state.s);
						break;

					case MONITOR_PFKEY_OPEN:
						LOG_DBG((LOG_MISC, 80,
						    "monitor_loop: "
						    "MONITOR_PFKEY_OPEN"));
						m_priv_test_state(STATE_INIT);
						m_priv_pfkey_open(m_state.s);
						break;

					case MONITOR_GET_SOCKET:
						LOG_DBG((LOG_MISC, 80,
						    "monitor_loop: "
						    "MONITOR_GET_SOCKET"));
						m_priv_test_state(STATE_INIT);
						m_priv_getsocket(m_state.s);
						break;

					case MONITOR_SETSOCKOPT:
						LOG_DBG((LOG_MISC, 80,
						    "monitor_loop: "
						    "MONITOR_SETSOCKOPT"));
						m_priv_test_state(STATE_INIT);
						m_priv_setsockopt(m_state.s);
						break;

					case MONITOR_BIND:
						LOG_DBG((LOG_MISC, 80,
						    "monitor_loop: "
						    "MONITOR_BIND"));
						m_priv_test_state(STATE_INIT);
						m_priv_bind(m_state.s);
						break;

					case MONITOR_INIT_DONE:
						LOG_DBG((LOG_MISC, 80,
						    "monitor_loop: "
						    "MONITOR_INIT_DONE"));
						m_priv_test_state(STATE_INIT);
						m_priv_increase_state(
						    STATE_RUNNING);
						break;

					case MONITOR_SHUTDOWN:
						LOG_DBG((LOG_MISC, 80,
						    "monitor_loop: "
						    "MONITOR_SHUTDOWN"));
						m_priv_increase_state(
						    STATE_QUIT);
						break;

					default:
						log_print("monitor_loop: "
						    "got unknown code %d",
						    msgcode);
					}
d590 58
@


1.34
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.33 2004/11/08 12:40:19 hshoexer Exp $	 */
d1121 1
a1121 1
		log_print("m_priv_increase_state: attempt to decrase state "
@


1.33
log
@rename char array realpath to pathreal to avoid naming conflict with
realpath(3); makes lint a bit happier

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.32 2004/11/08 12:34:00 hshoexer Exp $	 */
d100 1
a100 1
	memset(&m_state, 0, sizeof m_state);
d574 1
a574 1
		memset(fds, 0, fdsn);
@


1.32
log
@more monitor cleanup:
remove dead code, some debug messages, prototype monitor_close() to void.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.31 2004/11/08 12:23:31 hshoexer Exp $	 */
d224 1
a224 1
	char	realpath[MAXPATHLEN];
d227 1
a227 1
		strlcpy(realpath, path, sizeof realpath);
d229 1
a229 1
		snprintf(realpath, sizeof realpath, "%s/%s", m_state.root,
d236 1
a236 1
	if (m_write_raw(m_state.s, realpath, strlen(realpath) + 1))
@


1.31
log
@no const for sysdep_sa_len (not yet), slipped in during previous commit...
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.30 2004/11/08 12:11:00 hshoexer Exp $	 */
a331 39
monitor_socket(int domain, int type, int protocol)
{
	int	s;
	int32_t	err;

	if (m_write_int32(m_state.s, MONITOR_GET_SOCKET))
		goto errout;

	if (m_write_int32(m_state.s, (int32_t)domain))
		goto errout;

	if (m_write_int32(m_state.s, (int32_t)type))
		goto errout;

	if (m_write_int32(m_state.s, (int32_t)protocol))
		goto errout;

	if (m_read_int32(m_state.s, &err))
		goto errout;

	if (err != 0) {
		errno = (int)err;
		return -1;
	}
	/* Read result.  */
	s = mm_receive_fd(m_state.s);
	if (s < 0) {
		log_error("monitor_socket: mm_receive_fd () failed: %s",
		    strerror(errno));
		return -1;
	}
	return s;

errout:
	log_error("monitor_socket: problem talking to privileged process");
	return -1;
}

int
d483 1
a483 1
int
a487 2

	return 0;
d596 2
a597 2
						    "%s: MONITOR_UI_INIT",
						    __func__));
d604 2
a605 2
						    "%s: MONITOR_PFKEY_OPEN",
						    __func__));
d612 2
a613 2
						    "%s: MONITOR_GET_SOCKET",
						    __func__));
d620 2
a621 2
						    "%s: MONITOR_SETSOCKOPT",
						    __func__));
d628 2
a629 2
						    "%s: MONITOR_BIND",
						    __func__));
d636 2
a637 2
						    "%s: MONITOR_INIT_DONE",
						    __func__));
d645 2
a646 2
						    "%s: MONITOR_SHUTDOWN",
						    __func__));
@


1.30
log
@monitor cleanup: honor const, added missing inlcude, missing typecast (makes
lint happy)

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.29 2004/08/12 11:21:07 hshoexer Exp $	 */
d1123 1
a1123 1
	if (sysdep_sa_len((const struct sockaddr *)sa) != salen) {
d1125 1
a1125 1
		  (int)sysdep_sa_len((const struct sockaddr *)sa), (int)salen);
@


1.29
log
@Fix compiler warning on alpha.
Noted by and ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.28 2004/08/08 19:11:06 deraadt Exp $	 */
d34 2
d71 1
a71 1
int             m_write_raw(int, char *, size_t);
d387 1
a387 1
	if (m_write_raw(m_state.s, (char *)optval, (size_t)optlen))
d418 1
a418 1
	if (m_write_raw(m_state.s, (char *)name, (size_t)namelen))
d545 1
d877 1
a877 1
	if (m_read_int32(s, &optlen))
d992 1
a992 1
m_write_raw(int s, char *data, size_t dlen)
d1123 1
a1123 1
	if (sysdep_sa_len((struct sockaddr *)sa) != salen) {
d1125 1
a1125 1
		  (int)sysdep_sa_len((struct sockaddr *)sa), (int)salen);
@


1.28
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.27 2004/06/26 06:07:03 hshoexer Exp $	 */
d1172 1
a1172 1
		    cur_state, state);
@


1.27
log
@Narrow down privsep interface.  Move pf_key_v2_open() to monitor.

Work in progress.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.26 2004/06/25 00:58:39 hshoexer Exp $	 */
d140 1
a140 1
		kill(getpid(), SIGSTOP); 	/* Wait here for SIGCONT.  */
@


1.26
log
@Narrow down privsep interface.  Remove ui_init to monitor. So we can get rid of
monitor_mkfifo.

Work in progress.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.25 2004/06/24 17:02:48 hshoexer Exp $	 */
d55 1
d85 1
d187 31
d640 8
d730 30
@


1.25
log
@Remove some unused code.
Fix handling of sigchild.  Now it's possible to sigstop/sigcont isakmpd
correclty.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.24 2004/06/21 18:34:11 ho Exp $	 */
d53 1
a65 2
extern char    *ui_fifo;

a76 1
static void     m_priv_mkfifo(int);
d83 2
d146 38
a401 42
int
monitor_mkfifo(const char *path, mode_t mode)
{
	int32_t	ret, err;
	char	realpath[MAXPATHLEN];

	/* Only the child process is supposed to run this.  */
	if (m_state.pid)
		log_fatal("[priv] bad call to monitor_mkfifo");

	if (path[0] == '/')
		strlcpy(realpath, path, sizeof realpath);
	else
		snprintf(realpath, sizeof realpath, "%s/%s", m_state.root,
		    path);

	if (m_write_int32(m_state.s, MONITOR_MKFIFO))
		goto errout;

	if (m_write_raw(m_state.s, realpath, strlen(realpath) + 1))
		goto errout;

	ret = (int32_t)mode;
	if (m_write_int32(m_state.s, ret))
		goto errout;

	if (m_read_int32(m_state.s, &err))
		goto errout;

	if (err != 0)
		errno = (int)err;

	if (m_read_int32(m_state.s, &ret))
		goto errout;

	return (int)ret;

errout:
	log_print("monitor_mkfifo: read/write error");
	return -1;
}

d599 8
a630 8
					case MONITOR_MKFIFO:
						LOG_DBG((LOG_MISC, 80,
						    "%s: MONITOR_MKFIFO",
						    __func__));
						m_priv_test_state(STATE_INIT);
						m_priv_mkfifo(m_state.s);
						break;

d660 32
a898 48
	return;
}

/* Privileged: called by monitor_loop.  */
static void
m_priv_mkfifo(int s)
{
	char	path[MAXPATHLEN];
	mode_t	mode;
	int32_t	v, err;

	if (m_read_raw(s, path, MAXPATHLEN))
		goto errout;

	if (m_read_int32(s, &v))
		goto errout;
	mode = (mode_t) v;

	/*
	 * ui_fifo is set before creation of the unpriv'ed child.  So path
	 * should exactly match ui_fifo.  It's also restricted to /var/run.
	 */
	if (m_priv_local_sanitize_path(path, sizeof path, O_RDWR) != 0
	    || strncmp(ui_fifo, path, strlen(ui_fifo))) {
		err = EACCES;
		v = -1;
	} else {
		unlink(path);	/* XXX See ui.c:ui_init() */

		err = 0;
		v = (int32_t)mkfifo(path, mode);
		if (v) {
			log_error("m_priv_mkfifo: mkfifo(\"%s\", %o) failed",
			    path, mode);
			err = (int32_t)errno;
		}
	}

	if (m_write_int32(s, err))
		goto errout;

	if (m_write_int32(s, v))
		goto errout;

	return;

errout:
	log_print("m_priv_mkfifo: read/write error");
@


1.24
log
@Strip away umask bits in monitor_fopen(). hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.23 2004/06/20 15:03:35 ho Exp $	 */
a61 1
volatile sig_atomic_t monitor_sighupped = 0;
d537 1
a537 1
	int	 n, maxfd;
d565 3
a567 15
		if (sigtermed || sigchlded) {
			if (sigtermed)
				kill(m_state.pid, SIGTERM);

			if (sigchlded) {
				do {
					pid = waitpid(m_state.pid, &n,
					    WNOHANG);
				}
				while (pid == -1 && errno == EINTR);

				if (pid == m_state.pid && (WIFEXITED(n) ||
				    WIFSIGNALED(n)))
					m_priv_increase_state(STATE_QUIT);
			}
d570 11
a580 3
		if (monitor_sighupped) {
			kill(m_state.pid, SIGHUP);
			monitor_sighupped = 0;
d582 1
@


1.23
log
@To make debugging the unprivileged child process easier, make 'isakmpd -dd'
pause just after privsep; print the PIDs and wait for SIGCONT.
hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.22 2004/06/14 09:55:41 ho Exp $	 */
d198 2
a199 1
	int	 fd, flags = 0, mask, saved_errno;
d221 2
d224 1
@


1.22
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.21 2004/05/23 18:17:56 hshoexer Exp $	 */
d92 1
a92 1
monitor_init(void)
d133 11
d529 1
a529 1
monitor_loop(int debugging)
d536 1
a536 1
	if (!debugging)
@


1.21
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.20 2004/05/10 18:34:15 deraadt Exp $	 */
d557 2
a558 1
					pid = waitpid(m_state.pid, &n, WNOHANG);
d593 3
a595 1
						LOG_DBG((LOG_MISC, 80, "%s: MONITOR_GET_SOCKET", __func__));
d601 3
a603 1
						LOG_DBG((LOG_MISC, 80, "%s: MONITOR_SETSOCKOPT", __func__));
d609 3
a611 1
						LOG_DBG((LOG_MISC, 80, "%s: MONITOR_BIND", __func__));
d617 3
a619 1
						LOG_DBG((LOG_MISC, 80, "%s: MONITOR_MKFIFO", __func__));
d625 3
a627 1
						LOG_DBG((LOG_MISC, 80, "%s: MONITOR_INIT_DONE", __func__));
d629 2
a630 1
						m_priv_increase_state(STATE_RUNNING);
d634 5
a638 2
						LOG_DBG((LOG_MISC, 80, "%s: MONITOR_SHUTDOWN", __func__));
						m_priv_increase_state(STATE_QUIT);
d642 3
a644 1
						log_print("monitor_loop: got unknown code %d", msgcode);
d1040 2
a1041 1
		log_print("m_priv_check_sockopt: Illegal option name %d", name);
@


1.20
log
@64bit gcc saw missing cast
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.19 2004/04/15 18:39:26 deraadt Exp $	 */
d120 2
a121 1
			log_fatal("monitor_init: setgid(%d) failed", pw->pw_gid);
d124 2
a125 1
			log_fatal("monitor_init: setuid(%d) failed", pw->pw_uid);
d139 3
a141 3
	int             fd, mode32 = (int32_t) mode;
	int32_t         err;
	char            realpath[MAXPATHLEN];
d146 2
a147 1
		snprintf(realpath, sizeof realpath, "%s/%s", m_state.root, path);
d186 2
a187 2
	FILE           *fp;
	int             fd, flags = 0, mask, saved_errno;
d198 2
a199 1
		flags = (mode[1] == '+' ? O_RDWR : O_WRONLY) | O_CREAT | O_TRUNC;
d202 2
a203 1
		flags = (mode[1] == '+' ? O_RDWR : O_WRONLY) | O_CREAT | O_APPEND;
d247 2
a248 2
	int             s;
	int32_t         err;
d253 1
a253 1
	if (m_write_int32(m_state.s, (int32_t) domain))
d256 1
a256 1
	if (m_write_int32(m_state.s, (int32_t) type))
d259 1
a259 1
	if (m_write_int32(m_state.s, (int32_t) protocol))
d266 1
a266 1
		errno = (int) err;
d273 1
a273 1
			  strerror(errno));
d285 1
a285 1
		   socklen_t optlen)
d287 1
a287 1
	int32_t         ret, err;
d294 1
a294 1
	if (m_write_int32(m_state.s, (int32_t) level))
d296 1
a296 1
	if (m_write_int32(m_state.s, (int32_t) optname))
d298 1
a298 1
	if (m_write_int32(m_state.s, (int32_t) optlen))
d300 1
a300 1
	if (m_write_raw(m_state.s, (char *) optval, (size_t) optlen))
d307 1
a307 1
		errno = (int) err;
d312 1
a312 1
	return (int) ret;
d322 1
a322 1
	int32_t         ret, err;
d329 1
a329 1
	if (m_write_int32(m_state.s, (int32_t) namelen))
d331 1
a331 1
	if (m_write_raw(m_state.s, (char *) name, (size_t) namelen))
d338 1
a338 1
		errno = (int) err;
d343 1
a343 1
	return (int) ret;
d353 2
a354 2
	int32_t         ret, err;
	char            realpath[MAXPATHLEN];
d363 2
a364 1
		snprintf(realpath, sizeof realpath, "%s/%s", m_state.root, path);
d372 1
a372 1
	ret = (int32_t) mode;
d380 1
a380 1
		errno = (int) err;
d385 1
a385 1
	return (int) ret;
d410 1
a410 1
		(void) close(fd);
d414 1
a414 1
		(void) close(fd);
d424 1
a424 1
		(void) close(fd);
d430 1
a430 1
		(void) close(fd);
d435 1
a435 1
	(void) close(fd);
d438 1
a438 1
		dp = (struct dirent *) cp;
d459 1
a459 1
		dp = (struct dirent *) cp;
d509 1
a509 1
	int             oerrno = errno;
d520 4
a523 4
	pid_t           pid;
	fd_set         *fds;
	size_t          fdsn;
	int             n, maxfd;
d531 1
a531 1
	fds = (fd_set *) malloc(fdsn);
d548 2
a549 2
		 * Currently, there is no need for us to hang around if the child
		 * is in the process of shutting down.
d582 1
a582 1
				int32_t         msgcode;
d640 4
a643 4
	char            path[MAXPATHLEN];
	int32_t         v, err;
	int             flags;
	mode_t          mode;
d658 1
a658 1
	flags = (int) v;
d669 1
a669 1
		v = (int32_t) open(path, flags, mode);
d671 1
a671 1
			err = (int32_t) errno;
d693 2
a694 2
	int             domain, type, protocol;
	int32_t         v, err;
d698 1
a698 1
	domain = (int) v;
d702 1
a702 1
	type = (int) v;
d706 1
a706 1
	protocol = (int) v;
d709 1
a709 1
	v = (int32_t) socket(domain, type, protocol);
d711 1
a711 1
		err = (int32_t) errno;
d732 4
a735 4
	int             sock, level, optname;
	char           *optval = 0;
	socklen_t       optlen;
	int32_t         v, err;
d750 1
a750 1
	optval = (char *) malloc(optlen);
d762 1
a762 1
		v = (int32_t) setsockopt(sock, level, optname, optval, optlen);
d764 1
a764 1
			err = (int32_t) errno;
d792 1
a792 1
	int             sock;
d794 2
a795 2
	socklen_t       namelen;
	int32_t         v, err;
d805 1
a805 1
	name = (struct sockaddr *) malloc(namelen);
d809 1
a809 1
	if (m_read_raw(s, (char *) name, (size_t) namelen))
d817 1
a817 1
		v = (int32_t) bind(sock, name, namelen);
d820 2
a821 2
				  sock, name, namelen, v);
			err = (int32_t) errno;
d850 3
a852 3
	char            path[MAXPATHLEN];
	mode_t          mode;
	int32_t         v, err;
d865 2
a866 2
	if (m_priv_local_sanitize_path(path, sizeof path, O_RDWR) != 0 ||
	    strncmp(ui_fifo, path, strlen(ui_fifo))) {
d873 1
a873 1
		v = (int32_t) mkfifo(path, mode);
d875 3
a877 2
			log_error("m_priv_mkfifo: mkfifo(\"%s\", %o) failed", path, mode);
			err = (int32_t) errno;
d902 2
a903 1
	u_int32_t       v;
d920 2
a921 1
	u_int32_t       v;
d931 3
a933 2
	u_int32_t       v;
	int             r;
d946 1
a946 1
	u_int8_t        tmp;
d958 1
a958 1
	char           *p;
d970 1
a970 1
	for (p = path; *p && (p - path) < (int) pmax; p++)
d1040 1
a1040 1
	if (sysdep_sa_len((struct sockaddr *) sa) != salen) {
d1042 1
a1042 1
		  (int) sysdep_sa_len((struct sockaddr *) sa), (int) salen);
d1051 1
a1051 1
		port = ((const struct sockaddr_in *) sa)->sin_port;
d1058 1
a1058 1
		port = ((const struct sockaddr_in6 *) sa)->sin6_port;
d1079 2
a1080 2
		log_print("m_priv_increase_state: attempt to decrase state or match "
			  "current state");
d1082 2
a1083 1
		log_print("m_priv_increase_state: attempt to switch to invalid state");
d1091 2
a1092 1
		log_print("m_priv_test_state: Illegal state: %d != %d", cur_state, state);
@


1.19
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: monitor.c,v 1.18 2004/04/07 22:45:49 ho Exp $	 */
d528 2
a529 1
		log_fatal("monitor_loop: malloc (%u) failed", fdsn);
@


1.18
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.17 2004/03/31 10:53:10 ho Exp $	*/
d55 5
a59 6
struct monitor_state
{
  pid_t	pid;
  int	s;
  char	root[MAXPATHLEN];
} m_state;
d66 1
a66 1
extern char *ui_fifo;
d69 16
a84 16
int m_write_int32 (int, int32_t);
int m_write_raw (int, char *, size_t);
int m_read_int32 (int, int32_t *);
int m_read_raw (int, char *, size_t);
void m_flush (int);

static void m_priv_getfd (int);
static void m_priv_getsocket (int);
static void m_priv_setsockopt (int);
static void m_priv_bind (int);
static void m_priv_mkfifo (int);
static int  m_priv_local_sanitize_path (char *, size_t, int);
static int  m_priv_check_sockopt (int, int);
static int  m_priv_check_bind (const struct sockaddr *, socklen_t);
static void m_priv_increase_state (int);
static void m_priv_test_state (int);
d92 1
a92 1
monitor_init (void)
d94 4
a97 3
  struct passwd *pw;
  int p[2];
  memset (&m_state, 0, sizeof m_state);
d99 2
a100 2
  if (socketpair (AF_UNIX, SOCK_STREAM, PF_UNSPEC, p) != 0)
    log_fatal ("monitor_init: socketpair() failed");
d102 4
a105 4
  pw = getpwnam (ISAKMPD_PRIVSEP_USER);
  if (pw == NULL)
    log_fatal ("monitor_init: getpwnam(\"%s\") failed",
	       ISAKMPD_PRIVSEP_USER);
d107 3
a109 3
  m_state.pid = fork ();
  m_state.s = p[m_state.pid ? 1 : 0];
  strlcpy (m_state.root, pw->pw_dir, sizeof m_state.root);
d111 1
a111 1
  LOG_DBG ((LOG_SYSDEP, 30, "monitor_init: pid %d my fd %d", m_state.pid,
d114 16
a129 19
  /* The child process should drop privileges now.  */
  if (!m_state.pid)
    {
      if (chroot (pw->pw_dir) != 0 || chdir("/") != 0)
	log_fatal ("monitor_init: chroot failed");

      if (setgid (pw->pw_gid) != 0)
	log_fatal ("monitor_init: setgid(%d) failed", pw->pw_gid);

      if (setuid (pw->pw_uid) != 0)
	log_fatal ("monitor_init: setuid(%d) failed", pw->pw_uid);

      LOG_DBG ((LOG_MISC, 10,
		"monitor_init: privileges dropped for child process"));
    }
  else
    {
      setproctitle ("monitor [priv]");
    }
d131 1
a131 1
  return m_state.pid;
d135 1
a135 1
monitor_open (const char *path, int flags, mode_t mode)
d137 41
a177 45
  int fd, mode32 = (int32_t) mode;
  int32_t err;
  char realpath[MAXPATHLEN];

  if (path[0] == '/')
    strlcpy (realpath, path, sizeof realpath);
  else
    snprintf (realpath, sizeof realpath, "%s/%s", m_state.root, path);

  /* Write data to priv process.  */
  if (m_write_int32 (m_state.s, MONITOR_GET_FD))
    goto errout;

  if (m_write_raw (m_state.s, realpath, strlen (realpath) + 1))
    goto errout;

  if (m_write_int32 (m_state.s, flags))
    goto errout;

  if (m_write_int32 (m_state.s, mode32))
    goto errout;

  if (m_read_int32 (m_state.s, &err))
    goto errout;

  if (err != 0)
    {
      errno = (int)err;
      return -1;
    }

  /* Wait for response.  */
  fd = mm_receive_fd (m_state.s);
  if (fd < 0)
    {
      log_error ("monitor_open: mm_receive_fd () failed: %s",
	         strerror (errno));
      return -1;
    }

  return fd;

 errout:
  log_error ("monitor_open: problem talking to privileged process");
  return -1;
d181 1
a181 1
monitor_fopen (const char *path, const char *mode)
d183 20
a202 2
  FILE *fp;
  int fd, flags = 0, mask, saved_errno;
d204 1
a204 35
  /* Only the child process is supposed to run this.  */
  if (m_state.pid)
    log_fatal ("[priv] bad call to monitor_fopen");

  switch (mode[0])
    {
    case 'r':
      flags = (mode[1] == '+' ? O_RDWR : O_RDONLY);
      break;
    case 'w':
      flags = (mode[1] == '+' ? O_RDWR : O_WRONLY) | O_CREAT | O_TRUNC;
      break;
    case 'a':
      flags = (mode[1] == '+' ? O_RDWR : O_WRONLY) | O_CREAT | O_APPEND;
      break;
    default:
      log_fatal ("monitor_fopen: bad call");
    }

  mask = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;

  fd = monitor_open (path, flags, mask);
  if (fd < 0)
    return NULL;

  /* Got the fd, attach a FILE * to it.  */
  fp = fdopen (fd, mode);
  if (!fp)
    {
      log_error ("monitor_fopen: fdopen() failed");
      saved_errno = errno;
      close (fd);
      errno = saved_errno;
      return NULL;
    }
d206 14
a219 1
  return fp;
d223 1
a223 1
monitor_stat (const char *path, struct stat *sb)
d225 1
a225 1
  int fd, r, saved_errno;
d227 10
a236 10
  /* O_NONBLOCK is needed for stat'ing fifos. */
  fd = monitor_open (path, O_RDONLY | O_NONBLOCK, 0);
  if (fd < 0)
      return -1;

  r = fstat (fd, sb);
  saved_errno = errno;
  close (fd);
  errno = saved_errno;
  return r;
d240 1
a240 1
monitor_socket (int domain, int type, int protocol)
d242 5
a246 2
  int s;
  int32_t err;
d248 24
a271 2
  if (m_write_int32 (m_state.s, MONITOR_GET_SOCKET))
    goto errout;
d273 3
a275 32
  if (m_write_int32 (m_state.s, (int32_t)domain))
    goto errout;

  if (m_write_int32 (m_state.s, (int32_t)type))
    goto errout;

  if (m_write_int32 (m_state.s, (int32_t)protocol))
    goto errout;

  if (m_read_int32 (m_state.s, &err))
    goto errout;

  if (err != 0)
    {
      errno = (int)err;
      return -1;
    }

  /* Read result.  */
  s = mm_receive_fd (m_state.s);
  if (s < 0)
    {
      log_error ("monitor_socket: mm_receive_fd () failed: %s",
	         strerror (errno));
      return -1;
    }

  return s;

 errout:
  log_error ("monitor_socket: problem talking to privileged process");
  return -1;
d279 2
a280 2
monitor_setsockopt (int s, int level, int optname, const void *optval,
		    socklen_t optlen)
d282 1
a282 1
  int32_t ret, err;
d284 28
a311 28
  if (m_write_int32 (m_state.s, MONITOR_SETSOCKOPT))
    goto errout;
  if (mm_send_fd (m_state.s, s))
    goto errout;

  if (m_write_int32 (m_state.s, (int32_t)level))
    goto errout;
  if (m_write_int32 (m_state.s, (int32_t)optname))
    goto errout;
  if (m_write_int32 (m_state.s, (int32_t)optlen))
    goto errout;
  if (m_write_raw (m_state.s, (char *)optval, (size_t)optlen))
    goto errout;

  if (m_read_int32 (m_state.s, &err))
    goto errout;

  if (err != 0)
    errno = (int)err;

  if (m_read_int32 (m_state.s, &ret))
    goto errout;

  return (int)ret;

 errout:
  log_print ("monitor_setsockopt: read/write error");
  return -1;
d315 1
a315 1
monitor_bind (int s, const struct sockaddr *name, socklen_t namelen)
d317 1
a317 1
  int32_t ret, err;
d319 4
a322 4
  if (m_write_int32 (m_state.s, MONITOR_BIND))
    goto errout;
  if (mm_send_fd (m_state.s, s))
    goto errout;
d324 4
a327 4
  if (m_write_int32 (m_state.s, (int32_t)namelen))
    goto errout;
  if (m_write_raw (m_state.s, (char *)name, (size_t)namelen))
    goto errout;
d329 2
a330 2
  if (m_read_int32 (m_state.s, &err))
    goto errout;
d332 2
a333 2
  if (err != 0)
    errno = (int)err;
d335 2
a336 2
  if (m_read_int32 (m_state.s, &ret))
    goto errout;
d338 1
a338 1
  return (int)ret;
d340 3
a342 3
 errout:
  log_print ("monitor_bind: read/write error");
  return -1;
d346 1
a346 1
monitor_mkfifo (const char *path, mode_t mode)
d348 2
a349 2
  int32_t ret, err;
  char realpath[MAXPATHLEN];
d351 3
a353 3
  /* Only the child process is supposed to run this.  */
  if (m_state.pid)
    log_fatal ("[priv] bad call to monitor_mkfifo");
d355 4
a358 4
  if (path[0] == '/')
    strlcpy (realpath, path, sizeof realpath);
  else
    snprintf (realpath, sizeof realpath, "%s/%s", m_state.root, path);
d360 2
a361 2
  if (m_write_int32 (m_state.s, MONITOR_MKFIFO))
    goto errout;
d363 2
a364 2
  if (m_write_raw (m_state.s, realpath, strlen (realpath) + 1))
    goto errout;
d366 3
a368 3
  ret = (int32_t)mode;
  if (m_write_int32 (m_state.s, ret))
    goto errout;
d370 2
a371 2
  if (m_read_int32 (m_state.s, &err))
    goto errout;
d373 2
a374 2
  if (err != 0)
    errno = (int)err;
d376 2
a377 2
  if (m_read_int32 (m_state.s, &ret))
    goto errout;
d379 1
a379 1
  return (int)ret;
d381 3
a383 3
 errout:
  log_print ("monitor_mkfifo: read/write error");
  return -1;
d387 1
a387 1
monitor_opendir (const char *path)
d389 62
a450 83
  char *buf, *cp;
  size_t bufsize;
  int fd, nbytes, entries;
  long base;
  struct stat sb;
  struct dirent *dp;
  struct monitor_dirents *direntries;

  fd = monitor_open (path, 0, O_RDONLY);
  if (fd < 0)
    { 
      log_error ("monitor_opendir: opendir(\"%s\") failed", path);
      return NULL;
    }

  /* Now build a list with all dirents from fd. */
  if (fstat (fd, &sb) < 0)
    {
      (void)close (fd);
      return NULL;
    }

  if (!S_ISDIR (sb.st_mode))
    {
      (void)close (fd);
      errno = EACCES;
      return NULL;
    }

  bufsize = sb.st_size;
  if (bufsize < sb.st_blksize)
    bufsize = sb.st_blksize;

  buf = calloc (bufsize, sizeof (char));
  if (buf == NULL)
    {
      (void)close (fd);
      errno = EACCES;
      return NULL;
    }

  nbytes = getdirentries (fd, buf, bufsize, &base);
  if (nbytes <= 0)
    {
      (void)close (fd);
      free (buf);
      errno = EACCES;
      return NULL;
    }
  (void)close (fd);

  for (entries = 0, cp = buf; cp < buf + nbytes; )
    {
      dp = (struct dirent *)cp;
      cp += dp->d_reclen;
      entries++;
    }

  direntries = calloc (1, sizeof (struct monitor_dirents));
  if (direntries == NULL)
    {
      free (buf);
      errno = EACCES;
      return NULL;
    }

  direntries->dirents = calloc (entries + 1, sizeof (struct dirent *));
  if (direntries->dirents == NULL)
    {
      free (buf);
      free (direntries);
      errno = EACCES;
      return NULL;
    }
  direntries->current = 0;

  for (entries = 0, cp = buf; cp < buf + nbytes; )
    {
      dp = (struct dirent *)cp;
      direntries->dirents[entries++] = dp;
      cp += dp->d_reclen;
    }
  direntries->dirents[entries] = NULL;
d452 8
a459 1
  return direntries;
d463 1
a463 1
monitor_readdir (struct monitor_dirents *direntries)
d465 2
a466 2
  if (direntries->dirents[direntries->current] != NULL)
    return direntries->dirents[direntries->current++];
d468 1
a468 1
  return NULL;
d472 1
a472 1
monitor_closedir (struct monitor_dirents *direntries)
d474 2
a475 2
  free (direntries->dirents);
  free (direntries);
d477 1
a477 1
  return 0;
d481 1
a481 1
monitor_init_done (void)
d483 2
a484 2
  if (m_write_int32 (m_state.s, MONITOR_INIT_DONE))
    log_print ("monitor_init_done: read/write error");
d486 1
a486 1
  return;
d495 1
a495 1
monitor_got_sigchld (int sig)
d497 1
a497 1
  sigchlded = 1;
d503 1
a503 1
  int oerrno = errno;
d505 3
a507 3
  if (m_state.pid != -1)
    kill(m_state.pid, sig);
  errno = oerrno;
d512 1
a512 1
monitor_loop (int debugging)
d514 49
a562 43
  pid_t pid;
  fd_set *fds;
  size_t fdsn;
  int n, maxfd;

  if (!debugging)
    log_to (0);

  maxfd = m_state.s + 1;

  fdsn = howmany (maxfd, NFDBITS) * sizeof (fd_mask);
  fds = (fd_set *)malloc (fdsn);
  if (!fds)
    {
      kill (m_state.pid, SIGTERM);
      log_fatal ("monitor_loop: malloc (%u) failed", fdsn);
      return;
    }

  /* If the child dies, we should shutdown also.  */
  signal (SIGCHLD, monitor_got_sigchld);

  /* SIGHUP, SIGUSR1 and SIGUSR2 will be forwarded to child. */
  signal (SIGHUP, sig_pass_to_chld);
  signal (SIGUSR1, sig_pass_to_chld);
  signal (SIGUSR2, sig_pass_to_chld);

  while (cur_state < STATE_QUIT)
    {
      /*
       * Currently, there is no need for us to hang around if the child
       * is in the process of shutting down.
       */
      if (sigtermed || sigchlded)
	{
	  if (sigtermed)
	    kill (m_state.pid, SIGTERM);

	  if (sigchlded)
	    {
	      do
		{
		  pid = waitpid (m_state.pid, &n, WNOHANG);
d564 2
a565 1
	      while (pid == -1 && errno == EINTR);
d567 57
a623 78
	      if (pid == m_state.pid && (WIFEXITED (n) || WIFSIGNALED (n)))
		m_priv_increase_state (STATE_QUIT);
	    }

	  break;
	}

      if (monitor_sighupped)
	{
	  kill (m_state.pid, SIGHUP);
	  monitor_sighupped = 0;
	}

      memset (fds, 0, fdsn);
      FD_SET (m_state.s, fds);

      n = select (maxfd, fds, NULL, NULL, NULL);
      if (n == -1)
	{
	  if (errno != EINTR)
	    {
	      log_error ("select");
	      sleep (1);
	    }
	}
      else if (n)
	if (FD_ISSET (m_state.s, fds))
	  {
	    int32_t msgcode;
	    if (m_read_int32 (m_state.s, &msgcode))
	      m_flush (m_state.s);
	    else
	      switch (msgcode)
		{
		case MONITOR_GET_FD:
		  m_priv_getfd (m_state.s);
		  break;

		case MONITOR_GET_SOCKET:
		  LOG_DBG ((LOG_MISC, 80, "%s: MONITOR_GET_SOCKET", __func__));
		  m_priv_test_state (STATE_INIT);
		  m_priv_getsocket (m_state.s);
		  break;

		case MONITOR_SETSOCKOPT:
		  LOG_DBG ((LOG_MISC, 80, "%s: MONITOR_SETSOCKOPT", __func__));
		  m_priv_test_state (STATE_INIT);
		  m_priv_setsockopt (m_state.s);
		  break;

		case MONITOR_BIND:
		  LOG_DBG ((LOG_MISC, 80, "%s: MONITOR_BIND", __func__));
		  m_priv_test_state (STATE_INIT);
		  m_priv_bind (m_state.s);
		  break;

		case MONITOR_MKFIFO:
		  LOG_DBG ((LOG_MISC, 80, "%s: MONITOR_MKFIFO", __func__));
		  m_priv_test_state (STATE_INIT);
		  m_priv_mkfifo (m_state.s);
		  break;

		case MONITOR_INIT_DONE:
		  LOG_DBG ((LOG_MISC, 80, "%s: MONITOR_INIT_DONE", __func__));
		  m_priv_test_state (STATE_INIT);
		  m_priv_increase_state (STATE_RUNNING);
		  break;

		case MONITOR_SHUTDOWN:
		  LOG_DBG ((LOG_MISC, 80, "%s: MONITOR_SHUTDOWN", __func__));
		  m_priv_increase_state (STATE_QUIT);
		  break;

		default:
		  log_print ("monitor_loop: got unknown code %d", msgcode);
		}
	  }
    }
d625 2
a626 2
  free (fds);
  exit (0);
d631 1
a631 1
m_priv_getfd (int s)
d633 47
a679 51
  char path[MAXPATHLEN];
  int32_t v, err;
  int flags;
  mode_t mode;

  /*
   * We expect the following data on the socket:
   *  u_int32_t  pathlen
   *  <variable> path
   *  u_int32_t  flags
   *  u_int32_t  mode
   */

  if (m_read_raw (s, path, MAXPATHLEN))
    goto errout;

  if (m_read_int32 (s, &v))
    goto errout;
  flags = (int)v;

  if (m_read_int32 (s, &v))
    goto errout;
  mode = (mode_t)v;

  if (m_priv_local_sanitize_path (path, sizeof path, flags) != 0)
    {
      err = EACCES;
      v = -1;
    }
  else
    {
      err = 0;
      v = (int32_t)open (path, flags, mode);
      if (v < 0)
	err = (int32_t)errno;
    }

  if (m_write_int32 (s, err))
    goto errout;

  if (v > 0 && mm_send_fd (s, v))
    {
      close (v);
      goto errout;
    }
  close (v);
  return;

 errout:
  log_error ("m_priv_getfd: read/write operation failed");
  return;
d684 1
a684 1
m_priv_getsocket (int s)
d686 2
a687 2
  int domain, type, protocol;
  int32_t v, err;
d689 30
a718 31
  if (m_read_int32 (s, &v))
    goto errout;
  domain = (int)v;

  if (m_read_int32 (s, &v))
    goto errout;
  type = (int)v;

  if (m_read_int32 (s, &v))
    goto errout;
  protocol = (int)v;

  err = 0;
  v = (int32_t)socket (domain, type, protocol);
  if (v < 0)
    err = (int32_t)errno;

  if (m_write_int32 (s, err))
    goto errout;

  if (v > 0 && mm_send_fd (s, v))
    {
      close (v);
      goto errout;
    }
  close (v);
  return;

 errout:
  log_error ("m_priv_getsocket: read/write operation failed");
  return;
d723 1
a723 1
m_priv_setsockopt (int s)
d725 54
a778 57
  int sock, level, optname;
  char *optval = 0;
  socklen_t optlen;
  int32_t v, err;

  sock = mm_receive_fd (s);
  if (sock < 0)
    goto errout;

  if (m_read_int32 (s, &level))
    goto errout;

  if (m_read_int32 (s, &optname))
    goto errout;

  if (m_read_int32 (s, &optlen))
    goto errout;

  optval = (char *)malloc (optlen);
  if (!optval)
    goto errout;

  if (m_read_raw (s, optval, optlen))
    goto errout;

  if (m_priv_check_sockopt (level, optname) != 0)
    {
      err = EACCES;
      v = -1;
    }
  else
    {
      err = 0;
      v = (int32_t) setsockopt (sock, level, optname, optval, optlen);
      if (v < 0)
	err = (int32_t)errno;
    }

  close (sock);
  sock = -1;

  if (m_write_int32 (s, err))
    goto errout;

  if (m_write_int32 (s, v))
    goto errout;

  free (optval);
  return;

 errout:
  log_print ("m_priv_setsockopt: read/write error");
  if (optval)
    free (optval);
  if (sock >= 0)
    close (sock);
  return;
d783 1
a783 1
m_priv_bind (int s)
d785 52
a836 56
  int sock;
  struct sockaddr *name = 0;
  socklen_t namelen;
  int32_t v, err;

  sock = mm_receive_fd (s);
  if (sock < 0)
    goto errout;

  if (m_read_int32 (s, &v))
    goto errout;
  namelen = (socklen_t)v;

  name = (struct sockaddr *)malloc (namelen);
  if (!name)
    goto errout;

  if (m_read_raw (s, (char *)name, (size_t)namelen))
    goto errout;

  if (m_priv_check_bind (name, namelen) != 0)
    {
      err = EACCES;
      v = -1;
    }
  else
    {
      err = 0;
      v = (int32_t)bind (sock, name, namelen);
      if (v < 0)
      {
	log_error ("m_priv_bind: bind(%d,%p,%d) returned %d",
		   sock, name, namelen, v);
	err = (int32_t)errno;
      }
    }

  close (sock);
  sock = -1;

  if (m_write_int32 (s, err))
    goto errout;

  if (m_write_int32 (s, v))
    goto errout;

  free (name);
  return;

 errout:
  log_print ("m_priv_bind: read/write error");
  if (name)
    free (name);
  if (sock >= 0)
    close (sock);
  return;
d841 1
a841 1
m_priv_mkfifo (int s)
d843 41
a883 45
  char path[MAXPATHLEN];
  mode_t mode;
  int32_t v, err;

  if (m_read_raw (s, path, MAXPATHLEN))
    goto errout;

  if (m_read_int32 (s, &v))
    goto errout;
  mode = (mode_t)v;

  /* 
   * ui_fifo is set before creation of the unpriv'ed child.  So path should 
   * exactly match ui_fifo.  It's also restricted to /var/run.
   */
  if (m_priv_local_sanitize_path (path, sizeof path, O_RDWR) != 0 ||
      strncmp (ui_fifo, path, strlen (ui_fifo)))
    {
      err = EACCES;
      v = -1;
    }
  else
    {
      unlink (path); /* XXX See ui.c:ui_init() */

      err = 0;
      v = (int32_t)mkfifo (path, mode);
      if (v)
	{
	  log_error ("m_priv_mkfifo: mkfifo(\"%s\", %o) failed", path, mode);
	  err = (int32_t)errno;
	}
    }

  if (m_write_int32 (s, err))
    goto errout;

  if (m_write_int32 (s, v))
    goto errout;

  return;

 errout:
  log_print ("m_priv_mkfifo: read/write error");
  return;
d892 1
a892 1
m_write_int32 (int s, int32_t value)
d894 3
a896 3
  u_int32_t v;
  memcpy (&v, &value, sizeof v);
  return (write (s, &v, sizeof v) == -1);
d901 1
a901 1
m_write_raw (int s, char *data, size_t dlen)
d903 3
a905 3
  if (m_write_int32 (s, (int32_t)dlen))
    return 1;
  return (write (s, data, dlen) == -1);
d909 1
a909 1
m_read_int32 (int s, int32_t *value)
d911 5
a915 5
  u_int32_t v;
  if (read (s, &v, sizeof v) != sizeof v)
    return 1;
  memcpy (value, &v, sizeof v);
  return 0;
d919 1
a919 1
m_read_raw (int s, char *data, size_t maxlen)
d921 8
a928 8
  u_int32_t v;
  int r;
  if (m_read_int32 (s, &v))
    return 1;
  if (v > maxlen)
    return 1;
  r = read (s, data, v);
  return (r == -1);
d933 1
a933 1
m_flush (int s)
d935 2
a936 2
  u_int8_t tmp;
  int one = 1;
d938 3
a940 3
  ioctl (s, FIONBIO, &one);		/* Non-blocking */
  while (read (s, &tmp, 1) > 0) ;
  ioctl (s, FIONBIO, 0);		/* Blocking */
d945 1
a945 1
m_priv_local_sanitize_path (char *path, size_t pmax, int flags)
d947 1
a947 1
  char *p;
d949 30
a978 32
  /*
   * We only permit paths starting with
   *  /etc/isakmpd/	(read only)
   *  /var/run/		(rw)
   */

  if (strlen (path) < strlen ("/var/run/"))
    goto bad_path;

  /* Any path containing '..' is invalid.  */
  for (p = path; *p && (p - path) < (int)pmax; p++)
    if (*p == '.' && *(p + 1) == '.')
      goto bad_path;

  /* For any write-mode, only a few paths are permitted.  */
  if ((flags & O_ACCMODE) != O_RDONLY)
    {
      if (strncmp ("/var/run/", path, strlen ("/var/run/")) == 0)
	return 0;
      goto bad_path;
    }

  /* Any other path is read-only.  */
  if (strncmp (ISAKMPD_ROOT, path, strlen (ISAKMPD_ROOT)) == 0 ||
      strncmp ("/var/run/", path, strlen ("/var/run/")) == 0)
    return 0;

 bad_path:
  log_print ("m_priv_local_sanitize_path: illegal path \"%.1023s\", "
	     "replaced with \"/dev/null\"", path);
  strlcpy (path, "/dev/null", pmax);
  return 1;
d983 1
a983 1
m_priv_check_sockopt (int level, int name)
d985 11
a995 32
  switch (level)
    {
    /* These are allowed */
    case SOL_SOCKET:
    case IPPROTO_IP:
    case IPPROTO_IPV6:
      break;

    default:
      log_print ("m_priv_check_sockopt: Illegal level %d", level);
      return 1;
    }

  switch (name)
    {
    /* These are allowed */
    case SO_REUSEPORT:
    case SO_REUSEADDR:
    case IP_AUTH_LEVEL:
    case IP_ESP_TRANS_LEVEL:
    case IP_ESP_NETWORK_LEVEL:
    case IP_IPCOMP_LEVEL:
    case IPV6_AUTH_LEVEL:
    case IPV6_ESP_TRANS_LEVEL:
    case IPV6_ESP_NETWORK_LEVEL:
    case IPV6_IPCOMP_LEVEL:
      break;

    default:
      log_print ("m_priv_check_sockopt: Illegal option name %d", name);
      return 1;
    }
d997 20
a1016 1
  return 0;
d1021 1
a1021 1
m_priv_check_bind (const struct sockaddr *sa, socklen_t salen)
d1023 1
a1023 1
  in_port_t port;
d1025 28
a1052 12
  if (sa == NULL)
    {
      log_print ("NULL address");
      return 1;
    }

    if (sysdep_sa_len ((struct sockaddr *)sa) != salen)
      {
	log_print ("Length mismatch: %d %d",
		   (int) sysdep_sa_len ((struct sockaddr *)sa), (int) salen);
	return 1;
      }
d1054 1
a1054 22
    switch (sa->sa_family)
      {
      case AF_INET:
	if (salen != sizeof (struct sockaddr_in))
	  {
	    log_print ("Invalid inet address length");
	    return 1;
	  }
	port = ((const struct sockaddr_in *)sa)->sin_port;
	break;
      case AF_INET6:
	if (salen != sizeof (struct sockaddr_in6))
	  {
	    log_print ("Invalid inet6 address length");
	    return 1;
	  }
	port = ((const struct sockaddr_in6 *)sa)->sin6_port;
	break;
      default:
	log_print ("Unknown address family");
	return 1;
      }
d1056 6
a1061 1
    port = ntohs(port);
a1062 9
    if (port != ISAKMP_PORT_DEFAULT && port < 1024)
      {
	log_print ("Disallowed port %u", port);
	return 1;
      }

    return 0;
}
	
d1065 1
a1065 1
m_priv_increase_state (int state)
d1067 6
a1072 6
  if (state <= cur_state)
    log_print ("m_priv_increase_state: attempt to decrase state or match "
	       "current state");
  if (state < STATE_INIT || state > STATE_QUIT)
    log_print ("m_priv_increase_state: attempt to switch to invalid state");
  cur_state = state;
d1076 1
a1076 1
m_priv_test_state (int state)
d1078 3
a1080 3
  if (cur_state != state)
    log_print ("m_priv_test_state: Illegal state: %d != %d", cur_state, state);
  return;
@


1.17
log
@Use sysdep_sa_len() instead of sa->sa_len, also correct a log_fatal() message. hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.16 2004/03/29 17:07:59 deraadt Exp $	*/
d1017 1
a1017 1
  for (p = path; *p && (p - path) < pmax; p++)
@


1.16
log
@use malloc (oops)
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.15 2004/03/29 16:32:47 deraadt Exp $	*/
d47 2
d557 1
a557 1
      log_fatal ("monitor_loop: calloc() failed");
d1093 1
a1093 1
    if (sa->sa_len != salen)
d1095 2
a1096 1
	log_print ("Length mismatch: %d %d", (int) sa->sa_len, (int) salen);
@


1.15
log
@wrong FD_ZERO(); from ho, hshoexer, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.14 2004/03/23 18:20:03 hshoexer Exp $	*/
d551 1
a551 1
  fds = (fd_set *)calloc (fdsn);
@


1.14
log
@Remove erroneous null termination.

ok ho@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.13 2004/03/19 14:04:43 hshoexer Exp $	*/
d542 1
d550 2
a551 1
  fds = (fd_set *)calloc (howmany (maxfd, NFDBITS), sizeof (fd_mask));
d599 1
a599 1
      FD_ZERO (fds);
@


1.13
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.12 2004/03/15 16:34:28 hshoexer Exp $	*/
a981 1
  data[v - 1] = 0;
@


1.12
log
@Properly check succes of chroot().

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.11 2004/03/15 16:29:00 hshoexer Exp $	*/
d33 1
d61 1
d63 3
d74 10
a83 6
void m_priv_getfd (int);
void m_priv_getsocket (int);
void m_priv_setsockopt (int);
void m_priv_bind (int);
void m_priv_mkfifo (int);
void m_priv_local_sanitize_path (char *, size_t, int);
d139 1
a141 6
  if (m_state.pid)
    {
      /* Called from the parent, i.e already privileged.  */
      return open (path, flags, mode);
    }

d160 8
d173 2
a174 1
      log_error ("monitor_open: open(\"%s\") failed", path);
d189 1
a189 1
  int fd, flags = 0, umask = 0;
d210 3
a212 1
  fd = monitor_open (path, flags, umask);
d221 1
d223 1
d235 2
a236 1
  fd = monitor_open (path, O_RDONLY, 0);
a237 2
    {
      errno = EACCES; /* A good guess? */
a238 1
    }
d251 1
d265 8
d276 6
d294 1
a294 1
  int ret;
d298 2
a299 1
  mm_send_fd (m_state.s, s); /* XXX? */
d310 6
d319 1
a319 1
  return ret;
d329 1
a329 1
  int ret;
d333 2
a334 1
  mm_send_fd (m_state.s, s);
d341 6
d350 1
a350 1
  return ret;
d360 1
a360 1
  int32_t ret;
d382 6
d398 117
d519 1
a519 1
/* Help function for monitor_loop().  */
d526 10
d540 1
d542 1
a542 1
  int n, maxfd, shutdown = 0;
d560 6
a565 1
  while (!shutdown)
d573 3
d577 11
a587 2
	    wait (&n);
	  shutdown++;
d591 6
d623 2
d629 2
d635 2
d641 2
d646 6
d653 2
a654 1
		  shutdown++;
d668 1
a668 1
void
d672 1
a672 1
  int32_t v;
d695 12
a706 1
  m_priv_local_sanitize_path (path, sizeof path, flags);
d708 4
a711 2
  v = (int32_t)open (path, flags, mode);
  if (mm_send_fd (s, v))
d725 1
a725 1
void
d729 1
a729 1
  int32_t v;
d743 1
d745 7
a751 1
  if (mm_send_fd (s, v))
d765 1
a765 1
void
d771 1
a771 1
  int32_t v;
d793 13
a805 1
  v = (int32_t) setsockopt (sock, level, optname, optval, optlen);
d808 4
d828 1
a828 1
void
d834 1
a834 1
  int32_t v;
d851 16
a866 4
  v = (int32_t)bind (sock, name, namelen);
  if (v < 0)
    log_error ("m_priv_bind: bind(%d,%p,%d) returned %d",
	       sock, name, namelen, v);
d870 4
d890 1
a890 1
void
d893 1
a893 1
  char name[MAXPATHLEN];
d895 1
a895 1
  int32_t v;
d897 1
a897 1
  if (m_read_raw (s, name, MAXPATHLEN))
d904 22
a925 1
  /* XXX Sanity checks for 'name'.  */
d927 2
a928 4
  unlink (name); /* XXX See ui.c:ui_init() */
  v = (int32_t)mkfifo (name, mode);
  if (v)
    log_error ("m_priv_mkfifo: mkfifo(\"%s\", %d) failed", name, mode);
d999 1
a999 1
void
d1005 1
a1005 1
   * Basically, we only permit paths starting with
d1007 1
a1007 5
   *  /var/run/
   *  /var/tmp
   *  /tmp
   *
   * XXX This is an interim measure only.
d1010 1
a1010 1
  if (strlen (path) < sizeof "/tmp")
d1021 2
a1022 4
      if (strncmp ("/var/run/", path, sizeof "/var/run") == 0 ||
	  strncmp ("/var/tmp/", path, sizeof "/var/tmp") == 0 ||
	  strncmp ("/tmp/", path, sizeof "/tmp") == 0)
	return;
d1026 4
a1029 3
  /* Any other paths are read-only.  */
  if (strncmp (ISAKMPD_ROOT, path, strlen (ISAKMPD_ROOT)) == 0)
    return;
d1035 112
a1148 1

@


1.11
log
@Remove unused code.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.10 2003/09/25 22:28:48 aaron Exp $	*/
d106 2
a107 3
      if (chroot (pw->pw_dir) != 0)
	log_fatal ("monitor_init: chroot(\"%s\") failed", pw->pw_dir);
      chdir ("/");
@


1.10
log
@Fix off-by-one out-of-bounds write; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.9 2003/09/05 07:50:04 tedu Exp $	*/
a50 3
#if defined (USE_X509)
#include "x509.h"
#endif
a75 11
#if defined (USE_X509)
void m_priv_rsa_getkey (int);
void m_priv_rsa_freekey (int);
void m_priv_rsa_uploadkey (int);
void m_priv_rsa_encrypt (int);

int32_t m_priv_local_addkey (RSA *);
RSA *m_priv_local_getkey (int32_t);
void m_priv_local_deletekey (int32_t);
#endif /* USE_X509 */

a348 128
#if defined (USE_X509)
/* Called by rsa_sig_encode_hash, the code that gets a key from ACQUIRE.  */
char *
monitor_RSA_upload_key (char *k_raw)
{
  RSA *rsa = (RSA *)k_raw;
  int32_t v;

  if (m_write_int32 (m_state.s, MONITOR_RSA_UPLOADKEY))
    goto errout;

  /* XXX - incomplete */
  if (m_write_raw (m_state.s, k_raw, 0))
    goto errout;

  RSA_free (rsa);

  if (m_read_int32 (m_state.s, &v))
    goto errout;

  return (char *)v;

 errout:
  log_print ("monitor_RSA_upload_key: read/write error");
  return 0;
}

char *
monitor_RSA_get_private_key (char *id, char *local_id)
{
  char *confval;
  int32_t v;

  if (m_write_int32 (m_state.s, MONITOR_RSA_GETKEY))
    goto errout;

  /*
   * The privileged process will call ike_auth_get_key, so we need to
   * to collect some current configuration data for it.
   */
  confval = conf_get_str ("KeyNote", "Credential-directory");
  if (!confval)
    m_write_int32 (m_state.s, 0);
  else
    m_write_raw (m_state.s, confval, strlen (confval) + 1);

  confval = conf_get_str ("X509-certificates", "Private-key");
  if (!confval)
    m_write_int32 (m_state.s, 0);
  else
    m_write_raw (m_state.s, confval, strlen (confval) + 1);

  /* Next, the required arguments.  */
  if (m_write_raw (m_state.s, id, strlen (id) + 1))
    goto errout;
  if (m_write_raw (m_state.s, local_id, strlen (local_id) + 1))
    goto errout;

  /* Now, read the results.  */
  if (m_read_int32 (m_state.s, &v))
    goto errout;

  return (char *)v;

 errout:
  log_print ("monitor_RSA_upload_key: read/write error");
  return 0;
}

int
monitor_RSA_private_encrypt (int hashsize, unsigned char *hash,
			     unsigned char **sigdata, void *rkey, int padtype)
{
  int32_t v;
  char *data = 0;
  int datalen;

  *sigdata = 0;

  if (m_write_int32 (m_state.s, MONITOR_RSA_ENCRYPT))
    goto errout;

  if (m_write_int32 (m_state.s, (int32_t)hashsize))
    goto errout;

  if (m_write_raw (m_state.s, hash, hashsize))
    goto errout;

  if (m_write_int32 (m_state.s, (int32_t)rkey))
    goto errout;

  if (m_write_int32 (m_state.s, (int32_t)padtype))
    goto errout;

  /* Read results.  */
  if (m_read_int32 (m_state.s, &v))
    goto errout;
  datalen = (int)v;

  if (datalen == -1)
    goto errout;

  data = (char *)malloc (datalen);
  if (!data)
    goto errout;

  if (m_read_raw (m_state.s, data, datalen))
    goto errout;

  *sigdata = data;
  return datalen;

 errout:
  if (data)
    free (data);
  return -1;
}

void
monitor_RSA_free (void *key)
{
  if (m_write_int32 (m_state.s, MONITOR_RSA_FREEKEY) == 0)
    m_write_int32 (m_state.s, (int32_t)key);

  return;
}
#endif /* USE_X509 */

a441 19
#if defined (USE_X509)
		case MONITOR_RSA_UPLOADKEY:
		  /* XXX Not implemented yet. */
		  /* m_priv_rsa_uploadkey (m_state.s); */
		  break;

		case MONITOR_RSA_GETKEY:
		  m_priv_rsa_getkey (m_state.s);
		  break;

		case MONITOR_RSA_ENCRYPT:
		  m_priv_rsa_encrypt (m_state.s);
		  break;

		case MONITOR_RSA_FREEKEY:
		  m_priv_rsa_freekey (m_state.s);
		  break;
#endif

a653 236
#if defined (USE_X509)
void
m_priv_rsa_getkey (int s)
{
  char cred_dir[MAXPATHLEN], pkey_path[MAXPATHLEN], pbuf[MAXPATHLEN];
  char id[MAXPATHLEN],local_id[MAXPATHLEN];		/* XXX MAXPATHLEN? */
  size_t fsize;
  int32_t keyno;
  RSA *rsakey = 0;
  BIO *keyh;

  cred_dir[0] = pkey_path[0] = id[0] = local_id[0] = 0;
  if (m_read_raw (s, pbuf, sizeof pbuf))
    goto errout;
  if (pbuf[0] == '/')
    strlcpy (cred_dir, pbuf, sizeof cred_dir);
  else
    snprintf (cred_dir, sizeof cred_dir, "%s/%s", m_state.root, pbuf);

  if (m_read_raw (s, pbuf, sizeof pbuf))
    goto errout;
  if (pbuf[0] == '/')
    strlcpy (pkey_path, pbuf, sizeof pkey_path);
  else
    snprintf (pkey_path, sizeof pkey_path, "%s/%s", m_state.root, pbuf);

  if (m_read_raw (s, id, sizeof id))
    goto errout;
  if (m_read_raw (s, local_id, sizeof local_id))
    goto errout;

  /* This is basically a copy of ike_auth_get_key ().  */
#if defined (USE_KEYNOTE)
  if (local_id[0] && cred_dir[0])
    {
      struct stat sb;
      struct keynote_deckey dc;
      char *privkeyfile, *buf2, *buf;
      int fd, pkflen;
      size_t size;

      pkflen = strlen (cred_dir) + strlen (local_id) +
	sizeof PRIVATE_KEY_FILE + sizeof "//" - 1;
      privkeyfile = calloc (pkflen, sizeof (char));
      if (!privkeyfile)
	{
	  log_print ("m_priv_rsa_getkey: failed to allocate %d bytes", pkflen);
	  goto errout;
	}

      snprintf (privkeyfile, pkflen, "%s/%s/%s", cred_dir, local_id,
		PRIVATE_KEY_FILE);

      if (stat (privkeyfile, &sb) < 0)
	{
	  free (privkeyfile);
	  goto ignorekeynote;
	}
      size = (size_t)sb.st_size;

      fd = open (privkeyfile, O_RDONLY, 0);
      if (fd < 0)
	{
	  log_print ("m_priv_rsa_getkey: failed opening \"%s\"", privkeyfile);
	  free (privkeyfile);
	  goto errout;
	}

      buf = calloc (size + 1, sizeof (char));
      if (!buf)
	{
	  log_print ("m_priv_rsa_getkey: failed allocating %lu bytes",
		     (unsigned long)size + 1);
	  free (privkeyfile);
	  goto errout;
	}

      if (read (fd, buf, size) != size)
	{
	  free (buf);
	  log_print ("m_priv_rsa_getkey: "
		     "failed reading %lu bytes from \"%s\"",
		     (unsigned long)size, privkeyfile);
	  free (privkeyfile);
	  goto errout;
	}

      close (fd);

      /* Parse private key string */
      buf2 = kn_get_string (buf);
      free (buf);

      if (kn_decode_key (&dc, buf2, KEYNOTE_PRIVATE_KEY) == -1)
	{
	  free (buf2);
	  log_print ("m_priv_rsa_getkey: failed decoding key in \"%s\"",
		     privkeyfile);
	  free (privkeyfile);
	  goto errout;
	}

      free (buf2);

      if (dc.dec_algorithm != KEYNOTE_ALGORITHM_RSA)
	{
	  log_print ("m_priv_rsa_getkey: wrong algorithm type %d in \"%s\"",
		     dc.dec_algorithm, privkeyfile);
	  free (privkeyfile);
	  kn_free_key (&dc);
	  goto errout;
	}

      free (privkeyfile);
      rsakey = dc.dec_key;
    }
 ignorekeynote:
#endif /* USE_KEYNOTE */

  /* XXX I do not really like to call this from here.  */
  if (check_file_secrecy (pkey_path, &fsize))
    goto errout;

  keyh = BIO_new (BIO_s_file ());
  if (keyh == NULL)
    {
      log_print ("m_priv_rsa_getkey: "
		 "BIO_new (BIO_s_file ()) failed");
      goto errout;
    }
  if (BIO_read_filename (keyh, pkey_path) == -1)
    {
      log_print ("m_priv_rsa_getkey: "
		 "BIO_read_filename (keyh, \"%s\") failed",
		 pkey_path);
      BIO_free (keyh);
      goto errout;
    }

#if SSLEAY_VERSION_NUMBER >= 0x00904100L
  rsakey = PEM_read_bio_RSAPrivateKey (keyh, NULL, NULL, NULL);
#else
  rsakey = PEM_read_bio_RSAPrivateKey (keyh, NULL, NULL);
#endif
  BIO_free (keyh);
  if (!rsakey)
    {
      log_print ("m_priv_rsa_getkey: PEM_read_bio_RSAPrivateKey failed");
      goto errout;
    }

  /* Enable RSA blinding.  */
  if (RSA_blinding_on (rsakey, NULL) != 1)
    {
      log_error ("m_priv_rsa_getkey: RSA_blinding_on () failed");
      goto errout;
    }

  keyno = m_priv_local_addkey (rsakey);
  m_write_int32 (s, keyno);
  return;

 errout:
  m_write_int32 (s, -1);
  if (rsakey)
    RSA_free (rsakey);
  return;
}

void
m_priv_rsa_encrypt (int s)
{
  int32_t hashsize, padtype, datalen;
  char *hash = 0, *data = 0;
  RSA *key;
  int32_t v;

  if (m_read_int32 (s, &hashsize))
    goto errout;

  hash = (char *)malloc (hashsize);
  if (!hash)
    goto errout;

  if (m_read_raw (s, hash, hashsize))
    goto errout;

  if (m_read_int32 (s, &v))
    goto errout;

  if (m_read_int32 (s, &padtype))
    goto errout;

  key = m_priv_local_getkey (v);
  if (!key)
    goto errout;

  data = (char *)malloc (RSA_size (key));
  if (!data)
    goto errout;

  datalen = RSA_private_encrypt (hashsize, hash, data, key, padtype);
  if (datalen == -1)
    {
      log_print ("m_priv_rsa_encrypt: RSA_private_encrypt () failed");
      goto errout;
    }

  if (m_write_int32 (s, datalen))
    goto errout;

  if (m_write_raw (s, data, datalen))
    goto errout;

  free (hash);
  free (data);
  return;

 errout:
  m_write_int32 (s, -1);
  if (data)
    free (data);
  if (hash)
    free (hash);
  return;
}

void
m_priv_rsa_freekey (int s)
{
  int32_t keyno;
  if (m_read_int32 (s, &keyno) == 0)
    m_priv_local_deletekey (keyno);
}
#endif /* USE_X509 */

a710 75

#if defined (USE_X509)
/* Privileged process RSA key storage help functions.  */
struct m_key_storage
{
  RSA *key;
  int32_t keyno;
  struct m_key_storage *next;
} *keylist = 0;

int32_t
m_priv_local_addkey (RSA *key)
{
  struct m_key_storage *n, *k;

  n = (struct m_key_storage *)calloc (1, sizeof (struct m_key_storage));
  if (!n)
    return 0;

  if (!keylist)
    {
      keylist = n;
      n->keyno = 1;
    }
  else
    {
      for (k = keylist; k->next; k = k->next) ;
      k->next = n;
      n->keyno = k->keyno + 1;		/* XXX 2^31 keys? */
    }

  n->key = key;
  return n->keyno;
}

RSA *
m_priv_local_getkey (int32_t keyno)
{
  struct m_key_storage *k;

  for (k = keylist; k; k = k->next)
    if (k->keyno == keyno)
      return k->key;
  return 0;
}

void
m_priv_local_deletekey (int32_t keyno)
{
  struct m_key_storage *k;

  if (keylist->keyno == keyno)
    {
      k = keylist;
      keylist = keylist->next;
    }
  else
    for (k = keylist; k->next; k = k->next)
      if (k->next->keyno == keyno)
	{
	  struct m_key_storage *s = k->next;
	  k->next = k->next->next;
	  k = s;
	  break;
	}

  if (k)
    {
      RSA_free (k->key);
      free (k);
    }

  return;
}
#endif /* USE_X509 */
@


1.9
log
@socket leak on error paths.  from Patrick Latifi.  ok deraadt@@ ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.8 2003/07/29 02:01:22 avsm Exp $	*/
d1093 1
a1093 1
  data[v] = 0;
@


1.8
log
@off-by-one in a printf %s
markus@@ ok a while back
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.7 2003/06/10 16:41:29 deraadt Exp $	*/
d700 2
d721 1
d732 2
d747 2
d767 1
d778 2
@


1.7
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.6 2003/06/03 14:28:16 ho Exp $	*/
d1213 1
a1213 1
  log_print ("m_priv_local_sanitize_path: illegal path \"%.1024s\", "
@


1.6
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.5 2003/05/18 21:26:36 ho Exp $	*/
d401 1
a401 1
   * to collect some current configuration data for it. 
d491 1
a491 1
/* 
d524 1
a524 1
  
d615 1
a615 1
m_priv_getfd (int s)  
d659 1
a659 1
m_priv_getsocket (int s)  
d692 1
a692 1
m_priv_setsockopt (int s)  
d815 1
a815 1
  
@


1.5
log
@Add some path sanitation; only permit write operations to /tmp,
/var/tmp and /var/run. Opens in /etc/isakmpd/ are read-only. Any other
path is invalid. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.4 2003/05/18 19:37:46 ho Exp $	*/
a13 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.4
log
@More isakmpd privsep work. X509 private keys are now kept in the privileged
process only. Various cleanup and bugfixes.
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.3 2003/05/15 02:04:45 ho Exp $	*/
d79 1
d643 1
a643 1
  /* XXX Sanity checks  */
d1175 46
@


1.3
log
@Proper exit of the monitor process.
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.2 2003/05/15 01:51:10 ho Exp $	*/
d43 6
d51 5
d79 11
a89 1
void m_priv_close (int);
d115 1
a115 1
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_init: pid %d my fd %d", m_state.pid,
a147 1
  /* Only the child process is supposed to run this.  */
d149 4
a152 3
    log_fatal ("[priv] bad call to monitor_open");

  LOG_DBG ((LOG_SYSDEP, 95, "monitor_open: enter"));
a179 1
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_open: got fd %d", fd));
a193 2
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_fopen: enter"));

a233 2
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_stat: enter"));

d243 1
a243 1
  monitor_close (fd);
a252 2
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_socket: enter"));

a268 1
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_socket: return fd %d", s));
a281 2
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_setsockopt: enter"));

d284 1
a284 1
  mm_send_fd (m_state.s, s);
a309 2
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_bind: enter"));

a338 2
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_mkfifo: enter"));

d364 29
a392 2
int
monitor_close (int s)
d394 26
a419 1
  if (m_write_int32 (m_state.s, MONITOR_CLOSE))
d422 3
a424 1
  mm_send_fd (m_state.s, s);
d426 1
a426 1
  return close (s);
d429 2
a430 2
  log_print ("monitor_close: write error");
  return close (s);
d434 2
a435 1
monitor_fclose (FILE *fp)
d437 3
a439 1
  int fd = fileno (fp);
d441 3
a443 1
  if (m_write_int32 (m_state.s, MONITOR_CLOSE))
d446 2
a447 1
  mm_send_fd (m_state.s, fd);
d449 26
a474 1
  return fclose (fp);
d477 12
a488 2
  log_print ("monitor_fclose: write error");
  return fclose (fp);
d490 1
a542 1
      LOG_DBG ((LOG_SYSDEP, 95, "monitor_loop: waiting for select()"));
a543 1
      LOG_DBG ((LOG_SYSDEP, 95, "monitor_loop: select returned %d", n));
d581 12
a592 2
		case MONITOR_CLOSE:
		  m_priv_close (m_state.s);
d595 6
a600 2
		case MONITOR_SHUTDOWN:
		  shutdown++;
d602 1
a630 2
  LOG_DBG ((LOG_SYSDEP, 95, "m_priv_getfd: enter"));

d645 6
a650 1
  mm_send_fd (s, v);
a664 2
  LOG_DBG ((LOG_SYSDEP, 95, "m_priv_getsocket: enter"));

d678 6
a683 1
  mm_send_fd (s, v);
d719 1
a741 2
  LOG_DBG ((LOG_SYSDEP, 95, "m_priv_bind: enter"));

d756 5
a781 2
  LOG_DBG ((LOG_SYSDEP, 95, "m_priv_mkfifo: enter"));

d806 169
a974 1
/* Privileged: called by monitor_loop.  */
d976 1
a976 1
m_priv_close (int s)  
d978 11
a988 1
  int sock, r;
d990 29
a1018 2
  sock = mm_receive_fd (s);
  r = close (sock);
d1020 3
a1022 1
  LOG_DBG ((LOG_SYSDEP, 95, "m_priv_close: closing fd %d, ret %d", sock, r));
d1024 6
d1033 9
a1094 1
  LOG_DBG ((LOG_SYSDEP, 95, "m_flush: fd %d enter", s));
a1097 1
  LOG_DBG ((LOG_SYSDEP, 95, "m_flush: fd %d done", s));
d1099 75
@


1.2
log
@wait() for the child process
@
text
@d1 1
a1 1
/*	$OpenBSD: monitor.c,v 1.1 2003/05/15 00:28:53 ho Exp $	*/
d434 1
@


1.1
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ui.h,v 1.4 1998/12/21 01:02:28 niklas Exp $	*/
d34 1
d94 2
a95 1
  LOG_DBG ((LOG_SYSDEP, 95, "monitor_init: pid %d my fd %d", m_state.pid, m_state.s));
d430 5
a434 1
	shutdown++;
@

