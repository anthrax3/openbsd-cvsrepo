head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.40
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.38
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.34
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.32
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.30
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.28
	OPENBSD_5_0:1.23.0.26
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.24
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.22
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.18
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.20
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.16
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.14
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.12
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.10
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.8
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.6
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	0qPuuXwccpVXsXcV;

1.24
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2005.04.08.22.32.09;	author cloder;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.14.08.42.56;	author hshoexer;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.06.16.12.07;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.12.51.38;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.18.08.58;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.03.16.27.41;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.23.14.17.08;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.22.13.30.33;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.17.10.35.51;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.16.07.04.28;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.01.06.03.34;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.29.18.52.16;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.29.03.39.04;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.27.03.31.40;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.27.15.39.54;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.27.12.03.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.26.21.49.36;	author ho;	state Exp;
branches;
next	;


desc
@@


1.25
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@/* $OpenBSD: dnssec.c,v 1.24 2015/01/16 06:39:58 deraadt Exp $	 */

/*
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <arpa/inet.h>
#include <stdlib.h>

#include <openssl/rsa.h>

#ifdef LWRES
#include <lwres/netdb.h>
#include <dns/keyvalues.h>
#else
#include <netdb.h>
#endif

#include "dnssec.h"
#include "exchange.h"
#include "ipsec_num.h"
#include "libcrypto.h"
#include "log.h"
#include "message.h"
#include "transport.h"
#include "util.h"

#ifndef DNS_UFQDN_SEPARATOR
#define DNS_UFQDN_SEPARATOR "._ipsec."
#endif

/* adapted from <dns/rdatastruct.h> / RFC 2535  */
struct dns_rdata_key {
	u_int16_t       flags;
	u_int8_t        protocol;
	u_int8_t        algorithm;
	u_int16_t       datalen;
	unsigned char  *data;
};

void *
dns_get_key(int type, struct message *msg, int *keylen)
{
	struct exchange *exchange = msg->exchange;
	struct rrsetinfo *rr;
	struct dns_rdata_key key_rr;
	char            name[HOST_NAME_MAX+1];
	in_addr_t       ip4;
	u_int8_t        algorithm, *id, *umark;
	size_t          id_len;
	int             ret, i;

	switch (type) {
	case IKE_AUTH_RSA_SIG:
		algorithm = DNS_KEYALG_RSA;
		break;

	case IKE_AUTH_RSA_ENC:
	case IKE_AUTH_RSA_ENC_REV:
		/* XXX Not yet. */
		/* algorithm = DNS_KEYALG_RSA; */
		return 0;

	case IKE_AUTH_DSS:
		/* XXX Not yet. */
		/* algorithm = DNS_KEYALG_DSS; */
		return 0;

	case IKE_AUTH_PRE_SHARED:
	default:
		return 0;
	}

	id = exchange->initiator ? exchange->id_r : exchange->id_i;
	id_len = exchange->initiator ? exchange->id_r_len : exchange->id_i_len;
	bzero(name, sizeof name);

	if (!id || id_len == 0) {
		log_print("dns_get_key: ID is missing");
		return 0;
	}
	/* Exchanges (and SAs) don't carry the ID in ISAKMP form */
	id -= ISAKMP_GEN_SZ;
	id_len += ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF;

	switch (GET_ISAKMP_ID_TYPE(id)) {
	case IPSEC_ID_IPV4_ADDR:
		/* We want to lookup a KEY RR in the reverse zone.  */
		if (id_len < sizeof ip4)
			return 0;
		memcpy(&ip4, id + ISAKMP_ID_DATA_OFF, sizeof ip4);
		snprintf(name, sizeof name, "%d.%d.%d.%d.in-addr.arpa.", ip4
		    >> 24, (ip4 >> 16) & 0xFF, (ip4 >> 8) & 0xFF, ip4 & 0xFF);
		break;

	case IPSEC_ID_IPV6_ADDR:
		/* XXX Not yet. */
		return 0;
		break;

	case IPSEC_ID_FQDN:
		if ((id_len + 1) >= sizeof name)
			return 0;
		/* ID is not NULL-terminated. Add trailing dot and NULL.  */
		memcpy(name, id + ISAKMP_ID_DATA_OFF, id_len);
		*(name + id_len) = '.';
		*(name + id_len + 1) = '\0';
		break;

	case IPSEC_ID_USER_FQDN:
		/*
		 * Some special handling here. We want to convert the ID
		 * 'user@@host.domain' string into 'user._ipsec.host.domain.'.
		 */
		if ((id_len + sizeof(DNS_UFQDN_SEPARATOR)) >= sizeof name)
			return 0;
		/* Look for the '@@' separator.  */
		for (umark = id + ISAKMP_ID_DATA_OFF; (umark - id) < id_len;
		    umark++)
			if (*umark == '@@')
				break;
		if (*umark != '@@') {
			LOG_DBG((LOG_MISC, 50, "dns_get_key: bad UFQDN ID"));
			return 0;
		}
		*umark++ = '\0';
		/* id is now terminated. 'umark', however, is not.  */
		snprintf(name, sizeof name, "%s%s", id + ISAKMP_ID_DATA_OFF,
		    DNS_UFQDN_SEPARATOR);
		memcpy(name + strlen(name), umark, id_len - strlen(id) - 1);
		*(name + id_len + sizeof(DNS_UFQDN_SEPARATOR) - 2) = '.';
		*(name + id_len + sizeof(DNS_UFQDN_SEPARATOR) - 1) = '\0';
		break;

	default:
		return 0;
	}

	LOG_DBG((LOG_MISC, 50, "dns_get_key: trying KEY RR for %s", name));
	ret = getrrsetbyname(name, C_IN, T_KEY, 0, &rr);

	if (ret) {
		LOG_DBG((LOG_MISC, 30, "dns_get_key: no DNS responses "
		    "(error %d)", ret));
		return 0;
	}
	LOG_DBG((LOG_MISC, 80,
	    "dns_get_key: rrset class %d type %d ttl %d nrdatas %d nrsigs %d",
	    rr->rri_rdclass, rr->rri_rdtype, rr->rri_ttl, rr->rri_nrdatas,
	    rr->rri_nsigs));

	/* We don't accept unvalidated data. */
	if (!(rr->rri_flags & RRSET_VALIDATED)) {
		LOG_DBG((LOG_MISC, 10, "dns_get_key: "
		    "got unvalidated response"));
		freerrset(rr);
		return 0;
	}
	/* Sanity. */
	if (rr->rri_nrdatas == 0 || rr->rri_rdtype != T_KEY) {
		LOG_DBG((LOG_MISC, 30, "dns_get_key: no KEY RRs received"));
		freerrset(rr);
		return 0;
	}
	bzero(&key_rr, sizeof key_rr);

	/*
	 * Find a key with the wanted algorithm, if any.
	 * XXX If there are several keys present, we currently only find the
	 * first.
         */
	for (i = 0; i < rr->rri_nrdatas && key_rr.datalen == 0; i++) {
		key_rr.flags = ntohs((u_int16_t) * rr->rri_rdatas[i].rdi_data);
		key_rr.protocol = *(rr->rri_rdatas[i].rdi_data + 2);
		key_rr.algorithm = *(rr->rri_rdatas[i].rdi_data + 3);

		if (key_rr.protocol != DNS_KEYPROTO_IPSEC) {
			LOG_DBG((LOG_MISC, 50, "dns_get_key: ignored "
			    "non-IPsec key"));
			continue;
		}
		if (key_rr.algorithm != algorithm) {
			LOG_DBG((LOG_MISC, 50, "dns_get_key: ignored "
			    "key with other alg"));
			continue;
		}
		key_rr.datalen = rr->rri_rdatas[i].rdi_length - 4;
		if (key_rr.datalen <= 0) {
			LOG_DBG((LOG_MISC, 50, "dns_get_key: "
			    "ignored bad key"));
			key_rr.datalen = 0;
			continue;
		}
		/* This key seems to fit our requirements... */
		key_rr.data = malloc(key_rr.datalen);
		if (!key_rr.data) {
			log_error("dns_get_key: malloc (%d) failed",
			    key_rr.datalen);
			freerrset(rr);
			return 0;
		}
		memcpy(key_rr.data, rr->rri_rdatas[i].rdi_data + 4,
		    key_rr.datalen);
		*keylen = key_rr.datalen;
	}

	freerrset(rr);

	if (key_rr.datalen)
		return key_rr.data;
	return 0;
}

int
dns_RSA_dns_to_x509(u_int8_t *key, int keylen, RSA **rsa_key)
{
	RSA	*rsa;
	int	 key_offset;
	u_int8_t e_len;

	if (!key || keylen <= 0) {
		log_print("dns_RSA_dns_to_x509: invalid public key");
		return -1;
	}
	rsa = RSA_new();
	if (rsa == NULL) {
		log_error("dns_RSA_dns_to_x509: "
		    "failed to allocate new RSA struct");
		return -1;
	}
	e_len = *key;
	key_offset = 1;

	if (e_len == 0) {
		if (keylen < 3) {
			log_print("dns_RSA_dns_to_x509: invalid public key");
			RSA_free(rsa);
			return -1;
		}
		e_len = *(key + key_offset++) << 8;
		e_len += *(key + key_offset++);
	}
	if (e_len > (keylen - key_offset)) {
		log_print("dns_RSA_dns_to_x509: invalid public key");
		RSA_free(rsa);
		return -1;
	}
	rsa->e = BN_bin2bn(key + key_offset, e_len, NULL);
	key_offset += e_len;

	/* XXX if (keylen <= key_offset) -> "invalid public key" ? */

	rsa->n = BN_bin2bn(key + key_offset, keylen - key_offset, NULL);

	*rsa_key = rsa;

	LOG_DBG((LOG_MISC, 30, "dns_RSA_dns_to_x509: got %d bits RSA key",
	    BN_num_bits(rsa->n)));
	return 0;
}

#if notyet
int
dns_RSA_x509_to_dns(RSA *rsa_key, u_int8_t *key, int *keylen)
{
	return 0;
}
#endif
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: dnssec.c,v 1.23 2005/04/08 22:32:09 cloder Exp $	 */
d218 1
a218 1
		key_rr.data = (char *)malloc(key_rr.datalen);
@


1.23
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: dnssec.c,v 1.22 2005/04/04 19:31:11 deraadt Exp $	 */
d70 1
a70 1
	char            name[MAXHOSTNAMELEN];
@


1.22
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: dnssec.c,v 1.21 2005/02/27 13:12:12 hshoexer Exp $	 */
a40 2

#include "sysdep.h"
@


1.21
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: dnssec.c,v 1.20 2004/06/14 09:55:41 ho Exp $	 */
d139 1
a139 1
	         */
@


1.20
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: dnssec.c,v 1.19 2004/05/14 08:42:56 hshoexer Exp $	 */
d101 1
a101 1
	memset(name, 0, sizeof name);
d190 1
a190 1
	memset(&key_rr, 0, sizeof key_rr);
@


1.19
log
@Some more KNF, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: dnssec.c,v 1.18 2004/04/15 18:39:25 deraadt Exp $	 */
d129 1
a129 1
		/* ID is not NULL-terminated. Add trailing dot and terminate. */
d179 2
a180 1
		LOG_DBG((LOG_MISC, 10, "dns_get_key: got unvalidated response"));
d214 2
a215 1
			LOG_DBG((LOG_MISC, 50, "dns_get_key: ignored bad key"));
d252 2
a253 1
		log_error("dns_RSA_dns_to_x509: failed to allocate new RSA struct");
@


1.18
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: dnssec.c,v 1.17 2003/11/06 16:12:07 ho Exp $	 */
d66 2
a67 2
void           *
dns_get_key(int type, struct message * msg, int *keylen)
d117 2
a118 2
		snprintf(name, sizeof name, "%d.%d.%d.%d.in-addr.arpa.", ip4 >> 24,
		    (ip4 >> 16) & 0xFF, (ip4 >> 8) & 0xFF, ip4 & 0xFF);
d129 1
a129 1
		/* ID is not NULL-terminated. Add trailing dot and terminate.  */
d143 2
a144 1
		for (umark = id + ISAKMP_ID_DATA_OFF; (umark - id) < id_len; umark++)
d168 2
a169 2
		LOG_DBG((LOG_MISC, 30, "dns_get_key: no DNS responses (error %d)",
		    ret));
d193 2
a194 1
	 * XXX If there are several keys present, we currently only find the first.
d202 2
a203 1
			LOG_DBG((LOG_MISC, 50, "dns_get_key: ignored non-IPsec key"));
d218 1
a218 1
		key_rr.data = (char *) malloc(key_rr.datalen);
d220 2
a221 1
			log_error("dns_get_key: malloc (%d) failed", key_rr.datalen);
d225 2
a226 1
		memcpy(key_rr.data, rr->rri_rdatas[i].rdi_data + 4, key_rr.datalen);
d238 1
a238 1
dns_RSA_dns_to_x509(u_int8_t * key, int keylen, RSA ** rsa_key)
d240 3
a242 3
	RSA            *rsa;
	int             key_offset;
	u_int8_t        e_len;
d286 1
a286 1
dns_RSA_x509_to_dns(RSA * rsa_key, u_int8_t * key, int *keylen)
@


1.17
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.16 2003/06/03 14:28:16 ho Exp $	*/
d59 5
a63 5
  u_int16_t flags;
  u_int8_t protocol;
  u_int8_t algorithm;
  u_int16_t datalen;
  unsigned char *data;
d66 2
a67 2
void *
dns_get_key (int type, struct message *msg, int *keylen)
d69 93
a161 61
  struct exchange *exchange = msg->exchange;
  struct rrsetinfo *rr;
  struct dns_rdata_key key_rr;
  char name[MAXHOSTNAMELEN];
  in_addr_t ip4;
  u_int8_t algorithm;
  u_int8_t *id, *umark;
  size_t id_len;
  int ret, i;

  switch (type)
    {
    case IKE_AUTH_RSA_SIG:
      algorithm = DNS_KEYALG_RSA;
      break;

    case IKE_AUTH_RSA_ENC:
    case IKE_AUTH_RSA_ENC_REV:
      /* XXX Not yet. */
      /* algorithm = DNS_KEYALG_RSA; */
      return 0;

    case IKE_AUTH_DSS:
      /* XXX Not yet. */
      /* algorithm = DNS_KEYALG_DSS; */
      return 0;

    case IKE_AUTH_PRE_SHARED:
    default:
      return 0;
    }

  id = exchange->initiator ? exchange->id_r : exchange->id_i;
  id_len = exchange->initiator ? exchange->id_r_len : exchange->id_i_len;
  memset (name, 0, sizeof name);

  if (!id || id_len == 0)
    {
      log_print ("dns_get_key: ID is missing");
      return 0;
    }

  /* Exchanges (and SAs) don't carry the ID in ISAKMP form */
  id -= ISAKMP_GEN_SZ;
  id_len += ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF;

  switch (GET_ISAKMP_ID_TYPE (id))
    {
    case IPSEC_ID_IPV4_ADDR:
      /* We want to lookup a KEY RR in the reverse zone.  */
      if (id_len < sizeof ip4)
	return 0;
      memcpy (&ip4, id + ISAKMP_ID_DATA_OFF, sizeof ip4);
      snprintf (name, sizeof name, "%d.%d.%d.%d.in-addr.arpa.", ip4 >> 24,
	       (ip4 >> 16) & 0xFF, (ip4 >> 8) & 0xFF, ip4 & 0xFF);
      break;

    case IPSEC_ID_IPV6_ADDR:
      /* XXX Not yet. */
      return 0;
      break;
d163 2
a164 47
    case IPSEC_ID_FQDN:
      if ((id_len + 1) >= sizeof name)
	return 0;
      /* ID is not NULL-terminated. Add trailing dot and terminate.  */
      memcpy (name, id + ISAKMP_ID_DATA_OFF, id_len);
      *(name + id_len) = '.';
      *(name + id_len + 1) = '\0';
      break;

    case IPSEC_ID_USER_FQDN:
      /*
       * Some special handling here. We want to convert the ID
       * 'user@@host.domain' string into 'user._ipsec.host.domain.'.
       */
      if ((id_len + sizeof (DNS_UFQDN_SEPARATOR)) >= sizeof name)
	return 0;
      /* Look for the '@@' separator.  */
      for (umark = id + ISAKMP_ID_DATA_OFF; (umark - id) < id_len; umark++)
	if (*umark == '@@')
	  break;
      if (*umark != '@@')
	{
	  LOG_DBG ((LOG_MISC, 50, "dns_get_key: bad UFQDN ID"));
	  return 0;
	}
      *umark++ = '\0';
      /* id is now terminated. 'umark', however, is not.  */
      snprintf (name, sizeof name, "%s%s", id + ISAKMP_ID_DATA_OFF,
		DNS_UFQDN_SEPARATOR);
      memcpy (name + strlen (name), umark, id_len - strlen (id) - 1);
      *(name + id_len + sizeof (DNS_UFQDN_SEPARATOR) - 2) = '.';
      *(name + id_len + sizeof (DNS_UFQDN_SEPARATOR) - 1) = '\0';
      break;

    default:
      return 0;
    }

  LOG_DBG ((LOG_MISC, 50, "dns_get_key: trying KEY RR for %s", name));
  ret = getrrsetbyname (name, C_IN, T_KEY, 0, &rr);

  if (ret)
    {
      LOG_DBG ((LOG_MISC, 30, "dns_get_key: no DNS responses (error %d)",
		ret));
      return 0;
    }
d166 6
a171 1
  LOG_DBG ((LOG_MISC, 80,
d176 54
a229 66
  /* We don't accept unvalidated data. */
  if (!(rr->rri_flags & RRSET_VALIDATED))
    {
      LOG_DBG ((LOG_MISC, 10, "dns_get_key: got unvalidated response"));
      freerrset (rr);
      return 0;
    }

  /* Sanity. */
  if (rr->rri_nrdatas == 0 || rr->rri_rdtype != T_KEY)
    {
      LOG_DBG ((LOG_MISC, 30, "dns_get_key: no KEY RRs received"));
      freerrset (rr);
      return 0;
    }

  memset (&key_rr, 0, sizeof key_rr);

  /*
   * Find a key with the wanted algorithm, if any.
   * XXX If there are several keys present, we currently only find the first.
   */
  for (i = 0; i < rr->rri_nrdatas && key_rr.datalen == 0; i++)
    {
      key_rr.flags     = ntohs ((u_int16_t) *rr->rri_rdatas[i].rdi_data);
      key_rr.protocol  = *(rr->rri_rdatas[i].rdi_data + 2);
      key_rr.algorithm = *(rr->rri_rdatas[i].rdi_data + 3);

      if (key_rr.protocol != DNS_KEYPROTO_IPSEC)
	{
	  LOG_DBG ((LOG_MISC, 50, "dns_get_key: ignored non-IPsec key"));
	  continue;
	}

      if (key_rr.algorithm != algorithm)
	{
	  LOG_DBG ((LOG_MISC, 50, "dns_get_key: ignored key with other alg"));
	  continue;
	}

      key_rr.datalen = rr->rri_rdatas[i].rdi_length - 4;
      if (key_rr.datalen <= 0)
	{
	  LOG_DBG ((LOG_MISC, 50, "dns_get_key: ignored bad key"));
	  key_rr.datalen = 0;
	  continue;
	}

      /* This key seems to fit our requirements... */
      key_rr.data = (char *)malloc (key_rr.datalen);
      if (!key_rr.data)
	{
	  log_error ("dns_get_key: malloc (%d) failed", key_rr.datalen);
	  freerrset (rr);
	  return 0;
	}
      memcpy (key_rr.data, rr->rri_rdatas[i].rdi_data + 4, key_rr.datalen);
      *keylen = key_rr.datalen;
    }

  freerrset (rr);

  if (key_rr.datalen)
    return key_rr.data;
  else
    return 0;
d233 1
a233 1
dns_RSA_dns_to_x509 (u_int8_t *key, int keylen, RSA **rsa_key)
d235 15
a249 43
  RSA *rsa;
  int key_offset;
  u_int8_t e_len;

  if (!key || keylen <= 0)
    {
      log_print ("dns_RSA_dns_to_x509: invalid public key");
      return -1;
    }

  rsa = RSA_new ();
  if (rsa == NULL)
    {
      log_error ("dns_RSA_dns_to_x509: failed to allocate new RSA struct");
      return -1;
    }

  e_len = *key;
  key_offset = 1;

  if (e_len == 0)
    {
      if (keylen < 3)
	{
	  log_print ("dns_RSA_dns_to_x509: invalid public key");
	  RSA_free (rsa);
	  return -1;
	}
      e_len  = *(key + key_offset++) << 8;
      e_len += *(key + key_offset++);
    }

  if (e_len > (keylen - key_offset))
    {
      log_print ("dns_RSA_dns_to_x509: invalid public key");
      RSA_free (rsa);
      return -1;
    }

  rsa->e = BN_bin2bn (key + key_offset, e_len, NULL);
  key_offset += e_len;

  /* XXX if (keylen <= key_offset) -> "invalid public key" ? */
d251 18
a268 1
  rsa->n = BN_bin2bn (key + key_offset, keylen - key_offset, NULL);
d270 1
a270 1
  *rsa_key = rsa;
d272 1
a272 2
  LOG_DBG ((LOG_MISC, 30, "dns_RSA_dns_to_x509: got %d bits RSA key",
	    BN_num_bits (rsa->n)));
d274 3
a276 1
  return 0;
d281 1
a281 1
dns_RSA_x509_to_dns (RSA *rsa_key, u_int8_t *key, int *keylen)
d283 1
a283 1
  return 0;
@


1.16
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.15 2003/06/03 12:51:38 ho Exp $	*/
d153 1
a153 1
	  LOG_DBG((LOG_MISC, 50, "dns_get_key: bad UFQDN ID"));
@


1.15
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.14 2002/06/10 18:08:58 ho Exp $	*/
a13 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.14
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.13 2002/06/09 08:13:06 todd Exp $	*/
d105 1
a105 1
  memset (name, 0, MAXHOSTNAMELEN);
d124 1
a124 1
      snprintf (name, MAXHOSTNAMELEN, "%d.%d.%d.%d.in-addr.arpa.", ip4 >> 24,
d134 1
a134 1
      if ((id_len + 1) >= MAXHOSTNAMELEN)
d147 1
a147 1
      if ((id_len + sizeof (DNS_UFQDN_SEPARATOR)) >= MAXHOSTNAMELEN)
d160 1
a160 1
      snprintf (name, MAXHOSTNAMELEN, "%s%s", id + ISAKMP_ID_DATA_OFF,
@


1.13
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.12 2002/01/03 16:27:41 ho Exp $	*/
d267 1
a267 1
  rsa = LC (RSA_new, ());
d282 1
a282 1
	  LC (RSA_free, (rsa));
d292 1
a292 1
      LC (RSA_free, (rsa));
d296 1
a296 1
  rsa->e = LC (BN_bin2bn, (key + key_offset, e_len, NULL));
d301 1
a301 1
  rsa->n = LC (BN_bin2bn, (key + key_offset, keylen - key_offset, NULL));
d306 1
a306 1
	    LC (BN_num_bits, (rsa->n))));
@


1.12
log
@str[n]{cpy,cat} -> strl{cpy,cat}, sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.11 2001/08/23 14:17:08 aaron Exp $	*/
d98 1
a98 1
    case IKE_AUTH_PRE_SHARED: 
d124 1
a124 1
      snprintf (name, MAXHOSTNAMELEN, "%d.%d.%d.%d.in-addr.arpa.", ip4 >> 24, 
d176 1
a176 1
      LOG_DBG ((LOG_MISC, 30, "dns_get_key: no DNS responses (error %d)", 
d180 2
a181 2
  
  LOG_DBG ((LOG_MISC, 80, 
d183 1
a183 1
	    rr->rri_rdclass, rr->rri_rdtype, rr->rri_ttl, rr->rri_nrdatas, 
d185 1
a185 1
  
d193 1
a193 1
  
d200 1
a200 1
    } 
d204 1
a204 1
  /* 
@


1.11
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.10 2001/08/22 13:30:33 ho Exp $	*/
d124 1
a124 1
      sprintf (name, "%d.%d.%d.%d.in-addr.arpa.", ip4 >> 24, 
d160 2
a161 1
      sprintf (name, "%s%s", id + ISAKMP_ID_DATA_OFF, DNS_UFQDN_SEPARATOR);
@


1.10
log
@USER_FQDN ID support, untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.9 2001/08/17 10:35:51 ho Exp $	*/
d196 1
a196 1
      LOG_DBG ((LOG_MISC, 30, "dns_get_key: no KEY RRs recieved"));
@


1.9
log
@Rewrite to do lookups depending on ID type. IPv4 and FQDN only for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.8 2001/08/16 07:04:28 jakob Exp $	*/
d55 4
d77 1
a77 1
  u_int8_t *id;
d114 2
a115 2
  id -= ISAKMP_ID_TYPE_OFF;
  id_len += ISAKMP_ID_TYPE_OFF - ISAKMP_ID_DATA_OFF;
d128 5
d143 21
a163 1
      /* Some special handling here. */
a165 1
    case IPSEC_ID_IPV6_ADDR:
a166 1
      /* XXX not yet */
@


1.8
log
@add support for getrrsetbyname(3) from libc. ok ho@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.7 2001/07/01 06:03:34 angelos Exp $	*/
d67 1
a68 3
  struct hostent *hostent;
  struct sockaddr *dst;
  int ret, i;
d70 2
d73 3
d99 5
a103 4
  /* Get peer IP address */
  msg->transport->vtbl->get_dst (msg->transport, &dst);
  /* Get peer name and aliases */
  switch (dst->sa_family)
d105 1
a105 13
    case AF_INET:
      hostent =
	gethostbyaddr ((char *)&((struct sockaddr_in *)dst)->sin_addr,
		       sizeof (struct in_addr), PF_INET);
      break;
    case AF_INET6:
      hostent =
	gethostbyaddr ((char *)&((struct sockaddr_in6 *)dst)->sin6_addr,
		       sizeof (struct in6_addr), PF_INET6);
      break;
    default:
      log_print ("dns_get_key: unsupported protocol family %d",
		 dst->sa_family);
d109 5
a113 1
  if (!hostent)
d115 8
a122 2
#ifdef USE_DEBUG
      char *dst_str;
d124 8
a131 2
      if (sockaddr2text (dst, &dst_str, 0))
	dst_str = 0;
d133 3
a135 3
      LOG_DBG ((LOG_MISC, 30, 
		"dns_get_key: gethostbyaddr (%s) failed: %s", 
		dst_str ? dst_str : "<???>", hstrerror (h_errno)));
d137 3
a139 3
      if (dst_str)
	free (dst_str);
#endif
d143 2
a144 17
  /* Try host official name */
  LOG_DBG ((LOG_MISC, 50, "dns_get_key: trying KEY RR for %s", 
	    hostent->h_name));
  ret = getrrsetbyname (hostent->h_name, C_IN, T_KEY, 0, &rr);
  if (ret)
    {
      /* Try host aliases */
      i = 0;
      while (hostent->h_aliases[i] && ret)
	{
	  LOG_DBG ((LOG_MISC, 50, "dns_get_key: trying KEY RR for alias %s", 
		    hostent->h_aliases[i]));
	  ret = getrrsetbyname (hostent->h_aliases[i], C_IN, T_KEY, 0,
				      &rr);
	  i++;
	}
    }
@


1.7
log
@Remove inaccurate "Assumes IPv4" comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.6 2001/06/29 18:52:16 ho Exp $	*/
d36 3
d40 3
a42 2
#include <lwres/lwres.h>
#include <lwres/netdb.h>
d103 2
a104 2
	lwres_gethostbyaddr ((char *)&((struct sockaddr_in *)dst)->sin_addr,
			     sizeof (struct in_addr), PF_INET);
d108 2
a109 2
	lwres_gethostbyaddr ((char *)&((struct sockaddr_in6 *)dst)->sin6_addr,
			     sizeof (struct in6_addr), PF_INET6);
d126 2
a127 2
		"dns_get_key: lwres_gethostbyaddr (%s) failed: %s", 
		dst_str ? dst_str : "<???>", lwres_hstrerror (lwres_h_errno)));
d138 1
a138 1
  ret = lwres_getrrsetbyname (hostent->h_name, C_IN, T_KEY, 0, &rr);
d147 1
a147 1
	  ret = lwres_getrrsetbyname (hostent->h_aliases[i], C_IN, T_KEY, 0,
d169 1
a169 1
      lwres_freerrset (rr);
d177 1
a177 1
      lwres_freerrset (rr);
d218 1
a218 1
	  lwres_freerrset (rr);
d225 1
a225 1
  lwres_freerrset (rr);
@


1.6
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.5 2001/06/29 03:39:04 ho Exp $	*/
a59 1
/* XXX IPv4 specific */
@


1.5
log
@Don't assume IPv4. Initial IPv6 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.4 2001/06/27 03:31:40 angelos Exp $	*/
d94 1
a94 1
  msg->transport->vtbl->get_dst (msg->transport, &dst, &i);
@


1.4
log
@Consistently use "IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.3 2001/01/27 15:39:54 ho Exp $	*/
d49 1
d66 1
a66 1
  struct sockaddr_in *dst;
d94 1
a94 1
  msg->transport->vtbl->get_dst (msg->transport, (struct sockaddr **)&dst, &i);
d96 17
a112 2
  hostent = lwres_gethostbyaddr ((char *)&dst->sin_addr, 
				 sizeof (struct in_addr), PF_INET);
d116 6
d124 5
a128 2
		inet_ntoa (((struct sockaddr_in *)dst)->sin_addr),
		lwres_hstrerror (lwres_h_errno)));
@


1.3
log
@Call OpenSSL functions with LC (). Various style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: dnssec.c,v 1.1 2001/01/26 21:49:36 ho Exp $	*/
d167 1
a167 1
	  LOG_DBG ((LOG_MISC, 50, "dns_get_key: ignored non-IPSEC key"));
@


1.2
log
@(c) 2001
@
text
@d29 1
a29 3
#include <stdlib.h>
#include <string.h>

d33 3
a39 2
#include <openssl/rsa.h>

d42 1
d44 2
a49 3
#include "ipsec_num.h"
#include "dnssec.h"

d52 4
a55 4
  u_int16_t      flags;
  u_int8_t       protocol;
  u_int8_t       algorithm;
  u_int16_t      datalen;
d78 1
a78 1
      /* XXX Not yes. */
d80 1
a80 1
      return NULL;
d85 1
a85 1
      return NULL;
d89 1
a89 1
      return NULL;
d104 1
a104 1
      return NULL;
d121 1
a121 1
	  i ++;
d129 1
a129 1
      return NULL;
d142 1
a142 1
      return NULL;
d150 1
a150 1
      return NULL;
d153 1
a153 1
  memset (&key_rr, 0, sizeof (key_rr));
d159 1
a159 1
  for (i = 0; i < rr->rri_nrdatas && key_rr.datalen == 0; i ++)
d177 1
a177 1
      key_rr.datalen   = rr->rri_rdatas[i].rdi_length - 4;
d191 1
a191 1
	  return NULL;
d202 1
a202 1
    return NULL;
d218 2
a219 2
  rsa = RSA_new ();
  if (!rsa)
d233 1
a233 1
	  RSA_free (rsa);
d243 1
a243 1
      RSA_free (rsa);
d247 1
a247 1
  rsa->e = BN_bin2bn (key + key_offset, e_len, NULL);
d252 1
a252 1
  rsa->n = BN_bin2bn (key + key_offset, keylen - key_offset, NULL);
d257 1
a257 1
	    BN_num_bits (rsa->n)));
@


1.1
log
@Preliminary but working code to permit IKE authentication using DNSSEC
validated KEY records. Uses lwresd from the bind-9.1.0 port.
Enable by adding 'dnssec' to FEATURES.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2000 Håkan Olsson.  All rights reserved.
@

