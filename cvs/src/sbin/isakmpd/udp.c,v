head	1.95;
access;
symbols
	OPENBSD_6_1_BASE:1.95
	OPENBSD_6_0:1.95.0.34
	OPENBSD_6_0_BASE:1.95
	OPENBSD_5_9:1.95.0.30
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.95.0.32
	OPENBSD_5_8_BASE:1.95
	OPENBSD_5_7:1.95.0.24
	OPENBSD_5_7_BASE:1.95
	OPENBSD_5_6:1.95.0.28
	OPENBSD_5_6_BASE:1.95
	OPENBSD_5_5:1.95.0.26
	OPENBSD_5_5_BASE:1.95
	OPENBSD_5_4:1.95.0.22
	OPENBSD_5_4_BASE:1.95
	OPENBSD_5_3:1.95.0.20
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.95.0.18
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.16
	OPENBSD_5_0:1.95.0.14
	OPENBSD_5_0_BASE:1.95
	OPENBSD_4_9:1.95.0.12
	OPENBSD_4_9_BASE:1.95
	OPENBSD_4_8:1.95.0.10
	OPENBSD_4_8_BASE:1.95
	OPENBSD_4_7:1.95.0.6
	OPENBSD_4_7_BASE:1.95
	OPENBSD_4_6:1.95.0.8
	OPENBSD_4_6_BASE:1.95
	OPENBSD_4_5:1.95.0.4
	OPENBSD_4_5_BASE:1.95
	OPENBSD_4_4:1.95.0.2
	OPENBSD_4_4_BASE:1.95
	OPENBSD_4_3:1.94.0.4
	OPENBSD_4_3_BASE:1.94
	OPENBSD_4_2:1.94.0.2
	OPENBSD_4_2_BASE:1.94
	OPENBSD_4_1:1.93.0.6
	OPENBSD_4_1_BASE:1.93
	OPENBSD_4_0:1.93.0.4
	OPENBSD_4_0_BASE:1.93
	OPENBSD_3_9:1.93.0.2
	OPENBSD_3_9_BASE:1.93
	OPENBSD_3_8:1.91.0.2
	OPENBSD_3_8_BASE:1.91
	OPENBSD_3_7:1.84.0.2
	OPENBSD_3_7_BASE:1.84
	OPENBSD_3_6:1.79.0.2
	OPENBSD_3_6_BASE:1.79
	OPENBSD_3_5:1.67.0.2
	OPENBSD_3_5_BASE:1.67
	OPENBSD_3_4:1.64.0.2
	OPENBSD_3_4_BASE:1.64
	OPENBSD_3_3:1.58.0.2
	OPENBSD_3_3_BASE:1.58
	OPENBSD_3_2:1.56.0.2
	OPENBSD_3_2_BASE:1.56
	OPENBSD_3_1:1.54.0.2
	OPENBSD_3_1_BASE:1.54
	OPENBSD_3_0:1.52.0.2
	OPENBSD_3_0_BASE:1.52
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.95
date	2008.07.22.09.45.56;	author bluhm;	state Exp;
branches;
next	1.94;

1.94
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.93;

1.93
date	2006.02.02.14.33.53;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2005.10.27.08.19.59;	author hshoexer;	state Exp;
branches;
next	1.91;

1.91
date	2005.08.25.09.57.58;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2005.06.04.21.54.55;	author hshoexer;	state Exp;
branches;
next	1.89;

1.89
date	2005.06.01.23.03.56;	author cloder;	state Exp;
branches;
next	1.88;

1.88
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.87;

1.87
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.86;

1.86
date	2005.04.08.16.07.22;	author cloder;	state Exp;
branches;
next	1.85;

1.85
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2005.03.05.12.21.34;	author ho;	state Exp;
branches;
next	1.83;

1.83
date	2005.03.04.16.51.52;	author hshoexer;	state Exp;
branches;
next	1.82;

1.82
date	2005.03.04.16.09.59;	author hshoexer;	state Exp;
branches;
next	1.81;

1.81
date	2005.02.25.14.14.31;	author hshoexer;	state Exp;
branches;
next	1.80;

1.80
date	2004.12.14.10.17.28;	author mcbride;	state Exp;
branches;
next	1.79;

1.79
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2004.08.03.10.54.09;	author ho;	state Exp;
branches;
next	1.77;

1.77
date	2004.06.25.19.42.38;	author mcbride;	state Exp;
branches;
next	1.76;

1.76
date	2004.06.21.13.09.01;	author ho;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2004.06.17.19.36.36;	author hshoexer;	state Exp;
branches;
next	1.73;

1.73
date	2004.06.14.09.55.42;	author ho;	state Exp;
branches;
next	1.72;

1.72
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.71;

1.71
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2004.05.23.16.14.37;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.29.16.32.19;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.65;

1.65
date	2003.09.26.11.29.11;	author cedric;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.04.07.31.17;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.18.20.06.14;	author ho;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.18.18.16.34;	author ho;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2003.02.12.15.11.31;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2002.12.03.20.05.10;	author ho;	state Exp;
branches;
next	1.56;

1.56
date	2002.09.11.09.50.44;	author ho;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.01.07.44.22;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.03.16.27.41;	author ho;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.26.13.29.26;	author ho;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.09.14.53.05;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.25.22.13.27;	author niklas;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.23.23.32.35;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.23.23.11.02;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.13.14.33.35;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.12.15.48.44;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.11.10.13.32;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.11.09.57.30;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.06.14.37.11;	author ho;	state Exp;
branches;
next	1.43;

1.43
date	2001.07.05.12.36.57;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.03.07.54.20;	author ho;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.01.20.29.39;	author niklas;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.01.06.00.32;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.01.05.42.05;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.29.22.59.40;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.29.22.43.40;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.29.22.01.27;	author ho;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.29.20.45.39;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.29.20.38.16;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.29.20.22.58;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.29.19.41.43;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.29.18.52.17;	author ho;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.07.08.14.21;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.09.22.09.53;	author ho;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.06.22.17.21;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.27.12.03.36;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.26.11.08.08;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.23.12.56.51;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.16.23.27.23;	author niklas;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.08.03.07.23.55;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.07.22.04.58;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.08.08.43.16;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.25.17.23.42;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.01.02.46.19;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.26.15.22.17;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.10.01.14.08.05;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.06.05.23.11.19;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.06.05.22.54.42;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.04.30.11.46.59;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.04.27.21.09.01;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.04.19.20.55.09;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.04.05.21.00.08;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.03.31.23.47.12;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.03.02.15.12.00;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.02.26.03.51.33;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.12.22.02.25.15;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.12.22.01.46.04;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.12.21.01.02.27;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.23.2.1
date	2000.12.11.05.28.49;	author jason;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2001.05.08.12.45.26;	author ho;	state Exp;
branches;
next	;


desc
@@


1.95
log
@If isakmpd is started with -4 or -6, virtual_get_default() may
return NULL.  This happens if isakmpd is configured for the other
address family.  Add a NULL pointer check and initialize rv.
ok hshoexer
@
text
@/* $OpenBSD: udp.c,v 1.94 2007/04/16 13:01:39 moritz Exp $	 */
/* $EOM: udp.c,v 1.57 2001/01/26 10:09:57 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2000 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2003, 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <limits.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "conf.h"
#include "if.h"
#include "isakmp.h"
#include "log.h"
#include "message.h"
#include "monitor.h"
#include "transport.h"
#include "udp.h"
#include "util.h"
#include "virtual.h"

#define UDP_SIZE 65536

/* If a system doesn't have SO_REUSEPORT, SO_REUSEADDR will have to do. */
#ifndef SO_REUSEPORT
#define SO_REUSEPORT SO_REUSEADDR
#endif

/* These are reused by udp_encap.c, thus not 'static' here.  */
struct transport *udp_clone(struct transport *, struct sockaddr *);
int		  udp_fd_set(struct transport *, fd_set *, int);
int		  udp_fd_isset(struct transport *, fd_set *);
void		  udp_get_dst(struct transport *, struct sockaddr **);
void		  udp_get_src(struct transport *, struct sockaddr **);
char		 *udp_decode_ids(struct transport *);
void		  udp_remove(struct transport *);

static struct transport *udp_create(char *);
static void     udp_report(struct transport *);
static void     udp_handle_message(struct transport *);
static struct transport *udp_make(struct sockaddr *);
static int      udp_send_message(struct message *, struct transport *);

static struct transport_vtbl udp_transport_vtbl = {
	{0}, "udp_physical",
	udp_create,
	0,
	udp_remove,
	udp_report,
	udp_fd_set,
	udp_fd_isset,
	udp_handle_message,
	udp_send_message,
	udp_get_dst,
	udp_get_src,
	udp_decode_ids,
	udp_clone,
	0
};

char		*udp_default_port = 0;
int		 bind_family = 0;

void
udp_init(void)
{
	transport_method_add(&udp_transport_vtbl);
}

/* Create a UDP transport structure bound to LADDR just for listening.  */
static struct transport *
udp_make(struct sockaddr *laddr)
{
	struct udp_transport *t = 0;
	int	s, on, wildcardaddress = 0;
	char	*tstr;

	t = calloc(1, sizeof *t);
	if (!t) {
		log_print("udp_make: calloc (1, %lu) failed",
		    (unsigned long)sizeof *t);
		free(laddr);
		return 0;
	}
	t->src = laddr;

	s = socket(laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
	if (s == -1) {
		log_error("udp_make: socket (%d, %d, %d)", laddr->sa_family,
		    SOCK_DGRAM, IPPROTO_UDP);
		goto err;
	}
	/* Make sure we don't get our traffic encrypted.  */
	if (sysdep_cleartext(s, laddr->sa_family) == -1)
		goto err;

	/* Wildcard address ?  */
	switch (laddr->sa_family) {
	case AF_INET:
		if (((struct sockaddr_in *)laddr)->sin_addr.s_addr ==
		    INADDR_ANY)
			wildcardaddress = 1;
		break;
	case AF_INET6:
		if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)laddr)->sin6_addr))
			wildcardaddress = 1;
		break;
	}

	/*
	 * In order to have several bound specific address-port combinations
	 * with the same port SO_REUSEADDR is needed.  If this is a wildcard
	 * socket and we are not listening there, but only sending from it
	 * make sure it is entirely reuseable with SO_REUSEPORT.
	 */
	on = 1;
	if (setsockopt(s, SOL_SOCKET,
	    wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
	    (void *)&on, sizeof on) == -1) {
		log_error("udp_make: setsockopt (%d, %d, %d, %p, %lu)", s,
		    SOL_SOCKET, wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
		    &on, (unsigned long)sizeof on);
		goto err;
	}
	t->transport.vtbl = &udp_transport_vtbl;
	if (monitor_bind(s, t->src, SA_LEN(t->src))) {
		if (sockaddr2text(t->src, &tstr, 0))
			log_error("udp_make: bind (%d, %p, %lu)", s, &t->src,
			    (unsigned long)sizeof t->src);
		else {
			log_error("udp_make: bind (%d, %s, %lu)", s, tstr,
			    (unsigned long)sizeof t->src);
			free(tstr);
		}
		goto err;
	}
	t->s = s;
	if (sockaddr2text(t->src, &tstr, 0))
		LOG_DBG((LOG_MISC, 20, "udp_make: "
		    "transport %p socket %d family %d", t, s,
		    t->src->sa_family == AF_INET ? 4 : 6));
	else {
		LOG_DBG((LOG_MISC, 20, "udp_make: "
		    "transport %p socket %d ip %s port %d", t, s,
		    tstr, ntohs(sockaddr_port(t->src))));
		free (tstr);
	}
	transport_setup(&t->transport, 0);
	t->transport.flags |= TRANSPORT_LISTEN;
	return &t->transport;

err:
	if (s >= 0)
		close(s);
	if (t) {
		/* Already closed.  */
		t->s = -1;
		udp_remove(&t->transport);
	}
	return 0;
}

/* Clone a listen transport U, record a destination RADDR for outbound use.  */
struct transport *
udp_clone(struct transport *ut, struct sockaddr *raddr)
{
	struct udp_transport *u = (struct udp_transport *)ut;
	struct udp_transport *u2;
	struct transport *t;

	t = malloc(sizeof *u);
	if (!t) {
		log_error("udp_clone: malloc (%lu) failed",
		    (unsigned long)sizeof *u);
		return 0;
	}
	u2 = (struct udp_transport *)t;

	memcpy(u2, u, sizeof *u);

	u2->src = malloc(SA_LEN(u->src));
	if (!u2->src) {
		log_error("udp_clone: malloc (%lu) failed",
		    (unsigned long)SA_LEN(u->src));
		free(t);
		return 0;
	}
	memcpy(u2->src, u->src, SA_LEN(u->src));

	u2->dst = malloc(SA_LEN(raddr));
	if (!u2->dst) {
		log_error("udp_clone: malloc (%lu) failed",
		    (unsigned long)SA_LEN(raddr));
		free(u2->src);
		free(t);
		return 0;
	}
	memcpy(u2->dst, raddr, SA_LEN(raddr));

	t->flags &= ~TRANSPORT_LISTEN;
	transport_setup(t, 0);
	return t;
}

/*
 * Initialize an object of the UDP transport class.  Fill in the local
 * IP address and port information and create a server socket bound to
 * that specific port.  Add the polymorphic transport structure to the
 * system-wide pools of known ISAKMP transports.
 */
struct transport *
udp_bind(const struct sockaddr *addr)
{
	struct sockaddr *src;

	src = malloc(SA_LEN(addr));
	if (!src)
		return 0;

	memcpy(src, addr, SA_LEN(addr));
	return udp_make(src);
}

/*
 * NAME is a section name found in the config database.  Setup and return
 * a transport useable to talk to the peer specified by that name.
 */
static struct transport *
udp_create(char *name)
{
	struct virtual_transport *v;
	struct udp_transport *u;
	struct transport *rv = 0;
	struct sockaddr	*dst, *addr;
	char	*addr_str, *port_str;
	struct conf_list *addr_list = 0;
	struct conf_list_node *addr_node;

	port_str = conf_get_str(name, "Port");
	if (!port_str)
		port_str = udp_default_port;
	if (!port_str)
		port_str = UDP_DEFAULT_PORT_STR;

	addr_str = conf_get_str(name, "Address");
	if (!addr_str) {
		log_print("udp_create: no address configured for \"%s\"",
		    name);
		return 0;
	}
	if (text2sockaddr(addr_str, port_str, &dst, 0, 0)) {
		log_print("udp_create: address \"%s\" not understood",
		    addr_str);
		return 0;
	}
	addr_str = conf_get_str(name, "Local-address");
	if (!addr_str)
		addr_list = conf_get_list("General", "Listen-on");
	if (!addr_str && !addr_list) {
		v = virtual_get_default(dst->sa_family);
		if (!v) {
			log_print("udp_create: no virtual default transport "
			    "for address family %d", dst->sa_family);
			goto ret;
		}
		u = (struct udp_transport *)v->main;
		if (!u) {
			log_print("udp_create: no udp default transport "
			    "for address family %d", dst->sa_family);
			goto ret;
		}
		rv = udp_clone((struct transport *)u, dst);
		if (rv)
			rv->vtbl = &udp_transport_vtbl;
		goto ret;
	}

	if (addr_list) {
		for (addr_node = TAILQ_FIRST(&addr_list->fields);
		    addr_node; addr_node = TAILQ_NEXT(addr_node, link))
			if (text2sockaddr(addr_node->field,
			    port_str, &addr, 0, 0) == 0) {
				v = virtual_listen_lookup(addr);
				free(addr);
				if (v) {
					addr_str = addr_node->field;
					break;
				}
			}
		if (!addr_str) {
			log_print("udp_create: no matching listener found");
			goto ret;
		}
	}
	if (text2sockaddr(addr_str, port_str, &addr, 0, 0)) {
		log_print("udp_create: address \"%s\" not understood",
		    addr_str);
		goto ret;
	}

	v = virtual_listen_lookup(addr);
	free(addr);
	if (!v) {
		log_print("udp_create: %s:%s must exist as a listener too",
		    addr_str, port_str);
		goto ret;
	}
	rv = udp_clone(v->main, dst);
	if (rv)
		rv->vtbl = &udp_transport_vtbl;

ret:
	if (addr_list)
		conf_free_list(addr_list);
	free(dst);
	return rv;
}

void
udp_remove(struct transport *t)
{
	struct udp_transport *u = (struct udp_transport *)t;
	struct transport *p;

	free(u->src);
	free(u->dst);
	if ((t->flags & TRANSPORT_LISTEN) && u->s >= 0)
		close(u->s);

	for (p = LIST_FIRST(&transport_list); p && p != t; p =
	    LIST_NEXT(p, link))
		;
	if (p == t)
		LIST_REMOVE(t, link);

	LOG_DBG((LOG_TRANSPORT, 90, "udp_remove: removed transport %p", t));
	free(t);
}

/* Report transport-method specifics of the T transport. */
void
udp_report(struct transport *t)
{
	struct udp_transport *u = (struct udp_transport *)t;
	char		*src = NULL, *dst = NULL;
	in_port_t	 sport, dport;

	if (sockaddr2text(u->src, &src, 0))
		return;
	sport = sockaddr_port(u->src);

	if (!u->dst || sockaddr2text(u->dst, &dst, 0))
		dst = 0;
	dport = dst ? sockaddr_port(u->dst) : 0;

	LOG_DBG((LOG_REPORT, 0, "udp_report: fd %d src %s:%u dst %s:%u", u->s,
	    src, ntohs(sport), dst ? dst : "<none>", ntohs(dport)));

	free(dst);
	free(src);
}

/*
 * A message has arrived on transport T's socket.  If T is single-ended,
 * clone it into a double-ended transport which we will use from now on.
 * Package the message as we want it and continue processing in the message
 * module.
 */
static void
udp_handle_message(struct transport *t)
{
	struct udp_transport *u = (struct udp_transport *)t;
	u_int8_t        buf[UDP_SIZE];
	struct sockaddr_storage from;
	u_int32_t       len = sizeof from;
	ssize_t         n;
	struct message *msg;

	n = recvfrom(u->s, buf, UDP_SIZE, 0, (struct sockaddr *)&from, &len);
	if (n == -1) {
		log_error("recvfrom (%d, %p, %d, %d, %p, %p)", u->s, buf,
		    UDP_SIZE, 0, &from, &len);
		return;
	}

	if (t->virtual == (struct transport *)virtual_get_default(AF_INET) ||
	    t->virtual == (struct transport *)virtual_get_default(AF_INET6)) {
		t->virtual->vtbl->reinit();

		/*
		 * As we don't know the actual destination address of the
		 * packet, we can't really deal with it. So, just ignore it
		 * and hope we catch the retransmission.
		 */
		return;
	}

	/*
	 * Make a specialized UDP transport structure out of the incoming
	 * transport and the address information we got from recvfrom(2).
	 */
	t = t->virtual->vtbl->clone(t->virtual, (struct sockaddr *)&from);
	if (!t)
		return;

	msg = message_alloc(t, buf, n);
	if (!msg) {
		log_error("failed to allocate message structure, dropping "
		    "packet received on transport %p", u);
		t->vtbl->remove(t);
		return;
	}
	message_recv(msg);
}

/* Physically send the message MSG over its associated transport.  */
static int
udp_send_message(struct message *msg, struct transport *t)
{
	struct udp_transport *u = (struct udp_transport *)t;
	ssize_t         n;
	struct msghdr   m;

	/*
	 * Sending on connected sockets requires that no destination address is
	 * given, or else EISCONN will occur.
	 */
	m.msg_name = (caddr_t) u->dst;
	m.msg_namelen = SA_LEN(u->dst);
	m.msg_iov = msg->iov;
	m.msg_iovlen = msg->iovlen;
	m.msg_control = 0;
	m.msg_controllen = 0;
	m.msg_flags = 0;
	n = sendmsg(u->s, &m, 0);
	if (n == -1) {
		/* XXX We should check whether the address has gone away */
		log_error("sendmsg (%d, %p, %d)", u->s, &m, 0);
		return -1;
	}
	return 0;
}

int
udp_fd_set(struct transport *t, fd_set *fds, int bit)
{
	struct udp_transport		*u = (struct udp_transport *)t;

	if (bit)
		FD_SET(u->s, fds);
	else
		FD_CLR(u->s, fds);

	return u->s + 1;
}

int
udp_fd_isset(struct transport *t, fd_set *fds)
{
	struct udp_transport		*u = (struct udp_transport *)t;

	return FD_ISSET(u->s, fds);
}

/*
 * Get transport T's peer address and stuff it into the sockaddr pointed
 * to by DST.
 */
void
udp_get_dst(struct transport *t, struct sockaddr **dst)
{
	*dst = ((struct udp_transport *)t)->dst;
}

/*
 * Get transport T's local address and stuff it into the sockaddr pointed
 * to by SRC.  Put its length into SRC_LEN.
 */
void
udp_get_src(struct transport *t, struct sockaddr **src)
{
	*src = ((struct udp_transport *)t)->src;
}

char *
udp_decode_ids(struct transport *t)
{
	struct sockaddr *src, *dst;
	static char     result[1024];
	char            idsrc[256], iddst[256];

	t->vtbl->get_src(t, &src);
	t->vtbl->get_dst(t, &dst);

	if (getnameinfo(src, SA_LEN(src), idsrc, sizeof idsrc, NULL, 0,
	    NI_NUMERICHOST) != 0) {
		log_print("udp_decode_ids: getnameinfo () failed for 'src'");
		strlcpy(idsrc, "<error>", 256);
	}
	if (getnameinfo(dst, SA_LEN(dst), iddst, sizeof iddst, NULL, 0,
	    NI_NUMERICHOST) != 0) {
		log_print("udp_decode_ids: getnameinfo () failed for 'dst'");
		strlcpy(iddst, "<error>", 256);
	}

	snprintf(result, sizeof result, "src: %s dst: %s", idsrc, iddst);
	return result;
}
@


1.94
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.93 2006/02/02 14:33:53 hshoexer Exp $	 */
d270 1
a270 1
	struct transport *rv;
d298 5
a303 1

d305 2
a306 7
			log_print("udp_create: no default transport");
			rv = 0;
			goto ret;
		} else {
			rv = udp_clone((struct transport *)u, dst);
			if (rv)
				rv->vtbl = &udp_transport_vtbl;
d309 4
a328 1
			rv = 0;
a334 1
		rv = 0;
a342 1
		rv = 0;
@


1.93
log
@Small cleanup to avoid gotos, from Andrey Matveev.
ok moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.92 2005/10/27 08:19:59 hshoexer Exp $	 */
d362 2
a363 4
	if (u->src)
		free(u->src);
	if (u->dst)
		free(u->dst);
d396 2
a397 4
	if (dst)
		free(dst);
	if (src)
		free(src);
@


1.92
log
@Do not touch LIST_* macro internals.

with otto@@, ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.91 2005/08/25 09:57:58 markus Exp $	 */
d388 1
a388 1
		goto ret;
a397 1
ret:
@


1.91
log
@read the information from the INADDR_ANY socket and do not loop if
a new IP appears (cf udp.c, rev 1.74), ok ho@@ hshoexer@@ cloder@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.90 2005/06/04 21:54:55 hshoexer Exp $	 */
d360 1
d368 5
a372 1
	if (t->link.le_prev)
@


1.90
log
@undo last commit, all memory is already freed by udp_remove()

ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.89 2005/06/01 23:03:56 cloder Exp $	 */
d422 13
@


1.89
log
@Fix memory leaks. OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.88 2005/04/08 23:15:26 hshoexer Exp $	 */
a195 1
		free(t);
@


1.88
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.87 2005/04/08 22:32:10 cloder Exp $	 */
d196 1
@


1.87
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.86 2005/04/08 16:07:22 cloder Exp $	 */
a53 1
#include "sysdep.h"
d163 1
a163 1
	if (monitor_bind(s, t->src, sysdep_sa_len(t->src))) {
d218 1
a218 1
	u2->src = malloc(sysdep_sa_len(u->src));
d220 2
a221 2
		log_error("udp_clone: malloc (%d) failed",
		    sysdep_sa_len(u->src));
d225 1
a225 1
	memcpy(u2->src, u->src, sysdep_sa_len(u->src));
d227 1
a227 1
	u2->dst = malloc(sysdep_sa_len(raddr));
d229 2
a230 2
		log_error("udp_clone: malloc (%d) failed",
		    sysdep_sa_len(raddr));
d235 1
a235 1
	memcpy(u2->dst, raddr, sysdep_sa_len(raddr));
d253 1
a253 1
	src = malloc(sysdep_sa_len((struct sockaddr *)addr));
d257 1
a257 1
	memcpy(src, addr, sysdep_sa_len((struct sockaddr *)addr));
d453 1
a453 1
	m.msg_namelen = sysdep_sa_len(u->dst);
d519 1
a519 1
	if (getnameinfo(src, sysdep_sa_len(src), idsrc, sizeof idsrc, NULL, 0,
d524 1
a524 1
	if (getnameinfo(dst, sysdep_sa_len(dst), iddst, sizeof iddst, NULL, 0,
@


1.86
log
@Remove references to LINUX_IPSEC
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.85 2005/04/04 19:31:11 deraadt Exp $	 */
a46 2

#include "sysdep.h"
@


1.85
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.84 2005/03/05 12:21:34 ho Exp $	 */
a36 1
#ifndef linux
a37 1
#endif
@


1.84
log
@No need for err.h. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.83 2005/03/04 16:51:52 hshoexer Exp $	 */
d319 1
a319 1
		     addr_node; addr_node = TAILQ_NEXT(addr_node, link))
d321 1
a321 2
			    port_str, &addr, 0, 0)
			    == 0) {
d430 1
a430 1
         */
d456 1
a456 1
         */
@


1.83
log
@remove unused function udp_decode_port(), add modified version as text2port() to
utilities.

ok cloder ho
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.81 2005/02/25 14:14:31 hshoexer Exp $	 */
a43 1
#include <err.h>
@


1.82
log
@remove unused variable.

noticed by and ok markus
@
text
@a85 3
#if 0
static in_port_t udp_decode_port(char *);
#endif
a539 30

#if 0
/*
 * Take a string containing an ext representation of port and return a
 * binary port number in host byte order.  Return zero if anything goes wrong.
 * XXX Currently unused.
 */
static in_port_t
udp_decode_port(char *port_str)
{
	char           *port_str_end;
	long            port_long;
	struct servent *service;

	port_long = ntohl(strtol(port_str, &port_str_end, 0));
	if (port_str == port_str_end) {
		service = getservbyname(port_str, "udp");
		if (!service) {
			log_print("udp_decode_port: service \"%s\" unknown",
			    port_str);
			return 0;
		}
		return ntohs(service->s_port);
	} else if (port_long < 1 || port_long > 65535) {
		log_print("udp_decode_port: port %ld out of range", port_long);
		return 0;
	}
	return port_long;
}
#endif
@


1.81
log
@Zap -P option.  It has never done anything.  While there tweak descripton of
-N.

zap -P ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.80 2004/12/14 10:17:28 mcbride Exp $	 */
d279 1
a279 1
	struct transport *rv, *t;
a354 1
	t = (struct transport *)v;
@


1.80
log
@Allow the Address, Network, or Netmask values of the <IPsec-ID> to be
specified with an interface name (in which case the first address is used)
or the keyword 'default' (in which case the address is selected based on the
default route). eg:

[roadwarrior-ip]
ID-type=                IPV4_ADDR
Address=                default

ok ho@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.79 2004/08/08 19:11:06 deraadt Exp $	 */
d108 1
a108 2
char		*udp_bind_port = 0;
int		bind_family = 0;
@


1.79
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.78 2004/08/03 10:54:09 ho Exp $	 */
d298 1
a298 1
	if (text2sockaddr(addr_str, port_str, &dst)) {
d325 2
a326 1
			if (text2sockaddr(addr_node->field, port_str, &addr)
d341 1
a341 1
	if (text2sockaddr(addr_str, port_str, &addr)) {
@


1.78
log
@Rewrite the transport reference count code to avoid leaks.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.77 2004/06/25 19:42:38 mcbride Exp $	 */
d346 1
a346 1
	
@


1.77
log
@Remove HAVE_GETNAMEINFO alternate code. Compiled binary is unchanged.

ok msf@@ hshoexer@@ itojun@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.76 2004/06/21 13:09:01 ho Exp $	 */
d79 1
a81 1
static void     udp_remove(struct transport *);
a195 1
	transport_reference(&t->transport);
d357 1
a357 1
	if (rv) {
a358 2
		transport_reference(rv->virtual);
	}
d376 6
a381 6
	if (t->flags & TRANSPORT_LISTEN) {
		if (u->s >= 0)
			close(u->s);
		if (u->link.le_prev)
			LIST_REMOVE(u, link);
	}
@


1.76
log
@Port floating (500->4500) for p1 and p2 exchanges.
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.75 2004/06/20 15:24:05 ho Exp $	 */
a532 1
#ifdef HAVE_GETNAMEINFO
a542 4
#else
	strlcpy(idsrc, inet_ntoa(src->sin_addr), 256);
	strlcpy(iddst, inet_ntoa(dst->sin_addr), 256);
#endif	/* HAVE_GETNAMEINFO */
@


1.75
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.74 2004/06/17 19:36:36 hshoexer Exp $	 */
d74 5
a78 3
void		 udp_get_dst(struct transport *, struct sockaddr **);
void		 udp_get_src(struct transport *, struct sockaddr **);
char		*udp_decode_ids(struct transport *);
d96 2
a97 2
	0,
	0,
d480 21
@


1.74
log
@Plug a memleak. Found and fixed (and some cleanup) by Patrick Latifi.
Thanks!

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.73 2004/06/14 09:55:42 ho Exp $	 */
d7 1
d63 1
d72 5
a76 6
struct udp_transport {
	struct transport transport;
	struct sockaddr *src, *dst;
	int             s;
	LIST_ENTRY(udp_transport) link;
};
a77 1
static struct transport *udp_clone(struct udp_transport *, struct sockaddr *);
a78 1
static void     udp_reinit(void);
a80 2
static int      udp_fd_set(struct transport *, fd_set *, int);
static int      udp_fd_isset(struct transport *, fd_set *);
d83 1
a83 4
static int      udp_send_message(struct message *);
static void     udp_get_dst(struct transport *, struct sockaddr **);
static void     udp_get_src(struct transport *, struct sockaddr **);
static char    *udp_decode_ids(struct transport *);
d89 1
a89 1
	{0}, "udp",
d91 1
a91 1
	udp_reinit,
d94 2
a95 2
	udp_fd_set,
	udp_fd_isset,
d100 3
a102 1
	udp_decode_ids
a104 5
/* A list of UDP transports we listen for messages on.  */
static
LIST_HEAD(udp_listen_list, udp_transport) udp_listen_list;

static struct transport *default_transport, *default_transport6;
d109 2
a110 3
/* Find an UDP transport listening on ADDR:PORT.  */
static struct udp_transport *
udp_listen_lookup(struct sockaddr *addr)
d112 1
a112 7
	struct udp_transport *u;

	for (u = LIST_FIRST(&udp_listen_list); u; u = LIST_NEXT(u, link))
		if (sysdep_sa_len(u->src) == sysdep_sa_len(addr) &&
		    memcmp(u->src, addr, sysdep_sa_len(addr)) == 0)
			return u;
	return 0;
d120 2
a121 1
	int		s, on, wildcardaddress = 0;
d125 1
a125 1
		log_print("udp_make: malloc (%lu) failed",
a171 2
		char	*tstr;

d183 11
a193 1
	transport_add(&t->transport);
d210 2
a211 2
static struct transport *
udp_clone(struct udp_transport *u, struct sockaddr *raddr)
d213 1
d247 1
a247 1
	transport_add(t);
d257 1
a257 1
static struct transport *
a270 165
 * When looking at a specific network interface address, if it's an INET one,
 * create an UDP server socket bound to it.
 * Return 0 if successful, -1 otherwise.
 */
static int
udp_bind_if(char *ifname, struct sockaddr *if_addr, void *arg)
{
	char	*port = (char *) arg, *addr_str, *ep;
	struct sockaddr_storage saddr_st;
	struct sockaddr *saddr = (struct sockaddr *) & saddr_st;
	struct conf_list *listen_on;
	struct udp_transport *u;
	struct conf_list_node *address;
	struct sockaddr *addr;
	struct transport *t;
	struct ifreq    flags_ifr;
	int		s, error;
	long		lport;

	/*
	 * Well, UDP is an internet protocol after all so drop other ifreqs.
	*/
	if ((if_addr->sa_family != AF_INET ||
	    sysdep_sa_len(if_addr) != sizeof(struct sockaddr_in)) &&
	    (if_addr->sa_family != AF_INET6 ||
	    sysdep_sa_len(if_addr) != sizeof(struct sockaddr_in6)))
		return 0;

	/*
	 * Only create sockets for families we should listen to.
	 */
	if (bind_family) {
		switch (if_addr->sa_family) {
		case AF_INET:
			if ((bind_family & BIND_FAMILY_INET4) == 0)
				return 0;
			break;
		case AF_INET6:
			if ((bind_family & BIND_FAMILY_INET6) == 0)
				return 0;
			break;
		default:
			return 0;
		}
	}

	/*
	 * These special addresses are not useable as they have special meaning
	 * in the IP stack.
	 */
	if (if_addr->sa_family == AF_INET &&
	    (((struct sockaddr_in *)if_addr)->sin_addr.s_addr == INADDR_ANY ||
	    (((struct sockaddr_in *)if_addr)->sin_addr.s_addr == INADDR_NONE)))
		return 0;

	/*
	 * Go through the list of transports and see if we already have this
	 * address bound. If so, unmark the transport and skip it; this allows
	 * us to call this function when we suspect a new address has appeared.
	 */
	if (sysdep_sa_len(if_addr) > sizeof saddr_st)
		return 0;
	memcpy(saddr, if_addr, sysdep_sa_len(if_addr));
	switch (saddr->sa_family) { /* Add the port number to the sockaddr. */
	case AF_INET:
		((struct sockaddr_in *)saddr)->sin_port =
		    htons(strtol(port, &ep, 10));
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)saddr)->sin6_port =
		    htons(strtol(port, &ep, 10));
		break;
	}

	if ((u = udp_listen_lookup(saddr)) != 0) {
		u->transport.flags &= ~TRANSPORT_MARK;
		return 0;
	}
	/* Don't bother with interfaces that are down.  */
	s = socket(if_addr->sa_family, SOCK_DGRAM, 0);
	if (s == -1) {
		log_error("udp_bind_if: socket (%d, SOCK_DGRAM, 0) failed",
		    if_addr->sa_family);
		return -1;
	}
	strlcpy(flags_ifr.ifr_name, ifname, sizeof flags_ifr.ifr_name);
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t) & flags_ifr) == -1) {
		log_error("udp_bind_if: ioctl (%d, SIOCGIFFLAGS, ...) failed",
		    s);
		return -1;
	}
	close(s);
	if (!(flags_ifr.ifr_flags & IFF_UP))
		return 0;

	/*
	 * Set port.
	 * XXX Use getservbyname too.
	 */
	lport = strtol(port, &ep, 10);
	if (*ep != '\0' || lport < (long) 0 || lport > (long) USHRT_MAX) {
		log_print("udp_bind_if: "
		    "port string \"%s\" not convertible to in_port_t", port);
		return -1;
	}
	switch (if_addr->sa_family) {
	case AF_INET:
		((struct sockaddr_in *)if_addr)->sin_port = htons(lport);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)if_addr)->sin6_port = htons(lport);
		break;
	default:
		log_print("udp_bind_if: unsupported protocol family %d",
		    if_addr->sa_family);
		break;
	}

	/*
	 * If we are explicit about what addresses we can listen to, be sure
	 * to respect that option.
	 * This is quite wasteful redoing the list-run for every interface,
	 * but who cares?  This is not an operation that needs to be fast.
	 */
	listen_on = conf_get_list("General", "Listen-on");
	if (listen_on) {
		for (address = TAILQ_FIRST(&listen_on->fields); address;
		    address = TAILQ_NEXT(address, link)) {
			if (text2sockaddr(address->field, port, &addr)) {
				log_print("udp_bind_if: invalid address %s "
				    "in \"Listen-on\"", address->field);
				continue;
			}
			/* If found, take the easy way out. */
			if (memcmp(addr, if_addr, sysdep_sa_len(addr)) == 0) {
				free(addr);
				break;
			}
			free(addr);
		}
		conf_free_list(listen_on);

		/*
		 * If address is zero then we did not find the address among
		 * the ones we should listen to.
		 * XXX We do not discover if we do not find our listen
		 * addresses...  Maybe this should be the other way round.
		 */
		if (!address)
			return 0;
	}
	t = udp_bind(if_addr);
	if (!t) {
		error = sockaddr2text(if_addr, &addr_str, 0);
		log_print("udp_bind_if: failed to create a socket on %s:%s",
		    error ? "unknown" : addr_str, port);
		if (!error)
			free(addr_str);
		return -1;
	}
	LIST_INSERT_HEAD(&udp_listen_list, (struct udp_transport *)t, link);
	return 0;
}

/*
d277 1
d279 2
a280 2
	struct transport *rv;
	struct sockaddr *dst, *addr;
d282 2
d289 1
a289 1
		port_str = "500";
d304 6
a309 4
		addr_str = conf_get_str("General", "Listen-on");
	if (!addr_str) {
		if ((dst->sa_family == AF_INET && !default_transport) ||
		    (dst->sa_family == AF_INET6 && !default_transport6)) {
d314 22
a335 4
			/* XXX Ugly! */
			rv = udp_clone((struct udp_transport *)
			    (dst->sa_family == AF_INET ? default_transport :
			    default_transport6), dst);
d345 2
a346 1
	u = udp_listen_lookup(addr);
d348 1
a348 1
	if (!u) {
d354 6
a359 1
	rv = udp_clone(u, dst);
d362 2
a379 4
		if (t == default_transport)
			default_transport = 0;
		else if (t == default_transport6)
			default_transport6 = 0;
d391 2
a392 1
	char	*src = NULL, *dst = NULL;
d396 1
d400 1
d402 2
a403 2
	LOG_DBG((LOG_REPORT, 0, "udp_report: fd %d src %s dst %s", u->s, src,
	    dst ? dst : "<none>"));
a412 159
 * Probe the interface list and determine what new interfaces have
 * appeared.
 *
 * At the same time, we try to determine whether existing interfaces have
 * been rendered invalid; we do this by marking all UDP transports before
 * we call udp_bind_if () through if_map (), and then releasing those
 * transports that have not been unmarked.
 */
static void
udp_reinit(void)
{
	struct udp_transport *u, *u2;
	char		*port;

	/* Initialize the protocol and port numbers. */
	port = udp_default_port ? udp_default_port : "500";

	/* Mark all UDP transports, except the default ones. */
	for (u = LIST_FIRST(&udp_listen_list); u; u = LIST_NEXT(u, link))
		if (&u->transport != default_transport &&
		    &u->transport != default_transport6)
			u->transport.flags |= TRANSPORT_MARK;

	/* Re-probe interface list. */
	if (if_map(udp_bind_if, port) == -1)
		log_print("udp_init: Could not bind the ISAKMP UDP port %s "
		    "on all interfaces", port);

	/*
	 * Release listening transports for local addresses that no
	 * longer exist. udp_bind_if () will have left those still marked.
         */
	u = LIST_FIRST(&udp_listen_list);
	while (u) {
		u2 = LIST_NEXT(u, link);

		if (u->transport.flags & TRANSPORT_MARK) {
			LIST_REMOVE(u, link);
			transport_release(&u->transport);
		}
		u = u2;
	}
}

/*
 * Find out the magic numbers for the UDP protocol as well as the UDP port
 * to use.  Setup an UDP server for each address of this machine, and one
 * for the generic case when we are the initiator.
 */
void
udp_init(void)
{
	struct sockaddr_storage dflt_stor;
	struct sockaddr_in *dflt = (struct sockaddr_in *) & dflt_stor;
	struct conf_list *listen_on;
	char           *port;
	long            lport;
	char           *ep;

	/* Initialize the protocol and port numbers.  */
	port = udp_default_port ? udp_default_port : "500";

	LIST_INIT(&udp_listen_list);

	transport_method_add(&udp_transport_vtbl);

	/* Bind the ISAKMP UDP port on all network interfaces we have.  */
	if (if_map(udp_bind_if, port) == -1)
		log_fatal("udp_init: Could not bind the ISAKMP UDP port %s "
		    "on all interfaces", port);

	/* Only listen to the specified address if Listen-on is configured */
	listen_on = conf_get_list("General", "Listen-on");
	if (listen_on) {
		LOG_DBG((LOG_TRANSPORT, 50,
		    "udp_init: not binding ISAKMP UDP port to INADDR_ANY"));
		conf_free_list(listen_on);
		return;
	}
	/*
	 * Get port.
	 * XXX Use getservbyname too.
         */
	lport = strtol(port, &ep, 10);
	if (*ep != '\0' || lport < (long) 0 || lport > (long) USHRT_MAX) {
		log_print("udp_init: port string \"%s\" not convertible to "
		    "in_port_t", port);
		return;
	}
	/*
	 * Bind to INADDR_ANY in case of new addresses popping up.  Packet
	 * reception on this transport is taken as a hint to reprobe the
	 * interface list.
         */
	if (!bind_family || (bind_family & BIND_FAMILY_INET4)) {
		memset(&dflt_stor, 0, sizeof dflt_stor);
		dflt->sin_family = AF_INET;
#if !defined (LINUX_IPSEC)
		((struct sockaddr_in *)dflt)->sin_len =
		    sizeof(struct sockaddr_in);
#endif
		((struct sockaddr_in *)dflt)->sin_port = htons(lport);

		default_transport = udp_bind((struct sockaddr *)&dflt_stor);
		if (!default_transport) {
			log_error("udp_init: could not allocate default "
			    "IPv4 ISAKMP UDP port");
			return;
		}
		LIST_INSERT_HEAD(&udp_listen_list,
		    (struct udp_transport *)default_transport, link);
	}
	if (!bind_family || (bind_family & BIND_FAMILY_INET6)) {
		memset(&dflt_stor, 0, sizeof dflt_stor);
		dflt->sin_family = AF_INET6;
#if !defined (LINUX_IPSEC)
		((struct sockaddr_in6 *)dflt)->sin6_len =
		    sizeof(struct sockaddr_in6);
#endif
		((struct sockaddr_in6 *)dflt)->sin6_port = htons(lport);

		default_transport6 = udp_bind((struct sockaddr *)&dflt_stor);
		if (!default_transport6) {
			log_error("udp_init: could not allocate default "
			    "IPv6 ISAKMP UDP port");
			return;
		}
		LIST_INSERT_HEAD(&udp_listen_list,
		    (struct udp_transport *)default_transport6, link);
	}
}

/*
 * Set transport T's socket in FDS, return a value useable by select(2)
 * as the number of file descriptors to check.
 */
static int
udp_fd_set(struct transport *t, fd_set *fds, int bit)
{
	struct udp_transport *u = (struct udp_transport *)t;

	if (bit)
		FD_SET(u->s, fds);
	else
		FD_CLR(u->s, fds);

	return u->s + 1;
}

/* Check if transport T's socket is set in FDS.  */
static int
udp_fd_isset(struct transport *t, fd_set *fds)
{
	struct udp_transport *u = (struct udp_transport *)t;

	return FD_ISSET(u->s, fds);
}

/*
d421 1
a421 1
	struct udp_transport *u = (struct udp_transport *) t;
d428 1
a428 1
	n = recvfrom(u->s, buf, UDP_SIZE, 0, (struct sockaddr *) & from, &len);
a434 14
	 * If we received the packet over the default transports, reprobe the
	 * interfaces.
         */
	if (t == default_transport || t == default_transport6) {
		udp_reinit();

		/*
		 * As we don't know the actual destination address of the
		 * packet, we can't really deal with it. So, just ignore it
		 * and hope we catch the retransmission.
	         */
		return;
	}
	/*
d438 1
a438 1
	t = udp_clone(u, (struct sockaddr *)&from);
d446 1
d454 1
a454 1
udp_send_message(struct message *msg)
d456 1
a456 1
	struct udp_transport *u = (struct udp_transport *)msg->transport;
d484 1
a484 1
static void
d494 1
a494 1
static void
d500 1
a500 1
static char *
d503 1
d507 3
d511 2
a512 3
	if (getnameinfo(((struct udp_transport *)t)->src,
	    sysdep_sa_len(((struct udp_transport *)t)->src),
	    idsrc, sizeof idsrc, NULL, 0, NI_NUMERICHOST) != 0) {
d516 2
a517 3
	if (getnameinfo(((struct udp_transport *)t)->dst,
	    sysdep_sa_len(((struct udp_transport *)t)->dst),
	    iddst, sizeof iddst, NULL, 0, NI_NUMERICHOST) != 0) {
d522 3
a524 5
	strlcpy(idsrc, inet_ntoa(((struct udp_transport *)t)->src.sin_addr),
	    256);
	strlcpy(iddst, inet_ntoa(((struct udp_transport *)t)->dst.sin_addr),
	    256);
#endif				/* HAVE_GETNAMEINFO */
@


1.73
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.72 2004/06/09 14:02:44 ho Exp $	 */
d142 1
d145 2
a185 1
	t->src = laddr;
d266 1
a266 1
	struct sockaddr *src = malloc(sysdep_sa_len((struct sockaddr *)addr));
d268 1
d535 1
a535 1
	char	*src, *dst;
@


1.72
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.71 2004/05/23 18:17:56 hshoexer Exp $	 */
d458 2
a459 1
		log_print("udp_create: no address configured for \"%s\"", name);
@


1.71
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.70 2004/05/23 16:14:37 deraadt Exp $	 */
d715 1
a715 1
udp_handle_message(struct transport * t)
@


1.70
log
@remove excessive monitor_ prefixes
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.69 2004/04/15 18:39:26 deraadt Exp $	 */
d140 2
a141 1
		log_print("udp_make: malloc (%lu) failed", (unsigned long) sizeof *t);
d157 2
a158 1
		if (((struct sockaddr_in *)laddr)->sin_addr.s_addr == INADDR_ANY)
d169 3
a171 3
	 * with the same port SO_REUSEADDR is needed.
	 * If this is a wildcard socket and we are not listening there, but only
	 * sending from it make sure it is entirely reuseable with SO_REUSEPORT.
d176 4
a179 4
	    (void *) &on, sizeof on) == -1) {
		log_error("udp_make: setsockopt (%d, %d, %d, %p, %lu)", s, SOL_SOCKET,
		    wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
		    &on, (unsigned long) sizeof on);
d189 1
a189 1
			    (unsigned long) sizeof t->src);
d192 1
a192 1
			    (unsigned long) sizeof t->src);
d223 2
a224 1
		log_error("udp_clone: malloc (%lu) failed", (unsigned long) sizeof *u);
d227 1
a227 1
	u2 = (struct udp_transport *) t;
d233 2
a234 1
		log_error("udp_clone: malloc (%d) failed", sysdep_sa_len(u->src));
d242 2
a243 1
		log_error("udp_clone: malloc (%d) failed", sysdep_sa_len(raddr));
d264 1
a264 1
	struct sockaddr *src = malloc(sysdep_sa_len((struct sockaddr *) addr));
d269 1
a269 1
	memcpy(src, addr, sysdep_sa_len((struct sockaddr *) addr));
d325 2
a326 2
	    (((struct sockaddr_in *) if_addr)->sin_addr.s_addr == INADDR_ANY ||
	    (((struct sockaddr_in *) if_addr)->sin_addr.s_addr == INADDR_NONE)))
d337 1
a337 1
	switch (saddr->sa_family) {	/* Add the port number to the sockaddr. */
d339 1
a339 1
		((struct sockaddr_in *) saddr)->sin_port =
d343 1
a343 1
		((struct sockaddr_in6 *) saddr)->sin6_port =
d361 2
a362 1
		log_error("udp_bind_if: ioctl (%d, SIOCGIFFLAGS, ...) failed", s);
d381 1
a381 1
		((struct sockaddr_in *) if_addr)->sin_port = htons(lport);
d384 1
a384 1
		((struct sockaddr_in6 *) if_addr)->sin6_port = htons(lport);
d403 2
a404 2
				log_print("udp_bind_if: invalid address %s in \"Listen-on\"",
				    address->field);
d417 4
a420 4
		 * If address is zero then we did not find the address among the ones
		 * we should listen to.
		 * XXX We do not discover if we do not find our listen addresses...
		 * Maybe this should be the other way round.
d434 1
a434 1
	LIST_INSERT_HEAD(&udp_listen_list, (struct udp_transport *) t, link);
d462 2
a463 1
		log_print("udp_create: address \"%s\" not understood", addr_str);
d484 2
a485 1
		log_print("udp_create: address \"%s\" not understood", addr_str);
d492 2
a493 2
		log_print("udp_create: %s:%s must exist as a listener too", addr_str,
		    port_str);
d505 1
a505 1
udp_remove(struct transport * t)
d507 1
a507 1
	struct udp_transport *u = (struct udp_transport *) t;
d528 1
a528 1
udp_report(struct transport * t)
d530 1
a530 1
	struct udp_transport *u = (struct udp_transport *) t;
d575 2
a576 2
		log_print("udp_init: Could not bind the ISAKMP UDP port %s on all "
		    "interfaces", port);
d618 2
a619 2
		log_fatal("udp_init: Could not bind the ISAKMP UDP port %s on all "
		    "interfaces", port);
d635 2
a636 2
		log_print("udp_init: port string \"%s\" not convertible to in_port_t",
		    port);
d640 2
a641 2
	 * Bind to INADDR_ANY in case of new addresses popping up.
	 * Packet reception on this transport is taken as a hint to reprobe the
d648 2
a649 1
		((struct sockaddr_in *) dflt)->sin_len = sizeof(struct sockaddr_in);
d651 1
a651 1
		((struct sockaddr_in *) dflt)->sin_port = htons(lport);
d653 1
a653 1
		default_transport = udp_bind((struct sockaddr *) & dflt_stor);
d660 1
a660 1
		    (struct udp_transport *) default_transport, link);
d666 2
a667 1
		((struct sockaddr_in6 *) dflt)->sin6_len = sizeof(struct sockaddr_in6);
d669 1
a669 1
		((struct sockaddr_in6 *) dflt)->sin6_port = htons(lport);
d671 1
a671 1
		default_transport6 = udp_bind((struct sockaddr *) & dflt_stor);
d678 1
a678 1
		    (struct udp_transport *) default_transport6, link);
d687 1
a687 1
udp_fd_set(struct transport * t, fd_set * fds, int bit)
d689 1
a689 1
	struct udp_transport *u = (struct udp_transport *) t;
d701 1
a701 1
udp_fd_isset(struct transport * t, fd_set * fds)
d703 1
a703 1
	struct udp_transport *u = (struct udp_transport *) t;
d726 2
a727 2
		log_error("recvfrom (%d, %p, %d, %d, %p, %p)", u->s, buf, UDP_SIZE, 0,
		    &from, &len);
d738 3
a740 3
		 * As we don't know the actual destination address of the packet,
		 * we can't really deal with it. So, just ignore it and hope we
		 * catch the retransmission.
d748 1
a748 1
	t = udp_clone(u, (struct sockaddr *) & from);
d754 2
a755 2
		log_error("failed to allocate message structure, dropping packet "
		    "received on transport %p", u);
d763 1
a763 1
udp_send_message(struct message * msg)
d765 1
a765 1
	struct udp_transport *u = (struct udp_transport *) msg->transport;
d794 1
a794 1
udp_get_dst(struct transport * t, struct sockaddr ** dst)
d796 1
a796 1
	*dst = ((struct udp_transport *) t)->dst;
d804 1
a804 1
udp_get_src(struct transport * t, struct sockaddr ** src)
d806 1
a806 1
	*src = ((struct udp_transport *) t)->src;
d810 1
a810 1
udp_decode_ids(struct transport * t)
d816 2
a817 2
	if (getnameinfo(((struct udp_transport *) t)->src,
	    sysdep_sa_len(((struct udp_transport *) t)->src),
d822 2
a823 2
	if (getnameinfo(((struct udp_transport *) t)->dst,
	    sysdep_sa_len(((struct udp_transport *) t)->dst),
d829 4
a832 2
	strlcpy(idsrc, inet_ntoa(((struct udp_transport *) t)->src.sin_addr), 256);
	strlcpy(iddst, inet_ntoa(((struct udp_transport *) t)->dst.sin_addr), 256);
@


1.69
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: udp.c,v 1.68 2004/04/07 22:45:49 ho Exp $	 */
d143 1
a143 1
	s = monitor_socket(laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
d156 1
a156 1
		if (((struct sockaddr_in *) laddr)->sin_addr.s_addr == INADDR_ANY)
d160 1
a160 1
		if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *) laddr)->sin6_addr))
d172 1
a172 1
	if (monitor_setsockopt(s, SOL_SOCKET,
d348 1
a348 1
	s = monitor_socket(if_addr->sa_family, SOCK_DGRAM, 0);
@


1.68
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.67 2004/03/29 16:32:19 deraadt Exp $	*/
/*	$EOM: udp.c,v 1.57 2001/01/26 10:09:57 niklas Exp $	*/
d65 1
a65 1
/* If a system doesn't have SO_REUSEPORT, SO_REUSEADDR will have to do.  */
d71 4
a74 5
  struct transport transport;
  struct sockaddr *src;
  struct sockaddr *dst;
  int s;
  LIST_ENTRY (udp_transport) link;
d77 13
a89 13
static struct transport *udp_clone (struct udp_transport *, struct sockaddr *);
static struct transport *udp_create (char *);
static void udp_reinit (void);
static void udp_remove (struct transport *);
static void udp_report (struct transport *);
static int udp_fd_set (struct transport *, fd_set *, int);
static int udp_fd_isset (struct transport *, fd_set *);
static void udp_handle_message (struct transport *);
static struct transport *udp_make (struct sockaddr *);
static int udp_send_message (struct message *);
static void udp_get_dst (struct transport *, struct sockaddr **);
static void udp_get_src (struct transport *, struct sockaddr **);
static char *udp_decode_ids (struct transport *);
d91 1
a91 1
static in_port_t udp_decode_port (char *);
d95 12
a106 12
  { 0 }, "udp",
  udp_create,
  udp_reinit,
  udp_remove,
  udp_report,
  udp_fd_set,
  udp_fd_isset,
  udp_handle_message,
  udp_send_message,
  udp_get_dst,
  udp_get_src,
  udp_decode_ids
d110 2
a111 1
static LIST_HEAD (udp_listen_list, udp_transport) udp_listen_list;
a112 3
char *udp_default_port = 0;
char *udp_bind_port = 0;
int bind_family = 0;
d114 3
d120 1
a120 1
udp_listen_lookup (struct sockaddr *addr)
d122 1
a122 1
  struct udp_transport *u;
d124 5
a128 5
  for (u = LIST_FIRST (&udp_listen_list); u; u = LIST_NEXT (u, link))
    if (sysdep_sa_len (u->src) == sysdep_sa_len (addr)
	&& memcmp (u->src, addr, sysdep_sa_len (addr)) == 0)
      return u;
  return 0;
d133 1
a133 1
udp_make (struct sockaddr *laddr)
d135 29
a163 2
  struct udp_transport *t = 0;
  int s, on, wildcardaddress = 0;
d165 35
a199 71
  t = calloc (1, sizeof *t);
  if (!t)
    {
      log_print ("udp_make: malloc (%lu) failed", (unsigned long)sizeof *t);
      return 0;
    }

  s = monitor_socket (laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
  if (s == -1)
    {
      log_error ("udp_make: socket (%d, %d, %d)", laddr->sa_family, SOCK_DGRAM,
		 IPPROTO_UDP);
      goto err;
    }

  /* Make sure we don't get our traffic encrypted.  */
  if (sysdep_cleartext (s, laddr->sa_family) == -1)
    goto err;

  /* Wildcard address ?  */
  switch (laddr->sa_family)
    {
    case AF_INET:
      if (((struct sockaddr_in *)laddr)->sin_addr.s_addr == INADDR_ANY)
	wildcardaddress = 1;
      break;
    case AF_INET6:
      if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)laddr)->sin6_addr))
	wildcardaddress = 1;
      break;
    }

  /*
   * In order to have several bound specific address-port combinations
   * with the same port SO_REUSEADDR is needed.
   * If this is a wildcard socket and we are not listening there, but only
   * sending from it make sure it is entirely reuseable with SO_REUSEPORT.
   */
  on = 1;
  if (monitor_setsockopt (s, SOL_SOCKET,
		  wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
		  (void *)&on, sizeof on) == -1)
    {
      log_error ("udp_make: setsockopt (%d, %d, %d, %p, %lu)", s, SOL_SOCKET,
		 wildcardaddress ? SO_REUSEPORT : SO_REUSEADDR,
		 &on, (unsigned long)sizeof on);
      goto err;
    }

  t->transport.vtbl = &udp_transport_vtbl;
  t->src = laddr;
  if (monitor_bind (s, t->src, sysdep_sa_len (t->src)))
    {
      char *tstr;
      if (sockaddr2text (t->src, &tstr, 0))
	  log_error ("udp_make: bind (%d, %p, %lu)", s, &t->src,
		(unsigned long)sizeof t->src);
      else
	{
	  log_error ("udp_make: bind (%d, %s, %lu)", s, tstr,
		(unsigned long)sizeof t->src);
	  free (tstr);
	}
      goto err;
    }

  t->s = s;
  transport_add (&t->transport);
  transport_reference (&t->transport);
  t->transport.flags |= TRANSPORT_LISTEN;
  return &t->transport;
d202 8
a209 9
  if (s >= 0)
    close (s);
  if (t)
    {
      /* Already closed.  */
      t->s = -1;
      udp_remove (&t->transport);
    }
  return 0;
d214 1
a214 1
udp_clone (struct udp_transport *u, struct sockaddr *raddr)
d216 2
a217 2
  struct transport *t;
  struct udp_transport *u2;
d219 8
a226 28
  t = malloc (sizeof *u);
  if (!t)
    {
      log_error ("udp_clone: malloc (%lu) failed", (unsigned long)sizeof *u);
      return 0;
    }
  u2 = (struct udp_transport *)t;

  memcpy (u2, u, sizeof *u);

  u2->src = malloc (sysdep_sa_len (u->src));
  if (!u2->src)
    {
      log_error ("udp_clone: malloc (%d) failed", sysdep_sa_len (u->src));
      free (t);
      return 0;
    }
  memcpy (u2->src, u->src, sysdep_sa_len (u->src));

  u2->dst = malloc (sysdep_sa_len (raddr));
  if (!u2->dst)
    {
      log_error ("udp_clone: malloc (%d) failed", sysdep_sa_len (raddr));
      free (u2->src);
      free (t);
      return 0;
    }
  memcpy (u2->dst, raddr, sysdep_sa_len (raddr));
d228 7
a234 1
  t->flags &= ~TRANSPORT_LISTEN;
d236 8
a243 1
  transport_add (t);
d245 3
a247 1
  return t;
d257 1
a257 1
udp_bind (const struct sockaddr *addr)
d259 1
a259 1
  struct sockaddr *src = malloc (sysdep_sa_len ((struct sockaddr *)addr));
d261 2
a262 2
  if (!src)
    return 0;
d264 2
a265 2
  memcpy (src, addr, sysdep_sa_len ((struct sockaddr *)addr));
  return udp_make (src);
d274 1
a274 1
udp_bind_if (char *ifname, struct sockaddr *if_addr, void *arg)
d276 109
a384 39
  char *port = (char *)arg;
  struct sockaddr_storage saddr_st;
  struct sockaddr *saddr = (struct sockaddr *)&saddr_st;
  struct conf_list *listen_on;
  struct udp_transport *u;
  struct conf_list_node *address;
  struct sockaddr *addr;
  struct transport *t;
  struct ifreq flags_ifr;
  char *addr_str, *ep;
  int s, error;
  long lport;

  /*
   * Well, UDP is an internet protocol after all so drop other ifreqs.
   */
  if ((if_addr->sa_family != AF_INET
       || sysdep_sa_len (if_addr) != sizeof (struct sockaddr_in))
      && (if_addr->sa_family != AF_INET6
	  || sysdep_sa_len (if_addr) != sizeof (struct sockaddr_in6)))
    return 0;

  /*
   * Only create sockets for families we should listen to.
   */
  if (bind_family)
    switch (if_addr->sa_family)
      {
      case AF_INET:
	if ((bind_family & BIND_FAMILY_INET4) == 0)
	  return 0;
	break;
      case AF_INET6:
	if ((bind_family & BIND_FAMILY_INET6) == 0)
	  return 0;
	break;
      default:
	return 0;
      }
d386 43
a428 116
  /*
   * These special addresses are not useable as they have special meaning
   * in the IP stack.
   */
  if (if_addr->sa_family == AF_INET
      && (((struct sockaddr_in *)if_addr)->sin_addr.s_addr == INADDR_ANY
	  || (((struct sockaddr_in *)if_addr)->sin_addr.s_addr
	      == INADDR_NONE)) )
    return 0;

  /*
   * Go through the list of transports and see if we already have this
   * address bound. If so, unmark the transport and skip it; this allows
   * us to call this function when we suspect a new address has appeared.
   */
  if (sysdep_sa_len (if_addr) > sizeof saddr_st)
    return 0;
  memcpy (saddr, if_addr, sysdep_sa_len (if_addr));
  switch (saddr->sa_family)  /* Add the port number to the sockaddr. */
    {
    case AF_INET:
      ((struct sockaddr_in *)saddr)->sin_port
	= htons (strtol (port, &ep, 10));
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)saddr)->sin6_port
	= htons (strtol (port, &ep, 10));
      break;
    }

  if ((u = udp_listen_lookup (saddr)) != 0)
    {
      u->transport.flags &= ~TRANSPORT_MARK;
      return 0;
    }

  /* Don't bother with interfaces that are down.  */
  s = monitor_socket (if_addr->sa_family, SOCK_DGRAM, 0);
  if (s == -1)
    {
      log_error ("udp_bind_if: socket (%d, SOCK_DGRAM, 0) failed",
		 if_addr->sa_family);
      return -1;
    }
  strlcpy (flags_ifr.ifr_name, ifname, sizeof flags_ifr.ifr_name);
  if (ioctl (s, SIOCGIFFLAGS, (caddr_t)&flags_ifr) == -1)
    {
      log_error ("udp_bind_if: ioctl (%d, SIOCGIFFLAGS, ...) failed", s);
      return -1;
    }
  close (s);
  if (!(flags_ifr.ifr_flags & IFF_UP))
    return 0;

  /*
   * Set port.
   * XXX Use getservbyname too.
   */
  lport = strtol (port, &ep, 10);
  if (*ep != '\0' || lport < (long)0 || lport > (long)USHRT_MAX)
    {
      log_print ("udp_bind_if: "
		 "port string \"%s\" not convertible to in_port_t", port);
      return -1;
    }

  switch (if_addr->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)if_addr)->sin_port = htons (lport);
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)if_addr)->sin6_port = htons (lport);
      break;
    default:
      log_print ("udp_bind_if: unsupported protocol family %d",
		 if_addr->sa_family);
      break;
    }

  /*
   * If we are explicit about what addresses we can listen to, be sure
   * to respect that option.
   * This is quite wasteful redoing the list-run for every interface,
   * but who cares?  This is not an operation that needs to be fast.
   */
  listen_on = conf_get_list ("General", "Listen-on");
  if (listen_on)
    {
      for (address = TAILQ_FIRST (&listen_on->fields); address;
	   address = TAILQ_NEXT (address, link))
	{
	  if (text2sockaddr (address->field, port, &addr))
	    {
	      log_print ("udp_bind_if: invalid address %s in \"Listen-on\"",
			 address->field);
	      continue;
	    }

	  /* If found, take the easy way out. */
	  if (memcmp (addr, if_addr, sysdep_sa_len (addr)) == 0)
	    {
	      free (addr);
	      break;
	    }
	  free (addr);
	}
      conf_free_list (listen_on);

      /*
       * If address is zero then we did not find the address among the ones
       * we should listen to.
       * XXX We do not discover if we do not find our listen addresses...
       * Maybe this should be the other way round.
       */
      if (!address)
a429 14
    }

  t = udp_bind (if_addr);
  if (!t)
    {
      error = sockaddr2text (if_addr, &addr_str, 0);
      log_print ("udp_bind_if: failed to create a socket on %s:%s",
		 error ? "unknown" : addr_str, port);
      if (!error)
	free (addr_str);
      return -1;
    }
  LIST_INSERT_HEAD (&udp_listen_list, (struct udp_transport *)t, link);
  return 0;
d437 1
a437 1
udp_create (char *name)
d439 55
a493 65
  struct udp_transport *u;
  struct transport *rv;
  struct sockaddr *dst, *addr;
  char *addr_str, *port_str;

  port_str = conf_get_str (name, "Port");
  if (!port_str)
    port_str = udp_default_port;
  if (!port_str)
    port_str = "500";

  addr_str = conf_get_str (name, "Address");
  if (!addr_str)
    {
      log_print ("udp_create: no address configured for \"%s\"", name);
      return 0;
    }
  if (text2sockaddr (addr_str, port_str, &dst))
    {
      log_print ("udp_create: address \"%s\" not understood", addr_str);
      return 0;
    }

  addr_str = conf_get_str (name, "Local-address");
  if (!addr_str)
    addr_str = conf_get_str ("General", "Listen-on");
  if (!addr_str)
    {
      if ((dst->sa_family == AF_INET && !default_transport)
	  || (dst->sa_family == AF_INET6 && !default_transport6))
	{
	  log_print ("udp_create: no default transport");
	  rv = 0;
	  goto ret;
	}
      else
	{
	  /* XXX Ugly!  */
	  rv = udp_clone ((struct udp_transport *)(dst->sa_family == AF_INET
						   ? default_transport
						   : default_transport6), dst);
	  goto ret;
	}
    }

  if (text2sockaddr (addr_str, port_str, &addr))
    {
      log_print ("udp_create: address \"%s\" not understood", addr_str);
      rv = 0;
      goto ret;
    }
  u = udp_listen_lookup (addr);
  free (addr);
  if (!u)
    {
      log_print ("udp_create: %s:%s must exist as a listener too", addr_str,
		 port_str);
      rv = 0;
      goto ret;
    }
  rv = udp_clone (u, dst);

 ret:
  free (dst);
  return rv;
d497 1
a497 1
udp_remove (struct transport *t)
d499 1
a499 1
  struct udp_transport *u = (struct udp_transport *)t;
d501 15
a515 16
  if (u->src)
    free (u->src);
  if (u->dst)
    free (u->dst);
  if (t->flags & TRANSPORT_LISTEN)
    {
      if (u->s >= 0)
	close (u->s);
      if (t == default_transport)
	default_transport = 0;
      else if (t == default_transport6)
	default_transport6 = 0;
      if (u->link.le_prev)
	LIST_REMOVE (u, link);
    }
  free (t);
d518 1
a518 1
/* Report transport-method specifics of the T transport.  */
d520 1
a520 1
udp_report (struct transport *t)
d522 2
a523 2
  struct udp_transport *u = (struct udp_transport *)t;
  char *src, *dst;
d525 2
a526 2
  if (sockaddr2text (u->src, &src, 0))
    goto ret;
d528 2
a529 2
  if (!u->dst || sockaddr2text (u->dst, &dst, 0))
    dst = 0;
d531 1
a531 1
  LOG_DBG ((LOG_REPORT, 0, "udp_report: fd %d src %s dst %s", u->s, src,
d534 5
a538 5
 ret:
  if (dst)
    free (dst);
  if (src)
    free (src);
d551 1
a551 1
udp_reinit (void)
d553 2
a554 2
  struct udp_transport *u, *u2;
  char *port;
d556 2
a557 2
  /* Initialize the protocol and port numbers.  */
  port = udp_default_port ? udp_default_port : "500";
d559 24
a582 24
  /* Mark all UDP transports, except the default ones. */
  for (u = LIST_FIRST (&udp_listen_list); u; u = LIST_NEXT (u, link))
    if (&u->transport != default_transport
	&& &u->transport != default_transport6)
       u->transport.flags |= TRANSPORT_MARK;

  /* Re-probe interface list.  */
  if (if_map (udp_bind_if, port) == -1)
    log_print ("udp_init: Could not bind the ISAKMP UDP port %s on all "
	       "interfaces", port);

  /*
   * Release listening transports for local addresses that no
   * longer exist. udp_bind_if () will have left those still marked.
   */
  u = LIST_FIRST (&udp_listen_list);
  while (u)
    {
      u2 = LIST_NEXT (u, link);

      if (u->transport.flags & TRANSPORT_MARK)
	{
	  LIST_REMOVE (u, link);
	  transport_release (&u->transport);
a583 3

      u = u2;
    }
d592 1
a592 1
udp_init (void)
d594 45
a638 50
  struct sockaddr_storage dflt_stor;
  struct sockaddr_in *dflt = (struct sockaddr_in *)&dflt_stor;
  struct conf_list *listen_on;
  char *port;
  long lport;
  char *ep;

  /* Initialize the protocol and port numbers.  */
  port = udp_default_port ? udp_default_port : "500";

  LIST_INIT (&udp_listen_list);

  transport_method_add (&udp_transport_vtbl);

  /* Bind the ISAKMP UDP port on all network interfaces we have.  */
  if (if_map (udp_bind_if, port) == -1)
      log_fatal ("udp_init: Could not bind the ISAKMP UDP port %s on all "
		 "interfaces", port);

  /* Only listen to the specified address if Listen-on is configured */
  listen_on = conf_get_list ("General", "Listen-on");
  if (listen_on)
    {
      LOG_DBG ((LOG_TRANSPORT, 50,
		"udp_init: not binding ISAKMP UDP port to INADDR_ANY"));
      conf_free_list (listen_on);
      return;
    }

  /*
   * Get port.
   * XXX Use getservbyname too.
   */
  lport = strtol (port, &ep, 10);
  if (*ep != '\0' || lport < (long)0 || lport > (long)USHRT_MAX)
    {
      log_print ("udp_init: port string \"%s\" not convertible to in_port_t",
		 port);
      return;
    }

  /*
   * Bind to INADDR_ANY in case of new addresses popping up.
   * Packet reception on this transport is taken as a hint to reprobe the
   * interface list.
   */
  if (!bind_family || (bind_family & BIND_FAMILY_INET4))
    {
      memset (&dflt_stor, 0, sizeof dflt_stor);
      dflt->sin_family = AF_INET;
d640 1
a640 1
      ((struct sockaddr_in *)dflt)->sin_len = sizeof (struct sockaddr_in);
d642 1
a642 1
      ((struct sockaddr_in *)dflt)->sin_port = htons (lport);
d644 12
a655 15
      default_transport = udp_bind ((struct sockaddr *)&dflt_stor);
      if (!default_transport)
	{
	  log_error ("udp_init: could not allocate default "
		     "IPv4 ISAKMP UDP port");
	  return;
	}
      LIST_INSERT_HEAD (&udp_listen_list,
			(struct udp_transport *)default_transport, link);
    }

  if (!bind_family || (bind_family & BIND_FAMILY_INET6))
    {
      memset (&dflt_stor, 0, sizeof dflt_stor);
      dflt->sin_family = AF_INET6;
d657 1
a657 1
      ((struct sockaddr_in6 *)dflt)->sin6_len = sizeof (struct sockaddr_in6);
d659 1
a659 1
      ((struct sockaddr_in6 *)dflt)->sin6_port = htons (lport);
d661 9
a669 10
      default_transport6 = udp_bind ((struct sockaddr *)&dflt_stor);
      if (!default_transport6)
	{
	  log_error ("udp_init: could not allocate default "
		     "IPv6 ISAKMP UDP port");
	  return;
	}
      LIST_INSERT_HEAD (&udp_listen_list,
			(struct udp_transport *)default_transport6, link);
    }
d677 1
a677 1
udp_fd_set (struct transport *t, fd_set *fds, int bit)
d679 1
a679 1
  struct udp_transport *u = (struct udp_transport *)t;
d681 4
a684 4
  if (bit)
    FD_SET (u->s, fds);
  else
    FD_CLR (u->s, fds);
d686 1
a686 1
  return u->s + 1;
d691 1
a691 1
udp_fd_isset (struct transport *t, fd_set *fds)
d693 1
a693 1
  struct udp_transport *u = (struct udp_transport *)t;
d695 1
a695 1
  return FD_ISSET (u->s, fds);
d705 1
a705 1
udp_handle_message (struct transport *t)
d707 42
a748 47
  struct udp_transport *u = (struct udp_transport *)t;
  u_int8_t buf[UDP_SIZE];
  struct sockaddr_storage from;
  u_int32_t len = sizeof from;
  ssize_t n;
  struct message *msg;

  n = recvfrom (u->s, buf, UDP_SIZE, 0, (struct sockaddr *)&from, &len);
  if (n == -1)
    {
      log_error ("recvfrom (%d, %p, %d, %d, %p, %p)", u->s, buf, UDP_SIZE, 0,
		 &from, &len);
      return;
    }

  /*
   * If we received the packet over the default transports, reprobe the
   * interfaces.
   */
  if (t == default_transport || t == default_transport6)
    {
      udp_reinit ();

      /*
       * As we don't know the actual destination address of the packet,
       * we can't really deal with it. So, just ignore it and hope we
       * catch the retransmission.
       */
      return;
    }

  /*
   * Make a specialized UDP transport structure out of the incoming
   * transport and the address information we got from recvfrom(2).
   */
  t = udp_clone (u, (struct sockaddr *)&from);
  if (!t)
    return;

  msg = message_alloc (t, buf, n);
  if (!msg)
    {
      log_error ("failed to allocate message structure, dropping packet "
		 "received on transport %p", u);
      return;
    }
  message_recv (msg);
d753 1
a753 1
udp_send_message (struct message *msg)
d755 22
a776 23
  struct udp_transport *u = (struct udp_transport *)msg->transport;
  ssize_t n;
  struct msghdr m;

  /*
   * Sending on connected sockets requires that no destination address is
   * given, or else EISCONN will occur.
   */
  m.msg_name = (caddr_t)u->dst;
  m.msg_namelen = sysdep_sa_len (u->dst);
  m.msg_iov = msg->iov;
  m.msg_iovlen = msg->iovlen;
  m.msg_control = 0;
  m.msg_controllen = 0;
  m.msg_flags = 0;
  n = sendmsg (u->s, &m, 0);
  if (n == -1)
    {
      /* XXX We should check whether the address has gone away */
      log_error ("sendmsg (%d, %p, %d)", u->s, &m, 0);
      return -1;
    }
  return 0;
d784 1
a784 1
udp_get_dst (struct transport *t, struct sockaddr **dst)
d786 1
a786 1
  *dst = ((struct udp_transport *)t)->dst;
d794 1
a794 1
udp_get_src (struct transport *t, struct sockaddr **src)
d796 1
a796 1
  *src = ((struct udp_transport *)t)->src;
d800 1
a800 1
udp_decode_ids (struct transport *t)
d802 2
a803 2
  static char result[1024];
  char idsrc[256], iddst[256];
d806 12
a817 15
  if (getnameinfo (((struct udp_transport *)t)->src,
		   sysdep_sa_len (((struct udp_transport *)t)->src),
		   idsrc, sizeof idsrc, NULL, 0, NI_NUMERICHOST) != 0)
    {
      log_print ("udp_decode_ids: getnameinfo () failed for 'src'");
      strlcpy (idsrc, "<error>", 256);
    }

  if (getnameinfo (((struct udp_transport *)t)->dst,
		   sysdep_sa_len (((struct udp_transport *)t)->dst),
		   iddst, sizeof iddst, NULL, 0, NI_NUMERICHOST) != 0)
    {
      log_print ("udp_decode_ids: getnameinfo () failed for 'dst'");
      strlcpy (iddst, "<error>", 256);
    }
d819 3
a821 3
  strlcpy (idsrc, inet_ntoa (((struct udp_transport *)t)->src.sin_addr), 256);
  strlcpy (iddst, inet_ntoa (((struct udp_transport *)t)->dst.sin_addr), 256);
#endif /* HAVE_GETNAMEINFO */
d823 2
a824 3
  snprintf (result, sizeof result, "src: %s dst: %s", idsrc, iddst);

  return result;
d834 1
a834 1
udp_decode_port (char *port_str)
d836 18
a853 22
  char *port_str_end;
  long port_long;
  struct servent *service;

  port_long = ntohl (strtol (port_str, &port_str_end, 0));
  if (port_str == port_str_end)
    {
      service = getservbyname (port_str, "udp");
      if (!service)
	{
	  log_print ("udp_decode_port: service \"%s\" unknown", port_str);
	  return 0;
	}
      return ntohs (service->s_port);
    }
  else if (port_long < 1 || port_long > 65535)
    {
      log_print ("udp_decode_port: port %ld out of range", port_long);
      return 0;
    }

  return port_long;
@


1.67
log
@memory mishandling; from ho
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.66 2004/03/19 14:04:43 hshoexer Exp $	*/
d390 1
a390 1
  if (*ep != '\0' || lport < 0 || lport > USHRT_MAX)
d674 1
a674 1
  if (*ep != '\0' || lport < 0 || lport > USHRT_MAX)
@


1.66
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.65 2003/09/26 11:29:11 cedric Exp $	*/
d346 3
a348 1
  memcpy (saddr, if_addr, sizeof saddr_st);
@


1.65
log
@don't listen to INADDR_ANY if Listen-on is specified.
patch from markus@@, ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.64 2003/06/10 16:41:29 deraadt Exp $	*/
d145 1
a145 1
  s = socket (laddr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
d177 1
a177 1
  if (setsockopt (s, SOL_SOCKET,
d366 1
a366 1
  s = socket (if_addr->sa_family, SOCK_DGRAM, 0);
@


1.64
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.63 2003/06/04 07:31:17 ho Exp $	*/
d640 1
d656 10
@


1.63
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.62 2003/06/03 12:51:39 ho Exp $	*/
d692 1
a692 1
  
@


1.62
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.61 2003/05/18 20:06:14 ho Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.61
log
@struct sockaddr is not large enough in itself to contain the address
value. Switching to sockaddr_storage makes interface rescanning work
properly. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.60 2003/05/18 18:16:34 ho Exp $	*/
d879 1
a879 1
  snprintf (result, 1024, "src: %s dst: %s", idsrc, iddst);
@


1.60
log
@Sysdep for native Linux IPSec, 2.5 and later. From Thomas Walpuski, with
various tweaks by me. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.59 2003/05/15 00:28:53 ho Exp $	*/
d297 2
a298 1
  struct sockaddr saddr;
d351 2
a352 2
  bcopy (if_addr, &saddr, sizeof saddr);
  switch (saddr.sa_family)  /* Add the port number to the sockaddr. */
d355 1
a355 1
      ((struct sockaddr_in *)&saddr)->sin_port
d359 1
a359 1
      ((struct sockaddr_in6 *)&saddr)->sin6_port
d364 1
a364 1
  if ((u = udp_listen_lookup (&saddr)) != 0)
d613 1
a613 1
    log_error ("udp_init: Could not bind the ISAKMP UDP port %s on all "
@


1.59
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.58 2003/02/12 15:11:31 markus Exp $	*/
d681 1
d683 1
d701 1
d703 1
@


1.58
log
@better error checking on bind(); from Alexander_Bluhm at genua.de; ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.57 2002/12/03 20:05:10 ho Exp $	*/
d62 1
d194 1
a194 1
  if (bind (s, t->src, sysdep_sa_len (t->src)))
@


1.57
log
@Add -4/-6 cmdline options to select what address family (IPv4,v6) to use.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.56 2002/09/11 09:50:44 ho Exp $	*/
d290 1
d292 1
a292 1
static void
d314 1
a314 1
    return;
d324 1
a324 1
	  return;
d328 1
a328 1
	  return;
d331 1
a331 1
	return;
d342 1
a342 1
    return;
d365 1
a365 1
      return;
d374 1
a374 1
      return;
d380 1
a380 1
      return;
d384 1
a384 1
    return;
d395 1
a395 1
      return;
d448 1
a448 1
	return;
d459 1
a459 1
      return;
d462 1
d598 4
d610 3
a612 2
  /* XXX need to check errors.  */
  if_map (udp_bind_if, udp_default_port ? udp_default_port : "500");
d655 3
a657 2
  /* XXX need to check errors */
  if_map (udp_bind_if, port);
@


1.56
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.55 2002/06/01 07:44:22 deraadt Exp $	*/
d119 1
d316 18
d668 6
a673 4
  memset (&dflt_stor, 0, sizeof dflt_stor);
  dflt->sin_family = AF_INET;
  ((struct sockaddr_in *)dflt)->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)dflt)->sin_port = htons (lport);
d675 12
a686 2
  default_transport = udp_bind ((struct sockaddr *)&dflt_stor);
  if (!default_transport)
d688 4
a691 5
      log_error ("udp_init: could not allocate default IPv4 ISAKMP UDP port");
      return;
    }
  LIST_INSERT_HEAD (&udp_listen_list,
		    (struct udp_transport *)default_transport, link);
d693 9
a701 10
  memset (&dflt_stor, 0, sizeof dflt_stor);
  dflt->sin_family = AF_INET6;
  ((struct sockaddr_in6 *)dflt)->sin6_len = sizeof (struct sockaddr_in6);
  ((struct sockaddr_in6 *)dflt)->sin6_port = htons (lport);

  default_transport6 = udp_bind ((struct sockaddr *)&dflt_stor);
  if (!default_transport6)
    {
      log_error ("udp_init: could not allocate default IPv6 ISAKMP UDP port");
      return;
a702 2
  LIST_INSERT_HEAD (&udp_listen_list,
		    (struct udp_transport *)default_transport6, link);
@


1.55
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.54 2002/01/03 16:27:41 ho Exp $	*/
d716 1
a716 1
  int len = sizeof from;
@


1.54
log
@str[n]{cpy,cat} -> strl{cpy,cat}, sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.53 2001/10/26 13:29:26 ho Exp $	*/
d144 1
a144 1
      log_print ("udp_make: malloc (%d) failed", sizeof *t);
d184 1
a184 1
      log_error ("udp_make: setsockopt (%d, %d, %d, %p, %d)", s, SOL_SOCKET,
d186 1
a186 1
		 &on, sizeof on);
d196 2
a197 1
	  log_error ("udp_make: bind (%d, %p, %d)", s, &t->src, sizeof t->src);
d200 2
a201 1
	  log_error ("udp_make: bind (%d, %s, %d)", s, tstr, sizeof t->src);
d235 1
a235 1
      log_error ("udp_clone: malloc (%d) failed", sizeof *u);
@


1.53
log
@Change to use sysdep_sa_len() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.52 2001/10/09 14:53:05 ho Exp $	*/
d354 1
a354 1
  strncpy (flags_ifr.ifr_name, ifname, sizeof flags_ifr.ifr_name - 1);
d821 1
a821 1
      strcpy (idsrc, "<error>");
d829 1
a829 1
      strcpy (iddst, "<error>");
d832 2
a833 2
  strcpy (idsrc, inet_ntoa (((struct udp_transport *)t)->src.sin_addr));
  strcpy (iddst, inet_ntoa (((struct udp_transport *)t)->dst.sin_addr));
d836 1
a836 1
  sprintf (result, "src: %s dst: %s", idsrc, iddst);
@


1.52
log
@Print correct portnr in warning msg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.51 2001/08/25 22:13:27 niklas Exp $	*/
d128 2
a129 2
    if (u->src->sa_len == addr->sa_len
	&& memcmp (u->src, addr, addr->sa_len) == 0)
d192 1
a192 1
  if (bind (s, t->src, t->src->sa_len))
d240 1
a240 1
  u2->src = malloc (u->src->sa_len);
d243 1
a243 1
      log_error ("udp_clone: malloc (%d) failed", u->src->sa_len);
d247 1
a247 1
  memcpy (u2->src, u->src, u->src->sa_len);
d249 1
a249 1
  u2->dst = malloc (raddr->sa_len);
d252 1
a252 1
      log_error ("udp_clone: malloc (%d) failed", raddr->sa_len);
d257 1
a257 1
  memcpy (u2->dst, raddr, raddr->sa_len);
d275 1
a275 1
  struct sockaddr *src = malloc (addr->sa_len);
d280 1
a280 1
  memcpy (src, addr, addr->sa_len);
a305 4
#ifdef USE_OLD_SOCKADDR
  if (if_addr->sa_family != AF_INET && if_addr->sa_family != AF_INET6)
    return;
#else
d307 1
a307 1
       || if_addr->sa_len != sizeof (struct sockaddr_in))
d309 1
a309 1
	  || if_addr->sa_len != sizeof (struct sockaddr_in6)))
a310 1
#endif
d410 1
a410 1
	  if (memcmp (addr, if_addr, addr->sa_len) == 0)
d773 1
a773 1
  m.msg_namelen = u->dst->sa_len;
d817 1
a817 1
		   ((struct udp_transport *)t)->src->sa_len,
d825 1
a825 1
		   ((struct udp_transport *)t)->dst->sa_len,
@


1.51
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.50 2001/08/23 23:32:35 angelos Exp $	*/
d510 1
a510 1
		 udp_default_port);
@


1.50
log
@Make the wildcard address use SO_REUSEPORT, so multiple instances of
isakmpd can run on the same machine and reuse the wildcard
address. This is intended mostly for debugging and testing purposes,
so multiple listener issues are not relevant.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.49 2001/08/23 23:11:02 angelos Exp $	*/
d128 2
a129 2
    if (u->src->sa_len == addr->sa_len &&
	memcmp (u->src, addr, addr->sa_len) == 0)
d216 2
a217 1
      t->s = -1; /* already closed */
d336 2
a337 2
      ((struct sockaddr_in *)&saddr)->sin_port =
	  htons (strtol (port, &ep, 10));
d340 2
a341 2
      ((struct sockaddr_in6 *)&saddr)->sin6_port =
	  htons (strtol (port, &ep, 10));
d482 2
a483 2
      if ((dst->sa_family == AF_INET && !default_transport) ||
	  (dst->sa_family == AF_INET6 && !default_transport6))
d583 2
a584 2
    if (&u->transport != default_transport &&
	&u->transport != default_transport6)
d588 1
a588 1
  /* XXX need to check errors */
@


1.49
log
@Reinitialize transports on SIGUP.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.48 2001/08/13 14:33:35 itojun Exp $	*/
d139 1
a139 1
  int s, on;
d160 13
d181 1
a181 7
#if 0
		  (laddr->sin_addr.s_addr == INADDR_ANY
		   && conf_get_str ("General", "Listen-on"))
		  ? SO_REUSEPORT : SO_REUSEADDR,
#else
		  SO_REUSEADDR,
#endif
d185 1
a185 7
#if 0
		 (laddr->sin_addr.s_addr == INADDR_ANY
		  && conf_get_str ("General", "Listen-on"))
		 ? SO_REUSEPORT : SO_REUSEADDR,
#else
		 SO_REUSEADDR,
#endif
a661 1

@


1.48
log
@use getifaddrs(3) rather than SIOCGIFCONF.  in fact, if_map() does not do
the right thing on certain set of interface addresses.  SIOCGIFCONF is
the worst possible ioctl API...
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.47 2001/08/12 15:48:44 angelos Exp $	*/
d84 1
d102 1
d566 43
d715 1
a715 1
  struct udp_transport *u = (struct udp_transport *)t, *u2;
d731 2
a732 8
   * If we received a packet over the default transports, then:
   * - if we use the Listen-on directive in the configuration, just ignore
   *   the packet
   * - otherwise, re-probe the interface list
   * At the same time, we try to determine whether existing transports have
   * been rendered invalid; we do this by marking all UDP transports before
   * we call udp_bind_if () through if_map (), and then releasing those
   * transports that have not been unmarked.
d736 1
a736 30
      if (conf_get_str ("General", "Listen-on"))
	return;

      /* Mark all UDP transports, except the default ones. */
      for (u = LIST_FIRST (&udp_listen_list); u; u = LIST_NEXT (u, link))
	if (&u->transport != default_transport &&
	    &u->transport != default_transport6)
	  u->transport.flags |= TRANSPORT_MARK;

      /* Re-probe interface list. */
      /* XXX need to check errors */
      if_map (udp_bind_if, udp_default_port ? udp_default_port : "500");

      /*
       * Release listening transports for local addresses that no
       * longer exist.
       */
      u = LIST_FIRST (&udp_listen_list);
      while (u)
        {
	  u2 = LIST_NEXT (u, link);

	  if (u->transport.flags & TRANSPORT_MARK)
	    {
	      LIST_REMOVE (u, link);
	      transport_release (&u->transport);
	    }

	  u = u2;
	}
@


1.47
log
@Don't coredump if the kernel doesn't support IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.46 2001/08/11 10:13:32 angelos Exp $	*/
d269 1
a269 1
udp_bind (struct sockaddr *addr)
d285 1
a285 1
udp_bind_if (struct ifreq *ifrp, void *arg)
d288 1
a288 1
  struct sockaddr *if_addr = &ifrp->ifr_addr, saddr;
d355 1
a355 1
  strncpy (flags_ifr.ifr_name, ifrp->ifr_name, sizeof flags_ifr.ifr_name - 1);
@


1.46
log
@Check socket >= 0. We should also be going through the list of cloned
transports and invalidating (somehow) those whose socket should not be
used.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.45 2001/08/11 09:57:30 angelos Exp $	*/
d612 5
a616 1
    log_error ("udp_init: could not allocate default IPv4 ISAKMP UDP port");
d627 4
a630 1
    log_error ("udp_init: could not allocate default IPv6 ISAKMP UDP port");
@


1.45
log
@When a message is received on the wildcard (default) transport,
re-examine the interface list; new addresses are bound to, and sockets
to deleted addresses are closed.

This only occurs if the Listen-to directive in isakmpd.conf is *not*
used.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.44 2001/07/06 14:37:11 ho Exp $	*/
d209 1
a209 1
  if (s != -1)
@


1.44
log
@Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.43 2001/07/05 12:36:57 ho Exp $	*/
a125 1
    /* XXX enough ? */
d212 4
a215 1
    udp_remove (&t->transport);
d239 1
d248 1
d288 1
a288 1
  struct sockaddr *if_addr = &ifrp->ifr_addr;
d290 1
d318 2
a319 3
      && (((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr
	  == INADDR_ANY
	  || (((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr
d323 24
d526 11
a587 3
  if (conf_get_str("General", "Listen-on"))
    return;

d601 3
a603 4
   * If we don't bind to specific addresses via the Listen-on configuration
   * option, bind to INADDR_ANY in case of new addresses popping up.
   * XXX We should use packets coming in on this socket as a signal
   * to reprobe for new interfaces.
d613 2
a614 2
  else if (conf_get_str ("General", "Listen-on"))
    default_transport->flags &= ~TRANSPORT_LISTEN;
d624 2
a625 2
  else if (conf_get_str ("General", "Listen-on"))
    default_transport6->flags &= ~TRANSPORT_LISTEN;
d663 1
a663 1
  struct udp_transport *u = (struct udp_transport *)t;
d679 51
a734 1
    /* XXX Should we do more here?  */
d739 5
a743 2
    /* XXX Log?  */
    return;
d769 1
@


1.43
log
@Add prototypes and some other various cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.42 2001/07/03 07:54:20 ho Exp $	*/
d530 1
a530 1
udp_init ()
@


1.42
log
@Slightly more verbose error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.41 2001/07/01 20:29:39 niklas Exp $	*/
d94 3
d738 2
d743 1
d745 1
a745 1
in_port_t
d771 1
@


1.41
log
@strtol strictness.  Style.  Do not use dst end on an unconnected socket.
This should fix the IPv6 work for this round,
There has been code by ho@@ too in most my recent commits, we did this on
Boston Logan airport, on our way home from !c2k1, the OpenBSD hackathon.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.40 2001/07/01 06:00:32 angelos Exp $	*/
d715 1
a715 1
      log_print ("udp_decode_ids: getnameinfo () failed");
d723 1
a723 1
      log_print ("udp_decode_ids: getnameinfo () failed");
@


1.40
log
@Pass the right arguments to getnameinfo()
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.39 2001/07/01 05:42:05 angelos Exp $	*/
d49 1
d287 1
a287 1
  char *addr_str;
d289 1
d298 4
a301 4
  if ((if_addr->sa_family != AF_INET ||
       if_addr->sa_len != sizeof (struct sockaddr_in)) &&
      (if_addr->sa_family != AF_INET6 ||
       if_addr->sa_len != sizeof (struct sockaddr_in6)))
d309 5
a313 4
  if (if_addr->sa_family == AF_INET && 
      (((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr == INADDR_ANY
       || (((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr
	   == INADDR_NONE)) )
d334 12
a345 1
  /* Set port */
d349 1
a349 2
      ((struct sockaddr_in *)if_addr)->sin_port = 
	htons((in_port_t)strtol (port, NULL, 10));
d352 1
a352 2
      ((struct sockaddr_in6 *)if_addr)->sin6_port = 
	htons((in_port_t)strtol (port, NULL, 10));
d478 1
a478 1
    } 
d505 1
a505 1
  if (sockaddr2text (u->src, &src, 0) || sockaddr2text (u->dst, &dst, 0))
d508 5
a512 1
  LOG_DBG ((LOG_REPORT, 0, "udp_report: fd %d src %s dst %s", u->s, src, dst));
d532 2
d550 12
d570 1
a570 2
  ((struct sockaddr_in *)dflt)->sin_port = 
    htons ((in_port_t)strtol (port, NULL, 10));
d581 1
a581 2
  ((struct sockaddr_in6 *)dflt)->sin6_port = 
    htons ((in_port_t)strtol (port, NULL, 10));
@


1.39
log
@Fix remote_negotiation_address attribute; fix sockaddr2text() return
value when zero-filling; log_error()->log_print() consistently.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.38 2001/06/29 22:59:40 angelos Exp $	*/
a72 1
/* XXX IPv4 specific.  */
d683 2
a684 2
  if (getnameinfo ((struct sockaddr *)&((struct udp_transport *)t)->src,
		   sizeof ((struct udp_transport *)t)->src,
d691 2
a692 2
  if (getnameinfo ((struct sockaddr *)&((struct udp_transport *)t)->dst,
		   sizeof ((struct udp_transport *)t)->dst,
@


1.38
log
@Fix address byte ordering issue, ho@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.37 2001/06/29 22:43:40 ho Exp $	*/
d696 1
a696 1
      log_error ("udp_decode_ids: getnameinfo () failed");
@


1.37
log
@Removing a debugging printout...
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.36 2001/06/29 22:01:27 ho Exp $	*/
d523 2
a560 2

  transport_method_add (&udp_transport_vtbl);
@


1.36
log
@setsockopt flags needs to be IPv6 aware
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.35 2001/06/29 20:45:39 angelos Exp $	*/
a452 1
  log_print ("udp_create: addr_str = [%s]", addr_str);
@


1.35
log
@Set the port *before* the comparison.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.34 2001/06/29 20:38:16 angelos Exp $	*/
d153 2
a154 4
  if (sysdep_cleartext (s) == -1)
    {
      goto err;
    }
d308 4
a311 4
#if 0
  if (((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr == INADDR_ANY
      || (((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr
	  == INADDR_NONE))
a312 1
#endif
d315 1
a315 1
  s = socket (AF_INET, SOCK_DGRAM, 0);
d318 2
a319 1
      log_error ("udp_bind_if: socket (AF_INET, SOCK_DGRAM, 0) failed");
d453 1
d527 3
@


1.34
log
@LOG_DBG in hash_get, and if sysdep_cleartext() fails bail out of
initializing socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.33 2001/06/29 20:22:58 niklas Exp $	*/
d334 17
d370 1
a370 1
	  /* If found, take the easy way out.  */
a389 16
  /* Set port */
  switch (if_addr->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)if_addr)->sin_port = 
	htons((in_port_t)strtol (port, NULL, 10));
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)if_addr)->sin6_port = 
	htons((in_port_t)strtol (port, NULL, 10));
      break;
    default:
      log_print ("udp_bind_if: unsupported protocol family %d",
		 if_addr->sa_family);
      break;
    }
@


1.33
log
@Create an IPv6 default transport
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.32 2001/06/29 19:41:43 ho Exp $	*/
d153 4
a156 1
  sysdep_cleartext (s);
@


1.32
log
@IPv6 support, by niklas@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.30 2001/06/07 08:14:21 angelos Exp $	*/
d114 1
a114 1
static struct transport *default_transport;
d434 2
a435 1
      if (!default_transport)
d443 4
a446 1
	  rv = udp_clone ((struct udp_transport *)default_transport, dst);
d539 1
a539 1
    log_error ("udp_init: could not allocate default ISAKMP UDP port");
d542 12
@


1.31
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d76 2
a77 2
  struct sockaddr_in src;
  struct sockaddr_in dst;
d82 1
a82 2
static struct transport *udp_clone (struct udp_transport *,
				    struct sockaddr_in *);
d89 1
a89 1
static struct transport *udp_make (struct sockaddr_in *);
d112 2
a113 3
in_port_t udp_default_port = 0;
in_port_t udp_bind_port = 0;
static int udp_proto;
d118 1
a118 1
udp_listen_lookup (in_addr_t addr, in_port_t port)
d123 3
a125 1
    if (u->src.sin_addr.s_addr == addr && u->src.sin_port == port)
d132 1
a132 1
udp_make (struct sockaddr_in *laddr)
d137 1
a137 1
  t = malloc (sizeof *t);
d144 1
a144 1
  s = socket (AF_INET, SOCK_DGRAM, udp_proto);
d147 2
a148 2
      log_error ("udp_make: socket (%d, %d, %d)", AF_INET, SOCK_DGRAM,
		 udp_proto);
d163 1
d167 3
d173 1
d177 3
d185 2
a186 2
  memcpy (&t->src, laddr, sizeof t->src);
  if (bind (s, (struct sockaddr *)&t->src, sizeof t->src))
d188 8
a195 1
      log_error ("udp_make: bind (%d, %p, %d)", s, &t->src, sizeof t->src);
a198 1
  memset (&t->dst, 0, sizeof t->dst);
d209 1
a209 1
    free (t);
d215 1
a215 1
udp_clone (struct udp_transport *u, struct sockaddr_in *raddr)
d229 18
a246 1
  memcpy (&u2->dst, raddr, sizeof u2->dst);
d261 1
a261 1
udp_bind (in_addr_t addr, in_port_t port)
d263 4
a266 1
  struct sockaddr_in src;
d268 2
a269 8
  memset (&src, 0, sizeof src);
#ifndef USE_OLD_SOCKADDR
  src.sin_len = sizeof src;
#endif
  src.sin_family = AF_INET;
  src.sin_addr.s_addr = addr;
  src.sin_port = port;
  return udp_make (&src);
d279 2
a280 2
  in_port_t port = *(in_port_t *)arg;
  in_addr_t if_addr = ((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr;
d283 1
a283 1
  struct in_addr addr;
d286 2
a287 1
  int s;
a290 1
   * XXX IPv6 support is missing.
d293 2
a294 1
  if (ifrp->ifr_addr.sa_family != AF_INET)
d296 5
a300 2
  if (ifrp->ifr_addr.sa_family != AF_INET
      || ifrp->ifr_addr.sa_len != sizeof (struct sockaddr_in))
a301 1
    return;
d307 1
d312 1
d343 1
a343 1
	  if (!inet_aton (address->field, &addr))
d351 6
a356 2
	  if (addr.s_addr == if_addr)
	    break;
d370 17
a386 1
  t = udp_bind (if_addr, port);
d389 5
a393 2
      log_print ("udp_bind_if: failed to create a socket on %s:%d",
		 inet_ntoa (*((struct in_addr *)&if_addr)), ntohs (port));
d407 2
a408 1
  struct sockaddr_in dst;
a409 2
  in_addr_t addr;
  in_port_t port;
d412 4
a415 9
  if (port_str)
    {
      port = udp_decode_port (port_str);
      if (!port)
	return 0;
    }
  else
    port = UDP_DEFAULT_PORT;
  port = htons (port);
d423 1
a423 2
  addr = inet_addr (addr_str);
  if (addr == INADDR_NONE)
d425 1
a425 1
      log_print ("udp_create: inet_addr (\"%s\") failed", addr_str);
a428 8
  memset (&dst, 0, sizeof dst);
#ifndef USE_OLD_SOCKADDR
  dst.sin_len = sizeof dst;
#endif
  dst.sin_family = AF_INET;
  dst.sin_addr.s_addr = addr;
  dst.sin_port = port;

d437 2
a438 1
	  return 0;
d441 4
a444 1
	return udp_clone ((struct udp_transport *)default_transport, &dst);
d447 1
a447 2
  addr = inet_addr (addr_str);
  if (addr == INADDR_NONE)
d449 3
a451 2
      log_print ("udp_create: inet_addr (\"%s\") failed", addr_str);
      return 0;
d453 2
a454 2
  u = udp_listen_lookup (addr, (udp_default_port ? htons (udp_default_port) :
						   htons (UDP_DEFAULT_PORT)));
d457 1
a457 1
      log_print ("udp_create: %s:%d must exist as a listener too", addr_str,
d459 2
a460 1
      return 0;
d462 5
a466 1
  return udp_clone (u, &dst);
d472 6
d486 4
a489 1
  char src[16], dst[16];
d491 7
a497 4
  snprintf (src, 16, "%s", inet_ntoa (u->src.sin_addr));
  snprintf (dst, 16, "%s", inet_ntoa (u->dst.sin_addr));
  LOG_DBG ((LOG_REPORT, 0, "udp_report: fd %d src %s dst %s", u->s, src,
	    dst));
d508 3
a510 3
  struct protoent *p;
  struct servent *s;
  in_port_t port;
d513 1
a513 9
  p = getprotobyname ("udp");
  udp_proto = p ? p->p_proto : IPPROTO_UDP;
  if (udp_default_port)
    port = htons (udp_default_port);
  else
    {
      s = getservbyname ("isakmp", "udp");
      port = s ? s->s_port : htons (UDP_DEFAULT_PORT);
    }
d519 1
a519 1
  if_map (udp_bind_if, &port);
d527 7
a533 1
  default_transport = udp_bind (INADDR_ANY, port);
d579 1
a579 1
  struct sockaddr_in from;
d596 1
a596 1
  t = udp_clone (u, &from);
d620 2
a621 2
  m.msg_name = (caddr_t)&u->dst;
  m.msg_namelen = sizeof u->dst;
d643 1
a643 1
  *dst = (struct sockaddr *)&((struct udp_transport *)t)->dst;
d648 1
a648 1
 * to by SRC.
d653 1
a653 1
  *src = (struct sockaddr *)&((struct udp_transport *)t)->src;
d689 1
a689 1
 * binary port number.  Return zero if anything goes wrong.
d698 1
a698 1
  port_long = strtol (port_str, &port_str_end, 0);
@


1.30
log
@Print the right port on error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.29 2001/04/09 22:09:53 ho Exp $	*/
d92 2
a93 2
static void udp_get_dst (struct transport *, struct sockaddr **, int *);
static void udp_get_src (struct transport *, struct sockaddr **, int *);
d578 1
a578 1
 * to by DST.  Put its length into DST_LEN.
d581 1
a581 1
udp_get_dst (struct transport *t, struct sockaddr **dst, int *dst_len)
a583 1
  *dst_len = sizeof ((struct udp_transport *)t)->dst;
d588 1
a588 1
 * to by SRC.  Put its length into SRC_LEN.
d591 1
a591 1
udp_get_src (struct transport *t, struct sockaddr **src, int *src_len)
a593 1
  *src_len = sizeof ((struct udp_transport *)t)->src;
@


1.29
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.28 2001/03/06 22:17:21 angelos Exp $	*/
d337 1
a337 1
		 inet_ntoa (*((struct in_addr *)&if_addr)), port);
@


1.28
log
@Don't use the source for both sides!
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.27 2001/01/27 12:03:36 niklas Exp $	*/
d457 1
a457 1
      s = getservbyname("isakmp", "udp");
@


1.27
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.26 2001/01/26 12:12:52 niklas Exp $	*/
d622 1
a622 1
  strcpy (iddst, inet_ntoa (((struct udp_transport *)t)->src.sin_addr));
@


1.26
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.25 2001/01/26 11:08:08 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.25
log
@Merge with EOM 1.57

author: niklas
Remove unused constant
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.24 2000/11/23 12:56:51 niklas Exp $	*/
d463 1
a463 1
  /* Bind the ISAKMP UDP port on all network interfaces we have. */
@


1.24
log
@Merge with EOM 1.56

author: niklas
style nits

author: angelos
Print and use correct port when looking at listening sockets.
Don't setup unnecessary flows on the receiver side.

author: angelos
Careful on the type used by inet_ntoa()

author: niklas
byte ordering
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.23 2000/10/16 23:27:23 niklas Exp $	*/
/*	$EOM: udp.c,v 1.56 2000/11/23 12:22:08 niklas Exp $	*/
a65 1
#define BACKLOG 16
@


1.23
log
@Merge with EOM 1.52

author: niklas
ifdef HAVE_GETNAMINFO

author: angelos
That comment doesn't justify an XXX mark :-)
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.22 2000/08/03 07:23:55 niklas Exp $	*/
/*	$EOM: udp.c,v 1.52 2000/10/15 22:02:55 niklas Exp $	*/
d337 2
a338 2
      log_print ("udp_bind_if: failed to create a socket on %x:%d",
		 htons (if_addr), port);
d346 1
a346 1
 * a transport useable to talk to the peer specified by that name
d409 2
a410 1
  u = udp_listen_lookup (addr, port);
d414 1
a414 1
		 port);
d650 1
a650 1
      return service->s_port;
@


1.23.2.1
log
@Pull in patch from current:
Fix (niklas, angelos):
Merge with EOM 1.56

author: niklas
style nits

author: angelos
Print and use correct port when looking at listening sockets.
Don't setup unnecessary flows on the receiver side.

author: angelos
Careful on the type used by inet_ntoa()

author: niklas
byte ordering
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.23 2000/10/16 23:27:23 niklas Exp $	*/
d337 2
a338 2
      log_print ("udp_bind_if: failed to create a socket on %s:%d",
		 inet_ntoa (*((struct in_addr *)&if_addr)), port);
d346 1
a346 1
 * a transport useable to talk to the peer specified by that name.
d409 1
a409 2
  u = udp_listen_lookup (addr, (udp_default_port ? htons (udp_default_port) :
						   htons (UDP_DEFAULT_PORT)));
d413 1
a413 1
		 udp_default_port);
d649 1
a649 1
      return ntohs (service->s_port);
@


1.23.2.2
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.29 2001/04/09 22:09:53 ho Exp $	*/
/*	$EOM: udp.c,v 1.57 2001/01/26 10:09:57 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2001 Niklas Hallqvist.  All rights reserved.
d66 1
d458 1
a458 1
      s = getservbyname ("isakmp", "udp");
d464 1
a464 1
  /* Bind the ISAKMP UDP port on all network interfaces we have.  */
d623 1
a623 1
  strcpy (iddst, inet_ntoa (((struct udp_transport *)t)->dst.sin_addr));
@


1.22
log
@udp.c: Merge with EOM 1.50
transport.h: Merge with EOM 1.16

author: provos
provide transport dependent ID decoding; hope indentation is right now ;)
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.21 2000/04/07 22:04:58 niklas Exp $	*/
/*	$EOM: udp.c,v 1.50 2000/07/17 18:57:59 provos Exp $	*/
d302 1
a302 1
   * XXX This is quite wasteful redoing the list-run for every interface,
d604 1
d607 1
a607 1
		  idsrc, sizeof(idsrc), NULL, 0, NI_NUMERICHOST) != 0)
d609 1
a609 1
      log_error ("ipsec_ipv4toa: getnameinfo() failed");
d615 1
a615 1
		  iddst, sizeof(iddst), NULL, 0, NI_NUMERICHOST) != 0)
d617 1
a617 1
      log_error ("ipsec_ipv4toa: getnameinfo() failed");
d620 5
@


1.21
log
@Merge with EOM 1.49

author: ho
Missing #ifndef linux
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.20 2000/03/08 08:43:16 niklas Exp $	*/
/*	$EOM: udp.c,v 1.49 2000/03/14 19:42:32 ho Exp $	*/
d95 1
d107 2
a108 1
  udp_get_src
d598 25
@


1.20
log
@Merge with EOM 1.48

author: ho
Do not crash if user forgot address field.
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.19 2000/02/25 17:23:42 niklas Exp $	*/
/*	$EOM: udp.c,v 1.48 2000/03/07 21:37:52 ho Exp $	*/
d41 1
d43 1
@


1.19
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.18 2000/02/01 02:46:19 niklas Exp $	*/
/*	$EOM: udp.c,v 1.47 2000/02/20 19:58:42 niklas Exp $	*/
d365 5
@


1.18
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.17 2000/01/26 15:22:17 niklas Exp $	*/
/*	$EOM: udp.c,v 1.46 2000/01/31 22:33:49 niklas Exp $	*/
d425 2
a426 1
  log_debug (LOG_REPORT, 0, "udp_report: fd %d src %s dst %s", u->s, src, dst);
@


1.17
log
@Merge with EOM 1.45

date: 2000/01/25 06:51:20;  author: angelos;  state: Exp;  lines: +2 -3
Unneeded variable.

date: 2000/01/25 06:50:51;  author: angelos;  state: Exp;  lines: +1 -27
Didn't realize there was a sysdep_cleartext() for setting the BYPASS
flags for socket security levels. Remove reduntant setsockopt() code.

date: 2000/01/11 04:47:41;  author: angelos;  state: Exp;  lines: +30 -4
Set IPSEC_LEVEL_BYPASS on all our sockets, so IKE packets don't
accidentally get encrypted.
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.16 1999/10/01 14:08:05 niklas Exp $	*/
/*	$EOM: udp.c,v 1.45 2000/01/25 06:51:20 angelos Exp $	*/
d6 1
@


1.16
log
@Merge with EOM 1.42

author: niklas
Do not consider down interfaces or ones with bad addresses
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.15 1999/06/05 23:11:19 niklas Exp $	*/
/*	$EOM: udp.c,v 1.42 1999/09/30 12:59:27 niklas Exp $	*/
d131 1
a131 2
  int s;
  int on;
d166 2
a167 2
		   && conf_get_str ("General", "Listen-on"))
		  ? SO_REUSEPORT : SO_REUSEADDR,
@


1.15
log
@Merge with EOM 1.41, RCSIds
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.14 1999/06/05 22:54:42 niklas Exp $	*/
/*	$EOM: udp.c,v 1.41 1999/06/05 23:08:53 niklas Exp $	*/
d38 1
d40 1
d254 2
d258 1
a258 1
   * Well UDP is an internet protocol after all so drop other ifreqs.
d270 26
d384 9
a392 1
    return udp_clone ((struct udp_transport *)default_transport, &dst);
@


1.14
log
@Use the Listen-on address as local address if Local-address
not given, but Listen-on is.
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.13 1999/04/30 11:46:59 niklas Exp $	*/
/*	$EOM: udp.c,v 1.40 1999/04/29 18:46:54 niklas Exp $	*/
@


1.13
log
@Merge with EOM 1.40

author: niklas
inet_ntoa returns a static, do not call twice in an expression
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.12 1999/04/27 21:09:01 niklas Exp $	*/
d351 2
@


1.12
log
@Merge with EOM 1.39

author: niklas
reference transport when doing listen sockets.  Style + remove old comment
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.11 1999/04/19 20:55:09 niklas Exp $	*/
/*	$EOM: udp.c,v 1.39 1999/04/25 22:01:58 niklas Exp $	*/
d381 5
a385 3
 
  log_debug (LOG_REPORT, 0, "udp_report: fd %d src %s dst %s", u->s,
	     inet_ntoa (u->src.sin_addr), inet_ntoa (u->dst.sin_addr));
@


1.11
log
@./udp.c: Merge with EOM 1.38

Add LOG_REPORT to always go to logchannel regardless of level; misc small fixes

Move transport-independent reporting to transport_report instead.  Also
report the socket fd for UDP transports.  A derived transport class is always
aligned with the transport superclass, so there is no need to search for
the udp_transport that matches a given transport.

Add udp_report for transport_report

Garbage collect transports via refcounting.  Fix commentary.
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.10 1999/04/05 21:00:08 niklas Exp $	*/
/*	$EOM: udp.c,v 1.38 1999/04/13 20:00:42 ho Exp $	*/
d181 2
a182 1
  transport_add ((struct transport *)t);
d184 1
a184 1
  return (struct transport *)t;
a460 2
 * XXX We will be leaking transports unless we kill them after last
 * probable use, i.e. when ISAKMP SA's gets torn down.
@


1.10
log
@Merge with EOM 1.34
Mem leak plugging.

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.9 1999/03/31 23:47:12 niklas Exp $	*/
/*	$EOM: udp.c,v 1.34 1999/04/05 08:09:56 niklas Exp $	*/
d81 2
d94 2
d202 4
a205 1
    return 0;
d369 16
d492 1
a492 1
    /* XXX Log.  */
@


1.9
log
@Merge with EOM 1.32
Implement Local-address binding
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.8 1999/03/02 15:12:00 niklas Exp $	*/
/*	$EOM: udp.c,v 1.32 1999/03/31 23:34:48 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d280 1
@


1.8
log
@if.c: Merge with EOM 1.8
Deal with old socket APIs

udp.c: Merge with EOM 1.31
Deal with old socket APIs

message.c: Merge with EOM 1.107
Remove unnecessary system dependent include
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.7 1999/02/26 03:51:33 niklas Exp $	*/
/*	$EOM: udp.c,v 1.31 1999/03/02 14:26:13 niklas Exp $	*/
d75 1
d89 1
a89 1
struct transport_vtbl udp_transport_vtbl = {
d100 3
d108 12
d150 1
a150 1
   * sending from it make it is entirely reuseable with SO_REUSEPORT.
d243 1
d291 8
a298 2
  /* XXX Deal with errors better.  */
  udp_bind (if_addr, port);
d308 1
d323 1
d339 1
a339 1
  dst.sin_port = htons (port);
d341 18
a358 1
  return udp_clone ((struct udp_transport *)default_transport, &dst);
d383 2
@


1.7
log
@Merge from the Ericsson repository
| revision 1.30
| date: 1999/02/25 11:39:25;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
| revision 1.29
| date: 1999/02/24 15:45:38;  author: niklas;  state: Exp;  lines: +17 -5
| Use correct socket options for sharing of ports
| ----------------------------
| revision 1.28
| date: 1999/02/24 12:17:02;  author: niklas;  state: Exp;  lines: +2 -3
| Set extra transport flags after initialization
| ----------------------------
| revision 1.27
| date: 1999/02/14 00:16:07;  author: niklas;  state: Exp;  lines: +51 -8
| New fd_set API.  Listen on chosen interfaces only.
| ----------------------------
| revision 1.26
| date: 1999/01/31 01:23:22;  author: niklas;  state: Exp;  lines: +3 -1
| commentary
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.6 1998/12/22 02:25:15 niklas Exp $	*/
/*	$EOM: udp.c,v 1.30 1999/02/25 11:39:25 niklas Exp $	*/
d64 5
d206 1
d208 1
d232 3
d237 1
d309 1
d311 1
@


1.6
log
@Generalize udp port decoding.  Remove unneeded decls.
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.5 1998/12/22 01:46:04 niklas Exp $	*/
/*	$EOM: udp.c,v 1.25 1998/12/22 02:23:42 niklas Exp $	*/
d49 2
d75 1
a75 1
static int udp_fd_set (struct transport *, fd_set *);
d125 6
d132 5
a136 2
  /* XXX Is this redundant considering SO_REUSEPORT below?  */
  if (setsockopt (s, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof on) == -1)
d139 4
a142 1
		 SO_REUSEADDR, &on, sizeof on);
d156 1
a157 2

  transport_add ((struct transport *)t);
d180 1
a180 1
  memcpy (t, u, sizeof *u);
d216 4
d229 34
d264 1
a264 1
  udp_bind (((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr, port);
d334 2
a335 1
   * Bind to INADDR_ANY in case of new addresses popping up.
d342 2
d353 1
a353 1
udp_fd_set (struct transport *t, fd_set *fds)
d357 5
a361 1
  FD_SET (u->s, fds);
@


1.5
log
@Remove obsolete connection code.  Use strtol instead of atoi
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.4 1998/12/21 01:02:27 niklas Exp $	*/
/*	$EOM: udp.c,v 1.24 1998/12/22 01:40:23 niklas Exp $	*/
a226 3
  char *port_str_end;
  long port_long;
  struct servent *service;
d231 3
a233 18
      port_long = strtol (port_str, &port_str_end, 0);
      if (port_str == port_str_end)
	{
	  service = getservbyname (port_str, "udp");
	  if (!service)
	    {
	      log_print ("udp_create: service \"%s\" unknown", port_str);
	      return 0;
	    }
	  port = service->s_port;
	}
      else if (port_long < 1 || port_long > 65535)
	{
	  log_print ("udp_create: port %l out of range", port_long);
	  return 0;
	}
      else
	port = port_long;
d406 31
@


1.4
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.3 1998/11/17 11:10:21 niklas Exp $	*/
/*	$EOM: udp.c,v 1.23 1998/12/15 16:58:48 niklas Exp $	*/
a216 55
 * ADDR_ARG is either a numeric IP address (we cannot risk doing DNS lookups
 * which might take considerable time) or an address and a UDP port number
 * separated by a colon.  That address specifies a peer ISAKMP daemon we
 * will talk to.  Setup and return a transport useable to talk to that
 * service.
 */
static struct transport *
udp_create_old (char *addr_arg)
{
  struct sockaddr_in dst;
  char *addr_str, *port_str;
  in_addr_t addr;
  in_port_t port;

  addr_str = strdup (addr_arg);
  if (!addr_str)
    {
      log_print ("udp_create_old: strdup (\"%s\") failed", addr_arg);
      return 0;
    }

  port_str = strchr (addr_str, ':');
  if (port_str)
    {
      *port_str++ = '\0';
      port = atoi (port_str);
      if (!port)
	{
	  log_print ("udp_create_old: connection to port 0 not allowed");
	  free (addr_str);
	  return 0;
	}
    }
  else
    port = UDP_DEFAULT_PORT;

  addr = inet_addr (addr_str);
  if (addr == INADDR_NONE)
    {
      log_print ("udp_create_old: inet_addr (\"%s\") failed", addr_str);
      free (addr_str);
      return 0;
    }
  free (addr_str);

  memset (&dst, 0, sizeof dst);
  dst.sin_len = sizeof dst;
  dst.sin_family = AF_INET;
  dst.sin_addr.s_addr = addr;
  dst.sin_port = htons (port);

  return udp_clone ((struct udp_transport *)default_transport, &dst);
}

/*
d227 2
a230 5
  /* If an address tag does not exist, try backward compatibility mode.  */
  addr_str = conf_get_str (name, "Address");
  if (!addr_str)
    return udp_create_old (name);

d234 2
a235 1
      if (!isdigit (port_str[0]))
d245 1
a245 1
      else
d247 2
a248 7
	  port = atoi (port_str);
	  if (!port)
	    {
	      log_print ("udp_create: port specification \"%s\" malformed",
			 port_str);
	      return 0;
	    }
d250 2
d256 1
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: udp.c,v 1.2 1998/11/15 00:44:04 niklas Exp $	*/
/*	$EOM: udp.c,v 1.22 1998/10/11 20:25:11 niklas Exp $	*/
d42 1
d49 1
d217 1
a217 1
 * ADDR is either a numeric IP address (we cannot risk doing DNS lookups
d224 1
a224 1
udp_create (char *addr_arg)
d234 1
a234 1
      log_print ("udp_create: strdup (\"%s\") failed", addr_arg);
d237 1
d244 68
a311 1
	log_print ("udp_create: connection to port 0 not allowed");
d315 1
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: udp.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: udp.c,v 1.22 1998/10/11 20:25:11 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
