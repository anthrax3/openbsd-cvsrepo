head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.6
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.8
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.10
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.8
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.22
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.20
	OPENBSD_5_0:1.20.0.18
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.16
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.14
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.10
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.12
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.8
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.6
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7;
locks; strict;
comment	@ * @;


1.24
date	2015.08.20.22.05.51;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	kSNAVuz4GFuZCA1Z;

1.23
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	0qPuuXwccpVXsXcV;

1.22
date	2014.11.19.13.35.37;	author krw;	state Exp;
branches;
next	1.21;
commitid	mAzZN8w74KfuFeKi;

1.21
date	2012.10.29.17.09.52;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.05.17.43.34;	author cloder;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.22.10.01.02;	author hshoexer;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.14.14.03.33;	author hshoexer;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.25.15.03.47;	author hshoexer;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.02.19.49.23;	author hshoexer;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.18.20.04.51;	author hshoexer;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.05.18.06.06;	author cloder;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.05.12.22.40;	author ho;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.18.18.15.46;	author hshoexer;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2004.08.03.10.54.09;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.29.08.54.08;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.30.10.07.13;	author hshoexer;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.21.23.27.10;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.20.17.17.35;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	;

1.7.2.1
date	2004.11.21.19.19.39;	author brad;	state Exp;
branches;
next	;

1.10.2.1
date	2005.05.29.20.46.24;	author brad;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Do not cast a size_t to (unsigned long) to pass it as an argument to malloc.
Like really, who does??!
@
text
@/*	$OpenBSD: nat_traversal.c,v 1.23 2015/08/20 22:02:21 deraadt Exp $	*/

/*
 * Copyright (c) 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdlib.h>
#include <string.h>

#include "conf.h"
#include "exchange.h"
#include "hash.h"
#include "ipsec.h"
#include "isakmp_fld.h"
#include "isakmp_num.h"
#include "ipsec_num.h"
#include "log.h"
#include "message.h"
#include "nat_traversal.h"
#include "prf.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "util.h"
#include "virtual.h"

int	disable_nat_t = 0;

/*
 * NAT-T capability of the other peer is determined by a particular vendor
 * ID sent in the first message. This vendor ID string is supposed to be a
 * MD5 hash of "RFC 3947".
 *
 * These seem to be the "well" known variants of this string in use by
 * products today.
 *
 * Note that the VID specified in draft 2 is ambiguous: It was
 * accidentally calculated from the string "draft-ietf-ipsec-nat-t-ike-02\n"
 * although the string was documented without the trailing '\n'. The authors
 * suggested afterwards to use the string with the trailing '\n'.
 */

static struct nat_t_cap isakmp_nat_t_cap[] = {
	{ VID_DRAFT_V2_N, EXCHANGE_FLAG_NAT_T_DRAFT,
	  "draft-ietf-ipsec-nat-t-ike-02\n", NULL, 0 },
	{ VID_DRAFT_V3, EXCHANGE_FLAG_NAT_T_DRAFT,
	  "draft-ietf-ipsec-nat-t-ike-03", NULL, 0 },
	{ VID_RFC3947, EXCHANGE_FLAG_NAT_T_RFC,
	  "RFC 3947", NULL, 0 },
};

#define NUMNATTCAP	(sizeof isakmp_nat_t_cap / sizeof isakmp_nat_t_cap[0])

/* In seconds. Recommended in draft-ietf-ipsec-udp-encaps-09.  */
#define NAT_T_KEEPALIVE_INTERVAL	20

static int	nat_t_setup_hashes(void);
static int	nat_t_add_vendor_payload(struct message *, struct nat_t_cap *);
static int	nat_t_add_nat_d(struct message *, struct sockaddr *);
static int	nat_t_match_nat_d_payload(struct message *, struct sockaddr *);

void
nat_t_init(void)
{
	nat_t_setup_hashes();
}

/* Generate the NAT-T capability marker hashes. Executed only once.  */
static int
nat_t_setup_hashes(void)
{
	struct hash *hash;
	int n = NUMNATTCAP;
	int i;

	/* The draft says to use MD5.  */
	hash = hash_get(HASH_MD5);
	if (!hash) {
		/* Should never happen.  */
		log_print("nat_t_setup_hashes: "
		    "could not find MD5 hash structure!");
		return -1;
	}

	/* Populate isakmp_nat_t_cap with hashes.  */
	for (i = 0; i < n; i++) {
		isakmp_nat_t_cap[i].hashsize = hash->hashsize;
		isakmp_nat_t_cap[i].hash = malloc(hash->hashsize);
		if (!isakmp_nat_t_cap[i].hash) {
			log_error("nat_t_setup_hashes: malloc (%lu) failed",
			    (unsigned long)hash->hashsize);
			goto errout;
		}

		hash->Init(hash->ctx);
		hash->Update(hash->ctx,
		    (unsigned char *)isakmp_nat_t_cap[i].text,
		    strlen(isakmp_nat_t_cap[i].text));
		hash->Final(isakmp_nat_t_cap[i].hash, hash->ctx);

		LOG_DBG((LOG_EXCHANGE, 50, "nat_t_setup_hashes: "
		    "MD5(\"%s\") (%lu bytes)", isakmp_nat_t_cap[i].text,
		    (unsigned long)hash->hashsize));
		LOG_DBG_BUF((LOG_EXCHANGE, 50, "nat_t_setup_hashes",
		    isakmp_nat_t_cap[i].hash, hash->hashsize));
	}

	return 0;

errout:
	for (i = 0; i < n; i++)
		free(isakmp_nat_t_cap[i].hash);
	return -1;
}

/* Add one NAT-T VENDOR payload.  */
static int
nat_t_add_vendor_payload(struct message *msg, struct nat_t_cap *cap)
{
	size_t	  buflen = cap->hashsize + ISAKMP_GEN_SZ;
	u_int8_t *buf;

	if (disable_nat_t)
		return 0;

	buf = malloc(buflen);
	if (!buf) {
		log_error("nat_t_add_vendor_payload: malloc (%lu) failed",
		    (unsigned long)buflen);
		return -1;
	}

	SET_ISAKMP_GEN_LENGTH(buf, buflen);
	memcpy(buf + ISAKMP_VENDOR_ID_OFF, cap->hash, cap->hashsize);
	if (message_add_payload(msg, ISAKMP_PAYLOAD_VENDOR, buf, buflen, 1)) {
		free(buf);
		return -1;
	}
	return 0;
}

/* Add the NAT-T capability markers (VENDOR payloads).  */
int
nat_t_add_vendor_payloads(struct message *msg)
{
	int i;

	if (disable_nat_t)
		return 0;

	for (i = 0; i < NUMNATTCAP; i++)
		if (nat_t_add_vendor_payload(msg, &isakmp_nat_t_cap[i]))
			return -1;
	return 0;
}

/*
 * Check an incoming message for NAT-T capability markers.
 */
void
nat_t_check_vendor_payload(struct message *msg, struct payload *p)
{
	u_int8_t *pbuf = p->p;
	size_t	  vlen;
	int	  i;

	if (disable_nat_t)
		return;

	vlen = GET_ISAKMP_GEN_LENGTH(pbuf) - ISAKMP_GEN_SZ;

	for (i = 0; i < NUMNATTCAP; i++) {
		if (vlen != isakmp_nat_t_cap[i].hashsize) {
			continue;
		}
		if (memcmp(isakmp_nat_t_cap[i].hash, pbuf + ISAKMP_GEN_SZ,
		    vlen) == 0) {
			/* This peer is NAT-T capable.  */
			msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_CAP_PEER;
			msg->exchange->flags |= isakmp_nat_t_cap[i].flags;
			LOG_DBG((LOG_EXCHANGE, 10,
			    "nat_t_check_vendor_payload: "
			    "NAT-T capable peer detected"));
			p->flags |= PL_MARK;
		}
	}

	return;
}

/* Generate the NAT-D payload hash : HASH(CKY-I | CKY-R | IP | Port).  */
static u_int8_t *
nat_t_generate_nat_d_hash(struct message *msg, struct sockaddr *sa,
    size_t *hashlen)
{
	struct ipsec_exch *ie = (struct ipsec_exch *)msg->exchange->data;
	struct hash	 *hash;
	u_int8_t	 *res;
	in_port_t	  port;

	hash = hash_get(ie->hash->type);
	if (hash == NULL) {
		log_print ("nat_t_generate_nat_d_hash: no hash");
		return NULL;
	}

	*hashlen = hash->hashsize;

	res = malloc(*hashlen);
	if (!res) {
		log_print("nat_t_generate_nat_d_hash: malloc (%lu) failed",
		    (unsigned long)*hashlen);
		*hashlen = 0;
		return NULL;
	}

	port = sockaddr_port(sa);
	bzero(res, *hashlen);

	hash->Init(hash->ctx);
	hash->Update(hash->ctx, msg->exchange->cookies,
	    sizeof msg->exchange->cookies);
	hash->Update(hash->ctx, sockaddr_addrdata(sa), sockaddr_addrlen(sa));
	hash->Update(hash->ctx, (unsigned char *)&port, sizeof port);
	hash->Final(res, hash->ctx);
	return res;
}

/* Add a NAT-D payload to our message.  */
static int
nat_t_add_nat_d(struct message *msg, struct sockaddr *sa)
{
	int	  ret;
	u_int8_t *hbuf, *buf;
	size_t	  hbuflen, buflen;

	hbuf = nat_t_generate_nat_d_hash(msg, sa, &hbuflen);
	if (!hbuf) {
		log_print("nat_t_add_nat_d: NAT-D hash gen failed");
		return -1;
	}

	buflen = ISAKMP_NAT_D_DATA_OFF + hbuflen;
	buf = malloc(buflen);
	if (!buf) {
		log_error("nat_t_add_nat_d: malloc (%lu) failed",
		    (unsigned long)buflen);
		free(hbuf);
		return -1;
	}

	SET_ISAKMP_GEN_LENGTH(buf, buflen);
	memcpy(buf + ISAKMP_NAT_D_DATA_OFF, hbuf, hbuflen);
	free(hbuf);

	if (msg->exchange->flags & EXCHANGE_FLAG_NAT_T_RFC)
		ret = message_add_payload(msg, ISAKMP_PAYLOAD_NAT_D, buf,
		    buflen, 1);
	else if (msg->exchange->flags & EXCHANGE_FLAG_NAT_T_DRAFT)
		ret = message_add_payload(msg, ISAKMP_PAYLOAD_NAT_D_DRAFT,
		    buf, buflen, 1);
	else
		ret = -1;
		
	if (ret) {
		free(buf);
		return -1;
	}
	return 0;
}

/* We add two NAT-D payloads, one each for src and dst.  */
int
nat_t_exchange_add_nat_d(struct message *msg)
{
	struct sockaddr *sa;

	/* Remote address first. */
	msg->transport->vtbl->get_dst(msg->transport, &sa);
	if (nat_t_add_nat_d(msg, sa))
		return -1;

	msg->transport->vtbl->get_src(msg->transport, &sa);
	if (nat_t_add_nat_d(msg, sa))
		return -1;
	return 0;
}

/* Generate and match a NAT-D hash against the NAT-D payload (pl.) data.  */
static int
nat_t_match_nat_d_payload(struct message *msg, struct sockaddr *sa)
{
	struct payload *p;
	u_int8_t *hbuf;
	size_t	 hbuflen;
	int	 found = 0;

	/*
	 * If there are no NAT-D payloads in the message, return "found"
	 * as this will avoid NAT-T (see nat_t_exchange_check_nat_d()).
	 */
	if ((p = payload_first(msg, ISAKMP_PAYLOAD_NAT_D_DRAFT)) == NULL &&
	    (p = payload_first(msg, ISAKMP_PAYLOAD_NAT_D)) == NULL)
		return 1;

	hbuf = nat_t_generate_nat_d_hash(msg, sa, &hbuflen);
	if (!hbuf)
		return 0;

	for (; p; p = TAILQ_NEXT(p, link)) {
		if (GET_ISAKMP_GEN_LENGTH (p->p) !=
		    hbuflen + ISAKMP_NAT_D_DATA_OFF)
			continue;

		if (memcmp(p->p + ISAKMP_NAT_D_DATA_OFF, hbuf, hbuflen) == 0) {
			found++;
			break;
		}
	}
	free(hbuf);
	return found;
}

/*
 * Check if we need to activate NAT-T, and if we need to send keepalive
 * messages to the other side, i.e if we are a nat:ed peer.
 */
int
nat_t_exchange_check_nat_d(struct message *msg)
{
	struct sockaddr *sa;
	int	 outgoing_path_is_clear, incoming_path_is_clear;

	/* Assume trouble, i.e NAT-boxes in our path.  */
	outgoing_path_is_clear = incoming_path_is_clear = 0;

	msg->transport->vtbl->get_src(msg->transport, &sa);
	if (nat_t_match_nat_d_payload(msg, sa))
		outgoing_path_is_clear = 1;

	msg->transport->vtbl->get_dst(msg->transport, &sa);
	if (nat_t_match_nat_d_payload(msg, sa))
		incoming_path_is_clear = 1;

	if (outgoing_path_is_clear && incoming_path_is_clear) {
		LOG_DBG((LOG_EXCHANGE, 40, "nat_t_exchange_check_nat_d: "
		    "no NAT"));
		return 0; /* No NAT-T required.  */
	}

	/* NAT-T handling required.  */
	msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_ENABLE;

	if (!outgoing_path_is_clear) {
		msg->exchange->flags |= EXCHANGE_FLAG_NAT_T_KEEPALIVE;
		LOG_DBG((LOG_EXCHANGE, 10, "nat_t_exchange_check_nat_d: "
		    "NAT detected, we're behind it"));
	} else
		LOG_DBG ((LOG_EXCHANGE, 10,
		    "nat_t_exchange_check_nat_d: NAT detected"));
	return 1;
}

static void
nat_t_send_keepalive(void *v_arg)
{
	struct sa *sa = (struct sa *)v_arg;
	struct transport *t;
	struct timeval now;
	int interval;

	/* Send the keepalive message.  */
	t = ((struct virtual_transport *)sa->transport)->encap;
	t->vtbl->send_message(NULL, t);

	/* Set new timer.  */
	interval = conf_get_num("General", "NAT-T-Keepalive", 0);
	if (interval < 1)
		interval = NAT_T_KEEPALIVE_INTERVAL;
	gettimeofday(&now, 0);
	now.tv_sec += interval;

	sa->nat_t_keepalive = timer_add_event("nat_t_send_keepalive",
	    nat_t_send_keepalive, v_arg, &now);
	if (!sa->nat_t_keepalive)
		log_print("nat_t_send_keepalive: "
		    "timer_add_event() failed, will send no more keepalives");
}

void
nat_t_setup_keepalive(struct sa *sa)
{
	struct sockaddr *src;
	struct timeval now;

	if (sa->initiator)
		sa->transport->vtbl->get_src(sa->transport, &src);
	else
		sa->transport->vtbl->get_dst(sa->transport, &src);

	if (!virtual_listen_lookup(src))
		return;

	gettimeofday(&now, 0);
	now.tv_sec += NAT_T_KEEPALIVE_INTERVAL;

	sa->nat_t_keepalive = timer_add_event("nat_t_send_keepalive",
	    nat_t_send_keepalive, sa, &now);
	if (!sa->nat_t_keepalive)
		log_print("nat_t_setup_keepalive: "
		    "timer_add_event() failed, will not send keepalives");

	LOG_DBG((LOG_TRANSPORT, 50, "nat_t_setup_keepalive: "
	    "added event for phase 1 SA %p", sa));
}
@


1.23
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.22 2014/11/19 13:35:37 krw Exp $	*/
d230 1
a230 1
	res = malloc((unsigned long)*hashlen);
@


1.22
log
@Nuke yet more obvious #include duplications.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.21 2012/10/29 17:09:52 markus Exp $	*/
d109 1
a109 1
		isakmp_nat_t_cap[i].hash = (char *)malloc(hash->hashsize);
d230 1
a230 1
	res = (u_int8_t *)malloc((unsigned long)*hashlen);
@


1.21
log
@backout possible infinit-loop (from rev 1.5) when parsing nat_d;
report from Thomas Proell/Siemens ProductCERT; fix from hshoexer; ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.20 2007/05/05 17:43:34 cloder Exp $	*/
a37 1
#include "hash.h"
@


1.20
log
@Kill a log message which looks like an error message but is actually
both meaningless and harmless. ("nat_t_check_vendor_payload: bad size")
ok todd
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.19 2007/04/16 13:01:39 moritz Exp $	*/
d332 1
a332 1
	while (p) {
a340 1
		p = TAILQ_NEXT(p, link);
@


1.19
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.18 2007/02/22 10:01:02 hshoexer Exp $	*/
a195 3
			LOG_DBG((LOG_EXCHANGE, 50, "nat_t_check_vendor_payload: "
			    "bad size %lu != %lu", (unsigned long)vlen,
			    (unsigned long)isakmp_nat_t_cap[i].hashsize));
@


1.18
log
@Add a comment that explains, why the VID of draft 2 NAT-T includes
a traling '\n'.

suggested by and ok deraadt@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.17 2006/06/14 14:03:33 hshoexer Exp $	*/
d134 1
a134 2
		if (isakmp_nat_t_cap[i].hash)
			free(isakmp_nat_t_cap[i].hash);
@


1.17
log
@indentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.16 2005/07/25 15:03:47 hshoexer Exp $	*/
d58 5
@


1.16
log
@Use payload NAT-D or NAT-D-DRAFT according to NAT-T vendor ID advertised by the
peer.

looks good ho
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.15 2005/06/02 19:49:23 hshoexer Exp $	*/
d127 1
a127 1
  errout:
@


1.15
log
@unbreak port floating, noticed by sean at obstacle9 dot com

ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.14 2005/05/18 20:04:51 hshoexer Exp $	*/
d59 8
a66 4
static const char *isakmp_nat_t_cap_text[] = {
	"draft-ietf-ipsec-nat-t-ike-02\n",	/* draft, V2 */
	"draft-ietf-ipsec-nat-t-ike-03",	/* draft, V3 */
	"RFC 3947"
d69 2
a73 4
/* The MD5 hashes of the above strings is put in this array.  */
static char	**nat_t_hashes;
static size_t	  nat_t_hashsize;

d75 1
a75 1
static int	nat_t_add_vendor_payload(struct message *, char *);
d82 1
a82 1
	nat_t_hashes = (char **)NULL;
d90 1
a90 1
	int n = sizeof isakmp_nat_t_cap_text / sizeof isakmp_nat_t_cap_text[0];
a100 9
	nat_t_hashsize = hash->hashsize;

	/* Allocate one more than is necessary, i.e NULL terminated.  */
	nat_t_hashes = (char **)calloc((size_t)(n + 1), sizeof(char *));
	if (!nat_t_hashes) {
		log_error("nat_t_setup_hashes: calloc (%lu,%lu) failed",
		    (unsigned long)n, (unsigned long)sizeof(char *));
		return -1;
	}
d102 1
a102 1
	/* Populate with hashes.  */
d104 3
a106 2
		nat_t_hashes[i] = (char *)malloc(nat_t_hashsize);
		if (!nat_t_hashes[i]) {
d108 1
a108 1
			    (unsigned long)nat_t_hashsize);
d114 3
a116 3
		    (unsigned char *)isakmp_nat_t_cap_text[i],
		    strlen(isakmp_nat_t_cap_text[i]));
		hash->Final(nat_t_hashes[i], hash->ctx);
d119 2
a120 2
		    "MD5(\"%s\") (%lu bytes)", isakmp_nat_t_cap_text[i],
		    (unsigned long)nat_t_hashsize));
d122 1
a122 1
		    nat_t_hashes[i], nat_t_hashsize));
d129 2
a130 4
		if (nat_t_hashes[i])
			free(nat_t_hashes[i]);
	free(nat_t_hashes);
	nat_t_hashes = NULL;
d136 1
a136 1
nat_t_add_vendor_payload(struct message *msg, char *hash)
d138 1
a138 1
	size_t	 buflen = nat_t_hashsize + ISAKMP_GEN_SZ;
d152 1
a152 1
	memcpy(buf + ISAKMP_VENDOR_ID_OFF, hash, nat_t_hashsize);
d164 1
a164 1
	int i = 0;
d169 2
a170 5
	if (!nat_t_hashes)
		if (nat_t_setup_hashes())
			return 0;  /* XXX should this be an error?  */
	while (nat_t_hashes[i])
		if (nat_t_add_vendor_payload(msg, nat_t_hashes[i++]))
d183 1
a183 1
	int	  i = 0;
a187 9
	/* Already checked? */
	if (p->flags & PL_MARK ||
	    msg->exchange->flags & EXCHANGE_FLAG_NAT_T_CAP_PEER)
		return;

	if (!nat_t_hashes)
		if (nat_t_setup_hashes())
			return;

a188 6
	if (vlen != nat_t_hashsize) {
		LOG_DBG((LOG_EXCHANGE, 50, "nat_t_check_vendor_payload: "
		    "bad size %lu != %lu", (unsigned long)vlen,
		    (unsigned long)nat_t_hashsize));
		return;
	}
d190 8
a197 2
	while (nat_t_hashes[i])
		if (memcmp(nat_t_hashes[i++], pbuf + ISAKMP_GEN_SZ,
d201 1
a205 1
			return;
d207 3
d254 1
d277 10
a286 1
	if (message_add_payload(msg, ISAKMP_PAYLOAD_NAT_D_DRAFT, buf, buflen, 1)) {
@


1.14
log
@allow payload types 20 and 21 for nat-t

ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.13 2005/04/08 22:32:10 cloder Exp $	*/
d330 2
a331 2
	p = payload_first(msg, ISAKMP_PAYLOAD_NAT_D_DRAFT);
	if (!p)
@


1.13
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.12 2005/04/05 18:06:06 cloder Exp $	*/
d293 1
a293 1
	if (message_add_payload(msg, ISAKMP_PAYLOAD_NAT_D, buf, buflen, 1)) {
d330 1
a330 1
	p = payload_first(msg, ISAKMP_PAYLOAD_NAT_D);
@


1.12
log
@Add -T flag to isakmpd to disable NAT-T support from the command line.
This lets binat setups work again without having to recompile isakmpd.
OK ho, hshoexer.
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.11 2005/04/04 19:31:11 deraadt Exp $	*/
a29 2

#include "sysdep.h"
@


1.11
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.10 2005/03/05 12:22:40 ho Exp $	*/
d51 2
d151 3
d176 3
d197 3
@


1.10
log
@Add RFC3947 NAT-T vendor ID string. hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.9 2005/02/27 13:12:12 hshoexer Exp $	*/
a161 1

a173 1

a176 1

a217 2

	return;
a254 1

a287 1

a304 1

@


1.10.2.1
log
@MFC:
Fix by hshoexer@@

don't advertise RFC compliance when this doesn't work.

ok markus@@ hshoexer@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.10 2005/03/05 12:22:40 ho Exp $	*/
d61 2
a62 1
	"draft-ietf-ipsec-nat-t-ike-03"		/* draft, V3 */
@


1.9
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.8 2004/11/18 18:15:46 hshoexer Exp $	*/
d52 3
a54 4
 * XXX According to draft-ietf-ipsec-nat-t-ike-07.txt, the NAT-T
 * capability of the other peer is determined by a particular vendor ID
 * sent as the first message. This vendor ID string is supposed to be a
 * MD5 hash of "RFC XXXX", where XXXX is the future RFC number.
d60 3
a62 5
	"draft-ietf-ipsec-nat-t-ike-02\n",	/* V2 */
	"draft-ietf-ipsec-nat-t-ike-03",	/* V3 */
#ifdef notyet
	"RFC XXXX",
#endif
@


1.8
log
@use hash and not hmac to calculate NAT-D payloads.  Also add NAT-D payload for
the destination address first.  Remove support for obsolete V1 NAT-T.

This fixes interoperability problems with non-openbsd isakmpd implementations.

"looks good" ho@@, ok markus@@ for hash/hmac
testing by various people (thanks!)
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.7 2004/08/08 19:11:06 deraadt Exp $	*/
d255 1
a255 1
	memset(res, 0, *hashlen);
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.6 2004/08/03 10:54:09 ho Exp $	*/
a60 1
	"draft-ietf-ipsec-nat-t-ike-00",	/* V1 (XXX: may be obsolete) */
a234 1
	struct prf	 *prf;
a236 1
	int		  prf_type = PRF_HMAC; /* XXX */
d244 1
a244 6
	prf = prf_alloc(prf_type, hash->type, msg->exchange->cookies,
	    ISAKMP_HDR_COOKIES_LEN);
	if(!prf) {
		log_print("nat_t_generate_nat_d_hash: prf_alloc failed");
		return NULL;
	}
a245 1
	*hashlen = prf->blocksize;
a249 1
		prf_free(prf);
d257 6
a262 4
	prf->Update(prf->prfctx, sockaddr_addrdata(sa), sockaddr_addrlen(sa));
	prf->Update(prf->prfctx, (unsigned char *)&port, sizeof port);
	prf->Final(res, prf->prfctx);
	prf_free (prf);
d307 2
a308 1
	msg->transport->vtbl->get_src(msg->transport, &sa);
d312 1
a312 1
	msg->transport->vtbl->get_dst(msg->transport, &sa);
@


1.7.2.1
log
@MFC:
Fix by hshoexer@@

use hash and not hmac to calculate NAT-D payloads.  Also add NAT-D payload for
the destination address first.  Remove support for obsolete V1 NAT-T.

This fixes interoperability problems with non-openbsd isakmpd implementations.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.7 2004/08/08 19:11:06 deraadt Exp $	*/
d61 1
d236 1
d239 1
d247 6
a252 1
	*hashlen = hash->hashsize;
d254 1
d259 1
d267 4
a270 6
	hash->Init(hash->ctx);
	hash->Update(hash->ctx, msg->exchange->cookies,
	    sizeof msg->exchange->cookies);
	hash->Update(hash->ctx, sockaddr_addrdata(sa), sockaddr_addrlen(sa));
	hash->Update(hash->ctx, (unsigned char *)&port, sizeof port);
	hash->Final(res, hash->ctx);
d315 1
a315 2
	/* Remote address first. */
	msg->transport->vtbl->get_dst(msg->transport, &sa);
d319 1
a319 1
	msg->transport->vtbl->get_src(msg->transport, &sa);
@


1.6
log
@Rewrite the transport reference count code to avoid leaks.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.5 2004/07/29 08:54:08 ho Exp $	*/
d433 1
a433 1
	
@


1.5
log
@Repair NAT-T using Aggressive mode, NAT-D checks were in the wrong place.
Noted by Yvan VANHULLEBUS.
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.4 2004/06/30 10:07:13 hshoexer Exp $	*/
d433 5
a438 1
	sa->transport->vtbl->get_src(sa->transport, &src);
d450 3
@


1.4
log
@Compile cleanly with gcc3.3.2.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.3 2004/06/21 23:27:10 ho Exp $	*/
d335 8
d347 1
a347 2
	for (p = payload_first(msg, ISAKMP_PAYLOAD_NAT_D); p;
	     p = TAILQ_NEXT(p, link)) {
d356 1
@


1.3
log
@Implement NAT-T keepalive messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.2 2004/06/20 17:17:35 ho Exp $	*/
d29 1
d129 2
a130 2
		    "MD5(\"%s\") (%d bytes)", isakmp_nat_t_cap_text[i],
		    nat_t_hashsize));
d209 2
a210 1
		    "bad size %d != %d", vlen, nat_t_hashsize));
@


1.2
log
@Make the payload array in struct message dynamic, since we need to handle
payloads in the private range, such as the pre-RFC NAT-D/NAT-OA.
Replace TAILQ_FIRST(&msg->payload[i]) instances with function calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: nat_traversal.c,v 1.1 2004/06/20 15:24:05 ho Exp $	*/
d32 1
d45 1
d48 1
d68 3
d390 46
@


1.1
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp.c,v 1.65 2003/09/26 11:29:11 cedric Exp $	*/
d331 1
a331 1
	for (p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_NAT_D]); p;
@

