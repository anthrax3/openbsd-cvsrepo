head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.18
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.16
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.12
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.8
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.10
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.32
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.30
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.28
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.26
	OPENBSD_5_0:1.35.0.24
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.22
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.20
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.16
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.18
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.14
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.12
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.10
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.8
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.6
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.36
date	2014.01.22.03.09.31;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.21.01.40.23;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.04.10.05.02;	author hshoexer;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.08.19.05.15;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.08.16.06.25;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.08.15.56.48;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.10.15.59.11;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.26.06.07.03;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.15.18.39.30;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.03.14.53.11;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.11.09.50.44;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.26.12.23.46;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.23.19.07.00;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.22.20.59.14;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.22.18.13.36;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.22.13.06.09;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.22.06.58.00;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.06.15.46.16;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.06.09.35.58;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.29.22.01.28;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.29.19.08.12;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.29.18.45.27;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.05.00.51.49;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.24.03.59.58;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.12.01.46.17;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.08.05.22.40.37;	author niklas;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	99.05.01.20.43.40;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.04.05.20.57.35;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.03.24.14.40.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.15.27.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.03.59.18;	author niklas;	state Exp;
branches;
next	;

1.6.6.1
date	2001.05.08.12.45.29;	author ho;	state Exp;
branches;
next	;


desc
@@


1.36
log
@improve randomization.  remove some junk debugging features that are
fundamentally broken.
ok jsing mikeb
@
text
@/* $OpenBSD: sysdep.c,v 1.35 2005/12/21 01:40:23 millert Exp $	 */
/* $EOM: sysdep.c,v 1.9 2000/12/04 04:46:35 angelos Exp $	 */

/*
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "app.h"
#include "log.h"
#include "monitor.h"
#include "util.h"


/* Force communication on socket FD to go in the clear.  */
int
sysdep_cleartext(int fd, int af)
{
	int level, sw;
	struct {
		int             ip_proto;	/* IP protocol */
		int             auth_level;
		int             esp_trans_level;
		int             esp_network_level;
		int             ipcomp_level;
	} optsw[] = {
	    {
		IPPROTO_IP,
		IP_AUTH_LEVEL,
		IP_ESP_TRANS_LEVEL,
		IP_ESP_NETWORK_LEVEL,
#ifdef IP_IPCOMP_LEVEL
		IP_IPCOMP_LEVEL
#else
		0
#endif
	    }, {
		IPPROTO_IPV6,
		IPV6_AUTH_LEVEL,
		IPV6_ESP_TRANS_LEVEL,
		IPV6_ESP_NETWORK_LEVEL,
#ifdef IPV6_IPCOMP_LEVEL
		IPV6_IPCOMP_LEVEL
#else
		0
#endif
	    },
	};

	if (app_none)
		return 0;

	switch (af) {
	case AF_INET:
		sw = 0;
		break;
	case AF_INET6:
		sw = 1;
		break;
	default:
		log_print("sysdep_cleartext: unsupported protocol family %d", af);
		return -1;
	}

	/*
         * Need to bypass system security policy, so I can send and
         * receive key management datagrams in the clear.
         */
	level = IPSEC_LEVEL_BYPASS;
	if (monitor_setsockopt(fd, optsw[sw].ip_proto, optsw[sw].auth_level,
	    (char *) &level, sizeof level) == -1) {
		log_error("sysdep_cleartext: "
		    "setsockopt (%d, %d, IP_AUTH_LEVEL, ...) failed", fd,
		    optsw[sw].ip_proto);
		return -1;
	}
	if (monitor_setsockopt(fd, optsw[sw].ip_proto, optsw[sw].esp_trans_level,
	    (char *) &level, sizeof level) == -1) {
		log_error("sysdep_cleartext: "
		    "setsockopt (%d, %d, IP_ESP_TRANS_LEVEL, ...) failed", fd,
		    optsw[sw].ip_proto);
		return -1;
	}
	if (monitor_setsockopt(fd, optsw[sw].ip_proto, optsw[sw].esp_network_level,
	    (char *) &level, sizeof level) == -1) {
		log_error("sysdep_cleartext: "
		    "setsockopt (%d, %d, IP_ESP_NETWORK_LEVEL, ...) failed", fd,
		    optsw[sw].ip_proto);
		return -1;
	}
	if (optsw[sw].ipcomp_level &&
	    monitor_setsockopt(fd, optsw[sw].ip_proto, optsw[sw].ipcomp_level,
	    (char *) &level, sizeof level) == -1 &&
	    errno != ENOPROTOOPT) {
		log_error("sysdep_cleartext: "
		    "setsockopt (%d, %d, IP_IPCOMP_LEVEL, ...) failed,", fd,
		    optsw[sw].ip_proto);
		return -1;
	}
	return 0;
}
@


1.35
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.34 2005/05/04 10:05:02 hshoexer Exp $	 */
a38 2

#include "sysdep.h"
@


1.34
log
@clean up KEY_API() wrapper.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.33 2005/04/08 23:15:26 hshoexer Exp $	 */
a31 1
#include <sys/errno.h>
d38 1
@


1.33
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.32 2005/04/08 22:32:10 cloder Exp $	 */
d42 2
a46 50
#include "app.h"
#include "conf.h"
#include "ipsec.h"

#include "pf_key_v2.h"
#define KEY_API(x) pf_key_v2_##x

#include "log.h"

/*
 * When select(2) has noticed our application needs attendance, this is what
 * gets called.  FD is the file descriptor causing the alarm.
 */
void
sysdep_app_handler(int fd)
{
	KEY_API(handler)(fd);
}

/* Check that the connection named NAME is active, or else make it active.  */
void
sysdep_connection_check(char *name)
{
	KEY_API(connection_check)(name);
}

/*
 * Generate a SPI for protocol PROTO and the source/destination pair given by
 * SRC, SRCLEN, DST & DSTLEN.  Stash the SPI size in SZ.
 */
u_int8_t *
sysdep_ipsec_get_spi(size_t *sz, u_int8_t proto, struct sockaddr *src,
    struct sockaddr *dst, u_int32_t seq)
{
	if (app_none) {
		*sz = IPSEC_SPI_SIZE;
		/* XXX should be random instead I think.  */
		return (u_int8_t *)strdup("\x12\x34\x56\x78");
	}
	return KEY_API(get_spi)(sz, proto, src, dst, seq);
}

struct sa_kinfo *
sysdep_ipsec_get_kernel_sa(u_int8_t *spi, size_t spi_sz, u_int8_t proto,
    struct sockaddr *dst)
{
	if (app_none)
		return 0;
	return KEY_API(get_kernel_sa)(spi, spi_sz, proto, dst);
}
a133 34
}

int
sysdep_ipsec_delete_spi(struct sa *sa, struct proto *proto, int incoming)
{
	if (app_none)
		return 0;
	return KEY_API(delete_spi)(sa, proto, incoming);
}

int
sysdep_ipsec_enable_sa(struct sa *sa, struct sa *isakmp_sa)
{
	if (app_none)
		return 0;
	return KEY_API(enable_sa)(sa, isakmp_sa);
}

int
sysdep_ipsec_group_spis(struct sa *sa, struct proto *proto1,
    struct proto *proto2, int incoming)
{
	if (app_none)
		return 0;
	return KEY_API(group_spis)(sa, proto1, proto2, incoming);
}

int
sysdep_ipsec_set_spi(struct sa *sa, struct proto *proto, int incoming,
    struct sa *isakmp_sa)
{
	if (app_none)
		return 0;
	return KEY_API(set_spi) (sa,proto, incoming, isakmp_sa);
@


1.32
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.31 2005/04/08 19:05:15 deraadt Exp $	 */
a52 7

/* Return the length of the sockaddr struct.  */
u_int8_t
sysdep_sa_len(struct sockaddr *sa)
{
	return sa->sa_len;
}
@


1.31
log
@remove more conditional crud
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.30 2005/04/08 16:06:25 deraadt Exp $	 */
a52 13

/*
 * An as strong as possible random number generator, reverting to a
 * deterministic pseudo-random one if regrand is set.
 */
u_int32_t
sysdep_random()
{
	if (!regrand)
		return arc4random();
	else
		return random();
}
@


1.30
log
@app.c
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.29 2005/04/08 15:56:48 deraadt Exp $	 */
a44 1
#ifdef NEED_SYSDEP_APP
a48 1
#ifdef USE_PF_KEY_V2
a50 1
#endif
a51 1
#endif /* NEED_SYSDEP_APP */
a73 3
/* As regress/ use this file I protect the sysdep_app_* stuff like this.  */
#ifdef NEED_SYSDEP_APP

a236 1
#endif
@


1.29
log
@sysdep_progname() is non-portable gunk
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.28 2004/08/10 15:59:11 ho Exp $	 */
a57 2
extern char    *__progname;

a79 13
/*
 * Prepare the application we negotiate SAs for (i.e. the IPsec stack)
 * for communication.  We return a file descriptor useable to select(2) on.
 */
int
sysdep_app_open()
{
#ifdef USE_PRIVSEP
	return monitor_pf_key_v2_open();
#else
	return KEY_API(open)();
#endif
}
@


1.28
log
@Better implementation of the Dead Peer Detection protocol, RFC 3706.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.27 2004/06/26 06:07:03 hshoexer Exp $	 */
a70 7
}

/* Return the basename of the command used to invoke us.  */
char *
sysdep_progname()
{
	return __progname;
@


1.27
log
@Narrow down privsep interface.  Move pf_key_v2_open() to monitor.

Work in progress.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.26 2004/04/15 18:39:30 deraadt Exp $	 */
d134 9
@


1.26
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: sysdep.c,v 1.25 2003/06/03 14:53:11 ho Exp $	 */
d96 3
d100 1
@


1.25
log
@Remove clauses 3 and 4. Approved by markus@@ and niklas@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: sysdep.c,v 1.24 2003/05/15 00:28:53 ho Exp $	*/
/*	$EOM: sysdep.c,v 1.9 2000/12/04 04:46:35 angelos Exp $	*/
d58 1
a58 1
extern char *__progname;
d65 1
a65 1
sysdep_random ()
d67 4
a70 4
  if (!regrand)
    return arc4random ();
  else
    return random();
d75 1
a75 1
sysdep_progname ()
d77 1
a77 1
  return __progname;
d82 1
a82 1
sysdep_sa_len (struct sockaddr *sa)
d84 1
a84 1
  return sa->sa_len;
d94 1
a94 1
sysdep_app_open ()
d96 1
a96 1
  return KEY_API(open) ();
d104 1
a104 1
sysdep_app_handler (int fd)
d106 1
a106 1
  KEY_API (handler) (fd);
d111 1
a111 1
sysdep_connection_check (char *name)
d113 1
a113 1
  KEY_API (connection_check) (name);
d121 2
a122 2
sysdep_ipsec_get_spi (size_t *sz, u_int8_t proto, struct sockaddr *src,
		      struct sockaddr *dst, u_int32_t seq)
d124 6
a129 7
  if (app_none)
    {
      *sz = IPSEC_SPI_SIZE;
      /* XXX should be random instead I think.  */
      return (u_int8_t *)strdup ("\x12\x34\x56\x78");
    }
  return KEY_API (get_spi) (sz, proto, src, dst, seq);
d134 1
a134 1
sysdep_cleartext (int fd, int af)
d136 13
a148 14
  int level, sw;
  struct {
    int ip_proto;		/* IP protocol */
    int auth_level;
    int esp_trans_level;
    int esp_network_level;
    int ipcomp_level;
  } optsw[] =
    {
      {
	IPPROTO_IP,
	IP_AUTH_LEVEL,
	IP_ESP_TRANS_LEVEL,
	IP_ESP_NETWORK_LEVEL,
d150 1
a150 1
	IP_IPCOMP_LEVEL
d152 1
a152 1
	0
d154 5
a158 6
      },
      {
	IPPROTO_IPV6,
	IPV6_AUTH_LEVEL,
	IPV6_ESP_TRANS_LEVEL,
	IPV6_ESP_NETWORK_LEVEL,
d160 1
a160 1
	IPV6_IPCOMP_LEVEL
d162 1
a162 1
	0
d164 2
a165 2
      },
    };
d167 2
a168 2
  if (app_none)
    return 0;
d170 82
a251 87
  switch (af)
    {
    case AF_INET:
      sw = 0;
      break;
    case AF_INET6:
      sw = 1;
      break;
    default:
      log_print ("sysdep_cleartext: unsupported protocol family %d", af);
      return -1;
    }

  /*
   * Need to bypass system security policy, so I can send and
   * receive key management datagrams in the clear.
   */
  level = IPSEC_LEVEL_BYPASS;
  if (monitor_setsockopt (fd, optsw[sw].ip_proto, optsw[sw].auth_level,
			  (char *)&level, sizeof level) == -1)
    {
      log_error ("sysdep_cleartext: "
		 "setsockopt (%d, %d, IP_AUTH_LEVEL, ...) failed", fd,
		 optsw[sw].ip_proto);
      return -1;
    }
  if (monitor_setsockopt (fd, optsw[sw].ip_proto, optsw[sw].esp_trans_level,
			  (char *)&level, sizeof level) == -1)
    {
      log_error ("sysdep_cleartext: "
		 "setsockopt (%d, %d, IP_ESP_TRANS_LEVEL, ...) failed", fd,
		 optsw[sw].ip_proto);
      return -1;
    }
  if (monitor_setsockopt (fd, optsw[sw].ip_proto, optsw[sw].esp_network_level,
			  (char *)&level, sizeof level) == -1)
    {
      log_error("sysdep_cleartext: "
		"setsockopt (%d, %d, IP_ESP_NETWORK_LEVEL, ...) failed", fd,
		optsw[sw].ip_proto);
      return -1;
    }
  if (optsw[sw].ipcomp_level
      && monitor_setsockopt (fd, optsw[sw].ip_proto, optsw[sw].ipcomp_level,
			     (char *)&level, sizeof level) == -1
      && errno != ENOPROTOOPT)
    {
      log_error("sysdep_cleartext: "
		"setsockopt (%d, %d, IP_IPCOMP_LEVEL, ...) failed,", fd,
		optsw[sw].ip_proto);
      return -1;
    }
  return 0;
}

int
sysdep_ipsec_delete_spi (struct sa *sa, struct proto *proto, int incoming)
{
  if (app_none)
    return 0;
  return KEY_API (delete_spi) (sa, proto, incoming);
}

int
sysdep_ipsec_enable_sa (struct sa *sa, struct sa *isakmp_sa)
{
  if (app_none)
    return 0;
  return KEY_API (enable_sa) (sa, isakmp_sa);
}

int
sysdep_ipsec_group_spis (struct sa *sa, struct proto *proto1,
			 struct proto *proto2, int incoming)
{
  if (app_none)
    return 0;
  return KEY_API (group_spis) (sa, proto1, proto2, incoming);
}

int
sysdep_ipsec_set_spi (struct sa *sa, struct proto *proto, int incoming,
		      struct sa *isakmp_sa)
{
  if (app_none)
    return 0;
  return KEY_API (set_spi) (sa, proto, incoming, isakmp_sa);
@


1.24
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.23 2002/09/11 09:50:44 ho Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.23
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.22 2002/06/09 08:13:07 todd Exp $	*/
d47 1
d196 2
a197 2
  if (setsockopt (fd, optsw[sw].ip_proto, optsw[sw].auth_level, (char *)&level,
		  sizeof level) == -1)
d204 2
a205 2
  if (setsockopt (fd, optsw[sw].ip_proto, optsw[sw].esp_trans_level,
		  (char *)&level, sizeof level) == -1)
d212 2
a213 2
  if (setsockopt (fd, optsw[sw].ip_proto, optsw[sw].esp_network_level,
		  (char *)&level, sizeof level) == -1)
d221 2
a222 2
      && setsockopt (fd, optsw[sw].ip_proto, optsw[sw].ipcomp_level,
		     (char *)&level, sizeof level) == -1
@


1.22
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.21 2001/10/26 12:23:46 ho Exp $	*/
d132 1
a132 1
      return strdup ("\x12\x34\x56\x78");
@


1.21
log
@Add sysdep_sa_len function.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.20 2001/08/23 19:07:00 niklas Exp $	*/
d142 1
a142 1
  struct { 
d149 1
a149 1
    { 
d173 1
a173 1
  
@


1.20
log
@Compile on old systems, my version.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.19 2001/08/22 20:59:14 ho Exp $	*/
d82 7
@


1.19
log
@Revert last change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.18 2001/08/22 18:13:36 ho Exp $	*/
d143 22
a164 4
      { IPPROTO_IP, IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
	IP_IPCOMP_LEVEL },
      { IPPROTO_IPV6, IPV6_AUTH_LEVEL, IPV6_ESP_TRANS_LEVEL,
	IPV6_ESP_NETWORK_LEVEL, IPV6_IPCOMP_LEVEL },
d212 3
a214 2
  if (setsockopt (fd, optsw[sw].ip_proto, optsw[sw].ipcomp_level,
		  (char *)&level, sizeof level) == -1
@


1.18
log
@Compile on older systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.17 2001/08/22 13:06:09 niklas Exp $	*/
d144 1
a144 4
#ifdef IP_IPCOMP_LEVEL
	IP_IPCOMP_LEVEL,
#endif
      },
d146 1
a146 5
	IPV6_ESP_NETWORK_LEVEL,
#ifdef IPV6_IPCOMP_LEVEL
	IPV6_IPCOMP_LEVEL,
#endif
      },
@


1.17
log
@IPCOMP policy control should be optional for backward
compatibility.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.16 2001/08/22 06:58:00 niklas Exp $	*/
d144 4
a147 1
	IP_IPCOMP_LEVEL },
d149 5
a153 1
	IPV6_ESP_NETWORK_LEVEL, IPV6_IPCOMP_LEVEL },
@


1.16
log
@Bypass IPCOMP too.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.15 2001/08/12 12:03:02 heko Exp $	*/
d37 1
d195 2
a196 1
		  (char *)&level, sizeof level) == -1)
d199 1
a199 1
		"setsockopt (%d, %d, IP_IPCOMP_LEVEL, ...) failed", fd,
@


1.15
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.14 2001/07/06 15:46:16 niklas Exp $	*/
d134 1
a134 2
  struct 
  { 
d139 2
a140 1
  } optsw[] = 
d142 2
a143 1
      { IPPROTO_IP, IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL },
d145 1
a145 1
	IPV6_ESP_NETWORK_LEVEL },
d190 8
@


1.14
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.13 2001/07/06 09:35:58 ho Exp $	*/
d58 1
a58 1
#endif NEED_SYSDEP_APP
@


1.13
log
@Remove support for PF_ENCAP (deprecated since OpenBSD2.5).
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.12 2001/06/29 22:01:28 ho Exp $	*/
d180 2
a181 2
		 "setsockopt (%d, %d, IP_ESP_TRANS_LEVEL, ...) "
		 "failed", fd, optsw[sw].ip_proto);
d188 2
a189 2
		"setsockopt (%d, %d, IP_ESP_NETWORK_LEVEL, ...) "
		 "failed", fd, optsw[sw].ip_proto);
@


1.12
log
@setsockopt flags needs to be IPv6 aware
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.11 2001/06/29 19:08:12 ho Exp $	*/
a55 4
#else
#include <net/encap.h>
#include "pf_encap.h"
#define KEY_API(x) pf_encap_##x
@


1.11
log
@Get rid of redundant lengths in get_spi API.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.10 2001/06/29 18:45:27 ho Exp $	*/
d135 1
a135 1
sysdep_cleartext (int fd)
d137 14
a150 2
  int level;

d154 13
d172 2
a173 2
  if (setsockopt (fd, IPPROTO_IP, IP_AUTH_LEVEL, (char *)&level, sizeof level)
      == -1)
d176 2
a177 1
		 "setsockopt (%d, IPPROTO_IP, IP_AUTH_LEVEL, ...) failed", fd);
d180 2
a181 2
  if (setsockopt (fd, IPPROTO_IP, IP_ESP_TRANS_LEVEL, (char *)&level,
		  sizeof level) == -1)
d184 2
a185 2
		 "setsockopt (%d, IPPROTO_IP, IP_ESP_TRANS_LEVEL, ...) "
		 "failed", fd);
d188 2
a189 2
  if (setsockopt (fd, IPPROTO_IP, IP_ESP_NETWORK_LEVEL, (char *)&level,
		  sizeof level) == -1)
d192 2
a193 2
		"setsockopt (%d, IPPROTO_IP, IP_ESP_NETWORK_LEVEL, ...) "
		 "failed", fd);
@


1.10
log
@More sa_len usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.9 2001/05/05 00:51:49 angelos Exp $	*/
d122 1
a122 2
		      int srclen, struct sockaddr *dst, int dstlen,
                      u_int32_t seq)
d130 1
a130 2
  return KEY_API (get_spi) (sz, proto, src, src->sa_len, dst, dst->sa_len, 
			    seq);
@


1.9
log
@Adhere to the new set_spi prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.8 2001/02/24 03:59:58 angelos Exp $	*/
d131 2
a132 1
  return KEY_API (get_spi) (sz, proto, src, srclen, dst, dstlen, seq);
@


1.8
log
@For the GETSPI PFKEY message, use the sequence number from the ACQUIRE
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.7 2000/12/12 01:46:17 niklas Exp $	*/
d200 2
a201 1
sysdep_ipsec_set_spi (struct sa *sa, struct proto *proto, int incoming)
d205 1
a205 1
  return KEY_API (set_spi) (sa, proto, incoming);
@


1.7
log
@sysdep/openbsd/sysdep.c: Merge with EOM 1.9
pf_encap.h: Merge with EOM 1.13
pf_key_v2.h: Merge with EOM 1.4
sysdep.h: Merge with EOM 1.17

author: angelos
Pass the local/remote Phase 1 ID to the flow, so it can be reused when
an SA is re-negotiated.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysdep.c,v 1.6 1999/08/05 22:40:37 niklas Exp $	*/
d122 2
a123 1
		      int srclen, struct sockaddr *dst, int dstlen)
d131 1
a131 1
  return KEY_API (get_spi) (sz, proto, src, srclen, dst, dstlen);
@


1.6
log
@regress/rsakeygen/Makefile: Merge with EOM 1.5
sysdep/openbsd/sysdep.c: Merge with EOM 1.8
cookie.c: Merge with EOM 1.21
util.c: Merge with EOM 1.15
util.h: Merge with EOM 1.7

author: niklas
Move regrand var to util.c, and get the decl from util.h, do not update the
cookie secret if in deterministic mode.
@
text
@d1 2
a2 2
/*	$OpenBSD: sysdep.c,v 1.5 1999/05/01 20:43:40 niklas Exp $	*/
/*	$EOM: sysdep.c,v 1.8 1999/08/05 15:00:06 niklas Exp $	*/
d182 1
a182 1
sysdep_ipsec_enable_sa (struct sa *sa)
d186 1
a186 1
  return KEY_API (enable_sa) (sa);
@


1.6.6.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: sysdep.c,v 1.8 2001/02/24 03:59:58 angelos Exp $	*/
/*	$EOM: sysdep.c,v 1.9 2000/12/04 04:46:35 angelos Exp $	*/
d122 1
a122 2
		      int srclen, struct sockaddr *dst, int dstlen,
                      u_int32_t seq)
d130 1
a130 1
  return KEY_API (get_spi) (sz, proto, src, srclen, dst, dstlen, seq);
d182 1
a182 1
sysdep_ipsec_enable_sa (struct sa *sa, struct sa *isakmp_sa)
d186 1
a186 1
  return KEY_API (enable_sa) (sa, isakmp_sa);
@


1.5
log
@sysdep/openbsd/sysdep.c: Merge with EOM 1.7
DESIGN-NOTES: Merge with EOM 1.42
Makefile: Merge with EOM 1.51
app.c: Merge with EOM 1.6
conf.c: Merge with EOM 1.18
init.c: Merge with EOM 1.14
isakmpd.conf.5: Merge with EOM 1.19
pf_encap.c: Merge with EOM 1.64
pf_encap.h: Merge with EOM 1.12
pf_key_v2.h: Merge with EOM 1.3
sysdep.h: Merge with EOM 1.16
transport.c: Merge with EOM 1.40
ui.c: Merge with EOM 1.32

author: niklas
A new connection abstraction
@
text
@d1 2
a2 2
/*	$OpenBSD: sysdep.c,v 1.4 1999/04/05 20:57:35 niklas Exp $	*/
/*	$EOM: sysdep.c,v 1.7 1999/05/01 20:21:23 niklas Exp $	*/
d46 2
a65 6

/*
 * This is set to true in case of regression-test mode, when it will
 * cause predictable random numbers be generated.
 */
int regrand = 0;
@


1.4
log
@Merge with EOM 1.6
1999

Mem leak plugging.

Make "Connections" handling nicer, and even implement it for KLIPS.
A stab at reregestering the on-demand routes for PF_ENCAP.
@
text
@d1 2
a2 2
/*	$OpenBSD: sysdep.c,v 1.3 1999/03/24 14:40:46 niklas Exp $	*/
/*	$EOM: sysdep.c,v 1.6 1999/04/05 18:27:42 niklas Exp $	*/
d113 1
a113 4
/*
 * This is where we try to set up routes that make the IP-stack request
 * SAs from us on demand. 
 */
d115 1
a115 1
sysdep_conf_init_hook ()
d117 1
a117 15
  struct conf_list *conns;
  struct conf_list_node *conn;

  conns = conf_get_list ("Phase 2", "Connections");
  if (conns)
    {
      for (conn = TAILQ_FIRST (&conns->fields); conn;
	   conn = TAILQ_NEXT (conn, link))
	{
	  if (KEY_API(connection) (conn->field))
	    /* XXX What else?  */
	    continue;
	}
      conf_free_list (conns);
    }
@


1.3
log
@Merge with EOM 1.3
New sysdep API

Include the right things
@
text
@d1 2
a2 2
/*	$OpenBSD: sysdep.c,v 1.2 1999/03/02 15:27:36 niklas Exp $	*/
/*	$EOM: sysdep.c,v 1.3 1999/03/24 11:06:26 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
a121 3
  char *conf, *doi_str, *local_id, *remote_id, *peer, *address;
  struct in_addr laddr, lmask, raddr, rmask, gwaddr;
  int lid, rid;
d124 1
a124 2
  for (conn = TAILQ_FIRST (&conns->fields); conn;
       conn = TAILQ_NEXT (conn, link))
d126 2
a127 3
      /* Figure out the DOI.  We only handle IPsec so far.  */
      conf = conf_get_str (conn->field, "Configuration");
      if (!conf)
d129 3
a131 4
	  log_print ("sysdep_conf_init_hook: "
		     "No \"Configuration\" specified for %s",
		     conn->field);
	  continue;
d133 1
a133 57
      doi_str = conf_get_str (conf, "DOI");
      if (!doi_str)
	{
	  log_print ("sysdep_conf_init_hook: No DOI specified for %s", conf);
	  continue;
	}
      if (strcasecmp (doi_str, "IPSEC") != 0)
	{
	  log_print ("sysdep_conf_init_hook: DOI \"%s\" unsupported", doi_str);
	  continue;
	}

      local_id = conf_get_str (conn->field, "Local-ID");
      remote_id = conf_get_str (conn->field, "Remote-ID");

      /*
       * At the moment I only do on-demand keying for modes with client IDs.
       */
      if (!local_id || !remote_id)
	{
	  log_print ("sysdep_conf_init_hook: "
		     "Both Local-ID and Remote-ID required for %s",
		     conn->field);
	  continue;
	}

      if (ipsec_get_id (local_id, &lid, &laddr, &lmask))
	continue;
      if (ipsec_get_id (remote_id, &rid, &raddr, &rmask))
	continue;

      peer = conf_get_str (conn->field, "ISAKMP-peer");
      if (!peer)
	{
	  log_print ("sysdep_conf_init_hook: "
		     "section %s has no \"ISAKMP-peer\" tag", conn->field);
	  continue;
	}
      address = conf_get_str (peer, "Address");
      if (!address)
	{
	  log_print ("sysdep_conf_init_hook: "
		     "section %s has no \"Address\" tag", peer);
	  continue;
	}
      if (!inet_aton (address, &gwaddr))
	{
	  log_print ("sysdep_conf_init_hook: invalid adress %s in section %s",
		     address, peer);
	  continue;
	}

      /* XXX The special SPI below needs to be symbolic.  */
      if (KEY_API(route) (laddr.s_addr, lmask.s_addr, raddr.s_addr,
			  rmask.s_addr, 1, gwaddr.s_addr, conn->field))
	/* XXX What else?  */
	continue;
@


1.2
log
@RCS tags
@
text
@d1 2
a2 2
/*	$OpenBSD: sysdep.c,v 1.1 1999/02/26 03:59:18 niklas Exp $	*/
/*	$EOM: sysdep.c,v 1.1 1999/02/25 14:18:42 niklas Exp $	*/
a39 1
#include <net/encap.h>
a49 2
#endif NEED_SYSDEP_APP
#include "log.h"
d55 1
d60 3
d200 2
a201 2
 * Generate a SPI for protocol PROTO and the destination signified by
 * ID & ID_SZ.  Stash the SPI size in SZ.
d204 2
a205 1
sysdep_ipsec_get_spi (size_t *sz, u_int8_t proto, void *id, size_t id_sz)
d213 1
a213 1
  return KEY_API (get_spi) (sz, proto, id, id_sz);
d257 1
a257 1
sysdep_ipsec_delete_spi (struct sa *sa, struct proto *proto, int initiator)
d261 1
a261 1
  return KEY_API (delete_spi) (sa, proto, initiator);
d265 1
a265 1
sysdep_ipsec_enable_sa (struct sa *sa, int initiator)
d269 1
a269 1
  return KEY_API (enable_sa) (sa, initiator);
d274 1
a274 1
		      struct proto *proto2, int role)
d278 1
a278 1
  return KEY_API (group_spis) (sa, proto1, proto2, role);
d282 1
a282 2
sysdep_ipsec_set_spi (struct sa *sa, struct proto *proto, int role,
		      int initiator)
d286 1
a286 1
  return KEY_API (set_spi) (sa, proto, role, initiator);
@


1.1
log
@Merge from the Ericsson repository
| revision 1.1
| date: 1999/02/25 14:18:42;  author: niklas;  state: Exp;
| Better OS-dependency layout
| =============================================================================
@
text
@d1 2
a2 1
/*	$Id: sysdep.c,v 1.1 1999/02/25 14:18:42 niklas Exp $	*/
@

