head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.26
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.22
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.24
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.16
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.20
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.18
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.14
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.18
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.20
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.16
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.14
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.12
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.14
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2010.06.29.19.50.16;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.08.16.37.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.29.08.54.08;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.23.18.17.55;	author hshoexer;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.04.07.31.16;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.01.02.46.18;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.08.26.22.28.54;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.04.27.21.11.53;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.04.19.19.59.53;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Replace the hand-crafted Diffie-Hellman implementation in isakmpd with
the smaller implementation from iked that is using libcrypto instead.
This allows to remove a lot of code (which is always good), get rid of
some custom crypto code by using libcrypto, theoretically adds
support for many new MODP and EC2N/ECP modes (but it is not configurable
yet), and allows to share the dh.c/dh.h code in different codebases
(it is identical in isakmpd and iked, but could also be used elsewhere).

ok deraadt@@
@
text
@/* $OpenBSD: ike_aggressive.c,v 1.10 2005/04/08 22:32:10 cloder Exp $	 */
/* $EOM: ike_aggressive.c,v 1.4 2000/01/31 22:33:45 niklas Exp $	 */

/*
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999 Angelos D. Keromytis.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <string.h>

#include "attribute.h"
#include "conf.h"
#include "constants.h"
#include "crypto.h"
#include "dh.h"
#include "doi.h"
#include "exchange.h"
#include "hash.h"
#include "ike_auth.h"
#include "ike_aggressive.h"
#include "ike_phase_1.h"
#include "ipsec.h"
#include "ipsec_doi.h"
#include "isakmp.h"
#include "log.h"
#include "message.h"
#include "nat_traversal.h"
#include "prf.h"
#include "sa.h"
#include "transport.h"
#include "util.h"

static int	initiator_recv_SA_KE_NONCE_ID_AUTH(struct message *);
static int	initiator_send_SA_KE_NONCE_ID(struct message *);
static int	initiator_send_AUTH(struct message *);
static int	responder_recv_SA_KE_NONCE_ID(struct message *);
static int	responder_send_SA_KE_NONCE_ID_AUTH(struct message *);
static int	responder_recv_AUTH(struct message *);

int (*ike_aggressive_initiator[])(struct message *) = {
	initiator_send_SA_KE_NONCE_ID,
	initiator_recv_SA_KE_NONCE_ID_AUTH,
	initiator_send_AUTH
};

int (*ike_aggressive_responder[])(struct message *) = {
	responder_recv_SA_KE_NONCE_ID,
	responder_send_SA_KE_NONCE_ID_AUTH,
	responder_recv_AUTH
};

/* Offer a set of transforms to the responder in the MSG message.  */
static int
initiator_send_SA_KE_NONCE_ID(struct message *msg)
{
	if (ike_phase_1_initiator_send_SA(msg))
		return -1;

	if (ike_phase_1_initiator_send_KE_NONCE(msg))
		return -1;

	return ike_phase_1_send_ID(msg);
}

/* Figure out what transform the responder chose.  */
static int
initiator_recv_SA_KE_NONCE_ID_AUTH(struct message *msg)
{
	if (ike_phase_1_initiator_recv_SA(msg))
		return -1;

	if (ike_phase_1_initiator_recv_KE_NONCE(msg))
		return -1;

	return ike_phase_1_recv_ID_AUTH(msg);
}

static int
initiator_send_AUTH(struct message *msg)
{
	msg->exchange->flags |= EXCHANGE_FLAG_ENCRYPT;

	if (ike_phase_1_send_AUTH(msg))
		return -1;

	/*
	 * RFC 2407 4.6.3 says that, among others, INITIAL-CONTACT MUST NOT
	 * be sent in Aggressive Mode.  This leaves us with the choice of
	 * doing it in an informational exchange of its own with no delivery
	 * guarantee or in the first Quick Mode, or not at all.
	 * draft-jenkins-ipsec-rekeying-01.txt has some text that requires
	 * INITIAL-CONTACT in phase 1, thus contradicting what we learned
	 * above.  I will bring this up in the IPsec list.  For now we don't
	 * do INITIAL-CONTACT at all when using aggressive mode.
         */
	return 0;
}

/*
 * Accept a set of transforms offered by the initiator and chose one we can
 * handle.  Also accept initiator's public DH value, nonce and ID.
 */
static int
responder_recv_SA_KE_NONCE_ID(struct message *msg)
{
	if (ike_phase_1_responder_recv_SA(msg))
		return -1;

	if (ike_phase_1_recv_ID(msg))
		return -1;

	return ike_phase_1_recv_KE_NONCE(msg);
}

/*
 * Reply with the transform we chose.  Send our public DH value and a nonce
 * to the initiator.
 */
static int
responder_send_SA_KE_NONCE_ID_AUTH(struct message *msg)
{
	/* Add the SA payload with the transform that was chosen.  */
	if (ike_phase_1_responder_send_SA(msg))
		return -1;

	/* XXX Should we really just use the initiator's nonce size?  */
	if (ike_phase_1_send_KE_NONCE(msg, msg->exchange->nonce_i_len))
		return -1;

	if (ike_phase_1_post_exchange_KE_NONCE(msg))
		return -1;

	return ike_phase_1_responder_send_ID_AUTH(msg);
}

/*
 * Reply with the transform we chose.  Send our public DH value and a nonce
 * to the initiator.
 */
static int
responder_recv_AUTH(struct message *msg)
{
	if (ike_phase_1_recv_AUTH(msg))
		return -1;

	/* Aggressive: Check for NAT-D payloads and contents.  */
	if (msg->exchange->flags & EXCHANGE_FLAG_NAT_T_CAP_PEER)
		(void)nat_t_exchange_check_nat_d(msg);
	return 0;
}
@


1.10
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_aggressive.c,v 1.9 2005/04/08 16:37:14 deraadt Exp $	 */
a52 1
#include "math_group.h"
@


1.9
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: ike_aggressive.c,v 1.8 2004/07/29 08:54:08 ho Exp $	 */
a36 2

#include "sysdep.h"
@


1.8
log
@Repair NAT-T using Aggressive mode, NAT-D checks were in the wrong place.
Noted by Yvan VANHULLEBUS.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_aggressive.c,v 1.7 2004/05/23 18:17:55 hshoexer Exp $	 */
a56 1
#if defined (USE_NAT_TRAVERSAL)
a57 1
#endif
a175 1
#if defined (USE_NAT_TRAVERSAL)
a178 1
#endif
@


1.7
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_aggressive.c,v 1.6 2004/04/15 18:39:25 deraadt Exp $	 */
d57 3
d65 6
a70 5
static int      initiator_recv_SA_KE_NONCE_ID_AUTH(struct message *);
static int      initiator_send_SA_KE_NONCE_ID(struct message *);
static int      initiator_send_AUTH(struct message *);
static int      responder_recv_SA_KE_NONCE_ID(struct message *);
static int      responder_send_SA_KE_NONCE_ID_AUTH(struct message *);
d81 1
a81 1
	ike_phase_1_recv_AUTH
d166 18
a183 1
	return -1;
@


1.6
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_aggressive.c,v 1.5 2003/06/04 07:31:16 ho Exp $	 */
d68 1
a68 1
int             (*ike_aggressive_initiator[]) (struct message *) = {
d74 1
a74 1
int             (*ike_aggressive_responder[]) (struct message *) = {
d82 1
a82 1
initiator_send_SA_KE_NONCE_ID(struct message * msg)
d95 1
a95 1
initiator_recv_SA_KE_NONCE_ID_AUTH(struct message * msg)
d107 1
a107 1
initiator_send_AUTH(struct message * msg)
d132 1
a132 1
responder_recv_SA_KE_NONCE_ID(struct message * msg)
d148 1
a148 1
responder_send_SA_KE_NONCE_ID_AUTH(struct message * msg)
@


1.5
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_aggressive.c,v 1.4 2000/02/01 02:46:18 niklas Exp $	*/
/*	$EOM: ike_aggressive.c,v 1.4 2000/01/31 22:33:45 niklas Exp $	*/
d62 10
a71 10
static int initiator_recv_SA_KE_NONCE_ID_AUTH (struct message *);
static int initiator_send_SA_KE_NONCE_ID (struct message *);
static int initiator_send_AUTH (struct message *);
static int responder_recv_SA_KE_NONCE_ID (struct message *);
static int responder_send_SA_KE_NONCE_ID_AUTH (struct message *);

int (*ike_aggressive_initiator[]) (struct message *) = {
  initiator_send_SA_KE_NONCE_ID,
  initiator_recv_SA_KE_NONCE_ID_AUTH,
  initiator_send_AUTH
d74 4
a77 4
int (*ike_aggressive_responder[]) (struct message *) = {
  responder_recv_SA_KE_NONCE_ID,
  responder_send_SA_KE_NONCE_ID_AUTH,
  ike_phase_1_recv_AUTH
d82 1
a82 1
initiator_send_SA_KE_NONCE_ID (struct message *msg)
d84 2
a85 2
  if (ike_phase_1_initiator_send_SA (msg))
    return -1;
d87 2
a88 2
  if (ike_phase_1_initiator_send_KE_NONCE (msg))
    return -1;
d90 1
a90 1
  return ike_phase_1_send_ID (msg);
d95 1
a95 1
initiator_recv_SA_KE_NONCE_ID_AUTH (struct message *msg)
d97 2
a98 2
  if (ike_phase_1_initiator_recv_SA (msg))
    return -1;
d100 2
a101 2
  if (ike_phase_1_initiator_recv_KE_NONCE (msg))
    return -1;
d103 1
a103 1
  return ike_phase_1_recv_ID_AUTH (msg);
d107 1
a107 1
initiator_send_AUTH (struct message *msg)
d109 1
a109 1
  msg->exchange->flags |= EXCHANGE_FLAG_ENCRYPT;
d111 2
a112 2
  if (ike_phase_1_send_AUTH (msg))
    return -1;
d114 11
a124 11
  /*
   * RFC 2407 4.6.3 says that, among others, INITIAL-CONTACT MUST NOT
   * be sent in Aggressive Mode.  This leaves us with the choice of
   * doing it in an informational exchange of its own with no delivery
   * guarantee or in the first Quick Mode, or not at all.
   * draft-jenkins-ipsec-rekeying-01.txt has some text that requires
   * INITIAL-CONTACT in phase 1, thus contradicting what we learned
   * above.  I will bring this up in the IPsec list.  For now we don't
   * do INITIAL-CONTACT at all when using aggressive mode.
   */
  return 0;
d132 1
a132 1
responder_recv_SA_KE_NONCE_ID (struct message *msg)
d134 2
a135 2
  if (ike_phase_1_responder_recv_SA (msg))
    return -1;
d137 2
a138 2
  if (ike_phase_1_recv_ID (msg))
    return -1;
d140 1
a140 1
  return ike_phase_1_recv_KE_NONCE (msg);
d148 1
a148 1
responder_send_SA_KE_NONCE_ID_AUTH (struct message *msg)
d150 7
a156 7
  /* Add the SA payload with the transform that was chosen.  */
  if (ike_phase_1_responder_send_SA (msg))
   return -1;

  /* XXX Should we really just use the initiator's nonce size?  */
  if (ike_phase_1_send_KE_NONCE (msg, msg->exchange->nonce_i_len))
    return -1;
d158 2
a159 2
  if (ike_phase_1_post_exchange_KE_NONCE (msg))
    return -1;
d161 2
a162 2
  return ike_phase_1_responder_send_ID_AUTH (msg);
    return -1;
@


1.4
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_aggressive.c,v 1.3 1999/08/26 22:28:54 niklas Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.3
log
@Merge with EOM 1.3

author: angelos
Revert order of handling KE/NONCE and IDs, such that we can use the ID
to lookup for the shared secret...
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_aggressive.c,v 1.2 1999/04/27 21:11:53 niklas Exp $	*/
/*	$EOM: ike_aggressive.c,v 1.3 1999/08/19 01:14:04 angelos Exp $	*/
d6 1
@


1.2
log
@ike_aggressive.c: Merge with EOM 1.2
ike_main_mode.c: Merge with EOM 1.77
ipsec.h: Merge with EOM 1.35

author: niklas
Send out INITIAL-CONTACT notifications
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_aggressive.c,v 1.1 1999/04/19 19:59:53 niklas Exp $	*/
/*	$EOM: ike_aggressive.c,v 1.2 1999/04/25 22:12:33 niklas Exp $	*/
d141 1
a141 1
  if (ike_phase_1_recv_KE_NONCE (msg))
d144 1
a144 1
  return ike_phase_1_recv_ID (msg);
@


1.1
log
@./ike_aggressive.c: Merge with EOM 1.1
./ike_phase_1.h: Merge with EOM 1.1
./ike_aggressive.h: Merge with EOM 1.1

Let's get aggressive!
@
text
@d1 2
a2 1
/*	$Id: ike_aggressive.c,v 1.1 1999/04/16 21:24:43 niklas Exp $	*/
d115 14
a128 1
  return ike_phase_1_send_AUTH (msg);
@

