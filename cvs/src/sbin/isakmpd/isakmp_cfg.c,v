head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.12
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.8
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.10
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.26
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.24
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.22
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.20
	OPENBSD_5_0:1.38.0.18
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.16
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.14
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.10
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.12
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.8
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.6
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.4
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.37.0.8
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.6
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.4
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.34.0.4
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.39
date	2014.01.23.01.04.28;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.20.17.17.35;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.15.15.53.13;	author hshoexer;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.11.16.56.11;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.04.21.13.35;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.09.12.46.45;	author ho;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.08.23.18.01.33;	author ho;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2002.07.16.11.15.53;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.09.04.25.31;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.09.01.23.55;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.09.01.15.20;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.00.48.53;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.00.44.55;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.08.23.16.49;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.08.17.35.06;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.07.21.59.22;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.07.20.26.22;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.19.53.19;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.06.19.03.10;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.26.12.03.07;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.27.03.10.55;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.23.19.44.28;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.25.15.18.14;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.04.07.41.19;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.04.07.29.10;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.01.20.43.39;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2003.03.20.19.39.44;	author margarida;	state Exp;
branches;
next	;

1.23.2.1
date	2004.03.17.15.05.03;	author brad;	state Exp;
branches;
next	;

1.25.2.1
date	2004.03.17.14.59.17;	author brad;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Remove a mid-layer which acts like arc4random isn't fairly standard.
ok mikeb
@
text
@/* $OpenBSD: isakmp_cfg.c,v 1.38 2007/04/16 13:01:39 moritz Exp $	 */

/*
 * Copyright (c) 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2002 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Gatespace
 * (http://www.gatespace.com/).
 */

#include <sys/types.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <bitstring.h>

#include "attribute.h"
#include "conf.h"
#include "exchange.h"
#include "hash.h"
#include "ipsec.h"
#include "isakmp_fld.h"
#include "isakmp_num.h"
#include "log.h"
#include "message.h"
#include "prf.h"
#include "sa.h"
#include "transport.h"
#include "util.h"

/*
 * Validation script used to test messages for correct content of
 * payloads depending on the exchange type.
 */
int16_t script_transaction[] = {
	ISAKMP_PAYLOAD_ATTRIBUTE,	/* Initiator -> responder.  */
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_ATTRIBUTE,	/* Responder -> initiator.  */
	EXCHANGE_SCRIPT_END
};

static int      cfg_decode_attribute(u_int16_t, u_int8_t *, u_int16_t, void *);
static int	cfg_encode_attributes(struct isakmp_cfg_attr_head *, u_int32_t,
    u_int32_t, char *, u_int8_t **, u_int16_t *);
static int      cfg_initiator_send_ATTR(struct message *);
static int      cfg_initiator_recv_ATTR(struct message *);
static int      cfg_responder_recv_ATTR(struct message *);
static int      cfg_responder_send_ATTR(struct message *);

u_int8_t       *cfg_add_hash(struct message *);
int		cfg_finalize_hash(struct message *, u_int8_t *, u_int8_t *,
    u_int16_t);
int             cfg_verify_hash(struct message *);

/* Server: SET/ACK    Client; REQ/REPLY */
int (*isakmp_cfg_initiator[]) (struct message *) = {
	cfg_initiator_send_ATTR,
	cfg_initiator_recv_ATTR
};

/* Server: REQ/REPLY  Client: SET/ACK */
int (*isakmp_cfg_responder[]) (struct message *) = {
	cfg_responder_recv_ATTR,
	cfg_responder_send_ATTR
};

/*
 * When we are "the server", this starts SET/ACK mode
 * When we are "the client", this starts REQ/REPLY mode
 */
static int
cfg_initiator_send_ATTR(struct message *msg)
{
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_exch *ie = msg->exchange->data;
	u_int8_t       *hashp = 0, *attrp, *attr;
	size_t          attrlen, off;
	char           *id_string, *cfg_mode, *field;
	struct sockaddr *sa;
#define CFG_ATTR_BIT_MAX ISAKMP_CFG_ATTR_FUTURE_MIN	/* XXX */
	bitstr_t        bit_decl(attrbits, CFG_ATTR_BIT_MAX);
	u_int16_t       bit, length;
	u_int32_t       life;

	if (msg->exchange->phase == 2) {
		hashp = cfg_add_hash(msg);
		if (!hashp)
			return -1;
	}
	/* We initiated this exchange, check isakmp_sa for other side.  */
	if (isakmp_sa->initiator)
		id_string = ipsec_id_string(isakmp_sa->id_r,
		    isakmp_sa->id_r_len);
	else
		id_string = ipsec_id_string(isakmp_sa->id_i,
		    isakmp_sa->id_i_len);
	if (!id_string) {
		log_print("cfg_initiator_send_ATTR: cannot parse ID");
		goto fail;
	}
	/* Check for attribute list to send to the other side */
	attrlen = 0;
	bit_nclear(attrbits, 0, CFG_ATTR_BIT_MAX - 1);

	cfg_mode = conf_get_str(id_string, "Mode");
	if (!cfg_mode || strcmp(cfg_mode, "SET") == 0) {
		/* SET/ACK mode */
		ie->cfg_type = ISAKMP_CFG_SET;

		LOG_DBG((LOG_NEGOTIATION, 10,
		    "cfg_initiator_send_ATTR: SET/ACK mode"));

#define ATTRFIND(STR,ATTR4,LEN4,ATTR6,LEN6) do				\
	{								\
		if ((sa = conf_get_address (id_string, STR)) != NULL)	\
			switch (sa->sa_family) {			\
			case AF_INET:					\
				bit_set (attrbits, ATTR4);		\
				attrlen += ISAKMP_ATTR_SZ + LEN4;	\
				break;					\
			case AF_INET6:					\
				bit_set (attrbits, ATTR6);		\
				attrlen += ISAKMP_ATTR_SZ + LEN6;	\
				break;					\
			default:					\
				break;					\
			}						\
		free (sa);						\
	} while (0)

		/*
		 * XXX We don't simultaneously support IPv4 and IPv6
		 * addresses.
		 */
		ATTRFIND("Address", ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS, 4,
		    ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS, 16);
		ATTRFIND("Netmask", ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK, 4,
		    ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK, 16);
		ATTRFIND("Nameserver", ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS, 4,
		    ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS, 16);
		ATTRFIND("WINS-server", ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS, 4,
		    ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS, 16);
		ATTRFIND("DHCP-server", ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP, 4,
		    ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP, 16);
#ifdef notyet
		ATTRFIND("Network", ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET, 8,
		    ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET, 17);
#endif
#undef ATTRFIND

		if (conf_get_str(id_string, "Lifetime")) {
			bit_set(attrbits,
			    ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY);
			attrlen += ISAKMP_ATTR_SZ + 4;
		}
	} else {
		struct conf_list *alist;
		struct conf_list_node *anode;

		ie->cfg_type = ISAKMP_CFG_REQUEST;

		LOG_DBG((LOG_NEGOTIATION, 10,
		    "cfg_initiator_send_ATTR: REQ/REPLY mode"));

		alist = conf_get_list(id_string, "Attributes");
		if (alist) {
			for (anode = TAILQ_FIRST(&alist->fields); anode;
			    anode = TAILQ_NEXT(anode, link)) {
				if (strcasecmp(anode->field, "Address") == 0) {
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS);
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS);
					attrlen += ISAKMP_ATTR_SZ * 2;
				} else if (strcasecmp(anode->field, "Netmask")
				    == 0) {
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK);
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK);
					attrlen += ISAKMP_ATTR_SZ * 2;
				} else if (strcasecmp(anode->field,
				    "Nameserver") == 0) {
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS);
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS);
					attrlen += ISAKMP_ATTR_SZ * 2;
				} else if (strcasecmp(anode->field,
				    "WINS-server") == 0) {
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS);
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS);
					attrlen += ISAKMP_ATTR_SZ * 2;
				} else if (strcasecmp(anode->field,
				    "DHCP-server") == 0) {
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP);
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP);
					attrlen += ISAKMP_ATTR_SZ * 2;
				} else if (strcasecmp(anode->field,
				    "Lifetime") == 0) {
					bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY);
					attrlen += ISAKMP_ATTR_SZ;
				} else {
					log_print("cfg_initiator_send_ATTR: "
					    "unknown attribute %.20s in "
					    "section [%s]", anode->field,
					    id_string);
				}
			}

			conf_free_list(alist);
		}
	}

	if (attrlen == 0) {
		/* No data found.  */
		log_print("cfg_initiator_send_ATTR: no IKECFG attributes "
		    "found for [%s]", id_string);

		/*
		 * We can continue, but this indicates a configuration error
		 * that the user probably will want to correct.
		 */
		free(id_string);
		return 0;
	}
	attrlen += ISAKMP_ATTRIBUTE_SZ;
	attrp = calloc(1, attrlen);
	if (!attrp) {
		log_error("cfg_initiator_send_ATTR: calloc (1, %lu) failed",
		    (unsigned long)attrlen);
		goto fail;
	}
	if (message_add_payload(msg, ISAKMP_PAYLOAD_ATTRIBUTE, attrp, attrlen,
	    1)) {
		free(attrp);
		goto fail;
	}
	SET_ISAKMP_ATTRIBUTE_TYPE(attrp, ie->cfg_type);
	arc4random_buf((u_int8_t *) & ie->cfg_id, sizeof ie->cfg_id);
	SET_ISAKMP_ATTRIBUTE_ID(attrp, ie->cfg_id);

	off = ISAKMP_ATTRIBUTE_SZ;

	/*
	 * Use the bitstring built previously to collect the right
	 * parameters for attrp.
         */
	for (bit = 0; bit < CFG_ATTR_BIT_MAX; bit++)
		if (bit_test(attrbits, bit)) {
			attr = attrp + off;
			SET_ISAKMP_ATTR_TYPE(attr, bit);

			if (ie->cfg_type == ISAKMP_CFG_REQUEST) {
				off += ISAKMP_ATTR_SZ;
				continue;
			}
			/* All the other are similar, this is the odd one.  */
			if (bit == ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY) {
				life = conf_get_num(id_string, "Lifetime",
				    1200);
				SET_ISAKMP_ATTR_LENGTH_VALUE(attr, 4);
				encode_32(attr + ISAKMP_ATTR_VALUE_OFF, life);
				off += ISAKMP_ATTR_SZ + 4;
				continue;
			}
			switch (bit) {
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
				length = 4;
				break;

			case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
				length = 16;
				break;

			default:
				length = 0;	/* Silence gcc.  */
			}

			switch (bit) {
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
				field = "Address";
				break;
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
				field = "Netmask";
				break;
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
				field = "Nameserver";
				break;
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
				field = "DHCP-server";
				break;
			case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
			case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
				field = "WINS-server";
				break;
			default:
				field = 0;	/* Silence gcc.  */
			}

			sa = conf_get_address(id_string, field);

			SET_ISAKMP_ATTR_LENGTH_VALUE(attr, length);
			memcpy(attr + ISAKMP_ATTR_VALUE_OFF,
			    sockaddr_addrdata(sa), length);

			free(sa);

			off += ISAKMP_ATTR_SZ + length;
		}
	if (msg->exchange->phase == 2)
		if (cfg_finalize_hash(msg, hashp, attrp, attrlen))
			goto fail;

	return 0;

fail:
	free(id_string);
	return -1;
}

/*
 * As "the server", this ends SET/ACK.
 * As "the client", this ends REQ/REPLY.
 */
static int
cfg_initiator_recv_ATTR(struct message *msg)
{
	struct payload *attrp = payload_first(msg, ISAKMP_PAYLOAD_ATTRIBUTE);
	struct ipsec_exch *ie = msg->exchange->data;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct isakmp_cfg_attr *attr;
	struct sockaddr *sa;
	const char     *uk_addr = "<unknown>";
	char           *addr;

	if (msg->exchange->phase == 2)
		if (cfg_verify_hash(msg))
			return -1;

	/* Sanity.  */
	if (ie->cfg_id != GET_ISAKMP_ATTRIBUTE_ID(attrp->p)) {
		log_print("cfg_initiator_recv_ATTR: "
		    "cfg packet ID does not match!");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		return -1;
	}
	switch (attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF]) {
	case ISAKMP_CFG_ACK:
		if (ie->cfg_type != ISAKMP_CFG_SET) {
			log_print("cfg_initiator_recv_ATTR: "
			    "bad packet type ACK");
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED,
			    0, 1, 0);
			return -1;
		}
		break;
	case ISAKMP_CFG_REPLY:
		if (ie->cfg_type != ISAKMP_CFG_REQUEST) {
			log_print("cfg_initiator_recv_ATTR: "
			    "bad packet type REPLY");
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED,
			    0, 1, 0);
			return -1;
		}
		break;

	default:
		log_print("cfg_initiator_recv_ATTR: unexpected configuration "
		    "message type %d", attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF]);
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		return -1;
	}

	attribute_map(attrp->p + ISAKMP_ATTRIBUTE_ATTRS_OFF,
	    GET_ISAKMP_GEN_LENGTH(attrp->p) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    cfg_decode_attribute, ie);

	switch (ie->cfg_type) {
	case ISAKMP_CFG_ACK: {
			/* SET/ACK -- Server side (ACK from client) */
			msg->transport->vtbl->get_src(isakmp_sa->transport,
			    &sa);
			if (sockaddr2text(sa, &addr, 0) < 0)
				addr = (char *) uk_addr;

			for (attr = LIST_FIRST(&ie->attrs); attr;
			    attr = LIST_NEXT(attr, link))
				LOG_DBG((LOG_NEGOTIATION, 50,
				    "cfg_initiator_recv_ATTR: "
				    "client %s ACKs attribute %s", addr,
				    constant_name(isakmp_cfg_attr_cst,
					attr->type)));

			if (addr != uk_addr)
				free(addr);
		}
		break;

	case ISAKMP_CFG_REPLY: {
			/*
			 * REQ/REPLY: effect attributes we've gotten
			 * responses on.
			 */
			msg->transport->vtbl->get_src(isakmp_sa->transport,
			    &sa);
			if (sockaddr2text(sa, &addr, 0) < 0)
				addr = (char *) uk_addr;

			for (attr = LIST_FIRST(&ie->attrs); attr;
			    attr = LIST_NEXT(attr, link))
				LOG_DBG((LOG_NEGOTIATION, 50,
				    "cfg_initiator_recv_ATTR: "
				    "server %s replied with attribute %s",
				    addr, constant_name(isakmp_cfg_attr_cst,
					attr->type)));

			if (addr != uk_addr)
				free(addr);
		}
		break;

	default:
		break;
	}

	attrp->flags |= PL_MARK;
	return 0;
}

/*
 * As "the server", this starts REQ/REPLY (initiated by the client).
 * As "the client", this starts SET/ACK (initiated by the server).
 */
static int
cfg_responder_recv_ATTR(struct message *msg)
{
	struct payload *attrp = payload_first(msg, ISAKMP_PAYLOAD_ATTRIBUTE);
	struct ipsec_exch *ie = msg->exchange->data;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct isakmp_cfg_attr *attr;
	struct sockaddr *sa;
	char           *addr;

	if (msg->exchange->phase == 2)
		if (cfg_verify_hash(msg))
			return -1;

	ie->cfg_id = GET_ISAKMP_ATTRIBUTE_ID(attrp->p);
	ie->cfg_type = attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF];

	switch (ie->cfg_type) {
	case ISAKMP_CFG_REQUEST:
	case ISAKMP_CFG_SET:
		break;

	default:
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		log_print("cfg_responder_recv_ATTR: "
		    "unexpected configuration message type %d", ie->cfg_type);
		return -1;
	}

	attribute_map(attrp->p + ISAKMP_ATTRIBUTE_ATTRS_OFF,
	    GET_ISAKMP_GEN_LENGTH(attrp->p) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    cfg_decode_attribute, ie);

	switch (ie->cfg_type) {
	case ISAKMP_CFG_REQUEST:
		/* We're done.  */
		break;

	case ISAKMP_CFG_SET: {
			/* SET/ACK -- Client side (SET from server) */
			const char     *uk_addr = "<unknown>";

			msg->transport->vtbl->get_dst(isakmp_sa->transport,
			    &sa);
			if (sockaddr2text(sa, &addr, 0) < 0)
				addr = (char *) uk_addr;

			for (attr = LIST_FIRST(&ie->attrs); attr;
			    attr = LIST_NEXT(attr, link))
				LOG_DBG((LOG_NEGOTIATION, 50,
				    "cfg_responder_recv_ATTR: "
				    "server %s asks us to SET attribute %s",
				    addr, constant_name(isakmp_cfg_attr_cst,
					attr->type)));

			/*
			 * XXX Here's the place to add code to walk through
			 * XXX each attribute and send them along to dhclient
			 * XXX or whatever. Each attribute that we act upon
			 * XXX (such as setting a netmask), should be marked
			 * XXX like this for us to send the proper ACK
			 * XXX response: attr->attr_used++;
			 */

			if (addr != uk_addr)
				free(addr);
		}
		break;

	default:
		break;
	}

	attrp->flags |= PL_MARK;
	return 0;
}

/*
 * As "the server", this ends REQ/REPLY mode.
 * As "the client", this ends SET/ACK mode.
 */
static int
cfg_responder_send_ATTR(struct message *msg)
{
	struct ipsec_exch *ie = msg->exchange->data;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	u_int8_t       *hashp = 0, *attrp;
	u_int16_t       attrlen;
	char           *id_string;

	if (msg->exchange->phase == 2) {
		hashp = cfg_add_hash(msg);
		if (!hashp)
			return -1;
	}
	/* We are responder, check isakmp_sa for other side.  */
	if (isakmp_sa->initiator ^ (ie->cfg_type == ISAKMP_CFG_REQUEST))
		id_string = ipsec_id_string(isakmp_sa->id_i,
		    isakmp_sa->id_i_len);
	else
		id_string = ipsec_id_string(isakmp_sa->id_r,
		    isakmp_sa->id_r_len);
	if (!id_string) {
		log_print("cfg_responder_send_ATTR: cannot parse client's ID");
		return -1;
	}
	if (cfg_encode_attributes(&ie->attrs, (ie->cfg_type == ISAKMP_CFG_SET ?
	    ISAKMP_CFG_ACK : ISAKMP_CFG_REPLY), ie->cfg_id, id_string, &attrp,
	    &attrlen)) {
		free(id_string);
		return -1;
	}
	free(id_string);

	if (message_add_payload(msg, ISAKMP_PAYLOAD_ATTRIBUTE, attrp, attrlen,
	    1)) {
		free(attrp);
		return -1;
	}
	if (msg->exchange->phase == 2)
		if (cfg_finalize_hash(msg, hashp, attrp, attrlen))
			return -1;

	return 0;
}

u_int8_t *
cfg_add_hash(struct message *msg)
{
	struct ipsec_sa *isa = msg->isakmp_sa->data;
	struct hash    *hash = hash_get(isa->hash);
	u_int8_t       *hashp;

	hashp = malloc(ISAKMP_HASH_SZ + hash->hashsize);
	if (!hashp) {
		log_error("cfg_add_hash: malloc (%lu) failed",
		    ISAKMP_HASH_SZ + (unsigned long)hash->hashsize);
		return 0;
	}
	if (message_add_payload(msg, ISAKMP_PAYLOAD_HASH, hashp,
	    ISAKMP_HASH_SZ + hash->hashsize, 1)) {
		free(hashp);
		return 0;
	}
	return hashp;
}

int
cfg_finalize_hash(struct message *msg, u_int8_t *hashp, u_int8_t *data,
    u_int16_t length)
{
	struct ipsec_sa *isa = msg->isakmp_sa->data;
	struct prf     *prf;

	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf)
		return -1;

	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, msg->exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	prf->Update(prf->prfctx, data, length);
	prf->Final(hashp + ISAKMP_GEN_SZ, prf->prfctx);
	prf_free(prf);
	return 0;
}

int
cfg_verify_hash(struct message *msg)
{
	struct payload *hashp = payload_first(msg, ISAKMP_PAYLOAD_HASH);
	struct ipsec_sa *isa = msg->isakmp_sa->data;
	struct prf     *prf;
	u_int8_t       *hash, *comp_hash;
	size_t          hash_len;

	if (!hashp) {
		log_print("cfg_verify_hash: phase 2 message missing HASH");
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION,
		    0, 1, 0);
		return -1;
	}
	hash = hashp->p;
	hash_len = GET_ISAKMP_GEN_LENGTH(hash);
	comp_hash = malloc(hash_len - ISAKMP_GEN_SZ);
	if (!comp_hash) {
		log_error("cfg_verify_hash: malloc (%lu) failed",
		    (unsigned long)hash_len - ISAKMP_GEN_SZ);
		return -1;
	}
	/* Verify hash.  */
	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf) {
		free(comp_hash);
		return -1;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, msg->exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	prf->Update(prf->prfctx, hash + hash_len,
	    msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
	prf->Final(comp_hash, prf->prfctx);
	prf_free(prf);

	if (memcmp(hash + ISAKMP_GEN_SZ, comp_hash, hash_len - ISAKMP_GEN_SZ)
	    != 0) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION,
		    0, 1, 0);
		free(comp_hash);
		return -1;
	}
	free(comp_hash);

	/* Mark the HASH as handled.  */
	hashp->flags |= PL_MARK;

	/* Mark message authenticated. */
	msg->flags |= MSG_AUTHENTICATED;

	return 0;
}

/*
 * Decode the attribute of type TYPE with a LEN length value pointed to by
 * VALUE.  VIE is a pointer to the IPsec exchange context holding the
 * attributes indexed by type for easy retrieval.
 */
static int
cfg_decode_attribute(u_int16_t type, u_int8_t * value, u_int16_t len,
    void *vie)
{
	struct ipsec_exch *ie = vie;
	struct isakmp_cfg_attr *attr;

	if (type >= ISAKMP_CFG_ATTR_PRIVATE_MIN &&
	    type <= ISAKMP_CFG_ATTR_PRIVATE_MAX)
		return 0;
	if (type == 0 || type >= ISAKMP_CFG_ATTR_FUTURE_MIN) {
		LOG_DBG((LOG_NEGOTIATION, 30,
		    "cfg_decode_attribute: invalid attr type %u", type));
		return -1;
	}
	attr = calloc(1, sizeof *attr);
	if (!attr) {
		log_error("cfg_decode_attribute: calloc (1, %lu) failed",
		    (unsigned long)sizeof *attr);
		return -1;
	}
	attr->type = type;
	attr->length = len;
	if (len) {
		attr->value = malloc(len);
		if (!attr->value) {
			log_error("cfg_decode_attribute: malloc (%d) failed",
			    len);
			free(attr);
			/* Should we also deallocate all other values?  */
			return -1;
		}
		memcpy(attr->value, value, len);
	}
	LIST_INSERT_HEAD(&ie->attrs, attr, link);
	return 0;
}

/*
 * Encode list of attributes from ie->attrs into a attribute payload.
 */
static int
cfg_encode_attributes(struct isakmp_cfg_attr_head *attrs, u_int32_t type,
    u_int32_t cfg_id, char *id_string, u_int8_t **attrp, u_int16_t *len)
{
	struct isakmp_cfg_attr *attr;
	struct sockaddr *sa;
	sa_family_t     family;
	u_int32_t       value;
	u_int16_t       off;
	char           *field;

	/* Compute length */
	*len = ISAKMP_ATTRIBUTE_SZ;
	for (attr = LIST_FIRST(attrs); attr; attr = LIST_NEXT(attr, link)) {
		/* With ACK we only include the attrs we've actually used.  */
		if (type == ISAKMP_CFG_ACK && attr->attr_used == 0)
			continue;

		switch (attr->type) {
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
		case ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY:
			attr->length = 4;
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET:
			attr->length = 8;
			break;

		case ISAKMP_CFG_ATTR_APPLICATION_VERSION:
			/* XXX So far no version identifier of isakmpd here. */
			attr->length = 0;
			break;

		case ISAKMP_CFG_ATTR_SUPPORTED_ATTRIBUTES:
			attr->length = 2 * 15;
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
			attr->length = 16;
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
			attr->length = 17;
			break;

		default:
			attr->ignore++;
			/* XXX Log!  */
		}
		*len += ISAKMP_ATTR_SZ + attr->length;
	}

	/* Allocate enough space for the payload */
	*attrp = calloc(1, *len);
	if (!*attrp) {
		log_error("cfg_encode_attributes: calloc (1, %lu) failed",
		    (unsigned long)*len);
		return -1;
	}
	SET_ISAKMP_ATTRIBUTE_TYPE(*attrp, type);
	SET_ISAKMP_ATTRIBUTE_ID(*attrp, cfg_id);

	off = ISAKMP_ATTRIBUTE_SZ;
	for (attr = LIST_FIRST(attrs); attr; attr = LIST_NEXT(attr, link)) {
		/* With ACK we only include the attrs we've actually used.  */
		if (type == ISAKMP_CFG_ACK && attr->attr_used == 0)
			continue;

		switch (attr->type) {
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
			family = AF_INET;
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
			family = AF_INET6;
			break;

		default:
			family = 0;
			break;
		}

		switch (attr->type) {
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
			field = "Address";
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
			field = "Network";	/* XXX or just "Address" */
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
			field = "Netmask";
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
			field = "DHCP-server";
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
			field = "Nameserver";
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
			field = "WINS-server";
			break;

		default:
			field = 0;
		}

		switch (attr->type) {
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
		case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
			sa = conf_get_address(id_string, field);
			if (!sa) {
				LOG_DBG((LOG_NEGOTIATION, 10,
				    "cfg_responder_send_ATTR: "
				    "attribute not found: %s", field));
				attr->length = 0;
				break;
			}
			if (sa->sa_family != family) {
				log_print("cfg_responder_send_ATTR: "
				    "attribute %s - expected %s got %s data",
				    field,
				    (family == AF_INET ? "IPv4" : "IPv6"),
				    (sa->sa_family ==
					AF_INET ? "IPv4" : "IPv6"));
				free(sa);
				attr->length = 0;
				break;
			}
			/* Temporary limit length for the _SUBNET types. */
			if (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET)
				attr->length = 4;
			else if (attr->type ==
			    ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET)
				attr->length = 16;

			memcpy(*attrp + off + ISAKMP_ATTR_VALUE_OFF,
			    sockaddr_addrdata(sa), attr->length);
			free(sa);

			/* _SUBNET types need some extra work. */
			if (attr->type ==
			    ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET) {
				sa = conf_get_address(id_string, "Netmask");
				if (!sa) {
					LOG_DBG((LOG_NEGOTIATION, 10,
					    "cfg_responder_send_ATTR: "
					   "attribute not found: Netmask"));
					attr->length = 0;
					break;
				}
				if (sa->sa_family != AF_INET) {
					log_print("cfg_responder_send_ATTR: "
					    "attribute Netmask - expected "
					    "IPv4 got IPv6 data");
					free(sa);
					attr->length = 0;
					break;
				}
				memcpy(*attrp + off + ISAKMP_ATTR_VALUE_OFF +
				    attr->length, sockaddr_addrdata(sa),
				    attr->length);
				attr->length = 8;
				free(sa);
			} else if (attr->type ==
			    ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET) {
				int prefix = conf_get_num(id_string, "Prefix",
				    -1);

				if (prefix == -1) {
					log_print("cfg_responder_send_ATTR: "
					    "attribute not found: Prefix");
					attr->length = 0;
					break;
				} else if (prefix < -1 || prefix > 128) {
					log_print("cfg_responder_send_ATTR: "
					    "attribute Prefix - invalid "
					    "value %d", prefix);
					attr->length = 0;
					break;
				}
				*(*attrp + off + ISAKMP_ATTR_VALUE_OFF + 16) =
				    (u_int8_t)prefix;
				attr->length = 17;
			}
			break;

		case ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY:
			value = conf_get_num(id_string, "Lifetime", 1200);
			encode_32(*attrp + off + ISAKMP_ATTR_VALUE_OFF, value);
			break;

		case ISAKMP_CFG_ATTR_APPLICATION_VERSION:
			/* XXX So far no version identifier of isakmpd here. */
			break;

		case ISAKMP_CFG_ATTR_SUPPORTED_ATTRIBUTES:
			break;

		default:
			break;
		}

		SET_ISAKMP_ATTR_TYPE(*attrp + off, attr->type);
		SET_ISAKMP_ATTR_LENGTH_VALUE(*attrp + off, attr->length);
		off += ISAKMP_ATTR_VALUE_OFF + attr->length;
	}

	return 0;
}
@


1.38
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.37 2005/04/08 22:32:10 cloder Exp $	 */
d257 1
a257 1
	getrandom((u_int8_t *) & ie->cfg_id, sizeof ie->cfg_id);
@


1.37
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.36 2005/04/06 16:00:20 deraadt Exp $	 */
d347 1
a347 2
	if (id_string)
		free(id_string);
@


1.36
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.35 2005/04/04 19:31:11 deraadt Exp $	 */
a38 2

#include "sysdep.h"
@


1.35
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.34 2004/08/08 19:11:06 deraadt Exp $	 */
d703 2
a704 2
	if (type >= ISAKMP_CFG_ATTR_PRIVATE_MIN
	    && type <= ISAKMP_CFG_ATTR_PRIVATE_MAX)
@


1.34
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.33 2004/06/20 17:17:35 ho Exp $	 */
d242 1
a242 1
	         */
@


1.33
log
@Make the payload array in struct message dynamic, since we need to handle
payloads in the private range, such as the pre-RFC NAT-D/NAT-OA.
Replace TAILQ_FIRST(&msg->payload[i]) instances with function calls.
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.32 2004/06/15 15:53:13 hshoexer Exp $	 */
d896 1
a896 1
				    (sa->sa_family == 
d914 1
a914 1
			if (attr->type == 
@


1.32
log
@also use MSG_AUTHENTICATED flag.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.31 2004/06/14 09:55:41 ho Exp $	 */
d361 1
a361 2
	struct payload *attrp =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_ATTRIBUTE]);
d470 1
a470 2
	struct payload *attrp =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_ATTRIBUTE]);
d638 1
a638 2
	struct payload *hashp =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
@


1.31
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.30 2004/06/09 14:02:44 ho Exp $	 */
d687 3
@


1.30
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.29 2004/05/23 18:17:56 hshoexer Exp $	 */
d69 1
a69 1
		    u_int32_t, char *, u_int8_t **, u_int16_t *);
d77 1
a77 1
		    u_int16_t);
d279 2
a280 1
				life = conf_get_num(id_string, "Lifetime", 1200);
d376 2
a377 1
		log_print("cfg_initiator_recv_ATTR: cfg packet ID does not match!");
d384 2
a385 1
			log_print("cfg_initiator_recv_ATTR: bad packet type ACK");
d393 2
a394 1
			log_print("cfg_initiator_recv_ATTR: bad packet type REPLY");
d415 2
a416 1
			msg->transport->vtbl->get_src(isakmp_sa->transport, &sa);
d438 2
a439 1
			msg->transport->vtbl->get_src(isakmp_sa->transport, &sa);
d511 2
a512 1
			msg->transport->vtbl->get_dst(isakmp_sa->transport, &sa);
d640 2
a641 1
	struct payload *hashp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
d770 1
a770 1
			/* XXX So far no version identifier of isakmpd here.  */
d896 2
a897 1
				    (sa->sa_family == AF_INET ? "IPv4" : "IPv6"));
d914 2
a915 1
			if (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET) {
d949 2
a950 2
					    "attribute Prefix - invalid value %d",
					    prefix);
d966 1
a966 1
			/* XXX So far no version identifier of isakmpd here.  */
@


1.29
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.28 2004/04/15 18:39:26 deraadt Exp $	 */
d78 1
a78 1
int             cfg_verify_hash(struct message * msg);
d610 1
a610 1
cfg_finalize_hash(struct message * msg, u_int8_t * hashp, u_int8_t * data,
@


1.28
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: isakmp_cfg.c,v 1.27 2004/03/11 16:56:11 hshoexer Exp $	 */
d60 1
a60 1
int16_t         script_transaction[] = {
d68 2
a69 3
static int
cfg_encode_attributes(struct isakmp_cfg_attr_head *, u_int32_t,
		      u_int32_t, char *, u_int8_t **, u_int16_t *);
d76 2
a77 3
int
cfg_finalize_hash(struct message *, u_int8_t *, u_int8_t *,
		  u_int16_t);
d81 1
a81 1
int             (*isakmp_cfg_initiator[]) (struct message *) = {
d87 1
a87 1
int             (*isakmp_cfg_responder[]) (struct message *) = {
d97 1
a97 1
cfg_initiator_send_ATTR(struct message * msg)
d117 2
a118 1
		id_string = ipsec_id_string(isakmp_sa->id_r, isakmp_sa->id_r_len);
d120 2
a121 1
		id_string = ipsec_id_string(isakmp_sa->id_i, isakmp_sa->id_i_len);
d135 2
a136 1
		LOG_DBG((LOG_NEGOTIATION, 10, "cfg_initiator_send_ATTR: SET/ACK mode"));
d140 15
a154 16
	  if ((sa = conf_get_address (id_string, STR)) != NULL)		\
	    switch (sa->sa_family)					\
	      {								\
	      case AF_INET:						\
		bit_set (attrbits, ATTR4);				\
		attrlen += ISAKMP_ATTR_SZ + LEN4;			\
		break;							\
	      case AF_INET6:						\
		bit_set (attrbits, ATTR6);				\
		attrlen += ISAKMP_ATTR_SZ + LEN6;			\
		break;							\
	      default:							\
		break;							\
	      }								\
          free (sa);							\
        } while (0)
d161 1
a161 1
			 ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS, 16);
d163 1
a163 1
			 ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK, 16);
d165 1
a165 1
			 ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS, 16);
d167 1
a167 1
			 ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS, 16);
d169 1
a169 1
			 ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP, 16);
d172 1
a172 1
			 ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET, 17);
d177 2
a178 1
			bit_set(attrbits, ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY);
d188 1
a188 1
			 "cfg_initiator_send_ATTR: REQ/REPLY mode"));
d193 1
a193 1
			     anode = TAILQ_NEXT(anode, link)) {
d198 2
a199 1
				} else if (strcasecmp(anode->field, "Netmask") == 0) {
d203 2
a204 1
				} else if (strcasecmp(anode->field, "Nameserver") == 0) {
d208 2
a209 1
				} else if (strcasecmp(anode->field, "WINS-server") == 0) {
d213 2
a214 1
				} else if (strcasecmp(anode->field, "DHCP-server") == 0) {
d218 2
a219 1
				} else if (strcasecmp(anode->field, "Lifetime") == 0) {
d223 4
a226 2
					log_print("cfg_initiator_send_ATTR: unknown attribute "
						  "%.20s in section [%s]", anode->field, id_string);
d237 1
a237 1
			  "found for [%s]", id_string);
d240 2
a241 2
		 * We can continue, but this indicates a configuration error that
		 * the user probably will want to correct.
d250 1
a250 1
			  (unsigned long) attrlen);
d253 2
a254 1
	if (message_add_payload(msg, ISAKMP_PAYLOAD_ATTRIBUTE, attrp, attrlen, 1)) {
d334 2
a335 2
			memcpy(attr + ISAKMP_ATTR_VALUE_OFF, sockaddr_addrdata(sa),
			       length);
d358 1
a358 1
cfg_initiator_recv_ATTR(struct message * msg)
d360 2
a361 2
	struct payload *attrp
	= TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_ATTRIBUTE]);
d383 2
a384 1
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
d391 2
a392 1
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
d398 2
a399 3
		log_print("cfg_initiator_recv_ATTR: "
			  "unexpected configuration message type %d",
			  attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF]);
d405 2
a406 2
		      GET_ISAKMP_GEN_LENGTH(attrp->p)
		 - ISAKMP_TRANSFORM_SA_ATTRS_OFF, cfg_decode_attribute, ie);
d409 1
a409 2
	case ISAKMP_CFG_ACK:
		{
d416 6
a421 4
			     attr = LIST_NEXT(attr, link))
				LOG_DBG((LOG_NEGOTIATION, 50, "cfg_initiator_recv_ATTR: "
					 "client %s ACKs attribute %s", addr,
					 constant_name(isakmp_cfg_attr_cst, attr->type)));
d428 1
a428 2
	case ISAKMP_CFG_REPLY:
		{
d438 6
a443 4
			     attr = LIST_NEXT(attr, link))
				LOG_DBG((LOG_NEGOTIATION, 50, "cfg_initiator_recv_ATTR: "
				"server %s replied with attribute %s", addr,
					 constant_name(isakmp_cfg_attr_cst, attr->type)));
d463 1
a463 1
cfg_responder_recv_ATTR(struct message * msg)
d465 2
a466 2
	struct payload *attrp
	= TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_ATTRIBUTE]);
d488 1
a488 1
		  "unexpected configuration message type %d", ie->cfg_type);
d493 2
a494 2
		      GET_ISAKMP_GEN_LENGTH(attrp->p)
		 - ISAKMP_TRANSFORM_SA_ATTRS_OFF, cfg_decode_attribute, ie);
d501 1
a501 2
	case ISAKMP_CFG_SET:
		{
d510 6
a515 4
			     attr = LIST_NEXT(attr, link))
				LOG_DBG((LOG_NEGOTIATION, 50, "cfg_responder_recv_ATTR: "
					 "server %s asks us to SET attribute %s", addr,
					 constant_name(isakmp_cfg_attr_cst, attr->type)));
d518 6
a523 5
			 * XXX Here's the place to add code to walk through each attribute
			 * XXX and send them along to dhclient or whatever. Each attribute
			 * XXX that we act upon (such as setting a netmask), should be
			 * XXX marked like this for us to send the proper ACK response:
			 * XXX   attr->attr_used++;
d544 1
a544 1
cfg_responder_send_ATTR(struct message * msg)
d559 2
a560 1
		id_string = ipsec_id_string(isakmp_sa->id_i, isakmp_sa->id_i_len);
d562 2
a563 1
		id_string = ipsec_id_string(isakmp_sa->id_r, isakmp_sa->id_r_len);
d569 2
a570 2
					 ISAKMP_CFG_ACK : ISAKMP_CFG_REPLY),
				  ie->cfg_id, id_string, &attrp, &attrlen)) {
d576 2
a577 1
	if (message_add_payload(msg, ISAKMP_PAYLOAD_ATTRIBUTE, attrp, attrlen, 1)) {
d588 2
a589 2
u_int8_t       *
cfg_add_hash(struct message * msg)
d598 1
a598 1
			  ISAKMP_HASH_SZ + (unsigned long) hash->hashsize);
d602 1
a602 1
				ISAKMP_HASH_SZ + hash->hashsize, 1)) {
d611 1
a611 1
		  u_int16_t length)
d616 2
a617 1
	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a, isa->skeyid_len);
d623 1
a623 1
		    ISAKMP_HDR_MESSAGE_ID_LEN);
d631 1
a631 1
cfg_verify_hash(struct message * msg)
d641 2
a642 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
d650 1
a650 1
			  (unsigned long) hash_len - ISAKMP_GEN_SZ);
d655 1
a655 1
			isa->skeyid_len);
d662 1
a662 1
		    ISAKMP_HDR_MESSAGE_ID_LEN);
d664 1
a664 1
		    msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
d668 4
a671 2
	if (memcmp(hash + ISAKMP_GEN_SZ, comp_hash, hash_len - ISAKMP_GEN_SZ) != 0) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
d690 1
a690 1
		     void *vie)
d700 1
a700 1
		       "cfg_decode_attribute: invalid attr type %u", type));
d706 1
a706 1
			  (unsigned long) sizeof *attr);
d714 2
a715 1
			log_error("cfg_decode_attribute: malloc (%d) failed", len);
d730 2
a731 3
cfg_encode_attributes(struct isakmp_cfg_attr_head * attrs, u_int32_t type,
		      u_int32_t cfg_id, char *id_string, u_int8_t ** attrp,
		      u_int16_t * len)
d793 1
a793 1
			  (unsigned long) *len);
d877 3
a879 2
				LOG_DBG((LOG_NEGOTIATION, 10, "cfg_responder_send_ATTR: "
					 "attribute not found: %s", field));
d884 5
a888 4
				log_print("cfg_responder_send_ATTR: attribute %s - expected %s "
					  "got %s data", field,
				      (family == AF_INET ? "IPv4" : "IPv6"),
					  (sa->sa_family == AF_INET ? "IPv4" : "IPv6"));
d896 2
a897 1
			else if (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET)
d900 2
a901 2
			memcpy(*attrp + off + ISAKMP_ATTR_VALUE_OFF, sockaddr_addrdata(sa),
			       attr->length);
d908 2
a909 1
					LOG_DBG((LOG_NEGOTIATION, 10, "cfg_responder_send_ATTR: "
d915 3
a917 2
					log_print("cfg_responder_send_ATTR: attribute Netmask - "
					     "expected IPv4 got IPv6 data");
d922 3
a924 2
				memcpy(*attrp + off + ISAKMP_ATTR_VALUE_OFF + attr->length,
				       sockaddr_addrdata(sa), attr->length);
d927 4
a930 2
			} else if (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET) {
				int             prefix = conf_get_num(id_string, "Prefix", -1);
d934 1
a934 1
					     "attribute not found: Prefix");
d938 3
a940 2
					log_print("cfg_responder_send_ATTR: attribute Prefix - "
						"invalid value %d", prefix);
d944 2
a945 1
				*(*attrp + off + ISAKMP_ATTR_VALUE_OFF + 16) = (u_int8_t) prefix;
@


1.27
log
@Fix a memleak.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.26 2003/12/04 21:13:35 miod Exp $	*/
d60 5
a64 5
int16_t script_transaction[] = {
  ISAKMP_PAYLOAD_ATTRIBUTE,	/* Initiator -> responder.  */
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_ATTRIBUTE,	/* Responder -> initiator.  */
  EXCHANGE_SCRIPT_END
d67 14
a80 12
static int cfg_decode_attribute (u_int16_t, u_int8_t *, u_int16_t, void *);
static int cfg_encode_attributes (struct isakmp_cfg_attr_head *, u_int32_t,
				  u_int32_t, char *, u_int8_t **, u_int16_t *);
static int cfg_initiator_send_ATTR (struct message *);
static int cfg_initiator_recv_ATTR (struct message *);
static int cfg_responder_recv_ATTR (struct message *);
static int cfg_responder_send_ATTR (struct message *);

u_int8_t *cfg_add_hash (struct message *);
int	  cfg_finalize_hash (struct message *,u_int8_t *, u_int8_t *,
			     u_int16_t);
int	  cfg_verify_hash (struct message *msg);
d83 3
a85 3
int (*isakmp_cfg_initiator[]) (struct message *) = {
  cfg_initiator_send_ATTR,
  cfg_initiator_recv_ATTR
d89 3
a91 3
int (*isakmp_cfg_responder[]) (struct message *) = {
  cfg_responder_recv_ATTR,
  cfg_responder_send_ATTR
d99 1
a99 1
cfg_initiator_send_ATTR (struct message *msg)
d101 6
a106 6
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_exch *ie = msg->exchange->data;
  u_int8_t *hashp = 0, *attrp, *attr;
  size_t attrlen, off;
  char *id_string, *cfg_mode, *field;
  struct sockaddr *sa;
d108 26
a133 31
  bitstr_t bit_decl (attrbits, CFG_ATTR_BIT_MAX);
  u_int16_t bit, length;
  u_int32_t life;

  if (msg->exchange->phase == 2)
    {
      hashp = cfg_add_hash (msg);
      if (!hashp)
	return -1;
    }

  /* We initiated this exchange, check isakmp_sa for other side.  */
  if (isakmp_sa->initiator)
    id_string = ipsec_id_string (isakmp_sa->id_r, isakmp_sa->id_r_len);
  else
    id_string = ipsec_id_string (isakmp_sa->id_i, isakmp_sa->id_i_len);
  if (!id_string)
    {
      log_print ("cfg_initiator_send_ATTR: cannot parse ID");
      goto fail;
    }

  /* Check for attribute list to send to the other side */
  attrlen = 0;
  bit_nclear (attrbits, 0, CFG_ATTR_BIT_MAX - 1);

  cfg_mode = conf_get_str (id_string, "Mode");
  if (!cfg_mode || strcmp (cfg_mode, "SET") == 0)
    {
      /* SET/ACK mode */
      ie->cfg_type = ISAKMP_CFG_SET;
d135 1
a135 1
      LOG_DBG ((LOG_NEGOTIATION, 10, "cfg_initiator_send_ATTR: SET/ACK mode"));
d156 14
a169 11
      /* XXX We don't simultaneously support IPv4 and IPv6 addresses.  */
      ATTRFIND ("Address", ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS, 4,
		ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS, 16);
      ATTRFIND ("Netmask", ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK, 4,
		ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK, 16);
      ATTRFIND ("Nameserver", ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS, 4,
		ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS, 16);
      ATTRFIND ("WINS-server", ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS, 4,
		ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS, 16);
      ATTRFIND ("DHCP-server", ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP, 4,
		ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP, 16);
d171 2
a172 2
      ATTRFIND ("Network", ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET, 8,
		ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET, 17);
d176 47
a222 27
      if (conf_get_str (id_string, "Lifetime"))
	{
	  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY);
	  attrlen += ISAKMP_ATTR_SZ + 4;
	}
    }
  else
    {
      struct conf_list *alist;
      struct conf_list_node *anode;

      ie->cfg_type = ISAKMP_CFG_REQUEST;

      LOG_DBG ((LOG_NEGOTIATION, 10,
		"cfg_initiator_send_ATTR: REQ/REPLY mode"));

      alist = conf_get_list (id_string, "Attributes");
      if (alist)
	{
	  for (anode = TAILQ_FIRST (&alist->fields); anode;
	       anode = TAILQ_NEXT (anode, link))
	    {
	      if (strcasecmp (anode->field, "Address") == 0)
		{
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS);
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS);
		  attrlen += ISAKMP_ATTR_SZ * 2;
d224 1
a224 35
	      else if (strcasecmp (anode->field, "Netmask") == 0)
		{
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK);
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK);
		  attrlen += ISAKMP_ATTR_SZ * 2;
		}
	      else if (strcasecmp (anode->field, "Nameserver") == 0)
		{
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS);
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS);
		  attrlen += ISAKMP_ATTR_SZ * 2;
		}
	      else if (strcasecmp (anode->field, "WINS-server") == 0)
		{
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS);
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS);
		  attrlen += ISAKMP_ATTR_SZ * 2;
		}
	      else if (strcasecmp (anode->field, "DHCP-server") == 0)
		{
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP);
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP);
		  attrlen += ISAKMP_ATTR_SZ * 2;
		}
	      else if (strcasecmp (anode->field, "Lifetime") == 0)
		{
		  bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY);
		  attrlen += ISAKMP_ATTR_SZ;
		}
	      else
		{
		  log_print ("cfg_initiator_send_ATTR: unknown attribute "
			     "%.20s in section [%s]", anode->field, id_string);
		}
	    }
d226 22
a247 1
	  conf_free_list (alist);
d249 3
a251 1
    }
d253 89
a341 130
  if (attrlen == 0)
    {
      /* No data found.  */
      log_print ("cfg_initiator_send_ATTR: no IKECFG attributes "
		 "found for [%s]", id_string);

      /*
       * We can continue, but this indicates a configuration error that
       * the user probably will want to correct.
       */
      free (id_string);
      return 0;
    }

  attrlen += ISAKMP_ATTRIBUTE_SZ;
  attrp = calloc (1, attrlen);
  if (!attrp)
    {
      log_error ("cfg_initiator_send_ATTR: calloc (1, %lu) failed",
		 (unsigned long)attrlen);
      goto fail;
    }

  if (message_add_payload (msg, ISAKMP_PAYLOAD_ATTRIBUTE, attrp, attrlen, 1))
    {
      free (attrp);
      goto fail;
    }

  SET_ISAKMP_ATTRIBUTE_TYPE (attrp, ie->cfg_type);
  getrandom ((u_int8_t *)&ie->cfg_id, sizeof ie->cfg_id);
  SET_ISAKMP_ATTRIBUTE_ID (attrp, ie->cfg_id);

  off = ISAKMP_ATTRIBUTE_SZ;

  /*
   * Use the bitstring built previously to collect the right
   * parameters for attrp.
   */
  for (bit = 0; bit < CFG_ATTR_BIT_MAX; bit++)
    if (bit_test (attrbits, bit))
      {
	attr = attrp + off;
	SET_ISAKMP_ATTR_TYPE (attr, bit);

	if (ie->cfg_type == ISAKMP_CFG_REQUEST)
	  {
	    off += ISAKMP_ATTR_SZ;
	    continue;
	  }

	/* All the other are similar, this is the odd one.  */
	if (bit == ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY)
	  {
	    life = conf_get_num (id_string, "Lifetime", 1200);
	    SET_ISAKMP_ATTR_LENGTH_VALUE (attr, 4);
	    encode_32 (attr + ISAKMP_ATTR_VALUE_OFF, life);
	    off += ISAKMP_ATTR_SZ + 4;
	    continue;
	  }

	switch (bit)
	  {
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
	    length = 4;
	    break;

	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
	    length = 16;
	    break;

	  default:
	    length = 0; /* Silence gcc.  */
	  }

	switch (bit)
	  {
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	    field = "Address";
	    break;
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
	    field = "Netmask";
	    break;
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
	    field = "Nameserver";
	    break;
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
	    field = "DHCP-server";
	    break;
	  case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
	  case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
	    field = "WINS-server";
	    break;
	  default:
	    field = 0; /* Silence gcc.  */
	  }

	sa = conf_get_address (id_string, field);

	SET_ISAKMP_ATTR_LENGTH_VALUE (attr, length);
	memcpy (attr + ISAKMP_ATTR_VALUE_OFF, sockaddr_addrdata (sa),
		length);

	free (sa);

	off += ISAKMP_ATTR_SZ + length;
      }

  if (msg->exchange->phase == 2)
    if (cfg_finalize_hash (msg, hashp, attrp, attrlen))
      goto fail;

  return 0;

 fail:
  if (id_string)
    free (id_string);
  return -1;
d349 1
a349 1
cfg_initiator_recv_ATTR (struct message *msg)
d351 34
a384 47
  struct payload *attrp
    = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_ATTRIBUTE]);
  struct ipsec_exch *ie = msg->exchange->data;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct isakmp_cfg_attr *attr;
  struct sockaddr *sa;
  const char *uk_addr = "<unknown>";
  char *addr;

  if (msg->exchange->phase == 2)
    if (cfg_verify_hash (msg))
      return -1;

  /* Sanity.  */
  if (ie->cfg_id != GET_ISAKMP_ATTRIBUTE_ID (attrp->p))
    {
      log_print ("cfg_initiator_recv_ATTR: cfg packet ID does not match!");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      return -1;
    }

  switch (attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF])
    {
    case ISAKMP_CFG_ACK:
      if (ie->cfg_type != ISAKMP_CFG_SET)
	{
	  log_print ("cfg_initiator_recv_ATTR: bad packet type ACK");
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
	  return -1;
	}
      break;
    case ISAKMP_CFG_REPLY:
      if (ie->cfg_type != ISAKMP_CFG_REQUEST)
	{
	  log_print ("cfg_initiator_recv_ATTR: bad packet type REPLY");
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
	  return -1;
	}
      break;

    default:
      log_print ("cfg_initiator_recv_ATTR: "
		 "unexpected configuration message type %d",
		 attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF]);
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      return -1;
    }
d386 10
a395 2
  attribute_map (attrp->p + ISAKMP_ATTRIBUTE_ATTRS_OFF,
		 GET_ISAKMP_GEN_LENGTH (attrp->p)
d398 43
a440 41
  switch (ie->cfg_type)
    {
    case ISAKMP_CFG_ACK:
      {
	/* SET/ACK -- Server side (ACK from client) */
	msg->transport->vtbl->get_src (isakmp_sa->transport, &sa);
	if (sockaddr2text (sa, &addr, 0) < 0)
	  addr = (char *)uk_addr;

	for (attr = LIST_FIRST (&ie->attrs); attr;
	     attr = LIST_NEXT (attr, link))
	  LOG_DBG ((LOG_NEGOTIATION, 50, "cfg_initiator_recv_ATTR: "
		    "client %s ACKs attribute %s", addr,
		    constant_name (isakmp_cfg_attr_cst, attr->type)));

	if (addr != uk_addr)
	  free (addr);
      }
      break;

    case ISAKMP_CFG_REPLY:
      {
	/* REQ/REPLY: effect attributes we've gotten responses on.  */
	msg->transport->vtbl->get_src (isakmp_sa->transport, &sa);
	if (sockaddr2text (sa, &addr, 0) < 0)
	  addr = (char *)uk_addr;

	for (attr = LIST_FIRST (&ie->attrs); attr;
	     attr = LIST_NEXT (attr, link))
	  LOG_DBG ((LOG_NEGOTIATION, 50, "cfg_initiator_recv_ATTR: "
		    "server %s replied with attribute %s", addr,
		    constant_name (isakmp_cfg_attr_cst, attr->type)));

	if (addr != uk_addr)
	  free (addr);
      }
      break;

    default:
      break;
    }
d442 2
a443 2
  attrp->flags |= PL_MARK;
  return 0;
d451 1
a451 1
cfg_responder_recv_ATTR (struct message *msg)
d453 19
a471 27
  struct payload *attrp
    = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_ATTRIBUTE]);
  struct ipsec_exch *ie = msg->exchange->data;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct isakmp_cfg_attr *attr;
  struct sockaddr *sa;
  char *addr;

  if (msg->exchange->phase == 2)
    if (cfg_verify_hash (msg))
      return -1;

  ie->cfg_id = GET_ISAKMP_ATTRIBUTE_ID (attrp->p);
  ie->cfg_type = attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF];

  switch (ie->cfg_type)
    {
    case ISAKMP_CFG_REQUEST:
    case ISAKMP_CFG_SET:
      break;

    default:
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      log_print ("cfg_responder_recv_ATTR: "
		 "unexpected configuration message type %d", ie->cfg_type);
      return -1;
    }
d473 9
a481 2
  attribute_map (attrp->p + ISAKMP_ATTRIBUTE_ATTRS_OFF,
		 GET_ISAKMP_GEN_LENGTH (attrp->p)
d484 32
a515 20
  switch (ie->cfg_type)
    {
    case ISAKMP_CFG_REQUEST:
      /* We're done.  */
      break;

    case ISAKMP_CFG_SET:
      {
	/* SET/ACK -- Client side (SET from server) */
	const char *uk_addr = "<unknown>";

	msg->transport->vtbl->get_dst (isakmp_sa->transport, &sa);
	if (sockaddr2text (sa, &addr, 0) < 0)
	  addr = (char *)uk_addr;

	for (attr = LIST_FIRST (&ie->attrs); attr;
	     attr = LIST_NEXT (attr, link))
	  LOG_DBG ((LOG_NEGOTIATION, 50, "cfg_responder_recv_ATTR: "
		    "server %s asks us to SET attribute %s", addr,
		    constant_name (isakmp_cfg_attr_cst, attr->type)));
d517 3
a519 16
	/*
	 * XXX Here's the place to add code to walk through each attribute
	 * XXX and send them along to dhclient or whatever. Each attribute
	 * XXX that we act upon (such as setting a netmask), should be
	 * XXX marked like this for us to send the proper ACK response:
	 * XXX   attr->attr_used++;
	 */

	if (addr != uk_addr)
	  free (addr);
      }
      break;

    default:
      break;
    }
d521 2
a522 2
  attrp->flags |= PL_MARK;
  return 0;
d530 1
a530 1
cfg_responder_send_ATTR (struct message *msg)
d532 27
a558 12
  struct ipsec_exch *ie = msg->exchange->data;
  struct sa *isakmp_sa = msg->isakmp_sa;
  u_int8_t *hashp = 0, *attrp;
  u_int16_t attrlen;
  char *id_string;

  if (msg->exchange->phase == 2)
    {
      hashp = cfg_add_hash (msg);
      if (!hashp)
	return -1;
    }
d560 7
a566 29
  /* We are responder, check isakmp_sa for other side.  */
  if (isakmp_sa->initiator ^ (ie->cfg_type == ISAKMP_CFG_REQUEST))
    id_string = ipsec_id_string (isakmp_sa->id_i, isakmp_sa->id_i_len);
  else
    id_string = ipsec_id_string (isakmp_sa->id_r, isakmp_sa->id_r_len);
  if (!id_string)
    {
      log_print ("cfg_responder_send_ATTR: cannot parse client's ID");
      return -1;
    }

  if (cfg_encode_attributes (&ie->attrs, (ie->cfg_type == ISAKMP_CFG_SET ?
					  ISAKMP_CFG_ACK : ISAKMP_CFG_REPLY),
			     ie->cfg_id, id_string, &attrp, &attrlen))
    {
      free (id_string);
      return -1;
    }
  free (id_string);

  if (message_add_payload (msg, ISAKMP_PAYLOAD_ATTRIBUTE, attrp, attrlen, 1))
    {
      free (attrp);
      return -1;
    }

  if (msg->exchange->phase == 2)
    if (cfg_finalize_hash (msg, hashp, attrp, attrlen))
      return -1;
d568 1
a568 1
  return 0;
d571 2
a572 2
u_int8_t *
cfg_add_hash (struct message *msg)
d574 16
a589 18
  struct ipsec_sa *isa = msg->isakmp_sa->data;
  struct hash *hash = hash_get (isa->hash);
  u_int8_t *hashp;

  hashp = malloc (ISAKMP_HASH_SZ + hash->hashsize);
  if (!hashp)
    {
      log_error ("cfg_add_hash: malloc (%lu) failed",
		 ISAKMP_HASH_SZ + (unsigned long)hash->hashsize);
      return 0;
    }
  if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, hashp,
			   ISAKMP_HASH_SZ + hash->hashsize, 1))
    {
      free (hashp);
      return 0;
    }
  return hashp;
d593 2
a594 2
cfg_finalize_hash (struct message *msg, u_int8_t *hashp, u_int8_t *data,
		 u_int16_t length)
d596 2
a597 2
  struct ipsec_sa *isa = msg->isakmp_sa->data;
  struct prf *prf;
d599 11
a609 11
  prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, msg->exchange->message_id,
	       ISAKMP_HDR_MESSAGE_ID_LEN);
  prf->Update (prf->prfctx, data, length);
  prf->Final (hashp + ISAKMP_GEN_SZ, prf->prfctx);
  prf_free (prf);
  return 0;
d613 1
a613 1
cfg_verify_hash (struct message *msg)
d615 40
a654 47
  struct payload *hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  struct ipsec_sa *isa = msg->isakmp_sa->data;
  struct prf *prf;
  u_int8_t *hash, *comp_hash;
  size_t hash_len;

  if (!hashp)
    {
      log_print ("cfg_verify_hash: phase 2 message missing HASH");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      return -1;
    }

  hash = hashp->p;
  hash_len = GET_ISAKMP_GEN_LENGTH (hash);
  comp_hash = malloc (hash_len - ISAKMP_GEN_SZ);
  if (!comp_hash)
    {
      log_error ("cfg_verify_hash: malloc (%lu) failed",
		 (unsigned long)hash_len - ISAKMP_GEN_SZ);
      return -1;
    }

  /* Verify hash.  */
  prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a,
		   isa->skeyid_len);
  if (!prf)
    {
      free (comp_hash);
      return -1;
    }

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, msg->exchange->message_id,
	       ISAKMP_HDR_MESSAGE_ID_LEN);
  prf->Update (prf->prfctx, hash + hash_len,
	       msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
  prf->Final (comp_hash, prf->prfctx);
  prf_free (prf);

  if (memcmp (hash + ISAKMP_GEN_SZ, comp_hash, hash_len - ISAKMP_GEN_SZ) != 0)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      free (comp_hash);
      return -1;
    }
  free (comp_hash);
d656 2
a657 2
  /* Mark the HASH as handled.  */
  hashp->flags |= PL_MARK;
d659 1
a659 1
  return 0;
d668 2
a669 2
cfg_decode_attribute (u_int16_t type, u_int8_t *value, u_int16_t len,
		      void *vie)
d671 2
a672 2
  struct ipsec_exch *ie = vie;
  struct isakmp_cfg_attr *attr;
d674 28
a701 33
  if (type >= ISAKMP_CFG_ATTR_PRIVATE_MIN
      && type <= ISAKMP_CFG_ATTR_PRIVATE_MAX)
    return 0;
  if (type == 0 || type >= ISAKMP_CFG_ATTR_FUTURE_MIN)
    {
      LOG_DBG ((LOG_NEGOTIATION, 30,
		"cfg_decode_attribute: invalid attr type %u", type));
      return -1;
    }

  attr = calloc (1, sizeof *attr);
  if (!attr)
    {
      log_error ("cfg_decode_attribute: calloc (1, %lu) failed",
		 (unsigned long)sizeof *attr);
      return -1;
    }
  attr->type = type;
  attr->length = len;
  if (len)
    {
      attr->value = malloc (len);
      if (!attr->value)
	{
	  log_error ("cfg_decode_attribute: malloc (%d) failed", len);
	  free (attr);
	  /* Should we also deallocate all other values?  */
	  return -1;
	}
      memcpy (attr->value, value, len);
    }
  LIST_INSERT_HEAD (&ie->attrs, attr, link);
  return 0;
d708 3
a710 3
cfg_encode_attributes (struct isakmp_cfg_attr_head *attrs, u_int32_t type,
		       u_int32_t cfg_id, char *id_string, u_int8_t **attrp,
		       u_int16_t *len)
d712 55
a766 50
  struct isakmp_cfg_attr *attr;
  struct sockaddr *sa;
  sa_family_t family;
  u_int32_t value;
  u_int16_t off;
  char *field;

  /* Compute length */
  *len = ISAKMP_ATTRIBUTE_SZ;
  for (attr = LIST_FIRST (attrs); attr; attr = LIST_NEXT (attr, link))
    {
      /* With ACK we only include the attrs we've actually used.  */
      if (type == ISAKMP_CFG_ACK && attr->attr_used == 0)
	continue;

      switch (attr->type)
	{
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
	case ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY:
	  attr->length = 4;
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET:
	  attr->length = 8;
	  break;

	case ISAKMP_CFG_ATTR_APPLICATION_VERSION:
	  /* XXX So far no version identifier of isakmpd here.  */
	  attr->length = 0;
	  break;

	case ISAKMP_CFG_ATTR_SUPPORTED_ATTRIBUTES:
	  attr->length = 2 * 15;
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
	  attr->length = 16;
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
	  attr->length = 17;
	  break;
d768 6
a773 3
	default:
	  attr->ignore++;
	  /* XXX Log!  */
d775 2
a776 152
      *len += ISAKMP_ATTR_SZ + attr->length;
    }

  /* Allocate enough space for the payload */
  *attrp = calloc (1, *len);
  if (!*attrp)
    {
      log_error ("cfg_encode_attributes: calloc (1, %lu) failed",
		 (unsigned long)*len);
      return -1;
    }

  SET_ISAKMP_ATTRIBUTE_TYPE (*attrp, type);
  SET_ISAKMP_ATTRIBUTE_ID (*attrp, cfg_id);

  off = ISAKMP_ATTRIBUTE_SZ;
  for (attr = LIST_FIRST (attrs); attr; attr = LIST_NEXT (attr, link))
    {
      /* With ACK we only include the attrs we've actually used.  */
      if (type == ISAKMP_CFG_ACK && attr->attr_used == 0)
	continue;

      switch (attr->type)
        {
        case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
        case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
        case ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET:
        case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
        case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
        case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
          family = AF_INET;
          break;

        case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
          family = AF_INET6;
          break;

        default:
          family = 0;
          break;
        }

      switch (attr->type)
        {
        case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
          field = "Address";
          break;

        case ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
          field = "Network"; /* XXX or just "Address" */
          break;

        case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
          field = "Netmask";
          break;

        case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
          field = "DHCP-server";
          break;

        case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
          field = "Nameserver";
          break;

        case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
        case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
          field = "WINS-server";
          break;

        default:
          field = 0;
        }

      switch (attr->type)
	{
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
	  sa = conf_get_address (id_string, field);
	  if (!sa)
	    {
	      LOG_DBG ((LOG_NEGOTIATION, 10, "cfg_responder_send_ATTR: "
			"attribute not found: %s", field));
	      attr->length = 0;
	      break;
	    }

	  if (sa->sa_family != family)
	    {
	      log_print ("cfg_responder_send_ATTR: attribute %s - expected %s "
			 "got %s data", field,
			 (family == AF_INET ? "IPv4" : "IPv6"),
			 (sa->sa_family == AF_INET ? "IPv4" : "IPv6"));
	      free (sa);
	      attr->length = 0;
	      break;
	    }

	  /* Temporary limit length for the _SUBNET types. */
	  if (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET)
	    attr->length = 4;
	  else if (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET)
	    attr->length = 16;

	  memcpy (*attrp + off + ISAKMP_ATTR_VALUE_OFF, sockaddr_addrdata (sa),
		  attr->length);
	  free (sa);

	  /* _SUBNET types need some extra work. */
	  if (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET)
	    {
	      sa = conf_get_address (id_string, "Netmask");
	      if (!sa)
		{
		  LOG_DBG ((LOG_NEGOTIATION, 10, "cfg_responder_send_ATTR: "
			    "attribute not found: Netmask"));
		  attr->length = 0;
		  break;
		}
	      if (sa->sa_family != AF_INET)
		{
		  log_print ("cfg_responder_send_ATTR: attribute Netmask - "
			     "expected IPv4 got IPv6 data");
		  free (sa);
		  attr->length = 0;
		  break;
		}
	      memcpy (*attrp + off + ISAKMP_ATTR_VALUE_OFF + attr->length,
		      sockaddr_addrdata (sa), attr->length);
	      attr->length = 8;
	      free (sa);
	    }
	  else if (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET)
	    {
	      int prefix = conf_get_num (id_string, "Prefix", -1);
d778 160
a937 34
	      if (prefix == -1)
		{
		  log_print ("cfg_responder_send_ATTR: "
			     "attribute not found: Prefix");
		  attr->length = 0;
		  break;
		}
	      else if (prefix < -1 || prefix > 128)
		{
		  log_print ("cfg_responder_send_ATTR: attribute Prefix - "
			     "invalid value %d", prefix);
		  attr->length = 0;
		  break;
		}

	      *(*attrp + off + ISAKMP_ATTR_VALUE_OFF + 16) = (u_int8_t)prefix;
	      attr->length = 17;
	    }
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY:
	  value = conf_get_num (id_string, "Lifetime", 1200);
	  encode_32 (*attrp + off + ISAKMP_ATTR_VALUE_OFF, value);
	  break;

	case ISAKMP_CFG_ATTR_APPLICATION_VERSION:
	  /* XXX So far no version identifier of isakmpd here.  */
	  break;

	case ISAKMP_CFG_ATTR_SUPPORTED_ATTRIBUTES:
	  break;

	default:
	  break;
d940 1
a940 6
      SET_ISAKMP_ATTR_TYPE (*attrp + off, attr->type);
      SET_ISAKMP_ATTR_LENGTH_VALUE (*attrp + off, attr->length);
      off += ISAKMP_ATTR_VALUE_OFF + attr->length;
    }

  return 0;
@


1.26
log
@Typos
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.25 2003/06/10 16:41:29 deraadt Exp $	*/
d358 2
@


1.25
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.24 2003/06/03 14:28:16 ho Exp $	*/
d117 1
a117 1
  /* We inititated of this exchange, check isakmp_sa for other side.  */
@


1.25.2.1
log
@MFC:
Fix by hshoexer@@

Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.25 2003/06/10 16:41:29 deraadt Exp $	*/
a357 2

	free (sa);
@


1.24
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.23 2003/01/09 12:46:45 ho Exp $	*/
d147 1
a147 1
		attrlen += ISAKMP_ATTR_SZ + LEN4;		       	\
@


1.23
log
@Proper id_string for SET/ACK responder, plus attr payload fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.22 2002/08/23 18:01:33 ho Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.23.2.1
log
@MFC:
Fix by hshoexer@@

Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.23 2003/01/09 12:46:45 ho Exp $	*/
a362 2

	free (sa);
@


1.22
log
@Small cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.21 2002/07/16 11:15:53 markus Exp $	*/
d586 1
a586 1
  if (isakmp_sa->initiator)
d1017 1
d1019 1
@


1.22.2.1
log
@Pull patch from current:
Fix by ho@@.
Proper id_string for SET/ACK responder, plus attr payload fixes.

ok millert@@ markus@@ ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.23 2003/01/09 12:46:45 ho Exp $	*/
d586 1
a586 1
  if (isakmp_sa->initiator ^ (ie->cfg_type == ISAKMP_CFG_REQUEST))
a1016 1
      SET_ISAKMP_ATTR_TYPE (*attrp + off, attr->type);
a1017 1
      off += ISAKMP_ATTR_VALUE_OFF + attr->length;
@


1.21
log
@fix $OpenBSD Tag
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.13 2002/06/08 17:35:06 ho Exp $	*/
d159 1
@


1.20
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$openbsd: isakmp_cfg.c,v 1.13 2002/06/08 17:35:06 ho Exp $	*/
@


1.19
log
@Mark attr payload as handled. Also make sure the correct payload
length is returned.
@
text
@d247 1
a247 1
  
d365 1
a365 1
  
d369 1
a369 1
  
d436 1
a436 1
  
d445 1
a445 1
      
d463 1
a463 1
      
d536 1
a536 1
      
d603 1
a603 1
      
d786 1
a786 1
      
d885 1
a885 1
          
d890 1
a890 1
          
d895 1
a895 1
          
d900 1
a900 1
          
@


1.18
log
@Bad me. Make sure it compiles before commit.
@
text
@d411 1
a411 1
	  log_print ("cfg_initiator_recv_ATTR: backup packet type ACK");
d479 1
d776 1
a776 1
  u_int16_t attrlen, off;
d780 1
a780 1
  attrlen = ISAKMP_ATTRIBUTE_SZ;
d827 1
a827 1
      attrlen += ISAKMP_ATTR_SZ + attr->length;
d831 1
a831 1
  *attrp = calloc (1, attrlen);
d835 1
a835 1
		 (unsigned long)attrlen);
@


1.17
log
@CFG_REQUEST
@
text
@d197 1
a197 5
      if (!alist)
	continue;

      for (anode = TAILQ_FIRST (&alist->fields); anode;
	   anove = TAILQ_NEXT (anode, link))
d199 2
a200 1
	  if (strcasecmp (anode->field, "Address") == 0)
d202 40
a241 37
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS);
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS);
	      attrlen += ISAKMP_ATTR_SZ * 2;
	    }
	  else if (strcasecmp (anode->field, "Netmask") == 0)
	    {
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK);
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK);
	      attrlen += ISAKMP_ATTR_SZ * 2;
	    }
	  else if (strcasecmp (anode->field, "Nameserver") == 0)
	    {
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS);
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS);
	      attrlen += ISAKMP_ATTR_SZ * 2;
	    }
	  else if (strcasecmp (anode->field, "WINS-server") == 0)
	    {
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS);
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS);
	      attrlen += ISAKMP_ATTR_SZ * 2;
	    }
	  else if (strcasecmp (anode->field, "DHCP-server") == 0)
	    {
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP);
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP);	
	      attrlen += ISAKMP_ATTR_SZ * 2;
	    }
	  else if (strcasecmp (anode->field, "Lifetime") == 0)
	    {
	      bit_set (attrbits, ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY);
	      attrlen += ISAKMP_ATTR_SZ;
	    }
	  else
	    {
	      log_print ("cfg_initiator_send_ATTR: unknown attribute %.20s "
			 "in section [%s]", anode->field, id_string);
d243 2
a245 2

      conf_free_list (alist);
@


1.16
log
@Style.
@
text
@d98 2
a99 3
 * As "the server", this starts SET/ACK mode
 * As "the client", this starts REQ/REPLY mode
 * XXX A lot can be shared with responder_send_ATTR.
d188 3
a190 1
      /* XXX REQ/REPLY  */
d195 51
d251 7
a257 2
      log_print ("cfg_initiator_send_ATTR: no IKECFG attributes found for %s",
		 id_string);
@


1.15
log
@Tighten the code to work for both SET/ACK and REQ/REPLY modes.
@
text
@d98 1
a98 1
 * As "the server", this starts SET/ACK mode 
d192 1
a192 1
      LOG_DBG ((LOG_NEGOTIATION, 10, 
d227 1
a227 1
   * Use the bitstring built previously to collect the right 
d365 1
a365 1
	} 
d488 1
a488 1
	 * XXX that we act upon (such as setting a netmask), should be 
d876 1
a876 1
			 "got %s data", field, 
@


1.14
log
@Factor out hash operations, some other cleanup.
@
text
@d113 2
d142 2
d190 2
d220 33
a252 16
  if (!cfg_mode || strcmp (cfg_mode, "SET") == 0)
    {
      /*
       * SET/ACK cont. Use the bitstring built previously to collect
       * the right parameters for attrp.
       */
      u_int16_t bit, length;
      u_int32_t life;

      SET_ISAKMP_ATTRIBUTE_TYPE (attrp, ISAKMP_CFG_SET);
      getrandom ((u_int8_t *)&ie->cfg_id, sizeof ie->cfg_id);
      SET_ISAKMP_ATTRIBUTE_ID (attrp, ie->cfg_id);

      off = ISAKMP_ATTRIBUTE_SZ;
      for (bit = 0; bit < CFG_ATTR_BIT_MAX; bit++)
	if (bit_test (attrbits, bit))
d254 19
a272 71
	    attr = attrp + off;
	    
	    /* All the other are similar, this is the odd one.  */
	    if (bit == ISAKMP_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY)
	      {
		life = conf_get_num (id_string, "Lifetime", 1200);
		SET_ISAKMP_ATTR_LENGTH_VALUE (attr, 4);
		encode_32 (attr + ISAKMP_ATTR_VALUE_OFF, life);
		off += ISAKMP_ATTR_SZ + 4;
		continue;
	      }

	    switch (bit)
	      {
	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
		length = 4;
		break;

	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
		length = 16;
		break;

	      default:
		length = 0; /* Silence gcc.  */
	      }

	    switch (bit)
	      {
	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
		field = "Address";
		break;

	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
		field = "Netmask";
		break;

	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
		field = "Nameserver";
		break;

	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
		field = "DHCP-server";
		break;

	      case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
	      case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
		field = "WINS-server";
		break;

	      default:
		field = 0; /* Silence gcc.  */
	      }

	    sa = conf_get_address (id_string, field);

	    SET_ISAKMP_ATTR_TYPE (attr, bit);
	    SET_ISAKMP_ATTR_LENGTH_VALUE (attr, length);
	    memcpy (attr + ISAKMP_ATTR_VALUE_OFF, sockaddr_addrdata (sa),
		    length);
d274 24
a297 1
	    off += length + ISAKMP_ATTR_SZ;
d299 9
a307 6
    }
  else
    {
      /* XXX REQ/REPLY cont.  */
      goto fail; 		   
    }
d330 1
a330 5
#ifdef notyet
  struct payload *p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_ATTRIBUTE]);
#endif
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
d334 1
d337 1
a337 1
  if (exchange->phase == 2)
d341 7
a347 2
  ie->cfg_id = GET_ISAKMP_ATTRIBUTE_ID (attrp->p);
  ie->cfg_type = attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF];
d349 1
a349 1
  switch (ie->cfg_type)
d352 7
d360 6
a384 4

	/* XXX for now, just print what we got.  */
	const char *uk_addr = "<unknown>";

d402 13
a414 3
	/*
	 * XXX REQ/REPLY: effect attributes we've gotten responses on.
	 */
a431 1
  struct exchange *exchange = msg->exchange;
d434 1
a434 1
  struct ipsec_exch *ie = exchange->data;
d440 1
a440 1
  if (exchange->phase == 2)
d467 1
d482 1
a482 1
		    "server %s sends SET attribute %s", addr,
d485 8
a494 2

	attrp->flags |= PL_MARK;
d502 1
a605 1
  struct exchange *exchange = msg->exchange;
d638 2
a639 1
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d725 4
d787 4
@


1.13
log
@a bit more for the responder cases
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.12 2002/06/07 21:59:22 ho Exp $	*/
d73 2
d80 5
a104 1
  struct exchange *exchange = msg->exchange;
d106 1
a106 5
  struct ipsec_sa *isa = isakmp_sa->data;
  struct ipsec_exch *ie = exchange->data;
  struct hash *hash = hash_get (isa->hash);
  struct prf *prf;
  size_t hashsize = hash->hashsize;
d114 1
a114 1
  if (exchange->phase == 2)
d116 1
a116 2
      /* We want a HASH payload to start with.  XXX Share with others?  */
      hashp = malloc (ISAKMP_HASH_SZ + hashsize);
d118 1
a118 11
	{
	  log_error ("cfg_initiator_send_ATTR: malloc (%lu) failed",
		     ISAKMP_HASH_SZ + (unsigned long)hashsize);
	  return -1;
	}
      if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, hashp,
			       ISAKMP_HASH_SZ + hashsize, 1))
	{
	  free (hashp);
	  return -1;
	}
d121 5
a125 2
  /* XXX This is wrong. */
  id_string = ipsec_id_string (isakmp_sa->id_i, isakmp_sa->id_i_len);
a231 1
	    SET_ISAKMP_ATTR_TYPE (attr, bit);
d297 2
d312 4
a315 13
  if (exchange->phase == 2)
    {
      prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a,
		       isa->skeyid_len);
      if (!prf)
	goto fail;
      prf->Init (prf->prfctx);
      prf->Update (prf->prfctx, exchange->message_id,
		   ISAKMP_HDR_MESSAGE_ID_LEN);
      prf->Update (prf->prfctx, attrp, attrlen);
      prf->Final (hashp + ISAKMP_GEN_SZ, prf->prfctx);
      prf_free (prf);
    }
a335 1
  struct payload *hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
a338 1
  struct ipsec_sa *isa = isakmp_sa->data;
a339 3
  struct prf *prf;
  u_int8_t *hash, *comp_hash;
  size_t hash_len;
d344 2
a345 47
    {
      if (!hashp)
	{
	  /* XXX Should another NOTIFY type be used?  */
	  message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
	  log_print ("cfg_initiator_recv_ATTR: phase 2 message missing HASH");
	  return -1;
	}

      hash = hashp->p;
      hash_len = GET_ISAKMP_GEN_LENGTH (hash);
      comp_hash = malloc (hash_len - ISAKMP_GEN_SZ);
      if (!comp_hash)
	{
	  log_error ("cfg_initiator_recv_ATTR: malloc (%lu) failed",
		     (unsigned long)hash_len - ISAKMP_GEN_SZ);
	  return -1;
	}

      /* Verify hash!  */
      prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a,
		       isa->skeyid_len);
      if (!prf)
	{
	  free (comp_hash);
	  return -1;
	}

      prf->Init (prf->prfctx);
      prf->Update (prf->prfctx, exchange->message_id,
                   ISAKMP_HDR_MESSAGE_ID_LEN);
      prf->Update (prf->prfctx, hash + hash_len,
                   msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
      prf->Final (comp_hash, prf->prfctx);
      prf_free (prf);
      if (memcmp (hash + ISAKMP_GEN_SZ, comp_hash, hash_len - ISAKMP_GEN_SZ)
          != 0)
        {
          message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
          free (comp_hash);
          return -1;
        }
      free (comp_hash);

      /* Mark the HASH as handled.  */
      hashp->flags |= PL_MARK;
    }
d348 1
d350 1
a350 1
  switch (attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF])
d368 1
a368 1
  switch (attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF])
a416 1
  struct payload *hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
a418 1
  struct ipsec_sa *isa = isakmp_sa->data;
a420 3
  struct prf *prf;
  u_int8_t *hash, *comp_hash;
  size_t hash_len;
d424 2
a425 46
    {
      if (!hashp)
	{
	  /* XXX Should another NOTIFY type be used?  */
	  message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
	  log_print ("cfg_responder_recv_ATTR: phase 2 message missing HASH");
	  return -1;
	}

      hash = hashp->p;
      hash_len = GET_ISAKMP_GEN_LENGTH (hash);
      comp_hash = malloc (hash_len - ISAKMP_GEN_SZ);
      if (!comp_hash)
	{
	  log_error ("cfg_responder_recv_ATTR: malloc (%lu) failed",
		     (unsigned long)hash_len - ISAKMP_GEN_SZ);
	  return -1;
	}

      /* Verify hash!  */
      prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a,
		       isa->skeyid_len);
      if (!prf)
	{
	  free (comp_hash);
	  return -1;
	}
      prf->Init (prf->prfctx);
      prf->Update (prf->prfctx, exchange->message_id,
		   ISAKMP_HDR_MESSAGE_ID_LEN);
      prf->Update (prf->prfctx, hash + hash_len,
		   msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
      prf->Final (comp_hash, prf->prfctx);
      prf_free (prf);
      if (memcmp (hash + ISAKMP_GEN_SZ, comp_hash, hash_len - ISAKMP_GEN_SZ)
	  != 0)
	{
	  message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
	  free (comp_hash);
	  return -1;
	}
      free (comp_hash);

      /* Mark the HASH as handled.  */
      hashp->flags |= PL_MARK;
    }
d428 1
d430 1
a430 1
  switch (attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF])
d439 1
a439 2
		 "unexpected configuration message type %d",
		 attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF]);
d445 1
a445 2
		 - ISAKMP_TRANSFORM_SA_ATTRS_OFF, cfg_decode_attribute,
		 ie);
d447 1
a447 1
  switch (attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF])
d457 1
a457 1
	msg->transport->vtbl->get_src (isakmp_sa->transport, &sa);
d469 2
a483 1
 * XXX A lot can be shared with initiator_send_ATTR.
d488 1
a488 2
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
d490 48
a537 1
  struct ipsec_sa *isa = isakmp_sa->data;
d539 44
d584 60
a643 3
  size_t hashsize = hash->hashsize;
  u_int8_t *hashp = 0, *attrp;
  size_t attrlen, off;
a644 4
  struct sockaddr *sa;
  u_int32_t value;
  char *id_string, *field;
  sa_family_t family;
d646 4
a649 6
  /*
   * XXX I can only assume it is the client who was the initiator
   * in phase 1, but I have not thought it through thoroughly.
   */
  id_string = ipsec_id_string (isakmp_sa->id_i, isakmp_sa->id_i_len);
  if (!id_string)
d651 3
a653 2
      log_print ("cfg_responder_send_ATTR: cannot parse client's ID");
      goto fail;
d656 10
a665 1
  if (exchange->phase == 2)
d667 2
a668 3
      /* We want a HASH payload to start with.  XXX Share with others?  */
      hashp = malloc (ISAKMP_HASH_SZ + hashsize);
      if (!hashp)
d670 4
a673 9
	  log_error ("cfg_responder_send_ATTR: malloc (%lu) failed",
		     ISAKMP_HASH_SZ + (unsigned long)hashsize);
	  goto fail;
	}
      if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, hashp,
			       ISAKMP_HASH_SZ + hashsize, 1))
	{
	  free (hashp);
	  goto fail;
d675 1
d677 18
d696 1
a696 1
  /* Compute reply attribute payload length.  */
d698 1
a698 1
  for (attr = LIST_FIRST (&ie->attrs); attr; attr = LIST_NEXT (attr, link))
d743 3
a745 2
  attrp = calloc (1, attrlen);
  if (!attrp)
d747 1
a747 1
      log_error ("cfg_responder_send_ATTR: calloc (1, %lu) failed",
d749 1
a749 7
      goto fail;
    }

  if (message_add_payload (msg, ISAKMP_PAYLOAD_ATTRIBUTE, attrp, attrlen, 1))
    {
      free (attrp);
      goto fail;
d752 2
a753 2
  SET_ISAKMP_ATTRIBUTE_TYPE (attrp, ISAKMP_CFG_REPLY); /* XXX or ACK */
  SET_ISAKMP_ATTRIBUTE_ID (attrp, ie->cfg_id);
d756 1
a756 2
  for (attr = LIST_FIRST (&ie->attrs); attr;
       off += ISAKMP_ATTR_SZ + attr->length, attr = LIST_NEXT (attr, link))
a757 1
      SET_ISAKMP_ATTR_TYPE (attrp + off, attr->type);
d759 23
a781 23
	{
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
	  family = AF_INET;
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
	  family = AF_INET6;
	  break;

	default:
	  family = 0;
	  break;
	}
d784 30
a813 5
	{
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	  field = "Address";
	  break;
d815 3
a817 24
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_SUBNET:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
	  field = "Network"; /* XXX or just "Address" */
	  break;
	  
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
	  field = "Netmask";
	  break;
	  
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_DHCP:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
	  field = "DHCP-server";
	  break;
	  
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
	  field = "Nameserver";
	  break;
	  
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
	  field = "WINS-server";
	  break;
a818 4
	default:
	  field = 0;
	}
	    
d857 1
a857 1
	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF, sockaddr_addrdata (sa),
d880 1
a880 1
	      memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF + attr->length,
d904 1
a904 1
	      *(attrp + off + ISAKMP_ATTR_VALUE_OFF + 16) = (u_int8_t)prefix;
d911 1
a911 1
	  encode_32 (attrp + off + ISAKMP_ATTR_VALUE_OFF, value);
a923 39
      SET_ISAKMP_ATTR_LENGTH_VALUE (attrp + off, attr->length);
    }

  if (exchange->phase == 2)
    {
      prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a,
		       isa->skeyid_len);
      if (!prf)
	{
	  /* XXX Log?  */
	  goto fail;
	}
      prf->Init (prf->prfctx);
      prf->Update (prf->prfctx, exchange->message_id,
		   ISAKMP_HDR_MESSAGE_ID_LEN);
      prf->Update (prf->prfctx, attrp, attrlen);
      prf->Final (hashp + ISAKMP_GEN_SZ, prf->prfctx);
      prf_free (prf);
    }

  return 0;

 fail:
  if (id_string)
    free (id_string);
  return -1;
}

/*
 * Decode the attribute of type TYPE with a LEN length value pointed to by
 * VALUE.  VIE is a pointer to the IPsec exchange context holding the
 * attributes indexed by type for easy retrieval.
 */
static int
cfg_decode_attribute (u_int16_t type, u_int8_t *value, u_int16_t len,
		      void *vie)
{
  struct ipsec_exch *ie = vie;
  struct isakmp_cfg_attr *attr;
d925 1
a925 8
  if (type >= ISAKMP_CFG_ATTR_PRIVATE_MIN
      && type <= ISAKMP_CFG_ATTR_PRIVATE_MAX)
    return 0;
  if (type == 0 || type >= ISAKMP_CFG_ATTR_FUTURE_MIN)
    {
      LOG_DBG ((LOG_NEGOTIATION, 30,
		"cfg_decode_attribute: invalid attr type %u", type));
      return -1;
a927 22
  attr = calloc (1, sizeof *attr);
  if (!attr)
    {
      log_error ("cfg_decode_attribute: calloc (1, %lu) failed",
		 (unsigned long)sizeof *attr);
      return -1;
    }
  attr->type = type;
  attr->length = len;
  if (len)
    {
      attr->value = malloc (len);
      if (!attr->value)
	{
	  log_error ("cfg_decode_attribute: malloc (%d) failed", len);
	  free (attr);
	  /* Should we also deallocate all other values?  */
	  return -1;
	}
      memcpy (attr->value, value, len);
    }
  LIST_INSERT_HEAD (&ie->attrs, attr, link);
@


1.12
log
@Avoid some gcc3 warnings. From David Krause <openbsd@@davidkrause.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.11 2002/06/07 20:26:22 ho Exp $	*/
d420 1
a420 2
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      log_print ("cfg_responder_recv_ATTR: "
d423 1
d431 1
a431 1
  if (attrp->p[ISAKMP_ATTRIBUTE_TYPE_OFF] == ISAKMP_CFG_ACK)
d433 3
a435 2
      /* SET / ACKNOWLEDGE */
      const char *uk_addr = "<unknown>";
d437 6
a442 3
      msg->transport->vtbl->get_src (isakmp_sa->transport, &sa);
      if (sockaddr2text (sa, &addr, 0) < 0)
	addr = (char *)uk_addr;
d444 18
a461 4
      for (attr = LIST_FIRST (&ie->attrs); attr; attr = LIST_NEXT (attr, link))
	LOG_DBG ((LOG_NEGOTIATION, 50, "cfg_responder_recv_ATTR: "
		  "client %s ACKs attribute %s", addr,
		  constant_name (isakmp_cfg_attr_cst, attr->type)));
d463 2
a464 8
      if (addr != uk_addr)
	free (addr);
    }
  else /* ISAKMP_CFG_REPLY */
    {
      /*
       * XXX REQ/REPLY: effect attributes we've gotten responses on.
       */
d484 2
d489 1
a543 7
      attribute_map (attrp->p + ISAKMP_ATTRIBUTE_ATTRS_OFF,
		     GET_ISAKMP_GEN_LENGTH (attrp->p)
		     - ISAKMP_TRANSFORM_SA_ATTRS_OFF, cfg_decode_attribute,
		     ie);
      break;

#ifdef notyet
a545 1
#endif
d555 34
d705 1
a705 1
  SET_ISAKMP_ATTRIBUTE_TYPE (attrp, ISAKMP_CFG_REPLY);
@


1.11
log
@Also allocate space for the attribute header.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.10 2002/06/07 19:53:19 ho Exp $	*/
d836 1
@


1.10
log
@Start for support of IKECFG in SET/ACK mode. Server side only so far.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.9 2002/06/06 19:03:10 ho Exp $	*/
d205 1
@


1.9
log
@Answer requests for netmasks, subnets, and dhcp-servers as well. Add
debug and warning messages for missing/bad values. Rewrite it a bit.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.8 2002/06/01 07:44:21 deraadt Exp $	*/
d5 1
d43 1
d58 1
d72 5
a76 5
static int decode_attribute (u_int16_t, u_int8_t *, u_int16_t, void *);
static int initiator_send_ATTR (struct message *);
static int initiator_recv_ATTR (struct message *);
static int responder_recv_ATTR (struct message *);
static int responder_send_ATTR (struct message *);
d78 1
d80 2
a81 2
  initiator_send_ATTR,
  initiator_recv_ATTR
d84 1
d86 2
a87 2
  responder_recv_ATTR,
  responder_send_ATTR
d90 5
a94 1
/* XXX A lot can be shared with responder_send_ATTR.  */
d96 1
a96 1
initiator_send_ATTR (struct message *msg)
d101 1
d105 6
a110 2
  u_int8_t *hashp = 0, *attrp;
  size_t attrlen;
d118 1
a118 1
	  log_error ("responder_send_ATTR: malloc (%lu) failed",
d130 9
a138 2
#ifndef to_be_removed
  attrp = 0;
d140 40
d181 1
d183 133
d321 1
a321 1
	return -1;
d330 5
d337 4
d342 1
a342 1
initiator_recv_ATTR (struct message *msg)
d344 3
a346 2
  struct exchange *exchange = msg->exchange;
#if 0
d350 10
d367 1
a367 1
	  log_print ("initiator_recv_ATTR: phase 2 message missing HASH");
d371 34
a404 1
      /* XXX Verify hash!  */
d410 44
d457 4
d462 1
a462 1
responder_recv_ATTR (struct message *msg)
d481 1
a481 1
	  log_print ("responder_recv_ATTR: phase 2 message missing HASH");
d490 1
a490 1
	  log_error ("responder_recv_ATTR: malloc (%lu) failed",
d530 2
a531 1
		     - ISAKMP_TRANSFORM_SA_ATTRS_OFF, decode_attribute, ie);
d541 1
a541 1
      log_print ("responder_recv_ATTR: "
d550 5
a554 1
/* XXX A lot can be shared with initiator_send_ATTR.  */
d556 1
a556 1
responder_send_ATTR (struct message *msg)
d580 1
a580 1
      log_print ("responder_send_ATTR: cannot parse client's ID");
d590 1
a590 1
	  log_error ("responder_send_ATTR: malloc (%lu) failed",
d652 1
a652 1
      log_error ("responder_send_ATTR: calloc (1, %lu) failed",
d705 1
a705 1
	  field = "Address"; /* XXX or "Network" */
d747 1
a747 1
	      LOG_DBG ((LOG_NEGOTIATION, 10, "responder_send_ATTR: "
d755 1
a755 1
	      log_print ("responder_send_ATTR: attribute %s - expected %s "
d780 1
a780 1
		  LOG_DBG ((LOG_NEGOTIATION, 10, "responder_send_ATTR: "
d787 1
a787 1
		  log_print ("responder_send_ATTR: attribute Netmask - "
d804 1
a804 1
		  log_print ("responder_send_ATTR: "
d811 1
a811 1
		  log_print ("responder_send_ATTR: attribute Prefix - "
d870 2
a871 1
decode_attribute (u_int16_t type, u_int8_t *value, u_int16_t len, void *vie)
d881 2
a882 2
      LOG_DBG ((LOG_NEGOTIATION, 30, "decode_attribute: invalid attr type %u",
		type));
d889 1
a889 1
      log_error ("decode_attribute: calloc (1, %lu) failed",
d900 1
a900 1
	  log_error ("decode_attribute: malloc (%d) failed", len);
@


1.8
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.7 2001/10/26 12:03:07 ho Exp $	*/
d269 2
a270 1
  char *id_string;
d352 1
a352 1
	(unsigned long)attrlen);
d373 8
d382 7
a388 17
	  sa = conf_get_address (id_string, "Address");
	  if (!sa)
	    {
	      /* XXX What to do?  */
	      attr->length = 0;
	      break;
	    }
	  if ((attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS
	       && sa->sa_family != AF_INET)
	      || (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS
		  && sa->sa_family != AF_INET6))
	    {
	      /* XXX What to do?  */
	      free (sa);
	      attr->length = 0;
	      break;
	    }
d390 2
a391 3
	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF, sockaddr_addrdata (sa),
		  attr->length);
	  free (sa);
d393 1
d395 5
a399 2
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NETMASK:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
d404 6
d411 1
a411 1

d414 11
d427 12
d441 3
a443 1
	  sa = conf_get_address (id_string, "Nameserver");
d446 2
a447 1
	      /* XXX What to do?  */
d451 2
a452 4
	  if ((attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_DNS
	       && sa->sa_family != AF_INET)
	      || (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS
		  && sa->sa_family != AF_INET6))
d454 5
a458 1
	      /* XXX What to do?  */
a459 1
	      free (sa);
d463 6
a471 1
	  break;
d473 2
a474 4
	case ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS:
	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
	  sa = conf_get_address (id_string, "WINS-server");
	  if (!sa)
d476 20
a495 3
	      /* XXX What to do?  */
	      attr->length = 0;
	      break;
d497 1
a497 4
	  if ((attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_NBNS
	       && sa->sa_family != AF_INET)
	      || (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS
		  && sa->sa_family != AF_INET6))
d499 19
a517 4
	      /* XXX What to do?  */
	      attr->length = 0;
	      free (sa);
	      break;
a518 4

	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF, sockaddr_addrdata (sa),
		  attr->length);
	  free (sa);
d578 5
a582 2
    /* XXX Log!  */
    return -1;
d588 1
a588 1
	(unsigned long)sizeof *attr);
@


1.7
log
@Just rename sockaddr_data/len functions to sockaddr_addrdata/addrlen.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.6 2001/08/27 03:10:55 deraadt Exp $	*/
d104 2
a105 2
	  log_error ("responder_send_ATTR: malloc (%d) failed",
		     ISAKMP_HASH_SZ + hashsize);
d194 2
a195 2
	  log_error ("responder_recv_ATTR: malloc (%d) failed",
		     hash_len - ISAKMP_GEN_SZ);
d288 2
a289 2
	  log_error ("responder_send_ATTR: malloc (%d) failed",
		     ISAKMP_HASH_SZ + hashsize);
d350 2
a351 1
      log_error ("responder_send_ATTR: calloc (1, %d) failed", attrlen);
d521 2
a522 1
      log_error ("decode_attribute: calloc (1, %d) failed", sizeof *attr);
@


1.6
log
@un-bork
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.5 2001/08/23 19:44:28 niklas Exp $	*/
d390 1
a390 1
	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF, sockaddr_data (sa),
d427 1
a427 1
	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF, sockaddr_data (sa),
d452 1
a452 1
	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF, sockaddr_data (sa),
@


1.5
log
@Use ipsec_id_string as the section name for IKE mode config.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.4 2001/07/25 15:18:14 markus Exp $	*/
d37 1
a38 1
#include <sys/types.h>
d41 1
@


1.4
log
@CFG mode changes: send attributes of size 0 if attribute is not available
fix several if statements, ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.3 2001/07/04 07:41:19 niklas Exp $	*/
d268 12
d289 1
a289 1
	  return -1;
d295 1
a295 1
	  return -1;
d350 1
a350 1
      return -1;
d356 1
a356 1
      return -1;
d371 1
a371 2
	  /* XXX The section should be tagged off the peer somehow.  */
	  sa = conf_get_address ("ISAKMP-cfg", "Address");
d408 1
a408 2
	  /* XXX The section should be tagged off the peer somehow.  */
	  sa = conf_get_address ("ISAKMP-cfg", "Nameserver");
d433 1
a433 2
	  /* XXX The section should be tagged off the peer somehow.  */
	  sa = conf_get_address ("ISAKMP-cfg", "WINS-server");
d457 1
a457 2
	  /* XXX The section should be tagged off the peer somehow.  */
	  value = conf_get_num ("ISAKMP-cfg", "Lifetime", 1200);
d480 1
a480 1
	  return -1;
d491 5
@


1.3
log
@Better IPv6/IPv4 integration
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.2 2001/07/04 07:29:10 niklas Exp $	*/
d334 1
a334 1
  attrp = malloc (attrlen);
d337 1
a337 1
      log_error ("responder_send_ATTR: malloc (%d) failed", attrlen);
a354 1
      SET_ISAKMP_ATTR_LENGTH_VALUE (attrp + off, attr->length);
d362 5
a366 2
	    /* XXX What to do?  */
	    continue;
d371 6
a376 3
	    /* XXX What to do?  */
	    free (sa);
	    continue;
d400 6
a405 3
	    /* XXX What to do?  */
	    continue;
	  if ((attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS
d407 1
a407 1
	      || (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS
d409 6
a414 3
	    /* XXX What to do?  */
	    free (sa);
	  continue;
d426 6
a431 3
	    /* XXX What to do?  */
	    continue;
	  if ((attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP4_ADDRESS
d433 1
a433 1
	      || (attr->type == ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS
d435 6
a440 3
	    /* XXX What to do?  */
	    free (sa);
	  continue;
d462 1
@


1.2
log
@IPv6
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmp_cfg.c,v 1.1 2001/07/01 20:43:39 niklas Exp $	*/
d359 1
d365 4
a368 1
	  if (sa->sa_family != AF_INET)
d373 2
a374 2
	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF,
		  &((struct sockaddr_in *)sa)->sin_addr, attr->length);
d379 1
d383 1
d387 1
d391 1
d397 4
a400 1
	  if (sa->sa_family != AF_INET)
d403 1
a403 1
	    continue;
d405 2
a406 2
	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF,
		  &((struct sockaddr_in *)sa)->sin_addr, attr->length);
d411 1
d417 4
a420 1
	  if (sa->sa_family != AF_INET)
d423 1
a423 1
	    continue;
d425 2
a426 2
	  memcpy (attrp + off + ISAKMP_ATTR_VALUE_OFF,
		  &((struct sockaddr_in *)sa)->sin_addr, attr->length);
a440 18
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NETMASK:
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_SUBNET:
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DHCP:
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_DNS:
	  break;

	case ISAKMP_CFG_ATTR_INTERNAL_IP6_NBNS:
@


1.1
log
@ISAKMP configuration, a.k.a IKECFG or "mode-config", protocol implementation.
Disabled, has no configuration mechanism yet.  This will be used for roaming
users, who are going to get parameters like IP-address and nameserver from its
peer, very much like DHCP, but securily inside an ISAKMP connection and still
in time before negotiation of IPsec connections.  You may see stylistic fixes
in this commit too.  Add some not yet used Makefile magic to deal with DNSSEC-
enabled OpenSSL too.  The IKECFG code work was sponsered by Gatespace Inc.
Thank you!  Configuration will come very soon, btw.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d312 1
a312 2
	  /* XXX 2 * 6 more when IPv6 is supported.  */
	  attr->length = 2 * 9;
a314 1
#if 0
a325 1
#endif
a427 1
#if 0
a444 1
#endif
@

