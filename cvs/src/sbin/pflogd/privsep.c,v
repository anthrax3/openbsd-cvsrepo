head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.2
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8;
locks; strict;
comment	@ * @;


1.30
date	2017.09.09.13.02.52;	author brynet;	state Exp;
branches;
next	1.29;
commitid	cwr6FpLV7RETuOBH;

1.29
date	2017.09.06.12.43.16;	author brynet;	state Exp;
branches;
next	1.28;
commitid	n6m5he50NEcXWLLP;

1.28
date	2017.09.05.15.41.25;	author brynet;	state Exp;
branches;
next	1.27;
commitid	UGtgLdiBxweIZpQK;

1.27
date	2017.08.12.16.31.09;	author florian;	state Exp;
branches;
next	1.26;
commitid	KdkubmhDljuvieOJ;

1.26
date	2017.07.04.23.13.09;	author mestre;	state Exp;
branches;
next	1.25;
commitid	daMhZDx1SRxBrReU;

1.25
date	2017.06.12.23.37.44;	author mestre;	state Exp;
branches;
next	1.24;
commitid	bPLMjoAkz9RLbQbA;

1.24
date	2017.01.23.04.25.05;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	NeJrtXDNhZqhGXfa;

1.23
date	2017.01.23.03.47.37;	author benno;	state Exp;
branches;
next	1.22;
commitid	909w8isNzfS1pH2h;

1.22
date	2016.01.16.03.17.48;	author canacar;	state Exp;
branches;
next	1.21;
commitid	2sPyHwdNzYQaXlAm;

1.21
date	2015.10.10.22.36.06;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	gjxLpEqCRrEu4Dmr;

1.20
date	2015.04.28.05.54.31;	author mlarkin;	state Exp;
branches;
next	1.19;
commitid	kFaSqsEDHBJjdg6X;

1.19
date	2014.06.26.17.56.09;	author tobias;	state Exp;
branches;
next	1.18;
commitid	BmVpKomov69NlBVS;

1.18
date	2013.09.13.08.49.17;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.25.20.55.04;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.06.10.45.56;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.15.16.38.04;	author canacar;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.22.09.21.02;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.14.19.07.03;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.08.14.32.47;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.12.26.06;	author avsm;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.03.10.21.18;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.14.19.17.05;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.13.19.01.57;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.18.14.21.52;	author canacar;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.15.20.10.43;	author canacar;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.22.19.53.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.22.19.35.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.22.19.21.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.22.18.51.55;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Rework pflogd(8)'s fork+exec model; re-exec the unpriv child, not the
privileged parent.

Based on feedback from deraadt@@ and bluhm@@ (worked on syslogd).

ok deraadt@@
@
text
@/*	$OpenBSD: privsep.c,v 1.29 2017/09/06 12:43:16 brynet Exp $	*/

/*
 * Copyright (c) 2003 Can Erkin Acar
 * Copyright (c) 2003 Anil Madhavapeddy <anil@@recoil.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/bpf.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pcap.h>
#include <pcap-int.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include "pflogd.h"

enum cmd_types {
	PRIV_INIT_PCAP,		/* init pcap fdpass bpf */
	PRIV_SET_SNAPLEN,	/* set the snaplength */
	PRIV_MOVE_LOG,		/* move logfile away */
	PRIV_OPEN_LOG,		/* open logfile for appending */
};

static int priv_fd = -1;
static volatile pid_t child_pid = -1;

static void sig_pass_to_chld(int);
static int  may_read(int, void *, size_t);
static void must_read(int, void *, size_t);
static void must_write(int, void *, size_t);
static int  set_snaplen(int snap);
static int  move_log(const char *name);

extern char *filename;
extern char *interface;
extern char errbuf[PCAP_ERRBUF_SIZE];
extern pcap_t *hpcap;

/* based on syslogd privsep */
void
priv_init(int Pflag, int argc, char *argv[])
{
	int i, fd = -1, bpfd = -1, nargc, socks[2], cmd;
	int snaplen, ret, olderrno;
	struct passwd *pw;
	char **nargv;
	unsigned int buflen;

	pw = getpwnam("_pflogd");
	if (pw == NULL)
		errx(1, "unknown user _pflogd");
	endpwent();

	if (Pflag) {
		gid_t gidset[1];

		/* Child - drop privileges and return */
		if (chroot(pw->pw_dir) != 0)
			err(1, "unable to chroot");
		if (chdir("/") != 0)
			err(1, "unable to chdir");

		gidset[0] = pw->pw_gid;
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
			err(1, "setresgid() failed");
		if (setgroups(1, gidset) == -1)
			err(1, "setgroups() failed");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
			err(1, "setresuid() failed");
		priv_fd = 3;
		return;
	}

	/* Create sockets */
	if (socketpair(AF_LOCAL, SOCK_STREAM, PF_UNSPEC, socks) == -1)
		err(1, "socketpair() failed");

	child_pid = fork();
	if (child_pid < 0)
		err(1, "fork() failed");

	if (!child_pid) {
		close(socks[0]);
		if (dup2(socks[1], 3) == -1)
			err(1, "dup2 unpriv sock failed");
		close(socks[1]);
		if ((nargv = reallocarray(NULL, argc + 2,
		    sizeof(char *))) == NULL)
			err(1, "alloc unpriv argv failed");
		nargc = 0;
		nargv[nargc++] = argv[0];
		nargv[nargc++] = "-P";
		for (i = 1; i < argc; i++)
			nargv[nargc++] = argv[i];
		nargv[nargc] = NULL;
		execvp(nargv[0], nargv);
		err(1, "exec unpriv '%s' failed", nargv[0]);
	}
	close(socks[1]);

	/* Father */
	/* Pass ALRM/TERM/HUP/INT/QUIT through to child */
	signal(SIGALRM, sig_pass_to_chld);
	signal(SIGTERM, sig_pass_to_chld);
	signal(SIGHUP,  sig_pass_to_chld);
	signal(SIGINT,  sig_pass_to_chld);
	signal(SIGQUIT, sig_pass_to_chld);

	setproctitle("[priv]");

#if 0
	/* This needs to do bpf ioctl */
BROKEN	if (pledge("stdio rpath wpath cpath sendfd proc bpf", NULL) == -1)
		err(1, "pledge");
#endif

	while (1) {
		if (may_read(socks[0], &cmd, sizeof(int)))
			break;
		switch (cmd) {
		case PRIV_INIT_PCAP:
			logmsg(LOG_DEBUG,
			    "[priv]: msg PRIV_INIT_PCAP received");
			/* initialize pcap */
			if (hpcap != NULL || init_pcap()) {
				logmsg(LOG_ERR, "[priv]: Exiting, init failed");
				_exit(1);
			}
			buflen = hpcap->bufsize; /* BIOCGBLEN for unpriv proc */
			must_write(socks[0], &buflen, sizeof(unsigned int));
			fd = pcap_fileno(hpcap);
			send_fd(socks[0], fd);
			if (fd < 0) {
				logmsg(LOG_ERR, "[priv]: Exiting, init failed");
				_exit(1);
			}
			break;

		case PRIV_SET_SNAPLEN:
			logmsg(LOG_DEBUG,
			    "[priv]: msg PRIV_SET_SNAPLENGTH received");
			must_read(socks[0], &snaplen, sizeof(int));

			ret = set_snaplen(snaplen);
			if (ret) {
				logmsg(LOG_NOTICE,
				   "[priv]: set_snaplen failed for snaplen %d",
				   snaplen);
			}

			must_write(socks[0], &ret, sizeof(int));
			break;

		case PRIV_OPEN_LOG:
			logmsg(LOG_DEBUG,
			    "[priv]: msg PRIV_OPEN_LOG received");
			/* create or append logs but do not follow symlinks */
			if (bpfd != -1) {
				close(bpfd);
				bpfd = -1;
			}
			bpfd = open(filename,
			    O_RDWR|O_CREAT|O_APPEND|O_NONBLOCK|O_NOFOLLOW,
			    0600);
			olderrno = errno;
			send_fd(socks[0], bpfd);
			if (bpfd < 0)
				logmsg(LOG_NOTICE,
				    "[priv]: failed to open %s: %s",
				    filename, strerror(olderrno));
			break;

		case PRIV_MOVE_LOG:
			logmsg(LOG_DEBUG,
			    "[priv]: msg PRIV_MOVE_LOG received");
			ret = move_log(filename);
			must_write(socks[0], &ret, sizeof(int));
			break;

		default:
			logmsg(LOG_ERR, "[priv]: unknown command %d", cmd);
			_exit(1);
			/* NOTREACHED */
		}
	}

	exit(1);
}

/* this is called from parent */
static int
set_snaplen(int snap)
{
	if (hpcap == NULL)
		return (1);

	hpcap->snapshot = snap;
	set_pcap_filter();

	return 0;
}

static int
move_log(const char *name)
{
	char ren[PATH_MAX];
	int len;

	for (;;) {
		int fd;

		len = snprintf(ren, sizeof(ren), "%s.bad.XXXXXXXX", name);
		if (len >= sizeof(ren)) {
			logmsg(LOG_ERR, "[priv] new name too long");
			return (1);
		}

		/* lock destination */
		fd = mkstemp(ren);
		if (fd >= 0) {
			close(fd);
			break;
		}
		if (errno != EINTR) {
			logmsg(LOG_ERR, "[priv] failed to create new name: %s",
			    strerror(errno));
			return (1);			
		}
	}

	if (rename(name, ren)) {
		logmsg(LOG_ERR, "[priv] failed to rename %s to %s: %s",
		    name, ren, strerror(errno));
		unlink(ren);
		return (1);
	}

	logmsg(LOG_NOTICE,
	       "[priv]: log file %s moved to %s", name, ren);

	return (0);
}


/* receive bpf fd from privileged process using fdpass and init pcap */
int
priv_init_pcap(int snaplen)
{
	int cmd, fd;
	unsigned int buflen;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_INIT_PCAP;

	must_write(priv_fd, &cmd, sizeof(int));
	must_read(priv_fd, &buflen, sizeof(unsigned int));
	fd = receive_fd(priv_fd);
	if (fd < 0)
		return (-1);

	/* XXX temporary until pcap_open_live_fd API */
	hpcap = pcap_create(interface, errbuf);
	if (hpcap == NULL)
		return (-1);

	/* XXX copies from pcap_open_live/pcap_activate */
	hpcap->fd = fd;
	pcap_set_snaplen(hpcap, snaplen);
	pcap_set_promisc(hpcap, 1);
	pcap_set_timeout(hpcap, PCAP_TO_MS);
	hpcap->oldstyle = 1;
	hpcap->linktype = DLT_PFLOG;
	hpcap->bufsize = buflen; /* XXX bpf BIOCGBLEN */
	hpcap->buffer = malloc(hpcap->bufsize);
	if (hpcap->buffer == NULL)
		return (-1);
	hpcap->activated = 1;

	return (0);
}

/*
 * send the snaplength to privileged process
 */
int
priv_set_snaplen(int snaplen)
{
	int cmd, ret;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_SET_SNAPLEN;

	must_write(priv_fd, &cmd, sizeof(int));
	must_write(priv_fd, &snaplen, sizeof(int));

	must_read(priv_fd, &ret, sizeof(int));

	/* also set hpcap->snapshot in child */
	if (ret == 0)
		hpcap->snapshot = snaplen;

	return (ret);
}

/* Open log-file */
int
priv_open_log(void)
{
	int cmd, fd;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_OPEN_LOG;
	must_write(priv_fd, &cmd, sizeof(int));
	fd = receive_fd(priv_fd);

	return (fd);
}

/* Move-away and reopen log-file */
int
priv_move_log(void)
{
	int cmd, ret;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_MOVE_LOG;
	must_write(priv_fd, &cmd, sizeof(int));
	must_read(priv_fd, &ret, sizeof(int));

	return (ret);
}

/* If priv parent gets a TERM or HUP, pass it through to child instead */
static void
sig_pass_to_chld(int sig)
{
	int oerrno = errno;

	if (child_pid != -1)
		kill(child_pid, sig);
	errno = oerrno;
}

/* Read all data or return 1 for error.  */
static int
may_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			return (1);
		default:
			pos += res;
		}
	}
	return (0);
}

/* Read data with the assertion that it all must come through, or
 * else abort the process.  Based on atomicio() from openssh. */
static void
must_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			_exit(0);
		default:
			pos += res;
		}
	}
}

/* Write data with the assertion that it all has to be written, or
 * else abort the process.  Based on atomicio() from openssh. */
static void
must_write(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = write(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			_exit(0);
		default:
			pos += res;
		}
	}
}
@


1.29
log
@pflogd(8) currently spams the console on shutdown if syslogd(8) wins the
race to die, so just stop logging pflogd exits.

This logging probably comes from the fact that pflogd was largely based
on syslogd.

Removes the annoying "pflogd[23954]: Exiting" messages pointed out by
deraadt@@

Also cleanup some missed SIGCHLD handling code that is no longer needed.

"LGTM" mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.28 2017/09/05 15:41:25 brynet Exp $	*/
d66 1
a66 1
priv_init(int argc, char *argv[])
d68 2
a69 1
	int i, nargc, socks[2];
d71 2
a72 5
	char childnum[11], **privargv;

	/* Create sockets */
	if (socketpair(AF_LOCAL, SOCK_STREAM, PF_UNSPEC, socks) == -1)
		err(1, "socketpair() failed");
d79 1
a79 5
	child_pid = fork();
	if (child_pid < 0)
		err(1, "fork() failed");

	if (!child_pid) {
d95 1
a95 2
		close(socks[0]);
		priv_fd = socks[1];
a97 1
	close(socks[1]);
d99 3
a101 17
	if (dup2(socks[0], 3) == -1)
		err(1, "dup2 priv sock failed");
	closefrom(4);

	snprintf(childnum, sizeof(childnum), "%d", child_pid);
	if ((privargv = reallocarray(NULL, argc + 3, sizeof(char *))) == NULL)
		err(1, "alloc priv argv failed");
	nargc = 0;
	privargv[nargc++] = argv[0];
	privargv[nargc++] = "-P";
	privargv[nargc++] = childnum;
	for (i = 1; i < argc; i++)
		privargv[nargc++] = argv[i];
	privargv[nargc] = NULL;
	execvp(privargv[0], privargv);
	err(1, "exec priv '%s' failed", privargv[0]);
}
d103 3
a105 6
__dead void
priv_exec(int child, int argc, char *argv[])
{
	int i, fd = -1, bpfd = -1, sock, cmd;
	int snaplen, ret, olderrno;
	unsigned int buflen;
d107 18
a124 10
	if (argc <= 2 || strcmp("-P", argv[1]) != 0)
		errx(1, "exec without priv");

	sock = 3;
	closefrom(4);

	child_pid = child;

	for (i = 1; i < _NSIG; i++)
		signal(i, SIG_DFL);
d127 1
a127 1
	/* Pass ALRM/TERM/HUP/INT/QUIT through to child, and accept CHLD */
d143 1
a143 1
		if (may_read(sock, &cmd, sizeof(int)))
d155 1
a155 1
			must_write(sock, &buflen, sizeof(unsigned int));
d157 1
a157 1
			send_fd(sock, fd);
d167 1
a167 1
			must_read(sock, &snaplen, sizeof(int));
d176 1
a176 1
			must_write(sock, &ret, sizeof(int));
d191 1
a191 1
			send_fd(sock, bpfd);
d202 1
a202 1
			must_write(sock, &ret, sizeof(int));
@


1.28
log
@fork+exec model for pflogd(8); move pcap init to the re-exec'd privsep
parent and use 'legit' fdpassing primitives to send the bpf fd to the
unprivileged child process.

Also reduces the pledge(2) promises in the unpriv child to just
   "stdio recvfd"

with help from deraadt, pcap feedback from canacar

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.27 2017/08/12 16:31:09 florian Exp $	*/
a51 2
volatile sig_atomic_t gotsig_chld = 0;

a52 1
static void sig_chld(int);
a149 1
	signal(SIGCHLD, sig_chld);
d159 1
a159 1
	while (!gotsig_chld) {
a391 7
}

/* if parent gets a SIGCHLD, it will exit */
static void
sig_chld(int sig)
{
	gotsig_chld = 1;
@


1.27
log
@Make not yet implemented pledges more visible in grep output.
input benno, deraadt, tedu
also standardize on #if 0 since it makes tedu's editor vomit.
OK benno, pirofti on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.26 2017/07/04 23:13:09 mestre Exp $	*/
d43 1
d63 2
d68 2
a69 2
int
priv_init(void)
d71 1
a71 2
	int i, bpfd = -1, socks[2], cmd;
	int snaplen, ret, olderrno;
d73 1
a73 3

	for (i = 1; i < _NSIG; i++)
		signal(i, SIG_DFL);
d106 1
a106 1
		return 0;
d108 37
a155 1
	close(socks[1]);
d164 1
a164 1
		if (may_read(socks[0], &cmd, sizeof(int)))
d167 18
d188 1
a188 1
			must_read(socks[0], &snaplen, sizeof(int));
d197 1
a197 1
			must_write(socks[0], &ret, sizeof(int));
d212 1
a212 1
			send_fd(socks[0], bpfd);
d223 1
a223 1
			must_write(socks[0], &ret, sizeof(int));
d233 1
a233 1
	_exit(1);
d286 40
@


1.26
log
@Revert back previous, pledge cannot be enabled on the privsep'd proc yet, at
least not as is

Reported by tim@@, OK deraadt@@ to backout the pledge for now
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.25 2017/06/12 23:37:44 mestre Exp $	*/
d121 1
a121 1
#if notyet
d123 1
a123 1
	if (pledge("stdio rpath wpath cpath sendfd proc bpf", NULL) == -1)
@


1.25
log
@pledge(2) bpf has been in use for some time now on tcpdump(8), this will enable
it also for pflogd(8)'s priv proc.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.24 2017/01/23 04:25:05 deraadt Exp $	*/
d121 2
d125 1
@


1.24
log
@Split pledge "ioctl" into "tape" and "bpf", and allow SIOCGIFGROUP only
upon "inet".  Adjust the 4 programs that care about this.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.23 2017/01/23 03:47:37 benno Exp $	*/
a120 3

#if notyet
	/* This needs to do bpf ioctl */
d123 1
a123 1
#endif
@


1.23
log
@pflogd will need pledge(proc), still disabled because of bfd
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.22 2016/01/16 03:17:48 canacar Exp $	*/
d124 1
a124 1
	if (pledge("stdio rpath wpath cpath ioctl sendfd proc", NULL) == -1)
@


1.22
log
@Interface status printing (at exit and USR1) was broken for a while.
Remove it completely to simplify the code.
even better deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.21 2015/10/10 22:36:06 deraadt Exp $	*/
d124 1
a124 1
	if (pledge("stdio rpath wpath cpath ioctl sendfd", NULL) == -1)
@


1.21
log
@pflogd contained the same "privsep error" as tcpdump -- assuming that
it can ioctl()'s against a bpf device node.  Privsep that operation
via a message to the parent process.  Unfortunately "rpath wpath cpath"
is still needed due to SIGHUP handling, but I have asked canacar the
expert to look into this.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.20 2015/04/28 05:54:31 mlarkin Exp $	*/
a45 1
	PRIV_PCAP_STATS		/* get pcap statistics */
a69 1
	struct pcap_stat stats;
a171 13
		case PRIV_PCAP_STATS:
			if (ioctl(bpfd, BIOCGSTATS, &stats) == -1) {
				int rval = -1;
				memset(&stats, 0, sizeof stats);
				must_write(socks[0], &stats, sizeof(stats));
				must_write(socks[0], &rval, sizeof(rval));
			} else {
				int rval = 0;
				must_write(socks[0], &stats, sizeof(stats));
				must_write(socks[0], &rval, sizeof(rval));
			}
			break;
			
a288 17

	return (ret);
}

/* Get statistics */
int
priv_pcap_stats(struct pcap_stat *ps)
{
	int cmd, ret;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_PCAP_STATS;
	must_write(priv_fd, &cmd, sizeof (int));
	must_read(priv_fd, ps, sizeof(*ps));
	must_read(priv_fd, &ret, sizeof(ret));
@


1.20
log
@
Someone went to the trouble of vertically aligning a set of parameters but
missed one. This diff is only a spacing change.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.19 2014/06/26 17:56:09 tobias Exp $	*/
d45 2
a46 1
	PRIV_OPEN_LOG		/* open logfile for appending */
d69 1
a69 1
	int i, fd, socks[2], cmd;
d71 1
d123 6
d152 5
a156 1
			fd = open(filename,
d160 2
a161 2
			send_fd(socks[0], fd);
			if (fd < 0)
a164 2
			else
				close(fd);
d174 13
d291 1
d304 17
@


1.19
log
@Create temporary file with mkstemp and unlink if rename operation fails.

ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.18 2013/09/13 08:49:17 blambert Exp $	*/
d115 1
a115 1
	signal(SIGQUIT,  sig_pass_to_chld);
@


1.18
log
@errx() provides its own newline, so remove it from the string here

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.17 2009/12/24 10:06:35 sobrado Exp $	*/
d196 1
a196 2
		len = snprintf(ren, sizeof(ren), "%s.bad.%08x",
		    name, arc4random());
d203 1
a203 1
		fd = open(ren, O_CREAT|O_EXCL, 0);
d208 1
a208 2
		/* if file exists, try another name */
		if (errno != EEXIST && errno != EINTR) {
d218 1
@


1.17
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.16 2006/10/25 20:55:04 moritz Exp $	*/
d276 1
a276 1
		errx(1, "%s: called from privileged portion\n", __func__);
@


1.16
log
@Remove some unneeded externs. OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.15 2006/03/06 10:45:56 djm Exp $	*/
d203 1
a203 1
		/* lock destinanion */
@


1.15
log
@convert permanent privilege revocation to use setresuid/setresgid;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.14 2006/01/15 16:38:04 canacar Exp $	*/
a60 3
/* bpf filter expression common to parent and child */
extern char *filter;
extern char *errbuf;
@


1.14
log
@If the log file is invalid/incompatible, try to rename the bad log file
and continue with a new name instead of suspending.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.13 2004/12/22 09:21:02 otto Exp $	*/
d101 2
d105 2
a106 8
		if (setegid(pw->pw_gid) == -1)
			err(1, "setegid() failed");
		if (setgid(pw->pw_gid) == -1)
			err(1, "setgid() failed");
		if (seteuid(pw->pw_uid) == -1)
			err(1, "seteuid() failed");
		if (setuid(pw->pw_uid) == -1)
			err(1, "setuid() failed");
@


1.13
log
@also pass SIGINT/QUIT to child, from mpech@@. ok avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.12 2004/07/14 19:07:03 henning Exp $	*/
a18 1
#include <sys/ioctl.h>
d30 1
d44 1
d59 1
d164 7
d194 41
d275 15
@


1.12
log
@no \n in errx(3)
From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.11 2004/04/08 14:32:47 avsm Exp $	*/
d115 1
a115 1
	/* Pass ALRM/TERM/HUP through to child, and accept CHLD */
d119 2
@


1.11
log
@sigh, really fix the error message this time, thanks Moritz Jodeit
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.10 2004/04/08 12:26:06 avsm Exp $	*/
d216 1
a216 1
		errx(1, "%s: called from privileged portion\n", __func__);
@


1.10
log
@reorder error message and send_fd in order to display the correct
errno in error message; pointed out by Moritz Jodeit <moritz at jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.9 2004/04/03 10:21:18 avsm Exp $	*/
d70 1
a70 1
	int snaplen, ret;
d150 2
d155 1
a155 1
				    filename, strerror(errno));
a157 1
			send_fd(socks[0], fd);
@


1.9
log
@dont close an invalid fd, canacar@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.8 2004/03/14 19:17:05 otto Exp $	*/
a149 1
			send_fd(socks[0], fd);
d156 1
@


1.8
log
@Check return code of chdir() after chroot(); noted by Joris Vink, slight mod
from avsm@@.
ok avsm@@ hshoexer@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.7 2004/02/13 19:01:57 otto Exp $	*/
d150 1
d155 2
a156 2
			send_fd(socks[0], fd);
			close(fd);
@


1.7
log
@cleanup signal handling; close descriptors.
ok avsm@@ millert@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.6 2004/01/18 14:21:52 canacar Exp $	*/
d95 2
a96 1
		chdir("/");
@


1.6
log
@Create log files if they do not already exist, but do not follow
symlinks. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.5 2004/01/15 20:10:43 canacar Exp $	*/
d48 1
a48 1
static pid_t child_pid = -1;
d73 3
d83 1
a113 3
	for (i = 1; i <= _NSIG; i++)
		signal(i, SIG_DFL);

d226 2
d230 1
@


1.5
log
@Synchronize with syslogd privsep: When reading a new command fails,
terminate the loop instead of exiting directly, suggested by avsm@@
Also get rid of trailing comma in enum, makes lint(1) happier, from
Andrey Matveev andrushock at korovino dot net
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2003/10/22 19:53:15 deraadt Exp $	*/
d144 4
a147 3

			/* XXX */
			fd = open(filename, O_RDWR|O_APPEND|O_NONBLOCK, 0);
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.3 2003/10/22 19:35:44 deraadt Exp $	*/
d44 1
a44 1
	PRIV_OPEN_LOG,		/* open logfile for appending */
d54 1
d123 2
a124 1
		must_read(socks[0], &cmd, sizeof(int));
d233 22
@


1.3
log
@use setgroups too; canacar ok
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.1 2003/10/22 18:51:55 canacar Exp $	*/
d152 1
a152 1
			
@


1.2
log
@caution with kill
@
text
@d85 2
d91 4
@


1.1
log
@privilege seperated pflogd

_pflogd user and group must be created for proper operation.

ok frantzen@@ henning@@ mcbride@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2003/08/01 14:04:35 avsm Exp $	*/
d48 1
a48 1
static pid_t child_pid;
d216 2
a217 1
	kill(child_pid, sig);
@

