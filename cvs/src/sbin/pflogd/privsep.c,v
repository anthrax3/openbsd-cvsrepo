head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8;
locks; strict;
comment	@ * @;


1.24
date	2017.01.23.04.25.05;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	NeJrtXDNhZqhGXfa;

1.23
date	2017.01.23.03.47.37;	author benno;	state Exp;
branches;
next	1.22;
commitid	909w8isNzfS1pH2h;

1.22
date	2016.01.16.03.17.48;	author canacar;	state Exp;
branches;
next	1.21;
commitid	2sPyHwdNzYQaXlAm;

1.21
date	2015.10.10.22.36.06;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	gjxLpEqCRrEu4Dmr;

1.20
date	2015.04.28.05.54.31;	author mlarkin;	state Exp;
branches;
next	1.19;
commitid	kFaSqsEDHBJjdg6X;

1.19
date	2014.06.26.17.56.09;	author tobias;	state Exp;
branches;
next	1.18;
commitid	BmVpKomov69NlBVS;

1.18
date	2013.09.13.08.49.17;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.25.20.55.04;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.06.10.45.56;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.15.16.38.04;	author canacar;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.22.09.21.02;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.14.19.07.03;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.08.14.32.47;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.12.26.06;	author avsm;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.03.10.21.18;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.14.19.17.05;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.13.19.01.57;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.18.14.21.52;	author canacar;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.15.20.10.43;	author canacar;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.22.19.53.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.22.19.35.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.22.19.21.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.22.18.51.55;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Split pledge "ioctl" into "tape" and "bpf", and allow SIOCGIFGROUP only
upon "inet".  Adjust the 4 programs that care about this.
@
text
@/*	$OpenBSD: privsep.c,v 1.23 2017/01/23 03:47:37 benno Exp $	*/

/*
 * Copyright (c) 2003 Can Erkin Acar
 * Copyright (c) 2003 Anil Madhavapeddy <anil@@recoil.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/bpf.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pcap.h>
#include <pcap-int.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include "pflogd.h"

enum cmd_types {
	PRIV_SET_SNAPLEN,	/* set the snaplength */
	PRIV_MOVE_LOG,		/* move logfile away */
	PRIV_OPEN_LOG,		/* open logfile for appending */
};

static int priv_fd = -1;
static volatile pid_t child_pid = -1;

volatile sig_atomic_t gotsig_chld = 0;

static void sig_pass_to_chld(int);
static void sig_chld(int);
static int  may_read(int, void *, size_t);
static void must_read(int, void *, size_t);
static void must_write(int, void *, size_t);
static int  set_snaplen(int snap);
static int  move_log(const char *name);

extern char *filename;
extern pcap_t *hpcap;

/* based on syslogd privsep */
int
priv_init(void)
{
	int i, bpfd = -1, socks[2], cmd;
	int snaplen, ret, olderrno;
	struct passwd *pw;

	for (i = 1; i < _NSIG; i++)
		signal(i, SIG_DFL);

	/* Create sockets */
	if (socketpair(AF_LOCAL, SOCK_STREAM, PF_UNSPEC, socks) == -1)
		err(1, "socketpair() failed");

	pw = getpwnam("_pflogd");
	if (pw == NULL)
		errx(1, "unknown user _pflogd");
	endpwent();

	child_pid = fork();
	if (child_pid < 0)
		err(1, "fork() failed");

	if (!child_pid) {
		gid_t gidset[1];

		/* Child - drop privileges and return */
		if (chroot(pw->pw_dir) != 0)
			err(1, "unable to chroot");
		if (chdir("/") != 0)
			err(1, "unable to chdir");

		gidset[0] = pw->pw_gid;
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
			err(1, "setresgid() failed");
		if (setgroups(1, gidset) == -1)
			err(1, "setgroups() failed");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
			err(1, "setresuid() failed");
		close(socks[0]);
		priv_fd = socks[1];
		return 0;
	}

	/* Father */
	/* Pass ALRM/TERM/HUP/INT/QUIT through to child, and accept CHLD */
	signal(SIGALRM, sig_pass_to_chld);
	signal(SIGTERM, sig_pass_to_chld);
	signal(SIGHUP,  sig_pass_to_chld);
	signal(SIGINT,  sig_pass_to_chld);
	signal(SIGQUIT, sig_pass_to_chld);
	signal(SIGCHLD, sig_chld);

	setproctitle("[priv]");
	close(socks[1]);


#if notyet
	/* This needs to do bpf ioctl */
	if (pledge("stdio rpath wpath cpath sendfd proc bpf", NULL) == -1)
		err(1, "pledge");
#endif
	while (!gotsig_chld) {
		if (may_read(socks[0], &cmd, sizeof(int)))
			break;
		switch (cmd) {
		case PRIV_SET_SNAPLEN:
			logmsg(LOG_DEBUG,
			    "[priv]: msg PRIV_SET_SNAPLENGTH received");
			must_read(socks[0], &snaplen, sizeof(int));

			ret = set_snaplen(snaplen);
			if (ret) {
				logmsg(LOG_NOTICE,
				   "[priv]: set_snaplen failed for snaplen %d",
				   snaplen);
			}

			must_write(socks[0], &ret, sizeof(int));
			break;

		case PRIV_OPEN_LOG:
			logmsg(LOG_DEBUG,
			    "[priv]: msg PRIV_OPEN_LOG received");
			/* create or append logs but do not follow symlinks */
			if (bpfd != -1) {
				close(bpfd);
				bpfd = -1;
			}
			bpfd = open(filename,
			    O_RDWR|O_CREAT|O_APPEND|O_NONBLOCK|O_NOFOLLOW,
			    0600);
			olderrno = errno;
			send_fd(socks[0], bpfd);
			if (bpfd < 0)
				logmsg(LOG_NOTICE,
				    "[priv]: failed to open %s: %s",
				    filename, strerror(olderrno));
			break;

		case PRIV_MOVE_LOG:
			logmsg(LOG_DEBUG,
			    "[priv]: msg PRIV_MOVE_LOG received");
			ret = move_log(filename);
			must_write(socks[0], &ret, sizeof(int));
			break;

		default:
			logmsg(LOG_ERR, "[priv]: unknown command %d", cmd);
			_exit(1);
			/* NOTREACHED */
		}
	}

	_exit(1);
}

/* this is called from parent */
static int
set_snaplen(int snap)
{
	if (hpcap == NULL)
		return (1);

	hpcap->snapshot = snap;
	set_pcap_filter();

	return 0;
}

static int
move_log(const char *name)
{
	char ren[PATH_MAX];
	int len;

	for (;;) {
		int fd;

		len = snprintf(ren, sizeof(ren), "%s.bad.XXXXXXXX", name);
		if (len >= sizeof(ren)) {
			logmsg(LOG_ERR, "[priv] new name too long");
			return (1);
		}

		/* lock destination */
		fd = mkstemp(ren);
		if (fd >= 0) {
			close(fd);
			break;
		}
		if (errno != EINTR) {
			logmsg(LOG_ERR, "[priv] failed to create new name: %s",
			    strerror(errno));
			return (1);			
		}
	}

	if (rename(name, ren)) {
		logmsg(LOG_ERR, "[priv] failed to rename %s to %s: %s",
		    name, ren, strerror(errno));
		unlink(ren);
		return (1);
	}

	logmsg(LOG_NOTICE,
	       "[priv]: log file %s moved to %s", name, ren);

	return (0);
}

/*
 * send the snaplength to privileged process
 */
int
priv_set_snaplen(int snaplen)
{
	int cmd, ret;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_SET_SNAPLEN;

	must_write(priv_fd, &cmd, sizeof(int));
	must_write(priv_fd, &snaplen, sizeof(int));

	must_read(priv_fd, &ret, sizeof(int));

	/* also set hpcap->snapshot in child */
	if (ret == 0)
		hpcap->snapshot = snaplen;

	return (ret);
}

/* Open log-file */
int
priv_open_log(void)
{
	int cmd, fd;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_OPEN_LOG;
	must_write(priv_fd, &cmd, sizeof(int));
	fd = receive_fd(priv_fd);

	return (fd);
}

/* Move-away and reopen log-file */
int
priv_move_log(void)
{
	int cmd, ret;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_MOVE_LOG;
	must_write(priv_fd, &cmd, sizeof(int));
	must_read(priv_fd, &ret, sizeof(int));

	return (ret);
}

/* If priv parent gets a TERM or HUP, pass it through to child instead */
static void
sig_pass_to_chld(int sig)
{
	int oerrno = errno;

	if (child_pid != -1)
		kill(child_pid, sig);
	errno = oerrno;
}

/* if parent gets a SIGCHLD, it will exit */
static void
sig_chld(int sig)
{
	gotsig_chld = 1;
}

/* Read all data or return 1 for error.  */
static int
may_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			return (1);
		default:
			pos += res;
		}
	}
	return (0);
}

/* Read data with the assertion that it all must come through, or
 * else abort the process.  Based on atomicio() from openssh. */
static void
must_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			_exit(0);
		default:
			pos += res;
		}
	}
}

/* Write data with the assertion that it all has to be written, or
 * else abort the process.  Based on atomicio() from openssh. */
static void
must_write(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = write(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
		case 0:
			_exit(0);
		default:
			pos += res;
		}
	}
}
@


1.23
log
@pflogd will need pledge(proc), still disabled because of bfd
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.22 2016/01/16 03:17:48 canacar Exp $	*/
d124 1
a124 1
	if (pledge("stdio rpath wpath cpath ioctl sendfd proc", NULL) == -1)
@


1.22
log
@Interface status printing (at exit and USR1) was broken for a while.
Remove it completely to simplify the code.
even better deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.21 2015/10/10 22:36:06 deraadt Exp $	*/
d124 1
a124 1
	if (pledge("stdio rpath wpath cpath ioctl sendfd", NULL) == -1)
@


1.21
log
@pflogd contained the same "privsep error" as tcpdump -- assuming that
it can ioctl()'s against a bpf device node.  Privsep that operation
via a message to the parent process.  Unfortunately "rpath wpath cpath"
is still needed due to SIGHUP handling, but I have asked canacar the
expert to look into this.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.20 2015/04/28 05:54:31 mlarkin Exp $	*/
a45 1
	PRIV_PCAP_STATS		/* get pcap statistics */
a69 1
	struct pcap_stat stats;
a171 13
		case PRIV_PCAP_STATS:
			if (ioctl(bpfd, BIOCGSTATS, &stats) == -1) {
				int rval = -1;
				memset(&stats, 0, sizeof stats);
				must_write(socks[0], &stats, sizeof(stats));
				must_write(socks[0], &rval, sizeof(rval));
			} else {
				int rval = 0;
				must_write(socks[0], &stats, sizeof(stats));
				must_write(socks[0], &rval, sizeof(rval));
			}
			break;
			
a288 17

	return (ret);
}

/* Get statistics */
int
priv_pcap_stats(struct pcap_stat *ps)
{
	int cmd, ret;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	cmd = PRIV_PCAP_STATS;
	must_write(priv_fd, &cmd, sizeof (int));
	must_read(priv_fd, ps, sizeof(*ps));
	must_read(priv_fd, &ret, sizeof(ret));
@


1.20
log
@
Someone went to the trouble of vertically aligning a set of parameters but
missed one. This diff is only a spacing change.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.19 2014/06/26 17:56:09 tobias Exp $	*/
d45 2
a46 1
	PRIV_OPEN_LOG		/* open logfile for appending */
d69 1
a69 1
	int i, fd, socks[2], cmd;
d71 1
d123 6
d152 5
a156 1
			fd = open(filename,
d160 2
a161 2
			send_fd(socks[0], fd);
			if (fd < 0)
a164 2
			else
				close(fd);
d174 13
d291 1
d304 17
@


1.19
log
@Create temporary file with mkstemp and unlink if rename operation fails.

ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.18 2013/09/13 08:49:17 blambert Exp $	*/
d115 1
a115 1
	signal(SIGQUIT,  sig_pass_to_chld);
@


1.18
log
@errx() provides its own newline, so remove it from the string here

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.17 2009/12/24 10:06:35 sobrado Exp $	*/
d196 1
a196 2
		len = snprintf(ren, sizeof(ren), "%s.bad.%08x",
		    name, arc4random());
d203 1
a203 1
		fd = open(ren, O_CREAT|O_EXCL, 0);
d208 1
a208 2
		/* if file exists, try another name */
		if (errno != EEXIST && errno != EINTR) {
d218 1
@


1.17
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.16 2006/10/25 20:55:04 moritz Exp $	*/
d276 1
a276 1
		errx(1, "%s: called from privileged portion\n", __func__);
@


1.16
log
@Remove some unneeded externs. OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.15 2006/03/06 10:45:56 djm Exp $	*/
d203 1
a203 1
		/* lock destinanion */
@


1.15
log
@convert permanent privilege revocation to use setresuid/setresgid;
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.14 2006/01/15 16:38:04 canacar Exp $	*/
a60 3
/* bpf filter expression common to parent and child */
extern char *filter;
extern char *errbuf;
@


1.14
log
@If the log file is invalid/incompatible, try to rename the bad log file
and continue with a new name instead of suspending.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.13 2004/12/22 09:21:02 otto Exp $	*/
d101 2
d105 2
a106 8
		if (setegid(pw->pw_gid) == -1)
			err(1, "setegid() failed");
		if (setgid(pw->pw_gid) == -1)
			err(1, "setgid() failed");
		if (seteuid(pw->pw_uid) == -1)
			err(1, "seteuid() failed");
		if (setuid(pw->pw_uid) == -1)
			err(1, "setuid() failed");
@


1.13
log
@also pass SIGINT/QUIT to child, from mpech@@. ok avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.12 2004/07/14 19:07:03 henning Exp $	*/
a18 1
#include <sys/ioctl.h>
d30 1
d44 1
d59 1
d164 7
d194 41
d275 15
@


1.12
log
@no \n in errx(3)
From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.11 2004/04/08 14:32:47 avsm Exp $	*/
d115 1
a115 1
	/* Pass ALRM/TERM/HUP through to child, and accept CHLD */
d119 2
@


1.11
log
@sigh, really fix the error message this time, thanks Moritz Jodeit
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.10 2004/04/08 12:26:06 avsm Exp $	*/
d216 1
a216 1
		errx(1, "%s: called from privileged portion\n", __func__);
@


1.10
log
@reorder error message and send_fd in order to display the correct
errno in error message; pointed out by Moritz Jodeit <moritz at jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.9 2004/04/03 10:21:18 avsm Exp $	*/
d70 1
a70 1
	int snaplen, ret;
d150 2
d155 1
a155 1
				    filename, strerror(errno));
a157 1
			send_fd(socks[0], fd);
@


1.9
log
@dont close an invalid fd, canacar@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.8 2004/03/14 19:17:05 otto Exp $	*/
a149 1
			send_fd(socks[0], fd);
d156 1
@


1.8
log
@Check return code of chdir() after chroot(); noted by Joris Vink, slight mod
from avsm@@.
ok avsm@@ hshoexer@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.7 2004/02/13 19:01:57 otto Exp $	*/
d150 1
d155 2
a156 2
			send_fd(socks[0], fd);
			close(fd);
@


1.7
log
@cleanup signal handling; close descriptors.
ok avsm@@ millert@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.6 2004/01/18 14:21:52 canacar Exp $	*/
d95 2
a96 1
		chdir("/");
@


1.6
log
@Create log files if they do not already exist, but do not follow
symlinks. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.5 2004/01/15 20:10:43 canacar Exp $	*/
d48 1
a48 1
static pid_t child_pid = -1;
d73 3
d83 1
a113 3
	for (i = 1; i <= _NSIG; i++)
		signal(i, SIG_DFL);

d226 2
d230 1
@


1.5
log
@Synchronize with syslogd privsep: When reading a new command fails,
terminate the loop instead of exiting directly, suggested by avsm@@
Also get rid of trailing comma in enum, makes lint(1) happier, from
Andrey Matveev andrushock at korovino dot net
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2003/10/22 19:53:15 deraadt Exp $	*/
d144 4
a147 3

			/* XXX */
			fd = open(filename, O_RDWR|O_APPEND|O_NONBLOCK, 0);
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.3 2003/10/22 19:35:44 deraadt Exp $	*/
d44 1
a44 1
	PRIV_OPEN_LOG,		/* open logfile for appending */
d54 1
d123 2
a124 1
		must_read(socks[0], &cmd, sizeof(int));
d233 22
@


1.3
log
@use setgroups too; canacar ok
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.1 2003/10/22 18:51:55 canacar Exp $	*/
d152 1
a152 1
			
@


1.2
log
@caution with kill
@
text
@d85 2
d91 4
@


1.1
log
@privilege seperated pflogd

_pflogd user and group must be created for proper operation.

ok frantzen@@ henning@@ mcbride@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2003/08/01 14:04:35 avsm Exp $	*/
d48 1
a48 1
static pid_t child_pid;
d216 2
a217 1
	kill(child_pid, sig);
@

