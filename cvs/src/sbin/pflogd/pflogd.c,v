head	1.56;
access;
symbols
	OPENBSD_6_1:1.53.0.8
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.51.0.6
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.49.0.10
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.8
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.4
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.49.0.2
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.48.0.2
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.10
	OPENBSD_5_0:1.47.0.8
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.47.0.6
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.4
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.46.0.6
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.45.0.6
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.4
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.56
date	2017.09.06.12.43.16;	author brynet;	state Exp;
branches;
next	1.55;
commitid	n6m5he50NEcXWLLP;

1.55
date	2017.09.05.15.41.25;	author brynet;	state Exp;
branches;
next	1.54;
commitid	UGtgLdiBxweIZpQK;

1.54
date	2017.07.23.14.28.22;	author jca;	state Exp;
branches;
next	1.53;
commitid	zpPkLlOBPtSOnc7Z;

1.53
date	2016.01.16.03.17.48;	author canacar;	state Exp;
branches;
next	1.52;
commitid	2sPyHwdNzYQaXlAm;

1.52
date	2015.10.10.22.36.06;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	gjxLpEqCRrEu4Dmr;

1.51
date	2015.02.07.02.09.13;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	pzd3OPiuZ6mCFBtc;

1.50
date	2014.11.20.15.22.39;	author tedu;	state Exp;
branches;
next	1.49;
commitid	HIbf8HnT4wFtIrOp;

1.49
date	2012.11.06.02.50.47;	author lteo;	state Exp;
branches;
next	1.48;

1.48
date	2012.03.05.11.50.16;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2009.11.03.20.47.41;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.22.08.16.49;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.06.14.11.26;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.06.09.40.48;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.04.13.55.24;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.02.20.38.58;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.02.20.38.14;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.27.20.07.42;	author jdixon;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.07.07.48.50;	author jmc;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.06.16.30.49;	author canacar;	state Exp;
branches;
next	1.37;

1.37
date	2006.10.26.13.34.47;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.25.20.20.19;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.15.16.38.04;	author canacar;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.04.22.35.48;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.09.12.09.30;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.08.18.51.18;	author canacar;	state Exp;
branches;
next	1.31;

1.31
date	2004.09.17.07.11.55;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.08.19.04.25;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.23.19.00.26;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.28.06.59.58;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.13.19.01.57;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.16.10.45.49;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.15.20.15.14;	author canacar;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.22.19.53.15;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.22.18.51.55;	author canacar;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.26.16.14.33;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.14.08.56.12;	author canacar;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.23.22.44.53;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.11.02.35.34;	author kjc;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.01.06.11.20;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.30.23.02.10;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.30.19.36.05;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.17.09.12.04;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.03.18.28.49;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.23.09.51.12;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.08.17.28.34;	author jasoni;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.21.07.46.09;	author dhartmei;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.01.23.27.23;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.10.14.30.08;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.29.17.42.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.24.19.48.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.24.19.46.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.23.04.07.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.23.04.06.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.22.14.49.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.21.22.29.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.56
log
@pflogd(8) currently spams the console on shutdown if syslogd(8) wins the
race to die, so just stop logging pflogd exits.

This logging probably comes from the fact that pflogd was largely based
on syslogd.

Removes the annoying "pflogd[23954]: Exiting" messages pointed out by
deraadt@@

Also cleanup some missed SIGCHLD handling code that is no longer needed.

"LGTM" mikeb@@
@
text
@/*	$OpenBSD: pflogd.c,v 1.55 2017/09/05 15:41:25 brynet Exp $	*/

/*
 * Copyright (c) 2001 Theo de Raadt
 * Copyright (c) 2001 Can Erkin Acar
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <net/if.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pcap-int.h>
#include <pcap.h>
#include <syslog.h>
#include <signal.h>
#include <err.h>
#include <errno.h>
#include <stdarg.h>
#include <fcntl.h>
#include <util.h>
#include "pflogd.h"

pcap_t *hpcap;
static FILE *dpcap;

int Debug = 0;
static int privchild = 0;
static int snaplen = DEF_SNAPLEN;
static int cur_snaplen = DEF_SNAPLEN;

volatile sig_atomic_t gotsig_close, gotsig_alrm, gotsig_hup;

char *filename = PFLOGD_LOG_FILE;
char *interface = PFLOGD_DEFAULT_IF;
char *filter = NULL;

char errbuf[PCAP_ERRBUF_SIZE];

int log_debug = 0;
unsigned int delay = FLUSH_DELAY;

char *copy_argv(char * const *);
void  dump_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
void  dump_packet_nobuf(u_char *, const struct pcap_pkthdr *, const u_char *);
int   flush_buffer(FILE *);
int   if_exists(char *);
void  logmsg(int, const char *, ...);
void  purge_buffer(void);
int   reset_dump(int);
int   scan_dump(FILE *, off_t);
int   set_snaplen(int);
void  set_suspended(int);
void  sig_alrm(int);
void  sig_close(int);
void  sig_hup(int);
void  usage(void);

static int try_reset_dump(int);

/* buffer must always be greater than snaplen */
static int    bufpkt = 0;	/* number of packets in buffer */
static int    buflen = 0;	/* allocated size of buffer */
static char  *buffer = NULL;	/* packet buffer */
static char  *bufpos = NULL;	/* position in buffer */
static int    bufleft = 0;	/* bytes left in buffer */

/* if error, stop logging but count dropped packets */
static int suspended = -1;
static long packets_dropped = 0;

void
set_suspended(int s)
{
	if (suspended == s)
		return;

	suspended = s;
	setproctitle("[%s] -s %d -i %s -f %s",
	    suspended ? "suspended" : "running",
	    cur_snaplen, interface, filename);
}

char *
copy_argv(char * const *argv)
{
	size_t len = 0, n;
	char *buf;

	if (argv == NULL)
		return (NULL);

	for (n = 0; argv[n]; n++)
		len += strlen(argv[n])+1;
	if (len == 0)
		return (NULL);

	buf = malloc(len);
	if (buf == NULL)
		return (NULL);

	strlcpy(buf, argv[0], len);
	for (n = 1; argv[n]; n++) {
		strlcat(buf, " ", len);
		strlcat(buf, argv[n], len);
	}
	return (buf);
}

void
logmsg(int pri, const char *message, ...)
{
	va_list ap;
	va_start(ap, message);

	if (log_debug) {
		vfprintf(stderr, message, ap);
		fprintf(stderr, "\n");
	} else
		vsyslog(pri, message, ap);
	va_end(ap);
}

__dead void
usage(void)
{
	fprintf(stderr, "usage: pflogd [-Dx] [-d delay] [-f filename]");
	fprintf(stderr, " [-i interface] [-s snaplen]\n");
	fprintf(stderr, "              [expression]\n");
	exit(1);
}

void
sig_close(int sig)
{
	gotsig_close = 1;
}

void
sig_hup(int sig)
{
	gotsig_hup = 1;
}

void
sig_alrm(int sig)
{
	gotsig_alrm = 1;
}

void
set_pcap_filter(void)
{
	struct bpf_program bprog;

	if (pcap_compile(hpcap, &bprog, filter, PCAP_OPT_FIL, 0) < 0)
		logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
	else {
		if (pcap_setfilter(hpcap, &bprog) < 0)
			logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
		pcap_freecode(&bprog);
	}
}

int
if_exists(char *ifname)
{
	return (if_nametoindex(ifname) != 0);
}

int
init_pcap(void)
{
	hpcap = pcap_open_live(interface, snaplen, 1, PCAP_TO_MS, errbuf);
	if (hpcap == NULL) {
		logmsg(LOG_ERR, "Failed to initialize: %s", errbuf);
		return (-1);
	}

	if (pcap_datalink(hpcap) != DLT_PFLOG) {
		logmsg(LOG_ERR, "Invalid datalink type");
		pcap_close(hpcap);
		hpcap = NULL;
		return (-1);
	}

	set_pcap_filter();

	/* lock */
	if (ioctl(pcap_fileno(hpcap), BIOCLOCK) < 0) {
		logmsg(LOG_ERR, "BIOCLOCK: %s", strerror(errno));
		return (-1);
	}

	return (0);
}

int
set_snaplen(int snap)
{
	if (priv_set_snaplen(snap))
		return (1);

	if (cur_snaplen > snap)
		purge_buffer();

	cur_snaplen = snap;

	return (0);
}

int
reset_dump(int nomove)
{
	int ret;

	for (;;) {
		ret = try_reset_dump(nomove);
		if (ret <= 0)
			break;
	}

	return (ret);
}

/*
 * tries to (re)open log file, nomove flag is used with -x switch
 * returns 0: success, 1: retry (log moved), -1: error
 */
int
try_reset_dump(int nomove)
{
	struct pcap_file_header hdr;
	struct stat st;
	int fd;
	FILE *fp;

	if (hpcap == NULL)
		return (-1);

	if (dpcap) {
		flush_buffer(dpcap);
		fclose(dpcap);
		dpcap = NULL;
	}

	/*
	 * Basically reimplement pcap_dump_open() because it truncates
	 * files and duplicates headers and such.
	 */
	fd = priv_open_log();
	if (fd < 0)
		return (-1);

	fp = fdopen(fd, "a+");

	if (fp == NULL) {
		logmsg(LOG_ERR, "Error: %s: %s", filename, strerror(errno));
		close(fd);
		return (-1);
	}
	if (fstat(fileno(fp), &st) == -1) {
		logmsg(LOG_ERR, "Error: %s: %s", filename, strerror(errno));
		fclose(fp);
		return (-1);
	}

	/* set FILE unbuffered, we do our own buffering */
	if (setvbuf(fp, NULL, _IONBF, 0)) {
		logmsg(LOG_ERR, "Failed to set output buffers");
		fclose(fp);
		return (-1);
	}

#define TCPDUMP_MAGIC 0xa1b2c3d4

	if (st.st_size == 0) {
		if (snaplen != cur_snaplen) {
			logmsg(LOG_NOTICE, "Using snaplen %d", snaplen);
			if (set_snaplen(snaplen))
				logmsg(LOG_WARNING,
				    "Failed, using old settings");
		}
		hdr.magic = TCPDUMP_MAGIC;
		hdr.version_major = PCAP_VERSION_MAJOR;
		hdr.version_minor = PCAP_VERSION_MINOR;
		hdr.thiszone = hpcap->tzoff;
		hdr.snaplen = hpcap->snapshot;
		hdr.sigfigs = 0;
		hdr.linktype = hpcap->linktype;

		if (fwrite((char *)&hdr, sizeof(hdr), 1, fp) != 1) {
			fclose(fp);
			return (-1);
		}
	} else if (scan_dump(fp, st.st_size)) {
		fclose(fp);
		if (nomove || priv_move_log()) {
			logmsg(LOG_ERR,
			    "Invalid/incompatible log file, move it away");
			return (-1);
		}
		return (1);
	}

	dpcap = fp;

	set_suspended(0);
	flush_buffer(fp);

	return (0);
}

int
scan_dump(FILE *fp, off_t size)
{
	struct pcap_file_header hdr;
	struct pcap_pkthdr ph;
	off_t pos;

	/*
	 * Must read the file, compare the header against our new
	 * options (in particular, snaplen) and adjust our options so
	 * that we generate a correct file. Furthermore, check the file
	 * for consistency so that we can append safely.
	 *
	 * XXX this may take a long time for large logs.
	 */
	(void) fseek(fp, 0L, SEEK_SET);

	if (fread((char *)&hdr, sizeof(hdr), 1, fp) != 1) {
		logmsg(LOG_ERR, "Short file header");
		return (1);
	}

	if (hdr.magic != TCPDUMP_MAGIC ||
	    hdr.version_major != PCAP_VERSION_MAJOR ||
	    hdr.version_minor != PCAP_VERSION_MINOR ||
	    hdr.linktype != hpcap->linktype ||
	    hdr.snaplen > PFLOGD_MAXSNAPLEN) {
		return (1);
	}

	pos = sizeof(hdr);

	while (!feof(fp)) {
		off_t len = fread((char *)&ph, 1, sizeof(ph), fp);
		if (len == 0)
			break;

		if (len != sizeof(ph))
			goto error;
		if (ph.caplen > hdr.snaplen || ph.caplen > PFLOGD_MAXSNAPLEN)
			goto error;
		pos += sizeof(ph) + ph.caplen;
		if (pos > size)
			goto error;
		fseek(fp, ph.caplen, SEEK_CUR);
	}

	if (pos != size)
		goto error;

	if (hdr.snaplen != cur_snaplen) {
		logmsg(LOG_WARNING,
		       "Existing file has different snaplen %u, using it",
		       hdr.snaplen);
		if (set_snaplen(hdr.snaplen)) {
			logmsg(LOG_WARNING,
			       "Failed, using old settings, offset %llu",
			       (unsigned long long) size);
		}
	}

	return (0);

 error:
	logmsg(LOG_ERR, "Corrupted log file.");
	return (1);
}

/* dump a packet directly to the stream, which is unbuffered */
void
dump_packet_nobuf(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	FILE *f = (FILE *)user;

	if (suspended) {
		packets_dropped++;
		return;
	}

	if (fwrite((char *)h, sizeof(*h), 1, f) != 1) {
		off_t pos = ftello(f);

		/* try to undo header to prevent corruption */
		if (pos < sizeof(*h) ||
		    ftruncate(fileno(f), pos - sizeof(*h))) {
			logmsg(LOG_ERR, "Write failed, corrupted logfile!");
			set_suspended(1);
			gotsig_close = 1;
			return;
		}
		goto error;
	}

	if (fwrite((char *)sp, h->caplen, 1, f) != 1)
		goto error;

	return;

error:
	set_suspended(1);
	packets_dropped ++;
	logmsg(LOG_ERR, "Logging suspended: fwrite: %s", strerror(errno));
}

int
flush_buffer(FILE *f)
{
	off_t offset;
	int len = bufpos - buffer;

	if (len <= 0)
		return (0);

	offset = ftello(f);
	if (offset == (off_t)-1) {
		set_suspended(1);
		logmsg(LOG_ERR, "Logging suspended: ftello: %s",
		    strerror(errno));
		return (1);
	}

	if (fwrite(buffer, len, 1, f) != 1) {
		set_suspended(1);
		logmsg(LOG_ERR, "Logging suspended: fwrite: %s",
		    strerror(errno));
		ftruncate(fileno(f), offset);
		return (1);
	}

	set_suspended(0);
	bufpos = buffer;
	bufleft = buflen;
	bufpkt = 0;

	return (0);
}

void
purge_buffer(void)
{
	packets_dropped += bufpkt;

	set_suspended(0);
	bufpos = buffer;
	bufleft = buflen;
	bufpkt = 0;
}

/* append packet to the buffer, flushing if necessary */
void
dump_packet(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	FILE *f = (FILE *)user;
	size_t len = sizeof(*h) + h->caplen;

	if (len < sizeof(*h) || h->caplen > (size_t)cur_snaplen) {
		logmsg(LOG_NOTICE, "invalid size %zu (%d/%d), packet dropped",
		       len, cur_snaplen, snaplen);
		packets_dropped++;
		return;
	}

	if (len <= bufleft)
		goto append;

	if (suspended) {
		packets_dropped++;
		return;
	}

	if (flush_buffer(f)) {
		packets_dropped++;
		return;
	}

	if (len > bufleft) {
		dump_packet_nobuf(user, h, sp);
		return;
	}

 append:
	memcpy(bufpos, h, sizeof(*h));
	memcpy(bufpos + sizeof(*h), sp, h->caplen);

	bufpos += len;
	bufleft -= len;
	bufpkt++;

	return;
}

int
main(int argc, char **argv)
{
	int ch, np, ret, Xflag = 0;
	pcap_handler phandler = dump_packet;
	const char *errstr = NULL;

	ret = 0;

	while ((ch = getopt(argc, argv, "Dxd:f:i:P:s:")) != -1) {
		switch (ch) {
		case 'D':
			Debug = 1;
			break;
		case 'd':
			delay = strtonum(optarg, 5, 60*60, &errstr);
			if (errstr)
				usage();
			break;
		case 'f':
			filename = optarg;
			break;
		case 'i':
			interface = optarg;
			break;
		case 'P': /* used internally, exec the parent */
			privchild = strtonum(optarg, 2, INT_MAX, &errstr);
			if (errstr)
				errx(1, "priv child %s: %s", errstr, optarg);
			break;
		case 's':
			snaplen = strtonum(optarg, 0, PFLOGD_MAXSNAPLEN,
			    &errstr);
			if (snaplen <= 0)
				snaplen = DEF_SNAPLEN;
			if (errstr)
				snaplen = PFLOGD_MAXSNAPLEN;
			cur_snaplen = snaplen;
			break;
		case 'x':
			Xflag = 1;
			break;
		default:
			usage();
		}

	}

	log_debug = Debug;
	argc -= optind;
	argv += optind;

	/* does interface exist */
	if (!if_exists(interface)) {
		warn("Failed to initialize: %s", interface);
		logmsg(LOG_ERR, "Failed to initialize: %s", interface);
		logmsg(LOG_ERR, "Exiting, init failure");
		exit(1);
	}

	if (!Debug) {
		openlog("pflogd", LOG_PID | LOG_CONS, LOG_DAEMON);
		if (daemon(0, 0)) {
			logmsg(LOG_WARNING, "Failed to become daemon: %s",
			    strerror(errno));
		}
	}

	tzset();
	(void)umask(S_IRWXG | S_IRWXO);

	/* filter will be used by the privileged process */
	if (argc) {
		filter = copy_argv(argv);
		if (filter == NULL)
			logmsg(LOG_NOTICE, "Failed to form filter expression");
	}
	argc += optind;
	argv -= optind;

	if (privchild > 1)
		priv_exec(privchild, argc, argv);

	/* Privilege separation begins here */
	priv_init(argc, argv);

	if (pledge("stdio recvfd", NULL) == -1)
		err(1, "pledge");

	setproctitle("[initializing]");
	/* Process is now unprivileged and inside a chroot */
	signal(SIGTERM, sig_close);
	signal(SIGINT, sig_close);
	signal(SIGQUIT, sig_close);
	signal(SIGALRM, sig_alrm);
	signal(SIGHUP, sig_hup);
	alarm(delay);

	if (priv_init_pcap(snaplen))
		errx(1, "priv_init_pcap failed");

	buffer = malloc(PFLOGD_BUFSIZE);

	if (buffer == NULL) {
		logmsg(LOG_WARNING, "Failed to allocate output buffer");
		phandler = dump_packet_nobuf;
	} else {
		bufleft = buflen = PFLOGD_BUFSIZE;
		bufpos = buffer;
		bufpkt = 0;
	}

	if (reset_dump(Xflag) < 0) {
		if (Xflag)
			return (1);

		logmsg(LOG_ERR, "Logging suspended: open error");
		set_suspended(1);
	} else if (Xflag)
		return (0);

	while (1) {
		np = pcap_dispatch(hpcap, PCAP_NUM_PKTS,
		    phandler, (u_char *)dpcap);
		if (np < 0) {
			if (!if_exists(interface)) {
				logmsg(LOG_NOTICE, "interface %s went away",
				    interface);
				ret = -1;
				break;
			}
			logmsg(LOG_NOTICE, "%s", pcap_geterr(hpcap));
		}

		if (gotsig_close)
			break;
		if (gotsig_hup) {
			if (reset_dump(0)) {
				logmsg(LOG_ERR,
				    "Logging suspended: open error");
				set_suspended(1);
			}
			gotsig_hup = 0;
		}

		if (gotsig_alrm) {
			if (dpcap)
				flush_buffer(dpcap);
			else 
				gotsig_hup = 1;
			gotsig_alrm = 0;
			alarm(delay);
		}
	}

	if (dpcap) {
		flush_buffer(dpcap);
		fclose(dpcap);
	}
	purge_buffer();

	pcap_close(hpcap);
	if (!Debug)
		closelog();
	return (ret);
}
@


1.55
log
@fork+exec model for pflogd(8); move pcap init to the re-exec'd privsep
parent and use 'legit' fdpassing primitives to send the bpf fd to the
unprivileged child process.

Also reduces the pledge(2) promises in the unpriv child to just
   "stdio recvfd"

with help from deraadt, pcap feedback from canacar

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.54 2017/07/23 14:28:22 jca Exp $	*/
a688 1
	logmsg(LOG_NOTICE, "Exiting");
@


1.54
log
@Don't hit pledge(2) restrictions on interface departure

if_exists() can't be used after dropping privileges, since it uses
socket(2) and ioctl(SIOCGIFDATA).  We're just trying to know whether an
interface exists, and if_nametoindex(3) is enough for that.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.53 2016/01/16 03:17:48 canacar Exp $	*/
d57 1
a76 1
int   init_pcap(void);
a217 2
	cur_snaplen = snaplen = pcap_snapshot(hpcap);

d543 1
a543 3
	closefrom(STDERR_FILENO + 1);

	while ((ch = getopt(argc, argv, "Dxd:f:i:s:")) != -1) {
d559 5
d571 1
d611 2
d614 2
a615 5
	/* initialize pcap before dropping privileges */
	if (init_pcap()) {
		logmsg(LOG_ERR, "Exiting, init failure");
		exit(1);
	}
d618 1
a618 4
	if (priv_init()) {
		logmsg(LOG_ERR, "unable to privsep");
		exit(1);
	}
d620 1
a620 4
	/*
	 * XXX needs wpath cpath rpath, for try_reset_dump() ?
	 */
	if (pledge("stdio rpath wpath cpath unix recvfd", NULL) == -1)
d631 3
@


1.53
log
@Interface status printing (at exit and USR1) was broken for a while.
Remove it completely to simplify the code.
even better deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.52 2015/10/10 22:36:06 deraadt Exp $	*/
d197 1
a197 17
	int s, ret = 1;
	struct ifreq ifr;
	struct if_data ifrdat;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err(1, "socket");
	bzero(&ifr, sizeof(ifr));
	if (strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name)) >=
		sizeof(ifr.ifr_name))
			errx(1, "main ifr_name: strlcpy");
	ifr.ifr_data = (caddr_t)&ifrdat;
	if (ioctl(s, SIOCGIFDATA, (caddr_t)&ifr) == -1)
		ret = 0;
	if (close(s))
		err(1, "close");

	return (ret);
@


1.52
log
@pflogd contained the same "privsep error" as tcpdump -- assuming that
it can ioctl()'s against a bpf device node.  Privsep that operation
via a message to the parent process.  Unfortunately "rpath wpath cpath"
is still needed due to SIGHUP handling, but I have asked canacar the
expert to look into this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.51 2015/02/07 02:09:13 deraadt Exp $	*/
d60 1
a60 1
volatile sig_atomic_t gotsig_close, gotsig_alrm, gotsig_hup, gotsig_usr1;
a73 1
void  log_pcap_stats(void);
a83 1
void  sig_usr1(int);
a180 6
sig_usr1(int sig)
{
	gotsig_usr1 = 1;
}

void
a551 13
void
log_pcap_stats(void)
{
	struct pcap_stat pstat;

	if (priv_pcap_stats(&pstat) < 0)
		logmsg(LOG_WARNING, "Reading stats: error");
	else
		logmsg(LOG_NOTICE,
			"%u packets received, %u/%u dropped (kernel/pflogd)",
			pstat.ps_recv, pstat.ps_drop, packets_dropped);
}

a649 1
	signal(SIGUSR1, sig_usr1);
a704 5

		if (gotsig_usr1) {
			log_pcap_stats();
			gotsig_usr1 = 0;
		}
a713 1
	log_pcap_stats();
@


1.51
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.50 2014/11/20 15:22:39 tedu Exp $	*/
d564 3
a566 2
	if (pcap_stats(hpcap, &pstat) < 0)
		logmsg(LOG_WARNING, "Reading stats: %s", pcap_geterr(hpcap));
d658 6
@


1.50
log
@remove sys/file.h includes in favor of fcntl.h where needed.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.49 2012/11/06 02:50:47 lteo Exp $	*/
d608 1
a608 1
			Xflag++;
@


1.49
log
@Ensure that if_exists() always closes its socket before returning.

Also fix a bug where the return value of if_exists() was not checked
correctly if the interface disappears while pflogd is running.

ok beck henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.48 2012/03/05 11:50:16 henning Exp $	*/
a34 1
#include <sys/file.h>
@


1.48
log
@fix format string:
use %zu for size_t and %d for signed ints
first one triggered by a mail from joerg @@ netbsd, thanks.
ok millert dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.47 2009/11/03 20:47:41 deraadt Exp $	*/
d206 1
a206 1
	int s;
d218 1
a218 1
		return (0);
d222 1
a222 1
	return (1);
d693 1
a693 1
			if (!if_exists(interface) == -1) {
@


1.47
log
@Get rid of pflogd.pid because the privsep child cannot delete the pidfile;
use pkill(1) in /etc/newsyslog.conf instead
together with otto and suggestions from tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.46 2008/10/22 08:16:49 henning Exp $	*/
d526 1
a526 1
		logmsg(LOG_NOTICE, "invalid size %u (%u/%u), packet dropped",
@


1.46
log
@log pcap stats upon SIGUSR1; ok canacar
From: Dave Harrison <dave@@nullcube.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.45 2007/06/06 14:11:26 henning Exp $	*/
d160 2
a161 2
	fprintf(stderr, " [-i interface] [-p pidfile]\n");
	fprintf(stderr, "              [-s snaplen] [expression]\n");
a578 1
	char *pidf = NULL;
d584 1
a584 1
	while ((ch = getopt(argc, argv, "Dxd:f:i:p:s:")) != -1) {
a599 3
		case 'p':
			pidf = optarg;
			break;
a634 1
		pidfile(pidf);
@


1.45
log
@fix oups, mlist@@scapa.dnsalias.net
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.44 2007/06/06 09:40:48 henning Exp $	*/
d61 1
a61 1
volatile sig_atomic_t gotsig_close, gotsig_alrm, gotsig_hup;
d75 1
d86 1
d184 6
d561 12
a575 1
	struct pcap_stat pstat;
d670 1
d726 5
d740 1
a740 7
	if (pcap_stats(hpcap, &pstat) < 0)
		logmsg(LOG_WARNING, "Reading stats: %s", pcap_geterr(hpcap));
	else
		logmsg(LOG_NOTICE,
		    "%u packets received, %u/%u dropped (kernel/pflogd)",
		    pstat.ps_recv, pstat.ps_drop, packets_dropped);

@


1.44
log
@reverse logic of if_exists so that if_exists(interface) is true if
interface exists and !if_exists(interface) is when it doesn't
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.43 2007/06/04 13:55:24 henning Exp $	*/
d608 1
a608 1
		warn(1, "Failed to initialize: %s", interface);
@


1.43
log
@use warn() where warn() is intended, not err()
exit nonzero if the inetrface does not exist
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.42 2007/06/02 20:38:58 henning Exp $	*/
d202 1
a202 1
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
d210 1
a210 1
		return (-1);
d214 1
a214 1
	return (0);
d607 2
a608 2
	if (if_exists(interface)) {
		warn("Failed to initialize: %s", interface);
d678 1
a678 1
			if (if_exists(interface) == -1) {
@


1.42
log
@do not shadow globals (in if_exists)
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.41 2007/06/02 20:38:14 henning Exp $	*/
d557 1
a557 1
	int ch, np, Xflag = 0;
d562 2
d608 1
a608 1
		err(1, "Failed to initialize: %s", interface);
d681 1
d725 1
a725 1
	return (0);
@


1.41
log
@on pcap error, check wether the interface went away and exit if it did.
spinning and flooding syslog in that case was not so nice.
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.40 2007/05/27 20:07:42 jdixon Exp $	*/
d196 1
a196 1
if_exists(char *interface)
d205 1
a205 1
	if (strlcpy(ifr.ifr_name, interface, sizeof(ifr.ifr_name)) >=
@


1.40
log
@Complain to stderr if cloned pflog interface doesn't exist.  Previously only logged LOG_ERR to syslog.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.39 2007/04/07 07:48:50 jmc Exp $	*/
d209 1
a209 2
	if (ioctl(s, SIOCGIFDATA, (caddr_t)&ifr) == -1) {
		logmsg(LOG_ERR, "Failed to initialize: %s", interface);
a210 1
	}
d607 1
d675 6
a680 1
		if (np < 0)
d682 1
@


1.39
log
@- use .Bk/.Ek to avoid SYNOPSIS splitting
- put -p in the correct place
- sync the -p argument name and tweak its description
- add -p to usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.38 2007/04/06 16:30:49 canacar Exp $	*/
d37 2
d47 1
d76 1
d196 24
d605 7
@


1.38
log
@Adds a pidfile argument to pflogd so that individual
instances can be rotated via newsyslog.
From Berk Demir < bdd at mindcast org >
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.37 2006/10/26 13:34:47 jmc Exp $	*/
d154 2
a155 2
	fprintf(stderr, " [-i interface] [-s snaplen]\n");
	fprintf(stderr, "              [expression]\n");
@


1.37
log
@- sort options
- sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.36 2006/10/25 20:20:19 henning Exp $	*/
d534 1
d538 1
a538 1
	while ((ch = getopt(argc, argv, "Dxd:f:i:s:")) != -1) {
d554 3
d584 1
a584 1
		pidfile(NULL);
@


1.36
log
@allow pflogd to listen on alternate pflog interfaces
"Berk D. Demir" <bdd@@mindcast.org> sent a diff in private, and then it
evolved quite a bit... ok djm canacar berk
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.35 2006/01/15 16:38:04 canacar Exp $	*/
d153 2
a154 2
	fprintf(stderr, "usage: pflogd [-Dx] [-d delay] [-i interface]");
	fprintf(stderr, " [-f filename] [-s snaplen]\n");
@


1.35
log
@If the log file is invalid/incompatible, try to rename the bad log file
and continue with a new name instead of suspending.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.34 2005/07/04 22:35:48 deraadt Exp $	*/
d105 3
a107 2
	setproctitle("[%s] -s %d -f %s",
            suspended ? "suspended" : "running", cur_snaplen, filename);
d153 3
a155 2
	fprintf(stderr, "usage: pflogd [-Dx] [-d delay] [-f filename] ");
	fprintf(stderr, "[-s snaplen] [expression]\n");
d537 1
a537 1
	while ((ch = getopt(argc, argv, "Dxd:s:f:")) != -1) {
d549 3
@


1.34
log
@do not whack errno before using it; Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.33 2005/02/09 12:09:30 henning Exp $	*/
d76 1
a76 1
int   reset_dump(void);
d85 2
d233 19
a251 1
reset_dump(void)
d273 1
a273 1
		return (1);
d280 1
a280 1
		return (1);
d285 1
a285 1
		return (1);
d292 1
a292 1
		return (1);
d314 1
a314 1
			return (1);
a316 1
		/* XXX move file and continue? */
d318 5
a360 1
		logmsg(LOG_ERR, "Invalid/incompatible log file, move it away");
d620 1
a620 1
	if (reset_dump()) {
d638 1
a638 1
			if (reset_dump()) {
d649 2
@


1.33
log
@missing tzset(), noticed by Chris Kuethe <chris.kuethe@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.32 2005/01/08 18:51:18 canacar Exp $	*/
d258 1
a259 1
		logmsg(LOG_ERR, "Error: %s: %s", filename, strerror(errno));
d263 1
a264 1
		logmsg(LOG_ERR, "Error: %s: %s", filename, strerror(errno));
d270 1
a271 1
		logmsg(LOG_ERR, "Failed to set output buffers");
d280 1
a280 2
			if (set_snaplen(snaplen)) {
				fclose(fp);
a282 1
			}
@


1.32
log
@Use the handler specified in phandler instead of always using
dump_packet. Report and patch from Peter Postma, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.31 2004/09/17 07:11:55 deraadt Exp $	*/
d557 1
@


1.31
log
@ugly spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.30 2004/08/08 19:04:25 deraadt Exp $	*/
d609 1
a609 1
		    dump_packet, (u_char *)dpcap);
@


1.30
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.29 2004/05/23 19:00:26 deraadt Exp $	*/
d393 2
a395 1
		off_t pos = ftello(f);
@


1.29
log
@use strtonum instead of atoi; dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.28 2004/04/28 06:59:58 deraadt Exp $	*/
d492 1
a492 1
 append:	
@


1.28
log
@fd leaks; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.27 2004/02/13 19:01:57 otto Exp $	*/
d509 1
d519 2
a520 2
			delay = atoi(optarg);
			if (delay < 5 || delay > 60*60)
d527 2
a528 1
			snaplen = atoi(optarg);
d531 1
a531 1
			if (snaplen > PFLOGD_MAXSNAPLEN)
@


1.27
log
@cleanup signal handling; close descriptors.
ok avsm@@ millert@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.26 2004/01/16 10:45:49 jmc Exp $	*/
d258 1
d263 1
d270 1
d281 1
@


1.26
log
@- standard option order
- sync usage()
- new sentence, new line
- Dv (not Va) for signals
- other nits

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.25 2004/01/15 20:15:14 canacar Exp $	*/
d505 2
@


1.25
log
@Try to preserve the integrity of the log file in case of errors/unexpected
shutdowns etc. Also check logfile integrity on startup and suspend
logging if an inconsistency is detected.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.24 2003/10/22 19:53:15 deraadt Exp $	*/
d150 1
a150 1
	fprintf(stderr, "usage: pflogd [-D] [-d delay] [-f filename] ");
@


1.24
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.23 2003/10/22 18:51:55 canacar Exp $	*/
d52 1
a52 1
pcap_dumper_t *dpcap;
d55 2
a56 1
int snaplen = DEF_SNAPLEN;
d69 4
a72 1
char *copy_argv(char * const *argv);
d74 2
a75 1
void  logmsg(int priority, const char *message, ...);
d77 3
d85 21
a192 1
		hpcap = NULL;
d205 1
a205 1
	snaplen = pcap_snapshot(hpcap);
d217 14
d239 2
a240 1
		return (1);
d242 3
a244 2
		pcap_dump_close(dpcap);
		dpcap = 0;
d266 5
a270 1
	dpcap = (pcap_dumper_t *)fp;
d275 1
a275 1
		if (snaplen != pcap_snapshot(hpcap)) {
d277 1
a277 1
			if (priv_set_snaplen(snaplen)) {
a290 1
			dpcap = NULL;
d292 1
a292 1
			return (-1);
d294 4
a297 1
		return (0);
d300 15
d316 1
a316 1
	 * XXX Must read the file, compare the header against our new
d318 4
a321 1
	 * that we generate a correct file.
d324 43
a366 9
	if (fread((char *)&hdr, sizeof(hdr), 1, fp) == 1) {
		if (hdr.magic != TCPDUMP_MAGIC ||
		    hdr.version_major != PCAP_VERSION_MAJOR ||
		    hdr.version_minor != PCAP_VERSION_MINOR ||
		    hdr.linktype != hpcap->linktype) {
			logmsg(LOG_ERR,
			    "Invalid/incompatible log file, move it away");
			fclose(fp);
			return (1);
d368 29
a396 9
		if (hdr.snaplen != snaplen) {
			logmsg(LOG_WARNING,
			    "Existing file has different snaplen %u, using it",
			    hdr.snaplen);
			if (priv_set_snaplen(hdr.snaplen)) {
				logmsg(LOG_WARNING,
				    "Failed, using old settings, offset %llu",
				    (unsigned long long) st.st_size);
			}
d398 1
d401 41
a441 1
	(void) fseek(fp, 0L, SEEK_END);
d445 54
d503 2
a504 1
	int ch, np;
d506 1
a506 1
	while ((ch = getopt(argc, argv, "Dd:s:f:")) != -1) {
d523 5
d569 1
d578 11
d590 7
a596 4
		logmsg(LOG_ERR, "Failed to open log file %s", filename);
		pcap_close(hpcap);
		exit(1);
	}
d599 2
a600 1
		np = pcap_dispatch(hpcap, PCAP_NUM_PKTS, pcap_dump, (u_char *)dpcap);
d608 3
a610 2
				logmsg(LOG_ERR, "Failed to open log file!");
				break;
d616 2
a617 10
			/* XXX pcap_dumper is an incomplete type which libpcap
			 * casts to a FILE* currently.  For now it is safe to
			 * make the same assumption, however this may change
			 * in the future.
			 */
			if (dpcap) {
				if (fflush((FILE *)dpcap) == EOF) {
					break;
				}
			}
d623 6
a628 3
	logmsg(LOG_NOTICE, "Exiting due to signal");
	if (dpcap)
		pcap_dump_close(dpcap);
d633 3
a635 2
		logmsg(LOG_NOTICE, "%u packets received, %u dropped",
		    pstat.ps_recv, pstat.ps_drop);
@


1.23
log
@privilege seperated pflogd

_pflogd user and group must be created for proper operation.

ok frantzen@@ henning@@ mcbride@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.22 2003/09/26 16:14:33 deraadt Exp $	*/
d340 1
a340 1
	/* Privilege separation begins here */	
@


1.22
log
@Walking up to a firewall box which had the console logged in, to see
the entire screen full of "Reopened logfile" is CLEAR and OBVIOUS reason
that that message is UTTERLY USELESS and is wiping important stuff off
the screen.
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.21 2003/08/22 21:50:34 david Exp $	*/
d34 1
d49 1
a49 9

#define DEF_SNAPLEN 116		/* default plus allow for larger header of pflog */
#define PCAP_TO_MS 500		/* pcap read timeout (ms) */
#define PCAP_NUM_PKTS 1000	/* max number of packets to process at each loop */
#define PCAP_OPT_FIL 0		/* filter optimization */
#define FLUSH_DELAY 60		/* flush delay */

#define PFLOGD_LOG_FILE		"/var/log/pflog"
#define PFLOGD_DEFAULT_IF	"pflog0"
d144 14
a160 3
	struct bpf_program bprog;
	pcap_t *oldhpcap = hpcap;

d164 1
a164 1
		hpcap = oldhpcap;
a167 7
	if (pcap_compile(hpcap, &bprog, filter, PCAP_OPT_FIL, 0) < 0)
		logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
	else if (pcap_setfilter(hpcap, &bprog) < 0)
		logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
	if (filter != NULL)
		free(filter);

d171 1
a171 1
		hpcap = oldhpcap;
d175 1
a175 2
	if (oldhpcap)
		pcap_close(oldhpcap);
d178 7
d193 1
a193 1
	int tmpsnap;
d207 6
a212 1
	fp = fopen(filename, "a+");
d214 1
a214 3
		snprintf(hpcap->errbuf, PCAP_ERRBUF_SIZE, "%s: %s",
		    filename, pcap_strerror(errno));
		logmsg(LOG_ERR, "Error: %s", pcap_geterr(hpcap));
d218 1
a218 3
		snprintf(hpcap->errbuf, PCAP_ERRBUF_SIZE, "%s: %s",
		    filename, pcap_strerror(errno));
		logmsg(LOG_ERR, "Error: %s", pcap_geterr(hpcap));
d229 3
a231 4
			if (init_pcap()) {
				logmsg(LOG_ERR, "Failed to initialize");
				if (hpcap == NULL) return (-1);
				logmsg(LOG_NOTICE, "Using old settings");
d265 1
a265 1
		    }
d268 1
a268 1
			    "Existing file specifies a snaplen of %u, using it",
d270 4
a273 9
			tmpsnap = snaplen;
			snaplen = hdr.snaplen;
			if (init_pcap()) {
				logmsg(LOG_ERR, "Failed to re-initialize");
				if (hpcap == 0)
					return (-1);
				logmsg(LOG_NOTICE,
					"Using old settings, offset: %llu",
					(unsigned long long)st.st_size);
a274 1
			snaplen = tmpsnap;
d327 1
a327 7
	signal(SIGTERM, sig_close);
	signal(SIGINT, sig_close);
	signal(SIGQUIT, sig_close);
	signal(SIGALRM, sig_alrm);
	signal(SIGHUP, sig_hup);
	alarm(delay);

d334 1
d339 14
@


1.21
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.20 2003/05/14 08:56:12 canacar Exp $	*/
a365 1
			logmsg(LOG_NOTICE, "Reopened logfile");
@


1.20
log
@pflogd now uses the new pflog link type. Trying to append to an existing
old-style logfile will fail. Move away old log files.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.19 2003/04/23 22:44:53 deraadt Exp $	*/
d201 1
a201 1
	 * Basically reimpliment pcap_dump_open() because it truncates
@


1.19
log
@most programs do not syslog at startup.  especially this one
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.18 2003/03/11 02:35:34 kjc Exp $	*/
d49 1
a49 1
#define DEF_SNAPLEN 96		/* default plus allow for larger header of pflog */
d254 10
a263 4
		if (hdr.magic == TCPDUMP_MAGIC &&
		    hdr.version_major == PCAP_VERSION_MAJOR &&
		    hdr.version_minor == PCAP_VERSION_MINOR &&
		    hdr.snaplen != snaplen) {
@


1.18
log
@always compile and set pcap filters even when filters are not specified.
bpf implements snaplen by filters and captures full packets when filters
are not set.

ok deraadt@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.17 2003/03/01 06:11:20 cloder Exp $	*/
a181 2
	logmsg(LOG_NOTICE, "Listening on %s, logging to %s, snaplen %d",
	    interface, filename, snaplen);
@


1.17
log
@Add ANSI prototypes.  Get rid of shadow warnings.  Use correct
printf format specifiers where needed.  Clarify one comment.
Now compiles with -Wmissing-prototypes -Wshadow, and this is
reflected in the Makefile.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.16 2002/11/30 23:02:10 deraadt Exp $	*/
d164 5
a168 5
	if (filter != NULL) {
		if (pcap_compile(hpcap, &bprog, filter, PCAP_OPT_FIL, 0) < 0)
			logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
		else if (pcap_setfilter(hpcap, &bprog) < 0)
			logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
a169 1
	}
@


1.16
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.15 2002/11/30 19:36:05 deraadt Exp $	*/
d73 1
a73 1
int delay = FLUSH_DELAY;
d76 8
a83 1
void logmsg(int priority, const char *message, ...);
d88 1
a88 1
	int len = 0, n;
d96 1
a96 1
	if (len <= 0)
d125 1
a125 1
void
d134 1
a134 1
sig_close(int signal)
d140 1
a140 1
sig_hup(int signal)
d146 1
a146 1
sig_alrm(int signal)
d262 1
a262 1
			    "Existing file specifies a snaplen of %d, using it",
d271 2
a272 2
					"Using old settings, offset: %d",
					st.st_size);
d368 10
a377 2
			if (dpcap)
				fflush((FILE *)dpcap);		/* XXX */
d390 1
a390 1
		logmsg(LOG_NOTICE, "%d packets received, %d dropped",
@


1.15
log
@do not syslog with extra newline
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.14 2002/10/17 09:12:04 dhartmei Exp $	*/
d112 1
a112 1
		fprintf("\n");
@


1.14
log
@Style nits and missing free(), from david@@phobia.ms
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.13 2002/09/03 18:28:49 deraadt Exp $	*/
d110 1
a110 1
	if (log_debug)
d112 2
a113 1
	else
d152 1
a152 1
		logmsg(LOG_ERR, "Failed to initialize: %s\n", errbuf);
d159 1
a159 1
			logmsg(LOG_WARNING, "%s\n", pcap_geterr(hpcap));
d161 1
a161 1
			logmsg(LOG_WARNING, "%s\n", pcap_geterr(hpcap));
d166 1
a166 1
		logmsg(LOG_ERR, "Invalid datalink type\n");
d176 2
a177 2
	logmsg(LOG_NOTICE, "Listening on %s, logging to %s, snaplen %d\n",
		interface, filename, snaplen);
d204 1
a204 1
		logmsg(LOG_ERR, "Error: %s\n", pcap_geterr(hpcap));
d210 1
a210 1
		logmsg(LOG_ERR, "Error: %s\n", pcap_geterr(hpcap));
d220 1
a220 1
			logmsg(LOG_NOTICE, "Using snaplen %d\n", snaplen);
d222 1
a222 1
				logmsg(LOG_ERR, "Failed to initialize\n");
d224 1
a224 1
				logmsg(LOG_NOTICE, "Using old settings\n");
d260 1
a260 1
				logmsg(LOG_ERR, "Failed to re-initialize\n");
d264 1
a264 1
					"Using old settings, offset: %d\n",
d313 1
a313 1
				strerror(errno));
d334 1
a334 1
		logmsg(LOG_ERR, "Exiting, init failure\n");
d339 1
a339 1
		logmsg(LOG_ERR, "Failed to open log file %s\n", filename);
d347 1
a347 1
			logmsg(LOG_NOTICE, "%s\n", pcap_geterr(hpcap));
d353 1
a353 1
				logmsg(LOG_ERR, "Failed to open log file!\n");
d356 1
a356 1
			logmsg(LOG_NOTICE, "Reopened logfile\n");
d368 1
a368 1
	logmsg(LOG_NOTICE, "Exiting due to signal\n");
d373 1
a373 1
		logmsg(LOG_WARNING, "Reading stats: %s\n", pcap_geterr(hpcap));
d375 1
a375 1
		logmsg(LOG_NOTICE, "%d packets received, %d dropped\n",
@


1.13
log
@use sig_atomic_t; cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.12 2002/05/23 09:51:12 deraadt Exp $	*/
d68 1
a68 1
char *filter = 0;
d85 1
a85 1
		return NULL;
d90 1
a90 1
		return NULL;
d94 1
a94 1
		return NULL;
d101 1
a101 1
	return buf;
d156 1
a156 1
	if (filter) {
d161 1
d189 1
a189 1
		return 1;
d204 1
a204 1
		return 1;
d210 1
a210 1
		return 1;
d328 1
a328 1
		if (filter == 0)
d380 1
a380 1
	return 0;
@


1.12
log
@minor KNF encountered while doing yet another boring 4AM source code audit...
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.11 2002/05/08 17:28:34 jasoni Exp $	*/
d63 2
a64 1
int gotsig_close, gotsig_alrm, gotsig_hup;
@


1.11
log
@add a newline after pcap error string (as pcap_geterr() doesn't).
- ok dhartmei@@ (a long time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.10 2002/01/21 07:46:09 dhartmei Exp $	*/
d110 1
a110 1
		vfprintf(stderr,message,ap);
d112 1
a112 1
		vsyslog(pri,message,ap);
d150 1
a150 1
		logmsg(LOG_ERR, "Failed to initialize: %s\n",errbuf);
d344 1
a344 1
			logmsg(LOG_NOTICE, "%s\n",pcap_geterr(hpcap));
@


1.10
log
@deamon -> daemon, from Alexander Yurchenko
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.9 2001/12/01 23:27:23 miod Exp $	*/
d157 1
a157 1
			logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
d159 1
a159 1
			logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
@


1.9
log
@Use pidfile() instead of doing the equivalent thing by hand, and sometimes
forgetting to unlink the pid file at exit.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.8 2001/10/10 14:30:08 mpech Exp $	*/
d309 1
a309 1
			logmsg(LOG_WARNING, "Failed to become deamon: %s",
@


1.8
log
@umask. spotted by form@@

deraadt@@, dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.7 2001/08/29 17:42:28 deraadt Exp $	*/
d47 1
a54 1
#define PFLOGD_PID_FILE		"/var/run/pflogd.pid"
a66 1
char *pidfile = PFLOGD_PID_FILE;
a276 1
	FILE *fp;
d312 1
a312 5
		fp = fopen(pidfile, "w");
		if (fp != NULL) {
			fprintf(fp, "%d\n", getpid());
			fclose(fp);
		}
@


1.7
log
@kill the -i option; it just causes all sorts of grief; canacar@@eee.metu.edu.tr
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.6 2001/08/24 19:48:37 deraadt Exp $	*/
d320 2
@


1.6
log
@move back to requested snaplen after SIGHUP; canacar@@eee.metu.edu.tr
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.5 2001/08/24 19:46:32 deraadt Exp $	*/
d120 1
a120 1
	fprintf(stderr, "usage: pflogd [-D] [-d delay] [-f filename] [-i interface] ");
d280 1
a280 1
	while ((ch = getopt(argc, argv, "Dd:i:s:f:")) != -1) {
a288 3
			break;
		case 'i':
			interface = optarg;
@


1.5
log
@rearrange so that snaplen cannot be changed; canacar@@eee.metu.edu.tr
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.4 2001/08/23 04:07:33 deraadt Exp $	*/
d184 1
d217 8
d255 1
d265 1
@


1.4
log
@fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.3 2001/08/23 04:06:12 deraadt Exp $	*/
d144 36
d182 1
a182 1
        struct pcap_file_header hdr;
d188 1
a188 1
	if (dpcap)
d190 2
d197 1
a197 1
	fp = fopen(filename, "a");
a211 2
	if (st.st_size != 0)
		return (0);
d215 18
a232 1
	/* 
d247 8
d257 1
a258 15

	hdr.magic = TCPDUMP_MAGIC;
	hdr.version_major = PCAP_VERSION_MAJOR;
	hdr.version_minor = PCAP_VERSION_MINOR;

	hdr.thiszone = hpcap->tzoff;
	hdr.snaplen = hpcap->snapshot;
	hdr.sigfigs = 0;
	hdr.linktype = hpcap->linktype;

	if (fwrite((char *)&hdr, sizeof(hdr), 1, fp) != 1) {
		dpcap = NULL;
		fclose(fp);
		return (-1);
	}
a264 1
	struct bpf_program bprog;
d326 2
a327 16
	hpcap = pcap_open_live(interface, snaplen, 1, PCAP_TO_MS, errbuf);
	if (hpcap == NULL) {
		logmsg(LOG_ERR, "Failed to initialize: %s\n",errbuf);
		exit(1);
	}

	if (filter) {
		if (pcap_compile(hpcap, &bprog, filter, PCAP_OPT_FIL, 0) < 0)
			logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
		else if (pcap_setfilter(hpcap, &bprog) < 0)
			logmsg(LOG_WARNING, "%s", pcap_geterr(hpcap));
	}

	if (pcap_datalink(hpcap) != DLT_PFLOG) {
		logmsg(LOG_ERR, "Invalid datalink type\n");
		pcap_close(hpcap);
a335 3

	logmsg(LOG_NOTICE, "Listening on %s, logging to %s, snaplen %d\n",
	    interface, filename, snaplen);
@


1.3
log
@do not permit snaplen change on an active log file
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.2 2001/08/22 14:49:37 deraadt Exp $	*/
d120 2
a121 2
	fprintf(stderr, "usage: pflogd [-a] [-i interface] [-f filename] ");
	fprintf(stderr, "[-s snaplen] [tcpdump filter expression]\n");
@


1.2
log
@properly handle empty log file
@
text
@d1 1
a1 1
/*	$OpenBSD: pflogd.c,v 1.1 2001/08/21 22:29:14 deraadt Exp $	*/
d178 20
@


1.1
log
@pflogd; work by canacar@@eee.metu.edu.tr and myself
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a46 1
#include "util.h"
d172 3
a174 1
	if (st.st_size == 0)
d187 3
a189 1
	if (fwrite((char *)&hdr, sizeof(hdr), 1, fp) != 1)
d191 1
@

