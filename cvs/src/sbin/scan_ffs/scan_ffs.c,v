head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.14.0.24
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.22
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.20
	OPENBSD_5_0:1.14.0.18
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.16
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.14
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.10
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.21
date	2015.11.23.19.19.30;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Cz19p5I1S6mVZIjV;

1.20
date	2015.10.11.04.33.17;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	F8zDU4ZvfD9WstsK;

1.19
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	F55lwc3gS4GN2mLs;

1.18
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.11.16.42.05;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.04.02.05.22.04;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.22.19.04.13;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.28.19.17.56;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.16.19.13.03;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.02.21.44.58;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.00.33.34;	author weingart;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.07.18.26.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.26.17.36.41;	author weingart;	state Exp;
branches;
next	1.5;

1.5
date	99.06.08.19.13.53;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.03.28.01.18.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.02.05.17.18.30;	author weingart;	state Exp;
branches;
next	1.2;

1.2
date	98.02.04.20.54.48;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.02.04.20.37.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@/*	$OpenBSD: scan_ffs.c,v 1.20 2015/10/11 04:33:17 deraadt Exp $	*/

/*
 * Copyright (c) 1998 Niklas Hallqvist, Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/fcntl.h>
#include <ufs/ffs/fs.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <limits.h>
#include <err.h>
#include <util.h>

#define SBCOUNT 64		/* XXX - Should be configurable */

/* Flags to control ourselves... */
#define FLAG_VERBOSE		1
#define FLAG_SMART		2
#define FLAG_LABELS		4

static void usage(void);

static int
ufsscan(int fd, daddr_t beg, daddr_t end, int flags)
{
	static char lastmount[MAXMNTLEN];
	static u_int8_t buf[SBSIZE * SBCOUNT];
	struct fs *sb;
	daddr_t blk, lastblk;
	int n;

	lastblk = -1;
	memset(lastmount, 0, MAXMNTLEN);

	for (blk = beg; blk <= ((end<0)?blk:end); blk += (SBCOUNT*SBSIZE/512)){
		memset(buf, 0, SBSIZE * SBCOUNT);
		if (lseek(fd, (off_t)blk * 512, SEEK_SET) < 0)
		    err(1, "lseek");
		if (read(fd, buf, SBSIZE * SBCOUNT) < 0)
			err(1, "read");

		for (n = 0; n < (SBSIZE * SBCOUNT); n += 512){
			sb = (struct fs*)(&buf[n]);
			if (sb->fs_magic == FS_MAGIC) {
				if (flags & FLAG_VERBOSE)
					printf("block %lld id %x,%x size %d\n",
					    (long long)(blk + (n/512)),
					    sb->fs_id[0], sb->fs_id[1],
					    sb->fs_ffs1_size);

				if (((blk+(n/512)) - lastblk) == (SBSIZE/512)) {
					if (flags & FLAG_LABELS ) {
						printf("X: %lld %lld 4.2BSD %d %d %d # %s\n",
						    ((off_t)sb->fs_ffs1_size *
						    sb->fs_fsize / 512),
						    (long long)(blk + (n/512) -
						    (2*SBSIZE/512)),
						    sb->fs_fsize, sb->fs_bsize,
						    sb->fs_cpg, lastmount);
					} else {
						/* XXX 2038 */
						time_t t = sb->fs_ffs1_time;

						printf("ffs at %lld size %lld "
						    "mount %s time %s",
						    (long long)(blk+(n/512) -
						    (2*SBSIZE/512)),
						    (long long)(off_t)sb->fs_ffs1_size *
						    sb->fs_fsize,
						    lastmount, ctime(&t));
					}

					if (flags & FLAG_SMART) {
						off_t size = (off_t)sb->fs_ffs1_size *
						    sb->fs_fsize;

						if ((n + size) < (SBSIZE * SBCOUNT))
							n += size;
						else {
							blk += (size/512 -
							    (SBCOUNT*SBCOUNT));
							break;
						}
					}
				}

				/* Update last potential FS SBs seen */
				lastblk = blk + (n/512);
				memcpy(lastmount, sb->fs_fsmnt, MAXMNTLEN);
			}
		}
	}
	return(0);
}


static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-lsv] [-b begin] [-e end] device\n",
	    __progname);
	exit(1);
}


int
main(int argc, char *argv[])
{
	int ch, fd, flags = 0;
	daddr_t beg = 0, end = -1;
	const char *errstr;

	if (pledge("stdio rpath disklabel", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "lsvb:e:")) != -1)
		switch(ch) {
		case 'b':
			beg = strtonum(optarg, 0, LLONG_MAX, &errstr);
			if (errstr)
				errx(1, "%s: %s", optarg, errstr);
			break;
		case 'e':
			end = strtonum(optarg, 0, LLONG_MAX, &errstr);
			if (errstr)
				errx(1, "%s: %s", optarg, errstr);
			break;
		case 'v':
			flags |= FLAG_VERBOSE;
			break;
		case 's':
			flags |= FLAG_SMART;
			break;
		case 'l':
			flags |= FLAG_LABELS;
			break;
		default:
			usage();
			/* NOTREACHED */
	}
	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	fd = opendev(argv[0], O_RDONLY, OPENDEV_PART, NULL);
	if (fd < 0)
		err(1, "%s", argv[0]);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	return (ufsscan(fd, beg, end, flags));
}
@


1.20
log
@After the disk is opened, this can pledge "stdio".
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.19 2015/01/20 18:22:21 deraadt Exp $	*/
d140 3
@


1.19
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.18 2015/01/16 06:40:00 deraadt Exp $	*/
d175 3
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.17 2013/11/01 17:36:19 krw Exp $	*/
a27 1
#include <sys/param.h>	/* MAXFRAG */
@


1.17
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.16 2013/06/11 16:42:05 deraadt Exp $	*/
d28 1
a29 1
#include <sys/param.h>
d37 1
@


1.16
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.15 2013/04/02 05:22:04 deraadt Exp $	*/
d73 3
a75 2
					    blk + (n/512), sb->fs_id[0],
					    sb->fs_id[1], sb->fs_ffs1_size);
d82 2
a83 1
						    blk+(n/512)-(2*SBSIZE/512),
d92 2
a93 1
						    blk+(n/512)-(2*SBSIZE/512),
@


1.15
log
@handle large time_t
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.14 2007/06/22 19:04:13 otto Exp $	*/
d50 1
a50 1
ufsscan(int fd, daddr64_t beg, daddr64_t end, int flags)
d55 1
a55 1
	daddr64_t blk, lastblk;
d135 1
a135 1
	daddr64_t beg = 0, end = -1;
@


1.14
log
@daddr_t -> daddr64_t; ok pedro@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.13 2007/03/19 13:27:47 pedro Exp $	*/
d85 3
d93 1
a93 1
						    lastmount, ctime(&sb->fs_ffs1_time));
@


1.13
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.12 2006/06/28 19:17:56 pedro Exp $	*/
d50 1
a50 1
ufsscan(int fd, daddr_t beg, daddr_t end, int flags)
d55 1
a55 1
	daddr_t blk, lastblk;
d72 1
a72 1
					printf("block %d id %x,%x size %d\n",
d78 2
a79 2
						printf("X: %d %d 4.2BSD %d %d %d # %s\n",
						    (daddr_t)((off_t)sb->fs_ffs1_size *
d85 1
a85 1
						printf("ffs at %d size %lld "
d132 2
a133 1
	daddr_t beg = 0, end = -1;
d138 3
a140 1
			beg = atoi(optarg);
d143 3
a145 1
			end = atoi(optarg);
@


1.12
log
@Use argv[0] where argv[0] is meant, Nicholas Marriott
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.11 2004/02/16 19:13:03 deraadt Exp $	*/
d74 1
a74 1
					    sb->fs_id[1], sb->fs_size);
d79 1
a79 1
						    (daddr_t)((off_t)sb->fs_size *
d88 1
a88 1
						    (long long)(off_t)sb->fs_size *
d90 1
a90 1
						    lastmount, ctime(&sb->fs_time));
d94 1
a94 1
						off_t size = (off_t)sb->fs_size *
@


1.11
log
@no need for extra param; Mathias@@enloco.net
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.10 2003/07/02 21:44:58 deraadt Exp $	*/
d163 1
a163 1
		err(1, "%s", argv[1]);
@


1.10
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.9 2003/06/03 00:33:34 weingart Exp $	*/
d47 2
d118 1
a118 1
usage(int code)
d124 1
a124 1
	exit(code);
d152 1
a152 1
			usage(1);
d159 1
a159 1
		usage(1);
@


1.9
log
@Kill clause 3 & 4 on some of my code.
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.8 2002/07/03 22:32:33 deraadt Exp $	*/
d47 1
a47 1
int
d115 1
a115 1
void
@


1.8
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.7 2001/07/07 18:26:21 deraadt Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.6 2001/01/26 17:36:41 weingart Exp $	*/
d53 1
a53 4
ufsscan(fd, beg, end, flags)
	int fd;
	daddr_t beg, end;
	int flags;
d64 1
a64 1
	for(blk = beg; blk <= ((end<0)?blk:end); blk += (SBCOUNT*SBSIZE/512)){
d71 1
a71 1
		for(n = 0; n < (SBSIZE * SBCOUNT); n += 512){
d82 2
a83 1
						    (daddr_t)((off_t)sb->fs_size * sb->fs_fsize / 512),
d88 2
a89 1
						printf("ffs at %d size %lld mount %s time %s",
d91 2
a92 1
						    (long long)(off_t)sb->fs_size * sb->fs_fsize,
d97 2
a98 1
						off_t size = (off_t)sb->fs_size * sb->fs_fsize;
d121 1
a121 2
usage(code)
	int code;
d124 3
a126 1
	(void)fprintf(stderr, "usage: %s [-lsv] [-b begin] [-e end] device\n", __progname);
d132 1
a132 3
main(argc, argv)
	int argc;
	char *argv[];
@


1.6
log
@Small cleanup patch from <mpech@@prosoft.org.lv>.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.5 1999/06/08 19:13:53 niklas Exp $	*/
d90 1
a90 1
						printf("ffs at %d size %qd mount %s time %s",
d92 1
a92 1
						    (off_t)sb->fs_size * sb->fs_fsize,
@


1.5
log
@Some large partition fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.4 1998/03/28 01:18:38 deraadt Exp $	*/
d120 2
a121 1
usage()
d123 3
a125 2
	fprintf(stderr, "usage: scan_ffs [-lsv] [-b begin] [-e end] <device>\n");
	exit(1);
d155 2
a156 1
			usage();
d162 1
a162 1
		usage();
@


1.4
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.3 1998/02/05 17:18:30 weingart Exp $	*/
d69 1
a69 1
		if (lseek(fd, blk * 512, SEEK_SET) < 0)
d85 1
a85 1
						    sb->fs_size * sb->fs_fsize / 512,
d90 1
a90 1
						printf("ffs at %d size %d mount %s time %s",
d92 1
a92 1
						    sb->fs_size * sb->fs_fsize,
d97 1
a97 1
						int size = sb->fs_size * sb->fs_fsize;
@


1.3
log
@special -> device
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.2 1998/02/04 20:54:48 millert Exp $	*/
d38 1
d40 1
d42 1
d58 1
a58 1
	static char *lastmount[MAXMNTLEN];
@


1.2
log
@fix usage string
@
text
@d1 1
a1 1
/*	$OpenBSD: scan_ffs.c,v 1.1 1998/02/04 20:37:14 deraadt Exp $	*/
d119 1
a119 1
	fprintf(stderr, "usage: scan_ffs [-lsv] [-b begin] [-e end] special\n");
@


1.1
log
@very handy program that scans a device for filesystems; from niklas & weingart.
Needs a man page, anyone willing?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 1
a119 1
	fprintf(stderr, "usage: ffsscan [-lsv] [-b begin] [-e end] special\n");
@
