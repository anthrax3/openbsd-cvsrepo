head	1.25;
access;
symbols
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.25
date	2001.05.30.02.11.45;	author deraadt;	state dead;
branches;
next	1.24;

1.24
date	2001.01.30.04.27.58;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.17.05.01.00;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.14.18.56.31;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.10.05.50.27;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.13.23.40.19;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.16.22.34.22;	author kjell;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.01.19.30.00;	author kjell;	state Exp;
branches;
next	1.17;

1.17
date	99.12.15.05.20.25;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	99.07.08.00.05.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.07.08.00.02.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.02.05.05.58.43;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.09.15.09.58.34;	author pattonme;	state Exp;
branches;
next	1.12;

1.12
date	98.01.26.04.13.41;	author dgregor;	state Exp;
branches;
next	1.11;

1.11
date	97.06.23.18.57.23;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.04.06.19.52.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.02.17.09.13.11;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.11.22.23.41;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.10.08.07.33.33;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.07.18.05.08.09;	author dm;	state Exp;
branches;
next	1.5;

1.5
date	96.07.10.03.53.49;	author ccappuc;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.30.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.21.39.54;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.41.30;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.33.36;	author dm;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: fils.c,v 1.24 2001/01/30 04:27:58 kjell Exp $	*/

/*
 * Copyright (C) 1993-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#ifdef  __FreeBSD__
# include <osreldate.h>
#endif
#include <stdio.h>
#include <string.h>
#if !defined(__SVR4) && !defined(__svr4__)
# include <strings.h>
#endif
#include <sys/types.h>
#include <sys/time.h>
#include <sys/param.h>
#include <sys/file.h>
#if defined(STATETOP) && defined(sun) && !defined(__svr4__) && !defined(__SVR4)
#include <sys/select.h>
#endif
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stddef.h>
#include <nlist.h>
#ifdef STATETOP
#include <ctype.h>
#include <ncurses.h>
#endif
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <net/if.h>
#if __FreeBSD_version >= 300000
# include <net/if_var.h>
#endif
#include <netdb.h>
#include <arpa/nameser.h>
#include <resolv.h>
#include <netinet/tcp.h>
#if defined(STATETOP) && !defined(linux)
# include <netinet/ip_var.h>
# include <netinet/tcp_fsm.h>
#endif
#include <netinet/ip_fil_compat.h>
#include <netinet/ip_fil.h>
#include "ipf.h"
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_frag.h>
#include <netinet/ip_state.h>
#include <netinet/ip_auth.h>
#ifdef STATETOP
#include <netinet/ipl.h>
#endif
#include "kmem.h"
#if defined(__NetBSD__) || (__OpenBSD__)
# include <paths.h>
#endif

#if !defined(lint)
static const char sccsid[] = "@@(#)fils.c	1.21 4/20/96 (C) 1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: fils.c,v 2.21.2.7 2000/12/02 00:13:56 darrenr Exp $";
#endif

#define	F_IN	0
#define	F_OUT	1
#define	F_AC	2
static	char	*filters[4] = { "ipfilter(in)", "ipfilter(out)",
				"ipacct(in)", "ipacct(out)" };

int	opts = 0;
#ifdef	USE_INET6
int	use_inet6 = 0;
#endif

#ifdef STATETOP
#define	STSTRSIZE 	80
#define	STGROWSIZE	16

#define	STSORT_PR	0
#define	STSORT_PKTS	1
#define	STSORT_BYTES	2
#define	STSORT_TTL	3
#define	STSORT_MAX	STSORT_TTL
#define	STSORT_DEFAULT	STSORT_BYTES


typedef struct statetop {
	union i6addr	st_src;
	union i6addr	st_dst;
	u_short		st_sport;
	u_short 	st_dport;
	u_char		st_p;
	u_char		st_state[2];
	U_QUAD_T	st_pkts;
	U_QUAD_T	st_bytes;
	u_long		st_age;
} statetop_t;
#endif

char *nlistf = NULL, *memf = NULL;

extern	int	main __P((int, char *[]));
static	void	showstats __P((int, friostat_t *));
static	void	showfrstates __P((int, ipfrstat_t *));
static	void	showlist __P((friostat_t *));
static	void	showipstates __P((int, ips_stat_t *));
static	void	showauthstates __P((int, fr_authstat_t *));
static	void	showgroups __P((friostat_t *));
static	void	Usage __P((char *));
static	void	printlist __P((frentry_t *));
static	char	*get_ifname __P((void *));
static	char	*hostname __P((int, void *));
static	void	parse_ipportstr __P((const char *, struct in_addr *, int *));
#ifdef STATETOP
static	void	topipstates __P((int, struct in_addr, struct in_addr, int, int, int, int, int));
static	char	*ttl_to_string __P((long));
static	int	sort_p __P((const void *, const void *));
static	int	sort_pkts __P((const void *, const void *));
static	int	sort_bytes __P((const void *, const void *));
static	int	sort_ttl __P((const void *, const void *));
#endif

static char *hostname(v, ip)
int v;
void *ip;
{
#ifdef	USE_INET6
	static char hostbuf[MAXHOSTNAMELEN+1];
#endif
	struct in_addr ipa;

	if (v == 4) {
		ipa.s_addr = *(u_32_t *)ip;
		return inet_ntoa(ipa);
	}
#ifdef  USE_INET6
	(void) inet_ntop(AF_INET6, ip, hostbuf, sizeof(hostbuf) - 1);
	hostbuf[MAXHOSTNAMELEN] = '\0';
	return hostbuf;
#else
	return "IPv6";
#endif
}


static void Usage(name)
char *name;
{
#ifdef  USE_INET6
	fprintf(stderr, 
	    "Usage: %s [-6aAfhIinosv] [-d <device>] [-M core]\n", name);
#else
	fprintf(stderr, 
	    "Usage: %s [-aAfhIinosv] [-d <device>] [-M core]\n", name);
#endif
	fprintf(stderr, "       %s -t [-S source address] [-D destination address] [-P protocol] [-T refreshtime] [-C] [-d <device>]\n", name);
	exit(1);
}


int main(argc,argv)
int argc;
char *argv[];
{
	fr_authstat_t	frauthst;
	fr_authstat_t	*frauthstp = &frauthst;
	friostat_t fio;
	friostat_t *fiop=&fio;
	ips_stat_t ipsst;
	ips_stat_t *ipsstp = &ipsst;
	ipfrstat_t ifrst;
	ipfrstat_t *ifrstp = &ifrst;
	char	*name = NULL, *device = IPL_NAME;
	int	c, fd;
	struct protoent *proto;

	int protocol = -1;		/* -1 = wild card for any protocol */
	int refreshtime = 1; 		/* default update time */
	int sport = -1;			/* -1 = wild card for any source port */
	int dport = -1;			/* -1 = wild card for any dest port */
	int topclosed = 0;		/* do not show closed tcp sessions */
	struct in_addr saddr, daddr;
	saddr.s_addr = INADDR_ANY; 	/* default any source addr */ 
	daddr.s_addr = INADDR_ANY; 	/* default any dest addr */

	while ((c = getopt(argc, argv, "6aACfghIilnostvd:M:D:P:S:T:")) != -1)
	{
		switch (c)
		{
#ifdef	USE_INET6
		case '6' :
			use_inet6 = 1;
			break;
#endif
		case 'a' :
			opts |= OPT_ACCNT|OPT_SHOWLIST;
			break;
		case 'A' :
			device = IPAUTH_NAME;
			opts |= OPT_AUTHSTATS;
			break;
		case 'C' :
			topclosed = 1;
			break;
		case 'd' :
			device = optarg;
			break;
		case 'D' :
			parse_ipportstr(optarg, &daddr, &dport);
			break;
		case 'f' :
			opts |= OPT_FRSTATES;
			break;
		case 'g' :
			opts |= OPT_GROUPS;
			break;
		case 'h' :
			opts |= OPT_HITS;
			break;
		case 'i' :
			opts |= OPT_INQUE|OPT_SHOWLIST;
			break;
		case 'I' :
			opts |= OPT_INACTIVE;
			break;
		case 'l' :
			opts |= OPT_SHOWLIST;
			break;
		case 'n' :
			opts |= OPT_SHOWLINENO;
			break;
		case 'M' :
			memf = optarg;
			break;
		case 'o' :
			opts |= OPT_OUTQUE|OPT_SHOWLIST;
			break;
		case 'P' :
			if ((proto = getprotobyname(optarg)) != NULL) {
				protocol = proto->p_proto;
			} else if (!sscanf(optarg, "%ud", &protocol) ||
					   (protocol < 0)) {
				fprintf(stderr, "%s : Invalid protocol: %s\n",
					argv[0], optarg);
				exit(-2);
			}
			break;
		case 's' :
			opts |= OPT_IPSTATES;
			break;
		case 'S' :
			parse_ipportstr(optarg, &saddr, &sport);
			break;
		case 't' :
#ifdef STATETOP
			opts |= OPT_STATETOP;
			break;
#else
			fprintf(stderr,
				"%s : state top facility not compiled in\n",
				argv[0]);
			exit(-2);
#endif
		case 'T' :
			if (!sscanf(optarg, "%d", &refreshtime) ||
				    (refreshtime <= 0)) {
				fprintf(stderr,
					"%s : Invalid refreshtime < 1 : %s\n",
					argv[0], optarg);
				exit(-2);
			}
			break;
		case 'v' :
			opts |= OPT_VERBOSE;
			break;
		default :
			Usage(argv[0]);
			break;
		}
	}

	if (nlistf != NULL || memf != NULL) {
		(void)setuid(getuid());
		(void)setgid(getgid());
	}

	if (openkmem(nlistf, memf) == -1)
		exit(-1);

	(void)setuid(getuid());
	(void)setgid(getgid());

	if ((fd = open(device, O_RDONLY)) < 0) {
		perror("open");
		exit(-1);
	}

	bzero((char *)&fio, sizeof(fio));
	bzero((char *)&ipsst, sizeof(ipsst));
	bzero((char *)&ifrst, sizeof(ifrst));

	if (!(opts & OPT_AUTHSTATS) && ioctl(fd, SIOCGETFS, &fiop) == -1) {
		perror("ioctl(ipf:SIOCGETFS)");
		exit(-1);
	}
	if ((opts & OPT_IPSTATES)) {
		int	sfd = open(IPL_STATE, O_RDONLY);

		if (sfd == -1) {
			perror("open");
			exit(-1);
		}
		if ((ioctl(sfd, SIOCGETFS, &ipsstp) == -1)) {
			perror("ioctl(state:SIOCGETFS)");
			exit(-1);
		}
		close(sfd);
	}
	if ((opts & OPT_FRSTATES) && (ioctl(fd, SIOCGFRST, &ifrstp) == -1)) {
		perror("ioctl(SIOCGFRST)");
		exit(-1);
	}

	if (opts & OPT_VERBOSE)
		printf("opts %#x name %s\n", opts, name ? name : "<>");

	if ((opts & OPT_AUTHSTATS) &&
	    (ioctl(fd, SIOCATHST, &frauthstp) == -1)) {
		perror("ioctl(SIOCATHST)");
		exit(-1);
	}

	if (opts & OPT_IPSTATES) {
		showipstates(fd, ipsstp);
	} else if (opts & OPT_SHOWLIST) {
		showlist(&fio);
		if ((opts & OPT_OUTQUE) && (opts & OPT_INQUE)){
			opts &= ~OPT_OUTQUE;
			showlist(&fio);
		}
	} else {
		if (opts & OPT_FRSTATES)
			showfrstates(fd, ifrstp);
#ifdef STATETOP
		else if (opts & OPT_STATETOP)
			topipstates(fd, saddr, daddr, sport, dport,
				    protocol, refreshtime, topclosed);
#endif
		else if (opts & OPT_AUTHSTATS)
			showauthstates(fd, frauthstp);
		else if (opts & OPT_GROUPS)
			showgroups(&fio);
		else
			showstats(fd, &fio);
	}
	return 0;
}


/*
 * read the kernel stats for packets blocked and passed
 */
static	void	showstats(fd, fp)
int	fd;
struct	friostat	*fp;
{
	u_32_t	frf = 0;

	if (ioctl(fd, SIOCGETFF, &frf) == -1)
		perror("ioctl(SIOCGETFF)");

#if SOLARIS
	printf("dropped packets:\tin %lu\tout %lu\n",
			fp->f_st[0].fr_drop, fp->f_st[1].fr_drop);
	printf("non-data packets:\tin %lu\tout %lu\n",
			fp->f_st[0].fr_notdata, fp->f_st[1].fr_notdata);
	printf("no-data packets:\tin %lu\tout %lu\n",
			fp->f_st[0].fr_nodata, fp->f_st[1].fr_nodata);
	printf("non-ip packets:\t\tin %lu\tout %lu\n",
			fp->f_st[0].fr_notip, fp->f_st[1].fr_notip);
	printf("   bad packets:\t\tin %lu\tout %lu\n",
			fp->f_st[0].fr_bad, fp->f_st[1].fr_bad);
	printf("copied messages:\tin %lu\tout %lu\n",
			fp->f_st[0].fr_copy, fp->f_st[1].fr_copy);
#endif
#ifdef	USE_INET6
	printf(" IPv6 packets:\t\tin %lu out %lu\n",
			fp->f_st[0].fr_ipv6[0], fp->f_st[0].fr_ipv6[1]);
#endif
	printf(" input packets:\t\tblocked %lu passed %lu nomatch %lu",
			fp->f_st[0].fr_block, fp->f_st[0].fr_pass,
			fp->f_st[0].fr_nom);
	printf(" counted %lu short %lu\n", 
			fp->f_st[0].fr_acct, fp->f_st[0].fr_short);
	printf("output packets:\t\tblocked %lu passed %lu nomatch %lu",
			fp->f_st[1].fr_block, fp->f_st[1].fr_pass,
			fp->f_st[1].fr_nom);
	printf(" counted %lu short %lu\n", 
			fp->f_st[1].fr_acct, fp->f_st[1].fr_short);
	printf(" input packets logged:\tblocked %lu passed %lu\n",
			fp->f_st[0].fr_bpkl, fp->f_st[0].fr_ppkl);
	printf("output packets logged:\tblocked %lu passed %lu\n",
			fp->f_st[1].fr_bpkl, fp->f_st[1].fr_ppkl);
	printf(" packets logged:\tinput %lu output %lu\n",
			fp->f_st[0].fr_pkl, fp->f_st[1].fr_pkl);
	printf(" log failures:\t\tinput %lu output %lu\n",
			fp->f_st[0].fr_skip, fp->f_st[1].fr_skip);
	printf("fragment state(in):\tkept %lu\tlost %lu\n",
			fp->f_st[0].fr_nfr, fp->f_st[0].fr_bnfr);
	printf("fragment state(out):\tkept %lu\tlost %lu\n",
			fp->f_st[1].fr_nfr, fp->f_st[1].fr_bnfr);
	printf("packet state(in):\tkept %lu\tlost %lu\n",
			fp->f_st[0].fr_ads, fp->f_st[0].fr_bads);
	printf("packet state(out):\tkept %lu\tlost %lu\n",
			fp->f_st[1].fr_ads, fp->f_st[1].fr_bads);
	printf("ICMP replies:\t%lu\tTCP RSTs sent:\t%lu\n",
			fp->f_st[0].fr_ret, fp->f_st[1].fr_ret);
	printf("Invalid source(in):\t%lu\n", fp->f_st[0].fr_badsrc);
	printf("Result cache hits(in):\t%lu\t(out):\t%lu\n",
			fp->f_st[0].fr_chit, fp->f_st[1].fr_chit);
	printf("IN Pullups succeeded:\t%lu\tfailed:\t%lu\n",
			fp->f_st[0].fr_pull[0], fp->f_st[0].fr_pull[1]);
	printf("OUT Pullups succeeded:\t%lu\tfailed:\t%lu\n",
			fp->f_st[1].fr_pull[0], fp->f_st[1].fr_pull[1]);
	printf("Fastroute successes:\t%lu\tfailures:\t%lu\n",
			fp->f_froute[0], fp->f_froute[1]);
	printf("TCP cksum fails(in):\t%lu\t(out):\t%lu\n",
			fp->f_st[0].fr_tcpbad, fp->f_st[1].fr_tcpbad);

	printf("Packet log flags set: (%#x)\n", frf);
	if (frf & FF_LOGPASS)
		printf("\tpackets passed through filter\n");
	if (frf & FF_LOGBLOCK)
		printf("\tpackets blocked by filter\n");
	if (frf & FF_LOGNOMATCH)
		printf("\tpackets not matched by filter\n");
	if (!frf)
		printf("\tnone\n");
}


static void printlist(fp)
frentry_t *fp;
{
	struct	frentry	fb;
	int	n;

	for (n = 1; fp; n++) {
		if (kmemcpy((char *)&fb, (u_long)fp, sizeof(fb)) == -1) {
			perror("kmemcpy");
			return;
		}
		fp = &fb;
		if (opts & OPT_OUTQUE)
			fp->fr_flags |= FR_OUTQUE;
		if (opts & (OPT_HITS|OPT_VERBOSE))
#ifdef	USE_QUAD_T
			printf("%qu ", (unsigned long long) fp->fr_hits);
#else
			printf("%lu ", fp->fr_hits);
#endif
		if (opts & (OPT_ACCNT|OPT_VERBOSE))
#ifdef	USE_QUAD_T
			printf("%qu ", (unsigned long long) fp->fr_bytes);
#else
			printf("%lu ", fp->fr_bytes);
#endif
		if (opts & OPT_SHOWLINENO)
			printf("@@%d ", n);
		printfr(fp);
		if (opts & OPT_VERBOSE)
			binprint(fp);
		if (fp->fr_grp)
			printlist(fp->fr_grp);
		fp = fp->fr_next;
	}
}

/*
 * print out filter rule list
 */
static	void	showlist(fiop)
struct	friostat	*fiop;
{
	struct	frentry	*fp = NULL;
	int	i, set;

	set = fiop->f_active;
	if (opts & OPT_INACTIVE)
		set = 1 - set;
	if (opts & OPT_ACCNT) {
		i = F_AC;
		if (opts & OPT_OUTQUE) {
			fp = (struct frentry *)fiop->f_acctout[set];
			i++;
		} else if (opts & OPT_INQUE)
			fp = (struct frentry *)fiop->f_acctin[set];
		else {
			fprintf(stderr, "No -i or -o given with -a\n");
			return;
		}
	} else {
#ifdef	USE_INET6
		if ((use_inet6) && (opts & OPT_OUTQUE)) {
			i = F_OUT;
			fp = (struct frentry *)fiop->f_fout6[set];
		} else if ((use_inet6) && (opts & OPT_INQUE)) {
			i = F_IN;
			fp = (struct frentry *)fiop->f_fin6[set];
		} else
#endif
		if (opts & OPT_OUTQUE) {
			i = F_OUT;
			fp = (struct frentry *)fiop->f_fout[set];
		} else if (opts & OPT_INQUE) {
			i = F_IN;
			fp = (struct frentry *)fiop->f_fin[set];
		} else
			return;
	}
	if (opts & OPT_VERBOSE)
		fprintf(stderr, "showlist:opts %#x i %d\n", opts, i);

	if (opts & OPT_VERBOSE)
		printf("fp %p set %d\n", fp, set);
	if (!fp) {
		fprintf(stderr, "empty list for %s%s\n",
			(opts & OPT_INACTIVE) ? "inactive " : "", filters[i]);
		return;
	}
	printlist(fp);
}


static void showipstates(fd, ipsp)
int fd;
ips_stat_t *ipsp;
{
	ipstate_t *istab[IPSTATE_SIZE], ips;

	if (!(opts & OPT_SHOWLIST)) {
		printf("IP states added:\n\t%lu TCP\n\t%lu UDP\n\t%lu ICMP\n",
			ipsp->iss_tcp, ipsp->iss_udp, ipsp->iss_icmp);
		printf("\t%lu hits\n\t%lu misses\n", ipsp->iss_hits,
			ipsp->iss_miss);
		printf("\t%lu maximum\n\t%lu no memory\n\t%lu bkts in use\n",
			ipsp->iss_max, ipsp->iss_nomem, ipsp->iss_inuse);
		printf("\t%lu active\n\t%lu expired\n\t%lu closed\n",
			ipsp->iss_active, ipsp->iss_expire, ipsp->iss_fin);
		return;
	}

	if (kmemcpy((char *)istab, (u_long)ipsp->iss_table, sizeof(istab)))
		return;

	while (ipsp->iss_list) {
		if (kmemcpy((char *)&ips, (u_long)ipsp->iss_list, sizeof(ips)))
			break;
		ipsp->iss_list = ips.is_next;
		printf("%s -> ", hostname(ips.is_v, &ips.is_src.in4));
		printf("%s ttl %ld pass %#x pr %d state %d/%d\n",
			hostname(ips.is_v, &ips.is_dst.in4),
			ips.is_age, ips.is_pass, ips.is_p,
			ips.is_state[0], ips.is_state[1]);
#ifdef	USE_QUAD_T
		printf("\tpkts %qu bytes %qu",
			(unsigned long long) ips.is_pkts,
			(unsigned long long) ips.is_bytes);
#else
		printf("\tpkts %ld bytes %ld", ips.is_pkts, ips.is_bytes);
#endif
		if (ips.is_p == IPPROTO_TCP)
#if defined(NetBSD) && (NetBSD >= 199905) && (NetBSD < 1991011) || \
    (__FreeBSD_version >= 220000) || defined(__OpenBSD__)
			printf("\t%hu -> %hu %x:%x %hu:%hu",
				ntohs(ips.is_sport), ntohs(ips.is_dport),
				ips.is_send, ips.is_dend,
				ips.is_maxswin, ips.is_maxdwin);
#else
			printf("\t%hu -> %hu %x:%x %hu:%hu",
				ntohs(ips.is_sport), ntohs(ips.is_dport),
				ips.is_send, ips.is_dend,
				ips.is_maxswin, ips.is_maxdwin);
#endif
		else if (ips.is_p == IPPROTO_UDP)
			printf(" %hu -> %hu", ntohs(ips.is_sport),
				ntohs(ips.is_dport));
		else if (ips.is_p == IPPROTO_ICMP
#ifdef	USE_INET6
			 || ips.is_p == IPPROTO_ICMPV6
#endif
			)
			printf(" %hu %hu %d", ips.is_icmp.ics_id,
				ips.is_icmp.ics_seq, ips.is_icmp.ics_type);

		printf("\n\t");

		if (ips.is_pass & FR_PASS) {
			printf("pass");
		} else if (ips.is_pass & FR_BLOCK) {
			printf("block");
			switch (ips.is_pass & FR_RETMASK)
			{
			case FR_RETICMP :
				printf(" return-icmp");
				break;
			case FR_FAKEICMP :
				printf(" return-icmp-as-dest");
				break;
			case FR_RETRST :
				printf(" return-rst");
				break;
			default :
				break;
			}
		} else if ((ips.is_pass & FR_LOGMASK) == FR_LOG) {
				printf("log");
			if (ips.is_pass & FR_LOGBODY)
				printf(" body");
			if (ips.is_pass & FR_LOGFIRST)
				printf(" first");
		} else if (ips.is_pass & FR_ACCOUNT)
			printf("count");

		if (ips.is_pass & FR_OUTQUE)
			printf(" out");
		else
			printf(" in");

		if ((ips.is_pass & FR_LOG) != 0) {
			printf(" log");
			if (ips.is_pass & FR_LOGBODY)
				printf(" body");
			if (ips.is_pass & FR_LOGFIRST)
				printf(" first");
			if (ips.is_pass & FR_LOGORBLOCK)
				printf(" or-block");
		}
		if (ips.is_pass & FR_QUICK)
			printf(" quick");
		if (ips.is_pass & FR_KEEPFRAG)
			printf(" keep frags");
		/* a given; no? */
		if (ips.is_pass & FR_KEEPSTATE)
			printf(" keep state");
		printf("\tIPv%d", ips.is_v);
		printf("\n");

		printf("\tpkt_flags & %x(%x) = %x,\t",
			ips.is_flags & 0xf, ips.is_flags,
			ips.is_flags >> 4);
		printf("\tpkt_options & %x = %x\n", ips.is_optmsk,
			ips.is_opt);
		printf("\tpkt_security & %x = %x, pkt_auth & %x = %x\n",
			ips.is_secmsk, ips.is_sec, ips.is_authmsk,
			ips.is_auth);
		printf("interfaces: in %s[%p] ",
		       get_ifname(ips.is_ifpin), ips.is_ifpin);
		printf("out %s[%p]\n",
		       get_ifname(ips.is_ifpout), ips.is_ifpout);
	}
}

#ifdef STATETOP
static void topipstates(fd, saddr, daddr, sport, dport, protocol,
		        refreshtime, topclosed)
int fd;
struct in_addr saddr;
struct in_addr daddr;
int sport;
int dport;
int protocol;
int refreshtime;
int topclosed;
{
	char str1[STSTRSIZE], str2[STSTRSIZE], str3[STSTRSIZE], str4[STSTRSIZE];
	int maxtsentries = 0, reverse = 0, sorting = STSORT_DEFAULT;
	int i, j, sfd, winx, tsentry, maxx, maxy, redraw = 0;
	ipstate_t *istab[IPSTATE_SIZE], ips;
	ips_stat_t ipsst, *ipsstp = &ipsst;
	statetop_t *tstable = NULL, *tp;
	struct timeval selecttimeout; 
	struct protoent *proto;
	fd_set readfd;
	char c = '\0';
	time_t t;

	/* open state device */
	if ((sfd = open(IPL_STATE, O_RDONLY)) == -1) {
		perror("open");
		exit(-1);
	}

	/* init ncurses stuff */
  	initscr();
  	cbreak();
  	noecho();
  	nodelay(stdscr, 1);

	/* repeat until user aborts */
	while ( 1 ) {

		/* get state table */
		bzero((char *)&ipsst, sizeof(&ipsst));
		if ((ioctl(sfd, SIOCGETFS, &ipsstp) == -1)) {
			perror("ioctl(SIOCGETFS)");
			exit(-1);
		}
		if (kmemcpy((char *)istab, (u_long)ipsstp->iss_table,
			    sizeof(ips)))
			return;

		/* clear the history */
		tsentry = -1;

		/* read the state table and store in tstable */
		while (ipsstp->iss_list) {
			if (kmemcpy((char *)&ips, (u_long)ipsstp->iss_list,
				    sizeof(ips)))
				break;
			ipsstp->iss_list = ips.is_next;

			if (((saddr.s_addr == INADDR_ANY) ||
			     (saddr.s_addr == ips.is_saddr)) &&
			    ((daddr.s_addr == INADDR_ANY) ||
			     (daddr.s_addr == ips.is_daddr)) &&
			    ((protocol < 0) || (protocol == ips.is_p)) &&
			    (((ips.is_p != IPPROTO_TCP) &&
			     (ips.is_p != IPPROTO_UDP)) || 
			     (((sport < 0) ||
			       (htons(sport) == ips.is_sport)) &&
			      ((dport < 0) ||
			       (htons(dport) == ips.is_dport)))) &&
			     (topclosed || (ips.is_p != IPPROTO_TCP) ||
			     (ips.is_state[0] < TCPS_CLOSE_WAIT) ||
			     (ips.is_state[1] < TCPS_CLOSE_WAIT))) { 
				/*
				 * if necessary make room for this state
				 * entry
				 */
				tsentry++;
				if (!maxtsentries ||
				    (tsentry == maxtsentries)) {

					maxtsentries += STGROWSIZE;
					tstable = realloc(tstable, maxtsentries * sizeof(statetop_t));
					if (!tstable) {
						perror("malloc");
						exit(-1);
					}
				}

				/* fill structure */
				tp = tstable + tsentry;
				tp->st_src = ips.is_src;
				tp->st_dst = ips.is_dst;
				tp->st_p = ips.is_p;
				tp->st_state[0] = ips.is_state[0];
				tp->st_state[1] = ips.is_state[1];
				tp->st_pkts = ips.is_pkts;
				tp->st_bytes = ips.is_bytes;
				tp->st_age = ips.is_age;
				if ((ips.is_p == IPPROTO_TCP) ||
				    (ips.is_p == IPPROTO_UDP)) {
					tp->st_sport = ips.is_sport;
					tp->st_dport = ips.is_dport;
				}

			}
		}


		/* sort the array */
		if (tsentry != -1)
			switch (sorting)
			{
			case STSORT_PR:
				qsort(tstable, tsentry + 1,
				      sizeof(statetop_t), sort_p);
				break;
			case STSORT_PKTS:
				qsort(tstable, tsentry + 1,
				      sizeof(statetop_t), sort_pkts);
				break;
			case STSORT_BYTES:
				qsort(tstable, tsentry + 1,
				      sizeof(statetop_t), sort_bytes);
				break;
			case STSORT_TTL:
				qsort(tstable, tsentry + 1,
				      sizeof(statetop_t), sort_ttl);
				break;
			default:
				break;
			}

		/* print title */
		erase();
		getmaxyx(stdscr, maxy, maxx);
		attron(A_BOLD);
		winx = 0;
		move(winx,0);
		sprintf(str1, "%s - state top", IPL_VERSION);
		for(j = 0 ; j < (maxx - 8 - strlen(str1)) / 2; j++)
			printw(" ");
		printw("%s", str1);
		attroff(A_BOLD);

		/* just for fun add a clock */
		move(winx, maxx - 8);
		t = time(NULL);
		strftime(str1, 80, "%T", localtime(&t));
		printw("%s\n", str1);

		/*
		 * print the display filters, this is placed in the loop, 
		 * because someday I might add code for changing these
		 * while the programming is running :-)
		 */
		if (sport >= 0)
			sprintf(str1, "%s,%d", inet_ntoa(saddr), sport);
		else
			sprintf(str1, "%s", inet_ntoa(saddr));

		if (dport >= 0)
			sprintf(str2, "%s,%d", inet_ntoa(daddr), dport);
		else
			sprintf(str2, "%s", inet_ntoa(daddr));

		if (protocol < 0)
			strcpy(str3, "any");
		else if ((proto = getprotobynumber(protocol)) != NULL)
			sprintf(str3, "%s", proto->p_name); 
		else
			sprintf(str3, "%d", protocol);

		switch (sorting)
		{
		case STSORT_PR:
			sprintf(str4, "proto");
			break;
		case STSORT_PKTS:
			sprintf(str4, "# pkts");
			break;
		case STSORT_BYTES:
			sprintf(str4, "# bytes");
			break;
		case STSORT_TTL:
			sprintf(str4, "ttl");
			break;
		default:
			sprintf(str4, "unknown");
			break;
		}

		if (reverse)
			strcat(str4, " (reverse)");

		winx += 2;
		move(winx,0);
		printw("Src = %s  Dest = %s  Proto = %s  Sorted by = %s\n\n",
		       str1, str2, str3, str4);

		/* print column description */
		winx += 2;
		move(winx,0);
		attron(A_BOLD);
		printw("%-21s %-21s %3s %4s %7s %9s %9s\n", "Source IP",
		       "Destination IP", "ST", "PR", "#pkts", "#bytes", "ttl");
		attroff(A_BOLD);

		/* print all the entries */
		tp = tstable;
		if (reverse)
			tp += tsentry;

		for(i = 0; i <= tsentry; i++) {
			/* print src/dest and port */
			if ((tp->st_p == IPPROTO_TCP) ||
			    (tp->st_p == IPPROTO_UDP)) {
				sprintf(str1, "%s,%hu",
					inet_ntoa(tp->st_src.in4),
					ntohs(tp->st_sport));
				sprintf(str2, "%s,%hu",
					inet_ntoa(tp->st_dst.in4),
					ntohs(tp->st_dport));
			} else {
				sprintf(str1, "%s", inet_ntoa(tp->st_src.in4));
				sprintf(str2, "%s", inet_ntoa(tp->st_dst.in4));
			}
			winx++;
			move(winx, 0);
			printw("%-21s %-21s", str1, str2);

			/* print state */
			sprintf(str1, "%X/%X", tp->st_state[0],
				tp->st_state[1]);
			printw(" %3s", str1);

			/* print proto */
			proto = getprotobynumber(tp->st_p);
			if (proto) {
				strncpy(str1, proto->p_name, 4);
				str1[4] = '\0';
			} else {
				sprintf(str1, "%d", tp->st_p);
			}
			printw(" %4s", str1);
				/* print #pkt/#bytes */
#ifdef	USE_QUAD_T
			printw(" %7qu %9qu", (unsigned long long) tp->st_pkts,
				(unsigned long long) tp->st_bytes);
#else
			printw(" %7lu %9lu", tp->st_pkts, tp->st_bytes);
#endif
			printw(" %9s", ttl_to_string(tp->st_age));

			if (reverse)
				tp--;
			else
				tp++;
		}

		/* screen data structure is filled, now update the screen */
		if (redraw)
			clearok(stdscr,1);

		refresh();
		if (redraw) {
			clearok(stdscr,0);
			redraw = 0;
		}

		/* wait for key press or a 1 second time out period */
		selecttimeout.tv_sec = refreshtime;
		selecttimeout.tv_usec = 0;
		FD_ZERO(&readfd);
		FD_SET(0, &readfd);
		select(1, &readfd, NULL, NULL, &selecttimeout);

		/* if key pressed, read all waiting keys */
		if (FD_ISSET(0, &readfd))
			while ((c = wgetch(stdscr)) != ERR) {
				if (tolower(c) == 'l') {
					redraw = 1;
				} else if (tolower(c) == 'q') {
					nocbreak();
					endwin();
					exit(0);
				} else if (tolower(c) == 'r') {
					reverse = !reverse;
				} else if (tolower(c) == 's') {
					sorting++;
					if (sorting > STSORT_MAX)
						sorting = 0;
				}
			}
	} /* while */

	close(sfd);

	printw("\n");
	nocbreak();
	endwin();
}
#endif

static void showfrstates(fd, ifsp)
int fd;
ipfrstat_t *ifsp;
{
	struct ipfr *ipfrtab[IPFT_SIZE], ifr;
	frentry_t fr;
	int i;

	printf("IP fragment states:\n\t%lu new\n\t%lu expired\n\t%lu hits\n",
		ifsp->ifs_new, ifsp->ifs_expire, ifsp->ifs_hits);
	printf("\t%lu no memory\n\t%lu already exist\n",
		ifsp->ifs_nomem, ifsp->ifs_exists);
	printf("\t%lu inuse\n", ifsp->ifs_inuse);
	if (kmemcpy((char *)ipfrtab, (u_long)ifsp->ifs_table, sizeof(ipfrtab)))
		return;
	for (i = 0; i < IPFT_SIZE; i++)
		while (ipfrtab[i]) {
			if (kmemcpy((char *)&ifr, (u_long)ipfrtab[i],
				    sizeof(ifr)) == -1)
				break;
			printf("%s -> ", hostname(4, &ifr.ipfr_src));
			if (kmemcpy((char *)&fr, (u_long)ifr.ipfr_rule,
				    sizeof(fr)) == -1)
				break;
			printf("%s %d %d %d %#02x = %#x\n",
				hostname(4, &ifr.ipfr_dst), ifr.ipfr_id,
				ifr.ipfr_ttl, ifr.ipfr_p, ifr.ipfr_tos,
				fr.fr_flags);
			ipfrtab[i] = ifr.ipfr_next;
		}
	if (kmemcpy((char *)ipfrtab, (u_long)ifsp->ifs_nattab,sizeof(ipfrtab)))
		return;
	for (i = 0; i < IPFT_SIZE; i++)
		while (ipfrtab[i]) {
			if (kmemcpy((char *)&ifr, (u_long)ipfrtab[i],
				    sizeof(ifr)) == -1)
				break;
			printf("NAT: %s -> ", hostname(4, &ifr.ipfr_src));
			if (kmemcpy((char *)&fr, (u_long)ifr.ipfr_rule,
				    sizeof(fr)) == -1)
				break;
			printf("%s %d %d %d %#02x = %#x\n",
				hostname(4, &ifr.ipfr_dst), ifr.ipfr_id,
				ifr.ipfr_ttl, ifr.ipfr_p, ifr.ipfr_tos,
				fr.fr_flags);
			ipfrtab[i] = ifr.ipfr_next;
		}
}


static void showauthstates(fd, asp)
int fd;
fr_authstat_t *asp;
{
	frauthent_t *frap, fra;

#ifdef	USE_QUAD_T
	printf("Authorisation hits: %qu\tmisses %qu\n",
		(unsigned long long) asp->fas_hits,
		(unsigned long long) asp->fas_miss);
#else
	printf("Authorisation hits: %ld\tmisses %ld\n", asp->fas_hits,
		asp->fas_miss);
#endif
	printf("nospace %ld\nadded %ld\nsendfail %ld\nsendok %ld\n",
		asp->fas_nospace, asp->fas_added, asp->fas_sendfail,
		asp->fas_sendok);
	printf("queok %ld\nquefail %ld\nexpire %ld\n",
		asp->fas_queok, asp->fas_quefail, asp->fas_expire);

	frap = asp->fas_faelist;
	while (frap) {
		if (kmemcpy((char *)&fra, (u_long)frap, sizeof(fra)) == -1)
			break;

		printf("age %ld\t", fra.fae_age);
		printfr(&fra.fae_fr);
		frap = fra.fae_next;
	}
}


static char *get_ifname(ptr)
void *ptr;
{
#if SOLARIS
	char *ifname;
	ill_t ill;

	if (ptr == (void *)-1)
		return "!";
	if (ptr == NULL)
		return "-";

	if (kmemcpy((char *)&ill, (u_long)ptr, sizeof(ill)) == -1)
		return "X";
	ifname = malloc(ill.ill_name_length + 1);
	if (kmemcpy(ifname, (u_long)ill.ill_name,
		    ill.ill_name_length) == -1)
		return "X";
	return ifname;
#else
# if defined(NetBSD) && (NetBSD >= 199905) && (NetBSD < 1991011) || \
    defined(__OpenBSD__)
#else
	char buf[32];
	int len;
# endif
	struct ifnet netif;

	if (ptr == (void *)-1)
		return "!";
	if (ptr == NULL)
		return "-";

	if (kmemcpy((char *)&netif, (u_long)ptr, sizeof(netif)) == -1)
		return "X";
# if defined(NetBSD) && (NetBSD >= 199905) && (NetBSD < 1991011) || \
    defined(__OpenBSD__)
	return strdup(netif.if_xname);
# else
	if (kstrncpy(buf, (u_long)netif.if_name, sizeof(buf)) == -1)
		return "X";
	if (netif.if_unit < 10)
		len = 2;
	else if (netif.if_unit < 1000)
		len = 3;
	else if (netif.if_unit < 10000)
		len = 4;
	else
		len = 5;
	buf[sizeof(buf) - len] = '\0';
	sprintf(buf + strlen(buf), "%d", netif.if_unit % 10000);
	return strdup(buf);
# endif
#endif
}


static void showgroups(fiop)
struct friostat	*fiop;
{
	static char *gnames[3] = { "Filter", "Accounting", "Authentication" };
	frgroup_t *fp, grp;
	int on, off, i;

	on = fiop->f_active;
	off = 1 - on;

	for (i = 0; i < 3; i++) {
		printf("%s groups (active):\n", gnames[i]);
		for (fp = fiop->f_groups[i][on]; fp; fp = grp.fg_next)
			if (kmemcpy((char *)&grp, (u_long)fp, sizeof(grp)))
				break;
			else
				printf("%hu\n", grp.fg_num);
		printf("%s groups (inactive):\n", gnames[i]);
		for (fp = fiop->f_groups[i][off]; fp; fp = grp.fg_next)
			if (kmemcpy((char *)&grp, (u_long)fp, sizeof(grp)))
				break;
			else
				printf("%hu\n", grp.fg_num);
	}
}

static void parse_ipportstr(argument, ip, port)
const char *argument;
struct in_addr *ip;
int *port;
{

	char *s, *comma;

	/* make working copy of argument, Theoretically you must be able
	 * to write to optarg, but that seems very ugly to me....
	 */
	if ((s = malloc(strlen(argument) + 1)) == NULL)
		perror("malloc");
	strcpy(s, argument);

	/* get port */
	if ((comma = strchr(s, ',')) != NULL) {
		if (!strcasecmp(s, "any")) {
			*port = -1;
		} else if (!sscanf(comma + 1, "%d", port) ||
			   (*port < 0) || (*port > 65535)) {
			fprintf(stderr, "Invalid port specfication in %s\n",
				argument);
			exit(-2);
		}
		*comma = '\0';
	}


	/* get ip address */
	if (!strcasecmp(s, "any")) {
		ip->s_addr = INADDR_ANY;
	} else	if (!inet_aton(s, ip)) {
		fprintf(stderr, "Invalid IP address: %s\n", s);
		exit(-2);
	}

	/* free allocated memory */
	free(s);
}


#ifdef STATETOP
static char ttlbuf[STSTRSIZE];

static char *ttl_to_string(ttl)
long int ttl;
{

	int hours, minutes, seconds;

	/* ttl is in half seconds */
	ttl /= 2;

	hours = ttl / 3600;
	ttl = ttl % 3600;
	minutes = ttl / 60;
	seconds = ttl % 60;

	if (hours > 0 )
		sprintf(ttlbuf, "%2d:%02d:%02d", hours, minutes, seconds);
	else
		sprintf(ttlbuf, "%2d:%02d", minutes, seconds);
	return ttlbuf;
}


static int sort_pkts(a, b)
const void *a;
const void *b;
{

	register const statetop_t *ap = a;
	register const statetop_t *bp = b;

	if (ap->st_pkts == bp->st_pkts)
		return 0;
	else if (ap->st_pkts < bp->st_pkts)
		return 1;
	return -1;
}


static int sort_bytes(a, b)
const void *a;
const void *b;
{
	register const statetop_t *ap = a;
	register const statetop_t *bp = b;

	if (ap->st_bytes == bp->st_bytes)
		return 0;
	else if (ap->st_bytes < bp->st_bytes)
		return 1;
	return -1;
}


static int sort_p(a, b)
const void *a;
const void *b;
{
	register const statetop_t *ap = a;
	register const statetop_t *bp = b;

	if (ap->st_p == bp->st_p)
		return 0;
	else if (ap->st_p < bp->st_p)
		return 1;
	return -1;
}


static int sort_ttl(a, b)
const void *a;
const void *b;
{
	register const statetop_t *ap = a;
	register const statetop_t *bp = b;

	if (ap->st_age == bp->st_age)
		return 0;
	else if (ap->st_age < bp->st_age)
		return 1;
	return -1;
}
#endif
@


1.24
log
@reimplement whacked ipfstat changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fils.c,v 1.23 2001/01/17 05:01:00 fgsch Exp $	*/
@


1.23
log
@1st part of ipf userland code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
#include <netinet/ip_compat.h>
a72 4
extern	char	*optarg;

#define	PRINTF	(void)printf
#define	FPRINTF	(void)fprintf
d109 2
d159 2
a160 1
	fprintf(stderr, "Usage: %s [-6aAfhIinosv] [-d <device>]\n", name);
d162 2
a163 1
	fprintf(stderr, "Usage: %s [-aAfhIinosv] [-d <device>]\n", name);
d195 1
a195 7
	if (openkmem() == -1)
		exit(-1);

	(void)setuid(getuid());
	(void)setgid(getgid());

	while ((c = getopt(argc, argv, "6aACfghIilnostvd:D:P:S:T:")) != -1)
d241 3
d291 11
d334 1
a334 1
		PRINTF("opts %#x name %s\n", opts, name ? name : "<>");
d382 1
a382 1
	PRINTF("dropped packets:\tin %lu\tout %lu\n",
d384 1
a384 1
	PRINTF("non-data packets:\tin %lu\tout %lu\n",
d386 1
a386 1
	PRINTF("no-data packets:\tin %lu\tout %lu\n",
d388 1
a388 1
	PRINTF("non-ip packets:\t\tin %lu\tout %lu\n",
d390 1
a390 1
	PRINTF("   bad packets:\t\tin %lu\tout %lu\n",
d392 1
a392 1
	PRINTF("copied messages:\tin %lu\tout %lu\n",
d396 1
a396 1
	PRINTF(" IPv6 packets:\t\tin %lu out %lu\n",
d399 1
a399 1
	PRINTF(" input packets:\t\tblocked %lu passed %lu nomatch %lu",
d402 1
a402 1
	PRINTF(" counted %lu short %lu\n", 
d404 1
a404 1
	PRINTF("output packets:\t\tblocked %lu passed %lu nomatch %lu",
d407 1
a407 1
	PRINTF(" counted %lu short %lu\n", 
d409 1
a409 1
	PRINTF(" input packets logged:\tblocked %lu passed %lu\n",
d411 1
a411 1
	PRINTF("output packets logged:\tblocked %lu passed %lu\n",
d413 1
a413 1
	PRINTF(" packets logged:\tinput %lu output %lu\n",
d415 1
a415 1
	PRINTF(" log failures:\t\tinput %lu output %lu\n",
d417 1
a417 1
	PRINTF("fragment state(in):\tkept %lu\tlost %lu\n",
d419 1
a419 1
	PRINTF("fragment state(out):\tkept %lu\tlost %lu\n",
d421 1
a421 1
	PRINTF("packet state(in):\tkept %lu\tlost %lu\n",
d423 1
a423 1
	PRINTF("packet state(out):\tkept %lu\tlost %lu\n",
d425 1
a425 1
	PRINTF("ICMP replies:\t%lu\tTCP RSTs sent:\t%lu\n",
d427 2
a428 2
	PRINTF("Invalid source(in):\t%lu\n", fp->f_st[0].fr_badsrc);
	PRINTF("Result cache hits(in):\t%lu\t(out):\t%lu\n",
d430 1
a430 1
	PRINTF("IN Pullups succeeded:\t%lu\tfailed:\t%lu\n",
d432 1
a432 1
	PRINTF("OUT Pullups succeeded:\t%lu\tfailed:\t%lu\n",
d434 1
a434 1
	PRINTF("Fastroute successes:\t%lu\tfailures:\t%lu\n",
d436 1
a436 1
	PRINTF("TCP cksum fails(in):\t%lu\t(out):\t%lu\n",
d439 1
a439 1
	PRINTF("Packet log flags set: (%#x)\n", frf);
d441 1
a441 1
		PRINTF("\tpackets passed through filter\n");
d443 1
a443 1
		PRINTF("\tpackets blocked by filter\n");
d445 1
a445 1
		PRINTF("\tpackets not matched by filter\n");
d447 1
a447 1
		PRINTF("\tnone\n");
d467 1
a467 1
			PRINTF("%qu ", (unsigned long long) fp->fr_hits);
d469 1
a469 1
			PRINTF("%lu ", fp->fr_hits);
d473 1
a473 1
			PRINTF("%qu ", (unsigned long long) fp->fr_bytes);
d475 1
a475 1
			PRINTF("%lu ", fp->fr_bytes);
d478 1
a478 1
			PRINTF("@@%d ", n);
d508 1
a508 1
			FPRINTF(stderr, "No -i or -o given with -a\n");
d531 1
a531 1
		FPRINTF(stderr, "showlist:opts %#x i %d\n", opts, i);
d534 1
a534 1
		PRINTF("fp %p set %d\n", fp, set);
d536 1
a536 1
		FPRINTF(stderr, "empty list for %s%s\n",
d551 1
a551 1
		PRINTF("IP states added:\n\t%lu TCP\n\t%lu UDP\n\t%lu ICMP\n",
d553 1
a553 1
		PRINTF("\t%lu hits\n\t%lu misses\n", ipsp->iss_hits,
d555 1
a555 1
		PRINTF("\t%lu maximum\n\t%lu no memory\n\t%lu bkts in use\n",
d557 1
a557 1
		PRINTF("\t%lu active\n\t%lu expired\n\t%lu closed\n",
d569 2
a570 2
		PRINTF("%s -> ", hostname(ips.is_v, &ips.is_src.in4));
		PRINTF("%s ttl %ld pass %#x pr %d state %d/%d\n",
d575 1
a575 1
		PRINTF("\tpkts %qu bytes %qu",
d579 1
a579 1
		PRINTF("\tpkts %ld bytes %ld", ips.is_pkts, ips.is_bytes);
d584 1
a584 1
			PRINTF("\t%hu -> %hu %x:%x %hu:%hu",
d589 1
a589 1
			PRINTF("\t%hu -> %hu %x:%x %hu:%hu",
d595 1
a595 1
			PRINTF(" %hu -> %hu", ntohs(ips.is_sport),
d602 1
a602 1
			PRINTF(" %hu %hu %d", ips.is_icmp.ics_id,
d605 1
a605 1
		PRINTF("\n\t");
d608 1
a608 1
			PRINTF("pass");
d610 1
a610 1
			PRINTF("block");
d614 1
a614 1
				PRINTF(" return-icmp");
d617 1
a617 1
				PRINTF(" return-icmp-as-dest");
d620 1
a620 1
				PRINTF(" return-rst");
d626 1
a626 1
				PRINTF("log");
d628 1
a628 1
				PRINTF(" body");
d630 1
a630 1
				PRINTF(" first");
d632 1
a632 1
			PRINTF("count");
d635 1
a635 1
			PRINTF(" out");
d637 1
a637 1
			PRINTF(" in");
d640 1
a640 1
			PRINTF(" log");
d642 1
a642 1
				PRINTF(" body");
d644 1
a644 1
				PRINTF(" first");
d646 1
a646 1
				PRINTF(" or-block");
d649 1
a649 1
			PRINTF(" quick");
d651 1
a651 1
			PRINTF(" keep frags");
d654 3
a656 3
			PRINTF(" keep state");
		PRINTF("\tIPv%d", ips.is_v);
		PRINTF("\n");
d658 1
a658 1
		PRINTF("\tpkt_flags & %x(%x) = %x,\t",
d661 1
a661 1
		PRINTF("\tpkt_options & %x = %x\n", ips.is_optmsk,
d663 1
a663 1
		PRINTF("\tpkt_security & %x = %x, pkt_auth & %x = %x\n",
d666 1
a666 1
		PRINTF("interfaces: in %s[%p] ",
d668 1
a668 1
		PRINTF("out %s[%p]\n",
d985 1
a985 1
	PRINTF("IP fragment states:\n\t%lu new\n\t%lu expired\n\t%lu hits\n",
d987 1
a987 1
	PRINTF("\t%lu no memory\n\t%lu already exist\n",
d989 1
a989 1
	PRINTF("\t%lu inuse\n", ifsp->ifs_inuse);
d997 1
a997 1
			PRINTF("%s -> ", hostname(4, &ifr.ipfr_src));
d1001 1
a1001 1
			PRINTF("%s %d %d %d %#02x = %#x\n",
d1014 1
a1014 1
			PRINTF("NAT: %s -> ", hostname(4, &ifr.ipfr_src));
d1018 1
a1018 1
			PRINTF("%s %d %d %d %#02x = %#x\n",
@


1.22
log
@Sync usage() with reality; mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: fils.c,v 1.21 2000/08/10 05:50:27 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d22 3
d30 4
d48 5
a52 1
#include <netinet/ip_fil_compat.h>
d60 3
d69 2
a70 2
static const char sccsid[] = "@@(#)fils.c	1.21 4/20/96 (C) 1993-1996 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: fils.c,v 2.2.2.7 2000/05/24 20:34:56 darrenr Exp $";
d73 4
d84 3
d88 24
a111 1
char *nlistf = NULL, *memf = NULL;
d123 32
d160 6
a165 3
	fprintf(stderr,
	    "usage: %s [-aAfghIinosv] [-d device] [-M core]\n", 
		name);
d175 1
d177 1
d179 1
d181 1
d184 16
d201 1
a201 1
	while ((c = getopt(argc, argv, "AafhgIinosvd:M:")) != -1)
d205 5
d214 1
d217 3
d223 3
d241 3
d250 10
d263 22
a287 3
		case 'M':
			memf = optarg;
			break;
a293 11
	if (nlistf != NULL || memf != NULL) {
		(void)setuid(getuid());
		(void)setgid(getgid());
	}

	if (openkmem(nlistf, memf) == -1)
		exit(-1);

	(void)setuid(getuid());
	(void)setgid(getgid());

d303 2
a304 2
	if (ioctl(fd, SIOCGETFS, &fio) == -1) {
		perror("ioctl(SIOCGETFS)");
d314 2
a315 2
		if ((ioctl(sfd, SIOCGIPST, &ipsst) == -1)) {
			perror("ioctl(SIOCGIPST)");
d320 1
a320 1
	if ((opts & OPT_FRSTATES) && (ioctl(fd, SIOCGFRST, &ifrst) == -1)) {
d326 1
a326 1
		printf("opts %#x name %s\n", opts, name ? name : "<>");
d329 1
a329 1
	    (ioctl(fd, SIOCATHST, &frauthst) == -1)) {
d334 3
a336 1
	if (opts & OPT_SHOWLIST) {
d343 7
a349 4
		if (opts & OPT_IPSTATES)
			showipstates(fd, &ipsst);
		else if (opts & OPT_FRSTATES)
			showfrstates(fd, &ifrst);
d351 1
a351 1
			showauthstates(fd, &frauthst);
d374 1
a374 1
	printf("dropped packets:\tin %lu\tout %lu\n",
d376 1
a376 1
	printf("non-data packets:\tin %lu\tout %lu\n",
d378 1
a378 1
	printf("no-data packets:\tin %lu\tout %lu\n",
d380 1
a380 1
	printf("non-ip packets:\t\tin %lu\tout %lu\n",
d382 1
a382 1
	printf("   bad packets:\t\tin %lu\tout %lu\n",
d384 1
a384 1
	printf("copied messages:\tin %lu\tout %lu\n",
d387 5
a391 1
	printf(" input packets:\t\tblocked %lu passed %lu nomatch %lu",
d394 1
a394 1
	printf(" counted %lu short %lu\n", 
d396 1
a396 1
	printf("output packets:\t\tblocked %lu passed %lu nomatch %lu",
d399 1
a399 1
	printf(" counted %lu short %lu\n", 
d401 1
a401 1
	printf(" input packets logged:\tblocked %lu passed %lu\n",
d403 1
a403 1
	printf("output packets logged:\tblocked %lu passed %lu\n",
d405 1
a405 1
	printf(" packets logged:\tinput %lu output %lu\n",
d407 1
a407 1
	printf(" log failures:\t\tinput %lu output %lu\n",
d409 1
a409 1
	printf("fragment state(in):\tkept %lu\tlost %lu\n",
d411 1
a411 1
	printf("fragment state(out):\tkept %lu\tlost %lu\n",
d413 1
a413 1
	printf("packet state(in):\tkept %lu\tlost %lu\n",
d415 1
a415 1
	printf("packet state(out):\tkept %lu\tlost %lu\n",
d417 1
a417 1
	printf("ICMP replies:\t%lu\tTCP RSTs sent:\t%lu\n",
d419 2
a420 1
	printf("Result cache hits(in):\t%lu\t(out):\t%lu\n",
d422 1
a422 1
	printf("IN Pullups succeeded:\t%lu\tfailed:\t%lu\n",
d424 1
a424 1
	printf("OUT Pullups succeeded:\t%lu\tfailed:\t%lu\n",
d426 1
a426 1
	printf("Fastroute successes:\t%lu\tfailures:\t%lu\n",
d428 1
a428 1
	printf("TCP cksum fails(in):\t%lu\t(out):\t%lu\n",
d431 1
a431 1
	printf("Packet log flags set: (%#x)\n", frf);
d433 1
a433 1
		printf("\tpackets passed through filter\n");
d435 1
a435 1
		printf("\tpackets blocked by filter\n");
d437 1
a437 1
		printf("\tpackets not matched by filter\n");
d439 1
a439 1
		printf("\tnone\n");
d459 1
a459 1
			printf("%qu ", fp->fr_hits);
d461 1
a461 1
			printf("%lu ", fp->fr_hits);
d465 1
a465 1
			printf("%qu ", fp->fr_bytes);
d467 1
a467 1
			printf("%lu ", fp->fr_bytes);
d470 1
a470 1
			printf("@@%d ", n);
d500 1
a500 1
			fprintf(stderr, "No -i or -o given with -a\n");
d503 19
a521 8
	} else if (opts & OPT_OUTQUE) {
		i = F_OUT;
		fp = (struct frentry *)fiop->f_fout[set];
	} else if (opts & OPT_INQUE) {
		i = F_IN;
		fp = (struct frentry *)fiop->f_fin[set];
	} else
		return;
d523 1
a523 1
		fprintf(stderr, "showlist:opts %#x i %d\n", opts, i);
d526 1
a526 1
		printf("fp %p set %d\n", fp, set);
d528 1
a528 1
		fprintf(stderr, "empty list for %s%s\n",
a540 1
	int i;
d542 12
a553 7
	printf("IP states added:\n\t%lu TCP\n\t%lu UDP\n\t%lu ICMP\n",
		ipsp->iss_tcp, ipsp->iss_udp, ipsp->iss_icmp);
	printf("\t%lu hits\n\t%lu misses\n", ipsp->iss_hits, ipsp->iss_miss);
	printf("\t%lu maximum\n\t%lu no memory\n\tbuckets in use\t%lu\n",
		ipsp->iss_max, ipsp->iss_nomem, ipsp->iss_inuse);
	printf("\t%lu active\n\t%lu expired\n\t%lu closed\n",
		ipsp->iss_active, ipsp->iss_expire, ipsp->iss_fin);
d556 10
a565 10
	for (i = 0; i < IPSTATE_SIZE; i++) {
		while (istab[i]) {
			if (kmemcpy((char *)&ips, (u_long)istab[i],
				    sizeof(ips)) == -1)
				break;
			printf("%s -> ", inet_ntoa(ips.is_src));
			printf("%s ttl %ld pass %#x pr %d state %d/%d\n",
				inet_ntoa(ips.is_dst), ips.is_age,
				ips.is_pass, ips.is_p, ips.is_state[0],
				ips.is_state[1]);
d567 3
a569 2
			printf("\tpkts %qd bytes %qd",
				ips.is_pkts, ips.is_bytes);
d571 1
a571 2
			printf("\tpkts %ld bytes %ld",
				ips.is_pkts, ips.is_bytes);
d573 1
a573 1
			if (ips.is_p == IPPROTO_TCP)
d576 176
a751 39
				printf("\t%hu -> %hu %x:%x %hu:%hu",
					ntohs(ips.is_sport),
					ntohs(ips.is_dport),
					ips.is_send, ips.is_dend,
					ips.is_maxswin, ips.is_maxdwin);
#else
				printf("\t%hu -> %hu %lx:%lx %hu:%hu",
					ntohs(ips.is_sport),
					ntohs(ips.is_dport),
					ips.is_send, ips.is_dend,
					ips.is_maxswin, ips.is_maxdwin);
#endif
			else if (ips.is_p == IPPROTO_UDP)
				printf(" %hu -> %hu", ntohs(ips.is_sport),
					ntohs(ips.is_dport));
			else if (ips.is_p == IPPROTO_ICMP)
				printf(" %hu %hu %d", ips.is_icmp.ics_id,
					ips.is_icmp.ics_seq,
					ips.is_icmp.ics_type);

			printf("\n\t");

			if (ips.is_pass & FR_PASS) {
				printf("pass");
			} else if (ips.is_pass & FR_BLOCK) {
				printf("block");
				switch (ips.is_pass & FR_RETMASK)
				{
				case FR_RETICMP :
					printf(" return-icmp");
					break;
				case FR_FAKEICMP :
					printf(" return-icmp-as-dest");
					break;
				case FR_RETRST :
					printf(" return-rst");
					break;
				default :
					break;
a752 8
			} else if ((ips.is_pass & FR_LOGMASK) == FR_LOG) {
					printf("log");
				if (ips.is_pass & FR_LOGBODY)
					printf(" body");
				if (ips.is_pass & FR_LOGFIRST)
					printf(" first");
			} else if (ips.is_pass & FR_ACCOUNT)
				printf("count");
d754 167
a920 2
			if (ips.is_pass & FR_OUTQUE)
				printf(" out");
d922 12
a933 1
				printf(" in");
d935 23
a957 8
			if ((ips.is_pass & FR_LOG) != 0) {
				printf(" log");
				if (ips.is_pass & FR_LOGBODY)
					printf(" body");
				if (ips.is_pass & FR_LOGFIRST)
					printf(" first");
				if (ips.is_pass & FR_LOGORBLOCK)
					printf(" or-block");
d959 7
a965 24
			if (ips.is_pass & FR_QUICK)
				printf(" quick");
			if (ips.is_pass & FR_KEEPFRAG)
				printf(" keep frags");
			/* a given; no? */
			if (ips.is_pass & FR_KEEPSTATE)
				printf(" keep state");
			printf("\n");

			printf("\tpkt_flags & %x(%x) = %x,\t",
				ips.is_flags & 0xf, ips.is_flags,
				ips.is_flags >> 4);
			printf("\tpkt_options & %x = %x\n", ips.is_optmsk,
				ips.is_opt);
			printf("\tpkt_security & %x = %x, pkt_auth & %x = %x\n",
				ips.is_secmsk, ips.is_sec, ips.is_authmsk,
				ips.is_auth);
			istab[i] = ips.is_next;
			printf("interfaces: in %s[%p] ",
			       get_ifname(ips.is_ifpin), ips.is_ifpin);
			printf("out %s[%p]\n",
			       get_ifname(ips.is_ifpout), ips.is_ifpout);
		}
	}
d967 1
a967 1

d977 1
a977 1
	printf("IP fragment states:\n\t%lu new\n\t%lu expired\n\t%lu hits\n",
d979 1
a979 1
	printf("\t%lu no memory\n\t%lu already exist\n",
d981 1
a981 1
	printf("\t%lu inuse\n", ifsp->ifs_inuse);
d989 1
a989 1
			printf("%s -> ", inet_ntoa(ifr.ipfr_src));
d993 19
a1011 2
			printf("%s %d %d %d %#02x = %#x\n",
				inet_ntoa(ifr.ipfr_dst), ifr.ipfr_id,
d1026 3
a1028 2
	printf("Authorisation hits: %qd\tmisses %qd\n", asp->fas_hits,
		asp->fas_miss);
d1133 128
@


1.21
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: fils.c,v 1.20 2000/03/13 23:40:19 kjell Exp $	*/
d85 1
a85 1
	    "usage: %s [-aAfhIinosv] [-d device] [-M core]\n", 
@


1.20
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
static const char rcsid[] = "@@(#)$IPFilter: fils.c,v 2.2.2.6 2000/02/23 11:16:35 darrenr Exp $";
d317 1
a317 1
			printf("%qd ", fp->fr_hits);
d319 1
a319 1
			printf("%ld ", fp->fr_hits);
d323 1
a323 1
			printf("%qd ", fp->fr_bytes);
d325 1
a325 1
			printf("%ld ", fp->fr_bytes);
@


1.19
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d56 1
a56 1
static const char rcsid[] = "@@(#)$IPFilter: fils.c,v 2.2.2.5 2000/01/27 08:49:40 darrenr Exp $";
d247 2
@


1.18
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.17
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d56 1
a56 1
static const char rcsid[] = "@@(#)$Id: fils.c,v 2.2.2.4 1999/12/04 02:06:24 darrenr Exp $";
d85 1
a85 1
	    "usage: %s [-aAfhIinosv] [-d device] [-M core] [-N system]\n", 
d102 1
a102 1
	while ((c = getopt(argc, argv, "AafhIinosvd:M:")) != -1)
d251 2
a252 1
	printf(" counted %lu\n", fp->f_st[0].fr_acct);
d256 2
a257 1
	printf(" counted %lu\n", fp->f_st[0].fr_acct);
@


1.16
log
@poof
@
text
@d1 1
a1 1
/*    $OpenBSD: fils.c,v 1.15 1999/07/08 00:02:26 deraadt Exp $    */
d9 3
a11 1

d15 1
a15 1
#include <strings.h>
d33 3
d40 1
a40 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
d55 1
a55 1
static const char rcsid[] = "@@(#)$Id: fils.c,v 1.15 1999/07/08 00:02:26 deraadt Exp $";
d74 1
d77 2
d84 2
a85 1
	    "usage: %s [-aAfhIinosv] [-d device] [-M core] [-N system]\n", name);
d89 1
d117 3
d214 2
d230 1
a230 1
	int	frf = 0;
d388 2
a389 2
	printf("\t%lu maximum\n\t%lu no memory\n",
		ipsp->iss_max, ipsp->iss_nomem);
d394 1
a394 1
	for (i = 0; i < IPSTATE_SIZE; i++)
d400 1
a400 1
			printf("%s ttl %ld pass %d pr %d state %d/%d\n",
d412 3
a414 1
				printf("\t%hu -> %hu %lu:%lu %hu:%hu",
d417 9
a425 2
					ips.is_seq, ips.is_ack,
					ips.is_swin, ips.is_dwin);
d440 3
a442 1
				if (ips.is_pass & FR_RETICMP)
d444 5
a448 1
				if (ips.is_pass & FR_RETRST)
d450 4
d468 1
a468 1
			if ((ips.is_pass & (FR_LOGB|FR_LOGP)) != 0) {
d486 2
a487 1
			printf("\tpkt_flags & %x = %x,\t", ips.is_flags & 0xf,
d495 4
d500 1
d509 1
d525 3
d531 1
a531 1
				ifr.ipfr_pass);
d541 2
d555 94
@


1.15
log
@cleanup; still needs kmem removal (terrible)
@
text
@d1 1
a1 1
/*    $OpenBSD: fils.c,v 1.14 1999/02/05 05:58:43 deraadt Exp $    */
d54 1
a54 1
static const char rcsid[] = "@@(#)$Id: fils.c,v 1.14 1999/02/05 05:58:43 deraadt Exp $";
d95 1
a95 1
	while ((c = getopt(argc, argv, "AafhIinosvd:M:N:")) != -1)
a130 3
			break;
		case 'N':
			nlistf = optarg;
@


1.14
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*    $OpenBSD: fils.c,v 1.13 1998/09/15 09:58:34 pattonme Exp $    */
d54 1
a54 1
static const char rcsid[] = "@@(#)$Id: fils.c,v 1.13 1998/09/15 09:58:34 pattonme Exp $";
a55 7
#ifdef	_PATH_UNIX
# define	VMUNIX	_PATH_UNIX
#else
# define	VMUNIX	"/vmunix"
#endif

extern	char	*optarg;
a56 2
#define	PRINTF	(void)printf
#define	FPRINTF	(void)fprintf
d65 2
a75 1

d79 2
a80 1
	fprintf(stderr, "Usage: %s [-aAfhIinosv] [-d <device>]\n", name);
a83 1

d95 1
a95 7
	if (openkmem() == -1)
		exit(-1);

	(void)setuid(getuid());
	(void)setgid(getgid());

	while ((c = getopt(argc, argv, "aAfhIinosvd:")) != -1)
d132 6
d144 11
d187 1
a187 1
		PRINTF("opts %#x name %s\n", opts, name ? name : "<>");
d228 1
a228 1
	PRINTF("dropped packets:\tin %lu\tout %lu\n",
d230 1
a230 1
	PRINTF("non-data packets:\tin %lu\tout %lu\n",
d232 1
a232 1
	PRINTF("no-data packets:\tin %lu\tout %lu\n",
d234 1
a234 1
	PRINTF("non-ip packets:\t\tin %lu\tout %lu\n",
d236 1
a236 1
	PRINTF("   bad packets:\t\tin %lu\tout %lu\n",
d239 1
a239 1
	PRINTF(" input packets:\t\tblocked %lu passed %lu nomatch %lu",
d242 2
a243 2
	PRINTF(" counted %lu\n", fp->f_st[0].fr_acct);
	PRINTF("output packets:\t\tblocked %lu passed %lu nomatch %lu",
d246 2
a247 2
	PRINTF(" counted %lu\n", fp->f_st[0].fr_acct);
	PRINTF(" input packets logged:\tblocked %lu passed %lu\n",
d249 1
a249 1
	PRINTF("output packets logged:\tblocked %lu passed %lu\n",
d251 1
a251 1
	PRINTF(" packets logged:\tinput %lu output %lu\n",
d253 1
a253 1
	PRINTF(" log failures:\t\tinput %lu output %lu\n",
d255 1
a255 1
	PRINTF("fragment state(in):\tkept %lu\tlost %lu\n",
d257 1
a257 1
	PRINTF("fragment state(out):\tkept %lu\tlost %lu\n",
d259 1
a259 1
	PRINTF("packet state(in):\tkept %lu\tlost %lu\n",
d261 1
a261 1
	PRINTF("packet state(out):\tkept %lu\tlost %lu\n",
d263 1
a263 1
	PRINTF("ICMP replies:\t%lu\tTCP RSTs sent:\t%lu\n",
d265 1
a265 1
	PRINTF("Result cache hits(in):\t%lu\t(out):\t%lu\n",
d267 1
a267 1
	PRINTF("IN Pullups succeeded:\t%lu\tfailed:\t%lu\n",
d269 1
a269 1
	PRINTF("OUT Pullups succeeded:\t%lu\tfailed:\t%lu\n",
d271 1
a271 1
	PRINTF("Fastroute successes:\t%lu\tfailures:\t%lu\n",
d273 1
a273 1
	PRINTF("TCP cksum fails(in):\t%lu\t(out):\t%lu\n",
d276 1
a276 1
	PRINTF("Packet log flags set: (%#x)\n", frf);
d278 1
a278 1
		PRINTF("\tpackets passed through filter\n");
d280 1
a280 1
		PRINTF("\tpackets blocked by filter\n");
d282 1
a282 1
		PRINTF("\tpackets not matched by filter\n");
d284 1
a284 1
		PRINTF("\tnone\n");
d304 1
a304 1
			PRINTF("%qd ", fp->fr_hits);
d306 1
a306 1
			PRINTF("%ld ", fp->fr_hits);
d310 1
a310 1
			PRINTF("%qd ", fp->fr_bytes);
d312 1
a312 1
			PRINTF("%ld ", fp->fr_bytes);
d315 1
a315 1
			PRINTF("@@%d ", n);
d345 1
a345 1
			FPRINTF(stderr, "No -i or -o given with -a\n");
d357 1
a357 1
		FPRINTF(stderr, "showlist:opts %#x i %d\n", opts, i);
d360 1
a360 1
		PRINTF("fp %p set %d\n", fp, set);
d362 1
a362 1
		FPRINTF(stderr, "empty list for %s%s\n",
d377 1
a377 1
	PRINTF("IP states added:\n\t%lu TCP\n\t%lu UDP\n\t%lu ICMP\n",
d379 2
a380 2
	PRINTF("\t%lu hits\n\t%lu misses\n", ipsp->iss_hits, ipsp->iss_miss);
	PRINTF("\t%lu maximum\n\t%lu no memory\n",
d382 1
a382 1
	PRINTF("\t%lu active\n\t%lu expired\n\t%lu closed\n",
d391 2
a392 2
			PRINTF("%s -> ", inet_ntoa(ips.is_src));
			PRINTF("%s ttl %ld pass %d pr %d state %d/%d\n",
d397 1
a397 1
			PRINTF("\tpkts %qd bytes %qd",
d400 1
a400 1
			PRINTF("\tpkts %ld bytes %ld",
d404 1
a404 1
				PRINTF("\t%hu -> %hu %lu:%lu %hu:%hu",
d410 1
a410 1
				PRINTF(" %hu -> %hu", ntohs(ips.is_sport),
d413 1
a413 1
				PRINTF(" %hu %hu %d", ips.is_icmp.ics_id,
d417 1
a417 1
			PRINTF("\n\t");
d420 1
a420 1
				PRINTF("pass");
d422 1
a422 1
				PRINTF("block");
d424 1
a424 1
					PRINTF(" return-icmp");
d426 1
a426 1
					PRINTF(" return-rst");
d428 1
a428 1
					PRINTF("log");
d430 1
a430 1
					PRINTF(" body");
d432 1
a432 1
					PRINTF(" first");
d434 1
a434 1
				PRINTF("count");
d437 1
a437 1
				PRINTF(" out");
d439 1
a439 1
				PRINTF(" in");
d442 1
a442 1
				PRINTF(" log");
d444 1
a444 1
					PRINTF(" body");
d446 1
a446 1
					PRINTF(" first");
d448 1
a448 1
					PRINTF(" or-block");
d451 1
a451 1
				PRINTF(" quick");
d453 1
a453 1
				PRINTF(" keep frags");
d456 2
a457 2
				PRINTF(" keep state");
			PRINTF("\n");
d459 1
a459 1
			PRINTF("\tpkt_flags & %x = %x,\t", ips.is_flags & 0xf,
d461 1
a461 1
			PRINTF("\tpkt_options & %x = %x\n", ips.is_optmsk,
d463 1
a463 1
			PRINTF("\tpkt_security & %x = %x, pkt_auth & %x = %x\n",
d478 1
a478 1
	PRINTF("IP fragment states:\n\t%lu new\n\t%lu expired\n\t%lu hits\n",
d480 1
a480 1
	PRINTF("\t%lu no memory\n\t%lu already exist\n",
d482 1
a482 1
	PRINTF("\t%lu inuse\n", ifsp->ifs_inuse);
d490 2
a491 2
			PRINTF("%s -> ", inet_ntoa(ifr.ipfr_src));
			PRINTF("%s %d %d %d %#02x = %#x\n",
@


1.13
log
@Updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*    $OpenBSD: fils.c,v 1.12 1998/01/26 04:13:41 dgregor Exp $    */
d3 1
a3 1
 * Copyright (C) 1993-1997 by Darren Reed.
d54 1
a54 1
static const char rcsid[] = "@@(#)$Id$";
d227 4
d401 1
a401 1
				PRINTF("\t%hu -> %hu %lu:%lu %hu:%hu\n",
d407 1
a407 1
				PRINTF(" %hu -> %hu\n", ntohs(ips.is_sport),
d410 1
a410 1
				PRINTF(" %hu %hu %d\n", ips.is_icmp.ics_id,
d414 2
a415 3
			/* phil@@ultimate.com ... */
			PRINTF("\t");
			/* from "printfr()" */
a454 1
			/* ... phil@@ultimate.com */
@


1.12
log
@IPF 3.2.3
@
text
@d1 1
a1 1
/*    $OpenBSD$    */
d35 6
a40 2
#include "ip_fil_compat.h"
#include "ip_fil.h"
d42 5
a46 5
#include "ip_proxy.h"
#include "ip_nat.h"
#include "ip_frag.h"
#include "ip_state.h"
#include "ip_auth.h"
d49 1
a49 1
#include <paths.h>
d54 1
a54 1
static const char rcsid[] = "@@(#)$Id: fils.c,v 2.0.2.25.2.2 1997/11/20 12:41:04 darrenr Exp $";
d57 1
a57 1
#define	VMUNIX	_PATH_UNIX
d59 1
a59 1
#define	VMUNIX	"/vmunix"
d454 7
@


1.11
log
@merge in 3.1.11
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 1
 * (C)opyright 1993-1996 by Darren Reed.
d16 1
d31 4
d37 2
d42 1
a42 4
#include <netdb.h>
#include <arpa/nameser.h>
#include <resolv.h>
#include "ipf.h"
d44 1
a44 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d48 3
a50 3
#if !defined(lint) && defined(LIBC_SCCS)
static	char	sccsid[] = "@@(#)fils.c	1.21 4/20/96 (C) 1993-1996 Darren Reed";
static	char	rcsid[] = "$DRId: fils.c,v 2.0.1.3 1997/03/20 15:52:50 darrenr Exp $";
d70 9
a78 2
static	void	showstats(), showfrstates();
static	void	showlist(), showipstates();
d80 1
a80 1
void Usage(name)
d83 1
a83 1
	fprintf(stderr, "Usage: %s [-afhIiosv] [-d <device>]\n", name);
d92 1
d96 2
a97 2
	char	c, *name = NULL, *device = IPL_NAME;
	int	fd;
d105 1
a105 1
	while ((c = getopt(argc, argv, "afhIiosvd:")) != -1)
d112 3
d127 3
a132 3
		case 'I' :
			opts |= OPT_INACTIVE;
			break;
d161 12
a172 3
	if ((opts & OPT_IPSTATES) && (ioctl(fd, SIOCGIPST, &ipsst) == -1)) {
		perror("ioctl(SIOCGIPST)");
		exit(-1);
d181 7
d190 1
a190 1
		if((opts & OPT_OUTQUE) && (opts & OPT_INQUE)){
d199 2
d260 4
d270 2
d276 38
a319 1
	struct	frentry	fb;
d321 1
a321 1
	int	i, set, n;
d349 1
a349 1
		PRINTF("fp %#lx set %d\n", (u_long)fp, set);
d355 1
a355 20

	for (n = 1; fp; n++) {
		if (kmemcpy((char *)&fb, (u_long)fp, sizeof(fb)) == -1) {
			perror("kmemcpy");
			return;
		}
		fp = &fb;
		if (opts & OPT_OUTQUE)
			fp->fr_flags |= FR_OUTQUE;
		if (opts & (OPT_HITS|OPT_VERBOSE))
			PRINTF("%ld ", fp->fr_hits);
		if (opts & (OPT_ACCNT|OPT_VERBOSE))
			PRINTF("%ld ", fp->fr_bytes);
		if (opts & OPT_SHOWLINENO)
			PRINTF("@@%d ", n);
		printfr(fp);
		if (opts & OPT_VERBOSE)
			binprint(fp);
		fp = fp->fr_next;
	}
d377 2
a378 1
			if (kmemcpy(&ips, istab[i], sizeof(ips)) == -1)
d381 1
a381 1
			PRINTF("%s age %d pass %d pr %d state %d/%d\n",
d385 7
d399 1
a399 1
				PRINTF("\t%hu -> %hu\n", ntohs(ips.is_sport),
d402 1
a402 1
				PRINTF("\t%hu %hu %d\n", ips.is_icmp.ics_id,
d405 45
d471 1
a471 1
			if (kmemcpy(&ifr, (u_long)ipfrtab[i],
d481 19
@


1.10
log
@Fix int vs. long problems
@
text
@d1 1
d46 1
a46 1
static	char	rcsid[] = "$Id: fils.c,v 1.9 1997/02/17 09:13:11 deraadt Exp $";
d257 4
d273 1
a273 1
		PRINTF("fp %#x set %d\n", (u_long)fp, set);
@


1.9
log
@__OpenBSD__
@
text
@d45 1
a45 1
static	char	rcsid[] = "$Id: fils.c,v 1.8 1997/02/11 22:23:41 kstailey Exp $";
d268 1
a268 1
		PRINTF("fp %#x set %d\n", (u_int)fp, set);
@


1.8
log
@IPF 1.3.7
@
text
@d39 1
a39 1
#ifdef	__NetBSD__
d45 1
a45 1
static	char	rcsid[] = "$Id: fils.c,v 2.0.1.2 1997/01/30 10:21:48 darrenr Exp $";
@


1.7
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d43 1
a43 1
#ifndef	lint
d45 1
a45 1
static	char	rcsid[] = "$Id: fils.c,v 1.6 1996/07/18 05:08:09 dm Exp $";
d127 1
a127 1
			Usage();
d206 4
a209 3
	PRINTF(" packets logged:\tinput %lu-%lu output %lu-%lu\n",
			fp->f_st[0].fr_pkl, fp->f_st[0].fr_skip,
			fp->f_st[1].fr_pkl, fp->f_st[1].fr_skip);
d222 4
d251 1
a251 3
		if (opts & OPT_INQUE)
			fp = (struct frentry *)fiop->f_acctin[set];
		else {
d254 2
a255 1
		}
d318 1
a318 1
			PRINTF("%s age %d pass %d pr %d\n",
d320 2
a321 1
				ips.is_pass, ips.is_p);
d323 1
a323 1
				PRINTF("\t%hu -> %hu %lu:%lu %hu\n",
d326 2
a327 1
					ips.is_seq, ips.is_ack, ips.is_win);
@


1.6
log
@ipfilter 3.1.0
@
text
@d29 1
a30 1
#include "ip_fil_compat.h"
d45 1
a45 1
static	char	rcsid[] = "$Id: fils.c,v 1.2 1996/07/04 13:15:40 darrenr Exp $";
@


1.5
log
@no vmunix here, kernel is /bsd...
@
text
@a0 2
/*	$OpenBSD: fils.c,v 1.4 1996/06/23 14:30:57 deraadt Exp $	*/

d30 2
d44 2
a45 1
static	char	sccsid[] = "@@(#)fils.c	1.20 3/24/96 (C) 1993-1996 Darren Reed";
d50 1
a50 1
#define	VMUNIX	"/bsd"
d68 8
d125 3
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
#define	VMUNIX	"/vmunix"
@


1.3
log
@ipfilter 3.0.4
@
text
@d1 2
@


1.2
log
@IP filter 3.0.1
@
text
@d2 1
a2 1
 * (C)opyright 1993,1994,1995 by Darren Reed.
d42 1
a42 1
static	char	sccsid[] = "@@(#)fils.c	1.18 1/12/96 (C) 1993 Darren Reed";
d100 3
d205 2
d225 1
a225 1
	int	i, set;
d256 2
a257 1
	while (fp) {
d269 2
@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d8 1
d25 1
d29 3
a31 1
#include <netinet/ip_fil.h>
d42 1
a42 1
static	char	sccsid[] = "@@(#)fils.c	1.15 11/11/95 (C) 1993 Darren Reed";
d51 8
a58 4
#define	F_ST	0
#define	F_IN	1
#define	F_OUT	2
#define	F_FL	3
d62 2
a63 2
static	void	showstats();
static	void	showlist();
d69 3
a71 1
	struct	friostat	fio;
d81 1
a81 1
	while ((c = getopt(argc, argv, "hIiovd:")) != -1)
d85 3
d91 3
d106 3
d119 1
d121 3
d128 8
d138 2
a139 2
		printf("opts %#x name %s\n", opts, name ? name : "<>");
	if (opts & OPT_SHOWLIST){
d145 7
a152 2
	else
		showstats(fd, &fio);
d170 1
a170 1
	(void)printf("dropped packets:\tin %ld\tout %ld\n",
d172 1
a172 1
	(void)printf("non-ip packets:\t\tin %ld\tout %ld\n",
d174 1
a174 1
	(void)printf("   bad packets:\t\tin %ld\tout %ld\n",
d177 1
a177 1
	(void)printf(" input packets:\t\tblocked %ld passed %ld nomatch %ld\n",
d180 2
a181 1
	(void)printf("output packets:\t\tblocked %ld passed %ld nomatch %ld\n",
d184 2
a185 1
	(void)printf(" input packets logged:\tblocked %ld passed %ld\n",
d187 1
a187 1
	(void)printf("output packets logged:\tblocked %ld passed %ld\n",
d189 1
a189 1
	(void)printf(" packets logged:\tinput %ld-%ld output %ld-%ld\n",
d192 9
a200 1
	(void)printf("ICMP replies:\t%ld\tTCP RSTs sent:\t%ld\n",
d203 1
a203 1
	(void)printf("Packet log flags set: (%#x)\n", frf);
d205 1
a205 1
		printf("\tpackets passed through filter\n");
d207 1
a207 1
		printf("\tpackets blocked by filter\n");
d209 1
a209 1
		printf("\tnone\n");
d222 12
a233 1
	if (opts & OPT_OUTQUE)
d235 2
a236 1
	else if (opts & OPT_INQUE)
d238 2
a239 1
	else
a240 5
	set = fiop->f_active;
	if (opts & OPT_INACTIVE)
		set = 1 - set;
	fp = (i == F_IN) ? (struct frentry *)fiop->f_fin[set] :
			   (struct frentry *)fiop->f_fout[set];
d242 1
a242 1
		(void)fprintf(stderr, "showlist:opts %#x i %d\n", opts, i);
d245 1
a245 1
		printf("fp %#x set %d\n", (u_int)fp, set);
d247 2
a248 2
		(void)fprintf(stderr, "empty list for filter%s\n",
			(i == F_IN) ? "in" : "out");
d260 3
a262 1
			printf("%d ", fp->fr_hits);
d268 70
@
