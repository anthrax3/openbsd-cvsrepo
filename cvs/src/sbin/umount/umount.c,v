head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.2
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.8
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.4
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.4
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.12
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.10
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.12.16.17.44.59;	author krw;	state Exp;
branches;
next	1.26;
commitid	q7MaMOobu9Z5raUb;

1.26
date	2015.01.16.06.40.01;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2014.02.21.19.00.01;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.07.21.21.07.10;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2013.04.21.11.56.09;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.29.18.44.40;	author landry;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.26.06.55.06;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.02.15.19.25;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.28.16.23.58;	author bluhm;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.29.12.51.26;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.03.22.32.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.38;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.18.08.07.51;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.27.20.06.00;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.11.18.38.32;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.05.18.47.10;	author imp;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.30.02.05.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.02.27.07.59.30;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.02.17.18.03.47;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.41.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.32.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.12.11.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.06.20.29.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Eliminate some gcc warnings about 'unused variables', mostly by
adding appropriate #ifdef's around declarations.

ok millert@@ (with a tweak I will commit separately)
@
text
@/*	$OpenBSD: umount.c,v 1.26 2015/01/16 06:40:01 deraadt Exp $	*/
/*	$NetBSD: umount.c,v 1.16 1996/05/11 14:13:55 mycroft Exp $	*/

/*-
 * Copyright (c) 1980, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

#include <netdb.h>
#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#include <rpc/pmap_prot.h>
#include <nfs/rpcv2.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

typedef enum { MNTON, MNTFROM } mntwhat;

int	fflag, verbose;
char	**typelist = NULL;
char	*nfshost;

char	*getmntname(char *, mntwhat, char *);
void	 maketypelist(char *);
int	 selected(const char *);
int	 namematch(struct hostent *);
int	 umountall(void);
int	 umountfs(char *);
void	 usage(void);
int	 xdr_dir(XDR *, char *);

int
main(int argc, char *argv[])
{
	int all, ch, errs;

	/* Start disks transferring immediately. */
	sync();

	all = 0;
	while ((ch = getopt(argc, argv, "afh:t:v")) != -1)
		switch (ch) {
		case 'a':
			all = 1;
			break;
		case 'f':
			fflag = MNT_FORCE;
			break;
		case 'h':	/* -h implies -a. */
			all = 1;
			nfshost = optarg;
			break;
		case 't':
			if (typelist != NULL)
				errx(1, "only one -t option may be specified.");
			maketypelist(optarg);
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	argc -= optind;
	argv += optind;

	if ((argc == 0 && !all) || (argc != 0 && all))
		usage();

	/* -h implies "-t nfs" if no -t flag. */
	if ((nfshost != NULL) && (typelist == NULL))
		maketypelist(MOUNT_NFS);

	if (all)
		errs = umountall();
	else
		for (errs = 0; *argv != NULL; ++argv)
			if (umountfs(*argv) != 0)
				errs = 1;
	return (errs);
}

int
umountall(void)
{
	struct statfs *fs;
	int n;
	int rval;

	n = getmntinfo(&fs, MNT_NOWAIT);
	if (n == 0)
		err(1, NULL);

	rval = 0;
	while (--n >= 0) {
		/* Ignore the root. */
		if (strncmp(fs[n].f_mntonname, "/", MNAMELEN) == 0)
			continue;
		if (!selected(fs[n].f_fstypename))
			continue;
		if (umountfs(fs[n].f_mntonname))
			rval = 1;
	}
	return (rval);
}

int
umountfs(char *oname)
{
	struct hostent *hp;
#ifndef NO_NFS
	struct sockaddr_in saddr;
	struct timeval pertry, try;
	CLIENT *clp;
	int so;
#endif
	struct stat sb;
	char *delimp, *hostp, *mntpt;
	char *name, *newname, rname[PATH_MAX], type[MFSNAMELEN];

	if (isduid(oname, 0) || realpath(oname, rname) == NULL)
		mntpt = name = oname;
	else
		mntpt = name = rname;
	newname = NULL;

	/* If we can stat the file, check to see if it is a device or non-dir */
	if (stat(name, &sb) == 0) {
	    if (S_ISBLK(sb.st_mode)) {
		if ((mntpt = getmntname(name, MNTON, type)) == NULL) {
			warnx("%s: not currently mounted", name);
			return (1);
		}
	    } else if (!S_ISDIR(sb.st_mode)) {
		warnx("%s: not a directory or special device", name);
		return (1);
	    }
	}

	/*
	 * Look up the name in the mount table.
	 * 99.9% of the time the path in the kernel is the one
	 * realpath() returns but check the original just in case...
	 */
	if (!(newname = getmntname(name, MNTFROM, type)) &&
	    !(mntpt = getmntname(name, MNTON, type)) ) {
		mntpt = oname;
		if (!(newname = getmntname(oname, MNTFROM, type)) &&
		    !(mntpt = getmntname(oname, MNTON, type))) {
			warnx("%s: not currently mounted", oname);
			return (1);
		}
	}
	if (newname)
		name = newname;

	if (!selected(type))
		return (1);

	if (!strncmp(type, MOUNT_NFS, MFSNAMELEN)) {
		if ((delimp = strchr(name, '@@')) != NULL) {
			hostp = delimp + 1;
			*delimp = '\0';
			hp = gethostbyname(hostp);
			*delimp = '@@';
		} else if ((delimp = strchr(name, ':')) != NULL) {
			*delimp = '\0';
			hostp = name;
			hp = gethostbyname(hostp);
			name = delimp + 1;
			*delimp = ':';
		} else
			hp = NULL;
		if (!namematch(hp))
			return (1);
	}

	if (verbose)
		printf("%s: unmount from %s\n", name, mntpt);

	if (unmount(mntpt, fflag) < 0) {
		warn("%s", mntpt);
		return (1);
	}

#ifndef NO_NFS
	if (!strncmp(type, MOUNT_NFS, MFSNAMELEN) &&
	    (hp != NULL) && !(fflag & MNT_FORCE)) {
		enum clnt_stat clnt_stat;

		*delimp = '\0';
		memset(&saddr, 0, sizeof(saddr));
		saddr.sin_family = AF_INET;
		saddr.sin_port = 0;
		memmove(&saddr.sin_addr, hp->h_addr, hp->h_length);
		pertry.tv_sec = 3;
		pertry.tv_usec = 0;
		so = RPC_ANYSOCK;
		if ((clp = clntudp_create(&saddr,
		    RPCPROG_MNT, RPCMNT_VER1, pertry, &so)) == NULL) {
			clnt_pcreateerror("Cannot MNT RPC");
			return (1);
		}
		clp->cl_auth = authunix_create_default();
		try.tv_sec = 20;
		try.tv_usec = 0;
		clnt_stat = clnt_call(clp,
		    RPCMNT_UMOUNT, xdr_dir, name, xdr_void, (caddr_t)0, try);
		if (clnt_stat != RPC_SUCCESS) {
			clnt_perror(clp, "Bad MNT RPC");
			return (1);
		}
		auth_destroy(clp->cl_auth);
		clnt_destroy(clp);
	}
#endif
	return (0);
}

char *
getmntname(char *name, mntwhat what, char *type)
{
	struct statfs *mntbuf;
	int n;

	if ((n = getmntinfo(&mntbuf, MNT_NOWAIT)) == 0) {
		warn("getmntinfo");
		return (NULL);
	}
	while (--n >= 0) {
		if ((what == MNTON) &&
		    (strncmp(mntbuf[n].f_mntfromname, name, MNAMELEN) == 0 ||
		     strncmp(mntbuf[n].f_mntfromspec, name, MNAMELEN) == 0)) {
			if (type)
				memcpy(type, mntbuf[n].f_fstypename,
				    sizeof(mntbuf[n].f_fstypename));
			return (mntbuf[n].f_mntonname);
		}
		if ((what == MNTFROM) &&
		    (strncmp(mntbuf[n].f_mntonname, name, MNAMELEN) == 0)) {
			if (type)
				memcpy(type, mntbuf[n].f_fstypename,
				    sizeof(mntbuf[n].f_fstypename));
			return (mntbuf[n].f_mntfromname);
		}
	}
	return (NULL);
}

static enum { IN_LIST, NOT_IN_LIST } which;

int
selected(const char *type)
{
	char **av;

	/* If no type specified, it's always selected. */
	if (typelist == NULL)
		return (1);
	for (av = typelist; *av != NULL; ++av)
		if (!strncmp(type, *av, MFSNAMELEN))
			return (which == IN_LIST ? 1 : 0);
	return (which == IN_LIST ? 0 : 1);
}

void
maketypelist(char *fslist)
{
	int i;
	char *nextcp, **av;

	if ((fslist == NULL) || (fslist[0] == '\0'))
		errx(1, "empty type list");

	/*
	 * XXX
	 * Note: the syntax is "noxxx,yyy" for no xxx's and
	 * no yyy's, not the more intuitive "noxxx,noyyy".
	 */
	if (fslist[0] == 'n' && fslist[1] == 'o') {
		fslist += 2;
		which = NOT_IN_LIST;
	} else
		which = IN_LIST;

	/* Count the number of types. */
	for (i = 1, nextcp = fslist; (nextcp = strchr(nextcp, ',')); i++)
		++nextcp;

	/* Build an array of that many types. */
	if ((av = typelist = calloc(i + 1, sizeof(char *))) == NULL)
		err(1, NULL);
	av[0] = fslist;
	for (i = 1, nextcp = fslist; (nextcp = strchr(nextcp, ',')); i++) {
		*nextcp = '\0';
		av[i] = ++nextcp;
	}
	/* Terminate the array. */
	av[i] = NULL;
}

int
namematch(struct hostent *hp)
{
	char *cp, **np;

	if ((hp == NULL) || (nfshost == NULL))
		return (1);

	if (strcasecmp(nfshost, hp->h_name) == 0)
		return (1);

	if ((cp = strchr(hp->h_name, '.')) != NULL) {
		*cp = '\0';
		if (strcasecmp(nfshost, hp->h_name) == 0)
			return (1);
	}
	for (np = hp->h_aliases; *np; np++) {
		if (strcasecmp(nfshost, *np) == 0)
			return (1);
		if ((cp = strchr(*np, '.')) != NULL) {
			*cp = '\0';
			if (strcasecmp(nfshost, *np) == 0)
				return (1);
		}
	}
	return (0);
}

#ifndef NO_NFS
/*
 * xdr routines for mount rpc's
 */
int
xdr_dir(XDR *xdrsp, char *dirp)
{
	return (xdr_string(xdrsp, &dirp, RPCMNT_PATHLEN));
}
#endif

void
usage(void)
{
	fprintf(stderr,
	    "usage: %s\n       %s\n",
	    "umount [-fv] special | node",
	    "umount -a [-fv] [-h host] [-t type]");
	exit(1);
}
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.25 2014/02/21 19:00:01 deraadt Exp $	*/
d148 1
a149 1
	struct stat sb;
d153 2
@


1.25
log
@Permit building without portmap/mountd rpc calls in the fallback nfs path
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.24 2013/07/21 21:07:10 millert Exp $	*/
a32 1
#include <sys/param.h>
d50 1
d154 1
a154 1
	char *name, *newname, rname[MAXPATHLEN], type[MFSNAMELEN];
@


1.24
log
@In getmntname(), iterate through the list of mount points from
end to beginning instead of from beginning to end.  This matches
the behavior of umountall() and fixes "umount -a" in cases where
there are multiple file systems on the same mount point.
Based on a diff from naddy@@.  OK naddy@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.23 2013/04/21 11:56:09 jsing Exp $	*/
a146 1
	enum clnt_stat clnt_stat;
d221 1
d224 2
d251 1
d365 1
d374 1
@


1.23
log
@Check both f_mntfromname and f_mntfromspec when looking for a mounted
filesystem. This makes umount via DUID possible.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.22 2012/05/29 18:44:40 landry Exp $	*/
d256 1
a256 1
	int i, mntsize;
d258 1
a258 1
	if ((mntsize = getmntinfo(&mntbuf, MNT_NOWAIT)) == 0) {
d262 1
a262 1
	for (i = 0; i < mntsize; i++) {
d264 2
a265 2
		    (strncmp(mntbuf[i].f_mntfromname, name, MNAMELEN) == 0 ||
		     strncmp(mntbuf[i].f_mntfromspec, name, MNAMELEN) == 0)) {
d267 3
a269 3
				memcpy(type, mntbuf[i].f_fstypename,
				    sizeof(mntbuf[i].f_fstypename));
			return (mntbuf[i].f_mntonname);
d272 1
a272 1
		    (strncmp(mntbuf[i].f_mntonname, name, MNAMELEN) == 0)) {
d274 3
a276 3
				memcpy(type, mntbuf[i].f_fstypename,
				    sizeof(mntbuf[i].f_fstypename));
			return (mntbuf[i].f_mntfromname);
@


1.22
log
@Fix typo in error message ("Cannot MNT PRC"->RPC)
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.21 2009/10/27 23:59:34 deraadt Exp $	*/
d51 1
d157 1
a157 1
	if (realpath(oname, rname) == NULL)
d215 1
a215 1
		(void)printf("%s: unmount from %s\n", name, mntpt);
d263 3
a265 1
		if ((what == MNTON) && !strcmp(mntbuf[i].f_mntfromname, name)) {
d271 2
a272 1
		if ((what == MNTFROM) && !strcmp(mntbuf[i].f_mntonname, name)) {
d374 1
a374 1
	(void)fprintf(stderr,
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.20 2008/03/26 06:55:06 otto Exp $	*/
d233 1
a233 1
			clnt_pcreateerror("Cannot MNT PRC");
@


1.20
log
@zap undocumented 'F' flag; prompted by J.Thornburg. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.19 2007/09/02 15:19:25 deraadt Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)umount.c	8.3 (Berkeley) 2/20/94";
#else
static char rcsid[] = "$OpenBSD: umount.c,v 1.19 2007/09/02 15:19:25 deraadt Exp $";
#endif
#endif /* not lint */
@


1.19
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.18 2007/01/28 16:23:58 bluhm Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.18 2007/01/28 16:23:58 bluhm Exp $";
d68 1
a68 1
int	fake, fflag, verbose;
d90 1
a90 1
	while ((ch = getopt(argc, argv, "aFfh:t:v")) != -1)
a94 3
		case 'F':
			fake = 1;
			break;
a228 2
	if (fake)
		return (0);
@


1.18
log
@Remove #include <fstab.h> as there is no fstab in umount anymore.
Always use defined type name.  Comment clarification.
No binary change.  ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.17 2006/06/29 12:51:26 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.17 2006/06/29 12:51:26 jmc Exp $";
d338 1
a338 1
	if ((av = typelist = malloc((i + 1) * sizeof(char *))) == NULL)
@


1.17
log
@[-t ufs | lfs | external_type] -> [-t type]

syncs it w/ mount(8) too; suggested by martin
usage() update
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.16 2003/07/29 18:38:36 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.16 2003/07/29 18:38:36 deraadt Exp $";
a60 1
#include <fstab.h>
d125 1
a125 1
		maketypelist("nfs");
d325 1
a325 1
	 * no yyy's, not the more intuitive "noyyy,noyyy".
@


1.16
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.15 2003/06/02 20:06:17 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.15 2003/06/02 20:06:17 millert Exp $";
d392 2
a393 2
	    "umount [-fv] [-t fstypelist] special | node",
	    "umount -a[fv] [-h host] [-t fstypelist]");
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.14 2002/07/03 22:32:34 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.14 2002/07/03 22:32:34 deraadt Exp $";
d127 1
a127 1
		
@


1.14
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.13 2002/02/16 21:27:38 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.13 2002/02/16 21:27:38 millert Exp $";
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.12 2001/05/18 08:07:51 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.12 2001/05/18 08:07:51 mickey Exp $";
d87 1
a87 3
main(argc, argv)
	int argc;
	char *argv[];
d142 1
a142 1
umountall()
d166 1
a166 2
umountfs(oname)
	char *oname;
d276 1
a276 4
getmntname(name, what, type)
	char *name;
	mntwhat what;
	char *type;
d305 1
a305 2
selected(type)
	const char *type;
d319 1
a319 2
maketypelist(fslist)
	char *fslist;
d355 1
a355 2
namematch(hp)
	struct hostent *hp;
d386 1
a386 3
xdr_dir(xdrsp, dirp)
	XDR *xdrsp;
	char *dirp;
d392 1
a392 1
usage()
@


1.12
log
@why exit if returns
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.11 2000/07/27 20:06:00 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.11 2000/07/27 20:06:00 millert Exp $";
d77 8
a84 8
char	*getmntname __P((char *, mntwhat, char *));
void	 maketypelist __P((char *));
int	 selected __P((const char *));
int	 namematch __P((struct hostent *));
int	 umountall __P((void));
int	 umountfs __P((char *));
void	 usage __P((void));
int	 xdr_dir __P((XDR *, char *));
@


1.11
log
@Look up the pathname verbatim in mount table in addition to the realpath(3)ed
version.  Basically just a generalization of my previous commit in this area.
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.10 2000/04/11 18:38:32 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.10 2000/04/11 18:38:32 millert Exp $";
d140 1
a140 1
	exit(errs);
@


1.10
log
@If realpath() fails, just use the old name and don't make it a fatal error.
Closes PR #1185
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.9 2000/02/05 18:47:10 imp Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.9 2000/02/05 18:47:10 imp Exp $";
d187 3
a189 17
	if (stat(name, &sb) < 0) {
		/*
		 * 99.9% of the time the path in the kernel is the one
		 * realpath() returns but check the original just in case...
		 */
		if (!(newname = getmntname(name, MNTFROM, type)) &&
		    !(mntpt = getmntname(name, MNTON, type)) ) {
			mntpt = oname;
			if (!(newname = getmntname(oname, MNTFROM, type)) &&
			    !(mntpt = getmntname(oname, MNTON, type))) {
				warnx("%s: not currently mounted", oname);
				return (1);
			}
		}
		if (newname)
			name = newname;
	} else if (S_ISBLK(sb.st_mode)) {
d194 17
a210 3
	} else if (S_ISDIR(sb.st_mode)) {
		if ((name = getmntname(mntpt, MNTFROM, type)) == NULL) {
			warnx("%s: not currently mounted", mntpt);
a212 3
	} else {
		warnx("%s: not a directory or special device", name);
		return (1);
d214 2
@


1.9
log
@Fix uninitialized access introduced by millert.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.8 2000/01/30 02:05:05 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.8 2000/01/30 02:05:05 millert Exp $";
d181 4
a184 5
	if (realpath(oname, rname) == NULL) {
		warn("%s", oname);
		return (1);
	}
	mntpt = name = rname;
@


1.8
log
@When looking up a filesystem in the mount table, check the path as
giving by the user in addition to what reapath() returns.  Things
that call mount(2) directly may use paths different than what
realpath() returns but you still want to be able to umount them...
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.7 1999/02/27 07:59:30 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.7 1999/02/27 07:59:30 deraadt Exp $";
d181 2
a182 2
	if (realpath(name, rname) == NULL) {
		warn("%s", rname);
@


1.7
log
@reverse complete garbage which was not even tested, tsk tsk tsk
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.5 1997/01/15 23:41:45 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.5 1997/01/15 23:41:45 millert Exp $";
d127 1
a127 1
	if (argc == 0 && !all || argc != 0 && all)
d168 2
a169 2
umountfs(name)
	char *name;
d178 2
a179 1
	char *delimp, *hostp, *mntpt, rname[MAXPATHLEN], type[MFSNAMELEN];
a184 1

d186 1
d189 10
a198 4
		if ((name = getmntname(mntpt, MNTFROM, type)) == NULL) {
			name = rname;
			if ((mntpt = getmntname(name, MNTON, type)) == NULL) {
				warnx("%s: not currently mounted", name);
d202 2
d349 1
a349 1
	for (i = 1, nextcp = fslist; nextcp = strchr(nextcp, ','); i++)
d356 1
a356 1
	for (i = 1, nextcp = fslist; nextcp = strchr(nextcp, ','); i++) {
@


1.6
log
@try harder to match the mntonname with the name we are trying to unmount
@
text
@a278 1
	char realonname[MAXPATHLEN], realfromname[MAXPATHLEN];
d285 1
a285 11
		/*
		 * Translate the name in case the mount call wasn't done
		 * with a translated name.
		 * (but return the name as it is in the struct)
		 */
		if (realpath(mntbuf[i].f_mntfromname, realfromname) == NULL)
			continue;
		if (realpath(mntbuf[i].f_mntonname, realonname) == NULL)
			continue;

		if ((what == MNTON) && !strcmp(realfromname, name)) {
d291 1
a291 1
		if ((what == MNTFROM) && !strcmp(realonname, name)) {
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.4 1996/06/23 14:32:53 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.4 1996/06/23 14:32:53 deraadt Exp $";
d279 1
d286 11
a296 1
		if ((what == MNTON) && !strcmp(mntbuf[i].f_mntfromname, name)) {
d302 1
a302 1
		if ((what == MNTFROM) && !strcmp(mntbuf[i].f_mntonname, name)) {
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: umount.c,v 1.16 1996/05/11 14:13:55 mycroft Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: umount.c,v 1.16 1996/05/11 14:13:55 mycroft Exp $";
d97 1
a97 1
	while ((ch = getopt(argc, argv, "aFfh:t:v")) != EOF)
@


1.3
log
@add more error checking to greywolf patch
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: umount.c,v 1.16 1996/05/11 14:13:55 mycroft Exp $";
@


1.2
log
@use mounted table instead of fstab for -a; netbsd pr#2363; from greywolf@@defender.VAS.viewlogic.com
@
text
@d1 1
a1 1
/*	$NetBSD: umount.c,v 1.15 1995/09/22 02:03:48 mycroft Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: umount.c,v 1.15 1995/09/22 02:03:48 mycroft Exp $";
d133 1
a133 3
	if (all) {
		if (setfsent() == 0)
			err(1, "%s", _PATH_FSTAB);
d135 1
a135 1
	} else
d145 17
a161 11
	struct statfs *mtab;
	int rval = 0;
	int nfsys;	/* number of mounted filesystems */
	int i;

	if (nfsys = getmntinfo(&mtab, MNT_NOWAIT)) {
	    for (i=nfsys - 1; i; i--) {
		if (strcmp(mtab[i].f_mntonname, "/")) {
		    if (umountfs(mtab[i].f_mntonname)) rval = 1;
    	    	}
	    }
d163 1
a163 1
	return(rval);
@


1.1
log
@Initial revision
@
text
@d147 4
a150 3
	struct fstab *fs;
	int rval;
	char *cp;
d152 6
a157 26
	while ((fs = getfsent()) != NULL) {
		/* Ignore the root. */
		if (strcmp(fs->fs_file, "/") == 0)
			continue;
		/*
		 * !!!
		 * Historic practice: ignore unknown FSTAB_* fields.
		 */
		if (strcmp(fs->fs_type, FSTAB_RW) &&
		    strcmp(fs->fs_type, FSTAB_RO) &&
		    strcmp(fs->fs_type, FSTAB_RQ))
			continue;

		if (!selected(fs->fs_vfstype))
			continue;

		/* 
		 * We want to unmount the file systems in the reverse order
		 * that they were mounted.  So, we save off the file name
		 * in some allocated memory, and then call recursively.
		 */
		if ((cp = malloc((size_t)strlen(fs->fs_file) + 1)) == NULL)
			err(1, NULL);
		(void)strcpy(cp, fs->fs_file);
		rval = umountall();
		return (umountfs(cp) || rval);
d159 1
a159 1
	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
