head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.12
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.18
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.14
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.12
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.10
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.5.0.12
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.10
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2013.11.22.04.14.00;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.29.17.28.29;	author ckuethe;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.28.07.30.35;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.15.06.26.28;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.26.08.01.54;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.03.22.32.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.26.09.24.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.06.51.41;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.17.19.42.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	99.01.11.20.59.29;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.09.14.10.37.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.10.20.08.36.27;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.46.04;	author deraadt;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: preen.c,v 1.19 2013/11/22 04:14:00 deraadt Exp $	*/
/*	$NetBSD: preen.c,v 1.15 1996/09/28 19:21:42 christos Exp $	*/

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/queue.h>

#include <fstab.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <err.h>

#include "fsutil.h"

struct partentry {
	TAILQ_ENTRY(partentry)	 p_entries;
	char		  	*p_devname;	/* device name */
	char			*p_mntpt;	/* mount point */
	char		  	*p_type;	/* filesystem type */
	void			*p_auxarg;	/* auxiliary argument */
};

TAILQ_HEAD(part, partentry) badh;

struct diskentry {
	TAILQ_ENTRY(diskentry) 	    d_entries;
	char		       	   *d_name;	/* disk base name */
	TAILQ_HEAD(prt, partentry)  d_part;	/* list of partitions on disk */
	pid_t			    d_pid;	/* 0 or pid of fsck proc */
};

TAILQ_HEAD(disk, diskentry) diskh;

static int nrun = 0, ndisks = 0;

static struct diskentry *finddisk(const char *);
static void addpart(const char *, const char *, const char *, void *);
static int startdisk(struct diskentry *,
    int (*)(const char *, const char *, const char *, void *, pid_t *));
static void printpart(void);

int
checkfstab(int flags, int maxrun, void *(*docheck)(struct fstab *),
    int (*checkit)(const char *, const char *, const char *, void *, pid_t *))
{
	struct fstab *fs;
	struct diskentry *d, *nextdisk;
	struct partentry *p;
	int ret, retcode, passno, sumstatus, status, maxp;
	void *auxarg;
	char *name;
	pid_t pid;

	TAILQ_INIT(&badh);
	TAILQ_INIT(&diskh);

	sumstatus = 0;
	maxp = 2;

	for (passno = 1; passno <= maxp; passno++) {
		if (setfsent() == 0) {
			warnx("Can't open checklist file: %s", _PATH_FSTAB);
			return (8);
		}
		while ((fs = getfsent()) != 0) {
			if ((auxarg = (*docheck)(fs)) == NULL)
				continue;

			name = blockcheck(fs->fs_spec);
			if (flags & CHECK_DEBUG)
				printf("pass %d, name %s\n", passno, name);
			maxp = (fs->fs_passno > maxp) ? fs->fs_passno : maxp;

			if ((flags & CHECK_PREEN) == 0 ||
			    (passno == 1 && fs->fs_passno == 1)) {
				if (name == NULL) {
					if (flags & CHECK_PREEN)
						return 8;
					else
						continue;
				}
				sumstatus = (*checkit)(fs->fs_vfstype,
				    name, fs->fs_file, auxarg, NULL);

				if (sumstatus)
					return (sumstatus);
			} else  {
				if (name == NULL) {
					(void) fprintf(stderr,
					    "BAD DISK NAME %s\n", fs->fs_spec);
					sumstatus |= 8;
					continue;
				}
				if (passno == fs->fs_passno)
					addpart(fs->fs_vfstype, name,
					    fs->fs_file, auxarg);
			}
		}
		if ((flags & CHECK_PREEN) == 0)
			return 0;
	}

	if (flags & CHECK_DEBUG)
		printpart();

	if (flags & CHECK_PREEN) {
		if (maxrun == 0)
			maxrun = ndisks;
		if (maxrun > ndisks)
			maxrun = ndisks;
		nextdisk = TAILQ_FIRST(&diskh);
		for (passno = 0; passno < maxrun; ++passno) {
			if ((ret = startdisk(nextdisk, checkit)) != 0)
				return ret;
			nextdisk = TAILQ_NEXT(nextdisk, d_entries);
		}

		while ((pid = wait(&status)) != -1) {
			TAILQ_FOREACH(d, &diskh, d_entries)
				if (d->d_pid == pid)
					break;

			if (d == NULL) {
				warnx("Unknown pid %ld", (long)pid);
				continue;
			}


			if (WIFEXITED(status))
				retcode = WEXITSTATUS(status);
			else
				retcode = 0;

			p = TAILQ_FIRST(&d->d_part);

			if (flags & (CHECK_DEBUG|CHECK_VERBOSE))
				(void) printf("done %s: %s (%s) = %x\n",
				    p->p_type, p->p_devname, p->p_mntpt,
				    status);

			if (WIFSIGNALED(status)) {
				(void) fprintf(stderr,
				    "%s: %s (%s): EXITED WITH SIGNAL %d\n",
				    p->p_type, p->p_devname, p->p_mntpt,
				    WTERMSIG(status));
				retcode = 8;
			}

			TAILQ_REMOVE(&d->d_part, p, p_entries);

			if (retcode != 0) {
				TAILQ_INSERT_TAIL(&badh, p, p_entries);
				sumstatus |= retcode;
			} else {
				free(p->p_type);
				free(p->p_devname);
				free(p);
			}
			d->d_pid = 0;
			nrun--;

			if (TAILQ_EMPTY(&d->d_part))
				ndisks--;

			if (nextdisk == NULL) {
				if (!TAILQ_EMPTY(&d->d_part)) {
					if ((ret = startdisk(d, checkit)) != 0)
						return ret;
				}
			} else if (nrun < maxrun && nrun < ndisks) {
				for ( ;; ) {
					nextdisk = TAILQ_NEXT(nextdisk,
					    d_entries);
					if (nextdisk == NULL)
						nextdisk = TAILQ_FIRST(&diskh);
					if (!TAILQ_EMPTY(&nextdisk->d_part) &&
					    nextdisk->d_pid == 0)
						break;
				}
				if ((ret = startdisk(nextdisk, checkit)) != 0)
					return ret;
			}
		}
	}
	if (sumstatus) {
		p = TAILQ_FIRST(&badh);
		if (p == NULL)
			return (sumstatus);

		(void) fprintf(stderr,
			"THE FOLLOWING FILE SYSTEM%s HAD AN %s\n\t",
			TAILQ_NEXT(p, p_entries) ? "S" : "",
			"UNEXPECTED INCONSISTENCY:");

		for (; p; p = TAILQ_NEXT(p, p_entries))
			(void) fprintf(stderr,
			    "%s: %s (%s)%s", p->p_type, p->p_devname,
			    p->p_mntpt, TAILQ_NEXT(p, p_entries) ? ", " : "\n");

		return sumstatus;
	}
	(void) endfsent();
	return (0);
}


static struct diskentry *
finddisk(const char *name)
{
	const char *p;
	size_t len = 0;
	struct diskentry *d;

	for (p = name + strlen(name) - 1; p >= name; --p)
		if (isdigit((unsigned char)*p)) {
			len = p - name + 1;
			break;
		}

	if (p < name)
		len = strlen(name);

	TAILQ_FOREACH(d, &diskh, d_entries)
		if (strncmp(d->d_name, name, len) == 0 && d->d_name[len] == 0)
			return d;

	d = emalloc(sizeof(*d));
	d->d_name = estrdup(name);
	d->d_name[len] = '\0';
	TAILQ_INIT(&d->d_part);
	d->d_pid = 0;

	TAILQ_INSERT_TAIL(&diskh, d, d_entries);
	ndisks++;

	return d;
}


static void
printpart(void)
{
	struct diskentry *d;
	struct partentry *p;

	TAILQ_FOREACH(d, &diskh, d_entries) {
		(void) printf("disk %s: ", d->d_name);
		TAILQ_FOREACH(p, &d->d_part, p_entries)
			(void) printf("%s ", p->p_devname);
		(void) printf("\n");
	}
}


static void
addpart(const char *type, const char *devname, const char *mntpt, void *auxarg)
{
	struct diskentry *d = finddisk(devname);
	struct partentry *p;

	TAILQ_FOREACH(p, &d->d_part, p_entries)
		if (strcmp(p->p_devname, devname) == 0) {
			warnx("%s in fstab more than once!", devname);
			return;
		}

	p = emalloc(sizeof(*p));
	p->p_devname = estrdup(devname);
	p->p_mntpt = estrdup(mntpt);
	p->p_type = estrdup(type);
	p->p_auxarg = auxarg;

	TAILQ_INSERT_TAIL(&d->d_part, p, p_entries);
}


static int
startdisk(struct diskentry *d,
    int (*checkit)(const char *, const char *, const char *, void *, pid_t *))
{
	struct partentry *p = TAILQ_FIRST(&d->d_part);
	int rv;

	while ((rv = (*checkit)(p->p_type, p->p_devname, p->p_mntpt,
	    p->p_auxarg, &d->d_pid)) != 0 && nrun > 0)
		sleep(10);

	if (rv == 0)
		nrun++;

	return rv;
}
@


1.19
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.18 2010/11/29 17:28:29 ckuethe Exp $	*/
a32 1
#include <sys/param.h>
@


1.18
log
@make "fsck -p" respect fs_passno > 2, as implied by the manual. This can
be used to schedule the check of softraid(4) disks after all the slices
on the component disks have been checked.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.17 2009/10/27 23:59:32 deraadt Exp $	*/
d248 1
a248 1
		if (isdigit(*p)) {
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.16 2005/10/28 07:30:35 otto Exp $	*/
d82 1
a82 1
	int ret, retcode, passno, sumstatus, status;
d91 1
d93 1
a93 1
	for (passno = 1; passno <= 2; passno++) {
d105 1
d120 1
a120 1
			} else if (passno == 2 && fs->fs_passno > 1) {
d127 3
a129 2
				addpart(fs->fs_vfstype, name, fs->fs_file,
				    auxarg);
@


1.16
log
@Change some TAILQ_FIRST() == NULL tests into TAILQ_EMPTY(). The first
form is valid, but in these cases its more clear to say what you
mean. ok pat@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.15 2005/10/15 06:26:28 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)preen.c	8.3 (Berkeley) 12/6/94";
#else
static const char rcsid[] = "$OpenBSD: preen.c,v 1.15 2005/10/15 06:26:28 otto Exp $";
#endif
#endif /* not lint */
@


1.15
log
@Use queue macros instead of directly accessing fields. ok miod@@ aaron@@
jaredy@@ patrick@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.14 2003/06/26 08:01:54 tedu Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: preen.c,v 1.14 2003/06/26 08:01:54 tedu Exp $";
d200 1
a200 1
			if (TAILQ_FIRST(&d->d_part) == NULL)
d204 1
a204 1
				if (TAILQ_FIRST(&d->d_part)) {
d214 2
a215 2
					if (TAILQ_FIRST(&nextdisk->d_part) !=
					    NULL && nextdisk->d_pid == 0)
@


1.14
log
@const the rcsid, and make it say OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.13 2003/06/02 20:06:15 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD$";
d149 1
a149 1
		nextdisk = diskh.tqh_first;
d153 1
a153 1
			nextdisk = nextdisk->d_entries.tqe_next;
d157 1
a157 1
			for (d = diskh.tqh_first; d; d = d->d_entries.tqe_next)
d172 1
a172 1
			p = d->d_part.tqh_first;
d200 1
a200 1
			if (d->d_part.tqh_first == NULL)
d204 1
a204 1
				if (d->d_part.tqh_first) {
d210 2
a211 1
					nextdisk = nextdisk->d_entries.tqe_next;
d213 3
a215 3
						nextdisk = diskh.tqh_first;
					if (nextdisk->d_part.tqh_first != NULL
					    && nextdisk->d_pid == 0)
d224 1
a224 1
		p = badh.tqh_first;
d230 1
a230 1
			p->p_entries.tqe_next ? "S" : "",
d233 1
a233 1
		for (; p; p = p->p_entries.tqe_next)
d236 1
a236 1
			    p->p_mntpt, p->p_entries.tqe_next ? ", " : "\n");
d261 1
a261 1
	for (d = diskh.tqh_first; d != NULL; d = d->d_entries.tqe_next)
d284 1
a284 1
	for (d = diskh.tqh_first; d != NULL; d = d->d_entries.tqe_next) {
d286 1
a286 2
		for (p = d->d_part.tqh_first; p != NULL;
		    p = p->p_entries.tqe_next)
d299 1
a299 1
	for (p = d->d_part.tqh_first; p != NULL; p = p->p_entries.tqe_next)
d319 1
a319 1
	struct partentry *p = d->d_part.tqh_first;
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.12 2002/07/03 22:32:32 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$NetBSD: preen.c,v 1.15 1996/09/28 19:21:42 christos Exp $";
@


1.12
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.11 2002/06/09 08:13:05 todd Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.10 2002/05/26 09:24:35 deraadt Exp $	*/
d88 2
a89 5
checkfstab(flags, maxrun, docheck, checkit)
	int flags, maxrun;
	void *(*docheck)(struct fstab *);
	int (*checkit)(const char *, const char *, const char *, void *,
	    pid_t *);
d249 1
a249 2
finddisk(name)
	const char *name;
d282 1
a282 1
printpart()
d298 1
a298 3
addpart(type, devname, mntpt, auxarg)
	const char *type, *devname, *mntpt;
	void *auxarg;
d320 2
a321 4
startdisk(d, checkit)
	struct diskentry *d;
	int (*checkit)(const char *, const char *, const char *, void *,
	    pid_t *);
@


1.10
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.9 2002/03/14 06:51:41 mpech Exp $	*/
d83 1
a83 1
static int startdisk(struct diskentry *, 
@


1.9
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.8 2002/02/17 19:42:27 millert Exp $	*/
d97 1
a97 1
	int ret, pid, retcode, passno, sumstatus, status;
d100 1
d169 1
a169 1
				warnx("Unknown pid %d", pid);
@


1.8
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.7 2002/02/16 21:27:34 millert Exp $	*/
d108 1
a108 1
			warnx("Can't open checklist file: %s\n", _PATH_FSTAB);
d168 1
a168 1
				warnx("Unknown pid %d\n", pid);
d310 1
a310 1
			warnx("%s in fstab more than once!\n", devname);
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.6 2001/11/05 07:39:16 mpech Exp $	*/
d83 2
a84 2
static int startdisk __P((struct diskentry *, 
    int (*)(const char *, const char *, const char *, void *, pid_t *)));
d91 2
a92 2
	int (*checkit) __P((const char *, const char *, const char *, void *,
	    pid_t *));
d327 2
a328 2
	int (*checkit) __P((const char *, const char *, const char *, void *,
	    pid_t *));
@


1.6
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.5 1999/01/11 20:59:29 niklas Exp $	*/
d81 2
a82 2
static struct diskentry *finddisk __P((const char *));
static void addpart __P((const char *, const char *, const char *, void *));
d85 1
a85 1
static void printpart __P((void));
d90 1
a90 1
	void *(*docheck) __P((struct fstab *));
@


1.5
log
@pids should be pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: preen.c,v 1.4 1997/09/14 10:37:42 deraadt Exp $	*/
d326 1
a326 1
	register struct diskentry *d;
d330 1
a330 1
	register struct partentry *p = d->d_part.tqh_first;
@


1.4
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
	int			    d_pid;	/* 0 or pid of fsck proc */
@


1.3
log
@Sync with NetBSD 961019
@
text
@d255 1
a255 1
	size_t len;
@


1.2
log
@sync to netbsd 960418
@
text
@d1 2
a2 1
/*	$NetBSD: preen.c,v 1.11 1995/03/18 14:55:59 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: preen.c,v 1.11 1995/03/18 14:55:59 cgd Exp $";
d48 2
d56 3
d60 26
a85 20
struct part {
	struct	part *next;		/* forward link of partitions on disk */
	char	*name;			/* device name */
	char	*fsname;		/* mounted filesystem name */
	long	auxdata;		/* auxillary data for application */
} *badlist, **badnext = &badlist;

struct disk {
	char	*name;			/* disk base name */
	struct	disk *next;		/* forward link for list of disks */
	struct	part *part;		/* head of list of partitions on disk */
	int	pid;			/* If != 0, pid of proc working on */
} *disks;

int	nrun, ndisks;
char	hotroot;

char	*rawname(), *unrawname(), *blockcheck();
void addpart __P((char *, char *, long));
int startdisk __P((struct disk *, int (*)() ));
d88 5
a92 3
checkfstab(preen, maxrun, docheck, chkit)
	int preen, maxrun;
	int (*docheck)(), (*chkit)();
d94 3
a96 3
	register struct fstab *fsp;
	register struct disk *dk, *nextdisk;
	register struct part *pt;
d98 1
a98 1
	long auxdata;
d101 3
d105 1
d108 1
a108 2
			fprintf(stderr, "Can't open checklist file: %s\n",
			    _PATH_FSTAB);
d111 2
a112 2
		while ((fsp = getfsent()) != 0) {
			if ((auxdata = (*docheck)(fsp)) == 0)
d114 22
a135 11
			if (preen == 0 || passno == 1 && fsp->fs_passno == 1) {
				if (name = blockcheck(fsp->fs_spec)) {
					if (sumstatus = (*chkit)(name,
					    fsp->fs_file, auxdata, 0))
						return (sumstatus);
				} else if (preen)
					return (8);
			} else if (passno == 2 && fsp->fs_passno > 1) {
				if ((name = blockcheck(fsp->fs_spec)) == NULL) {
					fprintf(stderr, "BAD DISK NAME %s\n",
						fsp->fs_spec);
d139 2
a140 1
				addpart(name, fsp->fs_file, auxdata);
d143 2
a144 2
		if (preen == 0)
			return (0);
d146 5
a150 1
	if (preen) {
d155 1
a155 1
		nextdisk = disks;
d157 3
a159 5
			while (ret = startdisk(nextdisk, chkit) && nrun > 0)
				sleep(10);
			if (ret)
				return (ret);
			nextdisk = nextdisk->next;
d161 1
d163 2
a164 2
			for (dk = disks; dk; dk = dk->next)
				if (dk->pid == pid)
d166 3
a168 2
			if (dk == 0) {
				printf("Unknown pid %d\n", pid);
d171 2
d177 8
d186 4
a189 3
				printf("%s (%s): EXITED WITH SIGNAL %d\n",
					dk->part->name, dk->part->fsname,
					WTERMSIG(status));
d192 3
d196 1
d198 6
a203 7
				*badnext = dk->part;
				badnext = &dk->part->next;
				dk->part = dk->part->next;
				*badnext = NULL;
			} else
				dk->part = dk->part->next;
			dk->pid = 0;
d205 2
a206 1
			if (dk->part == NULL)
d210 3
a212 6
				if (dk->part) {
					while (ret = startdisk(dk, chkit) &&
					    nrun > 0)
						sleep(10);
					if (ret)
						return (ret);
d216 5
a220 4
					if ((nextdisk = nextdisk->next) == NULL)
						nextdisk = disks;
					if (nextdisk->part != NULL &&
					    nextdisk->pid == 0)
d223 2
a224 5
				while (ret = startdisk(nextdisk, chkit) &&
				    nrun > 0)
					sleep(10);
				if (ret)
					return (ret);
d229 2
a230 1
		if (badlist == 0)
d232 12
a243 6
		fprintf(stderr, "THE FOLLOWING FILE SYSTEM%s HAD AN %s\n\t",
			badlist->next ? "S" : "", "UNEXPECTED INCONSISTENCY:");
		for (pt = badlist; pt; pt = pt->next)
			fprintf(stderr, "%s (%s)%s", pt->name, pt->fsname,
			    pt->next ? ", " : "\n");
		return (sumstatus);
d245 1
a245 1
	(void)endfsent();
d249 2
a250 1
struct disk *
d252 1
a252 1
	char *name;
d254 1
a254 2
	register struct disk *dk, **dkp;
	register char *p;
d256 1
d263 1
d267 11
a277 19
	for (dk = disks, dkp = &disks; dk; dkp = &dk->next, dk = dk->next) {
		if (strncmp(dk->name, name, len) == 0 &&
		    dk->name[len] == 0)
			return (dk);
	}
	if ((*dkp = (struct disk *)malloc(sizeof(struct disk))) == NULL) {
		fprintf(stderr, "out of memory");
		exit (8);
	}
	dk = *dkp;
	if ((dk->name = malloc(len + 1)) == NULL) {
		fprintf(stderr, "out of memory");
		exit (8);
	}
	(void)strncpy(dk->name, name, len);
	dk->name[len] = '\0';
	dk->part = NULL;
	dk->next = NULL;
	dk->pid = 0;
d279 2
a280 1
	return (dk);
d283 3
a285 4
void
addpart(name, fsname, auxdata)
	char *name, *fsname;
	long auxdata;
d287 2
a288 2
	struct disk *dk = finddisk(name);
	register struct part *pt, **ppt = &dk->part;
d290 6
a295 13
	for (pt = dk->part; pt; ppt = &pt->next, pt = pt->next)
		if (strcmp(pt->name, name) == 0) {
			printf("%s in fstab more than once!\n", name);
			return;
		}
	if ((*ppt = (struct part *)malloc(sizeof(struct part))) == NULL) {
		fprintf(stderr, "out of memory");
		exit (8);
	}
	pt = *ppt;
	if ((pt->name = malloc(strlen(name) + 1)) == NULL) {
		fprintf(stderr, "out of memory");
		exit (8);
a296 8
	(void)strcpy(pt->name, name);
	if ((pt->fsname = malloc(strlen(fsname) + 1)) == NULL) {
		fprintf(stderr, "out of memory");
		exit (8);
	}
	(void)strcpy(pt->fsname, fsname);
	pt->next = NULL;
	pt->auxdata = auxdata;
d299 5
a303 4
int
startdisk(dk, checkit)
	register struct disk *dk;
	int (*checkit)();
d305 14
a318 1
	register struct part *pt = dk->part;
d320 1
a320 9
	dk->pid = fork();
	if (dk->pid < 0) {
		perror("fork");
		return (8);
	}
	if (dk->pid == 0)
		exit((*checkit)(pt->name, pt->fsname, pt->auxdata, 1));
	nrun++;
	return (0);
a322 47
char *
blockcheck(origname)
	char *origname;
{
	struct stat stslash, stblock, stchar;
	char *newname, *raw;
	int retried = 0;

	hotroot = 0;
	if (stat("/", &stslash) < 0) {
		perror("/");
		printf("Can't stat root\n");
		return (origname);
	}
	newname = origname;
retry:
	if (stat(newname, &stblock) < 0) {
		perror(newname);
		printf("Can't stat %s\n", newname);
		return (origname);
	}
	if (S_ISBLK(stblock.st_mode)) {
		if (stslash.st_dev == stblock.st_rdev)
			hotroot++;
		raw = rawname(newname);
		if (stat(raw, &stchar) < 0) {
			perror(raw);
			printf("Can't stat %s\n", raw);
			return (origname);
		}
		if (S_ISCHR(stchar.st_mode)) {
			return (raw);
		} else {
			printf("%s is not a character device\n", raw);
			return (origname);
		}
	} else if (S_ISCHR(stblock.st_mode) && !retried) {
		newname = unrawname(newname);
		retried++;
		goto retry;
	}
	/*
	 * Not a block or character device, just return name and
	 * let the user decide whether to use it.
	 */
	return (origname);
}
d324 5
a328 3
char *
unrawname(name)
	char *name;
d330 2
a331 2
	char *dp;
	struct stat stb;
d333 3
a335 11
	if ((dp = strrchr(name, '/')) == 0)
		return (name);
	if (stat(name, &stb) < 0)
		return (name);
	if (!S_ISCHR(stb.st_mode))
		return (name);
	if (dp[1] != 'r')
		return (name);
	(void)strcpy(&dp[1], &dp[2]);
	return (name);
}
d337 2
a338 6
char *
rawname(name)
	char *name;
{
	static char rawbuf[32];
	char *dp;
d340 1
a340 8
	if ((dp = strrchr(name, '/')) == 0)
		return (0);
	*dp = 0;
	(void)strcpy(rawbuf, name);
	*dp = '/';
	(void)strcat(rawbuf, "/r");
	(void)strcat(rawbuf, &dp[1]);
	return (rawbuf);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
