head	1.38;
access;
symbols
	OPENBSD_6_2:1.38.0.10
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.8
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.28.0.16
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.12
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.10
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.6
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.18
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.38
date	2015.11.23.19.19.29;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	Cz19p5I1S6mVZIjV;

1.37
date	2015.05.29.15.57.36;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	VDx2WmQh1k2U00FL;

1.36
date	2015.05.29.15.53.46;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	KTyFcHd0ZMH4f0TX;

1.35
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	6b2lLILbgCR1fvia;

1.34
date	2015.03.20.01.53.05;	author millert;	state Exp;
branches;
next	1.33;
commitid	8wXOh16hq8cCiNNm;

1.33
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2014.10.17.06.33.35;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	A97n8jt5SyFdggPU;

1.31
date	2014.10.08.16.27.53;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	0zFRxN2apca4J66f;

1.30
date	2014.07.13.17.28.13;	author jmc;	state Exp;
branches;
next	1.29;
commitid	xqL8idhRkNlfc0xg;

1.29
date	2014.07.13.12.03.48;	author claudio;	state Exp;
branches;
next	1.28;
commitid	45ZRaAXs9PH26rxu;

1.28
date	2010.11.17.11.22.42;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.20.18.11.17;	author sobrado;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.20.18.08.57;	author sobrado;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.20.19.50.09;	author dhill;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.21.14.27.55;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.12.13.28.34;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.28.07.30.35;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.15.06.26.28;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.03.05.03.50;	author jaredy;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.28.21.17.22;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.13.15.59.13;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.25.04.16.41;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.29.20.26.23;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.26.08.01.54;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.17.13.15.21;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.03.22.32.32;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.17.19.42.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.07.18.26.11;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.28.00.47.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.23.07.44.59;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.04.10.25.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.04.09.40.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.04.01.31.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.10.20.08.36.24;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@/*	$OpenBSD: fsck.c,v 1.37 2015/05/29 15:57:36 deraadt Exp $	*/
/*	$NetBSD: fsck.c,v 1.7 1996/10/03 20:06:30 christos Exp $	*/

/*
 * Copyright (c) 1996 Christos Zoulas. All rights reserved.
 * Copyright (c) 1980, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * From: @@(#)mount.c	8.19 (Berkeley) 4/19/94
 * From: NetBSD: mount.c,v 1.24 1995/11/18 03:34:29 cgd Exp
 *
 */

#include <sys/types.h>
#include <sys/mount.h>
#include <sys/queue.h>
#include <sys/resource.h>
#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <fstab.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

#include "pathnames.h"
#include "fsutil.h"

static enum { IN_LIST, NOT_IN_LIST } which = NOT_IN_LIST;
static enum { NONET_FILTER, NET_FILTER } filter = NONET_FILTER;

TAILQ_HEAD(fstypelist, entry) opthead, selhead;

struct entry {
	char *type;
	char *options;
	TAILQ_ENTRY(entry) entries;
};

static int maxrun;
static char *options;
static int flags;

int main(int, char *[]);

static int checkfs(const char *, const char *, const char *, void *, pid_t *);
static int selected(const char *);
static void addoption(char *);
static const char *getoptions(const char *);
static void addentry(struct fstypelist *, const char *, const char *);
static void maketypelist(char *);
static char *catopt(char *, const char *, int);
static void mangle(char *, int *, const char ***, int *);
static void usage(void);
static void *isok(struct fstab *);
static int hasopt(const char *, const char *);


int
main(int argc, char *argv[])
{
	const char *errstr;
	struct fstab *fs;
	int i, rval = 0;
	char *vfstype = NULL;
	char *p, globopt[3];
	struct rlimit rl;

	/* Increase our data size to the max */
	if (getrlimit(RLIMIT_DATA, &rl) == 0) {
		if (geteuid() == 0)
			rl.rlim_cur = rl.rlim_max = RLIM_INFINITY;
		else
			rl.rlim_cur = rl.rlim_max;
		if (setrlimit(RLIMIT_DATA, &rl) < 0)
			warn("Can't set resource limit to max data size");
	} else
		warn("Can't get resource limit for data size");

	if (pledge("stdio rpath wpath disklabel proc exec", NULL) == -1)
		err(1, "pledge");

	globopt[0] = '-';
	globopt[2] = '\0';

	TAILQ_INIT(&selhead);
	TAILQ_INIT(&opthead);

	while ((i = getopt(argc, argv, "b:dfl:nNpT:t:vy")) != -1)
		switch (i) {
		case 'd':
			flags |= CHECK_DEBUG;
			break;

		case 'v':
			flags |= CHECK_VERBOSE;
			break;

		case 'p':
			flags |= CHECK_PREEN;
			/*FALLTHROUGH*/
		case 'n':
		case 'f':
		case 'y':
			globopt[1] = i;
			options = catopt(options, globopt, 1);
			break;

		case 'b':
			if (asprintf(&p, "-b %s", optarg) == -1)
				err(1, "malloc failed");
			options = catopt(options, p, 1);
			free(p);
			break;

		case 'l':
			maxrun = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-l %s: %s", optarg, errstr);

			break;

		case 'T':
			if (*optarg)
				addoption(optarg);
			break;

		case 't':
			if (!TAILQ_EMPTY(&selhead))
				errx(1, "only one -t option may be specified.");

			maketypelist(optarg);
			vfstype = optarg;
			break;

		case 'N':
			filter = NET_FILTER;
			break;

		case '?':
		default:
			usage();
			/* NOTREACHED */
		}

	argc -= optind;
	argv += optind;

	if (argc == 0)
		return checkfstab(flags, maxrun, isok, checkfs);

#define	BADTYPE(type)							\
	(strcmp(type, FSTAB_RO) &&					\
	    strcmp(type, FSTAB_RW) && strcmp(type, FSTAB_RQ))


	for (; argc--; argv++) {
		char *spec, *type;

		if ((strncmp(*argv, "/dev/", 5) == 0 || isduid(*argv, 0)) &&
		    (type = readlabelfs(*argv, 0))) {
			spec = *argv;
		} else if ((fs = getfsfile(*argv)) == NULL &&
		    (fs = getfsspec(*argv)) == NULL) {
			if (vfstype == NULL)
				errx(1,
				    "%s: unknown special file or file system.",
				    *argv);
			spec = *argv;
			type = vfstype;
		} else {
			spec = fs->fs_spec;
			type = fs->fs_vfstype;
			if (BADTYPE(fs->fs_type))
				errx(1, "%s has unknown file system type.",
				    *argv);
		}

		rval |= checkfs(type, blockcheck(spec), *argv, NULL, NULL);
	}

	return rval;
}


static void *
isok(struct fstab *fs)
{
	if (fs->fs_passno == 0)
		return NULL;

	if (BADTYPE(fs->fs_type))
		return NULL;

	switch (filter) {
	case NET_FILTER:
		if (!hasopt(fs->fs_mntops, "net"))
			return NULL;
		break;
	case NONET_FILTER:
		if (hasopt(fs->fs_mntops, "net"))
			return NULL;
		break;
	}
	if (!selected(fs->fs_vfstype))
		return NULL;

	return fs;
}


static int
checkfs(const char *vfstype, const char *spec, const char *mntpt, void *auxarg,
    pid_t *pidp)
{
	/* List of directories containing fsck_xxx subcommands. */
	static const char *edirs[] = {
		_PATH_SBIN,
		_PATH_USRSBIN,
		NULL
	};
	const char **argv, **edir;
	pid_t pid;
	int argc, i, status, maxargc;
	char *optbuf = NULL, fsname[PATH_MAX], execname[PATH_MAX];
	const char *extra = getoptions(vfstype);

	if (strcmp(vfstype, "ufs") == 0)
		vfstype = MOUNT_UFS;

	maxargc = 100;
	argv = ereallocarray(NULL, maxargc, sizeof(char *));

	argc = 0;
	(void)snprintf(fsname, sizeof(fsname), "fsck_%s", vfstype);
	argv[argc++] = fsname;

	if (options) {
		if (extra != NULL)
			optbuf = catopt(options, extra, 0);
		else
			optbuf = estrdup(options);
	}
	else if (extra)
		optbuf = estrdup(extra);

	if (optbuf)
		mangle(optbuf, &argc, &argv, &maxargc);

	argv[argc++] = spec;
	argv[argc] = NULL;

	if (flags & (CHECK_DEBUG|CHECK_VERBOSE)) {
		(void)printf("start %s %swait %s", mntpt,
			pidp ? "no" : "", fsname);
		for (i = 1; i < argc; i++)
			(void)printf(" %s", argv[i]);
		(void)printf("\n");
	}

	switch (pid = fork()) {
	case -1:				/* Error. */
		warn("fork");
		free(optbuf);
		free(argv);
		return (1);

	case 0:					/* Child. */
		if (flags & CHECK_DEBUG)
			_exit(0);

		/* Go find an executable. */
		edir = edirs;
		do {
			(void)snprintf(execname,
			    sizeof(execname), "%s/fsck_%s", *edir, vfstype);
			execv(execname, (char * const *)argv);
			if (errno != ENOENT) {
				if (spec)
					warn("exec %s for %s", execname, spec);
				else
					warn("exec %s", execname);
			}
		} while (*++edir != NULL);

		if (errno == ENOENT) {
			if (spec)
				warn("exec %s for %s", execname, spec);
			else
				warn("exec %s", execname);
		}
		exit(1);
		/* NOTREACHED */

	default:				/* Parent. */
		free(optbuf);
		free(argv);

		if (pidp) {
			*pidp = pid;
			return 0;
		}

		if (waitpid(pid, &status, 0) < 0) {
			warn("waitpid");
			return (1);
		}

		if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) != 0)
				return (WEXITSTATUS(status));
		}
		else if (WIFSIGNALED(status)) {
			warnx("%s: %s", spec, strsignal(WTERMSIG(status)));
			return (1);
		}
		break;
	}

	return (0);
}


static int
selected(const char *type)
{
	struct entry *e;

	/* If no type specified, it's always selected. */
	TAILQ_FOREACH(e, &selhead, entries)
		if (!strncmp(e->type, type, MFSNAMELEN))
			return which == IN_LIST ? 1 : 0;

	return which == IN_LIST ? 0 : 1;
}


static const char *
getoptions(const char *type)
{
	struct entry *e;

	TAILQ_FOREACH(e, &opthead, entries)
		if (!strncmp(e->type, type, MFSNAMELEN))
			return e->options;
	return "";
}


static void
addoption(char *optstr)
{
	char *newoptions;
	struct entry *e;

	if ((newoptions = strchr(optstr, ':')) == NULL)
		errx(1, "Invalid option string");

	*newoptions++ = '\0';

	TAILQ_FOREACH(e, &opthead, entries)
		if (!strncmp(e->type, optstr, MFSNAMELEN)) {
			e->options = catopt(e->options, newoptions, 1);
			return;
		}
	addentry(&opthead, optstr, newoptions);
}


static void
addentry(struct fstypelist *list, const char *type, const char *opts)
{
	struct entry *e;

	e = emalloc(sizeof(struct entry));
	e->type = estrdup(type);
	e->options = estrdup(opts);
	TAILQ_INSERT_TAIL(list, e, entries);
}


static void
maketypelist(char *fslist)
{
	char *ptr;

	if ((fslist == NULL) || (fslist[0] == '\0'))
		errx(1, "empty type list");

	if (fslist[0] == 'n' && fslist[1] == 'o') {
		fslist += 2;
		which = NOT_IN_LIST;
	}
	else
		which = IN_LIST;

	while ((ptr = strsep(&fslist, ",")) != NULL)
		addentry(&selhead, ptr, "");

}


static char *
catopt(char *s0, const char *s1, int fr)
{
	char *cp;

	if (s0 && *s0) {
		if (asprintf(&cp, "%s,%s", s0, s1) == -1)
			err(1, "malloc failed");
	} else
		cp = estrdup(s1);

	if (fr)
		free(s0);
	return (cp);
}


static void
mangle(char *opts, int *argcp, const char ***argvp, int *maxargcp)
{
	char *p, *s;
	int argc = *argcp, maxargc = *maxargcp;
	const char **argv = *argvp;

	for (s = opts; (p = strsep(&s, ",")) != NULL;) {
		/* always leave space for one more argument and the NULL */
		if (argc >= maxargc - 3) {
			int newmaxargc = maxargc + 50;

			argv = ereallocarray(argv, newmaxargc, sizeof(char *));
			maxargc = newmaxargc;
		}
		if (*p != '\0') {
			if (*p == '-') {
				argv[argc++] = p;
				p = strchr(p, '=');
				if (p) {
					*p = '\0';
					argv[argc++] = p+1;
				}
			}
			else {
				argv[argc++] = "-o";
				argv[argc++] = p;
			}
		}
	}

	*argcp = argc;
	*argvp = argv;
	*maxargcp = maxargc;
}

static int
hasopt(const char *mntopts, const char *option)
{
	int found;
	char *opt, *optbuf;

	if (mntopts == NULL)
		return (0);
	optbuf = strdup(mntopts);
	found = 0;
	for (opt = optbuf; !found && opt != NULL; strsep(&opt, ","))
		found = !strncmp(opt, option, strlen(option));
	free(optbuf);
	return (found);
}


static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s "
	    "[-dfNnpvy] [-b block#] [-l maxparallel] [-T fstype:fsoptions]\n"
	    "            [-t fstype] [special | node ...]\n", __progname);
	exit(1);
}
@


1.37
log
@do not need non-NULL-check before free(p), other minor refactoring
from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.36 2015/05/29 15:53:46 deraadt Exp $	*/
d108 3
@


1.36
log
@remove duplicate assignments; from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.35 2015/04/18 18:28:37 deraadt Exp $	*/
d290 1
a290 2
		if (optbuf)
			free(optbuf);
d322 1
a322 2
		if (optbuf)
			free(optbuf);
d440 1
a440 1
	if (s0 && fr)
@


1.35
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.34 2015/03/20 01:53:05 millert Exp $	*/
a453 3

	argc = *argcp;
	maxargc = *maxargcp;
@


1.34
log
@Fix cut & pasto in warning message; from Andre Smagin
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.33 2015/01/16 06:39:57 deraadt Exp $	*/
d91 1
d143 4
a146 1
			maxrun = atoi(optarg);
@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.32 2014/10/17 06:33:35 deraadt Exp $	*/
d104 1
a104 1
			warn("Can't get resource limit to max data size");
@


1.32
log
@trivial replacement with reallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.31 2014/10/08 16:27:53 deraadt Exp $	*/
d38 1
a38 1
#include <sys/param.h>
d52 1
d247 1
a247 1
	char *optbuf = NULL, fsname[MAXPATHLEN], execname[MAXPATHLEN];
@


1.31
log
@replace internal erealloc() with ereallocarray(), and then use it to
spot mult int overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.30 2014/07/13 17:28:13 jmc Exp $	*/
d253 1
a253 1
	argv = emalloc(sizeof(char *) * maxargc);
@


1.30
log
@-N for SYNOPSIS and usage(), and some small changes to previous;
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.29 2014/07/13 12:03:48 claudio Exp $	*/
d458 1
a458 1
			argv = erealloc(argv, newmaxargc * sizeof(char *));
@


1.29
log
@Intorduce the same -N flag that mount(8) just got to do the same
selection of file systems with option 'net'. Again this will be used
by the rc script to fsck iscsi file systems before mounting them.
Again by default file systems with the net option are ignored when
scanning fstab.
"Get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.28 2010/11/17 11:22:42 jsing Exp $	*/
d505 1
a505 1
	    "[-dfnpvy] [-b block#] [-l maxparallel] [-T fstype:fsoptions]\n"
@


1.28
log
@Try to determine file system type using readlabelfs(3) if fsck is given
a disklabel UID.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.26 2007/10/20 18:11:17 sobrado Exp $	*/
d58 1
d68 3
a70 3
static int maxrun = 0;
static char *options = NULL;
static int flags = 0;
d84 1
d113 1
a113 1
	while ((i = getopt(argc, argv, "dvpfnyb:l:T:t:")) != -1)
d157 4
d216 10
d480 16
@


1.27
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d175 1
a175 1
		if (strncmp(*argv, "/dev/", 5) == 0 &&
@


1.26
log
@add missing [-b block#] to the usage of fsck(8)

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.24 2006/03/20 19:50:09 dhill Exp $	*/
a36 2

static const char rcsid[] = "$OpenBSD: fsck.c,v 1.24 2006/03/20 19:50:09 dhill Exp $";
@


1.25
log
@an usage message should fit on a 80-column display

ok jmc@@
@
text
@d475 1
a475 1
	    "[-dfnpvy] [-l maxparallel] [-T fstype:fsoptions]\n"
@


1.24
log
@NetBSD Coverity CID 1745: Fix memory leak.

yes otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.23 2005/11/21 14:27:55 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.23 2005/11/21 14:27:55 millert Exp $";
d474 3
a476 3
	fprintf(stderr, "usage: %s [-dfnpvy] [-l maxparallel] "
	    "[-T fstype:fsoptions] [-t fstype] [special | node ...]\n",
	    __progname);
@


1.23
log
@Accept and pass through -b option for fsck_ffs and fsck_ext2fs
OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.22 2005/11/12 13:28:34 deraadt Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.22 2005/11/12 13:28:34 deraadt Exp $";
d273 1
d306 1
@


1.22
log
@use snprintf; ok cloder dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.21 2005/10/28 07:30:35 otto Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.21 2005/10/28 07:30:35 otto Exp $";
d93 1
a93 1
	char globopt[3];
d113 1
a113 1
	while ((i = getopt(argc, argv, "dvpfnyl:t:T:")) != -1)
d131 7
@


1.21
log
@Change some TAILQ_FIRST() == NULL tests into TAILQ_EMPTY(). The first
form is valid, but in these cases its more clear to say what you
mean. ok pat@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.20 2005/10/15 06:26:28 otto Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.20 2005/10/15 06:26:28 otto Exp $";
a405 1
	size_t i;
d409 3
a411 5
		i = strlen(s0) + strlen(s1) + 1 + 1;
		cp = emalloc(i);
		(void)snprintf(cp, i, "%s,%s", s0, s1);
	}
	else
@


1.20
log
@Use queue macros instead of directly accessing fields. ok miod@@ aaron@@
jaredy@@ patrick@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.19 2005/02/03 05:03:50 jaredy Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.19 2005/02/03 05:03:50 jaredy Exp $";
d143 1
a143 1
			if (TAILQ_FIRST(&selhead) != NULL)
@


1.19
log
@sync usage output
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.18 2004/07/28 21:17:22 jmc Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.18 2004/07/28 21:17:22 jmc Exp $";
d143 1
a143 1
			if (selhead.tqh_first != NULL)
d330 1
a330 1
	for (e = selhead.tqh_first; e != NULL; e = e->entries.tqe_next)
d343 1
a343 1
	for (e = opthead.tqh_first; e != NULL; e = e->entries.tqe_next)
d361 1
a361 1
	for (e = opthead.tqh_first; e != NULL; e = e->entries.tqe_next)
@


1.18
log
@- sort options
- sync usage()
- use -keeps for SYNOPSIS
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.17 2004/01/13 15:59:13 otto Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.17 2004/01/13 15:59:13 otto Exp $";
a466 2
	static const char common[] =
	    "[-dfnpvy] [-l maxparallel] [-T fstype:fsoptions] [-t fstype]";
d468 3
a470 2
	(void)fprintf(stderr, "Usage: %s %s special | node ...\n",
	    __progname, common);
@


1.17
log
@Use = for assignment, not ==
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.16 2003/09/25 04:16:41 deraadt Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.16 2003/09/25 04:16:41 deraadt Exp $";
d468 1
a468 1
	    "[-dvpfny] [-l maxparallel] [-t fstype] [-T fstype:fsoptions]";
@


1.16
log
@do not crank size before erealloc
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.15 2003/07/29 20:26:23 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.15 2003/07/29 20:26:23 millert Exp $";
d439 1
a439 1
			maxargc == newmaxargc;
@


1.15
log
@If euid == 0 make datasize unlimited instead of cranking to the max
value returned by getrlimit().  Avoid resource limit issues when
fscking very large filesystems.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.14 2003/06/26 08:01:54 tedu Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: fsck.c,v 1.14 2003/06/26 08:01:54 tedu Exp $";
d436 4
a439 2
			maxargc += 50;
			argv = erealloc(argv, maxargc * sizeof(char *));
@


1.14
log
@const the rcsid, and make it say OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.13 2003/06/02 20:06:14 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD$";
d98 4
a101 1
		rl.rlim_cur = rl.rlim_max;
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.12 2002/10/17 13:15:21 brad Exp $	*/
d38 1
a38 1
static char rcsid[] = "$NetBSD: fsck.c,v 1.7 1996/10/03 20:06:30 christos Exp $";
@


1.12
log
@sync usage().
--
Ok'd by: deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.11 2002/07/03 22:32:32 deraadt Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.10 2002/06/09 08:13:05 todd Exp $	*/
d467 1
a467 1
	    "[-dpvlyn] [-T fstype:fsoptions] [-t fstype]";
d469 1
a469 1
	(void)fprintf(stderr, "Usage: %s %s [special|node]...\n",
@


1.10
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.9 2002/02/17 19:42:27 millert Exp $	*/
d92 1
a92 3
main(argc, argv)
	int argc;
	char *argv[];
d198 1
a198 2
isok(fs)
	struct fstab *fs;
d214 2
a215 4
checkfs(vfstype, spec, mntpt, auxarg, pidp)
	const char *vfstype, *spec, *mntpt;
	void *auxarg;
	pid_t *pidp;
d326 1
a326 2
selected(type)
	const char *type;
d340 1
a340 2
getoptions(type)
	const char *type;
d352 1
a352 2
addoption(optstr)
	char *optstr;
d372 1
a372 4
addentry(list, type, opts)
	struct fstypelist *list;
	const char *type;
	const char *opts;
d384 1
a384 2
maketypelist(fslist)
	char *fslist;
d405 1
a405 4
catopt(s0, s1, fr)
	char *s0;
	const char *s1;
	int fr;
d425 1
a425 5
mangle(opts, argcp, argvp, maxargcp)
	char *opts;
	int *argcp;
	const char ***argvp;
	int *maxargcp;
d463 1
a463 1
usage()
@


1.9
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.8 2002/02/16 21:27:34 millert Exp $	*/
d38 1
a38 1
 * From: NetBSD: mount.c,v 1.24 1995/11/18 03:34:29 cgd Exp 
d260 1
a260 1
		(void)printf("start %s %swait %s", mntpt, 
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.7 2001/07/07 18:26:11 deraadt Exp $	*/
d79 1
a79 2
static int checkfs __P((const char *, const char *, const char *, void *,
    pid_t *));
@


1.7
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.6 1997/02/28 00:47:44 millert Exp $	*/
d77 1
a77 1
int main __P((int, char *[]));
d81 9
a89 9
static int selected __P((const char *));
static void addoption __P((char *));
static const char *getoptions __P((const char *));
static void addentry __P((struct fstypelist *, const char *, const char *));
static void maketypelist __P((char *));
static char *catopt __P((char *, const char *, int));
static void mangle __P((char *, int *, const char ***, int *));
static void usage __P((void));
static void *isok __P((struct fstab *));
@


1.6
log
@Set data size resource limit to its max value so fsck will work
on large disks (and ccd's).
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.5 1996/12/23 07:44:59 downsj Exp $	*/
d285 1
a285 1
			if (errno != ENOENT)
d290 1
d293 1
a293 1
		if (errno == ENOENT)
d298 1
d460 1
a460 1
		if (*p != '\0')
d473 1
@


1.5
log
@readlabelfs()
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.4 1996/12/04 10:25:57 deraadt Exp $	*/
d47 1
d101 9
@


1.4
log
@vfork bye bye
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.3 1996/12/04 09:40:41 deraadt Exp $	*/
d165 1
a165 1
		    (type = readlabelfs(*argv))) {
@


1.3
log
@nice argv[0], please do not bite me
@
text
@d1 1
a1 1
/*	$OpenBSD: fsck.c,v 1.2 1996/12/04 01:31:11 deraadt Exp $	*/
d260 1
a260 1
		warn("vfork");
@


1.2
log
@use readlabelfs() if possible
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d222 1
a222 1
	char *optbuf = NULL, execname[MAXPATHLEN + 1];
a224 5
#ifdef __GNUC__
	/* Avoid vfork clobbering */
	(void) &optbuf;
#endif

d232 2
a233 1
	argv[argc++] = vfstype;
d251 2
a252 2
		(void)printf("start %s %swait fsck_%s", mntpt, 
			pidp ? "no" : "", vfstype);
d258 1
a258 1
	switch (pid = vfork()) {
@


1.1
log
@Sync with NetBSD 961019
@
text
@d57 1
d164 4
a167 1
		if ((fs = getfsfile(*argv)) == NULL &&
d175 1
a175 2
		}
		else {
@
