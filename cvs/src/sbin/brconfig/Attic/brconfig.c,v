head	1.44;
access;
symbols
	OPENBSD_4_6:1.42.0.14
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.10
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.8
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.6
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.4
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.44
date	2009.11.22.23.33.22;	author deraadt;	state dead;
branches;
next	1.43;

1.43
date	2009.11.05.20.30.55;	author todd;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.01.20.11.17;	author jmc;	state Exp;
branches;
next	1.41;

1.41
date	2006.12.31.10.44.52;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2006.12.30.18.43.41;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2006.12.11.22.11.48;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.03.13.41.19;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.25.00.26.42;	author djm;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.24.08.02.43;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.20.20.01.34;	author dhill;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.21.01.40.23;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.14.22.13.03;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.27.07.41.58;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.23.06.47.49;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.08.17.23.33;	author mcbride;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.02.21.01.00;	author tdeval;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.01.00.02.06;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.26.03.29.59;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.25.09.44.55;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.18.44.35;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.30.21.16.50;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.18.16.10.27;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.09.23.57.31;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.09.12.34.08;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.09.10.11.53;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.03.22.32.32;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.01.21.43.21;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.15.09.03.23;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.15.08.40.56;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.05.09.57.20;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.27.20.51.21;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.12.15.45.18;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.12.03.41.22;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.10.04.42.13;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.03.17.21.26;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.30.16.00.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.04.06.32.04;	author deraadt;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.01.25.22.06.27;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.10.22.14.25;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.12.03.03.38.23;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.09.03.12.47.12;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.09.01.03.28.01;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2000.10.06.20.40.26;	author jason;	state Exp;
branches;
next	;


desc
@@


1.44
log
@brconfig(8) functionality is now in ifconfig(8)
@
text
@/*	$OpenBSD: brconfig.c,v 1.43 2009/11/05 20:30:55 todd Exp $	*/

/*
 * Copyright (c) 1999, 2000 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/stdint.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/if_bridge.h>
#include <string.h>
#include <err.h>
#include <errno.h>
#include <getopt.h>
#include <sysexits.h>
#include <limits.h>

void usage(void);
int bridge_setflag(int, char *, short);
int bridge_clrflag(int, char *, short);
int bridge_ifsetflag(int, char *, char *, u_int32_t);
int bridge_ifclrflag(int, char *, char *, u_int32_t);
int bridge_list(int, char *, char *);
int bridge_cfg(int, char *, char *);
int bridge_addrs(int, char *, char *);
int bridge_addaddr(int, char *, char *, char *);
int bridge_deladdr(int, char *, char *);
int bridge_maxaddr(int, char *, char *);
int bridge_maxage(int, char *, char *);
int bridge_priority(int, char *, char *);
int bridge_proto(int, char *, char *);
int bridge_fwddelay(int, char *, char *);
int bridge_hellotime(int, char *, char *);
int bridge_ifprio(int, char *, char *, char *);
int bridge_ifcost(int, char *, char *, char *);
int bridge_timeout(int, char *, char *);
int bridge_flush(int, char *);
int bridge_flushall(int, char *);
int bridge_add(int, char *, char *);
int bridge_delete(int, char *, char *);
int bridge_addspan(int, char *, char *);
int bridge_delspan(int, char *, char *);
int bridge_holdcnt(int, char *, char *);
int bridge_status(int, char *);
int is_bridge(int, char *);
int bridge_show_all(int);
void printb(char *, unsigned short, char *);
int bridge_rule(int, char *, int, char **, int);
int bridge_rules(int, char *, char *, char *);
int bridge_flushrule(int, char *, char *);
void bridge_badrule(int, char **, int);
void bridge_showrule(struct ifbrlreq *, char *);
int bridge_rulefile(int, char *, char *);

int aflag = 0;
int Aflag = 0;

/* if_flags bits: borrowed from ifconfig.c */
#define	IFFBITS \
"\020\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5POINTOPOINT\6NOTRAILERS\7RUNNING\10NOARP\
\11PROMISC\12ALLMULTI\13OACTIVE\14SIMPLEX\15LINK0\16LINK1\17LINK2\20MULTICAST"

#define	IFBAFBITS	"\020\1STATIC"
#define	IFBIFBITS	\
"\020\1LEARNING\2DISCOVER\3BLOCKNONIP\4STP\5EDGE\6AUTOEDGE\7PTP\10AUTOPTP\11SPAN"

#define	PV2ID(pv, epri, eaddr)	do {					\
	epri	 = pv >> 48;						\
	eaddr[0] = pv >> 40;						\
	eaddr[1] = pv >> 32;						\
	eaddr[2] = pv >> 24;						\
	eaddr[3] = pv >> 16;						\
	eaddr[4] = pv >> 8;						\
	eaddr[5] = pv >> 0;						\
} while (0)

char *stpstates[] = {
	"disabled",
	"listening",
	"learning",
	"forwarding",
	"blocking",
	"discarding"
};
char *stpproto[] = {
	"stp",
	"(none)",
	"rstp",
};
char *stproles[] = {
	"disabled",
	"root",
	"designated",
	"alternate",
	"backup"
};

void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-Aa] [interface] [parameters]\n",
	    __progname);
	fprintf(stderr,
	    "       %s interface rule { block | pass } "
	    "{ in | out | in/out } on\n"
	    "\t\tinterface [src address] [dst address] [tag tagname]\n",
	    __progname);
}

int
main(int argc, char *argv[])
{
	int error = 0, ch, sock;
	char *brdg;

	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock < 0)
		err(1, "socket");

	while ((ch = getopt(argc, argv, "Aah")) != -1) {
		switch (ch) {
		case 'A':
			Aflag = 1;
			break;
		case 'a':
			aflag = 1;
			break;
		case 'h':
		default:
			usage();
			return (EX_USAGE);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc < 1)
		aflag = 1;
	if (aflag || Aflag)
		return bridge_show_all(sock);

	brdg = argv[0];

	if (strlen(brdg) >= IFNAMSIZ) {
		warnx("%s is not a bridge", brdg);
		return (EX_USAGE);
	}

	if (!is_bridge(sock, brdg)) {
		if (errno == ENXIO)
			warn("%s", brdg);
		else
			warnx("%s is not a bridge", brdg);
		return (EX_USAGE);
	}

	if (argc == 1) {
		error = bridge_status(sock, brdg);
		return (error);
	}

	for (argc--, argv++; argc != 0; argc--, argv++) {
		if (strcmp("add", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("add requires an argument");
				return (EX_USAGE);
			}
			error = bridge_add(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("delete", argv[0]) == 0 ||
		    strcmp("del", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("delete requires an argument");
				return (EX_USAGE);
			}
			error = bridge_delete(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("addspan", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("addspan requires an argument");
				return (EX_USAGE);
			}
			error = bridge_addspan(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("delspan", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("delspan requires an argument");
				return (EX_USAGE);
			}
			error = bridge_delspan(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("up", argv[0]) == 0) {
			error = bridge_setflag(sock, brdg, IFF_UP);
			if (error)
				return (error);
		} else if (strcmp("down", argv[0]) == 0) {
			error = bridge_clrflag(sock, brdg, IFF_UP);
			if (error)
				return (error);
		} else if (strcmp("discover", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("discover requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifsetflag(sock, brdg, argv[0],
			    IFBIF_DISCOVER);
			if (error)
				return (error);
		} else if (strcmp("-discover", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("-discover requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifclrflag(sock, brdg, argv[0],
			    IFBIF_DISCOVER);
			if (error)
				return (error);
		} else if (strcmp("blocknonip", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("blocknonip requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifsetflag(sock, brdg, argv[0],
			    IFBIF_BLOCKNONIP);
			if (error)
				return (error);
		} else if (strcmp("-blocknonip", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("-blocknonip requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifclrflag(sock, brdg, argv[0],
			    IFBIF_BLOCKNONIP);
			if (error)
				return (error);
		} else if (strcmp("learn", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("learn requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifsetflag(sock, brdg, argv[0],
			    IFBIF_LEARNING);
			if (error)
				return (error);
		} else if (strcmp("-learn", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("-learn requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifclrflag(sock, brdg, argv[0],
			    IFBIF_LEARNING);
			if (error)
				return (error);
		} else if (strcmp("flush", argv[0]) == 0) {
			error = bridge_flush(sock, brdg);
			if (error)
				return (error);
		} else if (strcmp("flushall", argv[0]) == 0) {
			error = bridge_flushall(sock, brdg);
			if (error)
				return (error);
		} else if (strcmp("static", argv[0]) == 0) {
			argc--; argv++;
			if (argc < 2) {
				warnx("static requires 2 arguments");
				return (EX_USAGE);
			}
			error = bridge_addaddr(sock, brdg, argv[0], argv[1]);
			if (error)
				return (error);
			argc--; argv++;
		} else if (strcmp("deladdr", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("deladdr requires an argument");
				return (EX_USAGE);
			}
			error = bridge_deladdr(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("link0", argv[0]) == 0) {
			error = bridge_setflag(sock, brdg, IFF_LINK0);
			if (error)
				return (error);
		} else if (strcmp("-link0", argv[0]) == 0) {
			error = bridge_clrflag(sock, brdg, IFF_LINK0);
			if (error)
				return (error);
		} else if (strcmp("link1", argv[0]) == 0) {
			error = bridge_setflag(sock, brdg, IFF_LINK1);
			if (error)
				return (error);
		} else if (strcmp("-link1", argv[0]) == 0) {
			error = bridge_clrflag(sock, brdg, IFF_LINK1);
			if (error)
				return (error);
		} else if (strcmp("link2", argv[0]) == 0) {
			error = bridge_setflag(sock, brdg, IFF_LINK2);
			if (error)
				return (error);
		} else if (strcmp("-link2", argv[0]) == 0) {
			error = bridge_clrflag(sock, brdg, IFF_LINK2);
			if (error)
				return (error);
		} else if (strcmp("addr", argv[0]) == 0) {
			error = bridge_addrs(sock, brdg, "");
			if (error)
				return (error);
		} else if (strcmp("maxaddr", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("maxaddr requires an argument");
				return (EX_USAGE);
			}
			error = bridge_maxaddr(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("hellotime", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("hellotime requires an argument");
				return (EX_USAGE);
			}
			error = bridge_hellotime(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("fwddelay", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("fwddelay requires an argument");
				return (EX_USAGE);
			}
			error = bridge_fwddelay(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("maxage", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("maxage requires an argument");
				return (EX_USAGE);
			}
			error = bridge_maxage(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("priority", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("priority requires an argument");
				return (EX_USAGE);
			}
			error = bridge_priority(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("proto", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("proto requires an argument");
				return (EX_USAGE);
			}
			error = bridge_proto(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("ifpriority", argv[0]) == 0) {
			argc--; argv++;
			if (argc < 2) {
				warnx("ifpriority requires 2 arguments");
				return (EX_USAGE);
			}
			error = bridge_ifprio(sock, brdg, argv[0], argv[1]);
			if (error)
				return (error);
			argc--; argv++;
		} else if (strcmp("ifcost", argv[0]) == 0) {
			argc--; argv++;
			if (argc < 2) {
				warnx("ifcost requires 2 arguments");
				return (EX_USAGE);
			}
			error = bridge_ifcost(sock, brdg, argv[0], argv[1]);
			if (error)
				return (error);
			argc--; argv++;
		} else if (strcmp("-ifcost", argv[0]) == 0) {
			argc--; argv++;
			if (argc < 1) {
				warnx("-ifcost requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifcost(sock, brdg, argv[0], NULL);
			if (error)
				return (error);
		} else if (strcmp("rules", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("rules requires an argument");
				return (EX_USAGE);
			}
			error = bridge_rules(sock, brdg, argv[0], NULL);
			if (error)
				return (error);
		} else if (strcmp("rule", argv[0]) == 0) {
			argc--; argv++;
			return (bridge_rule(sock, brdg, argc, argv, -1));
		} else if (strcmp("rulefile", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("rulefile requires an argument");
				return (EX_USAGE);
			}
			error = bridge_rulefile(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("flushrule", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("flushrule requires an argument");
				return (EX_USAGE);
			}
			error = bridge_flushrule(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("timeout", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("timeout requires an argument");
				return (EX_USAGE);
			}
			error = bridge_timeout(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else if (strcmp("stp", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("stp requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifsetflag(sock, brdg, argv[0],
			    IFBIF_STP);
			if (error)
				return (error);
		} else if (strcmp("-stp", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("-stp requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifclrflag(sock, brdg, argv[0],
			    IFBIF_STP);
			if (error)
				return (error);
		} else if (strcmp("edge", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("edge requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifsetflag(sock, brdg, argv[0],
			    IFBIF_BSTP_EDGE);
			if (error)
				return (error);
		} else if (strcmp("-edge", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("-edge requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifclrflag(sock, brdg, argv[0],
			    IFBIF_BSTP_EDGE);
			if (error)
				return (error);
		} else if (strcmp("autoedge", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("autoedge requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifsetflag(sock, brdg, argv[0],
			    IFBIF_BSTP_AUTOEDGE);
			if (error)
				return (error);
		} else if (strcmp("-autoedge", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("-autoedge requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifclrflag(sock, brdg, argv[0],
			    IFBIF_BSTP_AUTOEDGE);
			if (error)
				return (error);
		} else if (strcmp("ptp", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("ptp requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifsetflag(sock, brdg, argv[0],
			    IFBIF_BSTP_PTP);
			if (error)
				return (error);
		} else if (strcmp("-ptp", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("-ptp requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifclrflag(sock, brdg, argv[0],
			    IFBIF_BSTP_PTP);
			if (error)
				return (error);
		} else if (strcmp("autoptp", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("autoptp requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifsetflag(sock, brdg, argv[0],
			    IFBIF_BSTP_AUTOPTP);
			if (error)
				return (error);
		} else if (strcmp("-autoptp", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("-autoptp requires an argument");
				return (EX_USAGE);
			}
			error = bridge_ifclrflag(sock, brdg, argv[0],
			    IFBIF_BSTP_PTP);
			if (error)
				return (error);
		} else if (strcmp("holdcnt", argv[0]) == 0) {
			argc--; argv++;
			if (argc == 0) {
				warnx("holdcnt requires an argument");
				return (EX_USAGE);
			}
			error = bridge_holdcnt(sock, brdg, argv[0]);
			if (error)
				return (error);
		} else {
			warnx("unrecognized option: %s", argv[0]);
			return (EX_USAGE);
		}
	}

	return (0);
}

int
bridge_ifsetflag(int s, char *brdg, char *ifsname, u_int32_t flag)
{
	struct ifbreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	strlcpy(req.ifbr_ifsname, ifsname, sizeof(req.ifbr_ifsname));
	if (ioctl(s, SIOCBRDGGIFFLGS, (caddr_t)&req) < 0) {
		warn("%s: %s", brdg, ifsname);
		return (EX_IOERR);
	}

	req.ifbr_ifsflags |= flag & ~IFBIF_RO_MASK;

	if (ioctl(s, SIOCBRDGSIFFLGS, (caddr_t)&req) < 0) {
		warn("%s: %s", brdg, ifsname);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_ifclrflag(int s, char *brdg, char *ifsname, u_int32_t flag)
{
	struct ifbreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	strlcpy(req.ifbr_ifsname, ifsname, sizeof(req.ifbr_ifsname));

	if (ioctl(s, SIOCBRDGGIFFLGS, (caddr_t)&req) < 0) {
		warn("%s: %s", brdg, ifsname);
		return (EX_IOERR);
	}

	req.ifbr_ifsflags &= ~(flag | IFBIF_RO_MASK);

	if (ioctl(s, SIOCBRDGSIFFLGS, (caddr_t)&req) < 0) {
		warn("%s: %s", brdg, ifsname);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_show_all(int s)
{
	char *inbuf = NULL, *inb;
	struct ifconf ifc;
	struct ifreq *ifrp, ifreq;
	int len = 8192, i;

	while (1) {
		ifc.ifc_len = len;
		inb = realloc(inbuf, len);
		if (inb == NULL)
			err(1, "malloc");
		ifc.ifc_buf = inbuf = inb;
		if (ioctl(s, SIOCGIFCONF, &ifc) < 0)
			err(1, "ioctl(SIOCGIFCONF)");
		if (ifc.ifc_len + sizeof(struct ifreq) < len)
			break;
		len *= 2;
	}
	ifrp = ifc.ifc_req;
	ifreq.ifr_name[0] = '\0';
	for (i = 0; i < ifc.ifc_len; ) {
		ifrp = (struct ifreq *)((caddr_t)ifc.ifc_req + i);
		i += sizeof(ifrp->ifr_name) +
		    (ifrp->ifr_addr.sa_len > sizeof(struct sockaddr) ?
		    ifrp->ifr_addr.sa_len : sizeof(struct sockaddr));
		if (ifrp->ifr_addr.sa_family != AF_LINK)
			continue;
		if (!is_bridge(s, ifrp->ifr_name))
			continue;
		bridge_status(s, ifrp->ifr_name);
	}
	free(inbuf);
	return (0);
}

int
bridge_setflag(int s, char *brdg, short f)
{
	struct ifreq ifr;

	strlcpy(ifr.ifr_name, brdg, sizeof(ifr.ifr_name));

	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0) {
		warn("%s", brdg);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}

	ifr.ifr_flags |= f;

	if (ioctl(s, SIOCSIFFLAGS, (caddr_t)&ifr) < 0) {
		warn("%s", brdg);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}

	return (0);
}

int
bridge_clrflag(int s, char *brdg, short f)
{
	struct ifreq ifr;

	strlcpy(ifr.ifr_name, brdg, sizeof(ifr.ifr_name));

	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0) {
		warn("%s", brdg);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}

	ifr.ifr_flags &= ~(f);

	if (ioctl(s, SIOCSIFFLAGS, (caddr_t)&ifr) < 0) {
		warn("%s", brdg);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}

	return (0);
}

int
bridge_flushall(int s, char *brdg)
{
	struct ifbreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	req.ifbr_ifsflags = IFBF_FLUSHALL;
	if (ioctl(s, SIOCBRDGFLUSH, &req) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_flush(int s, char *brdg)
{
	struct ifbreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	req.ifbr_ifsflags = IFBF_FLUSHDYN;
	if (ioctl(s, SIOCBRDGFLUSH, &req) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_cfg(int s, char *brdg, char *delim)
{
	struct ifbropreq ifbp;
	u_int16_t pri;
	u_int8_t ht, fd, ma, hc, proto;
	u_int8_t lladdr[ETHER_ADDR_LEN];
	u_int16_t bprio;

	strlcpy(ifbp.ifbop_name, brdg, sizeof(ifbp.ifbop_name));
	if (ioctl(s, SIOCBRDGGPARAM, (caddr_t)&ifbp)) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	printf("%s", delim);
	pri = ifbp.ifbop_priority;
	ht = ifbp.ifbop_hellotime;
	fd = ifbp.ifbop_fwddelay;
	ma = ifbp.ifbop_maxage;
	hc = ifbp.ifbop_holdcount;
	proto = ifbp.ifbop_protocol;

	printf("priority %u hellotime %u fwddelay %u maxage %u "
	    "holdcnt %u proto %s\n", pri, ht, fd, ma, hc, stpproto[proto]);

	if (aflag && !Aflag)
		return (0);

	PV2ID(ifbp.ifbop_desg_bridge, bprio, lladdr);
	printf("\tdesignated: id %s priority %u\n",
	    ether_ntoa((struct ether_addr *)lladdr), bprio);

	if (ifbp.ifbop_root_bridge == ifbp.ifbop_desg_bridge)
		return (0);

	PV2ID(ifbp.ifbop_root_bridge, bprio, lladdr);
	printf("\troot: id %s priority %u ifcost %u port %u\n",
	    ether_ntoa((struct ether_addr *)lladdr), bprio,
	    ifbp.ifbop_root_path_cost, ifbp.ifbop_root_port & 0xfff);

	return (0);
}

int
bridge_list(int s, char *brdg, char *delim)
{
	struct ifbreq *reqp;
	struct ifbifconf bifc;
	int i, len = 8192;
	char buf[sizeof(reqp->ifbr_ifsname) + 1], *inbuf = NULL, *inb;

	while (1) {
		bifc.ifbic_len = len;
		inb = realloc(inbuf, len);
		if (inb == NULL)
			err(1, "malloc");
		bifc.ifbic_buf = inbuf = inb;
		strlcpy(bifc.ifbic_name, brdg, sizeof(bifc.ifbic_name));
		if (ioctl(s, SIOCBRDGIFS, &bifc) < 0)
			err(1, "%s", brdg);
		if (bifc.ifbic_len + sizeof(*reqp) < len)
			break;
		len *= 2;
	}
	for (i = 0; i < bifc.ifbic_len / sizeof(*reqp); i++) {
		reqp = bifc.ifbic_req + i;
		strlcpy(buf, reqp->ifbr_ifsname, sizeof(buf));
		printf("%s%s ", delim, buf);
		printb("flags", reqp->ifbr_ifsflags, IFBIFBITS);
		printf("\n");
		if (reqp->ifbr_ifsflags & IFBIF_SPAN)
			continue;
		printf("\t\t");
		printf("port %u ifpriority %u ifcost %u",
		    reqp->ifbr_portno, reqp->ifbr_priority,
		    reqp->ifbr_path_cost);
		if (reqp->ifbr_ifsflags & IFBIF_STP)
			printf(" %s role %s",
			    stpstates[reqp->ifbr_state],
			    stproles[reqp->ifbr_role]);
		printf("\n");
		bridge_rules(s, brdg, buf, delim);
	}
	free(bifc.ifbic_buf);
	return (0);		/* NOTREACHED */
}

int
bridge_add(int s, char *brdg, char *ifn)
{
	struct ifbreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	strlcpy(req.ifbr_ifsname, ifn, sizeof(req.ifbr_ifsname));
	if (ioctl(s, SIOCBRDGADD, &req) < 0) {
		if (errno == EEXIST)
			return (0);
		warn("%s: %s", brdg, ifn);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_delete(int s, char *brdg, char *ifn)
{
	struct ifbreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	strlcpy(req.ifbr_ifsname, ifn, sizeof(req.ifbr_ifsname));
	if (ioctl(s, SIOCBRDGDEL, &req) < 0) {
		warn("%s: %s", brdg, ifn);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_addspan(int s, char *brdg, char *ifn)
{
	struct ifbreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	strlcpy(req.ifbr_ifsname, ifn, sizeof(req.ifbr_ifsname));
	if (ioctl(s, SIOCBRDGADDS, &req) < 0) {
		warn("%s: %s", brdg, ifn);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_delspan(int s, char *brdg, char *ifn)
{
	struct ifbreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	strlcpy(req.ifbr_ifsname, ifn, sizeof(req.ifbr_ifsname));
	if (ioctl(s, SIOCBRDGDELS, &req) < 0) {
		warn("%s: %s", brdg, ifn);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_timeout(int s, char *brdg, char *arg)
{
	struct ifbrparam bp;
	long newtime;
	char *endptr;

	errno = 0;
	newtime = strtol(arg, &endptr, 0);
	if (arg[0] == '\0' || endptr[0] != '\0' ||
	    (newtime & ~INT_MAX) != 0L ||
	    (errno == ERANGE && newtime == LONG_MAX)) {
		printf("invalid arg for timeout: %s\n", arg);
		return (EX_USAGE);
	}

	strlcpy(bp.ifbrp_name, brdg, sizeof(bp.ifbrp_name));
	bp.ifbrp_ctime = newtime;
	if (ioctl(s, SIOCBRDGSTO, (caddr_t)&bp) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_maxage(int s, char *brdg, char *arg)
{
	struct ifbrparam bp;
	unsigned long v;
	char *endptr;

	errno = 0;
	v = strtoul(arg, &endptr, 0);
	if (arg[0] == '\0' || endptr[0] != '\0' || v > 0xffUL ||
	    (errno == ERANGE && v == ULONG_MAX)) {
		printf("invalid arg for maxage: %s\n", arg);
		return (EX_USAGE);
	}

	strlcpy(bp.ifbrp_name, brdg, sizeof(bp.ifbrp_name));
	bp.ifbrp_maxage = v;
	if (ioctl(s, SIOCBRDGSMA, (caddr_t)&bp) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_priority(int s, char *brdg, char *arg)
{
	struct ifbrparam bp;
	unsigned long v;
	char *endptr;

	errno = 0;
	v = strtoul(arg, &endptr, 0);
	if (arg[0] == '\0' || endptr[0] != '\0' || v > 0xffffUL ||
	    (errno == ERANGE && v == ULONG_MAX)) {
		printf("invalid arg for maxage: %s\n", arg);
		return (EX_USAGE);
	}

	strlcpy(bp.ifbrp_name, brdg, sizeof(bp.ifbrp_name));
	bp.ifbrp_prio = v;
	if (ioctl(s, SIOCBRDGSPRI, (caddr_t)&bp) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_proto(int s, char *brdg, char *arg)
{
	struct ifbrparam bp;
	int i, proto = -1;

	for (i = 0; i <= BSTP_PROTO_MAX; i++)
		if (strcmp(arg, stpproto[i]) == 0) {
			proto = i;
			break;
		}
	if (proto == -1) {
		printf("invalid arg for proto: %s\n", arg);
		return (EX_USAGE);
	}

	strlcpy(bp.ifbrp_name, brdg, sizeof(bp.ifbrp_name));
	bp.ifbrp_prio = proto;
	if (ioctl(s, SIOCBRDGSPROTO, (caddr_t)&bp) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_fwddelay(int s, char *brdg, char *arg)
{
	struct ifbrparam bp;
	unsigned long v;
	char *endptr;

	errno = 0;
	v = strtoul(arg, &endptr, 0);
	if (arg[0] == '\0' || endptr[0] != '\0' || v > 0xffUL ||
	    (errno == ERANGE && v == ULONG_MAX)) {
		printf("invalid arg for fwddelay: %s\n", arg);
		return (EX_USAGE);
	}

	strlcpy(bp.ifbrp_name, brdg, sizeof(bp.ifbrp_name));
	bp.ifbrp_fwddelay = v;
	if (ioctl(s, SIOCBRDGSFD, (caddr_t)&bp) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_hellotime(int s, char *brdg, char *arg)
{
	struct ifbrparam bp;
	unsigned long v;
	char *endptr;

	errno = 0;
	v = strtoul(arg, &endptr, 0);
	if (arg[0] == '\0' || endptr[0] != '\0' || v > 0xffUL ||
	    (errno == ERANGE && v == ULONG_MAX)) {
		printf("invalid arg for hellotime: %s\n", arg);
		return (EX_USAGE);
	}

	strlcpy(bp.ifbrp_name, brdg, sizeof(bp.ifbrp_name));
	bp.ifbrp_hellotime = v;
	if (ioctl(s, SIOCBRDGSHT, (caddr_t)&bp) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_maxaddr(int s, char *brdg, char *arg)
{
	struct ifbrparam bp;
	unsigned long newsize;
	char *endptr;

	errno = 0;
	newsize = strtoul(arg, &endptr, 0);
	if (arg[0] == '\0' || endptr[0] != '\0' || newsize > 0xffffffffUL ||
	    (errno == ERANGE && newsize == ULONG_MAX)) {
		printf("invalid arg for maxaddr: %s\n", arg);
		return (EX_USAGE);
	}

	strlcpy(bp.ifbrp_name, brdg, sizeof(bp.ifbrp_name));
	bp.ifbrp_csize = newsize;
	if (ioctl(s, SIOCBRDGSCACHE, (caddr_t)&bp) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_deladdr(int s, char *brdg, char *addr)
{
	struct ifbareq ifba;
	struct ether_addr *ea;

	strlcpy(ifba.ifba_name, brdg, sizeof(ifba.ifba_name));
	ea = ether_aton(addr);
	if (ea == NULL) {
		warnx("Invalid address: %s", addr);
		return (EX_USAGE);
	}
	bcopy(ea, &ifba.ifba_dst, sizeof(struct ether_addr));

	if (ioctl(s, SIOCBRDGDADDR, &ifba) < 0) {
		warn("%s: %s", brdg, addr);
		return (EX_IOERR);
	}

	return (0);
}

int
bridge_ifprio(int s, char *brdg, char *ifname, char *val)
{
	struct ifbreq breq;
	unsigned long v;
	char *endptr;

	strlcpy(breq.ifbr_name, brdg, sizeof(breq.ifbr_name));
	strlcpy(breq.ifbr_ifsname, ifname, sizeof(breq.ifbr_ifsname));

	errno = 0;
	v = strtoul(val, &endptr, 0);
	if (val[0] == '\0' || endptr[0] != '\0' || v > 0xffUL ||
	    (errno == ERANGE && v == ULONG_MAX)) {
		printf("invalid arg for ifpriority: %s\n", val);
		return (EX_USAGE);
	}
	breq.ifbr_priority = v;

	if (ioctl(s, SIOCBRDGSIFPRIO, (caddr_t)&breq) < 0) {
		warn("%s: %s", brdg, val);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_ifcost(int s, char *brdg, char *ifname, char *val)
{
	struct ifbreq breq;
	unsigned long v;
	char *endptr;

	strlcpy(breq.ifbr_name, brdg, sizeof(breq.ifbr_name));
	strlcpy(breq.ifbr_ifsname, ifname, sizeof(breq.ifbr_ifsname));

	if (val == NULL)
		v = 0;
	else {
		errno = 0;
		v = strtoul(val, &endptr, 0);
		if (val[0] == '\0' || endptr[0] != '\0' ||
		    v < 0 || v > 0xffffffffUL ||
		    (errno == ERANGE && v == ULONG_MAX)) {
			printf("invalid arg for ifcost: %s\n", val);
			return (EX_USAGE);
		}
	}
	breq.ifbr_path_cost = v;

	if (ioctl(s, SIOCBRDGSIFCOST, (caddr_t)&breq) < 0) {
		warn("%s: %s", brdg, val);
		return (EX_IOERR);
	}
	return (0);
}

int
bridge_addaddr(int s, char *brdg, char *ifname, char *addr)
{
	struct ifbareq ifba;
	struct ether_addr *ea;

	strlcpy(ifba.ifba_name, brdg, sizeof(ifba.ifba_name));
	strlcpy(ifba.ifba_ifsname, ifname, sizeof(ifba.ifba_ifsname));

	ea = ether_aton(addr);
	if (ea == NULL) {
		warnx("Invalid address: %s", addr);
		return (EX_USAGE);
	}
	bcopy(ea, &ifba.ifba_dst, sizeof(struct ether_addr));
	ifba.ifba_flags = IFBAF_STATIC;

	if (ioctl(s, SIOCBRDGSADDR, &ifba) < 0) {
		warn("%s: %s", brdg, addr);
		return (EX_IOERR);
	}

	return (0);
}

int
bridge_addrs(int s, char *brdg, char *delim)
{
	struct ifbaconf ifbac;
	struct ifbareq *ifba;
	char *inbuf = NULL, buf[sizeof(ifba->ifba_ifsname) + 1], *inb;
	int i, len = 8192;

	while (1) {
		ifbac.ifbac_len = len;
		inb = realloc(inbuf, len);
		if (inb == NULL)
			err(EX_IOERR, "malloc");
		ifbac.ifbac_buf = inbuf = inb;
		strlcpy(ifbac.ifbac_name, brdg, sizeof(ifbac.ifbac_name));
		if (ioctl(s, SIOCBRDGRTS, &ifbac) < 0) {
			if (errno == ENETDOWN)
				return (0);
			err(EX_IOERR, "%s", brdg);
		}
		if (ifbac.ifbac_len + sizeof(*ifba) < len)
			break;
		len *= 2;
	}

	for (i = 0; i < ifbac.ifbac_len / sizeof(*ifba); i++) {
		ifba = ifbac.ifbac_req + i;
		strlcpy(buf, ifba->ifba_ifsname, sizeof(buf));
		printf("%s%s %s %u ", delim, ether_ntoa(&ifba->ifba_dst),
		    buf, ifba->ifba_age);
		printb("flags", ifba->ifba_flags, IFBAFBITS);
		printf("\n");
	}
	free(inbuf);
	return (0);
}

int
bridge_holdcnt(int s, char *brdg, char *value)
{
	struct ifbrparam bp;
	const char *errstr;

	bp.ifbrp_txhc = strtonum(value, 0, UINT8_MAX, &errstr);
	if (errstr) {
		warn("holdcnt %s %s", value, errstr);
		return (EX_IOERR);
	}

	strlcpy(bp.ifbrp_name, brdg, sizeof(bp.ifbrp_name));
	if (ioctl(s, SIOCBRDGSTXHC, (caddr_t)&bp) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);
}

/*
 * Check to make sure 'brdg' is really a bridge interface.
 */
int
is_bridge(int s, char *brdg)
{
	struct ifreq ifr;
	struct ifbaconf ifbac;

	strlcpy(ifr.ifr_name, brdg, sizeof(ifr.ifr_name));

	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0)
		return (0);

	ifbac.ifbac_len = 0;
	strlcpy(ifbac.ifbac_name, brdg, sizeof(ifbac.ifbac_name));
	if (ioctl(s, SIOCBRDGRTS, (caddr_t)&ifbac) < 0) {
		if (errno == ENETDOWN)
			return (1);
		return (0);
	}
	return (1);
}

int
bridge_status(int s, char *brdg)
{
	struct ifreq ifr;
	struct ifbrparam bp1, bp2;
	int err;

	strlcpy(ifr.ifr_name, brdg, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0) {
		warn("%s", brdg);
		if (errno == EPERM)
			return (EX_NOPERM);
		return (EX_IOERR);
	}

	printf("%s: ", brdg);
	printb("flags", ifr.ifr_flags, IFFBITS);
	printf("\n");

	err = bridge_cfg(s, brdg, "\t");
	if (err)
		return (err);

	err = bridge_list(s, brdg, "\t");
	if (err)
		return (err);

	strlcpy(bp1.ifbrp_name, brdg, sizeof(bp1.ifbrp_name));
	if (ioctl(s, SIOCBRDGGCACHE, (caddr_t)&bp1) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}

	strlcpy(bp2.ifbrp_name, brdg, sizeof(bp2.ifbrp_name));
	if (ioctl(s, SIOCBRDGGTO, (caddr_t)&bp2) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}

	printf("\tAddresses (max cache: %u, timeout: %u):\n",
	    bp1.ifbrp_csize, bp2.ifbrp_ctime);

	err = bridge_addrs(s, brdg, "\t\t");
	return (err);
}

int
bridge_flushrule(int s, char *brdg, char *ifname)
{
	struct ifbrlreq req;

	strlcpy(req.ifbr_name, brdg, sizeof(req.ifbr_name));
	strlcpy(req.ifbr_ifsname, ifname, sizeof(req.ifbr_ifsname));
	if (ioctl(s, SIOCBRDGFRL, &req) < 0) {
		warn("%s: %s", brdg, ifname);
		return (EX_USAGE);
	}
	return (0);
}

int
bridge_rules(int s, char *brdg, char *ifname, char *delim)
{
	char *inbuf = NULL, *inb;
	struct ifbrlconf ifc;
	struct ifbrlreq *ifrp;
	int len = 8192, i;

	while (1) {
		ifc.ifbrl_len = len;
		inb = realloc(inbuf, len);
		if (inb == NULL)
			err(1, "malloc");
		ifc.ifbrl_buf = inbuf = inb;
		strlcpy(ifc.ifbrl_name, brdg, sizeof(ifc.ifbrl_name));
		strlcpy(ifc.ifbrl_ifsname, ifname, sizeof(ifc.ifbrl_ifsname));
		if (ioctl(s, SIOCBRDGGRL, &ifc) < 0)
			err(1, "ioctl(SIOCBRDGGRL)");
		if (ifc.ifbrl_len + sizeof(*ifrp) < len)
			break;
		len *= 2;
	}
	ifrp = ifc.ifbrl_req;
	for (i = 0; i < ifc.ifbrl_len; i += sizeof(*ifrp)) {
		ifrp = (struct ifbrlreq *)((caddr_t)ifc.ifbrl_req + i);
		bridge_showrule(ifrp, delim);
	}
	return (0);
}

void
bridge_showrule(struct ifbrlreq *r, char *delim)
{
	if (delim)
		printf("%s    ", delim);
	else
		printf("%s: ", r->ifbr_name);

	if (r->ifbr_action == BRL_ACTION_BLOCK)
		printf("block ");
	else if (r->ifbr_action == BRL_ACTION_PASS)
		printf("pass ");
	else
		printf("[neither block nor pass?]\n");

	if ((r->ifbr_flags & (BRL_FLAG_IN | BRL_FLAG_OUT)) ==
	    (BRL_FLAG_IN | BRL_FLAG_OUT))
		printf("in/out ");
	else if (r->ifbr_flags & BRL_FLAG_IN)
		printf("in ");
	else if (r->ifbr_flags & BRL_FLAG_OUT)
		printf("out ");
	else
		printf("[neither in nor out?]\n");

	printf("on %s", r->ifbr_ifsname);

	if (r->ifbr_flags & BRL_FLAG_SRCVALID)
		printf(" src %s", ether_ntoa(&r->ifbr_src));
	if (r->ifbr_flags & BRL_FLAG_DSTVALID)
		printf(" dst %s", ether_ntoa(&r->ifbr_dst));
	if (r->ifbr_tagname[0])
		printf(" tag %s", r->ifbr_tagname);

	printf("\n");
}

/*
 * Parse a rule definition and send it upwards.
 *
 * Syntax:
 *	{block|pass} {in|out|in/out} on {ifs} [src {mac}] [dst {mac}]
 */
int
bridge_rule(int s, char *brdg, int targc, char **targv, int ln)
{
	char **argv = targv;
	int argc = targc;
	struct ifbrlreq rule;
	struct ether_addr *ea, *dea;

	if (argc == 0) {
		fprintf(stderr, "invalid rule\n");
		return (EX_USAGE);
	}
	rule.ifbr_tagname[0] = 0;
	rule.ifbr_flags = 0;
	rule.ifbr_action = 0;
	strlcpy(rule.ifbr_name, brdg, sizeof(rule.ifbr_name));

	if (strcmp(argv[0], "block") == 0)
		rule.ifbr_action = BRL_ACTION_BLOCK;
	else if (strcmp(argv[0], "pass") == 0)
		rule.ifbr_action = BRL_ACTION_PASS;
	else
		goto bad_rule;
	argc--;	argv++;

	if (argc == 0) {
		bridge_badrule(targc, targv, ln);
		return (EX_USAGE);
	}
	if (strcmp(argv[0], "in") == 0)
		rule.ifbr_flags |= BRL_FLAG_IN;
	else if (strcmp(argv[0], "out") == 0)
		rule.ifbr_flags |= BRL_FLAG_OUT;
	else if (strcmp(argv[0], "in/out") == 0)
		rule.ifbr_flags |= BRL_FLAG_IN | BRL_FLAG_OUT;
	else
		goto bad_rule;
	argc--; argv++;

	if (argc == 0 || strcmp(argv[0], "on"))
		goto bad_rule;
	argc--; argv++;

	if (argc == 0)
		goto bad_rule;
	strlcpy(rule.ifbr_ifsname, argv[0], sizeof(rule.ifbr_ifsname));
	argc--; argv++;

	while (argc) {
		if (strcmp(argv[0], "dst") == 0) {
			if (rule.ifbr_flags & BRL_FLAG_DSTVALID)
				goto bad_rule;
			rule.ifbr_flags |= BRL_FLAG_DSTVALID;
			dea = &rule.ifbr_dst;
		} else if (strcmp(argv[0], "src") == 0) {
			if (rule.ifbr_flags & BRL_FLAG_SRCVALID)
				goto bad_rule;
			rule.ifbr_flags |= BRL_FLAG_SRCVALID;
			dea = &rule.ifbr_src;
		} else if (strcmp(argv[0], "tag") == 0) {
			if (argc < 2) {
				fprintf(stderr, "missing tag name\n");
				goto bad_rule;
			}
			if (rule.ifbr_tagname[0]) {
				fprintf(stderr, "tag already defined\n");
				goto bad_rule;
			}
			if (strlcpy(rule.ifbr_tagname, argv[1],
			    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
				fprintf(stderr, "tag name too long\n");
				goto bad_rule;
			}
			dea = NULL;
		} else
			goto bad_rule;

		argc--; argv++;

		if (argc == 0)
			goto bad_rule;
		if (dea != NULL) {
			ea = ether_aton(argv[0]);
			if (ea == NULL) {
				warnx("Invalid address: %s", argv[0]);
				return (EX_USAGE);
			}
			bcopy(ea, dea, sizeof(*dea));
		}
		argc--; argv++;
	}

	if (ioctl(s, SIOCBRDGARL, &rule) < 0) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	return (0);

bad_rule:
	bridge_badrule(targc, targv, ln);
	return (EX_USAGE);
}

#define MAXRULEWORDS 8

int
bridge_rulefile(int s, char *brdg, char *fname)
{
	FILE *f;
	char *str, *argv[MAXRULEWORDS], buf[1024];
	int ln = 0, argc = 0, err = 0, xerr;

	f = fopen(fname, "r");
	if (f == NULL) {
		warn("%s", fname);
		return (EX_IOERR);
	}

	while (fgets(buf, sizeof(buf), f) != NULL) {
		ln++;
		if (buf[0] == '#' || buf[0] == '\n')
			continue;

		argc = 0;
		str = strtok(buf, "\n\t\r ");
		while (str != NULL && argc < MAXRULEWORDS) {
			argv[argc++] = str;
			str = strtok(NULL, "\n\t\r ");
		}

		/* Rule is too long if there's more. */
		if (str != NULL) {
			fprintf(stderr, "invalid rule: %d: %s ...\n", ln, buf);
			continue;
		}

		xerr = bridge_rule(s, brdg, argc, argv, ln);
		if (xerr)
			err = xerr;
	}
	fclose(f);
	return (err);
}

void
bridge_badrule(int argc, char *argv[], int ln)
{
	int i;

	fprintf(stderr, "invalid rule: ");
	if (ln != -1)
		fprintf(stderr, "%d: ", ln);
	for (i = 0; i < argc; i++) {
		fprintf(stderr, "%s ", argv[i]);
	}
	fprintf(stderr, "\n");
}

/*
 * Print a value ala the %b format of the kernel's printf
 * (borrowed from ifconfig.c)
 */
void
printb(char *s, unsigned short v, char *bits)
{
	int i, any = 0;
	char c;

	if (bits && *bits == 8)
		printf("%s=%o", s, v);
	else
		printf("%s=%x", s, v);

	if (bits) {
		bits++;
		putchar('<');
		while ((i = *bits++)) {
			if (v & (1 << (i-1))) {
				if (any)
					putchar(',');
				any = 1;
				for (; (c = *bits) > 32; bits++)
					putchar(c);
			} else
				for (; *bits > 32; bits++)
					;
		}
		putchar('>');
	}
}
@


1.43
log
@adding an interface if it already is added should be successful, not give a
bogus and misleading error, this permits re-running bridgename.if(5) files etc
without confusion
prodded/found by deraadt@@
ok deraadt@@ phessler@@ henning@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.42 2007/01/01 20:11:17 jmc Exp $	*/
@


1.42
log
@- merge first two synopses
- standard options list
- sync usage()

started by a diff from stevesk;
usage() help from dlg;
ok reyk;
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.41 2006/12/31 10:44:52 jmc Exp $	*/
d851 2
@


1.41
log
@-A before -a;
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.40 2006/12/30 18:43:41 reyk Exp $	*/
d132 3
a134 1
	fprintf(stderr, "usage: brconfig [-Aa]\n");
d136 4
a139 1
	    "       brconfig interface [up] [down] [add if] [del if] ...\n");
@


1.40
log
@add -A to usage().

thanks to Sven-Volker Nowarra
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.39 2006/12/11 22:11:48 reyk Exp $	*/
d132 1
a132 1
	fprintf(stderr, "usage: brconfig [-aA]\n");
@


1.39
log
@refer to the RSTP point to point option as "PTP" instead of "P2P".
P2P is commonly used in relation to peer to peer networks, PTP is used
in various protocols for layer 2 point to point links (ie., full
duplex ethernet links).

note that the newly added brconfig commands [-]p2p and [-]autop2p will
change to [-]ptp and [-]autoptp.

suggested by Andrew Thompson (thompsa@@freebsd.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.38 2006/12/03 13:41:19 reyk Exp $	*/
d132 1
a132 1
	fprintf(stderr, "usage: brconfig -a\n");
@


1.38
log
@Add Rapid Spanning Tree Protocol support (802.1d-2004) based on work
by Andrew Thompson (thompsa@@freebsd.org). The local changes include
adoption to our bridge code, reduced stack usage and many other bits.
If stp is enabled, RSTP will now be used by default.

Thanks for help from Andrew.

This code has been in snaps for while now, commit encouraged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.37 2006/07/25 00:26:42 djm Exp $	*/
d96 1
a96 1
"\020\1LEARNING\2DISCOVER\3BLOCKNONIP\4STP\5EDGE\6AUTOEDGE\7P2P\10AUTOP2P\11SPAN"
d533 1
a533 1
		} else if (strcmp("p2p", argv[0]) == 0) {
d536 1
a536 1
				warnx("p2p requires an argument");
d540 1
a540 1
			    IFBIF_BSTP_P2P);
d543 1
a543 1
		} else if (strcmp("-p2p", argv[0]) == 0) {
d546 1
a546 1
				warnx("-p2p requires an argument");
d550 1
a550 1
			    IFBIF_BSTP_P2P);
d553 1
a553 1
		} else if (strcmp("autop2p", argv[0]) == 0) {
d556 1
a556 1
				warnx("autop2p requires an argument");
d560 1
a560 1
			    IFBIF_BSTP_AUTOP2P);
d563 1
a563 1
		} else if (strcmp("-autop2p", argv[0]) == 0) {
d566 1
a566 1
				warnx("-autop2p requires an argument");
d570 1
a570 1
			    IFBIF_BSTP_P2P);
@


1.37
log
@better yet, make this use getopt for argument processing;
"looks good" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.36 2006/07/24 08:02:43 djm Exp $	*/
d31 1
d62 1
d74 1
d86 3
d95 12
a106 1
#define	IFBIFBITS	"\020\1LEARNING\2DISCOVER\3BLOCKNONIP\4STP\11SPAN"
d114 13
a140 1
	int aflag = 0;
d147 1
a147 1
	while ((ch = getopt(argc, argv, "ah")) != -1) {
d149 3
d165 3
a167 1
	if (aflag || argc < 1)
d396 9
d425 9
d493 89
d603 1
a603 1
	req.ifbr_ifsflags |= flag;
d625 1
a625 1
	req.ifbr_ifsflags &= ~flag;
d754 1
a754 1
	struct ifbrparam ifbp;
d756 3
a758 1
	u_int8_t ht, fd, ma;
d760 2
a761 2
	strlcpy(ifbp.ifbrp_name, brdg, sizeof(ifbp.ifbrp_name));
	if (ioctl(s, SIOCBRDGGPRI, (caddr_t)&ifbp)) {
d765 10
a774 1
	pri = ifbp.ifbrp_prio;
d776 2
a777 5
	if (ioctl(s, SIOCBRDGGHT, (caddr_t)&ifbp)) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	ht = ifbp.ifbrp_hellotime;
d779 3
a781 5
	if (ioctl(s, SIOCBRDGGFD, (caddr_t)&ifbp)) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	fd = ifbp.ifbrp_fwddelay;
d783 2
a784 5
	if (ioctl(s, SIOCBRDGGMA, (caddr_t)&ifbp)) {
		warn("%s", brdg);
		return (EX_IOERR);
	}
	ma = ifbp.ifbrp_maxage;
d786 4
a789 2
	printf("%spriority %u hellotime %u fwddelay %u maxage %u\n",
	    delim, pri, ht, fd, ma);
d823 1
a823 1
		printf("\t\t\t");
d828 3
a830 1
			printf(" %s", stpstates[reqp->ifbr_state]);
d976 25
d1130 11
a1140 7
	errno = 0;
	v = strtoul(val, &endptr, 0);
	if (val[0] == '\0' || endptr[0] != '\0' ||
	    v < 1 || v > 0xffffffffUL ||
	    (errno == ERANGE && v == ULONG_MAX)) {
		printf("invalid arg for ifcost: %s\n", val);
		return (EX_USAGE);
d1213 20
d1276 1
a1276 2
	printf("\tConfiguration:\n");
	err = bridge_cfg(s, brdg, "\t\t");
d1280 1
a1280 2
	printf("\tInterfaces:\n");
	err = bridge_list(s, brdg, "\t\t");
d1562 1
a1562 1
	
@


1.36
log
@make "brconfig" with no arguments equivalent to "brconfig -a",
following the similar change to ifconfig; 'nice' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.35 2006/03/20 20:01:34 dhill Exp $	*/
d44 1
d110 2
a111 1
	int error = 0, sock;
d118 16
a133 1
	if (argc < 2 || strcmp(argv[1], "-a") == 0)
a135 6
	if (strcmp(argv[1], "-h") == 0) {
		usage();
		return (EX_USAGE);
	}

	argc--; argv++;
@


1.35
log
@NetBSD Coverity CID 774: Don't increment a pointer *before* testing it for NULL!

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.34 2005/12/21 01:40:23 millert Exp $	*/
d112 8
a119 1
	if (argc < 2) {
a123 4
	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock < 0)
		err(1, "socket");

a125 3

	if (strcmp(brdg, "-a") == 0)
		return bridge_show_all(sock);
@


1.34
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.33 2004/09/14 22:13:03 deraadt Exp $	*/
d1356 1
a1356 1
	bits++;
d1358 1
@


1.33
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.32 2004/05/27 07:41:58 otto Exp $	*/
a40 1
#include <sys/errno.h>
d43 1
@


1.32
log
@Rule parser improvements: line numbers, no nl at eof, handling of lines
with too many tokens. Based on diff from Jared Yanovich.
ok tdeval@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.31 2004/05/23 06:47:49 deraadt Exp $	*/
d1116 1
a1116 1
	struct ifbrlreq *ifrp, ifreq;
d1129 1
a1129 1
		if (ifc.ifbrl_len + sizeof(ifreq) < len)
d1134 1
a1134 1
	for (i = 0; i < ifc.ifbrl_len; i += sizeof(ifreq)) {
@


1.31
log
@do not free before going to exit path; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.30 2004/03/08 17:23:33 mcbride Exp $	*/
d1293 2
a1294 2
	char *str, *argv[MAXRULEWORDS], buf[1024], xbuf[1024];
	int ln = 1, argc = 0, err = 0, xerr;
d1302 1
a1302 4
	while (1) {
		fgets(buf, sizeof(buf), f);
		if (feof(f))
			break;
d1309 1
a1309 2
		strlcpy(xbuf, buf, sizeof(xbuf));
		while (str != NULL) {
a1310 5
			if (argc > MAXRULEWORDS) {
				fprintf(stderr, "invalid rule: %d: %s\n",
				    ln, xbuf);
				break;
			}
d1314 3
a1316 1
		if (argc > MAXRULEWORDS)
d1318 1
@


1.30
log
@Prevent user from specifying an interface name longer than IFNAMSIZ.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.29 2004/03/02 21:01:00 tdeval Exp $	*/
d493 1
a493 2
		if (inb == NULL) {
			free(inbuf);
a494 1
		}
d648 1
a648 2
		if (inb == NULL) {
			free(inbuf);
a649 1
		}
d999 1
a999 2
		if (inb == NULL) {
			free(inbuf);
a1000 1
		}
d1122 1
a1122 2
		if (inb == NULL) {
			free(inbuf);
a1123 1
		}
@


1.29
log
@64-bits datatype fixes for strto(u)l conversions.
From Daniel Lucq, through and OK by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.28 2004/01/01 00:02:06 deraadt Exp $	*/
d126 5
@


1.28
log
@use warnx for ENXIO devices, so that it says "Device not configured".  For
other errors, continue too use the "is not a bridge" mantra.
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.27 2003/09/26 03:29:59 deraadt Exp $	*/
d746 1
a746 1
	int newtime;
d751 3
a753 2
	if (arg[0] == '\0' || endptr[0] != '\0' || newtime < 0 ||
	    (errno == ERANGE && newtime == ULONG_MAX)) {
d771 1
a771 1
	u_int32_t v;
d776 2
a777 2
	if (arg[0] == '\0' || endptr[0] != '\0' ||
	    (errno == ERANGE && v == ULONG_MAX) || (v > 0xff)) {
d795 1
a795 1
	u_int32_t v;
d800 2
a801 2
	if (arg[0] == '\0' || endptr[0] != '\0' ||
	    (errno == ERANGE && v == ULONG_MAX) || (v > 0xffff)) {
d819 1
a819 1
	u_int32_t v;
d824 2
a825 2
	if (arg[0] == '\0' || endptr[0] != '\0' ||
	    (errno == ERANGE && v == ULONG_MAX) || (v > 0xff)) {
d843 1
a843 1
	u_int32_t v;
d848 2
a849 2
	if (arg[0] == '\0' || endptr[0] != '\0' ||
	    (errno == ERANGE && v == ULONG_MAX) || (v > 0xff)) {
d867 1
a867 1
	u_int32_t newsize;
d872 1
a872 1
	if (arg[0] == '\0' || endptr[0] != '\0' ||
d913 1
a913 1
	u_int32_t v;
d921 2
a922 2
	if (val[0] == '\0' || endptr[0] != '\0' ||
	    (errno == ERANGE && v == ULONG_MAX) || (v > 0xff)) {
d939 1
a939 1
	u_int32_t v;
d948 2
a949 1
	    (errno == ERANGE && v == ULONG_MAX) || (v < 1 || v > 0xffffffff)) {
@


1.27
log
@realloc properly; ok jason
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.26 2003/06/25 09:44:55 henning Exp $	*/
d128 4
a131 1
		warnx("%s is not a bridge", brdg);
@


1.26
log
@allow bridge filter rules to specify a tag.
if a packet matches such a rule it is tagged accordingly and pf can
filter based on that tag.
this allows, for example, bridge to be used as classifier for pf, and thus
gives all the power of pf based on mac address filters.

please note that currently the bridge filters only apply to packets
which are not destined for the local host.

ok deraadt@@ jason@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.25 2003/06/02 18:44:35 jason Exp $	*/
d477 1
a477 1
	char *inbuf = NULL;
d484 3
a486 2
		ifc.ifc_buf = inbuf = realloc(inbuf, len);
		if (inbuf == NULL)
d488 2
d637 1
a637 1
	char buf[sizeof(reqp->ifbr_ifsname) + 1], *inbuf = NULL;
a639 1
		strlcpy(bifc.ifbic_name, brdg, sizeof(bifc.ifbic_name));
d641 3
a643 2
		bifc.ifbic_buf = inbuf = realloc(inbuf, len);
		if (inbuf == NULL)
d645 3
d987 1
a987 1
	char *inbuf = NULL, buf[sizeof(ifba->ifba_ifsname) + 1];
d992 6
a997 1
		ifbac.ifbac_buf = inbuf = realloc(inbuf, len);
a998 2
		if (inbuf == NULL)
			err(EX_IOERR, "malloc");
d1110 1
a1110 1
	char *inbuf = NULL;
d1117 6
a1122 1
		ifc.ifbrl_buf = inbuf = realloc(inbuf, len);
a1124 2
		if (inbuf == NULL)
			err(1, "malloc");
@


1.25
log
@nuke clause 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.24 2003/05/30 21:16:50 henning Exp $	*/
d1158 2
d1182 1
d1229 15
d1251 7
a1257 4
		ea = ether_aton(argv[0]);
		if (ea == NULL) {
			warnx("Invalid address: %s", argv[0]);
			return (EX_USAGE);
a1258 1
		bcopy(ea, dea, sizeof(*dea));
@


1.24
log
@o timeout is int, not u_int32_t
o reject negative timeouts

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.23 2002/12/18 16:10:27 markus Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.23
log
@remove dup include
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.22 2002/12/09 23:57:31 deraadt Exp $	*/
d742 1
a742 1
	u_int32_t newtime;
d746 2
a747 2
	newtime = strtoul(arg, &endptr, 0);
	if (arg[0] == '\0' || endptr[0] != '\0' ||
@


1.22
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.21 2002/12/09 12:34:08 markus Exp $	*/
a49 1
#include <stdlib.h>
@


1.21
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.20 2002/12/09 10:11:53 markus Exp $	*/
a53 1
int main(int, char **);
d672 1
a672 1
	return (0);             /* NOTREACHED */
a784 1
	
a832 1
	
a856 1
	
@


1.20
log
@allow setting of ifcost with brconfig.  enables selection of preferred
port/path to root bridge among several LANs.   unlike ifpriority, which
allows you to select designated port if serveral interfaces belong
to the same LAN;  ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.19 2002/07/03 22:32:32 deraadt Exp $	*/
d948 1
a948 2
	    (errno == ERANGE && v == ULONG_MAX) ||
		(v < 1 || v > 0xffffffff)) {
@


1.19
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.18 2002/07/01 21:43:21 jason Exp $	*/
d70 1
d360 10
d664 3
a666 2
		printf("port %u priority %u",
		    reqp->ifbr_portno, reqp->ifbr_priority);
d929 27
@


1.18
log
@cut and pasto (fetch maxage correctly); Benny Holmgren <bigfoot@@astrakan.hig.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.17 2002/02/16 21:27:33 millert Exp $	*/
d105 1
a105 1
usage()
d113 1
a113 3
main(argc, argv)
	int argc;
	char *argv[];
d428 1
a428 4
bridge_ifsetflag(s, brdg, ifsname, flag)
	int s;
	char *brdg, *ifsname;
	u_int32_t flag;
d449 1
a449 4
bridge_ifclrflag(s, brdg, ifsname, flag)
	int s;
	char *brdg, *ifsname;
	u_int32_t flag;
d471 1
a471 2
bridge_show_all(s)
	int s;
d507 1
a507 4
bridge_setflag(s, brdg, f)
	int s;
	char *brdg;
	short f;
d533 1
a533 4
bridge_clrflag(s, brdg, f)
	int s;
	char *brdg;
	short f;
d559 1
a559 3
bridge_flushall(s, brdg)
	int s;
	char *brdg;
d573 1
a573 3
bridge_flush(s, brdg)
	int s;
	char *brdg;
d587 1
a587 3
bridge_cfg(s, brdg, delim)
	int s;
	char *brdg, *delim;
d625 1
a625 3
bridge_list(s, brdg, delim)
	int s;
	char *brdg, *delim;
d665 1
a665 3
bridge_add(s, brdg, ifn)
	int s;
	char *brdg, *ifn;
d681 1
a681 3
bridge_delete(s, brdg, ifn)
	int s;
	char *brdg, *ifn;
d697 1
a697 3
bridge_addspan(s, brdg, ifn)
	int s;
	char *brdg, *ifn;
d713 1
a713 3
bridge_delspan(s, brdg, ifn)
	int s;
	char *brdg, *ifn;
d729 1
a729 3
bridge_timeout(s, brdg, arg)
	int s;
	char *brdg, *arg;
d753 1
a753 3
bridge_maxage(s, brdg, arg)
	int s;
	char *brdg, *arg;
d778 1
a778 3
bridge_priority(s, brdg, arg)
	int s;
	char *brdg, *arg;
d802 1
a802 3
bridge_fwddelay(s, brdg, arg)
	int s;
	char *brdg, *arg;
d827 1
a827 3
bridge_hellotime(s, brdg, arg)
	int s;
	char *brdg, *arg;
d852 1
a852 3
bridge_maxaddr(s, brdg, arg)
	int s;
	char *brdg, *arg;
d876 1
a876 3
bridge_deladdr(s, brdg, addr)
	int s;
	char *brdg, *addr;
d898 1
a898 3
bridge_ifprio(s, brdg, ifname, val)
	int s;
	char *brdg, *ifname, *val;
d924 1
a924 3
bridge_addaddr(s, brdg, ifname, addr)
	int s;
	char *brdg, *ifname, *addr;
d949 1
a949 3
bridge_addrs(s, brdg, delim)
	int s;
	char *brdg, *delim;
d988 1
a988 3
is_bridge(s, brdg)
	int s;
	char *brdg;
d1009 1
a1009 3
bridge_status(s, brdg)
	int s;
	char *brdg;
d1057 1
a1057 3
bridge_flushrule(s, brdg, ifname)
	int s;
	char *brdg, *ifname;
d1071 1
a1071 4
bridge_rules(s, brdg, ifname, delim)
	int s;
	char *brdg, *ifname;
	char *delim;
d1100 1
a1100 3
bridge_showrule(r, delim)
	struct ifbrlreq *r;
	char *delim;
d1228 1
a1228 3
bridge_rulefile(s, brdg, fname)
	int s;
	char *brdg, *fname;
d1273 1
a1273 3
bridge_badrule(argc, argv, ln)
	int argc, ln;
	char **argv;
d1291 1
a1291 4
printb(s, v, bits)
	char *s;
	char *bits;
	unsigned short v;
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.16 2001/12/15 09:03:23 jason Exp $	*/
d633 1
a633 1
	if (ioctl(s, SIOCBRDGGFD, (caddr_t)&ifbp)) {
@


1.16
log
@KNF (A completely different idea)
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.15 2001/12/15 08:40:56 jason Exp $	*/
d53 34
a86 34
void usage __P((void));
int main __P((int, char **));
int bridge_setflag __P((int, char *, short));
int bridge_clrflag __P((int, char *, short));
int bridge_ifsetflag __P((int, char *, char *, u_int32_t));
int bridge_ifclrflag __P((int, char *, char *, u_int32_t));
int bridge_list __P((int, char *, char *));
int bridge_cfg __P((int, char *, char *));
int bridge_addrs __P((int, char *, char *));
int bridge_addaddr __P((int, char *, char *, char *));
int bridge_deladdr __P((int, char *, char *));
int bridge_maxaddr __P((int, char *, char *));
int bridge_maxage __P((int, char *, char *));
int bridge_priority __P((int, char *, char *));
int bridge_fwddelay __P((int, char *, char *));
int bridge_hellotime __P((int, char *, char *));
int bridge_ifprio __P((int, char *, char *, char *));
int bridge_timeout __P((int, char *, char *));
int bridge_flush __P((int, char *));
int bridge_flushall __P((int, char *));
int bridge_add __P((int, char *, char *));
int bridge_delete __P((int, char *, char *));
int bridge_addspan __P((int, char *, char *));
int bridge_delspan __P((int, char *, char *));
int bridge_status __P((int, char *));
int is_bridge __P((int, char *));
int bridge_show_all __P((int));
void printb __P((char *, unsigned short, char *));
int bridge_rule __P((int, char *, int, char **, int));
int bridge_rules __P((int, char *, char *, char *));
int bridge_flushrule __P((int, char *, char *));
void bridge_badrule __P((int, char **, int));
void bridge_showrule __P((struct ifbrlreq *, char *));
int bridge_rulefile __P((int, char *, char *));
@


1.15
log
@add support for creating span ports so that one can snoop a bridge
from another interface/machine/network.
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.14 2001/12/05 09:57:20 deraadt Exp $	*/
d155 1
a155 2
		}
		else if (strcmp("delete", argv[0]) == 0 ||
d165 1
a165 2
		}
		else if (strcmp("addspan", argv[0]) == 0) {
d174 1
a174 2
		}
		else if (strcmp("delspan", argv[0]) == 0) {
d183 1
a183 2
		}
		else if (strcmp("up", argv[0]) == 0) {
d187 1
a187 2
		}
		else if (strcmp("down", argv[0]) == 0) {
d191 1
a191 2
		}
		else if (strcmp("discover", argv[0]) == 0) {
d201 1
a201 2
		}
		else if (strcmp("-discover", argv[0]) == 0) {
d211 1
a211 2
		}
		else if (strcmp("blocknonip", argv[0]) == 0) {
d221 1
a221 2
		}
		else if (strcmp("-blocknonip", argv[0]) == 0) {
d231 1
a231 2
		}
		else if (strcmp("learn", argv[0]) == 0) {
d241 1
a241 2
		}
		else if (strcmp("-learn", argv[0]) == 0) {
d251 1
a251 2
		}
		else if (strcmp("flush", argv[0]) == 0) {
d255 1
a255 2
		}
		else if (strcmp("flushall", argv[0]) == 0) {
d259 1
a259 2
		}
		else if (strcmp("static", argv[0]) == 0) {
d269 1
a269 2
		}
		else if (strcmp("deladdr", argv[0]) == 0) {
d278 1
a278 2
		}
		else if (strcmp("link0", argv[0]) == 0) {
d282 1
a282 2
		}
		else if (strcmp("-link0", argv[0]) == 0) {
d286 1
a286 2
		}
		else if (strcmp("link1", argv[0]) == 0) {
d290 1
a290 2
		}
		else if (strcmp("-link1", argv[0]) == 0) {
d294 1
a294 2
		}
		else if (strcmp("link2", argv[0]) == 0) {
d298 1
a298 2
		}
		else if (strcmp("-link2", argv[0]) == 0) {
d302 1
a302 2
		}
		else if (strcmp("addr", argv[0]) == 0) {
d306 1
a306 2
		}
		else if (strcmp("maxaddr", argv[0]) == 0) {
d315 1
a315 2
		}
		else if (strcmp("hellotime", argv[0]) == 0) {
d324 1
a324 2
		}
		else if (strcmp("fwddelay", argv[0]) == 0) {
d333 1
a333 2
		}
		else if (strcmp("maxage", argv[0]) == 0) {
d342 1
a342 2
		}
		else if (strcmp("priority", argv[0]) == 0) {
d351 1
a351 2
		}
		else if (strcmp("ifpriority", argv[0]) == 0) {
d361 1
a361 2
		}
		else if (strcmp("rules", argv[0]) == 0) {
d370 1
a370 2
		}
		else if (strcmp("rule", argv[0]) == 0) {
d373 1
a373 2
		}
		else if (strcmp("rulefile", argv[0]) == 0) {
d382 1
a382 2
		}
		else if (strcmp("flushrule", argv[0]) == 0) {
d391 1
a391 2
		}
		else if (strcmp("timeout", argv[0]) == 0) {
d400 1
a400 2
		}
		else if (strcmp("stp", argv[0]) == 0) {
d410 1
a410 2
		}
		else if (strcmp("-stp", argv[0]) == 0) {
d420 1
a420 2
		}
		else {
d1255 1
a1255 2
		}
		else if (strcmp(argv[0], "src") == 0) {
d1260 1
a1260 2
		}
		else
@


1.14
log
@documentation nits
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.13 2001/11/05 07:39:16 mpech Exp $	*/
d75 2
d94 1
a94 1
#define	IFBIFBITS	"\020\1LEARNING\2DISCOVER\3BLOCKNONIP\4STP"
d167 20
d708 4
a711 1
		printf("\n\t\t\t");
d751 36
@


1.13
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.12 2001/02/27 20:51:21 jason Exp $	*/
d107 1
a107 1
	    "usage: brconfig interface [up] [down] [add if] [del if] ...\n");
@


1.12
log
@consistent printf
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.11 2001/02/12 15:45:18 jakob Exp $	*/
d1339 2
a1340 2
	register int i, any = 0;
	register char c;
@


1.11
log
@skip empty lines in rulefile. ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.10 2000/12/12 03:41:22 jason Exp $	*/
d653 1
a653 1
	printf("%spriority %u hellotime %u fwddelay %u maxage: %u\n",
@


1.10
log
@Add support for 802.1D spanning tree protocol.
NOTE: this requires recompiling brconfig with updated include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.9 2000/11/10 04:42:13 jason Exp $	*/
d1286 1
a1286 1
		if (buf[0] == '#')
@


1.9
log
@unused bit in display string
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.8 2000/07/03 17:21:26 jason Exp $	*/
d60 1
d65 5
d92 9
a100 1
#define	IFBIFBITS	"\020\1LEARNING\2DISCOVER\3BLOCKNONIP"
d317 51
d412 22
d620 40
d686 5
d739 1
a739 1
	struct ifbcachetoreq ifbct;
d743 1
d745 2
a746 1
	if (arg[0] == '\0' || endptr[0] != '\0') {
d751 3
a753 3
	strlcpy(ifbct.ifbct_name, brdg, sizeof(ifbct.ifbct_name));
	ifbct.ifbct_time = newtime;
	if (ioctl(s, SIOCBRDGSTO, (caddr_t)&ifbct) < 0) {
d761 107
d872 1
a872 1
	struct ifbcachereq ifbc;
d876 1
d878 2
a879 1
	if (arg[0] == '\0' || endptr[0] != '\0') {
d884 3
a886 3
	strlcpy(ifbc.ifbc_name, brdg, sizeof(ifbc.ifbc_name));
	ifbc.ifbc_size = newsize;
	if (ioctl(s, SIOCBRDGSCACHE, (caddr_t)&ifbc) < 0) {
d918 28
d1042 1
a1042 2
	struct ifbcachereq ifbc;
	struct ifbcachetoreq ifbct;
d1057 5
d1067 2
a1068 2
	strlcpy(ifbc.ifbc_name, brdg, sizeof(ifbc.ifbc_name));
	if (ioctl(s, SIOCBRDGGCACHE, (caddr_t)&ifbc) < 0) {
d1073 2
a1074 2
	strlcpy(ifbct.ifbct_name, brdg, sizeof(ifbct.ifbct_name));
	if (ioctl(s, SIOCBRDGGTO, (caddr_t)&ifbct) < 0) {
d1080 1
a1080 1
	    ifbc.ifbc_size, ifbct.ifbct_time);
@


1.8
log
@plug 2 memory leaks; reported by andrew.lunn@@ascom.ch.
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.7 2000/06/30 16:00:08 millert Exp $	*/
d86 1
a86 1
#define	IFBIFBITS	"\020\1LEARNING\2DISCOVER\3BLOCKNONIP\4BLOCKARP"
@


1.7
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.6 2000/02/04 06:32:04 deraadt Exp $	*/
d438 1
d735 1
a735 1

@


1.6
log
@show the rules
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.5 2000/01/25 22:06:27 jason Exp $	*/
d548 1
a548 1
			err(1, brdg);
@


1.6.2.1
log
@Pull in patch from current (more to come...):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.6 2000/02/04 06:32:04 deraadt Exp $	*/
a437 1
	free(inbuf);
d548 1
a548 1
			err(1, "%s", brdg);
d734 1
a734 1
	free(inbuf);
@


1.5
log
@add ethernet MAC filtering capability
also includes split of bridgeintr() with some optimizations for quicker
frame handling
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.4 2000/01/10 22:14:25 angelos Exp $	*/
d74 1
a74 1
int bridge_rules __P((int, char *, char *));
d77 1
a77 1
void bridge_showrule __P((struct ifbrlreq *));
d309 1
a309 1
			error = bridge_rules(sock, brdg, argv[0]);
d559 1
d827 1
a827 1
bridge_rules(s, brdg, ifname)
d830 1
d853 1
a853 1
		bridge_showrule(ifrp);
d859 1
a859 1
bridge_showrule(r)
d861 1
d863 4
a866 1
	printf("%s: ", r->ifbr_name);
@


1.4
log
@blocknonip flag -- use it on a per-interface basis to not accept from
and not forward to said interface traffic that's not
IPv4/IPv6/ARP/ReverseARP
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.3 1999/12/03 03:38:23 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Jason L. Wright (jason@@thought.net)
d73 6
d303 34
d809 238
d1048 1
a1048 1
 * Print a value a la the %b format of the kernel's printf
@


1.3
log
@make error messages more intuitive
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.2 1999/09/03 12:47:12 jason Exp $	*/
d80 1
a80 1
#define	IFBIFBITS	"\020\1LEARNING\2DISCOVER"
d177 22
d269 10
@


1.2
log
@Don't delete the cache on down/up transitions unless it's empty.  Instead
flush the dynamics.  Required other handling of the cache table to accomodate.
Modify SIOCBRDGFLUSH to handle flushall and flush dynamic requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.1 1999/09/01 03:28:01 deraadt Exp $	*/
d295 1
a295 1
		warn("ioctl(SIOCBRDGGIFFLGS)");
d302 1
a302 1
		warn("ioctl(SIOCBRDGSIFFLGS)");
d320 1
a320 1
		warn("ioctl(SIOCBRDGGIFFLGS)");
d327 1
a327 1
		warn("ioctl(SIOCBRDGSIFFLGS)");
d380 1
a380 1
		warn("ioctl(SIOCGIFFLAGS)");
d389 1
a389 1
		warn("ioctl(SIOCSIFFLAGS)");
d409 1
a409 1
		warn("ioctl(SIOCGIFFLAGS)");
d418 1
a418 1
		warn("ioctl(SIOCSIFFLAGS)");
d437 1
a437 1
		warn("ioctl(SIOCBRDGFLUSH)");
d453 1
a453 1
		warn("ioctl(SIOCBRDGFLUSH)");
d476 1
a476 1
			err(1, "ioctl(SIOCBRDGIFS)");
d502 1
a502 1
		warn("ioctl(SIOCADDBRDG)");
d520 1
a520 1
		warn("ioctl(SIOCDELBRDG)");
d546 1
a546 1
		warn("ioctl(SIOCBRDGGCACHE)");
d570 1
a570 1
		warn("ioctl(SIOCBRDGGCACHE)");
d593 1
a593 1
		warn("ioctl(SIOCBRDGDADDR)");
d620 1
a620 1
		warn("ioctl(SIOCBRDGSADDR)");
d646 1
a646 1
			err(EX_IOERR, "ioctl(SIOCBRDGRTS)");
d703 1
a703 1
		warn("ioctl(SIOCGIFFLAGS)");
d720 1
a720 1
		warn("ioctl(SIOCBRDGGCACHE)");
d726 1
a726 1
		warn("ioctl(SIOCBRDGGTO)");
@


1.1
log
@move brconfig to /sbin, where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: brconfig.c,v 1.11 1999/05/24 04:01:21 jason Exp $	*/
d432 1
a432 1
	struct ifreq ifr;
d434 4
a437 20
	strlcpy(ifr.ifr_name, brdg, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0) {
		warn("ioctl(SIOCGIFFLAGS)");
		return (EX_IOERR);
	}

	if ((ifr.ifr_flags & IFF_UP) == 0)
		return (0);

	strlcpy(ifr.ifr_name, brdg, sizeof(ifr.ifr_name));
	ifr.ifr_flags &= ~IFF_UP;
	if (ioctl(s, SIOCSIFFLAGS, (caddr_t)&ifr) < 0) {
		warn("ioctl(SIOCSIFFLAGS)");
		return (EX_IOERR);
	}

	strlcpy(ifr.ifr_name, brdg, sizeof(ifr.ifr_name));
	ifr.ifr_flags |= IFF_UP;
	if (ioctl(s, SIOCSIFFLAGS, (caddr_t)&ifr) < 0) {
		warn("ioctl(SIOCSIFFLAGS)");
a439 1

d451 1
@

