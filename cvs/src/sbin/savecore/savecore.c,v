head	1.57;
access;
symbols
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.56.0.2
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.49.0.8
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.6
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.48.0.14
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.12
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.10
	OPENBSD_5_0:1.48.0.8
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.6
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.4
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.44.0.4
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.42.0.12
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.10
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.8
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.42.0.6
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.42.0.4
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.40.0.2
	OPENBSD_3_6_BASE:1.40
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.31.0.4
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.19.0.4
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2016.09.01.14.12.07;	author tedu;	state Exp;
branches;
next	1.56;
commitid	l1qou69p43Qi9T41;

1.56
date	2016.07.04.04.05.29;	author guenther;	state Exp;
branches;
next	1.55;
commitid	ZuVXFaNJEKUAJEPr;

1.55
date	2015.10.18.03.17.48;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	J5synaripGBxFaJz;

1.54
date	2015.10.18.03.13.07;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	ts4kyMDvENX6iEZ9;

1.53
date	2015.04.26.01.23.19;	author guenther;	state Exp;
branches;
next	1.52;
commitid	4GUXlRw5WneppuJZ;

1.52
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	6b2lLILbgCR1fvia;

1.51
date	2015.03.15.00.41.27;	author millert;	state Exp;
branches;
next	1.50;
commitid	IbVxlqGw2UipKdDr;

1.50
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	Uu5nFG3wCl0LACBb;

1.49
date	2013.06.03.02.49.42;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.20.00.15.14;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.17.13.48.50;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.02.16.17.53;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.14.14.29.20;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.11.15.25.14;	author gilles;	state Exp;
branches;
next	1.42;

1.42
date	2005.01.07.21.57.10;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2004.09.15.18.52.29;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.02.13.09.04;	author tholo;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.13.21.03.34;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.28.04.09.13;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.15.20.25.17;	author marc;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.29.18.38.36;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.20.06.17;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.08.00.12.00;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.07.23.04.06;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.22.20.09.36;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.22.08.21.02;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.07.18.26.21;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.20.23.12.48;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.04.14.59.49;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.18.00.18.38;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.25.23.37.38;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.18.03.45.27;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.31.17.09.17;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.08.16.18.38.50;	author art;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	99.07.01.15.41.59;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.02.23.07.40.29;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.10.04.16.36.13;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.09.24.06.24.20;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.09.05.16.33.25;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.08.10.20.57.46;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	98.07.13.02.11.23;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.07.05.19.22.35;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.06.29.22.43.58;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.03.25.23.38.52;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.29.12.21.26;	author graichen;	state Exp;
branches;
next	1.7;

1.7
date	96.10.15.10.17.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.20.04.22.40;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.23.13.16.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.23.47.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.21.00.16.36;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.03.00.46;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.50;	author deraadt;	state Exp;
branches;
next	;

1.19.4.1
date	2000.07.06.21.25.27;	author jason;	state Exp;
branches;
next	;


desc
@@


1.57
log
@make the version symbol a fixed size (512) to reduce the potential for
bad effects when savecore reads beyond it
ok deraadt (and thanks to bluhm for remembering that this happens)
@
text
@/*	$OpenBSD: savecore.c,v 1.56 2016/07/04 04:05:29 guenther Exp $	*/
/*	$NetBSD: savecore.c,v 1.26 1996/03/18 21:16:05 leo Exp $	*/

/*-
 * Copyright (c) 1986, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* NODEV DEV_BSIZE */
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/syslog.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <nlist.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <zlib.h>
#include <kvm.h>
#include <vis.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

extern FILE *zopen(const char *fname, const char *mode, int bits);

#define KREAD(kd, addr, p)\
	(kvm_read(kd, addr, (char *)(p), sizeof(*(p))) != sizeof(*(p)))

struct nlist current_nl[] = {	/* Namelist for currently running system. */
#define X_DUMPDEV	0
	{ "_dumpdev" },
#define X_DUMPLO	1
	{ "_dumplo" },
#define X_TIME		2
	{ "_time_second" },
#define	X_DUMPSIZE	3
	{ "_dumpsize" },
#define X_VERSION	4
	{ "_version" },
#define X_PANICSTR	5
	{ "_panicstr" },
#define	X_DUMPMAG	6
	{ "_dumpmag" },
	{ NULL },
};
int cursyms[] = { X_DUMPDEV, X_DUMPLO, X_VERSION, X_DUMPMAG, -1 };
int dumpsyms[] = { X_TIME, X_DUMPSIZE, X_VERSION, X_PANICSTR, X_DUMPMAG, -1 };

struct nlist dump_nl[] = {	/* Name list for dumped system. */
	{ "_dumpdev" },		/* Entries MUST be the same as */
	{ "_dumplo" },		/*	those in current_nl[].  */
	{ "_time_second" },
	{ "_dumpsize" },
	{ "_version" },
	{ "_panicstr" },
	{ "_dumpmag" },
	{ NULL },
};

#define VERSIONSIZE 512

/* Types match kernel declarations. */
long	dumplo;			/* where dump starts on dumpdev (in blocks) */
off_t	dumpoff;		/* where dump starts on dumpdev (in bytes) */
u_long	dumpmag;		/* magic number in dump */
int	dumppages;		/* amount of memory dumped (in pages) */
u_long	dumpsize;		/* amount of memory dumped */

char	*kernel;
char	*dirn;			/* directory to save dumps in */
char	*ddname;		/* name of dump device */
dev_t	dumpdev;		/* dump device */
int	dumpfd;			/* read/write descriptor on block dev */
kvm_t	*kd_dump;		/* kvm descriptor on block dev	*/
time_t	now;			/* current date */
char	panic_mesg[1024];
int	panicstr;
char	vers[VERSIONSIZE];

int	clear, zcompress, force, verbose;	/* flags */

void	 check_kmem(void);
int	 check_space(void);
void	 clear_dump(void);
int	 dump_exists(void);
char	*find_dev(dev_t, int);
int	 get_crashtime(void);
void	 kmem_setup(void);
char	*rawname(char *s);
void	 save_core(void);
void	 usage(void);

int
main(int argc, char *argv[])
{
	struct rlimit rl;
	int ch;

	openlog("savecore", LOG_PERROR, LOG_DAEMON);

	/* Increase our data size to the max if we can. */
	if (getrlimit(RLIMIT_DATA, &rl) == 0) {
		rl.rlim_cur = rl.rlim_max;
		if (setrlimit(RLIMIT_DATA, &rl) < 0)
			syslog(LOG_WARNING, "can't set rlimit data size: %m");
	}

	while ((ch = getopt(argc, argv, "cdfN:vz")) != -1)
		switch(ch) {
		case 'c':
			clear = 1;
			break;
		case 'd':		/* Not documented. */
		case 'v':
			verbose = 1;
			break;
		case 'f':
			force = 1;
			break;
		case 'N':
			kernel = optarg;
			break;
		case 'z':
			zcompress = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (!clear) {
		if (argc != 1)
			usage();
		dirn = argv[0];
	}

	(void)time(&now);
	kmem_setup();

	if (pledge("stdio rpath wpath cpath", NULL) == -1) {
		syslog(LOG_ERR, "pledge: %m");
		exit(1);
	}

	if (clear) {
		clear_dump();
		return (0);
	}

	if (!dump_exists() && !force)
		return (1);

	check_kmem();

	if (panicstr)
		syslog(LOG_ALERT, "reboot after panic: %s", panic_mesg);
	else
		syslog(LOG_ALERT, "reboot");

	if ((!get_crashtime() || !check_space()) && !force)
		return (1);

	save_core();

	clear_dump();
	return (0);
}

char	*dump_sys;

void
kmem_setup(void)
{
	kvm_t	*kd_kern;
	char	errbuf[_POSIX2_LINE_MAX];
	int	i, hdrsz;

	/*
	 * Some names we need for the currently running system, others for
	 * the system that was running when the dump was made.  The values
	 * obtained from the current system are used to look for things in
	 * /dev/kmem that cannot be found in the dump_sys namelist, but are
	 * presumed to be the same (since the disk partitions are probably
	 * the same!)
	 */
	kd_kern = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
	if (kd_kern == NULL) {
		syslog(LOG_ERR, "%s: kvm_openfiles: %s", _PATH_UNIX, errbuf);
		exit(1);
	}
	if (kvm_nlist(kd_kern, current_nl) == -1)
		syslog(LOG_ERR, "%s: kvm_nlist: %s", _PATH_UNIX,
			kvm_geterr(kd_kern));

	for (i = 0; cursyms[i] != -1; i++)
		if (current_nl[cursyms[i]].n_value == 0) {
			syslog(LOG_ERR, "%s: %s not in namelist",
			    _PATH_UNIX, current_nl[cursyms[i]].n_name);
			exit(1);
		}

	(void)KREAD(kd_kern, current_nl[X_DUMPDEV].n_value, &dumpdev);
	if (dumpdev == NODEV) {
		syslog(LOG_WARNING, "no core dump (no dumpdev)");
		exit(1);
	}
	(void)KREAD(kd_kern, current_nl[X_DUMPLO].n_value, &dumplo);
	dumpoff = (off_t)dumplo * DEV_BSIZE;
	if (verbose)
		(void)printf("dumpoff = %lld (%ld * %d)\n",
		    (long long)dumpoff, dumplo, DEV_BSIZE);
	(void) KREAD(kd_kern, current_nl[X_DUMPMAG].n_value, &dumpmag);

	if (kernel == NULL) {
		if (kvm_read(kd_kern, current_nl[X_VERSION].n_value,
		    vers, sizeof(vers)) == -1) {
			syslog(LOG_ERR, "%s: kvm_read: version misread", _PATH_UNIX);
			exit(1);
		}
		vers[sizeof(vers) - 1] = '\0';
	}

	ddname = find_dev(dumpdev, S_IFBLK);
	dumpfd = open(ddname, O_RDWR);
	if (dumpfd == -1) {
		syslog(LOG_ERR, "%s: %m", ddname);
		exit(1);
	}


	dump_sys = kernel ? kernel : _PATH_UNIX;
	kd_dump = kvm_openfiles(kernel, ddname, NULL, O_RDWR, errbuf);
	if (kd_dump == NULL) {
		syslog(LOG_ERR, "%s: kvm_openfiles: %s", dump_sys, errbuf);
		exit(1);
	}

	if (kvm_nlist(kd_dump, dump_nl) == -1)
		syslog(LOG_ERR, "%s: kvm_nlist: %s", dump_sys,
			kvm_geterr(kd_dump));

	for (i = 0; dumpsyms[i] != -1; i++)
		if (dump_nl[dumpsyms[i]].n_value == 0) {
			syslog(LOG_ERR, "%s: %s not in namelist",
			    dump_sys, dump_nl[dumpsyms[i]].n_name);
			exit(1);
		}
	hdrsz = kvm_dump_mkheader(kd_dump, dumpoff);
	if (hdrsz == -1) {
		if(verbose)
			syslog(LOG_ERR, "%s: kvm_dump_mkheader: %s", dump_sys,
				kvm_geterr(kd_dump));
		syslog(LOG_WARNING, "no core dump");
		exit(1);
	}
	dumpoff += hdrsz;
	kvm_close(kd_kern);
}

void
check_kmem(void)
{
	char	*cp;
	int	panicloc;
	char core_vers[VERSIONSIZE];

	if (kvm_read(kd_dump, dump_nl[X_VERSION].n_value, core_vers,
	    sizeof(core_vers)) != sizeof(core_vers)) {
		syslog(LOG_ERR, "%s: kvm_read: version misread", dump_sys);
		exit(1);
	}
	core_vers[sizeof(core_vers) - 1] = '\0';

	if (strcmp(vers, core_vers) && kernel == 0) {
		vers[strcspn(vers, "\n")] = '\0';
		core_vers[strcspn(core_vers, "\n")] = '\0';

		syslog(LOG_WARNING,
		    "warning: %s version mismatch:\n\t%s\nand\t%s\n",
		    _PATH_UNIX, vers, core_vers);
	}

	(void)KREAD(kd_dump, dump_nl[X_PANICSTR].n_value, &panicstr);
	if (panicstr) {
		char	c, visout[5];
		size_t	vislen;

		cp       = panic_mesg;
		panicloc = panicstr;
		for (;;) {
			if (KREAD(kd_dump, panicloc, &c) != 0 || c == '\0')
				break;
			panicloc++;

			vis(visout, c, VIS_SAFE|VIS_NOSLASH, 0);
			vislen = strlen(visout);
			if (cp - panic_mesg + vislen >= sizeof(panic_mesg))
				break;
			strlcat(cp, visout,
			    panic_mesg + sizeof panic_mesg - cp);
			cp += strlen(cp);
		}
	}
}

int
dump_exists(void)
{
	u_long newdumpmag;

	(void)KREAD(kd_dump, dump_nl[X_DUMPMAG].n_value, &newdumpmag);

	/* Read the dump size. */
	(void)KREAD(kd_dump, dump_nl[X_DUMPSIZE].n_value, &dumppages);
	dumpsize = (u_long)dumppages * getpagesize();

	/*
	 * Return zero if core dump doesn't seem to be there and note
	 * it for syslog.  This check and return happens after the dump size
	 * is read, so dumpsize is whether or not the core is valid (for -f).
	 */
	if (newdumpmag != dumpmag) {
		if (verbose)
			syslog(LOG_WARNING,
			    "magic number mismatch (%lx != %lx)",
			    newdumpmag, dumpmag);
		syslog(LOG_WARNING, "no core dump");
		return (0);
	}
	return (1);
}

void
clear_dump(void)
{
	if (kvm_dump_inval(kd_dump) == -1)
		syslog(LOG_ERR, "%s: kvm_clear_dump: %s", ddname,
			kvm_geterr(kd_dump));

}

char buf[1024 * 1024];

void
save_core(void)
{
	FILE *fp;
	int bounds, ifd, nr, nw, ofd = -1;
	char *rawp, path[PATH_MAX];
	mode_t um;

	um = umask(S_IRWXG|S_IRWXO);

	/*
	 * Get the current number and update the bounds file.  Do the update
	 * now, because we may fail later and don't want to overwrite anything.
	 */
	(void)snprintf(path, sizeof(path), "%s/bounds", dirn);
	if ((fp = fopen(path, "r")) == NULL)
		goto err1;
	if (fgets(buf, sizeof(buf), fp) == NULL) {
		if (ferror(fp))
err1:			syslog(LOG_WARNING, "%s: %s", path, strerror(errno));
		bounds = 0;
	} else {
		const char *errstr = NULL;
		char *p;

		if ((p = strchr(buf, '\n')) != NULL)
			*p = '\0';
		bounds = strtonum(buf, 0, INT_MAX, &errstr);
		if (errstr)
			syslog(LOG_WARNING, "bounds was corrupt: %s", errstr);
	}
	if (fp != NULL)
		(void)fclose(fp);
	if ((fp = fopen(path, "w")) == NULL)
		syslog(LOG_ERR, "%s: %m", path);
	else {
		(void)fprintf(fp, "%d\n", bounds + 1);
		(void)fclose(fp);
	}

	/* Create the core file. */
	(void)snprintf(path, sizeof(path), "%s%s.%d.core%s",
	    dirn, _PATH_UNIX, bounds, zcompress ? ".Z" : "");
	if (zcompress) {
		if ((fp = zopen(path, "w", 0)) == NULL) {
			syslog(LOG_ERR, "%s: %s", path, strerror(errno));
			exit(1);
		}
	} else {
		ofd = open(path, O_WRONLY | O_CREAT | O_TRUNC,
		    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
		if (ofd == -1) {
			syslog(LOG_ERR, "%s: %m", path);
			exit(1);
		}
		
		fp  = fdopen(ofd, "w");
		if (fp == NULL) {
			syslog(LOG_ERR, "%s: fdopen: %s", path, strerror(errno));
			exit(1);
		}
	}

	/* Open the raw device. */
	rawp = rawname(ddname);
	if ((ifd = open(rawp, O_RDONLY)) == -1) {
		syslog(LOG_WARNING, "%s: %m; using block device", rawp);
		ifd = dumpfd;
	}

	/* Seek to the start of the core. */
	if (lseek(ifd, dumpoff, SEEK_SET) == -1) {
		syslog(LOG_ERR, "lseek: %m");
		exit(1);
	}

	if (kvm_dump_wrtheader(kd_dump, fp, dumpsize) == -1) {
		syslog(LOG_ERR, "kvm_dump_wrtheader: %s : %s", path,
			kvm_geterr(kd_dump));
		exit(1);
	}

	/* Copy the core file. */
	syslog(LOG_NOTICE, "writing %score to %s",
	    zcompress ? "compressed " : "", path);
	for (; dumpsize != 0; dumpsize -= nr) {
		(void)printf("%8luK\r", dumpsize / 1024);
		(void)fflush(stdout);
		nr = read(ifd, buf, MINIMUM(dumpsize, sizeof(buf)));
		if (nr <= 0) {
			if (nr == 0)
				syslog(LOG_WARNING,
				    "WARNING: EOF on dump device");
			else
				syslog(LOG_ERR, "%s: %m", rawp);
			goto err2;
		}
		nw = fwrite(buf, 1, nr, fp);
		if (nw != nr) {
			syslog(LOG_ERR, "%s: %s",
			    path, strerror(nw == 0 ? EIO : errno));
err2:			syslog(LOG_WARNING,
			    "WARNING: core may be incomplete");
			(void)printf("\n");
			exit(1);
		}
	}
	(void)close(ifd);
	(void)fclose(fp);

	/* Copy the kernel. */
	ifd = open(kernel ? kernel : _PATH_UNIX, O_RDONLY);
	if (ifd == -1) {
		syslog(LOG_ERR, "%s: %m", kernel ? kernel : _PATH_UNIX);
		exit(1);
	}
	(void)snprintf(path, sizeof(path), "%s%s.%d%s",
	    dirn, _PATH_UNIX, bounds, zcompress ? ".Z" : "");
	if (zcompress) {
		if ((fp = zopen(path, "w", 0)) == NULL) {
			syslog(LOG_ERR, "%s: %s", path, strerror(errno));
			exit(1);
		}
	} else {
		ofd = open(path, O_WRONLY | O_CREAT | O_TRUNC,
		    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
		if (ofd == -1) {
			syslog(LOG_ERR, "%s: %m", path);
			exit(1);
		}
	}
	syslog(LOG_NOTICE, "writing %skernel to %s",
	    zcompress ? "compressed " : "", path);
	while ((nr = read(ifd, buf, sizeof(buf))) > 0) {
		if (zcompress)
			nw = fwrite(buf, 1, nr, fp);
		else
			nw = write(ofd, buf, nr);
		if (nw != nr) {
			syslog(LOG_ERR, "%s: %s",
			    path, strerror(nw == 0 ? EIO : errno));
			syslog(LOG_WARNING,
			    "WARNING: kernel may be incomplete");
			exit(1);
		}
	}
	if (nr < 0) {
		syslog(LOG_ERR, "%s: %s",
		    kernel ? kernel : _PATH_UNIX, strerror(errno));
		syslog(LOG_WARNING,
		    "WARNING: kernel may be incomplete");
		exit(1);
	}
	if (zcompress)
		(void)fclose(fp);
	else
		(void)close(ofd);
	(void)umask(um);
}

char *
find_dev(dev_t dev, int type)
{
	DIR *dfd;
	struct dirent *dir;
	struct stat sb;
	char *dp, devname[PATH_MAX];

	if ((dfd = opendir(_PATH_DEV)) == NULL) {
		syslog(LOG_ERR, "%s: %s", _PATH_DEV, strerror(errno));
		exit(1);
	}
	(void)strlcpy(devname, _PATH_DEV, sizeof devname);
	while ((dir = readdir(dfd))) {
		(void)strlcpy(devname + sizeof(_PATH_DEV) - 1, dir->d_name,
		    sizeof devname - (sizeof(_PATH_DEV) - 1));
		if (lstat(devname, &sb)) {
			syslog(LOG_ERR, "%s: %s", devname, strerror(errno));
			continue;
		}
		if ((sb.st_mode & S_IFMT) != type)
			continue;
		if (dev == sb.st_rdev) {
			closedir(dfd);
			if ((dp = strdup(devname)) == NULL) {
				syslog(LOG_ERR, "%s", strerror(errno));
				exit(1);
			}
			return (dp);
		}
	}
	closedir(dfd);
	syslog(LOG_ERR, "can't find device %d/%d", major(dev), minor(dev));
	exit(1);
}

char *
rawname(char *s)
{
	char *sl, name[PATH_MAX];

	if ((sl = strrchr(s, '/')) == NULL || sl[1] == '0') {
		syslog(LOG_ERR,
		    "can't make raw dump device name from %s", s);
		return (s);
	}
	(void)snprintf(name, sizeof(name), "%.*s/r%s", (int)(sl - s), s, sl + 1);
	if ((sl = strdup(name)) == NULL) {
		syslog(LOG_ERR, "%s", strerror(errno));
		exit(1);
	}
	return (sl);
}

int
get_crashtime(void)
{
	time_t dumptime;			/* Time the dump was taken. */

	(void)KREAD(kd_dump, dump_nl[X_TIME].n_value, &dumptime);
	if (dumptime == 0) {
		if (verbose)
			syslog(LOG_ERR, "dump time is zero");
		return (0);
	}
	(void)printf("savecore: system went down at %s", ctime(&dumptime));
#define	SECSPERDAY	(24 * 60 * 60)
#define	LEEWAY		(7 * SECSPERDAY)
	if (dumptime < now - LEEWAY || dumptime > now + LEEWAY) {
		(void)printf("dump time is unreasonable\n");
		return (0);
	}
	return (1);
}

int
check_space(void)
{
	FILE *fp;
	char *tkernel;
	off_t minfree, spacefree, kernelsize, needed;
	struct stat st;
	struct statfs fsbuf;
	char buf[100], path[PATH_MAX];
	int fd;

	tkernel = kernel ? kernel : _PATH_UNIX;
	if (stat(tkernel, &st) < 0) {
		syslog(LOG_ERR, "%s: %m", tkernel);
		exit(1);
	}
	kernelsize = st.st_blocks * S_BLKSIZE;
	if ((fd = open(dirn, O_RDONLY, 0)) < 0 || fstatfs(fd, &fsbuf) < 0) {
		syslog(LOG_ERR, "%s: %m", dirn);
		exit(1);
	}
	close(fd);
	spacefree = ((off_t)fsbuf.f_bavail * fsbuf.f_bsize) / 1024;

	(void)snprintf(path, sizeof(path), "%s/minfree", dirn);
	if ((fp = fopen(path, "r")) == NULL)
		minfree = 0;
	else {
		if (fgets(buf, sizeof(buf), fp) == NULL)
			minfree = 0;
		else {
			const char *errstr;
			char *p;

			if ((p = strchr(buf, '\n')) != NULL)
				*p = '\0';
			minfree = strtonum(buf, 0, LLONG_MAX, &errstr);
			if (errstr)
				syslog(LOG_WARNING,
				    "minfree was corrupt: %s", errstr);
		}
		(void)fclose(fp);
	}

	needed = (dumpsize + kernelsize) / 1024;
	if (minfree > 0 && spacefree - needed < minfree) {
		syslog(LOG_WARNING,
		    "no dump, not enough free space on device");
		return (0);
	}
	if (spacefree - needed < minfree)
		syslog(LOG_WARNING,
		    "dump performed, but free space threshold crossed");
	return (1);
}

void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-cfvz] [-N system] directory\n",
		__progname);
	exit(1);
}
@


1.56
log
@Drop support for the undocumented second argument (same as -N option)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.55 2015/10/18 03:17:48 deraadt Exp $	*/
d92 2
d110 1
a110 1
char	vers[1024];
d299 1
a299 1
	char core_vers[1024];
@


1.55
log
@after kmem is open and setup, pledge "stdio rpath wpath cpath"
seems to be working.  commiting to get feedback from people who crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.53 2015/04/26 01:23:19 guenther Exp $	*/
d164 1
a164 1
		if (argc != 1 && argc != 2)
a167 2
	if (argc == 2)
		kernel = argv[1];
@


1.54
log
@Collapse some strange programmer style with too much abstraction.
@
text
@d174 5
@


1.53
log
@Fix glitches in previous commit: strip the \n and only complain on failure

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.52 2015/04/18 18:28:37 deraadt Exp $	*/
a114 1
int	 Create(char *, int);
a118 2
void	 Lseek(int, off_t, int);
int	 Open(char *, int rw);
d253 6
a258 1
	dumpfd = Open(ddname, O_RDWR);
d422 7
a428 1
		ofd = Create(path, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
d444 4
a447 1
	Lseek(ifd, dumpoff, SEEK_SET);
d484 5
a488 1
	ifd = Open(kernel ? kernel : _PATH_UNIX, O_RDONLY);
d496 8
a503 2
	} else
		ofd = Create(path, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
a661 37
}

int
Open(char *name, int rw)
{
	int fd;

	if ((fd = open(name, rw, 0)) < 0) {
		syslog(LOG_ERR, "%s: %m", name);
		exit(1);
	}
	return (fd);
}

void
Lseek(int fd, off_t off, int flag)
{
	off_t ret;

	ret = lseek(fd, off, flag);
	if (ret == -1) {
		syslog(LOG_ERR, "lseek: %m");
		exit(1);
	}
}

int
Create(char *file, int mode)
{
	int fd;

	fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, mode);
	if (fd < 0) {
		syslog(LOG_ERR, "%s: %m", file);
		exit(1);
	}
	return (fd);
@


1.52
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.51 2015/03/15 00:41:27 millert Exp $	*/
d393 2
a394 1
		const char *errstr;
d396 2
d619 1
d621 2
d624 3
a626 2
			syslog(LOG_WARNING,
			    "minfree was corrupt: %s", errstr);
@


1.51
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.50 2015/01/16 06:40:00 deraadt Exp $	*/
a36 1
#include <sys/types.h>
d392 7
a398 2
	} else
		bounds = atoi(buf);
d614 7
a620 2
		else
			minfree = atoi(buf);
@


1.50
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.49 2013/06/03 02:49:42 tedu Exp $	*/
a48 1
#include <tzfile.h>
d571 2
a572 1
#define	LEEWAY	(7 * SECSPERDAY)
@


1.49
log
@dependent clause requires a subject (comment grammar)
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.48 2009/10/27 23:59:34 deraadt Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d56 2
d378 1
a378 1
	char *rawp, path[MAXPATHLEN];
d444 1
a444 1
		nr = read(ifd, buf, MIN(dumpsize, sizeof(buf)));
d512 1
a512 1
	char *dp, devname[MAXPATHLEN];
d545 1
a545 1
	char *sl, name[MAXPATHLEN];
d588 1
a588 1
	char buf[100], path[MAXPATHLEN];
@


1.48
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.47 2009/06/20 00:15:14 millert Exp $	*/
d101 5
a105 5
char	*ddname;			/* name of dump device */
dev_t	dumpdev;			/* dump device */
int	dumpfd;				/* read/write descriptor on block dev */
kvm_t	*kd_dump;			/* kvm descriptor on block dev	*/
time_t	now;				/* current date */
d345 1
a345 1
	 * Return zero if core dump doesn't seem to be there, and note
d383 1
a383 1
	 * now, because may fail later and don't want to overwrite anything.
@


1.47
log
@If the user didn't specify a kernel, pass in NULL to kvm_openfiles()
so it can try /dev/ksyms.  The first call to kvm_openfiles()
was already correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.46 2009/01/17 13:48:50 miod Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1986, 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)savecore.c	8.3 (Berkeley) 1/2/94";
#else
static char rcsid[] = "$OpenBSD: savecore.c,v 1.46 2009/01/17 13:48:50 miod Exp $";
#endif
#endif /* not lint */
@


1.46
log
@Use different variables for the dump offset in blocks and the dump offset
in bytes; this allows us to get rid of many off_t casts, and ensures
proper operation on very large swap partitions on 32 bit machines.

From Pierre Riteau.
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.45 2009/01/02 16:17:53 miod Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.45 2009/01/02 16:17:53 miod Exp $";
d273 1
a273 2

	kd_dump = kvm_openfiles(dump_sys, ddname, NULL, O_RDWR, errbuf);
@


1.45
log
@Handle kernel core files larger than 2GB; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.44 2007/09/14 14:29:20 chl Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.44 2007/09/14 14:29:20 chl Exp $";
d107 5
a111 4
long	dumplo;				/* where dump starts on dumpdev */
u_long	dumpmag;			/* magic number in dump */
int	dumppages;			/* amount of memory dumped (in pages) */
u_long	dumpsize;			/* amount of memory dumped */
d254 1
a254 1
	dumplo *= DEV_BSIZE;
d256 2
a257 2
		(void)printf("dumplo = %ld (%ld * %d)\n",
		    dumplo, dumplo / DEV_BSIZE, DEV_BSIZE);
d290 1
a290 1
	hdrsz = kvm_dump_mkheader(kd_dump, (off_t)dumplo);
d298 1
a298 1
	dumplo += hdrsz;
d443 1
a443 1
	Lseek(ifd, (off_t)dumplo, SEEK_SET);
d455 1
a455 1
		(void)printf("%8ldK\r", dumpsize / 1024);
@


1.44
log
@remove some warnings:
unused variable `variable'
`variable' might be used uninitialized in this function

ok gilles@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.43 2007/09/11 15:25:14 gilles Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.43 2007/09/11 15:25:14 gilles Exp $";
d109 2
a110 1
int	dumpsize;			/* amount of memory dumped */
d355 2
a356 2
	(void)KREAD(kd_dump, dump_nl[X_DUMPSIZE].n_value, &dumpsize);
	dumpsize *= getpagesize();
d453 2
a454 2
	for (; dumpsize > 0; dumpsize -= nr) {
		(void)printf("%8dK\r", dumpsize / 1024);
@


1.43
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.42 2005/01/07 21:57:10 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.42 2005/01/07 21:57:10 millert Exp $";
a314 2
		char *p;

@


1.42
log
@Use fstatfs(), not statfs() to determine free space so if /var/crash
is a link we follow it.  OK deraadt@@ jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.41 2004/09/15 18:52:29 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.41 2004/09/15 18:52:29 deraadt Exp $";
d317 3
a319 6
		p = strchr(vers, '\n');
		if (p)
			*p = '\0';
		p = strchr(core_vers, '\n');
		if (p)
			*p = '\0';
@


1.41
log
@removed unused; avoid aliasing to libc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.40 2004/07/02 13:09:04 tholo Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.40 2004/07/02 13:09:04 tholo Exp $";
d605 1
d613 1
a613 1
	if (statfs(dirn, &fsbuf) < 0) {
d617 1
@


1.40
log
@Use "time_second" instead of "time" now that time handling in the kernel
has changed.

ok art@@ millert@@ marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.39 2004/01/13 21:03:34 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.39 2004/01/13 21:03:34 otto Exp $";
d66 1
d122 1
a122 1
int	clear, compress, force, verbose;	/* flags */
a136 1
void	 Write(int, void *, size_t);
d169 1
a169 1
			compress = 1;
d423 2
a424 2
	    dirn, _PATH_UNIX, bounds, compress ? ".Z" : "");
	if (compress) {
d456 1
a456 1
	    compress ? "compressed " : "", path);
d485 2
a486 2
	    dirn, _PATH_UNIX, bounds, compress ? ".Z" : "");
	if (compress) {
d494 1
a494 1
	    compress ? "compressed " : "", path);
d496 1
a496 1
		if (compress)
d515 1
a515 1
	if (compress)
a675 11
}

void
Write(int fd, void *bp, size_t size)
{
	int n;

	if ((n = write(fd, bp, size)) < size) {
		syslog(LOG_ERR, "write: %s", strerror(n == -1 ? errno : EIO));
		exit(1);
	}
@


1.39
log
@Use correct type for magic number.

ok marc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.38 2003/12/28 04:09:13 espie Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.38 2003/12/28 04:09:13 espie Exp $";
d80 1
a80 1
	{ "_time" },
d97 1
a97 1
	{ "_time" },
@


1.38
log
@zap bizarre log() prototype.
Doesn't even change the resulting binary (thank Ian Darwin for that idea)
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.37 2003/11/15 20:25:17 marc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.37 2003/11/15 20:25:17 marc Exp $";
d354 1
a354 1
	int newdumpmag;
d369 2
a370 1
			syslog(LOG_WARNING, "magic number mismatch (%x != %x)",
@


1.37
log
@fix savecore on big endian 64 bit arches.  OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.36 2003/07/29 18:38:36 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.36 2003/07/29 18:38:36 deraadt Exp $";
a130 1
void	 log(int, char *, ...);
@


1.36
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.35 2003/06/10 16:41:29 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.35 2003/06/10 16:41:29 deraadt Exp $";
d107 1
a107 1
int	dumpmag;			/* magic number in dump */
@


1.35
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.34 2003/06/02 20:06:17 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.34 2003/06/02 20:06:17 millert Exp $";
d222 1
a222 1
	
d239 1
a239 1
	
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.33 2003/04/08 00:12:00 mickey Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.33 2003/04/08 00:12:00 mickey Exp $";
d616 1
a616 1
 	spacefree = ((off_t)fsbuf.f_bavail * fsbuf.f_bsize) / 1024;
d630 1
a630 1
 	if (minfree > 0 && spacefree - needed < minfree) {
@


1.33
log
@fix null deref in error syslogging
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.32 2003/04/07 23:04:06 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.32 2003/04/07 23:04:06 deraadt Exp $";
@


1.32
log
@strlcat, and it counted srclen, not dstlen; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.31 2002/07/03 22:32:33 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.31 2002/07/03 22:32:33 deraadt Exp $";
d266 1
a266 1
			syslog(LOG_ERR, "%s: kvm_read: version misread", dump_sys);
@


1.31
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.30 2002/05/22 20:09:36 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.30 2002/05/22 20:09:36 deraadt Exp $";
d349 3
a351 2
			strcat(cp, visout);
			cp += vislen;
@


1.30
log
@oops, backwards length check; moritz@@jodeit.org
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.29 2002/05/22 08:21:02 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.29 2002/05/22 08:21:02 deraadt Exp $";
d141 1
a141 1
void	 Write(int, void *, int);
d144 1
a144 3
main(argc, argv)
	int argc;
	char *argv[];
d221 1
a221 1
kmem_setup()
d306 1
a306 1
check_kmem()
d356 1
a356 1
dump_exists()
d382 1
a382 1
clear_dump()
d393 1
a393 1
save_core()
d526 1
a526 3
find_dev(dev, type)
	dev_t dev;
	int type;
d562 1
a562 2
rawname(s)
	char *s;
d580 1
a580 1
get_crashtime()
d600 1
a600 1
check_space()
d645 1
a645 3
Open(name, rw)
	char *name;
	int rw;
d657 1
a657 3
Lseek(fd, off, flag)
	int fd, flag;
	off_t off;
d669 1
a669 3
Create(file, mode)
	char *file;
	int mode;
d682 1
a682 3
Write(fd, bp, size)
	int fd, size;
	void *bp;
d693 1
a693 1
usage()
@


1.29
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.28 2002/02/16 21:27:37 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.28 2002/02/16 21:27:37 millert Exp $";
d544 1
a544 1
		    sizeof devname + sizeof(_PATH_DEV) - 1);
@


1.28
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.27 2001/11/05 07:39:17 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.27 2001/11/05 07:39:17 mpech Exp $";
d535 1
a535 1
	char *dp, devname[MAXPATHLEN + 1];
d541 1
a541 1
	(void)strcpy(devname, _PATH_DEV);
d543 2
a544 1
		(void)strcpy(devname + sizeof(_PATH_DEV) - 1, dir->d_name);
@


1.27
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.26 2001/07/07 18:26:21 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.26 2001/07/07 18:26:21 deraadt Exp $";
d73 1
a73 1
extern FILE *zopen __P((const char *fname, const char *mode, int bits));
d127 15
a141 15
void	 check_kmem __P((void));
int	 check_space __P((void));
void	 clear_dump __P((void));
int	 Create __P((char *, int));
int	 dump_exists __P((void));
char	*find_dev __P((dev_t, int));
int	 get_crashtime __P((void));
void	 kmem_setup __P((void));
void	 log __P((int, char *, ...));
void	 Lseek __P((int, off_t, int));
int	 Open __P((char *, int rw));
char	*rawname __P((char *s));
void	 save_core __P((void));
void	 usage __P((void));
void	 Write __P((int, void *, int));
@


1.26
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.25 2001/06/20 23:12:48 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.25 2001/06/20 23:12:48 niklas Exp $";
d310 2
a311 2
	register char	*cp;
	register int	panicloc;
d397 2
a398 2
	register FILE *fp;
	register int bounds, ifd, nr, nw, ofd = -1;
d529 2
a530 2
	register dev_t dev;
	register int type;
d532 1
a532 1
	register DIR *dfd;
d606 1
a606 1
	register FILE *fp;
d681 1
a681 1
	register int fd;
@


1.25
log
@circumvent a 32-bit integer arithmetic overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.24 2001/06/04 14:59:49 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.24 2001/06/04 14:59:49 mickey Exp $";
d253 1
a253 1
	KREAD(kd_kern, current_nl[X_DUMPDEV].n_value, &dumpdev);
d258 1
a258 1
	KREAD(kd_kern, current_nl[X_DUMPLO].n_value, &dumplo);
d261 1
a261 1
		(void)printf("dumplo = %d (%d * %d)\n",
d263 1
a263 1
	KREAD(kd_kern, current_nl[X_DUMPMAG].n_value, &dumpmag);
d335 1
a335 1
	KREAD(kd_dump, dump_nl[X_PANICSTR].n_value, &panicstr);
d362 1
a362 1
	KREAD(kd_dump, dump_nl[X_DUMPMAG].n_value, &newdumpmag);
d365 1
a365 1
	KREAD(kd_dump, dump_nl[X_DUMPSIZE].n_value, &dumpsize);
d398 1
a398 1
	register int bounds, ifd, nr, nw, ofd;
d575 1
a575 1
	(void)snprintf(name, sizeof(name), "%.*s/r%s", sl - s, s, sl + 1);
d588 1
a588 1
	KREAD(kd_dump, dump_nl[X_TIME].n_value, &dumptime);
@


1.24
log
@return from main() don't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.23 2001/01/18 00:18:38 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.23 2001/01/18 00:18:38 deraadt Exp $";
d623 1
a623 1
 	spacefree = (fsbuf.f_bavail * fsbuf.f_bsize) / 1024;
@


1.23
log
@crank "K to go" field to 8 digits; lukem@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.22 2000/10/25 23:37:38 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.22 2000/10/25 23:37:38 deraadt Exp $";
d198 1
a198 1
		exit(0);
d202 1
a202 1
		exit(1);
d212 1
a212 1
		exit(1);
d217 1
a217 1
	exit(0);
@


1.22
log
@various savecore/kvm fixes; gluk@@ptci.ru, PR#1461
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.21 2000/09/18 03:45:27 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.21 2000/09/18 03:45:27 deraadt Exp $";
d463 1
a463 1
		(void)printf("%6dK\r", dumpsize / 1024);
@


1.21
log
@avoid alias against libc symbol dirname (binutils is so great)
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.20 2000/05/31 17:09:17 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.20 2000/05/31 17:09:17 millert Exp $";
d297 4
a300 2
		syslog(LOG_ERR, "%s: kvm_dump_mkheader: %s", dump_sys,
			kvm_geterr(kd_dump));
@


1.20
log
@Cleaner loop structure when reading panic string from the core image.
We now check the return value of KREAD() which may solve PR 1254.
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.19 1999/08/16 18:38:50 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.19 1999/08/16 18:38:50 art Exp $";
d115 1
a115 1
char	*dirname;			/* directory to save dumps in */
d188 1
a188 1
		dirname = argv[0];
d406 1
a406 1
	(void)snprintf(path, sizeof(path), "%s/bounds", dirname);
d426 1
a426 1
	    dirname, _PATH_UNIX, bounds, compress ? ".Z" : "");
d488 1
a488 1
	    dirname, _PATH_UNIX, bounds, compress ? ".Z" : "");
d617 2
a618 2
	if (statfs(dirname, &fsbuf) < 0) {
		syslog(LOG_ERR, "%s: %m", dirname);
d623 1
a623 1
	(void)snprintf(path, sizeof(path), "%s/minfree", dirname);
@


1.19
log
@add a missing strerror. (there was already a %s in the format string)
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.18 1999/07/01 15:41:59 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.18 1999/07/01 15:41:59 deraadt Exp $";
d336 1
d340 3
a342 2
		do {
			KREAD(kd_dump, panicloc, &c);
d346 6
a351 6
			if (c && cp + strlen(visout) <
			    &panic_mesg[sizeof(panic_mesg)]) {
				strcat(cp, visout);
				cp += strlen(visout);
			}
		} while (c && cp < &panic_mesg[sizeof(panic_mesg)]);
@


1.19.4.1
log
@Pull in patch from current:
Fix (millert):
Cleaner loop structure when reading panic string from the core image.
We now check the return value of KREAD() which may solve PR 1254.
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.19 1999/08/16 18:38:50 art Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.19 1999/08/16 18:38:50 art Exp $";
a335 1
		size_t	vislen;
d339 2
a340 3
		for (;;) {
			if (KREAD(kd_dump, panicloc, &c) != 0 || c == '\0')
				break;
d344 6
a349 6
			vislen = strlen(visout);
			if (cp - panic_mesg + vislen >= sizeof(panic_mesg))
				break;
			strcat(cp, visout);
			cp += vislen;
		}
@


1.18
log
@extra fclose(); ronald@@chersonese.com
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.17 1999/02/23 07:40:29 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.17 1999/02/23 07:40:29 deraadt Exp $";
d434 1
a434 1
			syslog(LOG_ERR, "%s: fdopen: %s", path);
@


1.17
log
@do not print multiple \n in kernel version number printout,
and vis the panicstr
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.16 1998/10/04 16:36:13 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.16 1998/10/04 16:36:13 millert Exp $";
a420 1
	(void)fclose(fp);
@


1.16
log
@increase data size
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.15 1998/09/24 06:24:20 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: savecore.c,v 1.26 1996/03/18 21:16:05 leo Exp $";
d71 1
d319 9
a327 1
	if (strcmp(vers, core_vers) && kernel == 0)
d331 1
d335 2
d340 1
a340 1
			KREAD(kd_dump, panicloc, cp);
d342 8
a349 1
		} while (*cp++ && cp < &panic_mesg[sizeof(panic_mesg)]);
@


1.15
log
@Back out gzip changes, they will not make 2.4
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.14 1998/09/05 16:33:25 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$NetBSD: savecore.c,v 1.26 1996/03/18 21:16:05 leo Exp $";
d55 1
d57 1
d147 1
d151 7
@


1.14
log
@We can now savecore with a gzipped kernel:
 o Use new gzip-aware nlist
 o If kernel cannot be found, use kernel.gz if it exists
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.13 1998/08/10 20:57:46 mickey Exp $	*/
a216 1
	struct stat st;
a266 12

	/* If no dumpsys, check for dumpsys.gz */
	if (stat(dump_sys, &st) == -1) {
		char *gzpath;

		asprintf(&gzpath, "%s.gz", dump_sys);
		if (stat(gzpath, &st) == -1) {
			syslog(LOG_ERR, "%s: %m", dump_sys);
			exit(1);
		}
		kernel = dump_sys = gzpath;
	}
@


1.13
log
@fix usage() string; use __progname
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.12 1998/07/13 02:11:23 millert Exp $	*/
d217 1
d268 12
@


1.12
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.11 1998/07/05 19:22:35 deraadt Exp $	*/
d675 3
a677 1
	fprintf(stderr, "usage: savecore [-cfvz] [-N system] directory");
@


1.11
log
@fix bugs; seen by dima
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.10 1998/06/29 22:43:58 deraadt Exp $	*/
d419 1
a419 1
	Lseek(ifd, (off_t)dumplo, L_SET);
@


1.10
log
@do not (void)kvm_read(...)
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.9 1998/03/25 23:38:52 deraadt Exp $	*/
d209 2
a216 1
	char	*dump_sys;
d302 1
a302 1
	    sizeof(core_vers) != sizeof(core_vers))
@


1.9
log
@usage to stderr, not syslog
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.8 1996/12/29 12:21:26 graichen Exp $	*/
d254 5
a258 2
		(void)kvm_read(kd_kern, current_nl[X_VERSION].n_value,
			vers, sizeof(vers));
d300 5
a304 2
	(void)kvm_read(kd_dump, dump_nl[X_VERSION].n_value, core_vers,
		sizeof(core_vers));
@


1.8
log
@remove one / from the printf of the filenames (_PATH_UNIX begings with a
slash - /bsd so we don't need an extra slash there)
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.7 1996/10/15 10:17:32 deraadt Exp $	*/
d668 1
a668 1
	(void)syslog(LOG_ERR, "usage: savecore [-cfvz] [-N system] directory");
@


1.7
log
@umask for writes; from joerg@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.6 1996/08/20 04:22:40 deraadt Exp $	*/
d388 1
a388 1
	(void)snprintf(path, sizeof(path), "%s/%s.%d.core%s",
d450 1
a450 1
	(void)snprintf(path, sizeof(path), "%s/%s.%d%s",
@


1.6
log
@dump one NOT TWO headers; from osymh@@gemini.oscs.montana.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.5 1996/06/23 13:16:21 deraadt Exp $	*/
d360 3
d485 1
@


1.5
log
@use _PATH_UNIX for kernel name
@
text
@d1 1
a1 1
/*	$OpenBSD: savecore.c,v 1.3 1996/03/21 00:16:36 niklas Exp $	*/
a409 6

	if (kvm_dump_wrtheader(kd_dump, fp, dumpsize) == -1) {
		syslog(LOG_ERR, "kvm_dump_wrtheader: %s : %s", path,
			kvm_geterr(kd_dump));
		exit(1);
	}
@


1.4
log
@sync to netbsd 960418
@
text
@d385 2
a386 2
	(void)snprintf(path, sizeof(path), "%s/bsd.%d.core%s",
	    dirname, bounds, compress ? ".Z" : "");
d453 2
a454 2
	(void)snprintf(path, sizeof(path), "%s/bsd.%d%s",
	    dirname, bounds, compress ? ".Z" : "");
@


1.3
log
@From NetBSD: Merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: savecore.c,v 1.25 1996/03/16 10:29:46 leo Exp $	*/
d47 1
a47 1
static char rcsid[] = "$NetBSD: savecore.c,v 1.25 1996/03/16 10:29:46 leo Exp $";
d280 1
a280 1
	hdrsz = kvm_dump_mkheader(kd_kern, kd_dump, (off_t)dumplo);
d283 1
a283 1
			kvm_geterr(kd_kern));
d410 6
@


1.2
log
@Name saved dump and kernel "bsd*", not "netbsd*"
@
text
@d1 2
a2 1
/*	$NetBSD: savecore.c,v 1.23 1995/07/24 20:35:02 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$NetBSD: savecore.c,v 1.23 1995/07/24 20:35:02 cgd Exp $";
d67 2
d72 2
a73 1
#define ok(number) ((number) - KERNBASE)
d90 1
a90 1
	{ "" },
d103 1
a103 1
	{ "" },
d116 1
a134 1
int	 Read __P((int, void *, int));
d212 4
a215 3
	FILE *fp;
	int kmem, i;
	char *dump_sys;
d225 9
a233 2
	if ((nlist(_PATH_UNIX, current_nl)) == -1)
		syslog(LOG_ERR, "%s: nlist: %s", _PATH_UNIX, strerror(errno));
d241 1
a241 13
	dump_sys = kernel ? kernel : _PATH_UNIX;
	if ((nlist(dump_sys, dump_nl)) == -1)
		syslog(LOG_ERR, "%s: nlist: %s", dump_sys, strerror(errno));
	for (i = 0; dumpsyms[i] != -1; i++)
		if (dump_nl[dumpsyms[i]].n_value == 0) {
			syslog(LOG_ERR, "%s: %s not in namelist",
			    dump_sys, dump_nl[dumpsyms[i]].n_name);
			exit(1);
		}

	kmem = Open(_PATH_KMEM, O_RDONLY);
	Lseek(kmem, (off_t)current_nl[X_DUMPDEV].n_value, L_SET);
	(void)Read(kmem, &dumpdev, sizeof(dumpdev));
d246 1
a246 2
	Lseek(kmem, (off_t)current_nl[X_DUMPLO].n_value, L_SET);
	(void)Read(kmem, &dumplo, sizeof(dumplo));
d251 8
a258 2
	Lseek(kmem, (off_t)current_nl[X_DUMPMAG].n_value, L_SET);
	(void)Read(kmem, &dumpmag, sizeof(dumpmag));
d261 6
a266 3
	fp = fdopen(kmem, "r");
	if (fp == NULL) {
		syslog(LOG_ERR, "%s: fdopen: %m", _PATH_KMEM);
a268 4
	if (kernel)
		return;
	(void)fseek(fp, (off_t)current_nl[X_VERSION].n_value, L_SET);
	(void)fgets(vers, sizeof(vers), fp);
d270 18
a287 1
	/* Don't fclose(fp), we use dumpfd later. */
d293 2
a294 2
	register char *cp;
	FILE *fp;
d297 4
a300 7
	fp = fdopen(dumpfd, "r");
	if (fp == NULL) {
		syslog(LOG_ERR, "%s: fdopen: %m", ddname);
		exit(1);
	}
	fseek(fp, (off_t)(dumplo + ok(dump_nl[X_VERSION].n_value)), L_SET);
	fgets(core_vers, sizeof(core_vers), fp);
d305 2
a306 3
	(void)fseek(fp,
	    (off_t)(dumplo + ok(dump_nl[X_PANICSTR].n_value)), L_SET);
	(void)fread(&panicstr, sizeof(panicstr), 1, fp);
d308 6
a313 5
		(void)fseek(fp, dumplo + ok(panicstr), L_SET);
		cp = panic_mesg;
		do
			*cp = getc(fp);
		while (*cp++ && cp < &panic_mesg[sizeof(panic_mesg)]);
a314 11
	/* Don't fclose(fp), we use dumpfd later. */
}

void
clear_dump()
{
	long newdumplo;

	newdumplo = 0;
	Lseek(dumpfd, (off_t)(dumplo + ok(dump_nl[X_DUMPMAG].n_value)), L_SET);
	Write(dumpfd, &newdumplo, sizeof(newdumplo));
d322 1
a322 2
	Lseek(dumpfd, (off_t)(dumplo + ok(dump_nl[X_DUMPMAG].n_value)), L_SET);
	(void)Read(dumpfd, &newdumpmag, sizeof(newdumpmag));
d325 1
a325 2
	Lseek(dumpfd, (off_t)(dumplo + ok(dump_nl[X_DUMPSIZE].n_value)), L_SET);
	(void)Read(dumpfd, &dumpsize, sizeof(dumpsize));
d343 9
d385 1
a385 1
	(void)snprintf(path, sizeof(path), "%s/bsd.%d%s.core",
d392 1
a392 1
	} else
d394 6
d411 6
d432 1
a432 4
		if (compress)
			nw = fwrite(buf, 1, nr, fp);
		else
			nw = write(ofd, buf, nr);
d443 1
a443 4
	if (compress)
		(void)fclose(fp);
	else 
		(void)close(ofd);
d545 1
a545 2
	Lseek(dumpfd, (off_t)(dumplo + ok(dump_nl[X_TIME].n_value)), L_SET);
	(void)Read(dumpfd, &dumptime, sizeof(dumptime));
a616 15
}

int
Read(fd, bp, size)
	int fd, size;
	void *bp;
{
	int nr;

	nr = read(fd, bp, size);
	if (nr != size) {
		syslog(LOG_ERR, "read: %m");
		exit(1);
	}
	return (nr);
@


1.1
log
@Initial revision
@
text
@d371 1
a371 1
	(void)snprintf(path, sizeof(path), "%s/netbsd.%d%s.core",
d427 1
a427 1
	(void)snprintf(path, sizeof(path), "%s/netbsd.%d%s",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
