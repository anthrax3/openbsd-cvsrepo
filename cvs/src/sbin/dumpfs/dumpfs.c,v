head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.12
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.10
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.8
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2015.11.23.19.19.29;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Cz19p5I1S6mVZIjV;

1.32
date	2015.01.20.18.22.21;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	F55lwc3gS4GN2mLs;

1.31
date	2015.01.16.06.39.57;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	Uu5nFG3wCl0LACBb;

1.30
date	2014.05.13.12.51.40;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2013.04.02.03.05.37;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2011.02.28.00.12.19;	author halex;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.19.09.41.12;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.08.03.00.20;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.22.09.01.44;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.21.16.00.27;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.05.22.11.56;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.19.10.53.36;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.09.13.35.02;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.25.21.23.53;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.06.21.09.53;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.01.19.13.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.13.02.39.06;	author gluk;	state Exp;
branches;
next	1.10;

1.10
date	99.07.18.16.03.56;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.04.25.06.38.07;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.11.13.07.38.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.30.02.59.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.05.31.08.32.31;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.02.11.07.01.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.30.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.11.17.47.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.20.13.36.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Use pledge "disklabel" as needed.  The theory here is these tools become more
resistant against memory correctup, if a corrupt filesystem is given to them.
ok krw
@
text
@/*	$OpenBSD: dumpfs.c,v 1.32 2015/01/20 18:22:21 deraadt Exp $	*/

/*
 * Copyright (c) 2002 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by Marshall
 * Kirk McKusick and Network Associates Laboratories, the Security
 * Research Division of Network Associates, Inc. under DARPA/SPAWAR
 * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS
 * research program.
 *
 * Copyright (c) 1983, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE MAXBSIZE isset */
#include <sys/time.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fstab.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <util.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

union {
	struct fs fs;
	char pad[MAXBSIZE];
} fsun;
#define afs	fsun.fs
 
union {
	struct cg cg;
	char pad[MAXBSIZE];
} cgun;
#define acg	cgun.cg

int	dumpfs(int, const char *);
int	dumpcg(const char *, int, int);
int	marshal(const char *);
int	open_disk(const char *);
void	pbits(void *, int);
__dead void	usage(void);

int
main(int argc, char *argv[])
{
	struct fstab *fs;
	const char *name;
	int ch, domarshal, eval, fd;

	domarshal = eval = 0;

	while ((ch = getopt(argc, argv, "m")) != -1) {
		switch (ch) {
		case 'm':
			domarshal = 1;
			break;
		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc < 1)
		usage();

	if (pledge("stdio rpath disklabel", NULL) == -1)
		err(1, "pledge");

	for (; *argv != NULL; argv++) {
		if ((fs = getfsfile(*argv)) != NULL)
			name = fs->fs_spec;
		else
			name = *argv;
		if ((fd = open_disk(name)) == -1) {
			eval |= 1;
			continue;
		}
		if (domarshal)
			eval |= marshal(name);
		else
			eval |= dumpfs(fd, name);
		close(fd);
	}
	exit(eval);
}

int
open_disk(const char *name)
{
	int fd, i, sbtry[] = SBLOCKSEARCH;
	ssize_t n;

	/* XXX - should retry w/raw device on failure */
	if ((fd = opendev(name, O_RDONLY, 0, NULL)) < 0) {
		warn("%s", name);
		return(-1);
	}

	/* Read superblock, could be UFS1 or UFS2. */
	for (i = 0; sbtry[i] != -1; i++) {
		n = pread(fd, &afs, SBLOCKSIZE, (off_t)sbtry[i]);
		if (n == SBLOCKSIZE && (afs.fs_magic == FS_UFS1_MAGIC ||
		    (afs.fs_magic == FS_UFS2_MAGIC &&
		    afs.fs_sblockloc == sbtry[i])) &&
		    afs.fs_bsize <= MAXBSIZE &&
		    afs.fs_bsize >= sizeof(struct fs))
			break;
	}
	if (sbtry[i] == -1) {
		warnx("cannot find filesystem superblock");
		close(fd);
		return (-1);
	}

	return (fd);
}

int
dumpfs(int fd, const char *name)
{
	time_t fstime;
	int64_t fssize;
	int32_t fsflags;
	size_t size;
	off_t off;
	int i, j;

	switch (afs.fs_magic) {
	case FS_UFS2_MAGIC:
		fssize = afs.fs_size;
		fstime = afs.fs_time;
		printf("magic\t%x (FFS2)\ttime\t%s",
		    afs.fs_magic, ctime(&fstime));
		printf("superblock location\t%jd\tid\t[ %x %x ]\n",
		    (intmax_t)afs.fs_sblockloc, afs.fs_id[0], afs.fs_id[1]);
		printf("ncg\t%d\tsize\t%jd\tblocks\t%jd\n",
		    afs.fs_ncg, (intmax_t)fssize, (intmax_t)afs.fs_dsize);
		break;
	case FS_UFS1_MAGIC:
		fssize = afs.fs_ffs1_size;
		fstime = afs.fs_ffs1_time;
		printf("magic\t%x (FFS1)\ttime\t%s",
		    afs.fs_magic, ctime(&fstime));
		printf("id\t[ %x %x ]\n", afs.fs_id[0], afs.fs_id[1]);
		i = 0;
		if (afs.fs_postblformat != FS_42POSTBLFMT) {
			i++;
			if (afs.fs_inodefmt >= FS_44INODEFMT) {
				size_t max;

				i++;
				max = afs.fs_maxcontig;
				size = afs.fs_contigsumsize;
				if ((max < 2 && size == 0) ||
				    (max > 1 && size >= MINIMUM(max, FS_MAXCONTIG)))
					i++;
			}
		}
		printf("cylgrp\t%s\tinodes\t%s\tfslevel %d\n",
		    i < 1 ? "static" : "dynamic",
		    i < 2 ? "4.2/4.3BSD" : "4.4BSD", i);
		printf("ncg\t%d\tncyl\t%d\tsize\t%d\tblocks\t%d\n",
		    afs.fs_ncg, afs.fs_ncyl, afs.fs_ffs1_size, afs.fs_ffs1_dsize);
		break;
	default:
		goto err;
	}
	printf("bsize\t%d\tshift\t%d\tmask\t0x%08x\n",
	    afs.fs_bsize, afs.fs_bshift, afs.fs_bmask);
	printf("fsize\t%d\tshift\t%d\tmask\t0x%08x\n",
	    afs.fs_fsize, afs.fs_fshift, afs.fs_fmask);
	printf("frag\t%d\tshift\t%d\tfsbtodb\t%d\n",
	    afs.fs_frag, afs.fs_fragshift, afs.fs_fsbtodb);
	printf("minfree\t%d%%\toptim\t%s\tsymlinklen %d\n",
	    afs.fs_minfree, afs.fs_optim == FS_OPTSPACE ? "space" : "time",
	    afs.fs_maxsymlinklen);
	switch (afs.fs_magic) {
	case FS_UFS2_MAGIC:
		printf("%s %d\tmaxbpg\t%d\tmaxcontig %d\tcontigsumsize %d\n",
		    "maxbsize", afs.fs_maxbsize, afs.fs_maxbpg,
		    afs.fs_maxcontig, afs.fs_contigsumsize);
		printf("nbfree\t%jd\tndir\t%jd\tnifree\t%jd\tnffree\t%jd\n",
		    (intmax_t)afs.fs_cstotal.cs_nbfree, 
		    (intmax_t)afs.fs_cstotal.cs_ndir,
		    (intmax_t)afs.fs_cstotal.cs_nifree, 
		    (intmax_t)afs.fs_cstotal.cs_nffree);
		printf("bpg\t%d\tfpg\t%d\tipg\t%d\n",
		    afs.fs_fpg / afs.fs_frag, afs.fs_fpg, afs.fs_ipg);
		printf("nindir\t%d\tinopb\t%d\tmaxfilesize\t%ju\n",
		    afs.fs_nindir, afs.fs_inopb, 
		    (uintmax_t)afs.fs_maxfilesize);
		printf("sbsize\t%d\tcgsize\t%d\tcsaddr\t%jd\tcssize\t%d\n",
		    afs.fs_sbsize, afs.fs_cgsize, (intmax_t)afs.fs_csaddr,
		    afs.fs_cssize);
		break;
	case FS_UFS1_MAGIC:
		printf("maxbpg\t%d\tmaxcontig %d\tcontigsumsize %d\n",
		    afs.fs_maxbpg, afs.fs_maxcontig, afs.fs_contigsumsize);
		printf("nbfree\t%d\tndir\t%d\tnifree\t%d\tnffree\t%d\n",
		    afs.fs_ffs1_cstotal.cs_nbfree, afs.fs_ffs1_cstotal.cs_ndir,
		    afs.fs_ffs1_cstotal.cs_nifree, afs.fs_ffs1_cstotal.cs_nffree);
		printf("cpg\t%d\tbpg\t%d\tfpg\t%d\tipg\t%d\n",
		    afs.fs_cpg, afs.fs_fpg / afs.fs_frag, afs.fs_fpg,
		    afs.fs_ipg);
		printf("nindir\t%d\tinopb\t%d\tnspf\t%d\tmaxfilesize\t%ju\n",
		    afs.fs_nindir, afs.fs_inopb, afs.fs_nspf,
		    (uintmax_t)afs.fs_maxfilesize);
		printf("sbsize\t%d\tcgsize\t%d\tcgoffset %d\tcgmask\t0x%08x\n",
		    afs.fs_sbsize, afs.fs_cgsize, afs.fs_cgoffset,
		    afs.fs_cgmask);
		printf("csaddr\t%d\tcssize\t%d\n",
		    afs.fs_ffs1_csaddr, afs.fs_cssize);
		printf("rotdelay %dms\trps\t%d\tinterleave %d\n",
		    afs.fs_rotdelay, afs.fs_rps, afs.fs_interleave);
		printf("nsect\t%d\tnpsect\t%d\tspc\t%d\n",
		    afs.fs_nsect, afs.fs_npsect, afs.fs_spc);
		break;
	default:
		goto err;
	}
	printf("sblkno\t%d\tcblkno\t%d\tiblkno\t%d\tdblkno\t%d\n",
	    afs.fs_sblkno, afs.fs_cblkno, afs.fs_iblkno, afs.fs_dblkno);
	printf("cgrotor\t%d\tfmod\t%d\tronly\t%d\tclean\t%d\n",
	    afs.fs_cgrotor, afs.fs_fmod, afs.fs_ronly, afs.fs_clean);
	printf("avgfpdir %d\tavgfilesize %d\n",
	    afs.fs_avgfpdir, afs.fs_avgfilesize);
	printf("flags\t");
	if (afs.fs_magic == FS_UFS2_MAGIC ||
	    afs.fs_ffs1_flags & FS_FLAGS_UPDATED)
		fsflags = afs.fs_flags;
	else
		fsflags = afs.fs_ffs1_flags;
	if (fsflags == 0)
		printf("none");
	if (fsflags & FS_UNCLEAN)
		printf("unclean ");
	if (fsflags & FS_DOSOFTDEP)
		printf("soft-updates ");
	if (fsflags & FS_FLAGS_UPDATED)
		printf("updated ");
#if 0
	fsflags &= ~(FS_UNCLEAN | FS_DOSOFTDEP | FS_FLAGS_UPDATED);
	if (fsflags != 0)
		printf("unknown flags (%#x)", fsflags);
#endif
	putchar('\n');
	printf("fsmnt\t%s\n", afs.fs_fsmnt);
	printf("volname\t%s\tswuid\t%ju\n",
		afs.fs_volname, (uintmax_t)afs.fs_swuid);
	printf("\ncs[].cs_(nbfree,ndir,nifree,nffree):\n\t");
	afs.fs_csp = calloc(1, afs.fs_cssize);
	for (i = 0, j = 0; i < afs.fs_cssize; i += afs.fs_bsize, j++) {
		size = afs.fs_cssize - i < afs.fs_bsize ?
		    afs.fs_cssize - i : afs.fs_bsize;
		off = (off_t)(fsbtodb(&afs, (afs.fs_csaddr + j *
		    afs.fs_frag))) * DEV_BSIZE;
		if (pread(fd, (char *)afs.fs_csp + i, size, off) != size)
			goto err;
	}
	for (i = 0; i < afs.fs_ncg; i++) {
		struct csum *cs = &afs.fs_cs(&afs, i);
		if (i && i % 4 == 0)
			printf("\n\t");
		printf("(%d,%d,%d,%d) ",
		    cs->cs_nbfree, cs->cs_ndir, cs->cs_nifree, cs->cs_nffree);
	}
	printf("\n");
	if (fssize % afs.fs_fpg) {
		if (afs.fs_magic == FS_UFS1_MAGIC)
			printf("cylinders in last group %d\n",
			    howmany(afs.fs_ffs1_size % afs.fs_fpg,
			    afs.fs_spc / afs.fs_nspf));
		printf("blocks in last group %ld\n\n",
		    (long)((fssize % afs.fs_fpg) / afs.fs_frag));
	}
	for (i = 0; i < afs.fs_ncg; i++)
		if (dumpcg(name, fd, i))
			goto err;
	return (0);

err:	warn("%s", name);
	return (1);
}

int
dumpcg(const char *name, int fd, int c)
{
	time_t cgtime;
	off_t cur;
	int i, j;

	printf("\ncg %d:\n", c);
	cur = (off_t)fsbtodb(&afs, cgtod(&afs, c)) * DEV_BSIZE;
	if (pread(fd, &acg, afs.fs_bsize, cur) != afs.fs_bsize) {
		warn("%s: error reading cg", name);
		return(1);
	}
	switch (afs.fs_magic) {
	case FS_UFS2_MAGIC:
		cgtime = acg.cg_ffs2_time;
		printf("magic\t%x\ttell\t%jx\ttime\t%s",
		    acg.cg_magic, (intmax_t)cur, ctime(&cgtime));
		printf("cgx\t%d\tndblk\t%d\tniblk\t%d\tinitiblk %d\n",
		    acg.cg_cgx, acg.cg_ndblk, acg.cg_ffs2_niblk,
		    acg.cg_initediblk);
		break;
	case FS_UFS1_MAGIC:
		cgtime = acg.cg_time;
		printf("magic\t%x\ttell\t%jx\ttime\t%s",
		    afs.fs_postblformat == FS_42POSTBLFMT ?
		    ((struct ocg *)&acg)->cg_magic : acg.cg_magic,
		    (intmax_t)cur, ctime(&cgtime));
		printf("cgx\t%d\tncyl\t%d\tniblk\t%d\tndblk\t%d\n",
		    acg.cg_cgx, acg.cg_ncyl, acg.cg_niblk, acg.cg_ndblk);
		break;
	default:
		break;
	}
	printf("nbfree\t%d\tndir\t%d\tnifree\t%d\tnffree\t%d\n",
	    acg.cg_cs.cs_nbfree, acg.cg_cs.cs_ndir,
	    acg.cg_cs.cs_nifree, acg.cg_cs.cs_nffree);
	printf("rotor\t%d\tirotor\t%d\tfrotor\t%d\nfrsum",
	    acg.cg_rotor, acg.cg_irotor, acg.cg_frotor);
	for (i = 1, j = 0; i < afs.fs_frag; i++) {
		printf("\t%d", acg.cg_frsum[i]);
		j += i * acg.cg_frsum[i];
	}
	printf("\nsum of frsum: %d", j);
	if (afs.fs_contigsumsize > 0) {
		for (i = 1; i < afs.fs_contigsumsize; i++) {
			if ((i - 1) % 8 == 0)
				printf("\nclusters %d-%d:", i,
				    afs.fs_contigsumsize - 1 < i + 7 ?
				    afs.fs_contigsumsize - 1 : i + 7);
			printf("\t%d", cg_clustersum(&acg)[i]);
		}
		printf("\nclusters size %d and over: %d\n",
		    afs.fs_contigsumsize,
		    cg_clustersum(&acg)[afs.fs_contigsumsize]);
		printf("clusters free:\t");
		pbits(cg_clustersfree(&acg), acg.cg_nclusterblks);
	} else
		printf("\n");
	printf("inodes used:\t");
	pbits(cg_inosused(&acg), afs.fs_ipg);
	printf("blks free:\t");
	pbits(cg_blksfree(&acg), afs.fs_fpg);
#if 0
	/* XXX - keep this? */
	if (afs.fs_magic == FS_UFS1_MAGIC) {
		printf("b:\n");
		for (i = 0; i < afs.fs_cpg; i++) {
			if (cg_blktot(&acg)[i] == 0)
				continue;
			printf("   c%d:\t(%d)\t", i, cg_blktot(&acg)[i]);
			printf("\n");
		}
	}
#endif
	return (0);
}

int
marshal(const char *name)
{
	int Oflag;

	printf("# newfs command for %s\n", name);
	printf("newfs ");
	if (afs.fs_volname[0] != '\0')
		printf("-L %s ", afs.fs_volname);

	Oflag = (afs.fs_magic == FS_UFS2_MAGIC) +
	    (afs.fs_inodefmt == FS_44INODEFMT);
	printf("-O %d ", Oflag);
	printf("-b %d ", afs.fs_bsize);
	/* -c unimplemented */
	printf("-e %d ", afs.fs_maxbpg);
	printf("-f %d ", afs.fs_fsize);
	printf("-g %d ", afs.fs_avgfilesize);
	printf("-h %d ", afs.fs_avgfpdir);
	/* -i unimplemented */
	printf("-m %d ", afs.fs_minfree);
	printf("-o ");
	switch (afs.fs_optim) {
	case FS_OPTSPACE:
		printf("space ");
		break;
	case FS_OPTTIME:
		printf("time ");
		break;
	default:
		printf("unknown ");
		break;
	}
	/* -S unimplemented */
	printf("-s %jd ", (intmax_t)afs.fs_size * (afs.fs_fsize / DEV_BSIZE));
	printf("%s ", name);
	printf("\n");

	return 0;
}

void
pbits(void *vp, int max)
{
	int i;
	char *p;
	int count, j;

	for (count = i = 0, p = vp; i < max; i++)
		if (isset(p, i)) {
			if (count)
				printf(",%s", count % 6 ? " " : "\n\t");
			count++;
			printf("%d", i);
			j = i;
			while ((i+1)<max && isset(p, i+1))
				i++;
			if (i != j)
				printf("-%d", i);
		}
	printf("\n");
}

__dead void
usage(void)
{
	(void)fprintf(stderr, "usage: dumpfs [-m] filesys | device\n");
	exit(1);
}
@


1.32
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.31 2015/01/16 06:39:57 deraadt Exp $	*/
d102 3
@


1.31
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.30 2014/05/13 12:51:40 krw Exp $	*/
d41 1
a41 1
#include <sys/param.h>	/* DEV_BSIZE MAXFRAG MAXBSIZE isset */
@


1.30
log
@Nuke another pointless dev_bsize variable always set to 512 and use
DEV_BSIZE. David Vasek says it still works the same on 4K-byte-sector
device. i.e.  prints one value incorrectly. For which a fix should
be following soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.29 2013/04/02 03:05:37 guenther Exp $	*/
d41 1
a41 1
#include <sys/param.h>
d57 2
d189 1
a189 1
				    (max > 1 && size >= MIN(max, FS_MAXCONTIG)))
@


1.29
log
@Use a time_t variable with ctime()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.28 2011/02/28 00:12:19 halex Exp $	*/
a68 2
long	dev_bsize;

a146 1
	dev_bsize = afs.fs_fsize / fsbtodb(&afs, 1);
d288 1
a288 1
		    afs.fs_frag))) * dev_bsize;
d325 1
a325 1
	cur = (off_t)fsbtodb(&afs, cgtod(&afs, c)) * dev_bsize;
@


1.28
log
@switch open(...) to opendev(...)
makes yet another utility honor DUID's

ok jsing@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.27 2009/10/27 23:59:32 deraadt Exp $	*/
d347 1
a347 1
		    (intmax_t)cur, ctime(&acg.cg_time));
@


1.27
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.26 2008/08/19 09:41:12 pedro Exp $	*/
d55 1
d74 1
a74 1
int	open_disk(const char *name);
d128 1
a128 1
	if ((fd = open(name, O_RDONLY, 0)) < 0) {
@


1.26
log
@Look at 'fs_flags' when dumping FFS2 file systems, okay beck@@, millert@@
and otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.25 2008/06/08 03:00:20 otto Exp $	*/
a39 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)dumpfs.c	8.5 (Berkeley) 4/29/95";
#else
static const char rcsid[] = "$OpenBSD: dumpfs.c,v 1.25 2008/06/08 03:00:20 otto Exp $";
#endif
#endif /* not lint */
@


1.25
log
@fix generated size for -m; bug report by Peter J. Philipp; ok millert@@
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.24 2008/01/22 09:01:44 otto Exp $	*/
d51 1
a51 1
static const char rcsid[] = "$OpenBSD: dumpfs.c,v 1.24 2008/01/22 09:01:44 otto Exp $";
d276 2
a277 1
	if (afs.fs_ffs1_flags & FS_FLAGS_UPDATED)
@


1.24
log
@pick the right csaddr when dumping cgs. Makes FFS2 dumps work much better
ok thib@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.23 2007/05/21 16:00:27 millert Exp $	*/
d51 1
a51 1
static const char rcsid[] = "$OpenBSD: dumpfs.c,v 1.23 2007/05/21 16:00:27 millert Exp $";
d444 1
a444 1
	printf("-s %jd ", (intmax_t)afs.fs_size);
@


1.23
log
@Use SBLOCKSEARCH[] to find the superblock.  OK pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.22 2007/05/05 22:11:56 millert Exp $	*/
d51 1
a51 1
static const char rcsid[] = "$OpenBSD: dumpfs.c,v 1.22 2007/05/05 22:11:56 millert Exp $";
d302 1
a302 1
		off = (off_t)(fsbtodb(&afs, (afs.fs_ffs1_csaddr + j *
@


1.22
log
@Add support for ffs2 and a new flag, -m, which will output a
newfs command that can be used to make a filesystem with the
same settings.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.21 2007/04/19 10:53:36 otto Exp $	*/
d51 1
a51 1
static const char rcsid[] = "$OpenBSD: dumpfs.c,v 1.21 2007/04/19 10:53:36 otto Exp $";
d137 1
a137 1
	int fd;
d147 7
a153 7
	if (((n = pread(fd, &afs, SBSIZE, (off_t)SBLOCK_UFS1) != SBSIZE) ||
	    afs.fs_magic != FS_UFS1_MAGIC) &&
	    ((n = pread(fd, &afs, SBSIZE, (off_t)SBLOCK_UFS2) != SBSIZE) ||
	    afs.fs_magic != FS_UFS2_MAGIC)) {
		switch (n) {
		case -1:
			warn("%s", name);
d155 4
a158 8
		case SBSIZE:
			warnx("%s: non-existent or truncated superblock, "
			    "skipped", name);
			break;
		default:
			warnx("%s: superblock has bad magic number, skipping.",
			    name);
		}
@


1.21
log
@teach dumpfs about the 'updated' flag; ok pedro@@
@
text
@d1 1
a1 2
/*	$OpenBSD: dumpfs.c,v 1.20 2007/03/19 13:27:47 pedro Exp $	*/
/*	$NetBSD: dumpfs.c,v 1.12 1997/04/26 05:41:33 lukem Exp $	*/
d4 9
d42 1
a42 1
static char copyright[] =
d49 1
a49 1
static char sccsid[] = "@@(#)dumpfs.c	8.2 (Berkeley) 2/2/94";
d51 1
a51 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.20 2007/03/19 13:27:47 pedro Exp $";
d65 1
a67 1
#include <string.h>
d74 2
a75 2
#define	afs	fsun.fs

d80 1
a80 1
#define	acg	cgun.cg
d82 1
a82 1
long	dev_bsize = 1;
d84 4
a87 2
int	dumpfs(char *);
int	dumpcg(char *, int, int);
d89 1
a89 1
void	usage(void);
d95 4
a98 1
	int ch, eval;
d100 5
a104 2
	while ((ch = getopt(argc, argv, "")) != -1)
		switch(ch) {
d109 1
d116 3
a118 3
	for (eval = 0; *argv; ++argv)
		if ((fs = getfsfile(*argv)) == NULL)
			eval |= dumpfs(*argv);
d120 11
a130 1
			eval |= dumpfs(fs->fs_spec);
d135 1
a135 1
dumpfs(char *name)
d137 1
a138 1
	int fd, i, j, size;
d140 5
a144 6
	if ((fd = open(name, O_RDONLY, 0)) < 0)
		goto err;
	if (lseek(fd, (off_t)SBOFF, SEEK_SET) == (off_t)-1)
		goto err;
	if ((n = read(fd, &afs, SBSIZE)) == -1)
		goto err;
d146 19
a164 11
	if (n != SBSIZE) {
		warnx("%s: non-existent or truncated superblock, skipped",
		    name);
		(void)close(fd);
 		return (1);
	}
 	if (afs.fs_magic != FS_MAGIC) {
		warnx("%s: superblock has bad magic number, skipping.", name);
		(void) close(fd);
 		return (1);
 	}
a165 2
	if (afs.fs_postblformat == FS_42POSTBLFMT)
		afs.fs_nrpos = 8;
d167 2
a168 7
	printf("magic\t%x\ttime\t%s", afs.fs_magic,
	    ctime(&afs.fs_ffs1_time));
	i = 0;
	if (afs.fs_postblformat != FS_42POSTBLFMT) {
		i++;
		if (afs.fs_inodefmt >= FS_44INODEFMT) {
			int max;
d170 29
d200 3
a202 4
			max = afs.fs_maxcontig;
			size = afs.fs_contigsumsize;
			if ((max < 2 && size == 0)
			    || (max > 1 && size >= MIN(max, FS_MAXCONTIG)))
d204 6
d211 8
a219 8
	printf("cylgrp\t%s\tinodes\t%s\tfslevel %d%s\n",
	    i < 1 ? "static" : "dynamic", i < 2 ? "4.2/4.3BSD" : "4.4BSD", i,
	    (afs.fs_ffs1_flags & FS_DOSOFTDEP) ? "\tsoft updates" : "");
	printf("nbfree\t%d\tndir\t%d\tnifree\t%d\tnffree\t%d\n",
	    afs.fs_ffs1_cstotal.cs_nbfree, afs.fs_ffs1_cstotal.cs_ndir,
	    afs.fs_ffs1_cstotal.cs_nifree, afs.fs_ffs1_cstotal.cs_nffree);
	printf("ncg\t%d\tncyl\t%d\tsize\t%d\tblocks\t%d\n",
	    afs.fs_ncg, afs.fs_ncyl, afs.fs_ffs1_size, afs.fs_ffs1_dsize);
d226 1
a226 3
	printf("cpg\t%d\tbpg\t%d\tfpg\t%d\tipg\t%d\n",
	    afs.fs_cpg, afs.fs_fpg / afs.fs_frag, afs.fs_fpg, afs.fs_ipg);
	printf("minfree\t%d%%\toptim\t%s\tmaxcontig %d\tmaxbpg\t%d\n",
d228 45
a272 9
	    afs.fs_maxcontig, afs.fs_maxbpg);
	printf("rotdelay %dms\trps\t%d\n", afs.fs_rotdelay, afs.fs_rps);
	printf("ntrak\t%d\tnsect\t%d\tnpsect\t%d\tspc\t%d\n",
	    afs.fs_ntrak, afs.fs_nsect, afs.fs_npsect, afs.fs_spc);
	printf("symlinklen %d\ttrackskew %d\tinterleave %d\tcontigsumsize %d\n",
	    afs.fs_maxsymlinklen, afs.fs_trackskew, afs.fs_interleave,
	    afs.fs_contigsumsize);
	printf("nindir\t%d\tinopb\t%d\tnspf\t%d\tmaxfilesize\t%qu\n",
	    afs.fs_nindir, afs.fs_inopb, afs.fs_nspf, afs.fs_maxfilesize);
d275 1
a275 5
	printf("sbsize\t%d\tcgsize\t%d\tcgoffset %d\tcgmask\t0x%08x\n",
	    afs.fs_sbsize, afs.fs_cgsize, afs.fs_cgoffset, afs.fs_cgmask);
	printf("csaddr\t%d\tcssize\t%d\tshift\t%d\tmask\t0x%08x\n",
	    afs.fs_ffs1_csaddr, afs.fs_cssize, afs.fs_csshift, afs.fs_csmask);
	printf("cgrotor\t%d\tfmod\t%d\tronly\t%d\tclean\t0x%02x\n",
d277 2
d280 5
a284 1
	if (afs.fs_ffs1_flags == 0)
d286 1
a286 1
	if (afs.fs_ffs1_flags & FS_UNCLEAN)
d288 1
a288 1
	if (afs.fs_ffs1_flags & FS_DOSOFTDEP)
d290 1
a290 1
	if (afs.fs_ffs1_flags & FS_FLAGS_UPDATED)
d292 9
a300 10
	if (afs.fs_ffs1_flags &
	    ~(FS_UNCLEAN | FS_DOSOFTDEP | FS_FLAGS_UPDATED) != 0)
		printf("unknown flags (%#x)", afs.fs_ffs1_flags &
		    ~(FS_UNCLEAN | FS_DOSOFTDEP | FS_FLAGS_UPDATED));
	printf("\n");
	if (afs.fs_cpc != 0)
		printf("blocks available in each of %d rotational positions",
		     afs.fs_nrpos);
	else
		printf("insufficient space to maintain rotational tables\n");
d306 3
a308 5
		if (lseek(fd,
		    (off_t)(fsbtodb(&afs, (afs.fs_ffs1_csaddr + j * afs.fs_frag))) *
		    dev_bsize, SEEK_SET) == (off_t)-1)
			goto err;
		if (read(fd, (char *)afs.fs_csp + i, size) != size)
d319 7
a325 5
	if (afs.fs_ncyl % afs.fs_cpg) {
		printf("cylinders in last group %d\n",
		    i = afs.fs_ncyl % afs.fs_cpg);
		printf("blocks in last group %d\n",
		    i * afs.fs_spc / NSPB(&afs));
a326 1
	printf("\n");
a329 1
	(void)close(fd);
d332 1
a332 3
err:	if (fd != -1)
		(void)close(fd);
	warn("%s", name);
d337 1
a337 1
dumpcg(char *name, int fd, int c)
d339 1
d344 26
a369 13
	if ((cur = lseek(fd, (off_t)(fsbtodb(&afs, cgtod(&afs, c))) * dev_bsize,
	    SEEK_SET)) == (off_t)-1)
		return (1);
	if (read(fd, &acg, afs.fs_bsize) != afs.fs_bsize) {
		warnx("%s: error reading cg", name);
		return (1);
	}
	printf("magic\t%x\ttell\t%qx\ttime\t%s",
	    afs.fs_postblformat == FS_42POSTBLFMT ?
	    ((struct ocg *)&acg)->cg_magic : acg.cg_magic,
	    cur, ctime(&acg.cg_time));
	printf("cgx\t%d\tncyl\t%d\tniblk\t%d\tndblk\t%d\n",
	    acg.cg_cgx, acg.cg_ncyl, acg.cg_niblk, acg.cg_ndblk);
d395 1
a395 1
	printf("iused:\t");
d397 1
a397 1
	printf("free:\t");
d399 10
a408 6
	printf("b:\n");
	for (i = 0; i < afs.fs_cpg; i++) {
		if (cg_blktot(&acg)[i] == 0)
			continue;
		printf("   c%d:\t(%d)\t", i, cg_blktot(&acg)[i]);
		printf("\n");
d410 1
d414 41
d477 1
a477 1
void
d480 1
a480 2

	(void)fprintf(stderr, "usage: dumpfs filesys | device\n");
@


1.20
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.19 2006/03/09 13:35:02 pedro Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.19 2006/03/09 13:35:02 pedro Exp $";
d193 6
a198 3
	if ((afs.fs_ffs1_flags & ~(FS_UNCLEAN | FS_DOSOFTDEP)) != 0)
		printf("unknown flags (%#x)",
		    afs.fs_ffs1_flags & ~(FS_UNCLEAN | FS_DOSOFTDEP));
@


1.19
log
@Remove option -n from newfs as well as all references to fs_postbl()
Various testing for a while, okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.18 2003/06/25 21:23:53 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.18 2003/06/25 21:23:53 deraadt Exp $";
d136 1
a136 1
	    ctime(&afs.fs_time));
d153 1
a153 1
	    (afs.fs_flags & FS_DOSOFTDEP) ? "\tsoft updates" : "");
d155 2
a156 2
	    afs.fs_cstotal.cs_nbfree, afs.fs_cstotal.cs_ndir,
	    afs.fs_cstotal.cs_nifree, afs.fs_cstotal.cs_nffree);
d158 1
a158 1
	    afs.fs_ncg, afs.fs_ncyl, afs.fs_size, afs.fs_dsize);
d183 1
a183 1
	    afs.fs_csaddr, afs.fs_cssize, afs.fs_csshift, afs.fs_csmask);
d187 1
a187 1
	if (afs.fs_flags == 0)
d189 1
a189 1
	if (afs.fs_flags & FS_UNCLEAN)
d191 1
a191 1
	if (afs.fs_flags & FS_DOSOFTDEP)
d193 1
a193 1
	if ((afs.fs_flags & ~(FS_UNCLEAN | FS_DOSOFTDEP)) != 0)
d195 1
a195 1
		    afs.fs_flags & ~(FS_UNCLEAN | FS_DOSOFTDEP));
d208 1
a208 1
		    (off_t)(fsbtodb(&afs, (afs.fs_csaddr + j * afs.fs_frag))) *
@


1.18
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.17 2003/06/02 20:06:14 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.17 2003/06/02 20:06:14 millert Exp $";
d111 1
a111 1
	int fd, c, i, j, k, size;
a201 16
	for (c = 0; c < afs.fs_cpc; c++) {
		printf("\ncylinder number %d:", c);
		for (i = 0; i < afs.fs_nrpos; i++) {
			if (fs_postbl(&afs, c)[i] == -1)
				continue;
			printf("\n   position %d:\t", i);
			for (j = fs_postbl(&afs, c)[i], k = 1; ;
			     j += fs_rotbl(&afs)[j], k++) {
				printf("%5d", j);
				if (k % 12 == 0)
					printf("\n\t\t");
				if (fs_rotbl(&afs)[j] == 0)
					break;
			}
		}
	}
a294 6
		for (j = 0; j < afs.fs_nrpos; j++) {
			if (afs.fs_cpc > 0 &&
			    fs_postbl(&afs, i % afs.fs_cpc)[j] == -1)
				continue;
			printf(" %d", cg_blks(&afs, &acg, i)[j]);
		}
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.16 2002/09/06 21:09:53 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.16 2002/09/06 21:09:53 deraadt Exp $";
d82 1
a82 3
main(argc, argv)
	int argc;
	char *argv[];
d108 1
a108 2
dumpfs(name)
	char *name;
d258 1
a258 3
dumpcg(name, fd, c)
	char *name;
	int fd, c;
d323 1
a323 3
pbits(vp, max)
	void *vp;
	int max;
d345 1
a345 1
usage()
@


1.16
log
@bogus ; outside of function
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.15 2002/06/09 08:13:05 todd Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.15 2002/06/09 08:13:05 todd Exp $";
@


1.15
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.14 2002/02/16 21:27:33 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.14 2002/02/16 21:27:33 millert Exp $";
d262 1
a262 1
};
d329 1
a329 1
};
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.13 2001/12/01 19:13:21 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.13 2001/12/01 19:13:21 deraadt Exp $";
d201 1
a201 1
		printf("unknown flags (%#x)", 
@


1.13
log
@remove unused variable; csapuntz ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.12 2001/11/05 07:39:16 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.12 2001/11/05 07:39:16 mpech Exp $";
d80 4
a83 4
int	dumpfs __P((char *));
int	dumpcg __P((char *, int, int));
void	pbits __P((void *, int));
void	usage __P((void));
@


1.12
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.11 2001/04/13 02:39:06 gluk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.11 2001/04/13 02:39:06 gluk Exp $";
d148 1
a148 1
			int max, siz;
@


1.11
log
@Fix overflow in superblock. From FreeBSD.

FreeBSD's log:
> The ffs superblock includes a 128-byte region for use by temporary
> in-core pointers to summary information. An array in this region
> (fs_csp) could overflow on filesystems with a very large number of
> cylinder groups (~16000 on i386 with 8k blocks). When this happens,
> other fields in the superblock get corrupted, and fsck refuses to
> check the filesystem.
>
> Solve this problem by replacing the fs_csp array in 'struct fs'
> with a single pointer, and add padding to keep the length of the
> 128-byte region fixed. Update the kernel and userland utilities
> to use just this single pointer.
>
> With this change, the kernel no longer makes use of the superblock
> fields 'fs_csshift' and 'fs_csmask'. Add a comment to newfs/mkfs.c
> to indicate that these fields must be calculated for compatibility
> with older kernels.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.10 1999/07/18 16:03:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.10 1999/07/18 16:03:56 deraadt Exp $";
d90 1
a90 1
	register struct fstab *fs;
d333 1
a333 1
	register void *vp;
d336 2
a337 2
	register int i;
	register char *p;
@


1.10
log
@print out fs_flags fields; mpp@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.9 1998/04/25 06:38:07 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.9 1998/04/25 06:38:07 deraadt Exp $";
d226 1
a229 1
		afs.fs_csp[j] = calloc(1, size);
d234 1
a234 1
		if (read(fd, afs.fs_csp[j], size) != size)
@


1.9
log
@handle truncated superblock read; rnordier@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.8 1997/11/13 07:38:37 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.8 1997/11/13 07:38:37 millert Exp $";
d193 11
@


1.8
log
@Say "soft updates" when FS_DOSOFTDEP is set in superblock, could look nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.7 1997/06/30 02:59:28 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.7 1997/06/30 02:59:28 deraadt Exp $";
d117 1
d124 1
a124 1
	if (read(fd, &afs, SBSIZE) != SBSIZE)
d127 6
@


1.7
log
@print fs_maxfilesize; bde@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.6 1997/05/31 08:32:31 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.6 1997/05/31 08:32:31 deraadt Exp $";
d127 1
a127 2
		warnx("%s: superblock has bad magic number, skipping.",
		     name);
d151 3
a153 2
	printf("cylgrp\t%s\tinodes\t%s\tfslevel %d\n",
	    i < 1 ? "static" : "dynamic", i < 2 ? "4.2/4.3BSD" : "4.4BSD", i);
@


1.6
log
@lukem: Determine filesystem level (ref: fsck_ffs(8) -c ...) and display it.
Code was derivied from observing how fsck_ffs `upgrades' to a given
level, and has been tested on recent NetBSD filesystems (reports as "3"),
SunOS ("1"), and ULTRIX ("0"). I haven't found a filesystem of level
"2" to test, but the code should detect it. Fixes [bin/1353]
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.5 1997/02/11 07:01:27 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.5 1997/02/11 07:01:27 millert Exp $";
d176 2
a177 2
	printf("nindir\t%d\tinopb\t%d\tnspf\t%d\n",
	    afs.fs_nindir, afs.fs_inopb, afs.fs_nspf);
@


1.5
log
@Remove occurences of headswitch and trackseek, they no longer
exist in struct fs.
@
text
@d1 2
a2 2
/*	$OpenBSD: dumpfs.c,v 1.4 1996/06/23 14:30:16 deraadt Exp $	*/
/*	$NetBSD: dumpfs.c,v 1.11 1996/01/09 21:23:36 pk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.4 1996/06/23 14:30:16 deraadt Exp $";
d138 16
a153 3
	printf("cylgrp\t%s\tinodes\t%s\n",
	    afs.fs_postblformat == FS_42POSTBLFMT ? "static" : "dynamic",
	    afs.fs_inodefmt < FS_44INODEFMT ? "4.2/4.3BSD" : "4.4BSD");
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: dumpfs.c,v 1.11 1996/01/09 21:23:36 pk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: dumpfs.c,v 1.11 1996/01/09 21:23:36 pk Exp $";
d157 1
a157 2
	printf("rotdelay %dms\theadswitch %dus\ttrackseek %dus\trps\t%d\n",
	    afs.fs_rotdelay, afs.fs_headswitch, afs.fs_trkseek, afs.fs_rps);
@


1.3
log
@sync with netbsd
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: dumpfs.c,v 1.11 1996/01/09 21:23:36 pk Exp $";
@


1.2
log
@lseek botch repair; from tegge@@idt.unit.no; netbsd pr#1768
@
text
@d1 1
a1 1
/*	$NetBSD: dumpfs.c,v 1.10 1995/04/12 21:23:24 mycroft Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: dumpfs.c,v 1.10 1995/04/12 21:23:24 mycroft Exp $";
d200 2
a201 2
		    (off_t)((off_t)fsbtodb(&afs, (afs.fs_csaddr + j * afs.fs_frag)) *
		    (off_t)dev_bsize), SEEK_SET) == (off_t)-1)
d242 1
a242 1
	if ((cur = lseek(fd, (off_t)((off_t)fsbtodb(&afs, cgtod(&afs, c)) * (off_t)dev_bsize),
@


1.1
log
@Initial revision
@
text
@d200 2
a201 2
		    (off_t)(fsbtodb(&afs, (afs.fs_csaddr + j * afs.fs_frag)) *
		    dev_bsize), SEEK_SET) == (off_t)-1)
d242 1
a242 1
	if ((cur = lseek(fd, (off_t)(fsbtodb(&afs, cgtod(&afs, c)) * dev_bsize),
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
