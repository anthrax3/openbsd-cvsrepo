head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.24
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.16
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.20
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.18
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.14
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.12
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.10
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.10.20.10.24.40;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	5NqAHool0KzwJ8Pu;

1.29
date	2016.03.07.19.16.06;	author tb;	state Exp;
branches;
next	1.28;
commitid	AuNisTcUeiPYiPvD;

1.28
date	2016.03.06.19.31.31;	author tb;	state Exp;
branches;
next	1.27;
commitid	hMnWEaQXjK0Xik43;

1.27
date	2016.03.06.14.38.19;	author espie;	state Exp;
branches;
next	1.26;
commitid	aZRns7A20ylmMKWi;

1.26
date	2016.03.06.13.40.23;	author natano;	state Exp;
branches;
next	1.25;
commitid	3o8qo2EfcJlpUQi1;

1.25
date	2016.03.05.21.15.41;	author espie;	state Exp;
branches;
next	1.24;
commitid	5Ah4bEn1dBN1CsZU;

1.24
date	2016.03.05.19.29.41;	author natano;	state Exp;
branches;
next	1.23;
commitid	ZeynJQvNXBzhiTyy;

1.23
date	2016.03.05.17.15.43;	author tb;	state Exp;
branches;
next	1.22;
commitid	ilrcM7KQwI12NNV3;

1.22
date	2016.03.05.16.32.54;	author millert;	state Exp;
branches;
next	1.21;
commitid	7eFewKcczbvMMsS8;

1.21
date	2016.03.05.10.47.08;	author espie;	state Exp;
branches;
next	1.20;
commitid	gyjuuktWAp1dPNKY;

1.20
date	2016.03.04.16.48.13;	author natano;	state Exp;
branches;
next	1.19;
commitid	SAN2pEQVjMKQBN9H;

1.19
date	2015.12.18.15.34.27;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	AFhr37Hsdwf3Un5m;

1.18
date	2010.03.27.09.10.02;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.30.13.52.40;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.16.08.49.18;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.08.23.51.33;	author dhill;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.20.06.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.07.18.26.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.28.17.03.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.03.22.05.54;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.04.18.19.40.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.10.04.19.30.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.18.09.59.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.11.16.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.31.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.36;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@delete useless call to setlocale(3);
patch from Jan Stary <hans at stare dot cz>;
OK millert@@ natano@@
@
text
@/*	$OpenBSD: mknod.c,v 1.29 2016/03/07 19:16:06 tb Exp $	*/
/*	$NetBSD: mknod.c,v 1.8 1995/08/11 00:08:18 jtc Exp $	*/

/*
 * Copyright (c) 1997-2016 Theo de Raadt <deraadt@@openbsd.org>,
 *	Marc Espie <espie@@openbsd.org>,	Todd Miller <millert@@openbsd.org>,
 *	Martin Natano <natano@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

extern char *__progname;

struct node {
	const char *name;
	mode_t mode;
	dev_t dev;
	char mflag;
};

static int domakenodes(struct node *, int);
static dev_t compute_device(int, char **);
__dead static void usage(int);

int
main(int argc, char *argv[])
{
	struct node *node;
	int ismkfifo;
	int n = 0;
	int mode = DEFFILEMODE;
	int mflag = 0;
	void *set;
	int ch;

	if (pledge("stdio dpath", NULL) == -1)
		err(1, "pledge");

	node = reallocarray(NULL, sizeof(struct node), argc);
	if (!node)
		err(1, NULL);

	ismkfifo = strcmp(__progname, "mkfifo") == 0;

	/* we parse all arguments upfront */
	while (argc > 1) {
		while ((ch = getopt(argc, argv, "m:")) != -1) {
			switch (ch) {
			case 'm':
				if (!(set = setmode(optarg)))
					errx(1, "invalid file mode '%s'",
					    optarg);
				/*
				 * In symbolic mode strings, the + and -
				 * operators are interpreted relative to
				 * an assumed initial mode of a=rw.
				 */
				mode = getmode(set, DEFFILEMODE);
				if ((mode & ACCESSPERMS) != mode)
					errx(1, "forbidden mode: %o", mode);
				mflag = 1;
				free(set);
				break;
			default:
				usage(ismkfifo);
			}
		}
		argc -= optind;
		argv += optind;

		if (ismkfifo) {
			while (*argv) {
				node[n].mode = mode | S_IFIFO;
				node[n].mflag = mflag;
				node[n].name = *argv;
				node[n].dev = 0;
				n++;
				argv++;
			}
			/* XXX no multiple getopt */
			break;
		} else {
			if (argc < 2)
				usage(ismkfifo);
			node[n].mode = mode;
			node[n].mflag = mflag;
			node[n].name = argv[0];
			if (strlen(argv[1]) != 1)
				errx(1, "invalid device type '%s'", argv[1]);

			/* XXX computation offset by one for next getopt */
			switch(argv[1][0]) {
			case 'p':
				node[n].mode |= S_IFIFO;
				node[n].dev = 0;
				argv++;
				argc--;
				break;
			case 'b':
				node[n].mode |= S_IFBLK;
				goto common;
			case 'c':
				node[n].mode |= S_IFCHR;
common:
				node[n].dev = compute_device(argc, argv);
				argv+=3;
				argc-=3;
				break;
			default:
				errx(1, "invalid device type '%s'", argv[1]);
			}
			n++;
		}
		optind = 1;
		optreset = 1;
	}

	if (n == 0)
		usage(ismkfifo);

	return (domakenodes(node, n));
}

static dev_t
compute_device(int argc, char **argv)
{
	dev_t dev;
	char *endp;
	unsigned long major, minor;

	if (argc < 4)
		usage(0);

	errno = 0;
	major = strtoul(argv[2], &endp, 0);
	if (endp == argv[2] || *endp != '\0')
		errx(1, "invalid major number '%s'", argv[2]);
	if (errno == ERANGE && major == ULONG_MAX)
		errx(1, "major number too large: '%s'", argv[2]);

	errno = 0;
	minor = strtoul(argv[3], &endp, 0);
	if (endp == argv[3] || *endp != '\0')
		errx(1, "invalid minor number '%s'", argv[3]);
	if (errno == ERANGE && minor == ULONG_MAX)
		errx(1, "minor number too large: '%s'", argv[3]);

	dev = makedev(major, minor);
	if (major(dev) != major || minor(dev) != minor)
		errx(1, "major or minor number too large (%lu %lu)", major,
		    minor);

	return dev;
}

static int
domakenodes(struct node *node, int n)
{
	int done_umask = 0;
	int rv = 0;
	int i;

	for (i = 0; i != n; i++) {
		int r;
		/*
		 * If the user specified a mode via `-m', don't allow the umask
		 * to modify it.  If no `-m' flag was specified, the default
		 * mode is the value of the bitwise inclusive or of S_IRUSR,
		 * S_IWUSR, S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH as
		 * modified by the umask.
		 */
		if (node[i].mflag && !done_umask) {
			(void)umask(0);
			done_umask = 1;
		}

		r = mknod(node[i].name, node[i].mode, node[i].dev);
		if (r < 0) {
			warn("%s", node[i].name);
			rv = 1;
		}
	}

	free(node);
	return rv;
}

__dead static void
usage(int ismkfifo)
{

	if (ismkfifo == 1)
		(void)fprintf(stderr, "usage: %s [-m mode] fifo_name ...\n",
		    __progname);
	else {
		(void)fprintf(stderr,
		    "usage: %s [-m mode] name b|c major minor\n",
		    __progname);
		(void)fprintf(stderr, "       %s [-m mode] name p\n",
		    __progname);
	}
	exit(1);
}
@


1.29
log
@Use the full idiom for error checking with strtoul(3), as
exemplified in the man page. Requested by deraadt@@.

Joint work with natano@@
input and ok espie@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.28 2016/03/06 19:31:31 tb Exp $	*/
a27 1
#include <locale.h>
a55 2

	setlocale(LC_ALL, "");
@


1.28
log
@Drop "rpath" promise. Now that pledge() is called after setlocale(),
this is no longer needed.

ok beck@@, natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.27 2016/03/06 14:38:19 espie Exp $	*/
d24 5
a32 2
#include <locale.h>
#include <err.h>
d75 1
a75 1
					errx(1, "invalid file mode '%s'", 
d153 1
a153 1
	u_int major, minor;
d157 3
a159 1
	major = (long)strtoul(argv[2], &endp, 0);
d162 5
a166 1
	minor = (long)strtoul(argv[3], &endp, 0);
d169 3
d174 1
a174 1
		errx(1, "major or minor number too large (%u %u)", major, 
d176 1
@


1.27
log
@my bad. thought it was setlocale "C".
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.26 2016/03/06 13:40:23 natano Exp $	*/
d57 1
a57 1
	if (pledge("stdio rpath dpath", NULL) == -1)
@


1.26
log
@Tighten mknod pledge().

The wpath, cpath and fattr promises are not required for calling mknod(2),
dpath is enough.

ok semarie@@
testing and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.25 2016/03/05 21:15:41 espie Exp $	*/
d55 2
a58 2

	setlocale(LC_ALL, "");
@


1.25
log
@better error messages, common work with natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.24 2016/03/05 19:29:41 natano Exp $	*/
d55 1
a55 1
	if (pledge("stdio rpath wpath cpath dpath fattr", NULL) == -1)
@


1.24
log
@Remove unused node type; ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.23 2016/03/05 17:15:43 tb Exp $	*/
d72 2
a73 1
					errx(1, "invalid file mode.");
d110 1
a110 2
				errx(1, "node must be type 'b|c|p' %s",
				    argv[1]);
d131 1
a131 2
				errx(1, "node must be type 'b|c|p' %s",
				    argv[1]);
d156 1
a156 1
		errx(1, "non-numeric major number.");
d159 1
a159 1
		errx(1, "non-numeric minor number.");
d162 2
a163 1
		errx(1, "major or minor number too large");
@


1.23
log
@Remove debugging code, extra whitespace and a lint annotation.

"just clean it", deraadt@@; ok sha256
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.22 2016/03/05 16:32:54 millert Exp $	*/
a36 1
	char type;
a94 1
				node[n].type = 'p';
a110 1
			node[n].type = argv[1][0];
d113 1
a113 1
			switch(node[n].type) {
d131 2
a132 2
				errx(1, "node must be type 'b|c|p' %c",
				    node[n].type);
@


1.22
log
@Use mknod(2) to create FIFOs by setting S_IFIFO in the mode.
Simplifies the logic in domakenodes() slightly.  OK espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.21 2016/03/05 10:47:08 espie Exp $	*/
a32 1

d65 1
a66 2
	ismkfifo = strcmp(__progname, "mkfifo") == 0;
	
d72 1
a72 1
				if (!(set = setmode(optarg))) {
a73 3
					/* NOTREACHED */
				}

a176 1
#if !defined(CHECK_PARSING_ONLY)
d197 1
a197 6
#else
	for (i = 0; i != n; i++)
		printf("%s %c (mode %o) dev=%d\n", node[i].name,
		    node[i].type, node[i].mode, node[i].dev);
		
#endif
@


1.21
log
@Almost complete rewrite of mknod.

With this, none of the original code survives, so the Copyright notice
can be changed accordingly.

This does pledge upfront, because having fifos or devices with
setuid/gid/sticky makes no sense anyway.

The reorganization was done to allow a "create multiple devices" at once
mode, in order to speed up MAKEDEV (eventually) now that the ksh builtin
is gone.  The code is picky and checks all parameters before doing anything.

Inputs from natano, deraadt, rpe, millert, tb, jmc...

okay tb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.20 2016/03/04 16:48:13 natano Exp $	*/
d99 1
a99 1
				node[n].mode = mode;
d123 1
d197 1
a197 4
		if (node[i].type == 'p')
			r = mkfifo(node[i].name, node[i].mode);
		else
			r = mknod(node[i].name, node[i].mode, node[i].dev);
@


1.20
log
@Invert the pledge() condition.

The only case where we don't want to pledge() is when a mode containing
the suid, sgid or sticky is is passed on the command line. mknod() in a
pledged binary would always strip those bits.

discussion and ok espie@@
ok deraadt@@ semarie@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.19 2015/12/18 15:34:27 deraadt Exp $	*/
d5 3
a7 2
 * Copyright (c) 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
d9 3
a11 2
 * This code is derived from software contributed to Berkeley by
 * Kevin Fall.
d13 7
a19 23
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d33 12
a44 3
int domknod(char **, mode_t);
int domkfifo(char **, mode_t);
void usage(int);
d49 43
a91 15
	int ch, ismkfifo = 0;
	void *set = NULL;
	mode_t mode = DEFFILEMODE;

	setlocale (LC_ALL, "");

	if (strcmp(__progname, "mkfifo") == 0)
		ismkfifo = 1;

	while ((ch = getopt(argc, argv, "m:")) != -1)
		switch (ch) {
		case 'm':
			if (!(set = setmode(optarg))) {
				errx(1, "invalid file mode.");
				/* NOTREACHED */
d93 3
d97 11
a107 7
			/*
			 * In symbolic mode strings, the + and - operators are
			 * interpreted relative to an assumed initial mode of
			 * a=rw.
			 */
			mode = getmode(set, DEFFILEMODE);
			free(set);
d109 33
a141 3
		case '?':
		default:
			usage(ismkfifo);
d143 3
a145 6
	argc -= optind;
	argv += optind;

	if ((mode & ACCESSPERMS) == mode)
		if (pledge("stdio rpath wpath cpath dpath fattr", NULL) == -1)
			err(1, "pledge");
d147 1
a147 1
	if (argv[0] == NULL)
a148 10
	if (!ismkfifo) {
		if (argc == 2 && argv[1][0] == 'p') {
			ismkfifo = 2;
			argc--;
			argv[1] = NULL;
		} else if (argc != 4) {
			usage(ismkfifo);
			/* NOTREACHED */
		}
	}
d150 1
a150 14
	/*
	 * If the user specified a mode via `-m', don't allow the umask
	 * to modify it.  If no `-m' flag was specified, the default
	 * mode is the value of the bitwise inclusive or of S_IRUSR,
	 * S_IWUSR, S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH as modified by
	 * the umask.
	 */
	if (set)
		(void)umask(0);

	if (ismkfifo)
		exit(domkfifo(argv, mode));
	else
		exit(domknod(argv, mode));
d153 2
a154 2
int
domknod(char **argv, mode_t mode)
d160 2
a161 9
	if (argv[1][0] == 'c')
		mode |= S_IFCHR;
	else if (argv[1][0] == 'b')
		mode |= S_IFBLK;
	else {
		errx(1, "node must be type 'b' or 'c'.");
		/* NOTREACHED */
	}

d163 1
a163 1
	if (endp == argv[2] || *endp != '\0') {
a164 2
		/* NOTREACHED */
	}
d166 1
a166 1
	if (endp == argv[3] || *endp != '\0') {
a167 2
		/* NOTREACHED */
	}
d169 1
a169 1
	if (major(dev) != major || minor(dev) != minor) {
d171 1
a171 7
		/* NOTREACHED */
	}
	if (mknod(argv[0], mode, dev) < 0) {
		err(1, "%s", argv[0]);
		/* NOTREACHED */
	}
	return(0);
d174 2
a175 2
int
domkfifo(char **argv, mode_t mode)
d177 18
a194 1
	int rv;
d196 6
a201 3
	for (rv = 0; *argv; ++argv) {
		if (mkfifo(*argv, mode) < 0) {
			warn("%s", *argv);
d205 8
a212 1
	return(rv);
d215 1
a215 1
void
@


1.19
log
@pledge "stdio rpath wpath cpath dpath fattr", as long as the -m option
wasn't used
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.18 2010/03/27 09:10:02 jmc Exp $	*/
d56 1
a56 1
	mode_t mode = 0;
d86 1
a86 1
	if (set)
d105 1
a105 1
	 * to modified it.  If no `-m' flag was specified, the default
a111 2
	else
		mode = DEFFILEMODE;
@


1.18
log
@`b' and `c' arguments to mknod are not optional; from LEVAI Daniel
c_sh.c part from sobrado;

ok millert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.17 2009/10/27 23:59:33 deraadt Exp $	*/
d64 1
a64 1
		switch(ch) {
d85 4
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.16 2007/12/30 13:52:40 sobrado Exp $	*/
d178 1
a178 1
		    "usage: %s [-m mode] name [b | c] major minor\n",
@


1.16
log
@do not repeat "usage:" twice

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.15 2006/12/16 08:49:18 jmc Exp $	*/
a34 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)mknod.c	8.1 (Berkeley) 6/5/93";
#else
static char rcsid[] = "$OpenBSD: mknod.c,v 1.15 2006/12/16 08:49:18 jmc Exp $";
#endif
#endif /* not lint */
@


1.15
log
@various small improvements;
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.14 2006/04/08 23:51:33 dhill Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.14 2006/04/08 23:51:33 dhill Exp $";
d191 2
a192 1
		(void)fprintf(stderr, "usage: %s [-m mode] name [b | c] major minor\n",
d194 1
a194 1
		(void)fprintf(stderr, "usage: %s [-m mode] name p\n",
@


1.14
log
@Remove unused variables.

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.13 2003/06/02 20:06:15 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.13 2003/06/02 20:06:15 millert Exp $";
d188 1
a188 1
		(void)fprintf(stderr, "usage: %s [-m mode] fifoname ...\n",
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.12 2002/07/03 22:32:33 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.12 2002/07/03 22:32:33 deraadt Exp $";
d61 2
a62 2
int domknod(int, char **, mode_t);
int domkfifo(int, char **, mode_t);
d126 1
a126 1
		exit(domkfifo(argc, argv, mode));
d128 1
a128 1
		exit(domknod(argc, argv, mode));
d132 1
a132 1
domknod(int argc, char **argv, mode_t mode)
d170 1
a170 1
domkfifo(int argc, char **argv, mode_t mode)
@


1.12
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.11 2002/06/09 08:13:07 todd Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.11 2002/06/09 08:13:07 todd Exp $";
@


1.11
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.10 2002/02/16 21:27:35 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.10 2002/02/16 21:27:35 millert Exp $";
d70 1
a70 3
main(argc, argv)
	int argc;
	char **argv;
d136 1
a136 4
domknod(argc, argv, mode)
	int argc;
	char **argv;
	mode_t mode;
d174 1
a174 4
domkfifo(argc, argv, mode)
	int argc;
	char **argv;
	mode_t mode;
d188 1
a188 2
usage(ismkfifo)
	int ismkfifo;
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.9 2001/07/07 18:26:14 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.9 2001/07/07 18:26:14 deraadt Exp $";
d187 1
a187 1
		if (mkfifo(*argv, mode) < 0) {  
@


1.9
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.8 2000/02/28 17:03:26 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.8 2000/02/28 17:03:26 millert Exp $";
d65 3
a67 3
int domknod __P((int, char **, mode_t));
int domkfifo __P((int, char **, mode_t));
void usage __P((int));
@


1.8
log
@Use a base of 0 when calling stroul() as per the man page; gagnocg@@ev1.net
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.7 2000/01/03 22:05:54 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.7 2000/01/03 22:05:54 millert Exp $";
d76 1
a76 1
	mode_t mode;
d96 1
a96 1
			mode = getmode (set, DEFFILEMODE);
@


1.7
log
@When a mode is specified via the -m flag, don't allow the umask
to modify the mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.6 1999/04/18 19:40:41 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.6 1999/04/18 19:40:41 millert Exp $";
d156 1
a156 1
	major = (long)strtoul(argv[2], &endp, 10);
d161 1
a161 1
	minor = (long)strtoul(argv[3], &endp, 10);
@


1.6
log
@merge mknod and mkfifo, support 'p' in mknod
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.5 1997/10/04 19:30:16 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.5 1997/10/04 19:30:16 deraadt Exp $";
d96 1
a96 1
			mode = getmode (set, 0666);
d119 11
a129 4
	/* The default mode is the value of the bitwise inclusive or of
	   S_IRUSR, S_IWUSR, S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH */
	if (!set)
		mode = 0666;
@


1.5
log
@freeze strtoul() base to 10
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.4 1997/06/18 09:59:36 deraadt Exp $	*/
d5 1
a5 1
 * Copyright (c) 1989, 1993
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.4 1997/06/18 09:59:36 deraadt Exp $";
d58 1
d60 1
d63 5
a67 1
static void usage();
d74 62
a138 1
	mode_t mode;
d140 1
a140 7
	if (argc != 5) {
		usage();
		/* NOTREACHED */
	}

	mode = 0666;
	if (argv[2][0] == 'c')
d142 1
a142 1
	else if (argv[2][0] == 'b')
d149 2
a150 2
	major = (long)strtoul(argv[3], &endp, 10);
	if (endp == argv[3] || *endp != '\0') {
d154 2
a155 2
	minor = (long)strtoul(argv[4], &endp, 10);
	if (endp == argv[4] || *endp != '\0') {
d164 2
a165 2
	if (mknod(argv[1], mode, dev) < 0) {
		err(1, "%s", argv[1]);
d168 10
d179 7
a185 1
	exit(0);
d189 2
a190 1
usage()
d192 10
a201 1
	fprintf(stderr, "usage: mknod name [b | c] major minor\n");
@


1.4
log
@fix non-numeric minor number checking; bde
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.3 1996/08/02 11:16:47 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.3 1996/08/02 11:16:47 deraadt Exp $";
d88 1
a88 1
	major = (long)strtoul(argv[3], &endp, 0);
d93 1
a93 1
	minor = (long)strtoul(argv[4], &endp, 0);
@


1.3
log
@use strtoul and check errors; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.2 1996/06/23 14:31:03 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.2 1996/06/23 14:31:03 deraadt Exp $";
d94 1
a94 1
	if (endp == argv[3] || *endp != '\0') {
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mknod.c,v 1.8 1995/08/11 00:08:18 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: mknod.c,v 1.8 1995/08/11 00:08:18 jtc Exp $";
d68 3
d88 16
a103 1
	if (mknod(argv[1], mode, makedev(atoi(argv[3]), atoi(argv[4]))) < 0) {
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: mknod.c,v 1.8 1995/08/11 00:08:18 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
