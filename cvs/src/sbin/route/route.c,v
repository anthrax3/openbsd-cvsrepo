head	1.200;
access;
symbols
	OPENBSD_6_1:1.200.0.4
	OPENBSD_6_1_BASE:1.200
	OPENBSD_6_0:1.184.0.2
	OPENBSD_6_0_BASE:1.184
	OPENBSD_5_9:1.182.0.2
	OPENBSD_5_9_BASE:1.182
	OPENBSD_5_8:1.176.0.4
	OPENBSD_5_8_BASE:1.176
	OPENBSD_5_7:1.172.0.2
	OPENBSD_5_7_BASE:1.172
	OPENBSD_5_6:1.169.0.4
	OPENBSD_5_6_BASE:1.169
	OPENBSD_5_5:1.166.0.4
	OPENBSD_5_5_BASE:1.166
	OPENBSD_5_4:1.163.0.2
	OPENBSD_5_4_BASE:1.163
	OPENBSD_5_3:1.160.0.2
	OPENBSD_5_3_BASE:1.160
	OPENBSD_5_2:1.157.0.2
	OPENBSD_5_2_BASE:1.157
	OPENBSD_5_1_BASE:1.155
	OPENBSD_5_1:1.155.0.4
	OPENBSD_5_0:1.155.0.2
	OPENBSD_5_0_BASE:1.155
	OPENBSD_4_9:1.152.0.2
	OPENBSD_4_9_BASE:1.152
	OPENBSD_4_8:1.147.0.2
	OPENBSD_4_8_BASE:1.147
	OPENBSD_4_7:1.141.0.2
	OPENBSD_4_7_BASE:1.141
	OPENBSD_4_6:1.135.0.4
	OPENBSD_4_6_BASE:1.135
	OPENBSD_4_5:1.127.0.2
	OPENBSD_4_5_BASE:1.127
	OPENBSD_4_4:1.119.0.2
	OPENBSD_4_4_BASE:1.119
	OPENBSD_4_3:1.112.0.2
	OPENBSD_4_3_BASE:1.112
	OPENBSD_4_2:1.110.0.2
	OPENBSD_4_2_BASE:1.110
	OPENBSD_4_1:1.104.0.2
	OPENBSD_4_1_BASE:1.104
	OPENBSD_4_0:1.100.0.2
	OPENBSD_4_0_BASE:1.100
	OPENBSD_3_9:1.92.0.2
	OPENBSD_3_9_BASE:1.92
	OPENBSD_3_8:1.91.0.2
	OPENBSD_3_8_BASE:1.91
	OPENBSD_3_7:1.83.0.2
	OPENBSD_3_7_BASE:1.83
	OPENBSD_3_6:1.73.0.2
	OPENBSD_3_6_BASE:1.73
	OPENBSD_3_5:1.63.0.2
	OPENBSD_3_5_BASE:1.63
	OPENBSD_3_4:1.60.0.2
	OPENBSD_3_4_BASE:1.60
	OPENBSD_3_3:1.56.0.2
	OPENBSD_3_3_BASE:1.56
	OPENBSD_3_2:1.50.0.2
	OPENBSD_3_2_BASE:1.50
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9:1.41.0.2
	OPENBSD_2_9_BASE:1.41
	OPENBSD_2_8:1.40.0.2
	OPENBSD_2_8_BASE:1.40
	OPENBSD_2_7:1.37.0.2
	OPENBSD_2_7_BASE:1.37
	OPENBSD_2_6:1.34.0.2
	OPENBSD_2_6_BASE:1.34
	OPENBSD_2_5:1.30.0.2
	OPENBSD_2_5_BASE:1.30
	OPENBSD_2_4:1.27.0.2
	OPENBSD_2_4_BASE:1.27
	OPENBSD_2_3:1.26.0.2
	OPENBSD_2_3_BASE:1.26
	OPENBSD_2_2:1.23.0.2
	OPENBSD_2_2_BASE:1.23
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.200
date	2017.03.23.13.28.25;	author krw;	state Exp;
branches;
next	1.199;
commitid	M00qhayHUh68Okl2;

1.199
date	2017.03.21.06.23.48;	author florian;	state Exp;
branches;
next	1.198;
commitid	2qRDopjrti0gL6F5;

1.198
date	2017.03.20.19.01.38;	author florian;	state Exp;
branches;
next	1.197;
commitid	kLF9C3VQuSyhxH97;

1.197
date	2017.03.02.17.09.21;	author krw;	state Exp;
branches;
next	1.196;
commitid	8FJMneZtCagt8T1v;

1.196
date	2017.01.23.00.10.07;	author krw;	state Exp;
branches;
next	1.195;
commitid	iQ04yZ2y9RiANbVX;

1.195
date	2017.01.19.23.18.29;	author phessler;	state Exp;
branches;
next	1.194;
commitid	blN5b1tPhlkhcTy8;

1.194
date	2017.01.17.19.05.47;	author jca;	state Exp;
branches;
next	1.193;
commitid	KGL0vg1X9zP6laQp;

1.193
date	2016.12.13.08.40.54;	author mpi;	state Exp;
branches;
next	1.192;
commitid	FpLOfKi5ERXgAXWf;

1.192
date	2016.09.24.19.36.49;	author phessler;	state Exp;
branches;
next	1.191;
commitid	T1ckX9pOVXoftCsq;

1.191
date	2016.09.15.12.51.20;	author phessler;	state Exp;
branches;
next	1.190;
commitid	xDnXMPkdJbOtI932;

1.190
date	2016.09.04.09.41.03;	author claudio;	state Exp;
branches;
next	1.189;
commitid	YKJFJUlkAumMxHj6;

1.189
date	2016.09.03.14.23.14;	author phessler;	state Exp;
branches;
next	1.188;
commitid	rJW7JJ1v8NrTSfc8;

1.188
date	2016.09.01.10.41.09;	author bluhm;	state Exp;
branches;
next	1.187;
commitid	q8aiRd0Ix8m0J5rx;

1.187
date	2016.09.01.09.41.34;	author bluhm;	state Exp;
branches;
next	1.186;
commitid	wRPxUwlIhFV2EtnL;

1.186
date	2016.08.31.21.32.06;	author bluhm;	state Exp;
branches;
next	1.185;
commitid	KxHBN8DDpvk5Wp6b;

1.185
date	2016.08.26.06.04.10;	author guenther;	state Exp;
branches;
next	1.184;
commitid	8lcx99ybejNVwA5V;

1.184
date	2016.07.09.20.39.17;	author tedu;	state Exp;
branches;
next	1.183;
commitid	srDOAuoh4bpfvAq4;

1.183
date	2016.06.07.01.29.38;	author tedu;	state Exp;
branches;
next	1.182;
commitid	aJp7bbwjTwgUYbAT;

1.182
date	2015.12.03.08.00.49;	author claudio;	state Exp;
branches;
next	1.181;
commitid	sWv8YKgXNDENyzuU;

1.181
date	2015.11.27.16.26.52;	author benno;	state Exp;
branches;
next	1.180;
commitid	cZfr9cdXdoYfPoYx;

1.180
date	2015.11.20.17.26.56;	author jca;	state Exp;
branches;
next	1.179;
commitid	pGSYOv8xohASlNKN;

1.179
date	2015.10.25.09.37.08;	author deraadt;	state Exp;
branches;
next	1.178;
commitid	9VGdOsmY208WgesJ;

1.178
date	2015.10.23.15.03.25;	author deraadt;	state Exp;
branches;
next	1.177;
commitid	vdJ8Vo9zOOLy1pir;

1.177
date	2015.09.11.20.08.40;	author mpi;	state Exp;
branches;
next	1.176;
commitid	5Sr0XPH2svtKebAw;

1.176
date	2015.07.18.21.26.03;	author mpi;	state Exp;
branches;
next	1.175;
commitid	pr9D6LhB66g1hdwE;

1.175
date	2015.07.18.00.05.02;	author phessler;	state Exp;
branches;
next	1.174;
commitid	w4H9LC8cbuDZ9nOJ;

1.174
date	2015.05.17.00.08.35;	author deraadt;	state Exp;
branches;
next	1.173;
commitid	iow9jGfRfepBECXM;

1.173
date	2015.03.18.22.31.22;	author mpi;	state Exp;
branches;
next	1.172;
commitid	YrnjKRHVUCxCBBIv;

1.172
date	2015.02.06.03.22.00;	author reyk;	state Exp;
branches;
next	1.171;
commitid	2ShTul7wSa8iiu5L;

1.171
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.170;
commitid	Uu5nFG3wCl0LACBb;

1.170
date	2014.08.19.12.39.36;	author mpi;	state Exp;
branches;
next	1.169;
commitid	fCh9nGSviO7kTgAQ;

1.169
date	2014.07.24.17.45.35;	author jca;	state Exp;
branches;
next	1.168;
commitid	VXLfsZtcnUulNR3Z;

1.168
date	2014.06.23.03.46.16;	author guenther;	state Exp;
branches;
next	1.167;
commitid	uXnRK9VvnFZsAqfW;

1.167
date	2014.05.08.09.28.08;	author mpi;	state Exp;
branches;
next	1.166;

1.166
date	2014.01.22.06.23.37;	author claudio;	state Exp;
branches;
next	1.165;

1.165
date	2013.10.28.15.05.35;	author deraadt;	state Exp;
branches;
next	1.164;

1.164
date	2013.10.18.08.38.52;	author bluhm;	state Exp;
branches;
next	1.163;

1.163
date	2013.07.19.20.10.23;	author guenther;	state Exp;
branches;
next	1.162;

1.162
date	2013.05.27.14.07.25;	author sthen;	state Exp;
branches;
next	1.161;

1.161
date	2013.03.21.04.43.17;	author deraadt;	state Exp;
branches;
next	1.160;

1.160
date	2012.12.04.02.30.33;	author deraadt;	state Exp;
branches;
next	1.159;

1.159
date	2012.09.23.13.46.29;	author claudio;	state Exp;
branches;
next	1.158;

1.158
date	2012.08.14.08.49.56;	author chl;	state Exp;
branches;
next	1.157;

1.157
date	2012.07.13.10.15.53;	author benno;	state Exp;
branches;
next	1.156;

1.156
date	2012.03.17.10.16.40;	author dlg;	state Exp;
branches;
next	1.155;

1.155
date	2011.07.04.22.48.31;	author claudio;	state Exp;
branches;
next	1.154;

1.154
date	2011.07.02.22.00.54;	author claudio;	state Exp;
branches;
next	1.153;

1.153
date	2011.04.25.11.14.37;	author sthen;	state Exp;
branches;
next	1.152;

1.152
date	2010.10.25.19.39.55;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2010.10.11.11.45.00;	author claudio;	state Exp;
branches;
next	1.150;

1.150
date	2010.09.21.10.58.23;	author krw;	state Exp;
branches;
next	1.149;

1.149
date	2010.09.04.08.06.09;	author blambert;	state Exp;
branches;
next	1.148;

1.148
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.147;

1.147
date	2010.07.14.01.23.04;	author dlg;	state Exp;
branches;
next	1.146;

1.146
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.145;

1.145
date	2010.06.27.07.57.59;	author guenther;	state Exp;
branches;
next	1.144;

1.144
date	2010.05.19.13.11.25;	author claudio;	state Exp;
branches;
next	1.143;

1.143
date	2010.05.19.10.30.27;	author claudio;	state Exp;
branches;
next	1.142;

1.142
date	2010.03.23.15.01.50;	author claudio;	state Exp;
branches;
next	1.141;

1.141
date	2009.12.01.16.21.46;	author reyk;	state Exp;
branches;
next	1.140;

1.140
date	2009.11.02.21.08.44;	author claudio;	state Exp;
branches;
next	1.139;

1.139
date	2009.11.02.17.57.06;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2009.09.14.11.45.48;	author claudio;	state Exp;
branches;
next	1.137;

1.137
date	2009.07.23.14.23.06;	author sthen;	state Exp;
branches;
next	1.136;

1.136
date	2009.07.23.14.19.52;	author claudio;	state Exp;
branches;
next	1.135;

1.135
date	2009.06.27.11.35.57;	author michele;	state Exp;
branches;
next	1.134;

1.134
date	2009.06.25.15.42.24;	author claudio;	state Exp;
branches;
next	1.133;

1.133
date	2009.06.06.20.30.22;	author claudio;	state Exp;
branches;
next	1.132;

1.132
date	2009.05.31.18.02.28;	author claudio;	state Exp;
branches;
next	1.131;

1.131
date	2009.05.30.21.06.34;	author claudio;	state Exp;
branches;
next	1.130;

1.130
date	2009.05.30.20.03.31;	author claudio;	state Exp;
branches;
next	1.129;

1.129
date	2009.05.30.19.50.28;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2009.04.28.12.09.35;	author michele;	state Exp;
branches;
next	1.127;

1.127
date	2009.02.03.16.44.15;	author michele;	state Exp;
branches;
next	1.126;

1.126
date	2009.01.29.11.21.34;	author michele;	state Exp;
branches;
next	1.125;

1.125
date	2009.01.28.22.19.53;	author michele;	state Exp;
branches;
next	1.124;

1.124
date	2009.01.08.12.52.35;	author michele;	state Exp;
branches;
next	1.123;

1.123
date	2008.12.16.16.21.09;	author sthen;	state Exp;
branches;
next	1.122;

1.122
date	2008.12.15.16.14.57;	author michele;	state Exp;
branches;
next	1.121;

1.121
date	2008.12.12.20.26.30;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2008.09.15.20.12.11;	author claudio;	state Exp;
branches;
next	1.119;

1.119
date	2008.05.09.07.14.56;	author henning;	state Exp;
branches;
next	1.118;

1.118
date	2008.05.09.06.52.47;	author henning;	state Exp;
branches;
next	1.117;

1.117
date	2008.05.07.06.06.25;	author claudio;	state Exp;
branches;
next	1.116;

1.116
date	2008.05.06.12.53.32;	author claudio;	state Exp;
branches;
next	1.115;

1.115
date	2008.05.06.03.45.33;	author claudio;	state Exp;
branches;
next	1.114;

1.114
date	2008.05.06.03.44.14;	author claudio;	state Exp;
branches;
next	1.113;

1.113
date	2008.04.28.11.36.14;	author norby;	state Exp;
branches;
next	1.112;

1.112
date	2007.09.25.08.57.47;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2007.09.05.20.30.21;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2007.06.04.12.23.43;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.30.01.08.41;	author mcbride;	state Exp;
branches;
next	1.108;

1.108
date	2007.03.25.16.10.35;	author claudio;	state Exp;
branches;
next	1.107;

1.107
date	2007.03.23.20.33.10;	author jmc;	state Exp;
branches;
next	1.106;

1.106
date	2007.03.23.16.02.26;	author pyr;	state Exp;
branches;
next	1.105;

1.105
date	2007.03.23.13.43.32;	author claudio;	state Exp;
branches;
next	1.104;

1.104
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.103;

1.103
date	2006.11.28.16.48.13;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.101;

1.101
date	2006.10.15.09.44.25;	author mcbride;	state Exp;
branches;
next	1.100;

1.100
date	2006.06.17.17.16.04;	author pascoe;	state Exp;
branches;
next	1.99;

1.99
date	2006.06.16.17.46.43;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2006.06.16.16.55.19;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2006.05.27.18.26.45;	author claudio;	state Exp;
branches;
next	1.96;

1.96
date	2006.05.21.13.27.08;	author mpf;	state Exp;
branches;
next	1.95;

1.95
date	2006.04.20.11.21.17;	author claudio;	state Exp;
branches;
next	1.94;

1.94
date	2006.03.30.12.11.37;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2006.03.30.09.56.06;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2005.12.11.12.33.43;	author aaron;	state Exp;
branches;
next	1.91;

1.91
date	2005.06.09.08.07.45;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2005.06.06.04.22.28;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2005.05.27.22.38.52;	author mcbride;	state Exp;
branches;
next	1.88;

1.88
date	2005.05.27.04.55.27;	author mcbride;	state Exp;
branches;
next	1.87;

1.87
date	2005.03.30.07.59.03;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2005.03.30.05.34.30;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2005.03.30.05.29.04;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2005.03.30.05.20.18;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2005.02.18.04.00.21;	author jaredy;	state Exp;
branches;
next	1.82;

1.82
date	2005.02.17.17.02.24;	author jaredy;	state Exp;
branches;
next	1.81;

1.81
date	2004.10.14.15.20.56;	author jaredy;	state Exp;
branches;
next	1.80;

1.80
date	2004.10.13.22.54.35;	author jaredy;	state Exp;
branches;
next	1.79;

1.79
date	2004.09.26.19.46.01;	author jaredy;	state Exp;
branches;
next	1.78;

1.78
date	2004.09.24.14.35.15;	author jaredy;	state Exp;
branches;
next	1.77;

1.77
date	2004.09.24.01.24.30;	author jaredy;	state Exp;
branches;
next	1.76;

1.76
date	2004.09.23.20.20.19;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2004.09.22.01.07.10;	author jaredy;	state Exp;
branches;
next	1.74;

1.74
date	2004.09.15.23.40.29;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2004.09.07.10.14.43;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2004.08.03.11.23.11;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.06.25.01.26.01;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.19.19.55.53;	author cedric;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.12.09.40.49;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.09.19.32.08;	author cedric;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.06.17.08.23;	author cedric;	state Exp;
branches;
next	1.66;

1.66
date	2004.05.15.07.43.34;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.26.06.24.20;	author cedric;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.07.09.43.00;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.18.12.26.16;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.15.10.50.49;	author markus;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.09.10.01.57;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2003.08.26.08.33.12;	author itojun;	state Exp;
branches;
next	1.59;

1.59
date	2003.07.02.21.44.58;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.26.16.35.21;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2003.03.13.09.09.27;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.11.02.32.31;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.31.17.51.16;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.11.24.20.56.24;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2002.10.18.00.27.41;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2002.10.17.20.38.03;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.10.21.19.24;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.08.18.53.42;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.05.22.14.15;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.04.22.22.37;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.26.09.24.35;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.20.23.06.27;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2001.07.07.18.26.20;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.11.17.51.56;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.27.03.23.31;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.24.01.02.24;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2000.08.03.07.01.32;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2000.07.27.20.12.25;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.20.12.26.35;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.22.20.25.06;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	99.12.08.07.55.54;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	99.09.22.05.10.04;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	99.08.17.09.13.15;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	99.07.29.22.14.33;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	99.07.28.09.47.22;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	99.02.24.22.56.01;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	99.01.08.00.38.30;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.12.20.23.47.52;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	98.09.21.08.31.46;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.12.12.09.06.08;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.12.12.09.04.33;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.11.16.18.42.35;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.07.13.23.12.09;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	97.06.24.04.05.38;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.06.24.03.45.43;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.06.24.03.15.23;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.06.04.10.36.16;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.04.10.10.09.02;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.01.15.23.41.40;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	96.12.22.03.00.53;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.12.14.18.41.37;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.12.14.17.36.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.12.14.17.23.54;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.11.25.03.57.56;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.10.27.15.11.10;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.10.27.14.53.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.09.03.07.29.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.08.16.09.26.11;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.08.15.19.06.09;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.05.11.53.41;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.02.15.39.28;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.14.32.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.47.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.08.07.32.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.200
log
@Fix printf() incantation for non-NULL terminated string.

Pointed out by florian@@.

ok bluhm@@
@
text
@/*	$OpenBSD: route.c,v 1.199 2017/03/21 06:23:48 florian Exp $	*/
/*	$NetBSD: route.c,v 1.16 1996/04/15 18:27:05 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netmpls/mpls.h>

#ifdef BFD
#include <sys/time.h>
#include <net/bfd.h>
#endif

#include <arpa/inet.h>
#include <netdb.h>

#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <limits.h>
#include <stdio.h>
#include <ctype.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <paths.h>
#include <err.h>

#include "keywords.h"
#include "show.h"

const struct if_status_description
			if_status_descriptions[] = LINK_STATE_DESCRIPTIONS;

union sockunion so_dst, so_gate, so_mask, so_ifa, so_ifp, so_label, so_src;

typedef union sockunion *sup;
pid_t	pid;
int	rtm_addrs, s;
int	forcehost, forcenet, Fflag, nflag, af, qflag, tflag, Tflag;
int	iflag, verbose, aflen = sizeof(struct sockaddr_in);
int	locking, lockrest, debugonly;
u_long	mpls_flags = MPLS_OP_LOCAL;
u_long	rtm_inits;
uid_t	uid;
u_int	tableid;

struct rt_metrics	rt_metrics;

int	 flushroutes(int, char **);
int	 newroute(int, char **);
int	 show(int, char *[]);
int	 keycmp(const void *, const void *);
int	 keyword(char *);
void	 monitor(int, char *[]);
int	 prefixlen(char *);
void	 sockaddr(char *, struct sockaddr *);
void	 sodump(sup, char *);
char	*priorityname(uint8_t);
uint8_t	 getpriority(char *);
void	 print_getmsg(struct rt_msghdr *, int);
#ifdef BFD
const char *bfd_state(unsigned int);
const char *bfd_diag(unsigned int);
const char *bfd_calc_uptime(time_t);
void	 print_bfdmsg(struct rt_msghdr *);
void	 print_sabfd(struct sockaddr_bfd *, int);
#endif
const char *get_linkstate(int, int);
void	 print_rtmsg(struct rt_msghdr *, int);
void	 pmsg_common(struct rt_msghdr *);
void	 pmsg_addrs(char *, int);
void	 bprintf(FILE *, int, char *);
void	 mask_addr(union sockunion *, union sockunion *, int);
int	 inet6_makenetandmask(struct sockaddr_in6 *, char *);
int	 getaddr(int, char *, struct hostent **);
void	 getmplslabel(char *, int);
int	 rtmsg(int, int, int, uint8_t);
__dead void usage(char *);
void	 set_metric(char *, int);
void	 inet_makenetandmask(u_int32_t, struct sockaddr_in *, int);
void	 interfaces(void);
void	 getlabel(char *);
int	 gettable(const char *);
int	 rdomain(int, char **);
void	 print_rtdns(struct sockaddr_rtdns *);
void	 print_rtstatic(struct sockaddr_rtstatic *);
void	 print_rtsearch(struct sockaddr_rtsearch *);

__dead void
usage(char *cp)
{
	extern char *__progname;

	if (cp)
		warnx("botched keyword: %s", cp);
	fprintf(stderr,
	    "usage: %s [-dnqtv] [-T tableid] command [[modifiers] args]\n",
	    __progname);
	fprintf(stderr,
	    "commands: add, change, delete, exec, flush, get, monitor, show\n");
	exit(1);
}

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

int
main(int argc, char **argv)
{
	int ch;
	int rval = 0;
	int kw;
	int Terr = 0;

	if (argc < 2)
		usage(NULL);

	tableid = getrtable();
	while ((ch = getopt(argc, argv, "dnqtT:v")) != -1)
		switch (ch) {
		case 'n':
			nflag = 1;
			break;
		case 'q':
			qflag = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		case 't':
			tflag = 1;
			break;
		case 'T':
			Terr = gettable(optarg);
			Tflag = 1;
			break;
		case 'd':
			debugonly = 1;
			break;
		default:
			usage(NULL);
			/* NOTREACHED */
		}
	argc -= optind;
	argv += optind;

	pid = getpid();
	uid = geteuid();
	if (*argv == NULL)
		usage(NULL);

	kw = keyword(*argv);
	if (Tflag && Terr != 0 && kw != K_ADD) {
		errno = Terr;
		err(1, "routing table %d", tableid);
	}
	if (kw == K_EXEC)
		exit(rdomain(argc - 1, argv + 1));

	s = socket(PF_ROUTE, SOCK_RAW, 0);
	if (s == -1)
		err(1, "socket");
	if (kw == K_MONITOR) {
		unsigned int filter = 0;
		int af = 0;

		while (--argc > 0) {
			if (**(++argv)== '-')
				switch (keyword(*argv + 1)) {
				case K_INET:
					af = AF_INET;
					break;
				case K_INET6:
					af = AF_INET6;
					break;
				case K_IFACE:
				case K_INTERFACE:
					filter = ROUTE_FILTER(RTM_IFINFO) |
					    ROUTE_FILTER(RTM_IFANNOUNCE);
					break;
				default:
					usage(*argv);
					/* NOTREACHED */
				}
			else
				usage(*argv);
		}
		if (setsockopt(s, AF_ROUTE, ROUTE_MSGFILTER, &filter,
		    sizeof(filter)) == -1)
			err(1, "setsockopt(ROUTE_MSGFILTER)");
	}
	/* force socket onto table user requested */
	if (Tflag == 1 && Terr == 0 &&
	    setsockopt(s, AF_ROUTE, ROUTE_TABLEFILTER,
	    &tableid, sizeof(tableid)) == -1)
		err(1, "setsockopt(ROUTE_TABLEFILTER)");

	switch (kw) {
	case K_SHOW:
		uid = 0;
		exit(show(argc, argv));
		break;
	case K_FLUSH:
		exit(flushroutes(argc, argv));
		break;
	}

	if (pledge("stdio rpath dns", NULL) == -1)
		err(1, "pledge");

	switch (kw) {
	case K_GET:
		uid = 0;
		/* FALLTHROUGH */
	case K_CHANGE:
	case K_ADD:
	case K_DELETE:
		rval = newroute(argc, argv);
		break;
	case K_MONITOR:
		monitor(argc, argv);
		break;
	default:
		usage(*argv);
		/* NOTREACHED */
	}
	exit(rval);
}

/*
 * Purge all entries in the routing tables not
 * associated with network interfaces.
 */
int
flushroutes(int argc, char **argv)
{
	size_t needed;
	int mib[7], rlen, seqno;
	char *buf = NULL, *next, *lim = NULL;
	struct rt_msghdr *rtm;
	struct sockaddr *sa;
	uint8_t prio = 0;
	unsigned int ifindex = 0;

	if (uid)
		errx(1, "must be root to alter routing table");
	shutdown(s, SHUT_RD); /* Don't want to read back our messages */
	while (--argc > 0) {
		if (**(++argv) == '-')
			switch (keyword(*argv + 1)) {
			case K_INET:
				af = AF_INET;
				break;
			case K_INET6:
				af = AF_INET6;
				break;
			case K_LINK:
				af = AF_LINK;
				break;
			case K_MPLS:
				af = AF_MPLS;
				break;
			case K_IFACE:
			case K_INTERFACE:
				if (!--argc)
					usage(1+*argv);
				ifindex = if_nametoindex(*++argv);
				if (ifindex == 0)
					errx(1, "no such interface %s", *argv);
				break;
			case K_PRIORITY:
				if (!--argc)
					usage(1+*argv);
				prio = getpriority(*++argv);
				break;
			default:
				usage(*argv);
				/* NOTREACHED */
			}
		else
			usage(*argv);
	}
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;		/* protocol */
	mib[3] = 0;		/* wildcard address family */
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;		/* no flags */
	mib[6] = tableid;
	while (1) {
		if (sysctl(mib, 7, NULL, &needed, NULL, 0) == -1)
			err(1, "route-sysctl-estimate");
		if (needed == 0)
			break;
		if ((buf = realloc(buf, needed)) == NULL)
			err(1, "realloc");
		if (sysctl(mib, 7, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			err(1, "actual retrieval of routing table");
		}
		lim = buf + needed;
		break;
	}

	if (pledge("stdio rpath dns", NULL) == -1)
		err(1, "pledge");

	if (verbose) {
		printf("Examining routing table from sysctl\n");
		if (af)
			printf("(address family %s)\n", (*argv + 1));
	}
	if (buf == NULL)
		return (1);

	seqno = 0;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		if (verbose)
			print_rtmsg(rtm, rtm->rtm_msglen);
		if ((rtm->rtm_flags & (RTF_GATEWAY|RTF_STATIC|RTF_LLINFO)) == 0)
			continue;
		if ((rtm->rtm_flags & (RTF_LOCAL|RTF_BROADCAST)) != 0)
			continue;
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		if (af && sa->sa_family != af)
			continue;
		if (ifindex && rtm->rtm_index != ifindex)
			continue;
		if (prio && rtm->rtm_priority != prio)
			continue;
		if (sa->sa_family == AF_KEY)
			continue;  /* Don't flush SPD */
		if (debugonly)
			continue;
		rtm->rtm_type = RTM_DELETE;
		rtm->rtm_seq = seqno;
		rtm->rtm_tableid = tableid;
		rlen = write(s, next, rtm->rtm_msglen);
		if (rlen < (int)rtm->rtm_msglen) {
			warn("write to routing socket");
			printf("got only %d for rlen\n", rlen);
			break;
		}
		seqno++;
		if (qflag)
			continue;
		if (verbose)
			print_rtmsg(rtm, rlen);
		else {
			struct sockaddr	*mask, *rti_info[RTAX_MAX];

			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);

			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

			sa = rti_info[RTAX_DST];
			mask = rti_info[RTAX_NETMASK];

			p_sockaddr(sa, mask, rtm->rtm_flags, 20);
			p_sockaddr(rti_info[RTAX_GATEWAY], NULL, RTF_HOST, 20);
			printf("done\n");
		}
	}
	free(buf);
	return (0);
}

void
set_metric(char *value, int key)
{
	long long relative_expire;
	const char *errstr;
	int flag = 0;

	switch (key) {
	case K_MTU:
		rt_metrics.rmx_mtu = strtonum(value, 0, UINT_MAX, &errstr);
		if (errstr)
			errx(1, "set_metric mtu: %s is %s", value, errstr);
		flag = RTV_MTU;
		break;
	case K_EXPIRE:
		relative_expire = strtonum(value, 0, INT_MAX, &errstr);
		if (errstr)
			errx(1, "set_metric expire: %s is %s", value, errstr);
		rt_metrics.rmx_expire = relative_expire ?
		    relative_expire + time(NULL) : 0;
		flag = RTV_EXPIRE;
		break;
	case K_HOPCOUNT:
	case K_RECVPIPE:
	case K_SENDPIPE:
	case K_SSTHRESH:
	case K_RTT:
	case K_RTTVAR:
		/* no longer used, only for compatibility */
		return;
	default:
		errx(1, "king bula sez: set_metric with invalid key");
	}
	rtm_inits |= flag;
	if (lockrest || locking)
		rt_metrics.rmx_locks |= flag;
	if (locking)
		locking = 0;
}

int
newroute(int argc, char **argv)
{
	char *cmd, *dest = "", *gateway = "", *error;
	int ishost = 0, ret = 0, attempts, oerrno, flags = RTF_STATIC;
	int fmask = 0;
	int key;
	uint8_t prio = 0;
	struct hostent *hp = NULL;

	if (uid)
		errx(1, "must be root to alter routing table");
	cmd = argv[0];
	if (*cmd != 'g')
		shutdown(s, SHUT_RD); /* Don't want to read back our messages */
	while (--argc > 0) {
		if (**(++argv)== '-') {
			switch (key = keyword(1 + *argv)) {
			case K_LINK:
				af = AF_LINK;
				aflen = sizeof(struct sockaddr_dl);
				break;
			case K_INET:
				af = AF_INET;
				aflen = sizeof(struct sockaddr_in);
				break;
			case K_INET6:
				af = AF_INET6;
				aflen = sizeof(struct sockaddr_in6);
				break;
			case K_SA:
				af = PF_ROUTE;
				aflen = sizeof(union sockunion);
				break;
			case K_MPLS:
				af = AF_MPLS;
				aflen = sizeof(struct sockaddr_mpls);
				fmask |= RTF_MPLS;
				break;
			case K_MPLSLABEL:
				if (!--argc)
					usage(1+*argv);
				if (af != AF_INET && af != AF_INET6)
					errx(1, "-mplslabel requires "
					    "-inet or -inet6");
				getmplslabel(*++argv, 0);
				mpls_flags = MPLS_OP_PUSH;
				flags |= RTF_MPLS;
				break;
			case K_IN:
				if (!--argc)
					usage(1+*argv);
				if (af != AF_MPLS)
					errx(1, "-in requires -mpls");
				getmplslabel(*++argv, 1);
				break;
			case K_OUT:
				if (!--argc)
					usage(1+*argv);
				if (af != AF_MPLS)
					errx(1, "-out requires -mpls");
				if (mpls_flags == MPLS_OP_LOCAL)
					errx(1, "-out requires -push, -pop, "
					    "-swap");
				getmplslabel(*++argv, 0);
				flags |= RTF_MPLS;
				break;
			case K_POP:
				if (af != AF_MPLS)
					errx(1, "-pop requires -mpls");
				mpls_flags = MPLS_OP_POP;
				break;
			case K_PUSH:
				if (af != AF_MPLS)
					errx(1, "-push requires -mpls");
				mpls_flags = MPLS_OP_PUSH;
				break;
			case K_SWAP:
				if (af != AF_MPLS)
					errx(1, "-swap requires -mpls");
				mpls_flags = MPLS_OP_SWAP;
				break;
			case K_IFACE:
			case K_INTERFACE:
				iflag++;
				break;
			case K_NOSTATIC:
				flags &= ~RTF_STATIC;
				break;
			case K_LLINFO:
				flags |= RTF_LLINFO;
				break;
			case K_LOCK:
				locking = 1;
				break;
			case K_LOCKREST:
				lockrest = 1;
				break;
			case K_HOST:
				forcehost++;
				break;
			case K_REJECT:
				flags |= RTF_REJECT;
				break;
			case K_BLACKHOLE:
				flags |= RTF_BLACKHOLE;
				break;
			case K_PROTO1:
				flags |= RTF_PROTO1;
				break;
			case K_PROTO2:
				flags |= RTF_PROTO2;
				break;
			case K_CLONING:
				flags |= RTF_CLONING;
				break;
			case K_STATIC:
				flags |= RTF_STATIC;
				break;
			case K_IFA:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_IFA, *++argv, NULL);
				break;
			case K_IFP:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_IFP, *++argv, NULL);
				break;
			case K_GATEWAY:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_GATEWAY, *++argv, NULL);
				gateway = *argv;
				break;
			case K_DST:
				if (!--argc)
					usage(1+*argv);
				ishost = getaddr(RTA_DST, *++argv, &hp);
				dest = *argv;
				break;
			case K_LABEL:
				if (!--argc)
					usage(1+*argv);
				getlabel(*++argv);
				break;
			case K_NETMASK:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_NETMASK, *++argv, NULL);
				/* FALLTHROUGH */
			case K_NET:
				forcenet++;
				break;
			case K_PREFIXLEN:
				if (!--argc)
					usage(1+*argv);
				ishost = prefixlen(*++argv);
				break;
			case K_MPATH:
				flags |= RTF_MPATH;
				break;
			case K_MTU:
			case K_HOPCOUNT:
			case K_EXPIRE:
			case K_RECVPIPE:
			case K_SENDPIPE:
			case K_SSTHRESH:
			case K_RTT:
			case K_RTTVAR:
				if (!--argc)
					usage(1+*argv);
				set_metric(*++argv, key);
				break;
			case K_PRIORITY:
				if (!--argc)
					usage(1+*argv);
				prio = getpriority(*++argv);
				break;
			case K_BFD:
				flags |= RTF_BFD;
				fmask |= RTF_BFD;
				break;
			case K_NOBFD:
				flags &= ~RTF_BFD;
				fmask |= RTF_BFD;
				break;
			default:
				usage(1+*argv);
				/* NOTREACHED */
			}
		} else {
			if ((rtm_addrs & RTA_DST) == 0) {
				dest = *argv;
				ishost = getaddr(RTA_DST, *argv, &hp);
			} else if ((rtm_addrs & RTA_GATEWAY) == 0) {
				gateway = *argv;
				getaddr(RTA_GATEWAY, *argv, &hp);
			} else
				usage(NULL);
		}
	}
	if (forcehost)
		ishost = 1;
	if (forcenet)
		ishost = 0;
	if (forcenet && !(rtm_addrs & RTA_NETMASK))
		errx(1, "netmask missing");
	flags |= RTF_UP;
	if (ishost)
		flags |= RTF_HOST;
	if (iflag == 0)
		flags |= RTF_GATEWAY;
	for (attempts = 1; ; attempts++) {
		errno = 0;
		if ((ret = rtmsg(*cmd, flags, fmask, prio)) == 0)
			break;
		if (errno != ENETUNREACH && errno != ESRCH)
			break;
		if (af == AF_INET && *gateway && hp && hp->h_addr_list[1]) {
			hp->h_addr_list++;
			memcpy(&so_gate.sin.sin_addr, hp->h_addr_list[0],
			    hp->h_length);
		} else
			break;
	}
	if (*cmd == 'g') {
		if (ret != 0 && qflag == 0)
			warn("writing to routing socket");
		exit(0);
	}
	oerrno = errno;
	if (!qflag) {
		printf("%s %s %s", cmd, ishost ? "host" : "net", dest);
		if (*gateway) {
			printf(": gateway %s", gateway);
			if (attempts > 1 && ret == 0 && af == AF_INET)
			    printf(" (%s)", inet_ntoa(so_gate.sin.sin_addr));
		}
		if (ret == 0)
			printf("\n");
		if (ret != 0) {
			switch (oerrno) {
			case ESRCH:
				error = "not in table";
				break;
			case EBUSY:
				error = "entry in use";
				break;
			case ENOBUFS:
				error = "routing table overflow";
				break;
			default:
				error = strerror(oerrno);
				break;
			}
			printf(": %s\n", error);
		}
	}
	return (ret != 0);
}

int
show(int argc, char *argv[])
{
	int		 af = 0;
	char		 prio = 0;

	while (--argc > 0) {
		if (**(++argv)== '-')
			switch (keyword(*argv + 1)) {
			case K_INET:
				af = AF_INET;
				break;
			case K_INET6:
				af = AF_INET6;
				break;
			case K_LINK:
				af = AF_LINK;
				break;
			case K_MPLS:
				af = AF_MPLS;
				break;
			case K_GATEWAY:
				Fflag = 1;
				break;
			case K_LABEL:
				if (!--argc)
					usage(1+*argv);
				getlabel(*++argv);
				break;
			case K_PRIORITY:
				if (!--argc)
					usage(1+*argv);
				prio = getpriority(*++argv);
				break;
			default:
				usage(*argv);
				/* NOTREACHED */
			}
		else
			usage(*argv);
	}

	p_rttables(af, tableid, Tflag, prio);
	return (0);
}

void
inet_makenetandmask(u_int32_t net, struct sockaddr_in *sin, int bits)
{
	u_int32_t addr, mask = 0;
	char *cp;

	rtm_addrs |= RTA_NETMASK;
	if (net == 0 && bits == 0)
		mask = addr = 0;
	else if (bits) {
		addr = net;
		mask = 0xffffffff << (32 - bits);
	} else if (net < 128) {
		addr = net << IN_CLASSA_NSHIFT;
		mask = IN_CLASSA_NET;
	} else if (net < 65536) {
		addr = net << IN_CLASSB_NSHIFT;
		mask = IN_CLASSB_NET;
	} else if (net < 16777216L) {
		addr = net << IN_CLASSC_NSHIFT;
		mask = IN_CLASSC_NET;
	} else {
		addr = net;
		if ((addr & IN_CLASSA_HOST) == 0)
			mask = IN_CLASSA_NET;
		else if ((addr & IN_CLASSB_HOST) == 0)
			mask = IN_CLASSB_NET;
		else if ((addr & IN_CLASSC_HOST) == 0)
			mask = IN_CLASSC_NET;
		else
			mask = 0xffffffff;
	}
	addr &= mask;
	sin->sin_addr.s_addr = htonl(addr);
	sin = &so_mask.sin;
	sin->sin_addr.s_addr = htonl(mask);
	sin->sin_len = 0;
	sin->sin_family = 0;
	cp = (char *)(&sin->sin_addr + 1);
	while (*--cp == '\0' && cp > (char *)sin)
		continue;
	sin->sin_len = 1 + cp - (char *)sin;
}

/*
 * XXX the function may need more improvement...
 */
int
inet6_makenetandmask(struct sockaddr_in6 *sin6, char *plen)
{
	struct in6_addr in6;
	const char *errstr;
	int i, len, q, r;

	if (NULL==plen) {
		if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) &&
		    sin6->sin6_scope_id == 0) {
			plen = "0";
		} else if ((sin6->sin6_addr.s6_addr[0] & 0xe0) == 0x20) {
			/* aggregatable global unicast - RFC2374 */
			memset(&in6, 0, sizeof(in6));
			if (!memcmp(&sin6->sin6_addr.s6_addr[8],
			    &in6.s6_addr[8], 8))
				plen = "64";
		}
	}

	if (!plen || strcmp(plen, "128") == 0)
		return (1);
	else {
		rtm_addrs |= RTA_NETMASK;
		prefixlen(plen);

		len = strtonum(plen, 0, 128, &errstr);
		if (errstr)
			errx(1, "prefixlen %s is %s", plen, errstr);

		q = (128-len) >> 3;
		r = (128-len) & 7;
		i = 15;

		while (q-- > 0)
			sin6->sin6_addr.s6_addr[i--] = 0;
		if (r > 0)
			sin6->sin6_addr.s6_addr[i] &= 0xff << r;

		return (0);
	}
}

/*
 * Interpret an argument as a network address of some kind,
 * returning 1 if a host address, 0 if a network address.
 */
int
getaddr(int which, char *s, struct hostent **hpp)
{
	sup su = NULL;
	struct hostent *hp;
	struct netent *np;
	int afamily, bits;

	if (af == 0) {
		if (strchr(s, ':') != NULL) {
			af = AF_INET6;
			aflen = sizeof(struct sockaddr_in6);
		} else {
			af = AF_INET;
			aflen = sizeof(struct sockaddr_in);
		}
	}
	afamily = af;	/* local copy of af so we can change it */

	rtm_addrs |= which;
	switch (which) {
	case RTA_DST:
		su = &so_dst;
		break;
	case RTA_GATEWAY:
		su = &so_gate;
		break;
	case RTA_NETMASK:
		su = &so_mask;
		break;
	case RTA_IFP:
		su = &so_ifp;
		afamily = AF_LINK;
		break;
	case RTA_IFA:
		su = &so_ifa;
		break;
	default:
		errx(1, "internal error");
		/* NOTREACHED */
	}
	su->sa.sa_len = aflen;
	su->sa.sa_family = afamily;

	if (strcmp(s, "default") == 0) {
		switch (which) {
		case RTA_DST:
			forcenet++;
			getaddr(RTA_NETMASK, s, NULL);
			break;
		case RTA_NETMASK:
			su->sa.sa_len = 0;
		}
		return (0);
	}

	switch (afamily) {
	case AF_INET6:
	    {
		struct addrinfo hints, *res;
		char            buf[
		   sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255:255:255:255/128")
		];
		char           *sep;

		if (strlcpy(buf, s, sizeof buf) >= sizeof buf) {
			errx(1, "%s: bad value", s);
		}

		sep = strchr(buf, '/');
		if (sep != NULL)
			*sep++ = '\0';
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = afamily;	/*AF_INET6*/
		hints.ai_flags = AI_NUMERICHOST;
		hints.ai_socktype = SOCK_DGRAM;		/*dummy*/
		if (getaddrinfo(buf, "0", &hints, &res) != 0) {
			hints.ai_flags = 0;
			if (getaddrinfo(buf, "0", &hints, &res) != 0)
				errx(1, "%s: bad value", s);
		}
		if (sizeof(su->sin6) != res->ai_addrlen)
			errx(1, "%s: bad value", s);
		if (res->ai_next)
			errx(1, "%s: resolved to multiple values", s);
		memcpy(&su->sin6, res->ai_addr, sizeof(su->sin6));
		freeaddrinfo(res);
		if ((IN6_IS_ADDR_LINKLOCAL(&su->sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_LINKLOCAL(&su->sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_INTFACELOCAL(&su->sin6.sin6_addr)) &&
		    su->sin6.sin6_scope_id) {
			*(u_int16_t *)&su->sin6.sin6_addr.s6_addr[2] =
				htons(su->sin6.sin6_scope_id);
			su->sin6.sin6_scope_id = 0;
		}
		if (hints.ai_flags == AI_NUMERICHOST) {
			if (which == RTA_DST)
				return (inet6_makenetandmask(&su->sin6, sep));
			return (0);
		} else
			return (1);
	    }

	case AF_LINK:
		su->sdl.sdl_index = if_nametoindex(s);
		memset(&su->sdl.sdl_data, 0, sizeof(su->sdl.sdl_data));
		return (1);
	case AF_MPLS:
		errx(1, "mpls labels require -in or -out switch");
	case PF_ROUTE:
		su->sa.sa_len = sizeof(*su);
		sockaddr(s, &su->sa);
		return (1);

	case AF_INET:
		if (hpp != NULL)
			*hpp = NULL;
		if (which == RTA_DST && !forcehost) {
			bits = inet_net_pton(AF_INET, s, &su->sin.sin_addr,
			    sizeof(su->sin.sin_addr));
			if (bits == 32)
				return (1);
			if (bits >= 0) {
				inet_makenetandmask(ntohl(
				    su->sin.sin_addr.s_addr),
				    &su->sin, bits);
				return (0);
			}
			np = getnetbyname(s);
			if (np != NULL && np->n_net != 0) {
				inet_makenetandmask(np->n_net, &su->sin, 0);
				return (0);
			}
			if (forcenet)
				errx(1, "%s: not a network", s);
		}
		if (inet_pton(AF_INET, s, &su->sin.sin_addr) == 1)
			return (1);
		hp = gethostbyname(s);
		if (hp != NULL) {
			if (hpp != NULL)
				*hpp = hp;
			su->sin.sin_addr = *(struct in_addr *)hp->h_addr;
			return (1);
		}
		errx(1, "%s: bad address", s);
		/* NOTREACHED */

	default:
		errx(1, "%d: bad address family", afamily);
		/* NOTREACHED */
	}
}

void
getmplslabel(char *s, int in)
{
	sup su = NULL;
	const char *errstr;
	u_int32_t label;

	label = strtonum(s, 0, 0x000fffff, &errstr);
	if (errstr)
		errx(1, "bad label: %s is %s", s, errstr);
	if (in) {
		rtm_addrs |= RTA_DST;
		su = &so_dst;
		su->smpls.smpls_label = htonl(label << MPLS_LABEL_OFFSET);
	} else {
		rtm_addrs |= RTA_SRC;
		su = &so_src;
		su->smpls.smpls_label = htonl(label << MPLS_LABEL_OFFSET);
	}

	su->sa.sa_len = sizeof(struct sockaddr_mpls);
	su->sa.sa_family = AF_MPLS;
}

int
prefixlen(char *s)
{
	const char *errstr;
	int len, q, r;
	int max;

	switch (af) {
	case AF_INET:
		max = sizeof(struct in_addr) * 8;
		break;
	case AF_INET6:
		max = sizeof(struct in6_addr) * 8;
		break;
	default:
		errx(1, "prefixlen is not supported with af %d", af);
		/* NOTREACHED */
	}

	rtm_addrs |= RTA_NETMASK;
	len = strtonum(s, 0, max, &errstr);
	if (errstr)
		errx(1, "prefixlen %s is %s", s, errstr);

	q = len >> 3;
	r = len & 7;
	switch (af) {
	case AF_INET:
		memset(&so_mask, 0, sizeof(so_mask));
		so_mask.sin.sin_family = AF_INET;
		so_mask.sin.sin_len = sizeof(struct sockaddr_in);
		so_mask.sin.sin_addr.s_addr = htonl(0xffffffff << (32 - len));
		break;
	case AF_INET6:
		so_mask.sin6.sin6_family = AF_INET6;
		so_mask.sin6.sin6_len = sizeof(struct sockaddr_in6);
		memset((void *)&so_mask.sin6.sin6_addr, 0,
			sizeof(so_mask.sin6.sin6_addr));
		if (q > 0)
			memset((void *)&so_mask.sin6.sin6_addr, 0xff, q);
		if (r > 0)
			*((u_char *)&so_mask.sin6.sin6_addr + q) =
			    (0xff00 >> r) & 0xff;
		break;
	}
	return (len == max);
}

void
interfaces(void)
{
	size_t needed;
	int mib[6];
	char *buf = NULL, *lim, *next;
	struct rt_msghdr *rtm;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;		/* protocol */
	mib[3] = 0;		/* wildcard address family */
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;		/* no flags */
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
		err(1, "route-sysctl-estimate");
	if (needed) {
		if ((buf = malloc(needed)) == NULL)
			err(1, "malloc");
		if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
			err(1, "actual retrieval of interface table");
		lim = buf + needed;
		for (next = buf; next < lim; next += rtm->rtm_msglen) {
			rtm = (struct rt_msghdr *)next;
			print_rtmsg(rtm, rtm->rtm_msglen);
		}
		free(buf);
	}
}

void
monitor(int argc, char *argv[])
{
	int n;
	char msg[2048];
	time_t now;

	if (pledge("stdio rpath dns", NULL) == -1)
		err(1, "pledge");

	verbose = 1;
	if (debugonly) {
		interfaces();
		exit(0);
	}
	for (;;) {
		if ((n = read(s, msg, sizeof(msg))) == -1) {
			if (errno == EINTR)
				continue;
			err(1, "read");
		}
		now = time(NULL);
		printf("got message of size %d on %s", n, ctime(&now));
		print_rtmsg((struct rt_msghdr *)msg, n);
	}
}

struct {
	struct rt_msghdr	m_rtm;
	char			m_space[512];
} m_rtmsg;

int
rtmsg(int cmd, int flags, int fmask, uint8_t prio)
{
	static int seq;
	char *cp = m_rtmsg.m_space;
	int l;

#define NEXTADDR(w, u)				\
	if (rtm_addrs & (w)) {			\
		l = ROUNDUP(u.sa.sa_len);	\
		memcpy(cp, &(u), l);		\
		cp += l;			\
		if (verbose)			\
			sodump(&(u), #u);	\
	}

	errno = 0;
	memset(&m_rtmsg, 0, sizeof(m_rtmsg));
	if (cmd == 'a')
		cmd = RTM_ADD;
	else if (cmd == 'c')
		cmd = RTM_CHANGE;
	else if (cmd == 'g') {
		cmd = RTM_GET;
		if (so_ifp.sa.sa_family == 0) {
			so_ifp.sa.sa_family = AF_LINK;
			so_ifp.sa.sa_len = sizeof(struct sockaddr_dl);
			rtm_addrs |= RTA_IFP;
		}
	} else
		cmd = RTM_DELETE;
#define rtm m_rtmsg.m_rtm
	rtm.rtm_type = cmd;
	rtm.rtm_flags = flags;
	rtm.rtm_fmask = fmask;
	rtm.rtm_version = RTM_VERSION;
	rtm.rtm_seq = ++seq;
	rtm.rtm_addrs = rtm_addrs;
	rtm.rtm_rmx = rt_metrics;
	rtm.rtm_inits = rtm_inits;
	rtm.rtm_tableid = tableid;
	rtm.rtm_priority = prio;
	rtm.rtm_mpls = mpls_flags;
	rtm.rtm_hdrlen = sizeof(rtm);

	if (rtm_addrs & RTA_NETMASK)
		mask_addr(&so_dst, &so_mask, RTA_DST);
	NEXTADDR(RTA_DST, so_dst);
	NEXTADDR(RTA_GATEWAY, so_gate);
	NEXTADDR(RTA_NETMASK, so_mask);
	NEXTADDR(RTA_IFP, so_ifp);
	NEXTADDR(RTA_IFA, so_ifa);
	NEXTADDR(RTA_LABEL, so_label);
	NEXTADDR(RTA_SRC, so_src);
	rtm.rtm_msglen = l = cp - (char *)&m_rtmsg;
	if (verbose)
		print_rtmsg(&rtm, l);
	if (debugonly)
		return (0);
	if (write(s, &m_rtmsg, l) != l) {
		return (-1);
	}
	if (cmd == RTM_GET) {
		do {
			l = read(s, &m_rtmsg, sizeof(m_rtmsg));
		} while (l > 0 && (rtm.rtm_version != RTM_VERSION ||
		    rtm.rtm_seq != seq || rtm.rtm_pid != pid));
		if (l == -1)
			warn("read from routing socket");
		else
			print_getmsg(&rtm, l);
	}
#undef rtm
	return (0);
}

void
mask_addr(union sockunion *addr, union sockunion *mask, int which)
{
	int olen = mask->sa.sa_len;
	char *cp1 = olen + (char *)mask, *cp2;

	for (mask->sa.sa_len = 0; cp1 > (char *)mask; )
		if (*--cp1 != '\0') {
			mask->sa.sa_len = 1 + cp1 - (char *)mask;
			break;
		}
	if ((rtm_addrs & which) == 0)
		return;
	switch (addr->sa.sa_family) {
	case AF_INET:
	case AF_INET6:
	case 0:
		return;
	}
	cp1 = mask->sa.sa_len + 1 + (char *)addr;
	cp2 = addr->sa.sa_len + 1 + (char *)addr;
	while (cp2 > cp1)
		*--cp2 = '\0';
	cp2 = mask->sa.sa_len + 1 + (char *)mask;
	while (cp1 > addr->sa.sa_data)
		*--cp1 &= *--cp2;
}

char *msgtypes[] = {
	"",
	"RTM_ADD: Add Route",
	"RTM_DELETE: Delete Route",
	"RTM_CHANGE: Change Metrics or flags",
	"RTM_GET: Report Metrics",
	"RTM_LOSING: Kernel Suspects Partitioning",
	"RTM_REDIRECT: Told to use different route",
	"RTM_MISS: Lookup failed on this address",
	"RTM_LOCK: fix specified metrics",
	"RTM_OLDADD: caused by SIOCADDRT",
	"RTM_OLDDEL: caused by SIOCDELRT",
	"RTM_RESOLVE: Route created by cloning",
	"RTM_NEWADDR: address being added to iface",
	"RTM_DELADDR: address being removed from iface",
	"RTM_IFINFO: iface status change",
	"RTM_IFANNOUNCE: iface arrival/departure",
	"RTM_DESYNC: route socket overflow",
	"RTM_INVALIDATE: invalidate cache of L2 route",
	"RTM_BFD: bidirectional forwarding detection",
	"RTM_PROPOSAL: config proposal"
};

char metricnames[] =
"\011priority\010rttvar\7rtt\6ssthresh\5sendpipe\4recvpipe\3expire\2hopcount\1mtu";
char routeflags[] =
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010XMASK_PRESENT"
"\011CLONING\012MULTICAST\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2"
"\020PROTO1\021CLONED\022CACHED\023MPATH\025MPLS\026LOCAL\027BROADCAST"
"\030CONNECTED\031BFD";
char ifnetflags[] =
"\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5PTP\6NOTRAILERS\7RUNNING\010NOARP\011PPROMISC"
"\012ALLMULTI\013OACTIVE\014SIMPLEX\015LINK0\016LINK1\017LINK2\020MULTICAST";
char addrnames[] =
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD\011SRC\012SRCMASK\013LABEL\014BFD\015DNS\016STATIC\017SEARCH";

const char *
get_linkstate(int mt, int link_state)
{
	const struct if_status_description *p;
	static char buf[8];

	for (p = if_status_descriptions; p->ifs_string != NULL; p++) {
		if (LINK_STATE_DESC_MATCH(p, mt, link_state))
			return (p->ifs_string);
	}
	snprintf(buf, sizeof(buf), "[#%d]", link_state);
	return buf;
}

void
print_rtmsg(struct rt_msghdr *rtm, int msglen)
{
	long long relative_expire;
	struct if_msghdr *ifm;
	struct ifa_msghdr *ifam;
	struct if_announcemsghdr *ifan;
	char ifname[IF_NAMESIZE];

	if (verbose == 0)
		return;
	if (rtm->rtm_version != RTM_VERSION) {
		warnx("routing message version %d not understood",
		    rtm->rtm_version);
		return;
	}
	if (rtm->rtm_type > 0 &&
	    rtm->rtm_type < sizeof(msgtypes)/sizeof(msgtypes[0]))
		printf("%s", msgtypes[rtm->rtm_type]);
	else
		printf("[rtm_type %d out of range]", rtm->rtm_type);

	printf(": len %d", rtm->rtm_msglen);
	switch (rtm->rtm_type) {
	case RTM_DESYNC:
		printf("\n");
		break;
	case RTM_IFINFO:
		ifm = (struct if_msghdr *)rtm;
		(void) printf(", if# %d, ", ifm->ifm_index);
		if (if_indextoname(ifm->ifm_index, ifname) != NULL)
			printf("name: %s, ", ifname);
		printf("link: %s, mtu: %u, flags:",
		    get_linkstate(ifm->ifm_data.ifi_type,
		        ifm->ifm_data.ifi_link_state),
		    ifm->ifm_data.ifi_mtu);
		bprintf(stdout, ifm->ifm_flags, ifnetflags);
		pmsg_addrs((char *)ifm + ifm->ifm_hdrlen, ifm->ifm_addrs);
		break;
	case RTM_NEWADDR:
	case RTM_DELADDR:
		ifam = (struct ifa_msghdr *)rtm;
		printf(", metric %d, flags:", ifam->ifam_metric);
		bprintf(stdout, ifam->ifam_flags, routeflags);
		pmsg_addrs((char *)ifam + ifam->ifam_hdrlen, ifam->ifam_addrs);
		break;
	case RTM_IFANNOUNCE:
		ifan = (struct if_announcemsghdr *)rtm;
		printf(", if# %d, name %s, what: ",
		    ifan->ifan_index, ifan->ifan_name);
		switch (ifan->ifan_what) {
		case IFAN_ARRIVAL:
			printf("arrival");
			break;
		case IFAN_DEPARTURE:
			printf("departure");
			break;
		default:
			printf("#%d", ifan->ifan_what);
			break;
		}
		printf("\n");
		break;
#ifdef BFD
	case RTM_BFD:
		print_bfdmsg(rtm);
		break;
#endif
	case RTM_PROPOSAL:
		printf(", source ");
		switch (rtm->rtm_priority) {
		case RTP_PROPOSAL_STATIC:
			printf("static");
			break;
		case RTP_PROPOSAL_DHCLIENT:
			printf("dhcp");
			break;
		case RTP_PROPOSAL_SLAAC:
			printf("slaac");
			break;
		default:
			printf("unknown");
			break;
		}
		printf(" table %u, ifidx %u, ",
		    rtm->rtm_tableid, rtm->rtm_index);
		printf("pid: %ld, seq %d, errno %d\nflags:",
		    (long)rtm->rtm_pid, rtm->rtm_seq, rtm->rtm_errno);
		bprintf(stdout, rtm->rtm_flags, routeflags);
		printf("\nfmask:");
		bprintf(stdout, rtm->rtm_fmask, routeflags);
		if (verbose) {
#define lock(f)	((rtm->rtm_rmx.rmx_locks & __CONCAT(RTV_,f)) ? 'L' : ' ')
			relative_expire = rtm->rtm_rmx.rmx_expire ?
			    rtm->rtm_rmx.rmx_expire - time(NULL) : 0;
			printf("\nuse: %8llu   mtu: %8u%c   expire: %8lld%c",
			    rtm->rtm_rmx.rmx_pksent,
			    rtm->rtm_rmx.rmx_mtu, lock(MTU),
			    relative_expire, lock(EXPIRE));
#undef lock
		}
		printf("\nlocks: ");
		bprintf(stdout, rtm->rtm_rmx.rmx_locks, metricnames);
		printf(" inits: ");
		bprintf(stdout, rtm->rtm_inits, metricnames);
		pmsg_addrs(((char *)rtm + rtm->rtm_hdrlen),
		   rtm->rtm_addrs & ~(RTA_STATIC | RTA_SEARCH | RTA_DNS));
		printf("Static Routes:\n");
		if (rtm->rtm_addrs & RTA_STATIC) {
			char *next = (char *)rtm + rtm->rtm_hdrlen;
			struct sockaddr	*sa, *rti_info[RTAX_MAX];
			struct sockaddr_rtstatic *rtstatic;
			sa = (struct sockaddr *)next;
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
			rtstatic = (struct sockaddr_rtstatic *)
			    rti_info[RTAX_STATIC];
			if (rtstatic != NULL) {
				printf(" ");
				print_rtstatic(rtstatic);
			}
		}
		printf("Domain search:\n");
		if (rtm->rtm_addrs & RTA_SEARCH) {
			char *next = (char *)rtm + rtm->rtm_hdrlen;
			struct sockaddr	*sa, *rti_info[RTAX_MAX];
			struct sockaddr_rtsearch *rtsearch;
			sa = (struct sockaddr *)next;
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
			rtsearch = (struct sockaddr_rtsearch *)
			    rti_info[RTAX_SEARCH];
			if (rtsearch != NULL) {
				printf(" ");
				print_rtsearch(rtsearch);
			}
		}
		printf("Domain Name Servers:\n");
		if (rtm->rtm_addrs & RTA_DNS) {
			char *next = (char *)rtm + rtm->rtm_hdrlen;
			struct sockaddr	*sa, *rti_info[RTAX_MAX];
			struct sockaddr_rtdns *rtdns;
			sa = (struct sockaddr *)next;
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
			rtdns = (struct sockaddr_rtdns *)rti_info[RTAX_DNS];
			if (rtdns != NULL) {
				printf(" ");
				print_rtdns(rtdns);
			}
		}
		break;
	default:
		printf(", priority %d, table %u, ifidx %u, ",
		    rtm->rtm_priority, rtm->rtm_tableid, rtm->rtm_index);
		printf("pid: %ld, seq %d, errno %d\nflags:",
		    (long)rtm->rtm_pid, rtm->rtm_seq, rtm->rtm_errno);
		bprintf(stdout, rtm->rtm_flags, routeflags);
		printf("\nfmask:");
		bprintf(stdout, rtm->rtm_fmask, routeflags);
		if (verbose) {
#define lock(f)	((rtm->rtm_rmx.rmx_locks & __CONCAT(RTV_,f)) ? 'L' : ' ')
			relative_expire = rtm->rtm_rmx.rmx_expire ?
			    rtm->rtm_rmx.rmx_expire - time(NULL) : 0;
			printf("\nuse: %8llu   mtu: %8u%c   expire: %8lld%c",
			    rtm->rtm_rmx.rmx_pksent,
			    rtm->rtm_rmx.rmx_mtu, lock(MTU),
			    relative_expire, lock(EXPIRE));
#undef lock
		}
		pmsg_common(rtm);
	}
}

char *
priorityname(uint8_t prio)
{
	switch (prio) {
	case RTP_NONE:
		return ("none");
	case RTP_LOCAL:
		return ("local");
	case RTP_CONNECTED:
		return ("connected");
	case RTP_STATIC:
		return ("static");
	case RTP_OSPF:
		return ("ospf");
	case RTP_ISIS:
		return ("is-is");
	case RTP_RIP:
		return ("rip");
	case RTP_BGP:
		return ("bgp");
	case RTP_DEFAULT:
		return ("default");
	default:
		return ("");
	}
}

uint8_t
getpriority(char *priostr)
{
	const char *errstr;
	uint8_t prio;

	switch (keyword(priostr)) {
	case K_LOCAL:
		prio = RTP_LOCAL;
		break;
	case K_CONNECTED:
		prio = RTP_CONNECTED;
		break;
	case K_STATIC:
		prio = RTP_STATIC;
		break;
	case K_OSPF:
		prio = RTP_OSPF;
		break;
	case K_RIP:
		prio = RTP_RIP;
		break;
	case K_BGP:
		prio = RTP_BGP;
		break;
	default:
		prio = strtonum(priostr, -RTP_MAX, RTP_MAX, &errstr);
		if (errstr)
			errx(1, "priority is %s: %s", errstr, priostr);
	}

	return (prio);
}

void
print_getmsg(struct rt_msghdr *rtm, int msglen)
{
	long long relative_expire;
	struct sockaddr *dst = NULL, *gate = NULL, *mask = NULL, *ifa = NULL;
	struct sockaddr_dl *ifp = NULL;
	struct sockaddr_rtlabel *sa_rl = NULL;
#ifdef BFD
	struct sockaddr_bfd *sa_bfd = NULL;
#endif
	struct sockaddr *mpls = NULL;
	struct sockaddr *sa;
	char *cp;
	int i;

	printf("   route to: %s\n", routename(&so_dst.sa));
	if (rtm->rtm_version != RTM_VERSION) {
		warnx("routing message version %d not understood",
		    rtm->rtm_version);
		return;
	}
	if (rtm->rtm_msglen > msglen)
		warnx("message length mismatch, in packet %d, returned %d",
		    rtm->rtm_msglen, msglen);
	if (rtm->rtm_errno) {
		warnx("RTM_GET: %s (errno %d)",
		    strerror(rtm->rtm_errno), rtm->rtm_errno);
		return;
	}
	cp = ((char *)rtm + rtm->rtm_hdrlen);
	if (rtm->rtm_addrs)
		for (i = 1; i; i <<= 1)
			if (i & rtm->rtm_addrs) {
				sa = (struct sockaddr *)cp;
				switch (i) {
				case RTA_DST:
					dst = sa;
					break;
				case RTA_GATEWAY:
					gate = sa;
					break;
				case RTA_NETMASK:
					mask = sa;
					break;
				case RTA_IFA:
					ifa = sa;
					break;
				case RTA_IFP:
					if (sa->sa_family == AF_LINK &&
					   ((struct sockaddr_dl *)sa)->sdl_nlen)
						ifp = (struct sockaddr_dl *)sa;
					break;
				case RTA_SRC:
					mpls = sa;
					break;
				case RTA_LABEL:
					sa_rl = (struct sockaddr_rtlabel *)sa;
					break;
#ifdef BFD
				case RTA_BFD:
					sa_bfd = (struct sockaddr_bfd *)sa;
					break;
#endif
				}
				ADVANCE(cp, sa);
			}
	if (dst && mask)
		mask->sa_family = dst->sa_family;	/* XXX */
	if (dst)
		printf("destination: %s\n", routename(dst));
	if (mask) {
		int savenflag = nflag;

		nflag = 1;
		printf("       mask: %s\n", routename(mask));
		nflag = savenflag;
	}
	if (gate && rtm->rtm_flags & RTF_GATEWAY)
		printf("    gateway: %s\n", routename(gate));
	if (ifp)
		printf("  interface: %.*s\n",
		    ifp->sdl_nlen, ifp->sdl_data);
	if (ifa)
		printf(" if address: %s\n", routename(ifa));
	if (mpls) {
		printf(" mpls label: %s %s\n", mpls_op(rtm->rtm_mpls),
		    routename(mpls));
	}
	printf("   priority: %u (%s)\n", rtm->rtm_priority,
	   priorityname(rtm->rtm_priority));
	printf("      flags: ");
	bprintf(stdout, rtm->rtm_flags, routeflags);
	printf("\n");
	if (sa_rl != NULL)
		printf("      label: %s\n", sa_rl->sr_label);
#ifdef BFD
	if (sa_bfd)
		print_sabfd(sa_bfd, rtm->rtm_fmask);
#endif

#define lock(f)	((rtm->rtm_rmx.rmx_locks & __CONCAT(RTV_,f)) ? 'L' : ' ')
	relative_expire = rtm->rtm_rmx.rmx_expire ?
	    rtm->rtm_rmx.rmx_expire - time(NULL) : 0;
	printf("     use       mtu    expire\n");
	printf("%8llu  %8u%c %8lld%c\n",
	    rtm->rtm_rmx.rmx_pksent,
	    rtm->rtm_rmx.rmx_mtu, lock(MTU),
	    relative_expire, lock(EXPIRE));
#undef lock
#define	RTA_IGN	(RTA_DST|RTA_GATEWAY|RTA_NETMASK|RTA_IFP|RTA_IFA|RTA_BRD)
	if (verbose)
		pmsg_common(rtm);
	else if (rtm->rtm_addrs &~ RTA_IGN) {
		printf("sockaddrs: ");
		bprintf(stdout, rtm->rtm_addrs, addrnames);
		putchar('\n');
	}
#undef	RTA_IGN
}

#ifdef BFD
const char *
bfd_state(unsigned int state)
{
	switch (state) {
	case BFD_STATE_ADMINDOWN:
		return("admindown");
		break;
	case BFD_STATE_DOWN:
		return("down");
		break;
	case BFD_STATE_INIT:
		return("init");
		break;
	case BFD_STATE_UP:
		return("up");
		break;
	}
	return "invalid";
}

const char *
bfd_diag(unsigned int diag)
{
	switch (diag) {
	case BFD_DIAG_NONE:
		return("none");
		break;
	case BFD_DIAG_EXPIRED:
		return("expired");
		break;
	case BFD_DIAG_ECHO_FAILED:
		return("echo-failed");
		break;
	case BFD_DIAG_NEIGHBOR_SIGDOWN:
		return("neighbor-down");
		break;
	case BFD_DIAG_FIB_RESET:
		return("fib-reset");
		break;
	case BFD_DIAG_PATH_DOWN:
		return("path-down");
		break;
	case BFD_DIAG_CONCAT_PATH_DOWN:
		return("concat-path-down");
		break;
	case BFD_DIAG_ADMIN_DOWN:
		return("admindown");
		break;
	case BFD_DIAG_CONCAT_REVERSE_DOWN:
		return("concat-reverse-down");
		break;
	}
	return "invalid";
}

const char *
bfd_calc_uptime(time_t time)
{
	static char buf[256];
	struct tm *tp;
	const char *fmt;

	if (time > 2*86400)
		fmt = "%dd%kh%Mm%Ss";
	else if (time > 2*3600)
		fmt = "%kh%Mm%Ss";
	else if (time > 2*60)
		fmt = "%Mm%Ss";
	else
		fmt = "%Ss";

	tp = localtime(&time);
	(void)strftime(buf, sizeof(buf), fmt, tp);
	return (buf);
}

void
print_bfdmsg(struct rt_msghdr *rtm)
{
	struct bfd_msghdr *bfdm = (struct bfd_msghdr *)rtm;

	printf("\n");
	print_sabfd(&bfdm->bm_sa, rtm->rtm_fmask);
	pmsg_addrs(((char *)rtm + rtm->rtm_hdrlen), rtm->rtm_addrs);
}

void
print_sabfd(struct sockaddr_bfd *sa_bfd, int fmask)
{
	struct timeval tv;

	gettimeofday(&tv, NULL);

	printf("        BFD:");

	/* only show the state, unless verbose or -bfd */
	if (!verbose && ((fmask & RTF_BFD) != RTF_BFD)) {
		printf(" %s\n", bfd_state(sa_bfd->bs_state));
		return;
	}

	switch (sa_bfd->bs_mode) {
	case BFD_MODE_ASYNC:
		printf(" async");
		break;
	case BFD_MODE_DEMAND:
		printf(" demand");
		break;
	default:
		printf(" unknown %u", sa_bfd->bs_mode);
		break;
	}

	printf(" state %s", bfd_state(sa_bfd->bs_state));
	printf(" remote %s", bfd_state(sa_bfd->bs_remotestate));
	printf(" laststate %s", bfd_state(sa_bfd->bs_laststate));

	printf(" error %d", sa_bfd->bs_error);
	printf("\n            ");
	printf(" diag %s", bfd_diag(sa_bfd->bs_localdiag));
	printf(" remote %s", bfd_diag(sa_bfd->bs_remotediag));
	printf("\n            ");
	printf(" discr %u", sa_bfd->bs_localdiscr);
	printf(" remote %u", sa_bfd->bs_remotediscr);
	printf("\n            ");
	printf(" uptime %s", bfd_calc_uptime(tv.tv_sec - sa_bfd->bs_uptime));
	if (sa_bfd->bs_lastuptime)
		printf(" last state time %s",
		    bfd_calc_uptime(sa_bfd->bs_lastuptime));
	printf("\n            ");
	printf(" mintx %u", sa_bfd->bs_mintx);
	printf(" minrx %u", sa_bfd->bs_minrx);
	printf(" minecho %u", sa_bfd->bs_minecho);
	printf(" multiplier %u", sa_bfd->bs_multiplier);
	printf("\n");
}
#endif /* BFD */

void
pmsg_common(struct rt_msghdr *rtm)
{
	printf("\nlocks: ");
	bprintf(stdout, rtm->rtm_rmx.rmx_locks, metricnames);
	printf(" inits: ");
	bprintf(stdout, rtm->rtm_inits, metricnames);
	pmsg_addrs(((char *)rtm + rtm->rtm_hdrlen), rtm->rtm_addrs);
}

void
pmsg_addrs(char *cp, int addrs)
{
	struct sockaddr *sa;
	int family = AF_UNSPEC;
	int i;
	char *p;

	if (addrs != 0) {
		printf("\nsockaddrs: ");
		bprintf(stdout, addrs, addrnames);
		putchar('\n');
		/* first run, search for address family */
		p = cp;
		for (i = 1; i; i <<= 1)
			if (i & addrs) {
				sa = (struct sockaddr *)p;
				if (family == AF_UNSPEC)
					switch (i) {
					case RTA_DST:
					case RTA_IFA:
						family = sa->sa_family;
					}
				ADVANCE(p, sa);
			}
		/* second run, set address family for mask and print */
		p = cp;
		for (i = 1; i; i <<= 1)
			if (i & addrs) {
				sa = (struct sockaddr *)p;
				if (family != AF_UNSPEC)
					switch (i) {
					case RTA_NETMASK:
						sa->sa_family = family;
					}
				printf(" %s", routename(sa));
				ADVANCE(p, sa);
			}
	}
	putchar('\n');
	fflush(stdout);
}

void
bprintf(FILE *fp, int b, char *s)
{
	int i;
	int gotsome = 0;

	if (b == 0)
		return;
	while ((i = *s++)) {
		if ((b & (1 << (i-1)))) {
			if (gotsome == 0)
				i = '<';
			else
				i = ',';
			putc(i, fp);
			gotsome = 1;
			for (; (i = *s) > 32; s++)
				putc(i, fp);
		} else
			while (*s > 32)
				s++;
	}
	if (gotsome)
		putc('>', fp);
}

int
keycmp(const void *key, const void *kt)
{
	return (strcmp(key, ((struct keytab *)kt)->kt_cp));
}

int
keyword(char *cp)
{
	struct keytab *kt;

	kt = bsearch(cp, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), keycmp);
	if (!kt)
		return (0);

	return (kt->kt_i);
}

void
sodump(sup su, char *which)
{
	switch (su->sa.sa_family) {
	case AF_LINK:
		printf("%s: link %s; ", which, link_ntoa(&su->sdl));
		break;
	case AF_INET:
		printf("%s: inet %s; ", which, inet_ntoa(su->sin.sin_addr));
		break;
	case AF_INET6:
	    {
		char ntop_buf[NI_MAXHOST];

		printf("%s: inet6 %s; ",
		    which, inet_ntop(AF_INET6, &su->sin6.sin6_addr,
		    ntop_buf, sizeof(ntop_buf)));
		break;
	    }
	}
	fflush(stdout);
}

/* States*/
#define VIRGIN	0
#define GOTONE	1
#define GOTTWO	2
/* Inputs */
#define	DIGIT	(4*0)
#define	END	(4*1)
#define DELIM	(4*2)

void
sockaddr(char *addr, struct sockaddr *sa)
{
	char *cp = (char *)sa;
	int size = sa->sa_len;
	char *cplim = cp + size;
	int byte = 0, state = VIRGIN, new = 0;

	memset(cp, 0, size);
	cp++;
	do {
		if ((*addr >= '0') && (*addr <= '9')) {
			new = *addr - '0';
		} else if ((*addr >= 'a') && (*addr <= 'f')) {
			new = *addr - 'a' + 10;
		} else if ((*addr >= 'A') && (*addr <= 'F')) {
			new = *addr - 'A' + 10;
		} else if (*addr == '\0')
			state |= END;
		else
			state |= DELIM;
		addr++;
		switch (state /* | INPUT */) {
		case GOTTWO | DIGIT:
			*cp++ = byte; /*FALLTHROUGH*/
		case VIRGIN | DIGIT:
			state = GOTONE; byte = new; continue;
		case GOTONE | DIGIT:
			state = GOTTWO; byte = new + (byte << 4); continue;
		default: /* | DELIM */
			state = VIRGIN; *cp++ = byte; byte = 0; continue;
		case GOTONE | END:
		case GOTTWO | END:
			*cp++ = byte; /* FALLTHROUGH */
		case VIRGIN | END:
			break;
		}
		break;
	} while (cp < cplim);
	sa->sa_len = cp - (char *)sa;
}

void
getlabel(char *name)
{
	so_label.rtlabel.sr_len = sizeof(so_label.rtlabel);
	so_label.rtlabel.sr_family = AF_UNSPEC;
	if (strlcpy(so_label.rtlabel.sr_label, name,
	    sizeof(so_label.rtlabel.sr_label)) >=
	    sizeof(so_label.rtlabel.sr_label))
		errx(1, "label too long");
	rtm_addrs |= RTA_LABEL;
}

int
gettable(const char *s)
{
	const char		*errstr;
	struct rt_tableinfo      info;
	int			 mib[6];
	size_t			 len;

	tableid = strtonum(s, 0, RT_TABLEID_MAX, &errstr);
	if (errstr)
		errx(1, "invalid table id: %s", errstr);

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_TABLE;
	mib[5] = tableid;

	len = sizeof(info);
	if (sysctl(mib, 6, &info, &len, NULL, 0) == -1)
		return (errno);
	else
		return (0);
}

int
rdomain(int argc, char **argv)
{
	if (!argc)
		usage(NULL);
	if (setrtable(tableid) == -1)
		err(1, "setrtable");
	execvp(*argv, argv);
	warn("%s", argv[0]);
	return (errno == ENOENT ? 127 : 126);
}

/*
 * Print RTM_PROPOSAL DNS server addresses.
 */
void
print_rtdns(struct sockaddr_rtdns *rtdns)
{
	struct in_addr	 server;
	struct in6_addr	 in6;
	size_t		 srclen, offset;
	unsigned int	 servercnt;
	int		 i;
	char		*src = rtdns->sr_dns;
	char		 ntopbuf[INET6_ADDRSTRLEN];

	offset = offsetof(struct sockaddr_rtdns, sr_dns);
	if (rtdns->sr_len <= offset) {
		printf("<invalid sr_len (%d <= %zu)>\n", rtdns->sr_len,
		    offset);
		return;
	}
	srclen = rtdns->sr_len - offset;
	if (srclen > sizeof(rtdns->sr_dns)) {
		printf("<invalid sr_len (%zu > %zu)>\n", srclen,
		    sizeof(rtdns->sr_dns));
		return;
	}

	switch (rtdns->sr_family) {
	case AF_INET:
		/* An array of IPv4 addresses. */
		servercnt = srclen / sizeof(struct in_addr);
		if (servercnt * sizeof(struct in_addr) != srclen) {
			printf("<invalid server count>\n");
			return;
		}
		for (i = 0; i < servercnt; i++) {
			memcpy(&server.s_addr, src, sizeof(server.s_addr));
			printf("%s ", inet_ntoa(server));
			src += sizeof(struct in_addr);
		}
		break;
	case AF_INET6:
		servercnt = srclen / sizeof(struct in6_addr);
		if (servercnt * sizeof(struct in6_addr) != srclen) {
			printf("<invalid server count>\n");
			return;
		}
		for (i = 0; i < servercnt; i++) {
			memcpy(&in6, src, sizeof(in6));
			src += sizeof(in6);
			printf("%s ", inet_ntop(AF_INET6, &in6, ntopbuf,
			    INET6_ADDRSTRLEN));
		}
		break;
	default:
		break;
	}
	printf("\n");
}

/*
 * Print RTM_PROPOSAL static routes.
 */
void
print_rtstatic(struct sockaddr_rtstatic *rtstatic)
{
	struct sockaddr_in6	 gateway6;
	struct in6_addr		 prefix;
	struct in_addr		 dest, gateway;
	size_t			 srclen, offset;
	int			 bits, bytes, error;
	uint8_t			 prefixlen;
	unsigned char		*src = rtstatic->sr_static;
	char			 ntoabuf[INET_ADDRSTRLEN];
	char			 hbuf[NI_MAXHOST];
	char			 ntopbuf[INET6_ADDRSTRLEN];

	offset = offsetof(struct sockaddr_rtstatic, sr_static);
	if (rtstatic->sr_len <= offset) {
		printf("<invalid sr_len (%d <= %zu)>\n", rtstatic->sr_len,
		    offset);
		return;
	}
	srclen = rtstatic->sr_len - offset;
	if (srclen > sizeof(rtstatic->sr_static)) {
		printf("<invalid sr_len (%zu > %zu)>\n", srclen,
		    sizeof(rtstatic->sr_static));
		return;
	}

	switch (rtstatic->sr_family) {
	case AF_INET:
		/* AF_INET -> RFC 3442 encoded static routes. */
		while (srclen) {
			bits = *src;
			src++;
			srclen--;
			bytes = (bits + 7) / 8;
			if (srclen < bytes || bytes > sizeof(dest.s_addr))
				break;
			memset(&dest, 0, sizeof(dest));
			memcpy(&dest.s_addr, src, bytes);
			src += bytes;
			srclen -= bytes;
			strlcpy(ntoabuf, inet_ntoa(dest), sizeof(ntoabuf));
			if (srclen < sizeof(gateway.s_addr))
				break;
			memcpy(&gateway.s_addr, src, sizeof(gateway.s_addr));
			src += sizeof(gateway.s_addr);
			srclen -= sizeof(gateway.s_addr);
			printf("%s/%u %s ", ntoabuf, bits, inet_ntoa(gateway));
		}
		break;
	case AF_INET6:
		while (srclen >= sizeof(prefixlen) + sizeof(prefix) +
		    sizeof(gateway6)) {
			memcpy(&prefixlen, src, sizeof(prefixlen));
			srclen -= sizeof(prefixlen);
			src += sizeof(prefixlen);

			memcpy(&prefix, src, sizeof(prefix));
			srclen -= sizeof(prefix);
			src += sizeof(prefix);

			memcpy(&gateway6, src, sizeof(gateway6));
			srclen -= sizeof(gateway6);
			src += sizeof(gateway6);

			if ((error = getnameinfo((struct sockaddr *)&gateway6,
			    gateway6.sin6_len, hbuf, sizeof(hbuf), NULL, 0,
			    NI_NUMERICHOST | NI_NUMERICSERV))) {
				warnx("cannot get gateway address: %s",
				    gai_strerror(error));
				return;
			}
			printf("%s/%u %s ", inet_ntop(AF_INET6, &prefix,
			    ntopbuf, INET6_ADDRSTRLEN), prefixlen, hbuf);
		}
		break;
	default:
		printf("<unknown address family %d>", rtstatic->sr_family);
		break;
	}
	printf("\n");
}

/*
 * Print RTM_PROPOSAL domain search list.
 */
void
print_rtsearch(struct sockaddr_rtsearch *rtsearch)
{
	char	*src = rtsearch->sr_search;
	size_t	 srclen, offset;

	offset = offsetof(struct sockaddr_rtsearch, sr_search);
	if (rtsearch->sr_len <= offset) {
		printf("<invalid sr_len (%d <= %zu)>\n", rtsearch->sr_len,
		    offset);
		return;
	}
	srclen = rtsearch->sr_len - offset;
	if (srclen > sizeof(rtsearch->sr_search)) {
		printf("<invalid sr_len (%zu > %zu)>\n", srclen,
		    sizeof(rtsearch->sr_search));
		return;
	}

	printf("%.*s\n", (int)srclen, src);
}
@


1.199
log
@getnameinfo errors should go to stderr & should print what's going on.
Pointed out by & ok bluhm
While here print prefixlen with %u, pointed out by bluhm, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.198 2017/03/20 19:01:38 florian Exp $	*/
d2175 1
a2175 1
	printf("%*s\n", (int)srclen, src);
@


1.198
log
@show inet6 proposals in route monitor
fine with krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.197 2017/03/02 17:09:21 krw Exp $	*/
d2077 1
a2077 1
	int			 bits, bytes;
d2135 1
a2135 1
			if (getnameinfo((struct sockaddr *)&gateway6,
d2137 3
a2139 2
			    NI_NUMERICHOST | NI_NUMERICSERV)) {
				printf("cannot get gateway address");
d2142 1
a2142 1
			printf("%s/%hhu %s ", inet_ntop(AF_INET6, &prefix,
@


1.197
log
@Implement a new routing message RTM_PROPOSAL that communicates
information that can be used to configure an interface and
related network components.

ok bluhm@@, ok for various older versions mpi@@ florian@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.196 2017/01/23 00:10:07 krw Exp $	*/
d2014 1
a2014 1
	char		*src = rtdns->sr_dns;
d2018 2
d2049 11
a2059 1
		printf("<AF_INET6> printing not yet implemented\n");
d2073 10
a2082 5
	struct in_addr	 dest, gateway;
	unsigned char	*src = rtstatic->sr_static;
	size_t		 srclen, offset;
	int		 bits, bytes;
	char		 ntoabuf[INET_ADDRSTRLEN];
d2121 23
a2143 1
		printf("<AF_INET6 printing not yet implemented>");
@


1.196
log
@Zap some bad whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.195 2017/01/19 23:18:29 phessler Exp $	*/
d122 3
d1264 1
d1278 1
a1278 1
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD\011SRC\12SRCMASK\013LABEL";
d1362 81
d2005 131
@


1.195
log
@add hooks so we can query the current state of a BFD session

bfd session details are visible with "route -n get 192.0.2.1 -bfd"

OK mpi@@ deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.194 2017/01/17 19:05:47 jca Exp $	*/
d242 1
a242 1
		
d1312 1
a1312 1
	printf(": len %d", rtm->rtm_msglen);	
d1635 1
a1635 1
	return (buf);		
@


1.194
log
@In monitor mode, also print the interface mtu of RTM_IFINFO messages.

ok deraadt@@ millert@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.193 2016/12/13 08:40:54 mpi Exp $	*/
d103 1
d1448 3
d1499 5
d1536 4
d1642 9
d1655 9
a1663 2
	printf(" mode ");
	switch (bfdm->bm_mode) {
d1665 1
a1665 1
		printf("async");
d1668 1
a1668 1
		printf("demand");
d1671 1
a1671 1
		printf("unknown %u", bfdm->bm_mode);
a1673 16
	printf(" state %s", bfd_state(bfdm->bm_state));
	printf(" remotestate %s", bfd_state(bfdm->bm_remotestate));
	printf(" laststate %s", bfd_state(bfdm->bm_laststate));

	printf(" error %d", bfdm->bm_error);
	printf(" localdiscr %u", bfdm->bm_localdiscr);
	printf(" remotediscr %u", bfdm->bm_remotediscr);
	printf(" localdiag %s", bfd_diag(bfdm->bm_localdiag));
	printf(" remotediag %s", bfd_diag(bfdm->bm_remotediag));
	printf(" uptime %s", bfd_calc_uptime(tv.tv_sec - bfdm->bm_uptime));
	printf(" lastuptime %s", bfd_calc_uptime(bfdm->bm_lastuptime));

	printf(" mintx %u", bfdm->bm_mintx);
	printf(" minrx %u", bfdm->bm_minrx);
	printf(" minecho %u", bfdm->bm_minecho);
	printf(" multiplier %u", bfdm->bm_multiplier);
d1675 22
a1696 1
	pmsg_addrs(((char *)rtm + rtm->rtm_hdrlen), rtm->rtm_addrs);
@


1.193
log
@Print the correct netmask instead of /0 when flushing routes to networks.

Issue reported by jsing@@, ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.192 2016/09/24 19:36:49 phessler Exp $	*/
d1321 1
a1321 1
		printf("link: %s, flags:",
d1323 2
a1324 1
		    ifm->ifm_data.ifi_link_state));
@


1.192
log
@print a BFD route message.

protected with #ifdef BFD while we still figure out some of the
mechanisms.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.191 2016/09/15 12:51:20 phessler Exp $	*/
d388 2
d391 8
a398 6
			printf("%-20.20s ", rtm->rtm_flags & RTF_HOST ?
			    routename(sa) : netname(sa, NULL)); /* XXX extract
								   netmask */
			sa = (struct sockaddr *)
			    (ROUNDUP(sa->sa_len) + (char *)sa);
			printf("%-20.20s ", routename(sa));
@


1.191
log
@Add RTM_INVALIDATE as a route message, to keep the kernel and userland
lists in sync.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.190 2016/09/04 09:41:03 claudio Exp $	*/
d44 5
d98 6
d1347 1
d1349 1
a1349 1
		printf("bfd\n");	/* XXX - expand*/
d1351 1
d1542 118
@


1.190
log
@Make it possible to set the RTF_BFD flag in a change request. Also add a
nobfd option to turn it off again. While here also print the fmask in the
rtmsg dump so it is possible to figure out why something happens (or not).
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.189 2016/09/03 14:23:14 phessler Exp $	*/
d1243 1
@


1.189
log
@Add userland parts for BFD.  Can't work if you don't have it enabled in
the kernel.

OK claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.188 2016/09/01 10:41:09 bluhm Exp $	*/
d612 5
d1252 1
a1252 1
"\030CONNECTED";
d1344 2
@


1.188
log
@Fix previous commit that displays all route flags with "route get".
The successor of octal 027 is 030 and not 028.  Found by
regress/sbin/route/rttest20.ok test.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.187 2016/09/01 09:41:34 bluhm Exp $	*/
d610 3
d1238 1
d1329 3
@


1.187
log
@Display all route flags in "route get", "route show" and "netstat -r"
output.  Sort them according to the RTF_... defines in route.h.
OK claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.186 2016/08/31 21:32:06 bluhm Exp $	*/
d1243 1
a1243 1
"\028CONNECTED";
@


1.186
log
@Remove unused RTF_MASK route flag.
Requested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.185 2016/08/26 06:04:10 guenther Exp $	*/
d1240 4
a1243 2
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010XMASK_PRESENT\011CLONING"
"\012XRESOLVE\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2\020PROTO1\021CLONED\023MPATH\025MPLS\026LOCAL\027BROADCAST";
@


1.185
log
@Add <time.h> for time() and ctime(); sort <net*/*.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.184 2016/07/09 20:39:17 tedu Exp $	*/
d1240 1
a1240 1
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010MASK_PRESENT\011CLONING"
@


1.184
log
@only print one error, not multiple misleading messages
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.183 2016/06/07 01:29:38 tedu Exp $	*/
d38 1
d42 2
d56 1
a58 2
#include <net/if_media.h>
#include <netmpls/mpls.h>
@


1.183
log
@per trending style, add continue to emtpy loop bodies.
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.182 2015/12/03 08:00:49 claudio Exp $	*/
d647 3
a649 1
	if (*cmd == 'g')
d651 1
a1170 2
		if (qflag == 0)
			warn("writing to routing socket");
@


1.182
log
@Print the interface index which is part of the route msg header.
mpi@@ and benno@@ agree
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.181 2015/11/27 16:26:52 benno Exp $	*/
d766 1
a766 1
		;
@


1.181
log
@After evaluating patches from Ricardo Mestre, it became obvious that
route needs pledge("stdio rpath dns") in all cases.
Looks best to me deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.180 2015/11/20 17:26:56 jca Exp $	*/
d1322 4
a1325 4
		printf(", priority %d, ", rtm->rtm_priority);
		printf("table %u, pid: %ld, seq %d, errno %d\nflags:",
		    rtm->rtm_tableid, (long)rtm->rtm_pid, rtm->rtm_seq,
		    rtm->rtm_errno);
@


1.180
log
@Replace hardcoded "0" with SHUT_RD; from Ricardo Mestre
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.179 2015/10/25 09:37:08 deraadt Exp $	*/
d229 2
a230 7
	if (nflag) {
		if (pledge("stdio rpath dns", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio rpath dns", NULL) == -1)
			err(1, "pledge");
	}
d327 2
a328 7
	if (nflag) {
		if (pledge("stdio rpath dns", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio rpath dns", NULL) == -1)
			err(1, "pledge");
	}
@


1.179
log
@route flush cannot pledge before sysctl for NET_RT_DUMP; defer the act.
issue spotted by matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.178 2015/10/23 15:03:25 deraadt Exp $	*/
d273 1
a273 1
	shutdown(s, 0); /* Don't want to read back our messages */
d453 1
a453 1
		shutdown(s, 0); /* Don't want to read back our messages */
@


1.178
log
@route has 3 code paths: monitor (listening on route socket); show
(sysctl and then print), change (getsocket, then read/write on that).
Refactor lightly and insert pledge "stdio rpath dns" in each case.
ok claudio benno phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.177 2015/09/11 20:08:40 mpi Exp $	*/
d79 1
a79 1
void	 flushroutes(int, char **);
d219 2
a220 1
	if (kw == K_SHOW) {
d223 4
d228 1
a228 1

a248 3
	case K_FLUSH:
		flushroutes(argc, argv);
		break;
d260 1
a260 1
void
d331 9
d346 1
a346 1
		return;
d396 1
@


1.177
log
@Remove RTF_XRESOLVE support.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.176 2015/07/18 21:26:03 mpi Exp $	*/
d81 1
a81 1
void	 show(int, char *[]);
d178 52
a229 19
	switch (kw) {
	case K_EXEC:
		break;
	case K_MONITOR:
		monitor(argc, argv);
		break;
	default:
		if (tflag)
			s = open(_PATH_DEVNULL, O_WRONLY);
		else
			s = socket(PF_ROUTE, SOCK_RAW, 0);
		if (s == -1)
			err(1, "socket");
		/* force socket onto table user requested */
		if (Tflag == 1 && Terr == 0 &&
		    setsockopt(s, AF_ROUTE, ROUTE_TABLEFILTER,
		    &tableid, sizeof(tableid)) == -1)
			err(1, "setsockopt(ROUTE_TABLEFILTER)");
		break;
d231 1
a232 3
	case K_EXEC:
		rval = rdomain(argc - 1, argv + 1);
		break;
a240 4
	case K_SHOW:
		uid = 0;
		show(argc, argv);
		break;
d242 1
a242 1
		/* handled above */
d678 1
a678 1
void
d721 1
a1076 2
	int af = 0;
	unsigned int filter = 0;
d1081 2
a1082 32
	while (--argc > 0) {
		if (**(++argv)== '-')
			switch (keyword(*argv + 1)) {
			case K_INET:
				af = AF_INET;
				break;
			case K_INET6:
				af = AF_INET6;
				break;
			case K_IFACE:
			case K_INTERFACE:
				filter = ROUTE_FILTER(RTM_IFINFO) |
				    ROUTE_FILTER(RTM_IFANNOUNCE);
				break;
			default:
				usage(*argv);
				/* NOTREACHED */
			}
		else
			usage(*argv);
	}

	s = socket(PF_ROUTE, SOCK_RAW, af);
	if (s == -1)
		err(1, "socket");

	if (setsockopt(s, AF_ROUTE, ROUTE_MSGFILTER, &filter,
	    sizeof(filter)) == -1)
		err(1, "setsockopt(ROUTE_MSGFILTER)");
	if (Tflag && setsockopt(s, AF_ROUTE, ROUTE_TABLEFILTER, &tableid,
	    sizeof(tableid)) == -1)
		err(1, "setsockopt(ROUTE_TABLEFILTER)");
@


1.176
log
@Make all commands accepting the "-priority" switch recognize aliases
for common priorities.

ok deraadt@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.175 2015/07/18 00:05:02 phessler Exp $	*/
a514 3
				break;
			case K_XRESOLVE:
				flags |= RTF_XRESOLVE;
@


1.175
log
@On systems with a full routing table (550k+), we often want to be able to
look at the routes with a priority, or to display all routes that do not
have a specific priority (normally, don't show bgp).

We are intentionally not updating netstat -r yet, as we do not have a
good flag to use.

first version from, and OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.174 2015/05/17 00:08:35 deraadt Exp $	*/
d88 2
a89 1
char	*priorityname(u_int8_t);
d100 1
a100 1
int	 rtmsg(int, int, int, u_char);
a233 1
	const char *errstr;
d239 1
a239 1
	u_char prio = 0;
d271 1
a271 4
				prio = strtonum(*++argv, 0, RTP_MAX, &errstr);
				if (errstr)
					errx(1, "priority is %s: %s", errstr,
					    *argv);
a402 1
	const char *errstr;
d407 1
a407 1
	u_char prio = 0;
d580 1
a580 4
				prio = strtonum(*++argv, 0, RTP_MAX, &errstr);
				if (errstr)
					errx(1, "priority is %s: %s", errstr,
					    *argv);
a658 2
	char		*priostr;
	const char	*errstr;
d686 1
a686 27
				priostr = *++argv;
				switch (keyword(priostr)) {
					case K_LOCAL:
					    prio = RTP_LOCAL;
					    break;
					case K_CONNECTED:
					    prio = RTP_CONNECTED;
					    break;
					case K_STATIC:
					    prio = RTP_STATIC;
					    break;
					case K_OSPF:
					    prio = RTP_OSPF;
					    break;
					case K_RIP:
					    prio = RTP_RIP;
					    break;
					case K_BGP:
					    prio = RTP_BGP;
					    break;
					default:
					    prio = strtonum(priostr, -RTP_MAX, RTP_MAX,
						&errstr);
					    if (errstr)
						errx(1, "priority is %s: %s",
						    errstr, *argv);
				}
d1114 1
a1114 1
rtmsg(int cmd, int flags, int fmask, u_char prio)
d1347 1
a1347 1
priorityname(u_int8_t prio)
d1371 34
@


1.174
log
@nope, ioctl has not been used for a while
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.174 2015/05/17 00:04:08 deraadt Exp $	*/
d664 4
a667 1
	int	af = 0;
d692 31
d731 1
a731 1
	p_rttables(af, tableid, Tflag);
@


1.173
log
@Instead of embedding interface names in a sockaddr use their indexes
when adding route entries with the -link option.

This prevent the ARP layer to take the name of your interface for an
Ethernet address.  If you still want to add stupid content to your
routing table, please write your own tool.

Thanks to Henk Jan Agteresch for reporting the original issue and
testing this diff.

ok mikeb@@, deraadt@@, benno@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.172 2015/02/06 03:22:00 reyk Exp $	*/
a33 1
#include <sys/ioctl.h>
@


1.172
log
@Remove route/netstat -f encap in favor of ipsecctl -s flow.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.171 2015/01/16 06:40:00 deraadt Exp $	*/
d899 2
a900 2
		su->sa.sa_len = sizeof(struct sockaddr_dl);
		link_addr(s, &su->sdl);
@


1.171
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.170 2014/08/19 12:39:36 mpi Exp $	*/
a680 3
				break;
			case K_ENCAP:
				af = PF_KEY;
@


1.170
log
@Entries for broadcast addresses should also be ignored, just like local
entries.

ok florian@@, mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.169 2014/07/24 17:45:35 jca Exp $	*/
a32 1
#include <sys/param.h>
d48 1
@


1.169
log
@Unbreak ''route flush'': the kernel now adds local (RTF_LOCAL) routes
for addresses configured on the system, and prevents userland from
deleting them.  Just skip those routes when flushing.
Problem noticed by mlarkin@@, ok henning@@ mpi@@ claudio@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.168 2014/06/23 03:46:16 guenther Exp $	*/
d323 1
a323 1
		if ((rtm->rtm_flags & RTF_LOCAL) != 0)
@


1.168
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.167 2014/05/08 09:28:08 mpi Exp $	*/
d322 2
@


1.167
log
@Introduce two new route flags: RTF_LOCAL and RTF_BROADCAST.

Nothing use them for the moment, but here is the plan:

Since a route lookup is always necessary to output a packet it makes
sense to store all the information regarding how the packet should be
sent in the routing entry.  This will save us some expensive lookups
on address lists.

But once we have all the information about our addresses in the routing
table, we can even use it in the input path with the hope that the number
of lookups in the forwarding case can be reduce to one.

ok henning@@, chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.166 2014/01/22 06:23:37 claudio Exp $	*/
d1681 1
a1681 1
	mib[1] = AF_ROUTE;
@


1.166
log
@Remove genmask support from route(8). It still will show them in monitor
or get but you can no longer set it. genmask will die soon since nobody
needs it. OK benno@@ and agreed by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.165 2013/10/28 15:05:35 deraadt Exp $	*/
d1246 1
a1246 1
"\012XRESOLVE\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2\020PROTO1\021CLONED\022SOURCE\023MPATH\025MPLS";
d1355 2
@


1.165
log
@use %d instead of %i in a few fprintf for clarity
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.164 2013/10/18 08:38:52 bluhm Exp $	*/
d65 1
a65 1
union sockunion so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp, so_label, so_src;
a534 5
			case K_GENMASK:
				if (!--argc)
					usage(1+*argv);
				getaddr(RTA_GENMASK, *++argv, NULL);
				break;
a825 3
	case RTA_GENMASK:
		su = &so_genmask;
		break;
a846 1
		case RTA_GENMASK:
a1165 1
	NEXTADDR(RTA_GENMASK, so_genmask);
a1524 1
					case RTA_GENMASK:
@


1.164
log
@Prepare the route(8) command for printing 64 bit route expire time.
Also fix the conversion between relative and absolute expire time.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.163 2013/07/19 20:10:23 guenther Exp $	*/
d176 1
a176 1
		err(1, "routing table %i", tableid);
@


1.163
log
@Prep for WARNINGS=yes: add the prototypes that were missing, silence
a "signed vs unsigned in conditional" warning, and eliminate what
looks like an unintentional variable shadowing.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.162 2013/05/27 14:07:25 sthen Exp $	*/
d365 2
a367 2
	u_int noval, *valp = &noval;
	const char *errstr;
d371 3
a373 1
		valp = &rt_metrics.rmx_mtu;
d377 5
a381 1
		valp = &rt_metrics.rmx_expire;
a399 3
	*valp = strtonum(value, 0, UINT_MAX, &errstr);
	if (errstr)
		errx(1, "set_metric: %s is %s", value, errstr);
d1280 1
d1347 3
a1349 3
			if (rtm->rtm_rmx.rmx_expire)
				rtm->rtm_rmx.rmx_expire -= time(NULL);
			printf("\nuse: %8llu   mtu: %8u%c   expire: %8d%c",
d1352 1
a1352 1
			    rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
d1387 1
d1473 7
a1479 6
	printf("%s\n", "     use       mtu    expire");
	printf("%8llu  ", rtm->rtm_rmx.rmx_pksent);
	printf("%8u%c ", rtm->rtm_rmx.rmx_mtu, lock(MTU));
	if (rtm->rtm_rmx.rmx_expire)
		rtm->rtm_rmx.rmx_expire -= time(NULL);
	printf("%8d%c\n", rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
@


1.162
log
@autodetect ipv6 addresses for route(8). ok benno@@ bluhm@@, manpage help jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.161 2013/03/21 04:43:17 deraadt Exp $	*/
d83 1
d91 1
d349 1
a349 2
			struct sockaddr *sa = (struct sockaddr *)(next +
			    rtm->rtm_hdrlen);
@


1.161
log
@create realloc() loops around sysctl for array-based mibs, in programs
which want a "full" dump
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.160 2012/12/04 02:30:33 deraadt Exp $	*/
d806 7
a812 2
		af = AF_INET;
		aflen = sizeof(struct sockaddr_in);
@


1.160
log
@remove some unnecessary sys/mbuf.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.159 2012/09/23 13:46:29 claudio Exp $	*/
d289 10
a298 6
	if (sysctl(mib, 7, NULL, &needed, NULL, 0) < 0)
		err(1, "route-sysctl-estimate");
	if (needed) {
		if ((buf = malloc(needed)) == NULL)
			err(1, "malloc");
		if (sysctl(mib, 7, buf, &needed, NULL, 0) < 0)
d300 1
d302 1
@


1.159
log
@Allow route -T 3 add to create a table even if the table does not exist
yet. This is the only way to create alternate routing tables.
Reminded by and OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.158 2012/08/14 08:49:56 chl Exp $	*/
a35 1
#include <sys/mbuf.h>
@


1.158
log
@fix bad argument passed to errx()

ok sthen@@ benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.157 2012/07/13 10:15:53 benno Exp $	*/
d105 1
a105 1
void	 gettable(const char *);
d133 1
d154 1
a154 1
			gettable(optarg);
d173 4
d191 2
a192 1
		if (Tflag && setsockopt(s, AF_ROUTE, ROUTE_TABLEFILTER,
d1660 1
a1660 1
void
d1681 3
a1683 1
		err(1, "routing table %i", tableid);
@


1.157
log
@allow destination/prefixlen syntax for ipv6 routes.
from Florian Obser, florian -AT- narrans -DOT- de

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.156 2012/03/17 10:16:40 dlg Exp $	*/
d767 1
a767 1
			errx(1, "prefixlen %s is %s", s, errstr);
@


1.156
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.155 2011/07/04 22:48:31 claudio Exp $	*/
d96 1
a96 1
int	 inet6_makenetandmask(struct sockaddr_in6 *);
d740 1
a740 1
inet6_makenetandmask(struct sockaddr_in6 *sin6)
a741 1
	char *plen = NULL;
d743 2
d746 11
a756 8
	if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) &&
	    sin6->sin6_scope_id == 0) {
		plen = "0";
	} else if ((sin6->sin6_addr.s6_addr[0] & 0xe0) == 0x20) {
		/* aggregatable global unicast - RFC2374 */
		memset(&in6, 0, sizeof(in6));
		if (!memcmp(&sin6->sin6_addr.s6_addr[8], &in6.s6_addr[8], 8))
			plen = "64";
d764 14
d845 8
d854 3
d861 1
a861 1
		if (getaddrinfo(s, "0", &hints, &res) != 0) {
d863 1
a863 1
			if (getaddrinfo(s, "0", &hints, &res) != 0)
d882 1
a882 1
				return (inet6_makenetandmask(&su->sin6));
@


1.155
log
@Force the sa_len to sizeof(struct sockaddr_dl) before calling
link_addr() since the function looks at sa_len internally.
This should solve issues with using -ifp modifier because
the aflen was often to small.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.154 2011/07/02 22:00:54 claudio Exp $	*/
a557 8
			case K_JUMBO:
				flags |= RTF_JUMBO;
				fmask |= RTF_JUMBO;
				break;
			case K_NOJUMBO:
				flags &= ~RTF_JUMBO;
				fmask |= RTF_JUMBO;
				break;
d1207 1
a1207 1
"\012XRESOLVE\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2\020PROTO1\021CLONED\022SOURCE\023MPATH\024JUMBO\025MPLS";
@


1.154
log
@-interface is an alias of -iface so make sure route(8) accepts both
flags in the monitor case. Brought up on the mailing list some long
time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.153 2011/04/25 11:14:37 sthen Exp $	*/
d868 1
@


1.153
log
@allow commands like "route add 0.0.0.0/1 $SOMEHOST" to work correctly,
previously they operated on the default route. reported by weerd@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.152 2010/10/25 19:39:55 deraadt Exp $	*/
d1038 1
@


1.152
log
@range check rtm_type more carefully against the known RTM_ values.
this is not the real solution to PR 6500; claudio is going to fix that
properly in the kernel
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.151 2010/10/11 11:45:00 claudio Exp $	*/
d707 1
a707 1
	if (net == 0)
@


1.151
log
@Make route(8) use the ROUTE_TABLEFILTER and change the code so that
route(8) will default to the process rtableid.
route -T 1 exec route add default 192.168.1.1
route -T 1 exec route -n show
These commands will now operate outmatically on rtable 1 and not on
rtable 0 as it was done before.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.150 2010/09/21 10:58:23 krw Exp $	*/
a1206 1
	NULL
d1249 7
a1255 1
	printf("%s: len %d", msgtypes[rtm->rtm_type], rtm->rtm_msglen);
@


1.150
log
@Add '-label' to specify that you only want to see routes having the
given label. No change to existing functionality.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.149 2010/09/04 08:06:09 blambert Exp $	*/
d71 1
a71 1
int	forcehost, forcenet, Fflag, nflag, af, qflag, tflag;
d137 1
d154 1
d185 4
d697 1
a697 1
	p_rttables(af, tableid);
d1055 4
a1058 1
		err(1, "setsockopt");
d1629 4
a1632 1
	const char	*errstr;
d1637 11
@


1.149
log
@sort generated keywords in order to replace linear probe with bsearch(3)
(more people should know about how to properly use libc-provided tools)

make keywords.h depend upon keywords.sh, so that it gets automatically
rebuilt when keywords.sh is edited

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.148 2010/09/02 14:03:21 sobrado Exp $	*/
d66 1
a66 8
union	sockunion {
	struct sockaddr		sa;
	struct sockaddr_in	sin;
	struct sockaddr_in6	sin6;
	struct sockaddr_dl	sdl;
	struct sockaddr_rtlabel	rtlabel;
	struct sockaddr_mpls	smpls;
} so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp, so_label, so_src;
d677 5
@


1.148
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.147 2010/07/14 01:23:04 dlg Exp $	*/
d1515 6
d1523 6
a1528 1
	struct keytab *kt = keywords;
a1529 2
	while (kt->kt_cp && strcmp(kt->kt_cp, cp))
		kt++;
@


1.147
log
@handle printing of RTM_DESYNC in route monitor.

reviewed by deraadt@@
written by sthen@@ who said i should commit it cos he was going to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.146 2010/07/03 04:44:51 guenther Exp $	*/
d432 1
a432 1
					errx(1, "-mplslabel requires " 
d1408 1
a1408 1
	   priorityname(rtm->rtm_priority)); 
@


1.146
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.145 2010/06/27 07:57:59 guenther Exp $	*/
d1199 1
d1243 1
a1243 1
	printf("%s: len %d, ", msgtypes[rtm->rtm_type], rtm->rtm_msglen);
d1245 3
d1250 1
a1250 1
		(void) printf("if# %d, ", ifm->ifm_index);
d1262 1
a1262 1
		printf("metric %d, flags:", ifam->ifam_metric);
d1268 1
a1268 1
		printf("if# %d, name %s, what: ",
d1284 1
a1284 1
		printf("priority %d, ", rtm->rtm_priority);
@


1.145
log
@Make 'route exec' emit error messages like xargs when execve() fails does.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.144 2010/05/19 13:11:25 claudio Exp $	*/
d1621 2
a1622 2
	if (setrdomain(tableid) == -1)
		err(1, "setrdomain");
@


1.144
log
@Set RTF_MPLS when playing with MPLS routes since this is now required.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.143 2010/05/19 10:30:27 claudio Exp $	*/
d1624 1
@


1.143
log
@Do not default to rdomain 1 for route exec use 0 as default like every other
route command. Found by Christophe Fillo (cf (at) utc fr).
While there cleanup the code a bit there is no need for special rtableid
handling for route exec.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.142 2010/03/23 15:01:50 claudio Exp $	*/
d426 1
d436 1
d454 1
@


1.142
log
@Print MPLS information in route -n get and do some cleanup in the show code.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.141 2009/12/01 16:21:46 reyk Exp $	*/
d84 1
a84 1
u_int	tableid = 0;
d112 2
a113 2
int	 gettable(const char *);
int	 rdomain(int, int, char **);
a138 1
	int rtableid = 1;
d159 1
a159 1
			rtableid = gettable(optarg);
d194 1
a194 1
		rval = rdomain(rtableid, argc - 1, argv + 1);
d1603 1
a1603 1
int
a1610 1
	return (tableid);
d1614 1
a1614 1
rdomain(int rtableid, int argc, char **argv)
d1618 1
a1618 1
	if (setrdomain(rtableid) == -1)
@


1.141
log
@Add the new exec command to run a process and its children in a
non-default rdomain/rtable.  route will change the default rdomain
using the new setrdomain() syscall and execute the supplied command,
eg. "route -T1 exec /usr/sbin/named".

Tested by many including michele@@, phessler@@
ok claudio@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.140 2009/11/02 21:08:44 claudio Exp $	*/
d1209 1
a1209 1
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD\013LABEL";
d1328 1
d1370 3
d1397 4
@


1.140
log
@Print the route metrics in monitor mode if -v is used. This info can be
useful from time to time and it is easer then deciphering ktrace output.
While there kill the no longer needed msec macro.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.139 2009/11/02 17:57:06 claudio Exp $	*/
d112 2
a113 1
void	 gettable(const char *);
d126 1
a126 1
	    "commands: add, change, delete, flush, get, monitor, show\n");
d139 2
d160 1
a160 1
			gettable(optarg);
d176 6
a181 1
	if (keyword(*argv) == K_MONITOR)
d183 14
a196 8

	if (tflag)
		s = open(_PATH_DEVNULL, O_WRONLY);
	else
		s = socket(PF_ROUTE, SOCK_RAW, 0);
	if (s == -1)
		err(1, "socket");
	switch (keyword(*argv)) {
d1596 1
a1596 1
void
d1604 12
@


1.139
log
@Use strtonum instead of atoi, this allows to do basic range checking.
While there remove some very old compat code supporting a syntax that
no one still knows or uses. OK henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.138 2009/09/14 11:45:48 claudio Exp $	*/
d1269 10
a1387 2
#define msec(u)	(((u) + 500) / 1000)		/* usec to msec */

a1394 1
#undef msec
@


1.138
log
@Switch get_linkstate() to use the new LINK_STATE_DESCRIPTIONS instead
of the if_media dance. Simplifies the code nicely.
OK henning, sthen, michele, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.137 2009/07/23 14:23:06 sthen Exp $	*/
d343 1
d370 3
a372 1
	*valp = atoi(value);
d582 2
a583 22
			} else {
				int hops = atoi(*argv);

				if (hops == 0) {
				    if (!qflag && strcmp(*argv, "0") == 0)
					printf("%s,%s",
					    "old usage of trailing 0",
					    "assuming route to if\n");
				    else
					usage(NULL);
				    iflag = 1;
				    continue;
				} else if (hops > 0 && hops < 10) {
				    if (!qflag) {
					printf("old usage of trailing digit, ");
					printf("assuming route via gateway\n");
				    }
				    iflag = 0;
				    continue;
				}
				getaddr(RTA_NETMASK, *argv, NULL);
			}
d924 2
a925 1
	int len = atoi(s), q, r;
d941 3
a943 2
	if (len < 0 || len > max)
		errx(1, "%s: bad value", s);
@


1.137
log
@Always print interface names, not just ifindex, even when -n is
specified. Most people want -n to avoid reverse DNS lookups, and
it's stupid not to print a useful interface name just for that.

YES PLEASE! Ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.136 2009/07/23 14:19:52 claudio Exp $	*/
d63 2
a64 3
const int ifm_status_valid_list[] = IFM_STATUS_VALID_LIST;
const struct ifmedia_status_description
	ifm_status_descriptions[] = IFM_STATUS_DESCRIPTIONS;
d1215 2
a1216 2
	const struct ifmedia_status_description *p;
	int i, media_type;
d1218 3
a1220 16
	switch (mt) {
	case IFT_ETHER:
		media_type = IFM_ETHER;
		break;
	case IFT_FDDI:
		media_type = IFM_FDDI;
		break;
	case IFT_CARP:
		media_type = IFM_CARP;
		break;
	case IFT_IEEE80211:
		media_type = IFM_IEEE80211;
		break;
	default:
		media_type = 0;
		break;
d1222 2
a1223 19

	if (link_state == LINK_STATE_UNKNOWN)
		return ("unknown");

	for (i = 0; ifm_status_valid_list[i] != 0; i++) {
		for (p = ifm_status_descriptions; p->ifms_valid != 0; p++) {
			if (p->ifms_type != media_type ||
			    p->ifms_valid != ifm_status_valid_list[i])
				continue;
			if (LINK_STATE_IS_UP(link_state))
				return (p->ifms_string[1]);
			return (p->ifms_string[0]);
		}
	}

	if (LINK_STATE_IS_UP(link_state))
		return ("up");
	else
		return ("down");
@


1.136
log
@Only print unknown in RTM_IFINFO messages when the link is in
LINK_STATE_UNKOWN. In the other case use LINK_STATE_IS_UP() to
print either "up" or "down". OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.135 2009/06/27 11:35:57 michele Exp $	*/
d1277 1
a1277 1
		if (!nflag && if_indextoname(ifm->ifm_index, ifname) != NULL)
@


1.135
log
@Mark MPLS routes with T (tagged) in route output.

suggested by dlg@@, ok claudio@@, laurent@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.134 2009/06/25 15:42:24 claudio Exp $	*/
d1251 4
a1254 1
	return ("unknown");
@


1.134
log
@Add a missing RTM_VERSION check.
Tested and OK sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.133 2009/06/06 20:30:22 claudio Exp $	*/
d1206 1
a1206 1
"\012XRESOLVE\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2\020PROTO1\021CLONED\022SOURCE\023MPATH\024JUMBO";
@


1.133
log
@Uninitialized variable causing havoc on flush. Found by rivo nurges
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.132 2009/05/31 18:02:28 claudio Exp $	*/
d1143 2
a1144 1
		} while (l > 0 && (rtm.rtm_seq != seq || rtm.rtm_pid != pid));
@


1.132
log
@Masking the priority with RTP_MASK is no longer needed in userland.
Kernel will do this now.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.131 2009/05/30 21:06:34 claudio Exp $	*/
d223 1
a223 1
	unsigned int ifindex;
@


1.131
log
@Make it possible to filter monitor output on AF or show only interface
specific changes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.130 2009/05/30 20:03:31 claudio Exp $	*/
d1306 1
a1306 1
		printf("priority %d, ", rtm->rtm_priority & RTP_MASK);
d1318 1
a1318 1
	switch (prio & RTP_MASK) {
d1411 1
a1411 1
	printf("   priority: %u (%s)\n", rtm->rtm_priority & RTP_MASK,
@


1.130
log
@priority is a u_char not a u_short.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.129 2009/05/30 19:50:28 claudio Exp $	*/
d93 1
a93 1
void	 monitor(void);
d172 5
a182 2
	if (*argv == NULL)
		usage(NULL);
d197 1
a197 1
		monitor();
d1016 1
a1016 1
monitor(void)
d1018 2
d1023 29
@


1.129
log
@Make route flush more powerful by allowing -iface/-interface or -priority
to be specified. So only routes matching these conditions will be flushed.
This will help making dhclient less dumb when fiddeling with routes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.128 2009/04/28 12:09:35 michele Exp $	*/
d107 1
a107 1
int	 rtmsg(int, int, int, u_short);
d219 1
a219 1
	u_short prio = 0;
d378 1
a378 1
	u_short prio = 0;
d1042 1
a1042 1
rtmsg(int cmd, int flags, int fmask, u_short prio)
@


1.128
log
@Sync with kernel changes.
Add support to route(8) for a new dummy operation to allow packets coming in
with a particular label to leave the MPLS cloud and join ipv4/ipv6 stack.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.127 2009/02/03 16:44:15 michele Exp $	*/
d213 1
d219 2
d225 2
a226 3
	if (argc > 1) {
		argv++;
		if (argc == 2 && **argv == '-')
d240 16
d298 4
@


1.127
log
@Reflect MPLS kernel changes. Operations are stored now in rt_mpls field.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.126 2009/01/29 11:21:34 michele Exp $	*/
d82 1
a82 1
u_long	mpls_flags = 0;
d407 4
a410 1
					errx(1, "-in requires -mpls");
@


1.126
log
@Introduce -mplslabel to allow ipv4/ipv6 packets enter MPLS clouds.
This is also consistent with mplslabel in ifconfig(8).

OK claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.125 2009/01/28 22:19:53 michele Exp $	*/
d82 1
d394 1
a394 1
				flags |= MPLS_OP_PUSH;
d413 1
a413 1
				flags |= MPLS_OP_POP;
d418 1
a418 1
				flags |= MPLS_OP_PUSH;
d423 1
a423 1
				flags |= MPLS_OP_SWAP;
d1058 1
@


1.125
log
@Reflect MPLS kernel changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.124 2009/01/08 12:52:35 michele Exp $	*/
d386 9
d405 2
@


1.124
log
@Reflect MPLS kernel changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.123 2008/12/16 16:21:09 sthen Exp $	*/
a395 2
				if (af != AF_MPLS)
					errx(1, "-out requires -mpls");
d895 2
a896 2
	su->sa.sa_len = aflen;
	su->sa.sa_family = af;
@


1.123
log
@Use macros from route.h when mapping route priorities to names; the
hardcoded values used here before were incorrect.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.122 2008/12/15 16:14:57 michele Exp $	*/
d74 1
a74 1
} so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp, so_label;
a883 5
	rtm_addrs |= RTA_DST;
	su = &so_dst;
	su->sa.sa_len = aflen;
	su->sa.sa_family = af;

d887 12
a898 4
	if (in)
		su->smpls.smpls_in_label = htonl(label << MPLS_LABEL_OFFSET);
	else
		su->smpls.smpls_out_label = htonl(label << MPLS_LABEL_OFFSET);
d1059 1
@


1.122
log
@Reflect kernel changes. Labels are no more per link unique
and operations are now stored in rt_flags.
This also simplify a lot the syntax.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.121 2008/12/12 20:26:30 claudio Exp $	*/
d1245 1
a1245 1
	case 0:
d1247 1
a1247 1
	case 4:
d1249 1
a1249 1
	case 8:
d1251 1
a1251 1
	case 16:
d1253 1
a1253 1
	case 20:
d1255 1
a1255 1
	case 24:
d1257 1
a1257 1
	case 32:
d1259 1
a1259 1
	case 48:
@


1.121
log
@Use the hdrlen to skip over the header and to the sockaddrs instead of the
implied sizeof(struct rt_msghdr). Makes code more robust when userland and
kernel are out of sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.120 2008/09/15 20:12:11 claudio Exp $	*/
d403 1
a403 1
				so_dst.smpls.smpls_operation = MPLS_OP_POP;
d408 1
a408 1
				so_dst.smpls.smpls_operation = MPLS_OP_PUSH;
d413 1
a413 1
				so_dst.smpls.smpls_operation = MPLS_OP_SWAP;
a881 1
	char *ifname;
a882 1
	u_int16_t ifindex = 0;
a888 6
	ifname = strchr(s, SCOPE_DELIMITER);
	if (ifname) {
		*ifname++ = '\0';
		ifindex = if_nametoindex(ifname);
	}

d892 1
a892 1
	if (in) {
d894 1
a894 2
		su->smpls.smpls_in_ifindex = ifindex;
	} else {
a895 2
		su->smpls.smpls_out_ifindex = ifindex;
	}
@


1.120
log
@Mask rtm->rtm_priority with RTP_MASK before printing so that the priority is
correctly shown even if the route is flagged RTP_DOWN. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.119 2008/05/09 07:14:56 henning Exp $	*/
d277 1
a277 1
		sa = (struct sockaddr *)(rtm + 1);
d299 2
a300 1
			struct sockaddr *sa = (struct sockaddr *)(rtm + 1);
d1056 1
d1216 1
a1216 1
		pmsg_addrs((char *)(ifm + 1), ifm->ifm_addrs);
d1223 1
a1223 1
		pmsg_addrs((char *)(ifam + 1), ifam->ifam_addrs);
d1301 1
a1301 1
	cp = ((char *)(rtm + 1));
d1385 1
a1385 1
	pmsg_addrs(((char *)(rtm + 1)), rtm->rtm_addrs);
@


1.119
log
@using the rtm_priority to translate priority number into nice name is
working much better than using rtm_version for that
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.118 2008/05/09 06:52:47 henning Exp $	*/
d1241 1
a1241 1
		printf("priority %d, ", rtm->rtm_priority);
d1253 1
a1253 1
	switch (prio) {
d1346 1
a1346 1
	printf("   priority: %u (%s)\n", rtm->rtm_priority,
@


1.118
log
@on route get, display the priority and a cleartext name (like, "bgp" for 48)
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.117 2008/05/07 06:06:25 claudio Exp $	*/
d1347 1
a1347 1
	   priorityname(rtm->rtm_version)); 
@


1.117
log
@Add support to show and modify rtm_priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.116 2008/05/06 12:53:32 claudio Exp $	*/
d96 1
d1250 25
d1346 2
@


1.116
log
@Yet another missing RTM_VERSION check. Found by norby@@. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.115 2008/05/06 03:45:33 claudio Exp $	*/
d105 1
a105 1
int	 rtmsg(int, int, int);
d348 1
d353 1
d521 8
d577 1
a577 1
		if ((ret = rtmsg(*cmd, flags, fmask)) == 0)
d1013 1
a1013 1
rtmsg(int cmd, int flags, int fmask)
d1053 1
d1136 1
a1136 1
"\011pksent\010rttvar\7rtt\6ssthresh\5sendpipe\4recvpipe\3expire\2hopcount\1mtu";
d1144 1
a1144 1
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD\13LABEL";
d1240 2
a1241 1
		printf("table: %u, pid: %ld, seq %d, errno %d, flags:",
d1329 1
a1329 1
	printf("%s\n", "     use  hopcount       mtu    expire");
a1330 1
	printf("%8u%c ", rtm->rtm_rmx.rmx_hopcount, lock(HOPCOUNT));
@


1.115
log
@Add code to specify the mpls label switching operation. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.114 2008/05/06 03:44:14 claudio Exp $	*/
d270 2
@


1.114
log
@Labels in the sockaddr are stored like on the wire so shift and byte swap
them. This makes route lookups work again. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.113 2008/04/28 11:36:14 norby Exp $	*/
d393 15
@


1.113
log
@It is now possible to enter static MPLS routes into the kernel.

It is still not possible to set the desired opration for an entry.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.112 2007/09/25 08:57:47 henning Exp $	*/
d872 1
a872 1
		su->smpls.smpls_in_label = htonl(label);
d875 1
a875 1
		su->smpls.smpls_out_label = htonl(label);
@


1.112
log
@make route flush obey the rtable ID
From: Pierre Riteau <pierre.riteau@@free.fr>
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.111 2007/09/05 20:30:21 claudio Exp $	*/
d58 1
d73 1
d104 1
d233 3
d376 18
d611 3
d801 2
a802 1

d845 32
@


1.111
log
@Correct the format strings after the recent rt_metrics changes.
rmx_pksent is not u_int64_t all others are just u_int.
This is almost the same as in usr.bin/netstat.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.110 2007/06/04 12:23:43 henning Exp $	*/
d209 1
a209 1
	int mib[6], rlen, seqno;
d243 2
a244 1
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
d249 1
a249 1
		if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
d277 1
@


1.110
log
@remove IPX, agreed by many
libc and kernel side awaiting a libc major bump to piggyback to
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.109 2007/05/30 01:08:41 mcbride Exp $	*/
d305 1
a305 1
	u_long noval, *valp = &noval;
d1239 3
a1241 3
	printf("%8lu  ", rtm->rtm_rmx.rmx_pksent);
	printf("%8lu%c ", rtm->rtm_rmx.rmx_hopcount, lock(HOPCOUNT));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_mtu, lock(MTU));
d1244 1
a1244 1
	printf("%8ld%c\n", rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
@


1.109
log
@Unbreak route.c after TOKEN removal by henning (bad henning, no cookie)

looks ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.108 2007/03/25 16:10:35 claudio Exp $	*/
a43 1
#include <netipx/ipx.h>
a69 1
	struct sockaddr_ipx	sipx;
a226 3
			case K_IPX:
				af = AF_IPX;
				break;
a367 4
			case K_IPX:
				af = AF_IPX;
				aflen = sizeof(struct sockaddr_ipx);
				break;
a581 3
			case K_IPX:
				af = AF_IPX;
				break;
a768 13
	case AF_IPX:
		if (which == RTA_DST) {
			extern short ipx_bh[3];
			struct sockaddr_ipx *sms = &(so_mask.sipx);
			memset(sms, 0, sizeof(*sms));
			sms->sipx_family = 0;
			sms->sipx_len = 6;
			sms->sipx_addr.ipx_net = *(union ipx_net *)ipx_bh;
			rtm_addrs |= RTA_NETMASK;
		}
		su->sipx.sipx_addr = ipx_addr(s);
		return (!ipx_nullhost(su->sipx.sipx_addr));

a1010 1
	case AF_IPX:
a1366 3
	case AF_IPX:
		printf("%s: ipx %s; ", which, ipx_ntoa(su->sipx.sipx_addr));
		break;
@


1.108
log
@Instead of using the global -F flag that only works with show, switch to a
show specific modifier -gateway to show only routes whose gateway are in the
same AF as the destination.
Requested by deraadt@@, OK pyr@@, reyk@@, michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.107 2007/03/23 20:33:10 jmc Exp $	*/
a1093 3
		break;
	case IFT_ISO88025:
		media_type = IFM_TOKEN;
@


1.107
log
@add -F to usage() and kill some extraneous whitespace;
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.106 2007/03/23 16:02:26 pyr Exp $	*/
d120 1
a120 1
	    "usage: %s [-dFnqtv] [-T tableid] command [[modifiers] args]\n",
d140 1
a140 1
	while ((ch = getopt(argc, argv, "dFnqtT:v")) != -1)
a141 3
		case 'F':
			Fflag = 1;
			break;
d582 2
a583 3
	if (argc > 1) {
		argv++;
		if (argc == 2 && **argv == '-')
d599 3
@


1.106
log
@Add a new flag -F to netstat restricting route display in conjuction
with -r to routes in the same address family as the destination.
ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.105 2007/03/23 13:43:32 claudio Exp $	*/
d120 1
a120 1
	    "usage: %s [-dnqtv] [ -T tableid ] command [[modifiers] args]\n",
@


1.105
log
@Only print the routing table id if the routing message uses the rt_msghdr
else some random value is printed for messages like RTM_NEWADDR. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.104 2006/11/28 19:21:15 reyk Exp $	*/
d79 1
a79 1
int	forcehost, forcenet, nflag, af, qflag, tflag;
d140 1
a140 1
	while ((ch = getopt(argc, argv, "dnqtT:v")) != -1)
d142 3
@


1.104
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.103 2006/11/28 16:48:13 henning Exp $	*/
d1139 1
a1139 2
	printf("%s: len %d, table %u, ", msgtypes[rtm->rtm_type],
	    rtm->rtm_msglen, rtm->rtm_tableid);
d1177 3
a1179 2
		printf("pid: %ld, seq %d, errno %d, flags:",
		    (long)rtm->rtm_pid, rtm->rtm_seq, rtm->rtm_errno);
@


1.103
log
@-T in synopsis and briefly in manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.102 2006/11/17 01:11:23 itojun Exp $	*/
d1115 3
a1117 1
			return (p->ifms_string[link_state == LINK_STATE_UP]);
@


1.102
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.101 2006/10/15 09:44:25 mcbride Exp $	*/
d120 1
a120 1
	    "usage: %s [-dnqtv] command [[modifiers] args]\n",
@


1.101
log
@Proper link state descriptions in print_rtmsg() RTM_IFINFO case.

ok deraadt henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.100 2006/06/17 17:16:04 pascoe Exp $	*/
d764 2
a765 1
		     IN6_IS_ADDR_MC_LINKLOCAL(&su->sin6.sin6_addr)) &&
@


1.100
log
@Display multipath and jumbo flags in route get/monitor.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.99 2006/06/16 17:46:43 henning Exp $	*/
d58 1
d63 4
d1079 42
a1126 1
	const char *state = "unknown";
d1144 3
a1146 9
		switch (ifm->ifm_data.ifi_link_state) {
		case LINK_STATE_DOWN:
			state = "down";
			break;
		case LINK_STATE_UP:
			state = "up";
			break;
		}
		printf("link: %s, flags:", state);
@


1.99
log
@make route show work on secondary tables, using the just committed
extension to the syctl NET_RT_DUMP interface, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.98 2006/06/16 16:55:19 henning Exp $	*/
d1067 1
a1067 1
"\012XRESOLVE\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2\020PROTO1\021CLONED";
@


1.98
log
@introduce -T <tableid> to work on alternate tables.
purposefully undocumented for the moment, claudio hshoexer norby ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.97 2006/05/27 18:26:45 claudio Exp $	*/
d604 1
a604 1
	p_rttables(af);
@


1.97
log
@Kill unused Aflag support that sneeked in via netstat code.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.96 2006/05/21 13:27:08 mpf Exp $	*/
d79 1
d105 1
d135 1
a135 1
	while ((ch = getopt(argc, argv, "dnqtv")) != -1)
d149 3
d980 1
d1090 2
a1091 1
	printf("%s: len %d, ", msgtypes[rtm->rtm_type], rtm->rtm_msglen);
d1419 10
@


1.96
log
@Pretty print netmasks in monitor mode.
From Alexander Bluhm <Alexander_Bluhm at genua.de>
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.95 2006/04/20 11:21:17 claudio Exp $	*/
d599 1
a599 1
	p_rttables(af, 0);
@


1.95
log
@Instead of printing useless metrics like recvpipe and sendpipe print
rmx_pksent in route get. This makes it possible to identify DoS targets
even if you have a full routing table. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.94 2006/03/30 12:11:37 claudio Exp $	*/
d1249 1
d1251 1
d1257 2
d1261 20
a1280 1
				sa = (struct sockaddr *)cp;
d1282 1
a1282 1
				ADVANCE(cp, sa);
@


1.94
log
@If an address family is specified do not print IPSec "routes". Additionally
add a -encap option to show only the IPSec part. OK hshoexer@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.93 2006/03/30 09:56:06 claudio Exp $	*/
d1215 2
a1216 7
	printf("%s\n", "\
 recvpipe  sendpipe  ssthresh  rtt,msec    rttvar  hopcount      mtu     expire");
	printf("%8lu%c ", rtm->rtm_rmx.rmx_recvpipe, lock(RPIPE));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_sendpipe, lock(SPIPE));
	printf("%8lu%c ", rtm->rtm_rmx.rmx_ssthresh, lock(SSTHRESH));
	printf("%8lu%c ", msec(rtm->rtm_rmx.rmx_rtt), lock(RTT));
	printf("%8lu%c ", msec(rtm->rtm_rmx.rmx_rttvar), lock(RTTVAR));
@


1.93
log
@Really ignore sendpipe, recvpipe, rtt, rttvar, etc. in route(8) instead of
passing these values to the kernel where they get ignored anyway.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.92 2005/12/11 12:33:43 aaron Exp $	*/
d587 3
@


1.92
log
@Don't allow a -prefixlen arg of -1.  jaredy@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.91 2005/06/09 08:07:45 markus Exp $	*/
a306 4
	case K_HOPCOUNT:
		valp = &rt_metrics.rmx_hopcount;
		flag = RTV_HOPCOUNT;
		break;
d311 1
a312 3
		valp = &rt_metrics.rmx_recvpipe;
		flag = RTV_RPIPE;
		break;
a313 3
		valp = &rt_metrics.rmx_sendpipe;
		flag = RTV_SPIPE;
		break;
a314 3
		valp = &rt_metrics.rmx_ssthresh;
		flag = RTV_SSTHRESH;
		break;
a315 3
		valp = &rt_metrics.rmx_rtt;
		flag = RTV_RTT;
		break;
d317 2
a318 3
		valp = &rt_metrics.rmx_rttvar;
		flag = RTV_RTTVAR;
		break;
@


1.91
log
@print the interface address on route get; ok henning, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.90 2005/06/06 04:22:28 henning Exp $	*/
d862 1
a862 1
	if (len < -1 || len > max)
@


1.90
log
@get rid of another leftover from the src routing adventure
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.89 2005/05/27 22:38:52 mcbride Exp $	*/
d1151 1
a1151 1
	struct sockaddr *dst = NULL, *gate = NULL, *mask = NULL;
d1187 3
d1217 2
@


1.89
log
@Use rtm_fmask instead of rtm_use

ok marius@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.88 2005/05/27 04:55:27 mcbride Exp $	*/
a67 1
	struct sockaddr_rtin	rtin;
@


1.88
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.87 2005/03/30 07:59:03 henning Exp $	*/
d351 2
a352 1
	int ishost = 0, ret = 0, attempts, oerrno, flags = RTF_STATIC, use = 0;
d474 1
a474 1
				use |= RTF_JUMBO;
d478 1
a478 1
				use |= RTF_JUMBO;
d540 1
a540 1
		if ((ret = rtmsg(*cmd, flags, use)) == 0)
d950 1
a950 1
rtmsg(int cmd, int flags, int use)
d983 1
a983 1
	rtm.rtm_use = use;
@


1.87
log
@make set_metric() bail out on invalid keys (unreachable, but better
safe than sorry later)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.86 2005/03/30 05:34:30 henning Exp $	*/
d99 1
a99 1
int	 rtmsg(int, int);
d351 1
a351 1
	int ishost = 0, ret = 0, attempts, oerrno, flags = RTF_STATIC;
d471 8
d539 1
a539 1
		if ((ret = rtmsg(*cmd, flags)) == 0)
d949 1
a949 1
rtmsg(int cmd, int flags)
d982 1
@


1.86
log
@unconditionalize INET6 support, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.85 2005/03/30 05:29:04 henning Exp $	*/
d336 2
@


1.85
log
@spring cleaning, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.84 2005/03/30 05:20:18 henning Exp $	*/
a64 1
#ifdef INET6
a65 1
#endif
d97 1
a97 3
#ifdef INET6
int	inet6_makenetandmask(struct sockaddr_in6 *);
#endif
a216 1
#ifdef INET6
a219 1
#endif
a368 1
#ifdef INET6
a372 1
#endif
a584 1
#ifdef INET6
a587 1
#endif
a648 1
#ifdef INET6
a675 1
#endif
a736 1
#ifdef INET6
a755 1
#ifdef __KAME__
a762 1
#endif
a769 1
#endif
a842 1
#ifdef INET6
a845 1
#endif
a863 1
#ifdef INET6
a874 1
#endif
a1025 1
#ifdef INET6
a1026 1
#endif
a1313 1
#ifdef INET6
a1322 1
#endif
@


1.84
log
@remove ccitt x.25 traces, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.83 2005/02/18 04:00:21 jaredy Exp $	*/
a32 14
#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1989, 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)route.c	8.3 (Berkeley) 3/19/94";
#else
static const char rcsid[] = "$OpenBSD: route.c,v 1.83 2005/02/18 04:00:21 jaredy Exp $";
#endif
#endif /* not lint */

d63 2
a64 2
	struct	sockaddr sa;
	struct	sockaddr_in sin;
d66 1
a66 1
	struct	sockaddr_in6 sin6;
d68 4
a71 4
	struct	sockaddr_ipx sipx;
	struct	sockaddr_dl sdl;
	struct	sockaddr_rtin rtin;
	struct	sockaddr_rtlabel rtlabel;
a79 1
struct	rt_metrics rt_metrics;
d83 2
d100 1
a100 1
static int inet6_makenetandmask(struct sockaddr_in6 *);
d168 1
a168 1
	if (s < 0)
d262 1
a262 1
	seqno = 0;		/* ??? */
d294 2
a295 1
			sa = (struct sockaddr *)(ROUNDUP(sa->sa_len) + (char *)sa);
d663 1
a663 1
static int
d954 2
a955 2
	struct	rt_msghdr m_rtm;
	char	m_space[512];
@


1.83
log
@ansi, knf, and other style nits; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.82 2005/02/17 17:02:24 jaredy Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.82 2005/02/17 17:02:24 jaredy Exp $";
a58 1
#include <netccitt/x25.h>
a83 1
	struct	sockaddr_x25 sx25;
a116 1
int	 x25_makemask(void);
a121 1
int	 ccitt_addr(char *, struct sockaddr_x25 *);
a244 3
			case K_X25:
				af = AF_CCITT;
				break;
a392 4
			case K_X25:
				af = AF_CCITT;
				aflen = sizeof(struct sockaddr_x25);
				break;
a615 3
			case K_X25:
				af = AF_CCITT;
				break;
a815 4
	case AF_CCITT:
		ccitt_addr(s, &su->sx25);
		return (which == RTA_DST ? x25_makemask() : 1);

a910 15
int
x25_makemask(void)
{
	char *cp;

	if ((rtm_addrs & RTA_NETMASK) == 0) {
		rtm_addrs |= RTA_NETMASK;
		for (cp = (char *)&so_mask.sx25.x25_net;
		     cp < &so_mask.sx25.x25_opts.op_flags; cp++)
			*cp = -1;
		so_mask.sx25.x25_len = (u_char)&(((sup)0)->sx25.x25_opts);
	}
	return (0);
}

a1060 1
	case AF_CCITT:
@


1.82
log
@print the interface name in monitor mode when interfaces go up/down; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.81 2004/10/14 15:20:56 jaredy Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.81 2004/10/14 15:20:56 jaredy Exp $";
d93 2
a94 2
int	forcehost, forcenet, nflag, af, qflag, tflag, keyword(char *);
int	iflag, verbose, aflen = sizeof (struct sockaddr_in);
d97 1
a97 1
u_long  rtm_inits;
d103 1
d113 1
a113 1
void	 mask_addr(union sockunion *, union sockunion *, int which);
d121 5
a125 4
void	set_metric(char *, int);
void	inet_makenetandmask(u_int32_t, struct sockaddr_in *, int);
void	interfaces(void);
void	getlabel(char *);
d134 1
a134 1
	(void) fprintf(stderr,
d137 1
a137 1
	(void) fprintf(stderr,
d156 1
a156 1
		switch(ch) {
d174 1
d210 1
d234 1
a234 1
		    switch (keyword(*argv + 1)) {
d254 3
a256 1
		} else
d275 2
a276 2
		(void) printf("Examining routing table from sysctl\n");
		 if (af)
d301 1
a301 1
			(void) printf("got only %d for rlen\n", rlen);
d311 1
a311 1
			(void) printf("%-20.20s ", rtm->rtm_flags & RTF_HOST ?
d315 2
a316 2
			(void) printf("%-20.20s ", routename(sa));
			(void) printf("done\n");
d329 32
a360 9
#define caseof(x, y, z)	case x: valp = &rt_metrics.z; flag = y; break
	caseof(K_MTU, RTV_MTU, rmx_mtu);
	caseof(K_HOPCOUNT, RTV_HOPCOUNT, rmx_hopcount);
	caseof(K_EXPIRE, RTV_EXPIRE, rmx_expire);
	caseof(K_RECVPIPE, RTV_RPIPE, rmx_recvpipe);
	caseof(K_SENDPIPE, RTV_SPIPE, rmx_sendpipe);
	caseof(K_SSTHRESH, RTV_SSTHRESH, rmx_ssthresh);
	caseof(K_RTT, RTV_RTT, rmx_rtt);
	caseof(K_RTTVAR, RTV_RTTVAR, rmx_rttvar);
d376 1
a376 1
	struct hostent *hp = 0;
d455 1
a455 1
				(void) getaddr(RTA_IFA, *++argv, 0);
d460 1
a460 1
				(void) getaddr(RTA_IFP, *++argv, 0);
d465 1
a465 1
				(void) getaddr(RTA_GENMASK, *++argv, 0);
d470 1
a470 1
				(void) getaddr(RTA_GATEWAY, *++argv, 0);
d482 1
a482 1
				(void) getlabel(*++argv);
d487 1
a487 1
				(void) getaddr(RTA_NETMASK, *++argv, 0);
d514 1
d522 1
a522 1
				(void) getaddr(RTA_GATEWAY, *argv, &hp);
d543 1
a543 1
				(void) getaddr(RTA_NETMASK, *argv, 0);
d575 1
a575 1
		(void) printf("%s %s %s", cmd, ishost? "host" : "net", dest);
d577 1
a577 1
			(void) printf(": gateway %s", gateway);
d579 1
a579 2
			    (void) printf(" (%s)",
				inet_ntoa(so_gate.sin.sin_addr));
d582 1
a582 1
			(void) printf("\n");
d598 1
a598 1
			(void) printf(": %s\n", error);
d609 7
a615 7
        if (argc > 1) {
                argv++;
                if (argc == 2 && **argv == '-')
                    switch (keyword(*argv + 1)) {
                        case K_INET:
                                af = AF_INET;
                                break;
d617 3
a619 3
                        case K_INET6:
                                af = AF_INET6;
                                break;
d621 10
a630 10
                        case K_IPX:
                                af = AF_IPX;
                                break;
                        case K_LINK:
                                af = AF_LINK;
                                break;
                        case K_X25:
                                af = AF_CCITT;
                                break;
                        default:
d632 3
a634 1
                } else
d636 2
a637 2
        }
	
d665 1
a665 1
			mask =  IN_CLASSA_NET;
d667 1
a667 1
			mask =  IN_CLASSB_NET;
d669 1
a669 1
			mask =  IN_CLASSC_NET;
d680 1
a680 1
	while (*--cp == 0 && cp > (char *)sin)
d706 1
a706 1
		return 1;
d709 2
a710 2
		(void)prefixlen(plen);
		return 0;
a722 1
	struct ccitt_addr *ccitt_addr(char *, struct sockaddr_x25 *);
d756 1
d765 1
a765 1
			getaddr(RTA_NETMASK, s, 0);
d871 1
d875 1
d896 1
d986 1
a986 1
	for(;;) {
d993 1
a993 1
		(void) printf("got message of size %d on %s", n, ctime(&now));
d1010 7
a1016 4
#define NEXTADDR(w, u) \
	if (rtm_addrs & (w)) {\
	    l = ROUNDUP(u.sa.sa_len); memcpy(cp, &(u), l); cp += l;\
	    if (verbose) sodump(&(u),#u);\
d1057 1
a1057 1
	if (write(s, (char *)&m_rtmsg, l) != l) {
d1064 1
a1064 1
			l = read(s, (char *)&m_rtmsg, sizeof(m_rtmsg));
d1082 1
a1082 1
		if (*--cp1 != 0) {
d1101 1
a1101 1
		*--cp2 = 0;
d1124 1
a1124 1
	0,
d1154 1
a1154 1
	(void)printf("%s: len %d, ", msgtypes[rtm->rtm_type], rtm->rtm_msglen);
d1160 1
a1160 1
			(void) printf("name: %s, ", ifname);
d1169 1
a1169 1
		(void) printf("link: %s, flags:", state);
d1176 1
a1176 1
		(void) printf("metric %d, flags:", ifam->ifam_metric);
d1182 1
a1182 1
		(void) printf("if# %d, name %s, what: ",
d1198 2
a1199 2
		(void) printf("pid: %ld, seq %d, errno %d, flags:",
			(long)rtm->rtm_pid, rtm->rtm_seq, rtm->rtm_errno);
d1215 1
a1215 1
	(void) printf("   route to: %s\n", routename(&so_dst.sa));
d1221 1
a1221 1
	if (rtm->rtm_msglen > msglen) {
d1224 1
a1224 2
	}
	if (rtm->rtm_errno)  {
d1258 1
a1258 1
		(void)printf("destination: %s\n", routename(dst));
d1263 1
a1263 1
		(void)printf("       mask: %s\n", routename(mask));
d1267 1
a1267 1
		(void)printf("    gateway: %s\n", routename(gate));
d1269 1
a1269 1
		(void)printf("  interface: %.*s\n",
d1271 1
a1271 1
	(void)printf("      flags: ");
d1280 1
a1280 1
	(void) printf("%s\n", "\
d1290 1
a1290 1
		rtm->rtm_rmx.rmx_expire -= time(0);
d1298 1
a1298 1
		(void) printf("sockaddrs: ");
d1308 1
a1308 1
	(void) printf("\nlocks: ");
d1310 1
a1310 1
	(void) printf(" inits: ");
d1322 1
a1322 1
		(void) printf("\nsockaddrs: ");
d1324 1
a1324 1
		(void) putchar('\n');
d1328 1
a1328 1
				(void) printf(" %s", routename(sa));
d1332 2
a1333 2
	(void) putchar('\n');
	(void) fflush(stdout);
d1350 1
a1350 1
			(void) putc(i, fp);
d1353 1
a1353 1
				(void) putc(i, fp);
d1359 1
a1359 1
		(void) putc('>', fp);
d1377 1
a1377 2
		(void) printf("%s: link %s; ",
		    which, link_ntoa(&su->sdl));
d1380 1
a1380 2
		(void) printf("%s: inet %s; ",
		    which, inet_ntoa(su->sin.sin_addr));
d1387 1
a1387 1
		(void) printf("%s: inet6 %s; ",
d1389 1
a1389 1
				     ntop_buf, sizeof(ntop_buf)));
d1394 1
a1394 2
		(void) printf("%s: ipx %s; ",
		    which, ipx_ntoa(su->sipx.sipx_addr));
d1397 1
a1397 1
	(void) fflush(stdout);
d1426 1
a1426 1
		} else if (*addr == 0)
@


1.81
log
@avoid collision of variable "err" with err()
use errx() after strlcpy if out of space
style nits/knf

ok henning hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.80 2004/10/13 22:54:35 jaredy Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.80 2004/10/13 22:54:35 jaredy Exp $";
d1108 1
d1122 2
@


1.80
log
@print the expire route metric as signed; ok deraadt claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.79 2004/09/26 19:46:01 jaredy Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.79 2004/09/26 19:46:01 jaredy Exp $";
d344 1
a344 1
	char *cmd, *dest = "", *gateway = "", *err;
d557 1
a557 1
				err = "not in table";
d560 1
a560 1
				err = "entry in use";
d563 1
a563 1
				err = "routing table overflow";
d566 1
a566 1
				err = strerror(oerrno);
d569 1
a569 1
			(void) printf(": %s\n", err);
d1423 1
a1423 1
		err(1, "label too long");
@


1.79
log
@fix printf's for route metrics.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.78 2004/09/24 14:35:15 jaredy Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.78 2004/09/24 14:35:15 jaredy Exp $";
d1252 1
a1252 1
	printf("%8lu%c\n", rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
@


1.78
log
@simplify some parts, little more warn() fixing.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.77 2004/09/24 01:24:30 jaredy Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.77 2004/09/24 01:24:30 jaredy Exp $";
d1243 7
a1249 7
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_recvpipe, lock(RPIPE));
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_sendpipe, lock(SPIPE));
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_ssthresh, lock(SSTHRESH));
	printf("%8d%c ", (int)msec(rtm->rtm_rmx.rmx_rtt), lock(RTT));
	printf("%8d%c ", (int)msec(rtm->rtm_rmx.rmx_rttvar), lock(RTTVAR));
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_hopcount, lock(HOPCOUNT));
	printf("%8d%c ", (int)rtm->rtm_rmx.rmx_mtu, lock(MTU));
d1252 1
a1252 1
	printf("%8d%c\n", (int)rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
@


1.77
log
@kill homegrown quit(); use err()/errx() instead
make other error messages consistent
sync usage

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.76 2004/09/23 20:20:19 henning Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.76 2004/09/23 20:20:19 henning Exp $";
d185 1
a185 1
		goto no_cmd;
a204 1
	no_cmd:
d249 1
a249 1
				goto bad;
d251 1
a251 1
bad:			usage(*argv);
d284 2
a285 4
		if (af) {
			if (sa->sa_family != af)
				continue;
		}
d346 1
a346 1
	int key, mpath = 0;
d469 1
a469 1
				mpath++;
a523 2
	if (mpath)
		flags |= RTF_MPATH;
d602 1
a602 1
                                goto bad;
d604 1
a604 1
bad:                    usage(*argv);
d1112 1
a1112 1
		(void) printf("routing message version %d not understood\n",
d1186 1
a1186 1
		warnx("RTM_GET: %s (errno %d)\n",
a1335 4
#ifdef INET6
	char ntop_buf[NI_MAXHOST];	/*for inet_ntop()*/
#endif

d1347 3
d1354 1
@


1.76
log
@properly check read() and write() return values.
one instance found by jaredy, causes issues with route -t monitor
ok jaredy hshoexer mickey fgs
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.75 2004/09/22 01:07:10 jaredy Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.75 2004/09/22 01:07:10 jaredy Exp $";
a119 1
void	quit(char *);
d128 2
d131 1
a131 1
		(void) fprintf(stderr, "route: botched keyword: %s\n", cp);
d133 2
a134 1
	    "usage: route [ -nqSv ] cmd [[ -<modifiers> ] args ]\n");
d136 1
a136 14
	    "keywords: get, add, change, delete, show, flush, monitor.\n");
	exit(1);
	/* NOTREACHED */
}

void
quit(char *s)
{
	int sverrno = errno;

	(void) fprintf(stderr, "route: ");
	if (s)
		(void) fprintf(stderr, "%s: ", s);
	(void) fprintf(stderr, "%s\n", strerror(sverrno));
a137 1
	/* NOTREACHED */
d183 1
a183 1
		quit("socket");
d225 2
a226 4
	if (uid) {
		errno = EACCES;
		quit("must be root to alter routing table");
	}
d261 1
a261 1
		quit("route-sysctl-estimate");
d264 1
a264 1
			quit("malloc");
d266 1
a266 1
			quit("actual retrieval of routing table");
d297 1
a297 3
			(void) fprintf(stderr,
			    "route: write to routing socket: %s\n",
			    strerror(errno));
d352 2
a353 4
	if (uid) {
		errno = EACCES;
		quit("must be root to alter routing table");
	}
d760 2
a761 13
			if (getaddrinfo(s, "0", &hints, &res) != 0) {
				(void) fprintf(stderr, "%s: bad value\n", s);
				exit(1);
			}
		}
		if (sizeof(su->sin6) != res->ai_addrlen) {
			(void) fprintf(stderr, "%s: bad value\n", s);
			exit(1);
		}
		if (res->ai_next) {
			(void) fprintf(stderr,
			    "%s: resolved to multiple values\n", s);
			exit(1);
d763 4
d867 1
a867 3
		(void) fprintf(stderr,
		    "prefixlen is not supported with af %d\n", af);
		exit(1);
d871 2
a872 4
	if (len < -1 || len > max) {
		(void) fprintf(stderr, "%s: bad value\n", s);
		exit(1);
	}
d930 1
a930 1
		quit("route-sysctl-estimate");
d933 1
a933 1
			quit("malloc");
d935 1
a935 1
			quit("actual retrieval of interface table");
d1027 1
a1027 1
			perror("writing to routing socket");
d1035 1
a1035 3
			(void) fprintf(stderr,
			    "route: read from routing socket: %s\n",
			    strerror(errno));
d1182 1
a1182 2
		(void)fprintf(stderr,
		    "routing message version %d not understood\n",
d1187 1
a1187 2
		(void)fprintf(stderr,
		    "message length mismatch, in packet %d, returned %d\n",
d1191 1
a1191 1
		(void) fprintf(stderr, "RTM_GET: %s (errno %d)\n",
@


1.75
log
@remove -S, -src, -srcmask, and other source routing stuff.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.74 2004/09/15 23:40:29 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.74 2004/09/15 23:40:29 deraadt Exp $";
d979 1
d987 5
a991 2
		time_t now;
		n = read(s, msg, 2048);
d1054 1
a1054 1
	if (write(s, (char *)&m_rtmsg, l) < 0) {
d1063 1
a1063 1
		if (l < 0)
@


1.74
log
@lint demands little cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.73 2004/09/07 10:14:43 markus Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.73 2004/09/07 10:14:43 markus Exp $";
d88 1
a88 1
} so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp, so_src, so_srcmask, so_label;
d94 1
a94 1
int	Sflag, iflag, verbose, aflen = sizeof (struct sockaddr_in);
d122 1
a122 1
void	inet_makenetandmask(u_int32_t, struct sockaddr_in *, int, int);
d165 1
a165 1
	while ((ch = getopt(argc, argv, "nqdtvS")) != -1)
a181 3
		case 'S':
			Sflag = 1;
			break;
d363 1
a363 1
	char *cmd, *dest = "", *source = "", *gateway = "", *err;
a470 11
			case K_SRC:
				if (!--argc)
					usage(1+*argv);
				(void) getaddr(RTA_SRC, *++argv, 0);
				source = *argv;
				break;
			case K_SRCMASK:
				if (!--argc)
					usage(1+*argv);
				(void) getaddr(RTA_SRCMASK, *++argv, 0);
				break;
d508 1
a508 1
			if ((rtm_addrs & (RTA_DST|RTA_SRC)) == 0) {
a550 5
	if (rtm_addrs & (RTA_SRC|RTA_SRCMASK)) {
		if (!(rtm_addrs & RTA_DST))
			getaddr(RTA_DST, "default", &hp);
		flags |= RTF_SOURCE;
	}
a568 2
		if (*source)
			(void) printf(": source %s", source);
d630 1
a630 1
	p_rttables(af, 0, Sflag);
d634 1
a634 1
inet_makenetandmask(u_int32_t net, struct sockaddr_in *sin, int bits, int which)
d639 1
a639 1
	rtm_addrs |= (which == RTA_DST) ? RTA_NETMASK : RTA_SRCMASK;
d667 1
a667 1
	sin = (which == RTA_DST) ? &so_mask.sin : &so_srcmask.sin;
a746 6
	case RTA_SRC:
		su = &so_src;
		break;
	case RTA_SRCMASK:
		su = &so_srcmask;
		break;
d841 1
a841 1
		if ((which == RTA_DST || which == RTA_SRC) && !forcehost) {
d849 1
a849 1
				    &su->sin, bits, which);
d854 1
a854 2
				inet_makenetandmask(np->n_net, &su->sin, 0,
				    which);
a1037 2
	if (rtm_addrs & RTA_SRCMASK)
		mask_addr(&so_src, &so_srcmask, RTA_SRC);
a1043 2
	NEXTADDR(RTA_SRC, so_src);
	NEXTADDR(RTA_SRCMASK, so_srcmask);
d1125 2
a1126 1
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010MASK_PRESENT\011CLONING\012XRESOLVE\013LLINFO\014STATIC\015BLACKHOLE\016PROTO3\017PROTO2\020PROTO1\021CLONED\022SOURCE";
d1128 2
a1129 1
"\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5PTP\6NOTRAILERS\7RUNNING\010NOARP\011PPROMISC\012ALLMULTI\013OACTIVE\014SIMPLEX\015LINK0\016LINK1\017LINK2\020MULTICAST";
d1131 1
a1131 1
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD\011SRC\012SRCMASK\13LABEL";
a1200 1
	struct sockaddr *src = NULL, *srcmask = NULL;
a1238 6
				case RTA_SRC:
					src = sa;
					break;
				case RTA_SRCMASK:
					srcmask = sa;
					break;
a1260 11
	if (src && srcmask)
		srcmask->sa_family = src->sa_family;	/* XXX */
	if (src)
		(void)printf("     source: %s\n", routename(src));
	if (srcmask) {
		int savenflag = nflag;

		nflag = 1;
		(void)printf("       mask: %s\n", routename(mask));
		nflag = savenflag;
	}
d1289 1
a1289 2
#define	RTA_IGN	(RTA_DST|RTA_GATEWAY|RTA_NETMASK|RTA_SRC|RTA_SRCMASK| \
		    RTA_IFP|RTA_IFA|RTA_BRD)
@


1.73
log
@make -netmask work again; ok henning, mcbride, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.72 2004/08/03 11:23:11 henning Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.72 2004/08/03 11:23:11 henning Exp $";
d93 1
a93 1
int	forcehost, forcenet, doflush, nflag, af, qflag, tflag, keyword(char *);
d111 1
a111 1
void	 bprintf(FILE *, int, u_char *);
d684 1
a684 1
			mask = -1;
a1030 1
	int rlen;
d1082 1
a1082 1
	if ((rlen = write(s, (char *)&m_rtmsg, l)) < 0) {
d1381 1
a1381 1
bprintf(FILE *fp, int b, u_char *s)
@


1.72
log
@display route labels with "route get", and allow them to be set
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.71 2004/06/25 01:26:01 henning Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.71 2004/06/25 01:26:01 henning Exp $";
d556 2
d871 1
a871 3
			if (bits == 32) {
				if (forcenet)
					errx(1, "%s: not a network", s);
a872 1
			}
@


1.71
log
@remove netiso and netns code
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.70 2004/06/19 19:55:53 cedric Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.70 2004/06/19 19:55:53 cedric Exp $";
d87 2
a88 1
} so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp, so_src, so_srcmask;
d124 1
d485 5
d1078 1
d1163 1
a1163 1
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD\011SRC\012SRCMASK";
d1235 1
d1283 3
d1318 3
d1325 1
a1325 1
	(void) printf("\n%s\n", "\
d1498 12
@


1.70
log
@require RTF_MPATH to enter a multipath route with RTM_ADD.
route(8) takes a new -mpath modifier to enter a multipath route.
requested deraadt@@, ok itojun@@ mcbride@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.69 2004/06/12 09:40:49 claudio Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.69 2004/06/12 09:40:49 claudio Exp $";
a57 1
#include <netns/ns.h>
a58 1
#include <netiso/iso.h>
a82 1
	struct	sockaddr_ns sns;
a83 1
	struct	sockaddr_iso siso;
a254 3
			case K_XNS:
				af = AF_NS;
				break;
a260 4
			case K_ISO:
			case K_OSI:
				af = AF_ISO;
				break;
a382 5
			case K_OSI:
			case K_ISO:
				af = AF_ISO;
				aflen = sizeof(struct sockaddr_iso);
				break;
a400 4
			case K_XNS:
				af = AF_NS;
				aflen = sizeof(struct sockaddr_ns);
				break;
a626 3
                        case K_XNS:
                                af = AF_NS;
                                break;
a632 4
                        case K_ISO:
                        case K_OSI:
                                af = AF_ISO;
                                break;
a829 13
	case AF_NS:
		if (which == RTA_DST) {
			extern short ns_bh[3];
			struct sockaddr_ns *sms = &(so_mask.sns);
			memset(sms, 0, sizeof(*sms));
			sms->sns_family = 0;
			sms->sns_len = 6;
			sms->sns_addr.x_net = *(union ns_net *)ns_bh;
			rtm_addrs |= RTA_NETMASK;
		}
		su->sns.sns_addr = ns_addr(s);
		return (!ns_nullhost(su->sns.sns_addr));

a842 12
	case AF_OSI:
		su->siso.siso_addr = *iso_addr(s);
		if (which == RTA_NETMASK || which == RTA_GENMASK) {
			char *cp = (char *)TSEL(&su->siso);
			su->siso.siso_nlen = 0;
			do {
				--cp;
			} while ((cp > (char *)su) && (*cp == 0));
			su->siso.siso_len = 1 + cp - (char *)su;
		}
		return (1);

a1109 1
	case AF_NS:
a1117 4
	case AF_ISO:
		olen = MIN(addr->siso.siso_nlen,
			   MAX(mask->sa.sa_len - 6, 0));
		break;
a1125 5
	switch (addr->sa.sa_family) {
	case AF_ISO:
		addr->siso.siso_nlen = olen;
		break;
	}
a1414 4
	case AF_ISO:
		(void) printf("%s: iso %s; ",
		    which, iso_ntoa(&su->siso.siso_addr));
		break;
a1425 4
	case AF_NS:
		(void) printf("%s: xns %s; ",
		    which, ns_ntoa(su->sns.sns_addr));
		break;
@


1.69
log
@Make route show output similar to netstat -r output.
OK cedric@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.68 2004/06/09 19:32:08 cedric Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.68 2004/06/09 19:32:08 cedric Exp $";
d377 1
a377 1
	int key;
d516 3
d570 2
@


1.68
log
@Fix IPv4 name->address translation. Addresses like "10.1000" will not be
accepted anymore, but constructs like "route add 10.1.2/24 <gw>" will
finally do the right thing. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.67 2004/06/06 17:08:23 cedric Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.67 2004/06/06 17:08:23 cedric Exp $";
d54 2
a56 1
#include <net/if_dl.h>
d70 1
d77 1
a102 2
char	*routename(struct sockaddr *);
char	*netname(struct sockaddr *);
d105 1
d122 4
a125 8
__dead void usage(char *cp);
void	quit(char *s);
char	*any_ntoa(const struct sockaddr *sa);
void	set_metric(char *value, int key);
void	inet_makenetandmask(u_int32_t net, struct sockaddr_in *sin, int bits,
	    int which);
char	*ns_print(struct sockaddr_ns *sns);
char	*ipx_print(struct sockaddr_ipx *sipx);
a127 2
extern void show(int, char **);	/* XXX - from show.c */

d337 2
a338 1
			    routename(sa) : netname(sa));
a346 232
static char hexlist[] = "0123456789abcdef";

char *
any_ntoa(const struct sockaddr *sa)
{
	static char obuf[240];
	const char *in = sa->sa_data;
	char *out = obuf;
	int len = sa->sa_len - 2;

	*out++ = 'Q';
	do {
		*out++ = hexlist[(*in >> 4) & 15];
		*out++ = hexlist[(*in++)    & 15];
		*out++ = '.';
	} while (--len > 0 && (out + 3) < &obuf[sizeof obuf-1]);
	out[-1] = '\0';
	return (obuf);
}

char *
routename(struct sockaddr *sa)
{
	char *cp = NULL;
	static char line[MAXHOSTNAMELEN];
	struct hostent *hp;
	static char domain[MAXHOSTNAMELEN];
	static int first = 1;
	char *ns_print(struct sockaddr_ns *);
	char *ipx_print(struct sockaddr_ipx *);

	if (first) {
		first = 0;
		if (gethostname(domain, sizeof domain) == 0 &&
		    (cp = strchr(domain, '.')))
			(void) strlcpy(domain, cp + 1, sizeof domain);
		else
			domain[0] = 0;
		cp = NULL;
	}

	if (sa->sa_len == 0)
		(void) strlcpy(line, "default", sizeof line);
	else switch (sa->sa_family) {

	case AF_INET:
	    {	struct in_addr in;
		in = ((struct sockaddr_in *)sa)->sin_addr;

		if (in.s_addr == INADDR_ANY || sa->sa_len < 4)
			cp = "default";
		if (!cp && !nflag) {
			if ((hp = gethostbyaddr((char *)&in.s_addr,
			    sizeof (in.s_addr), AF_INET)) != NULL) {
				if ((cp = strchr(hp->h_name, '.')) &&
				    !strcmp(cp + 1, domain))
					*cp = 0;
				cp = hp->h_name;
			}
		}
		strlcpy(line, cp ? cp : inet_ntoa(in), sizeof line);
		break;
	    }

#ifdef INET6
	case AF_INET6:
	    {
		struct sockaddr_in6 sin6;
		int niflags;

#ifdef NI_WITHSCOPEID
		niflags = NI_WITHSCOPEID;
#else
		niflags = 0;
#endif
		if (nflag)
			niflags |= NI_NUMERICHOST;
		memset(&sin6, 0, sizeof(sin6));
		memcpy(&sin6, sa, sa->sa_len);
		sin6.sin6_len = sizeof(struct sockaddr_in6);
		sin6.sin6_family = AF_INET6;
#ifdef __KAME__
		if (sa->sa_len == sizeof(struct sockaddr_in6) &&
		    (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr)) &&
		    sin6.sin6_scope_id == 0) {
			sin6.sin6_scope_id =
			    ntohs(*(u_int16_t *)&sin6.sin6_addr.s6_addr[2]);
			sin6.sin6_addr.s6_addr[2] = 0;
			sin6.sin6_addr.s6_addr[3] = 0;
		}
#endif
		if (getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
		    line, sizeof(line), NULL, 0, niflags) != 0)
			strncpy(line, "invalid", sizeof(line));
		break;
	    }
#endif

	case AF_NS:
		return (ns_print((struct sockaddr_ns *)sa));

	case AF_IPX:
		return (ipx_print((struct sockaddr_ipx *)sa));

	case AF_LINK:
		return (link_ntoa((struct sockaddr_dl *)sa));

	case AF_ISO:
		(void) snprintf(line, sizeof line, "iso %s",
		    iso_ntoa(&((struct sockaddr_iso *)sa)->siso_addr));
		break;

	default:
		(void) snprintf(line, sizeof line, "(%d) %s",
		    sa->sa_family, any_ntoa(sa));
		break;
	}
	return (line);
}

/*
 * Return the name of the network whose address is given.
 * The address is assumed to be that of a net or subnet, not a host.
 */
char *
netname(struct sockaddr *sa)
{
	char *cp = NULL;
	static char line[MAXHOSTNAMELEN];
	struct netent *np = 0;
	in_addr_t net, mask, subnetshift;
	char *ns_print(struct sockaddr_ns *);
	char *ipx_print(struct sockaddr_ipx *);

	switch (sa->sa_family) {

	case AF_INET:
	    {
		struct in_addr in = ((struct sockaddr_in *)sa)->sin_addr;

		in.s_addr = ntohl(in.s_addr);
		if (in.s_addr == 0)
			cp = "default";
		else if (!nflag) {
			if (IN_CLASSA(in.s_addr)) {
				mask = IN_CLASSA_NET;
				subnetshift = 8;
			} else if (IN_CLASSB(in.s_addr)) {
				mask = IN_CLASSB_NET;
				subnetshift = 8;
			} else {
				mask = IN_CLASSC_NET;
				subnetshift = 4;
			}
			/*
			 * If there are more bits than the standard mask
			 * would suggest, subnets must be in use.
			 * Guess at the subnet mask, assuming reasonable
			 * width subnet fields.
			 */
			while (in.s_addr &~ mask)
				mask = (int)mask >> subnetshift;
			net = in.s_addr & mask;
			while ((mask & 1) == 0)
				mask >>= 1, net >>= 1;
			np = getnetbyaddr(net, AF_INET);
			if (np)
				cp = np->n_name;
		}
		in = ((struct sockaddr_in *)sa)->sin_addr;
		strlcpy(line, cp ? cp : inet_ntoa(in), sizeof line);
		break;
	    }

#ifdef INET6
	case AF_INET6:
	    {
		struct sockaddr_in6 sin6;
		int niflags;

#ifdef NI_WITHSCOPEID
		niflags = NI_WITHSCOPEID;
#else
		niflags = 0;
#endif
		if (nflag)
			niflags |= NI_NUMERICHOST;
		memset(&sin6, 0, sizeof(sin6));
		memcpy(&sin6, sa, sa->sa_len);
		sin6.sin6_len = sizeof(struct sockaddr_in6);
		sin6.sin6_family = AF_INET6;
#ifdef __KAME__
		if (sa->sa_len == sizeof(struct sockaddr_in6) &&
		    (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr)) &&
		    sin6.sin6_scope_id == 0) {
			sin6.sin6_scope_id =
			    ntohs(*(u_int16_t *)&sin6.sin6_addr.s6_addr[2]);
			sin6.sin6_addr.s6_addr[2] = 0;
			sin6.sin6_addr.s6_addr[3] = 0;
		}
#endif
		if (getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
		    line, sizeof(line), NULL, 0, niflags) != 0)
			strncpy(line, "invalid", sizeof(line));
		break;
	    }
#endif

	case AF_NS:
		return (ns_print((struct sockaddr_ns *)sa));

	case AF_IPX:
		return (ipx_print((struct sockaddr_ipx *)sa));

	case AF_LINK:
		return (link_ntoa((struct sockaddr_dl *)sa));

	case AF_ISO:
		(void) snprintf(line, sizeof line, "iso %s",
		    iso_ntoa(&((struct sockaddr_iso *)sa)->siso_addr));
		break;

	default:
		snprintf(line, sizeof line, "af %d: %s",
		    sa->sa_family, any_ntoa(sa));
		break;
	}
	return (line);
}

d626 42
a1010 92
}

short ns_nullh[] = {0,0,0};
short ns_bh[] = {-1,-1,-1};

char *
ns_print(struct sockaddr_ns *sns)
{
	struct ns_addr work;
	union { union ns_net net_e; u_int32_t long_e; } net;
	u_short port;
	static char mybuf[50+MAXHOSTNAMELEN];
	char cport[10], chost[25];
	char *host = "";
	u_char *q;

	work = sns->sns_addr;
	port = ntohs(work.x_port);
	work.x_port = 0;
	net.net_e  = work.x_net;
	if (ns_nullhost(work) && net.long_e == 0) {
		if (!port)
			return ("*.*");
		(void) snprintf(mybuf, sizeof mybuf, "*.0x%x", port);
		return (mybuf);
	}

	if (memcmp(ns_bh, work.x_host.c_host, 6) == 0)
		host = "any";
	else if (memcmp(ns_nullh, work.x_host.c_host, 6) == 0)
		host = "*";
	else {
		q = work.x_host.c_host;
		(void) snprintf(chost, sizeof chost, "0x%02x%02x%02x%02x%02x%02x",
			q[0], q[1], q[2], q[3], q[4], q[5]);
		host = chost;
	}
	if (port)
		(void) snprintf(cport, sizeof cport, ".0x%x", htons(port));
	else
		*cport = '\0';

	(void) snprintf(mybuf, sizeof mybuf, "0x%x.%s%s",
	    ntohl(net.long_e), host, cport);
	return (mybuf);
}

short ipx_nullh[] = {0,0,0};
short ipx_bh[] = {-1,-1,-1};

char *
ipx_print(struct sockaddr_ipx *sipx)
{
	struct ipx_addr work;
	union { union ipx_net net_e; u_int32_t long_e; } net;
	u_short port;
	static char mybuf[50+MAXHOSTNAMELEN], cport[10], chost[25];
	char *host = "";
	char *p;
	u_char *q;

	work = sipx->sipx_addr;
	port = ntohs(work.ipx_port);
	work.ipx_port = 0;
	net.net_e  = work.ipx_net;
	if (ipx_nullhost(work) && net.long_e == 0) {
		if (!port)
			return ("*.*");
		(void) snprintf(mybuf, sizeof mybuf, "*.0x%XH", port);
		return (mybuf);
	}

	if (memcmp(ipx_bh, work.ipx_host.c_host, 6) == 0)
		host = "any";
	else if (memcmp(ipx_nullh, work.ipx_host.c_host, 6) == 0)
		host = "*";
	else {
		q = work.ipx_host.c_host;
		(void) snprintf(chost, sizeof chost, "%02X%02X%02X%02X%02X%02XH",
			q[0], q[1], q[2], q[3], q[4], q[5]);
		for (p = chost; *p == '0' && p < chost + 12; p++)
			/* void */;
		host = p;
	}
	if (port)
		(void) snprintf(cport, sizeof cport, ".%XH", htons(port));
	else
		*cport = 0;

	(void) snprintf(mybuf, sizeof mybuf, "%XH.%s%s",
	    ntohl(net.long_e), host, cport);
	return (mybuf);
@


1.67
log
@add new "-src" and "-srcmask" modifiers to make it possible to add a source
selector part to the routing table entry. complements existing "-dst" and
"-dstmask". typical use:

   route add -src 20.20.20.22 20.20.20.21
   route add -src 192.168.1.0/24 -dst 192.168.2.0/24 20.20.20.21

useful for example to implement symetrical routing on multihomed boxes,
or to better select which packets to send to gif/tun/... tunnels.
new '-S' flag similar to netstat one. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.66 2004/05/15 07:43:34 claudio Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.66 2004/05/15 07:43:34 claudio Exp $";
d72 1
d892 1
d945 1
a945 3
	u_long val;
	char *q, qs;
	int afamily;
d952 1
a972 1
		su->sa.sa_family = af;
d981 1
a981 2
		usage("Internal Error");
		/*NOTREACHED*/
d984 2
a985 1
	su->sa.sa_family = afamily; /* cases that don't want it have left already */
d990 1
a990 1
			(void) getaddr(RTA_NETMASK, s, 0);
d998 1
d1097 24
a1120 17
	default:
		break;
	}

	if (hpp == NULL)
		hpp = &hp;
	*hpp = NULL;

	q = strchr(s,'/');
	if (q && (which == RTA_DST || which == RTA_SRC)) {
		qs = *q;
		*q = '\0';
		val = inet_addr(s);
		if (val != INADDR_NONE) {
			inet_makenetandmask(htonl(val), &su->sin,
			    strtoul(q+1, 0, 0), which);
			return (0);
d1122 7
a1128 6
		*q =qs;
	}
	if (((val = inet_addr(s)) != INADDR_NONE) &&
	    ((which != RTA_DST && which != RTA_SRC) || forcenet == 0)) {
		su->sin.sin_addr.s_addr = val;
		if (inet_lnaof(su->sin.sin_addr) != INADDR_ANY)
a1129 3
		else {
			val = ntohl(val);
			goto netdone;
d1131 4
a1135 17
	if ((val = inet_network(s)) != INADDR_NONE ||
	    (forcehost == 0 && (np = getnetbyname(s)) != NULL &&
	    (val = np->n_net) != 0)) {
netdone:
		if (which == RTA_DST || which == RTA_SRC)
			inet_makenetandmask(val, &su->sin, 0, which);
		return (0);
	}
	hp = gethostbyname(s);
	if (hp) {
		*hpp = hp;
		su->sin.sin_family = hp->h_addrtype;
		memcpy(&su->sin.sin_addr, hp->h_addr, hp->h_length);
		return (1);
	}
	(void) fprintf(stderr, "route: %s: bad value\n", s);
	exit(1);
d1364 1
a1364 1
	    if (verbose) sodump(&(u),"u");\
@


1.66
log
@Fix two byte overflow when printing unknown sockaddrs. OK cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.65 2004/04/26 06:24:20 cedric Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.65 2004/04/26 06:24:20 cedric Exp $";
d86 2
a87 1
} so_dst, so_gate, so_mask, so_genmask, so_ifa, so_ifp;
d93 1
a93 1
int	iflag, verbose, aflen = sizeof (struct sockaddr_in);
d112 1
a112 1
void	 mask_addr(void);
d123 2
a124 1
void	inet_makenetandmask(u_int32_t net, struct sockaddr_in *sin, int bits);
d137 1
a137 1
	    "usage: route [ -nqv ] cmd [[ -<modifiers> ] args ]\n");
d170 1
a170 1
	while ((ch = getopt(argc, argv, "nqdtv")) != -1)
d187 3
d609 1
a609 1
	char *cmd, *dest = "", *gateway = "", *err;
d726 11
d766 1
a766 1
			if ((rtm_addrs & RTA_DST) == 0) {
d805 5
d828 2
d860 1
a860 1
inet_makenetandmask(u_int32_t net, struct sockaddr_in *sin, int bits)
d865 1
a865 1
	rtm_addrs |= RTA_NETMASK;
d892 1
a892 1
	sin = &so_mask.sin;
d974 6
d1105 1
a1105 1
	if (q && which == RTA_DST) {
d1111 1
a1111 1
			    strtoul(q+1, 0, 0));
d1117 1
a1117 1
	    (which != RTA_DST || forcenet == 0)) {
d1130 2
a1131 2
		if (which == RTA_DST)
			inet_makenetandmask(val, &su->sin, 0);
d1399 3
a1401 1
		mask_addr();
d1408 2
d1436 1
a1436 1
mask_addr(void)
d1438 2
a1439 2
	int olen = so_mask.sa.sa_len;
	char *cp1 = olen + (char *)&so_mask, *cp2;
d1441 1
a1441 1
	for (so_mask.sa.sa_len = 0; cp1 > (char *)&so_mask; )
d1443 1
a1443 1
			so_mask.sa.sa_len = 1 + cp1 - (char *)&so_mask;
d1446 1
a1446 1
	if ((rtm_addrs & RTA_DST) == 0)
d1448 1
a1448 1
	switch (so_dst.sa.sa_family) {
d1459 2
a1460 2
		olen = MIN(so_dst.siso.siso_nlen,
			   MAX(so_mask.sa.sa_len - 6, 0));
d1463 2
a1464 2
	cp1 = so_mask.sa.sa_len + 1 + (char *)&so_dst;
	cp2 = so_dst.sa.sa_len + 1 + (char *)&so_dst;
d1467 2
a1468 2
	cp2 = so_mask.sa.sa_len + 1 + (char *)&so_mask;
	while (cp1 > so_dst.sa.sa_data)
d1470 1
a1470 1
	switch (so_dst.sa.sa_family) {
d1472 1
a1472 1
		so_dst.siso.siso_nlen = olen;
d1500 1
a1500 1
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010MASK_PRESENT\011CLONING\012XRESOLVE\013LLINFO\014STATIC\017PROTO2\020PROTO1\040CLONED";
d1504 1
a1504 1
"\1DST\2GATEWAY\3NETMASK\4GENMASK\5IFP\6IFA\7AUTHOR\010BRD";
d1574 1
d1612 6
d1637 11
d1673 2
a1674 1
#define	RTA_IGN	(RTA_DST|RTA_GATEWAY|RTA_NETMASK|RTA_IFP|RTA_IFA|RTA_BRD)
@


1.65
log
@fix route with explicit -gateway modifier. ok deraadt@@ itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.64 2004/04/07 09:43:00 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.64 2004/04/07 09:43:00 deraadt Exp $";
d352 1
a352 1
	int len = sa->sa_len;
@


1.64
log
@another piece inside qflag check
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.63 2004/01/18 12:26:16 markus Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.63 2004/01/18 12:26:16 markus Exp $";
d713 1
@


1.63
log
@print link state for RTM_IFINFO messages, flush stdout correctly
if message contains no address; ok mpf@@, deraadt@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.62 2004/01/15 10:50:49 markus Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.62 2004/01/15 10:50:49 markus Exp $";
d814 16
a829 15
	}
	if (ret != 0) {
		switch (oerrno) {
		case ESRCH:
			err = "not in table";
			break;
		case EBUSY:
			err = "entry in use";
			break;
		case ENOBUFS:
			err = "routing table overflow";
			break;
		default:
			err = strerror(oerrno);
			break;
a830 1
		(void) printf(": %s\n", err);
@


1.62
log
@print RTM_IFANNOUNCE message; netbsd; ok itojun@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.61 2004/01/09 10:01:57 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.61 2004/01/09 10:01:57 deraadt Exp $";
d1478 1
d1491 10
a1500 1
		(void) printf("if# %d, flags:", ifm->ifm_index);
d1648 11
a1658 11
	if (addrs == 0)
		return;
	(void) printf("\nsockaddrs: ");
	bprintf(stdout, addrs, addrnames);
	(void) putchar('\n');
	for (i = 1; i; i <<= 1)
		if (i & addrs) {
			sa = (struct sockaddr *)cp;
			(void) printf(" %s", routename(sa));
			ADVANCE(cp, sa);
		}
@


1.61
log
@route -q is supposed to be totally quiet
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.60 2003/08/26 08:33:12 itojun Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.60 2003/08/26 08:33:12 itojun Exp $";
d1459 1
d1477 1
d1500 17
@


1.60
log
@mark cloned route with RTF_CLONED.  remove RTF_CLONED route when clone parent
disappers.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.59 2003/07/02 21:44:58 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.59 2003/07/02 21:44:58 deraadt Exp $";
d1382 2
a1383 1
		perror("writing to routing socket");
@


1.59
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.58 2003/06/26 16:35:21 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.58 2003/06/26 16:35:21 deraadt Exp $";
d1464 1
a1464 1
"\1UP\2GATEWAY\3HOST\4REJECT\5DYNAMIC\6MODIFIED\7DONE\010MASK_PRESENT\011CLONING\012XRESOLVE\013LLINFO\014STATIC\017PROTO2\020PROTO1";
@


1.58
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.57 2003/06/02 20:06:16 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.57 2003/06/02 20:06:16 millert Exp $";
d118 8
@


1.57
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.56 2003/03/13 09:09:27 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.56 2003/03/13 09:09:27 deraadt Exp $";
d91 1
a91 1
int	forcehost, forcenet, doflush, nflag, af, qflag, tflag, keyword();
d364 2
a365 2
	char *ns_print();
	char *ipx_print();
d468 2
a469 2
	char *ns_print();
	char *ipx_print();
d908 1
a908 4
	struct ns_addr ns_addr();
	struct ipx_addr ipx_addr();
	struct iso_addr *iso_addr();
	struct ccitt_addr *ccitt_addr();
@


1.56
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.55 2003/03/11 02:32:31 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.55 2003/03/11 02:32:31 deraadt Exp $";
@


1.55
log
@strcpy -> strlcpy; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.54 2003/01/31 17:51:16 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.54 2003/01/31 17:51:16 millert Exp $";
d1203 1
a1203 1
		(void) sprintf(mybuf, "*.0x%x", port);
d1213 1
a1213 1
		(void) sprintf(chost, "0x%02x%02x%02x%02x%02x%02x",
d1218 1
a1218 1
		(void) sprintf(cport, ".0x%x", htons(port));
d1248 1
a1248 1
		(void) sprintf(mybuf, "*.0x%XH", port);
d1258 1
a1258 1
		(void) sprintf(chost, "%02X%02X%02X%02X%02X%02XH",
d1265 1
a1265 1
		(void) sprintf(cport, ".%XH", htons(port));
@


1.54
log
@o When checking for root, look at effective, not real uid; checking the
  real uid made sense when route(8) was setuid root but it no longer is.
o ANSIfy
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.53 2002/11/24 20:56:24 henning Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: route.c,v 1.53 2002/11/24 20:56:24 henning Exp $";
d375 1
a375 1
			(void) strcpy(domain, cp + 1);
d382 1
a382 1
		strcpy(line, "default");
@


1.53
log
@KNF while beeing here
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.52 2002/10/18 00:27:41 itojun Exp $	*/
d38 1
a38 1
static char copyright[] =
d45 1
a45 1
static char sccsid[] = "@@(#)route.c	8.3 (Berkeley) 3/19/94";
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.52 2002/10/18 00:27:41 itojun Exp $";
d126 1
a126 2
usage(cp)
	char *cp;
d139 1
a139 2
quit(s)
	char *s;
d156 1
a156 3
main(argc, argv)
	int argc;
	char **argv;
d188 1
a188 1
	uid = getuid();
d190 1
a190 1
		s = open("/dev/null", O_WRONLY);
d228 1
a228 3
flushroutes(argc, argv)
	int argc;
	char *argv[];
d343 1
a343 2
any_ntoa(sa)
	const struct sockaddr *sa;
d361 1
a361 2
routename(sa)
	struct sockaddr *sa;
d466 1
a466 2
netname(sa)
	struct sockaddr *sa;
d573 1
a573 3
set_metric(value, key)
	char *value;
	int key;
d598 1
a598 3
newroute(argc, argv)
	int argc;
	char **argv;
d832 1
a832 4
inet_makenetandmask(net, sin, bits)
	u_int32_t net;
	struct sockaddr_in *sin;
	int bits;
d879 1
a879 2
inet6_makenetandmask(sin6)
	struct sockaddr_in6 *sin6;
d909 1
a909 4
getaddr(which, s, hpp)
	int which;
	char *s;
	struct hostent **hpp;
d1115 1
a1115 2
prefixlen(s)
	char *s;
d1168 1
a1168 1
x25_makemask()
d1186 1
a1186 2
ns_print(sns)
	struct sockaddr_ns *sns;
d1231 1
a1231 2
ipx_print(sipx)
	struct sockaddr_ipx *sipx;
d1275 1
a1275 1
interfaces()
d1305 1
a1305 1
monitor()
d1330 1
a1330 2
rtmsg(cmd, flags)
	int cmd, flags;
d1400 1
a1400 1
mask_addr()
d1470 1
a1470 3
print_rtmsg(rtm, msglen)
	struct rt_msghdr *rtm;
	int msglen;
d1506 1
a1506 3
print_getmsg(rtm, msglen)
	struct rt_msghdr *rtm;
	int msglen;
d1602 1
a1602 2
pmsg_common(rtm)
	struct rt_msghdr *rtm;
d1612 1
a1612 3
pmsg_addrs(cp, addrs)
	char	*cp;
	int	addrs;
d1633 1
a1633 4
bprintf(fp, b, s)
	FILE *fp;
	int b;
	u_char *s;
d1659 1
a1659 2
keyword(cp)
	char *cp;
d1669 1
a1669 3
sodump(su, which)
	sup su;
	char *which;
d1717 1
a1717 3
sockaddr(addr, sa)
	char *addr;
	struct sockaddr *sa;
@


1.52
log
@correct prefixlen handling (-prefixlen 32 will make it a host route)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.51 2002/10/17 20:38:03 jason Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.51 2002/10/17 20:38:03 jason Exp $";
d1156 1
a1156 1
	rtm_addrs |= RTA_NETMASK;	
d1161 1
a1161 1
	
@


1.51
log
@Make prefixlen check to make sure its argument is present before deref; millert ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.50 2002/06/10 21:19:24 itojun Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.50 2002/06/10 21:19:24 itojun Exp $";
d740 1
a740 1
				prefixlen(*++argv);
d1185 1
a1185 1
	return(len);
@


1.50
log
@permit DNS name (they are considered RTF_HOST if specified as destination).
PR 2152
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.49 2002/06/08 18:53:42 itojun Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.49 2002/06/08 18:53:42 itojun Exp $";
d738 2
a739 1
				argc--;
@


1.49
log
@support IPv4 in -prefixlen.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.48 2002/06/05 22:14:15 itojun Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.48 2002/06/05 22:14:15 itojun Exp $";
d996 8
a1003 3
		if (getaddrinfo(s, "0", &hints, &res) != 0 ||
		    res->ai_family != AF_INET6 ||
		    res->ai_addrlen != sizeof(su->sin6)) {
d1007 5
d1013 1
d1023 6
a1028 4
		freeaddrinfo(res);
		if (which == RTA_DST)
			return inet6_makenetandmask(&su->sin6);
		return (0);
@


1.48
log
@more correction to RTF_HOST handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.47 2002/06/04 22:22:37 itojun Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.47 2002/06/04 22:22:37 itojun Exp $";
d107 1
a107 3
#ifdef INET6
static int prefixlen(char *);
#endif
a736 1
#ifdef INET6
d739 1
a739 7
				if (prefixlen(*++argv) == 128) {
					forcenet = 0;
					ishost = 1;
				} else {
					forcenet = 1;
					ishost = 0;
				}
a740 1
#endif
a1119 1
#ifdef INET6
d1125 16
d1142 2
a1143 2
	rtm_addrs |= RTA_NETMASK;
	if (len < -1 || len > 129) {
d1147 1
a1147 1

d1150 22
a1171 9
	so_mask.sin6.sin6_family = AF_INET6;
	so_mask.sin6.sin6_len = sizeof(struct sockaddr_in6);
	memset((void *)&so_mask.sin6.sin6_addr, 0,
		sizeof(so_mask.sin6.sin6_addr));
	if (q > 0)
		memset((void *)&so_mask.sin6.sin6_addr, 0xff, q);
	if (r > 0)
		*((u_char *)&so_mask.sin6.sin6_addr + q) = (0xff00 >> r) & 0xff;
	return (len);
a1172 1
#endif
@


1.47
log
@do not automagically have -prefixlen 128 on IPv6 host route.
From: Dawid Szymanski <dawszy@@arhea.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.46 2002/05/26 09:24:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.46 2002/05/26 09:24:35 deraadt Exp $";
d920 3
a922 1
	if (plen) {
d924 2
a925 1
		return prefixlen(plen);
a926 2

	return -1;
d1024 1
a1024 2
			if (inet6_makenetandmask(&su->sin6) == 128)
				return (1);
@


1.46
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.45 2002/05/20 23:06:27 itojun Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.45 2002/05/20 23:06:27 itojun Exp $";
a917 2
		else
			plen = "128";
@


1.45
log
@raise RTF_HOST for IPv6 /128 destination.  from ume
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.44 2002/02/16 21:27:37 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.44 2002/02/16 21:27:37 millert Exp $";
d1495 2
a1496 2
		(void) printf("pid: %d, seq %d, errno %d, flags:",
			rtm->rtm_pid, rtm->rtm_seq, rtm->rtm_errno);
@


1.44
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.43 2001/07/07 18:26:20 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.43 2001/07/07 18:26:20 deraadt Exp $";
d118 3
d903 1
a903 1
static void
d924 1
a924 1
		prefixlen(plen);
d926 2
d1023 1
d1025 2
a1026 2
			inet6_makenetandmask(&su->sin6);
		freeaddrinfo(res);
@


1.43
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.42 2001/05/11 17:51:56 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.42 2001/05/11 17:51:56 mickey Exp $";
d102 5
a106 5
char	*routename __P((struct sockaddr *));
char	*netname __P((struct sockaddr *));
void	 flushroutes __P((int, char **));
int	 newroute __P((int, char **));
void	 monitor __P((void));
d108 1
a108 1
static int prefixlen __P((char *));
d110 11
a120 11
void	 sockaddr __P((char *, struct sockaddr *));
void	 sodump __P((sup, char *));
void	 print_getmsg __P((struct rt_msghdr *, int));
void	 print_rtmsg __P((struct rt_msghdr *, int));
void	 pmsg_common __P((struct rt_msghdr *));
void	 pmsg_addrs __P((char *, int));
void	 bprintf __P((FILE *, int, u_char *));
void	 mask_addr __P((void));
int	 getaddr __P((int, char *, struct hostent **));
int	 rtmsg __P((int, int));
int	 x25_makemask __P((void));
d122 1
a122 1
extern void show __P((int, char **));	/* XXX - from show.c */
@


1.42
log
@use strlcpy instead of strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.41 2001/01/27 03:23:31 itojun Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.41 2001/01/27 03:23:31 itojun Exp $";
d237 1
a237 1
	char *buf = NULL, *next, *lim;
d936 1
a936 1
	sup su;
@


1.41
log
@correct 1.28 -> 1.29 (ortentry removal, cmetz).
can't use routename() here since it could overwrite DNS lookup result
pointed to by "hp".  maybe we need to change every gethostby* to get*info.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.40 2000/09/24 01:02:24 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.40 2000/09/24 01:02:24 millert Exp $";
d314 2
a315 2
                if (sa->sa_family == AF_KEY)
                        continue;  /* Don't flush SPD */
d407 1
a407 2
		strncpy(line, cp ? cp : inet_ntoa(in), sizeof line-1);
		line[sizeof line-1] = '\0';
d519 1
a519 2
		strncpy(line, cp ? cp : inet_ntoa(in), sizeof line-1);
		line[sizeof line-1] = '\0';
d825 1
a825 1
			        inet_ntoa(so_gate.sin.sin_addr));
d1133 1
a1133 1
	rtm_addrs |= RTA_NETMASK;	
d1138 1
a1138 1
	
@


1.40
log
@If the route add/delete fails exit w/ 1 instead of 0
Remove register decls and make return foo vs. return (foo) consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.39 2000/08/03 07:01:32 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.39 2000/08/03 07:01:32 angelos Exp $";
d826 2
a827 1
			    (void) printf(" (%s)", routename(&so_gate.sa));
@


1.39
log
@Don't flush SPD entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.38 2000/07/27 20:12:25 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.38 2000/07/27 20:12:25 angelos Exp $";
d105 1
a105 1
void	 newroute __P((int, char **));
d162 1
d165 1
a165 1
		usage((char *)NULL);
d185 1
a185 1
			usage((char *)NULL);
d207 1
a207 1
		newroute(argc, argv);
a221 1
		return 1;
d223 1
a223 1
	return 0;
d238 1
a238 1
	register struct rt_msghdr *rtm;
d370 1
a370 1
	register char *cp = NULL;
a374 1
	struct in_addr ina;
d609 1
a609 1
void
d612 1
a612 1
	register char **argv;
d615 1
a615 1
	int ishost = 0, ret, attempts, oerrno, flags = RTF_STATIC;
d773 1
a773 1
				int ret = atoi(*argv);
d775 1
a775 1
				if (ret == 0) {
d781 1
a781 1
					usage((char *)NULL);
d784 1
a784 1
				} else if (ret > 0 && ret < 10) {
d848 1
d854 1
a854 1
	register struct sockaddr_in *sin;
d858 1
a858 1
	register char *cp;
d937 1
a937 1
	register sup su;
d1022 1
a1022 1
		return 0;
d1055 1
a1055 1
			register char *cp = (char *)TSEL(&su->siso);
d1150 1
a1150 1
	return(len);
d1157 1
a1157 1
	register char *cp;
d1166 1
a1166 1
	return 0;
d1182 1
a1182 1
	register u_char *q;
d1227 2
a1228 2
	register char *p;
	register u_char *q;
d1269 1
a1269 1
	register struct rt_msghdr *rtm;
d1324 2
a1325 2
	register char *cp = m_rtmsg.m_space;
	register int l;
d1393 1
a1393 1
	register char *cp1 = olen + (char *)&so_mask, *cp2;
d1461 1
a1461 1
	register struct rt_msghdr *rtm;
d1499 1
a1499 1
	register struct rt_msghdr *rtm;
d1504 3
a1506 3
	register struct sockaddr *sa;
	register char *cp;
	register int i;
d1597 1
a1597 1
	register struct rt_msghdr *rtm;
d1611 1
a1611 1
	register struct sockaddr *sa;
d1631 3
a1633 3
	register FILE *fp;
	register int b;
	register u_char *s;
d1635 1
a1635 1
	register int i;
d1662 1
a1662 1
	register struct keytab *kt = keywords;
d1666 1
a1666 1
	return kt->kt_i;
d1671 1
a1671 1
	register sup su;
d1721 2
a1722 2
	register char *addr;
	register struct sockaddr *sa;
d1724 1
a1724 1
	register char *cp = (char *)sa;
d1727 1
a1727 1
	register int byte = 0, state = VIRGIN, new = 0;
@


1.38
log
@Don't show or delete IPsec flows with the route command -- this was a
kludge to begin with, and it's about time we get rid of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.37 2000/04/20 12:26:35 itojun Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.37 2000/04/20 12:26:35 itojun Exp $";
d314 2
@


1.37
log
@use scoped address notation (fe80::1%de0) for IPv6 linklocal unicast/multicast.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.36 2000/01/22 20:25:06 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.36 2000/01/22 20:25:06 deraadt Exp $";
a270 3
			case K_ENCAP:
				af = AF_KEY;
				break;
a311 7
				continue;
		} else {
			/*
			 * A general 'flush' should not touch PF_KEY flows,
			 * as the flows' SPIs would be left behind.
			 */
			if (sa->sa_family == AF_KEY)
@


1.36
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.35 1999/12/08 07:55:54 itojun Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.35 1999/12/08 07:55:54 itojun Exp $";
a385 3
#ifdef INET6
	static char ntop_buf[NI_MAXHOST];	/*for inet_ntop()*/
#endif
d423 3
a425 2
	    {	struct in6_addr in6;
		int gap;
d427 26
a452 5
		in6 = ((struct sockaddr_in6 *)sa)->sin6_addr;
		gap = 24 - sa->sa_len;
		if (gap > 0)
			bzero((char *)(&in6 + 1) - gap, gap);
		return ((char *)inet_ntop(AF_INET6, &in6, ntop_buf, sizeof(ntop_buf)));
a491 3
#ifdef INET6
	static char ntop_buf[NI_MAXHOST];	/*for inet_ntop()*/
#endif
d536 3
a538 2
	    {	struct in6_addr in6;
		int gap;
d540 26
a565 5
		in6 = ((struct sockaddr_in6 *)sa)->sin6_addr;
		gap = 24 - sa->sa_len;
		if (gap > 0)
			bzero((char *)(&in6 + 1) - gap, gap);
		return ((char *)inet_ntop(AF_INET6, &in6, ntop_buf, sizeof(ntop_buf)));
d905 30
d1004 10
a1013 1
		if (inet_pton(AF_INET6, s, (void *)&su->sin6.sin6_addr) != 1) {
d1017 13
d1031 1
@


1.35
log
@ipv6 support from KAME (needs no libc upgrade).  regen keywords.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.34 1999/09/22 05:10:04 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.34 1999/09/22 05:10:04 deraadt Exp $";
a160 1
	extern int optind;
@


1.34
log
@routing interface sends aligned to long word boundaries; itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.33 1999/08/17 09:13:15 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.33 1999/08/17 09:13:15 millert Exp $";
d82 3
d107 3
d254 5
d387 3
d425 13
d474 3
d519 13
d614 6
d710 12
d887 1
d893 1
a897 1
		su->sa.sa_family = af;
a900 1
		su->sa.sa_family = af;
d910 1
a910 1
		su->sa.sa_family = af;
d921 1
d934 10
a943 1
	switch (af) {
d1045 27
d1223 1
d1225 2
a1226 1
		(void) printf("got message of size %d\n", n);
d1324 3
d1592 4
d1609 7
@


1.33
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.32 1999/07/29 22:14:33 ho Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.32 1999/07/29 22:14:33 ho Exp $";
d147 1
a147 1
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(in_addr_t) - 1))) : sizeof(in_addr_t))
d335 1
a335 1
			sa = (struct sockaddr *)(sa->sa_len + (char *)sa);
@


1.32
log
@Modified 'route flush' default behaviour to skip '-encap' (PF_KEY) flows,
as deleting these will leave the SPIs behind. 'route flush -encap' will
still delete the flows. 'ipsecadm' should do this, and properly.

PF_KEY/AF_KEY nitpick. Sync man page. Add ref to ipsecadm(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.31 1999/07/28 09:47:22 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.31 1999/07/28 09:47:22 espie Exp $";
a51 1
#include <sys/file.h>
d69 1
d187 1
a187 1
		s = open("/dev/null", O_WRONLY, 0);
@


1.31
log
@qualifers is a typo.
synch with man page, which speaks of modifiers anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.30 1999/02/24 22:56:01 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.30 1999/02/24 22:56:01 angelos Exp $";
d234 1
d262 1
a262 1
				af = PF_KEY;
d302 1
a303 2
			struct sockaddr *sa = (struct sockaddr *)(rtm + 1);

d305 7
@


1.30
log
@Grok PF_KEY.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.29 1999/01/08 00:38:30 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.29 1999/01/08 00:38:30 deraadt Exp $";
d125 1
a125 1
	    "usage: route [ -nqv ] cmd [[ -<qualifers> ] args ]\n");
@


1.29
log
@remove ortentry reliance; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.28 1998/12/20 23:47:52 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.28 1998/12/20 23:47:52 millert Exp $";
d261 1
a261 1
				af = AF_ENCAP;
@


1.28
log
@add forward decl of struct in_addr to shut up gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.27 1998/09/21 08:31:46 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.27 1998/09/21 08:31:46 deraadt Exp $";
a78 1
struct	ortentry route;
d730 1
a730 3
			    (void) printf(" (%s)",
				inet_ntoa(((struct sockaddr_in *)
					   &route.rt_gateway)->sin_addr));
@


1.27
log
@bad sysctl(), malloc(0), and memory leaks fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.26 1997/12/12 09:06:08 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.26 1997/12/12 09:06:08 deraadt Exp $";
d367 1
@


1.26
log
@pid is pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.25 1997/12/12 09:04:33 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.25 1997/12/12 09:04:33 deraadt Exp $";
d233 1
a233 1
	char *buf, *next, *lim;
d280 7
a286 5
	if ((buf = malloc(needed)) == NULL)
		quit("malloc");
	if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
		quit("actual retrieval of routing table");
	lim = buf + needed;
d292 3
d334 1
d1083 1
a1083 1
	char *buf, *lim, *next;
d1094 11
a1104 8
	if ((buf = malloc(needed)) == NULL)
		quit("malloc");
	if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
		quit("actual retrieval of interface table");
	lim = buf + needed;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		print_rtmsg(rtm, rtm->rtm_msglen);
@


1.25
log
@no longer setuid; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.24 1997/11/16 18:42:35 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.24 1997/11/16 18:42:35 deraadt Exp $";
d91 2
a92 2
int	pid, rtm_addrs;
int	s;
@


1.24
log
@fix error message
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.23 1997/07/13 23:12:09 angelos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.23 1997/07/13 23:12:09 angelos Exp $";
d91 1
a91 1
int	pid, rtm_addrs, uid;
d98 1
a190 2
	seteuid(uid);
	setuid(uid);
@


1.23
log
@Added -encap flag for flushing, added a missing break; in flushing X25
entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.22 1997/06/24 04:05:38 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.22 1997/06/24 04:05:38 millert Exp $";
d960 1
a960 1
	(void) fprintf(stderr, "%s: bad value\n", s);
@


1.22
log
@Add real prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.21 1997/06/24 03:45:43 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.21 1997/06/24 03:45:43 millert Exp $";
d262 3
d267 1
@


1.21
log
@Make mask and subnetshift in_addr_t and bring back a cast of
mask to make it signed for the shift.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.20 1997/06/24 03:15:23 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.20 1997/06/24 03:15:23 millert Exp $";
d98 19
a116 8
struct	in_addr inet_makeaddr();
char	*routename(), *netname();
void   flushroutes(), newroute(), monitor(), sockaddr(), sodump();
void   print_getmsg(), print_rtmsg(), pmsg_common(), pmsg_addrs();
void   bprintf(), mask_addr();
int	getaddr(), rtmsg(), x25_makemask();
extern	char *inet_ntoa(), *iso_ntoa(), *link_ntoa();
extern void show();
d1306 1
a1306 1
	(void) printf("   route to: %s\n", routename(&so_dst));
@


1.20
log
@Fix "route show" on alpha.  Some parts from Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.19 1997/06/04 10:36:16 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.19 1997/06/04 10:36:16 deraadt Exp $";
d417 1
a417 2
	in_addr_t net;
	int mask, subnetshift;
d448 1
a448 1
				mask = mask >> subnetshift;
@


1.19
log
@make usage show minimal keywords
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.18 1997/04/10 10:09:02 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.18 1997/04/10 10:09:02 deraadt Exp $";
d136 1
a136 1
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
d371 2
a372 2
			if ((hp = gethostbyaddr((char *)&in,
			    sizeof (struct in_addr), AF_INET))) {
d417 2
a418 2
	long net, mask;
	int subnetshift;
d425 2
a426 2
	    {	struct in_addr in;
		in = ((struct sockaddr_in *)sa)->sin_addr;
d1007 1
a1007 1
	    (u_int32_t)ntohl(net.long_e), host, cport);
d1055 1
a1055 1
	    (u_int32_t)ntohl(net.long_e), host, cport);
@


1.18
log
@allow syntax of the form "route add -net 192.168.64.0/20 <destaddr>";
phk@@freebsd, man page changes done by me 'cause i'm a bit bored
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.17 1997/01/15 23:41:40 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.17 1997/01/15 23:41:40 millert Exp $";
d115 2
@


1.17
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.16 1996/12/22 03:00:53 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.16 1996/12/22 03:00:53 deraadt Exp $";
d328 3
a330 3
	        *out++ = hexlist[(*in >> 4) & 15];
	        *out++ = hexlist[(*in++)    & 15];
	        *out++ = '.';
d736 1
a736 1
inet_makenetandmask(net, sin)
d739 1
d747 4
a750 1
	else if (net < 128) {
d799 1
d906 13
d934 1
a934 1
			inet_makenetandmask(val, &su->sin);
@


1.16
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.15 1996/12/14 18:41:37 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.15 1996/12/14 18:41:37 deraadt Exp $";
d148 1
a148 1
	while ((ch = getopt(argc, argv, "nqdtv")) != EOF)
@


1.15
log
@inane
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.14 1996/12/14 17:36:33 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.14 1996/12/14 17:36:33 deraadt Exp $";
d177 1
@


1.14
log
@bit more paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.13 1996/12/14 17:23:54 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.13 1996/12/14 17:23:54 deraadt Exp $";
d414 1
a414 1
	u_int32_t net, mask;
d446 1
a446 1
				mask = (u_int32_t)mask >> subnetshift;
@


1.13
log
@merge netbsd changes for show command
yet more buf oflows (provided by netbsd!)
an attempt at 64 bit cleanliness
-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.12 1996/11/25 03:57:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.12 1996/11/25 03:57:56 deraadt Exp $";
d391 1
a391 1
		(void) sprintf(line, "iso %s",
@


1.12
log
@revoke privs; do not call getnetbyname if not needed, bmah@@cs.berkeley.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.9 1996/09/03 07:29:31 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.9 1996/09/03 07:29:31 deraadt Exp $";
a76 4
struct keytab {
	char	*kt_cp;
	int	kt_i;
} keywords[] = {
a77 2
	{0, 0}
};
d100 3
a102 2
void	flushroutes(), newroute(), monitor(), sockaddr(), sodump(), bprintf();
void	print_getmsg(), print_rtmsg(), pmsg_common(), pmsg_addrs(), mask_addr();
d105 1
d180 27
a206 24
	if (*argv)
		switch (keyword(*argv)) {
		case K_GET:
			uid = 0;
			/* FALLTHROUGH */

		case K_CHANGE:
		case K_ADD:
		case K_DELETE:
			newroute(argc, argv);
			exit(0);
			/* NOTREACHED */

		case K_MONITOR:
			monitor();
			/* NOTREACHED */

		case K_FLUSH:
			flushroutes(argc, argv);
			exit(0);
			/* NOTREACHED */
		}
	usage(*argv);
	/* NOTREACHED */
d268 1
a268 1
	if (verbose)
d270 3
d314 21
d339 1
a339 1
	register char *cp;
d342 1
a342 1
	static char domain[MAXHOSTNAMELEN + 1];
d349 1
a349 1
		if (gethostname(domain, MAXHOSTNAMELEN) == 0 &&
d354 1
a364 1
		cp = 0;
d367 3
a369 4
		if (cp == 0 && !nflag) {
			hp = gethostbyaddr((char *)&in, sizeof (struct in_addr),
				AF_INET);
			if (hp) {
d376 2
a377 8
		if (cp)
			strcpy(line, cp);
		else {
#define C(x)	((x) & 0xff)
			in.s_addr = ntohl(in.s_addr);
			(void) sprintf(line, "%u.%u.%u.%u", C(in.s_addr >> 24),
			   C(in.s_addr >> 16), C(in.s_addr >> 8), C(in.s_addr));
		}
d396 2
a397 6
	    {	u_short *s = (u_short *)sa;
		u_short *slim = s + ((sa->sa_len + 1) >> 1);
		char *cp = line + sprintf(line, "(%d)", sa->sa_family);

		while (++s < slim) /* start with sa->sa_data */
			cp += sprintf(cp, " %x", *s);
a398 1
	    }
d411 1
a411 1
	char *cp = 0;
d414 1
a414 2
	u_long net, mask;
	register u_long i;
d425 1
a425 1
		i = in.s_addr = ntohl(in.s_addr);
d429 1
a429 1
			if (IN_CLASSA(i)) {
d432 1
a432 1
			} else if (IN_CLASSB(i)) {
d446 1
a446 1
				mask = (long)mask >> subnetshift;
d454 3
a456 15
		if (cp) {
			strncpy(line, cp, sizeof line-1);
			line[sizeof line-1] = '\0';
		} else if ((in.s_addr & 0xffffff) == 0)
			(void) sprintf(line, "%u", C(in.s_addr >> 24));
		else if ((in.s_addr & 0xffff) == 0)
			(void) sprintf(line, "%u.%u", C(in.s_addr >> 24),
			    C(in.s_addr >> 16));
		else if ((in.s_addr & 0xff) == 0)
			(void) sprintf(line, "%u.%u.%u", C(in.s_addr >> 24),
			    C(in.s_addr >> 16), C(in.s_addr >> 8));
		else
			(void) sprintf(line, "%u.%u.%u.%u", C(in.s_addr >> 24),
			    C(in.s_addr >> 16), C(in.s_addr >> 8),
			    C(in.s_addr));
d470 1
a470 1
		(void) sprintf(line, "iso %s",
d475 2
a476 6
	    {	u_short *s = (u_short *)sa->sa_data;
		u_short *slim = s + ((sa->sa_len + 1)>>1);
		char *cp = line + sprintf(line, "af %d:", sa->sa_family);

		while (s < slim)
			cp += sprintf(cp, " %x", *s++);
a477 1
	    }
d659 1
a659 1
				        printf("%s,%s",
d668 2
a669 2
				        printf("old usage of trailing digit, ");
				        printf("assuming route via gateway\n");
d736 1
a736 1
	u_long net;
d739 1
a739 1
	u_long addr, mask = 0;
d790 1
d872 3
a874 1
			do {--cp ;} while ((cp > (char *)su) && (*cp == 0));
d952 1
a952 1
	union { union ns_net net_e; u_long long_e; } net;
a956 1
	register char *p;
d986 1
a986 1
	    ntohl(net.long_e), host, cport);
d998 1
a998 1
	union { union ipx_net net_e; u_long long_e; } net;
d1000 1
a1000 1
	static char mybuf[50], cport[10], chost[25];
d1012 1
a1012 1
		(void) sprintf(mybuf, "*.%XH", port);
d1033 2
a1034 1
	(void) sprintf(mybuf,"%XH.%s%s", ntohl(net.long_e), host, cport);
d1339 7
a1345 7
	printf("%8d%c ", rtm->rtm_rmx.rmx_recvpipe, lock(RPIPE));
	printf("%8d%c ", rtm->rtm_rmx.rmx_sendpipe, lock(SPIPE));
	printf("%8d%c ", rtm->rtm_rmx.rmx_ssthresh, lock(SSTHRESH));
	printf("%8d%c ", msec(rtm->rtm_rmx.rmx_rtt), lock(RTT));
	printf("%8d%c ", msec(rtm->rtm_rmx.rmx_rttvar), lock(RTTVAR));
	printf("%8d%c ", rtm->rtm_rmx.rmx_hopcount, lock(HOPCOUNT));
	printf("%8d%c ", rtm->rtm_rmx.rmx_mtu, lock(MTU));
d1348 1
a1348 1
	printf("%8d%c\n", rtm->rtm_rmx.rmx_expire, lock(EXPIRE));
d1407 2
a1408 2
	while (i = *s++) {
		if (b & (1 << (i-1))) {
d1483 1
a1483 1
	register int byte = 0, state = VIRGIN, new;
@


1.11
log
@buf oflow
@
text
@d181 1
d915 2
a916 1
	    ((np = getnetbyname(s)) != NULL && (val = np->n_net) != 0)) {
@


1.10
log
@buf oflow; thanks tqbf@@rdist.org
@
text
@d400 1
a400 1
	static char line[50];
d443 4
a446 3
		if (cp)
			strcpy(line, cp);
		else if ((in.s_addr & 0xffffff) == 0)
@


1.9
log
@use prefix 0x instead of DOS-like postfix H
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.8 1996/08/16 09:26:11 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.8 1996/08/16 09:26:11 mickey Exp $";
d955 1
a955 1
	static char mybuf[50];
d987 2
a988 1
	(void) sprintf(mybuf,"0x%x.%s%s", ntohl(net.long_e), host, cport);
@


1.8
log
@ipx.
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.7 1996/08/15 19:06:09 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.7 1996/08/15 19:06:09 deraadt Exp $";
d955 2
a956 1
	static char mybuf[50], cport[10], chost[25];
d968 1
a968 1
		(void) sprintf(mybuf, "*.%XH", port);
d978 1
a978 1
		(void) sprintf(chost, "%02X%02X%02X%02X%02X%02XH",
d980 1
a980 3
		for (p = chost; *p == '0' && p < chost + 12; p++)
			/* void */;
		host = p;
d983 1
a983 1
		(void) sprintf(cport, ".%XH", htons(port));
d985 1
a985 1
		*cport = 0;
d987 1
a987 1
	(void) sprintf(mybuf,"%XH.%s%s", ntohl(net.long_e), host, cport);
@


1.7
log
@stop walking off argv[]; netbsd pr#2700, mason@@primenet.com.au fixed by me
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.6 1996/08/05 11:53:41 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.6 1996/08/05 11:53:41 deraadt Exp $";
d63 1
d90 1
d238 3
d321 1
d367 3
d406 1
d463 3
d559 4
d793 1
d858 13
d992 47
d1175 1
d1458 4
@


1.6
log
@bigger buffer
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.5 1996/08/02 15:39:28 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.5 1996/08/02 15:39:28 deraadt Exp $";
d587 2
a588 1
				argc--;
d592 2
a593 1
				argc--;
d597 2
a598 1
				argc--;
d602 2
a603 1
				argc--;
d607 2
a608 1
				argc--;
d613 2
a614 1
				argc--;
d628 2
a629 1
				argc--;
@


1.5
log
@flush RTF_STATIC & RTF_LLINFO routes too; from rees@@umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.4 1996/06/23 14:32:23 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.4 1996/06/23 14:32:23 deraadt Exp $";
d311 1
a311 1
	static char line[50];
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: route.c,v 1.16 1996/04/15 18:27:05 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: route.c,v 1.16 1996/04/15 18:27:05 cgd Exp $";
a166 1
		case '?':
d270 1
a270 1
		if ((rtm->rtm_flags & RTF_GATEWAY) == 0)
@


1.3
log
@sync to netbsd 960418
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: route.c,v 1.16 1996/04/15 18:27:05 cgd Exp $";
@


1.2
log
@Produce less output on -q as promised by the man page;
from jhawk@@mit.edu; netbsd pr#998
@
text
@d1 1
a1 1
/*	$NetBSD: route.c,v 1.15 1996/01/07 00:07:23 pk Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: route.c,v 1.15 1996/01/07 00:07:23 pk Exp $";
d864 1
a864 1
	if (((val = inet_addr(s)) != -1) &&
d874 1
a874 1
	if ((val = inet_network(s)) != -1 ||
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: route.c,v 1.14 1995/04/20 20:52:46 mycroft Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: route.c,v 1.14 1995/04/20 20:52:46 mycroft Exp $";
d639 1
a639 1
				    if (strcmp(*argv, "0") == 0)
d648 4
a651 2
				    printf("old usage of trailing digit, ");
				    printf("assuming route via gateway\n");
d684 13
a696 10
	(void) printf("%s %s %s", cmd, ishost? "host" : "net", dest);
	if (*gateway) {
		(void) printf(": gateway %s", gateway);
		if (attempts > 1 && ret == 0 && af == AF_INET)
		    (void) printf(" (%s)",
			inet_ntoa(((struct sockaddr_in *)&route.rt_gateway)->sin_addr));
	}
	if (ret == 0)
		(void) printf("\n");
	else {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
