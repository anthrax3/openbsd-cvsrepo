head	1.141;
access;
symbols
	OPENBSD_6_2_BASE:1.141
	OPENBSD_6_1:1.141.0.4
	OPENBSD_6_1_BASE:1.141
	OPENBSD_6_0:1.131.0.2
	OPENBSD_6_0_BASE:1.131
	OPENBSD_5_9:1.130.0.2
	OPENBSD_5_9_BASE:1.130
	OPENBSD_5_8:1.129.0.4
	OPENBSD_5_8_BASE:1.129
	OPENBSD_5_7:1.123.0.2
	OPENBSD_5_7_BASE:1.123
	OPENBSD_5_6:1.121.0.4
	OPENBSD_5_6_BASE:1.121
	OPENBSD_5_5:1.119.0.4
	OPENBSD_5_5_BASE:1.119
	OPENBSD_5_4:1.112.0.4
	OPENBSD_5_4_BASE:1.112
	OPENBSD_5_3:1.112.0.2
	OPENBSD_5_3_BASE:1.112
	OPENBSD_5_2:1.110.0.2
	OPENBSD_5_2_BASE:1.110
	OPENBSD_5_1_BASE:1.109
	OPENBSD_5_1:1.109.0.2
	OPENBSD_5_0:1.103.0.2
	OPENBSD_5_0_BASE:1.103
	OPENBSD_4_9:1.98.0.2
	OPENBSD_4_9_BASE:1.98
	OPENBSD_4_8:1.97.0.2
	OPENBSD_4_8_BASE:1.97
	OPENBSD_4_7:1.91.0.2
	OPENBSD_4_7_BASE:1.91
	OPENBSD_4_6:1.80.0.4
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.72.0.2
	OPENBSD_4_4_BASE:1.72
	OPENBSD_4_3:1.62.0.2
	OPENBSD_4_3_BASE:1.62
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.48.0.4
	OPENBSD_4_1_BASE:1.48
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.39.0.4
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39;
locks; strict;
comment	@ * @;


1.141
date	2016.12.20.15.38.46;	author patrick;	state Exp;
branches;
next	1.140;
commitid	BK29JhdFtGZX805r;

1.140
date	2016.10.20.07.14.44;	author tb;	state Exp;
branches;
next	1.139;
commitid	o30AWKrB8Om7hJwp;

1.139
date	2016.09.21.17.50.05;	author jsing;	state Exp;
branches;
next	1.138;
commitid	zEoAiASt6hxlc3QC;

1.138
date	2016.09.19.17.46.52;	author jsing;	state Exp;
branches;
next	1.137;
commitid	EpIjQyAWebeJy27L;

1.137
date	2016.09.10.17.08.44;	author jsing;	state Exp;
branches;
next	1.136;
commitid	w0PIkrnMKncmYarD;

1.136
date	2016.09.10.17.06.11;	author jsing;	state Exp;
branches;
next	1.135;
commitid	iP7RQ0ZDutjdGIFn;

1.135
date	2016.09.10.16.53.22;	author jsing;	state Exp;
branches;
next	1.134;
commitid	ndlwtBWcdxwcJuNH;

1.134
date	2016.09.08.19.08.14;	author jsing;	state Exp;
branches;
next	1.133;
commitid	d1dRCivZy34eq7VU;

1.133
date	2016.09.08.18.41.04;	author jsing;	state Exp;
branches;
next	1.132;
commitid	LYgLz4LeRTDtZKmS;

1.132
date	2016.09.08.17.51.02;	author jsing;	state Exp;
branches;
next	1.131;
commitid	qQt30bS6KbpLPLZc;

1.131
date	2016.05.13.19.06.52;	author tedu;	state Exp;
branches;
next	1.130;
commitid	kwCI0w1ssg7YR8I6;

1.130
date	2016.02.04.08.31.26;	author uebayasi;	state Exp;
branches;
next	1.129;
commitid	emp91SDvkmjHwcdD;

1.129
date	2015.07.18.23.23.20;	author halex;	state Exp;
branches;
next	1.128;
commitid	FjCAjgz8Xx5xZrkn;

1.128
date	2015.05.30.06.24.59;	author jmc;	state Exp;
branches;
next	1.127;
commitid	TP5uk7tMUJkU0jsJ;

1.127
date	2015.05.29.00.33.37;	author uebayasi;	state Exp;
branches;
next	1.126;
commitid	k9pN2wgTn5cUwDek;

1.126
date	2015.05.11.12.14.22;	author pelikan;	state Exp;
branches;
next	1.125;
commitid	FyWQemb7SkV4vCvD;

1.125
date	2015.04.11.16.37.34;	author jsing;	state Exp;
branches;
next	1.124;
commitid	TtCayghEi4w23TkX;

1.124
date	2015.03.18.07.42.13;	author uebayasi;	state Exp;
branches;
next	1.123;
commitid	fCdTUoHrti68Ony5;

1.123
date	2015.01.16.06.39.56;	author deraadt;	state Exp;
branches;
next	1.122;
commitid	Uu5nFG3wCl0LACBb;

1.122
date	2014.10.08.10.08.03;	author jsing;	state Exp;
branches;
next	1.121;
commitid	4t2LOrLogjflzj3m;

1.121
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.120;
commitid	0acpjAf5myNxgwB5;

1.120
date	2014.04.22.20.42.01;	author tedu;	state Exp;
branches;
next	1.119;

1.119
date	2014.01.18.09.11.12;	author jsing;	state Exp;
branches;
next	1.118;

1.118
date	2014.01.18.09.01.01;	author jsing;	state Exp;
branches;
next	1.117;

1.117
date	2013.11.22.04.12.46;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2013.11.11.23.07.52;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2013.11.04.21.02.58;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2013.10.31.00.47.20;	author kettenis;	state Exp;
branches;
next	1.113;

1.113
date	2013.10.23.13.05.38;	author kettenis;	state Exp;
branches;
next	1.112;

1.112
date	2012.09.10.11.28.47;	author jsing;	state Exp;
branches;
next	1.111;

1.111
date	2012.09.06.19.41.59;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2012.04.19.19.13.51;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2012.01.22.11.00.39;	author jsing;	state Exp;
branches;
next	1.108;

1.108
date	2012.01.20.14.09.25;	author jsing;	state Exp;
branches;
next	1.107;

1.107
date	2012.01.17.15.15.57;	author jsing;	state Exp;
branches;
next	1.106;

1.106
date	2012.01.17.14.01.02;	author jsing;	state Exp;
branches;
next	1.105;

1.105
date	2012.01.07.12.16.46;	author jsing;	state Exp;
branches;
next	1.104;

1.104
date	2011.12.31.17.06.09;	author jsing;	state Exp;
branches;
next	1.103;

1.103
date	2011.08.01.08.23.52;	author matthieu;	state Exp;
branches;
next	1.102;

1.102
date	2011.07.09.16.53.37;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2011.07.08.01.17.58;	author tedu;	state Exp;
branches;
next	1.100;

1.100
date	2011.07.04.04.52.34;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.04.15.22.31;	author jcs;	state Exp;
branches;
next	1.98;

1.98
date	2010.12.01.19.40.18;	author ckuethe;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.10.02.56.16;	author matthew;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.01.09.35.42;	author jsing;	state Exp;
branches;
next	1.95;

1.95
date	2010.06.22.00.43.37;	author dtucker;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.18.17.15.37;	author jsing;	state Exp;
branches;
next	1.93;

1.93
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.92;

1.92
date	2010.04.03.15.22.44;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2010.01.08.16.38.22;	author halex;	state Exp;
branches;
next	1.90;

1.90
date	2010.01.03.01.41.47;	author nicm;	state Exp;
branches;
next	1.89;

1.89
date	2009.12.31.14.57.40;	author jmc;	state Exp;
branches;
next	1.88;

1.88
date	2009.12.31.14.00.45;	author jsing;	state Exp;
branches;
next	1.87;

1.87
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.24.06.06.06;	author jmc;	state Exp;
branches;
next	1.85;

1.85
date	2009.11.24.02.19.35;	author jsing;	state Exp;
branches;
next	1.84;

1.84
date	2009.10.25.17.53.07;	author marco;	state Exp;
branches;
next	1.83;

1.83
date	2009.10.22.15.27.15;	author jmc;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.21.22.31.17;	author marco;	state Exp;
branches;
next	1.81;

1.81
date	2009.07.31.16.12.10;	author jsing;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.18.08.05.51;	author halex;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.17.22.50.58;	author marco;	state Exp;
branches;
next	1.78;

1.78
date	2009.02.22.07.46.55;	author jmc;	state Exp;
branches;
next	1.77;

1.77
date	2008.09.02.23.05.12;	author dtucker;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.22.06.41.36;	author jmc;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.22.02.00.12;	author marco;	state Exp;
branches;
next	1.74;

1.74
date	2008.08.11.17.28.24;	author marco;	state Exp;
branches;
next	1.73;

1.73
date	2008.08.11.17.22.54;	author marco;	state Exp;
branches;
next	1.72;

1.72
date	2008.07.02.22.08.02;	author todd;	state Exp;
branches;
next	1.71;

1.71
date	2008.06.15.18.52.58;	author jmc;	state Exp;
branches;
next	1.70;

1.70
date	2008.06.15.00.43.23;	author hshoexer;	state Exp;
branches;
next	1.69;

1.69
date	2008.06.14.18.40.50;	author hshoexer;	state Exp;
branches;
next	1.68;

1.68
date	2008.06.14.17.04.50;	author djm;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.14.06.28.27;	author djm;	state Exp;
branches;
next	1.66;

1.66
date	2008.06.14.00.05.47;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2008.06.13.21.03.40;	author hshoexer;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.12.16.08.48;	author jmc;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.12.00.19.15;	author marco;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.19.23.53.53;	author marco;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.08.07.21.29;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2007.07.11.07.40.11;	author jmc;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.10.15.46.54;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.04.05.28.43;	author todd;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.01.00.00.54;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.31.04.23.23;	author grunk;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.28.21.54.26;	author marco;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.23.21.27.13;	author marco;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.23.16.38.55;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.03.20.15.26.06;	author jmc;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.20.06.29.02;	author jmc;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.20.03.40.38;	author todd;	state Exp;
branches;
next	1.49;

1.49
date	2007.03.19.03.02.09;	author marco;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.28.12.36.08;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.28.02.12.59;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.27.22.25.16;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.26.00.38.30;	author marco;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.25.22.26.03;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.25.04.28.26;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.25.03.39.12;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.25.03.12.50;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.07.23.57.23;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.23.23.20.23;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.23.03.59.32;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.21.23.37.24;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.18.22.14.27;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.18.15.00.37;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.18.14.40.37;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.18.12.53.22;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.18.12.19.08;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.18.04.49.52;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.17.06.31.01;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.15.23.13.24;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.09.03.08.27;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.09.01.43.33;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.08.20.26.21;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.08.18.57.16;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.08.04.04.13;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.05.02.40.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.05.02.34.52;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.03.16.12.53;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.03.03.01.31;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.03.02.39.55;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.02.20.27.13;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.01.16.39.22;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.29.16.01.18;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.18.15.10.56;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.18.14.34.41;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.18.01.59.43;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.18.01.29.19;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.01.21.53.40;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.18.11.51.46;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.12.20.49.19;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.06.20.51.46;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.06.02.36.34;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.05.20.25.50;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.05.19.45.06;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.04.22.43.07;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.04.17.37.17;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.30.08.06.03;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.29.22.04.21;	author marco;	state Exp;
branches;
next	;


desc
@@


1.141
log
@This commit removes bio_status() calls after a BIOCLOCATE since the
bio status will never be updated on a BIOCLOCATE.  In addition with
missed zeroing of the passed bio struct, this could lead to a print
of uninitialized memory.  While there, properly zero the bio struct
before passing it to ioctl().

ok mikeb@@
@
text
@/* $OpenBSD: bioctl.c,v 1.140 2016/10/20 07:14:44 tb Exp $ */

/*
 * Copyright (c) 2004, 2005 Marco Peereboom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>	/* NODEV */
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/stat.h>
#include <dev/softraidvar.h>
#include <dev/biovar.h>

#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <util.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <vis.h>
#include <readpassphrase.h>

struct locator {
	int		channel;
	int		target;
	int		lun;
};

struct timing {
	int		interval;
	int		start;
};

static void __dead	usage(void);
const char 		*str2locator(const char *, struct locator *);
const char 		*str2patrol(const char *, struct timing *);
void			bio_status(struct bio_status *);
int			bio_parse_devlist(char *, dev_t *);
void			bio_kdf_derive(struct sr_crypto_kdfinfo *,
			    struct sr_crypto_pbkdf *, char *, int);
void			bio_kdf_generate(struct sr_crypto_kdfinfo *);
int			bcrypt_pbkdf_autorounds(void);
void			derive_key(u_int32_t, int, u_int8_t *, size_t,
			    u_int8_t *, size_t, char *, int);

void			bio_inq(char *);
void			bio_alarm(char *);
int			bio_getvolbyname(char *);
void			bio_setstate(char *, int, char *);
void			bio_setblink(char *, char *, int);
void			bio_blink(char *, int, int);
void			bio_createraid(u_int16_t, char *, char *);
void			bio_deleteraid(char *);
void			bio_changepass(char *);
u_int32_t		bio_createflags(char *);
char			*bio_vis(char *);
void			bio_diskinq(char *);
void			bio_patrol(char *);

int			devh = -1;
int			human;
int			verbose;
u_int32_t		cflags = 0;
int			rflag = 0;
char			*password;

void			*bio_cookie;

int rpp_flag = RPP_REQUIRE_TTY;

int
main(int argc, char *argv[])
{
	struct bio_locate	bl;
	u_int64_t		func = 0;
	char			*devicename = NULL;
	char			*realname = NULL, *al_arg = NULL;
	char			*bl_arg = NULL, *dev_list = NULL;
	char			*key_disk = NULL;
	const char		*errstr;
	int			ch, blink = 0, changepass = 0, diskinq = 0;
	int			ss_func = 0;
	u_int16_t		cr_level = 0;
	int			biodev = 0;

	if (argc < 2)
		usage();

	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hik:l:O:Pp:qr:R:st:u:v")) !=
	    -1) {
		switch (ch) {
		case 'a': /* alarm */
			func |= BIOC_ALARM;
			al_arg = optarg;
			break;
		case 'b': /* blink */
			func |= BIOC_BLINK;
			blink = BIOC_SBBLINK;
			bl_arg = optarg;
			break;
		case 'C': /* creation flags */
			cflags = bio_createflags(optarg);
			break;
		case 'c': /* create */
			func |= BIOC_CREATERAID;
			if (isdigit((unsigned char)*optarg)) {
				cr_level = strtonum(optarg, 0, 10, &errstr);
				if (errstr != NULL)
					errx(1, "Invalid RAID level");
			} else
				cr_level = *optarg;
			break;
		case 'd':
			/* delete volume */
			func |= BIOC_DELETERAID;
			break;
		case 'u': /* unblink */
			func |= BIOC_BLINK;
			blink = BIOC_SBUNBLINK;
			bl_arg = optarg;
			break;
		case 'H': /* set hotspare */
			func |= BIOC_SETSTATE;
			ss_func = BIOC_SSHOTSPARE;
			al_arg = optarg;
			break;
		case 'h':
			human = 1;
			break;
		case 'i': /* inquiry */
			func |= BIOC_INQ;
			break;
		case 'k': /* Key disk. */
			key_disk = optarg;
			break;
		case 'l': /* device list */
			func |= BIOC_DEVLIST;
			dev_list = optarg;
			break;
		case 'P':
			/* Change passphrase. */
			changepass = 1;
			break;
		case 'p':
			password = optarg;
			break;
		case 'r':
			if (strcmp(optarg, "auto") == 0) {
				rflag = -1;
				break;
			}
			rflag = strtonum(optarg, 4, 1<<30, &errstr);
			if (errstr != NULL)
				errx(1, "number of KDF rounds is %s: %s",
				    errstr, optarg);
			break;
		case 'O':
			/* set a chunk to offline */
			func |= BIOC_SETSTATE;
			ss_func = BIOC_SSOFFLINE;
			al_arg = optarg;
			break;
		case 'R':
			/* rebuild to provided chunk/CTL */
			func |= BIOC_SETSTATE;
			ss_func = BIOC_SSREBUILD;
			al_arg = optarg;
			break;
		case 's':
			rpp_flag = RPP_STDIN;
			break;
		case 't': /* patrol */
			func |= BIOC_PATROL;
			al_arg = optarg;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'q':
			diskinq = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if (argc != 1 || (changepass && func != 0))
		usage();

	if (func == 0)
		func |= BIOC_INQ;

	devicename = argv[0];
	if (devicename == NULL)
		errx(1, "need device");

	devh = opendev(devicename, O_RDWR, OPENDEV_PART, &realname);
	if (devh == -1) {
		devh = open("/dev/bio", O_RDWR);
		if (devh == -1)
			err(1, "Can't open %s", "/dev/bio");

		memset(&bl, 0, sizeof(bl));
		bl.bl_name = devicename;
		if (ioctl(devh, BIOCLOCATE, &bl))
			errx(1, "Can't locate %s device via %s",
			    bl.bl_name, "/dev/bio");

		bio_cookie = bl.bl_bio.bio_cookie;
		biodev = 1;
		devicename = NULL;
	}

	if (diskinq) {
		bio_diskinq(devicename);
	} else if (changepass && !biodev) {
		bio_changepass(devicename);
	} else if (func & BIOC_INQ) {
		bio_inq(devicename);
	} else if (func == BIOC_ALARM) {
		bio_alarm(al_arg);
	} else if (func == BIOC_BLINK) {
		bio_setblink(devicename, bl_arg, blink);
	} else if (func == BIOC_PATROL) {
		bio_patrol(al_arg);
	} else if (func == BIOC_SETSTATE) {
		bio_setstate(al_arg, ss_func, argv[0]);
	} else if (func == BIOC_DELETERAID && !biodev) {
		bio_deleteraid(devicename);
	} else if (func & BIOC_CREATERAID || func & BIOC_DEVLIST) {
		if (!(func & BIOC_CREATERAID))
			errx(1, "need -c parameter");
		if (!(func & BIOC_DEVLIST))
			errx(1, "need -l parameter");
		if (!biodev)
			errx(1, "must use bio device");
		bio_createraid(cr_level, dev_list, key_disk);
	}

	return (0);
}

static void __dead
usage(void)
{
	extern char		*__progname;

	fprintf(stderr,
		"usage: %s [-hiqv] [-a alarm-function] "
		"[-b channel:target[.lun]]\n"
		"\t[-H channel:target[.lun]] "
		"[-R device | channel:target[.lun]]\n"
		"\t[-t patrol-function] "
		"[-u channel:target[.lun]] "
		"device\n"
		"       %s [-dhiPqsv] "
		"[-C flag[,flag,...]] [-c raidlevel] [-k keydisk]\n"
		"\t[-l special[,special,...]] "
		"[-O device | channel:target[.lun]]\n"
		"\t[-p passfile] [-R device | channel:target[.lun]]\n"
		"\t[-r rounds] "
		"device\n", __progname, __progname);

	exit(1);
}

const char *
str2locator(const char *string, struct locator *location)
{
	const char		*errstr;
	char			parse[80], *targ, *lun;

	strlcpy(parse, string, sizeof parse);
	targ = strchr(parse, ':');
	if (targ == NULL)
		return ("target not specified");
	*targ++ = '\0';

	lun = strchr(targ, '.');
	if (lun != NULL) {
		*lun++ = '\0';
		location->lun = strtonum(lun, 0, 256, &errstr);
		if (errstr)
			return (errstr);
	} else
		location->lun = 0;

	location->target = strtonum(targ, 0, 256, &errstr);
	if (errstr)
		return (errstr);
	location->channel = strtonum(parse, 0, 256, &errstr);
	if (errstr)
		return (errstr);
	return (NULL);
}

const char *
str2patrol(const char *string, struct timing *timing)
{
	const char		*errstr;
	char			parse[80], *interval = NULL, *start = NULL;

	timing->interval = 0;
	timing->start = 0;

	strlcpy(parse, string, sizeof parse);

	interval = strchr(parse, '.');
	if (interval != NULL) {
		*interval++ = '\0';
		start = strchr(interval, '.');
		if (start != NULL)
			*start++ = '\0';
	}
	if (interval != NULL) {
		/* -1 == continuously */
		timing->interval = strtonum(interval, -1, INT_MAX, &errstr);
		if (errstr)
			return (errstr);
	}
	if (start != NULL) {
		timing->start = strtonum(start, 0, INT_MAX, &errstr);
		if (errstr)
			return (errstr);
	}

	return (NULL);
}

void
bio_status(struct bio_status *bs)
{
	extern char		*__progname;
	char			*prefix;
	int			i;

	if (strlen(bs->bs_controller))
		prefix = bs->bs_controller;
	else
		prefix = __progname;

	for (i = 0; i < bs->bs_msg_count; i++)
		printf("%s: %s\n", prefix, bs->bs_msgs[i].bm_msg);

	if (bs->bs_status == BIO_STATUS_ERROR) {
		if (bs->bs_msg_count == 0)
			errx(1, "unknown error");
		else
			exit(1);
	}
}

void
bio_inq(char *name)
{
	char 			*status, *cache;
	char			size[64], scsiname[16], volname[32];
	char			percent[20], seconds[20];
	int			i, d, volheader, hotspare, unused;
	char			encname[16], serial[32];
	struct bioc_inq		bi;
	struct bioc_vol		bv;
	struct bioc_disk	bd;

	memset(&bi, 0, sizeof(bi));

	bi.bi_bio.bio_cookie = bio_cookie;

	if (ioctl(devh, BIOCINQ, &bi)) {
		if (errno == ENOTTY)
			bio_diskinq(name);
		else
			err(1, "BIOCINQ");
		return;
	}

	bio_status(&bi.bi_bio.bio_status);

	volheader = 0;
	for (i = 0; i < bi.bi_novol; i++) {
		memset(&bv, 0, sizeof(bv));
		bv.bv_bio.bio_cookie = bio_cookie;
		bv.bv_volid = i;
		bv.bv_percent = -1;
		bv.bv_seconds = 0;

		if (ioctl(devh, BIOCVOL, &bv))
			err(1, "BIOCVOL");

		bio_status(&bv.bv_bio.bio_status);

		if (name && strcmp(name, bv.bv_dev) != 0)
			continue;

		if (!volheader) {
			volheader = 1;
			printf("%-11s %-10s %14s %-8s\n",
			    "Volume", "Status", "Size", "Device");
		}

		percent[0] = '\0';
		seconds[0] = '\0';
		if (bv.bv_percent != -1)
			snprintf(percent, sizeof percent,
			    " %d%% done", bv.bv_percent);
		if (bv.bv_seconds)
			snprintf(seconds, sizeof seconds,
			    " %u seconds", bv.bv_seconds);
		switch (bv.bv_status) {
		case BIOC_SVONLINE:
			status = BIOC_SVONLINE_S;
			break;
		case BIOC_SVOFFLINE:
			status = BIOC_SVOFFLINE_S;
			break;
		case BIOC_SVDEGRADED:
			status = BIOC_SVDEGRADED_S;
			break;
		case BIOC_SVBUILDING:
			status = BIOC_SVBUILDING_S;
			break;
		case BIOC_SVREBUILD:
			status = BIOC_SVREBUILD_S;
			break;
		case BIOC_SVSCRUB:
			status = BIOC_SVSCRUB_S;
			break;
		case BIOC_SVINVALID:
		default:
			status = BIOC_SVINVALID_S;
		}
		switch (bv.bv_cache) {
		case BIOC_CVWRITEBACK:
			cache = BIOC_CVWRITEBACK_S;
			break;
		case BIOC_CVWRITETHROUGH:
			cache = BIOC_CVWRITETHROUGH_S;
			break;
		case BIOC_CVUNKNOWN:
		default:
			cache = BIOC_CVUNKNOWN_S;
		}

		snprintf(volname, sizeof volname, "%s %u",
		    bi.bi_dev, bv.bv_volid);

		unused = 0;
		hotspare = 0;
		if (bv.bv_level == -1 && bv.bv_nodisk == 1)
			hotspare = 1;
		else if (bv.bv_level == -2 && bv.bv_nodisk == 1)
			unused = 1;
		else {
			if (human)
				fmt_scaled(bv.bv_size, size);
			else
				snprintf(size, sizeof size, "%14llu",
				    bv.bv_size);
			switch (bv.bv_level) {
			case 'C':
				printf("%11s %-10s %14s %-7s CRYPTO%s%s\n",
				    volname, status, size, bv.bv_dev,
				    percent, seconds);
				break;
			case 'c':
				printf("%11s %-10s %14s %-7s CONCAT%s%s\n",
				    volname, status, size, bv.bv_dev,
				    percent, seconds);
				break;
			default:
				printf("%11s %-10s %14s %-7s RAID%u%s%s %s\n",
				    volname, status, size, bv.bv_dev,
				    bv.bv_level, percent, seconds, cache);
				break;
			}
			
		}

		for (d = 0; d < bv.bv_nodisk; d++) {
			memset(&bd, 0, sizeof(bd));
			bd.bd_bio.bio_cookie = bio_cookie;
			bd.bd_diskid = d;
			bd.bd_volid = i;
			bd.bd_patrol.bdp_percent = -1;
			bd.bd_patrol.bdp_seconds = 0;

			if (ioctl(devh, BIOCDISK, &bd))
				err(1, "BIOCDISK");
		
			bio_status(&bd.bd_bio.bio_status);

			switch (bd.bd_status) {
			case BIOC_SDONLINE:
				status = BIOC_SDONLINE_S;
				break;
			case BIOC_SDOFFLINE:
				status = BIOC_SDOFFLINE_S;
				break;
			case BIOC_SDFAILED:
				status = BIOC_SDFAILED_S;
				break;
			case BIOC_SDREBUILD:
				status = BIOC_SDREBUILD_S;
				break;
			case BIOC_SDHOTSPARE:
				status = BIOC_SDHOTSPARE_S;
				break;
			case BIOC_SDUNUSED:
				status = BIOC_SDUNUSED_S;
				break;
			case BIOC_SDSCRUB:
				status = BIOC_SDSCRUB_S;
				break;
			case BIOC_SDINVALID:
			default:
				status = BIOC_SDINVALID_S;
			}

			if (hotspare || unused)
				;	/* use volname from parent volume */
			else
				snprintf(volname, sizeof volname, "    %3u",
				    bd.bd_diskid);

			if (bv.bv_level == 'C' && bd.bd_size == 0)
				snprintf(size, sizeof size, "%14s", "key disk");
			else if (human)
				fmt_scaled(bd.bd_size, size);
			else
				snprintf(size, sizeof size, "%14llu",
				    bd.bd_size);
			snprintf(scsiname, sizeof scsiname,
			    "%u:%u.%u",
			    bd.bd_channel, bd.bd_target, bd.bd_lun);
			if (bd.bd_procdev[0])
				strlcpy(encname, bd.bd_procdev, sizeof encname);
			else
				strlcpy(encname, "noencl", sizeof encname);
			if (bd.bd_serial[0])
				strlcpy(serial, bd.bd_serial, sizeof serial);
			else
				strlcpy(serial, "unknown serial", sizeof serial);

			percent[0] = '\0';
			seconds[0] = '\0';
			if (bd.bd_patrol.bdp_percent != -1)
				snprintf(percent, sizeof percent,
				    " patrol %d%% done", bd.bd_patrol.bdp_percent);
			if (bd.bd_patrol.bdp_seconds)
				snprintf(seconds, sizeof seconds,
				    " %u seconds", bd.bd_patrol.bdp_seconds);

			printf("%11s %-10s %14s %-7s %-6s <%s>\n",
			    volname, status, size, scsiname, encname,
			    bd.bd_vendor);
			if (verbose)
				printf("%11s %-10s %14s %-7s %-6s '%s'%s%s\n",
				    "", "", "", "", "", serial, percent, seconds);
		}
	}
}

void
bio_alarm(char *arg)
{
	struct bioc_alarm	ba;

	memset(&ba, 0, sizeof(ba));
	ba.ba_bio.bio_cookie = bio_cookie;

	switch (arg[0]) {
	case 'q': /* silence alarm */
		/* FALLTHROUGH */
	case 's':
		ba.ba_opcode = BIOC_SASILENCE;
		break;

	case 'e': /* enable alarm */
		ba.ba_opcode = BIOC_SAENABLE;
		break;

	case 'd': /* disable alarm */
		ba.ba_opcode = BIOC_SADISABLE;
		break;

	case 't': /* test alarm */
		ba.ba_opcode = BIOC_SATEST;
		break;

	case 'g': /* get alarm state */
		ba.ba_opcode = BIOC_GASTATUS;
		break;

	default:
		errx(1, "invalid alarm function: %s", arg);
	}

	if (ioctl(devh, BIOCALARM, &ba))
		err(1, "BIOCALARM");

	bio_status(&ba.ba_bio.bio_status);

	if (arg[0] == 'g')
		printf("alarm is currently %s\n",
		    ba.ba_status ? "enabled" : "disabled");
}

int
bio_getvolbyname(char *name)
{
	int			id = -1, i;
	struct bioc_inq		bi;
	struct bioc_vol		bv;

	memset(&bi, 0, sizeof(bi));
	bi.bi_bio.bio_cookie = bio_cookie;
	if (ioctl(devh, BIOCINQ, &bi))
		err(1, "BIOCINQ");

	bio_status(&bi.bi_bio.bio_status);

	for (i = 0; i < bi.bi_novol; i++) {
		memset(&bv, 0, sizeof(bv));
		bv.bv_bio.bio_cookie = bio_cookie;
		bv.bv_volid = i;
		if (ioctl(devh, BIOCVOL, &bv))
			err(1, "BIOCVOL");

		bio_status(&bv.bv_bio.bio_status);

		if (name && strcmp(name, bv.bv_dev) != 0)
			continue;
		id = i;
		break;
	}

	return (id);
}

void
bio_setstate(char *arg, int status, char *devicename)
{
	struct bioc_setstate	bs;
	struct locator		location;
	struct stat		sb;
	const char		*errstr;

	memset(&bs, 0, sizeof(bs));
	if (stat(arg, &sb) == -1) {
		/* use CTL */
		errstr = str2locator(arg, &location);
		if (errstr)
			errx(1, "Target %s: %s", arg, errstr);
		bs.bs_channel = location.channel;
		bs.bs_target = location.target;
		bs.bs_lun = location.lun;
	} else {
		/* use other id */
		bs.bs_other_id = sb.st_rdev;
		bs.bs_other_id_type = BIOC_SSOTHER_DEVT;
	}

	bs.bs_bio.bio_cookie = bio_cookie;
	bs.bs_status = status;

	if (status != BIOC_SSHOTSPARE) {
		/* make sure user supplied a sd device */
		bs.bs_volid = bio_getvolbyname(devicename);
		if (bs.bs_volid == -1)
			errx(1, "invalid device %s", devicename);
	}

	if (ioctl(devh, BIOCSETSTATE, &bs))
		err(1, "BIOCSETSTATE");

	bio_status(&bs.bs_bio.bio_status);
}

void
bio_setblink(char *name, char *arg, int blink)
{
	struct locator		location;
	struct bioc_blink	bb;
	struct bioc_inq		bi;
	struct bioc_vol		bv;
	struct bioc_disk	bd;
	const char		*errstr;
	int			v, d, rv;

	errstr = str2locator(arg, &location);
	if (errstr)
		errx(1, "Target %s: %s", arg, errstr);

	/* try setting blink on the device directly */
	memset(&bb, 0, sizeof(bb));
	bb.bb_bio.bio_cookie = bio_cookie;
	bb.bb_status = blink;
	bb.bb_target = location.target;
	bb.bb_channel = location.channel;
	rv = ioctl(devh, BIOCBLINK, &bb);

	if (rv == 0 && bb.bb_bio.bio_status.bs_status == BIO_STATUS_UNKNOWN)
		return;

	if (rv == 0 && bb.bb_bio.bio_status.bs_status == BIO_STATUS_SUCCESS) {
		bio_status(&bb.bb_bio.bio_status);
		return;
	}

	/* if the blink didn't work, try to find something that will */

	memset(&bi, 0, sizeof(bi));
	bi.bi_bio.bio_cookie = bio_cookie;
	if (ioctl(devh, BIOCINQ, &bi))
		err(1, "BIOCINQ");

	bio_status(&bi.bi_bio.bio_status);

	for (v = 0; v < bi.bi_novol; v++) {
		memset(&bv, 0, sizeof(bv));
		bv.bv_bio.bio_cookie = bio_cookie;
		bv.bv_volid = v;
		if (ioctl(devh, BIOCVOL, &bv))
			err(1, "BIOCVOL");

		bio_status(&bv.bv_bio.bio_status);

		if (name && strcmp(name, bv.bv_dev) != 0)
			continue;

		for (d = 0; d < bv.bv_nodisk; d++) {
			memset(&bd, 0, sizeof(bd));
			bd.bd_bio.bio_cookie = bio_cookie;
			bd.bd_volid = v;
			bd.bd_diskid = d;

			if (ioctl(devh, BIOCDISK, &bd))
				err(1, "BIOCDISK");

			bio_status(&bd.bd_bio.bio_status);

			if (bd.bd_channel == location.channel &&
			    bd.bd_target == location.target &&
			    bd.bd_lun == location.lun) {
				if (bd.bd_procdev[0] != '\0')
					bio_blink(bd.bd_procdev,
					    location.target, blink);
				else
					warnx("Disk %s is not in an enclosure",
					    arg);
				return;
			}
		}
	}

	warnx("Disk %s does not exist", arg);

	return;
}

void
bio_blink(char *enclosure, int target, int blinktype)
{
	int			bioh;
	struct bio_locate	bl;
	struct bioc_blink	blink;

	bioh = open("/dev/bio", O_RDWR);
	if (bioh == -1)
		err(1, "Can't open %s", "/dev/bio");

	memset(&bl, 0, sizeof(bl));
	bl.bl_name = enclosure;
	if (ioctl(bioh, BIOCLOCATE, &bl))
		errx(1, "Can't locate %s device via %s", enclosure, "/dev/bio");

	memset(&blink, 0, sizeof(blink));
	blink.bb_bio.bio_cookie = bio_cookie;
	blink.bb_status = blinktype;
	blink.bb_target = target;

	if (ioctl(bioh, BIOCBLINK, &blink))
		err(1, "BIOCBLINK");

	bio_status(&blink.bb_bio.bio_status);

	close(bioh);
}

void
bio_createraid(u_int16_t level, char *dev_list, char *key_disk)
{
	struct bioc_createraid	create;
	struct sr_crypto_kdfinfo kdfinfo;
	struct sr_crypto_pbkdf	kdfhint;
	struct stat		sb;
	int			rv, no_dev, fd;
	dev_t			*dt;
	u_int16_t		min_disks = 0;

	if (!dev_list)
		errx(1, "no devices specified");

	dt = calloc(1, BIOC_CRMAXLEN);
	if (!dt)
		err(1, "not enough memory for dev_t list");

	no_dev = bio_parse_devlist(dev_list, dt);

	switch (level) {
	case 0:
		min_disks = 2;
		break;
	case 1:
		min_disks = 2;
		break;
	case 5:
		min_disks = 3;
		break;
	case 'C':
		min_disks = 1;
		break;
	case 'c':
		min_disks = 2;
		break;
	default:
		errx(1, "unsupported raid level");
	}

	if (no_dev < min_disks)
		errx(1, "not enough disks");

	/* for crypto raid we only allow one single chunk */
	if (level == 'C' && no_dev != min_disks)
		errx(1, "not exactly one partition");

	memset(&create, 0, sizeof(create));
	create.bc_bio.bio_cookie = bio_cookie;
	create.bc_level = level;
	create.bc_dev_list_len = no_dev * sizeof(dev_t);
	create.bc_dev_list = dt;
	create.bc_flags = BIOC_SCDEVT | cflags;
	create.bc_key_disk = NODEV;

	if (level == 'C' && key_disk == NULL) {

		memset(&kdfinfo, 0, sizeof(kdfinfo));
		memset(&kdfhint, 0, sizeof(kdfhint));

		create.bc_flags |= BIOC_SCNOAUTOASSEMBLE;

		create.bc_opaque = &kdfhint;
		create.bc_opaque_size = sizeof(kdfhint);
		create.bc_opaque_flags = BIOC_SOOUT;

		/* try to get KDF hint */
		if (ioctl(devh, BIOCCREATERAID, &create))
			err(1, "ioctl");

		bio_status(&create.bc_bio.bio_status);

		if (create.bc_opaque_status == BIOC_SOINOUT_OK) {
			bio_kdf_derive(&kdfinfo, &kdfhint, "Passphrase: ", 0);
			memset(&kdfhint, 0, sizeof(kdfhint));
		} else {
			bio_kdf_generate(&kdfinfo);
		}

		create.bc_opaque = &kdfinfo;
		create.bc_opaque_size = sizeof(kdfinfo);
		create.bc_opaque_flags = BIOC_SOIN;

	} else if (level == 'C' && key_disk != NULL) {

		/* Get device number for key disk. */
		fd = opendev(key_disk, O_RDONLY, OPENDEV_BLCK, NULL);
		if (fd == -1)
			err(1, "could not open %s", key_disk);
		if (fstat(fd, &sb) == -1) {
			int saved_errno = errno;
			close(fd);
			errc(1, saved_errno, "could not stat %s", key_disk);
		}
		close(fd);
		create.bc_key_disk = sb.st_rdev;

		memset(&kdfinfo, 0, sizeof(kdfinfo));

		kdfinfo.genkdf.len = sizeof(kdfinfo.genkdf);
		kdfinfo.genkdf.type = SR_CRYPTOKDFT_KEYDISK;
		kdfinfo.len = sizeof(kdfinfo);
		kdfinfo.flags = SR_CRYPTOKDF_HINT;

		create.bc_opaque = &kdfinfo;
		create.bc_opaque_size = sizeof(kdfinfo);
		create.bc_opaque_flags = BIOC_SOIN;

	}

	rv = ioctl(devh, BIOCCREATERAID, &create);
	explicit_bzero(&kdfinfo, sizeof(kdfinfo));
	if (rv == -1)
		err(1, "BIOCCREATERAID");

	bio_status(&create.bc_bio.bio_status);

	free(dt);
}

void
bio_kdf_derive(struct sr_crypto_kdfinfo *kdfinfo, struct sr_crypto_pbkdf
    *kdfhint, char* prompt, int verify)
{
	if (!kdfinfo)
		errx(1, "invalid KDF info");
	if (!kdfhint)
		errx(1, "invalid KDF hint");

	if (kdfhint->generic.len != sizeof(*kdfhint))
		errx(1, "KDF hint has invalid size");

	kdfinfo->flags = SR_CRYPTOKDF_KEY;
	kdfinfo->len = sizeof(*kdfinfo);

	derive_key(kdfhint->generic.type, kdfhint->rounds,
	    kdfinfo->maskkey, sizeof(kdfinfo->maskkey),
	    kdfhint->salt, sizeof(kdfhint->salt),
	    prompt, verify);
}

void
bio_kdf_generate(struct sr_crypto_kdfinfo *kdfinfo)
{
	if (!kdfinfo)
		errx(1, "invalid KDF info");

	if (rflag == -1)
		rflag = bcrypt_pbkdf_autorounds();

	kdfinfo->pbkdf.generic.len = sizeof(kdfinfo->pbkdf);
	kdfinfo->pbkdf.generic.type = SR_CRYPTOKDFT_BCRYPT_PBKDF;
	kdfinfo->pbkdf.rounds = rflag ? rflag : 16;

	kdfinfo->flags = SR_CRYPTOKDF_KEY | SR_CRYPTOKDF_HINT;
	kdfinfo->len = sizeof(*kdfinfo);

	/* generate salt */
	arc4random_buf(kdfinfo->pbkdf.salt, sizeof(kdfinfo->pbkdf.salt));

	derive_key(kdfinfo->pbkdf.generic.type, kdfinfo->pbkdf.rounds,
	    kdfinfo->maskkey, sizeof(kdfinfo->maskkey),
	    kdfinfo->pbkdf.salt, sizeof(kdfinfo->pbkdf.salt),
	    "New passphrase: ", 1);
}

int
bio_parse_devlist(char *lst, dev_t *dt)
{
	char			*s, *e;
	u_int32_t		sz = 0;
	int			no_dev = 0, i, x;
	struct stat		sb;
	char			dev[PATH_MAX];
	int			fd;

	if (!lst)
		errx(1, "invalid device list");

	s = e = lst;
	/* make sure we have a valid device list like /dev/sdNa,/dev/sdNNa */
	while (*e != '\0') {
		if (*e == ',')
			s = e + 1;
		else if (*(e + 1) == '\0' || *(e + 1) == ',') {
			/* got one */
			sz = e - s + 1;
			strlcpy(dev, s, sz + 1);
			fd = opendev(dev, O_RDONLY, OPENDEV_BLCK, NULL);
			if (fd == -1)
				err(1, "could not open %s", dev);
			if (fstat(fd, &sb) == -1) {
				int saved_errno = errno;
				close(fd);
				errc(1, saved_errno, "could not stat %s", dev);
			}
			close(fd);
			dt[no_dev] = sb.st_rdev;
			no_dev++;
			if (no_dev > (int)(BIOC_CRMAXLEN / sizeof(dev_t)))
				errx(1, "too many devices on device list");
		}
		e++;
	}

	for (i = 0; i < no_dev; i++)
		for (x = 0; x < no_dev; x++)
			if (dt[i] == dt[x] && x != i)
				errx(1, "duplicate device in list");

	return (no_dev);
}

u_int32_t
bio_createflags(char *lst)
{
	char			*s, *e, fs[32];
	u_int32_t		sz = 0;
	u_int32_t		flags = 0;

	if (!lst)
		errx(1, "invalid flags list");

	s = e = lst;
	/* make sure we have a valid flags list like force,noassemeble */
	while (*e != '\0') {
		if (*e == ',')
			s = e + 1;
		else if (*(e + 1) == '\0' || *(e + 1) == ',') {
			/* got one */
			sz = e - s + 1;
			switch (s[0]) {
			case 'f':
				flags |= BIOC_SCFORCE;
				break;
			case 'n':
				flags |= BIOC_SCNOAUTOASSEMBLE;
				break;
			default:
				strlcpy(fs, s, sz + 1);
				errx(1, "invalid flag %s", fs);
			}
		}
		e++;
	}

	return (flags);
}

void
bio_deleteraid(char *dev)
{
	struct bioc_deleteraid	bd;
	memset(&bd, 0, sizeof(bd));

	bd.bd_bio.bio_cookie = bio_cookie;
	/* XXX make this a dev_t instead of a string */
	strlcpy(bd.bd_dev, dev, sizeof bd.bd_dev);
	if (ioctl(devh, BIOCDELETERAID, &bd))
		err(1, "BIOCDELETERAID");

	bio_status(&bd.bd_bio.bio_status);
}

void
bio_changepass(char *dev)
{
	struct bioc_discipline bd;
	struct sr_crypto_kdfpair kdfpair;
	struct sr_crypto_kdfinfo kdfinfo1, kdfinfo2;
	struct sr_crypto_pbkdf kdfhint;
	int rv;

	memset(&bd, 0, sizeof(bd));
	memset(&kdfhint, 0, sizeof(kdfhint));
	memset(&kdfinfo1, 0, sizeof(kdfinfo1));
	memset(&kdfinfo2, 0, sizeof(kdfinfo2));

	/* XXX use dev_t instead of string. */
	strlcpy(bd.bd_dev, dev, sizeof(bd.bd_dev));
	bd.bd_cmd = SR_IOCTL_GET_KDFHINT;
	bd.bd_size = sizeof(kdfhint);
	bd.bd_data = &kdfhint;

	if (ioctl(devh, BIOCDISCIPLINE, &bd))
		err(1, "BIOCDISCIPLINE");

	bio_status(&bd.bd_bio.bio_status);

	/* Current passphrase. */
	bio_kdf_derive(&kdfinfo1, &kdfhint, "Old passphrase: ", 0);

	/*
	 * Unless otherwise specified, keep the previous number of rounds as
	 * long as we're using the same KDF.
	 */
	if (kdfhint.generic.type == SR_CRYPTOKDFT_BCRYPT_PBKDF && !rflag)
		rflag = kdfhint.rounds;

	/* New passphrase. */
	bio_kdf_generate(&kdfinfo2);

	kdfpair.kdfinfo1 = &kdfinfo1;
	kdfpair.kdfsize1 = sizeof(kdfinfo1);
	kdfpair.kdfinfo2 = &kdfinfo2;
	kdfpair.kdfsize2 = sizeof(kdfinfo2);

	bd.bd_cmd = SR_IOCTL_CHANGE_PASSPHRASE;
	bd.bd_size = sizeof(kdfpair);
	bd.bd_data = &kdfpair;

	rv = ioctl(devh, BIOCDISCIPLINE, &bd);

	memset(&kdfhint, 0, sizeof(kdfhint));
	explicit_bzero(&kdfinfo1, sizeof(kdfinfo1));
	explicit_bzero(&kdfinfo2, sizeof(kdfinfo2));

	if (rv)
		err(1, "BIOCDISCIPLINE");

	bio_status(&bd.bd_bio.bio_status);
}

#define BIOCTL_VIS_NBUF		4
#define BIOCTL_VIS_BUFLEN	80

char *
bio_vis(char *s)
{
	static char	 rbuf[BIOCTL_VIS_NBUF][BIOCTL_VIS_BUFLEN];
	static uint	 idx = 0;
	char		*buf;

	buf = rbuf[idx++];
	if (idx == BIOCTL_VIS_NBUF)
		idx = 0;

	strnvis(buf, s, BIOCTL_VIS_BUFLEN, VIS_NL|VIS_CSTYLE);
	return (buf);
}

void
bio_diskinq(char *sd_dev)
{
	struct dk_inquiry	di;

	if (ioctl(devh, DIOCINQ, &di) == -1)
		err(1, "DIOCINQ");

	printf("%s: <%s, %s, %s>, serial %s\n", sd_dev, bio_vis(di.vendor),
	    bio_vis(di.product), bio_vis(di.revision), bio_vis(di.serial));
}

void
bio_patrol(char *arg)
{
	struct bioc_patrol	bp;
	struct timing		timing;
	const char		*errstr;

	memset(&bp, 0, sizeof(bp));
	bp.bp_bio.bio_cookie = bio_cookie;

	switch (arg[0]) {
	case 'a':
		bp.bp_opcode = BIOC_SPAUTO;
		break;

	case 'm':
		bp.bp_opcode = BIOC_SPMANUAL;
		break;

	case 'd':
		bp.bp_opcode = BIOC_SPDISABLE;
		break;

	case 'g': /* get patrol state */
		bp.bp_opcode = BIOC_GPSTATUS;
		break;

	case 's': /* start/stop patrol */
		if (strncmp("sta", arg, 3) == 0)
			bp.bp_opcode = BIOC_SPSTART;
		else
			bp.bp_opcode = BIOC_SPSTOP;
		break;

	default:
		errx(1, "invalid patrol function: %s", arg);
	}

	switch (arg[0]) {
	case 'a':
		errstr = str2patrol(arg, &timing);
		if (errstr)
			errx(1, "Patrol %s: %s", arg, errstr);
		bp.bp_autoival = timing.interval;
		bp.bp_autonext = timing.start;
		break;
	}

	if (ioctl(devh, BIOCPATROL, &bp))
		err(1, "BIOCPATROL");

	bio_status(&bp.bp_bio.bio_status);

	if (arg[0] == 'g') {
		const char *mode, *status;
		char interval[40];

		interval[0] = '\0';

		switch (bp.bp_mode) {
		case BIOC_SPMAUTO:
			mode = "auto";
			snprintf(interval, sizeof interval,
			    " interval=%d next=%d", bp.bp_autoival,
			    bp.bp_autonext - bp.bp_autonow);
			break;
		case BIOC_SPMMANUAL:
			mode = "manual";
			break;
		case BIOC_SPMDISABLED:
			mode = "disabled";
			break;
		default:
			mode = "unknown";
			break;
		}
		switch (bp.bp_status) {
		case BIOC_SPSSTOPPED:
			status = "stopped";
			break;
		case BIOC_SPSREADY:
			status = "ready";
			break;
		case BIOC_SPSACTIVE:
			status = "active";
			break;
		case BIOC_SPSABORTED:
			status = "aborted";
			break;
		default:
			status = "unknown";
			break;
		}
		printf("patrol mode: %s%s\n", mode, interval);
		printf("patrol status: %s\n", status);
	}
}

/*
 * Measure this system's performance by measuring the time for 100 rounds.
 * We are aiming for something that takes around 1s.
 */
int
bcrypt_pbkdf_autorounds(void)
{
	struct timespec before, after;
	char buf[SR_CRYPTO_MAXKEYBYTES], salt[128];
	int r = 100;
	int duration;

	clock_gettime(CLOCK_THREAD_CPUTIME_ID, &before);
	if (bcrypt_pbkdf("testpassword", strlen("testpassword"),
	    salt, sizeof(salt), buf, sizeof(buf), r) != 0)
		errx(1, "bcrypt pbkdf failed");
	clock_gettime(CLOCK_THREAD_CPUTIME_ID, &after);

	duration = after.tv_sec - before.tv_sec;
	duration *= 1000000;
	duration += (after.tv_nsec - before.tv_nsec) / 1000;

	duration /= r;
	r = 1000000 / duration;

	if (r < 16)
		r = 16;

	return r;
}

void
derive_key(u_int32_t type, int rounds, u_int8_t *key, size_t keysz,
    u_int8_t *salt, size_t saltsz, char *prompt, int verify)
{
	FILE		*f;
	size_t		pl;
	struct stat	sb;
	char		passphrase[1024], verifybuf[1024];

	if (!key)
		errx(1, "Invalid key");
	if (!salt)
		errx(1, "Invalid salt");

	if (type != SR_CRYPTOKDFT_PKCS5_PBKDF2 &&
	    type != SR_CRYPTOKDFT_BCRYPT_PBKDF)
		errx(1, "unknown KDF type %d", type);

	if (rounds < (type == SR_CRYPTOKDFT_PKCS5_PBKDF2 ? 1000 : 4))
		errx(1, "number of KDF rounds is too small: %d", rounds);

	/* get passphrase */
	if (password) {
		if ((f = fopen(password, "r")) == NULL)
			err(1, "invalid passphrase file");

		if (fstat(fileno(f), &sb) == -1)
			err(1, "can't stat passphrase file");
		if (sb.st_uid != 0)
			errx(1, "passphrase file must be owned by root");
		if ((sb.st_mode & ~S_IFMT) != (S_IRUSR | S_IWUSR))
			errx(1, "passphrase file has the wrong permissions");

		if (fgets(passphrase, sizeof(passphrase), f) == NULL)
			err(1, "can't read passphrase file");
		pl = strlen(passphrase);
		if (pl > 0 && passphrase[pl - 1] == '\n')
			passphrase[pl - 1] = '\0';
		else
			errx(1, "invalid passphrase length");

		fclose(f);
	} else {
		if (readpassphrase(prompt, passphrase, sizeof(passphrase),
		    rpp_flag) == NULL)
			err(1, "unable to read passphrase");
	}

	if (verify && !password) {
		/* request user to re-type it */
		if (readpassphrase("Re-type passphrase: ", verifybuf,
		    sizeof(verifybuf), rpp_flag) == NULL) {
			explicit_bzero(passphrase, sizeof(passphrase));
			err(1, "unable to read passphrase");
		}
		if ((strlen(passphrase) != strlen(verifybuf)) ||
		    (strcmp(passphrase, verifybuf) != 0)) {
			explicit_bzero(passphrase, sizeof(passphrase));
			explicit_bzero(verifybuf, sizeof(verifybuf));
			errx(1, "Passphrases did not match");
		}
		/* forget the re-typed one */
		explicit_bzero(verifybuf, sizeof(verifybuf));
	}

	/* derive key from passphrase */
	if (type == SR_CRYPTOKDFT_PKCS5_PBKDF2) {
		if (verbose)
			printf("Deriving key using PKCS#5 PBKDF2 with %i rounds...\n",
			    rounds);
		if (pkcs5_pbkdf2(passphrase, strlen(passphrase), salt, saltsz,
		    key, keysz, rounds) != 0)
			errx(1, "pkcs5_pbkdf2 failed");
	} else if (type == SR_CRYPTOKDFT_BCRYPT_PBKDF) {
		if (verbose)
			printf("Deriving key using bcrypt PBKDF with %i rounds...\n",
			    rounds);
		if (bcrypt_pbkdf(passphrase, strlen(passphrase), salt, saltsz,
		    key, keysz, rounds) != 0)
			errx(1, "bcrypt_pbkdf failed");
	} else {
		errx(1, "unknown KDF type %d", type);
	}

	/* forget passphrase */
	explicit_bzero(passphrase, sizeof(passphrase));

	return;
}
@


1.140
log
@optarg is declared in unistd.h and usage is __dead. From Jan Stary.

ok natano
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.139 2016/09/21 17:50:05 jsing Exp $ */
d234 1
a239 2
		bio_status(&bl.bl_bio.bio_status);

a806 2
 
	bio_status(&bl.bl_bio.bio_status);
@


1.139
log
@Add support for automatically selecting the number of rounds to use with
bcrypt pbkdf, based on system performance. This is based on the bcrypt
autorounds code we have in libc.

Discussed with djm@@ and tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.138 2016/09/19 17:46:52 jsing Exp $ */
d62 1
a62 1
void			usage(void);
a102 1
	extern char		*optarg;
d275 1
a275 1
void
@


1.138
log
@Switch softraid crypto from PKCS5 PBKDF2 to bcrypt PBKDF.

New volumes will be created with bcrypt PBKDF, however existing volumes
will continue to use PKCS5 PBKDF2 until a passphrase change is made.

If you're booting from softraid crypto, ensure that your boot loader has
been upgraded to a version that supports bcrypt prior to changing your
passphrase. Also be aware that once the passphrase has been changed, an
older version of bioctl(8) (one that does not support bcrypt PBKDF) will
not be able to "unlock" the volume.

Partly based on a diff from djm@@.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.137 2016/09/10 17:08:44 jsing Exp $ */
d45 1
d70 1
d177 4
d972 3
d1276 31
d1374 3
d1381 3
@


1.137
log
@Teach bioctl derive_key() how to handle bcrypt_pbkdf.

Part of a diff from djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.135 2016/09/10 16:53:22 jsing Exp $ */
d175 1
a175 1
			rflag = strtonum(optarg, 1000, 1<<30, &errstr);
d967 2
a968 2
	kdfinfo->pbkdf.generic.type = SR_CRYPTOKDFT_PKCS5_PBKDF2;
	kdfinfo->pbkdf.rounds = rflag ? rflag : 8192;
d1108 5
a1112 2
	/* Keep the previous number of rounds, unless specified. */
	if (!rflag)
@


1.136
log
@Ugh, too many initialisms...
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.135 2016/09/10 16:53:22 jsing Exp $       */
d1278 2
a1279 1
	if (type != SR_CRYPTOKDFT_PKCS5_PBKDF2)
d1281 2
a1282 1
	if (rounds < 1000)
d1330 11
a1340 3
	if (pkcs5_pbkdf2(passphrase, strlen(passphrase), salt, saltsz,
	    key, keysz, rounds) != 0)
		errx(1, "pbkdf2 failed");
@


1.135
log
@Clean up some softraid crypto code - rename struct sr_crypto_kdf_pbkdf2 to
sr_crypto_pbkdf (since it is useable for more than just pkcs5_pbkdf2) and
embed a struct sr_crypto_genkdf within it, rather than redeclaring the same
fields. Rename SR_CRYPTOKDFT_PBKDF2 to SR_CRYPTOKDFT_PCKS5_PBKDF2 and add
SR_CRYPTOKDFT_BCRYPT_PBKDF for upcoming changes.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.134 2016/09/08 19:08:14 jsing Exp $       */
d967 1
a967 1
	kdfinfo->pbkdf.generic.type = SR_CRYPTOKDFT_PCKS5_PBKDF2;
d1278 1
a1278 1
	if (type != SR_CRYPTOKDFT_PCKS5_PBKDF2)
@


1.134
log
@When changing the passphrase, keep the previous number of rounds, unless
specified otherwise.

Part of a diff from halex@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.133 2016/09/08 18:41:04 jsing Exp $       */
d67 1
a67 1
			    struct sr_crypto_kdf_pbkdf2 *, char *, int);
d69 1
a69 1
void			derive_key_pkcs(u_int32_t, int, u_int8_t *, size_t,
d824 1
a824 1
	struct sr_crypto_kdf_pbkdf2 kdfhint;
d940 1
a940 1
bio_kdf_derive(struct sr_crypto_kdfinfo *kdfinfo, struct sr_crypto_kdf_pbkdf2
d948 1
a948 1
	if (kdfhint->len != sizeof(*kdfhint))
d954 1
a954 1
	derive_key_pkcs(kdfhint->type, kdfhint->rounds,
d966 3
a968 3
	kdfinfo->pbkdf2.len = sizeof(kdfinfo->pbkdf2);
	kdfinfo->pbkdf2.type = SR_CRYPTOKDFT_PBKDF2;
	kdfinfo->pbkdf2.rounds = rflag ? rflag : 8192;
d974 1
a974 1
	arc4random_buf(kdfinfo->pbkdf2.salt, sizeof(kdfinfo->pbkdf2.salt));
d976 1
a976 1
	derive_key_pkcs(kdfinfo->pbkdf2.type, kdfinfo->pbkdf2.rounds,
d978 1
a978 1
	    kdfinfo->pbkdf2.salt, sizeof(kdfinfo->pbkdf2.salt),
d1086 1
a1086 1
	struct sr_crypto_kdf_pbkdf2 kdfhint;
d1265 1
a1265 1
derive_key_pkcs(u_int32_t type, int rounds, u_int8_t *key, size_t keysz,
d1278 1
a1278 1
	if (type != SR_CRYPTOKDFT_PBKDF2)
@


1.133
log
@Shuffle some code to make futher changes easier - pass the KDF type into
derive_key_pkcs(), check the type and rounds in one place, unify the rounds
too small error.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.132 2016/09/08 17:51:02 jsing Exp $       */
d90 1
a90 1
int			rflag = 8192;
d968 1
a968 1
	kdfinfo->pbkdf2.rounds = rflag;
d1107 4
@


1.132
log
@When changing a passphrase, use bio_kdf_generate() so that we generate a
new salt and respect the specified number of rounds.

Before changing your softraid crypto passphrase ensure that you are running
a kernel with r1.131 of softraid_crypto.c, otherwise the volume will become
unusable.

Same diff also from djm@@ and halex@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.131 2016/05/13 19:06:52 tedu Exp $       */
d69 2
a70 2
void			derive_key_pkcs(int, u_int8_t *, size_t, u_int8_t *,
			    size_t, char *, int);
d177 1
a177 1
				errx(1, "Number of rounds is %s: %s",
a949 4
	if (kdfhint->type != SR_CRYPTOKDFT_PBKDF2)
		errx(1, "unknown KDF type %d", kdfhint->type);
	if (kdfhint->rounds < 1000)
		errx(1, "number of KDF rounds too low: %d", kdfhint->rounds);
d954 1
a954 1
	derive_key_pkcs(kdfhint->rounds,
d956 2
a957 1
	    kdfhint->salt, sizeof(kdfhint->salt), prompt, verify);
d969 2
a971 1
	kdfinfo->flags = SR_CRYPTOKDF_KEY | SR_CRYPTOKDF_HINT;
d976 1
a976 1
	derive_key_pkcs(kdfinfo->pbkdf2.rounds,
d1261 2
a1262 2
derive_key_pkcs(int rounds, u_int8_t *key, size_t keysz, u_int8_t *salt,
    size_t saltsz, char *prompt, int verify)
d1273 3
d1277 1
a1277 1
		errx(1, "Too few rounds: %d", rounds);
@


1.131
log
@overzealous use of errx() hides useful information about errors.
ok benno millert
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.130 2016/02/04 08:31:26 uebayasi Exp $       */
d1111 1
a1111 1
	bio_kdf_derive(&kdfinfo2, &kdfhint, "New passphrase: ", 1);
@


1.130
log
@Fix an unitialized variable; pointed out by jsg@@.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.129 2015/07/18 23:23:20 halex Exp $       */
d1302 1
a1302 1
			errx(1, "unable to read passphrase");
d1310 1
a1310 1
			errx(1, "unable to read passphrase");
@


1.129
log
@remove the restriction to disallow the use of a passphrase file during
initial creation of a crypto volume

ok phessler
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.128 2015/05/30 06:24:59 jmc Exp $       */
d1237 1
a1237 1
			status = "unknown";
@


1.128
log
@fix usage();
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.127 2015/05/29 00:33:37 uebayasi Exp $       */
a1278 3
	if (password && verify)
		errx(1, "can't specify passphrase file during initial "
		    "creation of crypto volume");
d1305 1
a1305 1
	if (verify) {
@


1.127
log
@Initial addition of ``Patrol Read'' support in bio(4), biocto(8), and
mfi(4).  Based on FreeBSD, but done without mfiutil(8).

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD$       */
d280 2
a281 1
		"\t[-u channel:target[.lun]] "
d288 1
a288 1
		"\t[-r rounds] [-t patrol-function] "
@


1.126
log
@explicit_bzero(3) on private data, in case of core dumps (and being a good example)

ok florian jsing
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.125 2015/04/11 16:37:34 jsing Exp $       */
d56 5
d63 1
d84 1
d116 1
a116 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hik:l:O:Pp:qr:R:su:v")) !=
d195 4
d251 2
d287 1
a287 1
		"\t[-r rounds] "
d323 33
d384 1
a384 1
	char			percent[10], seconds[20];
d510 2
d570 9
d583 2
a584 2
				printf("%11s %-10s %14s %-7s %-6s '%s'\n",
				    "", "", "", "", "", serial);
d1161 98
@


1.125
log
@Re-enable the RAID 5 discipline for softraid(4).

The RAID 5 implementation has been largely rewritten during the last two
hackathons in Dunedin - it now needs further testing and usage.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.124 2015/03/18 07:42:13 uebayasi Exp $       */
d872 1
a872 1
	memset(&kdfinfo, 0, sizeof(kdfinfo));
d1067 2
a1068 2
	memset(&kdfinfo1, 0, sizeof(kdfinfo1));
	memset(&kdfinfo2, 0, sizeof(kdfinfo2));
d1156 1
a1156 1
			memset(passphrase, 0, sizeof(passphrase));
d1161 2
a1162 2
			memset(passphrase, 0, sizeof(passphrase));
			memset(verifybuf, 0, sizeof(verifybuf));
d1166 1
a1166 1
		memset(verifybuf, 0, strlen(verifybuf));
d1175 1
a1175 1
	memset(passphrase, 0, sizeof(passphrase));
@


1.124
log
@Sort getopt() string.
@
text
@d1 1
a1 1
/* $OpenBSD$       */
a787 1
#ifdef RAID5
a790 1
#endif /* RAID5 */
@


1.123
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.122 2014/10/08 10:08:03 jsing Exp $       */
d109 1
a109 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hik:l:O:Pp:qr:R:svu:")) !=
@


1.122
log
@tedu the tedu code that tedu forgot to tedu when he tedued the other part
of this tedu code.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.121 2014/07/20 01:38:40 guenther Exp $       */
d30 1
a30 1
#include <sys/param.h>
d46 1
d935 1
a935 1
	char			dev[MAXPATHLEN];
@


1.121
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.120 2014/04/22 20:42:01 tedu Exp $       */
a48 8
#ifdef AOE
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

struct sr_aoe_config 	*create_aoe(u_int16_t, char *);
#endif /* AOE */

a759 46
#ifdef AOE
struct sr_aoe_config *
create_aoe(u_int16_t level, char *dev_list)
{
	static struct sr_aoe_config sac;
	char *nic;
	char *dsteaddr;
	char *shelf;
	char *slot;
	struct ether_addr *eaddr;
	const char *errstr;

	nic = dsteaddr = slot = shelf = 0;

	memset(&sac, 0, sizeof(sac));
	nic = dev_list;
	dsteaddr = strchr(nic, ',');
	if (!dsteaddr)
		goto invalid;
	*dsteaddr++ = '\0';
	shelf = strchr(dsteaddr, ',');
	if (!shelf)
		goto invalid;
	*shelf++ = '\0';
	slot = strchr(shelf, ',');
	if (!slot)
		goto invalid;
	*slot++ = '\0';
	strlcpy(sac.nic, nic, sizeof(sac.nic));
	eaddr = ether_aton(dsteaddr);
	if (!eaddr)
		goto invalid;
	sac.dsteaddr = *eaddr;
	sac.shelf = htons(strtonum(shelf, 0, 0xfffe, &errstr));
	if (errstr)
		goto invalid;
	sac.slot = strtonum(slot, 0, 0xfe, &errstr);
	if (errstr)
		goto invalid;

	return &sac;
invalid:
	errx(1, "invalid AOE dev list: use nic,dsteaddr,shelf,slot");
}
#endif /* AOE */

a765 3
#ifdef AOE
	struct sr_aoe_config	*sac;
#endif /* AOE */
d774 3
a776 11
#ifdef AOE
	if (level == 'a') {
		sac = create_aoe(level, dev_list);
		no_dev = 0;
		dt = NULL;
	} else
#endif /* AOE */
	{
		dt = calloc(1, BIOC_CRMAXLEN);
		if (!dt)
			err(1, "not enough memory for dev_t list");
d778 1
a778 2
		no_dev = bio_parse_devlist(dev_list, dt);
	}
a797 4
#ifdef AOE
	case 'a':
		break;
#endif /* AOE */
a816 7
#ifdef AOE
	if (level == 'a') {
		create.bc_opaque = sac;
		create.bc_opaque_size = sizeof(*sac);
		create.bc_opaque_flags = BIOC_SOIN;
	} else
#endif /* AOE */
@


1.120
log
@malloc/memset -> calloc. from peter malone
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.119 2014/01/18 09:11:12 jsing Exp $       */
d929 1
d931 1
a931 1
			err(1, "could not stat %s", key_disk);
d1030 1
d1032 1
a1032 1
				err(1, "could not stat %s", dev);
@


1.119
log
@Disable the RAID 5 discipline in bioctl, as the current softraid RAID 5
discipline will more than likely eat data if a drive is lost.

Discussed with krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.118 2014/01/18 09:01:01 jsing Exp $       */
d839 1
a839 1
		dt = (dev_t *)malloc(BIOC_CRMAXLEN);
a841 1
		memset(dt, 0, BIOC_CRMAXLEN);
@


1.118
log
@Remove the RAID 4 discipline from softraid. Anyone sensible would use RAID
5 instead of RAID 4, assuming both were functional.

Discussed with krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.117 2013/11/22 04:12:46 deraadt Exp $       */
d854 1
d858 1
d865 1
d868 1
@


1.117
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.116 2013/11/11 23:07:52 deraadt Exp $       */
a853 1
	case 4:
@


1.116
log
@oops, forgot a #ifdef AOE in last commit
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.115 2013/11/04 21:02:58 deraadt Exp $       */
d133 1
a133 1
			if (isdigit(*optarg)) {
@


1.115
log
@substantial namespace cleanup.  Might go a little bit too far, but we
can expose some of the kernel structures with split .h files if need be.
Discussed with various, including jsing.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.114 2013/10/31 00:47:20 kettenis Exp $       */
d41 1
d820 1
d822 1
@


1.114
log
@Make sure -v output is properly aligned with the normal output.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.113 2013/10/23 13:05:38 kettenis Exp $       */
d30 1
a32 2
#include <sys/param.h>
#include <sys/types.h>
d34 1
a35 1
#include <dev/softraidvar.h>
a44 1
#include <ctype.h>
d48 8
a77 1
struct sr_aoe_config 	*create_aoe(u_int16_t, char *);
d767 1
d811 1
d828 1
d833 3
a835 1
	} else  {
d882 1
d887 3
a889 1
	} else if (level == 'C' && key_disk == NULL) {
@


1.113
log
@Add support for displaying the cache write policy of RAID volumes to bioctl(8)
and make mfi(4) pass up the necessary information.  Adding support for other
RAID controllers is left as an excercise to the reader.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.112 2012/09/10 11:28:47 jsing Exp $       */
d527 1
a527 1
				printf("%7s %-10s %14s %-7s %-6s '%s'\n",
@


1.112
log
@Only keep track of the bio(4) cookie, not an entire bio_locate struct.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.110 2012/04/19 19:13:51 deraadt Exp $       */
d337 2
a338 1
	char 			*status, size[64], scsiname[16], volname[32];
d413 11
d452 1
a452 1
				printf("%11s %-10s %14s %-7s RAID%u%s%s\n",
d454 1
a454 1
				    bv.bv_level, percent, seconds);
@


1.111
log
@move pkcs5_pbkdf5 function to libutil so everybody can play with it
ok deraadt jsing matthew
@
text
@d87 2
a88 1
struct bio_locate	bl;
d94 1
d226 1
d347 1
a347 1
	bi.bi_bio.bio_cookie = bl.bl_bio.bio_cookie;
d362 1
a362 1
		bv.bv_bio.bio_cookie = bl.bl_bio.bio_cookie;
d450 1
a450 1
			bd.bd_bio.bio_cookie = bl.bl_bio.bio_cookie;
d527 1
a527 1
	ba.ba_bio.bio_cookie = bl.bl_bio.bio_cookie;
d574 1
a574 1
	bi.bi_bio.bio_cookie = bl.bl_bio.bio_cookie;
d582 1
a582 1
		bv.bv_bio.bio_cookie = bl.bl_bio.bio_cookie;
d621 1
a621 1
	bs.bs_bio.bio_cookie = bl.bl_bio.bio_cookie;
d654 1
a654 1
	bb.bb_bio.bio_cookie = bl.bl_bio.bio_cookie;
d671 1
a671 1
	bi.bi_bio.bio_cookie = bl.bl_bio.bio_cookie;
d679 1
a679 1
		bv.bv_bio.bio_cookie = bl.bl_bio.bio_cookie;
d691 1
a691 1
			bd.bd_bio.bio_cookie = bl.bl_bio.bio_cookie;
d738 1
a738 1
	blink.bb_bio.bio_cookie = bl.bl_bio.bio_cookie;
d853 1
a853 1
	create.bc_bio.bio_cookie = bl.bl_bio.bio_cookie;
d1061 1
a1061 1
	bd.bd_bio.bio_cookie = bd.bd_bio.bio_cookie;
@


1.110
log
@clear memory before passing to ioctl routines instead of praying it
will be ok and not break things upon return.
ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.109 2012/01/22 11:00:39 jsing Exp $       */
a48 2

#include "pbkdf2.h"
@


1.109
log
@If no controller name is provided, use the program name as a prefix. Also,
exit with an "unknown error" if a bio(4) error is reported but no status
message has been provided.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.108 2012/01/20 14:09:25 jsing Exp $       */
a339 1
	struct bioc_disk	bd;
d342 1
d525 1
d640 1
a643 1
	struct bioc_blink	bb;
d729 1
@


1.108
log
@Teach bioctl(8) about the new status interface for bio(4). With the
exception of a few messages specific to softraid(4) CRYPTO, there should
be no functional change for drivers that do not yet implement the interface
(which is currently all of them).
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.107 2012/01/17 15:15:57 jsing Exp $       */
d313 2
d317 13
a329 4
	for (i = 0; i < bs->bs_msg_count; i++) {
		if (strlen(bs->bs_controller))
			printf("%s: ", bs->bs_controller);
		printf("%s\n", bs->bs_msgs[i].bm_msg);
a330 3

	if (bs->bs_status == BIO_STATUS_ERROR)
		exit(1);
@


1.107
log
@Move the bio(4) cookie into a separate struct and make this struct the
first member of each ioctl data structure. This will allow for future
changes to bio(4) status handling.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.106 2012/01/17 14:01:02 jsing Exp $       */
d60 1
a60 1
void			cleanup(void);
a96 1
	/* u_int64_t subfunc = 0; */
d102 1
a102 1
	int			ch, rv, blink = 0, changepass = 0, diskinq = 0;
d220 1
a220 2
		rv = ioctl(devh, BIOCLOCATE, &bl);
		if (rv == -1)
d223 3
d311 15
d330 1
a330 1
	int			rv, i, d, volheader, hotspare, unused;
d340 1
a340 2
	rv = ioctl(devh, BIOCINQ, &bi);
	if (rv == -1) {
d348 2
d358 1
a358 2
		rv = ioctl(devh, BIOCVOL, &bv);
		if (rv == -1)
d361 2
d445 1
a445 2
			rv = ioctl(devh, BIOCDISK, &bd);
			if (rv == -1)
d447 2
a514 1
	int			rv;
d546 1
a546 2
	rv = ioctl(devh, BIOCALARM, &ba);
	if (rv == -1)
d549 3
a551 1
	if (arg[0] == 'g') {
a553 2

	}
d559 1
a559 1
	int			id = -1, i, rv;
d565 1
a565 2
	rv = ioctl(devh, BIOCINQ, &bi);
	if (rv == -1)
d568 2
d574 1
a574 2
		rv = ioctl(devh, BIOCVOL, &bv);
		if (rv == -1)
d577 2
a594 1
	int			rv;
d621 1
a621 2
	rv = ioctl(devh, BIOCSETSTATE, &bs);
	if (rv == -1)
d623 2
d649 2
a650 1
	if (rv == 0)
d653 5
d662 1
a662 2
	rv = ioctl(devh, BIOCINQ, &bi);
	if (rv == -1)
d665 2
d671 1
a671 2
		rv = ioctl(devh, BIOCVOL, &bv);
		if (rv == -1)
d674 2
d685 1
a685 2
			rv = ioctl(devh, BIOCDISK, &bd);
			if (rv == -1)
d688 2
d693 1
a693 1
				if (bd.bd_procdev[0] != '\0') {
d696 3
a698 2
				} else
					warnx("Disk %s is not in an enclosure", arg);
d705 1
d713 1
a713 1
	struct bio_locate	bio;
a714 1
	int			rv;
d720 2
a721 3
	bio.bl_name = enclosure;
	rv = ioctl(bioh, BIOCLOCATE, &bio);
	if (rv == -1)
d723 2
d727 1
a727 1
	blink.bb_bio.bio_cookie = bio.bl_bio.bio_cookie;
d731 1
a731 2
	rv = ioctl(bioh, BIOCBLINK, &blink);
	if (rv == -1)
d734 2
d865 1
a865 1
		if (ioctl(devh, BIOCCREATERAID, &create) == -1)
d868 2
d873 1
a873 1
		} else  {
d909 1
a909 4
	memset(&create, 0, sizeof(create));
	if (rv == -1) {
		if (errno == EPERM)
			errx(1, "Incorrect passphrase");
d911 2
a912 1
	}
d1054 3
a1056 1
		errx(1, "delete volume %s failed", dev);
d1080 3
a1082 1
		errx(1, "%s: failed to get KDF hint", dev);
d1105 4
a1108 6
	if (rv) {
		if (errno == EPERM)
			errx(1, "%s: incorrect passphrase", dev);
		else
			errx(1, "%s: failed to change passphrase", dev);
	}
@


1.106
log
@CONCAT requires at least two disks.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.102 2011/07/09 16:53:37 nicm Exp $       */
d322 1
a322 1
	bi.bi_cookie = bl.bl_cookie;
d336 1
a336 1
		bv.bv_cookie = bl.bl_cookie;
d423 1
a423 1
			bd.bd_cookie = bl.bl_cookie;
d499 1
a499 1
	ba.ba_cookie = bl.bl_cookie;
d547 1
a547 1
	bi.bi_cookie = bl.bl_cookie;
d554 1
a554 1
		bv.bv_cookie = bl.bl_cookie;
d593 1
a593 1
	bs.bs_cookie = bl.bl_cookie;
d625 1
a625 1
	bb.bb_cookie = bl.bl_cookie;
d636 1
a636 1
	bi.bi_cookie = bl.bl_cookie;
d643 1
a643 1
		bv.bv_cookie = bl.bl_cookie;
d654 1
a654 1
			bd.bd_cookie = bl.bl_cookie;
d697 1
a697 1
	blink.bb_cookie = bio.bl_cookie;
d811 1
a811 1
	create.bc_cookie = bl.bl_cookie;
d1019 1
a1019 1
	bd.bd_cookie = bd.bd_cookie;
@


1.105
log
@Provide a bioctl(8) option that changes the state of a chunk to offline.

man page part with todd@@
@
text
@d795 1
a795 1
		min_disks = 1;
@


1.104
log
@Implement a concatenating discipline for softraid.

Many thanks to Marco Peereboom for his assistance with testing and
debugging. Thanks also to Josh Grosse and Chris Jackman for testing.
@
text
@d111 1
a111 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hik:l:Pp:qr:R:svu:")) !=
d175 6
d270 4
a273 2
		"\t[-l special[,special,...]] [-p passfile]\n"
		"\t[-R device | channel:target[.lun]] [-r rounds] "
@


1.103
log
@Add missing closing braces in usage().
Ok jmc@@ (who also pointed me to the 2nd missing one) sobrado@@.
@
text
@d399 5
@


1.102
log
@Add a missing prototype, fix build with WARNINGS=yes.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.101 2011/07/08 01:17:58 tedu Exp $       */
d259 1
a259 1
		"[-R device | channel:target[.lun]\n"
d265 1
a265 1
		"\t[-R device | channel:target[.lun] [-r rounds] "
@


1.101
log
@add basic config support for creating aoe disks. ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.100 2011/07/04 04:52:34 tedu Exp $       */
d74 1
@


1.100
log
@use stronum, removing an atoi from the tree.  ok deraadt matthew
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.99 2011/04/04 15:22:31 jcs Exp $       */
d694 44
d744 1
d753 9
a761 4
	dt = (dev_t *)malloc(BIOC_CRMAXLEN);
	if (!dt)
		err(1, "not enough memory for dev_t list");
	memset(dt, 0, BIOC_CRMAXLEN);
d763 2
a764 1
	no_dev = bio_parse_devlist(dev_list, dt);
d783 2
d804 5
a808 1
	if (level == 'C' && key_disk == NULL) {
@


1.99
log
@give more space when printing volumes to allow softraid0 to fit

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.98 2010/12/01 19:40:18 ckuethe Exp $       */
d127 5
a131 3
			if (isdigit(*optarg))
				cr_level = atoi(optarg);
			else
@


1.98
log
@Allow add a -s switch to make bioctl read the passphrase from stdin. Handy
for scripting a big batch of remote unlocks. ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.97 2010/07/10 02:56:16 matthew Exp $       */
d339 1
a339 1
			printf("%-7s %-10s %14s %-8s\n",
d392 1
a392 1
				printf("%7s %-10s %14s %-7s CRYPTO%s%s\n",
d397 1
a397 1
				printf("%7s %-10s %14s %-7s RAID%u%s%s\n",
d467 1
a467 1
			printf("%7s %-10s %14s %-7s %-6s <%s>\n",
@


1.97
log
@Eliminate some unnecessary #include lines.

"sure" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.96 2010/07/01 09:35:42 jsing Exp $       */
d89 1
d110 1
a110 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hik:l:Pp:qr:R:vu:")) !=
d178 3
d259 4
a262 4
                "       %s [-dhiPqv] "
                "[-C flag[,flag,...]] [-c raidlevel] [-k keydisk]\n"
                "\t[-l special[,special,...]] [-p passfile]\n"
                "\t[-R device | channel:target[.lun] [-r rounds] "
d264 1
a264 1
	
d1077 1
a1077 1
		    RPP_REQUIRE_TTY) == NULL)
d1084 1
a1084 1
		    sizeof(verifybuf), RPP_REQUIRE_TTY) == NULL) {
@


1.96
log
@Use opendev(3) when handling key disks so that disklabel UIDs are
supported.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.94 2010/06/18 17:15:37 jsing Exp $       */
a32 1
#include <sys/queue.h>
a34 2
#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
a36 2
#include <sys/types.h>
#include <sys/stat.h>
a46 1
#include <util.h>
@


1.95
log
@rename devname->devicename to prevent shadowing devname(3).  ok marco jsing
@
text
@d701 1
a701 1
	int			rv, no_dev;
d779 6
a784 1
		if (stat(key_disk, &sb) == -1)
d786 2
@


1.94
log
@Make bioctl(8) disklabel UID friendly by attempting to open the device
using opendev(3) first and then trying /dev/bio if that failed. Also use
opendev(3) when getting device numbers for softraid.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.92 2010/04/03 15:22:44 nicm Exp $       */
d102 1
a102 1
	char			*devname = NULL;
d203 2
a204 2
	devname = argv[0];
	if (devname == NULL)
d207 1
a207 1
	devh = opendev(devname, O_RDWR, OPENDEV_PART, &realname);
d213 1
a213 1
		bl.bl_name = devname;
d219 1
a219 1
		devname = NULL;
d223 1
a223 1
		bio_diskinq(devname);
d225 1
a225 1
		bio_changepass(devname);
d227 1
a227 1
		bio_inq(devname);
d231 1
a231 1
		bio_setblink(devname, bl_arg, blink);
d235 1
a235 1
		bio_deleteraid(devname);
@


1.93
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d102 1
a102 1
	char			*bioc_dev = NULL, *sd_dev = NULL;
d110 1
d203 3
a205 6
	/* if at least glob sd[0-9]*, it is a drive identifier */
	if (strncmp(argv[0], "sd", 2) == 0 && strlen(argv[0]) > 2 &&
	    isdigit(argv[0][2]))
		sd_dev = argv[0];
	else
		bioc_dev = argv[0];
d207 2
a208 1
	if (bioc_dev) {
d213 1
a213 1
		bl.bl_name = bioc_dev;
d218 3
a220 6
	} else if (sd_dev) {
		devh = opendev(sd_dev, O_RDWR, OPENDEV_PART, &realname);
		if (devh == -1)
			err(1, "Can't open %s", sd_dev);
	} else
		errx(1, "need device");
d223 3
a225 3
		bio_diskinq(sd_dev);
	} else if (changepass && sd_dev != NULL) {
		bio_changepass(sd_dev);
d227 1
a227 1
		bio_inq(sd_dev);
d231 1
a231 1
		bio_setblink(sd_dev, bl_arg, blink);
d234 2
a235 2
	} else if (func == BIOC_DELETERAID && sd_dev != NULL) {
		bio_deleteraid(sd_dev);
d241 2
a242 2
		if (sd_dev)
			errx(1, "can't use sd device");
d861 1
d875 5
a879 1
			if (stat(dev, &sb) == -1)
d881 2
@


1.92
log
@scsi_all.h is needed before scsi_disk.h now. ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.91 2010/01/08 16:38:22 halex Exp $       */
d31 1
@


1.91
log
@"Too less" => "Too few"

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.90 2010/01/03 01:41:47 nicm Exp $       */
d35 1
a36 1
#include <scsi/scsi_all.h>
@


1.90
log
@Nuke some unused variables, ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.89 2009/12/31 14:57:40 jmc Exp $       */
d1040 1
a1040 1
		errx(1, "Too less rounds: %d", rounds);
@


1.89
log
@use the same arg name for -k as the man page;
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.88 2009/12/31 14:00:45 jsing Exp $       */
d704 2
a705 2
	int			rv, no_dev, i;
	dev_t			*dt, kd = NODEV;
@


1.88
log
@Add support for key disks. This allows a crypto volume to be constructed
without using a passphrase - instead the encryption mask key is stored on
the specified key disk partition (ideally being one on a removable device).
This also enables automatic assembly of crypto volumes at boot time.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.86 2009/11/24 06:06:06 jmc Exp $       */
d265 1
a265 1
                "[-C flag[,flag,...]] [-c raidlevel] [-k special]\n"
@


1.87
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d79 1
a79 1
void			bio_createraid(u_int16_t, char *);
d104 1
d113 1
a113 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hil:Pp:qr:R:vu:")) !=
d155 3
d246 1
a246 1
		bio_createraid(cr_level, dev_list);
d265 1
a265 1
                "[-C flag[,flag,...]] [-c raidlevel]\n"
d453 3
a455 1
			if (human)
d698 1
a698 1
bio_createraid(u_int16_t level, char *dev_list)
d703 3
a705 2
	int			rv, no_dev;
	dev_t			*dt;
d752 3
a755 1
	if (level == 'C') {
d759 2
a773 2
			/* no auto assembling */
			create.bc_flags |= BIOC_SCNOAUTOASSEMBLE;
d779 18
d845 1
a845 1
	kdfinfo->flags = (SR_CRYPTOKDF_KEY | SR_CRYPTOKDF_HINT);
@


1.86
log
@put -P in the right place;
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.85 2009/11/24 02:19:35 jsing Exp $       */
d616 1
a616 1
	/* if the blink didnt work, try to find something that will */
@


1.85
log
@Allow the passphrase to be changed on softraid crypto volumes. Ensure that
you backup your data and lock up your pets prior to using this.

Tested by todd@@

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.83 2009/10/22 15:27:15 jmc Exp $       */
d260 1
a260 1
                "       %s [-Pdhiqv] "
@


1.84
log
@Somehow during my testing I missed a test case where an existing crypto
volume could no longer be brought up.
Found by Pedro la Peu <pedro@@am-gen.org>, thanks for the report.
@
text
@d68 1
a68 1
			    struct sr_crypto_kdf_pbkdf2 *);
d71 1
a71 1
			    size_t, int);
d81 1
d105 2
a106 1
	int			ch, rv, blink = 0, diskinq = 0, ss_func = 0;
d112 2
a113 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hil:p:qr:R:vu:")) != -1) {
d158 4
d191 1
a191 1
	if (argc != 1)
d223 2
d260 1
a260 1
                "       %s [-dhiqv] "
d759 1
a759 1
			bio_kdf_derive(&kdfinfo, &kdfhint);
d786 1
a786 1
    *kdfhint)
d805 1
a805 1
	    kdfhint->salt, sizeof(kdfhint->salt), 0);
d825 2
a826 1
	    kdfinfo->pbkdf2.salt, sizeof(kdfinfo->pbkdf2.salt), 1);
d917 52
d1001 1
a1001 1
    size_t saltsz, int verify)
d1006 1
a1006 1
	char		 passphrase[1024], verifybuf[1024];
d1040 2
a1041 2
		if (readpassphrase("Passphrase: ", passphrase,
		    sizeof(passphrase), RPP_REQUIRE_TTY) == NULL)
@


1.83
log
@tweak previous; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.82 2009/10/21 22:31:17 marco Exp $       */
d954 4
a957 1
	if (password && verify == 0) {
d977 1
a977 1
	} else if (password == NULL && verify) {
d981 1
a981 3
	} else
		errx(1, "can't specify passphrase file during initial "
		    "creation of crypto volume");
@


1.82
log
@Add passphrase file for crypto volume bring-up.  Proded and ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.81 2009/07/31 16:12:10 jsing Exp $       */
d253 2
a254 3
                "\t[-l special[,special,...]] "
                "[-R device | channel:target[.lun]\n"
		"\t[-p passfile] [-r rounds] "
@


1.81
log
@Allow hotspares to be added to bio devices rather than requiring an sd
device.

"Yeah!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.79 2009/06/17 22:50:58 marco Exp $       */
d39 2
d90 1
d110 1
a110 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hil:qr:R:vu:")) != -1) {
d155 3
d212 1
a212 1
		errx(1, "need -d or -f parameter");
d255 1
a255 1
                "\t[-r rounds] "
d942 3
d955 27
a981 3
	if (readpassphrase("Passphrase: ", passphrase, sizeof(passphrase),
	    RPP_REQUIRE_TTY) == NULL)
		errx(1, "unable to read passphrase");
@


1.80
log
@fix crypto raid error message

ok marco@@
@
text
@d565 6
a570 4
	/* make sure user supplied a sd device */
	bs.bs_volid = bio_getvolbyname(devicename);
	if (bs.bs_volid == -1)
		errx(1, "invalid device %s", devicename);
@


1.79
log
@Add raid 4 & 5 in create

ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.78 2009/02/22 07:46:55 jmc Exp $       */
d721 1
a721 2
		errx(1, "not exactly one disks");
		
@


1.78
log
@split synopsis and the options list according to functionality;
diff from Mitja Mu?eni?

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.77 2008/09/02 23:05:12 dtucker Exp $       */
d701 4
@


1.77
log
@devname -> devicename to prevent shadowing devname(3); ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.76 2008/08/22 06:41:36 jmc Exp $       */
d239 1
a239 1
		"usage: %s [-dhiqv] [-a alarm-function] "
d241 10
a250 6
		"\t[-C flag[,flag,...]] [-c raidlevel] "
		"[-H channel:target[.lun]]\n"
		"\t[-l special[,special,...]] "
		"[-R device|channel:target[.lun]\n"
		"\t[-r rounds] [-u channel:target[.lun]] "
		"device\n", __progname);
@


1.76
log
@- -R before -r in SYNOPSIS/usage()
- avoid marking up `|'
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.75 2008/08/22 02:00:12 marco Exp $       */
d535 1
a535 1
bio_setstate(char *arg, int status, char *devname)
d562 1
a562 1
	bs.bs_volid = bio_getvolbyname(devname);
d564 1
a564 1
		errx(1, "invalid device %s", devname);
@


1.75
log
@Add a hack to manually kick off rebuilds.  This will need some love in the
near future.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.74 2008/08/11 17:28:24 marco Exp $       */
d243 1
a243 1
		"\t[-l special[,special,...]] [-r rounds] "
d245 1
a245 1
		"\t[-u channel:target[.lun]] "
@


1.74
log
@Undo last commit; deraadt didn't like it.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.73 2008/08/11 17:22:54 marco Exp $       */
d73 2
a74 1
void			bio_setstate(char *);
d101 1
a101 1
	int			ch, rv, blink = 0, diskinq = 0;
d107 1
a107 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hil:qr:vu:")) != -1) {
d139 1
d158 6
d217 1
a217 1
		bio_setstate(al_arg);
d244 3
a246 2
		"[-u channel:target[.lun]]\n"
		"\tdevice\n", __progname);
d504 30
d535 1
a535 1
bio_setstate(char *arg)
d539 1
d543 14
a556 3
	errstr = str2locator(arg, &location);
	if (errstr)
		errx(1, "Target %s: %s", arg, errstr);
d559 6
a564 4
	bs.bs_status = BIOC_SSHOTSPARE;
	bs.bs_channel = location.channel;
	bs.bs_target = location.target;
	bs.bs_lun = location.lun;
d887 1
@


1.73
log
@Add infrastructure to manually kick off rebuilds.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.72 2008/07/02 22:08:02 todd Exp $       */
d73 1
a73 2
int			bio_getvolbyname(char *);
void			bio_setstate(char *, int, char *);
d100 1
a100 1
	int			ch, rv, blink = 0, diskinq = 0, ss_func = 0;
d106 1
a106 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hil:qr:R:vu:")) != -1) {
a137 1
			ss_func = BIOC_SSHOTSPARE;
a155 6
		case 'R':
			/* rebuild to provided chunk/CTL */
			func |= BIOC_SETSTATE;
			ss_func = BIOC_SSREBUILD;
			al_arg = optarg;
			break;
d209 1
a209 1
		bio_setstate(al_arg, ss_func, argv[0]);
d236 2
a237 3
		"[-R device|channel:target[.lun]\n"
		"\t[-u channel:target[.lun]] "
		"device\n", __progname);
a494 30
int
bio_getvolbyname(char *name)
{
	int			id = -1, i, rv;
	struct bioc_inq		bi;
	struct bioc_vol		bv;

	memset(&bi, 0, sizeof(bi));
	bi.bi_cookie = bl.bl_cookie;
	rv = ioctl(devh, BIOCINQ, &bi);
	if (rv == -1)
		err(1, "BIOCINQ");

	for (i = 0; i < bi.bi_novol; i++) {
		memset(&bv, 0, sizeof(bv));
		bv.bv_cookie = bl.bl_cookie;
		bv.bv_volid = i;
		rv = ioctl(devh, BIOCVOL, &bv);
		if (rv == -1)
			err(1, "BIOCVOL");

		if (name && strcmp(name, bv.bv_dev) != 0)
			continue;
		id = i;
		break;
	}

	return (id);
}

d496 1
a496 1
bio_setstate(char *arg, int status, char *devname)
a499 1
	struct stat		sb;
d503 3
a505 14
	memset(&bs, 0, sizeof(bs));
	if (stat(arg, &sb) == -1) {
		/* use CTL */
		errstr = str2locator(arg, &location);
		if (errstr)
			errx(1, "Target %s: %s", arg, errstr);
		bs.bs_channel = location.channel;
		bs.bs_target = location.target;
		bs.bs_lun = location.lun;
	} else {
		/* use other id */
		bs.bs_other_id = sb.st_rdev;
		bs.bs_other_id_type = BIOC_SSOTHER_DEVT;
	}
d508 4
a511 6
	bs.bs_status = status;

	/* make sure user supplied a sd device */
	bs.bs_volid = bio_getvolbyname(devname);
	if (bs.bs_volid == -1)
		errx(1, "invalid device %s", devname);
a833 1
	/* XXX make this a dev_t instead of a string */
@


1.72
log
@string munging: say 'CRYPTO' not 'RAID67'
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.71 2008/06/15 18:52:58 jmc Exp $       */
d73 2
a74 1
void			bio_setstate(char *);
d101 1
a101 1
	int			ch, rv, blink = 0, diskinq = 0;
d107 1
a107 1
	while ((ch = getopt(argc, argv, "a:b:C:c:dH:hil:qr:vu:")) != -1) {
d139 1
d158 6
d217 1
a217 1
		bio_setstate(al_arg);
d244 3
a246 2
		"[-u channel:target[.lun]]\n"
		"\tdevice\n", __progname);
d504 30
d535 1
a535 1
bio_setstate(char *arg)
d539 1
d543 14
a556 3
	errstr = str2locator(arg, &location);
	if (errstr)
		errx(1, "Target %s: %s", arg, errstr);
d559 6
a564 4
	bs.bs_status = BIOC_SSHOTSPARE;
	bs.bs_channel = location.channel;
	bs.bs_target = location.target;
	bs.bs_lun = location.lun;
d887 1
@


1.71
log
@fix usage();
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.70 2008/06/15 00:43:23 hshoexer Exp $       */
d364 13
a376 3
			printf("%7s %-10s %14s %-7s RAID%u%s%s\n",
			    volname, status, size, bv.bv_dev,
			    bv.bv_level, percent, seconds);
@


1.70
log
@When generating a new volume, ask the user to re-type the passphrase for
verification.

ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.69 2008/06/14 18:40:50 hshoexer Exp $       */
d235 3
a237 2
		"\t[-l special[,special,...]] "
		"[-u channel:target[.lun]] [-d] device\n", __progname);
@


1.69
log
@Provide a status field for operations on the bc_opaque data.  Now we're
able to distinguish cleanly an failing ioctl (ie. return value -1) from
trying to retrieve a KDF hint from a not yet initialized volume.

ok marco djm
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.68 2008/06/14 17:04:50 djm Exp $       */
d51 1
d68 2
a69 2
void			get_pkcs_key(int, u_int8_t *, size_t, u_int8_t *,
			    size_t);
d716 1
a716 1
	get_pkcs_key(kdfhint->rounds,
d718 1
a718 1
	    kdfhint->salt, sizeof(kdfhint->salt));
d736 1
a736 1
	get_pkcs_key(kdfinfo->pbkdf2.rounds,
d738 1
a738 1
	    kdfinfo->pbkdf2.salt, sizeof(kdfinfo->pbkdf2.salt));
d859 2
a860 2
get_pkcs_key(int rounds, u_int8_t *key, size_t keysz, u_int8_t *salt,
    size_t saltsz)
d862 1
a862 1
	char		*passphrase;
d872 20
a891 3
	passphrase = getpass("Passphrase: ");
	if (!passphrase || strlen(passphrase) == 0)
		errx(1, "Need a passphrase");
d899 1
a899 1
	memset(passphrase, 0, strlen(passphrase));
@


1.68
log
@add a -r option to specify the number of PKCS5 PBKDF2 iterations used
to derive the password (minimum: 1000, maximum: more than you want)
ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.67 2008/06/14 06:28:27 djm Exp $       */
d667 4
a670 1
		if ((rv = ioctl(devh, BIOCCREATERAID, &create)) == 0) {
d673 1
a673 2
		} else {
			/* XXX this will kill the keys in case of an error */
d686 1
@


1.67
log
@Replace PBKDF2 implementation pulled in from vnconfig with one
derived from Damien Bergamini's wpa-psk. This implementation is
smaller, cleaner and uses the libc SHA1 functions instead of
pulling in OpenSSL.

make bioctl.c -Wall clean too

Verified with rfc3962 test vectors and against a assembled cryptoraid;
ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.66 2008/06/14 00:05:47 djm Exp $       */
d85 1
d98 1
d105 1
a105 1
	while ((ch = getopt(argc, argv, "b:C:c:dl:u:H:ha:ivq")) != -1) {
d149 6
d725 1
a725 1
	kdfinfo->pbkdf2.rounds = 10000;
@


1.66
log
@friendly error message when key decryption fails; ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.65 2008/06/13 21:03:40 hshoexer Exp $       */
d52 1
a52 1
#include "pkcs5_pbkdf2.h"
d736 1
a736 1
	char			devname[MAXPATHLEN];
d749 3
a751 3
			strlcpy(devname, s, sz + 1);
			if (stat(devname, &sb) == -1)
				err(1, "could not stat %s", devname);
d754 1
a754 1
			if (no_dev > (BIOC_CRMAXLEN / sizeof(dev_t)))
a849 1
	u_int8_t	*keybuf;
d865 3
a867 7
	if (pkcs5_pbkdf2(&keybuf, keysz, passphrase, strlen(passphrase), salt,
	    saltsz, rounds, 0))
		errx(1, "pkcs5_pbkdf2 failed");

	memcpy(key, keybuf, keysz);
	memset(keybuf, 0, keysz);
	free(keybuf);
@


1.65
log
@Implement pbkdf2 in in bioctl to derive master key from a passphrase.

ok marco djm
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.64 2008/06/12 16:08:48 jmc Exp $       */
d676 3
a678 1
	if (rv == -1)
d680 1
@


1.64
log
@-d tweaks;
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.63 2008/06/12 00:19:15 marco Exp $       */
d38 1
d52 2
d64 5
d602 2
d626 1
a626 1
		min_disks = 2;
d638 5
d650 24
d675 1
d682 44
d841 34
@


1.63
log
@Add delete volume functionality.

discussed with krw, kettenis & drahn
ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.62 2008/01/19 23:53:53 marco Exp $       */
d214 1
a214 1
		"usage: %s [-hiqv] [-a alarm-function] "
@


1.62
log
@Add initial scaffold for RAID 0.  No IO just yet.

Much prodding todd
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.61 2007/09/08 07:21:29 henning Exp $       */
d68 1
d95 1
a95 1
	while ((ch = getopt(argc, argv, "b:C:c:l:u:H:ha:ivq")) != -1) {
d116 4
d193 2
d219 1
a219 1
		"[-u channel:target[.lun]] device\n", __progname);
d715 12
@


1.61
log
@make bioctl behave like a unix program and exit 1 on error
ok deraadt, silence dlg marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.60 2007/07/11 07:40:11 jmc Exp $       */
d603 1
a603 1
		min_disks = 1;
d608 3
d617 3
@


1.60
log
@put -q in the right place;
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.59 2007/07/10 15:46:54 henning Exp $       */
d267 1
a267 1
			warn("BIOCINQ");
d280 2
a281 4
		if (rv == -1) {
			warn("BIOCVOL");
			return;
		}
d351 2
a352 4
			if (rv == -1) {
				warn("BIOCDISK");
				return;
			}
d446 1
a446 2
		warnx("invalid alarm function: %s", arg);
		return;
d450 2
a451 4
	if (rv == -1) {
		warn("BIOCALARM");
		return;
	}
d479 2
a480 4
	if (rv == -1) {
		warn("BIOCSETSTATE");
		return;
	}
d513 2
a514 4
	if (rv == -1) {
		warn("BIOCINQ");
		return;
	}
d521 2
a522 4
		if (rv == -1) {
			warn("BIOCVOL");
			return;
		}
d534 2
a535 4
			if (rv == -1) {
				warn("BIOCDISK");
				return;
			}
d578 1
a578 1
		warn("BIOCBLINK");
d623 2
a624 4
	if (rv == -1) {
		warn("BIOCCREATERAID");
		goto done;
	}
a625 1
done:
d727 2
a728 4
	if (ioctl(devh, DIOCINQ, &di) == -1) {
		warn("DIOCINQ");
		return;
	}
@


1.59
log
@implement -q to query a scsi disk for its inquiry data (vendor, model,
revision, serial #) and print that.
when the default bio ioctl fails with ENOTTY because the given disk is not
on a bio-supported raid controller, fall back to -q.
use strnvis to sanitize inquiry data so it is safe to use in scripts.
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.58 2007/06/04 05:28:43 todd Exp $       */
d207 1
a207 1
		"usage: %s [-hivq] [-a alarm-function] "
@


1.58
log
@document -C option of bioctl
use a simpler form of options with variable number of args
suggestions jmc@@ ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.57 2007/06/01 00:00:54 tedu Exp $       */
d49 1
d69 2
d88 1
a88 1
	int			ch, rv, blink = 0;
d94 1
a94 1
	while ((ch = getopt(argc, argv, "b:C:c:l:u:H:ha:iv")) != -1) {
d137 3
d178 3
a180 1
	if (func & BIOC_INQ) {
d207 1
a207 1
		"usage: %s [-hiv] [-a alarm-function] "
d264 4
a267 1
		warn("BIOCINQ");
d720 32
@


1.57
log
@support for softraid level 'c'.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.56 2007/05/31 04:23:23 grunk Exp $       */
d201 3
a203 2
		"\t[-c raidlevel] [-H channel:target[.lun]]\n"
		"\t[-l special[,special[,...]]] "
@


1.56
log
@typo, ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.55 2007/05/28 21:54:26 marco Exp $       */
d107 4
a110 1
			cr_level = atoi(optarg);
d610 3
@


1.55
log
@Make disk assembly smarter and add two qualifiers to it:
1) noautoassemble; when set the softraid volume will not be assembled during
   autoconf.
2) force; when set it will overwrite metadata on disk

While writing this I ran into 3 bugs that were fixed along the way
1) bcopy in sr_read_meta was copying data to the wrong pointer
2) in sr_read_meta the wrong metadata was coppied into the chunk
3) sr_free_discipline was freing a pointer that wasn't malloc'd

ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.54 2007/05/23 21:27:13 marco Exp $       */
d609 1
a609 1
		errx(1, "unsuported raid level");
@


1.54
log
@Remove all vnode dependencies so that we can bootstrap softraid volumes.
Code from tedu.

Replace all kernel string magic with dev_t passed in from bioctl.
Suggestion from beck and tedu.  Help from miod.

Fix chunk crc.

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.53 2007/04/23 16:38:55 deraadt Exp $       */
d67 1
d72 1
d91 1
a91 1
	while ((ch = getopt(argc, argv, "b:c:l:u:H:ha:iv")) != -1) {
d102 3
d617 1
a617 1
	create.bc_flags = BIOC_SCDEVT;
a618 1
	printf("ioctl\n");
d666 36
@


1.53
log
@remove -D stuff which is just silly, imagine if ls had a debug mode; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.52 2007/03/20 15:26:06 jmc Exp $       */
d33 2
d51 3
a53 3
	int channel;
	int target;
	int lun;
d56 15
a70 14
void usage(void);
const char *str2locator(const char *, struct locator *);
void cleanup(void);

void bio_inq(char *);
void bio_alarm(char *);
void bio_setstate(char *);
void bio_setblink(char *, char *, int);
void bio_blink(char *, int, int);
void bio_createraid(u_int16_t, char *);

int devh = -1;
int human;
int verbose;
d72 1
a72 1
struct bio_locate bl;
d77 2
a78 2
	extern char *optarg;
	u_int64_t func = 0;
d80 5
a84 5
	char *bioc_dev = NULL, *sd_dev = NULL;
	char *realname = NULL, *al_arg = NULL;
	char *bl_arg = NULL, *dev_list = NULL;
	int ch, rv, blink = 0;
	u_int16_t cr_level = 0;
d188 1
a188 1
	extern char *__progname;
d203 2
a204 2
	const char *errstr;
	char parse[80], *targ, *lun;
d233 7
a239 7
	char *status, size[64], scsiname[16], volname[32];
	char percent[10], seconds[20];
	int rv, i, d, volheader, hotspare, unused;
	char encname[16], serial[32];
	struct bioc_disk bd;
	struct bioc_inq bi;
	struct bioc_vol bv;
d401 2
a402 2
	int rv;
	struct bioc_alarm ba;
d582 2
a583 1
	int			rv;
d589 7
a606 10
	/* XXX validate device list for real */
#if 0
	if (strncmp(dev_list, "sd", 2) == 0 && strlen(dev_list) > 2 &&
	    isdigit(dev_list[2])) {
	    	if (strlen(dev_list) != 3)
			errx(1, "only one device supported");
	} else
		errx(1, "no sd device specified");
#endif

d610 3
a612 2
	create.bc_dev_list_len = strlen(dev_list);
	create.bc_dev_list = dev_list;
d614 1
d618 36
a653 1
		return;
d655 7
@


1.52
log
@further clean usage(); ok todd
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.51 2007/03/20 06:29:02 jmc Exp $       */
a65 1
int debug;
d80 2
a81 2
	int ch, rv, blink;
	u_int16_t cr_level;
d86 1
a86 1
	while ((ch = getopt(argc, argv, "b:c:l:u:H:ha:Div")) != -1) {
a105 3
		case 'D': /* debug */
			debug = 1;
			break;
a160 3
	if (debug)
		warnx("cookie = %p", bl.bl_cookie);

d188 1
a188 1
		"usage: %s [-Dhiv] [-a alarm-function] "
a239 3
	if (debug)
		printf("bio_inq\n");

a247 7
	if (debug)
		printf("bio_inq { %p, %s, %d, %d }\n",
		    bi.bi_cookie,
		    bi.bi_dev,
		    bi.bi_novol,
		    bi.bi_nodisk);

d306 2
a312 3
			unused = 0;
			hotspare = 0;

a577 1
	struct bio_locate	bio;
a581 3
	if (debug)
		printf("bio_createraid\n");

d602 1
a602 5

		if (debug)
			printf("bio_createraid: dev_list: %s\n", dev_list);
	}
	else
@


1.51
log
@sync usage() w/ synopsis;
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.50 2007/03/20 03:40:38 todd Exp $       */
d194 7
a200 5
	fprintf(stderr, "usage: %s [-Dhiv] [-a alarm-function] "
	    "[-b channel:target[.lun]]\n", __progname);
	fprintf(stderr, "\t[-c raidlevel] [-H channel:target[.lun]]\n");
	fprintf(stderr, "\t[-l special[,special[,...]]] "
	    "[-u channel:target[.lun]] device\n");
@


1.50
log
@document softraid and bioctl creation of softraid
ok marco@@, help from jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.49 2007/03/19 03:02:09 marco Exp $       */
d194 4
a197 4
	fprintf(stderr, "usage: %s\t[-Dhiv] [-a alarm-function]"
	    " [-b channel:target[.lun]] device\n", __progname);
	fprintf(stderr, "\t\t[[-c raidlevel] [-H channel:target[.lun]]\n");
	fprintf(stderr, "\t\t[-l special[,special[,...]]] "
@


1.49
log
@Add a new device that provides a framework for IO manipulation.  A very basic
implementation of a RAID 1 is included in this but it does not deal with
failures yet.  Disabled in GENERIC.

Suggestions from and ok beck@@ miod@@ krw@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.48 2006/08/28 12:36:08 mickey Exp $       */
d194 5
a198 2
	fprintf(stderr, "usage: %s [-Dhiv] [-a alarm-function]"
	    " [[-bHu] chan:targ[.lun]] device\n", __progname);
@


1.48
log
@proper justify the size caption to match numbers justification; deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.47 2006/08/28 02:12:59 deraadt Exp $       */
d63 1
d80 1
a80 1
	char *bl_arg = NULL;
d82 1
d87 1
a87 1
	while ((ch = getopt(argc, argv, "b:u:H:ha:Div")) != -1) {
d98 4
d120 4
d176 8
d586 52
@


1.47
log
@Except I disagree strongly, and I was not asked
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.45 2006/05/26 00:38:30 marco Exp $       */
d261 1
a261 1
			printf("%-7s %-10s %-14s %-8s\n",
@


1.46
log
@proper justify the size caption to match numbers justification; krw@@ ok
@
text
@d261 1
a261 1
			printf("%-7s %-10s %14s %-8s\n",
@


1.45
log
@Assign locator.target to blink structure.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.44 2006/05/25 22:26:03 deraadt Exp $       */
d261 1
a261 1
			printf("%-7s %-10s %-14s %-8s\n",
@


1.44
log
@handle Online/Scrub SD state for marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.43 2006/05/25 04:28:26 deraadt Exp $       */
d484 1
@


1.43
log
@more room for seconds string
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.42 2006/05/25 03:39:12 deraadt Exp $       */
d348 3
@


1.42
log
@print seconds of progress, if driver makes it available; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.41 2006/05/25 03:12:50 deraadt Exp $       */
d215 1
a215 1
	char percent[10], seconds[10];
@


1.41
log
@handle new volume status, and print % if known; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.40 2006/05/07 23:57:23 marco Exp $       */
d214 2
a215 1
	char *status, size[64], scsiname[16], volname[32], percent[10];
d248 1
d266 1
d270 3
d313 1
a313 1
			printf("%7s %-10s %14s %-7s RAID%u%s\n",
d315 1
a315 1
			    bv.bv_level, percent);
@


1.40
log
@Add a little debug to test BIOCINQ primitive.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.39 2005/08/23 23:20:23 deraadt Exp $       */
d214 1
a214 1
	char *status, size[64], scsiname[16], volname[32];
d246 1
d263 4
d277 9
d307 3
a309 2
			printf("%7s %-10s %14s %-7s RAID%u\n",
			    volname, status, size, bv.bv_dev, bv.bv_level);
@


1.39
log
@disable -B support for now; ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.38 2005/08/23 03:59:32 deraadt Exp $       */
d233 7
@


1.38
log
@repair warnx() misuses
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.37 2005/08/21 23:37:24 dlg Exp $       */
d85 1
a85 1
	while ((ch = getopt(argc, argv, "b:B:u:H:ha:Div")) != -1) {
a95 5
		case 'B': /* alarm blink */
			func |= BIOC_BLINK;
			blink = BIOC_SBALARM;
			bl_arg = optarg;
			break;
d177 1
a177 1
	    " [[-bBHu] chan:targ[.lun]] device\n", __progname);
@


1.37
log
@try to blink the device given on the command line before walking inquiries
on the device looking for an enclosure. this allows bioctl -b 0:0 ses0 to
work as well as bioctl -b 0:0 sd0/ami0.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.36 2005/08/18 22:14:27 deraadt Exp $       */
d235 1
a235 1
		warnx("bioc_ioctl(BIOCINQ) call failed");
d247 1
a247 1
			warnx("bioc_ioctl(BIOCVOL) call failed");
d303 1
a303 1
				warnx("bioc_ioctl(BIOCDISK) call failed");
d402 1
a402 1
		warnx("bioc_ioctl(ALARM) call failed");
d433 1
a433 1
		warnx("bioc_ioctl(BIOCSETSTATE) call failed");
d468 1
a468 1
		warn("bio ioctl(BIOCINQ) call failed");
d478 1
a478 1
			warn("bio ioctl(BIOCVOL) call failed");
d493 1
a493 1
				warn("bio ioctl(BIOCDISK) call failed");
d538 1
a538 1
		warn("bio ioctl(BIOCBLINK) call failed");
@


1.36
log
@add support to stop blinking (-u) or use the alarm LED instead (-B)
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.35 2005/08/18 15:00:37 deraadt Exp $       */
d445 1
d452 11
@


1.35
log
@better diagnostics in case of bad arguments; ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.34 2005/08/18 14:40:37 dlg Exp $       */
d61 2
a62 2
void bio_setblink(char *, char *);
void bio_blink(char *, int);
d80 1
a80 1
	int ch, rv;
d85 1
a85 1
	while ((ch = getopt(argc, argv, "b:H:ha:Div")) != -1) {
d93 11
d168 1
a168 1
		bio_setblink(sd_dev, bl_arg);
d182 1
a182 1
	    " [[-bH] chan:targ[.lun]] device\n", __progname);
d439 1
a439 1
bio_setblink(char *name, char *arg)
d490 1
a490 1
					    location.target);
d503 1
a503 1
bio_blink(char *enclosure, int target)
d521 1
a521 1
	blink.bb_status = BIOC_SBBLINK;
@


1.34
log
@rework the addressing for blinking to make it like the hotspares

help from and ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.33 2005/08/18 12:53:22 deraadt Exp $       */
d55 1
a55 1
int str2locator(const char *, struct locator *);
a63 3
/* globals */
const char *bio_device = "/dev/bio";

d133 1
a133 1
		devh = open(bio_device, O_RDWR);
d135 1
a135 1
			err(1, "Can't open %s", bio_device);
d141 1
a141 1
			    bl.bl_name, bio_device);
d175 1
a175 1
int
d179 1
a179 1
	char *targ, *lun;
d181 2
a182 1
	targ = strchr(string, ':');
d184 1
a184 2
		return (-1);

d192 1
a192 1
			return (-1);
d198 2
a199 3
		return (-1);

	location->channel = strtonum(string, 0, 256, &errstr);
d201 2
a202 3
		return (-1);

	return (0);
d405 4
a408 3
	struct bioc_setstate bs;
	struct locator location;
	int rv;
d410 3
a412 2
	if (str2locator(arg, &location) != 0)
		errx(1, "invalid channel:target[.lun]");
d430 6
a435 5
	struct locator			location;
	struct bioc_inq			bi;
	struct bioc_vol			bv;
	struct bioc_disk		bd;
	int				v, d, rv;
d437 3
a439 2
	if (str2locator(arg, &location) != 0)
		errx(1, "invalid channel:target[.lun]");
d481 1
a481 1
					warnx("Disk is not in an enclosure");
d487 1
a487 1
	warnx("Disk does not exist");
d499 1
a499 1
	bioh = open(bio_device, O_RDWR);
d501 1
a501 1
		err(1, "Can't open %s", bio_device);
d506 1
a506 1
		errx(1, "Can't locate %s device via %s", enclosure, bio_device);
@


1.33
log
@a step towards where dlg is heading next + knf
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.32 2005/08/18 12:19:08 dlg Exp $       */
a47 3
#define CT_SEP	':'
#define TL_SEP	'.'

d61 2
a62 1
void bio_blink(char *);
d160 1
a160 1
		bio_blink(bl_arg);
d181 1
d184 1
a184 1
	targ = strchr(string, CT_SEP);
d190 1
a190 1
	lun = strchr(targ, TL_SEP);
d193 2
a194 2
		location->lun = strtonum(lun, 0, 256, NULL);
		if (errno)
d199 2
a200 2
	location->target = strtonum(targ, 0, 256, NULL);
	if (errno)
d203 2
a204 2
	location->channel = strtonum(string, 0, 256, NULL);
	if (errno)
d431 1
a431 1
bio_blink(char *arg)
d433 70
a502 3
	struct bioc_blink blink;
	const char *errstr;
	int target, rv;
d504 4
a507 3
	target = strtonum(arg, 0, 255, &errstr);
	if (errstr != NULL)
		errx(1, "target is %s", errstr);
d510 1
a510 1
	blink.bb_cookie = bl.bl_cookie;
d514 1
a514 1
	rv = ioctl(devh, BIOCBLINK, &blink);
d516 3
a518 1
		err(1, "blink unable to be set");
@


1.32
log
@very basic blink support.

some manpage tweaks from jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.31 2005/08/18 04:49:52 marco Exp $       */
d175 2
a176 2
	fprintf(stderr, "usage: %s [-Dhiv] [-a alarm-function] [-b targ]"
	    " [-H chan:targ[.lun]] device\n", __progname);
d194 1
a194 1
		location->lun = strtonum(lun, 0, 256 /* XXX */, NULL);
d200 1
a200 1
	location->target = strtonum(targ, 0, 256 /* XXX */, NULL);
d203 2
a204 2
	
	location->channel = strtonum(string, 0, 256 /* XXX */, NULL);
d254 1
a254 1
		
d408 2
a409 1
void bio_setstate(char *arg)
a410 1
	int rv;
d413 1
a416 1
	
d435 1
a436 1
	const char *errstr;
@


1.31
log
@Add "create hot spare" ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.30 2005/08/17 06:31:01 marco Exp $       */
d64 1
d84 1
d90 1
a90 1
	while ((ch = getopt(argc, argv, "H:ha:Div")) != -1) {
d96 4
d161 2
d175 2
a176 3
	fprintf(stderr,
	    "usage: %s [-Dhiv] [-a alarm-function] [-H channel:target[.lun]] "
	        "device\n", __progname);
d429 21
@


1.30
log
@Add support for unused disks.
Fix SCSI string madness (by deraadt).
Add some debug statements in bioctl.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.29 2005/08/15 23:13:24 deraadt Exp $       */
d48 9
d58 1
d63 1
d88 1
a88 1
	while ((ch = getopt(argc, argv, "ha:Div")) != -1) {
d97 4
d155 2
d168 2
a169 1
	    "usage: %s [-Dhiv] [-a alarm-function] device\n", __progname);
d173 31
d390 1
a390 1
		warnx("bioc_ioctl() call failed");
d398 23
@


1.29
log
@if bv_level is -1, it is a hot spare; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.28 2005/08/09 03:08:27 deraadt Exp $       */
d159 1
a159 1
	int rv, i, d, volheader, hotspare;
d174 1
a174 1
		warnx("bioc_ioctl() call failed");
d186 1
a186 1
			warnx("bioc_ioctl() call failed");
d216 1
d219 2
d222 1
d242 1
a242 1
				warnx("bioc_ioctl() call failed");
d270 1
a270 1
			if (hotspare)
@


1.28
log
@align a column
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.27 2005/08/09 01:43:33 deraadt Exp $       */
d158 3
a160 2
	char *status, size[64], scsiname[16], encname[16], serial[32];
	int rv, i, d, volheader;
d214 1
a214 1
		snprintf(scsiname, sizeof scsiname, "%s %u",
d216 13
a228 7
		if (human)
			fmt_scaled(bv.bv_size, size);
		else
			snprintf(size, sizeof size, "%14llu",
			    bv.bv_size);
		printf("%7s %-10s %14s %-7s RAID%u\n",
		    scsiname, status, size, bv.bv_dev, bv.bv_level);
d265 7
d289 2
a290 2
			printf("    %3u %-10s %14s %-7s %-6s <%s>\n",
			    bd.bd_diskid, status, size, scsiname, encname,
d293 1
a293 1
				printf("    %3s %-10s %14s %-7s %-6s '%s'\n",
a296 1
	/* printf("where are my spares?\n"); */
@


1.27
log
@verbose output option
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.26 2005/08/08 20:26:21 deraadt Exp $       */
d220 1
a220 1
		printf("%7s %-10s %14s %-8s RAID%u\n",
@


1.26
log
@print information about ses/safte for each device; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.25 2005/08/08 18:57:16 deraadt Exp $       */
d58 3
a60 2
int debug = 0;
int human = 0;
d77 1
a77 1
	while ((ch = getopt(argc, argv, "ha:Di")) != -1) {
d92 3
d151 1
a151 1
	    "usage: %s [-Dhi] [-a alarm-function] device\n", __progname);
d158 1
a158 1
	char *status, size[64], scsiname[16], encname[16];
d267 5
a271 2
				snprintf(encname, sizeof encname, "%s",
				    bd.bd_procdev);
d273 1
a273 2
				snprintf(encname, sizeof encname, "%s",
				    "noencl");
d278 3
@


1.25
log
@print out target as channel:target.lun
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.24 2005/08/08 04:04:13 deraadt Exp $       */
d262 6
a267 1
			snprintf(encname, sizeof encname, "ses#");
@


1.24
log
@lots of cleanup, print lots of information based on new linkages between
devices provided by marco; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.23 2005/08/05 02:40:36 deraadt Exp $       */
d259 3
a261 6
			if (bd.bd_lun)
				snprintf(scsiname, sizeof scsiname,
				    "scsi%u:%u", bd.bd_target, bd.bd_lun);
			else
				snprintf(scsiname, sizeof scsiname,
				    "scsi%u", bd.bd_target);
@


1.23
log
@sync usage to man page
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.22 2005/08/05 02:34:52 deraadt Exp $       */
d40 1
d48 5
a52 1
#include "bioctl.h"
d59 1
d76 1
a76 1
	while ((ch = getopt(argc, argv, "a:Di")) != -1) {
d85 3
d99 1
a99 1
	if (argc < 0 || argc > 1)
d117 1
a117 1
		bl.name = bioc_dev;
d121 1
a121 1
			    bl.name, bio_device);
d130 1
a130 1
		warnx("cookie = %p", bl.cookie);
d133 1
a133 1
		bio_inq();
d147 1
a147 1
	    "usage: %s [-Di] [-a alarm-function] device\n", __progname);
d152 1
a152 1
bio_inq(void)
d154 5
a158 4
	bioc_inq bi;
	bioc_vol bv;
	bioc_disk bd;
	int rv, i, d;
d165 1
a165 1
	bi.cookie = bl.cookie;
d173 2
a174 4
	printf("RAID volumes   : %d\n", bi.novol);
	printf("Physical disks : %d\n\n", bi.nodisk);

	for (i = 0; i < bi.novol; i++) {
d176 2
a177 2
		bv.cookie = bl.cookie;
		bv.volid = i;
d185 10
a194 3
		printf("\tvolume id: %d\n", bv.volid);
		printf("\tstatus   : ");
		switch (bv.status) {
d196 1
a196 1
			printf("%s\n", BIOC_SVONLINE_S);
a197 1

d199 1
a199 1
			printf("%s\n", BIOC_SVOFFLINE_S);
a200 1

d202 1
a202 1
			printf("%s\n", BIOC_SVDEGRADED_S);
a203 1

d206 1
a206 1
			printf("%s\n", BIOC_SVINVALID_S);
a207 3
		printf("\tsize     : %lld\n", bv.size);
		printf("\traid     : %d\n", bv.level);
		printf("\tnr disks : %d\n", bv.nodisk);
d209 11
a219 1
		for (d = 0; d < bv.nodisk; d++) {
d221 3
a223 3
			bd.cookie = bl.cookie;
			bd.diskid = d;
			bd.volid = i;
d231 1
a231 3
			printf("\t\tdisk id  : %d\n", bd.diskid);
			printf("\t\tstatus   : ");
			switch (bd.status) {
d233 1
a233 1
				printf("%s\n", BIOC_SDONLINE_S);
a234 1

d236 1
a236 1
				printf("%s\n", BIOC_SDOFFLINE_S);
a237 1

d239 1
a239 1
				printf("%s\n", BIOC_SDFAILED_S);
a240 1

d242 1
a242 1
				printf("%s\n", BIOC_SDREBUILD_S);
a243 1

d245 1
a245 1
				printf("%s\n", BIOC_SDHOTSPARE_S);
a246 1

d248 1
a248 1
				printf("%s\n", BIOC_SDUNUSED_S);
a249 1

d252 1
a252 1
				printf("%s\n", BIOC_SDINVALID_S);
d254 16
a269 3
			printf("\t\tvolume id: %d\n", bd.volid);
			printf("\t\tsize     : %lld\n", bd.size);
			printf("\t\tvendor   : %s\n", bd.vendor);
a270 1
		printf("\n");
d272 1
d279 1
a279 4
	bioc_alarm ba;

	if (debug)
		printf("alarm in: %s, ", arg);
d281 1
a281 1
	ba.cookie = bl.cookie;
d287 1
a287 3
		if (debug)
			printf("silence\n");
		ba.opcode = BIOC_SASILENCE;
d291 1
a291 3
		if (debug)
			printf("enable\n");
		ba.opcode = BIOC_SAENABLE;
d295 1
a295 3
		if (debug)
			printf("disable\n");
		ba.opcode = BIOC_SADISABLE;
d299 1
a299 3
		if (debug)
			printf("test\n");
		ba.opcode = BIOC_SATEST;
d303 1
a303 3
		if (debug)
			printf("get state\n");
		ba.opcode = BIOC_GASTATUS;
d319 2
a320 1
		    ba.status ? "enabled" : "disabled");
@


1.22
log
@if no command specified, assume -i
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.21 2005/08/03 16:12:53 marco Exp $       */
d138 1
a138 1
	    "usage: %s [-Di] [-a function] device\n", __progname);
@


1.21
log
@Fix usage.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.20 2005/08/03 03:01:31 deraadt Exp $       */
d92 3
@


1.20
log
@be more sure about what is a drive vs controller; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.19 2005/08/03 02:39:55 deraadt Exp $       */
d135 1
a135 1
	    "usage: %s [-Di] [-a function] [device | drive]\n", __progname);
@


1.19
log
@various cleanups, the way i like it, ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.18 2005/08/02 20:27:13 jmc Exp $       */
d44 1
d93 3
a95 1
	if (strncmp(argv[0], "sd", 2) == 0)
@


1.18
log
@add -a properly to SYNOPSIS; sync usage();
ok marco@@
@
text
@d1 2
a2 1
/* $OpenBSD: bioctl.c,v 1.17 2005/08/01 16:39:22 marco Exp $       */
a59 1

d62 3
a64 8

	int ch;
	int rv;

	char *bioc_dev = NULL;
	char *sd_dev = NULL;
	char *realname = NULL;
	char *al_arg = NULL; /* argument to alarm */
d69 1
a69 3
	atexit(cleanup);

	while ((ch = getopt(argc, argv, "a:Dd:f:hi")) != -1) {
a74 1

a77 9

		case 'd': /* bio device */
			bioc_dev = optarg;
			break;

		case 'f': /* scsi device */
			sd_dev = optarg;
			break;

a80 3

		case 'h': /* help/usage */
			/* FALLTHROUGH */
d86 5
d92 4
a95 2
	if (sd_dev && bioc_dev)
		err(1, "-d and -f are mutually exclusive");
d108 1
a108 1
	        devh = opendev(sd_dev, O_RDWR, OPENDEV_PART, &realname);
d131 2
a132 2
	fprintf(stderr, "usage: %s [-Dhi] [-a function] -d device | -f device\n", __progname);

a136 10
cleanup(void)
{
	if (debug)
		printf("atexit\n");

	if (devh != -1)
		close(devh);
}

void
a141 1

@


1.17
log
@Add alarm support.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.16 2005/07/29 16:01:18 marco Exp $       */
d144 1
a144 1
	fprintf(stderr, "usage: %s [-aDhi] [-d device | -f disk]\n", __progname);
@


1.16
log
@Redo bioctl because initial implementation was too complex.

tested and ok dlg@@ beck@@
get it in @@deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.13 2005/07/18 01:59:43 marco Exp $       */
d69 1
d76 1
a76 1
	while ((ch = getopt(argc, argv, "Dd:f:hi")) != -1) {
d78 5
d132 2
d144 1
a144 1
	fprintf(stderr, "usage: %s [-Dhi] [-d device | -f disk]\n", __progname);
d266 61
@


1.15
log
@revert marcos bio changes, mickey not ok
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.11 2005/07/01 21:53:40 marco Exp $       */
d29 7
d37 1
d41 1
a44 8
#include <sys/ioctl.h>
#include <sys/param.h>
#include <sys/queue.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsi_all.h>
#include <scsi/scsi_ses.h>
#include <dev/biovar.h>

a49 7
SLIST_HEAD(dev_list, dev);

/* RAID card device list */
struct dev_list devices = SLIST_HEAD_INITIALIZER(dev);
/* User provided device list*/
struct dev_list ul = SLIST_HEAD_INITIALIZER(dev);

d60 2
a61 2
	bioc_capabilities bc;
	bioc_alarm ba;
a64 1
	unsigned char *pl;
a68 8
	char *al_arg = NULL; /* argument to alarm */
	char *ss_arg = NULL; /* argument to start/stop */
	char inq[INQSIZE];

	struct dev *delm;

	u_int64_t func = 0, subfunc = 0;
	u_int32_t devlist = 0;
d75 1
a75 1
	while ((ch = getopt(argc, argv, "a:b:Dd:ef:hl:pst:u:")) != -1) {
d77 1
a77 10
		case 'a': /* alarm */
			func |= BIOC_ALARM;
			al_arg = optarg;
			break;
		case 'b': /* LED blink/unblink */
			func |= BIOC_BLINK;
			al_arg = optarg;
			break;

		case 'D': /* enable debug */
d81 1
a81 1
		case 'd': /* device */
d85 1
a85 6
		case 'e': /* enumerate */
			func |= BIOC_SCSICMD;
			subfunc |= F_ENUM;
			break;

		case 'f': /* device */
d89 2
a90 21
		case 'l': /* device list, separated for now use one dev only*/
			func |= PARSELIST;
			pl = optarg;
			break;

		case 'p': /* ping */
			func |= BIOC_PING;
			break;

		case 's': /* status */
			func |= BIOC_STATUS;
			break;

		case 't':
			func |= BIOC_SCSICMD;
			subfunc |= parse_passthru(optarg);
			break;

		case 'u': /* start/stop */
			func |= BIOC_STARTSTOP;
			ss_arg = optarg;
d114 1
a114 2
	}
	else if (sd_dev) {
d118 1
a118 2
	}
	else
d124 2
a125 74
	if (func & PARSELIST)
		parse_devlist(pl);

	if (!bio_get_capabilities(&bc))
		warnx("could not retrieve capabilities.");
	else {
		/* we should have everything setup by now so get to work */
		if (func & BIOC_ALARM)
			if (bc.ioctls & BIOC_ALARM)
				bio_alarm(al_arg);
			else
				warnx("alarms are not supported.");

		if (func & BIOC_BLINK)
			if (bc.ioctls & BIOC_BLINK)
				SLIST_FOREACH(delm, &ul, next) {
					bio_blink(al_arg, delm->channel,
					    delm->target);
				}
			else
				warnx("blink is not supported.");

		if (func & BIOC_PING)
			if (bc.ioctls & BIOC_PING)
				bio_ping();
			else
				warnx("ping not supported.");

		if (func & BIOC_STATUS) {
			if (bc.ioctls & BIOC_STATUS)
				bio_status();
			else
				warnx("status function not supported.");
		}

		if (func & BIOC_STARTSTOP) {
			if (bc.ioctls & BIOC_STARTSTOP) {
				SLIST_FOREACH(delm, &ul, next) {
					bio_startstop(ss_arg,
					    delm->channel, delm->target);
				}
			} else
				warnx("start/stop unit not supported.");
		}

		if (func & BIOC_SCSICMD) {
			if (bc.ioctls & BIOC_SCSICMD) {
				if (subfunc & F_READCAP) {
					SLIST_FOREACH(delm, &ul, next) {
						bio_pt_readcap(delm->channel,
						    delm->target, F_NOISY);
					}
				}

				if (subfunc & F_INQUIRY) {
					SLIST_FOREACH(delm, &ul, next) {
						bio_pt_inquire(delm->channel,
						    delm->target, F_NOISY,
						    &inq[0]);
					}
				}

				if (subfunc & F_TUR) {
					SLIST_FOREACH(delm, &ul, next) {
						bio_pt_tur(delm->channel,
						    delm->target);
					}
				}

				if (subfunc & F_ENUM)
					bio_pt_enum();
			} else
				warnx("passthrough not supported.");
		}
d136 1
a136 3
	fprintf(stderr, "usage: %s [-Dehpt] [-a function] [-b function] "
	    "[-l device list]\n"
	    "\t[-u function] [-d device | -f disk]\n", __progname);
a143 2
	struct dev *delm;

a146 16
	while (devices.slh_first != NULL) {
		delm = devices.slh_first;
		SLIST_REMOVE_HEAD(&devices, next);
		if (debug)
			printf("free device: %p\n", delm);
		free(delm);
	}

	while (ul.slh_first != NULL) {
		delm = ul.slh_first;
		SLIST_REMOVE_HEAD(&ul, next);
		if (debug)
			printf("free ul: %p\n", delm);
		free(delm);
	}

a150 32
u_int64_t
parse_passthru(char *f)
{
	if (debug)
		printf("get_subfunc: %s, ", f);

	switch (f[0]) {
	case 'i': /* INQUIRY */
		if (debug)
			printf("inquiry\n");
		return (F_INQUIRY);

	case 'e': /* ENUMERATE, not a pass through hmmm */
		if (debug)
			printf("enumerate\n");
		return (F_ENUM);

	case 'r': /* READ CAPACITY */
		if (debug)
			printf("read cap\n");
		return (F_READCAP);

	case 't': /* TUR */
		if (debug)
			printf("TUR\n");
		return (F_TUR);

	default:
		errx(1, "invalid pass through function");
	}
}

d152 1
a152 56
parse_devlist(char *dl)
{
	u_int8_t c , t, done = 0;
	char *es, *s;
	struct dev *delm;

	es = NULL;
	s = dl;

	if (debug)
		printf("parse: %s\n", dl);

	while (!done) {
		c = strtol(s, &es, 10);
		if (debug)
			printf("%p %p %u %c\n", s, es, c, es[0]);
		s = es;
		if (es[0] == ':') {
			s++;
			t = strtol(s, &es, 10);
			if (debug)
				printf("%p %p %u %c\n", s, es, t, es[0]);
			s = es;

			if (c > 4)
				errx(1, "invalid channel number");
			if (t > 16)
				errx(1, "invalid target number");

			delm = malloc(sizeof(struct dev));
			if (!delm)
				errx(1, "not enough memory");

			delm->target = t;
			delm->channel = c;
			SLIST_INSERT_HEAD(&ul, delm, next);
		}
		if (es[0] == ',') {
			s++;
			continue;
		}
		if (es[0] == '\0') {
			done = 1;
			continue;
		}
		done = 2;
	}

	if (done == 2) {
		/* boink */
		errx(1, "invalid device list.");
	}
}

int
bio_get_capabilities(bioc_capabilities *bc)
d154 3
a156 13
	int rv;

	bc->cookie = bl.cookie;
	rv = ioctl(devh, BIOCCAPABILITIES, bc);
	if (rv == -1) {
		warnx("Error calling bioc_ioctl() via bio_ioctl()");
		return 0;
	}

	if (debug) {
		printf("ioctls = %016llx\n", bc->ioctls);
		printf("raid_types = %08lx\n", bc->raid_types);
	}
d158 1
a158 2
	return (1);
}
d160 1
a160 5
void
bio_alarm(char *arg)
{
	int rv;
	bioc_alarm ba;
d163 1
a163 1
		printf("alarm in: %s, ", arg);
d165 1
a165 1
	ba.cookie = bl.cookie;
d167 1
a167 39
	switch (arg[0]) {
	case 'q': /* silence alarm */
		/* FALLTHROUGH */
	case 's':
		if (debug)
			printf("silence\n");
		ba.opcode = BIOCSALARM_SILENCE;
		break;

	case 'e': /* enable alarm */
		if (debug)
			printf("enable\n");
		ba.opcode = BIOCSALARM_ENABLE;
		break;

	case 'd': /* disable alarm */
		if (debug)
			printf("disable\n");
		ba.opcode = BIOCSALARM_DISABLE;
		break;

	case 't': /* test alarm */
		if (debug)
			printf("test\n");
		ba.opcode = BIOCSALARM_TEST;
		break;

	case 'g': /* get alarm state */
		if (debug)
			printf("get state\n");
		ba.opcode = BIOCGALARM_STATE;
		break;

	default:
		warnx("invalid alarm function: %s", arg);
		return;
	}

	rv = ioctl(devh, BIOCALARM, &ba);
d173 2
a174 5
	if (arg[0] == 'g') {
		printf("alarm is currently %s\n",
		    ba.state ? "enabled" : "disabled");
	}
}
d176 4
a179 5
void
ses_verbose(u_int8_t *rc, u_int8_t len)
{
	struct ses_config_page *scp;
	struct ses_type_desc_hdr *tdh;
d181 3
a183 62
	char *str;
	u_int8_t i;

	scp = (struct ses_config_page *)rc;
	printf("element types: %d, id: %s\n", scp->nr_elem_typ,
	    scp->enc_vendor_id);

	str = (char *)
	    (&scp->enc_desc_len + scp->enc_desc_len + 1 +
	    (scp->nr_elem_typ * sizeof(struct ses_type_desc_hdr)));

	for (i = 0; i < scp->nr_elem_typ; i++) {
		tdh = (struct ses_type_desc_hdr *)
		    (&scp->enc_desc_len + scp->enc_desc_len + 1 +
		    (i * sizeof(struct ses_type_desc_hdr)));

		printf("type: %d, count: %d, sub enclosure id: %d, "
		    "len: %d, text: %s\n",
		    tdh->elem_type, tdh->nr_elem, tdh->sub_enc_id,
		    tdh->type_desc_len, str);

		str += tdh->type_desc_len;
	}
}

void
bio_blink_userland(u_int8_t opc, u_int8_t c, u_int8_t t)
{
	struct dev *delm;

	/* page 1 stuff */
	struct ses_enc_ctrl_diag_page *cdp;
	struct ses_config_page *scp;
	struct ses_type_desc_hdr *tdh;

	/* page 2 stuff */
	struct ses_enc_stat_diag_page *esdp;
	struct ses_dev_elmt_status_diag *desd;

	u_int8_t rc[SESSIZE];
	u_int8_t rc2[SESSIZE];
	u_int8_t i, elements, found = 0;

	/* FIXME if the raid controllers are clustered we might have more
	 * than one proc device. */

	bio_pt_enum();

	SLIST_FOREACH(delm, &devices, next) {
		if (delm->channel != c)
			continue;

		if (delm->type != T_PROCESSOR)
			continue;

		if (debug)
			printf("proc at channel: %d target: %2d\n",
			    delm->channel, delm->target);

		/* figure out what we have */
		if (!get_ses_page(delm->channel, delm->target,
		    SES_CFG_DIAG_PAGE, &rc[0], sizeof(rc))) {
d187 5
a191 71
		if (debug)
			ses_verbose(&rc[0], sizeof(rc));

		/* find first disk element */
		elements = 0;
		scp = (struct ses_config_page *)rc;
		for (i = 0; i < scp->nr_elem_typ; i++) {
			tdh = (struct ses_type_desc_hdr *)
			    (&scp->enc_desc_len + scp->enc_desc_len + 1 +
			    (i * sizeof(struct ses_type_desc_hdr)));

			if (tdh->elem_type == STDH_DEVICE) {
				found = 1;
				break;
			}
			elements += tdh->nr_elem;
		}

		if (debug) {
			printf("tdh->elem_type: %d, tdh->nr_elem: %d, "
			    "elements: %d\n",
			    tdh->elem_type, tdh->nr_elem, elements);
		}

		if (!found) {
			if (debug)
				printf("no devices found\n");

			return;
		}

		/* get ses page so that we can modify bits for blink */
		if (!get_ses_page(delm->channel, delm->target,
		    SES_CTRL_DIAG_PAGE, &rc2[0], sizeof(rc2))) {
			return;
		}

		esdp = (struct ses_enc_stat_diag_page *)rc2;
		desd = (struct ses_dev_elmt_status_diag *)
		    (esdp->elmts + elements); /* FIXME do we need padding? */

		/* loop through all slots to see if target is available */
		found = 0;
		for (i = 0; i < tdh->nr_elem; i++) {
			if (debug)
				printf("stat: %d, addr: %d, b3: %d, b4: %d\n",
				    desd->common_status,
				    desd->slot_addr,
				    desd->byte3,
				    desd->byte4);

			if (t == desd->slot_addr) {
				found = 1;
				break;
			}

			desd += 1; /* next element */
		}

		if (!found) {
			printf("target: %d not found\n", t);

			return;
		}

		cdp = (struct ses_enc_ctrl_diag_page *)rc2;
		cdp->elmts[i].common_ctrl = SDECD_SELECT;
		switch (opc) {
		case BIOCSBLINK_ALERT:
			cdp->elmts[i].byte4 = SDECD_RQST_FAULT;
			cdp->elmts[i].byte3 = 0x00;
d194 2
a195 3
		case BIOCSBLINK_BLINK:
			cdp->elmts[i].byte3 = SDECD_RQST_IDENT;
			cdp->elmts[i].byte4 = 0x00;
d198 2
a199 3
		case BIOCSBLINK_UNBLINK:
			cdp->elmts[i].byte3 = 0x00;
			cdp->elmts[i].byte4 = 0x00;
d202 1
d204 1
a204 1
			return;
d206 15
d222 6
a227 4
		if (!set_ses_page(delm->channel, delm->target,
		    &rc2[0], sizeof(rc2))) {
			return;
		}
d229 3
a231 3
		return; /* done */
	}
}
d233 3
a235 5
void
bio_blink(char * arg, u_int8_t c, u_int8_t t)
{
	int rv;
	bioc_blink bb;
d237 3
a239 2
	if (debug)
		printf("blink in: %s, ", arg);
d241 3
a243 1
	bb.cookie = bl.cookie;
d245 3
a247 18
	switch (arg[0]) {
	case 'a': /* blink amber or alert led */
		if (debug)
			printf("blink alert\n");
		bb.opcode = BIOCSBLINK_ALERT;
		break;

	case 'b': /* blink hdd */
		if (debug)
			printf("blink\n");
		bb.opcode = BIOCSBLINK_BLINK;
		break;

	case 'u': /* unblink hdd */
		if (debug)
			printf("unblink\n");
		bb.opcode = BIOCSBLINK_UNBLINK;
		break;
d249 7
a255 12
	default:
		warnx("invalid blink function: %s", arg);
		return;
	}

	rv = ioctl(devh, BIOCBLINK, &bb);
	if (rv == -1) {
		if (errno == EOPNOTSUPP) {
			/* operation is not supported in kernel, do it here */
			if (debug)
				printf("doing blink in userland\n");
			bio_blink_userland(bb.opcode, c, t);
a256 135
		else
			warnx("bioc_ioctl() call failed");
	}
}

void
bio_ping(void)
{
	int rv;
	bioc_ping bp;

	bp.cookie = bl.cookie;
	bp.x = 0;
	rv = ioctl(devh, BIOCPING, &bp);
	if (rv == -1) {
		warnx("Error calling bioc_ioctl() via bio_ioctl()");
		return;
	}

	printf("x after ioctl() = %i\n", bp.x);
}

void
bio_startstop(char *arg, u_int8_t c, u_int8_t t)
{
	int rv;
	bioc_startstop bs;

	if (debug)
		printf("startstop in: %s, ", arg);

	bs.cookie = bl.cookie;

	switch (arg[0]) {
	case 's': /* stop unit */
		if (debug)
			printf("stop\n");
		bs.opcode = BIOCSUNIT_STOP;
		break;

	case 'g': /* start or go unit */
		if (debug)
			printf("start\n");
		bs.opcode = BIOCSUNIT_START;
		break;

	default:
		warnx("invalid start/stop function: %s", arg);
		return;
	}

	bs.channel = c;
	bs.target = t;

	rv = ioctl(devh, BIOCSTARTSTOP, &bs);
	if (rv == -1) {
		warnx("bioc_ioctl() call failed");
		return;
	}

	if (debug)
		printf("startstop done\n");
}

/* get status, for now only do all */
void
bio_status(void)
{
	int rv;
	bioc_status bs;

	if (debug)
		printf("status()\n");

	bs.cookie = bl.cookie;
	bs.opcode = BIOCGSTAT_ALL;

	rv = ioctl(devh, BIOCSTATUS, &bs);
	if (rv == -1) {
		warnx("bioc_ioctl() call failed");
		return;
	}

	if (debug)
		printf("status done\n");
}

/* read capacity for disk c,t */
u_int64_t
bio_pt_readcap(u_int8_t c, u_int8_t t, u_int8_t flags)
{
	bioc_scsicmd bpt;
	struct read_cap rc;
	int rv;
	u_int64_t size;

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 10;
	bpt.cdb[0] = READ_CAPACITY;
	bpt.data = &rc;    /* set up return data pointer */
	bpt.datalen = sizeof(rc);
	bpt.direction = BIOC_DIRIN;
	bpt.senselen = 32; /* silly since the kernel overrides it */

	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("READ CAPACITY failed %x", bpt.status);
		return (0);
	}
	else if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			printf("channel: %d target: %2d READ CAPACITY failed "
			    "without sense data\n", c, t);

		return (0);
	}

	rc.maxlba = betoh32(rc.maxlba);
	rc.bsize = betoh32(rc.bsize);

	size = (u_int64_t)rc.maxlba * (u_int64_t)rc.bsize;

	if (debug)
		printf("\nREAD CAPACITY: %lu * %lu = %llu\n",
		    rc.maxlba, rc.bsize, size);

	if (flags & F_NOISY) {
		printf("channel: %d target: %2d READ CAPACITY  %llu", c, t,
		    size);
		print_cap(size);
a258 311

	return (size);
}


/* inquire device */
u_int32_t
bio_pt_inquire(u_int8_t c, u_int8_t t, u_int8_t flags, u_int8_t *inq)
{
	bioc_scsicmd bpt;
	int rv, i;

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 6;
	bpt.cdb[0] = INQUIRY;
	bpt.cdb[4] = INQSIZE;   /* LENGTH  */
	bpt.data = inq;    /* set up return data pointer */
	bpt.datalen = INQSIZE;  /* minimum INQ size */
	bpt.direction = BIOC_DIRIN;
	bpt.senselen = 32; /* silly since the kernel overrides it */

	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("INQUIRY failed %x", bpt.status);
		return 0;
	}
	else if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			if (flags & F_NOISY)
				printf("device %d:%d did not respond to "
				    "INQUIRY command\n", c, t);

		return 0;
	}

	printf("channel: %u target: %2u ", c, t);
	print_inquiry(flags, inq, bpt.datalen);

	if (flags & F_NOISY)
		printf("\n");

	return 1;
}

/* TUR for disk c,t */
u_int32_t
bio_pt_tur(u_int8_t c, u_int8_t t)
{
	bioc_scsicmd bpt;
	int rv;

	if (debug)
		printf("tur\n");

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 6;
	bpt.cdb[0] = TEST_UNIT_READY;
	bpt.direction = BIOC_DIRNONE;
	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("passthrough failed");
		return (0);
	}

	if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			printf("channel: %d target: %2d: TUR failed without "
			    "sense data\n", c, t);

		return (0);
	}

	printf("channel: %d target: %2d: TUR completed\n", c, t);

	return (1);
}


/* enumerate all disks */
void
bio_pt_enum(void)
{
	bioc_scsicmd bpt;
	u_int32_t c, t, i, d;
	int rv;
	u_int8_t inq[INQSIZE];

	struct dev *delm;

	d = 0;
	for (c = 0; c < 4 /* FIXME */; c++) {
		for (t = 0; t < 16 /* FIXME */; t++) {
			if (bio_pt_inquire(c, t, F_SILENCE, &inq[0])) {
				if (inq[0] & SID_QUAL)
					continue; /* invalid device */

				delm = malloc(sizeof(struct dev));
				if (delm == NULL)
					errx(1, "not enough memory");
				delm->id = d++;
				delm->target = t;
				delm->channel = c;
				delm->type = inq[0];
				if (delm->type == T_DIRECT) {
					/* FIXME check the return value */
					delm->capacity = bio_pt_readcap(
					    delm->channel, delm->target,
					    F_SILENCE);
					print_cap(delm->capacity);
				}
				printf("\n");

				SLIST_INSERT_HEAD(&devices, delm, next);
			}
		} /* for t */
	} /* for c */
}

/* printf sense data */
void
print_sense(u_int8_t *sensebuf, u_int8_t sensebuflen)
{
	u_int8_t i;

	if (debug)
		printf("print_sense() %p, %u\n", sensebuf, sensebuflen);

	for (i = 0; i < sensebuflen; i++) {
		printf("%02x ", sensebuf[i]);
	}
	printf("\n");

	/* FIXME add some pretty decoding here */
}

void
print_inquiry(u_int8_t flags, u_int8_t *inq, u_int8_t inqlen)
{
	u_int8_t i;

	if (inqlen < INQSIZE) {
		/* INQUIRY shall return at least 36 bytes */
		printf("invalid INQUIRY buffer size\n");
		return;
	}

	if (SID_QUAL & inq[0]) {
		printf("invalid device\n");
		return;
	}

	switch (SID_TYPE & inq[0]) {
	case T_DIRECT:
		printf("disk ");
		break;

	case T_PROCESSOR:
		printf("proc ");
		break;

	default:
		printf("unsuported device type\n");
		return;
	}

	for (i = 0;  i < inqlen; i++) {
		if (i < 8) {
			if ((flags & F_NOISY) || debug)
				printf("%02x ", inq[i]);
		}
		else
			printf("%c", inq[i] < ' ' ? ' ' : inq[i]);
	}
}

void print_cap(u_int64_t cap)
{
	if (cap / S_TERA > 1) {
		printf(" %3llu TB", cap / S_TERA);
		return;
	}

	if (cap / S_GIGA > 1) {
		printf(" %3llu GB", cap / S_GIGA);
		return;
	}

	if (cap / S_MEGA > 1) {
		printf(" %3llu MB", cap / S_MEGA);
		return;
	}

	if (cap / S_KILO > 1) {
		printf(" %3llu MB", cap / S_KILO);
		return;
	}

	printf(" %llu B", cap);
}

#if 0
	/* in case we want to do SAFTE this is the format */
	/* SAF-TE */
	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = delm->channel;
	bpt.target = delm->target;
	bpt.cdblen = 10;
	bpt.cdb[0] = 0x3c; /* READ BUFFER */
	bpt.cdb[1] = 0x01; /* SAF-TE command */
	bpt.cdb[8] = sizeof(rc); /* LSB size, FIXME */
	bpt.data = &rc[0];    /* set up return data pointer */
	bpt.datalen = sizeof(rc);
	bpt.direction = BIOC_DIRIN;
	bpt.senselen = 32; /* silly since the kernel overrides it */
#endif

int
get_ses_page(u_int8_t c, u_int8_t t, u_int8_t p, u_int8_t *buf, u_int8_t buflen)
{
	bioc_scsicmd bpt;
	int rv;

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 6;
	bpt.cdb[0] = RECEIVE_DIAGNOSTIC;
	/* FIXME add this cdb struct + #defines to scsi_all.h */
	bpt.cdb[1] = 0x01; /* set PCV bit for SES commands */
	bpt.cdb[2] = p;    /* SES page nr */
	bpt.cdb[4] = buflen;
	bpt.data = buf;    /* set up return data pointer */
	bpt.datalen = buflen;
	bpt.direction = BIOC_DIRIN;
	bpt.senselen = 32; /* silly since the kernel overrides it */

	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("RECEIVE_DIAGNOSTIC failed %x", bpt.status);
		return (0);
	}
	else if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			printf("channel: %d target: %2d RECEIVE_DIAGNOSTIC "
			    "failed without sense data\n", c, t);

		return (0);
	}

	if (debug) {
		/* abuse print sense a little */
		print_sense(buf, bpt.datalen);
	}

	return (1);
}

int
set_ses_page(u_int8_t c, u_int8_t t, u_int8_t *buf, u_int8_t buflen)
{
	bioc_scsicmd bpt;
	int rv;

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 6;
	bpt.cdb[0] = SEND_DIAGNOSTIC;
	bpt.cdb[1] = SSD_PF;
	bpt.cdb[4] = buflen;
	bpt.data = buf;    /* set up return data pointer */
	bpt.datalen = buflen;
	bpt.direction = BIOC_DIROUT;
	bpt.senselen = 32; /* silly since the kernel overrides it */

	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("SEND_DIAGNOSTIC failed %x", bpt.status);
		return (0);
	}
	else if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			printf("channel: %d target: %2d SEND_DIAGNOSTIC "
			    "failed without sense data\n", c, t);

		return (0);
	}

	if (debug) {
		/* abuse print sense a little */
		print_sense(buf, bpt.datalen);
	}

	return (1);
@


1.14
log
@tweaks;
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.13 2005/07/18 01:59:43 marco Exp $       */
d29 7
a43 9
#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

d49 7
d66 2
a67 2
	u_int64_t func = 0;
	/* u_int64_t subfunc = 0; */
d71 1
d76 8
d90 1
a90 1
	while ((ch = getopt(argc, argv, "Dd:f:hi")) != -1) {
d92 10
a101 1
		case 'D': /* debug */
d105 1
a105 1
		case 'd': /* bio device */
d109 6
a114 1
		case 'f': /* scsi device */
d118 21
a138 2
		case 'i': /* inquiry */
			func |= BIOC_INQ;
d174 74
a247 2
	if (func & BIOC_INQ) {
		bio_inq();
d258 3
a260 1
	fprintf(stderr, "usage: %s [-Dhi] -d device | -f device\n", __progname);
d268 2
d273 16
d293 32
d326 1
a326 1
bio_inq(void)
d328 6
a333 3
	bioc_inq bi;
	bioc_vol bv;
	bioc_disk bd;
d335 38
a372 1
	int rv, i, d;
d374 31
a404 1
	memset(&bi, 0, sizeof(bi));
d407 1
a407 1
		printf("bio_inq\n");
d409 1
a409 1
	bi.cookie = bl.cookie;
d411 39
a449 1
	rv = ioctl(devh, BIOCINQ, &bi);
d455 100
a554 2
	printf("RAID volumes   : %d\n", bi.novol);
	printf("Physical disks : %d\n\n", bi.nodisk);
d556 6
a561 4
	for (i = 0; i < bi.novol; i++) {
		memset(&bv, 0, sizeof(bv));
		bv.cookie = bl.cookie;
		bv.volid = i;
d563 3
a565 3
		rv = ioctl(devh, BIOCVOL, &bv);
		if (rv == -1) {
			warnx("bioc_ioctl() call failed");
d569 17
a585 15
		printf("\tvolume id: %d\n", bv.volid);
		printf("\tstatus   : %d\n", bv.status);
		printf("\tsize     : %lld\n", bv.size);
		printf("\traid     : %d\n", bv.level);
		printf("\tnr disks : %d\n", bv.nodisk);

		for (d = 0; d < bv.nodisk; d++) {
			memset(&bd, 0, sizeof(bd));
			bd.cookie = bl.cookie;
			bd.diskid = 0;

			rv = ioctl(devh, BIOCDISK, &bd);
			if (rv == -1) {
				warnx("bioc_ioctl() call failed");
				return;
d588 7
a594 5
			printf("\t\tdisk id  : %d\n", bd.diskid);
			printf("\t\tstatus   : %d\n", bd.status);
			printf("\t\tvolume id: %d\n", bd.volid);
			printf("\t\tsize     : %lld\n", bd.size);
			printf("\t\tvendor   : %s\n", bd.vendor);
d596 210
d808 311
@


1.13
log
@Fix online help.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.12 2005/07/18 01:29:19 marco Exp $       */
d139 1
a139 1
	fprintf(stderr, "usage: %s [-Dhi] [-d device | -f disk]\n", __progname);
@


1.12
log
@Kill initial implementation because it sucked.  It was far too complex the new
paradigm is to virtualize the operations.  Using physical data is really only
necessary on low end hardware or by advanced users.
For now only support the inquiry operation.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.11 2005/07/01 21:53:40 marco Exp $       */
d76 1
a76 1
	while ((ch = getopt(argc, argv, "Dd:f:i")) != -1) {
d139 1
a139 1
	fprintf(stderr, "usage: %s [-Di] [-d device | -f disk]\n", __progname);
@


1.11
log
@Add -f option for disk operations.  Idea by deraadt.

This is not fully functional yet.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.10 2005/04/18 11:51:46 jmc Exp $       */
a28 7
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <util.h>

d37 9
a50 7
SLIST_HEAD(dev_list, dev);

/* RAID card device list */
struct dev_list devices = SLIST_HEAD_INITIALIZER(dev);
/* User provided device list*/
struct dev_list ul = SLIST_HEAD_INITIALIZER(dev);

d61 2
a62 2
	bioc_capabilities bc;
	bioc_alarm ba;
a65 1
	unsigned char *pl;
a69 8
	char *al_arg = NULL; /* argument to alarm */
	char *ss_arg = NULL; /* argument to start/stop */
	char inq[INQSIZE];

	struct dev *delm;

	u_int64_t func = 0, subfunc = 0;
	u_int32_t devlist = 0;
d76 1
a76 1
	while ((ch = getopt(argc, argv, "a:b:Dd:ef:hl:pst:u:")) != -1) {
d78 1
a78 10
		case 'a': /* alarm */
			func |= BIOC_ALARM;
			al_arg = optarg;
			break;
		case 'b': /* LED blink/unblink */
			func |= BIOC_BLINK;
			al_arg = optarg;
			break;

		case 'D': /* enable debug */
d82 1
a82 1
		case 'd': /* device */
d86 1
a86 6
		case 'e': /* enumerate */
			func |= BIOC_SCSICMD;
			subfunc |= F_ENUM;
			break;

		case 'f': /* device */
d90 2
a91 21
		case 'l': /* device list, separated for now use one dev only*/
			func |= PARSELIST;
			pl = optarg;
			break;

		case 'p': /* ping */
			func |= BIOC_PING;
			break;

		case 's': /* status */
			func |= BIOC_STATUS;
			break;

		case 't':
			func |= BIOC_SCSICMD;
			subfunc |= parse_passthru(optarg);
			break;

		case 'u': /* start/stop */
			func |= BIOC_STARTSTOP;
			ss_arg = optarg;
d127 2
a128 74
	if (func & PARSELIST)
		parse_devlist(pl);

	if (!bio_get_capabilities(&bc))
		warnx("could not retrieve capabilities.");
	else {
		/* we should have everything setup by now so get to work */
		if (func & BIOC_ALARM)
			if (bc.ioctls & BIOC_ALARM)
				bio_alarm(al_arg);
			else
				warnx("alarms are not supported.");

		if (func & BIOC_BLINK)
			if (bc.ioctls & BIOC_BLINK)
				SLIST_FOREACH(delm, &ul, next) {
					bio_blink(al_arg, delm->channel,
					    delm->target);
				}
			else
				warnx("blink is not supported.");

		if (func & BIOC_PING)
			if (bc.ioctls & BIOC_PING)
				bio_ping();
			else
				warnx("ping not supported.");

		if (func & BIOC_STATUS) {
			if (bc.ioctls & BIOC_STATUS)
				bio_status();
			else
				warnx("status function not supported.");
		}

		if (func & BIOC_STARTSTOP) {
			if (bc.ioctls & BIOC_STARTSTOP) {
				SLIST_FOREACH(delm, &ul, next) {
					bio_startstop(ss_arg,
					    delm->channel, delm->target);
				}
			} else
				warnx("start/stop unit not supported.");
		}

		if (func & BIOC_SCSICMD) {
			if (bc.ioctls & BIOC_SCSICMD) {
				if (subfunc & F_READCAP) {
					SLIST_FOREACH(delm, &ul, next) {
						bio_pt_readcap(delm->channel,
						    delm->target, F_NOISY);
					}
				}

				if (subfunc & F_INQUIRY) {
					SLIST_FOREACH(delm, &ul, next) {
						bio_pt_inquire(delm->channel,
						    delm->target, F_NOISY,
						    &inq[0]);
					}
				}

				if (subfunc & F_TUR) {
					SLIST_FOREACH(delm, &ul, next) {
						bio_pt_tur(delm->channel,
						    delm->target);
					}
				}

				if (subfunc & F_ENUM)
					bio_pt_enum();
			} else
				warnx("passthrough not supported.");
		}
d139 1
a139 3
	fprintf(stderr, "usage: %s [-Dehpt] [-a function] [-b function] "
	    "[-l device list]\n"
	    "\t[-u function] [-d device | -f disk]\n", __progname);
a146 2
	struct dev *delm;

a149 16
	while (devices.slh_first != NULL) {
		delm = devices.slh_first;
		SLIST_REMOVE_HEAD(&devices, next);
		if (debug)
			printf("free device: %p\n", delm);
		free(delm);
	}

	while (ul.slh_first != NULL) {
		delm = ul.slh_first;
		SLIST_REMOVE_HEAD(&ul, next);
		if (debug)
			printf("free ul: %p\n", delm);
		free(delm);
	}

a153 32
u_int64_t
parse_passthru(char *f)
{
	if (debug)
		printf("get_subfunc: %s, ", f);

	switch (f[0]) {
	case 'i': /* INQUIRY */
		if (debug)
			printf("inquiry\n");
		return (F_INQUIRY);

	case 'e': /* ENUMERATE, not a pass through hmmm */
		if (debug)
			printf("enumerate\n");
		return (F_ENUM);

	case 'r': /* READ CAPACITY */
		if (debug)
			printf("read cap\n");
		return (F_READCAP);

	case 't': /* TUR */
		if (debug)
			printf("TUR\n");
		return (F_TUR);

	default:
		errx(1, "invalid pass through function");
	}
}

d155 1
a155 1
parse_devlist(char *dl)
d157 3
a159 6
	u_int8_t c , t, done = 0;
	char *es, *s;
	struct dev *delm;

	es = NULL;
	s = dl;
d161 1
a161 38
	if (debug)
		printf("parse: %s\n", dl);

	while (!done) {
		c = strtol(s, &es, 10);
		if (debug)
			printf("%p %p %u %c\n", s, es, c, es[0]);
		s = es;
		if (es[0] == ':') {
			s++;
			t = strtol(s, &es, 10);
			if (debug)
				printf("%p %p %u %c\n", s, es, t, es[0]);
			s = es;

			if (c > 4)
				errx(1, "invalid channel number");
			if (t > 16)
				errx(1, "invalid target number");

			delm = malloc(sizeof(struct dev));
			if (!delm)
				errx(1, "not enough memory");

			delm->target = t;
			delm->channel = c;
			SLIST_INSERT_HEAD(&ul, delm, next);
		}
		if (es[0] == ',') {
			s++;
			continue;
		}
		if (es[0] == '\0') {
			done = 1;
			continue;
		}
		done = 2;
	}
d163 1
a163 31
	if (done == 2) {
		/* boink */
		errx(1, "invalid device list.");
	}
}

int
bio_get_capabilities(bioc_capabilities *bc)
{
	int rv;

	bc->cookie = bl.cookie;
	rv = ioctl(devh, BIOCCAPABILITIES, bc);
	if (rv == -1) {
		warnx("Error calling bioc_ioctl() via bio_ioctl()");
		return 0;
	}

	if (debug) {
		printf("ioctls = %016llx\n", bc->ioctls);
		printf("raid_types = %08lx\n", bc->raid_types);
	}

	return (1);
}

void
bio_alarm(char *arg)
{
	int rv;
	bioc_alarm ba;
d166 1
a166 1
		printf("alarm in: %s, ", arg);
d168 1
a168 1
	ba.cookie = bl.cookie;
d170 1
a170 39
	switch (arg[0]) {
	case 'q': /* silence alarm */
		/* FALLTHROUGH */
	case 's':
		if (debug)
			printf("silence\n");
		ba.opcode = BIOCSALARM_SILENCE;
		break;

	case 'e': /* enable alarm */
		if (debug)
			printf("enable\n");
		ba.opcode = BIOCSALARM_ENABLE;
		break;

	case 'd': /* disable alarm */
		if (debug)
			printf("disable\n");
		ba.opcode = BIOCSALARM_DISABLE;
		break;

	case 't': /* test alarm */
		if (debug)
			printf("test\n");
		ba.opcode = BIOCSALARM_TEST;
		break;

	case 'g': /* get alarm state */
		if (debug)
			printf("get state\n");
		ba.opcode = BIOCGALARM_STATE;
		break;

	default:
		warnx("invalid alarm function: %s", arg);
		return;
	}

	rv = ioctl(devh, BIOCALARM, &ba);
d176 2
a177 11
	if (arg[0] == 'g') {
		printf("alarm is currently %s\n",
		    ba.state ? "enabled" : "disabled");
	}
}

void
ses_verbose(u_int8_t *rc, u_int8_t len)
{
	struct ses_config_page *scp;
	struct ses_type_desc_hdr *tdh;
d179 4
a182 2
	char *str;
	u_int8_t i;
d184 3
a186 96
	scp = (struct ses_config_page *)rc;
	printf("element types: %d, id: %s\n", scp->nr_elem_typ,
	    scp->enc_vendor_id);

	str = (char *)
	    (&scp->enc_desc_len + scp->enc_desc_len + 1 +
	    (scp->nr_elem_typ * sizeof(struct ses_type_desc_hdr)));

	for (i = 0; i < scp->nr_elem_typ; i++) {
		tdh = (struct ses_type_desc_hdr *)
		    (&scp->enc_desc_len + scp->enc_desc_len + 1 +
		    (i * sizeof(struct ses_type_desc_hdr)));

		printf("type: %d, count: %d, sub enclosure id: %d, "
		    "len: %d, text: %s\n",
		    tdh->elem_type, tdh->nr_elem, tdh->sub_enc_id,
		    tdh->type_desc_len, str);

		str += tdh->type_desc_len;
	}
}

void
bio_blink_userland(u_int8_t opc, u_int8_t c, u_int8_t t)
{
	struct dev *delm;

	/* page 1 stuff */
	struct ses_enc_ctrl_diag_page *cdp;
	struct ses_config_page *scp;
	struct ses_type_desc_hdr *tdh;

	/* page 2 stuff */
	struct ses_enc_stat_diag_page *esdp;
	struct ses_dev_elmt_status_diag *desd;

	u_int8_t rc[SESSIZE];
	u_int8_t rc2[SESSIZE];
	u_int8_t i, elements, found = 0;

	/* FIXME if the raid controllers are clustered we might have more
	 * than one proc device. */

	bio_pt_enum();

	SLIST_FOREACH(delm, &devices, next) {
		if (delm->channel != c)
			continue;

		if (delm->type != T_PROCESSOR)
			continue;

		if (debug)
			printf("proc at channel: %d target: %2d\n",
			    delm->channel, delm->target);

		/* figure out what we have */
		if (!get_ses_page(delm->channel, delm->target,
		    SES_CFG_DIAG_PAGE, &rc[0], sizeof(rc))) {
			return;
		}

		if (debug)
			ses_verbose(&rc[0], sizeof(rc));

		/* find first disk element */
		elements = 0;
		scp = (struct ses_config_page *)rc;
		for (i = 0; i < scp->nr_elem_typ; i++) {
			tdh = (struct ses_type_desc_hdr *)
			    (&scp->enc_desc_len + scp->enc_desc_len + 1 +
			    (i * sizeof(struct ses_type_desc_hdr)));

			if (tdh->elem_type == STDH_DEVICE) {
				found = 1;
				break;
			}
			elements += tdh->nr_elem;
		}

		if (debug) {
			printf("tdh->elem_type: %d, tdh->nr_elem: %d, "
			    "elements: %d\n",
			    tdh->elem_type, tdh->nr_elem, elements);
		}

		if (!found) {
			if (debug)
				printf("no devices found\n");

			return;
		}

		/* get ses page so that we can modify bits for blink */
		if (!get_ses_page(delm->channel, delm->target,
		    SES_CTRL_DIAG_PAGE, &rc2[0], sizeof(rc2))) {
d190 15
a204 17
		esdp = (struct ses_enc_stat_diag_page *)rc2;
		desd = (struct ses_dev_elmt_status_diag *)
		    (esdp->elmts + elements); /* FIXME do we need padding? */

		/* loop through all slots to see if target is available */
		found = 0;
		for (i = 0; i < tdh->nr_elem; i++) {
			if (debug)
				printf("stat: %d, addr: %d, b3: %d, b4: %d\n",
				    desd->common_status,
				    desd->slot_addr,
				    desd->byte3,
				    desd->byte4);

			if (t == desd->slot_addr) {
				found = 1;
				break;
d207 5
a211 7
			desd += 1; /* next element */
		}

		if (!found) {
			printf("target: %d not found\n", t);

			return;
a212 210

		cdp = (struct ses_enc_ctrl_diag_page *)rc2;
		cdp->elmts[i].common_ctrl = SDECD_SELECT;
		switch (opc) {
		case BIOCSBLINK_ALERT:
			cdp->elmts[i].byte4 = SDECD_RQST_FAULT;
			cdp->elmts[i].byte3 = 0x00;
			break;

		case BIOCSBLINK_BLINK:
			cdp->elmts[i].byte3 = SDECD_RQST_IDENT;
			cdp->elmts[i].byte4 = 0x00;
			break;

		case BIOCSBLINK_UNBLINK:
			cdp->elmts[i].byte3 = 0x00;
			cdp->elmts[i].byte4 = 0x00;
			break;

		default:
			return;
		}

		if (!set_ses_page(delm->channel, delm->target,
		    &rc2[0], sizeof(rc2))) {
			return;
		}

		return; /* done */
	}
}

void
bio_blink(char * arg, u_int8_t c, u_int8_t t)
{
	int rv;
	bioc_blink bb;

	if (debug)
		printf("blink in: %s, ", arg);

	bb.cookie = bl.cookie;

	switch (arg[0]) {
	case 'a': /* blink amber or alert led */
		if (debug)
			printf("blink alert\n");
		bb.opcode = BIOCSBLINK_ALERT;
		break;

	case 'b': /* blink hdd */
		if (debug)
			printf("blink\n");
		bb.opcode = BIOCSBLINK_BLINK;
		break;

	case 'u': /* unblink hdd */
		if (debug)
			printf("unblink\n");
		bb.opcode = BIOCSBLINK_UNBLINK;
		break;

	default:
		warnx("invalid blink function: %s", arg);
		return;
	}

	rv = ioctl(devh, BIOCBLINK, &bb);
	if (rv == -1) {
		if (errno == EOPNOTSUPP) {
			/* operation is not supported in kernel, do it here */
			if (debug)
				printf("doing blink in userland\n");
			bio_blink_userland(bb.opcode, c, t);
		}
		else
			warnx("bioc_ioctl() call failed");
	}
}

void
bio_ping(void)
{
	int rv;
	bioc_ping bp;

	bp.cookie = bl.cookie;
	bp.x = 0;
	rv = ioctl(devh, BIOCPING, &bp);
	if (rv == -1) {
		warnx("Error calling bioc_ioctl() via bio_ioctl()");
		return;
	}

	printf("x after ioctl() = %i\n", bp.x);
}

void
bio_startstop(char *arg, u_int8_t c, u_int8_t t)
{
	int rv;
	bioc_startstop bs;

	if (debug)
		printf("startstop in: %s, ", arg);

	bs.cookie = bl.cookie;

	switch (arg[0]) {
	case 's': /* stop unit */
		if (debug)
			printf("stop\n");
		bs.opcode = BIOCSUNIT_STOP;
		break;

	case 'g': /* start or go unit */
		if (debug)
			printf("start\n");
		bs.opcode = BIOCSUNIT_START;
		break;

	default:
		warnx("invalid start/stop function: %s", arg);
		return;
	}

	bs.channel = c;
	bs.target = t;

	rv = ioctl(devh, BIOCSTARTSTOP, &bs);
	if (rv == -1) {
		warnx("bioc_ioctl() call failed");
		return;
	}

	if (debug)
		printf("startstop done\n");
}

/* get status, for now only do all */
void
bio_status(void)
{
	int rv;
	bioc_status bs;

	if (debug)
		printf("status()\n");

	bs.cookie = bl.cookie;
	bs.opcode = BIOCGSTAT_ALL;

	rv = ioctl(devh, BIOCSTATUS, &bs);
	if (rv == -1) {
		warnx("bioc_ioctl() call failed");
		return;
	}

	if (debug)
		printf("status done\n");
}

/* read capacity for disk c,t */
u_int64_t
bio_pt_readcap(u_int8_t c, u_int8_t t, u_int8_t flags)
{
	bioc_scsicmd bpt;
	struct read_cap rc;
	int rv;
	u_int64_t size;

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 10;
	bpt.cdb[0] = READ_CAPACITY;
	bpt.data = &rc;    /* set up return data pointer */
	bpt.datalen = sizeof(rc);
	bpt.direction = BIOC_DIRIN;
	bpt.senselen = 32; /* silly since the kernel overrides it */

	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("READ CAPACITY failed %x", bpt.status);
		return (0);
	}
	else if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			printf("channel: %d target: %2d READ CAPACITY failed "
			    "without sense data\n", c, t);

		return (0);
	}

	rc.maxlba = betoh32(rc.maxlba);
	rc.bsize = betoh32(rc.bsize);

	size = (u_int64_t)rc.maxlba * (u_int64_t)rc.bsize;

	if (debug)
		printf("\nREAD CAPACITY: %lu * %lu = %llu\n",
		    rc.maxlba, rc.bsize, size);

	if (flags & F_NOISY) {
		printf("channel: %d target: %2d READ CAPACITY  %llu", c, t,
		    size);
		print_cap(size);
a214 311

	return (size);
}


/* inquire device */
u_int32_t
bio_pt_inquire(u_int8_t c, u_int8_t t, u_int8_t flags, u_int8_t *inq)
{
	bioc_scsicmd bpt;
	int rv, i;

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 6;
	bpt.cdb[0] = INQUIRY;
	bpt.cdb[4] = INQSIZE;   /* LENGTH  */
	bpt.data = inq;    /* set up return data pointer */
	bpt.datalen = INQSIZE;  /* minimum INQ size */
	bpt.direction = BIOC_DIRIN;
	bpt.senselen = 32; /* silly since the kernel overrides it */

	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("INQUIRY failed %x", bpt.status);
		return 0;
	}
	else if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			if (flags & F_NOISY)
				printf("device %d:%d did not respond to "
				    "INQUIRY command\n", c, t);

		return 0;
	}

	printf("channel: %u target: %2u ", c, t);
	print_inquiry(flags, inq, bpt.datalen);

	if (flags & F_NOISY)
		printf("\n");

	return 1;
}

/* TUR for disk c,t */
u_int32_t
bio_pt_tur(u_int8_t c, u_int8_t t)
{
	bioc_scsicmd bpt;
	int rv;

	if (debug)
		printf("tur\n");

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 6;
	bpt.cdb[0] = TEST_UNIT_READY;
	bpt.direction = BIOC_DIRNONE;
	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("passthrough failed");
		return (0);
	}

	if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			printf("channel: %d target: %2d: TUR failed without "
			    "sense data\n", c, t);

		return (0);
	}

	printf("channel: %d target: %2d: TUR completed\n", c, t);

	return (1);
}


/* enumerate all disks */
void
bio_pt_enum(void)
{
	bioc_scsicmd bpt;
	u_int32_t c, t, i, d;
	int rv;
	u_int8_t inq[INQSIZE];

	struct dev *delm;

	d = 0;
	for (c = 0; c < 4 /* FIXME */; c++) {
		for (t = 0; t < 16 /* FIXME */; t++) {
			if (bio_pt_inquire(c, t, F_SILENCE, &inq[0])) {
				if (inq[0] & SID_QUAL)
					continue; /* invalid device */

				delm = malloc(sizeof(struct dev));
				if (delm == NULL)
					errx(1, "not enough memory");
				delm->id = d++;
				delm->target = t;
				delm->channel = c;
				delm->type = inq[0];
				if (delm->type == T_DIRECT) {
					/* FIXME check the return value */
					delm->capacity = bio_pt_readcap(
					    delm->channel, delm->target,
					    F_SILENCE);
					print_cap(delm->capacity);
				}
				printf("\n");

				SLIST_INSERT_HEAD(&devices, delm, next);
			}
		} /* for t */
	} /* for c */
}

/* printf sense data */
void
print_sense(u_int8_t *sensebuf, u_int8_t sensebuflen)
{
	u_int8_t i;

	if (debug)
		printf("print_sense() %p, %u\n", sensebuf, sensebuflen);

	for (i = 0; i < sensebuflen; i++) {
		printf("%02x ", sensebuf[i]);
	}
	printf("\n");

	/* FIXME add some pretty decoding here */
}

void
print_inquiry(u_int8_t flags, u_int8_t *inq, u_int8_t inqlen)
{
	u_int8_t i;

	if (inqlen < INQSIZE) {
		/* INQUIRY shall return at least 36 bytes */
		printf("invalid INQUIRY buffer size\n");
		return;
	}

	if (SID_QUAL & inq[0]) {
		printf("invalid device\n");
		return;
	}

	switch (SID_TYPE & inq[0]) {
	case T_DIRECT:
		printf("disk ");
		break;

	case T_PROCESSOR:
		printf("proc ");
		break;

	default:
		printf("unsuported device type\n");
		return;
	}

	for (i = 0;  i < inqlen; i++) {
		if (i < 8) {
			if ((flags & F_NOISY) || debug)
				printf("%02x ", inq[i]);
		}
		else
			printf("%c", inq[i] < ' ' ? ' ' : inq[i]);
	}
}

void print_cap(u_int64_t cap)
{
	if (cap / S_TERA > 1) {
		printf(" %3llu TB", cap / S_TERA);
		return;
	}

	if (cap / S_GIGA > 1) {
		printf(" %3llu GB", cap / S_GIGA);
		return;
	}

	if (cap / S_MEGA > 1) {
		printf(" %3llu MB", cap / S_MEGA);
		return;
	}

	if (cap / S_KILO > 1) {
		printf(" %3llu MB", cap / S_KILO);
		return;
	}

	printf(" %llu B", cap);
}

#if 0
	/* in case we want to do SAFTE this is the format */
	/* SAF-TE */
	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = delm->channel;
	bpt.target = delm->target;
	bpt.cdblen = 10;
	bpt.cdb[0] = 0x3c; /* READ BUFFER */
	bpt.cdb[1] = 0x01; /* SAF-TE command */
	bpt.cdb[8] = sizeof(rc); /* LSB size, FIXME */
	bpt.data = &rc[0];    /* set up return data pointer */
	bpt.datalen = sizeof(rc);
	bpt.direction = BIOC_DIRIN;
	bpt.senselen = 32; /* silly since the kernel overrides it */
#endif

int
get_ses_page(u_int8_t c, u_int8_t t, u_int8_t p, u_int8_t *buf, u_int8_t buflen)
{
	bioc_scsicmd bpt;
	int rv;

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 6;
	bpt.cdb[0] = RECEIVE_DIAGNOSTIC;
	/* FIXME add this cdb struct + #defines to scsi_all.h */
	bpt.cdb[1] = 0x01; /* set PCV bit for SES commands */
	bpt.cdb[2] = p;    /* SES page nr */
	bpt.cdb[4] = buflen;
	bpt.data = buf;    /* set up return data pointer */
	bpt.datalen = buflen;
	bpt.direction = BIOC_DIRIN;
	bpt.senselen = 32; /* silly since the kernel overrides it */

	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("RECEIVE_DIAGNOSTIC failed %x", bpt.status);
		return (0);
	}
	else if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			printf("channel: %d target: %2d RECEIVE_DIAGNOSTIC "
			    "failed without sense data\n", c, t);

		return (0);
	}

	if (debug) {
		/* abuse print sense a little */
		print_sense(buf, bpt.datalen);
	}

	return (1);
}

int
set_ses_page(u_int8_t c, u_int8_t t, u_int8_t *buf, u_int8_t buflen)
{
	bioc_scsicmd bpt;
	int rv;

	memset(&bpt, 0, sizeof(bpt));
	bpt.cookie = bl.cookie;
	bpt.channel = c;
	bpt.target = t;
	bpt.cdblen = 6;
	bpt.cdb[0] = SEND_DIAGNOSTIC;
	bpt.cdb[1] = SSD_PF;
	bpt.cdb[4] = buflen;
	bpt.data = buf;    /* set up return data pointer */
	bpt.datalen = buflen;
	bpt.direction = BIOC_DIROUT;
	bpt.senselen = 32; /* silly since the kernel overrides it */

	rv = ioctl(devh, BIOCSCSICMD, &bpt);
	if (rv == -1) {
		warnx("SEND_DIAGNOSTIC failed %x", bpt.status);
		return (0);
	}
	else if (bpt.status) {
		if (bpt.sensebuf[0] == 0x70 || bpt.sensebuf[0] == 0x71)
			print_sense(&bpt.sensebuf[0], bpt.senselen);
		else
			printf("channel: %d target: %2d SEND_DIAGNOSTIC "
			    "failed without sense data\n", c, t);

		return (0);
	}

	if (debug) {
		/* abuse print sense a little */
		print_sense(buf, bpt.datalen);
	}

	return (1);
@


1.10
log
@sync usage() w/ man synopsis;
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.9 2005/04/12 20:49:19 marco Exp $       */
d34 1
d74 2
d90 1
a90 1
	while ((ch = getopt(argc, argv, "a:b:Dd:ehl:pst:u:")) != -1) {
d114 4
d149 21
a169 8
	devh = open(bio_device, O_RDWR);
	if (devh == -1)
		err(1, "Can't open %s", bio_device);

	bl.name = bioc_dev;
	rv = ioctl(devh, BIOCLOCATE, &bl);
	if (rv == -1)
		errx(1, "Can't locate %s device via %s", bl.name, bio_device);
d260 1
a260 1
	    "\t[-u function] -d device\n", __progname);
@


1.9
log
@Blink support is now fully functional.

Most enclosures timeout the normal blink in about 2 minutes; if not the user
can cancel the blink with -b unblink.  On the other hand the alarm blink never
times out.

example usage: bioctl -d ami0 -l 1:8 -b blink
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.8 2005/04/06 20:51:46 marco Exp $       */
d238 3
a240 8
	fprintf(stderr, "usage: %s [-Dehpt] "
	    "[-a alarm function] "
	    "[-b blink function] "
	    "[-s get status] "
	    "[-t passthrough] "
	    "[-l device list] "
	    "[-u go/stop function ] "
	    "-d raid device\n", __progname);
@


1.8
log
@Use scsi_ses.h
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.7 2005/04/06 02:36:34 marco Exp $       */
d447 31
d481 2
d484 6
d492 2
d511 37
d550 1
a550 1
		    &rc[0], sizeof(rc))) {
d554 27
a580 1
		cdp = (struct ses_enc_ctrl_diag_page *)rc;
d582 2
a583 1
		cdp->elmts[0].common_ctrl = 0x80;
d586 2
a587 1
			cdp->elmts[0].byte4 = SDECD_RQST_FAULT;
d591 2
a592 1
			cdp->elmts[0].byte3 = SDECD_RQST_IDENT;
d596 2
a597 2
			cdp->elmts[0].byte3 = 0x00;
			cdp->elmts[0].byte4 = 0x00;
d605 1
a605 1
		    &rc[0], sizeof(rc))) {
d1021 1
a1021 1
get_ses_page(u_int8_t c, u_int8_t t, u_int8_t *buf, u_int8_t buflen)
d1034 1
a1034 1
	bpt.cdb[2] = 0x02; /* SES page nr */
a1078 5
	/*
	buf[12] = 0x80;
	buf[14] = 0x00;
	buf[15] = 0x20;
	*/
@


1.7
log
@Add ses blink crud.  Not fully functional yet.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.6 2005/04/05 20:25:50 marco Exp $       */
d40 1
d450 1
a450 1
	struct scsi_enc_ctrl_diag_page *cdp;
d476 1
a476 1
		cdp = (struct scsi_enc_ctrl_diag_page *)rc;
@


1.6
log
@fix output from remaining passthrough functions
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.5 2005/04/05 19:45:06 marco Exp $       */
d446 60
d517 6
d546 1
d785 1
a785 1
	for (c = 0; c < 2 /* FIXME */; c++) {
d893 108
@


1.5
log
@clean up enumeration.
properly print inquiry data.
identify devices bioctl cares about.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.4 2005/04/04 22:43:07 marco Exp $       */
d203 1
a203 1
						    delm->target);
d570 1
a570 1
bio_pt_readcap(u_int8_t c, u_int8_t t)
d597 2
a598 1
			printf("read capacity failed without sense data\n");
d609 1
a609 1
		printf("READ CAPACITY: %lu * %lu = %llu\n",
d612 7
d661 3
d694 2
a695 1
			printf("tur failed without sense data\n");
d700 1
a700 2
	if (debug)
		printf("tur completed\n");
a732 3
					if (debug)
						printf("\n");

d734 2
a735 2
					    delm->channel, delm->target);
					printf(" ");
@


1.4
log
@Add initial blink/unblink harness.
Fix INQUIRY namespace polution.
Little clean up and new debug messages.
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.3 2005/04/04 17:37:17 marco Exp $       */
d74 1
a74 1
	char inq[36];
d210 2
a211 1
						    delm->target, &inq[0]);
d617 1
a617 1
bio_pt_inquire(u_int8_t c, u_int8_t t, u_int8_t *inq)
d628 1
a628 1
	bpt.cdb[4] = 36;   /* LENGTH  */
d630 1
a630 1
	bpt.datalen = 36;  /* minimum INQ size */
d643 3
a645 1
			printf("inquiry failed without sense data\n");
d650 2
a651 11
	if (debug) {
		printf("INQUIRY: ");
		printf("c: %u t: %u INQUIRY:", c, t);
		for (i = 0;  i < bpt.datalen; i++) {
			if (i < 8)
				printf("%0x ", inq[i]);
			else
				printf("%c", inq[i] < ' ' ? ' ' : inq[i]);
		}
		printf("\n");
	}
d702 1
a702 1
	u_int8_t inq[36];
d709 4
a712 2
			if (bio_pt_inquire(c, t, &inq[0])) {
				printf("disk %u: c: %u t: %u\n", d, c, t);
d719 13
d734 2
a735 11
		}
	}

	/* silly to do this here instead of in the for loop */
	SLIST_FOREACH(delm, &devices, next) {
		/* FIXME check the return value */
		delm->capacity = bio_pt_readcap(delm->channel, delm->target);
		if (debug)
			printf("%p: %u %u %u %llu\n", delm, delm->id,
			    delm->channel, delm->target, delm->capacity);
	}
d753 65
@


1.3
log
@use .h
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.2 2005/03/30 08:06:03 dlg Exp $       */
d29 1
d39 1
d86 1
a86 1
	while ((ch = getopt(argc, argv, "a:Dd:ehl:pst:u:")) != -1) {
d92 4
d107 1
a107 1
			subfunc |= ENUM;
d166 9
d200 1
a200 1
				if (subfunc & READCAP) {
d207 1
a207 1
				if (subfunc & INQUIRY) {
d214 1
a214 1
				if (subfunc & TUR) {
d221 1
a221 1
				if (subfunc & ENUM)
d236 7
a242 2
	fprintf(stderr, "usage: %s [-Dehpt] [-a alarm function] [-s get status]"
	    "[-t passthrough] [-l device list] [-u go/stop function ] "
d286 1
a286 1
		return (INQUIRY);
d291 1
a291 1
		return (ENUM);
d296 1
a296 1
		return (READCAP);
d301 1
a301 1
		return (TUR);
d445 41
d595 3
d641 2
d677 1
d688 2
d708 1
a708 1
	unsigned char inq[36];
@


1.2
log
@update copyright for marco who says i can have the free commit
@
text
@d1 1
a1 1
/* $OpenBSD: bioctl.c,v 1.1 2005/03/29 22:04:21 marco Exp $       */
a28 5
#include <sys/ioctl.h>
#include <sys/param.h>
#include <sys/queue.h>
#include <scsi/scsi_disk.h>

d34 4
d40 4
a43 33
#define READCAP 0x01
#define ENUM    0x02
#define TUR     0x04
#define INQUIRY 0x08

struct read_cap {
	u_int32_t		maxlba;
	u_int32_t		bsize;
};

struct dev {
	SLIST_ENTRY(dev)	next;
	u_int16_t		id;
	u_int8_t		channel;
	u_int8_t		target;
	u_int64_t		capacity;
};

void		usage(void);
void		cleanup(void);
u_int64_t	parse_passthru(char *);
void		parse_devlist(char *);
void		print_sense(u_int8_t *, u_int8_t);

int		bio_get_capabilities(bioc_capabilities *);
void		bio_alarm(char *);
void		bio_ping(void);
void		bio_startstop(char *, u_int8_t, u_int8_t);
void		bio_status(void);
u_int64_t	bio_pt_readcap(u_int8_t, u_int8_t);
u_int32_t	bio_pt_inquire(u_int8_t, u_int8_t, u_int8_t *);
u_int32_t	bio_pt_tur(u_int8_t, u_int8_t);
void		bio_pt_enum(void);
a51 2
char *bio_device = "/dev/bio";

a56 1
#define PARSELIST (0x8000000000000000llu)
@


1.1
log
@adding initial bioctl code

ok mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD$       */
d3 1
a3 1
 * Copyright (c) 2004 Marco Peereboom
@

