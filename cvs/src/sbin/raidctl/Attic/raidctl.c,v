head	1.32;
access;
symbols
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.6
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.8
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2012.04.06.15.54.58;	author jsing;	state dead;
branches;
next	1.31;

1.31
date	2010.09.24.00.11.15;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.12.15.29.24;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.02.15.19.24;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.21.16.33.09;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.02.18.07.03;	author ray;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.02.21.38.56;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.14.17.17.11;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.17.02.14.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.21.15.27.18;	author avsm;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.06.22.55.32;	author avsm;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.13.15.59.22;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.13.09.09.27;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.09.08.13.09;	author todd;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.31.13.12.09;	author tdeval;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.29.14.26.59;	author tdeval;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.22.14.56.58;	author tdeval;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.19.15.05.46;	author tdeval;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.19.08.38.40;	author tdeval;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.02.21.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.18.03.45.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.20.23.37;	author tdeval;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.29.21.54.57;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.07.18.26.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.04.14.59.49;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.11.18.03.45;	author peter;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.07.14.51.41;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.21.51.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.49.44;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Put raidctl in the attic.
@
text
@/*	$OpenBSD: raidctl.c,v 1.31 2010/09/24 00:11:15 deraadt Exp $	*/
/*      $NetBSD: raidctl.c,v 1.27 2001/07/10 01:30:52 lukem Exp $   */

/*-
 * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Greg Oster
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This program is a re-write of the original rf_ctrl program
 * distributed by CMU with RAIDframe 1.1.
 *
 * This program is the userland interface to the RAIDframe kernel
 * driver in Net/OpenBSD.
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#ifdef NETBSD
#include <sys/disklabel.h>
#endif

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "rf_raidframe.h"

extern  char *__progname;

typedef struct {
	int	fd;
	int	id;
} fdidpair;

int     main(int, char *[]);
void	do_ioctl(int, u_long, void *, const char *);
static  void rf_configure(fdidpair *, char*, int);
static  const char *device_status(RF_DiskStatus_t);
static  void rf_get_device_status(fdidpair *, int);
static	void rf_output_configuration(fdidpair *, int);
static  void get_component_number(fdidpair *, char *, int *, int *);
static  void rf_fail_disk(fdidpair *, char *, int);
static  void usage(void);
static  void get_component_label(fdidpair *, char *);
static  void set_component_label(fdidpair *, char *);
static  void init_component_labels(fdidpair *, int);
static  void set_autoconfig(fdidpair *, char *);
static  void add_hot_spare(fdidpair *, char *);
static  void remove_hot_spare(fdidpair *, char *);
static  void rebuild_in_place(fdidpair *, char *);
static  void check_status(fdidpair *,int,int);
static  void check_parity(fdidpair *,int,int);
static  void do_meter(fdidpair *, int, u_long);
static  void get_bar(char *, double, int);
static  void get_time_string(char *, int);
static  int open_device(fdidpair **, char *);
static  int get_all_devices(char ***, const char *);

int verbose;
int do_all;

int
main(int argc, char *argv[])
{
	int ch;
	int num_options;
	unsigned int action;
	char config_filename[PATH_MAX];
	char name[PATH_MAX];
	char component[PATH_MAX];
	char autoconf[10];
	int do_output;
	int do_recon;
	int do_rewrite;
	int serial_number;
	int i, nfd;
	fdidpair *fds;
	int force;
	u_long meter;
	const char *actionstr;

	num_options = 0;
	action = 0;
	meter = 0;
	do_output = 0;
	do_recon = 0;
	do_rewrite = 0;
	do_all = 0;
	serial_number = 0;
	force = 0;
	actionstr = NULL;

	while ((ch = getopt(argc, argv, "a:A:Bc:C:f:F:g:GiI:l:r:R:sSpPuv"))
	       != -1)
		switch(ch) {
		case 'a':
			action = RAIDFRAME_ADD_HOT_SPARE;
			if (strlcpy(component, optarg, sizeof component) >= sizeof(component))
				errx(1, "-a arg too long");	
			num_options++;
			break;
		case 'A':
			action = RAIDFRAME_SET_AUTOCONFIG;
			if (strlcpy(autoconf, optarg, sizeof(autoconf)) >= sizeof(autoconf))
				errx(1, "-A arg too long");
			num_options++;
			break;
		case 'B':
			action = RAIDFRAME_COPYBACK;
			num_options++;
			break;
		case 'c':
			action = RAIDFRAME_CONFIGURE;
			if (strlcpy(config_filename, optarg, sizeof config_filename) >=
			      sizeof(config_filename))
				errx(1, "-c arg too long");
			force = 0;
			num_options++;
			break;
		case 'C':
			if (strlcpy(config_filename, optarg, sizeof config_filename) >=
			      sizeof(config_filename))
				errx(1, "-C arg too long");
			action = RAIDFRAME_CONFIGURE;
			force = 1;
			num_options++;
			break;
		case 'f':
			action = RAIDFRAME_FAIL_DISK;
			if (strlcpy(component, optarg, sizeof component) >= sizeof(component))
				errx(1, "-f arg too long");
			do_recon = 0;
			num_options++;
			break;
		case 'F':
			action = RAIDFRAME_FAIL_DISK;
			if (strlcpy(component, optarg, sizeof component) >= sizeof(component))
				errx(1, "-F arg too long");
			do_recon = 1;
			num_options++;
			break;
		case 'g':
			action = RAIDFRAME_GET_COMPONENT_LABEL;
			if (strlcpy(component, optarg, sizeof component) >= sizeof(component))
				errx(1, "-g arg too long");
			num_options++;
			break;
		case 'G':
			action = RAIDFRAME_GET_INFO;
			do_output = 1;
			num_options++;
			break;
		case 'i':
			action = RAIDFRAME_REWRITEPARITY;
			num_options++;
			break;
		case 'I':
			action = RAIDFRAME_INIT_LABELS;
			serial_number = atoi(optarg);
			num_options++;
			break;
		case 'l':
			action = RAIDFRAME_SET_COMPONENT_LABEL;
			if (strlcpy(component, optarg, sizeof component) >= sizeof(component))
				errx(1, "-l arg too long");
			num_options++;
			break;
		case 'r':
			action = RAIDFRAME_REMOVE_HOT_SPARE;
			if (strlcpy(component, optarg, sizeof component) >= sizeof(component))
				errx(1, "-r arg too long");
			num_options++;
			break;
		case 'R':
			if (strlcpy(component, optarg, sizeof component) >= sizeof(component))
				errx(1, "-R arg too long");
			action = RAIDFRAME_REBUILD_IN_PLACE;
			num_options++;
			break;
		case 's':
			action = RAIDFRAME_GET_INFO;
			num_options++;
			break;
		case 'S':
			action = RAIDFRAME_CHECK_RECON_STATUS_EXT;
			num_options++;
			break;
		case 'p':
			action = RAIDFRAME_CHECK_PARITY;
			num_options++;
			break;
		case 'P':
			action = RAIDFRAME_CHECK_PARITY;
			do_rewrite = 1;
			num_options++;
			break;
		case 'u':
			action = RAIDFRAME_SHUTDOWN;
			num_options++;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if ((num_options > 1) || (argc == 0))
		usage();

	if (strlcpy(name, argv[0], sizeof name) >= sizeof(name))
		errx(1, "device name too long");

	if ((nfd = open_device(&fds, name)) < 1) {
		/* No configured raid device */
		free(fds);
		return (0);
	}

	if (do_all) {
		switch(action) {
		case RAIDFRAME_ADD_HOT_SPARE:
		case RAIDFRAME_REMOVE_HOT_SPARE:
		case RAIDFRAME_CONFIGURE:
		case RAIDFRAME_SET_AUTOCONFIG:
		case RAIDFRAME_FAIL_DISK:
		case RAIDFRAME_SET_COMPONENT_LABEL:
		case RAIDFRAME_GET_COMPONENT_LABEL:
		case RAIDFRAME_INIT_LABELS:
		case RAIDFRAME_REBUILD_IN_PLACE:
			errx(1,
			    "This action doesn't work with the 'all' device");
			break;
		default:
			break;
		}
	}

	switch(action) {
	case RAIDFRAME_ADD_HOT_SPARE:
		add_hot_spare(fds, component);
		break;
	case RAIDFRAME_REMOVE_HOT_SPARE:
		remove_hot_spare(fds, component);
		break;
	case RAIDFRAME_CONFIGURE:
		rf_configure(fds, config_filename, force);
		break;
	case RAIDFRAME_SET_AUTOCONFIG:
		set_autoconfig(fds, autoconf);
		break;
	case RAIDFRAME_COPYBACK:
		i = nfd;
		while (i--) {
			do_ioctl(fds[i].fd, RAIDFRAME_COPYBACK, NULL,
				 "RAIDFRAME_COPYBACK");
		}
		actionstr = "Copyback";
		meter = RAIDFRAME_CHECK_COPYBACK_STATUS_EXT;
		break;
	case RAIDFRAME_FAIL_DISK:
		rf_fail_disk(fds, component, do_recon);
		break;
	case RAIDFRAME_SET_COMPONENT_LABEL:
		set_component_label(fds, component);
		break;
	case RAIDFRAME_GET_COMPONENT_LABEL:
		get_component_label(fds, component);
		break;
	case RAIDFRAME_INIT_LABELS:
		init_component_labels(fds, serial_number);
		break;
	case RAIDFRAME_REWRITEPARITY:
		i = nfd;
		while (i--) {
			do_ioctl(fds[i].fd, RAIDFRAME_REWRITEPARITY, NULL,
				 "RAIDFRAME_REWRITEPARITY");
		}
		actionstr = "Parity Re-Write";
		meter = RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT;
		break;
	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
		check_status(fds, nfd, 1);
		break;
	case RAIDFRAME_GET_INFO:
		if (do_output)
			rf_output_configuration(fds, nfd);
		else
			rf_get_device_status(fds, nfd);
		break;
	case RAIDFRAME_REBUILD_IN_PLACE:
		rebuild_in_place(fds, component);
		break;
	case RAIDFRAME_CHECK_PARITY:
		check_parity(fds, nfd, do_rewrite);
		break;
	case RAIDFRAME_SHUTDOWN:
		i = nfd;
		while (i--) {
			do_ioctl(fds[i].fd, RAIDFRAME_SHUTDOWN, NULL,
				 "RAIDFRAME_SHUTDOWN");
		}
		break;
	default:
		break;
	}

	if (verbose && meter) {
		sleep(3);	/* XXX give the action a chance to start */
		printf("%s status:\n", actionstr);
		do_meter(fds, nfd, meter);
	}

	i = nfd;
	while (i--)
		close(fds[i].fd);

	free(fds);
	return (0);
}

void
do_ioctl(int fd, unsigned long command, void *arg, const char *ioctl_name)
{
	if (ioctl(fd, command, arg) < 0)
		errx(1, "ioctl (%s) failed", ioctl_name);
}


static void
rf_configure(fdidpair *fds, char *config_file, int force)
{
	void *generic;
	RF_Config_t cfg;

	if (rf_MakeConfig(config_file, &cfg) != 0)
		errx(1, "unable to create RAIDframe configuration structure");
	
	cfg.force = force;

	/*
	 * Note the extra level of redirection needed here, since
	 * what we really want to pass in is a pointer to the pointer to
	 * the configuration structure.
	 */

	generic = (void *) &cfg;
	do_ioctl(fds->fd, RAIDFRAME_CONFIGURE, &generic, "RAIDFRAME_CONFIGURE");
}

static const char *
device_status(RF_DiskStatus_t status)
{

	switch (status) {
	case rf_ds_optimal:
		return ("optimal");
	case rf_ds_failed:
		return ("failed");
	case rf_ds_reconstructing:
		return ("reconstructing");
	case rf_ds_dist_spared:
		return ("dist_spared");
	case rf_ds_spared:
		return ("spared");
	case rf_ds_spare:
		return ("spare");
	case rf_ds_used_spare:
		return ("used_spare");
	default:
		return ("UNKNOWN");
	}
	/* NOTREACHED */
}

static void
rf_get_device_status(fdidpair *fds, int nfd)
{
	RF_DeviceConfig_t device_config;
	void *cfg_ptr;
	int is_clean;
	int i,j;

	cfg_ptr = &device_config;

	i = nfd;
	while (i--) {
		do_ioctl(fds[i].fd, RAIDFRAME_GET_INFO, &cfg_ptr,
			 "RAIDFRAME_GET_INFO");

		printf("raid%d Components:\n", fds[i].id);
		for (j = 0; j < device_config.ndevs; j++) {
			printf("%20s: %s\n", device_config.devs[j].devname,
			       device_status(device_config.devs[j].status));
		}
		if (device_config.nspares > 0) {
			printf("Spares:\n");
			for (j = 0; j < device_config.nspares; j++) {
				printf("%20s: %s\n",
				       device_config.spares[j].devname,
				       device_status(device_config.spares[j].status));
			}
		} else {
			printf("No spares.\n");
		}
		if (verbose) {
			for(j=0; j < device_config.ndevs; j++) {
				if (device_config.devs[j].status ==
				    rf_ds_optimal) {
					get_component_label(&fds[i],
					   device_config.devs[j].devname);
				} else {
					printf("%s status is: %s.  "
					   "Skipping label.\n",
					   device_config.devs[j].devname,
					   device_status(device_config.devs[j].status));
				}
			}

			if (device_config.nspares > 0) {
				for(j=0; j < device_config.nspares; j++) {
					if ((device_config.spares[j].status ==
					     rf_ds_optimal) ||
					    (device_config.spares[j].status ==
					     rf_ds_used_spare)) {
						get_component_label(&fds[i],
						   device_config.spares[j].devname);
					} else {
						printf("%s status is: %s.  "
						   "Skipping label.\n",
						   device_config.spares[j].devname,
						   device_status(device_config.spares[j].status));
					}		
				}
			}
		}

		do_ioctl(fds[i].fd, RAIDFRAME_CHECK_PARITY, &is_clean,
			 "RAIDFRAME_CHECK_PARITY");
		if (is_clean) {
			printf("Parity status: clean\n");
		} else {
			printf("Parity status: DIRTY\n");
		}
		check_status(&fds[i], 1, 0);
	}
}

static void
rf_output_configuration(fdidpair *fds, int nfd)
{
	RF_DeviceConfig_t device_config;
	void *cfg_ptr;
	int i,j;
	RF_ComponentLabel_t component_label;
	void *label_ptr;
	int component_num;
	int num_cols;
	char name[PATH_MAX];

	cfg_ptr = &device_config;

	i = nfd;
	while (i--) {
		snprintf(name, PATH_MAX, "/dev/raid%dc", fds[i].id);

		printf("# raidctl config file for %s\n", name);
		printf("\n");
		do_ioctl(fds[i].fd, RAIDFRAME_GET_INFO, &cfg_ptr,
			 "RAIDFRAME_GET_INFO");

		printf("START array\n");
		printf("# numRow numCol numSpare\n");
		printf("%d %d %d\n", device_config.rows, device_config.cols,
		    device_config.nspares);
		printf("\n");

		printf("START disks\n");
		for(j = 0; j < device_config.ndevs; j++)
			printf("%s\n", device_config.devs[j].devname);
		printf("\n");

		if (device_config.nspares > 0) {
			printf("START spare\n");
			for(j = 0; j < device_config.nspares; j++)
				printf("%s\n", device_config.spares[j].devname);
			printf("\n");
		}

		for(j = 0; j < device_config.ndevs; j++) {
			if (device_config.devs[j].status == rf_ds_optimal)
				break;
		}
		if (j == device_config.ndevs) {
			printf("# WARNING: no optimal components; using %s\n",
			    device_config.devs[0].devname);
			j = 0;
		}
		get_component_number(&fds[i], device_config.devs[j].devname,
		    &component_num, &num_cols);
		memset(&component_label, 0, sizeof(RF_ComponentLabel_t));
		component_label.row = component_num / num_cols;
		component_label.column = component_num % num_cols;
		label_ptr = &component_label;
		do_ioctl(fds[i].fd, RAIDFRAME_GET_COMPONENT_LABEL, &label_ptr,
			 "RAIDFRAME_GET_COMPONENT_LABEL");

		printf("START layout\n");
		printf(
		    "# sectPerSU SUsPerParityUnit SUsPerReconUnit "
		    "RAID_level_%c\n",
		    (char) component_label.parityConfig);
		printf("%d %d %d %c\n",
		    component_label.sectPerSU, component_label.SUsPerPU,
		    component_label.SUsPerRU,
		    (char) component_label.parityConfig);
		printf("\n");

		printf("START queue\n");
		printf("fifo %d\n", device_config.maxqdepth);
	}
}

static void
get_component_number(fdidpair *fds, char *component_name, int *component_number,
		     int *num_columns)
{
	RF_DeviceConfig_t device_config;
	void *cfg_ptr;
	int i;
	int found;

	*component_number = -1;
		
	/* Assuming a full path spec... */
	cfg_ptr = &device_config;
	do_ioctl(fds->fd, RAIDFRAME_GET_INFO, &cfg_ptr, "RAIDFRAME_GET_INFO");

	*num_columns = device_config.cols;

	found = 0;
	for (i = 0; i < device_config.ndevs; i++) {
		if (strncmp(component_name, device_config.devs[i].devname,
			    PATH_MAX) == 0) {
			found = 1;
			*component_number = i;
		}
	}
	if (!found) { /* maybe it's a spare? */
		for (i = 0; i < device_config.nspares; i++) {
			if (strncmp(component_name,
				    device_config.spares[i].devname,
				    PATH_MAX) == 0) {
				found = 1;
				*component_number = i + device_config.ndevs;
				/* the way spares are done should
				   really change... */
				*num_columns = device_config.cols +
					device_config.nspares;
			}
		}
	}

	if (!found)
		errx(1, "%s is not a component of this device", component_name);
}

static void
rf_fail_disk(fdidpair *fds, char *component_to_fail, int do_recon)
{
	struct rf_recon_req recon_request;
	int component_num;
	int num_cols;

	get_component_number(fds, component_to_fail, &component_num, &num_cols);

	recon_request.row = component_num / num_cols;
	recon_request.col = component_num % num_cols;
	if (do_recon) {
		recon_request.flags = RF_FDFLAGS_RECON;
	} else {
		recon_request.flags = RF_FDFLAGS_NONE;
	}
	do_ioctl(fds->fd, RAIDFRAME_FAIL_DISK, &recon_request,
		 "RAIDFRAME_FAIL_DISK");
	if (do_recon && verbose) {
		printf("Reconstruction status:\n");
		sleep(3); /* XXX give reconstruction a chance to start */
		do_meter(fds, 1, RAIDFRAME_CHECK_RECON_STATUS_EXT);
	}
}

static void
get_component_label(fdidpair *fds, char *component)
{
	RF_ComponentLabel_t component_label;
	void *label_ptr;
	int component_num;
	int num_cols;

	get_component_number(fds, component, &component_num, &num_cols);

	memset(&component_label, 0, sizeof(RF_ComponentLabel_t));
	component_label.row = component_num / num_cols;
	component_label.column = component_num % num_cols;

	label_ptr = &component_label;
	do_ioctl(fds->fd, RAIDFRAME_GET_COMPONENT_LABEL, &label_ptr,
		 "RAIDFRAME_GET_COMPONENT_LABEL");

	printf("Component label for %s:\n", component);

	printf("   Row: %d, Column: %d, Num Rows: %d, Num Columns: %d\n",
	       component_label.row, component_label.column,
	       component_label.num_rows, component_label.num_columns);
	printf("   Version: %d, Serial Number: %d, Mod Counter: %d\n",
	       component_label.version, component_label.serial_number,
	       component_label.mod_counter);
	printf("   Clean: %s, Status: %d\n",
	       component_label.clean ? "Yes" : "No",
	       component_label.status);
	printf("   sectPerSU: %d, SUsPerPU: %d, SUsPerRU: %d\n",
	       component_label.sectPerSU, component_label.SUsPerPU,
	       component_label.SUsPerRU);
	printf("   Queue size: %d, blocksize: %d, numBlocks: %d\n",
	       component_label.maxOutstanding, component_label.blockSize,
	       component_label.numBlocks);
	printf("   RAID Level: %c\n", (char) component_label.parityConfig);
	printf("   Autoconfig: %s\n",
	       component_label.autoconfigure ? "Yes" : "No");
	printf("   Root partition: %s\n",
	       component_label.root_partition ? "Yes" : "No");
	printf("   Last configured as: raid%d\n", component_label.last_unit);
}

static void
set_component_label(fdidpair *fds, char *component)
{
	RF_ComponentLabel_t component_label;
	int component_num;
	int num_cols;

	get_component_number(fds, component, &component_num, &num_cols);

	/* XXX This is currently here for testing, and future expandability */

	component_label.version = 1;
	component_label.serial_number = 123456;
	component_label.mod_counter = 0;
	component_label.row = component_num / num_cols;
	component_label.column = component_num % num_cols;
	component_label.num_rows = 0;
	component_label.num_columns = 5;
	component_label.clean = 0;
	component_label.status = 1;
	
	do_ioctl(fds->fd, RAIDFRAME_SET_COMPONENT_LABEL, &component_label,
		 "RAIDFRAME_SET_COMPONENT_LABEL");
}


static void
init_component_labels(fdidpair *fds, int serial_number)
{
	RF_ComponentLabel_t component_label;

	component_label.version = 0;
	component_label.serial_number = serial_number;
	component_label.mod_counter = 0;
	component_label.row = 0;
	component_label.column = 0;
	component_label.num_rows = 0;
	component_label.num_columns = 0;
	component_label.clean = 0;
	component_label.status = 0;
	
	do_ioctl(fds->fd, RAIDFRAME_INIT_LABELS, &component_label,
		 "RAIDFRAME_SET_COMPONENT_LABEL");
}

static void
set_autoconfig(fdidpair *fds, char *autoconf)
{
	int auto_config;
	int root_config;

	auto_config = 0;
	root_config = 0;

	if (strncasecmp(autoconf, "root", 4) == 0) {
		root_config = 1;
	}

	if ((strncasecmp(autoconf, "yes", 3) == 0) ||
	    root_config == 1) {
		auto_config = 1;
	}

	do_ioctl(fds->fd, RAIDFRAME_SET_AUTOCONFIG, &auto_config,
		 "RAIDFRAME_SET_AUTOCONFIG");

	do_ioctl(fds->fd, RAIDFRAME_SET_ROOT, &root_config,
		 "RAIDFRAME_SET_ROOT");

	printf("raid%d: Autoconfigure: %s\n", fds->id,
	       auto_config ? "Yes" : "No");

	if (root_config == 1) {
		printf("raid%d: Root: %s\n", fds->id,
		       auto_config ? "Yes" : "No");
	}
}

static void
add_hot_spare(fdidpair *fds, char *component)
{
	RF_SingleComponent_t hot_spare;

	hot_spare.row = 0;
	hot_spare.column = 0;
	strlcpy(hot_spare.component_name, component,
		sizeof(hot_spare.component_name));
	
	do_ioctl(fds->fd, RAIDFRAME_ADD_HOT_SPARE, &hot_spare,
		 "RAIDFRAME_ADD_HOT_SPARE");
}

static void
remove_hot_spare(fdidpair *fds, char *component)
{
	RF_SingleComponent_t hot_spare;
	int component_num;
	int num_cols;

	get_component_number(fds, component, &component_num, &num_cols);

	hot_spare.row = component_num / num_cols;
	hot_spare.column = component_num % num_cols;

	strlcpy(hot_spare.component_name, component,
		sizeof(hot_spare.component_name));
	
	do_ioctl(fds->fd, RAIDFRAME_REMOVE_HOT_SPARE, &hot_spare,
		 "RAIDFRAME_REMOVE_HOT_SPARE");
}

static void
rebuild_in_place(fdidpair *fds, char *component)
{
	RF_SingleComponent_t comp;
	int component_num;
	int num_cols;

	get_component_number(fds, component, &component_num, &num_cols);

	comp.row = 0;
	comp.column = component_num;
	strlcpy(comp.component_name, component, sizeof(comp.component_name));
	
	do_ioctl(fds->fd, RAIDFRAME_REBUILD_IN_PLACE, &comp,
		 "RAIDFRAME_REBUILD_IN_PLACE");

	if (verbose) {
		printf("Reconstruction status:\n");
		sleep(3); /* XXX give reconstruction a chance to start */
		do_meter(fds, 1, RAIDFRAME_CHECK_RECON_STATUS_EXT);
	}

}

static void
check_parity(fdidpair *fds, int nfd, int do_rewrite)
{
	int i, is_clean, all_dirty, was_dirty;
	int percent_done;
	char dev_name[PATH_MAX];

	all_dirty = 0;
	i = nfd;
	while (i--) {
		is_clean = 0;
		percent_done = 0;
		snprintf(dev_name, PATH_MAX, "raid%d", fds[i].id);

		do_ioctl(fds[i].fd, RAIDFRAME_CHECK_PARITY, &is_clean,
		 	"RAIDFRAME_CHECK_PARITY");
		if (is_clean) {
			printf("%s: Parity status: clean\n", dev_name);
		} else {
			all_dirty |= 1 << fds[i].id;
			printf("%s: Parity status: DIRTY\n", dev_name);
			if (do_rewrite) {
				printf("%s: Initiating re-write of parity\n",
				    dev_name);
				do_ioctl(fds[i].fd, RAIDFRAME_REWRITEPARITY,
				    NULL, "RAIDFRAME_REWRITEPARITY");
			} else {
				/* parity is wrong, and is not being fixed. */
				exit(1);
			}
		}
	}

	if (do_all)
		strncpy(dev_name, "all raid", PATH_MAX);

	was_dirty = all_dirty;
	while (all_dirty) {
		sleep(3); /* wait a bit... */
		if (verbose) {
			printf("Parity Re-write status:\n");
			do_meter(fds, nfd,
			    RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT);
			all_dirty = 0;
		} else {
			i = nfd;
			while (i--) {
				do_ioctl(fds[i].fd,
				 	RAIDFRAME_CHECK_PARITYREWRITE_STATUS,
				 	&percent_done,
				 	"RAIDFRAME_CHECK_PARITYREWRITE_STATUS"
				 	);
				if (percent_done == 100) {
					all_dirty &= ~(1 << fds[i].id);
				}
			}
		}
	}
	if (verbose && was_dirty)
		printf("%s: Parity Re-write complete\n", dev_name);
}


static void
check_status(fdidpair *fds, int nfd, int meter)
{
	int i;
	int recon_percent_done = 0;
	int parity_percent_done = 0;
	int copyback_percent_done = 0;
	int do_recon = 0;
	int do_parity = 0;
	int do_copyback = 0;
	u_long check = 0;

	i = nfd;
	while (i--) {
		if (meter) {
			printf("raid%d Status:\n", fds[i].id);
		}
		do_ioctl(fds[i].fd, RAIDFRAME_CHECK_RECON_STATUS,
			 &recon_percent_done,
			 "RAIDFRAME_CHECK_RECON_STATUS");
		printf("Reconstruction is %d%% complete.\n",
			recon_percent_done);
		if (recon_percent_done < 100) {
			do_recon |= 1 << fds[i].id;
		}
		do_ioctl(fds[i].fd, RAIDFRAME_CHECK_PARITYREWRITE_STATUS,
			 &parity_percent_done,
			 "RAIDFRAME_CHECK_PARITYREWRITE_STATUS");
		printf("Parity Re-write is %d%% complete.\n",
			parity_percent_done);
		if (parity_percent_done < 100) {
			do_parity |= 1 << fds[i].id;
		}
		do_ioctl(fds[i].fd, RAIDFRAME_CHECK_COPYBACK_STATUS,
			 &copyback_percent_done,
			 "RAIDFRAME_CHECK_COPYBACK_STATUS");
		printf("Copyback is %d%% complete.\n",
			copyback_percent_done);
		if (copyback_percent_done < 100) {
			do_copyback |= 1 << fds[i].id;
		}
	}

	if (meter && verbose) {
		/* These 3 should be mutually exclusive at this point */
		if (do_recon) {
			printf("Reconstruction status:\n");
			check = RAIDFRAME_CHECK_RECON_STATUS_EXT;
		} else if (do_parity) {
			printf("Parity Re-write status:\n");
			check = RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT;
		} else if (do_copyback) {
			printf("Copyback status:\n");
			check = RAIDFRAME_CHECK_COPYBACK_STATUS_EXT;
		}
		do_meter(fds, nfd, check);
	}
}

const char *tbits = "|/-\\";

static void
do_meter(fdidpair *fds, int nfd, u_long option)
{
	int percent_done;
	int start_value;
	RF_ProgressInfo_t *progressInfo;
	void *pInfoPtr;
	struct timeval start_time;
	struct timeval current_time;
	double elapsed;
	int elapsed_sec;
	int elapsed_usec;
	int progress_total, progress_completed;
	int simple_eta, last_eta;
	double rate;
	int amount;
	int tbit_value;
	char buffer[1024];
	char bar_buffer[1024];
	char eta_buffer[1024];
	int not_done;
	int i;

	not_done = 0;
	percent_done = 0;
	tbit_value = 0;
	start_value = 0;
	last_eta = 0;
	progress_total = progress_completed = 0;
	progressInfo = calloc(nfd, sizeof(RF_ProgressInfo_t));
	if (!progressInfo)
		err(1, "calloc");

	if (gettimeofday(&start_time, NULL))
		err(1, "gettimeofday");

	current_time = start_time;

	i = nfd;
	while (i--) {
		pInfoPtr = &progressInfo[i];
		do_ioctl(fds[i].fd, option, &pInfoPtr, "");
		start_value += progressInfo[i].completed;
		progress_total += progressInfo[i].total;

		if (progressInfo[i].completed < progressInfo[i].total) {
			not_done |= 1 << i;
		}
	}

	while (not_done) {
		progress_completed = 0;
		percent_done = 0;
		amount = 0;

		i = nfd;
		while (i--) {
			pInfoPtr = &progressInfo[i];
			do_ioctl(fds[i].fd, option, &pInfoPtr, "");
			progress_completed += progressInfo[i].completed;

			if (progressInfo[i].completed >=
			    progressInfo[i].total) {
				not_done &= ~(1 << i);
			}
		}
		percent_done = (progress_completed * 100) / progress_total;
		amount = progress_completed - start_value;

		get_bar(bar_buffer, percent_done, 40);

		elapsed_sec =   current_time.tv_sec -
				start_time.tv_sec;
		elapsed_usec =  current_time.tv_usec -
				start_time.tv_usec;
		if (elapsed_usec < 0) {
			elapsed_usec += 1000000;
			elapsed_sec--;
		}

		elapsed = (double) elapsed_sec +
			  (double) elapsed_usec / 1000000.0;

		if (amount <= 0) { /* we don't do negatives (yet?) */
			amount = 0;
		}

		if (elapsed == 0)
			rate = 0.0;
		else
			rate = amount / elapsed;

		if (rate > 0.0) {
			simple_eta = (int)
				(((double)progress_total -
				  (double) progress_completed)
				 / rate);
		} else {
			simple_eta = -1;
		}

		if (simple_eta <= 0) {
			simple_eta = last_eta;
		} else {
			last_eta = simple_eta;
		}

		get_time_string(eta_buffer, simple_eta);

		snprintf(buffer, 1024,
			 "\r\t%3d%% |%s| ETA: %s %c",
			 percent_done, bar_buffer,
			 eta_buffer, tbits[tbit_value]);

		write(fileno(stdout), buffer, strlen(buffer));
		fflush(stdout);

		if (++tbit_value > 3)
			tbit_value = 0;

		if (not_done)
			sleep(2);

		if (gettimeofday(&current_time, NULL))
			err(1, "gettimeofday");
	}
	free(progressInfo);
	printf("\n");
}

/* 40 '*''s per line, then 40 ' ''s line. */
/* If you've got a screen wider than 160 characters, "tough" */

#define STAR_MIDPOINT 4*40
const char stars[] = "****************************************"
                     "****************************************"
                     "****************************************"
                     "****************************************"
                     "                                        "
                     "                                        "
                     "                                        "
                     "                                        ";

static void
get_bar(char *string, double percent, int max_strlen)
{
	int offset;

	if (max_strlen > STAR_MIDPOINT) {
		max_strlen = STAR_MIDPOINT;
	}
	offset = STAR_MIDPOINT -
		(int)((percent * max_strlen) / 100);
	if (offset < 0)
		offset = 0;
	snprintf(string, max_strlen, "%s", &stars[offset]);
}

static void
get_time_string(char *string, int simple_time)
{
	int minutes, seconds, hours;
	char hours_buffer[5];
	char minutes_buffer[5];
	char seconds_buffer[5];

	if (simple_time >= 0) {

		minutes = (int) simple_time / 60;
		seconds = ((int)simple_time - 60 * minutes);
		hours = minutes / 60;
		minutes = minutes - 60 * hours;
		
		if (hours > 0) {
			snprintf(hours_buffer, sizeof(hours_buffer),
				 "%02d:", hours);
		} else {
			snprintf(hours_buffer, sizeof(hours_buffer), "   ");
		}
		
		snprintf(minutes_buffer, sizeof(minutes_buffer),
			 "%02d:", minutes);
		snprintf(seconds_buffer, sizeof(seconds_buffer),
			 "%02d", seconds);
		snprintf(string, 1024, "%s%s%s",
			 hours_buffer, minutes_buffer, seconds_buffer);
	} else {
		snprintf(string, 1024, "   --:--");
	}
	
}

static int
open_device(fdidpair **devfd, char *name)
{
	int nfd, i;
 	struct stat st;
	char **devname;

	if (strcmp(name, "all") == 0) {
		do_all = 1;
		nfd = get_all_devices(&devname, "raid");
	} else {
		nfd = 1;
		if ((devname = malloc(sizeof(void*))) == NULL)
			err(1, "malloc");
		if ((devname[0] = malloc(PATH_MAX)) == NULL)
			err(1, "malloc");

		if ((name[0] == '/') || (name[0] == '.')) {
			/* they've (apparently) given a full path... */
			strlcpy(devname[0], name, PATH_MAX);
		} else {
			if (name[0] == '\0')
				errx(1, "invalid device");
			if (isdigit(name[strlen(name) - 1])) {
				snprintf(devname[0], PATH_MAX, "%s%s%c",
				    _PATH_DEV, name, 'a' + getrawpartition());		
			} else {
				snprintf(devname[0], PATH_MAX, "%s%s",
				    _PATH_DEV, name);
			}
		}
	}

	if ((*devfd = calloc(nfd, sizeof(fdidpair))) == NULL)
		errx(1, "malloc() error");

	i = nfd;
	while (i--) {
		if (((*devfd)[i].fd = open(devname[i], O_RDWR, 0640)) < 0)
			errx(1, "unable to open device file: %s", devname[i]);
		if (fstat((*devfd)[i].fd, &st) != 0)
			errx(errno, "fstat failure on: %s", devname[i]);
		if (!S_ISBLK(st.st_mode) && !S_ISCHR(st.st_mode))
			errx(EINVAL, "invalid device: %s", devname[i]);

		(*devfd)[i].id = RF_DEV2RAIDID(st.st_rdev);

		free(devname[i]);
	}

	if (devname != NULL)
		free(devname);

	return (nfd);
}

static int
get_all_devices(char ***diskarray, const char *genericname)
{
	int	i, numdevs, mib[2];
	size_t	len;
	char	*disks, *fp, *p;

	numdevs = 0;

	mib[0] = CTL_HW;
	mib[1] = HW_DISKNAMES;
	sysctl(mib, 2, NULL, &len, NULL, 0);
	if ((disks = malloc(len + 1)) == NULL)
		errx(1, "malloc() error");
	sysctl(mib, 2, disks, &len, NULL, 0);
	disks[len] = '\0';

	fp = disks;
	while ((fp = strstr((const char*)fp, genericname)) != NULL) {
		numdevs++;
		fp++;
	}

	*diskarray = (char**) calloc(numdevs, sizeof(void*));
	i = 0;
	fp = disks;
	while ((p = strsep(&fp, ",")) != NULL) {
		char *q = strchr(p, ':');

		if (q)
			*q = '\0';

		if (strstr((const char*)p, genericname) != NULL) {
			if (asprintf(&(*diskarray)[i++], "/dev/%s%c", p,
			    'a' + getrawpartition()) == -1)
				err(1, "asprintf");	
		}
	}

	free(disks);

	return (numdevs);
}

static void
usage(void)
{
	fprintf(stderr,
	    "usage: raidctl [-BGiPpSsuv] [-A [yes | no | root]] [-Cc config_file]\n");
	fprintf(stderr,
	    "               [-I serial_number] [-aFfgRr component] dev\n");
	exit(1);
	/* NOTREACHED */
}
@


1.31
log
@Now that HW_DISKNAMES returns xx0: or xx0:uid entries, we must truncate
the : and uid components out -- otherwise these two programs will work
poorly.
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.30 2009/11/12 15:29:24 deraadt Exp $	*/
@


1.30
log
@memory leak found by parfait; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.29 2008/06/26 05:42:06 ray Exp $	*/
d1206 5
@


1.29
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.28 2007/09/02 15:19:24 deraadt Exp $	*/
d1057 1
@


1.28
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.27 2007/02/21 16:33:09 jmc Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.27
log
@sort options; sync synopsis and usage()
from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.26 2006/11/02 18:07:03 ray Exp $	*/
d1162 1
a1162 1
	if ((*devfd = malloc(nfd * sizeof(fdidpair))) == NULL)
d1208 1
a1208 1
	*diskarray = (char**) malloc(numdevs * sizeof(void*));
@


1.26
log
@Error out on empty string passed as device name.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.25 2006/04/02 21:38:56 djm Exp $	*/
d1228 1
a1228 1
	    "usage: raidctl [-v] [-afFgrR component] [-BGipPsSu] [-cC config_file]\n");
d1230 1
a1230 1
	    "               [-A [yes | no | root]] [-I serial_number] dev\n");
@


1.25
log
@malloc(x * y) -> calloc(x, y) from adobriyan AT gmail.com, with tweaks
suggested by kjell@@; ok otto@@ pat@@ millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.24 2005/11/14 17:17:11 deraadt Exp $	*/
d1150 2
@


1.24
log
@use asprintf
and do fstat() on the opened fd, instead of stat() before open()
from dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.23 2004/07/17 02:14:33 deraadt Exp $	*/
d967 3
a969 2
	progressInfo = malloc(nfd * sizeof(RF_ProgressInfo_t));
	memset(&progressInfo[0], 0, nfd * sizeof(RF_ProgressInfo_t));
@


1.23
log
@some ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.22 2004/06/21 15:27:18 avsm Exp $	*/
d1140 4
a1143 2
		devname = malloc(sizeof(void*));
		devname[0] = malloc(PATH_MAX);
d1164 4
a1167 2
		if (stat(devname[i], &st) != 0)
			errx(errno, "stat failure on: %s", devname[i]);
a1170 2
		if (((*devfd)[i].fd = open(devname[i], O_RDWR, 0640)) < 0)
			errx(1, "unable to open device file: %s", devname[i]);
d1210 3
a1212 5
			int len = strlen(p) + 7;

			(*diskarray)[i] = (char*) malloc(len);
			snprintf((*diskarray)[i++], len, "/dev/%s%c", p,
				'a' + getrawpartition());
@


1.22
log
@dont compare int with NULL, compare to 0 instead, otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.21 2003/07/06 22:55:32 avsm Exp $	*/
d104 1
a104 3
main(argc, argv)
	int argc;
	char *argv[];
d366 1
a366 5
do_ioctl(fd, command, arg, ioctl_name)
	int fd;
	unsigned long command;
	void *arg;
	const char *ioctl_name;
d374 1
a374 4
rf_configure(fds, config_file, force)
	fdidpair *fds;
	char *config_file;
	int force;
d395 1
a395 2
device_status(status)
	RF_DiskStatus_t status;
d420 1
a420 3
rf_get_device_status(fds, nfd)
	fdidpair *fds;
	int nfd;
d493 1
a493 3
rf_output_configuration(fds, nfd)
	fdidpair *fds;
	int nfd;
d568 2
a569 5
get_component_number(fds, component_name, component_number, num_columns)
	fdidpair *fds;
	char *component_name;
	int *component_number;
	int *num_columns;
d612 1
a612 4
rf_fail_disk(fds, component_to_fail, do_recon)
	fdidpair *fds;
	char *component_to_fail;
	int do_recon;
d637 1
a637 3
get_component_label(fds, component)
	fdidpair *fds;
	char *component;
d680 1
a680 3
set_component_label(fds, component)
	fdidpair *fds;
	char *component;
d706 1
a706 3
init_component_labels(fds, serial_number)
	fdidpair *fds;
	int serial_number;
d725 1
a725 3
set_autoconfig(fds, autoconf)
	fdidpair *fds;
	char *autoconf;
d758 1
a758 3
add_hot_spare(fds, component)
	fdidpair *fds;
	char *component;
d772 1
a772 3
remove_hot_spare(fds, component)
	fdidpair *fds;
	char *component;
d791 1
a791 3
rebuild_in_place(fds, component)
	fdidpair *fds;
	char *component;
d815 1
a815 4
check_parity(fds, nfd, do_rewrite)
	fdidpair *fds;
	int nfd;
	int do_rewrite;
d878 1
a878 4
check_status(fds, nfd, meter)
	fdidpair *fds;
	int nfd;
	int meter;
d939 1
a939 4
do_meter(fds, nfd, option)
	fdidpair *fds;
	int nfd;
	u_long option;
d1080 1
a1080 4
get_bar(string, percent, max_strlen)
	char *string;
	double percent;
	int max_strlen;
d1095 1
a1095 3
get_time_string(string, simple_time)
	char *string;
	int simple_time;
d1129 1
a1129 3
open_device(devfd, name)
	fdidpair **devfd;
	char *name;
d1181 1
a1181 3
get_all_devices(diskarray, genericname)
	char	 ***diskarray;
	const char *genericname;
d1222 1
a1222 1
usage()
@


1.21
log
@error out instead of silently truncating command-line arguments if they
are too long
tdeval@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.20 2003/03/13 15:59:22 deraadt Exp $	*/
d253 1
a253 1
	if ((num_options > 1) || (argc == NULL))
@


1.20
log
@1 byte underflow; from tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.19 2003/03/13 09:09:27 deraadt Exp $	*/
d141 2
a142 1
			strlcpy(component, optarg, PATH_MAX);
d147 2
a148 1
			strlcpy(autoconf, optarg, sizeof(autoconf));
d157 3
a159 1
			strlcpy(config_filename, optarg, PATH_MAX);
d164 3
a166 1
			strlcpy(config_filename, optarg, PATH_MAX);
d173 2
a174 1
			strlcpy(component, optarg, PATH_MAX);
d180 2
a181 1
			strlcpy(component, optarg, PATH_MAX);
d187 2
a188 1
			strlcpy(component, optarg, PATH_MAX);
d207 2
a208 1
			strlcpy(component, optarg, PATH_MAX);
d213 2
a214 1
			strlcpy(component, optarg, PATH_MAX);
d218 2
a219 1
			strlcpy(component, optarg, PATH_MAX);
d256 2
a257 1
	strlcpy(name, argv[0], PATH_MAX);
@


1.19
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.18 2002/06/09 08:13:09 todd Exp $	*/
d1247 1
a1247 1
			int len = strlen(p) + 6;
@


1.18
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.17 2002/03/31 13:12:09 tdeval Exp $	*/
d1247 4
a1250 2
			(*diskarray)[i] = (char*) malloc(strlen(p) + 6);
			sprintf((*diskarray)[i++], "/dev/%s%c", p,
@


1.17
log
@grmbl, restore meter display.
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.16 2002/03/29 14:26:59 tdeval Exp $	*/
d40 2
a41 2
/* 
 * This program is a re-write of the original rf_ctrl program 
d136 1
a136 1
	while ((ch = getopt(argc, argv, "a:A:Bc:C:f:F:g:GiI:l:r:R:sSpPuv")) 
d196 1
a196 1
		case 'l': 
d241 1
a241 1
	if ((num_options > 1) || (argc == NULL)) 
d308 1
a308 1
			do_ioctl(fds[i].fd, RAIDFRAME_REWRITEPARITY, NULL, 
d380 1
a380 1
	/* 
d382 2
a383 2
	 * what we really want to pass in is a pointer to the pointer to 
	 * the configuration structure. 
d435 1
a435 1
			printf("%20s: %s\n", device_config.devs[j].devname, 
d442 1
a442 1
				       device_config.spares[j].devname, 
d464 1
a464 1
					if ((device_config.spares[j].status == 
d466 1
a466 1
					    (device_config.spares[j].status == 
d468 1
a468 1
						get_component_label(&fds[i], 
d557 2
a558 2
		printf("%d %d %d %c\n", 
		    component_label.sectPerSU, component_label.SUsPerPU, 
d598 1
a598 1
			if (strncmp(component_name, 
d605 1
a605 1
				*num_columns = device_config.cols + 
d634 1
a634 1
	do_ioctl(fds->fd, RAIDFRAME_FAIL_DISK, &recon_request, 
d666 1
a666 1
	       component_label.row, component_label.column, 
d672 1
a672 1
	       component_label.clean ? "Yes" : "No", 
d675 1
a675 1
	       component_label.sectPerSU, component_label.SUsPerPU, 
d681 1
a681 1
	printf("   Autoconfig: %s\n", 
d736 1
a736 1
 
d781 1
a781 1
	strlcpy(hot_spare.component_name, component, 
d802 1
a802 1
	strlcpy(hot_spare.component_name, component, 
d885 3
a887 3
				do_ioctl(fds[i].fd, 
				 	RAIDFRAME_CHECK_PARITYREWRITE_STATUS, 
				 	&percent_done, 
d922 1
a922 1
			 &recon_percent_done, 
d929 2
a930 2
		do_ioctl(fds[i].fd, RAIDFRAME_CHECK_PARITYREWRITE_STATUS, 
			 &parity_percent_done, 
d938 1
a938 1
			 &copyback_percent_done, 
d1047 1
a1047 1
		elapsed = (double) elapsed_sec + 
d1061 2
a1062 2
				(((double)progress_total - 
				  (double) progress_completed) 
d1068 1
a1068 1
		if (simple_eta <= 0) { 
d1084 1
a1084 1
		if (++tbit_value > 3) 
d1120 1
a1120 1
	offset = STAR_MIDPOINT - 
@


1.16
log
@cleanup variable and parameter usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.15 2002/02/22 14:56:58 tdeval Exp $	*/
d914 1
d951 1
d954 1
d957 1
d959 1
a959 1
		do_meter(fds, nfd, meter);
@


1.15
log
@Typo
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.14 2002/02/19 15:05:46 tdeval Exp $	*/
d110 1
a110 1
	unsigned long action;
a118 1
 	struct stat st;
a121 1
	int rawpart;
d132 1
d134 1
a949 2
			do_meter(fds, nfd,
				 RAIDFRAME_CHECK_RECON_STATUS_EXT);
a951 2
			do_meter(fds, nfd,
				 RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT);
a953 2
			do_meter(fds, nfd,
				 RAIDFRAME_CHECK_COPYBACK_STATUS_EXT);
d955 1
d991 1
d1164 1
a1164 1
	int nfd, rawpart, i;
a1180 1
				rawpart = getrawpartition();
d1182 1
a1182 1
				    _PATH_DEV, name, 'a' + rawpart);		
@


1.14
log
@no need to talk about parity re-write completion if no re-write was done.
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.13 2002/02/19 08:38:40 tdeval Exp $	*/
d440 1
a440 1
			for (j = 0; j < device_config.nspares; i++) {
@


1.13
log
@don't do anything if #raid=0 (just return)
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.12 2002/02/19 02:21:30 deraadt Exp $	*/
d841 1
a841 1
	int i, is_clean, all_dirty;
d874 1
d896 1
a896 1
	if (verbose)
@


1.12
log
@be QUIET by default, damn it
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.11 2002/02/18 03:45:27 deraadt Exp $	*/
d246 6
a251 1
	nfd = open_device(&fds, name);
@


1.11
log
@shorten usage
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.10 2002/02/17 20:23:37 tdeval Exp $	*/
d890 2
a891 1
	printf("%s: Parity Re-write complete\n", dev_name);
@


1.10
log
@raidctl can do some actions on 'all' configured raids now :
     -B : CopyBack
     -G : Generate config
     -i : Initialize
     -p : Check parity
     -P : Check and re-write parity
     -s : Status
     -S : Progress status
     -u : Unconfigure
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.9 2002/02/16 21:27:37 millert Exp $	*/
d1255 4
a1258 25
	fprintf(stderr, "usage: %s [-v] -a component dev\n", __progname);
	fprintf(stderr, "       %s [-v] -A [yes | no | root] dev\n", __progname);
	fprintf(stderr, "       %s [-v] -B dev\n", __progname);
	fprintf(stderr, "       %s [-v] -c config_file dev\n", __progname);
	fprintf(stderr, "       %s [-v] -C config_file dev\n", __progname);
	fprintf(stderr, "       %s [-v] -f component dev\n", __progname);
	fprintf(stderr, "       %s [-v] -F component dev\n", __progname);
	fprintf(stderr, "       %s [-v] -g component dev\n", __progname);
	fprintf(stderr, "       %s [-v] -G dev\n", __progname);
	fprintf(stderr, "       %s [-v] -i dev\n", __progname);
	fprintf(stderr, "       %s [-v] -I serial_number dev\n", __progname);
	fprintf(stderr, "       %s [-v] -p dev\n", __progname);
	fprintf(stderr, "       %s [-v] -P dev\n", __progname);
	fprintf(stderr, "       %s [-v] -r component dev\n", __progname); 
	fprintf(stderr, "       %s [-v] -R component dev\n", __progname);
	fprintf(stderr, "       %s [-v] -s dev\n", __progname);
	fprintf(stderr, "       %s [-v] -S dev\n", __progname);
	fprintf(stderr, "       %s [-v] -u dev\n", __progname);
#if 0
	fprintf(stderr, "usage: %s %s\n", __progname, 
		"-a | -f | -F | -g | -r | -R component dev");
	fprintf(stderr, "       %s -B | -i | -s | -S -u dev\n", __progname);
	fprintf(stderr, "       %s -c | -C config_file dev\n", __progname);
	fprintf(stderr, "       %s -I serial_number dev\n", __progname);
#endif
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.8 2001/12/29 21:54:57 tdeval Exp $	*/
d51 1
d71 5
d78 1
a78 1
static  void rf_configure(int, char*, int);
d80 4
a83 4
static  void rf_get_device_status(int);
static	void rf_output_configuration(int, const char *);
static  void get_component_number(int, char *, int *, int *);
static  void rf_fail_disk(int, char *, int);
d85 10
a94 10
static  void get_component_label(int, char *);
static  void set_component_label(int, char *);
static  void init_component_labels(int, int);
static  void set_autoconfig(int, int, char *);
static  void add_hot_spare(int, char *);
static  void remove_hot_spare(int, char *);
static  void rebuild_in_place(int, char *);
static  void check_status(int,int);
static  void check_parity(int,int,char *);
static  void do_meter(int, u_long);
d97 2
d101 1
a111 1
	char dev_name[PATH_MAX];
a117 1
	int raidID;
d120 2
a121 1
 	int fd;
d124 2
d129 1
d133 1
d246 17
a262 10
	if ((name[0] == '/') || (name[0] == '.')) {
		/* they've (apparently) given a full path... */
		strlcpy(dev_name, name, PATH_MAX);
	} else {
		if (isdigit(name[strlen(name) - 1])) {
			rawpart = getrawpartition();
			snprintf(dev_name, PATH_MAX, "%s%s%c", _PATH_DEV,
				 name, 'a' + rawpart);		
		} else {
			snprintf(dev_name, PATH_MAX, "%s%s", _PATH_DEV, name);
d264 1
a264 12
	}	

	if (stat(dev_name, &st) != 0)
		errx(errno, "stat failure on: %s", dev_name);
	if (!S_ISBLK(st.st_mode) && !S_ISCHR(st.st_mode))
		errx(EINVAL, "invalid device: %s", dev_name);

	raidID = RF_DEV2RAIDID(st.st_rdev);

	if ((fd = open(dev_name, O_RDWR, 0640)) < 0)
		errx(1, "unable to open device file: %s", dev_name);
	
d268 1
a268 1
		add_hot_spare(fd, component);
d271 1
a271 1
		remove_hot_spare(fd, component);
d274 1
a274 1
		rf_configure(fd, config_filename, force);
d277 1
a277 1
		set_autoconfig(fd, raidID, autoconf);
d280 4
a283 6
		printf("Copyback.\n");
		do_ioctl(fd, RAIDFRAME_COPYBACK, NULL, "RAIDFRAME_COPYBACK");
		if (verbose) {
			sleep(3); /* XXX give the copyback a chance to start */
			printf("Copyback status:\n");
			do_meter(fd, RAIDFRAME_CHECK_COPYBACK_STATUS_EXT);
d285 2
d289 1
a289 1
		rf_fail_disk(fd, component, do_recon);
d292 1
a292 1
		set_component_label(fd, component);
d295 1
a295 1
		get_component_label(fd, component);
d298 1
a298 1
		init_component_labels(fd, serial_number);
d301 4
a304 7
		printf("Initiating re-write of parity\n");
		do_ioctl(fd, RAIDFRAME_REWRITEPARITY, NULL, 
			 "RAIDFRAME_REWRITEPARITY");
		if (verbose) {
			sleep(3); /* XXX give it time to get started */
			printf("Parity Re-write status:\n");
			do_meter(fd, RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT);
d306 2
d310 1
a310 1
		check_status(fd, 1);
d314 1
a314 1
			rf_output_configuration(fd, dev_name);
d316 1
a316 1
			rf_get_device_status(fd);
d319 1
a319 1
		rebuild_in_place(fd, component);
d322 1
a322 1
		check_parity(fd, do_rewrite, dev_name);
d325 5
a329 1
		do_ioctl(fd, RAIDFRAME_SHUTDOWN, NULL, "RAIDFRAME_SHUTDOWN");
d335 11
a345 1
	close(fd);
d362 2
a363 2
rf_configure(fd, config_file, force)
	int fd;
d382 1
a382 1
	do_ioctl(fd, RAIDFRAME_CONFIGURE, &generic, "RAIDFRAME_CONFIGURE");
d412 3
a414 2
rf_get_device_status(fd)
	int fd;
d419 1
a419 1
	int i;
d423 9
a431 13
	do_ioctl(fd, RAIDFRAME_GET_INFO, &cfg_ptr, "RAIDFRAME_GET_INFO");

	printf("Components:\n");
	for (i = 0; i < device_config.ndevs; i++) {
		printf("%20s: %s\n", device_config.devs[i].devname, 
		       device_status(device_config.devs[i].status));
	}
	if (device_config.nspares > 0) {
		printf("Spares:\n");
		for (i = 0; i < device_config.nspares; i++) {
			printf("%20s: %s\n",
			       device_config.spares[i].devname, 
			       device_status(device_config.spares[i].status));
d433 6
a438 12
	} else {
		printf("No spares.\n");
	}
	if (verbose) {
		for(i=0; i < device_config.ndevs; i++) {
			if (device_config.devs[i].status == rf_ds_optimal) {
				get_component_label(fd,
				   device_config.devs[i].devname);
			} else {
				printf("%s status is: %s.  Skipping label.\n",
				   device_config.devs[i].devname,
				   device_status(device_config.devs[i].status));
d440 2
d443 13
d457 15
a471 13
		if (device_config.nspares > 0) {
			for(i=0; i < device_config.nspares; i++) {
				if ((device_config.spares[i].status == 
				     rf_ds_optimal) ||
				    (device_config.spares[i].status == 
				     rf_ds_used_spare)) {
					get_component_label(fd, 
					   device_config.spares[i].devname);
				} else {
					printf("%s status is: %s.  Skipping label.\n",
					       device_config.spares[i].devname,
					       device_status(device_config.spares[i].status));
				}		
a473 1
	}
d475 8
a482 6
	do_ioctl(fd, RAIDFRAME_CHECK_PARITY, &is_clean,
		 "RAIDFRAME_CHECK_PARITY");
	if (is_clean) {
		printf("Parity status: clean\n");
	} else {
		printf("Parity status: DIRTY\n");
a483 1
	check_status(fd, 0);
d487 3
a489 3
rf_output_configuration(fd, name)
	int fd;
	const char *name;
d493 1
a493 1
	int i;
d498 1
d502 3
a504 3
	printf("# raidctl config file for %s\n", name);
	printf("\n");
	do_ioctl(fd, RAIDFRAME_GET_INFO, &cfg_ptr, "RAIDFRAME_GET_INFO");
d506 4
a509 5
	printf("START array\n");
	printf("# numRow numCol numSpare\n");
	printf("%d %d %d\n", device_config.rows, device_config.cols,
	    device_config.nspares);
	printf("\n");
d511 5
a515 4
	printf("START disks\n");
	for(i = 0; i < device_config.ndevs; i++)
		printf("%s\n", device_config.devs[i].devname);
	printf("\n");
d517 3
a519 4
	if (device_config.nspares > 0) {
		printf("START spare\n");
		for(i = 0; i < device_config.nspares; i++)
			printf("%s\n", device_config.spares[i].devname);
a520 1
	}
d522 6
a527 17
	for(i = 0; i < device_config.ndevs; i++) {
		if (device_config.devs[i].status == rf_ds_optimal)
			break;
	}
	if (i == device_config.ndevs) {
		printf("# WARNING: no optimal components; using %s\n",
		    device_config.devs[0].devname);
		i = 0;
	}
	get_component_number(fd, device_config.devs[i].devname,
	    &component_num, &num_cols);
	memset(&component_label, 0, sizeof(RF_ComponentLabel_t));
	component_label.row = component_num / num_cols;
	component_label.column = component_num % num_cols;
	label_ptr = &component_label;
	do_ioctl(fd, RAIDFRAME_GET_COMPONENT_LABEL, &label_ptr,
		 "RAIDFRAME_GET_COMPONENT_LABEL");
d529 28
a556 8
	printf("START layout\n");
	printf(
	    "# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level_%c\n",
	    (char) component_label.parityConfig);
	printf("%d %d %d %c\n", 
	    component_label.sectPerSU, component_label.SUsPerPU, 
	    component_label.SUsPerRU, (char) component_label.parityConfig);
	printf("\n");
d558 3
a560 2
	printf("START queue\n");
	printf("fifo %d\n", device_config.maxqdepth);
d564 2
a565 2
get_component_number(fd, component_name, component_number, num_columns)
	int fd;
d579 1
a579 1
	do_ioctl(fd, RAIDFRAME_GET_INFO, &cfg_ptr, "RAIDFRAME_GET_INFO");
d611 2
a612 2
rf_fail_disk(fd, component_to_fail, do_recon)
	int fd;
d620 1
a620 1
	get_component_number(fd, component_to_fail, &component_num, &num_cols);
d629 1
a629 1
	do_ioctl(fd, RAIDFRAME_FAIL_DISK, &recon_request, 
d634 1
a634 1
		do_meter(fd, RAIDFRAME_CHECK_RECON_STATUS_EXT);
d639 2
a640 2
get_component_label(fd, component)
	int fd;
d648 1
a648 1
	get_component_number(fd, component, &component_num, &num_cols);
d655 1
a655 1
	do_ioctl(fd, RAIDFRAME_GET_COMPONENT_LABEL, &label_ptr,
d684 2
a685 2
set_component_label(fd, component)
	int fd;
d692 1
a692 1
	get_component_number(fd, component, &component_num, &num_cols);
d706 1
a706 1
	do_ioctl(fd, RAIDFRAME_SET_COMPONENT_LABEL, &component_label,
d712 2
a713 2
init_component_labels(fd, serial_number)
	int fd;
d728 1
a728 1
	do_ioctl(fd, RAIDFRAME_INIT_LABELS, &component_label,
d733 2
a734 3
set_autoconfig(fd, raidID, autoconf)
	int fd;
	int raidID;
d752 1
a752 1
	do_ioctl(fd, RAIDFRAME_SET_AUTOCONFIG, &auto_config,
d755 1
a755 1
	do_ioctl(fd, RAIDFRAME_SET_ROOT, &root_config,
d758 1
a758 1
	printf("raid%d: Autoconfigure: %s\n", raidID,
d762 1
a762 1
		printf("raid%d: Root: %s\n", raidID,
d768 2
a769 2
add_hot_spare(fd, component)
	int fd;
d779 1
a779 1
	do_ioctl(fd, RAIDFRAME_ADD_HOT_SPARE, &hot_spare,
d784 2
a785 2
remove_hot_spare(fd, component)
	int fd;
d792 1
a792 1
	get_component_number(fd, component, &component_num, &num_cols);
d800 1
a800 1
	do_ioctl(fd, RAIDFRAME_REMOVE_HOT_SPARE, &hot_spare,
d805 2
a806 2
rebuild_in_place(fd, component)
	int fd;
d813 1
a813 1
	get_component_number(fd, component, &component_num, &num_cols);
d819 1
a819 1
	do_ioctl(fd, RAIDFRAME_REBUILD_IN_PLACE, &comp,
d825 1
a825 1
		do_meter(fd, RAIDFRAME_CHECK_RECON_STATUS_EXT);
d831 3
a833 2
check_parity(fd, do_rewrite, dev_name)
	int fd;
a834 1
	char *dev_name;
d836 1
a836 1
	int is_clean;
d838 1
d840 19
a858 17
	is_clean = 0;
	percent_done = 0;
	do_ioctl(fd, RAIDFRAME_CHECK_PARITY, &is_clean,
		 "RAIDFRAME_CHECK_PARITY");
	if (is_clean) {
		printf("%s: Parity status: clean\n", dev_name);
	} else {
		printf("%s: Parity status: DIRTY\n", dev_name);
		if (do_rewrite) {
			printf("%s: Initiating re-write of parity\n",
			       dev_name);
			do_ioctl(fd, RAIDFRAME_REWRITEPARITY, NULL, 
				 "RAIDFRAME_REWRITEPARITY");
			sleep(3); /* XXX give it time to get started. */
			if (verbose) {
				printf("Parity Re-write status:\n");
				do_meter(fd, RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT);
d860 26
a885 9
				do_ioctl(fd, 
					 RAIDFRAME_CHECK_PARITYREWRITE_STATUS, 
					 &percent_done, 
					 "RAIDFRAME_CHECK_PARITYREWRITE_STATUS"
					 );
				while (percent_done < 100) {
					sleep(3); /* wait a bit... */
					do_ioctl(fd, RAIDFRAME_CHECK_PARITYREWRITE_STATUS, 
						 &percent_done, "RAIDFRAME_CHECK_PARITYREWRITE_STATUS");
a886 1

a887 4
			printf("%s: Parity Re-write complete\n", dev_name);
		} else {
			/* parity is wrong, and is not being fixed. */
			exit(1);
d890 1
d895 3
a897 2
check_status(fd, meter)
	int fd;
d900 1
d904 34
d939 14
a952 22
	do_ioctl(fd, RAIDFRAME_CHECK_RECON_STATUS, &recon_percent_done, 
		 "RAIDFRAME_CHECK_RECON_STATUS");
	printf("Reconstruction is %d%% complete.\n", recon_percent_done);
	do_ioctl(fd, RAIDFRAME_CHECK_PARITYREWRITE_STATUS, 
		 &parity_percent_done, 
		 "RAIDFRAME_CHECK_PARITYREWRITE_STATUS");
	printf("Parity Re-write is %d%% complete.\n", parity_percent_done);
	do_ioctl(fd, RAIDFRAME_CHECK_COPYBACK_STATUS, &copyback_percent_done, 
		 "RAIDFRAME_CHECK_COPYBACK_STATUS");
	printf("Copyback is %d%% complete.\n", copyback_percent_done);

	if (meter) {
	/* These 3 should be mutually exclusive at this point */
	if (recon_percent_done < 100) {
		printf("Reconstruction status:\n");
			do_meter(fd, RAIDFRAME_CHECK_RECON_STATUS_EXT);
	} else if (parity_percent_done < 100) {
		printf("Parity Re-write status:\n");
			do_meter(fd, RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT);
	} else if (copyback_percent_done < 100) {
		printf("Copyback status:\n");
			do_meter(fd, RAIDFRAME_CHECK_COPYBACK_STATUS_EXT);
d960 3
a962 2
do_meter(fd, option)
	int fd;
a965 1
	int last_value;
d967 1
a967 1
	RF_ProgressInfo_t progressInfo;
d974 1
a978 1
	int wait_for_more_data;
d982 10
a994 2
	memset(&progressInfo, 0, sizeof(RF_ProgressInfo_t));
	pInfoPtr = &progressInfo;
a995 4
	percent_done = 0;
	do_ioctl(fd, option, &pInfoPtr, "");
	last_value = progressInfo.completed;
	start_value = last_value;
a996 4
	
	wait_for_more_data = 0;
	tbit_value = 0;
	while(progressInfo.completed < progressInfo.total) {
d998 30
a1027 2
		percent_done = (progressInfo.completed * 100) / 
			progressInfo.total;
d1030 5
a1034 3
		
		elapsed_sec = current_time.tv_sec - start_time.tv_sec;
		elapsed_usec = current_time.tv_usec - start_time.tv_usec;
d1036 2
a1037 2
			elapsed_usec -= 1000000;
			elapsed_sec++;
d1039 1
a1039 1
		
d1041 1
a1041 3
			(double) elapsed_usec / 1000000.0;
		
		amount = progressInfo.completed - start_value;
a1044 3
			wait_for_more_data = 1;
		} else {
			wait_for_more_data = 0;
d1053 4
a1056 3
			simple_eta = (int) (((double)progressInfo.total - 
					     (double) progressInfo.completed) 
					    / rate);
d1069 4
a1072 3
		snprintf(buffer, 1024, "\r%3d%% |%s| ETA: %s %c",
			 percent_done, bar_buffer, eta_buffer,
			 tbits[tbit_value]);
a1076 7
		/* resolution wasn't high enough... wait until we get another
		   timestamp and perhaps more "work" done. */

		if (!wait_for_more_data) {
			last_value = progressInfo.completed;
		}

d1080 2
a1081 1
		sleep(2);
a1084 4

		do_ioctl(fd, option, &pInfoPtr, "");
		

d1088 1
a1099 1
                     "                                        "
d1154 96
@


1.8
log
@Changes to support the new RAID_AUTOCONF option (-A) of RAIDFrame.
raidctl(8) man page update.

ok drahn@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.7 2001/07/07 18:26:19 deraadt Exp $	*/
d70 21
a90 21
int     main __P((int, char *[]));
void	do_ioctl __P((int, u_long, void *, const char *));
static  void rf_configure __P((int, char*, int));
static  const char *device_status __P((RF_DiskStatus_t));
static  void rf_get_device_status __P((int));
static	void rf_output_configuration __P((int, const char *));
static  void get_component_number __P((int, char *, int *, int *));
static  void rf_fail_disk __P((int, char *, int));
static  void usage __P((void));
static  void get_component_label __P((int, char *));
static  void set_component_label __P((int, char *));
static  void init_component_labels __P((int, int));
static  void set_autoconfig __P((int, int, char *));
static  void add_hot_spare __P((int, char *));
static  void remove_hot_spare __P((int, char *));
static  void rebuild_in_place __P((int, char *));
static  void check_status __P((int,int));
static  void check_parity __P((int,int,char *));
static  void do_meter __P((int, u_long));
static  void get_bar __P((char *, double, int));
static  void get_time_string __P((char *, int));
@


1.7
log
@major -Wall cleanup, almost complete
@
text
@d1 3
a3 2
/*	$OpenBSD: raidctl.c,v 1.6 2001/06/04 14:59:49 mickey Exp $	*/
/*      $NetBSD: raidctl.c,v 1.11 2000/01/09 03:06:35 oster Exp $   */
d41 5
a45 7

   This program is a re-write of the original rf_ctrl program 
   distributed by CMU with RAIDframe 1.1.

   This program is the user-land interface to the RAIDframe kernel
   driver in NetBSD.

d51 4
a54 3
#include <util.h>
#include <stdio.h>
#include <fcntl.h>
d58 4
a61 1
#include <sys/types.h>
a62 5
#ifdef NETBSD
#include <sys/disklabel.h>
#include <machine/disklabel.h>
#endif
#include <stdlib.h>
d64 1
d71 1
a71 1
void do_ioctl __P((int, unsigned long, void *, char *));
d73 1
a73 1
static  char *device_status __P((RF_DiskStatus_t));
d75 1
d82 1
d86 1
a86 1
static  void check_status __P((int));
d88 1
a88 1
static  void do_meter __P((int, int));
d92 1
a92 1
int verbose = 0;
d95 1
a95 1
main(argc,argv)
a98 2
	extern char *optarg;
	extern int optind;
d106 2
a109 1
	int is_clean;
d111 1
a111 2
	int rawpart;
	int serial_number = 0;
d115 1
d119 1
a121 1
	is_clean = 0;
d124 2
a125 1
	while ((ch = getopt(argc, argv, "a:Bc:C:f:F:g:iI:l:r:R:sSpPuv")) != -1)
d129 6
a134 1
			strncpy(component, optarg, PATH_MAX);
d143 1
a143 1
			strncpy(config_filename,optarg,PATH_MAX);
d148 1
a148 1
			strncpy(config_filename,optarg,PATH_MAX);
d155 1
a155 1
			strncpy(component, optarg, PATH_MAX);
d161 1
a161 1
			strncpy(component, optarg, PATH_MAX);
d167 6
a172 1
			strncpy(component, optarg, PATH_MAX);
d186 1
a186 1
			strncpy(component, optarg, PATH_MAX);
d191 1
a191 1
			strncpy(component, optarg, PATH_MAX);
d195 1
a195 1
			strncpy(component,optarg,PATH_MAX);
d204 1
a204 1
			action = RAIDFRAME_CHECK_RECON_STATUS;
a221 3
			/* Don't bump num_options, as '-v' is not 
			   an option like the others */
			/* num_options++; */
d232 1
a232 1
	strncpy(name,argv[0],PATH_MAX);
d236 1
a236 1
		strncpy(dev_name, name, PATH_MAX);
d238 1
a238 1
		if (isdigit(name[strlen(name)-1])) {
d240 2
a241 2
			snprintf(dev_name,PATH_MAX,"/dev/%s%c",name,
				 'a'+rawpart);		
d243 1
a243 1
			snprintf(dev_name,PATH_MAX,"/dev/%s",name);
d247 4
a250 10
	if (stat(dev_name, &st) != 0) {
		fprintf(stderr,"%s: stat failure on: %s\n",
			__progname,dev_name);
		return (errno);
	}
	if (!S_ISBLK(st.st_mode) && !S_ISCHR(st.st_mode)) {
		fprintf(stderr,"%s: invalid device: %s\n",
			__progname,dev_name);
		return (EINVAL);
	}
d254 2
a255 5
	if ((fd = open( dev_name, O_RDWR, 0640)) < 0) {
		fprintf(stderr, "%s: unable to open device file: %s\n",
			__progname, dev_name);
		return (1);
	}
d260 1
a260 1
		add_hot_spare(fd,component);
d263 1
a263 1
		remove_hot_spare(fd,component);
d268 3
d277 1
a277 1
			do_meter(fd,RAIDFRAME_CHECK_COPYBACK_STATUS);
d281 1
a281 1
		rf_fail_disk(fd,component,do_recon);
d284 1
a284 1
		set_component_label(fd,component);
d287 1
a287 1
		get_component_label(fd,component);
d290 1
a290 1
		init_component_labels(fd,serial_number);
d299 1
a299 1
			do_meter(fd,RAIDFRAME_CHECK_PARITYREWRITE_STATUS);
d302 2
a303 2
	case RAIDFRAME_CHECK_RECON_STATUS:
		check_status(fd);
d306 4
a309 1
		rf_get_device_status(fd);
d312 1
a312 1
		rebuild_in_place(fd,component);
d315 1
a315 1
		check_parity(fd,do_rewrite,dev_name);
d333 1
a333 1
	char *ioctl_name;
d335 2
a336 4
	if (ioctl(fd, command, arg) < 0) {
		warn("ioctl (%s) failed", ioctl_name);
		exit(1);
	}
d341 1
a341 1
rf_configure(fd,config_file,force)
d349 2
a350 5
	if (rf_MakeConfig( config_file, &cfg ) != 0) {
		fprintf(stderr,"%s: unable to create RAIDframe %s\n",
			__progname, "configuration structure\n");
		exit(1);
	}
d355 3
a357 5

	   Note the extra level of redirection needed here, since
	   what we really want to pass in is a pointer to the pointer to 
	   the configuration structure. 

d364 1
a364 1
static char *
a367 1
	static char status_string[256];
d371 1
a371 2
		strcpy(status_string,"optimal");
		break;
d373 1
a373 2
		strcpy(status_string,"failed");
		break;
d375 1
a375 2
		strcpy(status_string,"reconstructing");
		break;
d377 1
a377 2
		strcpy(status_string,"dist_spared");
		break;
d379 1
a379 2
		strcpy(status_string,"spared");
		break;
d381 1
a381 2
		strcpy(status_string,"spare");
		break;
d383 1
a383 2
		strcpy(status_string,"used_spare");
		break;
d385 1
a385 2
		strcpy(status_string,"UNKNOWN");
		break;
d387 1
a387 1
	return(status_string);
d404 1
a404 1
	for(i=0; i < device_config.ndevs; i++) {
d410 1
a410 1
		for(i=0; i < device_config.nspares; i++) {
d418 29
d454 39
a492 1
	check_status(fd);
d494 29
d541 1
a541 2
	do_ioctl(fd, RAIDFRAME_GET_INFO, &cfg_ptr, 
		 "RAIDFRAME_GET_INFO");
d546 1
a546 1
	for(i=0; i < device_config.ndevs; i++) {
d548 1
a548 1
			    PATH_MAX)==0) {
d553 13
a565 4
	if (!found) {
		fprintf(stderr,"%s: %s is not a component %s", __progname, 
			component_name, "of this device\n");
		exit(1);
d567 3
d596 1
a596 1
		do_meter(fd,RAIDFRAME_CHECK_RECON_STATUS);
d612 1
a612 1
	memset( &component_label, 0, sizeof(RF_ComponentLabel_t));
d617 4
a620 2
	do_ioctl( fd, RAIDFRAME_GET_COMPONENT_LABEL, &label_ptr,
		  "RAIDFRAME_GET_COMPONENT_LABEL");
d622 21
a642 10
	printf("Component label for %s:\n",component);
	printf("Version: %d\n",component_label.version);
	printf("Serial Number: %d\n",component_label.serial_number);
	printf("Mod counter: %d\n",component_label.mod_counter);
	printf("Row: %d\n", component_label.row);
	printf("Column: %d\n", component_label.column);
	printf("Num Rows: %d\n", component_label.num_rows);
	printf("Num Columns: %d\n", component_label.num_columns);
	printf("Clean: %d\n", component_label.clean);
	printf("Status: %s\n", device_status(component_label.status));
d668 2
a669 2
	do_ioctl( fd, RAIDFRAME_SET_COMPONENT_LABEL, &component_label,
		  "RAIDFRAME_SET_COMPONENT_LABEL");
d690 2
a691 2
	do_ioctl( fd, RAIDFRAME_INIT_LABELS, &component_label,
		  "RAIDFRAME_SET_COMPONENT_LABEL");
d695 36
d739 1
a739 1
	strncpy(hot_spare.component_name, component, 
d742 2
a743 2
	do_ioctl( fd, RAIDFRAME_ADD_HOT_SPARE, &hot_spare,
		  "RAIDFRAME_ADD_HOT_SPARE");
d760 1
a760 1
	strncpy(hot_spare.component_name, component, 
d763 2
a764 2
	do_ioctl( fd, RAIDFRAME_REMOVE_HOT_SPARE, &hot_spare,
		  "RAIDFRAME_REMOVE_HOT_SPARE");
d768 1
a768 1
rebuild_in_place( fd, component )
d780 1
a780 1
	strncpy(comp.component_name, component, sizeof(comp.component_name));
d782 2
a783 2
	do_ioctl( fd, RAIDFRAME_REBUILD_IN_PLACE, &comp,
		  "RAIDFRAME_REBUILD_IN_PLACE");
d788 1
a788 1
		do_meter(fd,RAIDFRAME_CHECK_RECON_STATUS);
d794 1
a794 1
check_parity( fd, do_rewrite, dev_name )
d807 1
a807 1
		printf("%s: Parity status: clean\n",dev_name);
d809 1
a809 1
		printf("%s: Parity status: DIRTY\n",dev_name);
d815 1
a815 2
			sleep(3); /* XXX give it time to
				     get started. */
d818 1
a818 2
				do_meter(fd,
					 RAIDFRAME_CHECK_PARITYREWRITE_STATUS);
d825 2
a826 1
				while( percent_done < 100 ) {
d832 1
a832 2
			       printf("%s: Parity Re-write complete\n",
				      dev_name);
d834 1
a834 2
			/* parity is wrong, and is not being fixed.
			   Exit w/ an error. */
d842 1
a842 1
check_status( fd )
d844 1
d861 1
d865 1
a865 1
		do_meter(fd,RAIDFRAME_CHECK_RECON_STATUS);
d868 1
a868 1
		do_meter(fd,RAIDFRAME_CHECK_PARITYREWRITE_STATUS);
d871 2
a872 1
		do_meter(fd,RAIDFRAME_CHECK_COPYBACK_STATUS);
d876 1
a876 1
char *tbits = "|/-\\";
d879 1
a879 1
do_meter( fd, option )
d881 1
a881 1
	int option;
d884 4
a887 2
	int last_percent;
	int start_percent;
a888 1
	struct timeval last_time;
d893 1
a893 1
	int simple_eta;
d902 5
a906 4
	if (gettimeofday(&start_time,NULL)) {
		fprintf(stderr,"%s: gettimeofday failed!?!?\n",__progname);
		exit(errno);
	}
d908 3
a910 4
	do_ioctl( fd, option, &percent_done, "");
	last_percent = percent_done;
	start_percent = percent_done;
	last_time = start_time;
d915 1
d917 2
a918 1
	while(percent_done < 100) {
d922 2
a923 4
		elapsed_sec = current_time.tv_sec - last_time.tv_sec;
		
		elapsed_usec = current_time.tv_usec - last_time.tv_usec;
		
d925 1
a925 1
			elapsed_usec-=1000000;
a930 3
		if (elapsed <= 0.0) {
			elapsed = 0.0001; /* XXX */
		}
d932 2
a933 1
		amount = percent_done - last_percent;
a939 1
		rate = amount / elapsed;
d941 4
d947 3
a949 1
			simple_eta = (int) ((100.0 - (double) last_percent ) / rate);
d954 6
d962 3
a964 2
		snprintf(buffer,1024,"\r%3d%% |%s| ETA: %s %c",
			 percent_done,bar_buffer,eta_buffer,tbits[tbit_value]);
d966 1
a966 1
		write(fileno(stdout),buffer,strlen(buffer));
d973 1
a973 2
			last_time = current_time;
			last_percent = percent_done;
d976 1
a976 1
		if (++tbit_value>3) 
d981 2
a982 5
		if (gettimeofday(&current_time,NULL)) {
			fprintf(stderr,"%s: gettimeofday failed!?!?\n",
				__progname);
			exit(errno);
		}
d984 1
a984 1
		do_ioctl( fd, option, &percent_done, "");
d1005 1
a1005 1
get_bar(string,percent,max_strlen)
d1016 1
a1016 1
		(int)((percent * max_strlen)/ 100);
d1019 1
a1019 1
	snprintf(string,max_strlen,"%s",&stars[offset]);
d1023 1
a1023 1
get_time_string(string,simple_time)
d1035 1
a1035 1
		seconds = ((int)simple_time - 60*minutes);
d1037 1
a1037 1
		minutes = minutes - 60*hours;
d1040 2
a1041 1
			snprintf(hours_buffer,5,"%02d:",hours);
d1043 1
a1043 1
			snprintf(hours_buffer,5,"   ");
d1046 5
a1050 3
		snprintf(minutes_buffer,5,"%02d:",minutes);
		snprintf(seconds_buffer,5,"%02d",seconds);
		snprintf(string,1024,"%s%s%s",
d1053 1
a1053 1
		snprintf(string,1024,"   --:--");
d1062 1
d1069 1
d1072 2
@


1.6
log
@return from main() don't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.5 2000/01/11 18:03:45 peter Exp $	*/
d112 1
a112 1
	int serial_number;
d747 1
a747 1
	int simple_eta,last_eta;
a802 5
		}
		if (simple_eta <=0) { 
			simple_eta = last_eta;
		} else {
			last_eta = simple_eta;
@


1.5
log
@remove redundent printf
@
text
@d1 1
a1 1
/*	$OpenBSD: raidctl.c,v 1.4 2000/01/07 14:51:41 peter Exp $	*/
d255 1
a255 1
		exit(1);
d320 1
a320 1
	exit(0);
@


1.4
log
@sync with Greg Oster's NetBSD chages to Jan 4th 2000.
@
text
@d1 2
a2 2
/*	$OpenBSD: raidctl.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
/*      $NetBSD: raidctl.c,v 1.10 2000/01/05 03:02:41 oster Exp $   */
a331 1
		printf("ioctl (%s) failed", ioctl_name);
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: raidctl.c,v 1.2 1999/02/16 21:51:39 niklas Exp $	*/
/*      $NetBSD: raidctl.c,v 1.6 1999/03/02 03:13:59 oster Exp $   */
d72 1
a72 1
static  void do_ioctl __P((int, unsigned long, void *, char *));
d85 7
d108 2
a111 1
	int recon_percent_done;
d120 2
d124 1
a124 1
	while ((ch = getopt(argc, argv, "a:Bc:C:f:F:g:iI:l:r:R:sSu")) != -1)
d193 10
a202 1
			action = RAIDFRAME_CHECKRECON;
d209 6
d272 5
d294 5
d300 2
a301 5
	case RAIDFRAME_CHECKRECON:
		do_ioctl(fd, RAIDFRAME_CHECKRECON, &recon_percent_done, 
			 "RAIDFRAME_CHECKRECON");
		printf("Reconstruction is %d%% complete.\n",
		       recon_percent_done);
d309 3
d323 1
a323 1
static void
d332 1
d347 1
a347 1
	if (rf_MakeConfig( config_file, &cfg ) < 0) {
d408 1
d430 8
d498 5
d640 57
d701 209
d912 14
a925 14
	fprintf(stderr, "usage: %s -a component dev\n", __progname);
	fprintf(stderr, "       %s -B dev\n", __progname);
	fprintf(stderr, "       %s -c config_file dev\n", __progname);
	fprintf(stderr, "       %s -C config_file dev\n", __progname);
	fprintf(stderr, "       %s -f component dev\n", __progname);
	fprintf(stderr, "       %s -F component dev\n", __progname);
	fprintf(stderr, "       %s -g component dev\n", __progname);
	fprintf(stderr, "       %s -i dev\n", __progname);
	fprintf(stderr, "       %s -I serial_number dev\n", __progname);
	fprintf(stderr, "       %s -r component dev\n", __progname); 
	fprintf(stderr, "       %s -R component dev\n", __progname);
	fprintf(stderr, "       %s -s dev\n", __progname);
	fprintf(stderr, "       %s -S dev\n", __progname);
	fprintf(stderr, "       %s -u dev\n", __progname);
@


1.2
log
@merge from netbsd 990213 + make compile with our includes
@
text
@d1 2
a2 2
/*	$OpenBSD: raidctl.c,v 1.1 1999/01/11 14:49:44 niklas Exp $	*/
/*      $NetBSD: raidctl.c,v 1.4 1999/02/04 14:50:31 oster Exp $   */
d60 5
d73 1
a73 1
static  void rf_configure __P((int, char*));
d76 1
d79 6
d99 1
a99 1
	char component_to_fail[PATH_MAX];
d104 4
a107 2
	struct stat st;
	int fd;
d112 1
d114 1
a114 1
	while ((ch = getopt(argc, argv, "c:Cf:F:rRsu")) != -1)
d116 9
d126 1
d128 1
a128 1
			action = RAIDFRAME_CONFIGURE;
d132 3
a134 1
			action = RAIDFRAME_COPYBACK;
d139 1
a140 1
			strncpy(component_to_fail, optarg, PATH_MAX);
d145 1
d147 19
a165 1
			strncpy(component_to_fail, optarg, PATH_MAX);
d169 2
a170 1
			action = RAIDFRAME_REWRITEPARITY;
d174 2
a175 1
			action = RAIDFRAME_CHECKRECON;
d182 4
d235 6
d242 1
a242 1
		rf_configure(fd, config_filename);
d249 10
a258 1
		rf_fail_disk(fd,component_to_fail,do_recon);
d274 3
d303 1
a303 1
rf_configure(fd,config_file)
d306 1
d317 2
d328 1
a328 7
	do_ioctl(fd,RAIDFRAME_CONFIGURE,&generic,"RAIDFRAME_CONFIGURE");
#if 0
	if (ioctl(fd, RAIDFRAME_CONFIGURE, &generic) < 0) {
		warn("ioctl (RAIDFRAME_CONFIGURE): failed\n");
		exit(1);
	}
#endif
d386 1
a386 1
			printf("%20s [%d][%d]: %s\n",
a387 2
			       device_config.spares[i].spareRow,
 			       device_config.spares[i].spareCol, 
d397 1
a397 1
rf_fail_disk(fd, component_to_fail, do_recon)
d399 3
a401 2
	char *component_to_fail;
	int do_recon;
a402 1
	struct rf_recon_req recon_request;
a406 1
	int component_num;
d408 1
a408 1
	component_num = -1;
d414 3
d419 1
a419 2
		if (strncmp(component_to_fail,
			    device_config.devs[i].devname,
d422 1
a422 1
			component_num = i;
d426 2
a427 3
		fprintf(stderr,"%s: %s is not a component %s",
			__progname, component_to_fail, 
			"of this device\n");
d430 11
d442 4
a445 2
	recon_request.row = component_num / device_config.cols;
	recon_request.col = component_num % device_config.cols;
d453 89
d543 7
d553 41
d596 4
a599 2
	fprintf(stderr, "usage: %s -c config_file dev\n", __progname);
	fprintf(stderr, "       %s -C dev\n", __progname);
d602 5
a606 2
	fprintf(stderr, "       %s -r dev\n", __progname);
	fprintf(stderr, "       %s -R dev\n", __progname);
d608 1
d610 7
@


1.1
log
@Control RAIDframe
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/

d57 1
d60 2
a61 2
#include <sys/disklabel.h>
#include <machine/disklabel.h>
@

