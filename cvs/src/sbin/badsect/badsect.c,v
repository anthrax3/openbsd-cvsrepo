head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.12
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.8
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.20
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.11.12.22.33.07;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	yL2gco0cO8wLO0qe;

1.26
date	2015.01.20.18.22.20;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	F55lwc3gS4GN2mLs;

1.25
date	2015.01.16.06.39.56;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Uu5nFG3wCl0LACBb;

1.24
date	2014.05.22.14.38.48;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.21.16.32.08;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.01.17.36.18;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.11.16.42.02;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.02.06.22.29;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.32;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.06.19.16.05;	author sobrado;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.29.03.37.09;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.21.16.38.54;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.08.19.04.25;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.03.05.03.36;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.06.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.02.20.37.28;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.13.05.00.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.03.22.32.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.09.08.13.05;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.33;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.05.07.39.16;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.07.18.26.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.13.16.25.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.30.01.06.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.23.14.29.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@use symbolics for flags to open
from Ricardo Mestre
@
text
@/*	$OpenBSD: badsect.c,v 1.26 2015/01/20 18:22:20 deraadt Exp $	*/
/*	$NetBSD: badsect.c,v 1.10 1995/03/18 14:54:28 cgd Exp $	*/

/*
 * Copyright (c) 1981, 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * badsect
 *
 * Badsect takes a list of file-system relative sector numbers
 * and makes files containing the blocks of which these sectors are a part.
 * It can be used to contain sectors which have problems if these sectors
 * are not part of the bad file for the pack (see bad144).  For instance,
 * this program can be used if the driver for the file system in question
 * does not support bad block forwarding.
 */
#include <sys/param.h>	/* MAXBSIZE DEV_BSIZE isclr */
#include <sys/stat.h>

#include <ufs/ffs/fs.h>
#include <ufs/ufs/dinode.h>

#include <dirent.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <err.h>

static int chkuse(daddr_t, int);
static void rdfs(daddr_t, int, char *);

static union {
	struct	fs fs;
	char	fsx[SBSIZE];
} ufs;
#define sblock	ufs.fs
static union {
	struct	cg cg;
	char	cgx[MAXBSIZE];
} ucg;
#define	acg	ucg.cg
static struct	fs *fs;
static int	fsi;
static int	errs;

int
main(int argc, char *argv[])
{
	daddr_t number;
	struct stat stbuf, devstat;
	struct dirent *dp;
	DIR *dirp;
	char name[BUFSIZ];
	int len;

	if (argc < 3) {
		fprintf(stderr, "usage: badsect bbdir sector ...\n");
		exit(1);
	}
	if (chdir(argv[1]) < 0 || stat(".", &stbuf) < 0)
		err(2, "%s", argv[1]);

	strlcpy(name, _PATH_DEV, sizeof name);
	len = strlen(name);
	if ((dirp = opendir(name)) == NULL)
		err(3, "%s", name);

	while ((dp = readdir(dirp)) != NULL) {
		strlcpy(&name[len], dp->d_name, sizeof name - len);
		if (stat(name, &devstat) < 0)
			err(4, "%s", name);

		if (stbuf.st_dev == devstat.st_rdev &&
		    S_ISBLK(devstat.st_mode))
			break;
	}

	/*
	 * We've found the block device, but since the filesystem
	 * is mounted, we must write to the raw (character) device
	 * instead. This is not guaranteed to work if someone has a
	 * /dev that doesn't follow standard naming conventions, but
	 * it's all we've got.
	 */
	name[len] = 'r';
	strlcpy(&name[len+1], dp->d_name, sizeof name - (len+1));
	closedir(dirp);
	if (dp == NULL)
		err(5, "Cannot find dev 0%o corresponding to %s",
			stbuf.st_rdev, argv[1]);

	if ((fsi = open(name, O_RDONLY)) < 0)
		err(6, "%s", name);

	fs = &sblock;
	rdfs(SBOFF, SBSIZE, (char *)fs);
	for (argc -= 2, argv += 2; argc > 0; argc--, argv++) {
		number = strtonum(*argv, 0, QUAD_MAX, NULL);
		if (chkuse(number, 1))
			continue;
		if (mknod(*argv, S_IFMT|S_IRUSR|S_IWUSR,
		    dbtofsb(fs, number)) < 0) {
			warn("%s", *argv);
			errs++;
		}
	}
	printf("Don't forget to run ``fsck %s''\n", name);
	exit(errs);
}

static int
chkuse(daddr_t blkno, int cnt)
{
	int cg;
	daddr_t fsbn, bn;

	fsbn = dbtofsb(fs, blkno);
	if (fsbn+cnt > fs->fs_ffs1_size) {
		fprintf(stderr, "block %lld out of range of file system\n",
		    (long long)blkno);
		return (1);
	}
	cg = dtog(fs, fsbn);
	if (fsbn < cgdmin(fs, cg)) {
		if (cg == 0 || (fsbn+cnt) > cgsblock(fs, cg)) {
			fprintf(stderr, "block %lld in non-data area: cannot "
			    "attach\n", (long long)blkno);
			return (1);
		}
	} else {
		if ((fsbn+cnt) > cgbase(fs, cg+1)) {
			fprintf(stderr, "block %lld in non-data area: cannot "
			    "attach\n", (long long)blkno);
			return (1);
		}
	}
	rdfs(fsbtodb(fs, cgtod(fs, cg)), (int)sblock.fs_cgsize,
	    (char *)&acg);
	if (!cg_chkmagic(&acg)) {
		fprintf(stderr, "cg %d: bad magic number\n", cg);
		errs++;
		return (1);
	}
	bn = dtogd(fs, fsbn);
	if (isclr(cg_blksfree(&acg), bn))
		fprintf(stderr, "Warning: sector %lld is in use\n",
		    (long long)blkno);
	return (0);
}

/*
 * read a block from the file system
 */
static void
rdfs(daddr_t bno, int size, char *bf)
{
	if (pread(fsi, bf, size, bno * DEV_BSIZE) != size) {
		fprintf(stderr, "read error: %lld\n", (long long)bno);
		err(1, "rdfs");
	}
}
@


1.26
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.25 2015/01/16 06:39:56 deraadt Exp $	*/
d122 1
a122 1
	if ((fsi = open(name, 0)) < 0)
@


1.25
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.24 2014/05/22 14:38:48 krw Exp $	*/
d43 1
a43 1
#include <sys/param.h>	/* MAXFRAG MAXBSIZE DEV_BSIZE isclr */
@


1.24
log
@Nuke pointless dev_bsize variable which is always set to 512, and just
use DEV_BSIZE.

Replace lseek+read with pread().
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.23 2014/05/21 16:32:08 krw Exp $	*/
d43 1
a43 1
#include <sys/param.h>
d56 1
@


1.23
log
@Nuke some trailing whitespace to shrink subsequent diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.22 2013/11/01 17:36:18 krw Exp $	*/
a73 1
static long	dev_bsize = 1;
a125 1
	dev_bsize = fs->fs_fsize / fsbtodb(fs, 1);
d186 1
a186 8
	int n;

	if (lseek(fsi, (off_t)bno * dev_bsize, SEEK_SET) < 0) {
		fprintf(stderr, "seek error: %lld\n", (long long)bno);
		err(1, "rdfs");
	}
	n = read(fsi, bf, size);
	if (n != size) {
@


1.22
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.21 2013/06/11 16:42:02 deraadt Exp $	*/
d177 1
a177 1
		fprintf(stderr, "Warning: sector %lld is in use\n", 
@


1.21
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.20 2013/06/02 06:22:29 guenther Exp $	*/
d150 2
a151 1
		fprintf(stderr, "block %lld out of range of file system\n", blkno);
d157 2
a158 2
			fprintf(stderr, "block %lld in non-data area: cannot attach\n",
				blkno);
d163 2
a164 2
			fprintf(stderr, "block %lld in non-data area: cannot attach\n",
				blkno);
d177 2
a178 1
		fprintf(stderr, "Warning: sector %lld is in use\n", blkno);
@


1.20
log
@Switch from antique struct direct to struct dirent
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.19 2009/10/27 23:59:32 deraadt Exp $	*/
d58 2
a59 2
static int chkuse(daddr64_t, int);
static void rdfs(daddr64_t, int, char *);
d79 1
a79 1
	daddr64_t number;
d143 1
a143 1
chkuse(daddr64_t blkno, int cnt)
d146 1
a146 1
	daddr64_t fsbn, bn;
d184 1
a184 1
rdfs(daddr64_t bno, int size, char *bf)
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.18 2007/08/06 19:16:05 sobrado Exp $	*/
a43 1
#include <sys/dir.h>
d49 1
d81 1
a81 1
	struct direct *dp;
@


1.18
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.17 2007/06/29 03:37:09 deraadt Exp $	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1981, 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)badsect.c	8.1 (Berkeley) 6/5/93";
#else
static const char rcsid[] = "$OpenBSD: badsect.c,v 1.17 2007/06/29 03:37:09 deraadt Exp $";
#endif
#endif /* not lint */
@


1.17
log
@more daddr64_t changes; checked by otto
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.16 2007/03/19 13:27:47 pedro Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: badsect.c,v 1.16 2007/03/19 13:27:47 pedro Exp $";
d101 1
a101 1
		fprintf(stderr, "usage: badsect bbdir blkno [ blkno ]\n");
@


1.16
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.15 2005/07/21 16:38:54 fgsch Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: badsect.c,v 1.15 2005/07/21 16:38:54 fgsch Exp $";
d72 2
a73 2
static int chkuse(daddr_t, int);
static void rdfs(daddr_t, int, char *);
d93 1
a93 1
	daddr_t number;
d143 1
a143 1
		number = atoi(*argv);
d157 1
a157 1
chkuse(daddr_t blkno, int cnt)
d160 1
a160 1
	daddr_t fsbn, bn;
d163 2
a164 2
	if ((unsigned)(fsbn+cnt) > fs->fs_ffs1_size) {
		fprintf(stderr, "block %d out of range of file system\n", blkno);
d170 1
a170 1
			fprintf(stderr, "block %d in non-data area: cannot attach\n",
d176 1
a176 1
			fprintf(stderr, "block %d in non-data area: cannot attach\n",
d190 1
a190 1
		fprintf(stderr, "Warning: sector %d is in use\n", blkno);
d198 1
a198 1
rdfs(daddr_t bno, int size, char *bf)
@


1.15
log
@remove trailing newlines from err(3) calls; millert@@ and matthieu@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.14 2004/08/08 19:04:25 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: badsect.c,v 1.14 2004/08/08 19:04:25 deraadt Exp $";
d163 1
a163 1
	if ((unsigned)(fsbn+cnt) > fs->fs_size) {
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.13 2004/03/03 05:03:36 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: badsect.c,v 1.13 2004/03/03 05:03:36 tedu Exp $";
d133 1
a133 1
		err(5, "Cannot find dev 0%o corresponding to %s\n",
@


1.13
log
@cleanups, use err().  from Mathias () enloco.net pr3679
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.12 2003/06/02 20:06:14 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: badsect.c,v 1.12 2003/06/02 20:06:14 millert Exp $";
d104 1
a104 1
	if (chdir(argv[1]) < 0 || stat(".", &stbuf) < 0) 
d106 1
a106 1
	
d109 1
a109 1
	if ((dirp = opendir(name)) == NULL) 
d111 1
a111 1
	
d114 1
a114 1
		if (stat(name, &devstat) < 0) 
d116 1
a116 1
		
d132 1
a132 1
	if (dp == NULL) 
d135 2
a136 2
	
	if ((fsi = open(name, 0)) < 0) 
d138 1
a138 1
	
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.11 2003/04/02 20:37:28 deraadt Exp $	*/
d34 1
a34 1
static char copyright[] =
d43 1
a43 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.11 2003/04/02 20:37:28 deraadt Exp $";
d70 1
d72 4
a75 1
union {
d80 1
a80 1
union {
d85 4
a88 9
struct	fs *fs;
int	fso, fsi;
int	errs;
long	dev_bsize = 1;

char buf[MAXBSIZE];

void	rdfs(daddr_t, int, char *);
int	chkuse(daddr_t, int);
d104 3
a106 4
	if (chdir(argv[1]) < 0 || stat(".", &stbuf) < 0) {
		perror(argv[1]);
		exit(2);
	}
d109 3
a111 4
	if ((dirp = opendir(name)) == NULL) {
		perror(name);
		exit(3);
	}
d114 3
a116 4
		if (stat(name, &devstat) < 0) {
			perror(name);
			exit(4);
		}
d132 2
a133 2
	if (dp == NULL) {
		printf("Cannot find dev 0%o corresponding to %s\n",
d135 4
a138 6
		exit(5);
	}
	if ((fsi = open(name, 0)) < 0) {
		perror(name);
		exit(6);
	}
d148 1
a148 1
			perror(*argv);
d156 1
a156 1
int
d164 1
a164 1
		printf("block %d out of range of file system\n", blkno);
d170 1
a170 1
			printf("block %d in non-data area: cannot attach\n",
d176 1
a176 1
			printf("block %d in non-data area: cannot attach\n",
d190 1
a190 1
		printf("Warning: sector %d is in use\n", blkno);
d197 1
a197 1
void
d203 2
a204 3
		printf("seek error: %lld\n", (long long)bno);
		perror("rdfs");
		exit(1);
d208 2
a209 3
		printf("read error: %lld\n", (long long)bno);
		perror("rdfs");
		exit(1);
@


1.11
log
@Xenu made me fix the strcpy; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.10 2003/03/13 05:00:41 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.10 2003/03/13 05:00:41 deraadt Exp $";
@


1.10
log
@more strlcpy; most from Hans-Joerg.Hoexer@@yerbouti.franken.de, a bit from me
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.9 2002/07/03 22:32:32 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.9 2002/07/03 22:32:32 deraadt Exp $";
d120 1
a120 1
		strcpy(&name[len], dp->d_name);
d138 1
a138 1
	strcpy(&name[len+1], dp->d_name);
@


1.9
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.8 2002/06/09 08:13:05 todd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.8 2002/06/09 08:13:05 todd Exp $";
d113 1
a113 1
	strcpy(name, _PATH_DEV);
@


1.8
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.7 2002/02/16 21:27:33 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.7 2002/02/16 21:27:33 millert Exp $";
d96 1
a96 3
main(argc, argv)
	int argc;
	char *argv[];
d167 1
a167 3
chkuse(blkno, cnt)
	daddr_t blkno;
	int cnt;
d208 1
a208 4
rdfs(bno, size, bf)
	daddr_t bno;
	int size;
	char *bf;
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.6 2001/11/05 07:39:16 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.6 2001/11/05 07:39:16 mpech Exp $";
d133 1
a133 1
	 * We've found the block device, but since the filesystem 
@


1.6
log
@kill more registers;

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.5 2001/07/07 18:26:10 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.5 2001/07/07 18:26:10 deraadt Exp $";
d92 2
a93 2
void	rdfs __P((daddr_t, int, char *));
int	chkuse __P((daddr_t, int));
@


1.5
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.4 1996/09/13 16:25:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.4 1996/09/13 16:25:26 deraadt Exp $";
d102 1
a102 1
	register struct direct *dp;
@


1.4
log
@final correct badsect device patch from curt@@portal.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.3 1996/08/30 01:06:34 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.3 1996/08/30 01:06:34 deraadt Exp $";
d220 1
a220 1
		printf("seek error: %ld\n", bno);
d226 1
a226 1
		printf("read error: %ld\n", bno);
@


1.3
log
@use raw device only; netbsd pr#2719; flipk@@idea.exnet.iastate.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.2 1996/06/23 14:29:54 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.2 1996/06/23 14:29:54 deraadt Exp $";
d105 1
d116 1
d122 1
a122 1
		strcpy(&name[5], dp->d_name);
d133 1
a133 1
	 * we've found the block device, but since the filesystem 
d135 3
a137 1
	 * instead.
d139 2
a140 2
	name[5] = 'r';
	strcpy(&name[6], dp->d_name);
@


1.2
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: badsect.c,v 1.10 1995/03/18 14:54:28 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: badsect.c,v 1.10 1995/03/18 14:54:28 cgd Exp $";
d129 8
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: badsect.c,v 1.10 1995/03/18 14:54:28 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
