head	1.31;
access;
symbols
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.29.0.10
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.6
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.8
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.12
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.10
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.6
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.4
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.31
date	2017.07.21.20.38.20;	author bru;	state Exp;
branches;
next	1.30;
commitid	ob8Bi51A764QwCzw;

1.30
date	2017.04.06.17.33.39;	author jmc;	state Exp;
branches;
next	1.29;
commitid	omGXhtnOP9X49oJi;

1.29
date	2015.05.08.19.12.51;	author miod;	state Exp;
branches;
next	1.28;
commitid	f9koLQKgnj7EYOLZ;

1.28
date	2012.07.14.08.28.47;	author shadchin;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.14.08.25.12;	author shadchin;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.20.00.20.55;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.01.16.47.58;	author maja;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.19.15.34.45;	author martynas;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.15.21.38.16;	author martynas;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.15.20.32.28;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.26.13.36.33;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.21.07.54.17;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.20.15.22.23;	author robert;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.01.23.13.53;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.09.18.39.22;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.30.23.28.23;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.23.07.37.23;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.10.00.00.58;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.11.16.58.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.22.20.36.06;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.24.17.45.59;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.26.17.35.13;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.15.19.29.04;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.07.18.26.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.30.02.12.57;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.18.08.06.08;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.05.22.47.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.30.06.50.12;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.01.23.52.45;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Add fields for wsmouse/touchpad configuration.
@
text
@/*	$OpenBSD: wsconsctl.c,v 1.30 2017/04/06 17:33:39 jmc Exp $	*/
/*	$NetBSD: wsconsctl.c,v 1.2 1998/12/29 22:40:20 hannken Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Juergen Hannken-Illjes.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "wsconsctl.h"

extern const char *__progname;		/* from crt0.o */

extern struct field keyboard_field_tab[];
extern struct field mouse_field_tab[];
extern struct field display_field_tab[];

void	usage(void);

struct vartypesw {
	const	char *name;
	struct field *field_tab;
	void	(*init)(int,int);
	void	(*getval)(int);
	int	(*putval)(int);
	char *	(*nextdev)(int);
} typesw[] = {
	{ "keyboard", keyboard_field_tab, NULL,
	  keyboard_get_values, keyboard_put_values, keyboard_next_device },
	{ "mouse", mouse_field_tab, mouse_init,
	  mouse_get_values, mouse_put_values, mouse_next_device },
	{ "display", display_field_tab, NULL,
	  display_get_values, display_put_values, display_next_device },
	{ NULL }
};

struct vartypesw *tab_by_name(const char *, int *);

void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-an]\n"
	    "       %s [-n] [-f file] name ...\n"
	    "       %s [-n] [-f file] name=value ...\n",
	    __progname, __progname, __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int i, ch, error = 0, aflag = 0, do_merge, putval, devidx, devfd;
	struct vartypesw *sw = NULL;
	char *getsep = "=", *setsep = " -> ", *p;
	char *wdev = NULL;
	char *device;
	struct field *f;
	char devname[20];

	while ((ch = getopt(argc, argv, "af:nw")) != -1) {
		switch(ch) {
		case 'a':
			aflag = 1;
			break;
		case 'f':
			wdev = optarg;
			break;
		case 'n':
			getsep = setsep = NULL;
			break;
		case 'w':
			/* compat */
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (argc > 0 && aflag != 0)
		errx(1, "excess arguments after -a");
	if (argc == 0)
		aflag = 1;

	if (aflag != 0) {
		for (sw = typesw; sw->name; sw++) {
			for (devidx = 0;; devidx++) {
				device = (*sw->nextdev)(devidx);
				if (!device ||
				    ((devfd = open(device, O_WRONLY)) < 0 &&
				     (devfd = open(device, O_RDONLY)) < 0)) {
					if (!device || errno != ENXIO) {
						if (device && errno != ENOENT) {
							warn("%s", device);
							error = 1;
						}
						break;
					} else
						continue;
				}

				if (devidx == 0)
					snprintf(devname, sizeof(devname),
					    "%s", sw->name);
				else
					snprintf(devname, sizeof(devname),
					    "%s%d", sw->name, devidx);

				if (sw->init != NULL)
					(*sw->init)(devfd, devidx);

				for (f = sw->field_tab; f->name; f++)
					if (!(f->flags &
					    (FLG_NOAUTO|FLG_WRONLY)))
						f->flags |= FLG_GET;
				(*sw->getval)(devfd);
				for (f = sw->field_tab; f->name; f++)
					if (f->flags & FLG_DEAD)
						continue;
					else if (f->flags & FLG_NOAUTO)
						warnx("Use explicit arg to "
						    "view %s.%s.",
						    devname, f->name);
					else if (f->flags & FLG_GET)
						pr_field(devname, f, getsep);
			}
		}
	} else if (argc > 0) {
		for (i = 0; i < argc; i++) {
			sw = tab_by_name(argv[i], &devidx);
			if (!sw)
				continue;

			if (!wdev)
				device = (*sw->nextdev)(devidx);
			else
				device = wdev;

			if (!device ||
			    ((devfd = open(device, O_WRONLY)) < 0 &&
			     (devfd = open(device, O_RDONLY)) < 0)) {
				if (!device) {
					const char *c = strchr(argv[i], '.');
					int k;
					if (!c)
						c = strchr(argv[i], '\0');
					k = c - argv[i];
					warnx("%*.*s: no such variable",
					    k, k, argv[i]);
				} else
					warn("%s", device);
				error = 1;
				continue;
			}

			if (devidx == 0)
				snprintf(devname, sizeof(devname),
				    "%s", sw->name);
			else
				snprintf(devname, sizeof(devname),
				    "%s%d", sw->name, devidx);

			if (sw->init != NULL)
				(*sw->init)(devfd, devidx);

			p = strchr(argv[i], '=');
			if (p == NULL) {
				if (!strchr(argv[i], '.')) {
					for (f = sw->field_tab; f->name; f++)
						if (!(f->flags &
						    (FLG_NOAUTO|FLG_WRONLY)))
							f->flags |= FLG_GET;
					(*sw->getval)(devfd);
					for (f = sw->field_tab; f->name; f++)
						if (f->flags & FLG_DEAD)
							continue;
						else if (f->flags & FLG_NOAUTO)
							warnx("Use explicit "
							    "arg to view "
							    "%s.%s.",
							    devname, f->name);
						else if (f->flags & FLG_GET)
							pr_field(devname, f,
							    getsep);
					continue;
				}

				f = field_by_name(sw->field_tab, argv[i]);
				if (f->flags & FLG_DEAD)
					continue;
				if ((f->flags & FLG_WRONLY)) {
					warnx("%s: write only", argv[i]);
					continue;
				}
				f->flags |= FLG_GET;
				(*sw->getval)(devfd);
				if (f->flags & FLG_DEAD)
					continue;
				pr_field(devname, f, getsep);
			} else {
				if (!strchr(argv[i], '.') ||
				    (strchr(argv[i], '.') > p)) {
					warnx("%s: illegal variable name",
					    argv[i]);
					continue;
				}
				if (p > argv[i] &&
				    (*(p - 1) == '+' || *(p - 1) == '-')) {
					do_merge = *(p - 1);
					*(p - 1) = '\0';
				} else
					do_merge = 0;
				*p++ = '\0';

				f = field_by_name(sw->field_tab, argv[i]);
				if (f->flags & FLG_DEAD)
					continue;
				if (f->flags & FLG_RDONLY) {
					warnx("%s: read only", argv[i]);
					continue;
				}
				if (do_merge || f->flags & FLG_INIT) {
					if (!(f->flags & FLG_MODIFY))
						errx(1, "%s: can only be set",
						    argv[i]);
					f->flags |= FLG_GET;
					(*sw->getval)(devfd);
					f->flags &= ~FLG_GET;
				}
				rd_field(f, p, do_merge);
				f->flags |= FLG_SET;
				putval = (*sw->putval)(devfd);
				f->flags &= ~FLG_SET;
				if (putval != 0 ||
				    f->flags & (FLG_DEAD|FLG_NOAUTO))
					continue;
				if (f->flags & FLG_WRONLY) {
					pr_field(devname, f, setsep);
				} else {
					if (!(f->flags & FLG_NORDBACK)) {
						f->flags |= FLG_GET;
						(*sw->getval)(devfd);
					}
					if (f->flags & FLG_DEAD)
						continue;
					pr_field(devname, f, setsep);
				}
			}

			close(devfd);
		}
	} else
		usage();

	exit(error);
}

struct vartypesw *
tab_by_name(const char *var, int *idx)
{
	struct vartypesw *sw;
	const char *p = strchr(var, '.');
	char *c;
	int i;

	for (sw = typesw; sw->name; sw++)
		if (!strncmp(sw->name, var, strlen(sw->name)))
			break;

	if (!p)
		p = strchr(var, '\0');

	if (!sw->name) {
		i = p - var;
		warnx("%*.*s: no such variable", i, i, var);
		return (NULL);
	}

	if ((p - var) > strlen(sw->name)) {
		c = (char *)var;
		c = c + strlen(sw->name);
		i = 0;
		while (c < p) {
			if (*c >= '0' && *c <= '9')
				i = i * 10 + *c - '0';
			else
				i = -1;
			c++;
		}
		if (i < 0 || i > 32) {
			i = p - var;
			warnx("%*.*s: no such variable", i, i, var);
			return (NULL);
		}
	} else
		i = 0;

	*idx = i;

	return (sw);
}
@


1.30
log
@document -=; while here, simplify things so that we don;t add a separate
usage every time we think of a new way to use this;

-= bits from anton lindqvist
ok tb tom
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.29 2015/05/08 19:12:51 miod Exp $	*/
d53 1
d58 1
a58 1
	{ "keyboard", keyboard_field_tab,
d60 1
a60 1
	{ "mouse", mouse_field_tab,
d62 1
a62 1
	{ "display", display_field_tab,
d142 3
d195 3
@


1.29
log
@Add a new `don't read back' flag for variables, to prevent reading their value
after modifying them. Give this flag to `display.focus', since screen
switching is asynchronous, and reading back will return the screen we are
switching from if the switch has not completed yet.

Also, disallow -= and += syntax for display.focus, as it doesn't make any sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.28 2012/07/14 08:28:47 shadchin Exp $	*/
d74 2
a75 3
	    "       %s [-n] [-f file] name=value ...\n"
	    "       %s [-n] [-f file] name+=value ...\n",
	    __progname, __progname, __progname, __progname);
@


1.28
log
@ansify

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.27 2012/07/14 08:25:12 shadchin Exp $	*/
d267 4
a270 2
					f->flags |= FLG_GET;
					(*sw->getval)(devfd);
@


1.27
log
@zap whitespace

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.26 2010/08/20 00:20:55 fgsch Exp $	*/
d69 1
a69 1
usage()
@


1.26
log
@Don't silently ignore errors if we cannot open the device. While I'm here
simplify the code and apply some style(9).
Discussed with and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.25 2010/07/01 16:47:58 maja Exp $	*/
d128 1
a128 1
							error = 1;	
d322 1
a322 1
	
@


1.25
log
@Learn wsconsctl to handle more than the first keyboard, mouse and display.
E.g. if we have a /dev/wskbd1 keyboard1 will show up when doing a -a.

wsconsctl keyboard1 will now show you all variables for keyboard1.

feedback and ok miod@@. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.24 2009/07/19 15:34:45 martynas Exp $	*/
d35 1
d48 1
a48 1
void usage(char *);
d51 1
a51 1
	const char *name;
d53 3
a55 3
	void (*getval)(const char *pre, int);
	int (*putval)(const char *pre, int);
	int (*nextdev)(int *);
d69 1
a69 1
usage(char *msg)
a70 3
	if (msg != NULL)
		fprintf(stderr, "%s: %s\n", __progname, msg);

a76 1

d87 1
d106 1
a106 1
			usage(NULL);
d114 1
a114 1
		usage("excess arguments after -a");
d120 14
a133 5
			devidx = 0;
			while (devidx >= 0) {
				devfd = (*sw->nextdev)(&devidx);
				if (devidx < 0)
					continue;
d136 2
a137 4
					snprintf(devname,
						 sizeof(devname),
						 "%s",
						 sw->name);
d139 2
a140 9
					snprintf(devname,
						 sizeof(devname),
						 "%s%d",
						 sw->name,
						 devidx);
				devidx++;

				if (devfd < 0)
					continue;
d143 2
a144 1
					if ((f->flags & (FLG_NOAUTO|FLG_WRONLY)) == 0)
d146 1
a146 1
				(*sw->getval)(devname, devfd);
d151 3
a153 2
						warnx("Use explicit arg to view %s.%s.",
						      devname, f->name);
d160 8
a167 5
			p = strchr(argv[i], '=');
			if (p == NULL) {
				sw = tab_by_name(argv[i], &devidx);
				if (!sw)
					continue;
d169 4
a172 2
				devfd = (*sw->nextdev)(&devidx);
				if (devidx < 0) {
d178 7
a184 3
					warnx("%*.*s: no such variable", k, k, argv[i]);
					continue;
				}
d186 6
a191 24
				if (devidx == 0)
					snprintf(devname,
						 sizeof(devname),
						 "%s",
						 sw->name);
				else
					snprintf(devname,
						 sizeof(devname),
						 "%s%d",
						 sw->name,
						 devidx);

				if (wdev != NULL &&
				    (devfd = open(wdev, O_WRONLY)) < 0 &&
				    (devfd = open(wdev, O_RDONLY)) < 0) {
					warn("open: %s", wdev);
					error = 1;
					continue;
				}

				if (devfd < 0)
					continue;

				if (!strchr(argv[i],'.')) {
d193 3
d197 2
a198 1
						if ((f->flags & (FLG_NOAUTO|FLG_WRONLY)) == 0)
d200 1
a200 1
					(*sw->getval)(devname, devfd);
d205 4
a208 2
							warnx("Use explicit arg to view %s.%s.",
							      devname, f->name);
d210 2
a211 2
							pr_field(devname, f, getsep);

d218 1
a218 1
				if ((f->flags & FLG_WRONLY) != 0) {
d223 1
a223 1
				(*sw->getval)(devname, devfd);
d227 14
d242 1
a242 79
				continue;
			}
			if (!strchr(argv[i],'.') ||
			    (strchr(argv[i],'.') > p)) {
				warnx("%s: illegal variable name", argv[i]);
				continue;
			}
			if (p > argv[i] &&
			    (*(p - 1) == '+' || *(p - 1) == '-')) {
				do_merge = *(p - 1);
				*(p - 1) = '\0';
			} else
				do_merge = 0;
			*p++ = '\0';

			sw = tab_by_name(argv[i], &devidx);
			if (!sw)
				continue;

			devfd = (*sw->nextdev)(&devidx);
			if (devidx < 0) {
				const char *c = strchr(argv[i], '.');
				int k;
				if (!c)
					c = strchr(argv[i], '\0');
				k = c - argv[i];
				warnx("%*.*s: no such variable", k, k, argv[i]);
				continue;
			}

			if (devidx == 0)
				snprintf(devname,
					 sizeof(devname),
					 "%s",
					 sw->name);
			else
				snprintf(devname,
					 sizeof(devname),
					 "%s%d",
					 sw->name,
					 devidx);

			if (wdev != NULL &&
			    (devfd = open(wdev, O_WRONLY)) < 0 &&
			    (devfd = open(wdev, O_RDONLY)) < 0) {
				warn("open: %s", wdev);
				error = 1;
				continue;
			}

			if (devfd < 0)
				continue;

			f = field_by_name(sw->field_tab, argv[i]);
			if (f->flags & FLG_DEAD)
				continue;
			if ((f->flags & FLG_RDONLY) != 0) {
				warnx("%s: read only", argv[i]);
				continue;
			}
			if (do_merge || f->flags & FLG_INIT) {
				if ((f->flags & FLG_MODIFY) == 0)
					errx(1, "%s: can only be set",
					     argv[i]);
				f->flags |= FLG_GET;
				(*sw->getval)(devname, devfd);
				f->flags &= ~FLG_GET;
			}
			rd_field(f, p, do_merge);
			f->flags |= FLG_SET;
			putval = (*sw->putval)(devname, devfd);
			f->flags &= ~FLG_SET;
			if (putval != 0 || f->flags & (FLG_DEAD | FLG_NOAUTO))
				continue;
			if (f->flags & FLG_WRONLY) {
				pr_field(devname, f, setsep);
			} else {
				f->flags |= FLG_GET;
				(*sw->getval)(devname, devfd);
d245 28
a272 1
				pr_field(devname, f, setsep);
d274 2
d278 1
a278 1
		usage(NULL);
d280 1
a280 1
	return (error);
d296 1
a296 1
		p=strchr(var, '\0');
d310 1
a310 1
				i=i*10 + *c - '0';
d312 1
a312 1
				i=-1;
d318 1
a318 1
			return(NULL);
@


1.24
log
@if variable has a NOAUTO flag set;  skip printing.
requested & diff tested by david@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.23 2009/07/15 21:38:16 martynas Exp $	*/
a40 4
#define PATH_KEYBOARD		"/dev/wskbd0"
#define PATH_MOUSE		"/dev/wsmouse0"
#define PATH_DISPLAY		"/dev/ttyC0"

d50 1
a50 2
	const char *name, *file;
	int fd;
d54 1
d56 6
a61 6
	{ "keyboard", PATH_KEYBOARD, -1, keyboard_field_tab,
	  keyboard_get_values, keyboard_put_values },
	{ "mouse", PATH_MOUSE, -1, mouse_field_tab,
	  mouse_get_values, mouse_put_values },
	{ "display", PATH_DISPLAY, -1, display_field_tab,
	  display_get_values, display_put_values },
d65 1
a65 1
struct vartypesw *tab_by_name(const char *);
d86 1
a86 1
	int i, ch, error = 0, aflag = 0, do_merge, putval;
d91 1
d122 34
a155 6
			if (sw->fd < 0 &&
			    (sw->fd = open(sw->file, O_WRONLY)) < 0 &&
			    (sw->fd = open(sw->file, O_RDONLY)) < 0) {
				warn("%s", sw->file);
				error = 1;
				continue;
a156 12
			for (f = sw->field_tab; f->name; f++)
				if ((f->flags & (FLG_NOAUTO|FLG_WRONLY)) == 0)
					f->flags |= FLG_GET;
			(*sw->getval)(sw->name, sw->fd);
			for (f = sw->field_tab; f->name; f++)
				if (f->flags & FLG_DEAD)
					continue;
				else if (f->flags & FLG_NOAUTO)
					warnx("Use explicit arg to view %s.%s.",
					      sw->name, f->name);
				else if (f->flags & FLG_GET)
					pr_field(sw->name, f, getsep);
d162 1
a162 1
				sw = tab_by_name(argv[i]);
d166 10
a175 2
				if (wdev != NULL)
					sw->file = (const char *)wdev;
d177 16
a192 4
				if (sw->fd < 0 &&
				    (sw->fd = open(sw->file, O_WRONLY)) < 0 &&
				    (sw->fd = open(sw->file, O_RDONLY)) < 0) {
					warn("open: %s", sw->file);
d196 22
d226 1
a226 1
				(*sw->getval)(sw->name, sw->fd);
d229 7
a235 1
				pr_field(sw->name, f, getsep);
d245 2
a246 1
			sw = tab_by_name(argv[i]);
d250 10
a259 2
			if (wdev != NULL)
				sw->file = (const char *)wdev;
d261 16
a276 4
			if (sw->fd < 0 &&
			    (sw->fd = open(sw->file, O_WRONLY)) < 0 &&
			    (sw->fd = open(sw->file, O_RDONLY)) < 0) {
				warn("open: %s", sw->file);
d280 4
d296 1
a296 1
				(*sw->getval)(sw->name, sw->fd);
d301 1
a301 1
			putval = (*sw->putval)(sw->name, sw->fd);
d306 1
a306 1
				pr_field(sw->name, f, setsep);
d309 1
a309 1
				(*sw->getval)(sw->name, sw->fd);
d312 1
a312 1
				pr_field(sw->name, f, setsep);
d322 1
a322 1
tab_by_name(const char *var)
d326 2
a327 5

	if (!p) {
		warnx("%s: illegal variable name", var);
		return (NULL);
	}
d330 1
a330 1
		if (!strncmp(sw->name, var, p - var))
d333 3
d337 2
a338 1
		warnx("%s: no such variable", var);
d341 21
@


1.23
log
@now that set print is in one place;  it is possible to suppress var
making n flag work as expected for set.  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.22 2009/07/15 20:32:28 martynas Exp $	*/
d217 1
a217 1
			if (putval != 0 || f->flags & FLG_DEAD)
@


1.22
log
@for rw query and print value that has actually been set in the
similar way that mixerctl does.  so that info for setting things
like brightness makes sense (since we scale, like, 8 values to
per-cent).  also, it consistifies get/put, shrinks code since we
don't need to do that in every single 'driver'.  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.21 2008/06/26 05:42:06 ray Exp $	*/
d92 1
a92 1
	char *sep = "=", *p;
d105 1
a105 1
			sep = NULL;
d143 1
a143 1
					pr_field(sw->name, f, sep);
d174 1
a174 1
				pr_field(sw->name, f, sep);
d220 1
a220 1
				pr_field(sw->name, f, " -> ");
d226 1
a226 1
				pr_field(sw->name, f, " -> ");
@


1.21
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.20 2007/11/26 13:36:33 deraadt Exp $	*/
d58 1
a58 1
	void (*putval)(const char *pre, int);
d90 1
a90 1
	int i, ch, error = 0, aflag = 0, do_merge;
d215 1
a215 1
			(*sw->putval)(sw->name, sw->fd);
d217 11
@


1.20
log
@if no arguments given, assume a nice default; ok miod jakemsr deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.19 2007/05/21 07:54:17 jmc Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.19
log
@options w/o args come before options which take args;
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.18 2007/05/20 15:22:23 robert Exp $	*/
d85 1
a85 1
	    "usage: %s [-n] -a\n"
d127 2
@


1.18
log
@add a -f option to allow specifing an alternative
control device; "put it in" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.17 2006/04/01 23:13:53 miod Exp $	*/
d86 3
a88 3
	    "       %s [-f file] [-n] name ...\n"
	    "       %s [-f file] [-n] name=value ...\n"
	    "       %s [-f file] [-n] name+=value ...\n",
@


1.17
log
@Do not attempt to print parameters which turned out to be dead; fixes PR#5066.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.16 2004/08/09 18:39:22 deraadt Exp $	*/
d86 3
a88 3
	    "       %s [-n] name ...\n"
	    "       %s [-n] name=value ...\n"
	    "       %s [-n] name+=value ...\n",
d100 1
d103 1
a103 1
	while ((ch = getopt(argc, argv, "anw")) != -1) {
d108 3
d157 4
d192 4
@


1.16
log
@minor cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.15 2004/07/30 23:28:23 jmc Exp $	*/
d169 2
@


1.15
log
@mark down some punctuation, and sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.14 2004/06/23 07:37:23 david Exp $	*/
d88 2
a89 2
	    "       %s [-n] name+=value ...\n", __progname,
		__progname, __progname, __progname);
d97 3
a99 4
	int i, ch, error;
	int aflag;
	char *sep, *p;
	struct vartypesw *sw;
a100 5
	int do_merge;

	error = aflag = 0;
	sw = NULL;
	sep = "=";
@


1.14
log
@make -w optional; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.13 2003/07/10 00:00:58 david Exp $	*/
d85 2
a86 1
	    "usage: %s [-n] name ...\n"
d88 2
a89 2
	    "       %s [-n] -a\n", __progname,
		__progname, __progname);
@


1.13
log
@add missing includes
ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.12 2002/12/11 16:58:51 deraadt Exp $	*/
d86 1
a86 1
	    "       %s [-n] -w name=value ...\n"
d97 1
a97 1
	int aflag, wflag;
d103 1
a103 1
	error = aflag = wflag = 0;
d116 1
a116 1
			wflag = 1;
a127 2
	if (aflag != 0 && wflag != 0)
		usage("only one of -a or -w may be given");
d152 3
a154 46
		if (wflag != 0)
			for (i = 0; i < argc; i++) {
				p = strchr(argv[i], '=');
				if (p == NULL) {
					warnx("'=' not found");
					continue;
				}
				if (p > argv[i] &&
				    (*(p - 1) == '+' || *(p - 1) == '-')) {
					do_merge = *(p - 1);
					*(p - 1) = '\0';
				} else
					do_merge = 0;
				*p++ = '\0';
				sw = tab_by_name(argv[i]);
				if (!sw)
					continue;
				if (sw->fd < 0 &&
				    (sw->fd = open(sw->file, O_WRONLY)) < 0 &&
				    (sw->fd = open(sw->file, O_RDONLY)) < 0) {
					warn("open: %s", sw->file);
					error = 1;
					continue;
				}
				f = field_by_name(sw->field_tab, argv[i]);
				if (f->flags & FLG_DEAD)
					continue;
				if ((f->flags & FLG_RDONLY) != 0) {
					warnx("%s: read only", argv[i]);
					continue;
				}
				if (do_merge || f->flags & FLG_INIT) {
					if ((f->flags & FLG_MODIFY) == 0)
						errx(1, "%s: can only be set",
						     argv[i]);
					f->flags |= FLG_GET;
					(*sw->getval)(sw->name, sw->fd);
					f->flags &= ~FLG_GET;
				}
				rd_field(f, p, do_merge);
				f->flags |= FLG_SET;
				(*sw->putval)(sw->name, sw->fd);
				f->flags &= ~FLG_SET;
			}
		else
			for (i = 0; i < argc; i++) {
d175 1
d177 37
@


1.12
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.11 2002/05/22 20:36:06 mickey Exp $	*/
d44 1
@


1.11
log
@implement new type: %%, given min,cur,max print the value in %%.
also accepts -= and += to adjust the value.
implement new flags: INIT, DEAD.
init means to prefetch the variable before setting, where
dead means to assume the variable is not implemented
(enottty was observed, most likely), set by the low-level
routines (upon observing the ioctl results).
add the variables for screen brightness,contrast,backlight --
all are precent-type, also rework the display.c to be easier
on the eyes. requested, commented and helped upon by miod@@ and drahn@@.
there was a discussion on wheather truncate or round
(the thin and think ends of the same egg) where
decided to allow it to truncate until demanded
otherwise by the eager masses.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.10 2002/02/16 21:27:38 millert Exp $	*/
d78 1
a78 2
usage(msg)
	char *msg;
d93 1
a93 3
main(argc, argv)
	int argc;
	char **argv;
d227 1
a227 2
tab_by_name(var)
	const char *var;
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.9 2001/10/24 17:45:59 miod Exp $	*/
d142 3
a144 4
			for (i = 0; sw->field_tab[i].name; i++)
				if ((sw->field_tab[i].flags &
				    (FLG_NOAUTO|FLG_WRONLY)) == 0)
					sw->field_tab[i].flags |= FLG_GET;
d146 4
a149 2
			for (i = 0; sw->field_tab[i].name; i++)
				if (sw->field_tab[i].flags & FLG_NOAUTO)
d151 3
a153 3
					      sw->name, sw->field_tab[i].name);
				else if (sw->field_tab[i].flags & FLG_GET)
					pr_field(sw->name, sw->field_tab + i, sep);
d163 3
a165 1
				if (p > argv[i] && *(p - 1) == '+') {
a166 1
					do_merge = 1;
d181 2
d187 1
a187 1
				if (do_merge) {
d213 2
@


1.9
log
@- repair usage() output
- when changing display.foo settings, print "display.foo -> bar" like done
for mouse.* and keyboard.*
- use warn() over err() whenever possible and appropriate code path to display
as much as useful information as possible even if one ioctl fails. This is
especially useful to get the display.* settings via wsconsctl -a if your
mouse can't be probed, like on the iBook.

ok mcikye@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.8 2001/08/26 17:35:13 deraadt Exp $	*/
d57 1
a57 1
void usage __P((char *));
d63 2
a64 2
	void (*getval) __P((const char *pre, int));
	void (*putval) __P((const char *pre, int));
d75 1
a75 1
struct vartypesw *tab_by_name __P((const char *));
@


1.8
log
@minor cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.7 2001/07/15 19:29:04 mickey Exp $	*/
d85 3
a87 3
	    "usage: %s [-f file] [-n] name ...\n"
	    "       %s [-f file] [-n] -w name=value ...\n"
	    "       %s [-f file] [-n] -a\n", __progname,
a119 1
		case '?':
@


1.7
log
@paste open for each use, cache file descriptors
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.6 2001/07/07 18:26:22 deraadt Exp $	*/
d82 1
a82 1
		fprintf(stderr, "%s: %s\n\n", __progname, msg);
@


1.6
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.5 2001/06/30 02:12:57 mickey Exp $	*/
d59 1
a59 1
const struct vartypesw {
d61 1
d66 1
a66 1
	{ "keyboard", PATH_KEYBOARD, keyboard_field_tab,
d68 1
a68 1
	{ "mouse", PATH_MOUSE, mouse_field_tab,
d70 1
a70 1
	{ "display", PATH_DISPLAY, display_field_tab,
d75 1
a75 1
const struct vartypesw *tab_by_name __P((const char *));
d98 1
a98 1
	int i, ch, fd = -1, error;
d101 1
a101 1
	const struct vartypesw *sw;
d136 3
a138 2
			if ((fd = open(sw->file, O_WRONLY)) < 0 &&
			    (fd = open(sw->file, O_RDONLY)) < 0) {
d147 1
a147 1
			(*sw->getval)(sw->name, fd);
a153 1
			close(fd);
d156 1
a156 1
		if (wflag != 0) {
d172 7
d189 1
a189 1
					(*sw->getval)(sw->name, fd);
d194 1
a194 1
				(*sw->putval)(sw->name, fd);
d197 1
a197 1
		} else {
d202 7
d215 1
a215 1
				(*sw->getval)(sw->name, fd);
a217 1
		}
d224 1
a224 1
const struct vartypesw *
d228 1
a228 1
	const struct vartypesw *sw;
@


1.5
log
@make it more sysctl-like, ommit -kmd switches.
no backwards compatibility keeped.
add ability to change screens from cmd line.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.4 2001/05/18 08:06:08 mickey Exp $	*/
d97 1
a97 1
	int i, ch, fd, error;
@


1.4
log
@why exit if returns
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.3 2001/02/05 22:47:13 matthieu Exp $	*/
a55 3
extern int keyboard_field_tab_len;
extern int mouse_field_tab_len;
extern int display_field_tab_len;
d57 1
a57 2
static void usage __P((char *));
int main __P((int, char **));
d59 18
a76 1
static void
d83 5
a87 5
	fprintf(stderr, "usage: %s [-kmd] [-f file] [-n] name ...\n",
		__progname);
	fprintf(stderr, " -or-  %s [-kmd] [-f file] [-n] -w name=value ...\n",
		__progname);
	fprintf(stderr, " -or-  %s [-kmd] [-f file] [-n] -a\n", __progname);
d97 9
a105 14
	int i, ch, fd;
	int aflag, dflag, kflag, mflag, wflag;
	char *file, *sep, *p;
	struct field *f, *field_tab;
	int do_merge, field_tab_len;
	void (*getval) __P((int));
	void (*putval) __P((int));

	aflag = 0;
	dflag = 0;
	kflag = 0;
	mflag = 0;
	wflag = 0;
	file = NULL;
d108 1
a108 1
	while ((ch = getopt(argc, argv, "adf:kmnw")) != -1) {
a112 12
		case 'd':
			dflag = 1;
			break;
		case 'f':
			file = optarg;
			break;
		case 'k':
			kflag = 1;
			break;
		case 'm':
			mflag = 1;
			break;
a127 4
	if (dflag + kflag + mflag == 0)
		kflag = 1;
	if (dflag + kflag + mflag > 1)
		usage("only one of -k, -d or -m may be given");
a132 31
	if (kflag) {
		if (file == NULL)
			file = PATH_KEYBOARD;
		field_tab = keyboard_field_tab;
		field_tab_len = keyboard_field_tab_len;
		getval = keyboard_get_values;
		putval = keyboard_put_values;
	} else if (mflag) {
		if (file == NULL)
			file = PATH_MOUSE;
		field_tab = mouse_field_tab;
		field_tab_len = mouse_field_tab_len;
		getval = mouse_get_values;
		putval = mouse_put_values;
	} else if (dflag) {
		if (file == NULL)
			file = PATH_DISPLAY;
		field_tab = display_field_tab;
		field_tab_len = display_field_tab_len;
		getval = display_get_values;
		putval = display_put_values;
	}

	field_setup(field_tab, field_tab_len);

	fd = open(file, O_WRONLY);
	if (fd < 0)
		fd = open(file, O_RDONLY);
	if (fd < 0)
		err(1, "%s", file);

d134 20
a153 10
		for (i = 0; i < field_tab_len; i++)
			if ((field_tab[i].flags & (FLG_NOAUTO|FLG_WRONLY)) == 0)
				field_tab[i].flags |= FLG_GET;
		(*getval)(fd);
		for (i = 0; i < field_tab_len; i++)
			if (field_tab[i].flags & FLG_NOAUTO)
				warnx("Use explicit arg to view %s.",
				      field_tab[i].name);
			else if (field_tab[i].flags & FLG_GET)
				pr_field(field_tab + i, sep);
d158 4
a161 2
				if (p == NULL)
					errx(1, "'=' not found");
d168 8
a175 3
				f = field_by_name(argv[i]);
				if ((f->flags & FLG_RDONLY) != 0)
					errx(1, "%s: read only", argv[i]);
d181 1
a181 1
					(*getval)(fd);
d186 1
a186 1
				(*putval)(fd);
d191 8
a198 3
				f = field_by_name(argv[i]);
				if ((f->flags & FLG_WRONLY) != 0)
					errx(1, "%s: write only", argv[i]);
d200 2
a202 4
			(*getval)(fd);
			for (i = 0; i < field_tab_len; i++)
				if (field_tab[i].flags & FLG_GET)
					pr_field(field_tab + i, sep);
d207 25
a231 1
	return (0);
@


1.3
log
@when flags are FLG_WRONLY, say "write only" instead of "read only"
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.2 2001/01/30 06:50:12 aaron Exp $	*/
d226 1
a226 1
	exit(0);
@


1.2
log
@Change /dev/ttyE* to /dev/ttyC* to reflect reality in OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsconsctl.c,v 1.1 2000/07/01 23:52:45 mickey Exp $	*/
d215 1
a215 1
					errx(1, "%s: read only", argv[i]);
@


1.1
log
@wscons control tool; initial import from newtbsd tree
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
#define PATH_DISPLAY		"/dev/ttyE0"
@

