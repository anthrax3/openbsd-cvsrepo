head	1.65;
access;
symbols
	OPENBSD_6_2:1.65.0.4
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.63.0.8
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.63.0.4
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.62.0.10
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.62.0.2
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.62.0.6
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.62.0.4
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.59.0.4
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.59.0.2
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.58.0.2
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.2
	OPENBSD_5_0:1.53.0.6
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.53.0.4
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.45.0.4
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.34.0.4
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.65
date	2017.09.02.22.09.32;	author phessler;	state Exp;
branches;
next	1.64;
commitid	wyWSQOZRUfSizbSE;

1.64
date	2017.07.21.20.38.20;	author bru;	state Exp;
branches;
next	1.63;
commitid	ob8Bi51A764QwCzw;

1.63
date	2016.02.10.05.49.50;	author guenther;	state Exp;
branches;
next	1.62;
commitid	4VoeOO8ryUyFcWSQ;

1.62
date	2013.11.17.13.41.26;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.20.22.07.57;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.20.10.43.47;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2012.10.29.11.56.19;	author stsp;	state Exp;
branches;
next	1.58;

1.58
date	2012.07.14.08.25.12;	author shadchin;	state Exp;
branches;
next	1.57;

1.57
date	2012.04.17.14.53.47;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2012.04.17.08.51.24;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2011.09.20.17.00.24;	author shadchin;	state Exp;
branches;
next	1.54;

1.54
date	2011.09.15.04.59.16;	author shadchin;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.02.15.47.58;	author chl;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.01.03.00.14;	author maja;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.01.02.37.21;	author maja;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.28.20.40.39;	author maja;	state Exp;
branches;
next	1.49;

1.49
date	2010.03.07.21.26.24;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2010.03.04.14.31.12;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2010.02.28.22.32.48;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.25.22.02.46;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.03.17.37.02;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.03.21.30.11;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.02.18.38.06;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2009.05.20.18.22.30;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.05.09.20.34.25;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2009.03.12.19.10.22;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.29.22.25.15;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.24.20.10.55;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.27.16.56.46;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.08.20.51.58;	author robert;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.24.22.19.52;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.14.21.05.43;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.14.18.52.15;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.09.21.52.09;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.31.15.33.57;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.22.11.59.10;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.17.04.21.05;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.14.22.39.17;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.14.15.49.03;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.24.13.37.41;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.04.01.09.23;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.01.07.52.57;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.17.21.21.26;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.14.06.39.47;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.28.02.59.31;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.12.01.44.09;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.11.19.49.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.05.19.25.54;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.17.07.10.25;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.11.18.27.19;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.08.22.04.53;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.25.19.01.15;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.07.20.56.38;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.30.15.18.58;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.22.21.34.02;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.22.20.36.06;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.23.05.44.20;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.06.21.52.34;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.30.02.12.57;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.08.22.31.09;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.03.08.53.46;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.28.22.45.20;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.01.23.52.45;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.65
log
@teach wsconsctl about efifb

OK patrick@@
@
text
@/*	$OpenBSD: util.c,v 1.64 2017/07/21 20:38:20 bru Exp $ */
/*	$NetBSD: util.c,v 1.8 2000/03/14 08:11:53 sato Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Juergen Hannken-Illjes.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/ioctl.h>
#include <sys/time.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsksymdef.h>
#include <err.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include "wsconsctl.h"
#include "mousecfg.h"

#define TABLEN(t)		(sizeof(t)/sizeof(t[0]))

extern struct wskbd_map_data kbmap;	/* from keyboard.c */
extern struct wskbd_map_data newkbmap;	/* from map_parse.y */
extern struct wsmouse_calibcoords wmcoords;	/* from mouse.c */

struct nameint {
	int value;
	char *name;
};

static const struct nameint kbtype_tab[] = {
	{ WSKBD_TYPE_LK201,	"lk201" },
	{ WSKBD_TYPE_LK401,	"lk401" },
	{ WSKBD_TYPE_PC_XT,	"pc-xt" },
	{ WSKBD_TYPE_PC_AT,	"pc-at" },
	{ WSKBD_TYPE_USB,	"usb" },
	{ WSKBD_TYPE_NEXT,	"NeXT" },
	{ WSKBD_TYPE_HPC_KBD,	"hpc-kbd" },
	{ WSKBD_TYPE_HPC_BTN,	"hpc-btn" },
	{ WSKBD_TYPE_ADB,	"adb" },
	{ WSKBD_TYPE_SUN,	"sun" },
	{ WSKBD_TYPE_SUN5,	"sun5" },
	{ WSKBD_TYPE_HIL,	"hil" },
	{ WSKBD_TYPE_GSC,	"hp-ps2" },
	{ WSKBD_TYPE_LUNA,	"luna" },
	{ WSKBD_TYPE_ZAURUS,	"zaurus" },
	{ WSKBD_TYPE_DOMAIN,	"domain" },
	{ WSKBD_TYPE_BLUETOOTH,	"bluetooth" },
	{ WSKBD_TYPE_KPC,	"kpc" },
	{ WSKBD_TYPE_SGI,	"sgi" },
};

static const struct nameint mstype_tab[] = {
	{ WSMOUSE_TYPE_VSXXX,	"dec-tc" },
	{ WSMOUSE_TYPE_PS2,	"ps2" },
	{ WSMOUSE_TYPE_USB,	"usb" },
	{ WSMOUSE_TYPE_LMS,	"lms" },
	{ WSMOUSE_TYPE_MMS,	"mms" },
	{ WSMOUSE_TYPE_TPANEL,	"touch-panel" },
	{ WSMOUSE_TYPE_NEXT,	"NeXT" },
	{ WSMOUSE_TYPE_ARCHIMEDES, "archimedes" },
	{ WSMOUSE_TYPE_ADB,	"adb" },
	{ WSMOUSE_TYPE_HIL,	"hil" },
	{ WSMOUSE_TYPE_LUNA,	"luna" },
	{ WSMOUSE_TYPE_DOMAIN,	"domain" },
	{ WSMOUSE_TYPE_BLUETOOTH, "bluetooth" },
	{ WSMOUSE_TYPE_SUN,	"sun" },
	{ WSMOUSE_TYPE_SYNAPTICS, "synaptics" },
	{ WSMOUSE_TYPE_ALPS,	"alps" },
	{ WSMOUSE_TYPE_SGI,	"sgi" },
	{ WSMOUSE_TYPE_ELANTECH, "elantech" },
};

static const struct nameint dpytype_tab[] = {
	{ WSDISPLAY_TYPE_UNKNOWN,	"unknown" },
	{ WSDISPLAY_TYPE_PM_MONO,	"dec-pm-mono" },
	{ WSDISPLAY_TYPE_PM_COLOR,	"dec-pm-color" },
	{ WSDISPLAY_TYPE_CFB,		"dec-cfb" },
	{ WSDISPLAY_TYPE_XCFB,		"dec-xcfb" },
	{ WSDISPLAY_TYPE_MFB,		"dec-mfb" },
	{ WSDISPLAY_TYPE_SFB,		"dec-sfb" },
	{ WSDISPLAY_TYPE_ISAVGA,	"vga-isa" },
	{ WSDISPLAY_TYPE_PCIVGA,	"vga-pci" },
	{ WSDISPLAY_TYPE_TGA,		"dec-tga-pci" },
	{ WSDISPLAY_TYPE_SFBP,		"dec-sfb+" },
	{ WSDISPLAY_TYPE_PCIMISC,	"generic-pci" },
	{ WSDISPLAY_TYPE_NEXTMONO,	"next-mono" },
	{ WSDISPLAY_TYPE_PX,		"dec-px" },
	{ WSDISPLAY_TYPE_PXG,		"dec-pxg" },
	{ WSDISPLAY_TYPE_TX,		"dec-tx" },
	{ WSDISPLAY_TYPE_HPCFB,		"generic-hpc" },
	{ WSDISPLAY_TYPE_VIDC,		"arm-vidc" },
	{ WSDISPLAY_TYPE_SPX,		"dec-spx" },
	{ WSDISPLAY_TYPE_GPX,		"dec-gpx" },
	{ WSDISPLAY_TYPE_LCG,		"dec-lcg" },
	{ WSDISPLAY_TYPE_VAX_MONO,	"dec-mono" },
	{ WSDISPLAY_TYPE_SB_P9100,	"p9100" },
	{ WSDISPLAY_TYPE_EGA,		"ega" },
	{ WSDISPLAY_TYPE_DCPVR,		"powervr" },
	{ WSDISPLAY_TYPE_SUN24,		"sun24" },
	{ WSDISPLAY_TYPE_SUNBW,		"sunbw" },
	{ WSDISPLAY_TYPE_STI,		"hp-sti" },
	{ WSDISPLAY_TYPE_SUNCG3,	"suncg3" },
	{ WSDISPLAY_TYPE_SUNCG6,	"suncg6" },
	{ WSDISPLAY_TYPE_SUNFFB,	"sunffb" },
	{ WSDISPLAY_TYPE_SUNCG14,	"suncg14" },
	{ WSDISPLAY_TYPE_SUNCG2,	"suncg2" },
	{ WSDISPLAY_TYPE_SUNCG4,	"suncg4" },
	{ WSDISPLAY_TYPE_SUNCG8,	"suncg8" },
	{ WSDISPLAY_TYPE_SUNTCX,	"suntcx" },
	{ WSDISPLAY_TYPE_AGTEN,		"agten" },
	{ WSDISPLAY_TYPE_XVIDEO,	"xvideo" },
	{ WSDISPLAY_TYPE_SUNCG12,	"suncg12" },
	{ WSDISPLAY_TYPE_MGX,		"mgx" },
	{ WSDISPLAY_TYPE_SB_P9000,	"p9000" },
	{ WSDISPLAY_TYPE_RFLEX,		"rasterflex" },
	{ WSDISPLAY_TYPE_LUNA,		"luna" },
	{ WSDISPLAY_TYPE_DVBOX,		"davinci" },
	{ WSDISPLAY_TYPE_GBOX,		"gatorbox" },
	{ WSDISPLAY_TYPE_RBOX,		"renaissance" },
	{ WSDISPLAY_TYPE_HYPERION,	"hyperion" },
	{ WSDISPLAY_TYPE_TOPCAT,	"topcat" },
	{ WSDISPLAY_TYPE_PXALCD,	"pxalcd" },
	{ WSDISPLAY_TYPE_MAC68K,	"mac68k" },
	{ WSDISPLAY_TYPE_SUNLEO,	"sunleo" },
	{ WSDISPLAY_TYPE_TVRX,		"tvrx" },
	{ WSDISPLAY_TYPE_CFXGA,		"cfxga" },
	{ WSDISPLAY_TYPE_LCSPX,		"dec-lcspx" },
	{ WSDISPLAY_TYPE_GBE,		"gbe" },
	{ WSDISPLAY_TYPE_LEGSS,		"dec-legss" },
	{ WSDISPLAY_TYPE_IFB,		"ifb" },
	{ WSDISPLAY_TYPE_RAPTOR,	"raptor" },
	{ WSDISPLAY_TYPE_DL,		"displaylink" },
	{ WSDISPLAY_TYPE_MACHFB,	"mach64" },
	{ WSDISPLAY_TYPE_GFXP,		"gfxp" },
	{ WSDISPLAY_TYPE_RADEONFB,	"radeon" },
	{ WSDISPLAY_TYPE_SMFB,		"smfb" },
	{ WSDISPLAY_TYPE_SISFB,		"sisfb" },
	{ WSDISPLAY_TYPE_ODYSSEY,	"odyssey" },
	{ WSDISPLAY_TYPE_IMPACT,	"impact" },
	{ WSDISPLAY_TYPE_GRTWO,		"grtwo" },
	{ WSDISPLAY_TYPE_NEWPORT,	"newport" },
	{ WSDISPLAY_TYPE_LIGHT,		"light" },
	{ WSDISPLAY_TYPE_INTELDRM,	"inteldrm" },
	{ WSDISPLAY_TYPE_RADEONDRM,	"radeondrm" },
	{ WSDISPLAY_TYPE_EFIFB,		"efifb" }
};

static const struct nameint kbdenc_tab[] = {
	KB_ENCTAB
};

static const struct nameint kbdvar_tab[] = {
	KB_VARTAB
};

char *int2name(int, int, const struct nameint *, int);
int name2int(char *, const struct nameint *, int);
void print_kmap(struct wskbd_map_data *);
void print_emul(struct wsdisplay_emultype *);
void print_screen(struct wsdisplay_screentype *);

struct field *
field_by_name(struct field *field_tab, char *name)
{
	const char *p = strchr(name, '.');

	if (!p++)
		errx(1, "%s: illegal variable name", name);

	for (; field_tab->name; field_tab++)
		if (strcmp(field_tab->name, p) == 0)
			return (field_tab);

	errx(1, "%s: not found", name);
}

struct field *
field_by_value(struct field *field_tab, void *addr)
{
	for (; field_tab->name; field_tab++)
		if (field_tab->valp == addr)
			return (field_tab);

	errx(1, "internal error: field_by_value: not found");
}

char *
int2name(int val, int uflag, const struct nameint *tab, int len)
{
	static char tmp[20];
	int i;

	for (i = 0; i < len; i++)
		if (tab[i].value == val)
			return(tab[i].name);

	if (uflag) {
		snprintf(tmp, sizeof(tmp), "unknown_%d", val);
		return(tmp);
	} else
		return(NULL);
}

int
name2int(char *val, const struct nameint *tab, int len)
{
	int i;

	for (i = 0; i < len; i++)
		if (strcmp(tab[i].name, val) == 0)
			return(tab[i].value);
	return(-1);
}

void
pr_field(const char *pre, struct field *f, const char *sep)
{
	struct field_pc *pc;
	u_int flags;
	int i, n;
	char *p;

	if (sep)
		printf("%s.%s%s", pre, f->name, sep);

	switch (f->format) {
	case FMT_UINT:
		printf("%u", *((u_int *) f->valp));
		break;
	case FMT_INT:
		printf("%d", *((int *) f->valp));
		break;
	case FMT_BOOL:
		printf("%s", *((u_int *) f->valp)? "on" : "off");
		break;
	case FMT_PC:
		pc = f->valp;
		i = pc->max - pc->min;
		n = pc->cur - pc->min;
		printf("%u.%02u%%", n * 100 / i, ((n * 100) % i) * 100 / i);
		break;
	case FMT_KBDTYPE:
		p = int2name(*((u_int *) f->valp), 1,
			     kbtype_tab, TABLEN(kbtype_tab));
		printf("%s", p);
		break;
	case FMT_MSTYPE:
		p = int2name(*((u_int *) f->valp), 1,
			     mstype_tab, TABLEN(mstype_tab));
		printf("%s", p);
		break;
	case FMT_DPYTYPE:
		p = int2name(*((u_int *) f->valp), 1,
			     dpytype_tab, TABLEN(dpytype_tab));
		printf("%s", p);
		break;
	case FMT_KBDENC:
		p = int2name(KB_ENCODING(*((u_int *) f->valp)), 1,
			     kbdenc_tab, TABLEN(kbdenc_tab));
		printf("%s", p);

		flags = KB_VARIANT(*((u_int *) f->valp));
		for (i = 0; i < 32; i++) {
			if (!(flags & (1 << i)))
				continue;
			p = int2name(flags & (1 << i), 1,
				     kbdvar_tab, TABLEN(kbdvar_tab));
			printf(".%s", p);
		}
		break;
	case FMT_KBMAP:
		print_kmap((struct wskbd_map_data *) f->valp);
		break;
	case FMT_SCALE:
		printf("%d,%d,%d,%d,%d,%d,%d", wmcoords.minx, wmcoords.maxx,
		    wmcoords.miny, wmcoords.maxy, wmcoords.swapxy,
		    wmcoords.resx, wmcoords.resy);
		break;
	case FMT_EMUL:
		print_emul((struct wsdisplay_emultype *) f->valp);
		break;
	case FMT_SCREEN:
		print_screen((struct wsdisplay_screentype *) f->valp);
		break;
	case FMT_STRING:
		printf("%s", (const char *)f->valp);
		break;
	case FMT_CFG:
		mousecfg_pr_field((struct wsmouse_parameters *) f->valp);
		break;
	default:
		errx(1, "internal error: pr_field: no format %d", f->format);
		break;
	}

	printf("\n");
}

void
rd_field(struct field *f, char *val, int merge)
{
	struct wscons_keymap *mp;
	struct field_pc *pc;
	u_int u, r, fr;
	char *p;
	int i;

	switch (f->format) {
	case FMT_UINT:
		if (sscanf(val, "%u", &u) != 1)
			errx(1, "%s: not a number", val);
		if (merge)
			*((u_int *) f->valp) += u;
		else
			*((u_int *) f->valp) = u;
		break;
	case FMT_INT:
		if (sscanf(val, "%d", &i) != 1)
			errx(1, "%s: not a number", val);
		if (merge)
			*((int *) f->valp) += i;
		else
			*((int *) f->valp) = i;
		break;
	case FMT_BOOL:
		if (*val != 'o' || (val[1] != 'n' &&
		    (val[1] != 'f' || val[2] != 'f')))
			errx(1, "%s: invalid value (on/off)", val);
		*((u_int *) f->valp) = val[1] == 'n'? 1 : 0;
		break;
	case FMT_PC:
		fr = 0;
		if ((i = sscanf(val, "%u.%u%%", &u, &fr)) != 2 && i != 1)
			errx(1, "%s: not a valid number", val);
		pc = f->valp;
		r = pc->max - pc->min;
		i = pc->min + (r * u) / 100 + (r * fr) / 100 / 100;
		if (merge == '+')
			pc->cur += i;
		else if (merge == '-')
			pc->cur -= i;
		else
			pc->cur = i;
		if (pc->cur > pc->max)
			pc->cur = pc->max;
		if (pc->cur < pc->min)
			pc->cur = pc->min;
		break;
	case FMT_KBDENC:
		p = strchr(val, '.');
		if (p != NULL)
			*p++ = '\0';

		i = name2int(val, kbdenc_tab, TABLEN(kbdenc_tab));
		if (i == -1)
			errx(1, "%s: not a valid encoding", val);
		*((u_int *) f->valp) = i;

		while (p) {
			val = p;
			p = strchr(p, '.');
			if (p != NULL)
				*p++ = '\0';
			i = name2int(val, kbdvar_tab, TABLEN(kbdvar_tab));
			if (i == -1)
				errx(1, "%s: not a valid variant", val);
			*((u_int *) f->valp) |= i;
		}
		break;
	case FMT_KBMAP:
		if (! merge)
			kbmap.maplen = 0;
		map_scan_setinput(val);
		yyparse();
		if (merge) {
			if (newkbmap.maplen < kbmap.maplen)
				newkbmap.maplen = kbmap.maplen;
			for (i = 0; i < kbmap.maplen; i++) {
				mp = newkbmap.map + i;
				if (mp->command == KS_voidSymbol &&
				    mp->group1[0] == KS_voidSymbol &&
				    mp->group1[1] == KS_voidSymbol &&
				    mp->group2[0] == KS_voidSymbol &&
				    mp->group2[1] == KS_voidSymbol)
					*mp = kbmap.map[i];
			}
		}
		kbmap.maplen = newkbmap.maplen;
		bcopy(newkbmap.map, kbmap.map,
		      kbmap.maplen*sizeof(struct wscons_keymap));
		break;
	case FMT_SCALE:
	{
		const char *errstr = 0;

		/* Unspecified values default to 0. */
		bzero(&wmcoords, sizeof(wmcoords));
		val = (void *)strtok(val, ",");
		if (val != NULL) {
			wmcoords.minx = (int)strtonum(val,
			    -32768, 32767, &errstr);
			val = (void *)strtok(NULL, ",");
		}
		if (!errstr && val != NULL) {
			wmcoords.maxx = (int)strtonum(val,
			    -32768, 32767, &errstr);
			val = (void *)strtok(NULL, ",");
		}
		if (!errstr && val != NULL) {
			wmcoords.miny = (int)strtonum(val,
			    -32768, 32767, &errstr);
			val = (void *)strtok(NULL, ",");
		}
		if (!errstr && val != NULL) {
			wmcoords.maxy = (int)strtonum(val,
			    -32768, 32767, &errstr);
			val = (void *)strtok(NULL, ",");
		}
		if (!errstr && val != NULL) {
			wmcoords.swapxy = (int)strtonum(val,
			    -32768, 32767, &errstr);
			val = (void *)strtok(NULL, ",");
		}
		if (!errstr && val != NULL) {
			wmcoords.resx = (int)strtonum(val,
			    0, 32767, &errstr);
			val = (void *)strtok(NULL, ",");
		}
		if (!errstr && val != NULL) {
			wmcoords.resy = (int)strtonum(val,
			    0, 32767, &errstr);
			val = (void *)strtok(NULL, ",");
		}
		if (errstr)
			errx(1, "calibration value is %s", errstr);
		if (val != NULL)
			errx(1, "too many calibration values");

		break;
	}
	case FMT_STRING:
		strlcpy(f->valp, val, WSFONT_NAME_SIZE);
		break;
	case FMT_CFG:
		mousecfg_rd_field((struct wsmouse_parameters *) f->valp, val);
		break;
	default:
		errx(1, "internal error: rd_field: no format %d", f->format);
		break;
	}
}

void
print_kmap(struct wskbd_map_data *map)
{
	struct wscons_keymap *mp;
	int i;

	for (i = 0; i < map->maplen; i++) {
		mp = map->map + i;

		if (mp->command == KS_voidSymbol &&
		    mp->group1[0] == KS_voidSymbol &&
		    mp->group1[1] == KS_voidSymbol &&
		    mp->group2[0] == KS_voidSymbol &&
		    mp->group2[1] == KS_voidSymbol)
			continue;
		printf("\n");
		printf("keycode %u =", i);
		if (mp->command != KS_voidSymbol)
			printf(" %s", ksym2name(mp->command));
		printf(" %s", ksym2name(mp->group1[0]));
		if (mp->group1[0] != mp->group1[1] ||
		    mp->group1[0] != mp->group2[0] ||
		    mp->group1[0] != mp->group2[1]) {
			printf(" %s", ksym2name(mp->group1[1]));
			if (mp->group1[0] != mp->group2[0] ||
			    mp->group1[1] != mp->group2[1]) {
				printf(" %s", ksym2name(mp->group2[0]));
				printf(" %s", ksym2name(mp->group2[1]));
			}
		}
	}
	ksymenc(0);
}

void
print_emul(struct wsdisplay_emultype *emuls)
{
	struct wsdisplay_emultype e;
	int fd,i;
	char c='\0';

	fd=emuls->idx;
	e.idx=0;
	i = ioctl(fd, WSDISPLAYIO_GETEMULTYPE, &e);
	while(i == 0) {
		if (c != '\0')
			printf("%c", c);
		printf("%s", e.name);
		c=',';
		e.idx++;
		i = ioctl(fd, WSDISPLAYIO_GETEMULTYPE, &e);
	}
}

void
print_screen(struct wsdisplay_screentype *screens)
{
	struct wsdisplay_screentype s;
	int fd,i;
	char c='\0';

	fd=screens->idx;
	s.idx=0;
	i = ioctl(fd, WSDISPLAYIO_GETSCREENTYPE, &s);
	while(i == 0) {
		if (c != '\0')
			printf("%c", c);
		printf("%s", s.name);
		c=',';
		s.idx++;
		i = ioctl(fd, WSDISPLAYIO_GETSCREENTYPE, &s);
	}
}
@


1.64
log
@Add fields for wsmouse/touchpad configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.63 2016/02/10 05:49:50 guenther Exp $ */
d170 2
a171 1
	{ WSDISPLAY_TYPE_RADEONDRM,	"radeondrm" }
@


1.63
log
@Permit negative x and y coordinates in mouse.scale for uts and ums.
Needed by some touchscreens.

no objection matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.62 2013/11/17 13:41:26 kettenis Exp $ */
d43 1
d313 3
d468 3
@


1.62
log
@Distinguish between inteldrm and radeondrm.

ok jsg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.61 2013/10/20 22:07:57 miod Exp $ */
d422 1
a422 1
			    0, 32768, &errstr);
d427 1
a427 1
			    0, 32768, &errstr);
d432 1
a432 1
			    0, 32768, &errstr);
d437 1
a437 1
			    0, 32768, &errstr);
d442 1
a442 1
			    0, 32768, &errstr);
d447 1
a447 1
			    0, 32768, &errstr);
d452 1
a452 1
			    0, 32768, &errstr);
@


1.61
log
@Introduce write-only (for now) display.font parameter, which issues a
WSDISPLAYIO_USEFONT ioctl, asking the wsdisplay driver to change its
current display font to the one requested (by name).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.60 2013/10/20 10:43:47 miod Exp $ */
d168 2
a169 1
	{ WSDISPLAY_TYPE_KMS,		"kms" }
@


1.60
log
@WSDISPLAYIO_GTYPE ioctl support for KMS drivers. ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.59 2012/10/29 11:56:19 stsp Exp $ */
d308 3
d461 3
@


1.59
log
@Teach wsconsctl(8) about the elantech mouse type. Diff from shadchin@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.58 2012/07/14 08:25:12 shadchin Exp $ */
d167 2
a168 1
	{ WSDISPLAY_TYPE_LIGHT,		"light" }
@


1.58
log
@zap whitespace

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.57 2012/04/17 14:53:47 deraadt Exp $ */
d94 2
a95 1
	{ WSMOUSE_TYPE_SGI,	"sgi" }
@


1.57
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.56 2012/04/17 08:51:24 miod Exp $ */
d48 1
a48 1
extern struct wsmouse_calibcoords wmcoords; 	/* from mouse.c */
@


1.56
log
@Add type numbers for upcoming sgi work, forgotten during newport(4) import.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.55 2011/09/20 17:00:24 shadchin Exp $ */
d93 1
a93 1
	{ WSMOUSE_TYPE_ALPS,	"alps" }
@


1.55
log
@Prepare to add support ALPS touchpads

no objections mpi@@ and matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.54 2011/09/15 04:59:16 shadchin Exp $ */
d74 1
d94 1
d163 4
a166 1
	{ WSDISPLAY_TYPE_IMPACT,	"impact" }
@


1.54
log
@Fix recognition Synaptics touchpad
from Patrick Keshishian (sidster at boxsoft dot com)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.53 2010/07/02 15:47:58 chl Exp $ */
d91 2
a92 1
	{ WSMOUSE_TYPE_SYNAPTICS, "synaptics"}
@


1.53
log
@add missing header needed by ioctl()

ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.52 2010/07/01 03:00:14 maja Exp $ */
d90 2
a91 1
	{ WSMOUSE_TYPE_SUN,	"sun" }
@


1.52
log
@Remove two useless nul characters. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.51 2010/07/01 02:37:21 maja Exp $ */
d33 1
@


1.51
log
@add screen types and emulations to things to be shown for displays.
ok miod@@. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.50 2010/06/28 20:40:39 maja Exp $ */
d499 1
a499 1
		if (c != '0')
d519 1
a519 1
		if (c != '0')
@


1.50
log
@A long time ago when wsconsctl was written it expected that ksym was uniq.
That isn't the case. eg thorn, Cyrillic_CHE, L2_tcedilla, L5_scedilla and
L7_zcaron has the same (0xfe). So you have a 20% chance to get the right
output from wsconsctl.

Use the ksym name to decide which ksyms isn't Latin-1. Store that information
in the ksym tables. The use the keyboard encoding to make an educated guess
of which character to return.

Let say your encoding is pl. You have Latin-2 characters in the map.
Then check first for Latin-2 characters if none found try Latin-1.

ok miod@@

-moj
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.49 2010/03/07 21:26:24 miod Exp $ */
d172 2
d292 6
d486 40
@


1.49
log
@Minimalistic driver for the ImpactSR (Mardigras) video option found on older
Octane systems, as well as some Onyxes. With special permission to change a
systemwide .h file and add a manpage from deraadt@@
Magic numbers and operation sequencing borrowed from Linux; tested on
Octane + ESI.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.48 2010/03/04 14:31:12 jsing Exp $ */
d477 1
@


1.48
log
@Add wsdisplay type for SGI VPro (aka Odyssey)

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.47 2010/02/28 22:32:48 miod Exp $ */
d157 2
a158 1
	{ WSDISPLAY_TYPE_ODYSSEY,	"odyssey" }
@


1.47
log
@Minimal frame buffer driver for the SiS 315 found on Lemote Fuloong systems.
Currently unable to change video modes or provide any form of acceleration,
so you are stuck in a 640x400x8 mode, but at least people scared of serial
consoles will get a chance to use their Fuloongs now.

Tested by otto@@ (early developments) and jasper@@ (final version)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.46 2009/12/25 22:02:46 miod Exp $ */
d156 2
a157 1
	{ WSDISPLAY_TYPE_SISFB,		"sisfb" }
@


1.46
log
@A couple more device types.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.45 2009/07/03 17:37:02 kettenis Exp $ */
d155 2
a156 1
	{ WSDISPLAY_TYPE_SMFB,		"smfb" }
@


1.45
log
@Add a wsdisplay type for an upcoming driver for the Sun XVR-100 framebuffer.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.44 2009/06/03 21:30:11 kettenis Exp $ */
d70 3
a72 1
	{ WSKBD_TYPE_DOMAIN,	"domain" }
d88 1
d154 2
a155 1
	{ WSDISPLAY_TYPE_RADEONFB,	"radeon" }
@


1.44
log
@Define a wsdisplay type for gfxp(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.43 2009/06/02 18:38:06 kettenis Exp $ */
d150 2
a151 1
	{ WSDISPLAY_TYPE_GFXP,		"gfxp" }
@


1.43
log
@Define a proper wsdisplay type for machfb(4).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.42 2009/05/20 18:22:30 miod Exp $ */
d149 2
a150 1
	{ WSDISPLAY_TYPE_MACHFB,	"mach64" }
@


1.42
log
@Add code to attach sun mice on sparc and sparc64 as wsmouse devices. Since
not all Sun mice run at the canonical 1200 bps, hop between 1200, 4800 and
9600 bps by paying attention to breaks on the line.

Attachement and engine code written 7 years ago for OpenBSD/sparc, except for
sparc64 com(4) attachment. Speed hop idea borrowed from Opensolaris.

This allows sparc and sparc64 users to run X11 without needing a configuration
file anymore, as it was in the XFree86 3.x days. Multihead configurations
will still need a minimal configuration file, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.41 2009/05/09 20:34:25 mglocker Exp $ */
d148 2
a149 1
	{ WSDISPLAY_TYPE_DL,		"displaylink" }
@


1.41
log
@Need to add new display type to wsconsctl(8), too.

Noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.40 2009/03/12 19:10:22 kettenis Exp $ */
d85 2
a86 1
	{ WSMOUSE_TYPE_DOMAIN,	"domain" }
@


1.40
log
@Define a proper wsdisplay type for raptor(4).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.39 2008/12/29 22:25:15 miod Exp $ */
d146 2
a147 1
	{ WSDISPLAY_TYPE_RAPTOR,	"raptor" }
@


1.39
log
@Give ifb its own display type (be sure to make includes before rebuilding
wsconsctl)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.38 2008/08/24 20:10:55 miod Exp $ */
d145 2
a146 1
	{ WSDISPLAY_TYPE_IFB,		"ifb" }
@


1.38
log
@Define a proper wsdisplay type for legss(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.37 2008/06/26 05:42:06 ray Exp $ */
d144 2
a145 1
	{ WSDISPLAY_TYPE_LEGSS,		"dec-legss" }
@


1.37
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2007/11/27 16:56:46 miod Exp $ */
d143 2
a144 1
	{ WSDISPLAY_TYPE_GBE,		"gbe" }
@


1.36
log
@Add a few missing device entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.35 2007/05/08 20:51:58 robert Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.35
log
@Introduce the mouse.rawmode and mouse.scale fields for
touchscreen calibration via ioctls.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.34 2006/07/24 22:19:52 miod Exp $ */
d148 3
a150 1
	{ WSDISPLAY_TYPE_LCSPX,		"dec-lcspx" }
@


1.34
log
@Driver for the VS4000/90 frame buffer, adapted from NetBSD (ragge) and
Blaz Antonic's work, no acceleration yet, untested due to the lack of
hardware, but enough sacrifices were made to the RAMDAC Gods.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.33 2006/04/14 21:05:43 miod Exp $ */
d44 1
d54 1
d275 5
d381 49
@


1.33
log
@Minimal support for the HP98705 ``Tigershark'' TurboVRX frame buffer
(using an overlay plane only for now). Bootblocks, text console and X11
are supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2006/02/14 18:52:15 miod Exp $ */
d145 2
a146 1
	{ WSDISPLAY_TYPE_TVRX,		"tvrx" }
@


1.32
log
@Define a wsdisplay type for the Sun ZX/Leo frame buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.31 2006/01/09 21:52:09 miod Exp $ */
d144 2
a145 1
	{ WSDISPLAY_TYPE_SUNLEO,	"sunleo" }
@


1.31
log
@Introduce a wsdisplay type for mac68k frame buffers; we might need to become
less generic in the future, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.30 2005/05/31 15:33:57 brad Exp $ */
d143 2
a144 1
	{ WSDISPLAY_TYPE_MAC68K,	"mac68k" }
@


1.30
log
@fix a typo, touch-pannel -> touch-panel

From: Chris Kuethe via PR 4232
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2005/04/22 11:59:10 miod Exp $ */
d107 3
a109 3
	{ WSDISPLAY_TYPE_PX,		"dex-px" },
	{ WSDISPLAY_TYPE_PXG,		"dex-pxg" },
	{ WSDISPLAY_TYPE_TX,		"dex-tx" },
d142 2
a143 1
	{ WSDISPLAY_TYPE_PXALCD,	"pxalcd" }
@


1.29
log
@Driver for the Apollo Domain keyboard and mouse, for the HP 9000/4xx series.

Claims the console keyboard if a keyboard is detected at boot time,
otherwise HIL is preferred (but due to wsmux both can be used simultaneously).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2005/01/17 04:21:05 drahn Exp $ */
d84 1
a84 1
	{ WSMOUSE_TYPE_TPANEL,	"touch-pannel" },
@


1.28
log
@PXALCD type.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2005/01/14 22:39:17 miod Exp $ */
d74 2
a75 1
	{ WSKBD_TYPE_ZAURUS,	"zaurus" }
d89 2
a90 1
	{ WSMOUSE_TYPE_LUNA,	"luna" }
@


1.27
log
@Switch OpenBSD/hp300 to wscons, still using on-board ROM fonts for now.

Main features:
- MI hil drivers, allowing live plug/unplug of devices, and the keyboard
  does not need to be at id 1 anymore.
- SGC bus support on 4xx models. SGC frame buffers are supported too, but
  not as console, though you can use them as a regular glass terminal if
  you run a getty on ttyC0. Currently not compiled-in, awaiting for an sti(4)
  fix to be commited.
- HP-UX compatibility interfaces are removed. grfinfo and hilinfo are removed.

X11 support is currently broken by these changes; X.org X11R6 support will
be available very soon.

Tested on hyperion and 4 different flavours of catseye/topcat/kathmandu; other,
older frame buffers (davinci, gatorbox and renaissance) could not been tested
but should work; please report any regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2005/01/14 15:49:03 drahn Exp $ */
d139 2
a140 1
	{ WSDISPLAY_TYPE_TOPCAT,	"topcat" }
@


1.26
log
@zaurus entry, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2004/03/04 01:09:23 mickey Exp $ */
d134 6
a139 1
	{ WSDISPLAY_TYPE_LUNA,		"luna" }
@


1.25
log
@Define wscons device ids for the Luna devices.
@
text
@d73 2
a74 1
	{ WSKBD_TYPE_LUNA,	"luna" }
@


1.24
log
@one missed kbd type
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2004/03/01 07:52:57 miod Exp $ */
d72 2
a73 1
	{ WSKBD_TYPE_GSC,	"hp-ps2" }
d86 2
a87 1
	{ WSMOUSE_TYPE_HIL,	"hil" }
d132 2
a133 1
	{ WSDISPLAY_TYPE_RFLEX,		"rasterflex" }
@


1.23
log
@Define a wsdisplay type for rfx; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2003/06/17 21:21:26 miod Exp $ */
d71 2
a72 1
	{ WSKBD_TYPE_HIL,	"hil" }
@


1.22
log
@New driver and wsdisplay type for the Weitek Power9000 and Brooktree Bt445
combination, found on the Tadpole SPARCbook 3 only (later model use the
Power9100 and are already supported).

Untested for lack of hardware and volunteers, but carefully crafted; if it
does not work out of the box, this should be a good starting point.

"worth having in the tree" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2003/05/14 06:39:47 miod Exp $ */
d129 1
@


1.21
log
@The ramdac's hater club is proud to present new yet another SBus frame
bufer driver, this time for the Southland Media Systems (now Quantum 3D)
MGX and MGXPlus cards.

Not complete, but a good start.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2003/03/28 02:59:31 jason Exp $ */
d128 1
@


1.20
log
@add a whole bunch of display types (will be used by the accelerated X
stuff coming soon to a tree near you).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2003/02/12 01:44:09 miod Exp $ */
d127 1
@


1.19
log
@Define a wsmouse type for HIL mice.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2003/02/11 19:49:45 miod Exp $ */
d115 12
a126 1
	{ WSDISPLAY_TYPE_STI,		"hp-sti" }
@


1.18
log
@Define an HIL wscons keyboard type.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2003/02/05 19:25:54 mickey Exp $ */
d71 1
a71 1
	{ WSKBD_TYPE_HIL,	"hil" },
d83 2
a84 1
	{ WSMOUSE_TYPE_ADB,	"adb" }
@


1.17
log
@grok sti type wsdisplay
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2002/12/17 07:10:25 mickey Exp $ */
d71 1
@


1.16
log
@display.focus is a signed int, make it so; this fixes a problem under x11, which is now a correct -1
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2002/12/11 18:27:19 deraadt Exp $ */
d112 2
a113 1
	{ WSDISPLAY_TYPE_SUNBW,		"sunbw" }
@


1.15
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2002/11/08 22:04:53 mickey Exp $ */
d195 3
d264 8
@


1.14
log
@a missing next kbd type
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2002/07/25 19:01:15 miod Exp $ */
d128 1
a128 3
field_by_name(field_tab, name)
	struct field *field_tab;
	char *name;
d143 1
a143 3
field_by_value(field_tab, addr)
	struct field *field_tab;
	void *addr;
d153 1
a153 3
int2name(val, uflag, tab, len)
	int val, uflag, len;
	const struct nameint *tab;
d170 1
a170 4
name2int(val, tab, len)
	char *val;
	const struct nameint *tab;
	int len;
d181 1
a181 4
pr_field(pre, f, sep)
	const char *pre;
	struct field *f;
	const char *sep;
d185 1
a186 1
	int i, n;
d245 1
a245 4
rd_field(f, val, merge)
	struct field *f;
	char *val;
	int merge;
d247 1
a248 1
	int i;
d251 1
a251 1
	struct wscons_keymap *mp;
d336 1
a336 2
print_kmap(map)
	struct wskbd_map_data *map;
d338 1
a339 1
	struct wscons_keymap *mp;
@


1.13
log
@Rename the WSDISPLAY_TYPE_SUNFFB display type into a more generic name,
..._SUN24, since this only means 24 bit framebuffers with BGR encoding.
Also add a WSDISPLAY_TYPE_SUNBW for Sun monochrome framebuffers, to be used
by Xwsfb shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2002/06/07 20:56:38 drahn Exp $ */
d65 1
@


1.12
log
@Add wsconsctl recognition support for adb keyboard.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2002/05/30 15:18:58 jason Exp $ */
d110 2
a111 1
	{ WSDISPLAY_TYPE_SUNFFB,	"sunffb" }
@


1.11
log
@add WSKBD_TYPE_SUN5 here, too
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2002/05/22 21:34:02 jason Exp $ */
d80 2
a81 1
	{ WSMOUSE_TYPE_ARCHIMEDES, "archimedes" }
@


1.10
log
@add sunffb type
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 2002/05/22 20:36:06 mickey Exp $ */
d69 1
@


1.9
log
@implement new type: %%, given min,cur,max print the value in %%.
also accepts -= and += to adjust the value.
implement new flags: INIT, DEAD.
init means to prefetch the variable before setting, where
dead means to assume the variable is not implemented
(enottty was observed, most likely), set by the low-level
routines (upon observing the ioctl results).
add the variables for screen brightness,contrast,backlight --
all are precent-type, also rework the display.c to be easier
on the eyes. requested, commented and helped upon by miod@@ and drahn@@.
there was a discussion on wheather truncate or round
(the thin and think ends of the same egg) where
decided to allow it to truncate until demanded
otherwise by the eager masses.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 2002/02/23 05:44:20 jason Exp $ */
d107 2
a108 1
	{ WSDISPLAY_TYPE_DCPVR,		"powervr" }
@


1.8
log
@add sun keyboard type
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 2002/02/16 21:27:38 millert Exp $ */
d130 1
a130 1
		errx(1, "%s: illigale variable name", name);
d190 2
d193 1
a193 2
	u_int flags;
	int i;
d205 6
d257 1
d259 1
a259 1
	u_int u;
d277 18
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2001/07/06 21:52:34 mickey Exp $ */
d68 1
@


1.6
log
@cleanup, sync w/ kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 2001/06/30 02:12:57 mickey Exp $ */
d117 3
a119 3
char *int2name __P((int, int, const struct nameint *, int));
int name2int __P((char *, const struct nameint *, int));
void print_kmap __P((struct wskbd_map_data *));
@


1.5
log
@make it more sysctl-like, ommit -kmd switches.
no backwards compatibility keeped.
add ability to change screens from cmd line.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 2001/05/08 22:31:09 mickey Exp $ */
d59 1
a59 1
static struct nameint kbtype_tab[] = {
d70 1
a70 1
static struct nameint mstype_tab[] = {
d74 2
d77 2
d81 1
a81 1
static struct nameint dpytype_tab[] = {
d99 8
d109 1
a109 1
static struct nameint kbdenc_tab[] = {
d113 1
a113 1
static struct nameint kbdvar_tab[] = {
d117 3
a119 3
static char *int2name __P((int, int, struct nameint *, int));
static int name2int __P((char *, struct nameint *, int));
static void print_kmap __P((struct wskbd_map_data *));
d150 1
a150 1
static char *
d152 2
a153 4
	int val;
	int uflag;
	struct nameint *tab;
	int len;
d169 1
a169 1
static int
d172 1
a172 1
	struct nameint *tab;
d318 1
a318 1
static void
@


1.4
log
@add more display variables (for screen burner).
implement boolean type for variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 2001/03/03 08:53:46 maja Exp $ */
a104 3
static struct field *field_tab;
static int field_tab_len;

a108 9
void
field_setup(ftab, len)
	struct field *ftab;
	int len;
{
	field_tab = ftab;
	field_tab_len = len;
}

d110 2
a111 1
field_by_name(name)
d114 4
a117 1
	int i;
d119 3
a121 3
	for (i = 0; i < field_tab_len; i++)
		if (strcmp(field_tab[i].name, name) == 0)
			return(field_tab + i);
d127 2
a128 1
field_by_value(addr)
d131 3
a133 5
	int i;

	for (i = 0; i < field_tab_len; i++)
		if (field_tab[i].valp == addr)
			return(field_tab + i);
d174 2
a175 1
pr_field(f, sep)
d177 1
a177 1
	char *sep;
d184 1
a184 1
		printf("%s%s", f->name, sep);
@


1.3
log
@complete wscons support for abd keyboard. -moj ok @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 2001/01/28 22:45:20 niklas Exp $ */
d198 3
d260 6
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 2000/03/14 08:11:53 sato Exp $ */
d67 1
@


1.1
log
@wscons control tool; initial import from newtbsd tree
@
text
@d1 1
@

