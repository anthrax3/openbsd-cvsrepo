head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.14
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.12
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.10
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.8
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.05.08.19.12.51;	author miod;	state Exp;
branches;
next	1.19;
commitid	f9koLQKgnj7EYOLZ;

1.19
date	2013.10.20.22.07.57;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2013.08.18.16.32.23;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2012.08.08.16.44.07;	author shadchin;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.20.00.20.55;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.01.16.47.58;	author maja;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.01.02.37.21;	author maja;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.27.06.27.03;	author maja;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.15.20.32.28;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.26.05.42.06;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.19.19.34.40;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.10.00.00.58;	author david;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.17.07.10.25;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.11.18.27.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.22.20.36.06;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.17.45.59;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.06.04.11.26;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.30.02.12.57;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.08.22.31.09;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.01.23.52.45;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Add a new `don't read back' flag for variables, to prevent reading their value
after modifying them. Give this flag to `display.focus', since screen
switching is asynchronous, and reading back will return the screen we are
switching from if the switch has not completed yet.

Also, disallow -= and += syntax for display.focus, as it doesn't make any sense.
@
text
@/*	$OpenBSD: display.c,v 1.19 2013/10/20 22:07:57 miod Exp $	*/
/*	$NetBSD: display.c,v 1.1 1998/12/28 14:01:16 hannken Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Juergen Hannken-Illjes.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/ioctl.h>
#include <sys/time.h>
#include <dev/wscons/wsconsio.h>
#include <errno.h>
#include <fcntl.h>
#include <err.h>
#include <stdio.h>
#include <string.h>
#include "wsconsctl.h"

u_int dpytype;
u_int width, height, depth;
int focus;
struct field_pc brightness, contrast, backlight;
int burnon, burnoff, vblank, kbdact, msact, outact;
char fontname[WSFONT_NAME_SIZE];
struct wsdisplay_emultype emuls;
struct wsdisplay_screentype screens;

struct field display_field_tab[] = {
    { "type",		&dpytype,	FMT_DPYTYPE,	FLG_RDONLY },
    { "width",		&width,		FMT_UINT,	FLG_RDONLY },
    { "height",		&height,	FMT_UINT,	FLG_RDONLY },
    { "depth",		&depth,		FMT_UINT,	FLG_RDONLY },
    { "emulations",	&emuls,		FMT_EMUL,	FLG_RDONLY },
    { "screentypes",	&screens,	FMT_SCREEN,	FLG_RDONLY },
    { "focus",		&focus,		FMT_INT,	FLG_NORDBACK },
    { "brightness",	&brightness,	FMT_PC,		FLG_MODIFY|FLG_INIT },
    { "contrast",	&contrast,	FMT_PC,		FLG_MODIFY|FLG_INIT },
    { "backlight",	&backlight,	FMT_PC,		FLG_MODIFY|FLG_INIT },
    /* screen burner section, outact MUST BE THE LAST, see the set_values */
    { "screen_on",	&burnon,	FMT_UINT,	FLG_MODIFY|FLG_INIT },
    { "screen_off",	&burnoff,	FMT_UINT,	FLG_MODIFY|FLG_INIT },
    { "vblank",		&vblank,	FMT_BOOL,	FLG_MODIFY|FLG_INIT },
    { "kbdact",		&kbdact,	FMT_BOOL,	FLG_MODIFY|FLG_INIT },
    { "msact",		&msact,		FMT_BOOL,	FLG_MODIFY|FLG_INIT },
    { "outact",		&outact,	FMT_BOOL,	FLG_MODIFY|FLG_INIT },
    { "font",		fontname,	FMT_STRING,	FLG_WRONLY },
    { NULL }
};

#define	fillioctl(n)	{ cmd = n; cmd_str = #n; }

void
display_get_values(int fd)
{
	struct wsdisplay_addscreendata gscr;
	struct wsdisplay_param param;
	struct wsdisplay_burner burners;
	struct wsdisplay_fbinfo fbinfo;
	struct field *pf;
	const char *cmd_str;
	void *ptr;
	unsigned long cmd;
	int bon = 0, fbon = 0;

	focus = gscr.idx = -1;
	for (pf = display_field_tab; pf->name; pf++) {

		if (!(pf->flags & FLG_GET) || pf->flags & FLG_DEAD)
			continue;

		ptr = pf->valp;

		if (ptr == &dpytype) {
			fillioctl(WSDISPLAYIO_GTYPE);
		} else if (ptr == &focus) {
			fillioctl(WSDISPLAYIO_GETSCREEN);
			ptr = &gscr;
		} else if (ptr == &emuls) {
			fillioctl(WSDISPLAYIO_GETEMULTYPE);
			emuls.idx=0;
		} else if (ptr == &screens) {
			fillioctl(WSDISPLAYIO_GETSCREENTYPE);
			screens.idx=0;
		} else if (ptr == &brightness) {
			ptr = &param;
			param.param = WSDISPLAYIO_PARAM_BRIGHTNESS;
		} else if (ptr == &contrast) {
			ptr = &param;
			param.param = WSDISPLAYIO_PARAM_CONTRAST;
		} else if (ptr == &backlight) {
			ptr = &param;
			param.param = WSDISPLAYIO_PARAM_BACKLIGHT;
		} else if (ptr == &burnon || ptr == &burnoff ||
			   ptr == &vblank || ptr == &kbdact ||
			   ptr == &outact || ptr == &msact) {
			fillioctl(WSDISPLAYIO_GBURNER);
			ptr = &burners;
			if (!bon)
				bzero(&burners, sizeof(burners));
		} else if (ptr == &height || ptr == &width ||
			   ptr == &depth) {
			fillioctl(WSDISPLAYIO_GINFO);
			ptr = &fbinfo;
			if (!fbon)
				bzero(&fbinfo, sizeof(fbinfo));
		} else
			cmd = 0;

		if (ptr == &param) {
			fillioctl(WSDISPLAYIO_GETPARAM);
		}

		if ((cmd != WSDISPLAYIO_GBURNER && cmd != WSDISPLAYIO_GINFO) ||
		    (cmd == WSDISPLAYIO_GBURNER && !bon) ||
		    (cmd == WSDISPLAYIO_GINFO && !fbon)) {
			errno = ENOTTY;
			if (!cmd || ioctl(fd, cmd, ptr) < 0) {
				if (errno == ENOTTY) {
					pf->flags |= FLG_DEAD;
					continue;
				} else
					warn("%s", cmd_str);
			}
		}

		if (ptr == &burners) {
			if (!bon) {
				burnon = burners.on;
				burnoff = burners.off;
				vblank = burners.flags & WSDISPLAY_BURN_VBLANK;
				kbdact = burners.flags & WSDISPLAY_BURN_KBD;
				msact = burners.flags & WSDISPLAY_BURN_MOUSE;
				outact = burners.flags & WSDISPLAY_BURN_OUTPUT;
			}
			bon++;
		} else if (ptr == &fbinfo) {
			if (!fbon) {
				width = fbinfo.width;
				height = fbinfo.height;
				depth = fbinfo.depth;
			}
			fbon++;
		} else if (ptr == &emuls) {
			emuls.idx=fd;
		} else if (ptr == &screens) {
			screens.idx=fd;
		} else if (ptr == &param) {
			struct field_pc *pc = pf->valp;

			pc->min = param.min;
			pc->cur = param.curval;
			pc->max = param.max;
		} else if (ptr == &gscr)
			focus = gscr.idx;
	}
}

int
display_put_values(int fd)
{
	struct wsdisplay_param param;
	struct wsdisplay_burner burners;
	struct wsdisplay_font font;
	struct field *pf;
	const char *cmd_str;
	void *ptr;
	unsigned long cmd;
	int id;

	for (pf = display_field_tab; pf->name; pf++) {

		if (!(pf->flags & FLG_SET) || pf->flags & FLG_DEAD)
			continue;

		ptr = pf->valp;

		if (ptr == &focus) {
			fillioctl(WSDISPLAYIO_SETSCREEN);
		} else if (ptr == &brightness) {
			ptr = &param;
			id = WSDISPLAYIO_PARAM_BRIGHTNESS;
		} else if (ptr == &contrast) {
			ptr = &param;
			id = WSDISPLAYIO_PARAM_CONTRAST;
		} else if (ptr == &backlight) {
			ptr = &param;
			id = WSDISPLAYIO_PARAM_BACKLIGHT;
		} else if (ptr == &burnon || ptr == &burnoff ||
			   ptr == &vblank || ptr == &kbdact ||
			   ptr == &outact || ptr == &msact) {

			bzero(&burners, sizeof(burners));
			burners.on = burnon;
			burners.off = burnoff;
			if (vblank)
				burners.flags |= WSDISPLAY_BURN_VBLANK;
			else
				burners.flags &= ~WSDISPLAY_BURN_VBLANK;
			if (kbdact)
				burners.flags |= WSDISPLAY_BURN_KBD;
			else
				burners.flags &= ~WSDISPLAY_BURN_KBD;
			if (msact)
				burners.flags |= WSDISPLAY_BURN_MOUSE;
			else
				burners.flags &= ~WSDISPLAY_BURN_MOUSE;
			if (outact)
				burners.flags |= WSDISPLAY_BURN_OUTPUT;
			else
				burners.flags &= ~WSDISPLAY_BURN_OUTPUT;

			fillioctl(WSDISPLAYIO_SBURNER);
			ptr = &burners;
		} else if (ptr == fontname) {
			bzero(&font, sizeof(font));
			strlcpy(font.name, ptr, sizeof font.name);
			fillioctl(WSDISPLAYIO_USEFONT);
		} else
			cmd = 0;

		if (ptr == &param) {
			struct field_pc *pc = pf->valp;

			bzero(&param, sizeof(param));
			param.param = id;
			param.min = pc->min;
			param.curval = pc->cur;
			param.max = pc->max;
			fillioctl(WSDISPLAYIO_SETPARAM);
		}

		errno = ENOTTY;
		if (!cmd || ioctl(fd, cmd, ptr) < 0) {
			if (errno == ENOTTY) {
				pf->flags |= FLG_DEAD;
				continue;
			} else {
				warn("%s", cmd_str);
				return 1;
			}
		}
	}

	return 0;
}

char *
display_next_device(int index)
{
	static char devname[20];

	if (index > 7)
		return (NULL);

	snprintf(devname, sizeof(devname), "/dev/tty%c0", index + 'C');
	return (devname);
}
@


1.19
log
@Introduce write-only (for now) display.font parameter, which issues a
WSDISPLAYIO_USEFONT ioctl, asking the wsdisplay driver to change its
current display font to the one requested (by name).
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.18 2013/08/18 16:32:23 guenther Exp $	*/
d59 1
a59 1
    { "focus",		&focus,		FMT_INT,	FLG_MODIFY },
@


1.18
log
@Fix calls to printf-like functions which passed a non-fixed string
as the format and no variable args.
Replace "%#0.*X" with "%#.*X": the zero-fill flag is ignored/implied
on numeric conversions when a precision is specified.

ok jung@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.17 2012/08/08 16:44:07 shadchin Exp $	*/
d48 1
d70 1
d187 1
d238 4
@


1.17
log
@fix type (part from NetBSD)

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.16 2010/08/20 00:20:55 fgsch Exp $	*/
d144 1
a144 1
					warn(cmd_str);
d255 1
a255 1
				warn(cmd_str);
@


1.16
log
@Don't silently ignore errors if we cannot open the device. While I'm here
simplify the code and apply some style(9).
Discussed with and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.15 2010/07/01 16:47:58 maja Exp $	*/
d43 1
a43 1
int dpytype;
@


1.15
log
@Learn wsconsctl to handle more than the first keyboard, mouse and display.
E.g. if we have a /dev/wskbd1 keyboard1 will show up when doing a -a.

wsconsctl keyboard1 will now show you all variables for keyboard1.

feedback and ok miod@@. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.14 2010/07/01 02:37:21 maja Exp $	*/
d75 1
a75 1
display_get_values(const char *pre, int fd)
d181 1
a181 1
display_put_values(const char *pre, int fd)
d264 2
a265 2
int
display_next_device(int *index)
d267 1
a267 4
	char devname[20];
	int fd = -1;

	snprintf(devname, sizeof(devname), "/dev/tty%c0", *index + 'C');
d269 2
a270 4
	if (*index > 7) {
		*index = -1;
		return(fd);
	}
d272 2
a273 6
	if ((fd = open(devname, O_WRONLY)) < 0 &&
	    (fd = open(devname, O_RDONLY)) < 0) {
		if (errno != ENXIO)
			*index = -1;
	}
	return(fd);
@


1.14
log
@add screen types and emulations to things to be shown for displays.
ok miod@@. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.13 2009/09/27 06:27:03 maja Exp $	*/
d37 1
d39 1
d262 21
@


1.13
log
@Show fbinfo if it exists. ok mglocker@@  -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.12 2009/07/15 20:32:28 martynas Exp $	*/
d46 2
d54 2
d98 6
d163 4
@


1.12
log
@for rw query and print value that has actually been set in the
similar way that mixerctl does.  so that info for setting things
like brightness makes sense (since we scale, like, 8 values to
per-cent).  also, it consistifies get/put, shrinks code since we
don't need to do that in every single 'driver'.  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.11 2008/06/26 05:42:06 ray Exp $	*/
d42 1
d49 3
d74 1
d79 1
a79 1
	int bon = 0;
d110 6
d123 3
a125 1
		if (!bon || cmd != WSDISPLAYIO_GBURNER) {
d146 7
@


1.11
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.10 2004/11/19 19:34:40 mickey Exp $	*/
d144 1
a144 1
void
d218 1
a218 1
			} else
d220 2
d223 1
d225 1
a225 2
		pr_field(pre, pf, " -> ");
	}
@


1.10
log
@repair display.focus pokus; from janjaap@@ in pr#3990
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.9 2003/07/10 00:00:58 david Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.9
log
@add missing includes
ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.8 2002/12/17 07:10:25 mickey Exp $	*/
d146 2
a147 1
		}
@


1.8
log
@display.focus is a signed int, make it so; this fixes a problem under x11, which is now a correct -1
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.7 2002/12/11 18:27:19 deraadt Exp $	*/
d45 1
@


1.7
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.6 2002/05/22 20:36:06 mickey Exp $	*/
d54 1
a54 1
    { "focus",		&focus,		FMT_UINT,	FLG_MODIFY },
@


1.6
log
@implement new type: %%, given min,cur,max print the value in %%.
also accepts -= and += to adjust the value.
implement new flags: INIT, DEAD.
init means to prefetch the variable before setting, where
dead means to assume the variable is not implemented
(enottty was observed, most likely), set by the low-level
routines (upon observing the ioctl results).
add the variables for screen brightness,contrast,backlight --
all are precent-type, also rework the display.c to be easier
on the eyes. requested, commented and helped upon by miod@@ and drahn@@.
there was a discussion on wheather truncate or round
(the thin and think ends of the same egg) where
decided to allow it to truncate until demanded
otherwise by the eager masses.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.5 2001/10/24 17:45:59 miod Exp $	*/
d71 1
a71 3
display_get_values(pre, fd)
	const char *pre;
	int fd;
d150 1
a150 3
display_put_values(pre, fd)
	const char *pre;
	int fd;
@


1.5
log
@- repair usage() output
- when changing display.foo settings, print "display.foo -> bar" like done
for mouse.* and keyboard.*
- use warn() over err() whenever possible and appropriate code path to display
as much as useful information as possible even if one ioctl fails. This is
especially useful to get the display.* settings via wsconsctl -a if your
mouse can't be probed, like on the iBook.

ok mcikye@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.4 2001/07/06 04:11:26 pvalchev Exp $	*/
d43 1
d49 1
d53 12
a64 8
    { "type",			&dpytype,	FMT_DPYTYPE,	FLG_RDONLY },
    { "focus",			&focus,		FMT_UINT,	FLG_MODIFY },
    { "screen_on",		&burnon,	FMT_UINT,	FLG_MODIFY },
    { "screen_off",		&burnoff,	FMT_UINT,	FLG_MODIFY },
    { "vblank",			&vblank,	FMT_BOOL,	FLG_MODIFY },
    { "kbdact",			&kbdact,	FMT_BOOL,	FLG_MODIFY },
    { "msact",			&msact,		FMT_BOOL,	FLG_MODIFY },
    { "outact",			&outact,	FMT_BOOL,	FLG_MODIFY },
d68 2
d76 13
d90 29
a118 3
	if (field_by_value(display_field_tab, &dpytype)->flags & FLG_GET)
		if (ioctl(fd, WSDISPLAYIO_GTYPE, &dpytype) < 0)
			warn("WSDISPLAYIO_GTYPE");
d120 10
a129 5
	focus = gscr.idx = -1;
	if (field_by_value(display_field_tab, &focus)->flags & FLG_GET) {
		if (ioctl(fd, WSDISPLAYIO_GETSCREEN, &gscr) < 0)
			warn("WSDISPLAYIO_GETSCREEN");
	}
d131 2
a132 13
	if (field_by_value(display_field_tab, &burnon)->flags & FLG_GET ||
	    field_by_value(display_field_tab, &burnoff)->flags & FLG_GET ||
	    field_by_value(display_field_tab, &vblank)->flags & FLG_GET ||
	    field_by_value(display_field_tab, &kbdact)->flags & FLG_GET ||
	    field_by_value(display_field_tab, &msact )->flags & FLG_GET ||
	    field_by_value(display_field_tab, &outact)->flags & FLG_GET) {

		struct wsdisplay_burner burners;

		if (ioctl(fd, WSDISPLAYIO_GBURNER, &burners) < 0)
			warn("WSDISPLAYIO_GBURNER");
		else {
			if (field_by_value(display_field_tab, &burnon)->flags & FLG_GET)
a133 2

			if (field_by_value(display_field_tab, &burnoff)->flags & FLG_GET)
a134 2

			if (field_by_value(display_field_tab, &vblank)->flags & FLG_GET)
a135 2

			if (field_by_value(display_field_tab, &kbdact)->flags & FLG_GET)
a136 2

			if (field_by_value(display_field_tab, &msact )->flags & FLG_GET)
a137 2

			if (field_by_value(display_field_tab, &outact)->flags & FLG_GET)
d139 8
d156 65
a220 28
	if (field_by_value(display_field_tab, &focus)->flags & FLG_SET)
		if (ioctl(fd, WSDISPLAYIO_SETSCREEN, &focus) < 0)
			warn("WSDISPLAYIO_SETSCREEN");

	if (field_by_value(display_field_tab, &burnon)->flags & FLG_SET ||
	    field_by_value(display_field_tab, &burnoff)->flags & FLG_SET ||
	    field_by_value(display_field_tab, &vblank)->flags & FLG_SET ||
	    field_by_value(display_field_tab, &kbdact)->flags & FLG_SET ||
	    field_by_value(display_field_tab, &msact )->flags & FLG_SET ||
	    field_by_value(display_field_tab, &outact)->flags & FLG_SET) {

		struct wsdisplay_burner burners;

		if (ioctl(fd, WSDISPLAYIO_GBURNER, &burners) < 0)
			warn("WSDISPLAYIO_GBURNER");
		else {
			if (field_by_value(display_field_tab, &burnon)->flags & FLG_SET)
				burners.on = burnon;

			if (field_by_value(display_field_tab, &burnoff)->flags & FLG_SET)
				burners.off = burnoff;

			if (field_by_value(display_field_tab, &vblank)->flags & FLG_SET) {
				if (vblank)
					burners.flags |= WSDISPLAY_BURN_VBLANK;
				else
					burners.flags &= ~WSDISPLAY_BURN_VBLANK;
			}
d222 8
a229 6
			if (field_by_value(display_field_tab, &kbdact)->flags & FLG_SET) {
				if (kbdact)
					burners.flags |= WSDISPLAY_BURN_KBD;
				else
					burners.flags &= ~WSDISPLAY_BURN_KBD;
			}
d231 1
a231 31
			if (field_by_value(display_field_tab, &msact )->flags & FLG_SET) {
				if (msact)
					burners.flags |= WSDISPLAY_BURN_MOUSE;
				else
					burners.flags &= ~WSDISPLAY_BURN_MOUSE;
			}

			if (field_by_value(display_field_tab, &outact)->flags & FLG_SET) {
				if (outact)
					burners.flags |= WSDISPLAY_BURN_OUTPUT;
				else
					burners.flags &= ~WSDISPLAY_BURN_OUTPUT;
			}

			if (ioctl(fd, WSDISPLAYIO_SBURNER, &burners) < 0)
				warn("WSDISPLAYIO_SBURNER");
			else {
				if (field_by_value(display_field_tab, &burnon)->flags & FLG_SET)
					pr_field(pre, field_by_value(display_field_tab, &burnon), " -> ");
				if (field_by_value(display_field_tab, &burnoff)->flags & FLG_SET)
					pr_field(pre, field_by_value(display_field_tab, &burnoff), " -> ");
				if (field_by_value(display_field_tab, &vblank)->flags & FLG_SET)
					pr_field(pre, field_by_value(display_field_tab, &vblank), " -> ");
				if (field_by_value(display_field_tab, &kbdact)->flags & FLG_SET)
					pr_field(pre, field_by_value(display_field_tab, &kbdact), " -> ");
				if (field_by_value(display_field_tab, &msact )->flags & FLG_SET)
					pr_field(pre, field_by_value(display_field_tab, &msact), " -> ");
				if (field_by_value(display_field_tab, &outact)->flags & FLG_SET)
					pr_field(pre, field_by_value(display_field_tab, &outact), " -> ");
			}
		}
@


1.4
log
@add if braces to avoid compiler warnings; ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.3 2001/06/30 02:12:57 mickey Exp $	*/
d71 1
a71 1
			err(1, "WSDISPLAYIO_GTYPE");
d73 1
a73 1
	gscr.idx = -1;
d76 1
a76 1
			err(1, "WSDISPLAYIO_GETSCREEN");
a77 2
	else
		focus = gscr.idx;
d89 4
a92 1
			err(1, "WSDISPLAYIO_GBURNER");
d94 2
a95 2
		if (field_by_value(display_field_tab, &burnon)->flags & FLG_GET)
			burnon = burners.on;
d97 2
a98 2
		if (field_by_value(display_field_tab, &burnoff)->flags & FLG_GET)
			burnoff = burners.off;
d100 2
a101 2
		if (field_by_value(display_field_tab, &vblank)->flags & FLG_GET)
			vblank = burners.flags & WSDISPLAY_BURN_VBLANK;
d103 2
a104 2
		if (field_by_value(display_field_tab, &kbdact)->flags & FLG_GET)
			kbdact = burners.flags & WSDISPLAY_BURN_KBD;
d106 3
a108 5
		if (field_by_value(display_field_tab, &msact )->flags & FLG_GET)
			msact = burners.flags & WSDISPLAY_BURN_MOUSE;

		if (field_by_value(display_field_tab, &outact)->flags & FLG_GET)
			outact = burners.flags & WSDISPLAY_BURN_OUTPUT;
d119 1
a119 1
			err(1, "WSDISPLAYIO_SETSCREEN");
d131 52
a182 27
			err(1, "WSDISPLAYIO_GBURNER");

		if (field_by_value(display_field_tab, &burnon)->flags & FLG_SET)
			burners.on = burnon;

		if (field_by_value(display_field_tab, &burnoff)->flags & FLG_SET)
			burners.off = burnoff;

		if (field_by_value(display_field_tab, &vblank)->flags & FLG_SET) {
			if (vblank)
				burners.flags |= WSDISPLAY_BURN_VBLANK;
			else
				burners.flags &= ~WSDISPLAY_BURN_VBLANK;
		}

		if (field_by_value(display_field_tab, &kbdact)->flags & FLG_SET) {
			if (kbdact)
				burners.flags |= WSDISPLAY_BURN_KBD;
			else
				burners.flags &= ~WSDISPLAY_BURN_KBD;
		}

		if (field_by_value(display_field_tab, &msact )->flags & FLG_SET) {
			if (msact)
				burners.flags |= WSDISPLAY_BURN_MOUSE;
			else
				burners.flags &= ~WSDISPLAY_BURN_MOUSE;
a183 10

		if (field_by_value(display_field_tab, &outact)->flags & FLG_SET) {
			if (outact)
				burners.flags |= WSDISPLAY_BURN_OUTPUT;
			else
				burners.flags &= ~WSDISPLAY_BURN_OUTPUT;
		}

		if (ioctl(fd, WSDISPLAYIO_SBURNER, &burners) < 0)
			err(1, "WSDISPLAYIO_SBURNER");
@


1.3
log
@make it more sysctl-like, ommit -kmd switches.
no backwards compatibility keeped.
add ability to change screens from cmd line.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.2 2001/05/08 22:31:09 mickey Exp $	*/
d74 1
a74 1
	if (field_by_value(display_field_tab, &focus)->flags & FLG_GET)
d77 1
@


1.2
log
@add more display variables (for screen burner).
implement boolean type for variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.1 2000/07/01 23:52:45 mickey Exp $	*/
d47 1
d52 1
d59 1
a61 3
int display_field_tab_len = sizeof(display_field_tab)/
			     sizeof(display_field_tab[0]);

d63 2
a64 1
display_get_values(fd)
d67 3
a69 1
	if (field_by_value(&dpytype)->flags & FLG_GET)
d72 14
a85 6
	if (field_by_value(&burnon)->flags & FLG_GET ||
	    field_by_value(&burnoff)->flags & FLG_GET ||
	    field_by_value(&vblank)->flags & FLG_GET ||
	    field_by_value(&kbdact)->flags & FLG_GET ||
	    field_by_value(&msact )->flags & FLG_GET ||
	    field_by_value(&outact)->flags & FLG_GET) {
d92 1
a92 1
		if (field_by_value(&burnon)->flags & FLG_GET)
d95 1
a95 1
		if (field_by_value(&burnoff)->flags & FLG_GET)
d98 1
a98 1
		if (field_by_value(&vblank)->flags & FLG_GET)
d101 1
a101 1
		if (field_by_value(&kbdact)->flags & FLG_GET)
d104 1
a104 1
		if (field_by_value(&msact )->flags & FLG_GET)
d107 1
a107 1
		if (field_by_value(&outact)->flags & FLG_GET)
d113 2
a114 1
display_put_values(fd)
d117 10
a126 6
	if (field_by_value(&burnon)->flags & FLG_SET ||
	    field_by_value(&burnoff)->flags & FLG_SET ||
	    field_by_value(&vblank)->flags & FLG_SET ||
	    field_by_value(&kbdact)->flags & FLG_SET ||
	    field_by_value(&msact )->flags & FLG_SET ||
	    field_by_value(&outact)->flags & FLG_SET) {
d133 1
a133 1
		if (field_by_value(&burnon)->flags & FLG_SET)
d136 1
a136 1
		if (field_by_value(&burnoff)->flags & FLG_SET)
d139 1
a139 1
		if (field_by_value(&vblank)->flags & FLG_SET) {
d146 1
a146 1
		if (field_by_value(&kbdact)->flags & FLG_SET) {
d153 1
a153 1
		if (field_by_value(&msact )->flags & FLG_SET) {
d160 1
a160 1
		if (field_by_value(&outact)->flags & FLG_SET) {
@


1.1
log
@wscons control tool; initial import from newtbsd tree
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 2
a47 1
static int dpytype;
d51 6
d69 30
d105 49
@

