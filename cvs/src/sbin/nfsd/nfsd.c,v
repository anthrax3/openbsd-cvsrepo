head	1.37;
access;
symbols
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.36.0.6
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.4
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.32.0.6
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.31.0.12
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.10
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.8
	OPENBSD_5_0:1.31.0.6
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.6
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2017.08.31.06.50.56;	author mestre;	state Exp;
branches;
next	1.36;
commitid	qrgdo9sV92f0u3hv;

1.36
date	2016.06.07.01.29.38;	author tedu;	state Exp;
branches;
next	1.35;
commitid	aJp7bbwjTwgUYbAT;

1.35
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2014.05.11.00.03.14;	author chl;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.05.15.08.37;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.11.17.40.10;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.17.16.27.49;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.14.23.54.36;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.27.23.59.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.13.16.16.42;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.27.21.14.41;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.02.01.08.01;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.14.22.09.52;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.10.15.26.49;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.02.01.00.11;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.11.19.10.30;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.10.05.15.02;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.03.22.32.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.11.15.45.44;	author hin;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.22.08.21.02;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.07.18.26.17;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.04.14.59.48;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.19.17.57.40;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.22.20.25.03;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.02.24.09.51.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.09.05.18.29.34;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.18.03.11.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.08.04.19.25.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.06.29.11.10.32;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.06.25.18.28.10;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.41.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.16.20.41.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.21.00.16.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.44;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Unbreak DEBUG on nfsd(8) by changing the syslog macro. With this change a few
of the syslog calls also needed to change since fprintf(3) doesn't know about
%m and in these cases strerror(3) was added.

Caught with cppcheck

"looks good" to otto@@
@
text
@/*	$OpenBSD: nfsd.c,v 1.36 2016/06/07 01:29:38 tedu Exp $	*/
/*	$NetBSD: nfsd.c,v 1.19 1996/02/18 23:18:56 mycroft Exp $	*/

/*
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/uio.h>
#include <sys/ucred.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#include <rpc/pmap_prot.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

/* Global defs */
#ifdef DEBUG
#define	syslog(e, s, ...)			\
do {						\
	fprintf(stderr, (s), ##__VA_ARGS__);	\
	fprintf(stderr, "\n");			\
} while (0)
int	debug = 1;
#else
int	debug = 0;
#endif

struct	nfsd_srvargs nsd;

void	nonfs(int);
void	reapchild(int);
void	usage(void);

#define	MAXNFSDCNT	20
#define	DEFNFSDCNT	 4

/*
 * Nfs server daemon mostly just a user context for nfssvc()
 *
 * 1 - do file descriptor and signal cleanup
 * 2 - fork the nfsd(s)
 * 3 - create server socket(s)
 * 4 - register socket with portmap
 *
 * For connectionless protocols, just pass the socket into the kernel via.
 * nfssvc().
 * For connection based sockets, loop doing accepts. When you get a new
 * socket from accept, pass the msgsock into the kernel via. nfssvc().
 * The arguments are:
 *	-r - reregister with portmapper
 *	-t - support tcp nfs clients
 *	-u - support udp nfs clients
 * followed by "n" which is the number of nfsds' to fork off
 */
int
main(int argc, char *argv[])
{
	struct nfsd_args nfsdargs;
	struct sockaddr_in inetaddr;
	int ch, connect_type_cnt, i;
	int nfsdcnt = DEFNFSDCNT, on, reregister = 0, sock;
	int udpflag = 0, tcpflag = 0, tcpsock;
	const char *errstr = NULL;

	/* Start by writing to both console and log. */
	openlog("nfsd", LOG_PID | LOG_PERROR, LOG_DAEMON);

	if (argc == 1)
		udpflag = 1;
	while ((ch = getopt(argc, argv, "n:rtu")) != -1)
		switch (ch) {
		case 'n':
			nfsdcnt = strtonum(optarg, 1, MAXNFSDCNT, &errstr);
			if (errstr) {
				syslog(LOG_ERR, "nfsd count is %s: %s", errstr, optarg);
				return(1);
			}
			break;
		case 'r':
			reregister = 1;
			break;
		case 't':
			tcpflag = 1;
			break;
		case 'u':
			udpflag = 1;
			break;
		default:
			usage();
		};
	argv += optind;
	argc -= optind;

	/*
	 * XXX
	 * Backward compatibility, trailing number is the count of daemons.
	 */
	if (argc > 1)
		usage();
	if (argc == 1) {
		nfsdcnt = strtonum(argv[0], 1, MAXNFSDCNT, &errstr);
		if (errstr) {
			syslog(LOG_ERR, "nfsd count is %s: %s", errstr, optarg);
			return(1);
		}
	}

	if (debug == 0) {
		daemon(0, 0);
		(void)signal(SIGHUP, SIG_IGN);
		(void)signal(SIGINT, SIG_IGN);
		(void)signal(SIGQUIT, SIG_IGN);
		(void)signal(SIGSYS, nonfs);
	}
	(void)signal(SIGCHLD, reapchild);

	if (reregister) {
		if (udpflag &&
		    (!pmap_set(RPCPROG_NFS, 2, IPPROTO_UDP, NFS_PORT) ||
		     !pmap_set(RPCPROG_NFS, 3, IPPROTO_UDP, NFS_PORT))) {
			syslog(LOG_ERR, "can't register with portmap for UDP (%s).",
			    strerror(errno));
			return (1);
		}
		if (tcpflag &&
		    (!pmap_set(RPCPROG_NFS, 2, IPPROTO_TCP, NFS_PORT) ||
		     !pmap_set(RPCPROG_NFS, 3, IPPROTO_TCP, NFS_PORT))) {
			syslog(LOG_ERR, "can't register with portmap for TCP (%s).",
			    strerror(errno));
			return (1);
		}
		return (0);
	}

	/* Cut back to writing to log only. */
	closelog();
	openlog("nfsd", LOG_PID, LOG_DAEMON);

	for (i = 0; i < nfsdcnt; i++) {
		switch (fork()) {
		case -1:
			syslog(LOG_ERR, "fork: %s", strerror(errno));
			return (1);
		case 0:
			break;
		default:
			continue;
		}

		setproctitle("server");
		nsd.nsd_nfsd = NULL;
		if (nfssvc(NFSSVC_NFSD, &nsd) < 0) {
			syslog(LOG_ERR, "nfssvc: %s", strerror(errno));
			return (1);
		}
		return (0);
	}

	/* If we are serving udp, set up the socket. */
	if (udpflag) {
		if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
			syslog(LOG_ERR, "can't create udp socket");
			return (1);
		}
		memset(&inetaddr, 0, sizeof inetaddr);
		inetaddr.sin_family = AF_INET;
		inetaddr.sin_addr.s_addr = INADDR_ANY;
		inetaddr.sin_port = htons(NFS_PORT);
		inetaddr.sin_len = sizeof(inetaddr);
		if (bind(sock, (struct sockaddr *)&inetaddr,
		    sizeof(inetaddr)) < 0) {
			syslog(LOG_ERR, "can't bind udp addr");
			return (1);
		}
		if (!pmap_set(RPCPROG_NFS, 2, IPPROTO_UDP, NFS_PORT) ||
		    !pmap_set(RPCPROG_NFS, 3, IPPROTO_UDP, NFS_PORT)) {
			syslog(LOG_ERR, "can't register with udp portmap");
			return (1);
		}
		nfsdargs.sock = sock;
		nfsdargs.name = NULL;
		nfsdargs.namelen = 0;
		if (nfssvc(NFSSVC_ADDSOCK, &nfsdargs) < 0) {
			syslog(LOG_ERR, "can't Add UDP socket");
			return (1);
		}
		(void)close(sock);
	}

	/* Now set up the master server socket waiting for tcp connections. */
	on = 1;
	connect_type_cnt = 0;
	if (tcpflag) {
		if ((tcpsock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
			syslog(LOG_ERR, "can't create tcp socket");
			return (1);
		}
		if (setsockopt(tcpsock,
		    SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
			syslog(LOG_ERR, "setsockopt SO_REUSEADDR: %s", strerror(errno));
		memset(&inetaddr, 0, sizeof inetaddr);
		inetaddr.sin_family = AF_INET;
		inetaddr.sin_addr.s_addr = INADDR_ANY;
		inetaddr.sin_port = htons(NFS_PORT);
		inetaddr.sin_len = sizeof(inetaddr);
		if (bind(tcpsock, (struct sockaddr *)&inetaddr,
		    sizeof (inetaddr)) < 0) {
			syslog(LOG_ERR, "can't bind tcp addr");
			return (1);
		}
		if (listen(tcpsock, 5) < 0) {
			syslog(LOG_ERR, "listen failed");
			return (1);
		}
		if (!pmap_set(RPCPROG_NFS, 2, IPPROTO_TCP, NFS_PORT) ||
		    !pmap_set(RPCPROG_NFS, 3, IPPROTO_TCP, NFS_PORT)) {
			syslog(LOG_ERR, "can't register tcp with portmap");
			return (1);
		}
		connect_type_cnt++;
	}

	if (connect_type_cnt == 0)
		return (0);

	setproctitle("master");

	/*
	 * Loop forever accepting connections and passing the sockets
	 * into the kernel for the mounts.
	 */
	for (;;) {
		struct pollfd		pfd;
		struct sockaddr_in	inetpeer;
		int ret, msgsock;
		socklen_t len;

		pfd.fd = tcpsock;
		pfd.events = POLLIN;

		if (connect_type_cnt > 1) {
			ret = poll(&pfd, 1, INFTIM);
			if (ret < 1) {
				syslog(LOG_ERR, "poll failed: %s", strerror(errno));
				return (1);
			}
				
		}
		
		if (tcpflag) {
			len = sizeof(inetpeer);
			if ((msgsock = accept(tcpsock,
			    (struct sockaddr *)&inetpeer, &len)) < 0) {
				if (errno == EWOULDBLOCK || errno == EINTR ||
				    errno == ECONNABORTED)
					continue;
				syslog(LOG_ERR, "accept failed: %s", strerror(errno));
				return (1);
			}
			memset(inetpeer.sin_zero, 0, sizeof(inetpeer.sin_zero));
			if (setsockopt(msgsock, SOL_SOCKET,
			    SO_KEEPALIVE, &on, sizeof(on)) < 0)
				syslog(LOG_ERR,
				    "setsockopt SO_KEEPALIVE: %s", strerror(errno));
			nfsdargs.sock = msgsock;
			nfsdargs.name = (caddr_t)&inetpeer;
			nfsdargs.namelen = sizeof(inetpeer);
			if (nfssvc(NFSSVC_ADDSOCK, &nfsdargs) < 0) {
				syslog(LOG_ERR, "can't Add TCP socket");
				return (1);
			}
			(void)close(msgsock);
		}
	}
}

void
usage(void)
{
	(void)fprintf(stderr, "usage: nfsd [-rtu] [-n num_servers]\n");
	exit(1);
}

/* ARGSUSED */
void
nonfs(int signo)
{
	int save_errno = errno;
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	syslog_r(LOG_ERR, &sdata, "missing system call: NFS not available.");
	errno = save_errno;
}

/* ARGSUSED */
void
reapchild(int signo)
{
	int save_errno = errno;

	while (wait3(NULL, WNOHANG, NULL) > 0)
		continue;
	errno = save_errno;
}
@


1.36
log
@per trending style, add continue to emtpy loop bodies.
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.35 2015/01/16 06:40:00 deraadt Exp $	*/
d67 5
a71 1
#define	syslog(e, s)	fprintf(stderr,(s))
d170 2
a171 1
			syslog(LOG_ERR, "can't register with portmap for UDP (%m).");
d177 2
a178 1
			syslog(LOG_ERR, "can't register with portmap for TCP (%m).");
d191 1
a191 1
			syslog(LOG_ERR, "fork: %m");
d202 1
a202 1
			syslog(LOG_ERR, "nfssvc: %m");
d249 1
a249 1
			syslog(LOG_ERR, "setsockopt SO_REUSEADDR: %m");
d293 1
a293 1
				syslog(LOG_ERR, "poll failed: %m");
d306 1
a306 1
				syslog(LOG_ERR, "accept failed: %m");
d313 1
a313 1
				    "setsockopt SO_KEEPALIVE: %m");
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.34 2014/05/11 00:03:14 chl Exp $	*/
d345 1
a345 1
		;
@


1.34
log
@remove unused variable

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.33 2014/05/05 15:08:37 tedu Exp $	*/
a35 1
#include <sys/param.h>
@


1.33
log
@convert select to poll. from peter malone
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.32 2013/03/11 17:40:10 deraadt Exp $	*/
d105 1
a105 1
	struct sockaddr_in inetaddr, inetpeer;
@


1.32
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.31 2010/04/17 16:27:49 krw Exp $	*/
d106 1
a106 3
	fd_set *ready, *sockbits;
	size_t fd_size;
	int ch, connect_type_cnt, i, maxsock = 0, msgsock;
a109 1
	socklen_t len;
a263 1
		maxsock = tcpsock;
a272 14
	 * Allocate space for the fd_set pointers and fill in sockbits
	 */
	fd_size = howmany(maxsock + 1, NFDBITS) * sizeof(fd_mask);
	sockbits = malloc(fd_size);
	ready = malloc(fd_size);
	if (sockbits == NULL || ready == NULL) {
		syslog(LOG_ERR, "cannot allocate memory");
		return (1);
	}
	memset(sockbits, 0, fd_size);
	if (tcpflag)
		FD_SET(tcpsock, sockbits);

	/*
d277 8
a284 1
		memcpy(ready, sockbits, fd_size);
d286 3
a288 3
			if (select(maxsock + 1,
			    ready, NULL, NULL, NULL) < 1) {
				syslog(LOG_ERR, "select failed: %m");
d291 1
d293 2
a294 1
		if (tcpflag && FD_ISSET(tcpsock, ready)) {
@


1.31
log
@Print startup errors to both the console and the log, rather than
just the console.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.30 2010/04/14 23:54:36 krw Exp $	*/
d307 3
@


1.30
log
@Specifying an invalid number of nfsd's is an error. So error out
rather than try to guess what was intended.

ok halex@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.29 2009/10/27 23:59:33 deraadt Exp $	*/
d114 3
d123 4
a126 2
			if (errstr)
				errx(1, "nfsd count is %s: %s", errstr, optarg);
d151 4
a154 2
		if (errstr)
			errx(1, "nfsd count is %s: %s", errstr, argv[0]);
d169 4
a172 2
		     !pmap_set(RPCPROG_NFS, 3, IPPROTO_UDP, NFS_PORT)))
			err(1, "can't register with portmap for UDP.");
d175 4
a178 2
		     !pmap_set(RPCPROG_NFS, 3, IPPROTO_TCP, NFS_PORT)))
			err(1, "can't register with portmap for TCP.");
d181 3
@


1.29
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.28 2008/03/13 16:16:42 thib Exp $	*/
d120 2
a121 5
			if (errstr) {
				warnx("nfsd count %s %s; reset to %d",
				    optarg, errstr, DEFNFSDCNT);
				nfsdcnt = DEFNFSDCNT;
			}
d146 2
a147 5
		if (errstr) {
			warnx("nfsd count %s %s; reset to %d",
			    argv[0], errstr, DEFNFSDCNT);
			nfsdcnt = DEFNFSDCNT;
		}
@


1.28
log
@make sure we start 4 servers on udp if called with
no arguments, like the man page promises.

ok deraadt@@, blambert@@

From tcuji@@pwns.ms
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.27 2007/05/27 21:14:41 thib Exp $	*/
a34 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)nfsd.c	8.9 (Berkeley) 3/29/95";
#else
static const char rcsid[] = "$OpenBSD: nfsd.c,v 1.27 2007/05/27 21:14:41 thib Exp $";
#endif
#endif /* not lint */
@


1.27
log
@cleanup the nfssvc() system call.
* Remove alot of dead kerberos code like
  the options for NFSSVC_AUTHIN and NFSSVC_AUTHFAIL wich where
  originally to get the kerberos auth info into the kernel.
  (that hasnt worked for long, if ever.)
  Also remove some helper functions and associated goo, however
  theres still alot of it left.
* Remove NFSSVC_BIOD, biod's where replaced with kernel threads
  a long time ago.
* NFSSVC_MNTD wich was is NQNFS leftover.

Update the man page and nfsd(8).

nfssvc(2) besides being special has only one user in the tree
nfsd(8), therefore no library bumps are needed.
(discussed with deraadt@@).

ok beck@@, "go a head" deraadt@@
Tested by ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.26 2005/12/02 01:08:01 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: nfsd.c,v 1.26 2005/12/02 01:08:01 deraadt Exp $";
d128 2
@


1.26
log
@make lint a bit happier
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.25 2004/09/14 22:09:52 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: nfsd.c,v 1.25 2004/09/14 22:09:52 deraadt Exp $";
d123 1
a123 1
	int nfsdcnt = DEFNFSDCNT, nfssvc_flag, on, reregister = 0, sock;
a201 1
		nfssvc_flag = NFSSVC_NFSD;
d203 3
a205 6
		while (nfssvc(nfssvc_flag, &nsd) < 0) {
			if (errno != ENEEDAUTH) {
				syslog(LOG_ERR, "nfssvc: %m");
				return (1);
			}
			nfssvc_flag = NFSSVC_NFSD | NFSSVC_AUTHINFAIL;
d322 4
a325 1
			nfssvc(NFSSVC_ADDSOCK, &nfsdargs);
@


1.25
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.24 2004/05/10 15:26:49 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: nfsd.c,v 1.24 2004/05/10 15:26:49 deraadt Exp $";
d254 1
a254 1
		    SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on)) < 0)
d320 1
a320 1
			    SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0)
@


1.24
log
@remove iso crud, and other misc cleanups; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.23 2004/03/02 01:00:11 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: nfsd.c,v 1.23 2004/03/02 01:00:11 deraadt Exp $";
d339 1
d350 1
@


1.23
log
@bad openlog call; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.22 2003/08/11 19:10:30 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: nfsd.c,v 1.22 2003/08/11 19:10:30 millert Exp $";
a63 3
#ifdef ISO
#include <netiso/iso.h>
#endif
d94 3
a109 1
 *	-c - support iso cltp clients
a119 3
#ifdef ISO
	struct sockaddr_iso isoaddr, isopeer;
#endif
d122 4
a125 3
	int ch, cltpflag, connect_type_cnt, i, maxsock = 0, msgsock;
	int nfsdcnt, nfssvc_flag, on, reregister, sock, tcpflag, tcpsock;
	int tp4cnt, tpipcnt, udpflag;
d128 1
a128 13
#define	MAXNFSDCNT	20
#define	DEFNFSDCNT	 4
	nfsdcnt = DEFNFSDCNT;
	cltpflag = reregister = tcpflag = tp4cnt = tpipcnt = 0;
	tcpsock = udpflag = 0;
#ifdef ISO
#define	GETOPT	"cn:rtu"
#define	USAGE	"[-crtu] [-n num_servers]"
#else
#define	GETOPT	"n:rtu"
#define	USAGE	"[-rtu] [-n num_servers]"
#endif
	while ((ch = getopt(argc, argv, GETOPT)) != -1)
d131 4
a134 4
			nfsdcnt = atoi(optarg);
			if (nfsdcnt < 1 || nfsdcnt > MAXNFSDCNT) {
				warnx("nfsd count %d; reset to %d",
				    nfsdcnt, DEFNFSDCNT);
a146 13
#ifdef ISO
		case 'c':
			cltpflag = 1;
			break;
#ifdef notyet
		case 'i':
			tp4cnt = 1;
			break;
		case 'p':
			tpipcnt = 1;
			break;
#endif /* notyet */
#endif /* ISO */
a147 1
		case '?':
d160 4
a163 4
		nfsdcnt = atoi(argv[0]);
		if (nfsdcnt < 1 || nfsdcnt > MAXNFSDCNT) {
			warnx("nfsd count %d; reset to %d",
			    nfsdcnt, DEFNFSDCNT);
d225 2
a226 2
		if (bind(sock,
		    (struct sockaddr *)&inetaddr, sizeof(inetaddr)) < 0) {
a244 41
#ifdef ISO
	/* If we are serving cltp, set up the socket. */
	if (cltpflag) {
		if ((sock = socket(AF_ISO, SOCK_DGRAM, 0)) < 0) {
			syslog(LOG_ERR, "can't create cltp socket");
			return (1);
		}
		memset(&isoaddr, 0, sizeof(isoaddr));
		isoaddr.siso_family = AF_ISO;
		isoaddr.siso_tlen = 2;
		cp = TSEL(&isoaddr);
		*cp++ = (NFS_PORT >> 8);
		*cp = (NFS_PORT & 0xff);
		isoaddr.siso_len = sizeof(isoaddr);
		if (bind(sock,
		    (struct sockaddr *)&isoaddr, sizeof(isoaddr)) < 0) {
			syslog(LOG_ERR, "can't bind cltp addr");
			return (1);
		}
#ifdef notyet
		/*
		 * XXX
		 * Someday this should probably use "rpcbind", the son of
		 * portmap.
		 */
		if (!pmap_set(RPCPROG_NFS, NFS_VER2, IPPROTO_UDP, NFS_PORT)) {
			syslog(LOG_ERR, "can't register with udp portmap");
			return (1);
		}
#endif /* notyet */
		nfsdargs.sock = sock;
		nfsdargs.name = NULL;
		nfsdargs.namelen = 0;
		if (nfssvc(NFSSVC_ADDSOCK, &nfsdargs) < 0) {
			syslog(LOG_ERR, "can't add UDP socket");
			return (1);
		}
		close(sock);
	}
#endif /* ISO */

d261 2
a262 2
		if (bind(tcpsock,
		    (struct sockaddr *)&inetaddr, sizeof (inetaddr)) < 0) {
a278 76
#ifdef notyet
	/* Now set up the master server socket waiting for tp4 connections. */
	if (tp4flag) {
		if ((tp4sock = socket(AF_ISO, SOCK_SEQPACKET, 0)) < 0) {
			syslog(LOG_ERR, "can't create tp4 socket");
			return (1);
		}
		if (setsockopt(tp4sock,
		    SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on)) < 0)
			syslog(LOG_ERR, "setsockopt SO_REUSEADDR: %m");
		memset(&isoaddr, 0, sizeof(isoaddr));
		isoaddr.siso_family = AF_ISO;
		isoaddr.siso_tlen = 2;
		cp = TSEL(&isoaddr);
		*cp++ = (NFS_PORT >> 8);
		*cp = (NFS_PORT & 0xff);
		isoaddr.siso_len = sizeof(isoaddr);
		if (bind(tp4sock,
		    (struct sockaddr *)&isoaddr, sizeof(isoaddr)) < 0) {
			syslog(LOG_ERR, "can't bind tp4 addr");
			return (1);
		}
		if (listen(tp4sock, 5) < 0) {
			syslog(LOG_ERR, "listen failed");
			return (1);
		}
		/*
		 * XXX
		 * Someday this should probably use "rpcbind", the son of
		 * portmap.
		 */
		if (!pmap_set(RPCPROG_NFS, NFS_VER2, IPPROTO_TCP, NFS_PORT)) {
			syslog(LOG_ERR, "can't register tcp with portmap");
			return (1);
		}
		maxsock = tp4sock;
		connect_type_cnt++;
	}

	/* Now set up the master server socket waiting for tpip connections. */
	if (tpipflag) {
		if ((tpipsock = socket(AF_INET, SOCK_SEQPACKET, 0)) < 0) {
			syslog(LOG_ERR, "can't create tpip socket");
			return (1);
		}
		if (setsockopt(tpipsock,
		    SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on)) < 0)
			syslog(LOG_ERR, "setsockopt SO_REUSEADDR: %m");
		memset(&inetaddr, 0, sizeof inetaddr);
		inetaddr.sin_family = AF_INET;
		inetaddr.sin_addr.s_addr = INADDR_ANY;
		inetaddr.sin_port = htons(NFS_PORT);
		inetaddr.sin_len = sizeof(inetaddr);
		if (bind(tpipsock,
		    (struct sockaddr *)&inetaddr, sizeof (inetaddr)) < 0) {
			syslog(LOG_ERR, "can't bind tcp addr");
			return (1);
		}
		if (listen(tpipsock, 5) < 0) {
			syslog(LOG_ERR, "listen failed");
			return (1);
		}
		/*
		 * XXX
		 * Someday this should probably use "rpcbind", the son of
		 * portmap.
		 */
		if (!pmap_set(RPCPROG_NFS, NFS_VER2, IPPROTO_TCP, NFS_PORT)) {
			syslog(LOG_ERR, "can't register tcp with portmap");
			return (1);
		}
		maxsock = tpipsock;
		connect_type_cnt++;
	}
#endif /* notyet */

a296 6
#ifdef notyet
	if (tp4flag)
		FD_SET(tp4sock, sockbits);
	if (tpipflag)
		FD_SET(tpipsock, sockbits);
#endif
a328 35
#ifdef notyet
		if (tp4flag && FD_ISSET(tp4sock, ready)) {
			len = sizeof(isopeer);
			if ((msgsock = accept(tp4sock,
			    (struct sockaddr *)&isopeer, &len)) < 0) {
				syslog(LOG_ERR, "accept failed: %m");
				return (1);
			}
			if (setsockopt(msgsock, SOL_SOCKET,
			    SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0)
				syslog(LOG_ERR,
				    "setsockopt SO_KEEPALIVE: %m");
			nfsdargs.sock = msgsock;
			nfsdargs.name = (caddr_t)&isopeer;
			nfsdargs.namelen = len;
			nfssvc(NFSSVC_ADDSOCK, &nfsdargs);
			(void)close(msgsock);
		}
		if (tpipflag && FD_ISSET(tpipsock, ready)) {
			len = sizeof(inetpeer);
			if ((msgsock = accept(tpipsock,
			    (struct sockaddr *)&inetpeer, &len)) < 0) {
				syslog(LOG_ERR, "Accept failed: %m");
				return (1);
			}
			if (setsockopt(msgsock, SOL_SOCKET,
			    SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0)
				syslog(LOG_ERR, "setsockopt SO_KEEPALIVE: %m");
			nfsdargs.sock = msgsock;
			nfsdargs.name = (caddr_t)&inetpeer;
			nfsdargs.namelen = len;
			nfssvc(NFSSVC_ADDSOCK, &nfsdargs);
			(void)close(msgsock);
		}
#endif /* notyet */
d335 1
a335 1
	(void)fprintf(stderr, "usage: nfsd %s\n", USAGE);
@


1.22
log
@Dynamic select(2) support; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.21 2003/06/02 20:06:16 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: nfsd.c,v 1.21 2003/06/02 20:06:16 millert Exp $";
d217 1
a217 1
	openlog("nfsd:", LOG_PID, LOG_DAEMON);
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.20 2002/09/10 05:15:02 deraadt Exp $	*/
d37 1
a37 1
static char copyright[] =
d44 1
a44 1
static char sccsid[] = "@@(#)nfsd.c	8.9 (Berkeley) 3/29/95";
d46 1
a46 1
static char rcsid[] = "$NetBSD: nfsd.c,v 1.19 1996/02/18 23:18:56 mycroft Exp $";
d124 2
a125 1
	fd_set ready, sockbits;
a316 1
	FD_ZERO(&sockbits);
a344 1
		FD_SET(tcpsock, &sockbits);
a383 1
		FD_SET(tp4sock, &sockbits);
a419 1
		FD_SET(tpipsock, &sockbits);
d431 20
d455 1
a455 1
		ready = sockbits;
d458 1
a458 1
			    &ready, NULL, NULL, NULL) < 1) {
d463 1
a463 1
		if (tcpflag && FD_ISSET(tcpsock, &ready)) {
d482 1
a482 1
		if (tp4flag && FD_ISSET(tp4sock, &ready)) {
d499 1
a499 1
		if (tpipflag && FD_ISSET(tpipsock, &ready)) {
@


1.20
log
@socklen_t; cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.19 2002/07/03 22:32:33 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.18 2002/06/11 15:45:44 hin Exp $	*/
d129 1
a129 1
	int ch, cltpflag, connect_type_cnt, i, len, maxsock = 0, msgsock;
d132 1
@


1.18
log
@Remove some unused code for dealing with nfs over kerberos. No actual change,
just some #ifdef'ed out code removed.

ok deraadt@@, art@@ and csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.17 2002/05/22 08:21:02 deraadt Exp $	*/
d121 1
a121 3
main(argc, argv, envp)
	int argc;
	char *argv[], *envp[];
d506 1
a506 1
usage()
d513 1
a513 2
nonfs(signo)
	int signo;
d515 5
a519 2
	/* XXX signal race */
	syslog(LOG_ERR, "missing system call: NFS not available.");
d523 1
a523 2
reapchild(signo)
	int signo;
@


1.17
log
@strcpy, sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.16 2002/02/16 21:27:37 millert Exp $	*/
a74 5
#ifdef NFSKERB
#include <des.h>
#include <kerberosIV/krb.h>
#endif

a96 12
#ifdef NFSKERB
char		lnam[ANAME_SZ];
KTEXT_ST	kt;
AUTH_DAT	kauth;
char		inst[INST_SZ];
struct nfsrpc_fullblock kin, kout;
struct nfsrpc_fullverf kverf;
NFSKERBKEY_T	kivec;
struct timeval	ktv;
NFSKERBKEYSCHED_T kerb_keysched;
#endif

a133 8
#ifdef NFSKERB
	struct ucred *cr;
	char *cp, **cpp;
	int tpipflag = 0, tp4flag = 0, tpipsock = 0, tp4sock;
	struct timeval ktv;
	struct passwd *pwd;
	struct group *grp;
#endif
a236 9
#ifdef NFSKERB
		if (sizeof (struct nfsrpc_fullverf) != RPCX_FULLVERF ||
		    sizeof (struct nfsrpc_fullblock) != RPCX_FULLBLOCK)
		    syslog(LOG_ERR, "Yikes NFSKERB structs not packed!");
		nsd.nsd_authstr = (u_char *)&kt;
		nsd.nsd_authlen = sizeof (kt);
		nsd.nsd_verfstr = (u_char *)&kverf;
		nsd.nsd_verflen = sizeof (kverf);
#endif
a242 70
#ifdef NFSKERB
			/*
			 * Get the Kerberos ticket out of the authenticator
			 * verify it and convert the principal name to a user
			 * name. The user name is then converted to a set of
			 * user credentials via the password and group file.
			 * Finally, decrypt the timestamp and validate it.
			 * For more info see the IETF Draft "Authentication
			 * in ONC RPC".
			 */
			kt.length = ntohl(kt.length);
			if (gettimeofday(&ktv, NULL) == 0 &&
			    kt.length > 0 && kt.length <=
			    (RPCAUTH_MAXSIZ - 3 * NFSX_UNSIGNED)) {
			    kin.w1 = NFS_KERBW1(kt);
			    kt.mbz = 0;
			    (void)strlcpy(inst, "*", sizeof inst);
			    if (krb_rd_req(&kt, NFS_KERBSRV,
				inst, nsd.nsd_haddr, &kauth, "") == RD_AP_OK &&
				krb_kntoln(&kauth, lnam) == KSUCCESS &&
				(pwd = getpwnam(lnam)) != NULL) {
				cr = &nsd.nsd_cr;
				cr->cr_uid = pwd->pw_uid;
				cr->cr_groups[0] = pwd->pw_gid;
				cr->cr_ngroups = 1;
				setgrent();
				while ((grp = getgrent()) != NULL) {
					if (grp->gr_gid == cr->cr_groups[0])
						continue;
					for (cpp = grp->gr_mem;
					    *cpp != NULL; ++cpp)
						if (!strcmp(*cpp, lnam))
							break;
					if (*cpp == NULL)
						continue;
					cr->cr_groups[cr->cr_ngroups++]
					    = grp->gr_gid;
					if (cr->cr_ngroups == NGROUPS)
						break;
				}
				endgrent();

				/*
				 * Get the timestamp verifier out of the
				 * authenticator and verifier strings.
				 */
				kin.t1 = kverf.t1;
				kin.t2 = kverf.t2;
				kin.w2 = kverf.w2;
				memset((caddr_t)kivec, 0, sizeof (kivec));
				memmove((caddr_t)nsd.nsd_key,
				    (caddr_t)kauth.session,
				    sizeof(kauth.session));

				/*
				 * Decrypt the timestamp verifier in CBC mode.
				 */
				XXX

				/*
				 * Validate the timestamp verifier, to
				 * check that the session key is ok.
				 */
				nsd.nsd_timestamp.tv_sec = ntohl(kout.t1);
				nsd.nsd_timestamp.tv_usec = ntohl(kout.t2);
				nsd.nsd_ttl = ntohl(kout.w1);
				if ((nsd.nsd_ttl - 1) == ntohl(kout.w2))
				    nfssvc_flag = NFSSVC_NFSD | NFSSVC_AUTHIN;
			}
#endif /* NFSKERB */
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.15 2001/08/12 12:03:02 heko Exp $	*/
d293 1
a293 1
			    (void)strcpy(inst, "*");
@


1.15
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.14 2001/07/07 18:26:17 deraadt Exp $	*/
d114 3
a116 3
void	nonfs __P((int));
void	reapchild __P((int));
void	usage __P((void));
@


1.14
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.13 2001/06/04 14:59:48 mickey Exp $	*/
d44 1
a44 1
#endif not lint
@


1.13
log
@return from main() don't exit
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.12 2001/01/19 17:57:40 deraadt Exp $	*/
a141 1
	struct group *grp;
a142 2
	struct passwd *pwd;
	struct ucred *cr;
a146 1
	struct timeval ktv;
d148 1
a148 1
	int ch, cltpflag, connect_type_cnt, i, len, maxsock, msgsock;
d150 3
a152 1
	int tp4cnt, tp4flag, tp4sock, tpipcnt, tpipflag, tpipsock, udpflag;
d154 5
d163 2
a164 2
	cltpflag = reregister = tcpflag = tp4cnt = tp4flag = tpipcnt = 0;
	tpipflag = udpflag = 0;
@


1.12
log
@mark signal races i cannot fix at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.11 2000/01/22 20:25:03 deraadt Exp $	*/
d241 1
a241 1
		exit(0);
d249 1
a249 1
			exit (1);
d271 1
a271 1
				exit(1);
d345 1
a345 1
		exit(0);
d352 1
a352 1
			exit(1);
d362 1
a362 1
			exit(1);
d367 1
a367 1
			exit(1);
d374 1
a374 1
			exit(1);
d384 1
a384 1
			exit(1);
d396 1
a396 1
			exit(1);
d406 1
a406 1
			exit(1);
d414 1
a414 1
			exit(1);
d427 1
a427 1
			exit(1);
d440 1
a440 1
			exit(1);
d444 1
a444 1
			exit(1);
d449 1
a449 1
			exit(1);
d461 1
a461 1
			exit(1);
d476 1
a476 1
			exit(1);
d480 1
a480 1
			exit(1);
d489 1
a489 1
			exit(1);
d500 1
a500 1
			exit(1);
d513 1
a513 1
			exit(1);
d517 1
a517 1
			exit(1);
d526 1
a526 1
			exit(1);
d535 1
a535 1
		exit(0);
d549 1
a549 1
				exit(1);
d557 1
a557 1
				exit(1);
d576 1
a576 1
				exit(1);
d593 1
a593 1
				exit(1);
@


1.11
log
@remove extra externs not needed because of unistd.h (rest of tree will be done later.. contact me if you want to help)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.10 1999/02/24 09:51:12 deraadt Exp $	*/
d619 1
a619 1

@


1.10
log
@let it die nice from SIGTERM; fvdl
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.9 1997/09/05 18:29:34 deraadt Exp $	*/
a141 1
	extern int optind;
@


1.9
log
@busted warnx; msaitoh@@spa.is.uec.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.8 1997/08/18 03:11:26 millert Exp $	*/
a229 1
		(void)signal(SIGTERM, SIG_IGN);
@


1.8
log
@#include <string.h> not <strings.h> -- Yes, I'm a weanie...
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.7 1997/08/04 19:25:21 deraadt Exp $	*/
d175 2
a176 1
				warnx("nfsd count %d; reset to %d", DEFNFSDCNT);
d218 2
a219 1
			warnx("nfsd count %d; reset to %d", DEFNFSDCNT);
@


1.7
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.6 1997/06/29 11:10:32 provos Exp $	*/
d88 1
a88 1
#include <strings.h>
@


1.6
log
@new location of des.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.5 1997/06/25 18:28:10 kstailey Exp $	*/
d627 1
d629 3
a631 1
	while (wait3(NULL, WNOHANG, NULL) > 0);
@


1.5
log
@(foo *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.4 1997/01/15 23:41:34 millert Exp $	*/
d76 1
a76 1
#include <kerberosIV/des.h>
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.3 1996/09/16 20:41:28 deraadt Exp $	*/
d285 1
a285 1
			if (gettimeofday(&ktv, (struct timezone *)0) == 0 &&
@


1.3
log
@use memset/memmove
@
text
@d1 1
a1 1
/*	$OpenBSD: nfsd.c,v 1.2 1996/03/21 00:16:22 niklas Exp $	*/
d170 1
a170 1
	while ((ch = getopt(argc, argv, GETOPT)) != EOF)
@


1.2
log
@From NetBSD: Merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d323 4
a326 3
				bzero((caddr_t)kivec, sizeof (kivec));
				bcopy((caddr_t)kauth.session,
				    (caddr_t)nsd.nsd_key,sizeof(kauth.session));
d354 1
d432 1
d505 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: nfsd.c,v 1.17 1995/05/28 05:31:45 jtc Exp $	*/
d48 1
a48 1
static char sccsid[] = "@@(#)nfsd.c	8.7 (Berkeley) 2/22/94";
d50 1
a50 1
static char rcsid[] = "$NetBSD: nfsd.c,v 1.17 1995/05/28 05:31:45 jtc Exp $";
d52 1
a52 1
#endif not lint
a54 1
#include <syslog.h>
d72 1
a72 1
#include <nfs/nfsv2.h>
d75 1
a75 1
#ifdef KERBEROS
d89 1
d102 1
a102 1
#ifdef KERBEROS
d105 1
a105 1
AUTH_DAT	auth;
d107 5
d151 1
d234 2
a235 1
		    !pmap_set(RPCPROG_NFS, NFS_VER2, IPPROTO_UDP, NFS_PORT))
d238 2
a239 1
		    !pmap_set(RPCPROG_NFS, NFS_VER2, IPPROTO_TCP, NFS_PORT))
d259 8
a266 2
#ifdef KERBEROS
		nsd.nsd_authstr = (char *)kt.dat;
d274 21
a294 8
#ifdef KERBEROS
			kt.length = nsd.nsd_authlen;
			kt.mbz = 0;
			(void)strcpy(inst, "*");
			if (krb_rd_req(&kt, "rcmd",
			    inst, nsd.nsd_haddr, &auth, "") == RD_AP_OK &&
			    krb_kntoln(&auth, lnam) == KSUCCESS &&
			    (pwd = getpwnam(lnam)) != NULL) {
d315 26
a340 1
				nfssvc_flag = NFSSVC_NFSD | NFSSVC_AUTHIN;
d342 1
a342 1
#endif /* KERBEROS */
d362 2
a363 1
		if (!pmap_set(RPCPROG_NFS, NFS_VER2, IPPROTO_UDP, NFS_PORT)) {
d443 2
a444 1
		if (!pmap_set(RPCPROG_NFS, NFS_VER2, IPPROTO_TCP, NFS_PORT)) {
a606 1

d624 1
a624 1
	while (wait3((int *)0, WNOHANG, (struct rusage *)0) > 0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
