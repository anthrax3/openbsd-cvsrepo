head	1.42;
access;
symbols
	OPENBSD_6_1:1.42.0.8
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.3.0.40
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.32
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.36
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.34
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.30
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.28
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.26
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.24
	OPENBSD_5_0:1.3.0.22
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.20
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.18
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.14
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.16
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.12
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.10
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.8
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.2.0.16
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.14
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.12
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.1.0.6
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.4
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.2
	OPENBSD_2_9_BASE:1.1.1.1
	ver1:1.1.1.1
	apple19980218:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.01.31.23.00.11;	author krw;	state Exp;
branches;
next	1.41;
commitid	74Rthqc3AgIVhks7;

1.41
date	2016.01.31.15.28.56;	author krw;	state Exp;
branches;
next	1.40;
commitid	SANePqcLzJeNFm7O;

1.40
date	2016.01.31.14.55.41;	author krw;	state Exp;
branches;
next	1.39;
commitid	ZjbTHa9TF7xtCAJm;

1.39
date	2016.01.30.17.28.34;	author krw;	state Exp;
branches;
next	1.38;
commitid	COYvQbOVRVliKCZj;

1.38
date	2016.01.30.17.21.10;	author krw;	state Exp;
branches;
next	1.37;
commitid	BOQYiykYZJ8gnOpB;

1.37
date	2016.01.30.17.09.11;	author krw;	state Exp;
branches;
next	1.36;
commitid	ckpV9XGgFAiDBI9u;

1.36
date	2016.01.29.22.51.43;	author krw;	state Exp;
branches;
next	1.35;
commitid	T4U3iDofClirvhXD;

1.35
date	2016.01.29.15.06.37;	author krw;	state Exp;
branches;
next	1.34;
commitid	24MMipkr6YquiMM1;

1.34
date	2016.01.29.14.54.38;	author krw;	state Exp;
branches;
next	1.33;
commitid	JxW4PE5GwpjH1Ttx;

1.33
date	2016.01.29.14.48.20;	author krw;	state Exp;
branches;
next	1.32;
commitid	qzU9koNDngf0pT0B;

1.32
date	2016.01.28.22.09.56;	author krw;	state Exp;
branches;
next	1.31;
commitid	NbluAn6i0LiU8EjX;

1.31
date	2016.01.28.19.07.45;	author krw;	state Exp;
branches;
next	1.30;
commitid	V5tzgmz34tYP6x81;

1.30
date	2016.01.27.14.47.53;	author krw;	state Exp;
branches;
next	1.29;
commitid	HSGGvwKIkrWkURCB;

1.29
date	2016.01.24.01.38.32;	author krw;	state Exp;
branches;
next	1.28;
commitid	g7Azk2rL78IOOfnI;

1.28
date	2016.01.23.23.25.58;	author krw;	state Exp;
branches;
next	1.27;
commitid	PPThwZCvKA3Y8sbd;

1.27
date	2016.01.23.15.05.52;	author krw;	state Exp;
branches;
next	1.26;
commitid	VImq5zcnibLGbq1Q;

1.26
date	2016.01.22.18.57.42;	author krw;	state Exp;
branches;
next	1.25;
commitid	gbwjpDFPWC5oF67r;

1.25
date	2016.01.22.17.35.16;	author krw;	state Exp;
branches;
next	1.24;
commitid	yo0CGbxOUa4UAkDH;

1.24
date	2016.01.22.17.29.37;	author krw;	state Exp;
branches;
next	1.23;
commitid	cDtMRWiYL9BHYQT2;

1.23
date	2016.01.22.04.16.25;	author krw;	state Exp;
branches;
next	1.22;
commitid	e3erKRbnCu8liejZ;

1.22
date	2016.01.22.01.25.56;	author krw;	state Exp;
branches;
next	1.21;
commitid	UnRUlgKDkfeEnQQF;

1.21
date	2016.01.21.15.33.21;	author krw;	state Exp;
branches;
next	1.20;
commitid	YzEQpnBPgLX85u7F;

1.20
date	2016.01.21.02.52.52;	author krw;	state Exp;
branches;
next	1.19;
commitid	CSp7NWaeW8rVW6mR;

1.19
date	2016.01.18.17.57.35;	author krw;	state Exp;
branches;
next	1.18;
commitid	nIKs6pPbVKcIxae8;

1.18
date	2016.01.18.00.04.36;	author krw;	state Exp;
branches;
next	1.17;
commitid	luTmgvtH0tpvRRV4;

1.17
date	2016.01.17.23.18.19;	author krw;	state Exp;
branches;
next	1.16;
commitid	vC4VO4mr30PnBRSq;

1.16
date	2016.01.17.19.39.20;	author krw;	state Exp;
branches;
next	1.15;
commitid	slCzBfkhwAcLWsXe;

1.15
date	2016.01.17.18.57.52;	author krw;	state Exp;
branches;
next	1.14;
commitid	Rl8zxjpMi2a93hiE;

1.14
date	2016.01.17.18.44.59;	author krw;	state Exp;
branches;
next	1.13;
commitid	leFr8OHidfOIWdIJ;

1.13
date	2016.01.17.17.44.05;	author krw;	state Exp;
branches;
next	1.12;
commitid	ie6tS8cTDeRCB9yd;

1.12
date	2016.01.17.16.15.59;	author krw;	state Exp;
branches;
next	1.11;
commitid	pxt9IRDGideJOJo6;

1.11
date	2016.01.17.16.07.06;	author krw;	state Exp;
branches;
next	1.10;
commitid	MHlLpCG6jqCnA9Ts;

1.10
date	2016.01.17.15.57.12;	author krw;	state Exp;
branches;
next	1.9;
commitid	9OUrU3poCOjYi22w;

1.9
date	2016.01.17.14.28.25;	author krw;	state Exp;
branches;
next	1.8;
commitid	6tkl4uDyqk6o4dzS;

1.8
date	2016.01.16.22.28.14;	author krw;	state Exp;
branches;
next	1.7;
commitid	IIP5iNpDONoW4Jjm;

1.7
date	2016.01.15.23.05.00;	author krw;	state Exp;
branches;
next	1.6;
commitid	cXG0BedMOT1d0xiF;

1.6
date	2016.01.14.04.17.40;	author krw;	state Exp;
branches;
next	1.5;
commitid	FFi8VPodP6ImE2jX;

1.5
date	2016.01.12.15.32.08;	author krw;	state Exp;
branches;
next	1.4;
commitid	jkbr5rI0RhKaoKmr;

1.4
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.3;
commitid	DI30r1mqHPQNkhTm;

1.3
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.24.00.14.10;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.24.00.14.10;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Nuke pointless map field 'physical_block' and just use 'sbBlkSize' which is
set to the same value.
@
text
@/*	$OpenBSD: partition_map.h,v 1.41 2016/01/31 15:28:56 krw Exp $	*/

/*
 * partition_map.h - partition map routines
 *
 * Written by Eryk Vershen
 */

/*
 * Copyright 1996,1998 by Apple Computer, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef __partition_map__
#define __partition_map__

#define	BLOCK0_SIGNATURE	0x4552	/* 'ER' */
#define	DPME_SIGNATURE		0x504D	/* 'PM' */

#define	DPISTRLEN	32

struct ddmap {
    uint32_t	ddBlock;	/* 1st driver's starting sbBlkSize block */
    uint16_t	ddSize;		/* size of 1st driver (512-byte blks) */
    uint16_t	ddType;		/* system type (1 for Mac+) */
};

struct entry;

struct partition_map {
    LIST_HEAD(, entry)	disk_order;
    LIST_HEAD(, entry)	base_order;
    char	       *name;
    int			fd;
    int			changed;
    int			blocks_in_map;
    int			maximum_in_map;
    unsigned long	media_size;	/* in physical blocks */

    /* On-disk block 0 data. */
    uint16_t		sbSig;		/* "ER" */
    uint16_t		sbBlkSize;	/* physical block size of device */
    uint32_t		sbBlkCount;	/* # of physical blocks on device */
    uint16_t		sbDevType;	/* device type */
    uint16_t		sbDevId;	/* device id */
    uint32_t		sbData;		/* not used */
    uint16_t		sbDrvrCount;	/* driver descriptor count */
    struct ddmap	sbDDMap[8];	/* driver descriptor map*/
    uint8_t		sbReserved[430];
};

struct entry {
    LIST_ENTRY(entry)		disk_entry;
    LIST_ENTRY(entry)		base_entry;
    struct partition_map       *the_map;
    long			disk_address;

    /* On-disk dpme block data.*/
    uint16_t	dpme_signature;		/* "PM" */
    uint8_t	dpme_reserved_1[2];
    uint32_t	dpme_map_entries;	/* # of partition entries */
    uint32_t	dpme_pblock_start;	/* physical block start of partition */
    uint32_t	dpme_pblocks;		/* physical block count of partition */
    char	dpme_name[DPISTRLEN+1];	/* name of partition + NUL */
    char	dpme_type[DPISTRLEN+1];	/* type of partition + NUL */
    uint32_t	dpme_lblock_start;	/* logical block start of partition */
    uint32_t	dpme_lblocks;		/* logical block count of partition */
    uint32_t	dpme_flags;
#define	DPME_OS_SPECIFIC_1	(1<<8)
#define	DPME_OS_SPECIFIC_2	(1<<7)
#define	DPME_OS_PIC_CODE	(1<<6)
#define	DPME_WRITABLE		(1<<5)
#define	DPME_READABLE		(1<<4)
#define	DPME_BOOTABLE		(1<<3)
#define	DPME_IN_USE		(1<<2)
#define	DPME_ALLOCATED		(1<<1)
#define	DPME_VALID		(1<<0)
    uint32_t	dpme_boot_block;	/* logical block start of boot code */
    uint32_t	dpme_boot_bytes;	/* byte count of boot code */
    uint16_t	dpme_load_addr;		/* memory address of boot code */
    uint8_t	dpme_reserved_2[4];
    uint32_t	dpme_goto_addr;		/* memory jump address of boot code */
    uint8_t	dpme_reserved_3[4];
    uint32_t	dpme_checksum;		/* of the boot code. */
    char	dpme_processor_id[17];	/* processor type + NUL */
    uint8_t	dpme_reserved_4[376];
};

extern const char *kFreeType;
extern const char *kMapType;
extern const char *kUnixType;
extern const char *kHFSType;

extern int lflag;
extern int rflag;

struct partition_map	*create_partition_map(int, char *, uint64_t, uint32_t);
struct partition_map	*open_partition_map(int, char *, uint64_t, uint32_t);

struct entry	*find_entry_by_disk_address(long, struct partition_map *);
struct entry	*find_entry_by_type(const char *, struct partition_map *);
struct entry	*find_entry_by_base(uint32_t, struct partition_map *);

int	add_partition_to_map(const char *, const char *, uint32_t, uint32_t,
    struct partition_map *);

int	contains_driver(struct entry *);
void	free_partition_map(struct partition_map *);
void	delete_partition_from_map(struct entry *);
void	move_entry_in_map(long, long, struct partition_map *);
void	resize_map(long new_size, struct partition_map *);
void	write_partition_map(struct partition_map *);
void	dpme_init_flags(struct entry *);

#endif /* __partition_map__ */
@


1.41
log
@Just call contains_driver() when you need to know rather than carrying a
flag around. More obviously current data. Nuke unnecessary variables
when displaying a partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.40 2016/01/31 14:55:41 krw Exp $	*/
a51 1
    int			physical_block;
@


1.40
log
@Move dump_block() declaration from io.h to io.c since it is not
used anywhere else.

Remove declarations of non-existant kPatchType and init_partition_map().
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.39 2016/01/30 17:28:34 krw Exp $	*/
a73 1
    int				contains_driver;
d124 1
@


1.39
log
@Zap a couple of declarations for non-existant variable and function.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.38 2016/01/30 17:21:10 krw Exp $	*/
a110 1
extern const char *kPatchType;
a114 1
struct partition_map	*init_partition_map(char *);
@


1.38
log
@Move last three lines (#define's) from dpme.h to partition_map.h and
tweak #include's as necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.37 2016/01/30 17:09:11 krw Exp $	*/
a112 1
extern int dflag;
a132 1
void	sync_device_size(struct partition_map *);
@


1.37
log
@Fold struct dpme into struct entry. Same reasons as for folding
struct block0 into struct partition_map. Easier to read code.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.36 2016/01/29 22:51:43 krw Exp $	*/
d32 5
@


1.36
log
@Fold struct block0 into struct partition map. There can be only one
and read/write_block0() can move the data from/to disk to/from
appropriate fields anywhere. Removes a bunch of dereferencing,
malloc'ing and pointer checking.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.35 2016/01/29 15:06:37 krw Exp $	*/
a67 1
    struct dpme		       *dpme;
d70 30
a105 1
extern const char *kFreeName;
d128 1
a128 1
void	dpme_init_flags(struct dpme *);
@


1.35
log
@Shorter names means a few whitespace adjustments.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.34 2016/01/29 14:54:38 krw Exp $	*/
d33 6
a44 1
    struct block0       *block0;
d51 11
@


1.34
log
@Rename struct partition_map_header to struct partition_map. No change to
.o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.33 2016/01/29 14:48:20 krw Exp $	*/
d49 6
a54 6
    LIST_ENTRY(entry)			disk_entry;
    LIST_ENTRY(entry)			base_entry;
    struct partition_map	       *the_map;
    struct dpme			       *dpme;
    long				disk_address;
    int					contains_driver;
d69 2
a70 4
struct partition_map	*create_partition_map(int, char *, uint64_t,
    uint32_t);
struct partition_map	*open_partition_map(int, char *, uint64_t,
    uint32_t);
d72 3
a74 6
struct entry		*find_entry_by_disk_address(long,
    struct partition_map *);
struct entry		*find_entry_by_type(const char *,
    struct partition_map *);
struct entry		*find_entry_by_base(uint32_t,
    struct partition_map *);
d78 1
@


1.33
log
@Rename struct partition_map to struct entry. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.32 2016/01/28 22:09:56 krw Exp $	*/
d35 1
a35 1
struct partition_map_header {
d51 1
a51 1
    struct partition_map_header	       *the_map;
d68 2
a69 2
struct partition_map_header	*init_partition_map(char *);
struct partition_map_header	*create_partition_map(int, char *, uint64_t,
d71 1
a71 1
struct partition_map_header	*open_partition_map(int, char *, uint64_t,
d75 1
a75 1
    struct partition_map_header *);
d77 1
a77 1
    struct partition_map_header *);
d79 1
a79 1
    struct partition_map_header *);
d82 2
a83 2
    struct partition_map_header *);
void	free_partition_map(struct partition_map_header *);
d85 3
a87 3
void	move_entry_in_map(long, long, struct partition_map_header *);
void	resize_map(long new_size, struct partition_map_header *);
void	write_partition_map(struct partition_map_header *);
d89 1
a89 1
void	sync_device_size(struct partition_map_header *);
@


1.32
log
@Flip base_order to a LIST().
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.31 2016/01/28 19:07:45 krw Exp $	*/
d33 1
a33 1
struct partition_map;
d36 10
a45 10
    LIST_HEAD(, partition_map)	disk_order;
    LIST_HEAD(, partition_map)	base_order;
    char		       *name;
    struct block0	       *block0;
    int				fd;
    int				changed;
    int				physical_block;
    int				blocks_in_map;
    int				maximum_in_map;
    unsigned long		media_size;	/* in physical blocks */
d48 3
a50 3
struct partition_map {
    LIST_ENTRY(partition_map)		disk_entry;
    LIST_ENTRY(partition_map)		base_entry;
d74 1
a74 1
struct partition_map		*find_entry_by_disk_address(long,
d76 1
a76 1
struct partition_map		*find_entry_by_type(const char *,
d78 1
a78 1
struct partition_map		*find_entry_by_base(uint32_t,
d84 1
a84 1
void	delete_partition_from_map(struct partition_map *);
@


1.31
log
@Hand rolled lists suck. First, replace disk_order with an LIST.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.30 2016/01/27 14:47:53 krw Exp $	*/
d37 1
a38 1
    struct partition_map       *base_order;
d50 1
a50 2
    struct partition_map	       *next_by_base;
    struct partition_map	       *prev_by_base;
@


1.30
log
@We do not support logical_block != physical_block. Remove logical_block
field and left over code that checks for logical != physical.

Removes confusion with dmpe fields lblock_start and lblocks, which
have nothing to do with block sizes! lblock_start is the block
offset within the partition where the data actually starts. and
lblocks is the number of blocks of data within the partition. Both
are in units of *physical blocks*, a.k.a. disk sectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.29 2016/01/24 01:38:32 krw Exp $	*/
d33 2
d36 1
a37 1
    struct partition_map       *disk_order;
d49 1
a49 2
    struct partition_map	       *next_on_disk;
    struct partition_map	       *prev_on_disk;
@


1.29
log
@Whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.28 2016/01/23 23:25:58 krw Exp $	*/
d40 1
a40 2
    int				physical_block;	/* must be == sbBlockSize */
    int				logical_block;	/* must be <= physical_block */
d43 1
a43 1
    unsigned long		media_size;	/* in logical_blocks */
@


1.28
log
@Nuke unused kPatchType. Nuke kStringNot and use " not' where needed.
Nuke kStringEmpty and use "" where needed. Nuke unused static 'g'.

Eliminate #include's in *.h files.

Some whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.27 2016/01/23 15:05:52 krw Exp $	*/
d69 2
a70 3
int add_partition_to_map(const char *, const char *, uint32_t, uint32_t, struct partition_map_header *);
void free_partition_map(struct partition_map_header *);
struct partition_map_header* create_partition_map(int, char *, uint64_t,
d72 1
a72 7
void delete_partition_from_map(struct partition_map *);
struct partition_map* find_entry_by_disk_address(long, struct partition_map_header *);
struct partition_map* find_entry_by_type(const char *, struct partition_map_header *);
struct partition_map* find_entry_by_base(uint32_t, struct partition_map_header *);
struct partition_map_header* init_partition_map(char *);
void move_entry_in_map(long, long, struct partition_map_header *);
struct partition_map_header* open_partition_map(int, char *, uint64_t,
d74 17
a90 4
void resize_map(long new_size, struct partition_map_header *);
void write_partition_map(struct partition_map_header *);
void dpme_init_flags(struct dpme *);
void		sync_device_size(struct partition_map_header *);
@


1.27
log
@Pass the disk sector size to open_partition_map(), eliminating it's
internal need for DEV_BSIZE. Ditto create_partition_map().

malloc((sizeof(struct [block0|dpme])) instead of malloc(DEV_BSIZE).

Remove another #include <param.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.26 2016/01/22 18:57:42 krw Exp $	*/
a31 3

#include "dpme.h"
#include "file_media.h"
@


1.26
log
@Change partition map field 'data' to 'dmpe'. Change 'create_data'
to 'create_dmpe'. Sweep up some 'struct dpme *data' to struct dpme
*dpme'.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.25 2016/01/22 17:35:16 krw Exp $	*/
d74 2
a75 1
struct partition_map_header* create_partition_map(int, char *, uint64_t);
d82 2
a83 1
struct partition_map_header* open_partition_map(int, char *, uint64_t);
@


1.25
log
@Rename map field 'misc' to 'block0' since that's what it is.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.24 2016/01/22 17:29:37 krw Exp $	*/
d56 1
a56 1
    struct dpme			       *data;
@


1.24
log
@Whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.23 2016/01/22 04:16:25 krw Exp $	*/
d40 1
a40 1
    struct block0	       *misc;
@


1.23
log
@Repair creation of initial partition table on a blank disk, broken
when hoisting file operations and ioctl to main(). Pass media size
to open_partition_map() and create_partition_map() so they can
properly initialize a map.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.22 2016/01/22 01:25:56 krw Exp $	*/
d37 11
a47 11
    char *name;
    struct partition_map * disk_order;
    struct partition_map * base_order;
    struct block0 *misc;
    int fd;
    int changed;
    int physical_block;		/* must be == sbBlockSize */
    int logical_block;		/* must be <= physical_block */
    int blocks_in_map;
    int maximum_in_map;
    unsigned long media_size;	/* in logical_blocks */
d51 8
a58 8
    struct partition_map * next_on_disk;
    struct partition_map * prev_on_disk;
    struct partition_map * next_by_base;
    struct partition_map * prev_by_base;
    long disk_address;
    struct partition_map_header * the_map;
    int contains_driver;
    struct dpme *data;
d61 6
a66 6
extern const char * kFreeType;
extern const char * kMapType;
extern const char * kUnixType;
extern const char * kHFSType;
extern const char * kFreeName;
extern const char * kPatchType;
@


1.22
log
@In the "why use two variables when one would do" category, eliminate
the 'written' field and just use the 'changed' field to mediate
when it is appropriate to ask whether changes should be discarded.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.21 2016/01/21 15:33:21 krw Exp $	*/
d74 1
a74 1
struct partition_map_header* create_partition_map(int, char *);
d81 1
a81 1
struct partition_map_header* open_partition_map(int, char *);
@


1.21
log
@Hoist all file opening and ioctl calls into main(), passing a pointer to
a valid map to edit(). Should enable pledging a la fdisk at some point.

Since edit() always gets a valid map (and maintains its validity even when
'I'nitializing a new one) many checks for (map == NULL) are junked.

Remove some dances around block sizes by using DEV_BSIZE everywhere
since we don't support non-DEV_BSIZE (a.k.a. 512-byte) sectors.

Remove many superfluous #include statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.20 2016/01/21 02:52:52 krw Exp $	*/
a42 1
    int written;
@


1.20
log
@Nuke 'writable' field now that it is always in sync with 'rflag'. Since
(!rflag && writable == 0) can't be true remove those warning blocks and
simply leave the not-writable warning when attempting to write the
map. Always show 'w' in the help and rely on the check and warning
in do_write_partition_map() so the user always gets a message.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.19 2016/01/18 17:57:35 krw Exp $	*/
d69 2
a71 1
extern int dflag;
d74 2
a75 2
void close_partition_map(struct partition_map_header *);
struct partition_map_header* create_partition_map(char *, struct partition_map_header *);
d80 1
a80 1
struct partition_map_header* init_partition_map(char *, struct partition_map_header *);
d82 1
a82 1
struct partition_map_header* open_partition_map(char *, int *);
d86 1
@


1.19
log
@struct file_media had 1 field left. And one place where struct
file_media was actually stored. So move the last field (fd) into
the place formerly used to store pointer to the instance. As a
result we can just pass fd's around rather than pointers to a struct
containing a fd.

close_file_media() becomes empty but for a close(). So just use
close() and nuke close_file_media().
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.18 2016/01/18 00:04:36 krw Exp $	*/
a41 1
    int writable;
@


1.18
log
@Remove a grab bag of unused #define's, fields, enum's, variables,
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.17 2016/01/17 23:18:19 krw Exp $	*/
a36 1
    struct file_media *m;
d41 1
@


1.17
log
@Change "//" comments to "/**/". Nuke really stupid ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.16 2016/01/17 19:39:20 krw Exp $	*/
a60 9
    int HFS_kind;
};

/* Identifies the HFS kind. */
enum {
    kHFS_not       =   0,	/* ' ' */
    kHFS_std       =   1,	/* 'h' */
    kHFS_embed     =   2,	/* 'e' */
    kHFS_plus      =   3	/* '+' */
@


1.16
log
@Reduce namespace pollution by eliminating parameter names from forward
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.15 2016/01/17 18:57:52 krw Exp $	*/
d3 5
a7 5
//
// partition_map.h - partition map routines
//
// Written by Eryk Vershen
//
d45 2
a46 2
    int physical_block;		// must be == sbBlockSize
    int logical_block;		// must be <= physical_block
d49 1
a49 1
    unsigned long media_size;	// in logical_blocks
d66 4
a69 4
    kHFS_not       =   0,	// ' '
    kHFS_std       =   1,	// 'h'
    kHFS_embed     =   2,	// 'e'
    kHFS_plus      =   3	// '+'
@


1.15
log
@Remove a bunch of ridiculous and uninformative comments like "// Defines".
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.14 2016/01/17 18:44:59 krw Exp $	*/
d82 4
a85 4
int add_partition_to_map(const char *name, const char *dptype, uint32_t base, uint32_t length, struct partition_map_header *map);
void close_partition_map(struct partition_map_header *map);
struct partition_map_header* create_partition_map(char *name, struct partition_map_header *oldmap);
void delete_partition_from_map(struct partition_map *entry);
d87 3
a89 3
struct partition_map* find_entry_by_type(const char *type_name, struct partition_map_header *map);
struct partition_map* find_entry_by_base(uint32_t base, struct partition_map_header *map);
struct partition_map_header* init_partition_map(char *name, struct partition_map_header* oldmap);
d91 4
a94 4
struct partition_map_header* open_partition_map(char *name, int *valid_file);
void resize_map(long new_size, struct partition_map_header *map);
void write_partition_map(struct partition_map_header *map);
void dpme_init_flags(struct dpme *data);
@


1.14
log
@The great de-typedef'ification concludes with u32 -> uint32_t. And a
bunch of consequent printf() format corrections.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.13 2016/01/17 17:44:05 krw Exp $	*/
a35 9

//
// Defines
//


//
// Types
//
a71 4

//
// Global Constants
//
a78 4

//
// Global Variables
//
a81 4

//
// Forward declarations
//
@


1.13
log
@The great de-typedef'ification continues.

partition_map -> struct partition_map
partition_map_header -> struct partition_map_header
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.12 2016/01/17 16:15:59 krw Exp $	*/
d103 1
a103 1
int add_partition_to_map(const char *name, const char *dptype, u32 base, u32 length, struct partition_map_header *map);
d109 1
a109 1
struct partition_map* find_entry_by_base(u32 base, struct partition_map_header *map);
@


1.12
log
@The great de-typedef'ification continues. Block0 -> struct block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.11 2016/01/17 16:07:06 krw Exp $	*/
a59 1
typedef struct partition_map_header partition_map_header;
a71 1
typedef struct partition_map partition_map;
d103 12
a114 12
int add_partition_to_map(const char *name, const char *dptype, u32 base, u32 length, partition_map_header *map);
void close_partition_map(partition_map_header *map);
partition_map_header* create_partition_map(char *name, partition_map_header *oldmap);
void delete_partition_from_map(partition_map *entry);
partition_map* find_entry_by_disk_address(long, partition_map_header *);
partition_map* find_entry_by_type(const char *type_name, partition_map_header *map);
partition_map* find_entry_by_base(u32 base, partition_map_header *map);
partition_map_header* init_partition_map(char *name, partition_map_header* oldmap);
void move_entry_in_map(long, long, partition_map_header *);
partition_map_header* open_partition_map(char *name, int *valid_file);
void resize_map(long new_size, partition_map_header *map);
void write_partition_map(partition_map_header *map);
@


1.11
log
@The great de-typedef'ification continues. DPME -> struct dpme.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.10 2016/01/17 15:57:12 krw Exp $	*/
d50 1
a50 1
    Block0 *misc;
@


1.10
log
@Let the great de-typedef'ification begin. MEDIA -> struct file_media *.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.9 2016/01/17 14:28:25 krw Exp $	*/
d70 1
a70 1
    DPME *data;
d117 1
a117 1
void dpme_init_flags(DPME *data);
@


1.9
log
@A/UX is no more, was m68k only, and we have no sentimental reasons for
keeping support.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.8 2016/01/16 22:28:14 krw Exp $	*/
d46 1
a46 1
    FILE_MEDIA m;
@


1.8
log
@Move last field (size_in_bytes) in struct media to struct file_media
and replace MEDIA with FILE_MEDIA everywhere. media.h becomes unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.7 2016/01/15 23:05:00 krw Exp $	*/
a116 1
void bzb_init_slice(BZB *bp, int slice);
@


1.7
log
@We don't need yet another alias for DEV_BSIZE. Use DEV_BSIZE and
nuke PBLOCK_SIZE and another unused #define.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.6 2016/01/14 04:17:40 krw Exp $	*/
d34 1
a34 1
#include "media.h"
d46 1
a46 1
    MEDIA m;
@


1.6
log
@Nuke 'HFS_name' field which was not referenced now other than setting
it and freeing it. Unhook hfs_misc.c from build since it now longer
contains anything being used.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.5 2016/01/12 15:32:08 krw Exp $	*/
a39 2
#define	PBLOCK_SIZE	512
#define	MAX_LINUX_MAP	15
@


1.5
log
@Retire '-i', a poorly documented interactive mode that tries to
mimic the 20th century MacOS version of pdisk more closely than the
usual interactive editor. One set of commands is enough for anyone.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.h,v 1.4 2016/01/11 07:54:07 jasper Exp $	*/
a73 1
    char *HFS_name;
@


1.4
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a101 1
extern int interactive;
d117 1
a117 1
partition_map_header* open_partition_map(char *name, int *valid_file, int ask_logical_size);
@


1.3
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@d1 2
@


1.2
log
@rm trailing whitespace
@
text
@d4 1
a4 1
// Written by Eryk Vershen (eryk@@apple.com)
d39 1
d51 1
a51 1
    int writeable;
d53 1
d71 2
d76 8
d111 1
a111 1
partition_map* find_entry_by_disk_address(long index, partition_map_header *map);
d113 1
d115 1
a115 1
void move_entry_in_map(long old_index, long index, partition_map_header *map);
d119 2
@


1.1
log
@Initial revision
@
text
@d9 17
a25 17
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
@


1.1.1.1
log
@Import of pdisk from apple, BSD licensed code. Archive dated Feb 18 1998 
This is a HFS partition editing tool.
@
text
@@
