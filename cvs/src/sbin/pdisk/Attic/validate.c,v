head	1.42;
access;
symbols
	OPENBSD_5_8:1.5.0.34
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.26
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.30
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.28
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.24
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.22
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.20
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.18
	OPENBSD_5_0:1.5.0.16
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.14
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.12
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.8
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.10
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.6
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.2.0.16
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.14
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.12
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.1.0.6
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.4
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.2
	OPENBSD_2_9_BASE:1.1.1.1
	ver1:1.1.1.1
	apple19980218:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.01.27.14.24.05;	author krw;	state dead;
branches;
next	1.41;
commitid	N63NlWqvRcEOOg36;

1.41
date	2016.01.26.16.39.00;	author krw;	state Exp;
branches;
next	1.40;
commitid	rZKRcHhLUVQAhJLw;

1.40
date	2016.01.26.16.13.09;	author krw;	state Exp;
branches;
next	1.39;
commitid	7HeB8KYaCuiLcwze;

1.39
date	2016.01.25.21.51.23;	author krw;	state Exp;
branches;
next	1.38;
commitid	0afQloq2paFkikl3;

1.38
date	2016.01.25.03.26.54;	author jsg;	state Exp;
branches;
next	1.37;
commitid	9M3iLOXUEIPEiRWU;

1.37
date	2016.01.24.01.38.32;	author krw;	state Exp;
branches;
next	1.36;
commitid	g7Azk2rL78IOOfnI;

1.36
date	2016.01.24.01.16.20;	author krw;	state Exp;
branches;
next	1.35;
commitid	jrlPB5YCTRctBIL6;

1.35
date	2016.01.23.23.25.58;	author krw;	state Exp;
branches;
next	1.34;
commitid	PPThwZCvKA3Y8sbd;

1.34
date	2016.01.23.03.46.18;	author krw;	state Exp;
branches;
next	1.33;
commitid	HhlQ6dIQMjX8YGSD;

1.33
date	2016.01.23.01.43.13;	author krw;	state Exp;
branches;
next	1.32;
commitid	KY3XjrgZevMVU8fl;

1.32
date	2016.01.22.18.57.42;	author krw;	state Exp;
branches;
next	1.31;
commitid	gbwjpDFPWC5oF67r;

1.31
date	2016.01.22.17.35.16;	author krw;	state Exp;
branches;
next	1.30;
commitid	yo0CGbxOUa4UAkDH;

1.30
date	2016.01.22.12.31.04;	author krw;	state Exp;
branches;
next	1.29;
commitid	3OQZJKas0yPP6L3H;

1.29
date	2016.01.21.15.33.21;	author krw;	state Exp;
branches;
next	1.28;
commitid	YzEQpnBPgLX85u7F;

1.28
date	2016.01.21.01.37.18;	author krw;	state Exp;
branches;
next	1.27;
commitid	ZuA5wjezizXOOPSj;

1.27
date	2016.01.18.17.57.35;	author krw;	state Exp;
branches;
next	1.26;
commitid	nIKs6pPbVKcIxae8;

1.26
date	2016.01.18.02.24.02;	author krw;	state Exp;
branches;
next	1.25;
commitid	9A7pkUsHaALVP0eQ;

1.25
date	2016.01.17.23.18.19;	author krw;	state Exp;
branches;
next	1.24;
commitid	vC4VO4mr30PnBRSq;

1.24
date	2016.01.17.19.39.20;	author krw;	state Exp;
branches;
next	1.23;
commitid	slCzBfkhwAcLWsXe;

1.23
date	2016.01.17.19.15.55;	author krw;	state Exp;
branches;
next	1.22;
commitid	mHBjhdgm2kvWAkWc;

1.22
date	2016.01.17.18.57.52;	author krw;	state Exp;
branches;
next	1.21;
commitid	Rl8zxjpMi2a93hiE;

1.21
date	2016.01.17.18.44.59;	author krw;	state Exp;
branches;
next	1.20;
commitid	leFr8OHidfOIWdIJ;

1.20
date	2016.01.17.17.44.05;	author krw;	state Exp;
branches;
next	1.19;
commitid	ie6tS8cTDeRCB9yd;

1.19
date	2016.01.17.16.51.33;	author krw;	state Exp;
branches;
next	1.18;
commitid	cAi71iQezkoqrwuw;

1.18
date	2016.01.17.16.15.59;	author krw;	state Exp;
branches;
next	1.17;
commitid	pxt9IRDGideJOJo6;

1.17
date	2016.01.17.16.07.06;	author krw;	state Exp;
branches;
next	1.16;
commitid	MHlLpCG6jqCnA9Ts;

1.16
date	2016.01.17.15.57.12;	author krw;	state Exp;
branches;
next	1.15;
commitid	9OUrU3poCOjYi22w;

1.15
date	2016.01.16.22.28.14;	author krw;	state Exp;
branches;
next	1.14;
commitid	IIP5iNpDONoW4Jjm;

1.14
date	2016.01.16.21.41.41;	author krw;	state Exp;
branches;
next	1.13;
commitid	N0CsQGsGtplNR8ev;

1.13
date	2016.01.16.20.00.50;	author krw;	state Exp;
branches;
next	1.12;
commitid	2koPB3ak72axl95m;

1.12
date	2016.01.16.14.49.28;	author krw;	state Exp;
branches;
next	1.11;
commitid	tickLY4AeBovASt0;

1.11
date	2016.01.15.23.05.00;	author krw;	state Exp;
branches;
next	1.10;
commitid	cXG0BedMOT1d0xiF;

1.10
date	2016.01.12.20.09.39;	author krw;	state Exp;
branches;
next	1.9;
commitid	WFEddFcNLm6A2VYQ;

1.9
date	2016.01.11.23.31.27;	author krw;	state Exp;
branches;
next	1.8;
commitid	1Gl5xh4AgZJGXuPl;

1.8
date	2016.01.11.07.57.54;	author jasper;	state Exp;
branches;
next	1.7;
commitid	HZWVhdOSzNAX4WBf;

1.7
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.6;
commitid	DI30r1mqHPQNkhTm;

1.6
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	0qPuuXwccpVXsXcV;

1.5
date	2007.12.09.23.35.22;	author chl;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.29.00.43.41;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.24.00.14.19;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.24.00.14.19;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Two more for the attic.
@
text
@/*	$OpenBSD: validate.c,v 1.41 2016/01/26 16:39:00 krw Exp $	*/

/*
 * validate.c -
 *
 * Written by Eryk Vershen
 */

/*
 * Copyright 1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#include <stdio.h>
#include <stdlib.h>

#include "dpme.h"
#include "partition_map.h"
#include "validate.h"

enum range_state {
	kUnallocated,
	kAllocated,
	kMultiplyAllocated
};

struct range_list {
	struct range_list      *next;
	struct range_list      *prev;
	enum range_state	state;
	int			valid;
	uint32_t		start;
	uint32_t		end;
};

struct range_list *new_range_list_item(enum range_state state, int, uint32_t,
    uint32_t);

void	initialize_list(struct range_list **);
void	add_range(struct range_list **, uint32_t, uint32_t, int);
void	print_range_list(struct range_list *);
void	coalesce_list(struct range_list *);

struct range_list *
new_range_list_item(enum range_state state, int valid, uint32_t low,
    uint32_t high)
{
	struct range_list *item;

	item = malloc(sizeof(struct range_list));
	item->next = 0;
	item->prev = 0;
	item->state = state;
	item->valid = valid;
	item->start = low;
	item->end = high;
	return item;
}


void
initialize_list(struct range_list **list)
{
	struct range_list *item;

	item = new_range_list_item(kUnallocated, 0, 0, 0xFFFFFFFF);
	*list = item;
}


void
add_range(struct range_list **list, uint32_t base, uint32_t len, int allocate)
{
	struct range_list *item, *cur;
	uint32_t low, high;

	/* XXX initialized list will always have one element */
	if (list == NULL || *list == NULL)
		return;
	low = base;
	high = base + len - 1;
	/* XXX wrapped around */
	if (len == 0 || high < len - 1)
		return;
	cur = *list;
	while (low <= high) {
		if (cur == NULL)
			break;
		if (low <= cur->end) {
			if (cur->start < low) {
				item = new_range_list_item(cur->state,
				    cur->valid, cur->start, low - 1);
				/* insert before here */
				if (cur->prev == NULL) {
					item->prev = NULL;
					*list = item;
				} else {
					item->prev = cur->prev;
					item->prev->next = item;
				}
				cur->prev = item;
				item->next = cur;
				cur->start = low;
			}
			if (high < cur->end) {
				item = new_range_list_item(cur->state,
				    cur->valid, high + 1, cur->end);
				/* insert after here */
				if (cur->next == NULL) {
					item->next = NULL;
				} else {
					item->next = cur->next;
					item->next->prev = item;
				}
				cur->next = item;
				item->prev = cur;

				cur->end = high;
			}
			if (allocate) {
				switch (cur->state) {
				case kUnallocated:
					cur->state = kAllocated;
					break;
				case kAllocated:
				case kMultiplyAllocated:
					cur->state = kMultiplyAllocated;
					break;
				}
			} else {
				cur->valid = 1;
			}
			low = cur->end + 1;
		}
		cur = cur->next;
	}
}


void
coalesce_list(struct range_list *list)
{
	struct range_list *cur, *item;

	for (cur = list; cur != NULL;) {
		item = cur->next;
		if (item == NULL)
			break;
		if (cur->valid == item->valid &&
		    cur->state == item->state) {
			cur->end = item->end;
			cur->next = item->next;
			if (item->next != NULL)
				item->next->prev = cur;
			free(item);
		} else {
			cur = cur->next;
		}
	}
}


void
print_range_list(struct range_list *list)
{
	struct range_list *cur;
	const char *s = NULL;
	int printed;

	if (list == NULL) {
		printf("Empty range list\n");
		return;
	}
	printf("Range list:\n");
	printed = 0;
	for (cur = list; cur != NULL; cur = cur->next) {
		if (cur->valid) {
			switch (cur->state) {
			case kUnallocated:
				s = "unallocated";
				break;
			case kAllocated:
				continue;
			case kMultiplyAllocated:
				s = "multiply allocated";
				break;
			}
			printed = 1;
			printf("\t%u:%u %s\n", cur->start, cur->end, s);
		} else {
			switch (cur->state) {
			case kUnallocated:
				continue;
			case kAllocated:
				s = "allocated";
				break;
			case kMultiplyAllocated:
				s = "multiply allocated";
				break;
			}
			printed = 1;
			printf("\t%u:%u out of range, but %s\n", cur->start,
			    cur->end, s);
		}
	}
	if (printed == 0)
		printf("\tokay\n");
}


void
validate_map(struct partition_map_header *map)
{
	struct partition_map *entry;
	struct range_list *list;
	struct dpme *dpme;
	int i, printed;
	uint32_t limit;

	initialize_list(&list);

	/*
         * XXX signature valid
         * XXX size & count match DeviceCapacity
         * XXX number of descriptors matches array size
         * XXX each descriptor wholly contained in a partition
         * XXX the range below here is in physical blocks but the map is
         *     in logical blocks!!!
         */

	/* subtract one since args are base & len */
	add_range(&list, 1, map->block0->sbBlkCount - 1, 0);

	limit = map->blocks_in_map;
	if (limit < 1) {
		printf("No blocks in map.\n");
		return;
	}

	/* for each entry */
	for (i = 1; i <= limit; i++) {
		printf("block %d:\n", i);

		/* get entry */
		entry = find_entry_by_disk_address(i, map);
		if (entry != NULL)
			dpme = entry->dpme;
		else {
			printf("\tunable to get\n");
			goto post_processing;
		}
		printed = 0;

		/* signature matches */
		if (dpme->dpme_signature != DPME_SIGNATURE) {
			printed = 1;
			printf("\tsignature is 0x%x, should be 0x%x\n",
			    dpme->dpme_signature, DPME_SIGNATURE);
		}
		/* entry count matches */
		if (dpme->dpme_map_entries != limit) {
			printed = 1;
			printf("\tentry count is 0x%x, should be %u\n",
			    dpme->dpme_map_entries, limit);
		}
		/* lblocks contained within physical */
		if (dpme->dpme_lblock_start >= dpme->dpme_pblocks ||
		    dpme->dpme_lblocks > dpme->dpme_pblocks -
		    dpme->dpme_lblock_start) {
			printed = 1;
			printf("\tlogical blocks (%u for %u) not within "
			    "physical size (%u)\n", dpme->dpme_lblock_start,
			    dpme->dpme_lblocks, dpme->dpme_pblocks);
		}
		/* remember stuff for post processing */
		add_range(&list, dpme->dpme_pblock_start, dpme->dpme_pblocks,
		    1);

		/*
		 * XXX type is known type?
		 * XXX no unknown flags?
		 * XXX boot blocks either within or outside of logical
		 * XXX checksum matches contents
		 * XXX other fields zero if boot_bytes  is zero
		 * XXX processor id is known value?
		 * XXX no data in reserved3
		 */
		if (printed == 0)
			printf("\tokay\n");
	}

post_processing:
	/* properties of whole map */

	/* every block on disk in one & only one partition */
	coalesce_list(list);
	print_range_list(list);
	/* there is a partition for the map */
	/* map fits within partition that contains it */

	/* try to detect 512/2048 mixed partition map? */
}
@


1.41
log
@Whitespace, line wrapping fixes. Nuke many superfluous '{}' around single
statements. 0 -> NULL for pointer checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.40 2016/01/26 16:13:09 krw Exp $	*/
@


1.40
log
@Whitespace, line wrapping fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.39 2016/01/25 21:51:23 krw Exp $	*/
d94 2
a95 2
	if (list == 0 || *list == 0) {
		/* XXX initialized list will always have one element */
a96 1
	}
d99 2
a100 2
	if (len == 0 || high < len - 1) {
		/* XXX wrapped around */
a101 1
	}
d104 1
a104 2
		if (cur == 0) {
			/* XXX should never occur */
a105 1
		}
d111 2
a112 2
				if (cur->prev == 0) {
					item->prev = 0;
d126 2
a127 2
				if (cur->next == 0) {
					item->next = 0;
d162 1
a162 1
	for (cur = list; cur != 0;) {
d164 1
a164 1
		if (item == 0) {
a165 1
		}
d170 1
a170 1
			if (item->next != 0) {
a171 1
			}
d193 1
a193 1
	for (cur = list; cur != 0; cur = cur->next) {
d223 1
a223 1
	if (printed == 0) {
a224 1
	}
d263 1
a263 1
		if (entry != 0)
d305 1
a305 1
		if (printed == 0) {
a306 1
		}
@


1.39
log
@Tweak fields in struct dpme to be more consistent with Apple's info.

Better comments, make all reserved fields uint8_t arrays, don't
claim uint32_t fields are actually pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.38 2016/01/25 03:26:54 jsg Exp $	*/
d62 2
a63 1
new_range_list_item(enum range_state state, int valid, uint32_t low, uint32_t high)
a123 1

d171 2
a172 2
		if (cur->valid == item->valid
		    && cur->state == item->state) {
@


1.38
log
@remove some uneeded includes
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.37 2016/01/24 01:38:32 krw Exp $	*/
a282 6
		}
		/* reserved1 == 0 */
		if (dpme->dpme_reserved_1 != 0) {
			printed = 1;
			printf("\treserved word is 0x%x, should be 0\n",
			    dpme->dpme_reserved_1);
@


1.37
log
@Whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.36 2016/01/24 01:16:20 krw Exp $	*/
a36 3
#include "convert.h"
#include "io.h"
#include "file_media.h"
@


1.36
log
@Assuming the map is always provided simplifies a bunch of logic, nukes
get_block_n() and removes a whack of pointless static variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.35 2016/01/23 23:25:58 krw Exp $	*/
d81 1
a81 1
initialize_list(struct range_list ** list)
d165 1
a165 1
coalesce_list(struct range_list * list)
d190 1
a190 1
print_range_list(struct range_list * list)
d239 1
a239 1
validate_map(struct partition_map_header * map)
@


1.35
log
@Nuke unused kPatchType. Nuke kStringNot and use " not' where needed.
Nuke kStringEmpty and use "" where needed. Nuke unused static 'g'.

Eliminate #include's in *.h files.

Some whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.34 2016/01/23 03:46:18 krw Exp $	*/
d56 2
a57 38
static struct partition_map_header     *the_map;
static struct block0		       *b0;
static struct dpme		       *mb;
static char			       *buffer;
static int				the_fd;

int		get_block_n(int);
struct range_list *new_range_list_item(enum range_state state, int, uint32_t, uint32_t);
void		initialize_list(struct range_list **);
void		add_range(struct range_list **, uint32_t, uint32_t, int);
void		print_range_list(struct range_list *);
void		coalesce_list(struct range_list *);

int
get_block_n(int n)
{
	struct partition_map *entry;
	int rtn_value;

	if (the_map != NULL) {
		entry = find_entry_by_disk_address(n, the_map);
		if (entry != 0) {
			mb = entry->dpme;
			rtn_value = 1;
		} else {
			rtn_value = 0;
		}
	} else {
		if (read_block(the_fd, n, buffer) == 0) {
			rtn_value = 0;
		} else {
			mb = (struct dpme *) buffer;
			convert_dpme(mb, 1);
			rtn_value = 1;
		}
	}
	return rtn_value;
}
d59 4
d91 1
a91 1
add_range(struct range_list ** list, uint32_t base, uint32_t len, int allocate)
d196 1
a196 1
	if (list == 0) {
d241 1
d243 1
a246 2
	the_map = map;

a248 2
	b0 = map->block0;

d257 8
a264 18
	add_range(&list, 1, b0->sbBlkCount - 1, 0);	/* subtract one since
							 * args are base & len
							 */

	/* compute size of map */
	if (map != NULL) {
		limit = the_map->blocks_in_map;
	} else {
		if (get_block_n(1) == 0) {
			printf("unable to get first block\n");
			return;
		} else {
			if (mb->dpme_signature != DPME_SIGNATURE) {
				limit = -1;
			} else {
				limit = mb->dpme_map_entries;
			}
		}
d268 1
a268 9
	for (i = 1;; i++) {
		if (limit < 0) {
			/* XXX what to use for end of list? */
			if (i > 5) {
				break;
			}
		} else if (i > limit) {
			break;
		}
d272 4
a275 1
		if (get_block_n(i) == 0) {
d282 1
a282 1
		if (mb->dpme_signature != DPME_SIGNATURE) {
d285 1
a285 1
			    mb->dpme_signature, DPME_SIGNATURE);
d288 1
a288 1
		if (mb->dpme_reserved_1 != 0) {
d291 1
a291 1
			    mb->dpme_reserved_1);
d294 1
a294 5
		if (limit < 0) {
			printed = 1;
			printf("\tentry count is 0x%x, real value unknown\n",
			    mb->dpme_map_entries);
		} else if (mb->dpme_map_entries != limit) {
d297 1
a297 1
			    mb->dpme_map_entries, limit);
d300 3
a302 3
		if (mb->dpme_lblock_start >= mb->dpme_pblocks
		    || mb->dpme_lblocks > mb->dpme_pblocks -
		    mb->dpme_lblock_start) {
d305 2
a306 2
			    "physical size (%u)\n", mb->dpme_lblock_start,
			    mb->dpme_lblocks, mb->dpme_pblocks);
d309 2
a310 1
		add_range(&list, mb->dpme_pblock_start, mb->dpme_pblocks, 1);
@


1.34
log
@Flip read_block() and write_block() back to taking sector addresses
instead of off_t values. Do the DEV_BSIZE multiplication in these two
functions.

Easier to read code and kills two #include <sys/param.h>.

Kill unused label.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.33 2016/01/23 01:43:13 krw Exp $	*/
d34 2
d48 6
a53 6
	struct range_list *next;
	struct range_list *prev;
	enum range_state state;
	int		valid;
	uint32_t	start;
	uint32_t	end;
d56 5
a60 6
static char    *buffer;
static struct block0 *b0;
static struct dpme *mb;
static struct partition_map_header *the_map;
static int	the_fd;
static int	g;
a277 1
	g = map->logical_block;
@


1.33
log
@map->block0 is always allocated or the map is discarded.

So stop checking for NULL. Nuke get_block_zero() and just use
map->block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.32 2016/01/22 18:57:42 krw Exp $	*/
a30 2
#include <sys/param.h>		/* DEV_BSIZE */

d83 1
a83 1
		if (read_block(the_fd, n * DEV_BSIZE, buffer) == 0) {
a294 1
check_map:
@


1.32
log
@Change partition map field 'data' to 'dmpe'. Change 'create_data'
to 'create_dmpe'. Sweep up some 'struct dpme *data' to struct dpme
*dpme'.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.31 2016/01/22 17:35:16 krw Exp $	*/
a62 1
int		get_block_zero(void);
a70 21
get_block_zero(void)
{
	int rtn_value;

	if (the_map != NULL) {
		b0 = the_map->block0;
		rtn_value = 1;
	} else {
		if (read_block(the_fd, 0, buffer) == 0) {
			rtn_value = 0;
		} else {
			b0 = (struct block0 *) buffer;
			convert_block0(b0, 1);
			rtn_value = 1;
		}
	}
	return rtn_value;
}


int
d283 2
a284 4
	if (get_block_zero() == 0) {
		printf("unable to read block 0\n");
		goto check_map;
	}
@


1.31
log
@Rename map field 'misc' to 'block0' since that's what it is.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.30 2016/01/22 12:31:04 krw Exp $	*/
d101 1
a101 1
			mb = entry->data;
@


1.30
log
@Merge read_block() and read_file_media() into read_block(). Ditto
write_block() and write_file_media(). One layer of read/write
wrappers for pread/pwrite should be enough for anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.29 2016/01/21 15:33:21 krw Exp $	*/
d77 1
a77 1
		b0 = the_map->misc;
@


1.29
log
@Hoist all file opening and ioctl calls into main(), passing a pointer to
a valid map to edit(). Should enable pledging a la fdisk at some point.

Since edit() always gets a valid map (and maintains its validity even when
'I'nitializing a new one) many checks for (map == NULL) are junked.

Remove some dances around block sizes by using DEV_BSIZE everywhere
since we don't support non-DEV_BSIZE (a.k.a. 512-byte) sectors.

Remove many superfluous #include statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.28 2016/01/21 01:37:18 krw Exp $	*/
d80 1
a80 2
		if (read_file_media(the_fd, (long long) 0, DEV_BSIZE,
		    buffer) == 0) {
d107 1
a107 1
		if (read_file_media(the_fd, ((long long) n) * g, DEV_BSIZE, (void *) buffer) == 0) {
@


1.28
log
@Don't try to be cute by silently opening a disk read-only when R/W
access was requested. Just complain when the R/W open fails. Make
failure messages consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.27 2016/01/18 17:57:35 krw Exp $	*/
a32 2
#include <err.h>

a34 3
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
a297 1
	char *name;
d301 2
a302 24
	if (map == NULL) {
		the_map = NULL;
		if (get_string_argument("Name of device: ", &name, 1) == 0) {
			bad_input("Bad name");
			return;
		}
		the_fd = open_file_as_media(name, O_RDONLY);
		if (the_fd == -1) {
			warn("can't open file '%s' for reading", name);
			free(name);
			return;
		}
		g = DEV_BSIZE;

		buffer = malloc(DEV_BSIZE);
		if (buffer == NULL) {
			warn("can't allocate memory for disk buffer");
			goto done;
		}
	} else {
		name = 0;
		the_map = map;
		g = map->logical_block;
	}
d329 1
a329 1
			goto done;
a415 7

done:
	if (map == NULL) {
		close(the_fd);
		free(buffer);
		free(name);
	}
@


1.27
log
@struct file_media had 1 field left. And one place where struct
file_media was actually stored. So move the last field (fd) into
the place formerly used to store pointer to the instance. As a
result we can just pass fd's around rather than pointers to a struct
containing a fd.

close_file_media() becomes empty but for a close(). So just use
close() and nuke close_file_media().
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.26 2016/01/18 02:24:02 krw Exp $	*/
d315 1
a315 1
			warn("can't open file '%s'", name);
@


1.26
log
@Run indent(1) over it and tweak the results a bit manually to look more
KNF'ish.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.25 2016/01/17 23:18:19 krw Exp $	*/
d39 1
d65 1
a65 1
static struct file_media *the_media;
d85 1
a85 1
		if (read_file_media(the_media, (long long) 0, DEV_BSIZE,
d113 1
a113 1
		if (read_file_media(the_media, ((long long) n) * g, DEV_BSIZE, (void *) buffer) == 0) {
d308 1
a308 1
		the_map = 0;
d313 2
a314 2
		the_media = open_file_as_media(name, O_RDONLY);
		if (the_media == 0) {
d447 1
a447 1
		close_file_media(the_media);
@


1.25
log
@Change "//" comments to "/**/". Nuke really stupid ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.24 2016/01/17 19:39:20 krw Exp $	*/
d31 1
a31 1
#include <sys/param.h>	/* DEV_BSIZE */
d46 3
a48 3
    kUnallocated,
    kAllocated,
    kMultiplyAllocated
d52 6
a57 6
    struct range_list *next;
    struct range_list *prev;
    enum range_state state;
    int valid;
    uint32_t start;
    uint32_t end;
d60 1
a60 1
static char *buffer;
d65 1
a65 1
static int g;
d67 2
a68 2
int get_block_zero(void);
int get_block_n(int);
d70 4
a73 4
void initialize_list(struct range_list **);
void add_range(struct range_list **, uint32_t, uint32_t, int);
void print_range_list(struct range_list *);
void coalesce_list(struct range_list *);
d78 1
a78 1
    int rtn_value;
d80 3
a82 6
    if (the_map != NULL) {
	b0 = the_map->misc;
	rtn_value = 1;
    } else {
	if (read_file_media(the_media, (long long) 0, DEV_BSIZE, buffer) == 0) {
	    rtn_value = 0;
d84 8
a91 3
	    b0 = (struct block0 *) buffer;
	    convert_block0(b0, 1);
	    rtn_value = 1;
d93 1
a93 2
    }
    return rtn_value;
d100 2
a101 2
    struct partition_map * entry;
    int rtn_value;
d103 8
a110 5
    if (the_map != NULL) {
	entry = find_entry_by_disk_address(n, the_map);
	if (entry != 0) {
	    mb = entry->data;
	    rtn_value = 1;
d112 7
a118 1
	    rtn_value = 0;
d120 1
a120 10
    } else {
	if (read_file_media(the_media, ((long long) n) * g, DEV_BSIZE, (void *)buffer) == 0) {
	    rtn_value = 0;
	} else {
	    mb = (struct dpme *) buffer;
	    convert_dpme(mb, 1);
	    rtn_value = 1;
	}
    }
    return rtn_value;
d127 1
a127 1
    struct range_list *item;
d129 8
a136 8
    item = malloc(sizeof(struct range_list));
    item->next = 0;
    item->prev = 0;
    item->state = state;
    item->valid = valid;
    item->start = low;
    item->end = high;
    return item;
d141 1
a141 1
initialize_list(struct range_list **list)
d143 1
a143 1
    struct range_list *item;
d145 2
a146 2
    item = new_range_list_item(kUnallocated, 0, 0, 0xFFFFFFFF);
    *list = item;
d151 1
a151 1
add_range(struct range_list **list, uint32_t base, uint32_t len, int allocate)
d153 18
a170 33
    struct range_list *item;
    struct range_list *cur;
    uint32_t low;
    uint32_t high;

    if (list == 0 || *list == 0) {
	/* XXX initialized list will always have one element */
	return;
    }

    low = base;
    high = base + len - 1;
    if (len == 0 || high < len - 1) {
	/* XXX wrapped around */
	return;
    }

    cur = *list;
    while (low <= high) {
	if (cur == 0) {
	    /* XXX should never occur */
	    break;
	}
	if (low <= cur->end) {
	    if (cur->start < low) {
		item = new_range_list_item(cur->state, cur->valid, cur->start, low-1);
		/* insert before here */
		if (cur->prev == 0) {
		    item->prev = 0;
		    *list = item;
		} else {
		    item->prev = cur->prev;
		    item->prev->next = item;
d172 46
a217 13
		cur->prev = item;
		item->next = cur;

		cur->start = low;
	    }
	    if (high < cur->end) {
		item = new_range_list_item(cur->state, cur->valid, high+1, cur->end);
		/* insert after here */
		if (cur->next == 0) {
		    item->next = 0;
		} else {
		    item->next = cur->next;
		    item->next->prev = item;
d219 1
a219 20
		cur->next = item;
		item->prev = cur;

		cur->end = high;
	    }

	    if (allocate) {
		switch (cur->state) {
		case kUnallocated:
		    cur->state = kAllocated;
		    break;
		case kAllocated:
		case kMultiplyAllocated:
		    cur->state = kMultiplyAllocated;
		    break;
		}
	    } else {
		cur->valid = 1;
	    }
	    low = cur->end + 1;
a220 2
	cur = cur->next;
    }
d225 1
a225 1
coalesce_list(struct range_list *list)
d227 1
a227 2
    struct range_list *cur;
    struct range_list *item;
d229 16
a244 15
    for (cur = list; cur != 0; ) {
	item = cur->next;
	if (item == 0) {
	    break;
	}
	if (cur->valid == item->valid
		&& cur->state == item->state) {
	    cur->end = item->end;
	    cur->next = item->next;
	    if (item->next != 0) {
		item->next->prev = cur;
	    }
	    free(item);
	} else {
	    cur = cur->next;
a245 1
    }
d250 1
a250 1
print_range_list(struct range_list *list)
d252 43
a294 42
    struct range_list *cur;
    int printed;
    const char *s = NULL;

    if (list == 0) {
	printf("Empty range list\n");
	return;
    }
    printf("Range list:\n");
    printed = 0;
    for (cur = list; cur != 0; cur = cur->next) {
	if (cur->valid) {
	    switch (cur->state) {
	    case kUnallocated:
		s = "unallocated";
		break;
	    case kAllocated:
		continue;
	    case kMultiplyAllocated:
		s = "multiply allocated";
		break;
	    }
	    printed = 1;
	    printf("\t%u:%u %s\n", cur->start, cur->end, s);
	} else {
	    switch (cur->state) {
	    case kUnallocated:
		continue;
	    case kAllocated:
		s = "allocated";
		break;
	    case kMultiplyAllocated:
		s = "multiply allocated";
		break;
	    }
	    printed = 1;
	    printf("\t%u:%u out of range, but %s\n", cur->start, cur->end, s);
	}
    }
    if (printed == 0) {
	printf("\tokay\n");
    }
d299 1
a299 1
validate_map(struct partition_map_header *map)
d301 47
a347 47
    struct range_list *list;
    char *name;
    int i;
    uint32_t limit;
    int printed;

    if (map == NULL) {
	the_map = 0;
	if (get_string_argument("Name of device: ", &name, 1) == 0) {
	    bad_input("Bad name");
	    return;
	}
	the_media = open_file_as_media(name, O_RDONLY);
	if (the_media == 0) {
	    warn("can't open file '%s'", name);
	    free(name);
	    return;
	}
	g = DEV_BSIZE;

	buffer = malloc(DEV_BSIZE);
	if (buffer == NULL) {
	    warn("can't allocate memory for disk buffer");
	    goto done;
	}

    } else {
	name = 0;
	the_map = map;
	g = map->logical_block;
    }

    initialize_list(&list);

    if (get_block_zero() == 0) {
	printf("unable to read block 0\n");
	goto check_map;
    }
    /*
     * XXX signature valid
     * XXX size & count match DeviceCapacity
     * XXX number of descriptors matches array size
     * XXX each descriptor wholly contained in a partition
     * XXX the range below here is in physical blocks but the map is
     *     in logical blocks!!!
     */
    add_range(&list, 1, b0->sbBlkCount-1, 0);	/* subtract one since args are base & len */
d350 3
a352 7
    /* compute size of map */
    if (map != NULL) {
	limit = the_map->blocks_in_map;
    } else {
	if (get_block_n(1) == 0) {
	    printf("unable to get first block\n");
	    goto done;
d354 10
a363 25
	    if (mb->dpme_signature != DPME_SIGNATURE) {
	        limit = -1;
	    } else {
		limit = mb->dpme_map_entries;
	    }
	}
    }

    /* for each entry */
    for (i = 1; ; i++) {
	if (limit < 0) {
	    /* XXX what to use for end of list? */
	    if (i > 5) {
		break;
	    }
	} else if (i > limit) {
	    break;
	}

	printf("block %d:\n", i);

	/* get entry */
	if (get_block_n(i) == 0) {
	    printf("\tunable to get\n");
	    goto post_processing;
a364 1
	printed = 0;
d366 52
a417 27
	/* signature matches */
	if (mb->dpme_signature != DPME_SIGNATURE) {
	    printed = 1;
	    printf("\tsignature is 0x%x, should be 0x%x\n", mb->dpme_signature, DPME_SIGNATURE);
	}
	/* reserved1 == 0 */
	if (mb->dpme_reserved_1 != 0) {
	    printed = 1;
	    printf("\treserved word is 0x%x, should be 0\n", mb->dpme_reserved_1);
	}
	/* entry count matches */
	if (limit < 0) {
	    printed = 1;
	    printf("\tentry count is 0x%x, real value unknown\n", mb->dpme_map_entries);
	} else if (mb->dpme_map_entries != limit) {
	    printed = 1;
	    printf("\tentry count is 0x%x, should be %u\n", mb->dpme_map_entries, limit);
	}
	/* lblocks contained within physical */
	if (mb->dpme_lblock_start >= mb->dpme_pblocks
		|| mb->dpme_lblocks > mb->dpme_pblocks - mb->dpme_lblock_start) {
	    printed = 1;
	    printf("\tlogical blocks (%u for %u) not within physical size (%u)\n",
		    mb->dpme_lblock_start, mb->dpme_lblocks, mb->dpme_pblocks);
	}
	/* remember stuff for post processing */
	add_range(&list, mb->dpme_pblock_start, mb->dpme_pblocks, 1);
d419 12
a430 11
	/*
	 * XXX type is known type?
	 * XXX no unknown flags?
	 * XXX boot blocks either within or outside of logical
	 * XXX checksum matches contents
	 * XXX other fields zero if boot_bytes  is zero
	 * XXX processor id is known value?
	 * XXX no data in reserved3
	 */
	if (printed == 0) {
	    printf("\tokay\n");
a431 1
    }
d434 1
a434 1
    /* properties of whole map */
d436 5
a440 5
    /* every block on disk in one & only one partition */
    coalesce_list(list);
    print_range_list(list);
    /* there is a partition for the map */
    /* map fits within partition that contains it */
d442 1
a442 1
    /* try to detect 512/2048 mixed partition map? */
d445 5
a449 5
    if (map == NULL) {
	close_file_media(the_media);
	free(buffer);
	free(name);
    }
@


1.24
log
@Reduce namespace pollution by eliminating parameter names from forward
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.23 2016/01/17 19:15:55 krw Exp $	*/
d3 5
a7 5
//
// validate.c -
//
// Written by Eryk Vershen
//
a272 2
		//s = "allocated";
		//break;
a282 2
		//s = "unallocated";
		//break;
a308 2
    //printf("Validation not implemented yet.\n");

a336 1
    // get block 0
d341 8
a348 5
    // XXX signature valid
    // XXX size & count match DeviceCapacity
    // XXX number of descriptors matches array size
    // XXX each descriptor wholly contained in a partition
    // XXX the range below here is in physical blocks but the map is in logical blocks!!!
d352 1
a352 1
    // compute size of map
d368 1
a368 1
    // for each entry
d381 1
a381 1
	// get entry
d388 1
a388 1
	// signature matches
d393 1
a393 1
	// reserved1 == 0
d398 1
a398 1
	// entry count matches
d406 1
a406 1
	// lblocks contained within physical
d413 1
a413 1
	// remember stuff for post processing
d416 9
a424 7
	// XXX type is known type?
	// XXX no unknown flags?
	// XXX boot blocks either within or outside of logical
	// XXX checksum matches contents
	// XXX other fields zero if boot_bytes  is zero
	// XXX processor id is known value?
	// XXX no data in reserved3
d431 1
a431 1
    // properties of whole map
d433 1
a433 1
    // every block on disk in one & only one partition
d436 2
a437 2
    // there is a partition for the map
    // map fits within partition that contains it
d439 1
a439 1
    // try to detect 512/2048 mixed partition map?
@


1.23
log
@Kill leading, imbedded, trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.22 2016/01/17 18:57:52 krw Exp $	*/
d68 6
a73 6
int get_block_n(int n);
struct range_list *new_range_list_item(enum range_state state, int valid, uint32_t low, uint32_t high);
void initialize_list(struct range_list **list);
void add_range(struct range_list **list, uint32_t base, uint32_t len, int allocate);
void print_range_list(struct range_list *list);
void coalesce_list(struct range_list *list);
@


1.22
log
@Remove a bunch of ridiculous and uninformative comments like "// Defines".
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.21 2016/01/17 18:44:59 krw Exp $	*/
d158 2
a159 2
    	/* XXX initialized list will always have one element */
    	return;
d316 1
a316 1
    	the_map = 0;
d336 1
a336 1
    	name = 0;
d377 1
a377 1
	    	break;
@


1.21
log
@The great de-typedef'ification concludes with u32 -> uint32_t. And a
bunch of consequent printf() format corrections.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.20 2016/01/17 17:44:05 krw Exp $	*/
a34 1
// for *printf()
a35 1
// for malloc(), free()
a36 1
// for O_RDONLY
a37 1
// for errno
a44 9

//
// Defines
//


//
// Types
//
a59 9

//
// Global Constants
//


//
// Global Variables
//
a66 4

//
// Forward declarations
//
a74 4

//
// Routines
//
@


1.20
log
@The great de-typedef'ification continues.

partition_map -> struct partition_map
partition_map_header -> struct partition_map_header
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.19 2016/01/17 16:51:33 krw Exp $	*/
d69 2
a70 2
    u32 start;
    u32 end;
d95 1
a95 1
struct range_list *new_range_list_item(enum range_state state, int valid, u32 low, u32 high);
d97 1
a97 1
void add_range(struct range_list **list, u32 base, u32 len, int allocate);
d154 1
a154 1
new_range_list_item(enum range_state state, int valid, u32 low, u32 high)
d180 1
a180 1
add_range(struct range_list **list, u32 base, u32 len, int allocate)
d184 2
a185 2
    u32 low;
    u32 high;
d310 1
a310 1
	    printf("\t%lu:%lu %s\n", cur->start, cur->end, s);
d325 1
a325 1
	    printf("\t%lu:%lu out of range, but %s\n", cur->start, cur->end, s);
d340 1
a340 1
    u32 limit;
d435 1
a435 1
	    printf("\tentry count is 0x%lx, real value unknown\n", mb->dpme_map_entries);
d438 1
a438 1
	    printf("\tentry count is 0x%lx, should be %ld\n", mb->dpme_map_entries, limit);
d444 1
a444 1
	    printf("\tlogical blocks (%ld for %ld) not within physical size (%ld)\n",
@


1.19
log
@The great de-typedef'ification continues. range_list -> struct range_list.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.18 2016/01/17 16:15:59 krw Exp $	*/
d85 1
a85 1
static partition_map_header *the_map;
d129 1
a129 1
    partition_map * entry;
d335 1
a335 1
validate_map(partition_map_header *map)
@


1.18
log
@The great de-typedef'ification continues. Block0 -> struct block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.17 2016/01/17 16:07:06 krw Exp $	*/
a71 1
typedef struct range_list range_list;
d95 5
a99 5
range_list *new_range_list_item(enum range_state state, int valid, u32 low, u32 high);
void initialize_list(range_list **list);
void add_range(range_list **list, u32 base, u32 len, int allocate);
void print_range_list(range_list *list);
void coalesce_list(range_list *list);
d153 1
a153 1
range_list *
d156 1
a156 1
    range_list *item;
d170 1
a170 1
initialize_list(range_list **list)
d172 1
a172 1
    range_list *item;
d180 1
a180 1
add_range(range_list **list, u32 base, u32 len, int allocate)
d182 2
a183 2
    range_list *item;
    range_list *cur;
d257 1
a257 1
coalesce_list(range_list *list)
d259 2
a260 2
    range_list *cur;
    range_list *item;
d283 1
a283 1
print_range_list(range_list *list)
d285 1
a285 1
    range_list *cur;
d337 1
a337 1
    range_list *list;
@


1.17
log
@The great de-typedef'ification continues. DPME -> struct dpme.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.16 2016/01/17 15:57:12 krw Exp $	*/
d84 1
a84 1
static Block0 *b0;
d118 1
a118 1
	    b0 = (Block0 *) buffer;
@


1.16
log
@Let the great de-typedef'ification begin. MEDIA -> struct file_media *.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.15 2016/01/16 22:28:14 krw Exp $	*/
d85 1
a85 1
static DPME *mb;
d145 1
a145 1
	    mb = (DPME *) buffer;
@


1.15
log
@Move last field (size_in_bytes) in struct media to struct file_media
and replace MEDIA with FILE_MEDIA everywhere. media.h becomes unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.14 2016/01/16 21:41:41 krw Exp $	*/
d87 1
a87 1
static FILE_MEDIA the_media;
@


1.14
log
@There can be only one. 'grain' that is. i.e. DEV_BSIZE. No need to track
or store. Just use.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.13 2016/01/16 20:00:50 krw Exp $	*/
d87 1
a87 1
static MEDIA the_media;
@


1.13
log
@Start peeling away excess layers of abstraction.

Since 'file' is the only kind of media, no need to call the appropriate
functions via pointers. Just call the _file_ variants directly.
Nuke the fields do_read(), do_write(), do_close(), do_os_reload()
and the functions read_media(), write_media(), close_media() and
os_reload_media().

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.12 2016/01/16 14:49:28 krw Exp $	*/
d358 1
a358 4
	g = media_granularity(the_media);
	if (g < DEV_BSIZE) {
	    g = DEV_BSIZE;
	}
@


1.12
log
@Nuke support for 1024- and 2048-byte sector devices. Error out if
anything other than 512-byte sectors are encountered. Unlink
deblock_media.c from the build.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.11 2016/01/15 23:05:00 krw Exp $	*/
d115 1
a115 1
	if (read_media(the_media, (long long) 0, DEV_BSIZE, buffer) == 0) {
d142 1
a142 1
	if (read_media(the_media, ((long long) n) * g, DEV_BSIZE, (void *)buffer) == 0) {
d479 1
a479 1
	close_media(the_media);
@


1.11
log
@We don't need yet another alias for DEV_BSIZE. Use DEV_BSIZE and
nuke PBLOCK_SIZE and another unused #define.
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.10 2016/01/12 20:09:39 krw Exp $	*/
a44 1
#include "deblock_media.h"
a361 1
   	the_media = open_deblock_media(DEV_BSIZE, the_media);
@


1.10
log
@Use normal err/errx/warn/warnx rather than handrolling new ones. Move
usage() to pdisk.c and nuke do_help() and '-h'.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.9 2016/01/11 23:31:27 krw Exp $	*/
d31 2
d116 1
a116 1
	if (read_media(the_media, (long long) 0, PBLOCK_SIZE, buffer) == 0) {
d143 1
a143 1
	if (read_media(the_media, ((long long) n) * g, PBLOCK_SIZE, (void *)buffer) == 0) {
d360 2
a361 2
	if (g < PBLOCK_SIZE) {
	    g = PBLOCK_SIZE;
d363 1
a363 1
   	the_media = open_deblock_media(PBLOCK_SIZE, the_media);
d365 1
a365 1
	buffer = malloc(PBLOCK_SIZE);
@


1.9
log
@open_pathname_as_media() simply called open_file_as_media() which
takes the same parameters and returns the same value. Nuke
open_pathname_as_media() and call open_file_as_media() directly.

Nothing else from pathname.[ch] is used so remove them from build
in preparation for moving them to the attic.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.8 2016/01/11 07:57:54 jasper Exp $	*/
d31 2
a45 1
#include "errors.h"
d353 1
a353 1
	    error(errno, "can't open file '%s'", name);
d365 1
a365 1
	    error(errno, "can't allocate memory for disk buffer");
@


1.8
log
@trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: validate.c,v 1.7 2016/01/11 07:54:07 jasper Exp $	*/
a41 1
#include "pathname.h"
d45 1
d350 1
a350 1
	the_media = open_pathname_as_media(name, O_RDONLY);
@


1.7
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d231 1
a231 1
		
d424 1
a424 1
	
d452 1
a452 1
	
@


1.6
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 2
@


1.5
log
@remove unused functions

initially from tobias@@, but I removed some other unused one

ok martin@@ tobias@@
@
text
@d155 1
a155 1
    item = (range_list *) malloc(sizeof(struct range_list));
@


1.4
log
@With last pdisk and full functionality for mac68k now in place, start
cleaning the maze of ifdef's not relevant for us.

This round wipes most linux and/or MacOS-only bits, more to come.
@
text
@a95 1
void delete_list(range_list *list);
a172 14
}


void
delete_list(range_list *list)
{
    range_list *item;
    range_list *cur;

    for (cur = list; cur != 0; ) {
	item = cur;
	cur = cur->next;
	free(item);
    }
@


1.3
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@a31 1
#ifndef __linux__
a32 3
#else
#include <malloc.h>
#endif
@


1.2
log
@rm trailing whitespace
@
text
@d4 1
a4 1
// Written by Eryk Vershen (eryk@@apple.com)
d303 1
a303 1
    char *s;
d402 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
// validate.c - 
d9 17
a25 17
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
d111 1
a111 1
    
d133 1
a133 1
    
d159 1
a159 1
    
d175 1
a175 1
    
d186 1
a186 1
    
d202 1
a202 1
    
d207 1
a207 1
    
d304 1
a304 1
    
d358 1
a358 1
    
d360 1
a360 1
    
d483 1
a483 1
    
d489 1
a489 1
    
@


1.1.1.1
log
@Import of pdisk from apple, BSD licensed code. Archive dated Feb 18 1998 
This is a HFS partition editing tool.
@
text
@@
