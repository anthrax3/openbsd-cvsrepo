head	1.9;
access;
symbols
	OPENBSD_5_8:1.4.0.34
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.26
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.30
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.28
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.4
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2016.01.14.04.24.19;	author krw;	state dead;
branches;
next	1.8;
commitid	rR9qzEK8ZY9DO8Sp;

1.8
date	2016.01.12.20.09.39;	author krw;	state Exp;
branches;
next	1.7;
commitid	WFEddFcNLm6A2VYQ;

1.7
date	2016.01.11.17.55.45;	author jasper;	state Exp;
branches;
next	1.6;
commitid	m85VTdlsVhWAtyII;

1.6
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.5;
commitid	DI30r1mqHPQNkhTm;

1.5
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	0qPuuXwccpVXsXcV;

1.4
date	2007.12.09.23.35.22;	author chl;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.22.16.14.21;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.29.00.43.41;	author martin;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Move more unused files to attic.
@
text
@/*	$OpenBSD: hfs_misc.c,v 1.8 2016/01/12 20:09:39 krw Exp $	*/

//
// hfs_misc.c - hfs routines
//
// Written by Eryk Vershen
//

/*
 * Copyright 2000 by Eryk Vershen
 */

#include <err.h>

// for *printf()
#include <stdio.h>

// for malloc(), calloc() & free()
#include <stdlib.h>

// for strncpy() & strcmp()
#include <string.h>
// for O_RDONLY & O_RDWR
#include <fcntl.h>
// for errno
#include <errno.h>

#include "hfs_misc.h"
#include "partition_map.h"
#include "convert.h"


//
// Defines
//
#define MDB_OFFSET	2
#define HFS_SIG		0x4244	/* i.e 'BD' */
#define HFS_PLUS_SIG	0x482B	/* i.e 'H+' */

#define get_align_long(x)	(*(u32*)(x))


//
// Types
//
typedef long long u64;

typedef struct ExtDescriptor {		// extent descriptor
    u16	xdrStABN;	// first allocation block
    u16	xdrNumABlks;	// number of allocation blocks
} ext_descriptor;

typedef struct ExtDataRec {
    ext_descriptor	ed[3];	// extent data record
} ext_data_rec;

/*
 * The crazy "u16 x[2]" stuff here is to get around the fact
 * that I can't convince the Mac compiler to align on 32 bit
 * quantities on 16 bit boundaries...
 */
struct mdb_record {		// master directory block
    u16	drSigWord;	// volume signature
    u16	drCrDate[2];	// date and time of volume creation
    u16	drLsMod[2];	// date and time of last modification
    u16	drAtrb;		// volume attributes
    u16	drNmFls;	// number of files in root directory
    u16	drVBMSt;	// first block of volume bitmap
    u16	drAllocPtr;	// start of next allocation search
    u16	drNmAlBlks;	// number of allocation blocks in volume
    u32	drAlBlkSiz;	// size (in bytes) of allocation blocks
    u32	drClpSiz;	// default clump size
    u16	drAlBlSt;	// first allocation block in volume
    u16	drNxtCNID[2];	// next unused catalog node ID
    u16	drFreeBks;	// number of unused allocation blocks
    char	drVN[28];	// volume name
    u16	drVolBkUp[2];	// date and time of last backup
    u16	drVSeqNum;	// volume backup sequence number
    u16	drWrCnt[2];	// volume write count
    u16	drXTClpSiz[2];	// clump size for extents overflow file
    u16	drCTClpSiz[2];	// clump size for catalog file
    u16	drNmRtDirs;	// number of directories in root directory
    u32	drFilCnt;	// number of files in volume
    u32	drDirCnt;	// number of directories in volume
    u32	drFndrInfo[8];	// information used by the Finder
    u16	drEmbedSigWord;	// type of embedded volume
    ext_descriptor	drEmbedExtent;	// embedded volume extent
    u16	drXTFlSize[2];	// size of extents overflow file
    ext_data_rec	drXTExtRec;	// extent record for extents overflow file
    u16	drCTFlSize[2];	// size of catalog file
    ext_data_rec	drCTExtRec;	// extent record for catalog file
};


typedef u32 HFSCatalogNodeID;

typedef struct HFSPlusExtentDescriptor {
    u32 startBlock;
    u32 blockCount;
} HFSPlusExtentDescriptor;

typedef HFSPlusExtentDescriptor HFSPlusExtentRecord[ 8];

typedef struct HFSPlusForkData {
    u64 logicalSize;
    u32 clumpSize;
    u32 totalBlocks;
    HFSPlusExtentRecord extents;
} HFSPlusForkData;

struct HFSPlusVolumeHeader {
    u16 signature;
    u16 version;
    u32 attributes;
    u32 lastMountedVersion;
    u32 reserved;
    u32 createDate;
    u32 modifyDate;
    u32 backupDate;
    u32 checkedDate;
    u32 fileCount;
    u32 folderCount;
    u32 blockSize;
    u32 totalBlocks;
    u32 freeBlocks;
    u32 nextAllocation;
    u32 rsrcClumpSize;
    u32 dataClumpSize;
    HFSCatalogNodeID nextCatalogID;
    u32 writeCount;
    u64 encodingsBitmap;
    u8 finderInfo[ 32];
    HFSPlusForkData allocationFile;
    HFSPlusForkData extentsFile;
    HFSPlusForkData catalogFile;
    HFSPlusForkData attributesFile;
    HFSPlusForkData startupFile;
} HFSPlusVolumeHeader;


//
// Global Constants
//


//
// Global Variables
//


//
// Forward declarations
//
int read_partition_block(partition_map *entry, unsigned long num, char *buf);


//
// Routines
//
char *
get_HFS_name(partition_map *entry, int *kind)
{
    DPME *data;
    struct mdb_record *mdb;
    //struct HFSPlusVolumeHeader *mdb2;
    char *name = NULL;
    int len;

    *kind = kHFS_not;

    mdb = malloc(PBLOCK_SIZE);
    if (mdb == NULL) {
	warn("can't allocate memory for MDB");
	return NULL;
    }

    data = entry->data;
    if (strcmp(data->dpme_type, kHFSType) == 0) {
	if (read_partition_block(entry, 2, (char *)mdb) == 0) {
	    warnx("Can't read block %d from partition %ld", 2,
		entry->disk_address);
	    goto not_hfs;
	}
	if (mdb->drSigWord == HFS_PLUS_SIG) {
	    // pure HFS Plus
	    // printf("%lu HFS Plus\n", entry->disk_address);
	    *kind = kHFS_plus;
	} else if (mdb->drSigWord != HFS_SIG) {
	    // not HFS !!!
	    printf("%lu not HFS\n", entry->disk_address);
	    *kind = kHFS_not;
	} else if (mdb->drEmbedSigWord != HFS_PLUS_SIG) {
	    // HFS
	    // printf("%lu HFS\n", entry->disk_address);
	    *kind = kHFS_std;
	    len = mdb->drVN[0];
	    name = malloc(len+1);
	    strncpy(name, &mdb->drVN[1], len);
	    name[len] = 0;
	} else {
	    // embedded HFS plus
	    // printf("%lu embedded HFS Plus\n", entry->disk_address);
	    *kind = kHFS_embed;
	    len = mdb->drVN[0];
	    name = malloc(len+1);
	    strncpy(name, &mdb->drVN[1], len);
	    name[len] = 0;
	}
    }
not_hfs:
    free(mdb);
    return name;
}

// really need a function to read block n from partition m

int
read_partition_block(partition_map *entry, unsigned long num, char *buf)
{
    DPME *data;
    partition_map_header * map;
    u32 base;
    u64 offset;

    map = entry->the_map;
    data = entry->data;
    base = data->dpme_pblock_start;

    if (num >= data->dpme_pblocks) {
	return 0;
    }
    offset = ((long long) base) * map->logical_block + num * 512;

    return read_media(map->m, offset, 512, (void *)buf);
}
@


1.8
log
@Use normal err/errx/warn/warnx rather than handrolling new ones. Move
usage() to pdisk.c and nuke do_help() and '-h'.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hfs_misc.c,v 1.7 2016/01/11 17:55:45 jasper Exp $	*/
@


1.7
log
@- remove some unused data structures/fields
- unifdef notdef

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hfs_misc.c,v 1.6 2016/01/11 07:54:07 jasper Exp $	*/
d13 2
a30 1
#include "errors.h"
d173 1
a173 1
	error(errno, "can't allocate memory for MDB");
d180 2
a181 1
	    error(-1, "Can't read block %d from partition %d", 2, entry->disk_address);
@


1.6
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 5
#ifdef notdef
    u16	drVCSize;	// size (in blocks) of volume cache
    u16	drVBMCSize;	// size (in blocks) of volume bitmap cache
    u16	drCtlCSize;	// size (in blocks) of common volume cache
#else
a86 1
#endif
@


1.5
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 2
@


1.4
log
@remove unused functions

initially from tobias@@, but I removed some other unused one

ok martin@@ tobias@@
@
text
@d174 1
a174 1
    mdb = (struct mdb_record *) malloc(PBLOCK_SIZE);
d199 1
a199 1
	    name = (char *) malloc(len+1);
d207 1
a207 1
	    name = (char *) malloc(len+1);
@


1.3
log
@fix typo in function name, no functional change
@
text
@a156 1
u32 embeded_offset(struct mdb_record *mdb, u32 sector);
a162 11
u32
embedded_offset(struct mdb_record *mdb, u32 sector)
{
    u32 e_offset;

    e_offset = mdb->drAlBlSt + mdb->drEmbedExtent.xdrStABN * (mdb->drAlBlkSiz / 512);

    return e_offset + sector;
}


@


1.2
log
@With last pdisk and full functionality for mac68k now in place, start
cleaning the maze of ifdef's not relevant for us.

This round wipes most linux and/or MacOS-only bits, more to come.
@
text
@d165 1
a165 1
embeded_offset(struct mdb_record *mdb, u32 sector)
@


1.1
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@a14 1
#ifndef __linux__
a15 3
#else
#include <malloc.h>
#endif
@

