head	1.25;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.2.0.16
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.14
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.12
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.1.0.6
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.4
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.2
	OPENBSD_2_9_BASE:1.1.1.1
	ver1:1.1.1.1
	apple19980218:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.01.25.23.47.38;	author krw;	state dead;
branches;
next	1.24;
commitid	V95GNbSivMnI7HNY;

1.24
date	2016.01.25.21.51.23;	author krw;	state Exp;
branches;
next	1.23;
commitid	0afQloq2paFkikl3;

1.23
date	2016.01.23.23.25.58;	author krw;	state Exp;
branches;
next	1.22;
commitid	PPThwZCvKA3Y8sbd;

1.22
date	2016.01.22.18.57.42;	author krw;	state Exp;
branches;
next	1.21;
commitid	gbwjpDFPWC5oF67r;

1.21
date	2016.01.22.18.01.14;	author krw;	state Exp;
branches;
next	1.20;
commitid	PeIpzZXLTLqAtD5T;

1.20
date	2016.01.22.17.51.25;	author krw;	state Exp;
branches;
next	1.19;
commitid	fLei6nrsfiyNcAQn;

1.19
date	2016.01.22.17.49.07;	author krw;	state Exp;
branches;
next	1.18;
commitid	phXy6N4bAPuzMD4Z;

1.18
date	2016.01.18.14.49.24;	author krw;	state Exp;
branches;
next	1.17;
commitid	6UyS3yUNTByhUGwz;

1.17
date	2016.01.17.23.18.19;	author krw;	state Exp;
branches;
next	1.16;
commitid	vC4VO4mr30PnBRSq;

1.16
date	2016.01.17.19.39.20;	author krw;	state Exp;
branches;
next	1.15;
commitid	slCzBfkhwAcLWsXe;

1.15
date	2016.01.17.18.57.52;	author krw;	state Exp;
branches;
next	1.14;
commitid	Rl8zxjpMi2a93hiE;

1.14
date	2016.01.17.18.26.51;	author krw;	state Exp;
branches;
next	1.13;
commitid	9GTOoEz5fUEQ7iWl;

1.13
date	2016.01.17.18.23.30;	author krw;	state Exp;
branches;
next	1.12;
commitid	JmzV97SaRCDIs0Gg;

1.12
date	2016.01.17.16.26.26;	author krw;	state Exp;
branches;
next	1.11;
commitid	JomFzbWltJFhj4Ev;

1.11
date	2016.01.17.16.15.59;	author krw;	state Exp;
branches;
next	1.10;
commitid	pxt9IRDGideJOJo6;

1.10
date	2016.01.17.16.07.06;	author krw;	state Exp;
branches;
next	1.9;
commitid	MHlLpCG6jqCnA9Ts;

1.9
date	2016.01.17.14.28.25;	author krw;	state Exp;
branches;
next	1.8;
commitid	6tkl4uDyqk6o4dzS;

1.8
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.7;
commitid	DI30r1mqHPQNkhTm;

1.7
date	2014.07.21.01.51.11;	author guenther;	state Exp;
branches;
next	1.6;
commitid	ro8JUTvBpvQMiFY9;

1.6
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.28.22.26.58;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.11.17.20.40;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.24.00.13.54;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.24.00.13.54;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Two more for the attic.
@
text
@    /*	$OpenBSD: convert.c,v 1.24 2016/01/25 21:51:23 krw Exp $	*/

/*
 * convert.c - Little-endian conversion
 *
 * Written by Eryk Vershen
 *
 * See comments in convert.h
 */

/*
 * Copyright 1996,1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <endian.h>

#include "dpme.h"
#include "convert.h"

void	reverse2 (uint8_t *);
void	reverse4 (uint8_t *);

int
convert_dpme(struct dpme *dpme, int to_cpu_form)
{
#if BYTE_ORDER == LITTLE_ENDIAN
	/*
         * Since we will toss the block if the signature doesn't match
         * we don't need to check the signature down here.
         */
	reverse2((uint8_t *)&dpme->dpme_signature);
	reverse2((uint8_t *)&dpme->dpme_reserved_1);
	reverse4((uint8_t *)&dpme->dpme_map_entries);
	reverse4((uint8_t *)&dpme->dpme_pblock_start);
	reverse4((uint8_t *)&dpme->dpme_pblocks);
	reverse4((uint8_t *)&dpme->dpme_lblock_start);
	reverse4((uint8_t *)&dpme->dpme_lblocks);
	reverse4((uint8_t *)&dpme->dpme_flags);
	reverse4((uint8_t *)&dpme->dpme_boot_block);
	reverse4((uint8_t *)&dpme->dpme_boot_bytes);
	reverse4((uint8_t *)&dpme->dpme_load_addr);
	reverse4((uint8_t *)&dpme->dpme_goto_addr);
	reverse4((uint8_t *)&dpme->dpme_checksum);
#endif
	return 0;
}


int
convert_block0(struct block0 *block0, int to_cpu_form)
{
#if BYTE_ORDER == LITTLE_ENDIAN
	struct ddmap *m;
	uint16_t count;
	int i;

	/*
         * Since this data is optional we do not want to convert willy-nilly.
         * We use the flag to determine whether to check for the signature
         * before or after we flip the bytes and to determine which form of
         * the count to use.
         */
	if (to_cpu_form) {
		reverse2((uint8_t *)&block0->sbSig);
		if (block0->sbSig != BLOCK0_SIGNATURE) {
			reverse2((uint8_t *)&block0->sbSig);
			if (block0->sbSig != BLOCK0_SIGNATURE) {
				return 0;
			}
		}
	} else {
		if (block0->sbSig != BLOCK0_SIGNATURE) {
			return 0;
		}
		reverse2((uint8_t *)&block0->sbSig);
	}
	reverse2((uint8_t *)&block0->sbBlkSize);
	reverse4((uint8_t *)&block0->sbBlkCount);
	reverse2((uint8_t *)&block0->sbDevType);
	reverse2((uint8_t *)&block0->sbDevId);
	reverse4((uint8_t *)&block0->sbData);
	if (to_cpu_form) {
		reverse2((uint8_t *)&block0->sbDrvrCount);
		count = block0->sbDrvrCount;
	} else {
		count = block0->sbDrvrCount;
		reverse2((uint8_t *)&block0->sbDrvrCount);
	}

	if (count > 0) {
		m = (struct ddmap *)block0->sbMap;
		for (i = 0; i < count; i++) {
			reverse4((uint8_t *)&m[i].ddBlock);
			reverse2((uint8_t *)&m[i].ddSize);
			reverse2((uint8_t *)&m[i].ddType);
		}
	}
#endif
	return 0;
}


void
reverse2(uint8_t *bytes)
{
	uint8_t t;

	t = *bytes;
	*bytes = bytes[1];
	bytes[1] = t;
}


void
reverse4(uint8_t *bytes)
{
	uint8_t t;

	t = *bytes;
	*bytes = bytes[3];
	bytes[3] = t;
	t = bytes[1];
	bytes[1] = bytes[2];
	bytes[2] = t;
}
@


1.24
log
@Tweak fields in struct dpme to be more consistent with Apple's info.

Better comments, make all reserved fields uint8_t arrays, don't
claim uint32_t fields are actually pointers.
@
text
@d1 1
a1 1
    /*	$OpenBSD: convert.c,v 1.23 2016/01/23 23:25:58 krw Exp $	*/
@


1.23
log
@Nuke unused kPatchType. Nuke kStringNot and use " not' where needed.
Nuke kStringEmpty and use "" where needed. Nuke unused static 'g'.

Eliminate #include's in *.h files.

Some whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.22 2016/01/22 18:57:42 krw Exp $	*/
a59 1
	reverse4((uint8_t *)&dpme->dpme_load_addr_2);
a60 1
	reverse4((uint8_t *)&dpme->dpme_goto_addr_2);
@


1.22
log
@Change partition map field 'data' to 'dmpe'. Change 'create_data'
to 'create_dmpe'. Sweep up some 'struct dpme *data' to struct dpme
*dpme'.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.21 2016/01/22 18:01:14 krw Exp $	*/
d35 1
@


1.21
log
@Of course if you change the parameter name you need to change the uses of
said parameter to the new name.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.20 2016/01/22 17:51:25 krw Exp $	*/
d41 1
a41 1
convert_dpme(struct dpme *data, int to_cpu_form)
d48 15
a62 15
	reverse2((uint8_t *)&data->dpme_signature);
	reverse2((uint8_t *)&data->dpme_reserved_1);
	reverse4((uint8_t *)&data->dpme_map_entries);
	reverse4((uint8_t *)&data->dpme_pblock_start);
	reverse4((uint8_t *)&data->dpme_pblocks);
	reverse4((uint8_t *)&data->dpme_lblock_start);
	reverse4((uint8_t *)&data->dpme_lblocks);
	reverse4((uint8_t *)&data->dpme_flags);
	reverse4((uint8_t *)&data->dpme_boot_block);
	reverse4((uint8_t *)&data->dpme_boot_bytes);
	reverse4((uint8_t *)&data->dpme_load_addr);
	reverse4((uint8_t *)&data->dpme_load_addr_2);
	reverse4((uint8_t *)&data->dpme_goto_addr);
	reverse4((uint8_t *)&data->dpme_goto_addr_2);
	reverse4((uint8_t *)&data->dpme_checksum);
@


1.20
log
@Change parameter name 'data' to 'block0'.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.19 2016/01/22 17:49:07 krw Exp $	*/
d83 4
a86 4
		reverse2((uint8_t *)&data->sbSig);
		if (data->sbSig != BLOCK0_SIGNATURE) {
			reverse2((uint8_t *)&data->sbSig);
			if (data->sbSig != BLOCK0_SIGNATURE) {
d91 1
a91 1
		if (data->sbSig != BLOCK0_SIGNATURE) {
d94 1
a94 1
		reverse2((uint8_t *)&data->sbSig);
d96 5
a100 5
	reverse2((uint8_t *)&data->sbBlkSize);
	reverse4((uint8_t *)&data->sbBlkCount);
	reverse2((uint8_t *)&data->sbDevType);
	reverse2((uint8_t *)&data->sbDevId);
	reverse4((uint8_t *)&data->sbData);
d102 2
a103 2
		reverse2((uint8_t *)&data->sbDrvrCount);
		count = data->sbDrvrCount;
d105 2
a106 2
		count = data->sbDrvrCount;
		reverse2((uint8_t *)&data->sbDrvrCount);
d110 1
a110 1
		m = (struct ddmap *) data->sbMap;
@


1.19
log
@Whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.18 2016/01/18 14:49:24 krw Exp $	*/
d69 1
a69 1
convert_block0(struct block0 *data, int to_cpu_form)
@


1.18
log
@Run indent(1) over it and tweak the results a bit manually to look more
KNF'ish.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.17 2016/01/17 23:18:19 krw Exp $	*/
d37 2
a38 2
void		reverse2 (uint8_t *);
void		reverse4 (uint8_t *);
d41 1
a41 1
convert_dpme(struct dpme * data, int to_cpu_form)
d48 15
a62 15
	reverse2((uint8_t *) & data->dpme_signature);
	reverse2((uint8_t *) & data->dpme_reserved_1);
	reverse4((uint8_t *) & data->dpme_map_entries);
	reverse4((uint8_t *) & data->dpme_pblock_start);
	reverse4((uint8_t *) & data->dpme_pblocks);
	reverse4((uint8_t *) & data->dpme_lblock_start);
	reverse4((uint8_t *) & data->dpme_lblocks);
	reverse4((uint8_t *) & data->dpme_flags);
	reverse4((uint8_t *) & data->dpme_boot_block);
	reverse4((uint8_t *) & data->dpme_boot_bytes);
	reverse4((uint8_t *) & data->dpme_load_addr);
	reverse4((uint8_t *) & data->dpme_load_addr_2);
	reverse4((uint8_t *) & data->dpme_goto_addr);
	reverse4((uint8_t *) & data->dpme_goto_addr_2);
	reverse4((uint8_t *) & data->dpme_checksum);
d69 1
a69 1
convert_block0(struct block0 * data, int to_cpu_form)
d72 1
a72 1
	struct ddmap   *m;
d83 1
a83 1
		reverse2((uint8_t *) & data->sbSig);
d85 1
a85 1
			reverse2((uint8_t *) & data->sbSig);
d94 1
a94 1
		reverse2((uint8_t *) & data->sbSig);
d96 5
a100 5
	reverse2((uint8_t *) & data->sbBlkSize);
	reverse4((uint8_t *) & data->sbBlkCount);
	reverse2((uint8_t *) & data->sbDevType);
	reverse2((uint8_t *) & data->sbDevId);
	reverse4((uint8_t *) & data->sbData);
d102 1
a102 1
		reverse2((uint8_t *) & data->sbDrvrCount);
d106 1
a106 1
		reverse2((uint8_t *) & data->sbDrvrCount);
d112 3
a114 3
			reverse4((uint8_t *) & m[i].ddBlock);
			reverse2((uint8_t *) & m[i].ddSize);
			reverse2((uint8_t *) & m[i].ddType);
d123 1
a123 1
reverse2(uint8_t * bytes)
d134 1
a134 1
reverse4(uint8_t * bytes)
@


1.17
log
@Change "//" comments to "/**/". Nuke really stupid ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.16 2016/01/17 19:39:20 krw Exp $	*/
d37 2
a38 2
void reverse2(uint8_t *);
void reverse4(uint8_t *);
d41 1
a41 1
convert_dpme(struct dpme *data, int to_cpu_form)
d44 19
a62 19
    /*
     * Since we will toss the block if the signature doesn't match
     * we don't need to check the signature down here.
     */
    reverse2((uint8_t *)&data->dpme_signature);
    reverse2((uint8_t *)&data->dpme_reserved_1);
    reverse4((uint8_t *)&data->dpme_map_entries);
    reverse4((uint8_t *)&data->dpme_pblock_start);
    reverse4((uint8_t *)&data->dpme_pblocks);
    reverse4((uint8_t *)&data->dpme_lblock_start);
    reverse4((uint8_t *)&data->dpme_lblocks);
    reverse4((uint8_t *)&data->dpme_flags);
    reverse4((uint8_t *)&data->dpme_boot_block);
    reverse4((uint8_t *)&data->dpme_boot_bytes);
    reverse4((uint8_t *)&data->dpme_load_addr);
    reverse4((uint8_t *)&data->dpme_load_addr_2);
    reverse4((uint8_t *)&data->dpme_goto_addr);
    reverse4((uint8_t *)&data->dpme_goto_addr_2);
    reverse4((uint8_t *)&data->dpme_checksum);
d64 1
a64 1
    return 0;
d69 1
a69 1
convert_block0(struct block0 *data, int to_cpu_form)
d72 23
a94 17
    struct ddmap *m;
    uint16_t count;
    int i;

    /*
     * Since this data is optional we do not want to convert willy-nilly.
     * We use the flag to determine whether to check for the signature
     * before or after we flip the bytes and to determine which form of
     * the count to use.
     */
    if (to_cpu_form) {
	reverse2((uint8_t *)&data->sbSig);
	if (data->sbSig != BLOCK0_SIGNATURE) {
	    reverse2((uint8_t *)&data->sbSig);
	    if (data->sbSig != BLOCK0_SIGNATURE) {
		return 0;
	    }
d96 11
a106 3
    } else {
	if (data->sbSig != BLOCK0_SIGNATURE) {
	    return 0;
d108 8
a115 21
	reverse2((uint8_t *)&data->sbSig);
    }
    reverse2((uint8_t *)&data->sbBlkSize);
    reverse4((uint8_t *)&data->sbBlkCount);
    reverse2((uint8_t *)&data->sbDevType);
    reverse2((uint8_t *)&data->sbDevId);
    reverse4((uint8_t *)&data->sbData);
    if (to_cpu_form) {
	reverse2((uint8_t *)&data->sbDrvrCount);
	count = data->sbDrvrCount;
    } else {
	count = data->sbDrvrCount;
	reverse2((uint8_t *)&data->sbDrvrCount);
    }

    if (count > 0) {
	m = (struct ddmap *) data->sbMap;
	for (i = 0; i < count; i++) {
	    reverse4((uint8_t *)&m[i].ddBlock);
	    reverse2((uint8_t *)&m[i].ddSize);
	    reverse2((uint8_t *)&m[i].ddType);
a116 1
    }
d118 1
a118 1
    return 0;
d123 1
a123 1
reverse2(uint8_t *bytes)
d125 1
a125 1
    uint8_t t;
d127 3
a129 3
    t = *bytes;
    *bytes = bytes[1];
    bytes[1] = t;
d134 1
a134 1
reverse4(uint8_t *bytes)
d136 1
a136 1
    uint8_t t;
d138 6
a143 6
    t = *bytes;
    *bytes = bytes[3];
    bytes[3] = t;
    t = bytes[1];
    bytes[1] = bytes[2];
    bytes[2] = t;
@


1.16
log
@Reduce namespace pollution by eliminating parameter names from forward
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.15 2016/01/17 18:57:52 krw Exp $	*/
d3 7
a9 7
//
// convert.c - Little-endian conversion
//
// Written by Eryk Vershen
//
// See comments in convert.h
//
d44 4
a47 2
    // Since we will toss the block if the signature doesn't match
    // we don't need to check the signature down here.
d76 6
a81 4
    // Since this data is optional we do not want to convert willy-nilly.
    // We use the flag to determine whether to check for the signature
    // before or after we flip the bytes and to determine which form of
    // the count to use.
@


1.15
log
@Remove a bunch of ridiculous and uninformative comments like "// Defines".
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.14 2016/01/17 18:26:51 krw Exp $	*/
d37 2
a38 2
void reverse2(uint8_t *bytes);
void reverse4(uint8_t *bytes);
@


1.14
log
@The great de-typedef'ification continues. u16 -> uint16_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.13 2016/01/17 18:23:30 krw Exp $	*/
a36 24

//
// Defines
//


//
// Types
//


//
// Global Constants
//


//
// Global Variables
//


//
// Forward declarations
//
a39 4

//
// Routines
//
@


1.13
log
@The great de-typedef'ification continues. u8 -> uint8_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.12 2016/01/17 16:26:26 krw Exp $	*/
d99 1
a99 1
    u16 count;
@


1.12
log
@The great de-typedef'ification continues. DDMap -> struct ddmap.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.11 2016/01/17 16:15:59 krw Exp $	*/
d61 2
a62 2
void reverse2(u8 *bytes);
void reverse4(u8 *bytes);
d74 15
a88 15
    reverse2((u8 *)&data->dpme_signature);
    reverse2((u8 *)&data->dpme_reserved_1);
    reverse4((u8 *)&data->dpme_map_entries);
    reverse4((u8 *)&data->dpme_pblock_start);
    reverse4((u8 *)&data->dpme_pblocks);
    reverse4((u8 *)&data->dpme_lblock_start);
    reverse4((u8 *)&data->dpme_lblocks);
    reverse4((u8 *)&data->dpme_flags);
    reverse4((u8 *)&data->dpme_boot_block);
    reverse4((u8 *)&data->dpme_boot_bytes);
    reverse4((u8 *)&data->dpme_load_addr);
    reverse4((u8 *)&data->dpme_load_addr_2);
    reverse4((u8 *)&data->dpme_goto_addr);
    reverse4((u8 *)&data->dpme_goto_addr_2);
    reverse4((u8 *)&data->dpme_checksum);
d107 1
a107 1
	reverse2((u8 *)&data->sbSig);
d109 1
a109 1
	    reverse2((u8 *)&data->sbSig);
d118 1
a118 1
	reverse2((u8 *)&data->sbSig);
d120 5
a124 5
    reverse2((u8 *)&data->sbBlkSize);
    reverse4((u8 *)&data->sbBlkCount);
    reverse2((u8 *)&data->sbDevType);
    reverse2((u8 *)&data->sbDevId);
    reverse4((u8 *)&data->sbData);
d126 1
a126 1
	reverse2((u8 *)&data->sbDrvrCount);
d130 1
a130 1
	reverse2((u8 *)&data->sbDrvrCount);
d136 3
a138 3
	    reverse4((u8 *)&m[i].ddBlock);
	    reverse2((u8 *)&m[i].ddSize);
	    reverse2((u8 *)&m[i].ddType);
d147 1
a147 1
reverse2(u8 *bytes)
d149 1
a149 1
    u8 t;
d158 1
a158 1
reverse4(u8 *bytes)
d160 1
a160 1
    u8 t;
@


1.11
log
@The great de-typedef'ification continues. Block0 -> struct block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.10 2016/01/17 16:07:06 krw Exp $	*/
d98 1
a98 1
    DDMap *m;
d134 1
a134 1
	m = (DDMap *) data->sbMap;
@


1.10
log
@The great de-typedef'ification continues. DPME -> struct dpme.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.9 2016/01/17 14:28:25 krw Exp $	*/
d95 1
a95 1
convert_block0(Block0 *data, int to_cpu_form)
@


1.9
log
@A/UX is no more, was m68k only, and we have no sentimental reasons for
keeping support.
@
text
@d1 1
a1 1
/*	$OpenBSD: convert.c,v 1.8 2016/01/11 07:54:07 jasper Exp $	*/
d69 1
a69 1
convert_dpme(DPME *data, int to_cpu_form)
@


1.8
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a88 1
    convert_bzb((BZB *)data->dpme_bzb, to_cpu_form);
a91 31


#if BYTE_ORDER == LITTLE_ENDIAN
int
convert_bzb(BZB *data, int to_cpu_form)
{
    // Since the data here varies according to the type of partition we
    // do not want to convert willy-nilly. We use the flag to determine
    // whether to check for the signature before or after we flip the bytes.
    if (to_cpu_form) {
	reverse4((u8 *)&data->bzb_magic);
	if (data->bzb_magic != BZBMAGIC) {
	    reverse4((u8 *)&data->bzb_magic);
	    if (data->bzb_magic != BZBMAGIC) {
		return 0;
	    }
	}
    } else {
	if (data->bzb_magic != BZBMAGIC) {
	    return 0;
	}
	reverse4((u8 *)&data->bzb_magic);
    }
    reverse2((u8 *)&data->bzb_inode);
    reverse4((u8 *)&data->bzb_flags);
    reverse4((u8 *)&data->bzb_tmade);
    reverse4((u8 *)&data->bzb_tmount);
    reverse4((u8 *)&data->bzb_tumount);
    return 0;
}
#endif
@


1.7
log
@Switch from <sys/endian.h> or <machine/endian.h> to the new,
being-standardized <endian.h>

ok deraadt@@ millert@@ beck@@
@
text
@d1 2
@


1.6
log
@remove some unnecessary sys/param.h inclusions
@
text
@d31 1
a31 1
#include <machine/endian.h>
@


1.5
log
@use <machine/endian.h> to figure what we are running on instead of defining
our own macros
@
text
@d30 1
a30 1
#include <sys/param.h>
@


1.4
log
@remove a bunch of linux and NeXT defines and, in turn, -D__unix__
@
text
@d30 2
a31 4
#define LITTLE_ENDIAN 1234
#define BIG_ENDIAN 4321
#define BYTE_ORDER 4321
//#define BYTE_ORDER 1234
@


1.3
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@a29 3
#ifdef __linux__
#include <endian.h>
#else
a33 1
#endif
@


1.2
log
@rm trailing whitespace
@
text
@d4 1
a4 1
// Written by Eryk Vershen (eryk@@apple.com)
d36 1
@


1.1
log
@Initial revision
@
text
@d11 17
a27 17
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
@


1.1.1.1
log
@Import of pdisk from apple, BSD licensed code. Archive dated Feb 18 1998 
This is a HFS partition editing tool.
@
text
@@
