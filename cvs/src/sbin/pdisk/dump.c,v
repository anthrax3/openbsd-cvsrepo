head	1.75;
access;
symbols
	OPENBSD_6_1:1.75.0.8
	OPENBSD_6_1_BASE:1.75
	OPENBSD_6_0:1.75.0.4
	OPENBSD_6_0_BASE:1.75
	OPENBSD_5_9:1.75.0.2
	OPENBSD_5_9_BASE:1.75
	OPENBSD_5_8:1.9.0.24
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.16
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.20
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.18
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.14
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.12
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.10
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.3.0.14
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.12
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.10
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.1.1.0.6
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.4
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.2
	OPENBSD_2_9_BASE:1.1.1.1
	ver1:1.1.1.1
	apple19980218:1.1.1;
locks; strict;
comment	@ * @;


1.75
date	2016.02.23.02.39.54;	author krw;	state Exp;
branches;
next	1.74;
commitid	oYskOkPMCYpeYCHG;

1.74
date	2016.01.31.23.00.11;	author krw;	state Exp;
branches;
next	1.73;
commitid	74Rthqc3AgIVhks7;

1.73
date	2016.01.31.22.52.57;	author krw;	state Exp;
branches;
next	1.72;
commitid	jEdXY1kksJMnmJLm;

1.72
date	2016.01.31.15.28.56;	author krw;	state Exp;
branches;
next	1.71;
commitid	SANePqcLzJeNFm7O;

1.71
date	2016.01.31.14.55.41;	author krw;	state Exp;
branches;
next	1.70;
commitid	ZjbTHa9TF7xtCAJm;

1.70
date	2016.01.31.13.53.23;	author krw;	state Exp;
branches;
next	1.69;
commitid	nmZIQHslV68WytAx;

1.69
date	2016.01.30.17.21.10;	author krw;	state Exp;
branches;
next	1.68;
commitid	BOQYiykYZJ8gnOpB;

1.68
date	2016.01.30.17.09.11;	author krw;	state Exp;
branches;
next	1.67;
commitid	ckpV9XGgFAiDBI9u;

1.67
date	2016.01.29.22.51.43;	author krw;	state Exp;
branches;
next	1.66;
commitid	T4U3iDofClirvhXD;

1.66
date	2016.01.29.17.22.44;	author krw;	state Exp;
branches;
next	1.65;
commitid	dVSICm2Wa8uTInY9;

1.65
date	2016.01.29.15.06.37;	author krw;	state Exp;
branches;
next	1.64;
commitid	24MMipkr6YquiMM1;

1.64
date	2016.01.29.14.54.38;	author krw;	state Exp;
branches;
next	1.63;
commitid	JxW4PE5GwpjH1Ttx;

1.63
date	2016.01.29.14.48.20;	author krw;	state Exp;
branches;
next	1.62;
commitid	qzU9koNDngf0pT0B;

1.62
date	2016.01.28.19.07.45;	author krw;	state Exp;
branches;
next	1.61;
commitid	V5tzgmz34tYP6x81;

1.61
date	2016.01.28.13.09.21;	author krw;	state Exp;
branches;
next	1.60;
commitid	3P6vRTx5dJUWT10d;

1.60
date	2016.01.27.20.34.27;	author krw;	state Exp;
branches;
next	1.59;
commitid	Y2THIX6Zg0A69Yzv;

1.59
date	2016.01.27.18.26.05;	author gsoares;	state Exp;
branches;
next	1.58;
commitid	yKRrDoXBEj2SJboG;

1.58
date	2016.01.27.14.47.53;	author krw;	state Exp;
branches;
next	1.57;
commitid	HSGGvwKIkrWkURCB;

1.57
date	2016.01.27.00.03.52;	author krw;	state Exp;
branches;
next	1.56;
commitid	rqEjRk6knIDhhe6A;

1.56
date	2016.01.26.21.07.54;	author krw;	state Exp;
branches;
next	1.55;
commitid	DW9rfkVjTw1mfuI8;

1.55
date	2016.01.26.16.39.00;	author krw;	state Exp;
branches;
next	1.54;
commitid	rZKRcHhLUVQAhJLw;

1.54
date	2016.01.26.16.13.09;	author krw;	state Exp;
branches;
next	1.53;
commitid	7HeB8KYaCuiLcwze;

1.53
date	2016.01.25.23.43.20;	author krw;	state Exp;
branches;
next	1.52;
commitid	Qe66eD6zrMyPrXqP;

1.52
date	2016.01.25.21.51.23;	author krw;	state Exp;
branches;
next	1.51;
commitid	0afQloq2paFkikl3;

1.51
date	2016.01.25.03.26.54;	author jsg;	state Exp;
branches;
next	1.50;
commitid	9M3iLOXUEIPEiRWU;

1.50
date	2016.01.24.15.23.33;	author krw;	state Exp;
branches;
next	1.49;
commitid	AjTwGqLbiMbjTUQH;

1.49
date	2016.01.24.15.18.50;	author krw;	state Exp;
branches;
next	1.48;
commitid	qg9FUcvTXSVVSHLj;

1.48
date	2016.01.24.01.38.32;	author krw;	state Exp;
branches;
next	1.47;
commitid	g7Azk2rL78IOOfnI;

1.47
date	2016.01.23.23.25.58;	author krw;	state Exp;
branches;
next	1.46;
commitid	PPThwZCvKA3Y8sbd;

1.46
date	2016.01.23.03.46.18;	author krw;	state Exp;
branches;
next	1.45;
commitid	HhlQ6dIQMjX8YGSD;

1.45
date	2016.01.23.01.43.13;	author krw;	state Exp;
branches;
next	1.44;
commitid	KY3XjrgZevMVU8fl;

1.44
date	2016.01.22.18.57.42;	author krw;	state Exp;
branches;
next	1.43;
commitid	gbwjpDFPWC5oF67r;

1.43
date	2016.01.22.17.35.16;	author krw;	state Exp;
branches;
next	1.42;
commitid	yo0CGbxOUa4UAkDH;

1.42
date	2016.01.22.01.25.56;	author krw;	state Exp;
branches;
next	1.41;
commitid	UnRUlgKDkfeEnQQF;

1.41
date	2016.01.22.00.38.53;	author krw;	state Exp;
branches;
next	1.40;
commitid	x0tMj8kuzhFIVdU1;

1.40
date	2016.01.21.15.33.21;	author krw;	state Exp;
branches;
next	1.39;
commitid	YzEQpnBPgLX85u7F;

1.39
date	2016.01.21.02.52.52;	author krw;	state Exp;
branches;
next	1.38;
commitid	CSp7NWaeW8rVW6mR;

1.38
date	2016.01.19.14.50.40;	author krw;	state Exp;
branches;
next	1.37;
commitid	YKGwNSU9QoLkwIWa;

1.37
date	2016.01.18.21.50.53;	author krw;	state Exp;
branches;
next	1.36;
commitid	iCfrmMnzqdydi4ac;

1.36
date	2016.01.18.17.57.35;	author krw;	state Exp;
branches;
next	1.35;
commitid	nIKs6pPbVKcIxae8;

1.35
date	2016.01.18.15.17.22;	author krw;	state Exp;
branches;
next	1.34;
commitid	B4JxNlZzA8RjNvfN;

1.34
date	2016.01.17.23.18.19;	author krw;	state Exp;
branches;
next	1.33;
commitid	vC4VO4mr30PnBRSq;

1.33
date	2016.01.17.19.39.20;	author krw;	state Exp;
branches;
next	1.32;
commitid	slCzBfkhwAcLWsXe;

1.32
date	2016.01.17.19.15.55;	author krw;	state Exp;
branches;
next	1.31;
commitid	mHBjhdgm2kvWAkWc;

1.31
date	2016.01.17.18.57.52;	author krw;	state Exp;
branches;
next	1.30;
commitid	Rl8zxjpMi2a93hiE;

1.30
date	2016.01.17.18.44.59;	author krw;	state Exp;
branches;
next	1.29;
commitid	leFr8OHidfOIWdIJ;

1.29
date	2016.01.17.17.44.05;	author krw;	state Exp;
branches;
next	1.28;
commitid	ie6tS8cTDeRCB9yd;

1.28
date	2016.01.17.16.44.01;	author krw;	state Exp;
branches;
next	1.27;
commitid	kLv2k3tgOXORsd3c;

1.27
date	2016.01.17.16.34.41;	author krw;	state Exp;
branches;
next	1.26;
commitid	aIT6gqnS6kCYTivm;

1.26
date	2016.01.17.16.26.26;	author krw;	state Exp;
branches;
next	1.25;
commitid	JomFzbWltJFhj4Ev;

1.25
date	2016.01.17.16.15.59;	author krw;	state Exp;
branches;
next	1.24;
commitid	pxt9IRDGideJOJo6;

1.24
date	2016.01.17.16.07.06;	author krw;	state Exp;
branches;
next	1.23;
commitid	MHlLpCG6jqCnA9Ts;

1.23
date	2016.01.17.15.57.12;	author krw;	state Exp;
branches;
next	1.22;
commitid	9OUrU3poCOjYi22w;

1.22
date	2016.01.17.14.28.25;	author krw;	state Exp;
branches;
next	1.21;
commitid	6tkl4uDyqk6o4dzS;

1.21
date	2016.01.17.14.13.42;	author jasper;	state Exp;
branches;
next	1.20;
commitid	KoDSAptRoTS0S3qZ;

1.20
date	2016.01.16.22.28.14;	author krw;	state Exp;
branches;
next	1.19;
commitid	IIP5iNpDONoW4Jjm;

1.19
date	2016.01.16.20.00.50;	author krw;	state Exp;
branches;
next	1.18;
commitid	2koPB3ak72axl95m;

1.18
date	2016.01.15.23.05.00;	author krw;	state Exp;
branches;
next	1.17;
commitid	cXG0BedMOT1d0xiF;

1.17
date	2016.01.15.16.39.20;	author krw;	state Exp;
branches;
next	1.16;
commitid	jCu7JX5yifR514Uo;

1.16
date	2016.01.14.04.02.05;	author krw;	state Exp;
branches;
next	1.15;
commitid	oNnNZxQ1fbZJJMcx;

1.15
date	2016.01.12.20.09.39;	author krw;	state Exp;
branches;
next	1.14;
commitid	WFEddFcNLm6A2VYQ;

1.14
date	2016.01.12.15.32.08;	author krw;	state Exp;
branches;
next	1.13;
commitid	jkbr5rI0RhKaoKmr;

1.13
date	2016.01.11.23.31.27;	author krw;	state Exp;
branches;
next	1.12;
commitid	1Gl5xh4AgZJGXuPl;

1.12
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.11;
commitid	DI30r1mqHPQNkhTm;

1.11
date	2015.08.20.22.16.35;	author millert;	state Exp;
branches;
next	1.10;
commitid	e62lBrztJdrskjEi;

1.10
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	0qPuuXwccpVXsXcV;

1.9
date	2010.05.19.22.12.03;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.09.23.35.22;	author chl;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.11.17.20.40;	author martin;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.29.15.03.32;	author martin;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.29.00.43.41;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.15.13.28.22;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.24.00.14.03;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.24.00.14.03;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.75
log
@Fix display of pdisk partition sizes by casting the 32-bit number
of blocks to (long long) before multiplying by 512 and passing the
value to fmt_scaled().

Discovered and fix tested by rpe@@.

ok rpe@@ deraadt@@
@
text
@/*	$OpenBSD: dump.c,v 1.74 2016/01/31 23:00:11 krw Exp $	*/

/*
 * dump.c - dumping partition maps
 *
 * Written by Eryk Vershen
 */

/*
 * Copyright 1996,1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <util.h>

#include "partition_map.h"
#include "dump.h"
#include "io.h"

void	dump_block(unsigned char *, int);
void	dump_block_zero(struct partition_map *);
void	dump_partition_entry(struct entry *, int, int, int);
int	get_max_base_or_length(struct partition_map *);
int	get_max_name_string_length(struct partition_map *);
int	get_max_type_string_length(struct partition_map *);

void
dump_block_zero(struct partition_map *map)
{
	char buf[FMT_SCALED_STRSIZE];
	struct ddmap  *m;
	int i;

	printf("\nDevice block size=%u, Number of Blocks=%u",
	       map->sbBlkSize, map->sbBlkCount);
	if (fmt_scaled((long long)map->sbBlkCount * map->sbBlkSize, buf) == 0)
		printf(" (%s)\n", buf);
	else
		printf("\n");

	printf("DeviceType=0x%x, DeviceId=0x%x\n", map->sbDevType,
	    map->sbDevId);
	if (map->sbDrvrCount > 0) {
		printf("Drivers-\n");
		m = map->sbDDMap;
		for (i = 0; i < map->sbDrvrCount; i++) {
			printf("%d: %3u @@ %u, ", i + 1, m[i].ddSize,
			    m[i].ddBlock);
			printf("type=0x%x\n", m[i].ddType);
		}
	}
	printf("\n");
}


void
dump_partition_map(struct partition_map *map)
{
	struct entry *entry;
	int digits, max_type_length, max_name_length;

	printf("\nPartition map (with %d byte blocks) on '%s'\n",
	       map->sbBlkSize, map->name);

	digits = number_of_digits(get_max_base_or_length(map));
	if (digits < 6)
		digits = 6;
	max_type_length = get_max_type_string_length(map);
	if (max_type_length < 4)
		max_type_length = 4;
	max_name_length = get_max_name_string_length(map);
	if (max_name_length < 6)
		max_name_length = 6;
	printf(" #: %*s %-*s %*s   %-*s\n", max_type_length, "type",
	    max_name_length, "name", digits, "length", digits, "base");

	LIST_FOREACH(entry, &map->disk_order, disk_entry) {
		dump_partition_entry(entry, max_type_length,
		    max_name_length, digits);
	}
	dump_block_zero(map);
}


void
dump_partition_entry(struct entry *entry, int type_length, int name_length,
    int digits)
{
	char buf[FMT_SCALED_STRSIZE];

	printf("%2ld: %*.32s", entry->disk_address, type_length,
	    entry->dpme_type);
	printf("%c%-*.32s ", contains_driver(entry) ? '*' : ' ',
	    name_length, entry->dpme_name);

	printf("%*u @@ %-*u", digits, entry->dpme_pblocks, digits,
	    entry->dpme_pblock_start);

	if (fmt_scaled((long long)entry->dpme_pblocks *
	    entry->the_map->sbBlkSize, buf) == 0)
		printf("(%s)\n", buf);
	else
		printf("\n");
}


void
show_data_structures(struct partition_map *map)
{
	struct entry *entry;
	struct ddmap *m;
	int i;

	printf("Header:\n");
	printf("map %d blocks out of %d,  media %lu blocks (%d byte blocks)\n",
	    map->blocks_in_map, map->maximum_in_map, map->media_size,
	    map->sbBlkSize);
	printf("Map is%s writable", rflag ? " not" : "");
	printf(" and has%s been changed\n", (map->changed) ? "" : " not");
	printf("\n");

	printf("Block0:\n");
	printf("signature 0x%x", map->sbSig);
	printf("Block size=%u, Number of Blocks=%u\n", map->sbBlkSize,
	    map->sbBlkCount);
	printf("DeviceType=0x%x, DeviceId=0x%x, sbData=0x%x\n", map->sbDevType,
	    map->sbDevId, map->sbData);
	if (map->sbDrvrCount == 0) {
		printf("No drivers\n");
	} else {
		printf("%u driver%s-\n", map->sbDrvrCount,
		    (map->sbDrvrCount > 1) ? "s" : "");
		m = map->sbDDMap;
		for (i = 0; i < map->sbDrvrCount; i++) {
			printf("%u: @@ %u for %u, type=0x%x\n", i + 1,
			    m[i].ddBlock, m[i].ddSize, m[i].ddType);
		}
	}
	printf("\n");
	printf(" #:                 type  length   base    "
	       "flags     (      logical      )\n");
	LIST_FOREACH(entry, &map->disk_order, disk_entry) {
		printf("%2ld: %20.32s ", entry->disk_address, entry->dpme_type);
		printf("%7u @@ %-7u ", entry->dpme_pblocks,
		    entry->dpme_pblock_start);
		printf("%c%c%c%c%c%c%c%c%c ",
		       (entry->dpme_flags & DPME_VALID) ? 'V' : '.',
		       (entry->dpme_flags & DPME_ALLOCATED) ? 'A' : '.',
		       (entry->dpme_flags & DPME_IN_USE) ? 'I' : '.',
		       (entry->dpme_flags & DPME_BOOTABLE) ? 'B' : '.',
		       (entry->dpme_flags & DPME_READABLE) ? 'R' : '.',
		       (entry->dpme_flags & DPME_WRITABLE) ? 'W' : '.',
		       (entry->dpme_flags & DPME_OS_PIC_CODE) ? 'P' : '.',
		       (entry->dpme_flags & DPME_OS_SPECIFIC_2) ? '2' : '.',
		       (entry->dpme_flags & DPME_OS_SPECIFIC_1) ? '1' : '.');
		printf("( %7u @@ %-7u )\n", entry->dpme_lblocks,
		    entry->dpme_lblock_start);
	}
	printf("\n");
	printf(" #:  booter   bytes      load_address      "
	    "goto_address checksum processor\n");
	LIST_FOREACH(entry, &map->disk_order, disk_entry) {
		printf("%2ld: ", entry->disk_address);
		printf("%7u ", entry->dpme_boot_block);
		printf("%7u ", entry->dpme_boot_bytes);
		printf("%8x ", entry->dpme_load_addr);
		printf("%8x ", entry->dpme_goto_addr);
		printf("%8x ", entry->dpme_checksum);
		printf("%.32s", entry->dpme_processor_id);
		printf("\n");
	}
	printf("\n");
}


void
full_dump_partition_entry(struct partition_map *map, int ix)
{
	struct entry *entry;
	int i;
	uint32_t t;

	entry = find_entry_by_disk_address(ix, map);
	if (entry == NULL) {
		printf("No such partition\n");
		return;
	}
	printf("             signature: 0x%x\n", entry->dpme_signature);
	printf(" number of map entries: %u\n", entry->dpme_map_entries);
	printf("        physical start: %10u  length: %10u\n",
	    entry->dpme_pblock_start, entry->dpme_pblocks);
	printf("         logical start: %10u  length: %10u\n",
	    entry->dpme_lblock_start, entry->dpme_lblocks);

	printf("                 flags: 0x%x\n", entry->dpme_flags);
	printf("                        ");
	if (entry->dpme_flags & DPME_VALID)
		printf("valid ");
	if (entry->dpme_flags & DPME_ALLOCATED)
		printf("alloc ");
	if (entry->dpme_flags & DPME_IN_USE)
		printf("in-use ");
	if (entry->dpme_flags & DPME_BOOTABLE)
		printf("boot ");
	if (entry->dpme_flags & DPME_READABLE)
		printf("read ");
	if (entry->dpme_flags & DPME_WRITABLE)
		printf("write ");
	if (entry->dpme_flags & DPME_OS_PIC_CODE)
		printf("pic ");
	t = entry->dpme_flags >> 7;
	for (i = 7; i <= 31; i++) {
		if (t & 0x1)
			printf("%d ", i);
		t = t >> 1;
	}
	printf("\n");

	printf("                  name: '%.32s'\n", entry->dpme_name);
	printf("                  type: '%.32s'\n", entry->dpme_type);
	printf("      boot start block: %10u\n", entry->dpme_boot_block);
	printf("boot length (in bytes): %10u\n", entry->dpme_boot_bytes);
	printf("          load address: 0x%08x\n", entry->dpme_load_addr);
	printf("         start address: 0x%08x\n", entry->dpme_goto_addr);
	printf("              checksum: 0x%08x\n", entry->dpme_checksum);
	printf("             processor: '%.32s'\n", entry->dpme_processor_id);
	printf("dpme_reserved_1 -");
	dump_block(entry->dpme_reserved_1, sizeof(entry->dpme_reserved_1));
	printf("dpme_reserved_2 -");
	dump_block(entry->dpme_reserved_2, sizeof(entry->dpme_reserved_2));
	printf("dpme_reserved_3 -");
	dump_block(entry->dpme_reserved_3, sizeof(entry->dpme_reserved_3));
	printf("dpme_reserved_4 -");
	dump_block(entry->dpme_reserved_4, sizeof(entry->dpme_reserved_4));
}


void
dump_block(unsigned char *addr, int len)
{
	int i, j, limit1, limit;

#define LINE_LEN 16
#define UNIT_LEN  4
#define OTHER_LEN  8

	for (i = 0; i < len; i = limit) {
		limit1 = i + LINE_LEN;
		if (limit1 > len)
			limit = len;
		else
			limit = limit1;
		printf("\n%03x: ", i);
		for (j = i; j < limit1; j++) {
			if (j % UNIT_LEN == 0)
				printf(" ");
			if (j < limit)
				printf("%02x", addr[j]);
			else
				printf("  ");
		}
		printf(" ");
		for (j = i; j < limit; j++) {
			if (j % OTHER_LEN == 0)
				printf(" ");
			if (addr[j] < ' ')
				printf(".");
			else
				printf("%c", addr[j]);
		}
	}
	printf("\n");
}

void
full_dump_block_zero(struct partition_map *map)
{
	struct ddmap *m;
	int i;

	m = map->sbDDMap;

	printf("             signature: 0x%x\n", map->sbSig);
	printf("       size of a block: %u\n", map->sbBlkSize);
	printf("      number of blocks: %u\n", map->sbBlkCount);
	printf("           device type: 0x%x\n", map->sbDevType);
	printf("             device id: 0x%x\n", map->sbDevId);
	printf("                  data: 0x%x\n", map->sbData);
	printf("          driver count: %u\n", map->sbDrvrCount);
	for (i = 0; i < 8; i++) {
		if (m[i].ddBlock == 0 && m[i].ddSize == 0 && m[i].ddType == 0)
			break;
		printf("      driver %3u block: %u\n", i + 1, m[i].ddBlock);
		printf("        size in blocks: %u\n", m[i].ddSize);
		printf("           driver type: 0x%x\n", m[i].ddType);
	}
	printf("remainder of block -");
	dump_block(map->sbReserved, sizeof(map->sbReserved));
}

int
get_max_type_string_length(struct partition_map *map)
{
	struct entry *entry;
	int max, length;

	max = 0;

	LIST_FOREACH(entry, &map->disk_order, disk_entry) {
		length = strnlen(entry->dpme_type, DPISTRLEN);
		if (length > max)
			max = length;
	}

	return max;
}

int
get_max_name_string_length(struct partition_map *map)
{
	struct entry *entry;
	int max, length;

	max = 0;

	LIST_FOREACH(entry, &map->disk_order, disk_entry) {
		length = strnlen(entry->dpme_name, DPISTRLEN);
		if (length > max)
			max = length;
	}

	return max;
}

int
get_max_base_or_length(struct partition_map *map)
{
	struct entry *entry;
	int max;

	max = 0;

	LIST_FOREACH(entry, &map->disk_order, disk_entry) {
		if (entry->dpme_pblock_start > max)
			max = entry->dpme_pblock_start;
		if (entry->dpme_pblocks > max)
			max = entry->dpme_pblocks;
	}

	return max;
}
@


1.74
log
@Nuke pointless map field 'physical_block' and just use 'sbBlkSize' which is
set to the same value.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.73 2016/01/31 22:52:57 krw Exp $	*/
d57 1
a57 1
	if (fmt_scaled(map->sbBlkCount * map->sbBlkSize, buf) == 0)
d120 2
a121 2
	if (fmt_scaled(entry->dpme_pblocks * entry->the_map->sbBlkSize, buf) == 
	    0)
@


1.73
log
@Nuke djust_value_and_compute_prefix() and use fmt_scaled() to display
human readable sizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.72 2016/01/31 15:28:56 krw Exp $	*/
d84 1
a84 1
	       map->physical_block, map->name);
d138 1
a138 1
	    map->physical_block);
@


1.72
log
@Just call contains_driver() when you need to know rather than carrying a
flag around. More obviously current data. Nuke unnecessary variables
when displaying a partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.71 2016/01/31 14:55:41 krw Exp $	*/
d35 1
a40 1
void	adjust_value_and_compute_prefix(double *, int *);
d51 1
d53 1
a53 2
	double value;
	int i, prefix;
d55 6
a60 4
	value = ((double)map->sbBlkCount) * map->sbBlkSize;
	adjust_value_and_compute_prefix(&value, &prefix);
	printf("\nDevice block size=%u, Number of Blocks=%u (%1.1f%c)\n",
	       map->sbBlkSize, map->sbBlkCount, value, prefix);
d95 1
a95 1
	printf(" #: %*s %-*s %*s   %-*s ( size )\n", max_type_length, "type",
d107 2
a108 2
dump_partition_entry(struct entry *entry, int type_length,
    int name_length, int digits)
d110 1
a110 2
	double bytes;
	int j;
d120 5
a124 5
	bytes = ((double)entry->dpme_pblocks) * entry->the_map->physical_block;
	adjust_value_and_compute_prefix(&bytes, &j);
	if (j != ' ' && j != 'K')
		printf(" (%#5.1f%c)", bytes, j);
	printf("\n");
a371 32
}

void
adjust_value_and_compute_prefix(double *value, int *prefix)
{
	double bytes;
	int multiplier;

	bytes = *value;
	if (bytes < 1024.0) {
		multiplier = ' ';
	} else {
		bytes = bytes / 1024.0;
		if (bytes < 1024.0) {
			multiplier = 'K';
		} else {
			bytes = bytes / 1024.0;
			if (bytes < 1024.0) {
				multiplier = 'M';
			} else {
				bytes = bytes / 1024.0;
				if (bytes < 1024.0) {
					multiplier = 'G';
				} else {
					bytes = bytes / 1024.0;
					multiplier = 'T';
				}
			}
		}
	}
	*value = bytes;
	*prefix = multiplier;
@


1.71
log
@Move dump_block() declaration from io.h to io.c since it is not
used anywhere else.

Remove declarations of non-existant kPatchType and init_partition_map().
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.70 2016/01/31 13:53:23 krw Exp $	*/
a107 1
	struct partition_map *map;
d109 1
a109 1
	int j, driver;
a110 2
	map = entry->the_map;
	driver = entry->contains_driver ? '*' : ' ';
d113 2
a114 1
	printf("%c%-*.32s ", driver, name_length, entry->dpme_name);
d119 1
a119 1
	bytes = ((double)entry->dpme_pblocks) * map->physical_block;
@


1.70
log
@Apple sets lblock_start and lblocks to 0 in free space entries. Do
the same.

Don't use lblock_start or lblocks in calculation for length@@base
display. We no longer display lblock info there.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.69 2016/01/30 17:21:10 krw Exp $	*/
d41 1
@


1.69
log
@Move last three lines (#define's) from dpme.h to partition_map.h and
tweak #include's as necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.68 2016/01/30 17:09:11 krw Exp $	*/
a368 4
		if (entry->dpme_lblock_start > max)
			max = entry->dpme_lblock_start;
		if (entry->dpme_lblocks > max)
			max = entry->dpme_lblocks;
@


1.68
log
@Fold struct dpme into struct entry. Same reasons as for folding
struct block0 into struct partition_map. Easier to read code.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.67 2016/01/29 22:51:43 krw Exp $	*/
a35 1
#include "dpme.h"
@


1.67
log
@Fold struct block0 into struct partition map. There can be only one
and read/write_block0() can move the data from/to disk to/from
appropriate fields anywhere. Removes a bunch of dereferencing,
malloc'ing and pointer checking.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.66 2016/01/29 17:22:44 krw Exp $	*/
a108 1
	struct dpme *p;
a112 1
	p = entry->dpme;
d114 3
a116 2
	printf("%2ld: %*.32s", entry->disk_address, type_length, p->dpme_type);
	printf("%c%-*.32s ", driver, name_length, p->dpme_name);
d118 2
a119 2
	printf("%*u @@ %-*u", digits, p->dpme_pblocks, digits,
	    p->dpme_pblock_start);
d121 1
a121 1
	bytes = ((double) p->dpme_pblocks) * map->physical_block;
a133 1
	struct dpme *p;
d165 3
a167 3
		p = entry->dpme;
		printf("%2ld: %20.32s ", entry->disk_address, p->dpme_type);
		printf("%7u @@ %-7u ", p->dpme_pblocks, p->dpme_pblock_start);
d169 11
a179 11
		       (p->dpme_flags & DPME_VALID) ? 'V' : '.',
		       (p->dpme_flags & DPME_ALLOCATED) ? 'A' : '.',
		       (p->dpme_flags & DPME_IN_USE) ? 'I' : '.',
		       (p->dpme_flags & DPME_BOOTABLE) ? 'B' : '.',
		       (p->dpme_flags & DPME_READABLE) ? 'R' : '.',
		       (p->dpme_flags & DPME_WRITABLE) ? 'W' : '.',
		       (p->dpme_flags & DPME_OS_PIC_CODE) ? 'P' : '.',
		       (p->dpme_flags & DPME_OS_SPECIFIC_2) ? '2' : '.',
		       (p->dpme_flags & DPME_OS_SPECIFIC_1) ? '1' : '.');
		printf("( %7u @@ %-7u )\n", p->dpme_lblocks,
		    p->dpme_lblock_start);
a184 1
		p = entry->dpme;
d186 6
a191 6
		printf("%7u ", p->dpme_boot_block);
		printf("%7u ", p->dpme_boot_bytes);
		printf("%8x ", p->dpme_load_addr);
		printf("%8x ", p->dpme_goto_addr);
		printf("%8x ", p->dpme_checksum);
		printf("%.32s", p->dpme_processor_id);
d201 1
a201 2
	struct entry *cur;
	struct dpme *p;
d205 2
a206 2
	cur = find_entry_by_disk_address(ix, map);
	if (cur == NULL) {
d210 2
a211 3
	p = cur->dpme;
	printf("             signature: 0x%x\n", p->dpme_signature);
	printf(" number of map entries: %u\n", p->dpme_map_entries);
d213 1
a213 1
	    p->dpme_pblock_start, p->dpme_pblocks);
d215 1
a215 1
	    p->dpme_lblock_start, p->dpme_lblocks);
d217 1
a217 1
	printf("                 flags: 0x%x\n", (uint32_t)p->dpme_flags);
d219 1
a219 1
	if (p->dpme_flags & DPME_VALID)
d221 1
a221 1
	if (p->dpme_flags & DPME_ALLOCATED)
d223 1
a223 1
	if (p->dpme_flags & DPME_IN_USE)
d225 1
a225 1
	if (p->dpme_flags & DPME_BOOTABLE)
d227 1
a227 1
	if (p->dpme_flags & DPME_READABLE)
d229 1
a229 1
	if (p->dpme_flags & DPME_WRITABLE)
d231 1
a231 1
	if (p->dpme_flags & DPME_OS_PIC_CODE)
d233 1
a233 1
	t = p->dpme_flags >> 7;
d241 8
a248 8
	printf("                  name: '%.32s'\n", p->dpme_name);
	printf("                  type: '%.32s'\n", p->dpme_type);
	printf("      boot start block: %10u\n", p->dpme_boot_block);
	printf("boot length (in bytes): %10u\n", p->dpme_boot_bytes);
	printf("          load address: 0x%08x\n", p->dpme_load_addr);
	printf("         start address: 0x%08x\n", p->dpme_goto_addr);
	printf("              checksum: 0x%08x\n", p->dpme_checksum);
	printf("             processor: '%.32s'\n", p->dpme_processor_id);
d250 1
a250 1
	dump_block(p->dpme_reserved_1, sizeof(p->dpme_reserved_1));
d252 1
a252 1
	dump_block(p->dpme_reserved_2, sizeof(p->dpme_reserved_2));
d254 1
a254 1
	dump_block(p->dpme_reserved_3, sizeof(p->dpme_reserved_3));
d256 1
a256 1
	dump_block(p->dpme_reserved_4, sizeof(p->dpme_reserved_4));
d332 1
a332 1
		length = strnlen(entry->dpme->dpme_type, DPISTRLEN);
d349 1
a349 1
		length = strnlen(entry->dpme->dpme_name, DPISTRLEN);
d366 8
a373 8
		if (entry->dpme->dpme_pblock_start > max)
			max = entry->dpme->dpme_pblock_start;
		if (entry->dpme->dpme_pblocks > max)
			max = entry->dpme->dpme_pblocks;
		if (entry->dpme->dpme_lblock_start > max)
			max = entry->dpme->dpme_lblock_start;
		if (entry->dpme->dpme_lblocks > max)
			max = entry->dpme->dpme_lblocks;
@


1.66
log
@Tweak printing of partitions. Always show the pblock info in the
'p' command output. And always show the lblock info in the 'P'
command. Showing sometimes one and sometimes another with a subtle
extra character to indicate which is being shown is error prone.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.65 2016/01/29 15:06:37 krw Exp $	*/
a50 1
	struct block0 *p;
d55 1
a55 3
	p = map->block0;

	value = ((double) p->sbBlkCount) * p->sbBlkSize;
d58 1
a58 1
	       p->sbBlkSize, p->sbBlkCount, value, prefix);
d60 3
a62 2
	printf("DeviceType=0x%x, DeviceId=0x%x\n", p->sbDevType, p->sbDevId);
	if (p->sbDrvrCount > 0) {
d64 2
a65 2
		m = p->sbDDMap;
		for (i = 0; i < p->sbDrvrCount; i++) {
a133 1
	struct block0 *zp;
a145 2
	zp = map->block0;

d147 6
a152 6
	printf("signature 0x%x", zp->sbSig);
	printf("Block size=%u, Number of Blocks=%u\n", zp->sbBlkSize,
	    zp->sbBlkCount);
	printf("DeviceType=0x%x, DeviceId=0x%x, sbData=0x%x\n", zp->sbDevType,
	    zp->sbDevId, zp->sbData);
	if (zp->sbDrvrCount == 0) {
d155 4
a158 4
		printf("%u driver%s-\n", zp->sbDrvrCount,
		    (zp->sbDrvrCount > 1) ? "s" : "");
		m = zp->sbDDMap;
		for (i = 0; i < zp->sbDrvrCount; i++) {
a304 1
	struct block0 *zp;
d308 1
a308 6
	if (map->block0 == NULL) {
		printf("No block zero\n");
		return;
	}
	zp = map->block0;
	m = zp->sbDDMap;
d310 7
a316 7
	printf("             signature: 0x%x\n", zp->sbSig);
	printf("       size of a block: %u\n", zp->sbBlkSize);
	printf("      number of blocks: %u\n", zp->sbBlkCount);
	printf("           device type: 0x%x\n", zp->sbDevType);
	printf("             device id: 0x%x\n", zp->sbDevId);
	printf("                  data: 0x%x\n", zp->sbData);
	printf("          driver count: %u\n", zp->sbDrvrCount);
d325 1
a325 1
	dump_block(zp->sbReserved, sizeof(zp->sbReserved));
@


1.65
log
@Shorter names means a few whitespace adjustments.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.64 2016/01/29 14:54:38 krw Exp $	*/
a113 1
	uint32_t size;
d121 2
a122 15
	if (p->dpme_lblocks + p->dpme_lblock_start != p->dpme_pblocks) {
		printf("%*u+", digits, p->dpme_lblocks);
		size = p->dpme_lblocks;
	} else if (p->dpme_lblock_start != 0) {
		printf("%*u ", digits, p->dpme_lblocks);
		size = p->dpme_lblocks;
	} else {
		printf("%*u ", digits, p->dpme_pblocks);
		size = p->dpme_pblocks;
	}
	if (p->dpme_lblock_start == 0)
		printf("@@ %-*u", digits, p->dpme_pblock_start);
	else
		printf("@@~%-*u", digits, p->dpme_pblock_start +
		    p->dpme_lblock_start);
d124 1
a124 1
	bytes = ((double) size) * map->physical_block;
d170 1
a170 1
	       "flags        (logical)\n");
d185 2
a186 6
		if (p->dpme_lblock_start != 0 || p->dpme_pblocks !=
		    p->dpme_lblocks) {
			printf("(%u @@ %u)", p->dpme_lblocks,
			    p->dpme_lblock_start);
		}
		printf("\n");
@


1.64
log
@Rename struct partition_map_header to struct partition_map. No change to
.o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.63 2016/01/29 14:48:20 krw Exp $	*/
d228 1
a228 1
	struct dpme    *p;
d245 1
a245 1
	printf("                 flags: 0x%x\n", (uint32_t) p->dpme_flags);
@


1.63
log
@Rename struct partition_map to struct entry. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.62 2016/01/28 19:07:45 krw Exp $	*/
d42 1
a42 1
void	dump_block_zero(struct partition_map_header *);
d44 3
a46 3
int	get_max_base_or_length(struct partition_map_header *);
int	get_max_name_string_length(struct partition_map_header *);
int	get_max_type_string_length(struct partition_map_header *);
d49 1
a49 1
dump_block_zero(struct partition_map_header *map)
d78 1
a78 1
dump_partition_map(struct partition_map_header *map)
d110 1
a110 1
	struct partition_map_header *map;
d147 1
a147 1
show_data_structures(struct partition_map_header *map)
d225 1
a225 1
full_dump_partition_entry(struct partition_map_header *map, int ix)
d326 1
a326 1
full_dump_block_zero(struct partition_map_header *map)
d358 1
a358 1
get_max_type_string_length(struct partition_map_header *map)
d375 1
a375 1
get_max_name_string_length(struct partition_map_header *map)
d392 1
a392 1
get_max_base_or_length(struct partition_map_header *map)
@


1.62
log
@Hand rolled lists suck. First, replace disk_order with an LIST.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.61 2016/01/28 13:09:21 krw Exp $	*/
d43 1
a43 1
void	dump_partition_entry(struct partition_map *, int, int, int);
d80 1
a80 1
	struct partition_map *entry;
d107 1
a107 1
dump_partition_entry(struct partition_map *entry, int type_length,
d149 1
a149 1
	struct partition_map *entry;
d227 1
a227 1
	struct partition_map *cur;
d360 1
a360 1
	struct partition_map *entry;
d377 1
a377 1
	struct partition_map *entry;
d394 1
a394 1
	struct partition_map *entry;
@


1.61
log
@Since we don't allow maps to be created or opened with an invalid
block0, there is no point in checking later if block0 has magically
become invalid.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.60 2016/01/27 20:34:27 krw Exp $	*/
d30 2
d98 1
a98 2
	for (entry = map->disk_order; entry != NULL;
	     entry = entry->next_on_disk) {
d185 1
a185 2
	for (entry = map->disk_order; entry != NULL;
	    entry = entry->next_on_disk) {
d209 1
a209 2
	for (entry = map->disk_order; entry != NULL;
	    entry = entry->next_on_disk) {
d365 1
a365 2
	for (entry = map->disk_order; entry != NULL;
	    entry = entry->next_on_disk) {
d382 1
a382 2
	for (entry = map->disk_order; entry != NULL;
	    entry = entry->next_on_disk) {
d399 1
a399 2
	for (entry = map->disk_order; entry != NULL;
	    entry = entry->next_on_disk) {
@


1.60
log
@No need to copy dmpe_name to a buffer before printing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.59 2016/01/27 18:26:05 gsoares Exp $	*/
a54 2
	if (p->sbSig != BLOCK0_SIGNATURE)
		return;
a165 4
	if (zp->sbSig == BLOCK0_SIGNATURE)
		printf("\n");
	else
		printf(" should be 0x%x\n", BLOCK0_SIGNATURE);
@


1.59
log
@make sure to check malloc(3) return pointer against NULL.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.58 2016/01/27 14:47:53 krw Exp $	*/
d112 1
a112 2
	struct dpme    *p;
	char           *buf;
d121 1
a121 7

	buf = malloc(name_length + 1);
	if (buf == NULL)
		return;
	strlcpy(buf, p->dpme_name, name_length+1);
	printf("%c%-*.32s ", driver, name_length, buf);
	free(buf);
@


1.58
log
@We do not support logical_block != physical_block. Remove logical_block
field and left over code that checks for logical != physical.

Removes confusion with dmpe fields lblock_start and lblocks, which
have nothing to do with block sizes! lblock_start is the block
offset within the partition where the data actually starts. and
lblocks is the number of blocks of data within the partition. Both
are in units of *physical blocks*, a.k.a. disk sectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.57 2016/01/27 00:03:52 krw Exp $	*/
d124 2
@


1.57
log
@Nuke another (and I hope final) batch of superfluous '{}' around single
statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.56 2016/01/26 21:07:54 krw Exp $	*/
a51 1
	long t;
a69 8
			if (map->logical_block != p->sbBlkSize) {
				t = (m[i].ddSize * p->sbBlkSize) /
				    map->logical_block;
				printf("(%lu@@", t);
				t = m[i].ddBlock * p->sbBlkSize /
				    map->logical_block;
				printf("%lu)  ", t);
			}
d84 1
a84 1
	       map->logical_block, map->name);
d144 1
a144 1
	bytes = ((double) size) * map->logical_block;
d164 1
a164 1
	    map->logical_block);
@


1.56
log
@dpme_name and dpme_type are NUL-terminated in Apple code, so use
strlcpy() to fill them.

They are also supposed to be NUL-padded so zap previous contents
before copying in possibly shorter new values.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.55 2016/01/26 16:39:00 krw Exp $	*/
d147 1
a147 1
	if (p->dpme_lblock_start == 0) {
d149 1
a149 1
	} else {
a151 1
	}
d155 1
a155 1
	if (j != ' ' && j != 'K') {
a156 1
	}
d284 1
a284 1
		if (t & 0x1) {
a285 1
		}
d320 1
a320 1
		if (limit1 > len) {
d322 1
a322 1
		} else {
a323 1
		}
d326 1
a326 1
			if (j % UNIT_LEN == 0) {
d328 1
a328 2
			}
			if (j < limit) {
d330 1
a330 1
			} else {
a331 1
			}
d335 1
a335 1
			if (j % OTHER_LEN == 0) {
d337 1
a337 2
			}
			if (addr[j] < ' ') {
d339 1
a339 1
			} else {
a340 1
			}
d389 1
a389 1
		if (length > max) {
a390 1
		}
d407 1
a407 1
		if (length > max) {
a408 1
		}
@


1.55
log
@Whitespace, line wrapping fixes. Nuke many superfluous '{}' around single
statements. 0 -> NULL for pointer checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.54 2016/01/26 16:13:09 krw Exp $	*/
d133 1
a133 2
	strncpy(buf, p->dpme_name, name_length);
	buf[name_length] = 0;
@


1.54
log
@Whitespace, line wrapping fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.53 2016/01/25 23:43:20 krw Exp $	*/
d56 1
a56 1
	if (p->sbSig != BLOCK0_SIGNATURE) {
d58 1
a58 1
	}
d96 1
a96 1
	if (digits < 6) {
a97 1
	}
d99 1
a99 1
	if (max_type_length < 4) {
a100 1
	}
d102 1
a102 1
	if (max_name_length < 6) {
a103 1
	}
d185 1
a185 1
	if (zp->sbSig == BLOCK0_SIGNATURE) {
d187 1
a187 1
	} else {
a188 1
	}
d435 1
a435 1
		if (entry->dpme->dpme_pblock_start > max) {
d437 1
a437 2
		}
		if (entry->dpme->dpme_pblocks > max) {
d439 1
a439 2
		}
		if (entry->dpme->dpme_lblock_start > max) {
d441 1
a441 2
		}
		if (entry->dpme->dpme_lblocks > max) {
a442 1
		}
@


1.53
log
@Use new read/write_block0 and read/write_dpme which handle any
endian or alignment issues forcefully. Removes need for convert_*
functions so unhook convert.c from build. read/write_block become
static functions inside file_media.c.

Tweak struct block0 to stop trying to handle alignment issues by clever
declaration. Rely on the new functions to accurately translate between
on-disk and in-memory layouts.

Enables pdisk to work on amd64 and likely other architectures if
it's ever desirable. Does bring back DEV_BSIZE to pdisk.c since the
in-memory structure will *not* be 512 bytes on other archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.52 2016/01/25 21:51:23 krw Exp $	*/
d107 2
a108 4
	printf(" #: %*s %-*s %*s   %-*s ( size )\n",
	       max_type_length, "type",
	       max_name_length, "name",
	       digits, "length", digits, "base");
d178 2
a179 2
	       map->blocks_in_map, map->maximum_in_map,
	       map->media_size, map->logical_block);
d201 1
a201 1
		       (zp->sbDrvrCount > 1) ? "s" : "");
d214 1
a214 2
		printf("%2ld: %20.32s ",
		       entry->disk_address, p->dpme_type);
d235 1
a235 1
	       "goto_address checksum processor\n");
a299 1

d306 1
a306 1
	printf("dpme_reserved_3 -");
d308 1
d310 1
d312 1
d399 2
a400 1
	for (entry = map->disk_order; entry != NULL; entry = entry->next_on_disk) {
d418 2
a419 2
	for (entry = map->disk_order; entry != NULL; entry =
	    entry->next_on_disk) {
@


1.52
log
@Tweak fields in struct dpme to be more consistent with Apple's info.

Better comments, make all reserved fields uint8_t arrays, don't
claim uint32_t fields are actually pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.51 2016/01/25 03:26:54 jsg Exp $	*/
d64 1
a64 2
	printf("DeviceType=0x%x, DeviceId=0x%x\n",
	       p->sbDevType, p->sbDevId);
d67 1
a67 1
		m = (struct ddmap *)p->sbMap;
d204 1
a204 1
		m = (struct ddmap *)zp->sbMap;
d245 2
a246 2
		printf("%8x ", (uint32_t) p->dpme_load_addr);
		printf("%8x ", (uint32_t) p->dpme_goto_addr);
d310 1
a310 1
	printf("dpme_reserved_1 -");
a311 1
	printf("dpme_reserved_2 -");
a312 1
	printf("dpme_reserved_3 -");
d314 1
a314 2
	printf("dpme_reserved_4 -");
	dump_block(p->dpme_reserved_3, sizeof(p->dpme_reserved_4));
d372 1
d381 2
a382 3
	m = (struct ddmap *)zp->sbMap;
	for (i = 0; &m[i].ddType < &zp->sbMap[247]; i++) {
		if (m[i].ddBlock == 0 && m[i].ddSize == 0 && m[i].ddType == 0) {
a383 1
		}
d389 1
a389 2
	dump_block((unsigned char *)&m[i].ddBlock, (&zp->sbMap[247] -
	    ((unsigned short *)&m[i].ddBlock)) * 2);
@


1.51
log
@remove some uneeded includes
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.50 2016/01/24 15:23:33 krw Exp $	*/
d220 1
a220 1
		printf("%c%c%c%c%c%c%c%c%c%c%c%c ",
d229 1
a229 4
		       (p->dpme_flags & DPME_CHAINABLE) ? 'C' : '.',
		       (p->dpme_flags & DPME_DISKDRIVER) ? 'D' : '.',
		       (p->dpme_flags & (1 << 30)) ? 'M' : '.',
		       (p->dpme_flags & (1 << 31)) ? 'X' : '.');
a246 1
		printf("%8x ", (uint32_t) p->dpme_load_addr_2);
a247 1
		printf("%8x ", (uint32_t) p->dpme_goto_addr_2);
d249 1
a249 1
		printf("%.32s", p->dpme_process_id);
a270 1
	printf("             reserved1: 0x%x\n", p->dpme_reserved_1);
d307 2
a308 4
	printf("          load address: 0x%08x  0x%08x\n",
	       (uint32_t) p->dpme_load_addr, (uint32_t) p->dpme_load_addr_2);
	printf("         start address: 0x%08x  0x%08x\n",
	       (uint32_t) p->dpme_goto_addr, (uint32_t) p->dpme_goto_addr_2);
d310 5
a314 3
	printf("             processor: '%.32s'\n", p->dpme_process_id);
	printf("boot args field -");
	dump_block((unsigned char *)p->dpme_boot_args, 32 * 4);
d316 3
a318 1
	dump_block((unsigned char *)p->dpme_reserved_3, 62 * 4);
@


1.50
log
@Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.49 2016/01/24 15:18:50 krw Exp $	*/
a34 1
#include "file_media.h"
@


1.49
log
@Nuke get_align_long() and put_align_long() #define's. They don't do
anything according to gcc & cmp.

cmp suggested by & ok stefan@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.48 2016/01/24 01:38:32 krw Exp $	*/
d69 1
a69 1
		m = (struct ddmap *) p->sbMap;
d206 1
a206 1
		m = (struct ddmap *) zp->sbMap;
d321 1
a321 1
	dump_block((unsigned char *) p->dpme_boot_args, 32 * 4);
d323 1
a323 1
	dump_block((unsigned char *) p->dpme_reserved_3, 62 * 4);
d389 1
a389 1
	m = (struct ddmap *) zp->sbMap;
d399 2
a400 2
	dump_block((unsigned char *) &m[i].ddBlock, (&zp->sbMap[247] -
	    ((unsigned short *) &m[i].ddBlock)) * 2);
@


1.48
log
@Whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.47 2016/01/23 23:25:58 krw Exp $	*/
a39 2
#define get_align_long(x)	(*(x))

d71 2
a72 2
			printf("%d: %3u @@ %u, ", i + 1,
			       m[i].ddSize, get_align_long(&m[i].ddBlock));
d77 2
a78 2
				t = (get_align_long(&m[i].ddBlock) *
				    p->sbBlkSize) / map->logical_block;
d209 1
a209 2
			    get_align_long(&m[i].ddBlock), m[i].ddSize,
			    m[i].ddType);
@


1.47
log
@Nuke unused kPatchType. Nuke kStringNot and use " not' where needed.
Nuke kStringEmpty and use "" where needed. Nuke unused static 'g'.

Eliminate #include's in *.h files.

Some whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.46 2016/01/23 03:46:18 krw Exp $	*/
d42 6
a47 6
void		adjust_value_and_compute_prefix(double *, int *);
void		dump_block_zero(struct partition_map_header *);
void		dump_partition_entry(struct partition_map *, int, int, int);
int		get_max_base_or_length(struct partition_map_header *);
int		get_max_name_string_length(struct partition_map_header *);
int		get_max_type_string_length(struct partition_map_header *);
d50 1
a50 1
dump_block_zero(struct partition_map_header * map)
d52 2
a53 2
	struct block0  *p;
	struct ddmap   *m;
d91 1
a91 1
dump_partition_map(struct partition_map_header * map)
d126 2
a127 1
dump_partition_entry(struct partition_map * entry, int type_length, int name_length, int digits)
d174 1
a174 1
show_data_structures(struct partition_map_header * map)
d266 1
a266 1
full_dump_partition_entry(struct partition_map_header * map, int ix)
d373 1
a373 1
full_dump_block_zero(struct partition_map_header * map)
d407 1
a407 1
get_max_type_string_length(struct partition_map_header * map)
d425 1
a425 1
get_max_name_string_length(struct partition_map_header * map)
d444 1
a444 1
get_max_base_or_length(struct partition_map_header * map)
@


1.46
log
@Flip read_block() and write_block() back to taking sector addresses
instead of off_t values. Do the DEV_BSIZE multiplication in these two
functions.

Easier to read code and kills two #include <sys/param.h>.

Kill unused label.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.45 2016/01/23 01:43:13 krw Exp $	*/
d34 1
d36 1
a41 3
const char     *kStringEmpty = "";
const char     *kStringNot = " not";

d185 2
a186 3
	printf("Map is%s writable", rflag ? kStringNot : kStringEmpty);
	printf(" and has%s been changed\n", (map->changed) ? kStringEmpty :
	    kStringNot);
d206 1
a206 1
		       (zp->sbDrvrCount > 1) ? "s" : kStringEmpty);
@


1.45
log
@map->block0 is always allocated or the map is discarded.

So stop checking for NULL. Nuke get_block_zero() and just use
map->block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.44 2016/01/22 18:57:42 krw Exp $	*/
a28 2

#include <sys/param.h>		/* DEV_BSIZE */
@


1.44
log
@Change partition map field 'data' to 'dmpe'. Change 'create_data'
to 'create_dmpe'. Sweep up some 'struct dpme *data' to struct dpme
*dpme'.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.43 2016/01/22 17:35:16 krw Exp $	*/
d193 15
a207 2
	if (map->block0 == NULL) {
		printf("No block zero\n");
d209 7
a215 24
		zp = map->block0;

		printf("Block0:\n");
		printf("signature 0x%x", zp->sbSig);
		if (zp->sbSig == BLOCK0_SIGNATURE) {
			printf("\n");
		} else {
			printf(" should be 0x%x\n", BLOCK0_SIGNATURE);
		}
		printf("Block size=%u, Number of Blocks=%u\n",
		       zp->sbBlkSize, zp->sbBlkCount);
		printf("DeviceType=0x%x, DeviceId=0x%x, sbData=0x%x\n",
		       zp->sbDevType, zp->sbDevId, zp->sbData);
		if (zp->sbDrvrCount == 0) {
			printf("No drivers\n");
		} else {
			printf("%u driver%s-\n", zp->sbDrvrCount,
			       (zp->sbDrvrCount > 1) ? "s" : kStringEmpty);
			m = (struct ddmap *) zp->sbMap;
			for (i = 0; i < zp->sbDrvrCount; i++) {
				printf("%u: @@ %u for %u, type=0x%x\n", i + 1,
				       get_align_long(&m[i].ddBlock),
				       m[i].ddSize, m[i].ddType);
			}
@


1.43
log
@Rename map field 'misc' to 'block0' since that's what it is.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.42 2016/01/22 01:25:56 krw Exp $	*/
d139 1
a139 1
	p = entry->data;
d227 1
a227 1
		p = entry->data;
d256 1
a256 1
		p = entry->data;
d285 1
a285 1
	p = cur->data;
d422 1
a422 1
		length = strnlen(entry->data->dpme_type, DPISTRLEN);
d441 1
a441 1
		length = strnlen(entry->data->dpme_name, DPISTRLEN);
d460 2
a461 2
		if (entry->data->dpme_pblock_start > max) {
			max = entry->data->dpme_pblock_start;
d463 2
a464 2
		if (entry->data->dpme_pblocks > max) {
			max = entry->data->dpme_pblocks;
d466 2
a467 2
		if (entry->data->dpme_lblock_start > max) {
			max = entry->data->dpme_lblock_start;
d469 2
a470 2
		if (entry->data->dpme_lblocks > max) {
			max = entry->data->dpme_lblocks;
@


1.42
log
@In the "why use two variables when one would do" category, eliminate
the 'written' field and just use the 'changed' field to mediate
when it is appropriate to ask whether changes should be discarded.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.41 2016/01/22 00:38:53 krw Exp $	*/
d61 1
a61 1
	p = map->misc;
d193 1
a193 1
	if (map->misc == NULL) {
d196 1
a196 1
		zp = map->misc;
d386 1
a386 1
	if (map->misc == NULL) {
d390 1
a390 1
	zp = map->misc;
@


1.41
log
@Nuke 'expert' mode and the enabling, undocumented, '-d' flag by
just making all the commands available all the time. Document the
newly available commands.

Remove the former 'P' command (list partitions in base address
order) and use 'P' from expert mode (show map data structures).

Stop accepting uppercase aliases for commands documented as lower
case.

Bring the 'h' help text and man pages into agreement.

ok jasper@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.40 2016/01/21 15:33:21 krw Exp $	*/
d189 1
a189 2
	printf(", but%s changed", (map->changed) ? kStringEmpty : kStringNot);
	printf(" and has%s been written\n", (map->written) ? kStringEmpty :
@


1.40
log
@Hoist all file opening and ioctl calls into main(), passing a pointer to
a valid map to edit(). Should enable pledging a la fdisk at some point.

Since edit() always gets a valid map (and maintains its validity even when
'I'nitializing a new one) many checks for (map == NULL) are junked.

Remove some dances around block sizes by using DEV_BSIZE everywhere
since we don't support non-DEV_BSIZE (a.k.a. 512-byte) sectors.

Remove many superfluous #include statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.39 2016/01/21 02:52:52 krw Exp $	*/
d94 1
a94 1
dump_partition_map(struct partition_map_header * map, int disk_order)
d119 4
a122 13
	if (disk_order) {
		for (entry = map->disk_order; entry != NULL;
		     entry = entry->next_on_disk) {

			dump_partition_entry(entry, max_type_length,
			    max_name_length, digits);
		}
	} else {
		for (entry = map->base_order; entry != NULL;
		     entry = entry->next_by_base) {
			dump_partition_entry(entry, max_type_length,
			    max_name_length, digits);
		}
@


1.39
log
@Nuke 'writable' field now that it is always in sync with 'rflag'. Since
(!rflag && writable == 0) can't be true remove those warning blocks and
simply leave the not-writable warning when attempting to write the
map. Always show 'w' in the help and rely on the check and warning
in do_write_partition_map() so the user always gets a message.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.38 2016/01/19 14:50:40 krw Exp $	*/
a31 2
#include <err.h>

a34 2
#include <fcntl.h>
#include <errno.h>
a98 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
a192 4
	if (map == NULL) {
		printf("No partition map exists\n");
		return;
	}
a395 4
	if (map == NULL) {
		printf("No partition map exists\n");
		return;
	}
a428 3
	if (map == NULL) {
		return 0;
	}
a446 3
	if (map == NULL) {
		return 0;
	}
a465 3
	if (map == NULL) {
		return 0;
	}
@


1.38
log
@Bring code into line with man page and usage() by only allowing one
disk to be specified on the command line. Nuke dump() function and
hoist its few lines into main() as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.37 2016/01/18 21:50:53 krw Exp $	*/
d209 1
a209 2
	printf("Map is%s writable", (map->writable) ? kStringEmpty :
	    kStringNot);
@


1.37
log
@The contents of the Apple_Patches partition is none of our business.
Stop pretending we care or know what's in there. Remove 'debugging'
mode command to examine the partition contents and the supporting
code.

ok deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.36 2016/01/18 17:57:35 krw Exp $	*/
a54 18

int
dump(char *name)
{
	struct partition_map_header *map;
	int junk;

	map = open_partition_map(name, &junk);
	if (map == NULL) {
		return 0;
	}
	dump_partition_map(map, 1);

	close_partition_map(map);

	return 1;
}

@


1.36
log
@struct file_media had 1 field left. And one place where struct
file_media was actually stored. So move the last field (fd) into
the place formerly used to store pointer to the instance. As a
result we can just pass fd's around rather than pointers to a struct
containing a fd.

close_file_media() becomes empty but for a close(). So just use
close() and nuke close_file_media().
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.35 2016/01/18 15:17:22 krw Exp $	*/
a45 20
struct patchdescriptor {
	unsigned long	patchSig;
	unsigned short	majorVers;
	unsigned short	minorVers;
	unsigned long	flags;
	unsigned long	patchOffset;
	unsigned long	patchSize;
	unsigned long	patchCRC;
	unsigned long	patchDescriptorLen;
	unsigned char	patchName[33];
	unsigned char	patchVendor[1];
};

struct patchlist {
	unsigned short	numPatchBlocks;	/* number of disk blocks to hold the
					 * patch list */
	unsigned short	numPatches;	/* number of patches in list */
	struct patchdescriptor thePatch[1];
};

a455 70
}


void
display_patches(struct partition_map * entry)
{
	static unsigned char *patch_block;
	struct patchdescriptor *q;
	struct patchlist *p;
	unsigned char  *next, *s;
	long long offset;
	int i;

	offset = entry->data->dpme_pblock_start;
	offset = ((long long) entry->data->dpme_pblock_start) *
	    entry->the_map->logical_block;
	if (patch_block == NULL) {
		patch_block = malloc(DEV_BSIZE);
		if (patch_block == NULL) {
			warn("can't allocate memory for patch block buffer");
			return;
		}
	}
	if (read_file_media(entry->the_map->fd, (long long) offset, DEV_BSIZE,
	    (char *) patch_block) == 0) {
		warn("Can't read patch block");
		return;
	}
	p = (struct patchlist *) patch_block;
	if (p->numPatchBlocks != 1) {
		i = p->numPatchBlocks;
		free(patch_block);
		patch_block = reallocarray(NULL, i, DEV_BSIZE);
		if (patch_block == NULL) {
			warn("can't allocate memory for patch blocks buffer");
			return;
		}
		s = patch_block + DEV_BSIZE * i;
		while (i > 0) {
			s -= DEV_BSIZE;
			i -= 1;
			if (read_file_media(entry->the_map->fd, offset + i,
			    DEV_BSIZE, (char *)s) == 0) {
				warn("Can't read patch block %d", i);
				return;
			}
		}
		p = (struct patchlist *) patch_block;
	}
	printf("Patch list (%d entries)\n", p->numPatches);
	q = p->thePatch;
	for (i = 0; i < p->numPatches; i++) {
		printf("%2d signature: '%.4s'\n", i + 1, (char *) &q->patchSig);
		printf("     version: %d.%d\n", q->majorVers, q->minorVers);
		printf("       flags: 0x%lx\n", q->flags);
		printf("      offset: %ld\n", q->patchOffset);
		printf("        size: %ld\n", q->patchSize);
		printf("         CRC: 0x%lx\n", q->patchCRC);
		printf("        name: '%.*s'\n", q->patchName[0],
		    &q->patchName[1]);
		printf("      vendor: '%.*s'\n", q->patchVendor[0],
		    &q->patchVendor[1]);
		next = ((unsigned char *) q) + q->patchDescriptorLen;
		s = &q->patchVendor[q->patchVendor[0] + 1];
		if (next > s) {
			printf("remainder of entry -");
			dump_block(s, next - s);
		}
		q = (struct patchdescriptor *) next;
	}
@


1.35
log
@Run indent(1) over it and tweak the results a bit manually to look more
KNF'ish.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.34 2016/01/17 23:18:19 krw Exp $	*/
a483 1
	struct file_media *m;
a489 1
	m = entry->the_map->m;
d499 1
a499 1
	if (read_file_media(m, (long long) offset, DEV_BSIZE,
d517 2
a518 2
			if (read_file_media(m, offset + i, DEV_BSIZE,
			    (char *)s) == 0) {
@


1.34
log
@Change "//" comments to "/**/". Nuke really stupid ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.33 2016/01/17 19:39:20 krw Exp $	*/
d30 1
a30 1
#include <sys/param.h>	/* DEV_BSIZE */
d47 10
a56 10
    unsigned long	patchSig;
    unsigned short	majorVers;
    unsigned short	minorVers;
    unsigned long	flags;
    unsigned long	patchOffset;
    unsigned long	patchSize;
    unsigned long	patchCRC;
    unsigned long	patchDescriptorLen;
    unsigned char	patchName[33];
    unsigned char	patchVendor[1];
d60 4
a63 3
    unsigned short numPatchBlocks;	/* number of disk blocks to hold the patch list */
    unsigned short numPatches;		/* number of patches in list */
    struct patchdescriptor thePatch[1];
d66 2
a67 2
const char * kStringEmpty	= "";
const char * kStringNot		= " not";
d69 6
a74 6
void adjust_value_and_compute_prefix(double *, int *);
void dump_block_zero(struct partition_map_header *);
void dump_partition_entry(struct partition_map *, int, int, int);
int get_max_base_or_length(struct partition_map_header *);
int get_max_name_string_length(struct partition_map_header *);
int get_max_type_string_length(struct partition_map_header *);
d79 2
a80 2
    struct partition_map_header *map;
    int junk;
d82 5
a86 6
    map = open_partition_map(name, &junk);
    if (map == NULL) {
	return 0;
    }

    dump_partition_map(map, 1);
d88 1
a88 1
    close_partition_map(map);
d90 1
a90 1
    return 1;
d95 1
a95 1
dump_block_zero(struct partition_map_header *map)
d97 33
a129 33
    struct block0 *p;
    struct ddmap *m;
    int i;
    double value;
    int prefix;
    long t;

    p = map->misc;
    if (p->sbSig != BLOCK0_SIGNATURE) {
	return;
    }

    value = ((double)p->sbBlkCount) * p->sbBlkSize;
    adjust_value_and_compute_prefix(&value, &prefix);
    printf("\nDevice block size=%u, Number of Blocks=%u (%1.1f%c)\n",
	    p->sbBlkSize, p->sbBlkCount, value, prefix);

    printf("DeviceType=0x%x, DeviceId=0x%x\n",
	    p->sbDevType, p->sbDevId);
    if (p->sbDrvrCount > 0) {
	printf("Drivers-\n");
	m = (struct ddmap *) p->sbMap;
	for (i = 0; i < p->sbDrvrCount; i++) {
	    printf("%d: %3u @@ %u, ", i+1,
		    m[i].ddSize, get_align_long(&m[i].ddBlock));
	    if (map->logical_block != p->sbBlkSize) {
		t = (m[i].ddSize * p->sbBlkSize) / map->logical_block;
		printf("(%lu@@", t);
		t = (get_align_long(&m[i].ddBlock) * p->sbBlkSize)
			/ map->logical_block;
		printf("%lu)  ", t);
	    }
	    printf("type=0x%x\n", m[i].ddType);
d131 1
a131 2
    }
    printf("\n");
d136 1
a136 1
dump_partition_map(struct partition_map_header *map, int disk_order)
d138 2
a139 28
    struct partition_map * entry;
    int max_type_length;
    int max_name_length;
    int digits;

    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    printf("\nPartition map (with %d byte blocks) on '%s'\n",
	map->logical_block, map->name);

    digits = number_of_digits(get_max_base_or_length(map));
    if (digits < 6) {
	digits = 6;
    }
    max_type_length = get_max_type_string_length(map);
    if (max_type_length < 4) {
        max_type_length = 4;
    }
    max_name_length = get_max_name_string_length(map);
    if (max_name_length < 6) {
	max_name_length = 6;
    }
    printf(" #: %*s %-*s %*s   %-*s ( size )\n",
	    max_type_length, "type",
	    max_name_length, "name",
	    digits, "length", digits, "base");
d141 6
a146 3
    if (disk_order) {
	for (entry = map->disk_order; entry != NULL;
		entry = entry->next_on_disk) {
d148 20
a167 5
	    dump_partition_entry(entry, max_type_length, max_name_length, digits);
	}
    } else {
	for (entry = map->base_order; entry != NULL;
		entry = entry->next_by_base) {
d169 9
a177 1
	    dump_partition_entry(entry, max_type_length, max_name_length, digits);
d179 1
a179 2
    }
    dump_block_zero(map);
d184 1
a184 1
dump_partition_entry(struct partition_map *entry, int type_length, int name_length, int digits)
d186 6
a191 40
    struct partition_map_header *map;
    int j;
    struct dpme *p;
    uint32_t size;
    double bytes;
    int driver;
    char *buf;

    map = entry->the_map;
    p = entry->data;
    driver = entry->contains_driver? '*': ' ';
    printf("%2ld: %*.32s", entry->disk_address, type_length, p->dpme_type);

    buf = malloc(name_length+1);
    strncpy(buf, p->dpme_name, name_length);
    buf[name_length] = 0;
    printf("%c%-*.32s ", driver, name_length, buf);
    free(buf);

    if (p->dpme_lblocks + p->dpme_lblock_start != p->dpme_pblocks) {
	printf("%*u+", digits, p->dpme_lblocks);
	size = p->dpme_lblocks;
    } else if (p->dpme_lblock_start != 0) {
	printf("%*u ", digits, p->dpme_lblocks);
	size = p->dpme_lblocks;
    } else {
	printf("%*u ", digits, p->dpme_pblocks);
	size = p->dpme_pblocks;
    }
    if (p->dpme_lblock_start == 0) {
	printf("@@ %-*u", digits, p->dpme_pblock_start);
    } else {
	printf("@@~%-*u", digits, p->dpme_pblock_start + p->dpme_lblock_start);
    }

    bytes = ((double)size) * map->logical_block;
    adjust_value_and_compute_prefix(&bytes, &j);
    if (j != ' ' && j != 'K') {
	printf(" (%#5.1f%c)", bytes, j);
    }
d193 34
a226 1
    printf("\n");
d231 1
a231 1
show_data_structures(struct partition_map_header *map)
d233 20
a252 23
    struct block0 *zp;
    struct ddmap *m;
    int i;
    struct partition_map * entry;
    struct dpme *p;

    if (map == NULL) {
	printf("No partition map exists\n");
	return;
    }
    printf("Header:\n");
    printf("map %d blocks out of %d,  media %lu blocks (%d byte blocks)\n",
	    map->blocks_in_map, map->maximum_in_map,
	    map->media_size, map->logical_block);
    printf("Map is%s writable", (map->writable)?kStringEmpty:kStringNot);
    printf(", but%s changed", (map->changed)?kStringEmpty:kStringNot);
    printf(" and has%s been written\n", (map->written)?kStringEmpty:kStringNot);
    printf("\n");

    if (map->misc == NULL) {
	printf("No block zero\n");
    } else {
	zp = map->misc;
d254 2
a255 4
	printf("Block0:\n");
	printf("signature 0x%x", zp->sbSig);
	if (zp->sbSig == BLOCK0_SIGNATURE) {
	    printf("\n");
d257 25
a281 1
	    printf(" should be 0x%x\n", BLOCK0_SIGNATURE);
d283 28
a310 40
	printf("Block size=%u, Number of Blocks=%u\n",
		zp->sbBlkSize, zp->sbBlkCount);
	printf("DeviceType=0x%x, DeviceId=0x%x, sbData=0x%x\n",
		zp->sbDevType, zp->sbDevId, zp->sbData);
	if (zp->sbDrvrCount == 0) {
	    printf("No drivers\n");
	} else {
	    printf("%u driver%s-\n", zp->sbDrvrCount,
		    (zp->sbDrvrCount>1)?"s":kStringEmpty);
	    m = (struct ddmap *) zp->sbMap;
	    for (i = 0; i < zp->sbDrvrCount; i++) {
            printf("%u: @@ %u for %u, type=0x%x\n", i+1,
		   get_align_long(&m[i].ddBlock),
		   m[i].ddSize, m[i].ddType);
	    }
	}
    }
    printf("\n");
    printf(" #:                 type  length   base    "
	    "flags        (logical)\n");
    for (entry = map->disk_order; entry != NULL; entry = entry->next_on_disk) {
	p = entry->data;
	printf("%2ld: %20.32s ",
		entry->disk_address, p->dpme_type);
	printf("%7u @@ %-7u ", p->dpme_pblocks, p->dpme_pblock_start);
	printf("%c%c%c%c%c%c%c%c%c%c%c%c ",
		(p->dpme_flags & DPME_VALID)?'V':'.',
		(p->dpme_flags & DPME_ALLOCATED)?'A':'.',
		(p->dpme_flags & DPME_IN_USE)?'I':'.',
		(p->dpme_flags & DPME_BOOTABLE)?'B':'.',
		(p->dpme_flags & DPME_READABLE)?'R':'.',
		(p->dpme_flags & DPME_WRITABLE)?'W':'.',
		(p->dpme_flags & DPME_OS_PIC_CODE)?'P':'.',
		(p->dpme_flags & DPME_OS_SPECIFIC_2)?'2':'.',
		(p->dpme_flags & DPME_CHAINABLE)?'C':'.',
		(p->dpme_flags & DPME_DISKDRIVER)?'D':'.',
		(p->dpme_flags & (1<<30))?'M':'.',
		(p->dpme_flags & (1<<31))?'X':'.');
	if (p->dpme_lblock_start != 0 || p->dpme_pblocks != p->dpme_lblocks) {
	    printf("(%u @@ %u)", p->dpme_lblocks, p->dpme_lblock_start);
d313 16
a328 15
    }
    printf("\n");
    printf(" #:  booter   bytes      load_address      "
	    "goto_address checksum processor\n");
    for (entry = map->disk_order; entry != NULL; entry = entry->next_on_disk) {
	p = entry->data;
	printf("%2ld: ", entry->disk_address);
	printf("%7u ", p->dpme_boot_block);
	printf("%7u ", p->dpme_boot_bytes);
	printf("%8x ", (uint32_t)p->dpme_load_addr);
	printf("%8x ", (uint32_t)p->dpme_load_addr_2);
	printf("%8x ", (uint32_t)p->dpme_goto_addr);
	printf("%8x ", (uint32_t)p->dpme_goto_addr_2);
	printf("%8x ", p->dpme_checksum);
	printf("%.32s", p->dpme_process_id);
a329 2
    }
    printf("\n");
d334 1
a334 1
full_dump_partition_entry(struct partition_map_header *map, int ix)
d336 59
a394 51
    struct partition_map * cur;
    struct dpme *p;
    int i;
    uint32_t t;

    cur = find_entry_by_disk_address(ix, map);
    if (cur == NULL) {
	printf("No such partition\n");
	return;
    }

    p = cur->data;
    printf("             signature: 0x%x\n", p->dpme_signature);
    printf("             reserved1: 0x%x\n", p->dpme_reserved_1);
    printf(" number of map entries: %u\n", p->dpme_map_entries);
    printf("        physical start: %10u  length: %10u\n", p->dpme_pblock_start, p->dpme_pblocks);
    printf("         logical start: %10u  length: %10u\n", p->dpme_lblock_start, p->dpme_lblocks);

    printf("                 flags: 0x%x\n", (uint32_t)p->dpme_flags);
    printf("                        ");
    if (p->dpme_flags & DPME_VALID) printf("valid ");
    if (p->dpme_flags & DPME_ALLOCATED) printf("alloc ");
    if (p->dpme_flags & DPME_IN_USE) printf("in-use ");
    if (p->dpme_flags & DPME_BOOTABLE) printf("boot ");
    if (p->dpme_flags & DPME_READABLE) printf("read ");
    if (p->dpme_flags & DPME_WRITABLE) printf("write ");
    if (p->dpme_flags & DPME_OS_PIC_CODE) printf("pic ");
    t = p->dpme_flags >> 7;
    for (i = 7; i <= 31; i++) {
	if (t & 0x1) {
	    printf("%d ", i);
	}
	t = t >> 1;
    }
    printf("\n");

    printf("                  name: '%.32s'\n", p->dpme_name);
    printf("                  type: '%.32s'\n", p->dpme_type);

    printf("      boot start block: %10u\n", p->dpme_boot_block);
    printf("boot length (in bytes): %10u\n", p->dpme_boot_bytes);
    printf("          load address: 0x%08x  0x%08x\n",
		(uint32_t)p->dpme_load_addr, (uint32_t)p->dpme_load_addr_2);
    printf("         start address: 0x%08x  0x%08x\n",
		(uint32_t)p->dpme_goto_addr, (uint32_t)p->dpme_goto_addr_2);
    printf("              checksum: 0x%08x\n", p->dpme_checksum);
    printf("             processor: '%.32s'\n", p->dpme_process_id);
    printf("boot args field -");
    dump_block((unsigned char *)p->dpme_boot_args, 32*4);
    printf("dpme_reserved_3 -");
    dump_block((unsigned char *)p->dpme_reserved_3, 62*4);
d401 2
a402 4
    int i;
    int j;
    int limit1;
    int limit;
d407 18
a424 10
    for (i = 0; i < len; i = limit) {
	limit1 = i + LINE_LEN;
	if (limit1 > len) {
	    limit = len;
	} else {
	    limit = limit1;
	}
	printf("\n%03x: ", i);
	for (j = i; j < limit1; j++) {
	    if (j % UNIT_LEN == 0) {
d426 10
a435 17
	    }
	    if (j < limit) {
		printf("%02x", addr[j]);
	    } else {
		printf("  ");
	    }
	}
	printf(" ");
	for (j = i; j < limit; j++) {
	    if (j % OTHER_LEN == 0) {
		printf(" ");
	    }
	    if (addr[j] < ' ') {
		printf(".");
	    } else {
		printf("%c", addr[j]);
	    }
d437 1
a437 2
    }
    printf("\n");
d441 1
a441 1
full_dump_block_zero(struct partition_map_header *map)
d443 33
a475 33
    struct block0 *zp;
    struct ddmap *m;
    int i;

    if (map == NULL) {
	printf("No partition map exists\n");
	return;
    }

    if (map->misc == NULL) {
	printf("No block zero\n");
	return;
    }
    zp = map->misc;

    printf("             signature: 0x%x\n", zp->sbSig);
    printf("       size of a block: %u\n", zp->sbBlkSize);
    printf("      number of blocks: %u\n", zp->sbBlkCount);
    printf("           device type: 0x%x\n", zp->sbDevType);
    printf("             device id: 0x%x\n", zp->sbDevId);
    printf("                  data: 0x%x\n", zp->sbData);
    printf("          driver count: %u\n", zp->sbDrvrCount);
    m = (struct ddmap *) zp->sbMap;
    for (i = 0; &m[i].ddType < &zp->sbMap[247]; i++) {
	if (m[i].ddBlock == 0 && m[i].ddSize == 0 && m[i].ddType == 0) {
	    break;
	}
	printf("      driver %3u block: %u\n", i+1, m[i].ddBlock);
	printf("        size in blocks: %u\n", m[i].ddSize);
	printf("           driver type: 0x%x\n", m[i].ddType);
    }
    printf("remainder of block -");
    dump_block((unsigned char *)&m[i].ddBlock, (&zp->sbMap[247]-((unsigned short *)&m[i].ddBlock))*2);
d480 1
a480 1
display_patches(struct partition_map *entry)
d482 12
a493 14
    long long offset;
    struct file_media *m;
    static unsigned char *patch_block;
    struct patchlist *p;
    struct patchdescriptor *q;
    unsigned char *next;
    unsigned char *s;
    int i;

    offset = entry->data->dpme_pblock_start;
    m = entry->the_map->m;
    offset = ((long long) entry->data->dpme_pblock_start) * entry->the_map->logical_block;
    if (patch_block == NULL) {
	patch_block = malloc(DEV_BSIZE);
d495 5
a499 2
	    warn("can't allocate memory for patch block buffer");
	    return;
d501 3
a503 20
    }
    if (read_file_media(m, (long long)offset, DEV_BSIZE, (char *)patch_block) == 0) {
	warn("Can't read patch block");
	return;
    }
    p = (struct patchlist *) patch_block;
    if (p->numPatchBlocks != 1) {
	i = p->numPatchBlocks;
	free(patch_block);
	patch_block = reallocarray(NULL, i, DEV_BSIZE);
	if (patch_block == NULL) {
	    warn("can't allocate memory for patch blocks buffer");
	    return;
	}
	s = patch_block + DEV_BSIZE*i;
	while (i > 0) {
	    s -= DEV_BSIZE;
	    i -= 1;
	    if (read_file_media(m, offset+i, DEV_BSIZE, (char *)s) == 0) {
		warn("Can't read patch block %d", i);
a504 1
	    }
d507 40
a546 17
    }
    printf("Patch list (%d entries)\n", p->numPatches);
    q = p->thePatch;
    for (i = 0; i < p->numPatches; i++) {
	printf("%2d signature: '%.4s'\n", i+1, (char *)&q->patchSig);
	printf("     version: %d.%d\n", q->majorVers, q->minorVers);
	printf("       flags: 0x%lx\n", q->flags);
	printf("      offset: %ld\n", q->patchOffset);
	printf("        size: %ld\n", q->patchSize);
	printf("         CRC: 0x%lx\n", q->patchCRC);
	printf("        name: '%.*s'\n", q->patchName[0], &q->patchName[1]);
	printf("      vendor: '%.*s'\n", q->patchVendor[0], &q->patchVendor[1]);
	next = ((unsigned char *)q) + q->patchDescriptorLen;
	s = &q->patchVendor[q->patchVendor[0]+1];
	if (next > s) {
	    printf("remainder of entry -");
	    dump_block(s, next-s);
a547 2
	q = (struct patchdescriptor *)next;
    }
d551 1
a551 1
get_max_type_string_length(struct partition_map_header *map)
d553 2
a554 3
    struct partition_map * entry;
    int max;
    int length;
d556 4
a559 3
    if (map == NULL) {
	return 0;
    }
d561 5
a565 6
    max = 0;

    for (entry = map->disk_order; entry != NULL; entry = entry->next_on_disk) {
	length = strnlen(entry->data->dpme_type, DPISTRLEN);
	if (length > max) {
	    max = length;
a566 1
    }
d568 1
a568 1
    return max;
d572 1
a572 1
get_max_name_string_length(struct partition_map_header *map)
d574 2
a575 3
    struct partition_map * entry;
    int max;
    int length;
d577 4
a580 3
    if (map == NULL) {
	return 0;
    }
d582 6
a587 6
    max = 0;

    for (entry = map->disk_order; entry != NULL; entry = entry->next_on_disk) {
	length = strnlen(entry->data->dpme_name, DPISTRLEN);
	if (length > max) {
	    max = length;
a588 1
    }
d590 1
a590 1
    return max;
d594 1
a594 1
get_max_base_or_length(struct partition_map_header *map)
d596 2
a597 2
    struct partition_map * entry;
    int max;
d599 4
a602 3
    if (map == NULL) {
	return 0;
    }
d604 14
a617 14
    max = 0;

    for (entry = map->disk_order; entry != NULL; entry = entry->next_on_disk) {
	if (entry->data->dpme_pblock_start > max) {
	    max = entry->data->dpme_pblock_start;
	}
	if (entry->data->dpme_pblocks > max) {
	    max = entry->data->dpme_pblocks;
	}
	if (entry->data->dpme_lblock_start > max) {
	    max = entry->data->dpme_lblock_start;
	}
	if (entry->data->dpme_lblocks > max) {
	    max = entry->data->dpme_lblocks;
a618 1
    }
d620 1
a620 1
    return max;
d626 2
a627 2
    double bytes;
    int multiplier;
d629 1
a629 5
    bytes = *value;
    if (bytes < 1024.0) {
	multiplier = ' ';
    } else {
	bytes = bytes / 1024.0;
d631 1
a631 1
	    multiplier = 'K';
a632 4
	    bytes = bytes / 1024.0;
	    if (bytes < 1024.0) {
		multiplier = 'M';
	    } else {
d635 1
a635 1
		    multiplier = 'G';
d637 12
a648 2
		    bytes = bytes / 1024.0;
		    multiplier = 'T';
a649 1
	    }
d651 2
a652 3
    }
    *value = bytes;
    *prefix = multiplier;
@


1.33
log
@Reduce namespace pollution by eliminating parameter names from forward
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.32 2016/01/17 19:15:55 krw Exp $	*/
d3 5
a7 5
//
// dump.c - dumping partition maps
//
// Written by Eryk Vershen
//
d60 2
a61 2
    unsigned short numPatchBlocks;	// number of disk blocks to hold the patch list
    unsigned short numPatches;		// number of patches in list
@


1.32
log
@Kill leading, imbedded, trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.31 2016/01/17 18:57:52 krw Exp $	*/
a43 4

//
// Defines
//
a45 5

//
// Types
//

a64 5

//
// Global Constants
//

d68 6
a74 19
//
// Global Variables
//


//
// Forward declarations
//
void adjust_value_and_compute_prefix(double *value, int *prefix);
void dump_block_zero(struct partition_map_header *map);
void dump_partition_entry(struct partition_map *entry, int type_length, int name_length, int digits);
int get_max_base_or_length(struct partition_map_header *map);
int get_max_name_string_length(struct partition_map_header *map);
int get_max_type_string_length(struct partition_map_header *map);


//
// Routines
//
@


1.31
log
@Remove a bunch of ridiculous and uninformative comments like "// Defines".
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.30 2016/01/17 18:44:59 krw Exp $	*/
d389 4
a392 4
    	if (t & 0x1) {
    	    printf("%d ", i);
    	}
    	t = t >> 1;
d426 6
a431 6
    	limit1 = i + LINE_LEN;
    	if (limit1 > len) {
    	    limit = len;
    	} else {
    	    limit = limit1;
    	}
d433 1
a433 1
    	for (j = i; j < limit1; j++) {
d442 1
a442 1
    	}
d444 1
a444 1
    	for (j = i; j < limit; j++) {
d448 6
a453 6
    	    if (addr[j] < ' ') {
    	    	printf(".");
    	    } else {
    	    	printf("%c", addr[j]);
    	    }
    	}
d485 3
a487 3
    	if (m[i].ddBlock == 0 && m[i].ddSize == 0 && m[i].ddType == 0) {
    	    break;
    	}
@


1.30
log
@The great de-typedef'ification concludes with u32 -> uint32_t. And a
bunch of consequent printf() format corrections.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.29 2016/01/17 17:44:05 krw Exp $	*/
a33 1
// for *printf()
a34 2

// for malloc() & free()
a35 2

// for strcmp()
a36 1
// for O_RDONLY
a37 1
// for errno
@


1.29
log
@The great de-typedef'ification continues.

partition_map -> struct partition_map
partition_map_header -> struct partition_map_header
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.28 2016/01/17 16:44:01 krw Exp $	*/
d145 1
a145 1
    printf("\nDevice block size=%u, Number of Blocks=%lu (%1.1f%c)\n",
d154 1
a154 1
	    printf("%u: %3u @@ %lu, ", i+1,
d225 1
a225 1
    u32 size;
d242 1
a242 1
	printf("%*lu+", digits, p->dpme_lblocks);
d245 1
a245 1
	printf("%*lu ", digits, p->dpme_lblocks);
d248 1
a248 1
	printf("%*lu ", digits, p->dpme_pblocks);
d252 1
a252 1
	printf("@@ %-*lu", digits, p->dpme_pblock_start);
d254 1
a254 1
	printf("@@~%-*lu", digits, p->dpme_pblock_start + p->dpme_lblock_start);
d301 1
a301 1
	printf("Block size=%u, Number of Blocks=%lu\n",
d303 1
a303 1
	printf("DeviceType=0x%x, DeviceId=0x%x, sbData=0x%lx\n",
d312 1
a312 1
            printf("%u: @@ %lu for %u, type=0x%x\n", i+1,
d325 1
a325 1
	printf("%7lu @@ %-7lu ", p->dpme_pblocks, p->dpme_pblock_start);
d340 1
a340 1
	    printf("(%lu @@ %lu)", p->dpme_lblocks, p->dpme_lblock_start);
d350 7
a356 7
	printf("%7lu ", p->dpme_boot_block);
	printf("%7lu ", p->dpme_boot_bytes);
	printf("%8lx ", (u32)p->dpme_load_addr);
	printf("%8lx ", (u32)p->dpme_load_addr_2);
	printf("%8lx ", (u32)p->dpme_goto_addr);
	printf("%8lx ", (u32)p->dpme_goto_addr_2);
	printf("%8lx ", p->dpme_checksum);
d370 1
a370 1
    u32 t;
d381 3
a383 3
    printf(" number of map entries: %ld\n", p->dpme_map_entries);
    printf("        physical start: %10lu  length: %10lu\n", p->dpme_pblock_start, p->dpme_pblocks);
    printf("         logical start: %10lu  length: %10lu\n", p->dpme_lblock_start, p->dpme_lblocks);
d385 1
a385 1
    printf("                 flags: 0x%lx\n", (u32)p->dpme_flags);
d406 7
a412 7
    printf("      boot start block: %10lu\n", p->dpme_boot_block);
    printf("boot length (in bytes): %10lu\n", p->dpme_boot_bytes);
    printf("          load address: 0x%08lx  0x%08lx\n",
		(u32)p->dpme_load_addr, (u32)p->dpme_load_addr_2);
    printf("         start address: 0x%08lx  0x%08lx\n",
		(u32)p->dpme_goto_addr, (u32)p->dpme_goto_addr_2);
    printf("              checksum: 0x%08lx\n", p->dpme_checksum);
d484 2
a485 2
    printf("       size of a block: %d\n", zp->sbBlkSize);
    printf("      number of blocks: %ld\n", zp->sbBlkCount);
d488 2
a489 2
    printf("                  data: 0x%lx\n", zp->sbData);
    printf("          driver count: %d\n", zp->sbDrvrCount);
d495 2
a496 2
	printf("      driver %3u block: %ld\n", i+1, m[i].ddBlock);
	printf("        size in blocks: %d\n", m[i].ddSize);
@


1.28
log
@The great de-typedef'ification continues.

PatchList -> struct patchlist
Nuke PatchListPtr

PatchListDescriptor -> struct patchlistdescriptor
Nuke PatchListDescriptorPtr
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.27 2016/01/17 16:34:41 krw Exp $	*/
d99 5
a103 5
void dump_block_zero(partition_map_header *map);
void dump_partition_entry(partition_map *entry, int type_length, int name_length, int digits);
int get_max_base_or_length(partition_map_header *map);
int get_max_name_string_length(partition_map_header *map);
int get_max_type_string_length(partition_map_header *map);
d112 1
a112 1
    partition_map_header *map;
d129 1
a129 1
dump_block_zero(partition_map_header *map)
d171 1
a171 1
dump_partition_map(partition_map_header *map, int disk_order)
d173 1
a173 1
    partition_map * entry;
d220 1
a220 1
dump_partition_entry(partition_map *entry, int type_length, int name_length, int digits)
d222 1
a222 1
    partition_map_header *map;
d268 1
a268 1
show_data_structures(partition_map_header *map)
d273 1
a273 1
    partition_map * entry;
d365 1
a365 1
full_dump_partition_entry(partition_map_header *map, int ix)
d367 1
a367 1
    partition_map * cur;
d466 1
a466 1
full_dump_block_zero(partition_map_header *map)
d505 1
a505 1
display_patches(partition_map *entry)
d572 1
a572 1
get_max_type_string_length(partition_map_header *map)
d574 1
a574 1
    partition_map * entry;
d595 1
a595 1
get_max_name_string_length(partition_map_header *map)
d597 1
a597 1
    partition_map * entry;
d618 1
a618 1
get_max_base_or_length(partition_map_header *map)
d620 1
a620 1
    partition_map * entry;
@


1.27
log
@The great de-typedef'ification continues. OSType -> unsigned long.

Nuke names/NAMES as the only use was in an unused array of abbreviations
which also goes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.26 2016/01/17 16:26:26 krw Exp $	*/
d62 1
a62 1
typedef struct PatchDescriptor {
d73 1
a73 2
} PatchDescriptor;
typedef PatchDescriptor * PatchDescriptorPtr;
d75 1
a75 1
typedef struct PatchList {
d78 2
a79 3
    PatchDescriptor thePatch[1];
} PatchList;
typedef PatchList *PatchListPtr;
d510 2
a511 2
    PatchListPtr p;
    PatchDescriptorPtr q;
d530 1
a530 1
    p = (PatchListPtr) patch_block;
d548 1
a548 1
	p = (PatchListPtr) patch_block;
d567 1
a567 1
	q = (PatchDescriptorPtr)next;
@


1.26
log
@The great de-typedef'ification continues. DDMap -> struct ddmap.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.25 2016/01/17 16:15:59 krw Exp $	*/
a60 6
typedef struct names {
    const char *abbr;
    const char *full;
} NAMES;

typedef unsigned long OSType;
d63 1
a63 1
    OSType		patchSig;
a86 13
NAMES plist[] = {
    {"Drvr", "Apple_Driver"},
    {"Drv4", "Apple_Driver43"},
    {"Free", "Apple_Free"},
    {"Patc", "Apple_Patches"},
    {" HFS", "Apple_HFS"},
    {" MFS", "Apple_MFS"},
    {"PDOS", "Apple_PRODOS"},
    {"junk", "Apple_Scratch"},
    {"unix", "Apple_UNIX_SVR2"},
    {" map", "Apple_partition_map"},
    {0,	0},
};
@


1.25
log
@The great de-typedef'ification continues. Block0 -> struct block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.24 2016/01/17 16:07:06 krw Exp $	*/
d153 1
a153 1
    DDMap *m;
d173 1
a173 1
	m = (DDMap *) p->sbMap;
d292 1
a292 1
    DDMap *m;
d331 1
a331 1
	    m = (DDMap *) zp->sbMap;
d490 1
a490 1
    DDMap *m;
d511 1
a511 1
    m = (DDMap *) zp->sbMap;
@


1.24
log
@The great de-typedef'ification continues. DPME -> struct dpme.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.23 2016/01/17 15:57:12 krw Exp $	*/
d152 1
a152 1
    Block0 *p;
d291 1
a291 1
    Block0 *zp;
d489 1
a489 1
    Block0 *zp;
@


1.23
log
@Let the great de-typedef'ification begin. MEDIA -> struct file_media *.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.22 2016/01/17 14:28:25 krw Exp $	*/
d245 1
a245 1
    DPME *p;
d295 1
a295 1
    DPME *p;
d389 1
a389 1
    DPME *p;
@


1.22
log
@A/UX is no more, was m68k only, and we have no sentimental reasons for
keeping support.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.21 2016/01/17 14:13:42 jasper Exp $	*/
d529 1
a529 1
    FILE_MEDIA m;
@


1.21
log
@- tidy up a bunch of #if's for code that has been either enabled or disabled since forever,
  or not relevant at all (e.g. some bits for A/UX support)
- remove commented code that has never been compiled, etc

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.20 2016/01/16 22:28:14 krw Exp $	*/
a293 1
    int j, slice;
a295 2
    BZB *bp;
    const char *s;
a381 44
    printf(" #: type RU *slice mount_point (A/UX only fields)\n");
    for (entry = map->disk_order; entry != NULL; entry = entry->next_on_disk) {
	p = entry->data;
	printf("%2ld: ", entry->disk_address);

	bp = (BZB *) (p->dpme_bzb);
	j = -1;
	if (bp->bzb_magic == BZBMAGIC) {
	    switch (bp->bzb_type) {
	    case FSTEFS:
		s = "esch";
		break;
	    case FSTSFS:
		s = "swap";
		j = 1;
		break;
	    case FST:
	    default:
		s = "fsys";
		if ((bp->bzb_flags & BZB_ROOT) != 0) {
		    j = 0;
		} else if ((bp->bzb_flags & BZB_USR) != 0) {
		    j = 2;
		}
		break;
	    }
	    printf("%4s ", s);
	    printf("%c%c ",
		    (bp->bzb_flags & BZB_ROOT)?'R':' ',
		    (bp->bzb_flags & BZB_USR)?'U':' ');
	    slice = ((bp->bzb_flags >> BZB_SLICE_SHIFT) & BZB_SLICE_MASK);
	    if (slice != 0) {
		printf("  %2d", slice);
	    } else if (j >= 0) {
		printf(" *%2d", j);
	    } else {
		printf("    ");
	    }
	    if (bp->bzb_mount_point[0] != 0) {
		printf(" %.64s", bp->bzb_mount_point);
	    }
	}
	printf("\n");
    }
@


1.20
log
@Move last field (size_in_bytes) in struct media to struct file_media
and replace MEDIA with FILE_MEDIA everywhere. media.h becomes unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.19 2016/01/16 20:00:50 krw Exp $	*/
a54 4
#if DPISTRLEN != 32
#error Change in strlen in partition entries! Fix constants
#endif

a245 1
    const char *s;
d248 1
a248 2
    int driver, slice;
    // int kind;
a249 3
#if 1
    BZB *bp;
#endif
a260 10
    /*
    switch (entry->HFS_kind) {
    case kHFS_std:	kind = 'h'; break;
    case kHFS_embed:	kind = 'e'; break;
    case kHFS_plus:	kind = '+'; break;
    default:
    case kHFS_not:	kind = ' '; break;
    }
    printf("%c ", kind);
    */
a283 50
#if 1
    // Old A/UX fields that no one pays attention to anymore.
    bp = (BZB *) (p->dpme_bzb);
    j = -1;
    if (bp->bzb_magic == BZBMAGIC) {
	switch (bp->bzb_type) {
	case FSTEFS:
	    s = "EFS";
	    break;
	case FSTSFS:
	    s = "SFS";
	    j = 1;
	    break;
	case FST:
	default:
	    if ((bp->bzb_flags & BZB_ROOT) != 0) {
		if ((bp->bzb_flags & BZB_USR) != 0) {
		    s = "RUFS";
		} else {
		    s = "RFS";
		}
		j = 0;
	    } else if ((bp->bzb_flags & BZB_USR) != 0) {
		s = "UFS";
		j = 2;
	    } else {
		s = "FS";
	    }
	    break;
	}
	slice = ((bp->bzb_flags >> BZB_SLICE_SHIFT) & BZB_SLICE_MASK);
	if (slice != 0) {
	    printf(" s%1d %4s", slice - 1, s);
	} else if (j >= 0) {
	    printf(" S%1d %4s", j, s);
	} else {
	    printf("    %4s", s);
	}
	if ((bp->bzb_flags & BZB_CRIT) != 0) {
	    printf(" K%1d", bp->bzb_cluster);
	} else if (j < 0) {
	    printf("   ");
	} else {
	    printf(" k%1d", bp->bzb_cluster);
	}
	if (bp->bzb_mount_point[0] != 0) {
	    printf("  %.64s", bp->bzb_mount_point);
	}
    }
#endif
a342 5

/*
u32     dpme_boot_args[32]      ;
u32     dpme_reserved_3[62]     ;
*/
a384 3
/*
xx: cccc RU *dd s...
*/
@


1.19
log
@Start peeling away excess layers of abstraction.

Since 'file' is the only kind of media, no need to call the appropriate
functions via pointers. Just call the _file_ variants directly.
Nuke the fields do_read(), do_write(), do_close(), do_os_reload()
and the functions read_media(), write_media(), close_media() and
os_reload_media().

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.18 2016/01/15 23:05:00 krw Exp $	*/
d653 1
a653 1
    MEDIA m;
@


1.18
log
@We don't need yet another alias for DEV_BSIZE. Use DEV_BSIZE and
nuke PBLOCK_SIZE and another unused #define.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.17 2016/01/15 16:39:20 krw Exp $	*/
d47 1
d671 1
a671 1
    if (read_media(m, (long long)offset, DEV_BSIZE, (char *)patch_block) == 0) {
d688 1
a688 1
	    if (read_media(m, offset+i, DEV_BSIZE, (char *)s) == 0) {
@


1.17
log
@Replace bitfield_get() and bitfield_set() abstraction with simple masking
operations since all the uses but 1 are for 1 bit fields. No functional
change intended.

Unhook bitfield.c from build.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.16 2016/01/14 04:02:05 krw Exp $	*/
d30 2
d664 1
a664 1
	patch_block = malloc(PBLOCK_SIZE);
d670 1
a670 1
    if (read_media(m, (long long)offset, PBLOCK_SIZE, (char *)patch_block) == 0) {
d678 1
a678 1
	patch_block = reallocarray(NULL, i, PBLOCK_SIZE);
d683 1
a683 1
	s = patch_block + PBLOCK_SIZE*i;
d685 1
a685 1
	    s -= PBLOCK_SIZE;
d687 1
a687 1
	    if (read_media(m, offset+i, PBLOCK_SIZE, (char *)s) == 0) {
@


1.16
log
@Remove code supporting undocumented and inaccessible flags 'a'
(abbreviate partition type names), 'f' (print HFS partition names)
and 'kLogicalOption' (obviously a getopt_long() conversion error).
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.15 2016/01/12 20:09:39 krw Exp $	*/
d250 1
a250 1
    int driver;
d315 2
a316 2
	    if (bzb_root_get(bp) != 0) {
		if (bzb_usr_get(bp) != 0) {
d322 1
a322 1
	    } else if (bzb_usr_get(bp) != 0) {
d330 3
a332 2
	if (bzb_slice_get(bp) != 0) {
	    printf(" s%1ld %4s", bzb_slice_get(bp)-1, s);
d338 1
a338 1
	if (bzb_crit_get(bp) != 0) {
d360 1
a360 1
    int j;
d422 12
a433 12
		(dpme_valid_get(p))?'V':'.',
		(dpme_allocated_get(p))?'A':'.',
		(dpme_in_use_get(p))?'I':'.',
		(dpme_bootable_get(p))?'B':'.',
		(dpme_readable_get(p))?'R':'.',
		(dpme_writable_get(p))?'W':'.',
		(dpme_os_pic_code_get(p))?'P':'.',
		(dpme_os_specific_2_get(p))?'2':'.',
		(dpme_chainable_get(p))?'C':'.',
		(dpme_diskdriver_get(p))?'D':'.',
		(bitfield_get(p->dpme_flags, 30, 1))?'M':'.',
		(bitfield_get(p->dpme_flags, 31, 1))?'X':'.');
d478 1
a478 1
		if (bzb_root_get(bp) != 0) {
d480 1
a480 1
		} else if (bzb_usr_get(bp) != 0) {
d487 5
a491 4
		    (bzb_root_get(bp))?'R':' ',
		    (bzb_usr_get(bp))?'U':' ');
	    if (bzb_slice_get(bp) != 0) {
		printf("  %2ld", bzb_slice_get(bp)-1);
d529 7
a535 7
    if (dpme_valid_get(p)) printf("valid ");
    if (dpme_allocated_get(p)) printf("alloc ");
    if (dpme_in_use_get(p)) printf("in-use ");
    if (dpme_bootable_get(p)) printf("boot ");
    if (dpme_readable_get(p)) printf("read ");
    if (dpme_writable_get(p)) printf("write ");
    if (dpme_os_pic_code_get(p)) printf("pic ");
@


1.15
log
@Use normal err/errx/warn/warnx rather than handrolling new ones. Move
usage() to pdisk.c and nuke do_help() and '-h'.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.14 2016/01/12 15:32:08 krw Exp $	*/
a114 3
int aflag = AFLAG_DEFAULT;	/* abbreviate partition types */
int pflag = PFLAG_DEFAULT;	/* show physical limits of partition */
int fflag = FFLAG_DEFAULT;	/* show HFS volume names */
d211 3
a213 7
    if (aflag) {
	max_type_length = 4;
    } else {
	max_type_length = get_max_type_string_length(map);
	if (max_type_length < 4) {
	    max_type_length = 4;
	}
d260 1
a260 12
    if (aflag) {
	s = "????";
	for (j = 0; plist[j].abbr != 0; j++) {
	    if (strcmp(p->dpme_type, plist[j].full) == 0) {
		s = plist[j].abbr;
		break;
	    }
	}
	printf("%2ld: %.4s", entry->disk_address, s);
    } else {
	printf("%2ld: %*.32s", entry->disk_address, type_length, p->dpme_type);
    }
d263 2
a264 6
    if (entry->HFS_name == NULL || fflag == 0) {
	strncpy(buf, p->dpme_name, name_length);
	buf[name_length] = 0;
    } else {
	snprintf(buf, name_length + 1, "\"%s\"", entry->HFS_name);
    }
d278 1
a278 4
    if (pflag) {
	printf("%*lu ", digits, p->dpme_pblocks);
	size = p->dpme_pblocks;
    } else if (p->dpme_lblocks + p->dpme_lblock_start != p->dpme_pblocks) {
d288 1
a288 1
    if (pflag || p->dpme_lblock_start == 0) {
a750 11
	}

	if (fflag) {
		if (entry->HFS_name == NULL) {
		    length = 0;
		} else {
		    length = strlen(entry->HFS_name) + 2;
		}
		if (length > max) {
		    max = length;
		}
@


1.14
log
@Retire '-i', a poorly documented interactive mode that tries to
mimic the 20th century MacOS version of pdisk more closely than the
usual interactive editor. One set of commands is enough for anyone.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.13 2016/01/11 23:31:27 krw Exp $	*/
d30 2
a46 1
#include "errors.h"
a141 1
	//error(-1, "No partition map in '%s'", name);
d687 1
a687 1
	    error(errno, "can't allocate memory for patch block buffer");
d692 1
a692 1
	error(errno, "Can't read patch block");
d701 1
a701 1
	    error(errno, "can't allocate memory for patch blocks buffer");
d709 1
a709 1
		error(errno, "Can't read patch block %d", i);
@


1.13
log
@open_pathname_as_media() simply called open_file_as_media() which
takes the same parameters and returns the same value. Nuke
open_pathname_as_media() and call open_file_as_media() directly.

Nothing else from pathname.[ch] is used so remove them from build
in preparation for moving them to the attic.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.12 2016/01/11 07:54:07 jasper Exp $	*/
d139 1
a139 1
    map = open_partition_map(name, &junk, 0);
@


1.12
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 1
#include "pathname.h"
@


1.11
log
@Two reallocarray() conversions that were missed earlier.
OK deraadt@@
@
text
@d1 2
@


1.10
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d698 1
a698 1
	patch_block = malloc(PBLOCK_SIZE*i);
@


1.9
log
@Use the newly committed version of strnlen from libc. ok millert@@ kettenis@@
@
text
@d279 1
a279 1
    buf = (char *) malloc(name_length+1);
d684 1
a684 1
	patch_block = (unsigned char *) malloc(PBLOCK_SIZE);
d698 1
a698 1
	patch_block = (unsigned char *) malloc(PBLOCK_SIZE*i);
@


1.8
log
@remove unused functions

initially from tobias@@, but I removed some other unused one

ok martin@@ tobias@@
@
text
@a126 1
int strnlen(char *s, int n);
a732 14
}

int
strnlen(char *s, int n)
{
    int i;

    for (i = 0; i < n; i++) {
	if (*s == 0) {
	    break;
	}
	s++;
    }
    return i;
@


1.7
log
@remove a bunch of linux and NeXT defines and, in turn, -D__unix__
@
text
@a378 36
list_all_disks()
{
    MEDIA_ITERATOR iter;
    MEDIA m;
    DPME * data;
    char *name;
    long mark;

    data = (DPME *) malloc(PBLOCK_SIZE);
    if (data == NULL) {
	error(errno, "can't allocate memory for try buffer");
	return;
    }

    for (iter = first_media_kind(&mark); iter != 0; iter = next_media_kind(&mark)) {

    	while ((name = step_media_iterator(iter)) != 0) {

	    if ((m = open_pathname_as_media(name, O_RDONLY)) == 0) {
		error(errno, "can't open file '%s'", name);
	    } else {
		close_media(m);

		dump(name);
	    }
	    free(name);
	}

	delete_media_iterator(iter);
    }

    free(data);
}


void
@


1.6
log
@remove get_linux_name() and an accompanying variable;
this function was a stub after the last cleanup
@
text
@a64 1
#ifdef __unix__
a65 1
#endif
a397 1
#if defined(__linux__) || defined(__unix__)
a398 1
#endif
@


1.5
log
@With last pdisk and full functionality for mac68k now in place, start
cleaning the maze of ifdef's not relevant for us.

This round wipes most linux and/or MacOS-only bits, more to come.
@
text
@a203 1
    char *alternate;
d209 2
a210 9
    alternate = get_linux_name(map->name);
    if (alternate) {
	printf("\nPartition map (with %d byte blocks) on '%s' (%s)\n",
		map->logical_block, map->name, alternate);
	free(alternate);
    } else {
	printf("\nPartition map (with %d byte blocks) on '%s'\n",
		map->logical_block, map->name);
    }
@


1.4
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@a31 1
#ifndef __linux__
a32 4
//#include <unistd.h>
#else
#include <malloc.h>
#endif
@


1.3
log
@more writable spelling; torh
@
text
@d4 1
a4 1
// Written by Eryk Vershen (eryk@@apple.com)
d66 2
a67 2
    char *abbr;
    char *full;
d70 25
d101 1
d103 1
d122 1
d168 1
d186 10
a195 3
	    printf("%u: @@ %lu for %u, type=0x%x\n", i+1,
		   get_align_long(&m[i].ddBlock),
		   m[i].ddSize, m[i].ddType);
d215 1
a215 1
    alternate = get_mklinux_name(map->name);
d269 1
a269 1
    char *s;
d273 5
d290 1
a290 2
	printf("%2ld: %.4s%c%-*.32s ",
		entry->disk_address, s, driver, name_length, p->dpme_name);
d292 1
a292 3
	printf("%2ld: %*.32s%c%-*.32s ",
		entry->disk_address, type_length, p->dpme_type,
		driver, name_length, p->dpme_name);
d295 20
d340 1
a340 1
#if 0
d371 1
a371 1
	    printf(" s%1d %4s", bzb_slice_get(bp)-1, s);
d413 1
d415 1
d441 1
a441 1
    char *s;
d451 3
a453 2
    printf("Map is%s writable", (map->writeable)?kStringEmpty:kStringNot);
    printf(", but%s changed\n", (map->changed)?kStringEmpty:kStringNot);
d583 1
a583 1
full_dump_partition_entry(partition_map_header *map, int index)
d590 1
a590 1
    cur = find_entry_by_disk_address(index, map);
d721 1
d728 5
d748 39
a786 1
    dump_block(patch_block, PBLOCK_SIZE);
d843 11
@


1.2
log
@rm trailing whitespace
@
text
@d391 1
a391 1
    printf("Map is%s writeable", (map->writeable)?kStringEmpty:kStringNot);
@


1.1
log
@Initial revision
@
text
@d9 17
a25 17
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
d127 1
a127 1
    
d157 1
a157 1
	    printf("%u: @@ %lu for %u, type=0x%x\n", i+1, 
d275 1
a275 1
    
d349 1
a349 1
    
d418 1
a418 1
            printf("%u: @@ %lu for %u, type=0x%x\n", i+1, 
d534 1
a534 1
    
d567 1
a567 1
    printf("         start address: 0x%08lx  0x%08lx\n", 
d666 1
a666 1
    
@


1.1.1.1
log
@Import of pdisk from apple, BSD licensed code. Archive dated Feb 18 1998 
This is a HFS partition editing tool.
@
text
@@
