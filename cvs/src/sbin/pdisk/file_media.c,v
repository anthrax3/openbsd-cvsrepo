head	1.48;
access;
symbols
	OPENBSD_6_1:1.48.0.8
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.10.0.24
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.16
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.20
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.18
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.14
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.12
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.10
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.8
	OPENBSD_5_0:1.10.0.6
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	ver1:1.1.1.1
	apple19980218:1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2016.01.30.17.21.10;	author krw;	state Exp;
branches;
next	1.47;
commitid	BOQYiykYZJ8gnOpB;

1.47
date	2016.01.30.17.09.11;	author krw;	state Exp;
branches;
next	1.46;
commitid	ckpV9XGgFAiDBI9u;

1.46
date	2016.01.30.14.24.47;	author krw;	state Exp;
branches;
next	1.45;
commitid	VY8bEAw2uQf9Rw0z;

1.45
date	2016.01.29.22.51.43;	author krw;	state Exp;
branches;
next	1.44;
commitid	T4U3iDofClirvhXD;

1.44
date	2016.01.28.13.01.33;	author krw;	state Exp;
branches;
next	1.43;
commitid	00cCpXcvPr6DmCk2;

1.43
date	2016.01.26.21.07.54;	author krw;	state Exp;
branches;
next	1.42;
commitid	DW9rfkVjTw1mfuI8;

1.42
date	2016.01.26.16.13.09;	author krw;	state Exp;
branches;
next	1.41;
commitid	7HeB8KYaCuiLcwze;

1.41
date	2016.01.25.23.43.20;	author krw;	state Exp;
branches;
next	1.40;
commitid	Qe66eD6zrMyPrXqP;

1.40
date	2016.01.25.22.12.22;	author krw;	state Exp;
branches;
next	1.39;
commitid	kVpV4q40FW96TpRH;

1.39
date	2016.01.23.03.46.18;	author krw;	state Exp;
branches;
next	1.38;
commitid	HhlQ6dIQMjX8YGSD;

1.38
date	2016.01.22.12.31.04;	author krw;	state Exp;
branches;
next	1.37;
commitid	3OQZJKas0yPP6L3H;

1.37
date	2016.01.21.15.33.21;	author krw;	state Exp;
branches;
next	1.36;
commitid	YzEQpnBPgLX85u7F;

1.36
date	2016.01.19.16.53.04;	author krw;	state Exp;
branches;
next	1.35;
commitid	GhsSvNjOAVdG5I2c;

1.35
date	2016.01.18.17.57.35;	author krw;	state Exp;
branches;
next	1.34;
commitid	nIKs6pPbVKcIxae8;

1.34
date	2016.01.18.16.41.41;	author krw;	state Exp;
branches;
next	1.33;
commitid	bciL8XKP8aKEWDlM;

1.33
date	2016.01.18.15.30.00;	author krw;	state Exp;
branches;
next	1.32;
commitid	aMBITFjwes8vTDZh;

1.32
date	2016.01.18.14.55.08;	author krw;	state Exp;
branches;
next	1.31;
commitid	xAoUMz1vJQmpxnZH;

1.31
date	2016.01.18.00.04.36;	author krw;	state Exp;
branches;
next	1.30;
commitid	luTmgvtH0tpvRRV4;

1.30
date	2016.01.17.23.18.19;	author krw;	state Exp;
branches;
next	1.29;
commitid	vC4VO4mr30PnBRSq;

1.29
date	2016.01.17.19.39.20;	author krw;	state Exp;
branches;
next	1.28;
commitid	slCzBfkhwAcLWsXe;

1.28
date	2016.01.17.18.57.52;	author krw;	state Exp;
branches;
next	1.27;
commitid	Rl8zxjpMi2a93hiE;

1.27
date	2016.01.17.15.57.12;	author krw;	state Exp;
branches;
next	1.26;
commitid	9OUrU3poCOjYi22w;

1.26
date	2016.01.16.22.28.14;	author krw;	state Exp;
branches;
next	1.25;
commitid	IIP5iNpDONoW4Jjm;

1.25
date	2016.01.16.22.04.20;	author krw;	state Exp;
branches;
next	1.24;
commitid	RgMNl0Bk1tx3QrKF;

1.24
date	2016.01.16.21.41.41;	author krw;	state Exp;
branches;
next	1.23;
commitid	N0CsQGsGtplNR8ev;

1.23
date	2016.01.16.21.29.07;	author krw;	state Exp;
branches;
next	1.22;
commitid	Ps7EsBgpdFrGcD1r;

1.22
date	2016.01.16.20.00.50;	author krw;	state Exp;
branches;
next	1.21;
commitid	2koPB3ak72axl95m;

1.21
date	2016.01.16.14.49.28;	author krw;	state Exp;
branches;
next	1.20;
commitid	tickLY4AeBovASt0;

1.20
date	2016.01.15.23.16.40;	author krw;	state Exp;
branches;
next	1.19;
commitid	DW10SXx96ILQsthd;

1.19
date	2016.01.13.00.12.49;	author krw;	state Exp;
branches;
next	1.18;
commitid	Udkf0cBemwAcDi6s;

1.18
date	2016.01.12.23.48.42;	author krw;	state Exp;
branches;
next	1.17;
commitid	k0e5CXAF5NwSZwIj;

1.17
date	2016.01.12.20.09.39;	author krw;	state Exp;
branches;
next	1.16;
commitid	WFEddFcNLm6A2VYQ;

1.16
date	2016.01.12.16.08.37;	author krw;	state Exp;
branches;
next	1.15;
commitid	SiCi2OiU3VeQsi4m;

1.15
date	2016.01.11.17.55.45;	author jasper;	state Exp;
branches;
next	1.14;
commitid	m85VTdlsVhWAtyII;

1.14
date	2016.01.11.14.27.29;	author jasper;	state Exp;
branches;
next	1.13;
commitid	CvDCKx623CzeimQc;

1.13
date	2016.01.11.07.57.54;	author jasper;	state Exp;
branches;
next	1.12;
commitid	HZWVhdOSzNAX4WBf;

1.12
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.11;
commitid	DI30r1mqHPQNkhTm;

1.11
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	0qPuuXwccpVXsXcV;

1.10
date	2010.05.25.19.01.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.11.17.20.40;	author martin;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.29.00.43.41;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.02.00.48.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.02.00.13.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.24.00.20.59;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.24.00.14.06;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.24.00.14.06;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Move last three lines (#define's) from dpme.h to partition_map.h and
tweak #include's as necessary.
@
text
@/*	$OpenBSD: file_media.c,v 1.47 2016/01/30 17:09:11 krw Exp $	*/

/*
 * file_media.c -
 *
 * Written by Eryk Vershen
 */

/*
 * Copyright 1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>		/* DEV_BSIZE */
#include <sys/queue.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "partition_map.h"
#include "file_media.h"

struct ddmap_ondisk {
    uint8_t	ddBlock[4];
    uint8_t	ddSize[2];
    uint8_t	ddType[2];
};

struct block0_ondisk {
    uint8_t	sbSig[2];
    uint8_t	sbBlkSize[2];
    uint8_t	sbBlkCount[4];
    uint8_t	sbDevType[2];
    uint8_t	sbDevId[2];
    uint8_t	sbData[4];
    uint8_t	sbDrvrCount[2];
    uint8_t	sbDDMap[64];	/* ddmap_ondisk[8] */
    uint8_t	reserved[430];
};

struct dpme_ondisk {
    uint8_t	dpme_signature[2];
    uint8_t	dpme_reserved_1[2];
    uint8_t	dpme_map_entries[4];
    uint8_t	dpme_pblock_start[4];
    uint8_t	dpme_pblocks[4];
    uint8_t	dpme_name[DPISTRLEN];
    uint8_t	dpme_type[DPISTRLEN];
    uint8_t	dpme_lblock_start[4];
    uint8_t	dpme_lblocks[4];
    uint8_t	dpme_flags[4];
    uint8_t	dpme_boot_block[4];
    uint8_t	dpme_boot_bytes[4];
    uint8_t	dpme_load_addr[4];
    uint8_t	dpme_reserved_2[4];
    uint8_t	dpme_goto_addr[4];
    uint8_t	dpme_reserved_3[4];
    uint8_t	dpme_checksum[4];
    uint8_t	dpme_processor_id[16];
    uint8_t	dpme_reserved_4[376];
};

static int	read_block(int, uint64_t, void *);
static int	write_block(int, uint64_t, void *);

static int
read_block(int fd, uint64_t sector, void *address)
{
	ssize_t off;

	off = pread(fd, address, DEV_BSIZE, sector * DEV_BSIZE);
	if (off == DEV_BSIZE)
		return 1;

	if (off == 0)
		fprintf(stderr, "end of file encountered");
	else if (off == -1)
		warn("reading file failed");
	else
		fprintf(stderr, "short read");

	return 0;
}

static int
write_block(int fd, uint64_t sector, void *address)
{
	ssize_t off;

	off = pwrite(fd, address, DEV_BSIZE, sector * DEV_BSIZE);
	if (off == DEV_BSIZE)
		return 1;

	warn("writing to file failed");
	return 0;
}

int
read_block0(int fd, struct partition_map *map)
{
	struct block0_ondisk *block0_ondisk;
	struct ddmap_ondisk ddmap_ondisk;
	int i;

	block0_ondisk = malloc(sizeof(struct block0_ondisk));
	if (block0_ondisk == NULL)
		errx(1, "No memory to read block0");

	if (read_block(fd, 0, block0_ondisk) == 0)
		return 0;

	memcpy(&map->sbSig, block0_ondisk->sbSig,
	    sizeof(map->sbSig));
	map->sbSig = betoh16(map->sbSig);
	memcpy(&map->sbBlkSize, block0_ondisk->sbBlkSize,
	    sizeof(map->sbBlkSize));
	map->sbBlkSize = betoh16(map->sbBlkSize);
	memcpy(&map->sbBlkCount, block0_ondisk->sbBlkCount,
	    sizeof(map->sbBlkCount));
	map->sbBlkCount = betoh32(map->sbBlkCount);
	memcpy(&map->sbDevType, block0_ondisk->sbDevType,
	    sizeof(map->sbDevType));
	map->sbDevType = betoh16(map->sbDevType);
	memcpy(&map->sbDevId, block0_ondisk->sbDevId,
	    sizeof(map->sbDevId));
	map->sbDevId = betoh16(map->sbDevId);
	memcpy(&map->sbData, block0_ondisk->sbData,
	    sizeof(map->sbData));
	map->sbData = betoh32(map->sbData);
	memcpy(&map->sbDrvrCount, block0_ondisk->sbDrvrCount,
	    sizeof(map->sbDrvrCount));
	map->sbDrvrCount = betoh16(map->sbDrvrCount);

	for (i = 0; i < 8; i++) {
		memcpy(&ddmap_ondisk,
		    map->sbDDMap+i*sizeof(struct ddmap_ondisk),
		    sizeof(ddmap_ondisk));
		memcpy(&map->sbDDMap[i].ddBlock, &ddmap_ondisk.ddBlock,
		    sizeof(map->sbDDMap[i].ddBlock));
		map->sbDDMap[i].ddBlock =
		    betoh32(map->sbDDMap[i].ddBlock);
		memcpy(&map->sbDDMap[i].ddSize, &ddmap_ondisk.ddSize,
		    sizeof(map->sbDDMap[i].ddSize));
		map->sbDDMap[i].ddSize = betoh16(map->sbDDMap[i].ddSize);
		memcpy(&map->sbDDMap[i].ddType, &ddmap_ondisk.ddType,
		    sizeof(map->sbDDMap[i].ddType));
		map->sbDDMap[i].ddType = betoh32(map->sbDDMap[i].ddType);
	}

	free(block0_ondisk);
	return 1;
}

int
write_block0(int fd, struct partition_map *map)
{
	struct block0_ondisk *block0_ondisk;
	struct ddmap_ondisk ddmap_ondisk;
	int i, rslt;
	uint32_t tmp32;
	uint16_t tmp16;

	block0_ondisk = malloc(sizeof(struct block0_ondisk));
	if (block0_ondisk == NULL)
		errx(1, "No memory to write block 0");

	tmp16 = htobe16(map->sbSig);
	memcpy(block0_ondisk->sbSig, &tmp16,
	    sizeof(block0_ondisk->sbSig));
	tmp16 = htobe16(map->sbBlkSize);
	memcpy(block0_ondisk->sbBlkSize, &tmp16,
	    sizeof(block0_ondisk->sbBlkSize));
	tmp32 = htobe32(map->sbBlkCount);
	memcpy(block0_ondisk->sbBlkCount, &tmp32,
	    sizeof(block0_ondisk->sbBlkCount));
	tmp16 = htobe16(map->sbDevType);
	memcpy(block0_ondisk->sbDevType, &tmp16,
	    sizeof(block0_ondisk->sbDevType));
	tmp16 = htobe16(map->sbDevId);
	memcpy(block0_ondisk->sbDevId, &tmp16,
	    sizeof(block0_ondisk->sbDevId));
	tmp32 = htobe32(map->sbData);
	memcpy(block0_ondisk->sbData, &tmp32,
	    sizeof(block0_ondisk->sbData));
	tmp16 = htobe16(map->sbDrvrCount);
	memcpy(block0_ondisk->sbDrvrCount, &tmp16,
	    sizeof(block0_ondisk->sbDrvrCount));

	for (i = 0; i < 8; i++) {
		tmp32 = htobe32(map->sbDDMap[i].ddBlock);
		memcpy(ddmap_ondisk.ddBlock, &tmp32,
		    sizeof(ddmap_ondisk.ddBlock));
		tmp16 = htobe16(map->sbDDMap[i].ddSize);
		memcpy(&ddmap_ondisk.ddSize, &tmp16,
		    sizeof(ddmap_ondisk.ddSize));
		tmp16 = betoh32(map->sbDDMap[i].ddType);
		memcpy(&ddmap_ondisk.ddType, &tmp16,
		    sizeof(ddmap_ondisk.ddType));
		memcpy(map->sbDDMap+i*sizeof(struct ddmap_ondisk),
		    &ddmap_ondisk, sizeof(ddmap_ondisk));
	}

	rslt = write_block(fd, 0, block0_ondisk);
	free(block0_ondisk);
	return rslt;
}

int
read_dpme(int fd, uint64_t sector, struct entry *entry)
{
	struct dpme_ondisk *dpme_ondisk;

	dpme_ondisk = malloc(sizeof(struct dpme_ondisk));
	if (dpme_ondisk == NULL)
		errx(1, "No memory to read dpme");

	if (read_block(fd, sector, dpme_ondisk) == 0)
		return 0;

	memcpy(&entry->dpme_signature, dpme_ondisk->dpme_signature,
	    sizeof(entry->dpme_signature));
	memcpy(&entry->dpme_map_entries, dpme_ondisk->dpme_map_entries,
	    sizeof(entry->dpme_map_entries));
	memcpy(&entry->dpme_pblock_start, dpme_ondisk->dpme_pblock_start,
	    sizeof(entry->dpme_pblock_start));
	memcpy(&entry->dpme_pblocks, dpme_ondisk->dpme_pblocks,
	    sizeof(entry->dpme_pblocks));
	memcpy(&entry->dpme_lblock_start, dpme_ondisk->dpme_lblock_start,
	    sizeof(entry->dpme_lblock_start));
	memcpy(&entry->dpme_lblocks, dpme_ondisk->dpme_lblocks,
	    sizeof(entry->dpme_lblocks));
	memcpy(&entry->dpme_flags, dpme_ondisk->dpme_flags,
	    sizeof(entry->dpme_flags));
	memcpy(&entry->dpme_boot_block, dpme_ondisk->dpme_boot_block,
	    sizeof(entry->dpme_boot_block));
	memcpy(&entry->dpme_boot_bytes, dpme_ondisk->dpme_boot_bytes,
	    sizeof(entry->dpme_boot_bytes));
	memcpy(&entry->dpme_load_addr, dpme_ondisk->dpme_load_addr,
	    sizeof(entry->dpme_load_addr));
	memcpy(&entry->dpme_goto_addr, dpme_ondisk->dpme_goto_addr,
	    sizeof(entry->dpme_goto_addr));
	memcpy(&entry->dpme_checksum, dpme_ondisk->dpme_checksum,
	    sizeof(entry->dpme_checksum));

	entry->dpme_signature = betoh16(entry->dpme_signature);
	entry->dpme_map_entries = betoh32(entry->dpme_map_entries);
	entry->dpme_pblock_start = betoh32(entry->dpme_pblock_start);
	entry->dpme_pblocks = betoh32(entry->dpme_pblocks);
	entry->dpme_lblock_start = betoh32(entry->dpme_lblock_start);
	entry->dpme_lblocks = betoh32(entry->dpme_lblocks);
	entry->dpme_flags = betoh32(entry->dpme_flags);
	entry->dpme_boot_block = betoh32(entry->dpme_boot_block);
	entry->dpme_boot_bytes = betoh32(entry->dpme_boot_bytes);
	entry->dpme_load_addr = betoh32(entry->dpme_load_addr);
	entry->dpme_goto_addr = betoh32(entry->dpme_goto_addr);
	entry->dpme_checksum = betoh32(entry->dpme_checksum);

	memcpy(entry->dpme_reserved_1, dpme_ondisk->dpme_reserved_1,
	    sizeof(entry->dpme_reserved_1));
	memcpy(entry->dpme_reserved_2, dpme_ondisk->dpme_reserved_2,
	    sizeof(entry->dpme_reserved_2));
	memcpy(entry->dpme_reserved_3, dpme_ondisk->dpme_reserved_3,
	    sizeof(entry->dpme_reserved_3));
	memcpy(entry->dpme_reserved_4, dpme_ondisk->dpme_reserved_4,
	    sizeof(entry->dpme_reserved_4));

	strlcpy(entry->dpme_name, dpme_ondisk->dpme_name,
	    sizeof(entry->dpme_name));
	strlcpy(entry->dpme_type, dpme_ondisk->dpme_type,
	    sizeof(entry->dpme_type));
	strlcpy(entry->dpme_processor_id, dpme_ondisk->dpme_processor_id,
	    sizeof(entry->dpme_processor_id));

	free(dpme_ondisk);
	return 1;
}

int
write_dpme(int fd, uint64_t sector, struct entry *entry)
{
	struct dpme_ondisk *dpme_ondisk;
	int rslt;
	uint32_t tmp32;
	uint16_t tmp16;

	dpme_ondisk = malloc(sizeof(struct dpme_ondisk));
	if (dpme_ondisk == NULL)
		errx(1, "No memory to write dpme");

	memcpy(dpme_ondisk->dpme_name, entry->dpme_name,
	    sizeof(dpme_ondisk->dpme_name));
	memcpy(dpme_ondisk->dpme_type, entry->dpme_type,
	    sizeof(dpme_ondisk->dpme_type));
	memcpy(dpme_ondisk->dpme_processor_id, entry->dpme_processor_id,
	    sizeof(dpme_ondisk->dpme_processor_id));

	memcpy(dpme_ondisk->dpme_reserved_1, entry->dpme_reserved_1,
	    sizeof(dpme_ondisk->dpme_reserved_1));
	memcpy(dpme_ondisk->dpme_reserved_2, entry->dpme_reserved_2,
	    sizeof(dpme_ondisk->dpme_reserved_2));
	memcpy(dpme_ondisk->dpme_reserved_3, entry->dpme_reserved_3,
	    sizeof(dpme_ondisk->dpme_reserved_3));
	memcpy(dpme_ondisk->dpme_reserved_4, entry->dpme_reserved_4,
	    sizeof(dpme_ondisk->dpme_reserved_4));

	tmp16 = htobe16(entry->dpme_signature);
	memcpy(dpme_ondisk->dpme_signature, &tmp16,
	    sizeof(dpme_ondisk->dpme_signature));
	tmp32 = htobe32(entry->dpme_map_entries);
	memcpy(dpme_ondisk->dpme_map_entries, &tmp32,
	    sizeof(dpme_ondisk->dpme_map_entries));
	tmp32 = htobe32(entry->dpme_pblock_start);
	memcpy(dpme_ondisk->dpme_pblock_start, &tmp32,
	    sizeof(dpme_ondisk->dpme_pblock_start));
	tmp32 = htobe32(entry->dpme_pblocks);
	memcpy(dpme_ondisk->dpme_pblocks, &tmp32,
	    sizeof(dpme_ondisk->dpme_pblocks));
	tmp32 = htobe32(entry->dpme_lblock_start);
	memcpy(dpme_ondisk->dpme_lblock_start, &tmp32,
	    sizeof(dpme_ondisk->dpme_lblock_start));
	tmp32 = betoh32(entry->dpme_lblocks);
	memcpy(dpme_ondisk->dpme_lblocks, &tmp32,
	    sizeof(dpme_ondisk->dpme_lblocks));
	tmp32 = betoh32(entry->dpme_flags);
	memcpy(dpme_ondisk->dpme_flags, &tmp32,
	    sizeof(dpme_ondisk->dpme_flags));
	tmp32 = htobe32(entry->dpme_boot_block);
	memcpy(dpme_ondisk->dpme_boot_block, &tmp32,
	    sizeof(dpme_ondisk->dpme_boot_block));
	tmp32 = htobe32(entry->dpme_boot_bytes);
	memcpy(dpme_ondisk->dpme_boot_bytes, &tmp32,
	    sizeof(dpme_ondisk->dpme_boot_bytes));
	tmp32 = betoh32(entry->dpme_load_addr);
	memcpy(dpme_ondisk->dpme_load_addr, &tmp32,
	    sizeof(dpme_ondisk->dpme_load_addr));
	tmp32 = betoh32(entry->dpme_goto_addr);
	memcpy(dpme_ondisk->dpme_goto_addr, &tmp32,
	    sizeof(dpme_ondisk->dpme_goto_addr));
	tmp32 = betoh32(entry->dpme_checksum);
	memcpy(dpme_ondisk->dpme_checksum, &tmp32,
	    sizeof(dpme_ondisk->dpme_checksum));

	rslt = write_block(fd, sector, dpme_ondisk);
	free(dpme_ondisk);
	return rslt;
}
@


1.47
log
@Fold struct dpme into struct entry. Same reasons as for folding
struct block0 into struct partition_map. Easier to read code.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.46 2016/01/30 14:24:47 krw Exp $	*/
a38 1
#include "dpme.h"
@


1.46
log
@There is not much to do if we run out of memory, so simply exit if
a malloc() or calloc() fails. Simplifies a bunch of logic, makes
add_data_to_map() always succeed or exit, so make it a void.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.45 2016/01/29 22:51:43 krw Exp $	*/
d229 1
a229 1
read_dpme(int fd, uint64_t sector, struct dpme *dpme)
d240 53
a292 53
	memcpy(&dpme->dpme_signature, dpme_ondisk->dpme_signature,
	    sizeof(dpme->dpme_signature));
	memcpy(&dpme->dpme_map_entries, dpme_ondisk->dpme_map_entries,
	    sizeof(dpme->dpme_map_entries));
	memcpy(&dpme->dpme_pblock_start, dpme_ondisk->dpme_pblock_start,
	    sizeof(dpme->dpme_pblock_start));
	memcpy(&dpme->dpme_pblocks, dpme_ondisk->dpme_pblocks,
	    sizeof(dpme->dpme_pblocks));
	memcpy(&dpme->dpme_lblock_start, dpme_ondisk->dpme_lblock_start,
	    sizeof(dpme->dpme_lblock_start));
	memcpy(&dpme->dpme_lblocks, dpme_ondisk->dpme_lblocks,
	    sizeof(dpme->dpme_lblocks));
	memcpy(&dpme->dpme_flags, dpme_ondisk->dpme_flags,
	    sizeof(dpme->dpme_flags));
	memcpy(&dpme->dpme_boot_block, dpme_ondisk->dpme_boot_block,
	    sizeof(dpme->dpme_boot_block));
	memcpy(&dpme->dpme_boot_bytes, dpme_ondisk->dpme_boot_bytes,
	    sizeof(dpme->dpme_boot_bytes));
	memcpy(&dpme->dpme_load_addr, dpme_ondisk->dpme_load_addr,
	    sizeof(dpme->dpme_load_addr));
	memcpy(&dpme->dpme_goto_addr, dpme_ondisk->dpme_goto_addr,
	    sizeof(dpme->dpme_goto_addr));
	memcpy(&dpme->dpme_checksum, dpme_ondisk->dpme_checksum,
	    sizeof(dpme->dpme_checksum));

	dpme->dpme_signature = betoh16(dpme->dpme_signature);
	dpme->dpme_map_entries = betoh32(dpme->dpme_map_entries);
	dpme->dpme_pblock_start = betoh32(dpme->dpme_pblock_start);
	dpme->dpme_pblocks = betoh32(dpme->dpme_pblocks);
	dpme->dpme_lblock_start = betoh32(dpme->dpme_lblock_start);
	dpme->dpme_lblocks = betoh32(dpme->dpme_lblocks);
	dpme->dpme_flags = betoh32(dpme->dpme_flags);
	dpme->dpme_boot_block = betoh32(dpme->dpme_boot_block);
	dpme->dpme_boot_bytes = betoh32(dpme->dpme_boot_bytes);
	dpme->dpme_load_addr = betoh32(dpme->dpme_load_addr);
	dpme->dpme_goto_addr = betoh32(dpme->dpme_goto_addr);
	dpme->dpme_checksum = betoh32(dpme->dpme_checksum);

	memcpy(dpme->dpme_reserved_1, dpme_ondisk->dpme_reserved_1,
	    sizeof(dpme->dpme_reserved_1));
	memcpy(dpme->dpme_reserved_2, dpme_ondisk->dpme_reserved_2,
	    sizeof(dpme->dpme_reserved_2));
	memcpy(dpme->dpme_reserved_3, dpme_ondisk->dpme_reserved_3,
	    sizeof(dpme->dpme_reserved_3));
	memcpy(dpme->dpme_reserved_4, dpme_ondisk->dpme_reserved_4,
	    sizeof(dpme->dpme_reserved_4));

	strlcpy(dpme->dpme_name, dpme_ondisk->dpme_name,
	    sizeof(dpme->dpme_name));
	strlcpy(dpme->dpme_type, dpme_ondisk->dpme_type,
	    sizeof(dpme->dpme_type));
	strlcpy(dpme->dpme_processor_id, dpme_ondisk->dpme_processor_id,
	    sizeof(dpme->dpme_processor_id));
d299 1
a299 1
write_dpme(int fd, uint64_t sector, struct dpme *dpme)
d310 1
a310 1
	memcpy(dpme_ondisk->dpme_name, dpme->dpme_name,
d312 1
a312 1
	memcpy(dpme_ondisk->dpme_type, dpme->dpme_type,
d314 1
a314 1
	memcpy(dpme_ondisk->dpme_processor_id, dpme->dpme_processor_id,
d317 1
a317 1
	memcpy(dpme_ondisk->dpme_reserved_1, dpme->dpme_reserved_1,
d319 1
a319 1
	memcpy(dpme_ondisk->dpme_reserved_2, dpme->dpme_reserved_2,
d321 1
a321 1
	memcpy(dpme_ondisk->dpme_reserved_3, dpme->dpme_reserved_3,
d323 1
a323 1
	memcpy(dpme_ondisk->dpme_reserved_4, dpme->dpme_reserved_4,
d326 1
a326 1
	tmp16 = htobe16(dpme->dpme_signature);
d329 1
a329 1
	tmp32 = htobe32(dpme->dpme_map_entries);
d332 1
a332 1
	tmp32 = htobe32(dpme->dpme_pblock_start);
d335 1
a335 1
	tmp32 = htobe32(dpme->dpme_pblocks);
d338 1
a338 1
	tmp32 = htobe32(dpme->dpme_lblock_start);
d341 1
a341 1
	tmp32 = betoh32(dpme->dpme_lblocks);
d344 1
a344 1
	tmp32 = betoh32(dpme->dpme_flags);
d347 1
a347 1
	tmp32 = htobe32(dpme->dpme_boot_block);
d350 1
a350 1
	tmp32 = htobe32(dpme->dpme_boot_bytes);
d353 1
a353 1
	tmp32 = betoh32(dpme->dpme_load_addr);
d356 1
a356 1
	tmp32 = betoh32(dpme->dpme_goto_addr);
d359 1
a359 1
	tmp32 = betoh32(dpme->dpme_checksum);
@


1.45
log
@Fold struct block0 into struct partition map. There can be only one
and read/write_block0() can move the data from/to disk to/from
appropriate fields anywhere. Removes a bunch of dereferencing,
malloc'ing and pointer checking.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.44 2016/01/28 13:01:33 krw Exp $	*/
d127 1
a127 1
		return 0;
d185 1
a185 1
		return 0;
d235 1
a235 1
		return 0;
d308 1
a308 1
		return 0;
@


1.44
log
@Use consistent 'return' idiom -- no parenthesis since that was the style
of the existing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.43 2016/01/26 21:07:54 krw Exp $	*/
d31 1
d40 1
d119 1
a119 1
read_block0(int fd, struct block0 *block0)
d132 21
a152 21
	memcpy(&block0->sbSig, block0_ondisk->sbSig,
	    sizeof(block0->sbSig));
	block0->sbSig = betoh16(block0->sbSig);
	memcpy(&block0->sbBlkSize, block0_ondisk->sbBlkSize,
	    sizeof(block0->sbBlkSize));
	block0->sbBlkSize = betoh16(block0->sbBlkSize);
	memcpy(&block0->sbBlkCount, block0_ondisk->sbBlkCount,
	    sizeof(block0->sbBlkCount));
	block0->sbBlkCount = betoh32(block0->sbBlkCount);
	memcpy(&block0->sbDevType, block0_ondisk->sbDevType,
	    sizeof(block0->sbDevType));
	block0->sbDevType = betoh16(block0->sbDevType);
	memcpy(&block0->sbDevId, block0_ondisk->sbDevId,
	    sizeof(block0->sbDevId));
	block0->sbDevId = betoh16(block0->sbDevId);
	memcpy(&block0->sbData, block0_ondisk->sbData,
	    sizeof(block0->sbData));
	block0->sbData = betoh32(block0->sbData);
	memcpy(&block0->sbDrvrCount, block0_ondisk->sbDrvrCount,
	    sizeof(block0->sbDrvrCount));
	block0->sbDrvrCount = betoh16(block0->sbDrvrCount);
d156 1
a156 1
		    block0->sbDDMap+i*sizeof(struct ddmap_ondisk),
d158 10
a167 10
		memcpy(&block0->sbDDMap[i].ddBlock, &ddmap_ondisk.ddBlock,
		    sizeof(block0->sbDDMap[i].ddBlock));
		block0->sbDDMap[i].ddBlock =
		    betoh32(block0->sbDDMap[i].ddBlock);
		memcpy(&block0->sbDDMap[i].ddSize, &ddmap_ondisk.ddSize,
		    sizeof(block0->sbDDMap[i].ddSize));
		block0->sbDDMap[i].ddSize = betoh16(block0->sbDDMap[i].ddSize);
		memcpy(&block0->sbDDMap[i].ddType, &ddmap_ondisk.ddType,
		    sizeof(block0->sbDDMap[i].ddType));
		block0->sbDDMap[i].ddType = betoh32(block0->sbDDMap[i].ddType);
d175 1
a175 1
write_block0(int fd, struct block0 *block0)
d187 1
a187 1
	tmp16 = htobe16(block0->sbSig);
d190 1
a190 1
	tmp16 = htobe16(block0->sbBlkSize);
d193 1
a193 1
	tmp32 = htobe32(block0->sbBlkCount);
d196 1
a196 1
	tmp16 = htobe16(block0->sbDevType);
d199 1
a199 1
	tmp16 = htobe16(block0->sbDevId);
d202 1
a202 1
	tmp32 = htobe32(block0->sbData);
d205 1
a205 1
	tmp16 = htobe16(block0->sbDrvrCount);
d210 1
a210 1
		tmp32 = htobe32(block0->sbDDMap[i].ddBlock);
d213 1
a213 1
		tmp16 = htobe16(block0->sbDDMap[i].ddSize);
d216 1
a216 1
		tmp16 = betoh32(block0->sbDDMap[i].ddType);
d219 1
a219 1
		memcpy(block0->sbDDMap+i*sizeof(struct ddmap_ondisk),
@


1.43
log
@dpme_name and dpme_type are NUL-terminated in Apple code, so use
strlcpy() to fill them.

They are also supposed to be NUL-padded so zap previous contents
before copying in possibly shorter new values.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.42 2016/01/26 16:13:09 krw Exp $	*/
d91 1
a91 1
		return (1);
d100 1
a100 1
	return (0);
d110 1
a110 1
		return (1);
d113 1
a113 1
	return (0);
@


1.42
log
@Whitespace, line wrapping fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.41 2016/01/25 23:43:20 krw Exp $	*/
d285 1
a285 1
	memcpy(dpme->dpme_name, dpme_ondisk->dpme_name,
d287 1
a287 1
	memcpy(dpme->dpme_type, dpme_ondisk->dpme_type,
d289 1
a289 1
	memcpy(dpme->dpme_processor_id, dpme_ondisk->dpme_processor_id,
@


1.41
log
@Use new read/write_block0 and read/write_dpme which handle any
endian or alignment issues forcefully. Removes need for convert_*
functions so unhook convert.c from build. read/write_block become
static functions inside file_media.c.

Tweak struct block0 to stop trying to handle alignment issues by clever
declaration. Rely on the new functions to accurately translate between
on-disk and in-memory layouts.

Enables pdisk to work on amd64 and likely other architectures if
it's ever desirable. Does bring back DEV_BSIZE to pdisk.c since the
in-memory structure will *not* be 512 bytes on other archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.40 2016/01/25 22:12:22 krw Exp $	*/
d158 2
a159 1
		block0->sbDDMap[i].ddBlock = betoh32(block0->sbDDMap[i].ddBlock);
@


1.40
log
@Add read/write_block0 and read/write_dpme functions, not yet used.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.39 2016/01/23 03:46:18 krw Exp $	*/
d81 4
a84 1
int
d103 1
a103 1
int
a119 1
#if 0
a121 1
#endif
a151 1
#if 0
a165 1
#endif
a174 1
#if 0
d176 1
a176 2
#endif
	int rslt;
d197 1
a197 1
	memcpy(block0_ondisk->sbDevId, &tmp32,
a205 1
#if 0
a218 1
#endif
@


1.39
log
@Flip read_block() and write_block() back to taking sector addresses
instead of off_t values. Do the DEV_BSIZE multiplication in these two
functions.

Easier to read code and kills two #include <sys/param.h>.

Kill unused label.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.38 2016/01/22 12:31:04 krw Exp $	*/
d34 2
d38 1
d41 40
d111 257
@


1.38
log
@Merge read_block() and read_file_media() into read_block(). Ditto
write_block() and write_file_media(). One layer of read/write
wrappers for pread/pwrite should be enough for anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.37 2016/01/21 15:33:21 krw Exp $	*/
d39 1
a39 1
read_block(int fd, off_t offset, void *address)
d43 1
a43 1
	off = pread(fd, address, DEV_BSIZE, offset);
d58 1
a58 1
write_block(int fd, off_t offset, void *address)
d62 1
a62 1
	off = pwrite(fd, address, DEV_BSIZE, offset);
@


1.37
log
@Hoist all file opening and ioctl calls into main(), passing a pointer to
a valid map to edit(). Should enable pledging a la fdisk at some point.

Since edit() always gets a valid map (and maintains its validity even when
'I'nitializing a new one) many checks for (map == NULL) are junked.

Remove some dances around block sizes by using DEV_BSIZE everywhere
since we don't support non-DEV_BSIZE (a.k.a. 512-byte) sectors.

Remove many superfluous #include statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.36 2016/01/19 16:53:04 krw Exp $	*/
d38 2
a39 3
long
read_file_media(int fd, long long offset, unsigned long count,
		void *address)
d43 2
a44 2
	off = pread(fd, address, count, offset);
	if (off == count)
d57 2
a58 4

long
write_file_media(int fd, long long offset, unsigned long count,
		 void *address)
d62 2
a63 2
	off = pwrite(fd, address, count, offset);
	if (off == count)
@


1.36
log
@Remove forward declarations for functions that do not exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.35 2016/01/18 17:57:35 krw Exp $	*/
d31 1
a31 2
#include <sys/dkio.h>
#include <sys/disklabel.h>
a32 1

a33 1
#include <stdlib.h>
a34 7
#include <fcntl.h>
#include <limits.h>
#include <errno.h>

#include <sys/ioctl.h>
#include <sys/stat.h>
#include <util.h>
a36 33

void		compute_block_size(int, char *);

void
compute_block_size(int fd, char *name)
{
	struct disklabel dl;
	struct stat st;

	if (fstat(fd, &st) == -1)
		err(1, "can't fstat %s", name);
	if (!S_ISCHR(st.st_mode) && !S_ISREG(st.st_mode))
		errx(1, "%s is not a character device or a regular file", name);
	if (ioctl(fd, DIOCGPDINFO, &dl) == -1)
		err(1, "can't get disklabel for %s", name);

	if (dl.d_secsize != DEV_BSIZE)
		err(1, "%u-byte sector size not supported", dl.d_secsize);
}


int
open_file_as_media(char *file, int oflag)
{
	int fd;

	fd = opendev(file, oflag, OPENDEV_PART, NULL);
	if (fd >= 0)
		compute_block_size(fd, file);

	return (fd);
}

@


1.35
log
@struct file_media had 1 field left. And one place where struct
file_media was actually stored. So move the last field (fd) into
the place formerly used to store pointer to the instance. As a
result we can just pass fd's around rather than pointers to a struct
containing a fd.

close_file_media() becomes empty but for a close(). So just use
close() and nuke close_file_media().
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.34 2016/01/18 16:41:41 krw Exp $	*/
a48 1
void		file_init(void);
@


1.34
log
@Discard a whack of double and triple checking lseek/read/write parameters.
Just use pread/pwrite and report error emanating from them. No more
uses of size_in_byte field of struct file_media, so toss that too.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.33 2016/01/18 15:30:00 krw Exp $	*/
d69 1
a69 1
struct file_media *
a71 2
	struct stat info;
	struct file_media *a;
a73 1
	a = 0;
d75 4
a78 13
	if (fd >= 0) {
		a = malloc(sizeof(struct file_media));
		if (a != 0) {
			compute_block_size(fd, file);
			a->fd = fd;
			if (fstat(fd, &info) < 0) {
				warn("can't stat file '%s'", file);
			}
		} else {
			close(fd);
		}
	}
	return (a);
d83 1
a83 1
read_file_media(struct file_media *a, long long offset, unsigned long count,
d88 1
a88 1
	off = pread(a->fd, address, count, offset);
d104 1
a104 1
write_file_media(struct file_media *a, long long offset, unsigned long count,
d109 1
a109 1
	off = pwrite(a->fd, address, count, offset);
a114 11
}


long
close_file_media(struct file_media * a)
{
	if (a == 0) {
		return 0;
	}
	close(a->fd);
	return 1;
@


1.33
log
@os_reload_file_media() doesn't do anything except tell you if you passed it
a NULL pointer. And the result is ignored. Nuke it. This removes the only
use of the 'regular_file' field of struct file_media. So nuke that too.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.32 2016/01/18 14:55:08 krw Exp $	*/
a73 1
	off_t off;
a81 2
			off = lseek(fd, 0, SEEK_END);
			a->size_in_bytes = (long long) off;
d95 1
a95 1
read_file_media(struct file_media * a, long long offset, unsigned long count,
d98 14
a111 35
	off_t off;
	long rtn_value;
	int t;

	rtn_value = 0;
	if (a == 0) {
		/* no media */
		fprintf(stderr, "no media\n");
	} else if (count <= 0 || count % DEV_BSIZE != 0) {
		/* can't handle size */
		fprintf(stderr, "bad size\n");
	} else if (offset < 0 || offset % DEV_BSIZE != 0) {
		/* can't handle offset */
		fprintf(stderr, "bad offset\n");
	} else if (offset + count > a->size_in_bytes && a->size_in_bytes !=
	    (long long) 0) {
		/* check for offset (and offset+count) too large */
		fprintf(stderr, "offset+count too large\n");
	} else if (count > LLONG_MAX - offset) {
		/* check for offset (and offset+count) too large */
		fprintf(stderr, "offset+count too large 2\n");
	} else {
		/* do the read */
		off = offset;
		if ((off = lseek(a->fd, off, SEEK_SET)) >= 0) {
			if ((t = read(a->fd, address, count)) == count) {
				rtn_value = 1;
			} else {
				fprintf(stderr, "read failed\n");
			}
		} else {
			fprintf(stderr, "lseek failed\n");
		}
	}
	return rtn_value;
d116 1
a116 1
write_file_media(struct file_media * a, long long offset, unsigned long count,
d119 8
a126 26
	off_t off;
	long rtn_value;
	int t;

	rtn_value = 0;
	if (a == 0) {
		/* no media */
	} else if (count <= 0 || count % DEV_BSIZE != 0) {
		/* can't handle size */
	} else if (offset < 0 || offset % DEV_BSIZE != 0) {
		/* can't handle offset */
	} else if (count > LLONG_MAX - offset) {
		/* check for offset (and offset+count) too large */
	} else {
		/* do the write  */
		off = offset;
		if ((off = lseek(a->fd, off, SEEK_SET)) >= 0) {
			if ((t = write(a->fd, address, count)) == count) {
				if (off + count > a->size_in_bytes) {
					a->size_in_bytes = off + count;
				}
				rtn_value = 1;
			}
		}
	}
	return rtn_value;
@


1.32
log
@Run indent(1) over it and tweak the results a bit manually to look more
KNF'ish.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.31 2016/01/18 00:04:36 krw Exp $	*/
a85 1
			a->regular_file = 0;
a87 2
			} else {
				a->regular_file = S_ISREG(info.st_mode);
a179 18
}


long
os_reload_file_media(struct file_media * a)
{
	long rtn_value;

	rtn_value = 0;
	if (a == 0) {
		/* no media */
	} else if (a->regular_file) {
		/* okay - nothing to do */
		rtn_value = 1;
	} else {
		rtn_value = 1;
	}
	return rtn_value;
@


1.31
log
@Remove a grab bag of unused #define's, fields, enum's, variables,
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.30 2016/01/17 23:18:19 krw Exp $	*/
d30 1
a30 1
#include <sys/param.h>	/* DEV_BSIZE */
d48 2
a49 2
void compute_block_size(int, char *);
void file_init(void);
d72 23
a94 22
    struct file_media	*a;
    int			fd;
    off_t off;
    struct stat info;

    a = 0;
    fd = opendev(file, oflag, OPENDEV_PART, NULL);
    if (fd >= 0) {
	a = malloc(sizeof(struct file_media));
	if (a != 0) {
	    compute_block_size(fd, file);
	    off = lseek(fd, 0, SEEK_END);	/* seek to end of media */
	    a->size_in_bytes = (long long) off;
	    a->fd = fd;
	    a->regular_file = 0;
	    if (fstat(fd, &info) < 0) {
		warn("can't stat file '%s'", file);
	    } else {
		a->regular_file = S_ISREG(info.st_mode);
	    }
	} else {
	    close(fd);
d96 1
a96 2
    }
    return (a);
d101 2
a102 2
read_file_media(struct file_media *a, long long offset, unsigned long count,
    void *address)
d104 21
a124 29
    long rtn_value;
    off_t off;
    int t;

    rtn_value = 0;
    if (a == 0) {
	/* no media */
	fprintf(stderr,"no media\n");
    } else if (count <= 0 || count % DEV_BSIZE != 0) {
	/* can't handle size */
	fprintf(stderr,"bad size\n");
    } else if (offset < 0 || offset % DEV_BSIZE != 0) {
	/* can't handle offset */
	fprintf(stderr,"bad offset\n");
    } else if (offset + count > a->size_in_bytes && a->size_in_bytes != (long long) 0) {
	/* check for offset (and offset+count) too large */
	fprintf(stderr,"offset+count too large\n");
    } else if (count > LLONG_MAX - offset) {
	/* check for offset (and offset+count) too large */
	fprintf(stderr,"offset+count too large 2\n");
    } else {
	/* do the read */
	off = offset;
	if ((off = lseek(a->fd, off, SEEK_SET)) >= 0) {
	    if ((t = read(a->fd, address, count)) == count) {
		rtn_value = 1;
	    } else {
		fprintf(stderr,"read failed\n");
	    }
d126 11
a136 1
	    fprintf(stderr,"lseek failed\n");
d138 1
a138 2
    }
    return rtn_value;
d143 2
a144 2
write_file_media(struct file_media *a, long long offset, unsigned long count,
    void *address)
d146 23
a168 20
    long rtn_value;
    off_t off;
    int t;

    rtn_value = 0;
    if (a == 0) {
	/* no media */
    } else if (count <= 0 || count % DEV_BSIZE != 0) {
	/* can't handle size */
    } else if (offset < 0 || offset % DEV_BSIZE != 0) {
	/* can't handle offset */
    } else if (count > LLONG_MAX - offset) {
	/* check for offset (and offset+count) too large */
    } else {
	/* do the write  */
	off = offset;
	if ((off = lseek(a->fd, off, SEEK_SET)) >= 0) {
	    if ((t = write(a->fd, address, count)) == count) {
		if (off + count > a->size_in_bytes) {
			a->size_in_bytes = off + count;
a169 2
		rtn_value = 1;
	    }
d171 1
a171 2
    }
    return rtn_value;
d176 1
a176 1
close_file_media(struct file_media *a)
d178 5
a182 6
    if (a == 0) {
	return 0;
    }

    close(a->fd);
    return 1;
d187 1
a187 1
os_reload_file_media(struct file_media *a)
d189 1
a189 1
    long rtn_value;
d191 10
a200 10
    rtn_value = 0;
    if (a == 0) {
	/* no media */
    } else if (a->regular_file) {
	/* okay - nothing to do */
	rtn_value = 1;
    } else {
	rtn_value = 1;
    }
    return rtn_value;
@


1.30
log
@Change "//" comments to "/**/". Nuke really stupid ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.29 2016/01/17 19:39:20 krw Exp $	*/
a47 2
static long file_inited = 0;

a51 10
file_init(void)
{
    if (file_inited != 0) {
	return;
    }
    file_inited = 1;
}


void
a75 4

    if (file_inited == 0) {
	    file_init();
    }
@


1.29
log
@Reduce namespace pollution by eliminating parameter names from forward
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.28 2016/01/17 18:57:52 krw Exp $	*/
a99 1
	    //printf("file size = %Ld\n", off);
@


1.28
log
@Remove a bunch of ridiculous and uninformative comments like "// Defines".
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.27 2016/01/17 15:57:12 krw Exp $	*/
d50 1
a50 1
void compute_block_size(int fd, char *name);
@


1.27
log
@Let the great de-typedef'ification begin. MEDIA -> struct file_media *.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.26 2016/01/16 22:28:14 krw Exp $	*/
a34 1
// for printf()
a35 1
// for malloc() & free()
a36 1
// for lseek(), read(), write(), close()
a37 1
// for open()
a38 1
// for LONG_MAX
a39 1
// for errno
a47 14

/*
 * Types
 */


/*
 * Global Constants
 */


/*
 * Global Variables
 */
a49 3
/*
 * Forward declarations
 */
a52 3
/*
 * Routines
 */
@


1.26
log
@Move last field (size_in_bytes) in struct media to struct file_media
and replace MEDIA with FILE_MEDIA everywhere. media.h becomes unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.25 2016/01/16 22:04:20 krw Exp $	*/
d107 1
a107 1
FILE_MEDIA
d110 1
a110 1
    FILE_MEDIA	a;
d139 1
a139 1
    return (FILE_MEDIA) a;
d144 1
a144 1
read_file_media(FILE_MEDIA a, long long offset, unsigned long count,
d185 2
a186 1
write_file_media(FILE_MEDIA a, long long offset, unsigned long count, void *address)
d218 1
a218 1
close_file_media(FILE_MEDIA a)
d230 1
a230 1
os_reload_file_media(FILE_MEDIA a)
@


1.25
log
@Oops. Missed a file.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.24 2016/01/16 21:41:41 krw Exp $	*/
a57 7
typedef struct file_media *FILE_MEDIA;

struct file_media {
    struct media	m;
    int			fd;
    int			regular_file;
};
d107 1
a107 1
MEDIA
d127 1
a127 1
	    a->m.size_in_bytes = (long long) off;
d139 1
a139 1
    return (MEDIA) a;
d144 2
a145 1
read_file_media(MEDIA m, long long offset, unsigned long count, void *address)
a146 1
    FILE_MEDIA a;
a150 1
    a = (FILE_MEDIA) m;
d161 1
a161 1
    } else if (offset + count > a->m.size_in_bytes && a->m.size_in_bytes != (long long) 0) {
d185 1
a185 1
write_file_media(MEDIA m, long long offset, unsigned long count, void *address)
a186 1
    FILE_MEDIA a;
a190 1
    a = (FILE_MEDIA) m;
d205 2
a206 2
		if (off + count > a->m.size_in_bytes) {
			a->m.size_in_bytes = off + count;
d217 1
a217 1
close_file_media(MEDIA m)
a218 3
    FILE_MEDIA a;

    a = (FILE_MEDIA) m;
d229 1
a229 1
os_reload_file_media(MEDIA m)
a230 1
    FILE_MEDIA a;
a232 1
    a = (FILE_MEDIA) m;
@


1.24
log
@There can be only one. 'grain' that is. i.e. DEV_BSIZE. No need to track
or store. Just use.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.23 2016/01/16 21:29:07 krw Exp $	*/
a81 1
FILE_MEDIA new_file_media(void);
a95 7
FILE_MEDIA
new_file_media(void)
{
    return (FILE_MEDIA) new_media(sizeof(struct file_media));
}


d129 1
a129 1
	a = new_file_media();
@


1.23
log
@There can be only one. 'kind' that is. No need to allocate or track the
media kind since it will always be the same -- a file.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.22 2016/01/16 20:00:50 krw Exp $	*/
d80 1
a80 1
int compute_block_size(int fd, char *name);
d104 1
a104 1
int
a118 2

	return (dl.d_secsize);
d139 1
a139 1
	    a->m.grain = compute_block_size(fd, file);
d171 1
a171 1
    } else if (count <= 0 || count % a->m.grain != 0) {
d174 1
a174 1
    } else if (offset < 0 || offset % a->m.grain != 0) {
d212 1
a212 1
    } else if (count <= 0 || count % a->m.grain != 0) {
d214 1
a214 1
    } else if (offset < 0 || offset % a->m.grain != 0) {
@


1.22
log
@Start peeling away excess layers of abstraction.

Since 'file' is the only kind of media, no need to call the appropriate
functions via pointers. Just call the _file_ variants directly.
Nuke the fields do_read(), do_write(), do_close(), do_os_reload()
and the functions read_media(), write_media(), close_media() and
os_reload_media().

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.21 2016/01/16 14:49:28 krw Exp $	*/
a65 4
struct file_media_globals {
    long		exists;
    long		kind;
};
a75 1
static struct file_media_globals file_info;
a93 2

    file_info.kind = allocate_media_kind();
a140 1
	    a->m.kind = file_info.kind;
a172 3
    } else if (a->m.kind != file_info.kind) {
	/* wrong kind - XXX need to error here - this is an internal problem */
	fprintf(stderr,"wrong kind\n");
a213 2
    } else if (a->m.kind != file_info.kind) {
	/* wrong kind - XXX need to error here - this is an internal problem */
a243 3
    } else if (a->m.kind != file_info.kind) {
	/* XXX need to error here - this is an internal problem */
	return 0;
a260 2
    } else if (a->m.kind != file_info.kind) {
	/* wrong kind - XXX need to error here - this is an internal problem */
@


1.21
log
@Nuke support for 1024- and 2048-byte sector devices. Error out if
anything other than 512-byte sectors are encountered. Unlink
deblock_media.c from the build.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.20 2016/01/15 23:16:40 krw Exp $	*/
a87 4
long read_file_media(MEDIA m, long long offset, unsigned long count, void *address);
long write_file_media(MEDIA m, long long offset, unsigned long count, void *address);
long close_file_media(MEDIA m);
long os_reload_file_media(MEDIA m);
a152 4
	    a->m.do_read = read_file_media;
	    a->m.do_write = write_file_media;
	    a->m.do_close = close_file_media;
	    a->m.do_os_reload = os_reload_file_media;
@


1.20
log
@As with compute_device_size(), gut compute_block_size() and simply
ask the disklabel as everyone else does. Add file name to
compute_block_size() parameters to make error messages nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.19 2016/01/13 00:12:49 krw Exp $	*/
a73 4
int potential_block_sizes[] = {
    1, 512, 1024, 2048,
    0
};
d127 3
@


1.19
log
@Nuke unused enum.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.18 2016/01/12 23:48:42 krw Exp $	*/
d30 3
d89 1
a89 1
int compute_block_size(int fd);
d120 1
a120 1
compute_block_size(int fd)
d122 9
a130 17
    int size;
    int max_size;
    off_t x;
    long t;
    int i;
    char *buffer;

    max_size = 0;
    for (i = 0; ; i++) {
    	size = potential_block_sizes[i];
    	if (size == 0) {
	    break;
    	}
    	if (max_size < size) {
	    max_size = size;
    	}
    }
d132 1
a132 19
    buffer = malloc(max_size);
    if (buffer != 0) {
	for (i = 0; ; i++) {
	    size = potential_block_sizes[i];
	    if (size == 0) {
		break;
	    }
	    if ((x = lseek(fd, 0, SEEK_SET)) < 0) {
		warn("Can't seek on file");
		break;
	    }
	    if ((t = read(fd, buffer, size)) == size) {
		free(buffer);
		return size;
	    }
	}
    }
    free(buffer);
    return 0;
d154 1
a154 1
	    a->m.grain = compute_block_size(fd);
@


1.18
log
@#define LOFF_T off_t
#define llseek lseek
#define LOFF_T_MAX LLONG_MAX

I mean, really? Nuke'em and use off_t, lseek and LLONG_MAX.

Also make a couple of checks for overflow of off_t value more likely
to work.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.17 2016/01/12 20:09:39 krw Exp $	*/
a73 7
};

enum {
    kSCSI_Disks = 0,
    kATA_Devices = 1,
    kSCSI_CDs = 2,
    kMaxStyle = 2
@


1.17
log
@Use normal err/errx/warn/warnx rather than handrolling new ones. Move
usage() to pdisk.c and nuke do_help() and '-h'.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.16 2016/01/12 16:08:37 krw Exp $	*/
a52 8
 * Defines
 */
#define loff_t off_t
#define llseek lseek
#define LOFF_MAX LLONG_MAX


/*
d128 1
a128 1
    loff_t x;
d151 1
a151 1
	    if ((x = llseek(fd, (loff_t)0, SEEK_SET)) < 0) {
d171 1
a171 1
    loff_t off;
d185 1
a185 1
	    off = llseek(fd, (loff_t)0, SEEK_END);	/* seek to end of media */
d212 1
a212 1
    loff_t off;
d232 1
a232 1
    } else if (offset + count > (long long) LOFF_MAX) {
d238 1
a238 1
	if ((off = llseek(a->fd, off, SEEK_SET)) >= 0) {
d257 1
a257 1
    loff_t off;
d270 1
a270 1
    } else if (offset + count > (long long) LOFF_MAX) {
d275 1
a275 1
	if ((off = llseek(a->fd, off, SEEK_SET)) >= 0) {
@


1.16
log
@Remove media interation types, structures and functions. They are not used
anywhere, as evidenced by everything still compiling after they are gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.15 2016/01/11 17:55:45 jasper Exp $	*/
d30 2
a49 1
#include "errors.h"
d160 1
a160 1
		error(errno, "Can't seek on file");
d203 1
a203 1
		error(errno, "can't stat file '%s'", file);
@


1.15
log
@- remove some unused data structures/fields
- unifdef notdef

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.14 2016/01/11 14:27:29 jasper Exp $	*/
a74 9
typedef struct file_media_iterator *FILE_MEDIA_ITERATOR;

struct file_media_iterator {
    struct media_iterator   m;
    long		    style;
    long		    index;
};


a106 5
FILE_MEDIA_ITERATOR new_file_iterator(void);
void reset_file_iterator(MEDIA_ITERATOR m);
char *step_file_iterator(MEDIA_ITERATOR m);
void delete_file_iterator(MEDIA_ITERATOR m);

a331 172
}


FILE_MEDIA_ITERATOR
new_file_iterator(void)
{
    return (FILE_MEDIA_ITERATOR) new_media_iterator(sizeof(struct file_media_iterator));
}


MEDIA_ITERATOR
create_file_iterator(void)
{
    FILE_MEDIA_ITERATOR a;

    if (file_inited == 0) {
	file_init();
    }

    a = new_file_iterator();
    if (a != 0) {
	a->m.kind = file_info.kind;
	a->m.state = kInit;
	a->m.do_reset = reset_file_iterator;
	a->m.do_step = step_file_iterator;
	a->m.do_delete = delete_file_iterator;
	a->style = 0;
	a->index = 0;
    }

    return (MEDIA_ITERATOR) a;
}


void
reset_file_iterator(MEDIA_ITERATOR m)
{
    FILE_MEDIA_ITERATOR a;

    a = (FILE_MEDIA_ITERATOR) m;
    if (a == 0) {
	/* no media */
    } else if (a->m.kind != file_info.kind) {
	/* wrong kind - XXX need to error here - this is an internal problem */
    } else if (a->m.state != kInit) {
	a->m.state = kReset;
    }
}


char *
step_file_iterator(MEDIA_ITERATOR m)
{
    FILE_MEDIA_ITERATOR a;
    char *result;
    struct stat info;
    int	fd;
    int bump;
    int value;

    a = (FILE_MEDIA_ITERATOR) m;
    if (a == 0) {
	/* no media */
    } else if (a->m.kind != file_info.kind) {
	/* wrong kind - XXX need to error here - this is an internal problem */
    } else {
	switch (a->m.state) {
	case kInit:
	    a->m.state = kReset;
	    /* fall through to reset */
	case kReset:
	    a->style = 0 /* first style */;
	    a->index = 0 /* first index */;
	    a->m.state = kIterating;
	    /* fall through to iterate */
	case kIterating:
	    while (1) {
		if (a->style > kMaxStyle) {
		    break;
		}

		/* if old version of mklinux then skip CD drive */
		if (a->style == kSCSI_Disks && a->index == 3) {
		    a->index += 1;
		}

		/* generate result */
		result = malloc(20);
		if (result != NULL) {
		    /*
		     * for DR3 we should actually iterate through:
		     *
		     *    /dev/sd[a...]    # first missing is end of list
		     *    /dev/hd[a...]    # may be holes in sequence
		     *    /dev/scd[0...]   # first missing is end of list
		     *
		     * and stop in each group when either a stat of
		     * the name fails or if an open fails for
		     * particular reasons.
		     */
		    bump = 0;
		    value = (int) a->index;
		    switch (a->style) {
		    case kSCSI_Disks:
			if (value < 26) {
			    snprintf(result, 20, "/dev/sd%c", 'a'+value);
			} else if (value < 676) {
			    snprintf(result, 20, "/dev/sd%c%c",
				    'a' + value / 26,
				    'a' + value % 26);
			} else {
			    bump = -1;
			}
			break;
		    case kATA_Devices:
			if (value < 26) {
			    snprintf(result, 20, "/dev/hd%c", 'a'+value);
			} else {
			    bump = -1;
			}
			break;
		    case kSCSI_CDs:
			if (value < 10) {
			    snprintf(result, 20, "/dev/scd%c", '0'+value);
			} else {
			    bump = -1;
			}
			break;
		    }
		    if (bump != 0) {
			// already set don't even check
		    } else if (stat(result, &info) < 0) {
			bump = 1;
		    } else if ((fd = open(result, O_RDONLY)) >= 0) {
			close(fd);
		    } else if (errno == ENXIO || errno == ENODEV) {
			if (a->style == kATA_Devices) {
			    bump = -1;
			} else {
			    bump = 1;
			}
		    }
		    if (bump) {
			if (bump > 0) {
			    a->style += 1; /* next style */
			    a->index = 0; /* first index again */
			} else {
			    a->index += 1; /* next index */
			}
			free(result);
			continue;
		    }
		}

		a->index += 1; /* next index */
		return result;
	    }
	    a->m.state = kEnd;
	    /* fall through to end */
	case kEnd:
	default:
	    break;
	}
    }
    return 0 /* no entry */;
}


void
delete_file_iterator(MEDIA_ITERATOR m)
{
    return;
@


1.14
log
@plug a mem leak

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.13 2016/01/11 07:57:54 jasper Exp $	*/
d426 1
a426 1
#ifndef notdef
d431 1
a431 1
#endif
@


1.13
log
@trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: file_media.c,v 1.12 2016/01/11 07:54:07 jasper Exp $	*/
d182 1
@


1.12
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d193 1
a193 1
	
@


1.11
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 2
@


1.10
log
@use opendev(), as requested in 6373.  document this using text borrowed from
disklabel(8), and while at it, fix the usage code to not be utterly distasteful
ok drahn
@
text
@d430 1
a430 1
		result = (char *) malloc(20);
@


1.9
log
@remove a bunch of linux and NeXT defines and, in turn, -D__unix__
@
text
@d43 1
d197 1
a197 1
    fd = open(file, oflag);
@


1.8
log
@With last pdisk and full functionality for mac68k now in place, start
cleaning the maze of ifdef's not relevant for us.

This round wipes most linux and/or MacOS-only bits, more to come.
@
text
@a50 4
#ifdef __linux__
#define LOFF_MAX 9223372036854775807LL
extern __loff_t llseek (int __fd, __loff_t __offset, int __whence);
#elif defined(__OpenBSD__) || defined(__APPLE__)
a53 5
#else
#define loff_t long
#define llseek lseek
#define LOFF_MAX LONG_MAX
#endif
a188 1
#if defined(__linux__) || defined(__unix__)
a189 1
#endif
a210 1
#if defined(__linux__) || defined(__unix__)
a215 1
#endif
a476 1
#if defined(__linux__) || defined(__unix__)
a482 1
#endif
@


1.7
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@a40 7
#ifdef __linux__
#include <sys/ioctl.h>
#include <linux/fs.h>
#include <linux/hdreg.h>
#include <sys/stat.h>
#else
#ifdef __unix__
a42 2
#endif
#endif
a213 5
#if !defined(__linux__) && !defined(__unix__)
	    if (off <= 0) {
		off = 1; /* XXX not right? */
	    }
#endif
d289 1
a289 1
	
d341 1
a341 5
#if defined(__linux__)
    int i;
    int saved_errno;
#endif
	
a351 26
#ifdef __linux__
	sync();
	sleep(2);
	if ((i = ioctl(a->fd, BLKRRPART)) != 0) {
	    saved_errno = errno;
	} else {
	    // some kernel versions (1.2.x) seem to have trouble
	    // rereading the partition table, but if asked to do it
	    // twice, the second time works. - biro@@yggdrasil.com */
	    sync();
	    sleep(2);
	    if ((i = ioctl(a->fd, BLKRRPART)) != 0) {
		saved_errno = errno;
	    }
	}

	// printf("Syncing disks.\n");
	sync();
	sleep(4);		/* for sync() */

	if (i < 0) {
	    error(saved_errno, "Re-read of partition table failed");
	    printf("Reboot your system to ensure the "
		    "partition table is updated.\n");
	}
#endif
a355 5


#if !defined(__linux__) && !defined(__unix__)
#pragma mark -
#endif
@


1.6
log
@use SEEK_* for lseek()
@
text
@d4 1
a4 1
 * Written by Eryk Vershen (eryk@@apple.com)
d46 4
a50 3

#ifdef __OpenBSD__
#include <sys/stat.h>
d62 5
a66 1
extern __loff_t llseek(int __fd, __loff_t __offset, int __whence);
d207 1
a207 1
#if defined(__linux__) || defined(__OpenBSD__)
d236 1
a236 1
#if defined(__linux__) || defined(__OpenBSD__)
d263 1
a263 1
	//printf("no media\n");
d266 1
a266 1
	//printf("wrong kind\n");
d269 1
a269 1
	//printf("bad size\n");
d272 1
a272 1
	//printf("bad offset\n");
d275 1
a275 1
	//printf("offset+count too large\n");
d278 1
a278 1
	//printf("offset+count too large 2\n");
d286 1
a286 1
		//printf("read failed\n");
d289 1
a289 1
	    //printf("lseek failed\n");
d355 1
a355 1
#ifdef __linux__
d402 1
d404 1
d460 3
a462 1
    size_t len = 20;
d491 1
a491 1
		result = (char *) malloc(len);
d501 2
a502 2
		     * the name fails or if an open fails (except opens
		     * will fail if you run not as root)
d504 2
d508 9
a516 5
#ifdef __OpenBSD__
			snprintf(result, len, "/dev/sd%dc", (int)a->index);
#else
			snprintf(result, len, "/dev/sd%c", 'a'+(int)a->index);
#endif
d519 5
a523 5
#ifdef __OpenBSD__
			snprintf(result, len, "/dev/wd%dc", (int)a->index);
#else
			snprintf(result, len, "/dev/hd%c", 'a'+(int)a->index);
#endif
d526 20
a545 4
#ifdef __OpenBSD__
			snprintf(result, len, "/dev/cd%dc", (int)a->index);
#else
			snprintf(result, len, "/dev/scd%c", '0'+(int)a->index);
a546 1
			break;
d548 7
a554 3
		    if (stat(result, &info) < 0) {
			a->style += 1; /* next style */
			a->index = 0; /* first index again */
@


1.5
log
@snprintf; drahn ok
@
text
@d182 1
a182 1
	    if ((x = llseek(fd, (loff_t)0, 0)) < 0) {
d217 1
a217 1
	    off = llseek(fd, (loff_t)0, 2);	/* seek to end of media */
d277 1
a277 1
	if ((off = llseek(a->fd, off, 0)) >= 0) {
d314 1
a314 1
	if ((off = llseek(a->fd, off, 0)) >= 0) {
@


1.4
log
@rm trailing whitespace
@
text
@d453 1
d482 1
a482 1
		result = (char *) malloc(20);
d498 1
a498 1
			sprintf(result, "/dev/sd%dc", (int)a->index);
d500 1
a500 1
			sprintf(result, "/dev/sd%c", 'a'+(int)a->index);
d505 1
a505 1
			sprintf(result, "/dev/wd%dc", (int)a->index);
d507 1
a507 1
			sprintf(result, "/dev/hd%c", 'a'+(int)a->index);
d512 1
a512 1
			sprintf(result, "/dev/cd%dc", (int)a->index);
d514 1
a514 1
			sprintf(result, "/dev/scd%c", '0'+(int)a->index);
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d9 17
a25 17
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
d142 1
a142 1
    
d163 1
a163 1
    
d174 1
a174 1
    
d209 1
a209 1
    
d331 1
a331 1
    
d339 1
a339 1
    
d411 1
a411 1
    
d415 1
a415 1
    
d435 1
a435 1
    
d453 1
a453 1
    
@


1.2
log
@Make the apple code compile for OpenBSD. These changes are mostly from maja.
@
text
@d61 1
a61 1
extern __loff_t llseek __P ((int __fd, __loff_t __offset, int __whence));
@


1.1
log
@Initial revision
@
text
@d48 4
d202 1
a202 1
#ifdef __linux__
d231 1
a231 1
#ifdef __linux__
d496 3
d500 1
d503 3
d507 1
d510 3
d514 1
@


1.1.1.1
log
@Import of pdisk from apple, BSD licensed code. Archive dated Feb 18 1998 
This is a HFS partition editing tool.
@
text
@@
