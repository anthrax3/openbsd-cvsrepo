head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.10
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.7.0.40
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.32
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.36
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.34
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.30
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.28
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.26
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.24
	OPENBSD_5_0:1.7.0.22
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	ver1:1.1.1.1
	apple19980218:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.02.01.18.55.00;	author krw;	state Exp;
branches;
next	1.30;
commitid	szbJNGcTaZ1kG4a2;

1.30
date	2016.01.30.17.21.10;	author krw;	state Exp;
branches;
next	1.29;
commitid	BOQYiykYZJ8gnOpB;

1.29
date	2016.01.29.18.40.08;	author krw;	state Exp;
branches;
next	1.28;
commitid	A8P4plXiuUKUciE6;

1.28
date	2016.01.28.13.01.33;	author krw;	state Exp;
branches;
next	1.27;
commitid	00cCpXcvPr6DmCk2;

1.27
date	2016.01.27.16.38.37;	author krw;	state Exp;
branches;
next	1.26;
commitid	OxtaH45RCrnSeCna;

1.26
date	2016.01.27.00.26.33;	author krw;	state Exp;
branches;
next	1.25;
commitid	JYBy9gHn2rzRrFL4;

1.25
date	2016.01.27.00.03.52;	author krw;	state Exp;
branches;
next	1.24;
commitid	rqEjRk6knIDhhe6A;

1.24
date	2016.01.26.23.41.48;	author krw;	state Exp;
branches;
next	1.23;
commitid	RpcG9dSk73BpuL0t;

1.23
date	2016.01.26.16.39.00;	author krw;	state Exp;
branches;
next	1.22;
commitid	rZKRcHhLUVQAhJLw;

1.22
date	2016.01.24.01.38.32;	author krw;	state Exp;
branches;
next	1.21;
commitid	g7Azk2rL78IOOfnI;

1.21
date	2016.01.23.22.55.23;	author krw;	state Exp;
branches;
next	1.20;
commitid	rtEhuagLVJKBtrm1;

1.20
date	2016.01.23.19.14.04;	author krw;	state Exp;
branches;
next	1.19;
commitid	UnZYqZjmfQe3LcFQ;

1.19
date	2016.01.21.15.33.21;	author krw;	state Exp;
branches;
next	1.18;
commitid	YzEQpnBPgLX85u7F;

1.18
date	2016.01.19.17.55.19;	author krw;	state Exp;
branches;
next	1.17;
commitid	kYIZVKqwr3gv1uQg;

1.17
date	2016.01.18.15.03.18;	author krw;	state Exp;
branches;
next	1.16;
commitid	Zn2Bda3oZJrrkml4;

1.16
date	2016.01.17.23.18.19;	author krw;	state Exp;
branches;
next	1.15;
commitid	vC4VO4mr30PnBRSq;

1.15
date	2016.01.17.19.39.20;	author krw;	state Exp;
branches;
next	1.14;
commitid	slCzBfkhwAcLWsXe;

1.14
date	2016.01.17.19.15.55;	author krw;	state Exp;
branches;
next	1.13;
commitid	mHBjhdgm2kvWAkWc;

1.13
date	2016.01.17.18.57.52;	author krw;	state Exp;
branches;
next	1.12;
commitid	Rl8zxjpMi2a93hiE;

1.12
date	2016.01.12.23.48.42;	author krw;	state Exp;
branches;
next	1.11;
commitid	k0e5CXAF5NwSZwIj;

1.11
date	2016.01.12.20.09.39;	author krw;	state Exp;
branches;
next	1.10;
commitid	WFEddFcNLm6A2VYQ;

1.10
date	2016.01.11.07.57.54;	author jasper;	state Exp;
branches;
next	1.9;
commitid	HZWVhdOSzNAX4WBf;

1.9
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.8;
commitid	DI30r1mqHPQNkhTm;

1.8
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	0qPuuXwccpVXsXcV;

1.7
date	2006.05.11.17.20.40;	author martin;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.29.00.43.41;	author martin;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.05.07.39.17;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.24.00.20.59;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.24.00.14.06;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.24.00.14.06;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Use printf("%s",prompt) rather than printf(prompt) just for paranoia's
sake.
@
text
@/*	$OpenBSD: io.c,v 1.30 2016/01/30 17:21:10 krw Exp $	*/

/*
 * io.c - simple io and input parsing routines
 *
 * Written by Eryk Vershen
 */

/*
 * Copyright 1996,1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "partition_map.h"
#include "io.h"

#define UNGET_MAX_COUNT 10

short	unget_buf[UNGET_MAX_COUNT + 1];
int	unget_count;

static int	get_number(long *);
static char    *get_string(int);
static int	my_getch (void);

int
my_getch()
{
	if (unget_count > 0)
		return unget_buf[--unget_count];
	else
		return getc(stdin);
}


void
my_ungetch(int c)
{
	/*
         * In practice there is never more than one character in
         * the unget_buf, but what's a little overkill among friends?
         */
	if (unget_count < UNGET_MAX_COUNT)
		unget_buf[unget_count++] = c;
	else
		errx(1, "Programmer error in my_ungetch().");
}

void
flush_to_newline(int keep_newline)
{
	int c;

	for (;;) {
		c = my_getch();

		if (c <= 0) {
			break;
		} else if (c == '\n') {
			if (keep_newline)
				my_ungetch(c);
			break;
		} else {
			/* skip */
		}
	}
	return;
}


int
get_okay(const char *prompt, int default_value)
{
	int c;

	flush_to_newline(0);
	printf("%s", prompt);

	for (;;) {
		c = my_getch();

		if (c <= 0) {
			break;
		} else if (c == ' ' || c == '\t') {
			/* skip blanks and tabs */
		} else if (c == '\n') {
			my_ungetch(c);
			return default_value;
		} else if (c == 'y' || c == 'Y') {
			return 1;
		} else if (c == 'n' || c == 'N') {
			return 0;
		} else {
			flush_to_newline(0);
			printf("%s", prompt);
		}
	}
	return -1;
}

int
get_command(const char *prompt, int promptBeforeGet, int *command)
{
	int c;

	if (promptBeforeGet)
		printf("%s", prompt);

	for (;;) {
		c = my_getch();

		if (c <= 0) {
			break;
		} else if (c == ' ' || c == '\t') {
			/* skip blanks and tabs */
		} else if (c == '\n') {
			printf("%s", prompt);
		} else {
			*command = c;
			return 1;
		}
	}
	return 0;
}

int
get_number_argument(const char *prompt, long *number)
{
	int c;
	int result = 0;

	for (;;) {
		c = my_getch();

		if (c <= 0) {
			break;
		} else if (c == ' ' || c == '\t') {
			/* skip blanks and tabs */
		} else if (c == '\n') {
			printf("%s", prompt);
		} else if ('0' <= c && c <= '9') {
			my_ungetch(c);
			result = get_number(number);
			break;
		} else {
			my_ungetch(c);
			*number = 0;
			break;
		}
	}
	return result;
}


int
get_number(long *number)
{
	long value;
	int c;

	value = 0;
	while ((c = my_getch())) {
		if (c >= '0' && c <= '9') {
			value = value * 10 + (c - '0');
		} else if (c == ' ' || c == '\t' || c == '\n') {
			my_ungetch(c);
			*number = value;
			return 1;
		} else {
			return 0;
		}
	}

	return 0;
}

char *
get_dpistr_argument(const char *prompt)
{
	int c;

	for (;;) {
		c = my_getch();

		if (c <= 0) {
			break;
		} else if (c == ' ' || c == '\t') {
			/* skip blanks and tabs */
		} else if (c == '\n') {
			printf("%s", prompt);
		} else if (c == '"' || c == '\'') {
			return get_string(c);
		} else if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') ||
		    (c == '-' || c == '/' || c == '.' || c == ':')) {
			my_ungetch(c);
			return get_string(' ');
		} else {
			my_ungetch(c);
			return NULL;
		}
	}
	return NULL;
}


char *
get_string(int eos)
{
	char buf[DPISTRLEN+1];
	char *s, *limit;
	int c;

	memset(buf, 0, sizeof(buf));
	limit = buf + sizeof(buf);

	c = my_getch();
	for (s = buf;; c = my_getch()) {
		if (c <= 0 || c == eos || (eos == ' ' && c == '\t')) {
			*s = 0;
			break;
		} else if (c == '\n') {
			*s = 0;
			my_ungetch(c);
			break;
		} else {
			*s++ = c;
			if (s >= limit)
				return NULL;
		}
	}
	return strdup(buf);
}


unsigned long
get_multiplier(long divisor)
{
	unsigned long result, extra;
	int c;

	c = my_getch();

	extra = 1;
	if (c <= 0 || divisor <= 0) {
		result = 0;
	} else if (c == 't' || c == 'T') {
		result = 1024 * 1024;
		extra = 1024 * 1024;
	} else if (c == 'g' || c == 'G') {
		result = 1024 * 1024 * 1024;
	} else if (c == 'm' || c == 'M') {
		result = 1024 * 1024;
	} else if (c == 'k' || c == 'K') {
		result = 1024;
	} else {
		my_ungetch(c);
		result = 1;
	}
	if (result > 1) {
		if (extra > 1) {
			result /= divisor;
			if (result >= 4096)
				result = 0; /* overflow -> 20bits + >12bits */
			else
				result *= extra;
		} else if (result >= divisor) {
			result /= divisor;
		} else {
			result = 1;
		}
	}
	return result;
}


int
get_partition_modifier(void)
{
	int c, result;

	result = 0;

	c = my_getch();

	if (c == 'p' || c == 'P')
		result = 1;
	else if (c > 0)
		my_ungetch(c);

	return result;
}


int
number_of_digits(unsigned long value)
{
	int j;

	j = 1;
	while (value > 9) {
		j++;
		value = value / 10;
	}
	return j;
}


/*
 * Print a message on standard error & flush the input.
 */
void
bad_input(const char *fmt,...)
{
	va_list ap;

	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	fprintf(stderr, "\n");
	flush_to_newline(1);
}
@


1.30
log
@Move last three lines (#define's) from dpme.h to partition_map.h and
tweak #include's as necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.29 2016/01/29 18:40:08 krw Exp $	*/
d101 1
a101 1
	printf(prompt);
d119 1
a119 1
			printf(prompt);
d131 1
a131 1
		printf(prompt);
d141 1
a141 1
			printf(prompt);
d164 1
a164 1
			printf(prompt);
d214 1
a214 1
			printf(prompt);
@


1.29
log
@Base 10 should be enough for anybody!  Allowing hex and octal number
input for partition id's, partition starting points and partition
sizes is silly, especially since we never display anything but base
10 numbers.

Also ensure that numbers end with a space, tab or newline.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.28 2016/01/28 13:01:33 krw Exp $	*/
d30 2
d38 1
a38 1
#include "dpme.h"
@


1.28
log
@Use consistent 'return' idiom -- no parenthesis since that was the style
of the existing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.27 2016/01/27 16:38:37 krw Exp $	*/
a38 1
#define BAD_DIGIT 17		/* must be greater than any base */
d44 1
a44 1
static long	get_number(int);
d164 2
a165 2
			*number = get_number(c);
			result = 1;
d177 2
a178 2
long
get_number(int first_char)
d180 2
a181 1
	int c, base, digit, ret_value;
d183 11
a193 13
	if (first_char != '0') {
		c = first_char;
		base = 10;
		digit = BAD_DIGIT;
	} else if ((c = my_getch()) == 'x' || c == 'X') {
		c = my_getch();
		base = 16;
		digit = BAD_DIGIT;
	} else {
		my_ungetch(c);
		c = first_char;
		base = 8;
		digit = 0;
d195 2
a196 16
	ret_value = 0;
	for (ret_value = 0;; c = my_getch()) {
		if (c >= '0' && c <= '9')
			digit = c - '0';
		else if (c >= 'A' && c <= 'F')
			digit = 10 + (c - 'A');
		else if (c >= 'a' && c <= 'f')
			digit = 10 + (c - 'a');
		else
			digit = BAD_DIGIT;
		if (digit >= base)
			break;
		ret_value = ret_value * base + digit;
	}
	my_ungetch(c);
	return ret_value;
@


1.27
log
@On-disk partition name/types/processorid may or may not be NUL
terminated after all. So add an extra byte for a NUL in the in-memory
struct's.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.26 2016/01/27 00:26:33 krw Exp $	*/
d53 1
a53 1
		return (unget_buf[--unget_count]);
d55 1
a55 1
		return (getc(stdin));
d212 1
a212 1
	return (ret_value);
d269 1
a269 1
	return (strdup(buf));
@


1.26
log
@Nope. Missed a couple of '{}' that could go.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.25 2016/01/27 00:03:52 krw Exp $	*/
d247 1
a247 1
	char buf[DPISTRLEN];
@


1.25
log
@Nuke another (and I hope final) batch of superfluous '{}' around single
statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.24 2016/01/26 23:41:48 krw Exp $	*/
d83 1
a83 1
			if (keep_newline) {
a84 1
			}
d300 3
a302 4
			if (result >= 4096) {
				/* overflow -> 20bits + >12bits */
				result = 0;
			} else {
a303 1
			}
@


1.24
log
@Rework and simplify string argument parsing. All string arguments are at
most DPISTRLEN (32) characters so there is no need for fancy dynamic
growing strings. Use a DPISTRLEN long buffer and bail if it fills up.

Rename get_string() to get_dpistr() and get_string_argument() to
get_dpstr_argument() to emphasize they will return strings that fit
in DPISTRLEN.

Rework & simplify a pair of their consumers - do_rename_partition() and
do_change_type() - to be more obviously identitical to each other bar
the displayed verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.23 2016/01/26 16:39:00 krw Exp $	*/
d200 1
a200 1
		if (c >= '0' && c <= '9') {
d202 1
a202 1
		} else if (c >= 'A' && c <= 'F') {
d204 1
a204 1
		} else if (c >= 'a' && c <= 'f') {
d206 1
a206 1
		} else {
d208 1
a208 2
		}
		if (digit >= base) {
a209 1
		}
@


1.23
log
@Whitespace, line wrapping fixes. Nuke many superfluous '{}' around single
statements. 0 -> NULL for pointer checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.22 2016/01/24 01:38:32 krw Exp $	*/
d36 1
a39 1
#define	STRING_CHUNK	16
d45 3
a47 3
long	get_number(int);
char   *get_string(int);
int	my_getch (void);
d218 2
a219 2
int
get_string_argument(const char *prompt, char **string)
a221 1
	int result = 0;
d233 1
a233 3
			*string = get_string(c);
			result = 1;
			break;
d237 1
a237 3
			*string = get_string(' ');
			result = 1;
			break;
d240 1
a240 2
			*string = NULL;
			break;
d243 1
a243 1
	return result;
d250 3
a252 2
	char *s, *ret_value, *limit;
	int c, length;
d254 2
a255 7
	ret_value = malloc(STRING_CHUNK);
	if (ret_value == NULL) {
		warn("can't allocate memory for string buffer");
		return NULL;
	}
	length = STRING_CHUNK;
	limit = ret_value + length;
d258 1
a258 16
	for (s = ret_value;; c = my_getch()) {
		if (s >= limit) {
			/* expand string */
			limit = malloc(length + STRING_CHUNK);
			if (limit == NULL) {
				warn("can't allocate memory for string buffer");
				ret_value[length - 1] = 0;
				break;
			}
			strncpy(limit, ret_value, length);
			free(ret_value);
			s = limit + (s - ret_value);
			ret_value = limit;
			length += STRING_CHUNK;
			limit = ret_value + length;
		}
d260 1
a260 1
			*s++ = 0;
d263 1
a263 1
			*s++ = 0;
d268 2
d272 1
a272 1
	return (ret_value);
@


1.22
log
@Whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.21 2016/01/23 22:55:23 krw Exp $	*/
d52 1
a52 1
	if (unget_count > 0) {
d54 1
a54 1
	} else {
a55 1
	}
d66 1
a66 2

	if (unget_count < UNGET_MAX_COUNT) {
d68 1
a68 1
	} else {
a69 1
	}
d130 1
a130 1
	if (promptBeforeGet) {
d132 1
a132 1
	}
d237 2
a238 2
		} else if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
			|| (c == '-' || c == '/' || c == '.' || c == ':')) {
d253 1
a253 1
char           *
d351 1
a351 1
	if (c == 'p' || c == 'P') {
d353 1
a353 1
	} else if (c > 0) {
d355 1
a355 1
	}
@


1.21
log
@No need for 'default_value' parameter for get_number_argument() since we
always pass kDefault. a.k.a. -1. Nuke kDefault since it is now unused.

Nuke unused #define MAXIOSIZE in passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.20 2016/01/23 19:14:04 krw Exp $	*/
d42 2
a43 2
short		unget_buf[UNGET_MAX_COUNT + 1];
int		unget_count;
d45 3
a47 3
long		get_number(int);
char           *get_string(int);
int		my_getch  (void);
@


1.20
log
@No need for get_string_argument() parameter 'reprompt' since we
always pass it '1'.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.19 2016/01/21 15:33:21 krw Exp $	*/
a41 2
const long	kDefault = -1;

d154 1
a154 1
get_number_argument(const char *prompt, long *number, long default_value)
d167 1
a167 8
			if (default_value == kDefault) {
				printf(prompt);
			} else {
				my_ungetch(c);
				*number = default_value;
				result = 1;
				break;
			}
@


1.19
log
@Hoist all file opening and ioctl calls into main(), passing a pointer to
a valid map to edit(). Should enable pledging a la fdisk at some point.

Since edit() always gets a valid map (and maintains its validity even when
'I'nitializing a new one) many checks for (map == NULL) are junked.

Remove some dances around block sizes by using DEV_BSIZE everywhere
since we don't support non-DEV_BSIZE (a.k.a. 512-byte) sectors.

Remove many superfluous #include statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.18 2016/01/19 17:55:19 krw Exp $	*/
d231 1
a231 1
get_string_argument(const char *prompt, char **string, int reprompt)
d244 1
a244 7
			if (reprompt) {
				printf(prompt);
			} else {
				my_ungetch(c);
				*string = NULL;
				break;
			}
@


1.18
log
@Remove unused global 'io_buffer'.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.17 2016/01/18 15:03:18 krw Exp $	*/
a30 1

a34 1
#include <errno.h>
a49 1
void		my_ungetch(int);
@


1.17
log
@Run indent(1) over it and tweak the results a bit manually to look more
KNF'ish.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.16 2016/01/17 23:18:19 krw Exp $	*/
a47 1
char		io_buffer[MAXIOSIZE];
@


1.16
log
@Change "//" comments to "/**/". Nuke really stupid ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.15 2016/01/17 19:39:20 krw Exp $	*/
d40 1
a40 1
#define BAD_DIGIT 17	/* must be greater than any base */
d44 1
a44 1
const long kDefault = -1;
d46 8
a53 8
short unget_buf[UNGET_MAX_COUNT+1];
int unget_count;
char io_buffer[MAXIOSIZE];

long get_number(int);
char* get_string(int);
int my_getch(void);
void my_ungetch(int);
d58 5
a62 5
    if (unget_count > 0) {
	return (unget_buf[--unget_count]);
    } else {
	return (getc(stdin));
    }
d69 10
a78 10
    /*
     * In practice there is never more than one character in
     * the unget_buf, but what's a little overkill among friends?
     */

    if (unget_count < UNGET_MAX_COUNT) {
	unget_buf[unget_count++] = c;
    } else {
	errx(1, "Programmer error in my_ungetch().");
    }
d84 1
a84 1
    int		c;
d86 2
a87 2
    for (;;) {
	c = my_getch();
d89 10
a98 9
	if (c <= 0) {
	    break;
	} else if (c == '\n') {
	    if (keep_newline) {
		my_ungetch(c);
	    }
	    break;
	} else {
	    /* skip */
d100 1
a100 2
    }
    return;
d107 1
a107 1
    int		c;
d109 2
a110 2
    flush_to_newline(0);
    printf(prompt);
d112 2
a113 2
    for (;;) {
	c = my_getch();
d115 15
a129 14
	if (c <= 0) {
	    break;
	} else if (c == ' ' || c == '\t') {
	    /* skip blanks and tabs */
	} else if (c == '\n') {
	    my_ungetch(c);
	    return default_value;
	} else if (c == 'y' || c == 'Y') {
	    return 1;
	} else if (c == 'n' || c == 'N') {
	    return 0;
	} else {
	    flush_to_newline(0);
	    printf(prompt);
d131 1
a131 2
    }
    return -1;
d137 1
a137 1
    int		c;
d139 5
a143 5
    if (promptBeforeGet) {
	printf(prompt);
    }
    for (;;) {
	c = my_getch();
d145 10
a154 9
	if (c <= 0) {
	    break;
	} else if (c == ' ' || c == '\t') {
	    /* skip blanks and tabs */
	} else if (c == '\n') {
	    printf(prompt);
	} else {
	    *command = c;
	    return 1;
d156 1
a156 2
    }
    return 0;
d162 2
a163 2
    int c;
    int result = 0;
d165 2
a166 2
    for (;;) {
	c = my_getch();
d168 22
a189 21
	if (c <= 0) {
	    break;
	} else if (c == ' ' || c == '\t') {
	    /* skip blanks and tabs */
	} else if (c == '\n') {
	    if (default_value == kDefault) {
		printf(prompt);
	    } else {
		my_ungetch(c);
		*number = default_value;
		result = 1;
		break;
	    }
	} else if ('0' <= c && c <= '9') {
	    *number = get_number(c);
	    result = 1;
	    break;
	} else {
	    my_ungetch(c);
	    *number = 0;
	    break;
d191 1
a191 2
    }
    return result;
d198 10
a207 27
    int c;
    int base;
    int digit;
    int ret_value;

    if (first_char != '0') {
	c = first_char;
	base = 10;
	digit = BAD_DIGIT;
    } else if ((c=my_getch()) == 'x' || c == 'X') {
	c = my_getch();
	base = 16;
	digit = BAD_DIGIT;
    } else {
	my_ungetch(c);
	c = first_char;
	base = 8;
	digit = 0;
    }
    ret_value = 0;
    for (ret_value = 0; ; c = my_getch()) {
	if (c >= '0' && c <= '9') {
	    digit = c - '0';
	} else if (c >='A' && c <= 'F') {
	    digit = 10 + (c - 'A');
	} else if (c >='a' && c <= 'f') {
	    digit = 10 + (c - 'a');
d209 4
a212 1
	    digit = BAD_DIGIT;
d214 15
a228 2
	if (digit >= base) {
	    break;
d230 2
a231 4
	ret_value = ret_value * base + digit;
    }
    my_ungetch(c);
    return(ret_value);
d237 2
a238 2
    int c;
    int result = 0;
d240 2
a241 2
    for (;;) {
	c = my_getch();
d243 27
a269 26
	if (c <= 0) {
	    break;
	} else if (c == ' ' || c == '\t') {
	    /* skip blanks and tabs */
	} else if (c == '\n') {
	    if (reprompt) {
		printf(prompt);
	    } else {
		my_ungetch(c);
		*string = NULL;
		break;
	    }
	} else if (c == '"' || c == '\'') {
	    *string = get_string(c);
	    result = 1;
	    break;
	} else if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
		|| (c == '-' || c == '/' || c == '.' || c == ':')) {
	    my_ungetch(c);
	    *string = get_string(' ');
	    result = 1;
	    break;
	} else {
	    my_ungetch(c);
	    *string = NULL;
	    break;
d271 1
a271 2
    }
    return result;
d275 1
a275 1
char *
d278 5
a282 20
    int c;
    char *s;
    char *ret_value;
    char *limit;
    int length;

    ret_value = malloc(STRING_CHUNK);
    if (ret_value == NULL) {
	warn("can't allocate memory for string buffer");
	return NULL;
    }
    length = STRING_CHUNK;
    limit = ret_value + length;

    c = my_getch();
    for (s = ret_value; ; c = my_getch()) {
	if (s >= limit) {
	    /* expand string */
	    limit = malloc(length+STRING_CHUNK);
	    if (limit == NULL) {
d284 32
a315 19
		ret_value[length-1] = 0;
		break;
	    }
	    strncpy(limit, ret_value, length);
	    free(ret_value);
	    s = limit + (s - ret_value);
	    ret_value = limit;
	    length += STRING_CHUNK;
	    limit = ret_value + length;
	}
	if (c <= 0 || c == eos || (eos == ' ' && c == '\t')) {
	    *s++ = 0;
	    break;
	} else if (c == '\n') {
	    *s++ = 0;
	    my_ungetch(c);
	    break;
	} else {
	    *s++ = c;
d317 1
a317 2
    }
    return(ret_value);
d324 2
a325 3
    int c;
    unsigned long result;
    unsigned long extra;
d327 1
a327 1
    c = my_getch();
d329 2
a330 21
    extra = 1;
    if (c <= 0 || divisor <= 0) {
	result = 0;
    } else if (c == 't' || c == 'T') {
	result = 1024*1024;
	extra = 1024*1024;
    } else if (c == 'g' || c == 'G') {
	result = 1024*1024*1024;
    } else if (c == 'm' || c == 'M') {
	result = 1024*1024;
    } else if (c == 'k' || c == 'K') {
	result = 1024;
    } else {
	my_ungetch(c);
	result = 1;
    }
    if (result > 1) {
	if (extra > 1) {
	    result /= divisor;
	    if (result >= 4096) {
		/* overflow -> 20bits + >12bits */
d332 9
a340 5
	    } else {
		result *= extra;
	    }
	} else if (result >= divisor) {
	    result /= divisor;
d342 17
a358 1
	    result = 1;
d360 1
a360 2
    }
    return result;
d367 1
a367 2
    int c;
    int result;
d369 1
a369 1
    result = 0;
d371 1
a371 1
    c = my_getch();
d373 6
a378 6
    if (c == 'p' || c == 'P') {
	result = 1;
    } else if (c > 0) {
	my_ungetch(c);
    }
    return result;
d385 1
a385 1
    int j;
d387 6
a392 6
    j = 1;
    while (value > 9) {
	j++;
	value = value / 10;
    }
    return j;
d400 1
a400 1
bad_input(const char *fmt, ...)
d402 1
a402 1
    va_list ap;
d404 5
a408 5
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    fprintf(stderr, "\n");
    flush_to_newline(1);
@


1.15
log
@Reduce namespace pollution by eliminating parameter names from forward
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.14 2016/01/17 19:15:55 krw Exp $	*/
d3 5
a7 5
//
// io.c - simple io and input parsing routines
//
// Written by Eryk Vershen
//
d69 4
a72 2
    // In practice there is never more than one character in
    // the unget_buf, but what's a little overkill among friends?
d97 1
a97 1
	    // skip
d118 1
a118 1
	    // skip blanks and tabs
d148 1
a148 1
	    // skip blanks and tabs
d171 1
a171 1
	    // skip blanks and tabs
d249 1
a249 1
	    // skip blanks and tabs
d298 1
a298 1
	    // expand string
d404 3
a406 3
//
// Print a message on standard error & flush the input.
//
@


1.14
log
@Kill leading, imbedded, trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.13 2016/01/17 18:57:52 krw Exp $	*/
d50 2
a51 2
long get_number(int first_char);
char* get_string(int eos);
d53 1
a53 1
void my_ungetch(int c);
@


1.13
log
@Remove a bunch of ridiculous and uninformative comments like "// Defines".
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.12 2016/01/12 23:48:42 krw Exp $	*/
d380 1
a380 1
    	result = 1;
@


1.12
log
@#define LOFF_T off_t
#define llseek lseek
#define LOFF_T_MAX LLONG_MAX

I mean, really? Nuke'em and use off_t, lseek and LLONG_MAX.

Also make a couple of checks for overflow of off_t value more likely
to work.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.11 2016/01/12 20:09:39 krw Exp $	*/
a31 1
// for *printf()
a32 2

// for malloc() & free()
a33 1
// for strncpy()
a34 1
// for va_start(), etc.
a35 1
// for errno
a39 4

//
// Defines
//
a43 9

//
// Types
//


//
// Global Constants
//
a45 4

//
// Global Variables
//
a49 4

//
// Forward declarations
//
a54 4

//
// Routines
//
@


1.11
log
@Use normal err/errx/warn/warnx rather than handrolling new ones. Move
usage() to pdisk.c and nuke do_help() and '-h'.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.10 2016/01/11 07:57:54 jasper Exp $	*/
a52 2
#define loff_t long
#define llseek lseek
@


1.10
log
@trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: io.c,v 1.9 2016/01/11 07:54:07 jasper Exp $	*/
d30 2
a44 1
#include "errors.h"
d108 1
a108 1
	fatal(-1, "Programmer error in my_ungetch().");
d320 1
a320 1
	error(errno, "can't allocate memory for string buffer");
d332 1
a332 1
		error(errno, "can't allocate memory for string buffer");
@


1.9
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a110 1
	
a163 1
	
d171 1
a171 1
    }	
a188 1
	
a266 1
	
@


1.8
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 2
@


1.7
log
@remove a bunch of linux and NeXT defines and, in turn, -D__unix__
@
text
@d319 1
a319 1
    ret_value = (char *) malloc(STRING_CHUNK);
d331 1
a331 1
	    limit = (char *) malloc(length+STRING_CHUNK);
@


1.6
log
@With last pdisk and full functionality for mac68k now in place, start
cleaning the maze of ifdef's not relevant for us.

This round wipes most linux and/or MacOS-only bits, more to come.
@
text
@a49 7
#ifndef __unix__
#define SCSI_FD 8
#endif
#ifdef NeXT
#define loff_t off_t
#define llseek lseek
#else
a51 1
#endif
@


1.5
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@a31 1
#if !defined(__linux__)
a32 3
#else
#include <malloc.h>
#endif
a49 1
#ifndef __linux__
a58 1
#endif
@


1.4
log
@rm trailing whitespace
@
text
@d4 1
a4 1
// Written by Eryk Vershen (eryk@@apple.com)
d32 1
a32 1
#if !defined(__linux__) && !defined(__unix__) || defined(__OpenBSD__)
d92 1
a92 1
int my_getch();
d148 1
a148 1
get_okay(char *prompt, int default_value)
d179 1
a179 1
get_command(char *prompt, int promptBeforeGet, int *command)
d205 1
a205 1
get_number_argument(char *prompt, long *number, long default_value)
d284 1
a284 1
get_string_argument(char *prompt, char **string, int reprompt)
d454 1
a454 1
bad_input(char *fmt, ...)
@


1.3
log
@kill more registers;

millert@@ ok
@
text
@d9 17
a25 17
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
@


1.2
log
@Make the apple code compile for OpenBSD. These changes are mostly from maja.
@
text
@d243 1
a243 1
    register int c;
@


1.1
log
@Initial revision
@
text
@d32 1
a32 1
#if !defined(__linux__) && !defined(__unix__)
@


1.1.1.1
log
@Import of pdisk from apple, BSD licensed code. Archive dated Feb 18 1998 
This is a HFS partition editing tool.
@
text
@@
