head	1.98;
access;
symbols
	OPENBSD_6_2:1.98.0.6
	OPENBSD_6_2_BASE:1.98
	OPENBSD_6_1:1.98.0.8
	OPENBSD_6_1_BASE:1.98
	OPENBSD_6_0:1.98.0.4
	OPENBSD_6_0_BASE:1.98
	OPENBSD_5_9:1.98.0.2
	OPENBSD_5_9_BASE:1.98
	OPENBSD_5_8:1.7.0.14
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.26
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.24
	OPENBSD_5_0:1.6.0.22
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.10
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.1.1.1.0.2
	OPENBSD_2_9_BASE:1.1.1.1
	ver1:1.1.1.1
	apple19980218:1.1.1;
locks; strict;
comment	@ * @;


1.98
date	2016.02.01.12.53.37;	author krw;	state Exp;
branches;
next	1.97;
commitid	X7HCr1nukHE5U6Cs;

1.97
date	2016.01.31.23.00.11;	author krw;	state Exp;
branches;
next	1.96;
commitid	74Rthqc3AgIVhks7;

1.96
date	2016.01.31.22.26.52;	author krw;	state Exp;
branches;
next	1.95;
commitid	rtTenmK4b0owj55A;

1.95
date	2016.01.31.22.12.35;	author krw;	state Exp;
branches;
next	1.94;
commitid	jYdk2zZ4HGDdC9AG;

1.94
date	2016.01.31.17.19.26;	author krw;	state Exp;
branches;
next	1.93;
commitid	3gO5G3CYjxUgcsqU;

1.93
date	2016.01.31.15.28.56;	author krw;	state Exp;
branches;
next	1.92;
commitid	SANePqcLzJeNFm7O;

1.92
date	2016.01.31.13.53.23;	author krw;	state Exp;
branches;
next	1.91;
commitid	nmZIQHslV68WytAx;

1.91
date	2016.01.30.17.21.10;	author krw;	state Exp;
branches;
next	1.90;
commitid	BOQYiykYZJ8gnOpB;

1.90
date	2016.01.30.17.09.11;	author krw;	state Exp;
branches;
next	1.89;
commitid	ckpV9XGgFAiDBI9u;

1.89
date	2016.01.30.15.35.56;	author krw;	state Exp;
branches;
next	1.88;
commitid	DpSwyEIbCxGtms5m;

1.88
date	2016.01.30.14.24.47;	author krw;	state Exp;
branches;
next	1.87;
commitid	VY8bEAw2uQf9Rw0z;

1.87
date	2016.01.29.22.51.43;	author krw;	state Exp;
branches;
next	1.86;
commitid	T4U3iDofClirvhXD;

1.86
date	2016.01.29.17.34.08;	author krw;	state Exp;
branches;
next	1.85;
commitid	SccaDkdak6aLm9TG;

1.85
date	2016.01.29.15.06.37;	author krw;	state Exp;
branches;
next	1.84;
commitid	24MMipkr6YquiMM1;

1.84
date	2016.01.29.14.54.38;	author krw;	state Exp;
branches;
next	1.83;
commitid	JxW4PE5GwpjH1Ttx;

1.83
date	2016.01.29.14.48.20;	author krw;	state Exp;
branches;
next	1.82;
commitid	qzU9koNDngf0pT0B;

1.82
date	2016.01.29.14.26.42;	author krw;	state Exp;
branches;
next	1.81;
commitid	pLijmc3xMhh9tId3;

1.81
date	2016.01.29.12.16.41;	author krw;	state Exp;
branches;
next	1.80;
commitid	JZGoVEh0tsTwnEZi;

1.80
date	2016.01.28.22.09.56;	author krw;	state Exp;
branches;
next	1.79;
commitid	NbluAn6i0LiU8EjX;

1.79
date	2016.01.28.22.01.00;	author krw;	state Exp;
branches;
next	1.78;
commitid	UpP3MNvSWmrC8Lrc;

1.78
date	2016.01.28.19.07.45;	author krw;	state Exp;
branches;
next	1.77;
commitid	V5tzgmz34tYP6x81;

1.77
date	2016.01.28.18.12.51;	author krw;	state Exp;
branches;
next	1.76;
commitid	T73mgyKLILMKpbmI;

1.76
date	2016.01.28.17.17.57;	author krw;	state Exp;
branches;
next	1.75;
commitid	G2nIoczOWPLR4oGM;

1.75
date	2016.01.28.13.09.21;	author krw;	state Exp;
branches;
next	1.74;
commitid	3P6vRTx5dJUWT10d;

1.74
date	2016.01.28.13.01.33;	author krw;	state Exp;
branches;
next	1.73;
commitid	00cCpXcvPr6DmCk2;

1.73
date	2016.01.28.01.00.53;	author krw;	state Exp;
branches;
next	1.72;
commitid	xvnw9k1DWsDcS1KL;

1.72
date	2016.01.27.23.59.12;	author krw;	state Exp;
branches;
next	1.71;
commitid	6KT2kd7tqWnIDP4v;

1.71
date	2016.01.27.14.47.53;	author krw;	state Exp;
branches;
next	1.70;
commitid	HSGGvwKIkrWkURCB;

1.70
date	2016.01.27.14.19.59;	author krw;	state Exp;
branches;
next	1.69;
commitid	EqZjPBGHnNBMYpZq;

1.69
date	2016.01.27.00.03.52;	author krw;	state Exp;
branches;
next	1.68;
commitid	rqEjRk6knIDhhe6A;

1.68
date	2016.01.26.21.07.54;	author krw;	state Exp;
branches;
next	1.67;
commitid	DW9rfkVjTw1mfuI8;

1.67
date	2016.01.26.16.39.00;	author krw;	state Exp;
branches;
next	1.66;
commitid	rZKRcHhLUVQAhJLw;

1.66
date	2016.01.26.16.13.09;	author krw;	state Exp;
branches;
next	1.65;
commitid	7HeB8KYaCuiLcwze;

1.65
date	2016.01.26.02.38.05;	author krw;	state Exp;
branches;
next	1.64;
commitid	ccMl0u7inBNura1R;

1.64
date	2016.01.25.23.43.20;	author krw;	state Exp;
branches;
next	1.63;
commitid	Qe66eD6zrMyPrXqP;

1.63
date	2016.01.24.15.23.33;	author krw;	state Exp;
branches;
next	1.62;
commitid	AjTwGqLbiMbjTUQH;

1.62
date	2016.01.24.15.18.50;	author krw;	state Exp;
branches;
next	1.61;
commitid	qg9FUcvTXSVVSHLj;

1.61
date	2016.01.24.01.38.32;	author krw;	state Exp;
branches;
next	1.60;
commitid	g7Azk2rL78IOOfnI;

1.60
date	2016.01.24.01.09.08;	author krw;	state Exp;
branches;
next	1.59;
commitid	xnaZW4uhCmpMzNT0;

1.59
date	2016.01.23.23.25.58;	author krw;	state Exp;
branches;
next	1.58;
commitid	PPThwZCvKA3Y8sbd;

1.58
date	2016.01.23.15.05.52;	author krw;	state Exp;
branches;
next	1.57;
commitid	VImq5zcnibLGbq1Q;

1.57
date	2016.01.23.14.10.05;	author krw;	state Exp;
branches;
next	1.56;
commitid	bcC8H31SMEjEk8SE;

1.56
date	2016.01.23.13.24.15;	author krw;	state Exp;
branches;
next	1.55;
commitid	hbEWglShcq2SlbY4;

1.55
date	2016.01.23.03.46.18;	author krw;	state Exp;
branches;
next	1.54;
commitid	HhlQ6dIQMjX8YGSD;

1.54
date	2016.01.23.01.43.13;	author krw;	state Exp;
branches;
next	1.53;
commitid	KY3XjrgZevMVU8fl;

1.53
date	2016.01.23.01.16.12;	author krw;	state Exp;
branches;
next	1.52;
commitid	MZEk3tN2OXSQRuy0;

1.52
date	2016.01.23.01.09.29;	author krw;	state Exp;
branches;
next	1.51;
commitid	J6NEnLeFvUtwwJqI;

1.51
date	2016.01.23.01.03.46;	author krw;	state Exp;
branches;
next	1.50;
commitid	gksqAIcSfcyMvhMY;

1.50
date	2016.01.22.18.57.42;	author krw;	state Exp;
branches;
next	1.49;
commitid	gbwjpDFPWC5oF67r;

1.49
date	2016.01.22.17.35.16;	author krw;	state Exp;
branches;
next	1.48;
commitid	yo0CGbxOUa4UAkDH;

1.48
date	2016.01.22.15.59.33;	author krw;	state Exp;
branches;
next	1.47;
commitid	mH9L8zovdSIBuuYD;

1.47
date	2016.01.22.12.31.04;	author krw;	state Exp;
branches;
next	1.46;
commitid	3OQZJKas0yPP6L3H;

1.46
date	2016.01.22.04.16.25;	author krw;	state Exp;
branches;
next	1.45;
commitid	e3erKRbnCu8liejZ;

1.45
date	2016.01.22.01.25.56;	author krw;	state Exp;
branches;
next	1.44;
commitid	UnRUlgKDkfeEnQQF;

1.44
date	2016.01.22.00.38.53;	author krw;	state Exp;
branches;
next	1.43;
commitid	x0tMj8kuzhFIVdU1;

1.43
date	2016.01.21.15.33.21;	author krw;	state Exp;
branches;
next	1.42;
commitid	YzEQpnBPgLX85u7F;

1.42
date	2016.01.21.02.52.52;	author krw;	state Exp;
branches;
next	1.41;
commitid	CSp7NWaeW8rVW6mR;

1.41
date	2016.01.21.01.37.18;	author krw;	state Exp;
branches;
next	1.40;
commitid	ZuA5wjezizXOOPSj;

1.40
date	2016.01.18.17.57.35;	author krw;	state Exp;
branches;
next	1.39;
commitid	nIKs6pPbVKcIxae8;

1.39
date	2016.01.18.15.30.00;	author krw;	state Exp;
branches;
next	1.38;
commitid	aMBITFjwes8vTDZh;

1.38
date	2016.01.18.02.50.01;	author krw;	state Exp;
branches;
next	1.37;
commitid	beU89tKHGYlWVh4q;

1.37
date	2016.01.18.00.04.36;	author krw;	state Exp;
branches;
next	1.36;
commitid	luTmgvtH0tpvRRV4;

1.36
date	2016.01.17.23.18.19;	author krw;	state Exp;
branches;
next	1.35;
commitid	vC4VO4mr30PnBRSq;

1.35
date	2016.01.17.19.39.20;	author krw;	state Exp;
branches;
next	1.34;
commitid	slCzBfkhwAcLWsXe;

1.34
date	2016.01.17.19.15.55;	author krw;	state Exp;
branches;
next	1.33;
commitid	mHBjhdgm2kvWAkWc;

1.33
date	2016.01.17.18.57.52;	author krw;	state Exp;
branches;
next	1.32;
commitid	Rl8zxjpMi2a93hiE;

1.32
date	2016.01.17.18.44.59;	author krw;	state Exp;
branches;
next	1.31;
commitid	leFr8OHidfOIWdIJ;

1.31
date	2016.01.17.17.44.05;	author krw;	state Exp;
branches;
next	1.30;
commitid	ie6tS8cTDeRCB9yd;

1.30
date	2016.01.17.16.26.26;	author krw;	state Exp;
branches;
next	1.29;
commitid	JomFzbWltJFhj4Ev;

1.29
date	2016.01.17.16.15.59;	author krw;	state Exp;
branches;
next	1.28;
commitid	pxt9IRDGideJOJo6;

1.28
date	2016.01.17.16.07.06;	author krw;	state Exp;
branches;
next	1.27;
commitid	MHlLpCG6jqCnA9Ts;

1.27
date	2016.01.17.15.57.12;	author krw;	state Exp;
branches;
next	1.26;
commitid	9OUrU3poCOjYi22w;

1.26
date	2016.01.17.14.28.25;	author krw;	state Exp;
branches;
next	1.25;
commitid	6tkl4uDyqk6o4dzS;

1.25
date	2016.01.17.14.13.42;	author jasper;	state Exp;
branches;
next	1.24;
commitid	KoDSAptRoTS0S3qZ;

1.24
date	2016.01.16.22.28.14;	author krw;	state Exp;
branches;
next	1.23;
commitid	IIP5iNpDONoW4Jjm;

1.23
date	2016.01.16.21.41.41;	author krw;	state Exp;
branches;
next	1.22;
commitid	N0CsQGsGtplNR8ev;

1.22
date	2016.01.16.20.00.50;	author krw;	state Exp;
branches;
next	1.21;
commitid	2koPB3ak72axl95m;

1.21
date	2016.01.16.14.49.28;	author krw;	state Exp;
branches;
next	1.20;
commitid	tickLY4AeBovASt0;

1.20
date	2016.01.15.23.05.00;	author krw;	state Exp;
branches;
next	1.19;
commitid	cXG0BedMOT1d0xiF;

1.19
date	2016.01.15.16.39.20;	author krw;	state Exp;
branches;
next	1.18;
commitid	jCu7JX5yifR514Uo;

1.18
date	2016.01.14.04.22.25;	author krw;	state Exp;
branches;
next	1.17;
commitid	uj3XM0zkyTd99ZFd;

1.17
date	2016.01.14.04.17.40;	author krw;	state Exp;
branches;
next	1.16;
commitid	FFi8VPodP6ImE2jX;

1.16
date	2016.01.12.20.09.39;	author krw;	state Exp;
branches;
next	1.15;
commitid	WFEddFcNLm6A2VYQ;

1.15
date	2016.01.12.15.32.08;	author krw;	state Exp;
branches;
next	1.14;
commitid	jkbr5rI0RhKaoKmr;

1.14
date	2016.01.12.01.17.41;	author krw;	state Exp;
branches;
next	1.13;
commitid	EJ9jNI5lHIDjMGKR;

1.13
date	2016.01.11.23.31.27;	author krw;	state Exp;
branches;
next	1.12;
commitid	1Gl5xh4AgZJGXuPl;

1.12
date	2016.01.11.18.43.06;	author krw;	state Exp;
branches;
next	1.11;
commitid	qS6fX5yqWMkDVbPr;

1.11
date	2016.01.11.07.57.54;	author jasper;	state Exp;
branches;
next	1.10;
commitid	HZWVhdOSzNAX4WBf;

1.10
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.9;
commitid	DI30r1mqHPQNkhTm;

1.9
date	2016.01.10.22.30.49;	author krw;	state Exp;
branches;
next	1.8;
commitid	VSb2LXazHH5hN3OL;

1.8
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	0qPuuXwccpVXsXcV;

1.7
date	2012.08.08.12.05.22;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.29.00.43.41;	author martin;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.02.22.22.11;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.12.04.48.02;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.24.00.14.09;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.24.00.14.09;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.98
log
@Un-shorten some lines that don't need breaking anymore. Remove a couple of
indent levels by shuffling code bit.
@
text
@/*	$OpenBSD: partition_map.c,v 1.97 2016/01/31 23:00:11 krw Exp $	*/

/*
 * partition_map.c - partition map routines
 *
 * Written by Eryk Vershen
 */

/*
 * Copyright 1996,1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/stdint.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "partition_map.h"
#include "io.h"
#include "file_media.h"

#define APPLE_HFS_FLAGS_VALUE	0x4000037f

const char     *kFreeType = "Apple_Free";
const char     *kMapType = "Apple_partition_map";
const char     *kUnixType = "OpenBSD";
const char     *kHFSType = "Apple_HFS";

void		combine_entry(struct entry *);
struct entry   *create_entry(struct partition_map *, long, const char *,
    const char *, uint32_t, uint32_t);
void		delete_entry(struct entry *);
void		insert_in_base_order(struct entry *);
void		insert_in_disk_order(struct entry *);
int		read_partition_map(struct partition_map *);
void		remove_driver(struct entry *);
void		renumber_disk_addresses(struct partition_map *);

struct partition_map *
open_partition_map(int fd, char *name, uint64_t mediasz, uint32_t sectorsz)
{
	struct partition_map *map;
	int ok;

	map = malloc(sizeof(struct partition_map));
	if (map == NULL)
		errx(1, "No memory to open partition map");

	map->fd = fd;
	map->name = name;

	map->changed = 0;
	LIST_INIT(&map->disk_order);
	LIST_INIT(&map->base_order);
	map->blocks_in_map = 0;
	map->maximum_in_map = -1;

	if (mediasz > UINT32_MAX)
		map->media_size = UINT32_MAX;
	else
		map->media_size = mediasz;

	if (read_block0(map->fd, map) == 0) {
		warnx("Can't read block 0 from '%s'", name);
		free_partition_map(map);
		return NULL;
	}
	if (map->sbSig == BLOCK0_SIGNATURE &&
	    map->sbBlkSize == sectorsz &&
	    map->sbBlkCount == mediasz) {
		if (read_partition_map(map) == 0)
			return map;
	} else {
		if (map->sbSig != BLOCK0_SIGNATURE)
			warnx("Block 0 signature: Expected 0x%04x, "
			    "got 0x%04x", BLOCK0_SIGNATURE,
			    map->sbSig);
		else if (map->sbBlkSize != sectorsz)
			warnx("Block 0 sbBlkSize (%u) != sector size (%u)",
			    map->sbBlkSize, sectorsz);
		else if (map->sbBlkCount != mediasz)
			warnx("Block 0 sbBlkCount (%u) != media size (%llu)",
			    map->sbBlkCount,
			    (unsigned long long)mediasz);
	}

	if (!lflag) {
		my_ungetch('\n');
		printf("No valid partition map found on '%s'.\n", name);
		ok = get_okay("Create default map? [n/y]: ", 0);
		flush_to_newline(0);
		if (ok == 1) {
			free_partition_map(map);
			map = create_partition_map(fd, name, mediasz, sectorsz);
			if (map)
				return map;
		}
	}

	free_partition_map(map);
	return NULL;
}


void
free_partition_map(struct partition_map *map)
{
	struct entry *entry;

	if (map == NULL)
		return;

	while (!LIST_EMPTY(&map->disk_order)) {
		entry = LIST_FIRST(&map->disk_order);
		LIST_REMOVE(entry, disk_entry);
		free(entry);
	}

	free(map);
}

int
read_partition_map(struct partition_map *map)
{
	struct entry *cur, *nextcur;
	struct entry *entry;
	int ix;
	uint32_t limit, base, next, nextbase;

	limit = 1; /* There has to be at least one, which has the real limit. */
	for (ix = 1; ix <= limit; ix++) {
		entry = malloc(sizeof(struct entry));
		if (entry == NULL)
			errx(1, "No memory for partition entry");
		if (read_dpme(map->fd, ix, entry) == 0) {
			warnx("Can't read block %u from '%s'", ix, map->name);
			free(entry);
			return 1;
		}
		if (entry->dpme_signature != DPME_SIGNATURE) {
			warnx("Invalid signature on block %d. Expected %x, "
			    "got %x", ix, DPME_SIGNATURE,
			    entry->dpme_signature);
			free(entry);
			return 1;
		}
		if (ix == 1) {
			if (entry->dpme_map_entries > entry->dpme_pblocks) {
				warnx("Map entry count (%u) > # of physical "
				    "blocks (%u)", entry->dpme_map_entries,
				    entry->dpme_pblocks);
				free(entry);
				return 1;
			}
			if (entry->dpme_map_entries == 0) {
				warnx("Map entry count ==  0. Must be > 0");
				free(entry);
				return 1;
			}
			map->maximum_in_map = entry->dpme_pblocks;
			limit = entry->dpme_map_entries;
		}
		if (limit != entry->dpme_map_entries) {
			warnx("Invalid entry count on block %d. "
			    "Expected %d, got %d", ix, limit,
			    entry->dpme_map_entries);
			free(entry);
			return 1;
		}
		if (entry->dpme_lblock_start >= entry->dpme_pblocks) {
			warnx("\tlogical start (%u) >= block count"
			    "count (%u).", entry->dpme_lblock_start,
			    entry->dpme_pblocks);
			free(entry);
			return 1;
		}
		if (entry->dpme_lblocks > entry->dpme_pblocks -
			entry->dpme_lblock_start) {
			warnx("\tlogical blocks (%u) > available blocks (%u).",
			    entry->dpme_lblocks,
			    entry->dpme_pblocks - entry->dpme_lblock_start);
			free(entry);
			return 1;
		}
		entry->the_map = map;
		entry->disk_address = ix;
		insert_in_disk_order(entry);
		insert_in_base_order(entry);
		map->blocks_in_map++;
	}

	/* Traverse base_order looking for
	 *
	 * 1) Overlapping partitions
	 * 2) Unmapped space
	 */
	LIST_FOREACH(cur, &map->base_order, base_entry) {
		base = cur->dpme_pblock_start;
		next = base + cur->dpme_pblocks;
		if (base >= map->media_size ||
		    next < base ||
		    next > map->media_size) {
			warnx("Partition extends past end of disk: %u -> %u",
			    base, next);
		}
		nextcur = LIST_NEXT(cur, base_entry);
		if (nextcur)
			nextbase = nextcur->dpme_pblock_start;
		else
			nextbase = map->media_size;
		if (next != nextbase)
			warnx("Unmapped pblocks: %u -> %u", next, nextbase);
		if (next > nextbase)
			warnx("Partition %ld overlaps next partition",
			    cur->disk_address);
	}

	return 0;
}


void
write_partition_map(struct partition_map *map)
{
	struct entry *entry;
	int result;

	result = write_block0(map->fd, map);
	if (result == 0)
		warn("Unable to write block zero");

	LIST_FOREACH(entry, &map->disk_order, disk_entry) {
		result = write_dpme(map->fd, entry->disk_address, entry);
		if (result == 0)
			warn("Unable to write block %ld", entry->disk_address);
	}
}


struct partition_map *
create_partition_map(int fd, char *name, u_int64_t mediasz, uint32_t sectorsz)
{
	struct partition_map *map;
	struct entry *entry;

	map = malloc(sizeof(struct partition_map));
	if (map == NULL)
		errx(1, "No memory to create partition map");

	map->name = name;
	map->fd = fd;
	map->changed = 1;
	LIST_INIT(&map->disk_order);
	LIST_INIT(&map->base_order);

	map->blocks_in_map = 0;
	map->maximum_in_map = -1;
	map->media_size = mediasz;

	map->sbSig = BLOCK0_SIGNATURE;
	map->sbBlkSize = sectorsz;
	map->sbBlkCount = map->media_size;

	entry = create_entry(map, 1, "", kFreeType, 1, mediasz - 1);
	if (entry == NULL)
		errx(1, "No memory for new dpme");

	add_partition_to_map("Apple", kMapType, 1,
	    (map->media_size <= 128 ? 2 : 63), map);

	return map;
}


int
add_partition_to_map(const char *name, const char *dptype, uint32_t base,
    uint32_t length, struct partition_map *map)
{
	struct entry *cur;
	int limit, new_entries;
	uint32_t old_base, old_length, old_address;
	uint32_t new_base, new_length;

	if (map->maximum_in_map < 0)
		limit = map->media_size;
	else
		limit = map->maximum_in_map;

	/* find a block of free space that starts includes base and length */
	LIST_FOREACH(cur, &map->base_order, base_entry) {
		if (strncasecmp(cur->dpme_type, kFreeType, DPISTRLEN))
		    continue;
		if (cur->dpme_pblock_start <= base &&
		    (base + length) <=
		    (cur->dpme_pblock_start + cur->dpme_pblocks))
			break;
	}
	if (cur == NULL) {
		printf("requested base and length is not "
		       "within an existing free partition\n");
		return 0;
	}
	old_base = cur->dpme_pblock_start;
	old_length = cur->dpme_pblocks;
	old_address = cur->disk_address;

	/* Check that there is enough room in the map for the new entries! */
	if (base == old_base && length == old_length)
		new_entries = 0;
	else if (base == old_base)
		new_entries = 1;
	else if (base - old_base < old_length - length)
		new_entries = 2;
	else
		new_entries = 1;
	if (map->blocks_in_map + new_entries > limit) {
		printf("the map is not big enough\n");
		return 0;
	}

	/*
	 * Delete old free entry from map and add back 1 to 3 new entries.
	 *
	 * 1) Empty space from base+len to old end.
	 * 2) New entry from specified base for length.
	 * 3) Empty space from old base to new base.
	 *
	 *  All with the same disk address, so they must be added in that
	 *  order!
	 */
	delete_entry(cur);

	new_base = base + length;
	new_length = (old_base + old_length) - new_base;
	if (new_length > 0) {
		/* New free space entry *after* new partition. */
		cur = create_entry(map, old_address, "", kFreeType, new_base,
		    new_length);
		if (cur == NULL)
			errx(1, "No memory for new dpme");
	}

	cur = create_entry(map, old_address, name, dptype, base, length);
	if (cur == NULL)
		errx(1, "No memory for new entry");

	new_length = base - old_base;
	if (new_length > 0) {
		/* New free space entry *before* new partition. */
		cur = create_entry(map, old_address, "", kFreeType, old_base,
		    new_length);
		if (cur == NULL)
			errx(1, "No memory for new entry");
	}

	renumber_disk_addresses(map);
	map->changed = 1;
	return 1;
}


struct entry*
create_entry(struct partition_map *map, long ix, const char *name,
    const char *dptype, uint32_t base, uint32_t length)
{
	struct entry *entry;

	entry = calloc(1, sizeof(struct entry));
	if (entry == NULL)
		errx(1, "No memory for new entry");

	entry->dpme_signature = DPME_SIGNATURE;
	entry->dpme_map_entries = 1;
	entry->dpme_pblock_start = base;
	entry->dpme_pblocks = length;
	strlcpy(entry->dpme_name, name, sizeof(entry->dpme_name));
	strlcpy(entry->dpme_type, dptype, sizeof(entry->dpme_type));
	if (strncasecmp(dptype, kFreeType, DPISTRLEN)) {
		/* Only non-kFreeType entries get lblock info != 0. */
		entry->dpme_lblocks = entry->dpme_pblocks;
	}
	dpme_init_flags(entry);

	entry->disk_address = ix;
	entry->the_map = map;

	insert_in_disk_order(entry);
	insert_in_base_order(entry);

	map->blocks_in_map++;
	if (map->maximum_in_map < 0) {
		if (strncasecmp(entry->dpme_type, kMapType, DPISTRLEN) == 0)
			map->maximum_in_map = entry->dpme_pblocks;
	}

	return entry;
}

void
dpme_init_flags(struct entry *entry)
{
	if (strncasecmp(entry->dpme_type, kFreeType, DPISTRLEN) == 0)
		entry->dpme_flags = 0;
	else if (strncasecmp(entry->dpme_type, kMapType, DPISTRLEN) == 0)
		entry->dpme_flags = DPME_VALID | DPME_ALLOCATED;
	else if (strncasecmp(entry->dpme_type, kHFSType, DPISTRLEN) == 0)
		entry->dpme_flags = APPLE_HFS_FLAGS_VALUE;
	else
		entry->dpme_flags = DPME_VALID | DPME_ALLOCATED |
		    DPME_READABLE | DPME_WRITABLE;
}

void
renumber_disk_addresses(struct partition_map *map)
{
	struct entry *cur;
	long ix;

	/* reset disk addresses */
	ix = 1;
	LIST_FOREACH(cur, &map->disk_order, disk_entry) {
		cur->disk_address = ix++;
		cur->dpme_map_entries = map->blocks_in_map;
	}
}

void
delete_partition_from_map(struct entry *entry)
{
	struct partition_map *map;
	uint32_t base, length, address;

	if (strncasecmp(entry->dpme_type, kMapType, DPISTRLEN) == 0) {
		printf("Can't delete entry for the map itself\n");
		return;
	}
	if (strncasecmp(entry->dpme_type, kFreeType, DPISTRLEN) == 0) {
		printf("Can't delete entry for free space\n");
		return;
	}
	if (contains_driver(entry)) {
		printf("This program can't install drivers\n");
		if (get_okay("are you sure you want to delete this driver? "
		    "[n/y]: ", 0) != 1) {
			return;
		}
		remove_driver(entry);	/* update block0 if necessary */
	}

	map = entry->the_map;
	base = entry->dpme_pblock_start;
	length = entry->dpme_pblocks;
	address = entry->disk_address;

	delete_entry(entry);
	entry = create_entry(map, address, "" , kFreeType, base, length);
	combine_entry(entry);
	renumber_disk_addresses(entry->the_map);
	entry->the_map->changed = 1;
}


int
contains_driver(struct entry *entry)
{
	struct partition_map *map;
	struct ddmap *m;
	int i;
	uint32_t start;

	map = entry->the_map;
	m = map->sbDDMap;
	for (i = 0; i < map->sbDrvrCount; i++) {
		start = m[i].ddBlock;
		if (entry->dpme_pblock_start <= start &&
		    (start + m[i].ddSize) <= (entry->dpme_pblock_start +
		    entry->dpme_pblocks))
			return 1;
	}

	return 0;
}


void
combine_entry(struct entry *entry)
{
	struct entry *p;
	uint32_t end;

	if (entry == NULL ||
	    strncasecmp(entry->dpme_type, kFreeType, DPISTRLEN) != 0)
		return;

	p = LIST_NEXT(entry, base_entry);
	if (p != NULL) {
		if (strncasecmp(p->dpme_type, kFreeType, DPISTRLEN) !=
		    0) {
			/* next is not free */
		} else if (entry->dpme_pblock_start +
		    entry->dpme_pblocks != p->dpme_pblock_start) {
			/* next is not contiguous (XXX this is bad) */
			printf("next entry is not contiguous\n");
			/* start is already minimum */
			/* new end is maximum of two ends */
			end = p->dpme_pblock_start + p->dpme_pblocks;
			if (end > entry->dpme_pblock_start +
			    entry->dpme_pblocks) {
				entry->dpme_pblocks = end -
				    entry->dpme_pblock_start;
			}
			delete_entry(p);
		} else {
			entry->dpme_pblocks += p->dpme_pblocks;
			delete_entry(p);
		}
	}

	LIST_FOREACH(p, &entry->the_map->base_order, base_entry) {
		if (LIST_NEXT(p, base_entry) == entry)
			break;
	}
	if (p != NULL) {
		if (strncasecmp(p->dpme_type, kFreeType, DPISTRLEN) != 0) {
			/* previous is not free */
		} else if (p->dpme_pblock_start + p->dpme_pblocks !=
		    entry->dpme_pblock_start) {
			/* previous is not contiguous (XXX this is bad) */
			printf("previous entry is not contiguous\n");
			/* new end is maximum of two ends */
			end = p->dpme_pblock_start + p->dpme_pblocks;
			if (end < entry->dpme_pblock_start +
			    entry->dpme_pblocks) {
				end = entry->dpme_pblock_start +
				    entry->dpme_pblocks;
			}
			entry->dpme_pblocks = end - p->dpme_pblock_start;
			entry->dpme_pblock_start = p->dpme_pblock_start;
			delete_entry(p);
		} else {
			entry->dpme_pblock_start = p->dpme_pblock_start;
			entry->dpme_pblocks += p->dpme_pblocks;
			delete_entry(p);
		}
	}
}


void
delete_entry(struct entry *entry)
{
	struct partition_map *map;

	map = entry->the_map;
	map->blocks_in_map--;

	LIST_REMOVE(entry, disk_entry);
	LIST_REMOVE(entry, base_entry);

	free(entry);
}


struct entry *
find_entry_by_disk_address(long ix, struct partition_map *map)
{
	struct entry *cur;

	LIST_FOREACH(cur, &map->disk_order, disk_entry) {
		if (cur->disk_address == ix)
			break;
	}
	return cur;
}


struct entry *
find_entry_by_type(const char *type_name, struct partition_map *map)
{
	struct entry *cur;

	LIST_FOREACH(cur, &map->base_order, base_entry) {
		if (strncasecmp(cur->dpme_type, type_name, DPISTRLEN) == 0)
			break;
	}
	return cur;
}

struct entry *
find_entry_by_base(uint32_t base, struct partition_map *map)
{
	struct entry *cur;

	LIST_FOREACH(cur, &map->base_order, base_entry) {
		if (cur->dpme_pblock_start == base)
			break;
	}
	return cur;
}


void
move_entry_in_map(long index1, long index2, struct partition_map *map)
{
	struct entry *p1, *p2;

	if (index1 == index2)
		return;

	if (index1 == 1 || index2 == 1) {
		printf("Partition #1 cannot be moved\n");
		return;
	}
	p1 = find_entry_by_disk_address(index1, map);
	if (p1 == NULL) {
		printf("Partition #%ld not found\n", index1);
		return;
	}
	p2 = find_entry_by_disk_address(index2, map);
	if (p2 == NULL) {
		printf("Partition #%ld not found\n", index2);
		return;
	}

	LIST_REMOVE(p1, disk_entry);
	LIST_REMOVE(p2, disk_entry);

	p1->disk_address = index2;
	p2->disk_address = index1;

	insert_in_disk_order(p1);
	insert_in_disk_order(p2);

	renumber_disk_addresses(map);
	map->changed = 1;
}


void
insert_in_disk_order(struct entry *entry)
{
	struct partition_map *map;
	struct entry *cur;

	/* find position in disk list & insert */
	map = entry->the_map;
	if (LIST_EMPTY(&map->disk_order)) {
		LIST_INSERT_HEAD(&map->disk_order, entry, disk_entry);
		return;
	}

	LIST_FOREACH(cur, &map->disk_order, disk_entry) {
		if (cur->disk_address >= entry->disk_address) {
			LIST_INSERT_BEFORE(cur, entry, disk_entry);
			return;
		}
		if (LIST_NEXT(cur, disk_entry) == NULL) {
			LIST_INSERT_AFTER(cur, entry, disk_entry);
			return;
		}
	}
}


void
insert_in_base_order(struct entry *entry)
{
	struct partition_map *map;
	struct entry *cur;
	uint32_t start;

	/* find position in base list & insert */
	map = entry->the_map;
	if (LIST_EMPTY(&map->base_order)) {
		LIST_INSERT_HEAD(&map->base_order, entry, base_entry);
		return;
	}

	start = entry->dpme_pblock_start;
	LIST_FOREACH(cur, &map->base_order, base_entry) {
		if (start <= cur->dpme_pblock_start) {
			LIST_INSERT_BEFORE(cur, entry, base_entry);
			return;
		}
		if (LIST_NEXT(cur, base_entry) == NULL) {
			LIST_INSERT_AFTER(cur, entry, base_entry);
			return;
		}
	}
}


void
resize_map(long new_size, struct partition_map *map)
{
	struct entry *entry;
	struct entry *next;
	int incr;

	entry = find_entry_by_type(kMapType, map);

	if (entry == NULL) {
		printf("Couldn't find entry for map!\n");
		return;
	}
	if (new_size == entry->dpme_pblocks)
		return;

	next = LIST_NEXT(entry, base_entry);

	if (new_size < entry->dpme_pblocks) {
		/* make it smaller */
		if (next == NULL ||
		    strncasecmp(next->dpme_type, kFreeType, DPISTRLEN) != 0)
			incr = 1;
		else
			incr = 0;
		if (new_size < map->blocks_in_map + incr) {
			printf("New size would be too small\n");
			return;
		}
		goto doit;
	}
	/* make it larger */
	if (next == NULL ||
	    strncasecmp(next->dpme_type, kFreeType, DPISTRLEN) != 0) {
		printf("No free space to expand into\n");
		return;
	}
	if (entry->dpme_pblock_start + entry->dpme_pblocks
	    != next->dpme_pblock_start) {
		printf("No contiguous free space to expand into\n");
		return;
	}
	if (new_size > entry->dpme_pblocks + next->dpme_pblocks) {
		printf("No enough free space\n");
		return;
	}
doit:
	entry->dpme_type[0] = 0;
	delete_partition_from_map(entry);
	add_partition_to_map("Apple", kMapType, 1, new_size, map);
	map->maximum_in_map = new_size;
}


void
remove_driver(struct entry *entry)
{
	struct partition_map *map;
	struct ddmap *m;
	int i, j;
	uint32_t start;

	/*
	 * compute the factor to convert the block numbers in block0
	 * into partition map block numbers.
	 */
	map = entry->the_map;
	m = map->sbDDMap;
	for (i = 0; i < map->sbDrvrCount; i++) {
		start = m[i].ddBlock;
		/*
		 * zap the driver if it is wholly contained in the
		 * partition
		 */
		if (entry->dpme_pblock_start <= start && (start +
		    m[i].ddSize) <= (entry->dpme_pblock_start +
		    entry->dpme_pblocks)) {
			/*
			 * Delete this driver by copying down later ones and
			 * zapping the last one.
			 */
			for (j = i + 1; j < map->sbDrvrCount; j++, i++) {
				m[i].ddBlock = m[i].ddBlock;
				m[i].ddSize = m[j].ddSize;
				m[i].ddType = m[j].ddType;
			}
			m[i].ddBlock = 0;
			m[i].ddSize = 0;
			m[i].ddType = 0;
			map->sbDrvrCount -= 1;
			return;	/* XXX if we continue we will delete
				 * other drivers? */
		}
	}
}
@


1.97
log
@Nuke pointless map field 'physical_block' and just use 'sbBlkSize' which is
set to the same value.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.96 2016/01/31 22:26:52 krw Exp $	*/
d130 7
a136 7
	if (map) {
		while (!LIST_EMPTY(&map->disk_order)) {
			entry = LIST_FIRST(&map->disk_order);
			LIST_REMOVE(entry, disk_entry);
			free(entry);
		}
		free(map);
d138 2
d492 8
a500 11
	if (map->sbDrvrCount > 0) {
		m = map->sbDDMap;
		for (i = 0; i < map->sbDrvrCount; i++) {
			start = m[i].ddBlock;
			if (entry->dpme_pblock_start <= start &&
			    (start + m[i].ddSize) <=
			    (entry->dpme_pblock_start +
			    entry->dpme_pblocks))
				return 1;
		}
	}
d603 1
a603 2
		if (strncasecmp(cur->dpme_type, type_name, DPISTRLEN) ==
		    0)
d734 1
a734 2
		    strncasecmp(next->dpme_type, kFreeType, DPISTRLEN) !=
		    0)
d780 10
a789 5
	if (map->sbDrvrCount > 0) {
		m = map->sbDDMap;
		for (i = 0; i < map->sbDrvrCount; i++) {
			start = m[i].ddBlock;

d791 2
a792 2
			 * zap the driver if it is wholly contained in the
			 * partition
d794 4
a797 20
			if (entry->dpme_pblock_start <= start &&
			    (start + m[i].ddSize) <=
			    (entry->dpme_pblock_start + entry->dpme_pblocks)) {
				/* delete this driver */
				/*
				 * by copying down later ones and zapping the
				 * last
				 */
				for (j = i + 1; j < map->sbDrvrCount; j++,
				    i++) {
					m[i].ddBlock = m[i].ddBlock;
					m[i].ddSize = m[j].ddSize;
					m[i].ddType = m[j].ddType;
				}
				m[i].ddBlock = 0;
				m[i].ddSize = 0;
				m[i].ddType = 0;
				map->sbDrvrCount -= 1;
				return;	/* XXX if we continue we will delete
					 * other drivers? */
d799 6
@


1.96
log
@Use delete_entry()/create_entry() in delete_partition_from_map() instead of
trying to be clever and tweaking the existing entry into a free space
entry by manual manipulation of the fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.95 2016/01/31 22:12:35 krw Exp $	*/
a74 1
	map->physical_block = sectorsz;
a273 2
	map->physical_block = sectorsz;

d279 1
a279 1
	map->sbBlkSize = map->physical_block;
@


1.95
log
@Fold add_data_to_map() into create_entry() as the former is always called
immediately after the latter, manipulating fields in the same structure.

Use create_entry() in create_partition() rather than doing the same
actions manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.94 2016/01/31 17:19:26 krw Exp $	*/
d451 3
d471 4
a474 6
	memset(entry->dpme_name, 0, sizeof(entry->dpme_name));
	memset(entry->dpme_type, 0, sizeof(entry->dpme_type));
	strlcpy(entry->dpme_type, kFreeType, sizeof(entry->dpme_type));
	entry->dpme_lblock_start = 0;
	entry->dpme_lblocks = 0;
	dpme_init_flags(entry);
d476 2
@


1.94
log
@Don't use add_data_to_map() when reading from disk, since it resets some
of the dpme_ fields, overwriting data from disk.

Add some paranoia checks for map limits when reading from disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.93 2016/01/31 15:28:56 krw Exp $	*/
a48 1
void		add_data_to_map(struct entry *, long, struct partition_map *);
d50 2
a51 1
struct entry   *create_entry(const char *, const char *, uint32_t, uint32_t);
a258 16
void
add_data_to_map(struct entry *entry, long ix, struct partition_map *map)
{
	entry->disk_address = ix;
	entry->the_map = map;

	insert_in_disk_order(entry);
	insert_in_base_order(entry);

	map->blocks_in_map++;
	if (map->maximum_in_map < 0) {
		if (strncasecmp(entry->dpme_type, kMapType, DPISTRLEN) == 0)
			map->maximum_in_map = entry->dpme_pblocks;
	}
}

d285 1
a285 1
	entry = calloc(1, sizeof(struct entry));
d287 1
a287 1
		errx(1, "No memory for initial map entry");
a288 8
	entry->dpme_signature = DPME_SIGNATURE;
	entry->dpme_map_entries = 1;
	entry->dpme_pblock_start = 1;
	entry->dpme_pblocks = map->media_size - 1;
	strlcpy(entry->dpme_type, kFreeType, sizeof(entry->dpme_type));
	dpme_init_flags(entry);

	add_data_to_map(entry, 1, map);
d358 2
a359 1
		cur = create_entry("", kFreeType, new_base, new_length);
a361 1
		add_data_to_map(cur, old_address, map);
d364 1
a364 1
	cur = create_entry(name, dptype, base, length);
a366 1
	add_data_to_map(cur, old_address, map);
d371 2
a372 1
		cur = create_entry("", kFreeType, old_base, new_length);
a374 1
		add_data_to_map(cur, old_address, map);
d384 2
a385 2
create_entry(const char *name, const char *dptype, uint32_t base,
    uint32_t length)
d404 12
@


1.93
log
@Just call contains_driver() when you need to know rather than carrying a
flag around. More obviously current data. Nuke unnecessary variables
when displaying a partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.92 2016/01/31 13:53:23 krw Exp $	*/
d149 1
a149 1
	limit = 1; /* There has to be at least one, which has actual value. */
d166 14
a179 1
		if (ix == 1)
d181 1
d204 5
a208 2

		add_data_to_map(entry, ix, map);
@


1.92
log
@Apple sets lblock_start and lblocks to 0 in free space entries. Do
the same.

Don't use lblock_start or lblocks in calculation for length@@base
display. We no longer display lblock info there.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.91 2016/01/30 17:21:10 krw Exp $	*/
a49 1
int		contains_driver(struct entry *);
a246 1
	entry->contains_driver = contains_driver(entry);
d455 1
a455 1
	if (entry->contains_driver) {
a562 1
	entry->contains_driver = contains_driver(entry);
@


1.91
log
@Move last three lines (#define's) from dpme.h to partition_map.h and
tweak #include's as necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.90 2016/01/30 17:09:11 krw Exp $	*/
d409 4
a412 2
	entry->dpme_lblock_start = 0;
	entry->dpme_lblocks = entry->dpme_pblocks;
d469 2
a530 1
			entry->dpme_lblocks = entry->dpme_pblocks;
a533 1
			entry->dpme_lblocks = entry->dpme_pblocks;
d556 2
a557 6
			entry->dpme_pblocks = end -
			    p->dpme_pblock_start;
			/* new start is previous entry's start */
			entry->dpme_pblock_start =
			    p->dpme_pblock_start;
			entry->dpme_lblocks = entry->dpme_pblocks;
d560 1
a560 2
			entry->dpme_pblock_start =
			    p->dpme_pblock_start;
a561 1
			entry->dpme_lblocks = entry->dpme_pblocks;
@


1.90
log
@Fold struct dpme into struct entry. Same reasons as for folding
struct block0 into struct partition_map. Easier to read code.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.89 2016/01/30 15:35:56 krw Exp $	*/
a37 1
#include "dpme.h"
@


1.89
log
@Refactor add_partition_to_map() to be simpler if perhaps less
performance optimized. New logic will simplify merging struct
dpme into struct entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.88 2016/01/30 14:24:47 krw Exp $	*/
d50 1
a50 1
void		add_data_to_map(struct dpme *, long, struct partition_map *);
d53 1
a53 1
struct dpme    *create_dpme(const char *, const char *, uint32_t, uint32_t);
a136 1
			free(entry->dpme);
d147 1
a147 1
	struct dpme *dpme;
d153 2
a154 2
		dpme = malloc(sizeof(struct dpme));
		if (dpme == NULL)
d156 1
a156 1
		if (read_dpme(map->fd, ix, dpme) == 0) {
d158 1
a158 1
			free(dpme);
d161 1
a161 1
		if (dpme->dpme_signature != DPME_SIGNATURE) {
d164 2
a165 2
			    dpme->dpme_signature);
			free(dpme);
d169 2
a170 2
			limit = dpme->dpme_map_entries;
		if (limit != dpme->dpme_map_entries) {
d173 2
a174 2
			    dpme->dpme_map_entries);
			free(dpme);
d177 1
a177 1
		if (dpme->dpme_lblock_start >= dpme->dpme_pblocks) {
d179 3
a181 3
			    "count (%u).", dpme->dpme_lblock_start,
			    dpme->dpme_pblocks);
			free(dpme);
d184 2
a185 2
		if (dpme->dpme_lblocks > dpme->dpme_pblocks -
			dpme->dpme_lblock_start) {
d187 3
a189 3
			    dpme->dpme_lblocks,
			    dpme->dpme_pblocks - dpme->dpme_lblock_start);
			free(dpme);
d193 1
a193 1
		add_data_to_map(dpme, ix, map);
d202 2
a203 2
		base = cur->dpme->dpme_pblock_start;
		next = base + cur->dpme->dpme_pblocks;
d212 1
a212 1
			nextbase = nextcur->dpme->dpme_pblock_start;
d237 1
a237 1
		result = write_dpme(map->fd, entry->disk_address, entry->dpme);
d245 1
a245 1
add_data_to_map(struct dpme *dpme, long ix, struct partition_map *map)
a246 6
	struct entry *entry;

	entry = malloc(sizeof(struct entry));
	if (entry == NULL)
		errx(1, "No memory for new partition entry");

a248 1
	entry->dpme = dpme;
d256 2
a257 2
		if (strncasecmp(dpme->dpme_type, kMapType, DPISTRLEN) == 0)
			map->maximum_in_map = dpme->dpme_pblocks;
d265 1
a265 1
	struct dpme *dpme;
d287 10
a296 10
	dpme = calloc(1, sizeof(struct dpme));
	if (dpme == NULL)
		errx(1, "No memory for initial dpme");

	dpme->dpme_signature = DPME_SIGNATURE;
	dpme->dpme_map_entries = 1;
	dpme->dpme_pblock_start = 1;
	dpme->dpme_pblocks = map->media_size - 1;
	strlcpy(dpme->dpme_type, kFreeType, sizeof(dpme->dpme_type));
	dpme_init_flags(dpme);
d298 1
a298 1
	add_data_to_map(dpme, 1, map);
a310 1
	struct dpme *dpme;
d322 1
a322 1
		if (strncasecmp(cur->dpme->dpme_type, kFreeType, DPISTRLEN))
d324 1
a324 1
		if (cur->dpme->dpme_pblock_start <= base &&
d326 1
a326 1
		    (cur->dpme->dpme_pblock_start + cur->dpme->dpme_pblocks))
d334 2
a335 2
	old_base = cur->dpme->dpme_pblock_start;
	old_length = cur->dpme->dpme_pblocks;
d368 2
a369 2
		dpme = create_dpme("", kFreeType, new_base, new_length);
		if (dpme == NULL)
d371 1
a371 1
		add_data_to_map(dpme, old_address, map);
d374 4
a377 4
	dpme = create_dpme(name, dptype, base, length);
	if (dpme == NULL)
		errx(1, "No memory for new dpme");
	add_data_to_map(dpme, old_address, map);
d382 4
a385 4
		dpme = create_dpme("", kFreeType, old_base, new_length);
		if (dpme == NULL)
			errx(1, "No memory for new dpme");
		add_data_to_map(dpme, old_address, map);
d394 2
a395 2
struct dpme*
create_dpme(const char *name, const char *dptype, uint32_t base,
d398 1
a398 1
	struct dpme *dpme;
d400 15
a414 15
	dpme = calloc(1, sizeof(struct dpme));
	if (dpme == NULL)
		errx(1, "No memory for new dpme");

	dpme->dpme_signature = DPME_SIGNATURE;
	dpme->dpme_map_entries = 1;
	dpme->dpme_pblock_start = base;
	dpme->dpme_pblocks = length;
	strlcpy(dpme->dpme_name, name, sizeof(dpme->dpme_name));
	strlcpy(dpme->dpme_type, dptype, sizeof(dpme->dpme_type));
	dpme->dpme_lblock_start = 0;
	dpme->dpme_lblocks = dpme->dpme_pblocks;
	dpme_init_flags(dpme);

	return dpme;
d418 8
a425 8
dpme_init_flags(struct dpme *dpme)
{
	if (strncasecmp(dpme->dpme_type, kFreeType, DPISTRLEN) == 0)
		dpme->dpme_flags = 0;
	else if (strncasecmp(dpme->dpme_type, kMapType, DPISTRLEN) == 0)
		dpme->dpme_flags = DPME_VALID | DPME_ALLOCATED;
	else if (strncasecmp(dpme->dpme_type, kHFSType, DPISTRLEN) == 0)
		dpme->dpme_flags = APPLE_HFS_FLAGS_VALUE;
d427 1
a427 1
		dpme->dpme_flags = DPME_VALID | DPME_ALLOCATED |
d441 1
a441 1
		cur->dpme->dpme_map_entries = map->blocks_in_map;
d448 1
a448 3
	struct dpme *dpme;

	if (strncasecmp(entry->dpme->dpme_type, kMapType, DPISTRLEN) == 0) {
d452 1
a452 1
	if (strncasecmp(entry->dpme->dpme_type, kFreeType, DPISTRLEN) == 0) {
d465 4
a468 5
	dpme = entry->dpme;
	memset(dpme->dpme_name, 0, sizeof(dpme->dpme_name));
	memset(dpme->dpme_type, 0, sizeof(dpme->dpme_type));
	strlcpy(dpme->dpme_type, kFreeType, sizeof(dpme->dpme_type));
	dpme_init_flags(dpme);
d490 1
a490 1
			if (entry->dpme->dpme_pblock_start <= start &&
d492 2
a493 2
			    (entry->dpme->dpme_pblock_start +
			    entry->dpme->dpme_pblocks))
d508 1
a508 1
	    strncasecmp(entry->dpme->dpme_type, kFreeType, DPISTRLEN) != 0)
d513 1
a513 1
		if (strncasecmp(p->dpme->dpme_type, kFreeType, DPISTRLEN) !=
d516 2
a517 2
		} else if (entry->dpme->dpme_pblock_start +
		    entry->dpme->dpme_pblocks != p->dpme->dpme_pblock_start) {
d522 5
a526 6
			end = p->dpme->dpme_pblock_start +
			    p->dpme->dpme_pblocks;
			if (end > entry->dpme->dpme_pblock_start +
			    entry->dpme->dpme_pblocks) {
				entry->dpme->dpme_pblocks = end -
				    entry->dpme->dpme_pblock_start;
d528 1
a528 1
			entry->dpme->dpme_lblocks = entry->dpme->dpme_pblocks;
d531 2
a532 2
			entry->dpme->dpme_pblocks += p->dpme->dpme_pblocks;
			entry->dpme->dpme_lblocks = entry->dpme->dpme_pblocks;
d542 1
a542 2
		if (strncasecmp(p->dpme->dpme_type, kFreeType, DPISTRLEN) !=
		    0) {
d544 2
a545 2
		} else if (p->dpme->dpme_pblock_start + p->dpme->dpme_pblocks !=
		    entry->dpme->dpme_pblock_start) {
d549 5
a553 6
			end = p->dpme->dpme_pblock_start +
			    p->dpme->dpme_pblocks;
			if (end < entry->dpme->dpme_pblock_start +
			    entry->dpme->dpme_pblocks) {
				end = entry->dpme->dpme_pblock_start +
				    entry->dpme->dpme_pblocks;
d555 2
a556 2
			entry->dpme->dpme_pblocks = end -
			    p->dpme->dpme_pblock_start;
d558 3
a560 3
			entry->dpme->dpme_pblock_start =
			    p->dpme->dpme_pblock_start;
			entry->dpme->dpme_lblocks = entry->dpme->dpme_pblocks;
d563 4
a566 4
			entry->dpme->dpme_pblock_start =
			    p->dpme->dpme_pblock_start;
			entry->dpme->dpme_pblocks += p->dpme->dpme_pblocks;
			entry->dpme->dpme_lblocks = entry->dpme->dpme_pblocks;
a584 1
	free(entry->dpme);
d608 1
a608 1
		if (strncasecmp(cur->dpme->dpme_type, type_name, DPISTRLEN) ==
d621 1
a621 1
		if (cur->dpme->dpme_pblock_start == base)
d705 1
a705 1
	start = entry->dpme->dpme_pblock_start;
d707 1
a707 1
		if (start <= cur->dpme->dpme_pblock_start) {
d732 1
a732 1
	if (new_size == entry->dpme->dpme_pblocks)
d737 1
a737 1
	if (new_size < entry->dpme->dpme_pblocks) {
d740 1
a740 1
		    strncasecmp(next->dpme->dpme_type, kFreeType, DPISTRLEN) !=
d753 1
a753 1
	    strncasecmp(next->dpme->dpme_type, kFreeType, DPISTRLEN) != 0) {
d757 2
a758 2
	if (entry->dpme->dpme_pblock_start + entry->dpme->dpme_pblocks
	    != next->dpme->dpme_pblock_start) {
d762 1
a762 1
	if (new_size > entry->dpme->dpme_pblocks + next->dpme->dpme_pblocks) {
d767 1
a767 1
	entry->dpme->dpme_type[0] = 0;
d796 1
a796 1
			if (entry->dpme->dpme_pblock_start <= start &&
d798 1
a798 2
			    (entry->dpme->dpme_pblock_start
				+ entry->dpme->dpme_pblocks)) {
@


1.88
log
@There is not much to do if we run out of memory, so simply exit if
a malloc() or calloc() fails. Simplifies a bunch of logic, makes
add_data_to_map() always succeed or exit, so make it a void.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.87 2016/01/29 22:51:43 krw Exp $	*/
a49 6
enum add_action {
	kReplace = 0,
	kAdd = 1,
	kSplit = 2
};

d320 3
a322 6
	enum add_action act;
	int limit;
	uint32_t adjusted_base = 0;
	uint32_t adjusted_length = 0;
	uint32_t new_base = 0;
	uint32_t new_length = 0;
d324 6
a329 1
	/* find a block that starts includes base and length */
d331 2
d338 1
a338 3
	/* if it is not Extra then punt */
	if (cur == NULL ||
	    strncasecmp(cur->dpme->dpme_type, kFreeType, DPISTRLEN) != 0) {
d343 11
a353 30
	/* figure out what to do and sizes */
	dpme = cur->dpme;
	if (dpme->dpme_pblock_start == base) {
		/* replace or add */
		if (dpme->dpme_pblocks == length) {
			act = kReplace;
		} else {
			act = kAdd;
			adjusted_base = base + length;
			adjusted_length = dpme->dpme_pblocks - length;
		}
	} else {
		/* split or add */
		if (dpme->dpme_pblock_start + dpme->dpme_pblocks == base +
		    length) {
			act = kAdd;
			adjusted_base = dpme->dpme_pblock_start;
			adjusted_length = base - adjusted_base;
		} else {
			act = kSplit;
			new_base = dpme->dpme_pblock_start;
			new_length = base - new_base;
			adjusted_base = base + length;
			adjusted_length = dpme->dpme_pblocks - (length +
			    new_length);
		}
	}
	/* if the map will overflow then punt */
	if (map->maximum_in_map < 0)
		limit = map->media_size;
d355 2
a356 2
		limit = map->maximum_in_map;
	if (map->blocks_in_map + act > limit) {
d360 23
d385 2
a386 1
		return 0;
d388 7
a394 20
	if (act == kReplace) {
		free(cur->dpme);
		cur->dpme = dpme;
	} else {
		/* adjust this block's size */
		cur->dpme->dpme_pblock_start = adjusted_base;
		cur->dpme->dpme_pblocks = adjusted_length;
		cur->dpme->dpme_lblocks = adjusted_length;
		/* insert new with block address equal to this one */
		add_data_to_map(dpme, cur->disk_address, map);
		if (act == kSplit) {
			dpme = create_dpme("", kFreeType, new_base, new_length);
			if (dpme != NULL) {
				/*
				 * insert new with block address equal to
				 * this one
				 */
				add_data_to_map(dpme, cur->disk_address, map);
			}
		}
d396 1
@


1.87
log
@Fold struct block0 into struct partition map. There can be only one
and read/write_block0() can move the data from/to disk to/from
appropriate fields anywhere. Removes a bunch of dereferencing,
malloc'ing and pointer checking.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.86 2016/01/29 17:34:08 krw Exp $	*/
d56 1
a56 1
int		add_data_to_map(struct dpme *, long, struct partition_map *);
d74 2
a75 4
	if (map == NULL) {
		warn("can't allocate memory for open partition map");
		return NULL;
	}
d161 2
a162 4
		if (dpme == NULL) {
			warn("can't allocate memory for partition entry");
			return 1;
		}
d200 1
a200 4
		if (add_data_to_map(dpme, ix, map) == 0) {
			free(dpme);
			return 1;
		}
d251 1
a251 1
int
d257 3
a259 4
	if (entry == NULL) {
		warn("can't allocate memory for map entries");
		return 0;
	}
a272 1
	return 1;
d282 3
a284 4
	if (map == NULL) {
		warn("can't allocate memory for open partition map");
		return NULL;
	}
d302 2
a303 9
	if (dpme == NULL) {
		warn("can't allocate memory for initial dpme");
	} else {
		dpme->dpme_signature = DPME_SIGNATURE;
		dpme->dpme_map_entries = 1;
		dpme->dpme_pblock_start = 1;
		dpme->dpme_pblocks = map->media_size - 1;
		strlcpy(dpme->dpme_type, kFreeType, sizeof(dpme->dpme_type));
		dpme_init_flags(dpme);
d305 10
a314 8
		if (add_data_to_map(dpme, 1, map) == 0) {
			free(dpme);
		} else {
			add_partition_to_map("Apple", kMapType, 1,
			    (map->media_size <= 128 ? 2 : 63), map);
			return map;
		}
	}
d316 1
a316 2
	free_partition_map(map);
	return NULL;
d396 2
a397 3
		if (add_data_to_map(dpme, cur->disk_address, map) == 0) {
			free(dpme);
		} else if (act == kSplit) {
d404 1
a404 3
				if (add_data_to_map(dpme, cur->disk_address,
				    map) == 0)
					free(dpme);
d421 13
a433 13
	if (dpme == NULL) {
		warn("can't allocate memory for disk buffers");
	} else {
		dpme->dpme_signature = DPME_SIGNATURE;
		dpme->dpme_map_entries = 1;
		dpme->dpme_pblock_start = base;
		dpme->dpme_pblocks = length;
		strlcpy(dpme->dpme_name, name, sizeof(dpme->dpme_name));
		strlcpy(dpme->dpme_type, dptype, sizeof(dpme->dpme_type));
		dpme->dpme_lblock_start = 0;
		dpme->dpme_lblocks = dpme->dpme_pblocks;
		dpme_init_flags(dpme);
	}
@


1.86
log
@Warn of partitions extending past the end of the media.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.85 2016/01/29 15:06:37 krw Exp $	*/
a56 1
int		coerce_block0(struct partition_map *);
d94 1
a94 7
	map->block0 = malloc(sizeof(struct block0));
	if (map->block0 == NULL) {
		warn("can't allocate memory for block zero buffer");
		free(map);
		return NULL;
	}
	if (read_block0(map->fd, map->block0) == 0) {
d99 3
a101 3
	if (map->block0->sbSig == BLOCK0_SIGNATURE &&
	    map->block0->sbBlkSize == sectorsz &&
	    map->block0->sbBlkCount == mediasz) {
d105 1
a105 1
		if (map->block0->sbSig != BLOCK0_SIGNATURE)
d108 2
a109 2
			    map->block0->sbSig);
		else if (map->block0->sbBlkSize != sectorsz)
d111 2
a112 2
			    map->block0->sbBlkSize, sectorsz);
		else if (map->block0->sbBlkCount != mediasz)
d114 1
a114 1
			    map->block0->sbBlkCount,
a141 1
		free(map->block0);
d246 1
a246 1
	result = write_block0(map->fd, map->block0);
d307 7
a313 3
	map->block0 = calloc(1, sizeof(struct block0));
	if (map->block0 == NULL) {
		warn("can't allocate memory for block zero buffer");
d315 6
a320 1
		coerce_block0(map);
d322 2
a323 3
		dpme = calloc(1, sizeof(struct dpme));
		if (dpme == NULL) {
			warn("can't allocate memory for disk buffers");
d325 3
a327 15
			dpme->dpme_signature = DPME_SIGNATURE;
			dpme->dpme_map_entries = 1;
			dpme->dpme_pblock_start = 1;
			dpme->dpme_pblocks = map->media_size - 1;
			strlcpy(dpme->dpme_type, kFreeType,
			    sizeof(dpme->dpme_type));
			dpme_init_flags(dpme);

			if (add_data_to_map(dpme, 1, map) == 0) {
				free(dpme);
			} else {
				add_partition_to_map("Apple", kMapType,
				    1, (map->media_size <= 128 ? 2 : 63), map);
				return map;
			}
a336 19
coerce_block0(struct partition_map *map)
{
	struct block0 *p;

	p = map->block0;
	if (p->sbSig != BLOCK0_SIGNATURE) {
		p->sbSig = BLOCK0_SIGNATURE;
		p->sbBlkSize = map->physical_block;
		p->sbBlkCount = map->media_size;
		p->sbDevType = 0;
		p->sbDevId = 0;
		p->sbData = 0;
		p->sbDrvrCount = 0;
	}
	return 0;
}


int
d522 1
a522 2
	struct block0  *p;
	struct ddmap   *m;
a526 1
	p = map->block0;
d528 3
a530 3
	if (p->sbDrvrCount > 0) {
		m = p->sbDDMap;
		for (i = 0; i < p->sbDrvrCount; i++) {
d823 1
a823 1
	struct block0 *p;
a827 2
	p = entry->the_map->block0;

d832 4
a835 3
	if (p->sbDrvrCount > 0) {
		m = p->sbDDMap;
		for (i = 0; i < p->sbDrvrCount; i++) {
d851 2
a852 1
				for (j = i + 1; j < p->sbDrvrCount; j++, i++) {
d860 1
a860 1
				p->sbDrvrCount -= 1;
@


1.85
log
@Shorter names means a few whitespace adjustments.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.84 2016/01/29 14:54:38 krw Exp $	*/
d226 6
@


1.84
log
@Rename struct partition_map_header to struct partition_map. No change to
.o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.83 2016/01/29 14:48:20 krw Exp $	*/
d56 1
a56 2
int		add_data_to_map(struct dpme *, long,
		    struct partition_map *);
@


1.83
log
@Rename struct partition_map to struct entry. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.82 2016/01/29 14:26:42 krw Exp $	*/
d57 2
a58 2
		    struct partition_map_header *);
int		coerce_block0(struct partition_map_header *);
d65 1
a65 1
int		read_partition_map(struct partition_map_header *);
d67 1
a67 1
void		renumber_disk_addresses(struct partition_map_header *);
d69 1
a69 1
struct partition_map_header *
d72 1
a72 1
	struct partition_map_header *map;
d75 1
a75 1
	map = malloc(sizeof(struct partition_map_header));
d145 1
a145 1
free_partition_map(struct partition_map_header *map)
d162 1
a162 1
read_partition_map(struct partition_map_header *map)
d244 1
a244 1
write_partition_map(struct partition_map_header *map)
d262 1
a262 1
add_data_to_map(struct dpme *dpme, long ix, struct partition_map_header *map)
d287 1
a287 1
struct partition_map_header *
d290 1
a290 1
	struct partition_map_header *map;
d293 1
a293 1
	map = malloc(sizeof(struct partition_map_header));
d344 1
a344 1
coerce_block0(struct partition_map_header *map)
d364 1
a364 1
    uint32_t length, struct partition_map_header *map)
d497 1
a497 1
renumber_disk_addresses(struct partition_map_header *map)
d547 1
a547 1
	struct partition_map_header *map;
d650 1
a650 1
	struct partition_map_header *map;
d664 1
a664 1
find_entry_by_disk_address(long ix, struct partition_map_header *map)
d677 1
a677 1
find_entry_by_type(const char *type_name, struct partition_map_header *map)
d690 1
a690 1
find_entry_by_base(uint32_t base, struct partition_map_header *map)
d703 1
a703 1
move_entry_in_map(long index1, long index2, struct partition_map_header *map)
d742 1
a742 1
	struct partition_map_header *map;
d768 1
a768 1
	struct partition_map_header *map;
d794 1
a794 1
resize_map(long new_size, struct partition_map_header *map)
@


1.82
log
@Conform to Apple Mac OS X's behaviour of setting dpme_flags on free
partitions to 0, and setting them to VALID | ALLOCATED on the map
partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.81 2016/01/29 12:16:41 krw Exp $	*/
d59 2
a60 2
int		contains_driver(struct partition_map *);
void		combine_entry(struct partition_map *);
d62 3
a64 3
void		delete_entry(struct partition_map *);
void		insert_in_base_order(struct partition_map *);
void		insert_in_disk_order(struct partition_map *);
d66 1
a66 1
void		remove_driver(struct partition_map *);
d147 1
a147 1
	struct partition_map *entry;
d164 1
a164 1
	struct partition_map *cur, *nextcur;
d246 1
a246 1
	struct partition_map *entry;
d264 1
a264 1
	struct partition_map *entry;
d266 1
a266 1
	entry = malloc(sizeof(struct partition_map));
d366 1
a366 1
	struct partition_map *cur;
d499 1
a499 1
	struct partition_map *cur;
d511 1
a511 1
delete_partition_from_map(struct partition_map *entry)
d545 1
a545 1
contains_driver(struct partition_map *entry)
d572 1
a572 1
combine_entry(struct partition_map *entry)
d574 1
a574 1
	struct partition_map *p;
d648 1
a648 1
delete_entry(struct partition_map *entry)
d663 1
a663 1
struct partition_map *
d666 1
a666 1
	struct partition_map *cur;
d676 1
a676 1
struct partition_map *
d679 1
a679 1
	struct partition_map *cur;
d689 1
a689 1
struct partition_map *
d692 1
a692 1
	struct partition_map *cur;
d705 1
a705 1
	struct partition_map *p1, *p2;
d740 1
a740 1
insert_in_disk_order(struct partition_map *entry)
d743 1
a743 1
	struct partition_map *cur;
d766 1
a766 1
insert_in_base_order(struct partition_map *entry)
d769 1
a769 1
	struct partition_map *cur;
d796 2
a797 2
	struct partition_map *entry;
	struct partition_map *next;
d849 1
a849 1
remove_driver(struct partition_map *entry)
@


1.81
log
@Conform to Apple Mac OS X's behaviour of not giving 'Apple_Free'
partitions a name. Nuke kFreeName.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.80 2016/01/28 22:09:56 krw Exp $	*/
d326 1
a326 4
			dpme->dpme_lblock_start = 0;
			dpme->dpme_lblocks = dpme->dpme_pblocks;
			dpme->dpme_flags = DPME_WRITABLE | DPME_READABLE |
			    DPME_VALID;
d485 5
a489 2
	/* XXX this is gross, fix it! */
	if (strncasecmp(dpme->dpme_type, kHFSType, DPISTRLEN) == 0)
d492 2
a493 2
		dpme->dpme_flags = DPME_WRITABLE | DPME_READABLE |
		    DPME_ALLOCATED | DPME_VALID;
@


1.80
log
@Flip base_order to a LIST().
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.79 2016/01/28 22:01:00 krw Exp $	*/
a49 2
const char     *kFreeName = "Extra";

a323 2
			strlcpy(dpme->dpme_name, kFreeName,
			    sizeof(dpme->dpme_name));
d444 1
a444 2
			dpme = create_dpme(kFreeName, kFreeType, new_base,
			    new_length);
a533 1
	strlcpy(dpme->dpme_name, kFreeName, sizeof(dpme->dpme_name));
@


1.79
log
@Delete a bunch of Morris dancing in delete_partition_from_map().
No need to create a new dpme. Just rename/retype the existing and
let combine_entry() suck in any surrounding empty space partitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.78 2016/01/28 19:07:45 krw Exp $	*/
d88 1
a88 1
	map->base_order = NULL;
d166 1
a166 1
	struct partition_map *cur;
d226 1
a226 1
	for (cur = map->base_order; cur != NULL; cur = cur->next_by_base) {
d229 3
a231 2
		if (cur->next_by_base != NULL)
			nextbase = cur->next_by_base->dpme->dpme_pblock_start;
a272 2
	entry->next_by_base = NULL;
	entry->prev_by_base = NULL;
d304 1
a304 1
	map->base_order = NULL;
d383 1
a383 2
	cur = map->base_order;
	while (cur != NULL) {
a387 1
		cur = cur->next_by_base;
d587 2
a588 2
	if (entry->next_by_base != NULL) {
		p = entry->next_by_base;
d613 6
a618 2
	if (entry->prev_by_base != NULL) {
		p = entry->prev_by_base;
a656 1
	struct partition_map *p;
d662 1
a662 8

	p = entry->next_by_base;
	if (map->base_order == entry)
		map->base_order = p;
	if (p != NULL)
		p->prev_by_base = entry->prev_by_base;
	if (entry->prev_by_base != NULL)
		entry->prev_by_base->next_by_base = p;
d687 1
a687 2
	cur = map->base_order;
	while (cur != NULL) {
a690 1
		cur = cur->next_by_base;
d700 1
a700 2
	cur = map->base_order;
	while (cur != NULL) {
a702 1
		cur = cur->next_by_base;
d776 1
d780 14
a793 24
	cur = map->base_order;
	if (cur == NULL
	|| entry->dpme->dpme_pblock_start <= cur->dpme->dpme_pblock_start) {
		map->base_order = entry;
		entry->next_by_base = cur;
		if (cur != NULL)
			cur->prev_by_base = entry;
		entry->prev_by_base = NULL;
	} else {
		for (cur = map->base_order; cur != NULL;
		    cur = cur->next_by_base) {
			if (cur->dpme->dpme_pblock_start <=
			    entry->dpme->dpme_pblock_start &&
			    (cur->next_by_base == NULL ||
			    entry->dpme->dpme_pblock_start <=
			    cur->next_by_base->dpme->dpme_pblock_start)) {
				entry->next_by_base = cur->next_by_base;
				cur->next_by_base = entry;
				entry->prev_by_base = cur;
				if (entry->next_by_base != NULL)
					entry->next_by_base->prev_by_base =
					    entry;
				break;
			}
a811 2
	next = entry->next_by_base;

d815 2
a816 1
	/* make it smaller */
d818 1
@


1.78
log
@Hand rolled lists suck. First, replace disk_order with an LIST.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.77 2016/01/28 18:12:51 krw Exp $	*/
a520 1
	struct partition_map_header *map;
d527 4
d537 1
d539 8
a546 22
	/* if past end of disk, delete it completely */
	if (entry->next_by_base == NULL &&
	    entry->dpme->dpme_pblock_start >= entry->the_map->media_size) {
		if (entry->contains_driver) {
			remove_driver(entry);	/* update block0 if necessary */
		}
		delete_entry(entry);
		return;
	}
	/* If at end of disk, incorporate extra disk space to partition */
	if (entry->next_by_base == NULL) {
		entry->dpme->dpme_pblocks = entry->the_map->media_size -
		    entry->dpme->dpme_pblock_start;
	}
	dpme = create_dpme(kFreeName, kFreeType,
	    entry->dpme->dpme_pblock_start, entry->dpme->dpme_pblocks);
	if (dpme == NULL)
		return;
	if (entry->contains_driver)
		remove_driver(entry);	/* update block0 if necessary */
	free(entry->dpme);
	entry->dpme = dpme;
d548 2
a549 3
	map = entry->the_map;
	renumber_disk_addresses(map);
	map->changed = 1;
@


1.77
log
@Oops. Deleted one too many lines. Need to advance pointer when traversing
list.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.76 2016/01/28 17:17:57 krw Exp $	*/
d30 1
a68 1
void		remove_from_disk_order(struct partition_map *);
d87 1
a87 1
	map->disk_order = NULL;
d149 1
a149 1
	struct partition_map *entry, *next;
d153 3
a155 2
		for (entry = map->disk_order; entry != NULL; entry = next) {
			next = entry->next_on_disk;
d254 1
a254 2
	for (entry = map->disk_order; entry != NULL;
	    entry = entry->next_on_disk) {
a271 2
	entry->next_on_disk = NULL;
	entry->prev_on_disk = NULL;
d304 1
a304 1
	map->disk_order = NULL;
a510 1
	cur = map->disk_order;
d512 1
a512 1
	while (cur != NULL) {
a514 1
		cur = cur->next_on_disk;
d672 1
a672 1
	remove_from_disk_order(entry);
d692 1
a692 2
	cur = map->disk_order;
	while (cur != NULL) {
a694 1
		cur = cur->next_on_disk;
d753 2
a754 2
	remove_from_disk_order(p1);
	remove_from_disk_order(p2);
a767 20
remove_from_disk_order(struct partition_map *entry)
{
	struct partition_map_header *map;
	struct partition_map *p;

	map = entry->the_map;
	p = entry->next_on_disk;
	if (map->disk_order == entry)
		map->disk_order = p;
	if (p != NULL)
		p->prev_on_disk = entry->prev_on_disk;
	if (entry->prev_on_disk != NULL)
		entry->prev_on_disk->next_on_disk = p;

	entry->next_on_disk = NULL;
	entry->prev_on_disk = NULL;
}


void
d775 13
a787 22
	cur = map->disk_order;
	if (cur == NULL || entry->disk_address <= cur->disk_address) {
		map->disk_order = entry;
		entry->next_on_disk = cur;
		if (cur != NULL)
			cur->prev_on_disk = entry;
		entry->prev_on_disk = NULL;
	} else {
		for (cur = map->disk_order; cur != NULL;
		    cur = cur->next_on_disk) {
			if (cur->disk_address <= entry->disk_address &&
			    (cur->next_on_disk == NULL ||
			    entry->disk_address <=
			    cur->next_on_disk->disk_address)) {
				entry->next_on_disk = cur->next_on_disk;
				cur->next_on_disk = entry;
				entry->prev_on_disk = cur;
				if (entry->next_on_disk != NULL)
					entry->next_on_disk->prev_on_disk =
					    entry;
				break;
			}
@


1.76
log
@When adding a new partition to the map, use only existing mapped
space. Don't try to create new free space partitions to use. If the
map does not know about all of the space on the disk, it is broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.75 2016/01/28 13:09:21 krw Exp $	*/
d392 1
@


1.75
log
@Since we don't allow maps to be created or opened with an invalid
block0, there is no point in checking later if block0 has magically
become invalid.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.74 2016/01/28 13:01:33 krw Exp $	*/
d390 1
a390 1
		    (cur->dpme->dpme_pblock_start + cur->dpme->dpme_pblocks)) {
a391 45
		} else {
			/*
			 * check if request is past end of existing
			 * partitions, but on disk
			 */
			if ((cur->next_by_base == NULL) &&
			    (base + length <= map->media_size)) {
				/* Expand final free partition */
				if ((strncasecmp(cur->dpme->dpme_type,
				    kFreeType, DPISTRLEN) == 0) &&
				    base >= cur->dpme->dpme_pblock_start) {
					cur->dpme->dpme_pblocks =
					    map->media_size -
					    cur->dpme->dpme_pblock_start;
					break;
				}
				/* create an extra free partition */
				if (base >= cur->dpme->dpme_pblock_start +
				    cur->dpme->dpme_pblocks) {
					if (map->maximum_in_map < 0) {
						limit = map->media_size;
					} else {
						limit = map->maximum_in_map;
					}
					if (map->blocks_in_map + 1 > limit) {
						printf("the map is not big "
						    "enough\n");
						return 0;
					}
					dpme = create_dpme(kFreeName, kFreeType,
					    cur->dpme->dpme_pblock_start +
					    cur->dpme->dpme_pblocks,
					    map->media_size -
					    (cur->dpme->dpme_pblock_start +
					    cur->dpme->dpme_pblocks));
					if (dpme != NULL) {
						if (add_data_to_map(dpme,
						    cur->disk_address, map) ==
						    0)
							free(dpme);
					}
				}
			}
			cur = cur->next_by_base;
		}
@


1.74
log
@Use consistent 'return' idiom -- no parenthesis since that was the style
of the existing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.73 2016/01/28 01:00:53 krw Exp $	*/
a622 2
	if (p->sbSig != BLOCK0_SIGNATURE)
		return 0;
d967 2
a968 3
	struct partition_map_header *map;
	struct block0  *p;
	struct ddmap   *m;
d972 1
a972 4
	map = entry->the_map;
	p = map->block0;
	if (p->sbSig != BLOCK0_SIGNATURE)
		return;
@


1.73
log
@Make 'r' (reorder, a.k.a. swap) command work with any two existing
partitions.  Do NOT allow partition 1 to be moved!
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.72 2016/01/27 23:59:12 krw Exp $	*/
d137 1
a137 1
				return (map);
@


1.72
log
@Traverse next_by_base when checking maps coverage, not next_on_disk!
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.71 2016/01/27 14:47:53 krw Exp $	*/
d783 1
a783 1
move_entry_in_map(long old_index, long ix, struct partition_map_header *map)
d785 4
a788 1
	struct partition_map *cur;
d790 13
a802 9
	cur = find_entry_by_disk_address(old_index, map);
	if (cur == NULL) {
		printf("No such partition\n");
	} else {
		remove_from_disk_order(cur);
		cur->disk_address = ix;
		insert_in_disk_order(cur);
		renumber_disk_addresses(map);
		map->changed = 1;
d804 12
@


1.71
log
@We do not support logical_block != physical_block. Remove logical_block
field and left over code that checks for logical != physical.

Removes confusion with dmpe fields lblock_start and lblocks, which
have nothing to do with block sizes! lblock_start is the block
offset within the partition where the data actually starts. and
lblocks is the number of blocks of data within the partition. Both
are in units of *physical blocks*, a.k.a. disk sectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.70 2016/01/27 14:19:59 krw Exp $	*/
d225 1
a225 1
	for (cur = map->base_order; cur != NULL; cur = cur->next_on_disk) {
d228 2
a229 2
		if (cur->next_on_disk != NULL)
			nextbase = cur->next_on_disk->dpme->dpme_pblock_start;
@


1.70
log
@Check block 0 signature, physical block size and physical block count when
reading partition map.

Check for unmapped physical blocks and overlapping partitions when reading
partition map.

No need for duplicate checks in validate_map(), so remove validate.c from
build and 'v' command from code and docs.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.69 2016/01/27 00:03:52 krw Exp $	*/
a89 1
	map->logical_block = sectorsz;
a309 1
	map->logical_block = sectorsz;
d618 1
a618 1
	int i, f;
a624 2
	if (map->logical_block > p->sbBlkSize)
		return 0;
a625 1
	f = p->sbBlkSize / map->logical_block;
d630 2
a631 2
			if (entry->dpme->dpme_pblock_start <= f * start &&
			    f * (start + m[i].ddSize) <=
d953 1
a953 1
	int i, j, f;
a959 2
	if (map->logical_block > p->sbBlkSize)
		return;
a964 1
	f = p->sbBlkSize / map->logical_block;
d974 2
a975 2
			if (entry->dpme->dpme_pblock_start <= f * start &&
			    f * (start + m[i].ddSize) <=
@


1.69
log
@Nuke another (and I hope final) batch of superfluous '{}' around single
statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.68 2016/01/26 21:07:54 krw Exp $	*/
d110 18
a127 3

	if (read_partition_map(map) == 0)
		return map;
d166 1
d169 1
a169 1
	uint32_t limit;
d199 16
d220 20
@


1.68
log
@dpme_name and dpme_type are NUL-terminated in Apple code, so use
strlcpy() to fill them.

They are also supposed to be NUL-padded so zap previous contents
before copying in possibly shorter new values.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.67 2016/01/26 16:39:00 krw Exp $	*/
d235 1
a235 1
		if (strncasecmp(dpme->dpme_type, kMapType, DPISTRLEN) == 0) {
a236 1
		}
d380 1
a380 1
						    0) {
a381 1
						}
@


1.67
log
@Whitespace, line wrapping fixes. Nuke many superfluous '{}' around single
statements. 0 -> NULL for pointer checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.66 2016/01/26 16:13:09 krw Exp $	*/
d280 4
a283 2
			strncpy(dpme->dpme_name, kFreeName, DPISTRLEN);
			strncpy(dpme->dpme_type, kFreeType, DPISTRLEN);
d482 2
a483 2
		strncpy(dpme->dpme_name, name, DPISTRLEN);
		strncpy(dpme->dpme_type, dptype, DPISTRLEN);
@


1.66
log
@Whitespace, line wrapping fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.65 2016/01/26 02:38:05 krw Exp $	*/
d423 1
a423 1
	if (map->maximum_in_map < 0) {
d425 1
a425 1
	} else {
a426 1
	}
d432 1
a432 1
	if (dpme == NULL) {
d434 1
a434 1
	}
d455 1
a455 1
				    map) == 0) {
a456 1
				}
d492 2
a493 2
	if (strncasecmp(dpme->dpme_type, kHFSType, DPISTRLEN) == 0) {
		/* XXX this is gross, fix it! */
d495 1
a495 1
	} else {
a497 1
	}
d549 1
a549 1
	if (dpme == NULL) {
d551 1
a551 2
	}
	if (entry->contains_driver) {
a552 1
	}
d573 1
a573 1
	if (p->sbSig != BLOCK0_SIGNATURE) {
d575 1
a575 2
	}
	if (map->logical_block > p->sbBlkSize) {
d577 2
a578 3
	} else {
		f = p->sbBlkSize / map->logical_block;
	}
d586 1
a586 1
			    entry->dpme->dpme_pblocks)) {
a587 1
			}
d600 2
a601 2
	if (entry == NULL
	|| strncasecmp(entry->dpme->dpme_type, kFreeType, DPISTRLEN) != 0) {
d603 1
a603 1
	}
d678 1
a678 1
	if (map->base_order == entry) {
d680 1
a680 2
	}
	if (p != NULL) {
d682 1
a682 2
	}
	if (entry->prev_by_base != NULL) {
d684 1
a684 1
	}
d697 1
a697 1
		if (cur->disk_address == ix) {
a698 1
		}
d713 1
a713 1
		    0) {
a714 1
		}
d727 1
a727 1
		if (cur->dpme->dpme_pblock_start == base) {
a728 1
		}
d761 1
a761 1
	if (map->disk_order == entry) {
d763 1
a763 2
	}
	if (p != NULL) {
d765 1
a765 2
	}
	if (entry->prev_on_disk != NULL) {
d767 1
a767 1
	}
d785 1
a785 1
		if (cur != NULL) {
a786 1
		}
d798 1
a798 1
				if (entry->next_on_disk != NULL) {
a800 1
				}
d821 1
a821 1
		if (cur != NULL) {
a822 1
		}
d835 1
a835 1
				if (entry->next_by_base != NULL) {
a837 1
				}
d860 1
a860 1
	if (new_size == entry->dpme->dpme_pblocks) {
d862 1
a862 1
	}
d867 1
a867 1
		    0) {
d869 1
a869 1
		} else {
a870 1
		}
d911 1
a911 1
	if (p->sbSig != BLOCK0_SIGNATURE) {
d913 1
a913 3
	}
	if (map->logical_block > p->sbBlkSize) {
		/* this is not supposed to happen, but let's just ignore it. */
d915 6
a920 7
	} else {
		/*
		 * compute the factor to convert the block numbers in block0
		 * into partition map block numbers.
		 */
		f = p->sbBlkSize / map->logical_block;
	}
@


1.65
log
@Simplify logic of read_partition_map(), junking retries with various sizes
of logical block. Rely on read_dpme() to do the correct thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.64 2016/01/25 23:43:20 krw Exp $	*/
d353 2
a354 2
						map->media_size -
						cur->dpme->dpme_pblock_start;
d551 1
a551 1
		 entry->dpme->dpme_pblock_start, entry->dpme->dpme_pblocks);
d618 1
a618 2
			   entry->dpme->dpme_pblocks !=
			   p->dpme->dpme_pblock_start) {
d643 2
a644 2
		} else if (p->dpme->dpme_pblock_start + p->dpme->dpme_pblocks
			   != entry->dpme->dpme_pblock_start) {
@


1.64
log
@Use new read/write_block0 and read/write_dpme which handle any
endian or alignment issues forcefully. Removes need for convert_*
functions so unhook convert.c from build. read/write_block become
static functions inside file_media.c.

Tweak struct block0 to stop trying to handle alignment issues by clever
declaration. Rely on the new functions to accurately translate between
on-disk and in-memory layouts.

Enables pdisk to work on amd64 and likely other architectures if
it's ever desirable. Does bring back DEV_BSIZE to pdisk.c since the
in-memory structure will *not* be 512 bytes on other archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.63 2016/01/24 15:23:33 krw Exp $	*/
d111 1
a111 1
	if (read_partition_map(map) != -1)
d152 1
a152 2
	double d;
	int ix, old_logical;
d155 6
a160 25
	dpme = malloc(sizeof(struct dpme));
	if (dpme == NULL) {
		warn("can't allocate memory for disk buffers");
		return -1;
	}
	if (read_dpme(map->fd, 1, dpme) == 0) {
		warnx("Can't read block 1 from '%s'", map->name);
		free(dpme);
		return -1;
	} else if (dpme->dpme_signature != DPME_SIGNATURE) {
		old_logical = map->logical_block;
		map->logical_block = 512;
		while (map->logical_block <= map->physical_block) {
			if (read_dpme(map->fd, 1, dpme) == 0) {
				warnx("Can't read block 1 from '%s'",
				    map->name);
				free(dpme);
				return -1;
			} else if (dpme->dpme_signature == DPME_SIGNATURE) {
				d = map->media_size;
				map->media_size = (d * old_logical) /
				    map->logical_block;
				break;
			}
			map->logical_block *= 2;
d162 2
a163 2
		if (map->logical_block > map->physical_block) {
			warnx("No valid block 1 on '%s'", map->name);
d165 1
a165 1
			return -1;
d167 4
a170 5
	}
	limit = dpme->dpme_map_entries;
	ix = 1;
	while (1) {
		if (add_data_to_map(dpme, ix, map) == 0) {
d172 1
a172 1
			return -1;
d174 8
a181 4
		if (ix >= limit) {
			break;
		} else {
			ix++;
d183 1
a183 13

		dpme = malloc(sizeof(struct dpme));
		if (dpme == NULL) {
			warn("can't allocate memory for disk buffers");
			return -1;
		}
		if (read_dpme(map->fd, ix, dpme) == 0) {
			warnx("Can't read block %u from '%s'", ix, map->name);
			free(dpme);
			return -1;
		} else if ((dpme->dpme_signature != DPME_SIGNATURE) ||
			   (dpme->dpme_map_entries != limit)) {
			warnx("Bad dpme in block %u from '%s'", ix, map->name);
d185 1
a185 1
			return -1;
@


1.63
log
@Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.62 2016/01/24 15:18:50 krw Exp $	*/
a39 1
#include "convert.h"
d105 1
a105 3
	if (read_block(map->fd, 0, map->block0) == 0 ||
	    convert_block0(map->block0, 1) ||
	    coerce_block0(map)) {
d161 1
a161 1
	if (read_block(map->fd, 1, dpme) == 0) {
d165 1
a165 2
	} else if (convert_dpme(dpme, 1) ||
		   dpme->dpme_signature != DPME_SIGNATURE) {
d169 1
a169 1
			if (read_block(map->fd, 1, dpme) == 0) {
d174 1
a174 2
			} else if (convert_dpme(dpme, 1) == 0
				&& dpme->dpme_signature == DPME_SIGNATURE) {
d206 1
a206 1
		if (read_block(map->fd, ix, dpme) == 0) {
d210 1
a210 2
		} else if (convert_dpme(dpme, 1) ||
			   (dpme->dpme_signature != DPME_SIGNATURE) ||
d227 1
a227 2
	convert_block0(map->block0, 0);
	result = write_block(map->fd, 0, map->block0);
a229 1
	convert_block0(map->block0, 1);
d233 1
a233 2
		convert_dpme(entry->dpme, 0);
		result = write_block(map->fd, entry->disk_address, entry->dpme);
a235 1
		convert_dpme(entry->dpme, 1);
d616 1
a616 1
		m = (struct ddmap *)p->sbMap;
d975 1
a975 1
		m = (struct ddmap *)p->sbMap;
@


1.62
log
@Nuke get_align_long() and put_align_long() #define's. They don't do
anything according to gcc & cmp.

cmp suggested by & ok stefan@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.61 2016/01/24 01:38:32 krw Exp $	*/
d626 1
a626 1
		m = (struct ddmap *) p->sbMap;
d985 1
a985 1
		m = (struct ddmap *) p->sbMap;
@


1.61
log
@Whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.60 2016/01/24 01:09:08 krw Exp $	*/
a43 2
#define get_align_long(x)	(*(x))
#define put_align_long(y, x)	((*(x)) = (y))
d628 1
a628 1
			start = get_align_long(&m[i].ddBlock);
d987 1
a987 1
			start = get_align_long(&m[i].ddBlock);
d1003 1
a1003 2
					put_align_long(get_align_long(
					    &m[j].ddBlock), &m[i].ddBlock);
d1007 1
a1007 1
				put_align_long(0, &m[i].ddBlock);
a1016 1

@


1.60
log
@Delete duplicated line that was setting sbBlkCount to 0; Score one
for the 'v' command!
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.59 2016/01/23 23:25:58 krw Exp $	*/
d138 1
a138 1
free_partition_map(struct partition_map_header * map)
d154 1
a154 1
read_partition_map(struct partition_map_header * map)
d230 1
a230 1
write_partition_map(struct partition_map_header * map)
d253 1
a253 1
add_data_to_map(struct dpme * dpme, long ix, struct partition_map_header * map)
d344 1
a344 1
coerce_block0(struct partition_map_header * map)
d364 1
a364 1
    uint32_t length, struct partition_map_header * map)
d533 1
a533 1
dpme_init_flags(struct dpme * dpme)
d545 1
a545 1
renumber_disk_addresses(struct partition_map_header * map)
d561 1
a561 1
delete_partition_from_map(struct partition_map * entry)
d609 1
a609 1
contains_driver(struct partition_map * entry)
d644 1
a644 1
combine_entry(struct partition_map * entry)
d655 2
a656 1
		if (strncasecmp(p->dpme->dpme_type, kFreeType, DPISTRLEN) != 0) {
d682 2
a683 1
		if (strncasecmp(p->dpme->dpme_type, kFreeType, DPISTRLEN) != 0) {
d717 1
a717 1
delete_entry(struct partition_map * entry)
d743 1
a743 1
find_entry_by_disk_address(long ix, struct partition_map_header * map)
d759 1
a759 1
find_entry_by_type(const char *type_name, struct partition_map_header * map)
d775 1
a775 1
find_entry_by_base(uint32_t base, struct partition_map_header * map)
d791 1
a791 1
move_entry_in_map(long old_index, long ix, struct partition_map_header * map)
d809 1
a809 1
remove_from_disk_order(struct partition_map * entry)
d831 1
a831 1
insert_in_disk_order(struct partition_map * entry)
d868 1
a868 1
insert_in_base_order(struct partition_map * entry)
d907 1
a907 1
resize_map(long new_size, struct partition_map_header * map)
d963 1
a963 1
remove_driver(struct partition_map * entry)
@


1.59
log
@Nuke unused kPatchType. Nuke kStringNot and use " not' where needed.
Nuke kStringEmpty and use "" where needed. Nuke unused static 'g'.

Eliminate #include's in *.h files.

Some whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.58 2016/01/23 15:05:52 krw Exp $	*/
a352 1
		p->sbBlkCount = 0;
@


1.58
log
@Pass the disk sector size to open_partition_map(), eliminating it's
internal need for DEV_BSIZE. Ditto create_partition_map().

malloc((sizeof(struct [block0|dpme])) instead of malloc(DEV_BSIZE).

Remove another #include <param.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.57 2016/01/23 14:10:05 krw Exp $	*/
d37 1
a50 1
const char     *kPatchType = "Apple_Patches";
@


1.57
log
@Add comments to ensure future spelunkers realize that struct block0
and struct dpme must be 512-bytes long at the moment.

Use this fact to avoid using DEV_BSIZE and thus replace #include
<param.h> with #include <types.h> in pdisk.c.

Constrain media size to UINT32_MAX, the actual limit, instead of
LONG_MAX, which could be way more on some theoretical future arch
running pdisk. And do the constraint inside open_partition_map().
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.56 2016/01/23 13:24:15 krw Exp $	*/
a29 1
#include <sys/param.h>		/* DEV_BSIZE */
d75 1
a75 1
open_partition_map(int fd, char *name, uint64_t mediasz)
d92 2
a93 2
	map->physical_block = DEV_BSIZE;
	map->logical_block = DEV_BSIZE;
d102 1
a102 1
	map->block0 = malloc(DEV_BSIZE);
d126 1
a126 1
			map = create_partition_map(fd, name, mediasz);
d156 1
a156 1
	struct dpme    *dpme;
d161 1
a161 1
	dpme = malloc(DEV_BSIZE);
d208 1
a208 1
		dpme = malloc(DEV_BSIZE);
d284 1
a284 1
create_partition_map(int fd, char *name, u_int64_t mediasz)
d300 2
a301 2
	map->physical_block = DEV_BSIZE;
	map->logical_block = DEV_BSIZE;
d307 1
a307 1
	map->block0 = calloc(1, DEV_BSIZE);
d313 1
a313 1
		dpme = calloc(1, DEV_BSIZE);
d516 1
a516 1
	dpme = calloc(1, DEV_BSIZE);
@


1.56
log
@Avoid double prompt after creating default map on startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.55 2016/01/23 03:46:18 krw Exp $	*/
d31 1
d97 5
a101 1
	map->media_size = mediasz;
@


1.55
log
@Flip read_block() and write_block() back to taking sector addresses
instead of off_t values. Do the DEV_BSIZE multiplication in these two
functions.

Easier to read code and kills two #include <sys/param.h>.

Kill unused label.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.54 2016/01/23 01:43:13 krw Exp $	*/
d78 1
d118 3
a120 1
		if (get_okay("Create default map? [n/y]: ", 0) == 1) {
@


1.54
log
@map->block0 is always allocated or the map is discarded.

So stop checking for NULL. Nuke get_block_zero() and just use
map->block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.53 2016/01/23 01:16:12 krw Exp $	*/
d159 1
a159 1
	if (read_block(map->fd, DEV_BSIZE, dpme) == 0) {
d168 1
a168 1
			if (read_block(map->fd, DEV_BSIZE, dpme) == 0) {
d206 1
a206 1
		if (read_block(map->fd, ix * DEV_BSIZE, dpme) == 0) {
d237 1
a237 2
		result = write_block(map->fd, entry->disk_address * DEV_BSIZE,
		    entry->dpme);
@


1.53
log
@Nuke sync_device_size() and do it's one-field-update in coerce_block0(),
right after we read/allocate media->block0. Doing sync *before*
media->block0 is allocated is bad.

The map->physical_block is initialized correctly and never to the
magic number '1'. So just use map-physical_block to initialize
sbBlkSize.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.52 2016/01/23 01:09:29 krw Exp $	*/
d226 1
a226 2
	char *block;
	int i = 0, result = 0;
d228 3
a230 12
	if (map->block0 != NULL) {
		convert_block0(map->block0, 0);
		result = write_block(map->fd, 0, map->block0);
		convert_block0(map->block0, 1);
	} else {
		block = calloc(1, DEV_BSIZE);
		if (block != NULL) {
			result = write_block(map->fd, 0, block);
			free(block);
		}
	}
	if (result == 0) {
d232 2
a233 1
	}
d239 2
a241 4
		i = entry->disk_address;
		if (result == 0) {
			warn("Unable to write block %d", i);
		}
a342 3
	if (p == NULL) {
		return 1;
	}
a613 3
	if (p == NULL) {
		return 0;
	}
a965 3
	if (p == NULL) {
		return;
	}
@


1.52
log
@Always initialize media_size to provided mediasz in open_partition_map().
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.51 2016/01/23 01:03:46 krw Exp $	*/
a310 1
	sync_device_size(map);
d359 2
a360 5
		if (map->physical_block == 1) {
			p->sbBlkSize = DEV_BSIZE;
		} else {
			p->sbBlkSize = map->physical_block;
		}
a567 19

void
sync_device_size(struct partition_map_header * map)
{
	struct block0  *p;
	unsigned long size;
	double d;

	p = map->block0;
	if (p == NULL) {
		return;
	}
	d = map->media_size;
	size = (d * map->logical_block) / p->sbBlkSize;
	if (p->sbBlkCount != size) {
		p->sbBlkCount = size;
	}
}

@


1.51
log
@Break annoying long line.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.50 2016/01/22 18:57:42 krw Exp $	*/
d95 1
@


1.50
log
@Change partition map field 'data' to 'dmpe'. Change 'create_data'
to 'create_dmpe'. Sweep up some 'struct dpme *data' to struct dpme
*dpme'.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.49 2016/01/22 17:35:16 krw Exp $	*/
d375 2
a376 2
add_partition_to_map(const char *name, const char *dptype, uint32_t base, uint32_t length,
		     struct partition_map_header * map)
@


1.49
log
@Rename map field 'misc' to 'block0' since that's what it is.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.48 2016/01/22 15:59:33 krw Exp $	*/
d65 1
a65 1
struct dpme    *create_data(const char *, const char *, uint32_t, uint32_t);
d138 1
a138 1
			free(entry->data);
d148 1
a148 1
	struct dpme    *data;
d153 2
a154 2
	data = malloc(DEV_BSIZE);
	if (data == NULL) {
d158 1
a158 1
	if (read_block(map->fd, DEV_BSIZE, data) == 0) {
d160 1
a160 1
		free(data);
d162 2
a163 2
	} else if (convert_dpme(data, 1) ||
		   data->dpme_signature != DPME_SIGNATURE) {
d167 1
a167 1
			if (read_block(map->fd, DEV_BSIZE, data) == 0) {
d170 1
a170 1
				free(data);
d172 2
a173 2
			} else if (convert_dpme(data, 1) == 0
				&& data->dpme_signature == DPME_SIGNATURE) {
d183 1
a183 1
			free(data);
d187 1
a187 1
	limit = data->dpme_map_entries;
d190 2
a191 2
		if (add_data_to_map(data, ix, map) == 0) {
			free(data);
d200 2
a201 2
		data = malloc(DEV_BSIZE);
		if (data == NULL) {
d205 1
a205 1
		if (read_block(map->fd, ix * DEV_BSIZE, data) == 0) {
d207 1
a207 1
			free(data);
d209 5
a213 5
		} else if (convert_dpme(data, 1) ||
			   (data->dpme_signature != DPME_SIGNATURE) ||
			   (data->dpme_map_entries != limit)) {
			warnx("Bad data in block %u from '%s'", ix, map->name);
			free(data);
d244 1
a244 1
		convert_dpme(entry->data, 0);
d246 2
a247 2
		    entry->data);
		convert_dpme(entry->data, 1);
d257 1
a257 1
add_data_to_map(struct dpme * data, long ix, struct partition_map_header * map)
d272 1
a272 1
	entry->data = data;
d280 2
a281 2
		if (strncasecmp(data->dpme_type, kMapType, DPISTRLEN) == 0) {
			map->maximum_in_map = data->dpme_pblocks;
d291 1
a291 1
	struct dpme *data;
d318 2
a319 2
		data = calloc(1, DEV_BSIZE);
		if (data == NULL) {
d322 9
a330 9
			data->dpme_signature = DPME_SIGNATURE;
			data->dpme_map_entries = 1;
			data->dpme_pblock_start = 1;
			data->dpme_pblocks = map->media_size - 1;
			strncpy(data->dpme_name, kFreeName, DPISTRLEN);
			strncpy(data->dpme_type, kFreeType, DPISTRLEN);
			data->dpme_lblock_start = 0;
			data->dpme_lblocks = data->dpme_pblocks;
			data->dpme_flags = DPME_WRITABLE | DPME_READABLE |
d333 2
a334 2
			if (add_data_to_map(data, 1, map) == 0) {
				free(data);
d379 1
a379 1
	struct dpme *data;
d390 1
a390 1
		if (cur->data->dpme_pblock_start <= base &&
d392 1
a392 1
		    (cur->data->dpme_pblock_start + cur->data->dpme_pblocks)) {
d402 1
a402 1
				if ((strncasecmp(cur->data->dpme_type,
d404 2
a405 2
				    base >= cur->data->dpme_pblock_start) {
					cur->data->dpme_pblocks =
d407 1
a407 1
						cur->data->dpme_pblock_start;
d411 2
a412 2
				if (base >= cur->data->dpme_pblock_start +
				    cur->data->dpme_pblocks) {
d423 3
a425 3
					data = create_data(kFreeName, kFreeType,
					    cur->data->dpme_pblock_start +
					    cur->data->dpme_pblocks,
d427 4
a430 4
					    (cur->data->dpme_pblock_start +
					    cur->data->dpme_pblocks));
					if (data != NULL) {
						if (add_data_to_map(data,
d433 1
a433 1
							free(data);
d443 1
a443 1
	    strncasecmp(cur->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d449 2
a450 2
	data = cur->data;
	if (data->dpme_pblock_start == base) {
d452 1
a452 1
		if (data->dpme_pblocks == length) {
d457 1
a457 1
			adjusted_length = data->dpme_pblocks - length;
d461 1
a461 1
		if (data->dpme_pblock_start + data->dpme_pblocks == base +
d464 1
a464 1
			adjusted_base = data->dpme_pblock_start;
d468 1
a468 1
			new_base = data->dpme_pblock_start;
d471 1
a471 1
			adjusted_length = data->dpme_pblocks - (length +
d485 2
a486 2
	data = create_data(name, dptype, base, length);
	if (data == NULL) {
d490 2
a491 2
		free(cur->data);
		cur->data = data;
d494 3
a496 3
		cur->data->dpme_pblock_start = adjusted_base;
		cur->data->dpme_pblocks = adjusted_length;
		cur->data->dpme_lblocks = adjusted_length;
d498 2
a499 2
		if (add_data_to_map(data, cur->disk_address, map) == 0) {
			free(data);
d501 1
a501 1
			data = create_data(kFreeName, kFreeType, new_base,
d503 1
a503 1
			if (data != NULL) {
d508 1
a508 1
				if (add_data_to_map(data, cur->disk_address,
d510 1
a510 1
					free(data);
d521 3
a523 2
struct dpme    *
create_data(const char *name, const char *dptype, uint32_t base, uint32_t length)
d525 1
a525 1
	struct dpme *data;
d527 2
a528 2
	data = calloc(1, DEV_BSIZE);
	if (data == NULL) {
d531 9
a539 9
		data->dpme_signature = DPME_SIGNATURE;
		data->dpme_map_entries = 1;
		data->dpme_pblock_start = base;
		data->dpme_pblocks = length;
		strncpy(data->dpme_name, name, DPISTRLEN);
		strncpy(data->dpme_type, dptype, DPISTRLEN);
		data->dpme_lblock_start = 0;
		data->dpme_lblocks = data->dpme_pblocks;
		dpme_init_flags(data);
d541 1
a541 1
	return data;
d545 1
a545 1
dpme_init_flags(struct dpme * data)
d547 1
a547 1
	if (strncasecmp(data->dpme_type, kHFSType, DPISTRLEN) == 0) {
d549 1
a549 1
		data->dpme_flags = APPLE_HFS_FLAGS_VALUE;
d551 1
a551 1
		data->dpme_flags = DPME_WRITABLE | DPME_READABLE |
d567 1
a567 1
		cur->data->dpme_map_entries = map->blocks_in_map;
d595 1
a595 1
	struct dpme *data;
d597 1
a597 1
	if (strncasecmp(entry->data->dpme_type, kMapType, DPISTRLEN) == 0) {
d610 1
a610 1
	    entry->data->dpme_pblock_start >= entry->the_map->media_size) {
d619 2
a620 2
		entry->data->dpme_pblocks = entry->the_map->media_size -
		    entry->data->dpme_pblock_start;
d622 3
a624 3
	data = create_data(kFreeName, kFreeType,
		 entry->data->dpme_pblock_start, entry->data->dpme_pblocks);
	if (data == NULL) {
d630 2
a631 2
	free(entry->data);
	entry->data = data;
d665 1
a665 1
			if (entry->data->dpme_pblock_start <= f * start &&
d667 2
a668 2
			    (entry->data->dpme_pblock_start +
			    entry->data->dpme_pblocks)) {
d684 1
a684 1
	|| strncasecmp(entry->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d689 1
a689 1
		if (strncasecmp(p->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d691 3
a693 3
		} else if (entry->data->dpme_pblock_start +
			   entry->data->dpme_pblocks !=
			   p->data->dpme_pblock_start) {
d698 6
a703 6
			end = p->data->dpme_pblock_start +
			    p->data->dpme_pblocks;
			if (end > entry->data->dpme_pblock_start +
			    entry->data->dpme_pblocks) {
				entry->data->dpme_pblocks = end -
				    entry->data->dpme_pblock_start;
d705 1
a705 1
			entry->data->dpme_lblocks = entry->data->dpme_pblocks;
d708 2
a709 2
			entry->data->dpme_pblocks += p->data->dpme_pblocks;
			entry->data->dpme_lblocks = entry->data->dpme_pblocks;
d715 1
a715 1
		if (strncasecmp(p->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d717 2
a718 2
		} else if (p->data->dpme_pblock_start + p->data->dpme_pblocks
			   != entry->data->dpme_pblock_start) {
d722 6
a727 6
			end = p->data->dpme_pblock_start +
			    p->data->dpme_pblocks;
			if (end < entry->data->dpme_pblock_start +
			    entry->data->dpme_pblocks) {
				end = entry->data->dpme_pblock_start +
				    entry->data->dpme_pblocks;
d729 2
a730 2
			entry->data->dpme_pblocks = end -
			    p->data->dpme_pblock_start;
d732 3
a734 3
			entry->data->dpme_pblock_start =
			    p->data->dpme_pblock_start;
			entry->data->dpme_lblocks = entry->data->dpme_pblocks;
d737 4
a740 4
			entry->data->dpme_pblock_start =
			    p->data->dpme_pblock_start;
			entry->data->dpme_pblocks += p->data->dpme_pblocks;
			entry->data->dpme_lblocks = entry->data->dpme_pblocks;
d769 1
a769 1
	free(entry->data);
d797 1
a797 1
		if (strncasecmp(cur->data->dpme_type, type_name, DPISTRLEN) ==
d813 1
a813 1
		if (cur->data->dpme_pblock_start == base) {
d909 1
a909 1
	|| entry->data->dpme_pblock_start <= cur->data->dpme_pblock_start) {
d919 2
a920 2
			if (cur->data->dpme_pblock_start <=
			    entry->data->dpme_pblock_start &&
d922 2
a923 2
			    entry->data->dpme_pblock_start <=
			    cur->next_by_base->data->dpme_pblock_start)) {
d953 1
a953 1
	if (new_size == entry->data->dpme_pblocks) {
d957 1
a957 1
	if (new_size < entry->data->dpme_pblocks) {
d959 1
a959 1
		    strncasecmp(next->data->dpme_type, kFreeType, DPISTRLEN) !=
d973 1
a973 1
	    strncasecmp(next->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d977 2
a978 2
	if (entry->data->dpme_pblock_start + entry->data->dpme_pblocks
	    != next->data->dpme_pblock_start) {
d982 1
a982 1
	if (new_size > entry->data->dpme_pblocks + next->data->dpme_pblocks) {
d987 1
a987 1
	entry->data->dpme_type[0] = 0;
d1030 1
a1030 1
			if (entry->data->dpme_pblock_start <= f * start &&
d1032 2
a1033 2
			    (entry->data->dpme_pblock_start
				+ entry->data->dpme_pblocks)) {
@


1.48
log
@Lost a fix for one invocation of write_block() in diff juggling. It
takes an off_t offset, not a disk address, for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.47 2016/01/22 12:31:04 krw Exp $	*/
d96 2
a97 2
	map->misc = malloc(DEV_BSIZE);
	if (map->misc == NULL) {
d102 2
a103 2
	if (read_block(map->fd, 0, map->misc) == 0 ||
	    convert_block0(map->misc, 1) ||
d135 1
a135 1
		free(map->misc);
d228 4
a231 4
	if (map->misc != NULL) {
		convert_block0(map->misc, 0);
		result = write_block(map->fd, 0, map->misc);
		convert_block0(map->misc, 1);
d312 2
a313 2
	map->misc = calloc(1, DEV_BSIZE);
	if (map->misc == NULL) {
d353 1
a353 1
	p = map->misc;
d578 1
a578 1
	p = map->misc;
d648 1
a648 1
	p = map->misc;
d1003 1
a1003 1
	p = map->misc;
@


1.47
log
@Merge read_block() and read_file_media() into read_block(). Ditto
write_block() and write_file_media(). One layer of read/write
wrappers for pread/pwrite should be enough for anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.46 2016/01/22 04:16:25 krw Exp $	*/
d245 2
a246 1
		result = write_block(map->fd, entry->disk_address, entry->data);
@


1.46
log
@Repair creation of initial partition table on a blank disk, broken
when hoisting file operations and ioctl to main(). Pass media size
to open_partition_map() and create_partition_map() so they can
properly initialize a map.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.45 2016/01/22 01:25:56 krw Exp $	*/
a68 2
int		read_block(struct partition_map_header *, unsigned long,
		    char *);
a72 2
int		write_block(struct partition_map_header *, unsigned long,
		    char *);
d102 3
a104 3
	if (read_file_media(map->fd, 0, DEV_BSIZE, (char *) map->misc) == 0 ||
		   convert_block0(map->misc, 1) ||
		   coerce_block0(map)) {
d158 1
a158 1
	if (read_block(map, 1, (char *) data) == 0) {
d167 1
a167 1
			if (read_block(map, 1, (char *) data) == 0) {
d205 1
a205 1
		if (read_block(map, ix, (char *) data) == 0) {
d230 1
a230 1
		result = write_block(map, 0, (char *) map->misc);
d235 1
a235 1
			result = write_block(map, 0, block);
d245 1
a245 2
		result = write_block(map, entry->disk_address,
		    (char *)entry->data);
a1053 14
int
read_block(struct partition_map_header * map, unsigned long num, char *buf)
{
	return read_file_media(map->fd, ((long long) num) * map->logical_block,
			       DEV_BSIZE, (void *) buf);
}


int
write_block(struct partition_map_header * map, unsigned long num, char *buf)
{
	return write_file_media(map->fd, ((long long) num) * map->logical_block,
				DEV_BSIZE, (void *) buf);
}
@


1.45
log
@In the "why use two variables when one would do" category, eliminate
the 'written' field and just use the 'changed' field to mediate
when it is appropriate to ask whether changes should be discarded.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.44 2016/01/22 00:38:53 krw Exp $	*/
d79 1
a79 1
open_partition_map(int fd, char *name)
d122 1
a122 1
			map = create_partition_map(fd, name);
d292 1
a292 1
create_partition_map(int fd, char *name)
d313 2
d340 2
@


1.44
log
@Nuke 'expert' mode and the enabling, undocumented, '-d' flag by
just making all the commands available all the time. Document the
newly available commands.

Remove the former 'P' command (list partitions in base address
order) and use 'P' from expert mode (show map data structures).

Stop accepting uppercase aliases for commands documented as lower
case.

Bring the 'h' help text and man pages into agreement.

ok jasper@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.43 2016/01/21 15:33:21 krw Exp $	*/
a92 1
	map->written = 0;
@


1.43
log
@Hoist all file opening and ioctl calls into main(), passing a pointer to
a valid map to edit(). Should enable pledging a la fdisk at some point.

Since edit() always gets a valid map (and maintains its validity even when
'I'nitializing a new one) many checks for (map == NULL) are junked.

Remove some dances around block sizes by using DEV_BSIZE everywhere
since we don't support non-DEV_BSIZE (a.k.a. 512-byte) sectors.

Remove many superfluous #include statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.42 2016/01/21 02:52:52 krw Exp $	*/
d215 2
a216 3
			   (data->dpme_signature != DPME_SIGNATURE &&
			   dflag == 0) ||
			   (data->dpme_map_entries != limit && dflag == 0)) {
@


1.42
log
@Nuke 'writable' field now that it is always in sync with 'rflag'. Since
(!rflag && writable == 0) can't be true remove those warning blocks and
simply leave the not-writable warning when attempting to write the
map. Always show 'w' in the help and rely on the check and warning
in do_write_partition_map() so the user always gets a message.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.41 2016/01/21 01:37:18 krw Exp $	*/
a30 4
#include <sys/dkio.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
a32 4
#include <limits.h>
#include <unistd.h>
#include <util.h>

a35 2
#include <fcntl.h>
#include <errno.h>
a64 1
long		compute_device_size(char *);
a74 1
void		sync_device_size(struct partition_map_header *);
d79 1
a79 1
open_partition_map(char *name, int *valid_file)
a81 10
	int fd;

	fd = open_file_as_media(name, (rflag) ? O_RDONLY : O_RDWR);
	if (fd == -1) {
		warn("can't open file '%s' for %sing", name, (rflag) ?
		    "read" : "writ");
		*valid_file = 0;
		return NULL;
	}
	*valid_file = 1;
a85 1
		close(fd);
d88 2
d91 1
d96 4
a100 2
	map->physical_block = DEV_BSIZE;	/* preflight */
	map->fd = fd;
a103 1
		close(map->fd);
d106 2
a107 2
	} else if (read_file_media(map->fd, (long long) 0, DEV_BSIZE,
		   (char *) map->misc) == 0 ||
d111 1
a111 1
		close_partition_map(map);
a113 1
	map->physical_block = map->misc->sbBlkSize;
d115 2
a116 1
	map->logical_block = DEV_BSIZE;
d118 9
a126 2
	if (map->logical_block > MAXIOSIZE) {
		map->logical_block = MAXIOSIZE;
a127 7
	if (map->logical_block > map->physical_block) {
		map->physical_block = map->logical_block;
	}
	map->blocks_in_map = 0;
	map->maximum_in_map = -1;
	map->media_size = compute_device_size(map->name);
	sync_device_size(map);
d129 1
a129 7
	if (read_partition_map(map) < 0) {
		/* some sort of failure reading the map */
	} else {
		/* got it! */
		return map;
	}
	close_partition_map(map);
d135 1
a135 1
close_partition_map(struct partition_map_header * map)
d139 8
a146 9
	if (map == NULL) {
		return;
	}
	free(map->misc);

	for (entry = map->disk_order; entry != NULL; entry = next) {
		next = entry->next_on_disk;
		free(entry->data);
		free(entry);
a147 2
	close(map->fd);
	free(map);
a149 1

a292 1

d294 1
a294 1
init_partition_map(char *name, struct partition_map_header * oldmap)
d297 1
a298 33
	if (oldmap != NULL) {
		printf("map already exists\n");
		if (get_okay("do you want to reinit? [n/y]: ", 0) != 1) {
			return oldmap;
		}
	}
	map = create_partition_map(name, oldmap);
	if (map == NULL) {
		return oldmap;
	}
	close_partition_map(oldmap);

	add_partition_to_map("Apple", kMapType,
			     1, (map->media_size <= 128 ? 2 : 63), map);
	return map;
}


struct partition_map_header *
create_partition_map(char *name, struct partition_map_header * oldmap)
{
	struct partition_map_header *map;
	struct dpme *data;
	unsigned long number;
	long size;
	int fd;

	fd = open_file_as_media(name, (rflag) ? O_RDONLY : O_RDWR);
	if (fd == -1) {
		warn("can't open file '%s' for %sing", name, (rflag) ?
		    "read" : "writ");
		return NULL;
	}
a301 1
		close(fd);
d305 1
d310 2
a311 18
	if (oldmap != NULL) {
		size = oldmap->physical_block;
	} else {
		size = DEV_BSIZE;
	}
	map->fd = fd;
	if (map->physical_block > MAXIOSIZE) {
		map->physical_block = MAXIOSIZE;
	}
	map->physical_block = size;

	if (oldmap != NULL) {
		size = oldmap->logical_block;
	} else {
		size = DEV_BSIZE;
	}

	map->logical_block = size;
a315 3
	number = compute_device_size(map->name);
	map->media_size = number;

a320 1
		sync_device_size(map);
d344 2
a345 1
	close_partition_map(map);
a571 29

long
compute_device_size(char *name)
{
	struct disklabel dl;
	struct stat st;
	u_int64_t sz;
	int fd;

	fd = opendev(name, O_RDONLY, OPENDEV_PART, NULL);
	if (fd == -1)
		warn("can't open %s", name);

	if (fstat(fd, &st) == -1)
		err(1, "can't fstat %s", name);
	if (!S_ISCHR(st.st_mode) && !S_ISREG(st.st_mode))
		errx(1, "%s is not a character device or a regular file", name);
	if (ioctl(fd, DIOCGPDINFO, &dl) == -1)
		err(1, "can't get disklabel for %s", name);

	close(fd);

	sz = DL_GETDSIZE(&dl);
	if (sz > LONG_MAX)
		sz = LONG_MAX;

	return ((long) sz);
}

@


1.41
log
@Don't try to be cute by silently opening a disk read-only when R/W
access was requested. Just complain when the R/W open fails. Make
failure messages consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.40 2016/01/18 17:57:35 krw Exp $	*/
d94 1
a94 1
	int fd, writable;
a102 1
	writable = !rflag;
a111 1
	map->writable = (rflag) ? 0 : writable;
a367 1
	map->writable = (rflag) ? 0 : 1;
@


1.40
log
@struct file_media had 1 field left. And one place where struct
file_media was actually stored. So move the last field (fd) into
the place formerly used to store pointer to the instance. As a
result we can just pass fd's around rather than pointers to a struct
containing a fd.

close_file_media() becomes empty but for a close(). So just use
close() and nuke close_file_media().
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.39 2016/01/18 15:30:00 krw Exp $	*/
d98 4
a101 10
		fd = open_file_as_media(name, O_RDONLY);
		if (fd == -1) {
			warn("can't open file '%s'", name);
			*valid_file = 0;
			return NULL;
		} else {
			writable = 0;
		}
	} else {
		writable = 1;
d103 1
@


1.39
log
@os_reload_file_media() doesn't do anything except tell you if you passed it
a NULL pointer. And the result is ignored. Nuke it. This removes the only
use of the 'regular_file' field of struct file_media. So nuke that too.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.38 2016/01/18 02:50:01 krw Exp $	*/
d94 1
a94 2
	struct file_media *m;
	int writable;
d96 4
a99 4
	m = open_file_as_media(name, (rflag) ? O_RDONLY : O_RDWR);
	if (m == 0) {
		m = open_file_as_media(name, O_RDONLY);
		if (m == 0) {
d114 1
a114 1
		close_file_media(m);
d125 1
a125 1
	map->m = m;
d129 1
a129 1
		close_file_media(map->m);
d132 1
a132 1
	} else if (read_file_media(map->m, (long long) 0, DEV_BSIZE,
d181 1
a181 1
	close_file_media(map->m);
a266 1
	struct file_media *m;
a269 1
	m = map->m;
a356 1
	struct file_media *m;
d360 1
d362 2
a363 2
	m = open_file_as_media(name, (rflag) ? O_RDONLY : O_RDWR);
	if (m == 0) {
d371 1
a371 1
		close_file_media(m);
d385 1
a385 1
	map->m = m;
d1178 1
a1178 1
	return read_file_media(map->m, ((long long) num) * map->logical_block,
d1186 1
a1186 1
	return write_file_media(map->m, ((long long) num) * map->logical_block,
@


1.38
log
@Run indent(1) over it and tweak the results a bit manually to look more
KNF'ish.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.37 2016/01/18 00:04:36 krw Exp $	*/
a297 2

	os_reload_file_media(map->m);
@


1.37
log
@Remove a grab bag of unused #define's, fields, enum's, variables,
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.36 2016/01/17 23:18:19 krw Exp $	*/
d30 1
a30 1
#include <sys/param.h>	/* DEV_BSIZE */
d56 5
a60 5
const char * kFreeType	= "Apple_Free";
const char * kMapType	= "Apple_partition_map";
const char * kUnixType	= "OpenBSD";
const char * kHFSType	= "Apple_HFS";
const char * kPatchType	= "Apple_Patches";
d62 1
a62 1
const char * kFreeName	= "Extra";
d65 3
a67 3
    kReplace = 0,
    kAdd = 1,
    kSplit = 2
d70 19
a88 16
int add_data_to_map(struct dpme *, long, struct partition_map_header *);
int coerce_block0(struct partition_map_header *);
int contains_driver(struct partition_map *);
void combine_entry(struct partition_map *);
long compute_device_size(char *);
struct dpme* create_data(const char *, const char *, uint32_t, uint32_t);
void delete_entry(struct partition_map *);
void insert_in_base_order(struct partition_map *);
void insert_in_disk_order(struct partition_map *);
int read_block(struct partition_map_header *, unsigned long, char *);
int read_partition_map(struct partition_map_header *);
void remove_driver(struct partition_map *);
void remove_from_disk_order(struct partition_map *);
void renumber_disk_addresses(struct partition_map_header *);
void sync_device_size(struct partition_map_header *);
int write_block(struct partition_map_header *, unsigned long, char *);
d93 5
a97 7
    struct file_media *m;
    struct partition_map_header * map;
    int writable;

    m = open_file_as_media(name, (rflag)?O_RDONLY:O_RDWR);
    if (m == 0) {
	m = open_file_as_media(name, O_RDONLY);
d99 59
a157 3
	    warn("can't open file '%s'", name);
	    *valid_file = 0;
	    return NULL;
d159 2
a160 1
	    writable = 0;
a161 30
    } else {
	writable = 1;
    }
    *valid_file = 1;

    map = malloc(sizeof(struct partition_map_header));
    if (map == NULL) {
	warn("can't allocate memory for open partition map");
	close_file_media(m);
	return NULL;
    }
    map->name = name;
    map->writable = (rflag)?0:writable;
    map->changed = 0;
    map->written = 0;
    map->disk_order = NULL;
    map->base_order = NULL;

    map->physical_block = DEV_BSIZE;	/* preflight */
    map->m = m;
    map->misc = malloc(DEV_BSIZE);
    if (map->misc == NULL) {
	warn("can't allocate memory for block zero buffer");
	close_file_media(map->m);
	free(map);
	return NULL;
    } else if (read_file_media(map->m, (long long) 0, DEV_BSIZE, (char *)map->misc) == 0
	    || convert_block0(map->misc, 1)
	    || coerce_block0(map)) {
	warnx("Can't read block 0 from '%s'", name);
a163 24
    }
    map->physical_block = map->misc->sbBlkSize;

    map->logical_block = DEV_BSIZE;

    if (map->logical_block > MAXIOSIZE) {
	map->logical_block = MAXIOSIZE;
    }
    if (map->logical_block > map->physical_block) {
	map->physical_block = map->logical_block;
    }
    map->blocks_in_map = 0;
    map->maximum_in_map = -1;
    map->media_size = compute_device_size(map->name);
    sync_device_size(map);

    if (read_partition_map(map) < 0) {
	/* some sort of failure reading the map */
    } else {
	/* got it! */
	return map;
    }
    close_partition_map(map);
    return NULL;
d168 1
a168 1
close_partition_map(struct partition_map_header *map)
d170 1
a170 2
    struct partition_map * entry;
    struct partition_map * next;
d172 4
a175 3
    if (map == NULL) {
	return;
    }
d177 7
a183 9
    free(map->misc);

    for (entry = map->disk_order; entry != NULL; entry = next) {
	next = entry->next_on_disk;
	free(entry->data);
	free(entry);
    }
    close_file_media(map->m);
    free(map);
d188 1
a188 1
read_partition_map(struct partition_map_header *map)
d190 11
a200 22
    struct dpme *data;
    uint32_t limit;
    int ix;
    int old_logical;
    double d;

    data = malloc(DEV_BSIZE);
    if (data == NULL) {
	warn("can't allocate memory for disk buffers");
	return -1;
    }

    if (read_block(map, 1, (char *)data) == 0) {
	warnx("Can't read block 1 from '%s'", map->name);
	free(data);
	return -1;
    } else if (convert_dpme(data, 1)
	    || data->dpme_signature != DPME_SIGNATURE) {
	old_logical = map->logical_block;
	map->logical_block = 512;
	while (map->logical_block <= map->physical_block) {
	    if (read_block(map, 1, (char *)data) == 0) {
d204 24
a227 21
	    } else if (convert_dpme(data, 1) == 0
		    && data->dpme_signature == DPME_SIGNATURE) {
		d = map->media_size;
		map->media_size =  (d * old_logical) / map->logical_block;
		break;
	    }
	    map->logical_block *= 2;
	}
	if (map->logical_block > map->physical_block) {
	    warnx("No valid block 1 on '%s'", map->name);
	    free(data);
	    return -1;
	}
    }

    limit = data->dpme_map_entries;
    ix = 1;
    while (1) {
	if (add_data_to_map(data, ix, map) == 0) {
	    free(data);
	    return -1;
d229 12
d242 17
a258 4
	if (ix >= limit) {
	    break;
	} else {
	    ix++;
d260 1
a260 20

	data = malloc(DEV_BSIZE);
	if (data == NULL) {
	    warn("can't allocate memory for disk buffers");
	    return -1;
	}

	if (read_block(map, ix, (char *)data) == 0) {
	    warnx("Can't read block %u from '%s'", ix, map->name);
	    free(data);
	    return -1;
	} else if (convert_dpme(data, 1)
		|| (data->dpme_signature != DPME_SIGNATURE && dflag == 0)
		|| (data->dpme_map_entries != limit && dflag == 0)) {
	    warnx("Bad data in block %u from '%s'", ix, map->name);
	    free(data);
	    return -1;
	}
    }
    return 0;
d265 1
a265 1
write_partition_map(struct partition_map_header *map)
d267 17
a283 26
    struct file_media *m;
    char *block;
    struct partition_map * entry;
    int i = 0;
    int result = 0;

    m = map->m;
    if (map->misc != NULL) {
	convert_block0(map->misc, 0);
	result = write_block(map, 0, (char *)map->misc);
	convert_block0(map->misc, 1);
    } else {
	block = calloc(1, DEV_BSIZE);
	if (block != NULL) {
	    result = write_block(map, 0, block);
	    free(block);
	}
    }
    if (result == 0) {
	warn("Unable to write block zero");
    }
    for (entry = map->disk_order; entry != NULL; entry = entry->next_on_disk) {
	convert_dpme(entry->data, 0);
	result = write_block(map, entry->disk_address, (char *)entry->data);
	convert_dpme(entry->data, 1);
	i = entry->disk_address;
d285 12
a296 1
	    warn("Unable to write block %d", i);
a297 1
    }
d299 1
a299 1
    os_reload_file_media(map->m);
d304 1
a304 1
add_data_to_map(struct dpme *data, long ix, struct partition_map_header *map)
d306 1
a306 1
    struct partition_map *entry;
d308 22
a329 21
    entry = malloc(sizeof(struct partition_map));
    if (entry == NULL) {
	warn("can't allocate memory for map entries");
	return 0;
    }
    entry->next_on_disk = NULL;
    entry->prev_on_disk = NULL;
    entry->next_by_base = NULL;
    entry->prev_by_base = NULL;
    entry->disk_address = ix;
    entry->the_map = map;
    entry->data = data;
    entry->contains_driver = contains_driver(entry);

    insert_in_disk_order(entry);
    insert_in_base_order(entry);

    map->blocks_in_map++;
    if (map->maximum_in_map < 0) {
	if (strncasecmp(data->dpme_type, kMapType, DPISTRLEN) == 0) {
	    map->maximum_in_map = data->dpme_pblocks;
d331 1
a331 3
    }

    return 1;
d336 1
a336 1
init_partition_map(char *name, struct partition_map_header* oldmap)
d338 13
a350 1
    struct partition_map_header *map;
d352 3
a354 16
    if (oldmap != NULL) {
	printf("map already exists\n");
	if (get_okay("do you want to reinit? [n/y]: ", 0) != 1) {
	    return oldmap;
	}
    }

    map = create_partition_map(name, oldmap);
    if (map == NULL) {
	return oldmap;
    }
    close_partition_map(oldmap);

    add_partition_to_map("Apple", kMapType,
	    1, (map->media_size <= 128? 2: 63), map);
    return map;
d359 1
a359 1
create_partition_map(char *name, struct partition_map_header *oldmap)
d361 45
a405 11
    struct file_media *m;
    struct partition_map_header * map;
    struct dpme *data;
    unsigned long number;
    long size;

    m = open_file_as_media(name, (rflag)?O_RDONLY:O_RDWR);
    if (m == 0) {
	warn("can't open file '%s' for %sing", name, (rflag)?"read":"writ");
	return NULL;
    }
d407 2
a408 43
    map = malloc(sizeof(struct partition_map_header));
    if (map == NULL) {
	warn("can't allocate memory for open partition map");
	close_file_media(m);
	return NULL;
    }
    map->name = name;
    map->writable = (rflag)?0:1;
    map->changed = 1;
    map->disk_order = NULL;
    map->base_order = NULL;

    if (oldmap != NULL) {
	size = oldmap->physical_block;
    } else {
	size = DEV_BSIZE;
    }
    map->m = m;
    if (map->physical_block > MAXIOSIZE) {
	map->physical_block = MAXIOSIZE;
    }
    map->physical_block = size;

    if (oldmap != NULL) {
	size = oldmap->logical_block;
    } else {
	size = DEV_BSIZE;
    }

    map->logical_block = size;

    map->blocks_in_map = 0;
    map->maximum_in_map = -1;

    number = compute_device_size(map->name);
    map->media_size = number;

    map->misc = calloc(1, DEV_BSIZE);
    if (map->misc == NULL) {
	warn("can't allocate memory for block zero buffer");
    } else {
	coerce_block0(map);
	sync_device_size(map);
d410 3
a412 3
	data = calloc(1, DEV_BSIZE);
	if (data == NULL) {
	    warn("can't allocate memory for disk buffers");
d414 2
a415 9
	    data->dpme_signature = DPME_SIGNATURE;
	    data->dpme_map_entries = 1;
	    data->dpme_pblock_start = 1;
	    data->dpme_pblocks = map->media_size - 1;
	    strncpy(data->dpme_name, kFreeName, DPISTRLEN);
	    strncpy(data->dpme_type, kFreeType, DPISTRLEN);
	    data->dpme_lblock_start = 0;
	    data->dpme_lblocks = data->dpme_pblocks;
	    data->dpme_flags = DPME_WRITABLE | DPME_READABLE | DPME_VALID;
d417 21
a437 5
	    if (add_data_to_map(data, 1, map) == 0) {
		free(data);
	    } else {
		return map;
	    }
d439 2
a440 3
    }
    close_partition_map(map);
    return NULL;
d445 1
a445 1
coerce_block0(struct partition_map_header *map)
d447 1
a447 1
    struct block0 *p;
d449 16
a464 10
    p = map->misc;
    if (p == NULL) {
	return 1;
    }
    if (p->sbSig != BLOCK0_SIGNATURE) {
	p->sbSig = BLOCK0_SIGNATURE;
	if (map->physical_block == 1) {
	    p->sbBlkSize = DEV_BSIZE;
	} else {
	    p->sbBlkSize = map->physical_block;
d466 1
a466 7
	p->sbBlkCount = 0;
	p->sbDevType = 0;
	p->sbDevId = 0;
	p->sbData = 0;
	p->sbDrvrCount = 0;
    }
    return 0;
d472 1
a472 1
	struct partition_map_header *map)
d474 8
a481 8
    struct partition_map * cur;
    struct dpme *data;
    enum add_action act;
    int limit;
    uint32_t adjusted_base = 0;
    uint32_t adjusted_length = 0;
    uint32_t new_base = 0;
    uint32_t new_length = 0;
d484 4
a487 4
    cur = map->base_order;
    while (cur != NULL) {
	if (cur->data->dpme_pblock_start <= base
		&& (base + length) <=
d489 66
a554 1
	    break;
d556 17
a572 13
	  /* check if request is past end of existing partitions, but on disk */
	  if ((cur->next_by_base == NULL) &&
	      (base + length <= map->media_size)) {
	    /* Expand final free partition */
	    if ((strncasecmp(cur->data->dpme_type, kFreeType, DPISTRLEN) == 0)
		&& base >= cur->data->dpme_pblock_start) {
	      cur->data->dpme_pblocks =
		map->media_size - cur->data->dpme_pblock_start;
	      break;
	    }
	    /* create an extra free partition */
	    if (base >= cur->data->dpme_pblock_start + cur->data->dpme_pblocks) {
	      if (map->maximum_in_map < 0) {
d574 1
a574 1
	      } else {
d576 2
a577 2
	      }
	      if (map->blocks_in_map + 1 > limit) {
a579 12
	      }
	      data = create_data(kFreeName, kFreeType,
		  cur->data->dpme_pblock_start + cur->data->dpme_pblocks,
		  map->media_size - (cur->data->dpme_pblock_start + cur->data->dpme_pblocks));
	      if (data != NULL) {
		if (add_data_to_map(data, cur->disk_address, map) == 0) {
		  free(data);
		}
	      }
	    }
	  }
	  cur = cur->next_by_base;
d581 7
a587 25
    }
	/* if it is not Extra then punt */
    if (cur == NULL
	    || strncasecmp(cur->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
	printf("requested base and length is not "
		"within an existing free partition\n");
	return 0;
    }
	/* figure out what to do and sizes */
    data = cur->data;
    if (data->dpme_pblock_start == base) {
	/* replace or add */
	if (data->dpme_pblocks == length) {
	    act = kReplace;
	} else {
	    act = kAdd;
	    adjusted_base = base + length;
	    adjusted_length = data->dpme_pblocks - length;
	}
    } else {
	/* split or add */
	if (data->dpme_pblock_start + data->dpme_pblocks == base + length) {
	    act = kAdd;
	    adjusted_base = data->dpme_pblock_start;
	    adjusted_length = base - adjusted_base;
d589 5
a593 37
	    act = kSplit;
	    new_base = data->dpme_pblock_start;
	    new_length = base - new_base;
	    adjusted_base = base + length;
	    adjusted_length = data->dpme_pblocks - (length + new_length);
	}
    }
	/* if the map will overflow then punt */
    if (map->maximum_in_map < 0) {
	limit = map->media_size;
    } else {
	limit = map->maximum_in_map;
    }
    if (map->blocks_in_map + act > limit) {
	printf("the map is not big enough\n");
	return 0;
    }

    data = create_data(name, dptype, base, length);
    if (data == NULL) {
	return 0;
    }
    if (act == kReplace) {
	free(cur->data);
	cur->data = data;
    } else {
	    /* adjust this block's size */
	cur->data->dpme_pblock_start = adjusted_base;
	cur->data->dpme_pblocks = adjusted_length;
	cur->data->dpme_lblocks = adjusted_length;
	    /* insert new with block address equal to this one */
	if (add_data_to_map(data, cur->disk_address, map) == 0) {
	    free(data);
	} else if (act == kSplit) {
	    data = create_data(kFreeName, kFreeType, new_base, new_length);
	    if (data != NULL) {
		    /* insert new with block address equal to this one */
d595 14
a608 1
		    free(data);
a609 1
	    }
d611 3
a613 4
    }
    renumber_disk_addresses(map);
    map->changed = 1;
    return 1;
d617 1
a617 1
struct dpme *
d620 1
a620 1
    struct dpme *data;
d622 15
a636 15
    data = calloc(1, DEV_BSIZE);
    if (data == NULL) {
	warn("can't allocate memory for disk buffers");
    } else {
	data->dpme_signature = DPME_SIGNATURE;
	data->dpme_map_entries = 1;
	data->dpme_pblock_start = base;
	data->dpme_pblocks = length;
	strncpy(data->dpme_name, name, DPISTRLEN);
	strncpy(data->dpme_type, dptype, DPISTRLEN);
	data->dpme_lblock_start = 0;
	data->dpme_lblocks = data->dpme_pblocks;
	dpme_init_flags(data);
    }
    return data;
d640 1
a640 1
dpme_init_flags(struct dpme *data)
d642 7
a648 8
    if (strncasecmp(data->dpme_type, kHFSType, DPISTRLEN) == 0) {
	/* XXX this is gross, fix it! */
	data->dpme_flags = APPLE_HFS_FLAGS_VALUE;
    }
    else {
	data->dpme_flags = DPME_WRITABLE | DPME_READABLE | DPME_ALLOCATED |
	    DPME_VALID;
    }
d652 1
a652 1
renumber_disk_addresses(struct partition_map_header *map)
d654 2
a655 2
    struct partition_map * cur;
    long ix;
d658 7
a664 7
    cur = map->disk_order;
    ix = 1;
    while (cur != NULL) {
	cur->disk_address = ix++;
	cur->data->dpme_map_entries = map->blocks_in_map;
	cur = cur->next_on_disk;
    }
d692 1
a692 1
	return ((long)sz);
d697 1
a697 1
sync_device_size(struct partition_map_header *map)
d699 13
a711 13
    struct block0 *p;
    unsigned long size;
    double d;

    p = map->misc;
    if (p == NULL) {
	return;
    }
    d = map->media_size;
    size = (d * map->logical_block) / p->sbBlkSize;
    if (p->sbBlkCount != size) {
	p->sbBlkCount = size;
    }
d716 1
a716 1
delete_partition_from_map(struct partition_map *entry)
d718 2
a719 2
    struct partition_map_header *map;
    struct dpme *data;
d721 39
a759 38
    if (strncasecmp(entry->data->dpme_type, kMapType, DPISTRLEN) == 0) {
	printf("Can't delete entry for the map itself\n");
	return;
    }
    if (entry->contains_driver) {
	printf("This program can't install drivers\n");
	if (get_okay("are you sure you want to delete this driver? [n/y]: ", 0) != 1) {
	    return;
	}
    }
    /* if past end of disk, delete it completely */
    if (entry->next_by_base == NULL &&
	entry->data->dpme_pblock_start >= entry->the_map->media_size) {
      if (entry->contains_driver) {
	remove_driver(entry);	/* update block0 if necessary */
      }
      delete_entry(entry);
      return;
    }
    /* If at end of disk, incorporate extra disk space to partition */
    if (entry->next_by_base == NULL) {
      entry->data->dpme_pblocks =
	 entry->the_map->media_size - entry->data->dpme_pblock_start;
    }
    data = create_data(kFreeName, kFreeType,
	    entry->data->dpme_pblock_start, entry->data->dpme_pblocks);
    if (data == NULL) {
	return;
    }
    if (entry->contains_driver) {
	remove_driver(entry);	/* update block0 if necessary */
    }
    free(entry->data);
    entry->data = data;
    combine_entry(entry);
    map = entry->the_map;
    renumber_disk_addresses(map);
    map->changed = 1;
d764 1
a764 1
contains_driver(struct partition_map *entry)
d766 31
a796 10
    struct partition_map_header *map;
    struct block0 *p;
    struct ddmap *m;
    int i;
    int f;
    uint32_t start;

    map = entry->the_map;
    p = map->misc;
    if (p == NULL) {
a797 22
    }
    if (p->sbSig != BLOCK0_SIGNATURE) {
	return 0;
    }
    if (map->logical_block > p->sbBlkSize) {
	return 0;
    } else {
	f = p->sbBlkSize / map->logical_block;
    }
    if (p->sbDrvrCount > 0) {
	m = (struct ddmap *) p->sbMap;
	for (i = 0; i < p->sbDrvrCount; i++) {
	    start = get_align_long(&m[i].ddBlock);
	    if (entry->data->dpme_pblock_start <= f*start
		    && f*(start + m[i].ddSize)
			<= (entry->data->dpme_pblock_start
			+ entry->data->dpme_pblocks)) {
		return 1;
	    }
	}
    }
    return 0;
d802 1
a802 1
combine_entry(struct partition_map *entry)
d804 2
a805 2
    struct partition_map *p;
    uint32_t end;
d807 60
a866 49
    if (entry == NULL
	    || strncasecmp(entry->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
	return;
    }
    if (entry->next_by_base != NULL) {
	p = entry->next_by_base;
	if (strncasecmp(p->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
	    /* next is not free */
	} else if (entry->data->dpme_pblock_start + entry->data->dpme_pblocks
		!= p->data->dpme_pblock_start) {
	    /* next is not contiguous (XXX this is bad) */
	    printf("next entry is not contiguous\n");
	    /* start is already minimum */
	    /* new end is maximum of two ends */
	    end = p->data->dpme_pblock_start + p->data->dpme_pblocks;
	    if (end > entry->data->dpme_pblock_start + entry->data->dpme_pblocks) {
		entry->data->dpme_pblocks = end - entry->data->dpme_pblock_start;
	    }
	    entry->data->dpme_lblocks = entry->data->dpme_pblocks;
	    delete_entry(p);
	} else {
	    entry->data->dpme_pblocks += p->data->dpme_pblocks;
	    entry->data->dpme_lblocks = entry->data->dpme_pblocks;
	    delete_entry(p);
	}
    }
    if (entry->prev_by_base != NULL) {
	p = entry->prev_by_base;
	if (strncasecmp(p->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
	    /* previous is not free */
	} else if (p->data->dpme_pblock_start + p->data->dpme_pblocks
		!= entry->data->dpme_pblock_start) {
	    /* previous is not contiguous (XXX this is bad) */
	    printf("previous entry is not contiguous\n");
	    /* new end is maximum of two ends */
	    end = p->data->dpme_pblock_start + p->data->dpme_pblocks;
	    if (end < entry->data->dpme_pblock_start + entry->data->dpme_pblocks) {
		end = entry->data->dpme_pblock_start + entry->data->dpme_pblocks;
	    }
	    entry->data->dpme_pblocks = end - p->data->dpme_pblock_start;
	    /* new start is previous entry's start */
	    entry->data->dpme_pblock_start = p->data->dpme_pblock_start;
	    entry->data->dpme_lblocks = entry->data->dpme_pblocks;
	    delete_entry(p);
	} else {
	    entry->data->dpme_pblock_start = p->data->dpme_pblock_start;
	    entry->data->dpme_pblocks += p->data->dpme_pblocks;
	    entry->data->dpme_lblocks = entry->data->dpme_pblocks;
	    delete_entry(p);
d868 1
a868 2
    }
    entry->contains_driver = contains_driver(entry);
d873 1
a873 1
delete_entry(struct partition_map *entry)
d875 2
a876 2
    struct partition_map_header *map;
    struct partition_map *p;
d878 2
a879 2
    map = entry->the_map;
    map->blocks_in_map--;
d881 1
a881 12
    remove_from_disk_order(entry);

    p = entry->next_by_base;
    if (map->base_order == entry) {
	map->base_order = p;
    }
    if (p != NULL) {
	p->prev_by_base = entry->prev_by_base;
    }
    if (entry->prev_by_base != NULL) {
	entry->prev_by_base->next_by_base = p;
    }
d883 12
a894 2
    free(entry->data);
    free(entry);
d899 1
a899 1
find_entry_by_disk_address(long ix, struct partition_map_header *map)
d901 1
a901 1
    struct partition_map * cur;
d903 8
a910 8
    cur = map->disk_order;
    while (cur != NULL) {
	if (cur->disk_address == ix) {
	    break;
	}
	cur = cur->next_on_disk;
    }
    return cur;
d915 1
a915 1
find_entry_by_type(const char *type_name, struct partition_map_header *map)
d917 1
a917 1
    struct partition_map * cur;
d919 9
a927 8
    cur = map->base_order;
    while (cur != NULL) {
	if (strncasecmp(cur->data->dpme_type, type_name, DPISTRLEN) == 0) {
	    break;
	}
	cur = cur->next_by_base;
    }
    return cur;
d931 1
a931 1
find_entry_by_base(uint32_t base, struct partition_map_header *map)
d933 1
a933 1
    struct partition_map * cur;
d935 8
a942 8
    cur = map->base_order;
    while (cur != NULL) {
	if (cur->data->dpme_pblock_start == base) {
	    break;
	}
	cur = cur->next_by_base;
    }
    return cur;
d947 1
a947 1
move_entry_in_map(long old_index, long ix, struct partition_map_header *map)
d949 1
a949 1
    struct partition_map * cur;
d951 10
a960 10
    cur = find_entry_by_disk_address(old_index, map);
    if (cur == NULL) {
	printf("No such partition\n");
    } else {
	remove_from_disk_order(cur);
	cur->disk_address = ix;
	insert_in_disk_order(cur);
	renumber_disk_addresses(map);
	map->changed = 1;
    }
d965 1
a965 1
remove_from_disk_order(struct partition_map *entry)
d967 2
a968 2
    struct partition_map_header *map;
    struct partition_map *p;
d970 13
a982 13
    map = entry->the_map;
    p = entry->next_on_disk;
    if (map->disk_order == entry) {
	map->disk_order = p;
    }
    if (p != NULL) {
	p->prev_on_disk = entry->prev_on_disk;
    }
    if (entry->prev_on_disk != NULL) {
	entry->prev_on_disk->next_on_disk = p;
    }
    entry->next_on_disk = NULL;
    entry->prev_on_disk = NULL;
d987 1
a987 1
insert_in_disk_order(struct partition_map *entry)
d989 2
a990 2
    struct partition_map_header *map;
    struct partition_map * cur;
d992 26
a1017 20
    /* find position in disk list & insert */
    map = entry->the_map;
    cur = map->disk_order;
    if (cur == NULL || entry->disk_address <= cur->disk_address) {
	map->disk_order = entry;
	entry->next_on_disk = cur;
	if (cur != NULL) {
	    cur->prev_on_disk = entry;
	}
	entry->prev_on_disk = NULL;
    } else {
	for (cur = map->disk_order; cur != NULL; cur = cur->next_on_disk) {
	    if (cur->disk_address <= entry->disk_address
		    && (cur->next_on_disk == NULL
		    || entry->disk_address <= cur->next_on_disk->disk_address)) {
		entry->next_on_disk = cur->next_on_disk;
		cur->next_on_disk = entry;
		entry->prev_on_disk = cur;
		if (entry->next_on_disk != NULL) {
		    entry->next_on_disk->prev_on_disk = entry;
a1018 2
		break;
	    }
a1019 1
    }
d1024 1
a1024 1
insert_in_base_order(struct partition_map *entry)
d1026 2
a1027 2
    struct partition_map_header *map;
    struct partition_map * cur;
d1029 28
a1056 22
    /* find position in base list & insert */
    map = entry->the_map;
    cur = map->base_order;
    if (cur == NULL
	    || entry->data->dpme_pblock_start <= cur->data->dpme_pblock_start) {
	map->base_order = entry;
	entry->next_by_base = cur;
	if (cur != NULL) {
	    cur->prev_by_base = entry;
	}
	entry->prev_by_base = NULL;
    } else {
	for (cur = map->base_order; cur != NULL; cur = cur->next_by_base) {
	    if (cur->data->dpme_pblock_start <= entry->data->dpme_pblock_start
		    && (cur->next_by_base == NULL
		    || entry->data->dpme_pblock_start
			<= cur->next_by_base->data->dpme_pblock_start)) {
		entry->next_by_base = cur->next_by_base;
		cur->next_by_base = entry;
		entry->prev_by_base = cur;
		if (entry->next_by_base != NULL) {
		    entry->next_by_base->prev_by_base = entry;
a1057 2
		break;
	    }
a1058 1
    }
d1063 1
a1063 1
resize_map(long new_size, struct partition_map_header *map)
d1065 5
a1069 15
    struct partition_map * entry;
    struct partition_map * next;
    int incr;

    entry = find_entry_by_type(kMapType, map);

    if (entry == NULL) {
	printf("Couldn't find entry for map!\n");
	return;
    }
    next = entry->next_by_base;

    if (new_size == entry->data->dpme_pblocks) {
	return;
    }
d1071 9
d1081 15
a1095 1
    if (new_size < entry->data->dpme_pblocks) {
d1098 7
a1104 3
	    incr = 1;
	} else {
	    incr = 0;
d1106 3
a1108 3
	if (new_size < map->blocks_in_map + incr) {
	    printf("New size would be too small\n");
	    return;
a1109 18
	goto doit;
    }

	/* make it larger */
    if (next == NULL ||
	strncasecmp(next->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
	printf("No free space to expand into\n");
	return;
    }
    if (entry->data->dpme_pblock_start + entry->data->dpme_pblocks
	    != next->data->dpme_pblock_start) {
	printf("No contiguous free space to expand into\n");
	return;
    }
    if (new_size > entry->data->dpme_pblocks + next->data->dpme_pblocks) {
	printf("No enough free space\n");
	return;
    }
d1111 4
a1114 4
    entry->data->dpme_type[0] = 0;
    delete_partition_from_map(entry);
    add_partition_to_map("Apple", kMapType, 1, new_size, map);
    map->maximum_in_map = new_size;
d1119 1
a1119 1
remove_driver(struct partition_map *entry)
d1121 56
a1176 49
    struct partition_map_header *map;
    struct block0 *p;
    struct ddmap *m;
    int i;
    int j;
    int f;
    uint32_t start;

    map = entry->the_map;
    p = map->misc;
    if (p == NULL) {
	return;
    }
    if (p->sbSig != BLOCK0_SIGNATURE) {
	return;
    }
    if (map->logical_block > p->sbBlkSize) {
	/* this is not supposed to happen, but let's just ignore it. */
	return;
    } else {
	/*
	 * compute the factor to convert the block numbers in block0
	 * into partition map block numbers.
	 */
	f = p->sbBlkSize / map->logical_block;
    }
    if (p->sbDrvrCount > 0) {
	m = (struct ddmap *) p->sbMap;
	for (i = 0; i < p->sbDrvrCount; i++) {
	    start = get_align_long(&m[i].ddBlock);

	    /* zap the driver if it is wholly contained in the partition */
	    if (entry->data->dpme_pblock_start <= f*start
		    && f*(start + m[i].ddSize)
			<= (entry->data->dpme_pblock_start
			+ entry->data->dpme_pblocks)) {
		/* delete this driver */
		/* by copying down later ones and zapping the last */
		for (j = i+1; j < p->sbDrvrCount; j++, i++) {
		   put_align_long(get_align_long(&m[j].ddBlock), &m[i].ddBlock);
		   m[i].ddSize = m[j].ddSize;
		   m[i].ddType = m[j].ddType;
		}
	        put_align_long(0, &m[i].ddBlock);
		m[i].ddSize = 0;
		m[i].ddType = 0;
		p->sbDrvrCount -= 1;
		return; /* XXX if we continue we will delete other drivers? */
	    }
a1177 1
    }
d1181 1
a1181 1
read_block(struct partition_map_header *map, unsigned long num, char *buf)
d1183 2
a1184 2
    return read_file_media(map->m, ((long long) num) * map->logical_block,
		DEV_BSIZE, (void *)buf);
d1189 1
a1189 1
write_block(struct partition_map_header *map, unsigned long num, char *buf)
d1191 2
a1192 2
    return write_file_media(map->m, ((long long) num) * map->logical_block,
		DEV_BSIZE, (void *)buf);
@


1.36
log
@Change "//" comments to "/**/". Nuke really stupid ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.35 2016/01/17 19:39:20 krw Exp $	*/
a736 1
    entry->HFS_kind = kHFS_not;
@


1.35
log
@Reduce namespace pollution by eliminating parameter names from forward
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.34 2016/01/17 19:15:55 krw Exp $	*/
d3 5
a7 5
//
// partition_map.c - partition map routines
//
// Written by Eryk Vershen
//
a132 1
	// if I can't read block 0 I might as well give up
a137 1
    //printf("physical block size is %d\n", map->physical_block);
d153 1
a153 1
	// some sort of failure reading the map
d155 1
a155 2
	// got it!
	;
a193 2
//printf("called read_partition_map\n");
//printf("logical = %d, physical = %d\n", map->logical_block, map->physical_block);
a226 1
//printf("logical = %d, physical = %d\n", map->logical_block, map->physical_block);
a306 1
//printf("add data %d to map\n", ix);
a395 1
    // printf("block size is %d\n", map->physical_block);
a414 1
	// got it!
a421 1
	    // set data into entry
d466 1
a466 1
    return 0;	// we do this simply to make it easier to call this function
d483 1
a483 1
	// find a block that starts includes base and length
d491 1
a491 1
	  // check if request is past end of existing partitions, but on disk
d494 1
a494 1
	    // Expand final free partition
d501 1
a501 1
	    // create an extra free partition
d525 1
a525 1
	// if it is not Extra then punt
d532 1
a532 1
	// figure out what to do and sizes
d535 1
a535 1
	// replace or add
d544 1
a544 1
	// split or add
d557 1
a557 1
	// if the map will overflow then punt
d576 1
a576 1
	    // adjust this block's size
d580 1
a580 1
	    // insert new with block address equal to this one
d586 1
a586 1
		    // insert new with block address equal to this one
a592 1
	// renumber disk addresses
a593 1
	// mark changed
a607 1
	// set data into entry
d640 1
a640 1
	// reset disk addresses
d714 1
a714 1
    // if past end of disk, delete it completely
d718 1
a718 1
	remove_driver(entry);	// update block0 if necessary
d723 1
a723 1
    // If at end of disk, incorporate extra disk space to partition
d734 1
a734 1
	remove_driver(entry);	// update block0 if necessary
d798 1
a798 1
	    // next is not free
d801 1
a801 1
	    // next is not contiguous (XXX this is bad)
d803 2
a804 2
	    // start is already minimum
	    // new end is maximum of two ends
d820 1
a820 1
	    // previous is not free
d823 1
a823 1
	    // previous is not contiguous (XXX this is bad)
d825 1
a825 1
	    // new end is maximum of two ends
d831 1
a831 1
	    // new start is previous entry's start
d966 1
a966 1
    // find position in disk list & insert
d1000 1
a1000 1
    // find position in base list & insert
a1036 1
    // find map entry
a1044 1
	// same size
a1045 1
	// do nothing
d1049 1
a1049 1
	// make it smaller
d1064 1
a1064 1
	// make it larger
d1126 2
a1127 2
		// delete this driver
		// by copying down later ones and zapping the last
a1145 1
//printf("read block %d\n", num);
@


1.34
log
@Kill leading, imbedded, trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.33 2016/01/17 18:57:52 krw Exp $	*/
d71 15
a85 15
int coerce_block0(struct partition_map_header *map);
int contains_driver(struct partition_map *entry);
void combine_entry(struct partition_map *entry);
long compute_device_size(char *name);
struct dpme* create_data(const char *name, const char *dptype, uint32_t base, uint32_t length);
void delete_entry(struct partition_map *entry);
void insert_in_base_order(struct partition_map *entry);
void insert_in_disk_order(struct partition_map *entry);
int read_block(struct partition_map_header *map, unsigned long num, char *buf);
int read_partition_map(struct partition_map_header *map);
void remove_driver(struct partition_map *entry);
void remove_from_disk_order(struct partition_map *entry);
void renumber_disk_addresses(struct partition_map_header *map);
void sync_device_size(struct partition_map_header *map);
int write_block(struct partition_map_header *map, unsigned long num, char *buf);
@


1.33
log
@Remove a bunch of ridiculous and uninformative comments like "// Defines".
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.32 2016/01/17 18:44:59 krw Exp $	*/
d747 1
a747 1
    	remove_driver(entry);	// update block0 if necessary
d820 1
a820 1
	    	entry->data->dpme_pblocks = end - entry->data->dpme_pblock_start;
d1164 1
a1164 1
    		DEV_BSIZE, (void *)buf);
d1172 1
a1172 1
    		DEV_BSIZE, (void *)buf);
@


1.32
log
@The great de-typedef'ification concludes with u32 -> uint32_t. And a
bunch of consequent printf() format corrections.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.31 2016/01/17 17:44:05 krw Exp $	*/
a40 1
// for *printf()
a41 2

// for malloc(), calloc() & free()
a42 2

// for strncpy() & strcmp()
a43 1
// for O_RDONLY & O_RDWR
a44 1
// for errno
a51 4

//
// Defines
//
a54 6
// #define TEST_COMPUTE


//
// Types
//
a55 4

//
// Global Constants
//
a69 3
//
// Forward declarations
//
a86 4

//
// Routines
//
@


1.31
log
@The great de-typedef'ification continues.

partition_map -> struct partition_map
partition_map_header -> struct partition_map_header
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.30 2016/01/17 16:26:26 krw Exp $	*/
d99 1
a99 1
struct dpme* create_data(const char *name, const char *dptype, u32 base, u32 length);
d220 1
a220 1
    u32 limit;
d509 1
a509 1
add_partition_to_map(const char *name, const char *dptype, u32 base, u32 length,
d516 4
a519 4
    u32 adjusted_base = 0;
    u32 adjusted_length = 0;
    u32 new_base = 0;
    u32 new_length = 0;
d640 1
a640 1
create_data(const char *name, const char *dptype, u32 base, u32 length)
d795 1
a795 1
    u32 start;
d830 1
a830 1
    u32 end;
d946 1
a946 1
find_entry_by_base(u32 base, struct partition_map_header *map)
d1140 1
a1140 1
    u32 start;
@


1.30
log
@The great de-typedef'ification continues. DDMap -> struct ddmap.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.29 2016/01/17 16:15:59 krw Exp $	*/
d94 4
a97 4
int add_data_to_map(struct dpme *, long, partition_map_header *);
int coerce_block0(partition_map_header *map);
int contains_driver(partition_map *entry);
void combine_entry(partition_map *entry);
d100 10
a109 10
void delete_entry(partition_map *entry);
void insert_in_base_order(partition_map *entry);
void insert_in_disk_order(partition_map *entry);
int read_block(partition_map_header *map, unsigned long num, char *buf);
int read_partition_map(partition_map_header *map);
void remove_driver(partition_map *entry);
void remove_from_disk_order(partition_map *entry);
void renumber_disk_addresses(partition_map_header *map);
void sync_device_size(partition_map_header *map);
int write_block(partition_map_header *map, unsigned long num, char *buf);
d115 1
a115 1
partition_map_header *
d119 1
a119 1
    partition_map_header * map;
d137 1
a137 1
    map = malloc(sizeof(partition_map_header));
d195 1
a195 1
close_partition_map(partition_map_header *map)
d197 2
a198 2
    partition_map * entry;
    partition_map * next;
d217 1
a217 1
read_partition_map(partition_map_header *map)
d299 1
a299 1
write_partition_map(partition_map_header *map)
d303 1
a303 1
    partition_map * entry;
d337 1
a337 1
add_data_to_map(struct dpme *data, long ix, partition_map_header *map)
d339 1
a339 1
    partition_map *entry;
d342 1
a342 1
    entry = malloc(sizeof(partition_map));
d370 2
a371 2
partition_map_header *
init_partition_map(char *name, partition_map_header* oldmap)
d373 1
a373 1
    partition_map_header *map;
d394 2
a395 2
partition_map_header *
create_partition_map(char *name, partition_map_header *oldmap)
d398 1
a398 1
    partition_map_header * map;
d409 1
a409 1
    map = malloc(sizeof(partition_map_header));
d483 1
a483 1
coerce_block0(partition_map_header *map)
d510 1
a510 1
	partition_map_header *map)
d512 1
a512 1
    partition_map * cur;
d676 1
a676 1
renumber_disk_addresses(partition_map_header *map)
d678 1
a678 1
    partition_map * cur;
d721 1
a721 1
sync_device_size(partition_map_header *map)
d740 1
a740 1
delete_partition_from_map(partition_map *entry)
d742 1
a742 1
    partition_map_header *map;
d788 1
a788 1
contains_driver(partition_map *entry)
d790 1
a790 1
    partition_map_header *map;
d827 1
a827 1
combine_entry(partition_map *entry)
d829 1
a829 1
    partition_map *p;
d888 1
a888 1
delete_entry(partition_map *entry)
d890 2
a891 2
    partition_map_header *map;
    partition_map *p;
d914 2
a915 2
partition_map *
find_entry_by_disk_address(long ix, partition_map_header *map)
d917 1
a917 1
    partition_map * cur;
d930 2
a931 2
partition_map *
find_entry_by_type(const char *type_name, partition_map_header *map)
d933 1
a933 1
    partition_map * cur;
d945 2
a946 2
partition_map *
find_entry_by_base(u32 base, partition_map_header *map)
d948 1
a948 1
    partition_map * cur;
d962 1
a962 1
move_entry_in_map(long old_index, long ix, partition_map_header *map)
d964 1
a964 1
    partition_map * cur;
d980 1
a980 1
remove_from_disk_order(partition_map *entry)
d982 2
a983 2
    partition_map_header *map;
    partition_map *p;
d1002 1
a1002 1
insert_in_disk_order(partition_map *entry)
d1004 2
a1005 2
    partition_map_header *map;
    partition_map * cur;
d1036 1
a1036 1
insert_in_base_order(partition_map *entry)
d1038 2
a1039 2
    partition_map_header *map;
    partition_map * cur;
d1072 1
a1072 1
resize_map(long new_size, partition_map_header *map)
d1074 2
a1075 2
    partition_map * entry;
    partition_map * next;
d1132 1
a1132 1
remove_driver(partition_map *entry)
d1134 1
a1134 1
    partition_map_header *map;
d1188 1
a1188 1
read_block(partition_map_header *map, unsigned long num, char *buf)
d1197 1
a1197 1
write_block(partition_map_header *map, unsigned long num, char *buf)
@


1.29
log
@The great de-typedef'ification continues. Block0 -> struct block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.28 2016/01/17 16:07:06 krw Exp $	*/
d792 1
a792 1
    DDMap *m;
d811 1
a811 1
	m = (DDMap *) p->sbMap;
d1136 1
a1136 1
    DDMap *m;
d1161 1
a1161 1
	m = (DDMap *) p->sbMap;
@


1.28
log
@The great de-typedef'ification continues. DPME -> struct dpme.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.27 2016/01/17 15:57:12 krw Exp $	*/
d485 1
a485 1
    Block0 *p;
d723 1
a723 1
    Block0 *p;
d791 1
a791 1
    Block0 *p;
d1135 1
a1135 1
    Block0 *p;
@


1.27
log
@Let the great de-typedef'ification begin. MEDIA -> struct file_media *.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.26 2016/01/17 14:28:25 krw Exp $	*/
d99 1
a99 1
DPME* create_data(const char *name, const char *dptype, u32 base, u32 length);
d219 1
a219 1
    DPME *data;
d399 1
a399 1
    DPME *data;
d513 1
a513 1
    DPME *data;
d639 1
a639 1
DPME *
d642 1
a642 1
    DPME *data;
d663 1
a663 1
dpme_init_flags(DPME *data)
d743 1
a743 1
    DPME *data;
@


1.26
log
@A/UX is no more, was m68k only, and we have no sentimental reasons for
keeping support.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.25 2016/01/17 14:13:42 jasper Exp $	*/
d118 1
a118 1
    FILE_MEDIA m;
d301 1
a301 1
    FILE_MEDIA m;
d397 1
a397 1
    FILE_MEDIA m;
@


1.25
log
@- tidy up a bunch of #if's for code that has been either enabled or disabled since forever,
  or not relevant at all (e.g. some bits for A/UX support)
- remove commented code that has never been compiled, etc

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.24 2016/01/16 22:28:14 krw Exp $	*/
a674 43
/* These bits are appropriate for Apple_UNIX_SVR2 partitions
 * used by OpenBSD.  They may be ok for A/UX, but have not been
 * tested.
 */
void
bzb_init_slice(BZB *bp, int slice)
{
    memset(bp,0,sizeof(BZB));
    if ((slice >= 'A') && (slice <= 'Z')) {
	slice += 'a' - 'A';
    }
    if ((slice != 0) && ((slice < 'a') || (slice > 'z'))) {
	warnx("Bad bzb slice");
	slice = 0;
    }
    switch (slice) {
    case 0:
    case 'c':
	return;
    case 'a':
	bp->bzb_type = FST;
	strlcpy(bp->bzb_mount_point, "/", sizeof(bp->bzb_mount_point));
	bp->bzb_inode = 1;
	bp->bzb_flags = BZB_ROOT | BZB_USR;
	break;
    case 'b':
	bp->bzb_type = FSTSFS;
	strlcpy(bp->bzb_mount_point, "(swap)", sizeof(bp->bzb_mount_point));
	break;
    case 'g':
	strlcpy(bp->bzb_mount_point, "/usr", sizeof(bp->bzb_mount_point));
	/* Fall through */
    default:
	bp->bzb_type = FST;
	bp->bzb_inode = 1;
	bp->bzb_flags = BZB_USR;
	break;
    }
    // XXX OpenBSD disksubr.c ignores slice
    //	bp->bzb_flags |= (slice-'a'+1) << BZB_SLICE_SHIFT;
    bp->bzb_magic = BZBMAGIC;
}

a689 1

@


1.24
log
@Move last field (size_in_bytes) in struct media to struct file_media
and replace MEDIA with FILE_MEDIA everywhere. media.h becomes unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.23 2016/01/16 21:41:41 krw Exp $	*/
d438 1
a438 5
#if 0
    if (size > map->physical_block) {
	size = map->physical_block;
    }
#endif
@


1.23
log
@There can be only one. 'grain' that is. i.e. DEV_BSIZE. No need to track
or store. Just use.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.22 2016/01/16 20:00:50 krw Exp $	*/
d118 1
a118 1
    MEDIA m;
d301 1
a301 1
    MEDIA m;
d397 1
a397 1
    MEDIA m;
@


1.22
log
@Start peeling away excess layers of abstraction.

Since 'file' is the only kind of media, no need to call the appropriate
functions via pointers. Just call the _file_ variants directly.
Nuke the fields do_read(), do_write(), do_close(), do_os_reload()
and the functions read_media(), write_media(), close_media() and
os_reload_media().

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.21 2016/01/16 14:49:28 krw Exp $	*/
d150 1
a150 1
    map->physical_block = media_granularity(m);	/* preflight */
d424 1
a424 1
	size = media_granularity(m);
@


1.21
log
@Nuke support for 1024- and 2048-byte sector devices. Error out if
anything other than 512-byte sectors are encountered. Unlink
deblock_media.c from the build.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.20 2016/01/15 23:05:00 krw Exp $	*/
d140 1
a140 1
	close_media(m);
d155 1
a155 1
	close_media(map->m);
d158 1
a158 1
    } else if (read_media(map->m, (long long) 0, DEV_BSIZE, (char *)map->misc) == 0
d211 1
a211 1
    close_media(map->m);
d332 1
a332 1
    os_reload_media(map->m);
d412 1
a412 1
	close_media(m);
d1239 1
a1239 1
    return read_media(map->m, ((long long) num) * map->logical_block,
d1247 1
a1247 1
    return write_media(map->m, ((long long) num) * map->logical_block,
@


1.20
log
@We don't need yet another alias for DEV_BSIZE. Use DEV_BSIZE and
nuke PBLOCK_SIZE and another unused #define.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.19 2016/01/15 16:39:20 krw Exp $	*/
a54 1
#include "deblock_media.h"
a150 1
    m = open_deblock_media(DEV_BSIZE, m);
a425 1
    m = open_deblock_media(DEV_BSIZE, m);
@


1.19
log
@Replace bitfield_get() and bitfield_set() abstraction with simple masking
operations since all the uses but 1 are for 1 bit fields. No functional
change intended.

Unhook bitfield.c from build.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.18 2016/01/14 04:22:25 krw Exp $	*/
d30 1
a30 1
#include <sys/types.h>
d152 1
a152 1
    m = open_deblock_media(PBLOCK_SIZE, m);
d154 1
a154 1
    map->misc = malloc(PBLOCK_SIZE);
d160 1
a160 1
    } else if (read_media(map->m, (long long) 0, PBLOCK_SIZE, (char *)map->misc) == 0
d171 1
a171 1
    map->logical_block = PBLOCK_SIZE;
d229 1
a229 1
    data = malloc(PBLOCK_SIZE);
d278 1
a278 1
	data = malloc(PBLOCK_SIZE);
d315 1
a315 1
	block = calloc(1, PBLOCK_SIZE);
d428 1
a428 1
    m = open_deblock_media(PBLOCK_SIZE, m);
d439 1
a439 1
	size = PBLOCK_SIZE;
d454 1
a454 1
    map->misc = calloc(1, PBLOCK_SIZE);
d462 1
a462 1
	data = calloc(1, PBLOCK_SIZE);
d501 1
a501 1
	    p->sbBlkSize = PBLOCK_SIZE;
d651 1
a651 1
    data = calloc(1, PBLOCK_SIZE);
d1243 1
a1243 1
    		PBLOCK_SIZE, (void *)buf);
d1251 1
a1251 1
    		PBLOCK_SIZE, (void *)buf);
@


1.18
log
@Don't include hfs_misc.h, which no longer contains anything of use.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.17 2016/01/14 04:17:40 krw Exp $	*/
d475 1
a475 6
	    dpme_writable_set(data, 1);
	    dpme_readable_set(data, 1);
	    dpme_bootable_set(data, 0);
	    dpme_in_use_set(data, 0);
	    dpme_allocated_set(data, 0);
	    dpme_valid_set(data, 1);
d677 2
a678 6
	dpme_writable_set(data, 1);
	dpme_readable_set(data, 1);
	dpme_bootable_set(data, 0);
	dpme_in_use_set(data, 0);
	dpme_allocated_set(data, 1);
	dpme_valid_set(data, 1);
d705 1
a705 2
	bzb_root_set(bp,1);
	bzb_usr_set(bp,1);
d717 1
a717 1
	bzb_usr_set(bp,1);
d720 2
a721 2
    bzb_slice_set(bp,0);  // XXX OpenBSD disksubr.c ignores slice
    //	bzb_slice_set(bp,slice-'a'+1);
@


1.17
log
@Nuke 'HFS_name' field which was not referenced now other than setting
it and freeing it. Unhook hfs_misc.c from build since it now longer
contains anything being used.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.16 2016/01/12 20:09:39 krw Exp $	*/
a54 1
#include "hfs_misc.h"
@


1.16
log
@Use normal err/errx/warn/warnx rather than handrolling new ones. Move
usage() to pdisk.c and nuke do_help() and '-h'.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.15 2016/01/12 15:32:08 krw Exp $	*/
a102 1
char *get_HFS_name(partition_map *entry, int *kind);
a211 1
	free(entry->HFS_name);
a357 1
    entry->HFS_name = get_HFS_name(entry, &entry->HFS_kind);
a839 1
    free(entry->HFS_name);
a840 1
    entry->HFS_name = 0;
a971 1
    free(entry->HFS_name);
@


1.15
log
@Retire '-i', a poorly documented interactive mode that tries to
mimic the 20th century MacOS version of pdisk more closely than the
usual interactive editor. One set of commands is enough for anyone.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.14 2016/01/12 01:17:41 krw Exp $	*/
a58 1
#include "errors.h"
d129 1
a129 1
	    error(errno, "can't open file '%s'", name);
d142 1
a142 1
	error(errno, "can't allocate memory for open partition map");
d158 1
a158 1
	error(errno, "can't allocate memory for block zero buffer");
d166 1
a166 1
	error(-1, "Can't read block 0 from '%s'", name);
d234 1
a234 1
	error(errno, "can't allocate memory for disk buffers");
d239 1
a239 1
	error(-1, "Can't read block 1 from '%s'", map->name);
d248 1
a248 1
		error(-1, "Can't read block 1 from '%s'", map->name);
d260 1
a260 1
	    error(-1, "No valid block 1 on '%s'", map->name);
d283 1
a283 1
	    error(errno, "can't allocate memory for disk buffers");
d288 1
a288 1
	    error(-1, "Can't read block %u from '%s'", ix, map->name);
d294 1
a294 1
	    error(-1, "Bad data in block %u from '%s'", ix, map->name);
d325 1
a325 1
	error(errno, "Unable to write block zero");
d333 1
a333 1
	    error(errno, "Unable to write block %d", i);
d349 1
a349 1
	error(errno, "can't allocate memory for map entries");
d411 1
a411 2
	error(errno, "can't open file '%s' for %sing", name,
		(rflag)?"read":"writ");
d417 1
a417 1
	error(errno, "can't allocate memory for open partition map");
d460 1
a460 1
	error(errno, "can't allocate memory for block zero buffer");
d468 1
a468 1
	    error(errno, "can't allocate memory for disk buffers");
d662 1
a662 1
	error(errno, "can't allocate memory for disk buffers");
d707 1
a707 1
	error(-1,"Bad bzb slice");
d766 1
a766 1
		error(errno, "can't open %s", name);
@


1.14
log
@Since we use the disklabel size info we are always in 'device size
mode' and '-c' and the '-d' command to toggle cflag are pointless
since cflag is never examined.
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.13 2016/01/11 23:31:27 krw Exp $	*/
d120 1
a120 1
open_partition_map(char *name, int *valid_file, int ask_logical_size)
a124 1
    long size;
d174 2
a175 14
    if (ask_logical_size && interactive) {
	size = PBLOCK_SIZE;
	printf("A logical block is %ld bytes: ", size);
	flush_to_newline(0);
	get_number_argument("what should be the logical block size? ",
		&size, size);
	size = (size / PBLOCK_SIZE) * PBLOCK_SIZE;
	if (size < PBLOCK_SIZE) {
	    size = PBLOCK_SIZE;
	}
	map->logical_block = size;
    } else {
	map->logical_block = PBLOCK_SIZE;
    }
a337 3
    if (interactive)
	printf("The partition table has been altered!\n\n");

a406 1
    unsigned long default_number;
a408 1
    unsigned long multiple;
a435 10
    if (interactive) {
	printf("A physical block is %ld bytes: ", size);
	flush_to_newline(0);
	get_number_argument("what should be the physical block size? ",
		&size, size);
	size = (size / PBLOCK_SIZE) * PBLOCK_SIZE;
	if (size < PBLOCK_SIZE) {
	    size = PBLOCK_SIZE;
	}
    }
a446 10
    if (interactive) {
	printf("A logical block is %ld bytes: ", size);
	flush_to_newline(0);
	get_number_argument("what should be the logical block size? ",
		&size, size);
	size = (size / PBLOCK_SIZE) * PBLOCK_SIZE;
	if (size < PBLOCK_SIZE) {
	    size = PBLOCK_SIZE;
	}
    }
a457 34
    if (interactive) {
	printf("size of 'device' is %lu blocks (%d byte blocks): ",
		number, map->logical_block);
	default_number = number;
	flush_to_newline(0);
	do {
	    if (get_number_argument("what should be the size? ",
		    (long *)&number, default_number) == 0) {
		printf("Not a number\n");
		flush_to_newline(1);
		number = 0;
	    } else {
		multiple = get_multiplier(map->logical_block);
		if (multiple == 0) {
		    printf("Bad multiplier\n");
		    number = 0;
		} else if (multiple != 1) {
		    if (0xFFFFFFFF/multiple < number) {
			printf("Number too large\n");
			number = 0;
		    } else {
			number *= multiple;
		    }
		}
	    }
	    default_number = kDefault;
	} while (number == 0);

	if (number < 4) {
	    number = 4;
	}
	printf("new size of 'device' is %lu blocks (%d byte blocks)\n",
		number, map->logical_block);
    }
@


1.13
log
@open_pathname_as_media() simply called open_file_as_media() which
takes the same parameters and returns the same value. Nuke
open_pathname_as_media() and call open_file_as_media() directly.

Nothing else from pathname.[ch] is used so remove them from build
in preparation for moving them to the attic.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.12 2016/01/11 18:43:06 krw Exp $	*/
a92 6

//
// Global Variables
//
extern int cflag;

@


1.12
log
@Remove '-v' and related version handling. Use strncasecmp() instead
of handrolled local istrncmp(). No need to compile util.c anymore.

ok deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.11 2016/01/11 07:57:54 jasper Exp $	*/
a54 1
#include "pathname.h"
d60 1
d133 1
a133 1
    m = open_pathname_as_media(name, (rflag)?O_RDONLY:O_RDWR);
d135 1
a135 1
	m = open_pathname_as_media(name, O_RDONLY);
d434 1
a434 1
    m = open_pathname_as_media(name, (rflag)?O_RDONLY:O_RDWR);
@


1.11
log
@trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: partition_map.c,v 1.10 2016/01/11 07:54:07 jasper Exp $	*/
a59 1
#include "util.h"
d390 1
a390 1
	if (istrncmp(data->dpme_type, kMapType, DPISTRLEN) == 0) {
d629 2
a630 2
	    if ((istrncmp(cur->data->dpme_type, kFreeType, DPISTRLEN) == 0) &&
		base >= cur->data->dpme_pblock_start) {
d661 1
a661 1
	    || istrncmp(cur->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d761 2
a762 1
    if (istrncmp(data->dpme_type, kHFSType, DPISTRLEN) == 0) { /* XXX this is gross, fix it! */
d890 1
a890 1
    if (istrncmp(entry->data->dpme_type, kMapType, DPISTRLEN) == 0) {
d980 1
a980 1
	    || istrncmp(entry->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d985 1
a985 1
	if (istrncmp(p->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d1007 1
a1007 1
	if (istrncmp(p->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d1085 1
a1085 1
	if (istrncmp(cur->data->dpme_type, type_name, DPISTRLEN) == 0) {
d1243 2
a1244 2
	if (next == NULL
		|| istrncmp(next->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
d1257 2
a1258 2
    if (next == NULL
	    || istrncmp(next->data->dpme_type, kFreeType, DPISTRLEN) != 0) {
@


1.10
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d546 1
a546 1
	
@


1.9
log
@Use the normal method for determining a disk size. i.e. use the
device's default disklabel. Don't spew i/o's at the disk to find
the largest address that works, displaying many a 'read failed'
message along the way.

Problem noted by Brian Conway on bugs@@ and jasper@@.

ok jasper@@
@
text
@d1 2
@


1.8
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d28 11
d106 1
a106 1
long compute_device_size(partition_map_header *map, partition_map_header *oldmap);
d202 1
a202 1
    map->media_size = compute_device_size(map, map);
d500 1
a500 1
    number = compute_device_size(map, oldmap);
d835 1
a835 1
compute_device_size(partition_map_header *map, partition_map_header *oldmap)
d837 21
a857 100
#ifdef TEST_COMPUTE
    unsigned long length;
    struct hd_geometry geometry;
    struct stat info;
    loff_t pos;
#endif
    char* data;
    unsigned long l, r, x = 0;
    long long size;
    int valid = 0;
#ifdef TEST_COMPUTE
    int fd;

    fd = map->fd->fd;
    printf("\n");
    if (fstat(fd, &info) < 0) {
	printf("stat of device failed\n");
    } else {
	printf("stat: mode = 0%o, type=%s\n", info.st_mode,
		(S_ISREG(info.st_mode)? "Regular":
		(S_ISBLK(info.st_mode)?"Block":"Other")));
	printf("size = %d, blocks = %d\n",
		info.st_size, info.st_size/map->logical_block);
    }

    if (ioctl(fd, BLKGETSIZE, &length) < 0) {
	printf("get device size failed\n");
    } else {
	printf("BLKGETSIZE:size in blocks = %u\n", length);
    }

    if (ioctl(fd, HDIO_GETGEO, &geometry) < 0) {
	printf("get device geometry failed\n");
    } else {
	printf("HDIO_GETGEO: heads=%d, sectors=%d, cylinders=%d, start=%d,  total=%d\n",
		geometry.heads, geometry.sectors,
		geometry.cylinders, geometry.start,
		geometry.heads*geometry.sectors*geometry.cylinders);
    }

    if ((pos = llseek(fd, (loff_t)0, SEEK_END)) < 0) {
	printf("llseek to end of device failed\n");
    } else if ((pos = llseek(fd, (loff_t)0, SEEK_CUR)) < 0) {
	printf("llseek to end of device failed on second try\n");
    } else {
	printf("llseek: pos = %d, blocks=%d\n", pos, pos/map->logical_block);
    }
#endif

    if (cflag == 0 && oldmap != NULL && oldmap->misc->sbBlkCount != 0) {
	return (oldmap->misc->sbBlkCount
		* (oldmap->physical_block / map->logical_block));
    }

    size = media_total_size(map->m);
    if (size != 0) {
    	return (long)(size / map->logical_block);
    }

    // else case

    data = malloc(PBLOCK_SIZE);
    if (data == NULL) {
	error(errno, "can't allocate memory for try buffer");
	x = 0;
    } else {
	// double till off end
	l = 0;
	r = 1024;
	while (read_block(map, r, data) != 0) {
	    l = r;
	    if (r <= 1024) {
		r = r * 1024;
	    } else {
		r = r * 2;
	    }
	    if (r >= 0x80000000) {
		r = 0xFFFFFFFE;
		break;
	    }
	}
	// binary search for end
	while (l <= r) {
	    x = (r - l) / 2 + l;
	    if ((valid = read_block(map, x, data)) != 0) {
		l = x + 1;
	    } else {
		if (x > 0) {
		    r = x - 1;
		} else {
		    break;
		}
	    }
	}
	if (valid != 0) {
	    x = x + 1;
	}
	// printf("size in blocks = %d\n", x);
	free(data);
    }
d859 1
a859 1
    return x;
@


1.7
log
@remove mac68k leftovers
ok miod@@ mpi@@ deraadt@@ martin@@
@
text
@d136 1
a136 1
    map = (partition_map_header *) malloc(sizeof(partition_map_header));
d152 1
a152 1
    map->misc = (Block0 *) malloc(PBLOCK_SIZE);
d240 1
a240 1
    data = (DPME *) malloc(PBLOCK_SIZE);
d289 1
a289 1
	data = (DPME *) malloc(PBLOCK_SIZE);
d326 1
a326 1
	block = (char *) calloc(1, PBLOCK_SIZE);
d358 1
a358 1
    entry = (partition_map *) malloc(sizeof(partition_map));
d429 1
a429 1
    map = (partition_map_header *) malloc(sizeof(partition_map_header));
d526 1
a526 1
    map->misc = (Block0 *) calloc(1, PBLOCK_SIZE);
d534 1
a534 1
	data = (DPME *) calloc(1, PBLOCK_SIZE);
d728 1
a728 1
    data = (DPME *) calloc(1, PBLOCK_SIZE);
d887 1
a887 1
    data = (char *) malloc(PBLOCK_SIZE);
@


1.6
log
@With last pdisk and full functionality for mac68k now in place, start
cleaning the maze of ifdef's not relevant for us.

This round wipes most linux and/or MacOS-only bits, more to come.
@
text
@a69 3
#ifdef __m68k__
const char * kUnixType  = "Apple_UNIX_SVR2";
#else
a70 1
#endif
@


1.5
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@a31 1
#ifndef __linux__
a32 3
#else
#include <malloc.h>
#endif
a347 15

#ifdef __linux__
	// zap the block after the map (if possible) to get around a bug.
    if (map->maximum_in_map > 0 &&  i < map->maximum_in_map) {
	i += 1;
	block = (char *) malloc(PBLOCK_SIZE);
	if (block != NULL) {
	    if (read_block(map, i, block)) {
		block[0] = 0;
		write_block(map, i, block);
	    }
	    free(block);
	}
    }
#endif
@


1.4
log
@Default to A/UX partition type for OpenBSD newly created partitions on mac68k.
ok drahn@@
@
text
@d4 1
a4 1
// Written by Eryk Vershen (eryk@@apple.com)
d47 1
d99 1
a99 1
int add_data_to_map(struct dpme *data, long index, partition_map_header *map);
d106 1
d126 2
a127 2
    int writeable;
    int size;
d137 1
a137 1
	    writeable = 0;
d140 1
a140 1
	writeable = 1;
d151 1
a151 1
    map->writeable = (rflag)?0:writeable;
d153 1
d179 1
a179 1
	printf("A logical block is %d bytes: ", size);
d182 1
a182 1
		(long *)&size, size);
d229 1
d242 1
a242 1
    int index;
d284 1
a284 1
    index = 1;
d286 1
a286 1
	if (add_data_to_map(data, index, map) == 0) {
d291 1
a291 1
	if (index >= limit) {
d294 1
a294 1
	    index++;
d303 2
a304 2
	if (read_block(map, index, (char *)data) == 0) {
	    error(-1, "Can't read block %u from '%s'", index, map->name);
d310 1
a310 1
	    error(-1, "Bad data in block %u from '%s'", index, map->name);
d326 1
a326 1
    int result;
d352 2
d366 2
d376 1
a376 1
add_data_to_map(struct dpme *data, long index, partition_map_header *map)
d380 1
a380 1
//printf("add data %d to map\n", index);
d390 1
a390 1
    entry->disk_address = index;
d394 1
d442 1
a442 1
    int size;
d459 1
a459 1
    map->writeable = (rflag)?0:1;
d472 1
a472 1
	printf("A physical block is %d bytes: ", size);
d475 1
a475 1
		(long *)&size, size);
d493 1
a493 1
	printf("A logical block is %d bytes: ", size);
d496 1
a496 1
		(long *)&size, size);
d502 1
d506 1
d636 32
a667 1
	    cur = cur->next_by_base;
d764 1
a764 11
	if (strcmp(data->dpme_type, kHFSType) == 0) { /* XXX this is gross, fix it! */
	    data->dpme_flags = APPLE_HFS_FLAGS_VALUE;
	}
	else {
	    dpme_writable_set(data, 1);
	    dpme_readable_set(data, 1);
	    dpme_bootable_set(data, 0);
	    dpme_in_use_set(data, 0);
	    dpme_allocated_set(data, 1);
	    dpme_valid_set(data, 1);
	}
d769 59
d833 1
a833 1
    long index;
d837 1
a837 1
    index = 1;
d839 1
a839 1
	cur->disk_address = index++;
d966 1
a966 1
    size = (d * map->logical_block) / map->physical_block;
d989 14
d1012 3
d1146 1
d1152 1
a1152 1
find_entry_by_disk_address(long index, partition_map_header *map)
d1158 1
a1158 1
	if (cur->disk_address == index) {
d1182 15
d1199 1
a1199 1
move_entry_in_map(long old_index, long index, partition_map_header *map)
d1208 1
a1208 1
	cur->disk_address = index;
@


1.3
log
@rm trailing whitespace
@
text
@d73 3
d77 1
@


1.2
log
@New feature for pdisk, change the type of a parition.
Useful since that is part of the OpenBSD/macppc installation procedure.
Code by Alexander Guy,
examined by drahn@@
ok deraadt@@
@
text
@d9 17
a25 17
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
d504 1
a504 1
	    if (get_number_argument("what should be the size? ", 
d616 1
a616 1
	if (cur->data->dpme_pblock_start <= base 
d772 1
a772 1
	printf("stat: mode = 0%o, type=%s\n", info.st_mode, 
d812 1
a812 1
 
d814 1
a814 1
 
@


1.1
log
@Initial revision
@
text
@d73 1
a73 1
const char * kUnixType	= "Apple_UNIX_SVR2";
@


1.1.1.1
log
@Import of pdisk from apple, BSD licensed code. Archive dated Feb 18 1998 
This is a HFS partition editing tool.
@
text
@@
