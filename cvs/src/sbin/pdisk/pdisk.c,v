head	1.87;
access;
symbols
	OPENBSD_6_2:1.87.0.4
	OPENBSD_6_2_BASE:1.87
	OPENBSD_6_1:1.87.0.6
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.87.0.2
	OPENBSD_6_0_BASE:1.87
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.16.0.14
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.6
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.10
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.10
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.16
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.12
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	ver1:1.1.1.1
	apple19980218:1.1.1;
locks; strict;
comment	@ * @;


1.87
date	2016.05.28.22.26.13;	author tb;	state Exp;
branches;
next	1.86;
commitid	8lAMXD0we8oHKvtU;

1.86
date	2016.04.27.07.29.08;	author krw;	state Exp;
branches;
next	1.85;
commitid	SiBNOVewaqSG72PC;

1.85
date	2016.03.09.12.55.18;	author krw;	state Exp;
branches;
next	1.84;
commitid	SWFYnoNef7ocZrss;

1.84
date	2016.02.02.15.23.07;	author krw;	state Exp;
branches;
next	1.83;
commitid	BILGpkS18KvL7PGz;

1.83
date	2016.01.31.23.00.11;	author krw;	state Exp;
branches;
next	1.82;
commitid	74Rthqc3AgIVhks7;

1.82
date	2016.01.30.17.21.10;	author krw;	state Exp;
branches;
next	1.81;
commitid	BOQYiykYZJ8gnOpB;

1.81
date	2016.01.30.17.09.11;	author krw;	state Exp;
branches;
next	1.80;
commitid	ckpV9XGgFAiDBI9u;

1.80
date	2016.01.29.20.18.17;	author krw;	state Exp;
branches;
next	1.79;
commitid	JYGg5OtttidstGGH;

1.79
date	2016.01.29.14.54.38;	author krw;	state Exp;
branches;
next	1.78;
commitid	JxW4PE5GwpjH1Ttx;

1.78
date	2016.01.28.19.07.45;	author krw;	state Exp;
branches;
next	1.77;
commitid	V5tzgmz34tYP6x81;

1.77
date	2016.01.28.01.07.39;	author krw;	state Exp;
branches;
next	1.76;
commitid	6za2KPUMnp0PYP7o;

1.76
date	2016.01.27.20.11.00;	author krw;	state Exp;
branches;
next	1.75;
commitid	nG5oL7pLOwgdVHKs;

1.75
date	2016.01.27.16.38.37;	author krw;	state Exp;
branches;
next	1.74;
commitid	OxtaH45RCrnSeCna;

1.74
date	2016.01.27.14.47.53;	author krw;	state Exp;
branches;
next	1.73;
commitid	HSGGvwKIkrWkURCB;

1.73
date	2016.01.27.14.19.59;	author krw;	state Exp;
branches;
next	1.72;
commitid	EqZjPBGHnNBMYpZq;

1.72
date	2016.01.26.23.41.48;	author krw;	state Exp;
branches;
next	1.71;
commitid	RpcG9dSk73BpuL0t;

1.71
date	2016.01.26.21.07.54;	author krw;	state Exp;
branches;
next	1.70;
commitid	DW9rfkVjTw1mfuI8;

1.70
date	2016.01.26.16.39.00;	author krw;	state Exp;
branches;
next	1.69;
commitid	rZKRcHhLUVQAhJLw;

1.69
date	2016.01.25.23.43.20;	author krw;	state Exp;
branches;
next	1.68;
commitid	Qe66eD6zrMyPrXqP;

1.68
date	2016.01.25.03.26.54;	author jsg;	state Exp;
branches;
next	1.67;
commitid	9M3iLOXUEIPEiRWU;

1.67
date	2016.01.24.14.56.39;	author krw;	state Exp;
branches;
next	1.66;
commitid	KR9r7LGXUQQnnsqw;

1.66
date	2016.01.24.01.38.32;	author krw;	state Exp;
branches;
next	1.65;
commitid	g7Azk2rL78IOOfnI;

1.65
date	2016.01.23.23.25.58;	author krw;	state Exp;
branches;
next	1.64;
commitid	PPThwZCvKA3Y8sbd;

1.64
date	2016.01.23.22.55.23;	author krw;	state Exp;
branches;
next	1.63;
commitid	rtEhuagLVJKBtrm1;

1.63
date	2016.01.23.19.14.04;	author krw;	state Exp;
branches;
next	1.62;
commitid	UnZYqZjmfQe3LcFQ;

1.62
date	2016.01.23.15.05.52;	author krw;	state Exp;
branches;
next	1.61;
commitid	VImq5zcnibLGbq1Q;

1.61
date	2016.01.23.14.10.05;	author krw;	state Exp;
branches;
next	1.60;
commitid	bcC8H31SMEjEk8SE;

1.60
date	2016.01.22.18.57.42;	author krw;	state Exp;
branches;
next	1.59;
commitid	gbwjpDFPWC5oF67r;

1.59
date	2016.01.22.04.16.25;	author krw;	state Exp;
branches;
next	1.58;
commitid	e3erKRbnCu8liejZ;

1.58
date	2016.01.22.01.25.56;	author krw;	state Exp;
branches;
next	1.57;
commitid	UnRUlgKDkfeEnQQF;

1.57
date	2016.01.22.00.38.53;	author krw;	state Exp;
branches;
next	1.56;
commitid	x0tMj8kuzhFIVdU1;

1.56
date	2016.01.21.15.33.21;	author krw;	state Exp;
branches;
next	1.55;
commitid	YzEQpnBPgLX85u7F;

1.55
date	2016.01.21.02.52.52;	author krw;	state Exp;
branches;
next	1.54;
commitid	CSp7NWaeW8rVW6mR;

1.54
date	2016.01.19.23.44.47;	author krw;	state Exp;
branches;
next	1.53;
commitid	uhR2YfzDw6d44I5S;

1.53
date	2016.01.19.23.33.18;	author krw;	state Exp;
branches;
next	1.52;
commitid	NXsRbqd1cwFkwY5J;

1.52
date	2016.01.19.16.53.04;	author krw;	state Exp;
branches;
next	1.51;
commitid	GhsSvNjOAVdG5I2c;

1.51
date	2016.01.19.14.50.40;	author krw;	state Exp;
branches;
next	1.50;
commitid	YKGwNSU9QoLkwIWa;

1.50
date	2016.01.19.12.25.28;	author krw;	state Exp;
branches;
next	1.49;
commitid	gQmSX0Ydyt2IliSI;

1.49
date	2016.01.18.21.50.53;	author krw;	state Exp;
branches;
next	1.48;
commitid	iCfrmMnzqdydi4ac;

1.48
date	2016.01.18.17.57.35;	author krw;	state Exp;
branches;
next	1.47;
commitid	nIKs6pPbVKcIxae8;

1.47
date	2016.01.18.02.16.06;	author krw;	state Exp;
branches;
next	1.46;
commitid	5osriX6jUCwtHXoT;

1.46
date	2016.01.18.00.19.29;	author krw;	state Exp;
branches;
next	1.45;
commitid	Xly30kQs7l60hcTD;

1.45
date	2016.01.18.00.04.36;	author krw;	state Exp;
branches;
next	1.44;
commitid	luTmgvtH0tpvRRV4;

1.44
date	2016.01.17.23.18.19;	author krw;	state Exp;
branches;
next	1.43;
commitid	vC4VO4mr30PnBRSq;

1.43
date	2016.01.17.19.39.20;	author krw;	state Exp;
branches;
next	1.42;
commitid	slCzBfkhwAcLWsXe;

1.42
date	2016.01.17.19.15.55;	author krw;	state Exp;
branches;
next	1.41;
commitid	mHBjhdgm2kvWAkWc;

1.41
date	2016.01.17.18.57.52;	author krw;	state Exp;
branches;
next	1.40;
commitid	Rl8zxjpMi2a93hiE;

1.40
date	2016.01.17.17.44.05;	author krw;	state Exp;
branches;
next	1.39;
commitid	ie6tS8cTDeRCB9yd;

1.39
date	2016.01.17.16.15.59;	author krw;	state Exp;
branches;
next	1.38;
commitid	pxt9IRDGideJOJo6;

1.38
date	2016.01.17.16.07.06;	author krw;	state Exp;
branches;
next	1.37;
commitid	MHlLpCG6jqCnA9Ts;

1.37
date	2016.01.17.15.57.12;	author krw;	state Exp;
branches;
next	1.36;
commitid	9OUrU3poCOjYi22w;

1.36
date	2016.01.16.22.28.14;	author krw;	state Exp;
branches;
next	1.35;
commitid	IIP5iNpDONoW4Jjm;

1.35
date	2016.01.16.21.41.41;	author krw;	state Exp;
branches;
next	1.34;
commitid	N0CsQGsGtplNR8ev;

1.34
date	2016.01.16.20.00.50;	author krw;	state Exp;
branches;
next	1.33;
commitid	2koPB3ak72axl95m;

1.33
date	2016.01.15.23.05.00;	author krw;	state Exp;
branches;
next	1.32;
commitid	cXG0BedMOT1d0xiF;

1.32
date	2016.01.14.15.10.25;	author krw;	state Exp;
branches;
next	1.31;
commitid	zOToYN3jjwrKcWyv;

1.31
date	2016.01.14.04.22.25;	author krw;	state Exp;
branches;
next	1.30;
commitid	uj3XM0zkyTd99ZFd;

1.30
date	2016.01.14.04.02.05;	author krw;	state Exp;
branches;
next	1.29;
commitid	oNnNZxQ1fbZJJMcx;

1.29
date	2016.01.13.00.29.25;	author krw;	state Exp;
branches;
next	1.28;
commitid	deu37KG69oS6UN10;

1.28
date	2016.01.12.20.22.32;	author krw;	state Exp;
branches;
next	1.27;
commitid	pDCaWg7NVQgekM4j;

1.27
date	2016.01.12.20.09.39;	author krw;	state Exp;
branches;
next	1.26;
commitid	WFEddFcNLm6A2VYQ;

1.26
date	2016.01.12.15.32.08;	author krw;	state Exp;
branches;
next	1.25;
commitid	jkbr5rI0RhKaoKmr;

1.25
date	2016.01.12.01.17.41;	author krw;	state Exp;
branches;
next	1.24;
commitid	EJ9jNI5lHIDjMGKR;

1.24
date	2016.01.11.23.45.02;	author krw;	state Exp;
branches;
next	1.23;
commitid	WiKRzf6ROUEA306N;

1.23
date	2016.01.11.23.31.27;	author krw;	state Exp;
branches;
next	1.22;
commitid	1Gl5xh4AgZJGXuPl;

1.22
date	2016.01.11.18.43.06;	author krw;	state Exp;
branches;
next	1.21;
commitid	qS6fX5yqWMkDVbPr;

1.21
date	2016.01.11.08.01.07;	author jasper;	state Exp;
branches;
next	1.20;
commitid	nSo02Qki3YwCswjP;

1.20
date	2016.01.11.07.54.07;	author jasper;	state Exp;
branches;
next	1.19;
commitid	DI30r1mqHPQNkhTm;

1.19
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	82PdNqu2kKAuXPfA;

1.18
date	2015.12.06.12.00.16;	author tobias;	state Exp;
branches;
next	1.17;
commitid	CoyY8UEEpJPwBza5;

1.17
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	0qPuuXwccpVXsXcV;

1.16
date	2012.08.08.12.05.22;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.25.19.01.32;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.23.02.24.39;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.12.13.16.23;	author martin;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.11.17.20.40;	author martin;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.29.00.43.41;	author martin;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.27.19.52.21;	author martin;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.06.17.40.01;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.24.17.48.30;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.02.00.13.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.15.13.28.22;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.09.08.13.08;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.12.04.48.02;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.04.14.59.48;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.24.00.20.59;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.24.00.14.17;	author drahn;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.24.00.14.17;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Remove all the pledge "disklabel" before ioctl DIOCGPDINFO is
called in order to avoid a pledge crash with 'pdisk /dev/tty'.
Only the pledge "stdio" right after the ioctl remains.

ok krw
@
text
@/*	$OpenBSD: pdisk.c,v 1.86 2016/04/27 07:29:08 krw Exp $	*/

/*
 * pdisk - an editor for Apple format partition tables
 *
 * Written by Eryk Vershen
 *
 * Still under development (as of 15 January 1998)
 */

/*
 * Copyright 1996,1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>		/* DEV_BSIZE */
#include <sys/dkio.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "partition_map.h"
#include "io.h"
#include "dump.h"

int	lflag;	/* list the device */
int	rflag;	/* open device read Only */

static int	first_get = 1;

void	do_dump_map(struct partition_map *, int);
void	do_change_map_size(struct partition_map *);
void	do_create_partition(struct partition_map *, int);
void	do_delete_partition(struct partition_map *);
void	do_display_entry(struct partition_map *);
void	do_rename_partition(struct partition_map *);
void	do_change_type(struct partition_map *);
void	do_reorder(struct partition_map *);
void	do_write_partition_map(struct partition_map *);
void	edit(struct partition_map **);
int	get_base_argument(long *, struct partition_map *);
int	get_size_argument(long *, struct partition_map *);

__dead static void usage(void);

int
main(int argc, char **argv)
{
	struct disklabel dl;
	struct stat st;
	struct partition_map *map;
	int c, fd, oflags;

	oflags = O_RDWR;
	while ((c = getopt(argc, argv, "lr")) != -1) {
		switch (c) {
		case 'l':
			lflag = 1;
			oflags = O_RDONLY;
			break;
		case 'r':
			rflag = 1;
			oflags = O_RDONLY;
			break;
		default:
			usage();
			break;
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	fd = opendev(*argv, oflags, OPENDEV_PART, NULL);
	if (fd == -1)
		err(1, "can't open file '%s'", *argv);

	if (fstat(fd, &st) == -1)
		err(1, "can't fstat %s", *argv);
	if (!S_ISCHR(st.st_mode))
		errx(1, "%s is not a character device", *argv);

	if (ioctl(fd, DIOCGPDINFO, &dl) == -1)
		err(1, "can't get disklabel for %s", *argv);
	if (dl.d_secsize != DEV_BSIZE)
		errx(1, "disk sector size (%d) != 512\n", dl.d_secsize);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	map = open_partition_map(fd, *argv, DL_GETDSIZE(&dl), dl.d_secsize);
	if (map != NULL) {
		if (lflag)
			dump_partition_map(map);
		else
			edit(&map);
	}

	free_partition_map(map);
	close(fd);

	return 0;
}

/*
 * Edit the file
 */
void
edit(struct partition_map **mapp)
{
	struct partition_map *map = *mapp;
	struct partition_map *oldmap;
	int command;

	printf("Edit %s -\n", map->name);

	while (get_command("Command (? for help): ", first_get, &command)) {
		first_get = 0;

		switch (command) {
		case '?':
			printf("Notes:\n"
			    "  Base and length fields are blocks, which "
			    "vary in size between media.\n"
			    "  The base field can be <nth>p; i.e. the "
			    "base of the nth partition.\n"
			    "  The length field can be a length followed "
			    "by k, m, g or t to indicate\n"
			    "    kilo, mega, giga, or tera bytes.\n"
			    "  The length field can also be <nth>p; i.e. "
			    "the length of the nth partition.\n"
			    "  The name of a partition is descriptive "
			    "text.\n\n");

			/* fall through */
		case 'h':
			printf("Commands are:\n"
			    "  ?    verbose command help\n"
			    "  C    create a partition of a specified type\n"
			    "  c    create an OpenBSD partition\n"
			    "  d    delete a partition\n"
			    "  f    full display of a partition\n"
			    "  h    command help\n"
			    "  i    (re)initialize the partition map\n"
			    "  n    (re)name a partition\n"
			    "  P    show the partition map's data structures\n"
			    "  p    print the partition map\n"
			    "  q    quit editing\n"
			    "  r    reorder (swap) disk positions of two "
			        "entries in the partition map\n"
			    "  s    change the size of the partition map\n"
			    "  t    change the type of a partition\n"
			    "  w    write the partition map to disk\n");
			break;
		case 'P':
			do_dump_map(map, 1);
			break;
		case 'p':
			do_dump_map(map, 0);
			break;
		case 'q':
			if (map->changed) {
				if (get_okay("Discard changes? [n/y]: ", 0) !=
				    1) {
					break;
				}
			}
			flush_to_newline(1);
			return;
		case 'i':
			if (get_okay("Discard current map? [n/y]: ", 0) == 1) {
				oldmap = map;
				map = create_partition_map(oldmap->fd,
				    oldmap->name, oldmap->media_size,
				    oldmap->sbBlkSize);
				if (map == NULL)
					break;
				*mapp = map;
				free_partition_map(oldmap);
			}
			break;
		case 'C':
			do_create_partition(map, 1);
			break;
		case 'c':
			do_create_partition(map, 0);
			break;
		case 'n':
			do_rename_partition(map);
			break;
		case 'd':
			do_delete_partition(map);
			break;
		case 'r':
			do_reorder(map);
			break;
		case 's':
			do_change_map_size(map);
			break;
		case 't':
			do_change_type(map);
			break;
		case 'w':
			do_write_partition_map(map);
			break;
		case 'f':
			do_display_entry(map);
			break;
		default:
			bad_input("No such command (%c)", command);
			break;
		}
	}
}

void
do_create_partition(struct partition_map *map, int get_type)
{
	long base, length;
	char *name = NULL;
	char *type = NULL;

	if (get_base_argument(&base, map) == 0)
		return;
	if (get_size_argument(&length, map) == 0)
		return;

	name = get_dpistr_argument("Name of partition: ");
	if (name == NULL) {
		bad_input("Bad name");
		goto out;
	}

	if (get_type == 0)
		type = strdup(kUnixType);
	else
		type = get_dpistr_argument("Type of partition: ");
	if (type == NULL) {
		bad_input("Bad type");
		goto out;
	}

	if (strncasecmp(type, kFreeType, DPISTRLEN) == 0) {
		bad_input("Can't create a partition with the Free type");
		goto out;
	}
	if (strncasecmp(type, kMapType, DPISTRLEN) == 0) {
		bad_input("Can't create a partition with the Map type");
		goto out;
	}

	add_partition_to_map(name, type, base, length, map);

out:
	free(type);
	free(name);

	return;
}

int
get_base_argument(long *number, struct partition_map *map)
{
	struct entry *entry;
	int result = 0;

	if (get_number_argument("First block: ", number) == 0) {
		bad_input("Bad block number");
	} else {
		result = 1;
		if (get_partition_modifier()) {
			entry = find_entry_by_disk_address(*number, map);
			if (entry == NULL) {
				bad_input("Bad partition number");
				result = 0;
			} else {
				*number = entry->dpme_pblock_start;
			}
		}
	}
	return result;
}


int
get_size_argument(long *number, struct partition_map *map)
{
	struct entry *entry;
	unsigned long multiple;
	int result = 0;

	if (get_number_argument("Length in blocks: ", number) == 0) {
		bad_input("Bad length");
	} else {
		multiple = get_multiplier(map->sbBlkSize);
		if (multiple == 0) {
			bad_input("Bad multiplier");
		} else if (multiple != 1) {
			*number *= multiple;
			result = 1;
		} else if (get_partition_modifier()) {
			entry = find_entry_by_disk_address(*number, map);
			if (entry == NULL) {
				bad_input("Bad partition number");
			} else {
				*number = entry->dpme_pblocks;
				result = 1;
			}
		} else {
			result = 1;
		}
	}
	return result;
}


void
do_rename_partition(struct partition_map *map)
{
	struct entry *entry;
	char *name;
	long ix;

	if (get_number_argument("Partition number: ", &ix) == 0) {
		bad_input("Bad partition number");
		return;
	}
	entry = find_entry_by_disk_address(ix, map);
	if (entry == NULL) {
		printf("No such partition\n");
		return;
	}

	printf("Existing partition name ``%s''.\n", entry->dpme_name);
	name = get_dpistr_argument("New name of partition: ");
	if (name == NULL) {
		bad_input("Bad name");
		return;
	}

	/*
	 * Since dpme_name is supposed to be NUL-filled, make sure
	 * current contents are zapped before copying in new name!
	 */
	memset(entry->dpme_name, 0, sizeof(entry->dpme_name));
	strlcpy(entry->dpme_name, name, sizeof(entry->dpme_name));
	map->changed = 1;

	free(name);
	return;
}

void
do_change_type(struct partition_map *map)
{
	struct entry *entry;
	char *type;
	long ix;

	if (get_number_argument("Partition number: ", &ix) == 0) {
		bad_input("Bad partition number");
		return;
	}
	entry = find_entry_by_disk_address(ix, map);
	if (entry == NULL) {
		printf("No such partition\n");
		return;
	}

	printf("Existing partition type ``%s''.\n", entry->dpme_type);
	type = get_dpistr_argument("New type of partition: ");
	if (type == NULL) {
		bad_input("Bad type");
		return;
	}

        /*
	 * Since dpme_type is supposed to be NUL-filled, make sure
         * current contents are zapped before copying in new type!
	 */
	memset(entry->dpme_type, 0, sizeof(entry->dpme_type));
	strncpy(entry->dpme_type, type, sizeof(entry->dpme_type));
	map->changed = 1;

	free(type);
	return;
}


void
do_delete_partition(struct partition_map *map)
{
	struct entry *cur;
	long ix;

	if (get_number_argument("Partition number: ", &ix) == 0) {
		bad_input("Bad partition number");
		return;
	}

	cur = find_entry_by_disk_address(ix, map);
	if (cur == NULL)
		printf("No such partition\n");
	else
		delete_partition_from_map(cur);
}


void
do_reorder(struct partition_map *map)
{
	long ix, old_index;

	if (get_number_argument("Partition number: ", &old_index) == 0) {
		bad_input("Bad partition number");
		return;
	}
	if (get_number_argument("New number: ", &ix) == 0) {
		bad_input("Bad partition number");
		return;
	}
	move_entry_in_map(old_index, ix, map);
}


void
do_write_partition_map(struct partition_map *map)
{
	if (map->changed == 0) {
		bad_input("The map has not been changed.");
		return;
	}
	if (rflag) {
		bad_input("The map is not writable.");
		return;
	}
	printf("Writing the map destroys what was there before. ");
	if (get_okay("Is that okay? [n/y]: ", 0) != 1) {
		return;
	}
	write_partition_map(map);

	map->changed = 0;
}


void
do_change_map_size(struct partition_map *map)
{
	long size;

	if (get_number_argument("New size: ", &size) == 0) {
		bad_input("Bad size");
		return;
	}
	resize_map(size, map);
}


void
do_display_entry(struct partition_map *map)
{
	long number;

	if (get_number_argument("Partition number: ", &number) == 0) {
		bad_input("Bad partition number");
		return;
	}
	if (number == 0)
		full_dump_block_zero(map);
	else
		full_dump_partition_entry(map, number);
}

void
do_dump_map(struct partition_map *map, int verbose)
{
	if (verbose)
		show_data_structures(map);
	else
		dump_partition_map(map);
}

__dead static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-lr] disk\n", __progname);

	exit(1);
}
@


1.86
log
@Tweak command line processing vs pledge logic to make things nicer. No
functional change.

Prodded (a while ago) and ok (recently) deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.85 2016/03/09 12:55:18 krw Exp $	*/
a79 3
	if (pledge("stdio rpath wpath disklabel", NULL) == -1)
		err(1, "pledge");

a84 2
			if (pledge("stdio rpath disklabel", NULL) == -1)
				err(1, "pledge");
a88 2
			if (pledge("stdio rpath disklabel", NULL) == -1)
				err(1, "pledge");
a104 3

	if (pledge("stdio disklabel", NULL) == -1)
		err(1, "pledge");
@


1.85
log
@Accept only character special devices rather than generating a core
dump on the attempt to get a disklabel from a regular file.

Regular files have not been acceptable as the 'disk' for some time,
and pledging changed the consequences from a somewhat obscure error
message to an abort().

Issue discovered by espie@@.

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.84 2016/02/02 15:23:07 krw Exp $	*/
d77 1
a77 1
	int c, fd;
d79 1
d87 1
d93 1
d109 1
a109 2
	fd = opendev(*argv, ((rflag || lflag) ? O_RDONLY:O_RDWR), OPENDEV_PART,
	    NULL);
@


1.84
log
@Pledge, based on what's done in fdisk.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.83 2016/01/31 23:00:11 krw Exp $	*/
d116 2
a117 3
	if (!S_ISCHR(st.st_mode) && !S_ISREG(st.st_mode))
		errx(1, "%s is not a character device or a regular file",
		    *argv);
@


1.83
log
@Nuke pointless map field 'physical_block' and just use 'sbBlkSize' which is
set to the same value.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.82 2016/01/30 17:21:10 krw Exp $	*/
d79 3
d86 2
d91 2
d106 2
a107 1
	fd = opendev(*argv, (rflag ? O_RDONLY:O_RDWR), OPENDEV_PART, NULL);
d110 4
d119 1
d124 3
@


1.82
log
@Move last three lines (#define's) from dpme.h to partition_map.h and
tweak #include's as necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.81 2016/01/30 17:09:11 krw Exp $	*/
d196 1
a196 1
				    oldmap->physical_block);
d316 1
a316 1
		multiple = get_multiplier(map->physical_block);
@


1.81
log
@Fold struct dpme into struct entry. Same reasons as for folding
struct block0 into struct partition_map. Easier to read code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.80 2016/01/29 20:18:17 krw Exp $	*/
d47 1
a47 1
#include "dpme.h"
a48 1
#include "partition_map.h"
@


1.80
log
@Add do_dump_map() to make command processing more consistent. Pass
1/0 (a.k.a. vverbose/not verbose) do do_dump_map() to differentiate
P/p.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.79 2016/01/29 14:54:38 krw Exp $	*/
d299 1
a299 1
				*number = entry->dpme->dpme_pblock_start;
d328 1
a328 1
				*number = entry->dpme->dpme_pblocks;
d356 1
a356 1
	printf("Existing partition name ``%s''.\n", entry->dpme->dpme_name);
d367 2
a368 2
	memset(entry->dpme->dpme_name, 0, sizeof(entry->dpme->dpme_name));
	strlcpy(entry->dpme->dpme_name, name, sizeof(entry->dpme->dpme_name));
d392 1
a392 1
	printf("Existing partition type ``%s''.\n", entry->dpme->dpme_type);
d403 2
a404 2
	memset(entry->dpme->dpme_type, 0, sizeof(entry->dpme->dpme_type));
	strncpy(entry->dpme->dpme_type, type, sizeof(entry->dpme->dpme_type));
@


1.79
log
@Rename struct partition_map_header to struct partition_map. No change to
.o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.78 2016/01/28 19:07:45 krw Exp $	*/
d57 1
d178 1
a178 1
			show_data_structures(map);
d181 1
a181 1
			dump_partition_map(map);
d497 8
@


1.78
log
@Hand rolled lists suck. First, replace disk_order with an LIST.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.77 2016/01/28 01:07:39 krw Exp $	*/
d57 11
a67 11
void	do_change_map_size(struct partition_map_header *);
void	do_create_partition(struct partition_map_header *, int);
void	do_delete_partition(struct partition_map_header *);
void	do_display_entry(struct partition_map_header *);
void	do_rename_partition(struct partition_map_header *);
void	do_change_type(struct partition_map_header *);
void	do_reorder(struct partition_map_header *);
void	do_write_partition_map(struct partition_map_header *);
void	edit(struct partition_map_header **);
int	get_base_argument(long *, struct partition_map_header *);
int	get_size_argument(long *, struct partition_map_header *);
d76 1
a76 1
	struct partition_map_header *map;
d130 1
a130 1
edit(struct partition_map_header **mapp)
d132 2
a133 2
	struct partition_map_header *map = *mapp;
	struct partition_map_header *oldmap;
d238 1
a238 1
do_create_partition(struct partition_map_header *map, int get_type)
d283 1
a283 1
get_base_argument(long *number, struct partition_map_header *map)
d285 1
a285 1
	struct partition_map *entry;
d307 1
a307 1
get_size_argument(long *number, struct partition_map_header *map)
d309 1
a309 1
	struct partition_map *entry;
d339 1
a339 1
do_rename_partition(struct partition_map_header *map)
d341 1
a341 1
	struct partition_map *entry;
d375 1
a375 1
do_change_type(struct partition_map_header *map)
d377 1
a377 1
	struct partition_map *entry;
d412 1
a412 1
do_delete_partition(struct partition_map_header *map)
d414 1
a414 1
	struct partition_map *cur;
d431 1
a431 1
do_reorder(struct partition_map_header *map)
d448 1
a448 1
do_write_partition_map(struct partition_map_header *map)
d469 1
a469 1
do_change_map_size(struct partition_map_header *map)
d482 1
a482 1
do_display_entry(struct partition_map_header *map)
@


1.77
log
@Tweak verbiage for 'r' (reorder) command.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.76 2016/01/27 20:11:00 krw Exp $	*/
d36 1
@


1.76
log
@Tweak some verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.75 2016/01/27 16:38:37 krw Exp $	*/
d169 2
a170 1
			    "  r    reorder an entry in the partition map\n"
@


1.75
log
@On-disk partition name/types/processorid may or may not be NUL
terminated after all. So add an extra byte for a NUL in the in-memory
struct's.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.74 2016/01/27 14:47:53 krw Exp $	*/
d159 1
a159 1
			    "  C    create a partition of the specified type\n"
d162 1
a162 1
			    "  f    full display of the specified entry\n"
d171 2
a172 2
			    "  t    change the specified partition's type\n"
			    "  w    write the partition map\n");
@


1.74
log
@We do not support logical_block != physical_block. Remove logical_block
field and left over code that checks for logical != physical.

Removes confusion with dmpe fields lblock_start and lblocks, which
have nothing to do with block sizes! lblock_start is the block
offset within the partition where the data actually starts. and
lblocks is the number of blocks of data within the partition. Both
are in units of *physical blocks*, a.k.a. disk sectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.73 2016/01/27 14:19:59 krw Exp $	*/
d365 1
a365 1
	strlcpy(entry->dpme->dpme_name, name, DPISTRLEN);
d401 1
a401 1
	strncpy(entry->dpme->dpme_type, type, DPISTRLEN);
@


1.73
log
@Check block 0 signature, physical block size and physical block count when
reading partition map.

Check for unmapped physical blocks and overlapping partitions when reading
partition map.

No need for duplicate checks in validate_map(), so remove validate.c from
build and 'v' command from code and docs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.72 2016/01/26 23:41:48 krw Exp $	*/
d314 1
a314 1
		multiple = get_multiplier(map->logical_block);
@


1.72
log
@Rework and simplify string argument parsing. All string arguments are at
most DPISTRLEN (32) characters so there is no need for fancy dynamic
growing strings. Use a DPISTRLEN long buffer and bail if it fills up.

Rename get_string() to get_dpistr() and get_string_argument() to
get_dpstr_argument() to emphasize they will return strings that fit
in DPISTRLEN.

Rework & simplify a pair of their consumers - do_rename_partition() and
do_change_type() - to be more obviously identitical to each other bar
the displayed verbiage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.71 2016/01/26 21:07:54 krw Exp $	*/
a49 1
#include "validate.h"
a171 1
			    "  v    validate the partition map\n"
a226 3
			break;
		case 'v':
			validate_map(map);
@


1.71
log
@dpme_name and dpme_type are NUL-terminated in Apple code, so use
strlcpy() to fill them.

They are also supposed to be NUL-padded so zap previous contents
before copying in possibly shorter new values.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.70 2016/01/26 16:39:00 krw Exp $	*/
d245 1
a245 1
	char *type_name = NULL;
d247 1
a247 1
	if (get_base_argument(&base, map) == 0) {
d249 1
a249 2
	}
	if (get_size_argument(&length, map) == 0) {
d251 3
a253 2
	}
	if (get_string_argument("Name of partition: ", &name) == 0) {
d255 1
a255 1
		return;
d257 6
a262 4
	if (get_type == 0) {
		add_partition_to_map(name, kUnixType, base, length, map);
	} else if (get_string_argument("Type of partition: ", &type_name) ==
	    0) {
d264 10
a273 13
		goto xit1;
	} else {
		if (strncasecmp(type_name, kFreeType, DPISTRLEN) == 0) {
			bad_input("Can't create a partition with the Free "
			    "type");
			goto xit2;
		}
		if (strncasecmp(type_name, kMapType, DPISTRLEN) == 0) {
			bad_input("Can't create a partition with the Map "
			    "type");
			goto xit2;
		}
		add_partition_to_map(name, type_name, base, length, map);
d275 5
a279 3
xit2:
	free(type_name);
xit1:
d281 1
a351 5
	if (get_string_argument("New name of partition: ", &name) == 0) {
		bad_input("Bad name");
		return;
	}
	/* find partition and change it */
d355 8
a362 9
	} else {
		/*
		 * Since dpme_name is supposed to be NUL-filled, make sure
		 * current contents are zapped before copying in new name!
		 */
		memset(entry->dpme->dpme_name, 0,
		    sizeof(entry->dpme->dpme_name));
		strlcpy(entry->dpme->dpme_name, name, DPISTRLEN);
		map->changed = 1;
d364 9
d381 1
a381 1
	char *type = NULL;
a388 1

d391 1
a391 1
		goto out;
d393 1
d395 2
a396 1
	if (get_string_argument("New type of partition: ", &type) == 0) {
d398 1
a398 1
		goto out;
d400 1
a408 1
out:
@


1.70
log
@Whitespace, line wrapping fixes. Nuke many superfluous '{}' around single
statements. 0 -> NULL for pointer checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.69 2016/01/25 23:43:20 krw Exp $	*/
d359 7
a365 2
		/* stuff name into partition map entry dpme */
		strncpy(entry->dpme->dpme_name, name, DPISTRLEN);
d394 5
@


1.69
log
@Use new read/write_block0 and read/write_dpme which handle any
endian or alignment issues forcefully. Removes need for convert_*
functions so unhook convert.c from build. read/write_block become
static functions inside file_media.c.

Tweak struct block0 to stop trying to handle alignment issues by clever
declaration. Rely on the new functions to accurately translate between
on-disk and in-memory layouts.

Enables pdisk to work on amd64 and likely other architectures if
it's ever desirable. Does bring back DEV_BSIZE to pdisk.c since the
in-memory structure will *not* be 512 bytes on other archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.68 2016/01/25 03:26:54 jsg Exp $	*/
d408 1
a408 1
	/* find partition and delete it */
d410 1
a410 1
	if (cur == NULL) {
d412 1
a412 1
	} else {
a413 1
	}
d477 1
a477 1
	if (number == 0) {
d479 1
a479 1
	} else {
a480 1
	}
@


1.68
log
@remove some uneeded includes
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.67 2016/01/24 14:56:39 krw Exp $	*/
d32 1
a32 1
#include <sys/types.h>
d109 2
a110 11

	if (sizeof(struct block0) != dl.d_secsize) {
		errx(1, "Size of block zero structure (%zu) is not equal "
		    "to disk sector size (%d)\n", sizeof(struct block0),
		    dl.d_secsize);
	}
	if (sizeof(struct dpme) != dl.d_secsize) {
		errx(1, "Size of partition map entry (%zu) is not equal "
		    "to disk sector size (%d)\n", sizeof(struct dpme),
		    dl.d_secsize);
	}
@


1.67
log
@Nuke more pointless checks for map NULLness.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.66 2016/01/24 01:38:32 krw Exp $	*/
a50 1
#include "file_media.h"
@


1.66
log
@Whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.65 2016/01/23 23:25:58 krw Exp $	*/
a256 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
a355 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
a383 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
a413 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
a432 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
a447 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
@


1.65
log
@Nuke unused kPatchType. Nuke kStringNot and use " not' where needed.
Nuke kStringEmpty and use "" where needed. Nuke unused static 'g'.

Eliminate #include's in *.h files.

Some whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.64 2016/01/23 22:55:23 krw Exp $	*/
d53 2
a54 2
int		lflag;		/* list the device */
int		rflag;		/* open device read Only */
d58 11
a68 11
void		do_change_map_size(struct partition_map_header *);
void		do_create_partition(struct partition_map_header *, int);
void		do_delete_partition(struct partition_map_header *);
void		do_display_entry(struct partition_map_header *);
void		do_rename_partition(struct partition_map_header *);
void		do_change_type(struct partition_map_header *);
void		do_reorder(struct partition_map_header *);
void		do_write_partition_map(struct partition_map_header *);
void		edit(struct partition_map_header **);
int		get_base_argument(long *, struct partition_map_header *);
int		get_size_argument(long *, struct partition_map_header *);
d251 1
a251 1
do_create_partition(struct partition_map_header * map, int get_type)
d298 1
a298 1
get_base_argument(long *number, struct partition_map_header * map)
d322 1
a322 1
get_size_argument(long *number, struct partition_map_header * map)
d354 1
a354 1
do_rename_partition(struct partition_map_header * map)
d386 1
a386 1
do_change_type(struct partition_map_header * map)
d421 1
a421 1
do_delete_partition(struct partition_map_header * map)
d445 1
a445 1
do_reorder(struct partition_map_header * map)
d466 1
a466 1
do_write_partition_map(struct partition_map_header * map)
d491 1
a491 1
do_change_map_size(struct partition_map_header * map)
d504 1
a504 1
do_display_entry(struct partition_map_header * map)
@


1.64
log
@No need for 'default_value' parameter for get_number_argument() since we
always pass kDefault. a.k.a. -1. Nuke kDefault since it is now unused.

Nuke unused #define MAXIOSIZE in passing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.63 2016/01/23 19:14:04 krw Exp $	*/
d46 1
@


1.63
log
@No need for get_string_argument() parameter 'reprompt' since we
always pass it '1'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.62 2016/01/23 15:05:52 krw Exp $	*/
d302 1
a302 1
	if (get_number_argument("First block: ", number, kDefault) == 0) {
d327 1
a327 1
	if (get_number_argument("Length in blocks: ", number, kDefault) == 0) {
d363 1
a363 1
	if (get_number_argument("Partition number: ", &ix, kDefault) == 0) {
d395 1
a395 1
	if (get_number_argument("Partition number: ", &ix, kDefault) == 0) {
d429 1
a429 1
	if (get_number_argument("Partition number: ", &ix, kDefault) == 0) {
d452 1
a452 2
	if (get_number_argument("Partition number: ", &old_index, kDefault) ==
	    0) {
d456 1
a456 1
	if (get_number_argument("New number: ", &ix, kDefault) == 0) {
d494 1
a494 1
	if (get_number_argument("New size: ", &size, kDefault) == 0) {
d507 1
a507 1
	if (get_number_argument("Partition number: ", &number, kDefault) == 0) {
@


1.62
log
@Pass the disk sector size to open_partition_map(), eliminating it's
internal need for DEV_BSIZE. Ditto create_partition_map().

malloc((sizeof(struct [block0|dpme])) instead of malloc(DEV_BSIZE).

Remove another #include <param.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.61 2016/01/23 14:10:05 krw Exp $	*/
d266 1
a266 1
	if (get_string_argument("Name of partition: ", &name, 1) == 0) {
d272 1
a272 1
	} else if (get_string_argument("Type of partition: ", &type_name, 1) ==
d367 1
a367 1
	if (get_string_argument("New name of partition: ", &name, 1) == 0) {
d406 1
a406 1
	if (get_string_argument("New type of partition: ", &type, 1) == 0) {
@


1.61
log
@Add comments to ensure future spelunkers realize that struct block0
and struct dpme must be 512-bytes long at the moment.

Use this fact to avoid using DEV_BSIZE and thus replace #include
<param.h> with #include <types.h> in pdisk.c.

Constrain media size to UINT32_MAX, the actual limit, instead of
LONG_MAX, which could be way more on some theoretical future arch
running pdisk. And do the constraint inside open_partition_map().
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.60 2016/01/22 18:57:42 krw Exp $	*/
d121 1
a121 1
	map = open_partition_map(fd, *argv, DL_GETDSIZE(&dl));
d204 2
a205 1
				    oldmap->name, oldmap->media_size);
@


1.60
log
@Change partition map field 'data' to 'dmpe'. Change 'create_data'
to 'create_dmpe'. Sweep up some 'struct dpme *data' to struct dpme
*dpme'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.59 2016/01/22 04:16:25 krw Exp $	*/
d32 1
a32 1
#include <sys/param.h>		/* DEV_BSIZE */
a76 1
	uint64_t mediasz;
a78 8
	if (sizeof(struct dpme) != DEV_BSIZE) {
		errx(1, "Size of partition map entry (%zu) is not equal "
		    "to block size (%d)\n", sizeof(struct dpme), DEV_BSIZE);
	}
	if (sizeof(struct block0) != DEV_BSIZE) {
		errx(1, "Size of block zero structure (%zu) is not equal "
		    "to block size (%d)\n", sizeof(struct block0), DEV_BSIZE);
	}
a108 2
	if (dl.d_secsize != DEV_BSIZE)
		err(1, "%u-byte sector size not supported", dl.d_secsize);
d110 10
a119 4
	if (DL_GETDSIZE(&dl) > LONG_MAX)
		mediasz =  LONG_MAX;
	else
		mediasz = DL_GETDSIZE(&dl);
d121 1
a121 1
	map = open_partition_map(fd, *argv, mediasz);
@


1.59
log
@Repair creation of initial partition table on a blank disk, broken
when hoisting file operations and ioctl to main(). Pass media size
to open_partition_map() and create_partition_map() so they can
properly initialize a map.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.58 2016/01/22 01:25:56 krw Exp $	*/
d316 1
a316 1
				*number = entry->data->dpme_pblock_start;
d345 1
a345 1
				*number = entry->data->dpme_pblocks;
d380 2
a381 2
		/* stuff name into partition map entry data */
		strncpy(entry->data->dpme_name, name, DPISTRLEN);
d409 1
a409 1
	printf("Existing partition type ``%s''.\n", entry->data->dpme_type);
d414 1
a414 1
	strncpy(entry->data->dpme_type, type, DPISTRLEN);
@


1.58
log
@In the "why use two variables when one would do" category, eliminate
the 'written' field and just use the 'changed' field to mediate
when it is appropriate to ask whether changes should be discarded.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.57 2016/01/22 00:38:53 krw Exp $	*/
d77 1
d121 6
a126 1
	map = open_partition_map(fd, *argv);
a127 5
		if (DL_GETDSIZE(&dl) > LONG_MAX)
			map->media_size =  LONG_MAX;
		else
			map->media_size = DL_GETDSIZE(&dl);
		sync_device_size(map);
d209 1
a209 1
				    oldmap->name);
a211 4
				map->media_size = oldmap->media_size;
				sync_device_size(map);
				add_partition_to_map("Apple", kMapType,
				    1, (map->media_size <= 128 ? 2 : 63), map);
@


1.57
log
@Nuke 'expert' mode and the enabling, undocumented, '-d' flag by
just making all the commands available all the time. Document the
newly available commands.

Remove the former 'P' command (list partitions in base address
order) and use 'P' from expert mode (show map data structures).

Stop accepting uppercase aliases for commands documented as lower
case.

Bring the 'h' help text and man pages into agreement.

ok jasper@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.56 2016/01/21 15:33:21 krw Exp $	*/
d479 1
a479 1
	if (map->changed == 0 && map->written == 0) {
a493 1
	map->written = 1;
@


1.56
log
@Hoist all file opening and ioctl calls into main(), passing a pointer to
a valid map to edit(). Should enable pledging a la fdisk at some point.

Since edit() always gets a valid map (and maintains its validity even when
'I'nitializing a new one) many checks for (map == NULL) are junked.

Remove some dances around block sizes by using DEV_BSIZE everywhere
since we don't support non-DEV_BSIZE (a.k.a. 512-byte) sectors.

Remove many superfluous #include statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.55 2016/01/21 02:52:52 krw Exp $	*/
a52 1
int		dflag;		/* turn on debugging commands and printout */
a60 1
int		do_expert (struct partition_map_header *);
a67 2
void		print_edit_notes(void);
void		print_expert_notes(void);
d87 1
a87 1
	while ((c = getopt(argc, argv, "ldr")) != -1) {
a91 3
		case 'd':
			dflag = 1;
			break;
d128 1
a128 1
			dump_partition_map(map, 1);
a138 17
void
print_edit_notes()
{
	printf("Notes:\n");
	printf("  Base and length fields are blocks, which vary in size "
	    "between media.\n");
	printf("  The base field can be <nth>p; i.e. use the base of the "
	    "nth partition.\n");
	printf("  The length field can be a length followed by k, m, g or "
	    "t to indicate\n");
	printf("  kilo, mega, giga, or tera bytes; also the length can be "
	    "<nth>p; i.e. use\n");
	printf("  the length of the nth partition.\n");
	printf("  The name of a partition is descriptive text.\n");
	printf("\n");
}

d156 13
a168 1
			print_edit_notes();
a169 1
		case 'H':
d171 17
a187 18
			printf("Commands are:\n");
			printf("  C    (create with type also specified)\n");
			printf("  c    create new partition (standard OpenBSD "
			    "root)\n");
			printf("  d    delete a partition\n");
			printf("  h    help\n");
			printf("  i    initialize partition map\n");
			printf("  n    (re)name a partition\n");
			printf("  P    (print ordered by base address)\n");
			printf("  p    print the partition table\n");
			printf("  q    quit editing\n");
			printf("  r    reorder partition entry in map\n");
			printf("  s    change size of partition map\n");
			printf("  t    change a partition's type\n");
			printf("  w    write the partition table\n");
			if (dflag) {
				printf("  x    extra extensions for experts\n");
			}
d190 1
a190 1
			dump_partition_map(map, 0);
d193 1
a193 1
			dump_partition_map(map, 1);
a194 1
		case 'Q':
a203 1
		case 'I':
a224 1
		case 'N':
a227 1
		case 'D':
a230 1
		case 'R':
a233 1
		case 'S':
a236 1
		case 'T':
a239 10
		case 'X':
		case 'x':
			if (!dflag) {
				goto do_error;
			} else if (do_expert(map)) {
				flush_to_newline(1);
				return;
			}
			break;
		case 'W':
d243 6
a249 1
	do_error:
a496 72

void
print_expert_notes()
{
	printf("Notes:\n");
	printf("  The expert commands are for low level and experimental "
	    "features.\n");
	printf("  These commands are available only when debug mode is on.\n");
	printf("\n");
}


int
do_expert(struct partition_map_header * map)
{
	int command, quit = 0;

	while (get_command("Expert command (? for help): ", first_get,
		    &command)) {
		first_get = 0;

		switch (command) {
		case '?':
			print_expert_notes();
			/* fall through */
		case 'H':
		case 'h':
			printf("Commands are:\n");
			printf("  h    print help\n");
			printf("  p    print the partition table\n");
			printf("  P    (show data structures  - debugging)\n");
			printf("  f    full display of nth entry\n");
			printf("  v    validate map\n");
			printf("  q    return to main edit menu\n");
			printf("  Q    quit editing\n");
			break;
		case 'q':
			flush_to_newline(1);
			goto finis;
			break;
		case 'Q':
			if (map->changed) {
				if (get_okay("Discard changes? [n/y]: ", 0) !=
				    1) {
					break;
				}
			}
			quit = 1;
			goto finis;
			break;
		case 'P':
			show_data_structures(map);
			break;
		case 'p':
			dump_partition_map(map, 1);
			break;
		case 'F':
		case 'f':
			do_display_entry(map);
			break;
		case 'V':
		case 'v':
			validate_map(map);
			break;
		default:
			bad_input("No such command (%c)", command);
			break;
		}
	}
finis:
	return quit;
}
@


1.55
log
@Nuke 'writable' field now that it is always in sync with 'rflag'. Since
(!rflag && writable == 0) can't be true remove those warning blocks and
simply leave the not-writable warning when attempting to write the
map. Always show 'w' in the help and rely on the check and warning
in do_write_partition_map() so the user always gets a message.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.54 2016/01/19 23:44:47 krw Exp $	*/
d33 5
d39 1
a39 1

d42 1
d44 1
a44 3
#include <string.h>
#include <fcntl.h>
#include <errno.h>
d62 1
a62 1
int		do_expert (struct partition_map_header *, char *);
d67 1
a67 1
void		edit(char *);
d78 2
d81 1
a81 1
	int c, junk;
d114 21
a134 3
	if (lflag) {
		map = open_partition_map(*argv, &junk);
		if (map) {
d136 6
a141 4
			close_partition_map(map);
		}
	} else
		edit(*argv);
d167 1
a167 1
edit(char *name)
d169 3
a171 2
	struct partition_map_header *map;
	int command, valid_file;
d173 1
a173 5
	map = open_partition_map(name, &valid_file);
	if (!valid_file) {
		return;
	}
	printf("Edit %s -\n", name);
d211 1
a211 1
			if (map && map->changed) {
d218 1
a218 2
			goto finis;
			break;
d221 13
a233 1
			map = init_partition_map(name, map);
d265 1
a265 1
			} else if (do_expert(map, name)) {
d267 1
a267 1
				goto finis;
a279 3
finis:

	close_partition_map(map);
d536 1
a536 1
do_expert(struct partition_map_header * map, char *name)
a600 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
a613 4
	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
@


1.54
log
@Simplify the main command switch, eliminating a couple of /* fall
through */ and two variables by simply calling the target functions
with the different parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.53 2016/01/19 23:33:18 krw Exp $	*/
d175 1
a175 3
			if (!rflag) {
				printf("  w    write the partition table\n");
			}
d238 1
a238 5
			if (!rflag) {
				do_write_partition_map(map);
			} else {
				goto do_error;
			}
a261 3
	if (!rflag && map->writable == 0) {
		printf("The map is not writable.\n");
	}
a364 3
	if (!rflag && map->writable == 0) {
		printf("The map is not writable.\n");
	}
a396 3
	if (!rflag && map->writable == 0) {
		printf("The map is not writable.\n");
	}
a430 3
	if (!rflag && map->writable == 0) {
		printf("The map is not writable.\n");
	}
a453 3
	if (!rflag && map->writable == 0) {
		printf("The map is not writable.\n");
	}
d478 1
a478 1
	if (map->writable == 0) {
a572 3
	}
	if (!rflag && map->writable == 0) {
		printf("The map is not writable.\n");
@


1.53
log
@It's pointless to check for 'dflag' inside do_expert(), since you can't
get there unless dflag is set. Makes switch() statement easier to grasp.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.52 2016/01/19 16:53:04 krw Exp $	*/
d144 1
a144 1
	int command, order, get_type, valid_file;
a153 2
		order = 1;
		get_type = 0;
d183 2
a184 2
			order = 0;
			/* fall through */
d186 1
a186 1
			dump_partition_map(map, order);
d204 2
a205 2
			get_type = 1;
			/* fall through */
d207 1
a207 1
			do_create_partition(map, get_type);
@


1.52
log
@Remove forward declarations for functions that do not exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.51 2016/01/19 14:50:40 krw Exp $	*/
d545 1
a545 4
			if (dflag) {
				printf("  P    (show data structures  - "
				    "debugging)\n");
			}
d566 2
a567 5
			if (dflag) {
				show_data_structures(map);
				break;
			}
			/* fall through */
@


1.51
log
@Bring code into line with man page and usage() by only allowing one
disk to be specified on the command line. Nuke dump() function and
hoist its few lines into main() as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.50 2016/01/19 12:25:28 krw Exp $	*/
a64 1
int		get_command_line(int *, char ***);
@


1.50
log
@No need for pdisk(8) to provide a version of hexdump. Remove
the "expert" mode 'd'/'D' command and its supporting code.

ok deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.49 2016/01/18 21:50:53 krw Exp $	*/
d75 2
a76 1
	int c, name_index;
d103 5
a107 1
	name_index = optind;
d110 4
a113 6
		if (name_index < argc) {
			while (name_index < argc) {
				dump(argv[name_index++]);
			}
		} else {
			usage();
d115 3
a117 7
	} else if (name_index < argc) {
		while (name_index < argc) {
			edit(argv[name_index++]);
		}
	} else {
		usage();
	}
@


1.49
log
@The contents of the Apple_Patches partition is none of our business.
Stop pretending we care or know what's in there. Remove 'debugging'
mode command to examine the partition contents and the supporting
code.

ok deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.48 2016/01/18 17:57:35 krw Exp $	*/
a56 1
void		do_display_block(struct partition_map_header *, char *);
a545 1
			printf("  d    dump block n\n");
a578 4
		case 'D':
		case 'd':
			do_display_block(map, name);
			break;
a612 66
}


void
do_display_block(struct partition_map_header * map, char *alt_name)
{
	char *name;
	long number;
	int fd, g;
	static unsigned char *display_block;
	static long next_number = -1;
	static int display_g;

	if (map != NULL) {
		name = 0;
		fd = map->fd;
		g = map->logical_block;
	} else {
		if (alt_name == 0) {
			if (get_string_argument("Name of device: ", &name, 1)
			    == 0) {
				bad_input("Bad name");
				return;
			}
		} else {
			if ((name = strdup(alt_name)) == NULL) {
				warn("strdup failed");
				return;
			}
		}
		fd = open_file_as_media(name, O_RDONLY);
		if (fd == -1) {
			warn("can't open file '%s'", name);
			free(name);
			return;
		}
		g = DEV_BSIZE;
	}
	if (get_number_argument("Block number: ", &number, next_number) == 0) {
		bad_input("Bad block number");
		goto xit;
	}
	if (display_block == NULL || display_g < g) {
		if (display_block != NULL) {
			free(display_block);
			display_g = 0;
		}
		display_block = malloc(g);
		if (display_block == NULL) {
			warn("can't allocate memory for display block buffer");
			goto xit;
		}
		display_g = g;
	}
	if (read_file_media(fd, ((long long) number) * g, g,
		    (char *)display_block) != 0) {
		printf("block %ld -", number);
		dump_block((unsigned char *)display_block, g);
		next_number = number + 1;
	}
xit:
	if (name) {
		close(fd);
		free(name);
	}
	return;
@


1.48
log
@struct file_media had 1 field left. And one place where struct
file_media was actually stored. So move the last field (fd) into
the place formerly used to store pointer to the instance. As a
result we can just pass fd's around rather than pointers to a struct
containing a fd.

close_file_media() becomes empty but for a close(). So just use
close() and nuke close_file_media().
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.47 2016/01/18 02:16:06 krw Exp $	*/
a58 1
void		do_examine_patch_partition(struct partition_map_header *);
a554 1
			printf("  e    examine patch partition\n");
a592 4
		case 'E':
		case 'e':
			do_examine_patch_partition(map);
			break;
a707 17

void
do_examine_patch_partition(struct partition_map_header * map)
{
	struct partition_map *entry;

	if (map == NULL) {
		bad_input("No partition map exists");
		return;
	}
	entry = find_entry_by_type(kPatchType, map);
	if (entry == NULL) {
		printf("No patch partition\n");
	} else {
		display_patches(entry);
	}
}
@


1.47
log
@Run indent(1) over it and tweak the results a bit manually to look more
KNF'ish.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.46 2016/01/18 00:19:29 krw Exp $	*/
a630 1
	struct file_media *m;
d633 1
a633 1
	int g;
d640 1
a640 1
		m = map->m;
d655 2
a656 2
		m = open_file_as_media(name, O_RDONLY);
		if (m == 0) {
d679 1
a679 1
	if (read_file_media(m, ((long long) number) * g, g,
d687 1
a687 1
		close_file_media(m);
@


1.46
log
@Fold get_options() into main() and eliminate unneeded nFLAG_DEFAULT
#defines. Zero is a well known and acceptable number.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.45 2016/01/18 00:04:36 krw Exp $	*/
d32 1
a32 1
#include <sys/param.h>	/* DEV_BSIZE */
d48 23
a70 23
int lflag;	/* list the device */
int dflag;	/* turn on debugging commands and printout */
int rflag;	/* open device read Only */

static int first_get = 1;

void do_change_map_size(struct partition_map_header *);
void do_create_partition(struct partition_map_header *, int);
void do_delete_partition(struct partition_map_header *);
void do_display_block(struct partition_map_header *, char *);
void do_display_entry(struct partition_map_header *);
void do_examine_patch_partition(struct partition_map_header *);
int do_expert(struct partition_map_header *, char *);
void do_rename_partition(struct partition_map_header *);
void do_change_type(struct partition_map_header *);
void do_reorder(struct partition_map_header *);
void do_write_partition_map(struct partition_map_header *);
void edit(char *);
int get_base_argument(long *, struct partition_map_header *);
int get_command_line(int *, char ***);
int get_size_argument(long *, struct partition_map_header *);
void print_edit_notes(void);
void print_expert_notes(void);
d77 1
a77 1
    int c, name_index;
d79 39
a117 35
    if (sizeof(struct dpme) != DEV_BSIZE) {
	errx(1, "Size of partition map entry (%zu) "
		"is not equal to block size (%d)\n",
		sizeof(struct dpme), DEV_BSIZE);
    }
    if (sizeof(struct block0) != DEV_BSIZE) {
	errx(1, "Size of block zero structure (%zu) "
		"is not equal to block size (%d)\n",
		sizeof(struct block0), DEV_BSIZE);
    }

    while ((c = getopt(argc, argv, "ldr")) != -1) {
	switch (c) {
	case 'l':
	    lflag = 1;
	    break;
	case 'd':
	    dflag = 1;
	    break;
	case 'r':
	    rflag = 1;
	    break;
	default:
	    usage();
	    break;
	}
    }

    name_index = optind;

    if (lflag) {
	if (name_index < argc) {
	    while (name_index < argc) {
		dump(argv[name_index++]);
	    }
d119 1
a119 1
	    usage();
d121 1
a121 8
    } else if (name_index < argc) {
	while (name_index < argc) {
	    edit(argv[name_index++]);
	}
    } else {
	usage();
    }
    return 0;
a123 1

d127 12
a138 8
    printf("Notes:\n");
    printf("  Base and length fields are blocks, which vary in size between media.\n");
    printf("  The base field can be <nth>p; i.e. use the base of the nth partition.\n");
    printf("  The length field can be a length followed by k, m, g or t to indicate\n");
    printf("  kilo, mega, giga, or tera bytes; also the length can be <nth>p; i.e. use\n");
    printf("  the length of the nth partition.\n");
    printf("  The name of a partition is descriptive text.\n");
    printf("\n");
a140 1

d147 2
a148 5
    struct partition_map_header *map;
    int command;
    int order;
    int get_type;
    int valid_file;
d150 5
a154 6
    map = open_partition_map(name, &valid_file);
    if (!valid_file) {
	return;
    }

    printf("Edit %s -\n", name);
d156 97
a252 95
    while (get_command("Command (? for help): ", first_get, &command)) {
	first_get = 0;
	order = 1;
	get_type = 0;

	switch (command) {
	case '?':
	    print_edit_notes();
	    /* fall through */
	case 'H':
	case 'h':
	    printf("Commands are:\n");
	    printf("  C    (create with type also specified)\n");
	    printf("  c    create new partition (standard OpenBSD root)\n");
	    printf("  d    delete a partition\n");
	    printf("  h    help\n");
	    printf("  i    initialize partition map\n");
	    printf("  n    (re)name a partition\n");
	    printf("  P    (print ordered by base address)\n");
	    printf("  p    print the partition table\n");
	    printf("  q    quit editing\n");
	    printf("  r    reorder partition entry in map\n");
	    printf("  s    change size of partition map\n");
	    printf("  t    change a partition's type\n");
	    if (!rflag) {
		printf("  w    write the partition table\n");
	    }
	    if (dflag) {
		printf("  x    extra extensions for experts\n");
	    }
	    break;
	case 'P':
	    order = 0;
	    /* fall through */
	case 'p':
	    dump_partition_map(map, order);
	    break;
	case 'Q':
	case 'q':
	    if (map && map->changed) {
		if (get_okay("Discard changes? [n/y]: ", 0) != 1) {
		    break;
		}
	    }
	    flush_to_newline(1);
	    goto finis;
	    break;
	case 'I':
	case 'i':
	    map = init_partition_map(name, map);
	    break;
	case 'C':
	    get_type = 1;
	    /* fall through */
	case 'c':
	    do_create_partition(map, get_type);
	    break;
	case 'N':
	case 'n':
	    do_rename_partition(map);
	    break;
	case 'D':
	case 'd':
	    do_delete_partition(map);
	    break;
	case 'R':
	case 'r':
	    do_reorder(map);
	    break;
	case 'S':
	case 's':
	    do_change_map_size(map);
	    break;
	case 'T':
	case 't':
	    do_change_type(map);
	    break;
	case 'X':
	case 'x':
	    if (!dflag) {
		goto do_error;
	    } else if (do_expert(map, name)) {
		flush_to_newline(1);
		goto finis;
	    }
	    break;
	case 'W':
	case 'w':
	    if (!rflag) {
		do_write_partition_map(map);
	    } else {
		goto do_error;
	    }
	    break;
	default:
d254 3
a256 2
	    bad_input("No such command (%c)", command);
	    break;
a257 1
    }
d260 1
a260 1
    close_partition_map(map);
d264 1
a264 1
do_create_partition(struct partition_map_header *map, int get_type)
d266 3
a268 4
    long base;
    long length;
    char *name = 0;
    char *type_name = 0;
d270 35
a304 31
    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    if (!rflag && map->writable == 0) {
	printf("The map is not writable.\n");
    }
    if (get_base_argument(&base, map) == 0) {
	return;
    }
    if (get_size_argument(&length, map) == 0) {
	return;
    }

    if (get_string_argument("Name of partition: ", &name, 1) == 0) {
	bad_input("Bad name");
	return;
    }
    if (get_type == 0) {
	add_partition_to_map(name, kUnixType, base, length, map);
    } else if (get_string_argument("Type of partition: ", &type_name, 1) == 0) {
	bad_input("Bad type");
	goto xit1;
    } else {
	if (strncasecmp(type_name, kFreeType, DPISTRLEN) == 0) {
	    bad_input("Can't create a partition with the Free type");
	    goto xit2;
	}
	if (strncasecmp(type_name, kMapType, DPISTRLEN) == 0) {
	    bad_input("Can't create a partition with the Map type");
	    goto xit2;
a305 2
	add_partition_to_map(name, type_name, base, length, map);
    }
d307 1
a307 1
    free(type_name);
d309 2
a310 2
    free(name);
    return;
a312 1

d314 1
a314 1
get_base_argument(long *number, struct partition_map_header *map)
d316 2
a317 2
    struct partition_map * entry;
    int result = 0;
d319 13
a331 12
    if (get_number_argument("First block: ", number, kDefault) == 0) {
	bad_input("Bad block number");
    } else {
	result = 1;
	if (get_partition_modifier()) {
	    entry = find_entry_by_disk_address(*number, map);
	    if (entry == NULL) {
		bad_input("Bad partition number");
		result = 0;
	    } else {
		*number = entry->data->dpme_pblock_start;
	    }
d333 1
a333 2
    }
    return result;
d338 1
a338 1
get_size_argument(long *number, struct partition_map_header *map)
d340 6
a345 21
    struct partition_map * entry;
    int result = 0;
    unsigned long multiple;

    if (get_number_argument("Length in blocks: ", number, kDefault) == 0) {
	bad_input("Bad length");
    } else {
	multiple = get_multiplier(map->logical_block);
	if (multiple == 0) {
	    bad_input("Bad multiplier");
	} else if (multiple != 1) {
	    *number *= multiple;
	    result = 1;
	} else if (get_partition_modifier()) {
	    entry = find_entry_by_disk_address(*number, map);
	    if (entry == NULL) {
		bad_input("Bad partition number");
	    } else {
		*number = entry->data->dpme_pblocks;
		result = 1;
	    }
d347 17
a363 1
	    result = 1;
d365 1
a365 2
    }
    return result;
d370 1
a370 1
do_rename_partition(struct partition_map_header *map)
d372 3
a374 3
    struct partition_map * entry;
    long ix;
    char *name;
d376 25
a400 9
    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    if (!rflag && map->writable == 0) {
	printf("The map is not writable.\n");
    }
    if (get_number_argument("Partition number: ", &ix, kDefault) == 0) {
	bad_input("Bad partition number");
a401 17
    }
    if (get_string_argument("New name of partition: ", &name, 1) == 0) {
	bad_input("Bad name");
	return;
    }

	/* find partition and change it */
    entry = find_entry_by_disk_address(ix, map);
    if (entry == NULL) {
	printf("No such partition\n");
    } else {
	/* stuff name into partition map entry data */
	strncpy(entry->data->dpme_name, name, DPISTRLEN);
	map->changed = 1;
    }
    free(name);
    return;
d405 1
a405 1
do_change_type(struct partition_map_header *map)
d407 3
a409 3
    struct partition_map * entry;
    long ix;
    char *type = NULL;
d411 12
a422 4
    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
d424 11
a434 3
    if (!rflag && map->writable == 0) {
	printf("The map is not writable.\n");
    }
d436 2
a437 2
    if (get_number_argument("Partition number: ", &ix, kDefault) == 0) {
	bad_input("Bad partition number");
a438 21
    }

    entry = find_entry_by_disk_address(ix, map);

    if (entry == NULL ) {
        printf("No such partition\n");
	goto out;
    }

    printf("Existing partition type ``%s''.\n", entry->data->dpme_type);
    if (get_string_argument("New type of partition: ", &type, 1) == 0) {
	bad_input("Bad type");
	goto out;
    }

    strncpy(entry->data->dpme_type, type, DPISTRLEN);
    map->changed = 1;

out:
    free(type);
    return;
d443 1
a443 1
do_delete_partition(struct partition_map_header *map)
d445 2
a446 14
    struct partition_map * cur;
    long ix;

    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    if (!rflag && map->writable == 0) {
	printf("The map is not writable.\n");
    }
    if (get_number_argument("Partition number: ", &ix, kDefault) == 0) {
	bad_input("Bad partition number");
	return;
    }
d448 11
d460 6
a465 6
    cur = find_entry_by_disk_address(ix, map);
    if (cur == NULL) {
	printf("No such partition\n");
    } else {
	delete_partition_from_map(cur);
    }
d470 1
a470 1
do_reorder(struct partition_map_header *map)
d472 1
a472 2
    long old_index;
    long ix;
d474 17
a490 17
    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    if (!rflag && map->writable == 0) {
	printf("The map is not writable.\n");
    }
    if (get_number_argument("Partition number: ", &old_index, kDefault) == 0) {
	bad_input("Bad partition number");
	return;
    }
    if (get_number_argument("New number: ", &ix, kDefault) == 0) {
	bad_input("Bad partition number");
	return;
    }

    move_entry_in_map(old_index, ix, map);
d495 1
a495 1
do_write_partition_map(struct partition_map_header *map)
d497 17
a513 16
    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    if (map->changed == 0 && map->written == 0) {
	bad_input("The map has not been changed.");
	return;
    }
    if (map->writable == 0) {
	bad_input("The map is not writable.");
	return;
    }
    printf("Writing the map destroys what was there before. ");
    if (get_okay("Is that okay? [n/y]: ", 0) != 1) {
	return;
    }
d515 2
a516 4
    write_partition_map(map);

    map->changed = 0;
    map->written = 1;
d523 5
a527 4
    printf("Notes:\n");
    printf("  The expert commands are for low level and experimental features.\n");
    printf("  These commands are available only when debug mode is on.\n");
    printf("\n");
d532 1
a532 1
do_expert(struct partition_map_header *map, char *name)
d534 1
a534 2
    int command;
    int quit = 0;
d536 67
a602 63
    while (get_command("Expert command (? for help): ", first_get, &command)) {
	first_get = 0;

	switch (command) {
	case '?':
	    print_expert_notes();
	    /* fall through */
	case 'H':
	case 'h':
	    printf("Commands are:\n");
	    printf("  h    print help\n");
	    printf("  d    dump block n\n");
	    printf("  p    print the partition table\n");
	    if (dflag) {
		printf("  P    (show data structures  - debugging)\n");
	    }
	    printf("  f    full display of nth entry\n");
	    printf("  v    validate map\n");
	    printf("  e    examine patch partition\n");
	    printf("  q    return to main edit menu\n");
	    printf("  Q    quit editing\n");
	    break;
	case 'q':
	    flush_to_newline(1);
	    goto finis;
	    break;
	case 'Q':
	    if (map->changed) {
		if (get_okay("Discard changes? [n/y]: ", 0) != 1) {
		    break;
		}
	    }
	    quit = 1;
	    goto finis;
	    break;
	case 'P':
	    if (dflag) {
		show_data_structures(map);
		break;
	    }
	    /* fall through */
	case 'p':
	    dump_partition_map(map, 1);
	    break;
	case 'D':
	case 'd':
	    do_display_block(map, name);
	    break;
	case 'F':
	case 'f':
	    do_display_entry(map);
	    break;
	case 'V':
	case 'v':
	    validate_map(map);
	    break;
	case 'E':
	case 'e':
	    do_examine_patch_partition(map);
	    break;
	default:
	    bad_input("No such command (%c)", command);
	    break;
a603 1
    }
d605 1
a605 1
    return quit;
d609 1
a609 1
do_change_map_size(struct partition_map_header *map)
d611 1
a611 1
    long size;
d613 12
a624 12
    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    if (!rflag && map->writable == 0) {
	printf("The map is not writable.\n");
    }
    if (get_number_argument("New size: ", &size, kDefault) == 0) {
	bad_input("Bad size");
	return;
    }
    resize_map(size, map);
d629 1
a629 1
do_display_block(struct partition_map_header *map, char *alt_name)
d631 7
a637 7
    struct file_media *m;
    long number;
    char *name;
    static unsigned char *display_block;
    static int display_g;
    int g;
    static long next_number = -1;
d639 4
a642 10
    if (map != NULL) {
	name = 0;
	m = map->m;
	g = map->logical_block;
    } else {
	if (alt_name == 0) {
	    if (get_string_argument("Name of device: ", &name, 1) == 0) {
		bad_input("Bad name");
		return;
	    }
d644 41
a684 4
	    if ((name = strdup(alt_name)) == NULL) {
		warn("strdup failed");
		return;
	    }
a685 30
	m = open_file_as_media(name, O_RDONLY);
	if (m == 0) {
	    warn("can't open file '%s'", name);
	    free(name);
	    return;
	}
	g = DEV_BSIZE;
    }
    if (get_number_argument("Block number: ", &number, next_number) == 0) {
	bad_input("Bad block number");
	goto xit;
    }
    if (display_block == NULL || display_g < g) {
	if (display_block != NULL) {
	    free(display_block);
	    display_g = 0;
	}
	display_block = malloc(g);
	if (display_block == NULL) {
	    warn("can't allocate memory for display block buffer");
	    goto xit;
	}
	display_g = g;
    }
    if (read_file_media(m, ((long long)number) * g, g, (char *)display_block) != 0) {
	printf("block %ld -", number);
	dump_block((unsigned char*) display_block, g);
	next_number = number + 1;
    }

d687 5
a691 5
    if (name) {
	close_file_media(m);
	free(name);
    }
    return;
d696 1
a696 1
do_display_entry(struct partition_map_header *map)
d698 1
a698 1
    long number;
d700 13
a712 13
    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    if (get_number_argument("Partition number: ", &number, kDefault) == 0) {
	bad_input("Bad partition number");
	return;
    }
    if (number == 0) {
	full_dump_block_zero(map);
    } else {
	full_dump_partition_entry(map, number);
    }
d717 1
a717 1
do_examine_patch_partition(struct partition_map_header *map)
d719 1
a719 1
    struct partition_map * entry;
d721 10
a730 10
    if (map == NULL) {
	bad_input("No partition map exists");
	return;
    }
    entry = find_entry_by_type(kPatchType, map);
    if (entry == NULL) {
	printf("No patch partition\n");
    } else {
	display_patches(entry);
    }
d736 1
a736 1
    extern char * __progname;
d738 1
a738 1
    fprintf(stderr, "usage: %s [-lr] disk\n", __progname);
d740 1
a740 1
    exit(1);
@


1.45
log
@Remove a grab bag of unused #define's, fields, enum's, variables,
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.44 2016/01/17 23:18:19 krw Exp $	*/
d48 3
a50 7
#define DFLAG_DEFAULT	0
#define LFLAG_DEFAULT	0
#define RFLAG_DEFAULT	0

int lflag = LFLAG_DEFAULT;	/* list the device */
int dflag = DFLAG_DEFAULT;	/* turn on debugging commands and printout */
int rflag = RFLAG_DEFAULT;	/* open device read Only */
a68 1
int get_options(int, char **);
d77 1
a77 1
    int name_index;
d90 18
a107 1
    name_index = get_options(argc, argv);
a124 33
}


int
get_options(int argc, char **argv)
{
    int c;
    extern int optind;
    extern char *optarg;

    lflag = LFLAG_DEFAULT;
    dflag = DFLAG_DEFAULT;
    rflag = RFLAG_DEFAULT;

    optind = 1; /* reset option scanner logic */
    while ((c = getopt(argc, argv, "ldr")) != -1) {
	switch (c) {
	case 'l':
	    lflag = (LFLAG_DEFAULT)?0:1;
	    break;
	case 'd':
	    dflag = (DFLAG_DEFAULT)?0:1;
	    break;
	case 'r':
	    rflag = (RFLAG_DEFAULT)?0:1;
	    break;
	default:
	    usage();
	    break;
	}
    }

    return optind;
@


1.44
log
@Change "//" comments to "/**/". Nuke really stupid ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.43 2016/01/17 19:39:20 krw Exp $	*/
a47 1
#define ARGV_CHUNK 5
a50 9

enum getopt_values {
    kLongOption = 0,
    kBadOption = '?',
    kOptionArg = 1000,
    kListOption = 1001,
    kLogicalOption = 1002
};

@


1.43
log
@Reduce namespace pollution by eliminating parameter names from forward
declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.42 2016/01/17 19:15:55 krw Exp $	*/
d3 7
a9 7
//
// pdisk - an editor for Apple format partition tables
//
// Written by Eryk Vershen
//
// Still under development (as of 15 January 1998)
//
d137 1
a137 1
    optind = 1; // reset option scanner logic
d173 3
a175 3
//
// Edit the file
//
d200 1
a200 1
	    // fall through
d225 1
a225 1
	    // fall through
d245 1
a245 1
	    // fall through
a311 1
// XXX add help feature (i.e. '?' in any argument routine prints help string)
d426 1
a426 1
	// find partition and change it
d431 1
a431 1
	// stuff name into partition map entry data
d500 1
a500 1
	// find partition and delete it
a559 2

    // exit(0);
d585 1
a585 1
	    // fall through
d619 1
a619 1
	    // fall through
@


1.42
log
@Kill leading, imbedded, trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.41 2016/01/17 18:57:52 krw Exp $	*/
d68 16
a83 16
void do_change_map_size(struct partition_map_header *map);
void do_create_partition(struct partition_map_header *map, int get_type);
void do_delete_partition(struct partition_map_header *map);
void do_display_block(struct partition_map_header *map, char *alt_name);
void do_display_entry(struct partition_map_header *map);
void do_examine_patch_partition(struct partition_map_header *map);
int do_expert(struct partition_map_header *map, char *name);
void do_rename_partition(struct partition_map_header *map);
void do_change_type(struct partition_map_header *map);
void do_reorder(struct partition_map_header *map);
void do_write_partition_map(struct partition_map_header *map);
void edit(char *name);
int get_base_argument(long *number, struct partition_map_header *map);
int get_command_line(int *argc, char ***argv);
int get_size_argument(long *number, struct partition_map_header *map);
int get_options(int argc, char **argv);
@


1.41
log
@Remove a bunch of ridiculous and uninformative comments like "// Defines".
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.40 2016/01/17 17:44:05 krw Exp $	*/
d120 1
a120 1
 	usage();
d187 1
a187 1
    	return;
d283 1
a283 1
	    	goto do_error;
d683 1
a683 1
    	name = 0;
d711 3
a713 3
    	if (display_block != NULL) {
    	    free(display_block);
    	    display_g = 0;
d751 1
a751 1
    	full_dump_block_zero(map);
@


1.40
log
@The great de-typedef'ification continues.

partition_map -> struct partition_map
partition_map_header -> struct partition_map_header
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.39 2016/01/17 16:15:59 krw Exp $	*/
a34 1
// for printf()
a35 2

// for malloc() & free()
a37 2

// for strncpy() & strlen()
a38 1
// for O_RDONLY
a39 1
// for errno
a47 4

//
// Defines
//
a52 9

//
// Types
//


//
// Global Constants
//
a61 3
//
// Global Variables
//
a67 4

//
// Forward declarations
//
a88 3
//
// Routines
//
@


1.39
log
@The great de-typedef'ification continues. Block0 -> struct block0.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.38 2016/01/17 16:07:06 krw Exp $	*/
d95 11
a105 11
void do_change_map_size(partition_map_header *map);
void do_create_partition(partition_map_header *map, int get_type);
void do_delete_partition(partition_map_header *map);
void do_display_block(partition_map_header *map, char *alt_name);
void do_display_entry(partition_map_header *map);
void do_examine_patch_partition(partition_map_header *map);
int do_expert(partition_map_header *map, char *name);
void do_rename_partition(partition_map_header *map);
void do_change_type(partition_map_header *map);
void do_reorder(partition_map_header *map);
void do_write_partition_map(partition_map_header *map);
d107 1
a107 1
int get_base_argument(long *number, partition_map_header *map);
d109 1
a109 1
int get_size_argument(long *number, partition_map_header *map);
d209 1
a209 1
    partition_map_header *map;
d328 1
a328 1
do_create_partition(partition_map_header *map, int get_type)
d379 1
a379 1
get_base_argument(long *number, partition_map_header *map)
d381 1
a381 1
    partition_map * entry;
d403 1
a403 1
get_size_argument(long *number, partition_map_header *map)
d405 1
a405 1
    partition_map * entry;
d435 1
a435 1
do_rename_partition(partition_map_header *map)
d437 1
a437 1
    partition_map * entry;
d471 1
a471 1
do_change_type(partition_map_header *map)
d473 1
a473 1
    partition_map * entry;
d514 1
a514 1
do_delete_partition(partition_map_header *map)
d516 1
a516 1
    partition_map * cur;
d542 1
a542 1
do_reorder(partition_map_header *map)
d568 1
a568 1
do_write_partition_map(partition_map_header *map)
d607 1
a607 1
do_expert(partition_map_header *map, char *name)
d682 1
a682 1
do_change_map_size(partition_map_header *map)
d702 1
a702 1
do_display_block(partition_map_header *map, char *alt_name)
d768 1
a768 1
do_display_entry(partition_map_header *map)
d789 1
a789 1
do_examine_patch_partition(partition_map_header *map)
d791 1
a791 1
    partition_map * entry;
@


1.38
log
@The great de-typedef'ification continues. DPME -> struct dpme.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.37 2016/01/17 15:57:12 krw Exp $	*/
d129 1
a129 1
    if (sizeof(Block0) != DEV_BSIZE) {
d132 1
a132 1
		sizeof(Block0), DEV_BSIZE);
@


1.37
log
@Let the great de-typedef'ification begin. MEDIA -> struct file_media *.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.36 2016/01/16 22:28:14 krw Exp $	*/
d124 1
a124 1
    if (sizeof(DPME) != DEV_BSIZE) {
d127 1
a127 1
		sizeof(DPME), DEV_BSIZE);
@


1.36
log
@Move last field (size_in_bytes) in struct media to struct file_media
and replace MEDIA with FILE_MEDIA everywhere. media.h becomes unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.35 2016/01/16 21:41:41 krw Exp $	*/
d704 1
a704 1
    FILE_MEDIA m;
@


1.35
log
@There can be only one. 'grain' that is. i.e. DEV_BSIZE. No need to track
or store. Just use.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.34 2016/01/16 20:00:50 krw Exp $	*/
d704 1
a704 1
    MEDIA m;
@


1.34
log
@Start peeling away excess layers of abstraction.

Since 'file' is the only kind of media, no need to call the appropriate
functions via pointers. Just call the _file_ variants directly.
Nuke the fields do_read(), do_write(), do_close(), do_os_reload()
and the functions read_media(), write_media(), close_media() and
os_reload_media().

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.33 2016/01/15 23:05:00 krw Exp $	*/
d734 1
a734 4
	g = media_granularity(m);
	if (g < DEV_BSIZE) {
	    g = DEV_BSIZE;
	}
@


1.33
log
@We don't need yet another alias for DEV_BSIZE. Use DEV_BSIZE and
nuke PBLOCK_SIZE and another unused #define.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.32 2016/01/14 15:10:25 krw Exp $	*/
d755 1
a755 1
    if (read_media(m, ((long long)number) * g, g, (char *)display_block) != 0) {
d763 1
a763 1
	close_media(m);
@


1.32
log
@Kill unused variable 'lfile'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.31 2016/01/14 04:22:25 krw Exp $	*/
d32 1
d124 1
a124 1
    if (sizeof(DPME) != PBLOCK_SIZE) {
d127 1
a127 1
		sizeof(DPME), PBLOCK_SIZE);
d129 1
a129 1
    if (sizeof(Block0) != PBLOCK_SIZE) {
d132 1
a132 1
		sizeof(Block0), PBLOCK_SIZE);
d735 2
a736 2
	if (g < PBLOCK_SIZE) {
	    g = PBLOCK_SIZE;
@


1.31
log
@Don't include hfs_misc.h, which no longer contains anything of use.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.30 2016/01/14 04:02:05 krw Exp $	*/
a84 1
char *lfile;	/* list */
d137 1
a137 3
	if (lfile != NULL) {
	    dump(lfile);
	} else if (name_index < argc) {
a162 1
    lfile = NULL;
@


1.30
log
@Remove code supporting undocumented and inaccessible flags 'a'
(abbreviate partition type names), 'f' (print HFS partition names)
and 'kLogicalOption' (obviously a getopt_long() conversion error).
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.29 2016/01/13 00:29:25 krw Exp $	*/
a49 1
#include "hfs_misc.h"
@


1.29
log
@Remove obsolete flags (h, v, i, c) from getopt() call.

No need for 'flags' variable. Just call usage() on unknown options.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.28 2016/01/12 20:22:32 krw Exp $	*/
a169 2
    aflag = AFLAG_DEFAULT;
    pflag = PFLAG_DEFAULT;
a181 6
	    break;
	case 'a':
	    aflag = (AFLAG_DEFAULT)?0:1;
	    break;
	case kLogicalOption:
	    pflag = (PFLAG_DEFAULT)?0:1;
@


1.28
log
@The only thing in pdisk.h is an unused #define. So don't include it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.27 2016/01/12 20:09:39 krw Exp $	*/
a164 1
    int flag = 0;
d174 1
a174 1
    while ((c = getopt(argc, argv, "hlvdric")) != -1) {
d192 1
a192 1
	    flag = 1;
d196 1
a196 3
    if (flag) {
	usage();
    }
@


1.27
log
@Use normal err/errx/warn/warnx rather than handrolling new ones. Move
usage() to pdisk.c and nuke do_help() and '-h'.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.26 2016/01/12 15:32:08 krw Exp $	*/
a47 1
#include "pdisk.h"
@


1.26
log
@Retire '-i', a poorly documented interactive mode that tries to
mimic the 20th century MacOS version of pdisk more closely than the
usual interactive editor. One set of commands is enough for anyone.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.25 2016/01/12 01:17:41 krw Exp $	*/
d32 2
a51 1
#include "errors.h"
a61 1
#define HFLAG_DEFAULT	0
a87 1
int hflag = HFLAG_DEFAULT;	/* show help */
d116 1
d127 1
a127 1
	fatal(-1, "Size of partition map entry (%d) "
d132 1
a132 1
	fatal(-1, "Size of block zero structure (%d) "
d139 1
a139 3
    if (hflag) {
 	do_help();
    } else if (lflag) {
d147 1
a147 1
	    do_help();
d154 1
a154 1
 	do_help();
a169 1
    hflag = HFLAG_DEFAULT;
a177 3
	case 'h':
	    hflag = (HFLAG_DEFAULT)?0:1;
	    break;
d199 1
a199 1
	usage("bad arguments");
d740 1
a740 1
		error(errno, "strdup failed");
d746 1
a746 1
	    error(errno, "can't open file '%s'", name);
d766 1
a766 1
	    error(errno, "can't allocate memory for display block buffer");
d822 10
@


1.25
log
@Since we use the disklabel size info we are always in 'device size
mode' and '-c' and the '-d' command to toggle cflag are pointless
since cflag is never examined.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.24 2016/01/11 23:45:02 krw Exp $	*/
a61 1
#define INTERACT_DEFAULT	0
a90 1
int interactive = INTERACT_DEFAULT;
d109 1
a109 1
void edit(char *name, int ask_logical_size);
a113 1
void interact(void);
a140 2
    } else if (interactive) {
	interact();
d153 1
a153 1
	    edit(argv[name_index++], 0);
a161 124
void
interact()
{
    char *name;
    int command;
    int ask_logical_size;

    while (get_command("Top level command (? for help): ", first_get, &command)) {
	first_get = 0;
	ask_logical_size = 0;

	switch (command) {
	case '?':
	    // fall through
	case 'H':
	case 'h':
	    printf("Commands are:\n");
	    printf("  h    print help\n");
	    printf("  v    print the version number and release date\n");
	    printf("  l    list device's map\n");
	    printf("  e    edit device's map\n");
	    printf("  E    (edit map with specified block size)\n");
	    printf("  r    toggle readonly flag\n");
	    printf("  f    toggle show filesystem name flag\n");
	    if (dflag) {
		printf("  a    toggle abbreviate flag\n");
		printf("  p    toggle physical flag\n");
		printf("  d    toggle debug flag\n");
		printf("  x    examine block n of device\n");
	    }
	    printf("  q    quit the program\n");
	    break;
	case 'Q':
	case 'q':
	    return;
	    break;
	case 'l':
	    if (get_string_argument("Name of device: ", &name, 1) == 0) {
		bad_input("Bad name");
		break;
	    }
	    dump(name);
	    free(name);
	    break;
	case 'E':
	    ask_logical_size = 1;
	case 'e':
	    if (get_string_argument("Name of device: ", &name, 1) == 0) {
		bad_input("Bad name");
		break;
	    }
	    edit(name, ask_logical_size);
	    free(name);
	    break;
	case 'R':
	case 'r':
	    if (rflag) {
		rflag = 0;
	    } else {
		rflag = 1;
	    }
	    printf("Now in %s mode.\n", (rflag)?"readonly":"read/write");
	    break;
	case 'F':
	case 'f':
	    if (fflag) {
		fflag = 0;
	    } else {
		fflag = 1;
	    }
	    printf("Now in show %s name mode.\n", (fflag)?"filesystem":"partition");
	    break;
	case 'A':
	case 'a':
	    if (dflag) {
		if (aflag) {
		    aflag = 0;
		} else {
		    aflag = 1;
		}
		printf("Now in %s mode.\n", (aflag)?"abbreviate":"full type");
	    } else {
	    	goto do_error;
	    }
	    break;
	case 'P':
	case 'p':
	    if (dflag) {
		if (pflag) {
		    pflag = 0;
		} else {
		    pflag = 1;
		}
		printf("Now in %s mode.\n", (pflag)?"physical":"logical");
	    } else {
	    	goto do_error;
	    }
	    break;
	case 'D':
	case 'd':
	    if (dflag) {
		dflag = 0;
	    } else {
		dflag = 1;
	    }
	    printf("Now in %s mode.\n", (dflag)?"debug":"normal");
	    break;
	case 'X':
	case 'x':
	    if (dflag) {
		do_display_block(0, 0);
	    } else {
	    	goto do_error;
	    }
	    break;
	default:
	do_error:
	    bad_input("No such command (%c)", command);
	    break;
	}
    }
}


a176 1
    interactive = INTERACT_DEFAULT;
a192 3
	case 'i':
	    interactive = (INTERACT_DEFAULT)?0:1;
	    break;
d229 1
a229 1
edit(char *name, int ask_logical_size)
d237 1
a237 1
    map = open_partition_map(name, &valid_file, ask_logical_size);
@


1.24
log
@Remove some '-v' leftovers. Pointed out by jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.23 2016/01/11 23:31:27 krw Exp $	*/
a59 1
#define CFLAG_DEFAULT	0
a92 1
int cflag = CFLAG_DEFAULT;	/* compute device size */
a193 1
		printf("  c    toggle compute size flag\n");
a273 13
	case 'C':
	case 'c':
	    if (dflag) {
		if (cflag) {
		    cflag = 0;
		} else {
		    cflag = 1;
		}
		printf("Now in %s device size mode.\n", (cflag)?"always compute":"use existing");
	    } else {
	    	goto do_error;
	    }
	    break;
a306 1
    cflag = CFLAG_DEFAULT;
a318 3
	    break;
	case 'c':
	    cflag = (CFLAG_DEFAULT)?0:1;
@


1.23
log
@open_pathname_as_media() simply called open_file_as_media() which
takes the same parameters and returns the same value. Nuke
open_pathname_as_media() and call open_file_as_media() directly.

Nothing else from pathname.[ch] is used so remove them from build
in preparation for moving them to the attic.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.22 2016/01/11 18:43:06 krw Exp $	*/
a65 1
#define VFLAG_DEFAULT	0
a89 1
int vflag = VFLAG_DEFAULT;	/* show version */
d162 1
a162 1
    } else if (!vflag) {
a316 1
    vflag = VFLAG_DEFAULT;
a332 3
	    break;
	case 'v':
	    vflag = (VFLAG_DEFAULT)?0:1;
@


1.22
log
@Remove '-v' and related version handling. Use strncasecmp() instead
of handrolled local istrncmp(). No need to compile util.c anymore.

ok deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.21 2016/01/11 08:01:07 jasper Exp $	*/
a48 1
#include "pathname.h"
d53 1
d909 1
a909 1
	m = open_pathname_as_media(name, O_RDONLY);
@


1.21
log
@more whitespace was lurking
@
text
@d1 1
a1 1
/*	$OpenBSD: pdisk.c,v 1.20 2016/01/11 07:54:07 jasper Exp $	*/
a53 2
#include "version.h"
#include "util.h"
a131 1
    char *versionstr;
a142 8
    versionstr = (char *)get_version_string();
    if (versionstr) {
	if (strcmp(VERSION, versionstr) != 0) {
		fatal(-1, "Version string static form (%s) does not match dynamic form (%s)\n",
		    VERSION, versionstr);
	}
	free(versionstr);
    }
a145 3
    if (vflag) {
	printf("version " VERSION " (" RELEASE_DATE ")\n");
    }
a207 4
	case 'V':
	case 'v':
	    printf("version " VERSION " (" RELEASE_DATE ")\n");
	    break;
d541 1
a541 1
	if (istrncmp(type_name, kFreeType, DPISTRLEN) == 0) {
d545 1
a545 1
	if (istrncmp(type_name, kMapType, DPISTRLEN) == 0) {
@


1.20
log
@add rcs ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d152 1
a152 1
	free(versionstr); 
@


1.19
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 2
@


1.18
log
@Use __progname instead of manually handling argv[0].

ok deraadt, mmcc, tedu
@
text
@d568 1
a568 2
    if (type_name)
        free(type_name);
d570 1
a570 2
    if (name)
        free(name);
d705 1
a705 2
    if (type)
        free(type);
@


1.17
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@a133 2
    init_program_name(argv);

@


1.16
log
@remove mac68k leftovers
ok miod@@ mpi@@ deraadt@@ martin@@
@
text
@d950 1
a950 1
	display_block = (unsigned char *) malloc(g);
@


1.15
log
@use opendev(), as requested in 6373.  document this using text borrowed from
disklabel(8), and while at it, fix the usage code to not be utterly distasteful
ok drahn
@
text
@a104 3
#ifdef __m68k__
void do_update_dpme(partition_map *entry);
#endif
a525 22
#ifdef __m68k__
void
do_update_dpme(partition_map *entry)
{
    int slice = 0;
    if (!entry) return;
    dpme_init_flags(entry->data);
    entry->HFS_name = get_HFS_name(entry, &entry->HFS_kind);
    if (istrncmp(entry->data->dpme_type, kUnixType, DPISTRLEN) == 0) {
	printf("Available partition slices for %s:\n",entry->data->dpme_type);
	printf("  a   root partition\n");
	printf("  b   swap partition\n");
	printf("  c   do not set any bzb bits\n");
	printf("  g   user partition\n");
	printf("Other lettered values will create user partitions\n");
	get_command("Select a slice for default bzb values: ",0,&slice);
    }
    bzb_init_slice((BZB *)entry->data->dpme_bzb,slice);
    entry->the_map->changed = 1;
}
#endif

a568 3
#ifdef __m68k__
    do_update_dpme(find_entry_by_base(base,map));
#endif
a705 3
#ifdef __m68k__
    do_update_dpme(entry);
#endif
@


1.14
log
@partion -> partition. First one (mkfs.c) noted by Brad Tilley on tech@@.
@
text
@a174 1
	    usage("no device argument");
a181 1
	usage("no device argument");
@


1.13
log
@put back original getopt(3) handling lost during the update
@
text
@d140 1
a140 1
	fatal(-1, "Size of partion map entry (%d) "
@


1.12
log
@remove a bunch of linux and NeXT defines and, in turn, -D__unix__
@
text
@a32 1
#include <getopt.h>
d336 2
a337 19
    static struct option long_options[] =
    {
	// name		has_arg			&flag	val
	{"help",	no_argument,		0,	'h'},
	{"list",	optional_argument,	0,	kListOption},
	{"version",	no_argument,		0,	'v'},
	{"debug",	no_argument,		0,	'd'},
	{"readonly",	no_argument,		0,	'r'},
	{"abbr",	no_argument,		0,	'a'},
	{"fname",	no_argument,		0,	'f'},
	{"logical",	no_argument,		0,	kLogicalOption},
	{"interactive",	no_argument,		0,	'i'},
	{"compute_size", no_argument,		0,	'c'},
	{0, 0, 0, 0}
    };
    int option_index = 0;
    int getopt_error;		/* getopt choked */
    extern int optind;		/* next argv index */
    extern char *optarg;	/* pointer to argument */
a349 1
    fflag = FFLAG_DEFAULT;
d351 2
a352 10
    optind = 0;	// reset option scanner logic
    while ((c = getopt_long(argc, argv, "hlvdraLicf", long_options,
	    &option_index)) >= 0)
	{
	if (c == '?') {
	    getopt_error = 1;
	    c = optopt;
	} else {
	    getopt_error = 0;
	}
a353 3
	case kLongOption:
	    // option_index would be used here
	    break;
a356 5
	case kListOption:
	    if (optarg != NULL) {
		lfile = optarg;
	    }
	    // fall through
a371 3
	case 'f':
	    fflag = (FFLAG_DEFAULT)?0:1;
	    break;
a377 1
	case 'L':
a380 1
	case kBadOption:
@


1.11
log
@With last pdisk and full functionality for mac68k now in place, start
cleaning the maze of ifdef's not relevant for us.

This round wipes most linux and/or MacOS-only bits, more to come.
@
text
@a32 1
#if defined(__linux__) || defined(__OpenBSD__)
a33 1
#endif
a35 2

#ifdef __unix__
a36 1
#endif
a134 1
#if defined(__linux__) || defined(__unix__)
a135 9
#else
    SIOUXSettings.rows = 100;
    printf("This app uses the SIOUX console library\n");
    printf("Choose 'Quit' from the file menu to quit.\n\n");
    printf("Use fake disk names (/dev/scsi<bus>.<id>; i.e. /dev/scsi0.1, /dev/scsi1.3, etc.).\n\n");

    SIOUXSettings.autocloseonquit = 0;	/* Do we close the SIOUX window on program termination ... */
    SIOUXSettings.asktosaveonclose = 0;	/* Do we offer to save on a close ... */
#endif
a158 1
#if defined(__linux__) || defined(__unix__)
a187 9
#else
    interactive = 1;

    interact();

    SIOUXSettings.autocloseonquit = 1;
    //printf("Processing stopped: Choose 'Quit' from the file menu to quit.\n\n");
    return (0);
#endif
a332 1
#if defined(__linux__) || defined(__unix__)
a336 1
#if defined(__linux__) || defined(__OpenBSD__)
a352 3
#else
    extern int opterr;		/* who does error messages */
    extern int optopt;		/* char that caused the error */
a353 1
#endif
a369 1
#if defined(__linux__) || defined(__OpenBSD__)
a372 4
#else
    opterr = 0;			/* tell getopt to be quiet */
    while ((c = getopt(argc, argv, "hlvdraLicf")) != EOF)
#endif
a373 1
#if !(defined(__linux__) || defined(__OpenBSD__))
a379 1
#endif
a430 1
#endif
@


1.10
log
@update for pdisk 0.8a2, from NetBSD, retaining our local changes;
summing it up:

- Clean up sources - fix naming, delete old email addresses
- Added support for display of Mac volume names
- Fix block 0 display to show logical offset of drivers
- Require confirmation of quit without write
- Fix iteration to not complain about missing devices
- Warn when creating/writing a map with more than 15 entries

and, most important, add do_update_dpme() which allows us to partition
OpenBSD slices without previous MacOS setup.

Tested with shared MacOS install on macppc, procedure there remains the
same.

grammer and spelling help and ok jmc@@

ok miod@@
@
text
@a35 3
#ifdef __linux__
#include <malloc.h>
#else
a37 5
#if !defined(__unix__)
// for SIOUXsettings
#include <SIOUX.h>
#endif
#endif
a49 6
#ifdef __linux__
#include <sys/ioctl.h>
#include <linux/fs.h>
#include <linux/hdreg.h>
#endif

a131 3
#ifdef __linux__
void print_top_notes(void);
#endif
a191 3
#ifdef __linux__
	    list_all_disks();
#else
a193 1
#endif
a215 15
#ifdef __linux__
void
print_top_notes()
{
    printf("Notes:\n");
    printf("  Disks have fake names of the form /dev/scsi<bus>.<id>\n");
    printf("  For example, /dev/scsi0.1, /dev/scsi1.3, and so on.\n");
    printf("  Linux style names are also allowed (i.e /dev/sda or /dev/hda).\n");
    printf("  Due to some technical problems these names may not match\n");
    printf("  the 'real' linux names.\n");
    printf("\n");
}
#endif


a228 3
#ifdef __linux__
	    print_top_notes();
#endif
a235 3
#ifdef __linux__
	    printf("  L    list all devices' maps\n");
#endif
a256 5
#ifdef __linux__
	case 'L':
	    list_all_disks();
	    break;
#endif
a504 6
#if 0 /* this check is not found in linux fdisk-0.1 */
    if (map != NULL && map->blocks_in_map > MAX_LINUX_MAP) {
	error(-1, "Map contains more than %d blocks - Linux may have trouble", MAX_LINUX_MAP);
    }
#endif

a660 6
#if 0 /* this check is not found in linux fdisk-0.1 */
	if (map->blocks_in_map > MAX_LINUX_MAP) {
	    error(-1, "Map contains more than %d blocks - Linux may have trouble", MAX_LINUX_MAP);
	}
	goto xit1;
#endif
a673 5
#if 0 /* this check is not found in linux fdisk-0.1 */
	if (map->blocks_in_map > MAX_LINUX_MAP) {
	    error(-1, "Map contains more than %d blocks - Linux may have trouble", MAX_LINUX_MAP);
	}
#endif
a895 5
#if 0 /* this check is not found in linux fdisk-0.1 */
    if (map->blocks_in_map > MAX_LINUX_MAP) {
	error(-1, "Map contains more than %d blocks - Linux may have trouble", MAX_LINUX_MAP);
    }
#endif
@


1.9
log
@Check strdup return value for failure.  OK miod
@
text
@d4 1
a4 1
// Written by Eryk Vershen (eryk@@apple.com)
d33 3
a36 1
#include <getopt.h>
a37 2
#elif defined(__OpenBSD__)
#include <stdlib.h>
d41 1
d45 5
d68 1
d125 3
d143 6
a148 4
void interact();
void print_edit_notes();
void print_expert_notes();
void print_top_notes();
d157 1
a157 1
#if defined(__linux__) || defined (__OpenBSD__)
d160 1
d184 1
a184 1
    	if (strcmp(VERSION, versionstr) != 0) {
d187 2
a188 2
    	}
	free(versionstr);
d191 1
a191 1
#if defined(__linux__) || defined(__OpenBSD__)
d209 1
d211 4
d237 1
d244 3
a246 2
    printf("  MkLinux style names are also allowed (i.e /dev/sda or /dev/hda),\n");
    printf("  and these names follow the MkLinux DR3 conventions.\n");
d249 1
d265 1
d267 1
d275 1
d277 1
d281 1
d299 1
d303 1
d331 9
d405 1
a405 1
#ifdef __linux__
d410 1
d420 1
d427 7
a433 2
    extern int optind;
    extern char *optarg;
d446 1
d448 1
d450 15
a464 2
    while ((c = getopt_long(argc, argv, "hlvdric", long_options,
	    &option_index)) >= 0) {
d492 3
d501 1
a517 62
#ifdef __OpenBSD__
int
get_options(int argc, char **argv)
{
    int c;
    extern int optind;
    extern char *optarg;
    int flag = 0;

    lflag = LFLAG_DEFAULT;
    lfile = NULL;
    vflag = VFLAG_DEFAULT;
    hflag = HFLAG_DEFAULT;
    dflag = DFLAG_DEFAULT;
    rflag = RFLAG_DEFAULT;
    aflag = AFLAG_DEFAULT;
    pflag = PFLAG_DEFAULT;
    interactive = INTERACT_DEFAULT;
    cflag = CFLAG_DEFAULT;

    optind = 1;	// reset option scanner logic
    while ((c = getopt(argc, argv, "hlvdric")) != -1) {
	switch (c) {
	case 'h':
	    hflag = (HFLAG_DEFAULT)?0:1;
	    break;
	case 'l':
	    lflag = (LFLAG_DEFAULT)?0:1;
	    break;
	case 'v':
	    vflag = (VFLAG_DEFAULT)?0:1;
	    break;
	case 'd':
	    dflag = (DFLAG_DEFAULT)?0:1;
	    break;
	case 'c':
	    cflag = (CFLAG_DEFAULT)?0:1;
	    break;
	case 'r':
	    rflag = (RFLAG_DEFAULT)?0:1;
	    break;
	case 'i':
	    interactive = (INTERACT_DEFAULT)?0:1;
	    break;
	case 'a':
	    aflag = (AFLAG_DEFAULT)?0:1;
	    break;
	case kLogicalOption:
	    pflag = (PFLAG_DEFAULT)?0:1;
	    break;
	default:
	    flag = 1;
	    break;
	}
    }
    if (flag) {
	usage("bad arguments");
    }
    return optind;
}
#endif

d552 6
d570 3
a573 2
	    printf("  p    print the partition table\n");
	    printf("  P    (print ordered by base address)\n");
a574 3
	    printf("  s    change size of partition map\n");
	    printf("  c    create new partition (standard OpenBSD type)\n");
	    printf("  C    (create with type also specified)\n");
d576 3
a578 1
	    printf("  d    delete a partition\n");
d580 1
a584 1
	    printf("  q    quit editing (don't save changes)\n");
d597 5
d663 21
d690 2
a691 2
    char *name;
    char *type_name;
d697 1
a697 1
    if (!rflag && map->writeable == 0) {
d714 4
d719 1
a719 1

d733 5
d739 3
d743 2
a744 1
    free(type_name);
d746 2
a747 1
    free(name);
d812 1
a812 1
    long index;
d819 1
a819 1
    if (!rflag && map->writeable == 0) {
d822 1
a822 1
    if (get_number_argument("Partition number: ", &index, kDefault) == 0) {
d832 1
a832 1
    entry = find_entry_by_disk_address(index, map);
d848 1
a848 1
    long index;
d856 1
a856 1
    if (!rflag && map->writeable == 0) {
d860 1
a860 1
    if (get_number_argument("Partition number: ", &index, kDefault) == 0) {
d865 1
a865 1
    entry = find_entry_by_disk_address(index, map);
d879 3
d895 1
a895 1
    long index;
d901 1
a901 1
    if (!rflag && map->writeable == 0) {
d904 1
a904 1
    if (get_number_argument("Partition number: ", &index, kDefault) == 0) {
d910 1
a910 1
    cur = find_entry_by_disk_address(index, map);
d923 1
a923 1
    long index;
d929 1
a929 1
    if (!rflag && map->writeable == 0) {
d936 1
a936 1
    if (get_number_argument("New number: ", &index, kDefault) == 0) {
d941 1
a941 1
    move_entry_in_map(old_index, index, map);
d952 1
a952 1
    if (map->changed == 0) {
d956 1
a956 1
    if (map->writeable == 0) {
d960 5
d972 3
d1015 1
a1015 1
	    printf("  Q    quit without saving changes\n");
d1022 5
a1055 3
#ifndef __OpenBSD__
	do_error:
#endif
d1073 1
a1073 1
    if (!rflag && map->writeable == 0) {
d1093 1
d1122 1
a1122 1
    if (get_number_argument("Block number: ", &number, kDefault) == 0) {
d1139 1
d1141 1
@


1.8
log
@get rid of incorrectly sized buffer by using asprintf; ok millert
@
text
@d1045 4
a1048 1
	    name = strdup(alt_name);
@


1.7
log
@snprintf; drahn ok
@
text
@d155 1
d169 7
a175 3
    if (strcmp(VERSION, get_version_string()) != 0) {
	fatal(-1, "Version string static form (%s) does not match dynamic form (%s)\n",
		VERSION, get_version_string());
@


1.6
log
@more writable spelling; torh
@
text
@d1040 1
a1040 2
	    name = malloc(strlen(alt_name)+1);
	    strcpy(name, alt_name);
@


1.5
log
@rm trailing whitespace
@
text
@d660 1
a660 1
	printf("The map is not writeable.\n");
d768 1
a768 1
	printf("The map is not writeable.\n");
d805 1
a805 1
	printf("The map is not writeable.\n");
d847 1
a847 1
	printf("The map is not writeable.\n");
d875 1
a875 1
	printf("The map is not writeable.\n");
d902 1
a902 1
	bad_input("The map is not writeable.");
d1009 1
a1009 1
	printf("The map is not writeable.\n");
@


1.4
log
@New feature for pdisk, change the type of a parition.
Useful since that is part of the OpenBSD/macppc installation procedure.
Code by Alexander Guy,
examined by drahn@@
ok deraadt@@
@
text
@d11 17
a27 17
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
d151 1
a151 1
 
@


1.3
log
@return from main() don't exit
@
text
@d125 1
d563 1
a563 1
	    printf("  c    create new partition (standard MkLinux type)\n");
d568 1
d614 4
d789 43
@


1.2
log
@Make the apple code compile for OpenBSD. These changes are mostly from maja.
@
text
@d208 1
a208 1
    exit(0);
@


1.1
log
@Initial revision
@
text
@d36 2
d144 1
a144 1
#ifdef __linux__
d172 1
a172 1
#ifdef __linux__
d449 62
d939 1
d941 1
@


1.1.1.1
log
@Import of pdisk from apple, BSD licensed code. Archive dated Feb 18 1998 
This is a HFS partition editing tool.
@
text
@@
