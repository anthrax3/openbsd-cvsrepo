head	1.77;
access;
symbols
	OPENBSD_6_1:1.74.0.12
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.8
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.4
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.74.0.6
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.74.0.2
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.72.0.8
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.72.0.6
	OPENBSD_5_5_BASE:1.72
	OPENBSD_5_4:1.72.0.2
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.71.0.8
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.71.0.6
	OPENBSD_5_2_BASE:1.71
	OPENBSD_5_1_BASE:1.71
	OPENBSD_5_1:1.71.0.4
	OPENBSD_5_0:1.71.0.2
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.69.0.6
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.69.0.4
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.68.0.8
	OPENBSD_4_6_BASE:1.68
	OPENBSD_4_5:1.68.0.4
	OPENBSD_4_5_BASE:1.68
	OPENBSD_4_4:1.68.0.2
	OPENBSD_4_4_BASE:1.68
	OPENBSD_4_3:1.66.0.6
	OPENBSD_4_3_BASE:1.66
	OPENBSD_4_2:1.66.0.4
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.64.0.6
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.64.0.4
	OPENBSD_3_9_BASE:1.64
	OPENBSD_3_8:1.64.0.2
	OPENBSD_3_8_BASE:1.64
	OPENBSD_3_7:1.62.0.2
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.61.0.2
	OPENBSD_3_6_BASE:1.61
	OPENBSD_3_5:1.59.0.2
	OPENBSD_3_5_BASE:1.59
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36;
locks; strict;
comment	@ * @;


1.77
date	2017.08.11.22.30.38;	author benno;	state Exp;
branches;
next	1.76;
commitid	y1VyeV9JnotblbHq;

1.76
date	2017.07.15.16.01.14;	author awolk;	state Exp;
branches;
next	1.75;
commitid	0AKXaWuF261gsHLI;

1.75
date	2017.04.13.07.30.21;	author jsg;	state Exp;
branches;
next	1.74;
commitid	X6zbJDFVX01gsK09;

1.74
date	2015.01.20.17.19.05;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	OzaFaHwi8hYGzehL;

1.73
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.72;
commitid	Uu5nFG3wCl0LACBb;

1.72
date	2013.07.05.13.07.57;	author blambert;	state Exp;
branches;
next	1.71;

1.71
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.03.23.37.55;	author zinke;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.68;

1.68
date	2008.06.21.10.34.08;	author mcbride;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.10.20.55.02;	author mcbride;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.01.17.20.54;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.18.20.45.55;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.17.14.54.59;	author dhartmei;	state Exp;
branches;
next	1.63;

1.63
date	2005.05.21.21.03.58;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.12.22.17.17.55;	author dhartmei;	state Exp;
branches;
next	1.61;

1.61
date	2004.06.12.22.22.44;	author cedric;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.19.17.50.51;	author dhartmei;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.15.15.25.44;	author dhartmei;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.26.11.57.19;	author cedric;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.19.21.37.01;	author cedric;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.17.08.48.29;	author cedric;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.10.22.26.56;	author dhartmei;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.10.18.29.30;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.29.01.25.13;	author mcbride;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.31.22.14.41;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.31.11.18.24;	author cedric;	state Exp;
branches;
next	1.50;

1.50
date	2003.08.29.21.47.36;	author cedric;	state Exp;
branches;
next	1.49;

1.49
date	2003.07.31.22.25.54;	author cedric;	state Exp;
branches;
next	1.48;

1.48
date	2003.07.11.08.29.34;	author cedric;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.03.21.09.13;	author cedric;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.03.09.13.06;	author cedric;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.29.12.22.39;	author dhartmei;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.27.15.35.00;	author cedric;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.08.09.41.07;	author cedric;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.24.18.12.12;	author cedric;	state Exp;
branches;
next	1.41;

1.41
date	2003.04.30.12.30.27;	author cedric;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.27.16.02.08;	author cedric;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.25.19.07.28;	author pvalchev;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.05.23.56.32;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.27.18.01.57;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.07.15.16.33;	author cedric;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.14.17.17.27;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.05.08.52.08;	author cedric;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.04.17.29.06;	author cedric;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.04.12.10.02;	author cedric;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.03.14.51.36;	author cedric;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.03.08.42.15;	author cedric;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.25.23.17.34;	author cedric;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.25.18.16.05;	author cedric;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.25.16.33.19;	author cedric;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.23.16.10.29;	author cedric;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.22.01.15.32;	author cedric;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.18.22.18.09;	author cedric;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.18.15.00.24;	author cedric;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.18.11.46.06;	author cedric;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.14.21.58.12;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.14.10.42.32;	author cedric;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.11.21.54.43;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.11.21.50.57;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.10.16.09.19;	author cedric;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.10.14.21.21;	author cedric;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.09.18.59.02;	author dhartmei;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.09.18.55.32;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.07.00.21.08;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.03.23.31.26;	author cedric;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.03.23.00.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.03.22.57.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.03.22.54.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.03.22.50.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.03.22.24.19;	author cedric;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.03.21.55.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.03.21.53.35;	author cedric;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.03.21.43.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.03.21.37.44;	author cedric;	state Exp;
branches;
next	;


desc
@@


1.77
log
@add option -N (no domain resolution)
manpage wording and reminder about usage() jmc@@
ok florian@@ henning@@
@
text
@/*	$OpenBSD: pfctl_table.c,v 1.76 2017/07/15 16:01:14 awolk Exp $ */

/*
 * Copyright (c) 2002 Cedric Berger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/pfvar.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <limits.h>

#include "pfctl_parser.h"
#include "pfctl.h"

extern void	usage(void);
static int	pfctl_table(int, char *[], char *, const char *, char *,
		    const char *, int);
static void	print_table(struct pfr_table *, int, int);
static void	print_tstats(struct pfr_tstats *, int);
static int	load_addr(struct pfr_buffer *, int, char *[], char *, int, int);
static void	print_addrx(struct pfr_addr *, struct pfr_addr *, int);
static void	print_astats(struct pfr_astats *, int);
static void	radix_perror(void);
static void	xprintf(int, const char *, ...);
static void	print_iface(struct pfi_kif *, int);

static const char	*stats_text[PFR_DIR_MAX][PFR_OP_TABLE_MAX] = {
	{ "In/Block:",	"In/Match:",	"In/Pass:",	"In/XPass:" },
	{ "Out/Block:",	"Out/Match:",	"Out/Pass:",	"Out/XPass:" }
};

static const char	*istats_text[2][2][2] = {
	{ { "In4/Pass:", "In4/Block:" }, { "Out4/Pass:", "Out4/Block:" } },
	{ { "In6/Pass:", "In6/Block:" }, { "Out6/Pass:", "Out6/Block:" } }
};

#define RVTEST(fct) do {				\
		if ((!(opts & PF_OPT_NOACTION) ||	\
		    (opts & PF_OPT_DUMMYACTION)) &&	\
		    (fct)) {				\
			radix_perror();			\
			goto _error;			\
		}					\
	} while (0)

#define CREATE_TABLE do {						\
		table.pfrt_flags |= PFR_TFLAG_PERSIST;			\
		if ((!(opts & PF_OPT_NOACTION) ||			\
		    (opts & PF_OPT_DUMMYACTION)) &&			\
		    (pfr_add_tables(&table, 1, &nadd, flags)) &&	\
		    (errno != EPERM)) {					\
			radix_perror();					\
			goto _error;					\
		}							\
		if (nadd) {						\
			warn_namespace_collision(table.pfrt_name);	\
			xprintf(opts, "%d table created", nadd);	\
			if (opts & PF_OPT_NOACTION)			\
				return (0);				\
		}							\
		table.pfrt_flags &= ~PFR_TFLAG_PERSIST;			\
	} while(0)

void
pfctl_clear_tables(const char *anchor, int opts)
{
	if (pfctl_table(0, NULL, NULL, "-F", NULL, anchor, opts) == -1)
		exit(1);
}

void
pfctl_show_tables(const char *anchor, int opts)
{
	if (pfctl_table(0, NULL, NULL, "-s", NULL, anchor, opts) == -1)
		exit(1);
}

int
pfctl_command_tables(int argc, char *argv[], char *tname,
    const char *command, char *file, const char *anchor, int opts)
{
	if (tname == NULL || command == NULL)
		usage();
	return pfctl_table(argc, argv, tname, command, file, anchor, opts);
}

int
pfctl_table(int argc, char *argv[], char *tname, const char *command,
    char *file, const char *anchor, int opts)
{
	struct pfr_table	 table;
	struct pfr_buffer	 b, b2;
	struct pfr_addr		*a, *a2;
	int			 nadd = 0, ndel = 0, nchange = 0, nzero = 0;
	int			 rv = 0, flags = 0, nmatch = 0;
	void			*p;

	if (command == NULL)
		usage();
	if (opts & PF_OPT_NOACTION)
		flags |= PFR_FLAG_DUMMY;

	bzero(&b, sizeof(b));
	bzero(&b2, sizeof(b2));
	bzero(&table, sizeof(table));
	if (tname != NULL) {
		if (strlen(tname) >= PF_TABLE_NAME_SIZE)
			usage();
		if (strlcpy(table.pfrt_name, tname,
		    sizeof(table.pfrt_name)) >= sizeof(table.pfrt_name))
			errx(1, "pfctl_table: strlcpy");
	}
	if (strlcpy(table.pfrt_anchor, anchor,
	    sizeof(table.pfrt_anchor)) >= sizeof(table.pfrt_anchor))
		errx(1, "pfctl_table: strlcpy");

	if (!strcmp(command, "-F")) {
		if (argc || file != NULL)
			usage();
		RVTEST(pfr_clr_tables(&table, &ndel, flags));
		xprintf(opts, "%d tables deleted", ndel);
	} else if (!strcmp(command, "-s")) {
		b.pfrb_type = (opts & PF_OPT_VERBOSE2) ?
		    PFRB_TSTATS : PFRB_TABLES;
		if (argc || file != NULL)
			usage();
		for (;;) {
			pfr_buf_grow(&b, b.pfrb_size);
			b.pfrb_size = b.pfrb_msize;
			if (opts & PF_OPT_VERBOSE2)
				RVTEST(pfr_get_tstats(&table,
				    b.pfrb_caddr, &b.pfrb_size, flags));
			else
				RVTEST(pfr_get_tables(&table,
				    b.pfrb_caddr, &b.pfrb_size, flags));
			if (b.pfrb_size <= b.pfrb_msize)
				break;
		}

		if ((opts & PF_OPT_SHOWALL) && b.pfrb_size > 0)
			pfctl_print_title("TABLES:");

		PFRB_FOREACH(p, &b)
			if (opts & PF_OPT_VERBOSE2)
				print_tstats(p, opts & PF_OPT_DEBUG);
			else
				print_table(p, opts & PF_OPT_VERBOSE,
				    opts & PF_OPT_DEBUG);
	} else if (!strcmp(command, "kill")) {
		if (argc || file != NULL)
			usage();
		RVTEST(pfr_del_tables(&table, 1, &ndel, flags));
		xprintf(opts, "%d table deleted", ndel);
	} else if (!strcmp(command, "flush")) {
		if (argc || file != NULL)
			usage();
		RVTEST(pfr_clr_addrs(&table, &ndel, flags));
		xprintf(opts, "%d addresses deleted", ndel);
	} else if (!strcmp(command, "add")) {
		b.pfrb_type = PFRB_ADDRS;
		if (load_addr(&b, argc, argv, file, 0, opts))
			goto _error;
		CREATE_TABLE;
		if (opts & PF_OPT_VERBOSE)
			flags |= PFR_FLAG_FEEDBACK;
		RVTEST(pfr_add_addrs(&table, b.pfrb_caddr, b.pfrb_size,
		    &nadd, flags));
		xprintf(opts, "%d/%d addresses added", nadd, b.pfrb_size);
		if (opts & PF_OPT_VERBOSE)
			PFRB_FOREACH(a, &b)
				if ((opts & PF_OPT_VERBOSE2) || a->pfra_fback)
					print_addrx(a, NULL,
					    opts & PF_OPT_USEDNS);
	} else if (!strcmp(command, "delete")) {
		b.pfrb_type = PFRB_ADDRS;
		if (load_addr(&b, argc, argv, file, 0, opts))
			goto _error;
		if (opts & PF_OPT_VERBOSE)
			flags |= PFR_FLAG_FEEDBACK;
		RVTEST(pfr_del_addrs(&table, b.pfrb_caddr, b.pfrb_size,
		    &ndel, flags));
		xprintf(opts, "%d/%d addresses deleted", ndel, b.pfrb_size);
		if (opts & PF_OPT_VERBOSE)
			PFRB_FOREACH(a, &b)
				if ((opts & PF_OPT_VERBOSE2) || a->pfra_fback)
					print_addrx(a, NULL,
					    opts & PF_OPT_USEDNS);
	} else if (!strcmp(command, "replace")) {
		b.pfrb_type = PFRB_ADDRS;
		if (load_addr(&b, argc, argv, file, 0, opts))
			goto _error;
		CREATE_TABLE;
		if (opts & PF_OPT_VERBOSE)
			flags |= PFR_FLAG_FEEDBACK;
		for (;;) {
			int sz2 = b.pfrb_msize;

			RVTEST(pfr_set_addrs(&table, b.pfrb_caddr, b.pfrb_size,
			    &sz2, &nadd, &ndel, &nchange, flags));
			if (sz2 <= b.pfrb_msize) {
				b.pfrb_size = sz2;
				break;
			} else
				pfr_buf_grow(&b, sz2);
		}
		if (nadd)
			xprintf(opts, "%d addresses added", nadd);
		if (ndel)
			xprintf(opts, "%d addresses deleted", ndel);
		if (nchange)
			xprintf(opts, "%d addresses changed", nchange);
		if (!nadd && !ndel && !nchange)
			xprintf(opts, "no changes");
		if (opts & PF_OPT_VERBOSE)
			PFRB_FOREACH(a, &b)
				if ((opts & PF_OPT_VERBOSE2) || a->pfra_fback)
					print_addrx(a, NULL,
					    opts & PF_OPT_USEDNS);
	} else if (!strcmp(command, "expire")) {
		const char		*errstr;
		u_int			 lifetime;

		b.pfrb_type = PFRB_ASTATS;
		b2.pfrb_type = PFRB_ADDRS;
		if (argc != 1 || file != NULL)
			usage();
		lifetime = strtonum(*argv, 0, UINT_MAX, &errstr);
		if (errstr)
			errx(1, "expiry time: %s", errstr);
		for (;;) {
			pfr_buf_grow(&b, b.pfrb_size);
			b.pfrb_size = b.pfrb_msize;
			RVTEST(pfr_get_astats(&table, b.pfrb_caddr,
			    &b.pfrb_size, flags));
			if (b.pfrb_size <= b.pfrb_msize)
				break;
		}
		PFRB_FOREACH(p, &b) {
			((struct pfr_astats *)p)->pfras_a.pfra_fback = 0;
			if (time(NULL) - ((struct pfr_astats *)p)->pfras_tzero >
			     lifetime)
				if (pfr_buf_add(&b2,
				    &((struct pfr_astats *)p)->pfras_a))
					err(1, "duplicate buffer");
		}

		if (opts & PF_OPT_VERBOSE)
			flags |= PFR_FLAG_FEEDBACK;
		RVTEST(pfr_del_addrs(&table, b2.pfrb_caddr, b2.pfrb_size,
		    &ndel, flags));
		xprintf(opts, "%d/%d addresses expired", ndel, b2.pfrb_size);
		if (opts & PF_OPT_VERBOSE)
			PFRB_FOREACH(a, &b2)
				if ((opts & PF_OPT_VERBOSE2) || a->pfra_fback)
					print_addrx(a, NULL,
					    opts & PF_OPT_USEDNS);
	} else if (!strcmp(command, "show")) {
		b.pfrb_type = (opts & PF_OPT_VERBOSE) ?
			PFRB_ASTATS : PFRB_ADDRS;
		if (argc || file != NULL)
			usage();
		for (;;) {
			pfr_buf_grow(&b, b.pfrb_size);
			b.pfrb_size = b.pfrb_msize;
			if (opts & PF_OPT_VERBOSE)
				RVTEST(pfr_get_astats(&table, b.pfrb_caddr,
				    &b.pfrb_size, flags));
			else
				RVTEST(pfr_get_addrs(&table, b.pfrb_caddr,
				    &b.pfrb_size, flags));
			if (b.pfrb_size <= b.pfrb_msize)
				break;
		}
		PFRB_FOREACH(p, &b)
			if (opts & PF_OPT_VERBOSE)
				print_astats(p, opts & PF_OPT_USEDNS);
			else
				print_addrx(p, NULL, opts & PF_OPT_USEDNS);
	} else if (!strcmp(command, "test")) {
		b.pfrb_type = PFRB_ADDRS;
		b2.pfrb_type = PFRB_ADDRS;

		if (load_addr(&b, argc, argv, file, 1, opts))
			goto _error;
		if (opts & PF_OPT_VERBOSE2) {
			flags |= PFR_FLAG_REPLACE;
			PFRB_FOREACH(a, &b)
				if (pfr_buf_add(&b2, a))
					err(1, "duplicate buffer");
		}
		RVTEST(pfr_tst_addrs(&table, b.pfrb_caddr, b.pfrb_size,
		    &nmatch, flags));
		xprintf(opts, "%d/%d addresses match", nmatch, b.pfrb_size);
		if ((opts & PF_OPT_VERBOSE) && !(opts & PF_OPT_VERBOSE2))
			PFRB_FOREACH(a, &b)
				if (a->pfra_fback == PFR_FB_MATCH)
					print_addrx(a, NULL,
					    opts & PF_OPT_USEDNS);
		if (opts & PF_OPT_VERBOSE2) {
			a2 = NULL;
			PFRB_FOREACH(a, &b) {
				a2 = pfr_buf_next(&b2, a2);
				print_addrx(a2, a, opts & PF_OPT_USEDNS);
			}
		}
		if (nmatch < b.pfrb_size)
			rv = 2;
	} else if (!strcmp(command, "zero")) {
		if (argc || file != NULL)
			usage();
		flags |= PFR_FLAG_ADDRSTOO;
		RVTEST(pfr_clr_tstats(&table, 1, &nzero, flags));
		xprintf(opts, "%d table/stats cleared", nzero);
	} else
		warnx("pfctl_table: unknown command '%s'", command);
	goto _cleanup;

_error:
	rv = -1;
_cleanup:
	pfr_buf_clear(&b);
	pfr_buf_clear(&b2);
	return (rv);
}

void
print_table(struct pfr_table *ta, int verbose, int debug)
{
	if (!debug && !(ta->pfrt_flags & PFR_TFLAG_ACTIVE))
		return;
	if (verbose) {
		printf("%c%c%c%c%c%c%c\t%s",
		    (ta->pfrt_flags & PFR_TFLAG_CONST) ? 'c' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_PERSIST) ? 'p' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_ACTIVE) ? 'a' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_INACTIVE) ? 'i' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_REFERENCED) ? 'r' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_REFDANCHOR) ? 'h' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_COUNTERS) ? 'C' : '-',
		    ta->pfrt_name);
		if (ta->pfrt_anchor[0])
			printf("\t%s", ta->pfrt_anchor);
		puts("");
	} else
		puts(ta->pfrt_name);
}

void
print_tstats(struct pfr_tstats *ts, int debug)
{
	time_t	time = ts->pfrts_tzero;
	int	dir, op;

	if (!debug && !(ts->pfrts_flags & PFR_TFLAG_ACTIVE))
		return;
	print_table(&ts->pfrts_t, 1, debug);
	printf("\tAddresses:   %d\n", ts->pfrts_cnt);
	printf("\tCleared:     %s", ctime(&time));
	printf("\tReferences:  [ Anchors: %-18d Rules: %-18d ]\n",
	    ts->pfrts_refcnt[PFR_REFCNT_ANCHOR],
	    ts->pfrts_refcnt[PFR_REFCNT_RULE]);
	printf("\tEvaluations: [ NoMatch: %-18llu Match: %-18llu ]\n",
	    (unsigned long long)ts->pfrts_nomatch,
	    (unsigned long long)ts->pfrts_match);
	for (dir = 0; dir < PFR_DIR_MAX; dir++)
		for (op = 0; op < PFR_OP_TABLE_MAX; op++)
			printf("\t%-12s [ Packets: %-18llu Bytes: %-18llu ]\n",
			    stats_text[dir][op],
			    (unsigned long long)ts->pfrts_packets[dir][op],
			    (unsigned long long)ts->pfrts_bytes[dir][op]);
}

int
load_addr(struct pfr_buffer *b, int argc, char *argv[], char *file,
    int nonetwork, int opts)
{
	int	ev = 0;
	while (argc--)
		if ((ev = append_addr(b, *argv++, nonetwork, opts)) == -1) {
			if (errno)
				warn("cannot decode %s", argv[-1]);
			return (-1);
		}
	if (ev == 1) { /* expected further append_addr call */
		warnx("failed to decode %s", argv[-1]);
		return (-1);
	}
	if (pfr_buf_load(b, file, nonetwork, opts)) {
		warn("cannot load %s", file);
		return (-1);
	}
	return (0);
}

void
print_addrx(struct pfr_addr *ad, struct pfr_addr *rad, int dns)
{
	char		ch, buf[256] = "{error}";
	char		fb[] = { ' ', 'M', 'A', 'D', 'C', 'Z', 'X', ' ', 'Y', ' ' };
	unsigned int	fback, hostnet;

	fback = (rad != NULL) ? rad->pfra_fback : ad->pfra_fback;
	ch = (fback < sizeof(fb)/sizeof(*fb)) ? fb[fback] : '?';
	hostnet = (ad->pfra_af == AF_INET6) ? 128 : 32;
	inet_ntop(ad->pfra_af, &ad->pfra_u, buf, sizeof(buf));
	printf("%c %c%s", ch, (ad->pfra_not?'!':' '), buf);
	if (ad->pfra_net < hostnet)
		printf("/%d", ad->pfra_net);
	if (rad != NULL && fback != PFR_FB_NONE) {
		if (strlcpy(buf, "{error}", sizeof(buf)) >= sizeof(buf))
			errx(1, "print_addrx: strlcpy");
		inet_ntop(rad->pfra_af, &rad->pfra_u, buf, sizeof(buf));
		printf("\t%c%s", (rad->pfra_not?'!':' '), buf);
		if (rad->pfra_net < hostnet)
			printf("/%d", rad->pfra_net);
	}
	if (rad != NULL && fback == PFR_FB_NONE)
		printf("\t nomatch");
	if (dns && ad->pfra_net == hostnet) {
		char host[NI_MAXHOST];
		struct sockaddr_storage ss;

		strlcpy(host, "?", sizeof(host));
		bzero(&ss, sizeof(ss));
		ss.ss_family = ad->pfra_af;
		if (ss.ss_family == AF_INET) {
			struct sockaddr_in *sin = (struct sockaddr_in *)&ss;

			sin->sin_len = sizeof(*sin);
			sin->sin_addr = ad->pfra_ip4addr;
		} else {
			struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&ss;

			sin6->sin6_len = sizeof(*sin6);
			sin6->sin6_addr = ad->pfra_ip6addr;
		}
		if (getnameinfo((struct sockaddr *)&ss, ss.ss_len, host,
		    sizeof(host), NULL, 0, NI_NAMEREQD) == 0)
			printf("\t(%s)", host);
	}
	if (ad->pfra_ifname[0] != '\0')
		printf("@@%s", ad->pfra_ifname);
	printf("\n");
}

void
print_astats(struct pfr_astats *as, int dns)
{
	time_t	time = as->pfras_tzero;
	int	dir, op;

	print_addrx(&as->pfras_a, NULL, dns);
	printf("\tCleared:     %s", ctime(&time));
	if (as->pfras_a.pfra_states)
		printf("\tActive States:      %d\n", as->pfras_a.pfra_states);
	if (as->pfras_a.pfra_type == PFRKE_COST)
		printf("\tWeight:             %d\n", as->pfras_a.pfra_weight);	
	if (as->pfras_a.pfra_ifname[0])
		printf("\tInterface:          %s\n", as->pfras_a.pfra_ifname);
	if (as->pfras_a.pfra_fback == PFR_FB_NOCOUNT)
		return;
	for (dir = 0; dir < PFR_DIR_MAX; dir++)
		for (op = 0; op < PFR_OP_ADDR_MAX; op++)
			printf("\t%-12s [ Packets: %-18llu Bytes: %-18llu ]\n",
			    stats_text[dir][op],
			    (unsigned long long)as->pfras_packets[dir][op],
			    (unsigned long long)as->pfras_bytes[dir][op]);
}

void
radix_perror(void)
{
	extern char *__progname;
	fprintf(stderr, "%s: %s.\n", __progname, pfr_strerror(errno));
}

int
pfctl_define_table(char *name, int flags, int addrs, const char *anchor,
    struct pfr_buffer *ab, u_int32_t ticket)
{
	struct pfr_table tbl;

	bzero(&tbl, sizeof(tbl));
	if (strlcpy(tbl.pfrt_name, name, sizeof(tbl.pfrt_name)) >=
	    sizeof(tbl.pfrt_name) || strlcpy(tbl.pfrt_anchor, anchor,
	    sizeof(tbl.pfrt_anchor)) >= sizeof(tbl.pfrt_anchor))
		errx(1, "pfctl_define_table: strlcpy");
	tbl.pfrt_flags = flags;

	return pfr_ina_define(&tbl, ab->pfrb_caddr, ab->pfrb_size, NULL,
	    NULL, ticket, addrs ? PFR_FLAG_ADDRSTOO : 0);
}

void
warn_namespace_collision(const char *filter)
{
	struct pfr_buffer b;
	struct pfr_table *t;
	const char *name = NULL, *lastcoll;
	int coll = 0;

	bzero(&b, sizeof(b));
	b.pfrb_type = PFRB_TABLES;
	for (;;) {
		pfr_buf_grow(&b, b.pfrb_size);
		b.pfrb_size = b.pfrb_msize;
		if (pfr_get_tables(NULL, b.pfrb_caddr,
		    &b.pfrb_size, PFR_FLAG_ALLRSETS))
			err(1, "pfr_get_tables");
		if (b.pfrb_size <= b.pfrb_msize)
			break;
	}
	PFRB_FOREACH(t, &b) {
		if (!(t->pfrt_flags & PFR_TFLAG_ACTIVE))
			continue;
		if (filter != NULL && strcmp(filter, t->pfrt_name))
			continue;
		if (!t->pfrt_anchor[0])
			name = t->pfrt_name;
		else if (name != NULL && !strcmp(name, t->pfrt_name)) {
			coll++;
			lastcoll = name;
			name = NULL;
		}
	}
	if (coll == 1)
		warnx("warning: namespace collision with <%s> global table.",
		    lastcoll);
	else if (coll > 1)
		warnx("warning: namespace collisions with %d global tables.",
		    coll);
	pfr_buf_clear(&b);
}

void
xprintf(int opts, const char *fmt, ...)
{
	va_list args;

	if (opts & PF_OPT_QUIET)
		return;

	va_start(args, fmt);
	vfprintf(stderr, fmt, args);
	va_end(args);

	if (opts & PF_OPT_DUMMYACTION)
		fprintf(stderr, " (dummy).\n");
	else if (opts & PF_OPT_NOACTION)
		fprintf(stderr, " (syntax only).\n");
	else
		fprintf(stderr, ".\n");
}


/* interface stuff */

void
pfctl_show_ifaces(const char *filter, int opts)
{
	struct pfr_buffer	 b;
	struct pfi_kif		*p;
	int			 i = 0;

	bzero(&b, sizeof(b));
	b.pfrb_type = PFRB_IFACES;
	for (;;) {
		pfr_buf_grow(&b, b.pfrb_size);
		b.pfrb_size = b.pfrb_msize;
		if (pfi_get_ifaces(filter, b.pfrb_caddr, &b.pfrb_size)) {
			radix_perror();
			exit(1);
		}
		if (b.pfrb_size <= b.pfrb_msize)
			break;
		i++;
	}
	if (opts & PF_OPT_SHOWALL)
		pfctl_print_title("INTERFACES:");
	PFRB_FOREACH(p, &b)
		print_iface(p, opts);
}

void
print_iface(struct pfi_kif *p, int opts)
{
	time_t	tzero = p->pfik_tzero;
	int	i, af, dir, act;

	printf("%s", p->pfik_name);
	if (opts & PF_OPT_VERBOSE) {
		if (p->pfik_flags & PFI_IFLAG_SKIP)
			printf(" (skip)");
	}
	printf("\n");

	if (!(opts & PF_OPT_VERBOSE2))
		return;
	printf("\tCleared:     %s", ctime(&tzero));
	printf("\tReferences:  [ States:  %-18d Rules: %-18d ]\n",
	    p->pfik_states, p->pfik_rules);
	for (i = 0; i < 8; i++) {
		af = (i>>2) & 1;
		dir = (i>>1) &1;
		act = i & 1;
		printf("\t%-12s [ Packets: %-18llu Bytes: %-18llu ]\n",
		    istats_text[af][dir][act],
		    (unsigned long long)p->pfik_packets[af][dir][act],
		    (unsigned long long)p->pfik_bytes[af][dir][act]);
	}
}
@


1.76
log
@sbin/pfctl: void functions and exit(3) on error

Changes:
 voided:
  - pfctl_clear_tables
  - pfctl_show_tables
  - pfctl_show_ifaces

Those functions now exit(3) in case of error instead
of passing it up to the callers (where it was ignored).

OK mikeb@@, sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.75 2017/04/13 07:30:21 jsg Exp $ */
d61 1
a61 1
static int	load_addr(struct pfr_buffer *, int, char *[], char *, int);
d202 1
a202 1
		if (load_addr(&b, argc, argv, file, 0))
d217 1
a217 1
		if (load_addr(&b, argc, argv, file, 0))
d231 1
a231 1
		if (load_addr(&b, argc, argv, file, 0))
d324 1
a324 1
		if (load_addr(&b, argc, argv, file, 1))
d416 1
a416 1
    int nonetwork)
d420 1
a420 1
		if ((ev = append_addr(b, *argv++, nonetwork)) == -1) {
d429 1
a429 1
	if (pfr_buf_load(b, file, nonetwork)) {
@


1.75
log
@fix wrongly indented lines
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.74 2015/01/20 17:19:05 deraadt Exp $ */
d105 1
a105 1
int
d108 2
a109 1
	return pfctl_table(0, NULL, NULL, "-F", NULL, anchor, opts);
d112 1
a112 1
int
d115 2
a116 1
	return pfctl_table(0, NULL, NULL, "-s", NULL, anchor, opts);
d599 1
a599 1
int
d613 1
a613 1
			return (1);
a622 1
	return (0);
@


1.74
log
@Rewrite to void using union sockaddr_union
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.73 2015/01/16 06:40:00 deraadt Exp $ */
d499 1
a499 1
 	if (as->pfras_a.pfra_fback == PFR_FB_NOCOUNT)
@


1.73
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.72 2013/07/05 13:07:57 blambert Exp $ */
d37 2
a40 1
#include <arpa/inet.h>
d460 1
a460 1
		union sockaddr_union sa;
d463 7
a469 5
		bzero(&sa, sizeof(sa));
		sa.sa.sa_family = ad->pfra_af;
		if (sa.sa.sa_family == AF_INET) {
			sa.sa.sa_len = sizeof(sa.sin);
			sa.sin.sin_addr = ad->pfra_ip4addr;
d471 4
a474 2
			sa.sa.sa_len = sizeof(sa.sin6);
			sa.sin6.sin6_addr = ad->pfra_ip6addr;
d476 2
a477 2
		if (getnameinfo(&sa.sa, sa.sa.sa_len, host, sizeof(host),
		    NULL, 0, NI_NAMEREQD) == 0)
@


1.72
log
@Collect and display 'match' counters for pf tables.

While here, fix pf table displays to fit within 80 chars.

Manpage input jmc@@

ok henning@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.71 2011/07/27 00:26:10 mcbride Exp $ */
d50 1
@


1.71
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.70 2011/07/03 23:37:55 zinke Exp $ */
d67 2
a68 2
	{ "In/Block:",	"In/Pass:",	"In/XPass:" },
	{ "Out/Block:",	"Out/Pass:",	"Out/XPass:" }
d486 1
a486 1
	printf("\tCleared:            %s", ctime(&time));
d497 1
a497 1
			printf("\t%-19s [ Packets: %-18llu Bytes: %-18llu ]\n",
@


1.70
log
@bring in least-states load balancing algorithm

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.69 2010/01/12 03:20:51 mcbride Exp $ */
d414 1
d416 1
a416 1
		if (append_addr(b, *argv++, nonetwork)) {
d421 5
a425 1
	if (pfr_buf_load(b, file, nonetwork, append_addr)) {
d487 2
d490 3
a492 1
		printf("\tActive States:      %d\n", as->pfras_a.pfra_states);
a494 2
	if (as->pfras_a.pfra_ifname[0])
		printf("\tInterface:          %s\n", as->pfras_a.pfra_ifname);
@


1.69
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.68 2008/06/21 10:34:08 mcbride Exp $ */
d481 3
a483 1
	printf("\tCleared:     %s", ctime(&time));
d487 1
a487 1
		printf("\tInterface:   %s\n", as->pfras_a.pfra_ifname);
d490 1
a490 1
			printf("\t%-12s [ Packets: %-18llu Bytes: %-18llu ]\n",
@


1.68
log
@Fix "-T expire"; clear pfra_fback on addresses before sending them back to
the kernel to be deleted.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.67 2008/06/10 20:55:02 mcbride Exp $ */
d469 2
d484 2
@


1.67
log
@Make counters on table addresses optional and disabled by default.
Use the 'counters' table option in pf.conf if you actually need them.
If enabled, memory is not allocated until packets match an address.

This saves about 40% memory if counters are not being used, and paves the way
for some more significant cleanups coming soon.

ok henning mpf deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.66 2007/03/01 17:20:54 deraadt Exp $ */
d275 2
a276 1
		PFRB_FOREACH(p, &b)
d282 1
@


1.66
log
@be more careful with mixing &/| with &&/||, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.65 2007/01/18 20:45:55 henning Exp $ */
d367 1
a367 1
		printf("%c%c%c%c%c%c\t%s",
d374 1
d429 1
a429 1
	char		fb[] = { ' ', 'M', 'A', 'D', 'C', 'Z', 'X', ' ', 'Y' };
d478 2
@


1.65
log
@implement -T expire.
"pfctl -t tablename -T expire 3600" would expire all entries in the given
table that are older than 3600 seconds. ok dhartmei, manpage help & ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.64 2005/08/17 14:54:59 dhartmei Exp $ */
d177 1
a177 1
		if (opts & PF_OPT_SHOWALL && b.pfrb_size > 0)
d329 1
a329 1
		if (opts & PF_OPT_VERBOSE && !(opts & PF_OPT_VERBOSE2))
@


1.64
log
@with pfctl -vsI, indicate which interfaces are being skipped.
ok henning@@, markus@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.63 2005/05/21 21:03:58 henning Exp $ */
d253 36
@


1.63
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.62 2004/12/22 17:17:55 dhartmei Exp $ */
d571 4
@


1.62
log
@Introduce 'set skip on <ifspec>' to support a list of interfaces where no
packet filtering should occur (like loopback, for instance).
Code from Max Laier, with minor improvements based on feedback from
deraadt@@. ok mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.61 2004/06/12 22:22:44 cedric Exp $ */
d64 1
a64 2
static void	print_iface(struct pfi_if *, int);
static void	oprintf(int, int, const char *, int *, int);
d541 2
a542 2
	struct pfi_if		*p;
	int			 i = 0, f = PFI_FLAG_GROUP|PFI_FLAG_INSTANCE;
a543 2
	if (filter != NULL && *filter && !isdigit(filter[strlen(filter)-1]))
		f &= ~PFI_FLAG_INSTANCE;
d549 1
a549 1
		if (pfi_get_ifaces(filter, b.pfrb_caddr, &b.pfrb_size, f)) {
d565 1
a565 1
print_iface(struct pfi_if *p, int opts)
d567 1
a567 3
	time_t	tzero = p->pfif_tzero;
	int	flags = (opts & PF_OPT_VERBOSE) ? p->pfif_flags : 0;
	int	first = 1;
d570 1
a570 7
	printf("%s", p->pfif_name);
	oprintf(flags, PFI_IFLAG_INSTANCE, "instance", &first, 0);
	oprintf(flags, PFI_IFLAG_GROUP, "group", &first, 0);
	oprintf(flags, PFI_IFLAG_CLONABLE, "clonable", &first, 0);
	oprintf(flags, PFI_IFLAG_DYNAMIC, "dynamic", &first, 0);
	oprintf(flags, PFI_IFLAG_ATTACHED, "attached", &first, 0);
	oprintf(flags, PFI_IFLAG_SKIP, "skipped", &first, 1);
d577 1
a577 1
	    p->pfif_states, p->pfif_rules);
d584 2
a585 2
		    (unsigned long long)p->pfif_packets[af][dir][act],
		    (unsigned long long)p->pfif_bytes[af][dir][act]);
a587 12

void
oprintf(int flags, int flag, const char *s, int *first, int last)
{
	if (flags & flag) {
		printf(*first ? "\t(%s" : ", %s", s);
		*first = 0;
	}
	if (last && !*first)
		printf(")");
}

@


1.61
log
@Fix table add/replace commands with securelevel=2.
Reported by James J. Lippard. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.60 2004/05/19 17:50:51 dhartmei Exp $ */
d580 2
a581 1
	oprintf(flags, PFI_IFLAG_ATTACHED, "attached", &first, 1);
@


1.60
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.59 2004/03/15 15:25:44 dhartmei Exp $ */
d88 7
a94 1
		RVTEST(pfr_add_tables(&table, 1, &nadd, flags));	\
@


1.59
log
@cast %llu arguments to unsigned long long, from Max Laier,
ok henning@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.58 2004/02/26 11:57:19 cedric Exp $ */
d56 1
a56 1
		    const char *, const char *, int);
d99 1
a99 1
pfctl_clear_tables(const char *anchor, const char *ruleset, int opts)
d101 1
a101 1
	return pfctl_table(0, NULL, NULL, "-F", NULL, anchor, ruleset, opts);
d105 1
a105 1
pfctl_show_tables(const char *anchor, const char *ruleset, int opts)
d107 1
a107 1
	return pfctl_table(0, NULL, NULL, "-s", NULL, anchor, ruleset, opts);
d112 1
a112 2
    const char *command, char *file, const char *anchor, const char *ruleset,
    int opts)
d116 1
a116 2
	return pfctl_table(argc, argv, tname, command, file, anchor, ruleset,
	    opts);
d121 1
a121 1
    char *file, const char *anchor, const char *ruleset, int opts)
d146 1
a146 3
	    sizeof(table.pfrt_anchor)) >= sizeof(table.pfrt_anchor) ||
	    strlcpy(table.pfrt_ruleset, ruleset,
	    sizeof(table.pfrt_ruleset)) >= sizeof(table.pfrt_ruleset))
a335 2
		if (ta->pfrt_ruleset[0])
			printf(":%s", ta->pfrt_ruleset);
d453 1
a453 1
    const char *ruleset, struct pfr_buffer *ab, u_int32_t ticket)
d460 1
a460 3
	    sizeof(tbl.pfrt_anchor)) >= sizeof(tbl.pfrt_anchor) ||
	    strlcpy(tbl.pfrt_ruleset, ruleset, sizeof(tbl.pfrt_ruleset)) >=
	    sizeof(tbl.pfrt_ruleset))
@


1.58
log
@Fix pfctl -sa output. Found by David Krause, ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.57 2004/02/19 21:37:01 cedric Exp $ */
d362 2
a363 1
	    ts->pfrts_nomatch, ts->pfrts_match);
d367 3
a369 2
			    stats_text[dir][op], ts->pfrts_packets[dir][op],
			    ts->pfrts_bytes[dir][op]);
d445 3
a447 2
			    stats_text[dir][op], as->pfras_packets[dir][op],
			    as->pfras_bytes[dir][op]);
d595 3
a597 2
		    istats_text[af][dir][act], p->pfif_packets[af][dir][act],
		    p->pfif_bytes[af][dir][act]);
@


1.57
log
@Makes pfctl -ss and pfctl -sq use optional -i argument.
ok dhartmei@@ markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.56 2004/02/17 08:48:29 cedric Exp $ */
a158 1
		int i = 0;
a173 1
			i++;
d176 1
a176 1
		if (opts & PF_OPT_SHOWALL && i > 0)
@


1.56
log
@add -i flag, use it for -sI as a start. ok henning@@, ok+test mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.55 2004/02/10 22:26:56 dhartmei Exp $ */
d544 1
a544 1
	int i = 0;
d546 2
d553 1
a553 2
		if (pfi_get_ifaces(filter, b.pfrb_caddr, &b.pfrb_size,
		    PFI_FLAG_GROUP|PFI_FLAG_INSTANCE)) {
@


1.55
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.54 2004/02/10 18:29:30 henning Exp $ */
d540 1
a540 1
pfctl_show_ifaces(int opts)
d551 1
a551 1
		if (pfi_get_ifaces(NULL, b.pfrb_caddr, &b.pfrb_size,
@


1.54
log
@lotsoflotsoflotsof KNF
and an off by one
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.53 2004/01/29 01:25:13 mcbride Exp $ */
d125 6
a130 6
	struct pfr_table  table;
	struct pfr_buffer b, b2;
	struct pfr_addr	 *a, *a2;
	int		  nadd = 0, ndel = 0, nchange = 0, nzero = 0;
	int		  rv = 0, flags = 0, nmatch = 0;
	void		 *p;
@


1.53
log
@Clean up 'pfctl -s all' output.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.52 2003/12/31 22:14:41 deraadt Exp $ */
d172 1
a172 1
					b.pfrb_caddr, &b.pfrb_size, flags));
d186 1
a186 1
						opts & PF_OPT_DEBUG);
d205 1
a205 1
					&nadd, flags));
d211 1
a211 1
							opts & PF_OPT_USEDNS);
d219 1
a219 1
					&ndel, flags));
d225 1
a225 1
							opts & PF_OPT_USEDNS);
d237 1
a237 1
						&sz2, &nadd, &ndel, &nchange, flags));
d256 1
a256 1
							opts & PF_OPT_USEDNS);
d267 1
a267 1
							&b.pfrb_size, flags));
d270 1
a270 1
							&b.pfrb_size, flags));
d292 1
a292 1
					&nmatch, flags));
d298 1
a298 1
							opts & PF_OPT_USEDNS);
d326 1
a326 1
	void
d333 7
a339 7
				(ta->pfrt_flags & PFR_TFLAG_CONST) ? 'c' : '-',
				(ta->pfrt_flags & PFR_TFLAG_PERSIST) ? 'p' : '-',
				(ta->pfrt_flags & PFR_TFLAG_ACTIVE) ? 'a' : '-',
				(ta->pfrt_flags & PFR_TFLAG_INACTIVE) ? 'i' : '-',
				(ta->pfrt_flags & PFR_TFLAG_REFERENCED) ? 'r' : '-',
				(ta->pfrt_flags & PFR_TFLAG_REFDANCHOR) ? 'h' : '-',
				ta->pfrt_name);
d349 1
a349 1
	void
d361 2
a362 2
			ts->pfrts_refcnt[PFR_REFCNT_ANCHOR],
			ts->pfrts_refcnt[PFR_REFCNT_RULE]);
d364 1
a364 1
			ts->pfrts_nomatch, ts->pfrts_match);
d368 2
a369 3
					stats_text[dir][op],
					ts->pfrts_packets[dir][op],
					ts->pfrts_bytes[dir][op]);
d374 1
a374 1
		int nonetwork)
d389 1
a389 1
	void
d428 1
a428 1
					NULL, 0, NI_NAMEREQD) == 0)
d434 1
a434 1
	void
d445 2
a446 3
					stats_text[dir][op],
					as->pfras_packets[dir][op],
					as->pfras_bytes[dir][op]);
d449 1
a449 1
	void
d458 1
a458 1
		const char *ruleset, struct pfr_buffer *ab, u_int32_t ticket)
d463 5
a467 6
	if (strlcpy(tbl.pfrt_name, name,
				sizeof(tbl.pfrt_name)) >= sizeof(tbl.pfrt_name) ||
			strlcpy(tbl.pfrt_anchor, anchor,
				sizeof(tbl.pfrt_anchor)) >= sizeof(tbl.pfrt_anchor) ||
			strlcpy(tbl.pfrt_ruleset, ruleset,
				sizeof(tbl.pfrt_ruleset)) >= sizeof(tbl.pfrt_ruleset))
d472 1
a472 1
			NULL, ticket, addrs ? PFR_FLAG_ADDRSTOO : 0);
d475 1
a475 1
	void
d542 1
a542 1
	struct pfr_buffer 	 b;
d585 1
a585 1
        printf("\tCleared:     %s", ctime(&tzero));
d593 1
a593 2
		    istats_text[af][dir][act],
		    p->pfif_packets[af][dir][act],
@


1.52
log
@spacing.  note this, cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.51 2003/12/31 11:18:24 cedric Exp $ */
d159 1
d172 1
a172 1
				    b.pfrb_caddr, &b.pfrb_size, flags));
d175 1
d177 4
d186 1
a186 1
				    opts & PF_OPT_DEBUG);
d205 1
a205 1
		    &nadd, flags));
d211 1
a211 1
					    opts & PF_OPT_USEDNS);
d219 1
a219 1
		    &ndel, flags));
d225 1
a225 1
					    opts & PF_OPT_USEDNS);
d237 1
a237 1
			    &sz2, &nadd, &ndel, &nchange, flags));
d256 1
a256 1
					    opts & PF_OPT_USEDNS);
d259 1
a259 1
		    PFRB_ASTATS : PFRB_ADDRS;
d267 1
a267 1
				    &b.pfrb_size, flags));
d270 1
a270 1
				    &b.pfrb_size, flags));
d292 1
a292 1
		    &nmatch, flags));
d298 1
a298 1
					    opts & PF_OPT_USEDNS);
d326 1
a326 1
void
d333 7
a339 7
		    (ta->pfrt_flags & PFR_TFLAG_CONST) ? 'c' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_PERSIST) ? 'p' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_ACTIVE) ? 'a' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_INACTIVE) ? 'i' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_REFERENCED) ? 'r' : '-',
		    (ta->pfrt_flags & PFR_TFLAG_REFDANCHOR) ? 'h' : '-',
		    ta->pfrt_name);
d341 1
a341 1
		    printf("\t%s", ta->pfrt_anchor);
d343 1
a343 1
		    printf(":%s", ta->pfrt_ruleset);
d349 1
a349 1
void
d361 2
a362 2
	    ts->pfrts_refcnt[PFR_REFCNT_ANCHOR],
	    ts->pfrts_refcnt[PFR_REFCNT_RULE]);
d364 1
a364 1
	    ts->pfrts_nomatch, ts->pfrts_match);
d368 3
a370 3
			    stats_text[dir][op],
			    ts->pfrts_packets[dir][op],
			    ts->pfrts_bytes[dir][op]);
d375 1
a375 1
    int nonetwork)
d390 1
a390 1
void
d429 1
a429 1
		    NULL, 0, NI_NAMEREQD) == 0)
d435 1
a435 1
void
d446 3
a448 3
			    stats_text[dir][op],
			    as->pfras_packets[dir][op],
			    as->pfras_bytes[dir][op]);
d451 1
a451 1
void
d460 1
a460 1
    const char *ruleset, struct pfr_buffer *ab, u_int32_t ticket)
d466 5
a470 5
	    sizeof(tbl.pfrt_name)) >= sizeof(tbl.pfrt_name) ||
	    strlcpy(tbl.pfrt_anchor, anchor,
	    sizeof(tbl.pfrt_anchor)) >= sizeof(tbl.pfrt_anchor) ||
	    strlcpy(tbl.pfrt_ruleset, ruleset,
	    sizeof(tbl.pfrt_ruleset)) >= sizeof(tbl.pfrt_ruleset))
d475 1
a475 1
	    NULL, ticket, addrs ? PFR_FLAG_ADDRSTOO : 0);
d478 1
a478 1
void
d493 1
a493 1
				err(1, "pfr_get_tables");
d547 1
d561 1
d563 2
@


1.51
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.50 2003/08/29 21:47:36 cedric Exp $ */
d560 1
a560 1
void 
a566 1
	
@


1.50
log
@Document interactions between tables and anchors.
Add a warning on global/anchor name clashes to help prevent mistakes from our
users during the 3.3 -> 3.4 switch.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.49 2003/07/31 22:25:54 cedric Exp $ */
d64 2
d72 5
d532 72
@


1.49
log
@Make table tickets per-ruleset instead of global.
Make table tickets u_int32_t for consistency with other parts of PF.
Ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.48 2003/07/11 08:29:34 cedric Exp $ */
d83 1
d463 41
@


1.48
log
@Better parsing and -v support for tables:

  - remove the tableaddrs and tableaddr yacc production and reuse
    host_list instead.
  - produce better error messages.
  - do not load addresses from external file when it is not
    required (like with -R option).
  - store initializers in a new node_tinit linked list before
    putting them into the address buffer (see next point).
  - add a new print_tabledef() function, which makes "pfctl -nvf"
    print something useful for table definitions, which in turn
    makes it possible to write better regress tests (see first chunk
    of the diff) and bring table definition consistant with other
    parsed rules.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.47 2003/07/03 21:09:13 cedric Exp $ */
d446 1
a446 1
    const char *ruleset, struct pfr_buffer *ab, int ticket)
@


1.47
log
@Bye bye atexit(), bye bye globals...
The pfctl.c part will probably need some further improvements.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.46 2003/07/03 09:13:06 cedric Exp $ */
d445 2
a446 3
pfctl_define_table(char *name, int flags, int addrs, int noaction,
    const char *anchor, const char *ruleset, struct pfr_buffer *ab,
    int ticket)
a448 1
	int rv = 0;
d450 12
a461 18
	if (!noaction) {
		bzero(&tbl, sizeof(tbl));
		if (strlcpy(tbl.pfrt_name, name,
		    sizeof(tbl.pfrt_name)) >= sizeof(tbl.pfrt_name) ||
		    strlcpy(tbl.pfrt_anchor, anchor,
		    sizeof(tbl.pfrt_anchor)) >= sizeof(tbl.pfrt_anchor) ||
		    strlcpy(tbl.pfrt_ruleset, ruleset,
		    sizeof(tbl.pfrt_ruleset)) >= sizeof(tbl.pfrt_ruleset))
			errx(1, "pfctl_define_table: strlcpy");
		tbl.pfrt_flags = flags;

		if (pfr_ina_define(&tbl, ab->pfrb_caddr, ab->pfrb_size, NULL,
		    NULL, ticket, addrs ? PFR_FLAG_ADDRSTOO : 0) != 0) {
			rv = -1;
		}
	}
	pfr_buf_clear(ab);
	return (rv);
@


1.46
log
@This patch finally cleanup pfctl_table.c. No more global buffer,
and a couple of parsing functions moved to parse.y or pfctl_parser
where they belong.

I also took the opportunity to replace "void" functions with exit(1)
or err() inside by "int" functions, with the caller checking the
return value for errors (much cleaner and an old request from Theo)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.45 2003/06/29 12:22:39 dhartmei Exp $ */
a62 1
static void	inactive_cleanup(void);
a64 3
static int	 ticket, inactive;
extern char	*__progname;

d440 1
a443 15
void
pfctl_begin_table(void)
{
	static int hookreg;

	if (pfr_ina_begin(&ticket, NULL, 0) != 0) {
		radix_perror();
		exit(1);
	}
	if (!hookreg) {
		atexit(inactive_cleanup);
		hookreg = 1;
	}
}

d446 2
a447 1
    const char *anchor, const char *ruleset, struct pfr_buffer *ab)
a462 1
		inactive = 1;
a469 17
}

void
pfctl_commit_table(void)
{
	if (pfr_ina_commit(ticket, NULL, NULL, 0) != 0) {
		radix_perror();
		exit(1);
	}
	inactive = 0;
}

void
inactive_cleanup(void)
{
	if (inactive)
		pfr_ina_begin(NULL, NULL, 0);
@


1.45
log
@Replace assert(3) calls with warnx(3), if the warning is relevant at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.44 2003/06/27 15:35:00 cedric Exp $ */
a53 2
#define BUF_SIZE 256

a56 1
static void	grow_buffer(size_t, int);
d59 1
a59 2
static void	load_addr(int, char *[], char *, int);
static void	append_addr(char *, int);
d66 1
a66 9
static union {
	caddr_t			 caddr;
	struct pfr_table	*tables;
	struct pfr_addr		*addrs;
	struct pfr_tstats	*tstats;
	struct pfr_astats	*astats;
} buffer, buffer2;

static int	 size, msize, ticket, inactive;
d79 1
a79 1
			return (1);			\
d122 2
d125 2
a126 1
	int		  i, flags = 0, nmatch = 0;
d132 3
d148 1
d155 2
d160 9
a168 12
			if (opts & PF_OPT_VERBOSE2) {
				grow_buffer(sizeof(struct pfr_tstats), size);
				size = msize;
				RVTEST(pfr_get_tstats(&table, buffer.tstats,
				    &size, flags));
			} else {
				grow_buffer(sizeof(struct pfr_table), size);
				size = msize;
				RVTEST(pfr_get_tables(&table, buffer.tables,
				    &size, flags));
			}
			if (size <= msize)
d171 1
a171 1
		for (i = 0; i < size; i++)
d173 1
a173 2
				print_tstats(buffer.tstats+i,
				    opts & PF_OPT_DEBUG);
d175 1
a175 2
				print_table(buffer.tables+i,
				    opts & PF_OPT_VERBOSE,
d188 3
a190 1
		load_addr(argc, argv, file, 0);
d194 3
a196 3
		RVTEST(pfr_add_addrs(&table, buffer.addrs, size, &nadd,
		    flags));
		xprintf(opts, "%d/%d addresses added", nadd, size);
d198 3
a200 4
			for (i = 0; i < size; i++)
				if ((opts & PF_OPT_VERBOSE2) ||
				    buffer.addrs[i].pfra_fback)
					print_addrx(buffer.addrs+i, NULL,
d203 3
a205 1
		load_addr(argc, argv, file, 0);
d208 3
a210 3
		RVTEST(pfr_del_addrs(&table, buffer.addrs, size, &nadd,
		    flags));
		xprintf(opts, "%d/%d addresses deleted", nadd, size);
d212 3
a214 4
			for (i = 0; i < size; i++)
				if ((opts & PF_OPT_VERBOSE2) ||
				    buffer.addrs[i].pfra_fback)
					print_addrx(buffer.addrs+i, NULL,
d217 3
a219 1
		load_addr(argc, argv, file, 0);
d224 1
a224 1
			int size2 = msize;
d226 4
a229 4
			RVTEST(pfr_set_addrs(&table, buffer.addrs, size,
			    &size2, &nadd, &ndel, &nchange, flags));
			if (size2 <= msize) {
				size = size2;
d232 1
a232 1
				grow_buffer(sizeof(struct pfr_addr), size2);
d243 3
a245 4
			for (i = 0; i < size; i++)
				if ((opts & PF_OPT_VERBOSE2) ||
				    buffer.addrs[i].pfra_fback)
					print_addrx(buffer.addrs+i, NULL,
d248 2
d253 9
a261 12
			if (opts & PF_OPT_VERBOSE) {
				grow_buffer(sizeof(struct pfr_astats), size);
				size = msize;
				RVTEST(pfr_get_astats(&table, buffer.astats,
				    &size, flags));
			} else {
				grow_buffer(sizeof(struct pfr_addr), size);
				size = msize;
				RVTEST(pfr_get_addrs(&table, buffer.addrs,
				    &size, flags));
			}
			if (size <= msize)
d264 5
a268 8
		for (i = 0; i < size; i++)
			if (opts & PF_OPT_VERBOSE) {
				print_astats(buffer.astats+i,
				    opts & PF_OPT_USEDNS);
			} else {
				print_addrx(buffer.addrs+i, NULL,
				    opts & PF_OPT_USEDNS);
			}
d270 5
a274 1
		load_addr(argc, argv, file, 1);
d277 3
a279 5
			buffer2.caddr = calloc(sizeof(buffer.addrs[0]), size);
			if (buffer2.caddr == NULL)
				err(1, "calloc");
			memcpy(buffer2.addrs, buffer.addrs, size *
			    sizeof(buffer.addrs[0]));
d281 3
a283 3
		RVTEST(pfr_tst_addrs(&table, buffer.addrs, size, &nmatch,
		    flags));
		xprintf(opts, "%d/%d addresses match", nmatch, size);
d285 3
a287 3
			for (i = 0; i < size; i++)
				if (buffer.addrs[i].pfra_fback == PFR_FB_MATCH)
					print_addrx(buffer.addrs+i, NULL,
d290 5
a294 4
			for (i = 0; i < size; i++)
				print_addrx(buffer2.addrs+i, buffer.addrs+i,
				    opts & PF_OPT_USEDNS);
			free(buffer2.addrs);
d296 2
a297 2
		if (nmatch < size)
			return (2);
d306 1
a306 5
	if (buffer.caddr)
		free(buffer.caddr);
	size = msize = 0;
	return (0);
}
d308 6
a313 27
void
grow_buffer(size_t bs, int minsize)
{
	if (minsize != 0 && minsize <= msize) {
		warnx("grow_buffer: superfluous call");
		return;
	}
	if (!msize) {
		msize = minsize;
		if (msize < 64)
			msize = 64;
		buffer.caddr = calloc(bs, msize);
		if (buffer.caddr == NULL)
			err(1, "calloc");
	} else {
		int omsize = msize;
		if (minsize == 0)
			msize *= 2;
		else
			msize = minsize;
		if (msize < 0 || msize >= SIZE_T_MAX / bs)
			errx(1, "msize overflow");
		buffer.caddr = realloc(buffer.caddr, msize * bs);
		if (buffer.caddr == NULL)
			err(1, "realloc");
		bzero(buffer.caddr + omsize * bs, (msize-omsize) * bs);
	}
d363 3
a365 2
void
load_addr(int argc, char *argv[], char *file, int nonetwork)
d368 4
a371 51
		append_addr(*argv++, nonetwork);
	pfr_buf_load(file, nonetwork, append_addr);
}

void
append_addr(char *s, int test)
{
	char			 buf[BUF_SIZE], *r;
	int			 not = 0;
	struct node_host	*n, *h;

	for (r = s; *r == '!'; r++)
		not = !not;
	if (strlcpy(buf, r, sizeof(buf)) >= sizeof(buf))
		errx(1, "address too long");

	if ((n = host(buf)) == NULL)
		exit (1);

	do {
		if (size >= msize)
			grow_buffer(sizeof(struct pfr_addr), 0);
		buffer.addrs[size].pfra_not = not;
		switch (n->af) {
		case AF_INET:
			buffer.addrs[size].pfra_af = AF_INET;
			buffer.addrs[size].pfra_ip4addr.s_addr =
			    n->addr.v.a.addr.addr32[0];
			buffer.addrs[size].pfra_net =
			    unmask(&n->addr.v.a.mask, AF_INET);
			if (test && (not || buffer.addrs[size].pfra_net != 32))
				errx(1, "illegal test address");
			if (buffer.addrs[size].pfra_net > 32)
				errx(1, "illegal netmask %d",
				    buffer.addrs[size].pfra_net);
			break;
		case AF_INET6:
			buffer.addrs[size].pfra_af = AF_INET6;
			memcpy(&buffer.addrs[size].pfra_ip6addr,
			    &n->addr.v.a.addr.v6, sizeof(struct in6_addr));
			buffer.addrs[size].pfra_net =
			    unmask(&n->addr.v.a.mask, AF_INET6);
			if (test && (not || buffer.addrs[size].pfra_net != 128))
				errx(1, "illegal test address");
			if (buffer.addrs[size].pfra_net > 128)
				errx(1, "illegal netmask %d",
				    buffer.addrs[size].pfra_net);
			break;
		default:
			errx(1, "unknown address family %d", n->af);
			break;
d373 5
a377 5
		size++;
		h = n;
		n = n->next;
		free(h);
	} while (n != NULL);
d383 1
a383 1
	char		ch, buf[BUF_SIZE] = "{error}";
d462 1
a462 31
void
pfctl_append_addr(char *addr, int net, int neg)
{
	char *p = NULL;
	int rval;

	if (net < 0 && !neg) {
		append_addr(addr, 0);
		return;
	}
	if (net >= 0 && !neg)
		rval = asprintf(&p, "%s/%d", addr, net);
	else if (net < 0)
		rval = asprintf(&p, "!%s", addr);
	else
		rval = asprintf(&p, "!%s/%d", addr, net);
	if (rval == -1 || p == NULL) {
		radix_perror();
		exit(1);
	}
	append_addr(p, 0);
	free(p);
}

void
pfctl_append_file(char *file)
{
	load_addr(0, NULL, file, 0);
}

void
d464 1
a464 1
    const char *anchor, const char *ruleset)
d467 1
d481 3
a483 4
		if (pfr_ina_define(&tbl, buffer.addrs, size, NULL, NULL,
		    ticket, addrs ? PFR_FLAG_ADDRSTOO : 0) != 0) {
			radix_perror();
			exit(1);
d486 2
a487 2
	bzero(buffer.addrs, size * sizeof(buffer.addrs[0]));
	size = 0;
@


1.44
log
@Reorg part I: move 3 functions out of pf_table.c to pf_radix.c
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.43 2003/06/08 09:41:07 cedric Exp $ */
a40 1
#include <assert.h>
d311 1
a311 1
		assert(0);
d321 4
a324 1
	assert(minsize == 0 || minsize > msize);
@


1.43
log
@A table in an anchor creates a real anchor: pfctl -sA works.
The following two pfctl functions work with an "-a" option:
  - pfctl [-a foo[:bar]] -sT
  - pfctl [-a foo[:bar]] -FT
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.42 2003/05/24 18:12:12 cedric Exp $ */
a63 1
static int	next_token(char [], FILE *);
a394 3
	FILE	*fp;
	char	 buf[BUF_SIZE];

d397 1
a397 48
	if (file == NULL)
		return;
	if (!strcmp(file, "-"))
		fp = stdin;
	else {
		fp = fopen(file, "r");
		if (fp == NULL)
			err(1, "%s", file);
	}
	while (next_token(buf, fp))
		append_addr(buf, nonetwork);
	if (fp != stdin)
		fclose(fp);
}

int
next_token(char buf[BUF_SIZE], FILE *fp)
{
	static char	next_ch = ' ';
	int		i = 0;

	for (;;) {
		/* skip spaces */
		while (isspace(next_ch) && !feof(fp))
			next_ch = fgetc(fp);
		/* remove from '#' until end of line */
		if (next_ch == '#')
			while (!feof(fp)) {
				next_ch = fgetc(fp);
				if (next_ch == '\n')
					break;
			}
		else
			break;
	}
	if (feof(fp)) {
		next_ch = ' ';
		return (0);
	}
	do {
		if (i < BUF_SIZE)
			buf[i++] = next_ch;
		next_ch = fgetc(fp);
	} while (!feof(fp) && !isspace(next_ch));
	if (i >= BUF_SIZE)
		errx(1, "address too long (%d bytes)", i);
	buf[i] = '\0';
	return (1);
d519 1
a519 7
	if (errno == ESRCH)
		fprintf(stderr, "%s: Table does not exist.\n", __progname);
	else if (errno == ENOENT)
		fprintf(stderr, "%s: Anchor or Ruleset does not exist.\n",
		    __progname);
	else
		perror(__progname);
@


1.42
log
@Properly reset buffers after each "table" command.
More to come for the error case.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.41 2003/04/30 12:30:27 cedric Exp $ */
d159 1
a159 1
		RVTEST(pfr_clr_tables(&ndel, flags));
d168 2
a169 2
				RVTEST(pfr_get_tstats(buffer.tstats, &size,
				    flags));
d173 2
a174 2
				RVTEST(pfr_get_tables(buffer.tables, &size,
				    flags));
d572 3
@


1.41
log
@Allow tables to be loaded into anchors.
Most pfctl table commands (excluding 'show' and 'flush') support the "-a"
modifier.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.40 2003/04/27 16:02:08 cedric Exp $ */
d298 1
a298 1
		if (opts & PF_OPT_VERBOSE2)
d302 2
d314 3
@


1.40
log
@Update the pfioc_table IOCTL structure.
Prepare for anchors, improve robustness.
WARNING: need to sync kernel/userland.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.39 2003/04/25 19:07:28 pvalchev Exp $ */
d58 2
a59 1
static int	pfctl_table(int, char *[], char *, const char *, char *, int);
d109 1
a109 1
pfctl_clear_tables(int opts)
d111 1
a111 1
	return pfctl_table(0, NULL, NULL, "-F", NULL, opts);
d115 1
a115 1
pfctl_show_tables(int opts)
d117 1
a117 1
	return pfctl_table(0, NULL, NULL, "-s", NULL, opts);
d122 2
a123 1
    const char *command, char *file, int opts)
d127 2
a128 1
	return pfctl_table(argc, argv, tname, command, file, opts);
d133 1
a133 1
    char *file, int opts)
d151 5
d347 1
a347 1
		printf("%c%c%c%c%c\t%s\n",
d353 1
d355 5
a373 1
	printf("\tReferences:  %d\n", ts->pfrts_refcnt[PFR_REFCNT_RULE]);
d375 3
d617 2
a618 1
pfctl_define_table(char *name, int flags, int addrs, int noaction)
d624 6
a629 2
		if (strlcpy(tbl.pfrt_name, name, sizeof(tbl.pfrt_name)) >=
		    sizeof(tbl.pfrt_name))
@


1.39
log
@check asprintf return value for error as well, some implementations do
not set the pointer to NULL necessarily; ok dhartmei, henning, kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.38 2003/04/05 23:56:32 henning Exp $ */
d360 1
a360 1
	printf("\tReferences:  %d\n", ts->pfrts_refcnt);
@


1.38
log
@ease netmask handling a bit

input theo, ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.37 2003/03/27 18:01:57 henning Exp $ */
d574 1
d581 1
a581 1
		asprintf(&p, "%s/%d", addr, net);
d583 1
a583 1
		asprintf(&p, "!%s", addr);
d585 2
a586 2
		asprintf(&p, "!%s/%d", addr, net);
	if (p == NULL) {
@


1.37
log
@lotsa const char *
from David Hill <david at phobia.ms> a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.36 2003/03/07 15:16:33 cedric Exp $ */
d442 1
a442 1
	if ((n = host(buf, -1)) == NULL)
@


1.36
log
@Only show non-active tables when the -g flag is given.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.35 2003/02/14 17:17:27 henning Exp $ */
d58 1
a58 1
static int	pfctl_table(int, char *[], char *, char *, char *, int);
d69 1
a69 1
static void	xprintf(int, char *, ...);
d82 1
a82 1
static char	*stats_text[PFR_DIR_MAX][PFR_OP_TABLE_MAX] = {
d121 1
a121 1
    char *command, char *file, int opts)
d129 1
a129 1
pfctl_table(int argc, char *argv[], char *tname, char *command,
d640 1
a640 1
xprintf(int opts, char *fmt, ...)
@


1.35
log
@remove explicit table creation ( -T create ), it's useless.

ok pb@@ mcbride@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.34 2003/02/05 08:52:08 cedric Exp $ */
d60 1
a60 1
static void	print_table(struct pfr_table *, int);
d174 1
a174 1
				    opts & PF_OPT_VERBOSE);
d177 2
a178 1
				    opts & PF_OPT_VERBOSE);
d334 1
a334 1
print_table(struct pfr_table *ta, int all)
d336 1
a336 1
	if (!all && !(ta->pfrt_flags & PFR_TFLAG_ACTIVE))
d338 1
a338 1
	if (all) {
d351 1
a351 1
print_tstats(struct pfr_tstats *ts, int all)
d356 1
a356 1
	if (!all && !(ts->pfrts_flags & PFR_TFLAG_ACTIVE))
d358 1
a358 1
	print_table(&ts->pfrts_t, all);
@


1.34
log
@Do not scare ppl too much.
Suggested by camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.33 2003/02/04 17:29:06 cedric Exp $ */
a177 6
	} else if (!strcmp(command, "create")) {
		if (argc || file != NULL)
			usage();
		table.pfrt_flags = PFR_TFLAG_PERSIST;
		RVTEST(pfr_add_tables(&table, 1, &nadd, flags));
		xprintf(opts, "%d table added", nadd);
@


1.33
log
@use size_t for struct size and offset calculations.
check msize for overflow and realloc overflow.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.32 2003/02/04 12:10:02 cedric Exp $ */
d330 1
a330 1
			err(1, "buffer overflow");
@


1.32
log
@Cleanup buffer before reuse. Consistency + defensive programming.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.31 2003/02/03 14:51:36 cedric Exp $ */
d59 1
a59 1
static void	grow_buffer(int, int);
d313 1
a313 1
grow_buffer(int bs, int minsize)
d329 2
@


1.31
log
@remove loadopt global definition and cleanup a bit.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.30 2003/02/03 08:42:15 cedric Exp $ */
d621 1
@


1.30
log
@More cleanup in tables thanks to Andrey Matveev:
 - get rid of unnecessary header netinet/in.h in pfctl_radix.c and pfctl_table.c
 - do fclose(3) only when we use config file, not STDIN
 - get rid of unneeded temporatory variables
 - minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.29 2003/01/25 23:17:34 cedric Exp $ */
a562 2
	if ((loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)) == 0)
		return;
d607 13
a619 15
	if (noaction || (loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)) == 0) {
		size = 0;
		return;
	}
	bzero(&tbl, sizeof(tbl));
	if (strlcpy(tbl.pfrt_name, name, sizeof(tbl.pfrt_name)) >=
	    sizeof(tbl.pfrt_name))
		errx(1, "pfctl_define_table: strlcpy");
	tbl.pfrt_flags = flags;

	inactive = 1;
	if (pfr_ina_define(&tbl, buffer.addrs, size, NULL, NULL, ticket,
	    addrs ? PFR_FLAG_ADDRSTOO : 0) != 0) {
		radix_perror();
		exit(1);
a626 2
	if ((loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)) == 0)
		return;
@


1.29
log
@Another nice cleanup patch from Andrey Matveev
KNF + remove/reorg headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.28 2003/01/25 18:16:05 cedric Exp $ */
a37 1
#include <netinet/in.h>
d394 2
a395 1
	fclose(fp);
a561 1
	int rv;
d565 1
a565 2
	rv = pfr_ina_begin(&ticket, NULL, 0);
	if (rv) {
a607 1
	int rv;
d620 2
a621 3
	rv = pfr_ina_define(&tbl, buffer.addrs, size, NULL, NULL, ticket,
	    addrs ? PFR_FLAG_ADDRSTOO : 0);
	if (rv) {
d629 1
a629 1
pfctl_commit_table()
a630 2
	int rv;

d633 1
a633 2
	rv = pfr_ina_commit(ticket, NULL, NULL, 0);
	if (rv) {
d641 1
a641 1
inactive_cleanup()
@


1.28
log
@Fix NOACTION with table statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.27 2003/01/25 16:33:19 cedric Exp $ */
d42 2
a45 3
#include <time.h>
#include <fcntl.h>
#include <limits.h>
d47 1
d51 1
a51 4
#include <stdarg.h>
#include <unistd.h>
#include <ctype.h>
#include <assert.h>
d53 1
a54 1
#include "pfctl_parser.h"
d493 1
a493 1
	unsigned	fback, hostnet;
@


1.27
log
@Permit initialisation of a table content from a file in pf.conf.
Cleaning up of the table options parsing, more flexible.
idea+cleanup deraadt@@, ok dhartmei@@, pass all regress tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.26 2003/01/23 16:10:29 cedric Exp $ */
d610 1
a610 1
pfctl_define_table(char *name, int flags, int addrs)
d615 1
a615 1
	if ((loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)) == 0) {
@


1.26
log
@Little cleanup thanks to Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.25 2003/01/22 01:15:32 cedric Exp $ */
d601 6
@


1.25
log
@Automatically create tables for the "add" and "replace" table commands.
Requested by deraadt@@, pass all regress tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.24 2003/01/18 22:18:09 cedric Exp $ */
d516 1
a516 1
		char host[NI_MAXHOST] = "?";
a517 1
		int rv;
d519 1
a520 2
		sa.sa.sa_len = (ad->pfra_af == AF_INET) ?
		    sizeof(sa.sin) : sizeof(sa.sin6);
d522 2
a523 1
		if (ad->pfra_af == AF_INET)
d525 2
a526 1
		else
d528 3
a530 3
		rv = getnameinfo(&sa.sa, sa.sa.sa_len, host, sizeof(host),
		    NULL, 0, NI_NAMEREQD);
		if (!rv)
@


1.24
log
@va_end() missing. Thanks to Andrey Matveev.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.23 2003/01/18 15:00:24 cedric Exp $ */
d100 11
d200 1
d227 1
@


1.23
log
@Cleanup PF_OPT_NOACTION with tables. No changes on current behaviour,
but do something useful when the user has no access to /dev/pf.
Tested on i386, sparc64.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.22 2003/01/18 11:46:06 cedric Exp $ */
d645 1
d648 2
@


1.22
log
@Little cleanup from Andrey Matveev <andrushock@@korovino.net>
Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.21 2003/01/14 21:58:12 henning Exp $ */
d51 1
d73 1
a90 2

#define DUMMY ((flags & PFR_FLAG_DUMMY)?" (dummy)":"")
d92 3
a94 2
		int rv = fct;				\
		if (rv) {				\
d145 1
a145 3
		if (!(opts & PF_OPT_QUIET))
			fprintf(stderr, "%d tables deleted%s.\n", ndel,
			    DUMMY);
d176 1
a176 2
		if (!(opts & PF_OPT_QUIET))
			fprintf(stderr, "%d table added%s.\n", nadd, DUMMY);
d181 1
a181 2
		if (!(opts & PF_OPT_QUIET))
			fprintf(stderr, "%d table deleted%s.\n", ndel, DUMMY);
d186 1
a186 3
		if (!(opts & PF_OPT_QUIET))
			fprintf(stderr, "%d addresses deleted%s.\n", ndel,
				DUMMY);
d193 1
a193 3
		if (!(opts & PF_OPT_QUIET))
			fprintf(stderr, "%d/%d addresses added%s.\n", nadd,
			    size, DUMMY);
d206 1
a206 3
		if (!(opts & PF_OPT_QUIET))
			fprintf(stderr, "%d/%d addresses deleted%s.\n", nadd,
			    size, DUMMY);
d228 8
a235 13
		if (!(opts & PF_OPT_QUIET)) {
			if (nadd)
				fprintf(stderr, "%d addresses added%s.\n",
				    nadd, DUMMY);
			if (ndel)
				fprintf(stderr, "%d addresses deleted%s.\n",
				    ndel, DUMMY);
			if (nchange)
				fprintf(stderr, "%d addresses changed%s.\n",
				    nchange, DUMMY);
			if (!nadd && !ndel && !nchange)
				fprintf(stderr, "no changes%s.\n", DUMMY);
		}
d280 1
a280 2
		if (!(opts & PF_OPT_QUIET))
			printf("%d/%d addresses match.\n", nmatch, size);
d297 1
a297 3
		if (!(opts & PF_OPT_QUIET))
			fprintf(stderr, "%d table/stats cleared%s.\n", nzero,
			    DUMMY);
d636 17
@


1.21
log
@unified IP parser:
-move host(), set_ipmask and the ifa_* functions to pfctl_parser.[c|h]
-extend host() to handle /mask itself, plus minor adjustments
-use that in pfctl_table.c instead of coding the same shit again

discussed w/ cedric@@
ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.20 2003/01/14 10:42:32 cedric Exp $ */
d287 2
a288 4
			if (buffer2.caddr == NULL) {
				perror(__progname);
				return 1;
			}
d329 2
d338 3
a340 6
		if (buffer.caddr)
			bzero(buffer.caddr + omsize * bs, (msize-omsize) * bs);
	}
	if (!buffer.caddr) {
		perror(__progname);
		exit(1);
d397 2
a398 4
		if (fp == NULL) {
			perror(__progname);
			exit(1);
		}
a483 1
			break;
d620 1
a620 1
		errx(1, "pfctl_define_table");
@


1.20
log
@A bit of consistency in error messages. Before regress commit :)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.19 2003/01/11 21:54:43 henning Exp $ */
d60 1
a60 1
extern void	 usage(void);
d448 3
a450 4
	char		 buf[BUF_SIZE], *p, *q, *r;
	struct addrinfo *res, *ai, hints;
	int		 not = 0, net = -1, rv;
	struct in_addr	 ina;
d456 5
a460 8
	p = strrchr(buf, '/');
	if (test && (not || p))
		errx(1, "illegal test address");

	memset(&ina, 0, sizeof(struct in_addr));
	if ((net = inet_net_pton(AF_INET, buf, &ina, sizeof(&ina))) > -1) {
		if (test && net != 32)
			errx(1, "illegal test address");
a462 1
		buffer.addrs[size].pfra_ip4addr.s_addr = ina.s_addr;
d464 1
a464 20
		buffer.addrs[size].pfra_net = net;
		buffer.addrs[size].pfra_af = AF_INET;
		size++;
		return;
	}

	if (p) {
		net = strtol(p+1, &q, 0);
		if (!q || *q)
			errx(1, "illegal network: \"%s\"", p+1);
		*p++ = '\0';
	}

	bzero(&hints, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;
	rv = getaddrinfo(buf, NULL, &hints, &res);
	if (rv)
		errx(1, "illegal address: \"%s\"", buf);
	for (ai = res; ai; ai = ai->ai_next) {
		switch (ai->ai_family) {
a465 8
			if (net > 32)
				errx(1, "illegal netmask: \"%d\"", net);
			if (size >= msize)
				grow_buffer(sizeof(struct pfr_addr), 0);
			buffer.addrs[size].pfra_ip4addr =
			    ((struct sockaddr_in *)ai->ai_addr)->sin_addr;
			buffer.addrs[size].pfra_not = not;
			buffer.addrs[size].pfra_net = (net >= 0) ? net : 32;
d467 9
a475 1
			size++;
a477 8
			if (net > 128)
				errx(1, "illegal netmask: \"%d\"", net);
			if (size >= msize)
				grow_buffer(sizeof(struct pfr_addr), 0);
			buffer.addrs[size].pfra_ip6addr =
				((struct sockaddr_in6 *)ai->ai_addr)->sin6_addr;
			buffer.addrs[size].pfra_not = not;
			buffer.addrs[size].pfra_net = (net >= 0) ? net : 128;
d479 13
a491 1
			size++;
d494 5
a498 2
	}
	freeaddrinfo(res);
@


1.19
log
@use errx instead of handcrufting the same with fprintf and exit
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.18 2003/01/11 21:50:57 henning Exp $ */
d491 1
a491 1
				errx(1, "invalid netmask %d", net);
d503 1
a503 1
				errx(1, "invalid netmask %d", net);
@


1.18
log
@-use inet_net_pton to parse IPv4 addresses, gains us support for CIDR (10/8)
-remove a redundant strlen check

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.17 2003/01/10 16:09:19 cedric Exp $ */
d439 2
a440 5
	if (i >= BUF_SIZE) {
		fprintf(stderr, "%s: address too long (%d bytes)\n",
		    __progname, i);
		exit(1);
	}
d477 2
a478 5
		if (!q || *q) {
			fprintf(stderr, "%s: illegal network: \"%s\"\n",
			    __progname, p+1);
			exit(1);
		}
d485 2
a486 5
	if (rv) {
		fprintf(stderr, "%s: illegal address: \"%s\"\n", __progname,
		    buf);
		exit(1);
	}
d490 2
a491 5
			if (net > 32) {
				fprintf(stderr, "%s: network too big: %d\n",
				    __progname, net);
				exit(1);
			}
d502 2
a503 5
			if (net > 128) {
				fprintf(stderr, "%s: network too big: %d\n",
				    __progname, net);
				exit(1);
			}
@


1.17
log
@Fix adding and deleting addresses in a table when there is a conflict with
the "negated" attribute of an address. The previous behaviour was incorrect
in both cases (too strict for the add command and too permissive for the
delete command).
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.16 2003/01/10 14:21:21 cedric Exp $ */
d454 1
a457 7
	bzero(&hints, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM;
	if (strlen(s) >= BUF_SIZE) {
		fprintf(stderr, "%s: address too long (%ld bytes)\n",
		    __progname, (long)strlen(s));
		exit(1);
	}
d459 1
a459 1
		errx(1, "append_addr: strlcpy");
d462 16
a477 2
		fprintf(stderr, "%s: illegal test address: \"%s\"\n",
		    __progname, s);
d487 3
@


1.16
log
@Be a bit more strict when parsing options.
Disallow "pfctl -s rabbits" and friends.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.15 2003/01/09 18:59:02 dhartmei Exp $ */
d451 1
a451 1
	char		 buf[BUF_SIZE], *p, *q;
d453 1
a453 1
	int		 not = (*s == '!'), net = -1, rv;
d455 2
d464 1
a464 1
	if (strlcpy(buf, s+not, sizeof(buf)) >= sizeof(buf))
d525 3
a527 3
	char		buf[BUF_SIZE] = "{error}";
	const char	fb[] = { ' ', 'M', 'A', 'D', 'C', 'Z', 'X', ' ' };
	int		fback, hostnet;
d530 1
d533 1
a533 1
	printf("%c %c%s", fb[fback], (ad->pfra_not?'!':' '), buf);
@


1.15
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.14 2003/01/09 18:55:32 dhartmei Exp $ */
a83 15
static char	*commands[] = {
	"-F",		/* pfctl -F tables: flush all tables */
	"-s",		/* pfctl -s tables: show all tables */
	"create",	/* create a new table */
	"kill",		/* kill a table */
	"flush",	/* flush all addresses of a table */
	"add",		/* add one or more addresses in a table */
	"delete",	/* delete one or more addresses from a table */
	"replace",	/* replace the addresses of the table */
	"show",		/* show the content (addresses) of a table */
	"test",		/* test if the given addresses match a table */
	"zero",		/* clear all the statistics of a table */
	NULL
};

a124 1
	char		**p;
d128 1
a128 4
	for (p = commands; *p != NULL; p++)
		if (!strncmp(command, *p, strlen(command)))
			break;
	if (*p == NULL)
d140 1
a140 1
	if (!strcmp(*p, "-F")) {
d147 1
a147 1
	} else if (!strcmp(*p, "-s")) {
d172 1
a172 1
	} else if (!strcmp(*p, "create")) {
d179 1
a179 1
	} else if (!strcmp(*p, "kill")) {
d185 1
a185 1
	} else if (!strcmp(*p, "flush")) {
d192 1
a192 1
	} else if (!strcmp(*p, "add")) {
d207 1
a207 1
	} else if (!strcmp(*p, "delete")) {
d222 1
a222 1
	} else if (!strcmp(*p, "replace")) {
d256 1
a256 1
	} else if (!strcmp(*p, "show")) {
d282 1
a282 1
	} else if (!strcmp(*p, "test")) {
d309 1
a309 1
	} else if (!strcmp(*p, "zero")) {
d317 2
a318 1
	}
@


1.14
log
@strlcpy return checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.13 2003/01/09 10:40:44 cedric Exp $ */
d607 2
a608 1
void	pfctl_begin_table(void)
d626 2
a627 1
void    pfctl_append_addr(char *addr, int net, int neg)
d649 2
a650 1
void    pfctl_define_table(char *name, int flags, int addrs)
d675 2
a676 1
void	pfctl_commit_table(void)
d690 2
a691 1
void	inactive_cleanup(void)
@


1.13
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.12 2003/01/07 00:21:08 dhartmei Exp $ */
d155 3
a157 1
		strlcpy(table.pfrt_name, tname, PF_TABLE_NAME_SIZE);
d480 2
a481 1
	strlcpy(buf, s+not, sizeof(buf));
d552 2
a553 1
		strlcpy(buf, "{error}", sizeof buf);
d566 1
a566 1
		bzero(&sa, sizeof sa);
d657 3
a659 1
	strlcpy(tbl.pfrt_name, name, sizeof(tbl.pfrt_name));
@


1.12
log
@Remove table name hashing (pass the name in each ioctl instead), and
introduce reference counting for tables, they are now automatically
created and deleted through referencing rules. Diff partly from cedric@@.
ok mcbride@@, henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.11 2003/01/04 00:01:34 deraadt Exp $ */
d71 1
a71 1

d81 1
a81 1
static int	 size, msize;
d168 1
a168 1
			if (opts & PF_OPT_VERBOSE) {
d183 1
a183 1
			if (opts & PF_OPT_VERBOSE)
d185 1
a185 1
				    opts & PF_OPT_VERBOSE2);
d188 1
a188 1
				    opts & PF_OPT_VERBOSE2);
d192 1
d243 1
a243 1
		for(;;) {
d329 1
a329 1
		flags |= PFR_FLAG_RECURSE;
d368 10
a377 2
	printf("  %c%s\n", (ta->pfrt_flags & PFR_TFLAG_PERSIST)?'+':' ',
	    ta->pfrt_name);
d601 83
@


1.11
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.10 2003/01/03 23:31:26 cedric Exp $ */
d63 2
a64 2
static void	print_table(struct pfr_table *);
static void	print_tstats(struct pfr_tstats *);
d184 2
a185 1
				print_tstats(buffer.tstats+i);
d187 2
a188 1
				print_table(buffer.tables+i);
d363 1
a363 1
print_table(struct pfr_table *ta)
d365 4
a368 1
	printf("%s\n", ta->pfrt_name);
d372 1
a372 1
print_tstats(struct pfr_tstats *ts)
d377 3
a379 1
	printf("%s\n", ts->pfrts_name);
d381 1
@


1.10
log
@Make good use of the 'else' keyword.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.9 2003/01/03 23:00:39 deraadt Exp $ */
d55 1
a55 2
#include "pfctl_table.h"
#include "pfctl_radix.h"
a56 2
#include "pf_print_state.h"

@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.8 2003/01/03 22:57:02 deraadt Exp $ */
d167 1
a167 2
	}
	if (!strcmp(*p, "-s")) {
d190 1
a190 2
	}
	if (!strcmp(*p, "create")) {
d196 1
a196 2
	}
	if (!strcmp(*p, "kill")) {
d202 1
a202 2
	}
	if (!strcmp(*p, "flush")) {
d209 1
a209 2
	}
	if (!strcmp(*p, "add")) {
d224 1
a224 2
	}
	if (!strcmp(*p, "delete")) {
d239 1
a239 2
	}
	if (!strcmp(*p, "replace")) {
d273 1
a273 2
	}
	if (!strcmp(*p, "show")) {
d299 1
a299 2
	}
	if (!strcmp(*p, "test")) {
d326 1
a326 2
	}
	if (!strcmp(*p, "zero")) {
@


1.8
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.7 2003/01/03 22:54:29 deraadt Exp $ */
d131 1
a131 1
	char *command, char *file, int opts)
d140 1
a140 1
		char *file, int opts)
@


1.7
log
@zero sockaddr before use
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.6 2003/01/03 22:50:14 deraadt Exp $ */
d109 6
a114 3
#define RVTEST(fct)					\
	do { int rv = fct; if (rv)			\
		{ radix_perror(); return (1); }		\
@


1.6
log
@I am ready to strange the person who put a new strcpy() into our
source tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.5 2003/01/03 22:24:19 cedric Exp $ */
d555 1
@


1.5
log
@Remove _ before static functions & variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.4 2003/01/03 21:55:44 deraadt Exp $ */
d61 1
a61 1
#define _BUF_SIZE 256
d69 1
a69 1
static int	next_token(char [_BUF_SIZE], FILE *);
d399 1
a399 1
	char	 buf[_BUF_SIZE];
d420 1
a420 1
next_token(char buf[_BUF_SIZE], FILE *fp)
d444 1
a444 1
		if (i < _BUF_SIZE)
d448 1
a448 1
	if (i >= _BUF_SIZE) {
d460 1
a460 1
	char		 buf[_BUF_SIZE], *p, *q;
d466 1
a466 1
	if (strlen(s) >= _BUF_SIZE) {
d531 1
a531 1
	char		buf[_BUF_SIZE] = "{error}";
d542 1
a542 1
		strcpy(buf, "{error}");
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.3 2003/01/03 21:53:35 cedric Exp $ */
d64 10
a73 10
static int	_pfctl_table(int, char *[], char *, char *, char *, int);
static void	_grow_buffer(int, int);
static void	_print_table(struct pfr_table *);
static void	_print_tstats(struct pfr_tstats *);
static void	_load_addr(int, char *[], char *, int);
static int	_next_token(char [_BUF_SIZE], FILE *);
static void	_append_addr(char *, int);
static void	_print_addr(struct pfr_addr *, struct pfr_addr *, int);
static void	_print_astats(struct pfr_astats *, int);
static void	_perror(void);
d111 1
a111 1
		{ _perror(); return (1); }		\
d117 1
a117 1
	return _pfctl_table(0, NULL, NULL, "-F", NULL, opts);
d123 1
a123 1
	return _pfctl_table(0, NULL, NULL, "-s", NULL, opts);
d132 1
a132 1
	return _pfctl_table(argc, argv, tname, command, file, opts);
d136 1
a136 1
_pfctl_table(int argc, char *argv[], char *tname, char *command,
d170 1
a170 1
				_grow_buffer(sizeof(struct pfr_tstats), size);
d175 1
a175 1
				_grow_buffer(sizeof(struct pfr_table), size);
d185 1
a185 1
				_print_tstats(buffer.tstats+i);
d187 1
a187 1
				_print_table(buffer.tables+i);
d212 1
a212 1
		_load_addr(argc, argv, file, 0);
d224 1
a224 1
					_print_addr(buffer.addrs+i, NULL,
d228 1
a228 1
		_load_addr(argc, argv, file, 0);
d240 1
a240 1
					_print_addr(buffer.addrs+i, NULL,
d244 1
a244 1
		_load_addr(argc, argv, file, 0);
d256 1
a256 1
				_grow_buffer(sizeof(struct pfr_addr), size2);
d275 1
a275 1
					_print_addr(buffer.addrs+i, NULL,
d283 1
a283 1
				_grow_buffer(sizeof(struct pfr_astats), size);
d288 1
a288 1
				_grow_buffer(sizeof(struct pfr_addr), size);
d298 1
a298 1
				_print_astats(buffer.astats+i,
d301 1
a301 1
				_print_addr(buffer.addrs+i, NULL,
d306 1
a306 1
		_load_addr(argc, argv, file, 1);
d311 1
a311 1
				_perror();
d324 1
a324 1
					_print_addr(buffer.addrs+i, NULL,
d328 1
a328 1
				_print_addr(buffer2.addrs+i, buffer.addrs+i,
d346 1
a346 1
_grow_buffer(int bs, int minsize)
d371 1
a371 1
_print_table(struct pfr_table *ta)
d377 1
a377 1
_print_tstats(struct pfr_tstats *ts)
d396 1
a396 1
_load_addr(int argc, char *argv[], char *file, int nonetwork)
d402 1
a402 1
		_append_addr(*argv++, nonetwork);
d414 2
a415 2
	while (_next_token(buf, fp))
		_append_addr(buf, nonetwork);
d420 1
a420 1
_next_token(char buf[_BUF_SIZE], FILE *fp)
d422 1
a422 1
	static char	_next_ch = ' ';
d427 2
a428 2
		while (isspace(_next_ch) && !feof(fp))
			_next_ch = fgetc(fp);
d430 1
a430 1
		if (_next_ch == '#')
d432 2
a433 2
				_next_ch = fgetc(fp);
				if (_next_ch == '\n')
d440 1
a440 1
		_next_ch = ' ';
d445 3
a447 3
			buf[i++] = _next_ch;
		_next_ch = fgetc(fp);
	} while (!feof(fp) && !isspace(_next_ch));
d458 1
a458 1
_append_addr(char *s, int test)
d500 1
a500 1
				_grow_buffer(sizeof(struct pfr_addr), 0);
d515 1
a515 1
				_grow_buffer(sizeof(struct pfr_addr), 0);
d529 1
a529 1
_print_addr(struct pfr_addr *ad, struct pfr_addr *rad, int dns)
d571 1
a571 1
_print_astats(struct pfr_astats *as, int dns)
d576 1
a576 1
	_print_addr(&as->pfras_a, NULL, dns);
d587 1
a587 1
_perror(void)
@


1.3
log
@Initialize hints addrinfo in a safe way.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.2 2003/01/03 21:43:11 deraadt Exp $ */
d318 1
a318 1
			flags));
@


1.2
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.1 2003/01/03 21:37:44 cedric Exp $ */
d461 1
a461 1
	struct addrinfo *res, *ai, hints = { 0, 0, SOCK_DGRAM };
d464 2
@


1.1
log
@Bring in userland code for accessing PF radix tables.
ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_table.c,v 1.111 2002/12/25 16:05:23 dhartmei Exp $ */
d450 2
a451 2
			__progname, i);
	        exit(1);
d473 1
a473 1
			__progname, s);
d500 1
a500 1
				((struct sockaddr_in *)ai->ai_addr)->sin_addr;
d548 2
a549 2
        if (dns && ad->pfra_net == hostnet) {
	        char host[NI_MAXHOST] = "?";
d554 1
a554 1
			sizeof(sa.sin) : sizeof(sa.sin6);
d561 1
a561 1
			NULL, 0, NI_NAMEREQD);
@

