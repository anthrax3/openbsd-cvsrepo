head	1.64;
access;
symbols
	OPENBSD_6_2:1.64.0.14
	OPENBSD_6_2_BASE:1.64
	OPENBSD_6_1:1.64.0.12
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.64.0.8
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.4
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.64.0.6
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.63.0.10
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.63.0.8
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.63.0.4
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.63.0.2
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.62.0.2
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.2
	OPENBSD_5_0:1.58.0.4
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.2
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.56.0.4
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.39.0.4
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.64
date	2015.01.21.21.50.33;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	3o2AkhiRPQXvG94X;

1.63
date	2012.08.17.20.37.16;	author mikeb;	state Exp;
branches;
next	1.62;

1.62
date	2012.07.08.17.48.37;	author lteo;	state Exp;
branches;
next	1.61;

1.61
date	2012.06.01.08.35.45;	author jsg;	state Exp;
branches;
next	1.60;

1.60
date	2012.06.01.02.44.36;	author lteo;	state Exp;
branches;
next	1.59;

1.59
date	2011.10.13.18.30.54;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2010.11.12.13.14.41;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.02.14.01.04;	author sobrado;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.13.00.57.49;	author mcbride;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.19.01.00.16;	author bluhm;	state Exp;
branches;
next	1.53;

1.53
date	2008.09.09.13.56.38;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2008.08.12.16.40.18;	author david;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.29.08.42.15;	author mcbride;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.10.19.32.14;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.10.04.29.21;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.29.01.00.53;	author mcbride;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.09.13.59.31;	author mpf;	state Exp;
branches;
next	1.46;

1.46
date	2007.08.30.09.28.49;	author dhartmei;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.31.04.13.37;	author mcbride;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.01.17.20.53;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.14.11.09.44;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.04.08.24.15;	author mcbride;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.24.22.14.22;	author pascoe;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.10.22.13.26;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.10.17.48.08;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.26.23.11.36;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.31.11.18.24;	author cedric;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.27.19.37.43;	author mcbride;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.15.00.02.03;	author mcbride;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.06.22.01.28;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.04.11.05.16;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.21.09.07.01;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.20.16.53.48;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.07.21.10.47;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.19.20.22.53;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.17.07.45.28;	author dhartmei;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.16.17.15.17;	author dhartmei;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.09.15.38.46;	author cedric;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.03.15.52.24;	author cedric;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.24.17.06.39;	author cedric;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.08.16.06.03;	author dhartmei;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.21.22.23.49;	author dhartmei;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.20.18.37.52;	author camield;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.20.17.16.56;	author cedric;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.07.00.21.08;	author dhartmei;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.05.22.14.23;	author dhartmei;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.03.21.37.44;	author cedric;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.18.16.09.25;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.30.10.07.51;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.29.18.24.29;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.23.09.33.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.23.05.22.24;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.02.15.29.28;	author dhartmei;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.02.14.13.42;	author dhartmei;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.25.10.40.45;	author camield;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.22.12.28.08;	author mcbride;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.31.20.19.15;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.19.12.31.59;	author dhartmei;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.18.21.25.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.11.02.48.12;	author frantzen;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.06.22.22.44;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@/*	$OpenBSD: pf_print_state.c,v 1.63 2012/08/17 20:37:16 mikeb Exp $	*/

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#define TCPSTATES
#include <netinet/in.h>
#include <netinet/tcp_fsm.h>
#include <arpa/inet.h>
#include <net/pfvar.h>
#include <netdb.h>

#include <stdio.h>
#include <string.h>

#include "pfctl_parser.h"
#include "pfctl.h"

void	print_name(struct pf_addr *, sa_family_t);

void
print_addr(struct pf_addr_wrap *addr, sa_family_t af, int verbose)
{
	switch (addr->type) {
	case PF_ADDR_DYNIFTL:
		printf("(%s", addr->v.ifname);
		if (addr->iflags & PFI_AFLAG_NETWORK)
			printf(":network");
		if (addr->iflags & PFI_AFLAG_BROADCAST)
			printf(":broadcast");
		if (addr->iflags & PFI_AFLAG_PEER)
			printf(":peer");
		if (addr->iflags & PFI_AFLAG_NOALIAS)
			printf(":0");
		if (verbose) {
			if (addr->p.dyncnt <= 0)
				printf(":*");
			else
				printf(":%d", addr->p.dyncnt);
		}
		printf(")");
		break;
	case PF_ADDR_TABLE:
		if (verbose)
			if (addr->p.tblcnt == -1)
				printf("<%s:*>", addr->v.tblname);
			else
				printf("<%s:%d>", addr->v.tblname,
				    addr->p.tblcnt);
		else
			printf("<%s>", addr->v.tblname);
		return;
	case PF_ADDR_RANGE: {
		char buf[48];

		if (inet_ntop(af, &addr->v.a.addr, buf, sizeof(buf)) == NULL)
			printf("?");
		else
			printf("%s", buf);
		if (inet_ntop(af, &addr->v.a.mask, buf, sizeof(buf)) == NULL)
			printf(" - ?");
		else
			printf(" - %s", buf);
		break;
	}
	case PF_ADDR_ADDRMASK:
		if (PF_AZERO(&addr->v.a.addr, AF_INET6) &&
		    PF_AZERO(&addr->v.a.mask, AF_INET6))
			printf("any");
		else {
			char buf[48];

			if (inet_ntop(af, &addr->v.a.addr, buf,
			    sizeof(buf)) == NULL)
				printf("?");
			else
				printf("%s", buf);
		}
		break;
	case PF_ADDR_NOROUTE:
		printf("no-route");
		return;
	case PF_ADDR_URPFFAILED:
		printf("urpf-failed");
		return;
	case PF_ADDR_RTLABEL:
		printf("route \"%s\"", addr->v.rtlabelname);
		return;
	default:
		printf("?");
		return;
	}

	/* mask if not _both_ address and mask are zero */
	if (addr->type != PF_ADDR_RANGE &&
	    !(PF_AZERO(&addr->v.a.addr, AF_INET6) &&
	    PF_AZERO(&addr->v.a.mask, AF_INET6))) {
		int bits = unmask(&addr->v.a.mask, af);

		if (bits < (af == AF_INET ? 32 : 128))
			printf("/%d", bits);
	}
}

void
print_name(struct pf_addr *addr, sa_family_t af)
{
	char host[NI_MAXHOST];

	strlcpy(host, "?", sizeof(host));
	switch (af) {
	case AF_INET: {
		struct sockaddr_in sin;

		memset(&sin, 0, sizeof(sin));
		sin.sin_len = sizeof(sin);
		sin.sin_family = AF_INET;
		sin.sin_addr = addr->v4;
		getnameinfo((struct sockaddr *)&sin, sin.sin_len,
		    host, sizeof(host), NULL, 0, NI_NOFQDN);
		break;
	}
	case AF_INET6: {
		struct sockaddr_in6 sin6;

		memset(&sin6, 0, sizeof(sin6));
		sin6.sin6_len = sizeof(sin6);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = addr->v6;
		getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
		    host, sizeof(host), NULL, 0, NI_NOFQDN);
		break;
	}
	}
	printf("%s", host);
}

void
print_host(struct pf_addr *addr, u_int16_t port, sa_family_t af, u_int16_t rdom,
    const char *proto, int opts)
{
	struct servent	*s = NULL;
	char		ps[6];

	if (rdom)
		printf("(%u) ", ntohs(rdom));

	if (opts & PF_OPT_USEDNS)
		print_name(addr, af);
	else {
		struct pf_addr_wrap aw;

		memset(&aw, 0, sizeof(aw));
		aw.v.a.addr = *addr;
		if (af == AF_INET)
			aw.v.a.mask.addr32[0] = 0xffffffff;
		else {
			memset(&aw.v.a.mask, 0xff, sizeof(aw.v.a.mask));
			af = AF_INET6;
		}
		print_addr(&aw, af, opts & PF_OPT_VERBOSE2);
	}

	if (port) {
		snprintf(ps, sizeof(ps), "%u", ntohs(port));
		if (opts & PF_OPT_PORTNAMES)
			s = getservbyport(port, proto);
		if (af == AF_INET)
			printf(":%s", s ? s->s_name : ps);
		else
			printf("[%s]", s ? s->s_name : ps);
	}
}

void
print_seq(struct pfsync_state_peer *p)
{
	if (p->seqdiff)
		printf("[%u + %u](+%u)", ntohl(p->seqlo),
		    ntohl(p->seqhi) - ntohl(p->seqlo), ntohl(p->seqdiff));
	else
		printf("[%u + %u]", ntohl(p->seqlo),
		    ntohl(p->seqhi) - ntohl(p->seqlo));
}

void
print_state(struct pfsync_state *s, int opts)
{
	struct pfsync_state_peer *src, *dst;
	struct pfsync_state_key *sk, *nk;
	struct protoent *p;
	char *pn = NULL;
	int min, sec;
	int afto = (s->key[PF_SK_STACK].af != s->key[PF_SK_WIRE].af);
	int idx;

	if (s->direction == PF_OUT) {
		src = &s->src;
		dst = &s->dst;
		sk = &s->key[PF_SK_STACK];
		nk = &s->key[PF_SK_WIRE];
		if (s->proto == IPPROTO_ICMP || s->proto == IPPROTO_ICMPV6)
			sk->port[0] = nk->port[0];
	} else {
		src = &s->dst;
		dst = &s->src;
		sk = &s->key[PF_SK_WIRE];
		nk = &s->key[PF_SK_STACK];
		if (s->proto == IPPROTO_ICMP || s->proto == IPPROTO_ICMPV6)
			sk->port[1] = nk->port[1];
	}
	printf("%s ", s->ifname);
	if ((p = getprotobynumber(s->proto)) != NULL) {
		pn = p->p_name;
		printf("%s ", pn);
	} else
		printf("%u ", s->proto);

	print_host(&nk->addr[1], nk->port[1], nk->af, nk->rdomain, pn, opts);
	if (nk->af != sk->af || PF_ANEQ(&nk->addr[1], &sk->addr[1], nk->af) ||
	    nk->port[1] != sk->port[1] ||
	    nk->rdomain != sk->rdomain) {
		idx = afto ? 0 : 1;
		printf(" (");
		print_host(&sk->addr[idx], sk->port[idx], sk->af,
		    sk->rdomain, pn, opts);
		printf(")");
	}
	if (s->direction == PF_OUT || (afto && s->direction == PF_IN))
		printf(" -> ");
	else
		printf(" <- ");
	print_host(&nk->addr[0], nk->port[0], nk->af, nk->rdomain, pn, opts);
	if (nk->af != sk->af || PF_ANEQ(&nk->addr[0], &sk->addr[0], nk->af) ||
	    nk->port[0] != sk->port[0] ||
	    nk->rdomain != sk->rdomain) {
		idx = afto ? 1 : 0;
		printf(" (");
		print_host(&sk->addr[idx], sk->port[idx], sk->af,
		    sk->rdomain, pn, opts);
		printf(")");
	}

	printf("    ");
	if (s->proto == IPPROTO_TCP) {
		if (src->state <= TCPS_TIME_WAIT &&
		    dst->state <= TCPS_TIME_WAIT)
			printf("   %s:%s\n", tcpstates[src->state],
			    tcpstates[dst->state]);
		else if (src->state == PF_TCPS_PROXY_SRC ||
		    dst->state == PF_TCPS_PROXY_SRC)
			printf("   PROXY:SRC\n");
		else if (src->state == PF_TCPS_PROXY_DST ||
		    dst->state == PF_TCPS_PROXY_DST)
			printf("   PROXY:DST\n");
		else
			printf("   <BAD STATE LEVELS %u:%u>\n",
			    src->state, dst->state);
		if (opts & PF_OPT_VERBOSE) {
			printf("   ");
			print_seq(src);
			if (src->wscale && dst->wscale)
				printf(" wscale %u",
				    src->wscale & PF_WSCALE_MASK);
			printf("  ");
			print_seq(dst);
			if (src->wscale && dst->wscale)
				printf(" wscale %u",
				    dst->wscale & PF_WSCALE_MASK);
			printf("\n");
		}
	} else if (s->proto == IPPROTO_UDP && src->state < PFUDPS_NSTATES &&
	    dst->state < PFUDPS_NSTATES) {
		const char *states[] = PFUDPS_NAMES;

		printf("   %s:%s\n", states[src->state], states[dst->state]);
	} else if (s->proto != IPPROTO_ICMP && s->proto != IPPROTO_ICMPV6 &&
	    src->state < PFOTHERS_NSTATES && dst->state < PFOTHERS_NSTATES) {
		/* XXX ICMP doesn't really have state levels */
		const char *states[] = PFOTHERS_NAMES;

		printf("   %s:%s\n", states[src->state], states[dst->state]);
	} else {
		printf("   %u:%u\n", src->state, dst->state);
	}

	if (opts & PF_OPT_VERBOSE) {
		u_int64_t packets[2];
		u_int64_t bytes[2];
		u_int32_t creation = ntohl(s->creation);
		u_int32_t expire = ntohl(s->expire);

		sec = creation % 60;
		creation /= 60;
		min = creation % 60;
		creation /= 60;
		printf("   age %.2u:%.2u:%.2u", creation, min, sec);
		sec = expire % 60;
		expire /= 60;
		min = expire % 60;
		expire /= 60;
		printf(", expires in %.2u:%.2u:%.2u", expire, min, sec);

		bcopy(s->packets[0], &packets[0], sizeof(u_int64_t));
		bcopy(s->packets[1], &packets[1], sizeof(u_int64_t));
		bcopy(s->bytes[0], &bytes[0], sizeof(u_int64_t));
		bcopy(s->bytes[1], &bytes[1], sizeof(u_int64_t));
		printf(", %llu:%llu pkts, %llu:%llu bytes",
		    betoh64(packets[0]),
		    betoh64(packets[1]),
		    betoh64(bytes[0]),
		    betoh64(bytes[1]));
		if (ntohl(s->anchor) != -1)
			printf(", anchor %u", ntohl(s->anchor));
		if (ntohl(s->rule) != -1)
			printf(", rule %u", ntohl(s->rule));
		if (ntohs(s->state_flags) & PFSTATE_SLOPPY)
			printf(", sloppy");
		if (ntohs(s->state_flags) & PFSTATE_PFLOW)
			printf(", pflow");
		if (s->sync_flags & PFSYNC_FLAG_SRCNODE)
			printf(", source-track");
		if (s->sync_flags & PFSYNC_FLAG_NATSRCNODE)
			printf(", sticky-address");
		printf("\n");
	}
	if (opts & PF_OPT_VERBOSE2) {
		u_int64_t id;

		bcopy(&s->id, &id, sizeof(u_int64_t));
		printf("   id: %016llx creatorid: %08x",
		    betoh64(id), ntohl(s->creatorid));
		printf("\n");
	}
}

int
unmask(struct pf_addr *m, sa_family_t af)
{
	int i = 31, j = 0, b = 0;
	u_int32_t tmp;

	while (j < 4 && m->addr32[j] == 0xffffffff) {
		b += 32;
		j++;
	}
	if (j < 4) {
		tmp = ntohl(m->addr32[j]);
		for (i = 31; tmp & (1 << i); --i)
			b++;
	}
	return (b);
}
@


1.63
log
@Don't forget to byteswap the state_flags since it's a uint16_t now.
From Hrvoje Popovski via Florian Obser, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.62 2012/07/08 17:48:37 lteo Exp $	*/
d37 1
d39 1
a40 1
#include <arpa/inet.h>
@


1.62
log
@New attempt to make the -P flag work with -ss, so that states can be
printed with port names if desired.

tcpdump's pf_print_state.c has diverged significantly from pfctl's, so
the change to tcpdump's pf_print_state.c is not exactly the same as
pfctl's.

ok henning sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.61 2012/06/01 08:35:45 jsg Exp $	*/
d346 1
a346 1
		if (s->state_flags & PFSTATE_SLOPPY)
d348 1
a348 1
		if (s->state_flags & PFSTATE_PFLOW)
@


1.61
log
@revert previous, breaks tcpdump
spotted by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.60 2012/06/01 02:44:36 lteo Exp $	*/
d169 1
a169 1
    int opts)
d171 3
d194 3
d198 1
a198 1
			printf(":%u", ntohs(port));
d200 1
a200 1
			printf("[%u]", ntohs(port));
d221 1
d242 4
a245 3
	if ((p = getprotobynumber(s->proto)) != NULL)
		printf("%s ", p->p_name);
	else
d248 1
a248 1
	print_host(&nk->addr[1], nk->port[1], nk->af, nk->rdomain, opts);
d255 1
a255 1
		    sk->rdomain, opts);
d262 1
a262 1
	print_host(&nk->addr[0], nk->port[0], nk->af, nk->rdomain, opts);
d269 1
a269 1
		    sk->rdomain, opts);
@


1.60
log
@Make the -P flag work with -ss, so that states can be printed with port
names if desired.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.59 2011/10/13 18:30:54 claudio Exp $	*/
d169 1
a169 1
    const char *proto, int opts)
a170 3
	struct servent	*s = NULL;
	char		ps[6];

a190 3
		snprintf(ps, sizeof(ps), "%u", ntohs(port));
		if (opts & PF_OPT_PORTNAMES)
			s = getservbyport(port, proto);
d192 1
a192 1
			printf(":%s", s ? s->s_name : ps);
d194 1
a194 1
			printf("[%s]", s ? s->s_name : ps);
a214 1
	char *pn = NULL;
d235 3
a237 4
	if ((p = getprotobynumber(s->proto)) != NULL) {
		pn = p->p_name;
		printf("%s ", pn);
	} else
d240 1
a240 1
	print_host(&nk->addr[1], nk->port[1], nk->af, nk->rdomain, pn, opts);
d247 1
a247 1
		    sk->rdomain, pn, opts);
d254 1
a254 1
	print_host(&nk->addr[0], nk->port[0], nk->af, nk->rdomain, pn, opts);
d261 1
a261 1
		    sk->rdomain, pn, opts);
@


1.59
log
@pfctl change for af-to / NAT64 support.
The general syntax is:
pass in inet from any to 192.168.1.1 af-to inet6 from 2001::1 to 2001::2
In the NAT64 case the "to" is not needed in af-to and the IP is extraced
from the IPv6 dst (assuming a /64 prefix).
Again most work by sperreault@@, mikeb@@ and reyk@@
OK mcbride@@, put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.58 2010/11/12 13:14:41 claudio Exp $	*/
d169 1
a169 1
    int opts)
d171 3
d194 3
d198 1
a198 1
			printf(":%u", ntohs(port));
d200 1
a200 1
			printf("[%u]", ntohs(port));
d221 1
d242 4
a245 3
	if ((p = getprotobynumber(s->proto)) != NULL)
		printf("%s ", p->p_name);
	else
d248 1
a248 1
	print_host(&nk->addr[1], nk->port[1], nk->af, nk->rdomain, opts);
d255 1
a255 1
		    sk->rdomain, opts);
d262 1
a262 1
	print_host(&nk->addr[0], nk->port[0], nk->af, nk->rdomain, opts);
d269 1
a269 1
		    sk->rdomain, opts);
@


1.58
log
@The ioctl to show states returns a pfsync_state which is in network byte
order and therefore a ntohs is needed to show the rdomain correctly.
OK henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.57 2010/09/02 14:01:04 sobrado Exp $	*/
d216 2
d240 2
a241 2
	print_host(&nk->addr[1], nk->port[1], s->af, nk->rdomain, opts);
	if (PF_ANEQ(&nk->addr[1], &sk->addr[1], s->af) ||
d244 1
d246 2
a247 1
		print_host(&sk->addr[1], sk->port[1], s->af, sk->rdomain, opts);
d250 1
a250 1
	if (s->direction == PF_OUT)
d254 2
a255 2
	print_host(&nk->addr[0], nk->port[0], s->af, nk->rdomain, opts);
	if (PF_ANEQ(&nk->addr[0], &sk->addr[0], s->af) ||
d258 1
d260 2
a261 1
		print_host(&sk->addr[0], sk->port[0], s->af, sk->rdomain, opts);
@


1.57
log
@remove trailing spaces and tabs; no binary change.

written with help from henning@@, who suggested ensuring that there
are no changes in the digests for object files, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.56 2010/01/13 00:57:49 mcbride Exp $	*/
d168 1
a168 1
print_host(struct pf_addr *addr, u_int16_t port, sa_family_t af, int rdom,
d172 1
a172 1
		printf("(%d) ", rdom);
@


1.56
log
@In some cases the netmask gets set to a full 128 bit mask even if no
address family is selected; don't print the v6 mask if it's a v4 address.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.55 2009/11/03 10:59:04 claudio Exp $	*/
d222 1
a222 1
		if (s->proto == IPPROTO_ICMP || s->proto == IPPROTO_ICMPV6) 
d229 1
a229 1
		if (s->proto == IPPROTO_ICMP || s->proto == IPPROTO_ICMPV6) 
@


1.55
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.54 2009/03/19 01:00:16 bluhm Exp $	*/
d129 1
a129 1
		if (bits != (af == AF_INET ? 32 : 128))
@


1.54
log
@pfctl -ss printed state levels for ICMPv6.  Disable this the same
way it has already been done for ICMPv4.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.53 2008/09/09 13:56:38 henning Exp $	*/
d168 2
a169 1
print_host(struct pf_addr *addr, u_int16_t port, sa_family_t af, int opts)
d171 3
d238 1
a238 1
	print_host(&nk->addr[1], nk->port[1], s->af, opts);
d240 2
a241 1
	    nk->port[1] != sk->port[1]) {
d243 1
a243 1
		print_host(&sk->addr[1], sk->port[1], s->af, opts);
d250 1
a250 1
	print_host(&nk->addr[0], nk->port[0], s->af, opts);
d252 2
a253 1
	    nk->port[0] != sk->port[0]) {
d255 1
a255 1
		print_host(&sk->addr[0], sk->port[0], s->af, opts);
@


1.53
log
@welcome pflow(4), a netflow v5 compatible flow export interface.
flows export data gathered from pf states.
initial implementation by Joerg Goltermann <jg@@osn.de>, guidance and many
changes by me. 'put it in' theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.52 2008/08/12 16:40:18 david Exp $	*/
d286 2
a287 2
	} else if (s->proto != IPPROTO_ICMP && src->state < PFOTHERS_NSTATES &&
	    dst->state < PFOTHERS_NSTATES) {
@


1.52
log
@use correct byte order when printing state expiration minutes; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.51 2008/06/29 08:42:15 mcbride Exp $	*/
d328 2
@


1.51
log
@Simplify state creation code; merge state import/export code between pfsync
and the state-related pf(4) ioctls, and make functions in state creation and
destruction paths more robust in error conditions.

All values in struct pfsync_state now in network byte order, as with pfsync.

testing by david
ok henning, systat parts ok canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.50 2008/06/10 19:32:14 henning Exp $	*/
d309 1
a309 1
		min = s->expire % 60;
@


1.50
log
@save somespace in the state by collapsing two 8 bit ints used as booleans
into one 8 bit flags field.
shrinks the state structure by 4 bytes on 32bit archs
ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.49 2008/06/10 04:29:21 henning Exp $	*/
d198 2
a199 2
		printf("[%u + %u](+%u)", p->seqlo, p->seqhi - p->seqlo,
		    p->seqdiff);
d201 2
a202 1
		printf("[%u + %u]", p->seqlo, p->seqhi - p->seqlo);
d297 12
a308 7
		sec = s->creation % 60;
		s->creation /= 60;
		min = s->creation % 60;
		s->creation /= 60;
		printf("   age %.2u:%.2u:%.2u", s->creation, min, sec);
		sec = s->expire % 60;
		s->expire /= 60;
d310 7
a316 2
		s->expire /= 60;
		printf(", expires in %.2u:%.2u:%.2u", s->expire, min, sec);
d318 8
a325 8
		    pf_state_counter_from_pfsync(s->packets[0]),
		    pf_state_counter_from_pfsync(s->packets[1]),
		    pf_state_counter_from_pfsync(s->bytes[0]),
		    pf_state_counter_from_pfsync(s->bytes[1]));
		if (s->anchor != -1)
			printf(", anchor %u", s->anchor);
		if (s->rule != -1)
			printf(", rule %u", s->rule);
d335 6
a340 3
		printf("   id: %016llx creatorid: %08x%s\n",
		    betoh64(*(u_int64_t *)(s->id)), ntohl(s->creatorid),
		    ((s->sync_flags & PFSTATE_NOSYNC) ? " (no-sync)" : ""));
@


1.49
log
@in verbose mode indicate which states are sloppy, ryan reyk theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.48 2008/05/29 01:00:53 mcbride Exp $	*/
d315 1
a315 1
		if (s->sloppy)
@


1.48
log
@Second half of PF state table rearrangement.
- Mechanical change: Use arrays for state key pointers in pf_state, and
  addr/port in pf_state_key, to allow the use of indexes.
- Fix NAT, pfsync, pfctl, and tcpdump to handle the new state structures.
  In struct pfsync_state, both state keys are included even when identical.
- Also fix some bugs discovered in the existing code during testing.
  (in particular, "block return" for TCP packets was not returning an RST)

ok henning beck deraadt
tested by otto dlg beck laurent

Special thanks to users Manuel Pata and Emilio Perea who did enough testing
to actually find some bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.47 2008/05/09 13:59:31 mpf Exp $	*/
d315 2
@


1.47
log
@Add support to kill states by rule label or state id.
Fix printing of the state id in pfctl -ss -vv.
Remove the psnk_af hack to return the number of killed states.
OK markus, beck. "I like it" henning, deraadt.
Manpage help from jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.46 2007/08/30 09:28:49 dhartmei Exp $	*/
d168 1
a168 1
print_host(struct pfsync_state_host *h, sa_family_t af, int opts)
a169 2
	u_int16_t p = ntohs(h->port);

d171 1
a171 1
		print_name(&h->addr, af);
d176 1
a176 1
		aw.v.a.addr = h->addr;
d186 1
a186 1
	if (p) {
d188 1
a188 1
			printf(":%u", p);
d190 1
a190 1
			printf("[%u]", p);
d208 1
d215 4
d222 4
d232 7
a238 7
	if (PF_ANEQ(&s->lan.addr, &s->gwy.addr, s->af) ||
	    (s->lan.port != s->gwy.port)) {
		print_host(&s->lan, s->af, opts);
		if (s->direction == PF_OUT)
			printf(" -> ");
		else
			printf(" <- ");
a239 1
	print_host(&s->gwy, s->af, opts);
d244 7
a250 1
	print_host(&s->ext, s->af, opts);
@


1.46
log
@add support for address ranges ("from 10.1.2.50 - 10.1.3.75") in from/to
criteria. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.44 2007/03/01 17:20:53 deraadt Exp $	*/
d311 1
a311 1
		    pf_state_counter_from_pfsync(s->id), ntohl(s->creatorid),
@


1.45
log
@Cope with new ioctl interface (use pfsync_state instead of pf_state)

ok henning@@ toby@@ pyr@@
@
text
@d82 13
d124 2
a125 1
	if (!(PF_AZERO(&addr->v.a.addr, AF_INET6) &&
@


1.44
log
@be more careful with mixing &/| with &&/||, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.43 2006/03/14 11:09:44 djm Exp $	*/
d154 1
a154 1
print_host(struct pf_state_host *h, sa_family_t af, int opts)
d183 1
a183 1
print_seq(struct pf_state_peer *p)
d193 1
a193 1
print_state(struct pf_state *s, int opts)
d195 1
a195 1
	struct pf_state_peer *src, *dst;
d206 1
a206 1
	printf("%s ", s->u.ifname);
d281 9
a289 6
		    s->packets[0], s->packets[1], s->bytes[0], s->bytes[1]);
		if (s->anchor.nr != -1)
			printf(", anchor %u", s->anchor.nr);
		if (s->rule.nr != -1)
			printf(", rule %u", s->rule.nr);
		if (s->src_node != NULL)
d291 1
a291 1
		if (s->nat_src_node != NULL)
d297 1
a297 1
		    betoh64(s->id), ntohl(s->creatorid),
@


1.43
log
@implement a Unicast Reverse Path Forwarding (uRPF) check for pf(4)
which optionally verifies that a packet is received on the interface
that holds the route back to the packet's source address. This makes
it an automatic ingress filter, but only when routing is fully
symmetric.

bugfix feedback claudio@@; ok claudio@@ and dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.42 2005/11/04 08:24:15 mcbride Exp $	*/
d295 1
a295 1
		    (s->sync_flags & PFSTATE_NOSYNC ? " (no-sync)" : ""));
@


1.42
log
@crank pf_state and pf_src_node byte and packet counters to u_in64_t, since
we're breaking pfsync compatibility this cycle anyways.

Requested by djm@@, ok henning@@, 'wheee!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.41 2005/05/24 22:14:22 pascoe Exp $	*/
d98 3
@


1.41
log
@Identify states that will not be synchronised in pfctl -vvss output.

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.40 2004/12/10 22:13:26 henning Exp $	*/
d277 1
a277 1
		printf(", %u:%u pkts, %u:%u bytes",
@


1.40
log
@allow pf to filter on route labels
pass in from route dtag keep state queue reallyslow
tested by Gabriel Kihlman <gk@@stacken.kth.se> and
Michael Knudsen <e@@molioner.dk> and ryan
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.39 2004/02/10 17:48:08 henning Exp $	*/
d290 3
a292 2
		printf("   id: %016llx creatorid: %08x\n",
		    betoh64(s->id), ntohl(s->creatorid));
@


1.39
log
@fix at leats the worst of Cedric "KNF is for everybody but me" Berger's fuckup
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.38 2004/01/26 23:11:36 henning Exp $	*/
d98 3
@


1.38
log
@we must not omit printing the netmask when it is all zero, this is dangerous -
1.2.3.4/0 is not equal to 1.2.3.4... this "helped" to make failure already
only omit the netmask when both the addr and the mask itself are all zero
(the "any" case)

ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.37 2003/12/31 11:18:24 cedric Exp $	*/
d53 1
a53 1
	switch(addr->type) {
@


1.37
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.36 2003/12/27 19:37:43 mcbride Exp $	*/
d103 4
a106 1
	if (! PF_AZERO(&addr->v.a.mask, af)) {
@


1.36
log
@Remove extra \n from pf_print_state().

ok deraadt@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.35 2003/12/15 07:11:30 mcbride Exp $	*/
d55 16
a70 1
		printf("(%s)", addr->v.ifname);
d197 1
@


1.35
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.34 2003/12/15 00:02:03 mcbride Exp $	*/
a264 1
		printf("\n");
@


1.34
log
@Add support to track stateful connections by source ip. This allows us
to:
- Ensure that clients get a consistent IP mapping with load-balanced
  translation/routing rules
- Limit the number of simultaneous connections a client can make
- Limit the number of clients which can connect through a rule

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.33 2003/07/06 22:01:28 deraadt Exp $	*/
d143 1
a143 1
		else
d145 2
d267 4
@


1.33
log
@knf (cedric did not do it right)
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.32 2003/07/04 11:05:16 henning Exp $	*/
d259 5
@


1.32
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.31 2003/06/21 09:07:01 djm Exp $	*/
d69 2
a70 2
                    PF_AZERO(&addr->v.a.mask, AF_INET6))
                        printf("any");
@


1.31
log
@count packets and bidirectionally on state entries, allowing for fine-grained
traffic reporting w/ pfsync; ok dhartmei@@

Note: ABI change (new fields in struct pf_state), requires a rebuild of
pfctl and tcpdump.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.30 2003/06/20 16:53:48 deraadt Exp $	*/
d253 1
a253 1
		printf(", %u:%u pkts, %u:%u bytes", 
@


1.30
log
@some cleanings recommended by lint; dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.29 2003/06/07 21:10:47 henning Exp $	*/
d253 2
a254 1
		printf(", %u pkts, %u bytes", s->packets, s->bytes);
@


1.29
log
@in print_host(), don't set the mask blindly to /128 but adhere to the
address family. fixes the ipv4/128:port output in pfctl -ss.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.28 2003/05/19 20:22:53 henning Exp $	*/
d230 1
d236 1
@


1.28
log
@print out the full netmask; don't just ignore the upper bits in the v4 case
helps finding assignment bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.27 2003/05/17 07:45:28 dhartmei Exp $	*/
d141 4
a144 1
		memset(&aw.v.a.mask, 0xff, sizeof(aw.v.a.mask));
@


1.27
log
@Fix proxy related output.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.26 2003/05/16 17:15:17 dhartmei Exp $	*/
d260 1
a260 1
	int i = 31, j = 0, b = 0, msize;
d263 1
a263 5
	if (af == AF_INET)
		msize = 1;
	else
		msize = 4;
	while (j < msize && m->addr32[j] == 0xffffffff) {
d267 1
a267 1
	if (j < msize) {
@


1.26
log
@TCP SYN proxy. Instead of 'keep state' or 'modulate state', one can use
'synproxy state' for TCP connections. pf will complete the TCP handshake
with the active endpoint before passing any packets to the passive end-
point, preventing spoofed SYN floods from reaching the passive endpoint.

No additional memory requirements, no cookies needed, random initial
sequence numbers, uses the existing sequence number modulators to translate
packets after the handshakes.

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.25 2003/04/09 15:38:46 cedric Exp $	*/
d202 6
a207 4
		else if (src->state == PF_TCPS_PROXY_SRC)
			printf("   PROXY_SRC\n");
		else if (src->state == PF_TCPS_PROXY_DST)
			printf("   PROXY_DST\n");
d209 2
a210 1
			printf("   <BAD STATE LEVELS>\n");
@


1.25
log
@on "pfctl -vvss", print the anchor rule number when there is one.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.24 2003/04/03 15:52:24 cedric Exp $	*/
d199 1
a199 1
		    dst->state <= TCPS_TIME_WAIT) {
d202 5
a206 1
		} else {
a207 1
		}
@


1.24
log
@Simplify pfctl printing code.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.23 2003/03/24 17:06:39 cedric Exp $	*/
d243 2
@


1.23
log
@Add missing return. Fix following buglet:
# echo "pass in from <veryLONGtableNAME>" | pfctl -nvf-
pass in from <veryLONGtableNAME>/0 to any
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.22 2003/03/08 16:06:03 dhartmei Exp $	*/
d53 2
a54 3
	char buf[48];

	if (addr->type == PF_ADDR_DYNIFTL)
d56 2
a57 1
	else if (addr->type == PF_ADDR_TABLE) {
d67 20
a86 5
	} else {
		if (inet_ntop(af, &addr->v.a.addr, buf, sizeof(buf)) == NULL)
			printf("?");
		else
			printf("%s", buf);
@


1.22
log
@Remove unneeded #includes, from Andrey Matveev andrushock(at)pisem(dot)net
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.21 2003/01/21 22:23:49 dhartmei Exp $	*/
d57 1
a57 1
	else if (addr->type == PF_ADDR_TABLE)
d66 2
a67 1
	else {
@


1.21
log
@Support for TCP window scaling (RFC 1323). ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.20 2003/01/20 18:37:52 camield Exp $	*/
a35 5
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp6.h>
d40 1
a42 1
#include <stdlib.h>
a43 5
#include <ctype.h>
#include <netdb.h>
#include <stdarg.h>
#include <errno.h>
#include <err.h>
@


1.20
log
@Remove unused argument from print_name() and fix two other nits
found by lint.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.19 2003/01/20 17:16:56 cedric Exp $	*/
d202 3
d207 3
@


1.19
log
@Improve pfctl -vvs{r,n} output with rule containing tables.
Shows the number of entries in the table or if the table is not active.
ok dhartmei@@, no objections.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.18 2003/01/07 00:21:08 dhartmei Exp $	*/
d58 1
a58 1
void	print_name(struct pf_addr *, struct pf_addr *, sa_family_t);
d91 1
a91 1
print_name(struct pf_addr *addr, struct pf_addr *mask, sa_family_t af)
d129 1
a129 1
		print_name(&h->addr, NULL, af);
@


1.18
log
@Remove table name hashing (pass the name in each ioctl instead), and
introduce reference counting for tables, they are now automatically
created and deleted through referencing rules. Diff partly from cedric@@.
ok mcbride@@, henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.17 2003/01/05 22:14:23 dhartmei Exp $	*/
d61 1
a61 1
print_addr(struct pf_addr_wrap *addr, sa_family_t af)
d68 8
a75 1
		printf("<%s>", addr->v.tblname);
d136 1
a136 1
		print_addr(&aw, af);
@


1.17
log
@Move ifname from pf_addr to pf_addr_wrap, prepare pf_addr_wrap for table
name. ok henning@@, mcbride@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.16 2003/01/04 00:01:34 deraadt Exp $	*/
a64 9
	if (addr->v.a.mask.addr32[0] == PF_TABLE_MASK) {
		struct pfr_table tbl = { "?" };

		if (pfr_unwrap_table(&tbl, addr, 0))
			printf("<0x%08X>", addr->v.a.addr.addr32[0]);
		else
			printf("<%s>", tbl.pfrt_name);
		return;
	}
d67 2
@


1.16
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.15 2003/01/03 21:37:44 cedric Exp $	*/
d65 1
a65 1
	if (addr->mask.addr32[0] == PF_TABLE_MASK) {
d69 1
a69 1
			printf("<0x%08X>", addr->addr.addr32[0]);
d74 2
a75 2
	if (addr->addr_dyn != NULL)
		printf("(%s)", addr->addr.pfa.ifname);
d77 1
a77 1
		if (inet_ntop(af, &addr->addr, buf, sizeof(buf)) == NULL)
d82 2
a83 2
	if (! PF_AZERO(&addr->mask, af)) {
		int bits = unmask(&addr->mask, af);
d133 3
a135 3
		aw.addr = h->addr;
		memset(&aw.mask, 0xff, sizeof(aw.mask));
		aw.addr_dyn = NULL;
@


1.15
log
@Bring in userland code for accessing PF radix tables.
ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.14 2002/12/18 16:09:25 dhartmei Exp $	*/
d56 1
a56 2
#include "pfctl_radix.h"
#include "pf_print_state.h"
@


1.14
log
@rule.nr USHRT_MAX -> -1, to detect states whose creating rules are
already gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.13 2002/11/30 10:07:51 mickey Exp $	*/
d56 1
d66 9
@


1.13
log
@move unmask back into pf_print_state.c where it was, and please keep it there; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.12 2002/11/29 18:24:29 mickey Exp $	*/
d222 1
a222 1
		if (s->rule.nr != USHRT_MAX)
@


1.12
log
@no need for extra hrs; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.11 2002/11/23 09:33:54 deraadt Exp $	*/
d226 22
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.10 2002/11/23 05:22:24 mcbride Exp $	*/
d153 1
a153 1
	u_int8_t hrs, min, sec;
d215 1
a215 2
		hrs = s->creation;
		printf("   age %.2u:%.2u:%.2u", hrs, min, sec);
d220 1
a220 2
		hrs = s->expire;
		printf(", expires in %.2u:%.2u:%.2u", hrs, min, sec);
@


1.10
log
@code to support loading of pf rules with multiple redirection addresses
(in nat, rdr, route-to, dup-to and reply-to)

Syntax looks like this, see pf.conf(5) for details:

nat on wi0 proto { tcp, icmp } from any to 192.168.0.2 -> \
        192.168.0.16/29 source-hash random

rdr on wi0 proto { tcp } from any to 192.168.0.34 port 22 -> \
        { 192.168.0.8/31, 192.168.0.15 } port 22 round-robin

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.9 2002/11/02 15:29:28 dhartmei Exp $	*/
d125 1
a125 1
		memset(&aw.mask, 0xff, sizeof(aw.mask)); 
@


1.9
log
@%i -> %d, matches the style of existing code, from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.8 2002/11/02 14:13:42 dhartmei Exp $	*/
d61 1
a61 1
print_addr(struct pf_addr_wrap *addr, struct pf_addr *mask, sa_family_t af)
d73 2
a74 2
	if (mask != NULL) {
		int bits = unmask(mask, af);
d125 1
d127 1
a127 1
		print_addr(&aw, NULL, af);
@


1.8
log
@printf int with %i, not %u. from pilot@@monkey.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.7 2002/10/25 10:40:45 camield Exp $	*/
d77 1
a77 1
			printf("/%i", bits);
@


1.7
log
@- more sa_family_t
- move unmask code to correct file
- whitespace

ok mcbride@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.6 2002/10/22 12:28:08 mcbride Exp $	*/
d77 1
a77 1
			printf("/%u", bits);
@


1.6
log
@More conversion of "int af" and "u_int8_t af" declarations and function
arguments to the more correct and descriptive "sa_family_t af"

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.5 2002/07/31 20:19:15 henning Exp $	*/
d58 1
a58 23
void	print_name(struct pf_addr *, struct pf_addr *, int);

int
unmask(struct pf_addr *m, u_int8_t af)
{
	int i = 31, j = 0, b = 0, msize;
	u_int32_t tmp;

	if (af == AF_INET)
		msize = 1;
	else
		msize = 4;
	while (j < msize && m->addr32[j] == 0xffffffff) {
		b += 32;
		j++;
	}
	if (j < msize) {
		tmp = ntohl(m->addr32[j]);
		for (i = 31; tmp & (1 << i); --i)
			b++;
	}
	return (b);
}
d61 1
a61 1
print_addr(struct pf_addr_wrap *addr, struct pf_addr *mask, u_int8_t af)
d82 1
a82 1
print_name(struct pf_addr *addr, struct pf_addr *mask, int af)
@


1.5
log
@KNF, esp. missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.4 2002/07/19 12:31:59 dhartmei Exp $	*/
d137 1
a137 1
print_host(struct pf_state_host *h, u_int8_t af, int opts)
@


1.4
log
@Use getnameinfo() instead of gethostbyaddr() to support IPv6 reverse
lookups with pfctl -r. Makes things actually simpler.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.3 2002/07/18 21:25:01 deraadt Exp $	*/
d57 2
@


1.3
log
@use inet_aton(), until this is made v6 aware
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.2 2002/06/11 02:48:12 frantzen Exp $	*/
d104 1
a104 2
	char buf[48];
	struct hostent *hp;
d106 23
a128 5
	if (inet_ntop(af, addr, buf, sizeof(buf)) == NULL)
		printf("?");
	else {
		hp = getpfhostname(buf);
		printf("%s", hp->h_name);
a129 3
	if (mask != NULL) {
		if (!PF_AZERO(mask, af))
			printf("/%u", unmask(mask, af));
d131 1
a246 21
}

struct hostent *
getpfhostname(const char *addr_str)
{
	struct in_addr		inaddr;
	struct hostent		*hp;
	static struct hostent	 myhp;

	if (inet_aton(addr_str, &inaddr) == 0) {
		myhp.h_name = (char *)addr_str;
		hp = &myhp;
		return (hp);
	}
	hp = gethostbyaddr((char *)&inaddr.s_addr, sizeof(inaddr.s_addr),
	    AF_INET);
	if (hp == NULL) {
		myhp.h_name = (char *)addr_str;
		hp = &myhp;
	}
	return (hp);
@


1.2
log
@print a string for UDP and OTHER state level instead of a numeric level
ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.1 2002/06/06 22:22:44 mickey Exp $	*/
d237 1
a237 1
	in_addr_t		 addr_num;
d241 1
a241 2
	addr_num = inet_addr(addr_str);
	if (addr_num == INADDR_NONE) {
d246 2
a247 1
	hp = gethostbyaddr((char *)&addr_num, sizeof(addr_num), AF_INET);
@


1.1
log
@split out the pf_state printing functions to be used elsewhere, no functional change; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d201 9
@

