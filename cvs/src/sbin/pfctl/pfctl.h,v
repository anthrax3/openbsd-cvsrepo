head	1.55;
access;
symbols
	OPENBSD_6_2:1.55.0.4
	OPENBSD_6_2_BASE:1.55
	OPENBSD_6_1:1.53.0.12
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.8
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.4
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.53.0.6
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.50.0.6
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.4
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.46.0.2
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.43.0.8
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.4
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.39.0.4
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12;
locks; strict;
comment	@ * @;


1.55
date	2017.08.11.22.30.38;	author benno;	state Exp;
branches;
next	1.54;
commitid	y1VyeV9JnotblbHq;

1.54
date	2017.07.15.16.01.14;	author awolk;	state Exp;
branches;
next	1.53;
commitid	0AKXaWuF261gsHLI;

1.53
date	2015.01.19.23.52.02;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	Kn4uVrjBCwNTB932;

1.52
date	2014.04.19.14.22.32;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2013.10.12.12.16.11;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2012.07.08.17.48.37;	author lteo;	state Exp;
branches;
next	1.49;

1.49
date	2012.06.01.08.35.45;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2012.06.01.02.44.36;	author lteo;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.12.13.14.41;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2010.03.23.13.31.29;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.29.01.00.53;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.05.12.01.47;	author chl;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.31.04.13.37;	author mcbride;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.09.11.25.27;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.28.18.54.28;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.21.21.03.58;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.05.18.23.10;	author mcbride;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.14.20.44.22;	author cedric;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.19.17.50.51;	author dhartmei;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.09.12.42.06;	author cedric;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.19.21.37.01;	author cedric;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.17.08.48.29;	author cedric;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.10.22.26.56;	author dhartmei;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.29.01.25.13;	author mcbride;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.31.11.18.24;	author cedric;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.06.15.01.30;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.08.14.47.57;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.26.21.44.09;	author cedric;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.29.21.47.36;	author cedric;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.31.22.25.54;	author cedric;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.04.11.05.44;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.03.09.13.06;	author cedric;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.30.20.02.46;	author cedric;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.27.15.35.00;	author cedric;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.08.09.41.07;	author cedric;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.30.12.30.27;	author cedric;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.14.14.50.46;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.11.15.18.33;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.11.15.13.34;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.05.21.44.46;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.27.18.01.57;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.06.12.50.40;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.02.23.37.24;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.11.20.11.36;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.24.11.11.17;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.24.10.53.32;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.20.19.05.46;	author camield;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.20.17.16.56;	author cedric;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.09.17.33.19;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.07.00.21.08;	author dhartmei;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.04.22.42.14;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.55
log
@add option -N (no domain resolution)
manpage wording and reminder about usage() jmc@@
ok florian@@ henning@@
@
text
@/*	$OpenBSD: pfctl.h,v 1.54 2017/07/15 16:01:14 awolk Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef _PFCTL_H_
#define _PFCTL_H_

enum pfctl_show { PFCTL_SHOW_RULES, PFCTL_SHOW_LABELS, PFCTL_SHOW_NOTHING };

enum {	PFRB_TABLES = 1, PFRB_TSTATS, PFRB_ADDRS, PFRB_ASTATS,
	PFRB_IFACES, PFRB_TRANS, PFRB_MAX };
struct pfr_buffer {
	int	 pfrb_type;	/* type of content, see enum above */
	int	 pfrb_size;	/* number of objects in buffer */
	int	 pfrb_msize;	/* maximum number of objects in buffer */
	void	*pfrb_caddr;	/* malloc'ated memory area */
};
#define PFRB_FOREACH(var, buf)				\
	for ((var) = pfr_buf_next((buf), NULL);		\
	    (var) != NULL;				\
	    (var) = pfr_buf_next((buf), (var)))

int	 pfr_get_fd(void);
int	 pfr_clr_tables(struct pfr_table *, int *, int);
int	 pfr_add_tables(struct pfr_table *, int, int *, int);
int	 pfr_del_tables(struct pfr_table *, int, int *, int);
int	 pfr_get_tables(struct pfr_table *, struct pfr_table *, int *, int);
int	 pfr_get_tstats(struct pfr_table *, struct pfr_tstats *, int *, int);
int	 pfr_clr_tstats(struct pfr_table *, int, int *, int);
int	 pfr_clr_addrs(struct pfr_table *, int *, int);
int	 pfr_add_addrs(struct pfr_table *, struct pfr_addr *, int, int *, int);
int	 pfr_del_addrs(struct pfr_table *, struct pfr_addr *, int, int *, int);
int	 pfr_set_addrs(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int *, int *, int);
int	 pfr_get_addrs(struct pfr_table *, struct pfr_addr *, int *, int);
int	 pfr_get_astats(struct pfr_table *, struct pfr_astats *, int *, int);
int	 pfr_tst_addrs(struct pfr_table *, struct pfr_addr *, int, int *, int);
int	 pfr_ina_define(struct pfr_table *, struct pfr_addr *, int, int *,
	    int *, int, int);
void	 pfr_buf_clear(struct pfr_buffer *);
int	 pfr_buf_add(struct pfr_buffer *, const void *);
void	*pfr_buf_next(struct pfr_buffer *, const void *);
int	 pfr_buf_grow(struct pfr_buffer *, int);
int	 pfr_buf_load(struct pfr_buffer *, char *, int, int);
char	*pfr_strerror(int);
int	 pfi_get_ifaces(const char *, struct pfi_kif *, int *);
int	 pfi_clr_istats(const char *, int *, int);

void	 pfctl_print_title(char *);
void	 pfctl_clear_tables(const char *, int);
void	 pfctl_show_tables(const char *, int);
int	 pfctl_command_tables(int, char *[], char *, const char *, char *,
	    const char *, int);
void	 warn_namespace_collision(const char *);
void	 pfctl_show_ifaces(const char *, int);
FILE	*pfctl_fopen(const char *, const char *);

/*
 * generalized service curve used for admission control
 */
struct segment {
	LIST_ENTRY(segment)	_next;
	double			x, y, d, m;
};

void	 print_addr(struct pf_addr_wrap *, sa_family_t, int);
void	 print_host(struct pf_addr *, u_int16_t p, sa_family_t, u_int16_t, const char *, int);
void	 print_seq(struct pfsync_state_peer *);
void	 print_state(struct pfsync_state *, int);
int	 unmask(struct pf_addr *, sa_family_t);

int	 pfctl_cmdline_symset(char *);
int	 pfctl_add_trans(struct pfr_buffer *, int, const char *);
u_int32_t
	 pfctl_get_ticket(struct pfr_buffer *, int, const char *);
int	 pfctl_trans(int, struct pfr_buffer *, u_long, int);

int	 pfctl_show_queues(int, const char *, int, int);

#endif /* _PFCTL_H_ */
@


1.54
log
@sbin/pfctl: void functions and exit(3) on error

Changes:
 voided:
  - pfctl_clear_tables
  - pfctl_show_tables
  - pfctl_show_ifaces

Those functions now exit(3) in case of error instead
of passing it up to the callers (where it was ignored).

OK mikeb@@, sashan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.53 2015/01/19 23:52:02 deraadt Exp $ */
d72 1
a72 1
int	 pfr_buf_load(struct pfr_buffer *, char *, int);
@


1.53
log
@DEFAULT_PRIORITY and DEFAULT_QLIMIT no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.52 2014/04/19 14:22:32 henning Exp $ */
d78 2
a79 2
int	 pfctl_clear_tables(const char *, int);
int	 pfctl_show_tables(const char *, int);
d83 1
a83 1
int	 pfctl_show_ifaces(const char *, int);
@


1.52
log
@remove altq bits here, too
(i was convinced i committed that yesterday already, hrm)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.51 2013/10/12 12:16:11 henning Exp $ */
a84 8

#ifndef DEFAULT_PRIORITY
#define DEFAULT_PRIORITY	1
#endif

#ifndef DEFAULT_QLIMIT
#define DEFAULT_QLIMIT		50
#endif
@


1.51
log
@config bits for the bandwidth shaping part of the new queueing subsystem
syntax worked out with many in ljubljana using a whiteboard, testing &
looking over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.50 2012/07/08 17:48:37 lteo Exp $ */
a81 1
int	 pfctl_show_altq(int, const char *, int, int);
a100 5

int		 check_commit_altq(int, int);
void		 pfaltq_store(struct pf_altq *);
struct pf_altq	*pfaltq_lookup(const char *);
char		*rate2str(double);
@


1.50
log
@New attempt to make the -P flag work with -ss, so that states can be
printed with port names if desired.

tcpdump's pf_print_state.c has diverged significantly from pfctl's, so
the change to tcpdump's pf_print_state.c is not exactly the same as
pfctl's.

ok henning sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.49 2012/06/01 08:35:45 jsg Exp $ */
d119 2
@


1.49
log
@revert previous, breaks tcpdump
spotted by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.48 2012/06/01 02:44:36 lteo Exp $ */
d109 1
a109 1
void	 print_host(struct pf_addr *, u_int16_t p, sa_family_t, u_int16_t, int);
@


1.48
log
@Make the -P flag work with -ss, so that states can be printed with port
names if desired.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.47 2011/07/27 00:26:10 mcbride Exp $ */
d109 1
a109 1
void	 print_host(struct pf_addr *, u_int16_t p, sa_family_t, u_int16_t, const char *, int);
@


1.47
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.46 2010/11/12 13:14:41 claudio Exp $ */
d109 1
a109 1
void	 print_host(struct pf_addr *, u_int16_t p, sa_family_t, u_int16_t, int);
@


1.46
log
@The ioctl to show states returns a pfsync_state which is in network byte
order and therefore a ntohs is needed to show the rdomain correctly.
OK henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.45 2010/03/23 13:31:29 henning Exp $ */
d72 1
a72 2
int	 pfr_buf_load(struct pfr_buffer *, char *, int,
	    int (*)(struct pfr_buffer *, char *, int));
@


1.45
log
@remove -A, -O, -R and -T load
the partial loading of a ruleset (leaving ancors aside) is wrong and
conflicts with the general idea of how pf works. last not least it breaks
with the optimizer generating tables automagically.
ok deraadt sthen krw manpage jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.44 2009/11/03 10:59:04 claudio Exp $ */
d110 1
a110 1
void	 print_host(struct pf_addr *, u_int16_t p, sa_family_t, int, int);
@


1.44
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.43 2008/05/29 01:00:53 mcbride Exp $ */
a102 2

extern	int loadopt;
@


1.43
log
@Second half of PF state table rearrangement.
- Mechanical change: Use arrays for state key pointers in pf_state, and
  addr/port in pf_state_key, to allow the use of indexes.
- Fix NAT, pfsync, pfctl, and tcpdump to handle the new state structures.
  In struct pfsync_state, both state keys are included even when identical.
- Also fix some bugs discovered in the existing code during testing.
  (in particular, "block return" for TCP packets was not returning an RST)

ok henning beck deraadt
tested by otto dlg beck laurent

Special thanks to users Manuel Pata and Emilio Perea who did enough testing
to actually find some bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.42 2007/12/05 12:01:47 chl Exp $ */
d112 1
a112 1
void	 print_host(struct pf_addr *, u_int16_t p, sa_family_t, int);
@


1.42
log
@remove unused functions

from tobias@@

ok mcbride@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.41 2007/05/31 04:13:37 mcbride Exp $ */
d112 1
a112 1
void	 print_host(struct pfsync_state_host *, sa_family_t, int);
@


1.41
log
@Cope with new ioctl interface (use pfsync_state instead of pf_state)

ok henning@@ toby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.40 2007/02/09 11:25:27 henning Exp $ */
a50 1
void	 pfr_set_fd(int);
a64 1
int	 pfr_clr_astats(struct pfr_table *, struct pfr_addr *, int, int *, int);
a65 1
int	 pfr_set_tflags(struct pfr_table *, int, int, int, int *, int *, int);
@


1.40
log
@use DIOCGETRULE ioctl & action set to PF_GET_CLR_CNTR to clear counters
with -z instead of DIOCCLRRULECTRS. Unbreaks -z with anchors and makes the
read & reset operation atomic.
innstrument pfctl_show_rules() to clear counters while reading rules and
add a new output format for it, showing nothing, if only resetting counters
without actually displaying them is requested. minor cleanups on the way.
ok dhartmei & agreement from theo and ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.39 2006/01/28 18:54:28 henning Exp $ */
d115 3
a117 3
void	 print_host(struct pf_state_host *, sa_family_t, int);
void	 print_seq(struct pf_state_peer *);
void	 print_state(struct pf_state *, int);
@


1.39
log
@zap unused function
From: Andrey Matveev <evol@@online.ptt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.38 2005/05/21 21:03:58 henning Exp $ */
d35 2
@


1.38
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.37 2005/01/05 18:23:10 mcbride Exp $ */
a108 1
void		 pfaltq_free(struct pf_altq *);
@


1.37
log
@Modify pfctl behaviour so that 'set ...' options are no longer "sticky", ie.
they are reset to default values if omitted from a subsequent ruleset load.
Also:
- make sure 'set ...' options are not loaded in anchors.
- add a -m ("merge") flag to pfctl which allows an individual option to be set
  without reseting the others, eg:
   # echo "set loginterface fxp0" | pfctl -mf -

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.36 2004/06/14 20:44:22 cedric Exp $ */
d76 1
a76 1
int	 pfi_get_ifaces(const char *, struct pfi_if *, int *, int);
@


1.36
log
@Remove unused functions. ok beck@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.35 2004/05/19 17:50:51 dhartmei Exp $ */
d104 2
@


1.35
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.34 2004/04/09 12:42:06 cedric Exp $ */
a66 2
int	 pfr_ina_begin(struct pfr_table *, int *, int *, int);
int	 pfr_ina_commit(struct pfr_table *, int, int *, int *, int);
@


1.34
log
@Do not try to load directories. found+ok mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.33 2004/02/19 21:37:01 cedric Exp $ */
d82 2
a83 2
int	 pfctl_clear_tables(const char *, const char *, int);
int	 pfctl_show_tables(const char *, const char *, int);
d85 1
a85 1
	    const char *, const char *, int);
d120 1
a120 1
int	 pfctl_add_trans(struct pfr_buffer *, int, const char *, const char *);
d122 1
a122 1
	 pfctl_get_ticket(struct pfr_buffer *, int, const char *, const char *);
@


1.33
log
@Makes pfctl -ss and pfctl -sq use optional -i argument.
ok dhartmei@@ markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.32 2004/02/17 08:48:29 cedric Exp $ */
d89 1
@


1.32
log
@add -i flag, use it for -sI as a start. ok henning@@, ok+test mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.31 2004/02/10 22:26:56 dhartmei Exp $ */
d86 1
a86 1
int	 pfctl_show_altq(int, int, int);
@


1.31
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.30 2004/01/29 01:25:13 mcbride Exp $ */
d88 1
a88 1
int	 pfctl_show_ifaces(int);
@


1.30
log
@Clean up 'pfctl -s all' output.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.29 2003/12/31 11:18:24 cedric Exp $ */
d61 1
a61 1
	     int *, int *, int *, int);
d78 2
a79 2
int      pfi_get_ifaces(const char *, struct pfi_if *, int *, int);
int      pfi_clr_istats(const char *, int *, int);
@


1.29
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.28 2003/11/06 15:01:30 henning Exp $ */
d81 1
@


1.28
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.27 2003/10/08 14:47:57 henning Exp $ */
d36 2
a37 2
enum {	PFRB_TABLES = 1, PFRB_TSTATS, PFRB_ADDRS, PFRB_ASTATS, PFRB_TRANS,
	PFRB_MAX };
d78 2
d87 1
@


1.27
log
@fix cedric's breakage:
int is not the same as u_long
caused an integer overflow on our 64 bit archs and thus made pf not working
there

ok mcbride@@ marc@@ millert@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.26 2003/09/26 21:44:09 cedric Exp $ */
d116 1
a116 1
u_int32_t 
@


1.26
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.25 2003/08/29 21:47:36 cedric Exp $ */
d118 1
a118 1
int	 pfctl_trans(int, struct pfr_buffer *, int, int);
@


1.25
log
@Document interactions between tables and anchors.
Add a warning on global/anchor name clashes to help prevent mistakes from our
users during the 3.3 -> 3.4 switch.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.24 2003/07/31 22:25:54 cedric Exp $ */
d36 2
a37 1
enum {	PFRB_TABLES = 1, PFRB_TSTATS, PFRB_ADDRS, PFRB_ASTATS, PFRB_MAX };
d115 4
@


1.24
log
@Make table tickets per-ruleset instead of global.
Make table tickets u_int32_t for consistency with other parts of PF.
Ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.23 2003/07/04 11:05:44 henning Exp $ */
d83 1
@


1.23
log
@KNF after cedric (grmpf)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.22 2003/07/03 09:13:06 cedric Exp $ */
d66 2
a67 2
int	 pfr_ina_begin(int *, int *, int);
int	 pfr_ina_commit(int, int *, int *, int);
@


1.22
log
@This patch finally cleanup pfctl_table.c. No more global buffer,
and a couple of parsing functions moved to parse.y or pfctl_parser
where they belong.

I also took the opportunity to replace "void" functions with exit(1)
or err() inside by "int" functions, with the caller checking the
return value for errors (much cleaner and an old request from Theo)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.21 2003/06/30 20:02:46 cedric Exp $ */
d44 1
a44 1
	for((var) = pfr_buf_next((buf), NULL);		\
@


1.21
log
@Buffer management functions.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.20 2003/06/27 15:35:00 cedric Exp $ */
d41 1
a41 1
	caddr_t	 pfrb_caddr;	/* malloc'ated memory area */
d74 2
a75 1
void	 pfr_buf_load(char *, int, void (*)(char *, int));
@


1.20
log
@Reorg part I: move 3 functions out of pf_table.c to pf_radix.c
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.19 2003/06/08 09:41:07 cedric Exp $ */
d36 12
d70 4
@


1.19
log
@A table in an anchor creates a real anchor: pfctl -sA works.
The following two pfctl functions work with an "-a" option:
  - pfctl [-a foo[:bar]] -sT
  - pfctl [-a foo[:bar]] -FT
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.18 2003/04/30 12:30:27 cedric Exp $ */
d58 3
@


1.18
log
@Allow tables to be loaded into anchors.
Most pfctl table commands (excluding 'show' and 'flush') support the "-a"
modifier.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.17 2003/04/14 14:50:46 henning Exp $ */
d38 1
a38 1
int	 pfr_clr_tables(int *, int);
d41 2
a42 2
int	 pfr_get_tables(struct pfr_table *, int *, int);
int	 pfr_get_tstats(struct pfr_tstats *, int *, int);
@


1.17
log
@let print_altq and print_queue take a struct node_queue_bw parameter instead
of dintinct bw_percent
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.16 2003/04/11 15:18:33 henning Exp $ */
d58 4
a61 3
int	 pfctl_clear_tables(int);
int	 pfctl_show_tables(int);
int	 pfctl_command_tables(int, char *[], char *, const char *, char *, int);
@


1.16
log
@qname_to_qid and qname_to_pfaltq can be private functions now; nothing
outside pfctl_altq.c uses them any more, nor should.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.15 2003/04/11 15:13:34 henning Exp $ */
a83 3

void	 print_altq(const struct pf_altq *, unsigned, u_int16_t);
void	 print_queue(const struct pf_altq *, unsigned, u_int16_t, int);
@


1.15
log
@kill dead code.
qid_to_qname is not used anywhere. moreover, I cannot think of any
legitimate use; misuse is easy tho.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.14 2003/04/05 21:44:46 henning Exp $ */
a82 2
struct pf_altq	*qname_to_pfaltq(const char *, const char *);
u_int32_t	 qname_to_qid(const char *);
@


1.14
log
@allow queue specs to be limited to certain interfaces.

altq on { $if0 $if1 $if2 $if3 } priq bandwidth 10Mb queue { one two }
queue one priority 1 priq(default)
queue two on $if0 priority 15
queue two on ! $if0 priority 0

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.13 2003/03/27 18:01:57 henning Exp $ */
a84 1
char		*qid_to_qname(u_int32_t, const char *);
@


1.13
log
@lotsa const char *
from David Hill <david at phobia.ms> a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.12 2003/03/06 12:50:40 henning Exp $ */
d89 1
a89 1
void	 print_queue(const struct pf_altq *, unsigned, u_int16_t);
@


1.12
log
@fix queue assignment on filter rules which are not bound to an interface.
when looking up the queue IDs using qname_to_qid, we do not need to limit
the matching on the interface in question, as it is guaranteed that same
named queues on different interfaces habe the same queue id. moreover, we
must not limit the matches to the interface if we do not have an interface
given on the filter rule to match on ;-)

found after problems reported by Andre Nathan <andre at v2r dot com dot br>

ok dhartmei@@ pb@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.11 2003/03/02 23:37:24 henning Exp $ */
d60 1
a60 1
int	 pfctl_command_tables(int, char *[], char *, char *, char *, int);
@


1.11
log
@when printing queues at load time that have bandwidth specified in percent,
print the bandwidth in percent instead of the calculated absolute value.
if a queue belongs to more than one interface and they have different
bandwidth the calculated absolute is of course different per interface.
previously the first calculated absolute value was shown; what of course is
incorrect on the second interface. note that only the print was wrong, the
correct values were passed to the kernel.

ok theo daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.10 2003/02/11 20:11:36 henning Exp $ */
d84 1
a84 1
u_int32_t	 qname_to_qid(const char *, const char *);
@


1.10
log
@allow macro definition on the command line:
pfctl -Dextif=wi0 -f /etc/pf.conf
command line macro definitions override the ones made in the file (idea
theo), very handy if your notebook has another NIC at some conference, as
well as for debugging etc.
idea rezine@@mistrusted.net via pb@@
hacked live at FOSDEM

ok pb@@ dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.9 2003/01/24 11:11:17 henning Exp $ */
d88 2
a89 2
void	 print_altq(const struct pf_altq *, unsigned);
void	 print_queue(const struct pf_altq *, unsigned);
@


1.9
log
@let pfctl -vvsq loop and display measured bandwidth and packets/s per queue.
cbq only for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.8 2003/01/24 10:53:32 henning Exp $ */
d96 2
@


1.8
log
@export rate2str
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.7 2003/01/20 19:05:46 camield Exp $ */
d61 1
a61 1
int	 pfctl_show_altq(int, int);
@


1.7
log
@no named parameters in prototypes

ok dhartmei cedric henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.6 2003/01/20 17:16:56 cedric Exp $ */
d86 1
@


1.6
log
@Improve pfctl -vvs{r,n} output with rule containing tables.
Shows the number of entries in the table or if the table is not active.
ok dhartmei@@, no objections.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.5 2003/01/09 17:33:19 henning Exp $ */
d38 1
a38 1
int	 pfr_clr_tables(int *ndel, int);
d93 1
a93 1
void	 print_state(struct pf_state *s, int);
@


1.5
log
@first attack at pfctl queue statistics, to be displayed with pfctl -vsq

This commit is dedicated to the cute KLM girls who made part of this
possible with giving me a seat in the plane where you actually have enough
place to hack. Thanks, girls.

ok markus@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.4 2003/01/09 10:40:44 cedric Exp $ */
d90 1
a90 1
void	 print_addr(struct pf_addr_wrap *, sa_family_t);
@


1.4
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.3 2003/01/07 00:21:08 dhartmei Exp $ */
d61 1
a77 14

struct pf_altq_node {
	struct pf_altq		 altq;
	struct pf_altq_node	*next;
	struct pf_altq_node	*children;
};

void			 pfctl_insert_altq_node(struct pf_altq_node **,
			    const struct pf_altq);
struct pf_altq_node	*pfctl_find_altq_node(struct pf_altq_node *,
			    const char *, const char *);
void			 pfctl_print_altq_node(const struct pf_altq_node *,
			    unsigned);
void			 pfctl_free_altq_node(struct pf_altq_node *);
@


1.3
log
@Remove table name hashing (pass the name in each ioctl instead), and
introduce reference counting for tables, they are now automatically
created and deleted through referencing rules. Diff partly from cedric@@.
ok mcbride@@, henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.2 2003/01/04 22:42:14 henning Exp $ */
d53 5
@


1.2
log
@minor style
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl.h,v 1.1 2003/01/04 00:01:34 deraadt Exp $ */
a52 2
int	 pfr_wrap_table(struct pfr_table *, struct pf_addr_wrap *, int *, int);
int	 pfr_unwrap_table(struct pfr_table *, struct pf_addr_wrap *, int);
@


1.1
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.h,v 1.8 2002/11/30 13:53:15 mickey Exp $ */
d61 3
d100 5
a104 5
void	print_addr(struct pf_addr_wrap *, sa_family_t);
void	print_host(struct pf_state_host *, sa_family_t, int);
void	print_seq(struct pf_state_peer *);
void	print_state(struct pf_state *s, int);
int	unmask(struct pf_addr *, sa_family_t);
@

