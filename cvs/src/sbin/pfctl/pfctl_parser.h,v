head	1.105;
access;
symbols
	OPENBSD_6_1:1.105.0.6
	OPENBSD_6_1_BASE:1.105
	OPENBSD_6_0:1.105.0.2
	OPENBSD_6_0_BASE:1.105
	OPENBSD_5_9:1.104.0.4
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.104.0.6
	OPENBSD_5_8_BASE:1.104
	OPENBSD_5_7:1.104.0.2
	OPENBSD_5_7_BASE:1.104
	OPENBSD_5_6:1.102.0.4
	OPENBSD_5_6_BASE:1.102
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.99.0.8
	OPENBSD_5_4_BASE:1.99
	OPENBSD_5_3:1.99.0.6
	OPENBSD_5_3_BASE:1.99
	OPENBSD_5_2:1.99.0.4
	OPENBSD_5_2_BASE:1.99
	OPENBSD_5_1_BASE:1.99
	OPENBSD_5_1:1.99.0.2
	OPENBSD_5_0:1.97.0.2
	OPENBSD_5_0_BASE:1.97
	OPENBSD_4_9:1.94.0.4
	OPENBSD_4_9_BASE:1.94
	OPENBSD_4_8:1.94.0.2
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.92.0.2
	OPENBSD_4_7_BASE:1.92
	OPENBSD_4_6:1.88.0.4
	OPENBSD_4_6_BASE:1.88
	OPENBSD_4_5:1.87.0.6
	OPENBSD_4_5_BASE:1.87
	OPENBSD_4_4:1.87.0.4
	OPENBSD_4_4_BASE:1.87
	OPENBSD_4_3:1.87.0.2
	OPENBSD_4_3_BASE:1.87
	OPENBSD_4_2:1.86.0.4
	OPENBSD_4_2_BASE:1.86
	OPENBSD_4_1:1.86.0.2
	OPENBSD_4_1_BASE:1.86
	OPENBSD_4_0:1.83.0.4
	OPENBSD_4_0_BASE:1.83
	OPENBSD_3_9:1.83.0.2
	OPENBSD_3_9_BASE:1.83
	OPENBSD_3_8:1.80.0.4
	OPENBSD_3_8_BASE:1.80
	OPENBSD_3_7:1.80.0.2
	OPENBSD_3_7_BASE:1.80
	OPENBSD_3_6:1.77.0.2
	OPENBSD_3_6_BASE:1.77
	OPENBSD_3_5:1.74.0.2
	OPENBSD_3_5_BASE:1.74
	OPENBSD_3_4:1.67.0.2
	OPENBSD_3_4_BASE:1.67
	OPENBSD_3_3:1.50.0.2
	OPENBSD_3_3_BASE:1.50
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.105
date	2016.07.18.19.11.18;	author henning;	state Exp;
branches;
next	1.104;
commitid	eQpjIFzeyzGKCU43;

1.104
date	2014.10.27.21.51.32;	author mikeb;	state Exp;
branches;
next	1.103;
commitid	a2mU7I61ROTRhch2;

1.103
date	2014.08.23.00.11.03;	author pelikan;	state Exp;
branches;
next	1.102;
commitid	YY1Dd1zH9rSATCPx;

1.102
date	2014.04.19.14.22.32;	author henning;	state Exp;
branches
	1.102.4.1;
next	1.101;

1.101
date	2013.10.12.12.16.12;	author henning;	state Exp;
branches
	1.101.4.1;
next	1.100;

1.100
date	2013.08.01.19.03.11;	author mikeb;	state Exp;
branches;
next	1.99;

1.99
date	2011.12.03.12.46.16;	author mcbride;	state Exp;
branches
	1.99.8.1;
next	1.98;

1.98
date	2011.11.23.10.24.37;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.96;

1.96
date	2011.07.03.23.37.55;	author zinke;	state Exp;
branches;
next	1.95;

1.95
date	2011.04.06.13.19.55;	author claudio;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.25.23.27.47;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2010.03.23.13.31.29;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.91;

1.91
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.90;

1.90
date	2010.01.10.07.45.41;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2009.09.01.13.42.00;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2009.04.06.12.05.55;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.13.16.35.18;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2006.10.31.23.46.25;	author mcbride;	state Exp;
branches;
next	1.85;

1.85
date	2006.10.31.14.17.45;	author mcbride;	state Exp;
branches;
next	1.84;

1.84
date	2006.10.28.14.29.05;	author mcbride;	state Exp;
branches;
next	1.83;

1.83
date	2005.11.17.20.52.39;	author dhartmei;	state Exp;
branches;
next	1.82;

1.82
date	2005.10.13.13.27.06;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2005.10.13.12.54.01;	author henning;	state Exp;
branches;
next	1.80;

1.80
date	2005.02.07.18.18.14;	author david;	state Exp;
branches;
next	1.79;

1.79
date	2005.01.05.18.23.10;	author mcbride;	state Exp;
branches;
next	1.78;

1.78
date	2004.12.22.17.17.55;	author dhartmei;	state Exp;
branches;
next	1.77;

1.77
date	2004.07.16.23.44.25;	author frantzen;	state Exp;
branches;
next	1.76;

1.76
date	2004.05.19.17.50.51;	author dhartmei;	state Exp;
branches;
next	1.75;

1.75
date	2004.04.14.11.16.43;	author cedric;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.10.22.26.56;	author dhartmei;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.29.01.25.13;	author mcbride;	state Exp;
branches;
next	1.72;

1.72
date	2003.12.31.11.18.24;	author cedric;	state Exp;
branches;
next	1.71;

1.71
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.70;

1.70
date	2003.12.15.00.02.03;	author mcbride;	state Exp;
branches;
next	1.69;

1.69
date	2003.11.14.13.51.09;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2003.09.26.21.44.09;	author cedric;	state Exp;
branches;
next	1.67;

1.67
date	2003.08.21.19.12.09;	author frantzen;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.31.22.25.54;	author cedric;	state Exp;
branches;
next	1.65;

1.65
date	2003.07.18.06.30.07;	author cedric;	state Exp;
branches;
next	1.64;

1.64
date	2003.07.11.08.29.34;	author cedric;	state Exp;
branches;
next	1.63;

1.63
date	2003.07.03.21.09.13;	author cedric;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.03.09.13.06;	author cedric;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.19.20.21.53;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.10.00.45.24;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2003.04.30.12.30.27;	author cedric;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.15.11.29.24;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.14.14.50.46;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.13.20.41.37;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2003.04.13.20.16.06;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.13.19.36.00;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2003.04.05.23.56.32;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2003.04.03.15.52.24;	author cedric;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.27.18.01.57;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.07.12.55.37;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.18.21.59.34;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.16.14.04.34;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.03.14.51.36;	author cedric;	state Exp;
branches;
next	1.46;

1.46
date	2003.02.03.13.40.45;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.02.23.22.07;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2003.02.02.18.32.35;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.25.18.16.05;	author cedric;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.25.16.33.19;	author cedric;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.18.15.00.24;	author cedric;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.14.21.58.12;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.22.14.19.29;	author dhartmei;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.18.19.40.41;	author dhartmei;	state Exp;
branches;
next	1.35;

1.35
date	2002.12.18.14.14.09;	author mcbride;	state Exp;
branches;
next	1.34;

1.34
date	2002.12.17.12.36.59;	author mcbride;	state Exp;
branches;
next	1.33;

1.33
date	2002.12.05.14.10.45;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.04.08.07.28;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.30.13.53.15;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.28.12.14.25;	author mcbride;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.23.06.18.42;	author mcbride;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.23.05.22.24;	author mcbride;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.18.22.49.15;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.25.10.40.45;	author camield;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.25.08.13.26;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.11.06.12.15;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.11.03.12.03;	author dhartmei;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.11.02.12.37;	author dhartmei;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.11.01.58.00;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.08.21.09.59;	author dhartmei;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.07.58.07;	author dhartmei;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.07.19.33.03;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.06.22.22.44;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.01.04.06.47;	author hugh;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.11.22.22.57;	author dhartmei;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.27.18.11.45;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.09.11.30.53;	author dhartmei;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.04.21.54.15;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.01.17.58.16;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.15.03.54.40;	author frantzen;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.06.18.05.46;	author jasoni;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.23.04.10.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.11.09.54.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.16.21.09.38;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.25.18.02.44;	author dhartmei;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.25.09.44.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.23.16.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.24.21.40.51;	author dhartmei;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.24.21.04.16;	author kjell;	state Exp;
branches;
next	;

1.99.8.1
date	2014.10.29.15.36.44;	author sthen;	state Exp;
branches;
next	;
commitid	KDltmIoVhxTrRd6T;

1.101.4.1
date	2014.10.29.15.36.15;	author sthen;	state Exp;
branches;
next	;
commitid	HPnolLQ40jcwDio1;

1.102.4.1
date	2014.10.29.15.29.34;	author sthen;	state Exp;
branches;
next	;
commitid	fYdjk1qSZRmnT7ec;


desc
@@


1.105
log
@no more cbq_opts - CBQ is gone, ok mpi phessler benno
@
text
@/*	$OpenBSD: pfctl_parser.h,v 1.103 2014/08/23 00:11:03 pelikan Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002 - 2013 Henning Brauer <henning@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef _PFCTL_PARSER_H_
#define _PFCTL_PARSER_H_

#define PF_OSFP_FILE		"/etc/pf.os"

#define PF_OPT_DISABLE		0x0001
#define PF_OPT_ENABLE		0x0002
#define PF_OPT_VERBOSE		0x0004
#define PF_OPT_NOACTION		0x0008
#define PF_OPT_QUIET		0x0010
#define PF_OPT_CLRRULECTRS	0x0020
#define PF_OPT_USEDNS		0x0040
#define PF_OPT_VERBOSE2		0x0080
#define PF_OPT_DUMMYACTION	0x0100
#define PF_OPT_DEBUG		0x0200
#define PF_OPT_SHOWALL		0x0400
#define PF_OPT_OPTIMIZE		0x0800
#define PF_OPT_RECURSE		0x4000
#define PF_OPT_PORTNAMES	0x8000

#define PF_TH_ALL		0xFF

#define PF_NAT_PROXY_PORT_LOW	50001
#define PF_NAT_PROXY_PORT_HIGH	65535

#define PF_OPTIMIZE_BASIC	0x0001
#define PF_OPTIMIZE_PROFILE	0x0002

#define FCNT_NAMES { \
	"searches", \
	"inserts", \
	"removals", \
	NULL \
}

struct pfr_buffer;	/* forward definition */


struct pfctl {
	int dev;
	int opts;
	int optimize;
	int asd;			/* anchor stack depth */
	int bn;				/* brace number */
	int brace;
	int tdirty;			/* kernel dirty */
#define PFCTL_ANCHOR_STACK_DEPTH 64
	struct pf_anchor *astack[PFCTL_ANCHOR_STACK_DEPTH];
	struct pfioc_queue *pqueue;
	struct pfr_buffer *trans;
	struct pf_anchor *anchor, *alast;
	const char *ruleset;

	/* 'set foo' options */
	u_int32_t	 timeout[PFTM_MAX];
	u_int32_t	 limit[PF_LIMIT_MAX];
	u_int32_t	 debug;
	u_int32_t	 hostid;
	u_int32_t	 reassemble;
	char		*ifname;

	u_int8_t	 timeout_set[PFTM_MAX];
	u_int8_t	 limit_set[PF_LIMIT_MAX];
	u_int8_t	 debug_set;
	u_int8_t	 hostid_set;
	u_int8_t	 ifname_set;
	u_int8_t	 reass_set;
};

struct node_if {
	char			 ifname[IFNAMSIZ];
	u_int8_t		 not;
	u_int8_t		 dynamic; /* antispoof */
	u_int8_t		 use_rdomain;
	u_int			 ifa_flags;
	int			 rdomain;
	struct node_if		*next;
	struct node_if		*tail;
};

struct node_host {
	struct pf_addr_wrap	 addr;
	struct pf_addr		 bcast;
	struct pf_addr		 peer;
	sa_family_t		 af;
	u_int8_t		 not;
	u_int32_t		 ifindex;	/* link-local IPv6 addrs */
	u_int16_t		 weight;	/* load balancing weight */
	char			*ifname;
	u_int			 ifa_flags;
	struct node_host	*next;
	struct node_host	*tail;
};
void	freehostlist(struct node_host *);

struct node_os {
	char			*os;
	pf_osfp_t		 fingerprint;
	struct node_os		*next;
	struct node_os		*tail;
};

struct node_queue_bw {
	u_int32_t	bw_absolute;
	u_int16_t	bw_percent;
};

struct node_hfsc_sc {
	struct node_queue_bw	m1;	/* slope of 1st segment; bps */
	u_int			d;	/* x-projection of m1; msec */
	struct node_queue_bw	m2;	/* slope of 2nd segment; bps */
	u_int8_t		used;
};

struct node_hfsc_opts {
	struct node_hfsc_sc	realtime;
	struct node_hfsc_sc	linkshare;
	struct node_hfsc_sc	upperlimit;
	int			flags;
};

struct node_queue_opt {
	int			 qtype;
	union {
		struct priq_opts	priq_opts;
		struct node_hfsc_opts	hfsc_opts;
	}			 data;
};

SIMPLEQ_HEAD(node_tinithead, node_tinit);
struct node_tinit {	/* table initializer */
	SIMPLEQ_ENTRY(node_tinit)	 entries;
	struct node_host		*host;
	char				*file;
};


/* optimizer created tables */
struct pf_opt_tbl {
	char			 pt_name[PF_TABLE_NAME_SIZE];
	int			 pt_rulecount;
	int			 pt_generated;
	u_int32_t		 pt_flags;
	struct node_tinithead	 pt_nodes;
	struct pfr_buffer	*pt_buf;
};
#define PF_OPT_TABLE_PREFIX	"__automatic_"

/* optimizer pf_rule container */
struct pf_opt_rule {
	struct pf_rule		 por_rule;
	struct pf_opt_tbl	*por_src_tbl;
	struct pf_opt_tbl	*por_dst_tbl;
	u_int64_t		 por_profile_count;
	TAILQ_ENTRY(pf_opt_rule) por_entry;
	TAILQ_ENTRY(pf_opt_rule) por_skip_entry[PF_SKIP_COUNT];
};

TAILQ_HEAD(pf_opt_queue, pf_opt_rule);

extern TAILQ_HEAD(pf_qihead, pfctl_qsitem) qspecs, rootqs;
struct pfctl_qsitem {
	TAILQ_ENTRY(pfctl_qsitem)	 entries;
	struct pf_queuespec		 qs;
	struct pf_qihead		 children;
	int				 matches;
};


int	pfctl_rules(int, char *, int, int, char *, struct pfr_buffer *);
int	pfctl_optimize_ruleset(struct pfctl *, struct pf_ruleset *);
int     pf_opt_create_table(struct pfctl *, struct pf_opt_tbl *);
int     add_opt_table(struct pfctl *, struct pf_opt_tbl **, sa_family_t,
            struct pf_rule_addr *, char *);

int	pfctl_add_rule(struct pfctl *, struct pf_rule *, const char *);
int	pfctl_add_pool(struct pfctl *, struct pf_pool *, sa_family_t, int);
void	pfctl_move_pool(struct pf_pool *, struct pf_pool *);
void	pfctl_clear_pool(struct pf_pool *);

int	pfctl_set_timeout(struct pfctl *, const char *, int, int);
int	pfctl_set_reassembly(struct pfctl *, int, int);
int	pfctl_set_optimization(struct pfctl *, const char *);
int	pfctl_set_limit(struct pfctl *, const char *, unsigned int);
int	pfctl_set_logif(struct pfctl *, char *);
void	pfctl_set_hostid(struct pfctl *, u_int32_t);
int	pfctl_set_debug(struct pfctl *, char *);
int	pfctl_set_interface_flags(struct pfctl *, char *, int, int);

int	parse_config(char *, struct pfctl *);
int	parse_flags(char *);
int	pfctl_load_anchors(int, struct pfctl *, struct pfr_buffer *);

int	pfctl_load_queues(struct pfctl *);
int	pfctl_add_queue(struct pfctl *, struct pf_queuespec *);
struct pfctl_qsitem *	pfctl_find_queue(char *, struct pf_qihead *);

void	print_pool(struct pf_pool *, u_int16_t, u_int16_t, sa_family_t, int, int);
void	print_src_node(struct pf_src_node *, int);
void	print_rule(struct pf_rule *, const char *, int);
void	print_tabledef(const char *, int, int, struct node_tinithead *);
void	print_status(struct pf_status *, int);
void	print_queuespec(struct pf_queuespec *);

int	pfctl_define_table(char *, int, int, const char *, struct pfr_buffer *,
	    u_int32_t);

void		 pfctl_clear_fingerprints(int, int);
int		 pfctl_file_fingerprints(int, int, const char *);
pf_osfp_t	 pfctl_get_fingerprint(const char *);
int		 pfctl_load_fingerprints(int, int);
char		*pfctl_lookup_fingerprint(pf_osfp_t, char *, size_t);
void		 pfctl_show_fingerprints(int);

struct icmptypeent {
	const char *name;
	u_int8_t type;
};

struct icmpcodeent {
	const char *name;
	u_int8_t type;
	u_int8_t code;
};

const struct icmptypeent *geticmptypebynumber(u_int8_t, u_int8_t);
const struct icmptypeent *geticmptypebyname(char *, u_int8_t);
const struct icmpcodeent *geticmpcodebynumber(u_int8_t, u_int8_t, u_int8_t);
const struct icmpcodeent *geticmpcodebyname(u_long, char *, u_int8_t);

int			  string_to_loglevel(const char *);
const char		 *loglevel_to_string(int);

struct pf_timeout {
	const char	*name;
	int		 timeout;
};

extern const struct pf_timeout pf_timeouts[];

void			 set_ipmask(struct node_host *, u_int8_t);
int			 check_netmask(struct node_host *, sa_family_t);
int			 unmask(struct pf_addr *, sa_family_t);
struct node_host	*gen_dynnode(struct node_host *, sa_family_t);
void			 ifa_load(void);
unsigned int		 ifa_nametoindex(const char *);
char			*ifa_indextoname(unsigned int, char *);
struct node_host	*ifa_exists(const char *);
struct node_host	*ifa_lookup(const char *, int);
struct node_host	*host(const char *);

int			 append_addr(struct pfr_buffer *, char *, int);
int			 append_addr_host(struct pfr_buffer *,
			    struct node_host *, int, int);

#endif /* _PFCTL_PARSER_H_ */
@


1.104
log
@Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
@
text
@a157 1
		struct cbq_opts		cbq_opts;
@


1.103
log
@when you specify queues in a rule, make sure they have been defined.

DIOCADDRULE EBUSY turns into an error message that pfctl -n catches.
DIOCXCOMMIT EINVAL after the kernel rejected the rules was reported
to occur, possibly from hfsc.c: this should be fixed as well.

ok henning mikeb sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.102 2014/04/19 14:22:32 henning Exp $ */
d278 1
@


1.102
log
@remove altq bits here, too
(i was convinced i committed that yesterday already, hrm)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.101 2013/10/12 12:16:12 henning Exp $ */
d195 9
d230 1
a287 8

TAILQ_HEAD(pf_qihead, pfctl_qsitem);
struct pfctl_qsitem {
	TAILQ_ENTRY(pfctl_qsitem)	 entries;
	struct pf_queuespec		 qs;
	struct pf_qihead		 children;
	int				 matches;
};
@


1.102.4.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.104 2014/10/27 21:51:32 mikeb Exp $ */
a267 1
struct node_host	*gen_dynnode(struct node_host *, sa_family_t);
@


1.101
log
@config bits for the bandwidth shaping part of the new queueing subsystem
syntax worked out with many in ljubljana using a whiteboard, testing &
looking over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.100 2013/08/01 19:03:11 mikeb Exp $ */
a81 1
	struct pfioc_altq *paltq;
a201 1
int	pfctl_add_altq(struct pfctl *, struct pf_altq *);
a228 10
int	eval_pfaltq(struct pfctl *, struct pf_altq *, struct node_queue_bw *,
	    struct node_queue_opt *);
int	eval_pfqueue(struct pfctl *, struct pf_altq *, struct node_queue_bw *,
	    struct node_queue_opt *);

void	 print_altq(const struct pf_altq *, unsigned, struct node_queue_bw *,
	    struct node_queue_opt *);
void	 print_queue(const struct pf_altq *, unsigned, struct node_queue_bw *,
	    int, struct node_queue_opt *);

a237 1

@


1.101.4.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.104 2014/10/27 21:51:32 mikeb Exp $ */
a280 1
struct node_host	*gen_dynnode(struct node_host *, sa_family_t);
@


1.100
log
@Provide local implementations of if_nametoindex(3) and if_indextoname(3)
that make use of the cache of addresses populated by the ifa_load on
startup to save the trouble of calling expensive getaddrinfo(3) up to
four times per rule.   Performance wise this change provides a speed up
factor of 20 with a 11k line ruleset on a machine with 150 VLANs and 250
IP addresses (20 seconds down to 1 in this case).

"wow!" henning, ok benno, florian
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.99 2011/12/03 12:46:16 mcbride Exp $ */
d5 1
d221 3
d229 1
d291 8
@


1.99
log
@pfctl_set_hostid always returns 0; don't pretend otherwise and make it a
void function instead.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.98 2011/11/23 10:24:37 henning Exp $ */
d277 2
@


1.99.8.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.104 2014/10/27 21:51:32 mikeb Exp $ */
a275 1
struct node_host	*gen_dynnode(struct node_host *, sa_family_t);
@


1.98
log
@print ports as numbers by default; -P prints names instead
2/2 from Lawrence Teo <lteo at devio dot us>
ok sthen dlg and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.97 2011/07/27 00:26:10 mcbride Exp $ */
d212 1
a212 1
int	pfctl_set_hostid(struct pfctl *, u_int32_t);
@


1.97
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.96 2011/07/03 23:37:55 zinke Exp $ */
d51 1
@


1.96
log
@bring in least-states load balancing algorithm

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.95 2011/04/06 13:19:55 claudio Exp $ */
d120 1
@


1.95
log
@Userland bits to allow PF to filter on the rdomain a packet belongs to.
This allows to write rules like "pass in on rdomain 1".
Tested by phessler@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.94 2010/06/25 23:27:47 henning Exp $ */
d175 1
@


1.94
log
@remove -m (merge).
it is violating the transactional model we have and made stronger in
pf, it is broken in some cases and since some options are passed to the
kernel while some are userland only and affect how the rules are
parsed it is complete bullshit anyway - obviously, changing options
that affect ruleset parsing without reloading and thus reparsing the
ruleset cannot work. so stop pretending it could and cut the crap.
ok dlg krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.93 2010/03/23 13:31:29 henning Exp $ */
d106 1
d108 1
@


1.93
log
@remove -A, -O, -R and -T load
the partial loading of a ruleset (leaving ancors aside) is wrong and
conflicts with the general idea of how pf works. last not least it breaks
with the optimizer generating tables automagically.
ok deraadt sthen krw manpage jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.92 2010/01/18 23:52:46 mcbride Exp $ */
a49 1
#define PF_OPT_MERGE		0x2000
@


1.92
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.91 2010/01/12 03:20:51 mcbride Exp $ */
a74 1
	int loadopt;
a265 6

#define PFCTL_FLAG_FILTER	0x02
#define PFCTL_FLAG_NAT		0x04
#define PFCTL_FLAG_OPTION	0x08
#define PFCTL_FLAG_ALTQ		0x10
#define PFCTL_FLAG_TABLE	0x20
@


1.91
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.90 2010/01/10 07:45:41 deraadt Exp $ */
d259 3
@


1.90
log
@In the non-optimized case, an address list containing "any" (ie. { any 10.0.0.1 })
should be folded in the parser to any, not to 10.0.0.1.  How long this bug has
been with us is unclear.
ok guenther mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.89 2009/09/01 13:42:00 henning Exp $ */
a81 1
	struct pfioc_pooladdr paddr;
d194 3
d217 1
a217 1
void	print_pool(struct pf_pool *, u_int16_t, u_int16_t, sa_family_t, int);
@


1.89
log
@the diff theo calls me insanae for:
rewrite of the NAT code, basically. nat and rdr become actions on regular
rules, seperate nat/rdr/binat rules do not exist any more.
match in on $intf rdr-to 1.2.3.4
match out on $intf nat-to 5.6.7.8
the code is capable of doing nat and rdr in any direction, but we prevent
this in pfctl for now, there are implications that need to be documented
better.
the address rewrite happens inline, subsequent rules will see the already
changed addresses. nat / rdr can be applied multiple times as well.
match in on $intf rdr-to 1.2.3.4
match in on $intf to 1.2.3.4 rdr-to 5.6.7.8
help and ok dlg sthen claudio, reyk tested too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.88 2009/04/06 12:05:55 henning Exp $ */
d126 1
@


1.88
log
@1) scrub rules are completely gone.
2) packet reassembly: only one method remains, full reassembly. crop
and drop-ovl are gone.
.  set reassemble yes|no [no-df]
if no-df is given fragments (and only fragments!) with the df bit set
have it cleared before entering the fragment cache, and thus the
reassembled packet doesn't have df set either. it does NOT touch
non-fragmented packets.
3) regular rules can have scrub options.
.  pass scrub(no-df, min-ttl 64, max-mss 1400, set-tos lowdelay)
.  match scrub(reassemble tcp, random-id)
of course all options are optional. the individual options still do
what they used to do on scrub rules, but everything is stateful now.
4) match rules
"match" is a new action, just like pass and block are, and can be used
like they do. opposed to pass or block, they do NOT change the
pass/block state of a packet. i. e.
.  pass
.  match
passes the packet, and
.  block
.  match
blocks it.
Every time (!) a match rule matches, i. e. not only when it is the
last matching rule, the following actions are set:
-queue assignment. can be overwritten later, the last rule that set a
queue wins. note how this is different from the last matching rule
wins, if the last matching rule has no queue assignments and the
second last matching rule was a match rule with queue assignments,
these assignments are taken.
-rtable assignments. works the same as queue assignments.
-set-tos, min-ttl, max-mss, no-df, random-id, reassemble tcp, all work
like the above
-logging. every matching rule causes the packet to be logged. this
 means a single packet can get logged more than once (think multiple log
 interfaces with different receivers, like pflogd and spamlogd)
.
almost entirely hacked at n2k9 in basel, could not be committed close to
release. this really should have been multiple diffs, but splitting them
now is not feasible any more. input from mcbride and dlg, and frantzen
about the fragment handling.
speedup around 7% for the common case, the more the more scrub rules
were in use.
manpage not up to date, being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.87 2007/10/13 16:35:18 deraadt Exp $ */
d197 1
a197 1
int	pfctl_add_pool(struct pfctl *, struct pf_pool *, sa_family_t);
@


1.87
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.86 2006/10/31 23:46:25 mcbride Exp $ */
d94 1
d102 1
d202 1
@


1.86
log
@Allow a user to recursively print anchors including those without
reserved names, if a trailing * is specified in the anchor name.
e.g. recursively print the main  ruleset:

	pfctl -a '*' -sr

Recursively print the spam anchor:

	pfctl -a 'spam*'
	pfctl -a 'spam/*'

Also fix a bug which prevented the contents of inline anchors with
explicit names from being loaded into the kernel.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.85 2006/10/31 14:17:45 mcbride Exp $ */
d190 1
a190 1
int	pfctl_rules(int, char *, FILE *, int, int, char *, struct pfr_buffer *);
d207 1
a207 1
int	parse_rules(FILE *, struct pfctl *);
@


1.85
log
@Allow pfctl ruleset optimizer to be controlled from the ruleset.

"set" "ruleset-optimization" [ "none" | "basic" | "profile" ]

You can optionally control ruleset optimization with these keywords on the
command line with the -o option; the command line setting will override the
pf.conf setting. The existing -o/-oo flags continue to work as expected.

cleanup and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.84 2006/10/28 14:29:05 mcbride Exp $ */
d51 1
@


1.84
log
@Load all rules into memory before loading into the kernel, and add support
for anchors loaded inline in pf.conf, enclosed in a brace-delimited
block ("{" "}").

anchor on fxp0 {
	pass in proto tcp port 22
}

The anchor name is optional on inline loaded anchors.

testing ckuethe@@
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.83 2005/11/17 20:52:39 dhartmei Exp $ */
a49 1
#define PF_OPT_OPTIMIZE_PROFILE	0x1000
d57 3
d73 1
d189 1
a189 1
int	pfctl_rules(int, char *, FILE *, int, char *, struct pfr_buffer *);
d208 1
a208 1
int	pfctl_load_anchors(int, int, struct pfr_buffer *);
@


1.83
log
@for pfctl -f rules, open the file before resetting options. when opening
the file fails, produce only the error message and leave options
unchanged. reported by Tamas TEVESZ, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.82 2005/10/13 13:27:06 henning Exp $ */
a65 2
struct pf_opt_rule;
TAILQ_HEAD(pf_opt_queue, pf_opt_rule);
d72 3
a74 1
	u_int32_t tticket;		/* table ticket */
d76 2
a77 1
	u_int32_t rule_nr;
d82 1
a82 1
	const char *anchor;
a83 1
	struct pf_opt_queue opt_queue;
a178 1
	char			 por_anchor[MAXPATHLEN];
d184 1
d187 1
a187 1
int	pfctl_optimize_rules(struct pfctl *);
d192 1
@


1.82
log
@unused parameters
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.81 2005/10/13 12:54:01 henning Exp $ */
d186 1
a186 1
int	pfctl_rules(int, char *, int, char *, struct pfr_buffer *);
@


1.81
log
@dead defines
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.80 2005/02/07 18:18:14 david Exp $ */
d266 1
a266 1
struct node_host	*ifa_exists(const char *, int);
@


1.80
log
@KNF; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.79 2005/01/05 18:23:10 mcbride Exp $ */
a119 4
/* special flags used by ifa_exists */
#define PF_IFA_FLAG_GROUP	0x10000
#define PF_IFA_FLAG_DYNAMIC	0x20000
#define PF_IFA_FLAG_CLONABLE	0x40000
@


1.79
log
@Modify pfctl behaviour so that 'set ...' options are no longer "sticky", ie.
they are reset to default values if omitted from a subsequent ruleset load.
Also:
- make sure 'set ...' options are not loaded in anchors.
- add a -m ("merge") flag to pfctl which allows an individual option to be set
  without reseting the others, eg:
   # echo "set loginterface fxp0" | pfctl -mf -

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.78 2004/12/22 17:17:55 dhartmei Exp $ */
a96 1
	
@


1.78
log
@Introduce 'set skip on <ifspec>' to support a list of interfaces where no
packet filtering should occur (like loopback, for instance).
Code from Max Laier, with minor improvements based on feedback from
deraadt@@. ok mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.77 2004/07/16 23:44:25 frantzen Exp $ */
d51 1
d84 14
@


1.77
log
@'pfctl -o' ruleset optimizer that doesnt change the meaning of the final ruleset
- remove identical and subsetted rules
- when advantageous merge rules w/ similar addresses into a table and one rule
- re-order rules to improve skip step performance (can do better w/ kernel mods)
- 'pfctl -oo' will load the currently running ruleset and use it as a profile
to direct the optimization of quicked rules
ok henning@@ mcbride@@.  man page help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.76 2004/05/19 17:50:51 dhartmei Exp $ */
d190 1
@


1.76
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.75 2004/04/14 11:16:43 cedric Exp $ */
d49 2
d64 5
d82 1
d153 22
a174 1
struct pfr_buffer;	/* forward definition */
d177 1
d253 1
@


1.75
log
@make antispoof work with dynamic addresses. ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.74 2004/02/10 22:26:56 dhartmei Exp $ */
d147 1
a147 1
int	pfctl_rules(int, char *, int, char *, char *, struct pfr_buffer *);
d149 1
a149 1
int	pfctl_add_rule(struct pfctl *, struct pf_rule *);
d167 1
a167 1
void	print_rule(struct pf_rule *, int);
d181 2
a182 2
int	pfctl_define_table(char *, int, int, const char *, const char *,
	    struct pfr_buffer *, u_int32_t);
@


1.74
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.73 2004/01/29 01:25:13 mcbride Exp $ */
d80 1
@


1.73
log
@Clean up 'pfctl -s all' output.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.72 2003/12/31 11:18:24 cedric Exp $ */
d176 1
a176 1
	     struct node_queue_opt *);
d178 1
a178 1
	     int, struct node_queue_opt *);
@


1.72
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.71 2003/12/15 07:11:30 mcbride Exp $ */
d48 1
@


1.71
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.70 2003/12/15 00:02:03 mcbride Exp $ */
a75 6
enum pfctl_iflookup_mode {
	PFCTL_IFLOOKUP_HOST,
	PFCTL_IFLOOKUP_NET,
	PFCTL_IFLOOKUP_BCAST
};

d87 1
d96 4
d222 2
a223 2
struct node_host	*ifa_exists(const char *);
struct node_host	*ifa_lookup(const char *, enum pfctl_iflookup_mode);
@


1.70
log
@Add support to track stateful connections by source ip. This allows us
to:
- Ensure that clients get a consistent IP mapping with load-balanced
  translation/routing rules
- Limit the number of simultaneous connections a client can make
- Limit the number of clients which can connect through a rule

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.69 2003/11/14 13:51:09 henning Exp $ */
d157 1
@


1.69
log
@allow the debuglevel to  be set from pf.conf (set debug)

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.68 2003/09/26 21:44:09 cedric Exp $ */
d164 1
d167 1
a167 1
void	print_status(struct pf_status *);
@


1.68
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.67 2003/08/21 19:12:09 frantzen Exp $ */
d157 1
@


1.67
log
@Add Michal Zalewski's p0f v2 style passive OS fingerprinting to PF.
Exposes the source IP's operating system to the filter language.
Interesting policy decisions are now enforceable:
.	block proto tcp from any os SCO
.	block proto tcp from any os Windows to any port smtp
.	rdr ... from any os "Windows 98" to port WWW -> 127.0.0.1 port 8001
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.66 2003/07/31 22:25:54 cedric Exp $ */
a68 1
	struct pfioc_rule *prule[PF_RULESET_MAX];
d71 1
d146 1
a146 1
int	pfctl_rules(int, char *, int, char *, char *);
d160 1
a160 1
int	pfctl_load_anchors(int, int);
@


1.66
log
@Make table tickets per-ruleset instead of global.
Make table tickets u_int32_t for consistency with other parts of PF.
Ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.65 2003/07/18 06:30:07 cedric Exp $ */
d36 2
d102 7
d179 8
@


1.65
log
@Simplify handling of flags (-R, -N...). Remove PFCTL_FLAG_ALL.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.64 2003/07/11 08:29:34 cedric Exp $ */
d63 1
a63 1
	int tticket;			/* table ticket */
d169 1
a169 1
	    struct pfr_buffer *, int);
@


1.64
log
@Better parsing and -v support for tables:

  - remove the tableaddrs and tableaddr yacc production and reuse
    host_list instead.
  - produce better error messages.
  - do not load addresses from external file when it is not
    required (like with -R option).
  - store initializers in a new node_tinit linked list before
    putting them into the address buffer (see next point).
  - add a new print_tabledef() function, which makes "pfctl -nvf"
    print something useful for table definitions, which in turn
    makes it possible to write better regress tests (see first chunk
    of the diff) and bring table definition consistant with other
    parsed rules.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.63 2003/07/03 21:09:13 cedric Exp $ */
a191 1
#define PFCTL_FLAG_ALL		0x01
@


1.63
log
@Bye bye atexit(), bye bye globals...
The pfctl.c part will probably need some further improvements.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.62 2003/07/03 09:13:06 cedric Exp $ */
a69 1
	struct pfr_buffer *ab;		/* address buffer */
d128 9
d155 1
d168 1
a168 1
int	pfctl_define_table(char *, int, int, int, const char *, const char *,
d209 2
a210 1
int			 append_addr_not(struct pfr_buffer *, char *, int, int);
@


1.62
log
@This patch finally cleanup pfctl_table.c. No more global buffer,
and a couple of parsing functions moved to parse.y or pfctl_parser
where they belong.

I also took the opportunity to replace "void" functions with exit(1)
or err() inside by "int" functions, with the caller checking the
return value for errors (much cleaner and an old request from Theo)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.61 2003/05/19 20:21:53 henning Exp $ */
d63 2
a158 1
void	pfctl_begin_table(void);
d160 1
a160 2
	    struct pfr_buffer *);
void	pfctl_commit_table(void);
@


1.61
log
@reject invalid netmasks like 10.0.0.0/68, and fix up the netmask for
dynaddr rules after we know the address family

ok dhartmei@@, inspired by a session with bob
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.60 2003/05/10 00:45:24 henning Exp $ */
d68 1
d158 2
a159 3
void	pfctl_append_addr(char *, int, int);
void	pfctl_append_file(char *);
void	pfctl_define_table(char *, int, int, int, const char *, const char *);
d198 3
@


1.60
log
@support loading of anchors from within the main ruleset via
load anchor anchorname:rulesetname file /path/to/file

ok pb@@ dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.59 2003/04/30 12:30:27 cedric Exp $ */
d193 1
@


1.59
log
@Allow tables to be loaded into anchors.
Most pfctl table commands (excluding 'show' and 'flush') support the "-a"
modifier.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.58 2003/04/15 11:29:24 henning Exp $ */
d126 2
d140 1
@


1.58
log
@pass down the unparsed queue opts (struct node_queue_opt) to
print_altq/print_hfsc -> print_hfsc_opts and extract struct node_hfsc_sc
there for each service curve and pass those down to print_hfsc_sc. now
bandwidth specifications in the service curves are printed correct in the
case of a queue belonging to more than one interface/parent queue, the
parent queues having different bandwidths and the bandwith on teh service
curve beeing specified in percent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.57 2003/04/14 14:50:46 henning Exp $ */
d68 2
d156 1
a156 1
void	pfctl_define_table(char *, int, int, int);
@


1.57
log
@let print_altq and print_queue take a struct node_queue_bw parameter instead
of dintinct bw_percent
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.56 2003/04/13 20:41:37 henning Exp $ */
d146 2
a147 1
void	 print_altq(const struct pf_altq *, unsigned, struct node_queue_bw *);
d149 1
a149 1
	     int);
@


1.56
log
@new struct node_hfsc_opts for, surprise, hfsc options. needed because they
contain bandwidth specifications and we need to carry the unprocessed bw
specs around for quite some time until we can break them down to absolute
values.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.55 2003/04/13 20:16:06 henning Exp $ */
d145 4
@


1.55
log
@pass down the struct node_queue_opts from the altqif/queuespec yacc targets
to expand_altq/expand_queue -> eval_pfaltq/eval_pfqueue and
further down to the new eval_queue_opts() instead of evaluating them directly
in the yacc grammar.
this will be needed to process the hfsc options which can contain relative
bandwidth specifications, and we can't break them down to an absolute one
earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.54 2003/04/13 19:36:00 henning Exp $ */
d96 19
d120 1
a120 1
		struct hfsc_opts	hfsc_opts;
a121 5
};

struct node_queue_bw {
	u_int32_t	bw_absolute;
	u_int16_t	bw_percent;
@


1.54
log
@move the structs node_queue_bw and node_queue_opt to pfctl_parser.h.
let eval_pfqueue() and eval_pfaltq() take a pointer to a struct
node_queue_bw instead of two distince bw_absolute and bw_percent parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.53 2003/04/05 23:56:32 henning Exp $ */
d127 4
a130 2
int	eval_pfaltq(struct pfctl *, struct pf_altq *, struct node_queue_bw *);
int	eval_pfqueue(struct pfctl *, struct pf_altq *, struct node_queue_bw *);
@


1.53
log
@ease netmask handling a bit

input theo, ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.52 2003/04/03 15:52:24 cedric Exp $ */
d96 14
d127 2
a128 2
int	eval_pfaltq(struct pfctl *, struct pf_altq *, u_int32_t, u_int16_t);
int	eval_pfqueue(struct pfctl *, struct pf_altq *, u_int32_t, u_int16_t);
@


1.52
log
@Simplify pfctl printing code.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.51 2003/03/27 18:01:57 henning Exp $ */
d156 1
a156 1
struct node_host	*host(const char *, int);
@


1.51
log
@lotsa const char *
from David Hill <david at phobia.ms> a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.50 2003/03/07 12:55:37 henning Exp $ */
a108 1
void	print_filter(struct pf_rule *, int);
a110 3
void	print_nat(struct pf_rule *, int);
void	print_binat(struct pf_rule *, int);
void	print_rdr(struct pf_rule *, int);
@


1.50
log
@don't include debugging output, namely, the result of teh skip steps
calculation, in verbose output (pfctl -vvsr). Instead, use a new flag -g for
that.

result of a longer discussion with dhartmei@@ and jakob@@

ok cedric@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.49 2003/02/18 21:59:34 henning Exp $ */
d127 1
a127 1
	char *name;
d132 1
a132 1
	char *name;
@


1.49
log
@fix load option handling (-A, -N, -R) for options.
due to a bug in the loadopt check options were always loaded no matter which
loadopts where specified.
while beeing there, move the prints for that to where they belong, into the
appropriate pfctl_set_* functions, and thus only print when the options are
actually loaded.
fixes regress tests pfopt3, pfopt4, pfopt5 I added earlier.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.48 2003/02/16 14:04:34 henning Exp $ */
d45 1
@


1.48
log
@cosmetics
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.47 2003/02/03 14:51:36 cedric Exp $ */
d100 1
a100 1
int	pfctl_set_timeout(struct pfctl *, const char *, int);
@


1.47
log
@remove loadopt global definition and cleanup a bit.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.46 2003/02/03 13:40:45 henning Exp $ */
d116 2
a117 2
int	 eval_pfaltq(struct pfctl *, struct pf_altq *, u_int32_t, u_int16_t);
int	 eval_pfqueue(struct pfctl *, struct pf_altq *, u_int32_t, u_int16_t);
@


1.46
log
@fix a problem with queue definitions when load options (like -N etc) are
given; they used to check for their parent interface/queue even in this
case.

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.45 2003/02/02 23:22:07 henning Exp $ */
a153 1
extern int loadopt;
@


1.45
log
@there is no need to pass opts to parse_rules explicitely; it's passed as
part of the struct pfctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.44 2003/02/02 18:32:35 henning Exp $ */
d61 1
@


1.44
log
@const'ify params for the host stuff

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.43 2003/01/25 18:16:05 cedric Exp $ */
d104 1
a104 1
int	parse_rules(FILE *, struct pfctl *, int);
@


1.43
log
@Fix NOACTION with table statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.42 2003/01/25 16:33:19 cedric Exp $ */
d157 3
a159 3
struct node_host	*ifa_exists(char *);
struct node_host	*ifa_lookup(char *, enum pfctl_iflookup_mode);
struct node_host	*host(char *, int);
@


1.42
log
@Permit initialisation of a table content from a file in pf.conf.
Cleaning up of the table options parsing, more flexible.
idea+cleanup deraadt@@, ok dhartmei@@, pass all regress tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.41 2003/01/18 15:00:24 cedric Exp $ */
d121 1
a121 1
void	pfctl_define_table(char *, int, int);
@


1.41
log
@Cleanup PF_OPT_NOACTION with tables. No changes on current behaviour,
but do something useful when the user has no access to /dev/pf.
Tested on i386, sparc64.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.40 2003/01/14 21:58:12 henning Exp $ */
d120 1
@


1.40
log
@unified IP parser:
-move host(), set_ipmask and the ifa_* functions to pfctl_parser.[c|h]
-extend host() to handle /mask itself, plus minor adjustments
-use that in pfctl_table.c instead of coding the same shit again

discussed w/ cedric@@
ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.39 2003/01/09 10:40:44 cedric Exp $ */
d44 1
@


1.39
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.38 2003/01/04 00:01:34 deraadt Exp $ */
d67 26
d152 6
@


1.38
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.37 2002/12/22 14:19:29 dhartmei Exp $ */
d91 5
d122 1
d125 1
@


1.37
log
@Instead of inserting and removing rules at the top/bottom of the main
ruleset, make authpf manage its rules inside anchors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.36 2002/12/18 19:40:41 dhartmei Exp $ */
d87 3
@


1.36
log
@Store translation rule pointer in state entries, so pfctl -vsn can print
evaluation, packet, byte and state entry counters similar to -vsr. Helps
verify whether/how often translation rules are evaluated/matched.
ok frantzen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.35 2002/12/18 14:14:09 mcbride Exp $ */
d69 2
@


1.35
log
@Maintain separate pfioc_rule structures for each type of rule,
to prevent tickets from getting overwritten.

bug reported by dhartmei@@

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.34 2002/12/17 12:36:59 mcbride Exp $ */
d81 3
a83 3
void	print_nat(struct pf_rule *);
void	print_binat(struct pf_rule *);
void	print_rdr(struct pf_rule *);
@


1.34
log
@Match merge of pf_nat/pf_binat/pf_rdr structs into pf_rule

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.33 2002/12/05 14:10:45 henning Exp $ */
d62 1
a62 1
	struct pfioc_rule *prule;
@


1.33
log
@one step further to "program output is valid program input" and the related
extra regress testing opportunities (an excellent idea by markus@@).
only print rule numbers in case of pfctl -v -v; but not with pfctl -v.

ok markus@@ frantzen@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.32 2002/12/04 08:07:28 deraadt Exp $ */
d60 1
a60 1
	u_int16_t rule_nr;
a62 3
	struct pfioc_nat *pnat;
	struct pfioc_binat *pbinat;
	struct pfioc_rdr *prdr;
a67 3
int	pfctl_add_nat(struct pfctl *, struct pf_nat *);
int	pfctl_add_binat(struct pfctl *, struct pf_binat *);
int	pfctl_add_rdr(struct pfctl *, struct pf_rdr *);
d78 2
d81 3
a83 4
void	print_pool(struct pf_pool *, u_int16_t, u_int16_t, sa_family_t, int);
void	print_nat(struct pf_nat *);
void	print_binat(struct pf_binat *);
void	print_rdr(struct pf_rdr *);
@


1.32
log
@do not warn for unused variables except with -v -v; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.31 2002/11/30 13:53:15 mickey Exp $ */
d84 1
a84 1
void	print_rule(struct pf_rule *);
@


1.31
log
@move damn unmask() proto into place as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.30 2002/11/28 12:14:25 mcbride Exp $ */
d43 1
d81 1
a81 1
int	parse_rules(FILE *, struct pfctl *);
@


1.30
log
@- Adjust to match replacement of md5 with pf_hash
- Allow keys to be specified in hex (must be 128 bits, mainly to make
  pfctl -v output paresable by pfctl) or as a string. Randomly generate key
  if one is not specified.

Suggestions and fixes from camield@@

ok mickey@@ camield@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.28 2002/11/23 05:22:24 mcbride Exp $ */
a88 2

int	unmask(struct pf_addr *, sa_family_t);
@


1.29
log
@missing prototype, remember to use sa_family_t for af
@
text
@d84 1
a84 1
void	print_pool(struct pf_pool *, sa_family_t, int);
@


1.28
log
@code to support loading of pf rules with multiple redirection addresses
(in nat, rdr, route-to, dup-to and reply-to)

Syntax looks like this, see pf.conf(5) for details:

nat on wi0 proto { tcp, icmp } from any to 192.168.0.2 -> \
        192.168.0.16/29 source-hash random

rdr on wi0 proto { tcp } from any to 192.168.0.34 port 22 -> \
        { 192.168.0.8/31, 192.168.0.15 } port 22 round-robin

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.27 2002/11/18 22:49:15 henning Exp $ */
d84 1
@


1.27
log
@altq and pf merged

this isn't 100% done yet: the print_ stuff isn't finished, some features
will be added later, and there is no documetation yet, but committing now
enables a few more people to work on.

print_altq_node stuff hacked by Daniel at euroBSDcon; lotsa stuff from kjc,
debugging help also pb and camiel. lots of good ideas by theo.

"commit now" theo philipp daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.26 2002/10/25 10:40:45 camield Exp $ */
d60 1
@


1.26
log
@- more sa_family_t
- move unmask code to correct file
- whitespace

ok mcbride@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.25 2002/06/25 08:13:26 henning Exp $ */
d64 2
d72 1
d115 1
@


1.25
log
@move pfctl options -t, -m, -O and -l to pf.conf. These are set using the
"set" keyword. example rulefile:

set optimization aggressive
set timeout { tcp.closing 6, tcp.opening 6 }
set limit { states 1000, frags 1000 }
set loginterface wi0
pass out all keep state label "$nr:$srcaddr:$srcport:$dstaddr:$dstport"
block in all

fries@@ is working on an updated pf.conf(5)
discussed at c2k2 and on icb
ok dhartmei@@, kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.24 2002/06/11 06:12:15 kjell Exp $ */
d66 18
a83 18
int	 pfctl_add_rule(struct pfctl *, struct pf_rule *);
int	 pfctl_add_nat(struct pfctl *, struct pf_nat *);
int	 pfctl_add_binat(struct pfctl *, struct pf_binat *);
int	 pfctl_add_rdr(struct pfctl *, struct pf_rdr *);

int	 pfctl_set_timeout(struct pfctl *, const char *, int);
int	 pfctl_set_optimization(struct pfctl *, const char *);
int	 pfctl_set_limit(struct pfctl *, const char *, unsigned int);
int	 pfctl_set_logif(struct pfctl *, char *);

int	 parse_rules(FILE *, struct pfctl *);
int	 parse_flags(char *);

void	 print_rule(struct pf_rule *);
void	 print_nat(struct pf_nat *);
void	 print_binat(struct pf_binat *);
void	 print_rdr(struct pf_rdr *);
void	 print_status(struct pf_status *);
d85 1
a85 1
int	 unmask(struct pf_addr *, u_int8_t);
@


1.24
log
@Add -N and -R options. When used in conjunction with
pfctl -f <rulefile> they allow just the nat or filter rules to
be reloaded, respectively. The default (no flags) is to load everything.
If -N is specified, any existing filter rules are retained,
similarly for -R.

ok deraadt@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.23 2002/06/11 03:12:03 dhartmei Exp $ */
d71 5
d111 1
@


1.23
log
@Remove parse_nat() prototype, it's gone. Yes, authpf is broken at the
moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.22 2002/06/11 02:12:37 dhartmei Exp $ */
d102 4
@


1.22
log
@Make NAT proxy port range configurable per rule, for instance privileged
source ports can mapped to privileged proxy ports, or source port 500
to proxy port 500. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.21 2002/06/11 01:58:00 henning Exp $ */
a71 1
int	 parse_nat(FILE *, struct pfctl *);
@


1.21
log
@rework pfctl statistics display
move FCNT_NAMES from pfvar.h to pfctl_parser.h, only used by pfctl
some input by nick@@
ok frantzen@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.20 2002/06/08 21:09:59 dhartmei Exp $ */
d46 3
a54 1

@


1.20
log
@Change remaining read-only lookup tables to const, suggestion drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.19 2002/06/08 07:58:07 dhartmei Exp $ */
d45 8
@


1.19
log
@Make state timeouts configurable per rule, like

  pass in from any to any port www keep state (tcp.established 60)

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.18 2002/06/07 19:33:03 henning Exp $ */
d84 4
a87 4
struct icmptypeent	 *geticmptypebynumber(u_int8_t, u_int8_t);
struct icmptypeent	 *geticmptypebyname(char *, u_int8_t);
struct icmpcodeent	 *geticmpcodebynumber(u_int8_t, u_int8_t, u_int8_t);
struct icmpcodeent	 *geticmpcodebyname(u_long, char *, u_int8_t);
@


1.18
log
@allow using $srcaddr, $srcport, $dstaddr and $dstport in rule labels,
evaluated at parse time.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.17 2002/06/06 22:22:44 mickey Exp $ */
d88 7
@


1.17
log
@split out the pf_state printing functions to be used elsewhere, no functional change; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.16 2002/06/01 04:06:47 hugh Exp $ */
d70 2
@


1.16
log
@ECN flag support for pf. Committed in consultation with Daniel.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.15 2002/03/11 22:22:57 dhartmei Exp $ */
a68 1
void	 print_state(struct pf_state *, int);
a85 1
struct hostent		 *getpfhostname(const char *);
@


1.15
log
@Add -r to reverse lookup addresses when displaying states.
From John Kerbawy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.14 2002/02/27 18:11:45 dhartmei Exp $ */
d43 2
@


1.14
log
@Instead of printing useless @@0 rule numbers from pfctl -vR, increase a
counter. Helps debugging rule sets that are not loaded. Suggested by
John Kerbawy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.13 2002/01/09 11:30:53 dhartmei Exp $ */
d42 1
d81 5
a85 4
struct icmptypeent *geticmptypebynumber(u_int8_t, u_int8_t);
struct icmptypeent *geticmptypebyname(char *, u_int8_t);
struct icmpcodeent *geticmpcodebynumber(u_int8_t, u_int8_t, u_int8_t);
struct icmpcodeent *geticmpcodebyname(u_long, char *, u_int8_t);
@


1.13
log
@Add labels to rules. These are arbitrary names (not to be confused with
tags that will be used to tag packets later on). Add pfctl -z to clear
per-rule counters. Add pfctl -s labels to output per-rule counters in
terse format and only for rules that have labels. Suggested by
Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.12 2001/10/04 21:54:15 dhartmei Exp $ */
d46 1
@


1.12
log
@Honour -v flag when printing states, print only one line per state when
non-verbose. Suggested by gwyllion@@ace.ulyssis.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.11 2001/10/01 17:58:16 markus Exp $ */
d41 1
@


1.11
log
@print variable asignments only if -v is given. ok dhartmei/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.10 2001/09/15 03:54:40 frantzen Exp $ */
d64 1
a64 1
void	 print_state(struct pf_state *);
@


1.10
log
@IPv6 support from Ryan McBride (mcbride@@countersiege.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.9 2001/09/06 18:05:46 jasoni Exp $ */
d35 6
@


1.9
log
@1:1 bidrectional NAT (binat); ok dhartmei@@ and frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.8 2001/08/23 04:10:51 deraadt Exp $ */
d72 4
a75 4
struct icmptypeent *geticmptypebynumber(u_int8_t);
struct icmptypeent *geticmptypebyname(char *);
struct icmpcodeent *geticmpcodebynumber(u_int8_t, u_int8_t);
struct icmpcodeent *geticmpcodebyname(u_long, char *);
@


1.8
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.7 2001/08/11 09:54:59 deraadt Exp $ */
d41 1
d47 1
d56 1
@


1.7
log
@\+\n support, and spit out cc-style error messages.  the parser's line
counting is lex dependent, and will need to be tweaked
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.6 2001/07/16 21:09:38 markus Exp $ */
d4 1
a4 1
 * Copyright (c) 2001, Daniel Hartmeier
d12 1
a12 1
 *      notice, this list of conditions and the following disclaimer. 
d16 1
a16 1
 *      with the distribution. 
@


1.6
log
@add a yacc parser for pf.conf and nat.conf, with help from mickey@@,
plus: -n now turns off all operations, and just parses the conf files
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.5 2001/06/25 18:02:44 dhartmei Exp $ */
d52 5
a56 5
void	 print_rule (struct pf_rule *);
void	 print_nat (struct pf_nat *);
void	 print_rdr (struct pf_rdr *);
void	 print_state (struct pf_state *);
void	 print_status (struct pf_status *);
d69 4
a72 4
struct icmptypeent * geticmptypebynumber(u_int8_t);
struct icmptypeent * geticmptypebyname(char *);
struct icmpcodeent * geticmpcodebynumber(u_int8_t, u_int8_t);
struct icmpcodeent * geticmpcodebyname(u_long, char *);
@


1.5
log
@include guard fix; smat@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.4 2001/06/25 09:44:33 deraadt Exp $ */
d36 16
a51 4
char	*next_line (char **);
int	 parse_rule (int, char *, struct pf_rule *);
int	 parse_nat (int, char *, struct pf_nat *);
int	 parse_rdr (int, char *, struct pf_rdr *);
d57 16
@


1.4
log
@catch up to Art changes in the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.3 2001/06/24 23:16:36 deraadt Exp $ */
d33 2
a34 2
#ifndef _PFM_PARSER_H_
#define _PFM_PARSER_H_
d46 1
a46 1
#endif /* _PFM_PARSER_H_ */
@


1.3
log
@match changes in header files
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.2 2001/06/24 21:40:51 dhartmei Exp $ */
d37 8
a44 8
int	 parse_rule (int, char *, struct rule *);
int	 parse_nat (int, char *, struct nat *);
int	 parse_rdr (int, char *, struct rdr *);
void	 print_rule (struct rule *);
void	 print_nat (struct nat *);
void	 print_rdr (struct rdr *);
void	 print_state (struct state *);
void	 print_status (struct status *);
@


1.2
log
@REGENTS -> COPYRIGHT HOLDERS
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.h,v 1.1 2001/06/24 21:04:16 kjell Exp $ */
a34 2

#include <net/pfvar.h>
@


1.1
log
@Move and rename packet filter userland.
grr. CVS: making easy things difficult, and directory operations impossible.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfm_parser.h,v 1.1 2001/06/24 20:18:12 kjell Exp $ */
d22 1
a22 1
 * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
@

